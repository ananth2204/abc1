{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "SBGOLOB", "INMTNODE": "A", "INMTUID": "A", "INMFTIME": "20201220011625000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 9934834, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 5600, "INMRECFM": "FB", "INMDIR": 43, "INMDSNAM": "CBT.V500.FILE270.PDS", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 9934834, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 9934834, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"CBT.V500.FILE270.PDS": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 5600, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3340, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "200354", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\xbe'", "DS1LSTAR": "b'\\x00\\x9d\\x01'", "DS1TRBAL": "b'\\xe2\\xfa'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xa0\\x00\\x04\\x9a\\xc0\\xd8'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xa0\\x00\\x04\\x9a\\xc0\\xd8'", "b'X\\xf4\\xfd\\xd0\\x00\\x00\\x01\\xe0\\x00\\x07\\x01\\xea\\x00\\x0e\\x00\\x9e'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$$PHONE": {"ttr": 516, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00\\x00\\x00\\x94\\x05?\\x01\\x003\\x9f\\x178\\x00\\t\\x00\\x07\\x00\\x00\\xe6\\xe2\\xc2\\xc7@@@@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "1994-02-22T00:00:00", "modifydate": "2000-12-04T17:38:00", "lines": 9, "newlines": 7, "modlines": 0, "user": "WSBG"}, "text": "Here are some relevant phone numbers for contributors to this file:\n  (Courtesy of Gilbert Saint-Flour    973-992-9318  gsf@ibm.net)\n\n    Howard Glastetter      (360) ???-???? Weyerhaeuser in Tacoma, WA\n          Glastetter, Howard <howard.glastetter@WEYERHAEUSER.COM>\n    Kermit Kiser           (360) 902-3119\n    Larry Lucke            (360) 902-3122\n    Jeff Sprehn            (360) 586-4672\n    Gordon J. Schillinger  (360) 426-4433  x4611 Dept of Correction\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$CHGLOG": {"ttr": 518, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x05\\x00\\x00\\x00\\x88\\x00\\x7f\\x00\\x98)\\x9f\\x12D\\x01\\x13\\x01\\x0b\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf2\\xf7\\xf0@@@'", "ispf": {"version": "01.05", "flags": 0, "createdate": "1988-01-07T00:00:00", "modifydate": "1998-10-26T12:44:00", "lines": 275, "newlines": 267, "modlines": 0, "user": "FILE270"}, "text": "*\n*  $CHGLOG :  Change log member for     \"WASHMODS\" ;\n*      Washington Dept. of Information Services local mods tape.\n*\n*                   Contact - Kermit Kiser (206) 902-3119\n*                             WASHINGTON DEPT. OF INFORMATION SERVICES\n*                             25 State Office Bldg Two, OB-01\n*                             Olympia, Washington 98504\n*\n*\n* CBT Update                                ------------  Date 10/26/98\n*\n*       SUPRASM  - added new sample JCL to assemble SUPRNAME utility\n*       SUPRJCL  - added new sample JCL to execute SUPRNAME utility\n*       SUPRNAME - PARSEKMD should be PARSKMD pickup correct macro\n*       KMDPARS  - fixed to pickup supplied register equates\n*       OPERSCAN - fixed to pickup supplied register equates\n*\n* DIS Mods Tape - Version 8.0               ------------  Date 10/17/89\n*\n*       PANLEXIT - deleted as SPFEXEC is a more powerful replacement.\n*\n*       CONCAT   - (AKA CONCATEM) updated to V2.0 which is REENTRANT.\n*\n*       SETVAR   - updated to 2.2, now defaults to TSOE assemble. Refs\n*                  to IKJCT433 are now WXTRN. Too many phone calls!\n*\n*       FILEINFO - updated to V2.0 which is REENTRANT.\n*\n*       HOTKEYS -  updated HOTKEYS to have options for using\n*                  FILEAID and IOF as some installations may not have\n*                  these critical packages!\n*\n*       STACK FAST - updated STACK command to version 2.0 which has the\n*                  \"FAST\" operand. Placing this at the beginning of a\n*                  CLIST may improve performance by 50% or more. It runs\n*                  most CLISTs and eliminates the TMP ATTACH overhead\n*                  for TSO commands. Not tested with 1.4 or 2.x TSOs.\n*\n*       VPSSSEPR - Deleted. VPS 5.0 has an 80 column separator routine.\n*\n*       EDITNEW  - Finally, after many requests, I think we have\n*       EDITAPP    identified most of the pieces of the \"better edit\"\n*                  interface which has been often requested by those\n*                  who once worked at this installation. See the\n*                  EDIT$ member for details on this \"object-action\"\n*                  interface we developed years ago.\n*\n*\n* DIS   Mods Tape - Version 7.3             ------------  Date 05/05/89\n*\n*       HOTKEYS  - updated clists to add FLIST option which allows\n*                  placing cursor in a dataset name and requesting\n*                  all datasets which match name to cursor postion.\n*\n*       ISPCDSN  - updated to allow extraction of entire screen\n*                  image and determine precise cursor positioning.\n*                  See HOTKEY update for example of capabilities.\n*\n* DIS   Mods Tape - Version 7.2             ------------  Date 04/19/88\n*\n*       ENTERR   - macro updated to fix addressability problem when\n*                  assembling CONCATem command - thanks to Tom Wenner\n*                  of Maritime Publishing for reporting this one.\n*\n* DIS   Mods Tape - Version 7.1             ------------  Date 03/23/88\n*\n*       ISPCDSN  - updated to fix a problem with extracting dataset\n*                  names in ISPF message lines and to better handle\n*                  DDNAMEs and dataset names in CLIST code. (HOTKEYS)\n*\n*       SMPEIOF  - updated to fix a problem with new SMPE users.\n*\n*       LOGKILLR - added by request of Donald Daley at The Aerospace\n*                  Corporation. We used this to kill TSO LOGON\n*                  address spaces if prompting did not complete\n*                  within five minutes. We don't use it now.\n*                  I don't know how this will work with XA. See LOGKILL$\n*\n* WDPSC Mods Tape - Version 7               ------------  Date 12/21/87\n*\n*       The following three utilities were added at the request of the\n*                  University of Washington:\n*          BLKING   - added CLIST utility that indicates optimum\n*                  blksize and required space for allocation of\n*                  disk files.\n*\n*          PFKEYCHG - added program that determines which\n*                  PF Key has been pressed or determines\n*                  which function (such as END, RETURN, UP,\n*                  DOWN, LEFT, RIGHT, etc) has been requested.\n*\n*          PFKEYRST - added program that is used with\n*                  Dialog Manager to \"restore\" the users PF Key\n*                  definitions to their original values after\n*                  the program PFKEYCHG modified them.\n*\n*       NEWISPF  - updated NEWISPF, SPFEXEC, and WDPSCXS to fix a\n*                  problem due to a TSOE change in the stack format.\n*                  NEWISPF and SPFEXEC do not need to be linked with\n*                  ISRPCP (PDF) anymore - they will LOAD and CALL it.\n*\n*       SCXSCAN$ - added the usermod I use to install the \"X\" command\n*                  exit facility under TSOE (links into IKJTSLAR).\n*\n*\n* WDPSC Mods Tape - Version 6.1             ------------  Date 11/03/87\n*\n*       ADMUSP6B - added new PL1 program to create GDDM graphs from\n*                  a batch job. Reads same data as ADMUSP6 and calls\n*                  PGF ICU to create charts.\n*\n*       INDEX    - updated to allow right-to-left searching.\n*                  Note: TSOE R3 &SYSINDEX does substring searching\n*                   if you need that capability.\n*\n*       TRANS    - new TSO command which translates characters in CLIST\n*                  variables like REXX TRANSLATE command. We will try\n*                  to make this into a builtin function if we ever get\n*                  TSOE release 4...\n*\n*       WHATDDN  - new TSO command which returns the DDNAME associated\n*                  with a given dataset name. Written to allow HOTKEYS\n*                  to support VIO and uncataloged datasets.\n*\n*       HOTKEYS  - added support for FILEAID and IOF APPLIDS and\n*                  support for VIO datasets via the WHATDDN command!\n*\n*       XEQ      - added modified version of XEQ command from CBT tape\n*                  FILE296 to support TASKDD operand and SQSTRING.\n*\n*       SPFEXEC  - updated to fix problems with ACF2 EXEC and FOCUS.\n*                  Note: Although I have not yet installed ISPF 2.3,\n*                   I have read the install manual and those 'slick'\n*                   new user exits do not allow any ISPF functions!\n*                   SPFEXEC is much more powerful as a panel exit.\n*\n*       SHOW     - updated for JES 2.1.5 level (& SHOWFJM).\n*\n*       CTLGTMS  - added CTLGTMS# job to check catalog against TMS TMC\n*                  for dead entries per request of Stan Ward at\n*                  Tufts University. Also CATBYVOL updated to use\n*                  DYNALLOC to verify disk dataset status.\n*\n*       DOCSYS   - added missing source for SCAN4HIT and TBLH10 (msg)\n*                  per Dean Davis at City of Sacramento.\n*\n*\n* WDPSC Mods Tape - Version 6               ------------  Date 05/05/87\n*\n*       DOCSYS   - added our online document retrieval system per\n*                  several requests.\n*\n*       WPPSS    - added several utilities at request of Washington\n*                  Public Power Supply System: ALLOCGDG,CNV2GREG,INTRDR,\n*                  RJETRANS,JCLXREF,LOADXREF,MEMSTAT,NEXTGEN,DSN,\n*                  EXPANDIR,LASTOPEN,SHOW,UNNUM,WHOISI\n*\n*       OPT      - added ISR@PRIF panel for nesting any ISPF option.\n*\n*       RTSO     - added Jared's ISPF TSO option interface.\n*\n*       SPFEXEC  - added FOCUS/SAS/MEGACALC, etc. ISPF interface.\n*\n*       SMPEIOF  - added SMPE to IOF interface.(see STATUS clist)\n*\n*       INDEX    - added CLIST string function.\n*\n*       ISPCDSN  - added ISPF dialog program to extract a dataset name\n*                  from cursor location on the last displayed screen.\n*\n*       HOTKEYS  - new application to set function keys so you can put\n*                  cursor on a dataset name on any ISPF screen and hit\n*                  a function key to process the dataset with 3.1, PDS,\n*                  URZAP, BROWSE, EDIT, etc. No more rekeying DSNs!!!\n*                  Also supports ddnames but no other VIO names yet.\n*\n*       INMRZ01  - added TSOE RECEIVE command ACF2 interface.\n*\n*       deleted  - RLSE clist. RLSE command in CBT file 300 better.\n*\n* WDPSC Mods Tape - Version 5               ------------  Date 11/20/86\n*\n*       UCBMAP   - added XA version of command from CBT file 301.\n*\n*       SMF64EXT - added Howard's VSAM/CACHE activity analyzer.\n*\n*       VPSSSEPR - added VPS 80 column separator exit per Bill Smith.\n*\n*       SMF74MOD - added program to merge device activity from multiple CPUs\n*\n*       CHKBLOCK - added program to scan JCL for bad blocksizes\n*\n*       ENCRYPT/DECRYPT - ISPF edit macro clists and CRY/R050A90 pgms added\n*\n*       LISTMEMS  - updated to fix minor program bug\n*\n*       CLRSPFIO  - updated to allow parms for STFSMODE,STLINENO opts\n*\n*       ISPF macros- TSO versions of CUT/PASTE, CENTER, SHOWFLOW, COM\n*\n*       LOCATE    updated to support STEPLIB,ISPLLIB,LPALST,multi-mems\n*\n*       STACK     updated to M5 level (alternate operand spellings)\n*\n*       $CHGLOG   moved this change log to separate member $CHGLOG\n*\n*       PANLEXIT  added ISPF dialog interface to allow exits from\n*                 ISPF display panels. This is one of our best mods!\n*\n* WDPSC Mods Tape - Version 4.1             ------------  Date 4/18/86\n*\n*       UCC7MOD  added note concerning label 'RESTART'.\n*\n*       SPFEOPT  added missing clist (not on version 4 sent to CBT)\n*\n*       SETVAR#  add some JCL to link SETVAR for a non-TSOE system\n*                note->setting CLIST variables is not a supported IBM\n*                interface prior to TSOE and SETVAR may have to be\n*                modified by a competent TSO systems programmer.!\n*                JCL requested by Kelly J Reeb.\n*\n* WDPSC Mods Tape - Version 4               ------------  Date 4/10/86\n*\n*   We have XA in production now with TSOE 2.1 and all mods converted.\n*\n*       UCC7MOD  added our UCC7 virtual terminal mod per T. Carroll request.\n*\n*       ISPF     added our command table per Bill Smith request.\n*                also added ISR@PRIM,KMENU,PRE/POSTDIAL,SPFBATU...\n*\n*       MISC     added some new utilities : COMMANDR,SETRC,WTOPARM\n*                      SPFPRINT,NEWMWILE,LOCATE(XA),CHKTODAY\n*\n*       STACK    modified to fix an abend 001 in batch\n*\n*       SPFCATNV added new functions and new help panel (SPFCATH3)\n*\n*       SCXSCAN  updated for TSOE/XA\n*\n*       GDDM     all components of our GDDM interface added per DOT request.\n*\n*       DOCS     a new unloaded library was added for selected documents.\n*\n*       SETVAR   modified to use IKJCT441 interface for TSOE.\n*\n*       CONCATEM updated to not steal previous allocations and to\n*                fix 0C4 at instruction following label BASEREG2 (V1.2)\n*\n*                Added an alias of DATASET to the keyword DSNAME.\n*                Added a default of ACTCODE(A) if the ACTCODE keyword\n*                     parameter is not supplied.\n*                (Ver 1.3)\n*\n*       FILEATTR updated to pass back the volume serial number of a\n*                catalogued tape volume.\n*\n*       LISTMEMS updated to accept a PARM which will allow subsetting\n*                the output file based upon a PARM mask value.\n*                example, PARM='MASK=ABC**999' will output only those\n*                member names beginning with 'ABC', followed by any two\n*                characters, and then followed by '999'.\n*\n*\n* WDPSC Mods Tape - Version 3               ------------  Date 6/28/84\n*                               First version sent to CBT\n*\n*     The purpose of this tape is to transfer some of WDPSC's local\n*   utilities. All this stuff works here, but we don't guarantee it\n*   to work anywhere else. Some programs may need modification for\n*   an installation. Some are good only as \"HOWTO\" samples.\n*\n*     This tape contains the WDPSC programs which were released in\n*   CBT files 270-274. Two of those programs, named FTL and KOMM, have\n*   been modified and the latest versions are on this tape.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$DOC": {"ttr": 523, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x88\\x00\\x7f\\x00\\x94\\x05O\\x11T\\x02*\\x02*\\x00\\x00\\xe2\\xc2\\xc7\\xc3\\xe2\\xc3@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1988-01-07T00:00:00", "modifydate": "1994-02-23T11:54:00", "lines": 554, "newlines": 554, "modlines": 0, "user": "SBGCSC"}, "text": "*\n*  $DOC :  Documentation member for   \"WASHMODS\" ;\n*       Washington Dept. of Information Services local mods tape.\n*\n*                   Contact - Kermit Kiser (206) 902-3119\n*                             WASHINGTON DEPT. OF INFORMATION SERVICES\n*                             25 State Office Bldg Two, OB-01\n*                             Olympia, Washington 98504-2452\n*\n**** Note: The change history log has been moved to member $CHGLOG.\n*\n************************************************************************\n* DIS   Mods Tape - Version 8.0            ------------  Date 10/17/89\n************************************************************************\n*\n*     The purpose of this tape is to transfer some of DIS's local\n*   utilities. All this stuff works here, but we don't guarantee it\n*   to work anywhere else. Some programs may need modification for\n*   an installation. Some are good only as \"HOWTO\" samples.\n*\n*     This tape contains the DIS programs which were released in\n*   CBT files 270-274. Two of those programs, named FTL and KOMM, have\n*   been modified and the latest versions are on this tape.\n*\n*     Many of the TSO commands use the SETVAR subroutine.\n*   You may need to assemble SETVAR before these commands will work.\n*\n*     If a utility has documentation which is maintained separately,\n*   the document may be in the source PDS with a similiar name ending\n*   with the \"$\" character. A separate library for documents has\n*   been added containing many documents from the DOCSYS system- it\n*   is unloaded to member DOCLIB in this dataset.\n*\n*     If a utility has a sample JCL stream maintained separately,\n*   the JCL is in the source PDS with a similiar name but ending\n*   with the \"#\" character.\n*\n************************************************************************\n******** Tape loading information :     ********************************\n************************************************************************\n*\n* The tape is 1600 BPI NON-LABELED, with two files which are IEBCOPY\n* unloaded partitioned datasets.\n*         FILE ONE   - SOURCE CODE FOR OUR MODS.   (11 CYLS ON A 3380)\n*         FILE TWO   - LOAD Library for convenience (2 CYLs ON A 3380)\n*\n* To create the necessary MACLIB, CLIST, PROCLIB, etc libraries after\n* loading the source library from this tape:\n*\n*      Modify and submit either member REDIST or REDISTI which are in\n*      this library.  (Use REDIST if program PDSLOAD from the CBT tape\n*      is available, else use job REDISTI.)  REDIST or REDISTI will\n*      create the MACLIB, CLIST, PROCLIB, PANELS, SKELS, MESSAGES, TEXT,\n*      and PARM libraries from the appropriate members in this library.\n*      (Note: I have included PDSLOAD in the LOAD library on file 2\n*             of the tape in case you did not get it off the CBT tape.)\n*\n******** NOTE: CLISTs should be copied to a VB dataset after reloading.\n*             (Some have numbers in cols 1-8 and lines > 80 chars long.)\n*\n******** NOTE: The INDEXES library must be copied to a dataset with an\n*             LRECL of 200 before the DOCSYS system will work.\n*\n* Job MERGEJCL was used to unload libs into this one. Job EXPORT does\n* IEBCOPY unload of source and load libs onto a tape. IMPORT loads them.\n*\n************************************************************************\n* Summary of items included on this tape (not neccessarily complete):\n************************************************************************\n*\n*  NAME       TYPE      DESCRIPTION\n*  ________   ________  _________________________________________\n*\n*  $CHGLOG    Document  Log of changes and additions to the mods file.\n*\n*  $DOC       Document  You are reading it.\n*\n*  ALLOCGDG   PROGRAM   Dynamically allocate a GDG dataset to a DDNAME\n*                       based on relative generation number (because\n*                       TSO ALLOC will not do it!).\n*\n*  ALLOCMEM   PROGRAM   Dynamically allocate a partitioned dataset and\n*                       its member  to  a  given DDNAME  from  a  high\n*                       level language program.\n*\n*  CATBYVOL   PROGRAM   Checks IDCAMS uncatalog cards created by\n*                       VSAMSCAN program against volumes to find\n*                       NVSAM datasets which do not exist. See job in\n*                       CATBYVO#. I think DYL260 step is not needed.\n*\n*  CHKBLOCK   Program   Batch program to scan JCL or PROCS and report\n*                       on output datasets not efficiently blocked.\n*                       Sample JCL in CHKBLOC# will scan a library.\n*\n*  CHKTODAY   Program   Batch program to check for existence and\n*                       currency of a dataset. Sets a return code.\n*                       We use so that only the first caller of our\n*                       daily volume report process on any day does\n*                       the extensive analysis of all volumes.\n*\n*  CLIB       CLIST     Allocate a private CLIST library for\n*                       implicit CLIST execution without removing\n*                       previously allocated CLIST libraries.\n*                       Uses command CONCATEM.\n*\n*  CLRSPFIO   PROGRAM   CAN BE CALLED DIRECTLY OR LINKED TO\n*                       DYNAMICALLY VIA THE ISPEXEC SELECT\n*                       PGM(CLRSPFIO) TO TELL SPF TO IGNORE ANY\n*                       NON-SPF IO WHICH MAY HAVE TAKEN PLACE IN\n*                       THE DIALOG. Now allows parm options for\n*                       more complex requirements. The following\n*                       sequence killed the screen overflow when\n*                       exiting RESOLVE console mode to ISPF:\n*                        ISPEXEC SELECT PGM(CLRSPFIO) PARM(OFF)\n*                        ISPEXEC SELECT PGM(CLRSPFIO) PARM(INIT)\n*                        ISPEXEC SELECT PGM(CLRSPFIO) PARM(NORM)\n*\n*  CMDOUT     CLIST     Utility clist used by CLISTS and DIALOGS\n*                       to allocate and free work files.\n*                       Uses commands IFALC and FILEINFO.\n*\n*  CNTLCRT    PROGRAM   Can be called by CLISTS to issue CNTL or\n*                       FULLSCR TPUT messages.\n*\n*  CNV2GREG   PROGRAM   THIS IS A SUBROUTINE WHICH WILL RETURN A\n*                       FORMATTED GREGORIAN DATE GIVEN A STANDARD DATE,\n*                       JULIAN DATE OR SERIAL DATE\n*\n*  COMMANDR   PROGRAM   Authorized program to take a command\n*                       from the parm field and issue it via SVC 34.\n*\n*  CONCATEM   TSO CMD   ALLOCATE OR DEALLOCATE, CONCATENATE OR\n*  (CONCAT)             DECONCATENATE THE GIVEN DATASET TO THE\n*                       GIVEN DDNAME. IN THE CASE OF\n*                       CONCATENATION, PLACE THE GIVEN DATASET\n*                       \"AT THE TOP OF THE STACK\" OF ALL\n*                       DATASETS CONCATENATED TO THAT DDNAME.\n*\n*  CRY        Program   ISPF edit macro to encrypt and decrypt\n*                       data by calling R050A90 pgm from CBT tape.\n*                       Invoked by ENCRYPT & DECRYPT CLIST macros.\n*\n*  CTLGTMS#   JCL       Checks IDCAMS uncatalog cards created by\n*                       VSAMSCAN program against TMS TMC to find\n*                       NVSAM datasets which do not exist. IF DYL260\n*                       is not available, some conversion is needed.\n*\n*  DATECONV   TSO CMD   ACCEPT A STANDARD, JULIAN, OR SERIAL\n*                       DATE AND THEN CONVERT IT TO THE OTHER\n*                       TWO.\n*\n*  DDNTODSN   PROGRAM   Subroutine called by programs to return\n*                       DSNAME and VOLSER based on DDNAME passed.\n*\n*  DEVTYPE    TSO CMD   DETERMINE DEVICE TYPE GIVEN VOLUME\n*                       SERIAL NUMBER.\n*\n*  DOCSYS     .......   This is an ISPF dialog system for online\n*                       management and retrieval of documents. It\n*                       uses many of the other utilities on this tape.\n*                       See member DOCSYS$ for more details.\n*\n*  DSN        CLIST &   display dataset ENQs via DSNQ cmd, a version\n*             TSO CMD   of DENQ (see ENQ1DSN,ENQ1LOAD,ENQ2LOAD source).\n*                       These are XA versions with GCSCAN support.\n*\n*  DSNTAB     PROGRAM   Subroutine to pass back list of all DSNAMEs\n*                       concatenated to a given DDNAME.\n*\n*  DUMPVOL    PROGRAM   A sample program which reads a list of volumes\n*                       and builds a job to dump (FDR) only those\n*                       volumes which are currently mounted. No more\n*                       does Duane have to come in at 3AM because some\n*                       volumes are not mounted.\n*\n*  DYNALLOC   PROGRAM   Subroutine to dynamically allocate a given\n*                       dataset to a given DDNAME.\n*\n*  EDITNEW    DIALOG    ISPF/PDF replacement EDIT (option 2) dialogs.\n*  EDITAPP              Allows saving lists of datasets to select from\n*                       for editing or browseing. See EDIT$ for details.\n*\n*  FILEATTR   PROGRAM   OBTAIN VOLUME SERIAL NUMBER, LRECL,\n*                       BLKSIZE, DSORG, RECORD FORMAT, AND\n*                       DEVICE TYPE OF DATASET GIVEN THE DATASET\n*                       NAME (AND VOLUME SERIAL NUMBER IF NOT\n*                       CATALOGED) FROM A HIGH LEVEL LANGUAGE PGM.\n*\n*  FILEINFO   TSO CMD   RETURN INFO TO A CLIST SUCH AS LRECL,\n*                       BLKSIZE, RECFM, DSORG, VOLSER, ETC.\n*\n*  FILSPACE   PROGRAM   Subroutine that accepts a dataset name and\n*                       volume serial number and returns the number of\n*                       used extents and the number of used tracks.\n*\n*  FINDMEM    PROGRAM   DETERMINE WHETHER A SPECIFIED MEMBER OF\n*                       A PDS EXISTS OR NOT.\n*\n*  FINDTTR    PROGRAM   CALLED BY THE FINDTTR CLIST TO SEARCH A PDS FOR\n*                       A GIVEN STRING. THE TTR OF ALL BLOCKS CONTAINING\n*                       THE STRING IS DISPLAYED WHETHER IN\n*                       DIRECTORY, MEMBERS, GAS, OR BEYOND DS1LSTAR.\n*\n*  FIREUP     CLIST     ALLOCATE USER SPF DIALOG MANAGER\n*                       LIBRARIES AHEAD OF THE SPF PROGRAM\n*                       DEVELOPMENT FACILITY LIBRARIES AND/OR TO\n*                       ALLOCATE LIBRARIES TO DIALOG MANAGER\n*                       DDNAMES NOT ALREADY ALLOCATED.\n*\n*  FTL        PROGRAM   IEBGENER replacement for copying files.\n*                       Handles multiple files, changing DCB\n*                       characteristics, most file types.\n*\n*  GDDM       Misc.     Our interface to GDDM and PGF utilities.\n*                       Panels - GDDM, GDDMR3H\n*                       CLISTS - CHART,IMD,ISSE,LPQ,VSSE\n*                       Loadmods- IFALC,DATASTAT,KOMM,DEVTYPE,FILEINFO\n*                         NEWWAIT,ADMUSP6,LISTMEMS,LPRTQ,PROGDQUE\n*                       Source - DATASTAT,ADMUSP6,ADMUSP6O,LPRTQ2,PROGDQUE\n*                       DOCS - CHART,GDDM,ISSE,SAMPSYMS,VSSE\n*                       JCL - PROGDQ#\n*              note:    ADMUSP6 is enhanced IBM sample pgm to load\n*                       data into ICU. PROGDQUE builds GDDM queue.\n*                       LPRTQ displays contents of GDDM queue.\n*                       ADMUSP6B is batch chart utility.\n*\n*  GETMY      TSO CMD   Sample command for returning user/system\n*                       data to CLIST variables. Some installation\n*                       sensitive code, but a good starting place!\n*\n*  HEXTRAN    PROGRAM   TRANSLATE DATA FROM CHARACTER CODED\n*                       HEXADECIMAL TO TRUE HEXADECIMAL OR VICE\n*                       VERSA.\n*\n*  HOSEDOWN   CLIST     DEALLOCATE USER SPF DIALOG MANAGER\n*                       LIBRARIES (UNDO WHAT A PREVIOUS FIREUP\n*                       DID).\n*\n*  HOTKEYS    CLISTs    Sets PFKs to call HOTKEY clist as nested\n*  HOTKEY               ISPF dialog. HOTKEY clist extracts dataset\n*                       name (see ISPCDSN program) at cursor location\n*                       and calls the requested application (PDS cmd,\n*                       BROWSE, EDIT, etc.) passing the dataset name!\n*                       Also supports ddnames and VIO dsnames.          .\n*\n*  IFALC      TSO CMD   Tests whether a given DDNAME or DSNAME\n*                       is currently allocated to the user.\n*\n*  IFCAT      TSO CMD   Tests whether a given DSNAME\n*                       is cataloged. FILEINFO gives better data.\n*\n*  IKJUPDT    PROGRAM   Subroutine to convert calls to IKJUPDT\n*                       into LINK to program SETVAR. We used to link IBM\n*                       IKJUPDT (IKJCT433) directly with TSO commands in\n*                       order to put data into CLIST variables. This\n*                       technique is much more maintainable!.\n*\n*  INDEX      program   to scan a string for a delimiter and set\n*                       a return code based on its location -\n*                       used by HOTKEYS clist. Sets rc=0 if not found.\n*\n*  INMRZ01    PROGRAM   TSOE RECEIVE command exit. Interfaces with ACF2\n*                       to control userid access and allow batch receive\n*                       Modify the spool maintenence job check section\n*                       for your installation.\n*\n*  INTRDR     PROGRAM   THIS PROGRAM WILL ACCEPT A DDNAME PASSED TO IT\n*                       IN THE PARAMETER LIST AND THEN DYNAMICALLY\n*                       ALLOCATE THE INTERNAL READER TO THAT DDNAME\n*\n*  ISPCDSN    program   Fantastic program to extract a dataset name\n*                       from the last displayed panel if the cursor was\n*                       placed anywhere on a dataset name and put it in\n*                       an ISPF variable! Please don't tell IBM about\n*                       this one - it uses some internal ISPF pointers\n*                       that we aren't supposed to know about!\n*\n*  ISPCMDS    TABLE     ISPF command table we use. Allows a dialog or\n*                       panel to override commands, map PFKS, activate\n*                       SCROLL keys, etc by just setting a function\n*                       variable. Effect is local and does not screw up\n*                       your split screens. Also has RTSO, OPT, BR, ED\n*                       command support for nesting functions.\n*\n*  ISPF       misc      ISR@PRIM,KMENU,SPFBATU... Various ISPF stuff\n*                       to show how we hook it all together here.\n*                       Trace invisible option 'K' to find it.\n*\n*  ISPFmacs   CLISTs    CUT/PASTE, CENTER, SHOWFLOW, COM are ISPF edit\n*                       macros. Some converted from IBM diskette for TSO\n*                       Sorry, no docs available, but some HELP panels.\n*                       (CUTHELP,PASTEHLP)\n*\n*  JCLXREF    PROC      This PROCEDURE  reads a procedure library\n*                       and/or job streams and outputs up to six\n*                       reports.  Cross reference programs and\n*                       dataset names  with PROCEDURE names and their\n*                       step names. USES DYL260.\n*\n*  JTOSCONV   PROGRAM   CONVERT JULIAN DATES OF THE FORM YYDDD\n*                       TO STANDARD (MMDDYY) AFTER DATE\n*                       VALIDATION.\n*\n*  KOMM       TSO CMD   Command to do simple 3270 IO from a CLIST,\n*                       such as clear the screen or format fields.\n*\n*  LASTLINK   CLIST     DISPLAY INFORMATION ABOUT THE LAST TIME\n*                       A COBOL OR ASSEMBLER PROGRAM WAS\n*                       COMPILED AND LINKED.\n*\n*  LISTMEMS   PROGRAM   Given the name of a  partitioned data set,\n*                       produce an output file whose records  contain\n*                       the names of the members of that PDS (one\n*                       record per member).\n*\n*  LOADXREF   PROC      Cross  reference calling  programs to  called\n*                       program and vice versa. (Uses SHIFT90, a 90\n*                       degree print program. If you do not have this\n*                       or IBM's ROTATE90, there is a public domain\n*                       90 degree pgm in file 316, CBT mods tape).\n*\n*  LOCATE     TSO CMD   From the CBT tape originally. Modified to use\n*                       LPALST00 as well as LNKLST00 on an XA system.\n*                       Supports concatenated STEPLIBs also. Now has\n*                       ISPLLIB support and does multi-members ok.\n*\n*  LOGKILLR   PROGRAM   An old program designed to kill TSO LOGON\n*                       address spaces which hang in the user-prompt\n*                       code due to user walking away, etc.\n*\n*  MEMSTAT    TSO CMD   Checks a PDS for a member and sets &LASTCC.\n*                       Yeah, I know there are many, but WPPSS wants...\n*\n*  MLPALIST   PROGRAM   Lists modules loaded by MLPA or FLPA.\n*                       Similiar to AMBLIST LISTLPA.\n*\n*  NEWISPF    PROGRAM   THIS MODULE IS THE FRONTEND FOR ISPF AND/OR PDF.\n*                       IT HAS THE FOLLOWING FUNCTIONS:\n*                    1. SAVE THE INPUT ECT BECAUSE ISPF MODIFIES THE ECT\n*                       PTR TO THE IOWA WHICH IS NEEDED BY THE\n*                       WDPSCXS MODULE for stacking commands.\n*                    2. ALLOCATE THE USER PROFILE LIB TO DDNAME ISPPROF.\n*                    3. INVOKE THE NEWSPF CLIST IF PROFILE LIB\n*                       DOESN'T EXIST. NEWSPF creates new user profiles.\n*                    4. CALL THE REAL ISPF OR PDF COMMAND MODULE.\n*\n*  NEWMWILE   PROGRAM   Attaches itself, then terminates. Selected users\n*                       invoke this program when they start an ISPF\n*                       session to become exempt from the 522 abends\n*                       which we force on the average user.\n*                       Uses reusable module ITCOMA1.\n*\n*  NEWWAIT    PROGRAM   WAIT FOR A SPECIFIED PERIOD OF TIME\n*                       WITHOUT USING CPU TIME.This is the interruptible\n*                       version of WAITER.\n*\n*  NEXTGEN    TSO CMD   Return  two   CLIST  variables   &CURGEN  and\n*                       &NXTGEN where  &CURGEN contains  the absolute\n*                       generation number  of the  +0 generation  and\n*                       &NXTGEN  contains  the   absolute  generation\n*                       number of the +1 generation for a GDG.\n*\n*  PACKLIST   PROGRAM   Utility to build IEAPAK00 from data produced\n*                       by PSWSAMP routine.\n*\n*  PSWSAMP    PROGRAM   Trace table sampling utility for producing\n*                       data used by PACKLIST program.\n*\n*  REPROENQ   PROGRAM   Program to ENQ on SYSIGGV2 for a catalog\n*                       allocated to STEPLIB and call IDCAMS. Can backup\n*                       the catalogs without coding DISP=OLD and\n*                       draining the system using this. See REPROEN#.\n*\n*  RJETRANS   Program   Reassemble records  that have been  transmitted in\n*             (DYL280)  80 byte segments via RJE to their original logical\n*                       record length.\n*\n*  RTSO       Program   RTSO IMPLEMENTS A \"REMEMBER LAST TSO COMMAND\" FUNCTION\n*                       FOR BOTH THE \"TSO\" COMMAND ON THE \"COMMAND ==>\" LINE\n*                       AND FOR THE TSO COMMAND PANEL, PRIMARY MENU OPTION 6.\n*                       THE TSO COMMAND PANEL CAN BE BROUGHT UP FROM ANY PANEL\n*                       BY ENTERING \"TSO\" WITHOUT AN OPERAND, JUST LIKE THE\n*                       \"KEYS\" COMMAND.  THE LAST COMMAND ENTERED may be\n*                       PRESENTED WHEN THE TSO COMMAND PANEL IS DISPLAYED.\n*                       Related: panels ISRTSO,SPFEOPT,SPFEOH; clist\n*                       SPFEOPT; cmd table ISPCMDS\n*\n*  SCXSCAN    PROGRAM   LINKS AS A FRONT-END TO IKJSCAN TO\n*                       PROVIDE AN \"X CMD\" FACILITY FROM ANY\n*                       SUBCOMMAND MODE USING IKJSCAN (JUST LIKE\n*                       PCF X FACILITY)\n*\n*  SERLCONV   PROGRAM   CONVERT SERIAL DATES TO STANDARD DATE\n*                       FORMAT AFTER DATE VALIDATION.\n*\n*  SETRC      PROGRAM   This program turns a parm field into a\n*                       condition code. It is used to control execution\n*                       of PROC steps based on parms specified.\n*                       Not as good as a new JCL language, but a start.\n*\n*  SETVAR     PROGRAM   This is a subroutine which a TSO command\n*                       can link to in order to set a CLIST variable.\n*                       It links in IKJCT433(IKJUPDT) from LPALIB\n*                       for pre TSOE systems. For TSOE systems, the new\n*                       IKJCT441 TSOE interface is used.\n*\n*  SHOW       TSO CMD   Replacement for JTIP SHOW ALL command. Requires\n*                       JES2 exit-22, XJ22SHOW, and IGC00236 (included).\n*\n*  SPACE      TSO CMD   Displays allocation, utilization and extent\n*                       info for a dataset. Can return data to a CLIST.\n*\n*  SMF64EXT   PROGRAM   Analyzes SMF type 64 records to identify VSAM\n*                       datasets which are good candidates for use on\n*                       cached disk volumes.\n*\n*  SMF74MOD   PROGRAM   Merges SMF type 74 records from multiple CPUs\n*                       so ERBRMFPP device activity report will show\n*                       all activity to shared devices. Works for XA\n*                       and non-XA mixtures also.\n*\n*  SMPEIOF    PROGRAM   Intercepts SMPE calls to TSO STATUS command\n*                       and reroutes them to STATUS CLIST (included)\n*                       which uses IOF to check status and display\n*                       SMPE jobs. Much better than TSO OUTPUT command.\n*\n*  SPFCATNV   CLIST     This is an ISPF dialog for doing NVSAM catalog\n*                       functions. We use it as Tech Services option\n*                       K.N here. Good if you have multiple master and\n*                       user catalogs like we do. Change cat names in\n*                       the CLIST.\n*\n*  PANLEXIT   PROGRAM   ISPF dialog interface to allow exits from ISPF\n*                       display panels (not select panels yet) to a\n*\n*  SPFEXEC    PROGRAM   ISPF dialog interface to allow exits from ISPF\n* (PANLEXIT)            display panels (not select panels) to a\n*                       dialog or ISPF service. This is a replacement\n*                       for PANLEXIT. It is one of our best mods!\n*                       It allows fantastic flexibility in modifying\n*                       vendor dialogs, etc. It also provides the\n*                       interfaces to ISPLINK which IBM forgot! It can\n*                       be called as a REAL TSO command in contrast to\n*                       ISPEXEC which won't work from FOCUS, SAS, etc.\n*                       It can also be called directly with a single\n*                       ISPEXEC parm string in contrast to the two\n*                       parms (length,string) ISPLINK requires. It\n*                       accepts more flexible options than ISPEXEC\n*                       and will even initialize ISPF if needed!!!\n*                       Some SYNTAX examples:\n*                            SPFEXEC SELECT PANEL(ISRUTIL)\n*                       or   SPFEXEC PANEL(ISRUTIL)\n*                            SPFEXEC 3.1\n*                       or   @ SPFEXEC 'PANEL(ISRUTIL) OPT(1)'\n*                       etc., etc., etc........\n*\n*\n*  SPFPRINT   PROGRAM   This is linked as a frontend for your DSPRINT\n*                       command. It picks up an ISPF variable and adds\n*                       the contents to the command passed by ISPF. Now\n*                       you can modify the DSPRINT commands issued by\n*                       ISPF. Does not affect normal DSPRINT requests.\n*\n*  STACK      TSO CMD   STACK IS A NORMAL TSO COMMAND PROCESSOR:\n*                             STACK DDIN(INPUTDD) DDOUT(OUTDD) -\n*                             TASKLIB(TASKDD) LIST\n*\n*                       INPUTDD - DDNAME TO READ COMMAND FROM\n*                                        INSTEAD OF NORMAL SOURCE\n*                       OUTDD   - DDNAME THE COMMAND OUTPUT SHOULD\n*                                        GO TO\n*                       TASKDD  - DDNAME THE COMMAND SHOULD BE\n*                                        ATTACHED FROM IF DESIRED\n*                       LIST    - MEANS DISPLAY THE COMMAND ON THE\n*                                        OUTPUT FILE\n*                       (ALL OPERANDS ARE OPTIONAL)\n*                       (ALL FILE IO MUST BE DONE\n*                       VIA PUTGET MODULE TO BE INTERCEPTED)\n*\n*  STOJCONV   PROGRAM   CONVERT STANDARD DATES OF THE FORM\n*                       (MMDDYY) TO JULIAN AND SERIAL AFTER DATE\n*                       VALIDATION.\n*\n*  SUPRNAME   PROGRAM   The SUPRNAME program is a frontend processor to\n*                       AMASPZAP which adds some new control cards to\n*                       the SUPERZAP vanilla cards. It allows a dataset\n*                       to be renamed or scratched with no ENQ\n*                       contention even if the dataset name is allocated\n*                       to another job. It also allows a format one DSCB\n*                       to be dumped or zapped without knowing the CCHHR\n*                       address in the VTOC.\n*\n*  SYSOUT     TSO CMD   Command to allocate sysout files using the\n*                       new text units for FLASH, CHARS, MODIFY, etc.\n*\n*  TERMTYPE   PROGRAM   Program can be called by a CLIST to determine\n*                       screen lines, IE terminal type - TTY,M2,M3,etc.\n*\n*  TIMECOND   PROGRAM   Sets condition code to day of week, month,\n*                       year, etc for conditional execution of steps.\n*\n*  TRANS      TSO CMD   translates characters in CLIST variables. See\n*                       source for use documentation. No HELP mem yet.\n*\n*  UCBMAP     TSO CMD   A version of the UCBMAP command from file 301 of\n*                       the CBT tape with XA support (IOSVSUCB).\n*\n*  UCC7MOD    Source    A source patch to UCC7 module SASSLGON to allow\n*                       any VTAM terminal to sign on to UCC7.\n*\n*  UNCLIB     CLIST     DEALLOCATE (REMOVE) A PRIVATE CLIST\n*                       LIBRARY PREVIOUSLY ALLOCATED TO YOUR\n*                       SESSION.\n*\n*  UNNUM      CLIST     A clist to remove CLIST line nums for printing\n*\n*  VOL2DEVT   PROGRAM   Subroutine to return devicetype for given vol.\n*\n*  VSAMSCAN   PROGRAM   Reads catalog and writes IDCAMS uncatalog\n*                       cards for all NVSAM datasets which are then\n*                       processed by program CATBYVOL. See job in\n*                       CATBYVO#. I think DLY260 step is not needed.\n*\n*  WATDSN     CLIST     Utility to diplay datasets allocated to a given\n*             PROGRAM   DDNAME.\n*\n*  WDPSCXS    PROGRAM   Subroutine called by ISPF dialogs to stack a\n*                       command for execution when ISPF terminates.\n*                       Used for our option XL (Exit,Logoff). Requires\n*                       NEWISPF frontend to work correctly.\n*                       See clist SPFXL and panel ISR@PRIM also...\n*\n*  WHATDDN    TSO CMD   RETURN TO THE CLIST THE DDNAME(S) OF THE\n*                       DATASET(S) WHICH IS (ARE) ALLOCATED TO\n*                       THE DSNAME GIVEN.\n*\n*  WHATDSN    TSO CMD   RETURN TO THE CLIST THE DSNAME(S) OF THE\n*                       DATASET(S) WHICH IS (ARE) ALLOCATED TO\n*                       THE DDNAME GIVEN.\n*\n*  WHOISI     CLIST     List attributes  about your  LOGONID such  as\n*             DIALOG    account number, system  number, user catalog,\n*                       logon procedure, profile prefix, etc.\n*\n*  WTOPARM    PROGRAM   Send a message from the parm field to the\n*                       operator.\n*\n*  WTORCOND   PROGRAM   Ask operator a question (Y or N) and set\n*                       condition code for execution of later steps.\n*\n*  XEQ        COMMAND   Calls a program from a task/steplib or the\n*                       linklist without allocation overhead of 'CALL'\n*                       Known as @ here.\n*\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$FS3DOC": {"ttr": 774, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x00\\x7f\\x00\\x88\\x00\\x7f\\x12\\x00\\x07\\x87\\x07\\x87\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf2\\xf7\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-01-07T00:00:00", "modifydate": "1988-01-07T12:00:00", "lines": 1927, "newlines": 1927, "modlines": 0, "user": "FILE270"}, "mimetype": "application/octet-stream", "datatype": "binary", "extension": ".bin"}, "ADMUSP6": {"ttr": 1543, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x00\\x7f\\x00\\x88\\x00\\x7f\\x12\\x00\\x04#\\x04#\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf2\\xf7\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-01-07T00:00:00", "modifydate": "1988-01-07T12:00:00", "lines": 1059, "newlines": 1059, "modlines": 0, "user": "FILE270"}, "text": "        /* DATA SET 761KKUSP6  AT LEVEL 002 AS OF 10/04/83    */\n ADMUSP6:PROCEDURE OPTIONS(MAIN);\n /********************************************************************/\n /*                      ADMUSP6                                     */\n /*                                                                  */\n /*       APPLICATION TO PLOT THE DATA IN A NAMED FILE USING         */\n /*                THE 'CHART' UTILITY.                              */\n /*                                                                  */\n /*                                                                  */\n /*       THE FILE MUST CONSIST OF A NUMBER OF (80 BYTE)             */\n /*       RECORDS WHICH GIVE A TABLE OF DATA TO BE PLOTTED.          */\n /*       THE RECORDS ARE FORMATTED AS FOLLOWS:                      */\n /*                                                                  */\n /*        RECORD 1.                                                 */\n /*           CONTAINS THE CHART HEADING.                            */\n /*           LEADING AND TRAILING BLANKS ARE REMOVED FROM THE       */\n /*           TEXT SUPPLIED IN THE RECORD AND THE RESULTING          */\n /*           STRING IS USED TO TITLE THE GENERATED CHART.           */\n /*                                                                  */\n /*        RECORD 2.                                                 */\n /*           CONTAINS THE COLUMN HEADINGS OF THE TABLE,             */\n /*           WHICH WILL FORM THE CHART KEYS.  THESE KEYS            */\n /*           MUST BE SINGLE WORDS (WITHOUT IMBEDDED BLANKS)         */\n /*           OF NOT MORE THAN 32 CHARACTERS.                        */\n /*           OCCURRENCES OF UNDERSCORE CHARACTERS (_)               */\n /*           IN A WORD ARE REPLACED BY BLANKS SO THAT               */\n /*           BLANK CHARACTERS MAY BE GENERATED IN THE KEY           */\n /*           TEXT IF REQUIRED.                                      */\n /*                                                                  */\n /*           ONE WORD SHOULD BE PROVIDED FOR EACH DATA COLUMN       */\n /*           TO BE PLOTTED (EXCEPT THE FIRST WHICH IS USED AS       */\n /*           THE X DATA).                                           */\n /*                                                                  */\n /*        RECORDS 3 - N                                             */\n /*           CONTAIN THE TABLE OF DATA.    EACH RECORD              */\n /*           CONTAINS ONE TABLE ROW.  THE FIRST WORD IS THE         */\n /*           'X VALUE' FOR THE ROW, FURTHER WORDS ARE THE Y         */\n /*           VALUES.  THERE SHOULD BE ONE Y VALUE FOR EACH          */\n /*           KEY SPECIFIED ON THE KEY RECORD (RECORD 2).            */\n /*           X VALUES MAY BE NUMERIC OR ALPHANUMERIC.  Y VALUES     */\n /*           MUST BE NUMERIC, THAT IS THEY SHOULD BE CONVERTIBLE    */\n /*           TO FLOATING POINT NUMBERS BY THE NORMAL PL/I           */\n /*           CHARACTER TO ARITHMETIC CONVERSION.                    */\n /*                                                                  */\n /*      SAMPLE DATA MIGHT BE:                                       */\n /*                                                                  */\n /*               HISTORY OF RESULTS FOR XYZ LTD.                    */\n /*                   COSTS       SALES                              */\n /*        1975        320         120                               */\n /*        1976        330         340                               */\n /*        1977        430         520                               */\n /*        1978        550         630                               */\n /*        1979        620         640                               */\n /*                                                                  */\n /*                 .......*****........                             */\n /*                                                                  */\n /*   THE PROGRAM DISPLAYS AN ALPHANUMERIC PANEL REQUESTING          */\n /*   THE FOLLOWING INFORMATION:                                     */\n /*                                                                  */\n /*       1: THE NAME OF THE FILE CONTAINING THE TABLE TO BE         */\n /*          PLOTTED.                                                */\n /*                                                                  */\n /*       2: THE NAME OF A CHART FORMAT TO BE USED FOR THE           */\n /*          PLOT.                                                   */\n /*          (IF AN * IS INSERTED, THE DEFAULT FORMAT IS USED        */\n /*           BY CHART)                                              */\n /*                                                                  */\n /*       3: WHETHER A LINE GRAPH OF A BAR CHART IS TO BE PRODUCED.  */\n /*          IF A LINE GRAPH IS SELECTED, THE X VALUES ARE PASSED    */\n /*          AS NUMERIC DATA (ASSUMING THIS IS POSSIBLE).            */\n /*          THIS TYPE MAY BE USED FOR SURFACE CHARTS AND HISTOGRAMS.*/\n /*          NON-NUMERIC X VALUES CANNOT BE USED ON A LINE GRAPH     */\n /*          SINCE ALPHANUMERIC X LABELS CANNOT BE SPECIFIED FOR     */\n /*          A LINE GRAPH.                                           */\n /*                                                                  */\n /*          IF A BAR CHART IS SELECTED, THE X VALUES ARE PASSED     */\n /*          AS LABELS. THIS FORM IS ALSO SUITABLE FOR PIE CHARTS.   */\n /*                                                                  */\n /*       4: WHETHER THE CHART IS TO BE DISPLAYED OR JUST PRINTED    */\n /*                                                                  */\n /*   ONCE THE PANEL IS COMPLETED (ASSUMING THE INTERRUPT IS         */\n /*   BY A KEY OTHER THAN PF 3), THE DATA FILE IS FETCHED            */\n /*   (IF A NEW ONE IS ENTERED) AND PROVIDED THERE ARE NO ERRORS     */\n /*   THE CHART UTILITY IS CALLED.   THIS IS INSTRUCTED TO PLOT      */\n /*   THE DATA IMMEDIATELY.   THE USER CAN RETURN TO THE INITIAL     */\n /*   PANEL BY USING THE 'EXIT' KEY FROM CHART.  ALTERNATIVELY       */\n /*   HE MAY CHOOSE TO MODIFY THE FORMAT USING THE 'HOME' KEY,       */\n /*   WHEN ALL THE FACILITIES OF CHART ARE AVAILABLE.                */\n /*                                                                  */\n /*                                                                  */\n /*   THE UTILITY IS TERMINATED BY PF 3/15.                          */\n /*                                                                  */\n /********************************************************************/\n DECLARE\n\n\n   1 ADMTPCS,                     /* PANEL CONTROL STRUCTURE.        */\n    2 PCSLEVEL           /* NUMBER IDENTIFYING THE CHART LEVEL USED. */\n        FIXED BIN(31)    /* THE LEVEL NUMBER MAY CHANGE WITH FUTURE  */\n         INIT(0),        /* RELEASES IF THE CALL PARAMETER FORMAT    */\n                         /* CHANGES. MUST BE ZERO.                   */\n    2 PCSDISP            /* 0 = THE DATA CONTAINED IN \"DATA_CONTROL\" */\n        FIXED BIN(31)    /*     \"X\", \"Y\", \"KEYS\", \"LABELS\" AND       */\n         INIT(2),        /*     \"HEADING\" IS SAVED ONTO THE FILE     */\n                         /*     INDICATED BY PCSDNAME. NO PANELS ARE */\n                         /*     PRESENTED BEFORE RETURNING TO THE    */\n                         /*     APPLICATION PROGRAM.                 */\n                         /* 1 = THE \"HOME\" PANEL IS PRESENTED TO THE */\n                         /*     OPERATOR.                            */\n                         /* 2 = THE DISPLAY PANEL IS PRESENTED TO    */\n                         /*     THE OPERATOR USING THE SUPPLIED DATA */\n                         /*     AND CHART FORMAT. THE OPERATOR THEN  */\n                         /*     HAS THE CHOICE OF THE \"HOME\" PANEL,  */\n                         /*     OR RETURNING TO THE APPLICATION      */\n                         /*     PROGRAM.                             */\n                         /* 3 = THE DISPLAY PANEL IS PRESENTED TO    */\n                         /*     THE OPERATOR USING THE SUPPLIED DATA */\n                         /*     AND CHART FORMAT. THE \"HOME\" PANEL   */\n                         /*     IS NOT AVAILABLE, BUT THE \"PRINT\",   */\n                         /*     \"HELP\" AND \"SAVE\" FUNCTIONS MAY BE   */\n                         /*     AVAILABLE.                           */\n                         /* 4 = THE DATA CONTAINED IN \"DATA_CONTROL\" */\n                         /*     \"X\", \"Y\", \"KEYS\", \"LABELS\" AND       */\n                         /*     \"HEADING\" IS PRINTED (1 COPY).       */\n                         /*     RETURN IS MADE DIRECTLY TO THE       */\n                         /*     APPLICATION PROGRAM.                 */\n    2 PCSHELP            /* 0 = PF KEY ASSIGNMENTS ARE NOT DISPLAYED */\n        FIXED BIN(31)    /*     INITIALLY ON THE DISPLAY PANEL. THIS */\n           INIT(1),      /*     SETTING MAY BE CHANGED BY USE OF     */\n                         /*     ENTER WHENEVER THE DISPLAY PANEL IS  */\n                         /*     PRESENTED.                           */\n                         /* 1 = PF KEY ASSIGNMENTS ARE DISPLAYED     */\n                         /*     INITIALLY ON THE DISPLAY PANEL. THIS */\n                         /*     SETTING MAY BE CHANGED BY USE OF     */\n                         /*     ENTER WHENEVER THE DISPLAY PANEL IS  */\n                         /*     PRESENTED.                           */\n                         /* IGNORED IF PCSDISP=0, OR IF PCSDISP=4.   */\n    2 PCSISOL            /* 0 = SAVE AND RESTORE MENU PANELS ARE     */\n        FIXED BIN(31)    /*     MADE AVAILABLE TO THE OPERATOR.      */\n          INIT(0),       /* 1 = SAVE AND RESTORE MENU PANELS ARE NOT */\n                         /*     MADE AVAILABLE TO THE OPERATOR.      */\n                         /* IGNORED IF PCSDISP=0 OR PCSDISP=4.       */\n    2 PCSFNAME CHAR(8)   /* NAME OF PREVIOUSLY SAVED CHART FORMAT TO */\n          INIT('*'),     /* BE USED INITIALLY. THE NAME '*' IS       */\n                         /* RESERVED TO INDICATE THE DEFAULT CHART   */\n                         /* FORMAT. IGNORED IF PCSDISP=0.            */\n    2 PCSDNAME CHAR(8)   /* FOR PCSDISP=0, THE NAME UNDER WHICH THE  */\n          INIT('*'),     /* CHART DATA CONTAINED IN \"DATA_CONTROL\",  */\n                         /* \"X\", \"Y\", \"KEYS\", \"LABELS\" AND \"HEADING\" */\n                         /* IS TO BE SAVED.                          */\n                         /* FOR PCSDISP\u00ac=0, THE NAME OF A PREVIOUSLY */\n                         /* SAVED CHART DATA FILE TO BE USED INIT-   */\n                         /* -IALLY OR FOR PRINTING. THE NAME '*'     */\n                         /* INDICATES THAT THE DATA CONTAINED IN     */\n                         /* \"DATA_CONTROL\", \"X\", \"Y\", \"KEYS\",        */\n                         /* \"LABELS\" AND \"HEADING\" IS TO BE USED.    */\n    2 PCSPAIR            /* 0 = \"X\" AND \"Y\" DATA GROUPS ARE NOT      */\n        FIXED BIN(31)    /*     PAIRED. THERE IS ONLY ONE \"X\" DATA   */\n           INIT(0),      /*     GROUP, OR SET OF \"LABELS\", WHICH IS  */\n                         /*     PLOTTED AGAINST EACH \"Y\" DATA GROUP. */\n                         /*     IN THIS MODE OF OPERATION, THERE MAY */\n                         /*     BE RESTRICTIONS ON THE NUMBER OF \"Y\" */\n                         /*     DATA GROUPS WHICH CAN BE DISPLAYED   */\n                         /*     AT ANY ONE TIME.                     */\n                         /* 1 = \"X\" AND \"Y\" DATA GROUPS ARE PAIRED.  */\n                         /*     FOR EACH \"Y\" DATA GROUP THERE IS A   */\n                         /*     UNIQUE \"X\" DATA GROUP AGAINST WHICH  */\n                         /*     IT IS PLOTTED WHEN SELECTED. IN THIS */\n                         /*     MODE OF OPERATION, SOME SHADING      */\n                         /*     OPTIONS MAY BE IGNORED WHEN          */\n                         /*     DISPLAYED. IF \"LABELS\" ARE PROVIDED  */\n                         /*     INSTEAD OF \"X\", THEN EACH \"Y\" DATA   */\n                         /*     GROUP IS MATCHED VALUE FOR LABEL     */\n                         /*     AGAINST \"LABELS\" UNTIL THE DATA      */\n                         /*     GROUP IS EXHAUSTED.                  */\n                         /* IGNORED IF PCSDISP\u00ac=0 AND PCSDNAME\u00ac='*'. */\n    2 PCSNC              /* MAXIMUM NO. OF DATA GROUPS. FOR          */\n        FIXED BIN(31)    /* PCSPAIR=1, THE NUMBER OF DATA GROUPS FOR */\n           INIT(0),      /* WHICH STORAGE IS PROVIDED IN \"X\" (FOR    */\n                         /* PCSLABL=0) AND \"Y\", AND ALSO THE NO. OF  */\n                         /* VALUES IN \"DATA_CONTROL\". FOR PCSPAIR=0, */\n                         /* THE NUMBER OF DATA GROUPS FOR WHICH      */\n                         /* STORAGE IS PROVIDED IN \"Y\". RANGE 0      */\n                         /* THROUGH 999.                             */\n                         /* IGNORED IF PCSDISP\u00ac=0 AND PCSDNAME\u00ac='*'. */\n    2 PCSNE              /* MAXIMUM NO. OF ELEMENTS. THE NUMBER OF   */\n        FIXED BIN(31)    /* VALUES (PER DATA GROUP) FOR WHICH        */\n           INIT(0),      /* STORAGE IS PROVIDED IN \"X\" (FOR          */\n                         /* PCSLABL=0) AND \"Y\", AND ALSO THE NO. OF  */\n                         /* LABELS IN \"LABELS\" (FOR PCSLABL\u00ac=0).     */\n                         /* RANGE 0 THROUGH 999.                     */\n                         /* IGNORED IF PCSDISP\u00ac=0 AND PCSDNAME\u00ac='*'. */\n    2 PCSKEYL            /* LENGTH OF EACH STRING IN \"KEYS\". RANGE 0 */\n        FIXED BIN(31)    /* THROUGH 132.                             */\n           INIT(0),      /* IGNORED IF PCSDISP\u00ac=0 AND PCSDNAME\u00ac='*', */\n                         /* OR IF PCSNC = 0.                         */\n    2 PCSLABL            /* LENGTH OF EACH STRING IN \"LABELS\". RANGE */\n        FIXED BIN(31)    /* 0 THROUGH 132.                           */\n          INIT(0),       /* IGNORED IF PCSDISP\u00ac=0 AND PCSDNAME\u00ac='*', */\n                         /* OR IF PCSNE=0.                           */\n    2 PCSHEADL           /* LENGTH OF THE CHART \"HEADING\". RANGE 0   */\n        FIXED BIN(31)    /* THROUGH 132.                             */\n          INIT(0),       /* IGNORED IF PCSDISP\u00ac=0 AND PCSDNAME\u00ac='*'. */\n    2 PCSPNAME CHAR(8)   /* PRINTER DESTINATION NAME. ' ' INDICATES  */\n          INIT('*'),     /* NO PRINTER. '*' INDICATES THAT THE NAME  */\n                         /* IS UNKNOWN, IN WHICH CASE THE OPERATOR   */\n                         /* IS PROMTED FOR THE NAME AS REQUIRED).    */\n                         /* IGNORED IF PCSDISP=0. THESE RESERVED     */\n                         /* NAMES ARE NOT VALID FOR PCSDISP=4.       */\n    2 PCSPRDEP           /* DEPTH IN ROWS OF THE CHART AREA ON THE   */\n        FIXED BIN(31)    /* PRINTER. RANGE 1 THROUGH 132. IGNORED IF */\n          INIT(64),      /* PCSDISP=0, OR IF PCSPNAME=' ', OR IF     */\n                         /* PCSPNAME='*'.                            */\n    2 PCSPRWID           /* WIDTH IN COLUMNS OF THE CHART AREA ON THE*/\n        FIXED BIN(31)    /* PRINTER. RANGE 1 THROUGH 132. IGNORED IF */\n          INIT(120),     /* PCSDISP=0, OR IF PCSPNAME=' ', OR IF     */\n                         /* PCSPNAME='*'.                            */\n    2 PCSPCOPY           /* NO. OF COPIES REQUIRED FOR PRINT.        */\n        FIXED BIN(31)    /* IGNORED IF PCSDISP\u00ac=4.                   */\n          INIT(1);\n /********************************************************************/\n /*     END OF PANEL CONTROL STRUCTURE (PCS) DEFINITION.             */\n /********************************************************************/\n\n1 DECLARE\n /********************************************************************/\n /*                                                                  */\n /*       VARIOUS LOCAL VARIABLES                                    */\n /*                                                                  */\n /********************************************************************/\n\n\n   END_OF_FILE BIT(1),   /* END OF FILE INDICATOR                    */\n   RETCODE FIXED BIN(31),/* RETURN CODE FROM READ/ CLOSE             */\n   RETCODE1 FIXED BIN(31),/* RETURN CODE FROM OPEN                   */\n   EXIT BIT(1),          /* FLAG USED TO INDICATE EXIT REQUIRED      */\n   ONSOURCE BUILTIN,     /* FORCE IT TO BE BUILTIN                   */\n   FILE_NAME   CHAR(8)   /* DATA FILE NAME                           */\n    INIT('        '),\n   PRINTER_NAME CHAR(8)  /* DATA FILE NAME                           */\n    INIT('*       '),\n   FORMAT_TYPE CHAR(1)   /* '1' IF BAR CHART TYPE FORMAT             */\n    INIT('1'),           /* '2' IF LINE GRAPH TYPE FORMAT            */\n   OPTION      CHAR(1)   /* '1' IF DISPLAY REQUIRED                  */\n    INIT('1'),           /* '2' IF PRINT ONLY REQUIRED               */\n   LABELLEN FIXED BIN(15),/* LENGTH OF X LABELS.                     */\n\n                         /* ENTRY POINTS FOR ASSEMBLER I/O ROUTINES  */\n   ADMUSP6O ENTRY(CHARACTER(8),\n                  FIXED BIN(31)) OPTIONS(INTER ASSEMBLER),\n   ADMUSP6C ENTRY (FIXED BIN(31)) OPTIONS(INTER ASSEMBLER),\n   ADMUSP6R ENTRY(POINTER,\n                   FIXED BIN(31)) OPTIONS(INTER ASSEMBLER),\n\n   ERRPROC  EXTERNAL ENTRY,/*EXTERNAL ERROR HANDLING PROCEDURE       */\n\n   DUMMY POINTER;        /* DUMMY VARIABLE                           */\n\n DECLARE  (              /* GDDM ENTRY POINTS USED, REENTRANT FORM*/\n\n  ASCGET ENTRY(*,  BIN FIXED(31),BIN FIXED(31),CHAR(*)               ),\n  ASCPUT ENTRY(*,  BIN FIXED(31),BIN FIXED(31),*                     ),\n  ASDFMT ENTRY(*,  BIN FIXED(31),BIN FIXED(31),(*,*)BIN FIXED(31)    ),\n  ASFCUR ENTRY(*,  BIN FIXED(31),BIN FIXED(31),BIN FIXED(31)         ),\n  ASDFLT ENTRY(*,  BIN FIXED(31),(*) BIN FIXED(31)                   ),\n  ASQMOD ENTRY(*,  BIN FIXED(31),BIN FIXED(31),BIN FIXED(31),\n                   BIN FIXED(31)                                     ),\n  ASFMOD ENTRY(*,  BIN FIXED(31),BIN FIXED(31)                       ),\n  ASREAD ENTRY(*,  BIN FIXED(31),BIN FIXED(31),BIN FIXED(31)         ),\n\n  FSALRM ENTRY(*                                                     ),\n  FSINR  ENTRY(*                                                     ),\n  FSTERM ENTRY(*                                                     ),\n  FSEXIT ENTRY(*,  ENTRY,BIN FIXED(31)                               ),\n  CHART  ENTRY(                                                      )\n         )OPTIONS(ASM,INTER);\n\n  DECLARE                          /* GDDM ANCHOR BLOCK              */\n    1 AB,\n       2  AABSC   FIXED BIN(15),   /* SEVERITY CODE                  */\n       2  AABEC   FIXED BIN(15),   /* ERROR CODE                     */\n       2  AABAP   POINTER,         /* GDDM ANCHOR                    */\n       2  MESSAGE CHARACTER(60)    /* MESSAGE TEXT RETURNED FROM     */\n            INIT(' ');             /* ERROR PROCEDURE                */\n1/********************************************************************/\n /*                                                                  */\n /*       MAIN PROGRAM                                               */\n /*                                                                  */\n /********************************************************************/\n\n   CALL FSINR(AB);       /* INITIALISE GDDM FOR RE-ENTRANT CODE      */\n                         /* CAUSE ERRORS TO CALL ERRPROC  AND PLACE  */\n   CALL FSEXIT(AB,ERRPROC ,4);\n                         /* IF SEVERITY >= WARNING                   */\n   CALL SCFORMAT;        /* FORMAT THE SCREEN FOR THE INITIAL PANEL  */\n   EXIT = '0'B;          /* INITIALISE EXIT FLAG                     */\n\n   DO UNTIL (EXIT = '1'B); /* REPEAT UNTIL EXIT REQUESTED            */\n\n    CALL SCREAD;         /* FILL IN SCREEN PANEL WITH DEFAULT DATA   */\n                         /* AND READ USER'S INPUT.                   */\n    IF EXIT = '0'B THEN\n     DO;\n      IF FORMAT_TYPE = '1' THEN    /* IF BAR CHART TYPE FORMAT       */\n        PCSLABL = LABELLEN;        /* THEN SET LABEL LENGTH          */\n      ELSE                         /* OTHERWISE                      */\n        PCSLABL = 0;               /* SET 0 SO THAT X DATA IS USED.  */\n\n    IF PCSDISP = 4 & PRINTER_NAME = '*' THEN\n       PCSPNAME = FILE_NAME;       /* SET PRINTER NAME TO THE SAME   */\n    ELSE                          /*  AS THE DATA FILE NAME IF IT    */\n       PCSPNAME = PRINTER_NAME;   /*  IS NOT SPECIFIED AND NEEDED.   */\n                                  /*  THIS IS SENSIBLE ON CMS ONLY - */\n                                  /*  BUT FOR TSO IT DOES NOT CAUSE  */\n                                  /*  ANY PROBLEMS EXCEPT THAT       */\n                                  /*  THE WRONG DIAGNOSTIC IS        */\n                                  /*  GENERATED.                     */\n                                  /*  OTHERWISE SET AS GIVEN.        */\n      CALL CHART(AB,              /* CALL CHART UTILITY WITH RESULT. */\n                ADMTPCS,          /* CONTROL STRUCTURE.              */\n                DATA_CONTROL,     /* DATA CONTROL VECTOR (NONE).     */\n                XDATA,            /* X DATA                          */\n                YDATA,            /* Y DATA                          */\n                KEYS,             /* KEYS                            */\n                XLABELS,          /* DATA LABELS                     */\n                HEADING);         /* HEADING                         */\n     END;                         /* OF CHART CALL                   */\n   END;                  /* OF MAIN LOOP                             */\n\n   CALL FSTERM(AB);      /* TERMINATE GDDM                           */\n1DECLARE  (                      /* INPUT FIELD IDENTIFIERS:         */\n    DATAF INIT(1),                 /* INPUT FIELD NAME FOR PLOT DATA */\n    FORMF INIT(2),                 /* INPUT FIELD NAME FOR CHART FMT */\n    FTYPF INIT(3),                 /* INPUT FIELD FOR FORMAT TYPE    */\n    HEADF INIT(20),                /* OUTPUT ONLY FIELD FOR HEADING  */\n    FOOTF INIT(21),                /* OUTPUT ONLY FIELD FOR FOOTING  */\n    MSGF  INIT(22),                /* OUTPUT ONLY FIELD FOR MESSAGE  */\n    OPTF  INIT(23),                /* FIELD FOR FUNCTION OPTIONS     */\n    PRTF  INIT(24)                 /* FIELD FOR PRINTER NAME         */\n           ) FIXED BIN(31) STATIC;\n SCFORMAT:PROCEDURE;\n   /******************************************************************/\n   /*                                                                */\n   /*       FORMAT THE SCREEN TO CONTAIN FIELDS CONTAINING:          */\n   /*                                                                */\n   /*             1 THE NAME OF FILE TO BE PLOTTED                   */\n   /*             2 THE NAME OF THE CHART FORMAT                     */\n   /*             3 THE TYPE OF THE CHART FORMAT                     */\n   /*                                                                */\n   /*                                                                */\n   /******************************************************************/\n\n   /******************************************************************/\n   /*    DEFINE THE DEFAULT ATTRIBUTES                               */\n   /******************************************************************/\n   DECLARE\n    DFLTS(9) FIXED BIN(31) STATIC INIT\n      ( /* FIELD TYPE */  0,  /* INPUT OUTPUT */\n        /* INTENSITY  */  0,  /* NORMAL       */\n        /* COLOUR     */  0,  /* MONOCHROME   */\n        /* SYMBOL SET */  0,  /* STANDARD     */\n        /* HIGHLIGHT  */  0,  /* NORMAL       */\n        /* END ATTR.  */  0,  /* AUTOSKIP     */\n        /* NULLS OUT  */  0,  /* NO           */\n        /* BLANKS IN  */  2,  /* YES          */\n        /* TRANSLATION*/  1   /* UPPER CASE   */ );\n   /******************************************************************/\n   /*    DEFINE THE SCREEN FORMAT ARRAY                              */\n   /******************************************************************/\n   DECLARE\n    FORMAT(22,8) FIXED BIN(31)\n     INIT(\n    /* FIELD-ID, ROW ,COLUMN, DEPTH , WIDTH, TYPE , INTENSITY,COLOUR */\n       HEADF   ,  1  ,  30  ,   1   ,  20  ,  2   ,    2     ,   7  ,\n       FOOTF   ,  20 ,  30  ,   1   ,  20  ,  2   ,    2     ,   7  ,\n       MSGF    ,  2  ,  10  ,   1   ,  60  ,  2   ,    2     ,   2  ,\n       101     ,  9  ,  20  ,   1   ,  19  ,  2   ,    1     ,   1  ,\n       102     ,  10 ,  20  ,   1   ,  19  ,  2   ,    1     ,   1  ,\n       103     ,  12 ,  20  ,   1   ,  19  ,  2   ,    1     ,   1  ,\n       106     ,  12 ,  50  ,   1   ,  19  ,  2   ,    1     ,   1  ,\n       107     ,  13 ,  50  ,   1   ,  19  ,  2   ,    1     ,   1  ,\n       108     ,  3  ,  20  ,   1   ,  19  ,  2   ,    1     ,   1  ,\n       109     ,  3  ,  50  ,   1   ,  19  ,  2   ,    1     ,   1  ,\n       110     ,  4  ,  50  ,   1   ,  19  ,  2   ,    1     ,   1  ,\n       111     , 15  ,  20  ,   1   ,  19  ,  2   ,    1     ,   1  ,\n       112     , 15  ,  50  ,   1   ,  19  ,  2   ,    1     ,   1  ,\n       113     ,  10 ,  50  ,   1   ,  19  ,  2   ,    1     ,   1  ,\n       115     ,   5 ,  50  ,   1   ,  19  ,  2   ,    1     ,   1  ,\n       116     ,   6 ,  50  ,   1   ,  19  ,  2   ,    1     ,   1  ,\n       117     ,   7 ,  50  ,   1   ,  19  ,  2   ,    1     ,   1  ,\n       DATAF   ,  9  ,  40  ,   1   ,   8  ,  0   ,    1     ,   4  ,\n       FORMF   ,  10 ,  40  ,   1   ,   8  ,  0   ,    1     ,   4  ,\n       FTYPF   ,  12 ,  40  ,   1   ,   1  ,  1   ,    1     ,   4  ,\n       OPTF    ,  3  ,  40  ,   1   ,   1  ,  1   ,    1     ,   4  ,\n       PRTF    , 15  ,  40  ,   1   ,   8  ,  0   ,    1     ,   4  ),\n\n   /******************************************************************/\n   /*    DEFINE STATIC CONTENT OF FIELDS                             */\n   /******************************************************************/\n    1 CONTENT,\n\n     2 FIELD(16) FIXED BIN(31)  INIT    /* FIELD IDENTIFIERS          */\n     (HEADF,101,102,103,106,107,108,109,110,111,112,113,\n                                            115,116,117,FOOTF),\n\n     2 VALUE(16)  CHAR(19)         INIT /* CONSTANT CONTENTS          */\n      ( 'CHART IMPORT PANEL ',   /* HEADF*/\n        'CHART NAME      ==>',   /* 101  */\n        'FORMAT NAME     ==>',   /* 102  */\n        'X-DATA TYPE     ==>',   /* 103  */\n        '1- CHARACTER LABELS',   /* 106  */\n        '2- NUMERIC VALUES  ',   /* 107  */\n        'SELECT OPTION   ==>',   /* 108  */\n        '1-SHOW IMPORT CHART',   /* 109  */\n        '2-PRINT IMPORT ONLY',   /* 110  */\n        'PRINTER NAME    ==>',   /* 111  */\n        '(FOR OPTION 2)     ',   /* 112  */\n        '(ENTER NAME OR *)  ',   /* 113  */\n        '3-LOAD IMPORT CHART',   /* 115  */\n        '4-LOAD SAVED CHART ',   /* 116  */\n        '5-SHOW SAVED CHART ',   /* 117  */\n        'USE PF 3/15 TO EXIT');    /* FOOTF*/\n\n   /******************************************************************/\n   /*    FORMAT THE SCREEN AND FILL IN CONSTANT DATA -               */\n   /*            HEADINGS AND FIELD DESCRIPTORS                      */\n   /******************************************************************/\n\n                                   /*     SET DEFAULTS               */\n   CALL ASDFLT(AB,HBOUND(DFLTS,1),DFLTS);\n   CALL ASDFMT(AB,HBOUND(FORMAT,1),HBOUND(FORMAT,2),FORMAT);\n\n\n   DO I = 1 TO HBOUND(FIELD,1);    /* DO ALL CONTENT ARRAY -         */\n     CALL ASCPUT(AB,FIELD(I),      /*   FIELD   ID                   */\n                 LENGTH(VALUE(I)), /*   LENGTH OF STRING             */\n                 VALUE(I));        /*   INITIAL STRING               */\n   END;\n END;                              /* OF SCREEN FORMAT PROCEDURE     */\n1SCREAD:PROCEDURE;\n   /******************************************************************/\n   /*                                                                */\n   /*       THIS PROCEDURE INITIALISES THE PREPARED SCREEN PANEL     */\n   /*       FROM THE DEFAULT DATA IN THE STRUCTURE ADMPCS            */\n   /*       DISPLAYS IT TO THE TERMINAL OPERATOR AND READS           */\n   /*       ANY MODIFICATIONS HE MAKES.   IF AN ERROR IS             */\n   /*       DETECTED, THE MESSAGE IS DISPLAYED AND NEW INPUT         */\n   /*       IS AWAITED.  THE CYCLE IS REPEATED UNTIL THERE ARE       */\n   /*       NO DETECTED ERRORS.                                      */\n   /*                                                                */\n   /******************************************************************/\n\n  DECLARE                /* LOCAL  VARIABLES                         */\n   PICZ9 PICTURE 'Z9',   /* PICTURE USED AS FORMAT FOR NUMERIC OUTPUT*/\n   CHARS CHAR(2),        /* TEMPORARY USED FOR NUMNERIC INPUT        */\n   ATTYPE FIXED BIN(31), /* TYPE OF KEY USED TO CAUSE INTERRUPT      */\n   ATMOD  FIXED BIN(31), /* KEY NUMBER USED                          */\n   COUNT  FIXED BIN(31), /* COUNT OF MODIFIED FIELDS                 */\n   FIELD_ID FIXED BIN(31),/* FIELD NUMBER MODIFIED BY THE USER       */\n   LEN1   FIXED BIN(31), /* LENGTH  RETURNED BY QMOD (NOT USED)      */\n   LEN2   FIXED BIN(31); /* NON NULL LENGTH RETURNED BY QMOD         */\n\n   DO UNTIL(MESSAGE = '');         /* DO UNTIL THERE IS AGAIN NO MSG */\n\n   /******************************************************************/\n   /*       ADD VARYING SCREEN DATA FROM THE DATA IN ADMTPCS         */\n   /*       AS DEFAULTS FOR THE USER.                                */\n   /******************************************************************/\n\n    CALL ASCPUT(AB,DATAF,8,FILE_NAME);/*  THE FILE NAME              */\n\n    CALL ASCPUT(AB,FORMF,8,PCSFNAME); /*  THE FORMAT NAME            */\n\n    CALL ASCPUT(AB,FTYPF,1,FORMAT_TYPE);/* THE FORMAT TYPE           */\n\n    CALL ASCPUT(AB,OPTF,1,OPTION); /* INSERT THE SELECTED OPTION     */\n\n    CALL ASCPUT(AB,PRTF,8,PRINTER_NAME);/* INSERT PRINTER NAME       */\n\n\n                                   /*  INSERT ANY MESSAGE IN THE     */\n                                   /*  MESSAGE LINE.                 */\n   CALL ASCPUT(AB,MSGF,LENGTH(MESSAGE),MESSAGE);\n\n   IF MESSAGE \u00ac= '' THEN            /* THERE WAS AN ERROR -          */\n      CALL FSALRM(AB);              /* RING THE ALARM                */\n\n   MESSAGE = '';                    /* THEN CLEAR MSG FOR NEXT TIME  */\n1  /******************************************************************/\n   /*                                                                */\n   /*       READ THE SCREEN , EXTRACT THE DATA AND TAKE APPROPRIATE  */\n   /*       ACTION:                                                  */\n   /*             1 THE NAME OF DATA FILE.                           */\n   /*                - READ THE FILE                                 */\n   /*             2 THE NAME OF THE CHART FORMAT                     */\n   /*             3 THE TYPE OF THE CHART FORMAT                     */\n   /*                - CONVERT X DATA TO CORRECT TYPE                */\n   /*             4 THE WIDTH OF THE PRINTOUT                        */\n   /*             5 THE DEPTH OF THE PRINTOUT                        */\n   /*                                                                */\n   /******************************************************************/\n\n   CALL ASFCUR(AB,DATAF,1,1);     /* POSITION THE CURSOR ON FILE     */\n   CALL ASREAD(AB,ATTYPE,ATMOD,COUNT);/* AND READ THE SCREEN.        */\n\n   IF (ATTYPE = 1) & (ATMOD = 3 | ATMOD = 15) THEN\n      EXIT= '1'B;                  /* PF 3/15 WAS USED, INDICATE EXIT*/\n   ELSE                            /* PF 3/15 NOT USED:              */\n    DO;                            /* PROCESS INPUT FIELDS:          */\n      DO UNTIL(FIELD_ID = 0);      /* UNTIL ALL FIELDS PROCESSED     */\n                                   /* EXTRACT NEXT MODIFIED FIELD    */\n                                   /* INTO FIELD_ID.                 */\n       CALL ASQMOD(AB,1,FIELD_ID,LEN1,LEN2);\n\n       /**************************************************************/\n       /*    FIELD_ID NOW CONTAINS A FIELD NUMBER MODIFIED BY THE    */\n       /*    USER.  TEST WHICH ONE IT IS AND TAKE APPROPRIATE        */\n       /*    ACTION.                                                 */\n       /**************************************************************/\n       IF FIELD_ID = DATAF THEN\n        DO;                        /* EXTRACT THE DATA NAME FROM THE */\n         CALL ASCGET(AB,DATAF,8,FILE_NAME);\n         IF OPTION < 4 THEN                         /*       WDPSC   */\n         CALL GET_FILE;            /* PANEL AND FETCH IN THE DATA    */\n        END;\n\n       IF FIELD_ID = FORMF THEN\n        DO;                        /* EXTRACT THE FORMAT             */\n         CALL ASCGET(AB,FORMF,8,PCSFNAME);\n        END;\n\n       IF FIELD_ID = FTYPF THEN\n        DO;                        /* EXTRACT THE FORMAT TYPE        */\n         CALL ASCGET(AB,FTYPF,1,FORMAT_TYPE);\n        END;\n\n\n       IF FIELD_ID = OPTF THEN\n        DO;                        /* EXTRACT THE OPTION             */\n         CALL ASCGET(AB,OPTF,1,OPTION);\n        END;\n\n\n       IF FIELD_ID = PRTF THEN\n        DO;                        /* EXTRACT THE PRINTER NAME       */\n         CALL ASCGET(AB,PRTF,8,PRINTER_NAME);\n        END;\n\n\n\n     END;                           /* OF FIELD PROCESSING LOOP      */\n    /*****************************************************************/\n    /*       TEST IF NUMERIC X DATA FORMAT IS REQUESTED AND IF SO    */\n    /*       WHETHER DATA HAS BEEN MARKED SUITABLE.                  */\n    /*****************************************************************/\n    IF (FORMAT_TYPE = '2') & (XNUMERIC = '0'B) THEN\n     DO;                           /* IMPROPER REQUEST, DIAGNOSE:    */\n      IF  MESSAGE = ''  THEN\n         MESSAGE = 'X DATA NOT NUMERIC';\n      CALL ASFMOD(AB,FTYPF,1);     /* SET FIELD MODIFIED, SO IT      */\n     END;                          /* MUST BE MODIFIED               */\n\n    IF (FORMAT_TYPE \u00ac= '1') & (FORMAT_TYPE \u00ac= '2') THEN\n     DO;                           /* IMPROPER REQUEST, DIAGNOSE:    */\n      IF  MESSAGE = ''  THEN\n         MESSAGE = 'X DATA TYPE MUST BE 1 OR 2';\n      CALL ASFMOD(AB,FTYPF,1);     /* SET FIELD MODIFIED, SO IT      */\n     END;                          /* MUST BE CORRECTED              */\n\n    PCSDNAME = '*';\n\n    IF OPTION = '1' THEN           /* IF OPTION 1 SELECTED, DISPLAY  */\n      PCSDISP = 2;                 /* THE CHART                      */\n    ELSE\n     IF OPTION = '2' THEN          /* IF OPTION 2 SELECTED, PRINT    */\n       PCSDISP = 4;                /* ONLY.                          */\n    ELSE\n     IF OPTION = '3' THEN          /* IF OPTION 3 SELECTED, LOAD     */\n       PCSDISP = 1;                /* ONLY.                          */\n    ELSE\n     IF OPTION = '4' THEN          /* IF OPTION 4 SELECTED, LOAD     */\n       DO;\n       PCSDISP = 1;                /* ONLY.                          */\n       PCSDNAME = FILE_NAME;\n       END;\n    ELSE\n     IF OPTION = '5' THEN          /* IF OPTION 2 SELECTED, PRINT    */\n       DO;\n       PCSDISP = 2;                /* ONLY.                          */\n       PCSDNAME = FILE_NAME;\n       END;\n    ELSE\n     DO;                           /* OPTION INVALID  , DIAGNOSE:    */\n      IF  MESSAGE = ''  THEN\n         MESSAGE = 'OPTION MUST BE 1 THROUGH 5';\n      CALL ASFMOD(AB,OPTF,1);      /* SET FIELD MODIFIED             */\n     END;\n   END;                            /* OF GET DATA LOOP               */\n  END;                             /* OF DATA EXTRACTION             */\n END;                              /* OF SCREEN READ PROCEDURE       */\n1DECLARE\n  HEADING CHAR(132),               /* STRING OF CHARACTERS FORMING   */\n                                   /* THE HEADING.                   */\n  HEADLEN FIXED BIN(31),           /* LENGTH OF HEADING              */\n  XINDEX FIXED BIN(15),            /* LAST POSITION USED IN XDATA    */\n  YINDEX FIXED BIN(15),            /* LAST POSITION USED IN YDATA    */\n  XLABELS CHAR(15000),             /* STRING CONTAINING X LABELS     */\n  XNUMERIC BIT(1),                 /* INDICATES X IS ENTIRELY NUMERIC*/\n  NOFILE   BIT(1),                 /* INDICATES NO FILE FOUND        */\n  XDATA(6000) FLOAT,               /* ARRAY CONTAINING X DATA        */\n  YDATA(6000) FLOAT,               /* ARRAY CONTAINING Y DATA        */\n  DATA_CONTROL(100) FIXED BIN(31), /* ARRAY CONTAINING NE VALS       */\n  COLUMNS  FIXED BIN(15),          /* NUMBER OF DATA COLUMNS WANTED  */\n  ROWS     FIXED BIN(15),          /* NUMBER OF DATA ROWS FOUND      */\n  KEYS CHAR(400),                  /* STRING OF CHARACTERS CONTAINING*/\n                                   /* THE KEYS.  CONTAINS ALL KEYS   */\n                                   /* CONCATENATED TOGETHER.         */\n  KEYLEN FIXED BIN(15),            /* LENGTH OF EACH KEY.            */\n                                   /* (NUMBER IS GIVEN BY COLUMNS)   */\n  KEYCOUNT FIXED BIN(15),          /* COUNT OF KEYS DISCOVERED       */\n\n  CURRENT_TOKEN CHARACTER(32) VARYING,/* CURRENT INPUT TOKEN         */\n  INREC CHARACTER(32767)           /* CURRENT INPUT RECORD           */\n         VARYING BASED(RECPTR),    /*   WDPSC      */\n  CHARINDEX FIXED BIN(15);         /* INDEX TO CURRENT POSITION      */\n                                   /*  IN INPUT RECORD               */\n\n\n\n\n1GET_FILE: PROCEDURE;\n\n /********************************************************************/\n /*  READS THE INPUT FILE.                                           */\n /*        THIS CONSISTS OF:                                         */\n /*           THE HEADING CARD (CONTAINING THE PLOT TITLE)           */\n /*           THE KEYS CARD    (CONTAINING THE DATA DESCRIPTIONS)    */\n /*           DATA CARDS       (CONTAINING THE X AND Y DATA)         */\n /*                                                                  */\n /*  IT SETS (SOMETIMES BY SUBROUTINES):                             */\n /*                                                                  */\n /*  HEADING TO THE HEADING TEXT,  HEADLEN TO THE HEADING LENGTH     */\n /*  KEYS    TO THE KEY     TEXT,  KEYLEN  TO THE KEY     LENGTH     */\n /*  ROWS  TO THE NUMBER OF ROWS OF INPUT DATA.                      */\n /*  COLUMNS TO THE NUMBER OF COLUMNS (COMPONENTS+1)                 */\n /*  XLABELS TO THE XDATA LABELS,  YDATA TO THE YDATA VALUES         */\n /*  XDATA   TO THE XDATA VALUES IF THEY ARE NUMERIC.                */\n /*  XNUMERIC INDICATES THIS HAS BEEN DONE.                          */\n /********************************************************************/\n   CALL ADMUSP6O(FILE_NAME,RETCODE1);/* OPEN THE INPUT FILE          */\n   IF RETCODE1 = 4 THEN           /* CHECK ITS EXISTENCE            */\n     MESSAGE = 'DATA FILE NOT FOUND';\n   IF RETCODE1 = 8 THEN           /* CHECK ITS EXISTENCE            */\n     MESSAGE = 'DATA FILE OPEN ERROR';\n\n   IF MESSAGE = '' THEN            /* IF NO ERROR                    */\n     CALL GET_HEAD;                /* READ IN HEADING DATA           */\n\n   IF MESSAGE = '' THEN            /* IF NO ERROR                    */\n     CALL GET_KEYS;                /* READ IN THE KEY DATA           */\n\n   COLUMNS = KEYCOUNT+1;           /* THERE IS ONE COLUMN FOR EACH   */\n                                   /* KEY GIVEN PLUS ONE FOR XDATA   */\n   IF MESSAGE = '' THEN            /* IF NO ERROR                    */\n     CALL GET_MATRIX;              /* READ IN THE INPUT MATRIX       */\n\n   IF MESSAGE = '' THEN            /* IF ALL WENT WELL:              */\n    DO;                            /* RECORD THE DATA IN CHART       */\n                                   /* CONTROL STRUCTURE.             */\n  IF NG > 0 THEN DO;\n     PCSNE = MAXNE;                /* SET NUMBER OF ELEMENTS         */\n     PCSNC = NG   ;                /* SET NUMBER OF COMPONENTS       */\n                 END;\n            ELSE DO;\n     PCSNE = ROWS;                 /* SET NUMBER OF ELEMENTS         */\n     PCSNC = KEYCOUNT;             /* SET NUMBER OF COMPONENTS       */\n                 END;\n     PCSHEADL = HEADLEN;           /* HEADING LENGTH                 */\n     PCSKEYL =  KEYLEN;            /* KEY ITEM LENGTH                */\n     PCSLABL =  LABELLEN;          /* LABEL LENGTH                   */\n    END;\n   ELSE\n    DO;                            /* IF THERE IS A MESSAGE FROM     */\n     PCSNE = 0;                    /* THE FILE FETCH, SET THE ROWS   */\n     PCSNC = 0;                    /* AND COLUMNS TO ZERO.           */\n    END;                           /* (CAN CALL CHART WITH NO DATA)  */\n\n   IF RETCODE1 < 4 THEN\n      CALL ADMUSP6C(RETCODE);      /* CLOSE THE INPUT FILE           */\n END;                              /* OF GET FILE PROCEDURE          */\n\n\n1GET_HEAD: PROCEDURE;\n\n /********************************************************************/\n /*  READS A SINGLE INPUT RECORD CONTAINING THE HEADING TEXT.        */\n /*  LEADING AND TRAILING BLANKS ARE IGNORED.                        */\n /*   - SETS HEADING TO THE TEXT, HEADLEN TO THE LENGTH.             */\n /********************************************************************/\n\n  CALL ADMUSP6R(RECPTR,RETCODE);   /* FETCH THE HEADING RECORD       */\n  IF RETCODE > 0 THEN              /* IF RETURN CODE NON ZERO,       */\n    DO;                            /* DIAGNOSE -                     */\n      IF RETCODE = 4 THEN\n        MESSAGE = 'NO HEADING RECORD';\n      ELSE\n        MESSAGE = 'ERROR READING FILE';\n    END;\n  ELSE                             /* OK, RECORD FETCHED             */\n   DO;                             /* THERE IS A RECORD THERE:       */\n    CHARINDEX = 1;                 /* SET INITIAL POSITION           */\n\n    /*****************************************************************/\n    /*  SCAN OVER ANY INITIAL BLANKS                                 */\n    /*****************************************************************/\n    DO WHILE ((SUBSTR(INREC,CHARINDEX,1) = ' ')\n         & (CHARINDEX \u00ac> LENGTH(INREC)));\n      CHARINDEX = CHARINDEX + 1;\n    END;\n\n    /*****************************************************************/\n    /*  SET HEADING LENGTH, ASSUMING THERE ARE NO TRAILING BLANKS    */\n    /*****************************************************************/\n    HEADLEN = LENGTH(INREC) - CHARINDEX + 1;\n\n    /*****************************************************************/\n    /*   EITHER INPUT CHARACTER IS NON BLANK OR CHARINDEX            */\n    /*   IS GREATER THAN THE INPUT RECORD LENGTH.                    */\n    /*    - IN FORMER CASE, SCAN BACKWARDS FROM END OF RECORD.       */\n    /*****************************************************************/\n\n    IF CHARINDEX \u00ac> LENGTH(INREC) THEN\n\n      /***************************************************************/\n      /*   REDUCE HEADLEN UNTIL THE LAST CHARACTER IS NOT A BLANK.   */\n      /***************************************************************/\n\n      DO WHILE (SUBSTR(INREC,CHARINDEX+HEADLEN-1,1) = ' ');\n        HEADLEN = HEADLEN -1;\n      END;\n\n    /*****************************************************************/\n    /*   MOVE HEADING INTO RESERVED SPACE.                           */\n    /*****************************************************************/\n    HEADING = SUBSTR(INREC,CHARINDEX,HEADLEN);\n   END;\n END;                              /* OF GET HEADING PROCEDURE       */\n1GET_KEYS: PROCEDURE;\n\n /********************************************************************/\n /*  READS THE TOKENS FROM A SINGLE INPUT RECORD FOR THE KEY DATA.   */\n /*  EACH TOKEN IS A KEY AND THERE SHOULD BE THE SAME NUMBER OF Y    */\n /*  DATA COLUMNS.                                                   */\n /********************************************************************/\n\n\n  KEYLEN = 0;                      /* INITIALISE KEY LENGTH          */\n  KEYCOUNT = 0;                    /* AND NUMBER OF KEYS             */\n  CHARINDEX = 1;                   /* INITIALISE CHARACTER INDEX     */\n\n  CALL ADMUSP6R(RECPTR,RETCODE);   /* FETCH THE KEY RECORD           */\n  IF RETCODE > 0 THEN              /* IF NON ZERO RETURN */\n    DO;                            /* DIAGNOSE -                     */\n      IF RETCODE = 4 THEN\n        MESSAGE = 'NO KEY DATA SUPPLIED';\n      ELSE\n        MESSAGE = 'ERROR READING FILE';\n    END;\n  ELSE                             /* OK, RECORD FETCHED             */\n   DO UNTIL(CURRENT_TOKEN = '');   /* UNTIL END OF KEYS              */\n\n     CALL GET_TOKEN;               /* GET THE KEY                    */\n     IF CURRENT_TOKEN \u00ac= '' THEN   /* IF IT IS A REAL ONE:           */\n                                   /* APPEND IT TO THE KEY LIST      */\n       CALL APPEND(KEYS,KEYCOUNT,KEYLEN,CURRENT_TOKEN);\n   END;                            /* OF KEY FETCH LOOP              */\n END;                              /* OF GET KEYS PROCEDURE         */\n1GET_MATRIX:PROCEDURE;\n\n /********************************************************************/\n /*  READS THE RECTANGULAR DATA ARRAY FROM THE INPUT FILE.           */\n /*     EACH CARD CONTAINS 1 ROW OF DATA, THAT IS ONE X VALUE        */\n /*     AND COLUMNS Y VALUES.                                        */\n /*  THE X VALUES MAY BE NUMERIC OR ALPHANUMERIC.  THE Y VALUES      */\n /*  MUST BE NUMERIC.                                                */\n /*  AN ALPHANUMERIC VALUE MAY BE ANY TOKEN.  A NUMERIC VALUE        */\n /*  MAY BE ANY TOKEN WHICH PL/I WILL CONVERT TO FLOAT.              */\n /********************************************************************/\n  DECLARE\n    I  FIXED BIN(15);              /* LOCAL INDEX                    */\n\n  XINDEX = 0;                      /* INITIALISE THE ROW INDEX       */\n  ALLROWS = 0;\n  YINDEX = 0;                      /* THE INDEX TO YDATA             */\n  NG = 0;\n  MAXNE = 0;\n  ROWS   = 0;                      /* COUNT OF MATRIX ROWS           */\n  LABELLEN = 0;                    /* AND LENGTH OF X LABELS         */\n\n  ON CONVERSION                    /* IF THERE IS A CONVERSION ERROR */\n    BEGIN;                         /* IN THE DATA EXTRACTION, REPLACE*/\n      ONSOURCE = '0';              /* WITH 0 AND DIAGNOSE            */\n      MESSAGE = 'NON NUMERIC Y VALUE FOUND IN DATA';\n    END;\n\n  END_OF_FILE = '0'B;\n  DO WHILE(END_OF_FILE = '0'B      /* WHILE THERE IS MORE DATA       */\n         & MESSAGE = '');          /* AND NO ERROR IS FOUND.         */\n\n    CALL ADMUSP6R(RECPTR,RETCODE);    /* FETCH NEXT INPUT RECORD     */\n    IF RETCODE  > 0 THEN              /* IF NON ZERO RETURN          */\n      DO;                             /* DIAGNOSE -                  */\n       IF RETCODE = 4 THEN DO;\n         END_OF_FILE = '1'B;\n         DATA_CONTROL(NG) = ROWS;\n         IF ROWS > MAXNE THEN MAXNE = ROWS;\n                           END;\n       ELSE\n         MESSAGE = 'ERROR READING FILE';\n      END;\n    ELSE                            /* OK, RECORD FETCHED             */\n     DO;\n      CALL GET_TUPLE;              /* EXTRACT MATRIX ROW             */\n      ROWS = ROWS + 1;             /* AND COUNT THE NUMBER OF ROWS   */\n     END;\n\n  END;                             /* OF RECORD LOOP                 */\n\n IF NG =  0 THEN DO;\n   PCSPAIR = 0;\n   CALL TRANSPOSE(YDATA,ROWS,COLUMNS-1); /*TRANSPOSE THE Y MATRIX   */\n                 END;\n            ELSE PCSPAIR = 1;\n /********************************************************************/\n /*   ATTEMPT TO CONVERT THE XLABELS TO NUMERIC DATA                 */\n /*   IN XDATA.                                                      */\n /********************************************************************/\n\n  ON CONVERSION\n    BEGIN;                         /* IF A CONVERSION ERROR OCCURS,  */\n      XNUMERIC = '0';              /* SET FLAG TO NON NUMERIC        */\n      GOTO DONE;                   /* AND STOP PROCESSING            */\n    END;\n\n  XNUMERIC = '1'B;               /* ASSUME IT WILL WORK SUCCESSFULLY */\n  DO I = 0 TO ALLROWS-1;         /* PROCESS ALL XLABELS              */\n                                 /* CONVERTING THEM TO NUMERIC       */\n    XDATA(I+1) = SUBSTR(XLABELS,I*LABELLEN+1,LABELLEN);\n  END;\n DONE:                           /* PROCESSING FINISHED              */\n  REVERT CONVERSION;\n END;                            /* OF GET MATRIX PROCEDURE          */\n1GET_TUPLE: PROCEDURE;\n\n /********************************************************************/\n /*  READS A MATRIX ROW FROM A SINGLE INPUT RECORD.                  */\n /*  THE FIRST TOKEN ON THE CARD IS THE XLABEL AND IS CONCATENATED   */\n /*  INTO THE XLABEL ARRAY.   THE REMAINING TOKENS ARE CONVERTED     */\n /*  TO NUMERIC AND PLACED IN THE YDATA ARRAY.                       */\n /*  THE NUMBER OF ITEMS EXPECTED  IS  THE VARIABLE COLUMNS.         */\n /********************************************************************/\n  DCL I FIXED BIN(15);             /* INDEX TO ITEMS FETCHED         */\n\n  CHARINDEX = 1;                   /* INITIALISE CHARACTER POINTER   */\n /********************************************************************/\n /*  FIRST DO THE FIRST COLUMN, WHICH GOES INTO XLABELS.             */\n /********************************************************************/\n  IF XINDEX+1 > HBOUND(XDATA,1) THEN /* CHECK WHETHER TOO MANY ITEMS.*/\n   MESSAGE = 'TOO MANY DATA ITEMS';/* AND IF SO DIAGNOSE IT.         */\n\n  CALL GET_TOKEN;                  /* GET THE ITEM                   */\n  IF (CURRENT_TOKEN = '=NG') | (CURRENT_TOKEN = '=ng') THEN DO;\n     CALL GET_TOKEN;               /* GET THE KEY                    */\n     IF CURRENT_TOKEN \u00ac= '' THEN   /* IF IT IS A REAL ONE:           */\n                                   /* APPEND IT TO THE KEY LIST      */\n       CALL APPEND(KEYS,KEYCOUNT,KEYLEN,CURRENT_TOKEN);\n     DATA_CONTROL(NG) = ROWS;\n     NG = NG + 1 ;\n     IF ROWS > MAXNE THEN MAXNE = ROWS;\n     ROWS = -1;\n     COLUMNS = 2;\n                                END;\n                           ELSE DO;\n     ALLROWS = ALLROWS + 1;\n\n  IF XINDEX <= HBOUND(XDATA,1) THEN/* PROVIDED IT WILL FIT THE ARRAY */\n                                   /* APPEND TOKEN TO LABEL LIST     */\n    CALL APPEND(XLABELS,XINDEX,LABELLEN,CURRENT_TOKEN);\n\n /********************************************************************/\n /*  THEN DO THE REMAINING COLUMNS WHICH GO INTO YARRAY.             */\n /********************************************************************/\n\n  DO I = 2 TO COLUMNS;             /* FOR ALL COLUMNS EXPECTED,      */\n\n   YINDEX = YINDEX + 1;            /* INCREMENT YINDEX FOR NEXT SLOT */\n   IF YINDEX > HBOUND(YDATA,1) THEN /*CHECK WHETHER TOO MANY ITEMS.  */\n    MESSAGE = 'TOO MANY DATA ITEMS';/*AND ASSIGN IT INTO YDATA ARRAY */\n\n   CALL GET_TOKEN;                 /* GET THE ITEM                   */\n   IF YINDEX <= HBOUND(YDATA,1)    /* PROVIDED IT WILL FIT THE ARRAY */\n   THEN\n    YDATA(YINDEX) = CURRENT_TOKEN; /* ASSIGN IT IN (MAY NOT CONVERT) */\n\n  END;                             /* OF Y VALUE EXTRACTION          */\n                                END;\n END;                              /* OF GET TUPLE PROCEDURE         */\n\n1GET_TOKEN: PROCEDURE;\n\n /********************************************************************/\n /*  READS A SINGLE TOKEN FROM THE INPUT RECORD AND PLACES           */\n /*  IT IN CURRENT_TOKEN.                                            */\n /*  A TOKEN IS EITHER:                                              */\n /*     AS SERIES OF UP TO 32 ALPHANUMERIC CHARACTERS WITHOUT        */\n /*      IMBEDDED BLANKS.                                            */\n /*  OR A NULL STRING   (INDICATING NO INPUT).                       */\n /*   IF AN _ CHARACTER IS FOUND IT IS CHANGED TO A BLANK            */\n /********************************************************************/\n\n DECLARE\n   TOKEN_START FIXED BIN(15);      /* INDEX OF FIRST CHARACTER       */\n                                   /* IN THE TOKEN                   */\n /********************************************************************/\n /*  SCAN OVER ANY INITIAL BLANKS                                    */\n /********************************************************************/\n DO WHILE ((SUBSTR(INREC,CHARINDEX,1) = ' ')\n         & (CHARINDEX \u00ac> LENGTH(INREC)));\n   CHARINDEX = CHARINDEX + 1;\n END;\n /********************************************************************/\n /*  NOW EITHER INPUT CHARACTER IS NON BLANK OR CHARINDEX            */\n /*  IS GREATER THAN THE INPUT RECORD LENGTH.                        */\n /*    - IN FORMER CASE, SCAN TO NEXT BLANK.                         */\n /********************************************************************/\n IF CHARINDEX \u00ac> LENGTH(INREC) THEN\n  DO;                              /* THE INPUT POSITION IS VALID    */\n    TOKEN_START = CHARINDEX;       /* NOTE TOKEN START               */\n                                   /* SCAN TO THE END OF THE TOKEN   */\n                                   /* IE TO NEXT NON BLANK           */\n    DO WHILE ((SUBSTR(INREC,CHARINDEX,1) \u00ac= ' ')\n             & (CHARINDEX \u00ac> LENGTH(INREC)));\n                    /* REPLACE ANY  _ BY BLANK */\n      IF SUBSTR(INREC,CHARINDEX,1)  = '_' THEN\n         SUBSTR(INREC,CHARINDEX,1)  = ' ';\n      CHARINDEX = CHARINDEX + 1;\n    END;\n                                   /* COPY TOKEN TO CURRENT_TOKEN    */\n    CURRENT_TOKEN = SUBSTR(INREC,TOKEN_START,CHARINDEX-TOKEN_START);\n  END;\n ELSE                              /* INPUT POSITION INVALID,        */\n    CURRENT_TOKEN = '';            /* SET CURRENT TOKEN TO NULL      */\n END;                              /* OF GET TOKEN PROCEDURE         */\n1APPEND:PROCEDURE(STRING_ARRAY,ITEMS,STRING_LENGTH,TOKEN);\n /********************************************************************/\n /*   CONCATENTATES A TOKEN ONTO A STRING ARRAY.                     */\n /*     - THE STRING ARRAY IS A STRING CONTAINING ZERO OR MORE       */\n /*       TOKENS.  THESE ARE ALL CONCATENATED TOGETHER AND EACH IS   */\n /*       PADDED TO THE LENGTH OF THE LONGEST TOKEN.                 */\n /*     - THE STRING ARRAY, THE ITEM COUNT AND THE STRING LENGTH     */\n /*       ARE ALL SET BY THE PROCEDURE.                              */\n /********************************************************************/\n DECLARE\n    STRING_ARRAY CHAR(*),          /* THE CHARACTER STRING CONTAINING*/\n                                   /* THE TOKENS.                    */\n    ITEMS         FIXED BIN(15),   /* THE NUMBER OF TOKENS ALREADY   */\n                                   /* HELD IN THE STRING ARRAY.      */\n    STRING_LENGTH FIXED BIN(15),   /* THE LENGTH OF TOKENS IN THE    */\n                                   /* STRING ARRAY.                  */\n    TOKEN CHAR(32) VARYING,        /* THE TOKEN TO BE ADDED.         */\n\n    NEWLENGTH    FIXED BIN(15),    /* TEMPORARY TO CONTAIN NEW LEN   */\n    I            FIXED BIN(15);    /* TEMPORARY COUNTER              */\n\n IF LENGTH(TOKEN) > STRING_LENGTH  THEN\n   DO;\n    /*****************************************************************/\n    /*  THE NEW TOKEN IS LONGER THAN THE OLD ONES, SO REFORMAT       */\n    /*  THE STRING ARRAY FOR THE LONGER TOKENS.                      */\n    /*****************************************************************/\n    NEWLENGTH = LENGTH(TOKEN);            /* NEW STRING LENGTH       */\n    IF NEWLENGTH*ITEMS > LENGTH(STRING_ARRAY) THEN\n      MESSAGE = 'TOO MUCH STRING DATA';\n    ELSE                           /* IF ENOUGH ROOM THEN            */\n     DO;\n      DO I = ITEMS-1 TO 0 BY -1;   /*      PROCESS ALL STRINGS BY    */\n                                   /*      MOVING THEM ABOUT         */\n        SUBSTR(STRING_ARRAY,I*NEWLENGTH+1,NEWLENGTH)\n            = SUBSTR(STRING_ARRAY,I*STRING_LENGTH+1,STRING_LENGTH);\n      END;\n      STRING_LENGTH = NEWLENGTH;   /*  AND RESET STRING LENGTH.      */\n     END;\n   END;                            /*        END OF KEY REFORMAT     */\n /********************************************************************/\n /* NOW INSERT THE NEW KEY, EXPANDING TO KEYLEN.                     */\n /********************************************************************/\n ITEMS = ITEMS + 1;                /* INCREASE ITEM COUNT.           */\n IF STRING_LENGTH*ITEMS > LENGTH(STRING_ARRAY) THEN\n    MESSAGE = 'TOO MUCH STRING DATA';\n ELSE                              /* IF THERE IS ENOUGH ROOM THEN:  */\n                                   /* INSERT THE TOKEN               */\n  SUBSTR(STRING_ARRAY,(ITEMS-1)*STRING_LENGTH+1,STRING_LENGTH) = TOKEN;\n END;                              /* OF APPEND PROCEDURE            */\n1TRANSPOSE: PROCEDURE(INARRAY,ROWS,COLUMNS);\n /********************************************************************/\n /*   TRANSPOSES THE MATRIX INARRAY.                                 */\n /*     - THE ARRAY IS ASSUMED TO HAVE ROWS ROWS AND COLUMNS         */\n /*       COLUMNS.                                                   */\n /*     - ON INPUT IT IS STORED WITH THE ROW INDEX VARYING MOST      */\n /*       RAPIDLY. ON OUTPUT THE COLUMN INDEX VARIES MOST RAPIDLY    */\n /********************************************************************/\n DECLARE\n    INARRAY (*) FLOAT,             /* THE INPUT ARRAY.               */\n    ROWS          FIXED BIN(15),   /* THE NUMBER OF ROWS OF DATA     */\n    COLUMNS       FIXED BIN(15),   /* THE NUMBER OF COLUMNS          */\n    (I,J)         FIXED BIN(15),   /* TEMPORARY INDEXES              */\n    TEMP(ROWS*COLUMNS) FLOAT;      /* TEMPORARY USED IN CONVERSION   */\n\n    DO I = 0 TO ROWS-1;            /* TRANSPOSE THE MATRIX INTO TEMP */\n      DO J = 0 TO COLUMNS-1;\n        TEMP(J*ROWS+I+1) = INARRAY(I*COLUMNS+J+1);\n      END;\n    END;\n    DO I = 1 TO ROWS*COLUMNS;      /* AND COPY IT BACK TO INARRAY    */\n        INARRAY(I) = TEMP(I);\n    END;\n END;                              /* OF TRANSPOSE PROCEDURE         */\n\n\n END;                              /* OF ADMUSP6                     */\n*PROCESS;\n1ERRPROC : PROCEDURE(AB,ERRORBLOCK) OPTIONS(COBOL);\n /********************************************************************/\n /*   PROCEDURE NOMINATED AS ERROR EXIT BY AN FSEXIT CALL.           */\n /*     - RECEIVES CONTROL WHEN AN ERROR IS DETECTED.                */\n /*       THE PARAMETER PASSED IS NOT IN ACCEPTABLE PL/I FORMAT      */\n /*       SO THE PROCEDURE IS DECLARED OPTIONS COBOL                 */\n /*     - THE APPLICATION ANCHOR BLOCK PASSED BY GDDM CONTAINS       */\n /*       THE ADDRESS OF THE MESSAGE AREA IN THE USER EXTENSION.     */\n /*       THIS AREA IS SET TO THE MESSAGE TEXT.                      */\n /*     - THE PROCEDURE IS INCLUDED IN THE MAIN COMPILATION FOR      */\n /*       CONVENIENCE, HOWVER LOGICALLY IT IS EXTERNAL.              */\n /********************************************************************/\n DECLARE\n   1 ERRORBLOCK,                   /* THAT PART OF REQUIRED          */\n      2 SEVERITY FIXED BIN(31),    /* THE ERROR SEVERITY             */\n      2 NUMBER   FIXED BIN(31),    /* THE ERROR NUMBER               */\n      2 FNAME    CHARACTER(8),     /* THE FUNCTION NAME              */\n      2 MSGLEN   FIXED BIN(31),    /* MESSAGE LENGTH                 */\n      2 MSGTEXT  CHARACTER(80);    /* MESSAGE TEXT                   */\n DECLARE                          /* GDDM ANCHOR BLOCK              */\n    1 AB,\n       2  AABSC   FIXED BIN(15),   /* SEVERITY CODE                  */\n       2  AABEC   FIXED BIN(15),   /* ERROR CODE                     */\n       2  AABAP   CHARACTER(4),    /* GDDM ANCHOR, ACTUALLY A POINTER*/\n       2  MESSAGE CHARACTER(60);   /* MESSAGE TEXT RETURNED          */\n\n   MESSAGE = SUBSTR(MSGTEXT,1,LENGTH(MESSAGE));\n END;                              /* OF ERRPROC  PROCEDURE          */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ADMUSP6B": {"ttr": 2053, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x00\\x7f\\x00\\x88\\x00\\x7f\\x12\\x00\\x03N\\x03N\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf2\\xf7\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-01-07T00:00:00", "modifydate": "1988-01-07T12:00:00", "lines": 846, "newlines": 846, "modlines": 0, "user": "FILE270"}, "text": "        /* DATA SET 761GSUSP6  AT LEVEL 002 AS OF 09/28/87    */\n ADMUSP6:PROCEDURE(PARMLIST) OPTIONS(MAIN);\n         DECLARE PARMLIST CHAR(100) VARYING;\n /********************************************************************/\n /*                      ADMUSP6                                     */\n /*                                                                  */\n /*       APPLICATION TO PLOT THE DATA IN A NAMED FILE USING         */\n /*                THE 'CHART' UTILITY.                              */\n /*                                                                  */\n /*                                                                  */\n /*  INPUT PARAMETERS:                                               */\n /*                                                                  */\n /*           MEM            PDS MEMBER NAME CONTAINING DATA         */\n /*           PRT            PRINTER NAME FOR PRINTING GRAPH         */\n /*           FMT            NAME OF CHART FORMAT                    */\n /*           DEP            PRINTER DEPTH (ROWS) TO PRINT           */\n /*           WID            PRINTER WIDTH (COLS) TO PRINT           */\n /*           COP            NUMBER OF COPIES TO PRINT               */\n /*           HED            PRINTER HEADER PAGE CONTROL             */\n /*           VOF            PRINTER VERTICAL OFFSET                 */\n /*           HOF            PRINTER HORIZONTAL OFFSET               */\n /*           UNT            PRINTER LAYOUT PARAMETER UNITS          */\n /*                                                                  */\n /*   THE PROGRAM REQUIRES THAT PARAMETERS \"MEM\" AND \"PRT            */\n /*   BE SPECIFIED.  THE REMAINDER ARE OPTIONAL.                     */\n /*                                                                  */\n /*  PARAMETER FORMAT:                                               */\n /*     '/MEM=''XXXXXX'',FMT=''XXX'',PRT=''XXXXXXXX'',COP=2;'        */\n /*     (CHARACTER STRING OPTIONS MUST BE DOUBLE QUOTED!!!)          */\n /*                                                                  */\n /*                 .......*****........                             */\n /*                                                                  */\n /*   DATA FILE FORMAT:                                              */\n /*       THE FILE MUST CONSIST OF A NUMBER OF (80 BYTE)             */\n /*       RECORDS WHICH GIVE A TABLE OF DATA TO BE PLOTTED.          */\n /*       THE RECORDS ARE FORMATTED AS FOLLOWS:                      */\n /*                                                                  */\n /*        RECORD 1.                                                 */\n /*           CONTAINS THE CHART HEADING.                            */\n /*           LEADING AND TRAILING BLANKS ARE REMOVED FROM THE       */\n /*           TEXT SUPPLIED IN THE RECORD AND THE RESULTING          */\n /*           STRING IS USED TO TITLE THE GENERATED CHART.           */\n /*                                                                  */\n /*        RECORD 2.                                                 */\n /*           CONTAINS THE COLUMN HEADINGS OF THE TABLE,             */\n /*           WHICH WILL FORM THE CHART KEYS.  THESE KEYS            */\n /*           MUST BE SINGLE WORDS (WITHOUT IMBEDDED BLANKS)         */\n /*           OF NOT MORE THAN 32 CHARACTERS.                        */\n /*           OCCURRENCES OF UNDERSCORE CHARACTERS (_)               */\n /*           IN A WORD ARE REPLACED BY BLANKS SO THAT               */\n /*           BLANK CHARACTERS MAY BE GENERATED IN THE KEY           */\n /*           TEXT IF REQUIRED.                                      */\n /*                                                                  */\n /*           ONE WORD SHOULD BE PROVIDED FOR EACH DATA COLUMN       */\n /*           TO BE PLOTTED (EXCEPT THE FIRST WHICH IS USED AS       */\n /*           THE X DATA).                                           */\n /*                                                                  */\n /*        RECORDS 3 - N                                             */\n /*           CONTAIN THE TABLE OF DATA.    EACH RECORD              */\n /*           CONTAINS ONE TABLE ROW.  THE FIRST WORD IS THE         */\n /*           'X VALUE' FOR THE ROW, FURTHER WORDS ARE THE Y         */\n /*           VALUES.  THERE SHOULD BE ONE Y VALUE FOR EACH          */\n /*           KEY SPECIFIED ON THE KEY RECORD (RECORD 2).            */\n /*           X VALUES MAY BE NUMERIC OR ALPHANUMERIC.  Y VALUES     */\n /*           MUST BE NUMERIC, THAT IS THEY SHOULD BE CONVERTIBLE    */\n /*           TO FLOATING POINT NUMBERS BY THE NORMAL PL/I           */\n /*           CHARACTER TO ARITHMETIC CONVERSION.                    */\n /*                                                                  */\n /*      SAMPLE DATA MIGHT BE:                                       */\n /*                                                                  */\n /*               HISTORY OF RESULTS FOR XYZ LTD.                    */\n /*                   COSTS       SALES                              */\n /*        1975        320         120                               */\n /*        1976        330         340                               */\n /*        1977        430         520                               */\n /*        1978        550         630                               */\n /*        1979        620         640                               */\n /*                                                                  */\n /*                                                                  */\n /********************************************************************/\n DECLARE\n\n\n   1 ADMTPCS,                     /* PANEL CONTROL STRUCTURE.        */\n    2 PCSLEVEL           /* NUMBER IDENTIFYING THE CHART LEVEL USED. */\n        FIXED BIN(31)    /* 1 = CHART UTILITY RELEASE 3 ONWARDS      */\n         INIT(1),\n    2 PCSDISP            /* 0 = THE DATA CONTAINED IN \"DATA_CONTROL\" */\n        FIXED BIN(31)    /*     \"X\", \"Y\", \"KEYS\", \"LABELS\" AND       */\n         INIT(4),        /*     \"HEADING\" IS SAVED ONTO THE FILE     */\n                         /*     INDICATED BY PCSDNAME. NO PANELS ARE */\n                         /*     PRESENTED BEFORE RETURNING TO THE    */\n                         /*     APPLICATION PROGRAM.                 */\n                         /* 1 = THE \"HOME\" PANEL IS PRESENTED TO THE */\n                         /*     OPERATOR.                            */\n                         /* 2 = THE DISPLAY PANEL IS PRESENTED TO    */\n                         /*     THE OPERATOR USING THE SUPPLIED DATA */\n                         /*     AND CHART FORMAT. THE OPERATOR THEN  */\n                         /*     HAS THE CHOICE OF THE \"HOME\" PANEL,  */\n                         /*     OR RETURNING TO THE APPLICATION      */\n                         /*     PROGRAM.                             */\n                         /* 3 = THE DISPLAY PANEL IS PRESENTED TO    */\n                         /*     THE OPERATOR USING THE SUPPLIED DATA */\n                         /*     AND CHART FORMAT. THE \"HOME\" PANEL   */\n                         /*     IS NOT AVAILABLE, BUT THE \"PRINT\",   */\n                         /*     \"HELP\" AND \"SAVE\" FUNCTIONS MAY BE   */\n                         /*     AVAILABLE.                           */\n                         /* 4 = THE DATA CONTAINED IN \"DATA_CONTROL\" */\n                         /*     \"X\", \"Y\", \"KEYS\", \"LABELS\" AND       */\n                         /*     \"HEADING\" IS PRINTED (1 COPY).       */\n                         /*     RETURN IS MADE DIRECTLY TO THE       */\n                         /*     APPLICATION PROGRAM.                 */\n    2 PCSHELP            /* 0 = PF KEY ASSIGNMENTS ARE NOT DISPLAYED */\n        FIXED BIN(31)    /*     INITIALLY ON THE DISPLAY PANEL. THIS */\n           INIT(0),      /*     SETTING MAY BE CHANGED BY USE OF     */\n                         /*     ENTER WHENEVER THE DISPLAY PANEL IS  */\n                         /*     PRESENTED.                           */\n                         /* 1 = PF KEY ASSIGNMENTS ARE DISPLAYED     */\n                         /*     INITIALLY ON THE DISPLAY PANEL. THIS */\n                         /*     SETTING MAY BE CHANGED BY USE OF     */\n                         /*     ENTER WHENEVER THE DISPLAY PANEL IS  */\n                         /*     PRESENTED.                           */\n                         /* IGNORED IF PCSDISP=0, OR IF PCSDISP=4.   */\n    2 PCSISOL            /* 0 = SAVE AND RESTORE MENU PANELS ARE     */\n        FIXED BIN(31)    /*     MADE AVAILABLE TO THE OPERATOR.      */\n          INIT(1),       /* 1 = SAVE AND RESTORE MENU PANELS ARE NOT */\n                         /*     MADE AVAILABLE TO THE OPERATOR.      */\n                         /* IGNORED IF PCSDISP=0 OR PCSDISP=4.       */\n    2 PCSFNAME CHAR(8)   /* NAME OF PREVIOUSLY SAVED CHART FORMAT TO */\n          INIT('*'),     /* BE USED INITIALLY. THE NAME '*' IS       */\n                         /* RESERVED TO INDICATE THE DEFAULT CHART   */\n                         /* FORMAT. IGNORED IF PCSDISP=0.            */\n    2 PCSDNAME CHAR(8)   /* FOR PCSDISP=0, THE NAME UNDER WHICH THE  */\n          INIT('*'),     /* CHART DATA CONTAINED IN \"DATA_CONTROL\",  */\n                         /* \"X\", \"Y\", \"KEYS\", \"LABELS\" AND \"HEADING\" */\n                         /* IS TO BE SAVED.                          */\n                         /* FOR PCSDISP\u00ac=0, THE NAME OF A PREVIOUSLY */\n                         /* SAVED CHART DATA FILE TO BE USED INIT-   */\n                         /* -IALLY OR FOR PRINTING. THE NAME '*'     */\n                         /* INDICATES THAT THE DATA CONTAINED IN     */\n                         /* \"DATA_CONTROL\", \"X\", \"Y\", \"KEYS\",        */\n                         /* \"LABELS\" AND \"HEADING\" IS TO BE USED.    */\n    2 PCSPAIR            /* 0 = \"X\" AND \"Y\" DATA GROUPS ARE NOT      */\n        FIXED BIN(31)    /*     PAIRED. THERE IS ONLY ONE \"X\" DATA   */\n           INIT(0),      /*     GROUP, OR SET OF \"LABELS\", WHICH IS  */\n                         /*     PLOTTED AGAINST EACH \"Y\" DATA GROUP. */\n                         /*     IN THIS MODE OF OPERATION, THERE MAY */\n                         /*     BE RESTRICTIONS ON THE NUMBER OF \"Y\" */\n                         /*     DATA GROUPS WHICH CAN BE DISPLAYED   */\n                         /*     AT ANY ONE TIME.                     */\n                         /* 1 = \"X\" AND \"Y\" DATA GROUPS ARE PAIRED.  */\n                         /*     FOR EACH \"Y\" DATA GROUP THERE IS A   */\n                         /*     UNIQUE \"X\" DATA GROUP AGAINST WHICH  */\n                         /*     IT IS PLOTTED WHEN SELECTED. IN THIS */\n                         /*     MODE OF OPERATION, SOME SHADING      */\n                         /*     OPTIONS MAY BE IGNORED WHEN          */\n                         /*     DISPLAYED. IF \"LABELS\" ARE PROVIDED  */\n                         /*     INSTEAD OF \"X\", THEN EACH \"Y\" DATA   */\n                         /*     GROUP IS MATCHED VALUE FOR LABEL     */\n                         /*     AGAINST \"LABELS\" UNTIL THE DATA      */\n                         /*     GROUP IS EXHAUSTED.                  */\n                         /* IGNORED IF PCSDISP\u00ac=0 AND PCSDNAME\u00ac='*'. */\n    2 PCSNC              /* MAXIMUM NO. OF DATA GROUPS. FOR          */\n        FIXED BIN(31)    /* PCSPAIR=1, THE NUMBER OF DATA GROUPS FOR */\n           INIT(0),      /* WHICH STORAGE IS PROVIDED IN \"X\" (FOR    */\n                         /* PCSLABL=0) AND \"Y\", AND ALSO THE NO. OF  */\n                         /* VALUES IN \"DATA_CONTROL\". FOR PCSPAIR=0, */\n                         /* THE NUMBER OF DATA GROUPS FOR WHICH      */\n                         /* STORAGE IS PROVIDED IN \"Y\". RANGE 0      */\n                         /* THROUGH 999.                             */\n                         /* IGNORED IF PCSDISP\u00ac=0 AND PCSDNAME\u00ac='*'. */\n    2 PCSNE              /* MAXIMUM NO. OF ELEMENTS. THE NUMBER OF   */\n        FIXED BIN(31)    /* VALUES (PER DATA GROUP) FOR WHICH        */\n           INIT(0),      /* STORAGE IS PROVIDED IN \"X\" (FOR          */\n                         /* PCSLABL=0) AND \"Y\", AND ALSO THE NO. OF  */\n                         /* LABELS IN \"LABELS\" (FOR PCSLABL\u00ac=0).     */\n                         /* RANGE 0 THROUGH 999.                     */\n                         /* IGNORED IF PCSDISP\u00ac=0 AND PCSDNAME\u00ac='*'. */\n    2 PCSKEYL            /* LENGTH OF EACH STRING IN \"KEYS\". RANGE 0 */\n        FIXED BIN(31)    /* THROUGH 132.                             */\n           INIT(0),      /* IGNORED IF PCSDISP\u00ac=0 AND PCSDNAME\u00ac='*', */\n                         /* OR IF PCSNC = 0.                         */\n    2 PCSLABL            /* LENGTH OF EACH STRING IN \"LABELS\". RANGE */\n        FIXED BIN(31)    /* 0 THROUGH 132.                           */\n          INIT(0),       /* IGNORED IF PCSDISP\u00ac=0 AND PCSDNAME\u00ac='*', */\n                         /* OR IF PCSNE=0.                           */\n    2 PCSHEADL           /* LENGTH OF THE CHART \"HEADING\". RANGE 0   */\n        FIXED BIN(31)    /* THROUGH 132.                             */\n          INIT(0),       /* IGNORED IF PCSDISP\u00ac=0 AND PCSDNAME\u00ac='*'. */\n    2 PCSPNAME CHAR(8)   /* PRINTER DESTINATION NAME. ' ' INDICATES  */\n          INIT(' '),     /* NO PRINTER. '*' INDICATES THAT THE NAME  */\n                         /* IS UNKNOWN, IN WHICH CASE THE OPERATOR   */\n                         /* IS PROMTED FOR THE NAME AS REQUIRED).    */\n                         /* IGNORED IF PCSDISP=0. THESE RESERVED     */\n                         /* NAMES ARE NOT VALID FOR PCSDISP=4.       */\n                         /********************************************/\n                         /* NOTE THAT THE DEFINITION OF THE NEXT     */\n                         /* TWO FIELDS HAVE BEEN CHANGED TO          */\n                         /* 'FLOAT DEC(6) FROM RELEASE 3 ONWARD      */\n                         /********************************************/\n    2 PCSPRDEP           /* DEPTH IN ROWS OF THE CHART AREA ON THE   */\n        FLOAT DEC(6)     /* PRINTER. RANGE 1 THROUGH 132. IGNORED IF */\n          INIT(64),      /* PCSDISP=0, OR IF PCSPNAME=' ', OR IF     */\n                         /* PCSPNAME='*'.                            */\n    2 PCSPRWID           /* WIDTH IN COLUMNS OF THE CHART AREA ON THE*/\n        FLOAT DEC(6)     /* PRINTER. RANGE 1 THROUGH 132. IGNORED IF */\n          INIT(120),     /* PCSDISP=0, OR IF PCSPNAME=' ', OR IF     */\n                         /* PCSPNAME='*'.                            */\n    2 PCSPCOPY           /* NO. OF COPIES REQUIRED FOR PRINT.        */\n        FIXED BIN(31)    /* IGNORED IF PCSDISP\u00ac=4.                   */\n          INIT(1),\n                             /****************************************/\n                             /* THE REMAINING FIELDS ARE NEW FROM    */\n                             /* RELEASE 3 ONWARDS. THEY ARE NOT USED */\n                             /* IN THIS APPLICATION, EXCEPT PCSUNIT  */\n                             /****************************************/\n    2 PCSPHEAD FIXED BIN(31) /* PRINTER HEADER PAGE CONTROL          */\n               INIT(0),      /* 0 = DEFAULT, HEADER PAGE OUTPUT      */\n    2 PCSPVOFF FLOAT DEC(6)  /* PRINTER VERTICAL OFFSET (ROWS)       */\n               INIT(0),      /*                                      */\n    2 PCSPHOFF FLOAT DEC(6)  /* PRINTER HORIZONTAL OFFSET (COLUMNS)  */\n               INIT(0),      /*                                      */\n    2 PCSPUNIT FIXED BIN(31) /* PRINTER LAYOUT PARAMETER UNITS       */\n               INIT(4),      /* 4 = ROWS AND COLUMNS                 */\n    2 PCSDUMMY FIXED BIN(31) /* RESERVED                             */\n               INIT(0),      /*                                      */\n    2 PCSDYNAM CHAR(8)       /* DIRECTORY LISTING OBJECT NAME        */\n               INIT(' '),    /*                                      */\n    2 PCSDYTYP FIXED BIN(31) /* DIRECTORY LISTING OBJECT TYPE        */\n               INIT(0),      /* 0 = DEFAULT, NO INITIAL LIST         */\n    2 PCSDYTYQ FIXED BIN(31) /* DIRECTORY LISTING OBJECT SUBTYPE     */\n               INIT(0),      /* 0 = DEFAULT                          */\n    2 PCSDYLIB CHAR(8)       /* DIRECTORY LISTING OBJECT LIBRARY     */\n               INIT(' '),    /*                                      */\n    2 PCSEXPL  FIXED BIN(31) /* INITIAL EXPERIENCE LEVEL VALUE       */\n               INIT(0);      /* 0 = DEFAULT, STANDARD LEVEL          */\n /********************************************************************/\n /*     END OF PANEL CONTROL STRUCTURE (PCS) DEFINITION.             */\n /********************************************************************/\n\n1 DECLARE\n /********************************************************************/\n /*                                                                  */\n /*       VARIOUS LOCAL VARIABLES                                    */\n /*                                                                  */\n /********************************************************************/\n   END_OF_FILE BIT(1),   /* END OF FILE INDICATOR                    */\n   RETCODE FIXED BIN(31),/* RETURN CODE FROM READ/ CLOSE             */\n   RETCODE1 FIXED BIN(31),/* RETURN CODE FROM OPEN                   */\n   EXIT BIT(1),          /* FLAG USED TO INDICATE EXIT REQUIRED      */\n   ONSOURCE BUILTIN,     /* FORCE IT TO BE BUILTIN                   */\n   FILE_NAME   CHAR(8)   /* DATA FILE NAME                           */\n    INIT('        '),\n   LABELLEN FIXED BIN(15),/* LENGTH OF X LABELS.                     */\n   MEM    CHAR(8)        /* PDS MEMBER NAME CONTAINING DATA          */\n    INIT('        '),\n   PRT    CHAR(8)        /* PRINTER NAME FOR PRINTING GRAPH          */\n    INIT('        '),\n   FMT    CHAR(8)        /* NAME OF CHART FORMAT                     */\n    INIT('*       '),\n   DEP    FLOAT DEC(6)   /* PRINTER DEPTH (ROWS) TO PRINT            */\n    INIT(64),\n   WID    FLOAT DEC(6)   /* PRINTER WIDTH (COLS) TO PRINT            */\n    INIT(120),\n   COP    FIXED BIN(31)  /* NUMBER OF COPIES TO PRINT                */\n    INIT(1),\n   HED    FIXED BIN(31)  /* PRINTER HEADER PAGE CONTROL              */\n    INIT(0),\n   VOF    FLOAT DEC(6)   /* PRINTER VERTICAL OFFSET                  */\n    INIT(0),\n   HOF    FLOAT DEC(6)   /* PRINTER HORIZONTAL OFFSET                */\n    INIT(0),\n   UNT    FIXED BIN(31)  /* PRINTER LAYOUT PARAMETER UNITS           */\n    INIT(4),\n   DEB    CHAR(3)        /* DEBUG MODE FLAG                          */\n    INIT('OFF'),\n   PROCOPT_LIST(10) FIXED BIN(31), /* PROCESSING OPTIONS LIST        */\n   NAME_LIST(1) CHAR(8)            /* DEVICE CONTROL NAME LIST       */\n     INIT('        ');\n\n1 DECLARE                /* ENTRY POINTS FOR ASSEMBLER I/O ROUTINES  */\n   ADMUSP6O ENTRY(CHARACTER(8),\n                  FIXED BIN(31)) OPTIONS(INTER ASSEMBLER),\n   ADMUSP6C ENTRY (FIXED BIN(31)) OPTIONS(INTER ASSEMBLER),\n   ADMUSP6R ENTRY(POINTER,\n                   FIXED BIN(31)) OPTIONS(INTER ASSEMBLER),\n\n   ERRPROC  EXTERNAL ENTRY,/*EXTERNAL ERROR HANDLING PROCEDURE       */\n\n   DUMMY POINTER;        /* DUMMY VARIABLE                           */\n\n DECLARE  (              /* GDDM ENTRY POINTS USED, REENTRANT FORM*/\n  ASCGET ENTRY(*,  BIN FIXED(31),BIN FIXED(31),CHAR(*)               ),\n  ASCPUT ENTRY(*,  BIN FIXED(31),BIN FIXED(31),*                     ),\n  ASDFMT ENTRY(*,  BIN FIXED(31),BIN FIXED(31),(*,*)BIN FIXED(31)    ),\n  ASFCUR ENTRY(*,  BIN FIXED(31),BIN FIXED(31),BIN FIXED(31)         ),\n  ASDFLT ENTRY(*,  BIN FIXED(31),(*) BIN FIXED(31)                   ),\n  ASQMOD ENTRY(*,  BIN FIXED(31),BIN FIXED(31),BIN FIXED(31),\n                   BIN FIXED(31)                                     ),\n  ASFMOD ENTRY(*,  BIN FIXED(31),BIN FIXED(31)                       ),\n  ASREAD ENTRY(*,  BIN FIXED(31),BIN FIXED(31),BIN FIXED(31)         ),\n\n  FSALRM ENTRY(*                                                     ),\n  FSINR  ENTRY(*                                                     ),\n  FSTERM ENTRY(*                                                     ),\n  FSEXIT ENTRY(*,  ENTRY,BIN FIXED(31)                               ),\n  DSOPEN ENTRY(*,  BIN FIXED(31),BIN FIXED(31),CHAR(8),\n                   BIN FIXED(31),(*)BIN FIXED(31) CONN,\n                   BIN FIXED(31),(*)CHAR(8) CONN                     ),\n                                  /* OPEN DEVICE                     */\n  DSUSE  ENTRY(*,  BIN FIXED(31),BIN FIXED(31)                       ),\n                                  /* SPECIFY DEVICE USAGE            */\n  CHART  ENTRY(                                                      )\n         )OPTIONS(ASM,INTER);\n\n  DECLARE                          /* GDDM ANCHOR BLOCK              */\n    1 AB,\n       2  AABSC   FIXED BIN(15),   /* SEVERITY CODE                  */\n       2  AABEC   FIXED BIN(15),   /* ERROR CODE                     */\n       2  AABAP   POINTER,         /* GDDM ANCHOR                    */\n       2  MESSAGE CHARACTER(60)    /* MESSAGE TEXT RETURNED FROM     */\n            INIT(' ');             /* ERROR PROCEDURE                */\n\n\n1/********************************************************************/\n /*                                                                  */\n /*       MAIN PROGRAM                                               */\n /*                                                                  */\n /********************************************************************/\n   CALL FSINR(AB);       /* INITIALISE GDDM FOR RE-ENTRANT CODE      */\n   CALL FSEXIT(AB,ERRPROC ,4);     /* CAUSE ERRORS TO CALL ERRPROC   */\n\n   /******************************************************************/\n   /*   EXTRACT PARAMETER LIST DATA AND PLACE IN ADMTPCS             */\n   /******************************************************************/\n   GET STRING(PARMLIST)\n       DATA(MEM,PRT,FMT,DEP,WID,COP,HED,VOF,HOF,UNT,DEB);\n   FILE_NAME = MEM;                           /* NAME OF DATA FILE   */\n   PCSPNAME  = PRT;                           /* PRINTER NAME        */\n   PCSFNAME  = FMT;\n   PCSPRDEP  = DEP;\n   PCSPRWID  = WID;\n   PCSPCOPY  = COP;\n   PCSPHEAD  = HED;\n   PCSPVOFF  = VOF;\n   PCSPHOFF  = HOF;\n   PCSPUNIT  = UNT;\n\n   /******************************************************************/\n   /*   READ AND PROCESS DATA FROM FILE                              */\n   /******************************************************************/\n   CALL GET_FILE;                             /* GET DATA FROM FILE  */\n   PCSLABL = LABELLEN;                        /* SET LABEL LENGTH    */\n\n   IF DEB = 'ON' THEN\n     PUT DATA(ADMTPCS);         /* DEBUG MODE DISPLAY                */\n\n   /******************************************************************/\n   /*   OPEN DUMMY DEVICE FOR BATCH INVOCATION                       */\n   /******************************************************************/\n   CALL DSOPEN(AB,11,   1,   'L79A3',   0,PROCOPT_LIST,   1,NAME_LIST);\n   CALL DSUSE(AB,1,11);            /* USE DEVICE 11 AS PRIMARY       */\n\n   /******************************************************************/\n   /*   INVOKE CHART                                                 */\n   /******************************************************************/\n   CALL CHART(AB,               /* CALL CHART UTILITY WITH RESULT.   */\n             ADMTPCS,           /* CONTROL STRUCTURE.                */\n             DATA_CONTROL,      /* DATA CONTROL VECTOR (NONE).       */\n             XDATA,             /* X DATA                            */\n             YDATA,             /* Y DATA                            */\n             KEYS,              /* KEYS                              */\n             XLABELS,           /* DATA LABELS                       */\n             HEADING);          /* HEADING                           */\n\n   IF DEB = 'ON' THEN\n     PUT DATA(AB);              /* DEBUG MODE DISPLAY                */\n\n   CALL FSTERM(AB);             /* TERMINATE GDDM                    */\n /********************************************************************/\n /*      END OF MAIN PROGRAM                                         */\n /********************************************************************/\n\n1DECLARE\n  HEADING CHAR(132),               /* STRING OF CHARACTERS FORMING   */\n                                   /* THE HEADING.                   */\n  HEADLEN FIXED BIN(31),           /* LENGTH OF HEADING              */\n  XINDEX FIXED BIN(15),            /* LAST POSITION USED IN XDATA    */\n  YINDEX FIXED BIN(15),            /* LAST POSITION USED IN YDATA    */\n  XLABELS CHAR(15000),             /* STRING CONTAINING X LABELS     */\n  XNUMERIC BIT(1),                 /* INDICATES X IS ENTIRELY NUMERIC*/\n  NOFILE   BIT(1),                 /* INDICATES NO FILE FOUND        */\n  XDATA(6000) FLOAT,               /* ARRAY CONTAINING X DATA        */\n  YDATA(6000) FLOAT,               /* ARRAY CONTAINING Y DATA        */\n  DATA_CONTROL(100) FIXED BIN(31), /* ARRAY CONTAINING NE VALS       */\n  COLUMNS  FIXED BIN(15),          /* NUMBER OF DATA COLUMNS WANTED  */\n  ROWS     FIXED BIN(15),          /* NUMBER OF DATA ROWS FOUND      */\n  KEYS CHAR(400),                  /* STRING OF CHARACTERS CONTAINING*/\n                                   /* THE KEYS.  CONTAINS ALL KEYS   */\n                                   /* CONCATENATED TOGETHER.         */\n  KEYLEN FIXED BIN(15),            /* LENGTH OF EACH KEY.            */\n                                   /* (NUMBER IS GIVEN BY COLUMNS)   */\n  KEYCOUNT FIXED BIN(15),          /* COUNT OF KEYS DISCOVERED       */\n\n  CURRENT_TOKEN CHARACTER(32) VARYING,/* CURRENT INPUT TOKEN         */\n  INREC CHARACTER(32767)           /* CURRENT INPUT RECORD           */\n         VARYING BASED(RECPTR),    /*   WDPSC      */\n  CHARINDEX FIXED BIN(15);         /* INDEX TO CURRENT POSITION      */\n\n\n1GET_FILE: PROCEDURE;\n /********************************************************************/\n /*  READS THE INPUT FILE.                                           */\n /*        THIS CONSISTS OF:                                         */\n /*           THE HEADING CARD (CONTAINING THE PLOT TITLE)           */\n /*           THE KEYS CARD    (CONTAINING THE DATA DESCRIPTIONS)    */\n /*           DATA CARDS       (CONTAINING THE X AND Y DATA)         */\n /*                                                                  */\n /*  IT SETS (SOMETIMES BY SUBROUTINES):                             */\n /*                                                                  */\n /*  HEADING TO THE HEADING TEXT,  HEADLEN TO THE HEADING LENGTH     */\n /*  KEYS    TO THE KEY     TEXT,  KEYLEN  TO THE KEY     LENGTH     */\n /*  ROWS  TO THE NUMBER OF ROWS OF INPUT DATA.                      */\n /*  COLUMNS TO THE NUMBER OF COLUMNS (COMPONENTS+1)                 */\n /*  XLABELS TO THE XDATA LABELS,  YDATA TO THE YDATA VALUES         */\n /*  XDATA   TO THE XDATA VALUES IF THEY ARE NUMERIC.                */\n /*  XNUMERIC INDICATES THIS HAS BEEN DONE.                          */\n /********************************************************************/\n   CALL ADMUSP6O(FILE_NAME,RETCODE1);/* OPEN THE INPUT FILE          */\n   IF RETCODE1 = 4 THEN           /* CHECK ITS EXISTENCE            */\n     MESSAGE = 'DATA FILE NOT FOUND';\n   IF RETCODE1 = 8 THEN           /* CHECK ITS EXISTENCE            */\n     MESSAGE = 'DATA FILE OPEN ERROR';\n\n   IF MESSAGE = '' THEN            /* IF NO ERROR                    */\n     CALL GET_HEAD;                /* READ IN HEADING DATA           */\n\n   IF MESSAGE = '' THEN            /* IF NO ERROR                    */\n     CALL GET_KEYS;                /* READ IN THE KEY DATA           */\n\n   COLUMNS = KEYCOUNT+1;           /* THERE IS ONE COLUMN FOR EACH   */\n                                   /* KEY GIVEN PLUS ONE FOR XDATA   */\n   IF MESSAGE = '' THEN            /* IF NO ERROR                    */\n     CALL GET_MATRIX;              /* READ IN THE INPUT MATRIX       */\n\n   IF MESSAGE = '' THEN            /* IF ALL WENT WELL:              */\n    DO;                            /* RECORD THE DATA IN CHART       */\n                                   /* CONTROL STRUCTURE.             */\n  IF NG > 0 THEN DO;\n     PCSNE = MAXNE;                /* SET NUMBER OF ELEMENTS         */\n     PCSNC = NG   ;                /* SET NUMBER OF COMPONENTS       */\n                 END;\n            ELSE DO;\n     PCSNE = ROWS;                 /* SET NUMBER OF ELEMENTS         */\n     PCSNC = KEYCOUNT;             /* SET NUMBER OF COMPONENTS       */\n                 END;\n     IF PCSNE > 0 & XNUMERIC='1'B THEN PCSNE=PCSNE*-1;\n     PCSHEADL = HEADLEN;           /* HEADING LENGTH                 */\n     PCSKEYL =  KEYLEN;            /* KEY ITEM LENGTH                */\n     PCSLABL =  LABELLEN;          /* LABEL LENGTH                   */\n    END;\n   ELSE\n    DO;                            /* IF THERE IS A MESSAGE FROM     */\n     PCSNE = 0;                    /* THE FILE FETCH, SET THE ROWS   */\n     PCSNC = 0;                    /* AND COLUMNS TO ZERO.           */\n    END;                           /* (CAN CALL CHART WITH NO DATA)  */\n\n   IF RETCODE1 < 4 THEN\n      CALL ADMUSP6C(RETCODE);      /* CLOSE THE INPUT FILE           */\n END;                              /* OF GET FILE PROCEDURE          */\n\n\n1GET_HEAD: PROCEDURE;\n /********************************************************************/\n /*  READS A SINGLE INPUT RECORD CONTAINING THE HEADING TEXT.        */\n /*  LEADING AND TRAILING BLANKS ARE IGNORED.                        */\n /*   - SETS HEADING TO THE TEXT, HEADLEN TO THE LENGTH.             */\n /********************************************************************/\n\n  CALL ADMUSP6R(RECPTR,RETCODE);   /* FETCH THE HEADING RECORD       */\n  IF RETCODE > 0 THEN              /* IF RETURN CODE NON ZERO,       */\n    DO;                            /* DIAGNOSE -                     */\n      IF RETCODE = 4 THEN\n        MESSAGE = 'NO HEADING RECORD';\n      ELSE\n        MESSAGE = 'ERROR READING FILE';\n    END;\n  ELSE                             /* OK, RECORD FETCHED             */\n   DO;                             /* THERE IS A RECORD THERE:       */\n    CHARINDEX = 1;                 /* SET INITIAL POSITION           */\n\n    /*****************************************************************/\n    /*  SCAN OVER ANY INITIAL BLANKS                                 */\n    /*****************************************************************/\n    DO WHILE ((SUBSTR(INREC,CHARINDEX,1) = ' ')\n         & (CHARINDEX \u00ac> LENGTH(INREC)));\n      CHARINDEX = CHARINDEX + 1;\n    END;\n\n    /*****************************************************************/\n    /*  SET HEADING LENGTH, ASSUMING THERE ARE NO TRAILING BLANKS    */\n    /*****************************************************************/\n    HEADLEN = LENGTH(INREC) - CHARINDEX + 1;\n\n    /*****************************************************************/\n    /*   EITHER INPUT CHARACTER IS NON BLANK OR CHARINDEX            */\n    /*   IS GREATER THAN THE INPUT RECORD LENGTH.                    */\n    /*    - IN FORMER CASE, SCAN BACKWARDS FROM END OF RECORD.       */\n    /*****************************************************************/\n\n    IF CHARINDEX \u00ac> LENGTH(INREC) THEN\n\n      /***************************************************************/\n      /*   REDUCE HEADLEN UNTIL THE LAST CHARACTER IS NOT A BLANK.   */\n      /***************************************************************/\n\n      DO WHILE (SUBSTR(INREC,CHARINDEX+HEADLEN-1,1) = ' ');\n        HEADLEN = HEADLEN -1;\n      END;\n\n    /*****************************************************************/\n    /*   MOVE HEADING INTO RESERVED SPACE.                           */\n    /*****************************************************************/\n    HEADING = SUBSTR(INREC,CHARINDEX,HEADLEN);\n   END;\n END;                              /* OF GET HEADING PROCEDURE       */\n\n\n1GET_KEYS: PROCEDURE;\n /********************************************************************/\n /*  READS THE TOKENS FROM A SINGLE INPUT RECORD FOR THE KEY DATA.   */\n /*  EACH TOKEN IS A KEY AND THERE SHOULD BE THE SAME NUMBER OF Y    */\n /*  DATA COLUMNS.                                                   */\n /********************************************************************/\n\n  KEYLEN = 0;                      /* INITIALISE KEY LENGTH          */\n  KEYCOUNT = 0;                    /* AND NUMBER OF KEYS             */\n  CHARINDEX = 1;                   /* INITIALISE CHARACTER INDEX     */\n\n  CALL ADMUSP6R(RECPTR,RETCODE);   /* FETCH THE KEY RECORD           */\n  IF RETCODE > 0 THEN              /* IF NON ZERO RETURN */\n    DO;                            /* DIAGNOSE -                     */\n      IF RETCODE = 4 THEN\n        MESSAGE = 'NO KEY DATA SUPPLIED';\n      ELSE\n        MESSAGE = 'ERROR READING FILE';\n    END;\n  ELSE                             /* OK, RECORD FETCHED             */\n   DO UNTIL(CURRENT_TOKEN = '');   /* UNTIL END OF KEYS              */\n\n     CALL GET_TOKEN;               /* GET THE KEY                    */\n     IF CURRENT_TOKEN \u00ac= '' THEN   /* IF IT IS A REAL ONE:           */\n                                   /* APPEND IT TO THE KEY LIST      */\n       CALL APPEND(KEYS,KEYCOUNT,KEYLEN,CURRENT_TOKEN);\n   END;                            /* OF KEY FETCH LOOP              */\n END;                              /* OF GET KEYS PROCEDURE         */\n\n\n1GET_MATRIX:PROCEDURE;\n /********************************************************************/\n /*  READS THE RECTANGULAR DATA ARRAY FROM THE INPUT FILE.           */\n /*     EACH CARD CONTAINS 1 ROW OF DATA, THAT IS ONE X VALUE        */\n /*     AND COLUMNS Y VALUES.                                        */\n /*  THE X VALUES MAY BE NUMERIC OR ALPHANUMERIC.  THE Y VALUES      */\n /*  MUST BE NUMERIC.                                                */\n /*  AN ALPHANUMERIC VALUE MAY BE ANY TOKEN.  A NUMERIC VALUE        */\n /*  MAY BE ANY TOKEN WHICH PL/I WILL CONVERT TO FLOAT.              */\n /********************************************************************/\n  DECLARE\n    I  FIXED BIN(15);              /* LOCAL INDEX                    */\n\n  XINDEX = 0;                      /* INITIALISE THE ROW INDEX       */\n  ALLROWS = 0;\n  YINDEX = 0;                      /* THE INDEX TO YDATA             */\n  NG = 0;\n  MAXNE = 0;\n  ROWS   = 0;                      /* COUNT OF MATRIX ROWS           */\n  LABELLEN = 0;                    /* AND LENGTH OF X LABELS         */\n\n  ON CONVERSION                    /* IF THERE IS A CONVERSION ERROR */\n    BEGIN;                         /* IN THE DATA EXTRACTION, REPLACE*/\n      ONSOURCE = '0';              /* WITH 0 AND DIAGNOSE            */\n      MESSAGE = 'NON NUMERIC Y VALUE FOUND IN DATA';\n    END;\n\n  END_OF_FILE = '0'B;\n  DO WHILE(END_OF_FILE = '0'B      /* WHILE THERE IS MORE DATA       */\n         & MESSAGE = '');          /* AND NO ERROR IS FOUND.         */\n    CALL ADMUSP6R(RECPTR,RETCODE);    /* FETCH NEXT INPUT RECORD     */\n    IF RETCODE  > 0 THEN              /* IF NON ZERO RETURN          */\n      DO;                             /* DIAGNOSE -                  */\n         DATA_CONTROL(NG) = ROWS;\n         IF ROWS > MAXNE THEN\n           MAXNE = ROWS;\n       IF RETCODE = 4 THEN DO;\n         END_OF_FILE = '1'B;\n                           END;\n       ELSE\n         MESSAGE = 'ERROR READING FILE';\n      END;\n    ELSE                            /* OK, RECORD FETCHED             */\n     DO;\n      CALL GET_TUPLE;              /* EXTRACT MATRIX ROW             */\n      ROWS = ROWS + 1;             /* AND COUNT THE NUMBER OF ROWS   */\n     END;\n\n  END;                             /* OF RECORD LOOP                 */\n\n IF NG =  0 THEN DO;\n   PCSPAIR = 0;\n   CALL TRANSPOSE(YDATA,ROWS,COLUMNS-1); /*TRANSPOSE THE Y MATRIX   */\n                 END;\n            ELSE PCSPAIR = 1;\n /********************************************************************/\n /*   ATTEMPT TO CONVERT THE XLABELS TO NUMERIC DATA                 */\n /*   IN XDATA.                                                      */\n /********************************************************************/\n\n  ON CONVERSION\n    BEGIN;                         /* IF A CONVERSION ERROR OCCURS,  */\n      XNUMERIC = '0';              /* SET FLAG TO NON NUMERIC        */\n      GOTO DONE;                   /* AND STOP PROCESSING            */\n    END;\n\n  XNUMERIC = '1'B;               /* ASSUME IT WILL WORK SUCCESSFULLY */\n  DO I = 0 TO ALLROWS-1;         /* PROCESS ALL XLABELS              */\n                                 /* CONVERTING THEM TO NUMERIC       */\n    XDATA(I+1) = SUBSTR(XLABELS,I*LABELLEN+1,LABELLEN);\n  END;\n DONE:                           /* PROCESSING FINISHED              */\n  REVERT CONVERSION;\n END;                            /* OF GET MATRIX PROCEDURE          */\n\n\n1GET_TUPLE: PROCEDURE;\n /********************************************************************/\n /*  READS A MATRIX ROW FROM A SINGLE INPUT RECORD.                  */\n /*  THE FIRST TOKEN ON THE CARD IS THE XLABEL AND IS CONCATENATED   */\n /*  INTO THE XLABEL ARRAY.   THE REMAINING TOKENS ARE CONVERTED     */\n /*  TO NUMERIC AND PLACED IN THE YDATA ARRAY.                       */\n /*  THE NUMBER OF ITEMS EXPECTED  IS  THE VARIABLE COLUMNS.         */\n /********************************************************************/\n  DCL I FIXED BIN(15);             /* INDEX TO ITEMS FETCHED         */\n\n  CHARINDEX = 1;                   /* INITIALISE CHARACTER POINTER   */\n /********************************************************************/\n /*  FIRST DO THE FIRST COLUMN, WHICH GOES INTO XLABELS.             */\n /********************************************************************/\n  IF XINDEX+1 > HBOUND(XDATA,1) THEN /* CHECK WHETHER TOO MANY ITEMS.*/\n   MESSAGE = 'TOO MANY DATA ITEMS';/* AND IF SO DIAGNOSE IT.         */\n\n  CALL GET_TOKEN;                  /* GET THE ITEM                   */\n  IF (CURRENT_TOKEN = '=NG') | (CURRENT_TOKEN = '=NG') THEN DO;\n     CALL GET_TOKEN;               /* GET THE KEY                    */\n     IF CURRENT_TOKEN \u00ac= '' THEN   /* IF IT IS A REAL ONE:           */\n                                   /* APPEND IT TO THE KEY LIST      */\n       CALL APPEND(KEYS,KEYCOUNT,KEYLEN,CURRENT_TOKEN);\n     DATA_CONTROL(NG) = ROWS;\n     NG = NG + 1 ;\n     IF ROWS > MAXNE THEN MAXNE = ROWS;\n     ROWS = -1;\n     COLUMNS = 2;\n                                END;\n                           ELSE DO;\n     ALLROWS = ALLROWS + 1;\n\n  IF XINDEX <= HBOUND(XDATA,1) THEN/* PROVIDED IT WILL FIT THE ARRAY */\n                                   /* APPEND TOKEN TO LABEL LIST     */\n    CALL APPEND(XLABELS,XINDEX,LABELLEN,CURRENT_TOKEN);\n\n /********************************************************************/\n /*  THEN DO THE REMAINING COLUMNS WHICH GO INTO YARRAY.             */\n /********************************************************************/\n\n  DO I = 2 TO COLUMNS;             /* FOR ALL COLUMNS EXPECTED,      */\n\n   YINDEX = YINDEX + 1;            /* INCREMENT YINDEX FOR NEXT SLOT */\n   IF YINDEX > HBOUND(YDATA,1) THEN /*CHECK WHETHER TOO MANY ITEMS.  */\n    MESSAGE = 'TOO MANY DATA ITEMS';/*AND ASSIGN IT INTO YDATA ARRAY */\n\n   CALL GET_TOKEN;                 /* GET THE ITEM                   */\n   IF YINDEX <= HBOUND(YDATA,1)    /* PROVIDED IT WILL FIT THE ARRAY */\n   THEN\n    YDATA(YINDEX) = CURRENT_TOKEN; /* ASSIGN IT IN (MAY NOT CONVERT) */\n\n  END;                             /* OF Y VALUE EXTRACTION          */\n                                END;\n END;                              /* OF GET TUPLE PROCEDURE         */\n\n\n1GET_TOKEN: PROCEDURE;\n /********************************************************************/\n /*  READS A SINGLE TOKEN FROM THE INPUT RECORD AND PLACES           */\n /*  IT IN CURRENT_TOKEN.                                            */\n /*  A TOKEN IS EITHER:                                              */\n /*     AS SERIES OF UP TO 32 ALPHANUMERIC CHARACTERS WITHOUT        */\n /*      IMBEDDED BLANKS.                                            */\n /*  OR A NULL STRING   (INDICATING NO INPUT).                       */\n /*   IF AN _ CHARACTER IS FOUND IT IS CHANGED TO A BLANK            */\n /********************************************************************/\n\n DECLARE\n   TOKEN_START FIXED BIN(15);      /* INDEX OF FIRST CHARACTER       */\n                                   /* IN THE TOKEN                   */\n /********************************************************************/\n /*  SCAN OVER ANY INITIAL BLANKS                                    */\n /********************************************************************/\n DO WHILE ((SUBSTR(INREC,CHARINDEX,1) = ' ')\n         & (CHARINDEX \u00ac> LENGTH(INREC)));\n   CHARINDEX = CHARINDEX + 1;\n END;\n /********************************************************************/\n /*  NOW EITHER INPUT CHARACTER IS NON BLANK OR CHARINDEX            */\n /*  IS GREATER THAN THE INPUT RECORD LENGTH.                        */\n /*    - IN FORMER CASE, SCAN TO NEXT BLANK.                         */\n /********************************************************************/\n IF CHARINDEX \u00ac> LENGTH(INREC) THEN\n  DO;                              /* THE INPUT POSITION IS VALID    */\n    TOKEN_START = CHARINDEX;       /* NOTE TOKEN START               */\n                                   /* SCAN TO THE END OF THE TOKEN   */\n                                   /* IE TO NEXT NON BLANK           */\n    DO WHILE ((SUBSTR(INREC,CHARINDEX,1) \u00ac= ' ')\n             & (CHARINDEX \u00ac> LENGTH(INREC)));\n                    /* REPLACE ANY  _ BY BLANK */\n      IF SUBSTR(INREC,CHARINDEX,1)  = '_' THEN\n         SUBSTR(INREC,CHARINDEX,1)  = ' ';\n      CHARINDEX = CHARINDEX + 1;\n    END;\n                                   /* COPY TOKEN TO CURRENT_TOKEN    */\n    CURRENT_TOKEN = SUBSTR(INREC,TOKEN_START,CHARINDEX-TOKEN_START);\n  END;\n ELSE                              /* INPUT POSITION INVALID,        */\n    CURRENT_TOKEN = '';            /* SET CURRENT TOKEN TO NULL      */\n END;                              /* OF GET TOKEN PROCEDURE         */\n\n\n1APPEND:PROCEDURE(STRING_ARRAY,ITEMS,STRING_LENGTH,TOKEN);\n /********************************************************************/\n /*   CONCATENTATES A TOKEN ONTO A STRING ARRAY.                     */\n /*     - THE STRING ARRAY IS A STRING CONTAINING ZERO OR MORE       */\n /*       TOKENS.  THESE ARE ALL CONCATENATED TOGETHER AND EACH IS   */\n /*       PADDED TO THE LENGTH OF THE LONGEST TOKEN.                 */\n /*     - THE STRING ARRAY, THE ITEM COUNT AND THE STRING LENGTH     */\n /*       ARE ALL SET BY THE PROCEDURE.                              */\n /********************************************************************/\n DECLARE\n    STRING_ARRAY CHAR(*),          /* THE CHARACTER STRING CONTAINING*/\n                                   /* THE TOKENS.                    */\n    ITEMS         FIXED BIN(15),   /* THE NUMBER OF TOKENS ALREADY   */\n                                   /* HELD IN THE STRING ARRAY.      */\n    STRING_LENGTH FIXED BIN(15),   /* THE LENGTH OF TOKENS IN THE    */\n                                   /* STRING ARRAY.                  */\n    TOKEN CHAR(32) VARYING,        /* THE TOKEN TO BE ADDED.         */\n\n    NEWLENGTH    FIXED BIN(15),    /* TEMPORARY TO CONTAIN NEW LEN   */\n    I            FIXED BIN(15);    /* TEMPORARY COUNTER              */\n\n IF LENGTH(TOKEN) > STRING_LENGTH  THEN\n   DO;\n    /*****************************************************************/\n    /*  THE NEW TOKEN IS LONGER THAN THE OLD ONES, SO REFORMAT       */\n    /*  THE STRING ARRAY FOR THE LONGER TOKENS.                      */\n    /*****************************************************************/\n    NEWLENGTH = LENGTH(TOKEN);            /* NEW STRING LENGTH       */\n    IF NEWLENGTH*ITEMS > LENGTH(STRING_ARRAY) THEN\n      MESSAGE = 'TOO MUCH STRING DATA';\n    ELSE                           /* IF ENOUGH ROOM THEN            */\n     DO;\n      DO I = ITEMS-1 TO 0 BY -1;   /*      PROCESS ALL STRINGS BY    */\n                                   /*      MOVING THEM ABOUT         */\n        SUBSTR(STRING_ARRAY,I*NEWLENGTH+1,NEWLENGTH)\n            = SUBSTR(STRING_ARRAY,I*STRING_LENGTH+1,STRING_LENGTH);\n      END;\n      STRING_LENGTH = NEWLENGTH;   /*  AND RESET STRING LENGTH.      */\n     END;\n   END;                            /*        END OF KEY REFORMAT     */\n /********************************************************************/\n /* NOW INSERT THE NEW KEY, EXPANDING TO KEYLEN.                     */\n /********************************************************************/\n ITEMS = ITEMS + 1;                /* INCREASE ITEM COUNT.           */\n IF STRING_LENGTH*ITEMS > LENGTH(STRING_ARRAY) THEN\n    MESSAGE = 'TOO MUCH STRING DATA';\n ELSE                              /* IF THERE IS ENOUGH ROOM THEN:  */\n                                   /* INSERT THE TOKEN               */\n  SUBSTR(STRING_ARRAY,(ITEMS-1)*STRING_LENGTH+1,STRING_LENGTH) = TOKEN;\n END;                              /* OF APPEND PROCEDURE            */\n\n\n1TRANSPOSE: PROCEDURE(INARRAY,ROWS,COLUMNS);\n /********************************************************************/\n /*   TRANSPOSES THE MATRIX INARRAY.                                 */\n /*     - THE ARRAY IS ASSUMED TO HAVE ROWS ROWS AND COLUMNS         */\n /*       COLUMNS.                                                   */\n /*     - ON INPUT IT IS STORED WITH THE ROW INDEX VARYING MOST      */\n /*       RAPIDLY. ON OUTPUT THE COLUMN INDEX VARIES MOST RAPIDLY    */\n /********************************************************************/\n DECLARE\n    INARRAY (*) FLOAT,             /* THE INPUT ARRAY.               */\n    ROWS          FIXED BIN(15),   /* THE NUMBER OF ROWS OF DATA     */\n    COLUMNS       FIXED BIN(15),   /* THE NUMBER OF COLUMNS          */\n    (I,J)         FIXED BIN(15),   /* TEMPORARY INDEXES              */\n    TEMP(ROWS*COLUMNS) FLOAT;      /* TEMPORARY USED IN CONVERSION   */\n\n    DO I = 0 TO ROWS-1;            /* TRANSPOSE THE MATRIX INTO TEMP */\n      DO J = 0 TO COLUMNS-1;\n        TEMP(J*ROWS+I+1) = INARRAY(I*COLUMNS+J+1);\n      END;\n    END;\n    DO I = 1 TO ROWS*COLUMNS;      /* AND COPY IT BACK TO INARRAY    */\n        INARRAY(I) = TEMP(I);\n    END;\n END;                              /* OF TRANSPOSE PROCEDURE         */\n\n\n END;                              /* OF ADMUSP6                     */\n*PROCESS;\n\n\n1ERRPROC : PROCEDURE(AB,ERRORBLOCK) OPTIONS(COBOL);\n /********************************************************************/\n /*   PROCEDURE NOMINATED AS ERROR EXIT BY AN FSEXIT CALL.           */\n /*     - RECEIVES CONTROL WHEN AN ERROR IS DETECTED.                */\n /*       THE PARAMETER PASSED IS NOT IN ACCEPTABLE PL/I FORMAT      */\n /*       SO THE PROCEDURE IS DECLARED OPTIONS COBOL                 */\n /*     - THE APPLICATION ANCHOR BLOCK PASSED BY GDDM CONTAINS       */\n /*       THE ADDRESS OF THE MESSAGE AREA IN THE USER EXTENSION.     */\n /*       THIS AREA IS SET TO THE MESSAGE TEXT.                      */\n /*     - THE PROCEDURE IS INCLUDED IN THE MAIN COMPILATION FOR      */\n /*       CONVENIENCE, HOWVER LOGICALLY IT IS EXTERNAL.              */\n /********************************************************************/\n DECLARE\n   1 ERRORBLOCK,                   /* THAT PART OF REQUIRED          */\n      2 SEVERITY FIXED BIN(31),    /* THE ERROR SEVERITY             */\n      2 NUMBER   FIXED BIN(31),    /* THE ERROR NUMBER               */\n      2 FNAME    CHARACTER(8),     /* THE FUNCTION NAME              */\n      2 MSGLEN   FIXED BIN(31),    /* MESSAGE LENGTH                 */\n      2 MSGTEXT  CHARACTER(80);    /* MESSAGE TEXT                   */\n DECLARE                          /* GDDM ANCHOR BLOCK              */\n    1 AB,\n       2  AABSC   FIXED BIN(15),   /* SEVERITY CODE                  */\n       2  AABEC   FIXED BIN(15),   /* ERROR CODE                     */\n       2  AABAP   CHARACTER(4),    /* GDDM ANCHOR, ACTUALLY A POINTER*/\n       2  MESSAGE CHARACTER(60);   /* MESSAGE TEXT RETURNED          */\n\n   MESSAGE = SUBSTR(MSGTEXT,1,LENGTH(MESSAGE));\n END;                              /* OF ERRPROC  PROCEDURE          */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ADMUSP6O": {"ttr": 2313, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x00\\x7f\\x00\\x88\\x00\\x7f\\x12\\x00\\x00\\xdc\\x00\\xdc\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf2\\xf7\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-01-07T00:00:00", "modifydate": "1988-01-07T12:00:00", "lines": 220, "newlines": 220, "modlines": 0, "user": "FILE270"}, "text": "*          DATA SET 761KKUSP6O AT LEVEL 001 AS OF 08/30/82\n         TITLE ' TSO FILE I/O MODULE FOR DATA PLOT APPLICATION'\n***********************************************************************\n*                                                                     *\n*     THIS ROUTINE PROVIDES PRIMITIVE FILE I/O FACLITIES ON TSO       *\n*     FOR THE DATA PLOT APPLICATION, ADMUSP6.                         *\n*                                                                     *\n*     THE ENTRIES ARE:  -  ADMUSP6O  TO OPEN A FILE WITH A GIVEN NAME *\n*                           AND RETURN A FLAG IF SUCCESSFUL           *\n*                       -  ADMUSP6R  TO READ AN 80 BYTE RECORD FROM   *\n*                           THE FILE AND RETURN A FLAG IF SUCCESSFUL  *\n*                       -  ADMUSP6C  TO CLOSE THE FILE                *\n*                                                                     *\n*     THE ROUTINE IS NOT RE-ENTRANT.                                  *\n*                                                                     *\n***********************************************************************\nADMUSP6O CSECT ,                   ADMUSP6O - THE MAIN ENTRY\n@MAINENT DS    0H\n         USING *,@15\n         B     @PROLOG\n         DC    AL2(@EP00001-@MAINENT)\nADMUSP6C DS    0H                  FILE CLOSE ENTRY POINT\n         USING *,@15\n         B     @PROLOG\n         DC    AL2(@EP00022-ADMUSP6C)\n         ENTRY ADMUSP6C\n*\nADMUSP6R DS    0H                  FILE READ ENTRY POINT\n         USING *,@15\n         B     @PROLOG\n         DC    AL2(@EP00031-ADMUSP6R)\n         ENTRY ADMUSP6R\n*\n         DROP  @15\n@PROLOG  STM   @14,@12,12(@13)     NON-REENTRANT PROLOGUE\n         BALR  @12,0               - SET BASE REGISTER\n@PSTART  DS    0H\n         USING @PSTART,@12\n         ST    @13,@SA00001+4      PERFORM SAVE AREA CHAINING\n         LA    @14,@SA00001\n         ST    @14,8(,@13)\n         LR    @13,@14\n         AH    @15,4(,@15)         AND BRANCH TO CODE FOR ENTRY\n         BR    @15\n*\n*        ADMUSP6O ENTRY(FNAME,RETCODE);\n*        DECLARE FNAME CHARACTER(8),   THE FILE NAME\n*                RETCODE FIXED(31);    INDICATOR THAT NO FILE EXISTS\n*\n@EP00001 MVC   @PC00001(8),0(@01)\n*                                  ADMUSP6O CODE\n         OPEN  (FILEDCB,(INPUT))   OPEN THE DATA FILE\n         LA    @03,FILEDCB         ADDRESS DCB\n         USING IHADCB,@03          AND\n         TM    DCBOFLGS,X'10'      FIND IF OPEN SUCCESSFUL,\n         BZ    NOTOPEN             IF NOT GO TO DIAGNOSE IT.\n         B     FIND                IF OK CONTINUE WITH FIND\n*\nNOTOPEN  DS    0H                  DIAGNOSE ERRONEOUS OPEN -\n         LA    @03,8               SET RETURN CODE 8.\n         B     RETURNO\n*                                  INSERT FILENAME INTO LONGNAME\nFIND     L     @15,@PC00001        WHICH IS JUST A TEMPORARY\n         MVC   LONGNAME(8),0(@15)\n         FIND  FILEDCB,LONGNAME,D  FIND THE PROPER MEMBER\n         LA    @03,4               INITIALISE RETURN CODE\n         C     @15,=F'4'           IF FILE NOT FOUND\n         BE    RETURNE             RETURN WITH CODE 4.\n         LA    @03,8               IF ERROR, SET RETURN CODE 8 AND\n         BH    RETURNE             RETURN\n         SR    @03,@03             OTHERWISE SET RETURN CODE 0  AND\n         LH    R0,FILEDCB+X'3E'         R0=BLKSIZE                WDPSC\n         AH    R0,=H'2'                 XTRA 2 FOR LENGTH         WDPSC\n         GETMAIN R,LV=(0)               R1->BUFFER                WDPSC\n         ST    R1,BUFFAD                SAVE ADDR                 WDPSC\n         NI    VBF,X'00'                SAY BLK NEEDED            WDPSC\n         B     RETURNO             RETURN\n*\nRETURNE  CLOSE FILEDCB             CLOSE THE FILE AGAIN BEFORE RETURN\n*\nRETURNO  L     @14,@PC00001+4      ADDRESS THE SECOND PARAMETER\n         ST    @03,0(@14)          AND STORE THE RETURN CODE\n         L     @13,4(,@13)\n         LM    @14,@12,12(@13)\n         BR    @14\n*\n*           ADMUSP6C: ENTRY;\n*\n@EP00022 MVC   @PC00001(4),0(@01)\n         CLOSE FILEDCB             CLOSE THE FILE\n         LH    R0,FILEDCB+X'3E'         R0=BLKSIZE                WDPSC\n         L     R1,BUFFAD                GET  ADDR                 WDPSC\n         FREEMAIN R,LV=(0),A=(1)        FREE IO BUFFER            WDPSC\n         L     @14,@PC00001        ADDRESS THE PARAMETER\n         SR    @15,@15             CLEAR RETURN CODE\n         ST    @15,0(@14)          AND STORE THE RETURN CODE.\n         L     @13,4(,@13)\n         LM    @14,@12,12(@13)     RETURN\n         BR    @14\n         EJECT\n*\n*     ADMUSP6R:ENTRY(INREC,RETCODE);\n*     DECLARE INREC CHARACTER (80), RETCODE FIXED(31);\n*\n@EP00031 MVC   @PC00001(8),0(@01) MOVE PARAMETERS\n*\n         SLR   R15,R15                  R15=0 INIT RC TO ZERO     WDPSC\n         TM    VBF,X'FF'                VALID BLOCK PRESENT?      WDPSC\n         BO    WHAB                     YES->WE HAVE A BLOCK      WDPSC\n         BAL   R14,RANB                 NO ->READ A NEW BLOCK     WDPSC\n*                                                                 WDPSC\nWHAB     BAL   R14,MCR                  MOVE CURRENT RECORD       WDPSC\n         BAL   R14,FNR                  FIND NEXT RECORD          WDPSC\n         B     RETURNR                  RETURN TO CALLER          WDPSC\n*\nRETURNR  L     @14,@PC00001+4      ADDRESS THE SECOND PARAMETER\n         ST    @15,0(@14)          AND STORE THE RETURN CODE\n         L     @13,4(,@13)\n         LM    @14,@12,12(@13)\n         BR    @14\n         EJECT\n*                                                                 WDPSC\nRANB     ST    R14,L1LS                                           WDPSC\n         L     @03,BUFFAD         GET BUFFER AREA                 WDPSC\n         LA    R3,2(,R3)                R3+2 SKIP XTRA LENGTH     WDPSC\n*                                 THEN READ THE NEXT RECORD\n         READ  RDECB,SF,FILEDCB,(@03)\n         CHECK RDECB\n         SR    @15,@15             CLEAR RETURN CODE\n*        B     RETURNR                                            WDPSC\n         OI    VBF,X'FF'                SET VALID BUFFER FLAG     WDPSC\n         TM    FILEDCB+X'24',X'40'   V  TYPE RECORDS?             WDPSC\n         BO    SETV                     YES\n         MVC   NRADD,BUFFAD             RESET NEXT RECORD PTR     WDPSC\nREX      L     R14,L1LS                                           WDPSC\n         BR    R14                                                WDPSC\n*\nSETV     L     R4,BUFFAD                R4->START OF BUFFER(-2)   WDPSC\n         LA    R4,6(,R4)                R4+6 PT PAST BDW          WDPSC\n         ST    R4,NRADD                 SAVE NEXT RECORD PTR      WDPSC\n         B     REX\n*\nREADERR  DS   0H                   I/O ERROR ON READ -\n         LA   @15,8                SET RETURN CODE 8.\n         B RETURNR\n*\nNODATA   DS   0H                   END OF FILE -\n         LA   @15,4                SET RETURN CODE 4.\n         B     RETURNR                                            WDPSC\n         EJECT\nMCR      L     R3,@PC00001              R3->CALLERS REC           WDPSC\n         L     R4,NRADD                 R4->NEXT RECORD           WDPSC\n         TM    FILEDCB+X'24',X'40'      V TYPE RECORDS?           WDPSC\n         BO    MVR                      YES                       WDPSC\n         LH    R5,FILEDCB+X'52'         R5=LRECL                  WDPSC\n         STH   R5,0(,R4)                PREFIX RECORD             WDPSC\n         ST    R4,0(,R3)                PASS TO ADMUSP6           WDPSC\n         BR    R14                                                WDPSC\n*                                                                 WDPSC\nMVR      LH    R5,0(,R4)                R5=RECORDS LENGTH         WDPSC\n         SH    R5,=H'4'                 R5-4 FOR RDW              WDPSC\n         STH   R5,2(,R4)                PREFIX THE RECORD         WDPSC\n         LA    R4,2(,R4)                R4->NEW RECORD PREFIX     WDPSC\n         ST    R4,0(,R3)                PASS TO ADMUSP6           WDPSC\n         BR    R14                                                WDPSC\n*                                                                 WDPSC\nFNR      TM    FILEDCB+X'24',X'40'      V TYPE RECORDS?           WDPSC\n         BNO   FNR2                     NO                        WDPSC\n         L     R4,NRADD                 R4->NEXT RECORD           WDPSC\n         LH    R3,0(,R4)                R3=REAL LENGTH            WDPSC\n         B     FNR3                                               WDPSC\nFNR2     LH    R3,FILEDCB+X'52'         R3=LRECL                  WDPSC\nFNR3     A     R3,NRADD                 R3->NEW NEXT RECORD       WDPSC\n         ST    R3,NRADD                 SAVE ADDR                 WDPSC\n*                                                                 WDPSC\n         LH    R4,FILEDCB+X'3E'         R4=BLKSIZE                WDPSC\n         L     R5,RDECB+16              R5->IOB                   WDPSC\n         SH    R4,14(,R5)               R4=BLKSIZE-RESIDUAL       WDPSC\n         A     R4,BUFFAD                R4->END OF BLK +1         WDPSC\n*                                                                 WDPSC\n         CR    R3,R4                    STILL IN BLK?             WDPSC\n         BLR   R14                      YES                       WDPSC\n         NI    VBF,X'00'                NO->SAY NEW BLK NEEDED    WDPSC\n         BR    R14                                                WDPSC\n         EJECT\n*\n         REGEQU\n*                END OF MODULE\n@DATA    DS    0F\n@SA00001 DS    18F\n@PC00001 DS    2F\nL1LS     DS    F                                                  WDPSC\nBUFFAD   DS    F                                                  WDPSC\nVBF      DS    X                                                  WDPSC\nNRADD    DS    F                                                  WDPSC\n         DS    0D\nLONGNAME DS    CL8\n         LTORG\n         EJECT\nFILEDCB  DCB   DDNAME=DATA,DSORG=PO,MACRF=(R),                         C\n               SYNAD=READERR,EODAD=NODATA\n         DCBD  DSORG=PO\n@00      EQU   00                      EQUATES FOR REGISTERS 0-15\n@01      EQU   01\n@02      EQU   02\n@03      EQU   03\n@04      EQU   04\n@05      EQU   05\n@06      EQU   06\n@07      EQU   07\n@08      EQU   08\n@09      EQU   09\n@10      EQU   10\n@11      EQU   11\n@12      EQU   12\n@13      EQU   13\n@14      EQU   14\n@15      EQU   15\n@ENDDATA EQU   *\n         END   ADMUSP6O\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "ALLOCGDG": {"ttr": 2564, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x00\\x7f\\x00\\x88\\x00\\x7f\\x12\\x00\\x01o\\x01o\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf2\\xf7\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-01-07T00:00:00", "modifydate": "1988-01-07T12:00:00", "lines": 367, "newlines": 367, "modlines": 0, "user": "FILE270"}, "text": "         TITLE 'ALLOCGDG -- DYNAMIC ALLOC OF GDG GIVEN REL GENERATION'\n         PRINT ON,NOGEN\n         SPACE 3\n*        THIS PROGRAM IS A SUBROUTINE WHICH DYNAMICALLY ALLOCATES\n*        A GENERATION DATA GROUP MEMBER EXPRESSED WITH THE RELATIVE\n*        GENERATION NUMBER TO THE DDNAME AND DSN PROVIDED.\n*\n*        TO CALL THIS PROGRAM FROM A CLIST, DO THE FOLLOWING:\n*\n*            CALL 'CTS150.CSLOAD(ALLOCGDG)' 'DDNAME,DSN|'\n*\n*        (E.G. CALL 'CTS150.CSLOAD(ALLOCGDG)' 'MASTIN,CTS150.GDG(+0)|'\n*\n*        AFTER THE CALL, &LASTCC WILL CONTAIN EITHER 0 OR 4\n*\n*            IF &LASTCC = 0, THEN THE FILE WAS SUCCESSFULLY ALLOCATED\n*            IF &LASTCC = 4, THEN THE FILE WAS NOT SUCCESSFULLY\n*                ALLOCATED FOR ONE OF THE FOLLOWING REASONS:\n*\n*                     A.  INVALID DDNAME PASSED TO THIS PROGRAM\n*                     B.  MISSING COMMA BETWEEN DDNAME AND DSN\n*                     C.  DATASET DSN NOT CATALOGUED\n*                     D.  DATASET DSN NOT ON ON-LINE DISK\n*                     E.  MISSING | AFTER THE DSN IN PARM\n*\n*\n*        ASSIGNMENT OF REGISTERS\n*        -----------------------\n*\n*        REGISTER      USAGE\n*        --------      -------------------------------------------\n*\n*           1          ADDRESS OF PARAMETER LIST\n*           2          NOT USED\n*           3          NOT USED\n*           4          WORK REGISTER\n*           5          RETURN REG USED IN ALL BR AND LINK INSTRUCTIONS\n*           6          INDEX REGISTER\n*           7          INDEX REGISTER\n*           8          LENGTH OF DDNAME\n*           9          INDEX REGISTER\n*           10         NOT USED\n*           11         SAVE REGISTER 1\n*           12         BASE REGISTER\n*           13         ADDRESS OF SAVE AREA\n*           14         RETURN ADDRESS\n*           15         ENTRY POINT ADDRESS\n         EJECT\n         SPACE 3\n*\n**********************************************\n*                                            *\n*        I N I T I A L I Z A T I O N         *\n*                                            *\n**********************************************\n*\nALLOCGDG CSECT\n         SAVE  (14,12)\n         BALR  12,0\n         USING *,12\n         ST    13,SAVEAREA+4\n         LA    13,SAVEAREA\n         B     STARTIT\n         SPACE\nSAVEAREA DC    18F'0'\n         SPACE 3\n********************************************************************\n*        EQUATE RESISTERS 0 THRU 15 TO MORE MEANINGFUL NAMES       *\n********************************************************************\n         SPACE 3\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n         EJECT\n         SPACE 3\n********************************************************************\n*                                                                  *\n*        SAVE REGISTER 1 CONTENTS IN REGISTER 11 AND PLACE         *\n*        PARAMETER AREA INTO PASSREC                               *\n*                                                                  *\n********************************************************************\n         SPACE 3\nSTARTIT  DS    0D\n         LR    R11,R1                 SAVE REG 1 CONTENTS IN REG 11\n         L     R9,0(R11)\n         MVC   IOAREA,0(R9)\n         EJECT\n         SPACE 3\n********************************************************************\n*                                                                  *\n*        M A I N   L I N E   L O G I C                             *\n*                                                                  *\n********************************************************************\n         SPACE 3\n         MVC   VALIDSW(3),YESS        MOVE 'YES' TO VALIDSW\n         SPACE 2\n         BAL   R5,PRELIM              PERFORM PRELIM ROUTINE\n         SPACE 2\n         CLC   VALIDSW,YESS           IS VALIDSW = 'YES'\n         BE    LOKAYT                 IF YES, BRANCH TO LOKAYT\n         B     SHUTDOWN               BRANCH TO SHUTDOWN\nLOKAYT   LOCATE CAMLIST1\n         SPACE 2\n         C     R15,=F'0'              COMPARE REG 15 TO BE = 0\n         BE    DOCALC                 IF REG 15=0, BRANCH TO DOCALC\n         MVC   VALIDSW(3),NOPE        MOVE 'NO ' TO VALIDSW\n         B     SHUTDOWN               BRANCH TO SHUTDOWN\nDOCALC   BAL   R5,CALCDLEN            PERFORM CALC LENGTH OF DSN\n         BAL   R5,DYNAMALC            PERFORM DYNAMIC ALLOCATION\n         B     SHUTDOWN               BRANCH TO SHUTDOWN\n         EJECT\n         SPACE 3\n*\n********************************************************************\n*                                                                  *\n*        THIS ROUTINE IS RESPONSIBLE FOR GENERATING THE FOLLOWING  *\n*        DATA FIELDS:                                              *\n*                                                                  *\n*           INDDNAME ===> DDNAME PASSED TO THIS PROGRAM VIA REG 1  *\n*           INDSN    ===> DSN PASSED TO THIS PROGRAM VIA REG 1     *\n*           FREEUT1A ===> BINARY LENGTH OF DDNAME                  *\n*           FREEUT1B ===> DDNAME PASSED TO THIS PROGRAM            *\n*           DD1UNT1A ===> BINARY LENGTH OF DDNAME                  *\n*           DD1UNT1B ===> DDNAME PASSED TO THIS PROGRAM            *\n*                                                                  *\n********************************************************************\n*\nPRELIM   ST    R5,SAVEIT1            SAVE REG 5 IN SAVEIT1\n         MVC   INDDNAME,=CL8' '\n         MVC   INDSN,=CL44' '\n         LA    R6,OKCHARS1\nTEST1    CLI   0(R6),C'#'\n         BNE   TEST2\n         MVC   VALIDSW,NOPE\n         B     EXITPRLM\nTEST2    CLC   PASSREC(1),0(R6)\n         BE    MOVE1ST\n         A     R6,=F'1'\n         B     TEST1\nMOVE1ST  MVC   INDDNAME(1),PASSREC\n         LA    R8,1\n         LA    R7,PASSREC+1\n         LA    R9,INDDNAME+1\nLOOP1    LA    R6,OKCHARS2\n         C     R8,=F'8'\n         BNH   TEST3\n         MVC   VALIDSW,NOPE\n         B     EXITPRLM\nTEST3    CLI   0(R7),C','\n         BE    LOADFLDS\nTEST4    CLI   0(R6),C'#'\n         BNE   TEST5\n         MVC   VALIDSW,NOPE\n         B     EXITPRLM\nTEST5    CLC   0(1,R7),0(R6)\n         BNE   BUMPIT\n         MVC   0(1,R9),0(R7)\n         A     R7,=F'1'\n         A     R9,=F'1'\n         A     R8,=F'1'\n         B     LOOP1\nBUMPIT   A     R6,=F'1'\n         B     TEST4\nLOADFLDS MVC   FREEUT1B,INDDNAME\n         MVC   DD1UNT1B,INDDNAME\n         LA    R4,INDSN+52\n         A     R7,=F'1'\n         LA    R9,INDSN\nTEST6    CR    R9,R4\n         BNH   TEST7\n         MVC   VALIDSW,NOPE\n         B     EXITPRLM\nTEST7    CLI   0(R7),C'|'\n         BE    CALCLENS\n         MVC   0(1,R9),0(R7)\n         A     R7,=F'1'\n         A     R9,=F'1'\n         B     TEST6\nCALCLENS ST    R8,DDNAMLEN\n         MVC   FREEUT1A(2),DDNAMLEN+2\n         MVC   DD1UNT1A(2),DDNAMLEN+2\nEXITPRLM L     R5,SAVEIT1            RESTORE REGISTER 5\n         BR    R5                    RETURN\n         EJECT\n         SPACE 3\n*\n********************************************************************\n*                                                                  *\n*               D Y N A M I C   A L L O C A T I O N                *\n*               -----------------------------------                *\n*                                                                  *\n*        THIS ROUTINE FIRST ATTEMPTS TO FREE THE DDNAME GIVEN.     *\n*        IF THE DDNAME WAS SUCCESSFULLY FREED, THEN THIS ROUTINE   *\n*        BRANCHES TO THE DYNAMIC ALLOCATION MACRO DYNALLOC.        *\n*        HOWEVER, IF THE DDNAME  WAS NOT SUCCESSFULLY FREED,       *\n*        THEN THIS ROUTINE CHECKS FOR ERROR REASON CODE 0438       *\n*        (DDNAME NOT FOUND).  IF THE ERROR REASON CODE IS 0438,    *\n*        THEN THIS ROUTINE BRANCHES TO THE DYNAMIC ALLOCATION      *\n*        MACRO DYNALLOC, ELSE IT MOVES 'NO ' TO VALIDSW.           *\n*                                                                  *\n********************************************************************\n*\nDYNAMALC ST    R5,SAVEIT2\n         LA    R1,FREEPARM\n         DYNALLOC                      FREE DDNAME\n         LTR   R15,R15                 TEST REGISTER 15 FOR ZERO\n         BZ    DODYNAM                 IF ZERO, BRANCH TO DODYNAM\n         CLC   ERCODE,HEX0438          COMPARE ERROR REASON CODE\n*                                         AGAINST HEXADECIMAL 0438\n         BE    DODYNAM                 IF EQUAL, BRANCH TO DODYNAM\n         MVC   VALIDSW,NOPE            MOVE 'NO ' TO VALIDSW\n         BR    R5                      RETURN\nDODYNAM  LA    R1,DD1PARM\n         DYNALLOC                      ALLOC F(DDNAME) DA(DSN) SHR\n         L     R5,SAVEIT2\n         LTR   R15,R15                 TEST REGISTER 15 FOR ZERO\n         BZR   R5                      IF ZERO, RETURN\n         MVC   VALIDSW,NOPE            MOVE 'NO ' TO VALIDSW\n         BR    R5                      RETURN\n         EJECT\n*\n********************************************************************\n*                                                                  *\n*        THIS ROUTINE IS RESPONSIBLE FOR GENERATING THE            *\n*        FOLLOWING TWO DATA FIELDS:                                *\n*                                                                  *\n*             DSNLEN ===> LENGTH OF DSN WITH ABSOLUTE GEN NUMBER   *\n*             DSNAME ===> DSN WITH ABSOLUTE GENERATION NUMBER      *\n*                                                                  *\n********************************************************************\n*\nCALCDLEN ST    R5,SAVEIT3            SAVE REG 5 IN SAVEIT3\n         MVC   DSNAME,INDSN\n         LA    R7,0\n         LA    R9,INDSN\nCOMPR    CLI   0(R9),C' '\n         BE    CONVRT\n         A     R7,=F'1'\n         A     R9,=F'1'\n         B     COMPR\nCONVRT   ST    R7,DSNAMLEN\n         MVC   DSNLEN(2),DSNAMLEN+2\n         L     R5,SAVEIT3            RESTORE REGISTER 5\n         BR    R5                    RETURN\n         EJECT\n         SPACE 3\n********************************************************************\n*                                                                  *\n*        E N D   O F   J O B   P R O C E S S I N G                 *\n*                                                                  *\n********************************************************************\n         SPACE 3\nSHUTDOWN CLC   VALIDSW,YESS           IS VALIDSW = 'YES'\n         BE    AOK                    IF YES, BRANCH TO AOK\n         LA    R15,4\n         B     GOBACK\nAOK      LA    R15,0\nGOBACK   L     R13,4(R13)\n         RETURN (14,12),RC=(15)\n         EJECT\n         SPACE 3\n*\n********************************************************************\n*                                                                  *\n*        DATA STRUCTURE FOR FREEING OF DDNAME                      *\n*                                                                  *\n********************************************************************\n*\n         SPACE 3\n         DS    0F\nFREEPARM DC    X'80'         TURN ON HIGH ORDER BIT\n         DC    AL3(FREERB)   ADDRESS OF REQUEST BLOCK\nFREERB   DC    X'14'         S99RBLN (LENGTH OF REQUEST BLOCK)\n         DC    X'02'         S99VERB (REQUEST FOR UNALLOCATION)\n         DC    X'2000'       S99FLAG1 (DO NOT MOUNT VOLUMES)\nERCODE   DC    X'0000'       S99ERROR (ERROR REASON CODE)\n         DC    X'0000'       S99INFO (INFORMATION REASON CODE)\n         DC    A(FREETUPL)   S99TXTPP (ADDR OF POINTER TO TEXT UNIT)\n         DC    X'00000000'   RESERVED\n         DC    X'00000000'   S99FLAG2\nFREETUPL DC    A(FREEUNT1)   ADDRESS OF TEXT UNIT #1\n         DC    X'80'         TURN ON HIGH ORDER BIT\n         DC    AL3(FREEUNT2) ADDRESS OF TEXT UNIT#2\nFREEUNT1 DC    X'0001'\n         DC    X'0001'\nFREEUT1A DS    BL2\nFREEUT1B DS    CL8\nFREEUNT2 DC    X'0007'\n         DC    X'0000'\n         EJECT\n         SPACE 3\n*\n********************************************************************\n*                                                                  *\n*        DATA STRUCTURE FOR DYNAMIC ALLOCATION                     *\n*                                                                  *\n********************************************************************\n*\n         SPACE 3\n         DS    0F\nDD1PARM  DC    X'80'         TURN ON HIGH ORDER BIT\n         DC    AL3(DD1RB)    ADDRESS OF REQUEST BLOCK\nDD1RB    DC    X'14'         S99RBLN (LENGTH OF REQUEST BLOCK)\n         DC    X'01'         S99VERB (REQUEST FOR DSNAME ALLOC)\n         DC    X'2000'       S99FLAG1 (DO NOT MOUNT VOLUMES)\n         DC    X'0000'       S99ERROR (ERROR REASON CODE)\n         DC    X'0000'       S99INFO (INFORMATION REASON CODE)\n         DC    A(DD1TUPL)    S99TXTPP (ADDR OF POINTERS TO TEXT UNITS\n         DC    X'00000000'   RESERVED\n         DC    X'00000000'   S99FLAG2\nDD1TUPL  DC    A(DD1UNIT1)   ADDRESS OF TEXT UNIT #1\n         DC    A(DD1UNIT2)   ADDRESS OF TEXT UNIT #2\n         DC    A(DD1UNIT3)   ADDRESS OF TEXT UNIT #3\n         DC    X'80'         TURN ON HIGH ORDER BIT\n         DC    AL3(DD1UNIT4) ADDRESS OF TEXT UNIT #4\nDD1UNIT1 DC    X'0001'\n         DC    X'0001'\nDD1UNT1A DS    BL2\nDD1UNT1B DS    CL8\nDD1UNIT2 DC    X'0002'\n         DC    X'0001'\nDSNLEN   DS    BL2\nDSNAME   DS    CL44\nDD1UNIT3 DC    X'0004',X'0001',X'0001',X'08'\nDD1UNIT4 DC    X'0052'\n         DC    X'0000'\n         EJECT\n         SPACE 3\n********************************************************************\n*        DATA AREAS                                                *\n********************************************************************\n         SPACE 3\n         DS    0F\nSAVEIT1  DS    F\nSAVEIT2  DS    F\nSAVEIT3  DS    F\nDDNAMLEN DS    F\nDSNAMLEN DS    F\nIOAREA   DS    0CL55\n         DS    CL2\nPASSREC  DS    CL53\nINDDNAME DS    CL8\nINDSN    DS    CL44\nCAMLIST1 CAMLST NAME,INDSN,,LOCAREA\nLOCAREA  DS    0D\n         DS    265C\n         DS    0D\nVALIDSW  DS    CL3\nHEX0438  DC    X'0438'\nYESS     DC    C'YES'\nNOPE     DC    C'NO '\nOKCHARS1 DC    C'ABCDEFGHIJKLMNOPQRSTUVWXYZ#'\nOKCHARS2 DC    C'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789#'\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "ALLOCME$": {"ttr": 2571, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x00\\x7f\\x00\\x88\\x00\\x7f\\x12\\x00\\x00G\\x00G\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf2\\xf7\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-01-07T00:00:00", "modifydate": "1988-01-07T12:00:00", "lines": 71, "newlines": 71, "modlines": 0, "user": "FILE270"}, "text": "1                                                        ALLOCMEM.1\n                                                         03/16/83\n\n\n  PROGRAM:       ALLOCMEM\n  AUTHOR:        Jeff Sprehn\n  AGENCY:        WDPSC\n  LANGUAGE:      Assembler\n  LOCATION:      WDPSC.SHARED.LOAD\n  FUNCTION:      Dynamically allocate a partitioned dataset and its\n                 member  to  a  given  DDNAME  from  a  high  level\n                 language program.\n\n  RUN MODE:      Batch or Interactive\n\n  ALLOCMEM is  a subroutine  which can  be called  by a  high level\n  language such as COBOL, PL1, or DYL260/DYL280.  Its purpose is to\n  dynamically allocate a partitioned dataset  and its member to the\n  supplied DDNAME.   In this way, if  the member name is  not known\n  until execution time,  this subroutine could be called  to do the\n  allocation when the  member name is known.   Also this subroutine\n  will deallocate  (FREE) the DDNAME  (if needed) before  doing the\n  allocation.  To call this subroutine from a COBOL program, do the\n  following:\n\n       o    Place the following data area in the WORKING STORAGE:\n\n            01   ALLOCMEM-I-O-AREA.\n                 05  DDNAME                    PIC X(8).\n                 05  DSNAME                    PIC X(44).\n                 05  MEMBER-NAME               PIC X(8).\n                 05  SUCCESS-INDICATOR         PIC 9(2).\n\n\n\n\n1                                                        ALLOCMEM.2\n                                                         03/16/83\n\n\n       o    Place the following code in the PROCEDUREDIVISION:\n\n            MOVE your ddname\n              TO DDNAME OF ALLOCMEM-I-O-AREA.\n            MOVE your dsname of your partitioned dataset\n              TO DSNAME OF ALLOCMEM-I-O-AREA.\n            MOVE your member name\n              TO MEMBER-NAME OF ALLOCMEM-I-O-AREA.\n\n            CALL 'ALLOCMEM' USING ALLOCMEM-I-O-AREA.\n\n       o    After     the   CALL    of     ALLOCMEM,    interrogate\n            SUCCESS-INDICATOR             OF     ALLOCMEM-I-O-AREA.\n            SUCCESS-INDICATOR  will contain  one  of the  following\n            values after the call:\n\n                      VALUE              MEANING\n                      -----     -----------------------------\n                        00      Allocation was successful\n                        04      Invalid or missing ddname\n                        08      Invalid or missing dsname\n                        12      Invalid or missing member name\n                        16      Dataset not catalogued\n                        20      Unsuccessful free of ddname\n                        24      Unsuccessful dynamic allocation\n  NOTE:     Make  sure that  DDNAME,  DSNAME,  and MEMBER-NAME  are\n            padded with spaces if less than maximum size.\n\n\n\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "ALLOCMEM": {"ttr": 2574, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x00\\x7f\\x00\\x88\\x00\\x7f\\x12\\x00\\x01H\\x01H\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf2\\xf7\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-01-07T00:00:00", "modifydate": "1988-01-07T12:00:00", "lines": 328, "newlines": 328, "modlines": 0, "user": "FILE270"}, "text": "         PRINT ON,NOGEN\n         SPACE 3\n*        THIS PROGRAM IS A SUBROUTINE WHICH DYNAMICALLY ALLOCATES\n*        A PARTITIONED DATASET AND ITS MEMBER TO THE DDNAME PROVIDED\n*\n*        TO CALL THIS SUBROUTINE FROM A COBOL PROGRAM, DO THE\n*        FOLLOWING:\n*\n*            .  PLACE THE FOLLOWING DATA AREA IN WORKING STORAGE:            001\n*\n*                    01  ALLOCMEM-I-O-AREA.                                  001\n*                        05  DDNAME                      PIC X(8).           001\n*                        05  DSNAME                      PIC X(44).          001\n*                        05  MEMBER-NAME                 PIC X(8).           001\n*                        05  SUCCESS-INDICATOR           PIC 9(2).           001\n*\n*            .  PLACE THE FOLLOWING CODE IN PROCEDURE DIVISION:\n*\n*                    MOVE YOUR DDNAME\n*                      TO DDNAME OF ALLOCMEM-I-O-AREA.\n*                    MOVE YOUR DSNAME OF YOUR PARTITIONED DATASET\n*                      TO DSNAME OF ALLOCMEM-I-O-AREA.\n*                    MOVE YOUR MEMBER NAME\n*                      TO MEMBER-NAME OF ALLOCMEM-I-O-AREA.\n*\n*                    CALL 'ALLOCMEM' USING ALLOCMEM-I-O-AREA.             001100\n*\n*\n*            .  MAKE SURE THAT DDNAME, DSNAME, AND MEMBER-NAME\n*               ARE PADDED WITH SPACES IF LESS THAN MAXIMUM SIZE\n*\n*\n*        SUCCESS-INDICATOR\n*        -----------------\n*\n*                  00     ALLOCATION WAS SUCCESSFUL\n*                  04     INVALID OR MISSING DDNAME\n*                  08     INVALID OR MISSING DSNAME\n*                  12     INVALID OR MISSING MEMBER NAME\n*                  16     DATASET NOT CATALOGUED\n*                  20     UNSUCCESSFUL FREE OF DDNAME\n*                  24     UNSUCCESSFUL DYNAMIC ALLOCATION\n*\n*\n         EJECT\n         SPACE 3\n*\n**********************************************\n*                                            *\n*        I N I T I A L I Z A T I O N         *\n*                                            *\n**********************************************\n*\nALLOCMEM CSECT\n         SAVE  (14,12)\n         BALR  12,0\n         USING *,12\n         ST    13,SAVEAREA+4\n         LA    13,SAVEAREA\n         B     STARTIT\n         SPACE\nSAVEAREA DC    18F'0'\n         SPACE 3\n********************************************************************\n*        EQUATE RESISTERS 0 THRU 15 TO MORE MEANINGFUL NAMES       *\n********************************************************************\n         SPACE 3\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n         EJECT\n         SPACE 3\n********************************************************************\n*                                                                  *\n*        SAVE REGISTER 1 CONTENTS IN REGISTER 11 AND PLACE         *\n*        PARAMETER AREA INTO IOAREA                                *\n*                                                                  *\n********************************************************************\n         SPACE 3\nSTARTIT  DS    0D\n         LR    R11,R1                 SAVE REG 1 CONTENTS IN REG 11\n         L     R9,0(R11)\n         MVC   IOAREA,0(R9)\n         EJECT\n         SPACE 3\n********************************************************************\n*                                                                  *\n*        M A I N   L I N E   L O G I C                             *\n*                                                                  *\n********************************************************************\n         SPACE 3\n         MVC   SUCCESSW,=CL2'00'      MOVE '00' TO SUCCESSW\n         LA    R10,0                  R10 ===> 0\n         BAL   R14,GENLENS            PERFORM ROUTINE TO DETERMINE\n*                                       THE SIGNIFICANT LENGTHS OF\n*                                       DDNAME, DSNAME, AND MEM NAME\n         CLC   SUCCESSW,=CL2'00'      IS SUCCESSW STILL EQUAL '00' ?\n         BNE   SHUTDOWN               IF NOT, BRANCH TO SHUTDOWN\n         MVC   CMLSTDSN,INDSNAME\n         LOCATE CAMLIST1\n         C     R15,=F'0'              DID LOCATE RETURN RC = 0 ?\n         BE    DYNAMALL               IF SO, BRANCH TO DYNAMALL\n         MVC   SUCCESSW,=CL2'16'      MOVE '16' TO SUCCESSW\n         LA    R10,16                 R10 ===> 16\n         B     SHUTDOWN               BRANCH TO SHUTDOWN\nDYNAMALL BAL   R14,DYNAMALC           PERFORM DYNAMIC ALLOCATION\n         B     SHUTDOWN               BRANCH TO SHUTDOWN\n         EJECT\n         SPACE 2\n********************************************************************\n*                                                                  *\n*        THIS ROUTINE IS RESPONSIBLE FOR VALIDATING THE DDNAME,    *\n*        DSNAME, AND MEMBER NAME PASSED TO THIS PROGRAM AND THEN   *\n*        GENERATING THE FOLLOWING FIELDS:                          *\n*                                                                  *\n*           DDNAMLEN ===> LENGTH OF DDNAME (BINARY HALFWORD)       *\n*           DSNAMLEN ===> LENGTH OF DSNAME (BINARY HALFWORD)       *\n*           MEMBRLEN ===> LENGTH OF MEMBER (BINARY HALFWORD)       *\n*                                                                  *\n********************************************************************\n*\nGENLENS  ST    R14,SAVEIT1           SAVE REG 14 IN SAVEIT1\n         LA    R5,8                  R5 ==> 8\n         LA    R6,INDDNAME+7         POINT TO LAST BYTE OF DDNAME\nLOOP1    CLI   0(R6),C' '            IS THIS BYTE = SPACE ?\n         BNE   STDDNLEN              IF NOT, BRANCH TO STDDNLEN\n         SH    R5,=H'1'              DECREMENT REG 5 BY 1\n         SH    R6,=H'1'              DECREMENT REG 6 BY 1\n         CH    R5,=H'1'\n         BNL   LOOP1\n         MVC   SUCCESSW,=CL2'04'     MOVE '04' TO SUCCESSW\n         LA    R10,04                R10 ===> 04\n         B     EXITGENS              BRANCH TO EXITGENS\nSTDDNLEN STH   R5,DDNAMLEN           DDNAMLEN = LENGTH OF DDNAME\n         LA    R5,44                 R5 ==> 44\n         LA    R6,INDSNAME+43        POINT TO LAST BYTE OF DSNAME\nLOOP2    CLI   0(R6),C' '            IS THIS BYTE = SPACE ?\n         BNE   STDSNLEN              IF NOT, BRANCH TO STDSNLEN\n         SH    R5,=H'1'              DECREMENT REG 5 BY 1\n         SH    R6,=H'1'              DECREMENT REG 6 BY 1\n         CH    R5,=H'1'\n         BNL   LOOP2\n         MVC   SUCCESSW,=CL2'08'     MOVE '08' TO SUCCESSW\n         LA    R10,08                R10 ===> 08\n         B     EXITGENS              BRANCH TO EXITGENS\nSTDSNLEN STH   R5,DSNAMLEN           DSNAMLEN = LENGTH OF DSNAME\n         LA    R5,8                  R5 ==> 8\n         LA    R6,INMEMBER+7         POINT TO LAST BYTE OF MEMBER\nLOOP3    CLI   0(R6),C' '            IS THIS BYTE = SPACE ?\n         BNE   STMEMLEN              IF NOT, BRANCH TO STMEMLEN\n         SH    R5,=H'1'              DECREMENT REG 5 BY 1\n         SH    R6,=H'1'              DECREMENT REG 6 BY 1\n         CH    R5,=H'1'\n         BNL   LOOP3\n         MVC   SUCCESSW,=CL2'12'     MOVE '12' TO SUCCESSW\n         LA    R10,12                R10 ===> 12\n         B     EXITGENS              BRANCH TO EXITGENS\nSTMEMLEN STH   R5,MEMBRLEN           MEMBRLEN = LENGTH OF MEMBER\nEXITGENS L     R14,SAVEIT1           RESTORE REGISTER 14\n         BR    R14                   RETURN\n         EJECT\n         SPACE 3\n*\n********************************************************************\n*                                                                  *\n*               D Y N A M I C   A L L O C A T I O N                *\n*               -----------------------------------                *\n*                                                                  *\n*        THIS ROUTINE FIRST ATTEMPTS TO FREE THE DDNAME GIVEN.     *\n*        IF THE DDNAME WAS SUCCESSFULLY FREED, THEN THIS ROUTINE   *\n*        BRANCHES TO THE DYNAMIC ALLOCATION MACRO DYNALLOC.        *\n*        HOWEVER, IF THE DDNAME  WAS NOT SUCCESSFULLY FREED,       *\n*        THEN THIS ROUTINE CHECKS FOR ERROR REASON CODE 0438       *\n*        (DDNAME NOT FOUND).  IF THE ERROR REASON CODE IS 0438,    *\n*        THEN THIS ROUTINE BRANCHES TO THE DYNAMIC ALLOCATION      *\n*        MACRO DYNALLOC, ELSE IT MOVES '20' TO SUCCESSW            *\n*                                                                  *\n********************************************************************\n*\nDYNAMALC ST    R14,SAVEIT2\n         MVC   FREEUT1A,DDNAMLEN\n         MVC   FREEUT1B,INDDNAME\n         LA    R1,FREEPARM\n         DYNALLOC                      FREE DDNAME\n         LTR   R15,R15                 TEST REGISTER 15 FOR ZERO\n         BZ    DODYNAM                 IF ZERO, BRANCH TO DODYNAM\n         CLC   ERCODE,HEX0438          COMPARE ERROR REASON CODE\n*                                         AGAINST HEXADECIMAL 0438\n         BE    DODYNAM                 IF EQUAL, BRANCH TO DODYNAM\n         MVC   SUCCESSW,=CL2'20'       MOVE '20' TO SUCCESSW\n         LA    R10,20                  R10 ===> 20\n         BR    R14                     RETURN\nDODYNAM  MVC   DD1UNT1A,DDNAMLEN\n         MVC   DD1UNT1B,INDDNAME\n         MVC   DSNLEN,DSNAMLEN\n         MVC   DSNAME,INDSNAME\n         MVC   MEMLEN,MEMBRLEN\n         MVC   MEMBER,INMEMBER\n         LA    R1,DD1PARM\n         DYNALLOC                      ALLOC F(DDNAME) DA(DSN) SHR\n         L     R14,SAVEIT2\n         LTR   R15,R15                 TEST REGISTER 15 FOR ZERO\n         BZR   R14                     IF ZERO, RETURN\n         MVC   SUCCESSW,=CL2'24'       MOVE '24' TO SUCCESSW\n         LA    R10,24                  R10 ===> 24\n         BR    R14                     RETURN\n         EJECT\n         SPACE 3\n********************************************************************\n*                                                                  *\n*        E N D   O F   J O B   P R O C E S S I N G                 *\n*                                                                  *\n********************************************************************\n         SPACE 3\nSHUTDOWN L     R9,0(R11)\n         MVC   0(62,R9),IOAREA\n         LR    R15,R10\n         L     R13,4(R13)\n         RETURN (14,12),RC=(15)\n         EJECT\n         SPACE 3\n*\n********************************************************************\n*                                                                  *\n*        DATA STRUCTURE FOR FREEING OF DDNAME                      *\n*                                                                  *\n********************************************************************\n*\n         SPACE 3\n         DS    0F\nFREEPARM DC    X'80'         TURN ON HIGH ORDER BIT\n         DC    AL3(FREERB)   ADDRESS OF REQUEST BLOCK\nFREERB   DC    X'14'         S99RBLN (LENGTH OF REQUEST BLOCK)\n         DC    X'02'         S99VERB (REQUEST FOR UNALLOCATION)\n         DC    X'2000'       S99FLAG1 (DO NOT MOUNT VOLUMES)\nERCODE   DC    X'0000'       S99ERROR (ERROR REASON CODE)\n         DC    X'0000'       S99INFO (INFORMATION REASON CODE)\n         DC    A(FREETUPL)   S99TXTPP (ADDR OF POINTER TO TEXT UNIT)\n         DC    X'00000000'   RESERVED\n         DC    X'00000000'   S99FLAG2\nFREETUPL DC    A(FREEUNT1)   ADDRESS OF TEXT UNIT #1\n         DC    X'80'         TURN ON HIGH ORDER BIT\n         DC    AL3(FREEUNT2) ADDRESS OF TEXT UNIT #2\nFREEUNT1 DC    X'0001'\n         DC    X'0001'\nFREEUT1A DS    BL2\nFREEUT1B DS    CL8\nFREEUNT2 DC    X'0007'       REMOVE PERM ALLOC ATTR\n         DC    X'0000'\n         EJECT\n         SPACE 3\n*\n********************************************************************\n*                                                                  *\n*        DATA STRUCTURE FOR DYNAMIC ALLOCATION                     *\n*                                                                  *\n********************************************************************\n*\n         SPACE 3\n         DS    0F\nDD1PARM  DC    X'80'         TURN ON HIGH ORDER BIT\n         DC    AL3(DD1RB)    ADDRESS OF REQUEST BLOCK\nDD1RB    DC    X'14'         S99RBLN (LENGTH OF REQUEST BLOCK)\n         DC    X'01'         S99VERB (REQUEST FOR DSNAME ALLOC)\n         DC    X'2000'       S99FLAG1 (DO NOT MOUNT VOLUMES)\n         DC    X'0000'       S99ERROR (ERROR REASON CODE)\n         DC    X'0000'       S99INFO (INFORMATION REASON CODE)\n         DC    A(DD1TUPL)    S99TXTPP (ADDR OF POINTERS TO TEXT UNITS\n         DC    X'00000000'   RESERVED\n         DC    X'00000000'   S99FLAG2\nDD1TUPL  DC    A(DD1UNIT1)   ADDRESS OF TEXT UNIT #1\n         DC    A(DD1UNIT2)   ADDRESS OF TEXT UNIT #2\n         DC    A(DD1UNIT3)   ADDRESS OF TEXT UNIT #3\n         DC    A(DD1UNIT4)   ADDRESS OF TEXT UNIT #4\n         DC    X'80'         TURN ON HIGH ORDER BIT\n         DC    AL3(DD1UNIT5) ADDRESS OF TEXT UNIT #5\nDD1UNIT1 DC    X'0001'\n         DC    X'0001'\nDD1UNT1A DS    BL2\nDD1UNT1B DS    CL8\nDD1UNIT2 DC    X'0002'\n         DC    X'0001'\nDSNLEN   DS    BL2\nDSNAME   DS    CL44\nDD1UNIT3 DC    X'0003'\n         DC    X'0001'\nMEMLEN   DS    BL2\nMEMBER   DS    CL8\nDD1UNIT4 DC    X'0004',X'0001',X'0001',X'08'\nDD1UNIT5 DC    X'0052'\n         DC    X'0000'\n         EJECT\n         SPACE 3\n********************************************************************\n*        DATA AREAS                                                *\n********************************************************************\n         SPACE 3\n         DS    0F\nSAVEIT1  DS    F\nSAVEIT2  DS    F\nDDNAMLEN DS    H\nDSNAMLEN DS    H\nMEMBRLEN DS    H\nIOAREA   DS    0CL62\nINDDNAME DS    CL8\nINDSNAME DS    CL44\nINMEMBER DS    CL8\nSUCCESSW DS    CL2\nCMLSTDSN DS    CL44\nCAMLIST1 CAMLST NAME,CMLSTDSN,,LOCAREA\nLOCAREA  DS    0D\n         DS    265C\n         DS    0D\nHEX0438  DC    X'0438'\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "BLKING": {"ttr": 2822, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x00\\x7f\\x00\\x88\\x00\\x7f\\x12\\x00\\x01\\x1d\\x01\\x1d\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf2\\xf7\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-01-07T00:00:00", "modifydate": "1988-01-07T12:00:00", "lines": 285, "newlines": 285, "modlines": 0, "user": "FILE270"}, "text": "      *******************************                                        ***\n       ID DIVISION.                                                          ...\n      *******************************                                   05/27/80\n                                                                        23521ALL\n       PROGRAM-ID. BLKING.                                              01 LV003\n       AUTHOR.     GARY DUFFIELD.                                       00006\n       REMARKS.\n                   THIS PROGRAM COMPUTES OPTIMUM BLKSIZE AND SPACE\n             ALLOCATIONS FOR 3330, 3350 OR 3380 DISK PACKS.\n           EJECT                                                        00007\n      *******************************                                   00008\n       ENVIRONMENT DIVISION.                                            00009\n      *******************************                                   00010\n                                                                        00011\n       CONFIGURATION SECTION.\n\n       SPECIAL-NAMES.\n                                                                        00011\n       INPUT-OUTPUT SECTION.                                            00012\n\n       FILE-CONTROL.                                                    00013\n\n           EJECT                                                        00015\n      *******************************                                   00016\n       DATA DIVISION.                                                   00017\n      *******************************                                   00018\n                                                                        00019\n       FILE SECTION.                                                    00020\n                                                                        00021\n       WORKING-STORAGE SECTION.                                         00033\n     5 77  PAN-VALET PICTURE X(24) VALUE '007CBT1536   10/27/89'.       00033\n                                                                        00034\n       01  SWITCHES.                                                    00035\n           05  3330-BIG                 PIC XXX     VALUE 'NO '.        00036\n               88  3330-EXCEEDED                    VALUE 'YES'.        00037\n                                                                        00044\n           05  3350-BIG                 PIC XXX     VALUE 'NO '.        00036\n               88  3350-EXCEEDED                    VALUE 'YES'.        00037\n                                                                        00044\n           05  3380-BIG                 PIC XXX     VALUE 'NO '.        00036\n               88  3380-EXCEEDED                    VALUE 'YES'.        00037\n                                                                        00044\n       01  WORK-AREAS.\n           05  UNITTYPE                 PIC X(21)         VALUE SPACE.\n           05  TRKCYL                   PIC XXX           VALUE 'TRK'.  00088\n           05  BLOCKSIZE                PIC Z(4)9         VALUE ZERO.   00088\n           05  PRIMARYA                 PIC Z(4)9         VALUE ZERO.   00088\n           05  SECONDARYA               PIC Z(4)9         VALUE ZERO.   00088\n           05  BLKSIZE                  PIC S9(9)  COMP-3 VALUE ZERO.   00088\n           05  PRIMARY                  PIC S9(9)  COMP-3 VALUE ZERO.   00088\n           05  SECONDARY                PIC S9(9)  COMP-3 VALUE ZERO.   00088\n           05  TRKSINCYL                PIC S9(9)  COMP-3 VALUE ZERO.   00088\n           05  MAXBLK                   PIC S9(9)  COMP-3 VALUE ZERO.   00088\n           05  MAXSIZE                  PIC S9(9)  COMP-3 VALUE ZERO.   00088\n           05  MAXSIZE1                 PIC S9(9)  COMP-3 VALUE ZERO.   00088\n           05  RECINBLK                 PIC S9(9)  COMP-3 VALUE ZERO.   00088\n           05  RECINTRK                 PIC S9(9)  COMP-3 VALUE ZERO.   00088\n           05  NOOFTRKS                 PIC S9(9)  COMP-3 VALUE ZERO.   00088\n           05  HOLDSIZE                 PIC S9(9)  COMP-3 VALUE ZERO.   00088\n           05  NOOFCYLS                 PIC S9(9)  COMP-3 VALUE ZERO.   00088\n           05  HOLDCYLS                 PIC S9(9)  COMP-3 VALUE ZERO.   00088\n           05  BLKPERTRK                PIC S9(9)  COMP-3 VALUE ZERO.   00088\n           05  BLKFCTR                  PIC S9(9)  COMP-3 VALUE ZERO.   00088\n           05  OVERHEAD                 PIC S9(9)  COMP-3 VALUE ZERO.   00088\n           05  TEST-BLKSIZE             PIC S9(9)  COMP-3 VALUE ZERO.   00088\n           05  HOLD-RECSINTRK           PIC S9(9)  COMP-3 VALUE ZERO.   00088\n           05  RECSINTRK                PIC S9(9)  COMP-3 VALUE ZERO.   00088\n           05  BLKPERTRK1               PIC S9(9)  COMP-3 VALUE ZERO.   00088\n           05  RECSINTRK1               PIC S9(9)  COMP-3 VALUE ZERO.   00088\n               EJECT                                                    00238\n      *******************************                                   00257\n       LINKAGE SECTION.                                                 00258\n      *******************************                                   00259\n\n      * THE LRECL AND APPROXIMATE NUMBER OF RECORDS IN THE FILE ARE     00021\n      * PASSED TO THE PROGRAM HERE.                                     00021\n                                                                        00044\n         01 PARM-FIELDS.\n            05  PARM-LENGTH             PIC S9(4) COMP.\n            05  LRECL                   PIC 9(7).\n            05  FILESIZE                PIC 9(9).\n               EJECT                                                    00238\n      **************************************                            00239\n       PROCEDURE DIVISION USING PARM-FIELDS.                            00240\n      **************************************                            00241\n       100-CONTROL-MODULE.                                              00242\n      *******************************                                   00243\n                                                                        00244\n           PERFORM 300-PROCESS-PARMS-MODULE.                            00246\n           STOP RUN.                                                    00255\n           EJECT                                                        00256\n      *******************************                                   00257\n       300-PROCESS-PARMS-MODULE.                                        00258\n      *******************************                                   00259\n                                                                        00260\n           DISPLAY '            UNIT TYPE          BLKSIZE   SPACE    ' 00260\n                   ' PRIMARY      SECONDARY'\n           DISPLAY '                                         UNIT'      00260\n           IF LRECL > 13030                                             00261\n                DISPLAY '     3330                        CANNOT BE'    00261\n                        ' USED (LRECL TOO LARGE)'                       00261\n                MOVE 'YES' TO 3330-BIG\n           ELSE\n                PERFORM 310-COMPUTE-3330.\n           IF LRECL > 19069                                             00261\n                DISPLAY '     3350                        CANNOT BE'    00261\n                        ' USED (LRECL TOO LARGE)'                       00261\n                MOVE 'YES' TO 3350-BIG\n           ELSE\n                PERFORM 320-COMPUTE-3350.\n           IF LRECL > 32767                                             00261\n                DISPLAY '     3380                        CANNOT BE'    00261\n                        ' USED (LRECL TOO LARGE)'                       00261\n                MOVE 'YES' TO 3380-BIG\n           ELSE\n                PERFORM 330-COMPUTE-3380.\n           IF 3330-EXCEEDED OR 3350-EXCEEDED                            00261\n                DISPLAY '     3330-3350 COMPATIBLE        (NOT'         00261\n                        ' APPLICABLE)'                                  00261\n           ELSE\n                PERFORM 340-COMPUTE-3050.\n           IF 3350-EXCEEDED OR 3380-EXCEEDED                            00261\n                DISPLAY '     3350-3380 COMPATIBLE        (NOT'         00261\n                        ' APPLICABLE)'                                  00261\n           ELSE\n                PERFORM 350-COMPUTE-5080.\n                                                                        00260\n      *******************************                                   00257\n       310-COMPUTE-3330.                                                00258\n      *******************************                                   00259\n                                                                        00260\n           MOVE '3330' TO UNITTYPE.\n           MOVE     19 TO TRKSINCYL.                                    00260\n           MOVE      0 TO HOLD-RECSINTRK.                               00260\n           MOVE  13165 TO MAXSIZE.                                      00260\n           MOVE    135 TO OVERHEAD.\n           MOVE      0 TO BLKFCTR.                                      00260\n           MOVE      0 TO TEST-BLKSIZE.                                 00260\n           PERFORM 400-CHECK-BEST-MODULE                                00260\n              UNTIL TEST-BLKSIZE > MAXSIZE.\n           PERFORM 500-COMPUTE-MODULE.                                  00260\n                                                                        00260\n      *******************************                                   00257\n       320-COMPUTE-3350.                                                00258\n      *******************************                                   00259\n                                                                        00260\n           MOVE '3350' TO UNITTYPE.\n           MOVE     30 TO TRKSINCYL.                                    00260\n           MOVE      0 TO HOLD-RECSINTRK.                               00260\n           MOVE  19254 TO MAXSIZE.                                      00260\n           MOVE    185 TO OVERHEAD.\n           MOVE      0 TO BLKFCTR.                                      00260\n           MOVE      0 TO TEST-BLKSIZE.                                 00260\n           PERFORM 400-CHECK-BEST-MODULE                                00260\n              UNTIL TEST-BLKSIZE > MAXSIZE.\n           PERFORM 500-COMPUTE-MODULE.                                  00260\n                                                                        00260\n      *******************************                                   00257\n       330-COMPUTE-3380.                                                00258\n      *******************************                                   00259\n                                                                        00260\n           MOVE '3380' TO UNITTYPE.\n           MOVE     15 TO TRKSINCYL.                                    00260\n           MOVE      0 TO HOLD-RECSINTRK.                               00260\n           MOVE  47968 TO MAXSIZE.                                      00260\n           MOVE    480 TO OVERHEAD.\n           MOVE      0 TO BLKFCTR.                                      00260\n           MOVE      0 TO TEST-BLKSIZE.                                 00260\n           PERFORM 400-CHECK-BEST-MODULE                                00260\n              UNTIL TEST-BLKSIZE > 32767.\n           PERFORM 500-COMPUTE-MODULE.                                  00260\n                                                                        00260\n      *******************************                                   00257\n       340-COMPUTE-3050.                                                00258\n      *******************************                                   00259\n                                                                        00260\n           MOVE '3330-3350 COMPATIBLE' TO UNITTYPE.\n           MOVE     19 TO TRKSINCYL.                                    00260\n           MOVE      0 TO HOLD-RECSINTRK.                               00260\n           MOVE  13165 TO MAXSIZE.                                      00260\n           MOVE  19254 TO MAXSIZE1.                                     00260\n           MOVE    185 TO OVERHEAD.\n           MOVE      0 TO BLKFCTR.                                      00260\n           MOVE      0 TO TEST-BLKSIZE.                                 00260\n           PERFORM 420-CHECK-BEST-OF-BOTH-MODULE                        00260\n              UNTIL TEST-BLKSIZE > MAXSIZE.\n           PERFORM 500-COMPUTE-MODULE.                                  00260\n                                                                        00260\n      *******************************                                   00257\n       350-COMPUTE-5080.                                                00258\n      *******************************                                   00259\n                                                                        00260\n           MOVE '3350-3380 COMPATIBLE' TO UNITTYPE.\n           MOVE     15 TO TRKSINCYL.                                    00260\n           MOVE      0 TO HOLD-RECSINTRK.                               00260\n           MOVE  19254 TO MAXSIZE.                                      00260\n           MOVE  47968 TO MAXSIZE1.                                     00260\n           MOVE    480 TO OVERHEAD.\n           MOVE      0 TO BLKFCTR.                                      00260\n           MOVE      0 TO TEST-BLKSIZE.                                 00260\n           PERFORM 420-CHECK-BEST-OF-BOTH-MODULE                        00260\n              UNTIL TEST-BLKSIZE > MAXSIZE.\n           PERFORM 500-COMPUTE-MODULE.                                  00260\n           EJECT                                                        00256\n      *******************************                                   00257\n       400-CHECK-BEST-MODULE.                                           00258\n      *******************************                                   00259\n                                                                        00260\n           ADD 1 TO BLKFCTR\n           COMPUTE TEST-BLKSIZE = (LRECL * BLKFCTR) + OVERHEAD.         00260\n           IF TEST-BLKSIZE NOT > MAXSIZE                                00260\n              PERFORM 410-COMPUTE-BEST-MODULE.                          00260\n                                                                        00260\n      *******************************                                   00257\n       410-COMPUTE-BEST-MODULE.                                         00258\n      *******************************                                   00259\n                                                                        00260\n           COMPUTE BLKPERTRK = MAXSIZE / TEST-BLKSIZE.                  00260\n           COMPUTE RECSINTRK = BLKPERTRK * BLKFCTR.                     00260\n           IF RECSINTRK > HOLD-RECSINTRK                                00260\n              MOVE RECSINTRK      TO HOLD-RECSINTRK                     00260\n              MOVE RECSINTRK      TO RECINTRK                           00260\n              MOVE BLKFCTR        TO RECINBLK                           00260\n              COMPUTE BLKSIZE = TEST-BLKSIZE - OVERHEAD.                00260\n                                                                        00260\n      *******************************                                   00257\n       420-CHECK-BEST-OF-BOTH-MODULE.                                   00258\n      *******************************                                   00259\n                                                                        00260\n           ADD 1 TO BLKFCTR.\n           COMPUTE TEST-BLKSIZE =                                       00260\n                   (LRECL * BLKFCTR) + OVERHEAD.                        00260\n           IF TEST-BLKSIZE NOT > MAXSIZE                                00260\n              PERFORM 430-COMPUTE-BEST-OF-BOTH.                         00260\n                                                                        00260\n      *******************************                                   00257\n       430-COMPUTE-BEST-OF-BOTH.                                        00258\n      *******************************                                   00259\n                                                                        00260\n           COMPUTE BLKPERTRK = MAXSIZE / TEST-BLKSIZE.                  00260\n           COMPUTE RECSINTRK = BLKPERTRK * BLKFCTR.                     00260\n           COMPUTE BLKPERTRK1 = MAXSIZE1 / TEST-BLKSIZE.                00260\n           COMPUTE RECSINTRK1 = BLKPERTRK1 * BLKFCTR.                   00260\n           IF RECSINTRK NOT < RECSINTRK1\n              COMPUTE RECSINTRK =\n                 (RECSINTRK + RECSINTRK1) - (RECSINTRK - RECSINTRK1)\n           ELSE\n              COMPUTE RECSINTRK =\n                 (RECSINTRK1 + RECSINTRK) - (RECSINTRK1 - RECSINTRK).\n           IF RECSINTRK > HOLD-RECSINTRK                                00260\n              MOVE RECSINTRK      TO HOLD-RECSINTRK                     00260\n              MOVE RECSINTRK      TO RECINTRK                           00260\n              MOVE BLKFCTR        TO RECINBLK                           00260\n              COMPUTE BLKSIZE = TEST-BLKSIZE - OVERHEAD.                00260\n           EJECT                                                        00260\n      *******************************                                   00257\n       500-COMPUTE-MODULE.                                              00258\n      *******************************                                   00259\n                                                                        00260\n           COMPUTE NOOFTRKS  = FILESIZE / RECINTRK.                     00260\n           COMPUTE HOLDSIZE  = NOOFTRKS * RECINTRK.                     00260\n           IF HOLDSIZE < FILESIZE                                       00260\n                ADD 1 TO NOOFTRKS.                                      00260\n           MOVE NOOFTRKS TO PRIMARY.                                    00260\n           COMPUTE NOOFCYLS = NOOFTRKS / TRKSINCYL.                     00260\n           IF NOOFCYLS > ZERO                                           00260\n                MOVE 'CYL' TO TRKCYL                                    00260\n                MOVE NOOFCYLS TO PRIMARY\n                COMPUTE HOLDCYLS  = NOOFCYLS * TRKSINCYL                00260\n                IF HOLDCYLS < NOOFTRKS                                  00260\n                     ADD 1 TO PRIMARY.                                  00260\n           COMPUTE SECONDARY  = PRIMARY / 4.                            00260\n           COMPUTE PRIMARY  = PRIMARY - SECONDARY.                      00260\n           IF SECONDARY = 0                                             00260\n                MOVE 1 TO SECONDARY.                                    00260\n           MOVE BLKSIZE TO BLOCKSIZE.\n           MOVE PRIMARY TO PRIMARYA.\n           MOVE SECONDARY TO SECONDARYA.\n           DISPLAY '     ' UNITTYPE '     ' BLOCKSIZE '     ' TRKCYL    00260\n                '      ' PRIMARYA '         ' SECONDARYA                00260\n           MOVE ZERO TO BLKSIZE PRIMARY SECONDARY TRKSINCYL MAXBLK      00260\n                RECINBLK RECINTRK NOOFTRKS HOLDSIZE NOOFCYLS TRKSINCYL  00088\n                HOLDCYLS.                                               00088\n           MOVE SPACE TO UNITTYPE.\n           MOVE 'TRK' TO TRKCYL.\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "BLKING$": {"ttr": 2828, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x00\\x7f\\x00\\x88\\x00\\x7f\\x12\\x00\\x006\\x006\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf2\\xf7\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-01-07T00:00:00", "modifydate": "1988-01-07T12:00:00", "lines": 54, "newlines": 54, "modlines": 0, "user": "FILE270"}, "text": "1                                                        BLKING.1\n                                                         06/25/82\n\n\n  CLIST:              BLKING\n  AUTHOR:             Gary Duffield\n  AGENCY:             Department of Labor and Industries\n  FUNCTION:           Indicate optimum blocksize and required space\n                      for allocation of a disk file.\n\n  TERMINAL TYPE:      3270 type or dialup.\n\n  This CLIST, when  given the logical record length  and the number\n  of records  to be written  to the file,  will present to  you the\n  optimum blocksize  and required  SPACE for  placing onto  a 3330,\n  3350 or 3380 disk pack.\n\n  Syntax -\n\n  _________________________________________________________________\n       Command        Operands\n  _________________________________________________________________\n       BLKING         lrecl filesize\n  _________________________________________________________________\n\n  Required positional operands\n       lrecl     - logical record length\n       filesize  - estimation of number of records on the file\n\n\n\n\n1                                                        BLKING.2\n                                                         06/25/82\n\n\n  Example\n  _______\n\n       You enter:\n            BLKING 132 1000\n\n       The CLIST will return:\n\n            UNIT TYPE          BLKSIZE   SPACE   PRIMARY   SECONDARY\n       3330                      6336     TRK       9          2\n       3350                      9372     TRK       6          1\n       3380                     23364     TRK       3          1\n       3330-3350 COMPATIBLE      6204     TRK       9          2\n       3350-3380 COMPATIBLE      6204     TRK       6          2\n\n\n\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "BREAKDSN": {"ttr": 3073, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x00\\x7f\\x00\\x88\\x00\\x7f\\x12\\x00\\x01F\\x01F\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf2\\xf7\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-01-07T00:00:00", "modifydate": "1988-01-07T12:00:00", "lines": 326, "newlines": 326, "modlines": 0, "user": "FILE270"}, "text": "000010*******************************\n000100 ID DIVISION.\n000110*******************************\n000200 PROGRAM-ID.     BREAKDSN.\n000300 AUTHOR.         GARY DUFFIELD.\n000310 REMARKS.\n000320                 THIS PROGRAM EDITS ANY DATASET NAME PASSED TO IT\n000330                 AND SPLITS OUT THE PDS MEMBER NAME IF IT EXISTS.\n000340\n000350*******************************\n000400 ENVIRONMENT DIVISION.\n000410*******************************\n000500 CONFIGURATION SECTION.\n000600 SOURCE-COMPUTER. IBM-370.\n000700 OBJECT-COMPUTER. IBM-370.\n000800\n000810*******************************\n000900 DATA DIVISION.\n000910*******************************\n001100 WORKING-STORAGE SECTION.\n001300 01  TABLES.\n001400     05  WORK-DSN-INPUT                  PIC X(44).\n001500     05  DSN-CHARACTER REDEFINES WORK-DSN-INPUT\n001600         OCCURS 44 TIMES INDEXED BY INX  PIC X.\n001700\n001800     05  WORK-DSN-OUTPUT                 PIC X(44).\n001900     05  DSN-CHAR-OUT REDEFINES WORK-DSN-OUTPUT\n002000         OCCURS 44 TIMES INDEXED BY INY  PIC X.\n002100\n002200     05  WORK-MEMBER                     PIC X(8).\n002300     05  DSN-CHAR-MEMBER REDEFINES WORK-MEMBER\n002400         OCCURS 8 TIMES INDEXED BY INZ   PIC X.\n002500\n002600 01  SWITCHES.\n002700     05  BAD-CHAR                        PIC X(3).\n002800         88  BAD-CHARACTER                           VALUE 'YES'.\n002850     05  QUOTE-CHAR                      PIC 9(5) COMP-3.\n002860         88  TOO-MANY-QUOTES                    VALUE 3 THRU 44.\n002870         88  NOT-ENOUGH-QUOTES                  VALUE 1.\n002900\n003000 01  ACCUMULATORS.\n003100     05  PERFORM-COUNT                   PIC 9(5) COMP-3.\n003110     05  CHAR-COUNT                      PIC 9(5) COMP-3.\n003200\n003300     EJECT\n003310*******************************\n003400 LINKAGE SECTION.\n003410*******************************\n003500\n003600 01  BREAKDSN-IO-AREA.\n003700     05  INPUT-DSN                       PIC X(44).\n003800     05  OUTPUT-DSN                      PIC X(44).\n003900     05  OUTPUT-MEMBER-NAME              PIC X(8).\n004000     05  MEMBER-NAME-PROVIDED            PIC X(3).\n004010     05  GDG-TYPE-DATASET                PIC X(3).\n004100     05  VALID-DSN-PASSED                PIC X(3).\n004200     05  ERROR-MESSAGE                   PIC X(30).\n004300     EJECT\n004400********************************************\n004500 PROCEDURE DIVISION USING BREAKDSN-IO-AREA.\n004600********************************************\n004700 0100-MAIN-MODULE.\n004800********************************************\n004900\n004910     PERFORM 0110-INITIALIZE-MODULE.\n004911     IF DSN-CHARACTER (INX) = SPACE OR '('\n004912        MOVE 'YES' TO BAD-CHAR.\n004920     IF DSN-CHARACTER (INX) = QUOTE\n004930        COMPUTE QUOTE-CHAR = QUOTE-CHAR + 1\n004940        MOVE DSN-CHARACTER (INX) TO DSN-CHAR-OUT (INY)\n004950        SET INX UP BY 1\n004960        SET INY UP BY 1.\n005400     PERFORM 0200-EXAMINE-DSN-MODULE\n005500        VARYING INX FROM INX BY 1\n005600        UNTIL (DSN-CHARACTER (INX) = ' ' OR '(' OR QUOTE)\n005610           OR (INX > 44)\n005700           OR (BAD-CHARACTER).\n005710     IF DSN-CHARACTER (INX) = QUOTE\n005720        COMPUTE QUOTE-CHAR = QUOTE-CHAR + 1.\n005730     SET INX DOWN BY 1.\n005740     IF DSN-CHARACTER (INX) = '.'\n005750        MOVE 'YES' TO BAD-CHAR.\n005760     SET INX UP BY 1.\n005800     IF BAD-CHARACTER\n005900        MOVE 'NO ' TO VALID-DSN-PASSED\n006000        MOVE 'INVALID SYNTAX FOR DSNAME' TO ERROR-MESSAGE\n006100     ELSE\n006200        IF INX > 44\n006210           IF NOT-ENOUGH-QUOTES\n006220              MOVE 'NO ' TO VALID-DSN-PASSED\n006230              MOVE 'INVALID SYNTAX FOR DSNAME' TO ERROR-MESSAGE\n006240           ELSE\n006300              MOVE WORK-DSN-OUTPUT TO OUTPUT-DSN\n006400              MOVE 'NO ' TO MEMBER-NAME-PROVIDED\n006410              MOVE 'NO ' TO GDG-TYPE-DATASET\n006500              MOVE 'YES' TO VALID-DSN-PASSED\n006700        ELSE\n006800           IF DSN-CHARACTER (INX) = ' ' OR QUOTE\n006900              PERFORM 0300-BASIC-DSN-MODULE\n007000           ELSE\n007100              PERFORM 0310-OTHER-DSN-MODULE.\n007110     GOBACK.\n007111\n007112********************************\n007113 0110-INITIALIZE-MODULE.\n007114********************************\n007115\n007120     SET INX TO 1.\n007130     SET INY TO 1.\n007140     SET INZ TO 1.\n007150     MOVE INPUT-DSN TO WORK-DSN-INPUT.\n007160     MOVE SPACE TO WORK-DSN-OUTPUT WORK-MEMBER OUTPUT-DSN\n007161                   OUTPUT-MEMBER-NAME MEMBER-NAME-PROVIDED\n007162                   GDG-TYPE-DATASET VALID-DSN-PASSED\n007163                   ERROR-MESSAGE.\n007170     MOVE 'NO ' TO BAD-CHAR.\n007180     MOVE ZERO TO QUOTE-CHAR PERFORM-COUNT CHAR-COUNT.\n007200     EJECT\n007300\n007400********************************\n007500 0200-EXAMINE-DSN-MODULE.\n007600********************************\n007700\n007800     COMPUTE PERFORM-COUNT = PERFORM-COUNT + 1.\n007900     IF (DSN-CHARACTER (INX) NOT NUMERIC)\n008000        AND (DSN-CHARACTER (INX) NOT ALPHABETIC)\n008100        AND (DSN-CHARACTER (INX) NOT = '@' AND '#' AND '$'\n008110           AND QUOTE AND '.' AND SPACE)\n008200        MOVE 'YES' TO BAD-CHAR.\n008210     IF DSN-CHARACTER (INX) = '.'\n008211        IF CHAR-COUNT = 0\n008212           MOVE 'YES' TO BAD-CHAR\n008213        ELSE\n008220           COMPUTE CHAR-COUNT = 0\n008230     ELSE\n008231        IF DSN-CHARACTER (INX) NOT = SPACE\n008240           COMPUTE CHAR-COUNT = CHAR-COUNT + 1.\n008250     IF CHAR-COUNT > 8\n008260        MOVE 'YES' TO BAD-CHAR.\n008261     IF CHAR-COUNT = 1\n008262        IF DSN-CHARACTER (INX) NUMERIC\n008263           MOVE 'YES' TO BAD-CHAR.\n008264     IF DSN-CHARACTER (INX) = QUOTE\n008265        COMPUTE QUOTE-CHAR = QUOTE-CHAR + 1.\n008266     IF TOO-MANY-QUOTES\n008267        MOVE 'YES' TO BAD-CHAR.\n008300     MOVE DSN-CHARACTER (INX) TO DSN-CHAR-OUT (INY).\n008400     SET INY UP BY 1.\n008500\n008600********************************\n008700 0205-MOVE-MEMBER-MODULE.\n008800********************************\n008900\n009000     COMPUTE PERFORM-COUNT = PERFORM-COUNT + 1.\n009100     IF (DSN-CHARACTER (INX) NOT NUMERIC)\n009200        AND (DSN-CHARACTER (INX) NOT ALPHABETIC)\n009300        AND (DSN-CHARACTER (INX) NOT = '@' AND '#' AND '$')\n009400        MOVE 'YES' TO BAD-CHAR.\n009500     MOVE DSN-CHARACTER (INX) TO DSN-CHAR-MEMBER (INZ).\n009600     SET INZ UP BY 1.\n009700     EJECT\n009800********************************\n009900 0300-BASIC-DSN-MODULE.\n010000********************************\n010100\n010110     MOVE DSN-CHARACTER (INX) TO DSN-CHAR-OUT (INY)\n010120     SET INX UP BY 1\n010200     SET INY UP BY 1\n010300     PERFORM 0200-EXAMINE-DSN-MODULE\n010400        VARYING INX FROM INX BY 1\n010500        UNTIL (DSN-CHARACTER (INX) NOT = ' ' AND QUOTE)\n010600           OR (INX > 44).\n010610     IF BAD-CHARACTER\n010620        MOVE 'NO ' TO VALID-DSN-PASSED\n010630        MOVE 'INVALID SYNTAX FOR DSNAME' TO ERROR-MESSAGE\n010640     ELSE\n010700        IF INX > 44\n010710           IF NOT-ENOUGH-QUOTES\n010720              MOVE 'NO ' TO VALID-DSN-PASSED\n010730              MOVE 'INVALID SYNTAX FOR DSNAME' TO ERROR-MESSAGE\n010740           ELSE\n010800              MOVE WORK-DSN-OUTPUT TO OUTPUT-DSN\n010900              MOVE 'NO ' TO MEMBER-NAME-PROVIDED\n010910              MOVE 'NO ' TO GDG-TYPE-DATASET\n011000              MOVE 'YES' TO VALID-DSN-PASSED\n011100        ELSE\n011200           MOVE 'NO ' TO VALID-DSN-PASSED\n011300           MOVE 'INVALID SYNTAX FOR DSNAME' TO ERROR-MESSAGE.\n011500\n011600********************************\n011700 0310-OTHER-DSN-MODULE.\n011800********************************\n011900\n012000     SET INX UP BY 1\n012100     IF INX > 44\n012200        MOVE 'NO ' TO VALID-DSN-PASSED\n012300        MOVE 'INVALID SYNTAX FOR DSNAME' TO ERROR-MESSAGE\n012400     ELSE\n012500       IF (DSN-CHARACTER (INX) NUMERIC)\n012600          OR (DSN-CHARACTER (INX) = '-' OR '+')\n012700          PERFORM 0400-GDG-DSN-MODULE\n012800       ELSE\n012900          IF DSN-CHARACTER (INX) ALPHABETIC\n012910             OR DSN-CHARACTER (INX) = '@' OR '#' OR '$'\n013000             PERFORM 0410-PDS-DSN-MODULE\n013100          ELSE\n013200             MOVE 'NO ' TO VALID-DSN-PASSED\n013300             MOVE 'INVALID MEMBER NAME' TO ERROR-MESSAGE.\n013400     EJECT\n013500********************************\n013600 0400-GDG-DSN-MODULE.\n013700********************************\n013710\n013800     SET INX DOWN BY 1.\n013810     MOVE DSN-CHARACTER (INX) TO DSN-CHAR-OUT (INY).\n013820     SET INX UP BY 1.\n013821     SET INY UP BY 1.\n013830     IF DSN-CHARACTER (INX) = '+' OR '-'\n013840        MOVE DSN-CHARACTER (INX) TO DSN-CHAR-OUT (INY)\n013900        SET INX UP BY 1\n013910        SET INY UP BY 1.\n014000     COMPUTE PERFORM-COUNT = 0\n014010     COMPUTE CHAR-COUNT = 1\n014100     PERFORM 0200-EXAMINE-DSN-MODULE\n014200        VARYING INX FROM INX BY 1\n014300        UNTIL (DSN-CHARACTER (INX) NOT NUMERIC)\n014400           OR (INX > 44)\n014500           OR (PERFORM-COUNT > 3).\n014600     IF (INX > 44) OR (PERFORM-COUNT > 3)\n014700        MOVE 'NO ' TO VALID-DSN-PASSED\n014800        MOVE 'INVALID SYNTAX FOR DSNAME' TO ERROR-MESSAGE\n014900     ELSE\n015000        IF  DSN-CHARACTER (INX) = ')'\n015010           IF PERFORM-COUNT = 0\n015011              MOVE 'NO ' TO VALID-DSN-PASSED\n015012              MOVE 'INVALID SYNTAX FOR DSNAME' TO ERROR-MESSAGE\n015020           ELSE\n015100              PERFORM 0500-GDG-CONT-MODULE\n015200        ELSE\n015300           MOVE 'NO ' TO VALID-DSN-PASSED\n015400           MOVE 'INVALID SYNTAX FOR DSNAME' TO ERROR-MESSAGE.\n015600\n015700********************************\n015800 0410-PDS-DSN-MODULE.\n015900********************************\n016000\n016200     COMPUTE PERFORM-COUNT = 0.\n016210     COMPUTE CHAR-COUNT = 0.\n016300     PERFORM 0205-MOVE-MEMBER-MODULE\n016400        VARYING INX FROM INX BY 1\n016500        UNTIL (DSN-CHARACTER (INX) = ')' OR ' ')\n016600           OR (INX > 44)\n016700           OR (PERFORM-COUNT > 8)\n016800           OR (BAD-CHARACTER).\n016900     IF BAD-CHARACTER\n017000        MOVE 'NO ' TO VALID-DSN-PASSED\n017100        MOVE 'INVALID MEMBER NAME' TO ERROR-MESSAGE\n017200     ELSE\n017300        IF INX > 44\n017400           MOVE 'NO ' TO VALID-DSN-PASSED\n017500           MOVE 'INVALID SYNTAX FOR DSNAME' TO ERROR-MESSAGE\n017600        ELSE\n017700           IF PERFORM-COUNT > 8\n017800              MOVE 'NO ' TO VALID-DSN-PASSED\n017900              MOVE 'MEMBER NAME TOO LONG' TO ERROR-MESSAGE\n018000           ELSE\n018100              IF  DSN-CHARACTER (INX) = ')'\n018200                 PERFORM 0510-PDS-CONT-MODULE\n018300              ELSE\n018400                 MOVE 'NO ' TO VALID-DSN-PASSED\n018500                 MOVE 'INVALID MEMBER NAME' TO ERROR-MESSAGE.\n018600     EJECT\n018700********************************\n018800 0500-GDG-CONT-MODULE.\n018900********************************\n019000\n019010     MOVE DSN-CHARACTER (INX) TO DSN-CHAR-OUT (INY)\n019100     SET INX UP BY 1\n019110     SET INY UP BY 1\n019200     PERFORM 0200-EXAMINE-DSN-MODULE\n019300        VARYING INX FROM INX BY 1\n019400        UNTIL (DSN-CHARACTER (INX) NOT = ' ' AND QUOTE)\n019500           OR (INX > 44).\n019510     IF BAD-CHARACTER\n019520        MOVE 'NO ' TO VALID-DSN-PASSED\n019530        MOVE 'INVALID SYNTAX FOR DSNAME' TO ERROR-MESSAGE\n019540     ELSE\n019600        IF INX > 44\n019610           IF NOT-ENOUGH-QUOTES\n019611              MOVE 'NO ' TO VALID-DSN-PASSED\n019612              MOVE 'INVALID SYNTAX FOR DSNAME' TO ERROR-MESSAGE\n019620           ELSE\n019700              MOVE WORK-DSN-OUTPUT TO OUTPUT-DSN\n019800              MOVE 'NO ' TO MEMBER-NAME-PROVIDED\n019900              MOVE 'YES' TO VALID-DSN-PASSED\n019910              MOVE 'YES' TO GDG-TYPE-DATASET\n020000        ELSE\n020100           MOVE 'NO ' TO VALID-DSN-PASSED\n020200           MOVE 'INVALID SYNTAX FOR DSNAME' TO ERROR-MESSAGE.\n020400\n020500********************************\n020600 0510-PDS-CONT-MODULE.\n020700********************************\n020800\n020900     SET INX UP BY 1\n021000     PERFORM 0200-EXAMINE-DSN-MODULE\n021100        VARYING INX FROM INX BY 1\n021200        UNTIL (DSN-CHARACTER (INX) NOT = ' ' AND QUOTE)\n021300           OR (INX > 44).\n021310     IF BAD-CHARACTER\n021320        MOVE 'NO ' TO VALID-DSN-PASSED\n021330        MOVE 'INVALID SYNTAX FOR DSNAME' TO ERROR-MESSAGE\n021340     ELSE\n021400        IF INX > 44\n021410           IF NOT-ENOUGH-QUOTES\n021420              MOVE 'NO ' TO VALID-DSN-PASSED\n021430              MOVE 'INVALID MEMBER NAME' TO ERROR-MESSAGE\n021440           ELSE\n021500              MOVE WORK-DSN-OUTPUT TO OUTPUT-DSN\n021600              MOVE WORK-MEMBER TO OUTPUT-MEMBER-NAME\n021700              MOVE 'YES' TO MEMBER-NAME-PROVIDED\n021710              MOVE 'NO ' TO GDG-TYPE-DATASET\n021800              MOVE 'YES' TO VALID-DSN-PASSED\n021900        ELSE\n022000           MOVE 'NO ' TO VALID-DSN-PASSED\n022100           MOVE 'INVALID SYNTAX FOR DSNAME' TO ERROR-MESSAGE.\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CALLCIPH": {"ttr": 3079, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x00\\x7f\\x00\\x88\\x00\\x7f\\x12\\x00\\x00\\x90\\x00\\x90\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf2\\xf7\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-01-07T00:00:00", "modifydate": "1988-01-07T12:00:00", "lines": 144, "newlines": 144, "modlines": 0, "user": "FILE270"}, "text": " /*                                                                  */ 00002\n /*   COPIED FROM THE CBT TAPE                                       */ 00002\n /*   SHOWS THE CALLING SEQUENCE FOR THE ENCIPHER/DECIPHER           */ 00002\n /*   PROGRAM CONTAINED IN MEMBER ENDECIPH                           */ 00002\n /*                                                                  */ 00002\n        /* DATA SET TSO049     AT LEVEL 001 AS OF 01/23/81    */\n /* PROGRAM : TSO049                                                 */ 00001\n /*                                                                  */ 00002\n /*  PURPOSE:  TO ENCIPHER OR DECIPHER A DATASET BY USING THE NBS    */ 00003\n /*            ALGORITHM (R050A90).                                  */ 00004\n /*                                                                  */ 00005\n /*  JCL:   //STEP   EXEC   PGM=TSO049,PARM='OPERATION,KEY'          */ 00006\n /*         //DATASET DD    DSN=DSN.TO.BE.WORKED.ON,DISP=OLD         */ 00007\n /*         //SYSPRINT DD   SYSOUT=*                                 */ 00008\n /*                                                                  */ 00009\n /*  THE KEY IS A 1 TO 8 BYTE KEY FOR THE OPERATION                  */ 00010\n /*  OPERATION IS 'E' FOR ENCIPHER OR 'D' FOR DECIPHER               */ 00011\n /*                                                                  */ 00012\n /*  K TRUE   22 JAN 81   V1M0                                       */ 00013\n /*                                                                  */ 00014\n TSO049: PROC (PARAM) OPTIONS(MAIN) REORDER;                            00015\n                                                                        00016\n   DCL DATASET  FILE   RECORD  SEQUENTIAL ENV(CONSECUTIVE);             00017\n   DCL SYSPRINT FILE   PRINT;                                           00018\n                                                                        00019\n   DCL PARAM    CHAR(100) VAR;                                          00020\n   DCL PARM1    CHAR(1) INIT(''),                                       00021\n       PARM2    CHAR(8) INIT(''),                                       00022\n       PARM3    CHAR(8) INIT('');                                       00023\n                                                                        00024\n   DCL RECIN    CHAR(255) VAR INIT('');                                 00025\n   DCL WORKREC  CHAR(255) INIT('');                                     00026\n   DCL KEY      CHAR(8)   INIT('');                                     00027\n   DCL OP  CHAR(12)  VAR INIT('');                                      00028\n                                                                        00029\n   DCL RECLEN   FIXED BIN(31,0) INIT(0);                                00030\n   DCL WORKLEN  FIXED BIN(31,0) INIT(0);                                00031\n   DCL RECCNT   FIXED BIN(31,0) INIT(0);                                00032\n   DCL SKIPCNT  FIXED BIN(31,0) INIT(0);                                00033\n   DCL (I,J,K)  FIXED BIN(15,0) INIT(0);                                00034\n                                                                        00035\n   DCL ENDFILE  BIT(1)  INIT('0'B);                                     00036\n   DCL ENCIPHER BIT(1)  INIT('1'B);                                     00037\n                                                                        00038\n   DCL SETKEY   EXTERNAL ENTRY OPTIONS(ASSEMBLER,INTER);                00039\n   DCL ENCIPH   EXTERNAL ENTRY OPTIONS(ASSEMBLER,INTER);                00040\n   DCL DECIPH   EXTERNAL ENTRY OPTIONS(ASSEMBLER,INTER);                00041\n                                                                        00042\n   DCL (LENGTH,SUBSTR,VERIFY,INDEX)  BUILTIN;                           00043\n                                                                        00044\n                                                                        00045\n1  ON ENDFILE(DATASET) ENDFILE = '1'B;                                  00046\n                                                                        00047\n   CALL SETUP;                                                          00048\n                                                                        00049\n   OPEN FILE(DATASET) UPDATE;                                           00050\n   READ FILE(DATASET) INTO(RECIN);                                      00051\n                                                                        00052\n  /*  MAIN LOOP */                                                      00053\n                                                                        00054\n   DO WHILE(\u00acENDFILE);                                                  00055\n      RECCNT  = RECCNT + 1;         /*  BUMP RECORD COUNT        */     00056\n      IF RECCNT > SKIPCNT THEN                                          00057\n        DO;                                                             00058\n          WORKREC = '';             /*  CLEAR OUT WORK AREA      */     00059\n          WORKREC = RECIN;          /*  MOVE RECORD TO WORK AREA */     00060\n          RECLEN = LENGTH(RECIN);   /*  SAVE LENGTH OF RECORD TOO*/     00061\n          WORKLEN = RECLEN/8 * 8;   /*  ENSURE AT LEAST 8 BYTES  */     00062\n                                                                        00063\n          IF ENCIPHER THEN CALL ENCIPH(WORKREC,WORKLEN);                00064\n                      ELSE CALL DECIPH(WORKREC,WORKLEN);                00065\n                                                                        00066\n          RECIN = SUBSTR(WORKREC,1,RECLEN); /* PUT RECORD BACK  */      00067\n        END;                                                            00068\n                                                                        00069\n      REWRITE FILE(DATASET) FROM(RECIN);                                00070\n      READ FILE(DATASET) INTO(RECIN);                                   00071\n  END;                                                                  00072\n                                                                        00073\n  CLOSE FILE(DATASET);                                                  00074\n  PUT FILE(SYSPRINT) SKIP EDIT                                          00075\n     (OP,' OPERATION COMPLETED')       (A,A);                           00076\n  PUT FILE(SYSPRINT) SKIP EDIT                                          00077\n     (RECCNT,' RECORDS PROCESSED')     (P'ZZ,ZZZ,ZZ9',A);               00078\n                                                                        00079\n  IF SKIPCNT > 0 THEN                                                   00080\n    PUT FILE(SYSPRINT) SKIP EDIT                                        00081\n     (SKIPCNT,' RECORDS SKIPPED')      (P'ZZ,ZZZ,ZZ9',A);               00082\n                                                                        00083\n1/*     SUBROUTINE: SETUP                                  */           00084\n /* EXTRACT PARM INFORMATION AND SETUP FOR PROCESSING      */           00085\n                                                                        00086\n SETUP: PROC;                                                           00087\n                                                                        00088\n                              /*                                    */  00089\n                              /*        GET PARM1 &                 */  00090\n                              /* PARM2 & PARM3 FROM EXEC PARAM      */  00091\n                              /*                                    */  00092\n    J=LENGTH(PARAM);                                                    00093\n    IF J > 0 THEN I=INDEX(PARAM,',');                                   00094\n    IF I=0 | J=0                                                        00095\n       THEN DO;                                                         00096\n          PARM1,PARM2,PARM3= '';                                        00097\n       END;                                                             00098\n       ELSE DO;                                                         00099\n          PARM1=SUBSTR(PARAM,1,I-1);                                    00100\n          I=I+1;                                                        00101\n          K=INDEX(SUBSTR(PARAM,I),',');                                 00102\n          IF K=0 | J = I                                                00103\n             THEN DO;                                                   00104\n                PARM2,PARM3= '';                                        00105\n             END;                                                       00106\n             ELSE DO;                                                   00107\n                IF K = 0 THEN K = J + 1;                                00108\n                PARM2=SUBSTR(PARAM,I,K-1);                              00109\n                I=I+K;                                                  00110\n                IF I <= J                                               00111\n                   THEN PARM3=SUBSTR(PARAM,I);                          00112\n             END;                                                       00113\n       END;                                                             00114\n                                                                        00115\n    IF PARM1 = 'E'  THEN ENCIPHER = '1'B;                               00116\n                    ELSE ENCIPHER = '0'B;                               00117\n    IF ENCIPHER THEN OP = 'ENCIPHER';                                   00118\n                ELSE OP = 'DECIPHER';                                   00119\n                                                                        00120\n    KEY = PARM2;                                                        00121\n                                                                        00122\n    IF PARM3 \u00ac= '       ' THEN /* SKIP NUMBER OF RECORDS         */     00123\n      DO;                                                               00124\n        K = VERIFY(PARM3,'01234567890 ');                               00125\n        IF K = 0 THEN                                                   00126\n          DO;                                                           00127\n            SKIPCNT = PARM3;                                            00128\n          END;                                                          00129\n      END;                                                              00130\n    PUT FILE(SYSPRINT) SKIP EDIT                                        00131\n      (OP,' USING KEY=''',KEY,''' BEGINS')                              00132\n      (A,A,A,A);                                                        00133\n                                                                        00134\n    CALL SETKEY(KEY);                                                   00135\n    RETURN;                                                             00136\n END;                                                                   00137\n END TSO049;                                                            00138\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CATBYVO#": {"ttr": 3083, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x00\\x7f\\x00\\x88\\x00\\x7f\\x12\\x00\\x002\\x002\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf2\\xf7\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-01-07T00:00:00", "modifydate": "1988-01-07T12:00:00", "lines": 50, "newlines": 50, "modlines": 0, "user": "FILE270"}, "text": "THIS TEXT HAS BEEN REDONE USING QUICKCAT AND DYL260\n//DNX00150 JOB (2100,56-D),'DPARS 0682-T',CLASS=H,MSGCLASS=T,TIME=1\n//* CATALOG CHECK OF DISK DATASETS. ANY CATALOG ENTRY THAT DOES NOT\n//* EXIST ON A VOLUME HAS A DELETE CONTROL CARD CREATED.\n//* SEE CVOLTMS FOR THE TAPE VERSION.\n//* REFERENCE THE CATALOG TO BE CHECKED IN STEPCAT AND VSAMCAT.\n//*\n//* PARM='XXXXXXXX'             PASSWORD UP TO 8 CHARACTERS.\n//*\n//Z1       EXEC PGM=VSAMSCAN,PARM=CATFOUR,TIME=2\n//STEPCAT  DD DSN=SYS1.USERCAT4,DISP=SHR\n//VSAMCAT  DD DSN=SYS1.USERCAT4,DISP=SHR\n//STEPLIB DD DSN=WDPSC.TSAEXAM,DISP=SHR\n//SYSPRINT DD SYSOUT=*\n//AMSCARD DD DSN=DN00150.A.AMS1,DISP=(,PASS,KEEP),UNIT=SYSSQ,\n//   SPACE=(CYL,(1,1)),DCB=BLKSIZE=3200\n//SYSUDUMP DD SYSOUT=*\n//* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n//* ELIMINATE TAPE DATA SETS FROM THE CATALOG EXTRACT\n//*\n//M8  EXEC DYL260\n//SYS260A DD DSN=DN00150.A.AMS1,DISP=(OLD,PASS,KEEP)\n//SYS260K DD DSN=DN00150.A.AMS2,DISP=(,PASS,KEEP),\n//  UNIT=SYSSQ,SPACE=(CYL,(1,1)),\n//  DCB=(LRECL=80,BLKSIZE=3200,RECFM=FB)\nC\nFA F\nFK F    80     A\nD       1A73                  EQ  1VX'20'               OUTREJ\n//* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n//* SORT RECORDS INTO VOLUME SEQUENCE FOR DASD CHECK\n//*\n//Y2  EXEC SORT\n//SORTIN DD DSN=DN00150.A.AMS2,DISP=(OLD,PASS,KEEP)\n//SORTOUT DD DSN=DN00150.A.AMS1,DISP=(OLD,PASS,KEEP)\n SORT FIELDS=(75,6,CH,A,73,2,CH,A),DYNALLOC=WORK\n//* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n//* CHECK AGAINST THE DASD FOR EXISTENCE\n//*\n//X3       EXEC PGM=CATBYVOL,TIME=1\n//STEPLIB DD DSN=WDPSC.TSAEXAM,DISP=SHR\n//SYSPRINT DD SYSOUT=*\n//SYSIN   DD DSN=DN00150.A.AMS1,DISP=(OLD,KEEP)\n//AMSCARD DD DSN=DN00150.A.AMS2,DISP=(OLD,PASS,KEEP)\n//SYSUDUMP DD SYSOUT=*\n//*\n//S8  EXEC FTL\n//IN01  DD DSN=DN00150.A.AMS2,DISP=(OLD,KEEP)\n//OUT01 DD DSN=DN00150.USERCAT4.DATA,DISP=(,KEEP),\n//   SPACE=(CYL,(1,1)),UNIT=WORK\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CATBYVOL": {"ttr": 3085, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x00\\x7f\\x00\\x88\\x00\\x7f\\x12\\x00\\x00\\xd7\\x00\\xd7\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf2\\xf7\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-01-07T00:00:00", "modifydate": "1988-01-07T12:00:00", "lines": 215, "newlines": 215, "modlines": 0, "user": "FILE270"}, "text": "//DNO00155 JOB (2100,56-D),'DPARS 0682 T',CLASS=H,MSGCLASS=T\n//* FROM WDPSC.DN00155.FILE(CATBYVOL)\n//D EXEC ASMHCL,LIBRARY='WDPSC.TSAEXAM',OPTION1=TERM,\n//  LNDSP=SHR\n    TITLE 'CATALOG VERIFICATION FOR NON-VSAM'\n*\n* INPUT IS AN AMS CARD IMAGE TO UNCATALOG A DATA SET.\n* COLUMN 73-74 CONTAINS THE LAST TWO BYTES OF UNIT TYPE\n* COLUMN 75-80 CONTAINS THE VOLUME SERIAL NUMBER\n*\n* INPUT IS IN VOLUME SERIAL NUMBER SEQUENCE\n* CARDS FOR TAPE ARE NOT  WRITTEN TO OUTPUT\n* CARDS FOR DASD ARE CHECKED FOR A VALID VOLUME.\n*   IF THE VOLUME EXISTS, IT IS CHECKED FOR THE DATA SET.\n*   IF THE VOLUME DOES NOT CONTAIN THE DATA SET, THE RECORD IS\n*   WRITTEN FOR IDCAMS PROCESSING.\n*\nCATBYVOL CSECT\n         SAVE  (14,12),,CATBYVOL\n         REGISTER\n         BALR  R12,0\n         USING *,R12\n         B     GO\n         DC    C'&SYSDATE'\n         DC    C'&SYSTIME'\nGO       CNOP  0,4\n         ST    R13,SAVE+4\n         LA    R11,SAVE\n         ST    R11,8(,R13)\n         LR    R13,R11\n* PARM FIELD ANALYSIS\n         L     R2,0(,R1)\n         LH    R3,0(,R2)\n         LTR   R3,R3\n         BZ    OPENS\n         OI    DEFLG,X'80'\nOPENS    EQU   *\n         OPEN  (PRINT,OUTPUT)\n         TM    PRINT+48,X'10'\n         BO    PR\n         ABEND 12\nPR       OPEN  (SYSIN,INPUT)\n         TM    SYSIN+48,X'10'\n         BZ    ERROR4              NO SYSIN DATA SET\n         OPEN  (AMSDCB,OUTPUT)\nPROCESS  GET   SYSIN,AMSCARD\n         CLI   AMSDEVT,X'20'      IF NOT A DASD DEVICE TYPE, IT IS\n         BNE   PROCESS            WILL BE PROCESSED ELSEWHERE\n         CLC   AMSDSN(9),=C'SYSCTLG.V'\n         BE    PROCESS             DO NOT DELETE CVOL ENTRIES\n         MVC   DYNDSN,AMSDSN\n         MVC   UNNDSN,AMSDSN\n         MVC   DYNVOL,AMSVOL\n         LA    R1,DYNAMIC\n         SVC   99                  DYNAMIC ALLOCATION\n         LTR   R15,R15             TEST RETURN\n         BZ    UNALLOC             DATA SET EXISTS ON VOLUME, CONTINUE\n         CLC   DYNERROR,=X'0210'    DATA SET ALLOCATED\n         BE    PROCESS\n         CLC   DYNERROR,=X'0218'    VOLUME NOT MOUNTED\n         BE    KEEPAMS\n         CLC   DYNERROR,=X'0220'    VOLUME NOT AVAILABLE\n         BE    KEEPAMS\n         CLC   DYNERROR,=X'0440'    DATA SET NOT FOUND\n         BE    KEEPAMS\n         B     ERROR8\nUNALLOC  EQU  *\n         LA    R1,UNDONE\n         SVC   99\n         LTR   R15,R15\n         BZ    PROCESS\n         B     ERRORC\n*\n         AGO   .SKIPIT\n         CLC   WORKDEVT(8),AMSDEVT SAME VOLUME AS LAST TIME\n         BE    VOLTHERE\n         MVC   WORKDEVT(8),AMSDEVT\n         L     R8,16               GET CVT ADDRESS\n         L     R8,40(,R8)          POINTER TO UCB ADDRESSES\n         SR    R7,R7\nFINDVOL  ICM   R7,3,0(R8)          UCB ADDRESS\n         BZ    UPUCB\n         CLM   R7,3,=X'FFFF'       END OF ADDRESS LIST\n         BE    NOTHERE\n         CLC   28(6,R7),WORKVOL    IS THIS THE VOLUME\n         BE    DSNCHECK\nUPUCB    LA    R8,2(,R8)           NEXT UCB ADDRESS\n         B     FINDVOL\nDSNCHECK ST    R7,WORKUCB          KEEP ADDRESS OF UCB\n         B     PROCESSB\nNOTHERE  XC    WORKUCB,WORKUCB     MARK VOLUME SERIAL INVALID\nVOLTHERE CLC   WORKUCB,=F'0000'\n         BE    KEEPAMS             KEEP THE UNCATALOG RECORD\n         SPACE 4\nPROCESSB EQU   *\n* VTOC VERIFY BY USE OF DF/DS FACILITY\n         L     R7,WORKUCB\n         XC    BFLHSP(6),BFLHSP         ZERO THE BUFFER LIST\n         XC    BFLEARG,BFLEARG        ZERO THE BUFFER LIST\nCVPLON   CVAFDIR ACCESS=READ,BRANCH=(YES,PGM),UCB=(R7),                X\n               DSN=AMSDSN,BUFLIST=EMPTY,                               X\n               MAPRCDS=NO,IXRCDS=NOKEEP,IOAREA=NOKEEP\n         PRINT NOGEN\n         ORG   CVPLON+4\n         ICVAFPL DSECT=NO    MAP THE PARAMETER LIST\n         ORG\n         PRINT GEN\n         C     R15,=F'4'           TEST RETURN CODE\n         BH    ERROR7        TELL ABOUT ERROR AND ABEND FOR ANALYSIS\n         CLI   CVSTAT,X'01'   DATA SET NOT FOUND\n         BNE   PROCESS        SKIP ALL ERRORS FOR NOW\n.SKIPIT  ANOP\nKEEPAMS  EQU   *\n         PUT   AMSDCB,AMSCARD\n         B     PROCESS\nOUTOF    EQU   *\n         CLOSE (PRINT,,AMSDCB,,SYSIN)\n         L     R13,SAVE+4\n         RETURN  (14,12),RC=0   ,,,,,,,,,,,,,,,,,S\nERROR8   ABEND 567,DUMP\nERRORC   ABEND 566,DUMP\nERROR7   ABEND 568,DUMP\nERROR4   PUT   PRINT,NOSYSIN\n         LA    R15,62\n         B     OUTOF\nSAVE     DS    18F\nLINES    DC    PL5'77'\n         PRINT NOGEN\nPRINT    DCB   DDNAME=SYSPRINT,RECFM=FA,BLKSIZE=133,LRECL=133,DSORG=PS,X\n               MACRF=(PM)\nAMSDCB   DCB   DDNAME=AMSCARD,RECFM=FB,MACRF=PM,LRECL=80,DSORG=PS\nSYSIN    DCB      DDNAME=SYSIN,RECFM=FB,LRECL=80,DSORG=PS,             X\n               MACRF=(GM),EODAD=OUTOF\n         PRINT GEN\nOUT      DC    136C' '\nNOSYSIN  DC    CL130'  NO SYSIN DATA SET  '\nAMSCARD  DS    0CL80\n         DS    CL15\nAMSDSN   DS    CL44\n         DS    CL13\nAMSDEVT  DS    CL2\nAMSVOL   DS    CL6\n*\nDEFLG    DC    X'00'\n         DC    C'DYNAMIC'\n         DS    0F\nDYNAMIC  DC    XL1'80'              HIGH ORDER BIT ON\n         DC    AL3(DYNBLOCK)        POINT TO REQUEST BLOCK\nDYNBLOCK DC    X'14'                LENGTH OF BLOCK\n         DC    X'01'                VERB CODE = DSNAME ALLOCATION\nDYNFLAGS DC    X'6000'              FLAGS\n*                DO NOT USE AN EXISTING ALLOCATION TO SATISFY THIS\n*                DO NOT MOUNT VOLUMES\nDYNERROR DC    X'0000'\nDYNINFO  DC    X'0000'\nDYNTEXTP DC    A(DYNPTRS)\n         DC    A(0)\nDYNFLAG2 DC    A(0)\n*                 POINTERS TO ________ TEXT UNIT\nDYNPTRS  DC    A(DYNTU02)     DSNAME\n         DC    A(DYNTU04)     STATUS\n         DC    A(DYNTU10)     VOLUME\n         DC    A(DYNTU15)     UNIT\n         DC    XL1'80',AL3(DYNTU1C) FREE ON CLOSE\n*\nDYNTU02  DC    X'0002',X'0001',X'002C'\nDYNDSN   DC    CL44' '\nDYNTU04  DC    X'0004',X'0001',X'0001',X'08'\nDYNTU10  DC    X'0010',X'0001',X'0006'\nDYNVOL   DC    CL6' '\nDYNTU15  DC    X'0015',X'0001',X'0008',C'SYSALLDA'\nDYNTU1C  DC    X'001C',X'0000'\n**\n         DC    C'UNDONE'\n         DS    0F\nUNDONE   DC    XL1'80'              HIGH ORDER BIT ON\n         DC    AL3(UNNBLOCK)        POINT TO REQUEST BLOCK\nUNNBLOCK DC    X'14'                LENGTH OF BLOCK\n         DC    X'02'                VERB CODE = UNALLOCATION\nUNNFLAGS DC    X'6000'              FLAGS\n*                DO NOT USE AN EXISTING ALLOCATION TO SATISFY THIS\n*                DO NOT MOUNT VOLUMES\nUNNERROR DC    X'0000'\nUNNINFO  DC    X'0000'\nUNNTEXTP DC    A(UNNPTRS)\n         DC    A(0)\nUNNFLAG2 DC    A(0)\n*                 POINTERS TO ________ TEXT UNIT\nUNNPTRS  DC    A(UNNTU02)     DSNAME\n         DC    A(UNNTU05)     DISPOSITION\n         DC    XL1'80',AL3(UNNTU07) FREE ON CLOSE\nUNNTU02  DC    X'0002',X'0001',X'002C'\nUNNDSN   DC    CL44' '\nUNNTU05  DC    X'0005',X'0001',X'0001',X'08'\nUNNTU07  DC    X'0007',X'0000'\n*\n*\n  AGO .A\nEMPTY    ICVAFBFL  DSECT=NO    THE BUFFER LIST FOR CVAFDIR\n         ORG   BFLHNOE         NUMBER OF ENTRIES\n         DC    X'0104'\n         ORG   BFLELTH\n         DC    AL1(96)         LENGTH OF DSCB DATA PORTION\n         ORG   BFLEBUF\n         DC    A(STUFF)\n         ORG\nSTUFF    DC    XL180'0'        THE BUFFER\n.A    ANOP\nWORKDEVT DC    XL2'00'          DEVICETYPE FOR ADDITIONAL CHECK\nWORKVOL  DC    CL6' '           VOLUME SERIAL IN PROCESS\nWORKUCB  DC    F'0'             ADDRESS OF UCB\n         END\n//LKED.SYSIN DD *\n  SETCODE AC(1)\n  NAME CATBYVOL(R)\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CHDSCB$": {"ttr": 3333, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x00\\x7f\\x00\\x88\\x00\\x7f\\x12\\x00\\x00#\\x00#\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf2\\xf7\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-01-07T00:00:00", "modifydate": "1988-01-07T12:00:00", "lines": 35, "newlines": 35, "modlines": 0, "user": "FILE270"}, "text": "1 10.060\n-                                                         CHDSCB Clist\n0Function -\n The CHDSCB Clist is for use when you wish to change the record format,\n logical record length, blocksize or DSORG of a dataset without\n modifying the data. The dataset is allocated with DISP=MOD and opened\n for output, then closed without writing any data. This causes the DSCB\n to be rewritten with the DCB data you specify. It is useful if a job\n has accidentally modified the blocksize of a library for example.\n WARNING: although the system prevents some types of changes, you can\n still get in trouble with this, so you should know what you are doing!\n NOTE: characteristics not specified will not be changed.\n\n Syntax -\n0_______________________________________________________________________\n0     Command     Operands\n _______________________________________________________________________\n0     %CHDSCB     dsn  RECFM(rfm) LRECL(lrl) BLKSIZE(blksi) DSORG(org)\n                       NOLIST     LR(lrl)    BLK(blksi)\n _______________________________________________________________________\n-Operands -\n0 Required    - dsn.\n-  dsn        - Name of dataset to be modified.\n0  RECFM(rfm) - rfm is the format you desire (for example FBA).\n0  LRECL(lrl) or LR(lrl) - lrl is the record length you desire.\n0  BLKSIZE(blksi) or BLK(blksi) - blksi is the blocksize to set.\n0  DSORG(org) - org is the new dataset organization. System will not\n                allow changing PO to anything else, maybe others.\n0  NOLIST     - dataset characteristics are not to be listed before and\n                after modification.                                     .\n-Example -\n0 Assume you have a dataset named A.LIB ;\n0 You then execute clist %CHDSCB as follows:\n0  %CHDSCB  'A.LIB'  BLKSIZE(3120)\n0 The blocksize of the dataset will be changed to 3120.\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "CHKBLOC$": {"ttr": 3335, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x00\\x7f\\x00\\x88\\x00\\x7f\\x12\\x00\\x00m\\x00m\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf2\\xf7\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-01-07T00:00:00", "modifydate": "1988-01-07T12:00:00", "lines": 109, "newlines": 109, "modlines": 0, "user": "FILE270"}, "text": "\nPROC NAME: CHKBLOCK\n\nFUNCTION:  LIST EVERY MEMBER OF A JCL OR PROCEDURE LIBRARY, AND\n           REPORT EVERY OUTPUT DD STATEMENT NOT OPTIMALLY BLOCKED.\n\nAUTHOR:    Howard H. Glastetter    (206) 902-3102\n\nAGENCY:    Washington State Data Processing Service Center #1\n\nCorrect Direct Access Storage Device (DASD) blocking is one of the most\neffective ways to reduce EDP costs and increase thoughput performance.\nThis procedure will make it easy to correctly block output on both old\nand new batch job streams.\n\nOne reason for optimal blocking is emphasized in an IBM Technical\nBulletin titled AN MVS TUNING PERSPECTIVE.  It states: \"An evaluation of\nan installations sequential data set blocksize is unquestionably the\nfirst thing to do when trying to reduce CPU utilization.  No other\nactivity has anywhere near the potential for saving CPU cycles.\"\n\nA second reason for optimal blocking is that ten to ninty percent of\nDASD space used by a data set can be wasted by poor blocksize.  See\nMarch 1986 WDPSC Newsletter.  DASD space is still a system cost\nconsideration and should be used effectively.\n\nTo use this procedure to examine your JCL or PROC library, simply use\nthe following JCL:\n\n\n//         JOB CARD\n//CHKITOUT EXEC CHKBLOCK,LIBRARY='YOUR.LIBRARY.NAME'\n\n\nAll the JCL you requested will be listed.  Every output DD record that\nisn't optimally blocked will have a warning message listed before it and\nsuggested new blocksize listed after it.  This process only suggests\nblocking for 3380 and TAPE devices since that is where all customer\ndata now resides.  Non JCL in your library and comments imbedded within\nDD statements will not be printed.\n\nOnce you have the list, you may simply take it and go thru your JCL or\nPROC library with SPF Option 2 and change the DD statements that aren't\noptimally blocked.\n\n\nOutput Examples (for simplicity, all have 80 character records):\n\n\nExample 1 shows a blocksize that was effective on 3350 devices, but\nis wasting 20% of 3380 space.  The new suggestion will put 100 more\nrecords on every track, saving DASD space and execution time.\n\nTHE BLOCKSIZE BELOW ONLY ALLOWS 4 BLOCKS PER TRACK AND IS WASTING SPACE\n\n//OUTSMALL  DD DSN=AGY999.SMALL.DSN,DISP=(NEW,PASS,DELETE),\n//             UNIT=SYSDA,SPACE=(CYL,(30,10),RLSE),\n//             DCB=(LRECL=80,BLKSIZE=9440,RECFM=FB)\n\n*-> BLOCKSIZE TOO LOW, TRY 11440 THIS IS 1/4 TRK BLOCKING, SAVE DISK\n\n\nExample 2 shows a blocksize that was likely picked because 10 is an easy\nnumber to multiply something by.  There are about 250 bytes of overhead\nfor every block on a 3380 track.  Blocksize should normally be a minimum\nof 1/5 track.  This corresponds to the normal buffer default of 5 and\ncauses a full track to be processed with each physical I/O, optimising\nperformance.  The new suggestion will put 565 records on every track\nrather than 360, a 63% space utilization improvement.  With more than\n10 times the records per block this file will be written with 1/10 the\nEXCPs, reducing CPU occupancy time and JOB costs.\n\nBLOCKSIZE BELOW IS UNDER 1/5 TRACK. IT'S WASTING DASD AND CPU CYCLES.\n\n//OUTTINY   DD DSN=AGY999.TINY.DSN,DISP=(NEW,PASS,DELETE),\n//             UNIT=SYSDA,SPACE=(CYL,(30,10),RLSE),\n//             DCB=(LRECL=80,BLKSIZE=800,RECFM=FB)\n\n*-> BLOCKSIZE TOO LOW, TRY 09040 THIS IS 1/5 TRK BLOCKING, SAVE DISK\n\n\nExample 3 shows a blocksize that was incorrectly selected.  It just\nexceeds 1/2 track and is wasting 50% of 3380 space.  The new suggestion\nwill put 586 records on every track rather than 294, which is a 99%\nimprovement.  Likely, you would want to cut your disk allocation request\nwhile changing your JCL.\n\nBLOCKSIZE BELOW IS TOO HIGH AND ONLY ALLOWS ONE BLOCK PER TRACK.\n\n//OUTBIG    DD DSN=AGY999.BIG.DSN,DISP=(NEW,PASS,DELETE),\n//             UNIT=SYSDA,SPACE=(CYL,(40,20),RLSE),\n//             DCB=(LRECL=80,BLKSIZE=23520,RECFM=FB)\n\n*-> BLOCKSIZE TOO HIGH, TRY 23440 THIS IS 1/2 TRK BLOCKING, SAVE DISK\n\n\nExample 4 shows a blocksize that is effective for DASD, but is small for\ntape output.  Tape should be blocked as high as possible unless there is\na reason (such as COM tapes) not to.\n\nTHE TAPE BELOW WOULD PROCESS MORE EFFICIENTLY WITH MAXIMUM BLOCKING\n\n//OUTTAPE   DD DSN=TAPE.BLOCKED.LOW,DISP=(NEW,PASS,DELETE),\n//             UNIT=TAPE16,\n//             DCB=(LRECL=80,BLKSIZE=11440,RECFM=FB)\n\n*-> BLOCKSIZE TOO LOW, TRY 32720 THIS IS MAXIMUM BLOCKING, SAVE TIME\n\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CHKBLOC#": {"ttr": 3338, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x00\\x7f\\x00\\x88\\x00\\x7f\\x12\\x00\\x00\\x85\\x00\\x85\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf2\\xf7\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-01-07T00:00:00", "modifydate": "1988-01-07T12:00:00", "lines": 133, "newlines": 133, "modlines": 0, "user": "FILE270"}, "text": "//CHKBLOCK PROC LIBRARY='LITTLE.BOPEEPS.SHEEP'\n//*\n//*  *  *  *  *  *  *  *  *\n//*\n//STEP1    EXEC PGM=LISTMEMS,          IDENTIFY MEMBERS IN LIBRARY\n//             REGION=40K\n//STEPLIB  DD  DSN=WDPSC.SHARED.LOAD,\n//             DISP=SHR\n//DD1      DD  UNIT=SYSDA,\n//             VOL=REF=&LIBRARY,\n//             DISP=SHR\n//INPDS    DD  DSN=&LIBRARY,\n//             DISP=SHR\n//OUTMEMS  DD  DSN=&&PDLIST2,\n//             DISP=(,PASS,DELETE),\n//             UNIT=SYSSQ,SPACE=(CYL,(1,1)),\n//             DCB=(LRECL=80,BLKSIZE=9040,RECFM=FB)\n//*\n//*  *  *  *  *  *  *  *  *\n//*\n//STEP2    EXEC PGM=DYL260,            CREATE IEBPP COMMANDS**\n//             PARM='UA=ALL',          (CODE IS SHOWN INLINE\n//             REGION=80K               FOR DOCUMENTATION PURPOSES)\n//SYSPRINT DD  SYSOUT=*\n//SYS260A  DD  DSN=&&PDLIST2,\n//             DISP=(OLD,DELETE)\n//SYS260J  DD  DSN=&&MEMBERS2,\n//             DISP=(,PASS,DELETE),\n//             UNIT=SYSSQ,SPACE=(CYL,(1,1)),\n//             DCB=(LRECL=80,BLKSIZE=9040,RECFM=FB)\n//SYSIN    DD  DSN=WDPSC.CARD(JCLXRTWO),DISP=SHR\nC          00080              MEMBER NAME=\nFA\nFJ             R\nD    115 VPUNCH TYPORG=PO       15 R4\nD    120 V,MAXNAME=600          20 R19\nD    1                        WJ\nD     3  U41                  EQ3  VALL                 AWL\nD     3  A6                   EQ3  U41                     REJ\nDAWL  8  A1                     8  U13\nD     40 U1                     40 R4\nD     3  V                      3  R44\nD     22 U44                    22 R47\nD                             WJ\nD     1  VY                     1  U70                  OUTOUT\nD   L 1  U70                  EQ1  VY                      EJ2\nD   L 1  V0                     2  URTC   B             EJ3EJ3\nDEJ2L 1  V8                     2  URTC   B\nDEJ3  1  V2                     1  UEOJ                 REJREJ\nEND\n//*\n//*  *  *  *  *  *  *  *  *\n//*\n//STEP3    EXEC PGM=IEBPTPCH,          EXTRACT JCL FROM PROCLIB\n//             REGION=60K              OR JCLLIB.\n//SYSPRINT DD  SYSOUT=*\n//SYSUT1   DD  DISP=SHR,\n//             DSN=&LIBRARY\n//SYSIN    DD  DSN=&&MEMBERS2,\n//             DISP=(OLD,PASS)\n//SYSUT2   DD  DSN=&&JCD2,\n//             UNIT=SYSDA,\n//             DISP=(,PASS,DELETE),\n//             SPACE=(CYL,(10,10),RLSE),\n//             DCB=(LRECL=81,RECFM=FB,BLKSIZE=9072)\n//*\n//*  *  *  *  *  *  *  *  *\n//*\n//STEP4    EXEC PGM=DYL260             MAKE MEMBER NAME LOOK LIKE\n//SYSPRINT DD  SYSOUT=*                PART OF THE JCL AND FLAG IT\n//SYS260A  DD  DSN=&&JCD2,             SO THAT STEP6 RECOGNIZSES\n//             DISP=(OLD,PASS)         THE START OF EACH NEW MEMBER\n//SYS260J  DD  DSN=&&PJCD2,\n//             UNIT=SYSDA,\n//             DISP=(,PASS,DELETE),\n//             SPACE=(CYL,(10,10),RLSE),\n//             DCB=(LRECL=81,BLKSIZE=9072)\n//SYSIN    DD  DSN=WDPSC.CARD(FLAGMEMB),DISP=SHR\nC          81               1\nFA F\nFJ F           R\nD     11 A2                   EQ11 VMEMBER NAME         MEMJCL\n*   ***  IF RECORD IS STANDARD JCL\nDJCL  81 A1                     81 R1\nD     1  V1                     1  UCLR                 OUTOUT\n*   ***  IF RECORD IS MEMBER STATEMENT\nDMEM  8  A15                    8  R4\nD     2  V//                    2  R2\nD     4  V$;.*                  4  R13\n*   * LITERAL ABOVE FLAGS MEMBER NAME FOR JCL THAT FOLLOWS\nD     1  V1                     1  UCLR                 OUTOUT\nEND\n//*\n//*  *  *  *  *  *  *  *  *\n//*\n//STEP5    EXEC PGM=DYL260,            STRIP OFF CONTROL CHARACTERS\n//             REGION=80K              SO COLUMNS 1 AND 2 ARE //\n//SYSPRINT DD  SYSOUT=*                IE RECOGNIZED AS JCL\n//SYS260A  DD  DSN=&&PJCD2,\n//             DISP=(OLD,DELETE)\n//SYS260J  DD  DSN=&&JCL,\n//             UNIT=SYSDA,\n//             DISP=(,PASS,DELETE),\n//             SPACE=(CYL,(10,10),RLSE),\n//             DCB=(LRECL=80,BLKSIZE=9040,RECFM=FB)\n//SYS260R  DD  DUMMY\n//SYSIN    DD  DSN=WDPSC.CARD(JCLXREF5),DISP=SHR\nC          80\nFA\nFJ             R\nD     80  2                     80 R1\nD     6  R1                   EQ6  VMEMBER                 OUT\nD     8  R14                    8  U41                  REJREJ\nR01 60         E\nT1                                                 WASHINGTON STATE LIQ\nT1   UOR CONTROL BOARD\nT2                                                        CATALOGUED PR\nT2 2 OCEDURES                                        U8211195-2\nP   8  U41                1 S            PROCEDURE NUMBER\nP   80 R1                   X            JCL STATEMENTS\nP   30 ULDT      2001                   *DATE AND PAGE NUMBER\n//*\n//*  *  *  *  *  *  *  *  *\n//*\n//STEP6    EXEC PGM=CHKBLOCK           LIST JCL, SUGGESTING BLOCKSIZES\n//STEPLIB  DD  DISP=SHR,\n//             DSN=WDPSC.SHARED.LOAD\n//SYSUDUMP DD  SYSOUT=*\n//FILEIN   DD  DSN=&&JCL,DISP=(OLD,DELETE)\n//FILEOUT  DD  SYSOUT=*,DCB=RECFM=FBA\n//*\n//*  *  *  *  *  *  *  *  *\n//*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CHKBLOCK": {"ttr": 3341, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x00\\x7f\\x00\\x88\\x00\\x7f\\x12\\x00\\x01\\x91\\x01\\x91\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf2\\xf7\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-01-07T00:00:00", "modifydate": "1988-01-07T12:00:00", "lines": 401, "newlines": 401, "modlines": 0, "user": "FILE270"}, "text": "CHKBLOCK CSECT\n*\n*\n*        THIS PROGRAM'S PURPOSE IS TO PRINT JCL STREAMS, EXAMINING\n*        THE BLOCKSIZE OF OUTPUT DATASETS TO SEE IF THE BLOCKSIZE IS\n*        EFFICIENT FOR THE LRECL.  OPTIMUM BLOCKSIZES ARE COMPARED TO\n*        THE SELECTED BLOCKSIZE.  IF THE SELECTED BLOCKSIZE IS WITHIN\n*        ONE RECORD LENGTH OF ANY OF THE HIGHEST FOUR OPTIMUM SIZES,\n*        THE DD STATEMENT IS PRINTED W/O COMMENT AND PROCESSING KEEPS\n*        GOING.  IF NOT, A STATEMENT WILL BE WRITTEN PRIOR TO THE DD\n*        STATEMENT SAYING WHAT IS WRONG WITH THE ORIGINAL BLOCKSIZE\n*        CHOICE.  THEN  A SUGGESTED BLOCKSIZE IS GIVEN FOLLOWING THE\n*        WRITING OF THE DD STATEMENT.  THIS SUGGESTED BLOCKSIZE WILL\n*        BE WITHIN ONE LRECL OF THE OPTIMUM FOR FB RECORDS OR EQUAL\n*        TO THE OPTIMUM IN THE CASE OF VB RECORDS.  ONE FIFTH TRACK\n*        BLOCKING IS CHOSEN AS THE SMALLEST SUGGESTED BLOCKSIZE.\n*        THIS IS BECAUSE THE BUFNO=5 DEFAULT WILL CAUSE A TRACK TO\n*        BE READ OR WRITTEN WITH EACH PHYSICAL I/O CYCLE.  PROCESSING\n*        A TRACK AT A TIME IS EFFICIENT FOR DASD AND THE CPU.  ONLY\n*        3380 DEVICES AND TAPE WILL BE CONSIDERED, SINCE THAT IS WHERE\n*        MOST USER DATA NOW RESIDES.\n*\n*        WRITTEN 4-7-86 BY HOWARD H.GLASTETTER\n*\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2         WORK - ADDR SAVE AREA\nR3       EQU   3         WORK - BXLE LOGIC\nR4       EQU   4         *                   ALTER R4 WITH CARE\nR5       EQU   5         *\nR6       EQU   6         WORK AIDS SOME BXLE ROUTINES\nR7       EQU   7         WORK FOR EXECUTE MOVE INSTRUCTION - LENGTH\nR8       EQU   8         *                                   TO FIELD\nR9       EQU   9         *                                   FROM FIELD\nR10      EQU   10        SUBROUTINE LINKAGE\nR11      EQU   11        WORK POINT TO DDJCLTAB\nR12      EQU   12        BASE\nR13      EQU   13        SYSTEM LINKAGE\nR14      EQU   14\nR15      EQU   15\n*\nBEGIN    SAVE  (14,12)       PROGRAM LINKAGE AND INITIATION\n         BALR  12,0\n         USING *,12\n         ST    R13,REGSAVE+4\n         LA    R11,REGSAVE\n         ST    R11,8(R13)\n         LR    R13,R11\n*\n         PRINT ON,NOGEN\n         EJECT\n         OPEN  (FILEIN,,FILEOUT,(OUTPUT))\n*\n         LA    R4,1                SEMI-PERMANENTLY INIALIZE R4\n*\nLOOP10   EQU   *                   INITIAL SEARCH FOR A DD STATEMENT\n         BAL   R10,READ70\n         CLC   RCRDIN(2),=C'//'    CHECK FOR NON-JCL\n         BNE   LOOP10              BYPASS NON JCL\n         CLI   RCRDIN+2,C'*'       CHECK FOR COMMENT\n         BE    WRITE20\n         LA    R3,RCRDIN+2\n         LA    R5,RCRDIN+71\nLOOP10A  EQU   *\n         CLC   0(6,R3),=C' $;.* '  PRIOR STEP INSERTS THIS RECORD\n         BE    LOOP10AA            PRINT MEM NAME AT TOP OF PAGE\n         BXLE  R3,R4,LOOP10A\n         LA    R3,RCRDIN+2         NOT JOB OR PROC, KEEP GOING\n         B     LOOP10B\nLOOP10AA EQU   *\n         CP    OUTCOUNT,=P'1'      WAS THE PRIOR MEMBER WHOLLY NON JCL\n         BNE   LOOP10AB            NOPE\n         MVI   PRINTCHR,C' '\n         MVC   RCRDOUT,PRINTCHR    BLANK THE RECORD\n         MVI   PRINTCHR,C'-'       SKIP 3 FOR NEXT PRINT LINE\n         MVC   RCRDOUT(38),=C'THE ABOVE MEMBER NAME CONTAINED NO JCL'\nLOOP10AB EQU   *\n         SP    OUTCOUNT,OUTCOUNT   CLEAR THE COUNT FIELD\n         MVC   RCRDOUT,RCRDIN\n         MVC   RCRDOUT(2),=C' ('\n         MVC   RCRDOUT+10(32),=C') IS THE MEMBER NAME CONTAINING '\n         MVC   RCRDOUT+42(28),=C'THE FOLLOWING JCL.          '\n         BAL   R10,WRITE80         SKIP TO TOP OF PAGE\n         MVI   PRINTCHR,C'-'       SKIP 3 FOR NEXT PRINT LINE\n         B     LOOP10              GET THE NEXT RECORD\nLOOP10B  EQU   *\n         CLC   0(4,R3),=C' DD '    FIND A 'DD' CLUSTER\n         BE    BLDTB30             THERE IT IS!\n         BXLE  R3,R4,LOOP10B\n*                                  FALL THRU MEANS NOT DD RECORD\nWRITE20  EQU   *\n         MVC   RCRDOUT,RCRDIN\n         BAL   R10,WRITE90\n         B     LOOP10\n         EJECT\n*        THIS ROUTINE BUILDS A TABLE OF RECORDS FOR A DD CLUSTER\n*\nBLDTB30  EQU   *\n         MVC   DDJCLTAB(256),DDJCLTAB-1        INIT TABLE\n         MVC   DDJCLTAB+256(256),DDJCLTAB+255  (DEBUG AID)\n         MVC   DDJCLTAB+512(256),DDJCLTAB+511\n         MVC   DDJCLTAB+768(256),DDJCLTAB+767\n         MVC   DDJCLTAB+1024(256),DDJCLTAB+1023\n         MVC   DDJCLTAB+1280(256),DDJCLTAB+1279\n         MVC   DDJCLTAB+1536(64),DDJCLTAB+1535\n         LA    R11,DDJCLTAB\nBLDTB30A EQU   *\n         LA    R3,RCRDIN+3\n         LA    R5,RCRDIN+71\n         CLC   RCRDIN(3),=C'//*'  CHECK FOR NON-JCL W/I DD STATEMENT\n         BE    BLDTB30D           IMBEDDED COMMENTS WILL BE DROPPED\nBLDTB30B EQU   *\n         CLC   0(2,R3),=C', '     CONTINUATION?\n         BE    BLDTB30C\n         BXLE  R3,R4,BLDTB30B\n         MVC   0(80,R11),RCRDIN   PUT LAST RECORD IN TABLE\n         B     CKDCB40            HAVE ALL THE DD CLUSTER NOW\nBLDTB30C EQU   *\n         MVC   0(80,R11),RCRDIN\n         LA    R11,80(R11)        BUMP TABLE ONE SLOT\nBLDTB30D EQU   *\n         BAL   R10,READ70\n         B     BLDTB30A           PROCESS ANOTHER STATEMENT\n*\n*        END OF BUILD TABLE, NOW SEARCH DD CLUSTER FOR NEEDED FIELDS\n         EJECT\nCKDCB40  EQU   *                  FIND DCB AND UNIT INFO BY\n         MVC   UNITSAVE,SPACES    SEARCHING THE COMPLETE DD\n         MVC   RECFMSAV,SPACES    STATEMENT NOW ISOLATED IN\n         ZAP   PACKRECL,=P'0'     THE TABLE.\n         ZAP   DISKSIZE,=P'0'\n         ZAP   PACKBLOK,=P'0'\n         LA    R3,DDJCLTAB\n         LA    R5,80(R11)         END OF LAST TABLE ELEMENT\n*\nCKDCB40A EQU   *                  GET OR BUILD NEEDED FIELDS\n         CLC   0(5,R3),=C'UNIT='\n         BE    CUNIT40C\n         CLC   0(6,R3),=C'RECFM='\n         BE    CRECF40D\n         CLC   0(8,R3),=C'BLKSIZE='\n         BE    CBLK50A\n         CLC   0(6,R3),=C'LRECL='\n         BE    CREC50B\n*\nCKDCB40B EQU   *\n         BXLE  R3,R4,CKDCB40A\n         B     CALC50EA            FALLTHRU SEARCH IS OVER\n*\nCUNIT40C EQU   *\n         MVC   UNITSAVE,5(R3)      SAVE THE UNIT\n         B     CKDCB40B\n*\nCRECF40D EQU   *\n         MVC   RECFMSAV,6(R3)      SAVE RECFM TYPE\n         B     CKDCB40B\n         EJECT\n*                                  PACK THE BLOCKSIZE ROUTINE\n*\nCBLK50A  EQU   *\n         LA    R3,8(R3)            POINT TO BLOCKSIZE HIGH ORDER\n         CLI   0(R3),C'*'          WE DON'T DO BACKREFS HERE!!!\n         BE    WRTAB60             PURGE THE TABLE\n         CLI   0(R3),X'50'         WE DON'T DO SYMBOLICS EITHER!!\n         BE    WRTAB60             PURGE THE TABLE\n         LA    R8,PACKBLOK         POINT TO BEGIN RECL\n         LR    R9,R3               SAVE BEGIN ADDR\n         L     R7,=F'48'           SET 'TO' FIELD (L1) TO 4 (HEX 30)\n         B     CREC50C             COMMON PACK TO WORK ROUTINE\n*\n*                                  PACK THE LRECL ROUTINE\n*\nCREC50B  EQU   *\n         LA    R3,6(R3)            POINT TO BEGIN RECL\n         LA    R8,PACKRECL         POINT TO BEGIN RECL\n         LR    R9,R3               SAVE BEGIN ADDR\n         L     R7,=F'32'           SET 'TO' FIELD (L1) TO 3 (HEX 20)\nCREC50C EQU   *\n         CLI   0(R3),C','          IS THIS THE DELIMITER??\n         BE    CALC50D\n         CLI   0(R3),C')'          OR THIS?\n         BE    CALC50D\n         CLI   0(R3),C' '          OR THIS?\n         BE    CALC50D\n         LA    R7,1(R7)            UP SEND FIELD LENGTH (L2)\n         BXLE  R3,R4,CREC50C\n*                                  FALL THRU SHOULD NOT HAPPEN\n*\nCALC50D  EQU   *\n         BCT   R7,*+4              DECRIMENT TO LOW ORDER CHARACTER\n         EX    R7,PACK100          PACK THE RECORD LENGTH\n         B     CKDCB40B            FINISH THE SEARCH\n         EJECT\nCALC50EA EQU   *\n         CP    PACKBLOK,=P'0'        BLKSIZE IN DCB STMT?\n         BE    WRTAB60               NO, PURGE THE TABLE\n         CP    PACKRECL,=P'0'        LRECL IN DD STMT?\n         BNE   CALC50EB              YES, KEEP GOING\n         B     WRTAB60               NO, PURGE THE TABLE\nCALC50EB EQU   *\n         CLC   UNITSAVE,=C'SYSDA'    IS THIS A 3380 DEVICE?\n         BE    CALC50G\n         CLC   UNITSAVE,=C'SYSSQ'\n         BE    CALC50G\n         CLC   UNITSAVE(4),=C'3380'\n         BE    CALC50G\n         CLC   UNITSAVE(4),=C'TAPE'  OR A TAPE?\n         BE    CALC50F\n         B     WRTAB60               NO, PURGE THE TABLE\n*\n*                                    HANDLE TAPE BLOCKSIZE\n*\nCALC50F  EQU   *\n         CP    PACKBLOK,TAPEBLOK     IS TAPE BLOCKED 32K?\n         BNL   WRTAB60               YEP\n         LA    R3,TAPEBLOK           BLOCKSIZE TABLE\n         B     CALC50HC              GIVE EM A TAPE SUGGESTION\n*\n*                                    HANDLE HIGH BLOCKSIZE\n*\nCALC50G  EQU   *\n         LA    R3,OPTTABLE           BLOCKSIZE TABLE\n         LA    R5,OPTTBEND           END OF TABLE\n         LA    R4,20                 INCRIMENT\n         CP    PACKBLOK,0(3,R3)      BLOCKED MORE THAN 1/2 TRACK?\n         BL    CALC50H               NO, CHECK FOR LOW BLOCKSIZE\n         BE    WRTAB60               PURGE TABLE, IT'S EXACTLY 1/2\n         MVI   MSGCOUNT,C'1'         TELL EM THEY CAN ONLY GET 1\n         MVI   S,C' '                BLOCK\n         MVC   PRINTREC,WARNMSG1     PER TRACK\n         BAL   R10,WRITE90\n         MVI   PRINTCHR,C'0'         SKIP A LINE BEFORE DD PRINT\n         BAL   R10,NUBLK110          GET THE BLOCKSIZE\n         MVC   MESSAGE1,=C'*-->> ABOVE BLOCKSIZE TOO HIGH, USE '\n         B     WRTAB60               PURGE TABLE AND GIVE WARNING\n         EJECT\n*\n*                                    HANDLE LOW BLOCKSIZE\n*\nCALC50H  EQU   *                     CHECK BLOCKSIZE TABLE\n         CP    PACKBLOK,0(3,R3)      FIND CLOSEST OPTIMUM\n         BL    CALC50HA\n         BE    WRTAB60               YOU CAN'T DO BETTER THAN EQUAL\n         B     CALC50HB\nCALC50HA EQU   *\n         BXLE  R3,R4,CALC50H         CHECK AGAIN\nCALC50HB EQU   *                     FALL THRU AT BOTTOM OF TABLE\n         SH    R3,=H'20'             GET BACK TO THE LOW BLOCK\nCALC50HC EQU   *                     FALL THRU AT BOTTOM OF TABLE\n         CLC   RECFMSAV,=C'VB'       VARIABLE SHOULD BE OPTIMUM\n         BNE   CALC50HF\n         CP    PACKBLOK,PACKRECL     IGNORE VBS\n         BL    WRTAB60               BLOCK SMALLER THAN LRECL - SKIP\n*\n         BAL   R10,WARN120           EXPLAIN WHAT'S WRONG\n*\n         MVC   MESSAGE1,=C' BLOCK ABOVE RECFM=VB OPTIMALLY USE '\n         UNPK  BLOKSIZE,0(3,R3)      OPT BLKSIZE IN DISPLAY AREA\n         OI    BLOKSIZE+4,X'F0'      REMOVE THE SIGN, IF ANY\n         B     WRTAB60               PURGE TABLE AND GIVE WARNING\nCALC50HF EQU   *                     FALL THRU AT BOTTOM OF TABLE\n         AP    PACKBLOK,PACKRECL     ADD A RECORD LENGTH TO BLKSIZE\n         CP    PACKBLOK,0(3,R3)      IS THE CHOSEN BLOCK OPTIMUM\n         BNL   WRTAB60               SEEMS SO\n*\n         BAL   R10,WARN120           EXPLAIN WHAT'S WRONG\n*\n         BAL   R10,NUBLK110          GET THE LOWEST HIGHER BLOCKSIZE\n         MVC   MESSAGE1,=C'*-->> ABOVE BLOCKSIZE TOO LOW,  USE '\n*                                    FALL THRU AND WRITE TABLE OUT\n         EJECT\n*                                    WRITE TABLE TO OUTPUT\nWRTAB60  EQU   *\n         CLC   MESSAGE1(8),SPACES    ANY SUGGESTIONS?\n         BE    WRTAB60A              NOPE\n         MVC   MESSAGE2,BLOKSIZE     MOVE EM WHILE R3 IS GOOD\n         MVC   MESSAGE4,3(R3)        1/N TRACK OR MAXIMUM\n         MVC   MESSAGE6,10(R3)       WHAT WILL IT SAVE\nWRTAB60A EQU   *\n         LA    R3,DDJCLTAB\n         LA    R4,80\n         LR    R5,R11                POINT TO BEGIN OF LAST RECORD\nWRTAB60B EQU   *\n         MVC   RCRDOUT,0(R3)\n         BAL   R10,WRITE90\n         BXLE  R3,R4,WRTAB60B        FALL THRU WHEN DD CLUSTER PRINTS\n*\n         CLC   MESSAGE1(8),SPACES    ANY SUGGESTIONS?\n         BE    WRTAB60C              NOPE\n         MVC   PRINTREC,MESSAGES     YEP\n         BAL   R10,WRITE90\n         MVI   PRINTCHR,C'-'         TRIPLE SPACE AFTER WARNING\n         MVC   MESSAGE1(8),SPACES    RESET AS A SWITCH\nWRTAB60C EQU   *\n         LA    R4,1                  NORMAL CONTENTS OF R4\n         B     LOOP10\n         EJECT\n*                                    S U B R O U T I N E S\nREAD70   EQU   *\n         GET   FILEIN,RCRDIN\n         MVI   RCRDIN+71,C' '        BLANK ALWAYS FOLLOWS LAST COMMA\n         BR    R10\n*\nWRITE80  EQU   *                     CAUSE PRINT AT TOP OF PAGE\n         MVI   PRINTCHR,C'1'\nWRITE90  EQU   *                     WRITE JCL\n         PUT   FILEOUT,PRINTREC\n         AP    OUTCOUNT,=P'1'        COUNTER TO CHECK FOR NO JCL\n         MVI   PRINTCHR,C' '         PRINT ALL ELSE NORMAL\n         MVC   HIGHLITE,SPACES       CLEANUP\n         BR    R10\n*\nPACK100  PACK  0(0,R8),0(0,R9)       BOTH LENGTHS IN R7\n*\nNUBLK110 EQU   *\n         ZAP   DISKSIZE,0(3,R3)      PLACE SELECTED BLOCK IN WORK\n         DP    DISKSIZE,PACKRECL\n         ZAP   PBLKSIZE,DISKSIZE(5)\n         MP    PBLKSIZE,PACKRECL     OPT BLKSIZE IN PACKED FORM\n         UNPK  BLOKSIZE,PBLKSIZE     OPT BLKSIZE IN SAVEAREA\n         OI    BLOKSIZE+4,X'F0'      REMOVE THE SIGN, IF ANY\n         BR    R10\n*\nWARN120  EQU   *                     EXPLAIN WHAT IS WRONG\n         ST    R10,TENSAVE\n         CLC   UNITSAVE(4),=C'TAPE'\n         BE    WARN120B\n         CLI   5(R3),C'5'            AT LOWEST BLOCK?\n         BNE   WARN120A              NO\n         MVC   PRINTREC,WARNMSG2     TELL EM THEY ARE TOO LOW\n         B     WARN120C\nWARN120A EQU   *\n         MVC   MSGCOUNT,5(R3)        TELL EM THEY CAN ONLY GET N\n         MVI   S,C'S'                BLOCKS\n         MVC   PRINTREC,WARNMSG1     PER TRACK\n         B     WARN120C\nWARN120B EQU   *\n         MVC   PRINTREC,WARNMSG3     TELL EM TAPE SHOULD BE OPTIMUM\nWARN120C EQU   *\n         BAL   R10,WRITE90           WRITE WHATEVER WARNING MESSAGE\n         MVI   PRINTCHR,C'0'         SKIP A LINE BEFORE DD PRINT\n         L     R10,TENSAVE\n         BR    R10\n*\nEOF130   EQU   *\n         CLOSE (FILEIN,,FILEOUT)\n         L     R13,REGSAVE+4\n         RETURN (14,12),RC=0\n         EJECT\nREGSAVE  DS    9D\nTENSAVE  DS    F\nRECFMSAV DS    CL2\nUNITSAVE DS    CL5\nPACKRECL DS    PL3\nPACKBLOK DS    PL4\nDISKSIZE DS    PL8\nBLOKSIZE DS    CL5\nPBLKSIZE DS    PL8\nOUTCOUNT DC    PL3'0'\nTAPEBLOK DC    PL3'32760',CL7'MAXIMUM',CL10'JOB TIME  '\nOPTTABLE DC    PL3'23476',CL7'1/2 TRK',CL10'DISK SPACE'\n         DC    PL3'15476',CL7'1/3 TRK',CL10'DISK SPACE'\n         DC    PL3'11476',CL7'1/4 TRK',CL10'DISK SPACE'\nOPTTBEND DC    PL3'09076',CL7'1/5 TRK',CL10'DISK SPACE'\nWARNMSG1 DS    0CL91\nMESSAGEA DC    CL33'-THE BLOCKSIZE BELOW ONLY ALLOWS '\nMSGCOUNT DC    C'X'\nMESSAGEB DC    CL6' BLOCK'\nS        DC    C'S'\nMESSAGEC DC    CL31' PER TRACK AND IS WASTING SPACE'\n         DC    CL19'        <--------****'\nWARNMSG2 DS    0CL91\n         DC    CL33'-THE BLOCKSIZE BELOW IS UNDER 1/5'\n         DC    CL30' TRACK BLOCKING.  THIS CAUSES '\n         DC    CL28'DASD AND CPU CYCLE OVERHEAD.'\nWARNMSG3 DS    0CL91\n         DC    CL34'-THE TAPE BELOW WOULD PROCESS MORE'\n         DC    CL33' EFFICIENTLY IF MAXIMUM BLOCKING'\n         DC    CL24' WERE USED     <-----***'\nSPACES   DC    CL21' '\nMESSAGES DS    0CL91\nMSGCCHAR DC    C'0'                         SKIP A LINE\nMESSAGE1 DC    CL36'                                    '\nMESSAGE2 DC    CL5' '                       SUGGESTED BLOCK\nMESSAGE3 DC    CL9' THIS IS '\nMESSAGE4 DC    CL7' '                       (1/N TRK)\nMESSAGE5 DC    CL23' BLOCK OPTIMUM <- SAVE '\nMESSAGE6 DC    CL10' '                      SAVE ...\n*\nFILEIN   DCB   DSORG=PS,LRECL=80,DDNAME=FILEIN,MACRF=(GM),EODAD=EOF130\nFILEOUT  DCB   DSORG=PS,LRECL=91,DDNAME=FILEOUT,MACRF=(PM)\n*\nRCRDIN   DS    CL80      INPUT RECORD AREA\n*\nPRINTREC DS    0CL91\nPRINTCHR DC    C' '\nRCRDOUT  DS    CL80      OUTPUT RECORD AREA\nHIGHLITE DC    CL10' '\n         DC    C'#'\nDDJCLTAB DS    CL1600    HOLD AREA FOR 'DD' CLUSTER\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CHKTODAY": {"ttr": 3590, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x00\\x7f\\x00\\x88\\x00\\x7f\\x12\\x00\\x00i\\x00i\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf2\\xf7\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-01-07T00:00:00", "modifydate": "1988-01-07T12:00:00", "lines": 105, "newlines": 105, "modlines": 0, "user": "FILE270"}, "text": "CHKTODAY CSECT\n*\n*        C H K T O D A Y                     (CHKTODAY)\n*\n*        THIS PROGRAM CHECKS TO SEE IF A FILE HAS BEEN CREATED TODAY.\n*        THE FILE NAME IS PASSED TO THE PROGRAM AS A PARM.  IF THE\n*        FILE NAME CAN'T BE FOUND A RC OF 8 IS ISSUED.  IF IT IS FOUND,\n*        IT COMPARES THE DS1CREDT OF THE FORMAT 1 DSCB TO TODAY'S\n*        DATE.  IF THEY ARE EQUAL IT ISSUES A RC 0 TO INDICATE THE FILE\n*        WAS CREATED TODAY. IF NOT A RC 4 IS ISSUED.  THE DATE HAS\n*        TO BE CONVERTED FROM PACKED DECIMAL (YYDDDF) FORMAT TO\n*        A BINARY FORMAT (YY0DDD) USED BY THE VTOC.\n*\n*                             WRITTEN BY HOWARD GLASTETTER    4-3-86\nR0       EQU   0\nR1       EQU   1              ADDR OF ADDR OF DSN GIVEN AS A PARM\nR2       EQU   2\nR3       EQU   3              ADDR OF DSN\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6              EXEC MOVE LENGTH\nR7       EQU   7              POINT FOR EXEC MOVE\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10             BINARY CONV REG\nR11      EQU   11             BASING\nR12      EQU   12             WORK (IN SETTING UP PROGRAM LINKAGE)\nR13      EQU   13             LINKAGE POINTER\nR14      EQU   14             RETURN REGISTER\nR15      EQU   15             RETURN CODE\n         PRINT ON,NOGEN\n*\nBEGIN    SAVE  (14,12)        HOUSEKEEPING\n         BALR  11,0\n         USING *,11\n         ST    R13,REGSAVE+4\n         LR    R12,R13\n         LA    R13,REGSAVE\n         ST    R13,8(R12)     ____________\n         EJECT\n*                             GET DATASET NAME AND VOLSER\n*\n         L     R3,0(R1)       SAVE DSN ADDR\n         LA    R7,DSNAME\n         LH    R6,0(R3)       LENGTH IN R6\n         BCT   R6,*+4         REDUCE LENGTH FOR EXEC MOVE\n         EX    R6,MOVEDSN     MOVE THE DATASET NAME TO THE FIELD\n*\n         LOCATE FINDVOL       FIND THE VOLSER OF THE DATASET\n         LTR   R15,R15        WAS THE VOLUME FOUND?\n         BNZ   NOTATALL       NO, THE FILE DOESN'T EXIST - CC4 ANYWAY\n         MVC   VOLNUM,LOCAREA+6  YEP, PLUG IN VOLNUM\n*\n         OBTAIN DSCBFILE      READ DSCB OF THE DATASET\n*\nGETDATE  TIME  DEC            TODAY'S DATE WILL RETURN IN R1\n         ST    R1,TODAY\n*\n         MVO   PACKEDYR,TODAY+1(1)             CONVERT YY\n         MVC   CONVERT+6(2),PACKEDYR\n         CVB   R10,CONVERT\n         STH   R10,BINARYYR\n*\n         MVC   CONVERT+6(2),TODAY+2            CONVERT DDD\n         CVB   R10,CONVERT\n         STH   R10,BINARYDA\n*\n         CLC   WORKAREA+9(3),BINARYYR+1       FILE CREATED TODAY?\n         BE    SETCC0                          YEP\n         MVC   REGSAVE+16(4),=F'4'             NOPE, FORCE RC 4\n         B     RETURN\nNOTATALL EQU   *\n         MVC   REGSAVE+16(4),=F'8'  DATASET NOT FOUND, FORCE RC 8\n         B     RETURN\nSETCC0   EQU   *\n         MVC   REGSAVE+16(4),=F'0'             FORCE RC 0\nRETURN   EQU   *\n         L     R15,REGSAVE+16                  PLACE RC IN R15\n         L     R13,REGSAVE+4                   RETURN HOUSEKEEPING\n         L     R14,12(R13)\n         LM    R2,R12,28(R13)\n         L     R0,20(R13)\n         BCR   15,R14\n*\nMOVEDSN  MVC   0(0,R7),2(R3)                   LENGTH IN R6\n         EJECT\n*\n*           AREA BELOW IS USED BY THE LOCATE AND OBTAIN MACROS\n*\nDSCBFILE CAMLST SEARCH,DSNAME,VOLNUM,WORKAREA\nDSNAME   DC    CL44'                                            '\nVOLNUM   DC    CL6'      '\nWORKAREA DS    CL140\nFINDVOL  CAMLST NAME,DSNAME,,LOCAREA\n         DS    0D\nLOCAREA  DS    CL265\n*\nREGSAVE  DS    9D\nCONVERT  DC    D'0'\nTODAY    DC    F'0'\nBINARYYR DC    H'0'\nBINARYDA DC    H'0'\nPACKEDYR DC    PL2'0'\n         END\n*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CHKTODY$": {"ttr": 3593, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x00\\x7f\\x00\\x88\\x00\\x7f\\x12\\x00\\x00/\\x00/\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf2\\xf7\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-01-07T00:00:00", "modifydate": "1988-01-07T12:00:00", "lines": 47, "newlines": 47, "modlines": 0, "user": "FILE270"}, "text": "\n           PROGRAM NAME: CHKTODAY\n\n           FUNCTION:     DETERMINE IF A DATASET EXISTS AND IF SO\n                         WHETHER IT WAS CREATED TODAY OR NOT.\n\n           AUTHOR:       Howard H. Glastetter\n\n           AGENCY:       WDPSC\n\n           Location:     WDPSC.SHARED.LOAD\n\n           This program will search for a dataset, return a user code\n           of 8 if it doesn't exist, return a user code of 4 if it was\n           created before today's date, or return a user code of 0 if\n           the dataset was created today.\n\n           Occasionally there is a common need for current data.\n           Sometimes, such data is created as an extracted subset of\n           a much larger file or via an expensive procedure.  The end\n           result might be duplicated efforts for the same data.\n\n           This program will allow checking first to see if a current\n           common file exists before recreating it.  The program works\n           for sequential, PDS and VSAM datasets.\n\n           If your have multiple copies of the same data being generated\n           on the same day, this program might save both money and time.\n\n           To determine the creation status of a file, enter the dataset\n           name as a parm to the CHKTODAY program.  If you are using a\n           USER CATALOG other than SYS1.USERCAT1, then place it in the\n           step JCL as a STEPCAT statement.  JCL follows:\n\n\n           //         JOB (         ),'            ',REGION=512K,MSGCLASS=A,\n           //       MSGLEVEL=( , ),CLASS= ,NOTIFY=\n           //JOBCAT   DD DSN=SYS1.USERCAT1,DISP=SHR\n           //*\n           //CHKITOUT EXEC PGM=CHKTODAY,PARM='YOUR.DATASET.NAME'        '\n           //STEPCAT  DD DSN=YOUR.USERCAT.IF.NOT.USERCAT1,DISP=SHR\n           //STEPLIB  DD DSN=WDPSC.SHARED.LOAD,DISP=SHR\n           //SYSUDUMP DD SYSOUT=*\n\n\n           Once the step executes, simply check the condition codes to see\n           if the file is OK to use or should be recreated.\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "CLIB$": {"ttr": 3595, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x00\\x7f\\x00\\x88\\x00\\x7f\\x12\\x00\\x00W\\x00W\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf2\\xf7\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-01-07T00:00:00", "modifydate": "1988-01-07T12:00:00", "lines": 87, "newlines": 87, "modlines": 0, "user": "FILE270"}, "text": "1                                                        CLIB.1\n                                                         06/25/82\n\n\n  CLIST:              CLIB\n  AUTHOR:             Jeff Sprehn\n  AGENCY:             WDPSC\n  FUNCTION:           Allocate  a  private CLIST  library  for  the\n                      duration of your session.\n\n  TERMINAL TYPE:      3270 type or dialup\n\n  The CLIB  CLIST is used to  allocate a private CLIST  library for\n  the duration of your session or  until you free it.  This library\n  then  becomes an  implicit command-library  like  the user  CLIST\n  library  (USER.CLIST).    Members  of  this  CLIST   library  can\n  thereafter  be executed  simply  by  entering their  name.   This\n  library should  have the same  DCB characteristics  as USER.CLIST\n  since  they are  concatenated.   Every time  that  this CLIST  is\n  invoked, the library to be allocated is  placed at the top of the\n  stack and all  other CLIST libraries that might  be allocated are\n  shoved down to make room for this library.  (In prior versions of\n  this  CLIST,  subsequent  CLIB's would  wipe  out  prior  CLIBS).\n  Unless you  LOGOFF, FREE  DDNAME SYSPROC,  or do  an UNCLIB,  all\n  CLIST  libraries used  in  CLIB command  are  \"attached\" to  your\n  session and their members may be invoked implicitly.\n\n  Syntax -\n\n  _________________________________________________________________\n       COMMAND  Operands\n  -----------------------------------------------------------------\n       CLIB     clist-library  XLIB(clist-library#2) PRINT  (print notif)\n\n\n\n\n1                                                        CLIB.2\n                                                         06/25/82\n\n\n  Operands -\n\n    Required - clist-library\n\n    Default  - None.\n      clist -library:  The name of the CLIST library to be allocated.\n      clist-library#2:  An additional CLIST library to be allocated.\n                        To avoid dataset name prefixing, this data\n                        set name must be enclosed in triple quotes.\n\n      print notif          Enter YES, NO, or do not specify.\n                           'YES' will  cause the  following message\n                           to be  displayed on your  terminal after\n                           successful completion:\n\n                                SUCCESSFUL COMPLETION\n                                     (RETURN CODE = 0)\n\n                           'NO' will prevent the above message from\n                           being written to your  terminal.  If you\n                           do not  specify the PRINT  keyword, then\n                           'YES' is the default.\n\n\n\n\n1                                                        CLIB.3\n                                                         06/25/82\n\n\n  EXAMPLE:\n       If you were  not a PROD1 user,  and you first logged  on and\n       entered:\n                 CLIB 'AGNCY999.MISC.CLIST' XLIB('''XX00999.MISC.CLIST''')\n\n  Then the  following CLIST  libraries would  be allocated  to your\n  session in the following order:\n\n       l.   AGNCY999.MISC.CLIST\n       2.   XX00999.MISC.CLIST\n       3.   WDPSC.MASTER.CLIST\n       4.   USER.CLIST\n\n\n\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CLISTS": {"ttr": 3598, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x00\\x7f\\x00\\x88\\x00\\x7f\\x12\\x00T\\xe4T\\xe4\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf2\\xf7\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-01-07T00:00:00", "modifydate": "1988-01-07T12:00:00", "lines": 21732, "newlines": 21732, "modlines": 0, "user": "FILE270"}, "text": "./ ADD NAME=BLKING   0113-81349-87071-1448-00012-00015-00000-LS02155\n        PROC 0\n\n\n        CONTROL NOMSG NOFLUSH\n\n\n        /*   CALL 'WDPSC.SHARED.LOAD(PGMUSAGE)' '&STR(BLKING  ,2)'  */\n\n\n        ISPEXEC CONTROL DISPLAY REFRESH\n\n\n        ISPEXEC DISPLAY PANEL(BLKPANEL)\n\n\n        IF &LASTCC > 0 THEN EXIT\n\n\n        FREE DDN(SYSOUT)\n\n\n        ALLOC DDN(SYSOUT) DSN(*)\n\n\n        SET &LRECL = &LRECL + 10000000\n\n\n        SET &FILESIZE = &FILESIZE + 1000000000\n\n\n        CALL 'WDPSC.SHARED.LOAD(BLKING)' '&SUBSTR(2:8,&LRECL)&SUBSTR(2:10,&FILES\nIZE)'\n\n        FREE DDN(SYSOUT)\n\n\n./ ADD NAME=CATGET   0108-81322-83033-1807-00038-00009-00000-KK00150\n        PROC 2 DSN CAT L\n\n\n        CONTROL NOFLUSH MSG END(ENDO)\n\n\n        IF &L = L THEN +\n\n\n         CONTROL MSG LIST CONLIST SYMLIST\n\n\n        IFALC F(VOLGET)\n\n\n        IF &LASTCC = 0 THEN GOTO ONWIT\n\n\n        ALLOC F(VOLGET) BLOCK(121) SP(10 10) NEW\n\n\n        ONWIT: +\n\n\n        GLOBAL RC VOL DEV\n\n\n        SET RC = 0\n\n\n        STACK DDOUT(VOLGET)\n\n\n        LISTCAT ENT(&DSN) ALL CAT(&CAT)\n\n\n        OPENFILE VOLGET\n\n\n        GETFILE VOLGET\n\n\n        IF &SUBSTR(1:7,&STR(&VOLGET)) NE &STR(NONVSAM) THEN DO\n\n\n                    CLOSFILE VOLGET\n\n\n                    SET RC = 12\n\n\n                    EXIT CODE(12)\n\n\n                                                            ENDO\n\n\n        GETFILE VOLGET\n\n\n        GETFILE VOLGET\n\n\n        GETFILE VOLGET\n\n\n        GETFILE VOLGET\n\n\n        GETFILE VOLGET\n\n\n        SET VOL = &SUBSTR(26:31,&STR(&VOLGET))\n\n\n        SET DEV = &SUBSTR(58:59,&STR(&VOLGET))\n\n\n        CLOSFILE VOLGET\n\n\n\n\n\n        DEVTYPE VOL(&VOL)\n\n\n        IF &LASTCC NE 0 THEN DO\n\n\n              IF &SUBSTR(1:4,&VOL) = 3350 THEN DO\n\n\n                                         SET &DEV = 3350\n\n\n                                         EXIT\n\n\n                                               ENDO\n\n\n               SET RC = 8\n\n\n               EXIT CODE(8)\n\n\n                              ENDO\n\n\n        SET &DEV = &STR(&DEVTYP)\n\n\n./ ADD NAME=CENTER   0137-86245-86266-1316-00069-00030-00000-CG00150\n        /*CLIST****************************************************************/\n\n\n        /*   ISPF/PDF edit macro to center lines of text between the bounds.  */\n\n\n        /*                                                                    */\n\n\n        /*   To run:                                                          */\n\n\n        /*    Enter CENTER on the COMMAND line and use the C line command     */\n\n\n        /*    (in any form) to select the lines to be centered.               */\n\n\n        /**********************************************************************/\n\n\n        ISREDIT MACRO NOPROCESS\n\n\n        CONTROL NOFLUSH NOMSG\n\n\n        /*CONTROL LIST CONLIST SYMLIST\n\n\n\n\n\n        GETMY SYSID\n\n\n        IF &SYSID = H3AN THEN SET TYPSTR = &&STR\n\n\n        IF &SYSID NE H3AN THEN SET TYPSTR = &&NRSTR\n\n\n\n\n\n        ISREDIT (LEFTBND,RIGHTBND) = BOUNDS\n\n\n        ISREDIT (LRECL) = DATA_WIDTH\n\n\n        SET BNDSIZE = &EVAL(&RIGHTBND-&LEFTBND+1)\n\n\n\n\n\n        /* PROCESS LINE COMMANDS, CHECK IF C  WAS SPECIFIED */\n\n\n        ISREDIT PROCESS RANGE C\n\n\n        SET RC = &LASTCC\n\n\n        IF &RC >= 16 THEN +\n\n\n        SET CODE(12)  /* LINE COMMAND CONFLICT - EDIT WILL CREATE MES\nSAGE\n\n        ELSE IF &RC >= 4 THEN +\n\n\n        DO\n\n\n          /* MISSING C LINE COMMAND */\n\n\n          SET ZEDSMSG = &STR(ENTER \"C\" LINE CMD)\n\n\n          SET ZEDLMSG = &STR(SPECIFY THE LINES TO BE CENTRED WITH THE \" C\" COMMA\nND)\n\n          ISPEXEC SETMSG MSG(ISRZ001)\n\n\n          EXIT CODE(12)\n\n\n        END\n\n\n\n\n\n        ISREDIT (ZFRANGE) = LINENUM .ZFRANGE\n\n\n        ISREDIT (ZLRANGE) = LINENUM .ZLRANGE\n\n\n        SET I = &ZFRANGE\n\n\n\n\n\n        DO WHILE &I <= &ZLRANGE\n\n\n        /* PUT THE LINE INTO THISLINE */\n\n\n          ISREDIT (THISLINE) = LINE &I\n\n\n          IF &LEFTBND = 1 THEN +\n\n\n            SET LEFTPART = &TYPSTR()\n\n\n          ELSE +\n\n\n            SET LEFTPART = &SUBSTR(1:&EVAL(&LEFTBND-1),&THISLINE)\n\n\n          SET MIDDLEPART = &SUBSTR(&LEFTBND:&EVAL+\n\n\n                           (&BNDSIZE+&LEFTBND-1),&TYPSTR(&THISLINE))\n\n\n             /*cg          (&BNDSIZE+&LEFTBND-1),&STR(&THISLINE))\n\n\n          IF &RIGHTBND = &LRECL THEN +\n\n\n            SET RIGHTPART = &TYPSTR()\n\n\n          ELSE +\n\n\n              SET RIGHTPART = &SUBSTR(&EVAL(&RIGHTBND+1):+\n\n\n                              &LRECL,&TYPSTR(&THISLINE))\n\n\n           /*cg               &LRECL,&STR(&THISLINE))\n\n\n\n\n\n          SET STRING  = &TYPSTR(&MIDDLEPART)\n\n\n          /*cg   SET STRING  = &STR(&MIDDLEPART)\n\n\n          SET FLDSIZE = &BNDSIZE\n\n\n          ISPEXEC VPUT (STRING,FLDSIZE) SHARED\n\n\n          CENTRE\n\n\n          ISPEXEC VGET (STRING) SHARED\n\n\n          SET CENTERPART = &TYPSTR(&STRING)\n\n\n          /*cg   SET CENTERPART = &STR(&STRING)\n\n\n          SET NEWLINE = &TYPSTR(&LEFTPART)&TYPSTR(&CENTERPART)&TYPSTR(&RIGHTPART\n)\n\n   /*cg   SET NEWLINE = &STR(&LEFTPART)&STR(&CENTERPART)&STR(&RIGHTPART)\n\n\n          /* REPLACE THE LINE WITH NEWLINE */\n\n\n          ISREDIT LINE &I = (NEWLINE)\n\n\n          SET I = &I+1\n\n\n        END\n\n\n        EXIT CODE(0)\n\n\n./ ADD NAME=CHART    0111-84129-85280-1432-00287-00241-00062-KK00150\n00010008PROC 0 DL(CHART.DATA) FL(CHART.FORMAT) IMPORT L NC D T K NLIB IPD +\n\n\n00011011  PCG  PRIVATE IL(CHART.IMPORT) PAIRED IPNP SS(USER.TSO.GDDM.SYMBOLS)\n\n\n00020000/* DL     SPECIFIES DATA LIBRARY                        */\n\n\n00030000/* FL     SPECIFIES FORMAT LIBRARY                      */\n\n\n00031000/* IL     SPECIFIES IMPORT LIBRARY                      */\n\n\n00040000/* IMPORT ALLOWS CHART TO READ DATA FROM EXTERNAL FILE  */\n\n\n00050000/* L      TURNS ON MSG LIST AND CONLIST                 */\n\n\n00060000/* NC     EXITS BEFORE CHART CALL, ALLOWS TESTING       */\n\n\n00070000/* D      DELETES LIBRARIES BEFORE TESTING ALLOCATION   */\n\n\n00080000/* T      USES TSO TEST TO CALL CHART OR IMPORT         */\n\n\n00090000/* K      USES ALTERNATE CHART FROM WDPSC.TSO.TESTLIB   */\n\n\n00100000/* NLIB   ALLOWS EXECUTION OF CHART WITHOUT LIBRARIES   */\n\n\n00110000/* IPD    USES DEFAULT IMPORT DATASET NAME W/O PROMPT   */\n\n\n00110100/* IPNP   USES GIVEN   IMPORT DATASET NAME W/O PROMPT   */\n\n\n00111000/* PRIVATE ALLOWS SHARING PREFIX BUT DIFFERENT LIBRARIES*/\n\n\n00120000CONTROL NOFLUSH END(ENDO) NOMSG\n\n\n00130000IF &L = L THEN CONTROL MSG LIST CONLIST\n\n\n00130100IF &SYSPREF = KX00150 THEN CONTROL MSG LIST CONLIST\n\n\n00130200   STACK\n\n\n00130300   CLOG '&SYSDATE &SYSTIME &SYSICMD' U($$$@150) S\n\n\n00131010IF &SYSPROC = TEST AND &SS EQ &STR(USER.TSO.GDDM.SYMBOLS) THEN +\n\n\n00131110   SET &SS = &STR(USER.TSO.GDDM.SYMBOLS)\n\n\n00131208IF &PRIVATE = PRIVATE AND &SYSPREF NE &SYSUID THEN DO\n\n\n00132000  IF &DL = CHART.DATA THEN SET &DL = &SYSUID..CHART.DATA\n\n\n00133000  IF &FL = CHART.FORMAT THEN SET &FL = &SYSUID..CHART.FORMAT\n\n\n00133100  IF &IL = CHART.IMPORT THEN SET &IL = &SYSUID..CHART.IMPORT\n\n\n00134000                                                ENDO\n\n\n00140000IF &D = D THEN DEL (&DL &FL)\n\n\n00150000FREE  ATTR(ADMAT)\n\n\n00160000ATTR ADMAT RECFM(F) LRECL(400) BLK(400)\n\n\n00170000\n\n\n00180000/*** ALLOCATE SYMBOL SETS IF NOT ALREADY ALLOCATED    ***/\n\n\n00190008IFALC FILE(ADMSYMBL) DSN('&SS')\n\n\n00200000IF &LASTCC NE 0 THEN DO\n\n\n00200100                     IFALC FILE(ADMSYMBL)\n\n\n00200200                     IF &LASTCC = 0 THEN FREE F(ADMSYMBL)\n\n\n00201008                     ALLOC F(ADMSYMBL) DSN('&SS')\n\n\n00202000                     ENDO\n\n\n00203000\n\n\n00204000/*** ALLOCATE GEN MAPLIB  IF NOT ALREADY ALLOCATED    ***/\n\n\n00205010IFALC FILE(ADMGGMAP) DSN('USER.TSO.GDDM.GENMAPS')\n\n\n00206000IF &LASTCC NE 0 THEN DO\n\n\n00207000                     IFALC FILE(ADMGGMAP)\n\n\n00208000                     IF &LASTCC = 0 THEN FREE F(ADMGGMAP)\n\n\n00209010                     ALLOC FI(ADMGGMAP) DSN('USER.TSO.GDDM.GENMAPS')\n\n\n00209100                     ENDO\n\n\n00210000\n\n\n00220000/*** CHECK LIBRARIES FOR PRIOR ALLOCATION             ***/\n\n\n00230000IF &NLIB EQ NLIB THEN GOTO CALLM              /* BYPASS LIB ALLOC   */\n\n\n00240000  IFALC FILE(ADMCDATA) DA(&DL)                /* CHECK: IF BOTH     */\n\n\n00250000  IF &LASTCC = 0 THEN DO                      /*  LIBRARIES HAVE    */\n\n\n00260000       IFALC FILE(ADMCFORM) DA(&FL)           /*  ALREADY BEEN      */\n\n\n00270000       IF &LASTCC =  0 THEN GOTO CALLM        /*  ALLOCATED,        */\n\n\n00280000                      ENDO                    /*  BYPASS ALLOCATION */\n\n\n00290000FREE F(ADMCDATA,ADMCFORM)\n\n\n00300000\n\n\n00310000DATASTAT &DL                                  /* CHECK: DO REQUESTD */\n\n\n00320000 SET DLF = &LASTCC                            /*  LIBRARIES ALREADY */\n\n\n00330000DATASTAT &FL                                  /*  EXIST?            */\n\n\n00340000 SET FLF = &LASTCC\n\n\n00350000IF &FLF = 0 AND &DLF = 0 THEN GOTO NORMAL     /* IF OKAY FOR CHART  */\n\n\n00360000                                              /*  USE, CALL CHART   */\n\n\n00370000IF &DLF NE 4 AND &DLF NE 0 THEN DO\n\n\n00380000      WRITE ERROR WITH DATA LIBRARY: DATASTAT CODE &DLF\n\n\n00390000      WRITE PLEASE CONTACT YOUR CHART CONSULTANT FOR HELP.\n\n\n00400000      EXIT                                    /* IF DATA LIB THERE, */\n\n\n00410000                                ENDO          /*  BUT NOT OK, EXIT  */\n\n\n00420000IF &FLF NE 4 AND &FLF NE 0 THEN DO\n\n\n00430000      WRITE ERROR WITH FORMAT LIBRARY: DATASTAT CODE &FLF\n\n\n00440000      WRITE PLEASE CONTACT YOUR CHART CONSULTANT FOR HELP.\n\n\n00450000      EXIT                                    /* IF FRMT LIB THERE, */\n\n\n00460000                                ENDO          /*  BUT NOT OK, EXIT  */\n\n\n00460100\n\n\n00460200/*** DO EXTRA CHECKING FOR DSNS THE USER SPECIFIED:   ***/\n\n\n00460401IF &DLF = 4  AND &DL NE CHART.DATA  THEN +\n\n\n00460600    DO\n\n\n00460700    DATASTAT '&DL'\n\n\n00460800    IF &LASTCC = 0 THEN DO\n\n\n00460900       SET &DL = &STR('&DL')\n\n\n00461000       SET &DLF = 0\n\n\n00461100                        ENDO\n\n\n00461200    ENDO\n\n\n00461300\n\n\n00461401IF &FLF = 4  AND &FL NE CHART.FORMAT THEN +\n\n\n00461600    DO\n\n\n00461700    DATASTAT '&FL'\n\n\n00461800    IF &LASTCC = 0 THEN DO\n\n\n00461900       SET &FL = &STR('&FL')\n\n\n00462000       SET &FLF = 0\n\n\n00462100                        ENDO\n\n\n00462200    ENDO\n\n\n00462300\n\n\n00462400IF &FLF = 0 AND &DLF = 0 THEN GOTO NORMAL     /* IF OKAY FOR CHART  */\n\n\n00462500                                              /*  USE, CALL CHART   */\n\n\n00470000KOMM CLEAR RESET\n\n\n00480000\n\n\n00490000/*** REQUEST VOLUME FOR LIBRARIES THAT DO NOT EXIST   ***/\n\n\n00500000GVOLOOP: +\n\n\n00510000IF &DLF = 4 AND &FLF = 4 THEN DO\n\n\n00520000            WRITE ***  YOUR CHART LIBRARIES DO NOT EXIST.  ***\n\n\n00530000            WRITE TO ALLOCATE THEM, ENTER ONE OF THE FOLLOWING:\n\n\n00540000                              ENDO\n\n\n00550000IF &DLF = 0 AND &FLF = 4 THEN DO\n\n\n00560000            WRITE ***  YOUR FORMAT LIBRARY DOES NOT EXIST.  ***\n\n\n00570000            WRITE TO ALLOCATE IT, ENTER ONE OF THE FOLLOWING:\n\n\n00580000                              ENDO\n\n\n00590000IF &DLF = 4 AND &FLF = 0 THEN DO\n\n\n00600000            WRITE ***  YOUR DATA LIBRARY DOES NOT EXIST.  ***\n\n\n00610000            WRITE TO ALLOCATE IT, ENTER ONE OF THE FOLLOWING:\n\n\n00620000                              ENDO\n\n\n00630000\n\n\n00640000            WRITE    P - TO ALLOCATE AND KEEP INDEFINITELY.\n\n\n00650000            WRITE    T - TO ALLOCATE AND KEEP FOR 3 DAYS.\n\n\n00660000            WRITE YOU MAY ALSO ENTER A SPECIFIC VOLUME IF YOU WISH.\n\n\n00670000             READ VOLP\n\n\n00680003             IF &VOLP = P THEN DO\n\n\n00681003                               SET VOL = TSOVOL\n\n\n00682003                               SET DEVTYP = SYSDA\n\n\n00683003                               GOTO NORMAL\n\n\n00684003                               ENDO\n\n\n00690000                          ELSE +\n\n\n00700004             IF &VOLP = T THEN DO\n\n\n00702004                               %DEFVOL\n\n\n00702104                               SET VOL = &LASTCC\n\n\n00703004                               ENDO\n\n\n00710000                          ELSE SET VOL = &VOLP\n\n\n00720000      DEVTYPE VOL(&VOL)\n\n\n00730000      IF &LASTCC NE 0 THEN DO\n\n\n00740000              WRITE '&VOLP' IS AN INVALID RESPONSE - PLEASE TRY AGAIN.\n\n\n00750000              WRITE\n\n\n00760000              GOTO GVOLOOP\n\n\n00770000                           ENDO\n\n\n00780000\n\n\n00790000/*** ALLOCATE LIBRARIES THAT DO NOT EXIST             ***/\n\n\n00800000NORMAL: +\n\n\n00810000IF &DLF = 4 THEN DO\n\n\n00820000      ALLOC F(ADMCDATA) DA(&DL) SP(3,3) TRACKS BLKSIZE(400) +\n\n\n00830000            DIR(10) UNIT(&DEVTYP) VOL(&VOL) USING(ADMAT)\n\n\n00840000      IF &LASTCC = 0 THEN +\n\n\n00850000                   WRITE DATA LIBRARY &SYSPREF..&DL HAS BEEN ALLOCATED.\n\n\n00860000                     ELSE DO\n\n\n00870000                          WRITE ERROR CODE &LASTCC OCCURED\n\n\n00880000                          WRITE IN ALLOCATION OF &SYSPREF..&DL\n\n\n00890000                          WRITE PLEASE CONTACT YOUR CHART CONSULTANT.\n\n\n00900000                          EXIT\n\n\n00910000                          ENDO\n\n\n00920000                 ENDO\n\n\n00930000             ELSE ALLOC F(ADMCDATA) DA(&DL)\n\n\n00940000IF &FLF = 4 THEN DO\n\n\n00950000      ALLOC F(ADMCFORM) DA(&FL) SP(3,3) TRACKS BLKSIZE(400) +\n\n\n00960000            DIR(10) UNIT(&DEVTYP) VOL(&VOL) USING(ADMAT)\n\n\n00970000      IF &LASTCC = 0 THEN +\n\n\n00980000                WRITE FORMAT LIBRARY &SYSPREF..&FL HAS BEEN ALLOCATED.\n\n\n00990000                     ELSE DO\n\n\n01000000                          WRITE ERROR CODE &LASTCC OCCURED\n\n\n01010000                          WRITE IN ALLOCATION OF &SYSPREF..&FL\n\n\n01020000                          WRITE PLEASE CONTACT YOUR CHART CONSULTANT.\n\n\n01030000                          EXIT\n\n\n01040000                          ENDO\n\n\n01050000                 ENDO\n\n\n01060000             ELSE ALLOC F(ADMCFORM) DA(&FL)\n\n\n01070000IF &FLF = 4 OR &DLF = 4 THEN CALL 'WDPSC.SHARED.LOAD(NEWWAIT)' '2'\n\n\n01080000\n\n\n01100000CALLM: +\n\n\n01111000IF &PAIRED = PAIRED THEN DO\n\n\n01111100                         FILEINFO DSN(&DL) MEM(PAIRED)\n\n\n01111200                         SET FRC = &LASTCC\n\n\n01111300                         IF &FRC NE 0 AND &FRC NE 24 THEN DO\n\n\n01111400                            WRITE FILEINFO ERROR &FRC WITH &DL :\n\n\n01111500                            WRITE &OUTMSG\n\n\n01111600                            CALL 'WDPSC.SHARED.LOAD(NEWWAIT)' '2'\n\n\n01111700                            GOTO NOPAIR\n\n\n01111800                                           ENDO\n\n\n01111900                         IF &MEMFND = YES THEN GOTO NOPAIR\n\n\n01112000                         COPY 'WDPSC.TSO.CHART.DATA(PAIRED)' '&FULLDSN(P\nAIRED)' NONUM\n\n01112100                         ENDO\n\n\n01112200\n\n\n01113000/*** CALL IMPORT VERSION OF CHART IF REQUESTED        ***/\n\n\n01114000NOPAIR: +\n\n\n01120000IF &IPD = IPD THEN DO\n\n\n01130000                    IFALC F(DATA)\n\n\n01140000                    IF &LASTCC = 0 THEN GOTO AFTALLOC\n\n\n01150000                    SET &SYSDVAL = &STR(&IL)\n\n\n01160000                    GOTO ALLOCIMP\n\n\n01170000                   ENDO\n\n\n01170100\n\n\n01170200 SET &SYSDVAL = &STR(&IL)\n\n\n01170300 IF &IL NE CHART.IMPORT AND &IL NE &SYSUID..CHART.IMPORT THEN +\n\n\n01170400       GOTO ALLOCIMP\n\n\n01170500 IF &IPNP = IPNP THEN GOTO ALLOCIMP\n\n\n01170600\n\n\n01171000IF &IMPORT EQ IMPORT THEN DO\n\n\n01174000\n\n\n01180000 ILNP: WRITE\n\n\n01190000       WRITE ENTER NAME OF IMPORT DATA LIBRARY:\n\n\n01200000       WRITE (JUST PRESS ENTER TO USE &SYSPREF..&IL)\n\n\n01210000       READ\n\n\n01220000       IF &SYSDVAL = &STR() THEN SET &SYSDVAL = &STR(&IL)\n\n\n01220100       IF &SYSDVAL = &STR(TSO) THEN EXIT\n\n\n01220200       IF &SYSDVAL = &STR(BYPASS) THEN GOTO NOIMPORT\n\n\n01221000                          ENDO\n\n\n01222000                     ELSE GOTO NOIMPORT\n\n\n01223000\n\n\n01230000ALLOCIMP: +\n\n\n01280000       DATASTAT &SYSDVAL\n\n\n01280100       SET ILF = &LASTCC\n\n\n01280200       IF &ILF NE 0 THEN DO\n\n\n01280300         IF &ILF = 4 AND &SYSDVAL NE CHART.IMPORT +\n\n\n01280400                     AND &SYSDVAL NE &SYSUID..CHART.IMPORT THEN +\n\n\n01280500            DO\n\n\n01280600            DATASTAT '&SYSDVAL'\n\n\n01280700            IF &LASTCC = 0 THEN DO\n\n\n01280800                                SET &SYSDVAL = '&SYSDVAL'\n\n\n01280900                                GOTO OKAI\n\n\n01281000                                ENDO\n\n\n01281100            ENDO\n\n\n01281200         IF &ILF > 3 THEN WRITE IMPORT LIBRARY NOT FOUND.\n\n\n01282000                     ELSE WRITE IMPORT LIBRARY IS WRONG TYPE DATASET.\n\n\n01282500                 WRITE ENTER BYPASS TO GO DIRECTLY TO CHART,\n\n\n01282600                 WRITE OR ENTER TSO TO RETURN TO TSO, OR\n\n\n01282800                 GOTO ILNP\n\n\n01284000                         ENDO\n\n\n01290000OKAI:  IFALC F(DATA) DSN(&SYSDVAL)\n\n\n01290100       IF &LASTCC = 0 THEN GOTO AFTALLOC\n\n\n01290200       IFALC F(DATA)\n\n\n01290300       IF &LASTCC = 0 THEN FREE F(DATA)\n\n\n01291000       ALLOC F(DATA) DSN(&SYSDVAL)\n\n\n01300000\n\n\n01320000AFTALLOC: +\n\n\n01321000       IF &NC EQ NC THEN EXIT\n\n\n01330000       IF &K = K THEN DO\n\n\n01340000               IF &T = T THEN TEST 'WDPSC.TSO.TESTLIB(ADMUSP6)'\n\n\n01350000                         ELSE CALL 'WDPSC.TSO.TESTLIB(ADMUSP6)'\n\n\n01360000                      EXIT\n\n\n01370000                      ENDO\n\n\n01380000       IF &T = T THEN TEST 'WDPSC.GDDM.GDDMLOAD(ADMUSP6)'\n\n\n01390000                 ELSE CALL 'WDPSC.GDDM.GDDMLOAD(ADMUSP6)'\n\n\n01400000       EXIT\n\n\n01410000\n\n\n01420000NOIMPORT: IF &NC EQ NC THEN EXIT\n\n\n01430000\n\n\n01440000/*** CALL NORMAL VERSION OF CHART                     ***/\n\n\n01441009IF &K = K OR &SYSPROC = TEST THEN DO\n\n\n01441108     IF &PCG = PCG THEN +\n\n\n01441208                    CALL 'WDPSC.GDDMR4.GDDMLOAD(ADMUCDSO)'   +\n\n\n01441308                               ' * * 1 1 * (21 1) ()'\n\n\n01441408                   ELSE +\n\n\n01442007     IF &T = T THEN TEST 'WDPSC.GDDMR4.GDDMLOAD(ADMCHART)'\n\n\n01443007               ELSE CALL 'WDPSC.GDDMR4.GDDMLOAD(ADMCHART)'\n\n\n01444006               GOTO CX\n\n\n01445000                                  ENDO\n\n\n01446010IF &PCG = PCG THEN +\n\n\n01447010               CALL 'WDPSC.GDDM.GDDMLOAD(ADMUCDSO)'   +\n\n\n01448010                          ' * * 1 1 * (21 1) ()'\n\n\n01449010              ELSE +\n\n\n01470000IF &T = T THEN TEST 'WDPSC.GDDM.GDDMLOAD(ADMCHART)'\n\n\n01480000          ELSE CALL 'WDPSC.GDDM.GDDMLOAD(ADMCHART)'\n\n\n01481005\n\n\n01490006CX:   CONTROL NOMSG NOFLUSH\n\n\n01500005      FREE F(INPDS,OUTMEMS)\n\n\n01510005      CONTROL MSG\n\n\n01520005      ALLOC F(INPDS) DA(&DL) SHR\n\n\n01530005      ALLOC F(OUTMEMS) DUMMY\n\n\n01540005      CALL 'WDPSC.SHARED.LOAD(LISTMEMS)'\n\n\n01550005      SET &RC = &LASTCC\n\n\n01560005      IF &RC EQ 8 THEN +\n\n\n01561005          DO\n\n\n01570005          WRITE DATASET &DL IS EMPTY\n\n\n01580005          WRITE ENTER KEEP TO KEEP IT; PRESS ENTER TO DELETE IT.\n\n\n01590005          READ\n\n\n01600005          IF &SYSDVAL NE KEEP THEN DEL &DL\n\n\n01610005          ENDO\n\n\n01620005\n\n\n01630005      CONTROL NOMSG NOFLUSH\n\n\n01640005      FREE F(INPDS,OUTMEMS)\n\n\n01650005      CONTROL MSG\n\n\n01660005      ALLOC F(INPDS) DA(&FL) SHR\n\n\n01670005      ALLOC F(OUTMEMS) DUMMY\n\n\n01680005      CALL 'WDPSC.SHARED.LOAD(LISTMEMS)'\n\n\n01690005      SET &RC = &LASTCC\n\n\n01700005      IF &RC EQ 8 THEN +\n\n\n01710005          DO\n\n\n01720005          WRITE DATASET &FL IS EMPTY\n\n\n01730005          WRITE ENTER KEEP TO KEEP IT; PRESS ENTER TO DELETE IT.\n\n\n01740005          READ\n\n\n01750006          IF &SYSDVAL NE KEEP THEN DEL &FL\n\n\n01760005          ENDO\n\n\n./ ADD NAME=CHDSCB   0103-77333-84009-1013-00030-00030-00009-KK00150\n00010003PROC 1 DSN RECFM() LRECL() BL() DSORG() REC() LR() BLK() BLKSIZE() NOLIS\nT\n\n00020003IF &NOLIST = THEN LISTD &DSN\n\n\n00030001CONTROL NOMSG END(ENDO)\n\n\n00040000FREE F(REL) ATTR(KKKC)\n\n\n00050001CONTROL MSG\n\n\n00060000IF &REC.K NE K THEN SET &RECFM = &REC\n\n\n00070000IF &LR.K NE K THEN SET &LRECL = &LR\n\n\n00080000IF &BLK.K NE K THEN SET &BL = &BLK\n\n\n00090000IF &BLKSIZE.K NE K THEN SET &BL = &BLKSIZE\n\n\n00101003SET RF1 = &STR()\n\n\n00102003SET RF2 = &STR()\n\n\n00103003SET RF3 = &STR()\n\n\n00110000SET &N = 1\n\n\n00120000IF &RECFM.K = K THEN GOTO SKIPARS\n\n\n00130000RFPARS: -\n\n\n00140000IF &LENGTH(&RECFM.) GT 1 THEN DO\n\n\n00150000                      SET &RF&N = &SUBSTR(1,&RECFM.)\n\n\n00160000                      SET &RECFM = &SUBSTR(2:&LENGTH(&RECFM.),&RECFM.)\n\n\n00170000                      SET &N = &N + 1\n\n\n00180000                      GOTO RFPARS\n\n\n00190000                              ENDO\n\n\n00200000SET &RECFM = RECFM(&RF1 &RF2 &RF3 &RECFM.)\n\n\n00210000SKIPARS: -\n\n\n00220000IF &LRECL.K NE K THEN SET &LRECL = LRECL(&LRECL.)\n\n\n00230000IF &BL.K    NE K THEN SET &BL    = BL(&BL.)\n\n\n00240000IF &DSORG.K NE K THEN SET &DSORG = DSORG(&DSORG.)\n\n\n00250000ATTR KKKC &RECFM &LRECL &BL &DSORG\n\n\n00260000ALLOC F(REL) DA(&DSN.) MOD KEEP US(KKKC)\n\n\n00270002CALL 'WDPSC.SYSLIBRY(RELSEQ)'\n\n\n00280003IF &NOLIST = THEN LISTD &DSN\n\n\n./ ADD NAME=CLERSCRN 0105-80329-85113-1608-00003-00008-00000-JS02150\n            CALL 'WDPSC.SHARED.LOAD(TERMTYPE)'\n\n\n            IF &LASTCC NE 0 THEN KOMM RESET CLEAR\n\n\n                ELSE WRITE\n\n\n./ ADD NAME=CLIB     0101-84242-85261-1059-00077-00074-00000-JS02150\n                PROC 1 DSN  XLIB(NONE) PRINT()\n\n\n                CONTROL NOMSG NOFLUSH END(ENDO)\n\n\n\n\n\n                IF &PRINT = NO THEN SET &PRTOPT = &STR(NO)\n\n\n                     ELSE SET &PRTOPT = &STR(YES)\n\n\n\n\n\n                IF &STR(&XLIB) NE &STR(NONE) THEN %CLIB &XLIB PRINT(&PRTOPT)\n\n\n\n\n\n                ERROR OFF\n\n\n\n\n\n                FILEINFO DSN(&STR(&DSN))\n\n\n                SET &RC = &LASTCC\n\n\n\n\n\n                IF &RC EQ 96 THEN DO\n\n\n                    WRITE\n\n\n                    WRITE ERROR ===> INVALID SYNTAX OF DSNAME\n\n\n                    GOTO ENDIT\n\n\n                    ENDO\n\n\n\n\n\n                IF &RC NE 0 THEN DO\n\n\n                    WRITE\n\n\n                    WRITE ERROR ===> &OUTMSG\n\n\n                    GOTO ENDIT\n\n\n                    ENDO\n\n\n\n\n\n                IF &DSORG NE PO THEN DO\n\n\n                    WRITE\n\n\n                    WRITE ERROR ===> DATASET TO BE CONCATENATED IS NOT\n\n\n                    WRITE            PARTITIONED DATASET\n\n\n                    GOTO ENDIT\n\n\n                    ENDO\n\n\n\n\n\n                IF &MEMCNTL EQ YES THEN DO\n\n\n                    WRITE\n\n\n                    WRITE ERROR ===> DO NOT PROVIDE MEMBER NAME\n\n\n                    GOTO ENDIT\n\n\n                    ENDO\n\n\n\n\n\n                IF &RECFM NE V THEN DO\n\n\n                    WRITE\n\n\n                    WRITE ERROR ===> &FULLDSN MUST CONTAIN\n\n\n                    WRITE            VARIABLE LENGTH RECORDS\n\n\n                    GOTO ENDIT\n\n\n                    ENDO\n\n\n\n\n\n                WHATDSN DDNAME(SYSPROC)\n\n\n                SET &RC = &LASTCC\n\n\n\n\n\n                IF &RC NE 0 THEN GOTO CONCATM\n\n\n\n\n\n                IF &FULLDSN NE &DSNAME THEN GOTO CONCATM\n\n\n\n\n\n                IF &PRINT = NO THEN GOTO ENDIT\n\n\n\n\n\n                WRITE\n\n\n                WRITE SUCCESSFUL COMPLETION\n\n\n                WRITE        (BUT NO ACTION WAS TAKEN SINCE THE GIVEN\n\n\n                WRITE         DATASET WAS ALREADY AT THE TOP OF THE STACK)\n\n\n                GOTO ENDIT\n\n\n\n\n\n         CONCATM: CONCATEM ACTCODE(A) DDNAME(SYSPROC) DSNAME('&FULLDSN')\n\n\n                SET &RC = &LASTCC\n\n\n\n\n\n                IF &PRINT = NO THEN GOTO ENDIT\n\n\n\n\n\n                WRITE\n\n\n                WRITE &OUTMSG\n\n\n                WRITE        (RETURN CODE = &RC)\n\n\n\n\n\n         ENDIT: IFALC FILE(SYSPROC)\n\n\n                SET &RC = &LASTCC\n\n\n\n\n\n                IF &RC = 0 THEN EXIT\n\n\n\n\n\n                ALLOC F(SYSPROC) DA('WDPSC.MASTER.CLIST' 'USER.CLIST') SHR\n\n\n\n\n\n                EXIT\n\n\n./ ADD NAME=CMDOUT   0112-82348-84153-1711-00047-00005-00000-KK00150\n        PROC 0 DDN(CMDOUT) FREE(NO) L PRC MOD USE(NONE) FORCE CYL\n\n\n        CONTROL NOMSG NOFLUSH END(ENDO)\n\n\n        IF &L = L THEN CONTROL MSG LIST CONLIST\n\n\n        IF &FREE NE NO THEN DO\n\n\n                            FREE F(CMD&FREE)\n\n\n                            EXIT\n\n\n                            ENDO\n\n\n        IF &CYL = THEN SET CYL = TRACK\n\n\n        SET &OUT = 1\n\n\n        LOOP: IFALC F(CMD&OUT)\n\n\n              IF &LASTCC NE 0 THEN GOTO GOTFN\n\n\n        RTRY: SET &OUT = &OUT + 1\n\n\n              GOTO LOOP\n\n\n        GOTFN: ALLOC F(CMD&OUT) DUMMY\n\n\n        IF &DDN = CMDOUT THEN SET &DDN = &DDN&OUT\n\n\n        IF &SYSPREF = &SYSUID OR &SYSUID = &STR() +\n\n\n                              THEN SET &CMDDSN = COMMAND.OUTPUT&OUT\n\n\n                              ELSE SET &CMDDSN = &SYSUID..COMMAND.OUTPUT&OUT\n\n\n        IF &USE = NONE THEN SET &U = &STR()\n\n\n                       ELSE SET &U = &STR(US(&USE))\n\n\n        IF &FORCE = FORCE THEN GOTO FREEIT\n\n\n        SET FRC = 0\n\n\n        IFALC F(&DDN) DA(&CMDDSN)\n\n\n        IF &LASTCC = 0 THEN +\n\n\n                   IF &U = THEN GOTO GOTCMDF\n\n\n                           ELSE GOTO SETATTR\n\n\n        FREEIT: +\n\n\n        IFALC F(&DDN)\n\n\n        IF &LASTCC = 0 THEN FREE F(&DDN)\n\n\n        FILEINFO DSN(&CMDDSN)\n\n\n        SET &FRC = &LASTCC\n\n\n        SETATTR: ERROR EXIT CODE(99)\n\n\n        IF &FRC = 0 THEN ALLOC F(&DDN) DSN(&CMDDSN) &U\n\n\n                    ELSE +\n\n\n        IF &FRC = 4 THEN ALLOC F(&DDN) DSN(&CMDDSN) NEW CAT &CYL  SP(1,1) &U\n\n\n                    ELSE DO\n\n\n                         WRITE ERROR IN CLIST CMDOUT ALLOCATING FOLLOWING DSN:\n\n\n                         WRITE &CMDDSN : &OUTMSG\n\n\n                         GOTO RTRY\n\n\n                         ENDO\n\n\n        GOTCMDF: ERROR OFF\n\n\n                 IF &PRC = PRC THEN WRITE RC IS &OUT\n\n\n                 IF &MOD = MOD THEN DO\n\n\n                                    FREE F(&DDN.M)\n\n\n                                    ALLOC F(&DDN.M) DSN(&CMDDSN) MOD &U\n\n\n                                    ENDO\n\n\n        EXCO:    EXIT CODE(&OUT)\n\n\n./ ADD NAME=COM                                    17OCT89 12.47.57\nISREDIT MACRO\n\n\n/*********************************************************************/\n\n\n/*  THIS ISPF/PDF EDIT MACRO DISPLAYS ONLY COMMENT LINES, THAT IS    */\n\n\n/*  LINES THAT CONTAIN A / FOLLOWED BY AN *.                         */\n\n\n/*                                                                   */\n\n\n/*  TO RUN:                                                          */\n\n\n/*     ENTER COMMENTS ON THE COMMAND LINE                            */\n\n\n/*********************************************************************/\n\n\n\n\n\n/* EXCLUDE ALL LINES */\n\n\nISREDIT EXCLUDE ALL\n\n\n\n\n\n/* FIND ALL COMMENT LINES\n\n\nISREDIT FIND ALL '/*'\n\n\n\n\n\nEXIT\n\n\n./ ADD NAME=CUT      0136-86247-86254-1050-00175-00170-00000-GS00150\n        /*CLIST****************************************************************/\n\n\n        /*   ISPF/PDF EDIT MACRO TO WRITE LINES FROM A FILE TO THE USER       */\n\n\n        /*   PROFILE POOL FOR LATER INCLUSION BY THE PASTE MACRO.             */\n\n\n        /*                                                                    */\n\n\n        /*   A TUTORIAL IS AVAILABLE BY PRESSING THE PF(1) KEY.               */\n\n\n        /**********************************************************************/\n\n\n        ISREDIT MACRO (PARM1) NOPROCESS\n\n\n        CONTROL NOFLUSH NOMSG\n\n\n        /*CONTROL LIST CONLIST SYMLIST\n\n\n        SET &MSGFLAG =      /* MESSAGE FLAG INDICATES NO PREVIOUS LINES CUT   */\n\n\n        SET PARM = &STR(T)  /* PARAMETER FOR STRIPPING TRAILING BLANKS        */\n\n\n\n\n\n        /* CHECK FOR INVALID PARAMETERS                                       */\n\n\n        IF &PARM1 \u00ac= &STR( ) AND &PARM1 \u00ac= &STR(R) +\n\n\n           AND &PARM1 \u00ac= &STR(REPLACE) THEN +\n\n\n          DO\n\n\n            IF &DATATYPE(&PARM1) = NUM AND &PARM1 > 0 THEN +\n\n\n              DO\n\n\n                /* SET NEW LIMIT FOR MAXIMUM NUMBER OF LINES CUT TO PROFILE   */\n\n\n                SET CUTLIMIT = &PARM1\n\n\n                ISPEXEC VPUT (CUTLIMIT) PROFILE\n\n\n              END\n\n\n            ELSE +\n\n\n              DO\n\n\n                /* AN INVALID CUT PARAMETER HAS BEEN PASSED                   */\n\n\n                SET ZERRSM = &STR(INVALID PARAMETER!!!)\n\n\n                SET MSG1 = &STR(USE \"R\" OR \"REPLACE\" TO REPLACE PREVIOUS)\n\n\n                SET MSG2 = &STR( LINES CUT, NUMBER > 0 TO SET CUT LIMIT)\n\n\n                SET ZERRLM = &STR(&MSG1&MSG2)\n\n\n                SET ZERRALRM = YES\n\n\n                SET ZERRHM = CUTHELP\n\n\n                ISPEXEC SETMSG MSG(ISRZ002)\n\n\n                EXIT CODE(12)\n\n\n              END\n\n\n          END\n\n\n\n\n\n        /* PROCESS LINE COMMANDS, CHECK IF C OR M WAS SPECIFIED               */\n\n\n        ISREDIT PROCESS RANGE C M\n\n\n        SET RC = &LASTCC\n\n\n        IF &RC >= 16 THEN +\n\n\n          EXIT CODE(12) /* LINE COMMAND CONFLICT - EDIT WILL CREATE MESSAGE   */\n\n\n        ELSE IF &RC >= 4 THEN +\n\n\n          DO /* MISSING C OR M LINE COMMAND                                   */\n\n\n            SET ZERRSM = &STR(MISSING LINE COMMAND!!!)\n\n\n            SET MSG1 = &STR(CUT REQUIRES A \"C\", \"M\", )\n\n\n            SET MSG2 = &STR(\"CC\" OR \"MM\" LINE COMMAND...)\n\n\n            SET ZERRLM = &STR(&MSG1&MSG2)\n\n\n            SET ZERRALRM = YES\n\n\n            SET ZERRHM = CUTHELP\n\n\n            ISPEXEC SETMSG MSG(ISRZ002)\n\n\n            EXIT CODE(12)\n\n\n          END\n\n\n\n\n\n        ISREDIT (CMD) = RANGE_CMD              /* GET LINE COMMAND            */\n\n\n        ISREDIT (FSTLINE) = LINENUM .ZFRANGE   /* GET FIRST LINE IN RANGE     */\n\n\n        ISREDIT (LSTLINE) = LINENUM .ZLRANGE   /* GET LAST LINE IN RANGE      */\n\n\n        SET LINESTOCUT = &EVAL(&LSTLINE-&FSTLINE+1)\n\n\n\n\n\n        /* GET THE NUMBER OF LINES THAT HAVE BEEN CUT BUT NOT PASTED,         */\n\n\n        /* SET TO A VALUE OF 0 AND SET FLAG IF NONE EXIST                     */\n\n\n        ISPEXEC VGET (LINESCUT) PROFILE\n\n\n        IF &LASTCC \u00ac= 0 THEN +\n\n\n          DO\n\n\n            SET MSGFLAG = 1\n\n\n            SET &LINESCUT = 0\n\n\n          END\n\n\n\n\n\n        /* GET THE MAXIMUM NUMBER OF LINES TO BE STORED IN THE PROFILE,       */\n\n\n        /* INITIALIZE TO 500 IF FIRST TIME.                                   */\n\n\n        ISPEXEC VGET (CUTLIMIT) PROFILE\n\n\n        IF &LASTCC \u00ac= 0 THEN +\n\n\n          DO\n\n\n            SET CUTLIMIT = 500\n\n\n            ISPEXEC VPUT (CUTLIMIT) PROFILE\n\n\n          END\n\n\n\n\n\n        /* STORE DATA WIDTH OF LARGER OF LINES CUT AND LINES TO BE CUT        */\n\n\n        ISREDIT (NEWLRECL) = DATA_WIDTH\n\n\n        ISPEXEC VGET (CUTLRECL) PROFILE\n\n\n        IF &NEWLRECL > &CUTLRECL THEN +\n\n\n          DO\n\n\n            SET CUTLRECL = &NEWLRECL\n\n\n            ISPEXEC VPUT (CUTLRECL) PROFILE\n\n\n          END\n\n\n\n\n\n        IF &PARM1 = &STR(R) OR &PARM1 = &STR(REPLACE) THEN +\n\n\n          DO\n\n\n            IF &LINESTOCUT < &LINESCUT THEN +\n\n\n              DO\n\n\n                /* DELETE VARIABLES THAT WILL NOT BE OVERWRITTEN              */\n\n\n                SET LN = &LINESTOCUT+1\n\n\n                DO WHILE &LN <= &LINESCUT\n\n\n                  SET CUTLN&LN = &STR()\n\n\n                  ISPEXEC VPUT (CUTLN&LN) PROFILE\n\n\n                  SET LN = &LN+1\n\n\n                END\n\n\n              END\n\n\n            SET MSGFLAG  = 1\n\n\n            SET LINESCUT = 0\n\n\n          END\n\n\n\n\n\n        /* CHECK TO SEE IF THE LIMIT WILL BE EXCEEDED                         */\n\n\n        /* BY STORING THE LINES INTO THE PROFILE.                             */\n\n\n        SET TOTAL = &LINESCUT + &LINESTOCUT\n\n\n        IF &TOTAL > &CUTLIMIT THEN +\n\n\n          DO\n\n\n            SET ZERRSM = &STR(CUT LIMIT EXCEEDED!!!)\n\n\n            SET MSG1 = &STR(CUT LIMIT SET AT &CUTLIMIT, REDUCE RANGE )\n\n\n            SET MSG2 = &STR(OF LINES TO CUT OR CHANGE CUT LIMIT...)\n\n\n            SET ZERRLM = &STR(&MSG1&MSG2)\n\n\n            SET ZERRALRM = YES\n\n\n            SET ZERRHM = CUTHELP\n\n\n            ISPEXEC SETMSG MSG(ISRZ002)\n\n\n            EXIT CODE(12)\n\n\n          END\n\n\n\n\n\n        /* CUT THE LINES AND PLACE IN PROFILE                                 */\n\n\n        SET LN = &LINESCUT+1\n\n\n        SET I  = &FSTLINE\n\n\n        DO WHILE &I <= &LSTLINE\n\n\n          ISREDIT (CUTLN&LN) = LINE &I\n\n\n        /*ISPEXEC VPUT (STRING,PARM) SHARED\n\n\n        /*STRIP\n\n\n        /*ISPEXEC VGET (STRING) SHARED\n\n\n        /*SET CUTLN&LN = &STR(&STRING)\n\n\n          ISPEXEC VPUT (CUTLN&LN) PROFILE\n\n\n          SET &LN = &LN+1\n\n\n          SET &I  = &I+1\n\n\n        END\n\n\n\n\n\n        /* PUT THE NUMBER OF LINES CUT INTO THE PROFILE FOR USE BY PASTE      */\n\n\n        /* SAVE THE NUMBER OF LINES THAT WERE PREVIOUSLY CUT                  */\n\n\n        SET PREVCUT  = &LINESCUT\n\n\n        SET LINESCUT = &LN-1\n\n\n        ISPEXEC VPUT (LINESCUT) PROFILE\n\n\n\n\n\n        /* DISPLAY APPROPRIATE MESSAGE FOR LINES CUT                          */\n\n\n        IF &CMD = &STR(M) THEN +\n\n\n          DO\n\n\n            /* DELETE LINES THAT WERE CUT IF LINE COMMAND OF M                */\n\n\n            ISREDIT DELETE &FSTLINE &LSTLINE\n\n\n            IF &MSGFLAG \u00ac=  THEN +\n\n\n              DO\n\n\n                SET ZEDSMSG = &STR(&LINESTOCUT LINES CUT && DELETED)\n\n\n                SET MSG1 = &STR(&LINESTOCUT LINES WERE CUT AND )\n\n\n                SET MSG2 = &STR(DELETED FROM THE CURRENT FILE...)\n\n\n                SET ZEDLMSG = &STR(&MSG1&MSG2)\n\n\n              END\n\n\n            ELSE +\n\n\n              DO\n\n\n                SET ZEDSMSG = &STR(&LINESTOCUT LINES CUT && DELETED)\n\n\n                SET MSG1 = &STR(A TOTAL OF &LINESCUT LINES HAVE BEEN CUT, )\n\n\n                SET MSG2 = &STR(THE LAST &LINESTOCUT HAVE BEEN DELETED...)\n\n\n                SET ZEDLMSG = &STR(&MSG1&MSG2)\n\n\n              END\n\n\n          END\n\n\n        ELSE +\n\n\n          DO\n\n\n            IF &MSGFLAG \u00ac=  THEN +\n\n\n              DO\n\n\n                SET ZEDSMSG = &STR(&LINESTOCUT LINES CUT)\n\n\n                SET MSG1 = &STR(&LINESTOCUT LINES WERE )\n\n\n                SET MSG2 = &STR(CUT FROM THE CURRENT FILE...)\n\n\n                SET ZEDLMSG = &STR(&MSG1&MSG2)\n\n\n              END\n\n\n            ELSE +\n\n\n              DO\n\n\n                SET ZEDSMSG = &STR(&LINESCUT LINES CUT IN ALL)\n\n\n                SET MSG1 = &STR(&LINESTOCUT LINES CUT PLUS &PREVCUT )\n\n\n                SET MSG2 = &STR(LINES PREVIOUSLY CUT TOTALS &LINESCUT....)\n\n\n                SET ZEDLMSG = &STR(&MSG1&MSG2)\n\n\n              END\n\n\n          END\n\n\n        ISPEXEC SETMSG MSG(ISRZ000)\n\n\n        EXIT\n\n\n./ ADD NAME=DECRYPT  0101-85289-85290-1240-00002-00002-00001-DS00150\n00010000ISREDIT MACRO (KEY)\n\n\n00020001ISREDIT !CRY DECRYPT,&KEY\n\n\n./ ADD NAME=DOCADD   0122-86161-88077-1238-00139-00063-00000-KK00155\n        PROC 1 DCNT OLDMEM(ZILCH) CCALL(DUMMY1)\n\n\n        CONTROL NOFLUSH END(ENDO) NOMSG\n\n\n        IF &SYSPREF = KX00150 THEN CONTROL MSG LIST CONLIST\n\n\n        ISPEXEC VGET (DOCSLVL1 DOCSLVL2 DOCSMEM DOCADD LIB SAMPDOC SAMPNDEX LVL1\n LVL2 DTYPE)\n\n        IF &LVL1 = &STR() THEN SET LVL1 = &DOCSLVL1\n\n\n        IF &LVL2 = &STR() THEN SET LVL2 = &DOCSLVL2\n\n\n        IF &LIB = &STR() THEN SET LIB = &DOCSMEM\n\n\n        IF &DTYPE = &STR() THEN SET DTYPE = DOC02\n\n\n        IF &DTYPE = DOC04 THEN SET CCALL = DOCISTAT\n\n\n        IF &SAMPDOC = &STR() THEN SET SAMPDOC = '&LVL1..&LVL2..MEMO(SAMPDOC)'\n\n\n        IF &SAMPNDEX = &STR() THEN SET SAMPNDEX = '&LVL1..&LVL2..INDEXES(SAMPNDE\nX)'\n\n        IF &DOCADD = &STR() THEN SET DOCADD = DOCADD\n\n\n        ISPEXEC CONTROL DISPLAY SAVE\n\n\n\n\n\n        ISPEXEC DISPLAY PANEL(&DOCADD&DCNT) CURSOR(DESCL1)\n\n\n        IF &LASTCC NE 0 THEN GOTO EXIT\n\n\n\n\n\n        RETRY: +\n\n\n        IF &DOCDSN = &STR() THEN SET DDSN = '&LVL1..&LVL2..&LIB'\n\n\n                            ELSE SET DDSN = &DOCDSN\n\n\n\n\n\n        IF &DOCDSN = &STR() THEN SET &W = MEMBER\n\n\n                            ELSE SET &W = DOCDSN\n\n\n\n\n\n        IF &MEMBER = &STR() THEN FILEINFO DSN(&DDSN)\n\n\n                            ELSE FILEINFO DSN(&DDSN) MEM(&MEMBER)\n\n\n        SET FRC = &LASTCC\n\n\n           IF &FRC NE 0 AND &FRC NE 24 THEN +\n\n\n             DO\n\n\n             SET GPML = &OUTMSG\n\n\n             ISPEXEC DISPLAY MSG(GPM001A) CURSOR(&W)\n\n\n             IF &LASTCC NE 0 THEN GOTO EXIT\n\n\n             GOTO RETRY\n\n\n             ENDO\n\n\n           IF &DSORG NE PS AND &DSORG NE PO THEN +\n\n\n             DO\n\n\n             SET GPML = NOT A GOOD DOCUMENT TYPE - CANCELED\n\n\n             ISPEXEC DISPLAY MSG(GPM001A) CURSOR(&W)\n\n\n             IF &LASTCC NE 0 THEN GOTO EXIT\n\n\n             GOTO RETRY\n\n\n             ENDO\n\n\n           IF &FRC = 0 AND &OLDMEM NE &MEMBER AND &MEMBER NE &STR() THEN +\n\n\n             DO\n\n\n             SET GPML = DOCUMENT ALREADY EXISTS. CHANGE NAME OR PRESS ENTER TO A\nDD IT.\n\n             SET OLDMEM = &MEMBER\n\n\n             ISPEXEC DISPLAY MSG(GPM001A) CURSOR(MEMBER)\n\n\n             IF &LASTCC NE 0 THEN GOTO EXIT\n\n\n             GOTO RETRY\n\n\n             ENDO\n\n\n           IF &DSORG = PO AND &MEMBER = &STR() AND &MEMCNTL = NO THEN +\n\n\n             DO\n\n\n             SET GPML = ENTER A MEMBER NAME FOR THE DOCUMENT.\n\n\n             SET OLDMEM = &MEMBER\n\n\n             ISPEXEC DISPLAY MSG(GPM001A) CURSOR(MEMBER)\n\n\n             IF &LASTCC NE 0 THEN GOTO EXIT\n\n\n             GOTO RETRY\n\n\n             ENDO\n\n\n\n\n\n        IF &DOCDSN NE &STR() THEN +\n\n\n           DO\n\n\n           SET CMD = &DTYPE\n\n\n           IF &DSORG = PO THEN +\n\n\n             DO\n\n\n             IF &MEMBER = &STR() AND &MEMCNTL = &STR(NO ) THEN +\n\n\n               DO\n\n\n               SET GPML = NO MEMBER WAS SPECIFIED - REQUEST CANCELED\n\n\n               ISPEXEC SETMSG MSG(GPM001)\n\n\n               GOTO EXIT\n\n\n               ENDO\n\n\n             IF &MEMCNTL = &STR(YES) THEN +\n\n\n               SET OPS = DUMMY DUMMY &FULLDSN\n\n\n             IF &MEMCNTL = &STR(NO ) THEN +\n\n\n               SET OPS = &FULLDSN &MEMBER &CCALL\n\n\n             ENDO\n\n\n           IF &DSORG = PS THEN +\n\n\n             DO\n\n\n             SET OPS = DUMMY DUMMY &FULLDSN\n\n\n             ENDO\n\n\n           ENDO\n\n\n\n\n\n        IF &DOCDSN = &STR() THEN +\n\n\n           DO\n\n\n           IF (&LVL1 = &DOCSLVL1 AND &LVL2 = &DOCSLVL2) OR +\n\n\n               &DTYPE = DOC04 THEN +\n\n\n             DO\n\n\n             IF &LIB = INDEXES THEN +\n\n\n                DO\n\n\n                SET CMD = DOC01\n\n\n                SET OPS = &MEMBER &LCNT DUMMY1\n\n\n                ENDO\n\n\n             ELSE +\n\n\n                DO\n\n\n                SET CMD = &DTYPE\n\n\n                IF &CMD = DOC02 THEN SET CMD = DOC03\n\n\n                IF &DSORG = PO THEN +\n\n\n                  SET OPS = &LIB &MEMBER &CCALL\n\n\n                ELSE SET OPS = DUMMY DUMMY &LIB\n\n\n                ENDO\n\n\n             ENDO\n\n\n           ELSE +\n\n\n             DO\n\n\n             SET CMD = &DTYPE\n\n\n             IF &DSORG = PO THEN +\n\n\n               SET OPS = &LVL1..&LVL2..&LIB &MEMBER &CCALL\n\n\n             ELSE SET OPS = DUMMY DUMMY &LVL1..&LVL2..&LIB\n\n\n             ENDO\n\n\n           ENDO\n\n\n\n\n\n        /* NOW EDIT THE INDEX MEMBER  */\n\n\n\n\n\n        ISPEXEC VPUT (CMD OPS DCNT) SHARED\n\n\n\n\n\n        ERROR DO\n\n\n              SET GPML = ERROR &LASTCC OCCURED IN INDEX EDIT\n\n\n              ISPEXEC SETMSG MSG(GPM001)\n\n\n              GOTO EXIT\n\n\n              ENDO\n\n\n\n\n\n        ISPEXEC EDIT DATASET('&DOCSLVL1..&DOCSLVL2..INDEXES(&DOCSMEM)') MACRO(DO\nCEDIT)\n\n\n\n\n        /* NOW EDIT THE NEW DOCUMENT  */\n\n\n\n\n\n          ERROR OFF\n\n\n          IF &FRC = 24 THEN +\n\n\n             DO\n\n\n             IF &DOCDSN = &STR() AND &LIB = INDEXES THEN +\n\n\n                  DO\n\n\n                  SET FADSN = &SAMPNDEX\n\n\n                  SET FACMD = DOCIINIT\n\n\n                  ENDO\n\n\n             ELSE SET FADSN = &SAMPDOC\n\n\n             ISPEXEC VPUT AUTOCOPY SHARED\n\n\n             ISPEXEC CONTROL NONDISPL ENTER\n\n\n             IF &MEMBER = THEN +\n\n\n                ISPEXEC EDIT DATASET('&FULLDSN') PANEL(DOCEDIT)\n\n\n                          ELSE +\n\n\n                ISPEXEC EDIT DATASET('&FULLDSN(&MEMBER)') PANEL(DOCEDIT)\n\n\n             ENDO\n\n\n        EXIT: ISPEXEC CONTROL DISPLAY RESTORE\n\n\n./ ADD NAME=DOCEDIT  0106-86163-86164-2240-00018-00013-00000-KK00150\n        ISREDIT MACRO\n\n\n        CONTROL ASIS\n\n\n        ISPEXEC VGET (DESCL1 DESCL2 DESCL3 CMD OPS DCNT) SHARED\n\n\n\n\n\n        SET B = &STR(                                                    )\n\n\n        SET B = &STR(&B&B)\n\n\n        SET PAD = &SUBSTR(1:70-&LENGTH(&STR(&DESCL1)),&B)\n\n\n\n\n\n        IF &DCNT > 2 THEN +\n\n\n           ISREDIT LINE_AFTER 3 = &STR(\"D3 &DESCL3\")\n\n\n\n\n\n        IF &DCNT > 1 THEN +\n\n\n           ISREDIT LINE_AFTER 3 = &STR(\"D2 &DESCL2\")\n\n\n\n\n\n           ISREDIT LINE_AFTER 3 = &STR(\"D1 &DESCL1&PAD &CMD &OPS\")\n\n\n\n\n\n        ISREDIT SAVE\n\n\n        ISREDIT END\n\n\n./ ADD NAME=DOCEDUP  0102-86163-86191-1832-00007-00005-00000-KX00150\n        ISREDIT MACRO\n\n\n\n\n\n        ISREDIT LINE_AFTER 0 = MSGLINE &STR(\"   DO NOT DELETE ANY OF THE TITLE L\nINES.     \")\n\n        ISREDIT LINE_AFTER 0 = MSGLINE &STR(\"         IN COLUMNS 1-3 OR 74-200.\n       \")\n\n        ISREDIT LINE_AFTER 0 = MSGLINE &STR(\"WARNING: DO NOT CHANGE CONTROL INFO\nRMATION\")\n\n\n\n\n        ISREDIT BOUNDS = 4 73\n\n\n./ ADD NAME=DOCFINAL 0116-86168-86220-1310-00032-00028-00005-KK00150\n00001000ISREDIT MACRO (L)\n\n\n00001100IF &L NE &STR() THEN CONTROL LIST CONLIST\n\n\n00001200IF &SYSPREF = KX00150 THEN CONTROL MSG LIST CONLIST\n\n\n00001300/* DONT TOSS THIS IT'S USED IN STATUS RPT SYSTEM  */\n\n\n00002000ISREDIT NUMBER OFF\n\n\n00003000CONTROL NOFLUSH END(ENDO)\n\n\n00004000ISPEXEC CONTROL ERRORS RETURN\n\n\n00005900SET &MEMNAME = &STR()\n\n\n00006000ISREDIT BOUNDS 1 74\n\n\n00006100ISREDIT (DATA1) = DATAID\n\n\n00006200ISREDIT (MEMNAME) = MEMBER\n\n\n00006300IF &MEMNAME = FINAL THEN +\n\n\n00006400  DO\n\n\n00006500  ISREDIT RECOVERY ON\n\n\n00030000  ISREDIT CAPS = OFF\n\n\n00040000  ISREDIT (L1) = LINE 1\n\n\n00050000  IF &LASTCC = 12 THEN DO\n\n\n00050100        ISPEXEC VGET STATCON SHARED       /* CONTROL DATAID  */\n\n\n00051000        ISREDIT COPY ALL AFTER 0\n\n\n00051116  /*    ISREDIT CHANGE X'4B40' X'4B4F' ALL */\n\n\n00051206        %DOCUPDAT &DATA1 SCRIPT &STATCON DATAIDS\n\n\n00051300        IF &LASTCC NE 0 THEN EXIT\n\n\n00052000        ISREDIT COPY SCRIPT AFTER 0\n\n\n00053000        ISREDIT CHANGE X'40AA' X'4BA4A240' 1 ALL\n\n\n00054000        ISREDIT CHANGE C'                                  ' X'4BA29240F\n1' 1 ALL\n\n00055013        ISREDIT CHANGE C'  ' C'QQ' 1 ALL\n\n\n00056013        ISREDIT CHANGE C'QQ' C'' 1 ALL\n\n\n00057014        ISREDIT CHANGE P'$ $===============================' X'4BA29240F\n1' 1 ALL\n\n00070000        ISREDIT RESET SPECIAL\n\n\n00140000                       ENDO\n\n\n00140100  EXIT\n\n\n00141000  ENDO\n\n\n./ ADD NAME=DOCIINIT 0104-86190-86191-1832-00014-00018-00000-KX00150\n        ISREDIT MACRO\n\n\n        CONTROL ASIS END(ENDO)\n\n\n\n\n\n        ISREDIT LINE_AFTER 0 = MSGLINE &STR(\"   DO NOT DELETE ANY OF THE TITLE L\nINES.    \")\n\n        ISREDIT LINE_AFTER 0 = MSGLINE &STR(\"         IN COLUMNS 1-3 OR 74-200.\n       \")\n\n        ISREDIT LINE_AFTER 0 = MSGLINE &STR(\"WARNING: DO NOT CHANGE CONTROL INFO\nRMATION\")\n\n\n\n\n        ISPEXEC VGET (DTYPE) SHARED\n\n\n        ISREDIT (MNAME) = MEMBER\n\n\n        IF &DTYPE = DOC04 THEN +\n\n\n          DO\n\n\n          ISREDIT CHANGE 'CONTROL' '&MNAME' ALL 1 200\n\n\n          ENDO\n\n\n        ISREDIT BOUNDS = 4 73\n\n\n./ ADD NAME=DOCIMERG 0108-86059-88090-1351-00045-00056-00007-KK00155\n00001000ISREDIT MACRO (L)\n\n\n00001100IF &L NE &STR() THEN CONTROL LIST CONLIST\n\n\n00001200IF &SYSPREF = KX00150 THEN CONTROL MSG LIST CONLIST\n\n\n00001300/* DONT TOSS THIS IT'S USED IN STATUS RPT SYSTEM  */\n\n\n00002000ISREDIT NUMBER OFF\n\n\n00003000CONTROL NOFLUSH END(ENDO)\n\n\n00004000ISPEXEC CONTROL ERRORS RETURN\n\n\n00005900SET &MEMNAME = &STR()\n\n\n00006000ISREDIT BOUNDS 1 74\n\n\n00006100ISREDIT (DATA1) = DATAID\n\n\n00006200ISREDIT (MEMNAME) = MEMBER\n\n\n00150000IF &MEMNAME = ALL THEN +\n\n\n00151000   DO\n\n\n00151200   ISREDIT DELETE ALL NX\n\n\n00152004   ISREDIT DEFINE DOCSMERG CMD MACRO\n\n\n00160100   ISREDIT COPY PATTERN AFTER 0\n\n\n00160200   ISREDIT RESET SPECIAL\n\n\n00162000   ISREDIT (CURMBR) = MEMBER\n\n\n00163000   ISPEXEC LMOPEN DATAID(&DATA1) OPTION(INPUT)\n\n\n00164000   SET LMRC = &LASTCC\n\n\n00165000      DO WHILE (&LMRC = 0)\n\n\n00166000      ISPEXEC LMMLIST DATAID(&DATA1) MEMBER(MEMBER) STATS(YES)\n\n\n00167000      SET LMRC = &LASTCC\n\n\n00168000      IF &LMRC = 0 AND &ZLCNORC NE 0 THEN +\n\n\n00169000         DO\n\n\n00169100         IF (&MEMBER NE &CURMBR) AND +\n\n\n00169200            (&MEMBER NE PATTERN) AND +\n\n\n00169301            (&MEMBER NE SCRIPT) AND +\n\n\n00169500            (&MEMBER NE FINAL) THEN +\n\n\n00169600               DO\n\n\n00169704               ISREDIT DOCSMERG &MEMBER &L\n\n\n00169800               ISPEXEC VGET HAVDATA\n\n\n00169900               IF &HAVDATA = YES THEN +\n\n\n00170000               ISREDIT LINE_AFTER 0 = MSGLINE +\n\n\n00170100                  '&MEMBER HAS TURNED IN A STATUS REPORT - &ZLMDATE.'\n\n\n00170200               ENDO\n\n\n00170300         ENDO\n\n\n00170400      ENDO\n\n\n00170506/* ISREDIT UP MAX  */\n\n\n00170607   ISREDIT LINE_AFTER 0 = LINE 1\n\n\n00170808   ISREDIT FIND '1' FIRST\n\n\n00170908   ISREDIT DELETE 1\n\n\n00171000   ISPEXEC LMMLIST DATAID(&DATA1) OPTION(FREE)\n\n\n00172000   ISPEXEC LMCLOSE DATAID(&DATA1)\n\n\n00180000   ENDO\n\n\n./ ADD NAME=DOCINPRT 0100-84215-84215-1241-00005-00005-00000-KK00150\n00010000PROC 0 M T V VM L OUT01() DIR() DSNB() CDCUR(MEMBER) PO(N)\n SF(NO)\n\n00020000CONTROL NOFLUSH END(ENDO)\n\n\n00041000     SET &GPM = NO PRINT AVAILABLE\n\n\n00042000     SET &GPML = NO PRINT IS AVAILABLE FOR THIS SELECTION\n\n\n00050000     ISPEXEC SETMSG MSG(GPM001)\n\n\n./ ADD NAME=DOCINSEL 0100-84327-84327-2048-00002-00002-00000-KK00150\n00009800PROC 1 OPERAND\n SF(NO)\n\n00009900%SPFOZD &OPERAND\n\n\n./ ADD NAME=DOCIOCTL 0102-87030-87030-1214-00061-00061-00000-KK00150\n00190700  PROC 0 U\n\n\n00190800  CONTROL NOMSG NOFLUSH END(ENDO)\n\n\n00190900  FREE F(SYSOUT)\n\n\n00191000  IFALC F(SYSOUT)\n\n\n00191100  IF &LASTCC NE 0 THEN ALLOC F(SYSOUT) DSN(*)\n\n\n00191200  SET &DOCSLVL1 =  DPSCD150\n\n\n00191300  SET &DOCSLVL2 = DOCSYS\n\n\n00191400  SET &DOCSTITL = &STR(IO CONTROL DOC SYSTEM)\n\n\n00194000  SET &GPML = &STR(PLEASE WAIT - INDEXES ARE BEING LOADED)\n\n\n00194100  SET &PSIZE = M\n\n\n00195000  ISPEXEC VPUT (DOCSLVL1 DOCSLVL2 DOCSTITL GPML PSIZE)\n\n\n00196000  ISPEXEC CONTROL DISPLAY LOCK\n\n\n00197000  ISPEXEC DISPLAY PANEL(GPM)\n\n\n00198000\n\n\n00211000  IF &U = U OR &SYSUID = GCTR150 OR &SYSUID = JPTR150  +\n\n\n00212000            OR &SYSUID = VWTR150 OR &SYSUID = SNTR150  +\n\n\n00213000            OR &SYSUID = MHTR150 OR &SYSUID = LLTR150 THEN +\n\n\n00220000     DO\n\n\n00223000     SET &LIB = IOMEMO\n\n\n00224000     SET &SAMPDOC = '&DOCSLVL1..&DOCSLVL2..IOMEMO(SAMPDOC)'\n\n\n00250000     SET ACTTAB = &STR(S,SEL P,PRT E,EDT)\n\n\n00260000     SET THDA1 = &STR(\u00a2         USE \"PF3\u00a2TO EXIT,\"PF5\u00a2TO CHANGE INDEX,\"P\nF6\u00a2TO ADD AN ENTRY)\n\n00270000     SET THDA2 = &STR(\u00a2             OPTIONS ARE\"S\u00a2FOR BROWSE,\"P\u00a2FOR PRIN\nT,\"E\u00a2FOR EDIT)\n\n00280000     SET DOCUPDT = YES\n\n\n00290000     ISPEXEC VPUT (ACTTAB,THDA1,THDA2,SAMPDOC,LIB,DOCUPDT) SHARED\n\n\n00300000     ENDO\n\n\n00310000  ELSE +\n\n\n00320000     DO\n\n\n00330000     SET DOCUPDT = NO\n\n\n00340000     ISPEXEC VPUT DOCUPDT SHARED\n\n\n00350000     ENDO\n\n\n00360000\n\n\n00370000RESHOW: +\n\n\n00371000  SET &DOCSMEM = IOPRIM\n\n\n00390000  SET &DOCSEXIT = NO\n\n\n00400000  ISPEXEC VPUT (DOCSMEM DOCSEXIT)\n\n\n00410000  ISPEXEC SELECT PGM(PANLEXIT) PARM(TBLHNDLR,1,PRIMET)\n\n\n00420000  ISPEXEC VGET DOCRSHOW SHARED\n\n\n00430000  IF &DOCRSHOW = YES THEN +\n\n\n00440000    DO\n\n\n00450000    SET DOCRSHOW =\n\n\n00460000    ISPEXEC VPUT DOCRSHOW SHARED\n\n\n00470000    GOTO RESHOW\n\n\n00480000    ENDO\n\n\n00490000\n\n\n00490100  SET &PSIZE =\n\n\n00491000  IF &U = U THEN +\n\n\n00510000    DO\n\n\n00520000    SET THDA1 = &STR()\n\n\n00530000    SET THDA2 = &STR()\n\n\n00540000    SET ACTTAB = &STR(S,SEL P,PRT)\n\n\n00550000    SET &SAMPDOC =\n\n\n00560000    SET DOCUPDT =\n\n\n00570000    SET &LIB =\n\n\n00580000    ISPEXEC VPUT (ACTTAB,THDA1,THDA2 DOCUPDT SAMPDOC LIB PSIZE) SHARED\n\n\n00590000    ENDO\n\n\n00600000  ELSE +\n\n\n00610000    DO\n\n\n00620000    SET DOCUPDT =\n\n\n00630000    ISPEXEC VPUT (DOCUPDT,PSIZE) SHARED\n\n\n00640000    ENDO\n\n\n./ ADD NAME=DOCISTAT 0113-86010-86034-1744-00020-00007-00000-KX00150\n        ISREDIT MACRO\n\n\n        ISREDIT NUMBER OFF\n\n\n        CONTROL NOFLUSH END(ENDO)\n\n\n        ISPEXEC CONTROL ERRORS RETURN\n\n\n        ISREDIT CAPS = OFF\n\n\n        ISREDIT RECOVERY ON\n\n\n        ISREDIT RESET SPECIAL\n\n\n        ISREDIT BOUNDS 3 74\n\n\n        ISREDIT RIGHT 2\n\n\n        ISREDIT (L1) = LINE 1\n\n\n        IF &LASTCC = 12 THEN DO\n\n\n                ISREDIT COPY PATTERN AFTER 0\n\n\n                ISREDIT RESET SPECIAL\n\n\n                             ENDO\n\n\n                ISREDIT LINE_AFTER +\n\n\n                    0 = MSGLINE '        Please do not create or copy a major to\npic line'\n\n                ISREDIT LINE_AFTER +\n\n\n                    0 = MSGLINE '            Please do not alter major topic lin\nes'\n\n                ISREDIT LINE_AFTER +\n\n\n                    0 = MSGLINE '        You may delete any major topic you do n\not need'\n\n./ ADD NAME=DOCLCL   0105-84006-84009-1739-00038-00035-00014-KK00150\n00012004PROC 0 L FN()\n\n\n00020003CONTROL NOFLUSH NOMSG END(ENDO)\n\n\n00030003IF &L = L THEN CONTROL MSG LIST CONLIST\n\n\n00031000ISPEXEC VGET (PDOCN HPID DSPRTOPT)\n\n\n00032000FILEINFO DSN('&PDOCN')\n\n\n00033000IF &LASTCC NE 0 AND &LASTCC NE 44 THEN GOTO EL\n\n\n00034000IF &DSORG = PS THEN GOTO DSPRINT\n\n\n00035000   ELSE IF &DSORG = PO THEN GOTO LISTPDS\n\n\n00036000        ELSE DO\n\n\n00037000          EL:  SET GPM = PRINT ERROR\n\n\n00038000               SET GPML = THE DATASET TO BE PRINTED IS NOT ACCEPTABLE.\n\n\n00039000               ISPEXEC SETMSG MSG(GPM001)\n\n\n00039100               ISPEXEC CONTROL NONDISPL END\n\n\n00039200               EXIT\n\n\n00039300             ENDO\n\n\n00039400LISTPDS: +\n\n\n00039501IF &MEMCNTL = YES THEN GOTO DSPRINT  /* NO NEED TO DO WHOLE LIB */\n\n\n00039600FREE F(SYSPRINT SYSLIB SYSPUNCH SYSIN)\n\n\n00039700ALLOC F(SYSIN) DUMMY\n\n\n00039800ALLOC F(SYSPRINT) DUMMY\n\n\n00039900ALLOC F(SYSLIB) DSN('&PDOCN')\n\n\n00040104CMDOUT DDN(SYSPUNCH)\n\n\n00040204SET FN = &LASTCC\n\n\n00040300CALL 'WDPSC.SYSLIBRY(LISTPDS)' 'DECK,NOLIST'\n\n\n00040402WHATDSN DDN(SYSPUNCH)\n\n\n00040502CHDSCB '&DSNAME' RECFM(FBA) NOLIST\n\n\n00040605FREE DSN('&DSNAME')\n\n\n00040702GOTO DSPRIN2\n\n\n00041200\n\n\n00042000DSPRINT: +\n\n\n00043002SET &DSNAME= &PDOCN\n\n\n00044002DSPRIN2: +\n\n\n00045002DSPRINT '&DSNAME' &HPID NONUM CCHAR &DSPRTOPT\n\n\n00071000SET GPM = PRINT QUEUED\n\n\n00072000SET GPML = THE DOCUMENT WAS QUEUED FOR PRINT ON PRINTER &HPID\n\n\n00073000ISPEXEC SETMSG MSG(GPM001)\n\n\n00080000ISPEXEC CONTROL NONDISPL END\n\n\n00090004IF &FN NE THEN CMDOUT FREE(&FN)\n\n\n./ ADD NAME=DOCMEMO  0100-86170-86170-1852-00015-00015-00000-KX00150\n00001000  PROC 1 SET\n\n\n00010000  CONTROL NOMSG NOFLUSH END(ENDO)\n\n\n00020000  IF &SET = ON THEN +\n\n\n00030000     DO\n\n\n00040000     ISPEXEC VGET LIB SHARED\n\n\n00050000     SET OLIB = &LIB\n\n\n00143100     SET &LIB = OPERMEMO\n\n\n00144000     ISPEXEC VPUT (LIB OLIB) SHARED\n\n\n00145000     ENDO\n\n\n00146000  IF &SET = OFF THEN +\n\n\n00147000     DO\n\n\n00148000     ISPEXEC VGET OLIB SHARED\n\n\n00149000     SET &LIB = &OLIB\n\n\n00160000     ISPEXEC VPUT (LIB) SHARED\n\n\n00170000     ENDO\n\n\n./ ADD NAME=DOCOMERG 0131-86010-86062-1230-00052-00007-00048-LL00150\n00001015ISREDIT MACRO (L)\n\n\n00001115IF &L NE &STR() THEN CONTROL LIST CONLIST\n\n\n00001230IF &SYSPREF = KX00150 THEN CONTROL LIST CONLIST\n\n\n00001300/* DONT TOSS THIS IT'S USED IN STATUS RPT SYSTEM  */\n\n\n00002000ISREDIT NUMBER OFF\n\n\n00003000CONTROL NOFLUSH END(ENDO)\n\n\n00004000ISPEXEC CONTROL ERRORS RETURN\n\n\n00005912SET &MEMNAME = &STR()\n\n\n00006026ISREDIT BOUNDS 1 74\n\n\n00006114ISREDIT (MEMNAME) = MEMBER\n\n\n00006225IF &MEMNAME = FINAL THEN DO\n\n\n00006321  ISREDIT RECOVERY ON\n\n\n00030013  ISREDIT CAPS = OFF\n\n\n00040013  ISREDIT (L1) = LINE 1\n\n\n00050013  IF &LASTCC = 12 THEN DO\n\n\n00051014        ISREDIT COPY ALL AFTER 0\n\n\n00070013        ISREDIT RESET SPECIAL\n\n\n00140013                       ENDO\n\n\n00140113                          EXIT\n\n\n00141013                          ENDO\n\n\n00150014IF &MEMNAME = ALL THEN +\n\n\n00151013   DO\n\n\n00151229   ISREDIT DELETE ALL NX\n\n\n00152018   ISREDIT DEFINE MERGSTAT CMD MACRO\n\n\n00160114   ISREDIT COPY PATTERN AFTER 0\n\n\n00160225   ISREDIT RESET SPECIAL\n\n\n00161014   ISREDIT (DATA1) = DATAID\n\n\n00162014   ISREDIT (CURMBR) = MEMBER\n\n\n00163014   ISPEXEC LMOPEN DATAID(&DATA1) OPTION(INPUT)\n\n\n00164014   SET LMRC = &LASTCC\n\n\n00164131   IF &LMRC = 12 THEN SET LMRC = 0\n\n\n00165024      DO WHILE (&LMRC = 0)\n\n\n00166014      ISPEXEC LMMLIST DATAID(&DATA1) MEMBER(MEMBER) STATS(YES)\n\n\n00167014      SET LMRC = &LASTCC\n\n\n00168025      IF &LMRC = 0 AND &ZLCNORC NE 0 THEN +\n\n\n00169014         DO\n\n\n00169114         IF (&MEMBER NE &CURMBR) AND +\n\n\n00169214            (&MEMBER NE PATTERN) AND +\n\n\n00169325            (&MEMBER NE FINAL) THEN +\n\n\n00169425               DO\n\n\n00169518               ISREDIT MERGSTAT &MEMBER &L\n\n\n00169627               ISPEXEC VGET HAVDATA\n\n\n00169727               IF &HAVDATA = YES THEN +\n\n\n00169825               ISREDIT LINE_AFTER 0 = MSGLINE +\n\n\n00169925                  '&MEMBER HAS TURNED IN A STATUS REPORT - &ZLMDATE.'\n\n\n00170025               ENDO\n\n\n00170114         ENDO\n\n\n00170214      ENDO\n\n\n00170323   ISREDIT UP MAX\n\n\n00170414   ISPEXEC LMMLIST DATAID(&DATA1) OPTION(FREE)\n\n\n00171014   ISPEXEC LMCLOSE DATAID(&DATA1)\n\n\n00180013   ENDO\n\n\n./ ADD NAME=DOCOPER  0109-86128-86188-1754-00059-00020-00059-KX00150\n00190706  PROC 0 U\n\n\n00190806  CONTROL NOMSG NOFLUSH END(ENDO)\n\n\n00190906  FREE F(SYSOUT)\n\n\n00191006  IFALC F(SYSOUT)\n\n\n00191106  IF &LASTCC NE 0 THEN ALLOC F(SYSOUT) DSN(*)\n\n\n00191206  SET &DOCSLVL1 =  DPSCD150\n\n\n00191306  SET &DOCSLVL2 = DOCSYS\n\n\n00191406  SET &DOCSTITL = &STR(OPERATIONS DOC SYSTEM)\n\n\n00194006  SET &GPML = &STR(PLEASE WAIT - INDEXES ARE BEING LOADED)\n\n\n00194108  SET &PSIZE = M\n\n\n00195008  ISPEXEC VPUT (DOCSLVL1 DOCSLVL2 DOCSTITL GPML PSIZE)\n\n\n00196006  ISPEXEC CONTROL DISPLAY LOCK\n\n\n00197006  ISPEXEC DISPLAY PANEL(GPM)\n\n\n00198006\n\n\n00211006  IF &U = U THEN +\n\n\n00220006     DO\n\n\n00223006     SET &LIB = OPERMEMO\n\n\n00224006     SET &SAMPDOC = '&DOCSLVL1..&DOCSLVL2..OPERMEMO(SAMPDOC)'\n\n\n00250006     SET ACTTAB = &STR(S,SEL P,PRT E,EDT)\n\n\n00260006     SET THDA1 = &STR(\u00a2         USE \"PF3\u00a2TO EXIT,\"PF5\u00a2TO CHANGE INDEX,\"P\nF6\u00a2TO ADD AN ENTRY)\n\n00270006     SET THDA2 = &STR(\u00a2             OPTIONS ARE\"S\u00a2FOR BROWSE,\"P\u00a2FOR PRIN\nT,\"E\u00a2FOR EDIT)\n\n00280006     SET DOCUPDT = YES\n\n\n00290006     ISPEXEC VPUT (ACTTAB,THDA1,THDA2,SAMPDOC,LIB,DOCUPDT) SHARED\n\n\n00300006     ENDO\n\n\n00310006  ELSE +\n\n\n00320006     DO\n\n\n00330006     SET DOCUPDT = NO\n\n\n00340006     ISPEXEC VPUT DOCUPDT SHARED\n\n\n00350006     ENDO\n\n\n00360006\n\n\n00370006RESHOW: +\n\n\n00371006  SET &DOCSMEM = OPERPRIM\n\n\n00390006  SET &DOCSEXIT = NO\n\n\n00400006  ISPEXEC VPUT (DOCSMEM DOCSEXIT)\n\n\n00410007  ISPEXEC SELECT PGM(PANLEXIT) PARM(TBLHNDLR,1,PRIMET)\n\n\n00420006  ISPEXEC VGET DOCRSHOW SHARED\n\n\n00430006  IF &DOCRSHOW = YES THEN +\n\n\n00440006    DO\n\n\n00450006    SET DOCRSHOW =\n\n\n00460006    ISPEXEC VPUT DOCRSHOW SHARED\n\n\n00470006    GOTO RESHOW\n\n\n00480006    ENDO\n\n\n00490006\n\n\n00490109  SET &PSIZE =\n\n\n00491006  IF &U = U THEN +\n\n\n00510006    DO\n\n\n00520006    SET THDA1 = &STR()\n\n\n00530006    SET THDA2 = &STR()\n\n\n00540006    SET ACTTAB = &STR(S,SEL P,PRT)\n\n\n00550006    SET &SAMPDOC =\n\n\n00560006    SET DOCUPDT =\n\n\n00570006    SET &LIB =\n\n\n00580009    ISPEXEC VPUT (ACTTAB,THDA1,THDA2 DOCUPDT SAMPDOC LIB PSIZE) SHARED\n\n\n00590006    ENDO\n\n\n00600006  ELSE +\n\n\n00610006    DO\n\n\n00620006    SET DOCUPDT =\n\n\n00630009    ISPEXEC VPUT (DOCUPDT,PSIZE) SHARED\n\n\n00640006    ENDO\n\n\n./ ADD NAME=DOCR90   0103-86035-86189-1145-00055-00035-00023-KK00150\n00010000PROC 0\n\n\n00020000CONTROL NOFLUSH   MSG END(ENDO)\n\n\n00030002ISPEXEC VGET (ZTEMPF PJOBC PDOCN PSIZE)\n\n\n00031000FILEINFO DSN('&PDOCN')\n\n\n00031100SET FICC = &LASTCC\n\n\n00031200IF &FICC NE 0 AND &FICC NE 44 THEN GOTO EL\n\n\n00032000IF &DSORG = PS THEN SET RSKEL = DOCR90\n\n\n00033000   ELSE IF &DSORG = PO THEN DO\n\n\n00033300               IF &MEMCNTL = YES THEN SET RSKEL = DOCR90\n\n\n00033400                                 ELSE SET RSKEL = DOCPDR90\n\n\n00033500                            ENDO\n\n\n00034000        ELSE DO\n\n\n00034100          EL:  SET GPM = PRINT ERROR &FICC\n\n\n00034201               SET GPML = &PDOCN  &OUTMSG\n\n\n00034300               ISPEXEC SETMSG MSG(GPM001)\n\n\n00034500               ISPEXEC CONTROL NONDISPL END\n\n\n00034600               EXIT\n\n\n00035000             ENDO\n\n\n00040000GETMY SYS\n\n\n00050000SET PJN = &SUBSTR(1:2,&SYSUID)P&SYS&SUBSTR(5:7,&SYSUID)\n\n\n00052002  DO\n\n\n00053002  SET PCHSET = ET49\n\n\n00054002  SET PFCB = F128\n\n\n00055002  SET PTRNA =\n\n\n00055103  SET PLMRG = 5\n\n\n00056002  ENDO\n\n\n00057002IF &PSIZE = M THEN +\n\n\n00058002  DO\n\n\n00059002  SET PCHSET = ET29\n\n\n00059102  SET PFCB = STD8\n\n\n00059202  SET PTRNA =\n\n\n00059303  SET PLMRG =\n\n\n00059402  ENDO\n\n\n00059502IF &PSIZE = L THEN +\n\n\n00059602  DO\n\n\n00059702  SET PCHSET = ET39\n\n\n00059802  SET PFCB = STD8\n\n\n00059902  SET PTRNA = T\n\n\n00060003  SET PLMRG =\n\n\n00061002  ENDO\n\n\n00070003ISPEXEC VPUT (PJN,PCHSET,PFCB,PTRNA,PLMRG)\n\n\n00160000  DO\n\n\n00172000   /* OPEN FILE TAILORING  */\n\n\n00172100   ISPEXEC FTOPEN TEMP\n\n\n00173000   /* TAILOR THE REQUEST   */\n\n\n00173100   ISPEXEC FTINCL &RSKEL\n\n\n00174000   /* CLOSE IT OFF         */\n\n\n00174100   ISPEXEC FTCLOSE\n\n\n00175000   /* SUBMIT THE JOB       */\n\n\n00176000   SUBMIT '&ZTEMPF'\n\n\n00180000  ENDO\n\n\n00192000SET GPM = PRINT SUBMITTED\n\n\n00200000SET GPML = A ROTATE90 JOB WAS SUMITTED IN JOB CLASS &PJOBC\n\n\n00210000ISPEXEC SETMSG MSG(GPM001)\n\n\n00220000ISPEXEC CONTROL NONDISPL END\n\n\n./ ADD NAME=DOCSAMP  0103-86190-87124-1231-00059-00058-00004-KK00150\n00010000  CONTROL NOMSG NOFLUSH END(ENDO)\n\n\n00011002  IF &SYSPREF = KX00150 THEN CONTROL LIST MSG CONLIST\n\n\n00012002  CLOG '&SYSDATE &SYSTIME &SYSICMD' U($$$$150) SAVE\n\n\n00020000  FREE F(SYSOUT)\n\n\n00021000  IFALC F(SYSOUT)\n\n\n00022000  IF &LASTCC NE 0 THEN ALLOC F(SYSOUT) DSN(*)\n\n\n00040000  SET &DOCSLVL1 =  WDPSC\n\n\n00050000  SET &DOCSLVL2 = SAMPLE\n\n\n00060000  SET &DOCSTITL = &STR(SAMPLE DOCUMENTATION SYSTEM)\n\n\n00060100  SET &GPML = &STR(PLEASE WAIT - INDEXES ARE BEING LOADED)\n\n\n00060200  ISPEXEC VPUT (DOCSLVL1 DOCSLVL2 DOCSTITL GPML)\n\n\n00060300  ISPEXEC CONTROL DISPLAY LOCK\n\n\n00060400  ISPEXEC DISPLAY PANEL(GPM)\n\n\n00060500\n\n\n00066100  GETMY ACFUID\n\n\n00066200  SET U = &SUBSTR(1:10,&ACFUID)\n\n\n00066300  IF &U = &STR(150D3100CS) OR &U = &STR(150D360004) OR &U = &STR(150D210\n0  ) THEN +\n\n00066400     DO\n\n\n00066601/*   SET &SAMPDOC = '&DOCSLVL1..&DOCSLVL2..TECHBULL(MEMO1)'   */\n\n\n00066700     SET ACTTAB = &STR(S,SEL P,PRT E,EDT)\n\n\n00066800     SET THDA1 = &STR(\u00a2         USE \"PF3\u00a2TO EXIT,\"PF5\u00a2TO CHANGE INDEX,\"P\nF6\u00a2TO ADD AN ENTRY)\n\n00066900     SET THDA2 = &STR(\u00a2             OPTIONS ARE\"S\u00a2FOR BROWSE,\"P\u00a2FOR PRIN\nT,\"E\u00a2FOR EDIT)\n\n00067000     SET DOCUPDT = YES\n\n\n00067100     ISPEXEC VPUT (ACTTAB,THDA1,THDA2,SAMPDOC,LIB,DOCUPDT) SHARED\n\n\n00067200     ENDO\n\n\n00067300  ELSE +\n\n\n00067400     DO\n\n\n00067500     SET DOCUPDT = NO\n\n\n00067600     ISPEXEC VPUT DOCUPDT SHARED\n\n\n00067700     ENDO\n\n\n00067800\n\n\n00067900RESHOW: +\n\n\n00068000  SET &DOCSMEM = PRIM\n\n\n00068100  SET &DOCSEXIT = NO\n\n\n00068200  ISPEXEC VPUT (DOCSMEM DOCSEXIT)\n\n\n00141003  ISPEXEC SELECT PGM(PANLEXIT) PARM(TBLHNDLR,1,PRIME)\n\n\n00142200  ISPEXEC VGET DOCRSHOW SHARED\n\n\n00142300  IF &DOCRSHOW = YES THEN +\n\n\n00142400    DO\n\n\n00142500    SET DOCRSHOW =\n\n\n00142600    ISPEXEC VPUT DOCRSHOW SHARED\n\n\n00142700    GOTO RESHOW\n\n\n00142800    ENDO\n\n\n00142900\n\n\n00143000  IF &U = &STR(150D3100CS) OR &U = &STR(150D360004) OR &U = &STR(150D210\n0  ) THEN +\n\n00143100    DO\n\n\n00143200    SET THDA1 = &STR()\n\n\n00143300    SET THDA2 = &STR()\n\n\n00143400    SET ACTTAB = &STR(S,SEL P,PRT)\n\n\n00143500    SET &SAMPDOC =\n\n\n00143600    SET DOCUPDT =\n\n\n00143700    SET &LIB =\n\n\n00143800    ISPEXEC VPUT (ACTTAB,THDA1,THDA2 DOCUPDT SAMPDOC LIB) SHARED\n\n\n00143900    ENDO\n\n\n00144000  ELSE +\n\n\n00144100    DO\n\n\n00144200    SET DOCUPDT =\n\n\n00144300    ISPEXEC VPUT DOCUPDT SHARED\n\n\n00144400    ENDO\n\n\n./ ADD NAME=DOCSMERG 0106-86204-86246-1053-00108-00103-00012-KX00150\n00010000ISREDIT MACRO (MNAME,L)\n\n\n00012005/* IF &SYSUID = DCAD150 THEN CONTROL LIST CONLIST /* */\n\n\n00013003IF &SYSPREF = KX00150 THEN CONTROL LIST CONLIST\n\n\n00020000/* DONT TOSS THIS IT'S USED IN STATUS RPT SYSTEM  */\n\n\n00030000ISREDIT NUMBER OFF\n\n\n00040000CONTROL NOFLUSH END(ENDO)\n\n\n00050000ISPEXEC CONTROL ERRORS RETURN\n\n\n00051003SET &BLANKS = &SUBSTR(1:80,&STR(\n                                                   ))\n\n00060000/*                                                                   */\n\n\n00061000/* LABEL LAST PATTERN LINE                                   */\n\n\n00062000/*                                                                   */\n\n\n00063100ISREDIT LABEL .ZL = .ENDPAT\n\n\n00071000/*                                                                   */\n\n\n00080000/* COPY  member at end of pattern                                    */\n\n\n00081000/*                                                                   */\n\n\n00090000ISREDIT COPY &MNAME AFTER .ENDPAT\n\n\n00091000SET &HAVDATA = NO    /* SAY NO GOOD DATA AT FIRST  */\n\n\n00100000ISREDIT (LN) = LINENUM .ENDPAT\n\n\n00102000SET &LN = &LN+1\n\n\n00102100ISREDIT LABEL &LN = .MSTART\n\n\n00103000ISREDIT LABEL .ZL = .MEND\n\n\n00103100ISREDIT CHANGE X'50' X'5050' .MSTART .MEND ALL  /* ampers make havok */\n\n\n00104000/*                                                                   */\n\n\n00110000/* LOOP: FIND TOPIC LINE                                             */\n\n\n00110100/*                                                                   */\n\n\n00110200ISREDIT LABEL 1 = .CURTOP\n\n\n00111000SET &MD = GO\n\n\n00120000   DO WHILE &MD = GO\n\n\n00121000   ISREDIT CURSOR = .CURTOP       /*  KERMIT CHANGE TIL UZ41259 */\n\n\n00130000   ISREDIT FIND X'AA'\n\n\n00131000   IF &LASTCC = 0 THEN +\n\n\n00132000      DO\n\n\n00133000/*                                                                   */\n\n\n00140000/*       search for matching topic                                   */\n\n\n00140100/*                                                                   */\n\n\n00140200      ISREDIT (CURTOP) = LINENUM .ZCSR\n\n\n00140300      ISREDIT (ENDPAT) = LINENUM .ENDPAT\n\n\n00140400      IF &CURTOP > &ENDPAT THEN GOTO DONE /* CHECK RE UZ41259 */\n\n\n00140500      ISREDIT (TOPIC) = LINE .ZCSR\n\n\n00140600      SET &TOPIC = &SUBSTR(1:50,&STR(&TOPIC))\n\n\n00140700SKIP: SET &CURTOP = &CURTOP+1 /* POINT to next line\nS */\n\n00141000      ISREDIT LABEL &CURTOP = .NL\n\n\n00141104      ISREDIT CURSOR = .NL 1\n\n\n00141301      ISREDIT FIND X'BA' .NL .NL  2\n\n\n00141400      IF &LASTCC = 0 THEN GOTO SKIP\n\n\n00141500      SET &CURTOP = &CURTOP+1 /* SKIP ONE EXTRA LINE    */\n\n\n00141600      ISREDIT (XX) = LINENUM .MSTART\n\n\n00141700      ISREDIT CURSOR = &XX\n\n\n00142000      ISREDIT FIND '&TOPIC' .MSTART .MEND NEXT\n\n\n00143000/*                                                                   */\n\n\n00150000/*       IF MATCH: GET 1ST (&FL) AND LAST (&LL) LINE NOS.            */\n\n\n00150100/*                                                                   */\n\n\n00151000      IF &LASTCC = 0 THEN +\n\n\n00152000         DO\n\n\n00153000         ISREDIT (FL) = LINENUM .ZCSR\n\n\n00153100         SET &FL = &FL + 1\n\n\n00154000         ISREDIT LABEL &FL = .TSTART\n\n\n00154200         ISREDIT (XZ) = LINENUM .ZCSR\n\n\n00154300         SET XZ = &XZ + 1\n\n\n00154400         ISREDIT LABEL &XZ = .TSEARCH\n\n\n00155000         ISREDIT FIND X'AA' .TSEARCH .MEND NEXT\n\n\n00156000         IF &LASTCC = 0 THEN +\n\n\n00156100           DO\n\n\n00156200           ISREDIT (LL) = LINENUM .ZCSR\n\n\n00156300           SET LL = &LL - 1\n\n\n00156400           ENDO\n\n\n00158000         ELSE ISREDIT (LL) = LINENUM .ZL\n\n\n00158100/*                                                                   */\n\n\n00158200/*        LOOP TO DELETE ANY LEADING BLANK LINES:                    */\n\n\n00158400/*                                                                   */\n\n\n00159000           DO WHILE &FL LE &LL\n\n\n00159200           ISREDIT (LINE) = LINE &FL\n\n\n00159500           ISREDIT LABEL &FL = .NL\n\n\n00159603           ISREDIT CURSOR = .NL 1\n\n\n00159701           ISREDIT FIND X'BA' .NL .NL  2\n\n\n00159800           IF &LASTCC = 0 OR +\n\n\n00159906              &SUBSTR(1:80,&NRSTR(&LINE)) = &BLANKS OR +\n\n\n00160006              &SUBSTR(1:3,&NRSTR(&LINE)) = &STR(+ _) THEN +\n\n\n00160100              SET &FL = &FL +1\n\n\n00160200           ELSE +\n\n\n00160300              DO\n\n\n00160400              SET &HAVDATA = YES\n\n\n00160500/*                                                                   */\n\n\n00160600/*                 copy adjusted line nos from mem                   */\n\n\n00160700/*                 after topic line                                  */\n\n\n00160800/*                                                                   */\n\n\n00160900              ISREDIT (OFFSET) = LINENUM .ENDPAT\n\n\n00161000              SET FL = &FL-&OFFSET\n\n\n00161100              SET LL = &LL-&OFFSET\n\n\n00161200              IF &FL > &LL THEN WRITE FL > LL IN MERGSTAT\n\n\n00161300              ISREDIT COPY &MNAME AFTER &CURTOP &FL &LL\n\n\n00161400              GOTO DONECOPY\n\n\n00161500              ENDO\n\n\n00161600           ENDO\n\n\n00161700         ENDO\n\n\n00161800      DONECOPY: ISREDIT LABEL &CURTOP = .CURTOP\n\n\n00161900      ENDO\n\n\n00162000   ELSE SET &MD = STOP\n\n\n00170000   ENDO\n\n\n00171000/*                                                                   */\n\n\n00180000/* no more topics: delete copied member from end                     */\n\n\n00180100/*                                                                   */\n\n\n00181004DONE: ISREDIT DELETE .MSTART .ZLAST\n\n\n00181104SET DRC = &LASTCC\n\n\n00181204IF &DRC NE 0 THEN WRITE DELETE RC WAS &DRC\n\n\n00181300ISPEXEC VPUT HAVDATA\n\n\n00182000/*                                                                   */\n\n\n00190000/* return                                                            */\n\n\n./ ADD NAME=DOCSOP   0108-84006-84030-1357-00043-00037-00017-JS02150\n00001004PROC 0 L FN()\n\n\n00020003CONTROL NOFLUSH NOMSG END(ENDO)\n\n\n00030004IF &L = L THEN CONTROL LIST MSG CONLIST\n\n\n00031000ISPEXEC VGET (PDOCN PSOC PDEST)\n\n\n00031104SET &DSNAME = &PDOCN\n\n\n00031400FILEINFO DSN('&PDOCN')\n\n\n00031500IF &LASTCC NE 0 AND &LASTCC NE 44 THEN GOTO EL\n\n\n00031600IF &DSORG = PS THEN GOTO FTL\n\n\n00031700   ELSE IF &DSORG = PO THEN GOTO LISTPDS\n\n\n00031800        ELSE DO\n\n\n00031900          EL:  SET GPM = PRINT ERROR\n\n\n00032000               SET GPML = THE DATASET TO BE PRINTED IS NOT ACCEPTABLE.\n\n\n00032100               ISPEXEC SETMSG MSG(GPM001)\n\n\n00032200               ISPEXEC CONTROL NONDISPL END\n\n\n00032300               EXIT\n\n\n00032400             ENDO\n\n\n00032500FTL: +\n\n\n00035000FREE F(IN01 OUT01 MESSAGES)\n\n\n00040004ALLOC F(IN01) DSN('&DSNAME')\n\n\n00050000ALLOC F(OUT01) SYSOUT(&PSOC) DEST(&PDEST)\n\n\n00060000ALLOC F(MESSAGES) DUMMY\n\n\n00070000CALL 'WDPSC.SYSLIBRY(FTL)' '01'\n\n\n00070106FREE F(IN01 OUT01 MESSAGES)\n\n\n00071000SET GPM = DOCUMENT PRINTED\n\n\n00072000SET GPML = THE DOCUMENT WAS PRINTED ON SYSOUT CLASS &PSOC AT &PDEST\n\n\n00073000ISPEXEC SETMSG MSG(GPM001)\n\n\n00080000ISPEXEC CONTROL NONDISPL END\n\n\n00081004IF &FN NE THEN CMDOUT FREE(&FN)\n\n\n00090000EXIT\n\n\n00091004\n\n\n00100000LISTPDS: +\n\n\n00101001IF &MEMCNTL = YES THEN GOTO FTL      /* NO NEED TO DO WHOLE LIB */\n\n\n00110004FREE F(SYSPRINT SYSLIB SYSIN)\n\n\n00120000ALLOC F(SYSIN) DUMMY\n\n\n00130000ALLOC F(SYSPRINT) DUMMY\n\n\n00140000ALLOC F(SYSLIB) DSN('&PDOCN')\n\n\n00140204CMDOUT DDN(SYSPUNCH)\n\n\n00140304SET FN = &LASTCC\n\n\n00140404CALL 'WDPSC.SYSLIBRY(LISTPDS)' 'DECK,NOLIST'\n\n\n00140504WHATDSN DDN(SYSPUNCH)\n\n\n00140604CHDSCB '&DSNAME' RECFM(FBA) NOLIST\n\n\n00140704FREE DSN('&DSNAME')\n\n\n00140804GOTO FTL\n\n\n./ ADD NAME=DOCSTAT  0103-86189-86210-1821-00026-00026-00002-KX00150\n00001000  PROC 1 SET D1() D2()\n\n\n00010000  CONTROL NOMSG NOFLUSH END(ENDO)\n\n\n00020000  IF &SET = ON THEN +\n\n\n00030000     DO\n\n\n00050000     SET DTYPE = DOC04\n\n\n00143100     SET LVL1 = &D1\n\n\n00143200     SET LVL2 = &D2\n\n\n00143300     ISPEXEC VGET (DOCSLVL1 DOCSLVL2 SAMPDOC SAMPNDEX)\n\n\n00143400     IF &LVL1 = &STR() THEN SET &LVL1 = &DOCSLVL1\n\n\n00143503     IF &LVL2 = &STR() THEN SET &LVL2 = &DOCSLVL2\n\n\n00143600     SET OSDOC = &SAMPDOC\n\n\n00143700     SET OSNDEX = &SAMPNDEX\n\n\n00143800     SET SAMPDOC = '&LVL1..&LVL2..CONTROL(PATTERN)'\n\n\n00143902     SET SAMPNDEX = '&DOCSLVL1..&DOCSLVL2..INDEXES(CONTROL)'\n\n\n00144000     ISPEXEC VPUT (LVL1 LVL2 SAMPDOC SAMPNDEX DTYPE OSDOC OSNDEX)\n\n\n00145000     ENDO\n\n\n00146000  IF &SET = OFF THEN +\n\n\n00147000     DO\n\n\n00147100     SET DTYPE =\n\n\n00147200     SET LVL1 =\n\n\n00147300     SET LVL2 =\n\n\n00147400     ISPEXEC VGET (OSDOC OSNDEX)\n\n\n00147700     SET SAMPDOC = &OSDOC\n\n\n00147800     SET SAMPNDEX = &OSNDEX\n\n\n00147900     ISPEXEC VPUT (LVL1 LVL2 SAMPDOC SAMPNDEX DTYPE) SHARED\n\n\n00170000     ENDO\n\n\n./ ADD NAME=DOCSYS   0104-85177-86254-1643-00060-00014-00053-KK00150\n00010000  CONTROL NOMSG NOFLUSH END(ENDO)\n\n\n00011003  IF &SYSPREF = KX00150 THEN CONTROL LIST MSG CONLIST\n\n\n00013004  CLOG '&SYSDATE &SYSTIME &SYSICMD' U($$$$150) SAVE\n\n\n00020000  FREE F(SYSOUT)\n\n\n00021000  IFALC F(SYSOUT)\n\n\n00022000  IF &LASTCC NE 0 THEN ALLOC F(SYSOUT) DSN(*)\n\n\n00040000  SET &DOCSLVL1 =  WDPSC\n\n\n00050000  SET &DOCSLVL2 = DOCSYS\n\n\n00060000  SET &DOCSTITL = &STR(WDPSC DOCUMENTATION SYSTEM)\n\n\n00060102  SET &GPML = &STR(PLEASE WAIT - INDEXES ARE BEING LOADED)\n\n\n00060202  ISPEXEC VPUT (DOCSLVL1 DOCSLVL2 DOCSTITL GPML)\n\n\n00060302  ISPEXEC CONTROL DISPLAY LOCK\n\n\n00060402  ISPEXEC DISPLAY PANEL(GPM)\n\n\n00060502\n\n\n00066102  GETMY ACFUID\n\n\n00066202  SET U = &SUBSTR(1:10,&ACFUID)\n\n\n00066302  IF &U = &STR(150D3100CS) OR &U = &STR(150D360004) OR &U = &STR(150D210\n0  ) THEN +\n\n00066402     DO\n\n\n00066502     SET &LIB = TECHBULL\n\n\n00066602     SET &SAMPDOC = '&DOCSLVL1..&DOCSLVL2..TECHBULL(MEMO1)'\n\n\n00066702     SET ACTTAB = &STR(S,SEL P,PRT E,EDT)\n\n\n00066802     SET THDA1 = &STR(\u00a2         USE \"PF3\u00a2TO EXIT,\"PF5\u00a2TO CHANGE INDEX,\"P\nF6\u00a2TO ADD AN ENTRY)\n\n00066902     SET THDA2 = &STR(\u00a2             OPTIONS ARE\"S\u00a2FOR BROWSE,\"P\u00a2FOR PRIN\nT,\"E\u00a2FOR EDIT)\n\n00067002     SET DOCUPDT = YES\n\n\n00067102     ISPEXEC VPUT (ACTTAB,THDA1,THDA2,SAMPDOC,LIB,DOCUPDT) SHARED\n\n\n00067202     ENDO\n\n\n00067302  ELSE +\n\n\n00067402     DO\n\n\n00067502     SET DOCUPDT = NO\n\n\n00067602     ISPEXEC VPUT DOCUPDT SHARED\n\n\n00067702     ENDO\n\n\n00067802\n\n\n00067902RESHOW: +\n\n\n00068002  SET &DOCSMEM = PRIM\n\n\n00068102  SET &DOCSEXIT = NO\n\n\n00068202  ISPEXEC VPUT (DOCSMEM DOCSEXIT)\n\n\n00141002  ISPEXEC SELECT PGM(PANLEXIT) PARM(TBLHNDLR,1,PRIME)\n\n\n00142202  ISPEXEC VGET DOCRSHOW SHARED\n\n\n00142302  IF &DOCRSHOW = YES THEN +\n\n\n00142402    DO\n\n\n00142502    SET DOCRSHOW =\n\n\n00142602    ISPEXEC VPUT DOCRSHOW SHARED\n\n\n00142702    GOTO RESHOW\n\n\n00142802    ENDO\n\n\n00142902\n\n\n00143002  IF &U = &STR(150D3100CS) OR &U = &STR(150D360004) OR &U = &STR(150D210\n0  ) THEN +\n\n00143102    DO\n\n\n00143202    SET THDA1 = &STR()\n\n\n00143302    SET THDA2 = &STR()\n\n\n00143402    SET ACTTAB = &STR(S,SEL P,PRT)\n\n\n00143502    SET &SAMPDOC =\n\n\n00143602    SET DOCUPDT =\n\n\n00143702    SET &LIB =\n\n\n00143802    ISPEXEC VPUT (ACTTAB,THDA1,THDA2 DOCUPDT SAMPDOC LIB) SHARED\n\n\n00143902    ENDO\n\n\n00144002  ELSE +\n\n\n00144102    DO\n\n\n00144202    SET DOCUPDT =\n\n\n00144302    ISPEXEC VPUT DOCUPDT SHARED\n\n\n00144402    ENDO\n\n\n./ ADD NAME=DOCTECH  0116-85120-86254-1643-00030-00016-00030-KK00150\n00010004  CONTROL NOMSG NOFLUSH END(ENDO)\n\n\n00020015  IF &SYSPREF = KX00150 THEN CONTROL LIST MSG CONLIST\n\n\n00030016  CLOG '&SYSDATE &SYSTIME &SYSICMD' U($$$$150) SAVE\n\n\n00040004  IFALC F(SYSOUT)\n\n\n00050004  IF &LASTCC NE 0 THEN ALLOC F(SYSOUT) DSN(*)\n\n\n00060004  SET &DOCSLVL1 =  SOFTD150\n\n\n00070004  SET &DOCSLVL2 = DOCSYS\n\n\n00080004  SET &DOCSTITL = &STR(TECHNICAL SERVICES DOC SYSTEM)\n\n\n00100004  SET &DOCSEXIT = NO\n\n\n00110004  SET &GPML = &STR(PLEASE WAIT - INDEXES ARE BEING LOADED)\n\n\n00120011  ISPEXEC VPUT (DOCSLVL1 DOCSLVL2 DOCSTITL DOCSEXIT GPML)\n\n\n00130004  ISPEXEC CONTROL DISPLAY LOCK\n\n\n00140004  ISPEXEC DISPLAY PANEL(GPM)\n\n\n00141010RESHOW: +\n\n\n00142011  SET &DOCSMEM = TECHPRIM\n\n\n00150004  SET ACTTAB = &STR(S,SEL P,PRT X,XFR Z,ZIP E,EDT)\n\n\n00151013  SET THDA1 = &STR(\u00a2         USE \"PF3\u00a2TO EXIT,\"PF5\u00a2TO CHANGE INDEX,\"PF6\u00a2\nTO ADD AN ENTRY)\n\n00151113  SET THDA2 = &STR(\u00a2          SELECT OPTIONS ARE\"S\u00a2FOR BROWSE,\"P\u00a2FOR PRI\nNT,\"E\u00a2FOR EDIT)\n\n00152008  SET DOCUPDT = YES\n\n\n00160012  ISPEXEC VPUT (ACTTAB,THDA1,THDA2,LIB DOCUPDT DOCSMEM) SHARED\n\n\n00170015  ISPEXEC SELECT PGM(PANLEXIT) PARM(TBLHNDLR,1,PRIME)\n\n\n00180014  SET THDA1 = &STR()\n\n\n00180114  SET THDA2 = &STR()\n\n\n00181008  SET DOCUPDT =\n\n\n00190014  ISPEXEC VPUT (ACTTAB,THDA1,THDA2 DOCUPDT) SHARED\n\n\n00260010  ISPEXEC VGET DOCRSHOW SHARED\n\n\n00270010  IF &DOCRSHOW NE YES THEN EXIT\n\n\n00280010  SET DOCRSHOW =\n\n\n00290010  ISPEXEC VPUT DOCRSHOW SHARED\n\n\n00300010  GOTO RESHOW\n\n\n./ ADD NAME=DOCTMERG 0100-86204-86204-1516-00042-00042-00000-KK00150\n00001000ISREDIT MACRO (L)\n\n\n00001100IF &L NE &STR() THEN CONTROL LIST CONLIST\n\n\n00001200IF &SYSPREF = KX00150 THEN CONTROL MSG LIST CONLIST\n\n\n00001300/* DONT TOSS THIS IT'S USED IN STATUS RPT SYSTEM  */\n\n\n00002000ISREDIT NUMBER OFF\n\n\n00003000CONTROL NOFLUSH END(ENDO)\n\n\n00004000ISPEXEC CONTROL ERRORS RETURN\n\n\n00005900SET &MEMNAME = &STR()\n\n\n00006000ISREDIT BOUNDS 1 74\n\n\n00006100ISREDIT (DATA1) = DATAID\n\n\n00006200ISREDIT (MEMNAME) = MEMBER\n\n\n00150000IF &MEMNAME = ALL THEN +\n\n\n00151000   DO\n\n\n00151200   ISREDIT DELETE ALL NX\n\n\n00152000   ISREDIT DEFINE DOCSMERG CMD MACRO\n\n\n00160100   ISREDIT COPY PATTERN AFTER 0\n\n\n00160200   ISREDIT RESET SPECIAL\n\n\n00162000   ISREDIT (CURMBR) = MEMBER\n\n\n00163000   ISPEXEC LMOPEN DATAID(&DATA1) OPTION(INPUT)\n\n\n00164000   SET LMRC = &LASTCC\n\n\n00165000      DO WHILE (&LMRC = 0)\n\n\n00166000      ISPEXEC LMMLIST DATAID(&DATA1) MEMBER(MEMBER) STATS(YES)\n\n\n00167000      SET LMRC = &LASTCC\n\n\n00168000      IF &LMRC = 0 AND &ZLCNORC NE 0 THEN +\n\n\n00169000         DO\n\n\n00169100         IF (&MEMBER NE &CURMBR) AND +\n\n\n00169200            (&MEMBER NE PATTERN) AND +\n\n\n00169300            (&MEMBER NE SCRIPT) AND +\n\n\n00169500            (&MEMBER NE FINAL) THEN +\n\n\n00169600               DO\n\n\n00169700               ISREDIT DOCQMERG &MEMBER &L\n\n\n00169800               ISPEXEC VGET HAVDATA\n\n\n00169900               IF &HAVDATA = YES THEN +\n\n\n00170000               ISREDIT LINE_AFTER 0 = MSGLINE +\n\n\n00170100                  '&MEMBER HAS TURNED IN A STATUS REPORT - &ZLMDATE.'\n\n\n00170200               ENDO\n\n\n00170300         ENDO\n\n\n00170400      ENDO\n\n\n00170500   ISREDIT UP MAX\n\n\n00170600   ISPEXEC LMMLIST DATAID(&DATA1) OPTION(FREE)\n\n\n00171000   ISPEXEC LMCLOSE DATAID(&DATA1)\n\n\n00180000   ENDO\n\n\n./ ADD NAME=DOCTOPRT 0100-84086-84086-1417-00050-00050-00000-KK00150\n00011000PROC 6 DUMMYA DUMMYB LISTLIB HIQ MIDQ DDESC\n\n\n00020000CONTROL NOFLUSH END(ENDO)\n\n\n00030000IF &STR(&LISTLIB) = DUMMY1 THEN +\n\n\n00040000    DO\n\n\n00041000     SET &GPM = NO PRINT AVAILABLE\n\n\n00042000     SET &GPML = NO PRINT IS AVAILABLE FOR THIS SELECTION\n\n\n00050000     ISPEXEC SETMSG MSG(GPM001)\n\n\n00060000     EXIT\n\n\n00070000    ENDO\n\n\n00070100\n\n\n00070200          ISPEXEC VGET (DOCSLVL1 DOCSLVL2 DOCSTITL)\n\n\n00070300          SET &DOCSAVL1 = &DOCSLVL1\n\n\n00070400          SET &DOCSAVL2 = &DOCSLVL2\n\n\n00070500          SET &DOCSAITL = &DOCSTITL\n\n\n00070600          SET &DOCSLVL1 = &HIQ\n\n\n00070700          SET &DOCSLVL2 = &MIDQ\n\n\n00070800          SET &DOCSTITL = &STR(&DDESC)\n\n\n00070900          ISPEXEC VPUT (DOCSLVL1 DOCSLVL2 DOCSTITL)\n\n\n00071000\n\n\n00080000SET PL = &LENGTH(&STR(&LISTLIB))\n\n\n00090000IF &SUBSTR(&PL-1,&STR(&LISTLIB)) = &STR(-) THEN +\n\n\n00100000  DO\n\n\n00110000   SET PT = &SUBSTR(&PL,&STR(&LISTLIB))\n\n\n00120000   SET &LISTLIB = &SUBSTR(1:&PL-2,&STR(&LISTLIB))\n\n\n00130000  ENDO\n\n\n00140000  ELSE SET PT = 1\n\n\n00141000SET &PDOCN = &DOCSLVL1..&DOCSLVL2..&LISTLIB\n\n\n00141200\n\n\n00142200ISPEXEC SELECT PGM(PASSDEST)\n\n\n00142300ISPEXEC VGET DEFDEST\n\n\n00142400IF &DEFDEST = LOCAL THEN SET DEFDEST = WDPSC\n\n\n00142500\n\n\n00142600GETMY PROG SYS ACCT\n\n\n00142700\n\n\n00142800ISPEXEC VGET (PSOC PDEST PACCT PJOBC PPROG PCOPIES)\n\n\n00142900\n\n\n00143000IF &PDEST = THEN SET &PDEST = &DEFDEST\n\n\n00143100IF &PSOC = THEN SET &PSOC = A\n\n\n00143200IF &STR(&PACCT) = THEN SET &PACCT = &STR(&ACCT)\n\n\n00143300IF &STR(&PPROG) = THEN SET &PPROG = &PROG\n\n\n00143400IF &PJOBC = THEN SET &PJOBC = D\n\n\n00143500IF &PCOPIES = THEN SET &PCOPIES = 1\n\n\n00143600\n\n\n00143700ISPEXEC VPUT (PDOCN PSOC PDEST PACCT PJOBC PPROG PCOPIES)\n\n\n00143800\n\n\n00143900ISPEXEC SELECT PANEL(DOCPM&PT)\n\n\n00144000          SET &DOCSLVL1 = &DOCSAVL1\n\n\n00145000          SET &DOCSLVL2 = &DOCSAVL2\n\n\n00146000          SET &DOCSTITL = &DOCSAITL\n\n\n00147000          ISPEXEC VPUT (DOCSLVL1 DOCSLVL2 DOCSTITL)\n\n\n./ ADD NAME=DOCTOSEL 0111-84086-86254-1656-00027-00019-00027-KK00150\n00010010  PROC 6 MEMNAME ENTRYCNT DUMMY1 HIQ MIDQ DDESC\n\n\n00020010  CONTROL NOMSG NOFLUSH END(ENDO)\n\n\n00021010  IF &SYSPREF = KX00150 THEN CONTROL LIST MSG CONLIST\n\n\n00021111  GETMY ACFUID\n\n\n00022011  IF &SUBSTR(1:4,&ACFUID) NE &STR(150D) THEN +\n\n\n00023010     DO\n\n\n00024010     SET GPM = NOT AVAILABLE\n\n\n00024110     SET GPML = THIS SELECTION RESTRICTED TO WDPSC PERSONNEL\n\n\n00025010     ISPEXEC SETMSG MSG(GPM001)\n\n\n00025110     EXIT\n\n\n00026010     ENDO\n\n\n00030010  ISPEXEC VGET (DOCSLVL1 DOCSLVL2 DOCSTITL)\n\n\n00040010  SET &DOCSAVL1 = &DOCSLVL1\n\n\n00050010  SET &DOCSAVL2 = &DOCSLVL2\n\n\n00060010  SET &DOCSAITL = &DOCSTITL\n\n\n00070010  SET &DOCSLVL1 = &HIQ\n\n\n00080010  SET &DOCSLVL2 = &MIDQ\n\n\n00090010  SET &DOCSTITL = &STR(&DDESC)\n\n\n00100010  ISPEXEC VPUT (DOCSLVL1 DOCSLVL2 DOCSTITL)\n\n\n00141010  SET &DOCSMEM = &MEMNAME\n\n\n00142010  ISPEXEC VPUT DOCSMEM\n\n\n00143010  IF &MEMNAME = PRIM THEN SET &MEMNAME = PRIMET\n\n\n00150010  ISPEXEC SELECT PGM(TBLHNDLR) PARM(&ENTRYCNT,&MEMNAME)\n\n\n00160010  SET &DOCSLVL1 = &DOCSAVL1\n\n\n00170010  SET &DOCSLVL2 = &DOCSAVL2\n\n\n00180010  SET &DOCSTITL = &DOCSAITL\n\n\n00190010  ISPEXEC VPUT (DOCSLVL1 DOCSLVL2 DOCSTITL)\n\n\n./ ADD NAME=DOCUPDAT 0102-86169-86169-1845-00054-00052-00003-KK00150\n00010000PROC 3 A B C DATAIDS\n\n\n00020000CONTROL NOMSG NOFLUSH END(ENDO)\n\n\n00021000IF &SYSPREF = KX00150 THEN CONTROL MSG CONLIST LIST\n\n\n00030000\n\n\n00061000/*  OPEN CONTROL FILE:    */\n\n\n00061100\n\n\n00061300   SET D1 = &STR(&A)\n\n\n00061400   SET D2 = &STR(&C)\n\n\n00061500   IF &DATAIDS = DATAIDS THEN +\n\n\n00061600      DO\n\n\n00061700      ISPEXEC LMQUERY DATAID(&A) DATASET(D1)\n\n\n00061800      ISPEXEC LMQUERY DATAID(&C) DATASET(D2)\n\n\n00061900      GOTO O\n\n\n00062000      ENDO\n\n\n00069300   ISPEXEC LMINIT DATAID(C) DATASET(&D2) ENQ(SHR)\n\n\n00069500   IF &LASTCC NE 0 THEN +\n\n\n00069600      DO\n\n\n00070400ERRX: SET &GPM = &STR(&ZERRSM)\n\n\n00070500      SET &GPML = &STR(&ZERRLM)\n\n\n00070600      ISPEXEC SETMSG MSG(GPM001)\n\n\n00070900      EXIT CODE(99)\n\n\n00071000      ENDO\n\n\n00071100O: ISPEXEC LMOPEN DATAID(&C)\n\n\n00071200   SET ORC2 = &LASTCC\n\n\n00071300   IF &ORC2 NE 0 AND &ORC2 NE 12 THEN GOTO ERRX\n\n\n00071400   ISPEXEC LMMFIND DATAID(&C) MEMBER(&B) STATS(YES)\n\n\n00071500   IF &LASTCC NE 0 THEN GOTO ERRX\n\n\n00071600   SET CDATE = &STR(&ZLMDATE)\n\n\n00071700   SET CTIME = &STR(&ZLMTIME)\n\n\n00071800\n\n\n00071900\n\n\n00072000/*  OPEN STATUS FILE:    */\n\n\n00072100\n\n\n00072200IF &DATAIDS = DATAIDS THEN GOTO O2\n\n\n00072300ISPEXEC LMINIT DATAID(A) DATASET('&D1') ENQ(SHR)\n\n\n00103100IF &LASTCC NE 0 THEN GOTO ERRX\n\n\n00103800O2: +\n\n\n00103900ISPEXEC LMOPEN DATAID(&A)\n\n\n00104000SET ORC1 = &LASTCC\n\n\n00104100IF &ORC1 NE 0 AND &ORC1 NE 12 THEN GOTO ERRX\n\n\n00104200ISPEXEC LMMFIND DATAID(&A) MEMBER(&B) STATS(YES)\n\n\n00104300SET RC = &LASTCC\n\n\n00104400IF &RC NE 0 AND &RC NE 8 THEN GOTO ERRX\n\n\n00104500IF &ZLMDATE NE &CDATE OR &ZLMTIME NE &CTIME OR &RC = 8 THEN +\n\n\n00104600  DO\n\n\n00104702  SET &SYSOUTTRAP = 9\n\n\n00105101  PDS &D2 COPY &B &D1 REPLACE SHR NOLIST\n\n\n00105202  SET &SYSOUTTRAP = 0\n\n\n00106000  ENDO\n\n\n00107000\n\n\n00108000IF &ORC1 = 0 THEN +\n\n\n00140000  ISPEXEC LMCLOSE DATAID(&A)\n\n\n00141000IF &ORC2 = 0 THEN +\n\n\n00150000  ISPEXEC LMCLOSE DATAID(&C)\n\n\n./ ADD NAME=DOCWMERG 0102-86168-86168-1557-00096-00096-00002-KK00150\n00010000ISREDIT MACRO (MNAME,L)\n\n\n00012002IF &SYSPREF = KX00150 THEN CONTROL LIST CONLIST\n\n\n00020000/* DONT TOSS THIS IT'S USED IN STATUS RPT SYSTEM  */\n\n\n00030000ISREDIT NUMBER OFF\n\n\n00040000CONTROL NOFLUSH END(ENDO)\n\n\n00050000ISPEXEC CONTROL ERRORS RETURN\n\n\n00060000/*                                                                   */\n\n\n00061000/* LABEL LAST PATTERN LINE                                   */\n\n\n00062000/*                                                                   */\n\n\n00063100ISREDIT LABEL .ZL = .ENDPAT\n\n\n00071000/*                                                                   */\n\n\n00080000/* COPY  member at end of pattern                                    */\n\n\n00081000/*                                                                   */\n\n\n00090000ISREDIT COPY &MNAME AFTER .ENDPAT\n\n\n00091000SET &HAVDATA = NO    /* SAY NO GOOD DATA AT FIRST  */\n\n\n00100000ISREDIT (LN) = LINENUM .ENDPAT\n\n\n00102000SET &LN = &LN+1\n\n\n00102100ISREDIT LABEL &LN = .MSTART\n\n\n00103000ISREDIT LABEL .ZL = .MEND\n\n\n00103102ISREDIT CHANGE X'50' X'5050' .MSTART .MEND ALL  /* ampers make havok */\n\n\n00104000/*                                                                   */\n\n\n00110000/* LOOP: FIND TOPIC LINE                                             */\n\n\n00110100/*                                                                   */\n\n\n00110200ISREDIT LABEL 1 = .CURTOP\n\n\n00111000SET &MD = GO\n\n\n00120000   DO WHILE &MD = GO\n\n\n00121000   ISREDIT CURSOR = .CURTOP       /*  KERMIT CHANGE TIL UZ41259 */\n\n\n00130000   ISREDIT FIND X'AA'\n\n\n00131000   IF &LASTCC = 0 THEN +\n\n\n00132000      DO\n\n\n00133000/*                                                                   */\n\n\n00140000/*       search for matching topic                                   */\n\n\n00140100/*                                                                   */\n\n\n00140200      ISREDIT (CURTOP) = LINENUM .ZCSR\n\n\n00140300      ISREDIT (ENDPAT) = LINENUM .ENDPAT\n\n\n00140400      IF &CURTOP > &ENDPAT THEN GOTO DONE /* CHECK RE UZ41259 */\n\n\n00140500      SET &CURTOP = &CURTOP+2 /* POINT PAST UNDERLINE AND 1ST BLANK LINE\nS */\n\n00141000      ISREDIT (TOPIC) = LINE .ZCSR\n\n\n00141100      SET &TOPIC = &SUBSTR(1:50,&STR(&TOPIC))\n\n\n00141300      ISREDIT (XX) = LINENUM .MSTART\n\n\n00141400      ISREDIT CURSOR = &XX\n\n\n00142000      ISREDIT FIND '&TOPIC' .MSTART .MEND NEXT\n\n\n00143000/*                                                                   */\n\n\n00150000/*       IF MATCH: GET 1ST (&FL) AND LAST (&LL) LINE NOS.            */\n\n\n00150100/*                                                                   */\n\n\n00151000      IF &LASTCC = 0 THEN +\n\n\n00152000         DO\n\n\n00153000         ISREDIT (FL) = LINENUM .ZCSR\n\n\n00153100         SET &FL = &FL + 1\n\n\n00154000         ISREDIT LABEL &FL = .TSTART\n\n\n00154200         ISREDIT (XZ) = LINENUM .ZCSR\n\n\n00154300         SET XZ = &XZ + 1\n\n\n00154400         ISREDIT LABEL &XZ = .TSEARCH\n\n\n00155000         ISREDIT FIND X'AA' .TSEARCH .MEND NEXT\n\n\n00156000         IF &LASTCC = 0 THEN +\n\n\n00156100           DO\n\n\n00156200           ISREDIT (LL) = LINENUM .ZCSR\n\n\n00156300           SET LL = &LL - 1\n\n\n00156400           ENDO\n\n\n00158000         ELSE ISREDIT (LL) = LINENUM .ZL\n\n\n00158100/*                                                                   */\n\n\n00158200/*        LOOP TO DELETE ANY LEADING BLANK LINES:                    */\n\n\n00158400/*                                                                   */\n\n\n00159000           DO WHILE &FL LE &LL\n\n\n00159100           ISREDIT (LINE) = LINE &FL\n\n\n00159300           SET &BLANKS = &SUBSTR(1:80,&STR(\n                                                              ))\n\n00159500           IF &SUBSTR(1:80,&STR(&LINE)) = &BLANKS OR +\n\n\n00159600              &SUBSTR(1:3,&STR(&LINE)) = &STR(+ _) THEN +\n\n\n00159700              SET &FL = &FL +1\n\n\n00159800           ELSE +\n\n\n00159900              DO\n\n\n00160000              SET &HAVDATA = YES\n\n\n00160100/*                                                                   */\n\n\n00160200/*                 copy adjusted line nos from mem                   */\n\n\n00160300/*                 after topic line                                  */\n\n\n00160400/*                                                                   */\n\n\n00160500              ISREDIT (OFFSET) = LINENUM .ENDPAT\n\n\n00160600              SET FL = &FL-&OFFSET\n\n\n00160700              SET LL = &LL-&OFFSET\n\n\n00160800              IF &FL > &LL THEN WRITE FL > LL IN MERGSTAT\n\n\n00160900              ISREDIT COPY &MNAME AFTER &CURTOP &FL &LL\n\n\n00161000              GOTO DONECOPY\n\n\n00161100              ENDO\n\n\n00161300           ENDO\n\n\n00161400         ENDO\n\n\n00161700      DONECOPY: ISREDIT LABEL &CURTOP = .CURTOP\n\n\n00161800      ENDO\n\n\n00162000   ELSE SET &MD = STOP\n\n\n00170000   ENDO\n\n\n00171000/*                                                                   */\n\n\n00180000/* no more topics: delete copied member from end                     */\n\n\n00180100/*                                                                   */\n\n\n00181000DONE: ISREDIT DELETE .MSTART .MEND\n\n\n00181100ISPEXEC VPUT HAVDATA\n\n\n00182000/*                                                                   */\n\n\n00190000/* return                                                            */\n\n\n./ ADD NAME=DOC01EDT 0103-85179-86190-1820-00004-00004-00002-KX00150\n00010002  PROC 3 MEMNAME ENTRYCNT DUMMY1 TYPE() D1() D2() D3()\n\n\n00020000  CONTROL NOMSG NOFLUSH END(ENDO)\n\n\n00021000  ISPEXEC VGET (DOCSLVL1 DOCSLVL2)\n\n\n00150003  ISPEXEC EDIT   DATASET('&DOCSLVL1..&DOCSLVL2..INDEXES(&MEMNAME)') MACR\nO(DOCEDUP)\n\n./ ADD NAME=DOC01PRT 0116-83336-86189-1705-00039-00007-00036-KK00150\n00010016PROC 3 DUMMYA DUMMYB LISTLIB TYPE() D1() D2() D3()\n\n\n00020010CONTROL NOFLUSH END(ENDO)\n\n\n00021011ISPEXEC VGET DOCSLVL1\n\n\n00022011ISPEXEC VGET DOCSLVL2\n\n\n00030012IF &STR(&LISTLIB) = DUMMY1 THEN +\n\n\n00040000    DO\n\n\n00041001     SET &GPM = NO PRINT AVAILABLE\n\n\n00042001     SET &GPML = NO PRINT IS AVAILABLE FOR THIS SELECTION\n\n\n00050001     ISPEXEC SETMSG MSG(GPM001)\n\n\n00060000     EXIT\n\n\n00070000    ENDO\n\n\n00071006\n\n\n00080012SET PL = &LENGTH(&STR(&LISTLIB))\n\n\n00090012IF &SUBSTR(&PL-1,&STR(&LISTLIB)) = &STR(-) THEN +\n\n\n00100002  DO\n\n\n00110012   SET PT = &SUBSTR(&PL,&STR(&LISTLIB))\n\n\n00120012   SET &LISTLIB = &SUBSTR(1:&PL-2,&STR(&LISTLIB))\n\n\n00130002  ENDO\n\n\n00140002  ELSE SET PT = 1\n\n\n00141012SET &PDOCN = &DOCSLVL1..&DOCSLVL2..&LISTLIB\n\n\n00141206\n\n\n00142204ISPEXEC SELECT PGM(PASSDEST)\n\n\n00142306ISPEXEC VGET DEFDEST\n\n\n00142406IF &DEFDEST = LOCAL THEN SET DEFDEST = WDPSC\n\n\n00142506\n\n\n00142606GETMY PROG SYS ACCT\n\n\n00142706\n\n\n00142807ISPEXEC VGET (PSOC PDEST PACCT PJOBC PPROG PCOPIES)\n\n\n00142906\n\n\n00143006IF &PDEST = THEN SET &PDEST = &DEFDEST\n\n\n00143106IF &PSOC = THEN SET &PSOC = A\n\n\n00143206IF &STR(&PACCT) = THEN SET &PACCT = &STR(&ACCT)\n\n\n00143314IF &STR(&PPROG) = THEN SET &PPROG = &STR(&PROG)\n\n\n00143406IF &PJOBC = THEN SET &PJOBC = D\n\n\n00143506IF &PCOPIES = THEN SET &PCOPIES = 1\n\n\n00143604\n\n\n00143707ISPEXEC VPUT (PDOCN PSOC PDEST PACCT PJOBC PPROG PCOPIES)\n\n\n00143806\n\n\n00143903ISPEXEC SELECT PANEL(DOCPM&PT)\n\n\n./ ADD NAME=DOC01SEL 0113-83335-86189-1807-00025-00006-00000-KX00150\n          PROC 3 MEMNAME ENTRYCNT DUMMY1 TYPE() D1() D2() D3()\n\n\n          CONTROL NOMSG NOFLUSH END(ENDO)\n\n\n          IF &SYSPREF = KX00150 THEN CONTROL LIST MSG CONLIST\n\n\n          IF &D1 NE &STR() THEN SET &D1 = D1(&D1)\n\n\n          IF &D2 NE &STR() THEN SET &D2 = D2(&D2)\n\n\n          IF &D3 NE &STR() THEN SET &D3 = D3(&D3)\n\n\n          ISPEXEC VGET DOCSMEM\n\n\n          SET SAVEMEM = &DOCSMEM\n\n\n        RESHOW: +\n\n\n          SET &DOCSMEM = &MEMNAME\n\n\n          ISPEXEC VPUT (DOCSMEM ENTRYCNT) SHARED\n\n\n          IF &TYPE NE &STR() THEN &TYPE ON &D1 &D2 &D3\n\n\n          ISPEXEC SELECT PGM(PANLEXIT) PARM(TBLHNDLR,&ENTRYCNT,&MEMNAME)\n\n\n          SET RC = &LASTCC\n\n\n          IF &SYSPREF = KX00150 THEN WRITE LASTCC WAS &RC\n\n\n          IF &TYPE NE &STR() THEN &TYPE OFF &D1 &D2 &D3\n\n\n          SET &DOCSMEM = &SAVEMEM\n\n\n          ISPEXEC VPUT (DOCSMEM) SHARED\n\n\n          ISPEXEC VGET DOCRSHOW SHARED\n\n\n          IF &DOCRSHOW = YES THEN +\n\n\n            DO\n\n\n            SET DOCRSHOW =\n\n\n            ISPEXEC VPUT DOCRSHOW SHARED\n\n\n            GOTO RESHOW\n\n\n            ENDO\n\n\n./ ADD NAME=DOC02EDT 0100-85179-85179-1630-00011-00011-00000-KX00150\n        PROC 3 A B C\n\n\n        CONTROL NOFLUSH END(ENDO)\n\n\n\n\n\n        SET PL = &LENGTH(&STR(&C))\n\n\n        IF &SUBSTR(&PL-1,&STR(&C)) = &STR(-) THEN +\n\n\n           SET &C = &SUBSTR(1:&PL-2,&STR(&C))\n\n\n\n\n\n        IF &C = DUMMY1 THEN SET &PDOCN = &A(&B)\n\n\n                       ELSE SET &PDOCN = &C\n\n\n\n\n\n        ISPEXEC EDIT   DATASET('&PDOCN')\n\n\n./ ADD NAME=DOC02PRT 0101-84081-84081-1357-00032-00034-00032-KK00150\n00010001PROC 3 A B C\n\n\n00020001CONTROL NOFLUSH END(ENDO)\n\n\n00071001\n\n\n00080001SET PL = &LENGTH(&STR(&C))\n\n\n00090001IF &SUBSTR(&PL-1,&STR(&C)) = &STR(-) THEN +\n\n\n00100001  DO\n\n\n00110001   SET PT = &SUBSTR(&PL,&STR(&C))\n\n\n00120001   SET &C = &SUBSTR(1:&PL-2,&STR(&C))\n\n\n00130001  ENDO\n\n\n00140001  ELSE SET PT = 1\n\n\n00140101\n\n\n00141001IF &C = DUMMY1 THEN SET &PDOCN = &A(&B)\n\n\n00141101               ELSE SET &PDOCN = &C\n\n\n00141201\n\n\n00142201ISPEXEC SELECT PGM(PASSDEST)\n\n\n00142301ISPEXEC VGET DEFDEST\n\n\n00142401IF &DEFDEST = LOCAL THEN SET DEFDEST = WDPSC\n\n\n00142501\n\n\n00142601GETMY PROG SYS ACCT\n\n\n00142701\n\n\n00142801ISPEXEC VGET (PSOC PDEST PACCT PJOBC PPROG PCOPIES)\n\n\n00142901\n\n\n00143001IF &PDEST = THEN SET &PDEST = &DEFDEST\n\n\n00143101IF &PSOC = THEN SET &PSOC = A\n\n\n00143201IF &STR(&PACCT) = THEN SET &PACCT = &STR(&ACCT)\n\n\n00143301IF &STR(&PPROG) = THEN SET &PPROG = &STR(&PROG)\n\n\n00143401IF &PJOBC = THEN SET &PJOBC = D\n\n\n00143501IF &PCOPIES = THEN SET &PCOPIES = 1\n\n\n00143601\n\n\n00143701ISPEXEC VPUT (PDOCN PSOC PDEST PACCT PJOBC PPROG PCOPIES)\n\n\n00143801\n\n\n00143901ISPEXEC SELECT PANEL(DOCPM&PT)\n\n\n./ ADD NAME=DOC02SEL 0102-84081-87034-1823-00019-00010-00000-KK00150\n        PROC 3 A B C\n\n\n        CONTROL NOFLUSH END(ENDO)\n\n\n\n\n\n        SET PL = &LENGTH(&STR(&C))\n\n\n        IF &SUBSTR(&PL-1,&STR(&C)) = &STR(-) THEN +\n\n\n           SET &C = &SUBSTR(1:&PL-2,&STR(&C))\n\n\n\n\n\n        IF &C = DUMMY1 THEN SET &PDOCN = &A(&B)\n\n\n                       ELSE SET &PDOCN = &C\n\n\n\n\n\n        ISPEXEC CONTROL ERRORS RETURN\n\n\n        ISPEXEC BROWSE DATASET('&PDOCN')\n\n\n        IF &LASTCC NE 0 THEN +\n\n\n            DO\n\n\n            SET &GPM = &STR(NOT AVAILABLE)\n\n\n            SET &GPML = THE ITEM SELECTED MAY BE EMPTY\n\n\n            ISPEXEC SETMSG MSG(GPM001)\n\n\n            EXIT\n\n\n            ENDO\n\n\n./ ADD NAME=DOC03EDT 0100-85179-85179-1635-00010-00010-00000-KX00150\n        PROC 3 LISTLIB MEMNAME OPTLIB\n\n\n        CONTROL MSG NOFLUSH END(ENDO)\n\n\n        ISPEXEC VGET DOCSLVL1\n\n\n        ISPEXEC VGET DOCSLVL2\n\n\n        SET PL = &LENGTH(&STR(&OPTLIB))\n\n\n        IF &SUBSTR(&PL-1,&STR(&OPTLIB)) = &STR(-) THEN +\n\n\n           SET &OPTLIB = &SUBSTR(1:&PL-2,&STR(&OPTLIB))\n\n\n        IF &OPTLIB = DUMMY1 THEN SET &LOWQUAL = &STR(&LISTLIB(&MEMNAME))\n\n\n               ELSE SET &LOWQUAL = &OPTLIB\n\n\n        ISPEXEC EDIT   DATASET('&DOCSLVL1..&DOCSLVL2..&LOWQUAL')\n\n\n./ ADD NAME=DOC03PRT 0107-83341-84032-1639-00034-00037-00007-JS02150\n00012000PROC 3 A B C\n\n\n00020000CONTROL NOFLUSH END(ENDO)\n\n\n00030006ISPEXEC VGET DOCSLVL1\n\n\n00040006ISPEXEC VGET DOCSLVL2\n\n\n00071005\n\n\n00080000SET PL = &LENGTH(&STR(&C))\n\n\n00090000IF &SUBSTR(&PL-1,&STR(&C)) = &STR(-) THEN +\n\n\n00100000  DO\n\n\n00110000   SET PT = &SUBSTR(&PL,&STR(&C))\n\n\n00120000   SET &C = &SUBSTR(1:&PL-2,&STR(&C))\n\n\n00130000  ENDO\n\n\n00140000  ELSE SET PT = 1\n\n\n00140102\n\n\n00140206IF &C = DUMMY1 THEN SET &PDOCN = &DOCSLVL1..&DOCSLVL2..&A(&B)\n\n\n00140306               ELSE SET &PDOCN = &DOCSLVL1..&DOCSLVL2..&C\n\n\n00141100\n\n\n00142200ISPEXEC SELECT PGM(PASSDEST)\n\n\n00142300ISPEXEC VGET DEFDEST\n\n\n00142400IF &DEFDEST = LOCAL THEN SET DEFDEST = WDPSC\n\n\n00142500\n\n\n00142600GETMY PROG SYS ACCT\n\n\n00142700\n\n\n00142800ISPEXEC VGET (PSOC PDEST PACCT PJOBC PPROG PCOPIES)\n\n\n00142900\n\n\n00143000IF &PDEST = THEN SET &PDEST = &DEFDEST\n\n\n00143100IF &PSOC = THEN SET &PSOC = A\n\n\n00143200IF &STR(&PACCT) = THEN SET &PACCT = &STR(&ACCT)\n\n\n00143307IF &STR(&PPROG) = THEN SET &PPROG = &STR(&PROG)\n\n\n00143400IF &PJOBC = THEN SET &PJOBC = D\n\n\n00143500IF &PCOPIES = THEN SET &PCOPIES = 1\n\n\n00143600\n\n\n00143700ISPEXEC VPUT (PDOCN PSOC PDEST PACCT PJOBC PPROG PCOPIES)\n\n\n00143800\n\n\n00143900ISPEXEC SELECT PANEL(DOCPM&PT)\n\n\n./ ADD NAME=DOC03SEL 0104-83335-87034-1824-00018-00003-00000-KK00150\n        PROC 3 LISTLIB MEMNAME OPTLIB\n\n\n        CONTROL MSG NOFLUSH END(ENDO)\n\n\n        ISPEXEC VGET DOCSLVL1\n\n\n        ISPEXEC VGET DOCSLVL2\n\n\n        SET PL = &LENGTH(&STR(&OPTLIB))\n\n\n        IF &SUBSTR(&PL-1,&STR(&OPTLIB)) = &STR(-) THEN +\n\n\n           SET &OPTLIB = &SUBSTR(1:&PL-2,&STR(&OPTLIB))\n\n\n        IF &OPTLIB = DUMMY1 THEN SET &LOWQUAL = &STR(&LISTLIB(&MEMNAME))\n\n\n               ELSE SET &LOWQUAL = &OPTLIB\n\n\n        ISPEXEC CONTROL ERRORS RETURN\n\n\n        ISPEXEC BROWSE DATASET('&DOCSLVL1..&DOCSLVL2..&LOWQUAL')\n\n\n        IF &LASTCC NE 0 THEN +\n\n\n            DO\n\n\n            SET &GPM = &STR(NOT AVAILABLE)\n\n\n            SET &GPML = THE ITEM SELECTED MAY BE EMPTY\n\n\n            ISPEXEC SETMSG MSG(GPM001)\n\n\n            EXIT\n\n\n            ENDO\n\n\n./ ADD NAME=DOC04EDT 0110-86059-86189-1639-00081-00064-00029-KK00150\n00010000PROC 3 A B C\n\n\n00020002CONTROL NOMSG NOFLUSH END(ENDO)\n\n\n00021000IF &SYSPREF = KX00150 THEN CONTROL MSG CONLIST LIST\n\n\n00022010ISPEXEC CONTROL ERRORS RETURN\n\n\n00023010ISPEXEC VGET (DOCSLVL1 DOCSLVL2)\n\n\n00030000\n\n\n00040000SET PL = &LENGTH(&STR(&C))\n\n\n00050000IF &SUBSTR(&PL-1,&STR(&C)) = &STR(-) THEN +\n\n\n00060000   SET &C = &SUBSTR(1:&PL-2,&STR(&C))\n\n\n00060100\n\n\n00061000/*  OPEN CONTROL FILE:    */\n\n\n00061100\n\n\n00062000   SET L = &LENGTH(&A)\n\n\n00062110   IF &L < 9 THEN SET A = &DOCSLVL1..&DOCSLVL2..&A\n\n\n00062210   SET L = &LENGTH(&A)\n\n\n00063000      DO WHILE &L > 1\n\n\n00064000         IF &SUBSTR(&L,&A) = &STR(.) THEN +\n\n\n00065000            DO\n\n\n00066000            SET SP = &SUBSTR(1:&L-1,&A)\n\n\n00067000            SET &L = 1\n\n\n00068000            ENDO\n\n\n00069000         SET L = &L - 1\n\n\n00069100      ENDO\n\n\n00069200   SET CTLDSN = &SP..CONTROL\n\n\n00069300   ISPEXEC LMINIT DATAID(STATCON) DATASET('&CTLDSN') ENQ(SHR)\n\n\n00069500   IF &LASTCC NE 0 THEN +\n\n\n00069600      DO\n\n\n00070402ERRX: SET &GPM = &STR(&ZERRSM)\n\n\n00070502      SET &GPML = &STR(&ZERRLM)\n\n\n00070602      ISPEXEC SETMSG MSG(GPM001)\n\n\n00070702      ISPEXEC LMCLOSE DATAID(&STATCON)\n\n\n00070802      ISPEXEC LMCLOSE DATAID(&STATMON)\n\n\n00070900      EXIT\n\n\n00071000      ENDO\n\n\n00071100   ISPEXEC LMOPEN DATAID(&STATCON)\n\n\n00071200   IF &LASTCC NE 0 THEN GOTO ERRX\n\n\n00071302   ISPEXEC LMMFIND DATAID(&STATCON) MEMBER(PATTERN) STATS(YES)\n\n\n00071400   IF &LASTCC NE 0 THEN GOTO ERRX\n\n\n00071502   SET CDATE = &STR(&ZLMDATE)\n\n\n00071602   SET CTIME = &STR(&ZLMTIME)\n\n\n00071700\n\n\n00071800\n\n\n00071900/*  OPEN STATUS FILE:    */\n\n\n00072000\n\n\n00072100ISPEXEC LMINIT DATAID(STATMON) DATASET('&A') ENQ(SHRW)\n\n\n00072200IF &LASTCC NE 0 THEN +\n\n\n00072300   DO\n\n\n00072400   IFCAT '&A'\n\n\n00072500   IF &LASTCC NE 0 THEN +\n\n\n00073000     DO\n\n\n00102300     IFALC DDN(KKCF)\n\n\n00102500     IF &LASTCC NE 0 THEN ATTR KKCF RECFM(V B A) LRECL(85) BL(8000)\n\n\n00102608     FILEINFO DSN('&CTLDSN')\n\n\n00102700     ALLOC DSN('&A') NEW TRACK SP(1 1) US(KKCF) VOL(&VOLSER) DIR(5)\n\n\n00102800     ISPEXEC LMINIT DATAID(STATMON) DATASET('&A') ENQ(SHRW)\n\n\n00102900     IF &LASTCC NE 0 THEN GOTO ERRX\n\n\n00103000     ENDO\n\n\n00103100   ELSE GOTO ERRX\n\n\n00103700   ENDO\n\n\n00103800ISPEXEC LMOPEN DATAID(&STATMON)\n\n\n00103900IF &LASTCC NE 0 THEN GOTO ERRX\n\n\n00104002ISPEXEC LMMFIND DATAID(&STATMON) MEMBER(PATTERN) STATS(YES)\n\n\n00104102SET RC = &LASTCC\n\n\n00104202IF &RC NE 0 AND &RC NE 8 THEN GOTO ERRX\n\n\n00104302IF &ZLMDATE NE &CDATE OR &ZLMTIME NE &CTIME OR &RC = 8 THEN +\n\n\n00104400  DO\n\n\n00104507  ISPEXEC LMCLOSE DATAID(&STATMON)\n\n\n00104609/*  ISPEXEC LMOPEN DATAID(&STATMON) OPTION(OUTPUT)  */\n\n\n00104707  IF &LASTCC NE 0 THEN GOTO ERRX\n\n\n00104810  SET &SYSOUTTRAP = 9\n\n\n00104910  PDS '&CTLDSN' COPY PATTERN '&A' REPLACE SHR NOLIST\n\n\n00105010  SET &SYSOUTTRAP = 0\n\n\n00105300  ENDO\n\n\n00106000\n\n\n00107007/* NOW TRANSFER TO EDIT MACRO  */\n\n\n00108007\n\n\n00111000ISPEXEC VPUT (STATCON STATMON) SHARED\n\n\n00112007ISPEXEC LMCLOSE DATAID(&STATCON)\n\n\n00113007ISPEXEC LMCLOSE DATAID(&STATMON)\n\n\n00120000\n\n\n00130003ISPEXEC EDIT DATAID(&STATMON) MEMBER(&B) MACRO(&C)\n\n\n./ ADD NAME=DOC04PRT 0102-86010-86189-1642-00034-00032-00004-KK00150\n00010000PROC 3 A B C\n\n\n00020000CONTROL NOFLUSH END(ENDO)\n\n\n00071000\n\n\n00080000SET PL = &LENGTH(&STR(&C))\n\n\n00090000IF &SUBSTR(&PL-1,&STR(&C)) = &STR(-) THEN +\n\n\n00100000  DO\n\n\n00110000   SET PT = &SUBSTR(&PL,&STR(&C))\n\n\n00120000   SET &C = &SUBSTR(1:&PL-2,&STR(&C))\n\n\n00130000  ENDO\n\n\n00140000  ELSE SET PT = 1\n\n\n00140100\n\n\n00140202ISPEXEC VGET (DOCSLVL1 DOCSLVL2)\n\n\n00140302SET L = &LENGTH(&A)\n\n\n00140402IF &L < 9 THEN SET A = &DOCSLVL1..&DOCSLVL2..&A\n\n\n00141001SET &PDOCN = &A(&B)\n\n\n00141200\n\n\n00142200ISPEXEC SELECT PGM(PASSDEST)\n\n\n00142300ISPEXEC VGET DEFDEST\n\n\n00142400IF &DEFDEST = LOCAL THEN SET DEFDEST = WDPSC\n\n\n00142500\n\n\n00142600GETMY PROG SYS ACCT\n\n\n00142700\n\n\n00142800ISPEXEC VGET (PSOC PDEST PACCT PJOBC PPROG PCOPIES)\n\n\n00142900\n\n\n00143000IF &PDEST = THEN SET &PDEST = &DEFDEST\n\n\n00143100IF &PSOC = THEN SET &PSOC = A\n\n\n00143200IF &STR(&PACCT) = THEN SET &PACCT = &STR(&ACCT)\n\n\n00143300IF &STR(&PPROG) = THEN SET &PPROG = &STR(&PROG)\n\n\n00143400IF &PJOBC = THEN SET &PJOBC = D\n\n\n00143500IF &PCOPIES = THEN SET &PCOPIES = 1\n\n\n00143600\n\n\n00143700ISPEXEC VPUT (PDOCN PSOC PDEST PACCT PJOBC PPROG PCOPIES)\n\n\n00143800\n\n\n00143900ISPEXEC SELECT PANEL(DOCPM&PT)\n\n\n./ ADD NAME=DOC04SEL 0104-86010-86189-1644-00030-00011-00000-KK00150\n        PROC 3 A B C\n\n\n        CONTROL NOFLUSH END(ENDO)\n\n\n\n\n\n        SET PL = &LENGTH(&STR(&C))\n\n\n        IF &SUBSTR(&PL-1,&STR(&C)) = &STR(-) THEN +\n\n\n           SET &C = &SUBSTR(1:&PL-2,&STR(&C))\n\n\n\n\n\n        ISPEXEC VGET (DOCSLVL1 DOCSLVL2)\n\n\n        SET L = &LENGTH(&A)\n\n\n        IF &L < 9 THEN SET A = &DOCSLVL1..&DOCSLVL2..&A\n\n\n        SET &PDOCN = &A(&B)\n\n\n\n\n\n        FILEINFO DSN('&PDOCN')\n\n\n        IF &LASTCC NE 0 THEN +\n\n\n            DO\n\n\n            SET &GPM = &STR(NOT AVAILABLE)\n\n\n            SET &GPML = THE ITEM SELECTED MAY NOT EXIST YET\n\n\n            ISPEXEC SETMSG MSG(GPM001)\n\n\n            EXIT\n\n\n            ENDO\n\n\n\n\n\n        ISPEXEC CONTROL ERRORS RETURN\n\n\n        ISPEXEC BROWSE DATASET('&PDOCN')\n\n\n        IF &LASTCC NE 0 THEN +\n\n\n            DO\n\n\n            SET &GPM = &STR(NOT AVAILABLE)\n\n\n            SET &GPML = THE ITEM SELECTED MAY BE EMPTY\n\n\n            ISPEXEC SETMSG MSG(GPM001)\n\n\n            EXIT\n\n\n            ENDO\n\n\n./ ADD NAME=DSN      0118-80046-85113-1609-00006-00003-00005-JS02150\n00010000PROC 1 DSN\n\n\n00020003IF &SUBSTR(1,&DSN) = &STR(') THEN +\n\n\n00020103           SET &DSN = &SUBSTR(2:&LENGTH(&STR(&DSN))-1,&STR(&DSN))\n\n\n00021003                             ELSE +\n\n\n00022003           SET &DSN = &STR(&SYSPREF..&DSN)\n\n\n00030010DSNQ  &DSN.*\n\n\n./ ADD NAME=EDITAPP  0115-85291-89121-1021-00251-00236-00251-LL02155\n00010013PROC 0 ZENVIR() ZSCREEND(24) MSGID(BMWE100) Z() +\n\n\n00020013     W88APP01() W88APP02() W88APP03() W88APP04() W88APP05() W88APP06()+\n\n\n00030013     W88APP07() W88APP08() W88APP09() W88APP10() W88APP11() W88APP12()+\n\n\n00040013     W88APP13() W88APP14() W88APP15() W88APP16() W88APP17() W88APP18()+\n\n\n00050013     W88APP19() W88APP20() W88APP21() W88APP22() W88APP23() W88APP24()\n\n\n00060013\n\n\n00070013 CONTROL NOMSG NOFLUSH END(ENDO)\n\n\n00080013 IF &SYSPREF = KX00155 THEN CONTROL MSG LIST CONLIST\n\n\n00090013\n\n\n00091015/* %TRAK EDITAPP PROD###\n\n\n00100013BEGIN:  SET W88X = &STR(&&W88X)\n\n\n00110013        SET W88APP = &STR(&&W88APP)\n\n\n00120013        SET S = &STR(&&S)\n\n\n00130013\n\n\n00140013            ISPEXEC VGET ( +\n\n\n00150013 W88APP01 W88APP02 W88APP03 W88APP04 W88APP05 W88APP06 W88APP07 +\n\n\n00160013 W88APP08 W88APP09 W88APP10 W88APP11 W88APP12 W88APP13 W88APP14 +\n\n\n00170013 W88APP15 W88APP16 W88APP17 W88APP18 W88APP19 W88APP20 W88APP21 +\n\n\n00180013 W88APP22 W88APP23 W88APP24) PROFILE\n\n\n00190013\n\n\n00200013/* START OF ISPF V2 RECOVERY CODE:  */\n\n\n00210013/* NOTE NEW PARMS INITIALIZED ON PROC STATEMENT (Z VARS) */\n\n\n00220013\n\n\n00230013ISPEXEC VGET (ZENVIR ZSCREEND)\n\n\n00240013IF &STR(&ZENVIR) NE &Z THEN +\n\n\n00250013  DO\n\n\n00260013  ISPEXEC EDREC INIT\n\n\n00270013  SET DONE = NO\n\n\n00280013  DO WHILE &DONE = NO\n\n\n00290013    ISPEXEC EDREC QUERY\n\n\n00300013    IF &LASTCC = 4 THEN +\n\n\n00310013      DO\n\n\n00320013      ISPEXEC DISPLAY PANEL(ISREDM02)\n\n\n00330013      IF &LASTCC NE 0 THEN DO\n\n\n00340013                           ISPEXEC EDREC DEFER\n\n\n00350013                           EXIT\n\n\n00360013                           ENDO\n\n\n00370013      IF &ZEDCMD = C THEN ISPEXEC EDREC CANCEL\n\n\n00380013      IF &ZEDCMD = D THEN ISPEXEC EDREC DEFER\n\n\n00390013      IF &ZEDCMD = &Z THEN ISPEXEC EDREC PROCESS\n\n\n00400013      ENDO\n\n\n00410013    ELSE SET DONE = YES\n\n\n00420013  ENDO\n\n\n00430013ENDO\n\n\n00440013/* END OF ISPF V2 RECOVERY CODE.  */\n\n\n00450013\n\n\n00460013/* FIRST TIME CHECK:  */\n\n\n00470013\n\n\n00480013ISPEXEC VGET KKMEF PROFILE\n\n\n00490013IF &KKMEF = &STR() THEN DO\n\n\n00500013   SET &KKMEF = Y\n\n\n00510013   ISPEXEC VPUT KKMEF PROFILE\n\n\n00520013   IF &W88APP01 NE &STR() THEN GOTO DSPLPANL\n\n\n00530013   SET &APPNO = &STR(01)\n\n\n00540013   SET W88APP01 = &STR(YOUR OLD BETTER EDIT DATASETS)\n\n\n00550013   GOTO INITSET\n\n\n00560013   ENDO\n\n\n00570013\n\n\n00580013 /* CHECK FOR APPL ALREADY SELECTED: */\n\n\n00590013ISPEXEC VGET ZTRAIL SHARED\n\n\n00600013IF &ZTRAIL NE &STR() THEN DO\n\n\n00610013   SET &ZCMD = &ZTRAIL\n\n\n00620013   SET &ZTRAIL = &STR()\n\n\n00630013   ISPEXEC VPUT ZTRAIL SHARED\n\n\n00640013   SET &RC = 0\n\n\n00650013   GOTO NODISP\n\n\n00660013   ENDO\n\n\n00670013\n\n\n00680013 /* START MAIN DISPLAY LOOP: */\n\n\n00690013 DSPLPANL:  ISPEXEC DISPLAY PANEL(&SYSICMD)  MSG(&MSGID)\n\n\n00700013            SET &RC = &LASTCC\n\n\n00710013            IF &RC = 8 THEN GOTO CONTINU\n\n\n00720013   NODISP:  SET &MSGID = &STR(BMWE100)\n\n\n00730013\n\n\n00740013/* ANALYZE ANY COMMAND ENTERED ON THE APPL PANEL:  */\n\n\n00750013            IF &ZCMD = S THEN DO\n\n\n00760013                SET &APPNO = &STR(01)\n\n\n00770013                GOTO CONTINU\n\n\n00780013                              ENDO\n\n\n00790013\n\n\n00800013            IF &ZCMD = N OR &ZCMD = D THEN DO\n\n\n00810013                SET &AC = &APPNO + 1\n\n\n00820013                IF &AC = 18 THEN SET &AC = 1\n\n\n00830013                IF &AC < 10 THEN SET &APPNO = &STR(0&AC)\n\n\n00840013                            ELSE SET &APPNO = &STR(&AC)\n\n\n00850013                GOTO CONTINU\n\n\n00860013                ENDO\n\n\n00870013\n\n\n00880013            IF &ZCMD = P OR &ZCMD = U OR &ZCMD = B THEN DO\n\n\n00890013                SET &AC = &APPNO - 1\n\n\n00900013                IF &AC = 0 THEN SET &AC = 17\n\n\n00910013                IF &AC < 10 THEN SET &APPNO = &STR(0&AC)\n\n\n00920013                            ELSE SET &APPNO = &STR(&AC)\n\n\n00930013                GOTO CONTINU\n\n\n00940013                ENDO\n\n\n00950013\n\n\n00960013            SET &LZ = &LENGTH(&ZCMD)\n\n\n00970013            IF &LZ > 2 THEN +\n\n\n00980013                DO\n\n\n00990013                IF &SUBSTR(2,&ZCMD) = &STR(.) THEN DO\n\n\n01000013                   SET &ZTRAIL = &SUBSTR(3:&LZ,&ZCMD)\n\n\n01010013                   SET &ZCMD = &SUBSTR(1,&ZCMD)\n\n\n01020013                   ISPEXEC VPUT ZTRAIL SHARED\n\n\n01030013                   ENDO\n\n\n01040013                ELSE IF &SUBSTR(3,&ZCMD) = &STR(.) THEN DO\n\n\n01050013                   SET &ZTRAIL = &SUBSTR(4:&LZ,&ZCMD)\n\n\n01060013                   SET &ZCMD = &SUBSTR(1:2,&ZCMD)\n\n\n01070013                   ISPEXEC VPUT ZTRAIL SHARED\n\n\n01080013                   ENDO\n\n\n01090013                ENDO\n\n\n01100013\n\n\n01110013            IF &ZCMD NE &STR() THEN DO\n\n\n01120013                IF &DATATYPE(&ZCMD) NE NUM THEN DO\n\n\n01130013                    SET &MSGID = &STR(BMWE101)\n\n\n01140013                    GOTO DSPLPANL\n\n\n01150013                    ENDO\n\n\n01160013\n\n\n01170013                IF &ZCMD GT 17 THEN DO\n\n\n01180013                    SET &MSGID = &STR(BMWE102)\n\n\n01190013                    GOTO DSPLPANL\n\n\n01200013                    ENDO\n\n\n01210013\n\n\n01220013                IF &ZCMD LT 1 THEN DO\n\n\n01230013                    SET &MSGID = &STR(BMWE102)\n\n\n01240013                    GOTO DSPLPANL\n\n\n01250013                    ENDO\n\n\n01260013\n\n\n01270013                SET &AC = &ZCMD\n\n\n01280013                IF &AC < 10 THEN SET &APPNO = &STR(0&AC)\n\n\n01290013                            ELSE SET &APPNO = &STR(&AC)\n\n\n01300013                GOTO CONTINU\n\n\n01310013                ENDO\n\n\n01320013\n\n\n01330013/* NO COMMAND, SO SCAN FOR A SELECT CODE FOR AN APPL:   */\n\n\n01340013                SET &AC = 1\n\n\n01350013                DO WHILE &AC < 18\n\n\n01360013                   IF &AC < 10 THEN SET &APPNO = &STR(0&AC)\n\n\n01370013                               ELSE SET &APPNO = &STR(&AC)\n\n\n01380013                   IF &STR(&S&APPNO) = &STR(S) THEN GOTO CONTINU\n\n\n01390013                   IF &STR(&S&APPNO) = &STR(E) THEN GOTO CONTINU\n\n\n01400013                   IF &STR(&S&APPNO) = &STR(L) THEN GOTO INITSET\n\n\n01410013                   SET &AC = &AC + 1\n\n\n01420013                ENDO\n\n\n01430013\n\n\n01440013                SET &APPNO = &STR(01)\n\n\n01450013\n\n\n01460013/* SAVE ANY CHANGES TO APPL NAMES :   */\n\n\n01470013 CONTINU:  +\n\n\n01480013            SET &ZCMD = &STR()\n\n\n01490013            ISPEXEC VPUT +\n\n\n01500013(W88APP01 W88APP02 W88APP03 W88APP04 W88APP05 W88APP06 W88APP07 +\n\n\n01510013 W88APP08 W88APP09 W88APP10 W88APP11 W88APP12 W88APP13 W88APP14 +\n\n\n01520013 W88APP15 W88APP16 W88APP17) PROFILE\n\n\n01530013\n\n\n01540013            IF &RC = 8 THEN EXIT\n\n\n01550013\n\n\n01560013/* NOW GET THE DSNAMES FOR THE APPL TO PASS TO BETTER EDIT PANEL: */\n\n\n01570013            SET &W88X&APPNO.01  =\n\n\n01580013            SET &W88X&APPNO.02  =\n\n\n01590013            SET &W88X&APPNO.03  =\n\n\n01600013            SET &W88X&APPNO.04  =\n\n\n01610013            SET &W88X&APPNO.05  =\n\n\n01620013            SET &W88X&APPNO.06  =\n\n\n01630013            SET &W88X&APPNO.07  =\n\n\n01640013            SET &W88X&APPNO.08  =\n\n\n01650013            SET &W88X&APPNO.09  =\n\n\n01660013            SET &W88X&APPNO.10  =\n\n\n01670013            SET &W88X&APPNO.11  =\n\n\n01680013            SET &W88X&APPNO.12  =\n\n\n01690013            SET &W88X&APPNO.13  =\n\n\n01700013            SET &W88X&APPNO.14  =\n\n\n01710013            SET &W88X&APPNO.15  =\n\n\n01720013            SET &W88X&APPNO.16  =\n\n\n01730013            SET &W88X&APPNO.17  =\n\n\n01740013\n\n\n01750013            ISPEXEC VGET +\n\n\n01760013(W88X&APPNO.01 W88X&APPNO.02 W88X&APPNO.03 W88X&APPNO.04 W88X&APPNO.05 W\n88X&APPNO.06 W88X&APPNO.07 +\n\n01770013 W88X&APPNO.08 W88X&APPNO.09 W88X&APPNO.10 W88X&APPNO.11 W88X&APPNO.12 W\n88X&APPNO.13 W88X&APPNO.14 +\n\n01780013 W88X&APPNO.15 W88X&APPNO.16 W88X&APPNO.17) PROFILE\n\n\n01790013\n\n\n01800013            SET &W88DSN01 = &STR(&W88X&APPNO.01)\n\n\n01810013            SET &W88DSN02 = &STR(&W88X&APPNO.02)\n\n\n01820013            SET &W88DSN03 = &STR(&W88X&APPNO.03)\n\n\n01830013            SET &W88DSN04 = &STR(&W88X&APPNO.04)\n\n\n01840013            SET &W88DSN05 = &STR(&W88X&APPNO.05)\n\n\n01850013            SET &W88DSN06 = &STR(&W88X&APPNO.06)\n\n\n01860013            SET &W88DSN07 = &STR(&W88X&APPNO.07)\n\n\n01870013            SET &W88DSN08 = &STR(&W88X&APPNO.08)\n\n\n01880013            SET &W88DSN09 = &STR(&W88X&APPNO.09)\n\n\n01890013            SET &W88DSN10 = &STR(&W88X&APPNO.10)\n\n\n01900013            SET &W88DSN11 = &STR(&W88X&APPNO.11)\n\n\n01910013            SET &W88DSN12 = &STR(&W88X&APPNO.12)\n\n\n01920013            SET &W88DSN13 = &STR(&W88X&APPNO.13)\n\n\n01930013            SET &W88DSN14 = &STR(&W88X&APPNO.14)\n\n\n01940013            SET &W88DSN15 = &STR(&W88X&APPNO.15)\n\n\n01950013            SET &W88DSN16 = &STR(&W88X&APPNO.16)\n\n\n01960013            SET &W88DSN17 = &STR(&W88X&APPNO.17)\n\n\n01970013\n\n\n01980013            ISPEXEC VPUT +\n\n\n01990013(W88DSN01 W88DSN02 W88DSN03 W88DSN04 W88DSN05 W88DSN06 W88DSN07 +\n\n\n02000013 W88DSN08 W88DSN09 W88DSN10 W88DSN11 W88DSN12 W88DSN13 W88DSN14 +\n\n\n02010013 W88DSN15 W88DSN16 W88DSN17) PROFILE\n\n\n02020013\n\n\n02030013/*   CALL THE BETTER EDIT PROGRAM :   */\n\n\n02040013            SET &KKMEAPP = &STR(&W88APP&APPNO)\n\n\n02050013\n\n\n02060013            ISPEXEC VGET BEMNAM PROFILE\n\n\n02070013            IF &LASTCC NE 0 THEN SET &BEMNAM = MULTEDIT\n\n\n02080013            SET &DYNPNAME = &BEMNAM\n\n\n02090013            IF &DYNPNAME = &Z THEN SET &DYNPNAME = MULTEDIT\n\n\n02100013            ISPEXEC VPUT (DYNPNAME KKMEAPP) SHARED\n\n\n02110013\n\n\n02120013            ISPEXEC SELECT PGM(PANLEXIT) PARM(DPSCEDT6)\n\n\n02130013\n\n\n02140013/*   GET ANY MODIFIED DATASET NAMES AND SAVE:   */\n\n\n02150013INITSET: +\n\n\n02160013            ISPEXEC VGET +\n\n\n02170013(W88DSN01 W88DSN02 W88DSN03 W88DSN04 W88DSN05 W88DSN06 W88DSN07 +\n\n\n02180013 W88DSN08 W88DSN09 W88DSN10 W88DSN11 W88DSN12 W88DSN13 W88DSN14 +\n\n\n02190013 W88DSN15 W88DSN16 W88DSN17) PROFILE\n\n\n02200013\n\n\n02210013            SET &W88X&APPNO.01 =  &STR(&W88DSN01)\n\n\n02220013            SET &W88X&APPNO.02 =  &STR(&W88DSN02)\n\n\n02230013            SET &W88X&APPNO.03 =  &STR(&W88DSN03)\n\n\n02240013            SET &W88X&APPNO.04 =  &STR(&W88DSN04)\n\n\n02250013            SET &W88X&APPNO.05 =  &STR(&W88DSN05)\n\n\n02260013            SET &W88X&APPNO.06 =  &STR(&W88DSN06)\n\n\n02270013            SET &W88X&APPNO.07 =  &STR(&W88DSN07)\n\n\n02280013            SET &W88X&APPNO.08 =  &STR(&W88DSN08)\n\n\n02290013            SET &W88X&APPNO.09 =  &STR(&W88DSN09)\n\n\n02300013            SET &W88X&APPNO.10 =  &STR(&W88DSN10)\n\n\n02310013            SET &W88X&APPNO.11 =  &STR(&W88DSN11)\n\n\n02320013            SET &W88X&APPNO.12 =  &STR(&W88DSN12)\n\n\n02330013            SET &W88X&APPNO.13 =  &STR(&W88DSN13)\n\n\n02340013            SET &W88X&APPNO.14 =  &STR(&W88DSN14)\n\n\n02350013            SET &W88X&APPNO.15 =  &STR(&W88DSN15)\n\n\n02360013            SET &W88X&APPNO.16 =  &STR(&W88DSN16)\n\n\n02370013            SET &W88X&APPNO.17 =  &STR(&W88DSN17)\n\n\n02380013\n\n\n02390013            ISPEXEC VPUT +\n\n\n02400013(W88X&APPNO.01 W88X&APPNO.02 W88X&APPNO.03 W88X&APPNO.04 W88X&APPNO.05 W\n88X&APPNO.06 W88X&APPNO.07 +\n\n02410013 W88X&APPNO.08 W88X&APPNO.09 W88X&APPNO.10 W88X&APPNO.11 W88X&APPNO.12 W\n88X&APPNO.13 W88X&APPNO.14 +\n\n02420013 W88X&APPNO.15 W88X&APPNO.16 W88X&APPNO.17) PROFILE\n\n\n02430013\n\n\n02440013/* CHECK FOR ANY COMMAND (UP/DOWN) PASSED BACK:  */\n\n\n02450013            ISPEXEC VGET KCMD SHARED\n\n\n02460013            IF &KCMD = &STR() THEN GOTO DSPLPANL\n\n\n02470013            SET ZCMD = &SUBSTR(1,&KCMD)\n\n\n02480013            SET KCMD = &STR()\n\n\n02490013            ISPEXEC VPUT KCMD SHARED\n\n\n02500013            GOTO NODISP\n\n\n./ ADD NAME=EDITNEW  0114-84324-89121-1021-00038-00009-00038-LL02155\n00010012PROC 0 ZENVIR() Z()\n\n\n00020012\n\n\n00030012 CONTROL NOMSG NOFLUSH END(ENDO)\n\n\n00040012 IF &SYSPREF = KX00150 THEN CONTROL MSG LIST CONLIST\n\n\n00050012\n\n\n00060012/* START OF ISPF V2 RECOVERY CODE:  */\n\n\n00070012/* NOTE NEW PARMS INITIALIZED ON PROC STATEMENT (Z VARS) */\n\n\n00080012\n\n\n00081014/* %TRAK EDITNEW PROD###\n\n\n00090012ISPEXEC VGET (ZENVIR)\n\n\n00100012IF &STR(&ZENVIR) NE &Z THEN +\n\n\n00110012  DO\n\n\n00120012  ISPEXEC EDREC INIT\n\n\n00130012  SET DONE = NO\n\n\n00140012    DO WHILE &DONE = NO\n\n\n00150012      ISPEXEC EDREC QUERY\n\n\n00160012      IF &LASTCC = 4 THEN +\n\n\n00170012        DO\n\n\n00180012        ISPEXEC DISPLAY PANEL(ISREDM02)\n\n\n00190012        IF &LASTCC NE 0 THEN DO\n\n\n00200012                             ISPEXEC EDREC DEFER\n\n\n00210012                             EXIT\n\n\n00220012                             ENDO\n\n\n00230012        IF &ZEDCMD = C THEN ISPEXEC EDREC CANCEL\n\n\n00240012        IF &ZEDCMD = D THEN ISPEXEC EDREC DEFER\n\n\n00250012        IF &ZEDCMD = &Z THEN ISPEXEC EDREC PROCESS\n\n\n00260012        ENDO\n\n\n00270012      ELSE SET DONE = YES\n\n\n00280012    ENDO\n\n\n00290012  ENDO\n\n\n00300012/* END OF ISPF V2 RECOVERY CODE.  */\n\n\n00310012\n\n\n00320012ISPEXEC VGET BEMNAM PROFILE\n\n\n00330012IF &LASTCC NE 0 THEN SET &BEMNAM = MULTEDIT\n\n\n00340012SET &DYNPNAME = &BEMNAM\n\n\n00350012IF &DYNPNAME = &Z THEN SET DYNPNAME = MULTEDIT\n\n\n00360012ISPEXEC VPUT DYNPNAME SHARED\n\n\n00370012ISPEXEC SELECT PGM(DPSCEDT6)\n\n\n./ ADD NAME=ENCRYPT  0101-85289-85290-1240-00002-00002-00001-DS00150\n00010000ISREDIT MACRO (KEY)\n\n\n00020001ISREDIT !CRY ENCRYPT,&KEY\n\n\n./ ADD NAME=ERRORMSG 0105-82314-84157-1529-00116-00005-00000-JS02150\n        PROC 1 CODE\n\n\n        CONTROL NOMSG\n\n\n        GLOBAL MSG\n\n\n        STACK\n\n\n        CLOG '&SYSDATE &SYSTIME ERRORMSG' U($$$#150) SAVE\n\n\n        ERROR DO\n\n\n              SET MSG = &STR(CLIST ERROR CODE WAS &CODE)\n\n\n              EXIT CODE(0)\n\n\n              END\n\n\n        GOTO MSG&CODE\n\n\n        MSG16:  SET MSG = &STR(NOT ENOUGH VIRTUAL STORAGE)\n\n\n                EXIT\n\n\n        MSG300: SET MSG = &STR(USER TRIED TO UPDATE AN UNAUTHORIZED VARIABLE)\n\n\n                EXIT\n\n\n        MSG304: SET MSG = &STR(INVALID KEYWORD ON EXIT STATEMENT)\n\n\n                EXIT\n\n\n        MSG308: SET MSG = &STR(CODE SPECIFIED, BUT NO CODE GIVEN ON EXIT STATEME\nNT)\n\n                EXIT\n\n\n        MSG312: SET MSG = &STR(INTERNAL GLOBAL PROCESSING ERROR)\n\n\n                EXIT\n\n\n        MSG316: SET MSG = &STR(TERMIN DELIMITER GREATER THAN 256 CHARACTERS)\n\n\n                EXIT\n\n\n        MSG324: SET MSG = &STR(GETLINE ERROR)\n\n\n                EXIT\n\n\n        MSG328: SET MSG = &STR(MORE THAN 64 DELIMITERS ON TERMIN)\n\n\n                EXIT\n\n\n        MSG332: SET MSG = &STR(INVALID FILE NAME SYNTAX)\n\n\n                EXIT\n\n\n        MSG336: SET MSG = &STR(FILE ALREADY OPEN)\n\n\n                EXIT\n\n\n        MSG340: SET MSG = &STR(INVALID OPEN TYPE SYNTAX)\n\n\n                EXIT\n\n\n        MSG344: SET MSG = &STR(UNDEFINED OPEN TYPE)\n\n\n                EXIT\n\n\n        MSG348: SET MSG = &STR(FILE SPECIFIED DID NOT OPEN)\n\n\n                EXIT\n\n\n        MSG352: SET MSG = &STR(GETFILE - FILENAME NOT CURRENTLY OPEN)\n\n\n                EXIT\n\n\n        MSG356: SET MSG = &STR(GETFILE - THE FILE HAS BEEN CLOSED BY THE SYSTEM)\n\n\n                EXIT\n\n\n        MSG360: SET MSG = &STR(PUTFILE - FILE NAME NOT CURRENTLY OPEN)\n\n\n                EXIT\n\n\n        MSG364: SET MSG = &STR(PUTFILE - THE FILE HAS BEEN CLOSED BY THE SYSTEM)\n\n\n                EXIT\n\n\n        MSG368: SET MSG = &STR(PUTFILE - CLOSFILE - FILE NOT OPENED BY OPENFILE)\n\n\n                EXIT\n\n\n        MSG372: SET MSG = &STR(PUTFILE - ISSUED BEFORE GETFILE ON A FILE OPENED\nFOR UPDATE)\n\n                EXIT\n\n\n        MSG400: SET MSG = &STR(GETFILE END OF FILE)\n\n\n                EXIT\n\n\n        MSG800: SET MSG = &STR(DATA FOUND WHERE OPERATOR WAS EXPECTED)\n\n\n                EXIT\n\n\n        MSG804: SET MSG = &STR(OPERATOR FOUND WHERE DATA WAS EXPECTED)\n\n\n                EXIT\n\n\n        MSG808: SET MSG = &STR(A COMPARISON OPERATOR WAS USED IN A SET STATEMENT\n)\n\n                EXIT\n\n\n        MSG816: SET MSG = &STR(OPERATOR FOUND AT THE END OF A STATEMENT)\n\n\n                EXIT\n\n\n        MSG820: SET MSG = &STR(OPERATORS OUT OF ORDER)\n\n\n                EXIT\n\n\n        MSG824: SET MSG = &STR(MORE THAN ONE EXCLUSIVE OPERATOR FOUND)\n\n\n                EXIT\n\n\n        MSG828: SET MSG = &STR(MORE THAN ONE EXCLUSIVE COMPARISON OPERATOR)\n\n\n                EXIT\n\n\n        MSG840: SET MSG = &STR(NOT ENOUGH OPERANDS)\n\n\n                EXIT\n\n\n        MSG844: SET MSG = &STR(NO VALID OPERATORS)\n\n\n                EXIT\n\n\n        MSG848: SET MSG = &STR(ATTEMPT TO LOAD CHARACTER FROM NUMERIC VALUE)\n\n\n                EXIT\n\n\n        MSG852: SET MSG = &STR(ADDITION ERROR - CHARACTER DATA)\n\n\n                EXIT\n\n\n        MSG856: SET MSG = &STR(SUBTRACTION ERROR - CHARACTER DATA)\n\n\n                EXIT\n\n\n        MSG860: SET MSG = &STR(MULTIPLICATION ERROR - CHARACTER DATA)\n\n\n                EXIT\n\n\n        MSG864: SET MSG = &STR(DIVIDE ERROR - CHARACTER DATA OR DIVISION BY ZERO\n)\n\n                EXIT\n\n\n        MSG868: SET MSG = &STR(PREFIX FOUND ON CHARACTER DATA)\n\n\n                EXIT\n\n\n        MSG872: SET MSG = &STR(NUMERIC VALUE TOO LARGE)\n\n\n                EXIT\n\n\n        MSG900: SET MSG = &STR(SINGLE AMPERSAND FOUND)\n\n\n                EXIT\n\n\n        MSG904: SET MSG = &STR(SYMBOLIC VARIABLE NOT FOUND)\n\n\n                EXIT\n\n\n        MSG908: SET MSG = &STR(ERROR OCCURD IN ERR ACTN RANGE THAT RECD CNTL BEC\nAUSE OF ANOTHER ERR)\n\n                EXIT\n\n\n        MSG912: SET MSG = &STR(SUBSTRING RANGE INVALID)\n\n\n                EXIT\n\n\n        MSG916: SET MSG = &STR(NON-NUMERIC VALUE IN SUBSTRING RANGE)\n\n\n                EXIT\n\n\n        MSG920: SET MSG = &STR(SUBSTRING RANGE VALUE TOO SMALL: 0 OR NEGATIVE)\n\n\n                EXIT\n\n\n        MSG924: SET MSG = &STR(INVALID SUBSTRING SYNTAX)\n\n\n                EXIT\n\n\n        MSG932: SET MSG = &STR(SUBSTRING OUTSIDE OF RANGE OF THE STRING)\n\n\n                EXIT\n\n\n        MSG936: SET MSG = &STR(A BUILT-IN FUNCTION REQUIRING A VALUE WAS ENTERED\n WITHOUT A VALUE)\n\n                EXIT\n\n\n        MSG940: SET MSG = &STR(INVALID SYMBOLIC VARIABLE)\n\n\n                EXIT\n\n\n        MSG944: SET MSG = &STR(A LABEL WAS USED AS A SYMBOLIC VARIABLE)\n\n\n                EXIT\n\n\n        MSG948: SET MSG = &STR(INVALID LABEL SYNTAX ON A GOTO STATEMENT)\n\n\n                EXIT\n\n\n        MSG952: SET MSG = &STR(GOTO LABEL WAS NOT DEFINED)\n\n\n                EXIT\n\n\n        MSG956: SET MSG = &STR(GOTO STATEMENT HAS NO LABEL)\n\n\n                EXIT\n\n\n        MSG960: SET MSG = &STR(SYSSCAN WAS SET TO AN INVALID VALUE)\n\n\n                EXIT\n\n\n        MSG964: SET MSG = &STR(LASTCC SET TO INVALID VALUE, EXIT TRIED TO USE AS\n DEFAULT VALUE)\n\n                EXIT\n\n\n        MSG999: SET MSG = &STR(INTERNAL COMMAND PROCEDURE ERROR)\n\n\n                EXIT\n\n\n./ ADD NAME=EXPANDIR 0110-86083-87120-1140-00230-00236-00000-JS02150\n00010100           CONTROL NOMSG NOFLUSH END(ENDO)\n\n\n00010800\n\n\n00010900           /*                                                */\n\n\n00011000           /*    DETERMINE IF THIS CLIST IS BEING INVOKED    */\n\n\n00011100           /*    FROM A NON FULL SCREEN TERMINAL (DIALUP)    */\n\n\n00011200           /*                                                */\n\n\n00012000\n\n\n00022400           CALL 'WDPSC.SHARED.LOAD(TERMTYPE)'\n\n\n00022500           SET &RC = &LASTCC\n\n\n00022600\n\n\n00022700           IF &RC = 0 THEN GOTO DIALUP\n\n\n00022900\n\n\n00023000           /*                                                */\n\n\n00023100           /*    DETERMINE IF THIS CLIST IS BEING INVOKED    */\n\n\n00023200           /*    FROM A READY RATHER THAN OPTION 6 OF SPF    */\n\n\n00023300           /*    IF SO, INVOKE ISPF                          */\n\n\n00023400           /*                                                */\n\n\n00023500\n\n\n00023600           ISPEXEC CONTROL DISPLAY REFRESH\n\n\n00023700               SET &SPF = &LASTCC\n\n\n00023805               IF &SPF \u00ac= 0 THEN DO\n\n\n00023900                  ISPF CMD(%EXPANDIR)\n\n\n00024000                  EXIT\n\n\n00024100                  ENDO\n\n\n00024300\n\n\n00024400           SET &PROJECT =\n\n\n00024500           SET &LIBRARY =\n\n\n00024600           SET &TYPE    =\n\n\n00024700\n\n\n00024800           ISPEXEC VGET PROJECT PROFILE\n\n\n00024900           ISPEXEC VGET LIBRARY PROFILE\n\n\n00025000           ISPEXEC VGET TYPE    PROFILE\n\n\n00025100\n\n\n00025200           SET &ADR      =\n\n\n00025300           SET &OTHERDSN =\n\n\n00025400\n\n\n00025500           SET &MSGID    = XDIR100\n\n\n00026500           SET &KURSOR   = PROJECT\n\n\n00026700\n\n\n00027200 DSPLPANL: ISPEXEC DISPLAY PANEL(EXPANDIR) MSG(&MSGID) CURSOR(&KURSOR)\n\n\n00027300           SET &RC = &LASTCC\n\n\n00027400           IF &RC = 8 THEN GOTO ENDIALOG\n\n\n00027500\n\n\n00027600           IF &OTHERDSN NE THEN DO\n\n\n00027700                 SET &PDSDSN = &OTHERDSN\n\n\n00027800                 SET &LOCATION = OTHER\n\n\n00027900                 GOTO DOFINFO\n\n\n00028000                 ENDO\n\n\n00028100\n\n\n00028200           IF &PROJECT = OR +\n\n\n00028300              &LIBRARY = OR +\n\n\n00028400              &TYPE    = THEN DO\n\n\n00028500                  SET &MSGID = &STR(XDIR101)\n\n\n00028600                  SET &KURSOR = &STR(PROJECT)\n\n\n00028700                  GOTO DSPLPANL\n\n\n00028800                  ENDO\n\n\n00028900\n\n\n00029000           SET &PDSDSN = &STR('&PROJECT..&LIBRARY..&TYPE')\n\n\n00029100           SET &LOCATION = SPFLIB\n\n\n00029200\n\n\n00029300 DOFINFO:  FILEINFO DSN(&STR(&PDSDSN))\n\n\n00029400           SET &RC = &LASTCC\n\n\n00029500\n\n\n00029600           IF &RC EQ 96 THEN DO\n\n\n00029700                  SET &MSGID = &STR(XDIR101)\n\n\n00029800                  GOTO DOFINFO2\n\n\n00029900                  ENDO\n\n\n00030000\n\n\n00030100           IF &RC NE 0 THEN DO\n\n\n00030200                  SET &MSGID = &STR(XDIR102)\n\n\n00030300                  GOTO DOFINFO2\n\n\n00030400                  ENDO\n\n\n00030500\n\n\n00030600           IF &DSORG NE PO THEN DO\n\n\n00030700                  SET &MSGID = &STR(XDIR103)\n\n\n00030800                  GOTO DOFINFO2\n\n\n00030900                  ENDO\n\n\n00031000\n\n\n00031100           IF &MEMCNTL EQ YES THEN DO\n\n\n00031200                  SET &MSGID = &STR(XDIR104)\n\n\n00031300                  GOTO DOFINFO2\n\n\n00031400                  ENDO\n\n\n00031500\n\n\n00031600           IF &ADR = 0 THEN DO\n\n\n00031700                  SET &MSGID = &STR(XDIR105)\n\n\n00031800                  SET &KURSOR = &STR(ADR)\n\n\n00031900                  GOTO DSPLPANL\n\n\n00032100                  ENDO\n\n\n00032200\n\n\n00032300           GOTO XPANDIR\n\n\n00033100\n\n\n00033200 DOFINFO2: IF &LOCATION = SPFLIB THEN SET &KURSOR = &STR(PROJECT)\n\n\n00033300                 ELSE SET &KURSOR = &STR(OTHERDSN)\n\n\n00033400\n\n\n00033500           GOTO DSPLPANL\n\n\n00033600\n\n\n00033700 XPANDIR:  SET &ADDAMT = 1000 + &ADR\n\n\n00033900           SET &ADDAMT = &STR(&SUBSTR(2:4,&ADDAMT))\n\n\n00034000\n\n\n00035001           CONTROL NOMSG\n\n\n00036004           FREE F(DUMDUM)\n\n\n00037001\n\n\n00038001           CONTROL MSG\n\n\n00039004           ALLOC F(DUMDUM) DUMMY\n\n\n00040200\n\n\n00041000           CONTROL NOMSG\n\n\n00042000           PROF NOWTPMSG\n\n\n00043000\n\n\n00043104           STACK DDOUT(DUMDUM)\n\n\n00044004           PDS '&FULLDSN' FIXPDS EXPAND(&ADDAMT)\n\n\n00062000           SET &RC = &LASTCC\n\n\n00063000\n\n\n00063100           PROF WTPMSG\n\n\n00063200\n\n\n00064000           IF &RC = 0 THEN SET &MSGID = &STR(XDIR106)\n\n\n00064100              ELSE SET &MSGID = &STR(XDIR107)\n\n\n00065000\n\n\n00066000           GOTO DSPLPANL\n\n\n00066100\n\n\n00066300 ENDIALOG: ISPEXEC VPUT PROJECT PROFILE\n\n\n00066400           ISPEXEC VPUT LIBRARY PROFILE\n\n\n00066500           ISPEXEC VPUT TYPE    PROFILE\n\n\n00067000\n\n\n00067108           ISPEXEC CONTROL DISPLAY REFRESH\n\n\n00068000           EXIT\n\n\n00069000\n\n\n00072000 DIALUP:   ERROR DO\n\n\n00073000               WRITE\n\n\n00074000               WRITE ***********************************\n\n\n00075000               WRITE *  INVALID SYNTAX OF DATASET NAME *\n\n\n00076000               WRITE ***********************************\n\n\n00078000               WRITE\n\n\n00079000               GOTO GETDSN\n\n\n00079100               ENDO\n\n\n00079200\n\n\n00079300 GETDSN:   WRITE\n\n\n00079400           WRITENR ENTER DATASET NAME==>\n\n\n00079800           READ\n\n\n00079900           SET &DSN = &STR(&SYSDVAL)\n\n\n00080000\n\n\n00081700           ERROR OFF\n\n\n00081800           FILEINFO DSN(&STR(&DSN))\n\n\n00081900           SET &RC = &LASTCC\n\n\n00082000\n\n\n00082100           IF &RC EQ 96 THEN DO\n\n\n00082200               WRITE\n\n\n00082300               WRITE ***********************************\n\n\n00082400               WRITE *  INVALID SYNTAX OF DATASET NAME *\n\n\n00082500               WRITE ***********************************\n\n\n00082800               GOTO DIALUP\n\n\n00082900               ENDO\n\n\n00083100\n\n\n00083200           IF &RC NE 0 THEN DO\n\n\n00083300               WRITE\n\n\n00083400               WRITE ***********************************\n\n\n00083500               WRITE &OUTMSG\n\n\n00083600               WRITE ***********************************\n\n\n00083800               GOTO DIALUP\n\n\n00083900               ENDO\n\n\n00084000\n\n\n00084100           IF &DSORG NE PO THEN DO\n\n\n00084200               WRITE\n\n\n00084300               WRITE ********************************\n\n\n00084400               WRITE *  DATASET NOT PARTITIONED     *\n\n\n00084500               WRITE ********************************\n\n\n00084700               GOTO DIALUP\n\n\n00084800               ENDO\n\n\n00084900\n\n\n00085000           IF &MEMCNTL EQ YES THEN DO\n\n\n00085100               WRITE\n\n\n00085200               WRITE ********************************\n\n\n00085300               WRITE *  DO NOT PROVIDE MEMBER NAME  *\n\n\n00085400               WRITE ********************************\n\n\n00085600               GOTO DIALUP\n\n\n00085700               ENDO\n\n\n00085800\n\n\n00086000 ERR2:     ERROR DO\n\n\n00086100               WRITE\n\n\n00086200               WRITE ***********************************\n\n\n00086300               WRITE *  INVALID DIRECTORY ADDITION AMT *\n\n\n00086400               WRITE ***********************************\n\n\n00086600               WRITE\n\n\n00086700               GOTO GTDIRADD\n\n\n00086800               ENDO\n\n\n00086900\n\n\n00087000 GTDIRADD: WRITE\n\n\n00087100           WRITE ENTER THE NUMBER OF DIRECTORY\n\n\n00087200           WRITENR       BLOCKS TO ADD TO THE DIRECTORY===>\n\n\n00087300           READ &ADR\n\n\n00088000\n\n\n00089000           IF &DATATYPE(&ADR) NE NUM THEN DO\n\n\n00089200               WRITE\n\n\n00089300               WRITE ***********************************\n\n\n00089400               WRITE *  INVALID DIRECTORY ADDITION AMT *\n\n\n00089500               WRITE ***********************************\n\n\n00089700               WRITE\n\n\n00089800               GOTO GTDIRADD\n\n\n00089900               ENDO\n\n\n00090000\n\n\n00090100           IF &ADR = 0 OR +\n\n\n00090200              &ADR GT 999 THEN DO\n\n\n00090300               WRITE\n\n\n00090400               WRITE ***********************************\n\n\n00090500               WRITE *  INVALID DIRECTORY ADDITION AMT *\n\n\n00090600               WRITE ***********************************\n\n\n00090800               WRITE\n\n\n00090900               GOTO GTDIRADD\n\n\n00091000               ENDO\n\n\n00091100\n\n\n00091200           ERROR OFF\n\n\n00091300\n\n\n00091400           SET &ADDAMT = 1000 + &ADR\n\n\n00091500           SET &ADDAMT = &STR(&SUBSTR(2:4,&ADDAMT))\n\n\n00091600\n\n\n00091700           CONTROL NOMSG\n\n\n00091801           FREE F(DUMDUM)\n\n\n00091900\n\n\n00092000           CONTROL MSG\n\n\n00092101           ALLOC F(DUMDUM) DUMMY\n\n\n00092600\n\n\n00092700           WRITE\n\n\n00092800\n\n\n00092904           STACK DDOUT(DUMDUM)\n\n\n00093200           PDS '&FULLDSN' FIXPDS EXPAND(&ADDAMT)\n\n\n00100000           SET &RC = &LASTCC\n\n\n00101000\n\n\n00102000           IF &RC = 0 THEN WRITE SUCCESSFUL COMPLETION\n\n\n00105000\n\n\n00110008           ISPEXEC CONTROL DISPLAY REFRESH\n\n\n00120008           EXIT\n\n\n./ ADD NAME=FINDTTR  0101-80157-80157-1124-00017-00012-00007-KK00150\n00010001PROC 1 DSNAME T\n\n\n00011000CONTROL NOFLUSH END(ENDO) NOMSG\n\n\n00020000FREE F(PDS  PRINT)\n\n\n00021000CONTROL MSG\n\n\n00030000ALLOC F(PDS) DA(&DSNAME)\n\n\n00040000ALLOC F(PRINT) DA(*)\n\n\n00040100WRITE ENTER STRING TO FIND:\n\n\n00040200READ\n\n\n00040300SET &PRM = &STR(&SYSDVAL)\n\n\n00041000IF &SUBSTR(1,&STR(&PRM)) = &STR(') THEN +\n\n\n00042000  SET &PRM = &SUBSTR(2:&LENGTH(&STR(&PRM))-1,&STR(&PRM))\n\n\n00043001IF &T NE T THEN DO\n\n\n00043101                CALL 'KK00150.MY.LOAD(FINDTTR)' '&PRM'\n\n\n00044001                ENDO\n\n\n00045001           ELSE DO\n\n\n00046001                TEST 'KK00150.MY.LOAD(FINDTTR)' '&PRM'\n\n\n00047001                ENDO\n\n\n./ ADD NAME=FIREUP   0104-83249-85113-1610-00176-00176-00000-JS02150\n                    PROC 0 PANEL() MESSAGE() SKELETON() TABLEIN() TABLEOUT() -\n\n\n                           TAILOUT() SPFLOAD() PRINT()\n\n\n\n\n\n                    CONTROL NOMSG NOFLUSH END(ENDO)\n\n\n\n\n\n        ISPPLIB:    IF &PANEL = THEN GOTO ISPMLIB\n\n\n\n\n\n                    SET &THEDSN = &PANEL\n\n\n                    SET &WHICHONE = 1\n\n\n                    SET &WHICHLIB = &STR(PANEL LIBRARY)\n\n\n                    SET &DDNAM = ISPPLIB\n\n\n                    SET &RETERN = ISPMLIB\n\n\n                    GOTO FINFO\n\n\n\n\n\n        ISPMLIB:    IF &MESSAGE = THEN GOTO ISPSLIB\n\n\n\n\n\n                    SET &THEDSN = &MESSAGE\n\n\n                    SET &WHICHONE = 2\n\n\n                    SET &WHICHLIB = &STR(MESSAGE LIBRARY)\n\n\n                    SET &DDNAM = ISPMLIB\n\n\n                    SET &RETERN = ISPSLIB\n\n\n                    GOTO FINFO\n\n\n\n\n\n        ISPSLIB:    IF &SKELETON = THEN GOTO ISPTLIB\n\n\n\n\n\n                    SET &THEDSN = &SKELETON\n\n\n                    SET &WHICHONE = 3\n\n\n                    SET &WHICHLIB = &STR(SKELETON LIBRARY)\n\n\n                    SET &DDNAM = ISPSLIB\n\n\n                    SET &RETERN = ISPTLIB\n\n\n                    GOTO FINFO\n\n\n\n\n\n        ISPTLIB:    IF &TABLEIN = THEN GOTO ISPTABL\n\n\n\n\n\n                    SET &THEDSN = &TABLEIN\n\n\n                    SET &WHICHONE = 4\n\n\n                    SET &WHICHLIB = &STR(TABLE INPUT LIBRARY)\n\n\n                    SET &DDNAM = ISPTLIB\n\n\n                    SET &RETERN = ISPTABL\n\n\n                    GOTO FINFO\n\n\n\n\n\n        ISPTABL:    IF &TABLEOUT = THEN GOTO ISPFILE\n\n\n\n\n\n                    SET &THEDSN = &TABLEOUT\n\n\n                    SET &WHICHONE = 5\n\n\n                    SET &WHICHLIB = &STR(TABLE OUTPUT LIBRARY)\n\n\n                    SET &DDNAM = ISPTABL\n\n\n                    SET &RETERN = ISPFILE\n\n\n                    GOTO FINFO\n\n\n\n\n\n        ISPFILE:    IF &TAILOUT = THEN GOTO ISPLLIB\n\n\n\n\n\n                    FREE F(ISPFILE)\n\n\n                    CONTROL MSG\n\n\n                    ALLOC F(ISPFILE) DA(&TAILOUT) SHR\n\n\n                    SET &RC = &LASTCC\n\n\n                    CONTROL NOMSG\n\n\n\n\n\n                    IF &PRINT NE YES THEN GOTO ISPLLIB\n\n\n\n\n\n                    IF &RC = 0 THEN DO\n\n\n                          WRITE FILE TAILORING OUTPUT LIBRARY ALLOCATED\n\n\n                          GOTO ISPLLIB\n\n\n                          ENDO\n\n\n\n\n\n        ISPLLIB:    IF &SPFLOAD = THEN GOTO KWIT\n\n\n\n\n\n                    SET &THEDSN = &SPFLOAD\n\n\n                    SET &WHICHONE = 7\n\n\n                    SET &WHICHLIB = &STR(SPF LINK LIBRARY)\n\n\n                    SET &DDNAM = ISPLLIB\n\n\n                    SET &RETERN = KWIT\n\n\n                    GOTO FINFO\n\n\n\n\n\n        KWIT:       GOTO ENDIT\n\n\n\n\n\n        FINFO:      FILEINFO DSN(&STR(&THEDSN))\n\n\n                    SET &RC = &LASTCC\n\n\n\n\n\n                    IF &RC EQ 96 THEN DO\n\n\n                        WRITE **************************************************\n*********\n\n                        WRITE INVALID DSNAME SYNTAX OF &WHICHLIB\n\n\n                        WRITE **************************************************\n*********\n\n                        GOTO EXITINFO\n\n\n                        ENDO\n\n\n\n\n\n                    IF &RC NE 0 THEN DO\n\n\n                        WRITE *******************************************\n\n\n                        WRITE &OUTMSG\n\n\n                        WRITE *******************************************\n\n\n                        GOTO EXITINFO\n\n\n                        ENDO\n\n\n\n\n\n                    IF &WHICHONE = 6 THEN GOTO FINFO2\n\n\n\n\n\n                    IF &DSORG NE PO THEN DO\n\n\n                        WRITE *******************************************\n\n\n                        WRITE THE &WHICHLIB MUST BE PARTITIONED\n\n\n                        WRITE *******************************************\n\n\n                        GOTO EXITINFO\n\n\n                        ENDO\n\n\n\n\n\n                    IF &MEMCNTL EQ YES THEN DO\n\n\n                        WRITE **************************\n\n\n                        WRITE DO NOT PROVIDE MEMBER NAME\n\n\n                        WRITE **************************\n\n\n                        GOTO EXITINFO\n\n\n                        ENDO\n\n\n\n\n\n        FINFO2:     IF &WHICHONE NE 7 THEN GOTO FINFO3\n\n\n\n\n\n                    IF &RECFM NE U THEN DO\n\n\n                        WRITE **************************************************\n****************\n\n                        WRITE THE &WHICHLIB MUST CONTAIN UNDEFINED RECORDS\n\n\n                        WRITE **************************************************\n****************\n\n                        GOTO EXITINFO\n\n\n                        ENDO\n\n\n\n\n\n                    GOTO CONCAT\n\n\n\n\n\n        FINFO3:     IF &RECFM NE F THEN DO\n\n\n                        WRITE **************************************************\n****************\n\n                        WRITE THE &WHICHLIB MUST CONTAIN FIXED LENGTH RECORDS\n\n\n                        WRITE **************************************************\n****************\n\n                        GOTO EXITINFO\n\n\n                        ENDO\n\n\n\n\n\n                    IF &LRECL NE 80 THEN DO\n\n\n                        WRITE **************************************************\n*\n\n                        WRITE LRECL OF &WHICHLIB MUST BE 80\n\n\n                        WRITE **************************************************\n*\n\n                        GOTO EXITINFO\n\n\n                        ENDO\n\n\n\n\n\n                    IF &WHICHONE = 4 OR +\n\n\n                       &WHICHONE = 5 OR +\n\n\n                       &WHICHONE = 6 THEN GOTO CONCAT\n\n\n\n\n\n                    IF &BLKSIZE LT 3120 THEN DO\n\n\n                        WRITE ***********************************************\n\n\n                        WRITE BLOCK SIZE OF &WHICHLIB\n\n\n                        WRITE GREATER THAN OR EQUAL TO 3120\n\n\n                        WRITE ***********************************************\n\n\n                        GOTO EXITINFO\n\n\n                        ENDO\n\n\n\n\n\n        CONCAT:     WHATDSN DDNAME(&DDNAM)\n\n\n                    SET &RC = &LASTCC\n\n\n\n\n\n                    IF &RC NE 0 THEN GOTO CONCATM\n\n\n\n\n\n                    IF &FULLDSN NE &DSNAME THEN GOTO CONCATM\n\n\n\n\n\n                    IF &PRINT NE YES THEN GOTO EXITINFO\n\n\n\n\n\n                    WRITE &WHICHLIB ALLOCATED   (PREVIOUSLY)\n\n\n                    GOTO EXITINFO\n\n\n\n\n\n        CONCATM:    CONCATEM ACTCODE(A) DDNAME(&DDNAM) DSNAME('&FULLDSN')\n\n\n                    SET &RC = &LASTCC\n\n\n\n\n\n                    IF &PRINT NE YES THEN GOTO EXITINFO\n\n\n\n\n\n                    IF &RC = 0 THEN DO\n\n\n                          WRITE &WHICHLIB ALLOCATED\n\n\n                          GOTO EXITINFO\n\n\n                          ENDO\n\n\n\n\n\n                    WRITE *****************************************************\n\n\n                    WRITE &OUTMSG\n\n\n                    WRITE        (RETURN CODE = &RC)\n\n\n                    WRITE *****************************************************\n\n\n\n\n\n        EXITINFO:   GOTO &RETERN\n\n\n\n\n\n        ENDIT:      EXIT\n\n\n./ ADD NAME=FNDSMEM  0105-86048-86199-1259-00178-00176-00000-LL02155\n                 CONTROL NOMSG NOFLUSH END(ENDO)\n\n\n\n\n\n                 SET &OPENSW = &STR(NO)\n\n\n\n\n\n                 SET &FNDSERR = &STR(FNDSMEM ERROR F01)\n\n\n                 ISPEXEC VPUT FNDSERR SHARED\n\n\n\n\n\n                 ISPEXEC VGET FNDSDSN SHARED\n\n\n                 SET &RC = &LASTCC\n\n\n\n\n\n                 IF &RC NE 0 THEN DO\n\n\n                    SET &FNDSERR = &STR(FNDSMEM ERROR F02)\n\n\n                    ISPEXEC VPUT FNDSERR SHARED\n\n\n                    GOTO ENDIT\n\n\n                    ENDO\n\n\n\n\n\n                 ISPEXEC VGET FNDSRCH SHARED\n\n\n                 SET &RC = &LASTCC\n\n\n\n\n\n                 IF &RC NE 0 THEN DO\n\n\n                    SET &FNDSERR = &STR(FNDSMEM ERROR F03)\n\n\n                    ISPEXEC VPUT FNDSERR SHARED\n\n\n                    GOTO ENDIT\n\n\n                    ENDO\n\n\n\n\n\n                 ISPEXEC VGET FNDSVOL SHARED\n\n\n                 SET &RC = &LASTCC\n\n\n\n\n\n                 IF &RC NE 0 THEN DO\n\n\n                    SET &FNDSERR = &STR(FNDSMEM ERROR F07)\n\n\n                    ISPEXEC VPUT FNDSERR SHARED\n\n\n                    GOTO ENDIT\n\n\n                    ENDO\n\n\n\n\n\n                 IF &FNDSVOL = &STR(ABSENT) THEN DO\n\n\n                      CONTROL NOMSG\n\n\n                      FREE F(PROCLIB)\n\n\n                      CONTROL MSG\n\n\n                      ALLOC F(PROCLIB) DA('&FNDSDSN') SHR\n\n\n                      SET &VOLPARAM =\n\n\n                      SET &PANULMSG = &STR(&FNDSDSN)\n\n\n                      GOTO ALLOCPRT\n\n\n                      ENDO\n\n\n\n\n\n                 CONTROL NOMSG\n\n\n                 FREE F(PROCLIB)\n\n\n\n\n\n                 DEVTYPE VOL(&FNDSVOL)\n\n\n                 SET &RC = &LASTCC\n\n\n\n\n\n                 IF &RC NE 0 THEN DO\n\n\n                    SET &FNDSERR = &STR(FNDSMEM ERROR F08)\n\n\n                    ISPEXEC VPUT FNDSERR SHARED\n\n\n                    GOTO ENDIT\n\n\n                    ENDO\n\n\n\n\n\n                 CONTROL MSG\n\n\n                 ALLOC F(PROCLIB) DA('&FNDSDSN') SHR -\n\n\n                     UNIT(&DEVTYP) VOL(&FNDSVOL)\n\n\n\n\n\n                 SET &VOLPARAM = &STR(VOLUME(&FNDSVOL))\n\n\n                 SET &PANULMSG = &STR(VOL=&FNDSVOL  DSN=&FNDSDSN)\n\n\n\n\n\n             ALLOCPRT: +\n\n\n                 CONTROL NOMSG\n\n\n                 FREE F(PRINT)\n\n\n                 CONTROL MSG\n\n\n                 ALLOC F(PRINT) NEW UNIT(SYSSQ) TRACKS SPACE(9,4)\n\n\n\n\n\n                 IF &SUBSTR(1,&STR(&FNDSRCH)) = &STR(') THEN +\n\n\n                     SET &FNDSRCH = &SUBSTR(2:&LENGTH(&STR(&FNDSRCH))-1,&STR(&FN\nDSRCH))\n\n\n\n\n                 CALL 'WDPSC.SHARED.LOAD(FINDEM)' '&FNDSRCH'\n\n\n                 SET &FNDSRC = &LASTCC\n\n\n\n\n\n                 CONTROL NOMSG\n\n\n                 FREE F(PROCLIB)\n\n\n\n\n\n                 ISPEXEC TBCREATE FNDSMEM NAMES(TYPCODE MBRNAME) NOWRITE\n\n\n                 SET &RC = &LASTCC\n\n\n\n\n\n                 IF &RC NE 0 THEN DO\n\n\n                      SET &FNDSERR = &STR(FNDSMEM ERROR F04)\n\n\n                      ISPEXEC VPUT FNDSERR SHARED\n\n\n                      GOTO ENDIT\n\n\n                      ENDO\n\n\n\n\n\n                 SET &OPENSW = &STR(YES)\n\n\n\n\n\n                 IF &FNDSRC NE 0 THEN DO\n\n\n                      SET &FNDSERR = &STR(CANNOT SEARCH LIBRARIES WITH MORE THAN\n 2500 MEMBERS)\n\n                      ISPEXEC VPUT FNDSERR SHARED\n\n\n                      GOTO ENDIT\n\n\n                      ENDO\n\n\n\n\n\n                 OPENFILE PRINT INPUT\n\n\n\n\n\n                 SET &CTR = 0\n\n\n\n\n\n        LOOP:    ERROR DO\n\n\n                      SET &RC = &LASTCC\n\n\n                      IF &RC = 400 THEN GOTO CLOS\n\n\n                      SET &FNDSERR = &STR(FNDSMEM ERROR F05)\n\n\n                      ISPEXEC VPUT FNDSERR SHARED\n\n\n                      GOTO CLOS\n\n\n                      ENDO\n\n\n\n\n\n                 GETFILE PRINT\n\n\n                 ERROR OFF\n\n\n                 SET &BUFFER = &STR(&PRINT)\n\n\n\n\n\n                 SET &TYPCODE = &STR(_)\n\n\n                 SET &MBRNAME = &STR(&SUBSTR(26:33,&STR(&BUFFER))\n\n\n\n\n\n                 ISPEXEC TBADD FNDSMEM\n\n\n                 SET &RC = &LASTCC\n\n\n                 IF &RC NE 0 THEN DO\n\n\n                      SET &FNDSERR = &STR(FNDSMEM ERROR F06)\n\n\n                      ISPEXEC VPUT FNDSERR SHARED\n\n\n                      GOTO ENDIT\n\n\n                      ENDO\n\n\n\n\n\n                 SET &CTR = &CTR + 1\n\n\n                 GOTO LOOP\n\n\n\n\n\n        CLOS:    ERROR OFF\n\n\n                 CLOSFILE PRINT\n\n\n\n\n\n                 IF &CTR = 0 THEN DO\n\n\n                      SET &FNDSERR = &STR(NO HITS FOUND IN ANY MEMBERS)\n\n\n                      ISPEXEC VPUT FNDSERR SHARED\n\n\n                      GOTO ENDIT\n\n\n                      ENDO\n\n\n\n\n\n                 ISPEXEC TBTOP FNDSMEM\n\n\n                 SET &MSGID = &STR(FNDS100)\n\n\n\n\n\n        DSPANEL: ISPEXEC TBDISPL FNDSMEM PANEL(FNDSMEM) MSG(&MSGID)\n\n\n                 SET &RC = &LASTCC\n\n\n\n\n\n                 IF &RC NE 0 THEN DO\n\n\n                      SET &FNDSERR = &STR(NO ERROR ENCOUNTERED)\n\n\n                      ISPEXEC VPUT FNDSERR SHARED\n\n\n                      GOTO ENDIT\n\n\n                      ENDO\n\n\n\n\n\n                 ERROR DO\n\n\n                      ERROR OFF\n\n\n                      SET &MSGID = &STR(FNDS101)\n\n\n                      GOTO DSPANEL\n\n\n                      ENDO\n\n\n\n\n\n                 IF &TYPCODE = &STR(S) OR +\n\n\n                    &TYPCODE = &STR(E) THEN DO\n\n\n                       SET &SERVICE = &STR(EDIT)\n\n\n                       GOTO DOIT\n\n\n                       ENDO\n\n\n\n\n\n                 IF &TYPCODE = &STR(B) THEN DO\n\n\n                       SET &SERVICE = &STR(BROWSE)\n\n\n                       GOTO DOIT\n\n\n                       ENDO\n\n\n\n\n\n                 ERROR OFF\n\n\n\n\n\n                 SET &MSGID = &STR(FNDS101)\n\n\n                 GOTO DSPANEL\n\n\n\n\n\n        DOIT:    ERROR OFF\n\n\n                 SET &THEMEMBR = &SUBSTR(1:&LENGTH(&MBRNAME),&MBRNAME)\n\n\n\n\n\n                 ISPEXEC &SERVICE DATASET('&FNDSDSN(&THEMEMBR)') &VOLPARAM\n\n\n\n\n\n                 SET &MSGID = &STR(FNDS100)\n\n\n                 GOTO DSPANEL\n\n\n\n\n\n        ENDIT:   IF &OPENSW = &STR(YES) THEN ISPEXEC TBEND FNDSMEM\n\n\n                 EXIT\n\n\n./ ADD NAME=FULLUT1  0106-80207-82348-1035-00222-00213-00015-LL02150\n00010000PROC 5 FSOPT SCREEN FORLIB ASMSRC ASMLOD +\n\n\n00020000        CTL1() CTL2() CTL3() CTL4() CTL5() CTL6()\n\n\n00030000CONTROL MAIN NOMSG END(ENDO)\n\n\n00040000SET &CF = N\n\n\n00050000IF &SYSPREF = CTEST THEN CONTROL MSG LIST CONLIST SYMLIST\n\n\n00060000\n\n\n00070000SET CTL = &STR(&&CTL)\n\n\n00080000SET I = 1\n\n\n00090000DO WHILE &I < 7\n\n\n00100000     IF &STR(&CTL&I) = Q THEN SET CTL&I = &STR(?)\n\n\n00110000     IF &STR(&CTL&I) = A THEN SET CTL&I = &STR('')\n\n\n00120000     IF &STR(&CTL&I) = N THEN SET CTL&I = &STR(\u00ac)\n\n\n00130000     SET &I = &I + 1\n\n\n00140000   ENDO\n\n\n00150000\n\n\n00160000IF &ASMSRC NE \u00a2\u00a2\u00a2 THEN DO\n\n\n00170000    IF &SYSPREF = &SYSUID THEN SET &FULLGEN = &STR(FULLGEN)\n\n\n00180000                          ELSE SET &FULLGEN = &STR(&SYSUID..FULLGEN)\n\n\n00190000                       ENDO\n\n\n00200000                  ELSE DO\n\n\n00210000    IF &SYSPREF = &SYSUID THEN SET &FULLGEN = &STR(FULLGEN.&SCREEN)\n\n\n00220000                 ELSE SET &FULLGEN = &STR(&SYSUID..FULLGEN.&SCREEN)\n\n\n00230000                       ENDO\n\n\n00240000\n\n\n00250000IF &SUBSTR(1,&FORLIB) NE &STR(') THEN SET &FORLIB = &SYSPREF..&FORLIB\n\n\n00260000       ELSE SET &FORLIB = &SUBSTR(2:&LENGTH(&FORLIB)-1,&FORLIB)\n\n\n00270000IF &SUBSTR(1,&ASMSRC) NE &STR(') THEN SET &ASMSRC = &SYSPREF..&ASMSRC\n\n\n00280000       ELSE SET &ASMSRC = &SUBSTR(2:&LENGTH(&ASMSRC)-1,&ASMSRC)\n\n\n00290000IF &SUBSTR(1,&ASMLOD) NE &STR(') THEN SET &ASMLOD = &SYSPREF..&ASMLOD\n\n\n00300000       ELSE SET &ASMLOD = &SUBSTR(2:&LENGTH(&ASMLOD)-1,&ASMLOD)\n\n\n00310000\n\n\n00320000IF &FSOPT NE A THEN DO\n\n\n00330000     IF &FORLIB = &SYSPREF..\u00a2\u00a2\u00a2 THEN DO\n\n\n00340000                  WRITE ERROR - FORMAT LIBRARY WAS NOT ENTERED.\n\n\n00350000                  EXIT\n\n\n00360000                                     ENDO\n\n\n00370000     ERROR  DO\n\n\n00380000             SET RC = &LASTCC\n\n\n00390000             IF &RC < 4 THEN WRITE DATASET IS NOT A PDS:\n\n\n00400000               ELSE WRITE FORMAT LIBRARY COULD NOT BE FOUND:\n\n\n00410000             WRITE       '&FORLIB'\n\n\n00420000             EXIT\n\n\n00430000            ENDO\n\n\n00440000     DATASTAT '&FORLIB'\n\n\n00450000     ERROR OFF\n\n\n00460000                    ENDO\n\n\n00470000\n\n\n00480000IF &ASMSRC NE &SYSPREF..\u00a2\u00a2\u00a2 THEN DO\n\n\n00490000     ERROR  DO\n\n\n00500000             SET RC = &LASTCC\n\n\n00510000             IF &RC < 4 THEN WRITE DATASET IS NOT A PDS:\n\n\n00520000               ELSE WRITE SOURCE LIBRARY COULD NOT BE FOUND:\n\n\n00530000             WRITE       '&ASMSRC'\n\n\n00540000             EXIT\n\n\n00550000            ENDO\n\n\n00560000     DATASTAT '&ASMSRC'\n\n\n00570000     ERROR OFF\n\n\n00580000                                 ENDO\n\n\n00590000\n\n\n00600000IF &FSOPT NE G THEN DO\n\n\n00610000    IF &ASMLOD = &SYSPREF..\u00a2\u00a2\u00a2 THEN DO\n\n\n00620000                            WRITE ERROR - LOAD LIBRARY WAS NOT ENTERED.\n\n\n00630000                            EXIT\n\n\n00640000                                    ENDO\n\n\n00650000     ERROR DO\n\n\n00660000             SET RC = &LASTCC\n\n\n00670000             IF &RC < 4 THEN WRITE DATASET IS NOT A PDS:\n\n\n00680000               ELSE WRITE LOAD LIBRARY COULD NOT BE FOUND:\n\n\n00690000            WRITE     '&ASMLOD'\n\n\n00700000            EXIT\n\n\n00710000           ENDO\n\n\n00720000     DATASTAT '&ASMLOD'\n\n\n00730000     ERROR OFF\n\n\n00740000                    ENDO\n\n\n00750000\n\n\n00760000IF &FSOPT = A THEN DO\n\n\n00770000\n\n\n00780000       IF &ASMSRC = &SYSPREF..\u00a2\u00a2\u00a2 THEN DO\n\n\n00790000          ERROR DO\n\n\n00800000                  SET RC = &LASTCC\n\n\n00810000                  IF &RC < 2 THEN GOTO ASMIT\n\n\n00820000                    ELSE WRITE ERROR - SOURCE COULD NOT BE FOUND:\n\n\n00830000                  EXIT\n\n\n00840000                ENDO\n\n\n00850000          DATASTAT &FULLGEN..ASM\n\n\n00860000          ERROR OFF\n\n\n00870000          WRITE INVALID SOURCE DATASET.\n\n\n00880000          EXIT\n\n\n00890000                                       ENDO\n\n\n00900000\n\n\n00910000                                  ELSE GOTO ASMIT\n\n\n00920000                   ENDO\n\n\n00930000\n\n\n00940000  ERROR DO\n\n\n00950000     SET CC = &LASTCC\n\n\n00960000     IF &CC NE 8 THEN DO\n\n\n00970000                     WRITE UNKNOWN I/O ERROR- RETURN CODE WAS &CC\n\n\n00980000                     WRITE PLEASE CHECK YOUR FORMAT LIBRARY NAME;\n\n\n00990000                     EXIT\n\n\n01000000                       ENDO\n\n\n01010000     KOMM CLEAR RESET\n\n\n01020000     WRITE MEMBER &SCREEN NOT FOUND IN '&FORLIB'.\n\n\n01030000     WRITE MEMBER IS BEING CREATED - PLEASE WAIT.\n\n\n01040000     ERROR OFF\n\n\n01050000     FREE F(IN01,OUT01,MESSAGES)\n\n\n01060000     ALLOC F(IN01) DSN('WDPSC.CARD(QUICK)') SHR\n\n\n01070000     ALLOC F(OUT01) DSN('&FORLIB(&SCREEN)') SHR\n\n\n01080000     ALLOC F(MESSAGES) DUMMY\n\n\n01090000     ERROR DO\n\n\n01100000           WRITE ERROR - &SCREEN COULD NOT BE CREATED.\n\n\n01110000           EXIT\n\n\n01120000           ENDO\n\n\n01130000     CALL 'WDPSC.SYSLIBRY(FTL)' '01'\n\n\n01140000     GOTO OPTLAB1\n\n\n01150000        ENDO\n\n\n01160000MEMSTAT '&FORLIB(&SCREEN)'  NOPRINT\n\n\n01170000\n\n\n01180000OPTLAB1:ERROR OFF\n\n\n01190001FREE F(FILEOUT,SCREEN,CRSADDR) ATTR(KAT1)\n\n\n01200000ALLOC F(SCREEN) DSN('&FORLIB(&SCREEN)') SHR\n\n\n01201006ALLOC F(CRSADDR) DSN('WDPSC.FS.ADDRESS') SHR\n\n\n01210000\n\n\n01220000ERROR DO\n\n\n01230000      ERROR\n\n\n01240000      ATTR KAT1 LRECL(80) RECFM(F B) BLK(4000)\n\n\n01250000      ALLOC F(FILEOUT) DSN(&FULLGEN..ASM) NEW TRACK SP(3,3) US(KAT1)\n\n\n01260000      ENDO\n\n\n01270000ALLOC F(FILEOUT) DSN(&FULLGEN..ASM)\n\n\n01280000\n\n\n01290000ERROR DO\n\n\n01300000      SET QRC = &LASTCC\n\n\n01310000      IF &QRC = 5 THEN EXIT CODE(0)\n\n\n01320000      WRITE RETURN CODE WAS &QRC\n\n\n01330000      WRITE UNKNOWN ERROR IN SCREEN GENERATOR.\n\n\n01340000      EXIT\n\n\n01350000      ENDO\n\n\n01360000\n\n\n01370002CALL 'WDPSC.SYSLIBRY(QUICK)' +\n\n\n01380000 '&CTL1&CTL2&CTL3&CTL4&CTL5&CTL6&SCREEN/' /*  CALL SCREEN GENERATOR  */\n\n\n01390000\n\n\n01400000\n\n\n01410000ERROR DO\n\n\n01420000      SET &A = &LASTCC\n\n\n01430000      ERROR OFF\n\n\n01440000  KOMM RESET CLEAR\n\n\n01450000      IF &A = SB37 OR &A = SD37 OR &A = SE37 THEN DO\n\n\n01460000                  WRITE NO SPACE AVAILABLE TO PLACE &SCREEN\n\n\n01470000                  WRITE INTO ASSEMBLER SOURCE DATASET &ASMSRC;\n\n\n01480000                  WRITE ASSEMBLER SOURCE IS IN &SYSPREF..&FULLGEN..ASM\n\n\n01490003                  EXIT\n\n\n01500000                        ENDO\n\n\n01510000      WRITE ERROR CODE &A OCCURED WHILE SAVING ASSEMBLER SOURCE.\n\n\n01520000      WRITE ASSEMBLER SOURCE IS IN &SYSPREF..&FULLGEN..ASM\n\n\n01521003      WRITE\n\n\n01522003      WRITE POSSIBLY ANOTHER USER IS EDITING &ASMSRC\n\n\n01523003      WRITE THIS MEANS THAT THIS APPLICATION CANNOT SUCCESSFULLY SAVE\n\n\n01524003      WRITE YOUR NEW MEMBER\n\n\n01525003      WRITE\n\n\n01526003      WRITE EITHER SPECIFY ANOTHER LIBRARY WHICH IS NOT BEING USED AT\n\n\n01527003      WRITE THIS TIME OR RECONSIDER SPECIFYING ONE AT ALL.  THIS LIBRARY\n\n\n01528003      WRITE IS NOT REQUIRED\n\n\n01530003      EXIT\n\n\n01540000      ENDO\n\n\n01550000CONTROL MSG\n\n\n01560000IF &ASMSRC NE &SYSPREF..\u00a2\u00a2\u00a2 THEN COPY &FULLGEN..ASM '&ASMSRC(&SCREEN)' N\nONUM\n\n01570000      ELSE DO\n\n\n01580000           KOMM CL RES\n\n\n01590000           WRITE ASSEMBLER SOURCE IS IN &SYSPREF..&FULLGEN..ASM\n\n\n01600000           SET &CF = Y\n\n\n01610000           ENDO\n\n\n01620000\n\n\n01630000ASMCHK: IF &FSOPT = G THEN EXIT\n\n\n01640000\n\n\n01650000ASMIT:  CONTROL NOMSG\n\n\n01660000  IF &CF = N THEN KOMM RESET CLEAR\n\n\n01670000\n\n\n01680000  WRITE\n\n\n01690000  WRITE\n\n\n01700000  WRITE ..................... INTERACTIVE ASSEMBLY AND LINK EDIT .......\n...............\n\n01710000  WRITE\n\n\n01720000  WRITE ASSEMBLY IN PROGRESS\n\n\n01730000  SET &TERMOPT = NOTERM\n\n\n01740000  ERROR DO\n\n\n01750000    WRITE\n\n\n01760000    CONTROL MSG\n\n\n01770000    SET &TERMOPT = TERM\n\n\n01780000    ERROR DO\n\n\n01790000           SET RC = &LASTCC\n\n\n01800000           WRITE ERROR IN ASSEMBLY PROCESS: RETURN CODE WAS &RC\n\n\n01810000           IF &RC GT 8 THEN EXIT\n\n\n01820000       WRITE  ASSEMBLER LISTING WAS PLACED IN &SYSPREF..&FULLGEN..LIST\n\n\n01830000           EXIT\n\n\n01840000          ENDO\n\n\n01850000        ENDO\n\n\n01860000\n\n\n01870000IF &FSOPT NE A OR &ASMSRC = &SYSPREF..\u00a2\u00a2\u00a2 THEN +\n\n\n01880004  ASM   &FULLGEN         OBJ(&FULLGEN) LIB('USER.TSO.MACLIB') +\n\n\n01890000                         PRINT(&FULLGEN) &TERMOPT LIST\n\n\n01900000                                          ELSE +\n\n\n01910004  ASM '&ASMSRC(&SCREEN)' OBJ(&FULLGEN) LIB('USER.TSO.MACLIB') +\n\n\n01920000                         PRINT(&FULLGEN) &TERMOPT LIST\n\n\n01930000  WRITE\n\n\n01940000  WRITE ASSEMBLER LISTING PLACED IN &SYSPREF..&FULLGEN..LIST\n\n\n01950000  WRITE\n\n\n01960000  WRITE LINK EDIT IN PROGRESS\n\n\n01970000  CONTROL MSG\n\n\n01980000  ERROR DO\n\n\n01990000         SET RC = &LASTCC\n\n\n02000000         WRITE ERROR IN LINKEDIT PROCESS: RETURN CODE WAS &RC\n\n\n02010000         IF &RC GT 8 THEN EXIT\n\n\n02020000   WRITE  LINK EDIT LISTING WAS PLACED IN &SYSPREF..&FULLGEN..LINKLIST\n\n\n02030000         EXIT\n\n\n02040000        ENDO\n\n\n02050000  LINK &FULLGEN. LOAD('&ASMLOD(&SCREEN)') LIST MAP PRINT(&FULLGEN)\n\n\n02060000  ERROR OFF\n\n\n02070000  WRITE LINK EDIT LISTING PLACED IN &SYSPREF..&FULLGEN..LINKLIST\n\n\n02080000  WRITE\n\n\n02090000  WRITE\n\n\n02100000  SET IS = &STR( LOAD MODULE &SCREEN PLACED IN &ASMLOD )\n\n\n02110000  SET &L = &LENGTH(&IS)\n\n\n02120000  SET PS = &STR(.....................................................)\n\n\n02130000  WRITE &SUBSTR(1:(77-&L)/2,&PS)&IS&SUBSTR(1:(78-&L)/2,&PS)\n\n\n./ ADD NAME=FULLUT2  0103-80207-80288-1716-00182-00180-00006-LG00150\n00010000PROC 2 SCREEN ASMLOD SCRUFLG(0) IOBUFLG(0) SCRNFLG(0) DEST()\n\n\n00020000CONTROL NOMSG NOFLUSH END(ENDO)\n\n\n00030000IF &SYSPREF = CTEST THEN CONTROL MSG LIST CONLIST SYMLIST\n\n\n00040000\n\n\n00050000IF &SYSPREF = &SYSUID THEN SET &FULLANAL = &STR(FULLANAL)\n\n\n00060000                      ELSE SET &FULLANAL = &STR(&SYSUID..FULLANAL)\n\n\n00070000\n\n\n00080000IF &SUBSTR(1,&ASMLOD) NE &STR(') THEN SET &ASMLOD = &SYSPREF..&ASMLOD\n\n\n00090000       ELSE SET &ASMLOD = &SUBSTR(2:&LENGTH(&ASMLOD)-1,&ASMLOD)\n\n\n00100000\n\n\n00110000IF &DEST NE THEN DO\n\n\n00120000                 SET &DEST = &STR(DEST(&DEST))\n\n\n00130000                 ENDO\n\n\n00140000\n\n\n00150000FREE F(FILEOUT,JOBSTREM,IN,OUT,LIBR)\n\n\n00160000\n\n\n00170000ERROR DO\n\n\n00180000      SET RC = &LASTCC\n\n\n00190000      IF &RC < 4 THEN WRITE '&ASMLOD' IS NOT A PDS;\n\n\n00200000                 ELSE WRITE '&ASMLOD' COULD NOT BE FOUND;\n\n\n00210000      WRITE PLEASE CHECK YOUR DSNAME.\n\n\n00220000      EXIT\n\n\n00230000      ENDO\n\n\n00240000DATASTAT '&ASMLOD'\n\n\n00250000\n\n\n00260000ERROR DO\n\n\n00270000     SET CC = &LASTCC\n\n\n00280000     IF &CC NE 8 THEN DO\n\n\n00290000                     WRITE UNKNOWN ERROR- LASTCC WAS &CC.\n\n\n00300000                     WRITE PLEASE NOTIFY TSO COORDINATOR OF ERROR 1 IN F\nULLSCREEN ANALYZER.\n\n00310000                     EXIT\n\n\n00320000                      ENDO\n\n\n00330000     WRITE MEMBER &SCREEN NOT FOUND IN '&ASMLOD'\n\n\n00340000     EXIT\n\n\n00350000      ENDO\n\n\n00360000MEMSTAT '&ASMLOD(&SCREEN)'  NOPRINT\n\n\n00370000\n\n\n00380000ERROR DO\n\n\n00390000      ERROR OFF\n\n\n00400000      FREE F(FILEOUT) ATTR(AT1)\n\n\n00410000      ATTR AT1 BLKSIZE(800) LRECL(80) RECFM(F,B)\n\n\n00420000      ALLOC F(FILEOUT) DSN(&FULLANAL..SCREEN) NEW SPACE(1,1) TRACKS US(A\nT1)\n\n00430000      RETURN\n\n\n00440000      ENDO\n\n\n00450000ALLOC F(FILEOUT) DSN(&FULLANAL..SCREEN)\n\n\n00460000\n\n\n00470000ERROR OFF\n\n\n00480000SET &QUALNO1 = D&SUBSTR(1:2,&SYSDATE)&SUBSTR(4:5,&SYSDATE)&SUBSTR(7:8,&S\nYSDATE)\n\n00490000SET &QUALNO2 = T&SUBSTR(1:2,&SYSTIME)&SUBSTR(4:5,&SYSTIME)&SUBSTR(7:8,&S\nYSTIME)\n\n00500000FREE F(JOBSTREM) ATTR(AT5)\n\n\n00510000ATTR AT5 BLKSIZE(80) LRECL(80) RECFM(F,B)\n\n\n00520000ALLOC F(JOBSTREM) DSN(&FULLANAL..&QUALNO1..&QUALNO2..JOB) NEW -\n\n\n00530000TRACKS SP(1,1) US(AT5)\n\n\n00540000\n\n\n00550000ALLOC F(LIBR) DSN('&ASMLOD') SHR\n\n\n00560000\n\n\n00570000IF &SYSPREF = CTEST THEN CALL 'WDPSC.SYSLIBRY(WAITER)' '10'\n\n\n00580000\n\n\n00590000ERROR DO\n\n\n00600000      WRITE LASTCC IS &LASTCC\n\n\n00610000      WRITE PLEASE NOTIFY TSO COORDINATOR OF ERROR 2 IN FULLSCREEN ANALY\nZER.\n\n00620000      EXIT\n\n\n00630000      ENDO\n\n\n00640000\n\n\n00650003CALL 'WDPSC.SYSLIBRY(TUBE)' '&SCREEN'\n\n\n00660000\n\n\n00670000ERROR OFF\n\n\n00680000\n\n\n00690002IF &SCRUFLG = 0 AND &IOBUFLG = 0 AND &SCRNFLG = 0 THEN GOTO FAX\n\n\n00700000\n\n\n00710000KOMM RESET CLEAR\n\n\n00720000\n\n\n00730000IF &SCRUFLG NE 0 THEN DO\n\n\n00740000     FREE F(SYS260J,SYSIN,SYS260A,SYSPRINT)\n\n\n00750000     ALLOC F(SYSPRINT) DUMMY\n\n\n00760000     ALLOC F(SYS260J) SYSOUT(A) &DEST\n\n\n00770000     ALLOC F(SYS260A) DSN(&FULLANAL..&QUALNO1..&QUALNO2..JOB) SHR\n\n\n00780000     ALLOC F(SYSIN) DA('WDPSC.CARD(TUBEDYL)')\n\n\n00790000     SET I = 0\n\n\n00800000        DO WHILE &I < &SCRUFLG\n\n\n00810000          SET I = &I+1\n\n\n00820000          CALL 'WDPSC.SYSLIBRY(DYL260)'\n\n\n00830000        ENDO\n\n\n00840000     WRITE\n\n\n00850000     IF &SCRUFLG = 1 THEN WRITE ONE COPY OF SCRUFF WAS PRINTED.\n\n\n00860000                     ELSE +\n\n\n00870000     WRITE &SCRUFLG COPIES OF SCRUFF WERE PRINTED.\n\n\n00880000                      ENDO\n\n\n00890000\n\n\n00900000IF &IOBUFLG NE 0 THEN DO\n\n\n00910000     FREE F(SYS260A,SYSIN,SYSPRINT)\n\n\n00920000     ALLOC F(SYS260A) DSN(&FULLANAL..SCREEN) SHR\n\n\n00930000     ALLOC F(SYSIN) DSN('WDPSC.CARD(TUBE)') SHR\n\n\n00940000     ALLOC F(SYSPRINT) SYSOUT(A) &DEST\n\n\n00950000     SET I = 0\n\n\n00960000        DO WHILE &I < &IOBUFLG\n\n\n00970000          SET I = &I+1\n\n\n00980000          CALL 'WDPSC.SYSLIBRY(DYL260)'\n\n\n00990000        ENDO\n\n\n01000000     WRITE\n\n\n01010000     IF &IOBUFLG = 1 THEN WRITE ONE COPY OF THE I/O BUFFERS WAS PRINTED.\n\n\n01020000                     ELSE +\n\n\n01030000     WRITE &IOBUFLG COPIES OF THE I/O BUFFERS WERE PRINTED.\n\n\n01040000                      ENDO\n\n\n01050000\n\n\n01060000IF &IOBUFLG NE 0 OR &SCRUFLG NE 0 THEN DO\n\n\n01070000     FREE F(SYSIN,SYSPRINT,SYS260J)\n\n\n01080000     ALLOC F(SYSIN) DA(*)\n\n\n01090000     ALLOC F(SYSPRINT) DA(*)\n\n\n01100000                                       ENDO\n\n\n01110000\n\n\n01120000IF &SCRNFLG NE 0 THEN DO\n\n\n01130000\n\n\n01140000     GETMY PROG SYS ACCT          /*  FIND JOBCARD INFO   */\n\n\n01150000\n\n\n01160000     IF &STR(&PROG) = &STR(*TSO* 0000 T) THEN DO\n\n\n01170000        WRITENR PLEASE ENTER YOUR PROGRAMMER NAME FIELD ==>\n\n\n01180000        READ\n\n\n01190000        SET &L = &LENGTH(&SYSDVAL)\n\n\n01200000\n\n\n01210000        IF &L GE 20 THEN  SET &PROG = &SUBSTR(1:20,&SYSDVAL)\n\n\n01220000                    ELSE +\n\n\n01230000                          SET &PROG = +\n\n\n01240000           &STR(&SYSDVAL&SUBSTR(&L+1:20,&STR(*TSO* 0000 T          )))\n\n\n01250000\n\n\n01260000        WRITE\n\n\n01270000        WRITE TO AVOID BEING PROMPTED FOR PROGRAMMER NAME FIELD;\n\n\n01280000        WRITE PLEASE USE THE PROG OPERAND ON AT LEAST ONE LOGON COMMAND.\n\n\n01290000                                              ENDO\n\n\n01300000\n\n\n01310000       ERROR DO\n\n\n01320000             ERROR OFF\n\n\n01330000             COPY 'WDPSC.CARD(TUBE)' &FULLANAL..WORK\n\n\n01340000             ERROR DO\n\n\n01350000                   WRITE LASTCC IS &LASTCC.\n\n\n01360000                   WRITE PLEASE NOTIFY TSO COORDINATOR OF ERROR 3 IN FUL\nLSCREEN ANALYZER\n\n01370000                   EXIT\n\n\n01380000                   ENDO\n\n\n01390000             ENDO\n\n\n01400000\n\n\n01410000     EDIT '&SYSPREF..&FULLANAL..WORK' OLD CNTL\n\n\n01420000       ERROR DO\n\n\n01430000             WRITE LASTCC IS &LASTCC.\n\n\n01440000             WRITE PLEASE NOTIFY TSO COORDINATOR OF ERROR 4 IN FULLSCREE\nN ANALYZER\n\n01450000             END NOSAVE\n\n\n01460000             EXIT\n\n\n01470000             ENDO\n\n\n01480000     TOP\n\n\n01490000     DEL * 99999\n\n\n01500000     SET JOBNAME = &SUBSTR(1:2,&SYSUID)F&SYS&SUBSTR(5:7,&SYSUID)\n\n\n01510000     010 //&JOBNAME JOB (&ACCT),'&PROG',CLASS=A\n\n\n01520000     030 /*ROUTE  PRINT LOCAL\n\n\n01530000     040 //JOBCAT DD DSN=SYS1.USERCAT1,DISP=SHR\n\n\n01540000     050 //*\n\n\n01550000     060 //STEP1  EXEC  PGM=DYL260\n\n\n01560000     070 //SYSPRINT DD  DUMMY\n\n\n01570000     080 //SYS260A  DD DSN=&SYSPREF..&FULLANAL..&QUALNO1..&QUALNO2..JOB,\n\n\n01580000     085 //   DISP=(OLD,DELETE)\n\n\n01590000     090 //SYS260R  DD  SYSOUT=A,FLASH=NULL,CHARS=TN,COPIES=&SCRNFLG\n\n\n01600000     100 //SYSIN  DD  *\n\n\n01610000     110 C\n\n\n01620000     120 FA F\n\n\n01630000     130 R011060100   1\n\n\n01640000     140 T1 5\n\n\n01650000     150 T2F5\n\n\n01660000     160 P   10 U1         01        X\n\n\n01670000     170 P   80 A1         11        X\n\n\n01680000     180 P   10 U1         91        X\n\n\n01690000     WRITE\n\n\n01700000     IF &SCRNFLG = 1 THEN +\n\n\n01710000     WRITE THE FOLLOWING JOB WILL PRINT ONE COPY OF THE SCREEN:\n\n\n01720000                     ELSE +\n\n\n01730000     WRITE THE FOLLOWING JOB WILL PRINT &SCRNFLG COPIES OF THE SCREEN:\n\n\n01740000     CONTROL MSG\n\n\n01750000     IF &SYSPREF = CTEST THEN L\n\n\n01760000                         ELSE SUB *\n\n\n01770000     END NO\n\n\n01770102     ERROR OFF\n\n\n01771001     FREE DA('&SYSPREF..&FULLANAL..&QUALNO1..&QUALNO2..JOB') KEEP\n\n\n01780000                       ENDO\n\n\n01800002FAX: IF &SCRNFLG = 0 THEN +\n\n\n01810002     FREE DA('&SYSPREF..&FULLANAL..&QUALNO1..&QUALNO2..JOB') DELETE\n\n\n./ ADD NAME=HOSEDOWN 0108-81317-85113-1610-00161-00196-00000-JS02150\n                    PROC 0 PANEL() MESSAGE() SKELETON() TABLEIN() TABLEOUT() -\n\n\n                           TAILOUT() SPFLOAD() PRINT()\n\n\n\n\n\n                    CONTROL NOMSG NOFLUSH END(ENDO)\n\n\n\n\n\n                    IF &TABLEIN = AND +\n\n\n                       &TABLEOUT = THEN GOTO ISPPLIB\n\n\n\n\n\n                    IF &TABLEIN NE AND +\n\n\n                       &TABLEOUT NE THEN GOTO DOTABLES\n\n\n\n\n\n                    WRITE *****************************************\n\n\n                    WRITE *  YOU MUST EITHER SPECIFY BOTH THE TABLE\n\n\n                    WRITE *  INPUT AND OUTPUT LIBRARIES OR DO NOT\n\n\n                    WRITE *  SPECIFY EITHER ONE AT ALL\n\n\n                    WRITE *****************************************\n\n\n                    GOTO ISPPLIB\n\n\n\n\n\n        DOTABLES:   FREE F(ISPTABL)\n\n\n                    FREE F(ISPTLIB)\n\n\n\n\n\n                    IF &PRINT EQ YES THEN DO\n\n\n                         WRITE &STR(TABLE INPUT LIBRARY DE-ALLOCATED)\n\n\n                         WRITE &STR(TABLE OUTPUT LIBRARY DE-ALLOCATED)\n\n\n                         ENDO\n\n\n\n\n\n        ISPPLIB:    IF &PANEL = THEN GOTO ISPMLIB\n\n\n\n\n\n                    SET &THEDSN = &PANEL\n\n\n                    SET &WHICHONE = 1\n\n\n                    SET &WHICHLIB = &STR(PANEL LIBRARY)\n\n\n                    SET &DDNAM = ISPPLIB\n\n\n                    SET &RETERN = ISPMLIB\n\n\n                    GOTO FINFO\n\n\n\n\n\n        ISPMLIB:    IF &MESSAGE = THEN GOTO ISPSLIB\n\n\n\n\n\n                    SET &THEDSN = &MESSAGE\n\n\n                    SET &WHICHONE = 2\n\n\n                    SET &WHICHLIB = &STR(MESSAGE LIBRARY)\n\n\n                    SET &DDNAM = ISPMLIB\n\n\n                    SET &RETERN = ISPSLIB\n\n\n                    GOTO FINFO\n\n\n\n\n\n        ISPSLIB:    IF &SKELETON = THEN GOTO ISPFILE\n\n\n\n\n\n                    SET &THEDSN = &SKELETON\n\n\n                    SET &WHICHONE = 3\n\n\n                    SET &WHICHLIB = &STR(SKELETON LIBRARY)\n\n\n                    SET &DDNAM = ISPSLIB\n\n\n                    SET &RETERN = ISPFILE\n\n\n                    GOTO FINFO\n\n\n\n\n\n        ISPFILE:    IF &TAILOUT = THEN GOTO ISPLLIB\n\n\n\n\n\n                    FREE F(ISPFILE)\n\n\n\n\n\n                    IF &PRINT EQ YES THEN DO\n\n\n                          WRITE FILE TAILORING OUTPUT LIBRARY &STR(DE-ALLOCATED)\n\n\n                          GOTO ISPLLIB\n\n\n                          ENDO\n\n\n\n\n\n        ISPLLIB:    IF &SPFLOAD = THEN GOTO KWIT\n\n\n\n\n\n                    SET &THEDSN = &SPFLOAD\n\n\n                    SET &WHICHONE = 7\n\n\n                    SET &WHICHLIB = &STR(SPF LINK LIBRARY)\n\n\n                    SET &DDNAM = ISPLLIB\n\n\n                    SET &RETERN = KWIT\n\n\n                    GOTO FINFO\n\n\n\n\n\n        KWIT:       GOTO ENDIT\n\n\n\n\n\n        FINFO:      FILEINFO DSN(&STR(&THEDSN))\n\n\n                    SET &RC = &LASTCC\n\n\n\n\n\n                    IF &RC EQ 96 THEN DO\n\n\n                        WRITE **************************************************\n*********\n\n                        WRITE INVALID DSNAME SYNTAX OF &WHICHLIB\n\n\n                        WRITE **************************************************\n*********\n\n                        GOTO EXITINFO\n\n\n                        ENDO\n\n\n\n\n\n                    IF &RC NE 0 THEN DO\n\n\n                        WRITE *******************************************\n\n\n                        WRITE &OUTMSG\n\n\n                        WRITE *******************************************\n\n\n                        GOTO EXITINFO\n\n\n                        ENDO\n\n\n\n\n\n                    IF &WHICHONE = 6 THEN GOTO FINFO2\n\n\n\n\n\n                    IF &DSORG NE PO THEN DO\n\n\n                        WRITE *******************************************\n\n\n                        WRITE THE &WHICHLIB MUST BE PARTITIONED\n\n\n                        WRITE *******************************************\n\n\n                        GOTO EXITINFO\n\n\n                        ENDO\n\n\n\n\n\n                    IF &MEMCNTL EQ YES THEN DO\n\n\n                        WRITE **************************\n\n\n                        WRITE DO NOT PROVIDE MEMBER NAME\n\n\n                        WRITE **************************\n\n\n                        GOTO EXITINFO\n\n\n                        ENDO\n\n\n\n\n\n        FINFO2:     IF &WHICHONE NE 7 THEN GOTO FINFO3\n\n\n\n\n\n                    IF &RECFM NE U THEN DO\n\n\n                        WRITE **************************************************\n****************\n\n                        WRITE THE &WHICHLIB MUST CONTAIN UNDEFINED RECORDS\n\n\n                        WRITE **************************************************\n****************\n\n                        GOTO EXITINFO\n\n\n                        ENDO\n\n\n\n\n\n                    GOTO UNCONCAT\n\n\n\n\n\n        FINFO3:     IF &RECFM NE F THEN DO\n\n\n                        WRITE **************************************************\n****************\n\n                        WRITE THE &WHICHLIB MUST CONTAIN FIXED LENGTH RECORDS\n\n\n                        WRITE **************************************************\n****************\n\n                        GOTO EXITINFO\n\n\n                        ENDO\n\n\n\n\n\n                    IF &LRECL NE 80 THEN DO\n\n\n                        WRITE **************************************************\n*\n\n                        WRITE LRECL OF &WHICHLIB MUST BE 80\n\n\n                        WRITE **************************************************\n*\n\n                        GOTO EXITINFO\n\n\n                        ENDO\n\n\n\n\n\n                    IF &WHICHONE = 4 OR +\n\n\n                       &WHICHONE = 5 OR +\n\n\n                       &WHICHONE = 6 THEN GOTO UNCONCAT\n\n\n\n\n\n                    IF &BLKSIZE LT 3120 THEN DO\n\n\n                        WRITE ***********************************************\n\n\n                        WRITE BLOCK SIZE OF &WHICHLIB\n\n\n                        WRITE GREATER THAN OR EQUAL TO 3120\n\n\n                        WRITE ***********************************************\n\n\n                        GOTO EXITINFO\n\n\n                        ENDO\n\n\n\n\n\n        UNCONCAT:   CONCATEM ACTCODE(D) DDNAME(&DDNAM) DSNAME('&FULLDSN')\n\n\n                    SET &RC = &LASTCC\n\n\n\n\n\n                    IF &PRINT NE YES THEN GOTO EXITINFO\n\n\n\n\n\n                    IF &RC = 0 THEN DO\n\n\n                          WRITE &WHICHLIB &STR(DE-ALLOCATED)\n\n\n                          GOTO EXITINFO\n\n\n                          ENDO\n\n\n\n\n\n                    WRITE *****************************************************\n\n\n                    WRITE &OUTMSG\n\n\n                    WRITE        (RETURN CODE = &RC)\n\n\n                    WRITE *****************************************************\n\n\n\n\n\n        EXITINFO:   GOTO &RETERN\n\n\n\n\n\n        ENDIT:      EXIT\n\n\n./ ADD NAME=HOTKEY   0101-89255-89255-1325-00358-00358-00001-KK00155\n00010000PROC 2 DSN FTN L CPOS(1) ISDDN(NO) OKDSN(NO) ML() U M C R +\n\n\n00011000       FILEAID(NO) ACF2(YES)\n\n\n00012000/* IF NOT USING ACF2 TO LIMIT ZAP ACCESS, CHANGE ACF2 PARM TO NO */\n\n\n00020000CONTROL NOFLUSH NOMSG END(ENDO)\n\n\n00021000SET &CURLVL = V2M0\n\n\n00022000IF &L = L THEN CONTROL NOFLUSH MSG LIST CONLIST SYMLIST\n\n\n00023000IF &SYSPREFIX = GX00155 THEN CONTROL NOFLUSH MSG LIST CONLIST SYMLIST\n\n\n00024000ISPEXEC CONTROL ERRORS RETURN\n\n\n00025000STACK FAST\n\n\n00025100SET ACFUID = XXXXYYYY\n\n\n00026000GETMY PROG SYS ACCT TERMID SYSID ACFUID\n\n\n00027000ISPEXEC VPUT (PROG SYS ACCT TERMID SYSID ACFUID) SHARED\n\n\n00028000SET &COMMLIST = &STR(BROWSE EDIT LIB INFO PDS TO FROM ZAP)\n\n\n00029000ISPEXEC VGET (ERRPNL HOTLVL) PROFILE\n\n\n00030000ISPEXEC VGET ZAPPLID ASIS\n\n\n00040000IF &ERRPNL = &STR() THEN SET ERRPNL = DISP\n\n\n00041000\n\n\n00041100IF &HOTLVL \u00ac= &CURLVL THEN +\n\n\n00041200  DO\n\n\n00041300  SET &HOTISR = ISR(OFF)\n\n\n00041400  SET &HOTIOF = IOF(OFF)\n\n\n00041500  SET &HOTFAXE = FAXE(OFF)\n\n\n00041600  SET HOT&ZAPPLID = &ZAPPLID(ON)\n\n\n00041700  WRITE PLEASE WAIT.  HOTKEYS FOR &SYSUID IS BEING UPDATED TO CURRENT LE\nVEL...\n\n00041800  %HOTKEYS REFRESH &HOTISR &HOTIOF &HOTFAXE\n\n\n00041900  WRITE HOTKEYS NOW AT &CURLVL LEVEL\n\n\n00042000  SET &HOTLVL = &CURLVL\n\n\n00042100  ISPEXEC VPUT HOTLVL PROFILE\n\n\n00042200  ENDO\n\n\n00042300\n\n\n00042400IF &STR(&DSN) = &STR(=) THEN +\n\n\n00042500  DO\n\n\n00042600  ISPEXEC SELECT PGM(ISPCDSN) PARM(DSN (SCREEN))\n\n\n00042700  SET CDSRC = &LASTCC\n\n\n00042800  IF &CDSRC NE 0 THEN +\n\n\n00042900    DO\n\n\n00043000    IF &ERRPNL = DISP THEN +\n\n\n00043100      DO\n\n\n00043200      IF &STR(&DSN) = &STR(=) THEN EXIT\n\n\n00043300      SET &GPM = &STR(BAD DSN-&CDSRC)\n\n\n00043400      SET &GPML = &STR(THE ITEM SELECTED MAY BE INVALID - &DSN)\n\n\n00043500      ISPEXEC DISPLAY PANEL(GPM)\n\n\n00043600      ENDO\n\n\n00043700    EXIT\n\n\n00043800    ENDO\n\n\n00043900  ISPEXEC VGET (DSN ISPCPOS) SHARED\n\n\n00044000  IF &LASTCC = 0 THEN +\n\n\n00045000    SET &CPOS = &ISPCPOS\n\n\n00046000  ELSE +\n\n\n00047000    EXIT CODE(99)\n\n\n00048000  ENDO\n\n\n00049000ELSE +\n\n\n00050000  SET &ISPCPOS = &CPOS\n\n\n00060000IF &SYSINDEX(&FTN,&COMMLIST) \u00ac= 0 THEN GOTO VCOMM\n\n\n00070000                                  ELSE GOTO V&FTN\n\n\n00080000\n\n\n00090000VBROWSE: GOTO VEDIT\n\n\n00100000VEDIT: +\n\n\n00110000IF &ISDDN = YES THEN +\n\n\n00120000  DO\n\n\n00130000  ISPEXEC LMINIT DATAID(ID) DDNAME(&DSN)\n\n\n00131000  IF &LASTCC \u00ac= 0 THEN SET &ERRFLAG = ON\n\n\n00132000  SET &EDBRCMD = ISPEXEC &FTN DATAID(&ID)\n\n\n00132100  SET &BADLMSG = &STR(YOUR DDNAME SELECTION WAS - &DSN)\n\n\n00132200  ENDO\n\n\n00132300ELSE +\n\n\n00132400  IF &OKDSN = YES THEN +\n\n\n00132500    DO\n\n\n00132600    SET &EDBRCMD = ISPEXEC &FTN DATASET(&DSN)\n\n\n00132700    SET &BADLMSG = &STR(YOUR DATASET SELECTION WAS - &DSN)\n\n\n00132800    ENDO\n\n\n00132900ELSE +\n\n\n00133000  DO\n\n\n00133100    SET &ERRFLAG = ON\n\n\n00133200    SET &BADSMSG = &STR(NOT FOUND)\n\n\n00133300    SET &BADLMSG = &STR(THE ITEM SELECTED MAY BE INVALID - &DSN)\n\n\n00133400  ENDO\n\n\n00133500GOTO &FTN\n\n\n00133600\n\n\n00133700VLIB:  GOTO VINFO\n\n\n00133800VINFO: +\n\n\n00133900IF &ISDDN = YES THEN +\n\n\n00134000  DO\n\n\n00134100  WHATDSN DDN(&DSN)\n\n\n00134200  SET FADSN = '&DSNAME'\n\n\n00134300  ENDO\n\n\n00134400ELSE +\n\n\n00134500  SET FADSN = &STR(&DSN)\n\n\n00134600SET MEMP = &SYSINDEX((,&STR(&FADSN))\n\n\n00134700IF &MEMP \u00ac= 0 THEN +\n\n\n00134800  DO\n\n\n00134900    SET FADSN = &SUBSTR(1:&MEMP-1,&STR(&FADSN))\n\n\n00135000    IF &SYSINDEX(',&STR(&FADSN)) = 1 THEN +\n\n\n00135100      SET &FADSN = &FADSN'\n\n\n00135200  ENDO\n\n\n00135300GOTO &FTN\n\n\n00135400\n\n\n00135500VPDS: +\n\n\n00135600IF &U \u00ac= U THEN +\n\n\n00135700  DO\n\n\n00135800  IF &ML \u00ac= &Z THEN SET &ML = &STR(ML &ML)\n\n\n00135900               ELSE SET &ML = &STR(ML :)\n\n\n00136000  SET &ML = &STR(&ML NOLKED)\n\n\n00137000  ENDO\n\n\n00138000ELSE +\n\n\n00139000  SET ML = &STR()\n\n\n00140000IF &ISDDN = YES THEN +\n\n\n00141000  SET &PDSCMD = PDS FILE(&DSN) &ML\n\n\n00142000ELSE IF &OKDSN = YES THEN +\n\n\n00143000  SET &PDSCMD = PDS &DSN &ML\n\n\n00144000GOTO &FTN\n\n\n00145000\n\n\n00146000VFROM: GOTO VTO\n\n\n00147000VTO: +\n\n\n00148000IF &FTN = FROM THEN SET NEXT = TO\n\n\n00149000               ELSE SET NEXT = FROM\n\n\n00150000IF &ISDDN = YES THEN +\n\n\n00160000  DO\n\n\n00170000  WHATDSN DDN(&DSN)\n\n\n00180000  SET &DSN = '&DSNAME'\n\n\n00190000  ENDO\n\n\n00191000SET &HOT&FTN = &DSN\n\n\n00192000ISPEXEC VPUT HOT&FTN PROFILE\n\n\n00193000SET ZPF = &&ZPF\n\n\n00194000SET ZPFL = &&ZPFL\n\n\n00195000SET I = 1\n\n\n00196000DO WHILE &I < 25\n\n\n00197000  SET J = &SUBSTR(2:3,&EVAL(100+&I))\n\n\n00198000  ISPEXEC VGET (ZPF&J ZPFL&J) PROFILE\n\n\n00199000  IF &STR(&ZPFL&J) = &STR(&FTN) THEN SET I = 25\n\n\n00199100  IF &STR(&ZPFL&J) = &STR(&FTN) THEN SET ZPF&J = &STR(OTSO %HOTKEY = &NE\nXT)\n\n00199200  IF &STR(&ZPFL&J) = &STR(&FTN) THEN SET ZPFL&J = &STR(&NEXT)\n\n\n00199300  ISPEXEC VPUT (ZPF&J ZPFL&J) PROFILE\n\n\n00199400  SET I = &I+1\n\n\n00199500  ENDO\n\n\n00199600GOTO &FTN\n\n\n00199700\n\n\n00199800VMENU: +\n\n\n00199900IF &ISDDN = YES THEN +\n\n\n00200000  DO\n\n\n00210000  WHATDSN DDN(&DSN)\n\n\n00220000  SET FULLDSN = &DSNAME\n\n\n00230000  ENDO\n\n\n00240000SET DSN = &FULLDSN\n\n\n00250000IF &SUBSTR(1:8,&ACFUID) = &STR(155D2100) OR   +\n\n\n00260000   &SUBSTR(1:8,&ACFUID) = &STR(155D2300) OR   +\n\n\n00261000   &ACF2 NE YES THEN +\n\n\n00270000  DO\n\n\n00280000  SET ZAPP = &STR( ZAP)\n\n\n00290000  SET ZAPPT = &STR(     - ACTIVATE URZAP FOR THIS DATASET)\n\n\n00300000  ENDO\n\n\n00310000SET CO = &STR( F)\n\n\n00320000SET COT = &STR((3.3)- COPY FROM ABOVE DATASET )\n\n\n00330000ISPEXEC VGET HOTFROM PROFILE\n\n\n00340000IF &HOTFROM NE &STR() THEN +\n\n\n00350000  DO\n\n\n00360000  SET REPT = &STR(REPLACE OPTION==>)\n\n\n00370000  SET CO = &STR( T)\n\n\n00380000  SET COT = &STR((3.3)- COPY TO ABOVE DATASET FROM &HOTFROM)\n\n\n00390000  ENDO\n\n\n00400000ISPEXEC DISPLAY PANEL(HOTMENU)\n\n\n00410000IF &LASTCC NE 0 THEN EXIT\n\n\n00420000IF &STR(&DSN) NE &STR('&FULLDSN') THEN GOTO VCOMM\n\n\n00430000EXIT\n\n\n00440000\n\n\n00450000VZAP: +\n\n\n00460000  IF &ISDDN = YES THEN +\n\n\n00470000    DO\n\n\n00480000    WHATDSN DDN(&DSN)\n\n\n00490000    SET &DSN = '&DSNAME'\n\n\n00500000    ENDO\n\n\n00510000ELSE +\n\n\n00520000  DO\n\n\n00530000  FILEINFO DSN(&DSN)\n\n\n00540000  SET &DSN = '&FULLDSN'\n\n\n00550000  ENDO\n\n\n00560000GOTO &FTN\n\n\n00570000\n\n\n00580000VFLIST: +\n\n\n00590000SET &FADSN = &DSN\n\n\n00600000SET FADSNL = &LENGTH(&FADSN)\n\n\n00610000SET FCHR = &SUBSTR(1,&DSN)\n\n\n00620000IF &FCHR \u00ac= &STR(') THEN +\n\n\n00630000  DO\n\n\n00640000  IF &FCHR = $ | &FCHR = # | &FCHR = @ THEN +\n\n\n00650000    DO\n\n\n00660000    SET &FADSN = &SUBSTR(2:&FADSNL,&FADSN)\n\n\n00670000    IF &CPOS > 1 THEN SET &CPOS = &CPOS - 1\n\n\n00680000    ENDO\n\n\n00681000  IF &SYSDSN('&FADSN') = OK THEN +\n\n\n00682000    SET &OKDSN = YES\n\n\n00683000  ELSE +\n\n\n00684000    DO\n\n\n00685000    SET &PFXFADSN = '&SYSPREF..&FADSN'\n\n\n00685100    IF &SYSDSN(&PFXFADSN) = OK THEN +\n\n\n00685200      DO\n\n\n00685300      SET &PFXLEN = &LENGTH(&SYSPREF)\n\n\n00685400      SET &FADSN = &PFXFADSN\n\n\n00685500      SET &CPOS = &CPOS + &PFXLEN + 2\n\n\n00685600      SET &OKDSN = YES\n\n\n00685700      ENDO\n\n\n00685800    ENDO\n\n\n00685900  ENDO\n\n\n00686000ELSE +\n\n\n00687000  IF &SYSDSN(&FADSN) = OK THEN SET &OKDSN = YES\n\n\n00687100SET FADSNL = &LENGTH(&FADSN)\n\n\n00687200IF &OKDSN = NO && &ISPCPOS = 1 THEN +\n\n\n00687300  SET &CPOS = &FADSNL\n\n\n00687400IF &SUBSTR(1,&FADSN) = &STR(') THEN +\n\n\n00687500  DO\n\n\n00687600  SET &FADSN = &SUBSTR(2:&FADSNL,&FADSN)\n\n\n00687700  IF &CPOS > 1 THEN SET &CPOS = &CPOS - 1\n\n\n00687800  SET &FADSNL = &FADSNL - 1\n\n\n00687900  ENDO\n\n\n00688000IF &SUBSTR(&FADSNL,&FADSN) = &STR(') THEN +\n\n\n00688100  DO\n\n\n00688200  SET &FADSN = &SUBSTR(1:&EVAL(&FADSNL-1),&FADSN)\n\n\n00688300  IF &CPOS = &FADSNL THEN SET &CPOS = &CPOS - 1\n\n\n00688400  SET &FADSNL = &FADSNL - 1\n\n\n00688500  ENDO\n\n\n00688600SET &FDELPOS = &SYSINDEX(.,&FADSN)\n\n\n00688700IF &FDELPOS = 0 THEN +\n\n\n00688800  SET &CPOS = &FADSNL\n\n\n00688900ELSE IF &CPOS < &FDELPOS THEN +\n\n\n00689000  SET &CPOS = &FDELPOS\n\n\n00689100SET &POSTPOS = &CPOS + 1\n\n\n00689200IF &POSTPOS > &FADSNL THEN +\n\n\n00689300  SET &FADSN = &FADSN..\n\n\n00689400SET &POSTCHR = &SUBSTR(&POSTPOS,&FADSN)\n\n\n00689500IF &POSTCHR = &STR(.) THEN +\n\n\n00689600  SET &CPOS = &CPOS+1\n\n\n00689700SET &FADSN = &SUBSTR(1:&CPOS,&FADSN)\n\n\n00689800SET &FADSN = &STR(&FADSN*)\n\n\n00689900GOTO &FTN\n\n\n00690000\n\n\n00690100VCOMM: +\n\n\n00690200SET F = &SUBSTR(1,&DSN)\n\n\n00690300IF &LENGTH(&STR(&DSN)) < 9 AND &F NE &STR(') THEN +\n\n\n00690400  DO\n\n\n00690500  SET P = &SYSINDEX(&STR(.),&STR(&DSN))\n\n\n00690600  SET M = &SYSINDEX((,&STR(&DSN))\n\n\n00690700  IF &P = 0 AND &M = 0 THEN +\n\n\n00690800    DO\n\n\n00690900    IFALC F(&DSN)\n\n\n00691000    IF &LASTCC = 0 THEN +\n\n\n00691100      DO\n\n\n00691200      SET &ISDDN = YES\n\n\n00691300      SET &OKDSN = YES\n\n\n00691400      ENDO\n\n\n00691500    ENDO\n\n\n00691600  ENDO\n\n\n00691700IF &ISDDN = NO THEN +\n\n\n00691800  DO\n\n\n00691900  IF &SYSDSN(&DSN) = OK THEN +\n\n\n00692000    SET &OKDSN = YES\n\n\n00692100  ELSE +\n\n\n00692200    DO\n\n\n00692300    IF &F \u00ac= &STR(') THEN +\n\n\n00692400      DO\n\n\n00692500      IF &SYSDSN('&DSN') = OK THEN +\n\n\n00692600        DO\n\n\n00692700        SET &DSN = &STR('&DSN')\n\n\n00692800        SET &OKDSN = YES\n\n\n00692900        ENDO\n\n\n00693000      ELSE IF &F = $ OR &F = # OR &F = @ THEN +\n\n\n00693100        DO\n\n\n00693200        SET &NADSN = '&SUBSTR(2:&LENGTH(&DSN),&DSN)'\n\n\n00693300        IF &SYSDSN(&NADSN) = OK THEN +\n\n\n00693400          DO\n\n\n00693500          SET &DSN = &NADSN\n\n\n00693600          SET &OKDSN = YES\n\n\n00693700          ENDO\n\n\n00693800        ENDO\n\n\n00693900      ENDO\n\n\n00694000    ENDO\n\n\n00694100  ENDO\n\n\n00694200IF &OKDSN = NO THEN +\n\n\n00694300  DO\n\n\n00694400  WHATDDN DS('&DSN')\n\n\n00694500  IF &LASTCC = 0 THEN +\n\n\n00694600    DO\n\n\n00694700    SET &DSN = &DDNAME1\n\n\n00694800    SET &ISDDN = YES\n\n\n00694900    ENDO\n\n\n00695000  ENDO\n\n\n00695100GOTO V&FTN\n\n\n00695200\n\n\n00695300BROWSE: GOTO EDIT\n\n\n00695400EDIT: +\n\n\n00695500&EDBRCMD\n\n\n00695600IF (&LASTCC > 4 | &ERRFLAG = ON) && &ERRPNL = DISP THEN +\n\n\n00695700  DO\n\n\n00695800    ISPEXEC SETMSG MSG(ISRZ002)\n\n\n00695900    SET &GPM  = &STR(&BADSMSG)\n\n\n00696000    SET &GPML = &STR(&BADLMSG)\n\n\n00697000    ISPEXEC DISPLAY PANEL(GPM)\n\n\n00698000  ENDO\n\n\n00699000EXIT\n\n\n00700000\n\n\n00701000LIB: +\n\n\n00702000SET &FADCMD = ISPEXEC SELECT PGM(ISRUDA) PARM(ISRUDA1)\n\n\n00703000GOTO FADCOMM\n\n\n00703100\n\n\n00703200INFO: +\n\n\n00703300SET DMPDSN =\n\n\n00703400ISPEXEC VPUT DMPDSN PROFILE\n\n\n00703500SET &FADCMD = ISPEXEC SELECT PANEL(IFAMU01) OPT(3.2)\n\n\n00703600IF &FILEAID NE YES THEN +\n\n\n00703700  DO\n\n\n00703800  SET FAOPT = I\n\n\n00703900  GOTO LIB\n\n\n00704000  ENDO\n\n\n00704100GOTO FADCOMM\n\n\n00704200\n\n\n00704300PDS: +\n\n\n00704400&PDSCMD\n\n\n00704500EXIT\n\n\n00705000\n\n\n00706000FROM: +\n\n\n00707000EXIT\n\n\n00708000\n\n\n00709000TO: +\n\n\n00710000IF &R = R THEN SET R = Y\n\n\n00720000          ELSE SET R = N\n\n\n00730000IF &U = U THEN SET FAOPT = WAIT\n\n\n00740000          ELSE SET FAOPT = C&R\n\n\n00750000IF &M = M THEN SET FAOPT = M&R\n\n\n00760000ISPEXEC VPUT (FAOPT) PROFILE\n\n\n00770000ISPEXEC SELECT PGM(ISRUMC)\n\n\n00780000SET HOTFROM =\n\n\n00790000SET HOTTO =\n\n\n00791000SET FAOPT =\n\n\n00792000ISPEXEC VPUT (HOTFROM HOTTO FAOPT) PROFILE\n\n\n00793000EXIT\n\n\n00794000\n\n\n00795000ZAP: +\n\n\n00796000WRITENR\n\n\n00797000URZAP &DSN\n\n\n00798000ISPEXEC SELECT PGM(CLRSPFIO)\n\n\n00799000ISPEXEC CONTROL DISPLAY REFRESH\n\n\n00800000EXIT\n\n\n00810000\n\n\n00820000FLIST: +\n\n\n00830000SET &FADCMD = ISPEXEC SELECT PANEL(IFAMU01) OPT(3.4)\n\n\n00830100IF &FILEAID NE YES THEN +\n\n\n00831000  SET &FADCMD = ISPEXEC SELECT PGM(ISRUDL) PARM(ISRUDLP)\n\n\n00840000GOTO FADCOMM\n\n\n00850000\n\n\n00860000FADCOMM: +\n\n\n00870000IF &U = U THEN SET FAOPT = WAIT\n\n\n00880001/*        ELSE SET FAOPT = */\n\n\n00890000ISPEXEC VPUT (FAOPT FADSN) SHARED\n\n\n00900000&FADCMD\n\n\n00910000SET FAOPT =\n\n\n00920000SET FADSN =\n\n\n00930000SET &ZTRAIL =\n\n\n00940000ISPEXEC VPUT (FAOPT FADSN ZTRAIL) SHARED\n\n\n00950000EXIT\n\n\n./ ADD NAME=HOTKEYO  0105-88307-88309-1540-00305-00257-00065-GS00155\n00010003PROC 2 DSN FTN L CPOS(1) ALCRC(4) FRC(4) U M C R\n\n\n00020000CONTROL NOFLUSH NOMSG END(ENDO)\n\n\n00030000IF &L = L THEN CONTROL NOFLUSH MSG LIST CONLIST SYMLIST\n\n\n00040000ISPEXEC CONTROL ERRORS RETURN\n\n\n00040100STACK FAST\n\n\n00040200ISPEXEC VGET ERRPNL PROFILE\n\n\n00040300IF &ERRPNL = &STR() THEN SET ERRPNL = DISP\n\n\n00040400GETMY PROG SYS ACCT TERMID SYSID ACFUID\n\n\n00040500ISPEXEC VPUT (PROG SYS ACCT TERMID SYSID ACFUID) SHARED\n\n\n00040600\n\n\n00040700RETEST: +\n\n\n00040800IF &STR(&DSN) = &STR(=) THEN +\n\n\n00040900  DO\n\n\n00041001  ISPEXEC SELECT PGM(ISPCDSN) PARM(DSN (SCREEN))\n\n\n00042000  SET CDSRC = &LASTCC\n\n\n00043000  IF &CDSRC NE 0 THEN +\n\n\n00044000    DO\n\n\n00045000    IF &ERRPNL = DISP THEN +\n\n\n00046000      DO\n\n\n00047000      IF &STR(&DSN) = &STR(=) THEN EXIT\n\n\n00048000      SET &GPM = &STR(BAD DSN-&CDSRC)\n\n\n00049000      SET &GPML = &STR(THE ITEM SELECTED MAY BE INVALID - &DSN)\n\n\n00050000      ISPEXEC DISPLAY PANEL(GPM)\n\n\n00060000      ENDO\n\n\n00070000    EXIT\n\n\n00080000    ENDO\n\n\n00090001  ISPEXEC VGET (DSN ISPCPOS) SHARED\n\n\n00100000  IF &LASTCC NE 0 THEN +\n\n\n00110000    DO\n\n\n00120000    EXIT CODE(99)\n\n\n00130000    ENDO\n\n\n00131003  SET &CPOS = &ISPCPOS\n\n\n00140000  ENDO\n\n\n00150000\n\n\n00160000SET F = &SUBSTR(1,&DSN)\n\n\n00170000IF &LENGTH(&STR(&DSN)) < 9 AND &F NE &STR(') THEN +\n\n\n00180000  DO\n\n\n00190000  SET P = &SYSINDEX(&STR(.),&STR(&DSN))\n\n\n00200000  SET M = &SYSINDEX((,&STR(&DSN))\n\n\n00210000  IF &P = 0 AND &M = 0 THEN +\n\n\n00220000    DO\n\n\n00230000    IFALC F(&DSN)\n\n\n00240000    SET ALCRC = &LASTCC\n\n\n00250000    ENDO\n\n\n00260000  ENDO\n\n\n00270000\n\n\n00280000IF &ALCRC NE 0 THEN +\n\n\n00290000  DO\n\n\n00300000  SET FULLDSN = &DSN\n\n\n00310000  IF &SYSDSN(&DSN) = OK THEN SET FRC = 0\n\n\n00320000     ELSE SET FRC = 4\n\n\n00330000  IF &FRC NE 0 AND &F NE &STR(') THEN +\n\n\n00340000    DO\n\n\n00350000    IF &SYSDSN('&DSN') = OK THEN SET FRC = 0\n\n\n00360000       ELSE SET FRC = 4\n\n\n00370000    IF &FRC = 0 THEN +\n\n\n00371000      DO\n\n\n00372000      SET DSN = &STR('&DSN')\n\n\n00373000      SET FULLDSN = &DSN\n\n\n00374000      ENDO\n\n\n00375000    ELSE IF &F = $ OR &F = # OR &F = @ THEN +\n\n\n00376000      DO\n\n\n00376100      SET &NADSN = '&SUBSTR(2:&LENGTH(&DSN),&DSN)'\n\n\n00376200      IF &SYSDSN(&NADSN) = OK THEN +\n\n\n00376300        DO\n\n\n00376400        SET FRC = 0\n\n\n00376500        SET &DSN = &NADSN\n\n\n00376600        SET &FULLDSN = &NADSN\n\n\n00376700        ENDO\n\n\n00376800      ELSE SET FRC = 4\n\n\n00376900      ENDO\n\n\n00377000    ENDO\n\n\n00378000  ENDO\n\n\n00379000\n\n\n00380000IF &ALCRC NE 0 AND &FRC NE 0 THEN +\n\n\n00390000  DO\n\n\n00400000  WHATDDN DS('&DSN')\n\n\n00410000  IF &LASTCC = 0 THEN +\n\n\n00420000    DO\n\n\n00430000    SET &ALCRC = 0\n\n\n00440000    SET &DSN = &DDNAME1\n\n\n00450000    ENDO\n\n\n00460000  ENDO\n\n\n00470000\n\n\n00480000IF &FTN = MENU THEN +\n\n\n00490000  DO\n\n\n00500000  IF &ALCRC = 0 THEN +\n\n\n00510000    DO\n\n\n00520000    WHATDSN DDN(&DSN)\n\n\n00530000    SET FULLDSN = &DSNAME\n\n\n00540000    ENDO\n\n\n00550000  SET DSN = &FULLDSN\n\n\n00560000  IF &SUBSTR(1:8,&ACFUID) = &STR(155D2100) OR   +\n\n\n00570000     &SUBSTR(1:8,&ACFUID) = &STR(155D2300) THEN +\n\n\n00580000    DO\n\n\n00581000    SET ZAP = &STR( ZAP)\n\n\n00582000    SET ZAPT = &STR(     - ACTIVATE URZAP FOR THIS DATASET)\n\n\n00583000    ENDO\n\n\n00584000  SET CO = &STR( F)\n\n\n00585000  SET COT = &STR((3.3)- COPY FROM ABOVE DATASET )\n\n\n00586000  ISPEXEC VGET HOTFROM PROFILE\n\n\n00587000  IF &HOTFROM NE &STR() THEN +\n\n\n00588000    DO\n\n\n00589000    SET REPT = &STR(REPLACE OPTION==>)\n\n\n00590000    SET CO = &STR( T)\n\n\n00600000    SET COT = &STR((3.3)- COPY TO ABOVE DATASET FROM &HOTFROM)\n\n\n00610000    ENDO\n\n\n00611000  ISPEXEC DISPLAY PANEL(HOTMENU)\n\n\n00612000  IF &LASTCC NE 0 THEN EXIT\n\n\n00613000  IF &STR(&DSN) NE &STR('&FULLDSN') THEN GOTO RETEST\n\n\n00614000  ENDO\n\n\n00615000\n\n\n00615100IF &FTN = EDIT OR &FTN = BROWSE THEN +\n\n\n00615200  DO\n\n\n00615300  IF &ALCRC = 0 THEN +\n\n\n00615400    DO\n\n\n00615500    ISPEXEC LMINIT DATAID(ID) DDNAME(&DSN)\n\n\n00615600    SET INITRC = &LASTCC\n\n\n00615700    IF &INITRC = 0 THEN ISPEXEC &FTN DATAID(&ID)\n\n\n00615800    SET FTNRC = &LASTCC\n\n\n00615900    IF &INITRC NE 0 OR &FTNRC NE 0 THEN +\n\n\n00616000      DO\n\n\n00617000      ISPEXEC SETMSG MSG(ISRZ002)\n\n\n00618000      SET &GPML = &STR(YOUR DDNAME SELECTION WAS - &DSN)\n\n\n00619000      ISPEXEC DISPLAY PANEL(GPM)\n\n\n00620000      ENDO\n\n\n00630000    EXIT\n\n\n00631000    ENDO\n\n\n00632000  IF &FRC = 0 THEN +\n\n\n00633000    DO\n\n\n00634000    ISPEXEC &FTN DATASET(&FULLDSN)\n\n\n00635000    IF &LASTCC > 4 THEN +\n\n\n00636000      DO\n\n\n00637000      ISPEXEC SETMSG MSG(ISRZ002)\n\n\n00638000      SET &GPML = &STR(YOUR DATASET SELECTION WAS - &DSN)\n\n\n00639000      ISPEXEC DISPLAY PANEL(GPM)\n\n\n00640000      ENDO\n\n\n00640100    ENDO\n\n\n00640200  IF &ALCRC NE 0 AND &FRC NE 0 THEN +\n\n\n00640300    DO\n\n\n00640400    IF &ERRPNL = DISP THEN +\n\n\n00640500      DO\n\n\n00640600      SET &GPM = &STR(NOT FOUND)\n\n\n00640700      SET &GPML = &STR(THE ITEM SELECTED MAY BE INVALID - &DSN)\n\n\n00640800      ISPEXEC DISPLAY PANEL(GPM)\n\n\n00640900      ENDO\n\n\n00641000    EXIT\n\n\n00642000    ENDO\n\n\n00643000  ENDO\n\n\n00644000\n\n\n00645000IF &FTN = LIB OR &FTN = LIBRARY OR &FTN = INFO OR &FTN = FLIST THEN +\n\n\n00646000  DO\n\n\n00647001  IF &ALCRC = 0 THEN +\n\n\n00648001    DO\n\n\n00649001    WHATDSN DDN(&DSN)\n\n\n00650001    SET FADSN = '&DSNAME'\n\n\n00651001    ENDO\n\n\n00651101  ELSE +\n\n\n00651201    SET FADSN = &DSN\n\n\n00651400  SET MEMP = &SYSINDEX((,&STR(&FADSN))\n\n\n00651500  IF &MEMP \u00ac= 0 THEN +\n\n\n00651600    DO\n\n\n00651700      SET FADSN = &SUBSTR(1:&MEMP-1,&FADSN)\n\n\n00651800      IF &SYSINDEX(',&STR(&FADSN)) = 1 THEN +\n\n\n00651900        SET &FADSN = &FADSN'\n\n\n00652000    ENDO\n\n\n00652100  IF &U = U THEN SET FAOPT = WAIT\n\n\n00653000            ELSE SET FAOPT =\n\n\n00654000  ISPEXEC VPUT (FAOPT FADSN) SHARED\n\n\n00655000  IF &FTN = LIB OR &FTN = LIBRARY  THEN +\n\n\n00656000    ISPEXEC SELECT PGM(ISRUDA) PARM(ISRUDA1)\n\n\n00657000  IF &FTN = INFO THEN +\n\n\n00658000    DO\n\n\n00659000    SET DMPDSN =\n\n\n00660000    ISPEXEC VPUT DMPDSN PROFILE\n\n\n00661000    ISPEXEC SELECT PANEL(IFAMU01) OPT(3.2)\n\n\n00662000    ENDO\n\n\n00662104\n\n\n00663000  IF &FTN = FLIST THEN +\n\n\n00664000    DO\n\n\n00664202    SET FADSNL = &LENGTH(&FADSN)\n\n\n00664304    SET &OKDSN = NO\n\n\n00664402    IF &SUBSTR(1,&FADSN) \u00ac= &STR(') THEN +\n\n\n00664502      DO\n\n\n00664704      IF &SYSDSN('&FADSN') = OK THEN +\n\n\n00664804        SET &OKDSN = YES\n\n\n00664904      ELSE +\n\n\n00665004        DO\n\n\n00665104        SET &PFXFADSN = '&SYSPREF..&FADSN'\n\n\n00665204        IF &SYSDSN(&PFXFADSN) = OK THEN +\n\n\n00665304          DO\n\n\n00665404          SET &PFXLEN = &LENGTH(&SYSPREF)\n\n\n00665504          SET &FADSN = &PFXFADSN\n\n\n00665604          SET &FADSNL = &FADSNL + &PFXLEN + 3\n\n\n00665704          SET &CPOS = &CPOS + &PFXLEN + 2\n\n\n00665804          SET &OKDSN = YES\n\n\n00665904          ENDO\n\n\n00666004        ENDO\n\n\n00666104      ENDO\n\n\n00666204        ELSE +\n\n\n00666504          IF &SYSDSN(&FADSN) = OK THEN SET &OKDSN = YES\n\n\n00666604    IF &OKDSN = NO && &ISPCPOS = 1 THEN +\n\n\n00666704      SET &CPOS = &FADSNL\n\n\n00666803    IF &SUBSTR(1,&FADSN) = &STR(') THEN +\n\n\n00666903      DO\n\n\n00667003      SET &FADSN = &SUBSTR(2:&FADSNL,&FADSN)\n\n\n00667104      IF &CPOS > 1 THEN SET &CPOS = &CPOS - 1\n\n\n00667203      SET &FADSNL = &FADSNL - 1\n\n\n00667303      ENDO\n\n\n00667403    IF &SUBSTR(&FADSNL,&FADSN) = &STR(') THEN +\n\n\n00667503      DO\n\n\n00667603      SET &FADSN = &SUBSTR(1:&EVAL(&FADSNL-1),&FADSN)\n\n\n00667704      IF &CPOS = &FADSNL THEN SET &CPOS = &CPOS - 1\n\n\n00667804      SET &FADSNL = &FADSNL - 1\n\n\n00667903      ENDO\n\n\n00668004    SET &FDELPOS = &SYSINDEX(.,&FADSN)\n\n\n00668104    IF &FDELPOS = 0 THEN +\n\n\n00668204      SET &CPOS = &FADSNL\n\n\n00668303    ELSE IF &CPOS < &FDELPOS THEN +\n\n\n00668403      SET &CPOS = &FDELPOS\n\n\n00668503    SET &POSTPOS = &CPOS + 1\n\n\n00668603    IF &POSTPOS > &FADSNL THEN +\n\n\n00668703      DO\n\n\n00668803      SET &FADSN = &FADSN..\n\n\n00668903      SET &FADSNL = &FADSNL + 1\n\n\n00669003      ENDO\n\n\n00669103    SET &POSTCHR = &SUBSTR(&POSTPOS,&FADSN)\n\n\n00669201    IF &POSTCHR = &STR(.) THEN +\n\n\n00669303      SET &CPOS = &CPOS+1\n\n\n00669403    SET &FADSN = &SUBSTR(1:&CPOS,&FADSN)\n\n\n00669501    SET &FADSN = &STR(&FADSN*)\n\n\n00669600    ISPEXEC VPUT FADSN SHARED\n\n\n00669700    ISPEXEC SELECT PANEL(IFAMU01) OPT(3.4)\n\n\n00669800    ENDO\n\n\n00669900  SET FAOPT =\n\n\n00670000  SET FADSN =\n\n\n00670105  SET &ZTRAIL =\n\n\n00670205  ISPEXEC VPUT (FAOPT FADSN ZTRAIL) SHARED\n\n\n00670300  ENDO\n\n\n00670400\n\n\n00670500IF &FTN = PDS THEN +\n\n\n00670600  DO\n\n\n00670700  IF &U = U THEN SET ML = &STR()\n\n\n00670800            ELSE SET ML = &STR(MEMLIST :)\n\n\n00670900  IF &ALCRC = 0 THEN +\n\n\n00671000    DO\n\n\n00671100    PDS FILE(&DSN) &ML\n\n\n00671200    EXIT\n\n\n00671300    ENDO\n\n\n00671400  IF &FRC = 0 THEN +\n\n\n00671500    PDS &DSN &ML\n\n\n00671600  ENDO\n\n\n00671700\n\n\n00671800IF &FTN = ZAP THEN +\n\n\n00671900  DO\n\n\n00672000  FILEINFO DSN(&DSN)\n\n\n00672100  IF &ALCRC = 0 THEN +\n\n\n00672200    DO\n\n\n00672300    WHATDSN DDN(&DSN)\n\n\n00672400    SET FULLDSN = '&DSNAME'\n\n\n00672500    ENDO\n\n\n00672600  URZAP '&FULLDSN'\n\n\n00672700  ISPEXEC SELECT PGM(CLRSPFIO)\n\n\n00672800  ISPEXEC CONTROL DISPLAY REFRESH\n\n\n00672900  ENDO\n\n\n00673000\n\n\n00673100IF &FTN = FROM OR &FTN = TO THEN +\n\n\n00673200  DO\n\n\n00673300  IF &FTN = FROM THEN SET NEXT = TO\n\n\n00673400                 ELSE SET NEXT = FROM\n\n\n00673500  IF &ALCRC = 0 THEN +\n\n\n00673600    DO\n\n\n00674000    WHATDSN DDN(&DSN)\n\n\n00675000    SET FULLDSN = '&DSNAME'\n\n\n00676000    ENDO\n\n\n00677000  SET HOT&FTN = &FULLDSN\n\n\n00678000  ISPEXEC VPUT HOT&FTN PROFILE\n\n\n00679000  SET ZPF = &&ZPF\n\n\n00680000  SET ZPFL = &&ZPFL\n\n\n00690000  SET I = 1\n\n\n00690100  DO WHILE &I < 25\n\n\n00690200    SET J = &SUBSTR(2:3,&EVAL(100+&I))\n\n\n00690300    ISPEXEC VGET (ZPF&J ZPFL&J) PROFILE\n\n\n00690400    IF &STR(&ZPFL&J) = &STR(&FTN) THEN SET I = 25\n\n\n00690500    IF &STR(&ZPFL&J) = &STR(&FTN) THEN SET ZPF&J = &STR(OTSO %HOTKEY = &\nNEXT)\n\n00690600    IF &STR(&ZPFL&J) = &STR(&FTN) THEN SET ZPFL&J = &STR(&NEXT)\n\n\n00690700    ISPEXEC VPUT (ZPF&J ZPFL&J) PROFILE\n\n\n00690800    SET I = &I+1\n\n\n00690900    ENDO\n\n\n00691000  IF &FTN = TO THEN +\n\n\n00691100    DO\n\n\n00691200    IF &R = R THEN SET R = Y\n\n\n00691300              ELSE SET R = N\n\n\n00691400    IF &U = U THEN SET FAOPT = WAIT\n\n\n00691500              ELSE SET FAOPT = C&R\n\n\n00691600    IF &M = M THEN SET FAOPT = M&R\n\n\n00691700    ISPEXEC VPUT (FAOPT) PROFILE\n\n\n00691800    ISPEXEC SELECT PGM(ISRUMC)\n\n\n00691900    SET HOTFROM =\n\n\n00692000    SET HOTTO =\n\n\n00693000    SET FAOPT =\n\n\n00694000    ISPEXEC VPUT (HOTFROM HOTTO FAOPT) PROFILE\n\n\n00695000    ENDO\n\n\n00696000  ENDO\n\n\n00697000\n\n\n./ ADD NAME=HOTKEYS  0100-89254-89254-2249-00210-00210-00000-KK00155\n00010000PROC 0 ON OFF NOSHOW LOW HI SHOW L MENU(KEY) APPL() ERRPNL(DISP) +\n\n\n00011000       ISR(ON) IOF(ON) FAXE(ON) REFRESH ACF2(YES) TSO(OTSO)\n\n\n00011100/*\n\n\n00011200/* CHANGE IOF  PARM TO NO ABOVE IF NOT USING IOF                  */\n\n\n00011300/* CHANGE FAXE PARM TO NO ABOVE IF NOT USING FILEAID              */\n\n\n00011400/* CHANGE ACF2 PARM TO NO ABOVE IF NOT USING ACF2 TO LIMIT URZAP  */\n\n\n00011500/* CHANGE TSO  PARM TO TSO ABOVE IF NOT USING RTSO IN CMD TABLE   */\n\n\n00011600/*\n\n\n00012000CONTROL END(ENDO)\n\n\n00013000IF &L = L THEN CONTROL MSG LIST CONLIST SYMLIST\n\n\n00014000IF &SYSPREF = GX00155 THEN CONTROL MSG LIST CONLIST SYMLIST\n\n\n00015000STACK FAST\n\n\n00016000IF &REFRESH = REFRESH THEN +\n\n\n00017000  DO\n\n\n00018000  %HOTKEYS OFF &NOSHOW &SHOW &HI &LOW MENU(&MENU) ISR(&ISR) IOF(&IOF) FA\nXE(&FAXE)\n\n00019000  %HOTKEYS ON &NOSHOW &SHOW &L MENU(&MENU) &HI &LOW ISR(&ISR) IOF(&IOF)\nFAXE(&FAXE)\n\n00020000  EXIT\n\n\n00030000  ENDO\n\n\n00030100IF &LOW NE LOW THEN SET HI = HI\n\n\n00030200IF &OFF NE OFF THEN SET ON = ON\n\n\n00030300\n\n\n00030400IF &APPL = &Z THEN +\n\n\n00030500  DO\n\n\n00030600  ISPEXEC VPUT ERRPNL PROFILE\n\n\n00030700  IF &ISR = ON THEN +\n\n\n00030800    DO\n\n\n00030900    ISPEXEC SELECT NEWAPPL(ISR) +\n\n\n00031000     CMD(%&SYSICMD &ON &OFF &NOSHOW &LOW &HI &SHOW &L MENU(&MENU) APPL(I\nSR))\n\n00031100    ENDO\n\n\n00031200  IF &IOF = ON THEN +\n\n\n00031300    DO\n\n\n00031400    ISPEXEC SELECT NEWAPPL(IOF) +\n\n\n00031500     CMD(%&SYSICMD &ON &OFF &NOSHOW &LOW &HI &SHOW &L MENU(&MENU) APPL(I\nOF))\n\n00031600    ENDO\n\n\n00031700  IF &FAXE = ON THEN +\n\n\n00031800    DO\n\n\n00031900    ISPEXEC SELECT NEWAPPL(FAXE) +\n\n\n00032000     CMD(%&SYSICMD &ON &OFF &NOSHOW &LOW &HI &SHOW &L MENU(&MENU) APPL(F\nAXE))\n\n00032100    ENDO\n\n\n00032200\n\n\n00032300  IF &SHOW = &Z AND &NOSHOW = &Z THEN +\n\n\n00032400    DO\n\n\n00032500    IF &ON = ON THEN SET &SHOWSTAT = ON\n\n\n00032600                ELSE SET &SHOWSTAT = OFF\n\n\n00032700    ENDO\n\n\n00032800  ELSE +\n\n\n00032900    DO\n\n\n00033000    IF &SHOW = SHOW THEN SET &SHOWSTAT = ON\n\n\n00033100                    ELSE SET &SHOWSTAT = OFF\n\n\n00033200    ENDO\n\n\n00033300  ISPEXEC SELECT PGM(ISPOPF) PARM(&SHOWSTAT) NOFUNC\n\n\n00033400  EXIT\n\n\n00033500  ENDO\n\n\n00033600\n\n\n00033700IF &ON = ON THEN +\n\n\n00033800  DO\n\n\n00033900  IF &LOW = LOW THEN SET ZPFSET = ALT\n\n\n00034000                ELSE SET ZPFSET = PRI\n\n\n00035000  SET ZPFFMT = MAX\n\n\n00036000  ISPEXEC VPUT (ZPFSET ZPFFMT) PROFILE\n\n\n00037000  ENDO\n\n\n00038000\n\n\n00039000SET KEY = &&KEY\n\n\n00040000SET KEYL = &&KEYL\n\n\n00041000SET OPF = &&OPF\n\n\n00041100SET OPFL = &&OPFL\n\n\n00041200SET ZPF = &&ZPF\n\n\n00041300SET ZPFL = &&ZPFL\n\n\n00041400IF &LOW = LOW THEN SET K = 1\n\n\n00041500              ELSE SET K = 13\n\n\n00041600IF &LOW = LOW THEN SET T = 12\n\n\n00041700              ELSE SET T = 24\n\n\n00041800IF &OFF = OFF THEN SET K = 1\n\n\n00041900IF &OFF = OFF THEN SET T = 24\n\n\n00042000GETMY PROG SYS ACCT TERMID SYSID ACFUID\n\n\n00042100ISPEXEC VPUT (PROG SYS ACCT TERMID SYSID ACFUID) SHARED\n\n\n00042200\n\n\n00042300IF &MENU NE KEY THEN +\n\n\n00042400  DO\n\n\n00042500  IF &DATATYPE(&MENU) NE NUM THEN EXIT\n\n\n00042600  SET K = &MENU\n\n\n00042700  IF &K > 24 THEN EXIT\n\n\n00042800  IF &K < 1 THEN EXIT\n\n\n00042900  IF &K < 13 THEN SET P = &SUBSTR(2:3,&EVAL(100+&K))\n\n\n00043000             ELSE SET P = &SUBSTR(2:3,&EVAL(100+&K-12))\n\n\n00043100  SET KEY&P = &STR(&TSO %HOTKEY = MENU)\n\n\n00043200  SET KEYL&P = MENU\n\n\n00043300  GOTO SETIT\n\n\n00043400  ENDO\n\n\n00043500\n\n\n00043600SET KEY01 = &STR(&TSO %HOTKEY = BROWSE)\n\n\n00043700SET KEYL01 = BROWSE\n\n\n00043800SET KEY02 = &STR(&TSO %HOTKEY = EDIT)\n\n\n00043900SET KEYL02 = EDIT\n\n\n00044000SET KEY03 =\n\n\n00044100SET KEYL03 =\n\n\n00044400IF &ACF2 = YES THEN +\n\n\n00044500  DO\n\n\n00044600  SET KEY03 = END\n\n\n00044700  SET KEYL03 = END\n\n\n00044800  IF &SUBSTR(1:8,&ACFUID) = &STR(155D2100) OR   +\n\n\n00044900     &SUBSTR(1:8,&ACFUID) = &STR(155D2300) THEN +\n\n\n00045000    DO\n\n\n00045100    SET KEY03 =\n\n\n00045200    SET KEYL03 =\n\n\n00045300    ENDO\n\n\n00045400  ENDO\n\n\n00045500SET KEY04 = &STR(&TSO %HOTKEY = LIB)\n\n\n00045600SET KEYL04 = LIB\n\n\n00045700SET KEY05 = &STR(&TSO %HOTKEY = INFO)\n\n\n00045800IF &FAXE = ON THEN +\n\n\n00045900  SET KEY05 = &STR(&TSO %HOTKEY = INFO FILEAID(YES))\n\n\n00046000SET KEYL05 = INFO\n\n\n00046100SET KEY06 = &STR(&TSO %HOTKEY = PDS)\n\n\n00046200SET KEYL06 = PDS ML\n\n\n00046300SET KEY07 = &STR(&TSO %HOTKEY = FROM)\n\n\n00046400SET KEYL07 = FROM\n\n\n00046500SET KEY08 = &STR(&TSO %HOTKEY = MENU)\n\n\n00046600SET KEYL08 = MENU\n\n\n00046700SET KEY09 = &STR(&TSO %HOTKEY = ZAP)\n\n\n00046800SET KEYL09 = ZAP\n\n\n00046900IF &ACF2 = YES THEN +\n\n\n00047000  DO\n\n\n00047100  SET KEY09 =\n\n\n00047200  SET KEYL09 =\n\n\n00047300  IF &SUBSTR(1:8,&ACFUID) = &STR(155D2100) OR   +\n\n\n00047400     &SUBSTR(1:8,&ACFUID) = &STR(155D2300) THEN +\n\n\n00047500    DO\n\n\n00047600    SET KEY09 = &STR(&TSO %HOTKEY = ZAP)\n\n\n00047700    SET KEYL09 = ZAP\n\n\n00047800    ENDO\n\n\n00047900  ENDO\n\n\n00048000SET KEY10 = &STR(&TSO %HOTKEY = FLIST)\n\n\n00048100IF &FAXE = ON THEN +\n\n\n00048200  SET KEY10 = &STR(&TSO %HOTKEY = FLIST FILEAID(YES))\n\n\n00048300SET KEYL10 = FLIST\n\n\n00048400SET KEY11 =\n\n\n00048500SET KEYL11 =\n\n\n00048600SET KEY12 =\n\n\n00048700SET KEYL12 =\n\n\n00049000SETIT: +\n\n\n00050000IF &ON = ON THEN +\n\n\n00060000  DO WHILE &K < &T +1\n\n\n00070000    SET J = &SUBSTR(2:3,&EVAL(100+&K))\n\n\n00080000    ISPEXEC VGET (ZPF&J ZPFL&J OPF&J OPFL&J) PROFILE\n\n\n00090000    IF &STR(&OPF&J) = &Z THEN SET OPF&J = &STR(&ZPF&J)\n\n\n00100000    IF &STR(&OPFL&J) = &Z THEN SET OPFL&J = &STR(&ZPFL&J)\n\n\n00110000    SET ZPFL&J = NOSHOW\n\n\n00120000    IF &K < 13 THEN SET P = &SUBSTR(2:3,&EVAL(100+&K))\n\n\n00130000               ELSE SET P = &SUBSTR(2:3,&EVAL(100+&K-12))\n\n\n00140000    IF &STR(&KEY&P) NE &Z THEN SET ZPF&J = &STR(&KEY&P)\n\n\n00150000    IF &STR(&KEYL&P) NE &Z THEN SET ZPFL&J = &STR(&KEYL&P)\n\n\n00151000    ISPEXEC VPUT (ZPF&J ZPFL&J OPF&J OPFL&J) PROFILE\n\n\n00152000    IF &MENU NE KEY THEN EXIT\n\n\n00153000    SET K = &K + 1\n\n\n00154000  ENDO\n\n\n00155000IF &OFF = OFF THEN +\n\n\n00156000  DO WHILE &K < &T +1\n\n\n00157000    SET J = &SUBSTR(2:3,&EVAL(100+&K))\n\n\n00158000    ISPEXEC VGET (OPF&J OPFL&J) PROFILE\n\n\n00159000    IF &STR(&OPF&J) NE &Z THEN +\n\n\n00160000      DO\n\n\n00170000      SET ZPF&J = &STR(&OPF&J)\n\n\n00180000      SET ZPFL&J = &STR(&OPFL&J)\n\n\n00190000      ISPEXEC VPUT (ZPF&J ZPFL&J) PROFILE\n\n\n00200000      ENDO\n\n\n00210000    IF &MENU NE KEY THEN EXIT\n\n\n00220000    SET K = &K + 1\n\n\n00230000  ENDO\n\n\n00240000\n\n\n00250000SET &KEY = &STR(&&TPFL)\n\n\n00260000SET &ZKEY = &STR(&&ZPFL)\n\n\n00270000SET &I = 1\n\n\n00280000SET &FOUNDEM = NO\n\n\n00290000DO WHILE &I <= 24 && &FOUNDEM = NO\n\n\n00291000  SET &K = &SUBSTR(2:3,&EVAL(100+&I))\n\n\n00292000  ISPEXEC VGET TPFL&K PROFILE\n\n\n00293000  IF &KEY&K \u00ac= &Z THEN SET &FOUNDEM = YES\n\n\n00294000  SET &I = &I + 1\n\n\n00295000ENDO\n\n\n00296000\n\n\n00297000EXIT\n\n\n00298000\n\n\n00299000IF &SHOWSTAT = ON && &FOUNDEM = YES THEN +\n\n\n00300000  DO\n\n\n00310000    SET &I = 1\n\n\n00320000    DO WHILE &I <= 24\n\n\n00330000      SET &K = &SUBSTR(2:3,&EVAL(100+&I))\n\n\n00340000      ISPEXEC VGET TPFL&K PROFILE\n\n\n00350000      SET &ZPFL&K = &KEY&K\n\n\n00360000      SET TPFL&K = &Z\n\n\n00370000      ISPEXEC VPUT (ZPFL&K TPFL&K) PROFILE\n\n\n00380000      SET &I = &I + 1\n\n\n00390000    ENDO\n\n\n00400000  ENDO\n\n\n00410000ELSE +\n\n\n00420000  DO\n\n\n00430000    IF &SHOWSTAT = OFF && &FOUNDEM = NO THEN +\n\n\n00440000      DO\n\n\n00450000        SET &I = 1\n\n\n00460000        DO WHILE &I <= 24\n\n\n00470000          SET &K = &SUBSTR(2:3,&EVAL(100+&I))\n\n\n00480000          ISPEXEC VGET (ZPFL&K) PROFILE\n\n\n00490000          SET &TPFL&K = &ZKEY&K\n\n\n00500000          SET &ZPFL&K = NOSHOW\n\n\n00510000          ISPEXEC VPUT (ZPFL&K TPFL&K) PROFILE\n\n\n00520000          SET I = &I + 1\n\n\n00530000        ENDO\n\n\n00540000      ENDO\n\n\n00550000  ENDO\n\n\n./ ADD NAME=IMD      0110-83307-85280-1434-00228-00184-00102-KK00150\n00010007PROC 0 MSL(GDDM.MAPS) L NC ADS(GDDM.ADS) T K NLIB PRIVATE VPRE() +\n\n\n00011010   SS(USER.TSO.GDDM.SYMBOLS)\n\n\n00020000/* MSL    MAP SPECIFICATION LIBRARY                     */\n\n\n00050000/* L      TURNS ON MSG LIST AND CONLIST                 */\n\n\n00060000/* NC     EXITS BEFORE IMD CALL, ALLOWS TESTING         */\n\n\n00080000/* T      USES TSO TEST TO CALL IMD OR IMPORT           */\n\n\n00090000/* K      USES ALTERNATE IMD FROM WDPSC.TSO.TESTLIB     */\n\n\n00100000/* NLIB   ALLOWS EXECUTION OF IMD WITHOUT LIBRARIES     */\n\n\n00111000/* PRIVATE ALLOWS SHARING PREFIX BUT DIFFERENT LIBRARIES*/\n\n\n00120000CONTROL NOFLUSH END(ENDO) NOMSG\n\n\n00130000IF &L = L THEN CONTROL MSG LIST CONLIST\n\n\n00130108IF &SYSPROC = TEST AND &SS EQ &STR(USER.TSO.GDDMR3.SYMBOLS) THEN +\n\n\n00130210   SET &SS = &STR(USER.TSO.GDDM.SYMBOLS)\n\n\n00131000IF &PRIVATE = PRIVATE AND &SYSPREF NE &SYSUID THEN DO\n\n\n00132000  IF &MSL = GDDM.MAPS THEN SET &MSL = &SYSUID..GDDM.MAPS\n\n\n00133000  IF &ADS = GDDM.ADS THEN SET &ADS = &SYSUID..GDDM.ADS\n\n\n00134000                                                ENDO\n\n\n00135007\n\n\n00136007/*** ALLOCATE SYMBOL SETS IF NOT ALREADY ALLOCATED    ***/\n\n\n00137007IFALC FILE(ADMSYMBL) DSN('&SS')\n\n\n00138007IF &LASTCC NE 0 THEN DO\n\n\n00139007                     IFALC FILE(ADMSYMBL)\n\n\n00140007                     IF &LASTCC = 0 THEN FREE F(ADMSYMBL)\n\n\n00150007                     ALLOC F(ADMSYMBL) DSN('&SS')\n\n\n00160007                     ENDO\n\n\n00170000\n\n\n00202200/*** ALLOCATE PRINT FILE  IF NOT ALREADY ALLOCATED    ***/\n\n\n00202300IFALC FILE(ADMLIST)\n\n\n00202400IF &LASTCC NE 0 THEN DO\n\n\n00202700                     ALLOC F(ADMLIST) SYSOUT(A)\n\n\n00202800                     ENDO\n\n\n00203000\n\n\n00204000/*** ALLOCATE IMD PANELS  IF NOT ALREADY ALLOCATED    ***/\n\n\n00205009IFALC FILE(ADMGIMP) DSN('WDPSC.GDDMR4.GDDMMAP')\n\n\n00206000IF &LASTCC NE 0 THEN DO\n\n\n00207000                     IFALC FILE(ADMGIMP)\n\n\n00208000                     IF &LASTCC = 0 THEN FREE F(ADMGIMP)\n\n\n00208109                     ALLOC FILE(ADMGIMP) DSN('WDPSC.GDDMR4.GDDMMAP')\n\n\n00209100                     ENDO\n\n\n00209200\n\n\n00209300/*** ALLOCATE GEN MAPLIB  IF NOT ALREADY ALLOCATED    ***/\n\n\n00209410IFALC FILE(ADMGGMAP) DSN('USER.TSO.GDDM.GENMAPS')\n\n\n00209500IF &LASTCC NE 0 THEN DO\n\n\n00209600                     IFALC FILE(ADMGGMAP)\n\n\n00209700                     IF &LASTCC = 0 THEN FREE F(ADMGGMAP)\n\n\n00209810                     ALLOC FI(ADMGGMAP) DSN('USER.TSO.GDDM.GENMAPS')\n\n\n00210000                     ENDO\n\n\n00211000\n\n\n00220000/*** CHECK LIBRARIES FOR PRIOR ALLOCATION             ***/\n\n\n00230000IF &NLIB EQ NLIB THEN GOTO CALLM              /* BYPASS LIB ALLOC   */\n\n\n00231000\n\n\n00240000  IFALC FILE(ADMGNADS) DA(&ADS)               /* CHECK: IF BOTH     */\n\n\n00250000  IF &LASTCC = 0 THEN DO                      /*  LIBRARIES HAVE    */\n\n\n00260000       IFALC FILE(ADMMSL1) DA(&MSL)           /*  ALREADY BEEN      */\n\n\n00270000       IF &LASTCC =  0 THEN GOTO CALLM        /*  ALLOCATED,        */\n\n\n00280000                      ENDO                    /*  BYPASS ALLOCATION */\n\n\n00290000FREE F(ADMGNADS,ADMMSL1)\n\n\n00300000\n\n\n00310000DATASTAT &ADS                                 /* CHECK: DO REQUESTD */\n\n\n00320002SET ADSF = &LASTCC                           /*  LIBRARIES ALREADY */\n\n\n00321002                                              /*  EXIST?            */\n\n\n00330002DATASTAT &MSL\n\n\n00330102SET MSLF = &LASTCC\n\n\n00330202IF &MSLF = 4 THEN DO\n\n\n00330402    DATASTAT '&MSL'\n\n\n00330502    IF &LASTCC = 2 THEN DO\n\n\n00330602       SET &MSL = &STR('&MSL')\n\n\n00330702       SET &MSLF = 2\n\n\n00330902                        ENDO\n\n\n00331002                  ENDO\n\n\n00331102 IF &MSLF = 4 THEN DO\n\n\n00331202     DATASTAT 'VSAMA.&SYSPREF..&MSL'\n\n\n00331302    IF &LASTCC = 2 THEN DO\n\n\n00331402       SET &MSL = &STR('VSAMA.&SYSPREF..&MSL')\n\n\n00331502       SET &MSLF = 2\n\n\n00331602                        ENDO\n\n\n00331702                   ENDO\n\n\n00331802 IF &MSLF = 4 THEN DO\n\n\n00331902     DATASTAT 'VSAMT.&SYSPREF..&MSL'\n\n\n00332002    IF &LASTCC = 2 THEN DO\n\n\n00332102       SET &MSL = &STR('VSAMT.&SYSPREF..&MSL')\n\n\n00332202       SET &MSLF = 2\n\n\n00332302                        ENDO\n\n\n00332402                   ENDO\n\n\n00332502 IF &MSLF = 4 THEN DO\n\n\n00332602     DATASTAT 'VSAMA.&MSL'\n\n\n00333002    IF &LASTCC = 2 THEN DO\n\n\n00334002       SET &MSL = &STR('VSAMA.&MSL')\n\n\n00335002       SET &MSLF = 2\n\n\n00336002                        ENDO\n\n\n00337002                   ENDO\n\n\n00338002 IF &MSLF = 4 THEN DO\n\n\n00338102     DATASTAT 'VSAMT.&MSL'\n\n\n00339102    IF &LASTCC = 2 THEN DO\n\n\n00339202       SET &MSL = &STR('VSAMT.&MSL')\n\n\n00339302       SET &MSLF = 2\n\n\n00339402                        ENDO\n\n\n00339502                   ENDO\n\n\n00346002\n\n\n00349802\n\n\n00350001IF &MSLF = 2 AND &ADSF = 0 THEN GOTO NORMAL   /* IF OKAY FOR IMD    */\n\n\n00360000                                              /*  USE, CALL IMD     */\n\n\n00370000IF &ADSF NE 4 AND &ADSF NE 0 THEN DO\n\n\n00380000      WRITE ERROR WITH ADS  LIBRARY: DATASTAT CODE &ADSF\n\n\n00390000      WRITE PLEASE CONTACT YOUR IMD CONSULTANT FOR HELP.\n\n\n00400000      EXIT                                    /* IF DATA LIB THERE, */\n\n\n00410000                                ENDO          /*  BUT NOT OK, EXIT  */\n\n\n00420001IF &MSLF NE 4 AND &MSLF NE 2 THEN DO\n\n\n00430000      WRITE ERROR WITH MSL LIBRARY: DATASTAT CODE &MSLF\n\n\n00440000      WRITE PLEASE CONTACT YOUR IMD CONSULTANT FOR HELP.\n\n\n00450000      EXIT                                    /* IF FRMT LIB THERE, */\n\n\n00460000                                ENDO          /*  BUT NOT OK, EXIT  */\n\n\n00460100\n\n\n00460200/*** DO EXTRA CHECKING FOR DSNS THE USER SPECIFIED:   ***/\n\n\n00460400IF &ADSF = 4 AND &ADS NE GDDM.ADS +\n\n\n00460500             AND &ADS NE &SYSUID..GDDM.ADS THEN +\n\n\n00460600    DO\n\n\n00460700    DATASTAT '&ADS'\n\n\n00460800    IF &LASTCC = 0 THEN DO\n\n\n00460900       SET &ADS = &STR('&ADS')\n\n\n00461000       SET &ADSF = 0\n\n\n00461100                        ENDO\n\n\n00461200    ENDO\n\n\n00462400\n\n\n00462501IF &MSLF = 2 AND &ADSF = 0 THEN GOTO NORMAL   /* IF OKAY FOR IMD    */\n\n\n00462600                                              /*  USE, CALL IMD     */\n\n\n00470000KOMM CLEAR RESET\n\n\n00480000\n\n\n00490000/*** REQUEST VOLUME FOR LIBRARIES THAT DO NOT EXIST   ***/\n\n\n00500000GVOLOOP: +\n\n\n00510000IF &ADSF = 4 AND &MSLF = 4 THEN DO\n\n\n00520000            WRITE ***  YOUR IMD LIBRARIES DO NOT EXIST.    ***\n\n\n00530000            WRITE TO ALLOCATE THEM, ENTER ONE OF THE FOLLOWING:\n\n\n00540000                              ENDO\n\n\n00550000IF &ADSF = 0 AND &MSLF = 4 THEN DO\n\n\n00560000            WRITE ***  YOUR MSL LIBRARY DOES NOT EXIST.  ***\n\n\n00570000            WRITE TO ALLOCATE IT, ENTER ONE OF THE FOLLOWING:\n\n\n00580000                              ENDO\n\n\n00590001IF &ADSF = 4 AND &MSLF = 2 THEN DO\n\n\n00600000            WRITE ***  YOUR ADS LIBRARY DOES NOT EXIST.  ***\n\n\n00610000            WRITE TO ALLOCATE IT, ENTER ONE OF THE FOLLOWING:\n\n\n00620000                              ENDO\n\n\n00630000\n\n\n00640000            WRITE    P - TO ALLOCATE AND KEEP INDEFINITELY.\n\n\n00650000            WRITE    T - TO ALLOCATE AND KEEP FOR 3 DAYS.\n\n\n00660000            WRITE YOU MAY ALSO ENTER A SPECIFIC ADS VOLUME IF YOU WISH.\n\n\n00670000             READ VOLP\n\n\n00680002             IF &VOLP = P THEN DO\n\n\n00681006                               SET VOL = TSOVOL\n\n\n00681106                               SET DEVTYP = SYSDA\n\n\n00682002                               SET VOLV = 335043\n\n\n00683002                               SET VPRE = VSAMA\n\n\n00683102                               SET VCAT = USERCAT8\n\n\n00683206                               GOTO NORMAL\n\n\n00684002                               ENDO\n\n\n00690000                          ELSE +\n\n\n00700002             IF &VOLP = T THEN DO\n\n\n00701002                               SET VOL = 335112\n\n\n00701102                               SET VOLV = 338019\n\n\n00701202                               SET VPRE = VSAMT\n\n\n00701302                               SET VCAT = USERCATT\n\n\n00702002                               ENDO\n\n\n00712002                          ELSE DO\n\n\n00713002                               SET VOL = &VOLP\n\n\n00714002                               SET VOLV = 335043\n\n\n00718102                               SET VPRE = VSAMA\n\n\n00718202                               SET VCAT = USERCAT8\n\n\n00718302                               ENDO\n\n\n00720000      DEVTYPE VOL(&VOL)\n\n\n00730000      IF &LASTCC NE 0 THEN DO\n\n\n00740000              WRITE '&VOLP' IS AN INVALID RESPONSE - PLEASE TRY AGAIN.\n\n\n00750000              WRITE\n\n\n00760000              GOTO GVOLOOP\n\n\n00770000                           ENDO\n\n\n00780000\n\n\n00790000/*** ALLOCATE LIBRARIES THAT DO NOT EXIST             ***/\n\n\n00800000NORMAL: +\n\n\n00801000FREE  ATTR(ADMAT)\n\n\n00802000ATTR ADMAT RECFM(F,B) LRECL(80) BLK(3120)\n\n\n00810000IF &ADSF = 4 THEN DO\n\n\n00820000      ALLOC F(ADMGNADS) DA(&ADS) SP(3,3) TRACKS BLKSIZE(400) +\n\n\n00830000            DIR(10) UNIT(&DEVTYP) VOL(&VOL) USING(ADMAT)\n\n\n00831002      SET ARC = &LASTCC\n\n\n00840002      IF &ARC    = 0 THEN +\n\n\n00850000                   WRITE DATA LIBRARY &SYSPREF..&ADS HAS BEEN ALLOCATED.\n\n\n00860000                     ELSE DO\n\n\n00870002                          WRITE ERROR CODE &ARC OCCURED\n\n\n00880000                          WRITE IN ALLOCATION OF &SYSPREF..&ADS\n\n\n00890000                          WRITE PLEASE CONTACT YOUR IMD CONSULTANT.\n\n\n00900000                          EXIT\n\n\n00910000                          ENDO\n\n\n00920000                 ENDO\n\n\n00930000             ELSE ALLOC F(ADMGNADS) DA(&ADS)\n\n\n00940000IF &MSLF = 4 THEN DO\n\n\n00940102      IF &SUBSTR(1,&STR(&MSL)) NE &STR(') THEN +\n\n\n00941002                SET &MSL = '&VPRE..&SYSPREF..&MSL'\n\n\n00950002      DEFINE CLUSTER (NAME(&MSL) +\n\n\n00960000                      VOL(&VOLV) SHR(3 3) RECSZ(256 256) +\n\n\n00961000                      CISZ(2048) KEYS(21 0)) +\n\n\n00962002             DATA (RECORDS(400 400)) CAT('SYS1.&VCAT')\n\n\n00963002      SET DRC = &LASTCC\n\n\n00970002      IF &DRC    = 0 THEN +\n\n\n00980002                WRITE MSL LIBRARY &MSL HAS BEEN ALLOCATED.\n\n\n00990000                     ELSE DO\n\n\n01000002                          WRITE ERROR CODE &DRC OCCURED\n\n\n01010002                          WRITE IN ALLOCATION OF &MSL\n\n\n01020000                          WRITE PLEASE CONTACT YOUR IMD CONSULTANT.\n\n\n01030000                          EXIT\n\n\n01040000                          ENDO\n\n\n01050000                 ENDO\n\n\n01060002\n\n\n01060102ALLOC F(ADMMSL1) DSN(&MSL)\n\n\n01062002\n\n\n01070000IF &MSLF = 4 OR &ADSF = 4 THEN CALL 'WDPSC.SHARED.LOAD(NEWWAIT)' '2'\n\n\n01080000\n\n\n01100000CALLM: +\n\n\n01110005CONTROL MSG\n\n\n01110200\n\n\n01420000NOIMPORT: IF &NC EQ NC THEN EXIT\n\n\n01430000\n\n\n01440000/*** CALL IMD                                         ***/\n\n\n01441008IF &K = K OR &SYSPROC = TEST THEN DO\n\n\n01442107 IF &T = T THEN TEST 'WDPSC.GDDMR4.GDDMLOAD(ADMIMD)' 'ADMMSL1'\n\n\n01443007           ELSE CALL 'WDPSC.GDDMR4.GDDMLOAD(ADMIMD)' 'ADMMSL1'\n\n\n01444000                EXIT\n\n\n01445000               ENDO\n\n\n01470005IF &T = T THEN TEST 'WDPSC.GDDM.GDDMLOAD(ADMIMD)'    'ADMMSL1'\n\n\n01480005          ELSE CALL 'WDPSC.GDDM.GDDMLOAD(ADMIMD)'    'ADMMSL1'\n\n\n./ ADD NAME=ISSE     0104-85206-85280-1433-00038-00036-00004-KK00150\n00700004PROC 0 SS(USER.TSO.GDDM.SYMBOLS) L NC VOL(NONE) SSN(ADMCOLSD) F\n\n\n00710000CONTROL NOFLUSH END(ENDO) NOMSG\n\n\n00720000IF &L = L THEN CONTROL MSG LIST CONLIST\n\n\n00721002IF &SYSPROC = TEST AND &SS EQ &STR(USER.TSO.GDDMR3.SYMBOLS) THEN +\n\n\n00722004   SET &SS = &STR(USER.TSO.GDDM.SYMBOLS)\n\n\n00730000IF &F = F THEN FREE F(ADMSYMBL)\n\n\n00740000IFALC F(ADMSYMBL) DA(&SS)\n\n\n00750000IF &LASTCC = 0 THEN GOTO CALLM\n\n\n00760000IFALC F(ADMSYMBL) DA('&SS')\n\n\n00770000IF &LASTCC = 0 THEN GOTO CALLM\n\n\n00780000IFALC F(ADMSYMBL)\n\n\n00790000IF &LASTCC = 0 THEN FREE F(ADMSYMBL)\n\n\n00800000DATASTAT &SS\n\n\n00810000IF &LASTCC NE 0 THEN DO\n\n\n00820000       DATASTAT '&SS'\n\n\n00830000       SET DRC = &LASTCC\n\n\n00840000       IF &DRC    NE 0 THEN DO\n\n\n00850000          WRITE DATASTAT RC IS &DRC\n\n\n00860000          WRITE SYMBOL SET LIBRARY CANNOT BE ALLOCATED : &SS\n\n\n00870000          WRITE PLEASE CHECK YOUR SS NAME.\n\n\n00880000          EXIT\n\n\n00890000                            ENDO\n\n\n00900000       SET &SS = &STR('&SS')\n\n\n00910000                     ENDO\n\n\n00920000ALLOC F(ADMSYMBL) DA(&SS)\n\n\n00930000       SET ARC = &LASTCC\n\n\n00940000       IF &ARC    NE 0 THEN DO\n\n\n00950000          WRITE ALLOC RC IS &ARC\n\n\n00960000          WRITE SYMBOL SET LIBRARY CANNOT BE ALLOCATED :\n\n\n00970000          WRITE PLEASE CHECK YOUR SS NAME.\n\n\n00980000          EXIT\n\n\n00990000                            ENDO\n\n\n01000000CALLM: +\n\n\n01030000  IF &NC = NC THEN EXIT\n\n\n01050002  IF &SYSPROC = TEST THEN +\n\n\n01060000               CALL 'WDPSC.GDDMR4.GDDMLOAD(ADMISSE)' '&SSN'\n\n\n01070000                     ELSE +\n\n\n01080000               CALL 'WDPSC.GDDM.GDDMLOAD(ADMISSE)' '&SSN'\n\n\n./ ADD NAME=LASTLINK 0110-82127-85317-1402-00193-00187-00000-JS02150\n                   PROC 0 VOL() CON\n\n\n                   IF &CON = CON THEN CONTROL LIST CONLIST\n\n\n                   CLERSCRN\n\n\n                   CONTROL NOMSG NOFLUSH END(ENDO)\n\n\n\n\n\n                   SET &ZEEVOL =\n\n\n                   IF &VOL NE  THEN DO\n\n\n                       SET &ZEEVOL = &STR(VOL(&VOL))\n\n\n                       ENDO\n\n\n\n\n\n        ERR1:   ERROR DO\n\n\n                    WRITE\n\n\n                    WRITE ***********************************\n\n\n                    WRITE *  INVALID SYNTAX OF DATASET NAME *\n\n\n                    WRITE ***********************************\n\n\n                    CALL 'WDPSC.SHARED.LOAD(NEWWAIT)' '5'\n\n\n                    CLERSCRN\n\n\n                    GOTO GETDSN\n\n\n                    ENDO\n\n\n\n\n\n        GETDSN: WRITE\n\n\n                WRITE ENTER DATASET NAME OF LOAD MODULE LIBRARY\n\n\n                WRITE   (UNQUOTED DATASET WILL HAVE PREFIX APPENDED)\n\n\n                WRITE\n\n\n                WRITENR ENTER DSN HERE ==>\n\n\n                READ\n\n\n                SET &DSN = &STR(&SYSDVAL)\n\n\n\n\n\n                CLERSCRN\n\n\n\n\n\n        ERR2:   ERROR DO\n\n\n                    WRITE\n\n\n                    WRITE **********************************\n\n\n                    WRITE *  INVALID SYNTAX OF MEMBER NAME *\n\n\n                    WRITE **********************************\n\n\n                    CALL 'WDPSC.SHARED.LOAD(NEWWAIT)' '5'\n\n\n                    CLERSCRN\n\n\n                    GOTO GETMEM\n\n\n                    ENDO\n\n\n\n\n\n        GETMEM: WRITE\n\n\n                WRITENR ENTER MEMBER NAME ===>\n\n\n                READ &MEMNAME\n\n\n\n\n\n        FINFO:  ERROR OFF\n\n\n                FILEINFO DSN(&STR(&DSN)) &ZEEVOL MEM(&STR(&MEMNAME))\n\n\n                SET &MYCC = &LASTCC\n\n\n\n\n\n                IF &MYCC EQ 96 THEN DO\n\n\n                    WRITE\n\n\n                    WRITE ***********************************\n\n\n                    WRITE *  INVALID SYNTAX OF DATASET NAME *\n\n\n                    WRITE ***********************************\n\n\n                    CALL 'WDPSC.SHARED.LOAD(NEWWAIT)' '5'\n\n\n                    CLERSCRN\n\n\n                    GOTO ERR1\n\n\n                    ENDO\n\n\n\n\n\n                IF &MYCC EQ 48 THEN DO\n\n\n                    WRITE\n\n\n                    WRITE **********************************\n\n\n                    WRITE *  INVALID SYNTAX OF MEMBER NAME *\n\n\n                    WRITE **********************************\n\n\n                    CALL 'WDPSC.SHARED.LOAD(NEWWAIT)' '5'\n\n\n                    CLERSCRN\n\n\n                    GOTO ERR2\n\n\n                    ENDO\n\n\n\n\n\n                IF &MYCC = 28 THEN GOTO ALLOCIT\n\n\n\n\n\n                IF &MYCC = 24 THEN DO\n\n\n                    WRITE\n\n\n                    WRITE *****************************\n\n\n                    WRITE *   MEMBER NAME NOT FOUND   *\n\n\n                    WRITE *****************************\n\n\n                    CALL 'WDPSC.SHARED.LOAD(NEWWAIT)' '5'\n\n\n                    CLERSCRN\n\n\n                    GOTO ERR2\n\n\n                    ENDO\n\n\n\n\n\n                IF &MYCC NE 0 THEN DO\n\n\n                    WRITE\n\n\n                    WRITE ******************************\n\n\n                    WRITE &OUTMSG\n\n\n                    WRITE ******************************\n\n\n                    CALL 'WDPSC.SHARED.LOAD(NEWWAIT)' '5'\n\n\n                    CLERSCRN\n\n\n                    GOTO ERR1\n\n\n                    ENDO\n\n\n\n\n\n                IF &DSORG NE PO THEN DO\n\n\n                    WRITE\n\n\n                    WRITE **********************************\n\n\n                    WRITE *   LOAD MODULE LIBRARY MUST BE  *\n\n\n                    WRITE *   A PARTITIONED DATASET        *\n\n\n                    WRITE **********************************\n\n\n                    CALL 'WDPSC.SHARED.LOAD(NEWWAIT)' '5'\n\n\n                    CLERSCRN\n\n\n                    GOTO ERR1\n\n\n                    ENDO\n\n\n\n\n\n                IF &RECFM NE U THEN DO\n\n\n                    WRITE\n\n\n                    WRITE **********************************\n\n\n                    WRITE *   LOAD MODULE LIBRARY MUST     *\n\n\n                    WRITE *   HAVE RECFM=U                 *\n\n\n                    WRITE *                                *\n\n\n                    WRITE *   THIS DATASET MUST NOT BE     *\n\n\n                    WRITE *   A LOAD MODULE LIBRARY        *\n\n\n                    WRITE **********************************\n\n\n                    CALL 'WDPSC.SHARED.LOAD(NEWWAIT)' '5'\n\n\n                    CLERSCRN\n\n\n                    GOTO ERR1\n\n\n                    ENDO\n\n\n\n\n\n                   SET &LODLIB = &FULLDSN\n\n\n                   GOTO DOIT\n\n\n\n\n\n        ALLOCIT: DEVTYPE VOL(&VOL)\n\n\n                 IF &LASTCC NE 0 THEN DO\n\n\n                    WRITE\n\n\n                    WRITE **********************************\n\n\n                    WRITE &OUTMSG\n\n\n                    WRITE **********************************\n\n\n                    EXIT\n\n\n                    ENDO\n\n\n\n\n\n                 FREE F(FINDMEDD)\n\n\n                 ALLOC F(FINDMEDD) DA('&FULLDSN') SHR -\n\n\n                 VOL(&VOL) UNIT(&DEVTYP)\n\n\n                 IF &LASTCC NE 0 THEN DO\n\n\n                    WRITE\n\n\n                    WRITE ***************************************\n\n\n                    WRITE UNSUCCESSFUL ALLOCATION OF LOAD LIBRARY\n\n\n                    WRITE ***************************************\n\n\n                    EXIT\n\n\n                    ENDO\n\n\n\n\n\n                 GOTO FINFO\n\n\n\n\n\n        DOIT:      FREE F(SYSIN)\n\n\n                   ALLOC F(SYSIN) NEW SPACE(1,1) BLK(80)\n\n\n                   OPENFILE SYSIN OUTPUT\n\n\n                   SET &SYSIN = &STR( LISTIDR MEMBER=&MEMNAME)\n\n\n                   PUTFILE SYSIN\n\n\n                   CLOSFILE SYSIN\n\n\n                   FREE F(SYSPRINT SYSLIB)\n\n\n                   ERROR DO\n\n\n                        CONTROL MSG\n\n\n                        ALLOC F(SYSPRINT) DSN('&SYSUID..LASTLINK.SYSPRINT') -\n\n\n                        NEW SPACE(1,1) TRACKS UNIT(SYSDA)\n\n\n                        CONTROL NOMSG\n\n\n                        ERROR OFF\n\n\n                        GOTO CONT1\n\n\n                        ENDO\n\n\n                   ALLOC F(SYSPRINT) DA('&SYSUID..LASTLINK.SYSPRINT') SHR\n\n\n                   ERROR OFF\n\n\n        CONT1:     CONTROL MSG\n\n\n                   DEVTYPE VOL(&VOLSER)\n\n\n                   IF &LASTCC NE 0 THEN DO\n\n\n                      WRITE\n\n\n                      WRITE **********************************\n\n\n                      WRITE &OUTMSG\n\n\n                      WRITE **********************************\n\n\n                      EXIT\n\n\n                      ENDO\n\n\n\n\n\n                   SET &VOLPAR = &STR(VOL(&VOLSER))\n\n\n                   SET &UNIT = &STR(UNIT(&DEVTYP))\n\n\n                   ALLOC F(SYSLIB) DA('&LODLIB') SHR &VOLPAR &UNIT\n\n\n                   CONTROL NOMSG\n\n\n                   CLERSCRN\n\n\n                   WRITE\n\n\n                   CALL 'SYS1.LINKLIB(AMBLIST)'\n\n\n                   FREE F(SYSIN SYSPRINT SYSLIB)\n\n\n                   FREE F(SYS260A,SYS260J)\n\n\n                   FREE ATTRLIST(SYSJATTR)\n\n\n                   ATTR SYSJATTR RECFM(F) LRECL(80) BLKSIZE(80)\n\n\n                   CONTROL MSG\n\n\n                   ALLOC F(SYS260A) DA('&SYSUID..LASTLINK.SYSPRINT') SHR\n\n\n                   ALLOC F(SYS260J) DSN(*) USING(SYSJATTR)\n\n\n                   ALLOC F(SYSPRINT) DUMMY\n\n\n                   ALLOC F(SYSIN) DA('WDPSC.MASTER.CLIST.PARMS(LLINKDYL)') SHR\n\n\n                   CALL 'WDPSC.SYSLIBRY(DYL260)'\n\n\n                   CONTROL NOMSG\n\n\n                   FREE F(SYSIN SYSPRINT)\n\n\n                   ALLOC F(SYSIN) DSN(*)\n\n\n                   ALLOC F(SYSPRINT) DSN(*)\n\n\n           /*  THE FOLLOWING 3 STATEMENTS WERE ADDED IN ORDER   */\n\n\n           /*  TO FIX PROBLEM EXPERIENCED ONLY BY 3290S         */\n\n\n                   WRITE\n\n\n                   WRITE PRESS ENTER TO EXIT THIS CLIST\n\n\n                   READ\n\n\n./ ADD NAME=LASTOPEN 0101-85021-85113-1611-00070-00073-00000-JS02150\n                CLERSCRN\n\n\n\n\n\n                CONTROL NOMSG NOFLUSH END(ENDO)\n\n\n\n\n\n                ATTN DO\n\n\n                    END\n\n\n                    RETURN\n\n\n                    ENDO\n\n\n\n\n\n        D1T1:   ERROR DO\n\n\n                    WRITE\n\n\n                    WRITE *******************************\n\n\n                    WRITE *  INVALID SYNTAX OF DSNAME   *\n\n\n                    WRITE *******************************\n\n\n                    CALL 'WDPSC.SHARED.LOAD(NEWWAIT)' '5'\n\n\n                    CLERSCRN\n\n\n                    GOTO D1T2\n\n\n                    ENDO\n\n\n\n\n\n        D1T2:   WRITE\n\n\n                WRITE ENTER DATASET NAME &STR(           (OR ENTER 'QUIT' TO EXI\nT))\n\n                WRITE    UNQUOTED DATASET WILL HAVE PREFIX APPENDED:\n\n\n                READ\n\n\n                SET &DSN = &STR(&SYSDVAL)\n\n\n\n\n\n                IF &DSN = QUIT THEN EXIT\n\n\n\n\n\n                ERROR OFF\n\n\n\n\n\n                FILEINFO DSN(&STR(&DSN))\n\n\n                SET &FILECC = &LASTCC\n\n\n\n\n\n                IF &FILECC EQ 96 THEN DO\n\n\n                    WRITE\n\n\n                    WRITE *******************************\n\n\n                    WRITE *  INVALID SYNTAX OF DSNAME   *\n\n\n                    WRITE *******************************\n\n\n                    CALL 'WDPSC.SHARED.LOAD(NEWWAIT)' '5'\n\n\n                    CLERSCRN\n\n\n                    GOTO D1T1\n\n\n                    ENDO\n\n\n\n\n\n                IF &FILECC NE 0 THEN DO\n\n\n                    WRITE\n\n\n                    WRITE *******************************\n\n\n                    WRITE &OUTMSG\n\n\n                    WRITE *******************************\n\n\n                    CALL 'WDPSC.SHARED.LOAD(NEWWAIT)' '5'\n\n\n                    CLERSCRN\n\n\n                    GOTO D1T1\n\n\n                    ENDO\n\n\n\n\n\n                IF &DSORG NE PO THEN GOTO DOIT\n\n\n\n\n\n                IF &MEMCNTL EQ YES THEN DO\n\n\n                    WRITE\n\n\n                    WRITE *********************************\n\n\n                    WRITE *   DO NOT PROVIDE MEMBER NAME  *\n\n\n                    WRITE *********************************\n\n\n                    CALL 'WDPSC.SHARED.LOAD(NEWWAIT)' '5'\n\n\n                    CLERSCRN\n\n\n                    GOTO D1T1\n\n\n                    ENDO\n\n\n\n\n\n        DOIT:   WRITE\n\n\n                SET &FULLDSN = &STR(&FULLDSN&SUBSTR(1:44-&LENGTH(&FULLDSN),\n                                       )\n\n                FREE F(OUTPUT)\n\n\n                CONTROL MSG\n\n\n                ALLOC F(OUTPUT) DSN(*) NEW\n\n\n                CALL 'WDPSC.SHARED.LOAD(GETDSCB1)' '999999,&STR(&FULLDSN)'\n\n\n./ ADD NAME=LPQ      0101-85211-85279-1533-00018-00018-00003-KX00150\n00010001PROC 0 A Q T D R3 Q81 Q33 DSN('''ADMPRINT.REQUEST.QUEUE''') R4\n\n\n00050200IF &Q81 = Q81 THEN SET DSN = &STR('USER.TSO.GDDMR3.QUEUE81')\n\n\n00050300IF &Q33 = Q33 THEN SET DSN = &STR('USER.TSO.GDDMR3.QUEUE33')\n\n\n00050401IF &R3 = R3 THEN SET DSN = &STR('USER.TSO.GDDMR3.PRINTQ')\n\n\n00050501IF &R4 = R4 THEN SET DSN = &STR('USER.TSO.GDDMR4.PRINTQ')\n\n\n00050600IF &T = T THEN SET DSN = &STR('SOFTD150.DSPRINT.QUEUE')\n\n\n00050700IF &A = A THEN SET DSN = &STR('USER.TSO.DSPRINT.ALTQUEUE')\n\n\n00050800IF &Q = Q THEN SET DSN = &STR('USER.TSO.DSPRINT.QUEUE')\n\n\n00050900IF &D = D THEN SET DSN = &STR('DSPRINT.REQUEST.QUEUE')\n\n\n00051000WRITE STATUS REPORT FOR PRINT QUEUE &DSN\n\n\n00051100CONTROL NOMSG\n\n\n00052000IFALC F(DRQ) DSN(&DSN)\n\n\n00053000IF &LASTCC = 0 THEN GOTO CALLLPQ\n\n\n00060000FREE F(DRQ,DRQATT)\n\n\n00061000CONTROL MSG\n\n\n00062000ATTR DRQATT BUFNO(10)\n\n\n00070000ALLOC FI(DRQ)  DA(&DSN)   SHR  US(DRQATT)\n\n\n00080000CALLLPQ: CALL 'WDPSC.SYSLIBRY(LPRTQ)'\n\n\n./ ADD NAME=NEWSPF   0125-83272-86339-1303-00089-00149-00026-LL02150\n00010004PROC 0 L PROFDSN(NONE) F MYCMD T NC TABL SETUP CLEANUP\n\n\n00020000CONTROL MAIN END(ENDO)\n\n\n00030000IF &L = L THEN CONTROL LIST MSG CONLIST\n\n\n00030120IF &SYSPREF = KX00150 THEN CONTROL MSG LIST CONLIST\n\n\n00031000\n\n\n00031105IF &CLEANUP = CLEANUP THEN GOTO MRCLEAN\n\n\n00032003\n\n\n00081100/*************************************************************/\n\n\n00081200/*  IF THE USER WANTS TO ENTER A DIFFERENT COMMAND STRING... */\n\n\n00081300/*************************************************************/\n\n\n00081400IF &MYCMD = MYCMD THEN DO\n\n\n00081500        WRITE ENTER ISPF INVOCATION COMMAND:\n\n\n00081600        READ\n\n\n00081700                       ENDO\n\n\n00081800                  ELSE +\n\n\n00081900        SET &SYSDVAL = PDF\n\n\n00082000\n\n\n00083000/*************************************************************/\n\n\n00090000/*  IF ISPPROF IS ALREADY ALLOCATED, ASSUME CONVERSION DONE: */\n\n\n00090100/*************************************************************/\n\n\n00100000IFALC F(ISPPROF)\n\n\n00110000IF &LASTCC = 0 THEN GOTO CHEKLIBS\n\n\n00111000\n\n\n00112000/*************************************************************/\n\n\n00120000/*  IF ISPPROF LIB EXISTS, ASSUME CONVERSION DONE:           */\n\n\n00120100/*************************************************************/\n\n\n00121000IF &PROFDSN = NONE THEN +\n\n\n00122019     IF &SYSUID = &SYSPREF OR &SYSPREF = &STR() +\n\n\n00122119                           THEN SET &PROFDSN = &SYSUID..ISPF.ISPPROF\n\n\n00123000                           ELSE SET &PROFDSN = &SYSPREF..&SYSUID..ISPF.I\nSPPROF\n\n00124000CONTROL NOMSG\n\n\n00130000ALLOC DDN(ISPPROF) DSN('&PROFDSN')\n\n\n00140000IF &LASTCC = 0 THEN GOTO CHEKLIBS\n\n\n00141000\n\n\n00141100/*************************************************************/\n\n\n00142000/* USER PROFILE LIB DOES NOT EXIST; WE MUST BUILD IT:        */\n\n\n00143000/*************************************************************/\n\n\n00144000FREE ATTR(KKISPRO)\n\n\n00145000CONTROL MSG\n\n\n00150000ATTR KKISPRO RECFM(F B) LRECL(80) BLKSIZE(3120)\n\n\n00160000ALLOC DDN(ISPPROF) DSN('&PROFDSN') NEW CATALOG TRACK SP(1 1) DIR(2) +\n\n\n00170021      USING(KKISPRO) UNIT(3380) VOL(SYS028)\n\n\n00171000IF &LASTCC NE 0 THEN DO\n\n\n00172000      WRITE ERROR ALLOCATING PROFILE DATASET (USER PARMS)\n\n\n00172112      WRITE PLEASE CONTACT WDPSC CUSTOMER TECHNICAL SUPPORT AT 3-4170\n\n\n00172218      ALLOC DDN(ISPPROF) DUMMY\n\n\n00173000      EXIT\n\n\n00180000                     ENDO\n\n\n00181000\n\n\n00182000/*************************************************************/\n\n\n00190000/* NEW PROFILE LIB ALLOCATED, NOW TRY TO CONVERT OLD PARMS:  */\n\n\n00190112/* 02/09/84 - SPFMVS GONE, NO CONVERSION ALLOWED NOW.......  */\n\n\n00191000/*************************************************************/\n\n\n00370000\n\n\n00371000/*************************************************************/\n\n\n00380000/* NOW WE CHECK IF ISPF LIBS ARE PRESENT:                    */\n\n\n00381000/*************************************************************/\n\n\n00400100CHEKLIBS: CONTROL MSG\n\n\n00414112/*               ALLOCATE ANY NEW LIBS THAT AREN'T THERE:  ***/\n\n\n00440023SPFCONC DDN(ISPPLIB) DSN('WDPSC.ISP.V2R2.ISPPLIB')\n\n\n00460023SPFCONC DDN(ISPSLIB) DSN('WDPSC.ISP.V2R2.ISPSLIB')\n\n\n00480023SPFCONC DDN(ISPMLIB) DSN('WDPSC.ISP.V2R2.ISPMLIB')\n\n\n00490023SPFCONC DDN(ISPTLIB) DSN('WDPSC.ISP.V2R2.ISPTLIB')\n\n\n00520100/*                                                           */\n\n\n00520200/*  THEN ALLOCATE TEST LIBRARIES IF REQUESTED:             ***/\n\n\n00521000IF &T = T THEN DO\n\n\n00521322  SPFCONC DDN(ISPPLIB) DSN('WDPSC.ISP.LOCAL.ISPPLIB')\n\n\n00521422  SPFCONC DDN(ISPSLIB) DSN('WDPSC.ISP.LOCAL.ISPSLIB')\n\n\n00521522  SPFCONC DDN(ISPMLIB) DSN('WDPSC.ISP.LOCAL.ISPMLIB')\n\n\n00521622  SPFCONC DDN(ISPTLIB) DSN('WDPSC.ISP.LOCAL.ISPTLIB')\n\n\n00521700  IF &TABL = TABL THEN +\n\n\n00521822  SPFCONC DDN(ISPTABL) DSN('WDPSC.ISP.LOCAL.ISPTLIB')\n\n\n00521900               ENDO\n\n\n00522000\n\n\n00523000/*************************************************************/\n\n\n00530107/*  THEN WE CAN ISSUE THE ISPF/PDF COMMAND IF NEEDED:        */\n\n\n00530200/*************************************************************/\n\n\n00531000NEWSPF: +\n\n\n00535100     IF &SETUP = SETUP THEN EXIT\n\n\n00535507     IF &NC = NC THEN GOTO MRCLEAN\n\n\n00535600     STACK T(ISPLLIB)\n\n\n00535700     &SYSDVAL\n\n\n00536100\n\n\n00552000/*************************************************************/\n\n\n00553007/* THIS SECTION IS USED WHILE SPFMVS IS PRODUCTION VERSION.  */\n\n\n00553107/* PUT THE OLD SPF LIBS BACK IN PLACE NOW:                   */\n\n\n00554000/*************************************************************/\n\n\n00555005MRCLEAN: +\n\n\n00555209EXIT    /* PDF IS NOW PRODUCTION VERSION  */\n\n\n./ ADD NAME=PASTE    0116-86252-86303-1641-00134-00028-00000-GS00150\n        /*CLIST****************************************************************/\n\n\n        /*   ISPF/PDF EDIT MACRO TO WRITE LINES FROM THE USER PROFILE POOL    */\n\n\n        /*   INTO THE CURRENT FILE.  THIS MACRO IS USED IN CONJUNCTION WITH   */\n\n\n        /*   THE CUT MACRO.                                                   */\n\n\n        /*                                                                    */\n\n\n        /*   A TUTORIAL IS AVAILABLE BY PRESSING THE PF(1) KEY                */\n\n\n        /**********************************************************************/\n\n\n        ISREDIT MACRO (PARM1) NOPROCESS\n\n\n        CONTROL NOFLUSH NOMSG\n\n\n        /*CONTROL LIST CONLIST SYMLIST\n\n\n        SET MSGFLAG = KEEP\n\n\n        SET OFLAG = OK\n\n\n\n\n\n        /* CHECK FOR INVALID PARAMETERS                                       */\n\n\n        IF &PARM1 \u00ac= &STR( ) AND &PARM1 \u00ac= &STR(K) AND +\n\n\n           &PARM1 \u00ac= &STR(KEEP) THEN +\n\n\n          DO\n\n\n            /* AN INVALID PASTE PARAMETER HAS BEEN PASSED                     */\n\n\n            SET ZERRSM = &STR(INVALID PARAMETER!!!)\n\n\n            SET MSG1 = &STR(USE PARAMETER \"K\" OR \"KEEP\" )\n\n\n            SET MSG2 = &STR(TO PREVENT VARIABLE DELETION...)\n\n\n            SET ZERRLM = &STR(&MSG1&MSG2)\n\n\n            SET ZERRALRM = YES\n\n\n            SET ZERRHM = PASTEHLP\n\n\n            ISPEXEC SETMSG MSG(ISRZ002)\n\n\n            EXIT CODE(12)\n\n\n          END\n\n\n\n\n\n        /* PROCESS LINE COMMANDS, CHECK IF A OR B WAS SPECIFIED               */\n\n\n        ISREDIT PROCESS DEST\n\n\n        SET RC = &LASTCC\n\n\n        IF &RC >= 16 THEN +\n\n\n          EXIT CODE(12)\n\n\n        ELSE IF &RC >= 4 THEN +\n\n\n          DO\n\n\n            SET ZERRSM = &STR(MISSING LINE COMMAND!!!)\n\n\n            SET MSG1 = &STR(PASTE REQUIRES USER TO ISSUE A )\n\n\n            SET MSG2 = &STR(LINE COMMAND OF EITHER \"A\" OR \"B\"...)\n\n\n            SET ZERRLM = &STR(&MSG1&MSG2)\n\n\n            SET ZERRALRM = YES\n\n\n            SET ZERRHM = PASTEHLP\n\n\n            ISPEXEC SETMSG MSG(ISRZ002)\n\n\n            EXIT CODE(12)\n\n\n          END\n\n\n\n\n\n        /* GET LINE COMMAND AND NUMBER OF LINES TO PASTE                      */\n\n\n        ISREDIT (PASTEPT) = LINENUM .ZDEST\n\n\n        ISPEXEC VGET (LINESCUT) PROFILE\n\n\n        SET CUT = &LINESCUT\n\n\n\n\n\n        /* CHECK THAT THERE ARE LINES TO BE PASTED                            */\n\n\n        IF &LINESCUT = 0 THEN +\n\n\n          DO\n\n\n            SET ZEDSMSG = &STR(NO LINES TO PASTE!!!)\n\n\n            SET MSG1 = &STR(LINES MUST FIRST BE CUT IN ORDER TO )\n\n\n            SET MSG2 = &STR(BE PASTED BY THE PASTE COMMAND...)\n\n\n            SET ZEDLMSG = &STR(&MSG1&MSG2)\n\n\n            ISPEXEC SETMSG MSG(ISRZ000)\n\n\n            EXIT CODE(0)\n\n\n          END\n\n\n\n\n\n        /* CHECK FOR TRUNCATION OF DATA                                       */\n\n\n        ISREDIT (PSTLRECL) = DATA_WIDTH\n\n\n        ISPEXEC VGET (CUTLRECL) PROFILE\n\n\n        SET CTLRECL = &CUTLRECL\n\n\n        IF &CUTLRECL > &PSTLRECL THEN +\n\n\n          SET OFLAG = OVERFLOW\n\n\n\n\n\n        /* PASTE LINES FROM PROFILE AFTER SELECTED POINT                  */\n\n\n        SET LN = 1\n\n\n        DO WHILE &LN <= &LINESCUT\n\n\n          ISPEXEC VGET (CUTLN&LN) PROFILE\n\n\n          ISREDIT LINE_AFTER &PASTEPT = DATALINE (CUTLN&LN)\n\n\n          SET LN = &LN+1\n\n\n          SET PASTEPT = &PASTEPT+1\n\n\n        END\n\n\n\n\n\n        /* DELETE LINES FROM PROFILE IF KEEP NOT SPECIFIED                    */\n\n\n        IF &PARM1 \u00ac= &STR(K) AND &PARM1 \u00ac= &STR(KEEP) THEN +\n\n\n          DO\n\n\n            SET LN = 1\n\n\n            DO WHILE &LN <= &LINESCUT\n\n\n              SET CUTLN&LN = &STR()\n\n\n              ISPEXEC VPUT (CUTLN&LN) PROFILE\n\n\n              SET LN = &LN+1\n\n\n            END\n\n\n            SET MSGFLAG = DELETE\n\n\n            SET LINESCUT = 0\n\n\n            SET CUTLRECL = 0\n\n\n            ISPEXEC VPUT (LINESCUT) PROFILE\n\n\n            ISPEXEC VPUT (CUTLRECL) PROFILE\n\n\n          END\n\n\n\n\n\n        /* IF TRUNCATION OF DATA, DISPLAY MESSAGE                             /*\n\n\n        IF &OFLAG = OVERFLOW THEN +\n\n\n          DO\n\n\n            SET TRNC = &CTLRECL-&PSTLRECL\n\n\n            SET ZERRSM = &STR(TRUNCATION OCCURED!!!)\n\n\n            SET MSG1 = &STR(LRECL OF LINES CUT IS &CTLRECL, FILE LRECL )\n\n\n            SET MSG2 = &STR(ONLY &PSTLRECL - &TRNC COLUMNS TRUNCATED... )\n\n\n            SET ZERRLM = &STR(&MSG1&MSG2)\n\n\n            SET ZERRALRM = YES\n\n\n            SET ZERRHM = PASTEHLP\n\n\n            ISPEXEC SETMSG MSG(ISRZ002)\n\n\n            EXIT CODE(0)\n\n\n          END\n\n\n\n\n\n        /* DISPLAY APPROPRIATE PASTE COMPLETION MESSAGE                       /*\n\n\n        IF &MSGFLAG = KEEP THEN +\n\n\n          DO\n\n\n            SET ZEDSMSG = &STR(&CUT LINES PASTED && KEPT)\n\n\n            SET MSG1 = &STR(A TOTAL OF &CUT LINES WERE )\n\n\n            SET MSG2 = &STR(PASTED, THEY REMAIN IN PROFILE...)\n\n\n            SET ZEDLMSG = &STR(&MSG1&MSG2)\n\n\n          END\n\n\n        ELSE +\n\n\n          DO\n\n\n            SET ZEDSMSG = &STR(&CUT PASTED && DELETED)\n\n\n            SET MSG1 = &STR(A TOTAL OF &CUT LINES WERE )\n\n\n            SET MSG2 = &STR(PASTED AND DELETED FROM PROFILE...)\n\n\n            SET ZEDLMSG = &STR(&MSG1&MSG2)\n\n\n          END\n\n\n        ISPEXEC SETMSG MSG(ISRZ000)\n\n\n\n\n\n        /* IF TRUNCATION OF DATA, DISPLAY MESSAGE                             /*\n\n\n        IF &OFLAG = OVERFLOW THEN +\n\n\n          DO\n\n\n            SET TRNC = &CTLRECL-&PSTLRECL\n\n\n            SET ZERRSM = &STR(TRUNCATION OCCURED!!!)\n\n\n            SET MSG1 = &STR(LRECL OF LINES CUT IS &CTLRECL, FILE LRECL )\n\n\n            SET MSG2 = &STR(ONLY &PSTLRECL - &TRNC COLUMNS TRUNCATED... )\n\n\n            SET ZERRLM = &STR(&MSG1&MSG2)\n\n\n          END\n\n\n        EXIT\n\n\n./ ADD NAME=POSTDIAL 0132-83245-86094-1820-00018-00001-00018-KK00150\n00010016    PROC 0\n\n\n00020016    CONTROL NOFLUSH END(ENDO)\n\n\n00031029      ISPEXEC VGET (POXC PCMD PDXF)\n\n\n00031129      /* NOTE PCMD IS NEVER XL IN POSTDIAL, USE PDXF TO CHECK XL */\n\n\n00032006      IF &POXC = &STR(A03) THEN EXIT\n\n\n00040032      ISPEXEC SELECT PGM(NEWMWILE) PARM(2) /* */\n\n\n00041021      IF &SYSPREF NE KK00150 THEN EXIT\n\n\n00050030      IF &SYSPROC = SPFSMPR1 THEN DO\n\n\n00060030         IF &PDXF = &STR(ZL) OR &PDXF = &STR(XL) THEN +\n\n\n00070009         ISPEXEC SELECT PGM(WDPSCXS) PARM(SMOFF)\n\n\n00071017         ENDO\n\n\n00080029      IF &PDXF = &STR(XL) THEN +\n\n\n00080124         SET ZSETFDSP = J\n\n\n00120021                          ELSE +\n\n\n00125024         SET ZSETFDSP = K\n\n\n00125330      IF &PDXF = &STR(ZL) THEN EXIT\n\n\n00125430      IF &PCMD = &STR(Z)  THEN EXIT\n\n\n00126024     ISPEXEC VPUT (ZSETFDSP) SHARED\n\n\n./ ADD NAME=PREDIAL  0106-83245-86094-1819-00001-00001-00001-KK00150\n00040002ISPEXEC SELECT PGM(NEWMWILE) PARM(1)\n\n\n./ ADD NAME=SHOWFLOW 0101-86141-86161-1759-00033-00033-00000-KK00150\n        ISREDIT MACRO\n\n\n        /*********************************************************************/\n\n\n        /*  THIS ISPF/PDF EDIT MACRO EXCLUDES ALL LINES IN THE DATA SET AND  */\n\n\n        /*  THEN FINDS ALL FLOW OF CONTROL WORDS FOR A PL/I PROGRAM.         */\n\n\n        /*                                                                   */\n\n\n        /*  TO RUN:                                                          */\n\n\n        /*     ENTER SHOWFLOW ON THE COMMAND LINE                            */\n\n\n        /*********************************************************************/\n\n\n\n\n\n        /* SAVE USER STATE SO THAT LAST FIND STRING WILL NOT BE AFFECTED     */\n\n\n        ISREDIT (USTATE) = USER_STATE\n\n\n\n\n\n        /* EXCLUDE ALL LINES */\n\n\n        ISREDIT EXCLUDE ALL\n\n\n\n\n\n        /* FIND CONTROL WORDS */\n\n\n        ISREDIT FIND ALL WORD PROCEDURE\n\n\n        ISREDIT FIND ALL WORD PROC\n\n\n        ISREDIT FIND ALL WORD CALL\n\n\n        ISREDIT FIND ALL WORD DO\n\n\n        ISREDIT FIND ALL WORD END\n\n\n        ISREDIT FIND ALL WORD ENDO\n\n\n        ISREDIT FIND ALL WORD IF\n\n\n        ISREDIT FIND ALL WORD THEN\n\n\n        ISREDIT FIND ALL WORD ELSE\n\n\n        ISREDIT FIND ALL WORD SELECT\n\n\n        ISREDIT FIND ALL WORD WHEN\n\n\n        ISREDIT FIND ALL WORD OTHERWISE\n\n\n\n\n\n        /* RESET USER STATE */\n\n\n        ISREDIT USER_STATE = (USTATE)\n\n\n\n\n\n        EXIT\n\n\n./ ADD NAME=SPFBATU  0100-83318-83318-1449-00148-00148-00000-KK00150\n00010000PROC 0 FI(NONE) L SF(Y)\n\n\n00020000CONTROL NOFLUSH   MSG END(ENDO)\n\n\n00030000IF &L = L THEN CONTROL MSG LIST CONLIST  /* */\n\n\n00040000GLOBAL GCRC GCVOL GCDEVT\n\n\n00050000GLOBAL EMSG\n\n\n00060000ERROR DO\n\n\n00070000      %ERRORMSG &LASTCC\n\n\n00080000      GOTO MAINLOOP\n\n\n00090000      ENDO\n\n\n00100000/* */\n\n\n00110000/*   INITIALIZE VARIABLES FIRST:                         */\n\n\n00120000/* */\n\n\n00130000SET EMSG = &STR()\n\n\n00131000SET OPT = &STR()\n\n\n00140000SET &CDCUR = MEMBER\n\n\n00150000ISPEXEC VGET (PRJ0 LIB0 TYP0 DSN) PROFILE\n\n\n00160000/* */\n\n\n00170000/*   DISPLAY OPTION/DATA PANEL:                         */\n\n\n00180000/* */\n\n\n00190000MAINLOOP: GOTO DISPLAY\n\n\n00200000DISPLAY: ERROR OFF\n\n\n00210000CONTROL MSG NOLIST NOCONLIST\n\n\n00220000ISPEXEC DISPLAY PANEL(SPFBATU) CURSOR(&CDCUR)\n\n\n00230000   SET DRC = &LASTCC\n\n\n00231000IF &L = L THEN CONTROL MSG LIST CONLIST  /* */\n\n\n00240000   IF &DRC NE 0 THEN DO\n\n\n00250000         IF &FI NE NONE THEN %CMDOUT FREE(&FI)\n\n\n00260000         ISPEXEC VPUT (PRJ0 LIB0 TYP0 DSN) PROFILE\n\n\n00261000         FREE F(SYSIN)\n\n\n00262000         ALLOC F(SYSIN) DA(*)\n\n\n00270000         EXIT\n\n\n00280000                     ENDO\n\n\n00290000SET EMSG = &STR()\n\n\n00291000IF &OPT = U THEN GOTO OPTVER\n\n\n00300000IF &FI = NONE THEN DO\n\n\n00310000              CONTROL NOMSG\n\n\n00320000              FREE ATTR(KKKASBU)\n\n\n00330000              ATTR KKKASBU RECFM(F,B) LRECL(121) BLK(1210)\n\n\n00340000              CONTROL MSG\n\n\n00350000              %CMDOUT DDN(SYSPRINT) USE(KKKASBU) FORCE &L\n\n\n00360000              SET &FI = &LASTCC\n\n\n00370000              IF &FI = 99 THEN DO\n\n\n00380000                  SET FI = NONE\n\n\n00390000                  SET EMSG = ERROR ALLOCATING CMD FILE\n\n\n00400000                  GOTO MAINLOOP\n\n\n00410000                               ENDO\n\n\n00420000              OPENFILE SYSPRINT OUTPUT\n\n\n00430000              CLOSFILE SYSPRINT\n\n\n00440000              SET SVOL = &VOL\n\n\n00450000              WHATDSN DDN(SYSPRINT)\n\n\n00460000              SET VOL = &SVOL\n\n\n00470000                   ENDO\n\n\n00480000GOTO OPTVER     /* VERIFY PARMS ENTERED   */\n\n\n00490000\n\n\n00500000OPTSEL:GOTO OPT&OPT\n\n\n00511000\n\n\n00520000ENDOPT: +\n\n\n00530000CALL 'WDPSC.CMDLIB(CLRSPFIO)'\n\n\n00540000ISPEXEC EDIT DATASET('&DSNAME.')\n\n\n00550000OPENFILE SYSPRINT OUTPUT\n\n\n00560000CLOSFILE SYSPRINT\n\n\n00561000SET CDCUR = MEMBER\n\n\n00570000GOTO MAINLOOP\n\n\n00580000\n\n\n00590000/*   OPTVER VERIFICATION SUBROUTINE:   */\n\n\n00600000\n\n\n00610000OPTVER: +\n\n\n00610100 IF &OPT NE Z AND &OPT NE U AND &MEMBER = THEN DO\n\n\n00610200     SET CDCUR = MEMBER\n\n\n00610300     SET EMSG = ENTER MEMBER NAME\n\n\n00610400     GOTO MAINLOOP\n\n\n00610500                                 ENDO\n\n\n00610600 IF &DSN = THEN SET &LIB = '&PRJ0..&LIB0..&TYP0'\n\n\n00610700           ELSE SET &LIB = &DSN\n\n\n00610800 SET &VO =\n\n\n00610900 SET &MO =\n\n\n00611000 IF &VOL NE &STR() THEN SET VO = VOL(&VOL)\n\n\n00611100 IF &MEMBER NE &STR() THEN SET MO = MEM(&MEMBER)\n\n\n00611200 FILEINFO DSN(&LIB) &VO &MO\n\n\n00611300 SET &FRC = &LASTCC\n\n\n00611400 IF &FRC NE 0 THEN DO\n\n\n00611500       IF &FRC = 24 THEN SET CDCUR = MEMBER\n\n\n00611600                    ELSE IF &DSN = THEN SET CDCUR = PRJ0\n\n\n00611700                                   ELSE SET CDCUR = DSN\n\n\n00611800       SET EMSG = &STR(&OUTMSG)\n\n\n00611900       GOTO MAINLOOP\n\n\n00612000                   ENDO\n\n\n00612100 IF &MEMCNTL = YES THEN DO\n\n\n00612200       SET CDCUR = DSN\n\n\n00612300       SET EMSG = MEMBER NAME NOT ALLOWED HERE\n\n\n00612400       GOTO MAINLOOP\n\n\n00612500                        ENDO\n\n\n00613000GOTO OPTSEL\n\n\n00620000\n\n\n00623100OPTU: STACK\n\n\n00624500URZAP '&FULLDSN' &VO\n\n\n00624600KOMM RES(1)\n\n\n00624700ISPEXEC CONTROL DISPLAY REFRESH\n\n\n00624800GOTO MAINLOOP\n\n\n00624900\n\n\n00625000OPTZ: +\n\n\n00625100CONTROL NOMSG\n\n\n00625200FREE F(SYSIN)\n\n\n00625300CONTROL MSG\n\n\n00625400ALLOC F(SYSIN) DA(*)\n\n\n00625500IF &VOL = &STR() THEN GOTO FREELIB\n\n\n00625600IFALC F(SYSLIB) DA('&FULLDSN')\n\n\n00625700IF &LASTCC = 0 THEN GOTO CALLZAP\n\n\n00625800FREELIB: CONTROL NOMSG\n\n\n00625900FREE F(SYSLIB)\n\n\n00626000CONTROL MSG\n\n\n00626100IF &VOL = &STR() THEN ALLOC F(SYSLIB) DA('&FULLDSN') SHR\n\n\n00626200                 ELSE ALLOC F(SYSLIB) DA('&FULLDSN') VOL(&VOL.) SHR UNIT\n(SYSALLDA)\n\n00626300CALLZAP: ISPEXEC CONTROL DISPLAY SM START(1)\n\n\n00626400         CALL 'SYS1.LINKLIB(AMASPZAP)'\n\n\n00626500GOTO ENDOPT\n\n\n00626600\n\n\n00626700OPTI: GOTO OPTB\n\n\n00626800OPTD: GOTO OPTB\n\n\n00627000\n\n\n00630000OPTB: +\n\n\n00631000IF &VOL = &STR() THEN GOTO FREELIB2\n\n\n00641000CONTROL NOMSG\n\n\n00642000FREE F(SYSLIB SYSIN)\n\n\n00643000GOTO ALLOCS\n\n\n00650000FREELIB2: CONTROL NOMSG\n\n\n00660000FREE F(SYSIN)\n\n\n00670000ALLOCS: CONTROL MSG\n\n\n00680000ALLOC F(SYSIN) SP(1) TRACK\n\n\n00681000IFALC F(SYSLIB) DA('&FULLDSN')\n\n\n00682000IF &LASTCC = 0 THEN GOTO BILDCTL\n\n\n00683000CONTROL NOMSG\n\n\n00684000FREE F(SYSLIB)\n\n\n00685000CONTROL MSG\n\n\n00690000IF &VOL = &STR() THEN ALLOC F(SYSLIB) DA('&FULLDSN') SHR\n\n\n00700000                 ELSE ALLOC F(SYSLIB) DA('&FULLDSN') VOL(&VOL.) SHR UNIT\n(SYSALLDA)\n\n00710000BILDCTL: OPENFILE SYSIN OUTPUT\n\n\n00711000IF &OPT = I THEN +\n\n\n00711100       SET SYSIN = &STR( LISTIDR OUTPUT=ALL,MEMBER=&MEMBER)\n\n\n00713000IF &OPT = B THEN +\n\n\n00720000       SET SYSIN = &STR( LISTLOAD OUTPUT=XREF,MEMBER=&MEMBER)\n\n\n00720100IF &OPT = D THEN +\n\n\n00722000       SET SYSIN = &STR( DUMPT &MEMBER &CSECT)\n\n\n00730000PUTFILE SYSIN\n\n\n00740000CLOSFILE SYSIN\n\n\n00741000IF &OPT = D THEN CALL 'SYS1.LINKLIB(AMASPZAP)'\n\n\n00750000            ELSE CALL 'SYS1.LINKLIB(AMBLIST)'\n\n\n00780000GOTO ENDOPT\n\n\n./ ADD NAME=SPFCATCC 0102-84079-84079-1143-00273-00274-00003-KK00150\n00010000PROC 0 TYPE(C) L CAT(NONE)\n\n\n00020000CONTROL NOFLUSH NOMSG END(ENDO)\n\n\n00021000IF &L = L THEN CONTROL MSG LIST CONLIST\n\n\n00022000   /**********************************************************/\n\n\n00022100   /* VERIFY THAT INPUT AND OUTPUT FILES ARE ALLOCATED:      */\n\n\n00022200   /**********************************************************/\n\n\n00023000ERROR EXIT CODE(99)\n\n\n00030000IFALC F(BILDLIST)\n\n\n00040000IFALC F(SYSIN)\n\n\n00121000   /**********************************************************/\n\n\n00122000   /* CALL THE INITALIZATION SUBROUTINE FOR VARIABLES:       */\n\n\n00123000   /**********************************************************/\n\n\n00124000GOTO INITVARS\n\n\n00130000INITDONE: CONTROL NOFLUSH\n\n\n00131000   /**********************************************************/\n\n\n00132000   /* ESTABLISH END OF FILE EXIT ROUTINE:                    */\n\n\n00133000   /**********************************************************/\n\n\n00140000ERROR DO\n\n\n00150000  ERROR OFF\n\n\n00160000  CLOSFILE BILDLIST\n\n\n00170000  CLOSFILE SYSIN\n\n\n00180000  EXIT\n\n\n00190000      ENDO\n\n\n00191000   /**********************************************************/\n\n\n00192000   /* OPEN THE INPUT AND OUTPUT FILES:                       */\n\n\n00193000   /**********************************************************/\n\n\n00200000OPENFILE BILDLIST INPUT\n\n\n00210000OPENFILE SYSIN OUTPUT\n\n\n00211000\n\n\n00220000   /**********************************************************/\n\n\n00221000   /**********************************************************/\n\n\n00230000   /* BEGIN MAIN PROCESSING LOOP:                            */\n\n\n00231000   /* LOOP READING THE IDCAMS LISTING FOR KNOWN ENTRIES:     */\n\n\n00232000   /* PERFORM SEPARATE SUBROUTINE FOR NVSAM,ALIAS,GDG:       */\n\n\n00240000   /**********************************************************/\n\n\n00241000   /**********************************************************/\n\n\n00250000LOOP: +\n\n\n00260000 GETFILE BILDLIST\n\n\n00270000 LOOP1:   IF &SUBSTR(1,&STR(&BILDLIST)) = &STR( ) THEN GOTO LOOP\n\n\n00280000 SET &SYSDVAL = &STR(&BILDLIST)\n\n\n00290000 READDVAL P1 P2 P3 P4\n\n\n00310000   /**********************************************************/\n\n\n00320000   /*                                    STANDARD NONVSAM:   */\n\n\n00330000   /**********************************************************/\n\n\n00350000 IF &STR(&P1) = NONVSAM THEN GOTO NVSAM\n\n\n00370000   /**********************************************************/\n\n\n01200000 /*                                      STANDARD GDG:       */\n\n\n01201000   /**********************************************************/\n\n\n01202000 IF &STR(&P1) = GDG THEN GOTO GDG\n\n\n01204000   /**********************************************************/\n\n\n01205000 /*                                      STANDARD ALIAS:     */\n\n\n01206000   /**********************************************************/\n\n\n01207000 IF &STR(&P1) = ALIAS THEN GOTO ALIAS\n\n\n01210000GOTO LOOP\n\n\n01210100\n\n\n01210300   /**********************************************************/\n\n\n01210400   /*          INDIVIDUAL ENTRY SUBROUTINES:                 */\n\n\n01210500   /**********************************************************/\n\n\n01210600\n\n\n01210700   /**********************************************************/\n\n\n01210800   /*                                    STANDARD NONVSAM:   */\n\n\n01210900   /**********************************************************/\n\n\n01211202NVSAM: SET DSN = &STR(&P3)\n\n\n01211300   /**********************************************************/\n\n\n01211400   /*                FIRST FIND THE VOLSER RECORD:           */\n\n\n01211500   /**********************************************************/\n\n\n01211600   FINDV: +\n\n\n01211700          GETFILE BILDLIST\n\n\n01211800          IF &SUBSTR(1,&STR(&BILDLIST)) NE &STR( ) THEN GOTO LOOP1\n\n\n01211900          SET &SYSDVAL = &STR(&BILDLIST)\n\n\n01212000          READDVAL P1 P2 P3 P4\n\n\n01212100          IF &STR(&P1) NE &STR(VOLUMES) THEN GOTO FINDV\n\n\n01212200          GETFILE BILDLIST\n\n\n01212300          SET &SYSDVAL = &STR(&BILDLIST)\n\n\n01212400          READDVAL P1 P2 P3 P4\n\n\n01212500          SET VOL = &SUBSTR(19:&LENGTH(&STR(&P1)),&STR(&P1))\n\n\n01212600          DO WHILE &SUBSTR(1,&STR(&VOL)) = &STR(-)\n\n\n01212700             SET VOL = &SUBSTR(2:&LENGTH(&STR(&VOL)),&STR(&VOL))\n\n\n01212800             ENDO\n\n\n01212900          SET DEV = &SUBSTR(16:&LENGTH(&STR(&P1))-1,&STR(&P2))\n\n\n01213000   /**********************************************************/\n\n\n01213100   /*                THEN  FIND THE DEVICE TYPE:             */\n\n\n01213200   /**********************************************************/\n\n\n01213300          SET DT = &STR(&D&DEV)\n\n\n01213400   /*     DEVTYPE VOL(&VOL)   */\n\n\n01213500          IF &LASTCC NE 0 THEN DO\n\n\n01213600              SET SYSIN = &STR(***** &VOL ***** ERROR ==> &OUTMSG )\n\n\n01213700              PUTFILE SYSIN\n\n\n01213800              GOTO LOOP\n\n\n01213900                               ENDO\n\n\n01214000\n\n\n01214100   /**********************************************************/\n\n\n01214200   /*                THEN  BUILD THE DESIRED CTL CARD:       */\n\n\n01214300   /**********************************************************/\n\n\n01214400          IF &TYPE = D THEN SET SYSIN = &STR( DEL '&DSN' )\n\n\n01214500                       ELSE  +\n\n\n01214600          IF &TYPE = U THEN SET SYSIN = &STR( DEL '&DSN' NSCR)\n\n\n01214700                       ELSE  DO\n\n\n01214800          SET SYSIN = &STR( DEF NVSAM&LP. NAME('&DSN') +)\n\n\n01214900                              PUTFILE SYSIN\n\n\n01215000/*        SET SYSIN = &STR(           VOL(&VOL) DEVT(&DEVTYP) &RP) */\n\n\n01215100          SET SYSIN = &STR(           VOL(&VOL) DEVT(&DT) &RP)\n\n\n01215200                             ENDO\n\n\n01215300   /**********************************************************/\n\n\n01215400   /*                THEN  WRITE SYSIN DESIRED CTL CARD:     */\n\n\n01215500   /**********************************************************/\n\n\n01215600          IF &STR(&CAT) = NONE THEN PUTFILE SYSIN\n\n\n01215700                         ELSE DO\n\n\n01215800                         SET &SYSIN = &STR(&SYSIN)&STR( +)\n\n\n01215900                              PUTFILE SYSIN\n\n\n01216000                         SET &SYSIN = &STR(   )&STR(CAT(&CAT))\n\n\n01216100                              PUTFILE SYSIN\n\n\n01216200                              ENDO\n\n\n01216300   /**********************************************************/\n\n\n01216400   /*   NOW SEE IF ANY ALIASES NEED TO BE MOVED:             */\n\n\n01216500   /**********************************************************/\n\n\n01216600          GETFILE BILDLIST\n\n\n01216700          IF &SUBSTR(1,&STR(&BILDLIST)) NE &STR( ) THEN GOTO LOOP1\n\n\n01216800          SET &SYSDVAL = &STR(&BILDLIST)\n\n\n01216900          READDVAL P1 P2 P3 P4\n\n\n01217000          IF &STR(&P1) = &STR(ASSOCIATIONS--------(NULL)) THEN GOTO LOOP\n\n\n01217100          IF &TYPE = D THEN GOTO LOOP\n\n\n01217200          IF &TYPE = U THEN GOTO LOOP\n\n\n01217300   /**********************************************************/\n\n\n01217400   /*   LOOP2   IF ANY ALIASES NEED TO BE MOVED:             */\n\n\n01217500   /**********************************************************/\n\n\n01217600  LOOP2:  GETFILE BILDLIST\n\n\n01217700          IF &SUBSTR(1,&STR(&BILDLIST)) NE &STR( ) THEN GOTO LOOP1\n\n\n01217800          SET &SYSDVAL = &STR(&BILDLIST)\n\n\n01217900          READDVAL P1 P2 P3 P4\n\n\n01218000          IF &STR(&P1) = NONVSAM THEN GOTO LOOP1\n\n\n01218100          IF &SUBSTR(1:9,&STR(&P1)) = &STR(ALIAS----) THEN DO\n\n\n01218200             SET AN = &SUBSTR(10:&LENGTH(&STR(&P1)),&STR(&P1))\n\n\n01218300             SET SYSIN = &STR( DEF ALIAS&LP. NAME('&AN') +)\n\n\n01218400                              PUTFILE SYSIN\n\n\n01218500             SET SYSIN = &STR(           REL('&DSN') &RP)\n\n\n01218600          IF &STR(&CAT) = NONE THEN PUTFILE SYSIN\n\n\n01218700                         ELSE DO\n\n\n01218800                         SET &SYSIN = &STR(&SYSIN)&STR( +)\n\n\n01218900                              PUTFILE SYSIN\n\n\n01219000                         SET &SYSIN = &STR(   )&STR(CAT(&CAT))\n\n\n01219100                              PUTFILE SYSIN\n\n\n01219200                              ENDO\n\n\n01219300                                                           ENDO\n\n\n01219400          GOTO LOOP2\n\n\n01219500   /**********************************************************/\n\n\n01219600   /*      END OF NVSAM ENTRY CODE                           */\n\n\n01219700   /**********************************************************/\n\n\n01219800\n\n\n01219900\n\n\n01220000   /**********************************************************/\n\n\n01220100   /*                                    STANDARD GDG:       */\n\n\n01220200   /**********************************************************/\n\n\n01220401GDG:      SET DSN = &STR(&P4)\n\n\n01220500   /**********************************************************/\n\n\n01220600   /*                FIRST FIND THE ATTR   RECORD:           */\n\n\n01220700   /**********************************************************/\n\n\n01220800   FINDA: +\n\n\n01220900          GETFILE BILDLIST\n\n\n01221000          IF &SUBSTR(1,&STR(&BILDLIST)) NE &STR( ) THEN GOTO LOOP1\n\n\n01221100          SET &SYSDVAL = &STR(&BILDLIST)\n\n\n01221200          READDVAL P1 P2 P3 P4\n\n\n01221300          IF &STR(&P1) NE &STR(ATTRIBUTES) THEN GOTO FINDA\n\n\n01221400          GETFILE BILDLIST\n\n\n01221500          SET &SYSDVAL = &STR(&BILDLIST)\n\n\n01221600          READDVAL P1 P2 P3 P4\n\n\n01221700          SET LIM = &SUBSTR(20:&LENGTH(&STR(&P1)),&STR(&P1))\n\n\n01221800          DO WHILE &SUBSTR(1,&STR(&LIM)) = &STR(-)\n\n\n01221900             SET LIM = &SUBSTR(2:&LENGTH(&STR(&LIM)),&STR(&LIM))\n\n\n01222000             ENDO\n\n\n01222100          SET SCR = &P2\n\n\n01222200          SET EMO = &P3\n\n\n01223300\n\n\n01223400   /**********************************************************/\n\n\n01223500   /*                THEN  BUILD THE DESIRED CTL CARD:       */\n\n\n01223600   /**********************************************************/\n\n\n01223700          IF &TYPE = D THEN SET SYSIN = &STR( DEL '&DSN' )\n\n\n01223800                       ELSE  +\n\n\n01223900          IF &TYPE = U THEN SET SYSIN = &STR( DEL '&DSN' NSCR)\n\n\n01224000                       ELSE  DO\n\n\n01224100          SET SYSIN = &STR( DEF GDG&LP. NAME('&DSN') +)\n\n\n01224200                              PUTFILE SYSIN\n\n\n01224300          SET SYSIN = &STR(           LIM(&LIM) &SCR &EMO &RP)\n\n\n01224500                             ENDO\n\n\n01224600   /**********************************************************/\n\n\n01224700   /*                THEN  WRITE SYSIN DESIRED CTL CARD:     */\n\n\n01224800   /**********************************************************/\n\n\n01224900          IF &STR(&CAT) = NONE THEN PUTFILE SYSIN\n\n\n01225000                         ELSE DO\n\n\n01225100                         SET &SYSIN = &STR(&SYSIN)&STR( +)\n\n\n01225200                              PUTFILE SYSIN\n\n\n01225300                         SET &SYSIN = &STR(   )&STR(CAT(&CAT))\n\n\n01225400                              PUTFILE SYSIN\n\n\n01225500                              ENDO\n\n\n01225600   GOTO LOOP\n\n\n01225700   /**********************************************************/\n\n\n01225800   /*      END OF GDG ENTRY CODE                             */\n\n\n01225900   /**********************************************************/\n\n\n01229000\n\n\n01229100\n\n\n01229200   /**********************************************************/\n\n\n01229300   /*                                    STANDARD ALIAS:     */\n\n\n01229400   /**********************************************************/\n\n\n01229501ALIAS:    SET DSN = &STR(&P3)\n\n\n01229600   /**********************************************************/\n\n\n01229700   /*                FIRST FIND THE REL    RECORD:           */\n\n\n01229800   /**********************************************************/\n\n\n01229900   FINDR: +\n\n\n01230000          GETFILE BILDLIST\n\n\n01230100          IF &SUBSTR(1,&STR(&BILDLIST)) NE &STR( ) THEN GOTO LOOP1\n\n\n01230200          SET &SYSDVAL = &STR(&BILDLIST)\n\n\n01230300          READDVAL P1 P2 P3 P4\n\n\n01230400          IF &STR(&P1) NE &STR(ASSOCIATIONS) THEN GOTO FINDR\n\n\n01230500          GETFILE BILDLIST\n\n\n01230600          SET &SYSDVAL = &STR(&BILDLIST)\n\n\n01230700          READDVAL P1 P2 P3 P4\n\n\n01230800          SET REL = &SUBSTR(10:&LENGTH(&STR(&P1)),&STR(&P1))\n\n\n01231400\n\n\n01231500   /**********************************************************/\n\n\n01231600   /*                THEN  BUILD THE DESIRED CTL CARD:       */\n\n\n01231700   /**********************************************************/\n\n\n01231800          IF &TYPE = D THEN SET SYSIN = &STR( DEL '&DSN' )\n\n\n01231900                       ELSE  +\n\n\n01232000          IF &TYPE = U THEN SET SYSIN = &STR( DEL '&DSN' NSCR)\n\n\n01232100                       ELSE  DO\n\n\n01232200          SET SYSIN = &STR( DEF ALIAS&LP. NAME('&DSN') +)\n\n\n01232300                              PUTFILE SYSIN\n\n\n01232400          SET SYSIN = &STR(           REL('&REL') &RP)\n\n\n01232500                             ENDO\n\n\n01232600   /**********************************************************/\n\n\n01232700   /*                THEN  WRITE SYSIN DESIRED CTL CARD:     */\n\n\n01232800   /**********************************************************/\n\n\n01232900          IF &STR(&CAT) = NONE THEN PUTFILE SYSIN\n\n\n01233000                         ELSE DO\n\n\n01233100                         SET &SYSIN = &STR(&SYSIN)&STR( +)\n\n\n01233200                              PUTFILE SYSIN\n\n\n01233300                         SET &SYSIN = &STR(   )&STR(CAT(&CAT))\n\n\n01233400                              PUTFILE SYSIN\n\n\n01233500                              ENDO\n\n\n01233600   GOTO LOOP\n\n\n01233700   /**********************************************************/\n\n\n01233800   /*      END OF ALIAS ENTRY CODE                           */\n\n\n01233900   /**********************************************************/\n\n\n01234000\n\n\n01234100   /**********************************************************/\n\n\n01234200   /**********************************************************/\n\n\n01234300   /* INITIALIZE VARIABLES SUBROUTINE :                      */\n\n\n01234400   /**********************************************************/\n\n\n01234500   /**********************************************************/\n\n\n01234600INITVARS: +\n\n\n01235000SET &LP = &SUBSTR(1,&STR(()))\n\n\n01240000SET &RP = &SUBSTR(2,&STR(()))\n\n\n01250000SET &D = &STR(&&D)\n\n\n01260000SET D30502009 = &STR(3330)\n\n\n01270000SET D3050200D = &STR(3330-1)\n\n\n01280000SET D3050200B = &STR(3350)\n\n\n01290000SET D3010200E = &STR(3380)\n\n\n01300000SET D30502006 = &STR(2305-1)\n\n\n01310000SET D30502007 = &STR(2305-2)\n\n\n01320000SET D00012000 = &STR(SYSDA)\n\n\n01330000SET D00022000 = &STR(SYSSQ)\n\n\n01340000SET D00082000 = &STR(WORK)\n\n\n01350000SET D00092000 = &STR(WORK)\n\n\n01360000SET D00058000 = &STR(TAPE8)\n\n\n01370000SET D00068000 = &STR(TAPE16)\n\n\n01380000SET D30008001 = &STR(2400)\n\n\n01390000SET D34008001 = &STR(2400-3)\n\n\n01400000SET D34208001 = &STR(2400-4)\n\n\n01410000SET D34008003 = &STR(3400-3)\n\n\n01420000SET D34208003 = &STR(3400-4)\n\n\n01430000SET D32008003 = &STR(3400-5)\n\n\n01440000SET D32108003 = &STR(3400-6)\n\n\n01450000GOTO INITDONE\n\n\n./ ADD NAME=SPFCATNV 0102-85273-86084-1745-00754-00753-00000-KK00150\n        PROC 0 FI(NONE) L\n\n\n        CONTROL NOFLUSH   MSG END(ENDO)\n\n\n        /*IF &SYSUID = KK00150 THEN CONTROL MSG LIST CONLIST  /* */\n\n\n        IF &L = L THEN CONTROL MSG LIST CONLIST  /* */\n\n\n        GLOBAL GCRC GCVOL GCDEVT\n\n\n        GLOBAL EMSG\n\n\n        ERROR DO\n\n\n              %ERRORMSG &LASTCC\n\n\n              GOTO MAINLOOP\n\n\n              ENDO\n\n\n        /******************************************************************/\n\n\n        /*   INITIALIZE VARIABLES FIRST:                                  */\n\n\n        /******************************************************************/\n\n\n        SET PATTR = &STR(LOW)\n\n\n        SET CN = &STR(&&CN)\n\n\n        SET CO = &STR(&&CO)\n\n\n        SET CP = &STR(&&CP)\n\n\n        SET PF = &STR(&&PF)\n\n\n        SET &P  = &STR(&&P)\n\n\n        SET &EO  = &STR(&&EO)\n\n\n        SET EMSG = &STR()\n\n\n        SET DEVT = &STR()\n\n\n        SET ALIAS = &STR()\n\n\n        SET &CDCUR = DSN\n\n\n        SET &VF = N\n\n\n        SET REP = &STR(&&REP)\n\n\n        SET REP1 = NONE\n\n\n        SET REP2 = NONE\n\n\n        SET REP3 = NONE\n\n\n        SET REP4 = NONE\n\n\n        SET REP5 = NONE\n\n\n        SET REP6 = NONE\n\n\n        SET REP7 = NONE\n\n\n        SET REP8 = NONE\n\n\n        ERROR OFF\n\n\n        ISPEXEC VGET (CN7 CN8 LF PASSDS) PROFILE\n\n\n        IF &PASSDS NE YES THEN SET &DSN = &STR()\n\n\n        IF &PASSDS NE YES THEN SET &VOL = &STR()\n\n\n        ERROR DO\n\n\n              %ERRORMSG &LASTCC\n\n\n              GOTO MAINLOOP\n\n\n              ENDO\n\n\n        INITCATS: SET ICF = N\n\n\n        SET CN1 = &STR(SYS1.SOFTCAT)\n\n\n        SET CD1 = &STR(SOFTWARE CAT)\n\n\n        SET PF1 = N\n\n\n        SET CN2 = &STR(SYS1.C03MCAT)\n\n\n        SET CD2 = &STR(Q1CD MASTER)\n\n\n        SET PF2 = N\n\n\n        SET CN3 = &STR(SYS1.E07MCAT)\n\n\n        SET CD3 = &STR(Q2EF MASTER)\n\n\n        SET PF3 = N\n\n\n        SET CN4 = &STR(SYS1.G29MCAT)\n\n\n        SET CD4 = &STR(H3AN MASTER)\n\n\n        SET PF4 = U\n\n\n        SET CN5 = &STR(SYS1.K15MCAT)\n\n\n        SET CD5 = &STR(K1K1 MASTER)\n\n\n        SET PF5 = U\n\n\n        SET CN6 = &STR(SYS1.USERCAT1)\n\n\n        SET CD6 = &STR(USERCAT1)\n\n\n        SET PF6 = N\n\n\n        SET PF7 = N\n\n\n        SET CD7 = &STR((OPTIONAL CAT))\n\n\n        SET PF8 = N\n\n\n        SET CD8 = &STR((OPTIONAL CAT))\n\n\n\n\n\n        /******************************************************************/\n\n\n        /*   MAIN DIALOG LOOP START: DISPLAY PANEL AND GET RESPONSE:      */\n\n\n        /******************************************************************/\n\n\n        MAINLOOP: IF &ICF = Y THEN GOTO INITCATS\n\n\n        DISPLAY: ERROR OFF\n\n\n        CONTROL MSG NOLIST NOCONLIST\n\n\n        ISPEXEC DISPLAY PANEL(&SYSICMD) CURSOR(&CDCUR)\n\n\n           SET DRC = &LASTCC\n\n\n           IF &DRC NE 0 THEN DO\n\n\n                 IF &FI NE NONE THEN %CMDOUT FREE(&FI)\n\n\n                 ISPEXEC VPUT (CN7 CN8 LF) PROFILE\n\n\n                 EXIT\n\n\n                             ENDO\n\n\n        IF &LF = L THEN DO\n\n\n                        ISPEXEC CONTROL DISPLAY SM START(1)\n\n\n                        CONTROL MSG LIST CONLIST\n\n\n                        SET VF = E\n\n\n                        SET L = L\n\n\n                        ENDO\n\n\n                   ELSE DO\n\n\n                        SET VF = N\n\n\n                        IF &LF = Y THEN SET VF = Y\n\n\n                        IF &LF = B THEN SET VF = Y\n\n\n                        IF &LF = E THEN SET VF = E\n\n\n                        ENDO\n\n\n        IF &STR(&DEVT) = &STR() THEN SET CDT = Y\n\n\n                                ELSE SET CDT = N\n\n\n        SET EMSG = &STR()\n\n\n        SET PATTR = &STR()\n\n\n\n\n\n        /******************************************************************/\n\n\n        /*   ALLOCATE AN OUTPUT FILE FOR DISPLAYING THE RESULTS:          */\n\n\n        /******************************************************************/\n\n\n        IF &FI = NONE THEN DO\n\n\n                      CONTROL NOMSG\n\n\n                      IF &LF = L THEN CONTROL MSG\n\n\n                      FREE ATTR(KKKACUNV)\n\n\n                      ATTR KKKACUNV RECFM(V,B) LRECL(137) BLK(3155)\n\n\n                      CONTROL MSG\n\n\n                      %CMDOUT MOD USE(KKKACUNV) FORCE &L\n\n\n                      SET &FI = &LASTCC\n\n\n                      IF &FI = 99 THEN DO\n\n\n                          SET FI = NONE\n\n\n                          SET EMSG = ERROR ALLOCATING CMD FILE\n\n\n                          GOTO MAINLOOP\n\n\n                                       ENDO\n\n\n                      OPENFILE CMDOUT&FI OUTPUT\n\n\n                      CLOSFILE CMDOUT&FI\n\n\n                      SET SVOL = &VOL\n\n\n                      WHATDSN DDN(CMDOUT&FI)\n\n\n                      SET &CDSN = &DSNAME\n\n\n                      SET VOL = &SVOL\n\n\n                           ENDO\n\n\n\n\n\n        /******************************************************************/\n\n\n        /*   MAKE ONE PASS   THROUGH ALL CATALOGS VERIFYING  REQUESTS:    */\n\n\n        /******************************************************************/\n\n\n        GOTO CATVER     /* VERIFY PARMS ENTERED   */\n\n\n\n\n\n        /******************************************************************/\n\n\n        /*   MAKE 3 PASSES THROUGH ALL CATALOGS PROCESSING REQUESTS:      */\n\n\n        /******************************************************************/\n\n\n        CATLOOP: +\n\n\n        SET PASS = 1\n\n\n        DO WHILE &PASS < 4\n\n\n                                 /*  INNER LOOP THROUGH EACH CATLOG:   */\n\n\n          SET CDF = YES\n\n\n          SET &I = 1\n\n\n          DO WHILE &I < 9\n\n\n            IF &CO&I NE &STR( ) THEN GOTO CATFUNC /* CATALOG NEEDS SOMETHING */\n\n\n            CATDONE: +\n\n\n            IF &CDF = YES THEN SET &CO&I =\n\n\n            SET CDF = YES\n\n\n            SET &I = &I + 1\n\n\n          ENDO\n\n\n\n\n\n          SET PASS = &PASS + 1\n\n\n        ENDO\n\n\n\n\n\n        /******************************************************************/\n\n\n        /*   ALL CATALOG FTNS DONE: DISPLAY RESULTS AND RESTART DIALOG:   */\n\n\n        /******************************************************************/\n\n\n\n\n\n        SET CDCUR = DSN\n\n\n        ENDLOOP: IF &CDT = Y THEN SET DEVT = &STR()\n\n\n                 IF &VF = N THEN DO\n\n\n                            OPENFILE CMDOUT&FI OUTPUT\n\n\n                            CLOSFILE CMDOUT&FI\n\n\n                            GOTO MAINLOOP\n\n\n                                 ENDO\n\n\n        ISPEXEC SELECT PGM(CLRSPFIO)\n\n\n        ISPEXEC CONTROL ERRORS RETURN\n\n\n        IF &VF = Y THEN ISPEXEC BROWSE DATASET('&CDSN.')\n\n\n        IF &VF = E THEN ISPEXEC EDIT DATASET('&CDSN.')\n\n\n        OPENFILE CMDOUT&FI OUTPUT\n\n\n        CLOSFILE CMDOUT&FI\n\n\n        SET VF = N\n\n\n        GOTO MAINLOOP\n\n\n\n\n\n        /******************************************************************/\n\n\n        /*   ALL DIALOG INTERNAL SUBROUTINES FOLLOW HERE:                 */\n\n\n        /******************************************************************/\n\n\n\n\n\n        /*   CATVER VERIFICATION SUBROUTINE:   */\n\n\n\n\n\n        CATVER: SET NAME = &STR(&DSN)\n\n\n        /*                                                                   */\n\n\n        /*  1 = NO OP                           6 = DELETE                   */\n\n\n        /*  2 = LISTCAT                         7 = CATALOG                  */\n\n\n        /*  3 = LISTCAT LVL                    11 = RECATALOG                */\n\n\n        /*  4 = UNCATALOG                      13 = RENAME                   */\n\n\n        /*  5 = DEF ALIAS                      17 = DEF GDG                  */\n\n\n        /* 19 = COPY FROM CATALOG              23 = MOVE FROM CATALOG        */\n\n\n        /*                                                                   */\n\n\n        /*  8 = COPY LIST(L) FROM CAT  (FL)  9 = COPY LIST(LL) FROM CAT (FLL)*/\n\n\n        /* 10 = MOVE LIST(L) FROM CAT  (ML) 12 = MOVE LIST(LL) FROM CAT (MLL)*/\n\n\n        /* 14 = CATALOG FROM LIST BILT BY 8,9,10,12  (THIS IS CL)            */\n\n\n        /*                                                                   */\n\n\n        /* 15 = UNCATALOG BY LEVEL                                           */\n\n\n        /* 16 = DELETE    BY LEVEL                                           */\n\n\n        /*                                                                   */\n\n\n        /* 18 = INVOKE FLIST FACILITY                                        */\n\n\n        /* 20 = ALTER (VIA PARM FIELD)                                       */\n\n\n        /*                                                                   */\n\n\n\n\n\n        /* DO PRELIMINARY PROCESSING:  VERIFY OPTION COMBINATIONS   */\n\n\n        /*     THEN VERIFY VOL AND DEVT FOR LATER CAT OR RECAT OPT  */\n\n\n\n\n\n        /* SET OP FLAGS OFF  */\n\n\n        SET &FF = NO\n\n\n        SET &MFF = NO\n\n\n        SET &CATF = NO\n\n\n        SET &CATLF = NO\n\n\n        SET &RECATF = NO\n\n\n        SET &COPYF = NO\n\n\n        SET &MOVEF = NO\n\n\n        SET &BILDF = NO\n\n\n        SET &DELF = NO\n\n\n        SET &RENF = NO\n\n\n        SET &GDGF = NO\n\n\n        SET &ALIASF = NO\n\n\n        SET &ULLF = NO\n\n\n        SET &ALTF = NO\n\n\n\n\n\n        SET &J = 1\n\n\n        DO WHILE &J < 9\n\n\n          IF &CO&J = 5 THEN SET &ALIASF = YES\n\n\n          IF &CO&J = 6 THEN SET &DELF = YES\n\n\n          IF &CO&J = 7 THEN SET &CATF = YES\n\n\n          IF &CO&J = 8  OR &CO&J = 9 OR &CO&J = 10 OR &CO&J = 12 THEN +\n\n\n                             SET &BILDF = YES\n\n\n          IF &CO&J = 11 THEN SET &RECATF = YES\n\n\n          IF &CO&J = 13 THEN SET &RENF = YES\n\n\n          IF &CO&J = 14 THEN SET &CATLF = YES\n\n\n          IF &CO&J = 15 THEN SET &ULLF = YES\n\n\n          IF &CO&J = 17 THEN SET &GDGF = YES\n\n\n          IF &CO&J = 19 THEN SET &COPYF = YES\n\n\n          IF &CO&J = 20 THEN SET &ALTF = YES\n\n\n          IF &CO&J = 23 THEN SET &MOVEF = YES\n\n\n          SET &J = &J + 1\n\n\n        ENDO\n\n\n\n\n\n        IF &BILDF = YES THEN DO\n\n\n            IF &CATF = YES OR &RECATF = YES OR +\n\n\n               &COPYF = YES OR &MOVEF = YES OR +\n\n\n               &RENF = YES OR &GDGF = YES THEN DO\n\n\n                SET EMSG = &STR(INVALID COMBINATION OF OPTIONS)\n\n\n                SET CDCUR = CO1\n\n\n                GOTO MAINLOOP\n\n\n                ENDO\n\n\n            IF &CATLF = NO THEN DO\n\n\n                SET EMSG = &STR(SPECIFY DEST FOR CATALOG-A-LIST)\n\n\n                SET CDCUR = CO1\n\n\n                GOTO MAINLOOP\n\n\n                ENDO\n\n\n            ENDO\n\n\n\n\n\n        IF &CATLF = YES THEN DO\n\n\n            IF &CATF = YES OR &RECATF = YES OR +\n\n\n               &COPYF = YES OR &MOVEF = YES OR +\n\n\n               &RENF = YES OR &GDGF = YES THEN DO\n\n\n                SET EMSG = &STR(INVALID COMBINATION OF OPTIONS)\n\n\n                SET CDCUR = CO1\n\n\n                GOTO MAINLOOP\n\n\n                ENDO\n\n\n            IF &BILDF = NO THEN DO\n\n\n                SET EMSG = &STR(SPECIFY SOURCE FOR CATALOG-A-LIST)\n\n\n                SET CDCUR = CO1\n\n\n                GOTO MAINLOOP\n\n\n                ENDO\n\n\n            ENDO\n\n\n\n\n\n        IF &ULLF = YES THEN DO\n\n\n            IF &CATF = YES OR &RECATF = YES OR +\n\n\n               &COPYF = YES OR &MOVEF = YES OR +\n\n\n               &RENF = YES OR &GDGF = YES THEN DO\n\n\n                SET EMSG = &STR(INVALID COMBINATION OF OPTIONS)\n\n\n                SET CDCUR = CO1\n\n\n                GOTO MAINLOOP\n\n\n                ENDO\n\n\n            ENDO\n\n\n\n\n\n        IF &GDGF = YES THEN DO\n\n\n            IF &CATF = YES OR &RECATF = YES OR +\n\n\n               &COPYF = YES OR &MOVEF = YES OR +\n\n\n               &RENF = YES OR &CATLF = YES  OR BILDF = YES THEN DO\n\n\n                SET EMSG = &STR(INVALID COMBINATION OF OPTIONS)\n\n\n                SET CDCUR = CO1\n\n\n                GOTO MAINLOOP\n\n\n                ENDO\n\n\n            ENDO\n\n\n\n\n\n\n\n\n        IF &CATF = NO AND &RECATF = NO  THEN GOTO CATLOOP /* NO VER NEEDED */\n\n\n        IF &COPYF = YES OR &MOVEF = YES THEN GOTO CATLOOP /* GET VOL LATER */\n\n\n\n\n\n        IF &STR(&VOL) = &STR() THEN DO\n\n\n\n\n\n          IF &RECATF = YES       THEN DO\n\n\n              SET EMSG = &STR(ERROR - VOLUME IS NEEDED TO RECATALOG DATASET.)\n\n\n              SET CDCUR = VOL\n\n\n              GOTO MAINLOOP\n\n\n                                      ENDO\n\n\n\n\n\n          IF &CATF = YES       THEN DO\n\n\n              FILEINFO DSN(&NAME)\n\n\n              SET FIRC = &LASTCC\n\n\n               IF &FIRC = 4 THEN DO\n\n\n                    SET EMSG = &STR(VOLUME NEEDED TO CATALOG &NAME)\n\n\n                    SET CDCUR = VOL\n\n\n                    GOTO MAINLOOP\n\n\n                                  ENDO\n\n\n               IF &FIRC NE 0 THEN DO\n\n\n                    SET EMSG = &STR(UNABLE TO CATALOG &NAME - &OUTMSG)\n\n\n                    SET CDCUR = VOL\n\n\n                    GOTO MAINLOOP\n\n\n                                  ENDO\n\n\n              SET &VOL = &STR(&VOLSER)\n\n\n                                    ENDO\n\n\n                                  ENDO\n\n\n\n\n\n        GOTVOL: +\n\n\n        IF &STR(&DEVT) = &STR() THEN +\n\n\n           DO\n\n\n           DEVTYPE VOL(&VOL)\n\n\n           SET DTRC = &LASTCC\n\n\n           IF &DTRC NE 0 THEN +\n\n\n                DO\n\n\n                IF &LENGTH(&VOL) > 3 THEN DO\n\n\n                     IF &SUBSTR(1:4,&VOL) = 3350 THEN DO\n\n\n                                                SET &DEVT = 3350\n\n\n                                                GOTO GOTDEVT\n\n\n                                                      ENDO\n\n\n                     IF &SUBSTR(1:4,&VOL) = 3380 THEN DO\n\n\n                                                SET &DEVT = 3380\n\n\n                                                GOTO GOTDEVT\n\n\n                                                      ENDO\n\n\n                                          ENDO\n\n\n                IF &DTRC = 8 THEN DO\n\n\n                                  SET EMSG = &STR(DEVICE TYPE NEEDED)\n\n\n                                  SET CDCUR = DEVT\n\n\n                                  GOTO MAINLOOP\n\n\n                                  ENDO\n\n\n                SET EMSG = &STR(DEVICE TYPE NEEDED - &OUTMSG)\n\n\n                SET CDCUR = DEVT\n\n\n                GOTO MAINLOOP\n\n\n                ENDO\n\n\n           SET &DEVT = &STR(&DEVTYP)\n\n\n           ENDO\n\n\n        GOTDEVT: +\n\n\n        GOTO CATLOOP\n\n\n\n\n\n\n\n\n        /*  CATALOG FUNCTION CONTROL SUBROUTINE:                             */\n\n\n        /*    (GET PASSWORD AS NEEDED, CALL SPECIFIC CATALOG FUNCTION)       */\n\n\n\n\n\n        /*                    FIRST, ANALYZE OPTION,PARMS AND PASSWORD:  */\n\n\n        CATFUNC: +\n\n\n        SET CC = &I\n\n\n        SET &SYSDVAL = &STR(&CP&CC)\n\n\n        SET &CP&CC = &STR()\n\n\n        READDVAL P1 P2 P3 P4 P5 P6\n\n\n        SET &PC = 1\n\n\n        DO WHILE &PC < 6\n\n\n        IF &PF&CC = Y OR &PF&CC = U THEN DO\n\n\n             IF &CO&CC = 8 OR &CO&CC = 9 THEN GOTO NOPASS\n\n\n             IF &CO&CC = 1 OR &CO&CC = 19 THEN GOTO NOPASS\n\n\n             IF &PF&CC = U AND &CO&CC < 4 THEN GOTO NOPASS\n\n\n             IF &REP&CC = NONE AND &P&PC = &STR() THEN +\n\n\n                                   DO\n\n\n                                   SET EMSG = &STR(ENTER PASSWORD)\n\n\n                                   SET CDCUR = CP&CC\n\n\n                                   SET PATTR = NON\n\n\n                                   GOTO DISPLAY\n\n\n                                   ENDO\n\n\n             IF &P&PC NE &STR() AND &PC = 1 THEN +\n\n\n                                   DO\n\n\n                                   SET &REP&CC = &STR(&P&PC)\n\n\n                                   GOTO NEXTPARM\n\n\n                                   ENDO\n\n\n                                         ENDO\n\n\n        NOPASS: +\n\n\n             IF &P&PC = &STR() THEN GOTO SELOPT\n\n\n             IF &P&PC = Y THEN DO\n\n\n                               SET &PF&CC = Y\n\n\n                               SET ICF = Y\n\n\n                               SET &NPC = &PC+1\n\n\n                               IF &P&NPC NE &STR() THEN DO\n\n\n                                                   SET &REP&CC = &P&NPC\n\n\n                                                   SET &PC = &PC+1\n\n\n                                                   ENDO\n\n\n                                                   ELSE DO\n\n\n                                                   SET &REP&CC = NONE\n\n\n                                                   ENDO\n\n\n                               GOTO NEXTPARM\n\n\n                               ENDO\n\n\n             IF &P&PC = &REP&CC THEN GOTO NEXTPARM\n\n\n             IF &CP&CC NE &STR() THEN SET &CP&CC = &STR(&CP&CC &P&PC)\n\n\n                                 ELSE SET &CP&CC = &STR(&P&PC)\n\n\n        NEXTPARM: SET &PC = &PC + 1\n\n\n        ENDO\n\n\n\n\n\n        /*                    SECOND ; CALL THE FUNCTION SUBROUTINE :      */\n\n\n        SELOPT: GOTO O&CO&CC                 /* CALL THE CATALOG FUNCTION  */\n\n\n\n\n\n        /*                    THIRD  ; SAY OK AND RETURN TO CATALOG LOOP:  */\n\n\n        CUP: SET EMSG = &STR(SUCCESSFUL COMPLETION FOR &CN&CC)\n\n\n             GOTO CATDONE\n\n\n\n\n\n        /***************************************************/\n\n\n        /* SPECIFIC CATALOG FUNCTION SUBROUTINES FOLLOW:   */\n\n\n        /***************************************************/\n\n\n\n\n\n        /* SOME FUNCTIONS NEED TO LIST THEIR RESULTS BACK FOR LATER DISPLAY: */\n\n\n        OKLC: +\n\n\n          STACK DDOUT(CMDOUT&FI.M)\n\n\n          LISTC ALL ENT(&NAME) CAT('&CN&CC'/&REP&CC)\n\n\n          GOTO CUP\n\n\n\n\n\n        /* SOME FUNCTIONS NEED TO WAIT UNTIL LATER TO PERFORM THEIR STUFF:   */\n\n\n        WAIT: +\n\n\n          SET CDF = NO\n\n\n          GOTO CATDONE\n\n\n\n\n\n        O1:    GOTO CATDONE                     /* NOP FUNCTION  */\n\n\n\n\n\n        /*         OPTION L  */\n\n\n        O2: +\n\n\n            IF &PASS = 1 THEN GOTO WAIT  /* NOT TIME TO DO THIS YET... */\n\n\n            IF &CP&CC = &STR() THEN SET &CP&CC = ALL\n\n\n            STACK DDOUT(CMDOUT&FI.M) LIST\n\n\n            LISTC &CP&CC ENT(&NAME) CAT('&CN&CC'/&REP&CC)\n\n\n            SET VF = Y\n\n\n            IF &CP&CC = ALL THEN SET &CP&CC = &STR()\n\n\n            GOTO CATDONE\n\n\n\n\n\n        /*         OPTION LL */\n\n\n        O3: +\n\n\n            IF &PASS = 1 THEN GOTO WAIT  /* NOT TIME TO DO THIS YET... */\n\n\n            IF &CP&CC = &STR() THEN SET &CP&CC = ALL\n\n\n            STACK DDOUT(CMDOUT&FI.M) LIST\n\n\n            LISTC &CP&CC LVL(&NAME) CAT('&CN&CC'/&REP&CC)\n\n\n            SET VF = Y\n\n\n            IF &CP&CC = ALL THEN SET &CP&CC = &STR()\n\n\n            GOTO CATDONE\n\n\n\n\n\n        /*         OPTION U  */\n\n\n        O4: +\n\n\n          IF &PASS = 1 THEN GOTO WAIT  /* NOT TIME TO DO THIS YET... */\n\n\n          STACK DDOUT(CMDOUT&FI.M) LIST\n\n\n          DEL &NAME NSCR &CP&CC CAT('&CN&CC'/&REP&CC)\n\n\n          SET &RC = &LASTCC\n\n\n          IF &RC NE 0 THEN DO\n\n\n                           SET VF = Y\n\n\n                           SET EMSG = &STR(ERROR &RC FOR &CN&CC)\n\n\n                           GOTO CATDONE\n\n\n                           ENDO\n\n\n          GOTO CUP\n\n\n\n\n\n        /*         OPTION A  */\n\n\n        O5: +\n\n\n          IF &PASS = 1 THEN GOTO WAIT  /* NOT TIME TO DO THIS YET... */\n\n\n          STACK DDOUT(CMDOUT&FI.M) LIST\n\n\n          DEF ALIAS(NAME(&ALIAS) REL(&NAME)) CAT('&CN&CC'/&REP&CC)\n\n\n          SET &RC = &LASTCC\n\n\n          IF &RC NE 0 THEN DO\n\n\n                           SET VF = Y\n\n\n                           SET EMSG = &STR(ERROR &RC FOR &CN&CC)\n\n\n                           GOTO CATDONE\n\n\n                           ENDO\n\n\n          GOTO OKLC\n\n\n\n\n\n        /*         OPTION D  */\n\n\n        O6: +\n\n\n          IF &PASS = 1 THEN GOTO WAIT  /* NOT TIME TO DO THIS YET... */\n\n\n          IF &PF&CC = U OR &PF&CC = Y THEN DO\n\n\n            %CATGET &NAME '&CN&CC.'\n\n\n               IF &GCRC NE 0 THEN DO\n\n\n                  SET EMSG = &STR(ERROR &GCRC FROM CATGET)\n\n\n                  SET CDCUR = CO&I\n\n\n                  GOTO ENDLOOP\n\n\n                                  ENDO\n\n\n          CONTROL NOMSG\n\n\n          FREE F(DANCATD)\n\n\n          CONTROL MSG\n\n\n          ALLOC F(DANCATD) DA(&NAME) VOL(&GCVOL) UNIT(&GCDEVT)\n\n\n          STACK DDOUT(CMDOUT&FI.M) LIST\n\n\n          DEL &NAME &CP&CC CAT('&CN&CC'/&REP&CC) FILE(DANCATD)\n\n\n          SET &RC = &LASTCC\n\n\n          CONTROL NOMSG\n\n\n          FREE F(DANCATD)\n\n\n          CONTROL MSG\n\n\n          IF &RC NE 0 THEN DO\n\n\n                           SET VF = Y\n\n\n                           SET EMSG = &STR(ERROR &RC FOR &CN&CC)\n\n\n                           GOTO CATDONE\n\n\n                           ENDO\n\n\n                                        ENDO\n\n\n                                 ELSE DO\n\n\n          STACK DDOUT(CMDOUT&FI.M) LIST\n\n\n          DEL &NAME &CP&CC CAT('&CN&CC'/&REP&CC)\n\n\n          SET &RC = &LASTCC\n\n\n          IF &RC NE 0 THEN DO\n\n\n                           SET VF = Y\n\n\n                           SET EMSG = &STR(ERROR &RC FOR &CN&CC)\n\n\n                           GOTO CATDONE\n\n\n                           ENDO\n\n\n                                      ENDO\n\n\n          GOTO CUP\n\n\n\n\n\n        /*         OPTION C  */\n\n\n        O7: +\n\n\n          IF &PASS = 1 THEN GOTO WAIT  /* NOT TIME TO DO THIS YET... */\n\n\n          STACK DDOUT(CMDOUT&FI.M) LIST\n\n\n          DEF NVSAM(NAME(&NAME) VOL(&VOL) DEVT(&DEVT) &CP&CC) CAT('&CN&CC'/&REP&\nCC)\n\n          SET &RC = &LASTCC\n\n\n          IF &RC NE 0 THEN DO\n\n\n                           SET VF = Y\n\n\n                           SET EMSG = &STR(ERROR &RC FOR &CN&CC)\n\n\n                           GOTO CATDONE\n\n\n                           ENDO\n\n\n          SET DOK = YES  /* SAY OK TO DELETE SOURCE ENTRY (FOR MF=MOVE OPT) */\n\n\n          GOTO OKLC\n\n\n\n\n\n        /*         OPTION FL  */\n\n\n        /*    SUBROUTINE TO BUILD LIST FROM CATALOG SPECIFIED:   */\n\n\n        O8: +\n\n\n          IF &PASS > 1 THEN GOTO CATDONE\n\n\n          IFALC F(BILDLIST)\n\n\n          IF &LASTCC NE 0 THEN ALLOC F(BILDLIST) NEW DELETE TRACKS SP(1 1)\n\n\n          SET CLF = OKGO /* SAY CAN DO IT */\n\n\n              OPENFILE CMDOUT&FI.M OUTPUT\n\n\n              SET CMDOUT&FI.M = &STR( TRANSFER FROM CATALOG &CN&CC)\n\n\n              PUTFILE CMDOUT&FI.M\n\n\n              CLOSFILE CMDOUT&FI.M\n\n\n              STACK DDOUT(BILDLIST)\n\n\n              LISTC ALL ENT(&NAME) CAT('&CN&CC')\n\n\n              IF &LASTCC NE 0 THEN SET CLF = NOGO /* SAY CANNOT DO IT */\n\n\n              GOTO WAIT\n\n\n\n\n\n        /*         OPTION FLL */\n\n\n        /*    SUBROUTINE TO BUILD LIST FROM CATALOG SPECIFIED:   */\n\n\n        O9: +\n\n\n          IF &PASS > 1 THEN GOTO CATDONE\n\n\n          IFALC F(BILDLIST)\n\n\n          IF &LASTCC NE 0 THEN ALLOC F(BILDLIST) NEW DELETE TRACKS SP(1 1)\n\n\n          SET CLF = OKGO /* SAY CAN DO IT */\n\n\n              OPENFILE CMDOUT&FI.M OUTPUT\n\n\n              SET CMDOUT&FI.M = &STR( TRANSFER FROM CATALOG &CN&CC)\n\n\n              PUTFILE CMDOUT&FI.M\n\n\n              CLOSFILE CMDOUT&FI.M\n\n\n              STACK DDOUT(BILDLIST)\n\n\n              LISTC ALL LVL(&NAME) CAT('&CN&CC')\n\n\n              IF &LASTCC NE 0 THEN SET CLF = NOGO /* SAY CANNOT DO IT */\n\n\n              GOTO WAIT\n\n\n\n\n\n        /*         OPTION ML  */\n\n\n        O10: +\n\n\n          IF &PASS = 1 THEN GOTO O8    /* NEED TO BUILD LIST FIRST.. */\n\n\n          IF &PASS = 2 THEN GOTO WAIT  /* NOT TIME TO DO THIS YET... */\n\n\n          OPENFILE CMDOUT&FI.M OUTPUT\n\n\n          SET CMDOUT&FI.M = &STR( MOVE FROM CATALOG &CN&CC)\n\n\n          PUTFILE CMDOUT&FI.M\n\n\n          CLOSFILE CMDOUT&FI.M\n\n\n          IF &CLF = NOGO THEN DO\n\n\n             SET EMSG = &STR(ERROR-CATALOG TRANSFER NOT SUCCESSFUL)\n\n\n             GOTO CATDONE\n\n\n             ENDO\n\n\n          IFALC F(SYSIN)\n\n\n          IF &LASTCC = 0 THEN FREE F(SYSIN)\n\n\n          IF &VF = E THEN DO\n\n\n                         %CMDOUT DDN(SYSIN) MOD\n\n\n                         SET SFN = &LASTCC\n\n\n                          ENDO\n\n\n                     ELSE +\n\n\n          ALLOC F(SYSIN) NEW DELETE               TRACKS SP(1 1) /* */\n\n\n          IF &SYSICMD = SPFCATNN THEN +\n\n\n          %SPFCATCN TYPE(U) CAT('''&CN&CC''/&REP&CC') &L\n\n\n                                 ELSE +\n\n\n          %SPFCATCC TYPE(U) CAT('''&CN&CC''/&REP&CC') &L\n\n\n          IF &LASTCC NE 0 THEN DO\n\n\n             SET EMSG = &STR(ERROR-CATALOG TRANSFER NOT SUCCESSFUL)\n\n\n             SET CLF = NOGO\n\n\n             GOTO CATDONE\n\n\n             ENDO\n\n\n          IFALC F(SYSPRINT)\n\n\n          IF &LASTCC = 0 THEN DO\n\n\n              IFALC F(SYSPRINT) DSN('&CDSN.')\n\n\n              IF &LASTCC = 0 THEN GOTO SYSPOK1\n\n\n              FREE F(SYSPRINT)\n\n\n              ENDO\n\n\n          ALLOC F(SYSPRINT) DSN('&CDSN.') MOD\n\n\n           SYSPOK1: IF &VF = E THEN DO\n\n\n                   WHATDSN DDN(SYSIN)\n\n\n                   ISPEXEC EDIT DATASET('&DSNAME')  /*  */\n\n\n                                    ENDO\n\n\n          CALL 'SYS1.LINKLIB(IDCAMS)'    /*  */\n\n\n          IF &LASTCC NE 0 THEN DO\n\n\n             SET EMSG = &STR(ERROR-CATALOG TRANSFER NOT SUCCESSFUL)\n\n\n             SET CLF = NOGO\n\n\n             IF &VF = E THEN %CMDOUT FREE(&SFN)\n\n\n             GOTO CATDONE\n\n\n             ENDO\n\n\n          IF &VF = E THEN %CMDOUT FREE(&SFN)\n\n\n          GOTO CUP\n\n\n\n\n\n\n\n\n        /*         OPTION R   */\n\n\n        O11: +\n\n\n          IF &PASS = 1 THEN GOTO WAIT  /* NOT TIME TO DO THIS YET... */\n\n\n          STACK DDOUT(CMDOUT&FI.M) LIST\n\n\n          DEL &NAME NSCR CAT('&CN&CC'/&REP&CC)\n\n\n          SET &RC = &LASTCC\n\n\n          IF &RC NE 0 THEN DO\n\n\n                           SET VF = Y\n\n\n                           SET EMSG = &STR(ERROR &RC FOR &CN&CC)\n\n\n                           GOTO CATDONE\n\n\n                           ENDO\n\n\n          RECAT: +\n\n\n          STACK DDOUT(CMDOUT&FI.M) LIST\n\n\n          DEF NVSAM(NAME(&NAME) VOL(&VOL) DEVT(&DEVT) &CP&CC) CAT('&CN&CC'/&REP&\nCC)\n\n          SET &RC = &LASTCC\n\n\n          IF &RC NE 0 THEN DO\n\n\n                           SET VF = Y\n\n\n                           SET EMSG = &STR(ERROR &RC FOR &CN&CC)\n\n\n                           GOTO CATDONE\n\n\n                           ENDO\n\n\n          GOTO OKLC\n\n\n\n\n\n        /*         OPTION MLL */\n\n\n        O12: +\n\n\n          IF &PASS = 1 THEN GOTO O9    /* NEED TO BUILD LIST FIRST.. */\n\n\n          IF &PASS = 2 THEN GOTO WAIT  /* NOT TIME TO DO THIS YET... */\n\n\n          GOTO O10\n\n\n\n\n\n        /*         OPTION RN  */\n\n\n        O13: +\n\n\n          IF &PASS = 1 THEN GOTO WAIT  /* NOT TIME TO DO THIS YET... */\n\n\n          STACK DDOUT(CMDOUT&FI.M) LIST\n\n\n          ALTER &NAME NEWNAME(&ALIAS) &CP&CC CAT('&CN&CC'/&REP&CC)\n\n\n          SET &RC = &LASTCC\n\n\n          IF &RC NE 0 THEN DO\n\n\n                           SET VF = Y\n\n\n                           SET EMSG = &STR(ERROR &RC FOR &CN&CC)\n\n\n                           GOTO CATDONE\n\n\n                           ENDO\n\n\n          STACK DDOUT(CMDOUT&FI.M) LIST\n\n\n          LISTC ALL ENT(&ALIAS) CAT('&CN&CC'/&REP&CC)\n\n\n          GOTO CUP\n\n\n\n\n\n        /*         OPTION CL  */\n\n\n        O14: +\n\n\n          IF &PASS = 1 THEN GOTO WAIT  /* NOT TIME TO DO THIS YET... */\n\n\n          OPENFILE CMDOUT&FI.M OUTPUT\n\n\n          SET CMDOUT&FI.M = &STR( TRANSFER TO CATALOG &CN&CC)\n\n\n          PUTFILE CMDOUT&FI.M\n\n\n          CLOSFILE CMDOUT&FI.M\n\n\n          IF &CLF = NOGO THEN DO\n\n\n             SET EMSG = &STR(ERROR-CATALOG TRANSFER NOT SUCCESSFUL)\n\n\n             GOTO CATDONE\n\n\n             ENDO\n\n\n          IFALC F(SYSIN)\n\n\n          IF &LASTCC = 0 THEN FREE F(SYSIN)\n\n\n          IF &VF = E THEN DO\n\n\n                         %CMDOUT DDN(SYSIN) MOD\n\n\n                         SET SFN = &LASTCC\n\n\n                          ENDO\n\n\n                     ELSE +\n\n\n          ALLOC F(SYSIN) NEW DELETE               TRACKS SP(1 1) /* */\n\n\n          IF &SYSICMD = SPFCATNN THEN +\n\n\n          %SPFCATCN CAT('''&CN&CC''/&REP&CC') &L\n\n\n                                 ELSE +\n\n\n          %SPFCATCC CAT('''&CN&CC''/&REP&CC') &L\n\n\n          IF &LASTCC NE 0 THEN DO\n\n\n             SET EMSG = &STR(ERROR-CATALOG TRANSFER NOT SUCCESSFUL)\n\n\n             SET CLF = NOGO\n\n\n             GOTO CATDONE\n\n\n             ENDO\n\n\n          IFALC F(SYSPRINT)\n\n\n          IF &LASTCC = 0 THEN DO\n\n\n              IFALC F(SYSPRINT) DSN('&CDSN.')\n\n\n              IF &LASTCC = 0 THEN GOTO SYSPOK\n\n\n              FREE F(SYSPRINT)\n\n\n              ENDO\n\n\n          ALLOC F(SYSPRINT) DSN('&CDSN.') MOD\n\n\n           SYSPOK: IF &VF = E THEN DO\n\n\n                   WHATDSN DDN(SYSIN)\n\n\n                   ISPEXEC EDIT DATASET('&DSNAME')  /*  */\n\n\n                                   ENDO\n\n\n          CALL 'SYS1.LINKLIB(IDCAMS)'    /*  */\n\n\n          IF &LASTCC NE 0 THEN DO\n\n\n             SET EMSG = &STR(ERROR-CATALOG TRANSFER NOT SUCCESSFUL)\n\n\n             SET CLF = NOGO\n\n\n             IF &VF = E THEN %CMDOUT FREE(&SFN)\n\n\n             GOTO CATDONE\n\n\n             ENDO\n\n\n          IF &VF = E THEN %CMDOUT FREE(&SFN)\n\n\n          GOTO CUP\n\n\n\n\n\n        /*         OPTION ULL */\n\n\n        O15: +\n\n\n          IF &PASS = 1 THEN GOTO O9    /* NEED TO BUILD LIST FIRST.. */\n\n\n          IF &PASS = 2 THEN GOTO WAIT  /* NOT TIME TO DO THIS YET... */\n\n\n          GOTO O10\n\n\n\n\n\n        /*         OPTION G   */\n\n\n        O17: +\n\n\n          IF &PASS = 1 THEN GOTO WAIT  /* NOT TIME TO DO THIS YET... */\n\n\n          IF &CP&CC = &STR() THEN SET &CP&CC = SCR\n\n\n          STACK DDOUT(CMDOUT&FI.M) LIST\n\n\n          DEF GDG(NAME(&NAME) LIM(&VOL) &CP&CC) CAT('&CN&CC'/&REP&CC)\n\n\n          SET &RC = &LASTCC\n\n\n          IF &CP&CC = &STR(SCR) THEN SET &CP&CC = &STR()\n\n\n          IF &RC NE 0 THEN DO\n\n\n                           SET VF = Y\n\n\n                           SET EMSG = &STR(ERROR &RC FOR &CN&CC)\n\n\n                           GOTO CATDONE\n\n\n                           ENDO\n\n\n          GOTO OKLC\n\n\n\n\n\n        /*         OPTION K   */\n\n\n        O18: +\n\n\n          IF &PASS = 1 THEN GOTO WAIT  /* NOT TIME TO DO THIS YET... */\n\n\n          IF &PASS = 2 THEN GOTO WAIT  /* NOT TIME TO DO THIS YET... */\n\n\n          SET DSLIST = &STR(&NAME)\n\n\n          SET FCAT = &STR('&CN&CC'/&REP&CC)\n\n\n          ISPEXEC VPUT (DSLIST FCAT) SHARED\n\n\n          %FLIST\n\n\n          SET VF = N\n\n\n          GOTO CATDONE\n\n\n\n\n\n        /*         OPTION F   */\n\n\n             /* IF SPECIFIED, GET VOL FROM CAT GIVEN :       */\n\n\n        O19: +\n\n\n           IF &PASS > 1 THEN GOTO CATDONE\n\n\n           %CATGET &NAME '&CN&CC.'\n\n\n           IF &GCRC NE 0 THEN DO\n\n\n              SET EMSG = &STR(ERROR &GCRC FROM CATGET)\n\n\n              SET CDCUR = CO&CC\n\n\n              GOTO MAINLOOP\n\n\n                              ENDO\n\n\n           SET &VOL = &GCVOL\n\n\n           SET &DEVT = &STR(&GCDEVT)\n\n\n           GOTO WAIT\n\n\n\n\n\n        /*         OPTION M(MODIFY=ALTER)  */\n\n\n        O20: +\n\n\n          IF &PASS = 1 THEN GOTO WAIT  /* NOT TIME TO DO THIS YET... */\n\n\n          STACK DDOUT(CMDOUT&FI.M) LIST\n\n\n          ALTER &NAME &CP&CC CAT('&CN&CC'/&REP&CC)\n\n\n          SET &RC = &LASTCC\n\n\n          IF &RC NE 0 THEN DO\n\n\n                           SET VF = Y\n\n\n                           SET EMSG = &STR(ERROR &RC FOR &CN&CC)\n\n\n                           GOTO CATDONE\n\n\n                           ENDO\n\n\n          STACK DDOUT(CMDOUT&FI.M) LIST\n\n\n          LISTC ALL ENT(&NAME) CAT('&CN&CC'/&REP&CC)\n\n\n          GOTO CUP\n\n\n\n\n\n        /*         OPTION MF  */\n\n\n        O23: +\n\n\n          IF &PASS = 1 THEN GOTO O19\n\n\n          IF &PASS = 2 THEN GOTO WAIT\n\n\n          IF &DOK = YES THEN GOTO O4\n\n\n           SET VF = Y\n\n\n           SET EMSG = &STR(ERROR-MOVE BYPASSED FOR &CN&CC)\n\n\n           GOTO CATDONE\n\n\n./ ADD NAME=SPFEOPT  0107-84270-89145-1604-00014-00003-00012-LL02155\n00010000PROC 1 PREPO\n\n\n00011003CONTROL NOFLUSH END(ENDO)\n\n\n00020001IF &PREPO EQ YES THEN +\n\n\n00040000ISPEXEC SELECT PGM(NEWMWILE) PARM(1)\n\n\n00050001IF &PREPO EQ NO  THEN +\n\n\n00060001ISPEXEC SELECT PGM(NEWMWILE) PARM(2)\n\n\n00340002ISPEXEC CONTROL SPLIT DISABLE\n\n\n00350002IF &LASTCC = 8 THEN DO\n\n\n00360002     SET &GPM = SPLIT SCREEN WARNING\n\n\n00370002     SET &GPML = ENVIRONMENTAL CHANGES MAY BE INVALID IN SPLIT SCREEN.\n\n\n00380002     ISPEXEC SETMSG MSG(GPM001)\n\n\n00390002     EXIT\n\n\n00400002                    ENDO\n\n\n00401002ISPEXEC CONTROL SPLIT ENABLE\n\n\n./ ADD NAME=SPFXL    0100-84214-84214-1136-00004-00004-00000-KK00150\n00010000CONTROL NOFLUSH\n\n\n00020000ISPEXEC CONTROL SPLIT DISABLE\n\n\n00030000IF &LASTCC NE 8 THEN ISPEXEC SELECT PGM(WDPSCXS) PARM(LOGOFF)\n\n\n00040000ISPEXEC CONTROL SPLIT ENABLE\n\n\n./ ADD NAME=SPFYFND  0109-86069-87314-1126-00198-00189-00016-LL02155\n00010000         CONTROL NOMSG NOFLUSH END(ENDO)\n\n\n00010205\n\n\n00011006         PROF MSGID\n\n\n00020003\n\n\n00030000         SET &FNDSERR = &STR(SPFYFND ERROR F01)\n\n\n00040000         ISPEXEC VPUT FNDSERR SHARED\n\n\n00050000\n\n\n00051000         ISPEXEC VGET FNDSDSN SHARED\n\n\n00051100         SET &RC = &LASTCC\n\n\n00051200\n\n\n00051300         IF &RC NE 0 THEN DO\n\n\n00051400            SET &FNDSERR = &STR(SPFYFND ERROR F02)\n\n\n00051500            ISPEXEC VPUT FNDSERR SHARED\n\n\n00051600            GOTO ENDIT\n\n\n00051700            ENDO\n\n\n00051800\n\n\n00051900         ISPEXEC VGET FNDSRCH SHARED\n\n\n00052000         SET &RC = &LASTCC\n\n\n00052100\n\n\n00052200         IF &RC NE 0 THEN DO\n\n\n00052300            SET &FNDSERR = &STR(SPFYFND ERROR F03)\n\n\n00052400            ISPEXEC VPUT FNDSERR SHARED\n\n\n00052500            GOTO ENDIT\n\n\n00052600            ENDO\n\n\n00052700\n\n\n00052800         IF &SYSUID = &SYSPREF THEN SET &HILEVEL = &SYSPREF\n\n\n00052900            ELSE SET &HILEVEL = &SYSPREF..&SYSUID\n\n\n00053000\n\n\n00540000/*                                                   */\n\n\n00550000/*  ALLOCATE DSNAME = HILEVEL..SPFYFND.CMDIN1        */\n\n\n00560000/*                                                   */\n\n\n00561000\n\n\n00570000         CONTROL NOMSG\n\n\n00580000         FREE F(CMDIN1)\n\n\n00590000         FREE ATTRLIST(AT1)\n\n\n00600000         ATTR AT1 RECFM(F,B) LRECL(80) BLKSIZE(800)\n\n\n00610000         ERROR DO\n\n\n00620000              CONTROL MSG\n\n\n00630000              ALLOC F(CMDIN1) DSN('&HILEVEL..SPFYFND.CMDIN1') NEW -\n\n\n00640000              SPACE(1,1) TRACKS UNIT(SYSDA) USING(AT1)\n\n\n00650000              ERROR OFF\n\n\n00660000              GOTO T2\n\n\n00670000              ENDO\n\n\n00680000         ALLOC F(CMDIN1) DA('&HILEVEL..SPFYFND.CMDIN1') SHR\n\n\n00690000         ERROR OFF\n\n\n00691000\n\n\n00700000/*                                                   */\n\n\n00710000/*  ALLOCATE DSNAME = HILEVEL..SPFYFND.CMDOUT1 */\n\n\n00720000/*                                                   */\n\n\n00721000\n\n\n00730000T2:      CONTROL NOMSG\n\n\n00740000         FREE F(CMDOUT1)\n\n\n00750000         FREE ATTRLIST(AT2)\n\n\n00760000         ATTR AT2 RECFM(F,B) LRECL(80) BLKSIZE(6160)\n\n\n00770000         ERROR DO\n\n\n00780000              CONTROL MSG\n\n\n00790000              ALLOC F(CMDOUT1) DSN('&HILEVEL..SPFYFND.CMDOUT1') NEW -\n\n\n00800000              SPACE(1,1) TRACKS UNIT(SYSDA) USING(AT2)\n\n\n00810000              ERROR OFF\n\n\n00820000              GOTO T3\n\n\n00830000              ENDO\n\n\n00840000         ALLOC F(CMDOUT1) DA('&HILEVEL..SPFYFND.CMDOUT1') SHR\n\n\n00850000         ERROR OFF\n\n\n01539300\n\n\n01560000T3:      OPENFILE CMDIN1 OUTPUT\n\n\n01570000         SET &CMDIN1 = &STR(PDS '&FNDSDSN' ATTRIB :)\n\n\n01580000         PUTFILE CMDIN1\n\n\n01630000         CLOSFILE CMDIN1\n\n\n01631000\n\n\n01640000/*                                                      */\n\n\n01650000/*       I N T E R C E P T   O U T P U T   O F          */\n\n\n01660000/*                                                      */\n\n\n01670000/*       T H E   P D S   C O M M A N D                  */\n\n\n01680000/*                                                      */\n\n\n01681000\n\n\n01690000STACKT1: CONTROL MAIN\n\n\n01700000         STACK LIST DDIN(CMDIN1) DDOUT(CMDOUT1)\n\n\n01712000\n\n\n01712100         CONTROL NOMSG\n\n\n01712200\n\n\n01712300         SET &SPFYSRCH = &STR(&FNDSRCH)\n\n\n01713000         ISPEXEC VPUT SPFYSRCH SHARED\n\n\n01714000         SET &SPFYSLEN = &LENGTH(&STR(&SPFYSRCH))\n\n\n01715000         SET &SPFYSLEN = &SPFYSLEN + 100\n\n\n01716000         SET &SPFYSLEN = &SUBSTR(2:3,&STR(&SPFYSLEN))\n\n\n01716100         ISPEXEC VPUT SPFYSLEN SHARED\n\n\n01716200\n\n\n01716300         FREE F(CMDIN1)\n\n\n01716500         FREE F(OUTFILE)\n\n\n01716600         FREE ATTRLIST(ATTR1)\n\n\n01716700         ATTR ATTR1 RECFM(F,B) LRECL(80) BLKSIZE(6160)\n\n\n01716800         ALLOC F(OUTFILE) NEW UNIT(SYSSQ) TRACKS SPACE(9,4) USING(ATTR1)\n\n\n01716900\n\n\n01717009         ISPEXEC SELECT PGM(SPFYFND5)\n\n\n01718000\n\n\n02120000         ISPEXEC TBCREATE SPFYFND NAMES(TYPCODE SPFSTATS) NOWRITE\n\n\n02130000         SET &RC = &LASTCC\n\n\n02140000\n\n\n02150000         IF &RC NE 0 THEN DO\n\n\n02160000              SET &FNDSERR = &STR(SPFYFND ERROR F04)\n\n\n02170000              ISPEXEC VPUT FNDSERR SHARED\n\n\n02180000              GOTO ENDIT\n\n\n02190000              ENDO\n\n\n02260000\n\n\n02270000         OPENFILE OUTFILE INPUT\n\n\n02280000\n\n\n02290000         SET &CTR = 0\n\n\n02300000\n\n\n02310000LOOP:    ERROR DO\n\n\n02320000              SET &RC = &LASTCC\n\n\n02330000              IF &RC = 400 THEN GOTO CLOS\n\n\n02340000              SET &FNDSERR = &STR(SPFYFND ERROR F05)\n\n\n02350000              ISPEXEC VPUT FNDSERR SHARED\n\n\n02360000              GOTO CLOS\n\n\n02370000              ENDO\n\n\n02380000\n\n\n02390000         GETFILE OUTFILE\n\n\n02400000         ERROR OFF\n\n\n02410000         SET &BUFFER = &STR(&OUTFILE)\n\n\n02420000\n\n\n02430000         SET &TYPCODE = &STR(_)\n\n\n02441000         SET &SPFSTATS = &STR(&BUFFER)\n\n\n02450000\n\n\n02460000         ISPEXEC TBADD SPFYFND\n\n\n02470000         SET &RC = &LASTCC\n\n\n02480000         IF &RC NE 0 THEN DO\n\n\n02490000              SET &FNDSERR = &STR(SPFYFND ERROR F06)\n\n\n02500000              ISPEXEC VPUT FNDSERR SHARED\n\n\n02510000              GOTO ENDIT\n\n\n02520000              ENDO\n\n\n02530000\n\n\n02540000         SET &CTR = &CTR + 1\n\n\n02550000         GOTO LOOP\n\n\n02560000\n\n\n02570000CLOS:    ERROR OFF\n\n\n02580000         CLOSFILE OUTFILE\n\n\n02590000\n\n\n02600000         IF &CTR = 0 THEN DO\n\n\n02610000              SET &FNDSERR = &STR(NO HITS FOUND)\n\n\n02620000              ISPEXEC VPUT FNDSERR SHARED\n\n\n02630000              GOTO ENDIT\n\n\n02640000              ENDO\n\n\n02650000\n\n\n02660000         ISPEXEC TBTOP SPFYFND\n\n\n02670000         SET &MSGID = &STR(FNDS100)\n\n\n02680000\n\n\n02690000DSPANEL: ISPEXEC TBDISPL SPFYFND PANEL(SPFYFND2) MSG(&MSGID)\n\n\n02700000         SET &RC = &LASTCC\n\n\n02710000\n\n\n02720000         IF &RC NE 0 THEN DO\n\n\n02730000              SET &FNDSERR = &STR(NO ERROR ENCOUNTERED)\n\n\n02740000              ISPEXEC VPUT FNDSERR SHARED\n\n\n02750000              GOTO ENDIT\n\n\n02760000              ENDO\n\n\n02770000\n\n\n02780000         ERROR DO\n\n\n02790000              ERROR OFF\n\n\n02800000              SET &MSGID = &STR(FNDS101)\n\n\n02810000              GOTO DSPANEL\n\n\n02820000              ENDO\n\n\n02830000\n\n\n02840000         IF &TYPCODE = &STR(S) OR +\n\n\n02850000            &TYPCODE = &STR(E) THEN DO\n\n\n02860000               SET &SERVICE = &STR(EDIT)\n\n\n02870000               GOTO DOIT\n\n\n02880000               ENDO\n\n\n02890000\n\n\n02900000         IF &TYPCODE = &STR(B) THEN DO\n\n\n02910000               SET &SERVICE = &STR(BROWSE)\n\n\n02920000               GOTO DOIT\n\n\n02930000               ENDO\n\n\n02940000\n\n\n02950000         ERROR OFF\n\n\n02960000\n\n\n02970000         SET &MSGID = &STR(FNDS101)\n\n\n02980000         GOTO DSPANEL\n\n\n02990000\n\n\n03000000DOIT:    ERROR OFF\n\n\n03001000         SET &DAMEMBER = &STR(&SUBSTR(1:8,&STR(&SPFSTATS))\n\n\n03010000         SET &THEMEMBR = &SUBSTR(1:&LENGTH(&DAMEMBER),&DAMEMBER)\n\n\n03020000\n\n\n03021001         IF &SERVICE = BROWSE THEN ISPEXEC CONTROL ERRORS RETURN\n\n\n03030000         ISPEXEC &SERVICE DATASET('&FNDSDSN(&THEMEMBR)')\n\n\n03040001         SET &SERVRC = &LASTCC\n\n\n03040101         IF &SERVICE NE BROWSE THEN GOTO SETTMSG\n\n\n03041101         IF &SERVRC NE 0 THEN DO\n\n\n03041201               SET &MSGID = &STR(FNDS102)\n\n\n03041301               ISPEXEC CONTROL ERRORS CANCEL\n\n\n03041401               GOTO DSPANEL\n\n\n03041501               ENDO\n\n\n03041601\n\n\n03042001         ISPEXEC CONTROL ERRORS CANCEL\n\n\n03044001\n\n\n03050001SETTMSG: SET &MSGID = &STR(FNDS100)\n\n\n03060000         GOTO DSPANEL\n\n\n03070000\n\n\n03080000ENDIT:   ISPEXEC TBEND SPFYFND\n\n\n03090000         EXIT\n\n\n./ ADD NAME=STATUS   0100-87118-87118-1947-00094-00094-00000-KX00150\n00000100PROC 1 JOB L SHOWIT\n\n\n00001000/*                                                            */\n\n\n00002000/* THIS IS THE STATUS CLIST WHICH INTERFACES SMPE TO IOF      */\n\n\n00003000/* COPY THE SMPEIOF PROGRAM TO THE SMPE DIALOG LOADLIB        */\n\n\n00004000/* WITH NAME STATUS TO INTERCEPT THE SMPE LINK TO TSO STATUS. */\n\n\n00005000/* THE PANLEXIT ROUTINE IS ALSO HELPFUL TO SUPPRESS GIMOT004  */\n\n\n00005100/*                                                            */\n\n\n00006000/* ADD THE FOLLOWING TO THE VIOFPCM PANEL    */\n\n\n00007000/*  OF IOF (IN THE BOTTOM OF INIT SECTION):  */\n\n\n00007100/*                                           */\n\n\n00008000/* IF (&PJOBN \u00ac= &Z)                         */\n\n\n00009000/*   &PJOBN = TRUNC(&PJOBN,'(')              */\n\n\n00009100/*   &PJOBI = .TRAIL                         */\n\n\n00009200/*   &PJOBI = TRUNC(&PJOBI,')')              */\n\n\n00009300/*   IF (&PJOBI \u00ac= &Z)                       */\n\n\n00009400/*     .RESP = ENTER                         */\n\n\n00009500/*       &XXX = END                          */\n\n\n00009600/*IF (&XXX \u00ac= &Z)                            */\n\n\n00009700/*  .RESP = &XXX                             */\n\n\n00009800/*                                           */\n\n\n00009900/* CHANGE THE FOLLOWING IN THE GIMSM PANEL   */\n\n\n00010000/*  OF SMPE (OPTIONAL TO SUPPRESS ERR MSG):  */\n\n\n00010100/*                                           */\n\n\n00010200/*     1,'PGM(PANLEXIT) PARM(GIMPDV)'        */\n\n\n00010400/*                                           */\n\n\n00010500/* ADD THE FOLLOWING TO THE GIMPDJNF PANEL   */\n\n\n00010600/*  OF SMPE (IN THE BODY AND INIT SECTIONS): */\n\n\n00010700/*\n            */\n\n00010800/*%                             &K1\n            */\n\n00010900/*+&K2\n            */\n\n00011000/*+&K3\n            */\n\n00011100/*&K1 = 'OUTPUT NOT AVAILABLE'\n            */\n\n00011200/*&K2 = 'THE OUTPUT OF THE LAST JOB &GGPSJOBN(&GGPSJOBI) SUBMITTED BY TH\nIS DIALOG'  */\n\n00011300/*&K3 = 'CANNOT BE PROCESSED BECAUSE OF THE ABOVE REASON.'\n            */\n\n00011400/*IF (&KSMPREAL \u00ac= &Z)\n            */\n\n00011500/*   &K1 = 'INDICATE JOB RESULTS'\n            */\n\n00011600/*   &K2 = 'CHOOSE ONE OF THE OPTIONS BELOW ACCORDING TO THE RESULTS OF'\n            */\n\n00011700/*   &K3 = 'JOB &GGPSJOBN(&GGPSJOBI)'\n            */\n\n00011800/*   &GPML = ' '\n            */\n\n00011900/*   &PANLEXIT = 'SETMSG MSG(GPM002)'\n            */\n\n00012000/*\n            */\n\n00012100CONTROL END(ENDO) NOMSG\n\n\n00012200IF &L = L THEN CONTROL END(ENDO) LIST MSG CONLIST\n\n\n00012300IF &SHOWIT = SHOWIT THEN +\n\n\n00012400  DO\n\n\n00012500  SET VIOFJOBN = &JOB\n\n\n00012600  ISPEXEC VPUT (VIOFJOBN) SHARED\n\n\n00012700  IF &L NE L THEN +\n\n\n00012800    ISPEXEC SELECT PGM(CLRSPFIO)\n\n\n00012900  ISPEXEC SELECT PGM(IOFSPF) PARM(I.)\n\n\n00013000  EXIT\n\n\n00013100  ENDO\n\n\n00013200ISPEXEC CONTROL DISPLAY LINE START(17)\n\n\n00014000WRITE CHECKING INPUT QUEUE\n\n\n00080000IOF &JOB CLIST I\n\n\n00090000SET IRC2 = &LASTCC\n\n\n00100000IF &IRC2 = 0 THEN +\n\n\n00110000  DO\n\n\n00111000  END\n\n\n00112000  END\n\n\n00120000  SET KSMPSTAT = IKJ56197I JOB &JOB WAITING FOR EXECUTION\n\n\n00130000  ISPEXEC VPUT KSMPSTAT SHARED\n\n\n00130100  ISPEXEC SELECT PGM(CLRSPFIO)\n\n\n00131000  EXIT\n\n\n00140000  ENDO\n\n\n00141000WRITE CHECKING EXECUTION QUEUE\n\n\n00150000IOF &JOB CLIST R\n\n\n00160000SET IRC3 = &LASTCC\n\n\n00170000IF &IRC3 = 0 THEN +\n\n\n00180000  DO\n\n\n00190000  END\n\n\n00200000  END\n\n\n00210000  SET KSMPSTAT = IKJ56211I JOB &JOB EXECUTING\n\n\n00220000  ISPEXEC VPUT KSMPSTAT SHARED\n\n\n00220100  ISPEXEC SELECT PGM(CLRSPFIO)\n\n\n00221000  EXIT\n\n\n00230000  ENDO\n\n\n00230200WRITE CHECKING OUTPUT QUEUE\n\n\n00231000SET KSMPREAL = ITSTHERE\n\n\n00231100SET KSMPSTAT = IKJ56202I JOB &JOB NOT FOUND\n\n\n00232000ISPEXEC VPUT (KSMPSTAT KSMPREAL) SHARED\n\n\n00240000IOF &JOB CLIST\n\n\n00250000SET IRC1 = &LASTCC\n\n\n00260000IF &IRC1 = 1503 THEN +\n\n\n00270000  DO\n\n\n00271000  SET KSMPREAL =\n\n\n00280000  SET KSMPSTAT = IKJ56202I JOB &JOB NOT FOUND\n\n\n00290000  ISPEXEC VPUT (KSMPSTAT KSMPREAL) SHARED\n\n\n00291000  ISPEXEC SELECT PGM(CLRSPFIO)\n\n\n00300000  ENDO\n\n\n00301000END\n\n\n00302000END\n\n\n00312100/* NOW CHANGE APPLID TO CALL IOF ALLOWING SPLIT SCREEN  */\n\n\n00313000ISPEXEC SELECT CMD(%STATUS &JOB SHOWIT) NEWAPPL(IOF)\n\n\n./ ADD NAME=STRIP    0133-86251-86266-1316-00065-00046-00000-CG00150\n        PROC 0\n\n\n        /*clist**************************************************\n\n\n        /* STRIP will strip all leading and/or trailing blanks  *\n\n\n        /* FROM A STRING.  THE PARM VARIABLE SPECIFIES THE      *\n\n\n        /* END(S) OF A STRING TO BE STRIPPED OF BLANKS.  THE    *\n\n\n        /* PARM variable may be L (leading), T (trailing), or B *\n\n\n        /* (both).  STRING and PARM must be passed to strip by  *\n\n\n        /* the statement ISPEXEC VPUT (STRING,PARM) SHARED.  A  *\n\n\n        /* variable STRSIZE will be created and passed back in  *\n\n\n        /* place of PARM, which will contain the length of the  *\n\n\n        /* string after stripping is complete.                  *\n\n\n        /********************************************************\n\n\n        CONTROL NOMSG\n\n\n        /*CONTROL LIST CONLIST SYMLIST\n\n\n\n\n\n        GETMY SYSID\n\n\n        IF &SYSID = H3AN THEN SET TYPSTR = &&STR\n\n\n        IF &SYSID NE H3AN THEN SET TYPSTR = &&NRSTR\n\n\n\n\n\n        ISPEXEC VGET (STRING,PARM) SHARED\n\n\n        SET STRSIZE  = &LENGTH(&TYPSTR(&STRING))\n\n\n  /*cg  SET STRSIZE  = &LENGTH(&STR(&STRING))\n\n\n        SET FRSTCHAR = 1\n\n\n        SET LASTCHAR = &STRSIZE\n\n\n\n\n\n        IF &PARM = &STR(L) OR &PARM = &STR(B) THEN +\n\n\n          DO\n\n\n            /* STRIP OUT LEADING BLANKS */\n\n\n            SET &CHAR = &SUBSTR(1,&TYPSTR(&STRING))\n\n\n    /*cg    SET &CHAR = &SUBSTR(1,&STRING)\n\n\n            SET &CHARPOS = 1\n\n\n            DO WHILE &TYPSTR(&CHAR) = &STR( ) AND &CHARPOS < &STRSIZE\n\n\n       /*cg DO WHILE &STR(&CHAR) = &STR( ) AND &CHARPOS < &STRSIZE\n\n\n              SET CHARPOS = &CHARPOS+1\n\n\n              SET &CHAR = &SUBSTR(&CHARPOS,&TYPSTR(&STRING))\n\n\n      /*cg    SET &CHAR = &SUBSTR(&CHARPOS,&STRING)\n\n\n            END\n\n\n            SET FRSTCHAR = &CHARPOS\n\n\n          END\n\n\n\n\n\n        IF &PARM = &STR(T) OR &PARM = &STR(B) THEN +\n\n\n          DO\n\n\n            /* STRIP OUT TRAILING BLANKS */\n\n\n            SET &CHAR = &SUBSTR(&STRSIZE,&TYPSTR(&STRING))\n\n\n /*cg       SET &CHAR = &SUBSTR(&STRSIZE,&STRING)\n\n\n            SET &CHARPOS = &STRSIZE\n\n\n            DO WHILE &TYPSTR(&CHAR) = &STR( ) AND &CHARPOS > 1\n\n\n   /*cg     DO WHILE &STR(&CHAR) = &STR( ) AND &CHARPOS > 1\n\n\n              SET CHARPOS = &CHARPOS-1\n\n\n              SET &CHAR = &SUBSTR(&CHARPOS,&TYPSTR(&STRING))\n\n\n   /*cg       SET &CHAR = &SUBSTR(&CHARPOS,&STRING)\n\n\n            END\n\n\n            SET LASTCHAR = &CHARPOS\n\n\n          END\n\n\n\n\n\n        /* EXTRACT THE STRIPPED STRING */\n\n\n        IF &LENGTH(&TYPSTR(&STRING)) = 0 THEN EXIT   /*CLIFF\n\n\n  /*cg  IF &LENGTH(&STR(&STRING))  = 0 THEN EXIT   /*CLIFF\n\n\n        SET STRING  = &SUBSTR(&FRSTCHAR:&LASTCHAR,&TYPSTR(&STRING))\n\n\n  /*cg  SET STRING  = &SUBSTR(&FRSTCHAR:&LASTCHAR,&STRING)\n\n\n        SET STRSIZE = &LENGTH(&TYPSTR(&STRING))\n\n\n  /*cg  SET STRSIZE = &LENGTH(&STR(&STRING))\n\n\n\n\n\n        ISPEXEC VPUT (STRING,STRSIZE) SHARED\n\n\n        EXIT\n\n\n./ ADD NAME=UNCLIB   0106-81209-85137-1437-00050-00044-00000-JS02150\n                PROC 1 DSN PRINT()\n\n\n                CONTROL NOMSG NOFLUSH END(ENDO)\n\n\n\n\n\n                ERROR OFF\n\n\n\n\n\n                FILEINFO DSN(&STR(&DSN))\n\n\n                SET &RC = &LASTCC\n\n\n\n\n\n                IF &RC EQ 96 THEN DO\n\n\n                    WRITE\n\n\n                    WRITE ERROR ===> INVALID SYNTAX OF DSNAME\n\n\n                    GOTO ENDIT\n\n\n                    ENDO\n\n\n\n\n\n                IF &RC NE 0 THEN DO\n\n\n                    WRITE\n\n\n                    WRITE ERROR ===> &OUTMSG\n\n\n                    GOTO ENDIT\n\n\n                    ENDO\n\n\n\n\n\n                IF &DSORG NE PO THEN DO\n\n\n                    WRITE\n\n\n                    WRITE ERROR ===> DATASET TO BE CONCATENATED IS NOT\n\n\n                    WRITE            PARTITIONED DATASET\n\n\n                    GOTO ENDIT\n\n\n                    ENDO\n\n\n\n\n\n                IF &MEMCNTL EQ YES THEN DO\n\n\n                    WRITE\n\n\n                    WRITE ERROR ===> DO NOT PROVIDE MEMBER NAME\n\n\n                    GOTO ENDIT\n\n\n                    ENDO\n\n\n\n\n\n                IF &RECFM NE V THEN DO\n\n\n                    WRITE\n\n\n                    WRITE ERROR ===> &FULLDSN MUST CONTAIN\n\n\n                    WRITE            VARIABLE LENGTH RECORDS\n\n\n                    GOTO ENDIT\n\n\n                    ENDO\n\n\n\n\n\n                CONCATEM ACTCODE(D) DDNAME(SYSPROC) DSNAME('&FULLDSN')\n\n\n                SET &RC = &LASTCC\n\n\n\n\n\n                IF &PRINT = NO THEN GOTO ENDIT\n\n\n\n\n\n                WRITE\n\n\n                WRITE &OUTMSG\n\n\n                WRITE        (RETURN CODE = &RC)\n\n\n\n\n\n         ENDIT: EXIT\n\n\n./ ADD NAME=UNNUM    0104-77018-78214-0931-00014-00015-00011-KK00150\n00000100PROC 1 DSN\n\n\n00000200CONTROL NOMSG MAIN END(ENDO)\n\n\n00000400FREE F(INOUT)\n\n\n00000502CONTROL MSG\n\n\n00000602ALLOC F(INOUT) DA(&DSN.)\n\n\n00000702OPENFILE INOUT UPDATE\n\n\n00000903ERROR DO\n\n\n00001003       CLOSFILE INOUT\n\n\n00001103       EXIT\n\n\n00001203      ENDO\n\n\n00001303LOOP: GETFILE INOUT\n\n\n00001403SET INOUT = &SUBSTR(9:&LENGTH(&INOUT.),&INOUT.)\n\n\n00001503PUTFILE INOUT\n\n\n00001603GOTO LOOP\n\n\n./ ADD NAME=VSSE     0104-85206-85280-1432-00038-00036-00004-KK00150\n00010004PROC 0 SS(USER.TSO.GDDM.SYMBOLS) L NC VOL(NONE) SSN(ADMDVSS) F\n\n\n00020000CONTROL NOFLUSH END(ENDO) NOMSG\n\n\n00030000IF &L = L THEN CONTROL MSG LIST CONLIST\n\n\n00031002IF &SYSPROC = TEST AND &SS EQ &STR(USER.TSO.GDDMR3.SYMBOLS) THEN +\n\n\n00032004   SET &SS = &STR(USER.TSO.GDDM.SYMBOLS)\n\n\n00040000IF &F = F THEN FREE F(ADMSYMBL)\n\n\n00080000IFALC F(ADMSYMBL) DA(&SS)\n\n\n00090000IF &LASTCC = 0 THEN GOTO CALLM\n\n\n00091000IFALC F(ADMSYMBL) DA('&SS')\n\n\n00092000IF &LASTCC = 0 THEN GOTO CALLM\n\n\n00100000IFALC F(ADMSYMBL)\n\n\n00101000IF &LASTCC = 0 THEN FREE F(ADMSYMBL)\n\n\n00450000DATASTAT &SS\n\n\n00451000IF &LASTCC NE 0 THEN DO\n\n\n00452000       DATASTAT '&SS'\n\n\n00452100       SET DRC = &LASTCC\n\n\n00453000       IF &DRC    NE 0 THEN DO\n\n\n00453100          WRITE DATASTAT RC IS &DRC\n\n\n00453200          WRITE SYMBOL SET LIBRARY CANNOT BE ALLOCATED : &SS\n\n\n00453300          WRITE PLEASE CHECK YOUR SS NAME.\n\n\n00453400          EXIT\n\n\n00454000                            ENDO\n\n\n00455000       SET &SS = &STR('&SS')\n\n\n00456000                     ENDO\n\n\n00460000ALLOC F(ADMSYMBL) DA(&SS)\n\n\n00460100       SET ARC = &LASTCC\n\n\n00461000       IF &ARC    NE 0 THEN DO\n\n\n00461100          WRITE ALLOC RC IS &ARC\n\n\n00462000          WRITE SYMBOL SET LIBRARY CANNOT BE ALLOCATED :\n\n\n00463000          WRITE PLEASE CHECK YOUR SS NAME.\n\n\n00464000          EXIT\n\n\n00465000                            ENDO\n\n\n00630000CALLM: +\n\n\n00631000  IF &NC = NC THEN EXIT\n\n\n00640002  IF &SYSPROC = TEST THEN +\n\n\n00650000               CALL 'WDPSC.GDDMR4.GDDMLOAD(ADMVSSE)' '&SSN'\n\n\n00661000                     ELSE +\n\n\n00670000               CALL 'WDPSC.GDDM.GDDMLOAD(ADMVSSE)' '&SSN'\n\n\n./ ADD NAME=WATDSN   0113-80276-85113-1616-00008-00007-00000-JS02150\n                PROC 1 DDNAME\n\n\n                CONTROL NOFLUSH NOMSG END(ENDO)\n\n\n                FREE F(SYSOUT)\n\n\n                ALLOC F(SYSOUT) DSN(*)\n\n\n                WRITE\n\n\n                IF &LENGTH(&STR(&DDNAME)) LT 8 THEN +\n\n\n                    SET &DDNAME = &STR(&DDNAME&SUBSTR(1:8-&LENGTH(&DDNAME),\n    )\n\n                CALL 'WDPSC.SHARED.LOAD(WATDSN)' '&STR(&DDNAME)'\n\n\n./ ADD NAME=WHOISI   0127-81238-87071-1503-00031-00034-00031-LS02150\n00010015            CONTROL NOMSG NOFLUSH END(ENDO)\n\n\n00010516\n\n\n00010617            ISPEXEC SELECT PGM(PASSDEST)\n\n\n00010717            ISPEXEC VGET DEFDEST\n\n\n00010817\n\n\n00010917            WHATDSN DDNAME(STEPCAT)\n\n\n00011015            SET &CAT = &DSNAME\n\n\n00012015\n\n\n00012420            GETMY PROG SYS ACCT TERMID\n\n\n00018815\n\n\n00019015            FREE F(SYSOUT)\n\n\n00019115            ALLOC F(SYSOUT) UNIT(SYSSQ) NEW\n\n\n00019519            CALL 'WDPSC.SHARED.LOAD(WATDSN)' 'STEPLIB '\n\n\n00019615\n\n\n00019815            OPENFILE SYSOUT\n\n\n00019915            GETFILE SYSOUT\n\n\n00020015            IF &SUBSTR(2:7,&SYSOUT) NE &STR(DDNAME)THEN DO\n\n\n00020115                SET &SLIBDSN1 = &STR(********************************)\n\n\n00020215                SET &SLIBDSN2 = &STR(* DDNAME STEPLIB NOT ALLOCATED *)\n\n\n00020315                SET &SLIBDSN3 = &STR(********************************)\n\n\n00020415                GOTO DOIT\n\n\n00020515                ENDO\n\n\n00020615\n\n\n00020715            SET &SLIBDSN1 = &SUBSTR(28:71,&SYSOUT)\n\n\n00020815            GETFILE SYSOUT\n\n\n00020915            SET &SLIBDSN2 = &SUBSTR(28:71,&SYSOUT)\n\n\n00021015            GETFILE SYSOUT\n\n\n00021115            SET &SLIBDSN3 = &SUBSTR(28:71,&SYSOUT)\n\n\n00021215            CLOSFILE SYSOUT\n\n\n00022015\n\n\n00030015 DOIT:      ISPEXEC DISPLAY PANEL(WHOISI)\n\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CLRSPFI$": {"ttr": 12550, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x00\\x7f\\x00\\x88\\x00\\x7f\\x12\\x00\\x00&\\x00&\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf2\\xf7\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-01-07T00:00:00", "modifydate": "1988-01-07T12:00:00", "lines": 38, "newlines": 38, "modlines": 0, "user": "FILE270"}, "text": "1                                                        CLRSPFIO.1\n                                                         09/01/83\n\n\n  PROGRAM:       CLRSPFIO\n  AUTHOR:        Kermit Kiser\n  AGENCY:        WDPSC\n  LANGUAGE:      Assembler\n  LOCATION:      Located in a \"system library\".  That is, it can be\n                 executed without supplying STEPLIB.\n  FUNCTION:      Prevent the  need for an unnecessary  ENTER (three\n                 asterisks at bottom of  screen) when attempting to\n                 do a Dialog Manager DISPLAY of a panel after doing\n                 CLIST WRITE(s).\n\n  RUN MODE:      To be used under SPF only.  Used in Dialog Manager\n                 applications.\n\n  This   program  is   useful   when   developing  Dialog   Manager\n  applications which  are driven  by CLISTs  when these  CLISTs mix\n  CLIST WRITE statements and Dialog Manager panel displays.\n\n  For example, if you prompt for a  variable in a CLIST via a WRITE\n  or WRITENR and READ statement and  then issue an ISPEXEC DISPLAY,\n  then three  asterisks will  appear at the  bottom of  the screen.\n  You will then be required to  hit ENTER before the Dialog Manager\n  panel will be displayed.\n\n  This program will eliminate this unnecessary ENTER and the Dialog\n  Manager panel  will be displayed  directly.  Place  the following\n  code in  your CLIST just prior  to displaying the  Dialog Manager\n  panel.\n\n       ISPEXEC SELECT PGM(CLRSPFIO)\n\n\n\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CLRSPFIO": {"ttr": 12552, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x00\\x7f\\x00\\x88\\x00\\x7f\\x12\\x00\\x00:\\x00:\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf2\\xf7\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-01-07T00:00:00", "modifydate": "1988-01-07T12:00:00", "lines": 58, "newlines": 58, "modlines": 0, "user": "FILE270"}, "text": "*\n*  08/12/86 - V2M0 MOD TO ALLOW PARMS TO BE PASSED:\n*\n*             PARM='INIT'   MEANS DO AN STFSMODE ON,INITIAL=YES\n*             PARM='ON'     MEANS DO AN STLINENO MODE=ON\n*             PARM='OFF'    MEANS DO AN STLINENO MODE=OFF,LINE=0\n*  (DEFAULT)  PARM='NORMAL' MEANS DO AN STLINENO MODE=OFF,LINE=0;\n*                           THEN TPUT(FSCR) RESET; STLINENO MODE=ON\n*\nCLRSPFIO START\n         SAVE  (14,12),,CLRIO-V2M0\n         LR    R12,R15                                            WDPSC\n         USING CLRSPFIO,R12\n         L     R11,0(R1)          R11->PARM\n         CLC   0(2,R11),=X'0000'  ANY PARM?\n         BNE   GOTPARM            YUP.\n         LA    R11,=C'  NORMAL'   DEFAULT PARM\nGOTPARM  EQU   *\n*\n         CLC   2(2,R11),=C'INIT'  FSMODE INIT?\n         BNE   CKOFF              NOOP.\n         STFSMODE ON,INITIAL=YES\n         B     XIT\nCKOFF    EQU   *\n*\n         CLC   2(2,R11),=C'ON'    FSMODE ON?\n         BE    ON                 YUP.\n         SLR   R2,R2                                              WDPSC\n         STLINENO MODE=OFF,LINE=(R2)                              WDPSC\n         CH    R15,=H'8'               0=VTAM?                    WDPSC\n         BE    TCAM                                               WDPSC\n         CLC   2(2,R11),=C'OFF'   FSMODE OFF ONLY?\n         BE    XIT                YUP.\n         EJECT\n         TPUT  =X'C3',1,FULLSCR,HOLD                              WDPSC\n*\n*        ICM   R0,15,=X'13000000'                                 WDPSC\n*        SLR   R1,R1                                              WDPSC\n*        ICM   R15,15,=C'    '                                    WDPSC\n*        SVC   94                                                 WDPSC\n*        SLR   R2,R2                                              WDPSC\n*\nON       STLINENO MODE=ON,LINE=2                                  WDPSC\n         CH    R15,=H'8'               0=VTAM?                    WDPSC\n         BNE   VTAM                                               WDPSC\n*\nTCAM     L     R9,548             R9->ASCB\n         L     R8,108(,R9)        R8->ASXB\n         L     R7,20(,R8)         R7->LWA\n         L     R6,152(,R7)        R6->TXC\n         LTR   R6,R6              ANY TXC PRESENT?\n         BZ    XIT                NO\n         NI    0(R6),X'F7'        SAY NO LINE IO OCCURED\nVTAM     EQU   *\n*\nXIT      RETURN (14,12),RC=0\n         REGEQU\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CMDOUT$": {"ttr": 12554, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x00\\x7f\\x00\\x88\\x00\\x7f\\x12\\x00\\x00#\\x00#\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf2\\xf7\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-01-07T00:00:00", "modifydate": "1988-01-07T12:00:00", "lines": 35, "newlines": 35, "modlines": 0, "user": "FILE270"}, "text": "1 00.000\n-                                                         CMDOUT   Clist\n0Function -\n0  The CMDOUT clist is used to allocate a temporary work file for use\n by the calling clist. It can reuse a previous work file allocation if\n it has been set free by \"CMDOUT FREE(n)\" where \"n\" is the work file\n number returned by CMDOUT in &LASTCC.\n\n0Syntax -\n _______________________________________________________________________\n0     Command              Operands\n _______________________________________________________________________\n0      CMDOUT  DDN(ddname) FREE(n) MOD USE(attrlist) FORCE\n _______________________________________________________________________\n-Operands -\n0 DDN(ddname) - causes a given ddname to be used for the allocation. If\n      not given, the ddname used is CMDOUTn where \"n\" is the file\n      number returned in &LASTCC.\n0 FREE(n)     - causes a previously allocated work file to be marked as\n      available for reuse. \"n\" is the file number returned in &LASTCC\n      at time of allocation.\n0 MOD         - causes another ddname of CMDOUTnM to be allocated as a\n      MOD disposition file.\n0 USE(attrlist) - specifies an attribute list name to be used for the\n      allocation of the work file.\n0 FORCE       - cause any previous allocation of the work file to be\n      ignored. The allocation is new.\n-Example -\n0 If this command is executed:\n0  CMDOUT\n0 Then a dataset with name prefix.COMMAND.OUTPUTn is allocated to\n  ddname CMDOUTn and &LASTCC is set to \"n\" which is the file number.\n-Note -\n0 If an error occurs while allocating the file, &LASTCC is set to 99.\n  A pre-existing dataset may be used by CMDOUT.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CNTLCRT": {"ttr": 12556, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x00\\x7f\\x00\\x88\\x00\\x7f\\x12\\x00\\x00\\x91\\x00\\x91\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf2\\xf7\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-01-07T00:00:00", "modifydate": "1988-01-07T12:00:00", "lines": 145, "newlines": 145, "modlines": 0, "user": "FILE270"}, "text": "*          DATA SET 761KKCNTL  AT LEVEL 001 AS OF 01/08/79\n         TITLE 'CNTLCRT  -  ROUTINE FOR CRT TTY CONTROL'\n* WRITTEN BY KERMIT KISER - WASHINGTON STATE DP SERVICE CENTER (WDPSC)\n*\nCNTLCRT  ENTERR\n         L     R4,0(R1)           R4 -> PARM FIELD\n         LA    R10,4(R4)          R10-> DATA FIELD\n         LH    R9,0(R4)           R9 =  PARM LEN\n         SH    R9,=H'2'           R9=R9-2\n         LTR   R9,R9              R9>0?\n         BNP   BADPARM            NO -> TROUBLE\n         SLR   R6,R6              R6=0\n         CLI   3(R4),C'X'         TRAN TO HEX?\n         BNE   TPUT               NO -> WRITE IT NOW\n*\n         TITLE 'CNTLCRT  -  TRANSLATE ROUTINE'\n*\n         LR    R5,R9              R5 = SAVE LENGTH\n         SRL   R5,1(0)            R5=R5/2\n         LR    R0,R5              R0= LEN TO GET\n         GETMAIN R,LV=(0)\n         LR    R6,R1              R6 -> SAVE OUT FIELD\n         LR    R11,R1             R11 -> HEXAREA FOR RESULT\n*\n*\n*\nCTH      BAL   R14,LENCHK         R8=WORKING LENGTH\n         BCTR  R8,R0              R8=R8-1\n         EX    R8,VALCK           NON-HEX CHARS?\n         BNZ   BADCHAR            YES\n         EX    R8,MVCHAR          NO->PUT IN CHARAREA\n         EX    R8,TRANCHAR        MAKE IT PACKABLE\n         PACK  HEXAREA(5),CHARAREA(9)  PACK IT\n         SRL   R8,1(R0)           R8=R8/2\n         EX    R8,MVCHEX          GIVE HIM THE HEX\n         BAL   R14,DONECHK        DONE?\n         B     CTH                NO\n*\n*\n*\nTRANDONE LR    R9,R5              R9 = LEN TO WRITE\n         LR    R10,R6             R10 -> DATA TO WRITE\n         B     TPUT\n         TITLE 'CNTLCRT  -  TPUT ROUTINES'\nTPUT     DS    0H\n         CLI   2(R4),C'C'         CONTROL?\n         BNE   TRYASIS            NO\n         TPUT  (R10),(R9),CONTROL\n         B     EXIT\n*\nTRYASIS  CLI   2(R4),C'A'         ASIS?\n         BNE   TRYEDIT            NO\n         TPUT  (R10),(R9),ASIS\n         B     EXIT\n*\n         EJECT\nTRYEDIT  CLI   2(R4),C'E'         EDIT?\n         BNE   TRYFULL            NO\n         TPUT  (R10),(R9),EDIT\n         B     EXIT\n*\nTRYFULL  CLI   2(R4),C'F'         FULLSCRN?\n         BNE   TYPERR             NO\n         TPUT  (R10),(R9),FULLSCR\n         B     EXIT\n*\n         TITLE 'CNTLCRT  -  SUBROUTINES'\n*\n*\nLENCHK   CH    R9,=H'8'           LEN TO TRAN > 8 ?\n         BH    USE8               YES\n         LR    R8,R9              R8=R9\n         SLR   R9,R9              R9=0\n         BR    R14                RETURN\nUSE8     LA    R8,8               R8=8\n         SH    R9,=H'8'           R9=R9-8\n         BR    R14                RETURN\n*\n*\nDONECHK  LTR   R9,R9              R9=0?\n         BZ    TRANDONE           YES->MUST BE THRU\n         LA    R10,8(,R10)        R10=R10+8 NEXT CHUNK\n         LA    R11,4(,R11)        R11=R11+4  \"     \"\n         BR    R14                RETURN\n*\n*\n*\nVALCK    TRT   0(0,R10),TABLE1\nMVCHAR   MVC   CHARAREA(0),0(R10)\nTRANCHAR TR    CHARAREA(0),TABLE2\nMVCHEX   MVC   0(0,R11),HEXAREA\n*\n*\n*\nTYPERR   TPUT  TYPEMESS,40        GIVE ERROR\n         B     EXIT\nTYPEMESS DC    CL40'TPUT TYPE ERROR'\n*\n*\n*\nBADPARM  LA    R15,4              R15=RC=4\n         B     RETURN             EXIT\n*\n*\nBADCHAR  LA    R15,8              R15=RC=8\n         B     RETURN             EXIT\n         TITLE 'CNTLCRT  -  EXIT ROUTINES'\n*\n*                                   CALL IT A DAY\nEXIT     EQU   *\n         LTR   R6,R6              R6=0?\n         BZ    DONE               YES->NOTHING TO FREE HERE\n         LR    R1,R6              R1->AREA TO FREE\n         LR    R0,R5              R0= LENGTH TO FREE\n         FREEMAIN R,LV=(0),A=(1)  FREE THE TRANS MSG\n*\nDONE     SLR    R15,R15             RETURN CODE = 0\n*\nRETURN   LEAVER\n*\n         TITLE 'CNTLCRT  -  CONSTANTS'\n*\nTABLE1   DC    256X'04'\n         ORG   TABLE1+X'C1'\n         DC    6X'00'\n         ORG   TABLE1+X'F0'\n         DC    10X'00'\n         ORG\n*\nTABLE2   DC    256X'00'\n         ORG   TABLE2+X'C1'\n         DC    X'FAFBFCFDFEFF'\n         ORG   TABLE2+X'F0'\n         DC    C'0123456789'\n         ORG\n         DC     C'0123456789ABCDEF'\nTABLE3   EQU   *-256\n         LTORG\n         TITLE 'CNTLCRT  -  DYNAMIC WORKAREA'\nWORKAREA DSECT\nSAVEAREA DS    18F                SAVEAREA\nCHARAREA DS    CL10\nHEXAREA  DS    XL6\nWORKLEN  EQU   *-WORKAREA\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CNTLCRT$": {"ttr": 12801, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x00\\x7f\\x00\\x88\\x00\\x7f\\x12\\x00\\x00I\\x00I\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf2\\xf7\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-01-07T00:00:00", "modifydate": "1988-01-07T12:00:00", "lines": 73, "newlines": 73, "modlines": 0, "user": "FILE270"}, "text": "1                                                        CNTLCRT.1\n                                                         06/25/82\n\n\n  PROGRAM:       CNTLCRT\n  AUTHOR:        Kermit Kiser\n  AGENCY:        WDPSC\n  LANGUAGE:      Assembler\n  LOCATION:      WDPSC.SHARED.LOAD\n  FUNCTION:      Write data to TSO terminal.\n\n  RUN MODE:      Interactive only\n\n  CNTLCRT  is a  program  which can  be  called by  a  CLIST or  an\n  application program executing under control  of TSO to write data\n  to  the User's  TSO terminal.   It allows  more flexibility  than\n  other  methods  of  sending  data  to  the  terminal.   For  more\n  information on the modes of  transmission, see the description of\n  the TPUT  SVC in  'OS/VS2 TSO  Guide to  Writing a  TMP or  a CP'\n  (GC28-0648-2).\n\n  To call from a CLIST:\n\n       CALL 'WDPSC.SHARED.LOAD(CNTLCRT)' 'mtdata'\n            m  =   the transmission mode:  A=ASIS,\n                   C=CONTROL,E=EDIT,F=FULLSCR\n\n            t  =   'X' if data is character coded\n                   hex or 'N' if not.\n\n            data = digits 0-9 and letters A-F if t is 'X',\n                   otherwise anything\n\n  EXAMPLE:  CALL 'WDPSC.SHARED.LOAD(CNTLCRT)' 'CX0C'\n            should clear the screen on a TTY CRT.\n\n\n\n\n1                                                        CNTLCRT.2\n                                                         06/25/82\n\n\n  To call from a COBOL Program:\n\n       CALL 'CNTLCRT' USING parameter.\n\n            parameter  -  is a four field data item:\n                          length, mode, trans, data.\n\n            length     -  binary halfword (2 bytes) with length of\n                          parameter not including this length field.\n\n            mode       -  transmission mode, see preceding page.\n\n            trans      -  translation option, see preceding page.\n\n            data       -  data to send, see preceding page.\n\n  EXAMPLE:\n\n            01 PARAMETER.\n               05  LEN     PIC S9999 COMP VALUE +6.\n               05  MODE    PIC X VALUE 'C'.\n               05  TRANS   PIC X VALUE 'X'.\n               05  DATA    PIC XX VALUE '0C2F'.\n\n  CALL 'CNTLCRT' USING PARAMETER.\n  Should clear the screen and ring the bell on a TTY CRT terminal.\n\n\n\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "CNV2GREG": {"ttr": 12804, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x00\\x7f\\x00\\x88\\x00\\x7f\\x12\\x00\\x010\\x010\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf2\\xf7\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-01-07T00:00:00", "modifydate": "1988-01-07T12:00:00", "lines": 304, "newlines": 304, "modlines": 0, "user": "FILE270"}, "text": "       ID DIVISION.\n       PROGRAM-ID.  CNV2GREG.\n      *****************************************************************\n      *  THIS IS A SUBROUTINE WHICH WILL RETURN A FORMATTED           *\n      *  GREGORIAN DATE GIVEN A STANDARD DATE, JULIAN DATE OR         *\n      *  SERIAL DATE                                                  *\n      *                                                               *\n      *  HOW TO USE THIS SUBROUTINE                                   *\n      *  ..........................                                   *\n      *                                                               *\n      *     1.  LOAD TYPE-OF-INPUT-DATE WITH 'STA', 'JUL', OR         *\n      *         'SER' DEPENDING UPON WHETHER THE DATE TO BE           *\n      *         CONVERTED IS STANDARD (MMDDYY), JULIAN, OR            *\n      *         SERIAL                                                *\n      *                                                               *\n      *     2.  MOVE YOUR DATE TO BE CONVERTED TO INPUT-DATE          *\n      *         (INPUT-DATE IS 6 BYTES IN LENGTH.  IF YOUR            *\n      *         DATE TO BE CONVERTED IS JULIAN OR SERIAL, LEFT        *\n      *         JUSTIFY IT IN INPUT-DATE)                             *\n      *                                                               *\n      *     3.  CALL 'CNV2GREG' USING CNV2GREG-I-O-AREA.              *\n      *                                                               *\n      *     4.  IF VALID-INPUT-DATE IS EQUAL TO 'YES'                 *\n      *            THEN YOUR DATE WAS VALID AND THE FORMATTED         *\n      *            DATE IS IN FORMATTED-DATE                          *\n      *         ELSE                                                  *\n      *            YOUR DATE TO BE CONVERTED IS INVALID.              *\n      *                                                               *\n      *   01  CNV2GREG-I-O-AREA.                                      *\n      *       05  INPUT-FIELDS.                                       *\n      *           10  TYPE-OF-INPUT-DATE            PIC X(03).        *\n      *           10  INPUT-DATE                    PIC X(06).        *\n      *       05  OUTPUT-FIELDS.                                      *\n      *           10  VALID-INPUT-DATE              PIC X(03).        *\n      *           10  FORMATTED-DATE                PIC X(18).        *\n      *                                                               *\n      *  FORMAT OF FORMATTED-DATE                                     *\n      *  ........................                                     *\n      *                                                               *\n      *        18 BYTE FIELD = MMMMMMMMM DD, 19YY                     *\n      *                                                               *\n      *           WHERE                                               *\n      *                                                               *\n      *                 MMMMMMMMM IS 'JANUARY  '                      *\n      *                              'FEBRUARY '                      *\n      *                              'MARCH    '                      *\n      *                              ETC                              *\n      *                                                               *\n      *                 DD        IS DAY OF MONTH (ZERO SUPPRESSED)   *\n      *                                                               *\n      *                 YY        IS YEAR                             *\n      *****************************************************************\n           EJECT\n       ENVIRONMENT DIVISION.\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n\n       77  MONTH-NOW-IN-ALPHA                    PIC X(9).\n\n       01  BREAKDOWN-STANDARD-DATE.\n           05  MONTH                             PIC X(02).\n           05  DAYY                              PIC 9(02).\n           05  YEAR                              PIC X(02).\n\n       01  WORK-INPUT-DATE.\n           05  BYTES-1-5                         PIC X(05).\n           05  FILLER                            PIC X(01).\n\n       01  WORK-FORMATTED-DATE.\n           05  WORK-ALPHA-MONTH                  PIC X(09).\n           05  FILLER            VALUE SPACE     PIC X(01).\n           05  WORK-DAY-OF-MONTH                 PIC Z9.\n           05  FILLER            VALUE ', '      PIC X(02).\n           05  FILLER            VALUE '19'      PIC X(02).\n           05  WORK-YEAR                         PIC X(02).\n\n           EJECT\n      *\n      *****************************************************************\n      *                                                               *\n      *         J T O S C O N V   L I N K A G E   A R E A             *\n      *                                                               *\n      *****************************************************************\n      *\n       01  JTOSCONV-I-O-AREA.\n           05  FILLER                        PIC X(08).\n           05  JTOSCONV-STANDARD-DATE        PIC X(06).\n           05  JTOSCONV-JULIAN-DATE          PIC X(05).\n           05  JTOSCONV-BAD-DATE             PIC X(03).\n\n           EJECT\n      *\n      *****************************************************************\n      *                                                               *\n      *         S T O J C O N V   L I N K A G E   A R E A             *\n      *                                                               *\n      *****************************************************************\n      *\n       01  STOJCONV-I-O-AREA.\n           05  FILLER                        PIC X(08).\n           05  STOJCONV-STANDARD-DATE        PIC X(06).\n           05  STOJCONV-JULIAN-DATE          PIC X(05).\n           05  STOJCONV-SERIAL-DATE          PIC X(05).\n           05  STOJCONV-BAD-DATE             PIC X(03).\n\n           EJECT\n      *\n      *****************************************************************\n      *                                                               *\n      *         S E R L C O N V   L I N K A G E   A R E A             *\n      *                                                               *\n      *****************************************************************\n      *\n       01  SERLCONV-I-O-AREA.\n           05  FILLER                        PIC X(08).\n           05  SERLCONV-SERIAL-DATE          PIC X(05).\n           05  SERLCONV-STANDARD-DATE        PIC X(06).\n           05  SERLCONV-VALID-INPUT          PIC X(03).\n           EJECT\n       LINKAGE SECTION.\n\n       01  CNV2GREG-I-O-AREA.\n           05  INPUT-FIELDS.\n               10  TYPE-OF-INPUT-DATE            PIC X(03).\n               10  INPUT-DATE                    PIC X(06).\n           05  OUTPUT-FIELDS.\n               10  VALID-INPUT-DATE              PIC X(03).\n               10  FORMATTED-DATE                PIC X(18).\n           EJECT\n       PROCEDURE DIVISION USING CNV2GREG-I-O-AREA.\n\n           MOVE SPACES TO FORMATTED-DATE OF CNV2GREG-I-O-AREA.\n\n      *         START CASE STATEMENT\n\n                IF TYPE-OF-INPUT-DATE OF CNV2GREG-I-O-AREA = 'STA'\n                       PERFORM 1000-PROCESS-STA-DATE\n                          THRU 1999-EXIT-STA-DATE\n           ELSE\n                IF TYPE-OF-INPUT-DATE OF CNV2GREG-I-O-AREA = 'JUL'\n                       PERFORM 2000-PROCESS-JUL-DATE\n                          THRU 2999-EXIT-JUL-DATE\n           ELSE\n                IF TYPE-OF-INPUT-DATE OF CNV2GREG-I-O-AREA = 'SER'\n                       PERFORM 3000-PROCESS-SER-DATE\n                          THRU 3999-EXIT-SER-DATE\n           ELSE\n                MOVE 'NO ' TO VALID-INPUT-DATE OF CNV2GREG-I-O-AREA.\n\n      *         END CASE STATEMENT\n\n           GO TO 9999-GOBACK.\n           EJECT\n       1000-PROCESS-STA-DATE.\n\n           MOVE INPUT-DATE OF CNV2GREG-I-O-AREA\n             TO STOJCONV-STANDARD-DATE.\n\n           CALL 'STOJCONV' USING STOJCONV-I-O-AREA.\n\n           IF STOJCONV-BAD-DATE = 'YES'\n                MOVE 'NO ' TO VALID-INPUT-DATE OF CNV2GREG-I-O-AREA\n                GO TO 1999-EXIT-STA-DATE.\n\n           MOVE INPUT-DATE OF CNV2GREG-I-O-AREA\n             TO BREAKDOWN-STANDARD-DATE.\n\n           PERFORM 4000-CONVERT-MONTH-TO-ALPHA\n              THRU 4999-EXIT-CONVERSION.\n\n           MOVE MONTH-NOW-IN-ALPHA\n             TO WORK-ALPHA-MONTH.\n           MOVE DAYY OF BREAKDOWN-STANDARD-DATE\n             TO WORK-DAY-OF-MONTH.\n           MOVE YEAR OF BREAKDOWN-STANDARD-DATE\n             TO WORK-YEAR.\n\n           MOVE WORK-FORMATTED-DATE\n             TO FORMATTED-DATE OF CNV2GREG-I-O-AREA.\n\n           MOVE 'YES' TO VALID-INPUT-DATE OF CNV2GREG-I-O-AREA.\n\n       1999-EXIT-STA-DATE.\n           EXIT.\n           EJECT\n       2000-PROCESS-JUL-DATE.\n\n           MOVE INPUT-DATE OF CNV2GREG-I-O-AREA\n             TO WORK-INPUT-DATE.\n\n           MOVE BYTES-1-5 OF WORK-INPUT-DATE\n             TO JTOSCONV-JULIAN-DATE.\n\n           CALL 'JTOSCONV' USING JTOSCONV-I-O-AREA.\n\n           IF JTOSCONV-BAD-DATE = 'YES'\n                MOVE 'NO ' TO VALID-INPUT-DATE OF CNV2GREG-I-O-AREA\n                GO TO 2999-EXIT-JUL-DATE.\n\n           MOVE JTOSCONV-STANDARD-DATE\n             TO BREAKDOWN-STANDARD-DATE.\n\n           PERFORM 4000-CONVERT-MONTH-TO-ALPHA\n              THRU 4999-EXIT-CONVERSION.\n\n           MOVE MONTH-NOW-IN-ALPHA\n             TO WORK-ALPHA-MONTH.\n           MOVE DAYY OF BREAKDOWN-STANDARD-DATE\n             TO WORK-DAY-OF-MONTH.\n           MOVE YEAR OF BREAKDOWN-STANDARD-DATE\n             TO WORK-YEAR.\n\n           MOVE WORK-FORMATTED-DATE\n             TO FORMATTED-DATE OF CNV2GREG-I-O-AREA.\n\n           MOVE 'YES' TO VALID-INPUT-DATE OF CNV2GREG-I-O-AREA.\n\n       2999-EXIT-JUL-DATE.\n           EXIT.\n           EJECT\n       3000-PROCESS-SER-DATE.\n\n           MOVE INPUT-DATE OF CNV2GREG-I-O-AREA\n             TO WORK-INPUT-DATE.\n\n           MOVE BYTES-1-5 OF WORK-INPUT-DATE\n             TO SERLCONV-SERIAL-DATE.\n\n           CALL 'SERLCONV' USING SERLCONV-I-O-AREA.\n\n           IF SERLCONV-VALID-INPUT = 'YES'\n                NEXT SENTENCE\n           ELSE\n                MOVE 'NO ' TO VALID-INPUT-DATE OF CNV2GREG-I-O-AREA\n                GO TO 3999-EXIT-SER-DATE.\n\n           MOVE SERLCONV-STANDARD-DATE\n             TO BREAKDOWN-STANDARD-DATE.\n\n           PERFORM 4000-CONVERT-MONTH-TO-ALPHA\n              THRU 4999-EXIT-CONVERSION.\n\n           MOVE MONTH-NOW-IN-ALPHA\n             TO WORK-ALPHA-MONTH.\n           MOVE DAYY OF BREAKDOWN-STANDARD-DATE\n             TO WORK-DAY-OF-MONTH.\n           MOVE YEAR OF BREAKDOWN-STANDARD-DATE\n             TO WORK-YEAR.\n\n           MOVE WORK-FORMATTED-DATE\n             TO FORMATTED-DATE OF CNV2GREG-I-O-AREA.\n\n           MOVE 'YES' TO VALID-INPUT-DATE OF CNV2GREG-I-O-AREA.\n\n       3999-EXIT-SER-DATE.\n           EXIT.\n           EJECT\n       4000-CONVERT-MONTH-TO-ALPHA.\n\n      *       START CASE STATEMENT\n\n              IF MONTH OF BREAKDOWN-STANDARD-DATE = '01'\n                    MOVE 'JANUARY  ' TO MONTH-NOW-IN-ALPHA\n           ELSE\n              IF MONTH OF BREAKDOWN-STANDARD-DATE = '02'\n                    MOVE 'FEBRUARY ' TO MONTH-NOW-IN-ALPHA\n           ELSE\n              IF MONTH OF BREAKDOWN-STANDARD-DATE = '03'\n                    MOVE 'MARCH    ' TO MONTH-NOW-IN-ALPHA\n           ELSE\n              IF MONTH OF BREAKDOWN-STANDARD-DATE = '04'\n                    MOVE 'APRIL    ' TO MONTH-NOW-IN-ALPHA\n           ELSE\n              IF MONTH OF BREAKDOWN-STANDARD-DATE = '05'\n                    MOVE 'MAY      ' TO MONTH-NOW-IN-ALPHA\n           ELSE\n              IF MONTH OF BREAKDOWN-STANDARD-DATE = '06'\n                    MOVE 'JUNE     ' TO MONTH-NOW-IN-ALPHA\n           ELSE\n              IF MONTH OF BREAKDOWN-STANDARD-DATE = '07'\n                    MOVE 'JULY     ' TO MONTH-NOW-IN-ALPHA\n           ELSE\n              IF MONTH OF BREAKDOWN-STANDARD-DATE = '08'\n                    MOVE 'AUGUST   ' TO MONTH-NOW-IN-ALPHA\n           ELSE\n              IF MONTH OF BREAKDOWN-STANDARD-DATE = '09'\n                    MOVE 'SEPTEMBER' TO MONTH-NOW-IN-ALPHA\n           ELSE\n              IF MONTH OF BREAKDOWN-STANDARD-DATE = '10'\n                    MOVE 'OCTOBER  ' TO MONTH-NOW-IN-ALPHA\n           ELSE\n              IF MONTH OF BREAKDOWN-STANDARD-DATE = '11'\n                    MOVE 'NOVEMBER ' TO MONTH-NOW-IN-ALPHA\n           ELSE\n              MOVE 'DECEMBER ' TO MONTH-NOW-IN-ALPHA.\n\n      *       END CASE STATEMENT\n\n       4999-EXIT-CONVERSION.\n           EXIT.\n           EJECT\n       9999-GOBACK.\n\n           GOBACK.\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "COMMANDR": {"ttr": 12810, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x00\\x7f\\x00\\x88\\x00\\x7f\\x12\\x00\\x007\\x007\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf2\\xf7\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-01-07T00:00:00", "modifydate": "1988-01-07T12:00:00", "lines": 55, "newlines": 55, "modlines": 0, "user": "FILE270"}, "text": "//KKA00150 JOB (2100,56-D),'KISER 2215 T',CLASS=H,MSGCLASS=T\n//F EXEC ASMHCL,LIB3='SYS1.AMODGEN',LIBRARY='WDPSC.PROGLIB',\n//  OPTION2='AC=1',LNDSP=SHR OPTION1=TERM\n         TITLE 'COMMANDR - '\nCOMMANDR CSECT\n         SAVE  (14,12),,*\n         BALR  R12,0            ESTABLISH PROGRAM BASE\n         USING *,R12\n         ST    R13,SAVE+4       SAVE AREA\n         LA    R2,SAVE\n         ST    R2,8(,R13)       BACK POINTERS\n         LR    R13,R2\n         L     R4,0(,R1)        PARAMETER STRING\n         LH    R5,0(,R4)        LENGTH OF COMMAND\n         CH    R5,=H'120'       MAXIMUM COMMAND LENGTH\n         BH LETSTOP\n         BCTR  R5,0              PREPARE FOR MOVE\n         EX    R5,CMDMOVE\nCMDMOVE  MVC   CMDAREA(0),2(R4)\n*\n         SR    R0,R0\n         WTO   MF=(E,CMDMSG)\n         WTO   MF=(E,CMDWTO)\n         MODESET KEY=ZERO          CHANGE TO KEY ZERO, NO CHANGE BACK\n         SR    R0,R0\n         LA    R1,CMDWTO\n         SVC   34                  ISSUE  COMMAND\n         LA    R9,0\n* IF DDNAME NOWAIT IS PRESENT, SKIP 10 SECOND WAITER\n         DEVTYPE =CL8'NOWAIT',DEVTAREA\n         BXLE  R15,R15,LETSTOP\n*\n      STIMER WAIT,DINTVL=SEC10    GIVE TIME FOR YOUR STOMACH TO SETTLE\nLETSTOP  EQU   *\n         L     R13,SAVE+4\n         LR    R15,R9\n         RETURN (14,12),RC=(15)\nSAVE     DC    18F'0'\n         DS    0D\nSEC10    DC    C'00001000'\nCMDMSG   WTO   'THIS COMMAND HAS BEEN ISSUED:   ',                     X\n               ROUTCDE=(1,9),DESC=4,MF=L\nCMDWTO   DS    0F\n         DC    AL2(L'CMDAREA)\n         DC    AL2(0)\nCMDAREA  DC    CL101' '\n         DC    X'1000',X'8080'   DESCRIPTOR AND ROUTE CODES\n         DS    0H\nDEVTAREA DS    6F\n         PRINT OFF\n         REGISTER ,\n         PRINT ON\n         END\n//LKED.SYSIN DD *\n   NAME COMMANDR(R)\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CONCATEM": {"ttr": 12812, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x00\\x7f\\x00\\x88\\x00\\x7f\\x12\\x00\\x04^\\x04^\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf2\\xf7\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-01-07T00:00:00", "modifydate": "1988-01-07T12:00:00", "lines": 1118, "newlines": 1118, "modlines": 0, "user": "FILE270"}, "text": "*\n*  AUTHOR:   JEFF SPREHN\n*\n*\n*  CCCC    OOOO   NN     NN   CCCC        A   TTTTTTTT EEEEE MM      MM\n* CC   C  OOOOOO  NN     NN  CC   C      AAA  TTTTTTTT EEEEE MMM    MMM\n*CC      OO    OO NNN    NN CC          AA AA    TT    EE    MMMM  MMMM\n*CC      OO    OO NNNN   NN CC          AA AA    TT    EE    MM  MM  MM\n*CC      OO    OO NN NN  NN CC         AA   AA   TT    EEEEE MM      MM\n*CC      OO    OO NN  NN NN CC         AAAAAAA   TT    EEEEE MM      MM\n*CC      OO    OO NN   NNNN CC        AA     AA  TT    EE    MM      MM\n*CC      OO    OO NN    NNN CC        AA     AA  TT    EE    MM      MM\n* CC   C  OOOOOO  NN     NN  CC    C AA       AA TT    EEEEE MM      MM\n*  CCCC    OOOO   NN      N   CCCCC  AA       AA TT    EEEEE MM      MM\n*\n*\n*  VER/MOD LEVELS:\n*  ---------------\n*\n*      1.0  ORIGINAL DISTRIBUTION\n*\n*      1.1  (MARCH 85)  MADE MODIFICATION TO THE TWO BYTE S99FLAG1\n*                       FOR THE DYNAMIC ALLOCATION (VERB CODE 01)\n*                       (ALLOCPRM) FROM X'2000'\n*                                  TO   X'A000'\n*\n*      1.2  (MAY 85)    MADE CORRECTION TO CODE IN ERROR IN ROUTINE\n*                       UNPKHEX FROM  MVC  1,=CL3'HTC'\n*                               TO    MVC  CNVTYPE,=CL3'HTC'\n*\n*      1.3  (APR 86)    1.  ADDED AN ALIAS OF DATASET TO THE KEYWORD\n*                           DSNAME\n*                       2.  ADDED A DEFAULT OF ACTCODE(A) IF THE\n*                           ACTCODE KEYWORD PARAMETER WAS NOT\n*                           SUPPLIED\n*\n*      2.0  (8/25/88)   REVISIONS MADE BY GORDON SCHILLINGER TO\n*                       ALLOW COMMAND TO RUN RE-ENTRANT, DUE TO\n*                       ITS HIGH USAGE.\n*\n*  --------------------------------------------------------------------\n*  COMMAND     OPERANDS\n*  --------------------------------------------------------------------\n*  CONCATEM    ACTCODE('ACTION CODE') DDNAME('DDNAME') DSNAME('DSNAME')\n*                                     OR FILE\n*  --------------------------------------------------------------------\n*\n*\n*  OPERANDS -\n*\n*     REQUIRED -\n*\n*        ACTCODE('ACTION CODE') --'ACTION CODE' IS EITHER 'A' OR 'D'\n*\n*                                    'A'  FOR CONCATENATING THE\n*                                         SUPPLIED DSNAME TO THE\n*                                         SUPPLIED DDNAME AT THE\n*                                         FRONT OF THE CONCATENATED\n*                                         GROUP\n*\n*                                    'D'  FOR REMOVING THE SUPPLIED\n*                                         DSNAME FROM THE CONCATENATED\n*                                         GROUP ASSOCIATED WITH THE\n*                                         SUPPLIED DDNAME\n*\n*\n*\n*        DDNAME('DDNAME') ------- 'DDNAME' IS THE DDNAME WITH WHICH WE\n*        OR FILE                  WANT TO CONCATENATE OR DECONCATENATE\n*                                 TO\n*\n*        DSNAME('DSNAME') ------- 'DSNAME' IS THE DSNAME WITH WHICH WE\n*                                 WANT TO CONCATENATE OR REMOVE FROM\n*                                 CONCATENATION\n*\n         EJECT\n*\n*\n*        THIS COMMAND WILL ALSO MAKE AVAILABLE TWO VARIABLES THAT AN\n*        INVOKING CLIST MAY INTERROGATE.  BELOW IS A TABLE OF VALUES\n*        AFTER EXECUTION OF THIS COMMAND FOR THESE TWO VARIABLES\n*        &OUTMSG AND &LASTCC (RETURN CODE)\n*\n*        |---------|------------------------------------------------|\n*        | &LASTCC |                 &OUTMSG                        |\n*        |---------|------------------------------------------------|\n*        |    0    | SUCCESSFUL COMPLETION                          |\n*        |---------|------------------------------------------------|\n*        |    4    | DYNAMIC ALLOC ERROR (ERR REASON CODE = XXXX)   |\n*        |---------|------------------------------------------------|\n*        |    8    | DYNAMIC DEALLOC ERROR (ERR REASON CODE = XXXX) |\n*        |---------|------------------------------------------------|\n*        |    12   | MISSING ACTION CODE                            |\n*        |---------|------------------------------------------------|\n*        |    16   | MISSING DDNAME PARAMETER                       |\n*        |---------|------------------------------------------------|\n*        |    20   | MISSING DSNAME PARAMETER                       |\n*        |---------|------------------------------------------------|\n*        |    24   | INVALID ACTION CODE  (MUST BE A OR D)          |\n*        |---------|------------------------------------------------|\n*        |    28   | DYNAMIC CONCAT  ERROR (ERR REASON CODE = XXXX) |\n*        |---------|------------------------------------------------|\n*        |    32   | MORE THAN 50 DATASETS ALREADY ALLOCATED        |\n*        |---------|------------------------------------------------|\n*        |    36   | CANNOT DO DEALLOCATION -- DDNAME NOT ALLOCATED |\n*        |---------|------------------------------------------------|\n*        |    40   | CANNOT DO DEALLOCATION -- DSNAME NOT ALLOCATED |\n*        |---------|------------------------------------------------|\n*        |    96   | INVALID SYNTAX OF ONE OR MORE OPERANDS         |\n*        |---------|------------------------------------------------|\n*\n         EJECT\nCONCATEM ENTERR LEVEL=V_2.0\n         LA    R3,BASEREG2   R3 IS TO BE THE SECOND BASE REGISTER\n         USING BASEREG2,R3\n         EJECT\n********************************************************************\n*                                                                  *\n*      M A I N   L I N E   L O G I C   F O R   C O N C A T E M     *\n*                                                                  *\n********************************************************************\n*\n         LR    R11,R1              SAVE THE PARM POINTER\n         LA    R4,0                R4==> 0\n         BAL   R14,DOPARSE         PERFORM THE PARSE SERVICE ROUTINE\n         CLC   PROCESSW,=C'YES'    WAS PARSE SUCCESFUL ?\n         BNE   INITL               IF NOT, BRANCH TO INITL\n         BAL   R14,LOADFLDS        PERFORM ROUTINE TO LOAD THE PARSED\n*                                    FIELDS INTO APPROP DATA FIELDS\n         CLC   PROCESSW,=C'YES'    IS EVERTHING STILL HONKEY DOREY ?\n         BNE   INITL               IF NOT, BRANCH TO INITL\n*\n*        INIT POINTERS IN DYNAMIC WORKAREA\n         LA    R1,ALLOCRB\n         STCM  R1,7,ALLOCPRM+1     ALLOC REQUEST BLOCK PTR\n         LA    R1,ALLOCTUA\n         ST    R1,ALLOCERC+4       PTR TO TEXT UNIT PTRS\n         LA    R1,ALLOCUT1\n         ST    R1,ALLOCTUA         TEXT UNIT #1 PTR\n         LA    R1,ALLOCUT2\n         ST    R1,ALLOCTUA+4       TEXT UNIT #2 PTR\n         LA    R1,ALLOCUT3\n         ST    R1,ALLOCTUA+8       TEXT UNIT #3 PTR\n         LA    R1,ALLOCUT4\n         STCM  R1,7,ALLOCTUA+13    TEXT UNIT #4 PTR\n         LA    R1,FREERB\n         STCM  R1,7,FREEPARM+1     FREE REQEST BLOCK PTR\n         LA    R1,FREEUNT1\n         STCM  R1,7,FREETUPL+1      TEXT UNIT #1 PTR\n         LA    R1,FREEUNT2\n         STCM  R1,7,FREETUPL+5     TEXT UNIT #2 PTR\n         LA    R1,CNCTRB\n         STCM  R1,7,CNCTPARM+1     CONCAT REQUEST BLOCK PTR\n         LA    R1,CNCTTUPL\n         ST    R1,CNCTERC+4        PTR TO TEXT UNIT PTR\n         LA    R1,CNCTUNT1\n         STCM  R1,7,CNCTTUPL+1     TEXT UNIT PTR\n*\n         BAL   R14,MAJORTN         PERFORM ROUTINE TO DO THE\n*                                    CONCATENATION OR DECONCATENATION\n*                                    AS REQUESTED\n         C    R4,=F'0'             WERE ANY ERRORS ENCOUNTERED?\n         BNE  INITL                IF THERE WERE, BRANCH TO INITL\n         MVC  OUTMSG,GOODMSG       MOVE 'SUCCESSFUL COMPLETION'\n*                                    TO OUTMSG\nINITL    BAL   R14,INITLIST        BUILD PARMLIST FOR IKJUPDT\n         MVC   DDNEOT,=H'-1'       MARK END OF DDN TABLE\n         BAL   R14,SETOUTMG        SET CLIST VARIABLE OUTMSG\n         B     SHUTDOWN            BRANCH TO SHUTDOWN\n         EJECT\n********************************************************************\n*                                                                  *\n*        P A R S E   I N P U T   C O M M A N D   B U F F E R       *\n*                                                                  *\n********************************************************************\n*\nDOPARSE  ST    R14,SAVEIT1          SAVE REG 14 CONTENTS IN SAVEIT1\n         KKPARSE\n         LTR   R15,R15              RC = 0 ? (I.E PARSE GO OK ?)\n         BNZ   PARSERR              IF NOT, BRANCH TO PARSERR\n         MVC   PROCESSW,=C'YES'     MOVE 'YES' TO PROCESSW\n         L     R10,ANS\n         USING IKJPARMD,R10\n         B     EXITPARS\nPARSERR  MVC   PROCESSW,=C'NO '     MOVE 'NO ' TO PROCESSW\n         LA    R4,96                SET REG 4 = 96\n         MVC   OUTMSG,ERRMSG3       MOVE 'INVALID SYNTAX OF ONE OR\n*                                     MORE OPERANDS' TO OUTMSG\nEXITPARS L     R14,SAVEIT1\n         BR    14\n         EJECT\n********************************************************************\n*                                                                  *\n*        THIS ROUTINE PROCESSES THE PARSED FIELDS, AND LOADS       *\n*        THE FOLLOWING FIVE DATA FIELDS:                           *\n*                                                                  *\n*               INACTCD                                            *\n*               INDDNAME                                           *\n*               INDDNLEN                                           *\n*               INDSNAME                                           *\n*               INDSNLEN                                           *\n*                                                                  *\n********************************************************************\n*\nLOADFLDS ST    R14,SAVEIT2             SAVE REG 14 CONTENTS IN SAVEIT2\n         MVC   PROCESSW,=CL3'YES'      MOVE 'YES' TO PROCESSW\n*\n         B     MODVER13                MODIFICATION (VER 1.3) MADE CUZ\n*                                      THE FOLLOWING TEST IS NO LONGER\n*                                      NEEDED\n*\n         TM    ACTCDSTR+6,X'80'        IS ACTION CODE PRESENT ?\n         BNO   NOACTCD                 IF NOT, BRANCH TO NOACTCD\n*\nMODVER13 L     R8,ACTCDSTR             R8 ==> ADDRESS OF THE ACT CODE\n         MVC   INACTCD(1),0(R8)        MOVE ACT CODE TO INACTCD\n         CLI   INACTCD,C'A'            IS ACTION CODE = 'A' ?\n         BE    LOADDDN                 IF SO, BRANCH TO LOADDDN\n         CLI   INACTCD,C'D'            IS ACTION CODE = 'D' ?\n         BE    LOADDDN                 IF SO, BRANCH TO LOADDDN\n         MVC   PROCESSW,=CL3'NO '      MOVE 'NO ' TO PROCESSW\n         LA    R4,24                   SET REG 4 = 24\n         MVC   OUTMSG,ERRMSG7          MOVE 'INVALID ACTION CODE'\n*                                        TO OUTMSG\n         B     EXITLOAD                BRANCH TO EXITLOAD\nLOADDDN  TM    DDNSTRNG+6,X'80'        IS DDNAME PRESENT ?\n         BNO   NODDNAME                IF NOT, BRANCH TO NODDNAME\n         MVC   INDDNAME,=CL8' '        MOVE SPACES TO INDDNAME\n         LA    R1,INDDNAME             R1 ==> ADDRESS OF INDDNAME\n         L     R8,DDNSTRNG             R8 ==> ADDRESS OF THE DDNAME\n         LH    R7,DDNSTRNG+4           R7 ==> LENGTH OF THE DDNAME\n         S     R7,=F'1'                SUBTRACT 1 FOR EX\n         SPACE 1\nMOVEDDN  MVC   0(0,R1),0(R8)           MOVE THE DDNAME TO INDDNAME\n         EX    R7,MOVEDDN\n         SPACE 1\n         MVC   INDDNLEN(2),DDNSTRNG+4  INDDNLEN ==> LENGTH OF DDNAME\n         TM    DSNSTRNG+6,X'80'        IS DSNAME PRESENT ?\n         BNO   NODSNAME                IF NOT, BRANCH TO NODSNAME\n         MVC   INDSNAME,=CL44' '       MOVE SPACES TO INDSNAME\n         LA    R1,INDSNAME             R1 ==> ADDRESS OF INDSNAME\n         L     R8,DSNSTRNG             R8 ==> ADDRESS OF THE DSNAME\n         LH    R7,DSNSTRNG+4           R7 ==> LENGTH OF THE DSNAME\n         S     R7,=F'1'                SUBTRACT 1 FOR EX\n         SPACE 1\nMOVEDSN  MVC   0(0,R1),0(R8)           MOVE THE DSNAME TO INDSNAME\n         EX    R7,MOVEDSN\n         SPACE 1\n         MVC   INDSNLEN(2),DSNSTRNG+4  INDSNLEN ==> LENGTH OF DSNAME\n         B     EXITLOAD                BRANCH TO EXITLOAD\nNOACTCD  MVC   PROCESSW,=CL3'NO '      MOVE 'NO ' TO PROCESSW\n         LA    R4,12                   SET REG 4 = 12\n         MVC   OUTMSG,ERRMSG4          MOVE 'MISSING ACTION CODE'\n*                                        TO OUTMSG\n         B     EXITLOAD                BRANCH TO EXITLOAD\nNODDNAME MVC   PROCESSW,=CL3'NO '      MOVE 'NO ' TO PROCESSW\n         LA    R4,16                   SET REG 4 = 16\n         MVC   OUTMSG,ERRMSG5          MOVE 'MISSING DDNAME' TO OUTMSG\n         B     EXITLOAD                BRANCH TO EXITLOAD\nNODSNAME MVC   PROCESSW,=CL3'NO '      MOVE 'NO ' TO PROCESSW\n         LA    R4,20                   SET REG 4 = 20\n         MVC   OUTMSG,ERRMSG6          MOVE 'MISSING DSNAME' TO OUTMSG\nEXITLOAD L     R14,SAVEIT2\n         BR    R14\n         EJECT\n*\n********************************************************************\n*                                                                  *\n*        THIS IS THE MAJOR ROUTINE OF THIS PROGRAM.  IT WILL       *\n*        EXAMINE THE ACTION CODE TO SEE IF THE USER REQUESTED      *\n*        CONCATENATION OR DECONCATENATION.  IF THE USER REQUESTED  *\n*        CONCATENATION, THEN THIS ROUTINE WILL CONCATENATE THE     *\n*        DSNAME PASSED TO IT IN FRONT OF THE EXISTING              *\n*        CONCATENATED DATASETS TO THE GIVEN DDNAME.  IF THE USER   *\n*        REQUESTED DECONCATENATION, THEN THIS ROUTINE WILL         *\n*        REMOVE THE DSNAME PASSED TO IT FROM THE CONCATENATION.    *\n*                                                                  *\n********************************************************************\n*\nMAJORTN  ST    R14,SAVEIT3            SAVE REG 14 IN SAVEIT3\n         MVI   DDNTABLE,X'FF'                  ---\n         MVC   DDNTABLE+1(199),DDNTABLE          ---\n         MVI   DDNTABLE+200,X'FF'                    --- INIT DDNTABLE\n         MVC   DDNTABLE+201(199),DDNTABLE+200    ---\n         MVI   DDNTABLE+400,X'FF'              ---\n         MVC   DDNTABLE+401(99),DDNTABLE+400   ---\n         CLI   INACTCD,C'A'           ACTION CODE = 'A' ?\n         BNE   UNALLOC                IF NOT, BRANCH TO UNALLOC\n         MVC   GTDSNDDN,INDDNAME      MOVE INDDNAME TO GTDSNDDN\n         BAL   R14,GETDSNS            PERFORM ROUTINE TO DETERMINE\n*                                        WHETHER THE DDNAME IS\n*                                        ALLOCATED AND IF SO TO OBTAIN\n*                                        LIST OF ASSOCIATED DSNAMES\n         CLI   GTDSNSW,C'0'           WAS DDNAME ALREADY ALLOCATED ?\n         BE    CONCAT3                IF SO, BRANCH TO CONCAT3\n         CLI   GTDSNSW,C'1'           WAS DDNAME NOT ALREADY ALLOCATED?\n         BE    CONCAT2                IF SO, BRANCH TO CONCAT2\n         MVC   OUTMSG,ERRMSG9         MOVE 'MORE THAN 50 DATASETS\n*                                        ALREADY ALLOCATED' TO OUTMSG\n         LA    R4,32                  SET R4 TO 32\n         B     EXITMAJR               BRANCH TO EXITMAJR\nCONCAT2  LA    R7,DDNTABLE            R7==> ADDRESS OF DDNTABLE\n         MVC   ALLOCDSN,INDSNAME      MOVE DSNAME TO ALLOCDSN\n         MVC   ALLOCDDN,INDDNAME      MOVE DDNAME TO ALLOCDDN\n         MVC   DDNLEN,INDDNLEN        MOVE LENGTH OF DDNAME TO DDNLEN\n         MVC   DSNLEN,INDSNLEN        MOVE LENGTH OF DSNAME TO DSNLEN\n         BAL   R14,DYNALLOK           PERFORM ROUTINE TO DO\n*                                        DYNAMIC ALLOCATION\n         CLC   ALLOCOK,=CL3'YES'      WAS ALLOCATION SUCCESSFUL ?\n         BE    CONCAT15               IF SO, BRANCH TO CONCAT15\n         MVC   OUTMSG,ALLOCMSG        MOVE DYNAMIC ALLOC ERR MSG\n*                                        TO OUTMSG\n         B     EXITMAJR               BRANCH TO EXITMAJR\nCONCAT3  MVC   DALLCDDN,INDDNAME      MOVE DDNAME TO DALLCDDN\n         MVC   DDNLEN,INDDNLEN        MOVE LENGTH OF DDNAME TO DDNLEN\n         BAL   R14,DEALLOK            PERFORM ROUTINE TO DO DYNAMIC\n*                                        DEALLOCATION\n         CLC   DALLCOK,=CL3'YES'      WAS DEALLOCATION SUCCESSFUL ?\n         BE    CONCAT4                IF SO, BRANCH TO CONCAT4\n         MVC   OUTMSG,DALLCMSG        MOVE DYNAMIC DEALLOC ERR MSG\n*                                        TO OUTMSG\n         B     EXITMAJR               BRANCH TO EXITMAJR\nCONCAT4  MVC   ALLOCDSN,INDSNAME      MOVE DSNAME TO ALLOCDSN\n         MVC   ALLOCDDN,INDDNAME      MOVE DDNAME TO ALLOCDDN\n         MVC   DDNLEN,INDDNLEN        MOVE LENGTH OF DDNAME TO DDNLEN\n         MVC   DSNLEN,INDSNLEN        MOVE LENGTH OF DSNAME TO DSNLEN\n         BAL   R14,DYNALLOK           PERFORM ROUTINE TO DO\n*                                        DYNAMIC ALLOCATION\n         CLC   ALLOCOK,=CL3'YES'      WAS ALLOCATION SUCCESSFUL ?\n         BE    CONCAT5                IF SO, BRANCH TO CONCAT5\n         MVC   OUTMSG,ALLOCMSG        MOVE DYNAMIC ALLOC ERR MSG\n*                                        TO OUTMSG\n         B     EXITMAJR               BRANCH TO EXITMAJR\nCONCAT5  LH    R6,DSNSCNT             R6==> NO OF SIGNIF ENTRIES IN\n*                                        DSNAMES TABLE\n         LA    R7,0                   R7==> 0\n         LA    R8,DSNSTABL            R8==> ADDRESS OF DSNAMES TABLE\n         LA    R9,DDNTABLE            R9==> ADDRESS OF GENERATED\n*                                        DDNAMES TABLE\nCONCAT6  CR    R7,R6                  HAVE WE ALLOCATED ALL OF THE\n*                                        DSNAMES ?\n         BE    CONCAT8                IF SO, BRANCH TO CONCAT8\n         MVC   ALLOCDSN,6(R8)         ALLOCDSN==> DSNAME TO BE ALLOC\n         MVC   ALLOCDDN,=CL8'DDNRETRN'\n         MVC   DSNLEN,4(R8)           DSNLEN==> LENGTH OF DSNAME\n         BAL   R14,DYNALLOK           PERFORM ROUTINE TO DO DYNAMIC\n*                                        ALLOC & RETURN GEN DDNAME\n         CLC   ALLOCOK,=CL3'YES'      WAS ALLOCATION SUCCESSFUL ?\n         BE    CONCAT7                IF SO, BRANCH TO CONCAT7\n         MVC   OUTMSG,ALLOCMSG        MOVE DYNAMIC ALLOC ERR MSG\n*                                        TO OUTMSG\n         B     EXITMAJR               BRANCH TO EXITMAJR\nCONCAT7  MVC   0(2,R9),ALLOCU1A       LOAD LENGTH OF DDNAME ENTRY\n*                                        INTO DDNAMES TABLE\n         MVC   2(8,R9),ALLOCU1B       LOAD DDNAME INTO DDNAMES TABLE\n         A     R7,=F'1'               ADD 1 TO REG 7\n         A     R8,=F'50'              ADD 50 TO REG 8\n         A     R9,=F'10'              ADD 10 TO REG 9\n         B     CONCAT6                BRANCH TO CONCAT6\nCONCAT8  LA    R6,DSNSTABL            R6==> ADDRESS OF DSNSTABL\n         LA    R7,0                   R7==> 0\n         LH    R8,DSNSCNT             R8==> # OF SIGNIFICANT\n*                                         ENTRIES IN DSNSTABL\nCONCAT10 CR    R7,R8                  HAVE WE EXHAUSTED THE DSNSTABL ?\n         BE    CONCAT13               IF SO, BRANCH TO CONCAT13\n         CLC   6(L'CLSTLIB1,R6),CLSTLIB1\n         BE    CONCAT11\n         A     R6,=F'50'              BUMP R6 BY 50\n         A     R7,=F'1'               BUMP R7 BY 1\n         B     CONCAT10               BRANCH TO CONCAT10\nCONCAT11 LA    R6,DSNSTABL            R6==> ADDRESS OF DSNSTABL\n         LA    R7,0                   R7==> 0\nCONCAT12 CR    R7,R8                  HAVE WE EXHAUSTED THE DSNSTABL ?\n         BE    CONCAT13               IF SO, BRANCH TO CONCAT13\n         CLC   6(L'CLSTLIB2,R6),CLSTLIB2\n         BE    CONCAT18\n         A     R6,=F'50'              BUMP R6 BY 50\n         A     R7,=F'1'               BUMP R7 BY 1\n         B     CONCAT12               BRANCH TO CONCAT12\nCONCAT13 LA    R7,DDNTABLE            R7==> ADDRESS OF DDNTABLE\n         LA    R8,49\nCONCAT14 CLC   0(2,R7),=X'FFFF'\n         BE    CONCAT15\n         A     R7,=F'10'\n         BCT   R8,CONCAT14\n         MVC   OUTMSG,ERRMSG9         MOVE 'MORE THAN 50 DATASETS\n*                                        ALREADY ALLOCATED' TO OUTMSG\n         LA    R4,32                  SET R4 TO 32\n         B     EXITMAJR               BRANCH TO EXITMAJR\nCONCAT15 CLC   INDDNAME(7),=C'SYSPROC'\n         BNE   CONCAT18\n         MVC   ALLOCDSN,=CL44' '\n         MVC   ALLOCDSN(L'CLSTLIB1),CLSTLIB1\n         MVC   ALLOCDDN,=CL8'DDNRETRN'\n         LA    R8,L'CLSTLIB1\n         STH   R8,DSNLEN\n         BAL   R14,DYNALLOK           PERFORM ROUTINE TO DO\n*                                        ALLOC & RETURN GEN DDNAME\n         CLC   ALLOCOK,=CL3'YES'      WAS ALLOCATION SUCCESSFUL ?\n         BE    CONCAT16               IF SO, BRANCH TO CONCAT16\n         MVC   OUTMSG,ALLOCMSG        MOVE DYNAMIC ALLOC ERR MSG\n*                                        TO OUTMSG\n         B     EXITMAJR               BRANCH TO EXITMAJR\nCONCAT16 MVC   0(2,R7),ALLOCU1A\n         MVC   DDNLEN,ALLOCU1A\n         LH    R6,DDNLEN              R6==> LENGTH OF THE DDNAME\n         S     R6,=F'1'               SUBTRACT 1 FOR EX\n         SPACE 1\nMOVEDDN1 MVC   2(0,R7),ALLOCU1B\n         EX    R6,MOVEDDN1\n         SPACE 1\n         A     R7,=F'10'\n         MVC   ALLOCDSN,=CL44' '\n         MVC   ALLOCDSN(L'CLSTLIB2),CLSTLIB2\n         MVC   ALLOCDDN,=CL8'DDNRETRN'\n         LA    R8,L'CLSTLIB2\n         STH   R8,DSNLEN\n         BAL   R14,DYNALLOK           PERFORM ROUTINE TO DO\n*                                        ALLOC & RETURN GEN DDNAME\n         CLC   ALLOCOK,=CL3'YES'      WAS ALLOCATION SUCCESSFUL ?\n         BE    CONCAT17               IF SO, BRANCH TO CONCAT17\n         MVC   OUTMSG,ALLOCMSG        MOVE DYNAMIC ALLOC ERR MSG\n*                                        TO OUTMSG\n         B     EXITMAJR               BRANCH TO EXITMAJR\nCONCAT17 MVC   0(2,R7),ALLOCU1A\n         MVC   DDNLEN,ALLOCU1A\n         LH    R6,DDNLEN              R6==> LENGTH OF THE DDNAME\n         S     R6,=F'1'               SUBTRACT 1 FOR EX\n         SPACE 1\nMOVEDDN2 MVC   2(0,R7),ALLOCU1B\n         EX    R6,MOVEDDN2\n         SPACE 1\nCONCAT18 CLC   DDNTABLE(2),=X'FFFF'\n         BE    EXITMAJR\n         MVC   CNCATDDN,INDDNAME\n         BAL   R14,CONCAT             PERFORM ROUTINE TO DO THE\n*                                        DYNAMIC CONCATENATION\n         CLC   CNCATOK,=CL3'YES'      WAS THE CONCATENATION SUCCESSFUL\n         BE    EXITMAJR               IF SO, BRANCH TO EXITMAJR\n         MVC   OUTMSG,CNCATMSG        MOVE DYNAMIC CONCAT ERR MSG\n*                                        TO OUTMSG\n         B     EXITMAJR               BRANCH TO EXITMAJR\nUNALLOC  MVC   GTDSNDDN,INDDNAME      MOVE INDDNAME TO GTDSNDDN\n         BAL   R14,GETDSNS            PERFORM ROUTINE TO DETERMINE\n*                                        WHETHER THE DDNAME IS\n*                                        ALLOCATED AND IF SO TO OBTAIN\n*                                        LIST OF ASSOCIATED DSNAMES\n         CLI   GTDSNSW,C'0'           WAS DDNAME ALLOCATED ?\n         BE    UNALLOC3               IF SO, BRANCH TO UNALLOC3\n         CLI   GTDSNSW,C'1'           WAS DDNAME NOT ALLOCATED?\n         BE    UNALLOC2               IF SO, BRANCH TO UNALLOC2\n         MVC   OUTMSG,ERRMSG9         MOVE 'MORE THAN 50 DATASETS\n*                                        ALREADY ALLOCATED' TO OUTMSG\n         LA    R4,32                  SET R4 TO 32\n         B     EXITMAJR               BRANCH TO EXITMAJR\nUNALLOC2 MVC   OUTMSG,ERRMSG10        MOVE 'CANNOT DO DEALLOCATION --\n*                                       DDNAME NOT ALLOCATED' TO OUTMSG\n         LA    R4,36                  SET R4 TO 36\n         B     EXITMAJR               BRANCH TO EXITMAJR\nUNALLOC3 LA    R6,DSNSTABL            R6==> ADDRESS OF DSNAMES TABLE\n         LH    R7,DSNSCNT             R7==> NO OF SIGNIFICANT ENTRIES\n*                                        IN THAT TABLE\n         LA    R8,0                   R8==> 0\nUNALLOC4 CR    R7,R8                  HAVE WE EXHAUSTED THE TABLE ?\n         BNE   UNALLOC5               IF NOT, BRANCH TO UNALLOC5\n         MVC   OUTMSG,ERRMSG11        MOVE 'CANNOT DO DEALLOCATION --\n*                                       DSNAME NOT ALLOCATED' TO OUTMSG\n         LA    R4,40                  SET R4 TO 40\n         B     EXITMAJR               BRANCH TO EXITMAJR\nUNALLOC5 CLC   INDSNAME,6(R6)         GIVEN DSNAME = DSNAME OF\n*                                         TABLE ENTRY ?\n         BE    UNALLOC6               IF SO, BRANCH TO UNALLOC6\n         A     R6,=F'50'              ADD 50 TO REG 6\n         A     R8,=F'1'               ADD 1 TO REG 8\n         B     UNALLOC4               BRANCH TO UNALLOC4\nUNALLOC6 MVC   DALLCDDN,INDDNAME      MOVE DDNAME TO DALLCDDN\n         MVC   DDNLEN,INDDNLEN        MOVE LENGTH OF DDNAME TO DDNLEN\n         BAL   R14,DEALLOK            PERFORM ROUTINE TO DO DYNAMIC\n*                                        DEALLOCATION\n         CLC   DALLCOK,=CL3'YES'      WAS DEALLOCATION SUCCESSFUL ?\n         BE    UNALLOC7               IF SO, BRANCH TO UNALLOC7\n         MVC   OUTMSG,DALLCMSG        MOVE DYNAMIC DEALLOC ERR MSG\n*                                        TO OUTMSG\n         B     EXITMAJR               BRANCH TO EXITMAJR\nUNALLOC7 CLC   DSNSCNT,=BL2'0001'     WAS THERE ONLY ONE DSNAME\n*                                        ALLOCATED TO THE DDNAME ?\n         BE    EXITMAJR               IF SO, BRANCH TO EXITMAJR\n         MVC   MAJORGUY,=CL3'YES'\n         LH    R6,DSNSCNT             R6==> NO OF SIGNIF ENTRIES IN\n*                                        DSNAMES TABLE\n         LA    R7,0                   R7==> 0\n         LA    R8,DSNSTABL            R8==> ADDRESS OF DSNAMES TABLE\n         LA    R9,DDNTABLE            R9==> ADDRESS OF GENERATED\n*                                        DDNAMES TABLE\nUNALLOC8 CR    R7,R6                  HAVE WE ALLOCATED ALL OF THE\n*                                        DSNAMES ?\n         BE    UNALLC11               IF SO, BRANCH TO UNALLC11\n         CLC   INDSNAME,6(R8)         IS THIS THE DSNAME THAT IS\n*                                        TO BE DEALLOCATED ?\n         BE    UNALLC10               IF SO, BRANCH TO UNALLC10\n         MVC   ALLOCDSN,6(R8)         ALLOCDSN==> DSNAME TO BE ALLOC\n         MVC   DSNLEN,4(R8)           DSNLEN==> LENGTH OF DSNAME\n         CLC   MAJORGUY,=CL3'YES'     IS DIS DA 1ST GUY IN THE TABLE?\n         BE    UNALLC8A               IF SO, BRANCH TO UNALLC8A\n         MVC   ALLOCDDN,=CL8'DDNRETRN'\n         B     UNALLC8B               BRANCH TO UNALLC8B\nUNALLC8A MVC   ALLOCDDN,INDDNAME      MOVE DDNAME TO ALLOCDDN\n         MVC   DDNLEN,INDDNLEN        MOVE LENGTH OF DDNAME TO DDNLEN\nUNALLC8B BAL   R14,DYNALLOK           PERFORM ROUTINE TO DO DYNAMIC\n*                                        ALLOC & RETURN GEN DDNAME\n         CLC   ALLOCOK,=CL3'YES'      WAS ALLOCATION SUCCESSFUL ?\n         BE    UNALLOC9               IF SO, BRANCH TO UNALLOC9\n         MVC   OUTMSG,ALLOCMSG        MOVE DYNAMIC ALLOC ERR MSG\n*                                        TO OUTMSG\n         B     EXITMAJR               BRANCH TO EXITMAJR\nUNALLOC9 CLC   MAJORGUY,=CL3'YES'     IS DIS DA 1ST GUY IN THE TABLE?\n         BNE   UNALLC9A               IF NOT, BRANCH TO UNALLC9A\n         MVC   MAJORGUY,=CL3'NO '     MOVE 'NO ' TO MAJORGUY\n         B     UNALLC10               BRANCH TO UNALLC10\nUNALLC9A MVC   0(2,R9),ALLOCU1A       LOAD LENGTH OF DDNAME ENTRY\n*                                        INTO DDNAMES TABLE\n         MVC   2(8,R9),ALLOCU1B       LOAD DDNAME INTO DDNAMES TABLE\n         A     R9,=F'10'              ADD 10 TO REG 9\nUNALLC10 A     R7,=F'1'               ADD 1 TO REG 7\n         A     R8,=F'50'              ADD 50 TO REG 8\n         B     UNALLOC8               BRANCH TO UNALLOC8\nUNALLC11 LH    R7,DSNSCNT\n         C     R7,=F'2'\n         BNH   EXITMAJR\n         MVC   CNCATDDN,INDDNAME\n         BAL   R14,CONCAT             PERFORM ROUTINE TO DO THE\n*                                        DYNAMIC CONCATENATION\n         CLC   CNCATOK,=CL3'YES'      WAS THE CONCATENATION SUCCESSFUL\n         BE    EXITMAJR               IF SO, BRANCH TO EXITMAJR\n         MVC   OUTMSG,CNCATMSG        MOVE DYNAMIC CONCAT ERR MSG\n*                                        TO OUTMSG\nEXITMAJR L     R14,SAVEIT3\n         BR    R14\n         EJECT\n*\n********************************************************************\n*                                                                  *\n*        THIS ROUTINE IS RESPONSIBLE FOR DYNAMICALLY ALLOCATING    *\n*        (VERB CODE 01) THE DSNAME PASSED TO THIS ROUTINE IN       *\n*        DATA FIELD ALLOCDSN                                       *\n*                                                                  *\n*        BEFORE PERFORMING THIS ROUTINE, DO THE FOLLOWING:         *\n*                                                                  *\n*           1.  MOVE THE DSNAME TO BE ALLOCATED TO ALLOCDSN        *\n*           2.  IF YOU WISH TO LET THE ROUTINE ASSIGN A UNIQUE     *\n*                  DDNAME OF ITS CHOICE                            *\n*                       MOVE 'DDNRETRN' TO ALLOCDDN                *\n*               ELSE                                               *\n*                       MOVE THE DDNAME TO ALLOCDDN.               *\n*           3.  MOVE THE LENGTH OF THE DDNAME TO DDNLEN            *\n*                  (NOT NEEDED IF WE WISH TO LET THE ROUTINE       *\n*                   ASSIGN A UNIQUE DDNAME OF ITS CHOICE)          *\n*           4.  MOVE THE LENGTH OF THE DSNAME TO DSNLEN            *\n*                                                                  *\n*                                                                  *\n*        AFTER PERFORMING THIS ROUTINE, DO THE FOLLOWING:          *\n*                                                                  *\n*           INTERROGATE ALLOCOK                                    *\n*                                                                  *\n*                IF ALLOCOK = 'YES'                                *\n*                    THEN THE ALLOCATION WAS SUCCESSFUL AND        *\n*                    DATA FIELD ALLOCMSG IS SPACES                 *\n*                                                                  *\n*                IF ALLOCOK IS NOT EQUAL TO 'YES'                  *\n*                    THEN THE ALLOCATION WAS NOT SUCCESSFUL AND    *\n*                    DATA FIELD ALLOCMSG CONTAINS A MEANINGFUL     *\n*                    MESSAGE AS TO WHY IT WASN'T                   *\n*                                                                  *\n********************************************************************\n*\nDYNALLOK ST    R14,SAVEIT4             SAVE REG 14 IN SAVEIT4\n         MVC   ALLOCOK,=CL3'YES'       MOVE 'YES' TO ALLOCOK\n         MVC   ALLOCMSG,=CL44' '       MOVE SPACES TO ALLOCMSG\n         CLC   ALLOCDDN,=CL8'DDNRETRN' ALLOCDDN = 'DDNRETRN' ?\n         BE    DYNALLK1                IF SO, BRANCH TO DYNALLK1\n         MVC   ALLOCUT1,=X'0001'       MOVE X'0001' TO ALLOCUT1\n         MVC   ALLOCU1A,DDNLEN         MOVE LEN OF DDNAME TO ALLOCU1A\n         MVC   ALLOCU1B,ALLOCDDN       MOVE DDNAME TO ALLOCU1B\n         B     DYNALLK2                BRANCH TO DYNALLK2\nDYNALLK1 MVC   ALLOCUT1,=X'0055'       MOVE X'0055' TO ALLOCUT1\n         MVC   ALLOCU1A,=X'0008'       MOVE X'0008' TO ALLOCU1A\n         MVC   ALLOCU1B,=CL8' '        MOVE SPACES TO ALLOCU1B\nDYNALLK2 MVC   ALLOCU2A,DSNLEN         MOVE LEN OF DSNAME TO ALLOCU2A\n         MVC   ALLOCU2B,ALLOCDSN       MOVE DSNAME TO ALLOCU2B\n         LA    R1,ALLOCPRM\n         DYNALLOC                      ALLOC F(DDNAME) DA(DSN) SHR\n         LTR   R15,R15                 TEST REGISTER 15 FOR ZERO\n         BZ    EXITALLC                IF ZERO, BRANCH TO EXITALLC\n         MVC   ALLOCOK,=CL3'NO '       MOVE 'NO ' TO ALLOCOK\n         MVC   ALLOCMSG,ERRMSG1        MOVE DYNAMIC ALLOC ERR MSG\n*                                        TO ALLOCMSG\n         MVC   HEXINPUT,ALLOCERC       LOAD HEXINPUT WITH ERR REASON CD\n         BAL   R14,UNPKHEX             PERFORM ROUTINE TO UNPACK THE\n*                                         ERR REASON CODE INTO HEXOUT\n         MVC   ALLOCMSG+39(4),HEXOUT   MOVE UNPACKED ERR REASON CODE\n*                                        TO ALLOCMSG\n         LA    R4,4                    SET R4 TO 4\nEXITALLC L     R14,SAVEIT4             RESTORE REGISTER 14\n         BR    R14                     RETURN\n         EJECT\n*\n********************************************************************\n*                                                                  *\n*        THIS ROUTINE IS RESPONSIBLE FOR DYNAMICALLY DE-ALLOCATING *\n*        (VERB CODE 02) THE DDNAME PASSED TO THIS ROUTINE IN       *\n*        DATA FIELD DALLCDDN                                       *\n*                                                                  *\n*        BEFORE PERFORMING THIS ROUTINE, DO THE FOLLOWING:         *\n*                                                                  *\n*           1.  MOVE THE DDNAME TO BE FREED TO DALLCDDN            *\n*           2.  MOVE THE LENGTH OF THAT DDNAME TO DDNLEN           *\n*                                                                  *\n*                                                                  *\n*        AFTER PERFORMING THIS ROUTINE, DO THE FOLLOWING:          *\n*                                                                  *\n*           INTERROGATE DALLCOK                                    *\n*                                                                  *\n*                IF DALLCOK = 'YES'                                *\n*                    THEN THE DE-ALLOCATION WAS SUCCESSFUL AND     *\n*                    DATA FIELD DALLCMSG IS SPACES                 *\n*                                                                  *\n*                IF DALLCOK IS NOT EQUAL TO 'YES'                  *\n*                    THEN THE DE-ALLOCATION WAS NOT SUCCESSFUL AND *\n*                    DATA FIELD DALLCMSG CONTAINS A MEANINGFUL     *\n*                    MESSAGE AS TO WHY IT WASN'T                   *\n*                                                                  *\n********************************************************************\n*\nDEALLOK  ST    R14,SAVEIT5             SAVE REG 14 IN SAVEIT5\n         MVC   DALLCOK,=CL3'YES'       MOVE 'YES' TO DALLCOK\n         MVC   DALLCMSG,=CL44' '       MOVE SPACES TO DALLCMSG\n         MVC   FREEUT1A,DDNLEN         MOVE LEN OF DDNAME TO FREEUT1A\n         MVC   FREEUT1B,DALLCDDN       MOVE THE DDNAME TO FREEUT1B\n         LA    R1,FREEPARM\n         DYNALLOC                      FREE F(DDNAME)\n         LTR   R15,R15                 TEST REGISTER 15 FOR ZERO\n         BZ    EXITFREE                IF ZERO, BRANCH TO EXITFREE\n         MVC   DALLCOK,=CL3'NO '       MOVE 'NO ' TO DALLCOK\n         MVC   DALLCMSG,ERRMSG2        MOVE DYNAMIC DEALLOC ERR MSG\n*                                        TO DALLCMSG\n         MVC   HEXINPUT,FREEERC        LOAD HEXINPUT WITH ERR REASON CD\n         BAL   R14,UNPKHEX             PERFORM ROUTINE TO UNPACK THE\n*                                         ERR REASON CODE INTO HEXOUT\n         MVC   DALLCMSG+41(4),HEXOUT   MOVE UNPACKED ERR REASON CODE\n*                                        TO DALLCMSG\n         LA    R4,8                    SET R4 TO 8\nEXITFREE L     R14,SAVEIT5             RESTORE REGISTER 14\n         BR    R14                     RETURN\n         EJECT\n*\n********************************************************************\n*                                                                  *\n*        THIS ROUTINE IS RESPONSIBLE FOR CONCATENATING             *\n*        (VERB CODE 03) ALL OF THE DDNAMES IN THE TABLE DDNTABLE   *\n*        TO THE DDNAME GIVEN IN CNCATDDN                           *\n*                                                                  *\n*        BEFORE PERFORMING THIS ROUTINE, DO THE FOLLOWING:         *\n*                                                                  *\n*            1.  LOAD THE TABLE OF DDNAMES DDNTABLE                *\n*            2.  LOAD THE DATA FIELD CNCATDDN WITH THE DDNAME      *\n*                   THAT ALL OF THE OTHER DDNAMES ARE TO BE        *\n*                   CONCATENATED TO                                *\n*                                                                  *\n*                                                                  *\n*        AFTER PERFORMING THIS ROUTINE, DO THE FOLLOWING:          *\n*                                                                  *\n*           INTERROGATE DALLCOK                                    *\n*                                                                  *\n*                IF CNCATOK = 'YES'                                *\n*                    THEN THE CONCATENATION WAS SUCCESSFUL AND     *\n*                    DATA FIELD CNCATMSG IS SPACES                 *\n*                                                                  *\n*                IF CNCATOK IS NOT EQUAL TO 'YES'                  *\n*                    THEN THE CONCATENATION WAS NOT SUCCESSFUL AND *\n*                    DATA FIELD CNCATMSG CONTAINS A MEANINGFUL     *\n*                    MESSAGE AS TO WHY IT WASN'T                   *\n*                                                                  *\n********************************************************************\n*\nCONCAT   ST    R14,SAVEIT6             SAVE REG 14 IN SAVEIT6\n         MVC   CNCATOK,=CL3'YES'       MOVE 'YES' TO CNCATOK\n         MVC   CNCATMSG,=CL44' '       MOVE SPACES TO CNCATMSG\n         MVC   CNCTABLE(2),INDDNLEN\n         LA    R1,CNCTABLE+2\n         LA    R8,CNCATDDN             R8==> ADDRESS OF CNCATDDN\n         LH    R5,INDDNLEN             R5==> LENGTH OF INDDNAME\n         S     R5,=F'1'                SUBTRACT 1 FOR EX\n         SPACE 1\nMOVEDD1  MVC   0(0,R1),0(R8)\n         EX    R5,MOVEDD1              MOVE INDDNAME TO CNCTABLE\n         LA    R6,1                    R6==> 1\n         LA    R8,CNCTABLE\n         A     R5,=F'3'\n         AR    R8,R5\n         LA    R7,DDNTABLE\nCMPR4FF  CLC   0(2,R7),=X'FFFF'        HAVE WE EXHAUSTED THE DDNTABLE?\n         BE    LOADNMBR                IF SO, BRANCH TO LOADNMBR\n         MVC   0(2,R8),0(R7)\n         A     R8,=F'2'\n         LH    R5,0(R7)\n         A     R7,=F'2'\n         S     R5,=F'1'                SUBTRACT 1 FOR EX\n         SPACE 1\nMOVEDD2  MVC   0(0,R8),0(R7)\n         EX    R5,MOVEDD2              MOVE INDDNAME TO CNCTABLE\n         A     R6,=F'1'\n         A     R7,=F'8'\n         A     R5,=F'1'\n         AR    R8,R5\n         B     CMPR4FF\nLOADNMBR STH   R6,CNCTNMBR\n         LA    R1,CNCTPARM\n         DYNALLOC                      DYNAMIC CONCATENATION\n         LTR   R15,R15                 TEST REGISTER 15 FOR ZERO\n         BZ    EXITCNCT                IF ZERO, BRANCH TO EXITCNCT\n         MVC   CNCATOK,=CL3'NO '       MOVE 'NO ' TO CNCATOK\n         MVC   CNCATMSG,ERRMSG8        MOVE DYNAMIC CONCAT ERR MSG\n*                                        TO CNCATMSG\n         MVC   HEXINPUT,CNCTERC        LOAD HEXINPUT WITH ERR REASON CD\n         BAL   R14,UNPKHEX             PERFORM ROUTINE TO UNPACK THE\n*                                         ERR REASON CODE INTO HEXOUT\n         MVC   CNCATMSG+41(4),HEXOUT   MOVE UNPACKED ERR REASON CODE\n*                                        TO CNCATMSG\n         LA    R4,28                   SET R4 TO 28\nEXITCNCT L     R14,SAVEIT6\n         BR    R14\n         EJECT\n*\n********************************************************************\n*                                                                  *\n*        THIS ROUTINE IS RESPONSIBLE FOR DETERMINING WHETHER THE   *\n*        DDNAME PASSED TO IT IS ALLOCATED.  IF IT IS ALLOCATED,    *\n*        THEN THIS ROUTINE PASSES BACK ALL OF THE ASSOCIATED       *\n*        DSNAMES (AND THEIR LENGTHS)                               *\n*                                                                  *\n*        BEFORE PERFORMING THIS ROUTINE, MOVE THE DDNAME TO        *\n*        GTDSNDDN                                                  *\n*                                                                  *\n*        AFTER PERFORMING THIS ROUTINE, DO THE FOLLOWING:          *\n*                                                                  *\n*          .  INTERROGATE GTDSNSW                                  *\n*                                                                  *\n*             .  IF GTDSNSW = 0, THEN THE DDNAME WAS INDEED        *\n*                  ALLOCATED AND THE DSNAMES TABLE IS THEN LOADED  *\n*                  INTO DSNSTABL AND THE NUMBER OF SIGNIFICANT     *\n*                  ENTRIES IN THAT TABLE IS IN DSNSCNT (EACH ENTRY *\n*                  IN THE TABLE IS 50 BYTES LONG.  THE LENGTH OF   *\n*                  THE DSNAME IS IN BYTES 5-6 AND THE DSNAME IS    *\n*                  IN BYTES 7-50)                                  *\n*                                                                  *\n*             .  IF GTDSNSW = 1, THEN THE DDNAME WAS NOT ALLOCATED *\n*                                                                  *\n*             .  IF GTDSNSW = 2, THEN THERE ARE MORE THAN 50       *\n*                  DATASETS CONCATENATED TO THE DDNAME FOUND IN    *\n*                  GTDSNDDN                                        *\n*                                                                  *\n********************************************************************\n*\nGETDSNS  ST    R14,SAVEIT7             SAVE REG 14 IN SAVEIT7\n         CALL  DSNTAB,(GTDSNDDN,DSNSTABL,TABLSIZE,DSNSCNT),VL,         X\n               MF=(E,LISTKALL)\n         C     R15,=F'4'\n         BE    RC4\n         C     R15,=F'8'\n         BE    RC8\n         MVI   GTDSNSW,C'0'\n         B     EXITDSNS\nRC4      MVI   GTDSNSW,C'1'\n         B     EXITDSNS\nRC8      MVI   GTDSNSW,C'2'\nEXITDSNS L     R14,SAVEIT7\n         BR    R14\n         EJECT\n*\n********************************************************************\n*                                                                  *\n*        THIS ROUTINE IS RESPONSIBLE FOR CONVERTING A TWO BYTE     *\n*        BINARY FIELD (SUCH AS X'0438') TO A FOUR BYTE CHARACTER   *\n*        FIELD (SUCH AS 0438)                                      *\n*                                                                  *\n*        BEFORE PERFORMING THIS ROUTINE, MOVE THE TWO BYTE BINARY  *\n*        FIELD TO BE CONVERTED TO HEXINPUT                         *\n*                                                                  *\n*        AFTER PERFORMING THIS ROUTINE, YOUR TWO BYTE BINARY       *\n*        FIELD WILL BE CONVERTED TO 4 CHARACTER BYTES IN HEXOUT    *\n*                                                                  *\n********************************************************************\n*\nUNPKHEX  ST    R14,SAVEIT8             SAVE REG 14 IN SAVEIT8\nBASEREG2 DS    0H\n*ASEREG2 MVC   CHARLEN,=XL2'0004'      CHARLEN IS LENGTH OF HEXOUT\n*        MVC   CNVTYPE,=CL3'HTC'       HTC ==> HEX TO CHAR CONVERSION\n         CALL  HEXTRAN,(HEXOUT,HEXINPUT,=XL2'0004',=CL3'HTC'),VL,      X\n               MF=(E,LISTKALL)\n         L     R14,SAVEIT8             RESTORE REGISTER 14\n         BR    R14                     RETURN\n         EJECT\n********************************************************************\n*                                                                  *\n*        BUILD UPDTLIST (IKJUPDT PARM LIST)                        *\n*                                                                  *\n********************************************************************\n*\nINITLIST ST    R14,SAVEIT9\n         MVC   UPDTUPT,CPPLUPT          UPT\n         MVC   UPDTECT,CPPLECT          ECT\n         LA    R9,ECB\n         ST    R9,UPDTECB               ECB\n         LA    R8,UPLIST\n         ST    R8,UPDTUPL               UPLIST\n         L     R14,SAVEIT9\n         BR    14\n         EJECT\n********************************************************************\n*                                                                  *\n*        BUILD UPDATE PARM LIST FOR &OUTMSG AND CALL IKJUPDT       *\n*                                                                  *\n********************************************************************\n*\nSETOUTMG ST    R14,SAVEIT10\n         LA    R9,=C'OUTMSG'       R9 ==> ADDRESS OF VAR NAME\n         ST    R9,LOCPTR           STORE ADDR OF VAR NAME IN LOCPTR\n         MVC   LOCLEN,=F'6'        LOCLEN = LENGTH OF VAR NAME\n         LA    R5,OUTMSG           R5 ==> ADDRESS OF VARIABLE\n         ST    R5,VALPTR           STORE ADDRESS OF VARIABLE IN VALPTR\n         MVC   VALLEN,=F'46'       VALLEN = LENGTH OF DATA FIELD\n         LA    R1,UPDTLIST         R1 ==> IKJUPDT PARM LIST\n         CALL  IKJUPDT             DO THE UPDATE\n         L     R14,SAVEIT10\n         BR    14\n         EJECT\n********************************************************************\n*                                                                  *\n*        E N D   O F   J O B   R O U T I N E                       *\n*                                                                  *\n********************************************************************\n*\nSHUTDOWN LR   R15,R4\n         LEAVER\n         EJECT\n         SPACE 3\n********************************************************************\n*                                                                  *\n*        D A T A   A R E A   C O N S T A N T S                     *\n*                                                                  *\n********************************************************************\n*\nCHARLEN  DS    BL2\nCLSTLIB1 DC    CL18'WDPSC.MASTER.CLIST'\nCLSTLIB2 DC    CL10'USER.CLIST'\nGOODMSG  DC    CL46'SUCCESSFUL COMPLETION                         '\nERRMSG1  DC    CL46'DYNAMIC ALLOC ERROR (ERR REASON CODE =     )  '\nERRMSG2  DC    CL46'DYNAMIC DEALLOC ERROR (ERR REASON CODE =     )'\nERRMSG3  DC    CL46'INVALID SYNTAX OF ONE OR MORE OPERANDS       )'\nERRMSG4  DC    CL46'MISSING ACTION CODE                          )'\nERRMSG5  DC    CL46'MISSING DDNAME PARAMETER                     )'\nERRMSG6  DC    CL46'MISSING DSNAME PARAMETER                     )'\nERRMSG7  DC    CL46'INVALID ACTION CODE  (MUST BE A OR D)        )'\nERRMSG8  DC    CL46'DYNAMIC CONCAT  ERROR (ERR REASON CODE =     )'\nERRMSG9  DC    CL46'MORE THAN 50 DATASETS ALREADY ALLOCATED      )'\nERRMSG10 DC    CL46'CANNOT DO DEALLOCATION -- DDNAME NOT ALLOCATED'\nERRMSG11 DC    CL46'CANNOT DO DEALLOCATION -- DSNAME NOT ALLOCATED'\nTABLSIZE DC    H'2500'\n*\n*\n*\n*\n         EJECT\n*\n********************************************************************\n*                                                                  *\n*        DYNAMIC ALLOCATION INIT BLOCK   (VERB CODE 01)            *\n*                                                                  *\n********************************************************************\n*\nDALLINIT DC    X'80'         TURN ON HIGH ORDER BIT\n         DC    AL3(0)        ADDRESS OF REQUEST BLOCK\n         DC    X'14'         S99RBLN (LENGTH OF REQUEST BLOCK)\n         DC    X'01'         S99VERB (REQUEST FOR DSNAME ALLOC)\n         DC    X'A000'       S99FLAG1 (DO NOT MOUNT VOLUMES)\n         DC    X'0000'       S99ERROR (ERROR REASON CODE)\n         DC    X'0000'       S99INFO (INFORMATION REASON CODE)\n         DC    A(0)          S99TXTPP (ADDR OF POINTERS TO TEXT UNITS\n         DC    X'00000000'   RESERVED\n         DC    X'00000000'   S99FLAG2\n         DC    A(0)          ADDRESS OF TEXT UNIT #1\n         DC    A(0)          ADDRESS OF TEXT UNIT #2\n         DC    A(0)          ADDRESS OF TEXT UNIT #3\n         DC    X'80'         TURN ON HIGH ORDER BIT\n         DC    AL3(0)        ADDRESS OF TEXT UNIT #4\n         DS    CL2           EITHER X'0001' OR X'0055'\n         DC    X'0001'\n         DS    BL2           LENGTH OF DDNAME\n         DS    CL8           DDNAME\n         DC    X'0002'\n         DC    X'0001'\n         DS    BL2           LENGTH OF DSNAME\n         DS    CL44          DSNAME\n         DC    X'0004',X'0001',X'0001',X'08'\n         DC    X'0052',X'0000'\nALLOCLEN EQU   *-DALLINIT\n         EJECT\n********************************************************************\n*                                                                  *\n*        DATA STRUCTURE FOR DE-ALLOCATION  (VERB CODE 02)          *\n*                                                                  *\n********************************************************************\nFREEINIT DC    X'80'         TURN ON HIGH ORDER BIT\n         DC    AL3(0)        ADDRESS OF REQUEST BLOCK\n         DC    X'14'         S99RBLN (LENGTH OF REQUEST BLOCK)\n         DC    X'02'         S99VERB (REQUEST FOR UNALLOCATION)\n         DC    X'2000'       S99FLAG1 (DO NOT MOUNT VOLUMES)\n         DC    X'0000'       S99ERROR (ERROR REASON CODE)\n         DC    X'0000'       S99INFO (INFORMATION REASON CODE)\n         DC    A(0)          S99TXTPP (ADDR OF POINTER TO TEXT UNIT)\n         DC    X'00000000'   RESERVED\n         DC    X'00000000'   S99FLAG2\n         DC    A(0)          ADDRESS OF TEXT UNIT #1\n         DC    X'80'         TURN ON HIGH ORDER BIT\n         DC    AL3(0)        ADDRESS OF TEXT UNIT #2\n         DC    X'0001'\n         DC    X'0001'\n         DS    BL2\n         DS    CL8\n         DC    X'0007'\n         DC    X'0000'\nFREELEN  EQU   *-FREEINIT\n         EJECT\n********************************************************************\n*                                                                  *\n*        DATA STRUCTURE FOR CONCATENATION   (VERB CODE 03)         *\n*                                                                  *\n********************************************************************\nCNCTINIT DC    X'80'         TURN ON HIGH ORDER BIT\n         DC    AL3(0)        ADDRESS OF REQUEST BLOCK\n         DC    X'14'         S99RBLN (LENGTH OF REQUEST BLOCK)\n         DC    X'03'         S99VERB (REQUEST FOR CONCATENATION)\n         DC    X'2000'       S99FLAG1 (DO NOT MOUNT VOLUMES)\n         DC    X'0000'       S99ERROR (ERROR REASON CODE)\n         DC    X'0000'       S99INFO (INFORMATION REASON CODE)\n         DC    A(0)          S99TXTPP (ADDR OF POINTER TO TEXT UNIT)\n         DC    X'00000000'   RESERVED\n         DC    X'00000000'   S99FLAG2\n         DC    X'80'         TURN ON HIGH ORDER BIT\n         DC    AL3(0)        ADDRESS OF TEXT UNIT\n         DC    X'0001'\n         DS    BL2\n         DS    CL500\nCNCTLEN  EQU   *-CNCTINIT\n         EJECT\n********************************************************************\n*                                                                  *\n*        S T A T I C   W O R K   A R E A                           *\n*                                                                  *\n********************************************************************\n         LTORG\n         EJECT\n********************************************************************\n*                                                                  *\n*        D Y N A M I C   W O R K   A R E A                         *\n*                                                                  *\n********************************************************************\n*\nWORKAREA DSECT\nSAVEAREA DS    18F\nALLOCDDN DS    CL8\nALLOCDSN DS    CL44\nALLOCMSG DS    CL46\nALLOCOK  DS    CL3\nANS      DS    F\nCNCATDDN DS    CL8\nCNCATMSG DS    CL46\nCNCATOK  DS    CL3\nDALLCDDN DS    CL8\nDALLCMSG DS    CL46\nDALLCOK  DS    CL3\nDDNLEN   DS    H\nDDNTABLE DS    50CL10\nDDNEOT   DC    X'FFFF'\nDSNLEN   DS    H\nDSNSCNT  DS    H\nDSNSTABL DS    50CL50\nECB      DS    F\nGTDSNDDN DS    CL8\nGTDSNSW  DS    CL1\nHEXINPUT DS    XL2\nHEXOUT   DS    CL4\nINACTCD  DS    CL1\n         DS    0D\nINDDNAME DS    CL8\nINDDNLEN DS    H\nINDSNAME DS    CL44\nINDSNLEN DS    H\nMAJORGUY DS    CL3\nOUTMSG   DS    CL46\nPPLA     DS    7F\nPROCESSW DS    CL3\nSAVEIT1  DS    F\nSAVEIT2  DS    F\nSAVEIT3  DS    F\nSAVEIT4  DS    F\nSAVEIT5  DS    F\nSAVEIT6  DS    F\nSAVEIT7  DS    F\nSAVEIT8  DS    F\nSAVEIT9  DS    F\nSAVEIT10 DS    F\n*\nUPDTLIST DS    0F\nUPDTUPT  DS    F\nUPDTECT  DS    F\nUPDTECB  DS    F\nUPDTUPL  DS    F\n*\nUPLIST   DS    0F\nLOCPTR   DS    AL4\nLOCLEN   DS    FL4\nVALPTR   DS    AL4\nVALLEN   DS    FL4\n*\nLISTKALL CALL  ,(0,0,0,0),VL,MF=L\n*\n*        DATA STRUCTURE FOR DYNAMIC ALLOCATION  (VERB CODE 01)\nALLOCPRM DS    0F\n         DC    X'80'         TURN ON HIGH ORDER BIT\n         DC    AL3(ALLOCRB)  ADDRESS OF REQUEST BLOCK\nALLOCRB  DC    X'14'         S99RBLN (LENGTH OF REQUEST BLOCK)\n         DC    X'01'         S99VERB (REQUEST FOR DSNAME ALLOC)\n         DC    X'A000'       S99FLAG1 (DO NOT MOUNT VOLUMES)\nALLOCERC DC    X'0000'       S99ERROR (ERROR REASON CODE)\n         DC    X'0000'       S99INFO (INFORMATION REASON CODE)\n         DC    A(ALLOCTUA)   S99TXTPP (ADDR OF POINTERS TO TEXT UNITS\n         DC    X'00000000'   RESERVED\n         DC    X'00000000'   S99FLAG2\nALLOCTUA DC    A(ALLOCUT1)   ADDRESS OF TEXT UNIT #1\n         DC    A(ALLOCUT2)   ADDRESS OF TEXT UNIT #2\n         DC    A(ALLOCUT3)   ADDRESS OF TEXT UNIT #3\n         DC    X'80'         TURN ON HIGH ORDER BIT\n         DC    AL3(ALLOCUT4) ADDRESS OF TEXT UNIT #4\nALLOCUT1 DS    CL2           EITHER X'0001' OR X'0055'\n         DC    X'0001'\nALLOCU1A DS    BL2           LENGTH OF DDNAME\nALLOCU1B DS    CL8           DDNAME\nALLOCUT2 DC    X'0002'\n         DC    X'0001'\nALLOCU2A DS    BL2           LENGTH OF DSNAME\nALLOCU2B DS    CL44          DSNAME\nALLOCUT3 DC    X'0004',X'0001',X'0001',X'08'\nALLOCUT4 DC    X'0052',X'0000'\n*\n*        DATA STRUCTURE FOR DE-ALLOCATION  (VERB CODE 02)\nFREEPARM DS    0F\n         DC    X'80'         TURN ON HIGH ORDER BIT\n         DC    AL3(FREERB)   ADDRESS OF REQUEST BLOCK\nFREERB   DC    X'14'         S99RBLN (LENGTH OF REQUEST BLOCK)\n         DC    X'02'         S99VERB (REQUEST FOR UNALLOCATION)\n         DC    X'2000'       S99FLAG1 (DO NOT MOUNT VOLUMES)\nFREEERC  DC    X'0000'       S99ERROR (ERROR REASON CODE)\n         DC    X'0000'       S99INFO (INFORMATION REASON CODE)\n         DC    A(FREETUPL)   S99TXTPP (ADDR OF POINTER TO TEXT UNIT)\n         DC    X'00000000'   RESERVED\n         DC    X'00000000'   S99FLAG2\nFREETUPL DC    A(FREEUNT1)   ADDRESS OF TEXT UNIT #1\n         DC    X'80'         TURN ON HIGH ORDER BIT\n         DC    AL3(FREEUNT2) ADDRESS OF TEXT UNIT #2\nFREEUNT1 DC    X'0001'\n         DC    X'0001'\nFREEUT1A DS    BL2\nFREEUT1B DS    CL8\nFREEUNT2 DC    X'0007'\n         DC    X'0000'\n*\n*        DATA STRUCTURE FOR CONCATENATION   (VERB CODE 03)\nCNCTPARM DS    0F\n         DC    X'80'         TURN ON HIGH ORDER BIT\n         DC    AL3(CNCTRB)   ADDRESS OF REQUEST BLOCK\nCNCTRB   DC    X'14'         S99RBLN (LENGTH OF REQUEST BLOCK)\n         DC    X'03'         S99VERB (REQUEST FOR CONCATENATION)\n         DC    X'2000'       S99FLAG1 (DO NOT MOUNT VOLUMES)\nCNCTERC  DC    X'0000'       S99ERROR (ERROR REASON CODE)\n         DC    X'0000'       S99INFO (INFORMATION REASON CODE)\n         DC    A(CNCTTUPL)   S99TXTPP (ADDR OF POINTER TO TEXT UNIT)\n         DC    X'00000000'   RESERVED\n         DC    X'00000000'   S99FLAG2\nCNCTTUPL DC    X'80'         TURN ON HIGH ORDER BIT\n         DC    AL3(CNCTUNT1) ADDRESS OF TEXT UNIT\nCNCTUNT1 DC    X'0001'\nCNCTNMBR DS    BL2\nCNCTABLE DS    CL500\nWORKLEN  EQU   *-WORKAREA\nCONCATEM CSECT\n         EJECT\n********************************************************************\n*                                                                  *\n*                   P A R S E   M A C R O S                        *\n*                                                                  *\n********************************************************************\n*\nPCL      IKJPARM\nACTCODE  IKJKEYWD DEFAULT='ACTCODE(A)'\n         IKJNAME 'ACTCODE',SUBFLD=ACTCD\nDDNAME   IKJKEYWD\n         IKJNAME 'DDNAME',SUBFLD=DDNAM,ALIAS=('FILE')\nDSNAME   IKJKEYWD\n         IKJNAME 'DSNAME',SUBFLD=DSNAM,ALIAS=('DATASET')\nACTCD    IKJSUBF\nACTCDSTR IKJIDENT 'ACT CODE',MAXLNTH=1,FIRST=ALPHA\nDDNAM    IKJSUBF\nDDNSTRNG IKJPOSIT DSNAME,DDNAM\nDSNAM    IKJSUBF\nDSNSTRNG IKJPOSIT DSNAME,USID\n         IKJENDP\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CONCATM$": {"ttr": 13319, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x00\\x7f\\x00\\x88\\x00\\x7f\\x12\\x00\\x00u\\x00u\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf2\\xf7\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-01-07T00:00:00", "modifydate": "1988-01-07T12:00:00", "lines": 117, "newlines": 117, "modlines": 0, "user": "FILE270"}, "text": "1                                                        CONCATEM.1\n                                                         06/25/82\n\n\n  COMMAND NAME:  CONCATEM\n  AUTHOR:        Jeff Sprehn\n  AGENCY:        WDPSC\n  FUNCTION:      Allocate    or    deallocate,    concatenate    or\n                 deconcatenate  the  given  dataset  to  the  given\n                 DDNAME.  In  the case of concatenation,  place the\n                 given dataset  \"at the  top of  the stack\"  of all\n                 datasets concatenated to that DDNAME.\n\n  __________________________________________________________________\n       Command        Operands\n  ------------------------------------------------------------------\n       CONCATEM       ACTCODE('action code') DDNAME('ddname') DSNAME('dsname')\n                                            or FILE\n  ------------------------------------------------------------------\n\n  Operands -\n\n       Required -\n\n            ACTCODE('action code') --'action code' is either 'A' or\n                                     'D'\n\n                           'A'  --   is    for     allocation    or\n                                     concatenation.  If  the DDNAME\n                                     is NOT already allocated, then\n                                     action code 'A'  allocates the\n                                     supplied DSNAME  to the  given\n                                     DDNAME.\n\n\n\n\n1                                                        CONCATEM.2\n                                                         06/25/82\n\n\n                                     If the DDNAME is already allocated, then ac\n                                     'A' concatenates the supplied DSNAME\n                                     to the given DDNAME at the front of the con\n\n                           'D'  --   is for deallocation or deconcatenation.\n                                     If the supplied DSNAME is the only DSNAME\n                                     allocated to the given DDNAME, then that DD\n\n                                     If the supplied DSNAME is NOT the\n                                     only DSNAME allocated to the given\n                                     DDNAME, then only that DSNAME is removed\n                                     associated with that DDNAME.\n\n                                               DDNAME('ddname')    -- 'ddname'\n            or FILE                  the allocate, deallocate, concatenate,\n                                     or deconcatenate.\n\n            DSNAME('dsname')    --   'dsname' is the DSNAME for the allocate,\n                                     deallocate, concatenate, or deconcatenate.\n\n\n\n\n1                                                        CONCATEM.3\n                                                         06/25/82\n\n\n  This  command  has  two  variables that  an  invoking  CLIST  may\n  interrogate.  Below is a table of  values after execution of this\n  command for the two variables &OUTMSG and &LASTCC (return code).\n\n       &LASTCC   &OUTMSG\n          0    SUCCESSFUL COMPLETION\n          4    DYNAMIC ALLOC ERROR (ERR REASON CODE = xxxx)\n          8    DYNAMIC DEALLOC ERROR (ERR REASON CODE =xxxx)\n         12    MISSING ACTION CODE\n         16    MISSING DDNAME PARAMETER\n         20    MISSING DSNAME PARAMETER\n         24    INVALID ACTION CODE (MUST BE A OR D)\n         28    DYNAMIC CONCAT ERROR (ERR REASON CODE = xxxx)\n         32    MORE THAN 50 DATASETS ALREADY ALLOCATED\n         36    CANNOT DO DEALLOCATION -- DDNAME NOT ALLOCATED\n         40    CANNOT DO DEALLOCATION -- DSNAME NOT ALLOCATED\n         96    INVALID SYNTAX OF ONE OR MORE OPERANDS\n\n\n\n\n1                                                        CONCATEM.4\n                                                         06/25/82\n\n\n  EXAMPLE:\n\n  Suppose that  the following  three datasets  are concatenated  to\n  DDNAME ISPPLIB in the order shown:\n\n            AGNCY999.ISPF.PANELS\n            AGNCY999.PAYROLL.PNLS\n            AGNCY999.REMIT.PANELS\n\n  Then, the following command was issued:\n\n       CONCATEM ACTCODE(A) DDNAME(ISPPLIB) DSNAME('AGNCY999.NEW.PANELS')\n\n  After  execution of  this  command, the  four  datasets would  be\n  concatenated to DDNAME ISPPLIB in the order shown:\n\n            AGNCY999.NEW.PANELS\n            AGNCY999.ISPF.PANELS\n            AGNCY999.PAYROLL.PNLS\n            AGNCY999.REMIT.PANELS\n\n\n\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CONTROL": {"ttr": 13322, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x00\\x7f\\x00\\x88\\x00\\x7f\\x12\\x00\\x01\\x05\\x01\\x05\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf2\\xf7\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-01-07T00:00:00", "modifydate": "1988-01-07T12:00:00", "lines": 261, "newlines": 261, "modlines": 0, "user": "FILE270"}, "text": "./ ADD NAME=DOCUMEN  0105-86044-86190-1648-00113-00003-00000-KK00150\n  1\n                   WDPSC STATUS REPORT SYSTEM\n\n\n    This status report system requires the structure of the WDPSC DOCSYS\n    to function.  That system requires ISPF/DM.  The panel definitions\n    and processing are supported by features of DOCSYS.\n\n\n    USER FLOW OF THE SYSTEM:\n\n    The system consists of several screens.  A system selection screen,\n    a month selection screen and a screen listing the individual users.\n\n    The month selection screen also contains the CONTROL data.  This\n    data is contained in a dataset - _____.______.CONTROL.  The name\n    and location of this dataset determines the name and location of\n    the monthly datasets.  They will be placed on the same volume it\n    is located on and will have names like  ______.______.JAN86 where\n    the _____ matches the qualifier of the Control file.\n    DCB Characteristics of these OS PDS datasets are:\n        RECFM=VB,LRECL=     ,BLKSIZE=\n\n    The monthly datasets will be created the first time the month is\n    selected by anyone and the control dataset's PATTERN member (as it\n    exists at that time) will be copied into the monthly dataset.  All\n    monthly datasets as well as the control dataset have copies of the\n    Pattern member.  Be aware that these may be different depending on\n    changes which may have been made to the PATTERN.\n\n    When a user selects his name on the user screen he is in browse\n    mode.  If the member is empty an error message - NOT AVAILABLE will\n    be returned to him.\n\n    When a user Edits his name on the user screen for the first time a\n    copy of the current pattern member from the monthly dataset will be\n    copied into the member.  The user may then delete any topics which\n    do not apply to him and begin inserting data under any topics which\n    are applicable.\n\n    When several people have entered their data the 'boss' may wish\n    to Edit the member called Consolidated.  It does a real-time merge\n    of the data contained in the other members of the monthly dataset\n    and places it in member ALL (a required member name).  This merge\n    relies on the topic lines from the monthly dataset's PATTERN member\n    matching those topic lines in the user's data. Take care when altering\n    a pattern which people may have already begun using.\n\n    There are messages at the top of the Consolidated data indicating\n    which of the users contributed to the merge - remember they may have\n    only entered one line, thus the recommendation of a DONE/INPROGRESS\n    topic in the pattern.  Each time the Consolidated member is Edited a\n    merge is done.  To view what was present the last time without doing\n    a merge do a Select on the member instead of an Edit.\n\n    When the data in the Consolidated member is 'done'.  Edit the\n    'To boss' entry.  This will copy the data from the consolidated\n    member into another one (FINAL - also a required name) where it may\n    be edited for submission to 'the boss'.  Only an Edit done when\n    member FINAL is empty will result in a copy from the consolidated\n    member.\n\n    Any of the selections may be printed by using P.\n    The screen displayed is used elsewhere in DOCSYS for printing of\n    data.  Options available are ROTATE90, 3800 FTL or VPS to a cluster\n    printer.\n\n    PATTERN HINTS:\n    The Pattern topics are single line entries and are required to have\n    a X'aa' at the start of the topic line.\n    Patterns may be underscored by using +_______ with the + in col 1.\n    Any data other than that on the topic or underscore lines will\n    be copied into individual reports and merged along with real data\n    into the merged reports (thus being repeated n times).  i.e. single\n    line topics are best.\n\n    A recommended topic for inclusion is one which indicates whether\n    users are DONE or IN PROGRESS with changes to their members.\n    Without this editing of FINAL data may begin before all user entries\n    are available.\n\n  1 UPDATES OF THE SYSTEM PANELS\n\n    NEW YEAR UPDATE:\n     E  the system selection line. There is a reference to the year in\n        the first 80 characters and again as you scroll to the right.\n        Update those references and END the screen.\n     Go to the month selection screen.\n     E  each of the months.  There is a reference to the year after you\n        scroll to the right.  Update that reference and END the screen.\n\n     NEW USER UPDATE:\n      Go to the month selection screen.\n      E  each month.  Repeat an existing user line (not one of the special\n         ones - just a normal user line).  Change the new line to contain\n         the new user's name in the selection area.  Scroll to the right\n         and specify the users name there too (must be appropriate for use\n         as a PDS member name).\n         END the screen.\n\n      NEW GROUP USING SYSTEM:\n       Verify their access to the clists, panels and skels required to\n       support the STATUS system functions - found on the various panels\n       of the system.  If they have no access then provide it to them.\n       How varies with the case.\n\n       Decide on high level qualifiers.\n       CREATE a dataset  'hiqual'.'nextqual'.CONTROL\n       Create the screens required for month and user selection.\n          Easy if you copy from an existing system.\n       Keep member names PATTERN, ALL and FINAL on the setup panels.\n          These names are system requirements.\n       Do PR & training and GO.\n./ ADD NAME=OLDPAT   0100-86210-86210-1717-00063-00063-00000-KX00150\n1\n-\n  TO:      Your Bossss\n  FROM:\n  SUBJECT: Status Report, ..month.. 1986\n  DATE:    .... .., 198.\n\n\n \u00a1STATUS of status report; Enter your name and condition of report.\n+ ______\n\n\n \u00a1MVS\n+ ___\n\n\n \u00a1UTILITIES\n+ _________\n\n\n \u00a1LANGUAGES\n+ _________\n\n\n \u00a1TSO\n+ ___\n\n\n \u00a1JES2\n+ ____\n\n\n \u00a1DATABASE\n+ ________\n\n\n \u00a1VM/PROFS - including VS/1, RSCS, etc\n+ ________\n\n\n \u00a1GENERAL SYSTEM - items like data set movement, DASD, error situations\n+ ______________\n\n\n \u00a1PERFORMANCE/CAPACITY\n+ ____________________\n\n\n \u00a1ACF2\n+ ____\n\n\n \u00a1MISCELLANEOUS\n+ _____________\n\n\n \u00a1NEXT QUARTER'S MAJOR EVENTS\n+ ___________________________\n\n\n \u00a1OPINION - keep it clean\n+ _______\n\n./ ADD NAME=PATTERN  0113-86013-86210-1718-00065-00040-00000-KX00150\n1\n-\n  TO:      Your Bossss\n  FROM:\n  SUBJECT: Status Report, ..month.. 1986\n  DATE:    .... .., 198.\n\n\n \u00a1STATUS of status report; Enter your name and condition of report.\n+ ______\n\n\n \u00a1MVS\n [MVS2\n [MVS3\n [MVS4\n\n\n \u00a1UTILITIES\n+ _________\n\n\n \u00a1LANGUAGES\n+ _________\n\n\n \u00a1TSO\n+ ___\n\n\n \u00a1JES2\n+ ____\n\n\n \u00a1DATABASE\n+ ________\n\n\n \u00a1VM/PROFS - including VS/1, RSCS, etc\n+ ________\n\n\n \u00a1GENERAL SYSTEM - items like data set movement, DASD, error situations\n+ ______________\n\n\n \u00a1PERFORMANCE/CAPACITY\n+ ____________________\n\n\n \u00a1ACF2\n+ ____\n\n\n \u00a1MISCELLANEOUS\n+ _____________\n\n\n \u00a1NEXT QUARTER'S MAJOR EVENTS\n+ ___________________________\n\n\n \u00a1OPINION - keep it clean\n+ _______\n\n./ ADD NAME=SCRIPT   0103-86059-86247-1344-00016-00016-00000-KX00150\n.rf cancel\n.bm +3\n.ll 65\n.fo off\n.ti ! 05\n.tb set 10\nTO:!Super Boss\n!Manager, Something......\n.sk 1\nFROM:!Just Boss\n!Manager, A group\n!WASHINGTON DATA PROCESSING SERVICE CENTER\n.sk 1\nDATE:!month, 19__\n.sk 1\n.fo on\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "CONVDATE": {"ttr": 13572, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x00\\x7f\\x00\\x88\\x00\\x7f\\x12\\x00\\x00\\xe5\\x00\\xe5\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf2\\xf7\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-01-07T00:00:00", "modifydate": "1988-01-07T12:00:00", "lines": 229, "newlines": 229, "modlines": 0, "user": "FILE270"}, "text": "*          DATA SET 752DZCONV3 AT LEVEL 003 AS OF 06/04/82\n*          DATA SET 140SWCONVD AT LEVEL 001 AS OF 08/25/71\n*        DATE CONVERSION\n*\n**   MODIFIED BY WDPSC TO MAKE CODE RE-ENTRANT.\n*        THE UNUSED STORAGE IN THE INPUT SAVEAREA IS USED.\n*\n*        A COBOL DRIVER PROGRAM TO TEST THIS MODULE FOLLOWS THE END\n*        CARD IN THIS PANVALET DATASET.  IT MAY BE COMPILED BY\n*        USING THE PROPER 'SELECT WORK' CARD.\n*\n         PUNCH ' ALIAS  JTOSDATE '\n         PUNCH ' ALIAS  STOJDATE '\n*\n**   SYMBOLIC REGISTERS\nR15 EQU 15 - BASE\nR14 EQU 14 - RETURN\nR13 EQU 13 - SAVE AREA\nR12      EQU   12\nR11      EQU   11\nR5       EQU   5\nR1  EQU 1  - PARM POINTER\n*\n*\nCONVDATE CSECT\n*\n*        THIS SUBPROGRAM CONVERTS JULIAN DATES TO STANDARD OR\n*              STANDARD DATES TO JULIAN BY USING ALTERNATE\n*              ENTRY POINTS\n*\n*           JULIAN TO STANDARD--CALL 'JTOSDATE' AND PROVIDE JULIAN\n*                   DATE AND AN AREA TO RECEIVE STANDARD DATE\n*           STANDARD TO JULIAN--CALL 'STOJDATE' AND PROVIDE STANDARD\n*                   DATE AND AN AREA TO RECEIVE JULIAN DATE\n*\n         ENTRY JTOSDATE,STOJDATE\n*\n*        THIS SUBROUTINE CONVERTS ANY 5-DIGIT JULIAN DATE PROVIDED\n*              IN EXTERNAL DECIMAL FORMAT (YYDDD) TO A 6-DIGIT\n*              STANDARD DATE IN EXTERNAL DECIMAL FORMAT (YYMMDD)\n*\n**     ATTRIBUTES - RE-ENTRANT\n*\nJTOSDATE EQU   *    ENTRY FOR JULIAN-TO-STANDARD CONVERSION\n         SAVE  (14,1)    SAVE REGS 14, 15, 0, 1\n         USING JTOSDATE,R15        MODULE BASE\n         USING SAVEAREA,R13        STORAGE BASE\n         L     R1,0(,R1)           LOAD PARM POINTER\n         PACK  JYR,0(2,R1)         PACK YEAR\n         PACK  JDAY,2(3,R1)        PACK JULIAN DAY\n         ZAP   MO1,=P'1'           INITIALIZE FIELD 'MO1'\n         ZAP   MOCNT,MO1           INITIALIZE MONTH\n         LA    R14,TABLE\n*                         CONSIDER LEAP YEAR\n         ZAP   LYR,JYR\n         DP    LYR,=P'4'\n         CP    LYR+3(1),=P'0'\n         BNE   NOTLYR         IF NOT A LEAP YEAR\n         CP    JDAY,=P'60'    LEAP YEAR\n         BL    NOTLYR\n         BH    PASTFEB\n         MVC   SMO,=C'02'     FEB 29\n         MVC   SDAY,=C'29'\n         B     MVCYR\nPASTFEB  SP    JDAY,=P'1'     PAST FEB 29\n*                         CONVERT ANY DATE EXCEPT FEB 29\nNOTLYR   CP    0(2,R14),JDAY       TO STANDARD DATE\n         BNL   MVCDATE\n         SP    JDAY,0(2,R14)       SET UP TO TEST NEXT\n         AP    MOCNT,=P'1'         MONTH AND\n         LA    R14,2(,R14)         LOOP BACK\n         B     NOTLYR\n*                         UNPACK AND FORMAT STANDARD DATE\nMVCDATE  UNPK  DAY,JDAY       DAY\n         MVZ   DAY+2(1),DAY+1\n         MVC   SDAY,DAY+1\n         UNPK  MONTH,MOCNT    MONTH\n         MVZ   MONTH+2(1),MONTH+1\n         MVC   SMO,MONTH+1\nMVCYR    UNPK  YEAR,JYR       YEAR\n         MVZ   YEAR+2(1),YEAR+1\n         MVC   SYR,YEAR+1\n*                         PLACE STANDARD DATE IN PASSED\n         L     R1,S1               PARAMETER LIST\n         L     R14,4(R1)           CALLER'S AREA\n         MVC   0(6,R14),SDATE      MOVE SDATE INTO CALLER'S AREA\n         LA    R15,0               ZERO R/C\n         L     R14,S14             RETURN TO\n         BR    R14                 CALLER\n         SPACE\n*        THIS SUBROUTINE CONVERTS ANY 6-DIGIT STANDARD DATE PROVIDED\n*              IN EXTERNAL DECIMAL FORMAT (YYMMDD) TO A 5-DIGIT\n*              JULIAN DATE IN EXTERNAL DECIMAL FORMAT (YYDDD)\n*\n         DROP  R15\nSTOJDATE DS    0F   ENTRY FOR STANDARD-TO-JULIAN CONVERSION\n*\n         SAVE  (14,1)    SAVE REGS 14, 15, 0, 1\n         ST    R12,S12\n         ST    R11,S11\n         LR    R12,R15\n         USING STOJDATE,R12\n         SPIE  DATAEXCP,(7)\n         ST    R1,HOLD\n         L     R1,S1                   LOAD PARM POINTER\n         L     R1,0(,R1)\n         PACK  JYR,0(2,R1)         YEAR\n         PACK  PMONTH,2(2,R1)      MONTH\n         PACK  PDAY,4(2,R1)        DAY\n*\n*\n         CP    PMONTH,=P'12'            D ZEIGLER  8-1-77\n         BH    ABEND12                  D ZEIGLER  8-1-77\n*                         INITIALIZE COUNTERS\n         ZAP   MO1,=P'1'           INITIALIZE FIELD 'MO1'\n         ZAP   MOCNT,MO1\n         ZAP   JDAY,=P'0'\n         LA    R14,TABLE\n*                         CONVERT ANY DATE TO JULIAN DATE\nCKMONTH  CP    PMONTH,MOCNT\n         BE    CKLYR\n         AP    JDAY,0(2,R14)       SET UP TO CHECK NEXT\n         AP    MOCNT,=P'1'         MONTH AND\n         LA    R14,2(,R14)         LOOP BACK\n         B     CKMONTH\nCKLYR    AP    JDAY,PDAY\n*                         CONSIDER LEAP YEAR\n         ZAP   LYR,JYR\n         DP    LYR,=P'4'\n         CP    LYR+3(1),=P'0'\n         BNE   CMPDAY                   D ZEIGLER  8-1-77\n         CP    PMONTH,=P'2'\n         BE    CHK29                    D ZEIGLER  8-1-77\n         BL    CMPDAY\n         CP    0(2,R14),PDAY\n         BL    ABEND31\n         AP    JDAY,=P'1'     PAST FEB\n*                         UNPACK AND FORMAT JULIAN DATE\nSKPLYR   UNPK  YEAR,JYR\n         MVZ   YEAR+2(1),YEAR+1\n         UNPK  DAY,JDAY\n         MVZ   DAY+2(1),DAY+1\n*                         PLACE JULIAN DATE IN PASSED\n         L     R1,S1               PARAMETER LIST\n         L     R14,4(R1)           CALLER'S AREA\n         MVC   0(5,R14),JULDATE    MOVE JDATE INTO CALLER'S AREA\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n         L     R12,S12\n         L     R11,HOLD\n         SPIE  MF=(E,(11))\n         L     R11,S11\n         SR    R15,R15\n         L     R14,S14             RETURN TO\n         BR    R14                 CALLER\nCMPDAY   CP    0(2,R14),PDAY            D ZEIGLER   8-1-77\n         BL    ABEND31                  D ZEIGLER   8-1-77\n         B     SKPLYR                   D ZEIGLER   8-1-77\nDATAEXCP ABEND 7,DUMP\nCHK29    CP    PDAY,=P'29'              D ZEIGLER   8-1-77\n         BH    ABEND31                  D ZEIGLER   8-1-77\n         B     SKPLYR                   D ZEIGLER   8-1-77\nABEND12 ABEND 12                       D ZEIGLER  8-1-77\nABEND31 ABEND 31                       D ZEIGLER  8-1-77\n         SPACE\n*                         CONSTANTS AND WORK AREAS\n         SPACE\nSAVEAREA DSECT      REGISTER SAVE AREA; ALSO USED FOR STORAGE\n         DS    3A\nS14      DS    A\nS15      DS    A\nS0       DS    A\nS1       DS    A\n*\nSDATE    DS    0CL6           STANDARD DATE--EXTERN DEC\nSYR      DS    CL2\nSMO      DS    CL2\nSDAY     DS    CL2\n*\nYEAR     DS    0CL3\n         DS    CL1\nJULDATE  DS    0CL5           JULIAN DATE--EXTERN DEC\n         DS    CL2\nDAY      DS    CL3\nMONTH    DS    CL3\n*\nJYR      DC    PL2'0'         JULIAN DATE--PACKED\nJDAY     DC    PL2'0'\n*\nPMONTH   DC    PL2'0'         INTERMEDIATE WORK AREAS\nPDAY     DC    PL2'0'\nLYR      DC    PL4'0'\nMO1      DC    P'1'              INITIALIZE MONTH COUNT\nMOCNT    DC    PL2'0'            MONTH COUNTER\n*                             TABLE OF MONTH LENGTHS\n*\nHOLD     DC    F'0'\nS11      DS    A\nS12      DS    A\n*\n         ORG   SAVEAREA+72\n         SPACE\nCONVDATE CSECT\n         LTORG\n         SPACE\nTABLE    DS    0CL24\n         DC    P'31'             JAN\n         DC    P'28'             FEB\n         DC    P'31'             MAR\n         DC    P'30'             APR\n         DC    P'31'             MAY\n         DC    P'30'             JUNE\n         DC    P'31'             JULY\n         DC    P'31'             AUG\n         DC    P'30'             SEPT\n         DC    P'31'             OCT\n         DC    P'30'             NOV\n         DC    P'31'             DEC\n*\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CRY": {"ttr": 13577, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x00\\x7f\\x00\\x88\\x00\\x7f\\x12\\x00\\x01O\\x01O\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf2\\xf7\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-01-07T00:00:00", "modifydate": "1988-01-07T12:00:00", "lines": 335, "newlines": 335, "modlines": 0, "user": "FILE270"}, "text": "ENCRYPT  CSECT\n*\n*\n***********************************************************************\n***********************************************************************\n*                                                                     *\n*        AUTHOR: D.L.SCHWARZ                                          *\n*                                                                     *\n*        DATE: OCT. 17, 1985. - VERSION 2, MOD. 0                     *\n*                                                                     *\n*        FUNCTION:                                                    *\n*                                                                     *\n*           THIS MODULE PERFORMS THE FUNCTION OF ENCRYPTION AND       *\n*           DECRYPTION OF DATA OPERATING AS A PRIMARY COMMAND         *\n*           UNDER ISPF/PDF EDIT.  THE MODULE IS LINKED INTO THE       *\n*           COMMAND LIBRARY UNDER THE NAME 'CRY'.                     *\n*                                                                     *\n*                                                                     *\n*        OPERATION:                                                   *\n*                                                                     *\n*           THE ENCRYPTION IS PERFORMED BY UTILIZING A KEY VALUE      *\n*           SUPPLIED AS AN OPERAND OF THE PRIMARY COMMAND.  THIS      *\n*           VALUE IS PASSED TO PROGRAM R050A90 AT ENTRY 'SETKEY',     *\n*           FOLLOWED BY RECURSIVE CALLS TO THE PROGRAM AT ENTRY       *\n*           POINTS 'ENCIPH' OR 'DECIPH', DEPENDING ON THE FUNCTION    *\n*           DESIRED.                                                  *\n*                                                                     *\n*           EXAMPLES OF USE:                                          *\n*                                                                     *\n*           !CRY ENCRYPT,KEYVALUE                                     *\n*           !CRY DECRYPT,KEYVALUE                                     *\n*                                                                     *\n*           THE 'KEYVALUE' IS A USER SUPPLIED KEYWORD WHICH IS        *\n*           MASSAGED AND USED AS THE ENCRYPT/DECRYPT CODE VALUE.      *\n*           THE KEYWORD IS LIMITED TO EIGHT (8) BYTES IN LENGTH,      *\n*           BUT MAY BE SHORTER, THIS PROGRAM WILL PAD IT TO THE       *\n*           CORRECT LENGTH.                                           *\n*                                                                     *\n*        CHANGES/UPDATES:                                             *\n*                                                                     *\n*           10/17/85.  VERSION 2, MODIFICATION 0.                     *\n*                                                                     *\n*                                                                     *\n***********************************************************************\n***********************************************************************\n*\n***********************************************************************\n*                                                                     *\n*                      REGISTER EQUATES                               *\n*                                                                     *\n***********************************************************************\n*\nR0       EQU   0\nR1       EQU   1\nPARMREG  EQU   1\nR2       EQU   2\nPREG     EQU   2\nKEYREG   EQU   2\nR3       EQU   3\nR4       EQU   4                    WORK REG\nR5       EQU   5                    WORK REG\nR6       EQU   6                    WORK REG\nR7       EQU   7                    WORK REG\nR8       EQU   8                    WORK REG\nR9       EQU   9                    WORK REG\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13                   SAVE AREA PTR.\nR14      EQU   14                   RETURN REGISTER\nR15      EQU   15                   RETURN CODE REG.\n*\n***********************************************************************\n*                                                                     *\n*                 GENERAL EQUATES                                     *\n*                                                                     *\n***********************************************************************\n*\n*\nBLANK    EQU   64                   BLANK\nZERO     EQU   0                    BINARY ZERO\nKEYVAL   EQU   KEY\n*\n*\n*\n         USING ENCRYPT,R15          ESTABLISH BASE\n         B     BEGIN\n*\n         DC    CL36' ENCRYPT  - VERSION 2.00 - 10/17/85. '\n*\nBEGIN    EQU   *\n         STM   14,12,12(R13)        SAVE ALL REGISTERS\n         LA    R2,SAVEA             OUR SAVE AREA\n         ST    R2,8(,R13)           CHAIN POINTER\n         ST    R13,SAVEA+4          CHAIN POINTER\n         LR    R13,R2               POINT TO OURS\n         LR    R12,R15\n         DROP  R15\n         USING ENCRYPT,R12          SET OUR BASE\n*\n***********************************************************************\n*        THE FOLLOWING CALLS TO ISPLINK ARE TO OBTAIN THE VALUES\n*        NECESSARY FOR THE OPERATION OF THE PROGRAM\n***********************************************************************\n*\n***********************************************************************\n*    1.  FIRST CALL TO OBTAIN THE FUCTION (ENCRYPT/DECRYPT)\n*        DESIRED, AND THE KEY VALUE.\n***********************************************************************\n*\n         CALL  ISPLINK,(VDEF,NL,FCDE,TYPEC,LEN8),VL\n*\n***********************************************************************\n*    2.  SECOND CALL TO DEFINE THE BUFFER AREA THAT WE WILL BE\n*        USING.\n***********************************************************************\n*\n         CALL  ISPLINK,(VDEF,LL,BUFFER,TYPEC,LEN256),VL\n*\n***********************************************************************\n*    3.  THIRD CALL TO OBTAIN THE LOGICAL RECORD LENGTH (LRECL) OF\n*        THE DATA WE ARE OPERATING ON.\n***********************************************************************\n*\n         CALL  ISPLINK,(VDEF,DL,LRECL,TYPEF,LEN4),VL\n*\n***********************************************************************\n*    4.  FOURTH CALL TO DEFINE THIS PROGRAM AS AN EDIT MACRO.\n***********************************************************************\n*\n         CALL  ISPLINK,(EDIT,LEN0,PARM1)\n*\n***********************************************************************\n*    5.  FIFTH CALL TO DEFINE THE LOGICAL RECORD LENGTH (LRECL) TO\n*        EDIT.\n***********************************************************************\n*\n         CALL  ISPLINK,(EDIT,LEN0,PARM2)\n*\n***********************************************************************\n*    6.  SIXTH CALL TO OBTAIN THE LINE NUMBER OF THE LAST RECORD IN\n*        THE CURRENT DATA SET.\n***********************************************************************\n*\n         CALL  ISPLINK,(EDIT,LEN0,PARM3)\n*\n***********************************************************************\n*    7.  SEVENTH CALL TO SET THE CURRENT PROFILE TO 'CAPS OFF' TO\n*        ASSURE THAT SPF WILL NOT FOLD THE ENCRYPTED DATA TO UPPER\n*        CASE.\n***********************************************************************\n*\n         CALL  ISPLINK,(EDIT,LEN0,PARM6)\n*\n***********************************************************************\n*        ALL NECESSARY PARAMETERS HAVE NOW BEEN OBTAINED AND DEFINED.\n*        NOW CHECK THE FUNCTION CODE FOR VALIDITY (ENCRYPT/DECRYPT).\n***********************************************************************\n*\n         OC    FCDE(7),BLANKS       FOLD THE CODE TO UPPER CASE\n         CLC   FCDE(7),ENCMDUP      COMPARE FOR OURS\n         BE    ENCIPH1              ITS US, GO PROCESS\n         CLC   FCDE(7),DECMDUP      COMPARE FOR OURS\n         BNE   EXIT                 NOT US, EXIT\n*\nDECIPH1  EQU   *\n         MVI   FUNC+3,X'04'         SET FUNCTION FOR DECRYPT\n         B     ITSUS                GO PROCESS\nENCIPH1  EQU   *\n         MVI   FUNC+3,X'00'         SET FUNCTION FOR ENCRYPT\n*\n***********************************************************************\n*        NOW CHECK THE KEY VALUE SPECIFIED.\n***********************************************************************\n*\nITSUS    EQU   *\n         SR    PREG,PREG\n         LA    PREG,KEY             POINT TO KEY\n         SR    R4,R4\nSEARCH   EQU   *\n         LA    R4,1(R4)             START COUNT\n         CH    R4,LIMIT             LIMIT REACHED?\n         BE    FOUNDB               YES\n         CLI   0(PREG),BLANK        FOUND BLANK?\n         BE    FOUNDB               YES\n         CLI   0(PREG),ZERO         BINARY ZEROS?\n         BE    FOUNDB               YES\n         LA    PREG,1(PREG)         NO, INCREMENT\n         B     SEARCH               AND GO BACK\nFOUNDB   EQU   *\n         CH    R4,ONE               ANY DATA?\n         BE    EXIT                 NO, EXIT\n*\n         OC    KEYVAL(8),BLANKS     FOLD TO UPPER CASE\n*\n***********************************************************************\n*        LINK TO THE EN/DECIPH PROGRAM AT ENTRY POINT 'SETKEY'\n*        TO ESTABLISH THE KEY VALUE.\n***********************************************************************\n*\n         LA    R1,KEYADD            SET UP PARM REG\n         L     R15,SETADD           ADDRESS OF SETKEY ENTRY\n         BALR  R14,R15              GO TO SETKEY\n         LTR   R15,R15              CHECK RETURN CODE\n         BNZ   ERRET                NOT ZERO, ERROR\n*\n         MVC   LINENO,=F'0'         SET LINE NUMBER TO ZERO\n*\nLOOP1    EQU   *\n         L     R11,LINENO           GET LINE NUMBER\n         LA    R11,1(,R11)          INCREMENT\n         ST    R11,LINENO           STORE BACK\n         CLC   LINENO,LLINE         LAST LINE DONE?\n         BH    EXIT                 YES, DONE\n*\n***********************************************************************\n*        CALL ISPLINK TO READ IN THE DESIGNATED LINE FROM THE\n*        DATA SET.\n***********************************************************************\n*\n         CALL  ISPLINK,(EDIT,LEN0,PARM4)\n*\n***********************************************************************\n*\n***********************************************************************\n*        CALL THE EN/DECIPH ROUTINE TO PERFORM THE EN/DECRYPTION\n*        ON THE CURRENT LINE.\n***********************************************************************\n*\n         LA    PARMREG,PARMLIST     SET R1 FOR CIPH ROUTINE\n         L     R6,FUNC              GET FUNCTION\n         L     R15,CIPHADD(R6)      GET ENTRY POINT REQUESTED\n         BALR  R14,R15              GO DO THE DESIRED FUNCTION\n         LTR   R15,R15              CHECK RETURN CODE\n         BNZ   ERRET                NOT ZERO, ERROR\n*\n***********************************************************************\n*        CALL ISPLINK TO WRITE BACK THE NEWLY EN/DECRYPTED LINE.\n***********************************************************************\n*\n         CALL  ISPLINK,(EDIT,LEN0,PARM5)\n*\n***********************************************************************\n*\n         B     LOOP1                GET THE NEXT RECORD\n*\n***********************************************************************\n*        EXIT CODE FOLLOWS.\n***********************************************************************\n*\nERRET    EQU   *\n         ST    R15,CONCODE          GET RETURN CODE\n         B     EXIT1                LEAVE\n*\nEXIT     EQU   *\n         SR    R15,R15              SET RETURN CODE\n         B     EXIT1                LEAVE\n*\nEXIT1    EQU   *\n         L     R13,SAVEA+4          RESTORE 13\n         L     R14,12(,R13)         RESTORE 14\n         L     R15,CONCODE          SET RETURN CODE\n         LM    R0,R12,20(R13)       RESTORE 0-12\n*\n         BR    R14                  RETURN\n*\n*\n***********************************************************************\n*                                                                     *\n*        CONSTANTS FOLLOW                                             *\n*                                                                     *\n***********************************************************************\n*\n         DS    0F                   ALIGN\n*\nSETADD   DC    V(SETKEY)            VCON OF SETKEY ROUTINE\nCIPHADD  EQU   *\n         DC    V(ENCIPH)            VCON OF ENCIPH ROUTINE\n         DC    V(DECIPH)            VCON OF DECIPH ROUTINE\nFUNC     DC    F'0'                 FUNCTION SAVE\nCONCODE  DC    F'0'                 RETURN CODE SAVE\nONE      DC    X'00000001'\nLIMIT    DC    H'8'                 LIMIT FOR KEY\nENCMDUP  DC    C'ENCRYPT'           COMPARE VALUE\nDECMDUP  DC    C'DECRYPT'           COMPARE VALUE\nBLANKS   DC    CL8' '               USED FOR FOLDING\n*\nNL       DC    C'(FCDE,KEY)'\n*\n         DS    0F                   ALIGN\nFCDE     DC    CL8' '               AREA FOR THE FUNCTION\nKEY      DC    CL8' '               AREA FOR THE KEY VALUE\n*\nDL       DC    C'(LRECL,LLINE,LINENO)'\n*\n         DS    0F                   ALIGN\nLRECL    DC    F'0'                 AREA FOR THE DATA LENGTH\nLLINE    DC    F'0'                 AREA FOR THE LAST LINE NUMBER\nLINENO   DC    F'0'                 CURRENT LINE NUMBER\n*\nLL       DC    C'(BUFFER)'\n*\n         DS    0F                   ALIGN\nVDEF     DC    CL8'VDEFINE'\nEDIT     DC    CL8'ISREDIT'\nTYPEC    DC    CL8'CHAR'\nTYPEF    DC    CL8'FIXED'\nLEN0     DC    F'0'\nLEN4     DC    F'4'\nLEN8     DC    F'8'\nLEN256   DC    F'256'\n*\nPARM1    DC    C'\u00a2MACRO (FCDE,KEY)\u00a2'\n*\nPARM2    DC    C'\u00a2(LRECL) = LRECL\u00a2'\n*\nPARM3    DC    C'\u00a2(LLINE) = LINENUM .ZLAST \u00a2'\n*\nPARM4    DC    C'\u00a2(BUFFER) = LINE &&LINENO \u00a2'\n*\nPARM5    DC    C'\u00a2LINE &&LINENO =(BUFFER) \u00a2'\n*\nPARM6    DC    C'\u00a2 CAPS OFF \u00a2'\n*\n         DS    0F                   ALIGN\nKEYADD   DC    A(KEYVAL)            KEY ADDRESS\nPARMLIST DC    A(BUFFER)            BUFFER ADDRESS\n         DC    A(BUFLEN)            BUFFER LENGTH ADDRESS\nBUFLEN   DC    A(BUFFEND-BUFFER)    BUFFER LENGTH\nSAVEA    DC    18F'0'               REGISTER SAVE AREA\n*\nBUFFER   DC    CL256' '             ENCRYPT/DECRYPT BUFFER\nBUFFEND  EQU   *\n*\n         END ENCRYPT\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CTLGTMS#": {"ttr": 13828, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x00\\x7f\\x00\\x88\\x00\\x7f\\x12\\x00\\x00Y\\x00Y\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf2\\xf7\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-01-07T00:00:00", "modifydate": "1988-01-07T12:00:00", "lines": 89, "newlines": 89, "modlines": 0, "user": "FILE270"}, "text": "//DNX00155 JOB (2100,56-D),'DPARS 0682-T',CLASS=H,MSGCLASS=T,\n//   TIME=2\n//* CATALOG CHECK FOR TAPE VOLUMES. ANY MISMATCHES BETWEEN THE TMC\n//*  AND CATALOG CAN BE UNCATALOGED.\n//* SEE CTLGDISK  FOR THE DISK VERSION.\n//*\n//* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n//* GATHER NONVSAM RECORDS FROM THE CATALOG\n//* PARM='XXXXXXXX'             PASSWORD UP TO 8 CHARACTERS.\n//*\n//Z1       EXEC PGM=VSAMSCAN,PARM=CARE,TIME=4\n//STEPCAT  DD DSN=SYS1.SOFTCAT,DISP=SHR\n//VSAMCAT  DD DSN=SYS1.SOFTCAT,DISP=SHR\n//STEPLIB DD DSN=WDPSC.TSAEXAM,DISP=SHR\n//SYSPRINT DD SYSOUT=*\n//AMSCARD DD DSN=&&AMS1,DISP=(,PASS),UNIT=WORK,\n//   SPACE=(CYL,(1,1)),DCB=BLKSIZE=3200\n//SYSUDUMP DD SYSOUT=*\n//* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n//* ELIMINATE THE RECORDS FOR DISK DATASETS\n//* LOOK AT UNIT TYPE FROM CATALOG RECORD AND KEEP THE TAPE OR '80'\n//*\n//M8       EXEC DYL260,TIME=2\n//SYS260A DD DSN=&&AMS1,DISP=(OLD,PASS)\n//SYS260K DD DSN=&&AMS2,DISP=(,PASS),UNIT=SYSSQ,\n//   SPACE=(CYL,(1,1)),DCB=BLKSIZE=3200\nC\nFA F\nFK F    80     A\nD       1A73                  EQ  1VX'80'                  REJ\nD       3A69                  EQ  3V001                 OUTREJ\n//* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n//*   PRODUCE RECORDS FROM THE TMC\n//*\n//V5      EXEC PGM=TMSDATA,TIME=2\n//STEPLIB  DD DSN=TMS.LOADMOD,DISP=SHR\n//SYSUT1   DD DSN=TMS.TMC,DISP=SHR\n//SYSUT3   DD DSN=&&TMSDATA,DISP=(,PASS),UNIT=SYSSQ,\n//      SPACE=(CYL,(10,5)),DCB=(BLKSIZE=6000)\n//SYSUT4   DD DUMMY,DCB=BLKSIZE=100\n//TMSRPT   DD SYSOUT=*\n//* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n//* SORT RECORDS INTO VOLUME SEQUENCE FOR TMS MATCH\n//*\n//W4  EXEC SORT,TIME=2\n//SORTIN DD DSN=&&AMS2,DISP=(OLD,PASS)\n//SORTOUT DD DSN=&&AMS1,DISP=(OLD,PASS)\n SORT FIELDS=(75,6,CH,A,73,2,CH,A),DYNALLOC=WORK\n//* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n//* MATCH CATALOG RECORDS AGAINST TMS DATA\n//*\n//T7       EXEC DYL260,TIME=2\n//SYS260A DD DSN=&&TMSDATA,DISP=(OLD,PASS) TMC DERIVED RECORDS\n//SYS260B DD DSN=&&AMS1,DISP=(OLD,PASS)     CATALOG DERIVED RECORDS\n//SYS260K DD DSN=&&AMS2,DISP=(OLD,PASS)\nC\nFA F\nFB F\nFK F    80     B\nD    1                        RB\nD    1                        RA\n* MATCH VOLUME SERIAL NUMBER\nDAAA    6A72                  EQ  6B75                  D1\nD       6A72                  LT  6B75                  RDA\nD                             WK                        RDB\n*\n* VOLUME MATCH MADE, CHECK FOR EQUAL DATA SET NAMES\n* IF EQUAL, READ NEXT CATALOG RECORD.\n* IF TMS LESS THAN CATALOG, READ CATALOG FILE.\n* IF TMS GREATER THAN CATALOG, WRITE CATALOG RECORD FOR FURTHER\n* PROCESSING AND READ CATALOG FILE.\nDD1    44A1                   EQ 44B6                   RDB\nD      44A1                   LT 44B6                   RDA\nD                             WK                        RDB\n*\n* EOF ON FILEA IS GREATER THAN OR EQUAL TO FILEB, NEVER LESS. THUS NO\n* CHECK IS NEEDED\nDRDA                          RA                        AAA\n* EOF ON FILEB MEANS NO MORE CAN BE DONE\nDRDB    5B1                   EQ  5VX'FFFFFFFFFF'       OFF\nD                             RB                        AAA\n*\nDOFF    1V2                       1UEOJ                 OUT\n//*\n//* PUT \"K\" FILE OUT FOR EDITING AND OTHER PROCESSING.\n//S8  EXEC FTL,TIME=2\n//IN01  DD DSN=&&AMS2,DISP=(OLD,PASS)\n//OUT01 DD DSN=DN00155.SOFTCAT.TAPE,DISP=(,CATLG),\n//   SPACE=(CYL,(1,1)),UNIT=WORK\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DATASTA$": {"ttr": 13831, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x00\\x7f\\x00\\x88\\x00\\x7f\\x12\\x00\\x005\\x005\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf2\\xf7\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-01-07T00:00:00", "modifydate": "1988-01-07T12:00:00", "lines": 53, "newlines": 53, "modlines": 0, "user": "FILE270"}, "text": "1                                                        DATASTAT.1\n                                                         06/25/82\n\n\n  COMMAND NAME:  DATASTAT (Alias:  DSTYPE)\n  SOURCE:        Kermit Kiser\n  AGENCY:        WDPSC\n  FUNCTION:      The DATASTAT  command is intended for  use in\n                 command    procedures   (CLISTS).     It    allows\n                 conditional execution  based on whether  a dataset\n                 is cataloged  or not cataloged  and what  type the\n                 dataset is.\n\n  Syntax -\n  __________________________________________________________________\n       Command        Operands\n  ------------------------------------------------------------------\n       DATASTAT       dsname\n   or DSTYPE\n  ------------------------------------------------------------------\n\n  Operands -\n    Required - dsname\n    Default  - None.\n      dsname - The dataset name you wish checked.\n\n  Example -\n    DATASTAT   LIB.DATA\n\n  Note:     DATASTAT returns a return code which depends on whether\n            or not the dataset was found  and what type the dataset\n            is.  The CLIST variable &LASTCC will contain the return\n            code.\n\n\n\n\n1                                                        DATASTAT.2\n                                                         06/25/82\n\n\n       Return codes are:\n            0    -    The dataset is a PDS.\n            1    -    The dataset is sequential.\n            2    -    The dataset is other type disk dataset.\n            3    -    The dataset is not a disk dataset.\n            4    -    The dataset is not cataloged.\n            8    -    The dataset is not on volume the catalog\n                      indicates.\n\n\n\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "DATASTAT": {"ttr": 13833, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x00\\x7f\\x00\\x88\\x00\\x7f\\x12\\x00\\x00\\xc5\\x00\\xc5\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf2\\xf7\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-01-07T00:00:00", "modifydate": "1988-01-07T12:00:00", "lines": 197, "newlines": 197, "modlines": 0, "user": "FILE270"}, "text": "*          DATA SET 761KKDSTAT AT LEVEL 001 AS OF 10/13/80\n         TITLE 'DATASTAT COMMAND PROCESSOR'\n***********************************************************************\n*                                                                     *\n* DATASTAT 'SWC.L.DATA'                                               *\n*   \"   MISC.CLIST                                                    *\n*   \"   'SWC.L.DATA(MEM)'                                             *\n*   \"   MISC.CLIST(CLMEM)                                             *\n*                                                                     *\n*  GIVES A RETURN CODE AS FOLLOWS:                                    *\n*        0     = DATASET IS A PDS       (PO)                          *\n*        1     = DATASET IS SEQUENTIAL  (PS)                          *\n*        2     = DATASET IS OTHER DASD  (DA,ETC.)                     *\n*        3     = DATASET IS NON-DASD    (TAPE,ETC.)                   *\n*        4     = DATASET IS NOT CATALOGUED                            *\n*        8     = DATASET IS NOT ON PACK (NOT FOUND IN VTOC)           *\n*                                                                     *\n***********************************************************************\n*\n* REGISTER USEAGE\n*\n*        R2-R7 WORK REGISTERS\n*        R8    BASE REGISTER FOR PDES\n*        R10   BASE REGISTER FOR PPL\n*        R11   BASE REGISTER FOR CPPL\n*        R12   BASE REGISTER FOR PROGRAM\n*        R13   BASE REGISTER FOR WORKAREA\n*        R14   LINK REGISTER\nDATASTAT ENTER (14,12),12,(,WORKL1)\n         EJECT\n*        SET UP ADDRESSABILITY\n*        COMMAND PROCCESSOR PARM LIST,PARSE PARM LIST,DYNAMIC ALLOC\n*        PARM LIST,WORKAREA. (CPPL,PPL,DAPL,W.A.)\n         USING WORK1,R13\n         LR    R11,R1\n         USING CPPL,R11\n         LA    R10,PPLAREA\n         USING PPL,R10\n         SPACE\n*\n*        PREPARE PARSE  CONTROL BLOCKS\n*        TRANSFER INFO FROM CPPL TO PPL\n         L     R5,CPPLCBUF    COMMAND BUFFER\n         ST    R5,PPLCBUF\n         L     R5,CPPLUPT    UPT\n         ST    R5,PPLUPT\n         L     R5,CPPLECT    ECT\n         ST    R5,PPLECT\n         LA    R5,PARSECB    MOVE OUR ECB\n         ST    R5,PPLECB\n         L     R5,=A(PARMS)\n         ST    R5,PPLPCL\n         LA    R5,ANSAREA\n         ST    R5,PPLANS\n         XC    PPLUWA(4),PPLUWA\n         XC    PARSECB(4),PARSECB\n         SPACE\n*\n*        PARSE COMMAND BUFFER\n*\n         LR    R1,R10\n         DROP  R10\n         LINK  EP=IKJPARS\n         SPACE\n*\n*        CHECK RETURN CODE\n*\n         LTR   R15,R15\n         BNZ   PARSERR\n         SPACE\n*\n*        SET UP PDL ADDRESSABILITY\n*\n         L     R8,ANSAREA\n         USING IKJPARMD,R8\n         EJECT\n*\n*\n*              ISSUE LOCATE AND OBTAIN  FOR DSN\n*\n*\n*              FIRST BUILD 44 BYTE DSN:\n*\n         MVI   DSNAME,C' '              A BLANK\n         MVC   DSNAME+1(43),DSNAME      SPREAD IT AROUND\n         LA    R1,DSNAME                R1->DSN AREA\n         TM    DSTRING+6,X'40'          QUOTED?\n         BNZ   YESQ                     YES\n         L     R2,CPPLUPT               R2->UPT\n         SLR   15,15                    R15=0\n         IC    R15,23(,R2)              R15=PREFIX LEN\n         LTR   R15,R15                  ANY?\n         BZ    YESQ                     NO\n         MVC   DSNAME(7),16(R2)         MOVE PREFIX\n         IC    R0,=C'.'                 LOAD A PERIOD\n         STC   R0,0(R15,R1)             INSERT IT\n         LA    R1,1(R15,R1)             POINT PAST IT\nYESQ     L     R4,DSTRING               R4->DSN AS ENTERED\n         LH    R3,DSTRING+4             R3=LEN OF ENTERED\n         BCTR  R3,R0                    -1 FOR EX\n         SPACE\nMOVEDSN3 MVC   0(0,R1),0(R4)\n         EX    R3,MOVEDSN3              CONCAT IT\n*\n*              THEN BUILD PARM LISTS:\n*\n         MVC   CAML1,CAML1R             PATTERN                   WDPSC\n         MVC   CAML2,CAML2R             PATTERN                   WDPSC\n         LA    R1,DSNAME                R1->DSNAME                WDPSC\n         ST    R1,CAML1+4               PASS IT                   WDPSC\n         ST    R1,CAML2+4                \"   \"                    WDPSC\n         LA    R1,CAMA1                 R1->WORK AREA 1           WDPSC\n         ST    R1,CAML1+12              PASS                      WDPSC\n         LA    R1,CAMA2                 R1->WORK AREA 2           WDPSC\n         ST    R1,CAML2+12              PASS                      WDPSC\n         LA    R1,CAMA1+6               R1->VOL SER AREA          WDPSC\n         ST    R1,CAML2+8               PASS                      WDPSC\n         EJECT                                                    WDPSC\n*\n*              NEXT DO LOCATE TO GET VOLSER:\n*\n         LOCATE  CAML1                  SEARCH CAT\n*\n         LTR   R15,R15                  FOUND?\n         BNZ   RC4                      NO\n         CLC   CAMA1(2),=X'0001'        ONE VOL?\n         BNE   RC3                      NO\n         CLI   CAMA1+4,X'20'            DASD?\n         BNE   RC3                      NO\n*\n*              NOW DO OBTAIN TO SEE IF  THERE\n*\n         OBTAIN  CAML2                 SEARCH VTOC\n*\n         LTR   R15,R15                  FOUND OK?\n         BNZ   RC8                      NO\n         TM    CAMA2+82-44,X'02'        PO?\n         BO    RC0                      YES\n         TM    CAMA2+82-44,X'40'        PS?\n         BO    RC1                      YES\n*\nRC2      LA    R15,2                    RC=2\n         B     EXIT\nRC1      LA    R15,1                    RC=1\n         B     EXIT\nRC0      SLR   R15,R15                  RC=0\n         B     EXIT\nRC3      LA    R15,3                    RC=3\n         B     EXIT\nRC4      LA    R15,4                    RC=4\n         B     EXIT\nRC8      LA    R15,8                    RC=8\n         B     EXIT\n         TITLE 'EXITS...BOTH GOOD AND BAD'\nEXIT     EQU   *\n         LEAVE EQ\n         TITLE 'DATASTAT -- ERROR PROCESSING'\n*\n*        AN ERROR OCCURED IN PARSE\n*\nPARSERR  EQU   *\n         TPUT  BADPARS,11\n         B     RC4\n         TITLE 'DATASTAT -- CONSTANTS, STORAGE, AND DSECTS'\n*\nCAML1R   CAMLST   NAME,DSNAMER,,CAMA1R\nCAML2R   CAMLST   SEARCH,DSNAMER,CAMA1R+6,CAMA2R\nCAMA1R   EQU   *                        DUMMY                     WDPSC\nCAMA2R   EQU   *                        DUMMY                     WDPSC\nDSNAMER  EQU   *                        DUMMY                     WDPSC\n*\nBADPARS  DC    CL11'PARSE ERROR'\n         LTORG                                                    WDPSC\n         EJECT                                                    WDPSC\nWORK1    DSECT\n         DS    18F\nPPLAREA  DS    7F\nANSAREA  DS    F\nPARSECB  DS    F\nDSNAME   DC    CL44' '\nCAML1    CAMLST   NAME,DSNAME,,CAMA1\nCAMA1    DS    0D\n         DC    265X'00'\nCAML2    CAMLST   SEARCH,DSNAME,CAMA1+6,CAMA2\nCAMA2    DS    0D\n         DC    140X'00'\nWORKL1   EQU   *-WORK1\nDATASTAT CSECT                                                    WDPSC\n         EJECT                                                    WDPSC\nPARMS    IKJPARM\nDSTRING  IKJPOSIT DSNAME,PROMPT='DATASET'\n         IKJENDP\n         EJECT                                                    WDPSC\n         IKJCPPL\n         SPACE 2\n         IKJPPL\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DATE": {"ttr": 13837, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x00\\x7f\\x00\\x88\\x00\\x7f\\x12\\x00\\x00\\xc1\\x00\\xc1\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf2\\xf7\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-01-07T00:00:00", "modifydate": "1988-01-07T12:00:00", "lines": 193, "newlines": 193, "modlines": 0, "user": "FILE270"}, "text": "*          DATA SET 752ABDATE  AT LEVEL 001 AS OF 06/26/74\nDATE     TITLE 'DATE OF YEAR ROUTINE'\n***********************************************************************\n*        *DATE*                                                       *\n*         ----                                                        *\n*   PURPOSE:  A SUBROUTINE TO COMPUTE AND RETURN THE PRESENT DATE.    *\n*             THE DATE IS RETURNED IN THE FORM:                       *\n*             DAY-OF-WEEK MONTH DAY, YEAR                             *\n*             TYPICALLY:                                              *\n*             THURSDAY NOVEMBER 13, 1969                              *\n*                                                                     *\n*             THE RETURNED STRING IS IN CHARACTER FORMAT, AND IS LEFT *\n*             ADJUSTED IN A 7 WORD ARRAY. THE LONGEST DATE POSSIBLE   *\n*             WILL JUST FILL 7 WORDS (28 BYTES).                      *\n*   CALLING SEQUENCE:                                                 *\n*               DIMENSION STRING(7)                                   *\n*               CALL DATE(STRING)                                     *\n*               WRITE (6,1) STRING                                    *\n*             1 FORMAT (10X,7A4)                                      *\n*                                                                     *\n*   METHOD:                                                           *\n*             STRIAGHT FORWARD. THE DAY OF THE WEEK SECTION IS        *\n*             MODELLED AFTER A FORMULA CALLED 'ZELLER'S CONGRUENCE',  *\n*             DOCUMENTED IN A BOOK CALLED  PROBLEMS FOR COMPUTER      *\n*             SOLUTION, THE RAND CORPORATION                          *\n*                                                                     *\n*        NO INPUT IS NEEDED. NO OPTIONS OR DIAGNOSTICS ARE IMPLEMENTED*\n*        AND ANY MALFUNCTIONS SHOULD BE REFFERED TO                   *\n*        CUSTOMER SUPPORT, 902-3400                                   *\n*                                                                     *\n*                                            NOVEMBER 15, 1969        *\n***********************************************************************\n*                                                                     *\nDATE     CSECT\n         STM   14,12,12(13)    SAVE REGISTERS\n         BALR  11,0            SET BASE REGISTER\n         USING *,11            INFORM ASSEMBLER OF BASE REG.\n         L     6,0(1)          LOAD REG 6 WITH A(ARGUMENT)\n         TIME  DEC             CALL DATE\n         SR    0,0             ZERO REG 0\n         ST    1,RETURNED      STORE RETURNED DATE FOR LATER USE\n         SRL   1,12            SHIFT OUT ALL BUT THE YEAR\n         STM   0,1,CVBAREA     STORE YEAR IN WORK AREA\n         OI    CVBAREA+7,X'0F' INSERT SIGN INTO YEAR\n         CVB   1,CVBAREA       CONVERT YEAR INTO BINARY\n         LR    9,1             KEEP YEAR IN REG 9\n         D     0,=F'4'         DIVIDE YEAR BY FOUR TO DETERMINE\n         LR    10,0            IF IT IS A LEAP YEAR\n         UNPK  YEAR+2(2),CVBAREA+6(2) UNPK & INSERT YEAR IN '19--'\n         SR    0,0             ZERO REG 0\n         L     1,RETURNED      LOAD 1 WITH DATE RETURNED FROM SVC 11\n         SLL   1,16            SHIFT OUT YEAR\n         SRL   1,16            SHIFT BACK TO ORIGINAL POSITION\n         STM   0,1,CVBAREA     STORE RESULT INTO WORK AREA\n         CVB   1,CVBAREA       CONVERT THE DAY OF YEAR TO BINARY\n         EJECT\n         LA    8,11            |\n         C     1,=F'31'        |\n         BNH   END             |\n         S     1,=F'31'        |\n         LA    8,1(8)          |\n         CR    10,0            |\n         BE    LEAP            |\n         C     1,=F'28'        |\n         BNH   END             |  DETERMINE MONTH AND DAY OF\n         S     1,=F'28'        |  THE MONTH, TAKING INTO ACCOUNT\n         LA    8,1             |  LEAP YEARS.\n         B     MARCH           |   REG7 = BCT REGISTER\nLEAP     C     1,=F'29'        |  AT ARRIVAL TO STATMENT 'END'\n         BNH   END             |   REG1 = DAY IN MONTH\n         S     1,=F'29'        |   REG8 = MONTH COUNT (JAN=11,FEB=12,\n         LA    8,1             |          MAR=1....DEC=10)\nMARCH    LA    7,3             |\n         B     MIDDLE          |\nLOOP     C     1,=F'30'        |\n         BNH   END             |\n         S     1,=F'30'        |\n         LA    8,1(8)          |\nMIDDLE   C     1,=F'31'        |\n         BNH   END             |\n         S     1,=F'31'        |\n         LA    8,1(8)          |\n         BCT   7,LOOP          |\n         B     MARCH           |\nEND      LR    7,8             LOAD REG 7 WITH MONTH COUNT\n         C     8,=F'10'        SEE IF MONTH IS JAN OR FEB\n         BNH   NTJANFEB        IF NOT GO TO 'NTJANFEB'\n         S     9,=F'1'         SUBTRACT 1 FROM YEAR\nNTJANFEB LR    2,9             |\n         SRDA  8,32            |\n         M     8,=F'26'        |\n         S     9,=F'2'         |\n         D     8,=F'10'        |  ZELLERS CONGRUENCE\n         AR    9,1             |\n         AR    9,2             |\n         SRDA  2,32            |\n         D     2,=F'4'         |\n         AR    9,3             |\n         S     9,=F'34'        |\n         SR    8,8             |\n         D     8,=F'7'         |\n         EJECT\n         MVI   0(6),X'40'      BLANK FIRST BYTE OF ARGUMENT\n         MVC   1(27,6),0(6)    PROPOGATE BLANKS THOUGH ENTIRE STRING\n         LR    5,1             LOAD REG 5 WITH DAY OF MO. CNT.\n         MH    8,=H'12'        MULTIPLY BY TWELVE TO GET ADDRESS\n         LA    4,DAYS(8)       LOAD REG 4 WITH ACTUAL ADDRESS\n         MVC   0(12,6),0(4)    MOVE THAT DAY INTO ARGUMENT\n         TRT   0(12,6),TRTABLE LOCATE FIRST BLANK IN ARGUMENT\n         S     7,=F'1'         SUBTRACT 1 FROM MONTH COUNT\n         MH    7,=H'12'        MULTIPLY MO. CNT. BY 12 TO GET ADDRESS\n         LA    4,MONTHS(7)     LOAD REG 4 WITH ACTUAL ADDRESS\n         MVC   1(12,1),0(4)    MOVE THE MONTH INTO ARGUMENT\n         TRT   1(12,1),TRTABLE FIND NEXT BLANK IN STRING (ARG)\n         CVD   5,CVBAREA       CONVERT DAY OF MONTH TO DECIMAL\n         OI    CVBAREA+7,X'0F' INSERT CORRECT SIGN FOR PRINTING\n         MVC   CVBAREA(4),PATTERN MOVE EDIT PATTERN TO WORK AREA\n         ED    CVBAREA(4),CVBAREA+6 EDIT & UNPK DAY OF MONTH\n         MVC   1(2,1),CVBAREA+2 MOVE DAY OF MONTH INTO STRING\n         MVC   3(2,1),COMMA    MOVE DELIMITING COMMA INTO STRING\n         MVC   5(4,1),YEAR     MOVE YEAR INTO STRING\n         LM    14,12,12(13)    *          *\n         SR    15,15           * EPILOGUE *\n         MVI   12(13),X'FF'    *          *\n         BR    14              RETURN\n         EJECT\n*   CONSTANTS SECTION\n*\nCVBAREA  DS    D\nRETURNED DS    F\nYEAR     DC    CL4'19  '\nDAYS     DC    CL12'SUNDAY      '\n         DC    CL12'MONDAY      '\n         DC    CL12'TUESDAY     '\n         DC    CL12'WEDNESDAY   '\n         DC    CL12'THURSDAY    '\n         DC    CL12'FRIDAY      '\n         DC    CL12'SATURDAY    '\nMONTHS   DC    CL12'MARCH       '\n         DC    CL12'APRIL       '\n         DC    CL12'MAY         '\n         DC    CL12'JUNE        '\n         DC    CL12'JULY        '\n         DC    CL12'AUGUST      '\n         DC    CL12'SEPTEMBER   '\n         DC    CL12'OCTOBER     '\n         DC    CL12'NOVEMBER    '\n         DC    CL12'DECEMBER    '\n         DC    CL12'JANUARY     '\n         DC    CL12'FEBRUARY    '\nTRTABLE  DC    64X'00'\n         DC    X'FF'\n         DC    191X'00'\nPATTERN  DC    X'40202020'\nCOMMA    DC    CL2', '\n         END\nTESTDATE CSECT      TEST DRIVER FOR VARIOUS DATE PROGRAMS\n         USING TESTDATE,R15\n         SAVE  (14,12),,*\n         LR    R14,R13\n         ST    R13,SAVE+4\n         CNOP  0,4\n         BAL   R13,AROUND\n         DROP  R15\n         USING SAVE,R13\nSAVE     DC    18A(0)\nAROUND   DS    0H\n         ST    R13,8(R14)\n         CALL     DATE,(DATE)\n         ST    R15,RC              SAVE   RETURN CODE\n         NOP   END\n         CNOP  0,4\n         BAL   R1,SVC35\n         DC    AL2(32)        LENGTH\n         DC    XL2'8000'      MCS FLAGS\nDATE     DC    CL28' '\n         DC    XL2'0000'      DESCRIPTOR CODES\n         DC    XL2'FFFF'      ROUTING FLAGS\nSVC35    DS    0H\n         SVC   35             WTO SVC\n         SPACE 1\nEND      EQU   *\n         L     R15,RC              RESTORE RETURN CODE\n         L     R13,SAVE+4\n       RETURN  (14,12),T,RC=(15)\nRC       DC    F'2048'\n         SPACE\nR15 EQU 15\nR14 EQU 14\nR13 EQU 13\nR1  EQU 1\nR0  EQU 0\n         END   TESTDATE\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "DATECON$": {"ttr": 14084, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x00\\x7f\\x00\\x88\\x00\\x7f\\x12\\x00\\x00\\x94\\x00\\x94\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf2\\xf7\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-01-07T00:00:00", "modifydate": "1988-01-07T12:00:00", "lines": 148, "newlines": 148, "modlines": 0, "user": "FILE270"}, "text": "1                                                        DATECONV.1\n                                                         06/25/82\n\n\n  COMMAND NAME:  DATECONV\n  AUTHOR:        Jeff Sprehn\n  AGENCY:        WDPSC\n  FUNCTION:      Accept a Standard, Julian, or Serial date and then\n                 convert it to the other two.\n\n  SYNTAX:\n\n  ___________________________________________________________________\n       Command        Operand(s)\n  -------------------------------------------------------------------\n       DATECONV       ACTCODE('action code') INDATE('input date')\n  -------------------------------------------------------------------\n\n  Operands -\n\n       Required -\n\n             ACTCODE('action code') -- If the date that you are\n                                       providing this command is a\n                                       standard date, enter\n                                       ACTCODE(STA)\n\n                                       If the date  that you are\n                                       providing this command is a\n                                       Julian  date, enter\n                                       ACTCODE(JUL)\n\n                                       If the date  that you are\n                                       providing this command is a\n                                       serial  date, enter\n                                       ACTCODE(SER)\n\n\n\n1                                                        DATECONV.2\n                                                         06/25/82\n\n\n            INDATE('input date') --       'input date' is  the date\n                                          that  you  are  providing\n                                          this command.   It is  to\n                                          be a standard, Julian, or\n                                          serial date.\n\n       This command returns  three CLIST variables to  the invoking\n       CLIST to use:\n\n       &STADATE\n       &JULDATE\n       &SERDATE\n\n  The standard date is returned in &STADATE\n  The Julian date is returned in   &JULDATE\n  The serial date is returned in   &SERDATE\n\n\n  POSSIBLE RETURN CODES:\n\n       Return Code                         Meaning\n       -----------         ----------------------------------------\n            0              Date was valid and conversions were made\n            4              Invalid date given to this command\n            8              Invalid action code given to this command\n           96              Invalid syntax of one or more operands\n\n\n\n\n1                                                        DATECONV.3\n                                                         06/25/82\n\n\n  DEFINITION OF STANDARD, JULIAN, AND SERIAL DATES:\n\n  o    A  standard date  is a  six (6)  digit numeric  of the  form\n       MMDDYY (such as 122581).\n\n  o    A Julian date is a five (5)  digit numeric of the form YYDDD\n       where  YY is  the  year and  DDD is  a  three digit  numeric\n       representing  the displacement  from the  beginning of  that\n       year.\n\n  o    A serial date is a five (5)  digit numeric of the form NNNNN\n       representing  the displacement  from  the  beginning of  the\n       twentieth century.  For  example, January 1, 1900  is serial\n       date 00001, January 2, 1900 is serial date 00002, January 1,\n       1901 is serial date 00366 (since  1900 was not a leap year),\n       and so on.\n\n  Serial date is a very useful tool  when one wishes to compute the\n  days elapsed between two dates in time when the years may differ.\n  Julian date will not serve this purpose well.  For example; using\n  Julian dates there would be 636 elapsed days between December 31,\n  1979 and  January 1,  1980 (80001 -  79365 =  636) where  in fact\n  there is  only 1.   Using serial dates  rather than  Julian would\n  yield the correct answer of 1.\n\n  EXAMPLE:\n\n  In a CLIST, determine whether the  date that the user has entered\n  (which is stored in CLIST variable &USERDATE) is more than 5 days\n  into the future.  If it is, inform  him that his date is invalid,\n  and prompt him for the date again:\n\n\n\n\n1                                                        DATECONV.4\n                                                         06/25/82\n\n\n             CONTROL NOMSG NOFLUSH END(ENDO)\n  ASK4DATE:  WRITE\n              WRITENR ENTER DATE ==>\n             READ &USERDATE\n             DATECONV ACTCODE(STA) INDATE(&USERDATE)\n             SET &RC = &LASTCC\n             IF &RC NE 0 THEN DO\n                  WRITE\n                  WRITE *** INVALID DATE ***\n                  CALL 'WDPSC.SHARED.LOAD(NEWWAIT)' '4'\n                  GOTO ASK4DATE\n                  ENDO\n             SET &USRSERDT = &SERDATE\n             SET &CURRMM = &SUBSTR(1:2,&SYSDATE)\n             SET &CURRDD = &SUBSTR(4:5,&SYSDATE)\n             SET &CURRYY = &SUBSTR(7:8,&SYSDATE)\n             SET &CURRDATE = &CURRMM.&CURRDD.&CURRYY\n             DATECONV ACTCODE(STA) INDATE(&CURRDATE)\n             SET &CURSERDT = &SERDATE\n             IF &CURSERDT GT &USRSERDT THEN GOTO FINI\n             SET &DIFF = &USRSERDT - &CURSERDT\n             IF &DIFF GT 5 THEN DO\n                  WRITE\n                  WRITE *** INVALID DATE ***\n                  CALL 'WDPSC.SHARED.LOAD(NEWWAIT)' '4'\n                   GOTO ASK4DATE\n                  ENDO\n  FINI:      EXIT\n\n\n\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "DATECONV": {"ttr": 14088, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x00\\x7f\\x00\\x88\\x00\\x7f\\x12\\x00\\x01\\xb6\\x01\\xb6\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf2\\xf7\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-01-07T00:00:00", "modifydate": "1988-01-07T12:00:00", "lines": 438, "newlines": 438, "modlines": 0, "user": "FILE270"}, "text": "*          DATA SET 764DATECNV AT LEVEL 003 AS OF 12/22/81\n*\n**********************\n*                    *\n*  D A T E C O N V   *\n*                    *\n**********************\n*\n*  --------------------------------------------------------------------\n*  COMMAND     OPERANDS\n*  --------------------------------------------------------------------\n*  DATECONV    ACTCODE('ACTION CODE') INDATE('INDATE')\n*  --------------------------------------------------------------------\n*\n*\n*  OPERANDS -\n*\n*     REQUIRED -\n*\n*       ACTCODE('ACTION CODE') --'ACTION CODE' IS ONE OF THE FOLLOWING:\n*\n*             \"STA\" IF THE DATE GIVEN TO THE COMMAND IS A STANDARD DATE\n*             \"JUL\" IF THE DATE GIVEN TO THE COMMAND IS A JULIAN DATE\n*             \"SER\" IF THE DATE GIVEN TO THE COMMAND IS A SERIAL DATE\n*\n*\n*        INDATE('INDATE') ------- 'INDATE' IS THE DATE THAT IS GIVEN\n*                                  TO THIS COMMAND FOR CONVERSION.\n*\n*\n*        THIS COMMAND MAKES AVAILABLE TO THE CLIST THREE VARIABLES\n*        &STADATE, &JULDATE, AND &SERDATE\n*\n*\n*           &STADATE WILL CONTAIN THE STANDARD DATE\n*           &JULDATE WILL CONTAIN THE JULIAN DATE\n*           &SERDATE WILL CONTAIN THE SERIAL DATE\n*\n*\n         EJECT\n*\n*        RETURN CODES\n*        ............................................................\n*\n*        |---------|------------------------------------------------|\n*        |   RC    |                 MEANING                        |\n*        |---------|------------------------------------------------|\n*        |    0    | DATE WAS VALID AND CONVERSIONS WERE MADE       |\n*        |---------|------------------------------------------------|\n*        |    4    | INVALID DATE GIVEN TO THIS COMMAND             |\n*        |---------|------------------------------------------------|\n*        |    8    | INVALID ACTION CODE GIVEN TO THIS COMMAND      |\n*        |---------|------------------------------------------------|\n*        |    96   | INVALID SYNTAX OF ONE OR MORE OPERANDS         |\n*        |---------|------------------------------------------------|\n*\n         EJECT\nDATECONV ENTERR\n         EJECT\n********************************************************************\n*                                                                  *\n*      M A I N   L I N E   L O G I C   F O R   D A T E C O N V     *\n*                                                                  *\n********************************************************************\n*\n         LR    R11,R1              SAVE THE PARM POINTER\n         LA    R4,0                R4==> 0\n         MVC   STADATE,=CL6' '\n         MVC   JULDATE,=CL5' '\n         MVC   SERDATE,=CL5' '\n         BAL   R14,DOPARSE         PERFORM THE PARSE SERVICE ROUTINE\n         CLC   PROCESSW,=C'YES'    WAS PARSE SUCCESFUL ?\n         BNE   INITL               IF NOT, BRANCH TO INITL\n         BAL   R14,LOADFLDS        PERFORM ROUTINE TO LOAD THE PARSED\n*                                    FIELDS INTO APPROP DATA FIELDS\n         CLC   PROCESSW,=C'YES'    IS EVERTHING STILL HONKEY DOREY ?\n         BNE   INITL               IF NOT, BRANCH TO INITL\n         BAL   R14,MAJORTN         PERFORM ROUTINE TO DO THE CONVERSION\nINITL    BAL   R14,INITLIST        BUILD PARMLIST FOR IKJUPDT\n         BAL   R14,SETSTDAT        SET CLIST VARIABLE &STADATE\n         BAL   R14,SETJUDAT        SET CLIST VARIABLE &JULDATE\n         BAL   R14,SETSEDAT        SET CLIST VARIABLE &SERDATE\n         B     SHUTDOWN            BRANCH TO SHUTDOWN\n         EJECT\n********************************************************************\n*                                                                  *\n*        P A R S E   I N P U T   C O M M A N D   B U F F E R       *\n*                                                                  *\n********************************************************************\n*\nDOPARSE  ST    R14,SAVEIT1          SAVE REG 14 CONTENTS IN SAVEIT1\n         KKPARSE\n         LTR   R15,R15              RC = 0 ? (I.E PARSE GO OK ?)\n         BNZ   PARSERR              IF NOT, BRANCH TO PARSERR\n         MVC   PROCESSW,=C'YES'     MOVE 'YES' TO PROCESSW\n         L     R10,ANS\n         USING IKJPARMD,R10\n         B     EXITPARS\nPARSERR  MVC   PROCESSW,=C'NO '     MOVE 'NO ' TO PROCESSW\n         LA    R4,96                SET REG 4 = 96\nEXITPARS L     R14,SAVEIT1\n         BR    14\n         EJECT\n********************************************************************\n*                                                                  *\n*        THIS ROUTINE PROCESSES THE PARSED FIELDS, AND LOADS       *\n*        THE TWO DATA FIELDS ACTCDIN AND DATEIN                    *\n*                                                                  *\n********************************************************************\n*\nLOADFLDS ST    R14,SAVEIT2             SAVE REG 14 CONTENTS IN SAVEIT2\n         MVC   PROCESSW,=CL3'YES'      MOVE 'YES' TO PROCESSW\n         TM    ACTCDSTR+6,X'80'        IS ACTION CODE PRESENT ?\n         BNO   BADACTCD                IF NOT, BRANCH TO BADACTCD\n         LH    R8,ACTCDSTR+4           R8==> LENGTH OF ACTION CODE\n         CH    R8,=H'3'                IS LENGTH OF ACT CODE = 3 ?\n         BNE   BADACTCD                IF NOT, BRANCH TO BADACTCD\n         L     R8,ACTCDSTR             R8 ==> ADDRESS OF THE ACT CODE\n         MVC   ACTCDIN,0(R8)           MOVE ACT CODE TO ACTCDIN\n         CLC   ACTCDIN,=CL3'STA'       IS ACTION CODE = 'STA' ?\n         BE    LOADDATE                IF SO, BRANCH TO LOADDATE\n         CLC   ACTCDIN,=CL3'JUL'       IS ACTION CODE = 'JUL' ?\n         BE    LOADDATE                IF SO, BRANCH TO LOADDATE\n         CLC   ACTCDIN,=CL3'SER'       IS ACTION CODE = 'SER' ?\n         BE    LOADDATE                IF SO, BRANCH TO LOADDATE\n         B     BADACTCD                BRANCH TO BADACTCD\nLOADDATE TM    DATSTRNG+6,X'80'        IS INDATE PRESENT ?\n         BNO   BADINDAT                IF NOT, BRANCH TO BADINDAT\n         LH    R8,DATSTRNG+4           R8==> LENGTH OF INDATE\n         CH    R8,=H'5'                IS LENGTH OF INDATE = 5 ?\n         BE    LOADLEN5                IF SO, BRANCH TO LOADLEN5\n         CH    R8,=H'6'                IS LENGTH OF INDATE = 6 ?\n         BE    LOADLEN6                IF SO, BRANCH TO LOADLEN6\n         B     BADINDAT                BRANCH TO BADINDAT\nLOADLEN5 CLC   ACTCDIN,=CL3'STA'       IS ACTION CODE = 'STA' ?\n         BE    BADINDAT                IF SO, BRANCH TO BADINDAT\n         MVC   DATEIN,=CL6' '\n         L     R8,DATSTRNG             R8 ==> ADDRESS OF THE INDATE\n         MVC   DATEIN(5),0(R8)\n         B     EXITLOAD                BRANCH TO EXITLOAD\nLOADLEN6 CLC   ACTCDIN,=CL3'STA'       IS ACTION CODE = 'STA' ?\n         BNE   BADINDAT                IF NOT, BRANCH TO BADINDAT\n         MVC   DATEIN,=CL6' '\n         L     R8,DATSTRNG             R8 ==> ADDRESS OF THE INDATE\n         MVC   DATEIN(6),0(R8)\n         B     EXITLOAD                BRANCH TO EXITLOAD\nBADACTCD MVC   PROCESSW,=CL3'NO '      MOVE 'NO ' TO PROCESSW\n         LA    R4,8                    SET REG 4 = 8\n         B     EXITLOAD                BRANCH TO EXITLOAD\nBADINDAT MVC   PROCESSW,=CL3'NO '      MOVE 'NO ' TO PROCESSW\n         LA    R4,4                    SET REG 4 = 4\nEXITLOAD L     R14,SAVEIT2\n         BR    R14\n         EJECT\n*\n********************************************************************\n*                                                                  *\n*        THIS ROUTINE EXAMINES ACTCDIN, AND THEN PERFORMS THE      *\n*        APPROPRIATE ROUTINE DEPENDING UPON WHETHER IT IS EQUAL    *\n*        TO 'STA', 'JUL', OR 'SER'.                                *\n*                                                                  *\n********************************************************************\n*\nMAJORTN  ST    R14,SAVEIT3\n         CLC   ACTCDIN,=CL3'STA'\n         BE    DOSTADAT\n         CLC   ACTCDIN,=CL3'JUL'\n         BE    DOJULDAT\n         BAL   R14,CNVSERDT\n         B     EXITMAJR\nDOSTADAT BAL   R14,CNVSTADT\n         B     EXITMAJR\nDOJULDAT BAL   R14,CNVJULDT\nEXITMAJR L     R14,SAVEIT3\n         BR    R14\n         EJECT\n*\n********************************************************************\n*                                                                  *\n*        THE ROUTINE IS RESPONSIBLE FOR PROCESSING A STANDARD      *\n*        DATE AND THEN CONVERTING IT TO JULIAN AND SERIAL DATES    *\n*                                                                  *\n********************************************************************\n*\nCNVSTADT ST    R14,SAVEIT4\n         MVC   INSTDATE,DATEIN\n         CALL  STOJCONV,(STOJAREA)\n         CLC   STOJSW,=CL3'YES'\n         BE    BADSTADT\n         MVC   STADATE,DATEIN\n         MVC   JULDATE,OUTJULDT\n         MVC   SERDATE,OUTSERDT\n         B     EXITSTA\nBADSTADT LA    R4,4\nEXITSTA  L     R14,SAVEIT4\n         BR    R14\n         EJECT\n*\n********************************************************************\n*                                                                  *\n*        THE ROUTINE IS RESPONSIBLE FOR PROCESSING A JULIAN        *\n*        DATE AND THEN CONVERTING IT TO STANDARD AND SERIAL        *\n*        DATES                                                     *\n*                                                                  *\n********************************************************************\n*\nCNVJULDT ST    R14,SAVEIT5\n         MVC   INJULDAT,DATEIN\n         CALL  JTOSCONV,(JTOSAREA)\n         CLC   JTOSSW,=CL3'YES'\n         BE    BADJULDT\n         MVC   INSTDATE,OUTSTDAT\n         CALL  STOJCONV,(STOJAREA)\n         CLC   STOJSW,=CL3'YES'\n         BE    BADJULDT\n         MVC   STADATE,OUTSTDAT\n         MVC   JULDATE,DATEIN\n         MVC   SERDATE,OUTSERDT\n         B     EXITJUL\nBADJULDT LA    R4,4\nEXITJUL  L     R14,SAVEIT5\n         BR    R14\n         EJECT\n*\n********************************************************************\n*                                                                  *\n*        THE ROUTINE IS RESPONSIBLE FOR PROCESSING A SERIAL        *\n*        DATE AND THEN CONVERTING IT TO STANDARD AND JULIAN        *\n*        DATES                                                     *\n*                                                                  *\n********************************************************************\n*\nCNVSERDT ST    R14,SAVEIT6\n         MVC   INSERDAT,DATEIN\n         CALL  SERLCONV,(SERLAREA)\n         CLC   SERLSW,=CL3'YES'\n         BNE   BADSERDT\n         MVC   INSTDATE,OUTSDATE\n         CALL  STOJCONV,(STOJAREA)\n         CLC   STOJSW,=CL3'YES'\n         BE    BADSERDT\n         MVC   STADATE,INSTDATE\n         MVC   JULDATE,OUTJULDT\n         MVC   SERDATE,DATEIN\n         B     EXITSER\nBADSERDT LA    R4,4\nEXITSER  L     R14,SAVEIT6\n         BR    R14\n         EJECT\n********************************************************************\n*                                                                  *\n*        BUILD UPDTLIST (IKJUPDT PARM LIST)                        *\n*                                                                  *\n********************************************************************\n*\nINITLIST ST    R14,SAVEIT7\n         MVC   UPDTUPT,CPPLUPT          UPT\n         MVC   UPDTECT,CPPLECT          ECT\n         LA    R9,ECB\n         ST    R9,UPDTECB               ECB\n         LA    R8,UPLIST\n         ST    R8,UPDTUPL               UPLIST\n         L     R14,SAVEIT7\n         BR    14\n         EJECT\n********************************************************************\n*                                                                  *\n*        BUILD UPDATE PARM LIST FOR &STADATE AND CALL IKJUPDT      *\n*                                                                  *\n********************************************************************\n*\nSETSTDAT ST    R14,SAVEIT8\n         LA    R9,=C'STADATE'      R9 ==> ADDRESS OF VAR NAME\n         ST    R9,LOCPTR           STORE ADDR OF VAR NAME IN LOCPTR\n         MVC   LOCLEN,=F'7'        LOCLEN = LENGTH OF VAR NAME\n         LA    R5,STADATE          R5 ==> ADDRESS OF VARIABLE\n         ST    R5,VALPTR           STORE ADDRESS OF VARIABLE IN VALPTR\n         MVC   VALLEN,=F'6'        VALLEN = LENGTH OF DATA FIELD\n         LA    R1,UPDTLIST         R1 ==> IKJUPDT PARM LIST\n         CALL  IKJUPDT             DO THE UPDATE\n         L     R14,SAVEIT8\n         BR    14\n         EJECT\n********************************************************************\n*                                                                  *\n*        BUILD UPDATE PARM LIST FOR &JULDATE AND CALL IKJUPDT      *\n*                                                                  *\n********************************************************************\n*\nSETJUDAT ST    R14,SAVEIT9\n         LA    R9,=C'JULDATE'      R9 ==> ADDRESS OF VAR NAME\n         ST    R9,LOCPTR           STORE ADDR OF VAR NAME IN LOCPTR\n         MVC   LOCLEN,=F'7'        LOCLEN = LENGTH OF VAR NAME\n         LA    R5,JULDATE          R5 ==> ADDRESS OF VARIABLE\n         ST    R5,VALPTR           STORE ADDRESS OF VARIABLE IN VALPTR\n         MVC   VALLEN,=F'5'        VALLEN = LENGTH OF DATA FIELD\n         LA    R1,UPDTLIST         R1 ==> IKJUPDT PARM LIST\n         CALL  IKJUPDT             DO THE UPDATE\n         L     R14,SAVEIT9\n         BR    14\n         EJECT\n********************************************************************\n*                                                                  *\n*        BUILD UPDATE PARM LIST FOR &SERDATE AND CALL IKJUPDT      *\n*                                                                  *\n********************************************************************\n*\nSETSEDAT ST    R14,SAVEIT10\n         LA    R9,=C'SERDATE'      R9 ==> ADDRESS OF VAR NAME\n         ST    R9,LOCPTR           STORE ADDR OF VAR NAME IN LOCPTR\n         MVC   LOCLEN,=F'7'        LOCLEN = LENGTH OF VAR NAME\n         LA    R5,SERDATE          R5 ==> ADDRESS OF VARIABLE\n         ST    R5,VALPTR           STORE ADDRESS OF VARIABLE IN VALPTR\n         MVC   VALLEN,=F'5'        VALLEN = LENGTH OF DATA FIELD\n         LA    R1,UPDTLIST         R1 ==> IKJUPDT PARM LIST\n         CALL  IKJUPDT             DO THE UPDATE\n         L     R14,SAVEIT10\n         BR    14\n         EJECT\n********************************************************************\n*                                                                  *\n*        E N D   O F   J O B   R O U T I N E                       *\n*                                                                  *\n********************************************************************\n*\nSHUTDOWN LR   R15,R4\n         LEAVER\n         EJECT\n         SPACE 3\n********************************************************************\n*                                                                  *\n*        D A T A   A R E A   C O N S T A N T S                     *\n*                                                                  *\n********************************************************************\n*\nSTADATE  DS    CL6\nJULDATE  DS    CL5\nSERDATE  DS    CL5\n         EJECT\n         SPACE 3\n********************************************************************\n*                                                                  *\n*        S T O J C O N V   L I N K A G E   A R E A                 *\n*                                                                  *\n********************************************************************\n*\nSTOJAREA DS    0CL27\n         DS    CL8\nINSTDATE DS    CL6\nOUTJULDT DS    CL5\nOUTSERDT DS    CL5\nSTOJSW   DS    CL3\n         EJECT\n         SPACE 3\n********************************************************************\n*                                                                  *\n*        J T O S C O N V   L I N K A G E   A R E A                 *\n*                                                                  *\n********************************************************************\n*\nJTOSAREA DS    0CL22\n         DS    CL8\nOUTSTDAT DS    CL6\nINJULDAT DS    CL5\nJTOSSW   DS    CL3\n         EJECT\n         SPACE 3\n********************************************************************\n*                                                                  *\n*        S E R L C O N V   L I N K A G E   A R E A                 *\n*                                                                  *\n********************************************************************\n*\nSERLAREA DS    0CL22\n         DS    CL8\nINSERDAT DS    CL5\nOUTSDATE DS    CL6\nSERLSW   DS    CL3\n         LTORG\n         EJECT\n         SPACE 3\n********************************************************************\n*                                                                  *\n*        D Y N A M I C   W O R K   A R E A                         *\n*                                                                  *\n********************************************************************\n*\nWORKAREA DSECT\nSAVEAREA DS    18F\nANS      DS    F\nECB      DS    F\nACTCDIN  DS    CL3\nDATEIN   DS    CL6\nPPLA     DS    7F\nPROCESSW DS    CL3\nSAVEIT1  DS    F\nSAVEIT2  DS    F\nSAVEIT3  DS    F\nSAVEIT4  DS    F\nSAVEIT5  DS    F\nSAVEIT6  DS    F\nSAVEIT7  DS    F\nSAVEIT8  DS    F\nSAVEIT9  DS    F\nSAVEIT10 DS    F\n*\nUPDTLIST DS    0F\nUPDTUPT  DS    F\nUPDTECT  DS    F\nUPDTECB  DS    F\nUPDTUPL  DS    F\n*\nUPLIST   DS    0F\nLOCPTR   DS    AL4\nLOCLEN   DS    FL4\nVALPTR   DS    AL4\nVALLEN   DS    FL4\n*\nWORKLEN  EQU   *-WORKAREA\nDATECONV CSECT\n         EJECT\n********************************************************************\n*                                                                  *\n*                   P A R S E   M A C R O S                        *\n*                                                                  *\n********************************************************************\n*\nPCL      IKJPARM\nACTCODE  IKJKEYWD\n         IKJNAME 'ACTCODE',SUBFLD=ACTCD\nINDATE   IKJKEYWD\n         IKJNAME 'INDATE',SUBFLD=INDAT\nACTCD    IKJSUBF\nACTCDSTR IKJIDENT 'ACT CODE',MAXLNTH=3,FIRST=ALPHA\nINDAT    IKJSUBF\nDATSTRNG IKJIDENT 'IN DATE',MAXLNTH=6,FIRST=NUMERIC,CHAR\n         IKJENDP\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DDNTODS$": {"ttr": 14341, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x00\\x7f\\x00\\x88\\x00\\x7f\\x12\\x00\\x00A\\x00A\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf2\\xf7\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-01-07T00:00:00", "modifydate": "1988-01-07T12:00:00", "lines": 65, "newlines": 65, "modlines": 0, "user": "FILE270"}, "text": "1                                                        DDNTODSN.1\n                                                         06/25/82\n\n\n  PROGRAM:       DDNTODSN\n  AUTHOR:        Jeff Sprehn\n  AGENCY:        WDPSC\n  LANGUAGE:      Assembler\n  LOCATION:      WDPSC.SHARED.LOAD\n  FUNCTION:      Obtain DSNAME and VOLSER(s)  of data set allocated\n                 to a given DDNAME.\n\n  RUN MODE:      Batch or Interactive\n\n  This program is a  subroutine meant to be called by  a high level\n  language program such as COBOL which  will accept a DDNAME passed\n  to it and pass  back the DSNAME allocated to that  DDNAME and the\n  volume serial number(s) where the data set resides.\n\n  To call this program, do the following:\n\n       Move your 8 byte DDNAME to DDNAME of DDNTODSN-I-O-AREA.\n\n       CALL 'DDNTODSN' using DDNTODSN-I-O-AREA.\n\n            Where:\n                 01  DDNTODSN-I-O-AREA.\n                    05  FILLER  VALUE 'VS' PIC X(2).\n                    05  DDNAME             PIC X(8).\n                    05  DSNAME             PIC X(44).\n                    05  VOL-COUNT          PIC S9(5) COMP.\n                    05  VOL-TABLE\n                        OCCURS 5 TIMES     PIC X(6).\n                    05  SUCCESS-INDICATOR  PIC 99.\n\n       Success-Indicator   Meaning\n          00              DSNAME was successfully generated\n          04              DDNAME was not allocated\n                             (i.e., DSNAME could not be generated)\n\n\n\n\n1                                                        DDNTODSN.2\n                                                         06/25/82\n\n\n  After the call, interrogate SUCCESS-INDICATOR.\n\n  If SUCCESS-INDICATOR = 0/, then  DSNAME, VOL-COUNT, and VOL-TABLE\n                         /0\n  contain the following:\n\n       DSNAME         DSNAME of the data set allocated to the given\n                      DDNAME.\n\n       VOL-COUNT      A number representing the significant entries\n                      in VOL-TABLE.\n\n       VOL-TABLE      Table  of volume  serial  numbers where  your\n                      data set resides.\n\n\n\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "DDNTODSN": {"ttr": 14343, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x00\\x7f\\x00\\x88\\x00\\x7f\\x12\\x00\\x00\\xfc\\x00\\xfc\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf2\\xf7\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-01-07T00:00:00", "modifydate": "1988-01-07T12:00:00", "lines": 252, "newlines": 252, "modlines": 0, "user": "FILE270"}, "text": "         PRINT ON,NOGEN\n         SPACE 3\n*        THIS PROGRAM IS A SUBROUTINE WHICH WILL ACCEPT A DDNAME\n*        PASSED TO IT IN THE PARAMETER LIST AND PASS BACK THE DSNAME\n*        ALLOCATED TO THAT DDNAME AND THE VOLUME SERIAL NUMBER(S)\n*        WHERE THE DATASET RESIDES.\n*\n*        TO CALL THIS PROGRAM, DO THE FOLLOWING :\n*\n*           MOVE YOUR 8 BYTE DDNAME TO DDNAME OF DDNTODSN-I-O-AREA.\n*\n*           CALL 'DDNTODSN' USING DDNTODSN-I-O-AREA.\n*\n*                WHERE:\n*\n*                      01  DDNTODSN-I-O-AREA.\n*                          05  FILLER  VALUE 'VS' PIC X(2).\n*                          05  DDNAME             PIC X(8).\n*                          05  DSNAME             PIC X(44).\n*                          05  VOL-COUNT          PIC S9(5) COMP.\n*                          05  VOL-TABLE\n*                              OCCURS 5 TIMES     PIC X(6).\n*                          05  SUCCESS-INDICATOR  PIC 99.\n*\n*\n*         SUCCESS-INDICATOR   MEANING\n*         -----------------   -----------------------------------\n*\n*                00           DSNAME WAS SUCCESSFULLY GENERATED\n*                04           DDNAME WAS NOT ALLOCATED\n*                                (I.E. DSNAME COULD NOT BE GENERATED)\n         EJECT\n         SPACE 3\n*\n*\n*\n*\n*\n*\n*        ASSIGNMENT OF REGISTERS\n*        -----------------------\n*\n*        REGISTER      USAGE\n*        --------      -------------------------------------------\n*\n*           1          ADDRESS OF PARAMETER LIST\n*           2          NOT USED\n*           3          WORK REGISTER\n*           4          WORK REGISTER\n*           5          WORK REGISTER\n*           6          WORK REGISTER\n*           7          ADDRESS OF TIOT\n*           8          ADDRESS OF TCB\n*           9          ADDRESS OF CVT\n*           10         ADDRESS OF THE JFCB\n*           11         SAVE REGISTER 1\n*           12         BASE REGISTER\n*           13         ADDRESS OF SAVE AREA\n*           14         RETURN ADDRESS\n*           15         ENTRY POINT ADDRESS\n*\n*\n*\n*\n         EJECT\n         SPACE 3\n*\n**********************************************\n*                                            *\n*        I N I T I A L I Z A T I O N         *\n*                                            *\n**********************************************\n*\nDDNTODSN CSECT\n         SAVE  (14,12)\n         BALR  12,0\n         USING *,12\n         ST    13,SAVEAREA+4\n         LA    13,SAVEAREA\n         B     STARTIT\n         SPACE\nSAVEAREA DC    18F'0'\n         SPACE 3\n********************************************************************\n*        EQUATE RESISTERS 0 THRU 15 TO MORE MEANINGFUL NAMES       *\n********************************************************************\n         SPACE 3\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n         EJECT\n         SPACE 3\n*\n********************************************************************\n*                                                                  *\n*        SAVE REGISTER 1 IN REGISTER 11 AND LOAD PARAMETER FIELD   *\n*        INTO IOAREA                                               *\n*                                                                  *\n********************************************************************\n*\n         SPACE 3\nSTARTIT  DS    0D\n         LR    R11,R1              SAVE REGISTER 1 CONTENTS IN REG 11\n         L     R9,0(R11)\n         MVC   IOAREA,0(R9)\n         MVC   DSN(44),=CL44' '       INIT DSN OF IOAREA WITH SPACES\n         MVC   VOLTABLE(30),=CL30' '  INIT VOLTABLE OF IOAREA W SPACES\n         MVC   VOLCNT(4),=X'00000000' INIT VOLCNT OF IOAREA WITH\n*                                        BINARY ZAROES\n         EJECT\n         SPACE 3\n*\n********************************************************************\n*                                                                  *\n*        M A I N   L I N E   L O G I C                             *\n*                                                                  *\n********************************************************************\n*\n         BAL   R14,FINDDDN         PERFORM ROUTINE TO FIND THE\n*                                     DDNAME IN THE TIOT\n         CLC   FINDDNAM,=C'YES'    WAS DDNAME ALLOCATED ?\n         BNE   SHUTDOWN            IF NOT, BRANCH TO SHUTDOWN\n         BAL   R14,PRCSJFCB        PERFORM ROUTINE TO LOAD THE DSN\n*                                     AND VOL(S) FROM THE JFCB\n         B     SHUTDOWN            BRANCH TO SHUTDOWN\n         EJECT\n         SPACE 3\n*\n********************************************************************\n*                                                                  *\n*        THIS ROUTINE IS RESPONSIBLE FOR CHAINING FROM THE CVT     *\n*        TO THE TCB TO THE TIOT AND LOCATING THE DDNAME AND THE    *\n*        FINDING THE POINTER TO THE APPROPRIATE JFCB               *\n*                                                                  *\n********************************************************************\n*\nFINDDDN  ST    R14,SAVEIT1      STORE R14 CONTENTS IN SAVEIT1\n         L     R9,16            R9 ==> ADDRESS OF CVT\n         L     R6,0(R9)         R6 ==> ADDRESS OF A DOUBLE WORD\n*                                        POINTING TO THE TCB\n         LA    R5,TCBDWRD       R5 ==> ADDRESS OF DOUBLE WORD TCBDWRD\n         MVC   0(8,R5),0(R6)    MOVE TCB ADDRESSES TO TCBDWRD\n         L     R8,TCBDWRD+4     R8 ==> ADDRESS OF TCB\n         L     R7,12(R8)        R7 ==> ADDRESS OF THE TIOT\n         LR    R4,R7            R4 ==> ADDRESS OF THE TIOT\n         A     R4,=F'24'        R4 ==> FIRST LENGTH FIELD\nTIOTLOOP CLC   0(4,R4),=X'00000000'  END OF TIOT ?\n         BE    NOTALLOC         IF YES, BRANCH TO NOTALLOC\n         LR    R3,R4            R3 ==> R4\n         A     R3,=F'4'         ADD 4 TO R3\n         CLC   DDNAME(8),0(R3)  DDNAME PASSED = DDNAME IN TIOT ?\n         BE    YESALLOC         IF YES, BRANCH TO YESALLOC\n         LA    R6,0\n         IC    R6,0(R4)\n         AR    R4,R6\n         B     TIOTLOOP         BRANCH TO TIOTLOOP\nNOTALLOC MVC   FINDDNAM,=C'NO ' MOVE 'NO ' TO FINDDNAM\n         B     EXITDDN          BRANCH TO EXITDDN\nYESALLOC MVC   FINDDNAM,=C'YES' MOVE 'YES' TO FINDDNAM\n         A     R3,=F'8'         ADD 8 TO REGISTER 3\n         MVC   JFCBADDR+1(3),0(R3)\n         L     R10,JFCBADDR     R10 ==> ADDRESS OF THE JFCB\nEXITDDN  L     R14,SAVEIT1      RESTORE REG 14 WITH SAVEIT1 CONTENTS\n         BR    14               RETURN\n         EJECT\n         SPACE 3\n*\n********************************************************************\n*                                                                  *\n*        THIS ROUTINE IS RESPONSIBLE FOR PROCESSING THE JFCB.      *\n*        THE ADDRESS OF THE JFCB IS IN REGISTER 10.  THIS          *\n*        ROUTINE LOADS THE DSNAME, VOL-CNT, AND VOL-TABLE          *\n*        FROM THE APPROPRIATE FIELDS IN THE JFCB                   *\n*                                                                  *\n********************************************************************\n*\nPRCSJFCB ST    R14,SAVEIT2      STORE R14 CONTENTS IN SAVEIT2\n         MVC   DSN(44),16(R10)  MOVE DSNAME IN JFCB TO DSN IN IOAREA\n         LA    R5,0             R5 ==> ZERO\n         IC    R5,133(R10)      STICK R5 WITH JFCBNVOL\n         ST    R5,VOLNO\n         MVC   VOLCNT(4),VOLNO        GENERATE VOL-CNT OF IOAREA\n         MVC   VOLTABLE(30),134(R10)  GENERATE VOL-TABLE OF IOAREA\n         L     R14,SAVEIT2      RESTORE REG 14 WITH SAVEIT2 CONTENTS\n         BR    14               RETURN\n         EJECT\n         SPACE 3\n*\n********************************************************************\n*                                                                  *\n*        E N D  O F   J O B   P R O C E S S I N G                  *\n*                                                                  *\n********************************************************************\n*\nSHUTDOWN CLC   FINDDNAM,=C'YES'    WAS DDNAME ALLOCATED ?\n         BNE   NOPE                IF NOT, BRANCH TO NOPE\n         LA    R15,0               SET RC = 0\n         MVC   INDICATR,=C'00'     MOVE '00' TO INDICATR\n         B     PLESQUIT            BRANCH TO PLESQUIT\nNOPE     LA    R15,4               SET RC = 4\n         MVC   INDICATR,=C'04'     MOVE '04' TO INDICATR\nPLESQUIT L     R9,0(R11)\n         MVC   0(90,R9),IOAREA\n         L     R13,4(R13)\n         RETURN (14,12),RC=(15)\n         EJECT\n         SPACE 3\n*\n********************************************************************\n*                                                                  *\n*        BREAKDOWN OF IOAREA                                       *\n*                                                                  *\n********************************************************************\n*\nIOAREA   DS    0CL90\n         DS    CL2\nDDNAME   DS    CL8\nDSN      DS    CL44\nVOLCNT   DS    BL4\nVOLTABLE DS    CL30\nINDICATR DS    CL2\n         EJECT\n         SPACE 3\n*\n********************************************************************\n*                                                                  *\n*        D A T A   A R E A S                                       *\n*                                                                  *\n********************************************************************\n*\n         SPACE 3\n         DS    0F\nTCBDWRD  DS    D\nSAVEIT1  DS    F\nSAVEIT2  DS    F\nJFCBADDR DC    F'0'\nVOLNO    DS    F\nFINDDNAM DS    CL3\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "DEVTYPE": {"ttr": 14348, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x00\\x7f\\x00\\x88\\x00\\x7f\\x12\\x00\\x01L\\x01L\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf2\\xf7\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-01-07T00:00:00", "modifydate": "1988-01-07T12:00:00", "lines": 332, "newlines": 332, "modlines": 0, "user": "FILE270"}, "text": "*          DATA SET 764DEVTYPE AT LEVEL 003 AS OF 07/03/80\n*\n*\n*   DDDDDDD  EEEEEEEE VV    VV TTTTTTTT YY    YY PPPPPPP  EEEEEEEE\n*   DD    DD EE       VV    VV    TT    YY    YY PP    PP EE\n*   DD    DD EE       VV    VV    TT     YY  YY  PPPPPPP  EE\n*   DD    DD EEEEEEEE VV    VV    TT      YYYY   PP       EEEEEEEE\n*   DD    DD EEEEEEEE VV    VV    TT       YY    PP       EEEEEEEE\n*   DD    DD EE       VV    VV    TT       YY    PP       EE\n*   DD    DD EE        VV  VV     TT       YY    PP       EE\n*   DDDDDDD  EEEEEEEE    VV       TT       YY    PP       EEEEEEEE\n*\n*\n*  -----------------------------------------------------------------\n*  COMMAND     OPERANDS\n*  -----------------------------------------------------------------\n*  DEVTYPE     VOL('VOL SER NUMBER')\n*  -----------------------------------------------------------------\n*\n*\n*  OPERANDS -\n*\n*       REQUIRED -\n*\n*           VOL('VOL SER NUMBER') -- 'VOL SER NUMBER' IS THE VOLUME\n*                                     SERIAL NUMBER OF THE DISK PACK\n*                                     THAT YOU WISH TO KNOW THE DEVICE\n*                                     TYPE.\n*\n*                                           E.G.\n*\n*                                        VOLUME SERIAL NUMBER 335041\n*                                        WILL RETURN IN CLIST VARIABLE\n*                                        &DEVTYP 3350.  VOL SER 222022\n*                                        WILL RETURN IN CLIST VARIABLE\n*                                        &DEVTYP 3330-1.\n*\n*\n*\n*\n*        THIS COMMAND RETURNS IN CLIST VARIABLE &DEVTYP THE DEVICE\n*        TYPE FOR A VOLUME SERIAL NUMBER (PROVIDED IN THE VOL KEYWORD\n*        PARAMETER).  THEREFORE THE POSSIBLE VALUES FOR &DEVTYP ARE\n*        AS FOLLOWS:\n*\n*                  '2305  '\n*                  '2305-2'\n*                  '3330-1'\n*                  '3350  '\n*                  '3380  '\n*\n         EJECT\n*\n*\n*        THIS COMMAND WILL ALSO MAKE AVAILABLE TWO OTHER VARIABLES\n*        THAT THE INVOKING CLIST MAY INTERROGATE.  BELOW IS A TABLE\n*        OF VALUES AFTER EXECUTION OF THIS COMMAND FOR THESE TWO\n*        VARIABLES &OUTMSG AND &LASTCC (RETURN CODE)\n*\n*        |---------|-----------------------------------------------|\n*        | &LASTCC |                 &OUTMSG                       |\n*        |---------|-----------------------------------------------|\n*        |    0    | SUCCESSFUL COMPLETION                         |\n*        |---------|-----------------------------------------------|\n*        |    4    | MISSING REQUIRED PARAMETER VOL                |\n*        |---------|-----------------------------------------------|\n*        |    8    | VOL PARAM MUST BE 5 OR 6 BYTES                |\n*        |---------|-----------------------------------------------|\n*        |   12    | VOLUME NOT MOUNTED                            |\n*        |---------|-----------------------------------------------|\n*        |   20    | NON RECOGNIZABLE UNIT TYPE                    |\n*        |---------|-----------------------------------------------|\n*        |   96    | INVALID SYNTAX OF OPERAND                     |\n*        |---------|-----------------------------------------------|\n         EJECT\nDEVTYPE  ENTERR\n         EJECT\n********************************************************************\n*                                                                  *\n*      M A I N   L I N E   L O G I C   F O R   D E V T Y P E       *\n*                                                                  *\n********************************************************************\n*\n         LR    R11,R1              SAVE THE PARM POINTER\n         BAL   R14,DOPARSE         PERFORM THE PARSE SERVICE ROUTINE\n         CLC   PROCESSW,=C'YES'    WAS PARSE SUCCESFUL ?\n         BNE   INITL               IF NOT, BRANCH TO INITL\n         BAL   R14,LOADVOL         PERFORM ROUTINE TO LOAD THE PARSED\n*                                    FIELD INTO VOLSER\n         CLC   PROCESSW,=C'YES'    IS EVERTHING STILL HONKEY DOREY ?\n         BNE   INITL               IF NOT, BRANCH TO INITL\n         BAL   R14,LOADDEVT        PERFORM ROUTINE TO PROCESS VOLSER\n*                                    AND LOAD DATA FIELD DEVTYPE\n*                                    WHICH WILL BECOME THE CLIST\n*                                    VARIABLE\nINITL    BAL   R14,INITLIST        BUILD PARMLIST FOR IKJUPDT\n         BAL   R14,SETDEVT         SET CLIST VARIABLE DEVTYP\n         BAL   R14,SETOUTMG        SET CLIST VARIABLE OUTMSG\n         B     SHUTDOWN            BRANCH TO SHUTDOWN\n         EJECT\n********************************************************************\n*                                                                  *\n*        P A R S E   I N P U T   C O M M A N D   B U F F E R       *\n*                                                                  *\n********************************************************************\n*\nDOPARSE  ST    R14,SAVEIT1\n         KKPARSE\n         LTR   R15,R15              RC = 0 ? (I.E PARSE GO OK ?)\n         BNZ   PARSERR              IF NOT, BRANCH TO PARSERR\n         MVC   PROCESSW,=C'YES'     MOVE 'YES' TO PROCESSW\n         L     R10,ANS\n         USING IKJPARMD,R10\n         B     EXITPARS\nPARSERR  MVC   PROCESSW,=C'NO '     MOVE 'NO ' TO PROCESSW\n         LA    R4,96                SET REG 4 = 96\n         MVC   OUTMSG,MESS96        MOVE 'INVALID SYNTAX OF OPERAND'\n*                                       TO OUTMSG\nEXITPARS L     R14,SAVEIT1\n         BR    14\n         EJECT\n********************************************************************\n*                                                                  *\n*        THIS ROUTINE PROCESSES THE PARSED FIELD AND THEN          *\n*        LOADS DATA FIELD VOLSER.                                  *\n*                                                                  *\n********************************************************************\n*\nLOADVOL  ST    R14,SAVEIT2\n         TM    VSTRING+6,X'80'         IS VOL SER PRESENT ?\n         BNO   NOVOLSR                 IF NOT, BRANCH TO NOVOLSR\n         MVC   VOLSER,=CL6' '          MOVE SPACES TO VOLSER\n         LH    R7,VSTRING+4            R7 ==> LENGTH OF THE VOL SER\n         C     R7,=F'6'                IS LENGTH OF VOL = 6 ?\n         BE    MOVE6                   IF YES, BRANCH TO MOVE6\n         C     R7,=F'5'                IS LENGTH OF VOL = 5 ?\n         BE    MOVE5                   IF YES, BRANCH TO MOVE5\n         B     RONGLEN                 BRANCH TO RONGLEN\nMOVE6    L     R8,VSTRING              R8 ==> ADDRESS OF THE VOL SER\n         MVC   VOLSER,0(R8)            MOVE THE VOL SER TO VOLSER\n         MVC   PROCESSW,=C'YES'        MOVE 'YES' TO PROCESSW\n         B     EXITLOAD                BRANCH TO EXITLOAD\nMOVE5    L     R8,VSTRING              R8 ==> ADDRESS OF THE VOL SER\n         MVC   VOLSER(5),0(R8)         MOVE THE VOL SER TO VOLSER\n         MVC   PROCESSW,=C'YES'        MOVE 'YES' TO PROCESSW\n         B     EXITLOAD                BRANCH TO EXITLOAD\nNOVOLSR  MVC   PROCESSW,=C'NO '        MOVE 'NO ' TO PROCESSW\n         LA    R4,4                    SET R4 = 4\n         MVC   OUTMSG,MESS4            MOVE 'MISSING REQUIRD PARAMETER'\n*                                         TO OUTMSG\n         B     EXITLOAD                BRANCH TO EXITLOAD\nRONGLEN  MVC   PROCESSW,=C'NO '        MOVE 'NO ' TO PROCESSW\n         LA    R4,8                    SET R4 = 8\n         MVC   OUTMSG,MESS8            MOVE 'VOL PARAM MUST BE 5 OR 6\n*                                         BYTES' TO OUTMSG\nEXITLOAD L     R14,SAVEIT2\n         BR    14\n         EJECT\n********************************************************************\n*                                                                  *\n*        THIS ROUTINE IS RESPONSIBLE FOR CREATING THE DATA         *\n*        ELEMENT DEVTYP WHICH WILL BECOME THE CLIST VARIABLE       *\n*        &DEVTYP BY EXAMINING THE VOLUME SERIAL NUMBER MADE        *\n*        AVAILABLE TO THIS ROUTINE IN VOLSER                       *\n*                                                                  *\n********************************************************************\n*\nLOADDEVT ST    R14,SAVEIT3\n         MVC   VOL2DVOL,VOLSER\n         CALL  VOL2DEVT,(DEVTAREA),VL\n         C     R15,=F'0'              WAS VOL2DEVT SUCCESSFUL ?\n         BE    MOVEDEVT               IF SO, BRANCH TO MOVEDEVT\n         C     R15,=F'4'              VOLUME NOT MOUNTED ?\n         BE    NOTMNTED               IF SO, BRANCH TO NOTMNTED\n         LA    R4,20                  SET R4 = 20\n         MVC   OUTMSG,MESS20          MOVE 'NON RECOGNIZBLE UNIT TYPE'\n*                                       TO OUTMSG\n         B     EXITDEVT               BRANCH TO EXITDEVT\nNOTMNTED LA    R4,12                  SET R4 = 12\n         MVC   OUTMSG,MESS12          MOVE 'VOLUME NOT MOUNTED'\n*                                       TO OUTMSG\n         B     EXITDEVT               BRANCH TO EXITDEVT\nMOVEDEVT MVC   DEVTYP(6),OUTDEVT\n         LA    R4,0                   SET R4 = 0\n         MVC   OUTMSG,MESS0           MOVE 'SUCCESSFUL COMPLETION'\n*                                       TO OUTMSG\nEXITDEVT L     R14,SAVEIT3\n         BR    14\n         EJECT\n********************************************************************\n*                                                                  *\n*        BUILD UPDTLIST (IKJUPDT PARM LIST)                        *\n*                                                                  *\n********************************************************************\n*\nINITLIST ST    R14,SAVEIT4\n         MVC   UPDTUPT,CPPLUPT          UPT\n         MVC   UPDTECT,CPPLECT          ECT\n         LA    R9,ECB\n         ST    R9,UPDTECB               ECB\n         LA    R8,UPLIST\n         ST    R8,UPDTUPL               UPLIST\n         L     R14,SAVEIT4\n         BR    14\n         EJECT\n********************************************************************\n*                                                                  *\n*        BUILD UPDATE PARM LIST FOR &DEVTYP AND CALL IKJUPDT       *\n*                                                                  *\n********************************************************************\n*\nSETDEVT  ST    R14,SAVEIT5\n         LA    R9,=C'DEVTYP'       R9 ==> ADDRESS OF VAR NAME\n         ST    R9,LOCPTR           STORE ADDR OF VAR NAME IN LOCPTR\n         MVC   LOCLEN,=F'6'        LOCLEN = LENGTH OF VAR NAME\n         LA    R5,DEVTYP           R5 ==> ADDRESS OF VARIABLE\n         ST    R5,VALPTR           STORE ADDRESS OF VARIABLE IN VALPTR\n         MVC   VALLEN,=F'0'\n         MVC   VALLEN+2(2),OUTDEVLN  VALLEN = LENGTH OF DEVICE TYPE\n         LA    R1,UPDTLIST         R1 ==> IKJUPDT PARM LIST\n         CALL  IKJUPDT             DO THE UPDATE\n         L     R14,SAVEIT5\n         BR    14\n         EJECT\n********************************************************************\n*                                                                  *\n*        BUILD UPDATE PARM LIST FOR &OUTMSG AND CALL IKJUPDT       *\n*                                                                  *\n********************************************************************\n*\nSETOUTMG ST    R14,SAVEIT6\n         LA    R9,=C'OUTMSG'       R9 ==> ADDRESS OF VAR NAME\n         ST    R9,LOCPTR           STORE ADDR OF VAR NAME IN LOCPTR\n         MVC   LOCLEN,=F'6'        LOCLEN = LENGTH OF VAR NAME\n         LA    R5,OUTMSG           R5 ==> ADDRESS OF VARIABLE\n         ST    R5,VALPTR           STORE ADDRESS OF VARIABLE IN VALPTR\n         MVC   VALLEN,=F'30'       VALLEN = LENGTH OF DATA FIELD\n         LA    R1,UPDTLIST         R1 ==> IKJUPDT PARM LIST\n         CALL  IKJUPDT             DO THE UPDATE\n         L     R14,SAVEIT6\n         BR    14\n         EJECT\n********************************************************************\n*                                                                  *\n*        E N D   O F   J O B   R O U T I N E                       *\n*                                                                  *\n********************************************************************\n*\nSHUTDOWN LR   R15,R4\n         LEAVER\n         EJECT\n         SPACE 3\n********************************************************************\n*                                                                  *\n*        D A T A   A R E A   C O N S T A N T S                     *\n*                                                                  *\n********************************************************************\n*\nMESS0    DC    C'SUCCESSFUL COMPLETION         '\nMESS4    DC    C'MISSING REQUIRED PARAMETER VOL'\nMESS8    DC    C'VOL PARAM MUST BE 5 OR 6 BYTES'\nMESS12   DC    C'VOLUME NOT MOUNTED            '\nMESS16   DC    C'UCB ERROR                     '\nMESS20   DC    C'NON RECOGNIZABLE UNIT TYPE    '\nMESS96   DC    C'INVALID SYNTAX OF OPERAND     '\n         SPACE 3\n*\n********************************************************************\n*                                                                  *\n*     V O L 2 D E V T   L I N K A G E   A R E A                    *\n*                                                                  *\n********************************************************************\n*\nDEVTAREA DS    0CL16\nVOL2DVOL DS    CL6\nOUTDEVT  DS    CL8\nOUTDEVLN DS    CL2\n         LTORG\n         EJECT\n         SPACE 3\n********************************************************************\n*                                                                  *\n*        D Y N A M I C   W O R K   A R E A                         *\n*                                                                  *\n********************************************************************\n*\nWORKAREA DSECT\nSAVEAREA DS    18F\nPPLA     DS    7F\nANS      DS    F\nECB      DS    F\nVOLSER   DS    CL6\nDEVTYP   DS    CL6\nOUTMSG   DS    CL30\nPROCESSW DS    CL3\n         DS    0D\nSAVEIT1  DS    F\nSAVEIT2  DS    F\nSAVEIT3  DS    F\nSAVEIT4  DS    F\nSAVEIT5  DS    F\nSAVEIT6  DS    F\n*\nUPDTLIST DS    0F\nUPDTUPT  DS    F\nUPDTECT  DS    F\nUPDTECB  DS    F\nUPDTUPL  DS    F\n*\nUPLIST   DS    0F\nLOCPTR   DS    AL4\nLOCLEN   DS    FL4\nVALPTR   DS    AL4\nVALLEN   DS    FL4\n*\nACCTVAL  DS    CL9\nWORKLEN  EQU   *-WORKAREA\nDEVTYPE  CSECT\n         EJECT\n********************************************************************\n*                                                                  *\n*                   P A R S E   M A C R O S                        *\n*                                                                  *\n********************************************************************\n*\nPCL      IKJPARM\nVOL      IKJKEYWD DEFAULT='VOL'\n         IKJNAME 'VOLUME',SUBFLD=VOLSR,ALIAS=('VOLSER')\nVOLSR    IKJSUBF\nVSTRING  IKJPOSIT DSNAME,VOLSER\n         IKJENDP\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "DEVTYPE$": {"ttr": 14598, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x00\\x7f\\x00\\x88\\x00\\x7f\\x12\\x00\\x00D\\x00D\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf2\\xf7\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-01-07T00:00:00", "modifydate": "1988-01-07T12:00:00", "lines": 68, "newlines": 68, "modlines": 0, "user": "FILE270"}, "text": "1                                                        DEVTYPE.1\n                                                         09/01/83\n\n\n  COMMAND NAME:  DEVTYPE\n  AUTHOR:        Jeff Sprehn\n  AGENCY:        WDPSC\n  FUNCTION:      The DEVTYPE command is intended for use in command\n                 procedures.   This command  returns  to the  CLIST\n                 (thru CLIST variable &DEVTYP)  the device type for\n                 a given volume serial number.\n\n  Syntax -\n  __________________________________________________________________\n       Command        Operand\n  ------------------------------------------------------------------\n       DEVTYPE        VOL('vol ser number')\n  ------------------------------------------------------------------\n\n  Operands -\n\n       Required -\n\n            VOL('vol ser number') -- 'vol ser number' is the volume\n                           serial number of the disk pack for which\n                           you wish to know the device type.\n\n                           For example:\n\n                                     Volume  serial  number  335041\n                                     will return in  CLIST variable\n                                     &DEVTYP 3350.  Vol  ser 222022\n                                     will return in  CLIST variable\n                                     &DEVTYP 3330-1.\n\n\n\n\n1                                                        DEVTYPE.2\n                                                         09/01/83\n\n\n       This command  returns in CLIST  variable &DEVTYP  the device\n       type for a volume serial number (provided in the VOL keyword\n       parameter).  Therefore, the possible  values for &DEVTYP are\n       as follows:\n            '2305'\n            '3330-1'\n            '3350'\n            '3380'\n\n       This command  will also make  available two  other variables\n       that the invoking  CLIST may interrogate.  Below  is a table\n       of  values after  execution of  this command  for these  two\n       variables &OUTMSG and &LASTCC (return code).\n\n            &LASTCC   &OUTMSG\n             0        Successful completion\n             4        Missing required parameter VOL\n             8        VOL param must be 5 or 6 bytes\n            12        Volume not mounted\n            16        UCB error\n            20        Non recognizable unit type\n            96        Invalid syntax of operand\n\n\n\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "DOCLIB": {"ttr": 14600, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x00\\x7f\\x00\\x88\\x00\\x7f\\x12\\x00\\t\\r\\t\\r\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf2\\xf7\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-01-07T00:00:00", "modifydate": "1988-01-07T12:00:00", "lines": 2317, "newlines": 2317, "modlines": 0, "user": "FILE270"}, "text": "./ ADD NAME=A@TBLHDR 0101-84193-84193-1341-00111-00061-00000-JS02150\n1                                                        TBLHNDLR.1\n                                                         07/11/84\n\n  PROGRAM:       TBLHNDLR\n  AUTHOR:        Jeff Sprehn\n  AGENCY:        WDPSC\n  LANGUAGE:      COBOL\n  LOCATION:      WDPSC.SHARED.LOAD\n  FUNCTION:      Utility table handling program used by DOCSYS systems.\n                 This is the program that dynamically builds, scrolls,\n                 and processes the DOCSYS indexes and detail screens.\n\n\n  This is a general purpose Dialog Manager tabling services program.\n  This program accepts an input file which contains the table data and\n  then builds and displays a temporary virtual storage table.\n\n  The program processes two (2) action codes which are as follows:\n\n       S    Display documentation member\n       P    Print documentation member\n\n  Each record on the input file (which becomes an entry in the table)\n  instructs this program which ISPF SELECT CMD to invoke for the above\n  two action codes.\n\n\n  Input file format\n  .................\n\n    Cols         Contents\n    ---------    ------------------------------------\n\n    001 - 002    'D1' for first description line\n                 'D2' for 2nd description line if any\n                 'D3' for 3rd description line if any\n    003 - 003    FILLER\n    004 - 073    Description of entry (could be 1 - n\n                   columns of data represented here)\n                   this field is protected output.\n    074 - 074    FILLER\n    075 - 079    First 5 bytes of command name to be\n                   invoked if this entry is selected\n                   (spaces if this is not a 'D1' rec)\n    080 - 080    FILLER\n    081 - 200    Parameters to pass to command if this field is\n                   selected.  Three parameters must be supplied.\n                   (spaces if this is not a 'D1' rec)\n\n  For example;\n      If a record on the input file has 'DOC01' in\n      record positions 75-79:\n        then\n          the CLIST DOC01SEL will be invoked if the user\n                             selected action code = 'S'\n                    DOC01PRT will be invoked if the user\n                             selected action code = 'P'\n\n1                                                        TBLHNDLR.2\n                                                         07/11/84\n\n\n\n\n\n   The first three (3) records on the input file\n   however must contain panel title and column heading\n   information as follows:\n\n      Columns       Contents\n      -------       --------------------------------\n\n      001-002       'T1'  for the panel title\n                    'T2'  for panel column heading #1\n                    'T3'  for panel column heading #2\n      003-003       FILLER\n      004-082       Title or column heading\n      083-200       FILLER\n\n\n   A PARM must be passed to this program as follows:\n\n      ISPEXEC SELECT PGM(TBLHNDLR) PARM(n,tttttttt)\n\n           where:\n\n                 n = '1' for using panel TBLHDLR1\n                           (single spaced entries)\n                     '2' for using panel TBLHDLR2\n                           (double spaced entries)\n                     '3' for using panel TBLHDLR3\n                           (triple spaced entries)\n\n                 tttttttt =  5 - 8 byte table name\n\n\n\n   Return codes\n   ............\n\n       RC         Meaning\n       ----       ------------------------------------\n\n        0         Successful completion\n        4         T1, T2, T3 record(s) missing\n        8         TBCREATE failed\n        12        TBADD failed\n        16        Invalid or missing parm\n        20        Invalid input table entry record\n\n\n./ ADD NAME=ADDMEMO  0101-85120-87124-1422-00030-00026-00000-KK00150\n********************************************************************\n* Note: most of this info is no longer useful, as the PFK6 option  *\n*       is now used to add new documents to the document system.   *\n********************************************************************\n\n    How to add a memo to the Tech Services online document system (K.D).\n\n 1. Copy the memo into the SOFTD150.DOCSYS.MEMO library.\n\n 2. Edit the index for memos in SOFTD150.DOCSYS.INDEXES(TECHMEMO) and\n   create a new index line (at line four) similiar to the current ones.\n   The four items of non-display control information in column 75 are\n   updated as follows:\n\n   A. The first item is the DOCSYS component which handles a request for\n     this item. Should not need to be changed.\n\n   B. The DSNAME suffix added to SOFTD150.DOCSYS to make the library\n     name which contains the document. Should not need to be changed.\n\n   C. The member name of the memo. Use the name you copied your memo\n     with.\n\n   D. A parameter for sequential datasets and special print requirements.\n     Should remain as DUMMY1 normally.\n\n 3. To be real nice, you should edit the primary index in\n   SOFTD150.DOCSYS.INDEXES(TECHPRIM) and update the date for when the\n   last memo was added.\n\n./ ADD NAME=ALLOCGDG 0100-83362-83362-1449-00061-00061-00000-TMCR150\n1                                                        ALLOCGDG.1\n                                                         06/25/82\n\n\n  PROGRAM:       ALLOCGDG\n  AUTHOR:        Jeff Sprehn\n  AGENCY:        WDPSC\n  LANGUAGE:      Assembler\n  LOCATION:      WDPSC.SHARED.LOAD\n  FUNCTION:      Dynamically  allocate  a   generation  data  group\n                 member  expressed  with  the  relative  generation\n                 number to the DDNAME and DSNAME provided.\n\n  RUN MODE:      Interactive\n\n  This program is intended  to be used in CLISTS to  allocate a GDG\n  member expressed with the relative  generation number because the\n  TSO ALLOC command will not let you  do so.  Hence; if you wish to\n  allocate  a GDG  member expressed  with  the relative  generation\n  number, issue a CALL to this program in the CLIST where you would\n  normally place your  TSO ALLOC statement (if  the ALLOC statement\n  were to allow you to do so).\n\n  To call this program from a CLIST, do the following:\n\n       CALL 'WDPSC.SHARED.LOAD(ALLOCGDG)' 'ddname,dsn|'\n\n            where\n                 ddname is the ddname you wish the data set\n                        allocated to.\n\n                 dsn is the DSNAME of the GDG expressed with\n                     the relative generation number.\n\n\n\n\n1                                                        ALLOCGDG.2\n                                                         06/25/82\n\n\n  EXAMPLE:\n\n       CALL 'WDPSC.SHARED.LOAD(ALLOCGDG)' 'MASTERIN.AGY999.MY.GDG(+0)|'\n\n\n       After the call, &LASTCC will contain either 0 or 4.\n\n       If &LASTCC = 0, then the file was successfully allocated.\n       If &LASTCC = 4, then the file was not successfully allocated\n                       for the one of the following reasons:\n\n                       a.  Invalid DDNAME passed to this program.\n                       b.  Missing comma between DDNAME and DSN.\n                       c.  Data set DSN not cataloged.\n                       d.  Data set DSN not on on-line disk.\n                       e.  Missing | after the DSN in parm.\n\n\n\n\n./ ADD NAME=CHART    0113-80352-84009-1754-00232-00057-00000-KK00150\n1\n-                                                                CHART Clist\n0         Function -\n          The CHART Clist is used to enter the Interactive Chart Utility of\n          IBM's Presentation Graphics Feature (PGF).  It allocates the datasets\n          which are needed, creating them if necessary, then calls the Chart\n          Utility. It can also accept data created externally to the Chart\n          Utility for plotting, if the data is in the correct format.  You must\n          be on a 3279 or 3278 graphics terminal to use this clist.\n\n          Syntax -\n0         ______________________________________________________________________\n0              Command     Operands\n          ______________________________________________________________________\n0              CHART       DL(dsname) FL(dsname) IMPORT\n          ______________________________________________________________________\n0          Required operands - none.\n0          Defaults  - DL(CHART.DATA) FL(CHART.FORMAT)\n-         Operands -\n0           DL(dsname)-dsname is the name of a library for saving plot data. It\n                       is refered to as the data save library in this document.\n                       If it does not exist, you are prompted for a volume on\n                       which to place the dataset and it is created by the\n                       clist.  It must have LRECL and BLKSIZE equal to 400.\n\n            FL(dsname)-dsname is the name of a library for saving plot formats.\n                       It is refered to as the format library in this document.\n                       If it does not exist, you are prompted for a volume on\n                       which to place the dataset and it is created by the\n                       clist.  It must have LRECL and BLKSIZE equal to 400.\n\n1\n-           IMPORT   - This operand tells the chart clist that you wish to load\n                       plot data created outside of the chart utility.  The\n                       clist prompts you for the name of the library containing\n                       the externally created plot data. This library is\n                       refered to as the import data library in this document.\n                       A default name of prefix.CHART.IMPORT may be used by\n                       entering a null line.  The library members contain plot\n                       data in either of two formats explained following the\n                       description of the import menu.  The library format may\n                       be fixed or variable blocked.  The Chart Utility is\n                       entered through a special interface which presents a\n                       menu for selecting the member you wish to load and other\n                       options for plotting the data. If you select option 1\n                       and press enter, the member is loaded and plotted if\n                       there are no errors in it.  At that point you have\n                       access to all Chart Utility functions, including saving\n                       the data to the data save library. When you exit from\n                       the Chart Utility, the import menu is displayed again\n                       and you may load another member or terminate CHART.\n                       More detailed information on the import data format and\n                       menu options follows the examples below.\n\n-         Example 1 -\n0          Assume you wish to invoke the Chart Utility without importing data\n           and you use the default data save and format library names.\n0           CHART\n-         Example 2 -\n0          Assume you have an import data library named prefix.PLOT.DATA .\n           You then execute clist CHART as follows:\n0           CHART IMPORT\n0          The clist prompts you:\n0           ENTER NAME OF IMPORT DATA LIBRARY:\n            (JUST PRESS ENTER TO USE prefix.CHART.IMPORT)\n0          You type:\n0           PLOT.DATA\n0          The import menu is then displayed.\n1\n             Import Interface Menu:\n\n           The import interface displays an alphanumeric panel requesting the\n            following information:\n\n               I: The action you wish performed. If you select:\n\n                  1 - SHOW IMPORT CHART ; The member you specify is loaded from\n                    your import data library and, provided there are no errors,\n                    the Chart Utility is called to plot the data immediately.\n\n                  2 - PRINT IMPORT ONLY ; the member you specify is loaded from\n                    your import data library and, provided there are no errors,\n                    the Chart Utility is called to print the chart. The import\n                    menu is displayed again immediately.\n\n                  3 - LOAD IMPORT CHART ; the member you specify is loaded from\n                    your import data library and, provided there are no errors,\n                    the Chart Utility is called. The home panel is displayed.\n\n                  4 - LOAD SAVED CHART ; The Chart Utility is called to load\n                    the member specified from the data save library. The home\n                    panel is displayed.\n\n                  5 - SHOW SAVED CHART ; The Chart Utility is called to load\n                    the member specified from the data save library. The data\n                    is plotted immediately.\n\n              II: The name of the member containing the data to be loaded. This\n                  is the member name in your import data library for options\n                  1-3 or the member name in your data save library for options\n                  4-5.\n\n             III: The name of a format in your format library to be used for\n                  plotting.  (If an * is inserted, the default format is used\n                  by the Chart Utility.)\n\n              IV: Whether X-data is numeric values or character labels.\n\n                  If numeric values are selected, the X values are passed as\n                  numeric data (assuming this is possible).  This type may be\n                  used for surface charts and histograms as well as line\n                  graphs.\n\n                  If character labels are selected, the X values are passed as\n                  labels. This form is suitable for bar charts and pie charts.\n\n           Once the panel is completed (assuming PF3 or PF15 was not pressed),\n           provided there are no errors, the Chart Utility is called.  The user\n           can return to the import panel from the Chart Utility by using the\n           'exit' key (PF9).  Alternatively he may choose to modify the format\n           or data by using the facilities of the Chart Utility.\n\n           The Import Utility is terminated by PF3 or PF15 from the import\n           menu.\n1\n\n         Import Data Formats:\n\n           The import data library consists of members containing either table\n          data or paired data. The table data format is described below. The\n          paired data format is described on the following page.\n\n              Table data consists of a number of records which give a table of\n          data to be plotted.  The records are formatted as follows:\n\n           Record 1.\n              Contains the chart heading.  Leading and trailing blanks are\n              removed from the text supplied in the record and the resulting\n              string is used to title the generated chart.  The heading cannot\n              be longer than 132 characters.\n\n           Record 2.\n              Contains the column headings of the table, which will form the\n              chart keys. The chart keys are the labels used in the graph\n              legend to describe the dependent lines (variables).  These keys\n              must be single words (without imbedded blanks) of not more than\n              132 characters.  Occurrences of underscore characters (_) in a\n              word are replaced by blanks so that blank characters may be\n              generated in the key text if required.\n\n              One word must be provided for each data column to be plotted\n              (except the first, which is used as the X data).\n\n           Records 3 - n\n              Contain the table of data.    Each record contains one table row.\n              The first word is the 'X value' for the row, further words are\n              the dependent Y values.  There must be one Y value for each key\n              specified on the key record (Record 2).  X values may be numeric\n              or alphanumeric.  Y values must be numeric.\n\n          Sample data might be:\n\n             History of Results for XYZ Ltd. 1973-1980\n                      Costs       Sales\n             73        220         120\n             74        220         220\n             75        280         300\n             76        330         340\n             77        430         520\n             78        550         630\n             79        620         640\n             80        650         690\n1\n         Import Data Formats (continued):\n\n              Paired data consists of four types of records which describe one\n          or more groups of X-Y data pairs (paired data groups). In contrast to\n          table data, where each X value must have a Y value for all dependent\n          variables being plotted, paired data groups have X-Y pairs (points)\n          where each X value needs only one Y value.\n\n           Record 1.\n              Contains the chart heading.  Leading and trailing blanks are\n              removed from the text supplied in the record and the resulting\n              string is used to title the generated chart.  The heading cannot\n              be longer than 132 characters.\n\n           Record 2.\n              Contains the group labels for the chart.  The group labels (or\n              chart keys) are the labels used in the graph legend to describe\n              the dependent lines (variables).  These keys must be single words\n              (without imbedded blanks) of not more than 132 characters.\n              Occurrences of underscore characters (_) in a word are replaced\n              by blanks so that blank characters may be generated in the key\n              text if required.\n\n              This record can be left blank (not omitted) if the keys are\n              placed on the group delimiter records. (See Record 3 and example\n              below.)\n\n           Records 3 and where needed. (Group delimiter record.)\n              This record begins with the three character string \"=NG\" which\n              indicates the beginning of a new paired data group. It may also\n              include the group label (preceeded by at least one space) if\n              Record 2 was left blank. One \"=NG\" record must preceed each\n              paired data group in the chart.\n\n           Record 4 and all data records.\n              These records contain one X-Y pair per record.  The first word is\n              the 'X value' , and the second word is the Y value.  X values may\n              be numeric or alphanumeric. Y values must be numeric.\n\n          Here is an example of paired data with two groups. Record two has\n          been left blank and the labels placed on the group delimiter records:\n\n           XYZ Ltd. SALES REPORT 1975-1980\n\n          =NG         Actual\n             75        300\n             76        340\n             77        520\n             78        630\n             79        640\n             80        690\n          =NG         Projected\n             80        690\n             81        720\n             82        800\n             83        850\n             84        900\n             85        1000\n\n./ ADD NAME=CLERSCRN 0100-83363-83363-0852-00026-00026-00000-TMCR150\n1                                                        CLERSCRN.1\n                                                         06/25/82\n\n\n  CLIST:              CLERSCRN\n  AUTHOR:             Jeff Sprehn\n  AGENCY:             WDPSC\n  FUNCTION:           Clear screen on 3270 type terminal or write\n                      a blank line on a dialup terminal.\n\n  TERMINAL TYPE: 3270 type or dialup\n\n  The CLERSCRN  CLIST is  intended to be  invoked by  other CLISTS.\n  This CLIST will  clear the screen on 3270 type  terminals or will\n  write a blank line on a dialup terminal.\n\n  Syntax -\n  __________________________________________________________________\n       Command        Operands\n  ------------------------------------------------------------------\n        CLERSCRN      none\n  __________________________________________________________________\n\n\n\n\n./ ADD NAME=CNV2GREG 0102-83362-83362-1458-00140-00142-00000-TMCR150\n1                                                        CNV2GREG.1\n                                                         03/16/83\n\n\n  PROGRAM:       CNV2GREG\n  AUTHOR:        Jeff Sprehn\n  AGENCY:        WDPSC\n  LANGUAGE:      COBOL\n  LOCATION:      WDPSC.SHARED.LOAD\n  FUNCTION:      Subroutine which  accepts a standard  date, julian\n                 date,  or  serial  date and  returns  a  formatted\n                 gregorian date.\n\n  RUN MODE:      Batch or Interactive\n\n  This is a  subroutine which accepts a standard date  (of the form\n  MMDDYY), julian date (of the form  YYDDD), or serial date (of the\n  form NNNNN) and returns an l8 byte formatted date as follows:\n\n       18 Byte Field = MMMMMMMMM DD, 19YY\n            where\n                 MMMMMMMMM is 'January  '\n                              'February '\n                              'March    '\n                               Etc.\n\n                 DD        is day of month (zero suppressed)\n\n                 YY        is year\n\n  For further discussion on standard, julian, and serial dates, see\n  the documentation for STOJCONV in this manual.\n\n\n\n\n1                                                        CNV2GREG.2\n                                                         03/16/83\n\n\n  HOW TO USE THIS SUBROUTINE:\n\n  1.   Place the following data area in WORKING STORAGE:\n\n            01  CNV2GREG-I-O-AREA.\n                 05  INPUT-FIELDS.\n                      10  TYPE-OF-INPUT-DATE             PIC X(03).\n                      10  INPUT-DATE                     PIC X(06).\n                 05  OUTPUT-FIELDS.\n                     10  VALID-INPUT-DATE                 PIC X(03).\n                     10  FORMATTED-DATE                   PIC X(18).\n\n  2    Do the following in your PROCEDURE DIVISION:\n\n       a.   Load  TYPE-OF-INPUT-DATE with  'STA',  'JUL', or  'SER'\n            depending  upon whether  the date  to  be converted  is\n            standard, julian, or serial.\n\n       b.   Move the date to be converted to INPUT-DATE (INPUT-DATE\n            is 6 bytes  in length.  If the date to  be converted is\n            julian or serial, left justify it in INPUT-DATE.)\n\n       c.   CALL 'CNV2GREG' USING CNV2GREG-I-O-AREA.\n\n       d.   If VALID-INPUT-DATE = 'YES'\n                 the date was valid and the\n                 formatted date is in FORMATTED-DATE\n            ELSE\n                 the date to be converted is invalid.\n\n\n  3.   After the CALL, the formatted date is contained in\n       FORMATTED-DATE OF CNV2GREG-I-O-AREA.\n\n\n\n\n1                                                        CNV2GREG.3\n                                                         03/16/83\n\n\n  EXAMPLE:\n\n  Convert the current date from the computer to an 18\n  byte formatted date.\n\n  1.   Place the follwing 3 data areas in WORKING\n       STORAGE:\n\n                 01  CNV2GREG-I-O-AREA.\n                      05  INPUT-FIELDS.\n                          10  TYPE-OF-INPUT-DATE              PIC X(03).\n                          10  INPUT-DATE                      PIC X(06) .\n                 05  OUTPUT-FIELDS.\n                          10  VALID-INPUT-DATE                PIC X(03) .\n                          10  FORMATTED-DATE                  PIC X(18) .\n\n                 01  CURRENT-DATE-BREAKDOWN.\n                      05  MONTH                               PIC XX.\n                      05  FILLER                              PIC X.\n                      05  DAYY                                PIC XX.\n                      05  FILLER                              PIC X.\n                      05  YEAR                                PIC XX.\n\n                 01  CURRENT-DATE-STANDARD.\n                      05  MONTH                               PIC XX.\n                      05  DAYY                                PIC XX.\n                      05  YEAR                                PIC XX.\n\n\n\n\n1                                                             CNV2GREG.4\n                                                              03/16/83\n\n\n       2.   In the PROCEDURE DIVISION, do the following:\n\n                 MOVE CURRENT-DATE TO CURRENT-DATE-BREAKDOWN.\n\n                 MOVE MONTH OF CURRENT-DATE-BREAKDOWN\n                   TO MONTH OF CURRENT-DATE-STANDARD.\n                 MOVE DAYY  OF CURRENT-DATE-BREAKDOWN\n                   TO DAYY  OF CURRENT-DATE-STANDARD.\n                 MOVE YEAR  OF CURRENT-DATE-BREAKDOWN\n                   TO YEAR  OF CURRENT-DATE-STANDARD.\n\n                 MOVE CURRENT-DATE-STANDARD\n                   TO INPUT-DATE OF CNV2GREG-I-O-AREA.\n                 MOVE 'STA'\n                   TO TYPE-OF-INPUT-DATE OF CNV2GREG-I-O-AREA.\n\n                 CALL 'CNV2GREG' USING CNV2GREG-I-O-AREA.\n\n       3.   After the CALL, the formatted date is contained in\n            FORMATTED-DATE of CNV2GREG-I-O-AREA.\n\n\n\n\n./ ADD NAME=DOCSYS   0102-84024-84171-1453-00040-00037-00000-JS02150\n1\n\n\n    Documentation for the major top level CLIST  (in this case DOCSYS)\n    __________________________________________________________________\n\n\n     The following is a printout of DOCSYS:\n\n         line 1  CONTROL NOMSG NOFLUSH END(ENDO)\n         line 2  FREE F(SYSOUT)\n         line 3  ALLOC F(SYSOUT) DSN(*)\n         line 4  SET &DOCSLVL1 = WDPSC\n         line 5  SET &DOCSLVL2 = DOCSYS\n         line 6  SET &DOCSTITL = &STR(WDPSC DOCUMENTATION SYSTEM)\n         line 7  ISPEXEC VPUT DOCSLVL1\n         line 8  ISPEXEC VPUT DOCSLVL2\n         line 9  ISPEXEC VPUT DOCSTITL\n         line 10 SET &DOCSMEM = PRIM\n         line 11 ISPEXEC VPUT DOCSMEM\n         line 12 SET &DOCSEXIT = NO\n         line 13 ISPEXEC VPUT DOCSEXIT\n         line 14 ISPEXEC SELECT PGM(TBLHNDLR) PARM(1,PRIME)\n\n\n     To create your own documentation system, copy this CLIST and modify\n     the following lines as shown:\n\n         line 4   SET &DOCSLVL1 to highest level qualifier of index library\n\n         line 5   SET &DOCSLVL2 to second level qualifier of index library\n\n         line 6   SET &DOCSTITL to appropriate name of system\n\n\n     Then put your primary options in member name PRIM of the index library:\n     &DOCSLVL1..&DOCSLVL2..INDEXES\n\n\n\n./ ADD NAME=DOCTECH  0100-84285-84285-1937-00030-00030-00000-KK00150\n1\n\n\n    Documentation for the major top level CLIST  (in this case DOCTECH)\n    ___________________________________________________________________\n\n     The following is a printout of DOCTECH:\n\n                  CONTROL NOMSG NOFLUSH END(ENDO)\n                  CLOG '&SYSDATE &SYSTIME DOCTECH' U($$$$150) SAVE\n                  FREE F(SYSOUT)\n                  ALLOC F(SYSOUT) DSN(*)\n                  SET &DOCSLVL1 =  SOFTD150\n                  SET &DOCSLVL2 = DOCSYS\n                  SET &DOCSTITL = &STR(TECHNICAL SERVICES DOC SYSTEM)\n                  ISPEXEC VPUT DOCSLVL1\n                  ISPEXEC VPUT DOCSLVL2\n                  ISPEXEC VPUT DOCSTITL\n                  SET &DOCSMEM = TECHPRIM\n                  ISPEXEC VPUT DOCSMEM\n                  SET &DOCSEXIT = NO\n                  ISPEXEC VPUT DOCSEXIT\n                  ISPEXEC SELECT PGM(TBLHNDLR) PARM(1,PRIMET)\n\n    Note that the high level index name used is TECHPRIM.\n\n    Note that accesses to the system are logged by the cmd log system.\n\n    The TBLHNDLR program is documented in the CTS Document system\n    under CTS utilities.\n./ ADD NAME=DOC01PRT 0100-84024-84024-0950-00088-00088-00000-JS02150\n1\n\n\n      Documentation for CLIST:  DOC01PRT\n      __________________________________\n\n\n      This CLIST is used to print an entire doumentation system library.\n      The CLIST DOC03PRT is used to print an individual entry or member.\n\n      __________________________________________________________________________\n      CLIST Name   Operand(s)\n      __________________________________________________________________________\n\n      DOC01PRT     dummya   dummyb   list-lib\n      __________________________________________________________________________\n\n      Operands (all three required)\n\n                 dummya         dummya is not used for this CLIST.  However; it\n                                is used for CLIST DOC01SEL.  It contains the\n                                member name of the index library to be used.\n\n                 dummyb         dummyb is not used for this CLIST.  However; it\n                                is used for CLIST DOC01SEL.  It contains a value\n                                of '1', '2', or '3' instructing DOC01SEL which\n                                panel type to use.\n\n                 list-lib       list-lib has three acceptable values.  They are:\n\n                                     value             meaning\n                                     ______________    _________________________\n\n                                     DUMMY1            This tells the CLIST to\n                                                       print at the top right:\n\n                                                          NO PRINT AVAILABLE\n\n                                     aaaaaaaa          where aaaaaaaa is the\n                                                       lowest level qualifier of\n                                                       the documentation system\n                                                       library to print\n\n                                     aaaaaaaa-n        where aaaaaaaa is the\n                                                       same as above but n is\n                                                       '1', '2', or '3' as\n                                                       explained on next page.\n\n1\n\n\n      Documentation for CLIST:  DOC01PRT  (Continued)\n      _______________________________________________\n\n\n        The value of 'n' is used to signal what kinds of printing\n        will be allowed.  The three ways in which the documents can\n        be printed are as follows:\n\n              .  direct print to RJE  (via DEST=RMTxx)\n              .  direct print to 3800 Page printer rotated 90 degrees\n              .  route print to a local cluster printer\n\n\n        IF n=1, then a panel will be displayed which will allow all\n                three ways to print the dataset\n\n        IF n=2, then a panel will be displayed which will allow the\n                dataset to be printed at an RJE or at the 3800 Page\n                Printer rotated 90 degrees only\n\n        IF n=3, then a panel will be displayed which will allow the\n                dataset to be printed at the 3800 Page Printer rotated\n                90 degrees only\n\n\n\n\n      Assumptions\n      ___________\n\n         1.  A previous CLIST did the following:\n\n                  SET &DOCSLVL1 = highest level qualifier of index library\n                  ISPEXEC VPUT DOCSLVL1\n                  SET &DOCSLVL2 = second level qualifier of index library\n                  ISPEXEC VPUT DOCSLVL2\n\n./ ADD NAME=DOC01SEL 0101-84024-84041-1350-00057-00057-00000-JS02150\n1\n\n\n      Documentation for CLIST:  DOC01SEL\n      __________________________________\n\n      This CLIST is used to display an index identified by mem-name in either\n      the single, double, or triple spaced mode as identified by entry-count\n\n      __________________________________________________________________________\n      CLIST Name   Operand(s)\n      __________________________________________________________________________\n\n      DOC01SEL     mem-name   entry-count   DUMMY1\n      __________________________________________________________________________\n\n      Operands (all three required)\n\n                 mem-name       mem-name is the 5-8 byte member name to use as\n                                the index.  mem-name is the member name\n                                of the library &DOCSLVL1..&DOCSLVL2..INDEXES\n\n                                This CLIST does an ISPEXEC VGET for DOCSLVL1\n                                and DOCSLVL2.  These two variables must have\n                                been VPUT previously (in the main CLIST)\n\n                 entry-count    Must have a value of '1', '2', or '3'.\n                                Use a '1' for displaying the panel TBLHDLR1\n                                Use a '2' for displaying the panel TBLHDLR2\n                                Use a '3' for displaying the panel TBLHDLR3\n\n                                Panel TBLHDLR1 single spaces its entries with\n                                   NO all dashes delimiter records.\n                                Panel TBLHDLR2 double spaces its entries with\n                                   all dashes delimiter records.\n                                Panel TBLHDLR3 triple spaces its entries with\n                                   all dashes delimiter records.\n\n                 DUMMY1         This CLIST has 3 required positional parameters\n                                which is a requirement of ALL CLISTs invoked by\n                                the Documentation system.  This parameter is not\n                                used for this CLIST.  However; it is used for\n                                CLIST DOC01PRT\n\n      Assumptions\n      ___________\n\n         1.  A previous CLIST did the following:\n\n                  SET &DOCSLVL1 = highest level qualifier of index library\n                  ISPEXEC VPUT DOCSLVL1\n                  SET &DOCSLVL2 = second level qualifier of index library\n                  ISPEXEC VPUT DOCSLVL2\n\n         2.  The index library (LRECL=200) has the following three (3) level\n             DSNAME:\n                      &DOCSLVL1..&DOCSLVL2..INDEXES\n./ ADD NAME=DOC02PRT 0101-84285-84285-1900-00090-00090-00000-KK00150\n1\n      Documentation for CLIST:  DOC02PRT\n      __________________________________\n\n      This CLIST is used to print an individual entry or member of a\n      documentation system library. It is the same in function as the\n      DOC03PRT clist but is used for datasets outside of the Document System.\n\n      __________________________________________________________________________\n      CLIST Name   Operand(s)\n      __________________________________________________________________________\n\n      DOC02PRT     list-lib   mem-name  opt-list-lib\n      __________________________________________________________________________\n\n      Operands (all three required)\n\n            list-lib          list-lib is the name of the library whose member\n                              specified by mem-name is to be printed.\n\n                              HOWEVER: IF opt-list-lib IS NOT EQUAL TO \"DUMMY1\",\n                              then this paramater is not used and becomes a\n                              dummy parameter.\n\n            mem-name          mem-name is the member name of the documentation\n                              system library which is to be printed.\n\n                              HOWEVER: IF opt-list-lib IS NOT EQUAL TO \"DUMMY1\",\n                              then this paramater is not used and becomes a\n                              dummy parameter.\n\n            opt-list-lib      opt-list-lib has four acceptable values.\n                              They are:\n\n                                     value             meaning\n                                     ______________    _________________________\n\n                                     DUMMY1            This tells the CLIST to\n                                                       use the value supplied\n                                                       in list-lib and mem-name\n\n                                     DUMMY1-n          where DUMMY1 is the\n                                                       same as above but n is\n                                                       '1', '2', or '3' as\n                                                       explained on next page.\n\n1\n      Documentation for CLIST:  DOC02PRT  (Continued)\n      _______________________________________________\n\n\n                                     aaaaaaaa          where aaaaaaaa is the\n                                                       name of the dataset to\n                                                       print.  (Used for\n                                                       sequential datasets)\n\n                                                       THUS; THIS OVERRIDES THE\n                                                       VALUES SUPPLIED IN\n                                                       list-lib AND mem-name\n\n                                     aaaaaaaa-n        where aaaaaaaa is the\n                                                       same as above but n is\n                                                       '1', '2', or '3' as\n                                                       explained below.\n                                                       (Used for seq datasets)\n\n                                                       THUS; THIS OVERRIDES THE\n                                                       VALUES SUPPLIED IN\n                                                       list-lib AND mem-name\n\n\n        The value of 'n' is used to signal what kinds of printing\n        will be allowed.  The three ways in which the documents can\n        be printed are as follows:\n\n              .  direct print to RJE  (via DEST=RMTxx)\n              .  direct print to 3800 Page printer rotated 90 degrees\n              .  route print to a local cluster printer\n\n        IF n=1, then a panel will be displayed which will allow all\n                three ways to print the dataset\n\n        IF n=2, then a panel will be displayed which will allow the\n                dataset to be printed at an RJE or at the 3800 Page\n                Printer rotated 90 degrees only\n\n        IF n=3, then a panel will be displayed which will allow the\n                dataset to be printed at the 3800 Page Printer rotated\n                90 degrees only\n\n./ ADD NAME=DOC02SEL 0102-84285-84285-1901-00070-00070-00000-KK00150\n1\n\n      Documentation for CLIST:  DOC02SEL\n      __________________________________\n\n      This CLIST is used to do an ISPEXEC BROWSE on the dataset\n      that is passed to it. (The dataset can be sequential or a\n      member of a partitioned dataset. This is the same in function\n      as DOC03SEL but is used for datasets outside the Document System.\n\n      __________________________________________________________________________\n      CLIST Name   Operand(s)\n      __________________________________________________________________________\n\n      DOC02SEL     list-lib   member-name   opt-list-lib\n      __________________________________________________________________________\n\n      Operands (all three required)\n\n\n            list-lib          list-lib is the name of\n                              the library whose member\n                              is to be displayed.\n                                  e.g.\n                                     if list-lib is\n                                     PREF.ANYNAME.TECHBULL, then the\n                                     member of PREF.ANYNAME.TECHBULL\n                                     will be displayed via the ISPEXEC\n                                     BROWSE service\n\n            member-name       member-name is the member name of the\n                              library identified   by\n                              list-lib that is to be displayed\n\n            opt-list-lib      opt-list-lib has four acceptable values.\n                              They are:\n\n                                     value             meaning\n                                     ______________    _________________________\n\n                                     DUMMY1            This tells the CLIST to\n                                                       use the value supplied\n                                                       in list-lib and mem-name\n\n                                     DUMMY1-n          Same as DUMMY1, but the\n                                                       value of n is used by the\n                                                       CLIST DOC02PRT to select\n                                                       appropriate print request\n                                                       panel\n1\n\n      Documentation for CLIST:  DOC02SEL   (Continued)\n      ________________________________________________\n\n\n                                     aaaaaaaa          where aaaaaaaa is the\n                                                       name of the dataset to\n                                                       browse.  (Used for\n                                                       sequential datasets)\n\n                                                       THUS; THIS OVERRIDES THE\n                                                       VALUES SUPPLIED IN\n                                                       list-lib AND mem-name\n\n                                     aaaaaaaa-n        Same as aaaaaaaa, but the\n                                                       value of n is used by the\n                                                       CLIST DOC02PRT to select\n                                                       appropriate print request\n                                                       panel\n\n./ ADD NAME=DOC03PRT 0100-84024-84024-0952-00101-00101-00000-JS02150\n1\n      Documentation for CLIST:  DOC03PRT\n      __________________________________\n\n      This CLIST is used to print an individual entry or member of a\n      documentation system library.\n\n      __________________________________________________________________________\n      CLIST Name   Operand(s)\n      __________________________________________________________________________\n\n      DOC03PRT     list-lib   mem-name  opt-list-lib\n      __________________________________________________________________________\n\n      Operands (all three required)\n\n            list-lib          list-lib is the lowest level qualifier of the\n                              documentation system library whose member\n                              specified by mem-name is to be printed.\n\n                              HOWEVER: IF opt-list-lib IS NOT EQUAL TO \"DUMMY1\",\n                              then this paramater is not used and becomes a\n                              dummy parameter.\n\n            mem-name          mem-name is the member name of the documentation\n                              system library which is to be printed.\n\n                              HOWEVER: IF opt-list-lib IS NOT EQUAL TO \"DUMMY1\",\n                              then this paramater is not used and becomes a\n                              dummy parameter.\n\n            opt-list-lib      opt-list-lib has four acceptable values.\n                              They are:\n\n                                     value             meaning\n                                     ______________    _________________________\n\n                                     DUMMY1            This tells the CLIST to\n                                                       use the value supplied\n                                                       in list-lib and mem-name\n\n                                     DUMMY1-n          where DUMMY1 is the\n                                                       same as above but n is\n                                                       '1', '2', or '3' as\n                                                       explained on next page.\n\n1\n      Documentation for CLIST:  DOC03PRT  (Continued)\n      _______________________________________________\n\n\n                                     aaaaaaaa          where aaaaaaaa is the\n                                                       lowest level qualifier of\n                                                       the documentation system\n                                                       library to print.  (Used\n                                                       for sequential datasets)\n\n                                                       THUS; THIS OVERRIDES THE\n                                                       VALUES SUPPLIED IN\n                                                       list-lib AND mem-name\n\n                                     aaaaaaaa-n        where aaaaaaaa is the\n                                                       same as above but n is\n                                                       '1', '2', or '3' as\n                                                       explained below.\n                                                       (Used for seq datasets)\n\n                                                       THUS; THIS OVERRIDES THE\n                                                       VALUES SUPPLIED IN\n                                                       list-lib AND mem-name\n\n\n        The value of 'n' is used to signal what kinds of printing\n        will be allowed.  The three ways in which the documents can\n        be printed are as follows:\n\n              .  direct print to RJE  (via DEST=RMTxx)\n              .  direct print to 3800 Page printer rotated 90 degrees\n              .  route print to a local cluster printer\n\n        IF n=1, then a panel will be displayed which will allow all\n                three ways to print the dataset\n\n        IF n=2, then a panel will be displayed which will allow the\n                dataset to be printed at an RJE or at the 3800 Page\n                Printer rotated 90 degrees only\n\n        IF n=3, then a panel will be displayed which will allow the\n                dataset to be printed at the 3800 Page Printer rotated\n                90 degrees only\n\n\n      Assumptions\n      ___________\n\n         1.  A previous CLIST did the following:\n\n                  SET &DOCSLVL1 = highest level qualifier of index library\n                  ISPEXEC VPUT DOCSLVL1\n                  SET &DOCSLVL2 = second level qualifier of index library\n                  ISPEXEC VPUT DOCSLVL2\n./ ADD NAME=DOC03SEL 0100-84024-84024-0952-00078-00078-00000-JS02150\n1\n\n      Documentation for CLIST:  DOC03SEL\n      __________________________________\n\n      This CLIST is used to do an ISPEXEC BROWSE on the dataset\n      that is passed to it. (The dataset can be sequential or a\n      member of a partitioned dataset.\n\n      __________________________________________________________________________\n      CLIST Name   Operand(s)\n      __________________________________________________________________________\n\n      DOC03SEL     list-lib   member-name   opt-list-lib\n      __________________________________________________________________________\n\n      Operands (all three required)\n\n\n            list-lib          list-lib is the lowest level qualifier name of\n                              the documentation system library whose member\n                              is to be displayed.\n                                  e.g.\n                                     if list-lib is TECHBULL, then the member\n                                     of &DOCSLVL1..&DOCSLVL2..TECHBULL will\n                                     be displayed via the ISPEXEC BROWSE service\n\n            member-name       member-name is the member name of the\n                              documentation system library identified   by\n                              list-lib that is to be displayed\n\n            opt-list-lib      opt-list-lib has four acceptable values.\n                              They are:\n\n                                     value             meaning\n                                     ______________    _________________________\n\n                                     DUMMY1            This tells the CLIST to\n                                                       use the value supplied\n                                                       in list-lib and mem-name\n\n                                     DUMMY1-n          Same as DUMMY1, but the\n                                                       value of n is used by the\n                                                       CLIST DOC03PRT to select\n                                                       appropriate print request\n                                                       panel\n1\n\n      Documentation for CLIST:  DOC03SEL   (Continued)\n      ________________________________________________\n\n\n                                     aaaaaaaa          where aaaaaaaa is the\n                                                       lowest level qualifier of\n                                                       the documentation system\n                                                       library to print.  (Used\n                                                       for sequential datasets)\n\n                                                       THUS; THIS OVERRIDES THE\n                                                       VALUES SUPPLIED IN\n                                                       list-lib AND mem-name\n\n                                     aaaaaaaa-n        Same as aaaaaaaa, but the\n                                                       value of n is used by the\n                                                       CLIST DOC03PRT to select\n                                                       appropriate print request\n                                                       panel\n\n\n      Assumptions\n      ___________\n\n         1.  A previous CLIST did the following:\n\n                  SET &DOCSLVL1 = highest level qualifier of index library\n                  ISPEXEC VPUT DOCSLVL1\n                  SET &DOCSLVL2 = second level qualifier of index library\n                  ISPEXEC VPUT DOCSLVL2\n./ ADD NAME=DSN      0100-83363-83363-0856-00062-00062-00000-TMCR150\n1                                                        DSN.1\n                                                         03/16/83\n\n\n  CLIST:              DSN\n  AUTHOR:             Dan Parsons\n  AGENCY:             WDPSC\n  FUNCTION:           Display  list of  job  names  or TSO  userids\n                      currently using a dataset name.\n\n  TERMINAL TYPE: 3270 type or dialup\n\n  This CLIST displays the following information for each occurrence\n  of a dataset name being currently  used whose dataset name begins\n  with a specified string:\n\n       a.   JOB Name (or TSO Userid)\n       b.   Disposition of file (SHR or EXCL)\n       c.   Dataset Name\n\n  Syntax -\n  _________________________________________________________________\n            Command             Operands\n  _________________________________________________________________\n            DSN                 'dataset name string'\n  _________________________________________________________________\n\n  Required positional operands -\n\n       dataset name string      a string of characters (enclosed in\n                                quotes)  either consisting  of  the\n                                desired dataset  name or  the first\n                                Nth  characters  of  dataset  names\n                                which you are  interested in (where\n                                N is a number from 1-44)\n\n\n\n\n1                                                        DSN.2\n                                                         03/16/83\n\n\n  Example\n  _______\n\n  You enter:\n\n            DSN 'AGY999'\n\n  the CLIST might display:\n\n       JOB/USER            MODE           MINOR NAME\n       ---------------------------------------------\n       JT44999             -SHR           AGY999.MASTER.PAYROLL\n       BP44999             -SHR           AGY999.NOV.DATA\n       DS144999            -EXCL\n       TM44999             -SHR           AGY999.SEPT.DATA\n\n\n\n\n./ ADD NAME=EXPANDIR 0100-83364-83364-1404-00096-00096-00000-TMCR150\n1                                                        EXPANDIR.1\n                                                         xyz123\n\n\n  CLIST:         EXPANDIR\n  AUTHOR:        Jeff Sprehn and SHARE\n  AGENCY:        WDPSC\n  FUNCTION:      Dynamically  add  specified  number  of  directory\n                 blocks to PDS directory.\n\n  TERMINAL TYPE: 3270 type or dialup\n\n  The purpose of this  CLIST is to make it very  easy to expand the\n  directory  of  a  PDS.   Without the  ability  to  do  a  dynamic\n  expansion of  the directory,  it is  a time  consuming four  step\n  process.  The  four step process which  can now be  replaced with\n  this one step process was:\n\n       Step 1:   Allocate a new PDS with  a different name and with\n                 an increased number of directory blocks (SPF 3.2)\n\n       Step 2:   Copy all members  of original PDS to  this new PDS\n                 (SPF 3.3)\n\n       Step 3:   Delete the original PDS (SPF 3.2)\n\n       Step 4:   Rename the new PDS back  to the original name (SPF\n                 3.2)\n\n\n\n\n1                                                        EXPANDIR.2\n                                                         xyz123\n\n\n  Syntax -\n\n  _________________________________________________________________\n  Command      Operands\n  -----------------------------------------------------------------\n  EXPANDIR     None\n  -----------------------------------------------------------------\n\n\n  This CLIST  examines the terminal  type to determine  whether the\n  terminal being used to invoke this  CLIST is a 3270 type terminal\n  (supporting  Full Screen  services)  or is  a  dialup (TTY)  type\n  terminal.\n\n  If the  terminal type is  a 3270  type terminal, then  this CLIST\n  invokes  the  Dialog  of  the same  name  (EXPANDIR)  to  do  the\n  expansion of the directory.  Therefore,  if your terminal type is\n  3270, then  reference the  documentation in  this manual  for the\n  Dialog EXPANDIR.\n\n  Therefore,  the  following  documentation   is  for  Dialup  type\n  terminals.\n\n\n\n\n1                                                        EXPANDIR.3\n                                                         xyz123\n\n\n  To use this CLIST, do the following:\n\n       1.   After a \"READY\", enter EXPANDIR and press enter.\n\n       2.   The CLIST will then respond with:\n\n                 ENTER DATASET NAME==>\n\n       3.   After  the ==>,  enter the  DSNAME  of the  partitioned\n            dataset whose  directory is  to be  expanded.  If  this\n            DSNAME is  not enclosed  in quotes,  then your  PROFILE\n            PREFIX will  be appended  to the  front of  the dataset\n            name.\n\n       4.   The CLIST will then respond with:\n\n                      ENTER THE NUMBER OF DIRECTORY\n                      BLOCKS TO ADD TO THE DIRECTORY===>\n\n       5.   After the ==>, enter the numeric value representing the\n            number of directory blocks to be added.\n\n       6.   The CLIST will then respond with:\n\n                 SSP95DIR EXECUTING\n                 SUCCESSFUL COMPLETION\n\n\n\n\n./ ADD NAME=FUTADDS  0101-84024-84046-1105-00027-00020-00000-JS02150\n1\n\n\n\n         Possible future additions to the WDPSC Documentation System\n         ___________________________________________________________\n\n\n              .   Page Printer Manual\n\n              .   Teleprocessing Services Manual\n\n              .   Technical Support Manual\n\n              .   Software Listing\n\n              .   Technical Hints\n\n              .   Application Support Center Services\n\n              .   Listing of documentation that is available:\n                      .  Some of it is in DOCSYS\n                      .  IBM  (order direct)\n                      .  Other Edna\n\n\n\n./ ADD NAME=GDDM     0106-81084-84009-1755-00028-00023-00000-KK00150\n1\n-         TO:       GDDM Application Developers\n0         FROM:     The Information Center Support Group\n                    WASHINGTON DATA PROCESSING SERVICE CENTER\n0         SUBJECT:  GDDM Libraries\n0         DATE:     April 1, 1981\n\n\n\n\n               If you are developing application programs which use PGF and/or\n          GDDM, you will need the following dataset names.\n\n               WDPSC.GDDM.GDDMLOAD is the link library containing the entry\n          names described in the GDDM and PGF manuals. You will need to specify\n          this library in your SYSLIB DD card when linking your program.\n\n               WDPSC.GDDM.GDDMSYM  is the library containing the symbol sets\n          provided with GDDM and PGF. These symbol sets are listed in the\n          attachment provided with the documentation for the ISSE and VSSE\n          clists.  These symbol sets are copied for you by the ISSE and VSSE\n          clists and may be used as a basis for developing new symbol sets.\n\n               WDPSC.GDDM.GDDMSAM is the library containing the sample programs\n          described in the GDDM and PGF manuals. You may copy these programs\n          into your own library as a basis for developing your application.\n\n          IF YOU HAVE ANY QUESTIONS, PLEASE CALL US AT 4-1470.\n./ ADD NAME=INTRDR   0100-83362-83362-1510-00058-00058-00000-TMCR150\n1                                                        INTRDR.1\n                                                         06/25/82\n\n\n  PROGRAM:       INTRDR\n  AUTHOR:        Jeff Sprehn\n  AGENCY:        WDPSC\n  LANGUAGE:      Assembler\n  LOCATION:      WDPSC.SHARED.LOAD\n  FUNCTION:      Accept a DDNAME and  then dynamically allocate the\n                 internal reader.\n\n  RUN MODE:      N/A...this is a subroutine.\n\n  This program is a subroutine which will accept a DDNAME passed to\n  it  in  the parameter  list  and  then dynamically  allocate  the\n  internal reader to that DDNAME.  This could allow, for example, a\n  COBOL program  to submit  a job from  within the  executing COBOL\n  program  (by  outputting JCL  to  the  file associated  with  the\n  DDNAME).  This could also allow a  CLIST to allocate the internal\n  reader.  The TSO  ALLOCATE command currently has  no provision to\n  do this.\n\n  To call this program from a CLIST, do the following:\n\n       CALL 'WDPSC.SHARED.LOAD(INTRDR)' '&DDNAME'\n            where &DDNAME contains the DDNAME\n\n\n\n\n1                                                        INTRDR.2\n                                                         06/25/82\n\n\n  To call this subroutine from a program, do the following:\n\n       MOVE the length of your ddname\n            TO DDNAME-LENGTH OF INTRDR-I-O-AREA.\n       MOVE your ddname\n            TO DDNAME OF INTRDR-I-O-AREA.\n       CALL 'INTRDR' USING INTRDR-I-O-AREA.\n            where:\n                 01  INTRDR-I-O-AREA.\n                     05  DDNAME-LENGTH    PIC S9(4) COMP.\n                     05  DDNAME           PIC X(8).\n\n  POSSIBLE RETURN CODES:\n\n       Return Code                       Meaning\n       -----------         -------------------------------------\n            0              Allocation was successful\n            4              Allocation error\n            8              Invalid DDNAME passed to this program\n\n\n\n\n./ ADD NAME=ISSE     0102-81065-84009-1756-00030-00029-00000-KK00150\n1\n-                                                                ISSE Clist\n0         Function -\n          The ISSE Clist is used to enter the Interactive Symbol Set Editor of\n          IBM's Graphical Data Display Manager(GDDM).  It allocates the symbol\n          set library, creating it if it doesn't exist, then calls the Editor\n          Utility.  You must be on a 3279 or 3278 graphics terminal to use this\n          clist. If you create a new symbol set library, you are given the\n          option of copying the sample symbol sets (see attached list) into the\n          library.  The symbol sets created by this editor are for use by GDDM\n          applications as characters, marker symbols, or shading patterns.\n\n          Syntax -\n0         ______________________________________________________________________\n0              Command     Operands\n          ______________________________________________________________________\n0              ISSE        SS(dsname) SSN(setname)\n          ______________________________________________________________________\n0          Required operands - none.\n0          Defaults  - SS(SYMBOL.SETS) SSN(ADMCOLSD)\n-         Operands -\n0           SS(dsname)-dsname is the name of a library for saving symbol sets.\n                       If it does not exist, you are prompted for a volume on\n                       which to place the dataset and it is created by the\n                       clist.  It must have LRECL and BLKSIZE equal to 400.\n\n            SSN(setname)-setname is the name of a symbol set you wish the\n                       Editor to load initially. This defaults to ADMCOLSD\n                       which is a sample symbol set containing different\n                       colored shading patterns.\n./ ADD NAME=JCLXREF  0104-84153-84188-1628-00172-00172-00000-JS02150\n1\n\n                                                         JCLXREF.1\n                                                         08/01/84\n\n\n\n\n  PROC NAME:     JCLXREF\n  AUTHOR:        Mike Phillips/Howard Glastetter\n  AGENCY:        Liquor Control Board\n  FUNCTION:      Cross reference  programs and  dataset names  with\n                 PROCEDURE names and their step names.\n\n\n  This PROCEDURE  inputs a procedure library and/or job streams and\n  outputs up to six reports.  They are:\n\n\n       RPT1\n       NON-CATALOGED PROCEDURES           List   in    alphabetical\n                                          order  of the  names  and\n                                          contents   of   the   job\n                                          streams (run streams  not\n                                          invoking procedures).\n\n\n       RPT2\n       SUMMARY OF CATALOGED PROCEDURES    List   in    alphabetical\n                                          order of  NAMES of  PROCS\n                                          that   belong   to   your\n                                          agency   in   the   given\n                                          procedure library.\n\n\n       RPT3\n       CATALOGED PROCEDURES               List   in    alphabetical\n                                          order    of   name    and\n                                          contents  of  PROCS  that\n                                          belong to your  agency in\n                                          the    given    procedure\n                                          library.\n\n\n\n1\n\n                                                         JCLXREF.2\n                                                         08/01/84\n\n\n\n       RPT4\n       SYSTEM REPORT                      Shows  the steps  in  the\n                                          PROCS      with       the\n                                          significant  ddnames  and\n                                          dataset names.\n\n\n       RPT5\n       PROGRAM CROSS REFERENCE            Cross  reference  program\n                                          names      with       the\n                                          corresponding  PROC  name\n                                          and step name.\n\n\n       RPT6\n       DATASET CROSS REFERENCE            Cross  reference  dataset\n                                          names      with       the\n                                          corresponding PROC  name,\n                                          step name,  program name,\n                                          and DDNAME.\n\n\n\n1\n\n                                                         JCLXREF.3\n                                                         08/01/84\n\n\n\n\n  Symbolic variables used in PROC JCLXREF\n  _______________________________________\n\n\n       SYMBOLIC       DEFAULT        USE\n       ________       _______        ___\n\n\n       PROCLIB        USER.PROCLIB   Dataset name of procedure library.\n\n       AGENCY         NONE           If    you     are    inputting\n                                     USER.PROCLIB      to      this\n                                     procedure,      then      code\n                                     AGENCY=your agency number.  If\n                                     you  are  inputting  your  own\n                                     private   procedure   library,\n                                     then  you   will  want   to  c\n                                     AGENCY='ALL'.\n\n       RPT1            0             0 = yes, you want Report RPT1.\n                                     1 = No, you do NOT want Report RPT1.\n\n\n       RPT2            0             0 = Yes, you want Report RPT2.\n                                     1 = No, you do NOT want Report RPT2.\n\n       RPT3            0             0 = Yes, you want Report RPT3.\n                                     1 = No, you do NOT want Report RPT3.\n\n       RPT4            0             0 = Yes, you want Report RPT4.\n                                     1 = No, you do NOT want Report RPT4.\n\n       RPT5            0             0 = Yes, you want Report RPT5.\n                                     1 = No, you do NOT want Report RPT5.\n\n       RPT6            0             0 = Yes, you want Report RPT6\n                                     1 = No, you do NOT want Report RPT6.\n\n\n1\n\n                                                         JCLXREF.4\n                                                         08/01/84\n\n\n\n\n\n  If you have  some job streams that do not  invoke procedures that\n  you wish to input to this procedure, override DDNAME IN01 of step\n  STEP0A to tell this procedure where they are.\n\n\n  Examples\n  ________\n\n\n       1.   Produce all six reports from  PROCS in USER.PROCLIB (no\n            job decks).\n\n\n                 //   EXEC  JCLXREF,AGENCY='999'\n\n\n       2.   Produce  all  six  reports  from  PROCS  in  a  private\n            procedure   library  (possibly   EASY  READER)   called\n            AGY999.PROCLIB.\n\n\n                 //   EXEC  JCLXREF,AGENCY='999',\n                 //     PROCLIB='AGY999.PROCLIB'\n\n\n       3.   Produce only the program  cross reference report (RPT5)\n            and  the dataset  cross  reference  report (RPT6)  from\n            USER.PROCLIB.\n\n\n                 //   EXEC  JCLXREF,AGENCY='999',\n                 //     RPTl='l',RPT2='l',RPT3='l',RPT4='l'\n\n\n       4.   Produce all six reports using both USER.PROCLIB and job\n            decks found in dataset AGY999.PROD.JOBS(ALL).\n\n\n                 //   EXEC  JCLXREF,AGENCY='999'\n                 //STEP0A.IN0l  DD  DISP=SHR,DSN=AGY999.PROD.JOBS(ALL)\n\n./ ADD NAME=LASTOPEN 0100-83364-83364-1414-00056-00056-00000-TMCR150\n1                                                        LASTOPEN.1\n                                                         06/25/82\n\n\n  CLIST:              LASTOPEN\n  AUTHOR:             Jeff Sprehn\n  AGENCY:             WDPSC\n  FUNCTION:           Display date  and job  name (userid)  of last\n                      job to access a dataset.\n\n  TERMINAL TYPE:      3270-type or dialup\n\n  The LASTOPEN CLIST accepts a dataset  name of a file and displays\n  the following information on your terminal about that file:\n\n       a.   The date that the dataset was last accessed\n\n       b.   The jobname  of the  job that  last accessed  the file.\n            (NOTE:  if  it was  last accessed by  a TSO  user, then\n            that jobname will  be the USERID with a  dollar sign in\n            the third position.)\n\n  Syntax -\n  _________________________________________________________________\n       Command        Operands\n  -----------------------------------------------------------------\n         LASTOPEN     None\n  -----------------------------------------------------------------\n\n  This CLIST will  prompt you for the dataset name  (the CLIST will\n  append  your PROFILE  PREFIX if  you  do not  quote this  dataset\n  name).\n\n\n\n\n1                                                        LASTOPEN.2\n                                                         06/25/82\n\n\n  Sample output -\n\n    *******************************************************************\n    *\n    *\n    *      THE     DATE    OF     LAST    ACCESS     IS    ll-24-80\n    *\n    *   THE JOBNAME  OF  THE JOB  THAT LAST  ACCESSED  THE FILE  IS\n    *   JS$02150 *\n    *\n    *\n    *******************************************************************\n\n\n\n\n./ ADD NAME=LIBRARYS 0102-84285-84286-1258-00034-00031-00000-KK00150\n1\n\n  Tech Services Documentation System libraries\n  ____________________________________________\n\n    Library Name                Contents\n    ____________________        _____________________________________________\n\n\n    SOFTD150.DOCSYS.INDEXES     Index library\n\n    SOFTD150.DOCSYS.MEMO        Tech Services Internal Memos\n\n    SOFTD150.DOCSYS.MISC        Miscellaneous Tech Documents\n\n    SOFTD150.DOCSYS.TECHMAN     Technical Services Internal Manual\n\n\n  TECHINFO System libraries     (These libraries are for the INFOSYS\n  _________________________      format of the local documentation.)\n\n    Library Name                Contents\n    ____________________        _____________________________________________\n\n\n    SOFTD150.TECHINFO.CNTL      Jobs relating to Document Systems\n\n    SOFTD150.TECHINFO.CLIST     Clists used to convert DOCSYS data\n                                into INFO loadable format\n\n    SOFTD150.TECHINFO.MAINPDS   Documents in format for OZB loading\n\n    SYSVS.SOFTD150.TECHINFO     Local INFOSYS database for K.I.T\n\n./ ADD NAME=LOADXREF 0100-83364-83364-1426-00080-00080-00000-TMCR150\n1                                                        LOADXREF.1\n                                                         06/25/82\n\n\n  PROC NAME:          LOADXREF\n  AUTHOR:             Jeff Sprehn\n  AGENCY:             WDPSC\n  FUNCTION:           Cross  reference calling  programs to  called\n                      program and vice versa.\n\n  This PROCEDURE by simply providing it the DSNAME of a load module\n  library(ies) will produce the following:\n\n       1.   CALLING PROGRAM CROSS REFERENCE:\n\n            This report shows the calling programs (in alphabetical\n            order)  in the  left  column  and the  called  programs\n            (subroutines) in the right column.\n\n       2.   CALLED PROGRAM CROSS REFERENCE\n\n            This report shows the called programs, subroutines, (in\n            alphabetical order) in the left  column and the calling\n            programs in the right column.\n\n\n\n\n1                                                        LOADXREF.2\n                                                         06/25/82\n\n\n  HOW TO INVOKE THE PROCEDURE:\n\n  1.   Insert the JOBPARM statement with LINECT=90 (The reports are\n       produced by the 3800 page printer and are shifted 90 degrees\n       to read like a book).\n\n  2.   EXEC  the PROC LOADXREF.\n\n  3.   Supply all of  the load module libraries  required using the\n       symbolic variables LIB1,LIB2,LIB3,LIB4,..........LIB15.\n\n  4.   Indicate the  number of copies of  the two reports  that you\n       desire.  The symbolic variable COPIES allows you to indicate\n       the  number  of  desired  copies.   The  procedure  defaults\n       COPIES=1.\n\n  NOTES:\n\n  1.   This procedure will allow up to  15 load module libraries as\n       input.  Hence, the intention is  to feed this procedure with\n       all of the load module libraries  in your shop.  However, if\n       your  shop  has  9  load module  libraries,  then  only  the\n       symbolic variables  LIB1 through  LIB9 need  to be  provided\n       (the  procedure  defaults  LIB2 through  LIB15  to  a  dummy\n       library that will not affect your reports).\n\n\n\n\n1                                                        LOADXREF.3\n                                                         06/25/82\n\n\n  SAMPLE JCL\n  __________\n\n       //xxxxxxxx JOB ......................................\n       //  CLASS=E,\n       //  MSGLEVEL=1,REGION=500K,TIME=6\n       /*JOBPARM LINECT=90\n       //*\n       //DOIT EXEC  LOADXREF,LIB1='DSN OF LIBRARY #1',\n       //    LIB2='DSN OF LIBRARY #2',\n       //    LIB3='DSN OF LIBRARY #3'\n\n\n\n\n./ ADD NAME=NEXTGEN  0100-83363-83363-0849-00081-00081-00000-TMCR150\n1                                                        NEXTGEN.1\n                                                         06/25/82\n\n\n  COMMAND NAME:       NEXTGEN\n  AUTHOR:             Jeff Sprehn\n  AGENCY:             WDPSC\n  FUNCTION:           Return  two   CLIST  variables   &CURGEN  and\n                      &NXTGEN where  &CURGEN contains  the absolute\n                      generation number  of the  +0 generation  and\n                      &NXTGEN  contains  the   absolute  generation\n                      number of the +l generation.\n\n  Syntax -\n\n  ___________________________________________________________________\n       Command        Operands\n  -------------------------------------------------------------------\n       NEXTGEN        DSN('dsname')\n  -------------------------------------------------------------------\n\n  Operands -\n\n       Required -\n\n            DSN('dsname')       'dsname'  is  the   DSNAME  of  the\n                                generation  data group  (base  name\n                                only).\n\n\n\n\n1                                                        NEXTGEN.2\n                                                         06/25/82\n\n\n  EXAMPLE -\n\n  Suppose  that  AGNCY999.MY.GDG(+0)  is  AGNCY999.MY.GDG.G0497V00,\n  then if one would enter the following command:\n\n       NEXTGEN DSN('AGNCY999.MY.GDG')\n\n  This  command  would  return  the  following  in  the  two  CLIST\n  variables:\n\n       CURGEN = G0497V00\n       NXTGEN = G0498V00\n\n\n\n\n1                                                        NEXTGEN.3\n                                                         06/25/82\n\n\n  Following is an example of the NEXTGEN command used in a CLIST to\n  allocate the +0 and new +1  generation of a generation data group\n  CTSl50.MY.GDG.\n\n       CONTROL MSG NOFLUSH\n       SET &GDGBASE = &STR(CTSl50.MY.GDG)\n\n       /*************************************************/\n       /*  EXEC NEXTGEN TO GENERATE CURGEN AND NXTGEN   */\n       /*************************************************/\n       NEXTGEN DSN('&GDGBASE')                          */\n       /*************************************************/\n       /*  ALLOCATE THE +0 GENERATION                   */\n       /*************************************************/\n       FREE F(MASTRIN)\n       ALLOC F(MASTRIN) DA('&GDGBASE..&CURGEN') OLD\n       /*************************************************/\n       /*  ALLOCATE THE +1 GENERATION                   */\n       /*************************************************/\n       FREE F(MASTROUT)\n       FREE ATTRLIST(AT1)\n       ATTR AT1 RECFM(F B) LRECL(80) BLKSIZE(800)\n       ALLOC F(MASTROUT) UNIT(SYSDA) NEW DA('&GDGBASE..&NXTGEN') -\n            TRACKS SPACE(1 1) USING(AT1)\n\n./ ADD NAME=OVERVIEW 0102-84286-84286-1644-00047-00026-00000-KK00150\n\n    How the Document System works:\n\n  It is an ISPF dialog, of which the highest level is a CLIST\n named DOCSYS (for SPF D) or DOCTECH (for SPF K.D) etc.\n\n  The DOCSYS clist sets variables to establish the high and middle\n default qualifiers for the Document System and the high level index\n member name.\n\n  It then calls via ISPF SELECT the TBLHNDLR dialog program which reads\n the index member from the document system library with last qualifier\n INDEXES and builds a table from the index which is displayed using\n ISPF table services. It accepts S or P selection codes which are\n translated to SEL or PRT and appended to non-displayed data from the\n index to form a clist command which is then invoked via ISPF\n SELECT service.\n\n  The various clists (DOC01SEL,DOC01PRT,DOC03SEL,etc.) examine the data\n passed from the index to locate the document or sub-index requested\n and browse it or recursively invoke TBLHNDLR to display a new index.\n They may print the document or do anything neccessary to search it.\n\n  TBLHNDLR is documented under CTS DOC System as a CTS utility pgm.\n\n    The TECHINFO system works as follows:\n\n  Job SOFTD150.TECHINFO.CNTL(DOCBGET) is submitted every Friday in\n class S. It is a batch TSO job which executes Clist DOCBGET in\n SOFTD150.MISC.CLIST. The DOCBGET Clist allocates the Clist library\n SOFTD150.TECHINFO.CLIST. It then processes a DOCSYS index member\n requested by the job and transforms all selected documents into\n a format loadable by the INFOSYS OZB program and stores them into\n a dataset called SOFTD150.TECHINFO.MAINPDS . If running in the first\n 7 days of the month, the job submits job DOCBGETM, otherwise RBLDINFO.\n\n  Job DOCBGETM (same cntl lib) processes a different index member and\n submits job RBLDINFO.\n\n  Job RBLDINFO rebuilds the local INFOSYS database from the updated\n MAINPDS members. The database is SYSVS.SOFTD150.TECHINFO .\n\n  There is also a clist called DOCSTEAL invoked as an ISPF dialog by\n SPF option K.K.D which operates the same as DOCTECH except that\n documents selected with the P option are converted to INFOSYS load\n format and saved.\n\n./ ADD NAME=RECLAYOT 0100-84024-84024-0953-00052-00052-00000-JS02150\n1\n\n\n      Decription of index file record layout\n      ______________________________________\n\n\n        The members of &DOCSLVL1..&DOCSLVL2..INDEXES must have the format as\n        shown below.  It must have ONE \"T1\" record, followed by ONE \"T2\"\n        record, followed by ONE \"T3\" record, followed by the \"D1\", \"D2\", and\n        \"D3\" records.\n\n        The LRECL of the Index Library (and thus each member) is 200\n\n\n              ....... record layout of T1, T2, T3 record ......\n\n\n               Columns       Contents\n               -------       --------------------------------\n\n               001-002       'T1'  for the PANEL title\n                             'T2'  for PANEL column heading #1\n                             'T3'  for PANEL column heading #2\n               003-003       FILLER\n               004-082       title or column heading\n               083-200       FILLER\n\n\n\n              ....... record layout of D1, D2, D3 recordS .....\n\n\n              Columns      Contents\n              ---------    ------------------------------------\n\n              001 - 002    'D1' for first description line\n                           'D2' for 2nd description line if any\n                           'D3' for 3rd description line if any\n              003 - 003    FILLER\n              004 - 073    Description of entry (could be 1 - n\n                             columns of data represented here)\n                             This field is protected OUTPUT.\n              074 - 074    FILLER\n              075 - 079    First 5 bytes of Command Name to be\n                             invoked if this entry is selected\n                             (SPACES if this is NOT a 'D1' rec)\n              080 - 080    FILLER\n              081 - 200    Parameters to pass to Command if this\n                             field is selected.  Three parameters\n                             MUST be supplied.\n                             (SPACES if this is NOT a 'D1' rec)\n./ ADD NAME=RJETRANS 0101-83357-83362-1549-00113-00113-00000-TMCR150\n1                                                        RJETRANS.1\n                                                         06/25/82\n\n\n  PROGRAM:       RJETRANS\n  AUTHOR:        Gary Duffield\n  AGENCY:        WDPSC\n  LANGUAGE:      DYL280\n  LOCATION:      N/A\n  FUNCTION:      Reassemble records  that have been  transmitted in\n                 80 byte segments via RJE to their original logical\n                 record length.\n\n  RUN MODE:      BATCH\n\n  This program can be used to input  from one to seven 'user tapes'\n  via a Remote Job Entry station.\n\n  Before using  this program,  it must be  'compiled' to  meet your\n  input tape  specifications.  Once 'compiled',  it may be  used in\n  any  job that  requires  transmission of  'user  tapes' with  the\n  specified logical record length and block size.\n\n  For any jobs  using 'user tapes' with a  different logical record\n  length  or block  size,  another copy  of  this  program must  be\n  compiled to meet its specifications.\n\n  Before compilation, this program is identified as RJETRANS.  When\n  you compile it, you may name it whatever you desire.\n\n\n\n\n1                                                        RJETRANS.2\n                                                         06/25/82\n\n\n  To 'compile' RJETRANS, submit the following JCL:\n\n  //    JOBCARD\n  //STEP1   EXEC DYL280,COPYLIB='WDPSC.CARD'\n  //SYS280FZ  DD DSN=&&OBJECT,DISP=(,PASS),UNIT=SYSDA,\n  //             SPACE=(TRK,(5,5))\n  //SYSIN     DD *\n  OPTION FREEZE XXXXXXXX\n  COPY RJETRANS #1=888 #2=9999\n  //STEP2   EXEC PGM=IEWL,PARM='LIST,LET'\n  //SYSLIN    DD DSN=&&OBJECT,DISP=(OLD,DELETE)\n  //SYSLMOD   DD DSN=AAAAAAAA,DISP=SHR\n  //SYSUT1    DD UNIT=SYSDA,SPACE=(TRK,(3,1))\n  //SYSPRINT  DD SYSOUT=A\n  //\n\n  Where:\n\n       888       =    Actual input logical record length.\n\n       9999      =    Smallest multiple of 80  that will fully\n                      contain the input blocksize.\n\n       XXXXXXXX  =    Name you  want assigned to  the compiled\n                      module.\n\n       AAAAAAAA  =    Load  library you  want  the compiled  module\n                      placed in.\n\n\n\n\n1                                                        RJETRANS.3\n                                                         06/25/82\n\n\n  Once you have  completed this compile, you may  use the resulting\n  module in your  production job stream by  including the following\n  JCL:\n  //STEPX  EXEC DYL280,PARM='UA=Z'\n  //STEPLIB  DD DSN=AAAAAAAA,DISP=SHR\n  //IN01     DD *\n     YOUR RJE TAPE ASSIGNMENT CONTROL CARDS\n       .\n       .\n       .\n  //IN07     DD *\n     YOUR RJE TAPE ASSIGNMENT CONTROL CARDS\n  //OUTFILE  DD DSN=   (DATASET YOUR WANT OUTPUT PLACED INTO)\n  //SYSIN    DD *\n  OPTION RESTORE XXXXXXXX\n\n  Where:\n       Z         =    Number of input tapes being processed.\n\n       AAAAAAAA  =    Load library  you compiled  your module  into\n                      (see previous page of documentation).\n\n       XXXXXXXX  =    Name  of module  you  compiled (see  previous\n                      page).\n\n  IMPORTANT:\n  _________\n\n  In the case of  multiple input tapes; each tape must  go in under\n  its own  separate 'INO_'  DD statement.   You need  only code  an\n  'INO_' DD  statement when there is  a tape to be  input following\n  it.  All  input tapes to  the step must  have the same  LRECL and\n  BLKSIZE.  The  parameter 'Z'  must be  changed to  tell how  many\n  tapes  are being  input.  If  this parameter  specifies a  number\n  greater than  the number  of 'INO_' DD  statements, a  user abend\n  '300' will result.\n\n\n\n\n./ ADD NAME=SAMPSYMS 0104-81086-84009-1757-00041-00036-00000-KK00150\n1\n-                                   SAMPLE SYMBOL SETS\n0\n          Several sample symbol sets are provided with PGF and GDDM.  These may\n          be used by application programs instead of the built-in defaults.\n          They are listed below, with short descriptions.  Except for ADMCOLSD,\n          the final character of the name of the symbol set conforms to the\n          convention for generic retrieval by GDDM:\n\n0         ______________________________________________________________________\n0              A ====>  9 x 16\n               C ====>  9 x 12\n               G ====> 10 x  8\n          ______________________________________________________________________\n-         ADMCOLSD      contains sample shading patterns, which create the\n                        appearance of 64 color shades.\n0         ADMDHIIA      contain standard characters, which correspond to the\n          ADMDHIIC      defaults built into GDDM.\n          ADMDHIIG\n\n0         ADMDHIMA      contain 8 standard markers, which correspond to the\n          ADMDHIMC      defaults built into GDDM.\n          ADMDHIMG\n\n0         ADMDHIPA      contain 17 standard patterns, which correspond to the\n          ADMDHIPC      defaults built into GDDM.\n          ADMDHIPG\n\n0         ADMDVSS       vector symbol set, which corresponds to the default\n                        built into GDDM.\n0                       NOTE:  It is not possible to use the Image Symbol Set\n                               Editor on this symbol set.  The Vector Symbol\n                               Set Editor which is a component of the\n                               Presentation Graphics Feature must be used.\n0         ADMITALA      contain sample italic characters.\n          ADMITALC\n          ADMITALG\n\n0         ADMPATTA      contain 64 sample geometric shading patterns.\n          ADMPATTC\n          ADMPATTG\n./ ADD NAME=TRANSFER 0100-84024-84024-0955-00025-00025-00000-JS02150\n1\n\n\n\n      How to transfer Training bulletins, Technical bulletins,\n      Shared Utilities, etc. from DLF to the documentation\n      system\n      ________________________________________________________\n\n\n          1.  First; the document must be in DLF.  Therefore; ask\n              Barb, Kari, Sandy, or Lee (whoever keyed it) to ARC\n              (ARCHIVE) it out from ATMS into DLF\n\n          2.  Go to Option '6' of SPF and invoke the CLIST:  DLFTODOC\n\n                 This CLIST will prompt you for:\n                      .  Documentation System Library (eg WDPSC.DOCSYS.TECHBULL)\n                      .  Member name of the Documentation System Library\n                      .  Document name in DLF\n                      .  Class of job\n\n          3.  After the job has run, you may need to edit it if it is more than\n              55 records in length.  Put a '1' in column 1 wherever a page break\n              is desired.\n./ ADD NAME=UNNUM                                  17OCT89 12.48.12\n1                                                        UNNUM.1\n                                                         06/25/82\n\n\n  CLIST:              UNNUM\n  AUTHOR:             Kermit Kiser\n  AGENCY:             WDPSC\n  FUNCTION:           Remove  line  numbers   from  small  variable\n                      length record files such as CLISTS.\n\n  TERMINAL TYPE: 3270 type or dialup.\n\n  The  UNNUM  CLIST is  used  to  remove  line numbers  from  small\n  variable length  record files  such as  CLISTs.  The  first eight\n  positions are deleted from each record.\n\n  Syntax -\n  _________________________________________________________________\n       Command             Operands\n  _________________________________________________________________\n         UNNUM             dsname\n  _________________________________________________________________\n\n  Operands -\n    Required - dsname\n      dsname - the full name of the dataset to be unnumbered,\n      including member-name if a PDS member.\n\n  Example -\n    UNNUM  ANY.CLIST(TESTMEM)\n\n            Note:     This command is useful if you wish to print a\n            CLIST without the line numbers or if you want to copy a\n            variable-length file to a fixed-length one.\n\n\n\n\n./ ADD NAME=VSSE     0104-81065-84009-1757-00029-00030-00000-KK00150\n1\n-                                                                VSSE Clist\n0         Function -\n          The VSSE Clist is used to enter the Vector Symbol Set Editor of IBM's\n          Presentation Graphics Feature (PGF).  It allocates the symbol set\n          library, creating it if it doesn't exist, then calls the Editor\n          Utility.  You must be on a 3279 or 3278 graphics terminal to use this\n          clist. If you create a new symbol set library, you are given the\n          option of copying the sample symbol sets (see attached list) into the\n          library.  The symbol sets created by this editor are for use by GDDM\n          applications as variable size and orientation characters.\n\n          Syntax -\n0         ______________________________________________________________________\n0              Command     Operands\n          ______________________________________________________________________\n0              VSSE        SS(dsname) SSN(setname)\n          ______________________________________________________________________\n0          Required operands - none.\n0          Defaults  - SS(SYMBOL.SETS) SSN(ADMDVSS)\n-         Operands -\n0           SS(dsname)-dsname is the name of a library for saving symbol sets.\n                       If it does not exist, you are prompted for a volume on\n                       which to place the dataset and it is created by the\n                       clist.  It must have LRECL and BLKSIZE equal to 400.\n\n            SSN(setname)-setname is the name of a symbol set you wish the\n                       Editor to load initially. This defaults to ADMDVSS which\n                       is a sample symbol set in vector symbol format.\n./ ADD NAME=WHOISI   0100-83364-83364-1508-00061-00061-00000-TMCR150\n1                                                        WHOISI.1\n                                                         01/09/84\n\n  DIALOG:             WHOISI\n  AUTHOR:             Jeff Sprehn\n  AGENCY:             WDPSC\n  FUNCTION:           List attributes  about your  LOGONID such  as\n                      account number, system  number, user catalog,\n                      logon procedure, profile prefix, etc.\n\n  SPF OPTION NUMBER:  W.1.3\n\n  This Dialog,  after entering  W.1.3 at  the primary  option menu,\n  will display the following information about your logonid:\n\n       o    Accounting information  (which includes bin  number and\n            sub agency)\n       o    System Number\n       o    Programmer Name Field\n       o    Terminal id\n       o    Default Print Destination\n       o    Primary User Catalog\n       o    STEPLIB datasets (If any)\n       o    Logonid\n       o    Profile Prefix\n       o    Logon Procedure\n       o    Terminal Type\n       o    Number of PF Keys\n\n\n\n1                                                        WHOISI.2\n                                                         01/09/84\n\n  EXAMPLE\n\n  Logonid RS14999 enters W.1.3 at the primary option menu.\n\n  -------------------------- WHOISI --------------------------\n\n  MY ACCOUNT IS ==============> 1234,72-0\n  MY SYSTEM NUMBER IS ========> 14\n  MY PROGRAMMER NAME FIELD ===> SMITH 1468 T\n  MY TERMINAL ID IS ==========> S324\n  MY DEFAULT PRINT DESINATION=> RMT33\n\n  MY PRIMARY USER CATALOG IS => SYS1.USERCAT1\n\n  MY STEPLIB DATASETS ARE ====> ********************************\n                          ====> * DDNAME STEPLIB NOT ALLOCATED *\n                          ====> ********************************\n\n  MY USERID IS ===============> RS14999\n  MY PROFILE PREFIX IS =======> AGNCY999\n  NAME OF MY LOGON PROCEDURE => SPF\n\n  MY TERMINAL TYPE IS ========> 3278\n  NUMBER OF PF KEYS IS =======> 24\n\n\n                   THAT'S WHO I AM !!!\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DOCSYS$": {"ttr": 15621, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x00\\x7f\\x00\\x88\\x00\\x7f\\x12\\x00\\x004\\x004\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf2\\xf7\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-01-07T00:00:00", "modifydate": "1988-01-07T12:00:00", "lines": 52, "newlines": 52, "modlines": 0, "user": "FILE270"}, "text": " DOCSYS\n\n  DOCSYS is an ISPF dialog used for maintaining online documentation and\n  retrieving it interactively.  A document system consists of DOCSYS, an\n  index library and one or more document libraries.  Multiple document\n  systems can be established and even linked together if desired.  A\n  document system is started from ISPF by a clist (See DOCSYS, DOCTECH,\n  DOCSAMP, DOCIOCTL for examples.) which defines the primary high and\n  middle dataset qualifiers used for document libraries and also\n  specifies display headings and authorization for updating.\n  Indexes to the documents are used to generate and display an ISPF\n  table from which the user may select documents for display or printing.\n\n  Notes:\n     1) References to CLOG may be removed. CLOG is a copy of the IBM\n        send command zapped to use an alternate dataset for logging.\n\n     2) The ROTATE90 program is not enclosed. It is an IBM FDP. If not\n        available, substitute another print option on the DOCPM.. panels.\n        There is a public domain 90 degree pgm called ROTATER in file\n        316 of the CBT mods tape.\n\n     3) The LISTPDS program is from file 316 of the CBT mods tape.\n        The PDS command is from file 182 of the CBT mods tape.\n\n     4) The authorization code must be altered to fit each startup\n        clist to the document system.\n\n     5) The INDEXES library must use INDEXES for the final qualifier\n        as coded and it must have an LRECL of 200. Be sure to copy the\n        sample index library to a dataset with that LRECL after loading.\n\n     6) Here are the components as far as I have been able to identify\n        them. Please let me know if you find anything missing. Note that\n        the PARMCNVS program which builds a control card used by ROTATE90\n        has no source but I have enclosed the load module.\n\n    clists    commands/pgms    panels   messages   skels/procs   misc\n\n     DOC...     CLOG=SEND        GPM     GPM00                  INDEXES\n                GETMY                                           DOCLIB\n                PANLEXIT                                        CONTROL\n                TBLHNDLR                                        JAN86\n     CMDOUT     FILEINFO        DOCADD..\n                CONCATEM\n                LISTPDS\n     CHDSCB     WHATDSN                            DOCR90\n                FTL                                DOCPDR90\n                PARMCNVS        DOCPM..            ROTATE90\n                PASSDEST        TBL...\n                STACK           DOCEDIT\n                PDS             DOCS.HLP                        ISPCMDS\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "DPSCEDT6": {"ttr": 15623, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x00\\x7f\\x00\\x88\\x00\\x7f\\x12\\x00\\x05\\t\\x05\\t\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf2\\xf7\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-01-07T00:00:00", "modifydate": "1988-01-07T12:00:00", "lines": 1289, "newlines": 1289, "modlines": 0, "user": "FILE270"}, "text": "       ID DIVISION.\n       PROGRAM-ID.  DPSCEDT6.\n\n      ****************************************************************\n      *                                                              *\n      *     THIS IS THE BETTER/EDIT PROGRAM                          *\n      *                                                              *\n      *     MODIFIED AUGUST 1984 TO INCORPORATE NEW FIND FEATURE     *\n      *                                                              *\n      *     MODIFIED NOVEMBER 1984 SO THAT THE PANEL-NAME COULD BE   *\n      *        SPECIFIED AT EXECUTION TIME RATHER THAN BEING         *\n      *        HARD CODED IN THE PROGRAM                             *\n      *                                                              *\n      *     MODIFIED DECEMBER 1984 TO ALLOW NEW OPTION \"X\" WHICH     *\n      *        IS ANOTHER KIND OF \"FIND\" FUNCTION WHICH SEARCHES     *\n      *        ALL OF THE FIELDS OF THE MEMBER SELECTION LIST        *\n      *        RATHER THAN THE DATA.                                 *\n      *                                                              *\n      *     MODIFIED FEBRUARY 1985 TO VGET THE PREFIX RATHER THAN    *\n      *        OBTAINING IT FROM THE PARM.  THIS WAS DONE SO THAT    *\n      *        THE PROGRAM COULD BE CALLED VIA PANVALET PROGRAM      *\n      *        ISPNRECV.                                             *\n      *           I.E.                                               *\n      *               ISPEXEC SELECT PGM(IPNRECV) PARM(DPSCEDT6)     *\n      *                                                              *\n      *     MODIFIED FEBRUARY 1986 TO FIX THE PROBLEM WITH THE       *\n      *        FIND OPTION ALWAYS REFERENCING THE DATASET BY THE     *\n      *        CATALOG INSTEAD OF TAKING THE VOLUME SERIAL NUMBER    *\n      *        IN CONSIDERATION IF SPECIFIED.                        *\n      *                                                              *\n      ****************************************************************\n           EJECT\n       ENVIRONMENT DIVISION.\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n      *\n      *    I N   A L P H A B E T I C A L   O R D E R\n      *\n       77  DISPLAY-RETURN-CODE                     PIC 9(4).\n       77  FINAL-DSNAME                            PIC X(56).\n       77  GENERIC-LOC-OF-CURSOR                   PIC X(8).\n       77  GOOD-BREAKDOWN                          PIC X(3).\n       77  HOLD-FIRST                              PIC X.\n       77  HOLD-SECOND                             PIC X.\n       77  NEXT-CURSOR-POSITION                    PIC X(8).\n       77  PROFILE-PREFIX-LENGTH                   PIC S9(4) COMP.\n       77  PROCESS-SWITCH                          PIC X(3).\n       77  SPF-EDIT-PGM-LENGTH                     PIC S9(8) COMP.\n       77  SPF-EDIT-SUB                            PIC S9(4) COMP.\n       77  SUB                                     PIC S9(5) COMP.\n       77  SUB2                                    PIC S9(5) COMP.\n       77  SUB3                                    PIC S9(5) COMP.\n       77  THE-DSNAME                              PIC X(44).\n       77  THE-MEMBER                              PIC X(8).\n       77  THE-VOL-SER                             PIC X(6).\n       77  TYPE-OF-SERVICE                         PIC X(6).\n       77  VGET-RETURN-CODE                        PIC 9(4).\n           EJECT\n      *\n      *    I S P L I N K   P A R A M E T E R S\n      *\n       01  SELEKT                VALUE 'SELECT'    PIC X(6).\n       01  SHARED                VALUE 'SHARED'    PIC X(6).\n       01  VGET                  VALUE 'VGET'      PIC X(4).\n       01  VPUT                  VALUE 'VPUT'      PIC X(4).\n       01  PROFILE               VALUE 'PROFILE'   PIC X(7).\n       01  VDEFINE               VALUE 'VDEFINE'   PIC X(7).\n       01  CHAR                  VALUE 'CHAR'      PIC X(4).\n       01  KONTROL               VALUE 'CONTROL'   PIC X(7).\n       01  RFRESH                VALUE 'REFRESH'   PIC X(7).\n       01  ERRORS                VALUE 'ERRORS'    PIC X(6).\n       01  RETERN                VALUE 'RETURN'    PIC X(6).\n       01  EDIT                  VALUE 'EDIT'      PIC X(4).\n       01  BROWSE                VALUE 'BROWSE'    PIC X(6).\n       01  DISPLY                VALUE 'DISPLAY'   PIC X(7).\n       01  PANEL-NAME                              PIC X(8).\n       01  CURSOR-FIELD                            PIC X(8).\n       01  MESSAGE-ID                              PIC X(8).\n       01  LENGTH-FIELD                            PIC S9(8) COMP.\n       01  FNDSMEM-CMD      VALUE 'CMD(%FNDSMEM)'  PIC X(13).\n       01  SPFYFND-CMD      VALUE 'CMD(%SPFYFND)'  PIC X(13).\n\n       01  INITIAL-MSG-ID.\n           05  FILLER            VALUE 'TRIK10'    PIC X(06).\n           05  UNITS-POS                           PIC 9.\n           05  FILLER            VALUE SPACE       PIC X(01).\n           EJECT\n      *\n      *    S P F   S Y M B O L I C   N A M E S\n      *\n       01  SPF-SYMBOLIC-NAMES.\n           05  DYNPNAME VALUE '(DYNPNAME)'         PIC X(10).\n           05  OPTION2  VALUE '(OPTION2)'          PIC X(9).\n           05  A00      VALUE '(A00)'              PIC X(5).\n           05  OTHERDSN VALUE '(OTHERDSN)'         PIC X(10).\n           05  OTHVOL   VALUE '(OTHVOL)'           PIC X(8).\n           05  MEMBER   VALUE '(MEMBER)'           PIC X(8).\n           05  SAVEDMSG VALUE '(SAVEDMSG)'         PIC X(10).\n           05  GENERMSG VALUE '(GENERMSG)'         PIC X(10).\n           05  ZERRMSG  VALUE '(ZERRMSG)'          PIC X(9).\n           05  ZPREFIX  VALUE '(ZPREFIX)'          PIC X(9).\n           05  FNDSERR  VALUE '(FNDSERR)'          PIC X(9).\n           05  FNDSDSN  VALUE '(FNDSDSN)'          PIC X(9).\n           05  FNDSRCH  VALUE '(FNDSRCH)'          PIC X(9).\n           05  FNDSVOL  VALUE '(FNDSVOL)'          PIC X(9).\n           05  A01-A17.\n               10  FILLER                          PIC X(48) VALUE\n             '(A01,A02,A03,A04,A05,A06,A07,A08,A09,A10,A11,A12'.\n               10  FILLER                          PIC X(21) VALUE\n             ',A13,A14,A15,A16,A17)'.\n           05  W88DSN01-W88DSN17.\n               10  FILLER                          PIC X(54) VALUE\n             '(W88DSN01,W88DSN02,W88DSN03,W88DSN04,W88DSN05,W88DSN06'.\n               10  FILLER                          PIC X(54) VALUE\n             ',W88DSN07,W88DSN08,W88DSN09,W88DSN10,W88DSN11,W88DSN12'.\n               10  FILLER                          PIC X(46) VALUE\n             ',W88DSN13,W88DSN14,W88DSN15,W88DSN16,W88DSN17)'.\n           EJECT\n      *\n      *    C O B O L   V A R I A B L E   N A M E S\n      *\n\n       01  COBOL-VARIABLE-NAMES.\n           05  DYNAMIC-PANEL-NAME                  PIC X(8).\n           05  OPTION-2-VALUE                      PIC X(3).\n           05  OTHER-DATASET-SEL-CODE              PIC X(3).\n           05  OTHER-DATASET-DSNAME                PIC X(44).\n           05  SUPPLIED-VOL-SER                    PIC X(6).\n           05  MEMBER-NAME-OR-SEARCH-CRITERIA.\n               10  BYTES-1-8                       PIC X(08).\n               10  FILLER                          PIC X(42).\n           05  DATASET-SAVED-MSG                   PIC X(21).\n           05  GENERIC-ERROR-MSG                   PIC X(30).\n           05  CNTL-ERRS-MSG-ID                    PIC X(8).\n           05  PROFILE-PREFIX-SVP                  PIC X(8).\n           05  FIND-OPTION-ERRMSG                  PIC X(30).\n           05  FIND-OPTION-DSNAME                  PIC X(44).\n           05  FIND-OPTION-SEARCH-ARG              PIC X(50).\n           05  FIND-OPTION-VOLUME                  PIC X(6).\n           05  SELECTION-CODE-ARRAY.\n               10  SEL-CODE-ELEMENT OCCURS 17 TIMES PIC X(03).\n           05  DSNAMES-ARRAY.\n               10  DSNAME-ELEMENT   OCCURS 17 TIMES PIC X(44).\n\n           EJECT\n      *\n      *    O T H E R   W O R K I N G   S T O R A G E   F I E L D S\n      *\n       01  ABOUT-TO-ABORT                          PIC X.\n\n       01  ABORT-NUMBER\n               REDEFINES ABOUT-TO-ABORT            PIC 9.\n\n       01  BREAKDOWN-TIME-OF-DAY.\n           05  THE-HOUR                            PIC 99.\n           05  THE-MINUTES                         PIC 99.\n           05  THE-SECONDS.\n               10  FILLER                          PIC 9.\n               10  UNITS-POS                       PIC 9.\n\n       01  CURSOR-LOC-TABLE.\n           05  FILLER    VALUE '01W88DSN01'        PIC X(10).\n           05  FILLER    VALUE '02W88DSN02'        PIC X(10).\n           05  FILLER    VALUE '03W88DSN03'        PIC X(10).\n           05  FILLER    VALUE '04W88DSN04'        PIC X(10).\n           05  FILLER    VALUE '05W88DSN05'        PIC X(10).\n           05  FILLER    VALUE '06W88DSN06'        PIC X(10).\n           05  FILLER    VALUE '07W88DSN07'        PIC X(10).\n           05  FILLER    VALUE '08W88DSN08'        PIC X(10).\n           05  FILLER    VALUE '09W88DSN09'        PIC X(10).\n           05  FILLER    VALUE '10W88DSN10'        PIC X(10).\n           05  FILLER    VALUE '11W88DSN11'        PIC X(10).\n           05  FILLER    VALUE '12W88DSN12'        PIC X(10).\n           05  FILLER    VALUE '13W88DSN13'        PIC X(10).\n           05  FILLER    VALUE '14W88DSN14'        PIC X(10).\n           05  FILLER    VALUE '15W88DSN15'        PIC X(10).\n           05  FILLER    VALUE '16W88DSN16'        PIC X(10).\n           05  FILLER    VALUE '17W88DSN17'        PIC X(10).\n\n       01  CURSOR-LOC-ARRAY\n              REDEFINES CURSOR-LOC-TABLE.\n           05   CURSOR-SEARCH-TABLE OCCURS 17 TIMES\n                    ASCENDING KEY IS CURSOR-LOC-ARGUMENT\n                       INDEXED BY CURSOR-LOC-INDEX.\n                 10  CURSOR-LOC-ARGUMENT           PIC 99.\n                 10  CURSOR-LOC-RESULT             PIC X(8).\n\n       01  RAW-DSN.\n           05  RAW-DSN-BYTE OCCURS 44 TIMES        PIC X.\n\n       01  TEMP-DSNAME.\n           05  TEMP-DSN-BYTE OCCURS 44 TIMES       PIC X.\n\n       01  INTERMEDIATE-DSNAME.\n           05  INT-DSN-BYTE OCCURS 44 TIMES        PIC X.\n\n       01  FINAL-DSNAME-TABLE.\n           05  FINAL-DSNAME-ELEMENT OCCURS 56 TIMES PIC X.\n\n       01  MEMBER-TABLE.\n           05  MEMBER-ELEMENT       OCCURS 8  TIMES PIC X.\n\n       01  TEMP-MEMBER.\n           05  TEMP-MEMBER-BYTE     OCCURS 8  TIMES PIC X.\n\n       01  PROFILE-PREFIX-TABLE.\n           05  PROFILE-PREFIX-BYTE  OCCURS 8  TIMES PIC X.\n\n       01  SPF-EDIT-PGM.\n           05  SPF-EDIT-PGM-BYTE  OCCURS 100 TIMES PIC X.\n\n       01  BREAKDOWN-FILEATTR-ERR-MSG.\n           05  BYTES-1-13                           PIC X(13).\n           05  FILLER                               PIC X(17).\n\n       01  BREAKDOWN-FIND-OPT-MSG.\n           05  BYTES-1-8                            PIC X(08).\n           05  FILLER                               PIC X(22).\n\n       01  MEMBER-SAVED-MSG.\n           05  FILLER     VALUE 'MEMBER '           PIC X(07).\n           05  MEMBER-BEING-SAVED                   PIC X(08).\n           05  FILLER     VALUE ' SAVED'            PIC X(06).\n\n           EJECT\n      *\n      *    F I L E A T T R   P A R A M E T E R S\n      *\n       01  FILEATTR-IN-DSN                         PIC X(44).\n       01  FILEATTR-OUT-VALID-SWITCH               PIC X(3).\n       01  FILEATTR-OUT-ERROR-MESSAGE              PIC X(30).\n       01  FILEATTR-OUT-VOLSER                     PIC X(6).\n       01  FILEATTR-OUT-LRECL                      PIC 9(5).\n       01  FILEATTR-OUT-BLKSIZE                    PIC 9(5).\n       01  FILEATTR-OUT-DSORG                      PIC X(2).\n       01  FILEATTR-OUT-RECFM                      PIC X(1).\n       01  FILEATTR-OUT-DEVICE                     PIC X(1).\n       01  FILEATTR-IN-VOLSER                      PIC X(6).\n           EJECT\n      *\n      *    B R E A K D S N   P A R A M E T E R S\n      *\n       01  BREAKDSN-IO-AREA.\n           05  INPUT-DSN                       PIC X(44).\n           05  OUTPUT-DSN                      PIC X(44).\n           05  OUTPUT-MEMBER-NAME              PIC X(8).\n           05  MEMBER-NAME-PROVIDED            PIC X(3).\n           05  GDG-TYPE-DATASET                PIC X(3).\n           05  VALID-DSN-PASSED                PIC X(3).\n           05  ERROR-MESSAGE                   PIC X(30).\n           EJECT\n       PROCEDURE DIVISION.\n      *\n      **************************************************************\n      *                                                            *\n      *                    M A I N   L I N E                       *\n      *                                                            *\n      **************************************************************\n      *\n           CALL 'ISPLINK'\n                USING KONTROL ERRORS RETERN.\n\n           PERFORM 1000-INITIALIZATION\n              THRU 1999-EXIT-INITIALIZATION.\n\n           MOVE SPACES TO OTHER-DATASET-DSNAME.\n           MOVE SPACES TO SUPPLIED-VOL-SER.\n           MOVE SPACES TO MEMBER-NAME-OR-SEARCH-CRITERIA.\n           MOVE 'MEMBER  ' TO CURSOR-FIELD.\n           MOVE ALL '-' TO DATASET-SAVED-MSG.\n\n      *\n      *    BEGIN LOADING INITIAL FUNNY MSG\n      *\n\n           MOVE TIME-OF-DAY TO BREAKDOWN-TIME-OF-DAY.\n\n           MOVE UNITS-POS OF BREAKDOWN-TIME-OF-DAY\n             TO UNITS-POS OF INITIAL-MSG-ID.\n\n           MOVE INITIAL-MSG-ID TO MESSAGE-ID.\n\n      *\n      *    END LOADING INITIAL FUNNY MSG\n      *\n\n       0010-DISPLAY-PANEL.\n\n           PERFORM 2000-DISPLAY-PANEL\n              THRU 2999-EXIT-DISPLAY-PANEL.\n\n           IF DISPLAY-RETURN-CODE = 8\n                PERFORM 9000-END-OF-JOB\n                   THRU 9999-EXIT-END-OF-JOB\n                STOP RUN.\n\n           IF  (OTHER-DATASET-SEL-CODE = 'S  '\n                                      OR 'E  '\n                                      OR 'B  '\n                                      OR 'F  '\n                                      OR 'X  ')\n             AND\n               (OTHER-DATASET-DSNAME = SPACES)\n                    MOVE 'WDED105 ' TO MESSAGE-ID\n                    MOVE 'OTHERDSN' TO CURSOR-FIELD\n                    MOVE ALL '-' TO DATASET-SAVED-MSG\n                    GO TO 0010-DISPLAY-PANEL.\n\n           IF OTHER-DATASET-DSNAME = SPACES\n               GO TO 0020-PROCESS-TABLE-OF-DSNS.\n\n           MOVE OTHER-DATASET-DSNAME TO RAW-DSN.\n           PERFORM 3000-BREAKDOWN-RAW-DSN\n              THRU 3999-EXIT-BREAK-RAW-DSN.\n\n           IF GOOD-BREAKDOWN = 'YES'\n               NEXT SENTENCE\n           ELSE\n               MOVE 'OTHERDSN' TO CURSOR-FIELD\n               MOVE ALL '-' TO DATASET-SAVED-MSG\n               GO TO 0010-DISPLAY-PANEL.\n\n           IF SUPPLIED-VOL-SER = SPACES\n               MOVE 'ABSENT' TO THE-VOL-SER\n           ELSE\n               MOVE SUPPLIED-VOL-SER TO THE-VOL-SER.\n\n      *    START CASE STATEMENT\n\n               IF OTHER-DATASET-SEL-CODE\n                    EQUAL '   ' OR '-  ' OR 'S  ' OR 'E  '\n                        MOVE 'EDIT  ' TO TYPE-OF-SERVICE\n           ELSE\n               IF OTHER-DATASET-SEL-CODE = 'B  '\n                        MOVE 'BROWSE' TO TYPE-OF-SERVICE\n           ELSE\n                        MOVE 'FIND  ' TO TYPE-OF-SERVICE.\n\n      *    END CASE STATEMENT\n\n           IF   (TYPE-OF-SERVICE = 'FIND  ')\n              AND\n                (THE-MEMBER NOT EQUAL TO 'ABSENT  ')\n                     MOVE 'WDED109 ' TO MESSAGE-ID\n                     MOVE 'OTHERDSN' TO CURSOR-FIELD\n                     MOVE ALL '-' TO DATASET-SAVED-MSG\n                     GO TO 0010-DISPLAY-PANEL.\n\n           IF   (TYPE-OF-SERVICE = 'FIND  ')\n              AND\n                (MEMBER-NAME-OR-SEARCH-CRITERIA = SPACES)\n                     MOVE 'WDED109A' TO MESSAGE-ID\n                     MOVE 'MEMBER  ' TO CURSOR-FIELD\n                     MOVE ALL '-' TO DATASET-SAVED-MSG\n                     GO TO 0010-DISPLAY-PANEL.\n\n           PERFORM 4000-PROCESS-THE-REQUEST\n              THRU 4999-EXIT-PROCESS-REQ.\n\n           IF GENERIC-LOC-OF-CURSOR = 'DATASET '\n               MOVE 'OTHERDSN' TO CURSOR-FIELD\n           ELSE\n               MOVE 'MEMBER  ' TO CURSOR-FIELD.\n\n           IF PROCESS-SWITCH = 'YES'\n                MOVE SPACES TO MEMBER-NAME-OR-SEARCH-CRITERIA.\n\n           GO TO 0010-DISPLAY-PANEL.\n\n       0020-PROCESS-TABLE-OF-DSNS.\n\n           MOVE ALL '-' TO DATASET-SAVED-MSG.\n           MOVE +1 TO SUB.\n\n       0030.\n\n           IF SUB GREATER THAN +17\n               MOVE 'EDIT  ' TO TYPE-OF-SERVICE\n               MOVE +1 TO SUB\n               MOVE 'S' TO SEL-CODE-ELEMENT (1)\n               GO TO 0040-BREAKDOWN-THE-DSN.\n\n           IF SEL-CODE-ELEMENT (SUB) = 'S  ' OR 'E  '\n               MOVE 'EDIT  ' TO TYPE-OF-SERVICE\n               GO TO 0040-BREAKDOWN-THE-DSN.\n\n           IF SEL-CODE-ELEMENT (SUB) = 'B  '\n               MOVE 'BROWSE' TO TYPE-OF-SERVICE\n               GO TO 0040-BREAKDOWN-THE-DSN.\n\n           IF SEL-CODE-ELEMENT (SUB) = 'F  ' OR 'X  '\n               MOVE 'FIND  ' TO TYPE-OF-SERVICE\n               GO TO 0040-BREAKDOWN-THE-DSN.\n\n           ADD +1 TO SUB.\n           GO TO 0030.\n\n       0040-BREAKDOWN-THE-DSN.\n\n           IF DSNAME-ELEMENT (SUB) = SPACES\n               MOVE 'WDED105 ' TO MESSAGE-ID\n               PERFORM 6000-DETERMINE-CURSOR-POSITION\n                  THRU 6999-EXIT-DET-CUR-POS\n               MOVE NEXT-CURSOR-POSITION TO CURSOR-FIELD\n               MOVE ALL '-' TO DATASET-SAVED-MSG\n               GO TO 0010-DISPLAY-PANEL.\n\n           MOVE DSNAME-ELEMENT (SUB) TO RAW-DSN.\n           PERFORM 3000-BREAKDOWN-RAW-DSN\n              THRU 3999-EXIT-BREAK-RAW-DSN.\n\n           IF GOOD-BREAKDOWN = 'YES'\n               NEXT SENTENCE\n           ELSE\n               PERFORM 6000-DETERMINE-CURSOR-POSITION\n                  THRU 6999-EXIT-DET-CUR-POS\n               MOVE NEXT-CURSOR-POSITION TO CURSOR-FIELD\n               MOVE ALL '-' TO DATASET-SAVED-MSG\n               GO TO 0010-DISPLAY-PANEL.\n\n           IF   (TYPE-OF-SERVICE = 'FIND  ')\n              AND\n                (THE-MEMBER NOT EQUAL TO 'ABSENT  ')\n                     MOVE 'WDED109 ' TO MESSAGE-ID\n                     PERFORM 6000-DETERMINE-CURSOR-POSITION\n                        THRU 6999-EXIT-DET-CUR-POS\n                     MOVE NEXT-CURSOR-POSITION TO CURSOR-FIELD\n                     MOVE ALL '-' TO DATASET-SAVED-MSG\n                     GO TO 0010-DISPLAY-PANEL.\n\n           IF SUPPLIED-VOL-SER = SPACES\n               MOVE 'ABSENT' TO THE-VOL-SER\n           ELSE\n               MOVE SUPPLIED-VOL-SER TO THE-VOL-SER.\n\n           IF   (TYPE-OF-SERVICE = 'FIND  ')\n              AND\n                (MEMBER-NAME-OR-SEARCH-CRITERIA = SPACES)\n                     MOVE 'WDED109A' TO MESSAGE-ID\n                     MOVE 'MEMBER  ' TO CURSOR-FIELD\n                     MOVE ALL '-' TO DATASET-SAVED-MSG\n                     GO TO 0010-DISPLAY-PANEL.\n\n           IF  (MEMBER-NAME-OR-SEARCH-CRITERIA = SPACES)\n             OR\n               (THE-MEMBER = 'ABSENT  ')\n                     GO TO 0060-DO-THE-EDIT-OR-BROWSE.\n\n           MOVE 'WDED108 ' TO MESSAGE-ID.\n           MOVE 'MEMBER  ' TO CURSOR-FIELD.\n           MOVE ALL '-' TO DATASET-SAVED-MSG.\n           GO TO 0010-DISPLAY-PANEL.\n\n       0060-DO-THE-EDIT-OR-BROWSE.\n\n           PERFORM 4000-PROCESS-THE-REQUEST\n              THRU 4999-EXIT-PROCESS-REQ.\n\n           IF PROCESS-SWITCH = 'YES'\n               MOVE 'MEMBER  ' TO CURSOR-FIELD\n               MOVE SPACES TO MEMBER-NAME-OR-SEARCH-CRITERIA\n               GO TO 0010-DISPLAY-PANEL.\n\n           IF GENERIC-LOC-OF-CURSOR = 'DATASET '\n               PERFORM 6000-DETERMINE-CURSOR-POSITION\n                  THRU 6999-EXIT-DET-CUR-POS\n               MOVE NEXT-CURSOR-POSITION TO CURSOR-FIELD\n           ELSE\n               MOVE 'MEMBER  ' TO CURSOR-FIELD.\n\n           GO TO 0010-DISPLAY-PANEL.\n           EJECT\n       1000-INITIALIZATION.\n\n           MOVE +08 TO LENGTH-FIELD.\n           CALL 'ISPLINK'\n             USING\n               VDEFINE\n               ZPREFIX\n               PROFILE-PREFIX-SVP\n               CHAR\n               LENGTH-FIELD.\n\n           CALL 'ISPLINK'\n                USING VGET ZPREFIX SHARED.\n\n           MOVE PROFILE-PREFIX-SVP TO PROFILE-PREFIX-TABLE.\n\n           MOVE +0 TO PROFILE-PREFIX-LENGTH.\n\n       1100-BUMP-THE-SUBSCRIPT.\n\n           ADD +1 TO PROFILE-PREFIX-LENGTH.\n\n           IF (PROFILE-PREFIX-LENGTH GREATER THAN +8)\n             OR\n              (PROFILE-PREFIX-BYTE (PROFILE-PREFIX-LENGTH) = SPACE)\n                  NEXT SENTENCE\n           ELSE\n                  GO TO 1100-BUMP-THE-SUBSCRIPT.\n\n           COMPUTE PROFILE-PREFIX-LENGTH = PROFILE-PREFIX-LENGTH - 1.\n\n           MOVE +08 TO LENGTH-FIELD.\n           CALL 'ISPLINK'\n             USING\n               VDEFINE\n               DYNPNAME\n               DYNAMIC-PANEL-NAME\n               CHAR\n               LENGTH-FIELD.\n\n           MOVE +03 TO LENGTH-FIELD.\n           CALL 'ISPLINK'\n             USING\n               VDEFINE A00 OTHER-DATASET-SEL-CODE CHAR LENGTH-FIELD.\n\n           MOVE +44 TO LENGTH-FIELD.\n           CALL 'ISPLINK'\n             USING\n               VDEFINE OTHERDSN OTHER-DATASET-DSNAME CHAR LENGTH-FIELD.\n\n           MOVE +06 TO LENGTH-FIELD.\n           CALL 'ISPLINK'\n             USING\n               VDEFINE OTHVOL SUPPLIED-VOL-SER CHAR LENGTH-FIELD.\n\n           MOVE +50 TO LENGTH-FIELD.\n           CALL 'ISPLINK'\n             USING\n               VDEFINE MEMBER MEMBER-NAME-OR-SEARCH-CRITERIA\n                   CHAR LENGTH-FIELD.\n\n           MOVE +21 TO LENGTH-FIELD.\n           CALL 'ISPLINK'\n             USING\n               VDEFINE SAVEDMSG DATASET-SAVED-MSG CHAR LENGTH-FIELD.\n\n           MOVE +30 TO LENGTH-FIELD.\n           CALL 'ISPLINK'\n             USING\n               VDEFINE GENERMSG GENERIC-ERROR-MSG CHAR LENGTH-FIELD.\n\n           MOVE +8 TO LENGTH-FIELD.\n           CALL 'ISPLINK'\n            USING\n             VDEFINE ZERRMSG CNTL-ERRS-MSG-ID CHAR LENGTH-FIELD.\n\n           MOVE +30 TO LENGTH-FIELD.\n           CALL 'ISPLINK'\n            USING\n             VDEFINE FNDSERR FIND-OPTION-ERRMSG CHAR LENGTH-FIELD.\n\n           MOVE +44 TO LENGTH-FIELD.\n           CALL 'ISPLINK'\n            USING\n             VDEFINE FNDSDSN FIND-OPTION-DSNAME CHAR LENGTH-FIELD.\n\n           MOVE +50 TO LENGTH-FIELD.\n           CALL 'ISPLINK'\n            USING\n             VDEFINE FNDSRCH FIND-OPTION-SEARCH-ARG CHAR LENGTH-FIELD.\n\n           MOVE +6 TO LENGTH-FIELD.\n           CALL 'ISPLINK'\n            USING\n             VDEFINE FNDSVOL FIND-OPTION-VOLUME CHAR LENGTH-FIELD.\n\n           MOVE +03 TO LENGTH-FIELD.\n           CALL 'ISPLINK'\n             USING\n               VDEFINE A01-A17 SELECTION-CODE-ARRAY CHAR LENGTH-FIELD.\n\n           MOVE +44 TO LENGTH-FIELD.\n           CALL 'ISPLINK'\n             USING\n               VDEFINE\n               W88DSN01-W88DSN17\n               DSNAMES-ARRAY\n               CHAR\n               LENGTH-FIELD.\n\n           MOVE SPACES TO DSNAMES-ARRAY.\n\n           CALL 'ISPLINK'\n                USING VGET W88DSN01-W88DSN17 PROFILE.\n\n           CALL 'ISPLINK'\n                USING VGET DYNPNAME SHARED.\n\n           IF RETURN-CODE NOT EQUAL ZERO\n               MOVE 'MULTEDIT' TO PANEL-NAME\n           ELSE\n               MOVE DYNAMIC-PANEL-NAME TO PANEL-NAME.\n\n       1999-EXIT-INITIALIZATION.\n           EXIT.\n           EJECT\n       2000-DISPLAY-PANEL.\n      *\n      **************************************************************\n      *                                                            *\n      *    DO THE EQUIVALENT OF:                                   *\n      *                                                            *\n      *         ISPEXEC DISPLAY PANEL(MULTEDIT) -                  *\n      *              MSG(MSG-ID) CURSOR(FIELD-NAME)                *\n      *                                                            *\n      **************************************************************\n      *\n           IF MESSAGE-ID = 'ABSENT  '\n               MOVE SPACES TO MESSAGE-ID.\n\n           CALL 'ISPLINK'\n                USING\n                   DISPLY\n                   PANEL-NAME\n                   MESSAGE-ID\n                   CURSOR-FIELD.\n\n           MOVE RETURN-CODE TO DISPLAY-RETURN-CODE.\n\n       2999-EXIT-DISPLAY-PANEL.\n           EXIT.\n           EJECT\n       3000-BREAKDOWN-RAW-DSN.\n      *\n      **************************************************************\n      *                                                            *\n      *    THIS ROUTINE ACCEPTS A DATASET NAME IN RAW-DSN AND      *\n      *    THEN CREATES THE FOLLOWING TWO DATA FIELDS:             *\n      *                                                            *\n      *           THE-DSNAME                                       *\n      *           THE-MEMBER                                       *\n      *                                                            *\n      *       WHERE THE-DSNAME IS THE DSNAME OF THE PDS WITHOUT    *\n      *       THE MEMBER SPECIFIED (IF ONE WAS SPECIFIED) AND      *\n      *       THE-MEMBER IS THE MEMBER NAME (IF WAS ONE SPECIFIED) *\n      *                                                            *\n      *       E.G.                                                 *\n      *           IF RAW-DSN PASSED = AGY999.MY.PDS(MASK1)         *\n      *                                                            *\n      *              THEN THIS ROUTINE CREATES THE-DSNAME AND      *\n      *              THE-MEMBER AS FOLLOWS:                        *\n      *                                                            *\n      *                   THE-DSNAME = AGY999.MY.PDS               *\n      *                   THE-MEMBER = MASK1                       *\n      *                                                            *\n      *       IF NO MEMBER WAS INCLUDED IN RAW-DSN OR IF THE       *\n      *       DATASET WAS NOT A PDS, THEN THE-MEMBER IS SET        *\n      *       EQUAL TO 'ABSENT  '                                  *\n      *                                                            *\n      *       IF ALL GOES WELL IN THE BREAKDOWN, THEN THIS ROUTINE *\n      *       MOVES 'YES' TO GOOD-BREAKDOWN ELSE IT WILL MOVE 'NO '*\n      *       TO GOOD-BREAKDOWN AND LOADS MESSAGE-ID WITH THE      *\n      *       APPROPRIATE MESSAGE                                  *\n      *                                                            *\n      **************************************************************\n      *\n\n           MOVE 'YES' TO GOOD-BREAKDOWN.\n\n           MOVE RAW-DSN TO INPUT-DSN OF BREAKDSN-IO-AREA.\n\n           CALL 'BREAKDSN' USING BREAKDSN-IO-AREA.\n\n           IF VALID-DSN-PASSED OF BREAKDSN-IO-AREA = 'YES'\n               NEXT SENTENCE\n           ELSE\n               MOVE 'NO ' TO GOOD-BREAKDOWN\n               MOVE ERROR-MESSAGE OF BREAKDSN-IO-AREA\n                 TO GENERIC-ERROR-MSG\n               MOVE 'WDED101' TO MESSAGE-ID\n               GO TO 3999-EXIT-BREAK-RAW-DSN.\n\n           MOVE OUTPUT-DSN OF BREAKDSN-IO-AREA TO TEMP-DSNAME.\n\n           IF MEMBER-NAME-PROVIDED OF BREAKDSN-IO-AREA = 'YES'\n                 MOVE OUTPUT-MEMBER-NAME OF BREAKDSN-IO-AREA\n                   TO THE-MEMBER\n           ELSE\n                 MOVE 'ABSENT  ' TO THE-MEMBER.\n\n           IF TEMP-DSN-BYTE (1) = QUOTE\n                PERFORM 3600-STRIP-OFF-QUOTES\n                   THRU 3699-EXIT-STRIP-QUOTES\n                GO TO 3400-GENERATE-THE-DSNAME.\n\n           PERFORM 3700-PREFIX-DSNAME\n              THRU 3799-EXIT-PREFIX-DSNAME.\n\n           IF PROCESS-SWITCH = 'YES'\n               NEXT SENTENCE\n           ELSE\n               MOVE 'NO ' TO GOOD-BREAKDOWN\n               GO TO 3999-EXIT-BREAK-RAW-DSN.\n\n       3400-GENERATE-THE-DSNAME.\n\n           MOVE INTERMEDIATE-DSNAME TO THE-DSNAME.\n           GO TO 3999-EXIT-BREAK-RAW-DSN.\n\n           EJECT\n       3600-STRIP-OFF-QUOTES.\n      *\n      **************************************************************\n      *                                                            *\n      *    THIS ROUTINE INPUTS TEMP-DSNAME (WHICH HAS ONLY THE     *\n      *    DSNAME WITHOUT A MEMBER SPECIFIED) AND IT GENERATES     *\n      *    THE DATA FIELD INTERMEDIATE-DSNAME WHICH HAS THE        *\n      *    BEGINNING AND ENDING QUOTES STRIPPED OFF                *\n      *                                                            *\n      *    IN SOME CASES, TEMP-DSNAME WILL NOT HAVE AN ENDING      *\n      *    QUOTE                                                   *\n      *                                                            *\n      **************************************************************\n      *\n           MOVE SPACES TO INTERMEDIATE-DSNAME.\n\n           MOVE +1 TO SUB2.\n\n       3610.\n\n           ADD +1 TO SUB2.\n           COMPUTE SUB3 = SUB2 - 1.\n\n           IF  (SUB2 GREATER THAN +44)\n             OR\n               (TEMP-DSN-BYTE (SUB2) = SPACE)\n             OR\n               (TEMP-DSN-BYTE (SUB2) = QUOTE)\n                    GO TO 3699-EXIT-STRIP-QUOTES.\n\n           MOVE TEMP-DSN-BYTE (SUB2)\n             TO INT-DSN-BYTE (SUB3).\n\n           GO TO 3610.\n\n       3699-EXIT-STRIP-QUOTES.\n           EXIT.\n           EJECT\n       3700-PREFIX-DSNAME.\n      *\n      **************************************************************\n      *                                                            *\n      *    THIS ROUTINE INPUTS TEMP-DSNAME (WHICH HAS ONLY THE     *\n      *    DSNAME WITHOUT A MEMBER SPECIFIED) AND IT GENERATES     *\n      *    THE DATA FIELD INTERMEDIATE-DSNAME WHICH HAS THE        *\n      *    PROFILE PREFIX APPENDED TO THE BEGINNING.  THE PREFIX   *\n      *    IS LOCATED IN THE FIELD PROFILE-PREFIX-TABLE.           *\n      *                                                            *\n      *    IF ALL GOES OK, THEN THIS ROUTINE DOES THE FOLLOWING:   *\n      *             MOVE 'YES' TO PROCESS-SWITCH                   *\n      *             MOVE 'ABSENT  ' TO MESSAGE-ID                  *\n      *             GO TO EXIT                                     *\n      *                                                            *\n      *    IF AFTER APPENDING THE PROFILE PREFIX, THE DSNAME       *\n      *    BECOMES LONGER THAN 44 BYTES, THEN THIS ROUTINE DOES    *\n      *    THE FOLLOWING:                                          *\n      *             MOVE 'NO ' TO PROCESS-SWITCH                   *\n      *             MOVE 'WDED100 ' TO MESSAGE-ID                  *\n      *             GO TO EXIT                                     *\n      *                                                            *\n      **************************************************************\n      *\n           MOVE 'YES' TO PROCESS-SWITCH.\n           MOVE 'ABSENT  ' TO MESSAGE-ID.\n           MOVE SPACES TO INTERMEDIATE-DSNAME.\n           MOVE +0 TO SUB3.\n\n       3710.\n\n           ADD +1 TO SUB3.\n\n           IF SUB3 GREATER THAN PROFILE-PREFIX-LENGTH\n               MOVE '.' TO INT-DSN-BYTE (SUB3)\n               ADD +1 TO SUB3\n           ELSE\n               MOVE PROFILE-PREFIX-BYTE (SUB3)\n                 TO INT-DSN-BYTE (SUB3)\n               GO TO 3710.\n\n           MOVE +0 TO SUB2.\n\n       3720.\n\n           ADD +1 TO SUB2.\n\n           IF SUB3 GREATER THAN +44\n              MOVE 'WDED100 ' TO MESSAGE-ID\n              MOVE 'NO ' TO PROCESS-SWITCH\n              GO TO 3799-EXIT-PREFIX-DSNAME.\n\n           IF TEMP-DSN-BYTE (SUB2) = SPACE\n              GO TO 3799-EXIT-PREFIX-DSNAME.\n\n           MOVE TEMP-DSN-BYTE (SUB2)\n             TO INT-DSN-BYTE (SUB3).\n           ADD +1 TO SUB3.\n           GO TO 3720.\n\n       3799-EXIT-PREFIX-DSNAME.\n           EXIT.\n           EJECT\n       3999-EXIT-BREAK-RAW-DSN.\n           EXIT.\n           EJECT\n       4000-PROCESS-THE-REQUEST.\n      *\n      **************************************************************\n      *                                                            *\n      *    THIS ROUTINE BASICALLY DOES THE FOLLOWING:              *\n      *                                                            *\n      *         1.  CALLS 'FILEATTR' TO SEE IF THE DATASET EXISTS  *\n      *         2.  IF FILEATTR FINDS A PROBLEM WITH THE DATASET,  *\n      *                THEN THIS ROUTINE MOVES 'NO ' TO            *\n      *                PROCESS-SWITCH, MOVES THE APPROPRIATE MSG   *\n      *                TO MESSAGE-ID, AND GOES TO THE EXIT.        *\n      *         3.  IF THE TYPE OF SERVICE IS BROWSE, THEN THIS    *\n      *                ROUTINE GOES TO 12                          *\n      *         4.  IF RECFM = U, THEN THIS ROUTINE MOVES 'NO '    *\n      *                TO PROCESS-SWITCH, MOVE THE APPROPRIATE MSG *\n      *                TO MESSAGE-ID, AND GOES TO THE EXIT.        *\n      *         5.  IF LRECL GT 255, THEN THIS ROUTINE MOVES 'NO ' *\n      *                TO PROCESS-SWITCH, MOVE THE APPROPRIATE MSG *\n      *                TO MESSAGE-ID, AND GOES TO THE EXIT.        *\n      *         6.  IF DSORG NE 'PS' OR 'PO', THEN IT  MOVES 'NO ' *\n      *                TO PROCESS-SWITCH, MOVE THE APPROPRIATE MSG *\n      *                TO MESSAGE-ID, AND GOES TO THE EXIT.        *\n      *         7.  IF A MEMBER NAME WAS SPECIFIED BUT THE DATASET *\n      *                IS NOT A PDS, THEN THIS ROUTINE MOVES 'NO ' *\n      *                TO PROCESS-SWITCH, MOVE THE APPROPRIATE MSG *\n      *                TO MESSAGE-ID, AND GOES TO THE EXIT.        *\n      *         8.  IF A MEMBER NAME WAS SPECIFIED, THEN IT        *\n      *                PERFORMS 5000-ATTACH-MEMBER WHICH ATTACHES  *\n      *                THE MEMBER NAME FOUND IN THE-MEMBER AND     *\n      *                CREATES FINAL-DSNAME                        *\n      *         9.  PEFORMS 7000-ENCLOSE-IN-QUOTES WHICH INPUTS    *\n      *                FINAL-DSNAME AND OUTPUTS FINAL-DSNAME WITH  *\n      *                QUOTES AROUND IT                            *\n      *         10. DOES THE EQUIVALENT OF THE FOLLOWING:          *\n      *                ISPEXEC EDIT DATASET(FINAL-DSNAME) -        *\n      *                     VOLUME(THE-VOL-SER)                    *\n      *         11. GO TO EXIT                                     *\n      *         12. IF A MEMBER NAME WAS SPECIFIED, THEN IT        *\n      *                PERFORMS 5000-ATTACH-MEMBER WHICH ATTACHES  *\n      *                THE MEMBER NAME FOUND IN THE-MEMBER AND     *\n      *                CREATES FINAL-DSNAME                        *\n      *         13. PEFORMS 7000-ENCLOSE-IN-QUOTES WHICH INPUTS    *\n      *                FINAL-DSNAME AND OUTPUTS FINAL-DSNAME WITH  *\n      *                QUOTES AROUND IT                            *\n      *         14. DOES THE EQUIVALENT OF THE FOLLOWING:          *\n      *                ISPEXEC BROWSE DATASET(FINAL-DSNAME) -      *\n      *                     VOLUME(THE-VOL-SER)                    *\n      *         15. GO TO EXIT                                     *\n      *                                                            *\n      **************************************************************\n      *\n           MOVE 'YES' TO PROCESS-SWITCH.\n           MOVE ALL '-' TO DATASET-SAVED-MSG.\n           MOVE 'DATASET ' TO GENERIC-LOC-OF-CURSOR.\n\n           IF  (MEMBER-NAME-OR-SEARCH-CRITERIA = SPACES)\n              OR\n               (TYPE-OF-SERVICE = 'FIND  ')\n                   NEXT SENTENCE\n           ELSE\n                   MOVE BYTES-1-8 OF MEMBER-NAME-OR-SEARCH-CRITERIA\n                     TO THE-MEMBER.\n\n           MOVE THE-DSNAME TO FILEATTR-IN-DSN.\n           MOVE THE-VOL-SER TO FILEATTR-IN-VOLSER.\n\n           CALL 'FILEATTR' USING FILEATTR-IN-DSN\n                                 FILEATTR-OUT-VALID-SWITCH\n                                 FILEATTR-OUT-ERROR-MESSAGE\n                                 FILEATTR-OUT-VOLSER\n                                 FILEATTR-OUT-LRECL\n                                 FILEATTR-OUT-BLKSIZE\n                                 FILEATTR-OUT-DSORG\n                                 FILEATTR-OUT-RECFM\n                                 FILEATTR-OUT-DEVICE\n                                 FILEATTR-IN-VOLSER.\n\n           IF FILEATTR-OUT-VALID-SWITCH = 'YES'\n                GO TO 4100-CHEK-SERV-TYPE.\n\n           MOVE 'NO ' TO PROCESS-SWITCH.\n           MOVE FILEATTR-OUT-ERROR-MESSAGE\n             TO BREAKDOWN-FILEATTR-ERR-MSG.\n\n      *        START CASE STATEMENT\n\n               IF BYTES-1-13 OF BREAKDOWN-FILEATTR-ERR-MSG\n                    EQUAL 'FORMAT-1 DSCB'\n                         MOVE 'DATASET NOT FOUND             '\n                           TO GENERIC-ERROR-MSG\n           ELSE\n               IF BYTES-1-13 OF BREAKDOWN-FILEATTR-ERR-MSG\n                    EQUAL 'INVALID SYNTA'\n                         MOVE 'INVALID DATASET NAME          '\n                           TO GENERIC-ERROR-MSG\n           ELSE\n               MOVE FILEATTR-OUT-ERROR-MESSAGE\n                 TO GENERIC-ERROR-MSG.\n\n      *        END CASE STATEMENT\n\n           MOVE 'WDED101 ' TO MESSAGE-ID.\n           GO TO 4999-EXIT-PROCESS-REQ.\n\n       4100-CHEK-SERV-TYPE.\n\n           IF TYPE-OF-SERVICE = 'BROWSE'\n              GO TO 4300-DO-BROWSE.\n\n           IF FILEATTR-OUT-RECFM = 'U'\n              MOVE 'WDED103 ' TO MESSAGE-ID\n              MOVE 'NO ' TO PROCESS-SWITCH\n              GO TO 4999-EXIT-PROCESS-REQ.\n\n           IF FILEATTR-OUT-LRECL GREATER THAN 255\n              MOVE 'WDED102 ' TO MESSAGE-ID\n              MOVE 'NO ' TO PROCESS-SWITCH\n              GO TO 4999-EXIT-PROCESS-REQ.\n\n           IF FILEATTR-OUT-DSORG = 'PO' OR 'PS'\n              NEXT SENTENCE\n           ELSE\n              MOVE 'WDED104 ' TO MESSAGE-ID\n              MOVE 'NO ' TO PROCESS-SWITCH\n              GO TO 4999-EXIT-PROCESS-REQ.\n\n           IF  (TYPE-OF-SERVICE = 'FIND  ')\n             AND\n               (FILEATTR-OUT-DSORG NOT EQUAL 'PO')\n                    MOVE 'WDED109B' TO MESSAGE-ID\n                    MOVE 'NO ' TO PROCESS-SWITCH\n                    GO TO 4999-EXIT-PROCESS-REQ.\n\n           IF TYPE-OF-SERVICE = 'FIND  '\n               PERFORM 8000-DO-FIND-FUNCTION\n                  THRU 8999-EXIT-FIND\n               GO TO 4999-EXIT-PROCESS-REQ.\n\n           IF FILEATTR-OUT-DSORG = 'PS'\n                IF THE-MEMBER = 'ABSENT  '\n                    MOVE '--------DATASET SAVED'\n                      TO DATASET-SAVED-MSG\n                ELSE\n                    MOVE 'WDED107 ' TO MESSAGE-ID\n                    MOVE 'NO ' TO PROCESS-SWITCH\n                    GO TO 4999-EXIT-PROCESS-REQ\n           ELSE\n                IF THE-MEMBER = 'ABSENT  '\n                    NEXT SENTENCE\n                ELSE\n                    MOVE THE-MEMBER TO MEMBER-BEING-SAVED\n                                         OF MEMBER-SAVED-MSG\n                    MOVE MEMBER-SAVED-MSG TO DATASET-SAVED-MSG.\n\n           IF THE-MEMBER = 'ABSENT  '\n               MOVE THE-DSNAME TO FINAL-DSNAME\n           ELSE\n               PERFORM 5000-ATTACH-MEMBER\n                  THRU 5999-EXIT-ATTACH-MEMBER.\n\n           PERFORM 7000-ENCLOSE-IN-QUOTES\n              THRU 7999-EXIT-PUT-IN-QUOTES.\n\n           IF THE-VOL-SER = 'ABSENT'\n                CALL 'ISPLINK'\n                     USING EDIT\n                           FINAL-DSNAME\n           ELSE\n                CALL 'ISPLINK'\n                     USING EDIT\n                           FINAL-DSNAME\n                           THE-VOL-SER.\n\n           IF RETURN-CODE = 0\n                 MOVE 'ABSENT  ' TO MESSAGE-ID\n                 GO TO 4999-EXIT-PROCESS-REQ.\n\n           IF RETURN-CODE = 4\n                 MOVE 'ABSENT  ' TO MESSAGE-ID\n                 MOVE ALL '-' TO DATASET-SAVED-MSG\n                 GO TO 4999-EXIT-PROCESS-REQ.\n\n           MOVE CNTL-ERRS-MSG-ID TO MESSAGE-ID.\n           MOVE 'NO ' TO PROCESS-SWITCH.\n           MOVE ALL '-' TO DATASET-SAVED-MSG.\n           GO TO 4999-EXIT-PROCESS-REQ.\n\n       4300-DO-BROWSE.\n\n           IF FILEATTR-OUT-DSORG = 'PO' OR 'PS'\n              NEXT SENTENCE\n           ELSE\n              MOVE 'WDED104 ' TO MESSAGE-ID\n              MOVE 'NO ' TO PROCESS-SWITCH\n              GO TO 4999-EXIT-PROCESS-REQ.\n\n           IF FILEATTR-OUT-DSORG = 'PO'\n              NEXT SENTENCE\n           ELSE\n              IF THE-MEMBER = 'ABSENT  '\n                  NEXT SENTENCE\n              ELSE\n                  MOVE 'WDED107 ' TO MESSAGE-ID\n                  MOVE 'NO ' TO PROCESS-SWITCH\n                  GO TO 4999-EXIT-PROCESS-REQ.\n\n           IF THE-MEMBER = 'ABSENT  '\n               MOVE THE-DSNAME TO FINAL-DSNAME\n           ELSE\n               PERFORM 5000-ATTACH-MEMBER\n                  THRU 5999-EXIT-ATTACH-MEMBER.\n\n           PERFORM 7000-ENCLOSE-IN-QUOTES\n              THRU 7999-EXIT-PUT-IN-QUOTES.\n\n           IF THE-VOL-SER = 'ABSENT'\n                CALL 'ISPLINK'\n                     USING BROWSE\n                           FINAL-DSNAME\n           ELSE\n                CALL 'ISPLINK'\n                     USING BROWSE\n                           FINAL-DSNAME\n                           THE-VOL-SER.\n\n           IF RETURN-CODE = 0\n                MOVE 'ABSENT  ' TO MESSAGE-ID\n                GO TO 4999-EXIT-PROCESS-REQ.\n\n           MOVE CNTL-ERRS-MSG-ID TO MESSAGE-ID.\n           MOVE 'NO ' TO PROCESS-SWITCH.\n           MOVE ALL '-' TO DATASET-SAVED-MSG.\n\n           IF MEMBER-NAME-OR-SEARCH-CRITERIA = SPACES\n                NEXT SENTENCE\n           ELSE\n                MOVE 'MEMBER  ' TO GENERIC-LOC-OF-CURSOR.\n\n       4999-EXIT-PROCESS-REQ.\n           EXIT.\n           EJECT\n       5000-ATTACH-MEMBER.\n      *\n      **************************************************************\n      *                                                            *\n      *    THIS ROUTINE IS GIVEN THE-DSNAME AND THE-MEMBER AND     *\n      *    CREATES FINAL-DSNAME WHICH HAS THE MEMBER ATTACHED TO   *\n      *    IT                                                      *\n      *                                                            *\n      *        E.G.                                                *\n      *                                                            *\n      *            IF THE-DSNAME IS AGY999.MY.PDS AND              *\n      *               THE-MEMBER IS MASK1                          *\n      *                                                            *\n      *                THEN THIS ROUTINE CREATES                   *\n      *                    FINAL-DSNAME = AGY999.MY.PDS(MASK1)     *\n      *                                                            *\n      *                                                            *\n      *                                                            *\n      **************************************************************\n      *\n           MOVE THE-DSNAME TO FINAL-DSNAME-TABLE.\n           MOVE +0 TO SUB2.\n\n       5100.\n\n           ADD +1 TO SUB2.\n\n           IF  (SUB2 GREATER THAN +44)\n             OR\n               (FINAL-DSNAME-ELEMENT (SUB2) = SPACE)\n                    NEXT SENTENCE\n           ELSE\n                    GO TO 5100.\n\n           MOVE '(' TO FINAL-DSNAME-ELEMENT (SUB2).\n\n           ADD +1 TO SUB2.\n\n           MOVE THE-MEMBER TO MEMBER-TABLE.\n           MOVE +0 TO SUB3.\n\n       5200.\n\n           ADD +1 TO SUB3.\n\n           IF  (SUB3 GREATER THAN +8)\n             OR\n               (MEMBER-ELEMENT (SUB3) = SPACE)\n                    NEXT SENTENCE\n           ELSE\n                    MOVE MEMBER-ELEMENT (SUB3)\n                      TO FINAL-DSNAME-ELEMENT (SUB2)\n                    ADD +1 TO SUB2\n                    GO TO 5200.\n\n           MOVE ')' TO FINAL-DSNAME-ELEMENT (SUB2).\n\n           MOVE FINAL-DSNAME-TABLE TO FINAL-DSNAME.\n\n       5999-EXIT-ATTACH-MEMBER.\n           EXIT.\n           EJECT\n       6000-DETERMINE-CURSOR-POSITION.\n      *\n      **************************************************************\n      *                                                            *\n      *    THIS ROUTINE IS GIVEN SUB (WHICH RANGES FROM 1 THRU 17) *\n      *    AND IT RETURNS NEXT-CURSOR-POSITION WHICH IS EQUAL TO   *\n      *    THE APPROPRAIE SPF VARIABLE NAME FOR THE DSNAME IN THE  *\n      *    TABLE                                                   *\n      *                                                            *\n      *        E.G.                                                *\n      *                                                            *\n      *            IF SUB IS EQUAL TO 4                            *\n      *                 THEN THIS ROUTINE MOVES 'W88DSN04'         *\n      *                    TO NEXT-CURSOR-POSITION                 *\n      *                                                            *\n      **************************************************************\n      *\n           SEARCH ALL CURSOR-SEARCH-TABLE\n              AT END\n                  GO TO 6500\n              WHEN\n                  CURSOR-LOC-ARGUMENT (CURSOR-LOC-INDEX) = SUB\n                       MOVE CURSOR-LOC-RESULT (CURSOR-LOC-INDEX)\n                         TO NEXT-CURSOR-POSITION\n                       GO TO 6999-EXIT-DET-CUR-POS.\n\n       6500.\n\n           DISPLAY '*******************************'.\n           DISPLAY '*                             *'.\n           DISPLAY '*  IF THIS MESSAGE IS EVER    *'.\n           DISPLAY '*  DISPLAYED, THEN IT IS      *'.\n           DISPLAY '*  EVEN POSSIBLE FOR AN EVEN  *'.\n           DISPLAY '*  NUMBER NOT TO BE DIVISIBLE *'.\n           DISPLAY '*  BY 2 !!!!!                 *'.\n           DISPLAY '*                             *'.\n           DISPLAY '*          OR (MORE LIKELY)   *'.\n           DISPLAY '*                             *'.\n           DISPLAY '*  SOMEONE HAS ALTERED THIS   *'.\n           DISPLAY '*  PROGRAM !!!                *'.\n           DISPLAY '*                             *'.\n           DISPLAY '*******************************'.\n           MOVE SPACE TO ABOUT-TO-ABORT.\n           ADD +1 TO ABORT-NUMBER.\n\n       6999-EXIT-DET-CUR-POS.\n           EXIT.\n           EJECT\n       7000-ENCLOSE-IN-QUOTES.\n      *\n      **************************************************************\n      *                                                            *\n      *    THIS ROUTINE INPUTS FINAL-DSNAME (WHICH DOES NOT HAVE   *\n      *    QUOTES AROUND IT) AND OUTPUTS FINAL-DSNAME WHICH HAS    *\n      *    QUOTES SURROUNDING IT                                   *\n      *                                                            *\n      *    FINAL-DSNAME MAY OR MAY NOT HAVE A MEMBER NAME INCLUDED *\n      *                                                            *\n      **************************************************************\n      *\n           MOVE FINAL-DSNAME TO FINAL-DSNAME-TABLE.\n           MOVE FINAL-DSNAME-ELEMENT (1) TO HOLD-FIRST.\n           MOVE QUOTE TO FINAL-DSNAME-ELEMENT (1).\n           MOVE +1 TO SUB2.\n\n       7100.\n\n           ADD +1 TO SUB2.\n\n           IF  (SUB2 GREATER THAN +54)\n             OR\n               (FINAL-DSNAME-ELEMENT (SUB2) = SPACE)\n                    MOVE HOLD-FIRST TO FINAL-DSNAME-ELEMENT (SUB2)\n                    ADD +1 TO SUB2\n                    MOVE QUOTE TO FINAL-DSNAME-ELEMENT (SUB2)\n                    MOVE FINAL-DSNAME-TABLE TO FINAL-DSNAME\n                    GO TO 7999-EXIT-PUT-IN-QUOTES.\n\n           MOVE FINAL-DSNAME-ELEMENT (SUB2) TO HOLD-SECOND.\n           MOVE HOLD-FIRST TO FINAL-DSNAME-ELEMENT (SUB2).\n           MOVE HOLD-SECOND TO HOLD-FIRST.\n           GO TO 7100.\n\n       7999-EXIT-PUT-IN-QUOTES.\n           EXIT.\n           EJECT\n       8000-DO-FIND-FUNCTION.\n\n           MOVE THE-DSNAME\n             TO FIND-OPTION-DSNAME.\n           MOVE THE-VOL-SER\n             TO FIND-OPTION-VOLUME.\n           MOVE MEMBER-NAME-OR-SEARCH-CRITERIA\n             TO FIND-OPTION-SEARCH-ARG.\n\n           CALL 'ISPLINK'\n                USING VPUT FNDSDSN SHARED.\n           CALL 'ISPLINK'\n                USING VPUT FNDSRCH SHARED.\n           CALL 'ISPLINK'\n                USING VPUT FNDSVOL SHARED.\n\n           MOVE +13 TO LENGTH-FIELD.\n\n           IF  (OTHER-DATASET-DSNAME NOT EQUAL SPACES)\n                         AND\n               (OTHER-DATASET-SEL-CODE = 'F  ')\n            OR\n               (OTHER-DATASET-DSNAME EQUAL SPACES)\n                         AND\n               (SEL-CODE-ELEMENT (SUB) = 'F  ')\n\n                    CALL 'ISPLINK'\n                       USING\n                          SELEKT\n                          LENGTH-FIELD\n                          FNDSMEM-CMD\n           ELSE\n                    CALL 'ISPLINK'\n                       USING\n                          SELEKT\n                          LENGTH-FIELD\n                          SPFYFND-CMD.\n\n           CALL 'ISPLINK'\n                USING VGET FNDSERR SHARED.\n\n           MOVE FIND-OPTION-ERRMSG\n             TO BREAKDOWN-FIND-OPT-MSG.\n\n           IF BYTES-1-8 OF BREAKDOWN-FIND-OPT-MSG = 'NO ERROR'\n              MOVE 'ABSENT  ' TO MESSAGE-ID\n              GO TO 8999-EXIT-FIND.\n\n           IF BYTES-1-8 OF BREAKDOWN-FIND-OPT-MSG = 'NO HITS '\n              MOVE 'WDED109C' TO MESSAGE-ID\n              GO TO 8999-EXIT-FIND.\n\n           IF BYTES-1-8 OF BREAKDOWN-FIND-OPT-MSG = 'CANNOT S'\n              MOVE 'WDED109D' TO MESSAGE-ID\n              GO TO 8999-EXIT-FIND.\n\n           MOVE FIND-OPTION-ERRMSG TO GENERIC-ERROR-MSG.\n              MOVE 'WDED101 ' TO MESSAGE-ID.\n\n       8999-EXIT-FIND.\n           EXIT.\n           EJECT\n       9000-END-OF-JOB.\n      *\n      **************************************************************\n      *                                                            *\n      *    THIS ROUTINE VPUTS THE FOLLOWING 17 VARIABLES TO THE    *\n      *    USER PROFILE:                                           *\n      *                                                            *\n      *              W88DSN01                                      *\n      *              W88DSN02                                      *\n      *              W88DSN03                                      *\n      *              W88DSN04                                      *\n      *              W88DSN05                                      *\n      *              W88DSN06                                      *\n      *              W88DSN07                                      *\n      *              W88DSN08                                      *\n      *              W88DSN09                                      *\n      *              W88DSN10                                      *\n      *              W88DSN11                                      *\n      *              W88DSN12                                      *\n      *              W88DSN13                                      *\n      *              W88DSN14                                      *\n      *              W88DSN15                                      *\n      *              W88DSN16                                      *\n      *              W88DSN17                                      *\n      *                                                            *\n      **************************************************************\n      *\n           CALL 'ISPLINK'\n                USING VPUT W88DSN01-W88DSN17 PROFILE.\n\n       9999-EXIT-END-OF-JOB.\n           EXIT.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DSNTAB": {"ttr": 16135, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x00\\x7f\\x00\\x88\\x00\\x7f\\x12\\x00\\x00e\\x00e\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf2\\xf7\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-01-07T00:00:00", "modifydate": "1988-01-07T12:00:00", "lines": 101, "newlines": 101, "modlines": 0, "user": "FILE270"}, "text": "*          DATA SET 761KKDSNTB AT LEVEL 001 AS OF 08/30/82\n* WRITTEN BY KERMIT KISER - WASHINGTON STATE DP SERVICE CENTER (WDPSC)\n*\nDSNTAB   ENTERR LEVEL=V1M0\n         LR    R11,R1             R11->PARM LIST\n         SLR   R15,R15            R15=0\n         EJECT\n*\n*        MAINLINE ROUTINE:\n*\n         BAL   R14,FINDDD         R9->DD ENTRY\n         BXH   R15,R15,EXIT       STOP IF NOT FOUND\n*\n*\n         SLR   R5,R5              R5=0  DSN COUNT\n         L     R6,4(,R11)         R6->DSN TABLE\n         L     R7,8(,R11)         R7->SIZE OF TABLE\n         LH    R7,0(,R7)          R7=LENGTH OF TABLE\n*\nMOVELOOP BAL   R14,MOVEDSN        PUT THE DSN IN THE TABLE\n         BXH   R15,R15,EXIT       STOP IF TABLE ERROR\n         CLI   0(R9),X'00'        END OF TIOT?\n         BE    MOVEND             YES\n         CLC   4(8,R9),=CL8' '    BLANK DD NAME?\n         BE    MOVELOOP           YES->MUST BE CONCATENATED\n*\nMOVEND   L     R1,12(,R11)        R1->ENTRY COUNT PARM\n         STH   R5,0(R1)           PASS THE COUNT OF ENTRIES TO JEFF\n         EJECT\n*\n*        CODE  TO LEAVE DSNTAB:\n*\nEXIT     LEAVER\n         EJECT\n*                                 FIND THE DDNAME IN THE TIOT:\n*\nFINDDD   ST    R14,L1LS\n         L     R1,540             R1->TCB NOW RUNNING\n         L     R2,12(,R1)         R2->TIOT\n         LA    R9,24(,R2)         R9->FIRST DD ENTRY IN TIOT\n         L     R10,0(,R11)        R10->DDNAME PASSED BY JEFF\n*\nMTCHLOOP CLC   0(8,R10),4(R9)     DDNAMES MATCH?\n         BE    FINDX              YES\n         BAL   R14,NEXTDD         R9->NEXT DD ENTRY\n         CLI   0(R9),X'00'        END OF TIOT?\n         BNE   MTCHLOOP           NO->COMPARE DDNAME\n*\n         LA    R15,2              R15=2 RC=4\n*\nFINDX    L     R14,L1LS\n         BR    R14                EXIT\n         EJECT\n*\n*              SUBRTN TO MOVE A   DSN TO THE TABLE:\n*\nMOVEDSN  ST    R14,L1LS\n         ICM   R1,7,12(R9)        R1->JFCB\n         CH    R7,=H'50'          ROOM IN TABLE FOR THIS NAME?\n         BNL   MOVEIT             YES -> DO IT\n         LA    R15,4              NO->SAY TABLE SIZE ERROR\n         B     MX\n*\nMOVEIT   MVC   6(44,R6),16(R1)    MOVE THE DSN INTO THE TABLE\n         MVC   0(4,R6),=X'00020001'    INIT TEXT UNIT KEY\n*\n*                                 FIND THE LENGTH OF THE DSN:\n*\n         LA    R2,6(,R6)          R2->DSN\n         SLR   R3,R3              R3=0 INIT DSN LEN\nDSL      IC    R4,0(R2,R3)        R4=NEXT DSN CHAR TO BE CHECKED\n         CLM   R4,1,=C' '         IS IT BLANK?\n         BE    DSEND              YES\n         LA    R3,1(,R3)          R3+1->NEXT CHAR\n         B     DSL                CHECK NEXT IF NO BLANK YET\n*\nDSEND    STH   R3,4(,R6)          PUT THE DSN LENGTH IN THE TABLE\n         SH    R7,=H'50'          UPDATE LENGTH REMAINING IN TABLE\n         LA    R5,1(,R5)          R5+1=DSN COUNT IN TABLE\n         BAL   R14,NEXTDD         R9->NEXT DD ENTRY IN TIOT\n         LA    R6,50(,R6)         R6->NEXT SLOT IN NAME TABLE\n*\nMX       L     R14,L1LS\n         BR    R14                EXIT\n         EJECT\n*\n*              SUBRTN TO MOVE R9  TO THE NEXT DD ENTRY IN THE TIOT\n*\nNEXTDD   SLR   R8,R8\n         IC    R8,0(,R9)          R8=LENGTH OF CURRENT DD ENTRY\n         LA    R9,0(R8,R9)        R9->NEXT DD ENTRY IN TIOT\n         BR    R14                RETURN\n         SPACE 2\n         LTORG\n         SPACE 2\nWORKAREA DSECT\nSAVEAREA DS    18F\nL1LS     DS    F\nL2LS     DS    F\nWORKLEN  EQU   *-WORKAREA\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "DSNTAB$": {"ttr": 16138, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x00\\x7f\\x00\\x88\\x00\\x7f\\x12\\x00\\x005\\x005\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf2\\xf7\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-01-07T00:00:00", "modifydate": "1988-01-07T12:00:00", "lines": 53, "newlines": 53, "modlines": 0, "user": "FILE270"}, "text": "1                                                        DSNTAB.1\n                                                         10/29/84\n\n\n  PROGRAM:       DSNTAB\n  AUTHOR:        Kermit Kiser\n  AGENCY:        WDPSC\n  LANGUAGE:      Assembler\n  LOCATION:      KK00150.MY.LOAD\n  FUNCTION:      Subroutine to pass back list of all DSNAMEs\n                 concatenated to a given DDNAME.\n\n  This is a subroutine which accepts a DDNAME and passes back to the\n  invoker a list of DSNAMEs concatenated to that DDNAME.  This program\n  can return up to 50 datasets concatenated to a given DDNAME.\n\n  To use this program from COBOL, do the following:\n\n     .  Place the following data areas in WORKING STORAGE:\n\n           01  THE-DDNAME                        PIC X(8).\n           01  DSNAME-TABLE.\n               05  DSNAME-ELEMENT OCCURS 50 TIMES.\n                   10  FILLER                    PIC X(6).\n                   10  THE-DSNAME                PIC X(44).\n           01  TABLSIZE      VALUE +2500         PIC S9(4) COMP.\n           01  NO-OF-SIGNIF-DSNAMES              PIC S9(4) COMP.\n\n     .  Place the following code in the PROCEDURE DIVISION.\n\n           MOVE your ddname TO THE-DDNAME.\n\n           CALL 'DSNTAB' USING  THE-DDNAME\n                                DSNAME-TABLE\n                                TABLSIZE\n                                NO-OF-SIGNIF-DSNAMES.\n\n     .  After the CALL, the list of DSNAMES will be found in\n        DSNAME-TABLE and the number of significant dataset\n        names will be found in NO-OF-SIGNIF-DSNAMES.\n\n\n  POSSIBLE RETURN CODES\n  _____________________\n\n         Value     Meaning\n         -----     ------------------------------------------------\n\n           0       Successful completion\n\n           4       DDNAME not found\n\n           8       More than 50 datasets concatenated to the DDNAME\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "DUMMY": {"ttr": 16140, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x00\\x7f\\x00\\x88\\x00\\x7f\\x12\\x00\\x00\\x03\\x00\\x03\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf2\\xf7\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-01-07T00:00:00", "modifydate": "1988-01-07T12:00:00", "lines": 3, "newlines": 3, "modlines": 0, "user": "FILE270"}, "text": "DUMMY\nDUMMY\nDUMMY\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "DUMPVOL": {"ttr": 16142, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x00\\x7f\\x00\\x88\\x00\\x7f\\x12\\x00\\x01_\\x01_\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf2\\xf7\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-01-07T00:00:00", "modifydate": "1988-01-07T12:00:00", "lines": 351, "newlines": 351, "modlines": 0, "user": "FILE270"}, "text": "//D0100150 JOB (2100,56-D),'DZEIG 0684 T',CLASS=H,MSGCLASS=T\n//X EXEC ASMHCL,LIBRARY='WDPSC.SYSLIBRY',LNDSP=SHR,\n//    LIB2='SYS1.AMODGEN',LIB3='WIZRD150.DN00150.FILE'\nDUMPVOL  CSECT\n         STM   R14,R12,12(R13)            SAVE REGISTERS\n         LR    R11,R13\n         BALR  R12,0                      LOAD BASE REGISTER\n         USING *,R12\n         LA    R13,SAVE                   SAVE AREA\n         ST    R13,8(0,R11)               AND BACK CHAIN\n         ST    R11,4(0,R13)\n         XR    R4,R4                      ANALYZE PARAMETER\n         L     R3,0(,R1)\n         CH    R4,0(,R3)                  IF LENGTH IS ZERO\n         BE    NOPARM                         NO PARAMETER\n         LA    R5,2(,R3)\n         LH    R4,0(,R3)\nDSNCHECK EQU   *\n         CLC   0(4,R5),=C'DSN='\n         BNE   DAYCHECK\n         LR    R6,R4\n         BCTR  R6,0\n         EX    R6,MVCJOB          MVC  JOBLIB(0),0(R5)\n         LA    R7,JOBLIB\n         LA    R6,52\nCOMMAR   CLI   0(R7),C','\n         BE    COMMA\n         LA    R7,1(,R7)\n         BCT   R6,COMMAR\n         B     UPSCAN\nCOMMA    MVI   0(R7),C' '\nDAYCHECK CLC   0(4,R5),=C'DAY='\n         BE    DAYPARM\nUPSCAN   EQU   *\n         LA    R5,1(,R5)\n         BCT   R4,DSNCHECK\n         B     NOPARM\n         SPACE 4\nDAYPARM  EQU   *\n         CLC   4(3,R5),=C'SUN'\n         BNE   UPSCAN\nSETPARM  MVI   JOB1+4,C'5'               DUANE 2/24/84\n         MVI   SETUP1+17,C'5'            DUANE 2/24/84\n         MVC   TAPDSN0B,VLTWDPSC\n         MVC   TAPDSN1B,VLTWDPSC\n         MVC   TAPDSN2B,VLTWDPSC\n         MVC   TAPDSN3B,VLTWDPSC\n         MVC   TAPDSN4B,VLTWDPSC\n         MVC   TAPRET1B,=C'14'           DUANE 2/24/84\n         MVC   TAPRET2B,=C'14'           DUANE 2/24/84\n         MVC   TAPRET3B,=C'14'           DUANE 2/24/84\n         MVC   TAPRET4B,=C'14'           DUANE 2/24/84\n         B     UPSCAN\nNOPARM   EQU   *\n         DEVTYPE SERIALS,DEVAREA,DEVTAB    CHECK FOR INPUT DDNAME\n         LTR   R15,R15\n         BNZ   FINIT                      FINISH IF NOT PRESENT\n         OPEN  (INDCB)\n         TM    INDCB+48,X'10'             DID OPEN FAIL\n         BZ    FINIT                      YES\n         LA    R4,VOLTABLE            POINT TO TABLE\n         SR    R11,R11                ZERO THE COUNT\n         SPACE 3\n**********************************************************************\n*                                                                    *\n*      READ INPUT FILE AND BUILD VOLUME TABLE                        *\nREADING  GET   INDCB                      GET INPUT FILE\n*        CLI   71(R1),C' '\n*        BNE   ACQUIRE\n*        CLI   6(R1),C' '\n*        BE    READING\nACQUIRE  EQU   *\n         MVC   0(6,R4),0(R1)         ACQUIRE VOLUME SERIAL NUMBER\n         LA    R4,10(,R4)            POINT TO NEXT TABLE ENTRY\n         LA    R11,1(,R11)           ADD TO COUNT\n         B     READING\n*                                                                    *\n**********************************************************************\n         SPACE 3\nEOF      EQU   *\n         LTR   R11,R11\n         BNP   VOLTABLE+100\n         ST    R11,VOLCOUNT\n        EJECT\n**********************************************************************\n*                                                                    *\n*    SET UP IOS SCAN OR UCB SCAN                                     *\n*  GIVES EACH DASD UCB BACK IN SUCESSION                             *\n         L     R4,CVTPTR\n         USING CVT,R4\nLOOKIT   LA    R1,UCBPARM\n         L     R15,CVTUCBSC\n         BALR  R14,R15\n         LTR   R15,R15\n         BNZ   ALLOVER\n         L     R6,UCBLOCAT\n         USING UCBCMSEG,R6\n         SPACE 4\n**********************************************************************\n*                                                                    *\n*     LOOP THROUGH VOLUME TABLE LOOKING FOR MATCH TO UCB             *\n         LA    R5,VOLTABLE\nCLCCLC   CLC   UCBVOLI,0(R5)\n         BE    PUBLIC\n         LA    R5,10(,R5)\n         CLC   0(2,R5),=X'EEEE'\n         BNE   CLCCLC\n         B     LOOKIT\nPUBLIC   EQU   *\n         MVC   6(3,R5),UCBNAME\n         B     LOOKIT\n* END OF VOLUME TABLE LOOP                                           *\n**********************************************************************\n* END OF UCB SCAN                                                    *\n**********************************************************************\n         SPACE 4\n**********************************************************************\n*                                                                    *\nALLOVER  EQU   *\n         L     R11,VOLCOUNT\n         L     R10,VOLCOUNT\n         LA    R5,VOLTABLE\n         ST    R11,VOLCOUNT\n* ALLOCATE AND OPEN THE OUTPUT DATA SET\n         DEVTYPE INTR,DEVAREA         CHECK FOR DDNAME JCL\n         LTR   R15,R15                IS IT PRESENT?\n         BNZ   FINIT                  NO\n         OPEN  (JCL,OUTPUT)           INTERNAL READER DATA SET\n         TM    JCL+48,X'10'         DID IT OPEN\n         BZ    FINIT\n         PUT   JCL,JOB1\n*//W6601150 JOB (2100,56-D),'DZEIG 0684 T',CLASS=C\n         CLC   JOBLIB(8),=CL8' '\n         BE    SETUPS\n         PUT   JCL,JOB3\n         SPACE 4\nSETUPS   EQU   *\n         L     R11,VOLCOUNT\n         LA    R5,VOLTABLE\n         PUT   JCL,SETUP1\n         PUT   JCL,MESSAGE1\nMESSAGES EQU   *\n         CLC   6(3,R5),=X'EEEEEE'\n         BE    MESSAGEX\n         MVC   VOLSER0A,0(R5)\n         PUT   JCL,MESSAGE2\nMESSAGEX EQU   *\n         LA    R5,10(,R5)\n         BCT   R11,MESSAGES\n         SPACE 4\n         L     R11,VOLCOUNT\n         LA    R5,VOLTABLE\nEXECUTE  EQU   *\n         PUT   JCL,EXEC3\n*//*\n         AP    STEP##,=P'1'       ADD 1 TO STEP COUNT\n         UNPK  STEPNAME,STEP##    UNPACK THE NUMBER\n         OI    STEPNAME+4,X'F0'   MAKE NUMBER USEABLE\n         PUT   JCL,EXEC1\n*//STEPNAME EXEC PGM=FDR,PARM=A     DUMP MULTIPLE VOLUMES\n         PUT   JCL,SLPRINT            DUANE 2/24/84\n*//SYSPRINT DD SYSOUT=*               DUANE 2/24/84\nLEVER1   EQU   *\n         CLC   6(3,R5),=X'EEEEEE'\n         BNE   LEVER2\n         LA    R5,10(,R5)\n         BCT   R11,LEVER1\n         B     SLISTSET\nLEVER2   EQU   *\n         MVC   VOLSER1,0(R5)\n         MVC   VOLSER1A,0(R5)\n         PUT   JCL,DISK1\n*//DISK1 DD UNIT=SYSALLDA,DISP=SHR,VOL=SER=??????\n         PUT   JCL,TAPE1\n*//TAPE1  DD UNIT=TAPE16,DISP=(,KEEP),DSN=\n         PUT   JCL,SYSPRIN1\n*//SYSPRIN1 DD SYSOUT=*\n         LA    R5,10(,R5)\n         BCT   R11,SECONDD\n         B     SLISTSET\nSECONDD  EQU   *\n         CLC   6(3,R5),=X'EEEEEE'\n         BNE   LEVER3\n         LA    R5,10(,R5)\n         BCT   R11,SECONDD\n         B     SLISTSET\nLEVER3   EQU   *\n         MVC   VOLSER2,0(R5)\n         MVC   VOLSER2A,0(R5)\n         PUT   JCL,DISK2\n*//DISK2 DD UNIT=SYSALLDA,DISP=SHR,VOL=SER=######\n         PUT   JCL,TAPE2\n*//TAPE2  DD UNIT=TAPE16,DISP=(,KEEP),DSN=\n         PUT   JCL,SYSPRIN2\n*//SYSPRIN2 DD SYSOUT=*\n         LA    R5,10(,R5)\n         BCT   R11,THREEDD\n         B     SLISTSET\n         SPACE 4\nTHREEDD  EQU   *\n         CLC   6(3,R5),=X'EEEEEE'\n         BNE   LEVER8\n         LA    R5,10(,R5)\n         BCT   R11,THREEDD\n         B     SLISTSET\nLEVER8   EQU   *\n         MVC   VOLSER3,0(R5)\n         MVC   VOLSER3A,0(R5)\n         PUT   JCL,DISK3\n*//DISK3 DD UNIT=SYSALLDA,DISP=SHR,VOL=SER=######\n         PUT   JCL,TAPE3\n*//TAPE3  DD UNIT=TAPE16,DISP=(,KEEP),DSN=\n         PUT   JCL,SYSPRIN3\n*//SYSPRIN3 DD SYSOUT=*\n         LA    R5,10(,R5)\n         BCT   R11,FOURDD\n         B     SLISTSET\n         SPACE 4\nFOURDD   EQU   *\n         CLC   6(3,R5),=X'EEEEEE'\n         BNE   LEVER10\n         LA    R5,10(,R5)\n         BCT   R11,FOURDD\n         B     SLISTSET\nLEVER10  EQU   *\n         MVC   VOLSER4,0(R5)\n         MVC   VOLSER4A,0(R5)\n         PUT   JCL,DISK4\n*//DISK4 DD UNIT=SYSALLDA,DISP=SHR,VOL=SER=######\n         PUT   JCL,TAPE4\n*//TAPE4  DD UNIT=TAPE16,DISP=(,KEEP),DSN=\n         PUT   JCL,SYSPRIN4\n*//SYSPRIN4 DD SYSOUT=*\n         LA    R5,10(,R5)\n         BCT   R11,EXECUTE\n         EJECT\nSLISTSET EQU   *\n         PUT   JCL,EXEC3\n*//*\n         PUT   JCL,EXEC2\n*//SLIST  EXEC PGM=SLIST,PARM='NOXTNT'\n         PUT   JCL,SLPRINT            DUANE 2/29/84\n*//SYSPRINT DD SYSOUT=*               DUANE 2/29/84\n         LA    R5,VOLTABLE\n         L     R11,VOLCOUNT\nSLISTP   EQU   *\n         CLC   6(3,R5),=X'EEEEEE'\n         BE    LEVER4\n         MVC   SLISTV1,0(R5)\n         MVC   SLISTV2,0(R5)\n         PUT   JCL,SLISTDD\n*//VVOLSER  DD UNIT=SYSALLDA,DISP=SHR,VOL=SER=VOLSER\nLEVER4   EQU   *\n         LA    R5,10(,R5)\n         BCT   R11,SLISTP\n*\n         CLOSE (INDCB)\n         CLOSE (JCL)\nFINIT    EQU   *\n         L     R13,SAVE+4\n         RETURN (14,12),RC=0\n         EJECT\nSAVE     DC    18F'0'\nMVCJOB   MVC   JOBLIB(0),0(R5)\nBLNKPTR  DC    A(BLNKPARM)\nBLNKPARM DC    H'0',C'  '\nVLTWDPSC DC    C'VLTWDPSC'\n         DS    0D\nDEVAREA  DC    6F'0'          AREA FOR DEVTYPE MACRO\nSERIALS  DC    C'SERIALS  '\nINTR     DC    C'DUMPJCL '\n         PRINT NOGEN\nINDCB    DCB   DDNAME=SERIALS,DSORG=PS,MACRF=(GL),EODAD=EOF\nJCL      DCB   DDNAME=DUMPJCL,DSORG=PS,MACRF=(PM),LRECL=80\nUCBPARM  DC    A(IOSSCAN)\n         DC    A(DASD20)\n         DC    X'80',AL3(UCBLOCAT)\nUCBLOCAT DC    A(0)\nDASD20   DC    X'20'   DEVICE CLASS FOR DASD\nPASSONE  DC    X'00'\n         DS    0D\nIOSSCAN  DC    25F'0'  100-BYTE UCB SCAN WORK AREA\n         SPACE 4\nJOB1   DC  CL80'//W6601150 JOB (2100,56-D),''DZEIG 0684 T'',CLASS=C,TIME\n               E=30'\nJOB3     DC    CL80'//JOBLIB DD DISP=SHR, '\nJOBLIB   EQU   JOB3+21,48\nEXEC1    DC    CL80'//A12345  EXEC PGM=FDR,PARM=A,REGION=1600K,COND=EVEX\n               N         '\nSTEPNAME EQU   EXEC1+3,5\nDISK1    DC    CL80'//DISK1 DD UNIT=SYSALLDA,DISP=SHR,VOL=SER='\nVOLSER1  EQU   DISK1+42,6\nTAPE1    DC    CL80'//TAPE1 DD UNIT=TAPE16,DISP=(,KEEP),DSN=SOFTBKUP.V1X\n               23456,LABEL=RETPD=30'\nVOLSER1A EQU   TAPE1+50,6\nTAPDSN1B EQU   TAPE1+40,8\nTAPRET1B EQU   TAPE1+69,2                DUANE 2/24/84\nDISK2    DC    CL80'//DISK2 DD UNIT=SYSALLDA,DISP=SHR,VOL=SER='\nVOLSER2  EQU   DISK2+42,6\nTAPE2    DC    CL80'//TAPE2 DD UNIT=TAPE16,DISP=(,KEEP),DSN=SOFTBKUP.V1X\n               23456,LABEL=RETPD=30'     DUANE 2/24/84\nVOLSER2A EQU   TAPE2+50,6\nTAPDSN2B EQU   TAPE2+40,8\nTAPRET2B EQU   TAPE2+69,2                DUANE 2/24/84\nDISK3    DC    CL80'//DISK3 DD UNIT=SYSALLDA,DISP=SHR,VOL=SER='\nVOLSER3  EQU   DISK3+42,6\nTAPE3    DC    CL80'//TAPE3 DD UNIT=TAPE16,DISP=(,KEEP),DSN=SOFTBKUP.V1X\n               23456,LABEL=RETPD=30'      DUANE 2/24/84\nVOLSER3A EQU   TAPE3+50,6\nTAPDSN3B EQU   TAPE3+40,8\nTAPRET3B EQU   TAPE3+69,2                 DUANE 2/24/84\nDISK4    DC    CL80'//DISK4 DD UNIT=SYSALLDA,DISP=SHR,VOL=SER='\nVOLSER4  EQU   DISK4+42,6\nTAPE4    DC    CL80'//TAPE4 DD UNIT=TAPE16,DISP=(,KEEP),DSN=SOFTBKUP.V1X\n               23456,LABEL=RETPD=30'      DUANE 2/24/84\nVOLSER4A EQU   TAPE4+50,6\nTAPDSN4B EQU   TAPE4+40,8\nTAPRET4B EQU   TAPE4+69,2                 DUANE 2/24/84\n         SPACE 6\nEXEC2    DC    CL80'//SLIST EXEC PGM=SLIST,PARM=NOXTNT,REGION=1600K,CONX\n               D=EVEN'\nEXEC3    DC    CL80'//* '\nSLPRINT  DC    CL80'//SYSPRINT DD SYSOUT=*'\nSYSPRIN1 DC    CL80'//SYSPRIN1 DD SYSOUT=*'\nSYSPRIN2 DC    CL80'//SYSPRIN2 DD SYSOUT=*'\nSYSPRIN3 DC    CL80'//SYSPRIN3 DD SYSOUT=*'\nSYSPRIN4 DC    CL80'//SYSPRIN4 DD SYSOUT=*'\nSLISTDD  DC    CL80'//V123456 DD UNIT=SYSALLDA,DISP=SHR,VOL=SER=123456'\nSLISTV1  EQU   SLISTDD+3,6\nSLISTV2  EQU   SLISTDD+44,6\nSETUP1   DC    CL80'/*SETUP        W6601150,2100-56-D,C880K,04 '\nMESSAGE1 DC    CL80'/*MESSAGE I/O CONTROL,2240,06.00,PD,WDPSC '\nMESSAGE2 DC    CL80'/*MESSAGE FDR     ,SOFTBKUP.V??????   -      -T-O-4-\n               -LIBRARY            '\nVOLSER0A EQU MESSAGE2+29,6\nTAPDSN0B EQU MESSAGE2+19,8\n         SPACE 4\nSTEP##   DC    PL3'0'\nVOLCOUNT DC    F'0'\n         LTORG\n         DS    0F\nVOLTABLE DC    2000X'EEEEEEEE'\n         PRINT OFF\n         CVT   DSECT=YES\n         IEFUCBOB\n         REGISTER  ,\n         PRINT ON\n         END\n//LKED.SYSIN DD *\n  NAME DUMPVOL(R)\n//SYSLIBRY DD DSN=WDPSC.SHARED.LOAD,DISP=SHR\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "DUMPVOL#": {"ttr": 16391, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x00\\x7f\\x00\\x88\\x00\\x7f\\x12\\x00\\x00\\x10\\x00\\x10\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf2\\xf7\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-01-07T00:00:00", "modifydate": "1988-01-07T12:00:00", "lines": 16, "newlines": 16, "modlines": 0, "user": "FILE270"}, "text": "//D0500150 JOB (2100,56-D),'DZEIG 0684 T',\n// MSGLEVEL=1,REGION=200K,CLASS=H\n//*LOGONID $DMD150\n//*PASSWORD STAN\n/*JOBPARM P=PROC03\n//JOBCAT DD DSN=SYS1.SOFTCAT,DISP=SHR\n//VOL EXEC PGM=DUMPVOL\n//STEPLIB DD DSN=WDPSC.SYSLIBRY,DISP=SHR\n//SERIALS  DD DSN=WIZRD150.DN00150.FILE(AABBCCDD),DISP=SHR\n//DUMPJCL  DD SYSOUT=(A,INTRDR)\n//S  EXEC SMP4L,RES=G29RES,LOG=,RUNIT=3350\n//SMPLOG DD DISP=SHR,SPACE=(CYL,0,RLSE)\n     LIST CDS SYS.\n//S1 EXEC SMP4L,RES=K15RES,LOG=,RUNIT=3350\n//SMPLOG DD DISP=SHR,SPACE=(CYL,0,RLSE)\n     LIST CDS SYS.\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "DYNALLC$": {"ttr": 16393, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x00\\x7f\\x00\\x88\\x00\\x7f\\x12\\x00\\x00n\\x00n\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf2\\xf7\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-01-07T00:00:00", "modifydate": "1988-01-07T12:00:00", "lines": 110, "newlines": 110, "modlines": 0, "user": "FILE270"}, "text": "1\n\n                                                         DYNALLOC.1\n                                                         08/01/84\n\n\n\n\n\n  PROGRAM:       DYNALLOC\n  AUTHOR:        Jeff Sprehn\n  AGENCY:        WDPSC\n  LANGUAGE:      Assembler\n  LOCATION:      WDPSC.SHARED.LOAD\n  FUNCTION:      Subroutine to dynamically allocate a given dataset\n                 to a given DDNAME.\n\n\n  RUN MODE: Batch or interactive\n\n\n  This  program is  a subroutine  which  dynamically allocates  the\n  following types of datasets to the DDNAME given:\n\n       .    Sequential dataset\n       .    A partitioned dataset with or without member name\n       .    A GDG  expressed with  absolute or  relative generation\n            number\n       .    A VSAM file\n\n  To call this program from COBOL, do the following:\n\n\n  1.   Place the following area in WORKING STORAGE:\n\n\n            01  DYNALLOC-I-O-AREA.\n                05  DDNAME                    PIC X(8).\n                05  DSNAME                    PIC X(44).\n\n\n\n\n1\n\n                                                         DYNALLOC.2\n                                                         08/01/84\n\n\n\n\n\n  2.   Place the following in the PROCEDURE DIVISION:\n\n\n            MOVE your ddname\n              TO DDNAME OF DYNALLOC-I-O-AREA.\n            MOVE your dataset name\n              TO DSNAME OF DYNALLOC-I-O-AREA.\n\n            CALL 'DYNALLOC' USING DYNALLOC-I-O-AREA.\n\n\n  3.   After the call, examine RETURN-CODE\n\n\n       RETURN CODE Value      Meaning\n       _________________     ________\n\n\n             0                Dynamic allocation was successful\n\n             4                Unable to free the DDNAME\n\n             8                Unsuccessful dynamic allocation\n\n            12                Dataset not catalogued\n\n            16                Invalid DSNAME given\n\n\n\n\n1\n                                                         DYNALLOC.3\n                                                         08/01/84\n\n\n\n\n\n  Example\n  _______\n\n\n  Within a COBOL  program, dynamically allocate a  VSAM file called\n  VSAMA.AGY999.TABLE.INDEX.BASE to DDNAME=TABLINDX\n\n\n       MOVE 'TABLINDX' TO DDNAME OF DYNALLOC-I-O-AREA.\n       MOVE 'VSAMA.AGY999.TABLE.INDEX.BASE'\n         TO DSNAME OF DYNALLOC-I-O-AREA.\n\n       CALL 'DYNALLOC' USING DYNALLOC-I-O-AREA.\n\n       IF RETURN-CODE = 0\n         NEXT SENTENCE\n       ELSE\n         Do error routine  (See Table of return codes)\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "DYNALLOC": {"ttr": 16396, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x00\\x7f\\x00\\x88\\x00\\x7f\\x12\\x00\\x01P\\x01P\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf2\\xf7\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-01-07T00:00:00", "modifydate": "1988-01-07T12:00:00", "lines": 336, "newlines": 336, "modlines": 0, "user": "FILE270"}, "text": "         PRINT ON,NOGEN\n         SPACE 3\n*        THIS PROGRAM IS A SUBROUTINE WHICH DYNAMICALLY ALLOCATES\n*        THE FOLLOWING TYPES OF DATASETS TO THE DDNAME GIVEN:\n*\n*            .  GOOD OLE OS SEQUENTIAL DATASET\n*            .  A PARTITIONED DATASET WITH OR WITHOUT MEMBER NAME\n*            .  A GDG EXPRESSED WITH ABSOLUTE OR RELATIVE GEN NUMBER\n*            .  A VSAM FILE\n*\n*        ALSO ALIASES OF THESE TYPES OF DATASETS ARE ACCEPTABLE\n*\n*        TO CALL THIS PROGRAM FROM COBOL, DO THE FOLLOWING:\n*\n*           1.  PLACE THE FOLLOWING AREA IN WORKING STORAGE:\n*\n*                  01  DYNALLOC-I-O-AREA.\n*                      05  DDNAME                    PIC X(8).\n*                      05  DSNAME                    PIC X(44).\n*\n*           2.  PLACE THE FOLLOWING IN THE PROCEDURE DIVISION:\n*\n*                  MOVE YOUR DDNAME\n*                    TO DDNAME OF DYNALLOC-I-O-AREA.\n*                  MOVE YOUR DATASET NAME\n*                    TO DSNAME OF DYNALLOC-I-O-AREA.\n*\n*                 CALL 'DYNALLOC' USING DYNALLOC-I-O-AREA.\n*\n*           3.  AFTER THE CALL, EXAMINE RETURN-CODE\n*\n*                 RETURN CODE VALUE      MEANING\n*                 _________________      _____________________________\n*\n*                       0                DYNAMIC ALLOC WAS SUCCESSFUL\n*\n*                       4                UNABLE TO FREE THE DDNAME\n*\n*                       8                UNSUCCESSFUL DYNAMIC ALLOC\n*\n*                      12                DATASET NOT CATALOGUED\n*\n*                      16                INVALID DSNAME GIVEN\n*\n*\n*\n*\n         EJECT\n         SPACE 3\n*\n**********************************************\n*                                            *\n*        I N I T I A L I Z A T I O N         *\n*                                            *\n**********************************************\n*\nDYNALLOC CSECT\n         SAVE  (14,12)\n         BALR  12,0\n         USING *,12\n         ST    13,SAVEAREA+4\n         LA    13,SAVEAREA\n         B     STARTIT\n         SPACE\nSAVEAREA DC    18F'0'\n         SPACE 3\n********************************************************************\n*        EQUATE RESISTERS 0 THRU 15 TO MORE MEANINGFUL NAMES       *\n********************************************************************\n         SPACE 3\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n         EJECT\n         SPACE 3\n********************************************************************\n*                                                                  *\n*        SAVE REGISTER 1 CONTENTS IN REGISTER 11 AND PLACE         *\n*        PARAMETER AREA INTO PASSAREA                              *\n*                                                                  *\n********************************************************************\n         SPACE 3\nSTARTIT  DS    0D\n         LR    R11,R1                 SAVE REG 1 CONTENTS IN REG 11\n         L     R9,0(R11)\n         MVC   PASSAREA,0(R9)\n         EJECT\n         SPACE 3\n********************************************************************\n*                                                                  *\n*        M A I N   L I N E   L O G I C                             *\n*                                                                  *\n********************************************************************\n         SPACE 3\n*\n         LA    R10,0                  R10===> 0\n*\n         MVC   BRKINDSN,INDSNAME\n         CALL  BREAKDSN,(BRKDSNIO),VL\n         CLC   BRKVALID,=CL3'YES'     DID ALL GO WELL ?\n         BE    LOKAYT                 IF SO, BRANCH TO LOKAYT\n         LA    R10,16                 R10===> 16\n         B     SHUTDOWN               BRANCH TO SHUTDOWN\nLOKAYT   LOCATE CAMLIST1              SEARCH ZEE CATALOG\n         C     R15,=F'0'              IS THE DSNAME IN THE CATALOG?\n         BE    DOCALC                 IF SO, BRANCH TO DOCALC\n         LA    R10,12                 R10===> 12\n         B     SHUTDOWN               BRANCH TO SHUTDOWN\nDOCALC   BAL   R5,CALCLENS            PERFORM ROUTINE TO CALCULATE\n*                                       DSNAME AND DDNAME LENGTHS\n         BAL   R5,DYNAMALC            PERFORM DYNAMIC ALLOCATION\n         B     SHUTDOWN               BRANCH TO SHUTDOWN\n         EJECT\n         SPACE 3\n*\n********************************************************************\n*                                                                  *\n*  THIS ROUTINE IS RESPONSIBLE FOR GENERATING THE FOLLOWING        *\n*  DATA FIELDS:                                                    *\n*                                                                  *\n*     DDNLEN  ===> BINARY LENGTH OF DDNAME                         *\n*     DSNLEN  ===> BINARY LENGTH OF DSNAME                         *\n*     MEMLEN  ===> BINARY LENGTH OF MEMBER NAME (IF PROVIDED)      *\n*                                                                  *\n********************************************************************\n*\nCALCLENS ST    R5,SAVEIT1\n         LA    R6,8\n         LA    R7,INDDNAME+7\nLOOP1    CLI   0(R7),C' '\n         BNE   MOVEIT1\n         S     R6,=F'1'\n         S     R7,=F'1'\n         B     LOOP1\nMOVEIT1  STH   R6,DDNLEN\n         LA    R6,44\n         LA    R7,BRKOTDSN+43\nLOOP2    CLI   0(R7),C' '\n         BNE   MOVEIT2\n         S     R6,=F'1'\n         S     R7,=F'1'\n         B     LOOP2\nMOVEIT2  STH   R6,DSNLEN\n         CLC   BRKMEMPR,=CL3'YES'\n         BNE   EXITCALC\n         LA    R6,8\n         LA    R7,BRKOTMEM+7\nLOOP3    CLI   0(R7),C' '\n         BNE   MOVEIT3\n         S     R6,=F'1'\n         S     R7,=F'1'\n         B     LOOP3\nMOVEIT3  STH   R6,MEMLEN\nEXITCALC L     R5,SAVEIT1            RESTORE REGISTER 5\n         BR    R5                    RETURN\n         EJECT\n         SPACE 3\n*\n********************************************************************\n*                                                                  *\n*               D Y N A M I C   A L L O C A T I O N                *\n*               -----------------------------------                *\n*                                                                  *\n*        THIS ROUTINE FIRST ATTEMPTS TO FREE THE DDNAME GIVEN.     *\n*        IF THE DDNAME WAS SUCCESSFULLY FREED, THEN THIS ROUTINE   *\n*        BRANCHES TO THE DYNAMIC ALLOCATION MACRO DYNALLOC.        *\n*        HOWEVER, IF THE DDNAME  WAS NOT SUCCESSFULLY FREED,       *\n*        THEN THIS ROUTINE CHECKS FOR ERROR REASON CODE 0438       *\n*        (DDNAME NOT FOUND).  IF THE ERROR REASON CODE IS 0438,    *\n*        THEN THIS ROUTINE BRANCHES TO THE DYNAMIC ALLOCATION      *\n*        MACRO DYNALLOC, ELSE IT LOADS R10 WITH A 4.               *\n*                                                                  *\n********************************************************************\n*\nDYNAMALC ST    R5,SAVEIT2\n*\n         MVC   FREEUT1A,DDNLEN\n         MVC   FREEUT1B,INDDNAME\n         MVC   DD1UNT1A,DDNLEN\n         MVC   DD1UNT1B,INDDNAME\n         MVC   DD1UNT2A,DSNLEN\n         MVC   DD1UNT2B,BRKOTDSN\n         MVC   DD1UNIT3,=XL2'0000'\n         CLC   BRKMEMPR,=CL3'YES'\n         BNE   FREEIT\n         MVC   DD1UNIT3,=XL2'0003'\n         MVC   DD1UNT3A,=XL2'0001'\n         MVC   DD1UNT3B,MEMLEN\n         MVC   DD1UNT3C,BRKOTMEM\n*\nFREEIT   LA    R1,FREEPARM\n         DYNALLOC                      FREE DDNAME\n         LTR   R15,R15                 TEST REGISTER 15 FOR ZERO\n         BZ    DODYNAM                 IF ZERO, BRANCH TO DODYNAM\n         CLC   ERCODE,HEX0438          COMPARE ERROR REASON CODE\n*                                         AGAINST HEXADECIMAL 0438\n         BE    DODYNAM                 IF EQUAL, BRANCH TO DODYNAM\n         LA    R10,4                   R10===> 4\n         L     R5,SAVEIT2\n         BR    R5                      RETURN\nDODYNAM  LA    R1,DD1PARM\n         DYNALLOC                      ALLOC F(DDNAME) DA(DSN) SHR\n         L     R5,SAVEIT2\n         LTR   R15,R15                 TEST REGISTER 15 FOR ZERO\n         BZR   R5                      IF ZERO, RETURN\n         LA    R10,8                   R10===> 8\n         BR    R5                      RETURN\n         EJECT\n         SPACE 3\n********************************************************************\n*                                                                  *\n*        E N D   O F   J O B   P R O C E S S I N G                 *\n*                                                                  *\n********************************************************************\n         SPACE 3\nSHUTDOWN LR    R15,R10\n         L     R13,4(R13)\n         RETURN (14,12),RC=(15)\n         EJECT\n         SPACE 3\n*\n********************************************************************\n*                                                                  *\n*        DATA STRUCTURE FOR FREEING OF DDNAME                      *\n*                                                                  *\n********************************************************************\n*\n         SPACE 3\n         DS    0F\nFREEPARM DC    X'80'         TURN ON HIGH ORDER BIT\n         DC    AL3(FREERB)   ADDRESS OF REQUEST BLOCK\nFREERB   DC    X'14'         S99RBLN (LENGTH OF REQUEST BLOCK)\n         DC    X'02'         S99VERB (REQUEST FOR UNALLOCATION)\n         DC    X'2000'       S99FLAG1 (DO NOT MOUNT VOLUMES)\nERCODE   DC    X'0000'       S99ERROR (ERROR REASON CODE)\n         DC    X'0000'       S99INFO (INFORMATION REASON CODE)\n         DC    A(FREETUPL)   S99TXTPP (ADDR OF POINTER TO TEXT UNIT)\n         DC    X'00000000'   RESERVED\n         DC    X'00000000'   S99FLAG2\nFREETUPL DC    A(FREEUNT1)   ADDRESS OF TEXT UNIT #1\n         DC    X'80'         TURN ON HIGH ORDER BIT\n         DC    AL3(FREEUNT2) ADDRESS OF TEXT UNIT#2\nFREEUNT1 DC    X'0001'\n         DC    X'0001'\nFREEUT1A DS    BL2\nFREEUT1B DS    CL8\nFREEUNT2 DC    X'0007'\n         DC    X'0000'\n         EJECT\n         SPACE 3\n*\n********************************************************************\n*                                                                  *\n*        DATA STRUCTURE FOR DYNAMIC ALLOCATION                     *\n*                                                                  *\n********************************************************************\n*\n         SPACE 3\n         DS    0F\nDD1PARM  DC    X'80'         TURN ON HIGH ORDER BIT\n         DC    AL3(DD1RB)    ADDRESS OF REQUEST BLOCK\nDD1RB    DC    X'14'         S99RBLN (LENGTH OF REQUEST BLOCK)\n         DC    X'01'         S99VERB (REQUEST FOR DSNAME ALLOC)\n         DC    X'2000'       S99FLAG1 (DO NOT MOUNT VOLUMES)\n         DC    X'0000'       S99ERROR (ERROR REASON CODE)\n         DC    X'0000'       S99INFO (INFORMATION REASON CODE)\n         DC    A(DD1TUPL)    S99TXTPP (ADDR OF POINTERS TO TEXT UNITS\n         DC    X'00000000'   RESERVED\n         DC    X'00000000'   S99FLAG2\nDD1TUPL  DC    A(DD1UNIT1)   ADDRESS OF TEXT UNIT #1\n         DC    A(DD1UNIT2)   ADDRESS OF TEXT UNIT #2\n         DC    A(DD1UNIT3)   ADDRESS OF TEXT UNIT #3\n         DC    A(DD1UNIT4)   ADDRESS OF TEXT UNIT #4\n         DC    X'80'         TURN ON HIGH ORDER BIT\n         DC    AL3(DD1UNIT5) ADDRESS OF TEXT UNIT #5\nDD1UNIT1 DC    X'0001'       DDNAME TEXT UNIT\n         DC    X'0001'\nDD1UNT1A DS    BL2\nDD1UNT1B DS    CL8\nDD1UNIT2 DC    X'0002'       DSNAME TEXT UNIT\n         DC    X'0001'\nDD1UNT2A DS    BL2\nDD1UNT2B DS    CL44\nDD1UNIT3 DS    XL2           MEMBER NAME TEXT UNIT\nDD1UNT3A DS    XL2\nDD1UNT3B DS    BL2\nDD1UNT3C DS    CL8\nDD1UNIT4 DC    X'0004',X'0001',X'0001',X'08'\nDD1UNIT5 DC    X'0052'\n         DC    X'0000'\n         EJECT\n         SPACE 3\n********************************************************************\n*        DATA AREAS                                                *\n********************************************************************\n         SPACE 3\n         DS    0F\nSAVEIT1  DS    F\nSAVEIT2  DS    F\nDDNLEN   DS    H\nDSNLEN   DS    H\nMEMLEN   DS    H\n*\nPASSAREA DS    0CL52\nINDDNAME DS    CL8\nINDSNAME DS    CL44\n*\n*   B R E A K D S N   P A R A M E T E R S\n*\nBRKDSNIO DS    0CL135\nBRKINDSN DS    CL44\nBRKOTDSN DS    CL44\nBRKOTMEM DS    CL8\nBRKMEMPR DS    CL3\nBRKGDG   DS    CL3\nBRKVALID DS    CL3\nBRKERROR DS    CL30\n*\nCAMLIST1 CAMLST NAME,BRKOTDSN,,LOCAREA\nLOCAREA  DS    0D\n         DS    265C\nHEX0438  DC    X'0438'\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "EDIT$": {"ttr": 16645, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x00\\x7f\\x00\\x88\\x00\\x7f\\x12\\x00\\x00?\\x00?\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf2\\xf7\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-01-07T00:00:00", "modifydate": "1988-01-07T12:00:00", "lines": 63, "newlines": 63, "modlines": 0, "user": "FILE270"}, "text": "  This member is an attempt to document or at least list the\npieces of the \"better edit\" system used here at WA St. DIS.\nThis system has been requested often by people who visited or\nworked at DIS for a while then moved on to another installation.\nUnfortunately, no one knows quite what all of the pieces are\nsince this was an evolved set of systems which made use of a lot\nof the mods already installed here. I have finally attempted to\ntrack down the various pieces and make sure they are all on our\nWASHMODS tape. Please let me know if you find any pieces missing\nand I will try to find them.\n  This system or set of systems represents several years of work\nto implement the object-action oriented mode of user interface,\neven before IBM was talking about SAA components. We first developed\nthe original \"Better Edit\" system, now known as EDITNEW, because\nafter using ISPF/PDF for a short time, any regular user knows what\nthe edit function does; He just has trouble remembering what datasets\nhe is currently working with. EDITNEW offered a screen which\nremembered 17 dataset names (best we could do with 24 line screens)\nfor the user to select from for editing. This was fine, but many of\nus worked on multiple systems at once and need more datasets with\nsegregation by system (application). EDITAPP was created to add\nanother level of selection with 17 applications, each then having\n17 datasets remembered in the profile. Many enhancements were added\nover time, such as different EDIT select panels which supported\nvolsers for software groups, up and down scrolling between\napplications and various member search options, eventually even the\nFLIST function of HOTKEYS.\n  The needs of the customers varied from the staff needs, however,\nso the technical people supporting them created an edit system\nwhich is completely different and far more comprehensive, replacing\nalmost all of the ISPF/PDF functions with object-action interface\nand adding many extensions such as VSAM browse/edit. This system is\ncalled the \"Edit Workbench\" and is used extensively by our customers\nand development staff. I do not know how it works, but I think it uses\na lot of command table, panel exit, and SUPERKEYS facilities to give\nfast access to various functions. It has scrollable access to many\ndataset names and user defined functions. I am making no attempt to\nadd this variety of EDIT to the tape at this time. Perhaps later.\n\n  Here are the components so far identified for the EDITNEW and EDITAPP\nsystems:\nPANELS:\n       ISR@PRIM - selects optional user edit clist\n       SPFEOPT - allows user to specify type of edit (and other opts)\n       MULTEDIT,MULTSOFT - default and special edit panels\n       EDITAPP - application selection panel.\n       SPFYFND2,FNDSMEM - search panels\nCLISTS:\n       EDITAPP - starts multi-application interface\n       EDITNEW - starts multi-dataset interface\n       SPFEOPT - sets user options from panel\n       FNDSMEM,SPFYFND - special search functions\nSOURCE:\n       DPSCEDT6 - last version of better edit dialog (COBOL)\n       PANLEXIT - FLIST interface (note SPFEXEC is real pgm name)\n       SCAN4HIT,BREAKDSN,FILEATTR,FINDMEM - subroutines for DPSCEDT6\n       DEVTYPE,STACK,FINDEM,SPFYFND5 - search subroutines\nLOADMODS:\n       PANLEXIT,DPSCEDT6,FINDEM,SPFYFND5,DEVTYPE,STACK\nTABLES:\n       ISPCMDS\nMESSAGES:\n       TRIK10,WDED10,FNDS10,SPFY10\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ENQ1DSN": {"ttr": 16647, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x00\\x7f\\x00\\x88\\x00\\x7f\\x12\\x00\\x02=\\x02=\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf2\\xf7\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-01-07T00:00:00", "modifydate": "1988-01-07T12:00:00", "lines": 573, "newlines": 573, "modlines": 0, "user": "FILE270"}, "text": "//DNE00150 JOB (2100,56-D),'DPARS 0682 T',CLASS=H MSGCLASS=T\n//*\n//* FROM WIZRD150.DN00150.FILE(ENQ1DSN)\n//L EXEC ASMHCL,OPTION1='TERM,RENT,TEST',LIBRARY='WDPSC.CMDLIB',\n//   OPTION2='RENT,TEST',LNDSP=SHR\n TITLE 'DISPLAY DATA SET NAME ENQUEUE'\n* DENQ TEXT ORIGINALLY FROM CBT MVS MODIFICATION TAPE VIA SHARE.\n* DO NOT LOSE THIS BECAUSE IT IS NOT ON TAPE ANY MORE.\n* 05/24/82 MODIFIED FOR SP 1.3 WHICH MOVED THE ENQ TABLES TO ANOTHER\n* ADDRESS SPACE CONNECTION IS NOW MADE WITH THE GQSCAN MACRO\nDSNQ     CSECT\n***********************************************************************\n*\n*        OPERATOR COMMAND TO DISPLAY JOBNAMES,USERIDS IN ENQ CHAIN\n*\n*        ON ENTRY:\n*                 R2  = ADDRESS OF DSXSA (EXTENDED SAVE AREA)\n*                 R15 = ADDRESS OF ENTRY POINT\n*\n*        COMMAND FORMAT:\n*\n*              DENQ  \"MAJOR\"/\"MINOR\"\n*\n*        WHERE:\n*              MAJOR = MAJOR QCB NAME, MAX 8 BYTES\n*              MINOR = MINOR QCB NAME, MAX 255 BYTES\n*\n*        MINOR MAY ALSO BE GIVEN AS:\n*              1) *   - OBTAIN ALL MINOR NAMES FOR GIVEN MAJOR NAME\n*              2) XY* - OBTAIN ALL MINOR NAMES BEGINNING WITH XY;\n*                       XY = ANY COMBINATION AND SIZE OF CHARACTERS\n*\n*        IF MAJOR IS GIVEN AS * , ONLY MAJOR QCB NAMES ARE PRINTED\n*\n*        CSECT  NAME: DSNQ\n*        MODULE NAME: DSNQ\n*        ATTRIBUTES : REENTRANT,REUSABLE\n*\n*        AUTHOR      : ALAN M. WOOLF\n*        DATE        : NOVEMBER 9, 1971\n*        INSTALLATION: SIKORSKY AIRCRAFT, DIV. OF UNITED AIRCRAFT CORP.\n*\n***********************************************************************\n         B     14(0,R15)          BRANCH AROUND ID\n         DC    AL1(8)\n         DC    CL8'DSNQ '         IDENTIFIER\n         LR    R12,R15            SET ADDRESSABILITY\n         LR    R2,R1\n         USING DSNQ,R12\n         LA    R0,LWKDSECT\n         GETMAIN R,LV=(0)\n         XC    0(256,R1),0(R1)    ZERO-OUT WORK AREA\n         XC    256(LWKDSECT-256,R1),256(R1)\n         LR    R13,R1\n         USING WKDSECT,R13        FIRST 18 WRDS ARE SAVE-AREA\n         ST    R14,SAVA           PUT RETURN ADDRESS IN UNUSED SLOT\n         STH   R0,WKSIZE          SAVE SIZE\n         EJECT\n***********************************************************************\n*\n*        GET CORE FOR WORK TABLE\n*\n***********************************************************************\n         L     R0,CORSIZ\n         STH   R0,CORESIZE\n         GETMAIN R,LV=(0)\n         LA    R1,0(R1)\n         ST    R1,CORE\n         SPACE 2\n         L     R0,CORSIZ\n         GETMAIN R,LV=(0)\n         ST    R1,GQSTUFF\n***********************************************************************\n*\n*        PARSE INPUT STRING\n*\n***********************************************************************\n         MVI   MAJNAM,C' '\n         MVC   MAJNAM+1(256),MAJNAM    CLEAR MAJOR/MINOR NAME FIELDS\n         MVC   MAJNAM+257(6),MAJNAM+256\n         MVC   MAJNAM(8),=CL8'SYSDSN'   SET MAJOR NAME\n         L     R3,0(R2)\n         OI    4(R3),X'40'\n         CLI   4(R3),C'D'\n         BNE   CHCKN\n         LA    R3,9(R3)\n         B     PARSEIT\nCHCKN    EQU   *\n         CLI   4(R3),C'N'\n         BNE   MUSTBEC\n         LA    R3,6(R3)\n         B     PARSEIT\nMUSTBEC  EQU   *\n         LA    R3,11(R3)\nPARSEIT  EQU   *\n         LR    R8,R3\n         SR    R4,R4              LENGTH COUNTER\n         LA    R5,9\nLOOP1    EQU   *\n         CLI   0(3),X'40'\n         BNE  LOOP2\n         LA    R3,1(,R3)\n         B     LOOP1\nLOOP2    CLI   0(R3),C'/'         MAJOR/MINOR DELIMITER ?\n         BE    PARMERR            YES...NO MINOR NAME GIVEN. 8\n         MVC   MAJLGTH,=H'5'\n         SR    R4,R4              RESET LENGTH COUNTER\n         LR    R8,R3              SAVE START OF MINOR NAME\n         LA    R5,44              MAX LENGTH OF MINOR NAME\nLOOP3    CLI   0(R3),C' '         END-OF-STRING\n         BE    GOTMINOR           YES...\n         LA    R3,1(,R3)          INCREMENT PTR\n         LA    R4,1(,R4)          INCREMENT LENGTH\n         BCT   R5,LOOP3\n         B     BADERR             MINOR NAME TOO LONG\nGOTMINOR BCTR  R4,0\n         LA    R6,MINNAME         WHERE TO GO IN EXECUTE\n         EX    R4,MVNAM           GET MINOR NAME\n         OC    MINNAME(255),HEX40S\n         LA    R4,1(,R4)          RESET LENGTH\n         STH   R4,MINLGTH         SAVE LENGTH\n***********************************************************************\n*\n*        SCAN FOR '*' IN MINOR NAME\n*\n***********************************************************************\n         LA    R3,MINNAME\n         SR    R4,R4              COUNT OF CHAR PRIOR TO '*'\n         LH    R5,MINLGTH\nLOOP4    CLI   0(R3),C'*'         FIND IT ?\n         BE    ASK                YES...\n         LA    R3,1(,R3)          NO..NEXT CHAR\n         LA    R4,1(,R4)          INCREMENT COUNT\n         BCT   R5,LOOP4\n         B     NOASK              NO '*' IN MINOR NAME\nASK      LTR   R4,R4              ANY CHAR PRIOR TO '*' ?\n         BZ    ALLMINOR           NO..GET ALL MINOR NAMES\n         MVI   SWTCH,X'0F'        YES..PARTIAL MINOR NAME GIVEN\n         STH   R4,MINLGTH         SET NEW LENGTH\n         B     NOASK              JOIN COMMON CODE\nALLMINOR MVI   SWTCH,X'F0'        SET FOR ALL MINOR NAMES\n***********************************************************************\n*\n*        OBTAIN FIRST MAJOR QCB\n*\n***********************************************************************\nNOASK    EQU   *\n         L     R5,X'10'           CVT PTR\nCHKQCB   EQU   *\n         ICM   R2,15,640(R5)      DOES FIRST VALID MAJOR QCB\n         BNZ   PRESP13            NO, SYSTEM IS PROBABLY SP1.3 OR ABOVE\n  TITLE ' RIB/RIBE SEARCH  IN AN SP 1.3 ENVIRONMENT'\n         LA    R4,MAJNAM           MAJOR NAME ADDRESS\n         TM    SWTCH,X'FF'         WAS AN ASTERISK PRESENT IN COMMAND\n         BZ    SASTRIK NO\n         SR    R5,R5\n         SR    R6,R6\n         B     SMINORGO\nSASTRIK  EQU   *\n         LA    R5,MINNAME       MINOR NAME ADDRESS\n         LH    R6,MINLGTH       MINOR NAME LENGTH\nSMINORGO EQU   *\n         STM   R4,R6,GQSTUFF+4\n         MVC   GQSTUFF+18(4),CORESIZE\n         L     R8,CORE\n         ST    R8,GQCORE LOCATION OF MESSAGE TABLE\n         SR    R8,R8\n         ST    R8,GQENTCT NUMBER OF USED ENTRIES IN TABLE\n         XC    GQTOKEN,GQTOKEN\n         SPACE 4\nSGUN     EQU   *\n         LM    R3,R7,GQSTUFF\n         LA    R2,GQTOKEN\n         SPACE 1\n         MVC   BUFFER(GQSCANLL),GQSCANL\n         GQSCAN AREA=((R3),(R7)),SCOPE=ALL,RESNAME=((R4),(R5),(R6)),  XX\n               TOKEN=(R2),MF=(E,BUFFER)\n         B     STABLE(R15)\nSTABLE   B     SSCANQ\n         B     NOOUTPUT\n         B     SSCANQ\n         B     QELERR\n         B     QELERR\n         SPACE 4\nSSCANQ   EQU   *\n         L     R3,GQSTUFF\n         STM   R15,R1,GQRETURN      STORE RETURN CODES\n         L     R2,GQENTCT           CURRENT NUMBER OF TABLE ENTRIES\n         L     R4,GQCORE            TABLE FOR RESOURCES\nSRIBALL  LR    R7,R3                 ADDRESS OF RIB\n         AH    R7,GQRIBLN           LENGTH OF RIB FIXED AREA\n         USING RIB,R3\n         USING RIBVAR,R7\n         USING RIBE,R10\n         SR    R9,R9\n         IC    R9,RIBRNMLN          LENGTH OF RNAME\n         TM    SWTCH,X'F0'          ALL MINOR NAMES\n         BO    SCMPNAME\n         TM    SWTCH,X'0F'          MINOR NAMES BEGINNING WITH\n         BO    SCKLGTH\n         CH    R9,MINLGTH           ARE LENGTHS EQUAL\n         BNE   SNXTRIB\nSCKLGTH  LH    R8,MINLGTH           COMPARISON LENGTH\n         BCTR  R8,0\n         EX    R8,CLCRNAME          CLC MINNAME(0),RIBRNAME\n         BNE   SNXTRIB\nSCMPNAME EQU   *\n         STC   R9,1(,R4)            PUT NAME LENGTH IN TABLE\n         LA    R9,2(,R9)            INCREASE FOR CONTROL BYTES\n         SR    R8,R8\n         D     R8,=F'9'\n         LTR   R8,R8                ANY REMAINDER?\n         BZ    SFILLOUT      L9     NO...\n         LA    R9,1(,R9)            YES,   ROUND UP\nSFILLOUT STC   R9,0(,R4)            PUT NO. OF TABLE ENTRIES IN TABLE\n         AR    R2,R9                INCREMENT NO. OF ENTRIES\n         C     R2,=F'1000'          OVERFLOW TABLE\n         BH    STBOFL2\n         IC    R9,RIBRNMLN          RETURN LENGTH TO ORIGINAL - 1\n         BCTR  R9,0\n         EX    R9,MVCRNAME          MOVE MINOR NAME TO TABLE\n         LH    R9,RIBVLEN\n         LA    R10,0(R9,R7)         LOCATION OF RIBE\n         SR    R8,R8\n         IC    R9,0(,R4)            NUMBER OF ENTRIES\n         M     R8,=F'9'\n         AR    R4,R9                POINT TO NEXT SLOT\n         L     R8,RIBNRIBE          NUMBER OF RIBE'S RETURNED\nSRIBE    EQU   *\n         MVC   0(8,R4),RIBEJBNM     JOBNAME OF RESOURCE USER\n         MVI   8(R4),C'S'           ASSUME SHARED ENQUEUE\n         TM    RIBERFLG,RIBERESV    RESERVE  REQUEST\n         BZ    SRIBECK1 NO\n         MVI   8(R4),C'R'           INDICATE RESERVE\nSRIBECK1 TM    RIBERFLG,RIBETYPE    SHARED  REQUEST?\n         BO    SRIBECK2\n         MVI   8(R4),C'E'\n         TM    RIBERFLG,RIBERESV    RESERVE REQUEST\n         BZ    SRIBECK2\n         MVI   8(R4),C'X'           EXCLUSIVE RESERVE\nSRIBECK2 EQU   *\n         MVI   SWTCH+1,X'F0'        FLAG MINORS FOUND\n         LA    R2,1(,R2)            INCREMENT ENTRY NUMBER\n         LA    R4,9(,R4)            INCREMENT TABLE LOCATION\n         C     R2,=F'1000'          TOO MANY ENTRIES\n         BH    STBOVFL\n         AH    R10,GQRIBELN         ADD LENGTH OF RIBE\n         BCT   R8,SRIBE             BRANCH WHEN RESULT IS ZERO\n         SPACE 1\nSNXTRIB  L     R8,GQRIBNUM          NUMBER OF RIB'S RETURNED\n         S     R8,=F'1'      REDUCE BY ONE\n         BZ    SNXTSCAN      BRANCH WHEN RESULT IS ZERO\n         ST    R8,GQRIBNUM\n         L     R8,RIBNRIBE      NUMBER OF RIBE'S\n         MH    R8,GQRIBELN      LENGTH OF RIBE FIXED\n         AH    R3,RIBVLEN       LENGTH OF RIBE VARIABLE (MULT OF 4)\n         AH    R3,GQRIBLN       LENGTH OF RIB  FIXED\n         AR    R3,R8            NEXT RIB\n         B     SRIBALL\n         SPACE 2\n*********************************************************************\n*\n*   CHECK FOR MORE RIB POSSIBILITIES AND RETURN TO GQSCAN IF\n*   NECESSARY\n*********************************************************************\nSNXTSCAN EQU   *\n         ICM   R3,15,GQTOKEN\n         BZ    SLEAVE\n         ST    R4,GQCORE          CURRENT LOCATION IN MESSAGE TABLE\n         ST    R2,GQENTCT         COUNT OF ENTRIES USED\n         B     SGUN\n         SPACE 1\nSTBOFL2  SR    R2,R9              REDUCE NUMBER OF USED ENTRIES\nSTBOVFL  LA    R1,32              SET RETURN CODE VALUE\n         LR    R3,R2              PLACE NUMBER OF ENTRIES\n         B     SETSIZE\n         SPACE 2\nSLEAVE   LR    R3,R2   AGREE TO PRE SP1.3 CODE\n         B     EXITOK\n         PRINT OFF\n  TITLE ' CODE FOR QCB/QEL SEARCH PRIOR TO SP 1.3'\nPRESP13  EQU   *\n         SPIE  SPIEXIT,(4)        SPIE 0C4'S\n***********************************************************************\n*\n*        SSM   *+1                DISABLE ALL INTERRUPTS\n*\n***********************************************************************\n         SR    R3,R3              CURRENT NUMBER OF TABLE ENTRIES\n         LA    R5,1000            MAX NUMBER OF ENTRIES\n         L     R4,CORE            START OF FREE CORE TABLE\n***********************************************************************\n*\n*        FIND REQUESTED MAJOR NAME QCB\n*\n***********************************************************************\nLOOP5    CLC   16(8,R2),MAJNAM    MAJOR NAMES MATCH ?\n         BE    LOOKMIN            YES...FIND MINOR NAMES\n         L     R2,0(,R2)          NEXT MAJOR QCB\n         LTR   R2,R2              END-OF-LIST ?\n         BNZ   LOOP5              NO...TRY NEXT QCB\n         B     NOMAJNAM           SET ERROR CODE\n         EJECT\n***********************************************************************\n*\n*        MAJOR QCB FOUND, LOOK FOR MINOR QCB(S)\n*\n***********************************************************************\nLOOKMIN  L     R7,8(,R2)          FIRST MINOR QCB\n         LTR   R7,R7              EXIST ?\n         BNZ   MINOROK            YES...SHOULDN'T FALL THRU\n         B     QCBERR             SET ERROR CODE\nMINOROK  TM    SWTCH,X'F0'        ALL MINOR NAMES ?\n         BZ    CHKMIN             NO...\nCHKQEL   SR    R9,R9\n         IC    R9,16(R7)          LENGTH OF MINOR QCB NAME\n         CH    R9,=H'44'          GTR 44 BYTES ?\n         BNH   LGTHOK             NO...USE AS IS\n         LA    R9,44              YES..RESET TO 44 AND TRUNCATE NAME\nLGTHOK   STC   R9,1(,R4)          PUT NAME LENGTH IN TABLE\n         LA    R9,2(,R9)          INCREASE FOR FOLLOWING COMPUTATIONS\n         SR    R10,R10\n         LR    R11,R9             LENGTH OF MINOR NAME+CONTROL BYTES\n         D     R10,=F'9'          MULTIPLE OF 9 ?\n         LTR   R10,R10            ANY REMAINDER ?\n         BZ    L9                 NO...\n         LA    R11,1(,R11)        YES...ROUND UP\nL9       STC   R11,0(,R4)         PUT NO. OF TABLE ENTRIES IN TABLE\n         CLI   20(R7),C'$'        VALID MINOR NAME\n         BL    UNKNOWN            NO, UNKNOWN\n         CLI   20(R7),C'9'        VALID MINOR NAME\n         BH    UNKNOWN            NO, UNKNOWN\n         AR    R3,R11             INCREMENT NO. OF ENTRIES\n         CR    R3,R5              OVERFLOW TABLE ?\n         BH    TABLOFL2           HOPEFULLY NOT.\n         BCTR  R9,0               REDUCE LENGTH\n         BCTR  R9,0               TO ORIGINAL AND THEN\n         BCTR  R9,0               SET FOR EXECUTE INST\n         EX    R9,QCBNAME         GET MINOR QCB NAME\n*                                 NO. OF TABLE SLOTS TAKEN BY NAME\nUNKBACK  SR    R10,R10            MULTIPLIED BY 9 BYTES/SLOT\n         M     R10,=F'9'          EQUALS TOTAL LENGTH TAKEN\n         AR    R4,R11             ADDED TO SLOT POINTER\n         L     R8,8(,R7)          FIRST QEL\n         LTR   R8,R8              EXIST ?\n         BNZ   QELOK              YES...SHOULDN'T FALL THRU\n         B     QELERR             SET ERROR CODE\n         EJECT\nQELOK    SR    R14,R14            INSERT\n         IC    R14,14(0,R8)          ASID\n         SLL   R14,8                    INTO REG 14\n         IC    R14,15(0,R8)                AND MULTIPLY\n         SLL   R14,2                          BY FOUR\n         L     R15,16             CVT ADDR\n         L     R15,556(0,R15)     ASVT ADDR\n         L     R15,524(R14,R15)   ASCB ADDR\n         L     R14,56(0,R15)      CSCB ADDR\n         CLI   28(R14),X'03'      INIT CSCB\n         BE    QELOKJOB           YES, GO HANDLE\nQELOKBAK LA    R14,0(0,R14)       CLEAR HIGH ORDER\n         LTR   R14,R14            CSCB ZERO\n         BZ    QELOKAS            YES, GO PRINT ASID\n         MVC   0(8,R4),8(R14)     JOBNAME\n         B     QELOKBK\nQELOKAS  MVC   0(4,R4),=CL4'AS= ' ADDRESS SPACE\n         UNPK  4(5,R4),14(3,R8)   UNPK ASID\n         MVI   8(R4),C' '         BLANK EXTRA CHAR\n         NC    4(4,R4),=4X'0F'    TRANSLATE TO PRINT\n         TR    4(4,R4),=C'0123456789ABCDEF'\nQELOKBK  MVI   8(R4),C'S'         ASSUME SHR'D ENQ\n         TM    12(R8),X'10'       RESERVE\n         BZ    QELOKBKX           NO, BR AROUND\n         MVI   8(R4),C'R'         IND SHR RESERVE\nQELOKBKX TM    12(R8),X'80'       IS IT SHR'D ?\n         BO    NEXTONE            YES...\n         MVI   8(R4),C'E'         NO...MUST BE EXCLUSIVE\n         TM    12(R8),X'10'       RESERVE\n         BZ    NEXTONE\n         MVI   8(R4),C'X'         IND EXCL RESERVE\nNEXTONE  LA    R3,1(,R3)          INCREMENT ENTRY NUMBER\n         LA    R4,9(,R4)          INCREMENT TABLE LOCATION\n         CR    R3,R5              TOO MANY ENTRIES IN TABLE ?\n         BH    TABLOVFL           YES...IGNORE REMAINDER\n         MVI   SWTCH+1,X'F0'      FLAG MINORS FOUND\nNEXTQEL  L     R8,0(,R8)          NEXT QEL\n         LA    R8,0(,R8)          CLEAR HI-BYTE\n         LTR   R8,R8              QEL EXIST ?\n         BNZ   QELOK              YES.\n         B     NEXTMIN            NO...GET NEXT MINOR QCB\nCHKMIN   SR    R8,R8\n         IC    R8,16(,R7)         LENGTH OF MINOR NAME\n         TM    SWTCH,X'0F'        ALL NAMES STARTING WITH GIVEN ?\n         BO    ALL                YES.\n         CH    R8,MINLGTH         MINOR NAME LENGTHS AGREE ?\n         BNE   NEXTMIN            NO...TRY ANOTHER MINOR QCB\nCOMP     BCTR  R8,0               LENGTHS AGREE..BUT DO NAMES ?\n         EX    R8,COMPMINR        FIND OUT.\n         BE    CHKQEL             YES..GET OWNER'S JOBNAME/USERID\nNEXTMIN  L     R7,0(,R7)          NEXT MINOR QCB\n         LTR   R7,R7              EXIST ?\n         BZ    EXITOK             NO..OUTPUT DATA\n         TM    SWTCH,X'F0'        DOING ALL MINOR QCB'S ?\n         BO    CHKQEL             YES...\n         B     CHKMIN             NO..TRY THIS MINOR QCB.\nALL      LH    R8,MINLGTH         LENGTH OF MINOR NAME TO START WITH\n         B     COMP               JOIN COMMON CODE\n        EJECT\nQELOKJOB LR    R15,R14            CSCB ADDR\n         SR    R1,R1              INSERT\n         IC    R1,14(0,R8)           ASID\n         SLL   R1,8                     INTO REG 1\n         IC    R1,15(0,R8)\nQELOKJB1 L     R14,0(0,R14)       NEXT CSCB\n         CR    R14,R15            SAME CSCB\n         BE    QELOKBAK           YES, INIT\n         CH    R1,30(0,R14)       ASID MATCH\n         BNE   QELOKJB1           NO, CHECK NEXT\n         B     QELOKBAK           GO USE CSCB\n         SPACE 4\n         SPACE 3\nSPIEXIT  MVC   8(4,R1),=A(SPIERTRY)  RETRY RTN ADDR\n         BR    R14                RETURN\n         SPACE 2\nSPIERTRY SPIE  SPIEXIT,(4)        SPIE 0C4'S\n         B     QELOK              GO PRINT ASID\n         SPACE 3\nUNKNOWN  MVC   2(7,R4),=CL7'UNKNOWN'\n         MVI   1(R4),X'07'        SET MINOR NAME LENGTH\n         MVI   0(R4),X'09'        SET NO. OF TABLE ENTRIES\n         LA    R11,9              LOAD ADJUSTED LENGTH\n         AR    R3,R11             INCREMENT NO. OF ENTRIES\n         CR    R3,R5              OVERFLOW TABLE ?\n         BH    TABLOFL2           HOPEFULLY NOT.\n         BCTR  R9,0               REDUCE LENGTH\n         BCTR  R9,0               TO ORIGINAL AND THEN\n         BCTR  R9,0               SET FOR EXECUTE INST\n         B     UNKBACK\n         PRINT ON\n         TITLE  'DISPLAY DATA SET ENQUEUE'\n***********************************************************************\n*\n*        TABLE COMPLETE, READY FOR EXIT\n*\n***********************************************************************\nEXITOK   DS    0H\n         TM    SWTCH+1,X'F0'      MINOR NAMES FOUND ?\n         BZ    NOOUTPUT           NO...\nEXITOK1  SR    R1,R1              MESSAGE CODE=0, ALL SUCCESSFUL\nSETSIZE  STH   R3,TBLSIZE         SET TABLE SIZE FOR I/O MODULE\n         SPACE 5\n***********************************************************************\n*\n*        XCTL TO SECOND LOAD OF MODULE FOR ALL I/O\n*\n***********************************************************************\nXCTL     STH   R1,MSGCODE         SET CODE FOR ENQ2LOAD\n*        SSM   ENABLE             ENABLE ALL INTERRUPTS\n         MVC   XCTLNAME(8),=CL8'ENQ2LOAD' NAME OF ENTRY POINT\n         XCTL  EPLOC=XCTLNAME,SF=(E,XCTLLIST)  GO TO I/O MODULE\n         EJECT\n***********************************************************************\n*\n*        ERROR MESSAGE CODES SET HERE\n*\n***********************************************************************\nNOMAJNAM LA    R1,4               MAJOR NAME QCB NOT FOUND\n         B     XCTL\n         SPACE 2\nQCBERR   LA    R1,8               MINOR QCB CHAIN ERROR\n         B     XCTL\n         SPACE 2\nQELERR   LA    R1,12              QEL CHAIN ERROR\n         B     XCTL\n         SPACE 2\nGETERR   LA    R1,16              NO FREE CORE AVAILABLE FROM GETMAIN\n         B     XCTL\n         SPACE 2\nBADERR   LA    R1,20              INVALID MAJOR/MINOR NAME\n         B     XCTL\n         SPACE 2\nPARMERR  LA    R1,24              NO MINOR NAME SPECIFIED\n         B     XCTL\n         SPACE 2\nNOOUTPUT LA    R1,28              MINOR NAME QCB NOT FOUND\n         B     XCTL\n         SPACE 2\nTABLOVFL LA    R1,32              LOST DATA--TABLE SIZE EXCEEDED\n         B     SETSIZE\n         SPACE 2\nTABLOFL2 SR    R3,R11             TABLE OVERFLOW ON MINOR QCB NAME\n         B     TABLOVFL           OMIT IT FROM TABLE\n         EJECT\n***********************************************************************\n*\n*        CONSTANTS, DSECTS, ETC HERE\n*\n***********************************************************************\nCLCRNAME CLC   MINNAME(0),RIBRNAME\nMVCRNAME MVC   2(0,R4),RIBRNAME\nMVNAM    MVC   0(*-*,R6),0(R8)\nCOMPMINR CLC   MINNAME(*-*),20(R7)\nQCBNAME  MVC   2(*-*,R4),20(R7)\nHEX40S   DC    255X'40'\nCORSIZ   DC    F'9120'\nGQSCANL  GQSCAN SCOPE=ALL,MF=L\nGQSCANLL EQU   *-GQSCANL\n*\nWKDSECT  DSECT\nSAVA     DS    18F                SAVE-AREA\nXSASAVE  DS    F                  EXTENDED SAVE-AREA PTR\nCORE     DS    F                  POINTER TO FREE CORE TABLE\nMAJLGTH  DS    H                  MODIFIED LENGTH OF MAJOR NAME\nMINLGTH  DS    H                  MODIFIED LENGTH OF MINOR NAME\nSWTCH    DS    H                  PROGRAM SWITCHES\nWKSIZE   DS    H                  SIZE OF WORK-AREA\nCORESIZE DS    H                  SIZE OF FREE-CORE TABLE\nMSGCODE  DS    H                  I/O MESSAGE CODE\nTBLSIZE  DS    H                  NUMBER OF TABLE ENTRIES\nMAJNAM   DS    CL8                MAJOR NAME\nMINNAME  DS    CL255              MINOR NAME\nWTOLIST  DS    F                  WTO CONTROL BYTES\nBUFFER   DS    CL65               WTO MESSAGE BUFFER\nXCTLLIST DS    0F                 XCTL CONTROL INFO\nXCTLEP   DS    F                  ADDRESS OF EP PARAMETER\nXCTLDCB  DS    F                  DCB ADDRESS PARAMETER\nXCTLNAME DS    CL8                ENTRY POINT NAME\nGQSTUFF  DS    5F                 SETUP FOR GQSCAN MACRO\n*        WORD 1  - ADDRESS OF AREA FOR RIB'S AND RIBE'S\n*        WORD 2  - ADDRESS OF QNAME\n*        WORD 3  - ADDRESS OF RNAME\n*        WORD 4  - LENGTH  OF RNAME\n*        WORD 5  - LENGTH  OF AREA\nGQRETURN DS    3F                 RETURN INFORMATION FROM GQSCAN\nGQRIBLN  EQU   GQRETURN+4,2\nGQRIBELN EQU   GQRETURN+6,2\nGQRIBNUM EQU   GQRETURN+8,4\nGQTOKEN  DS     F                 GQSCAN TOKEN VALUE\n*        WORD 1  RETURN CODE FROM GQSCAN EXECUTION\n*        WORD 2  FIRST  HALF - LENGTH FIXED PORTION OF RIB\n*                SECOND HALF - LENGTH OF EACH RIBE RETURNED\n*        WORD 3  - NUMBER OF RIB'S RETURNED\n*        WORD 4  - TOKEN\n*        WORD 5  - LOCATION OF PROGRAM'S MESSAGE TABLE\n*        WORD 6  - NUMBER OF ENTRIES REMAINING IN TABLE\nGQCORE   DS     F\nGQENTCT  DS     F\nLWKDSECT EQU   *-WKDSECT\n***********************************************************************\n*\n*              SWTCH -- BIT DEFINITIONS\n*\n*        OFFSET   VALUE   MEANING\n*       -------  ------- ---------\n*          +0     X'00'   FULLLY QUALIFIED MINOR NAME GIVEN\n*\n*          +0     X'F0'   OBTAIN ALL MINOR NAMES\n*\n*          +0     X'0F'   OBTAIN ALL MINOR NAMES STARTING WITH GIVEN\n*\n*          +1     X'F0'   FOUND MINOR NAME, OUTPUT EXISTS\n*\n*          +1     X'0F'   OBTAIN ONLY MAJOR QCB NAMES\n*\n***********************************************************************\n         REGISTER ,\n         SPACE 2\n         PRINT NOGEN\n         ISGRIB      ,\n         END\n//LKED.SYSIN DD *\n   NAME DSNQA(R)\n//SYSUDUMP DD SYSOUT=A\n//ABNLDUMP DD DUMMY\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ENQ1LOAD": {"ttr": 16902, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x00\\x7f\\x00\\x88\\x00\\x7f\\x12\\x00\\x02\\xa9\\x02\\xa9\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf2\\xf7\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-01-07T00:00:00", "modifydate": "1988-01-07T12:00:00", "lines": 681, "newlines": 681, "modlines": 0, "user": "FILE270"}, "text": "//DNE00150 JOB (2100,56-D),'DPARS 0682 T',CLASS=H,MSGCLASS=T\n//* FROM WIZRD150.DN00150.FILE(ENQ1LOAD)\n//L EXEC ASMHCL,OPTION1=TERM,LIBRARY='LOADLIB',LNDSP=SHR\n         TITLE 'DISPLAY ENQUEUE ' WDPSC.CMDLIB\n* DENQ TEXT ORIGINALLY FROM CBT MVS MODIFICATION TAPE VIA SHARE.\n* DO NOT LOSE THIS BECAUSE IT IS NOT ON TAPE ANY MORE.\n* 05/24/82 MODIFIED FOR SP 1.3 WHICH MOVED THE ENQ TABLES TO ANOTHER\n* ADDRESS SPACE CONNECTION IS NOW MADE WITH THE GQSCAN MACRO\nENQ1LOAD CSECT\n***********************************************************************\n*\n*        OPERATOR COMMAND TO DISPLAY JOBNAMES,USERIDS IN ENQ CHAIN\n*\n*        ON ENTRY:\n*                 R2  = ADDRESS OF DSXSA (EXTENDED SAVE AREA)\n*                 R15 = ADDRESS OF ENTRY POINT\n*\n*        COMMAND FORMAT:\n*\n*              DENQ  \"MAJOR\"/\"MINOR\"\n*\n*        WHERE:\n*              MAJOR = MAJOR QCB NAME, MAX 8 BYTES\n*              MINOR = MINOR QCB NAME, MAX 255 BYTES\n*\n*        MINOR MAY ALSO BE GIVEN AS:\n*              1) *   - OBTAIN ALL MINOR NAMES FOR GIVEN MAJOR NAME\n*              2) XY* - OBTAIN ALL MINOR NAMES BEGINNING WITH XY;\n*                       XY = ANY COMBINATION AND SIZE OF CHARACTERS\n*\n*        IF MAJOR IS GIVEN AS * , ONLY MAJOR QCB NAMES ARE PRINTED\n*\n*        CSECT  NAME: ENQ1LOAD\n*        MODULE NAME: ENQ1LOAD\n*        ATTRIBUTES : REENTRANT,REUSABLE\n*\n*        AUTHOR      : ALAN M. WOOLF\n*        DATE        : NOVEMBER 9, 1971\n*        INSTALLATION: SIKORSKY AIRCRAFT, DIV. OF UNITED AIRCRAFT CORP.\n*\n***********************************************************************\n         B     14(0,R15)          BRANCH AROUND ID\n         DC    AL1(8)\n         DC    CL8'ENQ1LOAD  '    IDENTIFIER\n         LR    R12,R15            SET ADDRESSABILITY\n         LR    R2,R1\n         USING ENQ1LOAD,R12\n         LA    R0,LWKDSECT\n         GETMAIN R,LV=(0)\n         XC    0(256,R1),0(R1)    ZERO-OUT WORK AREA\n         XC    256(LWKDSECT-256,R1),256(R1)\n         LR    R13,R1\n         USING WKDSECT,R13        FIRST 18 WRDS ARE SAVE-AREA\n         ST    R14,SAVA           PUT RETURN ADDRESS IN UNUSED SLOT\n         STH   R0,WKSIZE          SAVE SIZE\n         EJECT\n***********************************************************************\n*\n*        GET CORE FOR WORK TABLE\n*\n***********************************************************************\n         L     R0,CORSIZ\n         STH   R0,CORESIZE\n         GETMAIN R,LV=9120\n         LA    R1,0(R1)\n         ST    R1,CORE\n         SPACE 1\n         L     R0,CORSIZ2\n         GETMAIN R,LV=(0)\n         ST    R1,GQSTUFF\n***********************************************************************\n*\n*        PARSE INPUT STRING\n*\n***********************************************************************\n         MVI   MAJNAM,C' '\n         MVC   MAJNAM+1(256),MAJNAM    CLEAR MAJOR/MINOR NAME FIELDS\n         MVC   MAJNAM+257(6),MAJNAM+256\n         L     R3,0(,R2)              COMMAND INPUT STRING\n         OC    4(20,R3),4(R3)\n         LA    R3,4(,R3)              COMMAND TEXT\nLOOPC    CLI   0(R3),C' '             END OF COMMAND TEXT\n         BE    PARSEIT                YES\n         LA    R3,1(,R3)              TRY FOR END\n         B     LOOPC\nPARSEIT  EQU   *\n         CLI   0(R3),C' '           FIRST CHARACTER A BLANK\n         BNE   LOOPAEND             NO, PROCEED\n         LA    R3,1(,R3)            ADD 1\n         B     PARSEIT              TRY AGAIN\nLOOPAEND EQU   *\n         LR    R8,R3\n         CLI   0(R3),C'*'         FIND ONLY MAJOR NAMES ?\n         BE    SETMAJNM           YES..\n         LA    R4,0               LENGTH COUNTER\n         LA    R5,9\nLOOP2    CLI   0(R3),C'/'         MAJOR/MINOR DELIMITER ?\n         BE    GOTMAJOR           YES...\n         CLI   0(R3),C' '         END-OF-STRING ?\n         BE    PARMERR            YES...NO MINOR NAME GIVEN.\n         LA    R4,1(,R4)          INCREMENT LENGTH\n         LA    R3,1(,R3)          INCREMENT PTR\n         BCT   R5,LOOP2           TRY NEXT CHAR\n         B     BADERR             MAJOR NAME TOO LONG.\nGOTMAJOR BCTR  R4,0               SET FOR EXECUTE\n         LA    R6,MAJNAM          WHERE TO GO IN EXECUTE\n         EX    R4,MVNAM           GET MAJOR NAME\n         OC    MAJNAM(8),HEX40S\n         STH   R4,MAJLGTH         SAVE MODIFIED LENGTH\n         LA    R4,0               RESET LENGTH COUNTER\n         LA    R3,1(,R3)          MOVE PAST '/'\n         LR    R8,R3              SAVE START OF MINOR NAME\n         LA    R5,256             MAX LENGTH OF MINOR NAME\nLOOP3    CLI   0(R3),C' '         END-OF-STRING\n         BE    GOTMINOR           YES...\n         LA    R3,1(,R3)          INCREMENT PTR\n         LA    R4,1(,R4)          INCREMENT LENGTH\n         BCT   R5,LOOP3\n         B     BADERR             MINOR NAME TOO LONG\nGOTMINOR BCTR  R4,0\n         LA    R6,MINNAME         WHERE TO GO IN EXECUTE\n         EX    R4,MVNAM           GET MINOR NAME\n         OC    MINNAME(255),HEX40S\n         LA    R4,1(,R4)          RESET LENGTH\n         STH   R4,MINLGTH         SAVE LENGTH\n***********************************************************************\n*\n*        SCAN FOR '*' IN MINOR NAME\n*\n***********************************************************************\n         LA    R3,MINNAME\n         LA    R4,0               COUNT OF CHAR PRIOR TO '*'\n         LH    R5,MINLGTH\nLOOP4    CLI   0(R3),C'*'         FIND IT ?\n         BE    ASK                YES...\n         LA    R3,1(,R3)          NO..NEXT CHAR\n         LA    R4,1(,R4)          INCREMENT COUNT\n         BCT   R5,LOOP4\n         B     NOASK              NO '*' IN MINOR NAME\nASK      LTR   R4,R4              ANY CHAR PRIOR TO '*' ?\n         BZ    ALLMINOR           NO..GET ALL MINOR NAMES\n         MVI   SWTCH,X'0F'        YES..PARTIAL MINOR NAME GIVEN\n         STH   R4,MINLGTH         SET NEW LENGTH\n         B     NOASK              JOIN COMMON CODE\nALLMINOR MVI   SWTCH,X'F0'        SET FOR ALL MINOR NAMES\n         B     NOASK\nSETMAJNM XC    MAJNAM,MAJNAM      SET MAJOR NAME\n         XC    MAJLGTH(2),MAJLGTH SET MODIFIED LENGTH\n         MVI   SWTCH+1,X'0F'      SET FOR ONLY MAJOR NAMES\n         MVI   SWTCH,X'0F'      SET FOR ONLY MAJOR NAMES\n         EJECT\n***********************************************************************\n*\n*        CHECK POINTER IN CVT FOR EXISTENCE OF QCB/QEL CHAIN.\n*        IF ZERO, THE SYSTEM IS MVS/SP1.3 OR HIGHER AND THE GQSCAN\n*        MECHANISM MUST BE USED.\n*\n***********************************************************************\nNOASK    EQU   *\n         L     R5,X'10'           CVT PTR\n         ICM   R2,15,640(R5)      MAJOR QCB POINTER\n         BNZ   CHKQCB             IF IT EXISTS THIS IS BEFORE SP 1.3\n         LA    R4,MAJNAM          MAJOR NAME ADDRESS\n         TM    SWTCH,X'FF'        WAS AN ASTERISK PRESENT IN COMMAND\n         BZ    SASTRIK            NO\n         SR    R5,R5              ZERO THE MINOR\n         SR    R6,R6              ZERO THE MINOR LENGTH\n         TM    SWTCH+1,X'0F'      MAJOR ONLY\n         BZ    SMINORGO\n         SR    R4,R4              ZERO THE MAJOR\n         B     SMINORGO\nSASTRIK  EQU   *\n         LA    R5,MINNAME       MINOR NAME ADDRESS\n         LH    R6,MINLGTH       MINOR NAME LENGTH\nSMINORGO EQU   *\n         STM   R4,R6,GQSTUFF+4\n         MVC   GQSTUFF+18(4),CORESIZE\n         L     R8,CORE\n         ST    R8,GQCORE LOCATION OF MESSAGE TABLE\n         SR    R8,R8\n         ST    R8,GQENTCT NUMBER OF USED ENTRIES IN TABLE\n         XC    GQTOKEN,GQTOKEN\n         SPACE 4\n***********************************************************************\n*\n*      TOKEN IS A ZEROED FIELD ON FIRST ENTRY, AND IS USED AS START\n*      POINT IF NECESSARY.\n*      REGISTER  ARE ZERO FOR NON-SPECIFIC SCANS. R5 AND R6 ARE ZERO\n*      IF EITHER MAJOR ONLY OR GENERAL MINOR. R4 IS ZERO FOR MAJOR\n*      ONLY.\n*\n*\n*\n***********************************************************************\nSGUN     EQU   *\n         LM    R3,R7,GQSTUFF\n         LA    R2,GQTOKEN\n         SPACE 1\n         MVC   BUFFER(GQSCANLL),GQSCANL\n         GQSCAN AREA=((R3),(R7)),SCOPE=ALL,RESNAME=((R4),(R5),(R6)),  XX\n               TOKEN=(R2),MF=(E,BUFFER)\n         B     STABLE(R15)\nSTABLE   B     SSCANQ\n         B     NOOUTPUT\n         B     SSCANQ\n         B     QELERR\n         B     QELERR\n         SPACE 4\n***********************************************************************\n*\n*      ITEMS HAVE BEEN FOUND\n* THE STARTING POINT IS THE RIB CONTROL BLOCK.\n*\n***********************************************************************\nSSCANQ   EQU   *\n         L     R3,GQSTUFF\n         STM   R15,R1,GQRETURN      STORE RETURN CODES\n         L     R2,GQENTCT           CURRENT NUMBER OF TABLE ENTRIES\n         L     R4,GQCORE            TABLE FOR RESOURCES\nSRIBALL  LR    R7,R3                 ADDRESS OF RIB\n         AH    R7,GQRIBLN           LENGTH OF RIB FIXED AREA\n         USING RIB,R3\n         USING RIBVAR,R7\n         USING RIBE,R10\n         SR    R9,R9\n         IC    R9,RIBRNMLN          LENGTH OF RNAME\n         TM    SWTCH+1,X'0F'        MAJOR NAMES ONLY\n         BNZ   SRIBMAJR NO\n         TM    SWTCH,X'F0'          ALL MINOR NAMES\n         BO    SCMPNAME\n         TM    SWTCH,X'0F'          MINOR NAMES BEGINNING WITH\n         BO    SCKLGTH\n         CH    R9,MINLGTH           ARE LENGTHS EQUAL\n         BNE   SNXTRIB\nSCKLGTH  LH    R8,MINLGTH           COMPARISON LENGTH\n         BCTR  R8,0\n         EX    R8,CLCRNAME          CLC MINNAME(0),RIBRNAME\n         BNE   SNXTRIB\nSCMPNAME EQU   *\n         STC   R9,1(,R4)            PUT NAME LENGTH IN TABLE\n         LA    R9,2(,R9)            INCREASE FOR CONTROL BYTES\n         SR    R8,R8\n         D     R8,=F'9'\n         LTR   R8,R8                ANY REMAINDER?\n         BZ    SFILLOUT      L9     NO...\n         LA    R9,1(,R9)            YES,   ROUND UP\nSFILLOUT STC   R9,0(,R4)            PUT NO. OF TABLE ENTRIES IN TABLE\n         AR    R2,R9                INCREMENT NO. OF ENTRIES\n         C     R2,=F'1000'          OVERFLOW TABLE\n         BH    STBOFL2\n         IC    R9,RIBRNMLN          RETURN LENGTH TO ORIGINAL - 1\n         BCTR  R9,0\n         EX    R9,MVCRNAME          MOVE MINOR NAME TO TABLE\n         LH    R9,RIBVLEN\n         LA    R10,0(R9,R7)         LOCATION OF RIBE\n         SR    R8,R8\n         IC    R9,0(,R4)            NUMBER OF ENTRIES\n         M     R8,=F'9'\n         AR    R4,R9                POINT TO NEXT SLOT\n         L     R8,RIBNRIBE          NUMBER OF RIBE'S RETURNED\n***********************************************************************\n*\n*      THE RIBE CONTROL BLOCK IS SCANNED. RIBE IS LOCATED BY\n*      A(RIBRNAME) PLUS C(RIBVLEN). ADDRESS OF RNAME (MINOR) AND LENGTH\n*      OF VARIABLE SECTION.\n*\n***********************************************************************\nSRIBE    EQU   *\n         MVC   0(8,R4),RIBEJBNM     JOBNAME OF RESOURCE USER\n         MVI   8(R4),C'S'           ASSUME SHARED ENQUEUE\n         TM    RIBERFLG,RIBERESV    RESERVE  REQUEST\n         BZ    SRIBECK1 NO\n         MVI   8(R4),C'R'           INDICATE RESERVE\nSRIBECK1 TM    RIBERFLG,RIBETYPE    SHARED  REQUEST?\n         BO    SRIBECK2\n         MVI   8(R4),C'E'\n         TM    RIBERFLG,RIBERESV    RESERVE REQUEST\n         BZ    SRIBECK2\n         MVI   8(R4),C'X'           EXCLUSIVE RESERVE\nSRIBECK2 EQU   *\n         MVI   SWTCH+1,X'F0'        FLAG MINORS FOUND\n         LA    R2,1(,R2)            INCREMENT ENTRY NUMBER\n         LA    R4,9(,R4)            INCREMENT TABLE LOCATION\n         C     R2,=F'1000'          TOO MANY ENTRIES\n         BH    STBOVFL\n         AH    R10,GQRIBELN         ADD LENGTH OF RIBE\n         BCT   R8,SRIBE             BRANCH WHEN RESULT IS ZERO\n         SPACE 3\n***********************************************************************\n*\n*      ADVANCE TO NEXT RIB CONTROL BLOCK BY CALCULATING BASED ON\n*      NUMBER OF RIBE CONTROL BLOCKS FOR THE RIB AND THE APPROPIATE\n*      LENGTHS.\n*\n***********************************************************************\nSNXTRIB  L     R8,GQRIBNUM          NUMBER OF RIB'S RETURNED\n         S     R8,=F'1'      REDUCE BY ONE\n         BZ    SNXTSCAN      BRANCH WHEN RESULT IS ZERO\n         ST    R8,GQRIBNUM\n         L     R8,RIBNRIBE      NUMBER OF RIBE'S\n         MH    R8,GQRIBELN      LENGTH OF RIBE FIXED\n         AH    R3,RIBVLEN       LENGTH OF RIBE VARIABLE (MULT OF 4)\n         AH    R3,GQRIBLN       LENGTH OF RIB  FIXED\n         AR    R3,R8            NEXT RIB\n         B     SRIBALL\n         EJECT\n**********************************************************************\n*\n*   SCAN MAJOR NAMES ONLY.              THE OUTPUT TABLE IS SCANNED\n*   AND THE UNIQUE ONES ARE KEPT. THE TABLE IS IN ASCENDING SEQUENCE.\n*   ONCE NAME IS IN THE TABLE PROCEED TO THE NEXT RIB RETURNED BY\n*   GQSCAN.\n*\n**********************************************************************\nSRIBMAJR EQU   *\n         CLC   MAJNAM,RIBQNAME    CHECK MAJOR NAME TO LAST ONE\n         BE    SNXTRIB            GET NEXT IF EQUAL\n         MVC   MAJNAM,RIBQNAME    KEEP FOR CHECK\n         LTR   R2,R2               HAS IT BEGUN\n         BZ    SRIBMAJU NO\n         L     R7,CORE            BEGINNING OF OUTPUT TABLE\n         LA    R8,8               SIZE OF ENTRY\n         LR    R9,R4              EMPTY ENTRY IN TABLE\n         SR    R9,R8              POINT TO LAST USED ENTRY IN TABLE\nSRIBMAJS CLC   RIBQNAME,0(R7)\n         BE    SNXTRIB\n         BL    SRIBMAJT\n         BXH   R7,R8,SRIBMAJU\n         B     SRIBMAJS\nSRIBMAJT EQU   *\n         MVC   8(8,R9),0(R9)\n         SR    R9,R8\n         CR    R9,R7\n         BNL   SRIBMAJT\n         MVC   0(8,R7),RIBQNAME\n         B     SRIBMAJV\nSRIBMAJU EQU   *\n         MVC   0(8,R4),RIBQNAME   MOVE TO TABLE\nSRIBMAJV EQU   *\n         LA    R2,1(,R2)          INCREMENT TABLE COUNTER\n         LA    R4,8(,R4)          NEXT TABLE ENTRY\n         C     R2,=F'1000'        OVERFLOW TABLE YET\n         BH    STBOFL2            YEP\n         B     SNXTRIB            GET NEXT RIB AND PROCEED\n         SPACE 4\n*********************************************************************\n*\n*   CHECK FOR MORE RIB POSSIBILITIES AND RETURN TO GQSCAN IF\n*   NECESSARY\n*\n*********************************************************************\nSNXTSCAN EQU   *\n         ICM   R3,15,GQTOKEN\n         BZ    SLEAVE\n         ST    R4,GQCORE          CURRENT LOCATION IN MESSAGE TABLE\n         ST    R2,GQENTCT         COUNT OF ENTRIES USED\n         B     SGUN\n         SPACE 1\nSTBOFL2  SR    R2,R9              REDUCE NUMBER OF USED ENTRIES\nSTBOVFL  LA    R1,32              SET RETURN CODE VALUE\n         LR    R3,R2              PLACE NUMBER OF ENTRIES\n         B     SETSIZE\n         SPACE 2\nSLEAVE   LR    R3,R2   AGREE TO PRE SP1.3 CODE\n         TM    SWTCH+1,X'0F'      MAJOR NAMES ONLY\n         BO    EXITOK1\n         B     EXITOK\n         TITLE 'PRE SP 1.3 CODE'\n         PRINT OFF\nCHKQCB   EQU   *\n         BZ    NOMAJNAM           NO...\n         SPIE  SPIEXIT,(4)        SPIE 0C4'S\n         EJECT\n***********************************************************************\n*\n*        SSM   *+1                DISABLE ALL INTERRUPTS\n*\n***********************************************************************\n         LA    R3,0               CURRENT NUMBER OF TABLE ENTRIES\n         LA    R5,1000            MAX NUMBER OF ENTRIES\n         L     R4,CORE            START OF FREE CORE TABLE\n         TM    SWTCH+1,X'0F'      OBTAIN ONLY MAJOR NAMES ?\n         BZ    LOOP5              NO...CONTINUE NORMALLY\n***********************************************************************\n*\n*        OBTAIN ONLY MAJOR QCB NAMES HERE\n*\n***********************************************************************\nMAJLOOP  MVC   0(8,R4),16(R2)     GET MAJOR QCB NAME\n         LA    R3,1(,R3)          INCREMENT COUNTER\n         LA    R4,8(,R4)          NEXT TABLE ENTRY\n         CR    R3,R5              OVERFLOW TABLE ?\n         BH    TABLOVFL           YES...\n         L     R2,0(,R2)          NEXT MAJOR QCB\n         LTR   R2,R2              EXIST ?\n         BNZ   MAJLOOP            YES...GO GET IT\n         B     EXITOK1            ALL FINISHED.\n***********************************************************************\n*\n*        FIND REQUESTED MAJOR NAME QCB\n*\n***********************************************************************\nLOOP5    CLC   16(8,R2),MAJNAM    MAJOR NAMES MATCH ?\n         BE    LOOKMIN            YES...FIND MINOR NAMES\n         L     R2,0(,R2)          NEXT MAJOR QCB\n         LTR   R2,R2              END-OF-LIST ?\n         BNZ   LOOP5              NO...TRY NEXT QCB\n         B     NOMAJNAM           SET ERROR CODE\n         EJECT\n***********************************************************************\n*\n*        MAJOR QCB FOUND, LOOK FOR MINOR QCB(S)\n*\n***********************************************************************\nLOOKMIN  L     R7,8(,R2)          FIRST MINOR QCB\n         LTR   R7,R7              EXIST ?\n         BNZ   MINOROK            YES...SHOULDN'T FALL THRU\n         B     QCBERR             SET ERROR CODE\nMINOROK  TM    SWTCH,X'F0'        ALL MINOR NAMES ?\n         BZ    CHKMIN             NO...\nCHKQEL   SR    R9,R9\n         IC    R9,16(R7)          LENGTH OF MINOR QCB NAME\n         CH    R9,=H'44'          GTR 44 BYTES ?\n         BNH   LGTHOK             NO...USE AS IS\n         LA    R9,44              YES..RESET TO 44 AND TRUNCATE NAME\nLGTHOK   STC   R9,1(,R4)          PUT NAME LENGTH IN TABLE\n         LA    R9,2(,R9)          INCREASE FOR FOLLOWING COMPUTATIONS\n         SR    R10,R10\n         LR    R11,R9             LENGTH OF MINOR NAME+CONTROL BYTES\n         D     R10,=F'9'          MULTIPLE OF 9 ?\n         LTR   R10,R10            ANY REMAINDER ?\n         BZ    L9                 NO...\n         LA    R11,1(,R11)        YES...ROUND UP\nL9       STC   R11,0(,R4)         PUT NO. OF TABLE ENTRIES IN TABLE\n         CLI   20(R7),C'$'        VALID MINOR NAME\n         BL    UNKNOWN            NO, UNKNOWN\n         CLI   20(R7),C'9'        VALID MINOR NAME\n         BH    UNKNOWN            NO, UNKNOWN\n         AR    R3,R11             INCREMENT NO. OF ENTRIES\n         CR    R3,R5              OVERFLOW TABLE ?\n         BH    TABLOFL2           HOPEFULLY NOT.\n         BCTR  R9,0               REDUCE LENGTH\n         BCTR  R9,0               TO ORIGINAL AND THEN\n         BCTR  R9,0               SET FOR EXECUTE INST\n         EX    R9,QCBNAME         GET MINOR QCB NAME\n*                                 NO. OF TABLE SLOTS TAKEN BY NAME\nUNKBACK  SR    R10,R10            MULTIPLIED BY 9 BYTES/SLOT\n         M     R10,=F'9'          EQUALS TOTAL LENGTH TAKEN\n         AR    R4,R11             ADDED TO SLOT POINTER\n         L     R8,8(,R7)          FIRST QEL\n         LTR   R8,R8              EXIST ?\n         BNZ   QELOK              YES...SHOULDN'T FALL THRU\n         B     QELERR             SET ERROR CODE\n         EJECT\nQELOK    SR    R14,R14            INSERT\n         IC    R14,14(0,R8)          ASID\n         SLL   R14,8                    INTO REG 14\n         IC    R14,15(0,R8)                AND MULTIPLY\n         SLL   R14,2                          BY FOUR\n         L     R15,16             CVT ADDR\n         L     R15,556(0,R15)     ASVT ADDR\n         L     R15,524(R14,R15)   ASCB ADDR\n         L     R14,56(0,R15)      CSCB ADDR\n         CLI   28(R14),X'03'      INIT CSCB\n         BE    QELOKJOB           YES, GO HANDLE\nQELOKBAK LA    R14,0(0,R14)       CLEAR HIGH ORDER\n         LTR   R14,R14            CSCB ZERO\n         BZ    QELOKAS            YES, GO PRINT ASID\n         MVC   0(8,R4),8(R14)     JOBNAME\n         B     QELOKBK\nQELOKAS  MVC   0(4,R4),=CL4'AS= ' ADDRESS SPACE\n         UNPK  4(5,R4),14(3,R8)   UNPK ASID\n         MVI   8(R4),C' '         BLANK EXTRA CHAR\n         NC    4(4,R4),=4X'0F'    TRANSLATE TO PRINT\n         TR    4(4,R4),=C'0123456789ABCDEF'\nQELOKBK  MVI   8(R4),C'S'         ASSUME SHR'D ENQ\n         TM    12(R8),X'10'       RESERVE\n         BZ    QELOKBKX           NO, BR AROUND\n         MVI   8(R4),C'R'         IND SHR RESERVE\nQELOKBKX TM    12(R8),X'80'       IS IT SHR'D ?\n         BO    NEXTONE            YES...\n         MVI   8(R4),C'E'         NO...MUST BE EXCLUSIVE\n         TM    12(R8),X'10'       RESERVE\n         BZ    NEXTONE\n         MVI   8(R4),C'X'         IND EXCL RESERVE\nNEXTONE  LA    R3,1(,R3)          INCREMENT ENTRY NUMBER\n         LA    R4,9(,R4)          INCREMENT TABLE LOCATION\n         CR    R3,R5              TOO MANY ENTRIES IN TABLE ?\n         BH    TABLOVFL           YES...IGNORE REMAINDER\n         MVI   SWTCH+1,X'F0'      FLAG MINORS FOUND\nNEXTQEL  L     R8,0(,R8)          NEXT QEL\n         LA    R8,0(,R8)          CLEAR HI-BYTE\n         LTR   R8,R8              QEL EXIST ?\n         BNZ   QELOK              YES.\n         B     NEXTMIN            NO...GET NEXT MINOR QCB\nCHKMIN   SR    R8,R8\n         IC    R8,16(,R7)         LENGTH OF MINOR NAME\n         TM    SWTCH,X'0F'        ALL NAMES STARTING WITH GIVEN ?\n         BO    ALL                YES.\n         CH    R8,MINLGTH         MINOR NAME LENGTHS AGREE ?\n         BNE   NEXTMIN            NO...TRY ANOTHER MINOR QCB\nCOMP     BCTR  R8,0               LENGTHS AGREE..BUT DO NAMES ?\n         EX    R8,COMPMINR        FIND OUT.\n         BE    CHKQEL             YES..GET OWNER'S JOBNAME/USERID\nNEXTMIN  L     R7,0(,R7)          NEXT MINOR QCB\n         LTR   R7,R7              EXIST ?\n         BZ    EXITOK             NO..OUTPUT DATA\n         TM    SWTCH,X'F0'        DOING ALL MINOR QCB'S ?\n         BO    CHKQEL             YES...\n         B     CHKMIN             NO..TRY THIS MINOR QCB.\nALL      LH    R8,MINLGTH         LENGTH OF MINOR NAME TO START WITH\n         B     COMP               JOIN COMMON CODE\n        EJECT\nQELOKJOB LR    R15,R14            CSCB ADDR\n         SR    R1,R1              INSERT\n         IC    R1,14(0,R8)           ASID\n         SLL   R1,8                     INTO REG 1\n         IC    R1,15(0,R8)\nQELOKJB1 L     R14,0(0,R14)       NEXT CSCB\n         CR    R14,R15            SAME CSCB\n         BE    QELOKBAK           YES, INIT\n         CH    R1,30(0,R14)       ASID MATCH\n         BNE   QELOKJB1           NO, CHECK NEXT\n         B     QELOKBAK           GO USE CSCB\n         EJECT\n         PRINT ON\n***********************************************************************\n*\n*        TABLE COMPLETE, READY FOR EXIT\n*\n***********************************************************************\nEXITOK   DS    0H\n         TM    SWTCH+1,X'F0'      MINOR NAMES FOUND ?\n         BZ    NOOUTPUT           NO...\nEXITOK1  LA    R1,0               MESSAGE CODE=0, ALL SUCCESSFUL\nSETSIZE  STH   R3,TBLSIZE         SET TABLE SIZE FOR I/O MODULE\n         TITLE 'DISPLAY ENQUEUE '\n         SPACE 5\n***********************************************************************\n*\n*        XCTL TO SECOND LOAD OF MODULE FOR ALL I/O\n*\n***********************************************************************\nXCTL     STH   R1,MSGCODE         SET CODE FOR ENQ2LOAD\n*        SSM   ENABLE             ENABLE ALL INTERRUPTS\n         MVC   XCTLNAME(8),=CL8'ENQ2LOAD' NAME OF ENTRY POINT\n         XCTL  EPLOC=XCTLNAME,SF=(E,XCTLLIST)  GO TO I/O MODULE\n         SPACE 3\nSPIEXIT  MVC   8(4,R1),=A(SPIERTRY)  RETRY RTN ADDR\n         BR    R14                RETURN\n         SPACE 2\nSPIERTRY SPIE  SPIEXIT,(4)        SPIE 0C4'S\n         B     QELOK              GO PRINT ASID\n         SPACE 3\nUNKNOWN  MVC   2(7,R4),=CL7'UNKNOWN'\n         MVI   1(R4),X'07'        SET MINOR NAME LENGTH\n         MVI   0(R4),X'09'        SET NO. OF TABLE ENTRIES\n         LA    R11,9              LOAD ADJUSTED LENGTH\n         AR    R3,R11             INCREMENT NO. OF ENTRIES\n         CR    R3,R5              OVERFLOW TABLE ?\n         BH    TABLOFL2           HOPEFULLY NOT.\n         BCTR  R9,0               REDUCE LENGTH\n         BCTR  R9,0               TO ORIGINAL AND THEN\n         BCTR  R9,0               SET FOR EXECUTE INST\n         B     UNKBACK\n         EJECT\n***********************************************************************\n*\n*        ERROR MESSAGE CODES SET HERE\n*\n***********************************************************************\nNOMAJNAM LA    R1,4               MAJOR NAME QCB NOT FOUND\n         B     XCTL\n         SPACE 2\nQCBERR   LA    R1,8               MINOR QCB CHAIN ERROR\n         B     XCTL\n         SPACE 2\nQELERR   LA    R1,12              QEL CHAIN ERROR\n         B     XCTL\n         SPACE 2\nGETERR   LA    R1,16              NO FREE CORE AVAILABLE FROM GETMAIN\n         B     XCTL\n         SPACE 2\nBADERR   LA    R1,20              INVALID MAJOR/MINOR NAME\n         B     XCTL\n         SPACE 2\nPARMERR  LA    R1,24              NO MINOR NAME SPECIFIED\n         B     XCTL\n         SPACE 2\nNOOUTPUT LA    R1,28              MINOR NAME QCB NOT FOUND\n         B     XCTL\n         SPACE 2\nTABLOVFL LA    R1,32              LOST DATA--TABLE SIZE EXCEEDED\n         B     SETSIZE\n         SPACE 2\nTABLOFL2 SR    R3,R11             TABLE OVERFLOW ON MINOR QCB NAME\n         B     TABLOVFL           OMIT IT FROM TABLE\n         EJECT\n***********************************************************************\n*\n*        CONSTANTS, DSECTS, ETC HERE\n*\n***********************************************************************\nCLCRNAME CLC   MINNAME(0),RIBRNAME\nMVCRNAME MVC   2(0,R4),RIBRNAME\nMVNAM    MVC   0(*-*,R6),0(R8)\nCOMPMINR CLC   MINNAME(*-*),20(R7)\nQCBNAME  MVC   2(*-*,R4),20(R7)\n         DS    0D\n*DOUBLE   DC    2F'0'\n*TSMSK    DC    X'00007FFF'\n*SUB255   DC    X'FF000000'\n*ENABLE   DC    X'FF'\nHEX40S   DC    255X'40'\nCORSIZ   DC    F'9120'\nCORSIZ2  DC    F'12288'\nGQSCANL  GQSCAN SCOPE=ALL,MF=L\nGQSCANLL EQU   *-GQSCANL\n*\nWKDSECT  DSECT\nSAVA     DS    18F                SAVE-AREA\nXSASAVE  DS    F                  EXTENDED SAVE-AREA PTR\nCORE     DS    F                  POINTER TO FREE CORE TABLE\nMAJLGTH  DS    H                  MODIFIED LENGTH OF MAJOR NAME\nMINLGTH  DS    H                  MODIFIED LENGTH OF MINOR NAME\nSWTCH    DS    H                  PROGRAM SWITCHES\nWKSIZE   DS    H                  SIZE OF WORK-AREA\nCORESIZE DS    H                  SIZE OF FREE-CORE TABLE\nMSGCODE  DS    H                  I/O MESSAGE CODE\nTBLSIZE  DS    H                  NUMBER OF TABLE ENTRIES\nMAJNAM   DS    CL8                MAJOR NAME\nMINNAME  DS    CL255              MINOR NAME\nWTOLIST  DS    F                  WTO CONTROL BYTES\nBUFFER   DS    CL65               WTO MESSAGE BUFFER\nXCTLLIST DS    0F                 XCTL CONTROL INFO\nXCTLEP   DS    F                  ADDRESS OF EP PARAMETER\nXCTLDCB  DS    F                  DCB ADDRESS PARAMETER\nXCTLNAME DS    CL8                ENTRY POINT NAME\nGQSTUFF  DS    5F                 SETUP FOR GQSCAN MACRO\n*        WORD 1  - ADDRESS OF AREA FOR RIB'S AND RIBE'S\n*        WORD 2  - ADDRESS OF QNAME\n*        WORD 3  - ADDRESS OF RNAME\n*        WORD 4  - LENGTH  OF RNAME\n*        WORD 5  - LENGTH  OF AREA\nGQRETURN DS   3F           RETURN INFORMATION FROM GQSCAN\nGQRIBLN  EQU  GQRETURN+4,2\nGQRIBELN EQU  GQRETURN+6,2\nGQRIBNUM EQU  GQRETURN+8,4\nGQTOKEN  DS   F          GQSCAN TOKEN VALUE\n*        WORD 1  - RETURN CODE FROM GQSCAN EXECUTION\n*        WORD 2  - FIRST HALF  -  LENGTH FIXED PORTION OF RIB\n*                - SECOND HALF -  LENGTH OF EACH RIBE RETURNED\n*        WORD 3  - NUMBER OF RIB'S RETURNED\n*        WORD 4  - TOKEN\n*        WORD 5  - LOCATION OF PROGRAM'S MESSAGE TABLE\n*        WORD 6  - NUMBER OF ENTRIES REMAINING IN TABLE\nGQCORE   DS   F\nGQENTCT  DS   F\nLWKDSECT EQU   *-WKDSECT\n***********************************************************************\n*\n*              SWTCH -- BIT DEFINITIONS\n*\n*        OFFSET   VALUE   MEANING\n*       -------  ------- ---------\n*          +0     X'00'   FULLLY QUALIFIED MINOR NAME GIVEN\n*\n*          +0     X'F0'   OBTAIN ALL MINOR NAMES\n*\n*          +0     X'0F'   OBTAIN ALL MINOR NAMES STARTING WITH GIVEN\n*\n*          +1     X'F0'   FOUND MINOR NAME, OUTPUT EXISTS\n*\n*          +1     X'0F'   OBTAIN ONLY MAJOR QCB NAMES\n*\n***********************************************************************\n         REGISTER *\n         ISGRIB\n         END\n//LKED.SYSIN DD *\n   NAME DENQ(R)\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ENQ2LOAD": {"ttr": 17159, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x00\\x7f\\x00\\x88\\x00\\x7f\\x12\\x00\\x00\\xf8\\x00\\xf8\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf2\\xf7\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-01-07T00:00:00", "modifydate": "1988-01-07T12:00:00", "lines": 248, "newlines": 248, "modlines": 0, "user": "FILE270"}, "text": "//DNE00150 JOB (2100,56-D),'DPARS 0682 T',CLASS=H\n//* FROM WIZRD150.DN00150.FILE(ENQ2LOAD)\n//A EXEC ASMHCL,OPTION1='RENT,TERM', IBRARY='WDPSC.CMDLIB',\n//   OPTION2=RENT\nENQ2LOAD CSECT\n***********************************************************************\n*\n*        ENQ2LOAD -- SECOND LOAD OF IEESA03D\n*\n*        DOES ALL I/O FOR FIRST LOAD\n*\n*        ON ENTRY:\n*                 R13 = ADDRESS OF WORK-AREA OF IEESA03D\n*                 R15 = ENTRY POINT\n*\n*        CSECT  NAME: ENQ2LOAD\n*        MODULE NAME: ENQ2LOAD\n*        ATTRIBUTES : REENTRANT,REUSABLE\n*\n*        AUTHOR      : ALAN M. WOOLF\n*        DATE        : NOVEMBER 9, 1971\n*        INSTALLATION: SIKORSKY AIRCRAFT, DIV. OF UNITED AIRCRAFT COPR.\n*\n***********************************************************************\n         B     14(0,15)           BRANCH AROUND ID\n         DC    AL1(8)\n         DC    CL8'ENQ2LOAD  '\n         LR    R12,R15\n         USING ENQ2LOAD,R12\n         USING WKDSECT,R13\n         SPACE 2\n         MVI   WTOLIST+2,X'01'    MCSFLAG = QREG0\n         LH    R3,MSGCODE         GET MESSAGE ERROR CODE, IF ANY\n         LTR   R3,R3              ANY ERRORS ?\n         BZ    FORMAT             NO...\n         L     R5,MSGTABLE(R3)    YES...GET DISPLACEMENT OF MESSAGE\n         LA    R5,0(R12,R5)       ADD BASE FOR ABSOLUTE ADDRESS\n         LH    R4,0(,R5)          LENGTH OF MESSAGE\n         BCTR  R4,0               SET FOR EXECUTE\n         EX    R4,GETMSG\n         LA    R4,5(,R4)          RESET LENGTH+4 FOR CONTROL BYTES\n         STH   R4,WTOLIST         PUT LENGTH IN CONTROL FIELD\n         BAL   R11,IOCS           OUTPUT MESSAGE\n         CH    R3,=H'32'          \"LOST DATA\" ERROR CODE ?\n         BNE   CLEANUP            NO...ALL FINISHED THEN.\n         EJECT\n***********************************************************************\n*\n*        FORMAT DATA AND WRITE IT OUT\n*\n***********************************************************************\nFORMAT   EQU   *\n         LA    R3,36              SET MESSAGE CODE\n         LA    R9,2               LOOP COUNTER\n         TM    SWTCH+1,X'0F'      ONLY MAJOR QCB NAMES?\n         BZ    LOOP1              NO..OK AS IS.\n         LA    R3,44              YES..SET FOR CORRECT HEADER MSG.\nLOOP1    L     R5,MSGTABLE(R3)    DISPLACEMENT OF MESSAGE\n         LA    R5,0(R12,R5)       ADD BASE FOR ABSOLUTE ADDRESS\n         LH    R4,0(,R5)          LENGTH\n         BCTR  R4,0               SET FOR EXECUTE\n         EX    R4,GETMSG          MOVE MESSAGE TO BUFFER\n         LA    R4,5(,R4)          CORRECT LENGTH\n         STH   R4,WTOLIST         SET IN MESSAGE\n         BAL   R11,IOCS           DO OUTPUT\n         LA    R3,4(,R3)          NEXT MESSAGE CODE\n         BCT   R9,LOOP1           DO NEXT MESSAGE\n*\n         LH    R3,TBLSIZE         NO. OF ENTRIES IN TABLE\n         L     R5,CORE            START OF TABLE\n         LA    R6,BUFFER          START OF OUTPUT BUFFER\n*\n         TM    SWTCH+1,X'0F'      ONLY MAJOR QCB NAMES ?\n         BO    MAJONLY            YES..\n*\nLOOP2    MVI   BUFFER,C' '\n         MVC   BUFFER+1(64),BUFFER  BLANK-OUT BUFFER\n         LA    R4,24              SET NORMAL WTO LENGTH\n         SR    R9,R9\n         IC    R9,0(,R5)          GET FIRST CHAR IN ENTRY\n         CH    R9,=H'91'          LESS THAN X'5B'...CHAR '$' ?\n         BL    SETNAME            YES..MUST BE MINOR QCB NAME ENTRY.\nGETOWNER MVC   2(8,R6),0(R5)      JOBNAME/USERID\n         MVC   11(6,R6),=CL6'- SHR '   ASSUME SHR'D ENQ\n         CLI   8(R5),C'S'         IS IT SO ?\n         BE    PRINT\n         MVC   13(4,R6),=CL4'EXCL'  NO, ENQ EXCLUSIVE\n         CLI   8(R5),C'E'         IS IT SO\n         BE    PRINT\n         MVC   13(4,R6),=CL4'RSVS'  NO,  RESERVE SHR\n         CLI   8(R5),C'R'         IS IT SO\n         BE    PRINT\n         MVC   13(4,R6),=CL4'RSVX'  NO,  RESERVE EXCL\nPRINT    STH   R4,WTOLIST         SET MESSAGE LENGTH\n         BAL   R11,IOCS           OUTPUT BUFFER\n         LA    R5,9(,R5)          NEXT ENTRY IN TABLE\n         BCT   R3,LOOP2           DO NEXT ENTRY, IF ANY\n         B     CLEANUP            FINISHED...\n*\nSETNAME  SR    R11,R11\n         IC    R11,1(,R5)         LENGTH OF MINOR NAME\n         LR    R4,R11\n         LA    R4,24(,R4)         TOTAL MESSAGE LENGTH\n         BCTR  R11,0              SET FOR EXECUTE INST\n         EX    R11,GETNAME        MOVE NAME INTO BUFFER\n         SR    R3,R9              DELETE NO. OF TABLE ENTRIES\n         SR    R8,R8              (NO. OF ENTRIES) X (SIZE OF ENTRY)\n         M     R8,=F'9'           PLUS CURRENT POINTER EQUAL\n         AR    R5,R9              NEXT TABLE ENTRY\n         B     GETOWNER           GET JOBNAME/USERID, ETC.\n         SPACE 2\n***********************************************************************\n*\n*        PRINT ONLY MAJOR QCB NAMES HERE\n*\n***********************************************************************\nLOOP3    EQU   *\nMAJONLY  LA    R4,17              SIZE OF MESSAGE\n         STH   R4,WTOLIST         PLACE IN CONTROL FIELD\n         MVI   BUFFER,C' '\n         MVC   BUFFER+1(64),BUFFER BLANK-OUT BUFFER\n         MVC   5(8,R6),0(R5)      GET MAJOR NAME FROM TABLE\n         BAL   R11,IOCS           WRITE IT OUT\n         LA    R5,8(,R5)          NEXT ENTRY IN TABLE,IF ANY\n         BCT   R3,LOOP3           GET IT, IF IT EXISTS\n         B     CLEANUP            FINISHED...\n         EJECT\n***********************************************************************\n*\n*        RELEASE ALL CORE AND EXIT\n*\n***********************************************************************\nCLEANUP  EQU   *\n         L     R1,CORE            START OF CORE TABLE\n         LH    R0,CORESIZE        SIZE OF TABLE\n         FREEMAIN R,LV=(0),A=(1)\n         SPACE 2\n         LH    R0,WKSIZE          SIZE OF WORK-AREA\n         LR    R1,R13             START OF WORK-AREA\n         L     R14,SAVA           SET RETURN ADDRESS\n         FREEMAIN R,LV=(0),A=(1)\n         SPACE 2\n         SR    R15,R15\n         BR    R14                RETURN\n         EJECT\n***********************************************************************\n*\n*        IOCS -- I/O CONTROL SECTION\n*\n*        ON ENTRY:\n*                 R4  = MESSAGE LENGTH+4 (INCLUDES WTO CONTROL BYTES)\n*                 R7  = TJID IN HIGH ORDER BYTES, IF IT EXISTS\n*                 R10 = CONSOL ID FOR MCS\n*                 R11 = RETURN ADDRESS\n*\n*        NOTE: OUTPUT BUFFER IS SETUP PRIOR TO ENTRY\n*\n***********************************************************************\nIOCS     DS    0H\n         SR   R7,R7\n         SPACE 2\n         SH    R4,=H'4'           STRIP OFF LENGTH OF CONTROL BYTES\n         LA    R1,BUFFER          START OF MESSAGE\n         OR    R4,R7              PUT TJID INTO LENGTH REGISTER\n         TPUT  (1),(4),R          OUTPUT MESSAGE TO TSO USER\n         BR    R11                RETURN\n         EJECT\n***********************************************************************\n*\n*        CONSTANTS, TABLES, ETC.\n*\n***********************************************************************\nMSGTABLE DS    0F                 MSGCODE\n         DC    A(*)                 0 - NOT USED\n         DC    A(MSG1-ENQ2LOAD)     4\n         DC    A(MSG2-ENQ2LOAD)     8\n         DC    A(MSG3-ENQ2LOAD)   12\n         DC    A(MSG4-ENQ2LOAD)   16\n         DC    A(MSG5-ENQ2LOAD)   20\n         DC    A(MSG6-ENQ2LOAD)   24\n         DC    A(MSG7-ENQ2LOAD)   28\n         DC    A(MSG8-ENQ2LOAD)   32\n         DC    A(MSG9-ENQ2LOAD)   36\n         DC    A(MSG10-ENQ2LOAD)  40\n         DC    A(MSG11-ENQ2LOAD)  44\n         DC    A(MSG12-ENQ2LOAD)  48\n*\nMSG1     DC    H'32',C'*** MAJOR NAME QCB NOT FOUND ***'\nMSG2     DC    H'37',C'*** ERROR IN MINOR QCB CHAIN ***'\nMSG3     DC    H'27',C'*** QEL CHAIN ERROR ***'\nMSG4     DC    H'46',C'*** NO FREE SQA CORE AVAILABLE...TRY AGAIN ***'\nMSG5     DC    H'42',C'*** INVALID MAJOR/MINOR NAME SPECIFIED ***'\nMSG6     DC    H'31',C'*** NO MINOR NAME SPECIFIED ***'\nMSG7     DC    H'32',C'*** MINOR NAME QCB NOT FOUND ***'\nMSG8     DC    H'54',C'*** LOST DATA...MAXIMUM NUMBER OF ENTRIES EXCEEDX\n               ED ***'\nMSG9     DC    H'30',C'  JOB/USER   MODE   MINOR NAME'\nMSG10    DC    H'31',C' ------------------------------'\nMSG11    DC    H'16',C'  MAJOR QCB NAME'\nMSG12    DC    H'17',C' ----------------'\n         SPACE 2\n         DS    0F\nSUB255   DC    X'FF000000'\nGETMSG   MVC   BUFFER(*-*),2(R5)\nGETNAME  MVC   BUFFER+20(*-*),2(R5)\n         SPACE 2\nWKDSECT  DSECT\nSAVA     DS    18F                SAVE-AREA\nXSASAVE  DS    F                  EXTENDED SAVE-AREA PTR\nCORE     DS    F                  POINTER TO FREE CORE\nMAJLGTH  DS    H                  MODIFIED LENGTH OF MAJOR NAME\nMINLGTH  DS    H                  MODFIED LENGTH OF MINOR NAME\nSWTCH    DS    H                  PROGRAM SWITCHES\nWKSIZE   DS    H                  SIZE OF WORK-AREA\nCORESIZE DS    H                  SIZE OF FREE CORE\nMSGCODE  DS    H                  I/O MESSAGE CODE\nTBLSIZE  DS    H                  NUMBER OF TABLE ENTRIES\nMAJNAM   DS    CL8                MAJOR NAME\nMINNAME  DS    CL255              MINOR NAME\nWTOLIST  DS    F                  WTO CONTROL BYTES\nBUFFER   DS    CL65               WTO MESSAGE BUFFER\nXCTLLIST DS    0F                 XCTL CONTROL INFO\nXCTLEP   DS    F                  ADDRESS OF EP PARAMETER\nXCTLDCB  DS    F                  DCB ADDRESS PARAMETER\nXCTLNAME DS    CL8                ENTRY POINT NAME\nLWKDSECT EQU   *-WKDSECT\n         SPACE 2\n         SPACE 2\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n         SPACE 2\n         END\n//LKED.SYSIN DD *\n NAME ENQ2LOAD(R)\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "EXPORT": {"ttr": 17164, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x00\\x7f\\x00\\x88\\x00\\x7f\\x12\\x00\\x00\\x19\\x00\\x19\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf2\\xf7\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-01-07T00:00:00", "modifydate": "1988-01-07T12:00:00", "lines": 25, "newlines": 25, "modlines": 0, "user": "FILE270"}, "text": "//KKX00155 JOB (2100,56-D),'KISER 2215 T',CLASS=H,TYPRUN=HOLD,TIME=3\n//JOBCAT DD DISP=SHR,DSN=SYS1.SOFTCAT\n//COPYS1   EXEC IEBCOPY\n//*\n//*  EXPORT THE SOURCE MODULES FOR WASH STATE MODS:\n//*\n//*  RUN JOB IN 'WDPSC.EXPORT.ALLOFEM(MERGEJCL)' BEFORE THIS ONE.\n//*\n//IN  DD DISP=SHR,DSN=WDPSC.EXPORT.ALLOFEM\n//*\n//OUT DD DISP=(NEW,KEEP),UNIT=TAPE16,VOL=(,RETAIN,SER=EXPORT),\n// LABEL=(1,BLP,EXPDT=98000),DCB=DEN=3\n//*\n C I=IN,O=OUT\n//*\n//*  EXPORT THE LOAD MODULES FOR WASH STATE MODS:\n//*\n//COPYS2   EXEC IEBCOPY\n//*\n//IN  DD DISP=SHR,DSN=WDPSC.EXPORT.LOAD\n//*\n//OUT DD DISP=(NEW,KEEP),UNIT=TAPE16,VOL=(,RETAIN,SER=EXPORT),\n// LABEL=(2,NL,EXPDT=98000),DCB=DEN=3\n//*\n C I=IN,O=OUT\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "EXTENTNO": {"ttr": 17409, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x00\\x7f\\x00\\x88\\x00\\x7f\\x12\\x00\\x02M\\x02M\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf2\\xf7\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-01-07T00:00:00", "modifydate": "1988-01-07T12:00:00", "lines": 589, "newlines": 589, "modlines": 0, "user": "FILE270"}, "text": "         PRINT ON,NOGEN\n         SPACE 3\n*\n*        OUTDATED    OUTDATED    OUTDATED    OUTDATED  !!!!\n*        --------    --------    --------    --------\n*\n*        THIS PROGRAM IS NO LONGER TO BE USED.  IT HAS BEEN REPLACED\n*        BY THE PROGRAM FILSPACE AND THEN THE PGM FILEATTR AND THE\n*        COMMAND FILEINFO INVOKES FILSPACE IN ORDER TO PRODUCE THE\n*        USED EXTENT NUMBER AND THE NUMBER OF USED TRACKS\n*\n*\n*\n*        THIS PROGRAM IS A SUBROUTINE MEANT TO BE CALLED FROM A CLIST\n*        WHICH ACCEPTS A DATASET NAME PASSED TO IT AND THEN PASSES\n*        BACK TO THE INVOKER THE NUMBER OF USED EXTENTS THAT HAS\n*        BEEN REACHED BY THE DATASET\n*\n*        TO CALL THIS PROGRAM FROM A CLIST, DO THE FOLLOWING:\n*\n*              CALL 'WDPSC.SHARED.LOAD(EXTENTNO)' '&DSN'\n*\n*                     WHERE &DSN CONTAINS THE DATASET NAME\n*\n*        HOWEVER; THIS PROGRAM CAN BE CALLED FROM A COBOL PROGRAM\n*\n*        TO CALL THIS PROGRAM FROM A COBOL PROGRAM, DO THE FOLLOWING:\n*\n*           MOVE YOUR DSNAME TO DSNAME OF EXTENTNO-I-O-AREA.\n*           MOVE THE LENGTH OF YOUR DSNAME TO DSNAME-LENGTH\n*               OF EXTENTNO-I-O-AREA.\n*\n*           CALL 'EXTENTNO' USING EXTENTNO-I-O-AREA.\n*\n*                WHERE:\n*\n*                      01  EXTENTNO-I-O-AREA.\n*                          05  DSNAME-LENGTH      PIC S9(3) COMP.\n*                          05  DSNAME             PIC X(44).\n*\n*\n*           AFTER THE CALL, RETURN CODE WILL CONTAIN:\n*\n*               .  THE NUMBER OF USED EXTENTS\n*             OR\n*               .  0091 IF THE DATASET IS NOT CATALOGUED\n*             OR\n*               .  0092 IF THE DATASET IS CONTAINED ON MORE THAN\n*                           ONE VOLUME\n*             OR\n*               .  0093 IF THE DATASET IS ON TAPE\n*             OR\n*               .  0094 IF THE REQUIRED VOLUME IS NOT MOUNTED\n*             OR\n*               .  0095 IF THE DATASET IS NOT FOUND ON VOLUME\n*                           INDICATED BY THE CATALOGUE\n*             OR\n*               .  0096 IF THE OBTAIN MACRO RETURNED WITH\n*                           RC = 12, 16, OR 20\n*             OR\n*               .  0097 IF AN ERROR IN VOL2DEVT WAS ENCOUNTERED\n*             OR\n*               .  0099 IF THE DSNAME PASSED TO THIS PROGRAM\n*                           IS INVALID\n         EJECT\n         SPACE 3\n*\n**********************************************\n*                                            *\n*        I N I T I A L I Z A T I O N         *\n*                                            *\n**********************************************\n*\nEXTENTNO CSECT\n         SAVE  (14,12)\n         BALR  12,0\n         USING *,12\n         ST    13,SAVEAREA+4\n         LA    13,SAVEAREA\n         B     STARTIT\n         SPACE\nSAVEAREA DC    18F'0'\n         SPACE 3\n********************************************************************\n*        EQUATE RESISTERS 0 THRU 15 TO MORE MEANINGFUL NAMES       *\n********************************************************************\n         SPACE 3\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n         EJECT\n         SPACE 3\n*\n********************************************************************\n*                                                                  *\n*        SAVE REGISTER 1 IN REGISTER 11 AND LOAD PARAMETER FIELD   *\n*        INTO PARMAREA                                             *\n*                                                                  *\n********************************************************************\n*\n         SPACE 3\nSTARTIT  DS    0D\n         LR    R11,R1              SAVE REGISTER 1 CONTENTS IN REG 11\n         L     R9,0(R11)\n         MVC   PARMAREA,0(R9)\n         EJECT\n         SPACE 3\n*\n********************************************************************\n*                                                                  *\n*        M A I N   L I N E   L O G I C                             *\n*                                                                  *\n********************************************************************\n*\n         MVC   PROCESSW,=CL3'YES'  MOVE 'YES' TO PROCESSW\n*\n         BAL   R14,LOKATE          PERFORM ROUTINE TO DO LOCATE\n         CLC   PROCESSW,=CL3'YES'  WERE ANY ERRORS ENCOUNTERED ?\n         BNE   GETOUT              IF SO, BRANCH TO GETOUT\n         BAL   R14,OBTANE          PERFORM ROUTINE TO DO OBTAIN\n         CLC   PROCESSW,=CL3'YES'  WERE ANY ERRORS ENCOUNTERED ?\n         BNE   GETOUT              IF SO, BRANCH TO GETOUT\n         BAL   R14,EYEDSCB1        PERFORM ROUTINE TO PROCESS THE DSCB1\n         CLC   PROCESSW,=CL3'YES'  WERE ANY ERRORS ENCOUNTERED ?\n         BNE   GETOUT              IF SO, BRANCH TO GETOUT\n         CLC   PROCDCB3,=CL3'YES'  DO WE NEED TO PROCESS THE DSCB3 ?\n         BNE   GETOUT              IF NOT, BRANCH TO GETOUT\n         BAL   R14,EYEDSCB3        PERFORM ROUTINE TO PROCESS THE DSCB3\nGETOUT   B     SHUTDOWN            BRANCH TO SHUTDOWN\n         EJECT\n         SPACE 3\n*\n********************************************************************\n*                                                                  *\n*        THIS ROUTINE IS RESPONSIBLE FOR DOING A LOCATE ON THE     *\n*        DATASET NAME                                              *\n*                                                                  *\n*        IF THE LOCATE MACRO ISSUES A RETURN CODE OF 0 AND         *\n*        THE DATASET IS CONTAINED ON ONLY ONE VOLUME AND THE       *\n*        DATASET IS NOT ON TAPE, THEN THIS ROUTINE MOVES 'YES'     *\n*        TO PROCESSW ELSE IT MOVES 'NO ' TO PROCESSW               *\n*                                                                  *\n********************************************************************\n*\nLOKATE   ST    R14,SAVEIT1\n         LH    R8,PARMLEN             R8==> LENGTH OF PARM DSNAME\nLOCTEST1 CH    R8,=H'3'               IS THE LENGTH OF THE PARM\n*                                       DATASET NAME GT 3 ?\n         BH    LOCTEST2               IF SO, BRANCH TO LOCTEST2\n         LA    R10,99                 R10==> 99\n         MVC   PROCESSW,=CL3'NO '     MOVE 'NO ' TO PROCESSW\n         B     EXITLOC                BRANCH TO EXITLOC\nLOCTEST2 CH    R8,=H'44'              IS THE LENGTH OF THE PARM\n*                                       DATASET NAME LE 44 ?\n         BNH   LOADCAM                IF SO, BRANCH TO LOADCAM\n         LA    R10,99                 R10==> 99\n         MVC   PROCESSW,=CL3'NO '     MOVE 'NO ' TO PROCESSW\n         B     EXITLOC                BRANCH TO EXITLOC\nLOADCAM  MVI   CAMDSN,C' '            A BLANK\n         MVC   CAMDSN+1(43),CAMDSN    SPREAD IT AROUND\n         LA    R1,CAMDSN              R1 ==> ADDRESS OF CAMDSN\n         LA    R8,PARMDSN             R8 ==> ADDRESS OF PARMDSN\n         LH    R7,PARMLEN             R7 ==> LENGTH OF THE DSN\n         S     R7,=F'1'               SUBTRACT 1 FOR EX\n         SPACE 1\nMOVEDSN  MVC   0(0,R1),0(R8)          MOVE THE PARM DSN TO CAMDSN\n         EX    R7,MOVEDSN\n         SPACE 1\nLOKAYT   LOCATE CAMLIST1\n         SPACE 2\n         C     R15,=F'0'              IS DATASET CATALOGUED ?\n         BE    CATLGD                 IF SO, BRANCH TO CATLGD\n         LA    R10,91                 R10==> 91\n         MVC   PROCESSW,=CL3'NO '     MOVE 'NO ' TO PROCESSW\n         B     EXITLOC                BRANCH TO EXITLOC\nCATLGD   CLC   LOCAREA(2),=XL2'0001'  VERIFY THAT THE NUMBER OF\n*                                        VOLUMES COUNT IS 1\n         BE    VOLCNT1                IF YES, BRANCH TO VOLCNT1\n         LA    R10,92                 R10==> 92\n         MVC   PROCESSW,=CL3'NO '     MOVE 'NO ' TO PROCESSW\n         B     EXITLOC                BRANCH TO EXITLOC\nVOLCNT1  MVC   OBTVOL,LOCAREA+6       LOAD OBTVOL FROM CAMLST WORKAREA\n         CLI   LOCAREA+4,X'80'        COMPARE LOCAREA+4 TO BE EQUAL\n*                                       TO HEXADECIMAL 80  (THIS\n*                                       INDICATES THAT THE DATASET\n*                                       IS ON TAPE)\n         BNE   EXITLOC                IF NOT; BRANCH TO EXITLOC\n         LA    R10,93                 R10==> 93\n         MVC   PROCESSW,=CL3'NO '     MOVE 'NO ' TO PROCESSW\nEXITLOC  L     R14,SAVEIT1\n         BR    14                     RETURN\n         EJECT\n         SPACE 3\n*\n********************************************************************\n*                                                                  *\n*        THIS ROUTINE IS RESPONSIBLE FOR DOING AN OBTAIN ON THE    *\n*        DATASET NAME                                              *\n*                                                                  *\n*        IF THE OBTAIN MACRO ISSUES A RETURN CODE OF 0, THEN       *\n*        THIS ROUTINE MOVES 'YES' TO PROCESSW ELSE IT MOVES        *\n*        'NO ' TO PROCESSW                                         *\n*                                                                  *\n********************************************************************\n*\nOBTANE   ST    R14,SAVEIT2\nOBTAAN   OBTAIN CAMLIST2\n         SPACE 2\n         C     R15,=F'0'              COMPARE REG 15 TO BE = 0\n         BE    EXITOBT                IF REG 15=0, BRANCH TO EXITOBT\n         C     R15,=F'4'              COMPARE REG 15 TO BE = 4\n         BE    RCODE4                 IF REG 15=4, BRANCH TO RCODE4\n         C     R15,=F'8'              COMPARE REG 15 TO BE = 8\n         BE    RCODE8                 IF REG 15=8, BRANCH TO RCODE8\n         LA    R10,96                 R10==> 96\n         B     MOVENOPE               BRANCH TO MOVENOPE\nRCODE4   LA    R10,94                 R10==> 94\n         B     MOVENOPE               BRANCH TO MOVENOPE\nRCODE8   LA    R10,95                 R10==> 95\nMOVENOPE MVC   PROCESSW,=CL3'NO '     MOVE 'NO ' TO PROCESSW\nEXITOBT  L     R14,SAVEIT2\n         BR    14                     RETURN\n         EJECT\n         SPACE 3\n*\n********************************************************************\n*                                                                  *\n*        THIS ROUTINE IS RESPONSIBLE FOR PROCESSING THE DSCB1.     *\n*                                                                  *\n*        IF AN ERROR IS ENCOUNTERED, THIS ROUTINE DOES THE         *\n*        FOLLOWING:                                                *\n*                                                                  *\n*             .  MOVES 'NO ' TO PROCESSW                           *\n*             .  MOVES APPROPRIATE 9X VALUE TO REGISTER 10         *\n*                   WHICH IDENTIFIES THE REASON FOR THE ERROR      *\n*                                                                  *\n*        IF NO ERROR IS ENCOUNTERED AND THIS ROUTINE CALCULATES    *\n*        THAT THE USED EXTENTS DOES NOT EXCEED 3 (HENCE THERE      *\n*        IS NO DSCB3), THEN THIS ROUTINE DOES THE FOLLOWING:       *\n*                                                                  *\n*             .  MOVES 'NO ' TO PROCDCB3                           *\n*             .  MOVES APPROPRIATE VALUE TO REGISTER 10            *\n*                   (I.E 1, 2 OR 3)                                *\n*                                                                  *\n*        IF NO ERROR IS ENCOUNTERED AND THIS ROUTINE CALCULATES    *\n*        THAT THE USED EXTENTS DOES EXCEED 3 AND THAT IT NEEDS TO  *\n*        PROCESS THE DSCB3, THEN THIS ROUTINE DOES THE FOLLOWING:  *\n*                                                                  *\n*             .  MOVES 'YES' TO PROCDCB3                           *\n*             .  MOVES 3 TO REGISTER 10                            *\n*                   (TO BE ADDED TO IN EYEDSCB3)                   *\n*                                                                  *\n********************************************************************\n*\nEYEDSCB1 ST    R14,SAVEIT3\n*\n         MVC   PROCDCB3,=CL3'NO '  MOVE 'NO ' TO PROCDCB3\n         LA    R10,0               R10 ==> 0\n         ZAP   RUNTOT,PACKED0      RUNTOT = 0\n*\n         MVC   DS1LSTAR,OBTAREA+54   ---\n         MVC   HALFWORD(2),DS1LSTAR    ---\n         LH    R5,HALFWORD               ---- LSTRTRKS IS IN PACKED\n         CVD   R5,CVDOPRND              ---   DECIMAL AND CONTAINS\n         MVC   LSTRTRKS(3),CVDOPRND+5 ---     TOTAL NO OF USED TRACKS\n         MVC   VOLSER,OBTVOL\n*\n         CLI   OBTAREA+61,X'00'    IS 1ST EXTENT DESC INSIGNIFICANT ?\n         BE    EXITDCB1            IF SO, BRANCH TO EXITDCB1\n         LA    R10,1               R10 ==> 1\n         MVC   BGNCCHH(4),OBTAREA+63\n         MVC   ENDCCHH(4),OBTAREA+67\n         BAL   R14,CALCTRKS        PERFORM ROUTINE TO CALCULATE\n*                                  NUMBER OF TRACKS USED IN THIS EXTENT\n         CLC   PROCESSW,=CL3'YES'  WERE ANY ERRORS ENCOUNTERED ?\n         BNE   EXITDCB1            IF SO, BRANCH TO EXITDCB1\n         AP    RUNTOT,TOTRACKS     RUNTOT = TOTAL NUMBER OF USED TRACKS\n*                                      TO THIS POINT\n         CP    LSTRTRKS,RUNTOT     DOES THIS EXTENT PUT US PAST THE\n*                                      DS1LSTAR VALUE ?\n         BL    EXITDCB1            IF SO, BRANCH TO EXITDCB1\n         CLI   OBTAREA+71,X'00'    IS 2ND EXTENT DESC INSIGNIFICANT ?\n         BE    EXITDCB1            IF SO, BRANCH TO EXITDCB1\n         LA    R10,2               R10 ==> 2\n         MVC   BGNCCHH(4),OBTAREA+73\n         MVC   ENDCCHH(4),OBTAREA+77\n         BAL   R14,CALCTRKS        PERFORM ROUTINE TO CALCULATE\n*                                  NUMBER OF TRACKS USED IN THIS EXTENT\n         CLC   PROCESSW,=CL3'YES'  WERE ANY ERRORS ENCOUNTERED ?\n         BNE   EXITDCB1            IF SO, BRANCH TO EXITDCB1\n         AP    RUNTOT,TOTRACKS     RUNTOT = TOTAL NUMBER OF USED TRACKS\n*                                      TO THIS POINT\n         CP    LSTRTRKS,RUNTOT     DOES THIS EXTENT PUT US PAST THE\n*                                      DS1LSTAR VALUE ?\n         BL    EXITDCB1            IF SO, BRANCH TO EXITDCB1\n         CLI   OBTAREA+81,X'00'    IS 3RD EXTENT DESC INSIGNIFICANT ?\n         BE    EXITDCB1            IF SO, BRANCH TO EXITDCB1\n         LA    R10,3               R10 ==> 3\n         MVC   BGNCCHH(4),OBTAREA+83\n         MVC   ENDCCHH(4),OBTAREA+87\n         BAL   R14,CALCTRKS        PERFORM ROUTINE TO CALCULATE\n*                                  NUMBER OF TRACKS USED IN THIS EXTENT\n         CLC   PROCESSW,=CL3'YES'  WERE ANY ERRORS ENCOUNTERED ?\n         BNE   EXITDCB1            IF SO, BRANCH TO EXITDCB1\n         AP    RUNTOT,TOTRACKS     RUNTOT = TOTAL NUMBER OF USED TRACKS\n*                                      TO THIS POINT\n         CP    LSTRTRKS,RUNTOT     DOES THIS EXTENT PUT US PAST THE\n*                                      DS1LSTAR VALUE ?\n         BL    EXITDCB1            IF SO, BRANCH TO EXITDCB1\n         MVC   PROCDCB3,=CL3'YES'  MOVE 'YES' TO PROCDCB3\n         MVC   CCHHR,OBTAREA+91    MOVE CCHHR PTR FOR DSCB3 TO CCHHR\nEXITDCB1 L     R14,SAVEIT3\n         BR    14                  RETURN\n         EJECT\n         SPACE 3\n*\n********************************************************************\n*                                                                  *\n*        THIS ROUTINE IS RESPONSIBLE FOR PROCESSING THE DSCB3      *\n*        AND THEN GENERATING THE EXTENT NUMBER WHICH IS TO BE      *\n*        CONTAINED IN REGISTER 10.                                 *\n*                                                                  *\n********************************************************************\n*\nEYEDSCB3 ST    R14,SAVEIT4\nDODSCB3  OBTAIN CAMLIST3\n         SPACE 2\n         C     R15,=F'0'              COMPARE REG 15 TO BE = 0\n         BE    COUNTEM                IF REG 15=0, BRANCH TO COUNTEM\n         C     R15,=F'4'              COMPARE REG 15 TO BE = 4\n         BE    DSCB3RC4               IF REG 15=4, BRANCH TO DSCB3RC4\n         C     R15,=F'8'              COMPARE REG 15 TO BE = 8\n         BE    DSCB3RC8               IF REG 15=8, BRANCH TO DSCB3RC8\n         LA    R10,96                 R10==> 96\n         B     EXITDCB3               BRANCH TO EXITDCB3\nDSCB3RC4 LA    R10,94                 R10==> 94\n         B     EXITDCB3               BRANCH TO EXITDCB3\nDSCB3RC8 LA    R10,95                 R10==> 95\n         B     EXITDCB3               BRANCH TO EXITDCB3\nCOUNTEM  LA    R5,DCB3AREA            R5 ==> ADDRESS OF DSCB3\n         A     R5,=F'4'               OFFSET TO DS3EXTNT\n         LA    R6,1\nLOOP3A   C     R6,=F'4'\n         BH    NXTGROUP\n         CLI   0(R5),X'00'\n         BE    EXITDCB3\n         A     R10,=F'1'\n         MVC   BGNCCHH(4),2(R5)\n         MVC   ENDCCHH(4),6(R5)\n         BAL   R14,CALCTRKS        PERFORM ROUTINE TO CALCULATE\n*                                  NUMBER OF TRACKS USED IN THIS EXTENT\n         CLC   PROCESSW,=CL3'YES'  WERE ANY ERRORS ENCOUNTERED ?\n         BNE   EXITDCB3            IF SO, BRANCH TO EXITDCB3\n         AP    RUNTOT,TOTRACKS     RUNTOT = TOTAL NUMBER OF USED TRACKS\n*                                      TO THIS POINT\n         CP    LSTRTRKS,RUNTOT     DOES THIS EXTENT PUT US PAST THE\n*                                      DS1LSTAR VALUE ?\n         BL    EXITDCB3            IF SO, BRANCH TO EXITDCB3\n         A     R6,=F'1'\n         A     R5,=F'10'\n         B     LOOP3A\nNXTGROUP A     R5,=F'1'            OFFSET TO DS3ADEXT\n         LA    R6,1\nLOOP3B   C     R6,=F'9'\n         BH    EXITDCB3\n         CLI   0(R5),X'00'\n         BE    EXITDCB3\n         A     R10,=F'1'\n         MVC   BGNCCHH(4),2(R5)\n         MVC   ENDCCHH(4),6(R5)\n         BAL   R14,CALCTRKS        PERFORM ROUTINE TO CALCULATE\n*                                  NUMBER OF TRACKS USED IN THIS EXTENT\n         CLC   PROCESSW,=CL3'YES'  WERE ANY ERRORS ENCOUNTERED ?\n         BNE   EXITDCB3            IF SO, BRANCH TO EXITDCB3\n         AP    RUNTOT,TOTRACKS     RUNTOT = TOTAL NUMBER OF USED TRACKS\n*                                      TO THIS POINT\n         CP    LSTRTRKS,RUNTOT     DOES THIS EXTENT PUT US PAST THE\n*                                      DS1LSTAR VALUE ?\n         BL    EXITDCB3            IF SO, BRANCH TO EXITDCB3\n         A     R6,=F'1'\n         A     R5,=F'10'\n         B     LOOP3B\nEXITDCB3 L     R14,SAVEIT4\n         BR    14                  RETURN\n         EJECT\n         SPACE 1\n***********************************************************************\n*                                                                     *\n*        THIS ROUTINE CALCULATES THE NUMBER OF TRACKS GIVEN           *\n*        A BEGINNING CCHH, AN ENDING CCHH AND THE VOLUME SERIAL       *\n*        NUMBER                                                       *\n*                                                                     *\n*        BEFORE PERFORMING THIS ROUTINE, DO THE FOLLOWING:            *\n*                   MOVE THE BEGINNING CCHH TO BGNCCHH                *\n*                   MOVE THE ENDING CCHH TO ENDCCHH                   *\n*                   MOVE THE VOL SER TO VOLSER                        *\n*                                                                     *\n*        AFTER PERFORMING THIS ROUTINE, THE NUMBER OF USED            *\n*        TRACKS WILL BE IN TOTRACKS                                   *\n*                                                                     *\n***********************************************************************\n*\nCALCTRKS ST    R14,SAVEIT5        STORE R14 CONTENTS IN SAVEIT5\n         LH    R7,BGNCCHH              ----\n         CVD   R7,CVDOPRND               ----- PACK BEGINNING CYL\n         MVC   BEGINCYL(3),CVDOPRND+5  ----\n         LH    R7,ENDCCHH              ----\n         CVD   R7,CVDOPRND               ----- PACK ENDING CYL\n         MVC   ENDCYL(3),CVDOPRND+5    ----\n         LH    R7,BGNCCHH+2            ----\n         CVD   R7,CVDOPRND               ----- PACK BEGINNING TRK\n         MVC   BEGINTRK(3),CVDOPRND+5  ----\n         LH    R7,ENDCCHH+2            ----\n         CVD   R7,CVDOPRND               ----- PACK ENDING TRK\n         MVC   ENDTRK(3),CVDOPRND+5    ----\n         ZAP   CYLDIFF,ENDCYL          CYLDIFF = ENDING CYL #\n         SP    CYLDIFF,BEGINCYL        CYLDIFF = ENDING CYL - BEGIN CYL\n         BAL   14,DETRKCYL             THIS ROUTINE EXAMINES VOL SER\n*                                          TO DETERMINE THE # OF TRACKS\n*                                          PER CYLINDER AND PLACES THE\n*                                          ANSWER IN TRKPRCYL\n         CP    ENDTRK,BEGINTRK         IF ENDING TRK # > BEGINNING TRK\n         BH    ENDISGT                    # THEN BRANCH TO ENDISGT\n         ZAP   TRKDIFF,ENDTRK          TRKDIFF = ENDING TRACK #\n         SP    TRKDIFF,BEGINTRK        TRKDIFF = ENDING TRK - BEGIN TRK\n         AP    TRKDIFF,PACKED1         ADD 1 TO TRKDIFF\n         B     DOCALC                  BRANCH TO DOCALC\nENDISGT  SP    CYLDIFF,PACKED1         SUBTRACT 1 FROM CYLDIFF\n         ZAP   REMANTRK,TRKPRCYL       REMANTRK = TRKPRCYL\n         SP    REMANTRK,BEGINTRK       REMANTRK = TRKPRCYL - BEGINTRK\n         ZAP   TRKDIFF,REMANTRK        TRKDIFF = REMANTRK\n         AP    TRKDIFF,ENDTRK          TRKDIFF = REMANTRK + ENDTRK\n         AP    TRKDIFF,PACKED1         ADD 1 TO TRKDIFF\nDOCALC   ZAP   TOTRACKS,TRKPRCYL       TOTRACKS = TRKPRCYL\n         MP    TOTRACKS,CYLDIFF        TOTRACKS = TRKPRCYL X CYLDIFF\n         AP    TOTRACKS,TRKDIFF        ADD TRKDIFF TO TOTRACKS\n         L     R14,SAVEIT5\n         BR    R14                     RETURN\n         EJECT\n         SPACE 3\n***********************************************************************\n*                                                                     *\n*        THIS ROUTINE EXAMINES VOL SER TO DETERMINE THE DEVICE TYPE   *\n*        IN ORDER TO DETERMINE THE NUMBER OF TRACKS PER CYLINDER      *\n*                                                                     *\n*        BEFORE PERFORMING THIS ROUTINE, MOVE THE VOLUME SERIAL       *\n*        NUMBER TO VOLSER                                             *\n*                                                                     *\n*        AFTER PERFORMING THIS ROUTINE, THE NUMBER OF TRACKS PER      *\n*        CYLINDER IS IN TRKPRCYL                                      *\n*                                                                     *\n*        IF AN ERROR IS ENCOUNTERED IN THIS ROUTINE, IT WILL          *\n*        MOVE 'NO ' TO PROCESSW AND LOAD REGISTER 10 WITH 97          *\n*                                                                     *\n***********************************************************************\n*\nDETRKCYL ST    R14,SAVEIT6        STORE R14 CONTENTS IN SAVEIT6\n         MVC   INVOL,VOLSER       MOVE VOL SER TO INVOL\n         CALL  VOL2DEVT,(DEVTAREA),VL\n         C     R15,=F'0'          WAS VOL2DEVT SUCCESSFUL ?\n         BE    EYEDEVT            IF SO, BRANCH TO EYEDEVT\n         MVC   PROCESSW,=CL3'NO ' MOVE 'NO ' TO PROCESSW\n         LA    R10,97             R10 ==> 97\n         B     EXITDETR           BRANCH TO EXITDETR\nEYEDEVT  CLC   OUTDEVT(4),=CL4'3330'\n         BE    D3330\n         CLC   OUTDEVT(4),=CL4'3350'\n         BE    D3350\n         CLC   OUTDEVT(4),=CL4'3380'\n         BE    D3380\n         MVC   PROCESSW,=CL3'NO ' MOVE 'NO ' TO PROCESSW\n         LA    R10,97             R10 ==> 97\n         B     EXITDETR           BRANCH TO EXITDETR\nD3330    ZAP   TRKPRCYL,PACKED19  MOVE 19 TO TRKPRCYL\n         B     EXITDETR           BRANCH TO EXITDETR\nD3350    ZAP   TRKPRCYL,PACKED30  MOVE 30 TO TRKPRCYL\n         B     EXITDETR           BRANCH TO EXITDETR\nD3380    ZAP   TRKPRCYL,PACKED15  MOVE 15 TO TRKPRCYL\nEXITDETR L     R14,SAVEIT6\n         BR    R14                RETURN\n         EJECT\n         SPACE 3\n*\n********************************************************************\n*                                                                  *\n*        E N D  O F   J O B   P R O C E S S I N G                  *\n*                                                                  *\n********************************************************************\n*\nSHUTDOWN LR    R15,R10\n         L     R13,4(R13)\n         RETURN (14,12),RC=(15)\n         EJECT\n         SPACE 3\n*\n********************************************************************\n*                                                                  *\n*        BREAKDOWN OF PARMAREA                                     *\n*                                                                  *\n********************************************************************\n*\n         DS    0F\nPARMAREA DS    0CL46\nPARMLEN  DS    CL2\nPARMDSN  DS    CL44\n         EJECT\n         SPACE 3\n*\n********************************************************************\n*                                                                  *\n*        V O L 2 D E V T   L I N K A G E   A R E A                 *\n*                                                                  *\n********************************************************************\n*\nDEVTAREA DS    0CL16\nINVOL    DS    CL6\nOUTDEVT  DS    CL8\nOUTLEN   DS    CL2\n         EJECT\n         SPACE 3\n*\n********************************************************************\n*                                                                  *\n*        D A T A   A R E A S                                       *\n*                                                                  *\n********************************************************************\n*\n         SPACE 3\n         DS    0F\nSAVEIT1  DS    F\nSAVEIT2  DS    F\nSAVEIT3  DS    F\nSAVEIT4  DS    F\nSAVEIT5  DS    F\nSAVEIT6  DS    F\n         DS    0F\nCAMDSN   DS    CL44\nCAMLIST1 CAMLST NAME,CAMDSN,,LOCAREA\nLOCAREA  DS    0D\n         DS    265C\n         DS    0D\nCAMLIST2 CAMLST SEARCH,CAMDSN,OBTVOL,OBTAREA\nOBTAREA  DS    0D\n         DS    140C\n         DS    0D\nOBTVOL   DS    CL6\n         DS    0D\nCAMLIST3 CAMLST SEEK,CCHHR,OBTVOL,DCB3AREA\nDCB3AREA DS    0D\n         DS    140C\nPROCESSW DS    CL3\nPROCDCB3 DS    CL3\nCCHHR    DS    CL5\nBEGINCYL DS    PL3\nBEGINTRK DS    PL3\nBGNCCHH  DS    F\nCVDOPRND DS    D\nCYLDIFF  DS    PL3\nDS1LSTAR DS    CL3\nENDCCHH  DS    F\nENDCYL   DS    PL3\nENDTRK   DS    PL3\nHALFWORD DS    H\nLSTRTRKS DS    PL3\nPACKED0  DC    PL2'0'\nPACKED1  DC    PL2'1'\nPACKED15 DC    PL2'15'\nPACKED19 DC    PL2'19'\nPACKED30 DC    PL2'30'\nREMANTRK DS    PL3\nRUNTOT   DS    PL6\nTOTRACKS DS    PL6\nTRKDIFF  DS    PL3\nTRKPRCYL DS    PL3\nVOLSER   DS    CL6\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "FILEATT$": {"ttr": 17665, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x00\\x7f\\x00\\x88\\x00\\x7f\\x12\\x00\\x00\\x8c\\x00\\x8c\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf2\\xf7\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-01-07T00:00:00", "modifydate": "1988-01-07T12:00:00", "lines": 140, "newlines": 140, "modlines": 0, "user": "FILE270"}, "text": "1                                                        FILEATTR.1\n                                                         06/25/82\n\n\n  PROGRAM:       FILEATTR\n  AUTHOR:        Jeff Sprehn\n  AGENCY:        WDPSC\n  LANGUAGE:      Assembler\n  LOCATION:      WDPSC.SHARED.LOAD\n  FUNCTION:      Subroutine to obtain volume  serial number, LRECL,\n                 BLKSIZE, DSORG, record format,  and device type of\n                 dataset given the dataset  name (and volume serial\n                 number  if  not  cataloged)   from  a  high  level\n                 language program.\n\n  RUN MODE:      Batch or interactive.\n\n  HOW TO USE THIS PROGRAM:\n\n  The following data areas are REQUIRED in WORKING STORAGE:\n\n       01   IN-DSN                   PIC X(44).\n       01   OUT-VALID-SWITCH         PIC X(3).\n       01   OUT-ERROR-MSG            PIC X(30).\n       01   UT-VOLSER                PIC X(6).\n       01   OUT-LRECL                PIC 9(5).\n       01   OUT-BLKSIZE              PIC 9(5).\n       01   OUT-DSORG                PIC X(2).\n       01   OUT-REC-FORMAT           PIC X.\n       01   OUT-DEVICE               PIC X.\n\n  The following data  area is OPTIONAL.  It  is to be used  if your\n  dataset is not cataloged:\n\n       01   IN-VOLSER                PIC X(6).\n\n\n\n\n1                                                        FILEATTR.2\n                                                         06/25/82\n\n\n  In the PROCEDURE DIVISION:\n\n       If your dataset IS cataloged\n            MOVE your dataset name to IN-DSN.\n\n            CALL 'FILEATTR' USING IN-DSN\n                             OUT-VALID-SWITCH\n                             OUT-ERROR-MSG\n                             OUT-VOLSER\n                             OUT-LRECL\n                             OUT-BLKSIZE\n                             OUT-DSORG\n                             OUT-REC-FORMAT\n                             OUT-DEVICE.\n\n  If your dataset is NOT cataloged\n       MOVE your dataset name to IN-DSN.\n       MOVE your volume serial number to IN-VOLSER.\n\n       CALL 'FILEATTR' USING IN-DSN\n                             OUT-VALID-SWITCH\n                             OUT-ERROR-MSG\n                             OUT-VOLSER\n                             OUT-LRECL\n                             OUT-BLKSIZE\n                             OUT-DSORG\n                             OUT-REC-FORMAT\n                             OUT-DEVICE\n                            IN-VOLSER.\n\n\n\n\n1                                                        FILEATTR.3\n                                                         09/01/83\n\n\n  After the call, interrogate OUT-VALID-SWITCH.\n\n  If OUT-VALID-SWITCH  is not  equal to  'YES', then  OUT-ERROR-MSG\n  contains  the  reason  for  the  error  (such  as  data  set  not\n  cataloged)  and the  other parameters  are  not generated  except\n  possibly OUT-DEVICE.\n\n  If  OUT-VALID-SWITCH  is  equal  to  'YES',  then  the  following\n  parameters are generated with the contents as shown:\n\n          PARAMETER                   CONTENTS\n       ----------------    ------------------------------\n\n       OUT-VALID-SWITCH    'YES'\n       OUT-ERROR-MSG       Spaces\n       OUT-VOLSER          Volume Serial Number\n       OUT-LRECL           LRECL\n       OUT-BLKSIZE         BLKSIZE\n       OUT-DSORG           DSORG\n       OUT-RECFM           'F' for fixed length records\n                           'U' for undefined records\n                           'V' for variable length records\n       OUT-DEVICE          'T' data set is on tape\n                           'D' data set is on disk\n\n  NOTE:  If you wish to make all calls to FILEATTR with the same\n         number of parameters, and your dataset is cataloged, then\n         move 'ABSENT' to IN-VOLSER.\n\n\n\n\n1                                                        FILEATTR.4\n                                                         09/01/83\n\n\n  There  are  17 possible  error  messages  that this  program  can\n  produce which is stored in OUT-ERROR-MSG.  They are:\n\n       'DATASET NOT CATALOGED'\n       'FILE IS ON MORE THAN 1 VOLUME'\n       'REQUIRED VOLUME NOT MOUNTED'\n       'FORMAT-1 DSCB NOT FOUND ON VOL'\n       'OBTAIN MACRO RETURNED RC 12/16'\n       'INVALID SYNTAX FOR DSNAME'\n       'PROBLEM IN BAL PGM FILEATTR'\n       'MEMBER NAME NOT FOUND'\n       'UNSUCCESSFUL DYNAMIC ALLOCATION'\n       'I/O ERROR READING DIRECTORY'\n       'UNSUCCESSFUL FREE OF DDNAME'\n       'MEMBER NAME TOO LONG'\n       'INVALID MEMBER NAME'\n       'DATASET IS ON TAPE'\n       'INVALID VOL SER GIVEN'\n       'DATASET NOT PARTITIONED'\n       'DATASET IS NOT A GDG'\n\n\n\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "FILEATTR": {"ttr": 17668, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x00\\x7f\\x00\\x88\\x00\\x7f\\x12\\x00\\x02\\x91\\x02\\x91\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf2\\xf7\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-01-07T00:00:00", "modifydate": "1988-01-07T12:00:00", "lines": 657, "newlines": 657, "modlines": 0, "user": "FILE270"}, "text": "*          DATA SET 764FILATTR AT LEVEL 008 AS OF 11/24/82\n         SPACE 3\n********************************************************************\n*        SAVE REGISTERS AND ESTABLISH REGISTER 12 AS BASE REGISTER *\n********************************************************************\n         SPACE 3\nFILEATTR START\n         SAVE  (14,12),,*\n         LR    12,15\n         USING FILEATTR,12\n         ST    13,SAVEAREA+4\n         LA    13,SAVEAREA\n         B     STARTIT\n         SPACE\nSAVEAREA DC    18F'0'\n         SPACE 3\n********************************************************************\n*        EQUATE RESISTERS 0 THRU 15 TO MORE MEANINGFUL NAMES       *\n********************************************************************\n         SPACE 3\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n         EJECT\n         SPACE 3\n********************************************************************\n*        INITIALIZATION AND ESTABLISHING DATA AREAS                *\n*        CONTAINING OUR PARAMETERS                                 *\n********************************************************************\n         SPACE 3\nSTARTIT  DS    0D\n         LR    R11,R1         SAVE REG 1 CONTENTS IN REG 11\n         L     R9,0(R11)\n         MVC   INDSN,0(R9)    PUT PARAMETER #1 INTO INDSN\n         TM    32(R11),X'80'  IS DEVICE THE LAST PARAMETER PROVIDED?\n         BO    NOINVOL        IF SO, BRANCH TO NOINVOL\n         L     R9,36(R11)     PUT PARAMETER #10 INTO INVOL\n         MVC   INVOL,0(R9)\n         B     MAINLINE       BRANCH TO MAINLINE\nNOINVOL  MVC   INVOL,=CL6'ABSENT'\n         EJECT\n         SPACE 3\n********************************************************************\n*        MAIN LINE LOGIC                                           *\n********************************************************************\n         SPACE 3\nMAINLINE MVI   VOLSER,C' '\n         MVC   VOLSER+1(5),VOLSER     MOVE SPACES TO VOLSER\n         MVI   LRECL,C' '\n         MVC   LRECL+1(4),LRECL       MOVE SPACES TO LRECL\n         MVI   BLKSIZE,C' '\n         MVC   BLKSIZE+1(4),BLKSIZE   MOVE SPACES TO BLKSIZE\n         MVI   DSORG,C' '\n         MVC   DSORG+1(1),DSORG       MOVE SPACES TO DSORG\n         MVI   RECFM,C' '             MOVE SPACE TO RECFM\n         BAL   R14,BREAKDSN           PERFORM ROUTINE TO BREAKDOWN\n*                                       DSNAME FIELD INTO AN 8 BYTE\n*                                       MEMBER NAME AND A 44 BYTE DSN\n         SPACE 1\n         CLC   VALIDSW(3),YESS        IS VALIDSW = 'YES'?\n         BNE   SHUTDOWN               IF NOT, BRANCH TO SHUTDOWN\n         SPACE 2\n         CLC   INVOL,=C'ABSENT'       IS INVOL = 'ABSENT' ?\n         BE    LOKAYT                 IF YES, BRANCH TO LOKAYT\n         BAL   R14,EDITVOL            EDIT INVOL\n         CLC   GOODVOL,=CL3'YES'      WAS INVOL VALID ?\n         BE    MOVEVOL                IF SO, BRANCH TO MOVEVOL\n         MVC   ERRMSG(30),MESS16      MOVE 'INVALID VOL SER GIVEN'\n*                                       TO ERRMSG\n         MVC   VALIDSW(3),NOPE        MOVE 'NO ' TO VALIDSW\n         B     SHUTDOWN               BRANCH TO SHUTDOWN\nMOVEVOL  MVC   OBTVOL,INVOL           MOVE INVOL TO OBTVOL\n         B     OBTANE                 BRANCH TO OBTANE\nLOKAYT   LOCATE CAMLIST1\n         SPACE 2\n         C     R15,=F'0'              COMPARE REG 15 TO BE = 0\n         BE    RC0                    IF REG 15=0, BRANCH TO RC0\n         MVC   ERRMSG(30),MESS1       MOVE 'DATASET NOT CATALOGED'\n*                                       TO ERRMSG\n         MVC   VALIDSW(3),NOPE        MOVE 'NO ' TO VALIDSW\n         B     SHUTDOWN               BRANCH TO SHUTDOWN\nRC0      CLC   BRKGDG,YESS            IS IT IN GDG EXPRESSED FORMAT ?\n         BNE   CHKVOLCT               IF NOT, BRANCH TO CHKVOLCT\n         BAL   R14,DSNSUFFX           PERFORM A ROUTINE TO DETERMINE\n*                                        IF THIS DATASET IS A GDG ENTRY\n         CLC   ISITAGDG,YESS          IS THE DATASET A GDG ?\n         BE    CHKVOLSR               IF SO, BRANCH TO CHKVOLSR\n         MVC   ERRMSG(30),MESS18      MOVE 'DATASET IS NOT A GDG'\n*                                       TO ERRMSG\n         MVC   VALIDSW(3),NOPE        MOVE 'NO ' TO VALIDSW\n         B     SHUTDOWN               BRANCH TO SHUTDOWN\nCHKVOLSR CLC   LOCAREA+6(6),=XL6'000000000000'\n         BNE   CHKVOLCT\n         MVC   ERRMSG(30),MESS1       MOVE 'DATASET NOT CATALOGUED'\n*                                       TO ERRMSG\n         MVC   VALIDSW(3),NOPE        MOVE 'NO ' TO VALIDSW\n         B     SHUTDOWN               BRANCH TO SHUTDOWN\nCHKVOLCT CLC   LOCAREA(2),HEX0001     VERIFY THAT THE NUMBER OF\n*                                        VOLUMES COUNT IS 1\n         BE    MATCH                  IF YES, BRANCH TO MATCH\n         MVC   VALIDSW(3),NOPE        MOVE 'NO ' TO VALIDSW\n         MVC   ERRMSG(30),MESS2       MOVE 'FILE IS ON MORE THAN\n*                                       1 VOLUME' TO ERRMSG\n         MVC   VOLSER(6),LOCAREA+6    LOAD 1ST VOL SER HOWEVER\n         B     SHUTDOWN               BRANCH TO SHUTDOWN\nMATCH    MVC   VOLSER(6),LOCAREA+6    LOAD VOLSER FROM CAMLST WORKAREA\n         MVC   OBTVOL(6),VOLSER\n         CLI   LOCAREA+4,X'80'        COMPARE LOCAREA+4 TO BE EQUAL\n*                                       TO HEXADECIMAL 80  (THIS\n*                                       INDICATES THAT THE DATASET\n*                                       IS ON TAPE)\n         BE    ONTAPE                 IF YES; BRANCH TO ONTAPE\n         MVI   DEVICE,C'D'            MOVE 'D' (FOR DISK) TO DEVICE\n         B     OBTANE                 BRANCH TO OBTANE\nONTAPE   MVI   DEVICE,C'T'            MOVE 'T' (FOR TAPE) TO DEVICE\n         MVC   ERRMSG(30),MESS15      MOVE 'DATASET IS ON TAPE'\n*                                       TO ERRMSG\n         MVC   VALIDSW(3),NOPE        MOVE 'NO ' TO VALIDSW\n         B     SHUTDOWN               BRANCH TO SHUTDOWN\n         SPACE 2\nOBTANE   OBTAIN CAMLIST2\n         SPACE 2\n         C     R15,=F'0'              COMPARE REG 15 TO BE = 0\n         BE    RCODE0                 IF REG 15=0, BRANCH TO RCODE0\n         C     R15,=F'4'              COMPARE REG 15 TO BE = 4\n         BE    RCODE4                 IF REG 15=4, BRANCH TO RCODE4\n         C     R15,=F'8'              COMPARE REG 15 TO BE = 8\n         BE    RCODE8                 IF REG 15=8, BRANCH TO RCODE8\n         MVC   ERRMSG(30),MESS5       MOVE 'OBTAIN MACRO RETURNED\n*                                       RC 12/16' TO ERRMSG\n         B     MOVENOPE\nRCODE4   MVC   ERRMSG(30),MESS3       MOVE 'REQUIRED VOLUME NOT\n*                                       MOUNTED' TO ERRMSG\n         B     MOVENOPE\nRCODE8   MVC   ERRMSG(30),MESS4       MOVE 'FORMAT-1 DSCB NOT FOUND\n*                                       ON VOL' TO ERRMSG\nMOVENOPE MVC   VALIDSW(3),NOPE        MOVE 'NO ' TO VALIDSW\n         B     SHUTDOWN               BRANCH TO SHUTDOWN\nRCODE0   MVC   VALIDSW(3),YESS        MOVE 'YES' TO VALIDSW\n         MVI   ERRMSG,C' '\n         MVC   ERRMSG+1(29),ERRMSG    MOVE SPACES TO ERRMSG\n         MVI   DEVICE,C'D'            MOVE 'D' (FOR DISK) TO DEVICE\n         MVC   VOLSER,OBTVOL\n         SPACE 1\n         BAL   R14,LRECLRT            PERFORM LRECL ROUTINE\n         SPACE 1\n         BAL   R14,BLKSIZRT           PERFORM BLKSIZE ROUTINE\n         SPACE 1\n         BAL   R14,DSORGRT            PERFORM DSORG ROUTINE\n         SPACE 1\n         BAL   R14,RECFMRT            PERFORM RECFM ROUTINE\n         SPACE 1\n         CLC   MEMCNTL(3),YESS        WAS MEMBER NAME PROVIDED\n         BNE   SHUTDOWN               IF NOT, BRANCH TO SHUTDOWN\n         SPACE 1\n         CLC   DSORG,=CL2'PO'         DSORG = 'PO' ?\n         BE    DOSRCH                 IF SO, BRANCH TO DOSRCH\n         MVC   ERRMSG(30),MESS17      MOVE 'DATASET NOT PARTITIONED'\n*                                        TO ERRMSG\n         MVC   VALIDSW(3),NOPE        MOVE 'NO ' TO VALIDSW\n         B     SHUTDOWN               BRANCH TO SHUTDOWN\nDOSRCH   BAL   R14,SRCHDIR            PERFORM ROUTINE TO CALL 'FINDMEM'\n*                                       WHICH SEARCHES THE DIRECTORY\n*                                       FOR MEMBER NAME = FNDMEMBR\n         B     SHUTDOWN               BRANCH TO SHUTDOWN\n         EJECT\n*\n*\n***********************************************************\n*                                                         *\n*  THIS ROUTINE IS RESPONSIBLE FOR CREATING THE PARAMETER *\n*  LRECL THAT IS PASSED BACK TO THE CALLING PROGRAM       *\n*                                                         *\n***********************************************************\n*\n*\nLRECLRT  ST    R14,SAVEIT2\n         MVI   FULLWURD,X'00'              MOVE ALL BINARY ZEROS\n         MVC   FULLWURD+1(3),FULLWURD        TO FULLWURD\n         MVC   FULLWURD+2(2),OBTAREA+44    MOVE LRECL WHICH IS 2 BYTES\n*                                            IN LENGTH BINARY TO LOW\n*                                            ORDER 2 BYTES OF FULLWURD\n         L     R9,FULLWURD                 LOAD REG 9 WITH FULLWURD\n         CVD   R9,DUBLWURD                 CONVERT REG 9 CONTENTS TO\n*                                            PACKED DECIMAL AND\n*                                            PLACE INTO DUBLWURD\n         UNPK  LRECL(5),DUBLWURD+5(3)      CONVERT PACKED DECIMAL IN\n*                                            DUBLWURD+5 (FOR A LENGTH\n*                                            OF 3 BYTES) AND PLACE\n*                                            INTO LRECL (FOR A LENGTH\n*                                            OF 5 BYTES)\n         OI    LRECL+4,X'F0'               GET RID OF THE SIGN OF\n*                                            LRECL (I.E. CHANGE HIGH\n*                                            ORDER 4 BITS OF LOW ORDER\n*                                            BYTE OF LRECL TO ALL ONES\n         L     R14,SAVEIT2\n         BR    14\n         EJECT\n*\n*\n***********************************************************\n*                                                         *\n*  THIS ROUTINE IS RESPONSIBLE FOR CREATING THE PARAMETER *\n*  BLKSIZE THAT IS PASSED BACK TO THE CALLING PROGRAM     *\n*                                                         *\n***********************************************************\n*\n*\nBLKSIZRT ST    R14,SAVEIT3\n         MVI   FULLWURD,X'00'              MOVE ALL BINARY ZEROS\n         MVC   FULLWURD+1(3),FULLWURD        TO FULLWURD\n         MVC   FULLWURD+2(2),OBTAREA+42    MOVE BLKSIZE WHICH IS\n*                                            2 BYTES BINARY TO LOW\n*                                            ORDER 2 BYTES OF FULLWURD\n         L     R9,FULLWURD                 LOAD REG 9 WITH FULLWURD\n         CVD   R9,DUBLWURD                 CONVERT REG 9 CONTENTS TO\n*                                            PACKED DECIMAL AND\n*                                            PLACE INTO DUBLWURD\n         UNPK  BLKSIZE(5),DUBLWURD+5(3)    CONVERT PACKED DECIMAL IN\n*                                            DUBLWURD+5 (FOR A LENGTH\n*                                            OF 3 BYTES) AND PLACE\n*                                            INTO BLKSIZE (FOR A\n*                                            LENGTH OF 5 BYTES)\n         OI    BLKSIZE+4,X'F0'             GET RID OF THE SIGN OF\n*                                            BLKSIZE (I.E. CHANGE HIGH\n*                                            ORDER 4 BITS OF LOW ORDER\n*                                            BYTE OF BLKSIZE TO ALL\n*                                            ONES)\n         L     R14,SAVEIT3\n         BR    14\n         EJECT\n*\n*\n***********************************************************\n*                                                         *\n*  THIS ROUTINE IS RESPONSIBLE FOR CREATING THE PARAMETER *\n*  DSORG THAT IS PASSED BACK TO THE CALLING PROGRAM       *\n*                                                         *\n***********************************************************\n*\n*\nDSORGRT  ST    R14,SAVEIT4\n         TM    OBTAREA+38,B'10000000'\n         BO    MOVEIT1\n         TM    OBTAREA+38,B'01000000'\n         BO    MOVEIT2\n         TM    OBTAREA+38,B'00100000'\n         BO    MOVEIT3\n         TM    OBTAREA+38,B'00010000'\n         BO    MOVEIT4\n         TM    OBTAREA+38,B'00001000'\n         BO    MOVEIT5\n         TM    OBTAREA+38,B'00000100'\n         BO    MOVEIT6\n         TM    OBTAREA+38,B'00000010'\n         BO    MOVEIT7\n         B     MOVEIT8\nMOVEIT1  MVC   DSORG(2),ORGTABLE        MOVE 'IS' TO DSORG\n         B     EXITDSRG\nMOVEIT2  MVC   DSORG(2),ORGTABLE+2      MOVE 'PS' TO DSORG\n         B     EXITDSRG\nMOVEIT3  MVC   DSORG(2),ORGTABLE+4      MOVE 'DA' TO DSORG\n         B     EXITDSRG\nMOVEIT4  MVC   DSORG(2),ORGTABLE+6      MOVE 'CX' TO DSORG\n         B     EXITDSRG\nMOVEIT5  MVC   DSORG(2),ORGTABLE+8      MOVE 'CQ' TO DSORG\n         B     EXITDSRG\nMOVEIT6  MVC   DSORG(2),ORGTABLE+10     MOVE 'MQ' TO DSORG\n         B     EXITDSRG\nMOVEIT7  MVC   DSORG(2),ORGTABLE+12     MOVE 'PO' TO DSORG\n         B     EXITDSRG\nMOVEIT8  CLI   OBTAREA+38,X'00'\n         BNE   DSORGU\n         CLC   OBTAREA+96(5),=XL5'0000000000'\n         BNE   DSORGU\n         MVC   DSORG(2),ORGTABLE+16     MOVE 'VS' TO DSORG\n         B     EXITDSRG\nDSORGU   MVC   DSORG(2),ORGTABLE+14     MOVE 'U ' TO DSORG\nEXITDSRG L     R14,SAVEIT4\n         BR    14\n         EJECT\n*\n*\n***********************************************************\n*                                                         *\n*  THIS ROUTINE IS RESPONSIBLE FOR CREATING THE PARAMETER *\n*  RECFM THAT IS PASSED BACK TO THE CALLING PROGRAM       *\n*                                                         *\n***********************************************************\n*\n*\nRECFMRT  ST    R14,SAVEIT5\n         TM    OBTAREA+40,B'11000000'\n         BO    RECFMU\n         TM    OBTAREA+40,B'01000000'\n         BO    RECFMV\n         MVI   RECFM,C'F'\n         B     EXITRCFM\nRECFMU   MVI   RECFM,C'U'\n         B     EXITRCFM\nRECFMV   MVI   RECFM,C'V'\nEXITRCFM L     R14,SAVEIT5\n         BR    14\n         EJECT\n*\n******************************************************************\n*                                                                *\n*        THIS ROUTINE BREAKS DOWN A DSN OF THE FORM              *\n*        DSNAME OF THE PDS(MEMBER NAME) INTO TWO SEPARATE        *\n*        DATA FIELDS FNDDSN AND FNDMEMBR WHERE FNDDSN IS         *\n*        44 BYTES IN LENGTH (PADDED WITH SPACES) AND FNDMEMBR    *\n*        IS 8 BYTES IN LENGTH (ALSO PADDED WITH SPACES)          *\n*                                                                *\n******************************************************************\n*\nBREAKDSN ST    R14,SAVEIT1            SAVE REG 14 ADDRESS IN SAVEIT1\n         MVC   BRKINDSN,INDSN\n         CALL  BREAKDSN,(BRKDSNIO),VL\n         MVC   FNDDSN,BRKOTDSN\n         MVC   FNDMEMBR,BRKMEMBR\n         MVC   MEMCNTL,BRKMEMPR\n         MVC   VALIDSW,BRKVALID\n         MVC   ERRMSG,BRKERROR\n         L     R14,SAVEIT1\n         BR    R14\n         EJECT\n*\n******************************************************************\n*                                                                *\n*        THIS ROUTINE IS RESPONSIBLE FOR VALIDATING THAT A       *\n*        GIVEN BYTE OF A MEMBER NAME IS VALID.  THAT IS;         *\n*        IS IT EQUAL TO A-Z, 0-9 OR ONE OF THE THREE NATIONAL    *\n*        CHARACTERS @, $, OR #                                   *\n*                                                                *\n******************************************************************\n*\nCHEKBYTE ST    R14,SAVEIT6            SAVE REG 14 ADDRESS IN SAVEIT6\n         MVC   OKBYTE,YESS            MOVE 'YES' TO OKBYTE\n         L     R9,=A(OKCHARS)         LOAD ADDR OF OKCHARS INTO REG 9\nCHEK1    CLI   0(R9),X'FF'            END OF TABLE OKCHARS REACHED?\n         BE    NOGOOD                 IF YES, BRANCH TO NOGOOD\n         CLC   0(1,R6),0(R9)          MEMBER NAME BYTE = TABLE ENTRY?\n         BE    EXITCHEK               IF YES, BRANCH TO EXITCHEK\n         A     R9,=F'1'               ADD 1 TO INDEX REGISTER 9\n         B     CHEK1                  BRANCH TO CHEK1\nNOGOOD   MVC   OKBYTE,NOPE            MOVE 'NO ' TO OKBYTE\nEXITCHEK L     R14,SAVEIT6\n         BR    R14\n         EJECT\n*\n*\n***********************************************************\n*                                                         *\n*  THIS ROUTINE IS RESPONSIBLE FOR CALLING THE SUBROUTINE *\n*  FINDMEM WHICH DYNAMICALLY FREES AND ALLOCATES THE      *\n*  FILE WITH DSN = FNDDSN TO DDNAME FINDMEDD AND THEN     *\n*  SEARCHES THE DIRECTORY FOR MEMBER NAME = FNDMEMBR      *\n*                                                         *\n*  THE TWO BYTE FIELD INDICATR RETURNS VALUES WHICH       *\n*  RELATE TO THE SUCCESS OR NON SUCCESS OF THAT SEARCH    *\n*                                                         *\n***********************************************************\n*\n*\nSRCHDIR  ST    R14,SAVEIT7            SAVE REG 14 ADDRESS IN SAVEIT7\n         CALL  FINDMEM,(IOAREA,VOLSER),VL\n         CLC   INDICATR,C00           INDICATR = '00'?\n         BE    EXITFIND               IF YES, BRANCH TO EXITFIND\n         MVC   VALIDSW(3),NOPE        MOVE 'NO ' TO VALIDSW\n         CLC   INDICATR,C04           INDICATR = '04'?\n         BE    INDIC04                IF YES, BRANCH TO INDIC04\n         CLC   INDICATR,C08           INDICATR = '08'?\n         BE    INDIC08                IF YES, BRANCH TO INDIC08\n         CLC   INDICATR,C20           INDICATR = '20'?\n         BE    INDIC20                IF YES, BRANCH TO INDIC20\n         CLC   INDICATR,C24           INDICATR = '24'?\n         BE    INDIC24                IF YES, BRANCH TO INDIC24\n         MVC   ERRMSG(30),MESS7       MOVE 'PROBLEM IN BAL PGM\n*                                       FILEATTR' TO ERRMSG\n         B     EXITFIND               BRANCH TO EXITFIND\nINDIC04  MVC   ERRMSG(30),MESS8       MOVE 'MEMBER NAME DOES NOT EXIST\n*                                       TO ERRMSG\n         B     EXITFIND               BRANCH TO EXITFIND\nINDIC08  MVC   ERRMSG(30),MESS9       MOVE 'UNSUCCESSFUL ALLOCATION'\n*                                       TO ERRMSG\n         B     EXITFIND               BRANCH TO EXITFIND\nINDIC20  MVC   ERRMSG(30),MESS10      MOVE 'I/O ERROR READING DIRECTRY\n*                                       TO ERRMSG\n         B     EXITFIND               BRANCH TO EXITFIND\nINDIC24  MVC   ERRMSG(30),MESS11      MOVE 'UNSUCESSFUL FREE OF DDNAME\n*                                       TO ERRMSG\nEXITFIND L     R14,SAVEIT7\n         BR    R14\n         EJECT\n*\n*\n***********************************************************\n*                                                         *\n*        THIS ROUTINE IS RESPONSIBLE FOR EDITING INVOL    *\n*                                                         *\n*        IF INVOL MEETS THE CRITERIA FOR BEING A VALID    *\n*        VOLUMER SERIAL NUMBER (6 BYTES LONG, ALL         *\n*        NUMERICS AND ALPHABETICS), THEN THIS ROUTINE     *\n*        WILL MOVE 'YES' TO GOODVOL ELSE MOVE 'NO '       *\n*        TO GOODVOL                                       *\n*                                                         *\n***********************************************************\n*\n*\nEDITVOL  ST    R14,SAVEIT8            SAVE REG 14 ADDRESS IN SAVEIT8\n         MVC   GOODVOL,=CL3'YES'\n         MVC   EDITBYTE(1),INVOL\n         BAL   R14,EDIT1BYT\n         CLC   GOODVOL,=CL3'YES'\n         BNE   EXITEVOL\n         MVC   EDITBYTE(1),INVOL+1\n         BAL   R14,EDIT1BYT\n         CLC   GOODVOL,=CL3'YES'\n         BNE   EXITEVOL\n         MVC   EDITBYTE(1),INVOL+2\n         BAL   R14,EDIT1BYT\n         CLC   GOODVOL,=CL3'YES'\n         BNE   EXITEVOL\n         MVC   EDITBYTE(1),INVOL+3\n         BAL   R14,EDIT1BYT\n         CLC   GOODVOL,=CL3'YES'\n         BNE   EXITEVOL\n         MVC   EDITBYTE(1),INVOL+4\n         BAL   R14,EDIT1BYT\n         CLC   GOODVOL,=CL3'YES'\n         BNE   EXITEVOL\n         MVC   EDITBYTE(1),INVOL+5\n         BAL   R14,EDIT1BYT\n         B     EXITEVOL\n*\n*\n*\nEDIT1BYT ST    R14,SAVEIT9            SAVE REG 14 ADDRESS IN SAVEIT9\n         CLI   EDITBYTE,C'0'\n         BL    NEXTEST\n         CLI   EDITBYTE,C'9'\n         BH    BADINVOL\n         B     EXITEDT1\nNEXTEST  CLI   EDITBYTE,C'A'\n         BL    BADINVOL\n         CLI   EDITBYTE,C'Z'\n         BH    BADINVOL\n         B     EXITEDT1\nBADINVOL MVC   GOODVOL,=CL3'NO '\nEXITEDT1 L     R14,SAVEIT9\n         BR    R14\n*\n*\n*\nEXITEVOL L     R14,SAVEIT8\n         BR    R14\n         EJECT\n*\n*\n***********************************************************\n*                                                         *\n*        THIS ROUTINE IS RESPONSIBLE FOR DETERMINING      *\n*        WHETHER THE DATASET NAME CONTAINED IN FNDDSN     *\n*        IS A GDG (DETERMINED BY ITS LAST QUALIFIER       *\n*        BEING .GXXXXVXX)                                 *\n*                                                         *\n*        IF IT IS, THIS ROUTINE WILL MOVE 'YES' TO        *\n*        ISITAGDG ELSE IT WILL MOVE 'NO ' TO ISITAGDG     *\n*                                                         *\n***********************************************************\n*\n*\nDSNSUFFX ST    R14,SAVEIT10           SAVE REG 14 ADDRESS IN SAVEIT10\n         LA    R3,FNDDSN              R3==> ADDRESS OF FNDDSN\n         A     R3,=F'43'              ADD 43 TO REGISTER 3\n         LA    R4,0                   R4==> 0\nSUFFIX1  C     R4,=F'43'              HAVE WE INDEXED THRU FNDDSN?\n         BH    NOTAGDG                IF SO, BRANCH TO NOTAGDG\n         CLI   0(R3),C'.'             HAVE WE FOUND THE LAST PERIOD ?\n         BE    SUFFIX2                IF SO, BRANCH TO SUFFIX2\n         A     R4,=F'1'               ADD 1 TO REG 4\n         S     R3,=F'1'               SUBTRACT 1 FROM REG 3\n         B     SUFFIX1                BRANCH TO SUFFIX1\nSUFFIX2  A     R3,=F'1'               ADD 1 TO REG 3\n         CLI   0(R3),C'G'\n         BNE   NOTAGDG\n         A     R3,=F'1'\n         CLI   0(R3),C'0'\n         BL    NOTAGDG\n         CLI   0(R3),C'9'\n         BH    NOTAGDG\n         A     R3,=F'1'\n         CLI   0(R3),C'0'\n         BL    NOTAGDG\n         CLI   0(R3),C'9'\n         BH    NOTAGDG\n         A     R3,=F'1'\n         CLI   0(R3),C'0'\n         BL    NOTAGDG\n         CLI   0(R3),C'9'\n         BH    NOTAGDG\n         A     R3,=F'1'\n         CLI   0(R3),C'0'\n         BL    NOTAGDG\n         CLI   0(R3),C'9'\n         BH    NOTAGDG\n         A     R3,=F'1'\n         CLI   0(R3),C'V'\n         BNE   NOTAGDG\n         A     R3,=F'1'\n         CLI   0(R3),C'0'\n         BL    NOTAGDG\n         CLI   0(R3),C'9'\n         BH    NOTAGDG\n         A     R3,=F'1'\n         CLI   0(R3),C'0'\n         BL    NOTAGDG\n         CLI   0(R3),C'9'\n         BH    NOTAGDG\n         MVC   ISITAGDG,=CL3'YES'     MOVE 'YES' TO ISITAGDG\n         B     EXITSUFF               BRANCH TO EXITSUFF\nNOTAGDG  MVC   ISITAGDG,=CL3'NO '     MOVE 'NO ' TO ISITAGDG\nEXITSUFF L     R14,SAVEIT10\n         BR    R14\n         EJECT\n         SPACE 3\n********************************************************************\n*        LOAD PARAMETERS 2 - 8 AND BRANCH BACK TO CALLING PROGRAM  *\n********************************************************************\n         SPACE 3\nSHUTDOWN LA    R15,0                  SET RC = 0\n         L     R9,4(R11)\n         MVC   0(3,R9),VALIDSW        MOVE VALIDSW TO PARAMETER #2\n         L     R9,8(R11)\n         MVC   0(30,R9),ERRMSG        MOVE ERRMSG  TO PARAMETER #3\n         L     R9,12(R11)\n         MVC   0(6,R9),VOLSER         MOVE VOLSER  TO PARAMETER #4\n         L     R9,16(R11)\n         MVC   0(5,R9),LRECL          MOVE LRECL   TO PARAMETER #5\n         L     R9,20(R11)\n         MVC   0(5,R9),BLKSIZE        MOVE BLKSIZE TO PARAMETER #6\n         L     R9,24(R11)\n         MVC   0(2,R9),DSORG          MOVE DSORG   TO PARAMETER #7\n         L     R9,28(R11)\n         MVC   0(1,R9),RECFM          MOVE RECFM   TO PARAMETER #8\n         L     R9,32(R11)\n         MVC   0(1,R9),DEVICE         MOVE DEVICE  TO PARAMETER #9\n         L     R13,4(R13)\n         RETURN (14,12),RC=(15)\n         EJECT\n         SPACE 3\n********************************************************************\n*        DATA AREAS                                                *\n********************************************************************\n         SPACE 3\n         DS    0F\nINDSN    DS    CL44\nCAMLIST1 CAMLST NAME,FNDDSN,,LOCAREA\nLOCAREA  DS    0D\n         DS    265C\n         DS    0D\nCAMLIST2 CAMLST SEARCH,FNDDSN,OBTVOL,OBTAREA\nOBTAREA  DS    0D\n         DS    140C\n         DS    0D\nOBTVOL   DS    CL6\nVALIDSW  DS    CL3\nISITAGDG DS    CL3\nERRMSG   DS    CL30\nVOLSER   DS    CL6\nLRECL    DS    CL5\nBLKSIZE  DS    CL5\nDSORG    DS    CL2\nRECFM    DS    CL1\nDEVICE   DS    CL1\nINVOL    DS    CL6\nHEX0001  DC    X'0001'\nYESS     DC    C'YES'\nNOPE     DC    C'NO '\n*\n*   B R E A K D S N   P A R A M E T E R S\n*\nBRKDSNIO DS    0CL135\nBRKINDSN DS    CL44\nBRKOTDSN DS    CL44\nBRKMEMBR DS    CL8\nBRKMEMPR DS    CL3\nBRKGDG   DS    CL3\nBRKVALID DS    CL3\nBRKERROR DS    CL30\n*\n*\n*\nMESS1    DC    C'DATASET NOT CATALOGED         '\nMESS2    DC    C'FILE IS ON MORE THAN 1 VOLUME '\nMESS3    DC    C'REQUIRED VOLUME NOT MOUNTED   '\nMESS4    DC    C'FORMAT-1 DSCB NOT FOUND ON VOL'\nMESS5    DC    C'OBTAIN MACRO RETURNED RC 12/16'\nMESS6    DC    C'INVALID SYNTAX FOR DSNAME     '\nMESS7    DC    C'PROBLEM IN BAL PGM FILEATTR   '\nMESS8    DC    C'MEMBER NAME NOT FOUND         '\nMESS9    DC    C'UNSUCCESFUL DYNAMIC ALLOCATION'\nMESS10   DC    C'I/O ERROR READING DIRECTORY   '\nMESS11   DC    C'UNSUCCESSFUL FREE OF DDNAME   '\nMESS13   DC    C'MEMBER NAME TOO LONG          '\nMESS14   DC    C'INVALID MEMBER NAME           '\nMESS15   DC    C'DATASET IS ON TAPE            '\nMESS16   DC    C'INVALID VOL SER GIVEN         '\nMESS17   DC    C'DATASET NOT PARTITIONED       '\nMESS18   DC    C'DATASET IS NOT A GDG          '\nORGTABLE DC    C'ISPSDACXCQMQPOU VS'\n         DS    0D\nDUBLWURD DS    D\nFULLWURD DS    F\nSAVEIT1  DS    F\nSAVEIT2  DS    F\nSAVEIT3  DS    F\nSAVEIT4  DS    F\nSAVEIT5  DS    F\nSAVEIT6  DS    F\nSAVEIT7  DS    F\nSAVEIT8  DS    F\nSAVEIT9  DS    F\nSAVEIT10 DS    F\nGOODVOL  DS    CL3\nOKBYTE   DS    CL3\nMEMCNTL  DS    CL3\nEDITBYTE DS    CL1\nIOAREA   DS    0CL56\n         DS    CL2\nFNDMEMBR DS    CL8\nFNDDSN   DS    CL44\nINDICATR DS    CL2\nCONSTPO  DC    CL2'PO'\nC00      DC    CL2'00'\nC04      DC    CL2'04'\nC08      DC    CL2'08'\nC20      DC    CL2'20'\nC24      DC    CL2'24'\nOKCHARS  DC    C'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n         DC    C'0123456789'\n         DC    C'#@$'\n         DC    X'FF'\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "FILEINF$": {"ttr": 17925, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x00\\x7f\\x00\\x88\\x00\\x7f\\x12\\x00\\x00\\xf2\\x00\\xf2\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf2\\xf7\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-01-07T00:00:00", "modifydate": "1988-01-07T12:00:00", "lines": 242, "newlines": 242, "modlines": 0, "user": "FILE270"}, "text": "1                                                        FILEINFO.1\n                                                         01/09/84\n\n  COMMAND NAME:       FILEINFO\n  AUTHOR:             Jeff Sprehn\n  AGENCY:             WDPSC\n  FUNCTION:           The FILEINFO  command is intended for  use in\n                      command procedures.  This  command returns to\n                      the CLIST (thru  CLIST variables) information\n                      about  that  file  such  as  LRECL,  BLKSIZE,\n                      RECFM,  DSORG, volume  serial number,  device\n                      type, number of used tracks and extents.\n  Syntax -\n  _________________________________________________________________________\n       Command        Operands\n  -------------------------------------------------------------------------\n       FILEINFO       DSN('dataset name') VOL('vol ser') MEM('member name')\n  -------------------------------------------------------------------------\n\n  Operands -\n\n    Required -\n\n         DSN('dataset name')      -- 'dataset name' is  the dataset\n                                  name of the dataset that you wish\n                                  to   receive   file   information\n                                  about.  If the data-  set name is\n                                  not  quoted,  then   the  PROFILE\n                                  PREFIX will be appended.  You may\n                                  provide a member name of a PDS if\n                                  you  wish.   This   command  will\n                                  return in  CLIST variable  MEMFND\n                                  'YES' if  the member is  found in\n                                  the directory  and 'NO' if  it is\n                                  not found in the directory.\n\n\n\n\n1                                                        FILEINFO.2\n                                                         01/09/84\n\n\n            Optional:\n\n                 VOL('vol ser')      'vol  ser' is  to be  used if\n                                     your file is not cataloged.\n\n                 MEM('member name')  'member name'  is the  member\n                                     name  of  the   PDS  named  by\n                                     'dataset name'.   This command\n                                     will return in  CLIST variable\n                                     MEMFND 'YES' if  the member is\n                                     found  in  the  directory  and\n                                     'NO' if it is not found in the\n                                     directory.\n\n  After execution  of this command,  the following  CLIST variables\n  are set.  Their names and contents are as follows:\n\n        CLIST\n       Variable                         Contents\n       --------       ------------------------------------------------\n\n       &FULLDSN       Your dataset name as follows:\n                      a.   PROFILE PREFIX added if dataset name in\n                           DSN keyword was not quoted.\n                      b.   Quotes now stripped off.\n                      c.   Member name included, if and only if, member\n                           name was provided in the DSN keyword, other-\n                           wise &FULLDSN will not include this member name.\n\n       &LRECL         Logical record length of dataset.\n\n       &BLKSIZE       Blocksize of dataset.\n\n\n\n\n1                                                        FILEINFO.3\n                                                         01/09/84\n\n\n       &RECFM         Will contain one of the following three values:\n                           'F' for fixed length records\n                           'V' for variable length records\n                           'U' for undefined records.\n\n       &CNTLCHAR      Will contain one of the following three values:\n                           'A' dataset contains ANSI control characters\n                           'M' dataset contains machine control characters\n                           'N' dataset contains no control characters\n\n       &DEVTYPE       Will contain one of the following two values:\n                           'T' dataset is on tape\n                           'D' dataset is on disk\n\n       &VOLSER        Volume serial number where dataset resides.\n\n       &DSORG         Will contain one of the following values:\n                           'IS' for indexed sequential organization\n                           'PS' for physical sequential organization\n                           'DA' for direct organization\n                           'CX' for BTAM or QTAM line group\n                           'PO' for partitioned\n                           'U ' for unmovable - the data contains\n                                location dependent information\n                           'VS' for VSAM dataset\n\n       &ISITCAT       Will contain one of the following three values:\n                           'YES' if dataset is cataloged\n                           'NO ' if dataset is not cataloged\n                           '   ' if n/a (higher level error was\n                                detected prior to LOCATE)\n\n\n\n\n1                                                        FILEINFO.4\n                                                         01/09/84\n\n\n       &MEMFND        Will contain one of the following three values:\n                           'YES' if member of PDS was found\n                           'NO ' if member of PDS was not found\n                           '   ' if n/a (user didn't request this\n                                 command to locate a member)\n\n       &MEMCNTL       Will contain one of the following two values:\n                           'YES' if member name was included with\n                                 the DSN in the DSN keyword\n                           'NO ' if member name was not included\n                                 with the DSN in the DSN keyword\n\n       &EXTENTNO      Number  of  used  extents.    This  field  is\n                      significant  only for  disk sequential  files\n                      and partitioned datasets.\n\n       &TRKSUSED      Number  of   used  tracks.   This   field  is\n                      significant  only for  disk sequential  files\n                      and partitioned datasets.\n\n\n\n\n1                                                        FILEINFO.5\n                                                         01/09/84\n\n\n  This command  will also make  available two other  variables that\n  the invoking CLIST  may interrogate.  Below is a  table of values\n  after execution of  this command for these  two variables &OUTMSG\n  and &LASTCC (return code).\n\n       &LASTCC   &OUTMSG\n\n          0      Successful completion\n          4      Dataset not cataloged\n          8      File is on more than 1 volume\n         12      Required volume not mounted\n         16      Format-1 DSCB not found on vol\n         20      Obtain macro returned RC 12/16\n         24      Member name not found\n         28      Unsuccessful dynamic allocation\n         32      I/O error reading directory\n         36      Unsuccessful free of ddname\n         40      File is on a tape volume\n         44      Dataset not partitioned\n         48      Invalid syntax of member name\n         52      Error in program FILSPACE\n         96      Invalid syntax of operand(s)\n\n\n\n\n1                                                        FILEINFO.6\n                                                         01/09/84\n\n\n  Example of use -\n\n                 CONTROL NOMSG NOFLUSH END(ENDO)\n       START:    KOMM RESET CLEAR\n                 WRITE\n                 WRITE .............. LISTING A DATASET ..............\n                 WRITE\n                 WRITE\n\n                 WRITENR ENTER DATASET NAME ===>\n                 READ\n                 SET &DSN = &STR(&SYSDVAL)\n\n                 FILEINFO DSN(&STR(&DSN))\n                 SET &MYCC = &LASTCC\n\n                 IF &MYCC EQ 96 THEN DO\n                      WRITE\n                      WRITE ERROR ===> INVALID SYNTAX OF DSNAME\n                      CALL 'WDPSC.SHARED.LOAD(NEWWAIT)' '3'\n                      GOTO START\n                      ENDO\n\n                 IF &MYCC NE 0 THEN DO\n                      WRITE\n                      WRITE ERROR ===> &OUTMSG\n                      CALL 'WDPSC.SHARED.LOAD(NEWWAIT)' '3'\n                      GOTO START\n                      ENDO\n\n                 IF &DSORG = PS THEN GOTO LISTIT\n\n\n\n\n1                                                        FILEINFO.7\n                                                         01/09/84\n\n\n                 IF &DSORG NE PO THEN DO\n                      WRITE\n                      WRITE &FULLDSN IS NOT A SEQUENTIAL DATASET\n                      WRITE OR A PARTITIONED DATASET\n                      CALL 'WDPSC.SHARED.LOAD(NEWWAIT)' '3'\n                      GOTO START\n                      ENDO\n\n                 IF &MEMCNTL NE YES THEN DO\n                      WRITE\n                      WRITE &FULLDSN IS A PARTITIONED DATASET\n                      WRITE HENCE; YOU MUST PROVIDE A MEMBER NAME\n                      CALL 'WDPSC.SHARED.LOAD(NEWWAIT)' '3'\n                      GOTO START\n                      ENDO\n\n       LISTIT:   CONTROL MSG\n                 LIST '&FULLDSN'\n\n       ENDIT:    EXIT\n\n\n\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "FILEINFO": {"ttr": 17930, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x00\\x7f\\x00\\x88\\x00\\x7f\\x12\\x00\\x05A\\x05A\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf2\\xf7\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-01-07T00:00:00", "modifydate": "1988-01-07T12:00:00", "lines": 1345, "newlines": 1345, "modlines": 0, "user": "FILE270"}, "text": "*\n*FFFFFFFF IIIIIIII LL       EEEEEEEE IIIIIIII NN    NN FFFFFFFF OOOOOO\n*FF          II    LL       EE          II    NNN   NN FF      OO    OO\n*FFFFFF      II    LL       EE          II    NNNN  NN FFFFFF  OO    OO\n*FFFFFF      II    LL       EEEEEEEE    II    NN NN NN FFFFFF  OO    OO\n*FF          II    LL       EE          II    NN  NNNN FF      OO    OO\n*FF          II    LL       EE          II    NN   NNN FF      OO    OO\n*FF          II    LL       EE          II    NN    NN FF      OO    OO\n*FF       IIIIIIII LLLLLLLL EEEEEEEE IIIIIIII NN     N FF       OOOOOO\n*\n*\n*  -----------------------------------------------------------------\n*  COMMAND     OPERANDS\n*  -----------------------------------------------------------------\n*  FILEINFO    DSN('DATASET NAME') VOL('VOL SER') MEM('MEMBER NAME')\n*  -----------------------------------------------------------------\n*\n*\n*  OPERANDS -\n*\n*       REQUIRED -\n*\n*           DSN('DATASET NAME')  -- 'DATASET NAME' IS THE DATASET\n*                                   NAME OF THE DATASET THAT YOU\n*                                   WISH TO RECIEVE FILE INFORMATION\n*                                   ABOUT.  IF THE DATASET IS NOT\n*                                   QUOTED, THEN THE PROFILE PREFIX\n*                                   WILL BE APPENDED.  YOU MAY PROVIDE\n*                                   A MEMBER NAME OF A PDS IF YOU WISH.\n*                                   THIS COMMAND WILL RETURN IN CLIST\n*                                   VARIABLE MEMFND 'YES' IF THE\n*                                   MEMBER IS FOUND IN THE DIRECTORY\n*                                   AND 'NO ' IF IT IS NOT FOUND IN\n*                                   THE DIRECTORY.\n*\n*       OPTIONAL -\n*\n*           VOL('VOL SER') -------- 'VOL SER' IS TO BE USED IF YOUR\n*                                   FILE IS NOT CATALOGUED.\n*\n*\n*           MEM('MEMBER NAME') ---- 'MEMBER NAME' IS THE MEMBER NAME\n*                                   OF THE PDS NAMED BY 'DATASET NAME'.\n*                                   THIS COMMAND WILL RETURN IN CLIST\n*                                   VARIABLE MEMFND 'YES' IF THE\n*                                   MEMBER IS FOUND IN THE DIRECTORY\n*                                   AND 'NO ' IF IT IS NOT FOUND IN\n*                                   THE DIRECTORY.\n         EJECT\n*        AFTER EXECUTION OF THIS COMMAND, THE FOLLOWING CLIST VARIABLES\n*        ARE SET.   THERE NAMES AND CONTENTS ARE AS FOLLOWS:\n*\n*             CLIST\n*            VARIABLE    CONTENTS\n*            --------    --------------------------------------------\n*\n*            &FULLDSN    YOUR DATASET NAME AS FOLLOWS:\n*                           A.  PROFILE PREFIX ADDED IF DATASET NAME\n*                                 IN DSN KEYWORD WAS NOT QUOTED\n*                           B.  QUOTES NOW STRIPPED OFF\n*                           C.  MEMBER NAME INCLUDED IF AND ONLY IF\n*                                 MEMBER NAME WAS PROVIDED IN THE\n*                                 DSN KEYWORD TO THE COMMAND.  THUS;\n*                                 IF A MEMBER NAME WAS PROVIDED IN\n*                                 THE MEM KEYWORD, THEN &FULLDSN WILL\n*                                 NOT INCLUDE THIS MEMBER NAME\n*\n*            &LRECL      LOGICAL RECORD LENGTH OF DATASET\n*\n*            &BLKSIZE    BLOCK SIZE OF DATASET\n*\n*            &RECFM      WILL CONTAIN ONE OF THE FOLLOWING 3 VALUES:\n*\n*                            'F'  FOR FIXED LENGTH RECORDS\n*                            'V'  FOR VARIABLE LENGTH RECORDS\n*                            'U'  FOR UNDEFINED RECORDS\n*\n*            &CNTLCHAR   WILL CONTAIN ONE OF THE FOLLOWING 3 VALUES:\n*\n*                            'A'  FOR ANSI CONTROL CHARACTERS\n*                            'M'  FOR MACHINE CONTROL CHARACTERS\n*                            'N'  FOR NO CONTROL CHARACTERS\n*\n*            &DEVTYPE    WILL CONTAIN ONE OF THE FOLLOWING 2 VALUES:\n*\n*                            'T'  DATASET IS ON TAPE\n*                            'D'  DATASET IS ON DISK\n*\n*            &VOLSER     VOLUME SERIAL NUMBER WHERE DATASET RESIDES\n*\n*            &DSORG      WILL CONTAIN ONE OF THE FOLLOWING 9 VALUES:\n*\n*                            'IS' FOR  INDEXED SEQUENTIAL ORGANIZATION\n*                            'PS' FOR  PHYSICAL SEQUENTIAL ORGANIZATION\n*                            'DA' FOR  DIRECT ORGANIZATION\n*                            'CX' FOR  BTAM OR QTAM LINE GROUP\n*                            'CQ' FOR  QTAM DIRECT ACCESS MESSAGE QUEUE\n*                            'MQ' FOR  QTAM PROBLEM PGM MESSAGE QUEUE\n*                            'PO' FOR  PARTITIONED\n*                            'U ' FOR  UNMOVABLE - THE DATA CONTAINS\n*                                      LOCATION DEPENDENT INFORMATION\n*                            'VS' FOR  VSAM DATASET\n         EJECT\n*\n*             CLIST\n*            VARIABLE    CONTENTS\n*            --------    --------------------------------------------\n*\n*\n*            &ISITCAT    WILL CONTAIN ONE OF THE FOLLOWING 3 VALUES:\n*\n*                            'YES' IF DATASET IS CATALOGUED\n*                            'NO ' IF DATASET IS NOT CATALOGUED\n*                            '   ' IF N/A (HIGHER LEVEL ERROR WAS\n*                                      DETECTED PRIOR TO LOCATE)\n*\n*            &MEMFND     WILL CONTAIN ONE OF THE FOLLOWING 3 VALUES:\n*\n*                            'YES' IF MEMBER OF PDS WAS FOUND\n*                            'NO ' IF MEMBER OF PDS WAS NOT FOUND\n*                            '   ' IF N/A (USER DIDNT REQUEST THIS\n*                                      COMMAND TO LOCATE A MEMBER)\n*\n*            &MEMCNTL    WILL CONTAIN ONE OF THE FOLLOWING 2 VALUES:\n*\n*                            'YES' IF MEMBER NAME WAS INCLUDED WITH\n*                                     THE DSN IN THE DSN KEYWORD\n*                            'NO ' IF MEMBER NAME WAS NOT INCLUDED\n*                                     WITH THE DSN IN THE DSN KEYWORD\n*\n*            &TRKSUSED   NUMBER OF USED TRACKS\n*\n*            &EXTENTNO   NUMBER OF USED EXTENTS\n*\n         EJECT\n*\n*\n*        THIS COMMAND WILL ALSO MAKE AVAILABLE TWO OTHER VARIABLES\n*        THAT THE INVOKING CLIST MAY INTERROGATE.  BELOW IS A TABLE\n*        OF VALUES AFTER EXECUTION OF THIS COMMAND FOR THESE TWO\n*        VARIABLES &OUTMSG AND &LASTCC (RETURN CODE)\n*\n*        |---------|-----------------------------------------------|\n*        | &LASTCC |                 &OUTMSG                       |\n*        |---------|-----------------------------------------------|\n*        |    0    | SUCCESSFUL COMPLETION                         |\n*        |---------|-----------------------------------------------|\n*        |    4    | DATASET NOT CATALOGUED                        |\n*        |---------|-----------------------------------------------|\n*        |    8    | FILE IS ON MORE THAN 1 VOLUME                 |\n*        |---------|-----------------------------------------------|\n*        |    12   | REQUIRED VOLUME NOT MOUNTED                   |\n*        |---------|-----------------------------------------------|\n*        |    16   | FORMAT-1 DSCB NOT FOUND ON VOL                |\n*        |---------|-----------------------------------------------|\n*        |    20   | OBTAIN MACRO RETURNED RC 12/16                |\n*        |---------|-----------------------------------------------|\n*        |    24   | MEMBER NAME NOT FOUND                         |\n*        |---------|-----------------------------------------------|\n*        |    28   | UNSUCCESSFUL DYNAMIC ALLOCATION               |\n*        |---------|-----------------------------------------------|\n*        |    32   | I/O ERROR READING DIRECTORY                   |\n*        |---------|-----------------------------------------------|\n*        |    36   | UNSUCCESSFUL FREE OF DDNAME                   |\n*        |---------|-----------------------------------------------|\n*        |    40   | FILE IS ON A TAPE VOLUME                      |\n*        |---------|-----------------------------------------------|\n*        |    44   | DATASET NOT PARTITIONED                       |\n*        |---------|-----------------------------------------------|\n*        |    48   | INVALID SYNTAX OF MEMBER NAME                 |\n*        |---------|-----------------------------------------------|\n*        |    52   | ERROR IN PROGRAM FILSPACE                     |\n*        |---------|-----------------------------------------------|\n*        |    96   | INVALID SYNTAX OF OPERAND(S)                  |\n*        |---------|-----------------------------------------------|\n*\n*\n*|-----------------------------------------------------------------|    ----V1M3\n*| CHANGE ACTIVITY:                                                |\n*|                                                                 |    ----V1M3\n*|       VERSION 2.0  -  GORDON SCHILLINGER  DIS/CSD   09/02/88    |\n*|                       MODIFIED CODE TO BE REENTERABLE           |    ----V1M3\n*|                                                                 |    ----V1M3\n*|_________________________________________________________________|    ----V1M3\n         EJECT\nFILEINFO ENTERR LEVEL=V_2.0\n         LA    R6,BASEREG2   R6 IS TO BE THE SECOND BASE REGISTER\n         USING BASEREG2,R6\n         EJECT\n********************************************************************\n*                                                                  *\n*      M A I N   L I N E   L O G I C   F O R   F I L E I N F O     *\n*                                                                  *\n********************************************************************\n*\n         LR    R11,R1              SAVE THE PARM POINTER\n         BAL   R14,DOPARSE         PERFORM THE PARSE SERVICE ROUTINE\n         CLC   PROCESSW,=C'YES'    WAS PARSE SUCCESFUL ?\n         BNE   INITL               IF NOT, BRANCH TO INITL\n         BAL   R14,LOADFLDS        PERFORM ROUTINE TO LOAD THE PARSED\n*                                    FIELDS INTO QUALDSN, INVOL,\n*                                    AND QUALMEM\n         CLC   PROCESSW,=C'YES'    IS EVERTHING STILL HONKEY DOREY ?\n         BNE   INITL               IF NOT, BRANCH TO INITL\n         BAL   R14,PRCSFLDS        PERFORM ROUTINE TO PROCESS QUALDSN,\n*                                    INVOL, AND QUALMEM\n*                                      (I.E.\n*                                           DO LOCATE AND OBTAIN\n*                                             ON QUALDSN)\nINITL    BAL   R14,INITLIST        BUILD PARMLIST FOR IKJUPDT\n         BAL   R14,SETFLDSN        SET CLIST VARIABLE FULLDSN\n         BAL   R14,SETLRECL        SET CLIST VARIABLE LRECL\n         BAL   R14,SETBLKSZ        SET CLIST VARIABLE BLKSIZE\n         BAL   R14,SETRECFM        SET CLIST VARIABLE RECFM\n         BAL   R14,SETCCHAR        SET CLIST VARIABLE CNTLCHAR\n         BAL   R14,SETDEVTP        SET CLIST VARIABLE DEVTYPE\n         BAL   R14,SETVOLSR        SET CLIST VARIABLE VOLSER\n         BAL   R14,SETDSORG        SET CLIST VARIABLE DSORG\n         BAL   R14,SETISCAT        SET CLIST VARIABLE ISITCAT\n         BAL   R14,SETMEMFD        SET CLIST VARIABLE MEMFND\n         BAL   R14,SETMEMCT        SET CLIST VARIABLE MEMCNTL\n         BAL   R14,SETRKUSD        SET CLIST VARIABLE TRKSUSED\n         BAL   R14,SETEXTNO        SET CLIST VARIABLE EXTENTNO\n         BAL   R14,SETOUTMG        SET CLIST VARIABLE OUTMSG\n         B     SHUTDOWN            BRANCH TO SHUTDOWN\n         EJECT\n********************************************************************\n*                                                                  *\n*        P A R S E   I N P U T   C O M M A N D   B U F F E R       *\n*                                                                  *\n********************************************************************\n*\nDOPARSE  ST    R14,SAVEIT9\n         KKPARSE\n         LTR   R15,R15              RC = 0 ? (I.E PARSE GO OK ?)\n         BNZ   PARSERR              IF NOT, BRANCH TO PARSERR\n         MVC   PROCESSW,=C'YES'     MOVE 'YES' TO PROCESSW\n         L     R10,ANS\n         USING IKJPARMD,R10\n         B     EXITPARS\nPARSERR  MVC   PROCESSW,=C'NO '     MOVE 'NO ' TO PROCESSW\n         LA    R4,96                SET REG 4 = 96\n         MVC   OUTMSG,MESS96        MOVE 'INVALID SYNTAX OF OPERANDS'\n*                                       TO OUTMSG\nEXITPARS L     R14,SAVEIT9\n         BR    14\n         EJECT\n********************************************************************\n*                                                                  *\n*        THIS ROUTINE PROCESSES THE PARSED FIELDS AND THEN         *\n*        LOADS DATA FIELDS QUALDSN, INVOL, AND QUALMEM SO          *\n*        THAT THE ROUTINE PRCSFLDS (PROCESS FIELDS) CAN            *\n*        WORK ON EM                                                *\n*                                                                  *\n*        THIS ROUTINE ALSO LOADS DATA FIELD MEMCNTL                *\n*                                                                  *\n********************************************************************\n*\nLOADFLDS ST    R14,SAVEIT10\n         TM    DSTRING+6,X'80'         IS DSNAME PRESENT ?\n         BO    CLERQDSN                IF SO, BRANCH TO CLERQDSN\n         LA    R4,96                   SET R4 = 96\n         MVC   OUTMSG,MESS96           MOVE 'INVALID SYNTAX OF OPERANDS\n*                                         TO OUTMSG\n         MVC   PROCESSW,=C'NO '        MOVE 'NO ' TO PROCESSW\n         B     EXITLOAD                BRANCH TO EXITLOAD\nCLERQDSN MVI   QUALDSN,C' '            A BLANK\n         MVC   QUALDSN+1(43),QUALDSN   SPREAD IT AROUND\n         MVI   FULLDSN,C' '            A BLANK\n         MVC   FULLDSN+1(53),FULLDSN   SPREAD IT AROUND\n         LA    R1,QUALDSN              R1 ==> ADDRESS OF QUALDSN\n         L     R8,DSTRING              R8 ==> ADDRESS OF THE DSN\n         LH    R7,DSTRING+4            R7 ==> LENGTH OF THE DSN\n         S     R7,=F'1'                SUBTRACT 1 FOR EX\n         SPACE 1\nMOVEDSN  MVC   0(0,R1),0(R8)           MOVE THE DSN TO QUALDSN\n         EX    R7,MOVEDSN\n         SPACE 1\n         LA    R1,FULLDSN\n         EX    R7,MOVEDSN\n         TM    DSTRING+14,X'80'        IS MEMBER NAME PRESENT ?\n         BNO   MOVE89S                 IF NOT, BRANCH TO MOVE89S\n         MVC   MEMCNTL,=C'YES'         MOVE 'YES' TO MEMCNTL\n         MVC   CPMEM1,=CL8' '          MOVE 8 SPACES TO CPMEM1\n         LA    R1,CPMEM1               R1 ==> ADDRESS OF CPMEM1\n         L     R8,DSTRING+8            R8 ==> ADDRESS OF THE MEMBER\n         LH    R7,DSTRING+12           R7 ==> LENGTH OF THE MEMBER\n         S     R7,=F'1'                SUBTRACT 1 FOR EX\n         SPACE 1\n         EX    R7,MOVEMM1\n         B     DOMKYWD                 BRANCH TO DOMKYWD\nMOVEMM1  MVC   0(0,R1),0(R8)           MOVE THE MEMBER TO CPMEM1\n         SPACE 1\nMOVE89S  MVC   CPMEM1,=C'99999999'     MOVE '99999999' TO CPMEM1\n         MVC   MEMCNTL,=C'NO '         MOVE 'NO ' TO MEMCNTL\nDOMKYWD  MVC   CPMEM2,=CL8' '          MOVE 8 SPACES TO CPMEM2\n         LA    R1,CPMEM2               R1 ==> ADDRESS OF CPMEM2\n         L     R8,MSTRING              R8 ==> ADDRESS OF THE MEMBER\n         LH    R7,MSTRING+4            R7 ==> LENGTH OF THE MEMBER\n         S     R7,=F'1'                SUBTRACT 1 FOR EX\n         SPACE 1\nMOVEMM2  MVC   0(0,R1),0(R8)           MOVE THE MEMBER TO CPMEM2\n         EX    R7,MOVEMM2\n         SPACE 1\n         CLC   CPMEM1,=C'99999999'     IS CPMEM1 = ALL NINES ?\n         BE    M1IS999                 IF YES, BRANCH TO M1IS999\n         CLC   CPMEM2,=C'99999999'     IS CPMEM2 = ALL NINES ?\n         BE    M2IS999                 IF YES, BRANCH TO M2IS999\n         CLC   CPMEM1,CPMEM2           IS CPMEM1 = CPMEM2 ?\n         BNE   NOMATCH                 IF NOT, BRANCH TO NOMATCH\n         MVC   QUALMEM,CPMEM1          MOVE CPMEM1 TO QUALMEM\n         B     CHEKMEM                 BRANCH TO CHEKMEM\nM1IS999  MVC   QUALMEM,CPMEM2          MOVE CPMEM2 TO QUALMEM\n         B     CHEKMEM                 BRANCH TO CHEKMEM\nM2IS999  MVC   QUALMEM,CPMEM1          MOVE CPMEM2 TO QUALMEM\n         B     CHEKMEM                 BRANCH TO CHEKMEM\nNOMATCH  LA    R4,96                   SET R4 = 96\n         MVC   OUTMSG,MESS96           MOVE 'INVALID SYNTAX OF OPERANDS\n*                                         TO OUTMSG\n         MVC   PROCESSW,=C'NO '        MOVE 'NO ' TO PROCESSW\n         B     EXITLOAD                BRANCH TO EXITLOAD\nCHEKMEM  CLC   QUALMEM,=C'99999999'    IS QUALMEM = '99999999' ?\n         BE    DOVOLSR                 IF YES, BRANCH TO DOVOLSR\n         BAL   R14,EDITMEM             PERFORM EDIT MEMBER NAME\n         CLC   VALIDMEM,=C'YES'        IS MEMBER NAME VALID ?\n         BE    DOVOLSR                 IF YES, BRANCH TO DOVOLSR\n         LA    R4,48                   SET R4 = 48\n         MVC   OUTMSG,MESS48           MOVE 'INVALID SYNTAX OF MEMBER\n*                                         NAME' TO OUTMSG\n         MVC   PROCESSW,=C'NO '        MOVE 'NO ' TO PROCESSW\n         B     EXITLOAD                BRANCH TO EXITLOAD\nDOVOLSR  TM    VSTRING+6,X'80'         IS VOL SER PRESENT ?\n         BNO   MOVE69S                 IF NOT, BRANCH TO MOVE69S\n         MVC   INVOL,=CL6' '           MOVE 6 SPACES TO INVOL\n         LA    R1,INVOL                R1 ==> ADDRESS OF INVOL\n         L     R8,VSTRING              R8 ==> ADDRESS OF THE VOL SER\n         LH    R7,VSTRING+4            R7 ==> LENGTH OF THE VOL SER\n         S     R7,=F'1'                SUBTRACT 1 FOR EX\n         SPACE 1\n         EX    R7,MOVEVOL\n         B     MOVEYES                 BRANCH TO MOVEYES\nMOVEVOL  MVC   0(0,R1),0(R8)           MOVE THE VOL SER TO INVOL\n         SPACE 1\nMOVE69S  MVC   INVOL,=C'999999'        MOVE '999999' TO INVOL\nMOVEYES  MVC   PROCESSW,=C'YES'        MOVE 'YES' TO PROCESSW\n*\n*\n*\n*\n*\n******************************************************************\n*                                                                *\n*        BUILD CAMLIST1 AND CAMLIST2 FOR LOCATE AND OBTAIN       *\n*                                                                *\n******************************************************************\n*\n         MVI   CAMLIST1,X'00'                                           ----V1M3\n         MVC   CAMLIST1+1(CAML1LEN-1),CAMLIST1                          ----V1M3\n         MVI   CAMLIST2,X'00'                                           ----V1M3\n         MVC   CAMLIST2+1(CAML2LEN-1),CAMLIST2                          ----V1M3\n         MVI   CAMLIST1,68                                              ----V1M3\n         MVI   CAMLIST2,193                                             ----V1M3\n         LA    R1,QUALDSN\n         ST    R1,CAMLIST1+4\n         ST    R1,CAMLIST2+4\n         LA    R1,LOCAREA\n         ST    R1,CAMLIST1+12\n         LA    R1,OBTAREA\n         ST    R1,CAMLIST2+12\n         LA    R1,OBTVOL\n         ST    R1,CAMLIST2+8\n*\n******************************************************************\n*                                                                *\n*        E X I T   L O A D F L D S                               *\n*                                                                *\n******************************************************************\n*\nEXITLOAD L     R14,SAVEIT10\n         BR    14\n         EJECT\n********************************************************************\n*                                                                  *\n*        AS AN OVERVIEW, THIS ROUTINE DOES THE FOLLOWING:          *\n*                                                                  *\n*            1.  WAS VOLUME SERIAL NUMBER PROVIDED BY INVOKER ?    *\n*            2.  IF YES, GO TO 10                                  *\n*            3.  SEARCH CATALOG FOR QUALDSN (LOCATE)               *\n*            4.  IF NOT FOUND,                                     *\n*                     LOAD OUTMSG                                  *\n*                     SET UP RETURN CODE                           *\n*                     MOVE 'NO ' TO ISITCAT                        *\n*                     EXIT                                         *\n*            5.  IF FOUND, MOVE 'YES' TO ISITCAT                   *\n*            6.  STORE VOL SER                                     *\n*            7.  IS DATASET ON TAPE ?                              *\n*            8.  IF YES,                                           *\n*                     MOVE 'T' TO DEVTYPE                          *\n*                     LOAD OUTMSG                                  *\n*                     SET UP RETURN CODE                           *\n*                     EXIT                                         *\n*            9.  MOVE 'D' TO DEVTYPE                               *\n*           10.  OBTAIN FORMAT-1 DSCB FOR DATASET                  *\n*           11.  RETURN CODE OF OBTAIN = 0 ?                       *\n*           12.  IF NOT,                                           *\n*                     LOAD OUTMSG                                  *\n*                     SET UP RETURN CODE                           *\n*                     EXIT                                         *\n*           13.  PERFORM ROUTINE TO GENERATE LRECL                 *\n*           14.  PERFORM ROUTINE TO GENERATE BLKSIZE               *\n*           15.  PERFORM ROUTINE TO GENERATE DSORG                 *\n*           16.  PERFORM ROUTINE TO GENERATE RECFM                 *\n*           16A. PERFORM ROUTINE TO GENERATE CNTLCHAR              *\n*           16B. PERFORM ROUTINE TO GENERATE TRKSUSED AND EXTENTNO *\n*           17.  IS DATASET A PARTITIONED DATASET ?                *\n*           18.  IF YES, GO TO 24                                  *\n*           19.  WAS MEMBER NAME PROVIDED ?                        *\n*           20.  IF YES,                                           *\n*                     LOAD OUTMSG                                  *\n*                     SET UP RETURN CODE                           *\n*                     EXIT                                         *\n*           21.  SET RETURN CODE REG TO 0                          *\n*           22.  LOAD OUTMSG WITH 'SUCCESSFUL COMPLETION'          *\n*           23.  EXIT                                              *\n*           24.  WAS MEMBER NAME PROVIDED ?                        *\n*           25.  IF YES, GO TO 29                                  *\n*           26.  SET RETURN CODE REG TO 0                          *\n*           27.  LOAD OUTMSG WITH 'SUCCESSFUL COMPLETION'          *\n*           28.  EXIT                                              *\n*           29.  CALL BAL PGM 'FINDMEM' TO DETERMINE WHETHER       *\n*                   MEMBER DOES EXIST IN THE DIRECTORY ?           *\n*           30.  MEMBER FOUND ?                                    *\n*           31.  IF NOT,                                           *\n*                     LOAD OUTMSG                                  *\n*                     SET UP RETURN CODE                           *\n*                     EXIT                                         *\n*           32.  SET RETURN CODE REG TO 0                          *\n*           33.  LOAD OUTMSG WITH 'SUCCESSFUL COMPLETION'          *\n*           34.  EXIT                                              *\n*                                                                  *\n********************************************************************\n         EJECT\n*\nPRCSFLDS ST    R14,SAVEIT11\n         CLC   INVOL,=C'999999'       IS INVOL = '999999' ?\n         BE    LOKAYT                 IF YES, BRANCH TO LOKAYT\n         MVC   OBTVOL,INVOL           MOVE INVOL TO OBTVOL\n         B     OBTANE                 BRANCH TO OBTANE\nLOKAYT   LOCATE CAMLIST1\n         SPACE 2\n         C     R15,=F'0'              COMPARE REG 15 TO BE = 0\n         BE    RC0                    IF REG 15=0, BRANCH TO RC0\n         MVC   ISITCAT,NOPE           MOVE 'NO ' TO ISITCAT\n         LA    R4,4                   SET REG 4 = 4\n         MVC   OUTMSG,MESS4           MOVE 'DATASET NOT CATALOGUED'\n*                                       TO OUTMSG\n         B     EXITPRCS               BRANCH TO EXITPRCS\nRC0      MVC   ISITCAT,YESS           MOVE 'YES' TO ISITCAT\n         MVC   FULLDSN(44),QUALDSN    MOVE QUALDSN TO FULLDSN\n         MVC   FULLDSN+44(10),=CL10'          '\n         CLC   MEMCNTL,=CL3'YES'      WAS A MEMBER NAME GIVEN ?\n         BNE   RC0CONT                IF NOT, BRANCH TO RC0CONT\n         BAL   R14,GENFULDS           PERFORM ROUTINE TO SUFFIX (MNAME)\n*                                        TO FULLDSN\nRC0CONT  CLC   LOCAREA(2),HEX0001     VERIFY THAT THE NUMBER OF\n*                                        VOLUMES COUNT IS 1\n         BE    MATCH                  IF YES, BRANCH TO MATCH\n         LA    R4,8                   SET REG 4 = 8\n         MVC   OUTMSG,MESS8           MOVE 'FILE IS ON MOR THAN 1 VOL'\n*                                       TO OUTMSG\n         B     EXITPRCS               BRANCH TO EXITPRCS\nMATCH    MVC   VOLSER(6),LOCAREA+6    LOAD VOLSER FROM CAMLST WORKAREA\n         MVC   OBTVOL(6),VOLSER       MOVE VOLSER TO OBTVOL\n         CLI   LOCAREA+4,X'80'        IS DATASET ON TAPE ?\n         BE    ONTAPE                 IF YES; BRANCH TO ONTAPE\n         MVI   DEVTYPE,C'D'           MOVE 'D' (FOR DISK) TO DEVTYPE\n         B     OBTANE                 BRANCH TO OBTANE\nONTAPE   MVI   DEVTYPE,C'T'           MOVE 'T' (FOR TAPE) TO DEVTYPE\n         LA    R4,40                  SET REG 4 = 40\n         MVC   OUTMSG,MESS40          MOVE 'FILE IS ON A TAPE VOLUME'\n*                                       TO OUTMSG\n         B     EXITPRCS               BRANCH TO EXITPRCS\n         SPACE 2\nOBTANE   OBTAIN CAMLIST2\n         SPACE 2\n         C     R15,=F'0'              COMPARE REG 15 TO BE = 0\n         BE    RCODE0                 IF REG 15=0, BRANCH TO RCODE0\n         C     R15,=F'4'              COMPARE REG 15 TO BE = 4\n         BE    RCODE4                 IF REG 15=4, BRANCH TO RCODE4\n         C     R15,=F'8'              COMPARE REG 15 TO BE = 8\n         BE    RCODE8                 IF REG 15=8, BRANCH TO RCODE8\n         LA    R4,20                  SET REG 4 = 20\n         MVC   OUTMSG,MESS20          MOVE 'OBTAIN MACRO RETURNED'\n*                                       RC 12/16' TO OUTMSG\n         B     EXITPRCS               BRANCH TO EXITPRCS\nRCODE4   LA    R4,12                  SET REG 4 = 12\n         MVC   OUTMSG,MESS12          MOVE 'REQUIRED VOL NOT MOUNTED'\n*                                       TO OUTMSG\n         B     EXITPRCS               BRANCH TO EXITPRCS\nRCODE8   LA    R4,16                  SET REG 4 = 16\n         MVC   OUTMSG,MESS16          MOVE 'FORMAT-1 DSCB NOT FOUND'\n*                                       ON VOL' TO ERRMSG\n         MVC   VOLSER,=CL6' '         MOVE SPACES TO VOLSER\n         B     EXITPRCS               BRANCH TO EXITPRCS\nRCODE0   MVC   VOLSER,OBTVOL          MOVE OBTVOL TO VOLSER\n         MVI   DEVTYPE,C'D'           MOVE 'D' (FOR DISK) TO DEVTYPE\n         MVC   FULLDSN(44),QUALDSN    MOVE QUALDSN TO FULLDSN\n         MVC   FULLDSN+44(10),=CL10'          '\n         CLC   MEMCNTL,=CL3'YES'      WAS A MEMBER NAME GIVEN ?\n         BNE   GENLRECL               IF NOT, BRANCH TO GENLRECL\n         BAL   R14,GENFULDS           PERFORM ROUTINE TO SUFFIX (MNAME)\n*                                        TO FULLDSN\n         SPACE 1\nGENLRECL BAL   R14,LRECLRT            PERFORM LRECL ROUTINE\n         SPACE 1\n         BAL   R14,BLKSIZRT           PERFORM BLKSIZE ROUTINE\n         SPACE 1\n         BAL   R14,DSORGRT            PERFORM DSORG ROUTINE\n         SPACE 1\n         BAL   R14,RECFMRT            PERFORM RECFM ROUTINE\n         SPACE 1\n         BAL   R14,CCHARRT            PERFORM CNTLCHAR ROUTINE\n         SPACE 1\n         BAL   R14,SPACERT            PERFORM ROUTINE TO GENERATE\n*                                        TRKSUSED AND EXTENTNO\n         SPACE 1\n         CLC   GOODCALL,=CL3'YES'     DID ALL GO OK ?\n         BNE   EXITPRCS               IF NOT, BRANCH TO EXITPRCS\n         CLC   DSORG(2),=C'PO'        COMPARE DSORG = 'PO'\n         BE    PDS                    IF YES, BRANCH TO PDS\n         CLC   QUALMEM,=C'99999999'   IS QUALMEM = '99999999' ?\n         BE    NOMEM                  IF YES; BRANCH TO NOMEM\n         LA    R4,44                  SET REG 4 = 44\n         MVC   OUTMSG,MESS44          MOVE 'DATASET NOT PARTITIONED'\n*                                       TO OUTMSG\n         B     EXITPRCS               BRANCH TO EXITPRCS\nNOMEM    LA    R4,0                   SET REG 4 = 0\n         MVC   OUTMSG,MESS0           MOVE 'SUCCESSFUL COMPLETION'\n*                                       TO OUTMSG\n         B     EXITPRCS               BRANCH TO EXITPRCS\n         SPACE 1\nPDS      CLC   QUALMEM,=C'99999999'   IS QUALMEM = '99999999' ?\n         BNE   SEERCH                 IF NOT, BRANCH TO SEERCH\n         LA    R4,0                   SET REG 4 = 0\n         MVC   OUTMSG,MESS0           MOVE 'SUCCESSFUL COMPLETION'\n*                                       TO OUTMSG\n         B     EXITPRCS               BRANCH TO EXITPRCS\nSEERCH   MVC   FNDDSN,QUALDSN         MOVE QUALDSN TO FNDDSN\n         MVC   FNDMEMBR,QUALMEM       MOVE QUALMEM TO FNDMEMBR\n         BAL   R14,SRCHDIR            PERFORM ROUTNE TO CALL 'FINDMEM'\n*                                        WHICH SEARCHES THE DIRECTORY\n*                                        FOR MEMBER NAME = INMEM\n         CLC   INDICATR,=C'00'        IS INDICATR = '00' ?\n         BE    FOUND                  IF YES, BRANCH TO FOUND\n         MVC   MEMFND,NOPE            MOVE 'NO ' TO MEMFND\n         B     EXITPRCS               BRANCH TO EXITPRCS\nFOUND    MVC   MEMFND,YESS            MOVE 'YES' TO MEMFND\n         LA    R4,0                   SET REG 4 = 0\n         MVC   OUTMSG,MESS0           MOVE 'SUCCESSFUL COMPLETION'\n*                                       TO OUTMSG\nEXITPRCS L     R14,SAVEIT11\n         BR    14\n         EJECT\n*\n*\n***********************************************************\n*                                                         *\n*  THIS ROUTINE IS RESPONSIBLE FOR CREATING THE PARAMETER *\n*  LRECL THAT IS MADE AVAILABLE TO THE CALLING CLIST      *\n*                                                         *\n***********************************************************\n*\n*\nLRECLRT  ST    R14,SAVEIT2\n         MVI   FULLWURD,X'00'              MOVE ALL BINARY ZEROS\n         MVC   FULLWURD+1(3),FULLWURD        TO FULLWURD\n         MVC   FULLWURD+2(2),OBTAREA+44    MOVE LRECL WHICH IS 2 BYTES\n*                                            IN LENGTH BINARY TO LOW\n*                                            ORDER 2 BYTES OF FULLWURD\n         L     R9,FULLWURD                 LOAD REG 9 WITH FULLWURD\n         CVD   R9,DUBLWURD                 CONVERT REG 9 CONTENTS TO\n*                                            PACKED DECIMAL AND\n*                                            PLACE INTO DUBLWURD\n         UNPK  LRECL(5),DUBLWURD+5(3)      CONVERT PACKED DECIMAL IN\n*                                            DUBLWURD+5 (FOR A LENGTH\n*                                            OF 3 BYTES) AND PLACE\n*                                            INTO LRECL (FOR A LENGTH\n*                                            OF 5 BYTES)\n         OI    LRECL+4,X'F0'               GET RID OF THE SIGN OF\n*                                            LRECL (I.E. CHANGE HIGH\n*                                            ORDER 4 BITS OF LOW ORDER\n*                                            BYTE OF LRECL TO ALL ONES\n         L     R14,SAVEIT2\n         BR    14\n         EJECT\n*\n*\n***********************************************************\n*                                                         *\n*  THIS ROUTINE IS RESPONSIBLE FOR CREATING THE PARAMETER *\n*  BLKSIZE THAT IS MADE AVAILABLE TO THE CALLING CLIST    *\n*                                                         *\n***********************************************************\n*\n*\nBLKSIZRT ST    R14,SAVEIT3\n         MVI   FULLWURD,X'00'              MOVE ALL BINARY ZEROS\n         MVC   FULLWURD+1(3),FULLWURD        TO FULLWURD\n         MVC   FULLWURD+2(2),OBTAREA+42    MOVE BLKSIZE WHICH IS\n*                                            2 BYTES BINARY TO LOW\n*                                            ORDER 2 BYTES OF FULLWURD\n         L     R9,FULLWURD                 LOAD REG 9 WITH FULLWURD\n         CVD   R9,DUBLWURD                 CONVERT REG 9 CONTENTS TO\n*                                            PACKED DECIMAL AND\n*                                            PLACE INTO DUBLWURD\n         UNPK  BLKSIZE(5),DUBLWURD+5(3)    CONVERT PACKED DECIMAL IN\n*                                            DUBLWURD+5 (FOR A LENGTH\n*                                            OF 3 BYTES) AND PLACE\n*                                            INTO BLKSIZE (FOR A\n*                                            LENGTH OF 5 BYTES)\n         OI    BLKSIZE+4,X'F0'             GET RID OF THE SIGN OF\n*                                            BLKSIZE (I.E. CHANGE HIGH\n*                                            ORDER 4 BITS OF LOW ORDER\n*                                            BYTE OF BLKSIZE TO ALL\n*                                            ONES)\n         L     R14,SAVEIT3\n         BR    14\n         EJECT\n*\n*\n***********************************************************\n*                                                         *\n*  THIS ROUTINE IS RESPONSIBLE FOR CREATING THE PARAMETER *\n*  DSORG THAT IS MADE AVAILABLE TO THE CALLING CLIST      *\n*                                                         *\n***********************************************************\n*\n*\nDSORGRT  ST    R14,SAVEIT4\n         TM    OBTAREA+38,B'10000000'\n         BO    MOVEIT1\n         TM    OBTAREA+38,B'01000000'\n         BO    MOVEIT2\n         TM    OBTAREA+38,B'00100000'\n         BO    MOVEIT3\n         TM    OBTAREA+38,B'00010000'\n         BO    MOVEIT4\n         TM    OBTAREA+38,B'00001000'\n         BO    MOVEIT5\n         TM    OBTAREA+38,B'00000100'\n         BO    MOVEIT6\n         TM    OBTAREA+38,B'00000010'\n         BO    MOVEIT7\n         B     MOVEIT8\nMOVEIT1  MVC   DSORG(2),ORGTABLE        MOVE 'IS' TO DSORG\n         B     EXITDSRG\nMOVEIT2  MVC   DSORG(2),ORGTABLE+2      MOVE 'PS' TO DSORG\n         B     EXITDSRG\nMOVEIT3  MVC   DSORG(2),ORGTABLE+4      MOVE 'DA' TO DSORG\n         B     EXITDSRG\nMOVEIT4  MVC   DSORG(2),ORGTABLE+6      MOVE 'CX' TO DSORG\n         B     EXITDSRG\nMOVEIT5  MVC   DSORG(2),ORGTABLE+8      MOVE 'CQ' TO DSORG\n         B     EXITDSRG\nMOVEIT6  MVC   DSORG(2),ORGTABLE+10     MOVE 'MQ' TO DSORG\n         B     EXITDSRG\nMOVEIT7  MVC   DSORG(2),ORGTABLE+12     MOVE 'PO' TO DSORG\n         B     EXITDSRG\nMOVEIT8  CLI   OBTAREA+38,X'00'\n         BNE   DSORGU\n         CLC   OBTAREA+96(5),=XL5'0000000000'\n         BNE   DSORGU\n         MVC   DSORG(2),ORGTABLE+16     MOVE 'VS' TO DSORG\n         B     EXITDSRG\nDSORGU   MVC   DSORG(2),ORGTABLE+14     MOVE 'U ' TO DSORG\nEXITDSRG L     R14,SAVEIT4\n         BR    14\n         EJECT\n*\n*\n***********************************************************\n*                                                         *\n*  THIS ROUTINE IS RESPONSIBLE FOR CREATING THE PARAMETER *\n*  RECFM THAT IS MADE AVAILABLE TO THE CALLING CLIST      *\n*                                                         *\n***********************************************************\n*\n*\nRECFMRT  ST    R14,SAVEIT5\n         TM    OBTAREA+40,B'11000000'\n         BO    RECFMU\n         TM    OBTAREA+40,B'01000000'\n         BO    RECFMV\n         MVI   RECFM,C'F'\n         B     EXITRCFM\nRECFMU   MVI   RECFM,C'U'\n         B     EXITRCFM\nRECFMV   MVI   RECFM,C'V'\nEXITRCFM L     R14,SAVEIT5\n         BR    14\n         EJECT\n*\n*\n***********************************************************\n*                                                         *\n*  THIS ROUTINE IS RESPONSIBLE FOR CREATING THE PARAMETER *\n*  CNTLCHAR THAT IS MADE AVAILABLE TO THE CALLING CLIST   *\n*                                                         *\n***********************************************************\n*\n*\nCCHARRT  ST    R14,SAVEIT28\n         TM    OBTAREA+40,B'00000100'\n         BO    ANSICNTL\n         TM    OBTAREA+40,B'00000010'\n         BO    MACHCNTL\n         MVI   CNTLCHAR,C'N'\n         B     EXITCCHR\nANSICNTL MVI   CNTLCHAR,C'A'\n         B     EXITCCHR\nMACHCNTL MVI   CNTLCHAR,C'M'\nEXITCCHR L     R14,SAVEIT28\n         BR    14\n         EJECT\n*\n*\n************************************************************\n*                                                          *\n*  THIS ROUTINE IS RESPONSIBLE FOR CREATING THE            *\n*  PARAMETERS TRKSUSED AND EXTENTNO                        *\n*                                                          *\n************************************************************\n*\n*\nSPACERT  ST    R14,SAVEIT31\n         MVC   GOODCALL,=CL3'YES'       MOVE 'YES' TO GOODCALL\n         MVC   EXTENTNO,=CL2'00'        MOVE 00 TO EXTENTNO\n         MVC   TRKSUSED,=CL5'00000'     MOVE 00000 TO TRKSUSED\n         CLC   DSORG,=CL2'PS'           DSORG = 'PS' ?\n         BE    SPACERT2                 IF SO, BRANCH TO SPACERT2\n         CLC   DSORG,=CL2'PO'           DSORG = 'PO' ?\n         BE    SPACERT2                 IF SO, BRANCH TO SPACERT2\n         B     EXITSPAC                 BRANCH TO EXITSPAC\nSPACERT2 CLI   DEVTYPE,C'D'             IS DATASET ON DISK ?\n         BNE   EXITSPAC                 IF NOT, BRANCH TO EXITSPAC\n         MVC   FLSPDSN,QUALDSN\n         MVC   FLSPVOL,VOLSER\n         CALL  FILSPACE,(FLSPAREA),VL,MF=(E,RPPL)  GET # USED TRACKS\n         C     R15,=F'0'                RETURN CODE = 0 ?\n         BE    GNSPINFO                 IF SO, BRANCH TO GNSPINFO\n         MVC   GOODCALL,=CL3'NO '       MOVE 'NO ' TO GOODCALL\n         LA    R4,52                    SET R4 = 52\n         MVC   OUTMSG,MESS52            MOVE 'ERROR IN PGM FILSPACE'\n*                                         TO OUTMSG\n         B     EXITSPAC                 BRANCH TO EXITSPAC\nGNSPINFO MVC   EXTENTNO,OUTEXTNO        LOAD EXTENTNO\n         MVC   TRKSUSED,OUTTRKNO        LOAD TRKSUSED\nEXITSPAC L     R14,SAVEIT31\n         BR    14\n         EJECT\n*\n*\n***********************************************************\n*                                                         *\n*  THIS ROUTINE IS RESPONSIBLE FOR CALLING THE SUBROUTINE *\n*  FINDMEM WHICH DYNAMICALLY FREES AND ALLOCATES THE      *\n*  FILE WITH DSN = FNDDSN TO DDNAME FINDMEDD AND THEN     *\n*  SEARCHES THE DIRECTORY FOR MEMBER NAME = FNDMEMBR      *\n*                                                         *\n*  THE TWO BYTE FIELD INDICATR RETURNS VALUES WHICH       *\n*  RELATE TO THE SUCCESS OR NON SUCCESS OF THAT SEARCH    *\n*                                                         *\n***********************************************************\n*\n*\nSRCHDIR  ST    R14,SAVEIT7            SAVE REG 14 ADDRESS IN SAVEIT7\n         MVC   FNDVOL,VOLSER\n         CALL  FINDMEM,(IOAREA,FNDVOL),VL,MF=(E,RPPL)\n         CLC   INDICATR,=C'00'        INDICATR = '00'?\n         BE    EXITFIND               IF YES, BRANCH TO EXITFIND\n         CLC   INDICATR,=C'04'        INDICATR = '04'?\n         BE    INDIC04                IF YES, BRANCH TO INDIC04\n         CLC   INDICATR,=C'08'        INDICATR = '08'?\n         BE    INDIC08                IF YES, BRANCH TO INDIC08\n         CLC   INDICATR,=C'20'        INDICATR = '20'?\n         BE    INDIC20                IF YES, BRANCH TO INDIC20\n         CLC   INDICATR,=C'24'        INDICATR = '24'?\n         BE    INDIC24                IF YES, BRANCH TO INDIC24\nINDIC04  LA    R4,24                  SET REG 4 = 24\n         MVC   OUTMSG(30),MESS24      MOVE 'MEMBER NAME NOT FOUND'\n*                                       TO OUTMSG\n         B     EXITFIND               BRANCH TO EXITFIND\nINDIC08  LA    R4,28                  SET REG 4 = 28\n         MVC   OUTMSG(30),MESS28      MOVE 'UNSUCCESSFUL DYNAMIC\n*                                       ALLOCATION' TO OUTMSG\n         B     EXITFIND               BRANCH TO EXITFIND\nINDIC20  LA    R4,32                  SET REG 4 = 32\n         MVC   OUTMSG(30),MESS32      MOVE 'I/O ERROR READING\n*                                       DIRECTORY' TO OUTMSG\n         B     EXITFIND               BRANCH TO EXITFIND\nINDIC24  LA    R4,36                  SET REG 4 = 36\n         MVC   OUTMSG(30),MESS36      MOVE 'UNSUCCESSFUL FREE OF\n*                                       DDNAME' TO OUTMSG\nEXITFIND L     R14,SAVEIT7\n         BR    R14\n         EJECT\n*\n*\n***********************************************************\n*                                                         *\n*        THIS ROUTINE IS RESPONSIBLE FOR EDITING THE      *\n*        MEMBER NAME WHICH IS IN QUALMEM.                 *\n*                                                         *\n*        IF THE MEMBER NAME IS VALID, IT WILL MOVE 'YES'  *\n*        TO VALIDMEM ELSE IT WILL MOVE 'NO ' TO VALIDMEM  *\n*                                                         *\n***********************************************************\n*\n*\nEDITMEM  ST    R14,SAVEIT6            SAVE REG 14 ADDRESS IN SAVEIT6\n         LA    R9,OKCHARS1            R9==> ADDRESS OF OKCHARS1\nEDIT1    CLI   0(R9),C'+'             AT END OF TABLE OKCHARS1 ?\n         BE    NOGOOD                 IF YES, BRANCH TO NOGOOD\n         CLC   QUALMEM(1),0(R9)       HIGH ORDER BYTE OF QUALMEM\n*                                       MATCH ON TABLE ELEMENT ?\n         BE    EDIT2                  IF YES, BRANCH TO EDIT2\n         A     R9,=F'1'               ADD 1 TO REGISTER 9\n         B     EDIT1                  BRANCH TO EDIT1\nEDIT2    LA    R8,QUALMEM+1           R8==> ADDRESS OF QUALMEM + 1\n         LA    R7,1                   R7==> VALIDATED BYTES OF QUALMEM\nEDIT3    LA    R9,OKCHARS2            R9==> ADDRESS OF OKCHARS2\nEDIT4    CLI   0(R9),C'+'             AT END OF TABLE OKCHARS2 ?\n         BE    NOGOOD                 IF YES, BRANCH TO NOGOOD\n         CLC   0(1,R8),0(R9)          QUALMEM AS INDEXED BY REG 8\n*                                       MATCH TO TABLE ELEMENT ?\n         BE    EDIT5                  IF YES, BRANCH TO EDIT5\n         A     R9,=F'1'               ADD 1 TO REGISTER 9\n         B     EDIT4                  BRANCH TO EDIT4\nEDIT5    A     R8,=F'1'               ADD 1 TO REGISTER 8\n         A     R7,=F'1'               ADD 1 TO REGISTER 7\n         C     R7,=F'8'               ALL 8 BYTES OF QUALMEM VALIDATED?\n         BL    EDIT3                  IF NOT, BRANCH TO EDIT3\n         MVC   VALIDMEM,=C'YES'       MOVE 'YES' TO VALIDMEM\n         B     EXITEDIT               BRANCH TO EXITEDIT\nNOGOOD   MVC   VALIDMEM,=C'NO '       MOVE 'NO ' TO VALIDMEM\nEXITEDIT L     R14,SAVEIT6\n         BR    R14\n         EJECT\n*\n*\n***********************************************************\n*                                                         *\n*        THIS ROUTINE IS RESPONSIBLE FOR GENERATING THE   *\n*        DATA FIELD FULLDSN IF A MEMBER NAME WAS PROVIDED *\n*        WITHIN THE DATASET NAME                          *\n*                                                         *\n*        FULLDSN = X(Y)                                   *\n*                                                         *\n*            WHERE X IS THE SIGNIFICANT PORTION OF THE    *\n*               OS CATALOG NAME (THE INPUT DSNAME         *\n*               COULD HAVE BEEN AN ALIAS NAME)            *\n*                                                         *\n*            WHERE Y IS THE SIGNIFICANT PORTION OF THE    *\n*               MEMBER NAME (FOUND IN QUALMEM)            *\n*                                                         *\n***********************************************************\n*\n*\nGENFULDS ST    R14,SAVEIT26           SAVE REG 14 ADDRESS IN SAVEIT26\n         LA    R7,FULLDSN\n         LA    R8,1\nGENLOOP1 C     R8,=F'44'\n         BH    GENHIT1\n         CLI   0(R7),C' '\n         BE    GENHIT1\n         A     R7,=F'1'\n         A     R8,=F'1'\n         B     GENLOOP1\nGENHIT1  MVI   0(R7),C'('\n         A     R7,=F'1'\n         LA    R8,1\n         LA    R1,QUALMEM\nGENLOOP2 C     R8,=F'8'\n         BH    GENHIT2\n         CLI   0(R1),C' '\n         BE    GENHIT2\n         MVC   0(1,R7),0(R1)\n         A     R7,=F'1'\n         A     R8,=F'1'\n         A     R1,=F'1'\n         B     GENLOOP2\nGENHIT2  MVI   0(R7),C')'\n         L     R14,SAVEIT26\n         BR    R14\n         EJECT\n********************************************************************\n*                                                                  *\n*        BUILD UPDTLIST (IKJUPDT PARM LIST)                        *\n*                                                                  *\n********************************************************************\n*\nINITLIST ST    R14,SAVEIT13\n         MVC   UPDTUPT,CPPLUPT          UPT\n         MVC   UPDTECT,CPPLECT          ECT\n         LA    R9,ECB\n         ST    R9,UPDTECB               ECB\n         LA    R8,UPLIST\n         ST    R8,UPDTUPL               UPLIST\n         L     R14,SAVEIT13\n         BR    14\n         EJECT\n********************************************************************\n*                                                                  *\n*        BUILD UPDATE PARM LIST FOR &FULLDSN AND CALL IKJUPDT      *\n*                                                                  *\n********************************************************************\n*\nSETFLDSN ST    R14,SAVEIT14\n         LA    R9,=C'FULLDSN'      R9 ==> ADDRESS OF VAR NAME\n         ST    R9,LOCPTR           STORE ADDR OF VAR NAME IN LOCPTR\n         MVC   LOCLEN,=F'7'        LOCLEN = LENGTH OF VAR NAME\n         LA    R5,FULLDSN          R5 ==> ADDRESS OF VARIABLE\n         ST    R5,VALPTR           STORE ADDRESS OF VARIABLE IN VALPTR\n         LA    R9,0                R9 ==> 0\nCMPGT53  C     R9,=F'53'           IS REG 9 GREATER THAN 53 ?\n         BH    DSNGT53             IF YES, BRANCH TO DSNGT53\n         CLI   0(R5),C' '          IS FULLDSN AS INDEXED BY REG 5\n*                                     EQUAL TO SPACE ?\n         BE    HITASPAC            IF YES, BRANCH TO HITASPAC\n         A     R5,=F'1'            ADD 1 TO REGISTER 5\n         A     R9,=F'1'            ADD 1 TO REGISTER 9\n         B     CMPGT53             BRANCH TO CMPGT53\nDSNGT53  LA    R9,54               R9 ==> 54\nHITASPAC ST    R9,VALLEN           VALLEN = LENGTH OF DATA FIELD\n         LA    R1,UPDTLIST         R1 ==> IKJUPDT PARM LIST\n         CALL  IKJUPDT             DO THE UPDATE\n         L     R14,SAVEIT14\n         BR    14\n         EJECT\n********************************************************************\n*                                                                  *\n*        BUILD UPDATE PARM LIST FOR &LRECL AND CALL IKJUPDT        *\n*                                                                  *\n********************************************************************\n*\nSETLRECL ST    R14,SAVEIT15\n         LA    R9,=C'LRECL'        R9 ==> ADDRESS OF VAR NAME\n         ST    R9,LOCPTR           STORE ADDR OF VAR NAME IN LOCPTR\n         MVC   LOCLEN,=F'5'        LOCLEN = LENGTH OF VAR NAME\n         LA    R5,LRECL            R5 ==> ADDRESS OF VARIABLE\n         ST    R5,VALPTR           STORE ADDRESS OF VARIABLE IN VALPTR\n         MVC   VALLEN,=F'5'        VALLEN = LENGTH OF DATA FIELD\n         LA    R1,UPDTLIST         R1 ==> IKJUPDT PARM LIST\n         CALL  IKJUPDT             DO THE UPDATE\n         L     R14,SAVEIT15\n         BR    14\n         EJECT\n********************************************************************\n*                                                                  *\n*        BUILD UPDATE PARM LIST FOR &BLKSIZE AND CALL IKJUPDT      *\n*                                                                  *\n********************************************************************\n*\nSETBLKSZ ST    R14,SAVEIT16\n         LA    R9,=C'BLKSIZE'      R9 ==> ADDRESS OF VAR NAME\n         ST    R9,LOCPTR           STORE ADDR OF VAR NAME IN LOCPTR\n         MVC   LOCLEN,=F'7'        LOCLEN = LENGTH OF VAR NAME\n         LA    R5,BLKSIZE          R5 ==> ADDRESS OF VARIABLE\n         ST    R5,VALPTR           STORE ADDRESS OF VARIABLE IN VALPTR\n         MVC   VALLEN,=F'5'        VALLEN = LENGTH OF DATA FIELD\n         LA    R1,UPDTLIST         R1 ==> IKJUPDT PARM LIST\n         CALL  IKJUPDT             DO THE UPDATE\n         L     R14,SAVEIT16\n         BR    14\n         EJECT\n********************************************************************\n*                                                                  *\n*        BUILD UPDATE PARM LIST FOR &RECFM AND CALL IKJUPDT        *\n*                                                                  *\n********************************************************************\n*\nSETRECFM ST    R14,SAVEIT17\nBASEREG2 LA    R9,=C'RECFM'        R9 ==> ADDRESS OF VAR NAME\n         ST    R9,LOCPTR           STORE ADDR OF VAR NAME IN LOCPTR\n         MVC   LOCLEN,=F'5'        LOCLEN = LENGTH OF VAR NAME\n         LA    R5,RECFM            R5 ==> ADDRESS OF VARIABLE\n         ST    R5,VALPTR           STORE ADDRESS OF VARIABLE IN VALPTR\n         MVC   VALLEN,=F'1'        VALLEN = LENGTH OF DATA FIELD\n         LA    R1,UPDTLIST         R1 ==> IKJUPDT PARM LIST\n         CALL  IKJUPDT             DO THE UPDATE\n         L     R14,SAVEIT17\n         BR    14\n         EJECT\n********************************************************************\n*                                                                  *\n*        BUILD UPDATE PARM LIST FOR &CNTLCHAR AND CALL IKJUPDT     *\n*                                                                  *\n********************************************************************\n*\nSETCCHAR ST    R14,SAVEIT27\n         LA    R9,=C'CNTLCHAR'     R9 ==> ADDRESS OF VAR NAME\n         ST    R9,LOCPTR           STORE ADDR OF VAR NAME IN LOCPTR\n         MVC   LOCLEN,=F'8'        LOCLEN = LENGTH OF VAR NAME\n         LA    R5,CNTLCHAR         R5 ==> ADDRESS OF VARIABLE\n         ST    R5,VALPTR           STORE ADDRESS OF VARIABLE IN VALPTR\n         MVC   VALLEN,=F'1'        VALLEN = LENGTH OF DATA FIELD\n         LA    R1,UPDTLIST         R1 ==> IKJUPDT PARM LIST\n         CALL  IKJUPDT             DO THE UPDATE\n         L     R14,SAVEIT27\n         BR    14\n         EJECT\n********************************************************************\n*                                                                  *\n*        BUILD UPDATE PARM LIST FOR &DEVTYPE AND CALL IKJUPDT      *\n*                                                                  *\n********************************************************************\n*\nSETDEVTP ST    R14,SAVEIT18\n         LA    R9,=C'DEVTYPE'      R9 ==> ADDRESS OF VAR NAME\n         ST    R9,LOCPTR           STORE ADDR OF VAR NAME IN LOCPTR\n         MVC   LOCLEN,=F'7'        LOCLEN = LENGTH OF VAR NAME\n         LA    R5,DEVTYPE          R5 ==> ADDRESS OF VARIABLE\n         ST    R5,VALPTR           STORE ADDRESS OF VARIABLE IN VALPTR\n         MVC   VALLEN,=F'1'        VALLEN = LENGTH OF DATA FIELD\n         LA    R1,UPDTLIST         R1 ==> IKJUPDT PARM LIST\n         CALL  IKJUPDT             DO THE UPDATE\n         L     R14,SAVEIT18\n         BR    14\n         EJECT\n********************************************************************\n*                                                                  *\n*        BUILD UPDATE PARM LIST FOR &VOLSER AND CALL IKJUPDT       *\n*                                                                  *\n********************************************************************\n*\nSETVOLSR ST    R14,SAVEIT19\n         LA    R9,=C'VOLSER'       R9 ==> ADDRESS OF VAR NAME\n         ST    R9,LOCPTR           STORE ADDR OF VAR NAME IN LOCPTR\n         MVC   LOCLEN,=F'6'        LOCLEN = LENGTH OF VAR NAME\n         LA    R5,VOLSER           R5 ==> ADDRESS OF VARIABLE\n         ST    R5,VALPTR           STORE ADDRESS OF VARIABLE IN VALPTR\n         MVC   VALLEN,=F'6'        VALLEN = LENGTH OF DATA FIELD\n         LA    R1,UPDTLIST         R1 ==> IKJUPDT PARM LIST\n         CALL  IKJUPDT             DO THE UPDATE\n         L     R14,SAVEIT19\n         BR    14\n         EJECT\n********************************************************************\n*                                                                  *\n*        BUILD UPDATE PARM LIST FOR &DSORG AND CALL IKJUPDT        *\n*                                                                  *\n********************************************************************\n*\nSETDSORG ST    R14,SAVEIT20\n         LA    R9,=C'DSORG'        R9 ==> ADDRESS OF VAR NAME\n         ST    R9,LOCPTR           STORE ADDR OF VAR NAME IN LOCPTR\n         MVC   LOCLEN,=F'5'        LOCLEN = LENGTH OF VAR NAME\n         LA    R5,DSORG            R5 ==> ADDRESS OF VARIABLE\n         ST    R5,VALPTR           STORE ADDRESS OF VARIABLE IN VALPTR\n         MVC   VALLEN,=F'2'        VALLEN = LENGTH OF DATA FIELD\n         LA    R1,UPDTLIST         R1 ==> IKJUPDT PARM LIST\n         CALL  IKJUPDT             DO THE UPDATE\n         L     R14,SAVEIT20\n         BR    14\n         EJECT\n********************************************************************\n*                                                                  *\n*        BUILD UPDATE PARM LIST FOR &ISITCAT AND CALL IKJUPDT      *\n*                                                                  *\n********************************************************************\n*\nSETISCAT ST    R14,SAVEIT21\n         LA    R9,=C'ISITCAT'      R9 ==> ADDRESS OF VAR NAME\n         ST    R9,LOCPTR           STORE ADDR OF VAR NAME IN LOCPTR\n         MVC   LOCLEN,=F'7'        LOCLEN = LENGTH OF VAR NAME\n         LA    R5,ISITCAT          R5 ==> ADDRESS OF VARIABLE\n         ST    R5,VALPTR           STORE ADDRESS OF VARIABLE IN VALPTR\n         MVC   VALLEN,=F'3'        VALLEN = LENGTH OF DATA FIELD\n         LA    R1,UPDTLIST         R1 ==> IKJUPDT PARM LIST\n         CALL  IKJUPDT             DO THE UPDATE\n         L     R14,SAVEIT21\n         BR    14\n         EJECT\n********************************************************************\n*                                                                  *\n*        BUILD UPDATE PARM LIST FOR &MEMFND AND CALL IKJUPDT       *\n*                                                                  *\n********************************************************************\n*\nSETMEMFD ST    R14,SAVEIT23\n         LA    R9,=C'MEMFND'       R9 ==> ADDRESS OF VAR NAME\n         ST    R9,LOCPTR           STORE ADDR OF VAR NAME IN LOCPTR\n         MVC   LOCLEN,=F'6'        LOCLEN = LENGTH OF VAR NAME\n         LA    R5,MEMFND           R5 ==> ADDRESS OF VARIABLE\n         ST    R5,VALPTR           STORE ADDRESS OF VARIABLE IN VALPTR\n         MVC   VALLEN,=F'3'        VALLEN = LENGTH OF DATA FIELD\n         LA    R1,UPDTLIST         R1 ==> IKJUPDT PARM LIST\n         CALL  IKJUPDT             DO THE UPDATE\n         L     R14,SAVEIT23\n         BR    14\n         EJECT\n********************************************************************\n*                                                                  *\n*        BUILD UPDATE PARM LIST FOR &MEMCNTL AND CALL IKJUPDT      *\n*                                                                  *\n********************************************************************\n*\nSETMEMCT ST    R14,SAVEIT24\n         LA    R9,=C'MEMCNTL'      R9 ==> ADDRESS OF VAR NAME\n         ST    R9,LOCPTR           STORE ADDR OF VAR NAME IN LOCPTR\n         MVC   LOCLEN,=F'7'        LOCLEN = LENGTH OF VAR NAME\n         LA    R5,MEMCNTL          R5 ==> ADDRESS OF VARIABLE\n         ST    R5,VALPTR           STORE ADDRESS OF VARIABLE IN VALPTR\n         MVC   VALLEN,=F'3'        VALLEN = LENGTH OF DATA FIELD\n         LA    R1,UPDTLIST         R1 ==> IKJUPDT PARM LIST\n         CALL  IKJUPDT             DO THE UPDATE\n         L     R14,SAVEIT24\n         BR    14\n         EJECT\n********************************************************************\n*                                                                  *\n*        BUILD UPDATE PARM LIST FOR &TRKSUSED AND CALL IKJUPDT     *\n*                                                                  *\n********************************************************************\n*\nSETRKUSD ST    R14,SAVEIT29\n         LA    R9,=C'TRKSUSED'     R9 ==> ADDRESS OF VAR NAME\n         ST    R9,LOCPTR           STORE ADDR OF VAR NAME IN LOCPTR\n         MVC   LOCLEN,=F'8'        LOCLEN = LENGTH OF VAR NAME\n         LA    R5,TRKSUSED         R5 ==> ADDRESS OF VARIABLE\n         ST    R5,VALPTR           STORE ADDRESS OF VARIABLE IN VALPTR\n         MVC   VALLEN,=F'5'        VALLEN = LENGTH OF DATA FIELD\n         LA    R1,UPDTLIST         R1 ==> IKJUPDT PARM LIST\n         CALL  IKJUPDT             DO THE UPDATE\n         L     R14,SAVEIT29\n         BR    14\n         EJECT\n********************************************************************\n*                                                                  *\n*        BUILD UPDATE PARM LIST FOR &EXTENTNO AND CALL IKJUPDT     *\n*                                                                  *\n********************************************************************\n*\nSETEXTNO ST    R14,SAVEIT30\n         LA    R9,=C'EXTENTNO'     R9 ==> ADDRESS OF VAR NAME\n         ST    R9,LOCPTR           STORE ADDR OF VAR NAME IN LOCPTR\n         MVC   LOCLEN,=F'8'        LOCLEN = LENGTH OF VAR NAME\n         LA    R5,EXTENTNO         R5 ==> ADDRESS OF VARIABLE\n         ST    R5,VALPTR           STORE ADDRESS OF VARIABLE IN VALPTR\n         MVC   VALLEN,=F'2'        VALLEN = LENGTH OF DATA FIELD\n         LA    R1,UPDTLIST         R1 ==> IKJUPDT PARM LIST\n         CALL  IKJUPDT             DO THE UPDATE\n         L     R14,SAVEIT30\n         BR    14\n         EJECT\n********************************************************************\n*                                                                  *\n*        BUILD UPDATE PARM LIST FOR &OUTMSG AND CALL IKJUPDT       *\n*                                                                  *\n********************************************************************\n*\nSETOUTMG ST    R14,SAVEIT25\n         LA    R9,=C'OUTMSG'       R9 ==> ADDRESS OF VAR NAME\n         ST    R9,LOCPTR           STORE ADDR OF VAR NAME IN LOCPTR\n         MVC   LOCLEN,=F'6'        LOCLEN = LENGTH OF VAR NAME\n         LA    R5,OUTMSG           R5 ==> ADDRESS OF VARIABLE\n         ST    R5,VALPTR           STORE ADDRESS OF VARIABLE IN VALPTR\n         MVC   VALLEN,=F'30'       VALLEN = LENGTH OF DATA FIELD\n         LA    R1,UPDTLIST         R1 ==> IKJUPDT PARM LIST\n         CALL  IKJUPDT             DO THE UPDATE\n         L     R14,SAVEIT25\n         BR    14\n         EJECT\n********************************************************************\n*                                                                  *\n*        E N D   O F   J O B   R O U T I N E                       *\n*                                                                  *\n********************************************************************\n*\nSHUTDOWN LR   R15,R4\n         LEAVER\n         EJECT\n         SPACE 3\n********************************************************************\n*                                                                  *\n*        D A T A   A R E A   C O N S T A N T S                     *\n*                                                                  *\n********************************************************************\n*\nHEX0001  DC    X'0001'\nYESS     DC    C'YES'\nNOPE     DC    C'NO '\nMESS0    DC    C'SUCCESSFUL COMPLETION         '\nMESS4    DC    C'DATASET NOT CATALOGED         '\nMESS8    DC    C'FILE IS ON MORE THAN 1 VOLUME '\nMESS12   DC    C'REQUIRED VOLUME NOT MOUNTED   '\nMESS16   DC    C'FORMAT-1 DSCB NOT FOUND ON VOL'\nMESS20   DC    C'OBTAIN MACRO RETURNED RC 12/16'\nMESS24   DC    C'MEMBER NAME NOT FOUND         '\nMESS28   DC    C'UNSUCCESFUL DYNAMIC ALLOCATION'\nMESS32   DC    C'I/O ERROR READING DIRECTORY   '\nMESS36   DC    C'UNSUCCESSFUL FREE OF DDNAME   '\nMESS40   DC    C'FILE IS ON A TAPE VOLUME      '\nMESS44   DC    C'DATASET NOT PARTITIONED       '\nMESS48   DC    C'INVALID SYNTAX OF MEMBER NAME '\nMESS52   DC    C'ERROR IN PROGRAM FILSPACE     '\nMESS96   DC    C'INVALID SYNTAX OF OPERAND(S)  '\nORGTABLE DC    C'ISPSDACXCQMQPOU VS'\nOKCHARS1 DC    C'ABCDEFGHIJKLMNOPQRSTUVWXYZ@$#+'\nOKCHARS2 DC    C'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789@$# +'\n         LTORG\n         EJECT\n         SPACE 3\n********************************************************************\n*                                                                  *\n*        D Y N A M I C   W O R K   A R E A                         *\n*                                                                  *\n********************************************************************\n*\nWORKAREA DSECT\nSAVEAREA DS    18F\nPPLA     DS    7F\nANS      DS    F\nECB      DS    F\nQUALDSN  DS    CL44\nINVOL    DS    CL6\nQUALMEM  DS    CL8\nCPMEM1   DS    CL8\nCPMEM2   DS    CL8\nCAMLIST1 CAMLST NAME,QUALDSN,,LOCAREA\nCAML1LEN EQU   *-CAMLIST1                                               ----V1M3\nLOCAREA  DS    0D\n         DS    265C\n         DS    0D\nCAMLIST2 CAMLST SEARCH,QUALDSN,OBTVOL,OBTAREA\nCAML2LEN EQU   *-CAMLIST2                                               ----V1M3\nOBTAREA  DS    0D\n         DS    140C\n         DS    0D\nOBTVOL   DS    CL6\n*\n*   THESE FIELDS ARE TO BECOME THE CLIST VARIABLE FIELDS BY SAME NAME\n*\nFULLDSN  DS    CL54\nLRECL    DS    CL5\nBLKSIZE  DS    CL5\nRECFM    DS    CL1\nCNTLCHAR DS    CL1\nDEVTYPE  DS    CL1\nVOLSER   DS    CL6\nDSORG    DS    CL2\nISITCAT  DS    CL3\nMEMFND   DS    CL3\nMEMCNTL  DS    CL3\nTRKSUSED DS    CL5\nEXTENTNO DS    CL2\nOUTMSG   DS    CL30\n*\n****************************************************************\n*\nPROCESSW DS    CL3\nGOODCALL DS    CL3\nVALIDMEM DS    CL3\n         DS    0D\nDUBLWURD DS    D\nFULLWURD DS    F\nSAVEIT2  DS    F\nSAVEIT3  DS    F\nSAVEIT4  DS    F\nSAVEIT5  DS    F\nSAVEIT6  DS    F\nSAVEIT7  DS    F\nSAVEIT9  DS    F\nSAVEIT10 DS    F\nSAVEIT11 DS    F\nSAVEIT13 DS    F\nSAVEIT14 DS    F\nSAVEIT15 DS    F\nSAVEIT16 DS    F\nSAVEIT17 DS    F\nSAVEIT18 DS    F\nSAVEIT19 DS    F\nSAVEIT20 DS    F\nSAVEIT21 DS    F\nSAVEIT23 DS    F\nSAVEIT24 DS    F\nSAVEIT25 DS    F\nSAVEIT26 DS    F\nSAVEIT27 DS    F\nSAVEIT28 DS    F\nSAVEIT29 DS    F\nSAVEIT30 DS    F\nSAVEIT31 DS    F\nSAVR1    DS    F\n*\nUPDTLIST DS    0F\nUPDTUPT  DS    F\nUPDTECT  DS    F\nUPDTECB  DS    F\nUPDTUPL  DS    F\n*\nUPLIST   DS    0F\nLOCPTR   DS    AL4\nLOCLEN   DS    FL4\nVALPTR   DS    AL4\nVALLEN   DS    FL4\n*\nACCTVAL  DS    CL9\nIOAREA   DS    0CL56\n         DS    CL2\nFNDMEMBR DS    CL8\nFNDDSN   DS    CL44\nINDICATR DS    CL2\nFNDVOL   DS    CL6\nFLSPAREA DS    0CL59\n         DS    CL2\nFLSPDSN  DS    CL44\nFLSPVOL  DS    CL6\nOUTEXTNO DS    CL2\nOUTTRKNO DS    CL5\nRPPL     CALL  ,(0,0),VL,MF=L                                           ----V1M3\nWORKLEN  EQU   *-WORKAREA\nFILEINFO CSECT\n         EJECT\n********************************************************************\n*                                                                  *\n*                   P A R S E   M A C R O S                        *\n*                                                                  *\n********************************************************************\n*\nPCL      IKJPARM\nDSN      IKJKEYWD DEFAULT='DSN'\n         IKJNAME 'DSNAME',SUBFLD=DSNAM,ALIAS=('DATASET')\nVOL      IKJKEYWD DEFAULT='VOL(999999)'\n         IKJNAME 'VOLUME',SUBFLD=VOLSR,ALIAS=('VOLSER')\nMEM      IKJKEYWD DEFAULT='MEM'\n         IKJNAME 'MEMBER',SUBFLD=MEMBR\nDSNAM    IKJSUBF\nDSTRING  IKJPOSIT DSNAME,USID\nVOLSR    IKJSUBF\nVSTRING  IKJPOSIT DSNAME,VOLSER\nMEMBR    IKJSUBF\nMSTRING  IKJIDENT 'MEM NAME',MAXLNTH=13,DEFAULT='99999999',CHAR\n         IKJENDP\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "FILEUSE": {"ttr": 18689, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x00\\x7f\\x00\\x88\\x00\\x7f\\x12\\x00\\x025\\x025\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf2\\xf7\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-01-07T00:00:00", "modifydate": "1988-01-07T12:00:00", "lines": 565, "newlines": 565, "modlines": 0, "user": "FILE270"}, "text": "       ID DIVISION.\n       PROGRAM-ID.     FILEUSE.\n       AUTHOR.         JEFF SPREHN.\n           EJECT\n       ENVIRONMENT DIVISION.\n       CONFIGURATION SECTION.\n       SPECIAL-NAMES.\n           C01 IS NEW-PAGE.\n       INPUT-OUTPUT SECTION.\n\n       FILE-CONTROL.\n\n           SELECT  INPUT-FILE          ASSIGN UT-S-INPUT.\n           SELECT  REPORT-FILE         ASSIGN UT-S-REPORT.\n           EJECT\n       DATA DIVISION.\n\n       FILE SECTION.\n\n       FD  INPUT-FILE\n           LABEL RECORDS ARE   STANDARD\n           RECORDING MODE IS   F\n           RECORD CONTAINS     80 CHARACTERS\n           BLOCK CONTAINS      0 RECORDS\n           DATA RECORDS IS     INPUT-REC.\n\n       01  INPUT-REC.\n           05  INPUT-DSNAME                       PIC X(44).\n           05  FILLER                             PIC X(36).\n           EJECT\n\n       FD  REPORT-FILE\n           LABEL RECORDS ARE   STANDARD\n           RECORDING MODE IS   F\n           RECORD CONTAINS     133 CHARACTERS\n           BLOCK CONTAINS      0 RECORDS\n           DATA RECORDS IS     REPORT-REC.\n\n       01  REPORT-REC.\n           05  FILLER                              PIC X.\n           05  REPORT-LINE                         PIC X(132).\n           EJECT\n       WORKING-STORAGE SECTION.\n\n       77  TIME-TO-QUIT        VALUE 'NO '         PIC XXX.\n       77  PENDING-PRINT-LINE                      PIC X(132).\n       77  THE-LINE-CTR        VALUE +99           PIC S99.\n       77  HOLD-JOBNAME                            PIC X(8).\n\n           EJECT\n      *\n      ***********************************************\n      *   P A S S D S C B   P A R A M E T E R S     *\n      ***********************************************\n      *\n       01  PASSDSCB-DSN                            PIC X(44).\n       01  PASSDSCB-VOL                            PIC X(6).\n       01  PASSDSCB-VALID-SWITCH                   PIC X(3).\n       01  PASSDSCB-ERR-MSG                        PIC X(30).\n       01  PASSDSCB-DSCB1.\n           05  FILLER                              PIC X(17).\n           05  LAST-ACCESSOR                       PIC X(08).\n           05  FILLER                              PIC X(06).\n           05  LAST-ACCESS-DATE.\n               10  BYTE-1                          PIC X.\n               10  BYTES-2-3                       PIC XX.\n           05  FILLER                              PIC X(106).\n           EJECT\n      *\n      ***********************************************\n      *   F I L E A T T R   P A R A M E T E R S     *\n      ***********************************************\n      *\n       01  FILEATTR-IN-DSN                         PIC X(44).\n       01  FILEATTR-OUT-VALID-SWITCH               PIC X(3).\n       01  FILEATTR-OUT-ERROR-MESSAGE.\n           05  BYTES-1-13                          PIC X(13).\n           05  FILLER                              PIC X(17).\n       01  FILEATTR-OUT-VOLSER                     PIC X(6).\n       01  FILEATTR-OUT-LRECL                      PIC 9(5).\n       01  FILEATTR-OUT-BLKSIZE                    PIC 9(5).\n       01  FILEATTR-OUT-DSORG                      PIC X(2).\n       01  FILEATTR-OUT-RECFM                      PIC X(1).\n       01  FILEATTR-OUT-DEVICE                     PIC X(1).\n       01  FILEATTR-IN-VOLSER                      PIC X(6).\n           EJECT\n      *\n      ***********************************************\n      *   J T O S C O N V   P A R A M E T E R S     *\n      ***********************************************\n      *\n\n\n       01  JTOSCONV-I-O-AREA.\n           05  FILLER                              PIC X(8).\n           05  STANDARD-DATE.\n               10  MONTH                           PIC XX.\n               10  DAYY                            PIC XX.\n               10  YEAR                            PIC XX.\n           05  JULIAN-DATE                         PIC X(5).\n           05  INVALID-INPUT-DATE                  PIC X(3).\n\n           EJECT\n      *\n      ***********************************************\n      *   R E P O R T   P R I N T   L I N E S       *\n      *            (GENERATED BY CODEIT)            *\n      ***********************************************\n      *\n       01  TITLE-LINE.\n           05  FILLER\n                PIC X(47)\n                VALUE ' DATASET INFORMATION FOR ALL DATASETS BEGINNING'.\n           05  FILLER\n                PIC X(28)\n                VALUE ' WITH HIGH LEVEL QUALIFIER: '.\n           05  THE-PREFIX\n                PIC X(08).\n           05  FILLER\n                PIC X(47)\n                VALUE  SPACE.\n           05  FILLER\n                PIC X(02)\n                VALUE  SPACE.\n\n       01  COL-HEAD-1.\n           05  FILLER\n                PIC X(47)\n                VALUE  SPACE.\n           05  FILLER\n                PIC X(47)\n                VALUE ' RECORD                                     DAT'.\n           05  FILLER\n                PIC X(38)\n                VALUE 'E  OF   JOBNAME/LOGONID               '.\n\n       01  COL-HEAD-2.\n           05  FILLER\n                PIC X(47)\n                VALUE ' DATASET NAME                                  '.\n           05  FILLER\n                PIC X(47)\n                VALUE ' FORMAT     LRECL   BLKSIZE  DSORG  VOLUME  LAS'.\n           05  FILLER\n                PIC X(38)\n                VALUE 'T OPEN  OF LAST USER                  '.\n\n       01  COL-HEAD-3.\n           05  FILLER\n                PIC X(47)\n                VALUE ' --------------------------------------------  '.\n           05  FILLER\n                PIC X(47)\n                VALUE '---------  -------  -------  -----  ------  ---'.\n           05  FILLER\n                PIC X(38)\n                VALUE '------  ---------------               '.\n\n       01  DETAIL-LINE.\n           05  FILLER\n                PIC X(01)\n                VALUE  SPACE.\n           05  THE-DSNAME\n                PIC X(44).\n           05  FILLER\n                PIC X(02)\n                VALUE  SPACE.\n           05  THE-REC-FORMAT\n                PIC X(09).\n           05  FILLER\n                PIC X(03)\n                VALUE  SPACE.\n           05  THE-LRECL\n                PIC ZZZZ9.\n           05  FILLER\n                PIC X(04)\n                VALUE  SPACE.\n           05  THE-BLKSIZE\n                PIC ZZZZ9.\n           05  FILLER\n                PIC X(04)\n                VALUE  SPACE.\n           05  THE-DSORG\n                PIC XX.\n           05  FILLER\n                PIC X(04)\n                VALUE  SPACE.\n           05  THE-VOL-SER-NO\n                PIC X(06).\n           05  FILLER\n                PIC X(02)\n                VALUE  SPACE.\n           05  THE-DATE-OF-LAST-OPEN.\n               10  THE-MONTH\n                PIC XX.\n               10  FILLER\n                PIC X(01)\n                VALUE '-'.\n               10  THE-DAY\n                PIC XX.\n               10  FILLER\n                PIC X(01)\n                VALUE '-'.\n               10  THE-YEAR\n                PIC XX.\n           05  FILLER\n                PIC X(06)\n                VALUE  SPACE.\n           05  THE-LAST-USER\n                PIC X(08).\n           05  FILLER\n                PIC X(19)\n                VALUE  SPACE.\n\n       01  COMMON-ERROR-LINE.\n           05  FILLER\n                PIC X(01)\n                VALUE  SPACE.\n           05  THE-DSNAME\n                PIC X(44).\n           05  FILLER\n                PIC X(02)\n                VALUE  SPACE.\n           05  THE-ERROR-REASON\n                PIC X(66).\n           05  FILLER\n                PIC X(19)\n                VALUE  SPACE.\n\n       01  DATASET-ON-TAPE-PRINT-LINE.\n           05  FILLER  VALUE SPACE         PIC X(01).\n           05  THE-DSNAME                  PIC X(44).\n           05  FILLER  VALUE SPACES        PIC X(02).\n           05  FILLER                      PIC X(18)   VALUE\n                   'DATASET IS ON TAPE'.\n           05  FILLER  VALUE SPACES        PIC X(18).\n           05  THE-VOLSER                  PIC X(6).\n           05  FILLER  VALUE SPACES        PIC X(43).\n           EJECT\n      *\n      **************************************************************\n      *   O T H E R   W O R K I N G   S T O R A G E   F I E L D S  *\n      **************************************************************\n      *\n\n       01  YEAR-OF-LAST-ACCESS.\n           05  FILLER   VALUE LOW-VALUE            PIC X.\n           05  LAST-ACCESS-YEAR                    PIC X.\n\n       01  REDEF-YR-OF-LAST-ACCESS\n             REDEFINES YEAR-OF-LAST-ACCESS         PIC S9(2) COMP.\n\n       01  DAY-OF-LAST-ACCESS.\n           05  LAST-ACCESS-DAY                     PIC XX.\n\n       01  REDEF-DAY-OF-LAST-ACCESS\n             REDEFINES DAY-OF-LAST-ACCESS         PIC S9(3) COMP.\n\n       01  LAST-ACCESS-DATE-DISPLAY.\n           05  LAST-ACCESS-YEAR                    PIC 9(2).\n           05  LAST-ACCESS-DAY                     PIC 9(3).\n\n           EJECT\n       LINKAGE SECTION.\n\n       01  PARM-AREA.\n           05  FILLER                               PIC S9(4) COMP.\n           05  PARM-PREFIX                          PIC X(8).\n\n           EJECT\n       PROCEDURE DIVISION USING PARM-AREA.\n\n           PERFORM 1000-INITIALIZATION\n              THRU 1999-EXIT-INITIALIZATION.\n\n           PERFORM 2000-MAIN-PROCESS\n              THRU 2999-EXIT-MAIN-PROCESS\n\n                    UNTIL\n\n                         TIME-TO-QUIT = 'YES'.\n\n           PERFORM 9000-END-OF-JOB\n              THRU 9999-EXIT-END-OF-JOB.\n\n           STOP RUN.\n           EJECT\n       1000-INITIALIZATION.\n\n           OPEN  INPUT  INPUT-FILE\n                 OUTPUT REPORT-FILE.\n\n           PERFORM 3000-READ-INPUT-FILE\n              THRU 3999-EXIT-READ.\n\n           MOVE PARM-PREFIX TO THE-PREFIX OF TITLE-LINE.\n\n       1999-EXIT-INITIALIZATION.\n           EXIT.\n           EJECT\n       2000-MAIN-PROCESS.\n\n           MOVE INPUT-DSNAME OF INPUT-REC TO FILEATTR-IN-DSN.\n\n           CALL 'FILEATTR' USING FILEATTR-IN-DSN\n                                 FILEATTR-OUT-VALID-SWITCH\n                                 FILEATTR-OUT-ERROR-MESSAGE\n                                 FILEATTR-OUT-VOLSER\n                                 FILEATTR-OUT-LRECL\n                                 FILEATTR-OUT-BLKSIZE\n                                 FILEATTR-OUT-DSORG\n                                 FILEATTR-OUT-RECFM\n                                 FILEATTR-OUT-DEVICE.\n\n           IF FILEATTR-OUT-VALID-SWITCH = 'YES'\n                GO TO 2100-CALL-PASSDSCB.\n\n      *    START CASE STATEMENT\n\n             IF BYTES-1-13 OF FILEATTR-OUT-ERROR-MESSAGE\n               EQUAL 'FORMAT-1 DSCB'\n                MOVE 'DATASET NOT FOUND ON VOLUME INDICATED BY CATALOG'\n                  TO THE-ERROR-REASON OF COMMON-ERROR-LINE\n                MOVE INPUT-DSNAME OF INPUT-REC\n                  TO THE-DSNAME OF COMMON-ERROR-LINE\n                MOVE COMMON-ERROR-LINE TO PENDING-PRINT-LINE\n                PERFORM 4000-WRITE-REPORT\n                   THRU 4999-EXIT-WRITE-REPORT\n                PERFORM 6000-OVERSTRIKE-ERR-LINE\n                   THRU 6999-EXIT-OVERSTRIKE\n                GO TO 2900-TAKE-ANOTHER-READ\n           ELSE\n             IF BYTES-1-13 OF FILEATTR-OUT-ERROR-MESSAGE\n               EQUAL 'INVALID SYNTA'\n                MOVE 'INVALID DATASET NAME'\n                  TO THE-ERROR-REASON OF COMMON-ERROR-LINE\n                MOVE INPUT-DSNAME OF INPUT-REC\n                  TO THE-DSNAME OF COMMON-ERROR-LINE\n                MOVE COMMON-ERROR-LINE TO PENDING-PRINT-LINE\n                PERFORM 4000-WRITE-REPORT\n                   THRU 4999-EXIT-WRITE-REPORT\n                PERFORM 6000-OVERSTRIKE-ERR-LINE\n                   THRU 6999-EXIT-OVERSTRIKE\n                GO TO 2900-TAKE-ANOTHER-READ\n           ELSE\n             IF BYTES-1-13 OF FILEATTR-OUT-ERROR-MESSAGE\n               EQUAL 'DATASET IS ON'\n                MOVE FILEATTR-OUT-VOLSER\n                  TO THE-VOLSER OF DATASET-ON-TAPE-PRINT-LINE\n                MOVE INPUT-DSNAME OF INPUT-REC\n                  TO THE-DSNAME OF DATASET-ON-TAPE-PRINT-LINE\n                MOVE DATASET-ON-TAPE-PRINT-LINE\n                  TO PENDING-PRINT-LINE\n                PERFORM 4000-WRITE-REPORT\n                   THRU 4999-EXIT-WRITE-REPORT\n                PERFORM 7000-OVERSTRIKE-ONTAPE-LINE\n                   THRU 7999-EXIT-OVERSTRIKE\n                GO TO 2900-TAKE-ANOTHER-READ\n           ELSE\n             MOVE FILEATTR-OUT-ERROR-MESSAGE\n               TO THE-ERROR-REASON OF COMMON-ERROR-LINE\n             MOVE INPUT-DSNAME OF INPUT-REC\n               TO THE-DSNAME OF COMMON-ERROR-LINE\n             MOVE COMMON-ERROR-LINE TO PENDING-PRINT-LINE\n             PERFORM 4000-WRITE-REPORT\n                THRU 4999-EXIT-WRITE-REPORT\n             PERFORM 6000-OVERSTRIKE-ERR-LINE\n                THRU 6999-EXIT-OVERSTRIKE\n             GO TO 2900-TAKE-ANOTHER-READ.\n\n      *    END CASE STATEMENT\n\n       2100-CALL-PASSDSCB.\n\n           MOVE INPUT-DSNAME OF INPUT-REC TO PASSDSCB-DSN.\n           MOVE FILEATTR-OUT-VOLSER TO PASSDSCB-VOL.\n\n           CALL 'PASSDSCB' USING PASSDSCB-DSN\n                                 PASSDSCB-VOL\n                                 PASSDSCB-VALID-SWITCH\n                                 PASSDSCB-ERR-MSG\n                                 PASSDSCB-DSCB1.\n\n           IF PASSDSCB-VALID-SWITCH = 'YES'\n               NEXT SENTENCE\n           ELSE\n               MOVE PASSDSCB-ERR-MSG\n                 TO THE-ERROR-REASON OF COMMON-ERROR-LINE\n               MOVE INPUT-DSNAME OF INPUT-REC\n                 TO THE-DSNAME OF COMMON-ERROR-LINE\n               MOVE COMMON-ERROR-LINE TO PENDING-PRINT-LINE\n               PERFORM 4000-WRITE-REPORT\n                  THRU 4999-EXIT-WRITE-REPORT\n               GO TO 2900-TAKE-ANOTHER-READ.\n\n           MOVE INPUT-DSNAME OF INPUT-REC\n             TO THE-DSNAME OF DETAIL-LINE.\n\n      *    START CASE STATEMENT\n\n               IF FILEATTR-OUT-RECFM = 'F'\n                   MOVE 'FIXED    ' TO THE-REC-FORMAT OF DETAIL-LINE\n           ELSE\n               IF FILEATTR-OUT-RECFM = 'V'\n                   MOVE 'VARIABLE ' TO THE-REC-FORMAT OF DETAIL-LINE\n           ELSE\n               MOVE 'UNDEFINED' TO THE-REC-FORMAT OF DETAIL-LINE.\n\n      *    END CASE STATEMENT\n\n           MOVE FILEATTR-OUT-LRECL\n             TO THE-LRECL OF DETAIL-LINE.\n           MOVE FILEATTR-OUT-BLKSIZE\n             TO THE-BLKSIZE OF DETAIL-LINE.\n           MOVE FILEATTR-OUT-DSORG\n             TO THE-DSORG OF DETAIL-LINE.\n           MOVE FILEATTR-OUT-VOLSER\n             TO THE-VOL-SER-NO OF DETAIL-LINE.\n           PERFORM 8000-CONVERT-LAST-ACCESS-DATE\n              THRU 8999-EXIT-CONVERSION.\n           MOVE LAST-ACCESSOR OF PASSDSCB-DSCB1\n             TO HOLD-JOBNAME.\n\n           TRANSFORM HOLD-JOBNAME\n              FROM\n                  '0123456789$#@ABCDEFGHIJKLMNOPQRSTUVWXYZ|'\n                TO\n                  '||||||||||||||||||||||||||||||||||||||| '.\n\n           IF HOLD-JOBNAME = '||||||||'\n               MOVE LAST-ACCESSOR OF PASSDSCB-DSCB1\n                 TO THE-LAST-USER OF DETAIL-LINE\n           ELSE\n               MOVE 'UNKNOWN '\n                 TO THE-LAST-USER OF DETAIL-LINE.\n\n           MOVE DETAIL-LINE TO PENDING-PRINT-LINE.\n           PERFORM 4000-WRITE-REPORT\n              THRU 4999-EXIT-WRITE-REPORT.\n\n       2900-TAKE-ANOTHER-READ.\n\n           PERFORM 3000-READ-INPUT-FILE\n              THRU 3999-EXIT-READ.\n\n       2999-EXIT-MAIN-PROCESS.\n           EXIT.\n           EJECT\n       3000-READ-INPUT-FILE.\n\n           READ INPUT-FILE\n               AT END\n                   MOVE 'YES' TO TIME-TO-QUIT.\n\n       3999-EXIT-READ.\n           EXIT.\n           EJECT\n       4000-WRITE-REPORT.\n\n           IF THE-LINE-CTR GREATER THAN +55\n                PERFORM 5000-WRITE-HEADINGS\n                   THRU 5999-EXIT-WRITE-HEADINGS.\n\n           MOVE PENDING-PRINT-LINE TO REPORT-LINE OF REPORT-REC.\n           WRITE REPORT-REC AFTER 1.\n           ADD +1 TO THE-LINE-CTR.\n\n       4999-EXIT-WRITE-REPORT.\n           EXIT.\n           EJECT\n       5000-WRITE-HEADINGS.\n\n           MOVE TITLE-LINE TO REPORT-LINE OF REPORT-REC.\n           WRITE REPORT-REC AFTER NEW-PAGE.\n           MOVE COL-HEAD-1 TO REPORT-LINE OF REPORT-REC.\n           WRITE REPORT-REC AFTER 2.\n           MOVE COL-HEAD-2 TO REPORT-LINE OF REPORT-REC.\n           WRITE REPORT-REC AFTER 1.\n           MOVE COL-HEAD-3 TO REPORT-LINE OF REPORT-REC.\n           WRITE REPORT-REC AFTER 1.\n           MOVE SPACES TO REPORT-LINE OF REPORT-REC.\n           WRITE REPORT-REC AFTER 1.\n           MOVE +6 TO THE-LINE-CTR.\n\n       5999-EXIT-WRITE-HEADINGS.\n           EXIT.\n           EJECT\n       6000-OVERSTRIKE-ERR-LINE.\n\n           MOVE SPACES TO THE-DSNAME OF COMMON-ERROR-LINE.\n           MOVE COMMON-ERROR-LINE TO REPORT-LINE OF REPORT-REC.\n           WRITE REPORT-REC AFTER 0.\n           MOVE COMMON-ERROR-LINE TO REPORT-LINE OF REPORT-REC.\n           WRITE REPORT-REC AFTER 0.\n           MOVE COMMON-ERROR-LINE TO REPORT-LINE OF REPORT-REC.\n           WRITE REPORT-REC AFTER 0.\n\n       6999-EXIT-OVERSTRIKE.\n           EXIT.\n           EJECT\n       7000-OVERSTRIKE-ONTAPE-LINE.\n\n           MOVE SPACES\n             TO THE-DSNAME OF DATASET-ON-TAPE-PRINT-LINE.\n           MOVE SPACES\n             TO THE-VOLSER OF DATASET-ON-TAPE-PRINT-LINE.\n           MOVE DATASET-ON-TAPE-PRINT-LINE\n             TO REPORT-LINE OF REPORT-REC.\n           WRITE REPORT-REC AFTER 0.\n           MOVE DATASET-ON-TAPE-PRINT-LINE\n             TO REPORT-LINE OF REPORT-REC.\n           WRITE REPORT-REC AFTER 0.\n           MOVE DATASET-ON-TAPE-PRINT-LINE\n             TO REPORT-LINE OF REPORT-REC.\n           WRITE REPORT-REC AFTER 0.\n\n       7999-EXIT-OVERSTRIKE.\n           EXIT.\n           EJECT\n       8000-CONVERT-LAST-ACCESS-DATE.\n\n           MOVE BYTE-1 OF LAST-ACCESS-DATE OF PASSDSCB-DSCB1\n             TO LAST-ACCESS-YEAR OF YEAR-OF-LAST-ACCESS.\n\n           MOVE REDEF-YR-OF-LAST-ACCESS\n             TO LAST-ACCESS-YEAR OF LAST-ACCESS-DATE-DISPLAY.\n\n           MOVE BYTES-2-3 OF LAST-ACCESS-DATE OF PASSDSCB-DSCB1\n             TO LAST-ACCESS-DAY OF DAY-OF-LAST-ACCESS.\n\n           MOVE REDEF-DAY-OF-LAST-ACCESS\n             TO LAST-ACCESS-DAY OF LAST-ACCESS-DATE-DISPLAY.\n\n           MOVE LAST-ACCESS-DATE-DISPLAY\n             TO JULIAN-DATE OF JTOSCONV-I-O-AREA.\n\n           CALL 'JTOSCONV' USING JTOSCONV-I-O-AREA.\n\n           IF INVALID-INPUT-DATE OF JTOSCONV-I-O-AREA = 'YES'\n               MOVE '??' TO THE-MONTH OF THE-DATE-OF-LAST-OPEN\n                                            OF DETAIL-LINE\n               MOVE '??' TO THE-DAY OF THE-DATE-OF-LAST-OPEN\n                                            OF DETAIL-LINE\n               MOVE '??' TO THE-YEAR OF THE-DATE-OF-LAST-OPEN\n                                            OF DETAIL-LINE\n               GO TO 8999-EXIT-CONVERSION.\n\n           MOVE MONTH OF STANDARD-DATE OF JTOSCONV-I-O-AREA\n             TO THE-MONTH OF THE-DATE-OF-LAST-OPEN OF DETAIL-LINE.\n           MOVE DAYY  OF STANDARD-DATE OF JTOSCONV-I-O-AREA\n             TO THE-DAY OF THE-DATE-OF-LAST-OPEN OF DETAIL-LINE.\n           MOVE YEAR  OF STANDARD-DATE OF JTOSCONV-I-O-AREA\n             TO THE-YEAR OF THE-DATE-OF-LAST-OPEN OF DETAIL-LINE.\n\n       8999-EXIT-CONVERSION.\n           EXIT.\n           EJECT\n       9000-END-OF-JOB.\n\n           CLOSE INPUT-FILE\n                 REPORT-FILE.\n\n       9999-EXIT-END-OF-JOB.\n           EXIT.\n\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "FILEUSE$": {"ttr": 18699, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x00\\x7f\\x00\\x88\\x00\\x7f\\x12\\x00\\x00\\x1c\\x00\\x1c\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf2\\xf7\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-01-07T00:00:00", "modifydate": "1988-01-07T12:00:00", "lines": 28, "newlines": 28, "modlines": 0, "user": "FILE270"}, "text": "1                                                        FILEUSE.1\n                                                         03/16/83\n\n\n  PROC NAME:     FILEUSE\n  AUTHOR:        Jeff Sprehn\n  AGENCY:        WDPSC\n  FUNCTION:      Produce  a  report  itemizing  dataset  name,\n                 record format, LRECL,  BLKSIZE, DSORG, volume\n                 serial   number,    date   of    last   open,\n                 jobname/logonid of last user of all cataloged\n                 datasets beginning  with a  given high  level\n                 qualifier in alphabetical sequence.\n\n  HOW TO USE THIS PROCEDURE\n  _________________________\n\n  //DOIT EXEC FILEUSE,PREFIX='high level qualifier'\n\n  EXAMPLE\n  _______\n\n  Produce a report itemizing all  cataloged datasets beginning with\n  AGY999.\n\n  //DOIT EXEC FILEUSE,PREFIX='AGY999'\n\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "FILSPAC$": {"ttr": 18945, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x00\\x7f\\x00\\x88\\x00\\x7f\\x12\\x00\\x005\\x005\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf2\\xf7\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-01-07T00:00:00", "modifydate": "1988-01-07T12:00:00", "lines": 53, "newlines": 53, "modlines": 0, "user": "FILE270"}, "text": "1                                                        FILSPACE.1\n                                                         07/11/84\n\n\n  PROGRAM:       FILSPACE\n  AUTHOR:        Jeff Sprehn\n  AGENCY:        WDPSC\n  LANGUAGE:      Assembler\n  LOCATION:      WDPSC.SHARED.LOAD\n  FUNCTION:      Subroutine that accepts a dataset name and volume\n                 serial number and returns the number of used extents\n                 and the number of used tracks.\n\n\n  This program is a subroutine that accepts a dataset name and the\n  volume serial number that is passed to it and returns to the invoker\n  the number of used extents and the number of used tracks.\n\n  To use this subroutine, do the following:\n\n     1.  Place the following data area in the WORKING-STORAGE:\n\n         01  FILSPACE-I-O-AREA.\n             05  FILLER                    PIC X(02).\n             05  IN-DSN                    PIC X(44).\n             05  IN-VOL-SER                PIC X(06).\n             05  OUT-NO-OF-USED-EXTENTS    PIC 9(2).\n             05  OUT-NO-OF-USED-TRACKS     PIC 9(5).\n\n     2.  Place the following code in the PROCEDURE DIVISION:\n\n         MOVE the dataset name\n           TO IN-DSN OF FILSPACE-I-O-AREA.\n\n         MOVE the volume serial number\n           TO IN-VOL-SER OF FILSPACE-I-O-AREA.\n\n         CALL 'FILSPACE' USING FILSPACE-I-O-AREA.\n\n\n  Possible RETURN CODES\n  _____________________\n\n     RETURN CODE        Meaning\n     ___________        _____________________________________________\n\n         0              Successful completion\n         4              Required volume is not mounted\n         8              Dataset is not found on volume indicated\n         12             OBTAIN Macro returned with RC = 12, 16, or 20\n         16             Error in VOL2DEVT was encountered\n\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "FILSPACE": {"ttr": 18947, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x00\\x7f\\x00\\x88\\x00\\x7f\\x12\\x00\\x01\\xbd\\x01\\xbd\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf2\\xf7\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-01-07T00:00:00", "modifydate": "1988-01-07T12:00:00", "lines": 445, "newlines": 445, "modlines": 0, "user": "FILE270"}, "text": "*        THIS PROGRAM IS A SUBROUTINE THAT ACCEPTS A DATASET NAME\n*        AND THE VOLUME SERIAL NUMBER THAT IS PASSED TO IT AND\n*        RETURNS TO THE INVOKER THE NUMBER OF USED EXTENTS AND THE\n*        NUMBER OF USED TRACKS.\n*\n*        TO USE THIS SUBROUTINE, DO THE FOLLOWING:\n*\n*           1.  PLACE THE FOLLOWING DATA AREA IN THE WORKING-STORAGE:\n*\n*               01  FILSPACE-I-O-AREA.\n*                   05  FILLER                    PIC X(02).\n*                   05  IN-DSN                    PIC X(44).\n*                   05  IN-VOL-SER                PIC X(06).\n*                   05  OUT-NO-OF-USED-EXTENTS    PIC 9(2).\n*                   05  OUT-NO-OF-USED-TRACKS     PIC 9(5).\n*\n*           2.  PLACE THE FOLLOWING CODE IN THE PROCEDURE DIVISION:\n*\n*               MOVE DATASET NAME\n*                 TO IN-DSN OF FILSPACE-I-O-AREA.\n*\n*               MOVE VOLUME SERIAL NUMBER\n*                 TO IN-VOL-SER OF FILSPACE-I-O-AREA.\n*\n*               CALL 'FILSPACE' USING FILSPACE-I-O-AREA.\n*\n*\n*        POSSIBLE RETURN CODES\n*        _____________________\n*\n*           RETURN CODE        MEANING\n*           ___________        ______________________________________\n*\n*               0              SUCCESSFUL COMPLETION\n*               4              REQUIRED VOLUME IS NOT MOUNTED\n*               8              DATASET IS NOT FOUND ON VOLUME\n*                                  INDICATED\n*               12             OBTAIN MACRO RETURNED WITH\n*                                  RC = 12, 16, OR 20\n*               16             ERROR IN VOL2DEVT WAS ENCOUNTERED\n*\n*\n*---------------------------------------------------------------------\n*\n*  ACTIVITY LOG:\n*     VERSION 2.0  -  GORDON SCHILLINGER  DIS/CSD             9/9/88\n*                     MODIFIED CODE TO BE RE-ENTERANT\n*\n*---------------------------------------------------------------------\n         EJECT\n**********************************************\n*                                            *\n*        I N I T I A L I Z A T I O N         *\n*                                            *\n**********************************************\n*\nFILSPACE ENTERR LEVEL=V_2.0\n         LR    R11,R1\n         L     R9,0(R11)\n         MVC   PASSAREA,0(R9)\n********************************************************************\n*                                                                  *\n*        M A I N   L I N E   L O G I C                             *\n*                                                                  *\n********************************************************************\n*\n         MVC   PROCESSW,=CL3'YES'  MOVE 'YES' TO PROCESSW\n         LA    R10,0               R10 ==> 0\n*\n***      INITIALIZE DYNAMIC AREAS\n         MVI   CAMLIST2,193\n         LA    R1,INDSN\n         LA    R2,INVOL\n         LA    R3,OBTAREA\n         STM   R1,R3,CAMLIST2+4\n         MVI   CAMLIST3,192\n         MVI   CAMLIST3+1,128\n         LA    R1,CCHHR\n         LA    R2,INVOL\n         LA    R3,DCB3AREA\n         STM   R1,R3,CAMLIST3+4\n         MVC   PACKED0(PACKILEN),PACKINIT\n*\n         BAL   R14,OBTANE          PERFORM ROUTINE TO DO OBTAIN\n         CLC   PROCESSW,=CL3'YES'  WERE ANY ERRORS ENCOUNTERED ?\n         BNE   GETOUT              IF SO, BRANCH TO GETOUT\n         BAL   R14,EYEDSCB1        PERFORM ROUTINE TO PROCESS THE DSCB1\n         CLC   PROCESSW,=CL3'YES'  WERE ANY ERRORS ENCOUNTERED ?\n         BNE   GETOUT              IF SO, BRANCH TO GETOUT\n         CLC   PROCDCB3,=CL3'YES'  DO WE NEED TO PROCESS THE DSCB3 ?\n         BNE   GETOUT              IF NOT, BRANCH TO GETOUT\n         BAL   R14,EYEDSCB3        PERFORM ROUTINE TO PROCESS THE DSCB3\nGETOUT   B     SHUTDOWN            BRANCH TO SHUTDOWN\n         EJECT\n********************************************************************\n*                                                                  *\n*        THIS ROUTINE IS RESPONSIBLE FOR DOING AN OBTAIN ON THE    *\n*        DATASET NAME                                              *\n*                                                                  *\n*        IF THE OBTAIN MACRO ISSUES A RETURN CODE OF 0, THEN       *\n*        THIS ROUTINE MOVES 'YES' TO PROCESSW ELSE IT MOVES        *\n*        'NO ' TO PROCESSW                                         *\n*                                                                  *\n********************************************************************\n*\nOBTANE   ST    R14,SAVEIT1\nOBTAAN   OBTAIN CAMLIST2\n         SPACE 2\n         C     R15,=F'0'              COMPARE REG 15 TO BE = 0\n         BE    EXITOBT                IF REG 15=0, BRANCH TO EXITOBT\n         C     R15,=F'4'              COMPARE REG 15 TO BE = 4\n         BE    RCODE4                 IF REG 15=4, BRANCH TO RCODE4\n         C     R15,=F'8'              COMPARE REG 15 TO BE = 8\n         BE    RCODE8                 IF REG 15=8, BRANCH TO RCODE8\n         LA    R10,12                 R10==> 12\n         B     MOVENOPE               BRANCH TO MOVENOPE\nRCODE4   LA    R10,4                  R10==> 4\n         B     MOVENOPE               BRANCH TO MOVENOPE\nRCODE8   LA    R10,8                  R10==> 8\nMOVENOPE MVC   PROCESSW,=CL3'NO '     MOVE 'NO ' TO PROCESSW\nEXITOBT  L     R14,SAVEIT1\n         BR    14                     RETURN\n         EJECT\n********************************************************************\n*                                                                  *\n*        THIS ROUTINE IS RESPONSIBLE FOR PROCESSING THE DSCB1.     *\n*                                                                  *\n*        IF AN ERROR IS ENCOUNTERED, THIS ROUTINE DOES THE         *\n*        FOLLOWING:                                                *\n*                                                                  *\n*             .  MOVES 'NO ' TO PROCESSW                           *\n*             .  MOVES APPROPRIATE VALUE TO REGISTER 10            *\n*                   WHICH IDENTIFIES THE REASON FOR THE ERROR      *\n*                                                                  *\n*        IF NO ERROR IS ENCOUNTERED AND THIS ROUTINE CALCULATES    *\n*        THAT THE USED EXTENTS DOES NOT EXCEED 3 (HENCE THERE      *\n*        IS NO DSCB3), THEN THIS ROUTINE DOES THE FOLLOWING:       *\n*                                                                  *\n*             .  MOVES 'NO ' TO PROCDCB3                           *\n*             .  MOVES APPROPRIATE VALUE TO OUTTRKNO               *\n*             .  MOVES APPROPRIATE VALUE TO OUTEXTNO               *\n*                   (I.E 1, 2 OR 3)                                *\n*                                                                  *\n*        IF NO ERROR IS ENCOUNTERED AND THIS ROUTINE CALCULATES    *\n*        THAT THE USED EXTENTS DOES EXCEED 3 AND THAT IT NEEDS TO  *\n*        PROCESS THE DSCB3, THEN THIS ROUTINE DOES THE FOLLOWING:  *\n*                                                                  *\n*             .  MOVES 'YES' TO PROCDCB3                           *\n*             .  MOVES APPROPRIATE VALUE TO OUTTRKNO               *\n*                                                                  *\n********************************************************************\nEYEDSCB1 ST    R14,SAVEIT2\n         MVC   PROCDCB3,=CL3'NO '  MOVE 'NO ' TO PROCDCB3\n         ZAP   RUNTOT,PACKED0      RUNTOT = 0\n*\n         MVC   DS1LSTAR,OBTAREA+54\n         CLC   DS1LSTAR,=XL3'000000'\n         BNE   NOTEMPTY\n         MVC   OUTEXTNO,=CL2'00'\n         MVC   OUTTRKNO,=CL5'00000'\n         B     EXITDCB1\nNOTEMPTY MVC   HALFWORD(2),DS1LSTAR\n         LH    R5,HALFWORD\n         AH    R5,=H'1'\n         CVD   R5,CVDOPRND\n         MVC   LSTRTRKS(3),CVDOPRND+5\n         UNPK  OUTTRKNO(5),LSTRTRKS(3)\n         OI    OUTTRKNO+4,X'F0'\n*\n         CLI   OBTAREA+61,X'00'    IS 1ST EXTENT DESC INSIGNIFICANT ?\n         BE    EXITDCB1            IF SO, BRANCH TO EXITDCB1\n         MVC   OUTEXTNO,=CL2'01'   MOVE 01 TO OUTEXTNO\n         MVC   BGNCCHH(4),OBTAREA+63\n         MVC   ENDCCHH(4),OBTAREA+67\n         BAL   R14,CALCTRKS        CALC # TRACKS USED IN THIS EXTENT\n         CLC   PROCESSW,=CL3'YES'  WERE ANY ERRORS ENCOUNTERED ?\n         BNE   EXITDCB1            IF SO, BRANCH TO EXITDCB1\n         AP    RUNTOT,TOTRACKS     RUNTOT = TOTAL USED TRACKS SO FAR\n         CP    LSTRTRKS,RUNTOT     DOES THIS EXTENT EXCEED DS1LSTAR?\n         BNH   EXITDCB1            IF SO, BRANCH TO EXITDCB1\n         CLI   OBTAREA+71,X'00'    IS 2ND EXTENT DESC INSIGNIFICANT ?\n         BE    EXITDCB1            IF SO, BRANCH TO EXITDCB1\n         MVC   OUTEXTNO,=CL2'02'   MOVE 02 TO OUTEXTNO\n         MVC   BGNCCHH(4),OBTAREA+73\n         MVC   ENDCCHH(4),OBTAREA+77\n         BAL   R14,CALCTRKS        CALC # TRACKS USED IN THIS EXTENT\n         CLC   PROCESSW,=CL3'YES'  WERE ANY ERRORS ENCOUNTERED ?\n         BNE   EXITDCB1            IF SO, BRANCH TO EXITDCB1\n         AP    RUNTOT,TOTRACKS     RUNTOT = TOTAL # USED TRACKS SO FAR\n         CP    LSTRTRKS,RUNTOT     DOES THIS EXTENT EXCEED DS1LSTAR\n         BNH   EXITDCB1            IF SO, BRANCH TO EXITDCB1\n         CLI   OBTAREA+81,X'00'    IS 3RD EXTENT DESC INSIGNIFICANT ?\n         BE    EXITDCB1            IF SO, BRANCH TO EXITDCB1\n         MVC   OUTEXTNO,=CL2'03'   MOVE 03 TO OUTEXTNO\n         MVC   BGNCCHH(4),OBTAREA+83\n         MVC   ENDCCHH(4),OBTAREA+87\n         BAL   R14,CALCTRKS        CALC # TRACK USED THIS EXTENT\n         CLC   PROCESSW,=CL3'YES'  WERE ANY ERRORS ENCOUNTERED ?\n         BNE   EXITDCB1            IF SO, BRANCH TO EXITDCB1\n         AP    RUNTOT,TOTRACKS     RUNTOT = TOTAL # USED TRACKS SO FAR\n         CP    LSTRTRKS,RUNTOT     DOES EXTENT EXCEED DS1LSTAR?\n         BNH   EXITDCB1            IF SO, BRANCH TO EXITDCB1\n         MVC   PROCDCB3,=CL3'YES'  MOVE 'YES' TO PROCDCB3\n         MVC   CCHHR,OBTAREA+91    MOVE CCHHR PTR FOR DSCB3 TO CCHHR\nEXITDCB1 L     R14,SAVEIT2\n         BR    14                  RETURN\n         EJECT\n********************************************************************\n*                                                                  *\n*        THIS ROUTINE IS RESPONSIBLE FOR PROCESSING THE DSCB3      *\n*        AND THEN GENERATING THE EXTENT NUMBER                     *\n*                                                                  *\n********************************************************************\nEYEDSCB3 ST    R14,SAVEIT3\nDODSCB3  OBTAIN CAMLIST3\n         SPACE 2\n         C     R15,=F'0'              COMPARE REG 15 TO BE = 0\n         BE    COUNTEM                IF REG 15=0, BRANCH TO COUNTEM\n         C     R15,=F'4'              COMPARE REG 15 TO BE = 4\n         BE    DSCB3RC4               IF REG 15=4, BRANCH TO DSCB3RC4\n         C     R15,=F'8'              COMPARE REG 15 TO BE = 8\n         BE    DSCB3RC8               IF REG 15=8, BRANCH TO DSCB3RC8\n         LA    R10,12                 R10==> 12\n         B     EXITDCB3               BRANCH TO EXITDCB3\nDSCB3RC4 LA    R10,4                  R10==> 4\n         B     EXITDCB3               BRANCH TO EXITDCB3\nDSCB3RC8 LA    R10,8                  R10==> 8\n         B     EXITDCB3               BRANCH TO EXITDCB3\nCOUNTEM  ZAP   PACKEXT#,PACKED3\n         LA    R5,DCB3AREA            R5 ==> ADDRESS OF DSCB3\n         A     R5,=F'4'               OFFSET TO DS3EXTNT\n         LA    R6,1\nLOOP3A   C     R6,=F'4'\n         BH    NXTGROUP\n         CLI   0(R5),X'00'\n         BE    UNPKEXT#\n         AP    PACKEXT#,PACKED1\n         MVC   BGNCCHH(4),2(R5)\n         MVC   ENDCCHH(4),6(R5)\n         BAL   R14,CALCTRKS        CALC # TRACKS USED THIS EXTENT\n         CLC   PROCESSW,=CL3'YES'  WERE ANY ERRORS ENCOUNTERED ?\n         BNE   EXITDCB3            IF SO, BRANCH TO EXITDCB3\n         AP    RUNTOT,TOTRACKS     RUNTOT = TOTAL USED TRACKS SO FAR\n         CP    LSTRTRKS,RUNTOT     DOES EXTENT EXCEED DS1LSTAR\n         BNH   UNPKEXT#            IF SO, BRANCH TO UNPKEXT#\n         A     R6,=F'1'\n         A     R5,=F'10'\n         B     LOOP3A\nNXTGROUP A     R5,=F'1'            OFFSET TO DS3ADEXT\n         LA    R6,1\nLOOP3B   C     R6,=F'9'\n         BH    UNPKEXT#\n         CLI   0(R5),X'00'\n         BE    UNPKEXT#\n         AP    PACKEXT#,PACKED1\n         MVC   BGNCCHH(4),2(R5)\n         MVC   ENDCCHH(4),6(R5)\n         BAL   R14,CALCTRKS        CALC # TRACKS USED THIS EXTENT\n         CLC   PROCESSW,=CL3'YES'  WERE ANY ERRORS ENCOUNTERED ?\n         BNE   EXITDCB3            IF SO, BRANCH TO EXITDCB3\n         AP    RUNTOT,TOTRACKS     RUNTOT = TOTAL USED TRACKS SO FAR\n         CP    LSTRTRKS,RUNTOT     DOES EXTENT EXCEED DS1LSTAR?\n         BNH   UNPKEXT#            IF SO, BRANCH TO UNPKEXT#\n         A     R6,=F'1'\n         A     R5,=F'10'\n         B     LOOP3B\nUNPKEXT# UNPK  OUTEXTNO(2),PACKEXT#(3)\n         OI    OUTEXTNO+1,X'F0'\nEXITDCB3 L     R14,SAVEIT3\n         BR    14                  RETURN\n         EJECT\n***********************************************************************\n*                                                                     *\n*        THIS ROUTINE CALCULATES THE NUMBER OF TRACKS GIVEN           *\n*        A BEGINNING CCHH AND AN ENDING CCHH                          *\n*                                                                     *\n*        BEFORE PERFORMING THIS ROUTINE, DO THE FOLLOWING:            *\n*                   MOVE THE BEGINNING CCHH TO BGNCCHH                *\n*                   MOVE THE ENDING CCHH TO ENDCCHH                   *\n*                                                                     *\n*        AFTER PERFORMING THIS ROUTINE, THE NUMBER OF USED            *\n*        TRACKS WILL BE IN TOTRACKS                                   *\n*                                                                     *\n***********************************************************************\nCALCTRKS ST    R14,SAVEIT4        STORE R14 CONTENTS IN SAVEIT4\n         LH    R7,BGNCCHH              ----\n         CVD   R7,CVDOPRND               ----- PACK BEGINNING CYL\n         MVC   BEGINCYL(3),CVDOPRND+5  ----\n         LH    R7,ENDCCHH              ----\n         CVD   R7,CVDOPRND               ----- PACK ENDING CYL\n         MVC   ENDCYL(3),CVDOPRND+5    ----\n         LH    R7,BGNCCHH+2            ----\n         CVD   R7,CVDOPRND               ----- PACK BEGINNING TRK\n         MVC   BEGINTRK(3),CVDOPRND+5  ----\n         LH    R7,ENDCCHH+2            ----\n         CVD   R7,CVDOPRND               ----- PACK ENDING TRK\n         MVC   ENDTRK(3),CVDOPRND+5    ----\n         ZAP   CYLDIFF,ENDCYL          CYLDIFF = ENDING CYL #\n         SP    CYLDIFF,BEGINCYL        CYLDIFF = ENDING CYL - BEGIN CYL\n         BAL   14,DETRKCYL             GET # TRACK/CYL\n         CP    ENDTRK,BEGINTRK         IF ENDING TRK # > BEGINNING TRK\n         BH    ENDISGT                    # THEN BRANCH TO ENDISGT\n         ZAP   TRKDIFF,ENDTRK          TRKDIFF = ENDING TRACK #\n         SP    TRKDIFF,BEGINTRK        TRKDIFF = ENDING TRK - BEGIN TRK\n         AP    TRKDIFF,PACKED1         ADD 1 TO TRKDIFF\n         B     DOCALC                  BRANCH TO DOCALC\nENDISGT  SP    CYLDIFF,PACKED1         SUBTRACT 1 FROM CYLDIFF\n         ZAP   REMANTRK,TRKPRCYL       REMANTRK = TRKPRCYL\n         SP    REMANTRK,BEGINTRK       REMANTRK = TRKPRCYL - BEGINTRK\n         ZAP   TRKDIFF,REMANTRK        TRKDIFF = REMANTRK\n         AP    TRKDIFF,ENDTRK          TRKDIFF = REMANTRK + ENDTRK\n         AP    TRKDIFF,PACKED1         ADD 1 TO TRKDIFF\nDOCALC   ZAP   TOTRACKS,TRKPRCYL       TOTRACKS = TRKPRCYL\n         MP    TOTRACKS,CYLDIFF        TOTRACKS = TRKPRCYL X CYLDIFF\n         AP    TOTRACKS,TRKDIFF        ADD TRKDIFF TO TOTRACKS\n         L     R14,SAVEIT4\n         BR    R14                     RETURN\n         EJECT\n***********************************************************************\n*                                                                     *\n*        THIS ROUTINE EXAMINES VOL SER TO DETERMINE THE DEVICE TYPE   *\n*        IN ORDER TO DETERMINE THE NUMBER OF TRACKS PER CYLINDER      *\n*                                                                     *\n*        AFTER PERFORMING THIS ROUTINE, THE NUMBER OF TRACKS PER      *\n*        CYLINDER IS IN TRKPRCYL                                      *\n*                                                                     *\n*        IF AN ERROR IS ENCOUNTERED IN THIS ROUTINE, IT WILL          *\n*        MOVE 'NO ' TO PROCESSW AND LOAD REGISTER 10 WITH 16          *\n*                                                                     *\n***********************************************************************\nDETRKCYL ST    R14,SAVEIT5\n         MVC   VOL2DVOL,INVOL     MOVE VOL SER TO VOL2DVOL\n         CALL  VOL2DEVT,(DEVTAREA),MF=(E,CPPL)\n         C     R15,=F'0'          WAS VOL2DEVT SUCCESSFUL ?\n         BE    EYEDEVT            IF SO, BRANCH TO EYEDEVT\n         MVC   PROCESSW,=CL3'NO ' MOVE 'NO ' TO PROCESSW\n         LA    R10,16             R10 ==> 16\n         B     EXITDETR           BRANCH TO EXITDETR\nEYEDEVT  CLC   OUTDEVT(4),=CL4'3330'\n         BE    D3330\n         CLC   OUTDEVT(4),=CL4'3350'\n         BE    D3350\n         CLC   OUTDEVT(4),=CL4'3380'\n         BE    D3380\n         MVC   PROCESSW,=CL3'NO ' MOVE 'NO ' TO PROCESSW\n         LA    R10,16             R10 ==> 16\n         B     EXITDETR           BRANCH TO EXITDETR\nD3330    ZAP   TRKPRCYL,PACKED19  MOVE 19 TO TRKPRCYL\n         B     EXITDETR           BRANCH TO EXITDETR\nD3350    ZAP   TRKPRCYL,PACKED30  MOVE 30 TO TRKPRCYL\n         B     EXITDETR           BRANCH TO EXITDETR\nD3380    ZAP   TRKPRCYL,PACKED15  MOVE 15 TO TRKPRCYL\nEXITDETR L     R14,SAVEIT5\n         BR    R14                RETURN\n         EJECT\n********************************************************************\n*                                                                  *\n*        E N D  O F   J O B   P R O C E S S I N G                  *\n*                                                                  *\n********************************************************************\nSHUTDOWN LR    R15,R10\n         L     R9,0(R11)\n         MVC   0(59,R9),PASSAREA\n         L     R13,4(R13)\n         RETURN (14,12),RC=(15)\n         EJECT\n********************************************************************\n*                                                                  *\n*        D A T A   A R E A    (STATIC)                             *\n*                                                                  *\n********************************************************************\nPACKINIT DS    0F\n         DC    PL2'0'\n         DC    PL2'1'\n         DC    PL2'3'\n         DC    PL2'15'\n         DC    PL2'19'\n         DC    PL2'30'\nPACKILEN EQU   *-PACKINIT\n         LTORG\n         EJECT\n********************************************************************\n*                                                                  *\n*        D A T A   A R E A S  (DYNAMIC)                            *\n*                                                                  *\n********************************************************************\nWORKAREA DSECT\nSAVEAREA DS    18F\nSAVEIT1  DS    F\nSAVEIT2  DS    F\nSAVEIT3  DS    F\nSAVEIT4  DS    F\nSAVEIT5  DS    F\nCPPL     CALL  ,(0),MF=L\n         DS    0D\nCAMLIST2 CAMLST SEARCH,INDSN,INVOL,OBTAREA\nOBTAREA  DS    0D\n         DS    140C\n         DS    0D\nCAMLIST3 CAMLST SEEK,CCHHR,INVOL,DCB3AREA\nDCB3AREA DS    0D\n         DS    140C\nPROCESSW DS    CL3\nPROCDCB3 DS    CL3\nCCHHR    DS    CL5\nBEGINCYL DS    PL3\nBEGINTRK DS    PL3\nBGNCCHH  DS    F\nCVDOPRND DS    D\nCYLDIFF  DS    PL3\nDS1LSTAR DS    CL3\nENDCCHH  DS    F\nENDCYL   DS    PL3\nENDTRK   DS    PL3\nHALFWORD DS    H\nLSTRTRKS DS    PL3\n*\nPACKED0  DC    PL2'0'\nPACKED1  DC    PL2'1'\nPACKED3  DC    PL2'3'\nPACKED15 DC    PL2'15'\nPACKED19 DC    PL2'19'\nPACKED30 DC    PL2'30'\n*\nPACKEXT# DS    PL3\nREMANTRK DS    PL3\nRUNTOT   DS    PL6\nTOTRACKS DS    PL6\nTRKDIFF  DS    PL3\nTRKPRCYL DS    PL3\n*\nPASSAREA DS    0CL59\n         DS    CL2\nINDSN    DS    CL44\nINVOL    DS    CL6\nOUTEXTNO DS    CL2\nOUTTRKNO DS    CL5\n*\nDEVTAREA DS    0CL16\nVOL2DVOL DS    CL6\nOUTDEVT  DS    CL8\nOUTLEN   DS    CL2\n*\nWORKLEN  EQU   *-WORKAREA\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "FINDEM": {"ttr": 18955, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x00\\x7f\\x00\\x88\\x00\\x7f\\x12\\x00\\x026\\x026\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf2\\xf7\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-01-07T00:00:00", "modifydate": "1988-01-07T12:00:00", "lines": 566, "newlines": 566, "modlines": 0, "user": "FILE270"}, "text": "*\n****************************************************\n*                                                  *\n*   FINDEM                                         *\n*   ------                                         *\n*         MODIFIED SEPT 1984 TO FOLD EACH INPUT    *\n*         RECORD BYTE TO UPPER CASE SO THAT THIS   *\n*         PROGRAM IS NO LONGER CASE SENSITIVE.     *\n*                                                  *\n*         MODIFIED SEPT (LATER THAT MONTH) TO      *\n*         LOAD R15 (RETURN CODE REGISTER) WITH     *\n*         16 IF ATTEMPTING TO SEARCH A LIBRARY     *\n*         WITH MORE THAN 2500 MEMBERS RATHER       *\n*         THAN GETTING AN OC4.                     *\n*                                                  *\n****************************************************\n*\nFINDEM   ENTER (14,12),(3,4,12),(,WORKLEN)\n         USING WORKAREA,13\n         USING MEMBERDS,7\n         BAL   R5,PARMPTR  GET PARM\n         OPEN  (DIRDCB,(INPUT))\n         BAL   R5,BLDTBL\n         CLOSE (DIRDCB)\n         OPEN  (PDSDCB,(INPUT))\n         OPEN  (PRINT,(OUTPUT))\n         LA    R7,TABLE            SET ADDR POINTER TO 1ST MEM IN TABLE\nENDCOMP  EQU   *\n         MVI   FLAG,X'FF'      SET FLAG OFF\n         CLC   0(8,R7),FFFF        HAVE ALL MEMBERS BEEN PROCESSED?\n         BE    ALLDONE             YES, GETOUT OF THIS MESS\n         BAL   R5,FINDMEM          NO, GO FIND THIS MEMBER  R7 POINTS\n         BAL   R5,PRNTMEM       TELL US WHICH MEMBER WE ARE CHECKING\n         XR    R6,R6             CLEAR POINTER REG\nREADBAL  EQU   *                   TO THE MEMBER TO BE FOUND\n         BAL   R5,GETRCD           GO GET A RECORD FROM THIS MEMBER.\n*                                  COME BACK WITH R6 POINTING TO THE\n*                                  RECORD TO BE PROCESSED\n         BAL   R5,SCANRCD          GO SCAN THE RECORD POINTED TO BY R6\n*                                  IF YOU FIND A (+1), POINT R8 TO THE\n*                                  BEGENNING OF THE DSN , PUT THE LEN\n*                                  IN R10 AND PUT A NON-ZERO IN R15.\n*                                  DON'T CHANGE R6.\n         LTR   R15,R15             DID WE FIND ONE?\n         BZ    READBAL             NO, GO FIND US ANOTHER RCD\n*\n*    WE FINALLY HAVE WHAT WE ARE LOOKING FOR SO LET'S PRINT IT\n*\n         BAL   R5,PRTRCD\n         BCR   0,0\n         BCR   0,0\n         BCR   0,0\n         BCR   0,0\n         BCR   0,0\n         BCR   0,0\n         B     READBAL             GO GET ANOTHER RECORD\nALLDONE  EQU   *\n         CLOSE (PDSDCB)\nLEAVE    EQU   *\n         CLOSE (PRINT)\n         CLC   ALLOK,=CL3'YES'\n         BE    GOODEXIT\n         LEAVE EQ,CC=16\nGOODEXIT LEAVE CC=0\nGETRCD   EQU   *\n         XR    R10,R10\n         LTR   R6,R6               1ST TIME THRU?\n         BZ    GETBLK              YES, GO READ A BLOCK OF DATA\n         TM    PDSDCB+36,X'40'\n         BNZ   BELOW\n         LH    R10,PDSDCB+82       POINT TO NEXT RECORD\n         AR    R6,R10\n         CLC   0(8,R6),FFFF        WAS LAST RCD END OF BLOCK?\n         BE    GETBLK              YES, GO GET ANOTHER\nGETOUT2  BR    R5\nBELOW    EQU   *\n         IC    R10,1(R6)           POINT TO NEXT RECORD\n         AR    R6,R10\n         CLC   0(8,R6),FFFF        WAS LAST RCD END OF BLOCK?\n         BE    GETBLK              YES, GO GET ANOTHER\n         B     GETOUT2\nGETBLK   EQU   *\n         CLI  FLAG,X'00'    FLAG BEEN SET???\n         BNE   NOTSET       NOT END OF FILE PROBABLY\n         CLOSE (PDSDCB)     I THINK THIS IS STUPID\n         OPEN  (PDSDCB,(INPUT))  BUT IT HAS TO BE DONE TO MAKE IT WORK\n         MVI   FLAG,X'FF'        RESET FLAG\n         B     NXTMEM            AND GET ANOTHER MEMBER\nNOTSET   LA    R14,INAREA               CLEAR INPUT\n         L     R15,=A(L'INAREA)         LENGTH TO CLEAR\n         LA    R0,0                     SHOW CLEAR ONLY\n         LA    R1,0\n         ICM   R1,8,=X'FF'               FILL CAHRACTER\n         MVCL  R14,R0                 CLEAR IT\n         READ  PDSECB,SF,PDSDCB,INAREA,'S'   READ A DATA BLOCK\n         CHECK PDSECB              WAIT FOR THE READ TO COMPLETE\nSYN      EQU   *\n         CLI  PDSECB,X'7F'   ALL GOOD\n         BE   NOSET\n         MVI  FLAG,X'00'      NOPE SET FLAG TO TELL US\nNOSET    LA    R6,INAREA           POINT TO 1ST RCD OF BLOCK\n         TM    PDSDCB+36,X'40'\n         BZ    GETOUT2\n         LA    R6,4(R6)\n         B     GETOUT2\nPRNTMEM  EQU   *\n         BR    R5\n         EJECT\nSCANRCD  EQU   *\n*\n*   TRANSLATE RECORD TO UPPER CASE\n*\n         ST    R7,SAVEREG7         SAVE REG 7 IN SAVEREG7\n         ST    R9,SAVEREG9         SAVE REG 9 IN SAVEREG9\n         TM    PDSDCB+36,X'40'     RECFM = F ?\n         BNZ   TRNVAR              IF NOT, BRANCH TO TRNVAR\n         LH    R7,PDSDCB+82        R7==> LRECL OF DCB\n         LR    R9,R6               R9==> POINTS TO BEGINNING OF RECORD\n*                                      TO BE TRANSLATED\n         B     DOTRNSL             BRANCH TO DOTRNSL\nTRNVAR   MVC   VLRECL,0(R6)\n         LH    R7,VLRECL           R7==> LRECL OF THIS RECORD\n         S     R7,=F'4'            R7==> LRECL - 4 (CUZ OF RDW)\n         LR    R9,R6\n         A     R9,=F'4'            R9==> POINTS TO BEGINNING OF RECORD\n*                                      TO BE TRANSLATED OFFSET BY RDW\nDOTRNSL  S     R7,=F'1'            SUBTRACT 1 FOR THE EX\n         EX    R7,TRPARM           DO THE TRANSLATION\n         L     R7,SAVEREG7         RESTORE REGISTER 7\n         L     R9,SAVEREG9         RESTORE REGISTER 9\n*\n*   END OF TRANSLATION\n*\n         LR    R8,R6               GET BEGINNING ADDR (LEAVE R6 ALONE)\n         XR    R9,R9               CLEAR R9\n         XR    R15,R15             CLEAR R15\n         TM    PDSDCB+36,X'40'\n         BNZ   VSCAN\n         LH    R9,PDSDCB+82        GET LRECL\n*\n*   START SCANNING RCD\n*\nOL       EQU   *\n         LA    R1,PARMTBLE\nIL       EQU   *\n         L     R10,4(R1)\n         L     R11,0(R1)\n         EX    R10,CLCPARM\n         BE    FOUNDIT\n         LA    R1,8(,R1)           BUMP OVER EIGHT BYTES\n         CLC   0(8,R1),=X'FFFFFFFFFFFFFFFF'\n         BNE   IL\n         LA    R8,1(,R8)           NO, BUMP OVER ONE BYTE\n         BCT   R9,OL               DO N(LRECL) TIMES\n         B     GETOUT3\nVSCAN    EQU   *\n         IC    R9,1(R6)\n         LA    R8,4(R8)\n         B     OL\nFOUNDIT  EQU   *\n         LA    R15,1               SAY WE FOUND ONE\nGETOUT3  EQU   *\n         BR    R5\n         EJECT\nNXTMEM   EQU   *\n         LA    R7,8(R7)            SET ADDR TO NEXT MEMBER IN PDS\n         SR    R6,R6               CLEAR R6\n         B     ENDCOMP             GO DO IT ALL AGAIN\nFINDMEM  EQU   *\n         SR    R15,R15\n*\n         FIND  PDSDCB,MEMBER,D\n         LTR   R15,R15\n         BNZ   BLUP1\n         BR    R5\nBLUP1    EQU   *\n         B     *+4\n         DC    C'MEMBER NOT FOUND'\n         DS    0H\n         EJECT\nBLDTBL   EQU   *\n         LA    R7,TABLE            GET ADDR OF MEMBER TABLE\n         LA    R8,2500             SET MAXIMUM NUMBER OF ENTRIES\nREADBLK  EQU   *\n         READ  DIRECB,SF,DIRDCB,DIRECTRY,'S'\n         CHECK DIRECB\n         LA    R6,DIRECTRY+10      GET ADDR OF FIRST ENTRY\nTABLLOOP EQU   *\n         CP    PACKCTR,PACK2500    HAVE WE EXHAUSTED TABLE ?\n         BL    MOVEITIN            IT NOT, BRANCH TO MOVEITIN\n         MVC   ALLOK,=CL3'NO '     MOVE NO TO ALLOK WHICH WILL RESULT\n         B     LEAVE               IN THE RETURN CODE TO BE SET TO 16\nMOVEITIN MVC   0(8,R7),0(R6)       MOVE MEMBER NAME TO TABLE\n         AP    PACKCTR,PACK1\n         LA    R7,8(R7)            GET ADDR OF NEXT TABLE ENTRY\n         CLC   0(8,R6),DIRECTRY    IS THIS THE LAST GUY IN THIS BLOCK?\n         BNE   CONTINUE            NO GO AHEAD WITH THIS BLOCK\n         CLC   DIRECTRY(8),FFFF   YES,IS THIS LAST DIRECTORY BLOCK?\n         BNE   READBLK             NO, GO GET ANOTHER BLOCK\n         BR    R5                  YES GO BACK TO MAIN RTN\nCONTINUE EQU   *\n*  GET NEXT ENTRY IN DIRECTORY BLOCK\n         NI    11(R6),X'1F'        GET RID OF TOP 3 BITS OF INFO\n         XR    R2,R2               CLEAR R2\n         IC    R2,11(R6)           GET LENGTH OF VARIABLE PORTION IN\n*                                  HALF WORDS\n         SLA   R2,1                CHANGE TO NUMBER OF BYTES\n         AR    R6,R2               ADD TO BASE ADDRESS\n         LA    R6,12(R6)           ADD LENGTH OF FIXED PORTION\n         BCT   R8,TABLLOOP         GO PROCESS THIS ENTRY (2500 MAX)\n         B     *+4                 BLOW-UP IF TOO MANY\n         DC    C'TOO MANY ENTRIES IN DIRECTORY FOR TABLE'\n         DS    0H\nNOPARM   EQU   *\n         OPEN  (PRINT,OUTPUT)\n         PUT   PRINT,NOPARMSG\n         B     LEAVE\nPARMPTR  EQU   *\n         L     R1,0(R1)\n         CLI   1(R1),X'00' IS THERE A PARM THERE?\n         BE    NOPARM      BRANCH IF NO\n         XR    R2,R2\n         IC    R2,1(R1)\n         STH   R2,PARMLEN\n         BCTR  R2,0\n         EX    R2,MVPARM\n         XR    R6,R6\n         LA    R8,PARMTBLE\n         LA    R1,PARM\n         XR    R2,R2\n         ST    R1,0(R8)\nCOMP     EQU   *\n         CLI   0(R1),C','       IS THERE A COMMA?\n         BE    COMMA            YES GOTO COMMA\n         LA    R1,1(R1)\n         LA    R2,1(R2)\nCHPARM   EQU   *\n         LA    R6,1(R6)\n         CH    R6,PARMLEN\n         BNE   COMP\n         BCTR  R2,0\n         ST    R2,4(R8)\n         MVC   8(8,R8),=X'FFFFFFFFFFFFFFFF'\n         BR    R5\nCOMMA    EQU   *\n         BCTR  R2,0\n         ST    R2,4(R8)\n         LA    R8,8(R8)\n         LA    R1,1(R1)\n         ST    R1,0(R8)\n         XR   R2,R2\n         B     CHPARM\nPRTRCD   EQU   *         PRINT THIS RECORD AND THE SEQ # OF THE JCL\n         LR    R8,R6\n         TM    PDSDCB+36,X'40'\n         BNZ   VPRINT\n         XR    R9,R9               CLEAR R9\n         LH    R9,PDSDCB+82        GET LRECL\n         B     PCHECK\nVPRINT   EQU   *\n         IC    R9,1(R6)\n         LA    R8,4(R8)\nPCHECK   EQU   *\n         MVC   MEMNAM,MEMBER       MOVE MEMBER NAME OF PROC TO PRINT\n         CLC   MEMNAM,LASTMEM\n         BE    GETOUT\n         PUT   PRINT,PRTLINE       PRINT IT\n         MVC   LASTMEM,MEMNAM\nGETOUT   BR    R5\nMVPARM   MVC   PARM(0),2(R1)\nTRPARM   TR    0(0,R9),TRTABLE\nCLCPARM  CLC   0(0,R11),0(R8)\nNOPARMSG DC    CL78' NO STRING GIVEN FOR PROGRAM TO FIND.... '\n         EJECT\nDIRDCB   DCB   DDNAME=PROCLIB,BLKSIZE=256,KEYLEN=8,LRECL=256,DSORG=PS, X\n               MACRF=R,RECFM=F\nPDSDCB DCB DDNAME=PROCLIB,DSORG=PO,MACRF=R,EODAD=NXTMEM,SYNAD=SYN,     X\n               KEYLEN=0\nPRINT    DCB   DDNAME=PRINT,DSORG=PS,MACRF=(PM),BLKSIZE=78,LRECL=78,   X\n               RECFM=FBA\n         LTORG\nPRTLINE  DS    0CL78\n         DC    CL1' '\n         DC    CL24' FOUND IN MEMBER NAME = '\nMEMNAM   DC    CL8' '\n         DC    CL45' '\nHOLDREC  DC    CL80' '\nLASTMEM  DC    CL8'        '\nALLOK    DC    CL3'YES'\nPACK2500 DC    PL4'2500'\nPACK1    DC    PL1'1'\nPACKCTR  DC    PL4'1'\nFFFF     DC    8X'FF'\nFLAG     DC    X'FF'\nDSLEN    DC    F'10399'\nDIRECTRY DS    CL264\nPARM     DC    CL124' '\nPARMLEN  DC    XL2'0'\nPARMTBLE DC    120F'0'\nVLRECL   DS    H\nSAVEREG7 DS    F\nSAVEREG9 DS    F\nTRTABLE  DC    X'00'\n         DC    X'01'\n         DC    X'02'\n         DC    X'03'\n         DC    X'04'\n         DC    X'05'\n         DC    X'06'\n         DC    X'07'\n         DC    X'08'\n         DC    X'09'\n         DC    X'0A'\n         DC    X'0B'\n         DC    X'0C'\n         DC    X'0D'\n         DC    X'0E'\n         DC    X'0F'\n         DC    X'10'\n         DC    X'11'\n         DC    X'12'\n         DC    X'13'\n         DC    X'14'\n         DC    X'15'\n         DC    X'16'\n         DC    X'17'\n         DC    X'18'\n         DC    X'19'\n         DC    X'1A'\n         DC    X'1B'\n         DC    X'1C'\n         DC    X'1D'\n         DC    X'1E'\n         DC    X'1F'\n         DC    X'20'\n         DC    X'21'\n         DC    X'22'\n         DC    X'23'\n         DC    X'24'\n         DC    X'25'\n         DC    X'26'\n         DC    X'27'\n         DC    X'28'\n         DC    X'29'\n         DC    X'2A'\n         DC    X'2B'\n         DC    X'2C'\n         DC    X'2D'\n         DC    X'2E'\n         DC    X'2F'\n         DC    X'30'\n         DC    X'31'\n         DC    X'32'\n         DC    X'33'\n         DC    X'34'\n         DC    X'35'\n         DC    X'36'\n         DC    X'37'\n         DC    X'38'\n         DC    X'39'\n         DC    X'3A'\n         DC    X'3B'\n         DC    X'3C'\n         DC    X'3D'\n         DC    X'3E'\n         DC    X'3F'\n         DC    X'40'\n         DC    X'41'\n         DC    X'42'\n         DC    X'43'\n         DC    X'44'\n         DC    X'45'\n         DC    X'46'\n         DC    X'47'\n         DC    X'48'\n         DC    X'49'\n         DC    X'4A'\n         DC    X'4B'\n         DC    X'4C'\n         DC    X'4D'\n         DC    X'4E'\n         DC    X'4F'\n         DC    X'50'\n         DC    X'51'\n         DC    X'52'\n         DC    X'53'\n         DC    X'54'\n         DC    X'55'\n         DC    X'56'\n         DC    X'57'\n         DC    X'58'\n         DC    X'59'\n         DC    X'5A'\n         DC    X'5B'\n         DC    X'5C'\n         DC    X'5D'\n         DC    X'5E'\n         DC    X'5F'\n         DC    X'60'\n         DC    X'61'\n         DC    X'62'\n         DC    X'63'\n         DC    X'64'\n         DC    X'65'\n         DC    X'66'\n         DC    X'67'\n         DC    X'68'\n         DC    X'69'\n         DC    X'6A'\n         DC    X'6B'\n         DC    X'6C'\n         DC    X'6D'\n         DC    X'6E'\n         DC    X'6F'\n         DC    X'70'\n         DC    X'71'\n         DC    X'72'\n         DC    X'73'\n         DC    X'74'\n         DC    X'75'\n         DC    X'76'\n         DC    X'77'\n         DC    X'78'\n         DC    X'79'\n         DC    X'7A'\n         DC    X'7B'\n         DC    X'7C'\n         DC    X'7D'\n         DC    X'7E'\n         DC    X'7F'\n         DC    X'80'\n         DC    C'A'\n         DC    C'B'\n         DC    C'C'\n         DC    C'D'\n         DC    C'E'\n         DC    C'F'\n         DC    C'G'\n         DC    C'H'\n         DC    C'I'\n         DC    X'8A'\n         DC    X'8B'\n         DC    X'8C'\n         DC    X'8D'\n         DC    X'8E'\n         DC    X'8F'\n         DC    X'90'\n         DC    C'J'\n         DC    C'K'\n         DC    C'L'\n         DC    C'M'\n         DC    C'N'\n         DC    C'O'\n         DC    C'P'\n         DC    C'Q'\n         DC    C'R'\n         DC    X'9A'\n         DC    X'9B'\n         DC    X'9C'\n         DC    X'9D'\n         DC    X'9E'\n         DC    X'9F'\n         DC    X'A0'\n         DC    X'A1'\n         DC    C'S'\n         DC    C'T'\n         DC    C'U'\n         DC    C'V'\n         DC    C'W'\n         DC    C'X'\n         DC    C'Y'\n         DC    C'Z'\n         DC    X'AA'\n         DC    X'AB'\n         DC    X'AC'\n         DC    X'AD'\n         DC    X'AE'\n         DC    X'AF'\n         DC    X'B0'\n         DC    X'B1'\n         DC    X'B2'\n         DC    X'B3'\n         DC    X'B4'\n         DC    X'B5'\n         DC    X'B6'\n         DC    X'B7'\n         DC    X'B8'\n         DC    X'B9'\n         DC    X'BA'\n         DC    X'BB'\n         DC    X'BC'\n         DC    X'BD'\n         DC    X'BE'\n         DC    X'BF'\n         DC    X'C0'\n         DC    X'C1'\n         DC    X'C2'\n         DC    X'C3'\n         DC    X'C4'\n         DC    X'C5'\n         DC    X'C6'\n         DC    X'C7'\n         DC    X'C8'\n         DC    X'C9'\n         DC    X'CA'\n         DC    X'CB'\n         DC    X'CC'\n         DC    X'CD'\n         DC    X'CE'\n         DC    X'CF'\n         DC    X'D0'\n         DC    X'D1'\n         DC    X'D2'\n         DC    X'D3'\n         DC    X'D4'\n         DC    X'D5'\n         DC    X'D6'\n         DC    X'D7'\n         DC    X'D8'\n         DC    X'D9'\n         DC    X'DA'\n         DC    X'DB'\n         DC    X'DC'\n         DC    X'DD'\n         DC    X'DE'\n         DC    X'DF'\n         DC    X'E0'\n         DC    X'E1'\n         DC    X'E2'\n         DC    X'E3'\n         DC    X'E4'\n         DC    X'E5'\n         DC    X'E6'\n         DC    X'E7'\n         DC    X'E8'\n         DC    X'E9'\n         DC    X'EA'\n         DC    X'EB'\n         DC    X'EC'\n         DC    X'ED'\n         DC    X'EE'\n         DC    X'EF'\n         DC    X'F0'\n         DC    X'F1'\n         DC    X'F2'\n         DC    X'F3'\n         DC    X'F4'\n         DC    X'F5'\n         DC    X'F6'\n         DC    X'F7'\n         DC    X'F8'\n         DC    X'F9'\n         DC    X'FA'\n         DC    X'FB'\n         DC    X'FC'\n         DC    X'FD'\n         DC    X'FE'\n         DC    X'FF'\nINAREA   DS    CL24000\nWORKAREA DSECT\n         DS    18F\nTABLE    DS    2501CL8\nWORKLEN  EQU   *-WORKAREA\nMEMBERDS DSECT\nMEMBER   DS    CL8\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "FINDMEM": {"ttr": 19210, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x00\\x7f\\x00\\x88\\x00\\x7f\\x12\\x00\\x02\\x15\\x02\\x15\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf2\\xf7\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-01-07T00:00:00", "modifydate": "1988-01-07T12:00:00", "lines": 533, "newlines": 533, "modlines": 0, "user": "FILE270"}, "text": "         TITLE 'FINDMEM -- SEARCH PDS FOR A PARTICULAR MEMBER'\n**********************************************************************\n*        THIS PROGRAM IS A SUBROUTINE WHICH DYNAMICALLY ALLOCATES\n*        THE FILE WITH DSN PASSED TO THIS PROGRAM AND THEN SEARCHES\n*        THE DIRECTORY TO DETERMINE WHETHER THE MEMBER NAME PASSED\n*        TO THIS PROGRAM EXISTS.\n*\n*        TO CALL THIS PROGRAM FROM A COBOL PROGRAM, DO THE FOLLOWING:\n*\n*           IF YOUR PDS IS CATALOGUED,\n*\n*               MOVE YOUR DSN TO DSNAME OF FINDMEM-I-O-AREA.\n*               MOVE YOUR MEMBER NAME\n*                   TO MEMBER-NAME OF FINDMEM-I-O-AREA.\n*               CALL 'FINDMEM' USING FINDMEM-I-O-AREA.\n*\n*                    WHERE:\n*\n*                          01  FINDMEM-I-O-AREA.\n*                              05  OP-SYS VALUE 'VS'  PIC X(2).\n*                              05  MEMBER-NAME        PIC X(8).\n*                              05  DSNAME             PIC X(44).\n*                              05  SUCCESS-INDICATOR  PIC 99.\n*\n*\n*           IF YOUR PDS IS NOT CATALOGUED,\n*\n*               MOVE YOUR DSN TO DSNAME OF FINDMEM-I-O-AREA.\n*               MOVE YOUR MEMBER NAME\n*                   TO MEMBER-NAME OF FINDMEM-I-O-AREA.\n*               MOVE THE VOLUME SERIAL NUMBER TO VOL-SER-NO.\n*               CALL 'FINDMEM' USING FINDMEM-I-O-AREA, VOL-SER-NO.\n*\n*                    WHERE:\n*\n*                          01  FINDMEM-I-O-AREA (SEE ABOVE)\n*                          01  VOL-SER-NO             PIC X(6).\n*\n*\n*\n*             SUCCESS-INDICATOR   MEANING\n*             -----------------   -----------------------------------\n*\n*                    00           SUCCESSFUL ALLOCATION AND FIND\n*                    04           SUCCESSFULLY ALLOCATED FILE BUT\n*                                   COULDN'T FIND MEMBER IN DIRECTORY\n*                    08           UNSUCCESSFUL ALLOCATION\n*                    12           DSN PASSED TO THIS PGM IS SPACES\n*                    16           MEMBER NAME PASSED IS SPACES\n*                    20           I/O ERROR READING DIRECTORY\n*                    24           UNSUCCESSFUL FREE OF DDNAME FINDMEDD\n*                    28           INVALID VOL SER PASSED TO THIS PGM\n*\n*\n*        ASSIGNMENT OF REGISTERS\n*        -----------------------\n*\n*        REGISTER      USAGE\n*        --------      -------------------------------------------\n*\n*           1          ADDRESS OF PARAMETER LIST\n*           2          NOT USED\n*           3          NOT USED\n*           4          NOT USED\n*           5          RETURN REG USED IN ALL BR AND LINK INSTRUCTIONS\n*           6          NOT USED\n*           7          WORK REGISTER\n*           8          WORK REGISTER\n*           9          WORK REGISTER\n*           10         SAVE RETURN CODE VALUE\n*           11         SAVE REGISTER 1\n*           12         BASE REGISTER\n*           13         ADDRESS OF SAVE AREA\n*           14         RETURN ADDRESS\n*           15         ENTRY POINT ADDRESS\n*\n*---------------------------------------------------------------------\n*\n*  ACTIVITY LOG:\n*\n*    V2.0  -   GORDON J. SCHILLINGER    DIS/CSD                09/7/88\n*              MODIFIED TO MAKE FINDMEM RE-ENTERANT\n*\n**********************************************************************\n         EJECT\nFINDMEM  ENTERR LEVEL=V_2.0\n         LR    R11,R1                                                   ----V1M3\n********************************************************************\n*        INITIALIZE DYNAMIC AREAS\n********************************************************************\n         OI    ROPPL,X'80'\n         OI    RCPPL,X'80'\n         MVC   CBLOK(CINITL),CINIT\n         MVC   PDSFILE(PDSFLEN),PDSFINIT\n         MVC   FREEBLOK(FREELEN),FREEINIT\n         MVC   ALOCBLOK(ALOCLEN),ALOCINIT\n         LA    R1,FREERB                                                ----V1M3\n         STCM  R1,7,FREEPARM+1                                          ----V1M3\n         LA    R1,FREETUPL                                              ----V1M3\n         ST    R1,ERCODE+4                                              ----V1M3\n         LA    R1,FREEUNT1                                              ----V1M3\n         ST    R1,FREETUPL                                              ----V1M3\n         LA    R1,FREEUNT2                                              ----V1M3\n         STCM  R1,7,FREETUPL+5                                          ----V1M3\n         LA    R1,DD1RB                                                 ----V1M3\n         STCM  R1,7,DD1PARM+1                                           ----V1M3\n         LA    R1,DD1TUPL                                               ----V1M3\n         ST    R1,DD1RB+8                                               ----V1M3\n         LA    R1,DD1UNIT1                                              ----V1M3\n         LA    R2,DD1UNIT2                                              ----V1M3\n         STM   R1,R2,DD1TUPL                                            ----V1M3\n         LA    R1,DD1UNIT3                                              ----V1M3\n         STCM  R1,7,DD1HIGH3+1                                          ----V1M3\n         LA    R1,DD1UNIT4                                              ----V1M3\n         STCM  R1,7,DD1HIGH4+1                                          ----V1M3\n         LA    R1,DD1UNIT5                                              ----V1M3\n         STCM  R1,7,DD1HIGH5+1                                          ----V1M3\n*\n         L     R9,0(R11)\n         MVC   IOAREA,0(R9)\n         TM    0(R11),X'80'   CALLED W/ SINGLE PARM?\n         BO    NOINVOL        IF SO, BRANCH TO NOINVOL\n         L     R9,4(R11)      R9==> ADDRESS OF VOL SER NO\n         MVC   INVOL,0(R9)    PUT VOL SER NO INTO INVOL\n         B     MAINLINE       BRANCH TO MAINLINE\nNOINVOL  MVC   INVOL,=CL6'ABSENT'\n         EJECT\n         SPACE 3\n*\n********************************************************************\n*                                                                  *\n*        M A I N   L I N E   L O G I C                             *\n*                                                                  *\n********************************************************************\n*\nMAINLINE BAL   5,LOADSN            LOAD DATA AREAS DSNLEN AND DSNAME\n         CLC   PROCESSW,CYES       WERE DATA AREAS SUCCESSFULLY LOADED?\n         BNE   SHUTDOWN            IF NOT, BRANCH TO SHUTDOWN\n         CLC   INVOL,=CL6'ABSENT'  WAS VOL SER PROVIDED ?\n         BE    ALLOKATE            IF NOT, BRANCH TO ALLOKATE\n         BAL   5,EDITVOL           EDIT THE VOL SER PROVIDED\n         CLC   GOODVOL,CYES        WAS THE VOL SER VALID ?\n         BNE   SHUTDOWN            IF NOT, BRANCH TO SHUTDOWN\nALLOKATE BAL   5,DYNAMALC          PERFORM DYNAMIC ALLOCATION\n         CLC   PROCESSW,CYES       WAS DYNAMIC ALLOCATION SUCCESSFUL?\n         BE    OPENFIL             IF YES, GO TO OPENFIL\n         B     SHUTDOWN            BRANCH TO SHUTDOWN\nOPENFIL  OPEN  (PDSFILE,(INPUT)),MF=(E,ROPPL)  OPEN PDSFILE\n         MVC   FILOPEN,CYES        MOVE 'YES' TO FILOPEN\n         BAL   5,SERCHPDS          PERFORM SEARCH DIRECTORY FOR MEMBER\n         CLC   PROCESSW,CYES       WAS MEMBER FOUND?\n         BE    FOUND               IF YES, GO TO FOUND\n         B     SHUTDOWN            BRANCH TO SHUTDOWN\nFOUND    MVC   INDICATR,C00        MOVE 00 TO SUCCESS-INDICATOR\n         LA    R10,0               MOVE 0 TO REGISTER 10\n         B     SHUTDOWN            BRANCH TO SHUTDOWN\n         EJECT\n         SPACE 3\n*\n********************************************************************\n*                                                                  *\n*        THIS ROUTINE IS RESPONSIBLE FOR LOADING THE 2 DATA AREAS  *\n*        DSNLEN AND DSNAME.  THE DSN THAT IS PASSED TO THIS PGM    *\n*        IS MOVED TO DSNAME.  THIS ROUTINE THEN CALCULATES THE     *\n*        SIGNIFICANT LENGTH OF DSNAME AND MOVE THAT VALUE TO       *\n*        DSNLEN (EXPRESSED IN BINARY)                              *\n*                                                                  *\n********************************************************************\n*\nLOADSN   ST    R5,SAVEIT1            SAVE REG 5 IN SAVEIT1\n         MVC   DSNAME,DSN            MOVE DSN THAT IS PASSED TO THIS\n*                                      PROGRAM TO DSNAME\n         LA    R8,44                 LOAD REG 8 WITH 44\n         LA    R7,DSNAME+43\nCOMPR1   C     R8,=F'1'              COMPARE REG 8 TO 1\n         BNL   COMPR2                IF NOT LOW, GO TO COMPR2\n         MVC   INDICATR,C12          MOVE 12 TO SUCCESS-INDICATOR\n         LA    R10,12                MOVE 12 TO REGISTER 10\n         MVC   PROCESSW,CNO          MOVE 'NO ' TO PROCESSW\n         B     EXITLOAD              BRANCH TO EXITLOAD\nCOMPR2   CLI   0(R7),C' '            IS DSNAME AS INDEXED BY REG 7\n*                                      EQUAL TO A SPACE?\n         BNE   LOADLEN               IF NOT, GO TO LOADLEN\n         S     R7,=F'1'              SUBTRACT 1 FROM REGISTER 7\n         S     R8,=F'1'              SUBTRACT 1 FROM REGISTER 8\n         B     COMPR1                BRANCH TO COMPR1\nLOADLEN  ST    R8,R8LENGTH           STORE REG 8 IN R8LENGTH\n         MVC   DSNLEN(2),R8LENGTH+2  MOVE LOW ORDER 2 BYTES\n*                                      OF R8LENGTH TO DSNLEN\n         MVC   PROCESSW,CYES         MOVE 'YES' TO PROCESSW\nEXITLOAD L     R5,SAVEIT1            RESTORE REGISTER 5\n         BR    R5                    RETURN\n         EJECT\n         SPACE 3\n*\n********************************************************************\n*                                                                  *\n*               D Y N A M I C   A L L O C A T I O N                *\n*               -----------------------------------                *\n*                                                                  *\n*        THIS ROUTINE FIRST ATTEMPTS TO FREE DDNAME FINDMEDD.      *\n*        IF DDNAME FINDMEDD WAS SUCCESSFULLY FREED, THEN THIS      *\n*        ROUTINE BRANCHES TO THE DYNAMIC ALLOCATION MACRO          *\n*        DYNALLOC.  IF DDNAME FINDMEDD WAS NOT SUCCESSFULLY        *\n*        FREED, THEN IT CHECKS FOR ERROR REASON CODE 0438          *\n*        (DDNAME NOT FOUND).  IF THE ERROR REASON CODE IS 0438,    *\n*        THEN THIS ROUTINE BRANCHES TO THE DYNAMIC ALLOCATION      *\n*        MACRO DYNALLOC, ELSE IT PRODUCES AN ERROR CONDITION       *\n*        (SUCCESS-INDICATOR = '24')                                *\n*                                                                  *\n********************************************************************\n*\n         SPACE 3\nDYNAMALC ST    R5,SAVEIT2\n         MVC   PROCESSW,CYES\n         LA    R1,FREEPARM\n         DYNALLOC                      FREE F(FINDMEDD)\n         LTR   R15,R15                 TEST REGISTER 15 FOR ZERO\n         BZ    DODYNAM                 IF ZERO, BRANCH TO DODYNAM\n         CLC   ERCODE,HEX0438          COMPARE ERROR REASON CODE\n*                                         AGAINST HEXADECIMAL 0438\n         BE    DODYNAM                 IF EQUAL, BRANCH TO DODYNAM\n         MVC   PROCESSW,CNO            MOVE 'NO ' TO PROCESSW\n         MVC   INDICATR,C24            MOVE '24' TO SUCCESS-INDICATOR\n         LA    R10,24                  MOVE 24 TO REGISTER 10\n         BR    R5                      RETURN\nDODYNAM  CLC   INVOL,=CL6'ABSENT'      WAS VOL SER PROVIDED ?\n         BE    DODYNAM1                IF NOT, BRANCH TO DODYNAM1\n         MVI   DD1HIGH3,X'00'\n         MVI   DD1HIGH4,X'00'\n         MVI   DD1HIGH5,X'80'\n         MVC   DD1VOLSR,INVOL\n         B     DODYNAM2\nDODYNAM1 MVI   DD1HIGH3,X'80'\n         MVI   DD1HIGH4,X'00'\n         MVI   DD1HIGH5,X'00'\nDODYNAM2 LA    R1,DD1PARM\n         DYNALLOC                      ALLOC F(FINDMEDD) DA(DSN) SHR\n         L     R5,SAVEIT2\n         LTR   R15,R15                 TEST REGISTER 15 FOR ZERO\n         BZR   R5                      IF ZERO, RETURN\n         MVC   PROCESSW,CNO            MOVE 'NO ' TO PROCESSW\n         MVC   INDICATR,C08            MOVE '08' TO SUCCESS-INDICATOR\n         LA    R10,8                   MOVE 8 TO REGISTER 10\n         BR    R5                      RETURN\n         EJECT\n*\n********************************************************************\n*                                                                  *\n*        THIS ROUTINE IS RESPONSIBLE FOR SEARCHING THE             *\n*        DYNAMICALLY ALLOCATED PDS FOR THE GIVEN MEMBER            *\n*                                                                  *\n********************************************************************\n*\nSERCHPDS ST    R5,SAVEIT3           SAVE REG 5 IN SAVEIT3\n         CLC   MEMBER,EIGHTSP       IS MEMBER EQUAL TO 8 SPACES?\n         BNE   SEARCHIT             IF NOT, GO TO SEARCHIT\n         MVC   INDICATR,C16         MOVE 16 TO SUCCESS-INDICATOR\n         LA    R10,16               MOVE 16 TO REGISTER 10\n         MVC   PROCESSW,CNO         MOVE 'NO ' TO PROCESSW\n         B     EXITSRCH             BRANCH TO EXITSRCH\nSEARCHIT FIND  PDSFILE,MEMBER,D     SEARCH DIRECTORY FOR MEMBER\n         ST    R15,SAVER15          PUT REG 5 CONTENTS INTO SAVER15\n         CLI   SAVER15+3,X'00'      CONDITION CODE 00?\n         BE    RC00                 IF YES, GO TO RC00\n         CLI   SAVER15+3,X'04'      CONDITION CODE 04?\n         BE    RC04                 IF YES, GO TO RC04\n         MVC   INDICATR,C20         MOVE 20 TO SUCCESS-INDICATOR\n         LA    R10,20               MOVE 20 TO REGISTER 10\n         MVC   PROCESSW,CNO         MOVE 'NO ' TO PROCESSW\n         B     EXITSRCH             BRANCH TO EXITSRCH\nRC04     MVC   INDICATR,C04         MOVE 04 TO SUCCESS-INDICATOR\n         LA    R10,4                MOVE 4 TO REGISTER 10\n         MVC   PROCESSW,CNO         MOVE 'NO ' TO PROCESSW\n         B     EXITSRCH             BRANCH TO EXITSRCH\nRC00     MVC   PROCESSW,CYES        MOVE 'YES' TO PROCESSW\nEXITSRCH L     R5,SAVEIT3           RESTORE REGISTER 5\n         BR    R5                   RETURN\n         EJECT\n*\n*\n***********************************************************\n*                                                         *\n*        THIS ROUTINE IS RESPONSIBLE FOR EDITING INVOL    *\n*                                                         *\n*        IF INVOL MEETS THE CRITERIA FOR BEING A VALID    *\n*        VOLUMER SERIAL NUMBER (6 BYTES LONG, ALL         *\n*        NUMERICS AND ALPHABETICS), THEN THIS ROUTINE     *\n*        WILL MOVE 'YES' TO GOODVOL ELSE MOVE 'NO '       *\n*        TO GOODVOL                                       *\n*                                                         *\n***********************************************************\n*\n*\nEDITVOL  ST    R5,SAVEIT4\n         MVC   GOODVOL,=CL3'YES'\n         MVC   EDITBYTE(1),INVOL\n         BAL   R5,EDIT1BYT\n         CLC   GOODVOL,=CL3'YES'\n         BNE   EXITEVOL\n         MVC   EDITBYTE(1),INVOL+1\n         BAL   R5,EDIT1BYT\n         CLC   GOODVOL,=CL3'YES'\n         BNE   EXITEVOL\n         MVC   EDITBYTE(1),INVOL+2\n         BAL   R5,EDIT1BYT\n         CLC   GOODVOL,=CL3'YES'\n         BNE   EXITEVOL\n         MVC   EDITBYTE(1),INVOL+3\n         BAL   R5,EDIT1BYT\n         CLC   GOODVOL,=CL3'YES'\n         BNE   EXITEVOL\n         MVC   EDITBYTE(1),INVOL+4\n         BAL   R5,EDIT1BYT\n         CLC   GOODVOL,=CL3'YES'\n         BNE   EXITEVOL\n         MVC   EDITBYTE(1),INVOL+5\n         BAL   R5,EDIT1BYT\n         B     EXITEVOL\n*\n*\n*\nEDIT1BYT ST    R5,SAVEIT5            SAVE REG 14 ADDRESS IN SAVEIT5\n         CLI   EDITBYTE,C'0'\n         BL    NEXTEST\n         CLI   EDITBYTE,C'9'\n         BH    BADINVOL\n         B     EXITEDT1\nNEXTEST  CLI   EDITBYTE,C'A'\n         BL    BADINVOL\n         CLI   EDITBYTE,C'Z'\n         BH    BADINVOL\n         B     EXITEDT1\nBADINVOL MVC   GOODVOL,=CL3'NO '\n         MVC   INDICATR,C28         MOVE 28 TO SUCCESS-INDICATOR\n         LA    R10,28               MOVE 28 TO REGISTER 10\nEXITEDT1 L     R5,SAVEIT5\n         BR    R5\n*\n*\n*\nEXITEVOL L     R5,SAVEIT4\n         BR    R5\n         EJECT\n*\n********************************************************************\n*                                                                  *\n*        E N D  O F   J O B   P R O C E S S I N G                  *\n*                                                                  *\n********************************************************************\n*\nSHUTDOWN L     R9,0(R11)\n         MVC   0(56,R9),IOAREA\n         CLC   FILOPEN,CYES        WAS FILE OPENED?\n         BNE   LOADR15             IF NOT, GO TO LOADR15\n         CLOSE (PDSFILE),MF=(E,RCPPL)  CLOSE FILE\nLOADR15  LR    R15,R10\n         L     R13,4(R13)\n         RETURN (14,12),RC=(15)\n         EJECT\n********************************************************************\n*                                                                  *\n*        S T A T I C   W O R K   A R E A                           *\n*                                                                  *\n********************************************************************\nCINIT    DS    0F\n         DC    CL3'YES'\n         DC    CL3'NO '\n         DC    CL2'00'\n         DC    CL2'04'\n         DC    CL2'08'\n         DC    CL2'12'\n         DC    CL2'16'\n         DC    CL2'20'\n         DC    CL2'24'\n         DC    CL2'28'\n         DC    CL3'NO '\n         DC    CL8' '\n         DS    CL3\n         DC    X'0438'\nCINITL   EQU   *-CINIT\nPDSFINIT DCB   DDNAME=FINDMEDD,DSORG=PO,MACRF=(R)\nPDSFLEN  EQU   *-PDSFINIT\n*\n*        DATA STRUCTURE FOR FREEING OF DDNAME FINDMEDD\nFREEINIT DS    0F\n         DC    X'80'         TURN ON HIGH ORDER BIT\n         DC    AL3(0)        ADDRESS OF REQUEST BLOCK\n         DC    X'14'         S99RBLN (LENGTH OF REQUEST BLOCK)\n         DC    X'02'         S99VERB (REQUEST FOR UNALLOCATION)\n         DC    X'2000'       S99FLAG1 (DO NOT MOUNT VOLUMES)\n         DC    X'0000'       S99ERROR (ERROR REASON CODE)\n         DC    X'0000'       S99INFO (INFORMATION REASON CODE)\n         DC    A(0)          S99TXTPP (ADDR OF POINTER TO TEXT UNIT)\n         DC    X'00000000'   RESERVED\n         DC    X'00000000'   S99FLAG2\n         DC    A(0)          ADDRESS OF TEXT UNIT #1\n         DC    X'80'         TURN ON HIGH ORDER BIT\n         DC    AL3(0)        ADDRESS OF TEXT UNIT #2\n         DC    X'0001',X'0001',X'0008',C'FINDMEDD'\n         DC    X'0007'\n         DC    X'0000'\nFREELEN  EQU   *-FREEINIT\n*\n*        DATA STRUCTURE FOR DYNAMIC ALLOCATION\nALOCINIT DS    0F\n         DC    X'80'         TURN ON HIGH ORDER BIT\n         DC    AL3(0)        ADDRESS OF REQUEST BLOCK\n         DC    X'14'         S99RBLN (LENGTH OF REQUEST BLOCK)\n         DC    X'01'         S99VERB (REQUEST FOR DSNAME ALLOC)\n         DC    X'2000'       S99FLAG1 (DO NOT MOUNT VOLUMES)\n         DC    X'0000'       S99ERROR (ERROR REASON CODE)\n         DC    X'0000'       S99INFO (INFORMATION REASON CODE)\n         DC    A(0)          S99TXTPP (ADDR OF POINTERS TO TEXT UNITS\n         DC    X'00000000'   RESERVED\n         DC    X'00000000'   S99FLAG2\n         DC    A(0)          ADDRESS OF TEXT UNIT #1\n         DC    A(0)          ADDRESS OF TEXT UNIT #2\n         DS    XL1\n         DC    AL3(0)        ADDRESS OF TEXT UNIT #3\n         DS    XL1\n         DC    AL3(0)        ADDRESS OF TEXT UNIT #4\n         DS    XL1\n         DC    AL3(0)        ADDRESS OF TEXT UNIT #5\n         DC    X'0001',X'0001',X'0008',C'FINDMEDD'\n         DC    X'0002'\n         DC    X'0001'\n         DS    BL2\n         DS    CL44\n         DC    X'0004',X'0001',X'0001',X'08'\n         DC    X'0015',X'0001',X'0008',C'SYSALLDA'\n         DC    X'0010'\n         DC    X'0001'\n         DC    X'0006'\nALOCLEN  EQU   *-ALOCINIT\n*\n*        LITERAL POOL\n         LTORG\n         EJECT\n********************************************************************\n*                                                                  *\n*        D Y N A M I C   W O R K   A R E A                         *\n*                                                                  *\n********************************************************************\nWORKAREA DSECT\nSAVEAREA DS    18F\nSAVEIT1  DS    F\nSAVEIT2  DS    F\nSAVEIT3  DS    F\nSAVEIT4  DS    F\nSAVEIT5  DS    F\nSAVER15  DS    F\nR8LENGTH DS    F\nINVOL    DS    CL6\nGOODVOL  DS    CL3\nEDITBYTE DS    CL1\n*\nCBLOK    DS    0F\nCYES     DC    CL3'YES'\nCNO      DC    CL3'NO '\nC00      DC    CL2'00'\nC04      DC    CL2'04'\nC08      DC    CL2'08'\nC12      DC    CL2'12'\nC16      DC    CL2'16'\nC20      DC    CL2'20'\nC24      DC    CL2'24'\nC28      DC    CL2'28'\nFILOPEN  DC    CL3'NO '\nEIGHTSP  DC    CL8' '\nPROCESSW DS    CL3\nHEX0438  DC    X'0438'\n*\nIOAREA   DS    0CL56\n         DS    CL2\nMEMBER   DS    CL8\nDSN      DS    CL44\nINDICATR DS    CL2\nPDSFILE  DCB   DDNAME=FINDMEDD,DSORG=PO,MACRF=(R)\nROPPL    DC    F'0'          OPEN PARM LIST\nRCPPL    DC    F'0'          CLOSE PARM LIST\n*\nFREEBLOK DS    0F\nFREEPARM DC    X'80'         TURN ON HIGH ORDER BIT\n         DC    AL3(FREERB)   ADDRESS OF REQUEST BLOCK\nFREERB   DC    X'14'         S99RBLN (LENGTH OF REQUEST BLOCK)\n         DC    X'02'         S99VERB (REQUEST FOR UNALLOCATION)\n         DC    X'2000'       S99FLAG1 (DO NOT MOUNT VOLUMES)\nERCODE   DC    X'0000'       S99ERROR (ERROR REASON CODE)\n         DC    X'0000'       S99INFO (INFORMATION REASON CODE)\n         DC    A(FREETUPL)   S99TXTPP (ADDR OF POINTER TO TEXT UNIT)\n         DC    X'00000000'   RESERVED\n         DC    X'00000000'   S99FLAG2\nFREETUPL DC    A(FREEUNT1)   ADDRESS OF TEXT UNIT #1\n         DC    X'80'         TURN ON HIGH ORDER BIT\n         DC    AL3(FREEUNT2) ADDRESS OF TEXT UNIT #2\nFREEUNT1 DC    X'0001',X'0001',X'0008',C'FINDMEDD'\nFREEUNT2 DC    X'0007'\n         DC    X'0000'\n*\n*        DATA STRUCTURE FOR DYNAMIC ALLOCATION\nALOCBLOK DS    0F\nDD1PARM  DC    X'80'         TURN ON HIGH ORDER BIT\n         DC    AL3(DD1RB)    ADDRESS OF REQUEST BLOCK\nDD1RB    DC    X'14'         S99RBLN (LENGTH OF REQUEST BLOCK)\n         DC    X'01'         S99VERB (REQUEST FOR DSNAME ALLOC)\n         DC    X'2000'       S99FLAG1 (DO NOT MOUNT VOLUMES)\n         DC    X'0000'       S99ERROR (ERROR REASON CODE)\n         DC    X'0000'       S99INFO (INFORMATION REASON CODE)\n         DC    A(DD1TUPL)    S99TXTPP (ADDR OF POINTERS TO TEXT UNITS\n         DC    X'00000000'   RESERVED\n         DC    X'00000000'   S99FLAG2\nDD1TUPL  DC    A(DD1UNIT1)   ADDRESS OF TEXT UNIT #1\n         DC    A(DD1UNIT2)   ADDRESS OF TEXT UNIT #2\nDD1HIGH3 DS    XL1\n         DC    AL3(DD1UNIT3) ADDRESS OF TEXT UNIT #3\nDD1HIGH4 DS    XL1\n         DC    AL3(DD1UNIT4) ADDRESS OF TEXT UNIT #4\nDD1HIGH5 DS    XL1\n         DC    AL3(DD1UNIT5) ADDRESS OF TEXT UNIT #5\nDD1UNIT1 DC    X'0001',X'0001',X'0008',C'FINDMEDD'\nDD1UNIT2 DC    X'0002'\n         DC    X'0001'\nDSNLEN   DS    BL2\nDSNAME   DS    CL44\nDD1UNIT3 DC    X'0004',X'0001',X'0001',X'08'\nDD1UNIT4 DC    X'0015',X'0001',X'0008',C'SYSALLDA'\nDD1UNIT5 DC    X'0010'\n         DC    X'0001'\n         DC    X'0006'\nDD1VOLSR DS    CL6\nWORKLEN  EQU   *-WORKAREA\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "FINDMEM$": {"ttr": 19465, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x00\\x7f\\x00\\x88\\x00\\x7f\\x12\\x00\\x00N\\x00N\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf2\\xf7\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-01-07T00:00:00", "modifydate": "1988-01-07T12:00:00", "lines": 78, "newlines": 78, "modlines": 0, "user": "FILE270"}, "text": "1                                                        FINDMEM.1\n                                                         06/25/82\n\n\n  PROGRAM:       FINDMEM\n  AUTHOR:        Jeff Sprehn\n  AGENCY:        WDPSC\n  LANGUAGE:      Assembler\n  LOCATION:      WDPSC.SHARED.LOAD\n  FUNCTION:      Subroutine  to be  called by  high level  language\n                 program to  determine whether  a specified  member\n                 exists in a given PDS data set.\n\n  RUN MODE:      Batch or Interactive\n\n  This program is a subroutine  which dynamically allocates the DSN\n  passed to it and then searches the directory to determine whether\n  the member name passed to it exists or not.\n\n  To call this program from a COBOL program, do the following:\n\n  If your dataset IS cataloged:\n       MOVE your dataset name\n            TO DSNAME OF FINDMEM-I-O-AREA.\n       MOVE your member name\n            TO MEMBER-NAME OF FINDMEM-I-O-AREA.\n       CALL 'FINDMEM' USING FINDMEM-I-O-AREA.\n\n\n\n\n1                                                        FINDMEM.2\n                                                         06/25/82\n\n\n  If your dataset is NOT cataloged:\n\n       MOVE your dataset name\n            TO DSNAME OF FINDMEM-I-O-AREA.\n       MOVE  your member name\n            TO MEMBER-NAME OF FINDMEM-I-O-AREA.\n       MOVE your volume serial number\n            TO VOL-SER-NO.\n       CALL 'FINDMEM' USING FINDMEM-I-O-AREA\n                            VOL-SER-NO.\n\n\n\n\n1                                                        FINDMEM.3\n                                                         06/25/82\n\n\n  Place the following data areas in WORKING STORAGE:\n\n       01   FINDMEM-I-O-AREA.\n            05   OP-SYS VALUE 'VS'   PIC X(2).\n            05   MEMBER-NAME         PIC X(8).\n            05   DSNAME              PIC X(44).\n            05   SUCCESS-INDICATOR   PIC 99.\n       01   VOL-SER-NO     PIC X(6).\n\n  SUCCESS-INDICATOR                   MEANING\n  -----------------   -----------------------------------------\n       00             Successful allocation and find\n       04             Successfully allocated file but couldn't\n                       find member in directory\n       08             Unsuccessful allocation\n       12             DSN passed to this PGM is spaces\n       16             Member name passed is spaces\n       20             I/O error reading directory\n       24             Unsuccessful free of DDNAME FINDMEDD\n       28             Invalid volume serial number passed to\n                        this program\n\n\n\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "FINDTTR": {"ttr": 19468, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x00\\x7f\\x00\\x88\\x00\\x7f\\x12\\x00\\x00\\xbf\\x00\\xbf\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf2\\xf7\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-01-07T00:00:00", "modifydate": "1988-01-07T12:00:00", "lines": 191, "newlines": 191, "modlines": 0, "user": "FILE270"}, "text": "*          DATA SET 761KKFTTR  AT LEVEL 001 AS OF 10/13/80\n         TITLE 'FINDTTR - SEARCHES PDS  FOR STRING (GAS MEMS INCL) '\n* WRITTEN BY KERMIT KISER - WASHINGTON STATE DP SERVICE CENTER (WDPSC)\n*\nFINDTTR  ENTERR\n         EJECT\n         L     R11,0(,R1)               R11->PARM FIELD\n         LH    R10,0(,R11)              R10=PARM LENGTH\n         BCTR  R10,R0                   R10=R10-1 FOR EX\n*\n         L     R0,=A(BUFLEN)\n         GETMAIN R,LV=(0)\n         LR    R6,R1                    R6->I/O BUFF\n         USING MYBUF,R6\n*\n         BAL   R14,OPEN                 THE FILES\n         LTR   R15,R15                  OK?\n         BNZ   ERREX                    NO\n*\nPILOOP   BAL   R14,PROCIT               CHECK A BLOCK\n         LTR   R15,R15                  DONE?\n         BZ    PILOOP                   NO\n*\n         BAL   R14,CLOSE                THE FILES\n*\nOKEX     SLR   R15,R15                  RC=0\n*\nERREX    LEAVER\n         EJECT\nOPEN     EQU   *\n         ST    R14,L1LS\n*\n         MVI   OPENL,X'80'\n         MVC   PDS(96),PDSL\n         OPEN  (PDS,INPUT),MF=(E,OPENL)\n         LTR   R15,R15\n         BNZ   OPENX\n*\n         MVC   PRINT(96),PRINTL\n         OPEN  (PRINT,OUTPUT),MF=(E,OPENL)\n*\nOPENX    L     R14,L1LS\n         BR    R14\n         EJECT\nPROCIT   EQU   *\n         ST    R14,L1LS\n*\nREADBLK  READ  DECB,SF,PDS,MYBUF,32760,MF=E GET BLK\n*\n         CHECK DECB                     GOT IT?\n         TM    SF,X'80'                 SYNAD FLAG?\n         BO    MBEODS                   MUST BE END OF DATASET\n*\n         L     R7,BC                    R7=BLKS READ COUNT\n         LA    R7,1(,R7)                R7=R7+1\n         ST    R7,BC                    SAVE\n*\n         NOTE  PDS                      GET TTR OF BLOCK\n         ST    R1,TTR                   SAVE\n*\n         BAL   R14,SCANIT               STRING MATCH?\n         LTR   R15,R15\n         BNZ   PROCX\n*\n         TM    MF,X'80'                 SCAN MATCH?\n         BNO   PROCX                    NO\n         BAL   R14,NOTEIT               YES->TELL SOMEONE!\n*\nPROCX    L     R14,L1LS\n         BR    R14\n*\nMBEODS   LA    R15,99                   RC=99\n         B     PROCX\n         EJECT\nSCANIT   EQU   *\n         ST    R14,L2LS\n*\n         NI    MF,X'7F'                 RESET MATCH FLAG\n         LH    R9,DCBLRECL              R9 = BLK LEN\n         BCTR  R9,R0                    -1 TO SKIP FIRST\n*\n*              CHECK START OF BLOCK FIRST:\n         LA    R8,MYBUF                 R8->START OF BLOCK\n         EX    R10,CLC                  BLOCK STARTS WITH STRING?\n         BE    GOTONE                   YES ->TELL EM NOW!\n*\n*              THEN LOOP SCANNING REST:\nSRCHLOOP LA    R8,MYBUF(R9)             R8->SRCH LOC\n         EX    R10,CLC                  STRING THERE?\n         BE    GOTONE                   YES!\n         BCT   R9,SRCHLOOP              NO->KEEP LOOKING\n*\nSCANX    L     R14,L2LS\n         BR    R14\n*\nGOTONE   OI    MF,X'80'                 SAY WE FOUND ONE!\n         L     R7,MC                    R7=MATCH COUNT\n         LA    R7,1(,R7)                +1\n         ST    R7,MC\n         B     SCANX\n*\nCLC      CLC   2(0,R11),0(R8)           EXECUTED STRING COMPARE\n         EJECT\nNOTEIT   EQU   *\n         ST    R14,L2LS\n*\n         MVC   PUTLINE,=CL133' '        CLEAR PRINT LINE\n*\n         UNPK  TTRCHAR,TTR              GET TTR IN CHAR\n         TR    TTRCHAR(6),FIXTAB        MAKE READABLE\n*\n         MVC   PUTLINE(20),=CL20' SCAN MATCH AT TTR='\n         MVC   PUTLINE+20(6),TTRCHAR    INSERT TTR\n*\n         PUT   PRINT,PUTLINE            WRITE IT\n*\n         L     R14,L2LS\n         BR    R14\n         EJECT\nCLOSE    EQU   *\n         ST    R14,L1LS\n*\n         CLOSE (PDS),MF=(E,OPENL)       CLOSE PDS\n*\n         CLOSE (PRINT),MF=(E,OPENL)     CLOSE PRINT FILE\n*\n         L     R14,L1LS\n         BR    R14\n         EJECT\nEODAD    EQU   *\n         NOTE  PDS                      WHERE ARE WE?\n         C     R1,LASTEOF               SAME AS LAST ONE?\n         BE    MBEODS                   YES -> TERMINATE\n         ST    R1,LASTEOF               SAVE EOF ADDR\n         ST    R1,TTR                   SAVE\n         MVI   TTR+3,X'01'              SAY READ NEXT\n         POINT PDS,TTR                  POINT TO IT (PAST EOF)\n*\n         L     R7,EC                    GET EOF COUNT\n         LA    R7,1(,R7)                +1\n         ST    R7,EC                    SAVE\n*\n         B     READBLK\n*\nSYNAD    OI    SF,X'80'                 SAY DONE\n         BR    R14                      GET OUT\n         EJECT\nSTATWORK EQU   *\n*\nFIXTAB   EQU   *-X'F0'\n         DC    C'0123456789ABCDEF'\n         DS    0F\nPDSL     DCB   DSORG=PO,DDNAME=PDS,EODAD=EODAD,SYNAD=SYNAD,            X\n               RECFM=U,MACRF=R\n*\nPRINTL   DCB   DSORG=PS,DDNAME=PRINT,MACRF=PM,                         X\n               RECFM=FBA,BLKSIZE=133,LRECL=133\n*\n         LTORG\n         EJECT\nWORKAREA DSECT\nSAVEAREA DS    18F\nL1LS     DS    F\nL2LS     DS    F\nTTR      DS    F                        TTR POINTER\nLASTEOF  DS    F                        EOF POINTER\nTTRCHAR  DS    XL7                      TTR REFORMAT AREA\n*              FLAGS AND COUNTERS:\nMC       DS    F\nBC       DS    F\nEC       DS    F\nSF       DS    X\nMF       DS    X\n         EJECT\nPUTLINE  DS    XL133\nOPENL    DS    F\nDECB     READ  XECB,SF,MF=L\nPDS      DCB   DSORG=PO,DDNAME=PDS,EODAD=EODAD,SYNAD=SYNAD,            X\n               RECFM=U,MACRF=R\nDCBLRECL EQU   PDS+82\n         EJECT\n*\nPRINT    DCB   DSORG=PS,DDNAME=PRINT,MACRF=PM,                         X\n               RECFM=FBA,BLKSIZE=133,LRECL=133\nWORKLEN  EQU   *-WORKAREA\n         EJECT\nMYBUF    DSECT\n         DS    XL32760                  I/O BUFF\n         DS    256X                     OVERRUN\nBUFLEN   EQU   *-MYBUF\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "FINDTTR$": {"ttr": 19716, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x00\\x7f\\x00\\x88\\x00\\x7f\\x12\\x00\\x00\\x12\\x00\\x12\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf2\\xf7\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-01-07T00:00:00", "modifydate": "1988-01-07T12:00:00", "lines": 18, "newlines": 18, "modlines": 0, "user": "FILE270"}, "text": "1 10.000\n-                                                         FINDTTR\n\n    Program FINDTTR is CALLED BY THE FINDTTR CLIST TO SEARCH A PDS FOR A\n GIVEN STRING. THE TTR OF ALL BLOCKS CONTAINING THE STRING IS DISPLAYED\n WHETHER IN DIRECTORY,MEMBERS,GAS, OR BEYOND DS1LSTAR.\n\n    URZAP (K.U) can then be used to point a directory entry to the\n desired TTR location.\n\n    The only advantage of this over PDSGAS (option K.P) might be the\n ability to search beyond DS1LSTAR and find things compressed out.\n\n    The clist syntax is:\n\n        %FINDTTR  dsname\n\n    The clist will prompt for the search string.\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "FIREUP$": {"ttr": 19718, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x00\\x7f\\x00\\x88\\x00\\x7f\\x12\\x00\\x00d\\x00d\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf2\\xf7\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-01-07T00:00:00", "modifydate": "1988-01-07T12:00:00", "lines": 100, "newlines": 100, "modlines": 0, "user": "FILE270"}, "text": "1                                                        FIREUP.1\n                                                         06/25/82\n\n\n  CLIST:              FIREUP\n  AUTHOR:             Jeff Sprehn\n  AGENCY:             WDPSC\n  FUNCTION:           Allocate  user SPF  Dialog Manager  libraries\n                      ahead of the SPF Program Development Facility\n                      libraries  and/or  to allocate  libraries  to\n                      Dialog Manager DDNAMES not already allocated.\n\n  TERMINAL TYPE: 3270 type only\n\n\n  This CLIST will allocate for you ANY  OR ALL of the following SPF\n  Dialog Manager libraries:\n       Panel library\n       Message library\n       Skeleton library\n       Table input library\n       Table output library\n       File tailoring output library\n       SPF link library\n\n  The format of this command is as follows:\n\n       FIREUP PANEL (dataset name of panel library) -\n              MESSAGE(dataset name of message library) -\n              SKELETON(dataset name of skeleton library) -\n              TABLEIN(dataset name of table input library) -\n              TABLEOUT(dataset name of table output library) -\n              TAILOUT(dataset name of file tailoring output) -\n              SPFLOAD(dataset name of SPF link library) -\n              PRINT(alloc notification)\n\n\n\n\n1                                                        FIREUP.2\n                                                         06/25/82\n\n\n       'alloc notification' enter 'YES' if you wish the CLIST\n            to write out a one line message for each library\n            to be allocated stating that the allocation was\n            successful or enter 'NO' if you do NOT wish this\n            to take place.\n\n  EXAMPLE #1\n  __________\n\n       Allocate  a  panel library  called  \"AGNCY999.PANEL.LIB\",  a\n       message  library called  \"AGNCY999.MESSAGE.LIB\",  and a  SPF\n       link library  called \"AGNCY999.SPF.LOADLIB\"  (User's PROFILE\n       PREFIX  is  XX00999  and  user   does  not  want  allocation\n       notification messages).\n\n            FIREUP PANEL('''AGNCY999.PANEL.LIB''') -\n                   MESSAGE('''AGNCY999.MESSAGE.LIB''') -\n                   SPFLOAD('''AGNCY999.SPF.LOADLIB''') -\n                   PRINT(NO)\n\n  EXAMPLE #2\n  __________\n\n       Allocate  a panel  library  called \"XX00999.SPF.PANELIB\",  a\n       message library called \"XX00999.SPF.MSGLIB\",  and a skeleton\n       library called \"XX00999.SKELETON.LIB\" (User's PROFILE PREFIX\n       is  XX00999  and  user  does  want  allocation  notification\n       messages).\n\n            FIREUP PANEL (SPF.PANELIB) -\n                   MESSAGE(SPF.MSGLIB) -\n                   SKELETON(SKELETON.LIB) -\n                   PRINT(YES)\n\n\n\n\n1                                                        FIREUP.3\n                                                         06/25/82\n\n\n  This CLIST must be placed in one of the following:\n\n       .    Inside a CLIST executing in  \"straight TSO\" (outside of\n            SPF).\n\n       .    Inside      a     LOGON      PROCEDURE     such      as\n            PREFIX.MISC.CLIST(LOGON) for PRODl users.\n\n  The  Dialog Manager  libraries  cannot  be allocated  within  SPF\n  (Option '6') because the concatenation  will fail because the SPF\n  Program  Development Facility  libraries  are  OPEN and  are  not\n  CLOSED until you exit SPF.\n\n\n\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "FTL": {"ttr": 19721, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x00\\x7f\\x00\\x88\\x00\\x7f\\x12\\x00\\x01:\\x01:\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf2\\xf7\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-01-07T00:00:00", "modifydate": "1988-01-07T12:00:00", "lines": 314, "newlines": 314, "modlines": 0, "user": "FILE270"}, "text": "      TITLE ' THE GREAT, LATE PROGRAM FTL OR FASTER-THAN-LIGHT'\n* SEE A. EINSTEIN'S 'THEORY OF RELATIVITY' FOR A BETTER EXPLANATION.\nFTL    CSECT\n    SPACE 2\n*    FTL MAY BE USED UNDER O/S FOR  TRANSFER OF MULTIPLE SEQUENTIAL\n* FILES IN ONE STEP. THIS SAVES INITIATION/TERMINATION TIME.AND IS\n*    FTL WILL RUN IN 4K (NOT INCLUDING FILE BUFFERS)\n*\n*    FTL CAN REBLOCK FILES OR CHANGE PHYSICAL RECORD LENGTH OR FORMAT\n* BY SPECIFYING APPROPIATE DCB PARAMETERS ON THE OUTPUT DATA DEFINITION\n* (DD) STATEMENT.\n*\n*    THE DD STATEMENTS ARE PAIRED USING NAMES IN AND OUT AS PREFIXES\n* FOLLOWED BY A TWO-CHARACTER NUMBER FROM 01 TO 99. THESE PAIRS MUST BE\n* SEQUENTIAL STARTING WITH IN01 AND OUT01 AND INCREASING WITHOUT BREAK\n* FOR AS MANY FILES AS DESIRED.\n*    ANY SEQUENTIALLY ORGANIZED FILE MAY BE INPUT OR OUTPUT. IT MAY\n* HAVE ANY RECORD FORMAT, RECORD LENGTH, AND BLOCKSIZE CONSISTENT WITH\n* O/S. EXCEPTIONS ARE INDEXED SEQUENTIAL(ISAM) DATA SET ORGANIZATION,\n* VARIABLE SPANNED RECORD FORMAT, AND PARTITIONED DATA SETS. THE LATTER\n* MAY BE PROCESSED AS INDIVIDUAL MEMBERS.\n*\n*    WHEN EXPANDING   THE RECORD LENGTH, THE ADDITIONAL FIELD WILL HAVE\n* UNPREDICTABLE CONTENTS. OTHER CHANGES OF LENGTH, FORMAT, OR BLOCKSIZE\n* DO NOT AFFECT FILE CONTENT.\n*\n*    FOR EACH TRANSFER PAIR, A MESSAGE IS WRITTEN TO AN OUTPUT DATA SET\n* (DD NAME IS MESSAGES) GIVING A RECORD COUNT AND VOLUME SERIAL NUMBER\n* OF INPUT AND OUTPUT DATA SETS IF ON DIRECT ACCESS OR TAPE.\n*\n* FTL IS AN OLD SCIENCE FICTION TERM MEANING \"FASTER THAN LIGHT\".\n*\n         EJECT\n*  SAMPLE JCL\n*//SAVE EXEC PGM=FTL\n*//STEPLIB DD DSN=SYSLIBRY,DISP=SHR   PROGRAM LIBRARY\n*//SYSUDUMP DD SYSOUT=A\n*//MESSAGES DD SYSOUT=A\n*//IN01     DD DSN=Y01PR195,DISP=SHR,DCB=BUFNO=1,VOL=(,RETAIN)\n*//OUT01    DD DSN=T011PR195,DISP=(NEW,KEEP),UNIT=TAPE16,VOL=(,RETAIN),\n*//  DCB=(LRECL=1560,BLKSIZE=1560,BUFNO=1,RECFM=FB)\n*//IN02     DD DSN=Y02PR195,DISP=SHR,DCB=(BUFNO=4,OPTCD=C)\n*//OUT02    DD DSN=T02PR195,DISP=(NEW,KEEP),UNIT=TAPE16,LABEL=2,\n*//  VOL=C,RETAIN,REF=*,OUT01,\n*// DCB=(LRECL=492,BLKSIZE=19188,RECFM=FB,BUFNO=3,OPTCD=C)\n*//IN03     DD  .  .  .\n*//OUT03    DD  .  .  .\n*     .\n*     .\n*     .\n*    THIS EXAMPLE SHOWS A DCB GIVEN FOR EVERY DD STATEMENT, THIS IS\n* NOT NECESSARY WHEN NO CHANGE OF RECORD LENGTH, RECORD FORMAT, OR\n* BLOCKSIZE IS BEING MADE, BECAUSE THE PROGRAM WILL COPY THESE DCB\n* PARAMETERS FROM THE INPUT FILE.\n*\n*\n         EJECT\n         DS    0H\n         STM   R14,R12,12(R13)            SAVE REGISTERS\n         LR    R11,R13\n         BALR  R12,0                      LOAD BASE REGISTER\n         USING *,R12\n         LA    R13,SAVE                   SAVE AREA\n         ST    R13,8(0,R11)               AND BACK CHAIN\n         ST    R11,4(0,R13)\n         XR    R4,R4                      ANALYZE PARAMETER\n         L     R3,0(,R1)\n         USING WRKAREA,R6\n         USING PARM,R3\n         CH    R4,BCTF                    IF LENGTH IS ZERO\n         BE    NOPARM                         NO PARAMETER\n         PACK  PDDCT,DDCT                 SET NUMBER OF\n         CVB   R3,PDDCT                     DD PAIRS\n         ST    R3,DDNUMBER                    FOR LATER USE\nNOPARM   EQU   *\n         DEVTYPE SYSP,DEVAREA         CHECK FOR DDNAME MESSAGES\n         LTR   R15,R15                IS IT PRESENT?\n         BZ    OPNPRT                 YES, OPEN MESSAGES\n         MVC   SYSP,=C'SYSPRINT'      CHANGE TO    SYSPRINT\n         MVC   PRINT+40(8),=C'SYSPRINT'   AND IN DCB\n         DEVTYPE SYSP,DEVAREA         CHECK FOR DDNAME SYSPRINT\n         LTR   R15,R15                IS IT PRESENT?\n         BNZ   FINIT                  NO, FINISH, ELSE OPEN PRINT\n         USING IHADCB,R5\nOPNPRT   OPEN  (PRINT,OUTPUT)             MESSAGE DATA SET\n         TM    PRINT+48,X'10'         DID IT OPEN\n         BZ    FINIT\n         PUT   PRINT,HEAD                 HEADING\n         L     R1,536                     CURRENT TCB ADDRESS\n         L     R1,12(,R1) TIOT            TIOT  TO BE USED\n         LA    R6,MSG1                       FOR\n         MVC   WRKAREA+1(8),0(R1)                JOBNAME\n         MVC   WRKAREA+10(8),16(R1)              STEPNAME\n         MVC   WRKAREA+19(8),08(R1)              PROCSTEPNAME\n         PUT   PRINT,WRKAREA                     SECOND LINE OF HEADING\n         MVC   DDNIN,DDI                         DDNAMES TO MESSAGE\n         MVC   DDNOU,DDO\n         LA    R8,INDCB                   FOR GET  PROCESS\nHERWGO   EQU   *\n         MVC   OUTDCB+40(8),DDNOU         DDNAME TO DCB\n         MVC   INDCB+40(8),DDNIN          DDNAME TO DCB\n         DEVTYPE DDNOU,DEVAREA,DEVTAB     CHECK FOR OUTPUT DDNAME\n         LTR   R15,R15\n         BNZ   FINIT                      FINISH IF NOT PRESENT\n         DEVTYPE DDNIN,DEVAREA,DEVTAB     CHECK FOR INPUT DDNAME\n         LTR   R15,R15\n         BNZ   FINIT                      FINISH IF NOT  PRESENT\n         MVC   PDDCT,PDDCT+8              ZERO COUNT FIELD\n         OPEN  (INDCB)\n         OPEN  (OUTDCB,(OUTPUT))\n         LA     R5,OUTDCB                 BASE REGISTER FOR OUTPUT\n         TM    DCBOFLGS,X'10'             DID OPEN FAIL\n         BZ    FINIT                      YES\n         TM    INDCB+48,X'10'             DID OPEN FAIL\n         BZ    FINIT                      YES\n         L     R11,=F'04'\n***********************************************************************\n****************  TABLE OF INPUT TO OUTPUT ACTION *********************\n* RECORD FORMAT     ACTIONS\n* INPUT  OUTPUT     TO BE TAKEN\n**     **      *****                         **************************\n*  F   *   F     *   WRITE\n*  F   *   V     *   ADD 4 TO BEGIN OF RECORD; SET LENGTH IN RDW;\n*      *         *       SET LENGTH IN DCB; WRITE\n*  F   *   U     *   SET LENGTH IN DCB; WRITE\n*  V   *   F     *   REMOVE 4 BYTES; WRITE\n*  V   *   V     *   SET LENGTH IN DCB; WRITE\n*  V   *   U     *   REMOVE 4 BYTES; SET LENGTH IN DCB; WRITE\n*  U   *   F     *   WRITE\n*  U   *   V     *   ADD 4 TO BEGIN OF RECORD; SET LENGTH IN RDW;\n*      *         *       SET LENGTH IN DCB; WRITE\n*  U   *   U     *   SET LENGTH IN DCB; WRITE\n*      *         *\n***********************************************************************\nREADING  GET   (R8)                       GET INPUT FILE\n         LR    R6,R1\n         LH    R7,INDCB+82                RECORD LENGTH\n         TM    INDCB+36,DCBRECF           INPUT FIXED OR UNDEFINED\n         BO    C100                       YES\n         TM    DCBRECFM,DCBRECF           OUTPUT FIXED OR UNDEFINED\n         BNO   RITING                    NO\n         SH    R7,=H'4'                   VARIABLE TO FIXED OR\n         LA    R6,4(,R6)                      UNDEFINED\n         TM    DCBRECFM,DCBRECF           OUTPUT FORMAT TYPE\n         BO    WRITING                    FIXED\n         B     RITING                     UNDEFINED\nC100     TM    DCBRECFM,DCBRECV            OUTPUT VARIABLE OR UNDEFINED\n         BNO   WRITING                NOPE, MUST BE FIXED\n         TM    DCBRECFM,DCBRECF        OUTPUT FIXED OR UNDEFINED\n         BZ    C150                   NOPE, MUST BE  VARIABLE\n         B     RITING\nC150     LA    R7,4(,R7)              ADD 4 TO RECORD LENGTH\n         C     R7,OUTSIZE             LENGTH TO OUTPUT SIZE\n         BNH   READYMVE               LOW THEN GO\n         L     R2,OUTAREA             ANY OUTPUT AREA\n         LTR   R2,R2\n         BZ    NEWAREA                NO\n         L     R7,OUTSIZE\n         FREEMAIN R,LV=(R7),A=(R2)    RELEASE OLD\n         LH    R7,INDCB+82            INPUT RECORD LENGTH\n         LA    R7,4(,R7)              ADD 4 FOR RECORD-CONTROL-WORD\nNEWAREA  GETMAIN   R,LV=(R7)          GET NEW AREA\n         ST    R7,OUTSIZE             SIZE OF AREA\n         ST    R1,OUTAREA             ADDRESS OF AREA\nREADYMVE L     R2,OUTAREA      MOVE BY MOVE LONG\n         LR    R3,R7           SIZE OF MOVE\n         LH    R7,INDCB+DCBLRECL-IHADCB\n         LA    R2,4(,R2)       WHERE TO MOVE\n         MVCL  R2,R6                  DO IT\n         L     R6,OUTAREA      REFRESH ADDRESS\n         L     R7,OUTSIZE      REFRESH SIZE\n         STCM  R7,3,0(R6)      STORE SIZE IN RECORD\nRITING   STH   R7,DCBLRECL     RECORD LENGTH INTO OUTPUT DCB\nWRITING  EQU   *\n         CLC   INDCB+DCBLRECL-IHADCB(2),DCBLRECL  INPUT VS. OUTPIT\n         BNL   WRITEON\n         BAL   R9,OC4CHECK       THAN OUTPUT\nWRITEON  EQU   *\n         AP    PDDCT,ONE       ADD TO OUTPUT COUNT (LOGICAL)\n         PUT   (R5),(R6)      PUT RECORD AT R6 TO FILE AT R5\n         B     READING         START OVER\n         SPACE 3\n* ESSENTIALLY A REPEAT OF EARIER CODE. THIS CODE PREVENTS 0C4'S\n* THAT OCCUR WHEN INPUT IS SHORTER THAN THE OUTPUT\nOC4CHECK TM    DCBRECFM,DCBRECV       UNDEFINED OR VARIABLE\n         BOR   R9\n         LH    R3,DCBLRECL            OUTPUT RECORD LENGTH\n         LH    R7,INDCB+82            INPUT  RECORD LENGTH\n         C     R3,EXSIZE              EXCESS SIZE AREA\n         BNH   MOOVEON                LOW THEN GO\n         ICM   R2,15,EXAREA              ANY OUTPUT AREA\n         BZ    NEWSTG                 NO\n         L     R3,EXSIZE\n         FREEMAIN R,LV=(R3),A=(R2)    RELEASE OLD\n         LH    R3,DCBLRECL            OUTPUT RECORD LENGTH\n         SRL   R3,10\n         LA    R3,1(,R3)\n         SLL   R3,10\nNEWSTG   GETMAIN   R,LV=(R3)          GET NEW AREA\n         ST    R3,EXSIZE             SIZE OF AREA\n         ST    R1,EXAREA             ADDRESS OF AREA\nMOOVEON  L     R2,EXAREA           MOVE BY MOVE LONG\n         LH    R3,DCBLRECL            OUTPUT RECORD LENGTH\n         MVCL  R2,R6                  DO IT\n         L     R6,EXAREA          REFRESH ADDRESS\n         L     R7,EXSIZE           REFRESH SIZE\n         BR    R9\n         SPACE 4\nEODADR   EQU   *                  FINISH\n         TM    INDCB+26,X'A2'        PHYSICAL SEQUENTIAL\n         BM    E100                  NO, THEN NO INFORMATION\n         TM    INDCB+17,X'A0'         DISK OR TAPE\n         BZ    E100                  NO, AGAIN NO INFORMATION\n         L     R3,INDCB+44            DEB ADDRESS FROM DCB\n         L     R3,32(,R3)             UCB ADDRESS FROM DEB\n         MVC   FROM,28(R3)            VOLUME SERIAL NUMBER\nE100     TM    OUTDCB+26,X'A2'        PHYSICAL SEQUENTIAL\n         BM    E110\n         TM    OUTDCB+17,X'A0'        DISK OR TAPE\n         BZ    E110\n         L     R3,OUTDCB+44           DEB ADDRESS FROM DCB\n         L     R3,32(,R3)             UCB ADDRESS FROM DEB\n         MVC   TORM,28(R3)            VOLUME SERIAL NUMBER\nE110     EQU   *\n         CLOSE (INDCB,,OUTDCB)         CLOSE INXX AND OUTXX\n         OI    INDCB+52,X'20'          TURN            ON\n         UNPK  CNTRFLD,PDDCT           PREPARE AND\n         OI    CNTRFLD+7,X'F0'               PRINT RECORD COUNT\n         PUT   PRINT,MSG               THE PRINT\n         L     R3,DDNUMBER             ANY MORE PAIRS\n         BCT   R3,CLEANUP              YES\n         B     FINIT                    NO\nCLEANUP  XC    FROM,FROM               CLEAR MESSAGE AREA\n         XC    TORM,TORM\n         ST    R3,DDNUMBER             DD POSSIBLES\n         PACK  PDDCT,CNTFLD            CURRENT DDNAME NUMBER\n         AP    PDDCT,ONE               NEW DDNAME NUMBER\n         UNPK  CNTFLD,PDDCT            MAKE PRESENTABLE FOR MESSAGE\n         OI    CNTFLD+1,X'F0'\n         MVC   COTFLD,CNTFLD\n         FREEPOOL INDCB                RESET FILE AREAS\n         FREEPOOL OUTDCB               RESET FILE AREAS\n         B     HERWGO                  START AT OPEN\nFINIT    EQU    *                      FINISHED FOR SURE\n         CLOSE (PRINT)\n         L     R13,SAVE+4\n         RETURN  (14,12),T,RC=0       AND LEAVE\nSAVE     DS    18F\n         DS    0D\nPDDCT    DC    2PL8'00000'\nTFOUR    DS    CL1\nDEVAREA  DC    6F'0'         FOR DEVTYPE MACRO\nSYSP     DC    C'MESSAGES'\n* SWU  EXIT LIST PROBABLY NOT NEEDED\nINDCB    DCB   DSORG=PS,MACRF=GL,EODAD=EODADR,BUFNO=10 EXLST=(SWU)\nOUTDCB   DCB   DSORG=PS,MACRF=PM,EXLST=(OUTS),BUFNO=10\nDDI      DC    CL8'IN01    '\nDDO      DC    CL8'OUT01   '\nONE      DC    PL4'1'\nOUTSIZE  DC    F'0'\nOUTAREA  DC    F'0'\nEXSIZE   DC    F'0'\nEXAREA   DC    F'0'\nDDNUMBER DC    F'110'\nHEAD     DC    C'1LIQUOR CONTROL BOARD UTILITY FTL I-8 DP',20X'40'\n         REGISTER\nMSG      DS    0CL60\n         DC    CL6'0 END '\nDDNIN    DS    0CL8\n         DS    CL2\nCNTFLD   DS    CL2\n         DC    4X'40'\nCNTRFLD  DC    CL8'        '\n         DC    4X'40'\n         DC    C'RECORDS FROM '\nFROM     DS    CL6\n         DC    C'  TO '\nTORM     DS    CL6\n         DC    C'        '\nDDNOU    DS    0CL8\n         DS    CL3\nCOTFLD   DS    CL2\nPRINT    DCB   DSORG=PS,DDNAME=MESSAGES,MACRF=(PM),RECFM=FBA,LRECL=60, X\n               BLKSIZE=120\n         DS    0F\n         DROP  R5\n         USING IHADCB,R8\n*SWU     DC    XL1'85'\n*        DC    AL3(ROUTINE)\n*OUTINE  TM    INDCB+36,X'C0'\n*        BCR   4,R14\n*        NI    INDCB+52,X'DF'\n*        BR    R14\nOUTS     DC    XL1'85'\n         DC    AL3(AUTO)\nAUTO     CLI   36(R1),X'00'\n         BNE   AUTO1\n         MVC   36(1,R1),DCBRECFM\nAUTO1    CLC   82(2,R1),PDDCT+8\n         BNE   AUTO2\n         MVC   82(2,R1),DCBLRECL\nAUTO2    CLC   62(2,R1),PDDCT+8\n         BCR   7,R14\n         MVC   62(2,R1),DCBBLKSI\n         BR    R14\nMSG1     DC    60X'40'\nPARM     DSECT\nBCTF     DS    1H\nDDCT     DS    CL2\n         PRINT NOGEN\n         DCBD  DSORG=PS\nWRKAREA  DSECT         THIS IS DUMMY WORK AREA, LENGTH HERE MEANS\n         DS    CL3000     NOTHING, USED AS BASE REGISTER DEFINE ONLY\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "FTL$": {"ttr": 19969, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x00\\x7f\\x00\\x88\\x00\\x7f\\x12\\x00\\x004\\x004\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf2\\xf7\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-01-07T00:00:00", "modifydate": "1988-01-07T12:00:00", "lines": 52, "newlines": 52, "modlines": 0, "user": "FILE270"}, "text": "*    FTL MAY BE USED UNDER O/S FOR  TRANSFER OF MULTIPLE SEQUENTIAL\n* FILES IN ONE STEP. THIS SAVES INITIATION/TERMINATION TIME.AND IS\n*    FTL WILL RUN IN 4K (NOT INCLUDING FILE BUFFERS)\n*\n*    FTL CAN REBLOCK FILES OR CHANGE PHYSICAL RECORD LENGTH OR FORMAT\n* BY SPECIFYING APPROPIATE DCB PARAMETERS ON THE OUTPUT DATA DEFINITION\n* (DD) STATEMENT.\n*\n*    THE DD STATEMENTS ARE PAIRED USING NAMES IN AND OUT AS PREFIXES\n* FOLLOWED BY A TWO-CHARACTER NUMBER FROM 01 TO 99. THESE PAIRS MUST BE\n* SEQUENTIAL STARTING WITH IN01 AND OUT01 AND INCREASING WITHOUT BREAK\n* FOR AS MANY FILES AS DESIRED.\n*    ANY SEQUENTIALLY ORGANIZED FILE MAY BE INPUT OR OUTPUT. IT MAY\n* HAVE ANY RECORD FORMAT, RECORD LENGTH, AND BLOCKSIZE CONSISTENT WITH\n* O/S. EXCEPTIONS ARE INDEXED SEQUENTIAL(ISAM) DATA SET ORGANIZATION,\n* VARIABLE SPANNED RECORD FORMAT, AND PARTITIONED DATA SETS. THE LATTER\n* MAY BE PROCESSED AS INDIVIDUAL MEMBERS.\n*\n*    WHEN EXPANDING   THE RECORD LENGTH, THE ADDITIONAL FIELD WILL HAVE\n* UNPREDICTABLE CONTENTS. OTHER CHANGES OF LENGTH, FORMAT, OR BLOCKSIZE\n* DO NOT AFFECT FILE CONTENT.\n*\n*    FOR EACH TRANSFER PAIR, A MESSAGE IS WRITTEN TO AN OUTPUT DATA SET\n* (DD NAME IS MESSAGES) GIVING A RECORD COUNT AND VOLUME SERIAL NUMBER\n* OF INPUT AND OUTPUT DATA SETS IF ON DIRECT ACCESS OR TAPE.\n*\n* FTL IS AN OLD SCIENCE FICTION TERM MEANING \"FASTER THAN LIGHT\".\n*\n         EJECT\n*  SAMPLE JCL\n*//SAVE EXEC PGM=FTL\n*//STEPLIB DD DSN=SYSLIBRY,DISP=SHR   PROGRAM LIBRARY\n*//SYSUDUMP DD SYSOUT=A\n*//MESSAGES DD SYSOUT=A\n*//IN01     DD DSN=Y01PR195,DISP=SHR,DCB=BUFNO=1,VOL=(,RETAIN)\n*//OUT01    DD DSN=T011PR195,DISP=(NEW,KEEP),UNIT=TAPE16,VOL=(,RETAIN),\n*//  DCB=(LRECL=1560,BLKSIZE=1560,BUFNO=1,RECFM=FB)\n*//IN02     DD DSN=Y02PR195,DISP=SHR,DCB=(BUFNO=4,OPTCD=C)\n*//OUT02    DD DSN=T02PR195,DISP=(NEW,KEEP),UNIT=TAPE16,LABEL=2,\n*//  VOL=C,RETAIN,REF=*,OUT01,\n*// DCB=(LRECL=492,BLKSIZE=19188,RECFM=FB,BUFNO=3,OPTCD=C)\n*//IN03     DD  .  .  .\n*//OUT03    DD  .  .  .\n*     .\n*     .\n*     .\n*    THIS EXAMPLE SHOWS A DCB GIVEN FOR EVERY DD STATEMENT, THIS IS\n* NOT NECESSARY WHEN NO CHANGE OF RECORD LENGTH, RECORD FORMAT, OR\n* BLOCKSIZE IS BEING MADE, BECAUSE THE PROGRAM WILL COPY THESE DCB\n* PARAMETERS FROM THE INPUT FILE.\n*\n*\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "FULLSCR3": {"ttr": 19971, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x00\\x7f\\x00\\x88\\x00\\x7f\\x12\\x00\\x02-\\x02-\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf2\\xf7\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-01-07T00:00:00", "modifydate": "1988-01-07T12:00:00", "lines": 557, "newlines": 557, "modlines": 0, "user": "FILE270"}, "text": "*          DATA SET 761KKFS3   AT LEVEL 001 AS OF 10/13/80\n*          DATA SET 761KKFSCRN AT LEVEL 003 AS OF 02/20/79\n         TITLE 'FULLSCRN - 3270 I/O SUBROUTINE  -  VERSION 3.3'\n*          DATA SET 761KKFSCRN AT LEVEL 002 AS OF 06/07/78\n*  AUTHOR: KERMIT KISER - WASHINGTON STATE DP SERVICE CENTER (WDPSC).\n*          (206) 902-3119\nFULLSCR3 CSECT\nFULLSCRN DS    0H                 FOR VERSION 2\n         ENTRY FULLSCRN\nFULLSC   DS    0H                 FOR FORTRAN\n         ENTRY FULLSC\n         SAVE  (14,12),,FULLSCR3-V3M3\n         LR    R12,R15            HOPE HE KNOWS WHAT HE'S DOING\n         USING FULLSCR3,R12\n         EJECT\n*\n*   VERSION 2  FORMAT:\n*           CALL 'FULLSCRN' USING IOPARM OUTLEN OUTBUFF\n*                                       /INLEN  INBUFF/\n*                                       /RETLEN/ .\n*\n* WHERE:  /INLEN INBUFF/ AND /RETLEN/ ARE OPTIONAL PARMS, AND;\n*         IOPARM IS - \"I\"  FOR INPUT ONLY\n*                     \"O\"  FOR OUTPUT ONLY\n*                     \"B\"  FOR BOTH\n*\n*\n*\n*\n*   VERSION 3  FORMAT:\n*           CALL 'FULLSCR3' USING IOPARM  /OUTLEN OUTBUFF/\n*                                         /INLEN  INBUFF/\n*                                         /RETLEN/\n*                                         /SCRUFF/ .\n*\n* WHERE: IOPARM IS THE ONLY REQUIRED PARM AND HAS THE FOLLOWING FORMAT:\n*        IOPARM IS - \"VT123456\"   WHERE:\n*                  V - IS \"3\" TO INDICATE VERSION CALLED.\n*                        (\"S\" TO INDICATE SPF TYPE CALL.)\n*                  T - IS CALL TYPE: SAME AS IOPARM FOR VERSION 2.\n*                  1 - IS \"X\" IF OUTLEN PARM PRESENT.\n*                  2 - IS \"X\" IF OUTBUF PARM PRESENT.\n*                  3 - IS \"X\" IF INLEN  PARM PRESENT.\n*                  4 - IS \"X\" IF INBUFF PARM PRESENT.\n*                  5 - IS \"X\" IF RETLEN PARM PRESENT.\n*                  6 - IS ONE OF THE FOLLOWING IF SCRUFF PARM PRESENT:\n*                         \"I\" IF INPUT PARSE DESIRED.\n*                         \"O\" IF OUTPUT PARSE DESIRED.\n*                         \"B\" IF BOTH PARSES DESIRED.\n*                         \"U\" IF UNFORMATTED INPUT ONLY PARSE.\n*        SCRUFF IS - A NEW SCREEN BUFFER PARM OF 1920 BYTES WHICH MUST\n*                    BE SUPPLIED IF PARSING IS REQUESTED. INBUFF IS\n*                    STILL REQUIRED TO GIVE TGET SPACE FOR THE INPUT.\n*\n*    3270 DATA STREAMS ARE IN THE FOLLOWING FORMAT:\n*\n*  OUTBUFF:  WCC/SBA/ADDR/SF/ATTR/TEXT..SBA/ADDR/SF/ATTR/TEXT/..IC\n*  INBUFF :  AID/CURSOR-ADDR/SBA/ADDR/TEXT/..SBA/ADDR/TEXT....\n*\n*    FULLSCRN RETURN CODES:\n*              99 - TOO MANY PARMS FOR VERSION TWO CALL\n*              21 - NO OUTPUT LENGTH PARM FOR OUTPUT OPERATION\n*              23 - NO OUTPUT BUFFER PARM FOR OUTPUT OPER\n*              25 - NO INPUT LENGTH PARM FOR INPUT OPERATION\n*              27 - NO INPUT BUFFER PARM FOR INPUT OPERATION\n*              OTHER - IF THE RETURN CODE IS EVEN THEN IT IS\n*                      256*(TGET RETURN CODE)+(TPUT RETURN CODE)\n*\n         EJECT\n*\n*               NOTES ON USAGE OF FULLSCR3:\n*\n*        IN MOST CASES, THE USE OF ALL PARAMETERS IS SUGGESTED.\n*    INPUT AND OUTPUT BUFFERS AND LENGTHS MUST STILL BE SUPPLIED\n*    FOR VERSION 3. THE USER MUST PROVIDE THE SCREEN IMAGE BUFFER\n*    IF HE REQUESTS PARSING. A SPACE IN POSITIONS 3-8 OF IOPARM\n*    INDICATES THAT THE CORRESPONDING PARAMETER HAS NOT BEEN PASSED\n*    AND FULLSCR3 WILL ATTEMPT TO USE ANOTHER PARAMETER IN ITS PLACE\n*    IF IT IS NEEDED.\n*                   AN EXAMPLE OF IOPARM IS : \"3BXXXXXB\" .\n*\n*            SCREEN IMAGE BUFFER (\"SCRUFF\"):\n*\n*        A NEW PARAMETER (\"SCRUFF\") IS AVAILABLE FOR FULLSCRN'S\n*    PARSE CAPABILITIES WHICH ARE NEW WITH VERSION 3. THIS PARAMETER\n*    IS AN AREA 1920 BYTES LONG; THE SAME SIZE AS THE 3277-2 SCREEN.\n*    IT HAS NO RELATION TO THE TERMINAL I/O; HOWEVER, IT MUST BE\n*    SUPPLIED IN ADDITION TO THE I/O PARMS IF PARSING IS REQUESTED.\n*    IF BOTH OUTPUT AND INPUT PARSING (\"B\" IN POSITION 8 OF IOPARM)\n*    ARE REQUESTED, FULLSCR3 WILL TRY TO MAINTAIN AN IMAGE OF THE\n*    TERMINAL SCREEN IN THIS AREA. THIS IS DONE BY PARSING THE OUTPUT\n*    AND INPUT STREAMS AFTER THE I/O HAS OCCURED AND PLACING THE\n*    RESULTS IN THE PROPER LOCATIONS IN THE SCREEN IMAGE BUFFER.\n*        ATTRIBUTE BYTES ARE STORED IN THE BUFFER WITH THE TWO\n*    HIGH-ORDER BITS TURNED OFF EXCEPT FOR THE SPACE ATTRIBUTE (X'40')\n*    WHICH IS STORED AS X'C0' (TWO HIGH-ORDER BITS ONLY ON.) IN ORDER\n*    TO DIFFERENTIATE IT FROM THE NULL CHARACTER (X'00'). THIS ENABLES\n*    FULLSCR3 TO CLEAR TO THE END OF FIELDS, DO PROGRAM TABBING,\n*    ERASE UNPROTECTED TO ADDRESS, ETC.\n*\n         EJECT\n*\n*              MAINLINE CODE:\n*\nPARMCK   BAL   R14,INIT           SET UP VERSION & PARMS\n         LTR   R15,R15            OK?\n         BNZ   BGO                NO\n*\nIOCHECK  CLI   0(R10),C' '        I/O DESIRED?\n         BE    PARSECK            NO\n         BAL   R14,DOIO           YES -> DO IT\n         LTR   R15,R15            OK?\n         BNZ   BGO                NO\n*\nPARSECK  CLI   5(R9),C' '         PARSE DESIRED?\n         BE    NOPARS             NO\n         BAL   R14,DOPARS         YES -> DO IT\n         LTR   R15,R15            OK?\n         BNZ   BGO                NO\n*\nNOPARS   EQU   *\nBGO      EQU   *\nEXIT     RETURN (14,12),RC=(15)\n         SPACE\n*\n*   GET THE INPUT PARAMETERS:\n*\nINIT     LR    R11,R1             SAVE THE PARM POINTER\n         SLR   R15,R15            CLEAR RC\n         L     R10,0(R11)         R10 -> IOFLAG\n         CLI   0(R10),C'3'        VERSION 3 CALL?\n         BE    REL3               YES\n         CLI   0(R10),C'S'              SPF?\n         BNE   REL2                NO-> MUST BE PREVIOUS VERSION\nREL3     LA    R10,1(,R10)        R10 -> OLD IOPARM\n         LA    R9,1(,R10)         R9 -> PARM PARM\n         BR    R14                RETURN TO MAINLINE\nREL2     LR    R9,R11             R9=R11\nCNTLOOP  TM    8(R9),X'80'        LAST PARM?\n         BO    SETPARM            YES\n         LA    R9,4(,R9)          R9 = R9+ 4\n         B     CNTLOOP            CHECK NEXT ONE\nSETPARM  SR    R9,R11             R9=R9-R11\n         C     R9,=F'12'          GOOD COUNT?\n         BNH   OKSET              YES\n         LA    R15,99             NO\n         BR    R14                GET OUT\nOKSET    SLL   R9,1               R9=R9*2\n         LA    R9,PARMPARM(R9)    R9 -> PSEUDO PARM FOR V2 CALL\n         BR    R14\n         EJECT\nDOIO     EQU   *\n*\n*   CHECK FOR A WRITE\n*\n         CLI   0(R10),C'I'        IN ONLY?\n         BE    READCHK            YES\n*\n         BAL   R7,WRITESET        GET WRITE PARMS\n*\n         L     R15,0(,R11)              R15->IOPARM\n         CLI   0(R15),C'S'              SPF TYPE?\n         BNE   BUFFRITE                 NO\n         ICM   R15,15,=C'SPFP'          YES->TELL SVC\nBUFFRITE TPUT  (R5),(R6),FULLSCR\n         LR    R3,R15             R3=R15 SAVE RC\n         SLR   R15,R15            CLEAR FOR READ RC\n         B     READCHK            CHECK FOR READ\n         SPACE 5\n*              SUBRTN TO GET WRITE PARMS\n*\nWRITESET CLI   0(R9),C' '         OUTLEN GIVEN?\n         BNE   LOL                YES\n         LA    R15,21             NO -> RC=21\n         BR    R14                X\nLOL      L     R6,4(,R11)         R6-> OUTLEN\n         LH    R6,0(,R6)          R6 =  \"\n         CLI   1(R9),C' '         OUTBUFF GIVEN?\n         BNE   LOB                YES\n         LA    R15,23             NO -> RC=23\n         BR    R14                X\nLOB      L     R5,8(,R11)         R5 -> OUTBUF\n         LA    R5,0(,R5)          CLEAR HI BIT\n         BR    R7                 X\n         EJECT\n*\n*   CHECK FOR A READ\n*\nREADCHK  CLI   0(R10),C'O'        OUT ONLY?\n         BE    IOX                YES.\n*\n         BAL   R7,READSET         R5->INBUF,R6=INLEN\n         BAL   R7,RETCK           R4 -> RETLEN AREA\n*\n         L     R15,0(,R11)              R15->IOPARM\n         CLI   0(R15),C'S'              SPF TYPE?\n         BNE   BUFFREAD                 NO\n         ICM   R15,15,=C'SPFG'          YES->TELL SVC\nBUFFREAD TGET  (R5),(R6),ASIS     GET WHAT WE CAN\n         STH   R1,0(R4)           GIVE HIM THE LENGTH\n         SPACE 5\nIOX      EQU   *\nFINISH   SLL   R15,8(0) SAVE TGET RETURN CODE\n         OR    R15,R3    GET TPUT RETURN CODE\n         BR    R14                X\n         EJECT\n*\n*              SUBRTNS TO GET READ PARMS\n*\nREADSET  CLI   2(R9),C' '         INLEN PRESENT?\n         BE    TOL                NO\n         LA    R1,3               PARM 3 NEEDED\n         BAL   R2,FINDPARM        POINT R1 -> PARM 3\n         LH    R6,0(,R1)          R6 = INLEN\n         B     GIBA\nTOL      CLI   0(R9),C' '         OUTLEN?\n         BNE   GOL                YES\n         LA    R15,25             NO -> RC=25\n         BR    R14                X\nGOL      L     R6,4(,R11)         R6 -> OUTLEN\n         LH    R6,0(,R6)          R6 = OUTLEN\nGIBA     CLI   3(R9),C' '         INBUF?\n         BE    TOB                NO\n         LA    R1,4               PARM 4 REQ\n         BAL   R2,FINDPARM        R1 -> PARM 4\n         LR    R5,R1              R5 -> INBUF\n         BR    R7                 X\nTOB      CLI   1(R9),C' '         OUTBUF?\n         BNE   GOB                YES\n         LA    R15,27             NO -> RC=27\n         BR    R14                X\nGOB      L     R5,8(,R11)         R5 -> OUTBUF\n         BR    R7                 X\n         SPACE 3\n*\n*              RTN TO POINT R4 TO RETLEN PARM:\n*\nRETCK    CLI   4(R9),C' '         RETLEN?\n         BE    TIL                NO\n         LA    R1,5               GET P5\n         BAL   R2,FINDPARM        R1 -> P5\n         LR    R4,R1              R4 -> RETLEN\n         BR    R7                 X\nTIL      CLI   2(R9),C' '         INLEN?\n         BE    UOL                NO\n         LA    R1,3               GET P3\n         BAL   R2,FINDPARM        R1 -> P3\n         LR    R4,R1              R4 -> INLEN\n         BR    R7\nUOL      L     R4,4(,R11)         R4 -> OUTLEN\n         BR    R7\n         EJECT\n*\n*              PARSE I/O BUFFERS  SUBROUTINES:\n*\nDOPARS   CLI   5(R9),C'I'         IN ONLY?\n         BE    IPARS              YES\n         CLI   5(R9),C'U'         UNFORMATTED OPTION?\n         BE    IPARS              YES\n*\nOPARS    EQU   *\n*\n*              OUTPUT BUFFER PARSE SUBRTN GOES HERE:\n*\n         BAL   R7,WRITESET        R5->OUTBUF,R6=OUTLEN\n         LA    R1,6               REQ P6\n         BAL   R2,FINDPARM        R1->SCRUFF\n         LA    R8,0(,R1)          R8-> SCREEN BUFF  (MUST CLEAR HI BIT)\n         LR    R7,R8              R7-> SCREEN BUFF\n         LA    R3,1920(,R8)       R3-> SCREEN BUFF END(+1)\n         ICM   R15,15,=X'000000FF' INIT R15\n*\n*        SKIP  ESCAPE,CMD,WCC     IF PRESENT:\n*\n         CLI   0(R5),X'27'        ESC CHAR?\n         BE    ESC                YES\n         B     WCC                NO-> SKIP WCC\n*\n*        PICK  ROUTINE TO HANDLE  EACH BUFFER BYTE:\n*\nOPM      IC    R15,0(R5)          LOAD BYTE\n         CLI   0(R5),X'11'        SBA CHAR?\n         BE    OSBA               YES\n         CLI   0(R5),X'1D'        SF  CHAR?\n         BE    SF                 YES\n         CLI   0(R5),X'13'        IC  CHAR?\n         BE    IC                 YES\n         CLI   0(R5),X'05'        PT  CHAR?\n         BE    PT                 YES\n         CLI   0(R5),X'3C'        RA  CHAR?\n         BE    RA                 YES\n         CLI   0(R5),X'12'        EUA CHAR?\n         BE    EUA                YES\n         MVC   0(1,R7),0(R5)      MUST BE DATA -> MOVE IT\n         SLR   R15,R15            SAY NO ORDER THIS TIME\n         BAL   R2,BAC             BUFF ADDR CHECK\n         B     D1                 POINT PAST\n         EJECT\n*               OUTPUT BUFFER PARSE SUBRTN SUBRTNS:\n*\n*                                 COMMON EXITS:\n*\nD3       LA    R5,1(,R5)          R5=R5+1\n         SH    R6,=H'1'           R6=R6-1\nD2       LA    R5,1(,R5)          R5=R5+1\n         SH    R6,=H'1'           R6=R6-1\nD1       LA    R5,1(,R5)          R5=R5+1\n         SH    R6,=H'1'           R6=R6-1\n*\nBEC      SLL   R15,8              SAVE ORDER STATUS FOR PT\n         BP    OPM                CONTINUE IF NOT DONE\n         B     IPARS              CHECK FOR INPUT PARSE IF DONE HERE\n*\n*              COMMON SUB FUNCTIONS:\n*\nBAC      LA    R7,1(,R7)          R7=R7+1  UPDATE BUFFER DATA PTR\n         CR    R7,R3              PAST END?\n         BLR   R2                 NO\n         LR    R7,R8              R7->START OF BUFF\n         BR    R2\n*\nSBA      IC    R1,1(,R5)          R1= 1ST ADDR BYTE\n         IC    R0,2(,R5)          R0= 2ND ADDR BYTE\n         N     R1,=X'0000003F'    STRIP HIGH BITS\n         N     R0,=X'0000003F'    STRIP HIGH BITS\n         SLL   R1,6               SHIFT HI ADDR LEFT 6 BITS\n         OR    R1,R0              PUT IT TOGETHER\n         LA    R7,0(R1,R8)        R7 -> NEW SCREEN BUF POSN\n         LA    R5,3(,R5)          R5= R5+3 PT PAST SBA SEQ\n         SH    R6,=H'3'           UPDATE LENGTH\n         BR    R2\n*\nGAB      LR    R1,R7              SAVE OUR SCREEN LOC\n         SLR   R15,R15            CLEAR R15 IN CASE NO ATTR EXISTS\nGL       LA    R1,1(,R1)          R1=R1+1\n         CR    R1,R3              PAST SCREEN?\n         BL    SIB                NO\n         LR    R1,R8              SET TO TOP\nSIB      CLI   0(R1),X'00'        NULL?\n         BE    GEC                YES\n         CLI   0(R1),X'C0'        SP ATTR?\n         BE    GA                 YES\n         TM    0(R1),X'C0'        OTHER ATTR?\n         BNZ   GEC                NO\nGA       IC    R15,0(R1)          GET ATTR IN R15\nGEC      CR    R1,R7              DONE?\n         BNE   GL                 NO -> GO ON\n         BR    R2                 YES -> EXIT\n         EJECT\n*\n*              INDIVIDUAL ORDER HANDLING ROUTINES:\n*\nESC      EQU   D3                 IGNORE COMMAND CODE\nWCC      EQU   D1                 SKIP WCC\nIC       EQU   D1                 IGNORE IC ORDER\n*\n*                                 SBA ORDER:\nOSBA     BAL   R2,SBA             DO AN SBA\n         B     BEC                CONTINUE\n*\n*                                 SF ORDER:\nSF       MVC   0(1,R7),1(R5)      MOVE ATTRIBUTE BYTE\n         NI    0(R7),X'3F'        STRIP HI 2 BITS TO SAY ATTR\n         CLI   0(R7),X'00'        WAS IT SPACE?\n         BNE   SFS1               NO -> ITS OK\n         OI    0(R7),X'C0'        TURN ON HI BITS TO DIFFER FROM NULL\nSFS1     BAL   R2,BAC             BUFFER ADDRESS CHECK\n         B     D2                 POINT PAST\n*\n*                                 RA ORDER:\nRA       LR    R4,R7              SAVE BUFF ADDR\n         BAL   R2,SBA             GET NEW\nRAL      MVC   0(1,R4),0(R5)      MOVE RA DATA CHAR\n         LA    R4,1(,R4)          R4=R4+1\n         CR    R4,R3              PAST SCREEN?\n         BL    CRAD               NO\n         LR    R4,R8              YES->RESET TO START\nCRAD     CR    R4,R7              RA DONE?\n         BNE   RAL                NO\n         B     D1                 YES->CONT\n         EJECT\n*              ORDER ROUTINES CONTINUED:\n*\n*\n*                                 EUA ORDER:\nEUA      LR    R4,R7              SAVE OUR SCREEN LOC\n         BAL   R2,GAB             FIND ITS ATTRIBUTES\n         BAL   R2,SBA             FIND END ADDR\nEL       CLI   0(R4),X'00'        NULL?\n         BE    IN                 YES\n         CLI   0(R4),X'C0'        SP ATTR?\n         BE    EA                 YES\n         TM    0(R4),X'C0'        OTHER ATTR?\n         BNZ   ENA                NO\nEA       IC    R15,0(R4)          GET ATTR IN R15\nIN       LA    R4,1(,R4)          R4=R4+1  PT PAST\n         CR    R4,R3              OFF SCREEN?\n         BL    EDC                NO->OK\n         LR    R4,R8              SET TO TOP\nEDC      CR    R4,R7              DONE?\n         BNE   EL                 NO\n         IC    R15,=X'12'         SAY EUA OCCURED\n         B     D1                 EXIT EUA\nENA      N     R15,=X'00000020'   PROTECTED FIELD?\n         BNZ   IN                 YES -> GO ON\n         NI    0(R4),X'00'        NO -> KILL DATA\n         B     IN                 GO ON\n*\n*                                 PT ORDER:\nPT       CLI   0(R7),X'00'        NULL?\n         BE    PTPP               YES\n         CLI   0(R7),X'C0'        SP ATTR?\n         BE    PTA                YES\n         TM    0(R7),X'C0'        OTHER ATTR?\n         BZ    PTA                YES\nPTD      N     R15,=X'0000FF00'   ORDER MODE?\n         BNZ   PTPP               YES\n         NI    0(R7),X'00'        NO -> KILL IT\nPTPP     BAL   R2,BAC             R7=R7+1 SCREEN ADDR UPDT\n         BL    PT                 GO ON IF STILL IN SCREEN\n         B     D1                 ELSE END\nPTA      ICM   R15,2,=X'05'       SAY ORDER MODE NOW\n         TM    0(R7),X'20'        PROTECTED FIELD?\n         BO    PTPP               YES->SKIP IT\n         BAL   R2,BAC             NO -> POINT AT DATA PART\n         IC    R15,0(,R5)         LOAD PT ORDER\n         B     D1                 EXIT PT\n         EJECT\n*\n*               INPUT BUFFER PARSE SUBRTN:\n*\n*\n*              GET SET:\n*\nIPARS    CLI   5(R9),C'O'         OUT ONLY?\n         BE    PARX               YES\n         BAL   R7,GIBA            R5->INPUT BUFF\n         BAL   R7,RETCK           R4->INPUT LEN\n         LH    R6,0(,R4)          R6 = INPUT LEN\n         LA    R1,6               REQ P6\n         BAL   R2,FINDPARM        R1 -> SCREEN BUFF\n         LA    R8,0(,R1)          R8 -> SCREEN BUFF (MUST CLEAR HI BIT)\n         LR    R7,R8              R7 -> OUT AREA\n         LR    R4,R7              R4 -> CURRENT FIELD\n         LA    R3,1920(,R8)       R3 -> END BUFF+1\n*\n*              PARSE IT:\n*\n         CH    R6,=H'3'           AID,CURR ONLY?\n         BE    PARX               YES -> SKIP PARSING IT\n         SH    R6,=H'3'           R6 = R6-3\n         LA    R5,3(,R5)          R5=R5+3 SKIP AID,CURR\n         CLI   0(R5),X'11'        SBA?\n         BE    ISBA               YES-> DON'T CHECK FIELD FILL 1ST TIME\n         EJECT\n*\n*              INPUT PARSE LOOP:\n*\nIPL      CLI   0(R5),X'11'        SBA?\n         BNE   MDB                NO -> MUST BE DATA\n*\n         CLI   5(R9),C'U'         UNFORMATTED?\n         BE    FF1X               YES-> DO NOT ERASE EOF THE FIELD\nFF1      CLI   0(R7),X'00'        NULL BYTE?\n         BE    FS1                YES\n         CLI   0(R7),X'C0'        SPACE ATTR?\n         BE    FF1X               YES\n         TM    0(R7),X'C0'        ATTR BYTE?\n         BZ    FF1X               YES-> GO ON\n         MVI   0(R7),X'00'        NO -> MAKE IT NULL\nFS1      BAL   R2,BAC             BUFF OK?\n         CR    R7,R4              DONE HERE?\n         BNE   FF1                MORE?\nFF1X     EQU   *                  END-OF-FIELD\n*\nISBA     BAL   R2,SBA             YES -> DO IT\n         LR    R4,R7              R4 -> CURRENT FIELD\n*                                                                 WDPSC\n*              CODE TO SET MDT FOR MODIFIED FIELDS:               WDPSC\n*                                                                 WDPSC\n         BCTR  R7,R0                    R7=R7-1                   WDPSC\n         CR    R7,R8                    R7<R8=SCREEN START?       WDPSC\n         BNL   MDTCHK                   NO->CHK ATTR              WDPSC\n         LA    R7,1919(,R8)             R7->END OF SCREEN         WDPSC\nMDTCHK   CLI   0(R7),X'00'              NULL?                     WDPSC\n         BE    NMDT               YES\n         CLI   0(R7),X'C0'        SPACE ATTR?\n         BE    SMDT               YES\n         TM    0(R7),X'C0'        ATTR BYTE?\n         BNZ   NMDT               NO -> GO ON\nSMDT     OI    0(R7),X'01'              SET MDT ON                WDPSC\n         NI    0(R7),X'3F'              MAKE SURE STILL ATTR      WDPSC\nNMDT     LR    R7,R4                    RESET R7                  WDPSC\n         LTR   R6,R6                    RESET CC                  WDPSC\n*                                                                 WDPSC\n         BP    IPL                CONTINUE\n         B     FFNF                     FINAL FIELD NULL FILL\n         EJECT\n*                                                                 WDPSC\n*              CODE TO MOVE A DATA BYTE TO SCRUFF:                WDPSC\n*                                                                 WDPSC\nMDB      MVC   0(1,R7),0(R5)            MOVE DATA\n         BAL   R2,BAC             BUFFER ADDR CHECK\n         LA    R5,1(,R5)          R5 = R5+1\nBLOK     BCT   R6,IPL             LOOP THE LOOP\n*                                                                 WDPSC\n*              CODE TO CLEAR TO END OF FINAL FIELD IF NEEDED:     WDPSC\n*                                                                 WDPSC\nFFNF     CLI   5(R9),C'U'               UNFORMATTED?\n         BE    FF2X               YES-> DO NOT PAD\nFF2      CLI   0(R7),X'00'        NULL BYTE?\n         BE    FS2                YES\n         CLI   0(R7),X'C0'        SPACE ATTR?\n         BE    FF2X               YES\n         TM    0(R7),X'C0'        ATTR BYTE?\n         BZ    FF2X               YES-> GO ON\n         MVI   0(R7),X'00'        NO -> MAKE IT NULL\nFS2      BAL   R2,BAC             BUFF OK?\n         CR    R7,R4              DONE HERE?\n         BNE   FF2                MORE?\nFF2X     EQU   *                  NOMORE.\n         SPACE\n*\n*              RETURN FROM PARSE  TO MAINLINE\n*\nPARX     SLR   R15,R15            RC=0\n         BR    R14\n         EJECT\n*\n*              SUBRTN TO LOAD PTR TO A GIVEN PARM:\n*\nFINDPARM EQU   *\n         LR    R15,R9             R15=R9\n         LR    R0,R1              R0=R1\n         SLR   R1,R1              R1=0\nFL       BCT   R0,PC              THERE YET?\n         SLL   R1,2               R1=R1*4   YES\n         L     R1,4(R1,R11)       R1=4+R1+R11 -> PARM DESIRED\n         BR    R2                 RET\n*\nPC       CLI   0(R15),C' '        PARM HERE?\n         LA    R15,1(,R15)        R15=R15+1\n         BE    FL                 NO PARM\n         LA    R1,1(,R1)          YES -> R1=R1+1 COUNT IT\n         B     FL\n         EJECT\n*\n*              STATIC DATA:\n*\nPARMPARM EQU   *                  PSEUDO PARMS\n         DC    CL8'YY    '\n         DC    CL8'YY  Y '\n         DC    CL8'YYYY  '\n         DC    CL8'YYYYY '\n         LTORG\n         REGEQU\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "GETDSCB1": {"ttr": 20225, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x00\\x7f\\x00\\x88\\x00\\x7f\\x12\\x00\\x00\\xe7\\x00\\xe7\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf2\\xf7\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-01-07T00:00:00", "modifydate": "1988-01-07T12:00:00", "lines": 231, "newlines": 231, "modlines": 0, "user": "FILE270"}, "text": "000010 ID DIVISION.\n000020 PROGRAM-ID.     GETDSCB1.\n000030 AUTHOR.         JEFF SPREHN.\n000040     EJECT\n000050 ENVIRONMENT DIVISION.\n000060 CONFIGURATION SECTION.\n000070 SOURCE-COMPUTER. IBM-370.\n000080 OBJECT-COMPUTER. IBM-370.\n000090 INPUT-OUTPUT SECTION.\n000100\n000110 FILE-CONTROL.\n000120\n000130     SELECT  OUTPUT-FILE         ASSIGN UT-S-OUTPUT.\n000140     EJECT\n000150 DATA DIVISION.\n000160\n000170 FILE SECTION.\n000180\n000190 FD  OUTPUT-FILE\n000200     LABEL RECORDS ARE   STANDARD\n000210     RECORDING MODE IS   F\n000220     RECORD CONTAINS     70 CHARACTERS\n000230     BLOCK CONTAINS      0 RECORDS\n000240     DATA RECORDS IS     OUTPUT-REC.\n000250\n000260 01  OUTPUT-REC                              PIC X(70).\n000270     EJECT\n000280 WORKING-STORAGE SECTION.\n000281 77  HOLD-JOBNAME                            PIC X(8).\n000290\n000300 01  INDSN                                   PIC X(44).\n000310 01  INVOL                                   PIC X(6).\n000320 01  VALID-SWITCH                            PIC X(3).\n000330 01  ERRMSG                                  PIC X(30).\n000340 01  DSCB1.\n000390     05  FILLER                              PIC X(17).\n000400     05  LAST-ACCESSOR                       PIC X(08).\n000402     05  FILLER                              PIC X(06).\n000403     05  LAST-ACCESS-DATE.\n000404         10  BYTE-1                          PIC X.\n000405         10  BYTES-2-3                       PIC XX.\n000410     05  FILLER                              PIC X(106).\n000420\n000430 01  PRINT-LINE-A.\n000440     05  FILLER                              PIC X(32)  VALUE\n000450         ' *   THE DATE OF LAST ACCESS IS '.\n000460     05  LAST-ACCESS-DATE.\n000470         10  MONTH                           PIC XX.\n000480         10  FILLER  VALUE '-'               PIC X.\n000490         10  DAYY                            PIC XX.\n000500         10  FILLER  VALUE '-'               PIC X.\n000510         10  YEAR                            PIC XX.\n000520     05  FILLER      VALUE SPACES            PIC X(29).\n000521     05  FILLER      VALUE '*'               PIC X.\n000530\n000540 01  PRINT-LINE-B.\n000550     05  FILLER                              PIC X(49)  VALUE\n000560         ' *   THE JOBNAME OF THE JOB THAT LAST ACCESSED TH'.\n000561     05  FILLER                              PIC X(10)  VALUE\n000562         'E FILE IS '.\n000570     05  LAST-ACCESSOR                       PIC X(08).\n000580     05  FILLER      VALUE SPACES            PIC XX.\n000581     05  FILLER      VALUE '*'               PIC X.\n000590\n000600 01  PRINT-LINE-C.\n000610     05  FILLER                              PIC X(15)  VALUE\n000620         ' *   ERROR ==> '.\n000630     05  ERROR-MESSAGE                       PIC X(30).\n000640     05  FILLER      VALUE SPACES            PIC X(24).\n000641     05  FILLER      VALUE '*'               PIC X.\n000650\n000651 01  ASTERISK-SEPARATOR-LINE.\n000652     05  FILLER   VALUE ' *'                 PIC XX.\n000655     05  FILLER      VALUE SPACES            PIC X(67).\n000656     05  FILLER      VALUE '*'               PIC X.\n000657\n000658 01  ALL-ASTERISKS-LINE.\n000659     05  FILLER   VALUE ' *'                 PIC XX.\n000660     05  FILLER      VALUE ALL '*'           PIC X(67).\n000661     05  FILLER      VALUE '*'               PIC X.\n000662\n000663 01  YEAR-OF-LAST-ACCESS.\n000670     05  FILLER   VALUE LOW-VALUE            PIC X.\n000680     05  LAST-ACCESS-YEAR                    PIC X.\n000690\n000700 01  REDEF-YR-OF-LAST-ACCESS\n000710       REDEFINES YEAR-OF-LAST-ACCESS         PIC S9(2) COMP.\n000720\n000730 01  DAY-OF-LAST-ACCESS.\n000740     05  LAST-ACCESS-DAY                     PIC XX.\n000750\n000760 01  REDEF-DAY-OF-LAST-ACCESS\n000770       REDEFINES DAY-OF-LAST-ACCESS         PIC S9(3) COMP.\n000780\n000790 01  LAST-ACCESS-DATE-DISPLAY.\n000800     05  LAST-ACCESS-YEAR                    PIC 9(2).\n000810     05  LAST-ACCESS-DAY                     PIC 9(3).\n000820\n000830 01  JTOSCONV-I-O-AREA.\n000840     05  FILLER                              PIC X(8).\n000850     05  STANDARD-DATE.\n000860         10  MONTH                           PIC XX.\n000870         10  DAYY                            PIC XX.\n000880         10  YEAR                            PIC XX.\n000890     05  JULIAN-DATE                         PIC X(5).\n000900     05  INVALID-INPUT-DATE                  PIC X(3).\n000910\n000920     EJECT\n000930 LINKAGE SECTION.\n000940\n000950 01  PARM-AREA.\n000960     05  PARM-CNT                            PIC S9(4) COMP.\n000970     05  PARM-VOL                            PIC X(6).\n000980     05  FILLER                              PIC X.\n000990     05  PARM-DSN                            PIC X(44).\n001000\n001010     EJECT\n001020 PROCEDURE DIVISION USING PARM-AREA.\n001030\n001040 0000-OPEN.\n001050\n001060     OPEN  OUTPUT  OUTPUT-FILE.\n001070\n001080     MOVE PARM-DSN  TO INDSN.\n001090     MOVE PARM-VOL  TO INVOL.\n001100\n001110     CALL 'PASSDSCB' USING INDSN INVOL VALID-SWITCH ERRMSG DSCB1.\n001120\n001130     IF VALID-SWITCH = 'YES'\n001131         NEXT SENTENCE\n001270     ELSE\n001290         MOVE SPACES TO OUTPUT-REC\n001300         PERFORM 5000-WRITE THRU 5999-EXIT-WRITE\n001302         MOVE ALL-ASTERISKS-LINE TO OUTPUT-REC\n001303         PERFORM 5000-WRITE THRU 5999-EXIT-WRITE\n001304         MOVE ASTERISK-SEPARATOR-LINE TO OUTPUT-REC\n001305         PERFORM 5000-WRITE THRU 5999-EXIT-WRITE\n001310         MOVE ERRMSG TO ERROR-MESSAGE OF PRINT-LINE-C\n001320         MOVE PRINT-LINE-C TO OUTPUT-REC\n001330         PERFORM 5000-WRITE THRU 5999-EXIT-WRITE\n001331         MOVE ASTERISK-SEPARATOR-LINE TO OUTPUT-REC\n001332         PERFORM 5000-WRITE THRU 5999-EXIT-WRITE\n001334         MOVE ALL-ASTERISKS-LINE TO OUTPUT-REC\n001335         PERFORM 5000-WRITE THRU 5999-EXIT-WRITE\n001350         GO TO 9999-QUIT.\n001351\n001352     MOVE SPACES TO OUTPUT-REC.\n001353     PERFORM 5000-WRITE THRU 5999-EXIT-WRITE.\n001354     MOVE ALL-ASTERISKS-LINE TO OUTPUT-REC.\n001355     PERFORM 5000-WRITE THRU 5999-EXIT-WRITE.\n001356     MOVE ASTERISK-SEPARATOR-LINE TO OUTPUT-REC.\n001357     PERFORM 5000-WRITE THRU 5999-EXIT-WRITE.\n001358     PERFORM 6000-CONVERT-LAST-ACCESS-DATE\n001359        THRU 6999-EXIT.\n001360     MOVE PRINT-LINE-A TO OUTPUT-REC.\n001361     PERFORM 5000-WRITE THRU 5999-EXIT-WRITE.\n001362     MOVE ASTERISK-SEPARATOR-LINE TO OUTPUT-REC.\n001363     PERFORM 5000-WRITE THRU 5999-EXIT-WRITE.\n001364     MOVE LAST-ACCESSOR OF DSCB1\n001366       TO HOLD-JOBNAME.\n001367\n001368     TRANSFORM HOLD-JOBNAME\n001369        FROM\n001370            '0123456789$#@ABCDEFGHIJKLMNOPQRSTUVWXYZ|'\n001371          TO\n001372            '||||||||||||||||||||||||||||||||||||||| '.\n001373\n001374     IF HOLD-JOBNAME = '||||||||'\n001375         MOVE LAST-ACCESSOR OF DSCB1\n001376           TO LAST-ACCESSOR OF PRINT-LINE-B\n001377     ELSE\n001378         MOVE 'UNKNOWN '\n001379           TO LAST-ACCESSOR OF PRINT-LINE-B.\n001380\n001383     MOVE PRINT-LINE-B TO OUTPUT-REC.\n001384     PERFORM 5000-WRITE THRU 5999-EXIT-WRITE.\n001385     MOVE ASTERISK-SEPARATOR-LINE TO OUTPUT-REC.\n001386     PERFORM 5000-WRITE THRU 5999-EXIT-WRITE.\n001387     MOVE ALL-ASTERISKS-LINE TO OUTPUT-REC.\n001388     PERFORM 5000-WRITE THRU 5999-EXIT-WRITE.\n001389     GO TO 9999-QUIT.\n001390\n001391 5000-WRITE.\n001392\n001393     WRITE OUTPUT-REC.\n001400\n001410 5999-EXIT-WRITE.\n001420     EXIT.\n001430\n001440 6000-CONVERT-LAST-ACCESS-DATE.\n001450\n001460     MOVE BYTE-1 OF LAST-ACCESS-DATE OF DSCB1\n001470       TO LAST-ACCESS-YEAR OF YEAR-OF-LAST-ACCESS.\n001480\n001490     MOVE REDEF-YR-OF-LAST-ACCESS\n001500       TO LAST-ACCESS-YEAR OF LAST-ACCESS-DATE-DISPLAY.\n001510\n001520     MOVE BYTES-2-3 OF LAST-ACCESS-DATE OF DSCB1\n001530       TO LAST-ACCESS-DAY OF DAY-OF-LAST-ACCESS.\n001540\n001550     MOVE REDEF-DAY-OF-LAST-ACCESS\n001560       TO LAST-ACCESS-DAY OF LAST-ACCESS-DATE-DISPLAY.\n001570\n001580     MOVE LAST-ACCESS-DATE-DISPLAY\n001590       TO JULIAN-DATE OF JTOSCONV-I-O-AREA.\n001600\n001610     CALL 'JTOSCONV' USING JTOSCONV-I-O-AREA.\n001620\n001630     IF INVALID-INPUT-DATE OF JTOSCONV-I-O-AREA = 'YES'\n001640         MOVE '??' TO MONTH OF LAST-ACCESS-DATE OF PRINT-LINE-A\n001650         MOVE '??' TO DAYY  OF LAST-ACCESS-DATE OF PRINT-LINE-A\n001660         MOVE '??' TO YEAR  OF LAST-ACCESS-DATE OF PRINT-LINE-A\n001670         GO TO 6999-EXIT.\n001680\n001690     MOVE MONTH OF STANDARD-DATE OF JTOSCONV-I-O-AREA\n001700       TO MONTH OF LAST-ACCESS-DATE OF PRINT-LINE-A.\n001710     MOVE DAYY  OF STANDARD-DATE OF JTOSCONV-I-O-AREA\n001720       TO DAYY  OF LAST-ACCESS-DATE OF PRINT-LINE-A.\n001730     MOVE YEAR  OF STANDARD-DATE OF JTOSCONV-I-O-AREA\n001740       TO YEAR  OF LAST-ACCESS-DATE OF PRINT-LINE-A.\n001750\n001760 6999-EXIT.\n001770     EXIT.\n001780\n001790 9999-QUIT.\n001800\n001810     CLOSE    OUTPUT-FILE.\n001820\n001830     MOVE 0 TO RETURN-CODE.\n001840\n001850     STOP RUN.\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "GETMY": {"ttr": 20230, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x00\\x7f\\x00\\x88\\x00\\x7f\\x12\\x00\\x01\\x01\\x01\\x01\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf2\\xf7\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-01-07T00:00:00", "modifydate": "1988-01-07T12:00:00", "lines": 257, "newlines": 257, "modlines": 0, "user": "FILE270"}, "text": "*          DATA SET 761KKGETMY AT LEVEL 002 AS OF 10/04/83\nGETMY    TITLE ' - CP TO RETURN USER INFO TO A CLIST'\n*                                 WRITTEN BY KERMIT KISER\n*              V1M1 - MODIFIED NOV 1982 TO ADD TERMID OPERAND\n*              V1M2 - MODIFIED MAR 1983 TO ADD SYSID  OPERAND\n*              V1M3 - MODIFIED APR 1983 TO ADD ACFUID  OPERAND\n*              V1M4 - MODIFIED DEC 1983 TO USE NEW SETVAR SUBROUTINE\n*\n*  GETMY IS A TSO COMMAND WHICH RETURNS INFORMATION\n*        REQUESTED BY A CLIST IN CLIST VARIABLES.\n*        THE INFORMATION RETURNED IS INSTALLATION DEPENDENT\n*        AND THE CODE WILL NEED TO BE MODIFIED TO RETURN THE DATA\n*        WHICH IS USEFUL FOR YOUR INSTALLATION.\n*\n*//*\n*//* A TSO COMMAND USES SETVAR  AS FOLLOWS:\n*//*\n*//*     LINK  EP=SETVAR ,(UPT,ECT,ECB,UPLIST)                 V1M4\n*//*\n*//*          UPT = USER PROFILE TABLE       (FROM CPPL)\n*//*          ECT = ENVIRONMENT CONTROL TABLE   \"   \"\n*//*          ECB = COMMAND PROCESSOR ECB\n*//*          UPLIST = A FOUR WORD BLOCK AS BELOW:\n*//*\n*//*\n*//*  UPLIST  DS  0XL16\n*//*  LOCPTR  DS  AL4         PTR TO VARIABLE NAME\n*//*  LOCLEN  DS  F           LENGTH OF VARIABLE NAME\n*//*  VALPTR  DS  A           PTR TO DATA VALUE\n*//*  VALLEN  DS  F           LENGTH OF DATA VALUE\n*//*\n*//* EXAMPLE : SET &VAR = &STR(MYDATA)\n*//*    WOULD NEED THE FOLLOWING CONTROL BLOCK PASSED TO SETVAR :\n*//*\n*//*  UPLIST  DS  0XL16\n*//*  LOCPTR  DC  A(=C'VAR')    PTR TO VARIABLE NAME\n*//*  LOCLEN  DC  F'3'          LENGTH OF VARIABLE NAME\n*//*  VALPTR  DC  A(=C'MYDATA') PTR TO DATA VALUE\n*//*  VALLEN  DC  F'6'          LENGTH OF DATA VALUE\n*//*\nGETMY    ENTERR LEVEL=V1M4\n         LR    R11,R1                   R11->CPPL\n         USING CPPL,R11\n         EJECT\n*\n*              GETMY CONTROL ROUTINE:\n*\nSA       BAL   R14,PB                   PARSE THE INPUT BUFFER\n*\nS1       BAL   R14,INITLIST             BUILD PARMLIST FOR IKJUPDT\n*\nS2       BAL   R14,SETPROG              SET CLIST VAR PROG\n*\nS3       BAL   R14,SETSYS               SET CLIST VAR SYS\n*\nS4       BAL   R14,SETACCT              SET CLIST VAR ACCT\n*\nS5       BAL   R14,SETTERM              SET CLIST VAR TERMID\n*\nS6       BAL   R14,SETSYSID             SET CLIST VAR SYSID\n*\nS7       BAL   R14,SETACFID             SET CLIST VAR ACFUID\n         EJECT\n         LEAVER\n         EJECT\nPB       ST    R14,L1LS\n         PARSEKMD WORK=FASTAREA\n         SPACE 2\n         L     R14,L1LS\n         BR    R14\n         EJECT\n*\n*              BUILD UPDTLIST (IKJUPDT PARM LIST)\nINITLIST ST    R14,L1LS\n         MVC   UPDTUPT,CPPLUPT          UPT\n         MVC   UPDTECT,CPPLECT          ECT\n         LA    R9,ECB\n         ST    R9,UPDTECB               ECB\n         LA    R8,UPLIST\n         ST    R8,UPDTUPL               UPLIST\n         L     R14,L1LS\n         BR    R14\n         EJECT\n*              BUILD UPLIST (UPDATE PARM LIST) FOR PROG AND CALL UPDT:\nSETPROG  ST    R14,L1LS\n         TM    FLAG,X'80'               PROG REQUESTED?\n         BNOR  R14                      NO\n         BAL   R14,FINDPROG             LOCATE SYS AND PROG\n         LA    R9,=C'PROG'\n         ST    R9,LOCPTR                VARIABLE NAME\n         MVC   LOCLEN,=F'4'             VAR NAME LEN\n         ST    R5,VALPTR                VALUE LOCATION\n         MVC   VALLEN,=F'20'            VALUE LENGTH\n         LA    R1,UPDTLIST              R1->IKJUPDT PARM LIST\n         LINK  EP=SETVAR                DO THE UPDATE              V1M4\n         L     R14,L1LS\n         BR    R14\n         EJECT\n*              BUILD UPLIST (UPDATE PARM LIST) FOR SYS AND CALL UPDT:\nSETSYS   ST    R14,L1LS\n         TM    FLAG,X'20'               SYS REQUESTED?\n         BNOR  R14                      NO\n         BAL   R14,FINDPROG             LOCATE SYS AND PROG\n         LA    R9,=C'SYS'\n         ST    R9,LOCPTR                VARIABLE NAME\n         MVC   LOCLEN,=F'3'             VAR NAME LEN\n         LA    R7,3(,R7)                R7->SYS NO IN USE NOW\n         ST    R7,VALPTR                VALUE LOCATION\n         MVC   VALLEN,=F'2'             VALUE LENGTH\n         LA    R1,UPDTLIST              R1->IKJUPDT PARM LIST\n         LINK  EP=SETVAR                DO THE UPDATE              V1M4\n         L     R14,L1LS\n         BR    R14\n         EJECT\n*              BUILD UPLIST (UPDATE PARM LIST) FOR ACCT AND CALL UPDT:\nSETACCT  ST    R14,L1LS\n         TM    FLAG,X'40'               ACCT REQUESTED?\n         BNOR  R14                      NO\n         BAL   R14,FINDPROG             LOCATE SYS AND PROG\n         LA    R9,=C'ACCT'\n         ST    R9,LOCPTR                VARIABLE NAME\n         MVC   LOCLEN,=F'4'             VAR NAME LEN\n         LA    R6,25(,R5)               R6->ACCT NO IN USE\n         MVC   ACCTVAL(9),0(R6)         GET ACCT\n         MVI   ACCTVAL+4,C','           FOR FUN\n         LA    R6,ACCTVAL\n         ST    R6,VALPTR                ACCT VALUE PTR\n         MVC   VALLEN,=F'9'             ACCT VALUE LEN\n         LA    R1,UPDTLIST              R1->IKJUPDT PARM LIST\n         LINK  EP=SETVAR                DO THE UPDATE              V1M4\n         L     R14,L1LS\n         BR    R14\n         EJECT\n*              BUILD UPLIST (UPDATE PARM LIST) FOR TERMID & CALL UPDT:\nSETTERM  ST    R14,L1LS\n         TM    FLAG,X'10'             TERMID REQUESTED?\n         BNOR  R14                      NO\n         L     R10,CPPLPSCB       R10->PSCB\n         L     R10,68(,R10)       R10->PSCBX\n         LA    R9,=C'TERMID'\n         ST    R9,LOCPTR                VARIABLE NAME\n         MVC   LOCLEN,=F'6'             VAR NAME LEN\n         LA    R6,42(,R10)        R6->TERMID FIELD\n         ST    R6,VALPTR          TERMID VALUE PTR\n         MVC   VALLEN,=F'8'       TERMID VALUE LEN\n         LA    R1,UPDTLIST              R1->IKJUPDT PARM LIST\n         LINK  EP=SETVAR                DO THE UPDATE              V1M4\n         L     R14,L1LS\n         BR    R14\n         EJECT\n*              BUILD UPLIST (UPDATE PARM LIST) FOR SYSID & CALL UPDT:\nSETSYSID ST    R14,L1LS\n         TM    FLAG,X'08'             SYSID REQUESTED?\n         BNOR  R14                      NO\n         LA    R9,=C'SYSID'       VARIABLE NAME\n         ST    R9,LOCPTR          R9->  VARIABLE NAME\n         MVC   LOCLEN,=F'5'             VAR NAME LEN\n*              FIND THE SYSTEM ID :\n         L     R7,CVTPTR\n         USING CVT,R7\n         L     R6,CVTSMCA\n         USING SMCABASE,R6\n         L     R6,SMCASID\n         STCM  R6,15,SYSTEMG\n         DROP  R6,R7\n         LA    R6,SYSTEMG         R6->SYSID FIELD\n         ST    R6,VALPTR          SYSID VALUE PTR\n         MVC   VALLEN,=F'4'       SYSID VALUE LEN\n         LA    R1,UPDTLIST              R1->IKJUPDT PARM LIST\n         LINK  EP=SETVAR                DO THE UPDATE              V1M4\n         L     R14,L1LS\n         BR    R14\n         EJECT\n*              BUILD UPLIST (UPDATE PARM LIST) FOR ACFUID & CALL UPDT:\nSETACFID ST    R14,L1LS\n         TM    FLAG,X'04'            ACFUID REQUESTED?\n         BNOR  R14                      NO\n         LA    R9,=C'ACFUID'      VARIABLE NAME\n         ST    R9,LOCPTR          R9->  VARIABLE NAME\n         MVC   LOCLEN,=F'6'             VAR NAME LEN\n*              FIND THE ACFUID    :\n         LA    R7,ACFFLD\n         ST    R7,ACFPTR\n         MVC   ACFFLD(2),=H'24'   SET FIELD LENGTH\n         LA    R1,ACFPTR\n         L     R15,=V(GETMYUID)         CALL LINDA'S ACF2 FINDER\n         LTR   R15,R15                 DO WE HAVE IT?\n         BZ    ACFX                    NO-> CANNOT DO THIS THEN\n         BALR  R14,R15                  CALL LINDA'S ACF2 FINDER\n*              PASS THE ACFUID    :\n         LA    R6,ACFFLD+2              R6->ACFUID FIELD\n         ST    R6,VALPTR                ACFUID VALUE PTR\n         MVC   VALLEN,=F'24'            ACFUID VALUE LEN\n         LA    R1,UPDTLIST              R1->IKJUPDT PARM LIST\n         LINK  EP=SETVAR                DO THE UPDATE              V1M4\nACFX     L     R14,L1LS\n         BR    R14\n         EJECT\n*              FIND PROG AND SYS:\nFINDPROG L     R5,540                   R5->TCB\n         L     R5,180(,R5)              R5->JCSB\n         L     R5,260(,R5)              R5->JCT\n         LA    R7,24(,R5)               R7->JOBNAME\n         ICM   R5,7,56(R5)              R5->ACT\n         LA    R5,24(,R5)               R5-> PROG NAME FIELD\n         BR    R14\n         EJECT\nSTATWORK EQU   *\n         SPACE\nOPLIST   OPERLIST OPER1,OPER2,OPER3,OPER4,OPER5,OPER6\nOPER1    OPER  PROG,X'8000'\nOPER2    OPER  ACCT,X'4000'\nOPER3    OPER  SYS,X'2000'\nOPER4    OPER  TERMID,X'1000'\nOPER5    OPER  SYSID,X'0800'\nOPER6    OPER  ACFUID,X'0400'\n         LTORG\n         EJECT\nWORKAREA DSECT\nSAVEAREA DS    18F\nL1LS     DS    F\nL2LS     DS    F\nL3LS     DS    F\n*\nUPDTLIST DS    0F\nUPDTUPT  DS    F\nUPDTECT  DS    F\nUPDTECB  DS    F\nUPDTUPL  DS    F\n*\nUPLIST   DS    0F\nLOCPTR   DS    AL4\nLOCLEN   DS    FL4\nVALPTR   DS    AL4\nVALLEN   DS    FL4\n*\nSYSTEMG  DC    C'    '\nECB      DS    F\nACCTVAL  DS    CL9\n         EJECT\n*\nACFPTR   DS    F\nACFFLD   DS    H,CL24\n*\nFLAG     DS    F\n         SPACE\n         KPPL\nFASTAREA DS    XL512\n         SPACE 2\nWORKLEN  EQU   *-WORKAREA\n         EJECT\n         IKJCPPL\n         EJECT\n         PRINT  OFF\n         CVT     DSECT=YES\n         IEESMCA ,\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "GETMY$": {"ttr": 20235, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x00\\x7f\\x00\\x88\\x00\\x7f\\x12\\x00\\x00*\\x00*\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf2\\xf7\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-01-07T00:00:00", "modifydate": "1988-01-07T12:00:00", "lines": 42, "newlines": 42, "modlines": 0, "user": "FILE270"}, "text": "1                                                        GETMY.1\n                                                         03/16/83\n\n\n  COMMAND NAME:       GETMY\n  AUTHOR:             Kermit Kiser\n  AGENCY:             WDPSC\n  FUNCTION:           The GETMY command is for use within CLISTs to\n                      obtain  information   which  is   useful  for\n                      building  JOB  cards and  SETUP  cards.   The\n                      fields which can be requested are the account\n                      number, the system number  and the programmer\n                      name field of the user.\n\n  Syntax -\n  _________________________________________________________________\n       Command        Operands\n  -----------------------------------------------------------------\n       GETMY          PROG  SYS  ACCT  TERMID\n  -----------------------------------------------------------------\n\n  Operands:  At least one of the following are required:\n\n    PROG     - Returns programmer name field to CLIST variable &PROG.\n    SYS      - Returns system number to CLIST variable &SYS.\n    ACCT     - Returns account number to CLIST variable &ACCT.\n    TERMID   - Returns your 4 byte terminal id\n\n  Example:\n    Assume you have logged on to TSO with the following command:\n       LOGON XXSN111/PASSWORD ACCT(2222$33-S) PROG(MYNAM 4444 T)\n    You then execute a CLIST containing the following command:\n       GETMY PROG SYS ACCT\n\n    After the CLIST uses that command it can access these variables:\n       &PROG which contains \"MYNAM 4444 T       \" (full 20 char field);\n       &SYS  which contains \"SN\" (two char field);\n       &ACCT which contains \"2222,33-S\" (nine char field).\n\n\n\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "GETSCRN": {"ttr": 20237, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x00\\x7f\\x00\\x88\\x00\\x7f\\x12\\x00\\x00\\xb0\\x00\\xb0\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf2\\xf7\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-01-07T00:00:00", "modifydate": "1988-01-07T12:00:00", "lines": 176, "newlines": 176, "modlines": 0, "user": "FILE270"}, "text": "*          DATA SET 761KKGETSC AT LEVEL 001 AS OF 10/13/80\n         TITLE 'GETSCRN - GENERAL PURPOSE 3270 SCREEN INPUT RTN'\nGETSCRN  ENTERR\n         LR    R11,R1                   R11-> PARM LIST\n*\n         EJECT\n*                                       VERSION 1 MOD 0\n***********************************************************************\n*\n*\n*              CALL FORMAT:\n*\n*\n*        CALL  'GETSCRN' USING DDNAME, MENUNAME, LENGTH, MENUAREA.\n*\n*\n*              DDNAME =  8 BYTE DDNAME FOR MENU (LOAD MODULE)\n*              MENUNAME = 8 BYTE NAME OF MENU (LOAD MODULE)\n*              LENGTH = 2 BYTE COMP FLD TO RECEIVE MENU LENGTH\n*              MENUAREA = AREA TO RECEIVE MENU BUFFER\n*                    (MUST BE LARGE ENOUGH FOR ANY MENU REQUESTED)\n*\n*\n*              RETURN CODES:  99 = BAD PARMS\n*                          OTHER = DDNAME NOT ALLOCATED OR\n*                                  DDNAME DID NOT OPEN  OR\n*                                  MENU NOT FOUND ,ETC.\n*\n*\n*\n*\n*\n***********************************************************************\n         EJECT\n***********************************************************************\n*\n*              MAINLINE CONTROL LOGIC:\n*\n***********************************************************************\n*\n         BAL   R14,INIT                 CHECK PARM LIST OK\n         LTR   R15,R15\n         BNZ   RETURN\n*\n*\n         BAL   R14,DDCHEK               GO CHECK DD PRESENT AND OPEN\n         LTR   R15,R15\n         BNZ   RETURN\n*\n         BAL   R14,FINDMENU             GO FIND MENU AND LENGTH\n         LTR   R15,R15\n         BNZ   RETURN\n*\n*\n         BAL   R14,MOVEMENU             GO GIVE HIM THE OUTPUT BUFFER\n*\n*\n         BAL   R14,TERM                 CLOSE THE MENU FILE\n         EJECT\nRETURN   LEAVER\n         SPACE 3\n         EJECT\nINIT     ST    R14,L1LS\n         SPACE\n*\n         TM    0(R11),X'80'\n         BNZ   PARMERR\n         L     R10,0(,R11)              R10->DDNAME\n         MVC   DDNAME,0(R10)            SAVE\n*\n         TM    4(R11),X'80'\n         BNZ   PARMERR\n         L     R9,4(,R11)               R9 ->MENUNAME\n         MVC   MENUNAME,0(R9)           SAVE\n*\n         TM    8(R11),X'80'\n         BZ    IX\n         SPACE\nPARMERR  LA    R15,99                   RC=99 IF BAD PARM LIST\n         SPACE\nIX       L     R14,L1LS\n         BR    R14                      RET\n         EJECT\nDDCHEK   ST    R14,L1LS\n         SPACE\n         MVC   DCB(DCBLEN),DCBPAT       INIT DCB\n         MVC   DCB+40(8),DDNAME         GET DDNAME\n*\n         DEVTYPE  DDNAME,DEVAREA,DEVTAB  DD HERE?\n         LTR   R15,R15                  FOUND IT?\n         BNZ   DDX                      NO\n         SPACE 3\n         OI    OPENL,X'80'              FIX VL FLAG\nDDNOPEN  OPEN  (DCB,INPUT),MF=(E,OPENL)    OPEN FOR INPUT\n         SPACE 2\nDDX      L     R14,L1LS\n         BR    R14                      YES\n         EJECT\nFINDMENU ST    R14,L1LS\n*\n         LOAD  EPLOC=MENUNAME,DCB=DCB        LOAD MENU FROM MENU LIB\n         LA    R1,0(,R1)                CLEAR HI BYTE\n         SLL   R1,3                     MULT BY 8\n         ST    R1,MODLEN                SAVE MODULE LENGTH\n         ST    R0,MODLOC                SAVE MODULE LOCATION\n         LR    R3,R0                    R3->MODULE\n         L     R2,=A(MENUPAT)           R2->MENU PAT\n         USING MENUPAT,R2\n         MVC   MENULIKE(48),MENUPAT     INIT MENU COMPARE\n         DROP  R2\n         MVC   MENULIKE+5(8),MENUNAME   GET NAME OK\n         CLC   MENULIKE(24),0(R3)       LIT1 THERE?\n         BNE   NOTLIT1                  NO->OTHER TYPE MENU\n*\nLLOOP    SH    R1,=H'4'                 GET OFFSET TO LENLIT\n         L     R5,0(R1,R3)              LOAD THE LENGTH           WDPSC\n         C     R5,=F'0'                 OK?                       WDPSC\n         BE    LLOOP                    NO->LINKEDITOR PADDED TO DBLWD\n         LR    R1,R5                    R1=CORRECT MENU LENGTH    WDPSC\n         LA    R3,LIT-BEGIN(,R3)        R3->LIT MENU\n*\nNOTLIT1  STH   R1,MENULEN               SAVE MENU LEN\n         ST    R3,MENULOC               SAVE MENU LOC\n*\n         L     R14,L1LS\n         BR    R14                      RET\n         EJECT\nMOVEMENU ST    R14,L1LS\n*\n         L     R4,MENULOC               R4->FROM ADDR\n         LH    R5,MENULEN               R5= MENU LEN\n         L     R6,12(,R11)              R6->MENU AREA\n         LR    R7,R5                    R7= MENU LEN\n         MVCL  R6,R4                    GIVE IT TO HIM\n*\n         L     R8,8(,R11)               R8->LENGTH FIELD\n         LH    R5,MENULEN               R5= MENU LEN\n         STH   R5,0(,R8)                GIVE HIM THE LENGTH\n*\n         L     R14,L1LS\n         BR    R14                      RET\n         EJECT\nTERM     ST    R14,L1LS\n*\n         CLOSE (DCB),MF=(E,OPENL)       CLOSE AUDIT FILE\n         SPACE\n         L     R14,L1LS\n         BR    R14                      EXIT\n         EJECT\nDCBPAT   DCB   DSORG=PO,MACRF=R\nDCBLEN   EQU   *-DCBPAT\n         LTORG\n         TITLE 'WORKAREA - WORK AREA FOR GETSCRN-RTN'\nWORKAREA DSECT\n         SPACE\nSAVEAREA DS    18F                      SAVE AREA\nL1LS     DS    F                        LEVEL 1 LINK REG SAVE\nL2LS     DS    F\nL3LS     DS    F\nDDNAME   DC    CL8' '\nMENUNAME DC    CL8' '\nMENULEN  DS    F\nMENULOC  DS    F\nMODLEN   DS    F\nMODLOC   DS    F\nMENULIKE DS    XL52\nDEVAREA  DS    6F\nOPENL    OPEN  (DCB,OUTPUT),MF=L\n         SPACE 3\nDCB      DCB   DSORG=PO,MACRF=R\n         SPACE 3\nWORKLEN  EQU   *-WORKAREA\n         EJECT\n         LIT1  MENUPAT\n         LIT2\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "HEXTRAN": {"ttr": 20484, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x00\\x7f\\x00\\x88\\x00\\x7f\\x12\\x00\\x00\\x81\\x00\\x81\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf2\\xf7\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-01-07T00:00:00", "modifydate": "1988-01-07T12:00:00", "lines": 129, "newlines": 129, "modlines": 0, "user": "FILE270"}, "text": "*          DATA SET 761KKHXTRN AT LEVEL 001 AS OF 06/07/78\n         TITLE 'HEXTRAN  -  SUBROUTINE FOR HEX TRANSLATIONS'\n* WRITTEN BY KERMIT KISER - WASHINGTON STATE DP SERVICE CENTER (WDPSC)\n*\nHEXTRAN  ENTERR\n         LR    R6,R1             SAVE PARM PTR\n         LM    R10,R11,0(R1)      R10,R11->FIRST TWO PARMS\n         TM    4(R1),X'80'        MORE PARMS?\n         BNO   VL1                YES\n         LA    R9,8               R9=8=DEFAULT CHAR LEN\n         B     CTH                CHAR TO HEX IS DEFAULT\n         EJECT\n*  PICK  UP  PARMS IF VARIABLE LENGTH LIST\nVL1      SLR   R15,R15            R15=0\n         SLR   R9,R9              R9=0\n         SLR   R8,R8              R8=0\n         L     R2,8(,R1)          R2->3RD PARM\nWHATPARM CLC   0(2,R2),=CL2'CT'   CHAR TO HEX?\n         BE    CKCTH              MAYBE\n         CLC   0(2,R2),=CL2'HT'   HEX TO CHAR\n         BNE   TRYLEN             NO\nCKHTC    CLI   2(R2),C'C'         HTC?  (VERIFY)\n         BNE   BADPARM            NO->BAD PARM\n         LA    R15,4              R15=4->SAVE HTC FLAG\n         B     MOREPARM           SEE IF MORE\nCKCTH    CLI   2(R2),C'H'         CTH?  (VERIFY)\n         BNE   BADPARM            NO->BAD PARM\n         B     MOREPARM           SEE IF MORE\nTRYLEN   LH    R9,0(,R2)          R9=LENGTH?\n         LTR   R9,R9              R9>0?\n         BNP   BADPARM            NO-> BAD PARM\n*\nMOREPARM LTR   R8,R8              R8=0?\n         BNZ   NOMORE             NO\n         LA    R8,4               YES->FLAG HERE\n         TM    8(R1),X'80'        3 PARMS?\n         BO    NOMORE             YES->NO MORE TO LOOK AT\n         L     R2,12(,R1)         R2->4TH PARM\n         B     WHATPARM           SEE WHAT IT IS\nNOMORE   LTR   R9,R9              R9=0?\n         BNZ   WHATTRAN           NO\n         LA    R9,8               YES->R9=8=DEFAULT LENGTH\nWHATTRAN LTR   R15,R15            HTC?\n         BNZ   HTC                YES-> DO THAT\n*\n         TITLE 'HEXTRAN  -  TRANSLATE ROUTINES'\nCTH      BAL   R14,LENCHK         R8=WORKING LENGTH\n         BCTR  R8,R0              R8=R8-1\n         EX    R8,VALCK           NON-HEX CHARS?\n         BNZ   BADCHAR            YES\n         EX    R8,MVCHAR          NO->PUT IN CHARAREA\n         EX    R8,TRANCHAR        MAKE IT PACKABLE\n         PACK  HEXAREA(5),CHARAREA(9)  PACK IT\n         SRL   R8,1(R0)           R8=R8/2\n         EX    R8,MVCHEX          GIVE HIM THE HEX\n         BAL   R14,DONECHK        DONE?\n         B     CTH                NO\n*\n*\nHTC      BAL   R14,LENCHK         GET LENGTH TO USE\n         LR    R7,R8              R7=R8\n         SRL   R7,1(R0)           R7=R7/2\n         EX    R7,MVHEX           GET THE HEX\n         UNPK  CHARAREA(9),HEXAREA(5)  UNPACK IT\n         TR    CHARAREA(8),TABLE3  TRANSLATE TO EBCDIC\n         BCTR  R8,R0              R8=R8-1\n         EX    R8,GIVECHAR        GIVE IT TO HIM\n         BAL   R14,DONECHK        DONE?\n         B     HTC                NO\n*\n         TITLE 'HEXTRAN  -  SUBROUTINES'\nLENCHK   CH    R9,=H'8'           LEN TO TRAN > 8 ?\n         BH    USE8               YES\n         LR    R8,R9              R8=R9\n         SLR   R9,R9              R9=0\n         BR    R14                RETURN\nUSE8     LA    R8,8               R8=8\n         SH    R9,=H'8'           R9=R9-8\n         BR    R14                RETURN\n*\nDONECHK  LTR   R9,R9              R9=0?\n         BZ    DONE               YES->MUST BE THRU\n         LA    R10,8(,R10)        R10=R10+8 NEXT CHUNK\n         LA    R11,4(,R11)        R11=R11+4  \"     \"\n         BR    R14                RETURN\n*\nVALCK    TRT   0(0,R10),TABLE1\nMVCHAR   MVC   CHARAREA(0),0(R10)\nTRANCHAR TR    CHARAREA(0),TABLE2\nMVCHEX   MVC   0(0,R11),HEXAREA\n*\nMVHEX    MVC   HEXAREA(0),0(R11)\nGIVECHAR MVC   0(0,R10),CHARAREA\n*\nBADPARM  LA    R15,4              R15=RC=4\n         B     RETURN             EXIT\n*\nBADCHAR  LA    R15,8              R15=RC=8\n         B     RETURN             EXIT\n*\n*                                   CALL IT A DAY\nDONE     SLR    R15,R15             RETURN CODE = 0\nRETURN   LEAVER\n*\n         TITLE 'HEXTRAN  -  CONSTANTS'\n*\nTABLE1   DC    256X'04'\n         ORG   TABLE1+X'C1'\n         DC    6X'00'\n         ORG   TABLE1+X'F0'\n         DC    10X'00'\n         ORG\n*\nTABLE2   DC    256X'00'\n         ORG   TABLE2+X'C1'\n         DC    X'FAFBFCFDFEFF'\n         ORG   TABLE2+X'F0'\n         DC    C'0123456789'\n         ORG\n         DC     C'0123456789ABCDEF'\nTABLE3   EQU   *-256\n         LTORG\n         TITLE 'HEXTRAN  -  DYNAMIC WORKAREA'\nWORKAREA DSECT\nSAVEAREA DS    18F                SAVEAREA\nCHARAREA DS    CL10\nHEXAREA  DS    XL6\nWORKLEN  EQU   *-WORKAREA\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "HEXTRAN$": {"ttr": 20487, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x00\\x7f\\x00\\x88\\x00\\x7f\\x12\\x00\\x007\\x007\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf2\\xf7\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-01-07T00:00:00", "modifydate": "1988-01-07T12:00:00", "lines": 55, "newlines": 55, "modlines": 0, "user": "FILE270"}, "text": "1                                                        HEXTRAN.1\n                                                         03/16/83\n\n\n  PROGRAM:       HEXTRAN\n  AUTHOR:        Kermit Kiser\n  AGENCY:        WDPSC\n  LANGUAGE:      Assembler\n  LOCATION:      WDPSC.SHARED.LOAD\n  FUNCTION:      Translate data from character coded hexadecimal to\n                 true hexadecimal or vice-versa.\n\n  RUN MODE:      Batch or interactive\n\n  HEXTRAN is a subroutine which can be called by a COBOL program to\n  translate  data   from  Character   coded  hexadecimal   to  true\n  Hexadecimal or the reverse.  For  example the two characters 'C1'\n  would translate to the one character  'A' (binary byte 1100 0001)\n  or vice-versa.\n\n  HEXTRAN can be called from a COBOL program as follows:\n\n       CALL 'HEXTRAN' USING chararea, hexarea, charlen, type.\n\n  chararea       -    area containing  or to contain  the character\n                      coded hexadecimal.\n\n  hexarea        -    area containing or to contain the hexadecimal\n                      value.\n\n  charlen        -    optional  binary  halfword giving  length  of\n                      chararea (even number of  bytes).  Hexarea is\n                      assumed  to be  half  the  size of  chararea.\n                      Eight  (8) bytes  is  the  default length  of\n                      chararea if charlen is not used.\n\n\n\n\n1                                                        HEXTRAN.2\n                                                         03/16/83\n\n\n  type      -    optional three character field with values 'HTC'\n                      for hex to character translation or 'CTH' for\n                      character to hex translation.\n                      Character to Hex is the default if this parm is not specif\n\n  NOTE:     HEXTRAN gives a return code of 4 if your parameters are\n            invalid and a return code of 8 if it finds invalid data\n            in chararea ('0123456789ABCDEF' are the only valid characters).\n\n\n\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "HOSEDWN$": {"ttr": 20489, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x00\\x7f\\x00\\x88\\x00\\x7f\\x12\\x00\\x00b\\x00b\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf2\\xf7\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-01-07T00:00:00", "modifydate": "1988-01-07T12:00:00", "lines": 98, "newlines": 98, "modlines": 0, "user": "FILE270"}, "text": "1                                                        HOSEDOWN.1\n                                                         06/25/82\n\n\n\n  CLIST:              HOSEDOWN\n  AUTHOR:             Jeff Sprehn\n  AGENCY:             WDPSC\n  FUNCTION:           De-allocate user SPF Dialog Manager libraries\n                      (undo what a previous FIREUP did).\n\n  TERMINAL TYPE:      3270-type only\n\n  The intended purpose of  this CLIST is to cancel the  effect of a\n  previous execution of FIREUP.\n\n  This CLIST will  de-allocate for you ANY OR ALL  of the following\n  SPF Dialog Manager libraries:\n       Panel library\n       Message library\n       Skeleton library\n       Table input library\n       Table output library\n       File tailoring output library\n       SPF link library\n\n  The format of this command is as follows:\n\n  HOSEDOWN  PANEL (dataset name of panel library) -\n            MESSAGE(dataset name of message library) -\n            SKELETON(dataset name of skeleton library) -\n            TABLEIN(dataset name of table input library) -\n            TABLEOUT(dataset name of table output library) -\n            TAILOUT(dataset name of file tailoring output) -\n            SPFLOAD(dataset name of SPF link library) -\n            PRINT(de-alloc notification)\n\n\n\n\n1                                                        HOSEDOWN.2\n                                                         06/25/82\n\n\n       'De-alloc notification' enter 'YES' if you wish the CLIST to\n       write  out  one   line  message  for  each   library  to  be\n       de-allocated stating  that the deallocation  was succcessful\n       or enter 'NO' if you DO NOT wish this to take place.\n\n  EXAMPLE #1\n  __________\n\n       De-allocate a  panel library called  \"AGNCY999.PANEL.LIB\", a\n       message  library called  \"AGNCY999.MESSAGE.LIB\",  and a  SPF\n       link library  called \"AGNCY999.SPF.LOADLIB\"  (User's PROFILE\n       PREFIX  is  XX00999  and user  DOES  NOT  want  deallocation\n       notification messages).\n\n       HOSEDOWN  PANEL('''AGNCY999.PANEL.LIB''') -\n                 MESSAGE('''AGNCY999.MESSAGE.LIB''') -\n                 SPFLOAD('''AGNCY999.SPF.LOADLIB''') -\n                 PRINT(NO)\n\n  EXAMPLE #2\n  __________\n\n       De-allocate a panel library  called \"XX00999.SPF.PANELIB\", a\n       message library called \"XX00999.SPF.MSGLIB\",  and a skeleton\n       library called \"XX00999.SKELETON.LIB\" (User's PROFILE PREFIX\n       is  XX00999 and  user  DOES  want deallocation  notification\n       messages).\n\n       HOSEDOWN  PANEL(SPF.PANELIB) -\n                 MESSAGE(SPF.MSGLIB) -\n                 SKELETON(SKELETON.LIB) -\n                 PRINT(YES)\n\n\n\n\n1                                                        HOSEDOWN.3\n                                                         03/16/83\n\n\n  This CLIST must be placed in one of the following:\n       .    Inside a CLIST executing in  \"straight TSO\" (outside of\n            SPF).\n\n       .    Inside      a     LOGON      PROCEDURE     such      as\n            PREFIX.MISC.CLIST(LOGON) for PROD1 users.\n\n  The Dialog  Manager libraries  cannot be  deallocated within  SPF\n  (Option  '6')  because  the   SPF  Program  Development  Facility\n  libraries are OPEN and are not CLOSED until you exit SPF.\n\n\n\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "HOTKEYS$": {"ttr": 20492, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x00\\x7f\\x00\\x88\\x00\\x7f\\x12\\x00\\x00@\\x00@\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf2\\xf7\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-01-07T00:00:00", "modifydate": "1988-01-07T12:00:00", "lines": 64, "newlines": 64, "modlines": 0, "user": "FILE270"}, "text": "\nHOTKEYS is an ISPF CLIST dialog which sets the ISPF function keys\n        so that they will call various functions such as browse, edit,\n        library, PDS command, etc. and pass a dataset name found at\n        the cursor location when the key was pressed. In other words,\n        you move your cursor somewhere onto a dataset name, even in\n        some data you are editing/browsing, and hit the key and\n        presto! You are now editing/browsing, etc. the new dataset.\n        When you are done, you press END or RETURN and you are back\n        where you started.\n          A line of PFKey definitions is displayed at the bottom of\n        your screen, but this may be turned off with command\n        \"PFSHOW OFF\" without affecting the HOTKEYS.\n          If you only have 12 PFKeys then you can set one to select\n        the \"HOTKEY MENU\" which allows you to alter the dataset name\n        and specify which function you need.\n          The letter \"U\" may be entered in the command field prior to\n        pressing the HOTKEY PFKey for some functions. This will allow\n        you to change the dataset name or select alternate functions.\n          The HOTKEY PFKeys work from most ISPF panels.\n\nSYNTAX -\n        HOTKEYS ON    HI   MENU(nn)\n                OFF   LOW\n\n       default is ON, HI\n\n       ON  - means turn HOTKEYS on.\n       OFF - means restore PFKeys to state prior to HOTKEYS ON.\n       HI  - means use PFKeys in range 13-24 for HOTKEYS.\n       LOW - means use PFKeys in range 1-12 for HOTKEYS.\n       MENU(nn) - means only set PFKey nn to the HOTKEY menu.\n\n\nUSAGE NOTES:\n\n     1. Since HOTKEYS changes the PFKey definitions, in order to\n       use it under dialog applications which change the APPLID,\n       such as FILEAID, IOF, etc., it is neccessary to turn it on\n       while under these applications with TSO %HOTKEYS ON.\n\n     2. Some of the HOTKEY functions such as LIB (3.1) may not support\n       recursive entry, although EDIT and BROWSE now do.\n\n     3. The copy function requires you to select two datasets before\n       the copy utility is called. The copy PFKey initially is labeled\n       \"FROM\". After selecting a dataset, the label changes to \"TO\",\n       which indicates that the next use of the key will designate\n       the destination dataset and invoke the copy utility. An \"R\"\n       may be entered in the command field to copy with replace.\n\nINSTALLATION NOTES:\n\n     1. Changes to some ISPF panels are required to allow automatic\n       entry to ISPF functions with a passed DSNAME. I have enclosed\n       copies of my ISRUDA1, ISRUMC1, ISRUMC2A, ISRUMC2B panels.\n\n     2. Some of the other mods on this tape are required to support\n       HOTKEYS. Also PDS and URZAP from the CBT mods tape are needed\n       for some of the options. Change the code which checks to see\n       if the user is authorized to have URZAP in clist HOTKEYS.\n\n     3. As sent, FILEAID is required for the INFO key, but this\n       can be changed to use ISPF 3.2 easily.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "IFALC": {"ttr": 20494, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x00\\x7f\\x00\\x88\\x00\\x7f\\x12\\x00\\x01#\\x01#\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf2\\xf7\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-01-07T00:00:00", "modifydate": "1988-01-07T12:00:00", "lines": 291, "newlines": 291, "modlines": 0, "user": "FILE270"}, "text": "*          DATA SET 761KKIFALC AT LEVEL 001 AS OF 10/13/80\n         TITLE 'IFALOC -- COMMAND PROCESSER'\n***********************************************************************\n*                                                                     *\n* IFALC DA(----)                                                      *\n*   \"   DA(----) F(====)                                              *\n*   \"   DA(*) F(====)                                                 *\n*   \"   F(====)                                                       *\n*                                                                     *\n***********************************************************************\n*\n* REGISTER USEAGE\n*\n*        R2-R7 WORK REGISTERS\n*        R8    BASE REGISTER FOR PDES\n*        R9    BASE REGISTER FOR DAPL\n*        R10   BASE REGISTER FOR PPL\n*        R11   BASE REGISTER FOR CPPL\n*        R12   BASE REGISTER FOR PROGRAM\n*        R13   BASE REGISTER FOR WORKAREA\n*        R14   LINK REGISTER\nIFALOC    ENTER (14,12),12,(,WORKL1)\n         SPACE 3\n*        SET UP ADDRESSABILITY\n*        COMMAND PROCCESSOR PARM LIST,PARSE PARM LIST,DYNAMIC ALLOC\n*        PARM LIST,WORKAREA. (CPPL,PPL,DAPL,W.A.)\n         USING WORK1,R13\n         LR    R11,R1\n         USING CPPL,R11\n         LA    R10,PPLAREA\n         USING PPL,R10\n         LA    R9,DAPLAREA\n         USING DAPL,R9\n         SPACE 3\n*\n*        PREPARE PARSE AND DAIR CONTROL BLOCKS\n*        TRANSFER INFO FROM CPPL TO PPL AND DAPL\n         L     R5,CPPLCBUF    COMMAND BUFFER\n         ST    R5,PPLCBUF\n         L     R5,CPPLUPT    UPT\n         ST    R5,PPLUPT\n         ST    R5,DAPLUPT\n         L     R5,CPPLECT    ECT\n         ST    R5,PPLECT\n         ST    R5,DAPLECT\n         LA    R5,PARSECB    MOVE OUR ECB\n         ST    R5,PPLECB\n         ST    R5,DAPLECB\n         L     R5,CPPLPSCB   PSCB\n         ST    R5,DAPLPSCB\n         L     R5,=A(PARMS)\n         ST    R5,PPLPCL\n         LA    R5,ANSAREA\n         ST    R5,PPLANS\n         XC    PPLUWA(4),PPLUWA\n         XC    PARSECB(4),PARSECB\n         SPACE 3\n*\n*        PARSE COMMAND BUFFER\n*\n         LR    R1,R10\n         DROP  R10\n         LINK  EP=IKJPARS\n         SPACE 3\n*\n*        CHECK RETURN CODE\n*\n         LTR   R15,R15\n         BNZ   PARSERR\n         SPACE 3\n*\n*        SET UP PDL ADDRESSABILITY\n*\n         L     R8,ANSAREA\n         USING IKJPARMD,R8\n         SPACE 3\n          CLI   FILE+1,0\n          BE    NOFILE\n          CLI   DA+1,0\n          BNE   BOTH\n          SPACE 3\n* HERE ONLY FILE IS SPECIFIED, WE USE A TIOT LOOP\nGETTIOT  EQU   *\n         L     R6,DDNAME\n         LA    R7,TIOTADDR\n         EXTRACT (R7),FIELDS=(TIOT),MF=(E,EXPARM)   *KK* 5/1/80\n         L     R7,TIOTADDR        GET TIOT ADDR\n         LH    R3,DDNAME+4  LOAD LENGTH\n         BCTR  R3,0\n         SR    R4,R4               CLEAR REG\n         LA    R7,24(,R7)        GET 1ST DD ENTRY\n         LA    R4,24(R4)           ADD OFSET TO REG FOR LATER USE\nFINDDD   EQU   *\n         EX    R3,COMPDDN1        IS THIS OUR ENTRY?\n         BE    CHKCC               YES GET OUT\n         SR    R5,R5             CLEAR R5\n         IC    R5,0(R7)          GET OFFSET TO NEXT ENTRY\n         LA    R4,0(R5,R4)        ADD TO OFFSET REG\n         LA    R7,0(R5,R7)      GET ADDR OF NEXT ENTRY\n         CLC   0(4,R7),=F'0'      IS THIS LAST ENTRY\n         BE    ERROR4              YES GO SEND ERROR\n         B     FINDDD              GO LOOK AT THIS ONE\n         SPACE 3\nCOMPDDN1 CLC   4(0,R7),0(R6)\nCOMPDSN2 CLC   0(0,R5),0(R6)\nMOVEDSN3 MVC   0(0,R4),0(R5)\n         SPACE 3\nCHKCC    EQU   *\n         SLR   R15,R15\n         CLI   DA+1,0\n         BE    EXIT\n* WE KNOW BOTH OPERANDS WERE SPECIFIED\n         LR    R5,R6\n         MVC   CDCB(MODCBLEN),MODCB\n         MVI   CDCB+40,C' '\n         MVC   CDCB+41(7),CDCB+40\n         LA    R4,CDCB+40\n         EX    R3,MOVEDSN3\n         LA    R6,AJ\n         ST    R6,CDCB+36\n         LA    R6,JFCB\n         ST    R6,AJ\n         MVI   AJ,X'87'\n         MVC   RDL,RDLR                                           WDPSC\n         LA    R5,CDCB\n         RDJFCB ((R5),INPUT),MF=(E,RDL)\n         L     R5,DSTRING\n         LH    R3,DSTRING+4\n         BCTR  R3,0\n         EX    R3,COMPDSN2\n         BE    EXIT\n         B     ERROR4\n          SPACE 3\nNOFILE    EQU   *\n          CLI   DA+1,0\n          BE    NEITHER\n          SPACE 3\n* NOFILE WILL USE DAIR TO SEE IF DATASET IS ALLOCATED\n*\n*\n*        COMPLETE DAIR CONTROL BLOCKS\n*\n         MVC   DAPB(20),DAPB00\n         LA    R5,DAPB\n         ST    R5,DAPLDAPB\n         LA    R4,DSN\n         ST    R4,DAPB+4\n         MVI   0(R4),C' '\n         MVC   1(45,R4),0(R4)\n         L     R5,DSTRING\n         LH    R3,DSTRING+4\n         STH   R3,0(R4)\n         LA    R4,2(R4)\nCUTIN    EQU   *\n         BCTR  R3,0\n         EX    R3,MOVEDSN3\n*\n*        IF DATA SET WAS NOT IN QUOTES, ADD USERID TO FRONT\n*\n         TM    DSTRING+6,B'01000000'\n         BNZ   QUOTED01\n         OI    DAPB+16,B'00100000'\nQUOTED01 EQU   *\n         SPACE 3\n*\n*        CREATE DD CARD FOR DATA SET WITH DAIR\n*\n         LA    R1,DAPL\n         LINK  EP=IKJEFD00\n         SPACE 3\n*\n*        CHECK RETURN CODE FROM DAIR\n*\n         LTR   R15,R15\n         BNZ   DAIRERR\n         LA    R5,DAPB\n         L     R3,DSTRING\n         CLI   0(R3),C'*'\n         BE    TDAIRTRM\n         TM    2(R5),X'02'\n         BZ    ERROR4\n         B     EXIT\nTDAIRTRM EQU   *\n         TM    2(R5),X'01'\n         BZ    ERROR4\n         B     EXIT\n          SPACE 3\nBOTH      EQU   *\n* BOTH WILL CHECK TO SEE IF DATASET=TERMINAL, IF YES,IT USES DAIR,IF\n* NO, IT USES A TIOT LOOP AND THEN IT READS THE JFCB.\n         L     R3,DSTRING\n         CLI   0(R3),C'*'\n         BE    DAIRTERM\n         TM    DSTRING+6,B'01000000'                        *KK*\n         BNZ   GETTIOT                                      *KK*\n         L     R1,CPPLUPT               R1->UPT             *KK*\n         MVC   PFXDSN(7),16(R1)         SAVE PREFIX         *KK*\n         SLR   R15,R15                                      *KK*\n         IC    R15,23(,R1)              R15=PREFIX LEN      *KK*\n         IC    R0,=C'.'                 R0 = PERIOD         *KK*\n         STC   R0,PFXDSN(R15)           MOVE IT             *KK*\n         LA    R4,PFXDSN+1(R15)         PT PAST             *KK*\n         L     R5,DSTRING               R5->REST OF DSN     *KK*\n         LH    R3,DSTRING+4             R3=LEN \"            *KK*\n         BCTR  R3,R0                    -1 FOR EX           *KK*\n         EX    R3,MOVEDSN3              MOVE REST OF DSN    *KK*\n         LA    R3,2(R3,R15)             GET NEW LEN         *KK*\n         STH   R3,DSTRING+4             SAVE IT             *KK*\n         LA    R1,PFXDSN                PT TO NEW DSN       *KK*\n         ST    R1,DSTRING               SAVE NEW DSN PTR    *KK*\n         B     GETTIOT\n          SPACE 3\nDAIRTERM EQU   *\n         MVC   DAPB(20),DAPB00\n         LA    R5,DAPB\n         ST    R5,DAPLDAPB\n         MVI   DAPB+8,C' '\n         MVC   DAPB+9(7),DAPB+8\n         LA    R4,DAPB+8\n         L     R5,DDNAME\n         LH    R3,DDNAME+4\n         B     CUTIN\n          SPACE 3\nNEITHER  EQU   *\n* NEITHER KEYWORD IS SPECIFIED, GIVE ERROR, SET COND.CODES ,BYE\n         TPUT  NOOP,21\n         TITLE 'EXITS...BOTH GOOD AND BAD'\nERROR4   LEAVE CC=4\nEXIT     EQU   *\n         LEAVE EQ\n         TITLE 'IFALOC -- ERROR PROCESSING'\n*\n*        AN ERROR OCCURED IN PARSE\n*\nPARSERR  EQU   *\n         TPUT  BADPARS,11\n         B     ERROR4\n         SPACE 3\n*\n*        AN ERROR OCCURED IN DAIR.\n*\nDAIRERR  EQU   *\n         TPUT  BADAIR,24\n         B     ERROR4\n         SPACE 3\n         TITLE 'IFALOC -- CONSTANTS, STORAGE, AND DSECTS'\nNOOP     DC    CL21'NO OPERANDS SPECIFIED'\nBADPARS  DC    CL11'PARSE ERROR'\nBADAIR   DC    CL24'DYNAMIC ALLOCATION ERROR'\n         SPACE 2\nMODCB    DCB  DDNAME=DUMMY,DSORG=PS,MACRF=GM\nMODCBLEN EQU   *-MODCB\nRDLR     RDJFCB  (MODCB,INPUT),MF=L                              WDPSC\n         SPACE 3\nDAPB00   DC    F'0'\n         DC    A(0)           DSNAME BUFFER ADDRESS\n         DC    CL8' '         DDNAME ASSIGNED BY DAIR\n         DC    4XL1'00'\nPARMS    IKJPARM\nFILE     IKJKEYWD\n         IKJNAME 'FILE',SUBFLD=FIL,ALIAS=('DDNAME')\nDA       IKJKEYWD\n         IKJNAME 'DATASET',SUBFLD=DSET,ALIAS=('DSNAME')\nFIL      IKJSUBF\nDDNAME   IKJIDENT 'FILE',MAXLNTH=8,FIRST=ALPHA,OTHER=ALPHANUM,      XXXX\n               PROMPT='FILE'\nDSET     IKJSUBF\nDSTRING  IKJPOSIT DSTHING,PROMPT='DATASET'\n         IKJENDP\nWORK1    DSECT\n         DS    18F\nPPLAREA  DS    7F\nANSAREA  DS    F\nPARSECB  DS    F\nDAPLAREA DS    5F\n         DS    0F\nDAPB     DS    CL20\nRDL      RDJFCB  (MODCB,INPUT),MF=L                              WDPSC\nCDCB     DS    60F\nAJ       DS   F\nJFCB     DS   CL176\nTIOTADDR DS    F\n         DS   F\nDSN      DS   CL46\nEXPARM   EXTRACT  MF=L                                *KK*\nPFXDSN   DS   CL46                                    *KK*\nWORKL1   EQU   *-WORK1\n         IKJCPPL\n         IKJPPL\n         IKJDAPL\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "IFALC$": {"ttr": 20741, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x00\\x7f\\x00\\x88\\x00\\x7f\\x12\\x00\\x00:\\x00:\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf2\\xf7\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-01-07T00:00:00", "modifydate": "1988-01-07T12:00:00", "lines": 58, "newlines": 58, "modlines": 0, "user": "FILE270"}, "text": "1                                                        IFALC.1\n                                                         06/25/82\n\n\n  COMMAND NAME:       IFALC\n  SOURCE:             Kermit Kiser\n  AGENCY:             WDPSC\n  FUNCTION:           The  IFALC command  is  intended  for use  in\n                      command  procedures.  It  allows  conditional\n                      execution  based  on  whether   a  ddname  or\n                      dataset name is allocated or not allocated.\n\n  Syntax -\n  _________________________________________________________________\n       Command        Operands\n  -----------------------------------------------------------------\n       IFALC          FILE(ddname)   DATASET(dsname)\n  -----------------------------------------------------------------\n\n  Operands -\n    Required - Either FILE or DATASET\n            (DDNAME and DSNAME may be substituted\n             for FILE and DATASET respectively.)\n    Default - None.\n       FILE(ddname) -\n                 The ddname you wish to check.\n       DATASET(dsname) -\n                 The dataset name you wish to check.\n\n\n\n\n1                                                        IFALC.2\n                                                         06/25/82\n  EXAMPLE:\n\n    IFALC FILE(SYSPRINT) DATASET(OUT.PRINT)\n\n    NOTE:   IFALC returns a condition code of 0 if any of\n            the following conditions are met:\n\n       (1)  The FILE keyword  only is given:  The  ddname specified\n            is currently allocated to the TSO session.\n\n       (2)  The  DATASET   keyword  only  is  given:    The  dsname\n            specified is currently allocated to the TSO session.\n\n       (3)  Both  the FILE  and DATASET  keywords  are given:   The\n            dsname  specified   is  currently   allocated  to   the\n            specified ddname.\n\n            IFALC returns  a condition code of  4 if none  of these\n            conditions  were  met.   The   condition  code  may  be\n            obtained from the CLIST variable &LASTCC.\n\n\n\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "IFCAT": {"ttr": 20743, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x00\\x7f\\x00\\x88\\x00\\x7f\\x12\\x00\\x00\\xa9\\x00\\xa9\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf2\\xf7\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-01-07T00:00:00", "modifydate": "1988-01-07T12:00:00", "lines": 169, "newlines": 169, "modlines": 0, "user": "FILE270"}, "text": "*          DATA SET 761KKIFCAT AT LEVEL 001 AS OF 10/13/80\n         TITLE 'IFCAT -- COMMAND PROCESSOR'\n***********************************************************************\n*                                                                     *\n* IFCAT 'SWC.L.DATA'                                                  *\n*   \"   MISC.CLIST                                                    *\n*   \"   'SWC.L.DATA(MEM)'                                             *\n*   \"   MISC.CLIST(CLMEM)                                             *\n*                                                                     *\n***********************************************************************\n*\n* REGISTER USEAGE\n*\n*        R2-R7 WORK REGISTERS\n*        R8    BASE REGISTER FOR PDES\n*        R9    BASE REGISTER FOR DAPL\n*        R10   BASE REGISTER FOR PPL\n*        R11   BASE REGISTER FOR CPPL\n*        R12   BASE REGISTER FOR PROGRAM\n*        R13   BASE REGISTER FOR WORKAREA\n*        R14   LINK REGISTER\nIFCT    ENTER (14,12),12,(,WORKL1)\n         SPACE 3\n*        SET UP ADDRESSABILITY\n*        COMMAND PROCCESSOR PARM LIST,PARSE PARM LIST,DYNAMIC ALLOC\n*        PARM LIST,WORKAREA. (CPPL,PPL,DAPL,W.A.)\n         USING WORK1,R13\n         LR    R11,R1\n         USING CPPL,R11\n         LA    R10,PPLAREA\n         USING PPL,R10\n         LA    R9,DAPLAREA\n         USING DAPL,R9\n         SPACE 3\n*\n*        PREPARE PARSE AND DAIR CONTROL BLOCKS\n*        TRANSFER INFO FROM CPPL TO PPL AND DAPL\n         L     R5,CPPLCBUF    COMMAND BUFFER\n         ST    R5,PPLCBUF\n         L     R5,CPPLUPT    UPT\n         ST    R5,PPLUPT\n         ST    R5,DAPLUPT\n         L     R5,CPPLECT    ECT\n         ST    R5,PPLECT\n         ST    R5,DAPLECT\n         LA    R5,PARSECB    MOVE OUR ECB\n         ST    R5,PPLECB\n         ST    R5,DAPLECB\n         L     R5,CPPLPSCB   PSCB\n         ST    R5,DAPLPSCB\n         L     R5,=A(PARMS)\n         ST    R5,PPLPCL\n         LA    R5,ANSAREA\n         ST    R5,PPLANS\n         XC    PPLUWA(4),PPLUWA\n         XC    PARSECB(4),PARSECB\n         SPACE 3\n*\n*        PARSE COMMAND BUFFER\n*\n         LR    R1,R10\n         DROP  R10\n         LINK  EP=IKJPARS\n         SPACE 3\n*\n*        CHECK RETURN CODE\n*\n         LTR   R15,R15\n         BNZ   PARSERR\n         SPACE 3\n*\n*        SET UP PDL ADDRESSABILITY\n*\n         L     R8,ANSAREA\n         USING IKJPARMD,R8\n         SPACE 3\n*         CLI   DSTRING,0\n*         BE    NEITHER\n         SPACE 3\n*\n*\n*        COMPLETE DAIR CONTROL BLOCKS\n*\n         MVC   DAPB(16),DAPB04\n         LA    R5,DAPB\n         ST    R5,DAPLDAPB\n         LA    R4,DSN\n         ST    R4,DAPB+8\n         MVI   0(R4),C' '\n         MVC   1(45,R4),0(R4)\n         L     R5,DSTRING\n         LH    R3,DSTRING+4\n         STH   R3,0(R4)\n         LA    R4,2(R4)\n         BCTR  R3,0\n         EX    R3,MOVEDSN3\n*\n*        IF DATA SET WAS NOT IN QUOTES, ADD USERID TO FRONT\n*\n         TM    DSTRING+6,B'01000000'\n         BNZ   QUOTED01\n         OI    DAPB+12,B'00100000'\nQUOTED01 EQU   *\n         SPACE 3\n*\n*        CREATE DD CARD FOR DATA SET WITH DAIR\n*\n         LA    R1,DAPL\n         LINK  EP=IKJEFD00\n         SPACE 3\n*\n*        CHECK RETURN CODE FROM DAIR\n*\n         LTR   R15,R15\n         BNZ   ERROR4\n         LA    R5,DAPB\n         TM    2(R5),X'06'\n         BZ    ERROR4\n         B     EXIT\n         SPACE 3\nMOVEDSN3 MVC   0(0,R4),0(R5)\n         SPACE 3\nNEITHER  EQU   *\n* NEITHER KEYWORD IS SPECIFIED, GIVE ERROR, SET COND.CODES ,BYE\n         TPUT  NOOP,21\n         TITLE 'EXITS...BOTH GOOD AND BAD'\nERROR4   LEAVE CC=4\nEXIT     EQU   *\n         LEAVE EQ\n         TITLE 'IFCT -- ERROR PROCESSING'\n*\n*        AN ERROR OCCURED IN PARSE\n*\nPARSERR  EQU   *\n         TPUT  BADPARS,11\n         B     ERROR4\n         SPACE 3\n*\n*        AN ERROR OCCURED IN DAIR.\n*\n         SPACE 3\n         TITLE 'IFCT -- CONSTANTS, STORAGE, AND DSECTS'\nNOOP     DC    CL21'NO OPERANDS SPECIFIED'\nBADPARS  DC    CL11'PARSE ERROR'\nBADAIR   DC    CL24'DYNAMIC ALLOCATION ERROR'\n         SPACE 2\nDAPB04   DS    0F\n         DC    X'00040000'\n         DC    F'0'\n         DC    A(0)           DSNAME BUFFER ADDRESS\n         DC    4XL1'00'\nPARMS    IKJPARM\nDSTRING  IKJPOSIT DSNAME,PROMPT='DATASET'\n         IKJENDP\nWORK1    DSECT\n         DS    18F\nPPLAREA  DS    7F\nANSAREA  DS    F\nPARSECB  DS    F\nDAPLAREA DS    5F\n         DS    0F\nDAPB     DS    CL16\n         DS   F\nDSN      DS   CL46\nWORKL1   EQU   *-WORK1\n         IKJCPPL\n         IKJPPL\n         IKJDAPL\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "IFCAT$": {"ttr": 20747, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x00\\x7f\\x00\\x88\\x00\\x7f\\x12\\x00\\x00(\\x00(\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf2\\xf7\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-01-07T00:00:00", "modifydate": "1988-01-07T12:00:00", "lines": 40, "newlines": 40, "modlines": 0, "user": "FILE270"}, "text": "1                                                        IFCAT.1\n                                                         06/25/82\n\n\n\n  COMMAND NAME:       IFCAT (Alias:   FILESTAT)\n  SOURCE:             Kermit Kiser\n  AGENCY:             WDPSC\n  FUNCTION:           The  IFCAT command  is  intended  for use  in\n                      command  procedures.  It  allows  conditional\n                      execution  based  on  whether  a  dataset  is\n                      cataloged or not cataloged.\n\n  Syntax -\n  __________________________________________________________________\n       Command        Operands\n  ------------------------------------------------------------------\n       IFCAT          dsname\n  or   FILESTAT\n  ------------------------------------------------------------------\n\n  Operands -\n\n    Required - dsname\n\n  Default  - None.\n\n      Dsname - The dataset name you wish checked.\n\n  Example -\n    IFCAT      LIB.DATA\n\n  NOTE:     IFCAT returns a  condition code of 0 if  the dataset is\n            cataloged.   If it  is not  cataloged  a code  of 4  is\n            returned.  The CLIST variable  &LASTCC will contain the\n            return code.\n\n\n\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "IGC00236": {"ttr": 20749, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x00\\x7f\\x00\\x88\\x00\\x7f\\x12\\x00\\x00\\x92\\x00\\x92\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf2\\xf7\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-01-07T00:00:00", "modifydate": "1988-01-07T12:00:00", "lines": 146, "newlines": 146, "modlines": 0, "user": "FILE270"}, "text": "         TITLE 'SHOW/$/LOGON  SVC'\n*\n*        THIS MODULE REQUIRES ASMH - IT CAN RUN ABOVE 16M ADDRESS\n*\n*        THIS WAS SVC 242 BUT DAN CHANGED IT TO SVC 236\n*        IT IS USED BY THE LOGON EXIT MODULE LOGJCLX TO GET AUTHORIZED\n*        TO PERFORM SOME OF OUR LOCAL EXTENSIONS...\n*        IT MAY BE CALLED ONLY BY PROGRAMS RESIDING OUTSIDE OF THE\n*        PRIVATE (AND PRIVATE-EXTENDED) AREAS TO TURN ON/OFF JSCBAUTH\n*        OR TO ISSUE A SYSTEM COMMAND VIA SVC 34 ($ CMD DOES THAT)\n*\nIGC00236 START\n         USING *,R6\nIGC00236 AMODE ANY\nIGC00236 RMODE ANY\n         B     STARTSVC\n         DC    AL1(22)\n         DC    C'IGC00236-WDPSC/TSO SVC'\n*\n*                         CHECK SYSTEM LEVEL FIRST:\n*\nSTARTSVC L     R11,16             R11->CVT\n         USING CVT,R11\n         L     R2,28(5)           R2->CALLERS RB\n         L     R2,20(R2)          R2->CALLERS NEXT INSTRUCTION\n         N     R2,=X'7FFFFFFF'    KILL XA BIT\n*\nXACHK    TM    CVTDCB,CVTMVSE     XA SYSTEM?\n         BNO   NOTXA              NOPE.\n         LA    R8,XA              R8->XA CODE\n         O     R8,=X'80000000'    AMODE=31\n         BSM   0,R8               GO TO XA CODE\n*\n*        NON-XA SYSTEM: VERIFY CALLED FROM OUTSIDE PRIVATE AREA:\n*\nNOTXA    DS    0H\n         L     R10,CVTGDA         R10->GDA IN SQA\n         C     R2,16(R10)         BELOW PRIVATE?\n         BL    CALLEROK           YES\n         L     R9,16(R10)         R9->PRIVATE AREA\n         A     R9,20(R10)         R9->END OF PRIVATE AREA\n         CR    R9,R2              ABOVE PRIVATE?\n         BL    CALLEROK           YES\n         B     AUTHBEND           NO->KILL HIM\n*\n*\n*        XA SYSTEM: VERIFY CALLED FROM OUTSIDE PRIVATE AREA:\n*\nXA       DS    0H\n         L     R10,CVTGDA         R10->GDA IN SQA\n         L     R9,160(R10)        R9->PRIVATE AREA\n         LA    R9,0(,R9)          CLEAR XA BIT\n         CR    R2,R9              BELOW PRIVATE?\n         BL    CALLEROK           YES\n         A     R9,164(R10)        R9->END OF PRIVATE AREA\n         CR    R2,R9              ABOVE PRIVATE?\n         BL    AUTHBEND           NO->KILL HIM\n*\n         L     R9,168(R10)        R9->PRIVATE AREA EXTENDED\n         LA    R9,0(,R9)          CLEAR XA BIT\n         CR    R2,R9              BELOW PRIVATE EXTENDED?\n         BL    CALLEROK           YES\n         A     R9,172(R10)        R9->END OF PRIVATE AREA EXTENDED\n         CR    R2,R9              ABOVE PRIVATE EXTENDED?\n         BL    AUTHBEND           NO->KILL HIM\n         EJECT\n*\n*        CALLER IS NOT IN PRIVATE AREAS - CHECK FUNCTION REQUEST:\n*\nCALLEROK DS    0H\n         C     R0,=F'1'           1=PASS CMD TO SYSTEM?\n         BE    JARED              YUP\n         L     R8,180(R4)         R8->JSCB\n         LTR   R0,R0              RESET AUTH REQUEST?\n         BZ    AUTHOFF            YUP.\n         C     R0,=F'-1'          OK?\n         BE    AUTHON             YUP->SKIP PREAUTH CHECK\n         LR    R2,R0              GET TEST ADDRESS\n         L     R0,=F'-1'          DON'T LOOP\n         B     XACHK              GO SEE IF OK\n*\n*   TURN AUTHORIZATION ON:\n*\nAUTHON   OI    236(R8),X'01'      SET JSCBAUTH BIT TO ON.\n         B     RETURN             EXIT\n*\n*    TURN AUTHORIZATION OFF:\n*\nAUTHOFF  NI    236(R8),X'FE'      SET JSCBAUTH TO OFF.\n*\nRETURN   SLR   R15,R15            R15=0\n         BR    R14                EXIT SVC\n*\n*\n*\nAUTHBEND ABEND X'FEC',,,SYSTEM    GIVE SYSTEM ABEND\n         DS    0D\n         EJECT\n         PRINT     ON,GEN,NODATA\nJARED    DS        0H\n         L         2,0(1)              POINT AT CHAR VAR STRING\n         LH        3,0(2)              GET LENGTH\n         LTR       3,3                 ANY PARM\n         BNP       AUTHBEND\n*\n         LR    R8,R1              SAVE R1\n         LA    R0,WORKLEN         R0=LENGTH OF DESIRED WORKAREA\n         GETMAIN R,LV=(0)\n         LR    R12,R1             R12->WORKAREA\n         USING WORKAREA,R12\n         XC    WORKAREA(WORKLEN),WORKAREA      CLEAR THE AREA\n         LR    R1,R8              RESTORE R1\n*\n         BCTR      3,0\n         EX        3,MVC\nMVC      MVC       TEXT(0),2(2)        COPY TEXT TO SVC 34 PARM LIST\n         LA        3,5(3)              INCREMENT TO TRUE PARM LENGTH\n         STC       3,LENGTH            SAVE LENGTH IN SVC 34 PARM LIST\n         SPACE     1\n         STCTL     4,4,CR4             SAVE PRIMARY ASID\n         XC        CR4(2),CR4          CLEAR HIGH TWO BYTES\n         OI        CR4+2,X'80'         MAKE ASID INTO TJID\n         L         0,CR4               SVC 34 PARAMETER SOURCE PARM\n         SPACE     1\n         MGCR      COMMAND             QUEUE COMMAND\n         SPACE     1\n*\n         LR    R8,R1              SAVE R1\n         LA    R0,WORKLEN         R0=LENGTH OF DESIRED WORKAREA\n         LA    R1,WORKAREA\n         FREEMAIN R,LV=(0),A=(1)\n         LR    R1,R8              RESTORE R1\n*\n         SVC   3   EXIT                DIRECT TERMINATION\n         EJECT\n         LTORG\n         REGISTER\n         SPACE     3\nWORKAREA DSECT\nCR4      DC        A(0)\nCOMMAND  DC        X'00'               SVC 34 PARAMETER LIST\nLENGTH   DC        AL1(L'TEXT),2X'00'\nTEXT     DC        CL100'$PI '\nWORKLEN  EQU   *-WORKAREA\n         CVT  DSECT=YES\n         END  IGC00236\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "IKJUPDT": {"ttr": 20993, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x00\\x7f\\x00\\x88\\x00\\x7f\\x12\\x00\\x00/\\x00/\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf2\\xf7\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-01-07T00:00:00", "modifydate": "1988-01-07T12:00:00", "lines": 47, "newlines": 47, "modlines": 0, "user": "FILE270"}, "text": "IKJUP    TITLE ' - TO REPLACE CALLS TO IBM IKJUPDT '\n*                                 WRITTEN BY KERMIT KISER\n*\n*//*\n*//* A TSO COMMAND USES IKJUPDT AS FOLLOWS:\n*//*\n*//*     CALL  IKJUPDT,(UPT,ECT,ECB,UPLIST)\n*//*\n*//*          UPT = USER PROFILE TABLE       (FROM CPPL)\n*//*          ECT = ENVIRONMENT CONTROL TABLE   \"   \"\n*//*          ECB = COMMAND PROCESSOR ECB\n*//*          UPLIST = A FOUR WORD BLOCK AS BELOW:\n*//*\n*//*\n*//*  UPLIST  DS  0XL16\n*//*  LOCPTR  DS  AL4         PTR TO VARIABLE NAME\n*//*  LOCLEN  DS  F           LENGTH OF VARIABLE NAME\n*//*  VALPTR  DS  A           PTR TO DATA VALUE\n*//*  VALLEN  DS  F           LENGTH OF DATA VALUE\n*//*\n*//* EXAMPLE : SET &VAR = &STR(MYDATA)\n*//*    WOULD NEED THE FOLLOWING CONTROL BLOCK PASSED TO IKJUPDT:\n*//*\n*//*  UPLIST  DS  0XL16\n*//*  LOCPTR  DC  A(=C'VAR')    PTR TO VARIABLE NAME\n*//*  LOCLEN  DC  F'3'          LENGTH OF VARIABLE NAME\n*//*  VALPTR  DC  A(=C'MYDATA') PTR TO DATA VALUE\n*//*  VALLEN  DC  F'6'          LENGTH OF DATA VALUE\n*//*\nIKJUPDT  ENTERR LEVEL=V1M0\n         LR    R11,R1                   R11->CPPL\n         USING CPPL,R11\n         EJECT\n*\n         LINK  EP=SETVAR                DO THE UPDATE              V1M4\n*\n         EJECT\n         LEAVER\n         EJECT\n         LTORG\n         EJECT\nWORKAREA DSECT\nSAVEAREA DS    18F\nWORKLEN  EQU   *-WORKAREA\n         EJECT\n         IKJCPPL\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "IMPORT": {"ttr": 20995, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x00\\x7f\\x00\\x88\\x00\\x7f\\x12\\x00\\x00\\x19\\x00\\x19\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf2\\xf7\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-01-07T00:00:00", "modifydate": "1988-01-07T12:00:00", "lines": 25, "newlines": 25, "modlines": 0, "user": "FILE270"}, "text": "//KKI00155 JOB (2100,56-D),'KISER 2215 T',CLASS=H,TYPRUN=HOLD\n//JOBCAT DD DISP=SHR,DSN=SYS1.SOFTCAT\n//COPYS1   EXEC IEBCOPY\n//*\n//*  IMPORT THE SOURCE MODULES FOR WASH STATE MODS:\n//*\n//OUT DD DISP=(NEW,CATLG),DSN=WDPSC.IMPORT.ALLOFEM,\n// UNIT=SYSALLDA,VOL=SER=STOR01,SPACE=(CYL,(8,3,40),RLSE)\n//*\n//IN  DD DISP=(OLD,KEEP),UNIT=TAPE16,VOL=(,RETAIN,SER=EXPORT),\n// LABEL=(1,NL,EXPDT=98000),DCB=DEN=3\n//*\n C I=IN,O=OUT\n//*\n//*  IMPORT THE LOAD MODULES FOR WASH STATE MODS:\n//*\n//COPYS2   EXEC IEBCOPY\n//*\n//OUT DD DISP=(NEW,CATLG),DSN=WDPSC.IMPORT.LOAD,\n// UNIT=SYSALLDA,VOL=SER=STOR01,SPACE=(CYL,(3,1,30),RLSE)\n//*\n//IN  DD DISP=(OLD,KEEP),UNIT=TAPE16,VOL=(,RETAIN,SER=EXPORT),\n// LABEL=(2,NL,EXPDT=98000),DCB=DEN=3\n//*\n C I=IN,O=OUT\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "INDEX": {"ttr": 20997, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x00\\x7f\\x00\\x88\\x00\\x7f\\x12\\x00\\x00Q\\x00Q\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf2\\xf7\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-01-07T00:00:00", "modifydate": "1988-01-07T12:00:00", "lines": 81, "newlines": 81, "modlines": 0, "user": "FILE270"}, "text": "INDEX    TITLE ' - SCAN A STRING FOR A CHARACTER'\n***********************************************************************\n***                                                                 ***\n***  INDEX WILL SET A RETURN CODE BASED ON THE POSITION OF A        ***\n***  CHARACTER IN A STRING. *&\u00ac%$#@ TIRED OF THOSE VM GUYS          ***\n***  HAVING BETTER STRING FUNCTIONS!........SOMEDAY...              ***\n***                                                                 ***\n***  SYNTAX:                                                        ***\n***    @ INDEX 'CHRDIRSTR'                                          ***\n***    WHERE:                                                       ***\n***          CHR - IS THE CHAR TO SEARCH STRING FOR                 ***\n***          DIR - IS DIRECTION OF SEARCH,  <  OR  >                ***\n***          STR - IS THE STRING TO SEARCH                          ***\n***                                                                 ***\n***  RETURN CODES:                                                  ***\n***    (0)  - CHARACTER WAS NOT FOUND IN STRING                     ***\n***    (N)  - CHARACTER WAS FOUND AT POSITION N                     ***\n***                                                                 ***\n***  EXAMPLE:                                                       ***\n***    SET &STRING = &STR(SOME.STRING)                              ***\n***    @ INDEX '.>&STRING'                                          ***\n***    SET &SEPERATOR = &LASTCC                                     ***\n***  WOULD SET SEPERATOR = 5                                        ***\n***                                                                 ***\n***********************************************************************\n         EJECT\nINDEX    ENTERR LEVEL=V1M0\n         EJECT\n         L     R11,0(R1)          R11-> PARM\n         LA    R11,0(R11)         CLEAR HI BIT\n         LH    R3,0(R11)          R3 = PARM LENGTH\n         CH    R3,=H'2'\n         BH    TABLINIT\n         L     R15,=F'9999'       MISSING STRING PARAMETER\n         B     EXIT\nTABLINIT SLR   R2,R2              R2 = 0\n         IC    R2,2(R11)\n         STC   R2,TABL(R2)\n         SH    R3,=H'02'\nDELCHK   CLI   3(R11),C'>'        CHECK FOR REVERSE SEARCH\n         BE    REVSCAN\n         EX    R3,FWD             COPY STRING TO BUFFER\n         B     SCANIT\nREVSCAN  MVINC STRBUFF,0(R3),4(R11),TABLE=OLD\n         MVC   REVFLAG(2),=C'FF'  INDICATE REVERSE\nSCANIT   SLR   R15,R15            R15 = 0; INIT TO NOT FOUND\n         EX    R3,SCAN\n         BZ    EXIT\n         LR    R5,R1\n         LA    R4,STRBUFF\n         SR    R5,R4\n         CLC   REVFLAG(2),=C'FF'  CHECK FOR REVERSE\n         BE    ADJUST\n         LA    R15,1(R5)          R15 = POSITION IN STRING\n         B     EXIT\nADJUST   SR    R3,R5              ADJUST POSITION FOR REVERSE\n         LR    R15,R3             R15 = POSITION IN STRING\n*\n* RETURN TO WHOEVER CALLED US:\n*\nEXIT     LEAVER\n         SPACE\nFWD      MVC   STRBUFF(0),4(R11)\nSCAN     TRT   STRBUFF,TABL\n         EJECT\n*\n* STATIC WORKAREA:\n*\n         LTORG\n         EJECT\n***********************************************************************\n***                     DYNAMIC WORKAREA                            ***\n***********************************************************************\n         SPACE\nWORKAREA DSECT\nSAVEAREA DS    18F\nREVFLAG  DS    H\nSTRBUFF  DS    CL256\nTABL     DS    CL256\nWORKLEN  EQU   *-WORKAREA\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "INDEXES": {"ttr": 21000, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x00\\x7f\\x00\\x88\\x00\\x7f\\x12\\x00\\x01 \\x01 \\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf2\\xf7\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-01-07T00:00:00", "modifydate": "1988-01-07T12:00:00", "lines": 288, "newlines": 288, "modlines": 0, "user": "FILE270"}, "text": "./ ADD NAME=CONTROL  0111-86013-86191-1252-00008-00004-00000-KX00150\nT1 ...................Sample Status Reports for CONTROL ..............  ......\n\n\nT2           Reporter\n\n\nT3           ________\n\n\nD1       This might be anyone...                                          DOC04\nCONTROL anyone  DOCISTAT\n\nD1                                                                        doc04\ndummy DUMMY           dummy\n\nD1       Consolidated                                                     doc04\ncontrol ALL     docimerg\n\nD1       Final                                                            doc04\ncontrol FINAL   docfinal\n\nD1                                                                        doc04\ndummy DUMMY           dummy\n\n./ ADD NAME=DOCSYSD  0109-84285-87124-1557-00019-00012-00000-KK00150\nT1 ............... DOCUMENTATION FOR WDPSC DOCUMENTATION SYSTEM ................\n..\n\nT2\n\n\nT3\n\n\nD1 Tech Services DOCSYS overview of operation                             DOC02\nWDPSC.EXPORT.DOCS overview DUMMY1\n\nD1 Documentation for the major top level CLIST: DOCSYS                    DOC02\nWDPSC.EXPORT.DOCS DOCSYS   DUMMY1\n\nD1 Documentation for Tech Services top level CLIST: DOCTECH               DOC02\nWDPSC.EXPORT.DOCS DOCTECH  DUMMY1\n\nD1 Documentation for CLIST: DOC01PRT                                      DOC02\nWDPSC.EXPORT.DOCS DOC01PRT DUMMY1\n\nD1 Documentation for CLIST: DOC01SEL                                      DOC02\nWDPSC.EXPORT.DOCS DOC01SEL DUMMY1\n\nD1 Documentation for CLIST: DOC02PRT                                      DOC02\nWDPSC.EXPORT.DOCS DOC02PRT DUMMY1\n\nD1 Documentation for CLIST: DOC02SEL                                      DOC02\nWDPSC.EXPORT.DOCS DOC02SEL DUMMY1\n\nD1 Documentation for CLIST: DOC03PRT                                      DOC02\nWDPSC.EXPORT.DOCS DOC03PRT DUMMY1\n\nD1 Documentation for CLIST: DOC03SEL                                      DOC02\nWDPSC.EXPORT.DOCS DOC03SEL DUMMY1\n\nD1 TBLHNDLR - Table display program used by DOCSYS.                       DOC02\nWDPSC.EXPORT.DOCS A@TBLHDR DUMMY1\n\nD1 Description of index file record layout                                DOC02\nWDPSC.EXPORT.DOCS RECLAYOT DUMMY1\n\nD1 WDPSC Documentation System Libraries                                   DOC02\nWDPSC.EXPORT.DOCS LIBRARYS DUMMY1\n\nD1 Tech Services Documentation System Libraries                           DOC02\nWDPSC.EXPORT.DOCS LIBRARYS DUMMY1\n\nD1 Possible future additions to the WDPSC Documentation System            DOC02\nWDPSC.EXPORT.DOCS FUTADDS  DUMMY1\n\nD1 How to transfer Training bulletins, Tech bulletins from DLF to DOCSYS  DOC02\nWDPSC.EXPORT.DOCS TRANSFER DUMMY1\n\nD1 How to add a memo to the Tech Services DOCSYS (K.D).                   DOC02\nWDPSC.EXPORT.DOCS addmemo  DUMMY1\n\n./ ADD NAME=GDDMDOCS 0101-86115-87125-1336-00009-00009-00000-KK00150\nT1 ................ WDPSC documents concerning GDDM/PGF useage .................\n..\n\nT2     Document    Description\n\n\nT3     ----------  -------------------------------------------------------------\n--\n\nD1 CHART       How to invoke the Interactive Chart Utility and the        doc02\nwdpsc.export.docs CHART DUMMY1\n\nD2              Import Utility. Describes format of \"Import\" data.\n\n\nD1 GDDM        Information needed to develop GDDM applications.           doc02\nwdpsc.export.docs GDDM DUMMY1\n\nD1 ISSE        How to invoke the Interactive Symbol Set Editor.           doc02\nwdpsc.export.docs ISSE DUMMY1\n\nD1 SAMPSYMS    Describes some sample symbol sets.                         doc02\nwdpsc.export.docs SAMPSYMS DUMMY1\n\nD1 VSSE        How to invoke the Vector Symbol Set Editor.                doc02\nwdpsc.export.docs VSSE DUMMY1\n\n./ ADD NAME=JAN86    0104-86190-86210-1719-00009-00008-00000-KX00150\nT1 ...................Sample Status Reports for Jan 1986 .............. ......\n\n\nT2           Reporter\n\n\nT3           ________\n\n\nD1       Another guy                                                      DOC04\nJAN86 GUY2 DOCISTAT\n\nD1       This might be anyone...                                          DOC04\njan86 anyone    DOCISTAT\n\nD1                                                                        doc04\ndummy DUMMY           dummy\n\nD1       Consolidated                                                     doc04\njan86 ALL       doctmerg\n\nD1       Final                                                            doc04\njan86 FINAL     docfinal\n\nD1                                                                        doc04\ndummy DUMMY           dummy\n\n./ ADD NAME=MISCSAMP 0121-87125-87125-1337-00017-00003-00000-KK00150\nT1 ....................... This is a sample index  .............................\n..\n\nT2   These are some documents for items on the WASHMODS tape.\n\n\nT3   --------------------------------------------------------------------\n\n\nD1 GDDM     - Index for GDDM documents                                    DOC01\nGDDMDOCS 2 DUMMY1\n\nD1 ALLOCGDG - dynamically allocate a GDG generation.                      DOC02\nWDPSC.export.DOCS WHOISI DUMMY1\n\nD1 CLERSCRN - CLIST to clear screen or write blank line.                  DOC02\nWDPSC.export.DOCS UNNUM DUMMY1\n\nD1 CNV2GREG - program to convert dates to Gregorian format.               DOC02\nWDPSC.export.DOCS RJETRANS DUMMY1\n\nD1 DSN      - CLIST to display who is using a dataset.                    DOC02\nWDPSC.export.DOCS NEXTGEN DUMMY1\n\nD1 EXPANDIR - Dialog to add directory blocks to a PDS.                    DOC02\nWDPSC.export.DOCS LOADXREF DUMMY1\n\nD1 INTRDR   - Allocates internal reader files.                            DOC02\nWDPSC.export.DOCS LASTOPEN DUMMY1\n\nD1 JCLXREF  - cross reference programs and PROCs                          DOC02\nWDPSC.export.DOCS JCLXREF DUMMY1\n\nD1 LASTOPEN - show date and jobname for last access to a dataset          DOC02\nWDPSC.export.DOCS INTRDR DUMMY1\n\nD1 LOADXREF - cross reference calling programs to called programs         DOC02\nWDPSC.export.DOCS EXPANDIR DUMMY1\n\nD1 NEXTGEN  - retrieve GDG numbers from a CLIST                           DOC02\nWDPSC.export.DOCS DSN DUMMY1\n\nD1 RJETRANS - rebuild records from 80 byte segments from RJEs             DOC02\nWDPSC.export.DOCS CNV2GREG DUMMY1\n\nD1 UNNUM    - removes line numbers from VB CLISTs for printing            DOC02\nWDPSC.export.DOCS CLERSCRN DUMMY1\n\nD1 WHOISI   - Dialog to display information about current userid.         DOC02\nWDPSC.export.DOCS ALLOCGDG DUMMY1\n\n./ ADD NAME=PRIM     0108-86190-87125-1305-00009-00006-00000-KK00150\nT1 ....................... Sample Primary DOCSYS Index .........................\n..\n\nT2           Documentation Item                       Date of last change\n\n\nT3           _______________________________          ___________________\n\n\nD1 This is a sample subindex of misc documents.                           DOC01\nMISCSAMP 1 DUMMY1\n\nD1 This is a sample subindex for the DOCSYS documents.                    DOC01\nDOCSYSD 1 DUMMY1\n\nD1 Here is a sample item - From an external library.                      DOC02\ndummy1 whoisi wdpsc.export.docs\n\nD1 Here is a sample document - From an internal library.                  DOC03\nCONTROL DOCUMEN DUMMY1\n\nD1 This is a sample Status Report System                                  doc01\nstatus   1 dummy1   type(docstat)\n\nD1 This will transfer to WDPSC Documentation System                       DOCTO\nPRIM     1 DUMMY1   WDPSC  DOCSYS WDPSC-DOC-SYS\n\n./ ADD NAME=SAMPNDEX 0100-86163-86163-1208-00003-00003-00000-KK00150\nT1 ....................... This is a pattern index  ............................\n..\n\nT2   Change these three title lines to whatever you would like to\n\n\nT3   have displayed on the index display screen and save it.            _\n\n\n./ ADD NAME=SCONTROL 0100-86190-86190-1620-00012-00012-00000-KK00150\nT1 .................. Sample Status Report System Control Entries ..............\n..\n\nT2           Control Function\n\n\nT3           ________________\n\n\nD1                                                                        doc04\ndummy dummy           dummy\n\nD1       Pattern                                                          doc04\ncontrol Pattern         docistat\n\nD1                                                                        doc04\ndummy dummy           dummy\n\nD1       Documentation                                                    doc04\ncontrol Documen         docistat\n\nD1                                                                        doc04\ndummy dummy           dummy\n\nD1       Script controls for final report                                 doc04\ncontrol script          docistat\n\nD1                                                                        doc04\ndummy dummy           dummy\n\nD1       Base Index for status reports                                    doc01\ncontrol  1      dummy1\n\nD1                                                                        doc04\ndummy dummy           dummy\n\n./ ADD NAME=STATUS   0111-86190-86190-1824-00007-00008-00000-KX00150\nT1 ....................... Sample Status Report System .........................\n..\n\nT2           Date of reports\n\n\nT3           _______________\n\n\nD1       January    1986                                                  DOC01\nJan86    1 dummy1\n\nD1                                                                        doc02\ndummy dummy dummy\n\nD1       Sample Status System Control Entries                             DOC01\nSCONTROL 1 DUMMY1\n\nD1                                                                        doc02\ndummy dummy dummy\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "INMRZ01": {"ttr": 21006, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x00\\x7f\\x00\\x88\\x00\\x7f\\x12\\x00\\x00\\x8a\\x00\\x8a\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf2\\xf7\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-01-07T00:00:00", "modifydate": "1988-01-07T12:00:00", "lines": 138, "newlines": 138, "modlines": 0, "user": "FILE270"}, "text": "INMRZ01  TITLE 'INMRZ01 - ACF2/TSOE-RECEIVE COMMAND SECURITY EXIT'      00001**2\n********************************************************************    00004**2\n*                                                                       00008**2\n*  THIS EXIT CALLED BY TSOE RECEIVE COMMAND TO AUTHORIZE REQUESTS  *    00009**2\n*       BY GENERATING A PSUEDO DATASET NAME FOR ACF2 CHECKING      *    00009**2\n*                                                                       00021**2\n********************************************************************    00022**2\n         MACRO\n&LAB1    ENTERR  &SA=SAVEAREA,&WA=WORKAREA,&WL=WORKLEN,&LEVEL=,&R=,   XX\n               &CLEAR=YES\n         MNOTE ' CLEAR=&CLEAR,SA=&SA,WA=&WA,WL=&WL,LEVEL=&LEVEL'\n&LAB1    CSECT\n         SAVE  (14,12),,&LAB1-&LEVEL\n         LR    R12,R15            HOPE HE KNOWS WHAT HE'S DOING\n         USING &LAB1,R12\n         LR    R10,R1             SAVE PARM PTR R10->PARM PTR\n         L     R0,=A(&WL)         R0=GET LENGTH\n         GETMAIN R,LV=(0)         R1->WORKAREA\n         LR    R11,R13            R11->CALLERS SAVEAREA\n         LR    R13,R1             R13->WORKAREA\n         USING &WA.,R13\n         AIF   ('&CLEAR' NE 'YES').NCLEAR\n         L     R15,=A(&WL)        R0=GET LENGTH\n         S     R15,=F'72'         SKIP REGS\n         MOVE  72(13),(15),0,0,PAD=X'00'\n.NCLEAR  ANOP\n         ST    R11,&SA.+4         SAVE HIS SAVEAREA PTR\n         LA    R13,&SA            R13->SAVEAREA (MINE)\n         ST    R13,8(,R11)        MINE IN HIS\n         LR    R11,R1             R11->WORKAREA IN CASE NOT SAME AS R13\n*                       WORKAREA ADDR IS STILL R13 FOR\n*                       THE ASSEMBLER - IF DIFFERENT FROM R13\n*                       THEN USE: DROP R13 AND USING &WA.,R11\n         LR    R1,R10             RESTORE PARM PTR PTR\n         AIF   ('&R' EQ 'NO').NRE\n         REGEQU\n.NRE     ANOP\n         MEND\n         MACRO\n&LAB     LEAVER &WR=R13,&WL=WORKLEN\n&LAB     LR    R1,&WR             WORKAREA ADDR FOR FREEMAIN\n         L     R0,=A(&WL)         WORKAREA LEN   \"    \"\n         L     R13,4(R13)         GET CALLERS SAVEAREA ADDR\n         LR    R11,R15            SAVE RETURN CODE\n         FREEMAIN R,LV=(0),A=(1)\n         LR    R15,R11            RESTORE RETURN CODE\n         RETURN (14,12),RC=(15)\n         MEND\n         EJECT                                                          00027**2\nINMRZ01  ENTERR LEVEL=V1M0                                              00028**2\n         EJECT                                                          00042**2\n         LR    R11,R1      R11->PARM LIST\n         L     R1,20(R11)  R1->FLAG BYTE\n         TM    0(R1),X'80' SPOOL REQUEST?\n         BO    EXIT        NO-> ACF2 WILL HANDLE\n         L     R10,24(R11) R10->CURRENT USERID\n         L     R9,28(R11)  R9->REQUESTED USERID\n         CLC   0(8,R9),0(R10)     NORMAL REQUEST?\n         BNE   CHEKACF2    NO->BETTER CROSS CHECK\nEXIT     SLR   R15,R15            RC=0\nRET      LEAVER\n         EJECT\n*\n*  FIND ACF2 CVT\n*\nCHEKACF2 ACFGACVT R8,NONE=EXIT                                          00043**2\n         USING ACCVT,R8           R8 = A(ACF2 CVT)                      00044**2\n         SPACE\n         L     R3,8(R11)          R3->ACTION FLAGS\n         L     R6,4(R11)          R6->PARM STRING\n         LH    R7,0(R6)           R7=PARM LEN\n         CH    R7,=H'5'           <5?\n         BL    NOTWDPSC\n         CLC   2(5,R6),=C'WDPSC'  WDPSC SPOOL MAINT JOB?\n         BNE   NOTWDPSC           NOPE\n         EJECT\n*\n*   ACCESS THE USER'S ACUCB (THIS CODE IS WDPSC SPECIFIC):\n*        CHECK TO OK SPOOL MAINT TYPE JOBS\n*\n         ACFGUCB R4,NONE=EXIT\n         USING ACUCB,R4\n         L     R5,ACUUIDP         R5->WDPSC UID STRING\n         CLC   0(8,R5),=CL24'150D2100'   OS SUPPORT?\n         BE    OKDOKE\n         CLC   0(8,R5),=CL24'150D2300'   NET SERVICES?\n         BE    OKDOKE\n         EJECT                                                          00045**2\n*\n*   IF OPER BIT IS NOT ON, THEN ASK ACF2 FOR AUTH:\n*\nNOTWDPSC L     R1,12(R11)         R1->CPPL                                  6**2\n         L     R2,8(R1)           R2->PSCB PASSED\n         TM    16(R2),X'80'       OPER BIT ON?\n         BO    EXIT               YES->HE'S OK\n*\n*   BUILD PARM LIST TO ASK ACF2 IF RECEIVE IS OK:\n*\n         XC    ACFSPARM(ACFSPRML),ACFSPARM  CLEAR ACF2 PARM BLOCK       00046**2\n         MVI   ACFSPREQ,ACFSPRDS      DSNAME CHECK                      00047**2\n         MVI   ACFSPID1,ACFSPIUR   USER CALL                            00047**2\n         MVI   ACFSPAC1,ACFSPAOT+ACFSPAXX ALLOC TYPE,LIST END\n         MVC   FONYDSN,=CL44' '   CLEAR\n         MVC   FONYDSN(8),0(R9)   COPY PSUEDO USERID\n         LA    R6,FONYDSN         R6->DSN BLD AREA\nFLOOP    CLI   0(R6),C' '         FIND BLANK?\n         BE    GOT1               YUP\n         LA    R6,1(R6)           R6+1\n         B     FLOOP\nGOT1     MVC   0(13,R6),=C'.RECEIVE.FILE'\n         LA    R6,FONYDSN         R6->DSN BLD AREA\n         ST    R6,ACFSPDSN        ->DSNAME\n*\n* NOW CHECK THE PSUEDO DSN WITH ACF2 FOR AUTHORIZATION:\n*\n         ACFSVC ACDSV,TYPE=S,CVT=HAVE,NONE=EXIT                         00071**2\n         LTR   R15,R15            OK?\n         BZ    OKDOKE             YUP!\nABORT    OI    0(R3),X'04'        SAY NONO!!!!\n         B     EXIT\nOKDOKE   OI    0(R3),X'08'        SAY OK!\n         B     EXIT               STILL OK!\n         EJECT                                                          00090**2\n         LTORG                                                          00094**2\n         EJECT\nWORKAREA DSECT\nSAVEAREA DS    18F\nFONYDSN  DS    CL44\n         EJECT                                                          00088**2\n         ACDSV DSECT=NO                                                 00089**2\nWORKLEN  EQU   *-WORKAREA\n         EJECT                                                          00095**2\n         ACCVT                                                          00096**2\n         EJECT\n         ACUCB\n         EJECT\n         ACFASVT\n         END                                                            00097**2\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "INTRDR": {"ttr": 21249, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x00\\x7f\\x00\\x88\\x00\\x7f\\x12\\x00\\x00\\xd9\\x00\\xd9\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf2\\xf7\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-01-07T00:00:00", "modifydate": "1988-01-07T12:00:00", "lines": 217, "newlines": 217, "modlines": 0, "user": "FILE270"}, "text": "**************\n*   INTRDR   *\n**************\n*\n*        THIS PROGRAM IS A SUBROUTINE WHICH WILL ACCEPT A DDNAME\n*        PASSED TO IT IN THE PARAMETER LIST AND THEN DYNAMICALLY\n*        ALLOCATE THE INTERNAL READER TO THAT DDNAME\n*\n********************************************************************\n*\n*        TO CALL THIS PROGRAM FROM A CLIST, DO THE FOLLOWING:\n*\n*           CALL 'WDPSC.SHARED.LOAD(INTRDR)' '&DDNAME'\n*\n*                   WHERE &DDNAME CONTAINS THE DDNAME\n*\n********************************************************************\n*\n*        TO CALL THIS SUBROUTINE FROM A PROGRAM, DO THE FOLLOWING:\n*\n*           MOVE THE LENGTH OF YOUR DDNAME TO DDNAME-LENGTH\n*                INTRDR-I-O-AREA.\n*           MOVE YOUR DDNAME TO DDNAME OF INTRDR-I-O-AREA.\n*\n*           CALL 'INTRDR' USING INTRDR-I-O-AREA.\n*\n*                WHERE:\n*\n*                      01  INTRDR-I-O-AREA.\n*                          05  DDNAME-LENGTH    PIC S9(4) COMP.\n*                          05  DDNAME           PIC X(8).\n*\n*********************************************************************\n*\n*         RETURN CODES        MEANING\n*         ------------        -----------------------------------\n*\n*              0              ALLOCATION WAS SUCCESSFUL\n*              4              ALLOCATION ERROR\n*              8              INVALID DDNAME PASSED TO THIS PROGRAM\n*\n         EJECT\nINTRDR   CSECT\n         SAVE  (14,12)\n         BALR  12,0\n         USING *,12\n         ST    13,SAVEAREA+4\n         LA    13,SAVEAREA\n         B     STARTIT\n         SPACE\nSAVEAREA DC    18F'0'\n*\n********************************************************************\n*        EQUATE RESISTERS 0 THRU 15 TO MORE MEANINGFUL NAMES       *\n********************************************************************\n*\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n         EJECT\n         SPACE 3\n********************************************************************\n*        SAVE REGISTER 1 CONTENTS IN REGISTER 11 AND PLACE         *\n*        PARAMETER INTO IOAREA                                     *\n********************************************************************\n*\nSTARTIT  DS    0D\n         LR    R11,R1\n         L     R9,0(R11)\n         MVC   IOAREA,0(R9)\n         EJECT\n         SPACE 3\n*\n********************************************************************\n*        LOAD THE LENGTH OF THE DDNAME AND THE DDNAME INTO THE     *\n*        DYNAMIC UNALLOCATION AND DYNAMIC ALLOCATION WORK AREAS    *\n********************************************************************\n*\n         LA    R4,0                 R4==> 0\n         LH    R7,INDDNLN           R7==> LENGTH OF DDNAME\n         CH    R7,=H'0'             LENGTH NOT GREATER THAN 0 ?\n         BNH   NOGOOD               IF SO, BRANCH TO NOGOOD\n         CH    R7,=H'8'             LENGTH GREATER THAN 8 ?\n         BH    NOGOOD               IF SO, BRANCH TO NOGOOD\n         MVC   DD1DDNLN,INDDNLN     DD1DDNLN==> LENGTH OF DDNAME\n         MVC   FREEUT1A,INDDNLN     FREEUT1A==> LENGTH OF DDNAME\n         MVC   DD1DDNAM,INDDNAM     DD1DDNAM==> DDNAME\n         MVC   FREEUT1B,INDDNAM     FREEUT1B==> DDNAME\n         B     DODYNAM              BRANCH TO DODYNAM\nNOGOOD   LA    R4,8                 R4==> 8\n         B     SHUTDOWN             BRANCH TO SHUTDOWN\n         EJECT\n         SPACE 3\n*\n********************************************************************\n*        DO DYNAMIC ALLOCATION                                     *\n********************************************************************\n*\nDODYNAM  LA    R1,FREEPARM\n         DYNALLOC                      FREE DDNAME\n         LTR   R15,R15                 TEST REGISTER 15 FOR ZERO\n         BZ    DYNALLOK                IF ZERO, BRANCH TO DYNALLOK\n         CLC   ERCODE,=XL2'0438'       COMPARE ERROR REASON CODE\n*                                         AGAINST HEXADECIMAL 0438\n         BE    DYNALLOK                IF EQUAL, BRANCH TO DYNALLOK\n         LA    R4,4                    R4==> 4\n         B     SHUTDOWN                BRANCH TO SHUTDOWN\nDYNALLOK LA    R1,DD1PARM\n         DYNALLOC                      ALLOC F(DDNAME) DA(DSN) SHR\n         LTR   R15,R15                 TEST REGISTER 15 FOR ZERO\n         BZ    SHUTDOWN                IF ZERO, BRANCH TO SHUTDOWN\n         LA    R4,4                    R4==> 4\n         B     SHUTDOWN                BRANCH TO SHUTDOWN\n         EJECT\n         SPACE 3\n*\n********************************************************************\n*        E N D   O F   J O B   P R O C E S S I N G                 *\n********************************************************************\n*\nSHUTDOWN LR    R15,R4\n         L     R13,4(R13)\n         RETURN (14,12),RC=(15)\n         EJECT\n         SPACE 3\n*\n********************************************************************\n*                                                                  *\n*        DATA STRUCTURE FOR FREEING OF DDNAME                      *\n*                                                                  *\n********************************************************************\n*\n         SPACE 3\n         DS    0F\nFREEPARM DC    X'80'         TURN ON HIGH ORDER BIT\n         DC    AL3(FREERB)   ADDRESS OF REQUEST BLOCK\nFREERB   DC    X'14'         S99RBLN (LENGTH OF REQUEST BLOCK)\n         DC    X'02'         S99VERB (REQUEST FOR UNALLOCATION)\n         DC    X'2000'       S99FLAG1 (DO NOT MOUNT VOLUMES)\nERCODE   DC    X'0000'       S99ERROR (ERROR REASON CODE)\n         DC    X'0000'       S99INFO (INFORMATION REASON CODE)\n         DC    A(FREETUPL)   S99TXTPP (ADDR OF POINTER TO TEXT UNIT)\n         DC    X'00000000'   RESERVED\n         DC    X'00000000'   S99FLAG2\nFREETUPL DC    A(FREEUNT1)   ADDRESS OF TEXT UNIT #1\n         DC    X'80'         TURN ON HIGH ORDER BIT\n         DC    AL3(FREEUNT2) ADDRESS OF TEXT UNIT #2\nFREEUNT1 DC    X'0001'\n         DC    X'0001'\nFREEUT1A DS    BL2           LENGTH OF DDNAME\nFREEUT1B DS    CL8           DDNAME\nFREEUNT2 DC    X'0007'\n         DC    X'0000'       REMOVE PERM ALLOC ATTR\n         EJECT\n         SPACE 3\n*\n********************************************************************\n*                                                                  *\n*        DATA STRUCTURE FOR DYNAMIC ALLOCATION                     *\n*                                                                  *\n********************************************************************\n*\n         SPACE 3\n         DS    0F\nDD1PARM  DC    X'80'         TURN ON HIGH ORDER BIT\n         DC    AL3(DD1RB)    ADDRESS OF REQUEST BLOCK\nDD1RB    DC    X'14'         S99RBLN (LENGTH OF REQUEST BLOCK)\n         DC    X'01'         S99VERB (REQUEST FOR DSNAME ALLOC)\n         DC    X'2000'       S99FLAG1 (DO NOT MOUNT VOLUMES)\n         DC    X'0000'       S99ERROR (ERROR REASON CODE)\n         DC    X'0000'       S99INFO (INFORMATION REASON CODE)\n         DC    A(DD1TUPL)    S99TXTPP (ADDR OF POINTERS TO TEXT UNITS\n         DC    X'00000000'   RESERVED\n         DC    X'00000000'   S99FLAG2\nDD1TUPL  DC    A(DD1UNIT1)   ADDRESS OF TEXT UNIT #1\n         DC    A(DD1UNIT2)   ADDRESS OF TEXT UNIT #2\n         DC    A(DD1UNIT3)   ADDRESS OF TEXT UNIT #3\n         DC    X'80'         TURN ON HIGH ORDER BIT\n         DC    AL3(DD1UNIT4) ADDRESS OF TEXT UNIT #4\nDD1UNIT1 DC    X'0001'\n         DC    X'0001'\nDD1DDNLN DS    XL2           LENGTH OF DDNAME\nDD1DDNAM DS    CL8           DDNAME\nDD1UNIT2 DC    X'0018'\n         DC    X'0001'\n         DC    X'0001'\n         DC    C'A'          SYSOUT=(A\nDD1UNIT3 DC    X'0019'\n         DC    X'0001'\n         DC    X'0006'\n         DC    CL6'INTRDR'   SYSOUT=(A,INTRDR)\nDD1UNIT4 DC    X'0052'\n         DC    X'0000'       PERMANENTLY ALLOCATED ATTRIBUTE\n         EJECT\n         SPACE 3\n********************************************************************\n*        DATA AREAS                                                *\n********************************************************************\n         SPACE 3\n         DS    0D\nIOAREA   DS    0CL10\nINDDNLN  DS    CL2\nINDDNAM  DS    CL8\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "ISPCDSN": {"ttr": 21254, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x00\\x7f\\x00\\x88\\x00\\x7f\\x12\\x00\\x02+\\x02+\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf2\\xf7\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-01-07T00:00:00", "modifydate": "1988-01-07T12:00:00", "lines": 555, "newlines": 555, "modlines": 0, "user": "FILE270"}, "text": "ISPCDSN TITLE ' - DATASET SELECTION BY CURSOR FROM ISPF DISPLAY'\n***********************************************************************\n***                                                                 ***\n***  Author:                                                        ***\n***      Gordon J. Schillinger                                      ***\n***      Washington Data Processing Service Center                  ***\n***      Ph.  (206) 902-3147                           03/19/87     ***\n***                                                                 ***\n***                                                                 ***\n***  Modification log:                                              ***\n***                                                                 ***\n***      V3R1                                          10/20/88     ***\n***        - Provided a default variable name to contain the        ***\n***          dataset name, with an option to override.              ***\n***        - Added an additional variable to dataset processing     ***\n***          that returns the cursor position within the dsname.    ***\n***        - Allow coding of an options list to include or limit    ***\n***          the amount of information returned to the application. ***\n***        - Added an option to obtain cursor position on screen    ***\n***          as well as the current panel id.                       ***\n***        - Added an option to allow the extraction of an entire   ***\n***          ISPF panel screen image.                               ***\n***                                                                 ***\n***      V2R1                                          03/01/88     ***\n***        - Extracts dataset names from updated screen image to    ***\n***          allow processing of message fields.                    ***\n***        - Extracts member names or dataset names within a set    ***\n***          of parentheses.                                        ***\n***        - Allows cursor positioning on beginning and ending      ***\n***          quotes and parentheses.                                ***\n***                                                                 ***\n***      Original version                              03/19/87     ***\n***                                                                 ***\n***********************************************************************\n         EJECT\n***********************************************************************\n***                                                                 ***\n***  Ispcdsn will extract a dataset, pointed to by the cursor,      ***\n***  from an ISPF display panel.  Dataset names are scanned for     ***\n***  following standard naming and length conventions.              ***\n***                                                                 ***\n***  Optionally, an override variable name to contain the dataset   ***\n***  name may be passed to the program as a parameter, and will be  ***\n***  placed into the SHARED variable pool if no errors are          ***\n***  encountered.  If errors are encountered, a return code         ***\n***  reflecting the type of error will be returned following        ***\n***  completion of the program.  Although this was previously a     ***\n***  required parameter, it is no longer necessary since the        ***\n***  dataset name is returned, by default, to the variable          ***\n***  &ISPCDSN.                                                      ***\n***                                                                 ***\n***  Other enhancements include the availablity of screen           ***\n***  statistics pertaining to cursor location and panel id and the  ***\n***  availablity of a full screen image.                            ***\n***                                                                 ***\n***  Return Codes:                                                  ***\n***    (4)  - Dataset name contains unmatched quotes                ***\n***    (8)  - Dataset name missing between quotes                   ***\n***    (12) - Cursor not on a dataset name                          ***\n***    (16) - Dataset name larger than the 56 byte maximum          ***\n***    (20) - Control Block parameter error                         ***\n***                                                                 ***\n***********************************************************************\n         EJECT\n***********************************************************************\n***                                                                 ***\n***   SYNTAX:                                                       ***\n***                                                                 ***\n***   ISPCDSN SELECT PGM(ISPCDSN) PARM(xxxx (NODsn  ))              ***\n***                                          SCReen                 ***\n***                                          FSCReen                ***\n***   where:                                                        ***\n***      xxxx    - is the name of the variable in which you wish    ***\n***                use as an override to the default dataset        ***\n***                variable &ISPCDSN.   (OPTIONAL, user specified)  ***\n***                                                                 ***\n***      NODsn   - requests ISPCDSN to bypass dataset name          ***\n***                processing.  This is the default when FSCReen    ***\n***                is specified.  If not specified with SCReen      ***\n***                option, cursor must be on a valid dataset name.  ***\n***                Otherwise, a bad return code indicating the      ***\n***                invalidity of the dataset string will be set     ***\n***                and none of the variables will be return via     ***\n***                the shared variable pool.   (OPTIONAL)           ***\n***                                                                 ***\n***      SCReen  - requests screen characteristics be returned,     ***\n***                which include cursor row position (&ISPCROW),    ***\n***                cursor column position (&ISPCCOL), and panel     ***\n***                id of current display (&ISPCPID).   (OPTIONAL)   ***\n***                                                                 ***\n***      FSCReen - requests the full set of screen information      ***\n***                variables, which consists of ones set by SCReen  ***\n***                and one which returns a mirror image of the      ***\n***                current screen (&ISPCSCR).  The screen image     ***\n***                size (in bytes) is returned in &ISPCSCS.  By     ***\n***                default, dsname processing is bypassed unless    ***\n***                an override dsn is specified.   (OPTIONAL)       ***\n***                                                                 ***\n***      NOTE:  All parameters are optional.  Therefore, if none    ***\n***             are specified, only dataset processing is           ***\n***             performed.  This is due, in part, to the fact that  ***\n***             this was the only function ISPCDSN was originally   ***\n***             designed to perform.  Added to the dataset          ***\n***             processing was the returning of the cursor          ***\n***             position within the dataset string in &ISPCPOS.     ***\n***                                                                 ***\n***     VARIABLES RETURNED:                                         ***\n***        &ISPCDSN or &xxxx - dataset name at cursor               ***\n***        &ISPCPOS          - cursor position in dataset string    ***\n***        &ISPCROW          - cursor row position on screen        ***\n***        &ISPCCOL          - cursor col position on screen        ***\n***        &ISPCPID          - current paned id of display          ***\n***        &ISPCSCS          - screen size (bytes) returned         ***\n***        &ISPCSCR          - screen image currently displayed     ***\n***                                                                 ***\n***********************************************************************\n         EJECT\n***********************************************************************\n***          --- V3R1 Examples ---                                  ***\n***                                                                 ***\n***    ISPEXEC SELECT PGM(ISPCDSN)                                  ***\n***    IF &LASTCC = 0 THEN +                                        ***\n***      ISPEXEC VGET (ISPCDSN) SHARED                              ***\n***    - will, by default, return the dsname in &ISPCDSN, along     ***\n***      with the cursor position, &ISPCPOS, within the dsname.     ***\n***                                                                 ***\n***    ISPEXEC SELECT PGM(ISPCDSN) PARM(DSN (FSCR))                 ***\n***    ISPEXEC VGET (DSN ISPCSCR) SHARED                            ***\n***    - will return dsname in &DSN, cursor position within dsname  ***\n***      in &ISPCPOS, and the entire screen image in &ISPCSCR.      ***\n***      Also, &ISPCROW, &ISPCCOL and &ISPCPID will contain cursor ***\n***      position and panel id.  If DSN were not specified as an    ***\n***      override dsn, the dsname would not have been returned to   ***\n***      the application, as it is mutually exclusive with FSCREEN, ***\n***      by default.                                                ***\n***                                                                 ***\n***    ISPEXEC SELECT PGM(ISPCDSN) PARM( (SCR))                     ***\n***    ISPEXEC VGET (DSN ISPCSCR) SHARED                            ***\n***    - will return dsname in &ISPCDSN, cursor position within     ***\n***      dsname in &ISPCPOS, and cursor row, column and panel id    ***\n***      in &ISPCROW, &ISPCCOL, and &ISPCPID.                       ***\n***                                                                 ***\n***********************************************************************\n         EJECT\n***********************************************************************\n*                 --V2R1 EXAMPLES--    ( | = CURSOR IN EXAMPLES)      *\n* Here's an example of the updated screen image enhancement.  Prior   *\n* to V2R1, trying to extract this VIO dsn following a compress        *\n* would result in a null line.  Now; however, the VIO dataset         *\n* displayed when help is entered can be browsed to view the output    *\n* from the compress operation.  (via HOTKEYS)                         *\n*                                                                     *\n* ----------------------------  LIBRARY UTILITY  ----------- COMPRESS *\n* OPTION  ===>                                                        *\n* COMPRESS LISTING IS IN SYS88062.T095611.RA000.GS#00155.R0000004     *\n*    BLANK - DISPLAY MEMBER LIST   |       B - BROWSE MEMBER          *\n*    C - COMPRESS DATA SET                 P - PRINT MEMBER           *\n*    X - PRINT INDEX LISTING               R - RENAME MEMBER          *\n*    L - PRINT ENTIRE DATA SET             D - DELETE MEMBER          *\n*    I - DATA SET INFORMATION              S - DATA SET INFORMATION (S*\n*                                                                     *\n* ISPF LIBRARY:                                                       *\n*    PROJECT ===> SOFTD155                                            *\n*    GROUP   ===> MISC      ===>           ===>           ===>        *\n*    TYPE    ===> CLIST                                               *\n*                                                                     *\n*                                                                     *\n* RESULTS IN:                                                         *\n*                                                                     *\n* BROWSE -- SYS88062.T095611.RA000.GS#00155.R0000004 - LINE 000000 COL*\n* COMMAND ===>                                                  SCROLL*\n* ********************************* TOP OF DATA  **********************\n* -----   PDSFAST/XA      VER 3.3FC        CPUID 3084-66122146        *\n*    COPYRIGHT (C) 1986 SOFTWARE ENGINEERING OF AMERICA, INC.       DA*\n*                                                                     *\n* PDF101I  START PDSFAST EXECUTION                                    *\n*                                                                     *\n* PDF103C        COPY OUTDD=ISP09561,INDD=ISP09561                    *\n* PDF106F  COMPRESS VOLSER/DSN: SYS014 / GS00155.JOBS.CNTL            *\n* PDF110I  OPERATION IS COMPRESS - ISP09561 (DISK)                    *\n* PDF156M  ADMUSP6   - MOVED -    ADR 000225  0019000225              *\n* PDF156M  ALIST     IN PLACE     ADR 00011D  001900011D              *\n* PDF156M  APDGEOF   IN PLACE     ADR 00001D  001900001D              *\n* PDF156M  APGDSTY   IN PLACE     ADR 000027  0019000027              *\n* PDF156M  COPYFILE  IN PLACE     ADR 00001B  001900001B              *\n* PDF156M  CSRDSN    - MOVED -    ADR 000301  0019000301              *\n* PDF156M  CT        IN PLACE     ADR 000025  0019000025              *\n* PDF156M  DEFNTABL  - MOVED -    ADR 000217  0019000217              *\n*                                                                     *\n***********************************************************************\n         EJECT\n***********************************************************************\n*                 --V2R1 EXAMPLES--  (cont.)                          *\n* Here's an example of the dsname within parentheses enhancement:     *\n*                                                                     *\n*  ALLOC F(CDSN) DSN(MY.LOAD)                                         *\n*                       |                                             *\n*                                                                     *\n*    Now returns \"MY.LOAD\" instead of \"DSN(MY.LOAD)\" which would      *\n*    result in an \"INVALID DATASET NAME\" when processed, as in        *\n*    the previous release.                                            *\n*                                                                     *\n*    A dataset name and member may be extracted as before if cursor   *\n*    is placed on the dataset name portion:                           *\n*                                                                     *\n*  SRC.ASM(ISPCDSN)                                                   *\n*       |                                                             *\n*                                                                     *\n*                                                                     *\n*  Cursor may be positioned on beginning or ending quotes:            *\n*                                                                     *\n*  'GS00155.SRC.ASM(ISPCDSN)'                                         *\n*  |                                                                  *\n*           OR                                                        *\n*  'GS00155.SRC.ASM(ISPCDSN)'                                         *\n*                           |                                         *\n*   ...however, the first would return the dsn and member and         *\n*      the second, only the member.                                   *\n*                                                                     *\n***********************************************************************\n         EJECT\nISPCDSN  ENTERR WA=WORKAREA,SA=SAVEAREA,WL=WORKLEN,LEVEL=V310\n         EJECT\n***********************************************************************\n***                  REGISTER USAGE                                 ***\n***      R2 = WORK                R3 = WORK                         ***\n***      R4-> TLD CONTROL BLOCK   R5->CURRENT SCREEN IMAGE          ***\n***      R6 = OFFSET TO CURSOR    R7 = WORK                         ***\n***      R8-> DSNAME LEFT DELIM   R9-> CURSOR ON SCREEN             ***\n***      R10= WORK                R11->ENTRY PARMLIST               ***\n***********************************************************************\n         LR    R11,R1             R11-> PARMLIST\n         L     R4,0(R11)          R4->  CONTROL BLOCK\n         BAL   R14,FMTPARMS       FORMAT ENTRY PLIST\n         CLC   0(2,R4),=C'TLD'    ARE WE AT A TLD?\n         BE    VARINIT            YES, INITIALIZE VARS\n         SETRET RC=20             NO,  EXIT WITH RC(20)\nVARINIT  BAL   R14,IVAR           INITIALIZE ISPF VARIABLES\nGETCSR   L     R5,128(R4)         R5-> CURRENT SCREEN IMAGE\n         LH    R6,166(R4)         R6 = OFFSET TO CURSOR\n         TM    OPFLAG,X'06'       SCR OR FSCR?\n         BZ    GETDSN             NO,  SKIP SCREEN PROCESSING\nGETINFO  BAL   R14,SCRSTATS       YES, GET SCREEN INFO\n         TM    OPFLAG,X'84'       OVERRIDE DSN & FSCR?\n         BO    GETDSN             YES, PROCESS DSN\n         TM    OPFLAG,X'0C'       NODSN, OR FSCR?\n         BNZ   SETEM              YES, SKIP DSN PROCESSING\nGETDSN   MVC   TRNTBL,TBLINIT     NO,  INIT DSN TRANS TABLE\n         BAL   R14,DSNPROC             & EXTRACT DSNAME\n         LTR   R15,R15            DSNPROC RC=(0)?\n         BNZ   RETURN             NO, RETURN W/ BAD RC\nSETEM    BAL   R14,SVAR           SET SHARED VARIABLES\n         SETRET                   RC(0); NO ERRORS\n*\n* RETURN TO WHOEVER CALLED US:\nRETURN   LEAVER\n         EJECT\n***********************************************************************\n***            SUBROUTINE TO PARSE ENTRY PARMLIST                   ***\n***              ENTRY:   R11-> ISPCDSN ENTRY PLIST                 ***\n***********************************************************************\nFMTPARMS ST    R14,RETADDR\n         L     R3,4(R11)          R3-> NON-STD CMD BUFF\n         PARSEKMD BUFF=(R3),BUFFLEN=100,FLAG=OPFLAG,PARM=WORKAREA\n         L     R14,RETADDR\n         BR    R14\n         EJECT\n***********************************************************************\n***           SUBROUTINE TO EXTRACT SCREEN STATISTICS               ***\n***             ENTRY:   R5-> CURRENT SCREEN IMAGE                  ***\n***                      R6 = SCREEN OFFSET TO CSR                  ***\n***********************************************************************\nSCRSTATS ST    R14,RETADDR\n         IC    R3,=C')'\n         STC   R3,USRVARS-1       MARK END OF SYSVAR LIST\n         LA    R2,VARNAMES\n         CALL ISPLINK,(=CL8'VGET',0(R2),=CL8'SHARED'),VL,MF=(E,RPPL)\n         IC    R3,=C' '\n         STC   R3,USRVARS-1       RESET LIST\n         LR    R3,R6              COPY OFFSET TO LOW ORDER REG\n         LA    R3,1(,R3)          CVT OFFSET TO REL SCR POS\n         LA    R2,0               CLEAR HIGH ORDER REG\n         D     R2,SCRW            R2 = CSR COL POSITION\n         LTR   R2,R2              CSR = LRECL?\n         BZ    SETPOS             YES, NO ADJ REQUIRED\n         LA    R3,1(,R3)          NO,  ADJ ROW POSITION\nSETPOS   ST    R2,CSRCOL          SAVE COL POSITION\n         ST    R3,CSRROW          SAVE ROW POSITION\n         MVC   PANELID(8),344(R4) CAPTURE PANEL ID\n         TM    OPFLAG,X'04'       FSCREEN?\n         BNO   SCRRET             NO,  SKIP IT\n         LH    R2,SCRW+2          GET SCREEN WIDTH\n         MH    R2,SCRD+2          CALC SCREEN SIZE\n         ST    R2,SCRSIZE         STORE SCREEN SIZE IN POOL\n         MOVE  SCREEN,(R2),(R5)   CAPTURE SCREEN IMAGE\nSCRRET   L     R14,RETADDR\n         BR    R14\n         EJECT\n***********************************************************************\n***           SUBROUTINE TO INITIALIZE ISPF VARIABLES               ***\n***********************************************************************\nIVAR     ST    R14,RETADDR\n         MVC   VARRAYS(VARRLEN),VARRINIT   INITIALIZE ARRAYS\n         MVI   DSNAME,C' '\n         MVC   DSNAME+1(55),DSNAME         CLEAR DSNAME\n         MVC   PANELID(8),=CL8' '          CLEAR PANELID\n         LA    R2,VARNAMES                 R2-> VARIABLE LIST\n         CALL ISPLINK,(=CL8'VDEFINE',0(R2),VARSTOR,VARFMTS,            X\n               VARLENS,=CL8'LIST'),VL,MF=(E,RPPL)\n         L     R14,RETADDR\n         BR    R14\n***********************************************************************\n***           SUBROUTINE TO REPLACE AN ISPF VARIABLE                ***\n***********************************************************************\nRVAR     ST    R14,RETADDR2\n         LA    R2,ODSNVAR+2       R2-> REPLACEMENT VAR NAME\n         CALL ISPLINK,(=CL8'VREPLACE',0(R2),=F'56',DSNAME),            X\n               VL,MF=(E,RPPL)\n         L     R14,RETADDR2\n         BR    R14\n         EJECT\n***********************************************************************\n***           SUBROUTINE TO PROCESS DATA SET NAME                   ***\n***             ENTRY:  R5-> SCREEN IMAGE                           ***\n***                     R6-> OFFSET TO CURSOR                       ***\n***********************************************************************\nDSNPROC  ST    R14,RETADDR\n         LA    R15,0              NORMAL RC\n         LA    R9,0(R6,R5)        R9-> CURSOR LOCATION\n         LR    R3,R6              R3 = COPY OF CSR OFFSET\n         LA    R7,0               CLR FOR TABLE MODIFY\n         IC    R7,=C'('\n         STC   R7,TRNTBL(R7)      MAKE LEFT PAREN A DELIMETER\n         TRT   0(1,R9),TRNTBL     ARE WE ON DATA SET NAME?\n         BZ    SCANLFT            YES, BEGIN SCANNING FOR START\n         CLI   0(R9),C'('         IS IT LEFT PAREN?\n         BZ    EXPARENS           YES, EXTRACT WITHIN PARENS\n         CLI   0(R9),C''''        IS IT A QUOTE?\n         BNZ   CSRINVLD           NO, CURSOR INVALID\n         TRT   1(1,R9),TRNTBL     IS DSN TO RIGHT OF QUOTE?\n         BZ    SCANLFT            YES, PREPARE TO EXTRACT IT\n         BCTR  R9,0               NO,  CHECK LEFT OF QUOTE\n         TRT   0(1,R9),TRNTBL     WAS IT THERE?\n         BNZ   CSRINVLD           NO,  CURSOR INVALID\n         BCTR  R6,0               YES, BACK SPACE CURSOR\n         B     SCANLFT                 AND SCAN LEFT\nCSRINVLD SETRET RC=12,L=DSNRET    EXIT WITH RC(12)\nSCANLFT  LA    R9,0(R6,R5)        R9-> CURSOR LOCATION\n         TRT   0(1,R9),TRNTBL     BYTE IN TABLE?\n         BNZ   LFTDELTR           NO,  FOUND LEFT DELIMETER\n         BCTR  R6,R0              YES, DECREMENT OFFSET; CHECK NEXT\n         B     SCANLFT\nLFTDELTR CLI   0(R9),C'('         WAS DELIMETER LEFT PAREN?\n         BNE   INPARENS           NO, INCLUDE PARENS IN DSN\nEXPARENS IC    R7,=C')'\n         STC   R7,TRNTBL(R7)      MAKE RIGHT PAREN A DELIMETER\n         B     LFTPTR             EXTRACT WITHING PARENS\nINPARENS IC    R7,=C'('\n         LA    R8,0\n         STC   R8,TRNTBL(R7)      INCLUDE PARENS IN DSN IF PRESENT\n         CLI   0(R9),C''''        WAS DELIMETER A QUOTE?\n         BNE   LFTPTR             NO,  LEAVE BITS UNCHANGED\n         OI    QFLAG,X'40'        YES, FLIP BIT 6; INDICATES LEFT QUOTE\nLFTPTR   LA    R8,0(R9)           R8-> LEFT DELIMETER\n         LA    R6,1(R6)           INCR TO LEFTMOST POSITION\n         LA    R9,0(R6,R5)        R9-> LEFT POSITION OF DSNAME\n         SR    R1,R1              CLEAR FOR TEST\n         SR    R2,R2              CLEAR FOR TEST\nSCANRT   TRT   0(56,R9),TRNTBL    SCAN UNTIL NOT IN TABLE OR BUFFER END\n         CR    R1,R2              HAVE REGS. CHANGED?\n         BNE   EXTRACT            YES, EXTRACT DATASET\n         SETRET RC=16,L=DSNRET    NO,  EXIT WITH RC(16)\nEXTRACT  LA    R7,0(R1)           R7-> RIGHT DELIMETER\n         CLI   0(R7),C''''        WAS DELIMETER A QUOTE?\n         BNE   MASKCHK            NO,  LEAVE BITS UNCHANGED\n         OI    QFLAG,X'80'        YES, FLIP BIT 7;INDICATES RIGHT QUOTE\nMASKCHK  TM    QFLAG,X'C0'        CHECK FOR QUOTES SURROUNDING DSNAME\n         BZ    SETVPREP           NO QUOTES\n         BO    QUOTES             MATCHING QUOTES\n         SETRET RC=4,L=DSNRET     UNMATCHED; EXIT WITH RC(4)\nQUOTES   LA    R9,0(R8)           PICK UP LEFT QUOTE\n         BCTR  R6,0               ADJ OFFSET TO QUOTE\n         BCTR  R7,0               DECR TO RT DELIMETER-1\n         CR    R9,R7              ARE ADDRESSES SAME?\n         BNE   RTQUOTE            NO,  INCLUDE RIGHT QUOTE\n         SETRET RC=8,L=DSNRET     YES, MISSING DSNAME; EXIT WITH RC(8)\nRTQUOTE  LA    R7,2(R7)           PICK UP RIGHT QUOTE\nSETVPREP SR    R7,R9              R7 = LENGTH OF DATASET NAME\n         BCTR  R7,0               ADJ FOR EX\n         EX    R7,COPYDSN         COPY DSN TO VAR STOR AREA\n         TM    OPFLAG,X'80'       OVERRIDE DEFAULT DSN VAR?\n         BNO   DSNPOS                NO,  RETAIN DEFAULT\n         MVC   USRVARS(8),ODSNVAR+2  YES, UPDATE VAR IN LIST\n         BAL   R14,RVAR           CREATE NEW VAR & COPY OLD\nDSNPOS   SR    R3,R6              CALC CSR POS IN DSN\n         LA    R3,1(,R3)          R3 = CVT'D REL POS\n         ST    R3,CSRPOS          PLACE IN FUNC VAR POOL\nDSNRET   L     R14,RETADDR\n         BR    R14\nCOPYDSN  MVC   DSNAME(0),0(R9)\n         EJECT\n***********************************************************************\n***           SUBROUTINE TO SET ISPF VARIABLES                      ***\n***********************************************************************\nSVAR     ST    R14,RETADDR\n         LA    R2,USRVARS-1\n         IC    R3,=C'('\n         STC   R3,0(R2)\n         CALL ISPLINK,(=CL8'VPUT',0(R2),=CL8'SHARED'),VL,MF=(E,RPPL)\n         L     R14,RETADDR\n         BR    R14\n         EJECT\n***********************************************************************\n***                  PARSE MACRO AREA                               ***\n***********************************************************************\nOPLIST   OPERLIST SUBL,POS         PARSE SUBL FIRST; POS IS OPTIONAL\nPOS      OPER ,X'8000',POSITIONAL=YES,SUBFLD=ODSNVAR\nSUBL     OPER ,X'4000',SUBLIST=SUBLST,POSITIONAL=YES\nSUBLST   OPERLIST SKWD1,SKWD2,SKWD3\nSKWD1    OPER NODSN,X'0800',MINLEN=3\nSKWD2    OPER FSCREEN,X'0400',MINLEN=4\nSKWD3    OPER SCREEN,X'0200',MINLEN=3\n         EJECT\n***********************************************************************\n***           TRANSLATE INITIALIZATION TABLE                        ***\n***********************************************************************\nTBLINIT  DC    256X'FF'\n         ORG   TBLINIT+C'.'\n         DC    X'00'              .\n         ORG   TBLINIT+C'$'\n         DC    X'00'              $\n         ORG   TBLINIT+C'#'\n         DC    2X'00'             # @\n         ORG   TBLINIT+C'a'\n         DC    9X'00'             a..i\n         ORG   TBLINIT+C'('\n         DC    X'00'              (\n         ORG   TBLINIT+C'j'\n         DC    9X'00'             j..r\n         ORG   TBLINIT+C')'\n         DC    X'00'              )\n         ORG   TBLINIT+C's'\n         DC    8X'00'             s..z\n         ORG   TBLINIT+C'A'\n         DC    9X'00'             A..I\n         ORG   TBLINIT+C'J'\n         DC    9X'00'             J..R\n         ORG   TBLINIT+C'S'\n         DC    8X'00'             S..Z\n         ORG   TBLINIT+C'0'\n         DC    10X'00'            0..9\n         ORG\nTBLSIZE  EQU   250                LENGTH OF TABLE (BYTES)\n         EJECT\n***********************************************************************\n***                     STATIC WORKAREA                             ***\n***********************************************************************\nSCRMAX   EQU   4096               MAXIMUM SCREEN SIZE\nVARRINIT DS    0F\n         DC    C'('\n         DC    CL9'ZSCREEND'      *SYS VAR*\n         DC    CL9'ZSCREENW'      *SYS VAR*\n         DC    CL9'ISPCDSN'\n         DC    CL9'ISPCPOS'\n         DC    CL9'ISPCROW'\n         DC    CL9'ISPCCOL'\n         DC    CL9'ISPCPID'\n         DC    CL9'ISPCSCS'\n         DC    CL9'ISPCSCR'\n         DC    C')'\n         DS    0F\n         DC    CL8'FIXED'         ZSCREEND FORMAT  *SYS*\n         DC    CL8'FIXED'         ZSCREENW FORMAT  *SYS*\n         DC    CL8'CHAR'          ISPCDSN FORMAT\n         DC    CL8'FIXED'         ISPCPOS FORMAT\n         DC    CL8'FIXED'         ISPCROW FORMAT\n         DC    CL8'FIXED'         ISPCCOL FORMAT\n         DC    CL8'CHAR'          ISPCPID FORMAT\n         DC    CL8'FIXED'         ISPCSCS FORMAT\n         DC    CL8'CHAR'          ISPCSCR FORMAT\n         DC    F'4'               ZSCREEND LENGTH  *SYS*\n         DC    F'4'               ZSCREENW LENGTH  *SYS*\n         DC    F'56'              ISPCDSN LENGTH\n         DC    F'4'               ISPCPOS LENGTH\n         DC    F'4'               ISPCROW LENGTH\n         DC    F'4'               ISPCCOL LENGTH\n         DC    F'8'               ISPCPID LENGTH\n         DC    F'4'               ISPCSCS LENGTH\n         DC    A(SCRMAX)          ISPCSCR LENGTH\nVARRLEN  EQU   *-VARRINIT\n         LTORG\n         EJECT\n***********************************************************************\n***                     DYNAMIC WORKAREA                            ***\n***********************************************************************\n         SPACE\nWORKAREA DSECT\nSAVEAREA DS    18F\nRETADDR  DS    A\nRETADDR2 DS    A\nQFLAG    DS    X                  QUOTED DSN FLAG\nTRNTBL   DS    XL(TBLSIZE)        TRANSLATION TABLE FOR DSN\nOPFLAG   DS    X                  OPERANDS FLAG\nODSNVAR  DS    H                  OVERRIDE DSN VAR LEN\n         DS    CL8                OVERRIDE DSN VAR NAME\nRPPL     CALL  ,(0,0,0,0,0,0),MF=L\n         EJECT\nKPPL     KPPL\n         EJECT\n*\n*  VARIABLE ARRAYS FOR ISPF SERVICES\nVARRAYS  DS    0F\nVARNAMES DS    C                  (\nSYSVARS  DS    CL9                ZSCREEND  *SYS*\n         DS    CL9                ZSCREENW  *SYS*\nUSRVARS  DS    CL9                ISPCDSN OR SPECIFIED DSN\n         DS    CL9                ISPCPOS\n         DS    CL9                ISPCROW\n         DS    CL9                ISPCCOL\n         DS    CL9                ISPCPID\n         DS    CL9                ISPCSCS\n         DS    CL9                ISPCSCR\n         DS    C                  )\nVARFMTS  DS    0F\n         DS    CL8                ZSCREEND FORMAT  *SYS*\n         DS    CL8                ZSCREENW FORMAT  *SYS*\n         DS    CL8                ISPCDSN FORMAT\n         DS    CL8                ISPCPOS FORMAT\n         DS    CL8                ISPCROW FORMAT\n         DS    CL8                ISPCCOL FORMAT\n         DS    CL8                ISPCPID FORMAT\n         DS    CL8                ISPCSCS FORMAT\n         DS    CL8                ISPCSCR FORMAT\nVARLENS  DS    F                  ZSCREEND LENTH  *SYS*\n         DS    F                  ZSCREENW LENTH  *SYS*\n         DS    F                  ISPCDSN LENGTH\n         DS    F                  ISPCPOS LENGTH\n         DS    F                  ISPCROW LENGTH\n         DS    F                  ISPCCOL LENGTH\n         DS    F                  ISPCPID LENGTH\n         DS    F                  ISPCSCS LENGTH\n         DS    F                  ISPCSCR LENGTH\nVARSTOR  DS    0F\nSCRD     DS    F\nSCRW     DS    F\nDSNAME   DS    CL56\nCSRPOS   DS    F\nCSRROW   DS    F\nCSRCOL   DS    F\nPANELID  DS    CL8\nSCRSIZE  DS    F\nSCREEN   DS    CL(SCRMAX)\n*\nWORKLEN  EQU   *-WORKAREA\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ISPCDSN$": {"ttr": 21509, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x00\\x7f\\x00\\x88\\x00\\x7f\\x12\\x00\\x00t\\x00t\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf2\\xf7\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-01-07T00:00:00", "modifydate": "1988-01-07T12:00:00", "lines": 116, "newlines": 116, "modlines": 0, "user": "FILE270"}, "text": "IISPCDSN - DATASET SELECTION BY CURSOR FROM ISPF DISPLAY\n\n\n     Author:\n         Gordon J. Schillinger\n         Washington Data Processing Service Center\n         Ph.  (206) 902-3147                           03/19/87\n\n\n     Modification log:\n         V2R1                                          03/01/88\n           - Extracts dsnames from updated screen image to allow\n             message fields to processed.\n           - Extracts member names or dataset names withing a set\n             of parentheses.\n           - Allows cursor positioning on beginning and ending\n             quotes and parentheses.\n\n\n     Ispcdsn will extract a dataset, pointed to by the cursor,\n     from an ISPF display panel.  Dataset names are scanned for\n     following standard naming and length conventions.\n\n     The variable name to contain the dataset name must be passed\n     to the program as a parameter, and will be placed into the\n     SHARED variable pool if no errors are encountered.  If errors\n     are encountered, a return code reflecting the type of error\n     will be returned following completion of the program.\n\n     Return Codes:\n       (4)  - Dataset name contains unmatched quotes\n       (8)  - Dataset name missing between quotes\n       (12) - Cursor not on a dataset name\n       (16) - Dataset name larger than the 56 byte maximum\n       (20) - Control Block parameter error\n\n     Example:\n       ISPEXEC SELECT PGM(ISPCDSN) PARM(SOMEVAR)\n       IF &LASTCC = 0 THEN +\n         ISPEXEC VGET (SOMEVAR) SHARED\n\n\n\n\n                  --V2R1 EXAMPLES--    ( | = CURSOR IN EXAMPLES)\n  Here's an example of the updated screen image enhancement.  Prior\n  to V2R1, trying to extract this VIO dsn following a compress\n  would result in a null line.  Now; however, the VIO dataset\n  displayed when help is entered can be browsed to view the output\n  FROM THE COMPRESS OPERATION.\n\n  ----------------------------  LIBRARY UTILITY  ----------- COMPRESS\n  OPTION  ===>\n  COMPRESS LISTING IS IN SYS88062.T095611.RA000.GS#00155.R0000004\n     BLANK - DISPLAY MEMBER LIST   |       B - BROWSE MEMBER\n     C - COMPRESS DATA SET                 P - PRINT MEMBER\n     X - PRINT INDEX LISTING               R - RENAME MEMBER\n     L - PRINT ENTIRE DATA SET             D - DELETE MEMBER\n     I - DATA SET INFORMATION              S - DATA SET INFORMATION (S\n\n  ISPF LIBRARY:\n     PROJECT ===> SOFTD155\n     GROUP   ===> MISC      ===>           ===>           ===>\n     TYPE    ===> CLIST\n\n\n  RESULTS IN:\n\n  BROWSE -- SYS88062.T095611.RA000.GS#00155.R0000004 - LINE 000000 COL\n  COMMAND ===>                                                  SCROLL\n  ********************************  TOP OF DATA  *********************\n  -----   PDSFAST/XA      VER 3.3FC        CPUID 3084-66122146\n     COPYRIGHT (C) 1986 SOFTWARE ENGINEERING OF AMERICA, INC.       DA\n\n  PDF101I  START PDSFAST EXECUTION\n\n  PDF103C        COPY OUTDD=ISP09561,INDD=ISP09561\n  PDF106F  COMPRESS VOLSER/DSN: SYS014 / GS00155.JOBS.CNTL\n  PDF110I  OPERATION IS COMPRESS - ISP09561 (DISK)\n  PDF156M  ADMUSP6   - MOVED -    ADR 000225  0019000225\n  PDF156M  ALIST     IN PLACE     ADR 00011D  001900011D\n  PDF156M  APDGEOF   IN PLACE     ADR 00001D  001900001D\n  PDF156M  APGDSTY   IN PLACE     ADR 000027  0019000027\n  PDF156M  COPYFILE  IN PLACE     ADR 00001B  001900001B\n  PDF156M  CSRDSN    - MOVED -    ADR 000301  0019000301\n  PDF156M  CT        IN PLACE     ADR 000025  0019000025\n  PDF156M  DEFNTABL  - MOVED -    ADR 000217  0019000217\n\n\n\n  Here's an example of the dsname within parentheses enhancement:\n\n   ALLOC F(CDSN) DSN(MY.LOAD)\n                        |\n\n     Now returns \"MY.LOAD\" instead of \"DSN(MY.LOAD)\" which would\n     result in an \"INVALID DATASET NAME\" when processed, as in\n     the previous release.\n\n     A dataset name and member may be extracted as before if cursor\n     is placed on the dsname part:\n\n   SRC.ASM(ISPCDSN)\n                 |\n\n\n   Cursor may be positioned on beginning or ending quotes:\n\n   'GS00155.SRC.ASM(ISPCDSN)'\n   |\n            OR\n   'GS00155.SRC.ASM(ISPCDSN)'\n                            |\n       however, the first would return the dsn and member and\n       the second would return just the member.\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ISPCMDS": {"ttr": 21512, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x00\\x7f\\x00\\x88\\x00\\x7f\\x12\\x00\\x000\\x000\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf2\\xf7\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-01-07T00:00:00", "modifydate": "1988-01-07T12:00:00", "lines": 48, "newlines": 48, "modlines": 0, "user": "FILE270"}, "mimetype": "application/octet-stream", "datatype": "binary", "extension": ".bin"}, "ITCOMA1": {"ttr": 21514, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x00\\x7f\\x00\\x88\\x00\\x7f\\x12\\x00\\x00\\x03\\x00\\x03\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf2\\xf7\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-01-07T00:00:00", "modifydate": "1988-01-07T12:00:00", "lines": 3, "newlines": 3, "modlines": 0, "user": "FILE270"}, "text": "ITCOMA1  CSECT\nSTART    ITCOMA1\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "JAN86": {"ttr": 21516, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x00\\x7f\\x00\\x88\\x00\\x7f\\x12\\x00\\x01\\x0e\\x01\\x0e\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf2\\xf7\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-01-07T00:00:00", "modifydate": "1988-01-07T12:00:00", "lines": 270, "newlines": 270, "modlines": 0, "user": "FILE270"}, "text": "./ ADD NAME=ALL      0106-86210-86210-1902-00069-00201-00000-KX00150\n1\n-\n  TO:      Your Bossss\n  FROM:\n  SUBJECT: Status Report, ..month.. 1986\n  DATE:    .... .., 198.\n\n\n \u00a1STATUS of status report; Enter your name and condition of report.\n+ ______\n\n\n \u00a1MVS\n [MVS2\n [MVS3\n [MVS4\n\n\n  Here is another guy report....\n\n  Here is anyones report...\n\n \u00a1UTILITIES\n+ _________\n\n\n \u00a1LANGUAGES\n+ _________\n\n\n \u00a1TSO\n+ ___\n\n\n \u00a1JES2\n+ ____\n\n\n \u00a1DATABASE\n+ ________\n\n\n \u00a1VM/PROFS - including VS/1, RSCS, etc\n+ ________\n\n\n \u00a1GENERAL SYSTEM - items like data set movement, DASD, error situations\n+ ______________\n\n\n \u00a1PERFORMANCE/CAPACITY\n+ ____________________\n\n\n \u00a1ACF2\n+ ____\n\n\n \u00a1MISCELLANEOUS\n+ _____________\n\n\n \u00a1NEXT QUARTER'S MAJOR EVENTS\n+ ___________________________\n\n\n \u00a1OPINION - keep it clean\n+ _______\n\n./ ADD NAME=ANYONE   0100-86210-86210-1720-00066-00066-00000-KX00150\n1\n-\n  TO:      Your Bossss\n  FROM:\n  SUBJECT: Status Report, ..month.. 1986\n  DATE:    .... .., 198.\n\n\n \u00a1STATUS of status report; Enter your name and condition of report.\n+ ______\n\n\n \u00a1MVS\n [MVS2\n [MVS3\n [MVS4\n\n  Here is anyones report...\n\n \u00a1UTILITIES\n+ _________\n\n\n \u00a1LANGUAGES\n+ _________\n\n\n \u00a1TSO\n+ ___\n\n\n \u00a1JES2\n+ ____\n\n\n \u00a1DATABASE\n+ ________\n\n\n \u00a1VM/PROFS - including VS/1, RSCS, etc\n+ ________\n\n\n \u00a1GENERAL SYSTEM - items like data set movement, DASD, error situations\n+ ______________\n\n\n \u00a1PERFORMANCE/CAPACITY\n+ ____________________\n\n\n \u00a1ACF2\n+ ____\n\n\n \u00a1MISCELLANEOUS\n+ _____________\n\n\n \u00a1NEXT QUARTER'S MAJOR EVENTS\n+ ___________________________\n\n\n \u00a1OPINION - keep it clean\n+ _______\n\n./ ADD NAME=GUY2     0100-86210-86210-1720-00066-00066-00000-KX00150\n1\n-\n  TO:      Your Bossss\n  FROM:\n  SUBJECT: Status Report, ..month.. 1986\n  DATE:    .... .., 198.\n\n\n \u00a1STATUS of status report; Enter your name and condition of report.\n+ ______\n\n\n \u00a1MVS\n [MVS2\n [MVS3\n [MVS4\n\n  Here is another guy report....\n\n \u00a1UTILITIES\n+ _________\n\n\n \u00a1LANGUAGES\n+ _________\n\n\n \u00a1TSO\n+ ___\n\n\n \u00a1JES2\n+ ____\n\n\n \u00a1DATABASE\n+ ________\n\n\n \u00a1VM/PROFS - including VS/1, RSCS, etc\n+ ________\n\n\n \u00a1GENERAL SYSTEM - items like data set movement, DASD, error situations\n+ ______________\n\n\n \u00a1PERFORMANCE/CAPACITY\n+ ____________________\n\n\n \u00a1ACF2\n+ ____\n\n\n \u00a1MISCELLANEOUS\n+ _____________\n\n\n \u00a1NEXT QUARTER'S MAJOR EVENTS\n+ ___________________________\n\n\n \u00a1OPINION - keep it clean\n+ _______\n\n./ ADD NAME=PATTERN  0113-86013-86210-1718-00065-00040-00000-KX00150\n1\n-\n  TO:      Your Bossss\n  FROM:\n  SUBJECT: Status Report, ..month.. 1986\n  DATE:    .... .., 198.\n\n\n \u00a1STATUS of status report; Enter your name and condition of report.\n+ ______\n\n\n \u00a1MVS\n [MVS2\n [MVS3\n [MVS4\n\n\n \u00a1UTILITIES\n+ _________\n\n\n \u00a1LANGUAGES\n+ _________\n\n\n \u00a1TSO\n+ ___\n\n\n \u00a1JES2\n+ ____\n\n\n \u00a1DATABASE\n+ ________\n\n\n \u00a1VM/PROFS - including VS/1, RSCS, etc\n+ ________\n\n\n \u00a1GENERAL SYSTEM - items like data set movement, DASD, error situations\n+ ______________\n\n\n \u00a1PERFORMANCE/CAPACITY\n+ ____________________\n\n\n \u00a1ACF2\n+ ____\n\n\n \u00a1MISCELLANEOUS\n+ _____________\n\n\n \u00a1NEXT QUARTER'S MAJOR EVENTS\n+ ___________________________\n\n\n \u00a1OPINION - keep it clean\n+ _______\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "JTOSCON$": {"ttr": 21763, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x00\\x7f\\x00\\x88\\x00\\x7f\\x12\\x00\\x00<\\x00<\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf2\\xf7\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-01-07T00:00:00", "modifydate": "1988-01-07T12:00:00", "lines": 60, "newlines": 60, "modlines": 0, "user": "FILE270"}, "text": "1                                                        JTOSCONV.1\n                                                         03/16/83\n\n\n  PROGRAM:       JTOSCONV\n  AUTHOR:        Jeff Sprehn\n  AGENCY:        WDPSC\n  LANGUAGE:      COBOL\n  LOCATION:      WDPSC.SHARED.LOAD\n  FUNCTION:      Convert Julian dates of the form YYDDD to standard\n                 (MMDDYY) after date validation.\n\n  RUN MODE:      N/A ... this is a subroutine\n\n  This is  a subroutine  which accepts  a Julian  date of  the form\n  YYDDD and converts  it to a standard  date of the form  MMDDYY if\n  and only if the input date is a  valid date.  A Julian date is of\n  the form YYDDD where YY is the  year of the twentieth century and\n  DDD is  a three digit  number representing the  displacement from\n  the beginning of that year.\n\n  This program  is also  an interface to  the CONVDATE  entry point\n  JTOSDATE.  JTOSDATE will  abend if you supply it  with an invalid\n  date  such as  81366 (there  are only  365 days  in 198l).   This\n  subroutine (JTOSCONV) will completely edit your date first before\n  calling JTOSDATE to obtain your standard date.  A switch is to be\n  interrogated to determine the success of that edit.\n\n\n\n\n1                                                        JTOSCONV.2\n                                                         03/16/83\n\n\n  HOW TO USE THIS PROGRAM:\n\n  Place the following 01 level into your WORKING STORAGE SECTION:\n\n       01   JTOSCONV-I-O-AREA.\n            05   FILLER                   PIC X(8).\n            05   OUT-STANDARD-DATE        PIC 9(6).\n            05   IN-JULIAN-DATE           PIC X(5).\n            05   UNSUCCESSFUL-EDIT        PIC X(3).\n\n  Do the following in your PROCEDURE DIVISION:\n\n       MOVE your date to be converted to IN-JULIAN-DATE of\n            JTOSCONV-I-O-AREA.\n       CALL 'JTOSCONV' USING JTOSCONV-I-O-AREA.\n       IF UNSUCCESSFUL-EDIT = 'YES'\n            do your error routine\n\n       ELSE\n            your date is now in standard date format and is contained\n            in OUT-STANDARD-DATE.\n\n\n\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "JTOSCONV": {"ttr": 21765, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x00\\x7f\\x00\\x88\\x00\\x7f\\x12\\x00\\x00\\x94\\x00\\x94\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf2\\xf7\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-01-07T00:00:00", "modifydate": "1988-01-07T12:00:00", "lines": 148, "newlines": 148, "modlines": 0, "user": "FILE270"}, "text": "000010 ID DIVISION.                                                     04/16/76\n000020 PROGRAM-ID.    JTOSCONV.                                         23528JTO\n000030 AUTHOR.        JEFF SPREHN.                                      SC LV006\n000040 INSTALLATION.  LABOR AND INDUSTRIES.\n000050 DATE-WRITTEN.  APRIL, 1974.\n000060 DATE-COMPILED.\n000070 REMARKS.\n000080*****************************************************************\n000090*  THIS PROGRAM IS A CALLED MODULE THAT PERFORMS TWO FUNCTIONS: *\n000100*                                                               *\n000110*    1.  EDITS FOR THE VALIDITY OF THE JULIAN DATE THAT IS      *\n000120*        BEING PASSED TO THIS MODULE AND MOVES 'YES' TO         *\n000130*        INVALID-INPUT-DATE OF JTOSCONV-I-O-AREA IF             *\n000140*        THE DATE BEING PASSED CANNOT BE CONVERTED TO STANDARD, *\n000150*        ELSE, IF THE DATE CAN BE CONVERTED TO STANDARD, IT     *\n000160*        MOVES 'NO ' TO INVALID-INPUT-DATE OF                   *\n000170*        JTOSCONV-I-O-AREA.                                     *\n000180*                                                               *\n000190*    2.  CALLS 'JTOSDATE' AND MOVES THE RESULTANT STANDARD      *\n000200*        DATE OF THE FORM (MMDDYY) TO INPUT-DATE OF             *\n000210*        JTOSCONV-I-O-AREA SO THAT IT IS AVAILABLE TO           *\n000220*        THE MAIN-LINE CALLING PROGRAM IF AND ONLY IF THE       *\n000230*        JULIAN DATE BEING PASSED TO THIS MODULE WAS            *\n000240*        SUCCESSFULLY VALIDATED.                                *\n000250*                                                               *\n000260*                                                               *\n000270*    THEREFORE THIS MODULE CAN BE USED FOR TWO PURPOSES:        *\n000280*                                                               *\n000290*        1.  CONVERT JULIAN DATES TO DATES OF THE FORM (MMDDYY) *\n000300*            WITHOUT FEAR OF AN '0C7'.                          *\n000310*                                                               *\n000320*        2.  VALIDATE JULIAN DATES  (IN THIS CASE WE ARE NOT    *\n000330*            CONCERNED WHETHER THIS MODULE CALLED 'JTOSDATE'    *\n000340*            OR NOT).                                           *\n000350*                                                               *\n000360*****************************************************************\n000370     EJECT\n000380 ENVIRONMENT DIVISION.\n000390 CONFIGURATION SECTION.\n000400 SOURCE-COMPUTER. IBM-370-158.\n000410 OBJECT-COMPUTER. IBM-370-158.\n000420     EJECT\n000430 DATA DIVISION.\n000440\n000450 WORKING-STORAGE SECTION.\n000460\n000470 77  WORK-STOR  VALUE 'WORKING  STORAGE'     PIC X(16).\n000480\n000490 01  INTERMEDIATE-WORK-DATE.\n000500     05  MONTH                               PIC 99.\n000510     05  DAYY                                PIC 99.\n000520     05  YEAR                                PIC 99.\n000530\n000540 01  STANDARD-DATE.\n000550     05  YEAR                                PIC 99.\n000560     05  MONTH                               PIC 99.\n000570     05  DAYY                                PIC 99.\n000580\n000590 01  JULIAN-DATE-WORK.\n000600     05  YEAR                                PIC 99.\n000610     05  DAYY                                PIC 999.\n000620\n000630 01  INPUT-DATE-VALIDATION.\n000640     05  DATE-BREAK                          PIC X(05).\n000650     05  TEST-DATE-BREAK REDEFINES DATE-BREAK.\n000660         10  YEAR-TEST                       PIC 9(2).\n000670         10  DAYY                            PIC 9(3).\n000680\n000690 01  CALCULATE-RESULTS.\n000700     05  QUOTEN.\n000710         10  QUOTENTS                        PIC S99V9.\n000720     05  QUOTEN-BREAK REDEFINES QUOTEN.\n000730         10  QUOT-NUM                        PIC S99V.\n000740         10  QUOT-REMAIN                     PIC SV9.\n000750     EJECT\n000760 LINKAGE SECTION.\n000770\n       01  JTOSCONV-I-O-AREA.\n           05  MODULE-NAME                         PIC X(8).\n           05  INPUT-DATE                          PIC X(6).\n           05  JULIAN-DATE                         PIC X(5).\n           05  INVALID-INPUT-DATE                  PIC X(3).\n\n\n000870     EJECT\n000880 PROCEDURE DIVISION     USING     JTOSCONV-I-O-AREA.\n000890\n000900 0100.\n000910     MOVE 'JTOSCONV' TO MODULE-NAME OF JTOSCONV-I-O-AREA.\n000920     MOVE JULIAN-DATE OF JTOSCONV-I-O-AREA\n000930       TO DATE-BREAK OF INPUT-DATE-VALIDATION.\n000940     MOVE 'NO ' TO INVALID-INPUT-DATE OF\n000950         JTOSCONV-I-O-AREA.\n000960     PERFORM 15700-VALIDATE-DATE THRU 15799-EXIT-VALIDATE-DATE.\n000970\n000980     IF INVALID-INPUT-DATE OF JTOSCONV-I-O-AREA\n000990        EQUAL TO 'YES'\n001000           GO TO 99999-GOBACK.\n001010\n001020     MOVE JULIAN-DATE OF JTOSCONV-I-O-AREA TO JULIAN-DATE-WORK.\n001030\n001040     CALL 'JTOSDATE'\n001050         USING\n001060             JULIAN-DATE-WORK\n001070             STANDARD-DATE.\n001080\n001090     MOVE CORR STANDARD-DATE\n001100       TO INTERMEDIATE-WORK-DATE.\n001110     MOVE INTERMEDIATE-WORK-DATE\n001120         TO INPUT-DATE OF JTOSCONV-I-O-AREA.\n001130     GO TO 99999-GOBACK.\n001140*\n001150*    PARAGRAPHS 15700-VALIDATE-DATE THRU 15799-EXIT-VALIDATE-DATE\n001160*    IS ALWAYS PERFORMED.  IT GUARANTEES THAT THE DATE MOVED TO\n001170*    DATE-BREAK MAY BE PROPERLY CONVERTED TO STANDARD. IF THE DATE\n001180*    FAILS THE VALIDATION, 'YES' IS MOVED TO INVALID-INPUT-DATE.\n001190*\n001200 15700-VALIDATE-DATE.\n001210     IF DATE-BREAK  OF  INPUT-DATE-VALIDATION  NOT NUMERIC\n001220         GO TO 15788-REJECT-DATE.\n001230\n001240     MOVE ZEROS TO QUOTENTS    OF CALCULATE-RESULTS\n001250                   QUOT-REMAIN OF CALCULATE-RESULTS\n001260                   QUOT-NUM    OF CALCULATE-RESULTS.\n001270     COMPUTE QUOTENTS = YEAR-TEST / 04.\n001280\n001290     IF QUOT-REMAIN NOT EQUAL TO ZEROS\n001300        THEN\n001310             IF DAYY     OF INPUT-DATE-VALIDATION\n001320               IS LESS THAN 001 OR GREATER THAN 365\n001330                 GO TO 15788-REJECT-DATE.\n001340\n001350     IF QUOT-REMAIN EQUAL TO ZEROS\n001360        THEN\n001370             IF DAYY     OF INPUT-DATE-VALIDATION\n001380               IS LESS THAN 001 OR GREATER THAN 366\n001390                 GO TO 15788-REJECT-DATE.\n001400\n001410     GO TO 15799-EXIT-VALIDATE-DATE.\n001420\n001430 15788-REJECT-DATE.\n001440     MOVE 'YES' TO INVALID-INPUT-DATE OF JTOSCONV-I-O-AREA.\n001450\n001460 15799-EXIT-VALIDATE-DATE.\n001470     EXIT.\n001480\n001490 99999-GOBACK.\n001500     GOBACK.\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "KEYEX": {"ttr": 21769, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x00\\x7f\\x00\\x88\\x00\\x7f\\x12\\x00\\x00^\\x00^\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf2\\xf7\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-01-07T00:00:00", "modifydate": "1988-01-07T12:00:00", "lines": 94, "newlines": 94, "modlines": 0, "user": "FILE270"}, "text": "*          DATA SET 761KKKEYEX AT LEVEL 001 AS OF 08/30/82\n* WRITTEN BY KERMIT KISER - WASHINGTON STATE DP SERVICE CENTER (WDPSC)\n*\n         REGEQU\n         EJECT\nKEYEX    CSECT\n         SAVE  (14,12),,*\n         LR    R12,R15            R12->KEYEX\n         USING KEYEX,R12\n         LR    R11,R1             R11->KEYSECT\n         USING KEYSECT,R11\n         LR    R9,R13             R9->OLD SAVE\n         L     R13,KEYWP          R13->NEW SAVE\n         USING KEYWORK,R13\n         ST    R9,SAVE+4\n         ST    R13,8(,R9)\n         L     R10,BPPLP          R10->BPPL\n         USING BPPL,R10\n         SLR   R1,R1\n         SLR   R4,R4\n         L     R9,OPERPTR         R9->OPERAND\n         L     R8,OPLENPTR        R8->OPER LEN\n         LH    R8,0(,R8)          R8=OPER LEN\n         BCTR  R8,R0              R8-1 FOR EX\n         EX    R8,KTRT            ANY = PRESENT?\n         BZ    KEYCTX             NO -> CALL UNKNEXIT\n         BC    11,KEYXX           NO DATA\n         LR    R6,R1              R6->'='\n         SR    R6,R9              R6=KEYWD LENGTH\n         L     R5,KEYOL           R5->LIST OF KEYWORDS\n         EJECT\nKSL      LA    R5,4(R5)           R5->NEXT ENTRY\n         ICM   R4,7,1(R5)         R4->OPER DESCRIPT\n         BZ    KEYCTX             NOT FOUND->CALL TRUE EXIT\n         TM    2(R4),X'20'        KEYWORD DESC?\n         BNO   KSL\n         LH    R3,8(,R4)          R3=OPER DESC LEN FLD\n         CR    R6,R3              TOO SHORT?\n         BH    KSL                YES\n         LR    R3,R6\n         BCTR  R3,R0              R3-1\n         EX    R3,KCLC            NO->COMPARE THEM\n         BNE   KSL                NO MATCH->TRY AGAIN\n         L     R3,4(,R4)          R3->KEY AREA\n         LH    R2,0(,R3)          R2=LENGTH OF AREA\n         BCTR  R2,R0              R2-1 FOR EX\n         BCTR  R2,R0              R2-1 FOR MVI:\n         MVI   4(R3),C' '         A BLANK\n         EX    R2,KMVC1           FILL IT\n         LA    R8,0(R8,R9)        R8->END OF OPER\n         SR    R8,R1              R8=LENGTH OF DATA\n         STH   R8,2(,R3)          PASS DATA LEN\n         BCTR  R8,R0              R8-1\n         EX    R8,KMVC2           MOVE THE DATA\n         SLR   R5,R5\n         IC    R5,1(,R4)          R5=FLAG BYTE OFFSET\n         LA    R5,KEYFLG(R5)      R5->FLAG BYTE\n         OC    0(1,R5),0(R4)      SET THE FLAG\n         EJECT\nKEYXX    SLR   R15,R15            RC=0\nKEYX2    L     13,SAVE+4\n         RETURN (14,12),RC=(15)\n         BR    R14\n         SPACE 3\nKEYCTX   DS    0H\n         LR    R1,R11             R1->PARM LIST\n         L     R15,TUX            R15->TRUE EXIT\n         LTR   R15,R15            ANY EXIT?\n         BZ    KEYXX              NO\n         BALR  R14,R15            CALL IT\n         B     KEYX2\n         SPACE 3\nKTRT     TRT   0(0,R9),EQTAB\nEQTAB    DC    XL256'00'\n         ORG   EQTAB+C'='\n         DC    X'04'\n         ORG\nKCLC     CLC   0(0,R9),10(R4)     MATCH?\nKMVC1    MVC   5(0,R3),4(R3)      BLANK FILLER\nKMVC2    MVC   4(0,R3),1(R1)      DATA MOVE\n         EJECT\nKEYWORK  DSECT\nSAVE     DS    18F\nKEYFLG   DS    F\nKEYSECT  DSECT\nXP1      DS    F                  UNKN EXIT PARM\nBPPLP    DS    F                  PTR TO BPPL\nWORKP    DS    F                  PTR TO KMDPARS WORKAREA\n*\nKEYOL    DS    F                  PTR TO KEYWD OPLIST\nKEYWP    DS    F                  PTR TO KEY WORKAREA\nTUX      DS    F                  PTR TO TRUE UNKN EXIT\n         BPPL  DSECT\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "KMDPARS": {"ttr": 21772, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x88\\x00\\x7f\\x00\\x98)\\x9f\\x12)\\x01\\x0c\\x01\\t\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf2\\xf7\\xf0@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1988-01-07T00:00:00", "modifydate": "1998-10-26T12:29:00", "lines": 268, "newlines": 265, "modlines": 0, "user": "FILE270"}, "text": "*\n*   @OK - ADJUSTED TO INVOKE REGISTER EQUATE MACRO SUPPLIED IN\n*          FILE270 .MACLIB                       10/26/98\n*\n*   V1M4- MODIFIED 4/1/86 TO CHECK FOR ZERO LENGTH OPERANDS\n*          DUE TO A PROBLEM WITH SMPE AND OUR NEW SUBMIT FRONTEND\n*\n*              DOCUMENTATION FOR KMDPARS AND OPERSCAN SUBRTNS:\n*\n*\n*\n*               PARAMETER LIST PASSED TO KMDPARS:\n*\n*         KPPL     DS 10F :\n*         CBUFPTR  DS    F              CMDBUF TO BE PARSED\n*         OPLSTPTR DS    F              LIST OF OPERANDS TO FLAG\n*         FLAGPTR  DS    F              WHERE TO FLAG THEM\n*         UNKNEXIT DS    F              EXIT TO CALL IF UNKNOWN OPER\n*         EXITPARM DS    F              PARAMETER TO PASS EXITS (ADDR)\n*                                       (R1 POINTS HERE AT EXIT ENTRY)\n*         BPPLPASS DS    F              BPPL PTR WHEN EXIT GETS CONTROL\n*         WORKPASS DS    F              OPTIONAL WORKAREA (512 BYTES)\n*         KEYLPASS DS    F              LIST OF KEYWORD OPERANDS\n*         KEYWPASS DS    F              WORKAREA FOR KEYWORD PROCESSO\n*         REEXPASS DS    F              ADDRESS OF REAL UNKNOWN EXIT\n*\n*\n*               PARAMETER LIST PASSED TO OPERSCAN SUBROUTINE:\n*\n*         BPPL     DS    10F :\n*         BUFFPTR  DS    F              BUFFER PTR (CBUF)\n*         LENPTR   DS    F              LENGTH PTR (CBUF LEN)\n*         STARTPTR DS    F              START SEARCH PTR\n*         OPERPTR  DS    F              NEXT OPER LOC\n*         OPLENPTR DS    F              NEXT OPER LEN PTR\n*         SUBPTR   DS    F              SUBFIELD PTR\n*         SUBLENPT DS    F              SUBFIELD LEN PTR\n*         WORKPTR  DS    F              OPTIONAL WORKAREA (350 BYTES)\n*         OPDESCP  DS    F              PTR TO OPERAND DESCRIPTOR\n*                  DS    F              RESERVED (ZERO)\n*\n*         OPLEN    DS    H              POINTED TO BY OPLENPTR\n*         SUBLEN   DS    H              POINTED TO BY SUBLENPT\n*\n         TITLE 'KMDPARS - GENERAL PURPOSE COMMAND BUFF PARSE SUBRTN'\nKMDPARS  CSECT\n         SAVE  (14,12),,KMDPARS-V1M4\n         LR    R12,R15\n         USING KMDPARS,R12\n         LR    R11,R1                   R11 -> PARM LIST\n         USING KPPL,R11\n         SLR   R15,R15                  R15 = 0\n         LR    R10,R13                  SAVE SAVE\n         L     R13,WORKPASS             SEE IF A FREE ONE THERE\n         LTR   R13,R13                  ANY?\n         BNZ   FASTCALL                 YES -> SMART CALLER\n         LA    R0,WORKLEN               NO -> GET SOME\n         GETMAIN R,LV=(0)\n         LR    R13,R1                   SAVE IT\n         USING WORKAREA,R13\nFASTCALL ST    R10,SAVEAREA+4           SAVE HIS SAVE PTR\n         LA    R13,SAVEAREA             MAKE SURE MINE IS OK\n         USING SAVEAREA,R13\n         ST    R13,8(,R10)              GIVE HIM MY SAVE AREA\n         EJECT\n**********************************************************************\n*       MAINLINE PROCESSING CONTROL ROUTINE:                         *\n**********************************************************************\n*\n*              FIRST STEP IS EXTRACT OUR OPERANDS FROM COMMAND:\n*\nB4       BAL   R14,PB                   FIX BUFFER\n*\nSETRC    SLR   R15,R15                  R15=0\n         CLI   OPFLAG,X'FF'             ANY OPS FOUND?\n         BE    KMDEX                    YES -> EXIT\n         LA    R15,8                    SAY NONE THERE\n*\n**********************************************************************\n         EJECT\n**********************************************************************\n*       KMDPARS EXIT ROUTINE:                                        *\n**********************************************************************\n*\nKMDEX    LR    R1,R13                   R1 -> WORKAREA\n         LA    R0,WORKLEN               R0 = LENGTH OF AREA\n         L     R13,4(,R13)              R13 -> OLD SAVE AREA\n         C     R1,WORKPASS              IS WORKAREA MINE?\n         BE    FASTEX                   NO -> DONT FREE\n         LR    R11,R15                  SAVE RC\n         FREEMAIN R,LV=(0),A=(1)        FREE\n         LR    R15,R11                  GET RC BACK\nFASTEX   RETURN (14,12),RC=(15)         EXIT\n         REGEQU                                                     @OK\n         EJECT\n**********************************************************************\n*        PB -  PROCESS BUFFER TO REMOVE AND FLAG OUR OPERANDS\n**********************************************************************\nPB       ST    R14,L2LS\n*\n*       FIRST BUILD BUFFER-PROCESSING PARAMETER LIST:\n*\nBPI      XC    BPPL(40),BPPL            CLEAR BUFFER PROC PARMLIST\n         L     R10,CBUFPTR              R10 -> CBUF\n         ST    R10,BUFFPTR              BUFFER PTR\n         ST    R10,LENPTR               LENGTH PTR\n         LH    R9,2(R10)                R9 = OPERAND OFFSET\n         LA    R8,4(R9,R10)             R8 -> OPERAND START\n         ST    R8,STARTPTR              SEARCH PTR\n         LA    R7,OPLEN                 R7 -> OPLEN AREA\n         ST    R7,OPLENPTR              LENGTH PTR RETURN AREA\n         LA    R6,SUBLEN                R6 -> SUBLEN AREA\n         ST    R6,SUBLENPT              LENGTH PTR RETURN AREA\n         LA    R5,OPSCNWK               GET HIM A WORKAREA\n         ST    R5,WORKPTR               PASS IT TO HIM\n         XC    OPFLAG,OPFLAG            CLEAR OPERANDS PRESENT FLAG\n*\n*       THEN CHECK EACH OPERAND IN THE INPUT BUFFER:\n*\nDOPO     BAL   R14,PO                   PROCESS AN OPERAND\n         LTR   R15,R15                  MORE OPERANDS?\n         BZ    DOPO                     YES\n*\n*       SAY DONE AND EXIT:\n*\nBPT      SLR   R15,R15                  RC=0\n         L     R14,L2LS\n         BR    R14\n         EJECT\n**********************************************************************\n*              PO - PROCESS AN OPERAND:\n**********************************************************************\nPO       ST    R14,L3LS\n*\n*       FIRST WE OBTAIN AN OPERAND FROM THE BUFFER:\n*\n         BAL   R14,OO                   OBTAIN AN OPERAND\n         LTR   R15,R15                  ANY FOUND?\n         BNZ   POX                NO -> NOTHING TO PROCESS\n         OI    OPFLAG,X'FF'             SAY WE HAVE OPERANDS\n*\n*       GET READY TO CHECK THE OPERAND AGAINST OUR LIST:\n*\n         L     R10,OPERPTR              R10 -> OPERAND IN BUFFER\n         LH    R9,OPLEN                 R9  = OPLENGTH IN BUFFER\n         L     R8,OPLSTPTR              R8 -> OPLIST (-4)\n         LTR   R6,R9                    R6 = R9  = OPLEN         V1M4\n         BZ    UNKN                     OPERAND MAY BE IN PARENS V1M4\n         BCTR  R6,R0                    R6 = R6-1 FOR EX\n         EX    R6,FOLD                  MAKE OPERAND UPPER CASE\n*\n*       NOW SCAN THE LIST TO SEE IF ANY MATCH BUFFER OPERAND:\n*\nFOOP     LA    R8,4(R8)                 R8 -> NEXT OP DESC PTR\n         L     R7,0(R8)                 R7 -> OPERAND DESCRIPTOR\n         LTR   R7,R7                    R7 = 0? ANY MORE TO CHECK?\n         BZ    UNKN                     NO\n*\n         CH    R9,8(,R7)                OPLEN > DESCRIPTOR OPER LEN?\n         BH    FOOP                     YES -> TOO LONG TO BE THIS ONE\n*\n         SLR   R1,R1                    R1=0                      WDPSC\n         ICM   R1,1,3(R7)               R1=MINIMUM OPER LEN       WDPSC\n         BZ    ANYLEN                   SKIP IF 0                 WDPSC\n         CR    R9,R1                    OPLEN>MIN?                WDPSC\n         BL    FOOP                     NO->TOO SHORT TO BE THIS  WDPSC\n*\nANYLEN   EX    R6,OPCLC                 DOES OPERAND MATCH THIS ONE?\n         BNE   FOOP                     NO -> NOT THIS ONE\n         EJECT\n**********************************************************************\n*    WE HAVE AN OPERAND MATCH - SET FLAG AND DO OTHER OPTIONS:\n**********************************************************************\nFO       SLR   R5,R5\n         IC    R5,1(,R7)\n         A     R5,FLAGPTR\n         OC    0(1,R5),0(R7)            SET FLAG FOR OPERAND FOUND\n*\n         SLR   R10,R10                  R10=0                     WDPSC\n         ICM   R10,7,SUBPTR+1           R10->SUBFIELD?            WDPSC\n         BZ    XCHK                     NONE PRESENT              WDPSC\n         LH    R2,SUBLEN                R2=SUBFLD LEN             WDPSC\n         BCTR  R2,R0                    R2=R2-1 FOR EX            WDPSC\n         EX    R2,FOLD                  MAKE UPPER CASE           WDPSC\n*\nXCHK     TM    2(R7),X'80'              EXIT PRESENT?\n         BNO   DO                       NO\n         LA    R1,BPPL\n         ST    R1,BPPLPASS              GIVE HIM THE BPPL\n         ST    R7,OPDESCP               GIVE HIM THE OPER DESCRIPTOR\n         LA    R1,EXITPARM              YES -> PASS PARMS\n         L     R15,4(,R7)               R15->EXIT\n         TM    2(R7),X'10'              SUBEX BEING CALLED?\n         BNO   GCX                      NO\n         L     R15,0(,R15)\nGCX      BALR  R14,R15                  CALL IT\n*\nDO       TM    2(R7),X'40'              DELETE OPERAND DESIRED?\n         BNO   POX                      NO -> EXIT PO\n         L     R10,OPERPTR              R10->OPERAND IN BUFFER    WDPSC\n         EX    R6,DOMVC                 COVER OPERAND WITH BLANKS\n         ICM   R10,7,SUBPTR+1           R10->SUBFIELD             WDPSC\n         BZ    POX                      NONE THERE                WDPSC\n         EX    R2,DOMVC                 ERASE SUBFIELD            WDPSC\n         B     POX\n         SPACE 3\n**********************************************************************\n*    WE HAVE NO OPERAND MATCH - INVOKE EXIT IF PRESENT:\n**********************************************************************\nUNKN     L     R15,UNKNEXIT             UNKNOWN OPERAND EXIT ADDRESS\n         LTR   R15,R15                  EXIT PRESENT?\n         BZ    POX                      NO\n         LA    R1,BPPL\n         ST    R1,BPPLPASS              GIVE HIM THE BPPL\n         LA    R1,EXITPARM              YES -> PASS PARMS\n         BALR  R14,R15                  CALL IT\n         SPACE 3\n*\nPOX      L     R14,L3LS                 EXIT PO\n         BR    R14\n         SPACE\n*\n*       OPERATIONS EXECUTED AGAINST THE OPERAND IN THE BUFFER:\n*\nFOLD     OC    0(0,R10),=CL256' '       FOLD TO UPPER CASE\nOPCLC    CLC   0(0,R10),10(R7)          BUFFOP = DESCOP?\nDOMVC    MVC   0(0,R10),=CL256' '       MOVE BLANKS ON TOP OF OPERAND\n         EJECT\n**********************************************************************\n*       THE PARSE SUBROUTINE IS IN A SEPARATE MODULE\n*   IN ORDER TO MAKE IT GENERAL PURPOSE IN CASE WE NEED OTHER\n*   FRONTENDS TO IBM COMMANDS.\n**********************************************************************\nOO       ST    R14,L4LS\n*\n         LA    R1,BPPL                  R1 -> BUFFER PROC PARMLIST\n         CALL  OPERSCAN                 CALL PARSE ROUTINE\n*\n         L     R14,L4LS\n         BR    R14\n         EJECT\nSTATWORK EQU   *\n*\n         LTORG\n         DC    40X'00'                  ZAP AREA\n         TITLE 'WORKAREA FOR KMDPARS'\nWORKAREA DSECT\n*\nSAVEAREA DS    18F\nL1LS     DS    F\nL2LS     DS    F\nL3LS     DS    F\nL4LS     DS    F\n*\nOPFLAG   DS    X\n*\n         TITLE 'PARAMETER LIST PASSED TO OPERSCAN SUBROUTINE'\n*\n         BPPL\n*\nOPSCNWK  DS    XL350                    WORK AREA TO PASS TO OPERSCAN\n*\nWORKLEN  EQU   *-WORKAREA\n         TITLE 'PARAMETER LIST PASSED TO KMDPARS'\n*\n         KPPL  DSECT\n*\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "KOMM": {"ttr": 22019, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x00\\x7f\\x00\\x88\\x00\\x7f\\x12\\x00\\x03\\x06\\x03\\x06\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf2\\xf7\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-01-07T00:00:00", "modifydate": "1988-01-07T12:00:00", "lines": 774, "newlines": 774, "modlines": 0, "user": "FILE270"}, "text": "*          DATA SET 761KKKOMM  AT LEVEL 006 AS OF 10/04/83\nKOMM     TITLE 'V2M4 - CLIST COMMUNICATION ROUTINE FOR 3270 TERMINALS'\n         MACRO\n         REGEQU\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n         MEND\n         MACRO\n&LAB     LEAVER &WR=R13,&WL=WORKLEN\n&LAB     LR    R1,&WR             WORKAREA ADDR FOR FREEMAIN\n         L     R0,=A(&WL)         WORKAREA LEN   \"    \"\n         L     R13,4(R13)         GET CALLERS SAVEAREA ADDR\n         LR    R11,R15            SAVE RETURN CODE\n         FREEMAIN R,LV=(0),A=(1)\n         LR    R15,R11            RESTORE RETURN CODE\n         RETURN (14,12),RC=(15)\n         MEND\n         MACRO\n&LAB     LEAVENR\n&LAB     L     R13,4(R13)         GET CALLERS SAVEAREA ADDR\n         RETURN (14,12),RC=(15)\n         MEND\n         MACRO\n&LAB     KKPARSE &CPPL=R11,&ANS=ANS,&ECB=ECB,&PCL=PCL,&PPLA=PPLA\n*                  DEFAULT OPERANDS :\n*        KKPARSE &CPPL=R11,&ANS=ANS,&ECB=ECB,&PCL=PCL,&PPLA=PPLA\n*                            CPPL IS THE REGISTER CONTAINING THE\n*                                 POINTER TO THE COMMAND PROCESSOR\n*                                 PARAMETER LIST.\n*                            ANS  IS A FULLWORD WHERE PARSE RETURNS\n*                                 THE POINTER TO HIS ANSWER (IKJPARMD).\n*                            ECB  IS A FULLWORD.\n*                            PCL  IS THE NAME OF THE PARSE CONTROL\n*                                 LIST CSECT (IKJPARM).\n*                            PPLA IS A 7 FULLWORD AREA USED FOR\n*                                 THE PARSE PARAMETER LIST.\n*\n*        KKPARSE             USES REGS R14,R15,R1,&CPPL REG\n*\n         USING CPPL,&CPPL         POINTS TO CPPL (PARM LIST)\n*\n&LAB     LA    R1,&PPLA           R1->PPL AREA\n         USING PPL,R1             TELL ASSEMBLER POINTS TO PPL AREA\n*\n*                         CONSTRUCT PARSE PARAMETER LIST\n*                                           FOR IKJPARS :\n*\n         MVC   PPLUPT,CPPLUPT     UPT\n         MVC   PPLECT,CPPLECT     ECT\n         LA    R15,&ECB           ECB\n         ST    R15,PPLECB\n         L     R15,=V(&PCL.)      PCL\n         ST    R15,PPLPCL\n         LA    R15,&ANS           ANS\n         ST    R15,PPLANS\n         MVC   PPLCBUF,CPPLCBUF   CBUF\n         XC    PPLUWA,PPLUWA\n*\n         DROP  R1\n         EJECT\n*        CALLTSSR EP=IKJPARS      CALL PARSE:\n         CALLTSSR EP=IKJPARS      CALL PARSE:\n         EJECT\n*\n*                        DSECTS NEEDED BY PARSE:\n*\n*CPPL    IKJCPPL\nCPPL     IKJCPPL\n*PPL     IKJPPL\nPPL      IKJPPL\n*\nCVTMAP   DSECT\n         ORG   CVTMAP+524\nCVTPARS  DS    F\nCVTPTR   EQU   16\n*\n*\n&SYSECT  CSECT\n         MEND\n         MACRO\n&L1      MOVE  &TO,&TL,&FROM,&FL,&PAD=\n         LCLA  &NL,&UL,&VL\n         LCLC  &TO$,&TL$,&FROM$,&FL$\n&TO$     SETC  '&TO'\n&TL$     SETC  '&TL'\n&FROM$   SETC  '&FROM'\n&FL$     SETC  '&FL'\n         AIF   ('&TO'(1,1) NE '(').TLC\n&TO$     SETC  '0&TO'\n.TLC     AIF   ('&TL'(1,1) NE '(').FC\n&TL$     SETC  '0&TL'\n.FC      AIF   ('&FROM'(1,1) NE '(').FLC\n&FROM$   SETC  '0&FROM'\n.FLC     AIF   (T'&FL EQ 'O').OO\n         AIF   ('&FL'(1,1) NE '(').OO\n&FL$     SETC  '0&FL'\n.OO      ANOP\n&L1      STM   14,12,12(13)\n         LA    R2,&TO$\n         LA    R3,&TL$\n         LA    R4,&FROM$\n         AIF   (T'&FL EQ 'O').UTL\n         LA    R5,&FL$\n         AGO   .PC\n.UTL     LA    R5,&TL$\n.PC      AIF   ('&PAD' EQ '').NPC\n         ICM   R5,8,=&PAD\n.NPC     MVCL  R2,R4\n         LM    14,12,12(13)\n         MEND\n         MACRO\n&LAB1    ENTERR  &SA=SAVEAREA,&WA=WORKAREA,&WL=WORKLEN,&LEVEL=,&R=,   XX\n               &CLEAR=NO\n         MNOTE ' CLEAR=&CLEAR,SA=&SA,WA=&WA,WL=&WL,LEVEL=&LEVEL'\n&LAB1    CSECT\n         SAVE  (14,12),,&LAB1-&LEVEL\n         LR    R12,R15            HOPE HE KNOWS WHAT HE'S DOING\n         USING &LAB1,R12\n         LR    R10,R1             SAVE PARM PTR R10->PARM PTR\n         L     R0,=A(&WL)         R0=GET LENGTH\n         GETMAIN R,LV=(0)         R1->WORKAREA\n         LR    R11,R13            R11->CALLERS SAVEAREA\n         LR    R13,R1             R13->WORKAREA\n         USING &WA.,R13\n         AIF   ('&CLEAR' NE 'YES').NCLEAR\n         L     R15,=A(&WL)        R0=GET LENGTH\n         S     R15,=F'72'         SKIP REGS\n         MOVE  72(13),(15),0,0,PAD=X'00'\n.NCLEAR  ANOP\n         ST    R11,&SA.+4         SAVE HIS SAVEAREA PTR\n         LA    R13,&SA            R13->SAVEAREA (MINE)\n         ST    R13,8(,R11)        MINE IN HIS\n         LR    R11,R1             R11->WORKAREA IN CASE NOT SAME AS R13\n*                       WORKAREA ADDR IS STILL R13 FOR\n*                       THE ASSEMBLER - IF DIFFERENT FROM R13\n*                       THEN USE: DROP R13 AND USING &WA.,R11\n         LR    R1,R10             RESTORE PARM PTR PTR\n         AIF   ('&R' EQ 'NO').NRE\n         REGEQU\n.NRE     ANOP\n         MEND\n         MACRO\n&LAB1    ENTERNR &SA=SAVEAREA\n&LAB1    START\n         SAVE  (14,12),,*         HO-HUM\n         LR    R12,R15            HOPE HE KNOWS WHAT HE'S DOING\n         USING &LAB1,R12\n         ST    R13,&SA.+4         SAVE HIS SAVEAREA PTR\n         LR    R11,R13            SAVE THE SAVE POINTER\n         LA    R13,&SA            R13->SAVEAREA (MINE)\n         ST    R13,8(,R11)        MINE IN HIS\n         B     ENTEX\n&SA      DS    18F\n         REGEQU\nENTEX    DS    0H\n         MEND\n         MACRO\n&LAB1    COMMENT &A,&B,&C,&D,&E,&F,&G,&H,&I,&J,&K\n         MEND\n         EJECT\n*\n* TSO COMMAND KOMM - CLIST COMMUNICATION ROUTINE FOR 3270 TERMINALS\n*  AUTHOR: KERMIT KISER - WASHINGTON STATE DP SERVICE CENTER (WDPSC).\n*          (206) 902-3119   *****  KOMM  V2M4          *****\n*              V2M4 - MODIFIED FOR VTAM AND 3279 ORDERS 8/3/83\n*\n*  SYNTAX -   KOMM  WCC('CHAR') RESET('LINE') CLEAR\n*                   MESSAGE('ROW','COL','MESS') CURSOR('ROW','COL')\n*                   READTO('VAR')  AI\n*\n*  OPERANDS -\n*             WCC('CHAR') -  'CHAR' IS THE WRITE CONTROL CHARACTER TO\n*                          BE USED. 'C' IS THE DEFAULT.\n*\n*             RESET('LINE') - 'LINE' IS THE LINE YOU WISH TCAM'S LINE\n*                          COUNTER TO BE SET TO. NORMAL OUTPUT BEGINS\n*                          AT THIS LINE. 'LINE' DEFAULTS TO '1'.\n*\n*             CLEAR  -     CAUSES THE SCREEN TO BE CLEARED.\n*\n*             MESSAGE('ROW','COL','MESS') - DISPLAYS A MESSAGE ON THE\n*                          SCREEN. 'ROW' AND 'COL' ARE THE ROW AND\n*                          COLUMN WHERE THE MESSAGE STARTS. 'MESS' IS\n*                          THE MESSAGE (SEE NOTE).\n*\n*             CURSOR('ROW','COL') - MOVES THE CURSOR TO LOCATION GIVEN.\n*\n*             READTO('VAR') - OBTAINS REPLY AND PLACES IN CLIST VAR-\n*                          IABLE 'VAR'. 'VAR' MUST BE PRE-INITIALIZED\n*                          TO HAVE SUFFICIENT ROOM FOR THE REPLY.\n*\n*             AI  -  SUPPRESSES THE REMOVAL OF LEADING SBA FROM REPLY\n         EJECT\n*\n* RETURN-CODES : KOMM RETURNS CODES IN CLIST VAR LASTCC AS FOLLOWS:\n*\n*  WRITE OPERATION ONLY -\n*                       0 - NORMAL COMPLETION\n*                     256 - PARSE ERROR\n*                   OTHER - I/O ERROR OCCURED\n*\n*  WRITE AND READ OPERATION - THE RETURN CODE NORMALLY INDICATES WHICH\n*                                TRANSMIT KEY WAS PRESSED:\n*\n*   241 - PF1   193 - PF13               1 - TEST REQ\n*   242 - PF2   194 - PF14             110 - PA2\n*   243 - PF3   195 - PF15             125 - ENTER\n*   244 - PF4   196 - PF16            2048 - PA1 (KOMM INTERRUPTED\n*   245 - PF5   197 - PF17                             THEN RESUMED)\n*   246 - PF6   198 - PF18\n*   247 - PF7   199 - PF19\n*   248 - PF8   200 - PF20\n*   249 - PF9   201 - PF21\n*   122 - PF10   74 - PF22\n*   128 - PF11   75 - PF23\n*   124 - PF12   76 - PF24\n*\n*      IF NONE OF THE ABOVE:\n*                     256 - PARSE ERROR\n*                     260 - CLIST VARIABLE-NAME NOT FOUND\n*                   OTHER - I/O ERROR OCCURED\n         EJECT\n*\n* MESSAGE-NOTE:\n*                 IN ORDER TO GIVE THE USER MORE CONTROL OVER THE\n*              SCREEN FORMAT, KOMM SCANS THE MESSAGE AND DOES THIS:\n*\n*                 UPON ENCOUNTERING A \u00a2 (CENT SIGN), KOMM REMOVES\n*              THE \u00a2 (CENT SIGN) FROM THE MESSAGE AND TRANSLATES\n*              THE FOLLOWING CHARACTER TO A 3270 CONTROL CHARACTER\n*              OR A TSO PROBLEM CHARACTER, USING THE TABLE BELOW:\n*\n*         3270 CONTROL:                  TSO PROBLEM CHARS:\n*   CHAR   TRANSLATION   HEX          CHAR   TRANSLATION   HEX\n*    _         IC       X'13'          <         (        X'4D'\n*    -         SBA      X'11'          >         )        X'5D'\n*    |         SF       X'1D'          \"         '        X'7D'\n*    *         NULL     X'00'          /         \u00ac        X'5F'\n*    #         RA       X'3C'          \u00a2         \u00a2        X'4A'\n*    @         EUA      X'12'          A    (BROKEN BAR)  X'6A'\n*    .         PT       X'05'          B         ,        X'6B'\n*\n*           OTHERS SHOULD NOT BE CONSIDERED AS DEFINED AT THIS TIME,\n*       BUT ARE GENERALLY TRANSLATED TO THEMSELVES. THE PROBLEM CHARS\n*       ARE TRANSLATED BECAUSE ALL 3270 CHARS ARE USED IN ADDRESS\n*       SPECIFICATION ETC. BUT SOME HAVE SPECIAL SIGNIFICANCE TO TSO.\n*\n* EXAMPLE:\n*           KOMM CLEAR MESS(10,40,'\u00a2#  Z')\n*       WOULD CLEAR THE SCREEN AND FILL FROM LINE 10, COLUMN 40 TO\n*       THE BOTTOM OF THE SCREEN WITH THE LETTER 'Z'.\n*\n*\n*\n         TITLE 'SPECIAL FULLSCREEN COMM RTN'\n*\n*********************************************************************\n*    THIS PROGRAM IS DEPENDENT ON TCAM BEING ASSEMBLED WITH THE     *\n*    'SPFSCRN' MACROS OR EQUIVALENT IF  NOT USING VTAM.             *\n*********************************************************************\n*\n*        STANDARD CP LINKAGE\n*\nKOMM     ENTERR LEVEL=V2M4        R13 -> WORKAREA\n*                                 R12 -> KOMM ADDRESSABILITY\n         EJECT\n*\n*        PARSE THE INPUT COMMAND BUFFER\n*\n         LR    R11,R1             SAVE THE PARM POINTER\n*                                 R11 -> CPPL\nDOPARSE  KKPARSE\n*\n*\nANALR    LTR   R15,R15            RC = 0? PARSE WENT OK?\n         BNZ   PARSERR            NO. -> GO TO PARSE ERR\n         L     R10,ANS            R10 -> IKJPARMD\n         USING IKJPARMD,R10\n         EJECT\n*\n*              SETUP  -  PROCESS  OPERANDS\n*\n*                                 R9 == BAL REGISTER\n*                                 R8 -> CURRENT POSITION IN OUT BUFFER\n         LA    R8,BUFFO\n*\nMAINLINE BAL   R9,WCCP            GET WRITE CNTL CHAR\n         TM    RESET+1,X'FF'      RESET ENTERED?\n         BZ    CCK                NO\n         BAL   R9,RESETP          PUT RESET IN OUT BUFFR\nCCK      TM    CLEAR+1,X'FF'      CLEAR ENTERED?\n         BZ    MCK\n         BAL   R9,CLEARP          PUT CLR IN BUFFR\nMCK      TM    MESS+1,X'FF'       MESSAGE ENTERED?\n         BZ    ICK\n         BAL   R9,MESSP           PUT MSG IN BUFFR\nICK      TM    IC+1,X'FF'         INSERT CURSOR NTRD?\n         BZ    RCK\n         BAL   R9,ICP             PUT IN BUFFR\nRCK      TM    READTO+1,X'FF'     READTO ENTERED?\n         BZ    FIXLEN\n         BAL   R9,READTOP         GET ADDR FOR READTO\nFIXLEN   BAL   R9,SETLEN          INITIALIZE BUFFER LENGTHS\n*\n         LTR   R15,R15            RC=0 SO FAR?\n         BNZ   GETOUT             NO ->EXIT\n         EJECT\n*\n*        PERFORM THE I/O OPERATION NOW\n*\nFULLCHK  TM    FLAGS,X'FF'        INPUT AND OUTPUT?\n         BO    BOTH               YES\n         BZ    WHAT THE HECK?\n         TM    FLAGS,X'F0'        OUTPUT ONLY?\n         BO    RITEONLY           YES\nREADONLY CALL  FULLSCRN,(=C'I',BUFFLI,BUFFI),VL,MF=(E,PARML)\n         B     RCANAL\nRITEONLY CALL  FULLSCRN,(=C'O',BUFFLO,BUFFO),VL,MF=(E,PARML)\n         B     GETOUT\nBOTH     CALL  FULLSCRN,(=C'B',BUFFLO,BUFFO,BUFFLI,BUFFI),VL,          X\n               MF=(E,PARML)\n         B     RCANAL\n*\nWHAT     EQU   *                  WHAT THE HECK ARE WE DOING HERE?\n*\n         LA    R15,99             SET RC=99 TO CAUSE EXIT\n         EJECT\n*\n*         ANALYZE ANY INPUT OBTAINED BY FULLSCRN\n*\nRCANAL   BAL   R9,ERRCK           CHECK ERRORS\n         LTR   R15,R15            CORRECTED?\n         BNZ   GETOUT2            NO.\n*\n         BAL   R9,SETRC           SET RC BY AID BYTE\n         BAL   R9,SETVAR          MOVE ANY INPUT DATA TO CLIST VAR\n*\n*         ISSUE VTAM LINE COUNT RESET IN CASE UNDER VTAM: 8/3/83\n*\nGETOUT   EQU   *\n         TM    RESET+1,X'FF'      RESET ENTERED?\n         BZ    GETOUT2            NO\n         BAL   R9,RESETV          TELL VTAM\n*\nGETOUT2  LEAVER                   EXIT REENTRANT ROUTINE\n         EJECT\n*\n*       KOMM SUBROUTINES HERE\n*\nPARSERR  EQU   *\n         LA    R15,256\n         B     GETOUT\n*\nWCCP     EQU   *                  SETUP OUTPUT BUFFER\n         MVI   0(R8),C'C'         WCC DEFAULT - RESET ONLY\n         TM    CC+6,X'80'         WCC SPECIFIED?\n         BNO   WPP                NO\n         L     R7,CC              GET IT'S ADDRESS\n         MVC   0(1,R8),0(R7)      MOVE IT\n         OI    FLAGS,X'F0'        SET WRITE FLAG\nWPP      LA    R8,1(,R8)          POINT PAST\n         BR    R9\n*\nCLEARP   EQU   *                  SETUP OUTPUT BUFFER\n         MVC   0(7,R8),=X'1140403C404000'  RA TO FILL SCRN W/NULLS\n         OI    FLAGS,X'F0'        SET WRITE FLAG\n         LA    R8,7(,R8)          POINT PAST\n         BR    R9\n*\nRESETP   EQU   *\n         ST    R9,L1LS\n         MVC   0(4,R8),=X'115D7E11' INDICATE RESET LINE COUNT\n         L     R7,LINE            R7 -> BINARY ROW NUMBER\n         L     R7,0(R7)           R7 =   \"      \"    \"\n         LA    R5,1               R5 = 1\n         BAL   R9,CNVTADDR        GET 3270 BUFF TYPE ADDR\n         MVC   4(2,R8),BUFFI      MOVE THE ADDR\n         LA    R8,6(,R8)          POINT PAST\n         OI    FLAGS,X'F0'        SET WRITE FLAG\n         L     R9,L1LS\n         BR    R9                 RETURN\n         SPACE 2                                                  WDPSC\nRESETV   EQU   *                       VTAM RESET SUBRTN ADDED 8/3/83\n         ST    R9,L1LS\n         LR    R5,R15                  SAVE RC\n         L     R7,LINE            R7 -> BINARY ROW NUMBER\n         L     R7,0(R7)           R7 =   \"      \"    \"\n         STLINENO MODE=OFF,LINE=(R7)   TRY VTAM RESET         8/3/83\n         LR    R15,R5                  RESTORE RC\n         L     R9,L1LS\n         BR    R9                 RETURN\n         EJECT\nMESSP    EQU   *\n         ST    R9,L1LS\n         MVI   0(R8),X'11'        SBA\n         L     R7,MROW            R7 -> BINARY ROW NUMBER\n         L     R7,0(R7)           R7 =   \"      \"    \"\n         L     R5,MCOL            R5 -> BINARY COL NUMBER\n         L     R5,0(R5)           R5 =   \"      \"    \"\n         BAL   R9,CNVTADDR        GET 3270 BUFF TYPE ADDR\n         MVC   1(2,R8),BUFFI      MOVE THE ADDR\n         L     R7,MTEXT           GET TEXT ADDR R7-> TEXT\n         LH    R6,MTEXT+4         GET TEXT LENGTH  R6= LEN\n         BCTR  R6,R0              THEN EXECUTE     R6=R6-1\nMOVE     MVC   3(0,R8),0(R7)      MOVE INSTRUCTION (EXECUTED)\n         EX    R6,MOVE            MOVE TEXT\n*\n         LR    R5,R6              R5=LENGTH-1\n         LA    R7,3(,R8)          R7->TRANS START\nTRLOOP   EX    R5,TRANT           SCAN FOR \u00a2 (CENT SIGN)\n         BZ    TRDONE             NONE FOUND\n         TR    1(1,R1),TABLE2     TRANSLATE FOLLOWING CHAR\n         BCTR  R6,R0              R6=R6-1 UPDATE STRING LENGTH\n         LA    R7,1(,R1)          R7->NEW TRANS START\n         LA    R5,4(R8,R6)        R5->NEW LAST CHAR\n         SR    R5,R7              R5= NEW LENGTH\n         BNP   TREX               NOT ENOUGH TO TRANSLATE\n         EX    R5,TRMVC           SHIFT STRING ONE TO LEFT\n         BCTR  R5,R0              R5=R5-1 UPDATE SCAN LENGTH\n         B     TRLOOP             CHECK FOR MORE\nTRANT    TRT   0(0,R7),TABLE3     EXECUTED TRANSLATE\nTRMVC    MVC   0(0,R1),1(R1)      EXECUTED LEFT SHIFT\nTREX     EX    R5,TRMVC           DO LEFT SHIFT\nTRDONE   LA    R8,4(R6,R8)        POINT PAST\n         OI    FLAGS,X'F0'        SET WRITE FLAG\n         L     R9,L1LS\n         BR    R9                 RETURN\n         EJECT\nICP      EQU   *\n         ST    R9,L1LS\n         L     R7,ICROW           R7 -> BINARY ROW NUMBER\n         L     R7,0(R7)           R7 =   \"      \"    \"\n         L     R5,ICCOL           R5 -> BINARY COL NUMBER\n         L     R5,0(R5)           R5 =   \"      \"    \"\n         BAL   R9,CNVTADDR        GET 3270 BUFF TYPE ADDR\n         MVI   0(R8),X'11'        SBA\n         MVC   1(2,R8),BUFFI      MOVE THE ADDR\n         MVI   3(R8),X'13'        SAY IC\n         LA    R8,4(,R8)          POINT PAST\n         OI    FLAGS,X'F0'        SET WRITE FLAG\n         L     R9,L1LS\n         BR    R9                 RETURN\n*\nSETLEN   EQU   *\n         LA    R7,BUFFO           R7 -> BUFFO (R8->END OF BUFFO)\n         SR    R8,R7              R8=BUFFER LENGTH OUT\n         STH   R8,BUFFLO          SAVE IT IN BUFFLO\n         MVC   BUFFLI(2),=H'256'  ALSO SET BUFFLI\n         BR    R9                 RETURN\n*\n         EJECT\nREADTOP  EQU   *\n         L     R5,CPPLECT         R5->ECT\n         L     R5,4(,R5)          R5->IOSRL\n         L     R4,0(,R5)          R4->TOP OF STACK\nCKCLIST  TM    0(R4),X'08'        CLIST ELEMENT?\n         BO    GOTCL              YES->WE HAVE A CLIST\n         S     R4,=F'4'           R4=R4-4 (NEXT ELEMENT DOWN ON STACK)\n         C     R4,4(,R5)          R4<BOTTOM OF STACK PTR?\n         BNL   CKCLIST            NO ->STILL IN STACK; GO CHECK IT\n         LA    R15,260            YES->R15=260=RC\n         BR    R9                 EXIT READTOP WITH ERROR\nGOTCL    L     R7,RDD             R7->VARIABLE NAME\n         LH    R6,RDD+4           R6=VAR LENGTH FOR LENGTH COMPARE\n         L     R5,0(,R4)          R5->LSD\n         L     R5,12(,R5)         R5->EXECDATA\n         L     R5,0(,R5)          R5->SNTAB\n         L     R4,8(,R5)          R4==USED TABLE LENGTH\n         LA    R4,0(R4,R5)        R4->END OF TABLE USED\n         LA    R3,12(,R5)         R3->FIRST SNTAB ENTRY\n         LR    R1,R6              R1=R6  VARIABLE NAME LENGTH\n         BCTR  R1,R0              R1=R1-1 FOR EXECUTED COMPARE\n*\nRLOOP    LH    R2,6(,R3)          R2=NAME LENTH\n         CR    R6,R2              SAME LENGTH?\n         BNE   LOOPCHK            NO -> CHECK DONE\nCOMPARE  CLC   0(0,R7),8(R3)      EXECUTED\n         EX    R1,COMPARE         COMPARE NAMES\n         BE    GOTIT\nLOOPCHK  LA    R3,8(R2,R3)        POINT TO NEXT ENTRY\n         CR    R3,R4              DONE?\n         BL    RLOOP              NO->CONTINUE\nRERR     LA    R15,260       R15= RC=260\n         BR    R9                 EXIT READTOP WITH ERROR\nGOTIT    EQU   *\n         L     R1,0(,R3)          GET VALUE ADDR\n         ST    R1,VALADDR         SAVE IT\n         OI    FLAGS,X'0F'        SET READ FLAG\n         BR    R9                 RETURN\n         EJECT\nERRCK    EQU   *\n         BR    R9\n*\nSETRC    EQU   *\n         IC    R15,BUFFI          PICK UP AID BYTE IN R15\n         BR    R9                 RETURN\n*\nSETVAR   EQU   *\n         L     R7,VALADDR         R7->VALUE TABLE ENTRY\n         LH    R8,BUFFLI          GET INPUT LENGTH\n         CH    R8,=H'3'           LEN > 3 ?\n         BNH   SETNULL            NO -> SET VARIABLE TO NULL\n         SH    R8,=H'3'           R8=R8-3  SKIP AID,CURSOR ADDR\n         LA    R6,BUFFI+3         PT PAST  \"\n         CLI   AI+1,X'00'         AI ENTERED?\n         BNE   ROOMCHK            YES -> LEAVE SBA IN\n         CLI   0(R6),X'11'        SBA START MESSAGE?\n         BNE   ROOMCHK            NO -> ASSUME ITS DATA\n         LA    R6,3(,R6)          R6=R6+3  SKIP SBA,ADDR\n         SH    R8,=H'3'           AND FIX LENGTH\n         BNP   SETNULL            IN CASE?\nROOMCHK  CH    R8,2(,R7)          ROOM FOR INPUT?\n         BNH   SM                 YES->MOVE IT.\n         LH    R8,2(,R7)          NO ->GET HIS LENGTH\nSM       STH   R8,0(,R7)          STORE CORRECT LENGTH\n         BCTR  R8,R0              R8=R8-1\n         EX    R8,SMOVE           MOVE IT\n         BR    R9\nSMOVE    MVC   4(0,R7),0(R6)      EXECUTED\nSETNULL  SLR   R8,R8              R8=0\n         STH   R8,0(,R7)          STORE ZERO LENGTH\n         BR    R9                 RETURN\n         EJECT\n*\nCNVTADDR EQU   *                  CHANGE FROM BINARY ADDRESS\n*                                 MODULO 80 TO 3270 ADDRESS\n*                                 MODULO 64  -  INPUT:\n*                                 R7 = ROW , R5 = COL\n         BCTR  R7,R0              R7=R7-1\n         BCTR  R5,R0              R5=R5-1\n         MH    R7,=H'80'          R7=R7*80\n         AR    R7,R5              R7=R7+R5\n         SLR   R6,R6              R6=0\n         D     R6,=F'64'          (R6,R7)/64 R6=REMAINDER,R7=QUOTIENT\n         N     R7,=X'0000003F'    JUST IN CASE\n         STC   R7,BUFFI           PUT ROW IN WORKAREA\n         STC   R6,BUFFI+1         PUT COL IN WORKAREA\n         TR    BUFFI(2),TABLE1    CHANGE TO 3270 ADDRESS\n         BR    R9\n*\n         EJECT\n*\n*        STATIC WORKAREA\n*\nTABLE1   DC    C' ABCDEFGHI\u00a2.<(+|&&JKLMNOPQR!$*);\u00ac'\n         DC    C'-/STUVWXYZ ,%_>?0123456789:#@''=\"'\n         ORG   TABLE1+X'2A'\n         DC    X'6A'\n         ORG\n*\n*  TRANSLATE CHARS PRECEEDED BY A CENT SIGN (\u00a2)\n*\n*            3270                      TSO\n*        \u00a2_ -> IC  (13)            \u00a2< -> (  (4D)\n*        \u00a2- -> SBA (11)            \u00a2> -> )  (5D)\n*        \u00a2| -> SF  (1D)            \u00a2\" -> '  (7D)\n*        \u00a2* -> NULL(00)            \u00a2/ -> \u00ac  (5F)\n*        \u00a2# -> RA  (3C)            \u00a2\u00a2 -> \u00a2  (4A)   CENT SIGN\n*        \u00a2@ -> EUA (12)            \u00a2A ->    (6A)   BROKEN VERT BAR\n*        \u00a2. -> PT  (05)            \u00a2B -> ,  (6B)\n*            3279\n*        \u00a2$ -> SFE (29) SF EXTNDED \u00a21 ->    (01)\n*        \u00a2% -> MF  (2C) MOD FLD    \u00a22 ->    (02)\n*        \u00a2S -> SA  (28) SET ATTR   \u00a23 ->    (03)\n*        \u00a2C ->     (42) COLOR      \u00a24 ->    (04)\n*        \u00a2H ->     (41) HIGHLITE   \u00a25 ->    (05)\n*        \u00a2G ->     (43) SYM SET    \u00a26 ->    (06)\n*                                  \u00a27 ->    (07)\n*                                  \u00a28 ->    (08)\n*                                  \u00a29 ->    (09)\n*                                  \u00a2  ->    (0A)\n*                                  \u00a2  ->    (0B)\n*                                  \u00a2  ->    (0C)\n*                                  \u00a2  ->    (0D)\n*                                  \u00a2  ->    (0E)\n*                                  \u00a2  ->    (0F)\n*\nTABLE2   DC    X'000102030405060708090A0B0C0D0E0F'\n         DC    X'101112131415161718191A1B1C1D1E1F'\n         DC    X'202122232425262728292A2B2C2D2E2F'\n         DC    X'303132333435363738393A3B3C3D3E3F'\n         DC    X'404142434445464748494A054D4D4E1D'   05 4D 1D\n         DC    X'505152535455565758595A29005D5E5F'   29 00\n         DC    X'115F62636465666768696A6B2C135D6F'   11 5F 13 5D 2C\n         DC    X'707172737475767778797A3C127D7E7D'   3C 12 7D\n         DC    X'808182838485868788898A8B8C8D8E8F'\n         DC    X'909192939495969798999A9B9C9D9E9F'\n         DC    X'A0A1A2A3A4A5A6A7A8A9AAABACADAEAF'\n         DC    X'B0B1B2B3B4B5B6B7B8B9BABBBCBDBEBF'\n         DC    X'C06A6B42C4C5C64341C9CACBCCCDCECF'   6A 6B 42 43 41\n         DC    X'D0D1D2D3D4D5D6D7D8D9DADBDCDDDEDF'\n         DC    X'E0E128E3E4E5E6E7E8E9EAEBECEDEEEF'   28\n         DC    X'000102030405060708090A0B0C0D0E0F'\n         EJECT\nTABLE3   DC    XL256'00'\n         ORG   TABLE3+74\n         DC    X'04'\n         ORG\n*\nPTCHAREA DC    XL128'00'\n*\n         LTORG\n         EJECT\n*\n*   WORKING STORAGE AREA - DYNAMIC\n*\nWORKAREA DSECT\nSAVEAREA DS    18F\nPARML    CALL  ,(IOPARM,BUFFLO,BUFFO,BUFFLI,BUFFI),MF=L\n*\nIOPARM   DS    X\nBUFFLO   DS    H\nBUFFLI   DS    H\n         DS    0F\nBUFFO    DS    CL256\nBUFFI    DS    CL256\n*\nFLAGS    DC    F'0'\nL1LS     DC    F'0'\nVALADDR  DC    F'0'\nANS      DC    F'0'\nECB      DC    F'0'\nPPLA     DS    7F\nWORKLEN  EQU   *-WORKAREA\nKOMM     CSECT\n         EJECT\n*\nPCL      IKJPARM\nCLEAR    IKJKEYWD\n         IKJNAME   'CLEAR',ALIAS=('CL','C')\nWCC      IKJKEYWD\n         IKJNAME   'WCC',SUBFLD=CCFLD,ALIAS=('W','CC')\nRESET    IKJKEYWD\n         IKJNAME   'RESET',SUBFLD=LINEFLD,ALIAS=('RES','R')\nMESS     IKJKEYWD\n         IKJNAME   'MESSAGE',SUBFLD=MFLD,ALIAS=('MESS','MSG','M')\nIC       IKJKEYWD\n         IKJNAME   'IC',SUBFLD=ICFLD,ALIAS=('CURSOR','CUR','I')\nREADTO   IKJKEYWD\n         IKJNAME   'READTO',SUBFLD=RDFLD,ALIAS=('READ','RT')\nAI       IKJKEYWD\n         IKJNAME   'AI',ALIAS=('ASIS')\n*  SUBFIELD DESCRIPTIONS FOLLOW\nCCFLD    IKJSUBF\nCC       IKJIDENT 'WCC',MAXLNTH=2,PROMPT='WCC',CHAR\n*\nLINEFLD  IKJSUBF\nLINE     IKJIDENT 'RESET LINE NO',DEFAULT='1',INTEG\n*\nMFLD     IKJSUBF\nMROW     IKJIDENT 'MSG ROW',MAXLNTH=2,PROMPT='MSG ROW',INTEG\nMCOL     IKJIDENT 'MSG COL',MAXLNTH=2,PROMPT='MSG COL',INTEG\nMTEXT    IKJIDENT 'MSG TEXT',PROMPT='MSG TEXT',CHAR\n*\nICFLD    IKJSUBF\nICROW    IKJIDENT 'IC ROW',MAXLNTH=2,PROMPT='IC ROW',INTEG\nICCOL    IKJIDENT 'IC COL',MAXLNTH=2,PROMPT='IC COL',INTEG\n*\nRDFLD    IKJSUBF\nRDD      IKJIDENT 'INPUT VARIABLE',PROMPT='INPUT VARIABLE',CHAR\n         IKJENDP\n         TITLE 'FULLSCRN - 3270 I/O SUBROUTINE'\n*          DATA SET 761KKFSCRN AT LEVEL 002 AS OF 06/07/78\n*  AUTHOR: KERMIT KISER - WASHINGTON STATE DP SERVICE CENTER (WDPSC).\n*          (206) 902-3119\nFULLSCRN CSECT\nFULLSC   DS    0H\n         ENTRY FULLSC\n         SAVE  (14,12),,*         HO-HUM\n         LR    R12,R15            HOPE HE KNOWS WHAT HE'S DOING\n         USING FULLSCRN,R12\n*\n*   GET THE INPUT PARAMETERS:\n*           CALL 'FULLSCRN' USING IOPARM OUTLEN OUTBUFF /RETLEN/\n*                                        INLEN  INBUFF  /RETLEN/ .\n*\n*  OUTBUFF:  ESC/COM/WCC/SBA/ADDR/SF/ATTR/TEXT/IC\n*  INBUFF :  AID/CURSOR-ADDR/SBA/ADDR/TEXT/..SBA/ADDR/TEXT....\n*\nGETPARMS LR    R11,R1             SAVE THE PARM POINTER\n         L     R10,0(R11)         R10 -> IOFLAG\n         L     R8,4(R11)          R8  -> OUT BUFFLEN\n         LH    R8,0(R8)           R8  =  OUT BUFFLEN\n         L     R7,8(R11)          R7  -> OUT BUFFADDR\n         N     R7,=X'00FFFFFF'    FIX ADDR (REMOVE VL FLAG)\n         SLR   R4,R4              R4=0\n         TM    8(R11),X'80'       MORE?\n         BO    SAMEIN             NO.\n*\nLENCH    TM    12(R11),X'80'      ONE MORE PARM?\n         BNO   MOREIN             NO-> MAYBE TWO\n         L     R4,12(R11)         R4->RETURN LENGTH BUFFER\n         B     SAMEIN             GO ON\nMOREIN   TM    16(R11),X'80'      TWO MORE PARMS?\n         BO    DIFFIN             YES->INPUT PARMS ONLY\n         L     R4,20(,R11)        NO-> R4 -> RET LEN BUFFER\n*\nDIFFIN   L     R9,12(R11)         R9  -> IN BUFFLEN\n         LH    R6,0(R9)           R6  =  BUFFLEN\n         L     R5,16(R11)         R5  -> IN BUFFADDR\n         B     RETCH\nSAMEIN   L     R9,4(R11)          R9  -> IN BUFFLEN\n         LH    R6,0(R9)           R6  =  BUFFLEN\n         LR    R5,R7              R5  -> IN BUFFADDR\n*\nRETCH    LTR   R4,R4              R4=0 STILL?\n         BNZ   WRITECHK           NO->LEAVE IT THEN\n         LR    R4,R9              R4->RET LEN BUFF (COMPATIBLE W/OLD)\n         EJECT\n*\n*   CHECK FOR A WRITE\n*\nWRITECHK SLR   R3,R3              R3=0\n         CLI   0(R10),C'O'        OUTPUT?\n         BE    BUFFRITE           YES.\n         CLI   0(R10),C'B'        BOTH INPUT AND OUT?\n         BNE   READCHK            NO.\nBUFFRITE TPUT  (R7),(R8),FULLSCR,HOLD  FULLSCREEN TPUT\n         LR    R3,R15             R3  =  RET CODE\n         SLR   R15,R15            R15 CLEARED\n*\n*   CHECK FOR A READ\n*\nREADCHK  CLI   0(R10),C'I'        INPUT?\n         BE    BUFFREAD           YES.\n         CLI   0(R10),C'B'        BOTH INPUT AND OUT?\n         BNE   FINISH             NO.\nBUFFREAD TGET  (R5),(R6),ASIS     GET WHAT WE CAN\n         STH   R1,0(R4)           GIVE HIM THE LENGTH\n*\n*   RETURN\n*\nFINISH   SLL   R15,8(0) SAVE TGET RETURN CODE\n         OR    R15,R3    GET TPUT RETURN CODE\nEXIT     RETURN (14,12),RC=(15)   QUIT\n         EJECT\n         LTORG\n         END\n          TITLE  'TERMTYPE - PROGRAM TO INDICATE TERMINAL TYPE'\n*  AUTHOR: KERMIT KISER - WASHINGTON STATE DP SERVICE CENTER (WDPSC).\n*          (206) 902-3119\n*\n* THIS PROGRAM RETURNS A CODE WHICH DEPENDS ON THE TSO USERS TERMINAL:\n*      0 - TERMINAL IS A TTY TYPE\n*     24 - TERMINAL IS A 3270 TYPE\n*  IT CAN BE CALLED FROM A CLIST TO DECIDE WHEN TO USE THE KOMM CMD.\n*  THE RETURN CODE IS THEN PLACED IN CLIST VARIABLE &LASTCC.\n*\n*          DATA SET 761KKTTYPE AT LEVEL 001 AS OF 01/08/79\nTERMTYPE ENTERR\n         GTSIZE\n         LR    R15,R0             R15=SCREEN SIZE=0 IF TTY\n         LEAVER\n*\n*   WORKING STORAGE AREA - DYNAMIC\n*\nWORKAREA DSECT\nSAVEAREA DS    18F\nWORKLEN  EQU   *-WORKAREA\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "KOMM$": {"ttr": 22278, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x00\\x7f\\x00\\x88\\x00\\x7f\\x12\\x00\\x00f\\x00f\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf2\\xf7\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-01-07T00:00:00", "modifydate": "1988-01-07T12:00:00", "lines": 102, "newlines": 102, "modlines": 0, "user": "FILE270"}, "text": "1 10.030\n-                                                           KOMM command\n0Function -\n0  The KOMM command is a CLIST communication routine for 3270 terminals.\n It is for use within CLISTs to give simple applications control over\n the formatting capabilities of the 3270 type terminals.\n\n Syntax -\n _______________________________________________________________________\n0     Command              Operands\n _______________________________________________________________________\n0     KOMM              WCC(char)  RESET(line)  CLEAR\n                        MESSAGE(row,col,'mess')  CURSOR(row,col)\n                        READTO(variable)  AI\n _______________________________________________________________________\n-Operands -\n0 Required - None.\n-  WCC(char) -    char is the write control character to be used\n                  (see a 3270 programming guide for description).\n                  'C' is the default if this operand is not used.\n0  RESET(line) -  line is the line you wish the line count to be set to.\n                  Normal output (non-fullscreen) will begin at this line.\n                  line defaults to '1' if the subfield is omitted.\n0  CLEAR -        Causes the 3270 screen to be cleared.\n0  MESSAGE(row,col,'mess') -\n                  Displays a message on the 3270 screen. \"row,col\" is\n                  where the message begins. \"mess\" is the message to be\n                  displayed. A \"\u00a2\" in the message must appear as \"\u00a2\u00a2\"\n                  (See \"message-note\" below).\n0  CURSOR(row,col) -\n                  This causes the cursor to move to the given location.\n                  An alternate name for this operand is IC(row,col).\n0  READTO(var) -  This requests the command to obtain a reply and place\n                  it in the CLIST variable \"var\". The variable must\n                  be initialized with a data field at least as large\n                  as the reply you may obtain.\n0  AI -           This operand tells the command not to remove the\n                  leading SBA sequence from the input buffer.\n1 10.030                                                   (KOMM cont.)\n-\n-Example -\n0 If you enter the following command on a 3270 terminal:\n0  KOMM CLEAR MESS(10,40,'\u00a2#bbZ')\n0 where bb indicates two spaces for the RA address, the screen will be\n  cleared, then all positions from column 40 of line 10 to the bottom\n  of the screen would be filled with the letter \"Z\".\n-(Continued on next page.)\n1 10.030                                                   (KOMM cont.)\n-\n-Return-codes note--> KOMM return codes are as follows:\n- WRITE operation only return codes-\n0   ____________________________________________________________________\n0              0 - normal completion\n             256 - parse error occured\n           other - I/O error occured\n    ____________________________________________________________________\n0\n- READ operation return codes - The return code, if a read operation\n      was requested, normally indicates which transmit key was pressed:\n0   ____________________________________________________________________\n0    241 - PF1        193 - PF13             1 - TEST REQ\n     242 - PF2        194 - PF14           110 - PA2\n     243 - PF3        195 - PF15           125 - ENTER\n     244 - PF4        196 - PF16          2048 - PA1 (Followed by ENTER)\n     245 - PF5        197 - PF17\n     246 - PF6        198 - PF18\n     247 - PF7        199 - PF19\n     248 - PF8        200 - PF20\n     249 - PF9        201 - PF21\n     122 - PF10        74 - PF22\n     123 - PF11        75 - PF23\n     124 - PF12        76 - PF24\n    ____________________________________________________________________\n0        Other read return codes are:\n0            256 - parse error occured\n             260 - CLIST variable-name not found\n           other - I/O error occured\n    ____________________________________________________________________\n1 10.030                                                   (KOMM cont.)\n-\n-Message note--> In order to give the user more control over the\n         3270 screen format, KOMM scans the message line and upon\n         encountering a \"\u00a2\" (cent symbol) , removes the \"\u00a2\" from\n         the message and translates the following character to a\n         3270 control character or a TSO problem character, using\n         the table given below:\n    ____________________________________________________________________\n0        3270 control characters           TSO problem characters\n        char   translation   hex          char   translation   hex\n         _         IC        13            <          (        4d\n         -         SBA       11            >          )        5d\n         |         SF        1d            \"          '        7d\n         *         NULL      00            /          \u00ac        5f\n         #         RA        3c            \u00a2          \u00a2        4a\n         @         EUA       12            A          \u00a6        6a\n         .         PT        05            B          ,        6b\n    ____________________________________________________________________\n0           Others should not be considered as defined at this time,\n         but are generally translated to themselves. The problem\n         characters are translated because, while all 3270 characters\n         are used in screen address specification, some have special\n         significance to TSO and cannot be used in the command.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LASTLNK$": {"ttr": 22281, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x00\\x7f\\x00\\x88\\x00\\x7f\\x12\\x00\\x00>\\x00>\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf2\\xf7\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-01-07T00:00:00", "modifydate": "1988-01-07T12:00:00", "lines": 62, "newlines": 62, "modlines": 0, "user": "FILE270"}, "text": "1                                                        LASTLINK.1\n                                                         06/25/82\n\n\n  CLIST:              LASTLINK\n  AUTHOR:             Jeff Sprehn\n  AGENCY:             WDPSC\n  FUNCTION:           Display info about  the last time a  COBOL or\n                      Assembler program was compiled and linked.\n\n  TERMINAL TYPE: 3270 type or dialup\n\n  The LASTLINK CLIST  is used to produce a report  on your terminal\n  showing for the load module itself and all of its subroutines the\n  date of  the last  linkage edit.   The LASTLINK  CLIST shows  the\n  following:\n\n       a.   The date and  the release level used the  last time the\n            load module was produced.\n\n       b.   For  each   CSECT,  the  CSECT  name,   compiler  used,\n            version/mod and date is given.\n\n  Syntax -\n  _________________________________________________________________\n       Command        Operands\n  _________________________________________________________________\n        LASTLINK      VOL(vol ser no)\n  _________________________________________________________________\n\n  This  CLIST will  prompt  you for  the name  of  the load  module\n  library and its member name.\n\n  Optional parameter -\n       VOL(vol ser no)     to be used if your dataset is not cataloged\n\n\n\n\n1                                                        LASTLINK.2\n                                                         06/25/82\n\n\n  Sample output -\n                        LOAD MODULE TSODITTO\n      THIS LOAD MODULE WAS PRODUCED AT LEVEL 03.08 ON 11/13/80\n\n  CSECT               TRANSLATOR          VR.MD          YR/DY\n  TSODITTO            5740CB103           02.03          11/13/80\n  FULLSCR3            5741SC103           02.01          08/02/80\n  ILBOEXT             5741SC103           02.01          06/22/80\n  ILBOQIO             5741SC103           02.01          06/22/80\n  ILBOSRV             5741SC103           02.01          06/22/80\n  ILBOTRN             5741SC103           02.01          06/22/80\n  ILBOWTB             5741SC103           02.01          06/22/80\n  TRNSTRK             5741SC103           02.01          12/19/79\n  DITTOSC1            5741SC103           02.01          10/04/80\n  DITTOSC2            5741SC103           02.01          10/05/80\n\n\n\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "LINKUPDT": {"ttr": 22283, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x00\\x7f\\x00\\x88\\x00\\x7f\\x12\\x00\\x00_\\x00_\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf2\\xf7\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-01-07T00:00:00", "modifydate": "1988-01-07T12:00:00", "lines": 95, "newlines": 95, "modlines": 0, "user": "FILE270"}, "text": "//*\n//*  ATTENTION! THIS MEMBER IS NO LONGER USED! THERE IS NOW A\n//*             SUBROUTINE IKJUPDT WHICH CAN BE LINKED WITH PROGRAMS\n//*             USING THE OLD CALL IKJUPDT TECHNIQUE TO REPLACE\n//*             IKJCT433 WITH A LINK TO SETVAR\n//*\n//ZZZZZZZZ JOB\n//*\n//*  THIS IS A JOB TO CREATE A MODULE CALLED IKJUPDT WHICH CAN\n//*   BE CALLED BY A TSO COMMAND TO PLACE DATA INTO CLIST VARIABLES\n//*   FOR LATER REFERENCE. IKJUPDT IS AN ENTRY POINT IN CSECT\n//*   IKJCT433 OF IBM LOAD MODULE IKJPTGT (PUTGET). IT MUST FIRST\n//*   BE EXTRACTED BY THE LINK EDITOR THEN MODIFIED BY SUPERZAP TO\n//*   FORCE IT TO CREATE VARIABLES WHICH DO NOT ALREADY EXIST.\n//*\n//JOBCAT   DD DISP=SHR,DSN=\n//LKED    EXEC PGM=IEWL,PARM='XREF,LIST,LET,RENT',REGION=500K\n//*\n//*  EXTRACT IKJUPDT (CSECT=IKJCT433) FROM IKJPTGT:\n//*\n//*                           (IGNORE UNRESOLVED SYMBOLS)\n//SYSLIN   DD DDNAME=SYSIN\n//SYSLMOD  DD DISP=SHR,DSN=YOUR.LOADLIB\n//SYSLOLD  DD DISP=SHR,DSN=SYS1.LPALIB\n//SYSUT1   DD UNIT=SYSDA,SPACE=(1024,(50,20))\n//SYSPRINT DD SYSOUT=A\n//SYSIN DD *\n REPLACE IKJEFT30\n REPLACE IKJEFT35\n REPLACE IKJEFT40\n REPLACE IKJEFT45\n REPLACE IKJEFT52\n REPLACE IKJEFT53\n REPLACE IKJEFT54\n REPLACE IKJEFT55\n REPLACE IKJEFT56\n REPLACE IKJRBBMC\n REPLACE IKJCT434\n REPLACE IKJCT436\n INCLUDE SYSLOLD(IKJPTGT)\n NAME IKJUPDT\n//*\n//*            THE FOLLOWING\n//*            ZAP MUST BE APPLIED TO CAUSE IKJCT433 TO CREATE\n//*            VARIABLES WHICH HAVE NOT YET BEEN DEFINED BY THE CLIST.\n//*            IF YOU DON''T USE THE ZAP\n//*            THE PROGRAM WILL ONLY BE\n//*            ABLE TO UPDATE VARIABLES, NOT CREATE THEM...\n//*\n//SUPERZAP EXEC PGM=AMASPZAP\n//SYSPRINT DD  SYSOUT=A\n//SYSLIB DD DISP=SHR,DSN=YOUR.LOADLIB\n//**\n//**  SUPERZAP TO IKJUPDT TO FORCE THE CREATION OF CLIST VARIABLES:\n//**           (IKJUPDT IS AN ENTRY POINT IN IKJCT433)\n//**\n*   (FOR BASE LEVEL:)\n*\n NAME IKJUPDT IKJCT433\n VER 0011 F7F74BF2F1F5    77.215 =  BASE LEVEL\n VER  0ADE 41F0A88A\n REP  0ADE 41F0A8AA\n*\n*   (FOR UZ61714 LEVEL:)\n*\n NAME IKJUPDT IKJCT433\n VER 0010 F8F24BF3F4F8    82.348 =  UZ61714\n VER 1BA6 D503F000A8E2   CLC FUNC,  =F'8'   ADD?\n VER 1BAC 4770BB99       BNE        NOADD\n REP 1BAC 4700           NOP        FORCE THE ADD NAME CALL\n//*\n//* A TSO COMMAND USES IKJUPDT AS FOLLOWS:\n//*\n//*      CALL  IKJUPDT(UPT,ECT,ECB,UPLIST)\n//*\n//*           UPT = USER PROFILE TABLE       (FROM CPPL)\n//*           ECT = ENVIRONMENT CONTROL TABLE   \"   \"\n//*           ECB = COMMAND PROCESSOR ECB\n//*           UPLIST = A FOUR WORD BLOCK AS BELOW:\n//*\n//*\n//*   UPLIST  DS  0XL16\n//*   LOCPTR  DS  AL4         PTR TO VARIABLE NAME\n//*   LOCLEN  DS  F           LENGTH OF VARIABLE NAME\n//*   VALPTR  DS  A           PTR TO DATA VALUE\n//*   VALLEN  DS  F           LENGTH OF DATA VALUE\n//*\n//* EXAMPLE : SET &VAR = &STR(MYDATA)\n//*\n//*   UPLIST  DS  0XL16\n//*   LOCPTR  DC  A(=C'VAR')    PTR TO VARIABLE NAME\n//*   LOCLEN  DC  F'3'          LENGTH OF VARIABLE NAME\n//*   VALPTR  DC  A(=C'MYDATA') PTR TO DATA VALUE\n//*   VALLEN  DC  F'6'          LENGTH OF DATA VALUE\n//*\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LISTMEM$": {"ttr": 22286, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x00\\x7f\\x00\\x88\\x00\\x7f\\x12\\x00\\x006\\x006\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf2\\xf7\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-01-07T00:00:00", "modifydate": "1988-01-07T12:00:00", "lines": 54, "newlines": 54, "modlines": 0, "user": "FILE270"}, "text": "1                                                        LISTMEMS.1\n                                                         03/16/83\n\n\n  PROGRAM:       LISTMEMS\n  AUTHOR:        Jeff Sprehn\n  AGENCY:        WDPSC\n  LANGUAGE:      Assembler\n  LOCATION:      WDPSC.SHARED.LOAD\n  FUNCTION:      Given the name of a  partitioned data set, produce\n                 an output file whose records  contain the names of\n                 the members of that PDS (one record per member).\n\n  RUN MODE:      Batch or Interactive\n\n  This program is  used to produce an output  file (LRECL=80) which\n  will contain  (in record positions 1-8)  the member names  of the\n  partitioned data set which is allocated to the DDNAME INPDS.\n\n  HOW TO USE THIS PROGRAM:\n\n      IN BATCH:\n\n            //    EXEC PGM=LISTMEMS\n            //STEPLIB  DD  DISP=SHR,DSN=WDPSC.SHARED.LOAD\n            //INPDS    DD  DISP=SHR,DSN=dataset name of your PDS\n            //OUTMEMS  DD  UNIT=SYSDA,DISP=(NEW,PASS),\n            //   DSN=&&MEMBERS,\n            //   SPACE=(TRK,(2,1)),\n            //   DCB=(RECFM=FB,LRECL=80,BLKSIZE=6160)\n\n\n\n\n1                                                        LISTMEMS.2\n                                                         03/16/83\n\n\n       UNDER TSO:\n\n            ATTR AT1 RECFM(F,B) LRECL(80) BLKSIZE(6160)\n            ALLOC F(INPDS) DA('dataset name of your PDS') SHR\n            ALLOC F(OUTMEMS) DA('work dataset name') NEW -\n                  UNIT(SYSDA) TRACKS SPACE(2,1) -\n                  USING(AT1)\n            CALL 'WDPSC.SHARED.LOAD(LISTMEMS)'\n\n  NOTE:  LISTMEMS will output a valid dummy NULLFILE if your PDS\n         contains no records.  Therefore, a subsequent step that\n         reads the dataset would result in an immediate EOF.\n\n\n\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "LISTMEMS": {"ttr": 22529, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x00\\x7f\\x00\\x88\\x00\\x7f\\x12\\x00\\x00\\xf5\\x00\\xf5\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf2\\xf7\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-01-07T00:00:00", "modifydate": "1988-01-07T12:00:00", "lines": 245, "newlines": 245, "modlines": 0, "user": "FILE270"}, "text": "         SPACE 3\n**********************************************************************\n*                                                                    *\n*        LISTMEMS                                                    *\n*        --------                                                    *\n*                                                                    *\n*              MODIFIED APRIL 1985 TO INCLUDE A PARM WHICH WILL      *\n*              ALLOW SUBSETTING THE OUTPUT FILE BASED UPON A         *\n*              PARM MASK.  FOR EXAMPLE, PARM='MASK=ABC**999'         *\n*              WILL OUTPUT ONLY THOSE MEMBER NAMES BEGINNING WITH    *\n*              'ABC', FOLLOWED BY ANY TWO CHARACTERS AND THEN        *\n*              FOLLOWED BY '999'.  ANOTHER EXAMPLE PARM='MASK=A15'   *\n*              WILL OUTPUT ALL MEMBER NAMES BEGINNING WITH 'A15'.    *\n*                                                                    *\n**********************************************************************\n*\nLISTMEMS CSECT\n         SAVE  (14,12)\n         BALR  11,0\n         USING *,11\n         ST    13,SAVEAREA+4\n         LA    13,SAVEAREA\n         B     STARTIT\n         SPACE\nSAVEAREA DC    18F'0'\n         EJECT\n         SPACE 3\n********************************************************************\n*        EQUATE RESISTERS 0 THRU 15 TO MORE MEANINGFUL NAMES       *\n********************************************************************\n         SPACE 3\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n         EJECT\n         SPACE 3\n********************************************************************\n*                                                                  *\n*        SAVE REGISTER 1 CONTENTS IN REGISTER 11 AND PLACE         *\n*        PARAMETER AREA INTO PARMAREA                              *\n*                                                                  *\n********************************************************************\n         SPACE 3\nSTARTIT  DS    0D\n         LR    R10,R1                 SAVE REG 1 CONTENTS IN REG 10\n         C     R10,=F'0'\n         BE    NOPARM\n         L     R9,0(R10)\n         C     R9,=F'0'\n         BE    NOPARM\n         MVC   PARMAREA,0(R9)\n         B     MAINLINE\nNOPARM   MVC   PARMLEN,=XL2'0000'\n         B     MAINLINE\n         EJECT\n******************************************\n*                                        *\n*      M A I N   L I N E   L O G I C     *\n*                                        *\n******************************************\n*\nMAINLINE MVC   RETRNCD,=F'8'\n*\n         OPEN  (DIRDCB,(INPUT))\n         OPEN  (OUTMEMS,(OUTPUT))\n         BAL   14,PROCDIR           PERFORM ROUTINE TO PROCESS THE\n*                                      DIRECTORY OUTPUTTING MEMBER\n*                                      NAMES TO THE OUTPUT FILE\n*                                      EACH AS ONE RECORD\n         B     SHUTDOWN             BRANCH TO SHUTDOWN\n         EJECT\n         SPACE 3\n*\nPROCDIR  ST    14,SAVEIT1          STORE R14 CONTENTS IN SAVEIT1\nREADBLK  READ  DIRECB,SF,DIRDCB,DIRECTRY,'S'\n         CHECK DIRECB\n         LA    R6,DIRECTRY+10      GET ADDR OF FIRST ENTRY\nTABLLOOP BAL   14,PUTRECRD         PERFORM ROUTINE TO WRITE OUTPUT REC\n         CLC   0(8,R6),DIRECTRY    IS THIS THE LAST GUY IN THIS BLOCK?\n         BNE   CONTINUE            NO GO AHEAD WITH THIS BLOCK\n         CLC   DIRECTRY(8),FFFF    YES,IS THIS LAST DIRECTORY BLOCK?\n         BNE   READBLK             NO, GO GET ANOTHER BLOCK\n         B     EXITDIR             YES, EXIT THIS ROUTINE\nCONTINUE NI    11(R6),X'1F'        GET RID OF TOP 3 BITS OF INFO\n         XR    R2,R2               CLEAR R2\n         IC    R2,11(R6)           GET LENGTH OF VARIABLE PORTION IN\n*                                  HALF WORDS\n         SLA   R2,1                CHANGE TO NUMBER OF BYTES\n         AR    R6,R2               ADD TO BASE ADDRESS\n         LA    R6,12(R6)           ADD LENGTH OF FIXED PORTION\n         B     TABLLOOP            BRANCH TO TABLLOOP\nEXITDIR  L     14,SAVEIT1          RESTORE R14 WITH SAVEIT1 CONTENTS\n         BR    14                  RETURN\n         EJECT\n         SPACE 3\n*\nPUTRECRD ST    14,SAVEIT2          STORE R14 CONTENTS IN SAVEIT2\n         CLC   0(8,R6),FFFF\n         BE    EXITPUT\n         BAL   14,CHEK4HIT\n         CLC   HITFOUND,=CL3'YES'\n         BNE   EXITPUT\n         MVC   RECRDOUT,=CL80' '\n         MVC   RECRDOUT(8),0(R6)\n         PUT   OUTMEMS,RECRDOUT\n         MVC   RETRNCD,=F'0'\nEXITPUT  L     14,SAVEIT2          RESTORE R14 WITH SAVEIT2 CONTENTS\n         BR    14                  RETURN\n         EJECT\n*\n*************************************************************\n*                                                           *\n*        THIS ROUTINE CHECKS THE PARM TO SEE IF THE USER    *\n*        WISHES TO \"SUBSET\" HIS OUTPUT FILE.  IF THE PARM   *\n*        IS ABSENT, THEN THIS ROUTINE MOVES \"YES\" TO        *\n*        HITFOUND AND AS SUCH ALL MEMBER NAMES ARE OUTPUT.  *\n*                                                           *\n*        IF THERE IS A SIGNIFICANT PARM,  THEN IT IS        *\n*        COMPARED AGAINST THE MEMBER NAME TO SEE IF THE     *\n*        MEMBER NAME SHOULD BE OUTPUT.  IF NOT, THIS        *\n*        ROUTINE MOVES \"NO \" TO HITFOUND.                   *\n*                                                           *\n*************************************************************\n         SPACE 3\n*\nCHEK4HIT ST    14,SAVEIT3          STORE R14 CONTENTS IN SAVEIT3\n         MVC   HITFOUND,=CL3'YES'\n         CLC   PARMLEN,=H'0'       IS THE PARM ABSENT ?\n         BE    EXITCHEK            IF SO, BRANCH TO EXITCHEK\n         CLC   PARMID,=CL5'MASK='  IS PARM ID = MASK=\n         BNE   EXITCHEK            IF NOT, BRANCH TO EXITCHEK\n         LH    R9,PARMLEN\n         CH    R9,=H'13'           IS LENGTH OF PARM > 13 ?\n         BH    EXITCHEK            IF SO, BRANCH TO EXITCHEK\n         CH    R9,=H'6'            IS LENGTH OF PARM < 6 ?\n         BL    EXITCHEK            IF SO, BRANCH TO EXITCHEK\n         LA    R4,5\n         SR    R9,R4\n         STH   R9,MASKLEN          MASKLEN=SIGNIF LENGTH OF PARM MASK\n         LA    R9,7(R6)\n         LA    R4,8\nCHKLOOP1 C     R4,=F'1'\n         BL    EXITCHEK\n         CLI   0(R9),C' '\n         BNE   CHEK2\n         SH    R4,=H'1'\n         S     R9,=F'1'\n         B     CHKLOOP1\nCHEK2    STH   R4,MEMBRLEN         MEMBRLEN=SIGNIF LEN OF THE MEMBER\n         LA    R4,PARMMASK         R4==> ADDRESS OF PARM MASK\n         LR    R5,R6               R5==> ADDRESS OF THE MEMBER\n         LH    R9,MASKLEN\n         CH    R9,MEMBRLEN\n         BNH   CHEK3\n         MVC   HITFOUND,=CL3'NO '\n         B     EXITCHEK\nCHEK3    LA    R9,1\nCHEK4    CH    R9,MASKLEN\n         BH    EXITCHEK\n         CLI   0(R4),C'*'\n         BE    BUMPREGS\n         CLC   0(1,R4),0(R5)\n         BE    BUMPREGS\n         MVC   HITFOUND,=CL3'NO '\n         B     EXITCHEK\nBUMPREGS A     R4,=F'1'\n         A     R5,=F'1'\n         A     R9,=F'1'\n         B     CHEK4\nEXITCHEK L     14,SAVEIT3          RESTORE R14 WITH SAVEIT3 CONTENTS\n         BR    14                  RETURN\n         EJECT\n*\n*************************************************************\n*                                                           *\n*        E N D - O F - J O B     P R O C E S S I N G        *\n*                                                           *\n*************************************************************\n*\nSHUTDOWN CLOSE (DIRDCB)          CLOSE DIRDCB\n         CLOSE (OUTMEMS)         CLOSE OUTMEMS\n         L     15,RETRNCD\n         L     13,SAVEAREA+4\n         RETURN (14,12),RC=(15)\n         EJECT\n*\n*************************************************************\n*                                                           *\n*                       D C B ' S                           *\n*                                                           *\n*************************************************************\n*\nDIRDCB   DCB   DDNAME=INPDS,                                           X\n               BLKSIZE=256,                                            X\n               KEYLEN=8,                                               X\n               LRECL=256,                                              X\n               DSORG=PS,                                               X\n               MACRF=R,                                                X\n               RECFM=F\n*\nOUTMEMS DCB    DDNAME=OUTMEMS,                                         X\n               DEVD=DA,                                                X\n               DSORG=PS,                                               X\n               RECFM=FB,                                               X\n               LRECL=80,                                               X\n               BLKSIZE=800,                                            X\n               MACRF=(PM)\n*\nRECRDOUT DS    CL80\n*\n*\n         EJECT\n*************************************************************\n*                                                           *\n*               D A T A   A R E A S                         *\n*                                                           *\n*************************************************************\n*\nSAVEIT1  DS    F\nSAVEIT2  DS    F\nSAVEIT3  DS    F\nRETRNCD  DS    F\nPARMAREA DS    0CL15\nPARMLEN  DS    H\nPARMID   DS    CL5\nPARMMASK DS    CL8\nHITFOUND DS    CL3\nMASKLEN  DS    H\nMEMBRLEN DS    H\nFFFF     DC    8X'FF'\nDIRECTRY DS    CL264\n         END   LISTMEMS\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LOADEXTR": {"ttr": 22534, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x00\\x7f\\x00\\x88\\x00\\x7f\\x12\\x00\\x00\\xe5\\x00\\xe5\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf2\\xf7\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-01-07T00:00:00", "modifydate": "1988-01-07T12:00:00", "lines": 229, "newlines": 229, "modlines": 0, "user": "FILE270"}, "text": "000010 ID DIVISION.                                                     02/01/80\n000020 PROGRAM-ID.     LOADEXTR.                                        764LODEX\n000030 AUTHOR.         JEFF SPREHN.                                     TR LV005\n000040     EJECT\n000050 ENVIRONMENT DIVISION.\n000060 CONFIGURATION SECTION.\n000070 SOURCE-COMPUTER. IBM-370.\n000080 OBJECT-COMPUTER. IBM-370.\n000090 INPUT-OUTPUT SECTION.\n000100 FILE-CONTROL.\n000110\n000120     SELECT  INPUT-FILE          ASSIGN UT-S-INPUT.\n000130     SELECT  EXTRACT-FILE        ASSIGN UT-S-OUTPUT.\n000140     EJECT\n000150 DATA DIVISION.\n000160\n000170 FILE SECTION.\n000180\n000190 FD  INPUT-FILE\n000200     LABEL RECORDS ARE   STANDARD\n000210     RECORDING MODE IS   F\n000220     RECORD CONTAINS     121 CHARACTERS\n000230     BLOCK CONTAINS      0 RECORDS\n000240     DATA RECORDS IS     INPUT-REC.\n000250\n000260\n000270 01  INPUT-REC.\n000280     05  BYTE-1                              PIC X(01).\n000290     05  FILLER                              PIC X(01).\n000300     05  BYTES-3-19.\n000310         10  BYTES-3-10.\n000320             15  BYTES-3-5.\n000330                 20  BYTE-3                  PIC X(01).\n000340                 20  FILLER                  PIC X(02).\n000350             15  FILLER                      PIC X(05).\n000360         10  FILLER                          PIC X(09).\n000370     05  FILLER                              PIC X(13).\n000380     05  BYTES-33-80.\n000390         10  FILLER                          PIC X(05).\n000400         10  BYTE-38                         PIC X(01).\n000410         10  BYTES-39-46.\n000420             15  BYTES-39-41.\n000430                 20  BYTE-39                 PIC X(01).\n000440                 20  FILLER                  PIC X(02).\n000450             15  FILLER                      PIC X(05).\n000460         10  FILLER                          PIC X(34).\n000470     05  FILLER                              PIC X(01).\n000480     05  BYTES-82-89                         PIC X(08).\n000490     05  FILLER                              PIC X(32).\n000500     EJECT\n000510 FD  EXTRACT-FILE\n000520     LABEL RECORDS ARE   STANDARD\n000530     RECORDING MODE IS   F\n000540     RECORD CONTAINS     16 CHARACTERS\n000550     BLOCK CONTAINS      0 RECORDS\n000560     DATA RECORDS IS     EXTRACT-REC.\n000570\n000580\n000590 01  EXTRACT-REC.\n000600     05  CALLING-PROGRAM                     PIC X(8).\n000610     05  CALLED-PROGRAM                      PIC X(8).\n000620     EJECT\n000630 WORKING-STORAGE SECTION.\n000640\n000650\n000660 77  TIME-TO-STOP                            PIC X(3).\n000670 77  END-OF-RUN                VALUE 'NO '   PIC X(3).\n000680 77  SAVE-CALLING-PGM-NAME                   PIC X(8).\n000690\n000700 01  ABOUT-TO-ABORT                          PIC X.\n000710\n000720 01  ABORT-NUMBER\n000730       REDEFINES ABOUT-TO-ABORT              PIC 9.\n000740\n000750\n000760     EJECT\n000770 PROCEDURE DIVISION.\n000780\n000790 0000-OPEN.\n000800\n000810     OPEN   INPUT   INPUT-FILE\n000820           OUTPUT  EXTRACT-FILE.\n000830\n000840 1000-READ.\n000850\n000860     READ INPUT-FILE\n000870         AT END\n000880             GO TO 9999-QUIT.\n000890\n000900 1100.\n000910\n000920     IF BYTES-33-80 OF INPUT-REC\n000930        = 'ALPHABETICAL CROSS-REFERENCE LIST OF LOAD MODULE'\n000940            NEXT SENTENCE\n000950     ELSE\n000960            GO TO 1000-READ.\n000970\n000980     MOVE 'NO ' TO TIME-TO-STOP.\n000990\n001000     PERFORM 2000-MAIN-PROCESS\n001010        THRU 2999-EXIT-MAIN-PROCESS\n001020\n001030             UNTIL\n001040\n001050                    TIME-TO-STOP = 'YES'.\n001060\n001070     IF END-OF-RUN = 'YES'\n001080         GO TO 9999-QUIT\n001090     ELSE\n001100         GO TO 1100.\n001110     EJECT\n001120 2000-MAIN-PROCESS.\n001130\n001140     MOVE BYTES-82-89 OF INPUT-REC\n001150        TO SAVE-CALLING-PGM-NAME.\n001160\n001170 2100.\n001180\n001190     READ INPUT-FILE\n001200         AT END\n001210             DISPLAY '*****************'\n001220             DISPLAY '* ABORTING      *'\n001230             DISPLAY '*   PURPOSELY   *'\n001240             DISPLAY '*               *'\n001250             DISPLAY '* PROGRAM       *'\n001260             DISPLAY '*   BUG #1      *'\n001270             DISPLAY '*               *'\n001280             DISPLAY '*****************'\n001290             MOVE SPACE TO ABOUT-TO-ABORT\n001300             ADD 1 TO ABORT-NUMBER.\n001310\n001320     IF BYTES-3-19 OF INPUT-REC = ' SYMBOL   AT LMOD'\n001330        NEXT SENTENCE\n001340     ELSE\n001350        GO TO 2100.\n001360\n001370 2200.\n001380\n001390     READ INPUT-FILE\n001400         AT END\n001410             MOVE 'YES' TO TIME-TO-STOP\n001420             MOVE 'YES' TO END-OF-RUN\n001430             GO TO 2999-EXIT-MAIN-PROCESS.\n001440\n001450     IF BYTE-1 OF INPUT-REC = '1'\n001460             MOVE 'YES' TO TIME-TO-STOP\n001470             GO TO 2999-EXIT-MAIN-PROCESS.\n001480\n001490     IF BYTES-3-10 OF INPUT-REC = '*****END'\n001500             MOVE 'YES' TO TIME-TO-STOP\n001510             GO TO 2999-EXIT-MAIN-PROCESS.\n001520\n001530     PERFORM 3000-WRITE\n001540        THRU 3999-EXIT-WRITE.\n001550\n001560     GO TO 2200.\n001570\n001580 2999-EXIT-MAIN-PROCESS.\n001590     EXIT.\n001600     EJECT\n001610 3000-WRITE.\n001620\n001630     IF  (BYTE-3 OF INPUT-REC = '$')\n001640       OR\n001650         (BYTES-3-5 OF INPUT-REC = 'ILB')\n001660       OR\n001670         (BYTES-3-5 OF INPUT-REC = 'IHC')\n001680       OR\n001690         (BYTES-3-5 OF INPUT-REC = 'IHE')\n001700       OR\n001710         (BYTES-3-5 OF INPUT-REC = 'IBM')\n001720       OR\n001730         (BYTES-3-5 OF INPUT-REC = 'PLI')\n001740       OR\n001750         (BYTES-3-5 OF INPUT-REC = 'IEL')\n001760       OR\n001770         (BYTES-3-5 OF INPUT-REC = 'IKF')\n001780       OR\n001790         (BYTES-3-5 OF INPUT-REC = 'IHD')\n001800               GO TO 3500.\n001810\n001820     MOVE SAVE-CALLING-PGM-NAME\n001830       TO CALLING-PROGRAM OF EXTRACT-REC.\n001840\n001850     MOVE BYTES-3-10 OF INPUT-REC\n001860       TO CALLED-PROGRAM OF EXTRACT-REC.\n001870\n001880     WRITE EXTRACT-REC.\n001890\n001900 3500.\n001910\n001920     IF  (BYTE-38 OF INPUT-REC = '$')\n001930       OR\n001940         (BYTE-39 OF INPUT-REC = '$')\n001950       OR\n001960         (BYTES-39-41 OF INPUT-REC = 'ILB')\n001970       OR\n001980         (BYTES-39-41 OF INPUT-REC = 'IHC')\n001990       OR\n002000         (BYTES-39-41 OF INPUT-REC = 'IHE')\n002010       OR\n002020         (BYTES-39-41 OF INPUT-REC = 'IBM')\n002030       OR\n002040         (BYTES-39-41 OF INPUT-REC = 'PLI')\n002050       OR\n002060         (BYTES-39-41 OF INPUT-REC = 'IEL')\n002070       OR\n002080         (BYTES-39-41 OF INPUT-REC = 'IKF')\n002090       OR\n002100         (BYTES-39-41 OF INPUT-REC = 'IHD')\n002110               GO TO 3999-EXIT-WRITE.\n002120\n002130     MOVE SAVE-CALLING-PGM-NAME\n002140       TO CALLING-PROGRAM OF EXTRACT-REC.\n002150\n002160     MOVE BYTES-39-46 OF INPUT-REC\n002170       TO CALLED-PROGRAM OF EXTRACT-REC.\n002180\n002190     WRITE EXTRACT-REC.\n002200\n002210 3999-EXIT-WRITE.\n002220     EXIT.\n002230     EJECT\n002240 9999-QUIT.\n002250\n002260     CLOSE INPUT-FILE\n002270           EXTRACT-FILE.\n002280\n002290     STOP RUN.\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "LOADPRNT": {"ttr": 22539, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x00\\x7f\\x00\\x88\\x00\\x7f\\x12\\x00\\x00\\xd6\\x00\\xd6\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf2\\xf7\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-01-07T00:00:00", "modifydate": "1988-01-07T12:00:00", "lines": 214, "newlines": 214, "modlines": 0, "user": "FILE270"}, "text": "000010 ID DIVISION.                                                     01/07/80\n000020 PROGRAM-ID.     LOADPRNT.                                        764LODPR\n000030 AUTHOR.         JEFF SPREHN.                                     NT LV004\n000040     EJECT\n000050 ENVIRONMENT DIVISION.\n000060 CONFIGURATION SECTION.\n000070 SOURCE-COMPUTER. IBM-370.\n000080 OBJECT-COMPUTER. IBM-370.\n000090 SPECIAL-NAMES.\n000100     C01 IS NEW-PAGE.\n000110 INPUT-OUTPUT SECTION.\n000120 FILE-CONTROL.\n000130\n000140     SELECT  EXTRACT-FILE        ASSIGN UT-S-EXTRACT.\n000150     SELECT  REPORT-FILE         ASSIGN UT-S-REPORT.\n000160     EJECT\n000170 DATA DIVISION.\n000180\n000190 FILE SECTION.\n000200\n000210 FD  EXTRACT-FILE\n000220     LABEL RECORDS ARE   STANDARD\n000230     RECORDING MODE IS   F\n000240     RECORD CONTAINS     16 CHARACTERS\n000250     BLOCK CONTAINS      0 RECORDS\n000260     DATA RECORDS IS     EXTRACT-REC.\n000270\n000280 01  EXTRACT-REC.\n000290     05  CALLING-PROGRAM                     PIC X(8).\n000300     05  CALLED-PROGRAM                      PIC X(8).\n000310     EJECT\n000320 FD  REPORT-FILE\n000330     LABEL RECORDS ARE   STANDARD\n000340     RECORDING MODE IS   F\n000350     RECORD CONTAINS     80 CHARACTERS\n000360     BLOCK CONTAINS      0 RECORDS\n000370     DATA RECORDS IS     REPORT-REC.\n000380\n000390 01  REPORT-REC.\n000400     05  FILLER                              PIC X(01).\n000410     05  PRINT-REC                           PIC X(79).\n000420     EJECT\n000430 WORKING-STORAGE SECTION.\n000440\n000450 77  THE-LINE-COUNT      VALUE 99            PIC 99.\n000460 77  PREVIOUS-KEY                            PIC X(8).\n000470 77  THE-TITLE-LINE                          PIC X(79).\n000480 77  THE-FIRST-COL-HEAD                      PIC X(79).\n000490 77  THE-PAGE-NO         VALUE ZEROS         PIC 9(3).\n000500 77  PREVIOUS-RECORD     VALUE LOW-VALUES    PIC X(16).\n000510\n000520 01  ABOUT-TO-ABORT                          PIC X.\n000530\n000540 01  ABORT-NUMBER\n000550       REDEFINES ABOUT-TO-ABORT              PIC 9.\n000560\n000570 01  BREAKDOWN-INPUT-REC.\n000580     05  BYTES-1-8                           PIC X(8).\n000590     05  BYTES-9-16                          PIC X(8).\n000600\n000610 01  WDPSC-TITLE-LINE.\n000620     05  FILLER                              PIC X(41)  VALUE\n000630         'WASHINGTON DATA PROCESSING SERVICE CENTER'.\n000640     05  FILLER         VALUE SPACES         PIC X(30).\n000650     05  FILLER         VALUE 'PAGE '        PIC X(05).\n000660     05  PAGE-NUMBER                         PIC ZZ9.\n000670\n000680 01  TITLE-LINE-1.\n000690     05  FILLER                              PIC X(31)  VALUE\n000700         'CALLING PROGRAM CROSS REFERENCE'.\n000710     05  FILLER         VALUE SPACES         PIC X(40).\n000720     05  THE-RUN-DATE                        PIC X(08).\n000730\n000740 01  TITLE-LINE-2.\n000750     05  FILLER                              PIC X(31)  VALUE\n000760         'CALLED PROGRAM CROSS REFERENCE '.\n000770     05  FILLER         VALUE SPACES         PIC X(40).\n000780     05  THE-RUN-DATE                        PIC X(08).\n000790\n000800 01  COL-HEAD-1A.\n000810     05  FILLER                              PIC X(23)  VALUE\n000820         'CALLING          CALLED'.\n000830     05  FILLER         VALUE SPACES         PIC X(56).\n000840\n000850 01  COL-HEAD-1B.\n000860     05  FILLER                              PIC X(24)  VALUE\n000870         'CALLED           CALLING'.\n000880     05  FILLER         VALUE SPACES         PIC X(55).\n000890\n000900 01  COL-HEAD-2.\n000910     05  FILLER                              PIC X(24)  VALUE\n000920         'PROGRAM          PROGRAM'.\n000930     05  FILLER         VALUE SPACES         PIC X(55).\n000940\n000950 01  COL-HEAD-3.\n000960     05  FILLER                              PIC X(25)  VALUE\n000970         '--------         --------'.\n000980     05  FILLER         VALUE SPACES         PIC X(54).\n000990\n001000 01  DETAIL-LINE.\n001010     05  PGM-NAME-ON-LEFT                    PIC X(8).\n001020     05  FILLER      VALUE SPACES            PIC X(9).\n001030     05  PGM-NAME-ON-RIGHT                   PIC X(8).\n001040     05  FILLER      VALUE SPACES            PIC X(54).\n001050\n001060     EJECT\n001070 LINKAGE SECTION.\n001080\n001090 01  PARM-AREA.\n001100     05  PARM-CNT                            PIC S9(4) COMP.\n001110     05  PARM-VALUE                          PIC X(7).\n001120\n001130     EJECT\n001140 PROCEDURE DIVISION USING PARM-AREA.\n001150\n001160 0000-OPEN.\n001170\n001180     OPEN   INPUT  EXTRACT-FILE\n001190           OUTPUT  REPORT-FILE.\n001200\n001210     IF PARM-VALUE = 'CALLING' OR 'CALLED '\n001220          NEXT SENTENCE\n001230     ELSE\n001240          DISPLAY '*********************************'\n001250          DISPLAY '*                               *'\n001260          DISPLAY '*  PURPOSELY ABORTING           *'\n001270          DISPLAY '*                               *'\n001280          DISPLAY '*       INVALID PARM VALUE      *'\n001290          DISPLAY '*                               *'\n001300          DISPLAY '*                               *'\n001310          DISPLAY '*********************************'\n001320          MOVE SPACE TO ABOUT-TO-ABORT\n001330          ADD 1 TO ABORT-NUMBER.\n001340\n001350     MOVE CURRENT-DATE TO THE-RUN-DATE OF TITLE-LINE-1.\n001360\n001370     MOVE CURRENT-DATE TO THE-RUN-DATE OF TITLE-LINE-2.\n001380\n001390     IF PARM-VALUE = 'CALLING'\n001400         MOVE TITLE-LINE-1 TO THE-TITLE-LINE\n001410         MOVE COL-HEAD-1A TO THE-FIRST-COL-HEAD\n001420     ELSE\n001430         MOVE TITLE-LINE-2 TO THE-TITLE-LINE\n001440         MOVE COL-HEAD-1B TO THE-FIRST-COL-HEAD.\n001450\n001460 1000-READ.\n001470\n001480     READ  EXTRACT-FILE\n001490        AT END\n001500          GO TO 9999-QUIT.\n001510\n001520     IF EXTRACT-REC = PREVIOUS-RECORD\n001530           GO TO 1000-READ\n001540     ELSE\n001550           MOVE EXTRACT-REC TO PREVIOUS-RECORD.\n001560\n001570     IF PARM-VALUE = 'CALLING'\n001580           MOVE CALLING-PROGRAM OF EXTRACT-REC\n001590             TO BYTES-1-8 OF BREAKDOWN-INPUT-REC\n001600           MOVE CALLED-PROGRAM OF EXTRACT-REC\n001610             TO BYTES-9-16 OF BREAKDOWN-INPUT-REC\n001620     ELSE\n001630           MOVE CALLED-PROGRAM OF EXTRACT-REC\n001640             TO BYTES-1-8 OF BREAKDOWN-INPUT-REC\n001650           MOVE CALLING-PROGRAM OF EXTRACT-REC\n001660             TO BYTES-9-16 OF BREAKDOWN-INPUT-REC.\n001670\n001680     IF THE-LINE-COUNT IS GREATER THAN 85\n001690         ADD 1 TO THE-PAGE-NO\n001700         MOVE THE-PAGE-NO TO PAGE-NUMBER OF WDPSC-TITLE-LINE\n001710         MOVE WDPSC-TITLE-LINE TO PRINT-REC\n001720         WRITE REPORT-REC AFTER NEW-PAGE\n001730         MOVE THE-TITLE-LINE TO PRINT-REC\n001740         WRITE REPORT-REC AFTER 2\n001750         MOVE SPACES TO PRINT-REC\n001760         WRITE REPORT-REC AFTER 2\n001770         MOVE THE-FIRST-COL-HEAD TO PRINT-REC\n001780         WRITE REPORT-REC AFTER 1\n001790         MOVE COL-HEAD-2 TO PRINT-REC\n001800         WRITE REPORT-REC AFTER 1\n001810         MOVE COL-HEAD-3 TO PRINT-REC\n001820         WRITE REPORT-REC AFTER 1\n001830         MOVE SPACES TO PRINT-REC\n001840         WRITE REPORT-REC AFTER 1\n001850         MOVE LOW-VALUES TO PREVIOUS-KEY\n001860         MOVE +09 TO THE-LINE-COUNT.\n001870\n001880     IF BYTES-1-8 OF BREAKDOWN-INPUT-REC = PREVIOUS-KEY\n001890           MOVE SPACES\n001900             TO PGM-NAME-ON-LEFT OF DETAIL-LINE\n001910           MOVE BYTES-9-16 OF BREAKDOWN-INPUT-REC\n001920             TO PGM-NAME-ON-RIGHT OF DETAIL-LINE\n001930           MOVE DETAIL-LINE TO PRINT-REC\n001940           WRITE REPORT-REC AFTER 1\n001950           ADD +01 TO THE-LINE-COUNT\n001960     ELSE\n001970           MOVE BYTES-1-8 OF BREAKDOWN-INPUT-REC\n001980             TO PGM-NAME-ON-LEFT OF DETAIL-LINE\n001990           MOVE BYTES-9-16 OF BREAKDOWN-INPUT-REC\n002000             TO PGM-NAME-ON-RIGHT OF DETAIL-LINE\n002010           MOVE DETAIL-LINE TO PRINT-REC\n002020           WRITE REPORT-REC AFTER ADVANCING 2\n002030           ADD +02 TO THE-LINE-COUNT\n002040           MOVE BYTES-1-8 OF BREAKDOWN-INPUT-REC\n002050             TO PREVIOUS-KEY.\n002060\n002070     GO TO 1000-READ.\n002080     EJECT\n002090 9999-QUIT.\n002100\n002110     CLOSE  EXTRACT-FILE\n002120            REPORT-FILE.\n002130\n002140     STOP RUN.\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "LOCATE": {"ttr": 22788, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x00\\x7f\\x00\\x88\\x00\\x7f\\x12\\x00\\x02\\xc9\\x02\\xc9\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf2\\xf7\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-01-07T00:00:00", "modifydate": "1988-01-07T12:00:00", "lines": 713, "newlines": 713, "modlines": 0, "user": "FILE270"}, "text": "*\n*  MODIFIED 4/3/86 TO SUPPORT CONCATENATED STEPLIBS AND\n*              THE XA PARMLIB MEMBER LPALSTXX - KERMIT KISER\n*\n*  MODIFIED 4/22/86 TO ALSO SEARCH ISPLLIB CONCATENATION IF PRESENT- KK\n*\n*  MODIFIED 7/25/86 TO FIX THE PROBLEM OF LOCATE FINDING ONLY\n*              A PORTION  OF THE DATASETS WHEN MULTIPLE MEMBERS\n*              WERE SPECIFIED. - GORDON SCHILLINGER\n*\n         TITLE 'LOCATE - TSO COMMAND TO IDENTIFY THE LOCATION OF SPECIF*\n               IED MEMBERS IN SYSTEM LIBRARIES'\n*\n*        LOCATE WILL REPORT THE NAME OF THE DATASET IN WHICH THE\n*        SPECIFIED MEMBER(S) EXIST. SYSTEM LIBRARIES ARE SEARCHED IN\n*        A MANNER SIMILAR TO THE PROGRAM FETCH MODULE SEARCH ORDER:\n*              1) THE STEPLIB      (IF ONE EXISTS)\n*              2) SYS1.LPALIB      (SEE NOTE BELOW ABOUT FLPA, MLPA)\n*              3) SYS1.LINKLIB\n*              4) THE SYSTEM LINK LIST, ALWAYS ASSUMED TO BE LNKLST00\n*              5) SYS1.SVCLIB\n*        THESE DATASETS ARE ALLOCATED AND CONCATENATED, THEN A BLDL\n*        MACRO IS ISSUED AGAINST THE ENTIRE GROUP. THUS, ONLY THE FIRST\n*        OCCURRENCE OF A MEMBER WILL BE REPORTED ALTHOUGH IT MAY EXIST\n*        IN MORE THAN ONE LIBRARY.\n*\n*        LOCATED MEMBERS WILL BE IDENTIFIED BY ONE OF THE FOLLOWING:\n*              MEMBER-NAME IS A MEMBER IN DATASET-NAME\n*              -------------------------- STEPLIB DATASET-NAME\n*              ALIAS-NAME IS AN ALIAS OF MEMBER-NAME IN DATASET-NAME\n*              ---------------------------------------- STEPLIB DSNAME\n*\n*  NOTE ****** CONCERNING FIXED AND MODIFIED LINK PACK AREA DATASETS\n*              A LOGICAL ERROR CAN OCCUR IN THE STANDARD OPERATION OF\n*              LOCATE IF DATASETS OTHER THAN LINKLIB AND SVCLIB ARE\n*              USED FOR LPA EXTENSIONS AND ARE APPENDED TO THE LINK\n*              LIST, AS IS USUALLY THE CASE WITH SYS1.FLPALIB/MLPALIB.\n*              ALTHOUGH THE SYSTEM PROPERLY SEARCHES THE VIRTUAL\n*              STORAGE IMAGES OF THESE LIBRARIES, THE BLDL FUNCTION\n*              DOES NOT, SO A LOCATION OTHER THAN THAT OF THE MODULE\n*              ACTUALLY IN USE MAY BE REPORTED.\n*       ****** FOR THIS REASON, A 'LOCATE ALL' FEATURE IS PROVIDED\n*              WHICH WILL ISSUE A SEPARATE BLDL AGAINST EACH OF THE\n*              DATASETS LISTED ABOVE AND REPORT ALL OCCURRENCES.\n*\n*        IF ALLOCATION OF ANY LIBRARY OTHER THAN STEPLIB IS REFUSED,\n*        LOCATE WILL TERMINATE. IF STEPLIB IS A CONCATENATED GROUP IT\n*        WILL BE IGNORED TO PREVENT UNNECESSARY CONFUSION OF THE\n*        INTERNAL DATASET NAME TABLES.\n*\n*        ORIGINAL AUTHOR OF MVT VERSION UNKNOWN.\n*        THIS VERSION WRITTEN FOR MVS (OS/VS RELEASE 3) AND USES\n*        MVS-ONLY FUNCTIONS SUCH AS 'DYNALLOC' AND 'CALLTSSR'.\n*              OCTOBER, 1976       SAM LEPORE       617 890-8460 X-138\n*              GTE LABORATORIES, INC., 40 SYLVAN RD., WALTHAM, MASS.\n*\n*        ATTRIBUTES: RE-ENTRANT AND REUSABLE\n*        SYS1.AMODGEN REQUIRED TO RESOLVE CVT MACRO\n*\n         EJECT\n***********************************************************************\n*        FOLLOWING AS COMMENTS IS THE HELP ENTRY FOR    LOCATE        *\n*        TO USE THIS AS INPUT TO IEBUPDTE,                            *\n*        MERELY REMOVE THE ASTERISKS FROM COLUMN 1.                   *\n***********************************************************************\n         SPACE 2\n*./ ADD NAME=LOCATE\n*)F FUNCTION -\n*   LOCATE WILL REPORT THE NAME OF THE DATASET IN WHICH THE SPECIFIED\n*   MEMBER NAME(S) EXIST. SYSTEM LIBRARIES ARE SEARCHED IN A MANNER\n*   SIMILAR TO THE PROGRAM FETCH MODULE SEARCH ORDER. IF THE MEMBER\n*   NAME SPECIFIED IS AN ALIAS, AND IF THE MODULE WHICH IT NAMES\n*   IS REENTERABLE OR REUSABLE, LOCATE WILL ALSO IDENTIFY THE\n*   REAL MEMBER NAME.\n*)X SYNTAX -\n*   LOCATE (MEMBER-NAMES) ALL\n*\n*REQUIRED - AT LEAST ONE MEMBER-NAME\n*DEFAULTS - NONE\n*OPTIONAL - ALL\n*)O OPERANDS -\n*))MEMBER-NAMES - ONE OR MORE MEMBER OR ALIAS NAMES TO BE SEARCHED FOR\n*               IN THE SYSTEM LIBRARIES.\n*))ALL - REQUEST TO LOOK FOR MEMBER-NAME IN EACH OF THE SYSTEM\n*   LIBRARIES. IF ALL IS NOT SPECIFIED, ONLY THE FIRST OCCURRENCE\n*   OF EACH MEMBER-NAME WILL BE REPORTED, JUST AS PROGRAM FETCH\n*   STOPS AT THE FIRST PROGRAM COPY IT FINDS.\n*   LIBRARY SEARCH ORDER IS THE SAME WHETHER ALL IS SPECIFIED OR NOT.\n*     1) THE STEP LIBRARY, IF ONE EXISTS\n*     2) SYS1.LPALIB\n*     3) SYS1.LINKLIB\n*     4) THE SYSTEM LINKLIST, AS DEFINED BY LNKLST00\n*     5) SYS1.SVCLIB\n*./ ENDUP\n         EJECT\nLOCATE   CSECT\n         SAVE  (14,12),,*\n         LR    R12,R15             REG 12 IS BASE AT DISPLACEMENT +0\n         USING LOCATE,R12\n         LR    R11,R1              SAVE CPPL ADDRESS\n         USING CPPL,R11\n         GETMAIN R,LV=CORENEED\n         ST    R1,8(,R13)          FORWARD CHAIN\n         ST    R13,4(,R1)          BACKWARD CHAIN\n         LR    R13,R1              SAVEAREA/WORKAREA ADDRESSABILITY\n         USING WORKAREA,R13\n*\n***********************************************************************\n*        PARSE THE COMMAND OPERANDS                                   *\n***********************************************************************\n*\n         LA    R10,PPLAREA         ADDRESS THE PARSE PARAMETER LIST\n         USING PPL,R10\n         MVC   PPLUPT,CPPLUPT      INITIALIZE\n         MVC   PPLECT,CPPLECT        PARSE\n         LA    R1,ECB                  PARAMETER\n         ST    R1,PPLECB                 LIST\n         MVC   PPLPCL,=A(PARSEPCL)         CONTROL\n         LA    R1,PPLANSWR                   FIELDS\n         ST    R1,PPLANS\n         MVC   PPLCBUF,CPPLCBUF\n         SR    R1,R1\n         ST    R1,PPLUWA\n         ST    R1,ECB\n         CALLTSSR EP=IKJPARS,MF=(E,PPL)\n         CH    R15,=H'4'           SUCCESSFUL ?\n         BE    RETURN12            NO- MSG WAS ISSUED, RETURN TO TMP\n         BH    PARSFAIL            NO- ISSUE MSG VIA GNRLFAIL ROUTINE\n         L     R10,PPLANSWR        YES- ADDRESS PARSE DESCRIPTOR DSECT\n         USING IKJPARMD,R10\n*\n***********************************************************************\n*        INITIALIZE TSO MESSAGE ISSUER (IKJEFF02) PARAMETER LIST      *\n***********************************************************************\n*\n         LA    R9,MTPARMS          ADDRESS MESSAGE ISSUER WORKAREA\n         USING MTDSECTD,R9\n         XC    MTPARMS(MTLENMT),MTPARMS CLEAR THE PARM LIST\n         LA    R1,MTCSECTP\n         ST    R1,MTPLPTR          POINT TO PARMS\n         ST    R11,MTCPPLP         POINT TO CPPL\n         LA    R1,ECB\n         ST    R1,MTECBP           POINT TO PUTLINE COMMUNICATIONS ECB\n         MVI   MTRESV1,X'80'       INDICATE END OF LINKAGE LIST\n         MVC   MTCSECTP,=A(MESSAGES) ADDRESS OF MESSAGE TEXT CSECT\n         OI    MTSW1,MTNOIDSW+MTPUTLSW ALL MSGS ARE 'PUTLINE INFO'\n*\n***********************************************************************\n*        MOVE THE MEMBER NAMES TO THE WORKAREA                        *\n***********************************************************************\n*\n         LA    R8,BLDAREA          ADDRESS BLDL LIST WORKAREA\n         USING PDSBLDL,R8\n         LA    R3,1                INITIALIZE BXLE LOOP - TOTAL\n         LR    R4,R3                                    - INCREMENT\n         LA    R5,MAXMEMS                               - LIMIT\n         LA    R6,MEMNAME          ADDRESS FIRST SPECIFIED NAME PDE\nMOVELOOP L     R2,0(,R6)           ADDRESS NAME CHARACTER STRING\n         LH    R1,4(,R6)           LENGTH OF STRING\n         BCTR  R1,0\n         MVC   BLDMEM(8),=CL8' '   BLANK-FILL THE FIELD\n         EX    R1,MOVEMEM          MOVE MEMBER NAME TO BLDL LIST\n         L     R6,8(,R6)           FOLLOW CHAIN OF NAMES\n         C     R6,ENDCHAIN         END OF CHAIN ?\n         BE    ENDLOOP\n         LA    R8,ENTRYLEN(,R8)    POINT TO NEXT ENTRY IN BLDAREA\n         BXLE  R3,R4,MOVELOOP      LOOP UNTIL BLDAREA IS FULL\n         MVC   MTMSGID(4),=C'OVFL' TABLE OVERFLOW IMMINENT, ISSUE MSG\n         CALLTSSR EP=IKJEFF02,MF=(E,MTPARMS)\n         LTR   R15,R15\n         BNZ   RETURN12\n         LR    R3,R5               RESET TOTAL TO MAXMEMS\nENDLOOP  STH   R3,BLDLIST          SET NUMBER OF ENTRIES FOR BLDL\n         LA    R1,ENTRYLEN\n         STH   R1,BLDELEN          SET LENGTH OF EACH ENTRY\n         CR    R3,R4               ONLY ONE ENTRY ?\n         BE    STEPLIB             YES- SKIP THE SORT\n***********************************************************************\n*        SORT THE MEMBERS INTO ASCENDING SEQUENCE                     *\n***********************************************************************\n         SR    R3,R4               SET OUTER LOOP TO TOTAL MINUS 1\n         LA    R8,BLDAREA          ADDRESS FIRST MEMBER NAME\nNEWLOW   LA    R1,ENTRYLEN(,R8)    ADDRESS NEXT ENTRY FOR INNER LOOP\n         LR    R2,R3               SET INNER LOOP TO MAX OF OUTER VALUE\nWHICHLOW CLC   0(8,R8),0(R1)       COMPARE CURRENT 'LOW' TO NEXT ENTRY\n         BNH   OLDLOW              NOT HIGH- KEEP 'LOW', NEW 'NEXT'\n         MVC   DBLWORD(8),0(R8)    HIGH- SWITCH ENTRIES, SAVE OLD\n         MVC   0(8,R8),0(R1)            'NEXT' BECOMES 'LOW'\n         MVC   0(8,R1),DBLWORD\nOLDLOW   LA    R1,ENTRYLEN(,R1)    INCREMENT NEXT\n         BCT   R2,WHICHLOW         COMPLETE INNER LOOP\n         LA    R8,ENTRYLEN(,R8)    INCREMENT TO NEXT 'LOW'\n         BCT   R3,NEWLOW           COMPLETE OUTER LOOP\n*\n***********************************************************************\n*        BUILD THE LIBRARY SEARCH TABLE OF DATASET NAMES AND ALLOCATE *\n*        EACH LIBRARY. BUILD A CORRESPONDING TABLE OF DDNAMES RETURNED*\n*        BY DYNALLOC TO BE USED TO CONCATENATE OR OPEN EACH LIBRARY.  *\n***********************************************************************\nSTEPLIB  LA    R8,S99PARMS         ADDRESS S99 REQUEST BLOCK\n         USING S99RB,R8\n         XC    S99PARMS(S99RBLEN),S99PARMS CLEAR THE BLOCK\n         MVI   S99RBLN,S99RBLEN    SET LENGTH\n         LA    R1,S99TEXTP\n         ST    R1,S99TXTPP\n***********************************************************************\n*        FIRST SEE IF THERE IS AN ISPLLIB                             *\n***********************************************************************\n         CALL  DSNTAB,(=CL8'ISPLLIB',DSNTABLE,=H'1000',DSNCNT),VL,    XX\n               MF=(E,PLIST)\n         LTR   R15,R15                                           WDPSC\n         BZ    GOTSUM                                           WDPSC\n         CH    R15,=H'4'  OK?\n         BNE   RETURN12   OOPS!\n         LA    R3,DSNTABLE\n         B     CHKSTEP\nGOTSUM   LH    R1,DSNCNT                                         WDPSC\n         MH    R1,=H'50'                                         WDPSC\n         LA    R3,DSNTABLE(R1)                                   WDPSC\n***********************************************************************\n* CHECK STEPLIB AFTER ISPLLIB\n***********************************************************************\nCHKSTEP  CALL  DSNTAB,(=CL8'STEPLIB',0(R3),=H'1000',DSNCNT),VL,       XX\n               MF=(E,PLIST)\n         LTR   R15,R15                                           WDPSC\n         BZ    GOTMORE                                          WDPSC\n         CH    R15,=H'4'  OK?\n         BNE   RETURN12   OOPS!\n         B     LPALIB\nGOTMORE  LH    R1,DSNCNT                                         WDPSC\n         MH    R1,=H'50'                                         WDPSC\n         LA    R3,0(R1,R3)                                   WDPSC\n***********************************************************************\n*        THEN THROW IN LPALIB AND LINKLIB                             *\n***********************************************************************\nLPALIB   L     R1,16              R1->CVT\n         TM    116(R1),X'80'      XA?\n         BNO   SKPLPAX            NOPE\n         MVC   PARMNAME,LPALST00\n         BAL   R14,READPARM                                      WDPSC\nSKPLPAX  MVC   0(17,R3),SYS1LPA                                  WDPSC\n         LA    R3,50(R3)                                         WDPSC\n         MVC   0(18,R3),SYS1LINK                                 WDPSC\n         LA    R3,50(R3)                                         WDPSC\n         MVC   PARMNAME,LNKLST00\n         BAL   R14,READPARM                                      WDPSC\n         B     FINISHIT WITH SVCLIB                              WDPSC\n***********************************************************************\n*                FILL    TABLE WITH CONTENTS OF SYS1.PARMLIB(LNKLST00)*\n***********************************************************************\nREADPARM ST    R14,L1LS                                          WDPSC\n         MVI   S99VERB,S99VRBAL    SET DYNALLOC FUNTION TO ALLOCATE\n         LA    R1,S99TEXT\n         ST    R1,S99TEXTP         FIRST TEXT UNIT POINTER\n         MVC   S99TEXT(18),SYS1PARM DSNAME SYS1.PARMLIB\n         LA    R1,S99TEXT+18\n         ST    R1,S99TEXTP+4       SECOND TEXT UNIT POINTER\n         MVC   S99TEXT+18(14),PARMNAME MEMBER NAME LNKLST00\n         LA    R1,S99TEXT+32\n         ST    R1,S99TEXTP+8       THIRD TEXT UNIT POINTER\n         MVC   S99TEXT+32(7),STATSHR STATUS SHARE\n         LA    R1,S99TEXT+39\n         ST    R1,S99TEXTP+12      FOURTH TEXT UNIT POINTER\n         MVC   S99TEXT+39(4),FREECLOS AUTOMATICALLY FREE AT CLOSE\n         LA    R1,S99TEXT+43\n         ST    R1,S99TEXTP+16      FIFTH TEXT UNIT POINTER\n         MVC   S99TEXT+43(14),RTDDN RETURN ALLOCATED DDNAME\n         MVI   S99TEXTP+16,S99TUPLN INDICATE END OF POINTER LIST\n         ST    R8,DBLWORD          POINT TO REQUEST BLOCK\n         MVI   DBLWORD,S99RBPND\n         LA    R1,DBLWORD          ADDRESS THE POINTER\n         DYNALLOC\n         LTR   R15,R15             SUCCESSFUL ?\n         BNZ   S99FAIL\n         MVC   DCB(96),DCBPARML    INITIALIZE DCB FOR READ PARMLIB\n         MVC   DCB+40(8),S99TEXT+49 MOVE IN ALLOCATED DDNAME\n         MVI   DBLWORD,X'80'       SET OPEN OPTION INPUT,END OF LIST\n         OPEN  (DCB),MF=(E,DBLWORD)\n         TM    DCB+48,X'10'        OPEN SUCCESSFUL ?\n         BO    GETREC              YES- READ THE CONTROL CARDS\n         MVC   MTMSGID(4),=C'NOPN' NO- TELL USER CANNOT OPEN\n         LA    R1,ERRPARML\n         ST    R1,MTINSRT          POINT TO MESSAGE INSERT\n         MVI   MTLEN,L'ERRPARML    LENGTH OF INSERT\n         CALLTSSR EP=IKJEFF02,MF=(E,MTPARMS)\n         B     RETURN12\nGETREC   GET   DCB\n         MVI   71(R1),C'*'         FORCE END OF SCAN AT COLUMN 72\nFINDNONB CLI   0(R1),C' '          LOOK FOR FIRST NON-BLANK\n         BNE   FOUNDNB\n         LA    R1,1(,R1)           INCREMENT\n         B     FINDNONB\nFOUNDNB  CLC   0(12,R1),SYS1LINK+6 SYS1.LINKLIB DSNAME SPECIFIED ?\n         BNE   CKLPA               NO- PUT NAME INTO DSNTABLE\n         CLI   12(R1),C','         YES- MAKE SURE\n         BE    SKIPLINK\n         CLI   12(R1),C' '\n         BNE   USENAME\nSKIPLINK LA    R1,12(,R1)          INCREMENT PAST LINKLIB\n         B     CHECKEND            SEE IF END OF CARD\nCKLPA    CLC   0(11,R1),SYS1LPA+6  SYS1.LPALIB DSNAME SPECIFIED ?\n         BNE   USENAME             NO- PUT NAME INTO DSNTABLE\n         CLI   11(R1),C','         YES- MAKE SURE\n         BE    SKIPLPA\n         CLI   11(R1),C' '\n         BNE   USENAME\nSKIPLPA  LA    R1,11(,R1)          INCREMENT PAST LINKLIB\n         B     CHECKEND            SEE IF END OF CARD\nUSENAME  LR    R2,R1\nFINDEND  LA    R2,1(,R2)           FIND END OF CURRENT NAME\n         CLI   0(R2),C','          COMMA\n         BE    FOUNDEND\n         CLI   0(R2),C' '          OR BLANK\n         BNE   FINDEND\nFOUNDEND MVC   0(6,R3),SYS1LINK    MOVE IN S99TEXT KEY HEADER\n         SR    R2,R1               LENGTH OF DSNAME\n         STC   R2,5(,R3)           PUT INTO S99TEXT\n         BCTR  R2,0                DECREMENT FOR EXECUTE\n         EX    R2,MOVEDSN          MOVE DSNAME INTO DSNTABLE SLOT\n         LA    R3,50(,R3)          INCREMENT TO NEXT AVAILABLE SLOT\n         LA    R1,1(R2,R1)         POINT TO SEPARATOR CHARACTER\nCHECKEND CLI   0(R1),C' '          END OF LINKLIST ?\n         BE    DONEPARM            YES- FINISH DSNTABLE\n         CLI   1(R1),C' '          NO, NEXT COL BLANK ? (THIS IS COMMA)\n         BE    GETREC              YES- LINKLIST CONTINUES\n         LA    R1,1(,R1)           POINT TO ASSUMED NEXT DSN ON RECORD\n         CLI   0(R1),C'*'          COLUMN 72 ? (FORCED AT 'GETREC')\n         BNE   USENAME             NO- PROCESS NEXT DSNAME\n         B     GETREC              YES- COMMA IS IN 71, LIST CONTINUES\nDONEPARM MVI   DBLWORD,X'80'       SET CLOSE OPTION - END OF LIST\n         CLOSE (DCB),MF=(E,DBLWORD)\n         L     R14,L1LS                                          WDPSC\n         BR    R14                                               WDPSC\n***********************************************************************\n*        FINISH THE DSNTABLE WITH SVCLIB, THEN ALLOCATE ALL DATASETS  *\n***********************************************************************\nFINISHIT MVC   0(17,R3),SYS1SVC\n*\n         SR    R6,R6               ZERO COUNTER\n         LR    R5,R3               ADDRESS OF LAST DSN SLOT USED (SVC)\n         LA    R4,50               INCREMENTAL VALUE FOR BXLE\n         LA    R3,DSNTABLE         ADDRESS FIRST (STEPLIB) DSN TEXT KEY\n         LA    R2,DDNTABLE+4       ADDRESS TABLE OF RETURNED DDNAMES\n         CLI   1(R3),0             ANY STEPLIB ?\n         BNE   SETALLOC            YES- ALLOCATE IT\n         AR    R3,R4               NO- SKIP TO NEXT DSNTABLE SLOT\nSETALLOC MVI   S99VERB,S99VRBAL\n         LA    R1,S99TEXT\n         ST    R1,S99TEXTP\n         MVC   S99TEXT(7),STATSHR  STATUS SHARE\n         LA    R1,S99TEXT+7\n         ST    R1,S99TEXTP+4\n         MVC   S99TEXT+7(4),FREECLOS AUTOMATIC FREE AT CLOSE\n         LA    R1,S99TEXT+11\n         ST    R1,S99TEXTP+8\nALLOCATE MVC   S99TEXT+11(14),RTDDN RETURN ALLOCATED DDNAME\n         ST    R3,S99TEXTP+12      POINT TO NAME IN DSNTABLE\n         MVI   S99TEXTP+12,S99TUPLN END OF POINTERS\n         ST    R8,DBLWORD          POINT TO REQUEST BLOCK\n         MVI   DBLWORD,S99RBPND\n         LA    R1,DBLWORD          ADDRESS THE POINTER\n         DYNALLOC\n         LTR   R15,R15             SUCCESSFUL ?\n         BNZ   S99FAIL\n         MVC   0(10,R2),S99TEXT+15 MOVE LENGTH & DDNAME TO DDNTABLE\n         MVI   1(R2),8             FORCE LENGTH TO 8\n         LA    R2,10(,R2)          INCREMENT TO NEXT DDNTABLE SLOT\n         LA    R6,1(,R6)           KEEP COUNT OF DDNAMES ALLOCATED\n         BXLE  R3,R4,ALLOCATE\n*\n***********************************************************************\n*        OPEN THE LIBRARIES, BLDL, AND REPORT ON EACH MEMBER. IF 'ALL'*\n*        WAS SPECIFIED, LOOP FOR EACH LIBRARY. IF 'ALL' NOT SPECIFIED,*\n*        CONCATENATE THE LIBRARIES BEFORE OPEN AND LOOP ONLY ONCE.    *\n***********************************************************************\n*\n         LA    R2,DSNTABLE+50      DSNAMES TO BE USED AS MESSAGE INSERT\n         LA    R3,DDNTABLE+4       ADDRESS DDNAMES LENGTH-TEXT UNITS\n         CLI   DSNTABLE+1,0        ASSUME STEPLIB (FIRST ENTRY) ABSENT\n         BE    CHECKALL            YES- SEE IF 'ALL' SPECIFIED\n         LA    R2,DSNTABLE         NO- RESET DSNAME POINTER TO STEPLIB\n         CLI   5(R2),36            ROOM TO INCLUDE STEPLIB ID WITH DSN?\n         B     ONLYID              GOTTA SKIP THIS CUZA ISPLLIB--KK\n         BH    ONLYID              NO- JUST SAY 'STEPLIB', FORGET NAME\n         MVC   S99TEXT(36),6(R2)   YES- TEMPORARILY SAVE THE DSN\n         MVC   6(8,R2),=C'STEPLIB ' ADD IDENTITY\n         MVC   14(36,R2),S99TEXT   RESTORE THE NAME\n         LH    R1,4(,R2)           PICK UP DSN LENGTH\n         LA    R1,8(,R1)           ADD ID LENGTH\n         STH   R1,4(,R2)           RESET\n         B     CHECKALL\nONLYID   EQU   *                   I DONT LIKE THIS PART - KERMIT\n*        MVC   6(17,R2),=C'YOUR STEP LIBRARY' OVERLAY STEPLIB DSN\n*        MVI   5(R2),17            SET LENGTH\nCHECKALL CLI   ALL+1,1             'ALL' SPECIFIED ? (TO SEARCH EACH)\n         B     BLDLLOOP    BE      YES- SKIP CONCATENATION     5-15-78\n         MVI   S99VERB,S99VRBCC    SET CONCATENATION FUNCTION\n         LA    R1,DDNTABLE\n         ST    R1,S99TEXTP         POINT TO CONCATENATION TEXT UNIT\n         ST    R6,DDNTABLE         SET COUNT OF DDNAMES\n         MVI   DDNTABLE+1,1        SET TEXT UNIT KEY ID\n         MVI   S99TEXTP,S99TUPLN   END OF POINTERS\n         ST    R8,DBLWORD          POINT TO REQUEST BLOCK\n         MVI   DBLWORD,S99RBPND\n         LA    R1,DBLWORD          ADDRESS THE POINTER\n         DYNALLOC\n         LTR   R15,R15             SUCCESSFUL ?\n         BNZ   S99FAIL\n         LA    R4,ERRSYSL+1        ADDRESS INSERT FOR 'NOT FOUND' MSG\n         ICM   R4,B'1000',ERRSYSL  LENGTH OF INSERT\n         LA    R6,1                FORCE ONLY ONE PASS THRU BLDLLOOP\n         B     BLDLOPEN\nBLDLLOOP LA    R4,6(,R2)           ADDRESS INSERT FOR 'NOT FOUND' MSG\n         ICM   R4,B'1000',5(R2)    LENGTH OF INSERT\n***********************************************************************\n*        OPEN THE DATASET(S) VIA RETURNED DDNAME                      *\n***********************************************************************\nBLDLOPEN MVC   DCB(96),DCBSYSL     INITIALIZE DCB FOR OPEN FOR BLDL\n         MVC   DCB+40(8),2(R3)     MOVE IN ALLOCATED DDNAME\n         MVI   DBLWORD,X'80'       SET OPEN OPTION INPUT, END OF LIST\n         OPEN  (DCB),MF=(E,DBLWORD)\n         TM    DCB+48,X'10'        OPEN SUCCESSFUL ?\n         BO    BLDL                YES- ISSUE BLDL\n         MVC   MTMSGID(4),=C'NOPN' NO- TELL USER CANNOT OPEN\n         ST    R4,MTINSRT          USE INSERT AS IN 'NOT FOUND' MSG\n         CALLTSSR EP=IKJEFF02,MF=(E,MTPARMS)\n         B     RETURN12\n***********************************************************************\n*        AT LAST, ISSUE THE BLDL                                      *\n***********************************************************************\nBLDL     BLDL  DCB,BLDLIST\n         CH    R15,=H'4'           SUCCESSFUL ? (AT LEAST SOME FOUND)\n         BNH   REPORT              YES- REPORT ON MEMBERS\n         MVC   MTMSGID(4),=C'BLDL' NO- TELL USER BLDL FAILED\n         ST    R4,MTINSRT          POINT TO INSERT\n         STH   R15,DBLWORD         SAVE THE RETURN CODE, USE AS INSERT\n         LA    R1,DBLWORD\n         ST    R1,MTINSRT+4        POINT TO RETURN CODE INSERT\n         MVI   MTINSRT+4,X'02'+X'80' SET LENGTH & 'PRINT AS DEC CHAR'\n         CALLTSSR EP=IKJEFF02,MF=(E,MTPARMS)\n         B     BLDLCLOS\n***********************************************************************\n*        REPORT ON EACH MEMBER AS FOUND OR NOT FOUND BY BLDL          *\n***********************************************************************\nREPORT   LA    R8,BLDAREA          ADDRESS THE FILLED IN MEMBER ENTRIES\n         USING PDSBLDL,R8\n         LH    R7,BLDLIST          NUMBER OF MEMBER ENTRIES\nMEMLOOP  ST    R8,MTINSRT          POINT TO MEMBER NAME INSERT\n         MVI   MTINSRT,8           LENGTH\n         CLI   BLDR,0              MEMBER FOUND BY BLDL ?\n         BNE   OFFSETK             YES- OFFSET TO PROPER DSN INSERT\n         B     NXTMEMBR            NO, GET NEXT MEMBER ENTRY\nOFFSETK  SR    R1,R1\n         IC    R1,BLDK             GET RELATIVE CONCATENATION NUMBER\n         MH    R1,=H'50'           TIMES DSNTABLE ENTRY LENGTH\n         AR    R1,R2               ADDRESS RELATIVE DSNTABLE ENTRY\n         LA    R5,6(,R1)           ADDRESS DSN FOR MSG INSERT\n         ICM   R5,B'1000',5(R1)    LENGTH OF INSERT\n         TM    BLDTYPE,BLDALIAS    IS BLDMEM ACTUALLY AN ALIAS NAME ?\n         BO    ALIAS               YES- PREPARE ALIAS MESSAGE\n         MVC   MTMSGID(4),=C'MEMB' USE MEMBER MESSAGE\n         ST    R5,MTINSRT+4        POINT TO DSN INSERT\n         B     ISSUEMSG\nALIAS    MVC   MTMSGID(4),=C'ALIA' USE ALIAS MESSAGE\n         ST    R5,MTINSRT+8        DSN IS THIRD INSERT IN ALIAS MSG\n         MVI   MTINSRT+4,0         ASSUME NO SECOND INSERT\n         TM    BLDATTR1,BLDRENT+BLDREUS REENTRANT OR REUSABLE MEMBER ?\n         BZ    ISSUEMSG            NEITHER- MESSAGE COMPLETE AS IS\n         MVC   BLDMEMA-3(3),=C'OF ' PREFIX REAL MEMBER NAME FOR INSERT\n         LA    R1,BLDMEMA-3\n         ST    R1,MTINSRT+4        POINT TO SECOND INSERT (REAL MEMBER)\n         MVI   MTINSRT+4,11        LENGTH OF INSERT\nISSUEMSG EQU *\n         CALLTSSR EP=IKJEFF02,MF=(E,MTPARMS)\nNXTMEMBR LA    R8,ENTRYLEN(,R8)    INCREMENT TO NEXT MEMBER ENTRY\n         BCT   R7,MEMLOOP          LOOP FOR SPECIFIED MEMBERS\n***********************************************************************\n*        CLOSE THE DATASET(S) AND LOOP IF 'ALL' REQUESTED             *\n***********************************************************************\nBLDLCLOS MVI   DBLWORD,X'80'       SET CLOSE OPTION - END OF LIST\n         CLOSE (DCB),MF=(E,DBLWORD)\n         LA    R2,50(,R2)          INCREMENT TO NEXT DSNAME\n         LA    R3,10(,R3)          INCREMENT TO NEXT DDNAME\n         BCT   R6,BLDLLOOP         LOOP FOR EACH DD (IF 'ALL' SPECIF)\n*\n***********************************************************************\n*        DONE - FREE WORKAREAS (INCLUDING PARSE PDE'S)                *\n***********************************************************************\n*\n         IKJRLSA (10)              RELEASE PARSE STORAGE\n         LR    R1,R13              ADDRESS THE SAVEAREA/WORKAREA\n         L     R13,4(,R13)\n         FREEMAIN R,LV=CORENEED,A=(1)\n         RETURN (14,12),RC=0\n         EJECT\n*\n***********************************************************************\n*        FAILURE MESSAGE ROUTINES FOR PARSE, AND DYNALLOC             *\n***********************************************************************\n*\nPARSFAIL LA    R1,GFPARAM          ADDRESS GNRLFAIL WORKAREA\n         USING GFDSECTD,R1\n         XC    GFPARAM(GFLENGF),GFPARAM CLEAR THE PARM LIST\n         MVI   GFCALLID,GFPARSE    INDICATE PARSE ERROR\n         ST    R15,GFRCODE         ERROR RETURN CODE\n         ST    R11,GFCPPLP         POINTER TO CPPL\n         LA    R2,ECB\n         ST    R2,GFECBP           POINTER TO PUTLINE ECB\n         SR    R2,R2\n         ST    R2,ECB              CLEAR THE ECB\n         ST    R1,DBLWORD          POINT TO THE PARAMETER LIST\n         DROP  R1\n         LA    R1,DBLWORD          ADDRESS THE POINTER\n         LINK  EP=IKJEFF19\n         B     RETURN12\n*\nS99FAIL  LA    R1,DFPARAM          ADDRESS DAIRFAIL WORKAREA\n         USING DFDSECTD,R1\n         XC    DFPARAM(DFLEN),DFPARAM CLEAR THE PARMLIST\n         ST    R8,DFS99RBP         POINT TO REQUEST BLOCK\n         ST    R15,DBLWORD         SAVE THE RETURN CODE\n         LA    R2,DBLWORD\n         ST    R2,DFRCP            POINT TO RETURN CODE\n         LA    R2,=F'0'\n         ST    R2,DFJEFF02         SHOW IKJEFF02 IS NOT LOADED\n         LA    R2,DFSVC99\n         STH   R2,DBLWORD+4        SET CALLER ID TO INDICATE SVC99\n         LA    R2,DBLWORD+4\n         ST    R2,DFIDP            POINT TO CALLER ID\n         ST    R11,DFCPPLP         POINTER TO CPPL\n         DROP  R1\n         LINK  EP=IKJEFF18\n*\n*        SET 'NOT IN USE' ATTRIBUTE FOR ALL RESOURCES, THEN FLUSH STACK\n*\nRETURN12 LA    R8,S99PARMS         ADDRESS S99 REQUEST BLOCK\n         USING S99RB,R8\n         XC    S99PARMS(S99RBLEN),S99PARMS CLEAR THE BLOCK\n         MVI   S99RBLN,S99RBLEN    SET LENGTH\n         MVI   S99VERB,S99VRBRI    SET FUNCTION TO 'REMOVE IN USE'\n         LA    R1,S99TEXTP\n         ST    R1,S99TXTPP         POINT TO TEXT POINTERS\n         LA    R1,S99TEXT\n         ST    R1,S99TEXTP         POINT TO TEXT\n         MVC   S99TEXT(6),TCBAD    TEXT UNIT TO ADDRESS THIS TCB\n         MVC   S99TEXT+6(4),PSATOLD SUPPLY CURRENT TCB ADDRESS FROM PSA\n         MVI   S99TEXTP,S99TUPLN   INDICATE END OF TEXT UNIT POINTERS\n         ST    R8,DBLWORD          POINT TO REQUEST BLOCK\n         MVI   DBLWORD,S99RBPND    (HIGH BIT MUST BE ON)\n         LA    R1,DBLWORD          ADDRESS THE POINTER\n         DYNALLOC\n         IKJRLSA PPLANSWR          RELEASE ANY STORAGE FOR PARSE\n         L     R2,CPPLUPT          ADDRESS THE USER PROFILE TABLE\n         L     R3,CPPLECT          ADDRESS  ENVIRONMENT CONTROL TABLE\n         STACK DELETE=ALL,PARM=DBLWORD,UPT=(2),ECT=(3),ECB=ECB,        *\n               MF=(E,S99TEXT)      (USE S99TEXT AS WORKAREA FOR IOPL)\n         LR    R1,R13\n         L     R13,4(,R13)\n         FREEMAIN R,LV=CORENEED,A=(1)\n         RETURN (14,12),RC=12\n         EJECT\n***********************************************************************\n*                                  REGISTER USAGES                    *\n***********************************************************************\nR0       EQU   0\nR1       EQU   1                   WORK\nR2       EQU   2                   WORK\nR3       EQU   3                   WORK\nR4       EQU   4                   WORK\nR5       EQU   5                   WORK\nR6       EQU   6                   WORK\nR7       EQU   7                   WORK\nR8       EQU   8    *DUAL USE*     BLDL ARRAY BASE * S99 FUNCTIONS BASE\nR9       EQU   9                   TSO MESSAGE ISSUER PARAMETER BASE\nR10      EQU   10                  PARSE PPL AND PDL ADDRESSABILITY\nR11      EQU   11                  CPPL ADDRESSABILITY\nR12      EQU   12                  PROGRAM BASE\nR13      EQU   13                  *\nR14      EQU   14                  ** STANDARD LINKAGES\nR15      EQU   15                  *\n         SPACE 2\n***********************************************************************\n*                                  EQUATES                            *\n***********************************************************************\nMAXMEMS  EQU   16\nENTRYLEN EQU   46\nMAXDSNS  EQU   40\nPSATOLD  EQU   540                 ADDRESS OF CURRENT TCB, HEX LOC 21C\n         SPACE 2\n***********************************************************************\n*        EXECUTED INSTRUCTIONS                                        *\n***********************************************************************\nMOVEMEM  MVC   BLDMEM-PDSBLDL(0,R8),0(R2) MOVE MEMBER NAME TO BLDL AREA\nMOVEDSN  MVC   6(0,R3),0(R1)       MOVE DSNAME TO DSNTABLE SLOT\n         SPACE 2\n***********************************************************************\n*        DYNAMIC ALLOCATION TEXT UNITS INITIAL VALUES                 *\n***********************************************************************\nDDSTEPL  DC    X'0001',X'0001',X'0008',CL8'STEPLIB'    DINDDNAM\nRTDSN    DC    X'0005',X'0001',X'002C' PLUS CL44       DINRTDSN\nRTATT    DC    X'000C',X'0001',X'0001' PLUS X          DINRTATT\nSYS1LPA  DC    X'0002',X'0001',X'000B',C'SYS1.LPALIB'  DALDSNAM\nSYS1LINK DC    X'0002',X'0001',X'000C',C'SYS1.LINKLIB'\nSYS1SVC  DC    X'0002',X'0001',X'000B',C'SYS1.SVCLIB'\nSYS1PARM DC    X'0002',X'0001',X'000C',C'SYS1.PARMLIB'\nLNKLST00 DC    X'0003',X'0001',X'0008',C'LNKLST00'     DALMEMBR\nLPALST00 DC    X'0003',X'0001',X'0008',C'LPALST00'     DALMEMBR\nSTATSHR  DC    X'0004',X'0001',X'0001',X'08'           DALSTATS\nFREECLOS DC    X'001C',X'0000'                         DALCLOSE\nRTDDN    DC    X'0055',X'0001',X'0008',CL8' '          DALRTDDN\nTCBAD    DC    X'0001',X'0001',X'0004' PLUS XL4        DRITCBAD\n         SPACE 2\n***********************************************************************\n*        OTHER CONSTANTS                                              *\n***********************************************************************\nENDCHAIN DC    0F'0',X'FF000000'   END OF CHAIN OF PARSE PDE LIST\nERRPARML DC    C'PARMLIB LINKLIST MEMBER'\nERRSYSL  DC    AL1(34),C'CONCATENATED SYSTEM LINK LIBRARIES'\n         PRINT NOGEN\n         DS    0D\nDCBPARML DCB   DSORG=PS,MACRF=(GL)\nDCBSYSL  DCB   DSORG=PO,MACRF=(R)\n         LTORG\n         EJECT\n***********************************************************************\n*        WORKAREAS, DSECTS, AND MAPPING MACROES                       *\n***********************************************************************\nWORKAREA DSECT\n         DS    18F                 STANDARD REGISTER SAVEAREA\nDBLWORD  DS    D                   GENERAL PURPOSE DOUBLE WORD\nECB      DS    F                   TSSR COMMUNICATIONS ECB\nPPLAREA  DS    7F                  PARSE PARAMETER LIST\nPPLANSWR DS    F                   ADDRESS OF PDL (RETURNED BY PARSE)\nGFPARAM  DS    11F                 GNRLFAIL/VSAMFAIL ROUTINE PARAMETERS\nMTPARMS  DS    15F                 IKJEFF02 MESSAGE ISSUER PARM LIST\nS99PARMS DS    5F                  DYNAMIC ALLOCATION REQUEST BLOCK\nS99TEXTP DS    5F                  DYNALLOC TEXT UNIT POINTERS\nS99TEXT  DS    CL256               DYNALLOC TEXT UNITS (AND WORKAREA)\nDFPARAM  DS    5F                  DAIRFAIL ROUTINE PARAMETERS\nPARMNAME DS    XL14                                              WDPSC\nL1LS     DS    F                                                 WDPSC\nPLIST    DS    4F                                                WDPSC\nDSNCNT   DS    H                                                 WDPSC\nDSNTABLE DS    0XL6                TEXT UNIT KEYS FOR DATASETS TO BE\n         DS    0XL44                 ALLOCATED AND SEARCHED.\n         DS    (MAXDSNS)CL50         ROOM FOR STEP,LPA,SVC, & 16 LINKS\nDCB      DS    0D,CL96             DCB TO READ PARMLIB AND OPEN SYSLIBS\nDDNTABLE DS    XL4                 TEXT UNIT KEY TO CONCATENATE DDNAMES\n         DS    0XL2                  RETURNED BY DYNALLOC OF DSNTABLE.\n         DS    0XL8                  LENGTH OF EACH DDNAME FORCED TO 8\n         DS    (MAXDSNS)CL10         (TRAILING BLANKS IN VALUE ARE OK)\nBLDLIST  DS    H                   NUMBER OF ENTRIES IN LIST\nBLDELEN  DS    H                   LENGTH OF EACH ENTRY\nBLDAREA  DS    (MAXMEMS)CL(ENTRYLEN) ARRAY OF MEMBER NAME ENTRIES\nCORENEED EQU   *-WORKAREA          ***LENGTH NEEDED FOR GETMAIN***\n         SPACE 3\nPDSBLDL  DSECT\nBLDMEM   DS    CL8                 MEMBER OR ALIAS NAME\nBLDTT    DS    XL2                 TTR TRACK OF FIRST BLOCK\nBLDR     DS    X                   TTR RECORD\nBLDK     DS    X                   CONCATENATED DATASET NUMBER\nBLDLIBRY DS    X                   LIBRARY IDENTIFIER WHERE FOUND:\nBLDPRIV  EQU   0                     FOUND IN PRIVATE LIBRARY\nBLDLINK  EQU   1                     FOUND IN SYSTEM LINK LIST LIBRARY\nBLDJSTEP EQU   2                     FOUND IN JOB, STEP, OR TASK LIB\nBLDTYPE  DS    X\nBLDALIAS EQU   X'80'               BLDMEM FIELD IS AN ALIAS NAME\n         DS    XL3                 TTR OF FIRST TEXT BLOCK\n         DS    X                   RESERVED\n         DS    XL3                 TTR OF NOTE LIST OR SCATTER TABLE\n         DS    X                   NUMBER OF NOTE ENTRIES\nBLDATTR1 DS    X                   ATTRIBUTE BYTE 1\nBLDRENT  EQU   X'80'               REENTERABLE\nBLDREUS  EQU   X'40'               REUSABLE\nBLDATTR2 DS    X                   ATTRIBUTE BYTE 2\n         DS    XL3                 MAIN STORAGE NEEDED FOR MODULE\n         DS    XL2                 LENGTH OF FIRST TEXT BLOCK\n         DS    XL3                 ENTRY-POINT ADDRESS\n         DS    XL3                 FIRST TEXT BLOCK ORIGIN\n         DS    XL3                 ENTRY-POINT FOR MEMBER-NAME IF ALIAS\nBLDMEMA  DS    CL8                 LOAD MODULE MEMBER NAME IF ALIAS\n         SPACE 3\nLOCATE   CSECT\nPARSEPCL IKJPARM\nMEMNAME  IKJIDENT 'MEMBER NAME(S)',LIST,MAXLNTH=8,FIRST=ALPHA,         *\n               OTHER=ALPHANUM,PROMPT='MEMBER NAME(S)',HELP=('NAMES OF M*\n               EMBERS TO BE SEARCHED FOR IN THE SYSTEM LIBRARIES')\nALL      IKJKEYWD\n         IKJNAME 'ALL'\n         IKJENDP\n         PRINT GEN\n         IKJCPPL\n         IKJPPL\n         IKJEFFGF GFDSECT=YES\n         IKJEFFMT MTDSECT=YES\n         IEFZB4D0\nS99RBLEN EQU   S99RBEND-S99RB\n         IKJEFFDF DFDSECT=YES\nDFPEND   EQU   *\n         CVT   DSECT=YES           (DISTRIBUTED IN SYS1.AMODGEN)\n         EJECT\nMESSAGES CSECT\n         IKJTSMSG ('TOO MANY MEMBER NAMES FOR INTERNAL TABLE -- LIST TR*\n               UNCATED'),OVFL\n         IKJTSMSG ('STEPLIB FOUND TO BE CONCATENATED GROUP -- NOT SUPPO*\n               RTED, IGNORED'),STEP\n         IKJTSMSG ('UNABLE TO OPEN ',,' -- LOCATE TERMINATED'),NOPN\n         IKJTSMSG ('BLDL FAILED FOR ',,' -- BLDL RETURN CODE ',),BLDL\n         IKJTSMSG (,' IS A MEMBER IN ',),MEMB\n         IKJTSMSG (,' IS AN ALIAS ',,' IN ',),ALIA\n         IKJTSMSG (,' NOT FOUND IN ',),NFND\n         IKJTSMSG\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "LOGKILL$": {"ttr": 23046, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x00\\x7f\\x00\\x88\\x00\\x7f\\x12\\x00\\x00\\x15\\x00\\x15\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf2\\xf7\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-01-07T00:00:00", "modifydate": "1988-01-07T12:00:00", "lines": 21, "newlines": 21, "modlines": 0, "user": "FILE270"}, "text": "LOGKILLR actually consists of two CSECTs which are assembled together.\n\nLOGKILLM, the entry point, is used to replace the call to IKJEFLE in\nmodule IKJEFLA or IKJEFLA1(XA). This requires some tricky link-editing:\n\n INCLUDE USERLB(LOGKILLR)\n CHANGE IKJEFLE(LOGKILLM)\n INCLUDE LPALIB(IKJEFLA1)\n INCLUDE LPALIB(IKJEFLA1)     (to get IKJEFLE back in there)\n ALIAS LOGKILLR,and all the normal stuff...\n NAME IKJEFLA1(R)\n\nLOGKILLM attaches LOGKILLR as a subtask before calling IKJEFLE which\nattaches IKJEFLC who does the prompting stuff (terminal IO).\n\nIf IKJEFLE does not return in five minutes, LOGKILLR will abend the\naddress space. If IKJEFLE returns within five minutes, LOGKILLR is\ndetached before he can complete his mission.\n\nThis code may have to be updated to run in 31 bit mode. I don't think\nwe ran it under XA.\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "LOGKILLR": {"ttr": 23048, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x00\\x7f\\x00\\x88\\x00\\x7f\\x12\\x00\\x00C\\x00C\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf2\\xf7\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-01-07T00:00:00", "modifydate": "1988-01-07T12:00:00", "lines": 67, "newlines": 67, "modlines": 0, "user": "FILE270"}, "text": "*          DATA SET 761KKILLR  AT LEVEL 001 AS OF 07/13/81\n         TITLE 'LOGON STIMER KILL INTERCEPT MODULE'\nLOGKILLM ENTERR LEVEL=V2M1\n         EJECT\n*\n*              MAYBE WAIT A FEW SECONDS TO READ SOME MESSAGES:\n*\n         LR    R10,R1                   SAVE PARM PTR\n         L     R8,548                   R8->ASCB\n         L     R7,108(R8)               R7->ASXB\n         L     R6,20(R7)                R6->LWA\n         TM    59(R6),X'01'             INITIAL LOGON?\n         BO    GOFAST                   YES->GO ON QUICKLY\n         STIMER WAIT,BINTVL=FIVE       WAIT FIVE SECONDS\n         B     GOFAST                   THEN GO FAST\nFIVE     DC    F'500'                   5.00 SECONDS\n         EJECT\n*\n*              ATTACH THE KILLER:\n*\nGOFAST   ATTACH EP=LOGKILLR             ATTACH HIM\n         ST    R1,TCBADD                SAVE HIS ADDRESS\n         EJECT\n*\n*              CALL IKJEFLE:\n*\n         LR    R1,R10                   R1->FLE PARMS\n         CALL  IKJEFLE\n*\n         EJECT\n*\n*              NOW STOP THE KILLER BEFORE IT IS TOO LATE:\n*\n         DETACH TCBADD\n         EJECT\n*\n*              NOW RETURN TO IKJEFLC:\n*\n         LEAVER\n         EJECT\n         LTORG\nWORKAREA DSECT\nSAVEAREA DS    18F\nTCBADD   DS    F\nDUMMYECB DS    F\nWORKLEN  EQU   *-WORKAREA\n         TITLE 'LOGON STIMER CANCEL ROUTINE'\nLOGKILLR ENTERR  R=NO,LEVEL=V2M1\n         EJECT\n*\n*              SETUP FOR FIVE MINUTE WAIT:\n*\n         LA    R11,ABENDME\n         STIMER REAL,(R11),BINTVL=WAITTIME  ISSUE CONTRACT ON USER\n*\n*        WAIT  UNTIL SOMETHING HAPPENS:\n*\n         XC    DUMMYECB,DUMMYECB\n         WAIT  ECB=DUMMYECB\n*\n*              THEN ABEND THIS ADDRESS  SPACE:\n*\nABENDME  ABEND 99,,STEP,SYSTEM          KILL THIS ADDR SPACE\n*\nWAITTIME DC    F'30000'                 300 SECS = 5 MINUTES\n         LTORG\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "LPRTQ2": {"ttr": 23050, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x00\\x7f\\x00\\x88\\x00\\x7f\\x12\\x00\\x01\\x1c\\x01\\x1c\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf2\\xf7\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-01-07T00:00:00", "modifydate": "1988-01-07T12:00:00", "lines": 284, "newlines": 284, "modlines": 0, "user": "FILE270"}, "text": "***********************************************************************\n*                                                                     *\n* MODIFIED 12/20/83 BY KERMIT KISER - WASHINGTON STATE DP CENTER      *\n*  TO SUPPORT MORE QABS - MAY NEED HIGHER BUFNO TO WORK               *\n*                                                                     *\n*                                                                     *\n* FUNCTION - DISPLAY THE DSPRINT LOCAL PRINTER QUEUE                  *\n*                                                                     *\n* ENTRY POINT - LPQ                                                   *\n*                                                                     *\n* INPUT - DATA SET 'DSPRINT.REQUEST.QUEUE.                            *\n*                                                                     *\n* RESTRICTIONS - THIS PROGRAM ASSUMES THE INITQUE DEFAULTS OF 1 QAB   *\n*                AND TWO QEB'S.                                       *\n*                                                                     *\n* AUTHOR -        LESLIE F. ALNAS                                     *\n* INSTALLATION -  INTERNATIONAL GEOPHYSICAL COMPUTER SERVICES         *\n*                 LOS ANGELES, CALIFORNIA 90017                       *\n* DATE -          JANUARY 20, 1982                                    *\n*                                                                     *\n***********************************************************************\nLPQ      CSECT\n         SAVE  (14,12),,*               SAVE THE REGISTERS\n         LR    R12,R15                  LOAD EPA INTO 1ST BASE REGISTER\n         USING LPQ,R12                  ESTABLISH ADDRESSABILITY\n         ST    R13,SAVEAREA+4           SAVE CALLERS SAVEAREA PTR\n         LA    R3,SAVEAREA              ADDR OF MY SAVEAREA\n         ST    R3,8(13)                 SAVE MY SAVEAREA PTR\n         LR    R13,R3                   SAVEAREA ADDR IN REG 13\n         EJECT\n         OPEN  (DRQ,(INPUT))            OPEN DSPRINT.REQUEST.QUEUE\n         BAL   R7,INIT                  PUT OUT HEADER LINE\n         LA    R9,QABBUFA           R9->BUF PTR LIST AREA\n         SPACE\n*        LOOP TO READ ALL QUEUE DATASET BLOCKS AND SAVE PTRS TO THEM\nQRLOOP   GET   DRQ                      GET QUEUE ANCHOR BLOCK\n         ST    R1,0(R9)                 STORE QAB BUFFER ADDRESS\n         LA    R9,4(,R9)            R9 -> NEXT PTR SLOT\n         B     QRLOOP               READ NEXT BLOCK\n         SPACE\nSTART    L     R3,QABBUFA               LOAD ADDRESS OF QAB BUFFER\n         LA    R3,8(R3)                 POINT TO 1ST PRINTER QAB\n         USING DQAB,R3                  QUEUE ANCHOR BLOCK DSECT\n         USING DPQE,R4                  PRINT QUEUE ELEMENT DSECT\n         B     CHKNAME                  CHECK FOR VALID PRINTER NAME\n         SPACE\n*              LOOP THROUGH ALL PRINTER ELEMENTS:\nNEXTQAB  EQU   *\n         LA    R3,24(R3)                NEXT PRINTER QAB\n         L     R1,QABIX             R1=INDEX TO CURRENT BUF PTR\n         L     R2,QABBUFA(R1)       R2->CURRENT BUFFER\n         LA    R15,2480(,R2)        R15->END OF \"\n         CR    R3,R15               PAST END?\n         BL    CHKNAME              NOPE.->GO CHECK IT OUT.\n         TM    0(R2),X'80'          LAST QAB BUF?\n         BO    PQETOTAL             MUST BE DONE\n         LA    R1,4(,R1)            R1=INDEX TO NEXT QAB BUF PTR\n         ST    R1,QABIX             SAVE NEW INDEX\n         L     R2,QABBUFA(R1)       R2->NEXT QAB BUF\n         LTR   R2,R2                ANY BLOCK THERE?\n         BNP   QEBERROR             OOPS!\n         LA    R3,8(,R2)            R3->NEXT PRINTER ANCHOR\nCHKNAME  EQU   *\n         XR    R10,R10                  CLEAR PQE COUNT REGISTER\n         CLI   QABPTRNM,X'00'           PRINTER NAME DEFINED?\n         BE    PQETOTAL                 GO DISPLAY THE PQE TOTALS\nCHKQAB   EQU   *\n         CLC   QABORQEA,=F'0'           ANYTHING QUEUED?\n         BE    NEXTQAB                  NO...GET NEXT QAB ANCHOR\nGETQEB   EQU   *\n         MVC   MSGAREA(8),QABPTRNM      MOVE PRINTER NAME TO MSG AREA\n         LH    R1,QABORQEB          R1= INDEX TO QEB BUF PTR\n         LTR   R1,R1                GOOD ONE?\n         BNP   QEBERROR             NOPE!\n         SLL   R1,2                 MAKE INDEX INTO OFFSET INDEX\n         L     R4,QABBUFA(R1)       R4->QEB BUF\n         LTR   R4,R4                GOOD ONE?\n         BNP   QEBERROR             OOPS!\nMOVEPQE  EQU   *\n         AH    R4,QABORQEO              ADD OFFSET FOR PQE\n         EJECT\n*              LOOP THROUGH ALL REQUESTS FOR THE PRINTER:\nNEXTPQE  EQU   *\n         MVC   MSGAREA+9(7),PQETSOID    MOVE TSO USERID\n         TM    PQEDSTYP,X'02'           IS IT AN INTERIM DATA SET?\n         BO    MOVEDSN                  DON'T MOVE REQUEST NUMBER\n         LH    R5,PQEREQ#               GET REQUEST NUMBER\n         CVD   R5,WORK                  CONVERT TO IT TO DECIMAL\n         UNPK  MSGAREA+18(5),WORK+5(3)  MOVE REQUEST # TO MSGAREA\n         OI    MSGAREA+22,X'F0'         MAKE IT NUMERIC\nMOVEDSN  EQU   *\n         LR    R5,R4                    START OF PQE\n         LA    R5,4(R5)                 LOCATION OF DSNAME\n         LA    R6,MSGAREA+25            OUTPUT AREA FOR DSNAME\n         LA    R8,43                    MAX DSN LENGTH -1\n         TRT   0(44,R5),TABLE           FIND END OF DSN X'40'\n         BZ    EXMVCDSN                 MOVE ALL 44 CHARACTERS\n         SR    R1,R5                    GET LENGTH OF DSNAME\n         BCTR  R1,R0                    LENGTH MINUS 1\n         LR    R8,R1                    SAVE LENGTH OF MOVE\n         LR    R5,R4                    START OF PQE\n         LA    R5,4(R5)                 LOCATION OF DSNAME\nEXMVCDSN EQU   *\n         EX    R8,EXMVC                 EXECUTE MOVE FOR DSNAME\n         B     CHKMEMBR                 CHECK MEMBER NAME\nEXMVC    MVC   0(1,R6),0(R5)            >>>>>>  EXECUTE MOVE  <<<<<<\nCHKMEMBR EQU   *\n         CLI   PQEMEMBR,X'00'           IS THERE A MEMBER NAME?\n         BE    DOTPUT                   NO...GO PUT THE MSGAREA NOW\n         AR    R6,R8                    END OF DSNAME\n         MVI   1(R6),C'('               MOVE LEFT PARANTHESIS\n         LA    R6,2(R6)                 OUT AREA FOR MEMBER NAME\n         LR    R5,R4                    START OF PQE\n         LA    R5,48(R5)                LOCATION OF MEMBER NAME\n         LA    R8,7                     MAX MEMBER NAME LENGTH -1\n         TRT   0(8,R5),TABLE            FIND END OF MEMBER NAME X'40'\n         BZ    EXMVCMBR                 MEMBER NAME IS 8 BYTES LONG\n         SR    R1,R5                    GET LENGTH OF MEMBER NAME\n         BCTR  R1,R0                    LENGTH MINUS 1\n         LR    R8,R1                    SAVE LENGTH OF MOVE\n         LR    R5,R4                    START OF PQE\n         LA    R5,48(R5)                LOCATION OF MEMBER NAME\nEXMVCMBR EQU   *\n         EX    R8,EXMVC                 EXECUTE MOVE INSTRUCTION\n         AR    R6,R8                    END OF MEMBER NAME\n         MVI   1(R6),C')'               CLOSE PARANTHESIS\n         B     DOTPUT                   DO TPUT NOW\nDOTPUT   EQU   *\n         LA    R10,1(R10)               ADD 1 TO PQE COUNT\n         ST    R10,PQECOUNT             STORE THE COUNT FOR THAT QAB\n         BAL   R6,TPUTMSG               GO DISPLAY THE MESSAGE\n         CLC   PQENEXTA,=F'0'           IS THERE ANOTHER PQE CHAINED\n         BE    NEXTQAB                  NO...GET NEXT QAB\n         LH    R7,PQENEXTO              SAVE THE NEXT PQE OFFSET\n         LH    R1,PQENEXTB          R1= INDEX TO QEB BUF PTR\n         LTR   R1,R1                GOOD ONE?\n         BNP   QEBERROR             NOPE!\n         SLL   R1,2                 MAKE INDEX INTO OFFSET INDEX\n         L     R4,QABBUFA(R1)       R4->QEB BUF\n         LTR   R4,R4                GOOD ONE?\n         BNP   QEBERROR             OOPS!\n         AR    R4,R7                    GET OFFSET OF PQE\n         B     NEXTPQE                  GO MOVE NEXT PQE DATA\n         EJECT\n*              LPQ SUBROUTINES AND TERMINATION CODE:\nQEBERROR MVC   MSGAREA(38),=C'QEB ERROR...NOTIFY SYSTEMS PROGRAMMING'\n         BAL   R6,TPUTMSG              GO DISPLAY THE MESSAGE\n         B     DONE\nTPUTMSG  EQU   *\n         LA    R0,LMSG                  LENGTH OF MESSAGE\n         LA    R1,MSGAREA               POINT TO MESSAGE AREA\n         TPUT  (R1),(R0)                DISPLAY THE MESSAGE LINE\n         BAL   R8,CLRMSG                GO CLEAR THE MESSAGE AREA\n         BR    R6                       RETURN BRANCH\nINIT     EQU   *\n         BAL   R8,CLRMSG                GO CLEAR THE MESSAGE AREA\n         MVC   MSGAREA(22),=C'PRINTER  USERID   REQ#'\n         MVC   MSGAREA+27(22),=C'DATA SET NAME (MEMBER)'\n         BAL   R6,TPUTMSG              PUT OUT HEADER LINE\n         BAL   R8,CLRMSG                GO CLEAR THE MESSAGE AREA\n         BAL   R6,TPUTMSG               PUT OUT A BLANK LINE\n         BR    R7                       GO BACK\nCLRMSG   EQU   *\n         MVI   MSGAREA,C' '             CLEAR THE MESSAGE AREA\n         MVC   MSGAREA+1(LMSG-1),MSGAREA\n         BR    R8                       RETURN\n         EJECT\n*              START OF TERMINATION CODE: WHEN PRINTER LOOP ENDS:\nPQETOTAL EQU   *\n         BAL   R8,CLRMSG                GO CLEAR THE MESSAGE AREA\n         BAL   R6,TPUTMSG               PUT OUT A BLANK LINE\n         XC    QABIX,QABIX          RESET BUF INDEX TO ZERO\n         L     R3,QABBUFA               RELOAD ADDRESS OF QAB\n         LA    R3,8(R3)                 LOCATION OF 1ST PRINTER QAB\n         XR    R9,R9                    CLEAR TOTAL PQE'S REGISTER\n*              LOOP THRU PRINTERS TO DISPLAY REQUEST COUNTS:\nNEXTOTAL EQU   *\n         CLI   QABPTRNM,X'00'           VALID PRINTER NAME?\n         BE    PQEAVAIL                 NO...GO DISPLAY PQE'S AVAILABLE\n         CLI   PQECOUNT+3,X'00'         WAS ANYTHING TOTALED?\n         BE    BUMPQAB                  NO...THEN BUMP THE POINTER\n         L     R5,PQECOUNT              GET THE COUNT TOTAL\n         AR    R9,R5                    GET TOTAL FOR ALL QAB'S\n         CVD   R5,WORK                  CONVERT TO IT TO DECIMAL\n         UNPK  MSGAREA(2),WORK+6(2)     MOVE COUNT TO MSGAREA\n         CLI   MSGAREA,X'F0'            IS TENS POSITION A ZERO?\n         BNE   SKIPX40                  SKIP THE NEXT INSTRUCTION\n         MVI   MSGAREA,X'40'            DON'T PRINT THE ZERO\nSKIPX40  EQU   *\n         OI    MSGAREA+1,X'F0'          MAKE IT NUMERIC\n         MVC   MSGAREA+4(22),=C'DATA SET(S) QUEUED FOR'\n         MVC   MSGAREA+27(8),QABPTRNM   MOVE PRINTER NAME\n         BAL   R6,TPUTMSG               GO DISPLAY THE MESSAGE\nBUMPQAB  EQU   *\n         LA    R3,24(R3)                BUMP THE QAB POINTER\n         L     R1,QABIX             R1=INDEX TO CURRENT BUF PTR\n         L     R2,QABBUFA(R1)       R2->CURRENT BUFFER\n         LA    R15,2480(,R2)        R15->END OF \"\n         CR    R3,R15               PAST END?\n         BL    NEXTOTAL             NOPE.->GO CHECK IT OUT.\n         TM    0(R2),X'80'          LAST QAB BUF?\n         BO    PQEAVAIL             MUST BE DONE\n         LA    R1,4(,R1)            R1=INDEX TO NEXT QAB BUF PTR\n         ST    R1,QABIX             SAVE NEW INDEX\n         L     R2,QABBUFA(R1)       R2->NEXT QAB BUF\n         LTR   R2,R2                ANY BLOCK THERE?\n         BNP   QEBERROR             OOPS!\n         LA    R3,8(,R2)            R3->NEXT PRINTER ANCHOR\n         B     NEXTOTAL                 GO DO THE NEXT QAB TOTAL\nPQEAVAIL EQU   *\n         LTR   R9,R9                    ANYTHING THERE?\n         BNZ   MAXPQES                  YES...GET THE MAXIMUM PQE'S\n         MVC   MSGAREA+4(34),=C'ALL LOCAL PRINTER QUEUES ARE EMPTY'\n         BAL   R6,TPUTMSG               PUT OUT THE MESSAGE\nMAXPQES  EQU   *\n         B     DONE                 SKIP STUPID CODE:\n         LA    R5,62                    MAXIMUM PQE'S POSSIBLE\n         SR    R5,R9                    SUBTRACT NUMBER PQE'S USED\n         CVD   R5,WORK                  CONVERT IT TO DECIMAL\n         UNPK  MSGAREA(2),WORK+6(2)     MOVE TO MSGAREA\n         OI    MSGAREA+1,X'F0'          MAKE IT NUMERIC\n         MVC   MSGAREA+4(30),=C'PRINT QUEUE ELEMENTS AVAILABLE'\n         BAL   R6,TPUTMSG               GO DISPLAY THE MESSAGE\nDONE     EQU   *\n         L     R3,QABBUFA               ADDRESS OF QAB BUFFER\n         CLC   0(4,R3),=F'0'            ANY FREE PQE'S AVAILABLE\n         BNE   RETURN                   YES...RETURN NOW\n         BAL   R8,CLRMSG                CLEAR MESSAGE AREA\n         BAL   R6,TPUTMSG               PUT OUT A BLANK LINE\n         MVC   MSGAREA,=C'***** DSPRINT QUEUES ARE FULL *****'\n         BAL   R6,TPUTMSG               SEND QUEUE FULL MESSAGE\nRETURN   EQU   *\n         CLOSE (DRQ)                    CLOSE THE FILE\n         L     R13,4(0,R13)             RESTORE CALLERS SAVEAREA PTR\n         RETURN (14,12),RC=0            RETURN\n         PRINT NOGEN\nDRQ      DCB   MACRF=GL,DSORG=PS,DDNAME=DRQ,EODAD=START\nSAVEAREA DS    18F                      SAVEAREA\nTABLE    DC    256X'00'                 TRANSLATE TABLE\n         ORG   TABLE+X'40'\n         DC    X'FF'                    FUNCTION STOPPER\n         ORG   TABLE+256\nWORK     DS    D                        WORK AREA FOR CVD\nQABIX    DS    F                    INDEX TO BUF PTR TABLE:\nQABBUFA  DS    20F                      ADDRESS OF QAB BUFFER AREAS\nMSGAREA  DS    CL79                     MSG TO PUT\n         LTORG\nDQAB     DSECT                          QUEUE ANCHOR BLOCK DSECT\nQABPTRNM DS    CL8                      PRINTER NAME\nQABORQEA DS    0F                       OLDEST REQUEST ELEMENT\nQABORQEB DS    H                        REL. BLK. ADDR OF REQ. ELEMENT\nQABORQEO DS    H                        OFFSET WITHIN QEB FOR PQE\nPQECOUNT DS    0F                       FIELD ALSO USED TO COUNT PQE'S\nQABLRQEA DS    F                        LATEST REQUEST ELEMENT\n         DS    CL8                      REMAINING QAB BYTES\nDPQE     DSECT                          PRINT QUEUE ELEMENT DSECT\nPQENEXTA DS    0F                       POINTER TO NEXT PQE\nPQENEXTB DS    H                        REL. BLK. ADDR OF NEXT PQE\nPQENEXTO DS    H                        OFFSET OF NEXT PQE\nPQEDSN   DS    CL44                     PRINT DATA SET NAME\nPQEMEMBR DS    CL8                      PDS MEMBER NAME\nPQEREQ#  DS    H                        REQUEST NUMBER\n         DS    CL6                      RESERVED\n         DS    CL8                      PQE TIME STAMP\nPQETSOID DS    CL7                      TSO USER ID\nPQEDSTYP DS    X                        PQE DATA SET TYPE\nLMSG     EQU   L'MSGAREA                LENGTH OF MESSAGE\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "MACLIB": {"ttr": 23298, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x88\\x00\\x7f\\x00\\x98\\x05\\x8f\\x01\\x07&\\x9f&\\x8b\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1988-01-07T00:00:00", "modifydate": "1998-02-27T01:07:00", "lines": 9887, "newlines": 9867, "modlines": 0, "user": "SBGOLOB"}, "mimetype": "application/octet-stream", "datatype": "binary", "extension": ".bin"}, "MEMSTAT": {"ttr": 27145, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x00\\x7f\\x00\\x88\\x00\\x7f\\x12\\x00\\x00\\xea\\x00\\xea\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf2\\xf7\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-01-07T00:00:00", "modifydate": "1988-01-07T12:00:00", "lines": 234, "newlines": 234, "modlines": 0, "user": "FILE270"}, "text": "*          DATA SET 761KKMSTAT AT LEVEL 001 AS OF 10/13/80\n*          DATA SET SW2MEMSTAT AT LEVEL 001 AS OF 07/01/74\n         MACRO\n&LAB     PUTIT &MESS\n         LCLC  &L\n&L       SETC  'L'''\n&LAB     TPUT  M&SYSNDX,&L.M&SYSNDX\n         B     N&SYSNDX\nM&SYSNDX DC    C&MESS\nN&SYSNDX DS    0H\n         MEND\n*                        MEMSTAT\n* THE MEMSTAT PROGRAM WELL GO OUT TO A LIBRARY AND LOOK FOR A PITICULAR\n* MEMBER\nMEMSTAT  CSECT\nPARMLIST IKJPARM\nNAME     IKJPOSIT DSNAME,LIST,PROMPT='ENTER LIBRARY(MEMER) TO CHECK',  X\n               HELP='LIBRARY(MEMBER)'\nPRTL     IKJKEYWD  DEFAULT='PRINT'\n         IKJNAME  'PRINT'\n         IKJNAME  'NOPRINT'\n         IKJENDP\nMEMBERS  ENTER (14,12),11,(,WORKLEN)\n         LR    R2,R1\n         USING CPPL,R2             GET CONTROL\n         USING WORKAREA,R13        SAVE REGS\n         L     R7,CPPLUPT       *KK*\n         MVC   USID(8),16(R7)   *KK*\n         L     R7,PPLIST\n         ST    R7,PPLPCL\n         SR    R7,R7\n         MVC   PPLECT,CPPLECT\n         MVC   PPLCBUF,CPPLCBUF\n         MVC   PPLUPT,CPPLUPT\n         LA    R1,PPLUPT\n         LINK  EP=IKJPARS\n         LTR   R15,R15\n         BNZ   PARERR\nPARSOK   EQU   *\n         MVC   HOLDDSN,HELDDSN\n         L    R3,PPLANS\n         LA    R3,8(R3)\n         USING PDES,R3\n         L    R4,POINTDSN\n         LH    R5,DSNLEN\n         BCTR   R5,R0\n         LA     R6,HOLDDSN\n         EX     R5,MOVIT\n         TM    DSNFLG,X'40'\n         BNO   APPENDID\n         TM    MEMFLG,X'80'\n         BNO   NOMEM\nALLOCIT  EQU   *\n         LH   R6,DSNLEN\n         STH  R6,HOLDDSNL\n         LA    R6,HOLDDSNL\n         ST    R6,DA08PDSN\n         MVC   DAPLUPT,CPPLUPT\n         MVC   DAPLECT,CPPLECT\n         MVC   DAPLPSCB,CPPLPSCB\n         LA    R1,DA08CD\n         ST    R1,DAPLDAPB\n         LA    R1,DAPLUPT\n         LINK  EP=IKJDAIR\n         LTR   R15,R15\n         BNZ   DAIRERR\nDAIRDONE EQU   *\n         MVC   LIBDIR+40(8),DA08DDN\n         L     R4,POINTMEM\n         LH    R5,MEMLEN\n         BCTR   R5,0\n         LA     R6,HOLDMEM\n         EX     R5,MOVIT\n         OPEN  (LIBDIR)\nSTARTRDR EQU   *\n         FIND  LIBDIR,HOLDMEM,D\n         LTR   R15,R15\n         BNZ   NOTFOUND\nFOUNDIT  EQU   *\n         TM     KEYNUM,X'01'\n         BNO   ENDITALL\n         MVC   MSGFOUD+8(8),HOLDMEM\n         LA    R9,MSGFOUD\n         TPUT  (R9),23\n         B     ENDITALL\nNOTFOUND EQU   *\n         LA   R9,8\n         TM     KEYNUM,X'01'\n         BNO   BADRCOD\n         MVC   NOTFOUD+8(8),HOLDMEM\n         LA    R9,NOTFOUD\n         TPUT  (R9),33\n         LA   R9,8\n         B    BADRCOD\nPARERR   PUTIT 'PARSE ERROR'\n         B     ENDITALL\nDAIRERR  PUTIT 'LIBRARY  NOT FOUND '\n         B     ENDITALL\n*ODEALLC  PUTIT  'FILE HAS NOT BEEN DEALLOCATED DO A FREEALL'\nNODEALLC  B       LEAVEIT\nAPPENDID EQU   *\n         MVC   HOLDDSN(7),USID          *KK*\n         SLR   R1,R1                    *KK*\n         IC    R1,USID+7                *KK*\n         IC    R0,PERIOD                *KK*\n         STC   R0,HOLDDSN(R1)           *KK*\n         LA    R6,HOLDDSN+1(R1)         *KK*\n         L     R4,POINTDSN\n         LH    R5,DSNLEN\n         BCTR  R5,R0\n         EX    R5,MOVIT\n         LH     R5,DSNLEN\n         LA     R5,1(R5,R1)             *KK*\n        STH    R5,DSNLEN\n         B     ALLOCIT\nNOMEM    EQU   *\n         PUTIT 'NO MEMBER ENTERED'\nENDITALL EQU   *\n         SR     R9,R9\nBADRCOD EQU    *\n         CLOSE (LIBDIR)\n         MVC   DAPLUPT,CPPLUPT\n         MVC   DAPLECT,CPPLECT\n         MVC   DAPLPSCB,CPPLPSCB\n         LA   R1,DA18CD\n         ST   R1,DAPLDAPB\n         LA    R1,HOLDDSNL\n         ST    R1,DA18PDSN\n         LA    R1,DAPLUPT\n         LINK    EP=IKJDAIR\n         LTR   R15,R15\n         BNZ   NODEALLC\nLEAVEIT    EQU   *\n         LR   R15,R9\n         LEAVE EQ\nLIBDIR   DCB   DSORG=PO,DDNAME=BLANK,BLKSIZE=256,KEYLEN=0,MACRF=R,     X\n               RECFM=F,EODAD=ENDITALL\nMSGFOUD  DC    CL23'MEMBER           FOUND'\nNOTFOUD  DC    CL33'MEMBER           NOT IN DATA SET'\nHELDDSN  DC    CL44' '\n         DS    0D\nHOLDMEM   DC  CL8' '\nMOVIT    MVC  0(0,R6),0(R4)\nPPLIST     DC  V(PARMLIST)\nUSID       DC  CL8' '\nPERIOD   DC    C'.'\n         DS    0D\nDA08CD   DC    X'0008'\nDA08FLG  DC    H'0'\nDA08DARC DC    H'0'\nDA08CTRC DC    H'0'\nDA08PDSN DC    F'0'\nDA08DDN  DC    CL8' '\nDA08UNIT DC    CL8' '\nDA08SER  DC    CL8' '\nDA08BLK  DC    F'0'\nDA08PQTY DC    F'0'\nDA08SQTY DC    F'0'\nDA08DQTY DC    F'0'\nDA08MNM  DC    CL8' '\nDA08PSWD DC    CL8' '\nDA08DSP1 DC    X'08'\nDA08DSP2 DC    X'08'\nDA08DSP3 DC    X'08'\nDA08CTL  DC    X'00'\n         DC    X'000000'\nDA08DSO  DC    X'02'\n         DC     2F'0'\n*\n*\n         DS    0D\nDA18CD   DC    X'0018'\nDA18FLG  DC    H'0'\nDA18DARC DC    H'0'\nDA18CTRC DC    H'0'\nDA18PDSN DC    A(0)\nDA18DDN  DC    CL8' '\nDA18MNM  DC    CL8' '\nDA18SCLS DC    CL2' '\nDA18DPSC DC    X'08'\nDA18CTL  DC    X'0'\nDA18JBNM DC    CL8' '\n*\n*        PARSE PARM LIST\n*\nPPLUPT   DC    A(0)\nPPLECT   DC    A(0)\nPPLECB   DC    A(PPLECBS)\nPPLPCL   DC    A(0)\n         DC    A(PPLANS)\nPPLCBUF  DC    A(0)\nPPLWA    DC    A(0)\nPPLECBS  DC    A(0)\nPPLANS   DC    A(0)\n*\n*        DAIR  PARM LIST\n*\nDAPLUPT  DC    A(0)\nDAPLECT  DC    A(0)\nDAPLECB  DC    A(DAPLECBS)\nDAPLPSCB DC    A(0)\nDAPLDAPB DC   A(0)\nDAPLECBS DC    A(0)\n*\n*        WORK  AREA\n*\nWORKAREA DSECT\nSAVEAREA DS    18F\nHOLDDSNL     DS    H\nHOLDDSN       DS   CL44\nWORKLEN  EQU   *-WORKAREA\n*\n*        PDE ENTRIES\n*\nPDES     DSECT\nPOINTDSN DS    F\nDSNLEN   DS    H\nDSNFLG   DS    XL1\n         DS    XL1\nPOINTMEM DS    F\nMEMLEN   DS    H\nMEMFLG   DS    XL1\n         DS    XL1\n         DS    3F\n            DS   BL1\nKEYNUM       DS    BL1\nPDELEN   EQU   *-PDES\n*\n*         CPPL  PARM LIST PASSED WHEN CALLED\n*\n         IKJCPPL\n*\n*\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "MEMSTAT$": {"ttr": 27396, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x00\\x7f\\x00\\x88\\x00\\x7f\\x12\\x00\\x00)\\x00)\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf2\\xf7\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-01-07T00:00:00", "modifydate": "1988-01-07T12:00:00", "lines": 41, "newlines": 41, "modlines": 0, "user": "FILE270"}, "text": "1                                                        MEMSTAT.1\n                                                         06/25/82\n\n\n  COMMAND NAME:       MEMSTAT\n  SOURCE:             Kermit Kiser\n  AGENCY:             WDPSC\n  FUNCTION:           The MEMSTAT  command is  intended for  use in\n                      CLISTs.   It  allows   conditional  execution\n                      based on whether  a member exists in  a given\n                      partitioned dataset (library).\n\n  Syntax -\n  _________________________________________________________________\n       Command        Operands\n  -----------------------------------------------------------------\n       MEMSTAT        dsname(memname) PRINT\n                                     NOPRINT\n  -----------------------------------------------------------------\n\n  Operands -\n    Required - dsname(memname)\n    Default  - None\n       dsname - The name of the library you wish to check.\n       memname- The name of the member you wish to check for in the\n                library.\n       PRINT  - A message will be given with the member's status.\n                This is the default if neither PRINT nor NOPRINT is\n                entered.\n       NOPRINT- No message will be given.\n\n  EXAMPLE:       MEMSTAT    LIB.DATA(MEMBER)\n\n            NOTE:     MEMSTAT returns a condition code  of 0 if the\n            member exists in  the library and, if not, a  code of 8\n            is returned.   The CLIST variable &LASTCC  will contain\n            the return code.\n\n\n\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "MERGEJCL": {"ttr": 27398, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x00\\x7f\\x00\\x88\\x00\\x7f\\x12\\x00\\x00U\\x00U\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf2\\xf7\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-01-07T00:00:00", "modifydate": "1988-01-07T12:00:00", "lines": 85, "newlines": 85, "modlines": 0, "user": "FILE270"}, "text": "//KKM00155 JOB (2100,56-D),'KISER 2215 T',CLASS=A,MSGCLASS=T\n//*TYPRUN=HOLD\n//*\n//*  THIS JOB CONVERTS LIBRARYS SUCH AS WDPSC.MACLIB INTO\n//*    IEBUPDTE FORMAT AND PUTS THEM INTO THE EXPORT LIBRARY AS\n//*    A SINGLE MEMBER. IT USES THE LISTPDS PROGRAM FROM FILE 316\n//*    OF THE CBT TAPE TO CONVERT THE PDS TO SEQUENTIAL FORMAT.\n//*\n//S1   EXEC PGM=LISTPDS,PARM='NOLIST,DECK,UPDTE'\n//*\n//SYSPRINT DD SYSOUT=*\n//SYSLIB DD DISP=SHR,DSN=WDPSC.MACLIB\n//SYSPUNCH DD DSN=WDPSC.EXPORT.ALLOFEM(MACLIB),DISP=SHR\n//SYSIN DD DUMMY\n//*\n//S2   EXEC PGM=LISTPDS,PARM='NOLIST,DECK,UPDTE'\n//*\n//SYSPRINT DD SYSOUT=*\n//SYSLIB DD DISP=SHR,DSN=WDPSC.EXPORT.CLIST,DCB=LRECL=80\n//SYSPUNCH DD DSN=WDPSC.EXPORT.ALLOFEM(CLISTS),DISP=SHR\n//SYSIN DD DUMMY\n//*\n//S3   EXEC PGM=LISTPDS,PARM='NOLIST,DECK,UPDTE'\n//*\n//SYSPRINT DD SYSOUT=*\n//SYSLIB DD DISP=SHR,DSN=WDPSC.EXPORT.PROCLIB\n//SYSPUNCH DD DSN=WDPSC.EXPORT.ALLOFEM(PROCLIB),DISP=SHR\n//SYSIN DD DUMMY\n//*\n//S4   EXEC PGM=LISTPDS,PARM='NOLIST,DECK,UPDTE'\n//*\n//SYSPRINT DD SYSOUT=*\n//SYSLIB DD DISP=SHR,DSN=WDPSC.MASTER.CLIST.PARMS\n//SYSPUNCH DD DSN=WDPSC.EXPORT.ALLOFEM(PARMLIB),DISP=SHR\n//SYSIN DD DUMMY\n//*\n//S5   EXEC PGM=LISTPDS,PARM='NOLIST,DECK,UPDTE'\n//*\n//SYSPRINT DD SYSOUT=*\n//SYSLIB DD DISP=SHR,DSN=WDPSC.EXPORT.PANELS\n//SYSPUNCH DD DSN=WDPSC.EXPORT.ALLOFEM(PANELS),DISP=SHR\n//SYSIN DD DUMMY\n//*\n//S6   EXEC PGM=LISTPDS,PARM='NOLIST,DECK,UPDTE'\n//*\n//SYSPRINT DD SYSOUT=*\n//SYSLIB DD DISP=SHR,DSN=WDPSC.EXPORT.SKELS\n//SYSPUNCH DD DSN=WDPSC.EXPORT.ALLOFEM(SKELS),DISP=SHR\n//SYSIN DD DUMMY\n//*\n//S7   EXEC PGM=LISTPDS,PARM='NOLIST,DECK,UPDTE'\n//*\n//SYSPRINT DD SYSOUT=*\n//SYSLIB DD DISP=SHR,DSN=WDPSC.EXPORT.MSGS\n//SYSPUNCH DD DSN=WDPSC.EXPORT.ALLOFEM(MSGS),DISP=SHR\n//SYSIN DD DUMMY\n//*\n//S8   EXEC PGM=LISTPDS,PARM='NOLIST,DECK,UPDTE'\n//*\n//SYSPRINT DD SYSOUT=*\n//SYSLIB DD DISP=SHR,DSN=WDPSC.EXPORT.DOCS\n//SYSPUNCH DD DSN=WDPSC.EXPORT.ALLOFEM(DOCLIB),DISP=SHR\n//SYSIN DD DUMMY\n//*\n//S9   EXEC PGM=LISTPDS,PARM='NOLIST,DECK,UPDTE'\n//*\n//SYSPRINT DD SYSOUT=*\n//SYSLIB DD DISP=SHR,DSN=WDPSC.EXPORT.INDEXES,DCB=LRECL=80\n//SYSPUNCH DD DSN=WDPSC.EXPORT.ALLOFEM(INDEXES),DISP=SHR\n//SYSIN DD DUMMY\n//*\n//S10  EXEC PGM=LISTPDS,PARM='NOLIST,DECK,UPDTE'\n//*\n//SYSPRINT DD SYSOUT=*\n//SYSLIB DD DISP=SHR,DSN=WDPSC.EXPORT.CONTROL\n//SYSPUNCH DD DSN=WDPSC.EXPORT.ALLOFEM(CONTROL),DISP=SHR\n//SYSIN DD DUMMY\n//*\n//S11  EXEC PGM=LISTPDS,PARM='NOLIST,DECK,UPDTE'\n//*\n//SYSPRINT DD SYSOUT=*\n//SYSLIB DD DISP=SHR,DSN=WDPSC.EXPORT.JAN86\n//SYSPUNCH DD DSN=WDPSC.EXPORT.ALLOFEM(JAN86),DISP=SHR\n//SYSIN DD DUMMY\n//*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "MLPALIST": {"ttr": 27401, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x00\\x7f\\x00\\x88\\x00\\x7f\\x12\\x00\\x03\\x02\\x03\\x02\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf2\\xf7\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-01-07T00:00:00", "modifydate": "1988-01-07T12:00:00", "lines": 770, "newlines": 770, "modlines": 0, "user": "FILE270"}, "text": "*          DATA SET CBT930     AT LEVEL 001 AS OF 02/25/79\n* MLPALIST               VERSION 1.1 WDPSC AUTHOR STEVE ERICKSON        00001\n*          LISTS THE MODULES IN MEMORY THAT WERE LOADED BY THE          00002\n*  MODIFY LINK PACK AREA PARAMETER MEMBER AND THE FIXED LINK PACK       00003\n*  PACK AREA MEMBER, ALSO ANY MODULES THAT HAVE THE MODIFY/FIX BIT      00004\n*  OF THE CDE TURNED ARE LISTED.                                        00005\n*                                                                       00006\n* THE LIST FORMAT IS SIMILAR TO THAT OF LISTLPA COMMAND OF AMBLIST.     00007\n         SPACE 6                                                        00008\n*                                                                       00009\n*        DISTRIBUTION LIBRARY   SYS1.AMODGEN IS NEEDED TO ASSEMBLE THIS 00010\n*        ROUTINE.                                                       00011\n*                                                                       00012\n*        OTHER MACROS USED ARE                                          00013\n*               REGISTER - EQUATE MACRO FOR GENERAL REGISTERS           00014\n*               QKSRT1   - INTERNAL SORT ROUTINE, CSECT CREATED         00015\n*                                                                       00016\n*        PRINT OFF                                                      00017\n         MACRO                                                          00018\n         REGISTER                                                       00019\n         LCLA  &I                                                       00020\n.LOOP    ANOP                                                           00021\nR&I      EQU   &I                                                       00022\n&I       SETA  &I+1                                                     00023\n         AIF   (&I LT 16).LOOP                                          00024\n         MEND                                                           00025\n         MACRO                                                          00026\n         QKSRT1 &NAME,&TYPE,&LENGTH=0,&STRTKY=1,&KYLGTH=0,&ORDER=A,    X00027\n               &EXTRA=0,&OVRTYP=NONE,&DISP=1,&INLINE=NO                 00028\n*********************************************************************** 00029\n*** QUICKERSORT MACRO-SUBROUTINE: BASED ON CACM ALGORITHM NUMBER 271  * 00030\n*** THE FOLLOWING CHANGES AND ADDITIONS WERE MADE:                    * 00031\n*** 1.  CALCULATION OF P AS P:=(I+J)/2 WAS CHANGED TO: P:=I+(J-I)/2   * 00032\n*** 2.  THE LINE 'FOR Q:=Q STEP -1 UNTIL K DO' WAS CHANGED TO:        * 00033\n***        'FOR Q:=Q STEP -1 UNTIL K+1 DO'                            * 00034\n*** 3.  OPTION: CORRESPONDING ELEMENTS IN UP TO FIVE EXTRA ARRAYS MAY * 00035\n***        BE EXCHANGED, WHEN ELEMENTS IN THE SORTED ARRAY ARE        * 00036\n***        EXCHANGED.  EACH EXTRA ARRAY MUST CONTAIN THE SAME NUMBER  * 00037\n***        OF ELEMENTS, AND HAVE ELEMENT SIZES EQUAL TO THOSE OF THE  * 00038\n***        SORTED ARRAY.                                              * 00039\n*** 4.  OPTION: WITH 'TYPE' SET TO 'C' (CHARACTER FORMAT) OTHER TYPES * 00040\n***        OF COMPARES MAY BE MADE BY SPECIFYING ONE OR TWO           * 00041\n***        OVERRIDING PARAMETERS.                                     * 00042\n*** 5.  OPTION: IN LINE CODE MAY BE GENERATED, IF DESIRED, BY         * 00043\n***        SPECIFYING INLINE=YES.  A DUMMY PROGRAM NAME IS STILL      * 00044\n***        REQUIRED.  REGISTERS WILL BE SAVED IN A SPECIAL SAVEAREA.  * 00045\n*********************************************************************** 00046\n.********************************************************************** 00047\n.*           EXPLANATION OF KEYWORD AND POSITONAL OPERANDS:           * 00048\n.*                                                                    * 00049\n.* 1. NAME (POSITIONAL): THE SUBROUTINE MUST BE NAMED ARBITRARILY     * 00050\n.*    (ONE TO SIX CHARACTERS MAXIMUM) BY THE USER. FORTRAN OR COBOL   * 00051\n.*    RULES MUST BE FOLLOWED IN CHOOSING A NAME.                      * 00052\n.* 2. TYPE (POSITIONAL): THE TYPE OF VARIABLES TO BE SORTED MUST BE   * 00053\n.*    CONVEYED TO THE MACRO.  ADMISSIBLE VALUES ARE: P=PACKED;        * 00054\n.*    C=CHARACTER OR ALPHANUMERICS (= A-FORMAT VARIABLES); H=HALFWORD * 00055\n.*    INTEGERS (=INTEGER*2); F=FULLWORD (=INTEGER*4); E=SINGLE        * 00056\n.*    PRECISION FLOATING POINT (=REAL*4); D=DOUBLE PRECISION FLOATING * 00057\n.*    POINT (=REAL*8).                                                * 00058\n.* 3. LENGTH (KEYWORD): THE LENGTH IN BYTES OF THE FIELDS OF TYPES P  * 00059\n.*    AND C MUST BE SPECIFIED.  THE LENGTH MUST BE LESS THAN 256      * 00060\n.*    BYTES FOR C OR 16 BYTES FOR P.                                  * 00061\n.* 4. STRTKY (KEYWORD): THE COLUMN THE SORTING KEY BEGINS AT MAY BE   * 00062\n.*    CHANGED FROM ITS NULL VALUE OF COLUMN 1.                        * 00063\n.* 5. KYLGTH (KEYWORD): THE LENGTH OF THE DESIRED SORTING KEY.  IF    * 00064\n.*    KYLGTH IS OMITTED, LENGTH MINUS STRTKY IS THE DEFAULT OPTION.   * 00065\n.* 6. ORDER (KEYWORD): THE ORDER OF THE DESIRED SORT. OPTIONS ARE:    * 00066\n.*    A=ASCENDING ORDER; D=DESCENDING ORDER. IF ORDER IS NOT          * 00067\n.*    SPECIFIED, ASCENDING ORDER IS THE ASSUMED DEFAULT OPTION.       * 00068\n.* 7. EXTRA (KEYWORD): THE NUMBER OF ADDITIONAL ARRAYS (RANGE: 0 - 5) * 00069\n.*    EXTRA=0 IS THE DEFAULT OPTION.                                  * 00070\n.* 8. OVRTYP (KEYWORD): OVRTYP=(D,E,F, OR H) ALLOWS FIXED OR FLOATING * 00071\n.*    POINT COMPARES WITHIN LONGER FIELDS.  TYPE MUST EQUAL \"C\".      * 00072\n.* 9. DISP (KEYWORD): WHEN OVRTYP IS SPECIFIED, THIS SPECIFIES THE    * 00073\n.*    COLLUMN AT WHICH COMPARISON BEGINS.  DEFAULT IS COLLUMN 1.      * 00074\n.*10. INLINE (KEYWORD): INLINE=YES GENERATES IN LINE CODE WITHIN AN   * 00075\n.*    ASSEMBLER ROUTINE.  DEFAULT IS A CSECT CALLABLE BY FORTRAN.     * 00076\n.********************************************************************** 00077\n.*   THE FOLLOWING PARAMETER LIST IS REQUIRED IN THE FORTRAN CALL:    * 00078\n.*                                                                    * 00079\n.* 1. THE NAME OF THE ARRAY TO BE SORTED.                             * 00080\n.* 2. THE NUMBER OF ELEMENTS OF THE ARRAY TO BE SORTED.               * 00081\n.* 3. THE NAMES OF \"EXTRA\" ARRAYS, IF ANY.                            * 00082\n.********************************************************************** 00083\n.*  SEVERAL EXAMPLES WILL MAKE THE USE OF A MACRO SUBROUTINE CLEAR:   * 00084\n.*                                                                    * 00085\n.* PROBLEM 1: SORT THE CHARACTER ARRAY CALLED A OF 500 ELEMENTS OF 80 * 00086\n.* BYTES EACH ACCORDING TO AN 8 BYTE KEY STARTING IN COLUMN 20.       * 00087\n.* SOLUTION:  THE FOLLOWING CARDS ARE NEEDED:                         * 00088\n.* // JOB CARD                                                        * 00089\n.* // EXEC ASMGC                                                      * 00090\n.* //ASM.SYSIN DD *                                                   * 00091\n.* (QUICKERSORT MACRO DEFINITION SOURCE CODE IF NOT IN SYSTEM LIBRARY)* 00092\n.*          QKRSRT SORT1,C,LENGTH=80,STRTKY=20,KYLGTH=8               * 00093\n.*          END                                                       * 00094\n.* (COMMENT: THE NAME SORT1 WAS ARBITRARILY CHOSEN. ONLY THE QKRSRT   * 00095\n.* AND END CARD NEED APPEAR IF THE MACRO IS IN THE SYSTEM LIBRARY)    * 00096\n.* /*                                                                 * 00097\n.* // EXEC FORTGCLG                                                   * 00098\n.* //FORT.SYSIN DD *                                                  * 00099\n.* (FORTRAN DECK WHICH WILL CONTAIN THE FOLLOWING STATEMENT)          * 00100\n.*     .                                                              * 00101\n.*     .                                                              * 00102\n.*     .                                                              * 00103\n.*       CALL SORT1(A,500)                                            * 00104\n.*     .                                                              * 00105\n.*     .                                                              * 00106\n.*     .                                                              * 00107\n.* /*                                                                 * 00108\n.* //GO.SYSIN DD *                                                    * 00109\n.* (DATA, IF ANY)                                                     * 00110\n.* /*                                                                 * 00111\n.*                                                                    * 00112\n.* PROBLEM 2: SUPPOSE AN ARRAY OF DOUBLE PRECISION FLOATING POINT     * 00113\n.* NUMBERS IS TO BE SORTED.  SUPPOSE THE NAME DBLSRT IS CHOSEN FOR    * 00114\n.* THE SUBROUTINE.  THE MACRO PROTOTYPE CARD WOULD THEN READ:         * 00115\n.*          QKRSRT DBLSRT,D                                           * 00116\n.* HERE THE LENGTH IS IMPLIED TO BE 8 BYTES.  IN THE FORTRAN PROGRAM  * 00117\n.* THE STATEMENT \"CALL DBLSRT(.....)\" WOULD APPEAR.                   * 00118\n.*                                                                    * 00119\n.* PROBLEM 3: SUPPOSE AN ARRAY OF FIXED POINT NUMBERS IS TO BE SORTED.* 00120\n.* ALSO TO BE SORTED ELEMENT FOR ELEMENT WITH THE FIRST ARRAY ARE     * 00121\n.* THREE ADDITIONAL ARRAYS.  THE MACRO PROTOTYPE WOULD THEN READ:     * 00122\n.*          QKRSRT EXSRT,F,EXTRA=3                                    * 00123\n.* HERE THE LENGTH IS IMPLIED TO BE 4 BYTES.  IN THE FORTRAN PROGRAM  * 00124\n.* THE STATEMENT \"CALL EXSRT(.., .., .., .., ..)\" WOULD APPEAR.       * 00125\n.*                                                                    * 00126\n.* PROBLEM 4: SUPPOSE A REAL*4 ARRAY WITH DIMENSION ARR(3,100) IS TO  * 00127\n.* BE SORTED ON THE SECOND COLLUMN.  THE MACRO PROTOTYPE STATEMENT    * 00128\n.* WOULD THEN READ:                                                   * 00129\n.*          QKRSRT OVRSRT,C,LENGTH=12,OVRTYP=E,DISP=5                 * 00130\n.* HERE SORTING WOULD BE DONE ACCORDING TO THE SECOND COLLUMN.  IN THE* 00131\n.* FORTRAN PROGRAM THE STATEMENT \"CALL OVRSRT(ARR,100)\" WOULD APPEAR. * 00132\n.*                                                                    * 00133\n.* PROBLEM 5: SUPPOSE AN IN LINE SORT IS DESIRED IN AN ASSEMBLER      * 00134\n.* ROUTINE, WITH FIXED POINT COMPARES.  THE MACRO PROTOTYPE WOULD     * 00135\n.* THEN READ:                                                         * 00136\n.*          QKRSRT XYZ,F,INLINE=YES                                   * 00137\n.* HERE THE DUMMY NAME \"XYZ\" IS NOT GENERATED.  ENTERING THE SORT     * 00138\n.* ROUTINE, REGISTER 1 MUST CONTAIN THE ADDRESS OF A PARAMETER LIST   * 00139\n.* WITH THE ADDRESSES OF: THE ARRAY TO BE SORTED, THE ARRAY LENGTH    * 00140\n.* VARIABLE, AND EXTRA ARRAY ADDRESSES IF ANY.  THE CONTAINING CSECT  * 00141\n.* MUST USE R(15) FOR A BASE REGISTER.                                * 00142\n.*                                                                    * 00143\n.* EFFECTIVELY THE USER PROVIDES A ONE INSTRUCTION ASSEMBLY LANGUAGE  * 00144\n.* PROGRAM.  THE USER IS NOW ABLE TO SORT ANYTHING ANY WAY.           * 00145\n.********************************************************************** 00146\n         LCLA  &STRTKX,&LT2,&SLNGTX,&ZZ,&WW,&XX,&YY,&KYLGTX,&DISPL      00147\n         LCLC  &LENGTX,&TYPX,&BRNCH1,&BRNCH2,&QCHK,&REG,&Q              00148\n&KYLGTX  SETA  &KYLGTH *               VARIABLE PARAMETERS ARE          00149\n&TYPX    SETC  '&TYPE' *               CHANGED TO VARIABLE SYMBOLS      00150\n&LENGTX  SETC  '&LENGTH' *             SO THEIR VALUES MAY BE RESET     00151\n&STRTKX  SETA  &STRTKY-1                                                00152\n&DISPL   SETA  0                                                        00153\n         AIF   ('&OVRTYP' EQ 'NONE').REJ                                00154\n&DISPL   SETA  &DISP-1                                                  00155\n.REJ     AIF   (&EXTRA LE 5).L500                                       00156\n         MNOTE 16,'MORE THAN 5 EXTRA ARRAYS'                            00157\n         MEXIT                                                          00158\n.L500    ANOP                                                           00159\n&QCHK    SETC  'G' *                   INDICATES TYPE IS NOT C OR P     00160\n&REG     SETC  '7' *                   WORK REG IF TYPE IS NOT C OR P   00161\n         AIF   ('&ORDER' EQ 'A').L31 * WHICH ORDER IS DESIRED FOR SORT? 00162\n&BRNCH1  SETC  'H' *                   DESCENDING ORDER                 00163\n&BRNCH2  SETC  'L'                                                      00164\n         AGO   .L32                                                     00165\n.L31     ANOP *                        ASCENDING ORDER                  00166\n&BRNCH1  SETC  'L'                                                      00167\n&BRNCH2  SETC  'H'                                                      00168\n.L32     AIF   (1 LE K'&NAME AND K'&NAME LE 6).L2 * IS NAME OKAY?       00169\n         MNOTE 16,'IMPROPER LENGTH FOR SUBROUTINE NAME' * INVALID NAME  00170\n         MEXIT *                       STOP EXPANSION                   00171\n.L2      AIF   ('&TYPE' NE 'F' AND '&TYPE' NE 'E').L3 * TYPE F OR E?    00172\n&LENGTX  SETC  '4' *                   IF SO, SET LENGTH TO 4 BYTES     00173\n         AIF   ('&TYPE' NE 'F').L4                                      00174\n&TYPX    SETC  ' ' *                   IF TYPE F, SET &TYPX TO BLANK    00175\n         AGO   .L4                                                      00176\n.L3      AIF   ('&TYPE' NE 'H').L5 *   TYPE H (HALFWORD)?               00177\n&LENGTX  SETC  '2' *                   IF SO, SET LENGTH TO 2 BYTES     00178\n         AGO   .L4                                                      00179\n.L5      AIF   ('&TYPE' NE 'D').L6 *   TYPE D (DOUBLEWORD)?             00180\n&LENGTX  SETC  '8' *                   IF SO, SET LENGTH TO 8 BYTES     00181\n         AGO   .L4                                                      00182\n.L6      AIF   ('&TYPE' EQ 'C' OR '&TYPE' EQ 'P').L7 * TYPE C OR P?     00183\n         MNOTE 16,'INVALID TYPE' *     IF ABOVE TYPES NOT SPECIFIED     00184\n         MEXIT *                       STOP EXPANSION                   00185\n.L7      ANOP                                                           00186\n&QCHK    SETC  'B' *                   INDICATES TYPE IS C OR P         00187\n&REG     SETC  '6' *                   WORK REG IF TYPE IS C OR P       00188\n         AIF   ('&LENGTH' NE '0').L1 * LENGTH BLANK FOR TYPE C OR P?    00189\n         MNOTE 16,'LENGTH WAS NOT SPECIFIED FOR TYPE P OR C'            00190\n         MEXIT *                       IF SO, STOP EXPANSION            00191\n.L1      AIF   ('&OVRTYP' EQ 'NONE').M2                                 00192\n&Q       SETC  'B'                                                      00193\n         AIF   ('&OVRTYP' NE 'F' AND '&OVRTYP' NE 'E').M5               00194\n&YY      SETA  4                                                        00195\n         AGO   .M8                                                      00196\n.M5      AIF   ('&OVRTYP' NE 'H').M6                                    00197\n&YY      SETA  2                                                        00198\n         AGO   .M8                                                      00199\n.M6      AIF   ('&OVRTYP' NE 'D').M1                                    00200\n&YY      SETA  8                                                        00201\n.M8      ANOP                                                           00202\n&Q       SETC  'G'                                                      00203\n         AIF   (&DISP+&YY-1 LE &LENGTX).L4                              00204\n         MNOTE 16,'DISP PLUS OVRTYP LENGTH GREATER THAN LENGTH'         00205\n         MEXIT                                                          00206\n.M1      MNOTE 16,'INVALID OVRTYP'                                      00207\n         MEXIT                                                          00208\n.M2      AIF   (&STRTKX LE &LENGTH).M3                                  00209\n         MNOTE 16,'STRTKY GREATER THAN LENGTH'                          00210\n         MEXIT                                                          00211\n.M3      AIF   (&KYLGTX GT 0).M4                                        00212\n&KYLGTX  SETA  &LENGTH-&STRTKX                                          00213\n.M4      AIF   (&KYLGTX+&STRTKX LE &LENGTX).L4                          00214\n         MNOTE 16,'KYLGTH PLUS STRTKY GREATER THAN LENGTH'              00215\n         MEXIT                                                          00216\n.L4      ANOP                                                           00217\n&LT2     SETA  &LENGTX*2 *             LENGTH * 2                       00218\n&SLNGTX  SETA  &LENGTX/2-&LENGTX/8 *   SHIFT POSITIONS = LOG2(LENGTH)   00219\n         AIF   ('&QCHK' EQ 'G').L555                                    00220\n         AIF   ('&TYPE' EQ 'C').L551                                    00221\n         AIF   (&LENGTX LE 16).L555                                     00222\n         MNOTE 16,'LENGTH GREATER THAN 16 BYTES FOR DECIMAL'            00223\n         MEXIT                                                          00224\n.L551    AIF   (&LENGTX LE 256).L555                                    00225\n         MNOTE 16,'LENGTH GREATER THAN 256 BYTES FOR CHARACTER'         00226\n         MEXIT                                                          00227\n.L555    ANOP                                                           00228\n*                                      BEGIN QUICKERSORTING             00229\n         AIF   ('&INLINE' EQ 'NO').L543                                 00230\n         STM   14,12,S&SYSNDX                                           00231\n         AGO   .L531                                                    00232\n.L543    ANOP                                                           00233\n&NAME    CSECT                                                          00234\n         STM   14,12,12(13) *          SAVE REGISTERS                   00235\n         USING &NAME,15 *              SET UP BASE REGISTER             00236\n.L531    ST    13,R13&SYSNDX *            STORE POINTER TO SAVEAREA     00237\n*                                      (AD(W) MEANS THE ADDRESS OF W)   00238\n*                                      THE CONTENTS OF THE REGISTERS    00239\n*                                      FOR QUICKERSORT ARE AS FOLLOWS:  00240\n*                                       1 - LENGTH                      00241\n*                                       2 - TMP (TEMP. COMPARE STORAGE) 00242\n*                                       4 - T (TEMPORARY COMPARE ITEM)  00243\n*                                       5 - M (INDEX FOR LT AND UT)     00244\n*                                       8 - Q LOOP DECREMENT = LENGTH   00245\n*                                       9 - Q LOOP COMPARAND = AD(A(K)) 00246\n*                                      10 - K LOOP INCREMENT = LENGTH   00247\n*                                      11 - K LOOP COMPARAND = AD(A(Q)) 00248\n*                                      12 - AD(A(I))                    00249\n*                                      13 - AD(A(J))                    00250\n*                                      14 - =F'4' (CONSTANT)            00251\n*                                      15 - BASE REGISTER               00252\n*                                      0,3,6,7 - WORK REGISTERS         00253\n&XX      SETA  3+&EXTRA                                                 00254\n         LM    2,&XX,0(1)                                               00255\n         L     3,0(3)                                                   00256\n         AIF   (&EXTRA EQ 0).L88                                        00257\n         LR    9,2                                                      00258\n         AIF   (&EXTRA GT 1).L94                                        00259\n         LR    10,4                                                     00260\n         AGO   .L95                                                     00261\n.L94     ANOP                                                           00262\n&YY      SETA  9+&EXTRA                                                 00263\n         LM    10,&YY,8(1)                                              00264\n.L95     ANOP                                                           00265\n&ZZ      SETA  9                                                        00266\n&WW      SETA  4                                                        00267\n&YY      SETA  &EXTRA                                                   00268\n.L90     SR    &ZZ,&WW                                                  00269\n&YY      SETA  &YY-1                                                    00270\n&ZZ      SETA  &ZZ+1                                                    00271\n&WW      SETA  &WW+1                                                    00272\n         AIF   (&YY GT 0).L90                                           00273\n         SR    &ZZ,2                                                    00274\n         STM   9,&ZZ,DA&SYSNDX                                          00275\n.L88     LA    1,&LENGTX                                                00276\n         SR    2,1                                                      00277\n         SR    5,5 *                   M:=1;                            00278\n         LA    14,4                                                     00279\n         LR    10,1                                                     00280\n         LCR   8,1                                                      00281\n         LR    13,3                                                     00282\n         MR    12,1                                                     00283\n         LR    12,1 *                  I:=1;                            00284\n         AR    12,2                                                     00285\n         AR    13,2                                                     00286\n         AIF   ('&QCHK' EQ 'G').L1000                                   00287\n         LA    2,TMP&SYSNDX                                             00288\n.L1000   ANOP                                                           00289\nN&SYSNDX LR    &REG,13 *               N: IF J-I > 1 THEN               00290\n         SR    &REG,12                                                  00291\n         SR    &REG,1                                                   00292\n         BNP   L3E&SYSNDX                                               00293\n*                                      BEGIN COMMENT;                   00294\n         AR    &REG,1 *                   P:=I+(J-I)/2;                 00295\n         AIF   ('&QCHK' EQ 'G').L41                                     00296\n         SRDA  6,33                                                     00297\n         DR    6,1                                                      00298\n         MR    6,1                                                      00299\n         AGO   .L42                                                     00300\n.L41     SRA   7,&SLNGTX+1                                              00301\n         SLA   7,&SLNGTX                                                00302\n.L42     AR    7,12                                                     00303\n         AIF   ('&QCHK' EQ 'G').L43                                     00304\n         MVC   0(&LENGTX,2),0(7) *          T := A(P);                  00305\n         MVC   0(&LENGTX,7),0(12) *          A(P) := A(I);              00306\n         AIF   (&EXTRA EQ 0).L4444                                      00307\n&XX      SETA  0                                                        00308\n&YY      SETA  0                                                        00309\n&ZZ      SETA  &LENGTX                                                  00310\n.L1002   S     7,DA&SYSNDX+&YY                                          00311\n         S     12,DA&SYSNDX+&YY                                         00312\n         AIF   (&XX EQ &EXTRA).L44                                      00313\n         MVC   &ZZ.(&LENGTX,2),0(7)                                     00314\n         MVC   0(&LENGTX,7),0(12)                                       00315\n&XX      SETA  &XX+1                                                    00316\n&YY      SETA  &YY+4                                                    00317\n&ZZ      SETA  &ZZ+&LENGTX                                              00318\n         AGO   .L1002                                                   00319\n.L43     L&TYPX    4,0(7) *                T:=A(P);                     00320\n         L&TYPX    6,0(12)                                              00321\n         ST&TYPX    6,0(7) *                A(P):=A(I);                 00322\n         AIF   (&EXTRA EQ 0).L44                                        00323\n&XX      SETA  0                                                        00324\n&YY      SETA  0                                                        00325\n&ZZ      SETA  &LENGTX                                                  00326\n.L1001   S     7,DA&SYSNDX+&YY                                          00327\n         S     12,DA&SYSNDX+&YY                                         00328\n         AIF   (&XX EQ &EXTRA).L44                                      00329\n         L&TYPX 0,0(7)                                                  00330\n         L&TYPX 6,0(12)                                                 00331\n         ST&TYPX 6,0(7)                                                 00332\n         ST&TYPX 0,TMP&SYSNDX+&ZZ                                       00333\n&XX      SETA  &XX+1                                                    00334\n&YY      SETA  &YY+4                                                    00335\n&ZZ      SETA  &ZZ+&LENGTX                                              00336\n         AGO   .L1001                                                   00337\n.L4444   AIF   ('&OVRTYP' EQ 'NONE' OR '&TYPE' NE 'C').L44              00338\n&TYPX    SETC  '&OVRTYP'                                                00339\n         AIF   ('&TYPX' NE 'F').NOREJ                                   00340\n&TYPX    SETC  ' '                                                      00341\n.NOREJ   L&TYPX 4,&DISPL.(2)                                            00342\n.L44     LR    11,13 *                  Q := J;                         00343\n         LR    9,12                                                     00344\n         AR    9,1                                                      00345\n         AIF   ('&OVRTYP' EQ 'NONE' OR '&TYPE' NE 'C').NN               00346\n&QCHK    SETC  '&Q'                                                     00347\n&TYPX    SETC  '&OVRTYP'                                                00348\n         AIF   ('&TYPX' NE 'F').NN                                      00349\n&TYPX    SETC  ' '                                                      00350\n.NN      AIF   ('&QCHK' EQ 'B').L11                                     00351\nLP1&SYSNDX C&TYPX    4,&DISPL.(9) *          FOR K:=I+1STEP1 UNTIL Q DO 00352\n*                                      BEGIN COMMENT;                   00353\n         BN&BRNCH1   ND1&SYSNDX *               IF A(K) > T THEN        00354\n*                                      BEGIN COMMENT;                   00355\nLP2&SYSNDX C&TYPX  4,&DISPL.(11) *         FOR Q:=Q STEP-1 UNTIL K+1 DO 00356\n*                                      BEGIN COMMENT;                   00357\n         AGO   .L12                                                     00358\n.L11     AIF   ('&TYPX' NE 'P').L13                                     00359\n*                                      FOR K := I+1 STEP 1 UNTIL Q DO   00360\n*                                      BEGIN COMMENT;                   00361\n*                                     IF A(K) > T THEN                  00362\nLP1&SYSNDX CP    &STRTKX.(&KYLGTX,2),&STRTKX.(&KYLGTX,9)                00363\n         BN&BRNCH1   ND1&SYSNDX                                         00364\n*                                      BEGIN COMMENT;                   00365\n*                                     FOR Q := Q STEP -1 UNTIL K+1 DO   00366\n*                                      BEGIN COMMENT;                   00367\nLP2&SYSNDX CP    &STRTKX.(&KYLGTX,2),&STRTKX.(&KYLGTX,11)               00368\n         AGO   .L12                                                     00369\n.L13     ANOP                                                           00370\n*                                      FOR K := I+1 STEP 1 UNTIL Q DO   00371\n*                                      BEGIN COMMENT;                   00372\n*                                     IF A(K) > T THEN                  00373\nLP1&SYSNDX CLC   &STRTKX.(&KYLGTX,2),&STRTKX.(9)                        00374\n         BN&BRNCH1   ND1&SYSNDX                                         00375\n*                                      BEGIN COMMENT;                   00376\n*                                     FOR Q := Q STEP -1 UNTIL K+1 DO   00377\n*                                      BEGIN COMMENT;                   00378\nLP2&SYSNDX CLC   &STRTKX.(&KYLGTX,2),&STRTKX.(11)                       00379\n.L12     AIF   ('&OVRTYP' EQ 'NONE' OR '&TYPE' NE 'C').K1               00380\n&QCHK    SETC  'B'                                                      00381\n&TYPX    SETC  'C'                                                      00382\n.K1      BN&BRNCH2   ND2&SYSNDX *               IF A(Q) < T THEN        00383\n*                                      BEGIN COMMENT;                   00384\n&YY      SETA  0-4                                                      00385\n&XX      SETA  0                                                        00386\n.L99     AIF   ('&QCHK' EQ 'G').L46                                     00387\n         XC    0(&LENGTX,11),0(9) *          X := A(K);                 00388\n         XC    0(&LENGTX,9),0(11) *          A(K) := A(Q);              00389\n         XC    0(&LENGTX,11),0(9) *          A(Q) := X;                 00390\n         AGO   .L147                                                    00391\n.L46     L&TYPX    6,0(11)                                              00392\n         L&TYPX    0,0(9) *                X:=A(K);                     00393\n         ST&TYPX    6,0(9) *                A(K):=A(Q);                 00394\n         ST&TYPX   0,0(11) *               A(Q):=X;                     00395\n.L147    AIF   (&EXTRA EQ 0).L47                                        00396\n&XX      SETA  &XX+1                                                    00397\n&YY      SETA  &YY+4                                                    00398\n         S     9,DA&SYSNDX+&YY                                          00399\n         S     11,DA&SYSNDX+&YY                                         00400\n         AIF   (&XX LE &EXTRA).L99                                      00401\n.L47     SR    11,1 *                  Q := Q - 1;                      00402\n*                                      COMMENT;                         00403\n         B     ND1&SYSNDX *               GO TO L (ND1);                00404\n*                                      END                              00405\nND2&SYSNDX BXH   11,8,LP2&SYSNDX *          END FOR Q;                  00406\n         LR    11,9 *                  Q := K - 1;                      00407\n         SR    11,1                                                     00408\n         B     M&SYSNDX *                 GO TO M;                      00409\n*                                      END                              00410\nND1&SYSNDX BXLE  9,10,LP1&SYSNDX *       L: END FOR K;                  00411\n*                                      COMMENT;                         00412\n         AIF   ('&QCHK' EQ 'G').L48                                     00413\nM&SYSNDX MVC   0(&LENGTX,12),0(11) *      M: A(I) := A(Q);              00414\n         MVC   0(&LENGTX,11),TMP&SYSNDX *       A(Q) := T;              00415\n         AIF   (&EXTRA EQ 0).L49                                        00416\n&XX      SETA  0                                                        00417\n&YY      SETA  0                                                        00418\n&ZZ      SETA  &LENGTX                                                  00419\n.L876    S     11,DA&SYSNDX+&YY                                         00420\n         S     12,DA&SYSNDX+&YY                                         00421\n         AIF   (&XX EQ &EXTRA).L49                                      00422\n&YY      SETA  &YY+4                                                    00423\n         MVC   0(&LENGTX,11),&ZZ.(2)                                    00424\n&XX      SETA  &XX+1                                                    00425\n         MVC   0(&LENGTX,12),0(11)                                      00426\n&ZZ      SETA  &ZZ+&LENGTX                                              00427\n         AGO   .L876                                                    00428\n.L48     ANOP                                                           00429\nM&SYSNDX L&TYPX    6,0(11) *            M: A(I):=A(Q);                  00430\n         ST&TYPX    6,0(12)                                             00431\n         ST&TYPX    4,0(11) *               A(Q):=T;                    00432\n         AIF   (&EXTRA EQ 0).L49                                        00433\n&XX      SETA  0                                                        00434\n&YY      SETA  0                                                        00435\n&ZZ      SETA  &LENGTX                                                  00436\n.L765    S     11,DA&SYSNDX+&YY                                         00437\n         S     12,DA&SYSNDX+&YY                                         00438\n         AIF   (&XX EQ &EXTRA).L49                                      00439\n         L&TYPX 0,0(11)                                                 00440\n         ST&TYPX 0,0(12)                                                00441\n         L&TYPX 4,TMP&SYSNDX+&ZZ                                        00442\n         ST&TYPX 4,0(11)                                                00443\n&XX      SETA  &XX+1                                                    00444\n&YY      SETA  &YY+4                                                    00445\n&ZZ      SETA  &ZZ+&LENGTX                                              00446\n         AGO   .L765                                                    00447\n.L49     ANOP                                                           00448\n*                                      COMMENT;                         00449\n         LR    6,11 *                  IF 2 *Q > I+J THEN               00450\n         SR    11,1                                                     00451\n         SLA    6,1                                                     00452\n         SR    6,12                                                     00453\n         SR    6,13                                                     00454\n         BNP   LWR&SYSNDX *               BEGIN                         00455\n         ST    12,LT&SYSNDX.(5) *           LT(M) := I;                 00456\n         ST    11,UT&SYSNDX.(5) *          UT(M) := Q - 1;              00457\n         LA    11,&LT2.(11)                                             00458\n         LR    12,11 *                 I:=Q+1;                          00459\n         B     UM&SYSNDX *                END                           00460\n*                                      ELSE                             00461\n*                                      BEGIN                            00462\nLWR&SYSNDX ST    13,UT&SYSNDX.(5) *           UT(M) := J;               00463\n         LR    13,11 *                 J:=Q-1;                          00464\n         LA    11,&LT2.(11)                                             00465\n         ST    11,LT&SYSNDX.(5) *          LT(M) := Q + 1;              00466\n*                                      COMMENT;                         00467\nUM&SYSNDX LA    5,4(5) *                M := M + 1;                     00468\n         B     N&SYSNDX *                 GO TO N                       00469\n*                                      END                              00470\nL3E&SYSNDX CR    12,13 *                   ELSE IF I >= J THEN          00471\n*                                      BEGIN COMMENT;                   00472\n         BNL   P&SYSNDX *                 GO TO P                       00473\n*                                      END                              00474\n*                                      ELSE                             00475\n*                                      BEGIN COMMENT;                   00476\n         AIF   ('&OVRTYP' EQ 'NONE' OR '&TYPE' NE 'C').NP               00477\n&QCHK    SETC  '&Q'                                                     00478\n&TYPX    SETC  '&OVRTYP'                                                00479\n         AIF   ('&TYPX' NE 'F').NP                                      00480\n&TYPX    SETC  ' '                                                      00481\n.NP      AIF   ('&QCHK' EQ 'B').L21                                     00482\n         L&TYPX    0,&DISPL.(12)                                        00483\n         C&TYPX    0,&DISPL.(13) *               IF A(I) > A(J) THEN    00484\n         AGO   .L22                                                     00485\n.L21     AIF   ('&TYPX' NE 'P').L23                                     00486\n         CP    &STRTKX.(&KYLGTX,12),&STRTKX.(&KYLGTX,13)                00487\n*                                     IF A(I) > A(J) THEN               00488\n         AGO   .L22                                                     00489\n.L23     CLC   &STRTKX.(&KYLGTX,12),&STRTKX.(13)                        00490\n*                                     IF A(I) > A(J) THEN               00491\n.L22     AIF   ('&OVRTYP' EQ 'NONE' OR '&TYPE' NE 'C').K2               00492\n&QCHK    SETC  'B'                                                      00493\n&TYPX    SETC  'C'                                                      00494\n.K2      BN&BRNCH2   P&SYSNDX                                           00495\n*                                      BEGIN                            00496\n&YY      SETA  0-4                                                      00497\n&XX      SETA  0                                                        00498\n         AIF   ('&QCHK' EQ 'G').L410                                    00499\n.L999    AIF   ('&QCHK' EQ 'G').L987                                    00500\n         XC    0(&LENGTX,12),0(13) *           X := A(I);               00501\n         XC    0(&LENGTX,13),0(12) *           A(I) := A(J);            00502\n         XC    0(&LENGTX,12),0(13) *           A(J) := X;               00503\n         AGO   .L41129                                                  00504\n.L987    L&TYPX 0,0(12)                                                 00505\n.L410    L&TYPX    6,0(13) *               X:=A(I);                     00506\n         ST&TYPX    0,0(13) *               A(I):=A(J);                 00507\n         ST&TYPX    6,0(12) *               A(J):=X;                    00508\n.L41129  AIF   (&EXTRA EQ 0).L411                                       00509\n&XX      SETA  &XX+1                                                    00510\n&YY      SETA  &YY+4                                                    00511\n         S     12,DA&SYSNDX+&YY                                         00512\n         S     13,DA&SYSNDX+&YY                                         00513\n         AIF   (&XX LE &EXTRA).L999                                     00514\n.L411    ANOP                                                           00515\n*                                      END;                             00516\n*                                      COMMENT;                         00517\nP&SYSNDX SR    5,14 *               P: M := M - 1;                      00518\n         BM    QT&SYSNDX *                IF M > 0 THEN                 00519\n*                                      BEGIN                            00520\n         L     12,LT&SYSNDX.(5) *           I := LT(M);                 00521\n         L     13,UT&SYSNDX.(5) *           J := UT(M);                 00522\n         B     N&SYSNDX *                 GO TO N                       00523\n*                                      END;                             00524\n*                                      END                              00525\nQT&SYSNDX L     13,R13&SYSNDX *            END QUICKERSORT              00526\n         AIF   ('&INLINE' EQ 'NO').F100                                 00527\n         LM    14,12,S&SYSNDX                                           00528\n         B     YY&SYSNDX                                                00529\nS&SYSNDX DS    15F                                                      00530\n         AGO   .F250                                                    00531\n.F100    LM    14,12,12(13) *          RESTORE REGISTERS                00532\n         BR    14 *                    RETURN TO CALLING PROGRAM        00533\n.F250    ANOP                                                           00534\nUT&SYSNDX DS    20F *                   AUXILLARY STORAGE FOR UT ARRAY  00535\nLT&SYSNDX DS    20F *                   AUXILLARY STORAGE FOR LT ARRAY  00536\n         AIF   (&EXTRA GT 0).LK                                         00537\n         AIF   ('&QCHK' EQ 'G').LL                                      00538\nTMP&SYSNDX DS    CL&LENGTH *                  TEMP STORAGE FOR COMPARES 00539\n         AGO   .LL                                                      00540\n.LK      ANOP                                                           00541\n&YY      SETA  &EXTRA+1                                                 00542\nTMP&SYSNDX DS  &YY.CL&LENGTX *                 TEMP STORAGE FOR COMPARE 00543\n.LL      ANOP                                                           00544\nR13&SYSNDX DS    F *                     SAVE AREA FOR REGISTER 13      00545\n         AIF   (&EXTRA EQ 0).LM                                         00546\n&YY      SETA  &EXTRA+1                                                 00547\nDA&SYSNDX DS   &YY.F *                    SAVE AREA FOR ADDRESS CHANGES 00548\n.LM      AIF   ('&INLINE' EQ 'NO').LMN                                  00549\nYY&SYSNDX NOPR 12                                                       00550\n.LMN     MEND                                                           00551\n         EJECT                                                          00552\n         PRINT ON                                                       00553\nMLPALIST CSECT                                                          00554\n         REGISTER                                                       00555\n         B     12(,R15)                                                 00556\n         DC    CL8'BLOCKS'                                              00557\n         STM   R14,R12,12(R13)                                          00558\n         LR    R12,R15            USE REG 12 AS BASE                    00559\n         USING MLPALIST,R12                                             00560\n         GETMAIN RU,LV=LENGTH                                           00561\n         ST    R13,4(,R1)         CHAIN SAVEAREAS                       00562\n         ST    R1,8(,R13)         TOGETHER                              00563\n         LR    R13,R1                                                   00564\n         USING SAVEAREA,R13                                             00565\n         SPACE 3                                                        00566\n         MVC   RENTDCB(DCBLEN),SYSPRINT   MOVE DCB TO DSECT             00567\n         MVC   OPENL(OPENLEN),OPEN        MOVE OPEN STMTS TO DSECT      00568\n         LA    R1,OPENL           LETS OPEN THE PRINTER                 00569\n         OPEN  RENTDCB,MF=(E,(1)) WELL OPEN SAYS ME                     00570\n         MVI   PRINT,C' '         CLEAR OUT THE PRINT LINE              00571\n         MVC   PRINT+1(L'PRINT-1),PRINT                                 00572\n         SLR   R1,R1              CLEAR REG 1                           00573\n         ST    R1,ENTRIES         INIT VALUE                            00574\n         LA    R1,TABLE           GET THE ARRAY START ADDR              00575\n         ST    R1,PARM            SAVE IT IN PARM FIELD                 00576\n         ST    R1,CURRENT         SAVE FOR USE AS COUNTER               00577\n         LA    R1,ENTRIES         GET THE # OF ENTRIES POINTER          00578\n         ST    R1,PARM+4          SAVE THE SECOND PARM FIELD            00579\n         SPACE 3                                                        00580\n         L     R3,CVTPTR          GET THE CVT POINTER                   00581\n         USING CVT,R3             GET ADDRESSABILITY TO CVT             00582\n         L     R2,CVTQLPAQ        GET CDE CHAIN POINTER FROM CVT        00583\n         USING CDENTRY,R2         SET UP ADDRESSABILITY TO CDE          00584\n         SPACE 3                                                        00585\nCDELOOP  EQU   *                                                        00586\n         TM    CDATTR,CDNIP       WAS THIS CDE LOADED BY MLPA           00587\n         BO    MLPALOAD           YES IT WAS                            00588\nNEXTCDE  EQU   *                                                        00589\n         L     R2,CDCHAIN         GET THE NEXT LPA CDE ENTRY            00590\n         LA    R2,0(,R2)          CLEAR BYTE JUST IN CASE               00591\n         LTR   R2,R2              CHECK FOR END OF CHAIN                00592\n         BNZ   CDELOOP            NOPE GO GET ANOTHER CDE               00593\n         SPACE 3                                                        00594\n         L     R1,CURRENT         GET THE CURRENT POINTER               00595\n         MVC   0(L'PRINT,R1),PRINT  CLEAR OUT END OF TABLE              00596\n         LA    R1,PARM            SET UP FOR SORT                       00597\n         L     R15,=V(ALPHA)      LETS SORT IT ALPHA                    00598\n         BALR  R14,R15            GO DO IT                              00599\n         MVI   PRINT,C'1'                                               00600\n         MVC   PRINT+1(L'ALPHAHED),ALPHAHED MOVE IN HEADING             00601\n         BAL   R10,PRINTIT        PRINT HEADING                         00602\n         MVI   PRINT,C'0'                                               00603\n         MVC   PRINT+1(L'HEADER2),HEADER2                               00604\n         BAL   R10,PRINTIT                                              00605\n         L     R2,ENTRIES         HOW MANY ENTRIES DO WE HAVE           00606\n         LA    R2,1(,R2)          BUMP FOR DIVIDE                       00607\n         SRL   R2,1               DIVIDE BY 2                           00608\n         LR    R4,R2              SAVE FOR LATER                        00609\n         LA    R3,TABLE           GET START OF TABLE                    00610\n         LA    R6,56              MAX LINES PER PAGE                    00611\nPRTA     EQU   *                                                        00612\n         MVC   PRINT+1(L'CURENTRY),0(R3) GET THE CURRENT ENTRY          00613\n         MVC   PRINT+60(L'CURENTRY),48(R3) GET NEXT ENTRY               00614\n         BAL   R10,PRINTIT        NOW PRINTIT                           00615\n         BCTR  R6,R0              SUBTRACE 1 FROM LINE COUNT            00616\n         LTR   R6,R6              CHECK FOR FULL PAGE                   00617\n         BNZ   NOHEADA                                                  00618\n         MVI   PRINT,C'1'                                               00619\n         MVC   PRINT+1(L'ALPHAHED),ALPHAHED PRINT HEADING LINE          00620\n         BAL   R10,PRINTIT                                              00621\n         MVI   PRINT,C'0'                                               00622\n         MVC   PRINT+1(L'HEADER2),HEADER2                               00623\n         BAL   R10,PRINTIT                                              00624\nNOHEADA  EQU   *                                                        00625\n         LA    R3,96(,R3)         GET NEXT CDE POINTER                  00626\n         BCT   R2,PRTA            GET NEXT ONE                          00627\n         LA    R1,PARM            SET UP FOR SORT                       00628\n         L     R15,=V(NUMER)    LETS SORT IT NUMERIC                    00629\n         BALR  R14,R15            DO IT                                 00630\n         MVI   PRINT,C'1'                                               00631\n         MVC   PRINT+1(L'NUMHED),NUMHED FIX UP HEADING                  00632\n         BAL   R10,PRINTIT                                              00633\n         MVI   PRINT,C'0'                                               00634\n         MVC   PRINT+1(L'HEADER2),HEADER2                               00635\n         BAL   R10,PRINTIT                                              00636\n         LA    R3,TABLE           START OF TABLE                        00637\n         LA    R6,56              MAX LINES PER PAGE                    00638\nPRTN     EQU   *                                                        00639\n         MVC   PRINT+1(L'CURENTRY),0(R3)  GET START OF CDE TAB          00640\n         MVC   PRINT+60(L'CURENTRY),48(R3)  GET NEXT ENTRY              00641\n         BAL   R10,PRINTIT        GO PRINT TABLE                        00642\n         BCTR  R6,R0                                                    00643\n         LA    R3,96(,R3)         GET NEXT ENTRY                        00644\n         LTR   R6,R6                                                    00645\n         BNZ   NOHEADN                                                  00646\n         MVI   PRINT,C'1'                                               00647\n         MVC   PRINT+1(L'NUMHED),NUMHED                                 00648\n         MVI   PRINT,C'0'                                               00649\n         MVC   PRINT+1(L'HEADER2),HEADER2                               00650\n         BAL   R10,PRINTIT                                              00651\nNOHEADN  EQU   *                                                        00652\n         BCT   R4,PRTN            ARE WE DONE YET?                      00653\n         LA    R1,CLOSEL                                                00654\n         CLOSE RENTDCB,MF=(E,(1))                                       00655\n         LR    R2,R13             SAVE ADDRESS FOR FREEMAIN             00656\n         L     R13,4(,R13)        GET CALLERS SAVE AREA POINTER         00657\n         FREEMAIN RU,A=(R2),LV=LENGTH     FREE UP SAVEAREA              00658\n         LM    R14,R12,12(R13)    RELOAD CALLERS REGISTERS              00659\n         SLR   R15,R15            SET RETURN CODE OF ZERO               00660\n         BR    R14                RETURN TO CALLER                      00661\n         SPACE 3                                                        00662\nMLPALOAD EQU   *                                                        00663\n         TM    CDATTR,CDNIC       IS MODULE INPROCESS OF LOAD ?         00664\n         BO    NEXTCDE            YES GO GET ANOTHER ONE                00665\n         TM    CDATTR2,CDREL      IS MODULE INACTIVE ?                  00666\n         BO    NEXTCDE            YES GO GET ANOTHER                    00667\n         MVI   CURENTRY,C' '      CLEAR TO BLANKS                       00668\n         MVC   CURENTRY+1(L'CURENTRY-1),CURENTRY                        00669\n         MVC   BNAME(L'CDNAME),CDNAME THE CDE NAME                      00670\n         LA    R1,CDENTPT         GET THE MODULE ENTRY POINT            00671\n         LA    R10,BEPA           THIS IS HIS ENTRY POINT               00672\n         BAL   R14,UNPACK         MAKE IT READABLE                      00673\n         TM    CDATTR,CDMIN       IS IT A MINOR CDE ?                   00674\n         BO    MINORCDE           YES GO FIX HIM UP                     00675\n         ST    R2,R2SAVE          SAVE FOR LATER                        00676\nXLIST    EQU   *                                                        00677\n         L     R4,CDXLMJP         GET THE EXTENT LIST ADDR              00678\n         USING XTLST,R4           SET UP ADDR TO IT                     00679\n         LA    R1,XTLMSBLA        GET LENGTH                            00680\n         LA    R10,BLENGTH                                              00681\n         BAL   R14,UNPACK         MAKE IT READABLE                      00682\n         LA    R1,XTLMSBAA        GET MAIN STORAGE ADDRESS              00683\n         LA    R10,BLOCAT         WHERE IS HE IN STORAGE                00684\n         BAL   R14,UNPACK         MAKE IT READABLE                      00685\n         L     R1,ENTRIES         HOW MANY ENTRIES DO WE HAVE?          00686\n         LA    R1,1(,R1)          BUMP THE COUNTER                      00687\n         ST    R1,ENTRIES         SAVE THE NEW NUMBER                   00688\n         L     R1,CURRENT         SAVE CURRENT POINTER                  00689\n         MVC   0(L'CURENTRY,R1),CURENTRY  SAVE THE CONTENTS             00690\n         LA    R1,48(,R1)         BUMP BY THE LENGTH                    00691\n         ST    R1,CURRENT         SAVE THIS ENTRY                       00692\n         L     R2,R2SAVE          RELOAD REG 2                          00693\n         B     NEXTCDE            GO GET ANOTHER NAME                   00694\n         SPACE 3                                                        00695\nOPEN     OPEN  (SYSPRINT,(OUTPUT)),MF=L                                 00696\nCLOSE    CLOSE (SYSPRINT),MF=L                                          00697\nOPENLEN  EQU   *-OPEN                                                   00698\n         SPACE 3                                                        00699\nMINORCDE EQU   *                                                        00700\n         ST    R2,R2SAVE          WE NEED HIM LATER FOR CHAIN           00701\n         L     R2,CDXLMJP         GO GET HIS MAJOR CDE                  00702\n         MVC   BMAJOR(L'CDNAME),CDNAME GET THE MAJOR NAME               00703\n         B     XLIST                                                    00704\n         SPACE 3                                                        00705\nUNPACK   EQU   *                                                        00706\n         UNPK  ANSWER,0(5,R1)     PUT DATA INTO AN AREA TO WORK ON      00707\n         TR    ANSWER(8),TRANTAB  TURN IT INTO READABLE DATA            00708\n         MVC   2(6,R10),ANSWER+2  MOVE TO PRINT AREA                    00709\n         BR    R14                RETURN TO CALLER                      00710\n         SPACE 3                                                        00711\nPRINTIT  EQU   *                                                        00712\n         PUT   RENTDCB,PRINT                                            00713\n         MVI   PRINT,C' '         CLEAR THE PRINT LINE                  00714\n         MVC   PRINT+1(L'PRINT-1),PRINT                                 00715\n         BR    R10                                                      00716\n         PRINT NOGEN                                                    00717\n         SPACE 3                                                        00718\nSYSPRINT DCB   DDNAME=SYSPRINT,BLKSIZE=121,RECFM=FA,LRECL=121,    ******00719\n               DSORG=PS,MACRF=(PM)                                      00720\nDCBLEN   EQU   *-SYSPRINT                                               00721\nTRANTAB  EQU   *-240                                                    00722\n         DC    C'0123456789ABCDEF'                                      00723\n         LTORG                                                          00724\nALPHAHED DC    C'FIXED AND MODIFIED LINK PACK MAP - ALPHABETICALLY BY N*00725\n               AME'                                                     00726\nHEADER2  DC   C' NAME       LOCAT    LNGTH    ENTRY  MAJOR LPDE        *00727\n                    NAME       LOCAT    LNGTH    ENTRY   MAJOR LPDE'    00728\nNUMHED   DC   C'FIXED AND MODIFIED LINK PACK MAP - NUMERICALLY BY LOCAT*00729\n               ION'                                                     00730\n         SPACE 3                                                        00731\nSAVEAREA DSECT                                                          00732\n         DS    18F                                                      00733\nR2SAVE   DS    F                                                        00734\nENTRIES  DS    F                                                        00735\nPARM     DS    2F                                                       00736\nCURRENT  DS    F                                                        00737\nRENTDCB  DCB   DDNAME=SYSPRINT,BLKSIZE=121,RECFM=FA,LRECL=121,        **00738\n               DSORG=PS,MACRF=(PM)                                      00739\nPRINT    DS    CL121                                                    00740\nCURENTRY DS    0CL48                                                    00741\n         DS    C                                                        00742\nBNAME    DS    CL8                                                      00743\n         DS    C                                                        00744\nBLOCAT   DS    CL8                                                      00745\n         DS    C                                                        00746\nBLENGTH  DS    CL8                                                      00747\n         DS    C                                                        00748\nBEPA     DS    CL8                                                      00749\n         DS    C                                                        00750\nBMAJOR   DS    CL8                                                      00751\n         DS    CL3             FILL OUT TO 48 BYTES                     00752\nANSWER   DS    CL9                                                      00753\nOPENL    OPEN  SYSPRINT,MF=L                                            00754\nCLOSEL   CLOSE SYSPRINT,MF=L                                            00755\nTABLE    DS    12000F                                                   00756\n         DS    0D                                                       00757\nLENGTH   EQU   *-SAVEAREA                                               00758\n         DROP  R13                                                      00759\n         SPACE 3                                                        00760\n         IHAPSA                                                         00761\n         CVT   DSECT=YES                                                00762\n         IHACDE                                                         00763\n         IHAXTLST                                                       00764\n*  CREATE CSECT TO SORT LIST INTO ALPHAMERIC ORDER  ON MODULE NAME      00765\n     QKSRT1 ALPHA,C,LENGTH=48,STRTKY=2,KYLGTH=8                         00766\n*  CREATE CSECT TO SORT LIST INTO NUMERICAL ORDER ON ADDRESS            00767\n     QKSRT1 NUMER,C,LENGTH=48,STRTKY=12,KYLGTH=6                        00768\n         END                                                            00769\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "MODSCR3": {"ttr": 27656, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x00\\x7f\\x00\\x88\\x00\\x7f\\x12\\x00\\x01j\\x01j\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf2\\xf7\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-01-07T00:00:00", "modifydate": "1988-01-07T12:00:00", "lines": 362, "newlines": 362, "modlines": 0, "user": "FILE270"}, "text": "*          DATA SET 761KKMSCR3 AT LEVEL 001 AS OF 04/02/81\n         TITLE 'MODSCR3 - FULLSCR3 INTERFACE TO HANDLE MOD BLOCKS.'\n*\n*      PROGRAM MODSCR3 IS DESIGNED TO MAKE FULLSCREEN APPLICATIONS\n*  MORE EFFICIENT AND EASIER TO DEVELOP.\n*\n*   AUTHOR: KERMIT KISER - WASHINGTON STATE DP SERVICE CENTER (WDPSC).\n*          (206) 902-3119   ***  MODSCR3 VERSION 1.0 - OCTOBER 1980 ***\n*\n*  CALLING SEQUENCE :\n*\n*    CALL 'MODSCR3' USING (NORMAL FULLSCR3 PARMS), MOD1, MOD2,...MODN.\n*\n*     01 MOD1.\n*       02 FLAG1         PIC X  VAL=O MEANS R1 CONTAINS OFFSET ADDRESS\n*                               VAL=R MEANS R1 CONTAINS ROW OF ADDRESS\n*       02 FLAG2         PIC X  VAL=A MEANS MESSAGE BEGINS WITH ATTRIB\n*                               VAL=B MEANS ATTRIB AND MOVE CURSOR HERE\n*                               VAL=C MEANS MOVE CURSOR TO THIS FIELD\n*                               VAL=  MEANS NO ATTR AND NO CURSOR\n*       02 R1            PIC S9999 COMP VAL=ROW OR OFFSET  ADDRESS\n*       02 R2            PIC S9999 COMP VAL=COL OR ZERO OF ADDRESS\n*       02 LEN1          PIC S9999 COMP VAL=LENGTH OF MESSAGE\n*       02 MESS1         PIC X(LEN) DATA TO SEND TO 3270\n*\n*\n*********************************************************************\n*    THIS PROGRAM IS DEPENDENT ON TCAM BEING ASSEMBLED WITH THE     *\n*    'SPFSCRN' MACROS OR EQUIVALENT.                                *\n*********************************************************************\n         EJECT\nMODSCR3  ENTERR LEVEL=V1M0        R13 -> WORKAREA\n*                                 R12 -> ADDRESSABILITY\n         LR    R11,R1             R11->PARM LIST\n         ST    R11,FULLPARM\n         L     R10,0(,R11)        R10->IOPARM\n         SLR   R15,R15\n         EJECT\n*********************************************************************\n*        MAIN  PROCESSING CONTROL ROUTINE:                          *\n*********************************************************************\n         SPACE 2\n*\n*        COUNT THE INPUT PARMAMETERS GIVEN TO US:\n*\n         BAL   R14,PARMCHK              LOOK AT PARMS\n         LTR   R15,R15            RC = 0?  OK?\n         BNZ   GOUT               NO. -> GO TO FAST EXIT\n         SPACE 2\n*\n*              BUILD OUTBUFF FROM MODBLOCKS PROVIDED:\n*\n         TM    MF1,X'C0'                V3 TYPE WITH MODBLOCKS?\n         BNO   CFS3                     NO->IGNORE\n         BAL   R14,BLDBUFF              BUILD NEW OUTBUFF\n         LTR   R15,R15            RC = 0?  OK?\n         BNZ   GOUT               NO. -> GO TO FAST EXIT\n         SPACE 2\n*\n*              BUILD NEW FULLSCR3 PARM LIST WITH NEW OUTLEN,OUTBUFF:\n*\nNOBLD    BAL   R14,PARMBLD\n         LTR   R15,R15            RC = 0?  OK?\n         BNZ   GOUT               NO. -> GO TO FAST EXIT\n         SPACE 2\n*\n*              PROCEED WITH CALL TO FULLSCR3:\n*\nCFS3     L     R1,FULLPARM\n         CALL  FULLSCR3\n         SPACE 2\n*\n*              CLEANUP ANY LEFTOVERS:\n*\n         BAL   R14,CLEANUP\n         EJECT\n*\n*              NOW WE ARE ALL DONE:\n*\nGOUT     LEAVER\n         EJECT\nPARMCHK  ST    R14,L1LS\n*\n         CLI   0(R10),C'3'              V3 CALL?\n         BE    CP                       YES\n         CLI   0(R10),C'S'              V3 CALL?\n         BNE   PEX                      NO->IGNORE V2\nCP       OI    MF1,X'80'                FLAG V3 CALL\n         SPACE\n*                                       COUNT THE FULLSCR3 PARMS GIVEN:\n         SLR   R7,R7                    R7=0 INIT CNT\n         LA    R9,6                     MAX NORMAL PARMS\n         LA    R8,2(,R10)               R8->XES\nPPLOOP   CLI   0(R8),C' '               ONE THERE?\n         BE    NOCNT                    NO\n         LA    R7,1(,R7)                R7+1 COUNT\nNOCNT    LA    R8,1(,R8)                R8->NEXT X\n         BCT   R9,PPLOOP                MORE?\n         LA    R7,1(,R7)                R7+1 - COUNT IOPARM\n         STH   R7,PC1                   SAVE COUNT\n         SPACE\n*                                       COUNT MOD BLKS ALSO:\n         SLR   R9,R9\n         LA    R8,0(,R11)               R8->PARM1\nP2LOOP   TM    0(R8),X'80'              LAST ONE?\n         BO    CLP                      YES\n         LA    R8,4(,R8)                R8+4 = NEXT PARM\n         LA    R9,1(,R9)                R9+1 = COUNT IT\n         B     P2LOOP                   MORE?\nCLP      LA    R9,1(,R9)                R9+1 COUNT LAST ONE\n         STH   R9,PC2                   SAVE COUNT\n         SPACE\n         CH    R9,PC1                   GOOD COUNT?\n         BL    PERR                     NO\n         BE    PEX                      YES BUT NO MODBLKS\n         OI    MF1,X'40'                YES FLAG PRESENCE OF MODBLKS\n         B     PEX\n         SPACE\nPERR     LA    R15,99                   SAY BAD PARMS\nPEX      L     R14,L1LS\n         BR    R14\n         EJECT\n*\n*              SUBRTN TO BUILD NEW OUTBUFF FROM OLD AND MODBLOCKS:\n*\nBLDBUFF  ST    R14,L1LS\n         SPACE\n*              FIRST GET THE NEW OUTBUFF AREA:\n         LA    R0,4095                  R0=BUF LEN\n         GETMAIN R,LV=(0)              R1->NEW OUTBUFF\n         ST    R1,BUFADD                SAVE ADDR\n         LR    R9,R1                    R9->OUTBUFF\n         XC    BUFLEN,BUFLEN            SET LEN=0\n         SPACE\n*              NEXT MOVE ANY OLD-OUTBUFF INTO THE NEW OUTBUFF:\n         BAL   R14,SAVESCRN             MOVE ANY OLD-OUTBUFF\n         SPACE\n*              THEN ADD EACH MODBLOCK TO THE NEW OUTBUFF:\n         LH    R8,PC1                   R8=# OF FS3 PARMS\n         SLL   R8,2                     R8*4 = OFFSET TO MODS\n         LA    R8,0(R8,R11)             R8->FIRST MODBLK PTR\nMBLOOP   L     R7,0(,R8)                R7->NEXT MODBLK\n         BAL   R14,MOVEMOD              GET IT IN OUTBUFF\n         TM    0(R8),X'80'              LAST ONE?\n         BO    BEX                      YES -> DONE\n         LA    R8,4(,R8)                R8+4 - PT TO NEXT PARM\n         B     MBLOOP                   AGAIN\n         SPACE\nBEX      L     R14,L1LS\n         BR    R14\n         EJECT\nPARMBLD  ST    R14,L1LS\n         SPACE\n*              CHECK FOR OLD OUTLEN,OUTBUFF AND SKIP THEM:\n*\n         XC    MYPARMS,MYPARMS          CLEAR\n         LH    R8,PC1                   R8=FS3 PARM CNT\n         BCTR  R8,R0                    R8-1 SKIP IOPARM\n         LA    R9,4(,R11)               R9->SECOND PARM\n         CLI   2(R10),C' '              IS IT LEN?\n         BE    CFOB                     NO\n         BCTR  R8,R0                    YES SKIP\n         LA    R9,4(,R9)                PT PAST\nCFOB     CLI   3(R10),C' '              OUTBUFF THERE?\n         BE    ROPL                     NO\n         BCTR  R8,R0                    YES SKIP\n         LA    R9,4(,R9)                PT PAST\n         SPACE\n*              BUILD A NEW IOPARM AND POINT NEW PARM LIST THERE:\n*\nROPL     MVC   MIOPARM(8),0(R10)        MOVE IOPARM\n         MVC   MIOPARM+2(2),=C'XX'      FORCE OUTBUFF\n         LA    R2,MIOPARM               R2-> NEW IOPARM\n         ST    R2,MYPARMS               SAVE IN NEW PARM LIST\n         SPACE\n*              ADD THE NEW OUTLEN,OUTBUFF TO THE NEW PARM LIST:\n*\n         LA    R2,BUFLEN                R2->NEW OUTLEN\n         ST    R2,MYPARMS+4             SAVE IN PARMLIST\n         MVC   MYPARMS+8(4),BUFADD      NEW OUTBUFF\n         LTR   R8,R8                    ANY OTHERS\n         BNZ   MOP                      YES\n         OI    MYPARMS+8,X'80'          SAY LAST\n         SPACE\nPBEX     LA    R1,MYPARMS               R1->NEW PARMLIST\n         ST    R1,FULLPARM              SAVE PTR\n         L     R14,L1LS\n         BR    R14\n         SPACE\n*              ADD ANY OTHER OLD FULLSCR3 PARMS TO THE NEW PARM LIST:\n*\nMOP      LA    R7,MYPARMS+8             R7->FIRST EMPTY SLOT\nMOPL     LA    R7,4(,R7)                R7->NEXT SLOT\n         MVC   0(4,R7),0(R9)            PASS THE PARM\n         LA    R9,4(,R9)                NEXT PARM\n         BCT   R8,MOPL                  MORE?\n         OI    0(R7),X'80'              SAY LAST\n         B     PBEX\n         EJECT\n*\n*              SUBRTN TO FREE ANY LEFTOVER NEW OUTBUFF:\n*\nCLEANUP  ST    R14,L1LS\n         TM    MF1,X'40'                NEW OUTBUF BUILT?\n         BNOR  R14                      NO\n         LA    R0,4095                  R0=LEN\n         L     R1,BUFADD                R1->OUTBUF\n         FREEMAIN R,LV=(0),A=(1)        KILL IT\n         L     R14,L1LS\n         BR    R14\n         EJECT\nSAVESCRN ST    R14,L2LS\n         SPACE\n*              WAS AN OUTLEN,OUTBUFF COMBO PASSED?:\n*\n         CLI   2(R10),C' '              OUTLEN?\n         BE    IWCC                     NO\n         L     R7,4(,R11)               R7->OUTLEN\n         LH    R7,0(,R7)                R7=OUTBUFF LEN\n         STH   R7,BUFLEN                SAVE\n         CLI   3(R10),C' '              OUTBUFF\n         BNE   MTB                      YES\n         LA    R15,99                   BAD PARMS\n         B     SSX                      XIT\n         SPACE\n*              YES -> MOVE THE OUTBUFF PASSED INTO THE NEW OUTBUFF:\n*\nMTB      L     R6,8(,R11)               R6->OUTBUFF OLD\n         LR    R5,R7                    R5=MOVE LENGTH\n         LR    R4,R9                    R4->NEW OUTBUFF\n         MVCL  R4,R6                    MOVE OLD->NEW\n         LR    R9,R4                    R9->PAST DATA\n         SPACE\nSSX      L     R14,L2LS\n         BR    R14\n         SPACE\n*              NO  -> PUT A DEFAULT WRITE-CONTROL-CHAR IN NEW OUTBUFF:\n*                  ->  ALSO SPF CODE FOR AUTO RESHOW FEATURE:\n         SPACE\nIWCC     MVC   0(7,R9),=X'C3115D7F114040' INSERT DEFAULT WCC & SPF STR\n         LA    R9,7(,R9)                R9+7 - PT PAST\n         MVC   BUFLEN,=H'7'             SET INIT LEN TO 7\n         B     SSX\n         EJECT\n*\n*              SUBRTN TO ADD A MODBLOCK TO THE NEW OUTBUFF:\n*\nMOVEMOD  ST    R14,L2LS\n         SPACE\n*              IGNORE THE MODBLOCK IF NO DATA PRESENT:\n*\n         LH    R2,6(,R7)                R2=DATA LENGTH\n         LTR   R2,R2                    ANY?\n         BNZ   HASDATA                  YES\n         CLI   1(R7),C'B'               CURSOR MOVE?\n         BE    HASDATA                  YES\n         CLI   1(R7),C'C'               CURSOR MOVE?\n         BNER  R14                      NO\n         SPACE\n*              FIND THE 3270 ADDRESS NEEDED & PUT IN NEW OUTBUFF:\n*\nHASDATA  SLR   R4,R4\n         CLI   0(R7),C'R'               ROW,COL ADDR?\n         BE    RCFORM                   YES\n         LH    R5,2(,R7)                GET HIS OFFSET\n         B     OFFORM\nRCFORM   LH    R5,2(,R7)                GET HIS ROW\n         BCTR  R5,R0                    R5-1\n         MH    R5,=H'80'                R5*80\n         AH    R5,4(,R7)                R5+COL=OFFSET+1\n         BCTR  R5,R0                    R5-1=OFFSET ADDR\nOFFORM   D     R4,=F'64'          (R4,R5)/64 R4=REMAINDER,R5=QUOTIENT\n         N     R5,=X'0000003F'          JUST IN CASE\n         MVI   0(R9),X'11'              NEED SBA HERE\n         STC   R5,1(R9)                 PUT ROW IN WORKAREA\n         STC   R4,2(R9)                 PUT COL IN WORKAREA\n         TR    1(2,R9),TABLE1           CHANGE TO 3270 ADDRESS\n         LA    R9,3(,R9)                R9+3 PT PAST\n         LH    R6,BUFLEN                R6=CURRENT LENGTH\n         AH    R6,=H'3'                 R6+3 = NEW OUTBUFF LENGTH\n         EJECT\n*\n*              NEXT FIND THE OUTPUT DATA:\n*\n         LA    R4,8(,R7)                R4->DATA\n         LH    R5,6(,R7)                R5=DATA LEN\n         SPACE\n*\n*              PUT IN A START-FIELD ORDER IF REQUESTED:\n*\n         CLI   1(R7),C'A'               ATTR PRESENT?\n         BE    DOSF                     YES\n         CLI   1(R7),C'B'               ATTR PRESENT?\n         BNE   CFIC                     NO\nDOSF     LTR   R5,R5                    R5=0? AT LEAST ONE DATA BYTE?\n         BZ    CFIC                     NO\n         MVI   0(R9),X'1D'              PUT SF IN OUTBUFF\n         MVC   1(1,R9),0(R4)            TACK ON THE ATTR CHAR\n         LA    R4,1(,R4)                R4+1 -> NEXT DATA BYTE\n         BCTR  R5,R0                    R5-1 = NEW DATA LEN\n         LA    R9,2(,R9)                R9+2 PP\n         LA    R6,2(,R6)                R6+2 INCR LEN\n         SPACE\n*              CHECK FOR INSERT CURSOR REQUEST:\n*\nCFIC     CLI   1(R7),C'C'               MOVE CURSOR?\n         BE    DOIC                     YES\n         CLI   1(R7),C'B'               MOVE CURSOR?\n         BNE   MTD                      NO\nDOIC     MVI   0(R9),X'13'              PUT IN IC CHAR\n         LA    R9,1(R9)                 R9+1 -> NEXT FREE BYTE\n         LA    R6,1(R6)                 R6+1 = NEW OUTPUT LENGTH\n         SPACE\n*              FINALLY WE CAN MOVE IN THE NEW DATA:\n*\nMTD      LTR   R5,R5                    R5=0? ANY DATA LEFT TO MOVE?\n         BZ    MMX                      NO->EXIT NOW\n         LR    R1,R5                    R1=R5 SAVE THE LENGTH\n         LR    R2,R9                    R2->BUFF LOC\n         LR    R3,R5                    R3=DATA LEN\n         MVCL  R2,R4                    MOVE THE DATA\n         LR    R9,R2                    R9= UPDATED BUFF LOC\n         AR    R6,R1                    R6+R1=NEW OUTPUT LENGTH\n         SPACE\nMMX      STH   R6,BUFLEN                SAVE THE OUTPUT LENGTH\n         L     R14,L2LS\n         BR    R14\n         EJECT\n*\n*        STATIC WORKAREA:\n*\nTABLE1   DC    C' ABCDEFGHI\u00a2.<(+|&&JKLMNOPQR!$*);\u00ac'\n         DC    C'-/STUVWXYZ ,%_>?0123456789:#@''=\"'\n         ORG   TABLE1+X'2A'\n         DC    X'6A'\n         ORG\n*\n*\n         LTORG\n         EJECT\n*\n*   WORKING STORAGE AREA - DYNAMIC:\n*\nWORKAREA DSECT\nSAVEAREA DS    18F\nL1LS     DS    F\nL2LS     DS    F\nL3LS     DS    F\n*\nPC1      DS    H\nPC2      DS    H\nMF1      DS    X\n*\nBUFADD   DS    F\nBUFLEN   DS    H\n*\nFULLPARM DS    F\nMYPARMS  DS    10F\nMIOPARM  DS    D\nCLL      DS    0X\nWORKLEN  EQU   *-WORKAREA\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "MODTEST": {"ttr": 27909, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x00\\x7f\\x00\\x88\\x00\\x7f\\x12\\x00\\x00\\xae\\x00\\xae\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf2\\xf7\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-01-07T00:00:00", "modifydate": "1988-01-07T12:00:00", "lines": 174, "newlines": 174, "modlines": 0, "user": "FILE270"}, "text": "*          DATA SET 761KKMODT  AT LEVEL 001 AS OF 04/02/81\n         TITLE 'MODTEST - PROGRAM TO TEST MODSCR3 SUBROUTINE'\nMODTEST  ENTERR LEVEL=V1M0\n         LR    R11,R1                   R11 -> PARMAREA\n         LA    R4,4095(,R13)\n         USING WORKAREA+4095,R4\n         EJECT\n**********************************************************************\n*       MAINLINE PROCESSING CONTROL ROUTINE:                         *\n**********************************************************************\n*\n*              FIRST STEP IS GET MENU AND MOD NAMES:\n*\nB4       BAL   R14,PP                   SCAN PARMS\n*\n*              NEXT GET MENUS:\n*\n         BAL   R14,GETMENU              GET THE MENU\n*\n*              THEN GET ANY MODS:\n*\n         BAL   R14,GETMODS              GET THE MODBLKS\n*\n*              NOW BUILD A MODSCR3 PARM LIST:\n*\n         BAL   R14,BLDPARM              BLD PARMLIST\n*\n*              FINALLY DO THE MODSCR3 CALL:\n*\n         BAL   R14,MODCALL              CALL MODSCR3\n         EJECT\nTERM     LEAVER\n         EJECT\n*\n*        PP -  SCAN THE PARMS FOR MENU  NAME AND MODBLKS NAME:\n*\nPP       ST    R14,L1LS\n*\n         L     R2,0(,R11)               R2->PARMS\n         LH    R10,0(,R2)               R10==PARM LEN\n         LA    R9,2(,R2)                R9->PARMS\n         MVC   MENUNAME(8),=CL8'X'      INIT\n         MVC   MODNAME(8),=CL8'X'       INIT\nLL1      CLI   0(R9),C' '               BLANK?\n         BNE   GOP1                     NO->GOT OP 1\n         LA    R9,1(,R9)                R9->NEXT BYTE\n         BCT   R10,LL1                  MORE?\n         B     PPX                      NO\nGOP1     LA    R8,MENUNAME              R8->SAVE AREA\nLL2      CLI   0(R9),C' '               BLANK?\n         BE    LFM                      YES->LOOK FOR MOD NAME\n         MVC   0(1,R8),0(R9)            NO->SAVE IT\n         LA    R8,1(,R8)                R8+1 PT PAST\n         LA    R9,1(,R9)                R9+1 PT PAST\n         BCT   R10,LL2                  MORE?\n         B     PPX                      NO\nLFM      CLI   0(R9),C' '               BLNAK?\n         BNE   GOP2                     NO->GOT PARM 2\n         LA    R9,1(,R9)                R9+1\n         BCT   R10,LFM                  MORE?\n         B     PPX                      NO\nGOP2     LA    R8,MODNAME               R8->SAVE AREA\nLL3      CLI   0(R9),C' '               BLANK?\n         BE    PPX                      YES->MUST BE DONE\n         MVC   0(1,R8),0(R9)            NO->SAVE IT\n         LA    R8,1(,R8)                R8+1 PT PAST\n         LA    R9,1(,R9)                R9+1 PT PAST\n         BCT   R10,LL2                  MORE?\n*\n*\nPPX      L     R14,L1LS\n         BR    R14\n         EJECT\n*\n*        GETMENU - USE SUBRTN GETSCRN  TO LOAD THE 'PANEL' :\n*\nGETMENU  ST    R14,L1LS\n*\n         CALL  GETSCRN,(=CL8'MENULIB',MENUNAME,MENLEN,MENUAREA),VL,  XXX\n               MF=(E,CALLPL)\n*\nGMX      SLR   R15,R15                  RC=0\n         L     R14,L1LS\n         BR    R14\n         EJECT\n*\n*        GETMODS - USE SUBRTN GETSCRN  TO LOAD THE MODBLKS :\n*\nGETMODS  ST    R14,L1LS\n*\n         CALL  GETSCRN,(=CL8'MODLIB',MODNAME,MODLEN,MODAREA),VL,     XXX\n               MF=(E,CALLPL)\n*\nGMDX     SLR   R15,R15                  RC=0\n         L     R14,L1LS\n         BR    R14\n         EJECT\n*\n*        BLDPARM  - CONSTRUCT A PARMLIST FOR MODSCR3 :\n*\nBLDPARM  ST    R14,L1LS\n*                                       FULLSCR3 STUFF FIRST:\n         LA    R1,IOPARM                IOPARM\n         ST    R1,MODPARM\n         LA    R1,MENLEN                OUTLEN\n         ST    R1,MODPARM+4\n         LA    R1,MENUAREA              OUTBUFF\n         ST    R1,MODPARM+8\n         MVC   INLEN(2),=H'3000'        INLEN\n         LA    R1,INLEN\n         ST    R1,MODPARM+12\n         LA    R1,INBUFF                INBUFF\n         ST    R1,MODPARM+16\n         LA    R1,RETLEN                RETLEN\n         ST    R1,MODPARM+20\n         LA    R1,SCRUFF                SCRUFF\n         ST    R1,MODPARM+24\n         SPACE 2\n*                                       NOW THE MODBLKS:\n         LA    R10,MODPARM+24\n         LA    R9,MODAREA\nMPL      CLC   0(4,R9),=F'0'            ANY?\n         BE    FLGEND                   NO\n         MVC   4(4,R10),0(R9)           YES->PASS IT\n         LA    R10,4(,R10)              R10->PARM JUST MOVED\n         TM    0(R9),X'80'              LAST ONE?\n         BO    FLGEND                   YES\n         LA    R9,4(,R9)                R9->NEXT BLK PTR\n         B     MPL                      GO CHK IT\nFLGEND   OI    0(R10),X'80'             MAKE SURE LAST FLG ON\n*\nBLDX     L     R14,L1LS\n         BR    R14\n         EJECT\n*\n*        MODCALL - INVOKE THE MODSCR3 SUBRTN TO DO THE SCREEN IO:\n*\nMODCALL  ST    R14,L1LS\n*\n         LA    R1,MODPARM\n         CALL  MODSCR3\n*\nMCX      L     R14,L1LS\n         BR    R14\n         EJECT\nSTATWORK EQU   *\n*\nIOPARM   DC    CL8'SBXXXXXB'\n         LTORG\n         EJECT\nWORKAREA DSECT\nSAVEAREA DS    18F\nL1LS     DS    F\nL2LS     DS    F\nL3LS     DS    F\nDDN      DS    D\n*\nCALLPL   CALL  ,(DDN,MENUNAME,MENLEN,MENUAREA),VL,MF=L\n*\nMODPARM  DS    20F\n*\nMENUNAME DS    D\nMENLEN   DS    H\nMENUAREA DS    XL3000\nMODNAME  DS    D\nMODLEN   DS    H\nMODAREA  DS    XL1000\nINLEN    DS    H                                                  WDPSC\nINBUFF   DS    XL3000\nRETLEN   DS    H                                                  WDPSC\nSCRUFF   DS    XL2000\n*\nWORKLEN  EQU   *-WORKAREA\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "MSGS": {"ttr": 27913, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x00\\x7f\\x00\\x88\\x00\\x7f\\x12\\x00\\x00\\x86\\x00\\x86\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf2\\xf7\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-01-07T00:00:00", "modifydate": "1988-01-07T12:00:00", "lines": 134, "newlines": 134, "modlines": 0, "user": "FILE270"}, "text": "./ ADD NAME=FNDS10   0101-84237-86069-0918-00006-00004-00000-JS02150\nFNDS100 ' '\n\nFNDS101 'Invalid selection code'\n'The only valid selection codes are E for EDIT and B for BROWSE'\nFNDS102 'Member is empty '\n'An empty PDS member can not be browsed.'\n./ ADD NAME=GPM00    0101-83314-83314-1159-00036-00015-00000-KK00150\nGPM001 '&GPM'\n'&GPML'\n\nGPM001A '&GPM' .ALARM=YES\n'&GPML'\n\nGPM002\n'&GPML'\n\nGPM002A        .ALARM=YES\n'&GPML'\n\nGPM003 '&GPM' .HELP=&HELP\n'&GPML'\n\nGPM003A '&GPM' .HELP=&HELP .ALARM=YES\n'&GPML'\n\nGPM004         .HELP=&HELP\n'&GPML'\n\nGPM004A        .HELP=&HELP .ALARM=YES\n'&GPML'\n\nGPM005 '&GPM' .HELP=&HELP .ALARM=&ALARM\n'&GPML'\n\nGPM006         .HELP=&HELP .ALARM=&ALARM\n'&GPML'\n\nGPM007 '&GPM'              .ALARM=&ALARM\n'&GPML'\n\nGPM008                     .ALARM=&ALARM\n'&GPML'\n\n./ ADD NAME=SPFNV00  0100-83259-83259-1138-00003-00003-00000-KK00150\nSPFNV001 'ENTER AN OPTION'            .HELP=SPFCATH1  .ALARM=YES\n'YOU MUST ENTER AT LEAST ONE CATLOG OPTION.'\n\n./ ADD NAME=SPFY10   0101-84333-84334-1027-00010-00010-00000-JS02150\nSPFY100 ' '\n' '\nSPFY101 'INVALID DATASET NAME'\n\nSPFY102 '&OUTMSG'\n\nSPFY103 'DATASET NOT PARTITIONED'\n\nSPFY104 'MEM NAME NOT ALLOWED'\n\n./ ADD NAME=TBLH10   0101-83327-83332-1153-00004-00004-00000-JS02150\nTBLH100 ' '\n\nTBLH101 'Invalid action code'\n'Enter I (for index), S (for select), or P (for print)'\n./ ADD NAME=TRIK10   0117-83313-85050-0908-00020-00020-00000-JS02150\nTRIK100 'Whats your name ? '\n\nTRIK101 'Whats your phone # ?'\n\nTRIK102 'Who are you ?'\n\nTRIK103 'The upper right corner'\n\nTRIK104 'Open the Pod door HAL'\n\nTRIK105 'Where are you ?'\n\nTRIK106 'Why is there air ?'\n\nTRIK107 'Are we there yet ?'\n\nTRIK108 'Whats a computer ?'\n\nTRIK109 'I wanna watch MTV !!'\n\n./ ADD NAME=WDED10   0119-82111-85113-0829-00028-00018-00000-JS02150\nWDED100\n'INVALID DATASET NAME -- EXCEEDS 44 BYTES WHEN PREFIX APPENDED'\nWDED101 '&GENERMSG'\n\nWDED102 'LRECL GREATER THAN 255'\n'CANNOT EDIT A DATASET WITH LRECL GREATER THAN 255'\nWDED103 'RECFM = U'\n'CANNOT EDIT A DATASET WITH UNDEFINED RECORDS'\nWDED104 'INVALID DSORG'\n\nWDED105 'WHAR IS MY DATASET NAME?'\n\nWDED106 'INVALID SELECTION CODE '\n\nWDED107 'DATASET IS SEQUENTIAL'\n'MEMBER NAME NOT ALLOWED WHEN SELECTING A SEQUENTIAL DATASET'\nWDED108\n'DO NOT SPECIFY MEMBER NAME IN MORE THAN ONE PLACE '\nWDED109\n'WHEN USING THIS FUNCTION, DO NOT PROVIDE MEMBER NAME AS PART OF THE DSNAME'\nWDED109A\n'MISSING SEARCH STRING'\nWDED109B\n'THIS FUNCTION IS USED TO SEARCH PARTITIONED DATASETS ONLY'\nWDED109C\n'SPECIFIED STRING NOT FOUND IN ANY MEMBERS'\nWDED109D\n'CANNOT SEARCH LIBRARIES HAVING MORE THAN 2500 MEMBERS'\n./ ADD NAME=XDIR10   0103-83293-83293-1310-00019-00012-00000-JS02150\nXDIR100 ' '\n' '\nXDIR101 'INVALID DATASET NAME'\n\nXDIR102 '&OUTMSG'\n\nXDIR103 'DATASET NOT PARTITIONED'\n\nXDIR104\n'DO NOT PROVIDE MEMBER NAME'\n\nXDIR105\n'DIRECTORY ADD AMOUNT CAN NOT BE ZERO'\n\nXDIR106 'SUCCESSFUL COMPLETION'\n\nXDIR107 'ERROR IN SSP95DIR'\n'PLEASE CALL CUSTOMER TECHNICAL SUPPORT IF THIS ERROR OCCURS'\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "NEWISPF": {"ttr": 27916, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x00\\x7f\\x00\\x88\\x00\\x7f\\x12\\x00\\x00\\xf3\\x00\\xf3\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf2\\xf7\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-01-07T00:00:00", "modifydate": "1988-01-07T12:00:00", "lines": 243, "newlines": 243, "modlines": 0, "user": "FILE270"}, "text": "NEWISPF  TITLE 'ISPF AND PDF FRONTEND MODULE'\nNEWISPF  ENTERR LEVEL=V1M3\n         EJECT\n*\n* V1M3 - SWITCH TO STACK MACRO TO FIX PROBLEM WITH TSOE STACK FORMAT,\n*         ALLOW LOAD,CALL TO ISRPCP TO ELIMINATE LINK REQUIREMENT\n*\n* V1M2 - ALLOWED SPFMVS/ISPF SWITCHING BY CHECKING ISPTLIB AND ISPPARM\n*\n* V1M1 - ALLOC USER PROFILE, CALL NEWSPF CLIST IF NEW\n*\n* V1M0 - HAD SAVE ECT ONLY\n*\n*        THIS MODULE IS THE FRONTEND FOR ISPF AND/OR PDF.\n*         IT HAS THE FOLLOWING FUNCTIONS:\n*            1. SAVE THE INPUT ECT BECAUSE ISPF MODIFIES THE\n*               ECT PTR TO THE IOWA WHICH IS NEEDED BY THE XS MODULE.\n*            2. ALLOCATE THE USER PROFILE LIB TO DDNAME ISPPROF.\n*            3. INVOKE THE NEWSPF CLIST IF PROFILE LIB DOESN'T EXIST.\n*            4. CALL THE REAL ISPF OR PDF COMMAND MODULE.\n         EJECT\n*\n* NEWISPF MAINLINE ROUTINE CALLS EACH FUNCTION OF THIS MODULE\n*\n         BAL   R14,SAVEECT        1ST SAVE ECT\n*\n         BAL   R14,ALOCPROF       2ND ALLOC HIS PROFILE\n*\n         BAL   R14,XCLIST         3RD STACK NEWSPF CLIST IF NEEDED\n         BXH   R15,R15,EXIT       IF NEWSPF STACKED, SKIP ISPF\n*\n         BAL   R14,CALLISPF     4TH FINALLY READY TO CALL REAL ISPF/PDF\n         EJECT\n*\n*\n*    DONE HERE -> RETURN TO TERMINAL MONITOR OR WHOEVER CALLED:\n*\nEXIT     LEAVER\n         EJECT\n*\n*        1ST:  COPY THE CPPL AND THE ECT:\n*        (BECAUSE NASTY ISPF MODIFIES THE ECT IOWA PTR)\n*\nSAVEECT  ST    R14,L1LS\n         LR    R11,R1             SAVE PARM PTR\n         MVC   NEWCPPL(16),0(R11) COPY THE CPPL\n         LA    R10,NEWCPPL        R10->OUR COPY OF THE CPPL\n         USING CPPL,R10           MENTION TO ASSEMBLER\n         L     R8,CPPLECT         R8->ORIGINAL ECT\n         MVC   NEWECT(56),0(R8)   COPY THE ECT\n         LA    R9,NEWECT          R9->OUR COPY OF THE ECT\n         ST    R9,CPPLECT         POINT NEW CPPL TO NEW ECT!\n         MVC   CHEKWORD,=CL8'NEWISPF' THIS TELLS WDPSCXS WE ARE HERE\n         L     R14,L1LS\n         BR    R14\n         EJECT\n*\n*        2ND:  SEE IF DDNAME ISPPROF IS PRESENT AND TRY TO ALLOCATE\n*              IT IF IT IS NOT.\nALOCPROF ST    R14,L1LS\n         DEVTYPE =CL8'ISPPROF',DEVTAREA\n         BXLE  R15,R15,AX0        GO TO ISPF IF ISPPROF ALREADY HERE\n         OI    WASPROF,X'FF'      FLAG ISPPROF ABSENT\n         SPACE\n*        ISPPROF NOT ALLOCATED:BUILD DSN FOR DYNALLOC:\n         L     R9,CPPLUPT         R9->UPT\n         USING UPT,R9\n         L     R8,CPPLPSCB        R8->PSCB\n         USING PSCB,R8\n         LA    R1,PRODSN          R1->PROFILE DSN AREA\n         MVI   0(R1),C' '         A BLANK\n         MVC   1(43,R1),0(R1)     SPREAD IT AROUND\n         MVC   PRODSN(7),UPTPREFX MOVE DSN PREFIX\n         BAL   R14,FINDBLNK       FIND FIRST BLANK\n         MVI   0(R1),C'.'         PERIOD\n         LA    R1,1(,R1)          R1+1\n         CLC   UPTPREFL,PSCBUSRL PREFIX LEN=USERID LEN?\n         BNE   ADDUID             NOPE.\n         SLR   R2,R2              R2=0\n         IC    R2,UPTPREFL        R2=PREFIX LEN\n         BCTR  R2,R0              R2-1 FOR EX\nPUIDCLC  CLC   PSCBUSER(0),UPTPREFX FOR EX\n         EX    R2,PUIDCLC         UID=PREF?\n         BE    ATRAIL             YEP.\nADDUID   MVC   0(7,R1),PSCBUSER   ADD THE USERID\n         BAL   R14,FINDBLNK       POINT PAST\n         MVI   0(R1),C'.'         DOT\n         LA    R1,1(,R1)          R1+1\nATRAIL   MVC   0(12,R1),=C'ISPF.ISPPROF' TRAILING QUALIFIERS\n         BAL   R14,FINDBLNK       R1->END+1 OF DSN\n         LA    R2,PRODSN          R2->START OF DSN\n         SR    R1,R2              R1=DSN LEN\n         STH   R1,PRODSNL         SAVE THE LEN\n         B     TRYALLOC           GO ALLOC IT\n         SPACE\nFINDBLNK CLI   0(R1),C' '         BLANK?\n         BER   R14                YEP.\n         LA    R1,1(,R1)          R1+1\n         B     FINDBLNK           TRY NEXT\n         EJECT\n*        ISPPROF DSN BUILD, NOW ISSUE DYNALLOC REQUEST\n*\nTRYALLOC DYNABLK 3,MF=(E,DYNAPARM)   INIT DYNALLOC PARMLIST\n         DDNTU ISPPROF,7,MF=(E,DYNATU1)  INIT DDN TEXT UNIT\n         DSNTU PRODSN,PRODSNL,MF=(E,DYNATU2) INIT DSN TEXT UNIT\n         DSPTU SHR,MF=(E,DYNATU3) INIT DISP TEXT UNIT\n         LA    R1,DYNAPARM        R1->DYNALLOC PARM LIST\n         DYNALLOC                 ALLOC HIS PROFILE LIB IF IT EXISTS\n         SPACE\nAX0      L     R14,L1LS\n         BR    R14\n         EJECT\n*\n*        3RD:  IF THE USER DOES NOT HAVE A PROFILE LIBRARY,\n*              WE WILL TRANSFER CONTROL TO A CLIST NAMED 'NEWSPF'\n*\n*    OBTAIN THE COMMAND AREA AND COPY THE COMMAND IN:\n*\nXCLIST   ST    R14,L1LS\n         DEVTYPE =CL8'ISPPROF',DEVTAREA\n         BXH   R15,R15,DONEW      DO NEWSPF IF ISPPROF NOT HERE:\n         DEVTYPE =CL8'ISPTLIB',DEVTAREA\n         BXH   R15,R15,DONEW      DO NEWSPF IF ISPTLIB NOT HERE:\n         DEVTYPE =CL8'ISPPARM',DEVTAREA\n         BXH   R15,R15,SX0        SKIP IF ISPPARM NOT HERE:\n         TM    WASPROF,X'FF'      WAS ISPPROF ALREADY ALLOCATED\n         BZ    XX0                NEWSPF DONE IF ISPPROF WAS THERE\n         SPACE\nDONEW    LA    R3,CMDAREA0        R3->SP=0 CMD BLD AREA\n         LA    R2,SETCMD          R2->NEWSPF SETUP CMD\n         BAL   R14,GETCMD         MOVE THE CMD\n         L     R2,CPPLCBUF        R2->USERS CMD\n         XC    2(2,R2),2(R2)      RESET OFFSET TO 0\n         BAL   R14,GETCMD         MOVE THE CMD\n         DEVTYPE =CL8'ISPPARM',DEVTAREA\n         BXH   R15,R15,GET78      SKIP CLEANUP IF SPFMVS NOT PRODUCTION\n         LA    R2,CLEANCMD        R2->NEWSPF CLEANUP CMD\n         BAL   R14,GETCMD         MOVE THE CMD\n         B     GET78              GO GET 78 AREA\n         SPACE\nGETCMD   LH    R15,0(,R2)         R15=CMD LENGTH\n         BCTR  R15,R0             R15-1 FOR EXEC\n         EX    R15,MCMD1          MOVE THE CMD BUF\nMCMD1    MVC   0(0,R3),0(R2)      FOR EXEC\n         AH    R3,0(,R2)          R3->NEXT FREE AREA\n         BR    R14\n         SPACE\nSETCMD   DC    H'16',H'0',CL12'NEWSPF SETUP'   CMD BUF\n         SPACE\nCLEANCMD DC    H'18',H'0',CL14'NEWSPF CLEANUP'   CMD BUF\n         SPACE\nGET78    LA    R1,CMDAREA0        R1->1ST CMD\n         SR    R3,R1              R3=LENGTH OF ALL CMDS\n         LA    R0,16(,R3)         R0=CMD LENGTHS+LSD LEN\n         O     R0,=X'4E000000'    SUBPOOL=78\n         GETMAIN R,LV=(0)         ASK SYSTEM FOR IT\n         LR    R5,R1              R5 -> LSD AREA\n         USING LSD,R5             TELL ASSEMBLER WE HAVE IT\n         SPACE\n         MOVE  COMMANDS,0(R3),CMDAREA0  MOVE CMDS TO SP=78 AREA\n         STH   R3,LSDTOTLN        PASS THE CMD AREA LENGTH\n         EJECT\n*\n*    BUILD THE LSD DESCRIBING THE COMMAND:\n*\nLSDINIT  LA    R4,COMMANDS        R4 -> COMMANDS\n         ST    R4,LSDADATA        SAVE IT\n         ST    R4,LSDANEXT        \"\n         MVC   LSDRCLEN,=H'0'     RECLEN=0->FORMAT V RECORDS\n*\n*    NOW THAT  WE HAVE BUILT IT,LETS PUT IT ON THE STACK\n*\n         L     R7,CPPLECT         R7->ECT!\n         LA    R6,ECB             R6 -> ECB        BLOCK.\n*\n         STACK PARM=STACKL,UPT=(R9),ECT=(R7),ECB=(R6),             XXXXX\n               STORAGE=LSD,MF=(E,IOPL)\n         SPACE\n         LA    R15,4              RC=4->SKIP ISPF/PDF CALL\n         B     XX0\nSX0      SLR   R15,R15            RC=0\nXX0      L     R14,L1LS\n         BR    R14\n         EJECT\n*        4TH:  NOW FIND THE REAL  ISPF OR PDF GUY AND CALL HIM:\n*\nCALLISPF ST    R14,L1LS\n         WXTRN ISRPCP,ISPICP\n         L     R15,=A(ISRPCP)\n         LTR   R15,R15            PDF?\n         BNZ   CALLHIM            YEP\n         L     R15,=A(ISPICP)     ISPF?\n         LTR   R15,R15            ISPF?\n*V1M3    BZ    EXIT               NOPE...?!\n         BNZ   CALLHIM                                  V1M3\n         LOAD  EP=ISRPCP,SF=(E,LL)                      V1M3\n         LR    R15,R0             R15->ISPF/PDF         V1M3\nCALLHIM  LR    R1,R11             R1->ORIGINAL PARM LIST\n         BALR  R14,R15            CALL ISPF GUY\n         L     R14,L1LS\n         BR    R14\n         EJECT\n*\n*    CONSTANTS AND WORKAREAS\n*\n         LTORG\n         SPACE 3\nWORKAREA DSECT\nSAVEAREA DS    18F                SAVEAREA\nCHEKWORD DS    CL8                COMPARE STRING\nNEWCPPL  DS    4F                 SAVE CPPL\nNEWECT   DS    0D                 SAVE ECT\n         DS    XL64\nL1LS     DS    F\nL2LS     DS    F\nL3LS     DS    F\n         SPACE\nDEVTAREA DS    6F\nWASPROF  DS    H\nPRODSN   DS    CL44\nPRODSNL  DS    H\nLL       LOAD  SF=L               V1M3\n         SPACE\nDYNAPARM DYNABLK 3,MF=L\nDYNATU1  DDNTU ISPPROF,7,MF=L     DDN TEXT UNIT\nDYNATU2  DSNTU PRODSN,44,MF=L     DSN TEXT UNIT\nDYNATU3  DSPTU SHR,MF=L           DISP TEXT UNIT\n         SPACE\nCMDAREA0 DS    CL500              COMMANDS\n         SPACE\nIOPL     DS    4F                 IOPL\nECB      DS    F                  ECB\nSTACKL   STACK MF=L               STACK LIST\nWORKLEN  EQU   *-WORKAREA\n         EJECT\n         IKJCPPL\n         IKJECT\n         IKJUPT\n         IKJPSCB\n         EJECT\nLSD      IKJLSD                   LSD\nCOMMANDS DS    0H                 COMMAND AREA SP=78\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "NEWMWILE": {"ttr": 28164, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x00\\x7f\\x00\\x88\\x00\\x7f\\x12\\x00\\x00\\x81\\x00\\x81\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf2\\xf7\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-01-07T00:00:00", "modifydate": "1988-01-07T12:00:00", "lines": 129, "newlines": 129, "modlines": 0, "user": "FILE270"}, "text": "*\n*  4/4/86 - MODIFIED (V2M4) TO DO A WAIT AFTER ATTACH\n*\nNEWMWILE ENTERR LEVEL=V2M4\n         EJECT\n         LR    R11,R1                   R11-> PARM LIST\n         L     R10,0(,R11)              R10-> PARM FIELD\n         SLR   R9,R9                    R9 = 0\n         SLR   R8,R8                    R8 = 0\n         IC    R9,2(,R10)               R9 = CALL TYPE (0,1,2)\n         IC    R8,TT-240(R9)            R8 = BRANCH TAB OFFSET\n         B     BTAB(R8)                 PICK AN ENTRY POINT\n         SPACE 3\nBTAB     B     E0                       BTAB = BRANCH TABLE\n         B     E1\n         B     E2\n         SPACE 3\nRET      LEAVER\n         EJECT\nE1       LOAD  EP=ITCOMA1               R0-> INTER TASK COM AREA 1\n         SPACE\n         LR    R7,R0                   R7-> \"                     WDPSC\n         LA    R6,4                    MAX 4 COPIES RUNNING        *KK*\n         LA    R5,16(,R7)              R5->START OF TCB TABLE      *KK*\nE1L1     CLC   0(4,R5),540(0)          IS OUR TCB?                 *KK*\n         BNE   CNS                     NOPE -> TRY NEXT            *KK*\n         L     R2,4(,R5)             R2-> SUB TCB               WDPSC\n         USING TCB,R2                                           WDPSC\n         CLC   0(4,R5),TCBOTC        OURS?                      WDPSC\n         DROP  R2                                               WDPSC\n         BE    RET                   YUP=QUIT WHILE WE ARE AHEADWDPSC\n         B     E1ATT                 REUSE IT                   WDPSC\nCNS      LA    R5,8(,R5)               R5->NEXT TABLE SLOT         *KK*\n         BCT   R6,E1L1                 GO CHECK IT                 *KK*\n         LA    R6,4                    MAX 4 COPIES RUNNING        *KK*\n         LA    R5,16(,R7)              R5->START OF TCB TABLE      *KK*\nE1L2     CLC   0(4,R5),=F'0'           IS EMPTY SLOT?              *KK*\n         BE    E1ATT                   NO->WE CAN USE IT THEN      *KK*\n         LA    R5,8(,R5)               R5->NEXT TABLE SLOT         *KK*\n         BCT   R6,E1L2                 GO CHECK IT                 *KK*\n         B     RET                     NO ROOM IN TABLE           WDPSC\n         EJECT                                                     *KK*\nE1ATT    LA    R1,PARML                 R1 -> PARM LIST\n         LA    R2,CT0                                            V2M4\n         ST    R2,PARML                                          V2M4\n         LA    R2,MYECB                                          V2M4\n         ST    R2,PARML+4                                        V2M4\n         OI    PARML+4,X'80'                                     V2M4\n         XC    MYECB,MYECB                                       V2M4\n         SPACE\n         ATTACH EP=NEWMWILE\n         SPACE\n         ST    R1,4(,R5)                SAVE SUBTASK ADDR\n         MVC   0(4,R5),540(0)           SAVE OUR TCB ADDR          *KK*\n         WAIT  ECB=MYECB                                         V2M4\n         B     RET                      GET OUT\n         EJECT\nE2       LOAD  EP=ITCOMA1               R0-> INTER TASK COM AREA 1\n         SPACE\n         LR    R7,R0                   R7-> \"                     WDPSC\n         LA    R6,4                    MAX 4 COPIES RUNNING        *KK*\n         LA    R5,16(,R7)              R5->START OF TCB TABLE      *KK*\nE2L1     CLC   0(4,R5),540(0)          IS OUR TCB?                 *KK*\n         BE    E2DET                   WE ARE         ACTIVE!      *KK*\n         LA    R5,8(,R5)               R5->NEXT TABLE SLOT         *KK*\n         BCT   R6,E2L1                 GO CHECK IT                 *KK*\n         B     RET                     NOT ACTIVE\nE2DET    LA    R1,4(,R5)               R1->TCB ADDR               WDPSC\n         SPACE\n         L     R2,0(,R1)             R2->SUB TCB                WDPSC\n         USING TCB,R2                                           WDPSC\n         CLC   0(4,R5),TCBOTC        OURS?                      WDPSC\n         DROP  R2                                               WDPSC\n         BNE   RET                   NOPE-> NO MORE 23E ABEND!  WDPSC\n         SPACE\n         DETACH (R1)\n         SPACE\n         XC    0(8,R5),0(R5)           CLEAR TCB ADDR             WDPSC\n         B     RET                      GET OUT\n         EJECT\nE0       EQU   *\n         TM    0(R11),X'80'       2 PARMS?                       V2M4\n         BO    SETWAIT            NOPE.                          V2M4\n         L     R1,4(R11)                                         V2M4\n         POST  (R1)                                              V2M4\nSETWAIT  MVC   WAITCNT(2),=H'144'      INIT MAX WAIT COUNT 12 HRS\nE0L      XC    MYECB,MYECB              MAKE SURE ECB IS CLEAR!!!!\n         SPACE\n         STIMER REAL,POSTME,BINTVL=WAITTIME\n         SPACE\n         WAIT  ECB=MYECB\n         SPACE\n         LH    R7,WAITCNT               R7=WAIT CNT\n         BCT   R7,DOITAGIN              TOO MANY?\n         SPACE\nABENDME  ABEND 77,DUMP                  YES->KILL ME\n         SPACE\nDOITAGIN STH   R7,WAITCNT               SAVE THE CNT\n         B     E0L                      START OVER\n         SPACE 2\nPOSTME   DS    0H                       ASYNC EXIT\n         USING POSTME,R15\n         STM   14,12,12(R13)\n         LR    R11,R13                 SAVE R13                   WDPSC\n         L     R13,540                 R13->TCB                   WDPSC\n         L     R13,112(,R13)           R13->1ST SAVE AREA         WDPSC\n         L     R13,8(,R13)             R13->NEWMWILE SAVE AREA    WDPSC\n         SPACE 2\n         POST  MYECB                    POST THE ECB\n         SPACE 2\n         LR    R13,R11                 RESORE TO CP R13           WDPSC\n         LM    14,12,12(R13)\n         BR    R14                      RET TO MAIN\n         EJECT\n*\n*              WORK AREAS:\n*\nCT0      DC    C'CT0'\nTT       DC    X'0004080C1014181C2024'\nWAITTIME DC    F'30000'                 5 MIN?\n         SPACE 3\nWORKAREA DSECT\nSAVEAREA DS    18F\nPARML    DS    2A\nMYECB    DC    F'0'\nWAITCNT  DC    H'144'                   12 HRS MAX\nWORKLEN  EQU   *-WORKAREA\n         IKJTCB\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "NEWWAIT": {"ttr": 28167, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x00\\x7f\\x00\\x88\\x00\\x7f\\x12\\x00\\x00P\\x00P\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf2\\xf7\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-01-07T00:00:00", "modifydate": "1988-01-07T12:00:00", "lines": 80, "newlines": 80, "modlines": 0, "user": "FILE270"}, "text": "*          DATA SET 761KKNWAIT AT LEVEL 002 AS OF 08/30/82\n*\n* WRITTEN BY KERMIT KISER - WASHINGTON STATE DP SERVICE CENTER (WDPSC)\n*\nNEWWAIT  ENTERR\n         L     R11,0(R1)          R11->PARM FIELD\n         LH    R10,0(R11)         R10= PARM LENGTH\n         LA    R11,1(R11)         R11=R11+1\n         SLR   R9,R9              R9=0\n         SLR   R8,R8              R8=0\nLOOP1    LA    R11,1(R11)         R11=R11+1\n         CLI   0(R11),C' '        SPACE?\n         BNE   DECODE             NO->ASSUME DATA\n         BCT   R10,LOOP1          YES\n         B     NOVAL\n         EJECT\nDECODE   CLI   0(R11),C' '        SPACE?\n         BE    MBY100             YES\n         CLI   0(R11),C'.'        PERIOD?\n         BE    SKIPSET            YES\n         SLR   R2,R2              R2=0\n         TRT   0(1,R11),TABLE     GET VALUE\n         MH    R9,=H'10'          R9=R9*10\n         AR    R9,R2              R9=R9+R2\n         CH    R8,=H'1'           R8=1?\n         BH    DEDONE             HIGH=DONE\n         BE    LASTDIG            EQUAL->LAST DIGIT NEXT\nSKIPPED  LA    R11,1(R11)         R11=R11+1\n         BCT   R10,DECODE         R10=R10-1 >0 -> LOOP FOR NEXT DIGIT\n         B     MBY100             ASSUME DONE\n*\nSKIPSET  LTR   R8,R8              R8=0?\n         BNZ   ERRP               NO->OOPS\n         LA    R8,1               R8=1\n         B     SKIPPED\nLASTDIG  LA    R8,2               R8=2\n         B     SKIPPED\nERRP     EQU   *\nMBY100   CH    R8,=H'2'           TENTH DIGIT PRESENT ONLY?\n         BE    MBY10              YES\n         MH    R9,=H'10'          R9=R9*10\nMBY10    MH    R9,=H'10'          R9=R9*10\n*\nDEDONE   ST    R9,BINTVL\n         EJECT\n*\n         MVC   POSTME(POSTLEN),POSTMAP\n*\n         STIMER REAL,POSTME,BINTVL=BINTVL\n*\n         WAIT  ECB=POSTME+MYECB-POSTMAP\n*\n         B     EXIT\n         SPACE 3\n         DS    0F\nPOSTMAP  STM   14,12,12(R13)\n         POST  MYECB-POSTMAP(,R15)\n         LM    14,12,12(R13)\n         BR    R14\nMYECB    DC    F'0'\nPOSTLEN  EQU   *-POSTMAP\n         EJECT\nNOVAL    EQU   *\nEXIT     SLR   R15,R15            R15=0\n         LEAVER\n*\nTABLE    DC    256X'00'\n         ORG   TABLE+X'F0'\n         DC    X'00010203040506070809'\n         ORG\n         LTORG\n*\n*   WORKING STORAGE AREA - DYNAMIC\n*\nWORKAREA DSECT\nSAVEAREA DS    18F\nPOSTME   DS    XL(POSTLEN)\nBINTVL   DS    F\nWORKLEN  EQU   *-WORKAREA\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "NEWWAIT$": {"ttr": 28170, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x00\\x7f\\x00\\x88\\x00\\x7f\\x12\\x00\\x00@\\x00@\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf2\\xf7\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-01-07T00:00:00", "modifydate": "1988-01-07T12:00:00", "lines": 64, "newlines": 64, "modlines": 0, "user": "FILE270"}, "text": "1                                                        NEWWAIT.1\n                                                         06/25/82\n\n\n  PROGRAM:       NEWWAIT\n  AUTHOR:        Kermit Kiser\n  AGENCY:        WDPSC\n  LANGUAGE:      Assembler\n  LOCATION:      WDPSC.SHARED.LOAD\n  FUNCTION:      Wait for a specified period  of time without using\n                 CPU time (replaces WAITER).\n\n  RUN MODE:      Batch or interactive\n\n  NEWWAIT  is a  program  which can  be  called by  a  CLIST or  an\n  application program executing under control of  TSO to wait for a\n  specified period of time without using  CPU time.  It can be used\n  for generating temporary displays.\n\n  To call from a CLIST:\n       CALL 'WDPSC.SHARED.LOAD(NEWWAIT)' 'nn'\n\n             nn  =  the number of seconds to halt execution.  The\n                    minimum which can be specified is '.01' (one-\n                    hundredth second).\n\n  EXAMPLE:  CALL 'WDPSC.SHARED.LOAD(NEWWAIT)' '5'\n\n            Will cause a five second wait before continuing execution.\n\n\n\n\n1                                                        NEWWAIT.2\n                                                         06/25/82\n\n\n  To call from a COBOL Program:\n\n       CALL 'NEWWAIT' USING parameter.\n\n       Parameter is a two field data item:  length, time.\n\n            length  =  binary halfword (2 bytes) giving length of\n                       parameter not including this length field.\n\n            time    =  time in seconds to wait.  The format is the\n                       same as for a CLIST.\n\n  EXAMPLE:\n\n            01 PARAMETER.\n               05   LEN   PIC S9999 COMP VALUE +1.\n               05   TIM   PIC X VALUE '2'.\n\n       CALL 'NEWWAIT' USING PARAMETER.\n            will wait two seconds.\n\n       NOTE:     This  program  can  be  interrupted  by  pressing\n                 your attention key (BREAK, PAl, ATTN, etc.).\n\n\n\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "NEXTGEN": {"ttr": 28172, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x00\\x7f\\x00\\x88\\x00\\x7f\\x12\\x00\\x01p\\x01p\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf2\\xf7\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-01-07T00:00:00", "modifydate": "1988-01-07T12:00:00", "lines": 368, "newlines": 368, "modlines": 0, "user": "FILE270"}, "text": "*          DATA SET 764NEXTGEN AT LEVEL 004 AS OF 10/23/81\n********************\n*                  *\n*  N E X T G E N   *\n*                  *\n********************\n*\n*\n*  --------------------------------------------------------------------\n*  COMMAND     OPERANDS\n*  --------------------------------------------------------------------\n*  NEXTGEN     DSN('DSNAME')\n*  --------------------------------------------------------------------\n*\n*  OPERANDS -\n*\n*    REQUIRED -\n*\n*        DSN('DSNAME')         'DSNAME' IS THE DSNAME OF THE GENERATION\n*                              DATA GROUP (BASE NAME ONLY)\n*\n*  EXPLANATION -\n*\n*    THIS COMMAND WILL RETURN TWO CLIST VARIABLES &CURGEN AND &NXTGEN\n*    WHERE &CURGEN CONTAINS THE ABSOLUTE GENERATION NUMBER OF THE +0\n*    GENERATION AND &NXTGEN CONTAINS THE ABSOLUTE GENERATION NUMBER\n*    OF THE +1 GENERATION\n*\n*\n*  EXAMPLE -\n*\n*    SUPPOSE THAT AGNCY999.MY.GDG(+0) IS AGNCY999.MY.GDG.G0497V00\n*\n*    THEN IF ONE WOULD ENTER THE FOLLOWING COMMAND:\n*\n*            NEXTGEN DSN('AGNCY999.MY.GDG')\n*\n*    THIS COMMAND WOULD RETURN THE FOLLOWING IN THE TWO CLIST VARIABLES\n*\n*            CURGEN = G0497V00\n*\n*            NXTGEN = G0498V00\n*\n*            R E T U R N   C O D E S\n*            -----------------------\n*\n*\n*        &LASTCC         MEANING\n*        -------         --------------------------\n*\n*          0             SUCCESSFUL COMPLETION\n*          4             PARSE ERROR\n*          8             MISSING DSNAME PARAMETER\n*          12            GDG BASE NOT FOUND\n         EJECT\n*\n*        REGISTER       ASSIGNMENT\n*        --------       -------------------------------------------\n*\n*           3           NOT USED\n*           4           HOLDS THE RETURN CODE\n*           5           NOT USED\n*           6           WORK REGISTER\n*           7           WORK REGISTER\n*           8           WORK REGISTER\n*           9           NOT USED\n*           10          WORK REGISTER\n*           11          SAVE PARM POINTER\n*           12          BASE REGISTER\n*           13          ADDRESS OF SAVE AREA\n*           14          RETURN ADDRESS\n*           15          ENTRY POINT ADDRESS\n         EJECT\nNEXTGEN  ENTERR\n         EJECT\n********************************************************************\n*                                                                  *\n*      M A I N   L I N E   L O G I C   F O R   N E X T G E N       *\n*                                                                  *\n********************************************************************\n*\n         LR    R11,R1              SAVE THE PARM POINTER\n         LA    R4,0                R4 ==> 0\n         MVC   CURGEN,=CL8' '      MOVE SPACES TO CURGEN\n         MVC   NXTGEN,=CL8' '      MOVE SPACES TO NXTGEN\n         BAL   R14,DOPARSE         PERFORM THE PARSE SERVICE ROUTINE\n         CLC   PROCESSW,=C'YES'    WAS PARSE SUCCESFUL ?\n         BNE   INITL               IF NOT, BRANCH TO INITL\n         BAL   R14,LOADFLD         PERFORM ROUTINE TO LOAD THE PARSED\n*                                    FIELD INTO DATA FIELD GDGNAME\n         CLC   PROCESSW,=C'YES'    IS EVERTHING STILL HONKEY DOREY ?\n         BNE   INITL               IF NOT, BRANCH TO INITL\n         BAL   R14,MAJORTN         PERFORM ROUTINE TO DO THE LOCATE\n*                                    AND THEN GENERATE THE VALUES OF\n*                                    CLIST VARS &CURGEN AND &NXTGEN\nINITL    BAL   R14,INITLIST        BUILD PARMLIST FOR IKJUPDT\n         BAL   R14,SETCURGN        SET CLIST VARIABLE &CURGEN\n         BAL   R14,SETNXTGN        SET CLIST VARIABLE &NXTGEN\n         B     SHUTDOWN            BRANCH TO SHUTDOWN\n         EJECT\n********************************************************************\n*                                                                  *\n*        P A R S E   I N P U T   C O M M A N D   B U F F E R       *\n*                                                                  *\n********************************************************************\n*\nDOPARSE  ST    R14,SAVEIT1          SAVE REG 14 CONTENTS IN SAVEIT1\n         KKPARSE\n         LTR   R15,R15              RC = 0 ? (I.E PARSE GO OK ?)\n         BNZ   PARSERR              IF NOT, BRANCH TO PARSERR\n         MVC   PROCESSW,=C'YES'     MOVE 'YES' TO PROCESSW\n         L     R10,ANS\n         USING IKJPARMD,R10\n         B     EXITPARS\nPARSERR  MVC   PROCESSW,=C'NO '     MOVE 'NO ' TO PROCESSW\n         LA    R4,4                 SET REG 4 = 4\nEXITPARS L     R14,SAVEIT1\n         BR    14\n         EJECT\n********************************************************************\n*                                                                  *\n*        THIS ROUTINE PROCESSES THE PARSED FIELD, AND THEN         *\n*        LOADS THE DATA FIELD GDGNAME                              *\n*                                                                  *\n********************************************************************\n*\nLOADFLD  ST    R14,SAVEIT2             SAVE REG 14 CONTENTS IN SAVEIT2\n         MVC   PROCESSW,=CL3'YES'      MOVE 'YES' TO PROCESSW\n         TM    DSNSTRNG+6,X'80'        IS DSNAME PRESENT ?\n         BNO   NODSNAME                IF NOT, BRANCH TO NODSNAME\n         MVC   GDGNAME,=CL44' '        MOVE SPACES TO GDGNAME\n         LA    R1,GDGNAME              R1 ==> ADDRESS OF GDGNAME\n         L     R8,DSNSTRNG             R8 ==> ADDRESS OF THE DSNAME\n         LH    R7,DSNSTRNG+4           R7 ==> LENGTH OF THE DSNAME\n         S     R7,=F'1'                SUBTRACT 1 FOR EX\n         SPACE 1\nMOVEDSN  MVC   0(0,R1),0(R8)           MOVE THE DSNAME TO GDGNAME\n         EX    R7,MOVEDSN\n         SPACE 1\n         MVC   INDSNLEN(2),DSNSTRNG+4  INDSNLEN ==> LENGTH OF DSNAME\n         B     EXITLOAD                BRANCH TO EXITLOAD\nNODSNAME MVC   PROCESSW,=CL3'NO '      MOVE 'NO ' TO PROCESSW\n         LA    R4,8                    SET REG 4 = 8\nEXITLOAD L     R14,SAVEIT2\n         BR    R14\n         EJECT\n*\n********************************************************************\n*                                                                  *\n*     THIS ROUTINE IS RESPONSIBLE FOR DOING THE LOCATE AND THEN    *\n*     PARSING THE DSNAME IN ORDER TO GENERATE THE CLIST VARIABLES  *\n*     &CURGEN AND NXTGEN                                           *\n*                                                                  *\n********************************************************************\n*\nMAJORTN  ST    R14,SAVEIT3            SAVE REG 14 IN SAVEIT3\n         BAL   R14,ADDSUFFX           PERFORM ROUTINE TO SUFFIX THE\n*                                     DSNAME WITH (+0)\n         MVC   CAMLIST1,PATCAML1\n         LA    R1,GDGNAME\n         ST    R1,CAMLIST1+4\n         LA    R1,LOCAREA\n         ST    R1,CAMLIST1+12\n         LOCATE CAMLIST1\n         SPACE 2\n         C     R15,=F'0'              COMPARE REG 15 TO BE = 0\n         BE    RC0                    IF REG 15=0, BRANCH TO RC0\n         MVC   PROCESSW,=CL3'NO '     MOVE 'NO ' TO PROCESSW\n         LA    R4,12                  R4==> 12\n         B     EXITMAJR               BRANCH TO EXITMAJR\nRC0      LA    R6,GDGNAME             R6==> ADDRESS OF GDGNAME\n         A     R6,=F'43'              R6==> ADDRESS OF LOW ORDER OF\n*                                         GDGNAME\nABSLOOP  CLI   0(R6),C' '             HAVE WE FOUND A SIGNIFICANT CHAR?\n         BNE   FOUND                  IF SO, BRANCH TO FOUND\n         S     R6,=F'1'               DECREMENT R6 BY 1\n         B     ABSLOOP                BRANCH TO ABSLOOP\nFOUND    S     R6,=F'7'               SET R6 TO START OF ABS GEN NO\n         MVC   CURGEN(8),0(R6)        MOVE GXXXXV00 TO CURGEN\n         BAL   R14,ADDONE             PERFORM ROUTINE TO ADD 1 TO XXXX\nEXITMAJR L     R14,SAVEIT3\n         BR    R14\n         EJECT\n*\n********************************************************************\n*                                                                  *\n*        THIS ROUTINE IS RESPONSIBLE FOR ADDING 1 TO THE           *\n*        GENERATION NUMBER FOUND IN DATA FIELD CURGEN AND          *\n*        STORING THE RESULT IN NXTGEN                              *\n*                                                                  *\n*        E.G.                                                      *\n*                                                                  *\n*             IF CURGEN IS G0497V00 COMING IN TO THIS ROUTINE,     *\n*             THEN THIS ROUTINE WILL LOAD DATA FIELD NXTGEN        *\n*             WITH G0498V00                                        *\n*                                                                  *\n********************************************************************\n*\nADDONE   ST    R14,SAVEIT4            SAVE REG 14 IN SAVEIT4\n         MVC   NXTGEN,CURGEN\n         PACK  PACKGEN(3),CURGEN+1(4)\n         AP    PACKGEN,PACK1\n         UNPK  GENNO,PACKGEN\n         OI    GENNO+3,X'F0'\n         MVC   NXTGEN+1(4),GENNO\n         L     R14,SAVEIT4\n         BR    R14\n         EJECT\n*\n********************************************************************\n*                                                                  *\n*        THIS ROUTINE IS RESPONSIBLE FOR SUFFIXING THE DATA        *\n*        FIELD GDGNAME WITH (+0)                                   *\n*                                                                  *\n*        E.G.                                                      *\n*             IF GDGNAME COMING IN TO THIS ROUTINE IS              *\n*             AGNCY999.MY.GDG, THEN AFTER THIS ROUTINE IS          *\n*             COMPLETED, GDGNAME WILL CONTAIN AGNCY999.MY.GDG(+0)  *\n*                                                                  *\n********************************************************************\n*\nADDSUFFX ST    R14,SAVEIT5            SAVE REG 14 IN SAVEIT5\n         LA    R6,GDGNAME             R6==> ADDRESS OF GDGNAME\n         A     R6,=F'43'              R6==> ADDRESS OF LOW ORDER OF\n*                                         GDGNAME\nSFXLOOP  CLI   0(R6),C' '             HAVE WE FOUND A SIGNIFICANT CHAR?\n         BNE   SIGNIF                 IF SO, BRANCH TO SIGNIF\n         S     R6,=F'1'               DECREMENT R6 BY 1\n         B     SFXLOOP                BRANCH TO SFXLOOP\nSIGNIF   A     R6,=F'1'\n         MVC   0(4,R6),=CL4'(+0)'     SUFFIX DSNAME WITH (+0)\n         L     R14,SAVEIT5\n         BR    R14\n         EJECT\n********************************************************************\n*                                                                  *\n*        BUILD UPDTLIST (IKJUPDT PARM LIST)                        *\n*                                                                  *\n********************************************************************\n*\nINITLIST ST    R14,SAVEIT6\n         MVC   UPDTUPT,CPPLUPT          UPT\n         MVC   UPDTECT,CPPLECT          ECT\n         LA    R9,ECB\n         ST    R9,UPDTECB               ECB\n         LA    R8,UPLIST\n         ST    R8,UPDTUPL               UPLIST\n         L     R14,SAVEIT6\n         BR    14\n         EJECT\n********************************************************************\n*                                                                  *\n*        BUILD UPDATE PARM LIST FOR &CURGEN AND CALL IKJUPDT       *\n*                                                                  *\n********************************************************************\n*\nSETCURGN ST    R14,SAVEIT7\n         LA    R9,=C'CURGEN'\n         ST    R9,LOCPTR\n         MVC   LOCLEN,=F'6'\n         LA    R5,CURGEN\n         ST    R5,VALPTR\n         MVC   VALLEN,=F'8'\n         LA    R1,UPDTLIST\n         CALL  IKJUPDT\n         L     R14,SAVEIT7\n         BR    14\n         EJECT\n********************************************************************\n*                                                                  *\n*        BUILD UPDATE PARM LIST FOR &NXTGEN AND CALL IKJUPDT       *\n*                                                                  *\n********************************************************************\n*\nSETNXTGN ST    R14,SAVEIT8\n         LA    R9,=C'NXTGEN'\n         ST    R9,LOCPTR\n         MVC   LOCLEN,=F'6'\n         LA    R5,NXTGEN\n         ST    R5,VALPTR\n         MVC   VALLEN,=F'8'\n         LA    R1,UPDTLIST\n         CALL  IKJUPDT\n         L     R14,SAVEIT8\n         BR    14\n         EJECT\n********************************************************************\n*                                                                  *\n*        E N D   O F   J O B   R O U T I N E                       *\n*                                                                  *\n********************************************************************\n*\nSHUTDOWN LR   R15,R4\n         LEAVER\n         EJECT\n         SPACE 3\n********************************************************************\n*                                                                  *\n*        D A T A   A R E A   C O N S T A N T S                     *\n*                                                                  *\n********************************************************************\n*\nCURGEN   DS    CL8\nNXTGEN   DS    CL8\nPATCAML1 CAMLST  NAME,PATDSN,,PATLOC\nPATDSN   DS    CL44\nPATLOC   DS    CL256\nPACK1    DC    PL1'1'\n         LTORG\n         EJECT\n         SPACE 3\n********************************************************************\n*                                                                  *\n*        D Y N A M I C   W O R K   A R E A                         *\n*                                                                  *\n********************************************************************\n*\nWORKAREA DSECT\nSAVEAREA DS    18F\nANS      DS    F\nCAMLIST1 CAMLST NAME,GDGNAME,,LOCAREA\nLOCAREA  DS    0D\n         DS    265C\nECB      DS    F\n         DS    0D\nGENNO    DS    CL4\nGDGNAME  DS    CL44\nPACKGEN  DS    PL3\nINDSNLEN DS    H\nPPLA     DS    7F\nPROCESSW DS    CL3\nSAVEIT1  DS    F\nSAVEIT2  DS    F\nSAVEIT3  DS    F\nSAVEIT4  DS    F\nSAVEIT5  DS    F\nSAVEIT6  DS    F\nSAVEIT7  DS    F\nSAVEIT8  DS    F\n*\nUPDTLIST DS    0F\nUPDTUPT  DS    F\nUPDTECT  DS    F\nUPDTECB  DS    F\nUPDTUPL  DS    F\n*\nUPLIST   DS    0F\nLOCPTR   DS    AL4\nLOCLEN   DS    FL4\nVALPTR   DS    AL4\nVALLEN   DS    FL4\n*\nWORKLEN  EQU   *-WORKAREA\nNEXTGEN CSECT\n         EJECT\n********************************************************************\n*                                                                  *\n*                   P A R S E   M A C R O S                        *\n*                                                                  *\n********************************************************************\n*\nPCL      IKJPARM\nDSNAME   IKJKEYWD\n         IKJNAME 'DSNAME',SUBFLD=DSNAM\nDSNAM    IKJSUBF\nDSNSTRNG IKJPOSIT DSNAME,USID\n         IKJENDP\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "OPERSCAN": {"ttr": 28421, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x88\\x00\\x7f\\x00\\x98)\\x9f\\x12)\\x01j\\x01f\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf2\\xf7\\xf0@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1988-01-07T00:00:00", "modifydate": "1998-10-26T12:29:00", "lines": 362, "newlines": 358, "modlines": 0, "user": "FILE270"}, "text": "*\n*   @OK - ADJUSTED TO INVOKE REGISTER EQUATE MACRO SUPPLIED IN\n*          FILE270 .MACLIB                        10/26/98\n*\n*          DATA SET 761KKOPERS AT LEVEL 002 AS OF 02/13/80\n*\n* WRITTEN BY KERMIT KISER - WASHINGTON STATE DP SERVICE CENTER (WDPSC)\n*\n*\n*              DOCUMENTATION FOR KMDPARS AND OPERSCAN SUBRTNS:\n*\n*\n*\n*               PARAMETER LIST PASSED TO KMDPARS:\n*\n*         KPPL     DS 10F :\n*         CBUFPTR  DS    F              CMDBUF TO BE PARSED\n*         OPLSTPTR DS    F              LIST OF OPERANDS TO FLAG\n*         FLAGPTR  DS    F              WHERE TO FLAG THEM\n*         UNKNEXIT DS    F              EXIT TO CALL IF UNKNOWN OPER\n*         EXITPARM DS    F              PARAMETER TO PASS EXITS (ADDR)\n*                                       (R1 POINTS HERE AT EXIT ENTRY)\n*         BPPLPASS DS    F              BPPL PTR WHEN EXIT GETS CONTROL\n*         WORKPASS DS    F              OPTIONAL WORKAREA (512 BYTES)\n*                  DS    3F             RESERVED\n*\n*\n*               PARAMETER LIST PASSED TO OPERSCAN SUBROUTINE:\n*\n*         BPPL     DS    10F :\n*         BUFFPTR  DS    F              BUFFER PTR (CBUF)\n*         LENPTR   DS    F              LENGTH PTR (CBUF LEN)\n*         STARTPTR DS    F              START SEARCH PTR\n*         OPERPTR  DS    F              NEXT OPER LOC\n*         OPLENPTR DS    F              NEXT OPER LEN PTR\n*         SUBPTR   DS    F              SUBFIELD PTR\n*         SUBLENPT DS    F              SUBFIELD LEN PTR\n*         WORKPTR  DS    F              OPTIONAL WORKAREA (350 BYTES)\n*                  DS    2F             RESERVED\n*\n*         OPLEN    DS    H              POINTED TO BY OPLENPTR\n*         SUBLEN   DS    H              POINTED TO BY SUBLENPT\n*\n*          DATA SET 761KKOPSCN AT LEVEL 001 AS OF 04/27/79\n         TITLE 'OPERSCAN - PARSE ROUTINE FOR INTERCEPT COMMANDS'\nOPERSCAN CSECT\n         SAVE  (14,12),,*\n         LR    R12,R15\n         USING OPERSCAN,R12\n         LR    R11,R1                   R11 -> PARM LIST\n         USING BPPL,R11\n         SLR   R15,R15                  R15 = 0\n         LR    R10,R13                  SAVE SAVE\n         L     R13,WORKPTR              SEE IF A FREE ONE THERE\n         LTR   R13,R13                  ANY?\n         BNZ   FASTCALL                 YES -> SMART CALLER\n         LA    R0,WORKLEN               NO -> GET SOME\n         GETMAIN R,LV=(0)\n         LR    R13,R1                   SAVE IT\n         USING WORKAREA,R13\nFASTCALL ST    R10,SAVEAREA+4           SAVE HIS SAVE PTR\n         LA    R13,SAVEAREA             MAKE SURE MINE IS OK\n         USING SAVEAREA,R13\n         ST    R13,8(,R10)              GIVE HIM MY SAVE AREA\n*\n         EJECT\n         BAL   R14,VALCHECK             CAN WE LOOK FOR AN OPERAND?\n         LTR   R15,R15                  R15 STILL 0?\n         BNZ   OPEREX                   NO CAN DO\n*\n         BAL   R14,FINDOPER             LOOK FOR OPERAND\n         LTR   R15,R15                  R15 STILL 0?\n         BNZ   OPEREX                   NO CAN DO\n*\n         BAL   R14,FINDEND              FIND THE END OF THE OPERAND\n         EJECT\nOPEREX   LR    R1,R13                   R1 -> WORKAREA\n         LA    R0,WORKLEN               R0 = LENGTH OF AREA\n         L     R13,4(,R13)              R13 -> OLD SAVE AREA\n         C     R1,WORKPTR               IS WORKAREA MINE?\n         BE    FASTEX                   NO -> DONT FREE\n         LR    R11,R15                  SAVE RC\n         FREEMAIN R,LV=(0),A=(1)        FREE\n         LR    R15,R11                  GET RC BACK\nFASTEX   RETURN (14,12),RC=(15)         EXIT OPERSCAN\n         REGEQU                                                     @OK\n         EJECT\nVALCHECK ST    R14,L1LS\n*\n         ST    R15,OPERPTR              NEXT OPER PTR = 0\n         ST    R15,SUBPTR               SUBFLD PTR = 0\n*\n         L     R10,BUFFPTR              R10 -> BUFFER\n         L     R9,LENPTR                R9 ->  BUFF LEN\n         AH    R10,0(R9)                R10 -> BUFFEND+1\n         S     R10,STARTPTR             R10 = LEN TO SCAN\n         BP    SAVELEN                  SAVE IF > 0\n*\n         LA    R15,4                    RC = 4 -> NO OPER FOUND\n         BR    R14\n*\nSAVELEN  ST    R10,SCANLEN              SAVE LENGTH TO SCAN\n         BR    R14                      EXIT\n         EJECT\nFINDOPER ST    R14,L1LS\n*\n         SLR   R1,R1                    R1=0\n*\n         L     R10,STARTPTR             R10 -> START OF SEARCH\n         L     R9,SCANLEN               R9 = LEN TO SEARCH\n         BCTR  R9,R0                    R9 = R9-1 FOR EX\n         EX    R9,TRT1                  LOOK FOR AN OPERAND\n         BZ    NOOPER                   NONE FOUND?\n*              WE HAVE ONE! ; POINT TO  IT:\n         ST    R1,OPERPTR               RETURN OPER LOCATION\n         L     R8,BUFFPTR               R8 -> BUFF\n         L     R7,LENPTR                R7 -> BUFF LEN\n         AH    R8,0(R7)                 R8 -> BUFFEND+1\n         SR    R8,R1                    R8 = NEW SCAN LENGTH\n         ST    R8,SCANLEN               SAVE IT\n         BR    R14\nNOOPER   LA    R15,4\n         L     R14,L1LS\n         BR    R14\nTRT1     TRT   0(0,R10),TRANTAB1        EXECUTED SCAN\n         TITLE 'OPERSCAN    - FINDEND ROUTINES'\nFINDEND  DS    0H\n         ST    R14,L1LS           SAVE R14\n*\nFINDINIT L     R9,OPERPTR         R9 -> START OF OPER\n         A     R9,SCANLEN         R9 -> END OF BUFF +1\n         LR    R8,R9              R8 -> \"\n         BCTR  R8,R0              R8 = R8-1\n         L     R7,OPERPTR         R7 -> OPER START\n         LA    R5,NORMODE         R5 -> NORMMODE\n         SLR   R4,R4              R4 = 0 = PAREN DEPTH\n         L     R3,SCANLEN         R3 =  LEN TO SCAN\n         BCTR  R3,R0              R3=LENGTH FOR EXECUTE\n         SLR   R2,R2              R2=0\n         SLR   R1,R1              R1=0\n         L     R15,=F'-1'         R15 = -1\n         MVC   TRTTABLE,TT\n*\nSCANLOOP DS    0H\n         BAL   R14,SCANLINE       LINK TO PARSE SCAN\n         LTR   R15,R15            R15=0?\n         BM    SCANLOOP           CONTINUE IF NEGATIVE\n*\nFINDEXIT L     R14,L1LS           RESTORE R14\n         BR    R14                EXIT\n*\n*\nSCANLINE DS    0H\n*\nTRTEX    EX    R3,TRT             EXECUTE SCAN\n         BZ    0(,R5)             END OF LINE - NOTHING FOUND\n         BC    4,0(R2,R5)         NOT END OF LINE - SOMETHING FOUND\n         BC    2,4(R2,R5)         END OF LINE - SOMETHING FOUND\n         DS    0F\nTRT      TRT   0(0,R7),TRTTABLE   TRANSLATE INSTRUCTION (EXECUTED)\n         EJECT\n         DS    0F\nTT       DC    256X'0'            TRANS TABLE PATTERN\n         ORG   TT+107             COMMA\n         DC    X'04'\n         ORG   TT+77              LEFT PAREN\n         DC    X'0C'\n         ORG   TT+93              RIGHT PAREN\n         DC    X'14'\n         ORG   TT+125             QUOTE\n         DC    X'1C'\n         ORG   TT+64              BLANK\n         DC    X'24'\n         ORG\n*\n*   BRANCH TABLES\n*\nNORMODE  DS    0H\n         B     NORMEND                       END OF LINE\n         B     NORMCOM            COMMA\n         B     NMCOMEL            COMMA      END OF LINE\n         B     NORMLP             LEFT PAREN\n         B     NMLPEL             LEFT PAREN END OF LINE\n         B     NORMRP             RITE PAREN\n         B     NMRPEL             RITE PAREN END OF LINE\n         B     NORMQ              QUOTE\n         B     NORMQEL            QUOTE      END OF LINE\n         B     NORMB              BLANK\n         B     NORMBEL            BLANK      END OF LINE\n*\nPARNMODE DS    0H\n         B     PMEND                       END OF LINE\n         B     PMCOM              COMMA\n         B     PMCOMEL            COMMA      END OF LINE\n         B     PMLP               LEFT PAREN\n         B     PMLPEL             LEFT PAREN END OF LINE\n         B     PMRP               RITE PAREN\n         B     PMRPEL             RITE PAREN END OF LINE\n         B     PMQ                QUOTE\n         B     PMQEL              QUOTE      END OF LINE\n         B     PMB                BLANK\n         B     PMBEL              BLANK      END OF LINE\n*\nQMODE    DS    0H\n         B     QMEND                       END OF LINE\n         B     QMQ                QUOTE\n         B     QMQEL              QUOTE      END OF LINE\n         EJECT\n*\n*   COMMON SCAN ROUTINES\n*\n*\nCOMSEX1  DS    0H                 COMMON SCAN EXIT\n         LA    R7,1(,R1)          R7 -> NEXT SCAN POSITION\n         LR    R3,R8              R3 -> END OF LINE\n         SR    R3,R7              R3 =  EX LENGTH FOR SCAN\n         BM    SCANERR            ERROR IF NO LEN\n         BR    R14                EXIT SCANLINE\n*\nSTORLEN1 EQU   *                  STORE OPER LENGTH\n         ST    R1,STARTPTR        SAVE DELIM PTR\n         S     R1,OPERPTR         R1 = OPERLEN\n         L     R10,OPLENPTR       R10 -> OPER LEN FIELD\n         STH   R1,0(R10)          SAVE IT\n         BR    R14\n*\nSTORLEN2 EQU   *                  STORE SUBFIELD LENGTH\n         ST    R1,STARTPTR        SAVE DELIM PTR\n         S     R1,SUBPTR          R1 = SUBFLD LENGTH\n         L     R10,SUBLENPT       R10 -> SUBLEN FIELD\n         STH   R1,0(R10)          SAVE LEN\n         BR    R14\n*\n*\nSCANERR  EQU   *\n         LR    R1,R9              R1 -> BUFFEND+1\n         LTR   R4,R4              IN PARENS?\n         BZ    SENM               NO\n         LA    R15,12             RC=12 ERROR\n         B     STORLEN2\nSENM     LA    R15,8              RC= 8 ERROR\n         B     STORLEN1\n         EJECT\nNORMEND  EQU   *\n         LR    R1,R9              R1 -> BUFFEND+1\n         SLR   R15,R15            RC=0 -> SCAN COMPLETED\n         B     STORLEN1           EXIT\n*\nNMCOMEL  EQU   *                  NORMAL MODE,COMMA,EOL\nNORMCOM  EQU   *                  NORMAL MODE,COMMA\n         SLR   R15,R15            RC=0 -> SCAN COMPLETED\n         B     STORLEN1           EXIT\n*\nNMLPEL   B     NORMRP             NORMAL MODE,LEFT PAREN,EOL\nNORMLP   DS    0H                 NORMAL MODE,LEFT PAREN\n         LA    R5,PARNMODE        R5 -> PAREN MODE (MODE SWITCH)\n         LA    R4,1(,R4)          R4 = R4+1 (PAREN DEPTH = 1)\n         ST    R1,SUBPTR          SAVE START OF SUBFIELD\n         LR    R7,R1              R7 -> LEFT PAREN\n         S     R7,OPERPTR         R7 = OPERAND LENGTH\n         L     R10,OPLENPTR       R10 -> OPER LEN AREA\n         STH   R7,0(R10)          SAVE OPER LENGTH\n         B     COMSEX1            GO TO COMMON EXIT\n*\nNMRPEL   EQU   *                  NORMAL MODE,RITE PAREN,EOL\nNORMRP   EQU   *                  NORMAL MODE,RITE PAREN\n         SLR   R15,R15            RC=0 -> SCAN COMPLETE\n         B     STORLEN1           EXIT\n*\nNORMQEL  EQU   SCANERR            NORMAL MODE,QUOTE,EOL\nNORMQ    DS    0H                 NORMAL MODE,QUOTE\n         LA    R5,QMODE           CHANGE TO QUOTE MODE\n         XC    TRTTABLE,TRTTABLE  CLEAR TRANSLATE TABLE\n         MVI   TRTTABLE+125,X'04' QUOTE POSITION IN TABLE\n         B     COMSEX1            GO TO COMMON EXIT\n*\nNORMBEL  EQU   NORMCOM            NORMAL MODE,BLANK,EOL\nNORMB    EQU   NORMCOM            NORMAL MODE,BLANK\n         EJECT\n*\nPMEND    EQU   *                  PAREN MODE,EOL (NO VALID DELIM)\n         LR    R1,R9              R1 -> BUFFEND+1\n         SLR   R15,R15            RC=0 -> SCAN COMPLETED\n         B     STORLEN2           EXIT\n*\nPMCOMEL  EQU   PMEND              PAREN MODE,COMMA,EOL\nPMCOM    EQU   COMSEX1            PAREN MODE,COMMA\n*\nPMLPEL   EQU   PMEND              PAREN MODE,LEFT PAREN,EOL\nPMLP     DS    0H                 PAREN MODE,LEFT PAREN\n         LA    R4,1(,R4)          R4=R4+1 (PAREN DEPTH)\n         B     COMSEX1            GO TO COMMON EXIT\n*\nPMRPEL   EQU   PMEND              PAREN MODE,RITE PAREN,EOL\nPMRP     EQU   *                  PAREN MODE,RITE PAREN\n         BCT   R4,COMSEX1         R4=R4-1 (EXIT IF STILL NESTED)\n         SLR   R15,R15            RC=0 -> SCAN COMPLETE FLAG\n         LA    R1,1(R1)           R1=R1+1 POINT PAST DELIMITER\n         B     STORLEN2           GO TO SAVE SUBFLD LEN\n*\nPMQEL    EQU   SCANERR            PAREN MODE,QUOTE,EOL\nPMQ      EQU   NORMQ              PAREN MODE,QUOTE\n*\nPMBEL    EQU   PMEND              PAREN MODE,BLANK,EOL\nPMB      EQU   COMSEX1            PAREN MODE,BLANK\n*\nQMEND    EQU   SCANERR            QUOTE MODE,EOL (INVALID DELIM)\n*\nQMQ      DS    0H                 QUOTE MODE,QUOTE\n         CLI   1(R1),C''''        DOUBLE QUOTE?\n         BE    IGQ                YES ->SKIP IT\n         MVC   TRTTABLE,TT        NO -> RESET MODE\n         LTR   R4,R4              R4=0? (MODE=NORM)\n         BZ    QNS                YES -> QUOTE TO NORM SWITCH\n         LA    R5,PARNMODE        NO -> PAREN MODE SWITCH\n         B     COMSEX1            GO TO COMMON EXIT\nQNS      LA    R5,NORMODE         NORMAL MODE SWITCH\n         B     COMSEX1            GO TO COMMON EXIT\nIGQ      LA    R1,1(,R1)          R1=R1+1 (IGNORE QUOTES)\n         B     COMSEX1            GO TO COMMON EXIT\n*\nQMQEL    EQU   *                  QUOTE MODE,QUOTE,EOL\n         LTR   R4,R4              IN PARENS?\n         BZ    NORMEND            NO\n         B     PMEND              YES\n         TITLE 'OPERSCAN    - WORKAREA AND CONSTANTS'\nSTATWORK EQU   *\n*\nTRANTAB1 DC    256X'04'                 OPER SCAN TABLE\n         ORG   TRANTAB1+C' '            BLANK\n         DC    X'00'\n         ORG   TRANTAB1+C','            COMMA\n         DC    X'00'\n         ORG   TRANTAB1+C')'            RIGHT PAREN\n         DC    X'00'\n         ORG\n         LTORG\n         DC    80X'00'                  ZAP AREA\n         EJECT\nWORKAREA DSECT\nSAVEAREA DS    18F\nL1LS     DS    F\nL2LS     DS    F\nL3LS     DS    F\nL4LS     DS    F\nSCANLEN  DS    F\n*\nTRTTABLE DS    XL256\nWORKLEN  EQU   *-WORKAREA\n         TITLE 'PARAMETER LIST PASSED TO OPERSCAN SUBROUTINE'\nBPPL     DSECT\nBUFFPTR  DS    F                        BUFFER PTR\nLENPTR   DS    F                        LENGTH PTR\nSTARTPTR DS    F                        START SEARCH PTR\nOPERPTR  DS    F                        NEXT OPER LOC\nOPLENPTR DS    F                        NEXT OPER LEN PTR\nSUBPTR   DS    F                        SUBFIELD PTR\nSUBLENPT DS    F                        SUBFIELD LEN PTF\nWORKPTR  DS    F                        WORKAREA MAY BE PASSED HERE\n         DS    F\n         DS    F\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PACKLIST": {"ttr": 28428, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x00\\x7f\\x00\\x88\\x00\\x7f\\x12\\x00\\x01\\xd5\\x01\\xd5\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf2\\xf7\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-01-07T00:00:00", "modifydate": "1988-01-07T12:00:00", "lines": 469, "newlines": 469, "modlines": 0, "user": "FILE270"}, "text": "*          DATA SET CBT931     AT LEVEL 001 AS OF 02/25/79\n* PACKLIST SOURCE DSN=WDPSC.DN00150.FILE(PACKLIST)                      00001\n*                                                                       00002\n* PACKLIST        VERSION 1.0         WDPSC                             00003\n*        NOT WRITTEN AT STATE OF WASHINGTON, BUT SUBSTANTIALLY          00004\n*        ALTERED ON INPUT SIDE TO USE OUTPUT FROM TRACE TABLE SAMPLE    00005\n*        ROUTINE.                                                       00006\n* PACKLIST                                                              00007\n*        IS THE MODULE THAT BUILDS THE IEAPAK00 MEMBER OF               00008\n*        SYS1.PARMLIB. THE DATA IS OBTAINED BY USING THE ROUTINE        00009\n*        PSWSAMP (SEE NEXT ENTRY).   THE CONSTRUCTION IS BASED ON       00010\n*        FREQUENCY OF INTERUPTS IN A GIVEN LPA MODULE. ASSOCIATION      00011\n*        BY FREQUENCY IS POSSIBLE, BUT IS NOT ENFORCED.                 00012\n*                                                                       00013\n*        THE INTERUPTS IN AND TO LPA ARE COUNTED. THEN THE COUNTS FOR   00014\n*        EACH MODULE ARE DIVIDED BY THE LENGTH OF THAT MODULE. THIS     00015\n*        INDEX VALUE IS SORTED INTO DESCENDING ORDER. THE PACK LIST     00016\n*        IS THEN BUILT, TAKING PAGE BOUNDARIES INTO ACCOUNT. WHEN       00017\n*        THIS IS FINISHED, THE INDIVIDUAL RECORDS ARE REVERSED IN       00018\n*        ORDER TO PLACE THE MOST ACTIVE CLOSEST TO THE LPA PAGE         00019\n*        DIRECTORY ON THE LPA PAGING DATA SET.                          00020\n*                                                                       00021\n*        ALL MEMBERS OF LPALIB SHOULD BE INCLUDED IN THE PACKLIST AT    00022\n*        THE FRONT OF IEAPAK00. IF A MEMBER IS NOT INCLUDED IN THE      00023\n*        PACK LIST, IT GOES TO THE SPOT DESIRED FOR THE MOST ACTIVE     00024\n*        LPA MEMBERS.                                                   00025\n*                                                                       00026\n*  INVOKING JCL:                                                        00027\n* //PACKLIST EXEC PGM=PACKLIST                                          00028\n* //SYSPRINT DD  SYSOUT=A             REPORT ON ACTIVITY                00029\n* //SYSLPA   DD  DSN= DATA SET CONTAINING OUTPUT OF LISTLPA OF AMBLIST  00030\n* //SYSWORK  DD  TEMPORARY  WORK DATA SET                               00031\n* //SYSPSW   DD  DSN= DATA SET CONTAINING SAMPLES GATHERED BY PSWSAMP   00032\n* //SYSTEMP  DD  WORK TAPE, MUST BE TAPE BECAUSE IT IS READ BACKWARDS   00033\n* //SYSPUNCH DD  DSN= OUTPUT DATA SET FOR MODEL IEAPAK00                00034\n*                                                                       00035\n* HERE IS A JOBSTREAM THAT WORKED, GET RID OF THE '* ' TO RUN IT        00036\n* AFTER CHECKING ON THE EXISTANCE OF THE DATASETS CODED.                00037\n*                                                                       00038\n* //PAK00150 JOB (2100,56-D),'LLUEB 0679 T',CLASS=A,NOTIFY=LL00150      00039\n* //*---------------------------------------------------------------    00040\n* /*SETUP        PAK00150,2100-56-D,A200K,02                            00041\n* /*MESSAGE  LINDLUEBCK,3-0679,00.30,TD,WDPSC                           00042\n* //*---------------------------------------------------------------    00043\n* //PACKLIST EXEC PGM=PACKLIST                                          00044\n* //STEPLIB  DD DSN=WDPSC.SOFTLOAD,DISP=SHR                             00045\n* //SYSPRINT DD SYSOUT=A                                                00046\n* //SYSLPA   DD DSN=BRAD761.LPA,DISP=SHR                                00047\n* //SYSWORK  DD DSN=&&WORK,UNIT=SYSDA,SPACE=(CYL,1),DISP=(NEW,DELETE)   00048\n* //SYSPSW   DD DSN=PSWS,UNIT=TAPE16,DISP=OLD,                          00049\n* //            VOL=SER=015040                                          00050\n* /*MESSAGE  PACKLIST,PSWS             -015040-T-I-3-LIBRARY            00051\n* //*----------------------------------------------------------------   00052\n* //         DD DSN=PSWS,UNIT=AFF=SYSPSW,DISP=OLD,                      00053\n* //            VOL=SER=017019                                          00054\n* /*MESSAGE  PACKLIST,PSWS             -017019-T-I-3-LIBRARY            00055\n* //*----------------------------------------------------------------   00056\n* //SYSTEMP  DD DSN=PACKLIST.WORKTAPE,UNIT=TAPE16,DISP=(NEW,KEEP)       00057\n* /*MESSAGE  PACKLIST,PACKLIST.WORKTAPE-      -T-O-3-LIBRARY            00058\n* //*----------------------------------------------------------------   00059\n* //SYSPUNCH DD DSN=LL00150.PACKLIST(IEAPAK00),DISP=SHR                 00060\n         SPACE 5                                                        00061\n         LCLA  &PL                                                      00062\nTBS      DSECT                     TABLE ENTRY FOR LPA MODULE           00063\nTN       DS    CL8                 NAME                                 00064\nTS       DS    CL4                 START ADDRESS                        00065\nTL       DS    CL4                 LENGTH                               00066\nTF       DS    CL4                 NUMBER OF FAULTS                     00067\nTFL      DS    F                   FAULTS DIVIDED BY LENGTH             00068\nTBL      EQU   *-TBS               LENGTH OF TABLE ENTRY                00069\nLPAE     DSECT                     LPA LIST PRINT SEGMENT               00070\nLN       DS    CL8                 MODULE NAME                          00071\n         DS    C                                                        00072\nLX       DS    0CL17               TRANSLATE NEXT 17 BYTES              00073\nLS       DS    CL6                 START ADDRESS                        00074\n         DS    CL4                                                      00075\nLL       DS    CL6                 LENGTH                               00076\n         DS    C                                                        00077\n         REGISTER                                                       00078\nPACKLIST START 0                                                        00079\n         SAVE  (14,12)            SAVE ALL REGS                         00080\n         BAL   R12,80(,R15)        BRANCH AROUND SAVE                   00081\n         USING *,R13               WILL ALSO BE BASE                    00082\n         DS    18F                 SAVE AREA                            00083\n         ST    R12,8(,R13)         FORWARD CHAIN                        00084\n         ST    R13,4(,R12)         BACK CHAIN                           00085\n         LR    R13,R12             NOW POINT TO OUR SAVE AREA           00086\n         SPACE 3                                                        00087\n         OPEN  (SYSLPA,(INPUT))    INPUT IS AMBLIST OUTPUT              00088\n         TM    SYSLPA+48,X'10'     OPEN  SUCCESSFUL?                    00089\n         LA    R4,101                                                   00090\n         BZ    ABEND               NO  USER ABEND 101                   00091\nIT050    GET   SYSLPA,PI           SEARCH FOR NUMERIC SECTION... GET    00092\n         CLI   CC,C'1'          Q. TITLE PAGE                           00093\n         BNE   IT050               NO... GET NEXT PRINT IMAGE           00094\n         CLI   CC+31,C'N'       Q. N FOR START OF NUMERICAL LISTING     00095\n         BNE   IT050               NO... MUST STILL BE IN ALPHABETIC    00096\n         USING TBS,R9              TABLE DSECT                          00097\n         GETMAIN EU,LV=96000,A=TAB GET THE  TABLE WORK AREA             00098\n         L     R9,TAB              POINT TO IT                          00099\nIT100    GET   SYSLPA,PI           READ PRINT IMAGE                     00100\n         CLI   CC,X'40'         Q. DETAIL LINE                          00101\n         BNE   IT100               NO... IGNORE                         00102\n         LA    R1,S1               PIINT TO FIRST SEGMENT               00103\n         BAL   14,IT200            ADD TO TABLE                         00104\n         LA    R1,S2               POINT TO SECOND SEGMENT              00105\n         BAL   R14,IT200              CONVERT                           00106\n         B     IT100               GET NEXT RECORD                      00107\n         SPACE                                                          00108\n         USING LPAE,R1             SEGMENT DSECT                        00109\nIT200    CLI   LL,X'40'         Q. BLANK LENGTH (NOT MODULE NAME)       00110\n         BCR   8,R14              YES... IGNORE                         00111\n         XC    TF,TF               CLEAR COUNT COUNTER                  00112\n         MVC   TN,LN               SAVE MODULE NAME                     00113\n         PACK  LPAT,LL(6)                                               00114\n         AP    LPATOTAL,LPAT                                            00115\n         TR    LX,TOBIN            CONVERT START AND LENGTH TO BIN      00116\n         PACK  TS+1,LS(7)         SAVE START ADDRESS                    00117\n         PACK  TL+1,LL(7)              LENGTH                           00118\nONETIME  NOP   ITEND                    ONE TIME SWITCH                 00119\n         OI    ONETIME+1,X'F0'          CHANGE TO BRANCH                00120\n         MVC   LPALOW,TS                SAVE LPA LOW                    00121\n         MVI   LPALOW,0                                                 00122\nITEND    EQU   *                                                        00123\n         LA    R9,TBL(,R9)         POINT TO NEXT TABLE ENTRY            00124\n         BR    R14                 RETURN                               00125\n         SPACE 3                                                        00126\nIT900    S     R9,TAB+4            SET END OF TABLE                     00127\n         ST    R9,TAB+8            EOD(SYSLPA)... SAVE TABLE END        00128\n         L     R1,TS               LAST MOD START ADDR                  00129\n         A     R1,TL               ADD LENGTH OF MOD                    00130\n         LA    R1,0(,R1)                                                00131\n         ST    R1,LPAHI            SAVE LPA HIGH ADDR                   00132\n         CLOSE SYSLPA             DON'T NEED THIS ANYMORE               00133\n         SPACE                                                          00134\n         L     R9,16              CVT ADDR                              00135\n         L     R9,356(,R9)        PVT ADDR                              00136\n         LH    R8,26(R9)          CSA LOW -HIGH 16 BITS                 00137\n         SLL   R8,8              ADD LOW 8 BITS                         00138\n         LA    R8,0(,R8)          ZERO HIGH BYTE                        00139\n         ST    R8,SPALOW          SAVE                                  00140\n         EJECT                                                          00141\n         OPEN  (SYSPSW,(INPUT))   PROCESS  COUNT DATA                   00142\n         LA    R4,102                                                   00143\n         TM    SYSPSW+48,X'10'    OPEN SUCCESSFUL?                      00144\n         BZ    ABEND                                                    00145\nR100      GET   SYSPSW                                                  00146\n         LR    R5,R1                                                    00147\n         LA    R6,32                                                    00148\n         SLR   R5,R6                                                    00149\n          LH    R7,SYSPSW+62                                            00150\n         AR    R7,R5                                                    00151\nR120     BXH   R5,R6,R100                                               00152\n          TM    2(R5),X'70'                                             00153\n          BZ    R120                                                    00154\n         L     R12,4(,R5)          GET ADDR                             00155\n         LA    R12,0(,R12)                                              00156\n         C     R12,SPALOW       Q. IN ADDRESS SPACE AREA                00157\n         BNL   R150                NO...                                00158\n         AP    ASCTR,=P'1'         BUMP COUNTER                         00159\n         B     R120                READ AGAIN                           00160\nR150     C     R12,LPALOW       Q. IN CSA                               00161\n         BNL   R200                NO...                                00162\nR160     AP    CSACTR,=P'1'       BUMP CSA COUNTER                      00163\n         B     R120                GET ANOTHER TRACE RECORD             00164\nR200     C     R12,LPAHI        Q. ABOVE LPA                            00165\n         BNL   R160                YES... COUNT AS CSA                  00166\n         AP    LPACTR,=P'1'       BUMP LPA COUNTER                      00167\n         LM    R9,R11,TAB          GET TABLE LIMITS                     00168\n         SR    R9,R10                                                   00169\nR250     BXH   R9,R10,R160                                              00170\n         C     R12,TS           Q. EXCEED MODULE START                  00171\n         BNL   R250                                                     00172\n         SR    R9,R10                                                   00173\n         L     R12,TF                                                   00174\n         LA    R12,1(,R12)    BUMP COUNT COUNT BY ONE                   00175\n         ST    R12,TF              STORE RESULT                         00176\n         B     R120                GET NEXT RECORD                      00177\nR900      EQU   *                                                       00178\n         SPACE                                                          00179\n         CLOSE SYSPSW                                                   00180\n         EJECT                                                          00181\n          LM    R9,R11,TAB    GET TABLE LIMITS                          00182\n         SR    R9,R10                                                   00183\nR910     BXH   R9,R10,R920         POINT TO NEXT ENTRY                  00184\n         L     R7,TF              GETY NUMBER OF FAULTS                 00185\n         M     R6,=F'100000'         ALLOW 5 DECIMAL PLACES             00186\n         D     R6,TL               CALC FAULTS / LENGTH                 00187\n         ST    R7,TFL              SAVE ANSWER                          00188\n         B     R910                DO FOR NEXT ENTRY                    00189\n         SPACE                                                          00190\n*  ORDER TABLE BY DESCENDING FAULTS/BYTE (TFL)                          00191\nR920     L     R8,TAB+8      SAVE ACTUAL END OF TABLE                   00192\nR930     LM    R9,R11,TAB    SET UP TO BEGIN THE SORT                   00193\n         MVI   SORTTEST,0    HAS-SOMETHING-BEEN-MOVED BYTE              00194\nR940     LR    R5,R9                                                    00195\n         BXH   R9,R10,R960   INCREMENT FOR NEXT ENTRY                   00196\n         CLC   TFL,20(R5)    COMPARE ON FAULTS PER BYTE                 00197\n         BH    R950          EXCHANGE THE ENTRIES                       00198\n         BNE   R940          LOW                                        00199\n         CLC   TL,12(R5)     EQUAL, COMPARE ON LENGTH                   00200\n         BNH   R940                                                     00201\nR950     TS    SORTTEST      SET THE HAS-SOMETHING-BEEN-MOVED BYTE      00202\n         XC    0(TBL,R9),0(R5) EXCHANGE THE ENTRIES                     00203\n         XC    0(TBL,R5),0(R9) EXCHANGE THE ENTRIES                     00204\n         XC    0(TBL,R9),0(R5) EXCHANGE THE ENTRIES                     00205\n         B     R940                                                     00206\nR960     SR    R11,R10       SHRINK THE TABLE FOR A TIME                00207\n         ST    R11,TAB+8                                                00208\n         TS    SORTTEST                                                 00209\n         BNZ   R930                                                     00210\n         ST    R8,TAB+8      RESET THE END OF THE TABLE                 00211\n         EJECT                                                          00212\n         ED    TASCCTR,ASCTR     SHOW ADDRESS SPACE FAULTS              00213\n         ED    TCSACTR,CSACTR                                           00214\n         ED    TLPACTR,LPACTR      LPA                                  00215\n         SPACE 2                                                        00216\n         OPEN (SYSPRINT,(OUTPUT),SYSWORK,(OUTPUT))                      00217\n         LA    R4,103                                                   00218\n         TM    SYSPRINT+48,X'10'    OPEN OK?                            00219\n         BZ    ABEND                NO   USER ABEND 103                 00220\n         LA    R4,104                                                   00221\n         TM    SYSWORK+48,X'10'   OPEN OK?                              00222\n         BZ    ABEND                NO   USER ABEND 104                 00223\n         PUT   SYSPRINT,T           PRINT TITLE                         00224\n         ED    LPASIZE,LPATOTAL                                         00225\n         PUT   SYSPRINT,ST2                                             00226\n         PUT   SYSPRINT,ST               SUBTITLE                       00227\n         MVI   ST,C'1'                                                  00228\n         EJECT                                                          00229\n         LA    R7,56               LINES PER PAGE                       00230\n         LA    R6,CS+1             CARD IMAGE POINTER                   00231\n         LM    R9,R11,TAB        RESET TABLE LIMITS                     00232\n         SR    R9,R10                                                   00233\n         ST    R9,SAVE9                                                 00234\nP100     L     R9,SAVE9                                                 00235\n         MVI   FITNOFIT,0                                               00236\nP150     BXH   R9,R10,P900                                              00237\n         CLI   TF,X'FF'       Q. USED ENTRY                             00238\n         BE    P150              YES                                    00239\n* WHEN THIS THING IS WORKING PRINT IT HERE BY B P300                    00240\n         ST    R9,SAVE9            SAVE CURR LOC                        00241\n          L     R1,TL                                                   00242\n          N     R1,=F'4095'                                             00243\n          A     R1,PAGELEN                                              00244\n         C     R1,=F'4096'         OVER A PAGE ?                        00245\n         BNH   NOTOVER                                                  00246\n*  TRY TO FIND ENTRY WHICH WILL FIT                                     00247\n         SR   R9,R10                                                    00248\n         ST   R9,SAVE9                                                  00249\n          MVI   FITNOFIT,255                                            00250\nP225     BXH   R9,R10,P230         TRY TO FIND A FIT                    00251\n         CLI   TF,X'FF'         Q. ALREADY USED FLAG                    00252\n         BE    P225     YES.... DO NOT USE                              00253\n         L     R1,PAGELEN          CURRENT PAGELEN                      00254\n         A     R1,TL               LEN OF MOD                           00255\n         C     R1,=F'4096'       Q.FIT                                  00256\n         BH    P225                                                     00257\n         B     NOTOVER                                                  00258\n* AGAIN, WHEN WORKING, NOPRINT JUST PUNCH AND USED                      00259\nP230     EQU   *                                                        00260\n         SR    R9,R10                                                   00261\n         S     R1,TL                                                    00262\n         ST    R1,PAGELEN                                               00263\nP231     MVI   FITNOFIT,0                                               00264\n         BCTR  R6,0                MOVE BACK TO COMMA                   00265\n         MVI   0(R6),C')'          MOVE IN CLOSE PAREN                  00266\n         CLI   FIRSTPG,X'FF'      Q. FIRST PAGE GROUP                   00267\n         BE    P232     YES.... SKIP COMMA                              00268\n         MVI   1(R6),C','          MOVE IN COMMA                        00269\nP232     PUT   SYSWORK,CS         PUNCH CARD                            00270\n         MVI   FIRSTPG,X'00'       SW TO FALSE                          00271\n         MVI   CS,X'40'            TO CLEAR                             00272\n         MVC   CS+1(79),CS         CLEAR                                00273\n         MVI   CS,C'('             OPEN PAREN - NEXT CARD               00274\n         LA    R6,CS+1             RESET CARD POINTER                   00275\n         PUT   SYSPRINT,PGB                                             00276\n         BCTR  R7,0                                                     00277\nP235     L     R1,PAGELEN                                               00278\n         N     R1,=F'4095'                                              00279\n         ST    R1,PAGELEN                                               00280\n         B     P100                                                     00281\nNOTOVER  ST    R1,PAGELEN          CURRENT PAGE LEN                     00282\n         MVC   0(8,R6),TN          MOVE MODULE NAME TO PUNCH            00283\nP250     LA    R6,1(,R6)           NEXT CHAR (KNOW FIRST WASN'T BLANK   00284\n         CLI   0(R6),X'40'      Q. BLANK                                00285\n         BNE   P250                NO... CONTINUE SEARCH                00286\n         MVI   0(R6),C','          YES... COMMA AFTER NAME              00287\n         LA    R6,1(,R6)           POINT PAST COMMA                     00288\n         C     R6,CE            Q. CARD FILLED                          00289\n         BL    P300                NO... GO PRINT                       00290\n         PUT   SYSWORK,CS         PUNCH CARD IMAGE                      00291\n         LA    R6,CS+1             RESET CARD POINTER                   00292\n         MVI   CS,X'40'            INSURE LEADING PAREN GONE            00293\n         MVC   CS+1(79),CS         BLANK REST OF CARD IMAGE             00294\nP300     EQU   *                                                        00295\n         MVC   PN,TN               PRINT MODULE NAME                    00296\n         UNPK  PS(7),TS+1                START ADDRESS                  00297\n         MVI    TF,X'FF'                                                00298\n         UNPK  PL(7),TL+1                LENGTH                         00299\n         TR    PT,TOHEX-240                                             00300\n         MVI   PS+6,X'40'          BLANK GARBAGE                        00301\n         MVI   PL+6,X'40'          BLANK GARBAGE                        00302\n         MVC   PF(18),=X'40202020206B2020214020214B2020202020'          00303\n         L     R8,TF               GET NUMBER FAULTS                    00304\n         LA    R8,0(,R8)                                                00305\n         CVD   R8,DWD                              IN DECIMAL           00306\n         ED    PF,DWD+4                            READABLE             00307\n         L     R8,TFL              GET FACTOR                           00308\n         CVD   R8,DWD                         IN DECIMAL                00309\n         ED    PFL,DWD+4                      READABLE                  00310\n         BCTR  R7,0                                                     00311\n         LTR   R7,R7                                                    00312\n         BP    P400                                                     00313\n         LA    R7,56                                                    00314\n         PUT   SYSPRINT,ST               SUBTITLE                       00315\nP400     EQU   *                                                        00316\n         PUT   SYSPRINT,P          PRINT DETAIL LINE                    00317\n         L     R1,PAGELEN                                               00318\n         N     R1,=F'4095'                                              00319\n         BZ    P231                                                     00320\n         ST    R1,PAGELEN                                               00321\nP480     CLI   FITNOFIT,255                                             00322\n         BE    P225                                                     00323\n         B     P100                LOOK FOR NEXT ENTRY                  00324\n         EJECT                                                          00325\nP900     BCTR  R6,0                PUNCH LAST CARD BACK UP POINTER      00326\n         MVI   0(R6),C')'          MOVE IN TERMINATING PAREN            00327\n         MVI   1(R6),C','          WANT COMMA ON LAST CARD              00328\n         PUT   SYSWORK,CS                                               00329\n         CLOSE SYSPRINT                                                 00330\n         CLOSE SYSWORK                                                  00331\n         EJECT                                                          00332\n         OPEN  (SYSTEMP,(RDBACK),SYSPUNCH,(OUTPUT))                     00333\n         LA    R4,105                                                   00334\n         TM    SYSTEMP+48,X'10'     SUCCESSFUL OPEN                     00335\n         BZ    ABEND                                                    00336\n         LA    R4,106                                                   00337\n         TM    SYSPUNCH+48,X'10'                                        00338\n         BZ    ABEND                                                    00339\nS100     L     R9,TAB              USE TABLE TO STORE CARDS             00340\nS110     GET   SYSTEMP,(R9)       READ PAGE GROUP BACKWARDS             00341\n         CLI   0(R9),C'('        Q. FIRST CARD IN GROUP                 00342\n         BE    S150                YES...GO PUNCH                       00343\n         CLI   0(R9),C' '        Q. INTERMEDIATE CARD                   00344\n         BE    S130                YES...SAVE IT                        00345\n         CLI   0(R9),C')'        Q. LAST CARD IN PAGE GROUP             00346\n         BNE   ZERO                NO...CONFUSED--BLOWUP                00347\n         MVI   CPARSW,X'FF'        SET CLOSE PAREN SW TO TRUE           00348\n         B     S110                BYPASS CARD IN ERROR                 00349\n*  ERROR IN CARD IS IT IS A CARD WITH ONLY A OPEN PAREN AND COMMA       00350\nS130     LA    R6,54(R9)           EARLIEST BLANK POS                   00351\n         LA    R9,80(R9)           LOC NEXT CARD                        00352\n         TM    CPARSW,X'FF'      Q. NEED CLOSE PAREN                    00353\n         BNO   S110                NO...BYPASS                          00354\n         MVI   CPARSW,X'00'        SET CLOSE PAREN SW TO FALSE          00355\nS135     CLI   0(R6),X'40'       Q. BLANK                               00356\n         BNE   S140                NO...TRY NEXT POS                    00357\n         BCTR  R6,0                BACK ONE                             00358\n         MVI   0(R6),C')'          CLOSE PAREN                          00359\n         MVI   1(R6),C','          COMMA                                00360\n         B     S110                GET NEXT CARD                        00361\nS140     LA    R6,1(,R6)          NEXT CARD POS                         00362\n         CR    R6,R9             Q. AT NEXT CARD                        00363\n         BL    S135                NO...CONTINUE SEARCH                 00364\nMESSUP   DC    H'0'                ERROR IN SEARCHING CARD              00365\nS150     TM    CPARSW,X'FF'       Q. STILL NEED CLOSE PAR               00366\n         BNO   S154                 NO...DO NOT SET UP                  00367\n         LA    R6,53(R9)            ADDR OF ONLY CARD IN GROUP          00368\nS152     LA    R6,1(R6)             EARLIEST BLANK POS                  00369\n         CLI   0(R6),X'40'        Q. BLANK                              00370\n         BNE   S152                 NO...TRY NEXT POS                   00371\n         BCTR  R6,0                 BACK ONE                            00372\n         MVI   0(R6),C')'           CLOSE PAREN                         00373\n         MVI   1(R6),C','           COMMA                               00374\n         MVI   CPARSW,X'00'         CLOSE PAR SW TO FALSE               00375\n         B     S156                 MUST BE ONLY ONE CARD               00376\nS154     L     R7,TAB               LAST CARD IN GROUP                  00377\n         CR    R7,R9              Q.FIRST AND LAST THE SAME             00378\n         BE    S156                YES...NO SWITCH                      00379\n         XC    0(80,R7),0(R9)      SWITCH                               00380\n         XC    0(80,R9),0(R7)             FIRST AND                     00381\n         XC    0(80,R7),0(R9)                       LAST                00382\nS156     L     R7,TAB               FIRST CARD                          00383\n         LA    R8,80                LEN OF CARD                         00384\nS160     PUT   SYSPUNCH,0(R7)       PUNCH CARD                          00385\n         BXLE  R7,R8,S160           LOOP THRU PAGE GROUP                00386\n         B     S100                 NEXT GROUP                          00387\nS900     CLOSE SYSTEMP                                                  00388\n         CLOSE SYSPUNCH                                                 00389\n         EJECT                                                          00390\n         L     R13,4(,R13)                                              00391\n         RETURN (14,12),RC=0                                            00392\n         SPACE 3                                                        00393\nABEND    EQU *                                                          00394\n         ABEND (4),DUMP,STEP,USER                                       00395\nP        EQU   *                   PRINT LINE                           00396\n         DC    X'40'               SINGLE SPACE                         00397\nPN       DS    CL8                 MODULE NAME                          00398\n         DC    CL1' '                                                   00399\nPT       DS    0CL14               TRANSLATE TO HEX                     00400\nPS       DS    CL7                      MODULE START ADDRESS            00401\nPL       DS    CL7                      LENGTH OF MPOULE                00402\nPE       DS    0CL18               MOVE EDIT MASK HERE                  00403\nPF       DS    CL9                 NUMBER OF FAULTS                     00404\nPFL      DS    CL9                 FACTOR                               00405\n         DC    CL2' '                                                   00406\nWLEN     DC    CL20' '                                                  00407\nBLANKS   DC    CL20' '                                                  00408\nT        DC    C'1OTHER='                                               00409\nTASCCTR  DC    X'40206B2020206B202021'                                  00410\n         DC    C',CSA='                                                 00411\nTCSACTR  DC    X'40206B2020206B202021'                                  00412\n         DC    C',LPA='                                                 00413\nTLPACTR  DC    X'40206B2020206B202021'                                  00414\n         DC    C'.                        '                             00415\nLPATOTAL DC    PL5'0'                                                   00416\nST2      DC    C'0        LPASIZE IS '                                  00417\nLPASIZE  DC    X'402020206B2020206B202021'                              00418\n         DC    C'   BYTES                                       '       00419\n         DC    23C' '                                                   00420\nST       DC    C'0    NAME  START LENGTH     COUNTS      C/L'           00421\n         DC    CL23' '                                                  00422\nPGB      DC    32C' ',8C'*',30C' '                                      00423\nPI       EQU   *                   PRINT IMAGE FROM SYSLPA HERE         00424\nCC       DS    C                   PRINTER CARRAIGE CONTROL CHARACTER   00425\nS1       DS    CL60                SEGMENT ONE                          00426\nS2       DS    CL60                SEGMENT TWO                          00427\nCS       DC    C'('                                                     00428\nCEN      DC    79X'40'                                                  00429\nCE       DC    A(CS+54)                                                 00430\nPAGELEN  DC    F'0'                                                     00431\nTOHEX    DC    C'0123456789ABCDEF'                                      00432\nTOBIN    DC    256X'00'                                                 00433\n         ORG   TOBIN+X'C1'         POSITION TO 'A'                      00434\n         DC    X'0A0B0C0D0E0F'     TRANSLATE A-F                        00435\n         ORG   TOBIN+X'F0'         POSITION AT '0'                      00436\n         DC    X'00010203040506070809'                                  00437\n         ORG                                                            00438\n         DS    0F                                                       00439\nDWD      DS    D                                                        00440\nTAB      DC    A(0,TBL,0)                                               00441\n         DS    0F                                                       00442\nZERO     DC    F'0'                                                     00443\nSAVE9    DC    F'0'                                                     00444\nSPALOW   DC    X'00000000'                                              00445\nLPALOW   DC    X'7FFFFFFF'                                              00446\nLPAHI    DC    X'00000000'                                              00447\nHIVALUE  DC    X'7FFFFFFF'                                              00448\nLPAT     DC  PL3'0'                                                     00449\nFITNOFIT DC    X'00'                                                    00450\nSORTTEST DC    H'0'                                                     00451\nASCTR    DC    PL4'0'                                                   00452\nCSACTR   DC    PL4'0'                                                   00453\nLPACTR   DC    PL4'0'                                                   00454\nCPARSW   DC    X'00'                                                    00455\nFIRSTPG  DC    X'FF'     FIRST PAGE GROUP SW=TRUE                       00456\n         LTORG                                                          00457\n         PRINT NOGEN                                                    00458\nSYSPRINT DCB   DDNAME=SYSPRINT,DSORG=PS,MACRF=PM,RECFM=FBA,LRECL=60,   X00459\n               BLKSIZE=60                                               00460\nSYSLPA   DCB   DDNAME=SYSLPA,DSORG=PS,MACRF=GM,RECFM=FBA,EODAD=IT900    00461\nSYSWORK  DCB   DDNAME=SYSTEMP,DSORG=PS,MACRF=PM,RECFM=FB,LRECL=80,     X00462\n               BLKSIZE=3040                                             00463\nSYSPSW DCB DDNAME=SYSPSW,DSORG=PS,MACRF=GL,RECFM=FB,EODAD=R900          00464\nSYSTEMP  DCB   DDNAME=SYSTEMP,DSORG=PS,MACRF=GM,EODAD=S900              00465\nSYSPUNCH DCB   DDNAME=SYSPUNCH,DSORG=PS,MACRF=PM,RECFM=FB,LRECL=80,    X00466\n               BLKSIZE=3040                                             00467\n         END                                                            00468\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "PANELS": {"ttr": 28680, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x00\\x7f\\x00\\x88\\x00\\x7f\\x12\\x00\\n\\xaa\\n\\xaa\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf2\\xf7\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-01-07T00:00:00", "modifydate": "1988-01-07T12:00:00", "lines": 2730, "newlines": 2730, "modlines": 0, "user": "FILE270"}, "text": "./ ADD NAME=BLKPANEL 0103-86246-86246-0943-00019-00017-00000-LL02150\n)ATTR DEFAULT(%+_)\n      + TYPE(TEXT) INTENS(LOW) SKIP(ON)\n      % TYPE(TEXT) INTENS(HIGH) SKIP(ON)\n)BODY\n+wdpsc%BLKING+utility+\n+&BLKMSG\n+Enter record length ==>_LRECL   +\n+\n+Enter # of records  ==>_FILESIZE+\n+\n+\n+\n)INIT\n)PROC\nVER (&LRECL,NONBLANK)\nVER (&FILESIZE,NONBLANK)\nVER (&LRECL,NUM)\nVER (&FILESIZE,NUM)\n)END\n./ ADD NAME=CUTHELP  0110-86252-86253-1107-00025-00001-00000-GS00150\n%TUTORIAL ---------------  CUT EDIT MACRO INFORMATION  ---------------- TUTORIAL\n%COMMAND ===>_zcmd                                                             +\n\n+\n  ISPF/PDF EDIT MACRO TO WRITE LINES FROM A FILE TO THE USER\n  PROFILE POOL FOR LATER INCLUSION BY THE%PASTE+MACRO.\n\n  TO RUN:\n    ENTER%CUT+ON THE COMMAND LINE AND USE THE%C+OR%M+LINE COMMANDS\n    (IN ANY FORM) TO SELECT THE LINES TO BE CUT.\n+\n    IF THE%M+LINE COMMAND IS USED, THE LINES WILL BE DELETED.\n+\n    A PARAMETER OF%R+OR%REPLACE+CAN BE SPECIFIED TO REPLACE ANY\n    PREVIOUSLY CUT LINES (THAT HAVE NOT YET BEEN PASTED) WITH THE\n    NEWLY SELECTED LINES.  OTHERWISE, THE SELECTED LINES WILL BE\n    ADDED TO ANY PREVIOUSLY CUT LINES.\n+\n    AN ARBITRARY LIMIT OF 500 LINES IS SET IN THE MACRO BUT THIS\n    CAN BE CHANGED BY PROVIDING A NEW LIMIT ON THE MACRO CALL.\n    FOR EXAMPLE,%TO PROCESS UP TO 1000 LINES+ENTER%CUT 1000+ON THE\n    COMMAND LINE.  BE AWARE THAT EACH LINE GETS STORED IN YOUR\n    PROFILE.\n+\n)END\n./ ADD NAME=DOCADDH  0101-86171-86171-1814-00027-00026-00000-KX00150\n%TUTORIAL -------------  DOCSYS Add an Entry Help     ----------------- TUTORIAL\n%NEXT SELECTION ===>_ZCMD                               %(OR PRESS PF1 FOR HELP)\n%\n+ 1. Enter a description of the new document or index. This will be\n+    added to the current index. These entries are usually indented by\n+    about four spaces. There may be 1, 2 or 3 lines for the description.\n%\n+ 2. Enter the dataset name where the document is to be located. It may\n+    be a member of a document system library or another library or even\n+    a sequential file. The document system users must have read access\n+    to the document you specify. If you wish to add a new index level\n+    to the system, simply change the type field to \"INDEXES\" and enter\n+    a name for the new index in the member field. Also specify if the\n+    new index is to have 1, 2, or 3 lines per entry. If the document or\n+    index you specify does not exist, a sample document or index will\n+    be used to create the document or index and you will be transferred\n+    to ISPF EDIT to finish it. When you are satisfied with the new\n+    document, use the \"END\" key to save it, and it will be added to the\n+    current index. If the document already exists, you will be asked to\n+    change the member name or press ENTER to add it anyway. In this case,\n+    the document will not be edited.\n+\n+ 3. IF your document already exists in another library, you may change\n+    the SAMPLE name to create the new document from the original.\n)PROC\n   &ZUP = TWSD\n)END\n./ ADD NAME=DOCADD1  0105-86163-86174-1811-00043-00040-00000-KX00150\n)ATTR\n# TYPE(INPUT) INTENS(LOW) CAPS(OFF) JUST(ASIS)\n_ TYPE(INPUT) INTENS(LOW) CAPS(ON)\n% TYPE(TEXT) INTENS(LOW)\n+ TYPE(TEXT) INTENS(HIGH)\n)BODY\n%----------------------    Request to Add a Document  --------------------------\n%COMMAND ===>_ZCMD\n%\n% Enter 1 line description for the new index entry:\n%\n+==>#descl1\n%\n+Index being updated is '&DOCSLVL1..&DOCSLVL2..INDEXES(&DOCSMEM)'\n%\n% Verify the following and press+ENTER%to add the new entry:\n%\n%New document or index to add is:\n%   PROJECT+===>_lvl1    %\n%   LIBRARY+===>_lvl2    +\n%   TYPE   +===>_lib     % (If INDEXES, enter lines per item ==>_Z%)\n%   MEMBER +===>_MEMBER  %\n%\n%OTHER PARTITIONED OR SEQUENTIAL DATASET:\n%   DATASET NAME +===>_DOCDSN                                                  %\n%\n+Sample Document?==>_sampdoc\n% (If a sample is specified, it will be used to initialize the document.)\n)INIT\n .HELP = docaddh\n .ZVARS = '(LCNT)'\n)PROC\n IF (&LIB = INDEXES)\n   VER (&LCNT,LIST,1,2,3)\n   VER (&LCNT,NB)\n VER (&DOCDSN,DSNAME)\n VER (&SAMPDOC,DSNAME)\n VER (&LVL1,DSNAME)\n VER (&LVL2,DSNAME)\n VER (&LIB,DSNAME)\n VER (&MEMBER,NAME)\n VPUT DESCL1 SHARED\n)END\n./ ADD NAME=DOCADD2  0105-86163-86174-1819-00044-00041-00000-KX00150\n)ATTR\n# TYPE(INPUT) INTENS(LOW) CAPS(OFF) JUST(ASIS)\n_ TYPE(INPUT) INTENS(LOW) CAPS(ON)\n% TYPE(TEXT) INTENS(LOW)\n+ TYPE(TEXT) INTENS(HIGH)\n)BODY\n%----------------    DOCADD Dialog to add a document  --------------------------\n%COMMAND ===>_ZCMD\n%\n% Enter 2 lines of description for the new index entry:\n%\n+==>#descl1\n+==>#descl2\n%\n+Index being updated is '&DOCSLVL1..&DOCSLVL2..INDEXES(&DOCSMEM)'\n%\n% Verify the following and press+ENTER%to add the new entry:\n%\n%New document or index to add is:\n%   PROJECT+===>_lvl1    %\n%   LIBRARY+===>_lvl2    +\n%   TYPE   +===>_lib     % (If INDEXES, enter lines per item ==>_Z%)\n%   MEMBER +===>_MEMBER  %\n%\n%OTHER PARTITIONED OR SEQUENTIAL DATASET:\n%   DATASET NAME +===>_DOCDSN                                                  %\n%\n+Sample Document?==>_sampdoc\n% (If a sample is specified, it will be used to initialize the document.)\n)INIT\n .HELP = DOCADDH\n .ZVARS = '(LCNT)'\n)PROC\n IF (&LIB = INDEXES)\n   VER (&LCNT,LIST,1,2,3)\n   VER (&LCNT,NB)\n VER (&DOCDSN,DSNAME)\n VER (&SAMPDOC,DSNAME)\n VER (&LVL1,DSNAME)\n VER (&LVL2,DSNAME)\n VER (&LIB,DSNAME)\n VER (&MEMBER,NAME)\n VPUT (DESCL1 DESCL2) SHARED\n)END\n./ ADD NAME=DOCADD3  0105-86163-86174-1820-00045-00042-00000-KX00150\n)ATTR\n# TYPE(INPUT) INTENS(LOW) CAPS(OFF) JUST(ASIS)\n_ TYPE(INPUT) INTENS(LOW) CAPS(ON)\n% TYPE(TEXT) INTENS(LOW)\n+ TYPE(TEXT) INTENS(HIGH)\n)BODY\n%----------------    DOCADD Dialog to add a document  --------------------------\n%COMMAND ===>_ZCMD\n%\n% Enter 3 lines of description for the new index entry:\n%\n+==>#descl1\n+==>#descl2\n+==>#descl3\n%\n+Index being updated is '&DOCSLVL1..&DOCSLVL2..INDEXES(&DOCSMEM)'\n%\n% Verify the following and press+ENTER%to add the new entry:\n%\n%New document or index to add is:\n%   PROJECT+===>_lvl1    %\n%   LIBRARY+===>_lvl2    +\n%   TYPE   +===>_lib     % (If INDEXES, enter lines per item ==>_Z%)\n%   MEMBER +===>_MEMBER  %\n%\n%OTHER PARTITIONED OR SEQUENTIAL DATASET:\n%   DATASET NAME +===>_DOCDSN                                                  %\n%\n+Sample Document?==>_sampdoc\n% (If a sample is specified, it will be used to initialize the document.)\n)INIT\n .HELP = DOCADDH\n .ZVARS = '(LCNT)'\n)PROC\n IF (&LIB = INDEXES)\n   VER (&LCNT,LIST,1,2,3)\n   VER (&LCNT,NB)\n VER (&DOCDSN,DSNAME)\n VER (&SAMPDOC,DSNAME)\n VER (&LVL1,DSNAME)\n VER (&LVL2,DSNAME)\n VER (&LIB,DSNAME)\n VER (&MEMBER,NAME)\n VPUT (DESCL1 DESCL2 DESCL3) SHARED\n)END\n./ ADD NAME=DOCEDIT  0104-86162-86190-1752-00052-00045-00000-KK00150\n)ATTR\n  _ TYPE(INPUT) CAPS(OFF) INTENS(HIGH) FORMAT(&MIXED)\n  | AREA(DYNAMIC) EXTEND(ON) SCROLL(ON) USERMOD(20)\n  ! TYPE(OUTPUT) INTENS(HIGH) PAD(-)\n 01 TYPE(DATAOUT) INTENS(LOW)\n 02 TYPE(DATAOUT) INTENS(HIGH)\n 03 TYPE(DATAOUT) SKIP(ON) /* FOR TEXT ENTER CMD. FIELD */\n 04 TYPE(DATAIN)  INTENS(LOW)  CAPS(OFF)\n 05 TYPE(DATAIN)  INTENS(HIGH) CAPS(OFF)\n 06 TYPE(DATAIN)  INTENS(LOW)  CAPS(IN)\n 07 TYPE(DATAIN)  INTENS(HIGH) CAPS(IN)\n 08 TYPE(DATAIN)  INTENS(LOW)  FORMAT(DBCS)\n 09 TYPE(DATAIN)  INTENS(LOW)  FORMAT(EBCDIC)\n 0A TYPE(DATAIN)  INTENS(LOW)  FORMAT(&MIXED)\n 20 TYPE(DATAIN)  INTENS(LOW) CAPS(IN) FORMAT(&MIXED)\n)BODY WIDTH(&ZWIDTH) EXPAND(//)\n%EDIT -----!ZTITLE -------------------/-/---------------------%COLUMNS!ZCL!ZCR%%\n%COMMAND ===>_ZCMD                    / /                     %SCROLL ===>_Z   %\n|ZDATA -------------------------------/-/--------------------------------------|\n|                                     / /                                      |\n| ------------------------------------/-/--------------------------------------|\n)INIT\n  .HELP = ISR20000         /* DEFAULT TUTORIAL NAME     */\n  .ZVARS = 'ZSCED'         /* SCROLL AMT VARIABLE NAME  */\n  &MIXED = MIX             /* SET FROMAT MIX            */\n  IF (&ZPDMIX = N)         /* IF EBCDIC MODE REQUESTED  */\n    &MIXED = EBCDIC        /*  SET FORMAT EBCDIC        */\n\n  IF (&FADSN \u00ac= &Z)\n    &ZCMD = COPY\n    .RESP = ENTER\n\n  IF (&FADSN = &Z)\n   IF (&FACMD \u00ac= &Z)\n    &ZCMD = &FACMD\n    &FACMD = &Z\n    VPUT FACMD SHARED\n    .RESP = ENTER\n\n)REINIT\n  REFRESH(ZCMD,ZSCED,ZDATA,ZTITLE,ZCL,ZCR)\n  .HELP = ISR20000         /* DEFAULT TUTORIAL NAME     */\n\n)PROC\n  &ZCURSOR = .CURSOR\n  &ZCSROFF = .CSRPOS\n  &ZLVLINE = LVLINE(ZDATA)\n\n)END\n\n/*  DYNAMIC AREA SCREEN WIDTH FROM PQUERY. (80,132,160)\n/*  DYNAMIC AREA SCREEN DEPTH FROM PQUERY. (24,32,43,27,60)\n./ ADD NAME=DOCPM1   0100-86188-86188-1731-00037-00037-00000-KK00150\n%----------------    &DOCSTITL PRINT REQUEST -----------------------------------\n%SELECT OPTION ===>_OPT                    +\n% VERIFY APPROPRIATE PARAMETERS BEFORE PRESSING ENTER.\n%\n% 1+-%SUBMIT JOB TO PRINT ON 3800 AT WDPSC VIA ROTATE 90\n+       ACCOUNT AND BIN ==>_PACCT    +\n+       JOB CLASS       ==>_Z+\n+       NAME FIELD      ==>_PPROG               +\n+       COPIES          ==>_Z+ (1-9)\n+       Print Size      ==>_Z+ (S,M,L)\n%\n% 2+-%COPY PRINT TO SYSOUT:\n+       SYSOUT CLASS    ==>_Z+\n+       DESTINATION     ==>_PDEST   +\n%\n% 3+-%PRINT ON CLUSTER PRINTER:\n+       LOCAL PRINTER ID==>_HPID    +\n+       DSPRINT OPTIONS ==>_DSPRTOPT\n+\n% YOU HAVE SELECTED TO PRINT THE FOLLOWING:\n+ &ENTRYDS1                                                                   +\n+ &ENTRYDS2                                                                   +\n+ &ENTRYDS3                                                                   +\n)INIT\n .ZVARS = '(PJOBC PCOPIES PSIZE PSOC)'\n  .HELP = DOCS1HLP\n  IF (&PSIZE = &Z)\n      &PSIZE = 'S'\n)PROC\n  VER(&PSIZE,LIST,S,M,L)\n  &SEL = TRANS( TRUNC (&OPT,'.')\n                1,'CMD(%DOCR90)'\n                2,'CMD(%DOCSOP)'\n                3,'CMD(%DOCLCL)'\n                *,'?'\n                )\n)END\n./ ADD NAME=DOCPM2   0100-86188-86188-1802-00033-00033-00000-KX00150\n%----------------    &DOCSTITL PRINT REQUEST -----------------------------------\n%SELECT OPTION ===>_OPT                    +\n% VERIFY APPROPRIATE PARAMETERS BEFORE PRESSING ENTER:\n%\n% 1+-%SUBMIT JOB TO PRINT ON 3800 AT WDPSC VIA ROTATE 90\n+       ACCOUNT AND BIN ==>_PACCT    +\n+       JOB CLASS       ==>_Z+\n+       NAME FIELD      ==>_PPROG               +\n+       COPIES          ==>_Z+ (1-9)\n+       Print Size      ==>_Z+ (S,M,L)\n%\n% 2+-%COPY PRINT TO SYSOUT:\n+       SYSOUT CLASS    ==>_Z+\n+       DESTINATION     ==>_PDEST   +\n%\n+\n% YOU HAVE SELECTED TO PRINT THE FOLLOWING:\n+ &ENTRYDS1                                                                   +\n+ &ENTRYDS2                                                                   +\n+ &ENTRYDS3                                                                   +\n)INIT\n .ZVARS = '(PJOBC PCOPIES PSIZE PSOC)'\n  IF (&PSIZE = &Z)\n      &PSIZE = 'S'\n  .HELP = DOCS2HLP\n)PROC\n  VER(&PSIZE,LIST,S,M,L)\n  &SEL = TRANS( TRUNC (&OPT,'.')\n                1,'CMD(%DOCR90)'\n                2,'CMD(%DOCSOP)'\n                *,'?'\n                )\n)END\n./ ADD NAME=DOCPM3   0100-86188-86188-1805-00030-00030-00000-KX00150\n%----------------    &DOCSTITL PRINT REQUEST -----------------------------------\n%COMMAND ===>_OPT                                                      +\n% VERIFY APPROPRIATE PARAMETERS BEFORE PRESSING ENTER\n%  TO SUBMIT JOB TO PRINT ON 3800 AT WDPSC VIA ROTATE 90:\n%\n+       ACCOUNT AND BIN ==>_PACCT    +\n+       JOB CLASS       ==>_Z+\n+       NAME FIELD      ==>_PPROG               +\n+       COPIES          ==>_Z+ (1-9)\n+       Print Size      ==>_Z+ (S,M,L)\n%\n+\n% YOU HAVE SELECTED TO PRINT THE FOLLOWING:\n+ &ENTRYDS1                                                                   +\n+ &ENTRYDS2                                                                   +\n+ &ENTRYDS3                                                                   +\n)INIT\n .ZVARS = '(PJOBC PCOPIES PSIZE)'\n  IF (&PSIZE = &Z)\n      &PSIZE = 'S'\n  .HELP = DOCS3HLP\n)PROC\n  VER(&PSIZE,LIST,S,M,L)\n  IF (&OPT = &Z)\n      &OPT = '2'\n  &SEL = TRANS( TRUNC (&OPT,'.')\n                2,'CMD(%DOCR90)'\n                *,'?'\n                )\n)END\n./ ADD NAME=DOCS0HLP 0100-84017-84017-1636-00017-00017-00000-JS02150\n%TUTORIAL  --------------   &DOCSTITL --------------------------------%TUTORIAL+\n\n%                    -------------------------------------\n                     |          Selection Menus          |\n                     -------------------------------------\n+\n      The selection menus of the documentation system display a list of\n  items which you may request further information about or for which you\n  may request hardcopy listings of detailed information. If more items\n  are available than can be displayed on one screen, use your scroll\n  forward%(DOWN)+key to display the other items. To obtain more detailed\n  information for an item, enter an%\"S\"+in the field to the left of the\n  item. To obtain a hardcopy listing of the information, enter a%\"P\"+to\n  the left of the item and answer the questions which will be displayed\n  on the print request panel concerning print format and routing for\n  that document.\n)END\n./ ADD NAME=DOCS1HLP 0106-84017-84018-1041-00025-00017-00000-JS02150\n%TUTORIAL  --------------   &DOCSTITL --------------------------------%TUTORIAL+\n\n%                    -------------------------------------\n                     |    HELP FOR PRINT REQUEST PANEL   |\n                     -------------------------------------\n+\n+ Opposite%SELECT OPTION ===>+, enter one of the following:\n+        %1+ for printing the document rotated 90 degrees on 3800 Page Printer\n+        %2+ for printing the document on an RJE printer\n+        %3+ for printing the document on a cluster printer\n+\n+ If you have selected option%1+, then provide the following information:\n+        ACCOUNT AND BIN ==>  Enter%nnnn,bb-s+(nnnn=ACCT, bb=bin, s=sub agy)\n+        JOB CLASS       ==>  Enter a valid job class%(H,A,C,D,E, or S)+\n+        NAME FIELD      ==>  Enter programmer name field\n+        COPIES (1-9)    ==>  Enter numeric value%1-9+\n+\n+ If you have selected option%2+, then provide the following information:\n+        SYSOUT CLASS    ==>  Enter%A+or%T+\n+        DESTINATION     ==>  Enter%LOCAL+or%RMTxx+where%xx+is remote number\n+\n+ If you have selected option%3+, then provide the following information:\n+        LOCAL PRINTER ID==>  Enter the 5 character printer id\n+        DSPRINT OPTIONS ==>  Enter DSPRINT options\n)END\n./ ADD NAME=DOCS2HLP 0104-84017-84018-1041-00021-00007-00000-JS02150\n%TUTORIAL  --------------   &DOCSTITL --------------------------------%TUTORIAL+\n\n%                    -------------------------------------\n                     |    HELP FOR PRINT REQUEST PANEL   |\n                     -------------------------------------\n+\n+ Opposite%SELECT OPTION ===>+, enter one of the following:\n+        %1+ for printing the document rotated 90 degrees on 3800 Page Printer\n+        %2+ for printing the document on an RJE printer\n+\n+ If you have selected option%1+, then provide the following information:\n+        ACCOUNT AND BIN ==>  Enter%nnnn,bb-s+(nnnn=ACCT, bb=bin, s=sub agy)\n+        JOB CLASS       ==>  Enter a valid job class%(H,A,C,D,E, or S)+\n+        NAME FIELD      ==>  Enter programmer name field\n+        COPIES (1-9)    ==>  Enter numeric value%1-9+\n+\n+ If you have selected option%2+, then provide the following information:\n+        SYSOUT CLASS    ==>  Enter%A+or%T+\n+        DESTINATION     ==>  Enter%LOCAL+or%RMTxx+where%xx+is remote number\n+\n)END\n./ ADD NAME=DOCS3HLP 0104-84017-84018-0929-00014-00007-00000-JS02150\n%TUTORIAL  --------------   &DOCSTITL --------------------------------%TUTORIAL+\n\n%                    -------------------------------------\n                     |    HELP FOR PRINT REQUEST PANEL   |\n                     -------------------------------------\n+\n+\n+\n+   Verify that the following information is correct and press ENTER:\n+        ACCOUNT AND BIN ==> %nnnn,bb-s+(nnnn=ACCT, bb=bin, s=sub agency)\n+        JOB CLASS       ==>  valid job class%(H,A,C,D,E, or S)+\n+        NAME FIELD      ==>  programmer name field\n+        COPIES (1-9)    ==>  numeric value%1-9+\n)END\n./ ADD NAME=EDITAPP  0104-84107-84335-1653-00080-00062-00000-HJ00150\n)ATTR\n  @  TYPE(INPUT) INTENS(LOW) CAPS(ON) JUST(LEFT)\n)BODY\n+\n%----------------------- APPLICATION SELECTION PANEL ---------------------------\n+COMMAND%==>@ZCMD\n+\n+_Z+ 1%==>@W88APP01                                    %<===+\n+_Z+ 2%==>@W88APP02                                    %<===+\n+_Z+ 3%==>@W88APP03                                    %<===+\n+_Z+ 4%==>@W88APP04                                    %<===+\n+_Z+ 5%==>@W88APP05                                    %<===+\n+_Z+ 6%==>@W88APP06                                    %<===+\n+_Z+ 7%==>@W88APP07                                    %<===+\n+_Z+ 8%==>@W88APP08                                    %<===+\n+_Z+ 9%==>@W88APP09                                    %<===+\n+_Z+10%==>@W88APP10                                    %<===+\n+_Z+11%==>@W88APP11                                    %<===+\n+_Z+12%==>@W88APP12                                    %<===+\n+_Z+13%==>@W88APP13                                    %<===+\n+_Z+14%==>@W88APP14                                    %<===+\n+_Z+15%==>@W88APP15                                    %<===+\n+_Z+16%==>@W88APP16                                    %<===+\n+_Z+17%==>@W88APP17                                    %<===+\n)INIT\n .HELP = 'TEDITAPP'\n .ZVARS='(S01 S02 S03 S04 S05 S06 S07 S08 S09 S10 S11 S12 S13 S14 S15 S16 S17)'\n IF (&S01 \u00ac= ' ','-',&Z)  .CURSOR = S01\n IF (&S02 \u00ac= ' ','-',&Z)  .CURSOR = S02\n IF (&S03 \u00ac= ' ','-',&Z)  .CURSOR = S03\n IF (&S04 \u00ac= ' ','-',&Z)  .CURSOR = S04\n IF (&S05 \u00ac= ' ','-',&Z)  .CURSOR = S05\n IF (&S06 \u00ac= ' ','-',&Z)  .CURSOR = S06\n IF (&S07 \u00ac= ' ','-',&Z)  .CURSOR = S07\n IF (&S08 \u00ac= ' ','-',&Z)  .CURSOR = S08\n IF (&S09 \u00ac= ' ','-',&Z)  .CURSOR = S09\n IF (&S10 \u00ac= ' ','-',&Z)  .CURSOR = S10\n IF (&S11 \u00ac= ' ','-',&Z)  .CURSOR = S11\n IF (&S12 \u00ac= ' ','-',&Z)  .CURSOR = S12\n IF (&S13 \u00ac= ' ','-',&Z)  .CURSOR = S13\n IF (&S14 \u00ac= ' ','-',&Z)  .CURSOR = S14\n IF (&S15 \u00ac= ' ','-',&Z)  .CURSOR = S15\n IF (&S16 \u00ac= ' ','-',&Z)  .CURSOR = S16\n IF (&S17 \u00ac= ' ','-',&Z)  .CURSOR = S17\n &S01 = '-'\n &S02 = '-'\n &S03 = '-'\n &S04 = '-'\n &S05 = '-'\n &S06 = '-'\n &S07 = '-'\n &S08 = '-'\n &S09 = '-'\n &S10 = '-'\n &S11 = '-'\n &S12 = '-'\n &S13 = '-'\n &S14 = '-'\n &S15 = '-'\n &S16 = '-'\n &S17 = '-'\n)PROC\n VER (&S01,LIST,'S','L','-')\n VER (&S02,LIST,'S','L','-')\n VER (&S03,LIST,'S','L','-')\n VER (&S04,LIST,'S','L','-')\n VER (&S05,LIST,'S','L','-')\n VER (&S06,LIST,'S','L','-')\n VER (&S07,LIST,'S','L','-')\n VER (&S08,LIST,'S','L','-')\n VER (&S09,LIST,'S','L','-')\n VER (&S10,LIST,'S','L','-')\n VER (&S11,LIST,'S','L','-')\n VER (&S12,LIST,'S','L','-')\n VER (&S13,LIST,'S','L','-')\n VER (&S14,LIST,'S','L','-')\n VER (&S15,LIST,'S','L','-')\n VER (&S16,LIST,'S','L','-')\n VER (&S17,LIST,'S','L','-')\n)END\n./ ADD NAME=EXPANDIR 0100-86293-86293-1422-00027-00027-00000-JS02150\n)BODY\n%-------------------------- EXPAND PDS DIRECTORY ------------------------------\n+\n+\n+\n+ISPF LIBRARY:\n+   Project%===>_PROJECT +\n+   Library%===>_LIBRARY +\n+   Type   %===>_TYPE    +\n+\n+OTHER PARTITIONED DATASET:\n+   Data set Name%===>_OTHERDSN                                    +\n+\n+\n+\n+Number of directory blocks\n+    to add to the directory%===>_ADR+\n+\n+\n)PROC\n VER (&PROJECT,NAME,MSG=XDIR101)\n VER (&LIBRARY,NAME,MSG=XDIR101)\n VER (&TYPE,NAME,MSG=XDIR101)\n VER (&OTHERDSN,DSNAME)\n VER (&ADR,NUM)\n VER (&ADR,NONBLANK)\n)END\n./ ADD NAME=FNDSMEM  0119-84237-86049-0840-00016-00008-00000-JS02150\n)ATTR\n# TYPE(OUTPUT) INTENS(LOW)\n)BODY\n%EDIT/BROWSE --- &PANULMSG-----------------------------------------------------\n%COMMAND ===>_ZCMD                                            %SCROLL ===>_ZSCR+\n+\n% S+OR%E+FOR EDIT      %B+FOR BROWSE+\n+\n)MODEL\n _Z+#MBRNAME +                                                                 +\n)INIT\n  .ZVARS = '(TYPCODE)'\n  &ZSCR = 'PAGE'\n  &ZSCKEY = 'ZSCML'\n  .HELP = ISR2D000\n)END\n./ ADD NAME=FULLUT1  0120-80058-82075-1012-00058-00041-00000-KK00150\n$ ----------------------   &FULL SCREEN GENERATOR   $---------------------------\n&SELECT OPTION ===>%*FSOPT  $\n&\n&  G$- GENERATE SCREEN,&A$- ASSEMBLE SCREEN,&GA$- GENERATE AND ASSEMBLE SCREEN\n&\n$SCREEN NAME         &===>%SCREEN  $\n&\n&\n$SCREEN FORMAT LIB   &===>%FORLIB                                              $\n$\n$ASSEMBLER SOURCE LIB&===>%ASMSRC                                              $\n$\n$SCREEN LOAD LIBRARY &===>%ASMLOD                                              $\n$\n$      ATTRIBUTE CODES ARE:           DEFAULT:      REPLACEMENT:\n<FIELDS>!%|&*#\"\n*              PROTECTED HIGH INTENSITY   ==>&+*            ==>%U*\n*              PROTECTED LOW  INTENSITY   ==>&\u00ac*            ==>%V*\n*              UNPROTECTED HIGH INTENSITY ==>&$*            ==>%W*\n*              UNPROTECTED LOW  INTENSITY ==>&\u00a2*            ==>%X*\n*\n*              INITIAL CURSOR LOCATION    ==>&_*            ==>%Z*\n*\n<ACTION>\n1 *FSOPT CHAR(3)   CURSOR INIT(' ') GENHELP(TSAN05)\n         LIST(G,A,GA,*)\n         RETURN(G,A,GA,?);\n2 SCREEN CHAR(8)  NOCURSOR INIT($PARM2)\n         LIST(' ',*)\n         RETURN(?);\n3 FORLIB CHAR(46) NOCURSOR INIT($PARM3)\n         LIST(' ',*)\n         RETURN(\u00a2\u00a2\u00a2);\n4 ASMSRC CHAR(46) NOCURSOR INIT($PARM4)\n         LIST(' ',*)\n         RETURN(\u00a2\u00a2\u00a2);\n5 ASMLOD CHAR(46) NOCURSOR INIT($PARM5)\n         LIST(' ',*)\n         RETURN(\u00a2\u00a2\u00a2);\n6 U      CHAR(1)  NOCURSOR INIT($PARM6)  KEY(ATTR1)\n         LIST(' ','?',\u00ac,'''',*)\n         RETURN('+',Q,N,A);\n7 V      CHAR(1)  NOCURSOR INIT($PARM7)  KEY(ATTR2)\n         LIST(' ','?',\u00ac,'''',*)\n         RETURN('N',Q,N,A);\n8 W      CHAR(1)  NOCURSOR INIT($PARM8)  KEY(ATTR3)\n         LIST(' ','?',\u00ac,'''',*)\n         RETURN('$',Q,N,A);\n9 X      CHAR(1)  NOCURSOR INIT($PARM9)  KEY(ATTR4)\n         LIST(' ','?',\u00ac,'''',*)\n         RETURN('\u00a2',Q,N,A);\n10 Y     CHAR(1)  NOCURSOR INIT($PARM10) KEY(ATTR5)\n         LIST(' ','?',\u00ac,'''',*)\n         RETURN('@',Q,N,A);\n11 Z     CHAR(1)  NOCURSOR INIT($PARM11) KEY(ATTR6)\n         LIST(' ','?',\u00ac,'''',*)\n         RETURN('_',Q,N,A);\n<END>\n./ ADD NAME=FULLUT2  0121-79307-82075-1013-00040-00026-00000-KK00150\n$ ----------------------   &FULL SCREEN ANALYZER    $---------------------------\n&\n&\n& TO DISPLAY A SCREEN, ENTER THE FOLLOWING:\n&\n$ SCREEN NAME        &===>%SCREEN  $\n$ SCREEN LOAD LIBRARY&===>%ASMLOD                                             $\n&\n&\n&\n& TO PRINT SCREEN DATA FOR ANALYSIS ENTER COPIES DESIRED BELOW:\n&\n&\n$               PRINT&=>%*A$   COPIES OF SCRUFF.\n&\n$               PRINT&=>%*B$   COPIES OF I/O BUFFERS.\n$\n$               PRINT&=>%*C$   COPIES OF SCREEN. (SUBMITS A BATCH JOB.)\n$\n$               DEST &=>%D       $(TO OVERRIDE DEFAULT FOR SCRUFF AND I/O.)\n<ACTION>\n1 SCREEN CHAR(8) CURSOR INIT($PARM1) GENHELP(TSAN05)\n         LIST(' ',*)\n         RETURN(?);\n2 ASMLOD CHAR(46) NOCURSOR INIT($PARM2)\n         LIST(' ',*)\n         RETURN( ? );\n3 *A     CHAR(3) NOCURSOR INIT(' ')\n         LIST(' ',*)\n         RETURN('\u00ac');\n4 *B     CHAR(3) NOCURSOR INIT(' ')\n         LIST(' ',*)\n         RETURN('\u00ac');\n5 *C     CHAR(3) NOCURSOR INIT(' ')\n         LIST(' ',*)\n         RETURN('\u00ac');\n6 D      CHAR(5) NOCURSOR INIT($PARM6) KEY(FU2DEST)\n         LIST(' ',*)\n         RETURN('\u00ac');\n<END>\n./ ADD NAME=GDDM     0100-85280-85280-1444-00066-00066-00000-KX00150\n)ATTR\n_ TYPE(INPUT) INTENS(LOW) CAPS(ON)\n)BODY\n%-----------------------    GRAPHICS   UTILITIES    ----------------------------\n%SELECT OPTION ===>_OPT\n%\n%        C+ CHART  - INTERACTIVE CHART UTILITY\n%       CG+ CHART  - INTERACTIVE CHART UTILITY WITH 3270PC/G OR GX (LI MODE)\n%       CI+ IMPORT - CHART IMPORT GRAPHICS-DATA UTILITY\n%        V+ VSSE   - VECTOR SYMBOL SET EDITOR\n%        I+ ISSE   - INTERACTIVE SYMBOL SET EDITOR\n%        M+ IMD    - INTERACTIVE MAP DEFINITION UTILITY\n%\n%  NOTE: MANY OF THE FUNCTIONS OF THESE UTILITIES REQUIRE THE USE OF\n%      A TERMINAL WITH GRAPHICS CAPABILITIES(3279,3278-3,3290,ETC.).\n%\n%     CHART AND CHART IMPORT LIBRARIES ARE:\n+DATA LIB  ==>_DL\n+FORMAT LIB==>_FL\n+IMPORT LIB==>_IL\n%\n%     VSSE AND ISSE LIBRARY AND INITIAL SYMBOL SET ARE:\n+SYMBOL LIB==>_SL\n+              SYMBOL SET NAME ==>_SSN\n)INIT\n   .HELP = GDDMR3H\n   IF (&SL = '''USER.SYMBOL.SETS''')\n       &SL = '''USER.TSO.GDDM.SYMBOLS'''\n   IF (&SL = 'USER.SYMBOL.SETS')\n       &SL = '''USER.TSO.GDDM.SYMBOLS'''\n   IF (&SL = '''USER.TSO.GDDMR3.SYMBOLS''')\n       &SL = '''USER.TSO.GDDM.SYMBOLS'''\n   IF (&SL = '''USER.TSO.GDDMR4.SYMBOLS''')\n       &SL = '''USER.TSO.GDDM.SYMBOLS'''\n)PROC\n IF (&OPT = C,CI)\n   IF (&DL = &Z)\n       &DL = 'CHART.DATA'\n   IF (&FL = &Z)\n       &FL = 'CHART.FORMAT'\n IF (&OPT = CI)\n   IF (&IL = &Z)\n       &IL = 'CHART.IMPORT'\n IF (&OPT = V,I)\n   IF (&SL = &Z)\n       &SL = '''USER.TSO.GDDM.SYMBOLS'''\n   &SSN1 = ' '\n   IF (&SSN \u00ac= &Z)\n       &SSN1 = 'SSN(&SSN)'\n VER (&DL,DSNAME)\n VER (&FL,DSNAME)\n VER (&IL,DSNAME)\n VER (&SL,DSNAME)\n VER (&SSN,NAME)\n   &SEL = TRANS( TRUNC (&OPT,'.')\n                C,'CMD(%CHART DL(&DL) FL(&FL))'\n               CG,'CMD(%CHART DL(&DL) FL(&FL) PCG)'\n               CI,'CMD(%CHART IPNP DL(&DL) FL(&FL) IL(&IL))'\n                V,'CMD(%VSSE SS(&SL) &SSN1)'\n                I,'CMD(%ISSE SS(&SL) &SSN1)'\n                M,'CMD(%IMD)                       '\n                L,'CMD(%LPQ)                       '\n                *,'?'\n                )\n VPUT (DL,FL,IL,SL,SSN) PROFILE\n)END\n./ ADD NAME=GDDMR3H  0100-85197-85197-1807-00016-00016-00000-KX00150\n%TUTORIAL -------------     WDPSC SPECIAL OPTIONS     ----------------- TUTORIAL\n%NEXT SELECTION ===>_ZCMD                               %(OR PRESS PF1 FOR HELP)\n%\n%                     -------------------------------\n%                     |     GRAPHICS UTILITIES      |\n%                     -------------------------------\n+\n+\n+     This panel%(W.G)+can be used to invoke the GDDM/PGF/IMD graphics\n+ utilities. You may specify your graphics libraries or, if you leave\n+ the fields blank, default names will be used. The CHART data and\n+ format libaries will be allocated for you if needed. You may enter an\n+ initial symbol set to be edited if invoking a symbol set editor.\n)PROC\n   &ZUP = TWSD\n)END\n./ ADD NAME=GPM      0103-85120-85178-1434-00016-00015-00000-KX00150\n)ATTR\n_ TYPE(INPUT) INTENS(LOW) CAPS(ON)\n)BODY\n%\n%                   _ZCMD\n%\n%\n%\n%\n%                   &GPM\n%\n%&GPML\n%\n)INIT\n)PROC\n)END\n./ ADD NAME=HOTMENU  0103-87082-87093-1655-00030-00016-00000-KX00150\n%-----------------------------  hotkey menu   ----------------------------------\n%OPTION  ===>_ZCMD                                                             +\n%\n+DSNAME %===>_DSN\n%\n%   1+     - Browse the dataset\n%   2+     - Edit   the dataset\n% 3.1+     - Display Library member list\n% 3.2+     - Display dataset info\n% PDS+     - Display PDS command MEMLIST\n% &CO+&COT\n%           +&REPT                 _R  +\n%&ZAP+&ZAPT\n+\n)INIT\n  .CURSOR = ZCMD\n  IF (&HOTFROM \u00ac= ' ')\n    &R = TRANS(&R ' ',NO R,YES Y,YES *,NO)\n)PROC\n  &R = TRUNC(&R,1)\n  &R = TRANS(&R R,R Y,R N,' ')\n  &FTN = TRANS( &ZCMD\n                1,BROWSE\n                2,EDIT\n              3.1,LIB\n              3.2,INFO\n                F,FROM\n                T,TO\n                *,* )\n)END\n./ ADD NAME=ISR@PRIF 0103-85255-86114-1618-00106-00105-00000-KX00150\n%-----------------------  ISPF/PDF PRIMARY OPTION MENU  ------------------------\n%OPTION  ===>_ZCMD                                                             +\n%                                                           +USERID   - &ZUSER\n%   0 +ISPF PARMS  - Specify terminal and user parameters   +PREFIX   - &ZPREFIX\n%   1 +BROWSE      - Display source data or output listings +DATE     - &ZDATE\n%   2 +EDIT        - Create or change source data           +JULIAN   - &ZJDATE\n%   3 +UTILITIES   - Perform utility functions              +TIME     - &ZTIME\n%   4 +FOREGROUND  - Invoke language processors - foreground+TERMINAL - &ZTERM\n%   5 +BATCH       - Submit job for language processing     +PF KEYS  - &ZKEYS\n%   6 +COMMAND     - Enter TSO command or CLIST (remembered)+PROC     - &ZLOGON\n%   7 +DIALOG TEST - Perform dialog testing                  &DISPSID\n%   C +CHANGES     - Display summary of changes for this release\n%   D +DOCSYS      - WDPSC Documentation System\n%   F +FILE-AID    - Dataset BROWSE, EDIT, UTILITIES (VSAM or NVSAM)\n%  IC  INFO-CENTER - Information Center Packages\n%   P +PAN/SPF     - Panvalet/SPF system\n%   T +TUTORIAL    - Display information about ISPF/PDF\n%   U +USERDIAL    - To access your private dialogs from PDF\n%   W +WDPSC       - WDPSC miscellaneous options\n% X,XL+EXIT(LOGOFF)- Terminate ISPF using log/list defaults,(LOGOFF if XL)\n%\n+Enter%END+command to terminate ISPF.\n%\n)INIT\n  .HELP = ISR00003\n  &ZPRIM = no         /* never  A PRIMARY OPTION MENU      */\n  &ZHTOP = ISR00003   /* TUTORIAL TABLE OF CONTENTS        */\n  &ZHINDEX = ISR91000 /* TUTORIAL INDEX - 1ST PAGE         */\n  VPUT (ZHTOP,ZHINDEX) PROFILE\n  &OPSHUN2 = 'PGM(ISREDIT) PARM(P,ISREDM01)' /* NORMAL edit CALL */\n  IF (&OPTION2 \u00ac= '','STD')\n     &OPSHUN2 = 'CMD(%EDIT&OPTION2) NOCHECK'\n  IF (&SPFXF \u00ac= '')\n    IF (&ZCMD = &Z)\n      &ZCMD = &SPFXF\n      &SPFXF = ''\n      .RESP = ENTER\n  IF (&PREPO = 'YES')\n    IF (&PPAIF = '')\n      &SPFXF = &ZCMD\n      &ZCMD = 'PRE'\n      &PPAIF = '1'\n      .RESP = ENTER\n  IF (&SYSID \u00ac= &Z)\n    &DISPSID = 'SYSTEMID - &SYSID'\n  IF (&ZCMD = &Z)\n    .RESP = END\n)PROC\n  &PCMD = &ZCMD\n  IF (&ZCMD = XL,XC,ZL)\n      &SPFXF = 'X'\n  &ZSEL = TRANS( TRUNC (&ZCMD,'.')\n                0,'PANEL(ISPOPTA)'\n                1,'PGM(ISRBRO) PARM(ISRBRO01)'\n                2,'&OPSHUN2'\n                E,'PGM(ISREDIT) PARM(P,ISREDM01)' /* ORIGINAL */\n            ABEND,'PGM(ABEND0C1) '\n                3,'PANEL(ISRUTIL)'\n                4,'PANEL(ISRFPA)'\n                5,'PGM(ISRJB1) PARM(ISRJPA) NOCHECK'\n                6,'PGM(ISRPTC)'\n                7,'PGM(ISRYXDR) NOCHECK'\n      /*        8,'PGM(ISRLPRIM)'  */\n                C,'PGM(ISPTUTOR) PARM(ISR00005)'\n                T,'PGM(ISPTUTOR) PARM(ISR00000)'\n              ' ',' '\n                X,'EXIT'\n                Z,'EXIT'\n                P,'PANEL(PAN@PRIM)'\n               PS,'PANEL(PAN@PRIM)'\n               IC,'PANEL(INFOCTR)'\n                K,'PANEL(KMENU)'\n                S,'PANEL(SANA)'\n                W,'PANEL(WSDIDX)'\n                F,'PANEL(IFAMU01) NEWAPPL(FAXE)'\n                XL,'CMD(%SPFXL)'\n                ZL,'CMD(%SPFXL)'\n                XC,'PGM(WDPSCXS) PARM(&XC)'\n               PRE,'CMD(%PREDIAL)'\n                A,'CMD(%EDITAPP) NOCHECK'\n                U,'CMD(%USERDIAL) NOCHECK'\n                D,'CMD(%DOCSYS)'\n                I,'PGM(IOFSPF)  PARM(&ZCMD) NEWAPPL(IOF) NOCHECK'\n                *,'?' )\n  &ZTRAIL = .TRAIL\n  IF (&ZLOGON = 'INFOCTR')\n    IF (.RESP = 'END')\n        .RESP = 'ENTER'\n        &ZSEL = 'PANEL(INFOCTR)'\n  IF (&PREPO = 'YES')\n   IF (&ZCMD = XL,XC,ZL)\n      &PDXF = &ZCMD\n   IF (&ZSEL = 'EXIT')\n    IF (&PPAIF \u00ac= '2')\n      &SPFXF = &ZCMD\n      &ZSEL = 'CMD(%POSTDIAL)'\n      &PPAIF = '2'\n   IF (.RESP = 'END')\n    IF (&PPAIF \u00ac= '2')\n      &SPFXF = 'END'\n      &ZSEL = 'CMD(%POSTDIAL)'\n      &PPAIF = '2'\n      .RESP = 'ENTER'\n  IF (&ZCMD = 'END')\n      .RESP = 'END'\n)END\n./ ADD NAME=ISR@PRIM 0134-85297-89285-1403-00144-00102-00000-D200155\n%-----------------------  ISPF/PDF PRIMARY OPTION MENU  ------------------------\n%OPTION  ===>_ZCMD                                                             +\n%                                                           +USERID   - &ZUSER\n%   0 +ISPF PARMS  - Specify terminal and user parameters   +PREFIX   - &ZPREFIX\n%   1 +BROWSE      - Display source data or output listings +DATE     - &ZDATE\n%   2 +EDIT        - Create or change source data           +JULIAN   - &ZJDATE\n%   3 +UTILITIES   - Perform utility functions              +TIME     - &ZTIME\n%   4 +FOREGROUND  - Invoke language processors - foreground+TERMINAL - &ZTERM\n%   5 +BATCH       - Submit job for language processing     +PF KEYS  - &ZKEYS\n%   6 +COMMAND     - Enter TSO command or CLIST (remembered)+PROC     - &ZLOGON\n%   7 +DIALOG TEST - Perform dialog testing                  &DISPSID\n%   C +CHANGES     - Display summary of changes for this release\n%   D +DOCSYS      - WDPSC Documentation System\n%   F +FILE-AID    - Dataset BROWSE, EDIT, UTILITIES (VSAM or NVSAM)\n%  IC  INFO-CENTER - Information Center Packages\n%   P +PAN/SPF     - Panvalet/SPF system\n%   T +TUTORIAL    - Display information about ISPF/PDF\n%   U +USERDIAL    - To access your private dialogs from PDF\n%   V +VMCF        - To monitor and control local VPS printers\n%   W +WDPSC       - WDPSC miscellaneous options\n% X,XL+EXIT(LOGOFF)- Terminate ISPF using log/list defaults,(LOGOFF if XL)\n%\n+Enter%END+command to terminate ISPF.\n%\n)INIT\n  .HELP = ISR00003\n  &ZPRIM = YES        /* ALWAYS A PRIMARY OPTION MENU      */\n  &ZHTOP = ISR00003   /* TUTORIAL TABLE OF CONTENTS        */\n  &ZHINDEX = ISR91000 /* TUTORIAL INDEX - 1ST PAGE         */\n  VPUT (ZHTOP,ZHINDEX) PROFILE\n  &OPSHUN2 = 'PGM(ISREDIT) PARM(P,ISREDM01)' /* NORMAL edit CALL */\n  IF (&OPTION2 \u00ac= '','STD')\n     &OPSHUN2 = 'CMD(%EDIT&OPTION2) NOCHECK'\n  IF (&SPFXF \u00ac= '')\n    IF (&ZCMD = &Z)\n      &ZCMD = &SPFXF\n      &SPFXF = ''\n      .RESP = ENTER\n  IF (&PREPO = 'YES')\n    IF (&PPAIF = '')\n      &SPFXF = &ZCMD\n      &ZCMD = 'PRE'\n      &PPAIF = '1'\n      .RESP = ENTER\n  IF (&SYSID \u00ac= &Z)\n    &DISPSID = 'SYSTEMID - &SYSID'\n\n  &P = PM                             /* ===> set MVS/PM option code. */\n  &RTM = RTM                          /* ===> set REALTIME fastpath.  */\n  &RES = RES                          /* ===> set RESOLVE fastpath.   */\n  &JRN = JRN                          /* ===> set JOURNAL fastpath.   */\n  &PMGNAME = 'PERFORMANCE'            /* ===> set MVS/PM name.        */\n  &PMGDESC = 'MVS/PERFORMANCE MANAGER'/* ===> set MVS/PM description. */\n  IF (&PMGTERM = ENTER) &ZCMD = X     /* Restore original X command.  */\n  &PMGTERM = &Z                       /* Set termination flag null    */\n)PROC                    /*------------- REPLACED PROC STATEMENT      */\n  IF (&PMGINIT \u00ac= &Z)                 /* If we have initialized,      */\n   IF (&ZVERB \u00ac= RETURN)              /* but not jump function,       */\n    IF (&ZCMD = X  ) &PMGTERM = ENTER /* and \"X\" entered set \"ENTER\", */\n    IF (.RESP = END) &PMGTERM = END   /*  or \"END\" entered set \"END\". */\n    IF (&PMGTERM \u00ac= &Z)               /*   If we're terminating,      */\n      .RESP = ENTER                   /*     simulate ENTER.          */\n      &ZCMD = '&P'                    /*     and invoke PMGLTERM.     */\n   IF (&ZVERB = RETURN)               /* If RETURN function,          */\n      &ZCMD = &Z                      /*  set ZCMD to null            */\n      .RESP = ENTER                   /*  simulate ENTER              */\n      .MSG  = PMGI013                 /*  and issue message.          */\n  &PMGTRL = TRUNC(&ZCMD,'.')          /* Set trail variable ...       */\n  &PMGTRL = .TRAIL                    /* ... to .TRAIL.               */\n\n  &PCMD = &ZCMD\n  IF (&ZCMD = XL,XC,ZL)\n      &SPFXF = 'X'\n  &ZQ = &Z\n    IF (&ZCMD \u00ac= ' ')\n      &ZQ = TRUNC(&ZCMD,'.')\n      IF (&ZQ = ' ')\n        .MSG = ISRU000\n    &ZSEL = TRANS( &ZQ\n                0,'PANEL(ISPOPTA)'\n                1,'PGM(ISRBRO) PARM(ISRBRO01)'\n                2,'&OPSHUN2'\n                E,'PGM(ISREDIT) PARM(P,ISREDM01)' /* ORIGINAL */\n            ABEND,'PGM(ABEND0C1) '\n                3,'PANEL(ISRUTIL)'\n                4,'PANEL(ISRFPA)'\n                5,'PGM(ISRJB1) PARM(ISRJPA) NOCHECK'\n                6,'PGM(ISRPTC)'\n                7,'PGM(ISRYXDR) NOCHECK'\n      /*        8,'PGM(ISRLPRIM)'  */\n                C,'PGM(ISPTUTOR) PARM(ISR00005)'\n                T,'PGM(ISPTUTOR) PARM(ISR00000)'\n              ' ',' '\n                X,'EXIT'\n                Z,'EXIT'\n                P,'PANEL(PAN@PRIM)'\n               PS,'PANEL(PAN@PRIM)'\n               IC,'PANEL(INFOCTR)'\n                K,'PANEL(KMENU)'\n                S,'PANEL(SANA)'\n                W,'PANEL(WSDIDX)'\n                F,'PANEL(IFAMU01) NEWAPPL(FAXE)'\n                XL,'CMD(%SPFXL)'\n                ZL,'CMD(%SPFXL)'\n                XC,'PGM(WDPSCXS) PARM(&XC)'\n               PRE,'CMD(%PREDIAL)'\n                A,'CMD(%EDITAPP) NOCHECK'\n                U,'CMD(%USERDIAL) NOCHECK'\n                D,'CMD(%DCSYSUSR)'\n                I,'PGM(IOFSPF)  PARM(&ZCMD) NEWAPPL(IOF) NOCHECK'\n               IS,'PGM(DGTFMD01)  NEWAPPL(DGT) NOCHECK'\n              DCK,'PANEL(DCR@PRIM) NEWAPPL(DCR)'\n               EN,'PGM(C1SM1000) NEWAPPL(CTLI) NOCHECK'\n                V,'PGM(VM50ISPF) NEWAPPL(VMCF) NOCHECK PARM(&VMCOPT)'\n               MC,'PGM(MCTISPF) NEWAPPL(MCAT)'\n\n             '&P','PGM(PMGLMAIN) NOCHECK PARM(NOTEST)'\n           '&RTM','PGM(PMGLMAIN) NOCHECK PARM(NOTEST,/1.1.&PMGTRL)'\n           '&RES','PGM(PMGLMAIN) NOCHECK PARM(NOTEST,/2.1.&PMGTRL)'\n           '&JRN','PGM(PMGLMAIN) NOCHECK PARM(NOTEST,/J.B)'\n\n                *,'?' )\n  &ZTRAIL = .TRAIL\n  IF (&ZLOGON = 'INFOCTR')\n    IF (.RESP = 'END')\n        .RESP = 'ENTER'\n        &ZSEL = 'PANEL(INFOCTR)'\n  IF (&PREPO = 'YES')\n   IF (&ZCMD = XL,XC,ZL)\n      &PDXF = &ZCMD\n   IF (&ZSEL = 'EXIT')\n    IF (&PPAIF \u00ac= '2')\n      &SPFXF = &ZCMD\n      &ZSEL = 'CMD(%POSTDIAL)'\n      &PPAIF = '2'\n   IF (.RESP = 'END')\n    IF (&PPAIF \u00ac= '2')\n      &SPFXF = 'END'\n      &ZSEL = 'CMD(%POSTDIAL)'\n      &PPAIF = '2'\n      .RESP = 'ENTER'\n  IF (&ZCMD = 'END')\n      .RESP = 'END'\n)END\n./ ADD NAME=ISRTSO   0107-84258-87016-1557-00042-00049-00000-KX00150\n)ATTR\n  \\ TYPE(OUTPUT) INTENS(LOW)\n  { TYPE(OUTPUT) INTENS(HIGH)\n  } TYPE(INPUT) INTENS(&QQI)\n  # TYPE(INPUT) INTENS(HIGH) CAPS(OFF) JUST(LEFT)\n)BODY CMD(ZCMD)\n%-------------------------  TSO COMMAND PROCESSOR  -----------------------------\n%ENTER TSO COMMAND OR CLIST BELOW:\n%\n\\QQ1                       {QQ2 }ZSM  \\QQ3\n%===>#ZCMD\n\n                                                                               %\n+\n+                                                                              %\n)INIT\n  &ZCMD = &PTCBTEXT\n  IF (&SAVETSO = YES)\n    IF (&Z = &ZCMD)   &ZCMD = &ZRTSO                        /*JARED*/\n  .HELP = ISR60010\n  .CURSOR = ZCMD\n  &ZSM = TRANS(&ZSMMODE Y,YES *,NO)\n&QQ1 = ''\n&QQ2 = ''\n&QQ3 = ''\n&QQI = 'NON'\n&QQF = TRUNC (&ZLOGON,2)\nIF (&QQF = 'SM')\n    &QQ1 = 'ENTER SESSION MANAGER MODE'\n    &QQ2 = '===>'\n    &QQ3 = '  (YES or NO)'\n    &QQI = 'HIGH'\n)PROC\n  IF (&Z \u00ac= &ZCMD)  &ZRTSO = &ZCMD                        /*JARED*/\n    VPUT (ZRTSO) PROFILE                                  /*JARED*/\n  &PTCBTEXT = &ZCMD\n  &PTCLOG  = 'Y'       /* Y = Yes, log commands. N = No logging */\n  &ZSMMODE = TRANS(&ZSM YES,Y YE,Y Y,Y YO,Y *,N)\n  VPUT (ZSMMODE) PROFILE\n  IF(.RESP = END)\n    &ZSM = NO\n)END\n./ ADD NAME=ISRUDA1  0101-88012-88012-1248-00114-00094-00000-KX00155\n)ATTR\n  \u00ac TYPE(INPUT) INTENS(NON)\n)BODY\n%----------------------------  LIBRARY UTILITY  --------------------------------\n%OPTION  ===>_ZCMD                                                             +\n%\n%   blank+- Display member list          %B+- Browse member\n%   C+- Compress data set                %P+- Print member\n%   X+- Print index listing              %R+- Rename member\n%   L+- Print entire data set            %D+- Delete member\n%   I+- Data set information             %S+- Data set information (short)\n+\n+ISPF LIBRARY:\n+   PROJECT%===>_PRJ1    +\n+   GROUP  %===>_LIB1    % ===>_LIB2    % ===>_LIB3    % ===>_LIB4    +\n+   TYPE   %===>_TYP1    +\n+   MEMBER %===>_MEMB    +       (If \"P\", \"R\", \"D\", \"B\", or blank selected)\n+   NEWNAME%===>_NEWNAME +       (If \"R\" selected)\n+\n+OTHER PARTITIONED OR SEQUENTIAL DATA SET:\n+   DATA SET NAME %===>_DSN\n+   VOLUME SERIAL %===>_VOL   +  (If not cataloged)\n+\n+DATA SET PASSWORD%===>\u00acPSWD    +(If password protected)\n)INIT\n  IF ( &PASSDS = 'YES' )\n    IF ( &PRIF \u00ac= 'YES' )\n       &DSN = &PASSDSN\n       &VOL = &PASSVOL\n\n  &ZMLCSR = '        '                  /*                       @M1A*/\n  .HELP = ISR31000\n  &ZCMD = TRANS(&OPT Z,C M,' ' *,*)\n  /*&MEMB = &Z                                                    @MND*/\n  &NEWNAME = &Z\n  IF ( &DSN = ' ' )\n    &VOL = &Z\n  IF ( &DSN \u00ac= ' ' )\n    &MEMB = ' '                         /*                       @M1A*/\n    .CURSOR = DSN\n  IF ( .CURSOR = ' ' )\n    .CURSOR = ZCMD\n  &ZUTILREN = 'RRENAMED'\n  &ZUTILDEL = 'DDELETED'\n  &ZUTILPRT = 'PPRINTED'\n  &ZUTILBRO = 'B       '\n\n  IF (&NEXTTIME = 'END')\n    .MSG = &Z\n    .RESP = END\n  IF (&FADSN \u00ac= ' ')\n    IF (&PRIF \u00ac= 'YES')\n      &DSN = &FADSN\n      &VOL = &FAVOL\n      IF (&FAOPT \u00ac= WAIT)\n        &NEXTTIME = 'END'\n        &ZCMD = &FAOPT\n        .RESP = ENTER\n\n)REINIT                                 /*                       @M1A*/\n  IF (&ZMLCSR \u00ac= ' ')                   /*                       @M1A*/\n    .CURSOR = &ZMLCSR                   /*                       @M1A*/\n)PROC\n  &PRIF = 'YES'\n  IF ( &PASSDS = 'YES' )\n    IF (&DSN \u00ac= &PASSDSN,&Z)\n      VPUT (DSN VOL) PROFILE\n\n  &OPT = TRANS (&ZCMD M,# Z,# C,Z ' ',M *,*)\n  VER(&OPT,LIST,Z,L,X,P,R,D,B,M,I,S)\n\n  IF (&OPT = Z )\n    &GPM = 'Not Allowed'\n    &GPML = 'Compress not allowed for &DSN'\n    IF (&DSN = '''SYS1.LINKLIB''')\n      .MSG = GPM001A\n    IF (&DSN = '''USER.PROCLIB''')\n      .MSG = GPM001A\n    IF (&DSN = '''USER.TEST''')\n      .MSG = GPM001A\n\n  IF (&OPT = R )\n    VER(&NEWNAME,NB)\n    IF (&DSN = ' ')\n      VER(&MEMB,NB)\n  IF (&OPT \u00ac= R , D , M , P , B )\n    IF (&MEMB \u00ac= ' ' )\n      .MSG = ISRU008\n  IF (&DSN = ' ')\n    VER(&PRJ1,NB)\n    VER(&LIB1,NB)\n    VER(&TYP1,NB)\n    IF (&VOL \u00ac= ' ' )\n      .MSG = ISRU232\n    IF (&ZCMD = D , P , B )\n      VER(&MEMB,NB)\n  IF (&DSN \u00ac= ' ')                      /*                        @M1A*/\n    &ZMLCSR = '********'                /*                        @M1A*/\n    &ZSPLAT = Y                         /*                        @MPA*/\n    PANEXIT((DSN,ZMLCSR,ZSPLAT),PGM,&ZMLVEXIT,&ZMLVDATA,MSG=ISRM040)\n                                        /*                        @MPA*/\n  VPUT ( PRJ1 LIB1 LIB2 LIB3 LIB4 TYP1 ) PROFILE\n)END\n /*                                                                   */\n /* $SEG(ISRUDA1) COMP(DATASET) PROD(MVS)                             */\n /*                                                                   */\n /* CHANGE ACTIVITY                                                   */\n /*  $L0= UNFLAGED PRE230                    :                        */\n /*  $MN= MEMLIST   M230     860820   158590 :                        */\n /*  $M1= MEMLIST   M230     860819   158590 : Function test          */\n /*   PTM00000126                                                     */\n /*  $MP= DCR30     M230     861201   158590 : Member list            */\n /*   filter exit                                                     */\n /*  $H1= MEMLIST   M230     8612|@   397010 : PTM 867                */\n./ ADD NAME=ISRUDA2  0114-85323-86216-1408-00077-00049-00000-KK00150\n)ATTR\n  \u00ac TYPE(INPUT) INTENS(NON)\n)BODY\n%----------------------------  DATA SET UTILITY  -------------------------------\n%OPTION  ===>_ZCMD                                                             +\n%\n%   A+- Allocate new data set                %C+- Catalog data set\n%   R+- Rename entire data set               %U+- Uncatalog data set\n%   D+- Delete entire data set               %S+- Data set information (short)\n%   blank+- Data set information             %M+- Library Member list\n+\n+ISPF LIBRARY:\n+   PROJECT%===>_PRJ0    +\n+   GROUP  %===>_LIB0    +\n+   TYPE   %===>_TYP0    +\n+\n+OTHER PARTITIONED OR SEQUENTIAL DATA SET:\n+   DATA SET NAME %===>_DSN                                                    +\n+   VOLUME SERIAL %===>_VOL   +  (If not cataloged, required for option \"C\")\n+\n+DATA SET PASSWORD%===>\u00acPSWD    +(If password protected)\n)INIT\n  .HELP = ISR32000\n  &ZCMD = TRANS(&OPT N,R E,D I,' ' V,U *,*)\n  IF ( &PASSDS = 'YES' )\n       &DOWN = PASSTHRU\n       &UP = PASSTHRU\n    IF ( &PRIF \u00ac= 'YES' )\n       &DSN = &PASSDSN\n       &VOL = &PASSVOL\n  IF (&FADSN \u00ac= ' ')\n     &DSN = &FADSN\n  IF ( &DSN = ' ' )\n    &VOL = &Z\n  IF ( &DSN \u00ac= ' ' )\n    .CURSOR = ZCMD\n  IF ( .CURSOR = ' ' )\n    .CURSOR = ZCMD\n)REINIT\n    IF ( &PASSDS = 'YES' )\n       &DOWN = PASSTHRU\n       &UP = PASSTHRU\n       REFRESH (ZCMD DSN VOL)\n)PROC\n  &PRIF = 'YES'\n  IF ( &PASSDS = 'YES' )\n       &DOWN = &Z\n       &UP = &Z\n    IF (&DSN \u00ac= &PASSDSN,&Z)\n      VPUT (DSN VOL) PROFILE\n      &PVOL = TRANS (&VOL ' ',NONE *,*)\n      &PANLEXIT = 'SELECT CMD(%PASSDSN &DSN &PVOL)'\n    IF (&ZCMD = DOWN,UP)\n      &PANLEXIT = 'SELECT CMD(%PASSDSN &ZCMD 1)'\n      &DSN = &PANLEXIT\n      &VOL = &PASSVOL\n      &ZCMD = &Z\n      &GPM = 'Prev DSN'\n      &GPML = 'Previous DSNAME Selected for reuse'\n      .MSG = GPM001\n  &OPT = TRANS(&ZCMD N,# E,# I,# V,# R,N D,E ' ',I U,V *,*)\n  VER(&OPT,LIST,A,N,E,I,C,V,S,M)\n  IF ( &OPT = C )\n    VER(&VOL,NB)\n  IF ( &OPT = V )\n    IF (&VOL \u00ac= ' ' )\n      .MSG = ISRU230\n  IF ( &DSN = ' ' )\n    VER(&PRJ0,NB)\n    VER(&LIB0,NB)\n    VER(&TYP0,NB)\n    IF ( &OPT \u00ac= C )\n      IF (&VOL \u00ac= ' ' )\n        .MSG = ISRU232\n  VER (&DSN,DSNAME)\n  VPUT ( PRJ0 LIB0 TYP0 ) PROFILE\n)END\n./ ADD NAME=ISRUDLP  0102-89254-89254-2210-00061-00056-00000-KK00155\n%--------------------------- DATA SET LIST UTILITY -----------------------------\n%OPTION  ===>_ZCMD                                                             +\n%\n%  blank+- Display data set list%*         %P+ - Print data set list\n%  V    +- Display VTOC information only   %PV+- Print VTOC information only\n%\n+Enter one or both of the parameters below:\n+  DSNAME LEVEL %===>_ZDLDSNLV                                    +\n+  VOLUME       %===>_ZDLPVL+\n%\n%\n+  INITIAL DISPLAY VIEW    %===>_ZUPIV   +(VOLUME,SPACE,ATTRIB,TOTAL)\n+  CONFIRM DELETE REQUEST  %===>_ZUPCD+   (YES or NO)\n%\n%*+The following line commands will be available when the list is displayed:\n%\n%B+- Browse data set     %C+- Catalog data set     %F+- Free unused space\n%E+- Edit data set       %U+- Uncatalog data set   %=+- Repeat last command\n%D+- Delete data set     %P+- Print data set\n%R+- Rename data set     %X+- Print index listing\n%I+- Data set information%M+- Display member list\n%S+- Information (short) %Z+- Compress data set    %TSO command or CLIST\n)INIT\n  .HELP = ISR34000\n  IF (.MSG = &Z)\n    .CURSOR = ZCMD\n  &ZCMD = &ZUOPT\n  &ZUPIV = TRANS (&ZUVIEW 0,VOLUME 1,SPACE 2,ATTRIB 3,TOTAL *,VOLUME)\n  IF (&ZUCDR = &Z)\n    &ZUCDR = Y\n  &ZUPCD = TRANS (&ZUCDR Y,YES N,NO *,*)\n\n  IF (&NEXTTIME = 'END')\n    .MSG = &Z\n    .RESP = END\n  IF (&FADSN \u00ac= ' ')\n      &ZDLDSNLV = &FADSN\n      IF (&FAOPT \u00ac= WAIT)\n        &NEXTTIME = 'END'\n        &ZCMD = &FAOPT\n        .RESP = ENTER\n\n)PROC\n  IF (&ZCMD \u00ac= ' ')\n    VER (&ZCMD,LIST,P,V,PV)\n  &ZUOPT = TRUNC (&ZCMD,2)\n  IF (&ZUOPT = 'V ','PV')\n    VER (&ZDLPVL,NONBLANK)\n  IF (&ZUOPT = '  ','P ')\n    IF (&ZDLPVL = ' ')\n      VER (&ZDLDSNLV,NONBLANK,MSG=ISRU187)\n  &ZUCDR = TRUNC (&ZUPCD,1)\n  VER (&ZUCDR,NB,LIST,Y,N)\n  &ZVIEW = TRUNC (&ZUPIV,1)\n  VER (&ZVIEW,NB,LIST,V,S,A,T)\n  &ZUPIV = TRANS (&ZVIEW V,VOLUME S,SPACE A,ATTRIB T,TOTAL *,*)\n  &ZUVIEW = TRANS (&ZVIEW V,0 S,1 A,2 T,3 *,*)\n)END\n/* $SEG(ISRUDLP) COMP(DSLIST)  PROD(MVS):                            */\n/* $M0= ENHANC34 M230   860717  641747 :                             */\n/* $H0= DSLIST   M230   861016  040100 : FT PTM 294                  */\n./ ADD NAME=ISRUMC1  0111-85324-87093-1613-00083-00049-00000-KX00150\n)ATTR\n  \u00ac TYPE(INPUT) INTENS(NON)\n)BODY\n%---------------------------  MOVE/COPY UTILITY  -------------------------------\n%OPTION  ===>_ZCMD                                                             +\n%\n%   C+- Copy data set or member(s)             %CP+- Copy and print\n%   M+- Move data set or member(s)             %MP+- Move and print\n%   P+- Promote data set or member(s)          %PP+- Promote and print\n+\n+SPECIFY%\"FROM\"+DATA SET BELOW, THEN PRESS%ENTER+KEY\n+\n+FROM ISPF LIBRARY:\n+   PROJECT%===>_PRJ0    +\n+   GROUP  %===>_LIB0    +\n+   TYPE   %===>_TYP0    +\n+   MEMBER %===>_MEMB    +       (Blank for member list, * for all members)\n+\n+FROM OTHER PARTITIONED OR SEQUENTIAL DATA SET:\n+   DATA SET NAME %===>_DSN1\n+   VOLUME SERIAL %===>_VOL1  +  (If not cataloged)\n+\n+DATA SET PASSWORD%===>\u00acPSWD    +(If password protected)\n)INIT\n  IF (&PASSDS = 'YES')\n       &DOWN = PASSTHRU\n       &UP = PASSTHRU\n    IF (&PRIF  \u00ac= YES)\n      &DSN1 = &DSN\n      &VOL1 = &VOL\n  .HELP=ISR33020\n  &ZCMD = &ZOPT\n  &MEMB = &Z\n  &ZUMCSEL  = 'S'\n  &ZUMCCOPY = 'COPIED '\n  &ZUMCMOVE = 'MOVED  '\n  &ZUMCNREP = 'NO-REPL'\n  IF (&XXX = 'E')\n    .MSG = &Z\n    .RESP = END\n  IF (&HOTFROM \u00ac= ' ')\n      &DSN1 = &HOTFROM\n      IF (&FAOPT \u00ac= WAIT)\n        &XXX = 'E'\n        &ZCMD = TRUNC (&FAOPT,1)\n        &ZUREP = .TRAIL\n        .RESP = ENTER\n  IF ( &DSN1 \u00ac= ' ' )\n    .CURSOR = DSN1\n  IF ( .CURSOR = ' ')\n    .CURSOR = ZCMD\n)REINIT\n    IF (&PASSDS = 'YES')\n       &DOWN = PASSTHRU\n       &UP = PASSTHRU\n       REFRESH (ZCMD DSN1 VOL1)\n)PROC\n  &PRIF = 'YES'\n  IF ( &PASSDS = 'YES' )\n       &DOWN = &Z\n       &UP = &Z\n    IF (&DSN1 \u00ac= &PASSDSN,&Z)\n      &DSN = &DSN1\n      &VOL = &VOL1\n      VPUT (DSN VOL) PROFILE\n      &PVOL = TRANS (&VOL ' ',NONE *,*)\n      &PANLEXIT = 'SELECT CMD(%PASSDSN &DSN &PVOL)'\n    IF (&ZCMD = DOWN,UP)\n      &PANLEXIT = 'SELECT CMD(%PASSDSN &ZCMD 1)'\n      &DSN1 = &PANLEXIT\n      &VOL1 = &PASSVOL\n      &ZCMD = &Z\n      &GPM = 'Prev DSN'\n      &GPML = 'Previous DSNAME Selected for reuse'\n      .MSG = GPM001\n  VER(&ZCMD,NB,LIST,M,C,MP,CP,P,PP)\n  &ZOPT = &ZCMD\n  IF (&DSN1 = ' ')\n    VER (&PRJ0,NB)\n    VER (&LIB0,NB)\n    VER (&TYP0,NB)\n  VPUT ( PRJ0 LIB0 TYP0 ) PROFILE\n)END\n./ ADD NAME=ISRUMC2A 0111-85312-87093-1536-00086-00048-00000-KX00150\n)ATTR\n  \u00ac TYPE(INPUT) INTENS(NON)\n  @ TYPE(OUTPUT) INTENS(LOW)\n)BODY\n%&ZUMODE --- FROM &DSNI&ZUPMEMB ------------------------------------------------\n%COMMAND ===>_ZCMD                                                             +\n+\n+SPECIFY%\"TO\"+DATA SET BELOW.\n%\n+TO ISPF LIBRARY:\n+   PROJECT%===>_PROJ2   +\n+   GROUP  %===>_LIBR2   +\n+   TYPE   %===>_TYPE2   +\n+   MEMBER %===>_MEMB2   + @PRMPT                                   +\n+\n+TO OTHER PARTITIONED OR SEQUENTIAL DATA SET:\n+   DATA SET NAME %===>_DSN2\n+   VOLUME SERIAL %===>_VOL2  +  (If not cataloged)\n+\n+DATA SET PASSWORD%===>\u00acPSWD2   +(If password protected)\n+\n+\"TO\" DATA SET OPTIONS:\n+   IF PARTITIONED, REPLACE LIKE-NAMED MEMBERS%===>_ZURPL+ (YES or NO)\n+   IF SEQUENTIAL, \"TO\" DATA SET DISPOSITION  %===>_ZUOM + (OLD or MOD)\n+   SPECIFY PACK OPTION FOR \"TO\" DATA SET     %===>_ZUPO + (YES, NO or blank)\n)INIT\n  &ZCMD = &Z\n  .HELP = ISR33021\n  &ZUOM = TRANS (&ZUSD M,'MOD' O,'OLD')                     /* OZ93212 */\n  &ZURPL = TRANS (&ZUREP Y,'YES' N,'NO' *,*)\n  &ZUPO = TRANS (&ZUPK Y,'YES' N,'NO' *,*)\n  &PRMPT = TRANS (&PROMPT S,' ' P,'(BLANK UNLESS MEMBER IS TO BE RENAMED)')\n  IF (&PASSDS = 'YES')\n       &DOWN = PASSTHRU\n       &UP = PASSTHRU\n    IF (&PRIF2 \u00ac= YES)\n      &DSN2 = &DSN\n      &VOL2= &VOL\n  IF (&HOTTO \u00ac= ' ')\n      &DSN2 = &HOTTO\n      IF (&FAOPT \u00ac= WAIT)\n        .RESP = ENTER\n  IF (&ZURPL = ' ')\n    &ZURPL = NO\n  IF (&ZUOM = ' ')\n    &ZUOM = OLD\n)REINIT\n    IF (&PASSDS = 'YES')\n       &DOWN = PASSTHRU\n       &UP = PASSTHRU\n       REFRESH (ZCMD DSN2 VOL2)\n)PROC\n  &PRIF2 = 'YES'\n  IF ( &PASSDS = 'YES' )\n       &DOWN = &Z\n       &UP = &Z\n    IF (&DSN2 \u00ac= &PASSDSN,&Z)\n      &DSN = &DSN2\n      &VOL = &VOL2\n      VPUT (DSN VOL) PROFILE\n      &PVOL = TRANS (&VOL ' ',NONE *,*)\n      &PANLEXIT = 'SELECT CMD(%PASSDSN &DSN &PVOL)'\n    IF (&ZCMD = DOWN,UP)\n      &PANLEXIT = 'SELECT CMD(%PASSDSN &ZCMD 1)'\n      &DSN2 = &PANLEXIT\n      &VOL2 = &PASSVOL\n      &ZCMD = &Z\n      &GPM = 'Prev DSN'\n      &GPML = 'Previous DSNAME Selected for reuse'\n      .MSG = GPM001\n  IF (&DSN2 = ' ')\n    VER (&PROJ2,NB)\n    VER (&LIBR2,NB)\n    VER (&TYPE2,NB)\n  VER (&DSN2,DSNAME)\n  &ZUREP = TRUNC (&ZURPL,1)\n  &ZURPL = TRANS (&ZUREP Y,'YES' N,'NO' *,*)\n  VER (&ZURPL,LIST,YES,NO)\n  &ZUSD = TRUNC (&ZUOM,1)\n  &ZUOM = TRANS (&ZUSD M,'MOD' O,'OLD')                     /* OZ93212 */\n  VER (&ZUOM,LIST,MOD,OLD)\n  &ZUPK = TRUNC (&ZUPO,1)\n  VER (&ZUPK,LIST,Y,N)\n  &PROMPT = TRANS (&PRMPT ' ',S '(BLANK UNLESS MEMBER IS TO BE RENAMED)',P)\n  VPUT ( PROJ2 LIBR2 TYPE2 ZUREP ZUSD ) PROFILE\n)END\n./ ADD NAME=ISRUMC2B 0109-85310-87093-1536-00081-00045-00000-KX00150\n)ATTR\n  \u00ac TYPE(INPUT) INTENS(NON)\n  # TYPE(OUTPUT) INTENS(HIGH)\n)BODY\n%&ZUMODE --- FROM &DSNI&ZUPMEMB ------------------------------------------------\n%COMMAND ===>_ZCMD                                                             +\n+\n+SPECIFY%\"TO\"+DATA SET BELOW.\n+\n+TO ISPF LIBRARY:\n+   PROJECT%===>_PROJ2   +\n+   GROUP  %===>_LIBR2   +\n+   TYPE   %===>_TYPE2   +\n+\n+TO OTHER PARTITIONED OR SEQUENTIAL DATA SET:\n+   DATA SET NAME %===>_DSN2\n+   VOLUME SERIAL %===>_VOL2  +  (If not cataloged)\n+\n+DATA SET PASSWORD%===>\u00acPSWD2   +(If password protected)\n+\n+\"TO\" DATA SET OPTIONS:\n+   IF PARTITIONED, REPLACE LIKE-NAMED MEMBERS%===>_ZURPL+ (YES or NO)\n+   IF SEQUENTIAL, \"TO\" DATA SET DISPOSITION  %===>_ZUOM + (OLD or MOD)\n+   SPECIFY PACK OPTION FOR \"TO\" DATA SET     %===>_ZUPO + (YES, NO or blank)\n)INIT\n  &ZCMD = &Z\n  .HELP = ISR33021\n  &ZUOM = TRANS (&ZUSD M,'MOD' O,'OLD')                        /* OZ93212 */\n  &ZURPL = TRANS (&ZUREP Y,'YES' N,'NO' *,*)\n  &ZUPO = TRANS (&ZUPK Y,'YES' N,'NO' *,*)\n  IF (&PASSDS = 'YES')\n       &DOWN = PASSTHRU\n       &UP = PASSTHRU\n    IF (&PRIF2 \u00ac= YES)\n      &DSN2 = &DSN\n      &VOL2 = &VOL\n  IF (&HOTTO \u00ac= ' ')\n      &DSN2 = &HOTTO\n      IF (&FAOPT \u00ac= WAIT)\n        .RESP = ENTER\n  IF (&ZURPL = ' ')\n    &ZURPL = NO\n  IF (&ZUOM = ' ')\n    &ZUOM = OLD\n)REINIT\n    IF (&PASSDS = 'YES')\n       &DOWN = PASSTHRU\n       &UP = PASSTHRU\n       REFRESH (ZCMD DSN2 VOL2)\n)PROC\n  &PRIF2 = 'YES'\n  IF ( &PASSDS = 'YES' )\n       &DOWN = &Z\n       &UP = &Z\n    IF (&DSN2 \u00ac= &PASSDSN,&Z)\n      &DSN = &DSN2\n      &VOL = &VOL2\n      VPUT (DSN VOL) PROFILE\n      &PVOL = TRANS (&VOL ' ',NONE *,*)\n      &PANLEXIT = 'SELECT CMD(%PASSDSN &DSN &PVOL)'\n    IF (&ZCMD = DOWN,UP)\n      &PANLEXIT = 'SELECT CMD(%PASSDSN &ZCMD 1)'\n      &DSN2 = &PANLEXIT\n      &VOL2 = &PASSVOL\n      &ZCMD = &Z\n      &GPM = 'Prev DSN'\n      &GPML = 'Previous DSNAME Selected for reuse'\n      .MSG = GPM001\n  IF (&DSN2 = ' ')\n    VER (&PROJ2,NB)\n    VER (&LIBR2,NB)\n    VER (&TYPE2,NB)\n  VER (&DSN2,DSNAME)\n  &ZUREP = TRUNC (&ZURPL,1)\n  &ZURPL = TRANS (&ZUREP Y,'YES' N,'NO' *,*)\n  &ZUSD = TRUNC (&ZUOM,1)\n  &ZUOM = TRANS (&ZUSD M,'MOD' O,'OLD')                        /* OZ93212 */\n  &ZUPK = TRUNC (&ZUPO,1)\n  VER (&ZUPK,LIST,Y,N)\n  VPUT ( PROJ2 LIBR2 TYPE2 ZUREP ZUSD ) PROFILE\n)END\n./ ADD NAME=KMENU    0149-82357-86100-1811-00060-00038-00000-KK00150\n%----------------    TECHNICAL SERVICES UTILITIES   ----------------------------\n%SELECT OPTION ===>_OPT                    +\n%\n% C+- SOURCE PROGRAM COMPARE UTILITY\n% D%- Technical Services Documentation System\n%DS+- DASD SEARCH UTILITY\n% E+- INVOKE INFO/MANAGEMENT (ERROR TRACKING SYSTEM)\n% I+- INVOKE INFO/SYS DATABASE SELECTION PANEL\n%IO+- IPCS Option Menu (IPCS dialog system)\n% K+- KERMIT TEST PANELS\n% M+- SEND/RECEIVE MESSAGES\n% N+- NVSAM CATALOG UTILITY DIALOG\n% O+- OPTIONS- Local SPF options - EDIT type,PASSDSN,SAVETSO,etc.\n% P+- PDSGAS - Member Recovery Utility\n% R+- INVOKE RESOLVE\n% S+- INTERACTIVE SMP4 UTILITY\n%SE+- SMP/E Dialog System\n%SL%- SYSLOG - Display list of archived SYSLOG datasets for browseing\n% T+- EDIT TSO COMMAND OUTPUT\n%TL+- TECHNICAL LIBRARY SERVICE\n% U+- SYSTEM PROGRAMMER UTILITIES\n%\n)INIT\n  IF (&OXF = 'END')\n     &OXF = 'NORETRY'\n    .RESP = 'END'\n  &LBCCMD = 'CMD(&ZUSER.B)'\n)PROC\n   IF (&OPT = SL)\n      &DSLIST = 'DPSCD150.SYSLOG'\n  &SEL = TRANS( TRUNC (&OPT,'.')\n                A,'PANEL(ACFOPTS)'\n               SL,'CMD(%FLIST)'\n                D,'CMD(%DOCTECH)'\n                N,'CMD(%SPFCATNV)'\n               IM,'CMD(%SPFOZD I)'\n               IP,'CMD(%SPFOZD I PO(Y))'\n               TI,'CMD(%SPFOZD T)'\n                I,'PANEL(SPFOZSEL)'\n             IPCS,'CMD(%IOINIT)'\n               IO,'CMD(%IOINIT)'\n                E,'CMD(%SPFINFO)'\n                R,'CMD(%SPFPEEK)'\n               SH,'CMD(%SPFSH)'\n                C,'CMD(%SPFCOMPN)'\n                H,'CMD(%SPFHOLD)'\n                K,'PANEL(KKMENU)'\n                M,'CMD(%SPFMESSB)'\n                O,'PANEL(SPFEOPT)'\n                P,'CMD(%PDSGAS)'\n                S,'CMD(%SPFSMP4)'\n               SE,'CMD(%SMPE ZCMD(&ZCMD)) NOCHECK NEWAPPL(SMPE)'\n                T,'CMD(%SPFTSO)'\n               TL,'CMD(%SLSS)'\n                U,'CMD(%SPFBATU)'\n               DS,'CMD(%VTOCCMD1)'\n              LBC,'&LBCCMD'\n                *,'?'\n                )\n)END\n./ ADD NAME=MULTEDIT 0108-84335-85024-1551-00193-00176-00000-GD02150\n)ATTR\n  @  TYPE(INPUT) INTENS(LOW) CAPS(ON) JUST(LEFT)\n  #  TYPE(OUTPUT) INTENS(LOW) CAPS(ON) JUST(LEFT)\n  \u00ac  TYPE(OUTPUT) INTENS(HIGH) CAPS(ON) JUST(LEFT)\n  $  TYPE(TEXT) INTENS(LOW) SKIP(ON)\n)BODY\n%----------------------- A BETTER EDIT/BROWSE PANEL ------&SAVEDMSG-------------\n+COMMAND/DSN NO.%==>_ZCMD                                               +\n+\n+MEMBER NAME or\n+   FIND STRING %==>_MEMBER                                  +VOLUME%==>_OTHVOL+\n+DSN  %==>_OTHERDSN                                        % +OPTION%==>_A+\n\u00acKKMEAPP\n_B+  1%==>@W88DSN01                                    %%%%%Option Codes\n_C+  2%==>@W88DSN02                                    %%%%% E+Edit\n_D+  3%==>@W88DSN03                                    %%%%% B+Browse\n_E+  4%==>@W88DSN04                                    %%%%% F+Find string in\n_F+  5%==>@W88DSN05                                    %%%%%  +the data\n_G+  6%==>@W88DSN06                                    %%%%% X+Find string in\n_H+  7%==>@W88DSN07                                    %%%%%  +the member name\n_I+  8%==>@W88DSN08                                    %%%%%  +or SPF Statistics\n_J+  9%==>@W88DSN09                                    %%%%%\n_K+ 10%==>@W88DSN10                                    %%%%%\u00a2\u00a2\u00a2\u00a2\u00a2\u00a2\u00a2\u00a2\u00a2\u00a2\u00a2\u00a2\u00a2\u00a2\u00a2\u00a2\u00a2\u00a2\u00a2\n_L+ 11%==>@W88DSN11                                    %%%%%\u00a2+               %\u00a2\n_M+ 12%==>@W88DSN12                                    %%%%%\u00a2+     Does      %\u00a2\n_N+ 13%==>@W88DSN13                                    %%%%%\u00a2+     this      %\u00a2\n_O+ 14%==>@W88DSN14                                    %%%%%\u00a2+     make      %\u00a2\n_P+ 15%==>@W88DSN15                                    %%%%%\u00a2+     cents ?   %\u00a2\n_Q+ 16%==>@W88DSN16                                    %%%%%\u00a2+               %\u00a2\n_R+ 17%==>@W88DSN17                                    %%%%%\u00a2\u00a2\u00a2\u00a2\u00a2\u00a2\u00a2\u00a2\u00a2\u00a2\u00a2\u00a2\u00a2\u00a2\u00a2\u00a2\u00a2\u00a2\u00a2\n)INIT\n IF (&OPTION2 = APP,KK)\n   &UP = PASSTHRU\n   &DOWN = PASSTHRU\n .HELP = EDIT2HLP\n .CURSOR = ZCMD\n &A = ' '\n &B = '-'\n &C = '-'\n &D = '-'\n &E = '-'\n &F = '-'\n &G = '-'\n &H = '-'\n &I = '-'\n &J = '-'\n &K = '-'\n &L = '-'\n &M = '-'\n &N = '-'\n &O = '-'\n &P = '-'\n &Q = '-'\n &R = '-'\n IF (&ZTRAIL \u00ac= &Z)\n    &ZCMD = &ZTRAIL\n    &ZTRAIL = &Z\n    VPUT ZTRAIL SHARED\n   .RESP = 'ENTER'\n   .MSG = &Z\n)PROC\n IF (&OPTION2 = APP,KK)\n   &UP = &Z\n   &DOWN = &Z\n   IF (&ZCMD = UP,DOWN)\n      &KCMD = &ZCMD\n      VPUT (KCMD) SHARED\n      .RESP = 'END'\n VER (&ZCMD,RANGE,1,17)\n VER (&OTHVOL,PICT,'CCCCCC')\n VER (&A,LIST,'S','E','B','F','X','-')\n VER (&B,LIST,'S','E','B','F','X','-')\n VER (&C,LIST,'S','E','B','F','X','-')\n VER (&D,LIST,'S','E','B','F','X','-')\n VER (&E,LIST,'S','E','B','F','X','-')\n VER (&F,LIST,'S','E','B','F','X','-')\n VER (&G,LIST,'S','E','B','F','X','-')\n VER (&H,LIST,'S','E','B','F','X','-')\n VER (&I,LIST,'S','E','B','F','X','-')\n VER (&J,LIST,'S','E','B','F','X','-')\n VER (&K,LIST,'S','E','B','F','X','-')\n VER (&L,LIST,'S','E','B','F','X','-')\n VER (&M,LIST,'S','E','B','F','X','-')\n VER (&N,LIST,'S','E','B','F','X','-')\n VER (&O,LIST,'S','E','B','F','X','-')\n VER (&P,LIST,'S','E','B','F','X','-')\n VER (&Q,LIST,'S','E','B','F','X','-')\n VER (&R,LIST,'S','E','B','F','X','-')\n &A00 = &A\n &A01 = &B\n &A02 = &C\n &A03 = &D\n &A04 = &E\n &A05 = &F\n &A06 = &G\n &A07 = &H\n &A08 = &I\n &A09 = &J\n &A10 = &K\n &A11 = &L\n &A12 = &M\n &A13 = &N\n &A14 = &O\n &A15 = &P\n &A16 = &Q\n &A17 = &R\n &A00 = TRANS (&A00 S,E *,*)\n &A01 = TRANS (&A01 S,E *,*)\n &A02 = TRANS (&A02 S,E *,*)\n &A03 = TRANS (&A03 S,E *,*)\n &A04 = TRANS (&A04 S,E *,*)\n &A05 = TRANS (&A05 S,E *,*)\n &A06 = TRANS (&A06 S,E *,*)\n &A07 = TRANS (&A07 S,E *,*)\n &A08 = TRANS (&A08 S,E *,*)\n &A09 = TRANS (&A09 S,E *,*)\n &A10 = TRANS (&A10 S,E *,*)\n &A11 = TRANS (&A11 S,E *,*)\n &A12 = TRANS (&A12 S,E *,*)\n &A13 = TRANS (&A13 S,E *,*)\n &A14 = TRANS (&A14 S,E *,*)\n &A15 = TRANS (&A15 S,E *,*)\n &A16 = TRANS (&A16 S,E *,*)\n &A17 = TRANS (&A17 S,E *,*)\n IF (&ZCMD = 1)\n   &A01 = E\n   &OTHERDSN = &Z\n   &ZCMD = &Z\n IF (&ZCMD = 2)\n   &A02 = E\n   &OTHERDSN = &Z\n   &ZCMD = &Z\n IF (&ZCMD = 3)\n   &A03 = E\n   &OTHERDSN = &Z\n   &ZCMD = &Z\n IF (&ZCMD = 4)\n   &A04 = E\n   &OTHERDSN = &Z\n   &ZCMD = &Z\n IF (&ZCMD = 5)\n   &A05 = E\n   &OTHERDSN = &Z\n   &ZCMD = &Z\n IF (&ZCMD = 6)\n   &A06 = E\n   &OTHERDSN = &Z\n   &ZCMD = &Z\n IF (&ZCMD = 7)\n   &A07 = E\n   &OTHERDSN = &Z\n   &ZCMD = &Z\n IF (&ZCMD = 8)\n   &A08 = E\n   &OTHERDSN = &Z\n   &ZCMD = &Z\n IF (&ZCMD = 9)\n   &A09 = E\n   &OTHERDSN = &Z\n   &ZCMD = &Z\n IF (&ZCMD = 10)\n   &A10 = E\n   &OTHERDSN = &Z\n   &ZCMD = &Z\n IF (&ZCMD = 11)\n   &A11 = E\n   &OTHERDSN = &Z\n   &ZCMD = &Z\n IF (&ZCMD = 12)\n   &A12 = E\n   &OTHERDSN = &Z\n   &ZCMD = &Z\n IF (&ZCMD = 13)\n   &A13 = E\n   &OTHERDSN = &Z\n   &ZCMD = &Z\n IF (&ZCMD = 14)\n   &A14 = E\n   &OTHERDSN = &Z\n   &ZCMD = &Z\n IF (&ZCMD = 15)\n   &A15 = E\n   &OTHERDSN = &Z\n   &ZCMD = &Z\n IF (&ZCMD = 16)\n   &A16 = E\n   &OTHERDSN = &Z\n   &ZCMD = &Z\n IF (&ZCMD = 17)\n   &A17 = E\n   &OTHERDSN = &Z\n   &ZCMD = &Z\n)END\n./ ADD NAME=MULTSOFT 0103-85018-88021-1246-00329-00321-00000-KK00155\n)ATTR\n  @  TYPE(INPUT) INTENS(LOW) CAPS(ON) JUST(LEFT)\n  #  TYPE(OUTPUT) INTENS(LOW) CAPS(ON) JUST(LEFT)\n  \u00ac  TYPE(OUTPUT) INTENS(HIGH) CAPS(ON) JUST(LEFT)\n  $  TYPE(TEXT) INTENS(LOW) SKIP(ON)\n)BODY\n%----------------------- A BETTER EDIT/BROWSE PANEL ------&SAVEDMSG-------------\n+COMMAND/DSN NO.%==>_ZCMD                                               +\n+\n+    MEMBER NAME%==>_MEMBER                                    +(or FIND string)\n+      OTHER DSN%==>_OTHERDSN                                          +OPT%=>_A\n+        +VOLUME%==>_OTHVOL+\n\u00acKKMEAPP\n_B+  1%==>@W88DSN01                                    %    Option Codes\n_C+  2%==>@W88DSN02                                    %     E+Edit\n_D+  3%==>@W88DSN03                                    %     B+Browse\n_E+  4%==>@W88DSN04                                    %     F+Find string in\n_F+  5%==>@W88DSN05                                    %      +the data\n_G+  6%==>@W88DSN06                                    %     X+Find string in\n_H+  7%==>@W88DSN07                                    %      +the member name\n_I+  8%==>@W88DSN08                                    %      +or SPF Statistics\n_J+  9%==>@W88DSN09                                    %\n_K+ 10%==>@W88DSN10                                    %    \u00a2\u00a2\u00a2\u00a2\u00a2\u00a2\u00a2\u00a2\u00a2\u00a2\u00a2\u00a2\u00a2\u00a2\u00a2\u00a2\u00a2\u00a2\u00a2\n_L+ 11%==>@W88DSN11                                    %    \u00a2+               %\u00a2\n_M+ 12%==>@W88DSN12                                    %    \u00a2+     Does      %\u00a2\n_N+ 13%==>@W88DSN13                                    %    \u00a2+     this      %\u00a2\n_O+ 14%==>@W88DSN14                                    %    \u00a2+     make      %\u00a2\n_P+ 15%==>@W88DSN15                                    %    \u00a2+     cents ?   %\u00a2\n_Q+ 16%==>@W88DSN16                                    %    \u00a2+               %\u00a2\n_R+ 17%==>@W88DSN17                                    %    \u00a2\u00a2\u00a2\u00a2\u00a2\u00a2\u00a2\u00a2\u00a2\u00a2\u00a2\u00a2\u00a2\u00a2\u00a2\u00a2\u00a2\u00a2\u00a2\n)INIT\n IF (&OPTION2 = APP,KK)\n   &UP = PASSTHRU\n   &DOWN = PASSTHRU\n .HELP = EDIT2HLP\n .CURSOR = ZCMD\n &A = ' '\n &B = '-'\n &C = '-'\n &D = '-'\n &E = '-'\n &F = '-'\n &G = '-'\n &H = '-'\n &I = '-'\n &J = '-'\n &K = '-'\n &L = '-'\n &M = '-'\n &N = '-'\n &O = '-'\n &P = '-'\n &Q = '-'\n &R = '-'\n IF (&ZTRAIL \u00ac= &Z)\n    &ZCMD = TRUNC (&ZTRAIL, '.')\n    &MEMBER = .TRAIL\n    &ZTRAIL = &Z\n    VPUT ZTRAIL SHARED\n   .RESP = 'ENTER'\n   .MSG = &Z\n IF (&V00 \u00ac= &Z)\n   &OTHERDSN = '&OTHERDSN,&V00'\n   &OTHVOL = &Z\n   &V00 = &Z\n IF (&V01 \u00ac= &Z)\n   &W88DSN01 = '&W88DSN01,&V01'\n   &V01 = &Z\n   &OTHVOL = &Z\n IF (&V02 \u00ac= &Z)\n   &W88DSN02 = '&W88DSN02,&V02'\n   &V02 = &Z\n   &OTHVOL = &Z\n IF (&V03 \u00ac= &Z)\n   &W88DSN03 = '&W88DSN03,&V03'\n   &V03 = &Z\n   &OTHVOL = &Z\n IF (&V04 \u00ac= &Z)\n   &W88DSN04 = '&W88DSN04,&V04'\n   &V04 = &Z\n   &OTHVOL = &Z\n IF (&V05 \u00ac= &Z)\n   &W88DSN05 = '&W88DSN05,&V05'\n   &V05 = &Z\n   &OTHVOL = &Z\n IF (&V06 \u00ac= &Z)\n   &W88DSN06 = '&W88DSN06,&V06'\n   &V06 = &Z\n   &OTHVOL = &Z\n IF (&V07 \u00ac= &Z)\n   &W88DSN07 = '&W88DSN07,&V07'\n   &V07 = &Z\n   &OTHVOL = &Z\n IF (&V08 \u00ac= &Z)\n   &W88DSN08 = '&W88DSN08,&V08'\n   &V08 = &Z\n   &OTHVOL = &Z\n IF (&V09 \u00ac= &Z)\n   &W88DSN09 = '&W88DSN09,&V09'\n   &V09 = &Z\n   &OTHVOL = &Z\n IF (&V10 \u00ac= &Z)\n   &W88DSN10 = '&W88DSN10,&V10'\n   &V10 = &Z\n   &OTHVOL = &Z\n IF (&V11 \u00ac= &Z)\n   &W88DSN11 = '&W88DSN11,&V11'\n   &V11 = &Z\n   &OTHVOL = &Z\n IF (&V12 \u00ac= &Z)\n   &W88DSN12 = '&W88DSN12,&V12'\n   &V12 = &Z\n   &OTHVOL = &Z\n IF (&V13 \u00ac= &Z)\n   &W88DSN13 = '&W88DSN13,&V13'\n   &V13 = &Z\n   &OTHVOL = &Z\n IF (&V14 \u00ac= &Z)\n   &W88DSN14 = '&W88DSN14,&V14'\n   &V14 = &Z\n   &OTHVOL = &Z\n IF (&V15 \u00ac= &Z)\n   &W88DSN15 = '&W88DSN15,&V15'\n   &V15 = &Z\n   &OTHVOL = &Z\n IF (&V16 \u00ac= &Z)\n   &W88DSN16 = '&W88DSN16,&V16'\n   &V16 = &Z\n   &OTHVOL = &Z\n IF (&V17 \u00ac= &Z)\n   &W88DSN17 = '&W88DSN17,&V17'\n   &V17 = &Z\n   &OTHVOL = &Z\n IF (&X00 \u00ac= &Z)\n   &OTHVOL = &X00\n   &X00 = &Z\n IF (&ODSN \u00ac= &Z)\n   &OTHERDSN = &ODSN\n   &ODSN = &Z\n)REINIT\n IF (&OPTION2 = APP,KK)\n   &UP = PASSTHRU\n   &DOWN = PASSTHRU\n)PROC\n IF (&OPTION2 = APP,KK)\n   &UP = &Z\n   &DOWN = &Z\n   IF (&ZCMD = UP,DOWN)\n      &KCMD = &ZCMD\n      VPUT (KCMD) SHARED\n      .RESP = 'END'\n &ZCMD = TRUNC(&ZCMD,'.')\n VER (&ZCMD,RANGE,1,17)\n IF (&MEMBER = &Z)\n   &MEMBER = .TRAIL\n VER (&OTHVOL,PICT,'CCCCCC')\n VER (&A,LIST,'S','E','B','F','X','-')\n VER (&B,LIST,'S','E','B','F','X','-')\n VER (&C,LIST,'S','E','B','F','X','-')\n VER (&D,LIST,'S','E','B','F','X','-')\n VER (&E,LIST,'S','E','B','F','X','-')\n VER (&F,LIST,'S','E','B','F','X','-')\n VER (&G,LIST,'S','E','B','F','X','-')\n VER (&H,LIST,'S','E','B','F','X','-')\n VER (&I,LIST,'S','E','B','F','X','-')\n VER (&J,LIST,'S','E','B','F','X','-')\n VER (&K,LIST,'S','E','B','F','X','-')\n VER (&L,LIST,'S','E','B','F','X','-')\n VER (&M,LIST,'S','E','B','F','X','-')\n VER (&N,LIST,'S','E','B','F','X','-')\n VER (&O,LIST,'S','E','B','F','X','-')\n VER (&P,LIST,'S','E','B','F','X','-')\n VER (&Q,LIST,'S','E','B','F','X','-')\n VER (&R,LIST,'S','E','B','F','X','-')\n &A00 = &A\n &A01 = &B\n &A02 = &C\n &A03 = &D\n &A04 = &E\n &A05 = &F\n &A06 = &G\n &A07 = &H\n &A08 = &I\n &A09 = &J\n &A10 = &K\n &A11 = &L\n &A12 = &M\n &A13 = &N\n &A14 = &O\n &A15 = &P\n &A16 = &Q\n &A17 = &R\n &A00 = TRANS (&A00 S,E *,*)\n &A01 = TRANS (&A01 S,E *,*)\n &A02 = TRANS (&A02 S,E *,*)\n &A03 = TRANS (&A03 S,E *,*)\n &A04 = TRANS (&A04 S,E *,*)\n &A05 = TRANS (&A05 S,E *,*)\n &A06 = TRANS (&A06 S,E *,*)\n &A07 = TRANS (&A07 S,E *,*)\n &A08 = TRANS (&A08 S,E *,*)\n &A09 = TRANS (&A09 S,E *,*)\n &A10 = TRANS (&A10 S,E *,*)\n &A11 = TRANS (&A11 S,E *,*)\n &A12 = TRANS (&A12 S,E *,*)\n &A13 = TRANS (&A13 S,E *,*)\n &A14 = TRANS (&A14 S,E *,*)\n &A15 = TRANS (&A15 S,E *,*)\n &A16 = TRANS (&A16 S,E *,*)\n &A17 = TRANS (&A17 S,E *,*)\n &ODSN = &OTHERDSN\n IF (&ZCMD = 1)   &A01 = E\n IF (&ZCMD = 2)   &A02 = E\n IF (&ZCMD = 3)   &A03 = E\n IF (&ZCMD = 4)   &A04 = E\n IF (&ZCMD = 5)   &A05 = E\n IF (&ZCMD = 6)   &A06 = E\n IF (&ZCMD = 7)   &A07 = E\n IF (&ZCMD = 8)   &A08 = E\n IF (&ZCMD = 9)   &A09 = E\n IF (&ZCMD = 10)  &A10 = E\n IF (&ZCMD = 11)  &A11 = E\n IF (&ZCMD = 12)  &A12 = E\n IF (&ZCMD = 13)  &A13 = E\n IF (&ZCMD = 14)  &A14 = E\n IF (&ZCMD = 15)  &A15 = E\n IF (&ZCMD = 16)  &A16 = E\n IF (&ZCMD = 17)  &A17 = E\n &ZCMD = &Z\n &X00 = &OTHVOL\n IF (&OTHERDSN \u00ac= &Z)\n   &OTHERDSN = TRUNC(&OTHERDSN,',')\n   &OTHVOL = .TRAIL\n   &V00 = &OTHVOL\n IF (.RESP = 'ENTER')\n   &W88DSN01 = TRUNC(&W88DSN01,',')\n   &V01 = .TRAIL\n  IF (&OTHERDSN = &Z)\n   &OTHVOL = &V01\n IF (&A01 \u00ac= '-',' ')\n   &OTHERDSN = &Z\n   &OTHVOL = &V01\n IF (&A02 \u00ac= '-',' ')\n   &OTHERDSN = &Z\n   &W88DSN02 = TRUNC(&W88DSN02,',')\n   &OTHVOL = .TRAIL\n   &V02 = &OTHVOL\n IF (&A03 \u00ac= '-',' ')\n   &OTHERDSN = &Z\n   &W88DSN03 = TRUNC(&W88DSN03,',')\n   &OTHVOL = .TRAIL\n   &V03 = &OTHVOL\n IF (&A04 \u00ac= '-',' ')\n   &OTHERDSN = &Z\n   &W88DSN04 = TRUNC(&W88DSN04,',')\n   &OTHVOL = .TRAIL\n   &V04 = &OTHVOL\n IF (&A05 \u00ac= '-',' ')\n   &OTHERDSN = &Z\n   &W88DSN05 = TRUNC(&W88DSN05,',')\n   &OTHVOL = .TRAIL\n   &V05 = &OTHVOL\n IF (&A06 \u00ac= '-',' ')\n   &OTHERDSN = &Z\n   &W88DSN06 = TRUNC(&W88DSN06,',')\n   &OTHVOL = .TRAIL\n   &V06 = &OTHVOL\n IF (&A07 \u00ac= '-',' ')\n   &OTHERDSN = &Z\n   &W88DSN07 = TRUNC(&W88DSN07,',')\n   &OTHVOL = .TRAIL\n   &V07 = &OTHVOL\n IF (&A08 \u00ac= '-',' ')\n   &OTHERDSN = &Z\n   &W88DSN08 = TRUNC(&W88DSN08,',')\n   &OTHVOL = .TRAIL\n   &V08 = &OTHVOL\n IF (&A09 \u00ac= '-',' ')\n   &OTHERDSN = &Z\n   &W88DSN09 = TRUNC(&W88DSN09,',')\n   &OTHVOL = .TRAIL\n   &V09 = &OTHVOL\n IF (&A10 \u00ac= '-',' ')\n   &OTHERDSN = &Z\n   &W88DSN10 = TRUNC(&W88DSN10,',')\n   &OTHVOL = .TRAIL\n   &V10 = &OTHVOL\n IF (&A11 \u00ac= '-',' ')\n   &OTHERDSN = &Z\n   &W88DSN11 = TRUNC(&W88DSN11,',')\n   &OTHVOL = .TRAIL\n   &V11 = &OTHVOL\n IF (&A12 \u00ac= '-',' ')\n   &OTHERDSN = &Z\n   &W88DSN12 = TRUNC(&W88DSN12,',')\n   &OTHVOL = .TRAIL\n   &V12 = &OTHVOL\n IF (&A13 \u00ac= '-',' ')\n   &OTHERDSN = &Z\n   &W88DSN13 = TRUNC(&W88DSN13,',')\n   &OTHVOL = .TRAIL\n   &V13 = &OTHVOL\n IF (&A14 \u00ac= '-',' ')\n   &OTHERDSN = &Z\n   &W88DSN14 = TRUNC(&W88DSN14,',')\n   &OTHVOL = .TRAIL\n   &V14 = &OTHVOL\n IF (&A15 \u00ac= '-',' ')\n   &OTHERDSN = &Z\n   &W88DSN15 = TRUNC(&W88DSN15,',')\n   &OTHVOL = .TRAIL\n   &V15 = &OTHVOL\n IF (&A16 \u00ac= '-',' ')\n   &OTHERDSN = &Z\n   &W88DSN16 = TRUNC(&W88DSN16,',')\n   &OTHVOL = .TRAIL\n   &V16 = &OTHVOL\n IF (&A17 \u00ac= '-',' ')\n   &OTHERDSN = &Z\n   &W88DSN17 = TRUNC(&W88DSN17,',')\n   &OTHVOL = .TRAIL\n   &V17 = &OTHVOL\n IF (&X00 \u00ac= &Z)\n   &OTHVOL = &X00\n IF (&PASSDS = 'YES')\n    &DSN = &OTHERDSN\n    &VOL = &OTHVOL\n   VPUT (DSN VOL) PROFILE\n)END\n./ ADD NAME=PASTEHLP 0104-86254-86304-1327-00022-00022-00000-GS00150\n%TUTORIAL --------------  PASTE EDIT MACRO INFORMATION  --------------- TUTORIAL\n%COMMAND ===>_ZCMD                                                    +\n\n+\n  ISPF/PDF EDIT MACRO TO WRITE LINES FROM THE USER PROFILE POOL\n  INTO THE CURRENT FILE.  THIS MACRO IS USED IN CONJUNCTION WITH\n  THE%CUT+MACRO.\n+\n  TO RUN:\n    ENTER%PASTE+ON THE COMMAND LINE AND USE LINE COMMAND%A+(AFTER)\n    OR%B+(BEFORE) TO SELECT LOCATION TO%PASTE+THE%CUT+LINES.\n+\n    A PARAMETER OF%K+OR%KEEP+MAY BE SPECIFIED TO PREVENT THE CUT\n    LINES FROM BEING DELETED FROM THE USER PROFILE POOL.\n    OTHERWISE, THE CUT LINES WILL BE DELETED AFTER THEY ARE PASTED.\n+\n    IF LINES ARE CUT FROM A DATA SET WITH A LARGER LRECL THAN THE\n    DATA SET WHERE THE LINES ARE TO BE PASTED, THE LINES WILL BE\n    PASTED BUT WILL BE%TRUNCATED+BEYOND THE LRECL OF THE RECEIVING\n    DATA SET.\n+\n)END\n./ ADD NAME=SAN05    0102-81078-83251-1730-00027-00027-00000-KK00150\n%-----------------------    FULLSCREEN UTILITIES    ----------------------------\n%SELECT OPTION ===>_OPT     +\n%\n%        1+- FULLSCREEN GENERATOR\n%        2+- FULLSCREEN ANALYZER\n%\n%\n%\n%\n%\n%\n%\n)INIT\n   .HELP = TSAN05\n)PROC\n   &SEL = TRANS( TRUNC (&OPT,'.')\n                1,'PGM(ISRFOR) PARM(FULLUT1)'\n                2,'PGM(ISRFOR) PARM(FULLUT2)'\n                3,'PGM(ISRFOR) PARM(FULLUT3)'\n                4,'PGM(ISRFOR) PARM(FULLUT4)'\n                5,'PGM(ISRFOR) PARM(FULLUT5)'\n                6,'PGM(ISRFOR) PARM(FULLUT6)'\n                7,'PGM(ISRFOR) PARM(FULLUT7)'\n                8,'PGM(ISRFOR) PARM(FULLUT8)'\n                *,'?'\n                )\n)END\n./ ADD NAME=SPFBATU  0112-83063-83272-1726-00034-00030-00000-KK00150\n)ATTR\n_ TYPE(INPUT) INTENS(LOW) CAPS(ON)\n@ TYPE(TEXT)\n# TYPE(OUTPUT) INTENS(HIGH)\n)BODY\n%-----------------   SYSTEM PROGRAMMER UTILITIES FOR MODULE INFO  --------------\n%SELECT OPTION ===>_OPT     +\n%  #EMSG\n% B+- AMBLIST UTILITY XREF LISTING\n% Z+- AMASPZAP UTILITY (TERMINAL INPUT)\n% I+- IDRLIST XREF LISTING\n% D+- ZAP DUMP (ENTER LMOD,CSECT)\n% U+- UCLA INTERACTIVE ZAP UTILITY\n%\n%SPF LIBRARY:\n%   PROJECT@===>_PRJ0    %\n%   LIBRARY@===>_LIB0    @\n%   TYPE   @===>_TYP0    %\n%   MEMBER @===>_MEMBER  %          CSECT @===>_CSECT   %(FOR D)\n%\n%OTHER PARTITIONED OR SEQUENTIAL DATASET:\n%   DATASET NAME @===>_DSN                                                     %\n%   VOLUME SERIAL@===>_VOL   %  (IF NOT CATALOGED)\n)INIT\n)PROC\n VER (&OPT,NONBLANK)\n VER (&OPT,LIST,Z,I,B,D,U)\n VER (&DSN,DSNAME)\n VER (&PRJ0,DSNAME)\n VER (&LIB0,DSNAME)\n VER (&TYP0,DSNAME)\n VER (&MEMBER,NAME)\n VER (&CSECT,NAME)\n)END\n./ ADD NAME=SPFCATH1 0102-85197-86065-1602-00028-00028-00000-KK00150\n%TUTORIAL ------------- TECHNICAL SERVICES CATALOG UTILITY ----(CONTINUED PANEL)\n%NEXT SELECTION ===>_ZCMD                               %(OR PRESS PF1 FOR HELP)\n+\n+      THIS IS A SPECIAL CATALOG MAINTENENCE FACILITY FOR WDPSC. SELECT\n+  THE FUNCTION DESIRED BY PLACING THE OPTION NEXT TO THE CATALOG YOU\n+  WISH TO USE AND ENTERING THE INFORMATION NEEDED. MORE THAN ONE CATALOG\n+  MAY BE SPECIFIED. A 'Y' IN THE LISTCAT PARM FOR OPTIONAL CATALOGS WILL\n+  CAUSE A PROMPT FOR A CATALOG PASSWORD. (\"Y,PASSWORD\" IS ALSO ACCEPTABLE.)\n+\n%      C+= CATALOG A DATASET - ENTER DATASET NAME AND VOLUME (UNLESS AVAILABLE\n+          VIA NORMAL CATALOG SEARCH). ENTER DEVICE TYPE IF VOLUME NOT MOUNTED.\n%      U+= UNCATALOG A DATASET - ENTER THE DATASET NAME.\n%      R+= RECATALOG A DATASET (UNCATALOG THEN CATALOG) -\n+          ENTER DATASET NAME AND VOLUME.\n%      D+= DELETE A DATASET - ENTER DATASET NAME.\n%     LL+= LIST CATALOG ENTRIES BY LEVEL - ENTER INDEX LEVEL DESIRED.\n%     RN+= RENAME A DATASET - ENTER DATASET NAME AND NEW DATASET NAME.\n%      L+= LIST CATALOG ENTRY - ENTER DATASET DESIRED.\n%      A+= DEFINE AN ALIAS - ENTER REAL DATASET NAME AND ALIAS NAME.\n%      G+= DEFINE A GENERATION DATA GROUP - ENTER GDG BASE NAME AND\n+          NUMBER OF GENERATIONS (IN VOL FIELD). DEFAULTS ARE SCRATCH\n+          AND NOEMPTY HOWEVER OPTIONS FIELD CAN OVERRIDE.\n%      F+= OBTAIN VOLUME INFO FROM THIS CATALOG.\n%     MF+= OBTAIN VOLUME INFO FROM THIS CATALOG, THEN UNCATALOG IT.\n)PROC\n   &ZCONT = SPFCATH2\n   &ZUP = TSANA\n)END\n./ ADD NAME=SPFCATH2 0104-85197-86065-1603-00028-00027-00000-KK00150\n%TUTORIAL ------------- TECHNICAL SERVICES CATALOG UTILITY ----(CONTINUED PANEL)\n%NEXT SELECTION ===>_ZCMD                               %(OR PRESS PF1 FOR HELP)\n+\n+      THE CATALOG UTILITY CAN COPY OR MOVE MULTIPLE DATASETS FROM ONE\n+  CATALOG TO ANOTHER. THE FOLLOWING ARE THE OPTIONS WHICH MUST BE USED\n+  TO DO THIS. NOTE THAT YOU MUST SPECIFY CL AND ONE OTHER OPTION TO\n+  SPECIFY THE FROM CATALOG. WHILE OTHER OPTIONS MAY BE SPECIFIED, DO NOT\n+  SPECIFY INVALID COMBINATIONS OR RESULTS ARE UNPREDICTABLE (IE MF WITH C).\n+\n%     CL+ = CATALOG A LIST OF DATASETS. THE LIST MUST BE CREATED BY THE\n+           USE OF THE FL,FLL,ML OR MLL OPTIONS ALONG WITH THE CL OPTION.\n%     FL+ = CREATE A LIST OF DATASETS WITH VOLUME INFORMATION FROM THIS\n+           CATALOG FOR USE BY THE CL OPTION. USE THIS OPTION IF YOUR\n+           DATASET NAME CONTAINS AN * LEVEL.\n%     ML+ = CREATE A LIST OF DATASETS WITH VOLUME INFORMATION FROM THIS\n+           CATALOG FOR USE BY THE CL OPTION. USE THIS OPTION IF YOUR\n+           DATASET NAME CONTAINS AN * LEVEL. ENTRIES WILL BE UNCATALOGED.\n%     FLL+= CREATE A LIST OF DATASETS WITH VOLUME INFORMATION FROM THIS\n+           CATALOG FOR USE BY THE CL OPTION. USE THIS OPTION IF YOUR\n            DATASET NAME IS A HIGH LEVEL QUALIFIER.\n%     MLL+= CREATE A LIST OF DATASETS WITH VOLUME INFORMATION FROM THIS\n+           CATALOG FOR USE BY THE CL OPTION. USE THIS OPTION IF YOUR\n+           DATASET NAME IS A HIGH LEVEL QUALIFIER. ENTRIES WILL BE\n+           UNCATALOGED.\n)PROC\n   &ZCONT = SPFCATH3\n   &ZUP = TSANA\n)END\n./ ADD NAME=SPFCATH3 0103-85273-86065-1558-00027-00021-00000-KK00150\n%TUTORIAL ------------- TECHNICAL SERVICES CATALOG UTILITY ------------ TUTORIAL\n%NEXT SELECTION ===>_ZCMD                               %(OR PRESS PF1 FOR HELP)\n+\n   The CATALOG utility VIEW field may contain a \"Y\" if you wish to view\n   the command and response regardless of success. If left blank, only in\n   the case of an error will the IDCAMS response be displayed. You may also\n   enter an \"E\" if you wish to edit the IDCAMS output or generated command\n   list for transfer operations. An \"L\" may be entered to trace the dialog.\n   The \"PARMS\" field may be used to specify special IDCAMS options (eg. PURGE).\n+\n%  More catalog utility options:\n%     M  += Modify or ALTER the catalog entry for a dataset. For example,\n+           use FOR(7) in the PARM field to set EXPIRATION DATE to 7 days\n+           after CREATION DATE.\n%     ULL+= Uncatalog all datasets having a given high-level qualifier.\n+           This option can also be used if you need to delete datasets\n            with a common qualifier: Set the view flag to \"E\" and the\n+           uncatalog command list will be presented for editing before\n+           execution. Use the CHANGE ALL command to remove the NSCR\n+           parm and press the END key to execute the commands.\n%     K  += Invoke the FLIST utility to create a selectable list of\n+           datasets with the given qualifier from the catalog selected.\n            The list can be used to perform maintenence functions such\n+           as BROWSE, EDIT, DELETE, UNCATALOG, COMPRESS, etc.\n)PROC\n   &ZUP = TSANA\n)END\n./ ADD NAME=SPFCATNV 0103-84299-85274-1053-00079-00078-00000-KK00150\n)ATTR\n_ TYPE(INPUT) INTENS(LOW) CAPS(ON)\n\u00ac TYPE(INPUT) INTENS(&PATTR) CAPS(ON)\n@ TYPE(OUTPUT) INTENS(LOW) CAPS(ON)\n$ TYPE(TEXT) INTENS(LOW)\n% TYPE(TEXT) INTENS(HIGH)\n)BODY\n%---------------------   WDPSC NONVSAM CATALOG UTILITY   -----------------------\n$COMMAND ===>_ZCMD                                       $VIEW?>_LF\n$%&EMSG\n%   DSNAME %===>_DSN                                                $\n$   VOLSER  ===>_VOL     $        DEVT  ===>_DEVT    $ (OPTIONAL)\n$\n$C = CATALOG DATASET, U = UNCATALOG DATASET, L = LISTCAT ENTRY, LL = LISTCAT LVL\n$        (PRESS HELP KEY FOR MORE INFORMATION ON AVAILABLE OPTIONS.)\n$   PLACE OPTION DESIRED (C,D,L,U,LL,A,R,RN,G) BY CATALOG(S) YOU WISH:\n$\n$ OPTION FOR CATALOG:                          LISTCAT PARMS:\n$ ===>_CO1  @CN1                   @CD1           $===>\u00acCP1                   $\n$ ===>_CO2  @CN2                   @CD2           $===>\u00acCP2                   $\n$ ===>_CO3  @CN3                   @CD3           $===>\u00acCP3                   $\n$ ===>_CO4  @CN4                   @CD4           $===>\u00acCP4                   $\n$ ===>_CO5  @CN5                   @CD5           $===>\u00acCP5                   $\n$ ===>_CO6  @CN6                   @CD6           $===>\u00acCP6                   $\n$ ===>_CO7  _CN7                   @CD7           $===>\u00acCP7                   $\n$ ===>_CO8  _CN8                   @CD8           $===>\u00acCP8                   $\n$\n$ IF DEFINE ALIAS OR RENAME, PUT THE ALIAS OR NEW NAME HERE:\n$          %===>_ALIAS                                              $\n)INIT\n &CO1 = TRANS (&CO1 8,FL 9,FLL 10,ML 12,MLL 14,CL 15,ULL 18,K 20,M *,*)\n &CO2 = TRANS (&CO2 8,FL 9,FLL 10,ML 12,MLL 14,CL 15,ULL 18,K 20,M *,*)\n &CO3 = TRANS (&CO3 8,FL 9,FLL 10,ML 12,MLL 14,CL 15,ULL 18,K 20,M *,*)\n &CO4 = TRANS (&CO4 8,FL 9,FLL 10,ML 12,MLL 14,CL 15,ULL 18,K 20,M *,*)\n &CO5 = TRANS (&CO5 8,FL 9,FLL 10,ML 12,MLL 14,CL 15,ULL 18,K 20,M *,*)\n &CO6 = TRANS (&CO6 8,FL 9,FLL 10,ML 12,MLL 14,CL 15,ULL 18,K 20,M *,*)\n &CO7 = TRANS (&CO7 8,FL 9,FLL 10,ML 12,MLL 14,CL 15,ULL 18,K 20,M *,*)\n &CO8 = TRANS (&CO8 8,FL 9,FLL 10,ML 12,MLL 14,CL 15,ULL 18,K 20,M *,*)\n &CO1 = TRANS (&CO1 2,L 3,LL 4,U 5,A 6,D 7,C 11,R 13,RN 17,G 19,F 23,MF *,*)\n &CO2 = TRANS (&CO2 2,L 3,LL 4,U 5,A 6,D 7,C 11,R 13,RN 17,G 19,F 23,MF *,*)\n &CO3 = TRANS (&CO3 2,L 3,LL 4,U 5,A 6,D 7,C 11,R 13,RN 17,G 19,F 23,MF *,*)\n &CO4 = TRANS (&CO4 2,L 3,LL 4,U 5,A 6,D 7,C 11,R 13,RN 17,G 19,F 23,MF *,*)\n &CO5 = TRANS (&CO5 2,L 3,LL 4,U 5,A 6,D 7,C 11,R 13,RN 17,G 19,F 23,MF *,*)\n &CO6 = TRANS (&CO6 2,L 3,LL 4,U 5,A 6,D 7,C 11,R 13,RN 17,G 19,F 23,MF *,*)\n &CO7 = TRANS (&CO7 2,L 3,LL 4,U 5,A 6,D 7,C 11,R 13,RN 17,G 19,F 23,MF *,*)\n &CO8 = TRANS (&CO8 2,L 3,LL 4,U 5,A 6,D 7,C 11,R 13,RN 17,G 19,F 23,MF *,*)\n .HELP = SPFCATH1\n IF (&PATTR = '')\n    &PATTR = 'LOW'\n)PROC\n VER (&DSN,NONBLANK)\n VER (&CO1,LIST,L,LL,U,A,D,C,R,RN,G,F,MF,CL,FL,FLL,ML,MLL,ULL,K,M)\n &COT = '&CO1&CO2&CO3&CO4&CO5&CO6&CO7&CO8'\n VER (&COT,NONBLANK,MSG=SPFNV001)\n VER (&CO2,LIST,L,LL,U,A,D,C,R,RN,G,F,MF,CL,FL,FLL,ML,MLL,ULL,K,M)\n VER (&CO3,LIST,L,LL,U,A,D,C,R,RN,G,F,MF,CL,FL,FLL,ML,MLL,ULL,K,M)\n VER (&CO4,LIST,L,LL,U,A,D,C,R,RN,G,F,MF,CL,FL,FLL,ML,MLL,ULL,K,M)\n VER (&CO5,LIST,L,LL,U,A,D,C,R,RN,G,F,MF,CL,FL,FLL,ML,MLL,ULL,K,M)\n VER (&CO6,LIST,L,LL,U,A,D,C,R,RN,G,F,MF,CL,FL,FLL,ML,MLL,ULL,K,M)\n VER (&CO7,LIST,L,LL,U,A,D,C,R,RN,G,F,MF,CL,FL,FLL,ML,MLL,ULL,K,M)\n VER (&CO8,LIST,L,LL,U,A,D,C,R,RN,G,F,MF,CL,FL,FLL,ML,MLL,ULL,K,M)\n &CO1 = TRANS (&CO1 FL,8 FLL,9 ML,10 MLL,12 CL,14 ULL,15 K,18 M,20 *,*)\n &CO2 = TRANS (&CO2 FL,8 FLL,9 ML,10 MLL,12 CL,14 ULL,15 K,18 M,20 *,*)\n &CO3 = TRANS (&CO3 FL,8 FLL,9 ML,10 MLL,12 CL,14 ULL,15 K,18 M,20 *,*)\n &CO4 = TRANS (&CO4 FL,8 FLL,9 ML,10 MLL,12 CL,14 ULL,15 K,18 M,20 *,*)\n &CO5 = TRANS (&CO5 FL,8 FLL,9 ML,10 MLL,12 CL,14 ULL,15 K,18 M,20 *,*)\n &CO6 = TRANS (&CO6 FL,8 FLL,9 ML,10 MLL,12 CL,14 ULL,15 K,18 M,20 *,*)\n &CO7 = TRANS (&CO7 FL,8 FLL,9 ML,10 MLL,12 CL,14 ULL,15 K,18 M,20 *,*)\n &CO8 = TRANS (&CO8 FL,8 FLL,9 ML,10 MLL,12 CL,14 ULL,15 K,18 M,20 *,*)\n &CO1 = TRANS (&CO1 L,2 LL,3 U,4 A,5 D,6 C,7 R,11 RN,13 G,17 F,19 MF,23 *,*)\n &CO2 = TRANS (&CO2 L,2 LL,3 U,4 A,5 D,6 C,7 R,11 RN,13 G,17 F,19 MF,23 *,*)\n &CO3 = TRANS (&CO3 L,2 LL,3 U,4 A,5 D,6 C,7 R,11 RN,13 G,17 F,19 MF,23 *,*)\n &CO4 = TRANS (&CO4 L,2 LL,3 U,4 A,5 D,6 C,7 R,11 RN,13 G,17 F,19 MF,23 *,*)\n &CO5 = TRANS (&CO5 L,2 LL,3 U,4 A,5 D,6 C,7 R,11 RN,13 G,17 F,19 MF,23 *,*)\n &CO6 = TRANS (&CO6 L,2 LL,3 U,4 A,5 D,6 C,7 R,11 RN,13 G,17 F,19 MF,23 *,*)\n &CO7 = TRANS (&CO7 L,2 LL,3 U,4 A,5 D,6 C,7 R,11 RN,13 G,17 F,19 MF,23 *,*)\n &CO8 = TRANS (&CO8 L,2 LL,3 U,4 A,5 D,6 C,7 R,11 RN,13 G,17 F,19 MF,23 *,*)\n VPUT (DSN VOL) PROFILE\n)END\n./ ADD NAME=SPFEOH   0100-86141-86141-1304-00027-00027-00000-KK00150\n%TUTORIAL -------------     WDPSC LOCAL PARAMETERS    ----------------- TUTORIAL\n%NEXT SELECTION ===>_ZCMD                               %(OR PRESS PF1 FOR HELP)\n%\n+     This panel%(W.0)+can be used to request special ISPF processing or\n+ modifications developed locally. For example, special EDIT dialogs can\n+ be requested to replace the standard option 2 of ISPF. You can even\n+ create your own EDIT dialog by creating a CLIST named EDITxxxx and\n+ specifying xxxx on this panel for your EDIT version. Option 2 on the\n+ primary panel then calls your EDIT dialog. Some locally used EDITs are\n+\n+ NEW  - A list of 17 datasets is maintained for your selection.\n+ APP  - A set of 17 applications each with 17 datasets is maintained.\n+ CTS  - A multi-screen list of datasets with many options (EDIT WORKBENCH).\n+\n+     If YES is entered for the \"PASS DSNAME\" option, ISPF will attempt\n+ to remember the last dataset you entered in an \"other\" data set field.\n+ This is effective on many though not all ISPF panels and can save much\n+ retyping of dataset names.\n+\n+     If YES is entered for the \"SAVE TSO\" option, ISPF will remember\n+ the last TSO command entered from option 6.\n+\n+     If YES is entered for the \"PRE AND POST\" option, ISPF will call\n+ dialogs named PREDIAL and POSTDIAL at start of an ISPF screen.\n)PROC\n   &ZUP = TWSD\n)END\n./ ADD NAME=SPFEOPT  0158-88272-89244-1051-00067-00107-00000-LL02155\n)ATTR\n # AREA(DYNAMIC)\n)BODY\n%ISPF+Environmental Options+\n%TSO command   ==>_ZCMD                                                +\n%\n+EDIT systems  ==>_OPTION2 +CTS=edit workbench, STD=IBM standard edit,\n+                          +NEW=better edit, APP=better edit with mult panels\n+Updt%PROFILE+ ==>_A+      +Enter%Y+and press%ENTER+\n+Pass DSNAME?  ==>_PASSDS  +YES=pass DSNAME field if possible.\n+Save cmds?    ==>_SAVETSO +YES=save last TSO command in option 6.\n+PRE/POST?     ==>_PREPO   +YES=do PREDIAL and POSTDIAL processing.\n%SUPERKEY+    +==>_SUPER   +Enter%YES+and press%ENTER+to invoke SUPERKEY\n+                           environmental options panel\n%HOTKEYS +    +==>_HOT     +Enter%YES+and press%ENTER+to invoke HOTKEYS\n%                          +Enter%NO +and press%ENTER+to de-activate HOTKEYS+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+Press%ENTER+to save changes   +Press%END+to cancel\n)INIT\n.CURSOR = ZCMD\n.HELP = SPFEOH\n&SUPER = &Z\nIF (&PREPO = &Z)\n    &PREPO = 'NO'\nIF (&PASSDS = &Z)\n    &PASSDS = 'NO'\nIF (&SAVETSO = &Z)\n    &SAVETSO = 'NO'\n\n)REINIT\n&SUPER = &Z\nREFRESH *\n\n)PROC\n&ZSEL = TRANS( TRUNC (&ZCMD,'.')\n            ' ','CMD(%SPFEOPT &PREPO)'\n              *,'?'\n              )\nVPUT (OPTION2 PREPO PASSDS SAVETSO) PROFILE\nIF (&SUPER = YES)\n   IF (.MSG = ' ')\n      IF (.RESP = ENTER)\n         &PANLEXIT = 'SELECT CMD(%SUPERKEY)'\nIF (&HOT = YES)\n   IF (.MSG = ' ')\n      IF (.RESP = ENTER)\n         &PANLEXIT = 'SELECT CMD(%HOTKEYS)'\nIF (&HOT = NO)\n   IF (.MSG = ' ')\n      IF (.RESP = ENTER)\n         &PANLEXIT = 'SELECT CMD(%HOTKEYS OFF)'\nIF (&A = Y)\n   IF (.MSG = ' ')\n      IF (.RESP = ENTER)\n         &PANLEXIT = 'SELECT CMD(%PROF)'\n         &A = &Z\n&GPML = 'modification of standard environment complete'\n.MSG = GPM001A\n)END\n./ ADD NAME=SPFTSO   0103-82250-83314-1819-00013-00016-00000-KK00150\n)ATTR\n_ TYPE(INPUT) INTENS(LOW) CAPS(OFF)\n)BODY\n%------------------------  EDIT TSO COMMAND OUTPUT  ----------------------------\n%ENTER TSO COMMAND (NO CLISTS):\n%\n%===>_ZCMD\n\n\n%                                                                              %\n)INIT\n)PROC\n)END\n./ ADD NAME=SPFYFND2 0103-84335-84335-1346-00018-00016-00000-JS02150\n)ATTR\n# TYPE(OUTPUT) INTENS(LOW)\n)BODY\n%EDIT/BROWSE --- &FNDSDSN-------------------------------------------------------\n%COMMAND ===>_ZCMD                                            %SCROLL ===>_ZSCR+\n+\n% S+OR%E+FOR EDIT      %B+FOR BROWSE+\n+\n+                VER.MOD  CREATED   LAST MODIFIED  SIZE  INIT   MOD   ID\n+\n)MODEL\n _Z+#SPFSTATS                                                                  +\n)INIT\n  .ZVARS = '(TYPCODE)'\n  &ZSCR = 'PAGE'\n  &ZSCKEY = 'ZSCML'\n  .HELP = ISR2D000\n)END\n./ ADD NAME=TBLHDLR1 0118-85021-86345-1347-00041-00017-00000-JS02150\n)ATTR\n# TYPE(OUTPUT) INTENS(HIGH)\n\\ area(dynamic)\n\u00a2 type(dataout) intens(LOW)\n\" type(dataout) intens(HIGH)\n)BODY\n+\n%&PANTITLE\n+\n+ COMMAND INPUT ===>_ZCMD                                 + SCROLL AMT ==>_FNSC+\n\\thda1                                                                         \\\n\\thda2                                                                         \\\n+\n%&PANCOLH1\n%&PANCOLH2\n)MODEL\n _Z+#ENTRYDS1                                                                  +\n)INIT\n  .ZVARS = '(ACTCODE)'\n  &FNSC = CSR\n  .HELP = DOCS0HLP\n  IF (&THDA1 = &Z)\n      &THDA1 = '\u00a2                                 \"PF3\u00a2to EXIT '\n  IF (&THDA2 = &Z)\n      &THDA2 = '\u00a2               To left of item, put\"S\u00a2for Select,\"P\u00a2for Print'\n  IF (&DOCUPDT \u00ac= NO)\n    &RCHANGE = PASSTHRU\n    &RFIND = PASSTHRU\n)PROC\nIF (&ZCMD = RCHANGE)\n &PANLEXIT = 'SELECT CMD(%DOCADD 1)'\n &DOCRSHOW = YES\n VPUT DOCRSHOW SHARED\n .RESP = END\nIF (&ZCMD = RFIND)\n &DOC = '''&DOCSLVL1..&DOCSLVL2..INDEXES(&DOCSMEM)'''\n &PANLXSAV = 'EDIT DATASET(&DOC) MACRO(DOCEDUP)'\n &DOCRSHOW = YES\n VPUT DOCRSHOW SHARED\n .RESP = END\n)END\n./ ADD NAME=TBLHDLR2 0108-84264-86345-1347-00043-00019-00000-JS02150\n)ATTR\n# TYPE(OUTPUT) INTENS(LOW)\n\\ area(dynamic)\n\u00a2 type(dataout) intens(LOW)\n\" type(dataout) intens(HIGH)\n)BODY\n+\n%&PANTITLE\n+\n+ COMMAND INPUT ===>_ZCMD                                 + SCROLL AMT ==>_FNSC+\n\\thda1                                                                         \\\n\\thda2                                                                         \\\n+\n%&PANCOLH1\n%&PANCOLH2\n)MODEL\n _Z+#ENTRYDS1                                                                  +\n    #ENTRYDS2                                                                  +\n %   ---------------------------------------------------------------------------\n)INIT\n  .ZVARS = '(ACTCODE)'\n  IF (&FNSC = &Z)  &FNSC = CSR\n  .HELP = DOCS0HLP\n  IF (&THDA1 = &Z)\n      &THDA1 = '\u00a2                                 \"PF3\u00a2to EXIT '\n  IF (&THDA2 = &Z)\n      &THDA2 = '\u00a2               To left of item, put\"S\u00a2for Select,\"P\u00a2for Print'\n  IF (&DOCUPDT \u00ac= NO)\n    &RCHANGE = PASSTHRU\n    &RFIND = PASSTHRU\n)PROC\nIF (&ZCMD = RCHANGE)\n &PANLEXIT = 'SELECT CMD(%DOCADD 2)'\n &DOCRSHOW = YES\n VPUT DOCRSHOW SHARED\n .RESP = END\nIF (&ZCMD = RFIND)\n &DOC = '''&DOCSLVL1..&DOCSLVL2..INDEXES(&DOCSMEM)'''\n &PANLXSAV = 'EDIT DATASET(&DOC) MACRO(DOCEDUP)'\n &DOCRSHOW = YES\n VPUT DOCRSHOW SHARED\n .RESP = END\n)END\n./ ADD NAME=TBLHDLR3 0108-84264-86345-1347-00044-00020-00000-JS02150\n)ATTR\n# TYPE(OUTPUT) INTENS(LOW)\n\\ area(dynamic)\n\u00a2 type(dataout) intens(LOW)\n\" type(dataout) intens(HIGH)\n)BODY\n+\n%&PANTITLE\n+\n+ COMMAND INPUT ===>_ZCMD                                 + SCROLL AMT ==>_FNSC+\n\\thda1                                                                         \\\n\\thda2                                                                         \\\n+\n%&PANCOLH1\n%&PANCOLH2\n)MODEL\n _Z+#ENTRYDS1                                                                  +\n    #ENTRYDS2                                                                  +\n    #ENTRYDS3                                                                  +\n %   ---------------------------------------------------------------------------\n)INIT\n  .ZVARS = '(ACTCODE)'\n  IF (&FNSC = &Z)  &FNSC = CSR\n  .HELP = DOCS0HLP\n  IF (&THDA1 = &Z)\n      &THDA1 = '\u00a2                                 \"PF3\u00a2to EXIT '\n  IF (&THDA2 = &Z)\n      &THDA2 = '\u00a2               To left of item, put\"S\u00a2for Select,\"P\u00a2for Print'\n  IF (&DOCUPDT \u00ac= NO)\n    &RCHANGE = PASSTHRU\n    &RFIND = PASSTHRU\n)PROC\nIF (&ZCMD = RCHANGE)\n &PANLEXIT = 'SELECT CMD(%DOCADD 3)'\n &DOCRSHOW = YES\n VPUT DOCRSHOW SHARED\n .RESP = END\nIF (&ZCMD = RFIND)\n &DOC = '''&DOCSLVL1..&DOCSLVL2..INDEXES(&DOCSMEM)'''\n &PANLXSAV = 'EDIT DATASET(&DOC) MACRO(DOCEDUP)'\n &DOCRSHOW = YES\n VPUT DOCRSHOW SHARED\n .RESP = END\n)END\n./ ADD NAME=WHOISI   0111-81237-82334-1904-00025-00022-00000-JS02150\n)BODY\n%...................................  W H O I S I  .............................\n+\n+MY ACCOUNT IS ==============>% &ACCT\n+MY SYSTEM NUMBER IS ========>% &SYS\n+MY PROGRAMMER NAME FIELD ===>% &PROG\n+MY TERMINAL ID IS ==========>% &TERMID\n+MY DEFAULT PRINT DESTINATION>% &DEFDEST\n+\n+MY PRIMARY USER CATALOG IS =>% &CAT\n+\n+MY STEPLIB DATASETS ARE ====>% &SLIBDSN1\n+                        ====>% &SLIBDSN2\n+                        ====>% &SLIBDSN3\n+\n+MY USERID IS ===============>% &ZUSER\n+MY PROFILE PREFIX IS =======>% &ZPREFIX\n+NAME OF MY LOGON PROCEDURE =>% &ZLOGON\n+\n+MY TERMINAL TYPE IS ========>% &ZTERM\n+NUMBER OF PF KEYS IS =======>% &ZKEYS\n+\n+\n+                                %THAT'S WHO I AM !!!\n)END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PARMCNVS": {"ttr": 29953, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x00\\x7f\\x00\\x88\\x00\\x7f\\x12\\x00\\x00\\x05\\x00\\x05\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf2\\xf7\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-01-07T00:00:00", "modifydate": "1988-01-07T12:00:00", "lines": 5, "newlines": 5, "modlines": 0, "user": "FILE270"}, "text": "*****************************************************************\n*  Sorry, we do not have source for this program any longer.    *\n*     The load module is included in our load library.          *\n*     It builds a control card for ROTATE90.                    *\n*****************************************************************\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PARMLIB": {"ttr": 29955, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x00\\x7f\\x00\\x88\\x00\\x7f\\x12\\x00\\x0fF\\x0fF\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf2\\xf7\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-01-07T00:00:00", "modifydate": "1988-01-07T12:00:00", "lines": 3910, "newlines": 3910, "modlines": 0, "user": "FILE270"}, "text": "./ ADD NAME=ANTIFIND 0111-82173-82173-1632-00001-00027-00001-JS02150\nOPTION RESTORE ANTIFIND\n./ ADD NAME=BANNTBLE 0102-84356-84356-1527-00095-00095-00000-GD02150\n\n\u00a2   \u00a2\u00a2    \u00a2\u00a2\u00a2\u00a2\u00a2\u00a2 \u00a2\u00a2    \u00a2\u00a2\u00a2\u00a2      \u00a2\u00a2      \u00a2\u00a2    \u00a2\u00a2 \u00a2\u00a2\u00a2\u00a2\u00a2\u00a2    \u00a2\u00a2\n.                                                ..      ..\n<      <<    <<    <<    <<      <<        <<        <<        <<\n(      ((     ((     ((     ((      ((       ((       ((       ((\n+           ++      ++   ++++++++++++++++   ++      ++\n|   ||      ||      ||      ||      ||      ||      ||      ||\n&  &&&    && &&   && &&    &&&    &&&& &&&&  &&& &&  &&&  &&&& &&\n!   !!      !!      !!      !!      !!      !!              !!\n$   $$    $$$$$$ $$ $$ $$$$$$$      $$$$$$$ $$ $$ $$$$$$    $$\n*\n)))       ))       ))       ))      ))     ))     ))     ))\n;                 ..      ..              ,,      ,,     ,\n\u00ac                        \u00ac\u00ac\u00ac\u00ac\u00ac\u00ac\u00ac\u00ac       \u00ac\u00ac\n-                        --------\n/      //     //     //     //     //     //     //\n\u00a6   \u00a6\u00a6      \u00a6\u00a6      \u00a6\u00a6                      \u00a6\u00a6      \u00a6\u00a6      \u00a6\u00a6\n,                                         ,,      ,,     ,\n%%%%    %%%%   %%     %%     %%     %%     %%     %%  %%%%%   %%%\n_                                                        ________\n>>>        >>        >>        >>      >>    >>    >>    >>\n?  ????   ??  ??      ??     ??     ??      ??              ??\n`\n:                 ..      ..              ..      ..\n# ##  ##  ##  ## ######## ##  ##  ##  ## ######## ##  ##  ##  ##\n@ @@@@@@ @@    @@@@ @@ @@@@ @@ @@@@ @@@@@@@       @@@@@@\n'     '''      ''     '\n=                ================\n\"\"\"\"  \"\"\" \"\"   \"\"\"    \"\na AAAAAA AA    AAAA    AAAAAAAAAAAA    AAAA    AAAA    AAAA    AA\nbBBBBBBB BB    BBBB    BBBBBBBBB BB    BBBB    BBBB    BBBBBBBBB\nc CCCCCC CC    CCCC      CC      CC      CC      CC    CC CCCCCC\ndDDDDDDD DD    DDDD    DDDD    DDDD    DDDD    DDDD    DDDDDDDDD\neEEEEEEEEEE      EE      EEEEE   EE      EE      EE      EEEEEEEE\nfFFFFFFFFFF      FF      FFFF    FF      FF      FF      FF\ng GGGGGG GG    GGGG      GG      GG   GGGGG    GGGG    GG GGGGGG\nhHH    HHHH    HHHH    HHHHHHHHHHHH    HHHH    HHHH    HHHH    HH\niIIIIIIII   II      II      II      II      II      II   IIIIIIII\nj      JJ      JJ      JJ      JJ      JJ      JJJJ    JJ JJJJJJ\nkKK   KK KK  KK  KK KK   KKKK    KK KK   KK  KK  KK   KK KK    KK\nlLL      LL      LL      LL      LL      LL      LL      LLLLLLLL\nmM      MMM    MMMMM  MMMMMMMMMMMMM MM MMMM    MMMM    MMMM    MM\nnNN    NNNNN   NNNNNN  NNNN NN NNNN  NNNNNN   NNNNN    NNNN     N\no OOOOOO OO    OOOO    OOOO    OOOO    OOOO    OOOO    OO OOOOOO\npPPPPPPP PP    PPPP    PPPPPPPPP PP      PP      PP      PP\nq QQQQQQ QQ    QQQQ    QQQQ    QQQQ    QQQQ QQ QQQQ  QQQQ QQQQQQ\nrRRRRRRR RR    RRRR    RRRRRRRRR RR RR   RR  RR  RR   RR RR    RR\n~\ns SSSSSS SS    SSSS       SSS        SSS       SSSS    SS SSSSSS\ntTTTTTTTT   TT      TT      TT      TT      TT      TT      TT\nuUU    UUUU    UUUU    UUUU    UUUU    UUUU    UUUU    UU UUUUUU\nvVV    VVVV    VVVV    VVVV    VVVV    VVVV    VV VV  VV    VV\nwWW    WWWW    WWWW    WWWW WW WWWWWWWWWWWWW  WWWWW    WWW      W\nxXX    XXXX    XX XX  XX   XXXX    XXXX   XX  XX XX    XXXX    XX\nyYY    YYYY    YY YY  YY   YYYY     YY      YY      YY      YY\nzZZZZZZZZ     ZZ     ZZ    ZZZZZ    ZZ     ZZ     ZZ     ZZZZZZZZ\n{  {{{{{{  {{      {{     {{      {{       {{      {{      {{{{{{\nA AAAAAA AA    AAAA    AAAAAAAAAAAA    AAAA    AAAA    AAAA    AA\nBBBBBBBB BB    BBBB    BBBBBBBBB BB    BBBB    BBBB    BBBBBBBBB\nC CCCCCC CC    CCCC      CC      CC      CC      CC    CC CCCCCC\nDDDDDDDD DD    DDDD    DDDD    DDDD    DDDD    DDDD    DDDDDDDDD\nEEEEEEEEEEE      EE      EEEEE   EE      EE      EE      EEEEEEEE\nFFFFFFFFFFF      FF      FFFF    FF      FF      FF      FF\nG GGGGGG GG    GGGG      GG      GG   GGGGG    GGGG    GG GGGGGG\nHHH    HHHH    HHHH    HHHHHHHHHHHH    HHHH    HHHH    HHHH    HH\nIIIIIIIII   II      II      II      II      II      II   IIIIIIII\n}}}}}}       }}      }}       }}      }}     }}      }}  }}}}}}\nJ      JJ      JJ      JJ      JJ      JJ      JJJJ    JJ JJJJJJ\nKKK   KK KK  KK  KK KK   KKKK    KK KK   KK  KK  KK   KK KK    KK\nLLL      LL      LL      LL      LL      LL      LL      LLLLLLLL\nMM      MMM    MMMMM  MMMMMMMMMMMMM MM MMMM    MMMM    MMMM    MM\nNNN    NNNNN   NNNNNN  NNNN NN NNNN  NNNNNN   NNNNN    NNNN     N\nO OOOOOO OO    OOOO    OOOO    OOOO    OOOO    OOOO    OO OOOOOO\nPPPPPPPP PP    PPPP    PPPPPPPPP PP      PP      PP      PP\nQ QQQQQQ QQ    QQQQ    QQQQ    QQQQ    QQQQ QQ QQQQ  QQQQ QQQQQQ\nRRRRRRRR RR    RRRR    RRRRRRRRR RR RR   RR  RR  RR   RR RR    RR\n\\\\\\       \\\\       \\\\       \\\\       \\\\       \\\\\nS SSSSSS SS    SSSS       SSS        SSS       SSSS    SS SSSSSS\nTTTTTTTTT   TT      TT      TT      TT      TT      TT      TT\nUUU    UUUU    UUUU    UUUU    UUUU    UUUU    UUUU    UU UUUUUU\nVVV    VVVV    VVVV    VVVV    VVVV    VVVV    VV VV  VV    VV\nWWW    WWWW    WWWW    WWWW WW WWWWWWWWWWWWW  WWWWW    WWW      W\nXXX    XXXX    XX XX  XX   XXXX    XXXX   XX  XX XX    XXXX    XX\nYYY    YYYY    YY YY  YY   YYYY     YY      YY      YY      YY\nZZZZZZZZZ     ZZ     ZZ    ZZZZZ    ZZ     ZZ     ZZ     ZZZZZZZZ\n0  0000   00  00  00  00  00  00  00  00  00  00  00  00   0000\n1    1     111      11      11      11      11      11    111111\n2  2222   22  22      22     22     22     22     22      222222\n3 333333     33     33    3333       33      33  33  33   3333\n4   44     44     44 44   444444     44      44      44      44\n5 555555  55      55555   5   55      55      55  55  55   5555\n6   66     66     66      66      66666   66  66  66  66   6666\n7 777777     77     77     77     77      77      77      77\n8  8888   88  88   8888   88  88  88  88  88  88  88  88   8888\n9  9999   99  99  99  99   99999      99     99     99     99\n./ ADD NAME=BAN2TBLE                               17OCT89 12.48.04\n\n\u00a2   \u00a2\u00a2    \u00a2\u00a2\u00a2\u00a2\u00a2\u00a2 \u00a2\u00a2       \u00a2\u00a2\u00a2\u00a2\u00a2\u00a2    \u00a2\u00a2\n.                        ..      ..\n<    <<     <<     <<       <<       <<\n(     ((     ((      ((      ((       ((\n+   ++      ++   ++++++++   ++      ++\n|   ||      ||      ||      ||      ||\n&  &&&    && &&   &&&& &&&&  &&&  &&&& &&\n!   !!      !!      !!              !!\n$  $$$    $$  $     $     $  $$    $$$\n*\n) ))       ))      ))      ))     ))\n;         ..              ,,     ,\n\u00ac                \u00ac\u00ac\u00ac\u00ac\u00ac\u00ac\u00ac\u00ac      \u00ac\u00ac\n-                --------\n/  //       //       //       //       //\n\u00a6   \u00a6\u00a6      \u00a6\u00a6              \u00a6\u00a6      \u00a6\u00a6\n,                 ,,      ,,     ,\n% %%  %%     %%     %%     %%     %%  %%\n_                                ________\n>  >>       >>       >>     >>      >>\n?  ????   ?   ??     ??             ??\n`\n: ..      ..              ..      ..\n# ##  ## ######## ##  ## ######## ##  ##\n@ @@@@@@ @@ @  @@@@ @@@@@@@       @@@@@@\n'     '''      ''     '\n=                ================\n\"\"\"\"  \"\"\" \"\"   \"\"\"    \"\na AAAAAA AA    AAAAAAAAAAAA    AAAA    AA\nbBBBBBBB BB    BBBBBBBBB BB    BBBBBBBBB\nc CCCCCC CC    CCCC      CC    CC CCCCCC\ndDDDDDDD DD    DDDD    DDDD    DDDDDDDDD\neEEEEEEEEEE      EEEE    EE      EEEEEEEE\nfFFFFFFFFFF      FFFF    FF      FF\ng GGGGGG GG      GG   GGGGG    GG GGGGGG\nhHH    HHHH    HHHHHHHHHHHH    HHHH    HH\niIIIIIIII   II      II      II   IIIIIIII\nj      JJ      JJ      JJJJ    JJ JJJJJJ\nkKK  KK  KK KK   KKKK    KK KK   KK  KK\nlLL      LL      LL      LL      LLLLLLLL\nmMM    MMMMM  MMMMMMMMMMMMM MM MMMM    MM\nnNNN   NNNNNN  NNNN NN NNNN  NNNNNN   NNN\no OOOOOO OO    OOOO    OOOO    OO OOOOOO\npPPPPPPP PP    PPPPPPPPP PP      PP\nq QQQQQQ QQ    QQQQ QQ QQQQ  QQQQ QQQQQQQ\nrRRRRRRR RR    RRRRRRRRR RR   RR RR    RR\n~\ns SSSSSS SSS    S  SSSS  S    SSS SSSSSS\ntTTTTTTTT   TT      TT      TT      TT\nuUU    UUUU    UUUU    UUUU    UU UUUUUU\nvVV    VVVV    VVVV    VV VV  VV    VV\nwWW    WWWW WW WWWWWWWWWWWWW  WWWWW    WW\nxXX    XX XX  XX   XXXX   XX  XX XX    XX\nyYY    YY YY  YY   YYYY     YY      YY\nzZZZZZZZZ     ZZ    ZZ    ZZ     ZZZZZZZZ\n{  {{{{{{  {{     {{       {{      {{{{{{\nA AAAAAA AA    AAAAAAAAAAAA    AAAA    AA\nBBBBBBBB BB    BBBBBBBBB BB    BBBBBBBBB\nC CCCCCC CC    CCCC      CC    CC CCCCCC\nDDDDDDDD DD    DDDD    DDDD    DDDDDDDDD\nEEEEEEEEEEE      EEEE    EE      EEEEEEEE\nFFFFFFFFFFF      FFFF    FF      FF\nG GGGGGG GG      GG   GGGGG    GG GGGGGG\nHHH    HHHH    HHHHHHHHHHHH    HHHH    HH\nIIIIIIIII   II      II      II   IIIIIIII\n}}}}}}}      }}       }}     }}  }}}}}}\nJ      JJ      JJ      JJJJ    JJ JJJJJJ\nKKK  KK  KK KK   KKKK    KK KK   KK  KK\nLLL      LL      LL      LL      LLLLLLLL\nMMM    MMMMM  MMMMMMMMMMMMM MM MMMM    MM\nNNNN   NNNNNN  NNNN NN NNNN  NNNNNN   NNN\nO OOOOOO OO    OOOO    OOOO    OO OOOOOO\nPPPPPPPP PP    PPPPPPPPP PP      PP\nQ QQQQQQ QQ    QQQQ QQ QQQQ  QQQQ QQQQQQQ\nRRRRRRRR RR    RRRRRRRRR RR   RR RR    RR\n\\\\\\       \\\\       \\\\       \\\\       \\\\\nS SSSSSS SSS    S  SSSS  S    SSS SSSSSS\nTTTTTTTTT   TT      TT      TT      TT\nUUU    UUUU    UUUU    UUUU    UU UUUUUU\nVVV    VVVV    VVVV    VV VV  VV    VV\nWWW    WWWW WW WWWWWWWWWWWWW  WWWWW    WW\nXXX    XX XX  XX   XXXX   XX  XX XX    XX\nYYY    YY YY  YY   YYYY     YY      YY\nZZZZZZZZZ     ZZ    ZZ    ZZ     ZZZZZZZZ\n0  0000   00  00  00  00  00  00   0000\n1    1     111      11      11    111111\n2  2222   22  22     22     22    222222\n3 3333   33  33     33   33  33   3333\n4  4444   44 44  4444444     44      44\n5 555555  55        555   55  55   5555\n6  66     66      66666   66  66   6666\n7 777777     77     77     77     77\n8  8888   88  88   8888   88  88   8888\n9  9999   99  99   99999      99     99\n./ ADD NAME=BAN3TBLE                               17OCT89 12.48.04\n\n\u00a2   OO    OOOOOO OO       OOOOOO    OO\n.                        OO      OO\n<    OO     OO     OO       OO       OO\n(     OO     OO      OO      OO       OO\n+   OO      OO   OOOOOOOO   OO      OO\n|   OO      OO      OO      OO      OO\n&  OOO    OO OO   OOOO OOOO  OOO  OOOO OO\n!   OO      OO      OO              OO\n$  OOO    OO  O     O     O  OO    OOO\n*\n) OO       OO      OO      OO     OO\n;         OO              OO     O\n\u00ac                OOOOOOOO      OO\n-                OOOOOOOO\n/  OO       OO       OO       OO       OO\n\u00a6   OO      OO              OO      OO\n,                 OO      OO     O\n% OO  OO     OO     OO     OO     OO  OO\n_                                OOOOOOOO\n>  OO       OO       OO     OO      OO\n?  OOOO   O   OO     OO             OO\n`\n: OO      OO              OO      OO\n# OO  OO OOOOOOOO OO  OO OOOOOOOO OO  OO\n@ OOOOOO OO O  OOOO OOOOOOO       OOOOOO\n'     OOO      OO     O\n=                OOOOOOOOOOOOOOOO\n\"OOO  OOO OO   OOO    O\na OOOOOO OO    OOOOOOOOOOOO    OOOO    OO\nbOOOOOOO OO    OOOOOOOOO OO    OOOOOOOOO\nc OOOOOO OO    OOOO      OO    OO OOOOOO\ndOOOOOOO OO    OOOO    OOOO    OOOOOOOOO\neOOOOOOOOOO      OOOO    OO      OOOOOOOO\nfOOOOOOOOOO      OOOO    OO      OO\ng OOOOOO OO      OO   OOOOO    OO OOOOOO\nhOO    OOOO    OOOOOOOOOOOO    OOOO    OO\niOOOOOOOO   OO      OO      OO   OOOOOOOO\nj      OO      OO      OOOO    OO OOOOOO\nkOO  OO  OO OO   OOOO    OO OO   OO  OO\nlOO      OO      OO      OO      OOOOOOOO\nmOO    OOOOO  OOOOOOOOOOOOO OO OOOO    OO\nnOOO   OOOOOO  OOOO OO OOOO  OOOOOO   OOO\no OOOOOO OO    OOOO    OOOO    OO OOOOOO\npOOOOOOO OO    OOOOOOOOO OO      OO\nq OOOOOO OO    OOOO OO OOOO  OOOO OOOOOOO\nrOOOOOOO OO    OOOOOOOOO OO   OO OO    OO\n~\ns OOOOOO OOO    O  OOOO  O    OOO OOOOOO\ntOOOOOOOO   OO      OO      OO      OO\nuOO    OOOO    OOOO    OOOO    OO OOOOOO\nvOO    OOOO    OOOO    OO OO  OO    OO\nwOO    OOOO OO OOOOOOOOOOOOO  OOOOO    OO\nxOO    OO OO  OO   OOOO   OO  OO OO    OO\nyOO    OO OO  OO   OOOO     OO      OO\nzOOOOOOOO     OO    OO    OO     OOOOOOOO\n{  OOOOOO  OO     OO       OO      OOOOOO\nA OOOOOO OO    OOOOOOOOOOOO    OOOO    OO\nBOOOOOOO OO    OOOOOOOOO OO    OOOOOOOOO\nC OOOOOO OO    OOOO      OO    OO OOOOOO\nDOOOOOOO OO    OOOO    OOOO    OOOOOOOOO\nEOOOOOOOOOO      OOOO    OO      OOOOOOOO\nFOOOOOOOOOO      OOOO    OO      OO\nG OOOOOO OO      OO   OOOOO    OO OOOOOO\nHOO    OOOO    OOOOOOOOOOOO    OOOO    OO\nIOOOOOOOO   OO      OO      OO   OOOOOOOO\n}OOOOOO      OO       OO     OO  OOOOOO\nJ      OO      OO      OOOO    OO OOOOOO\nKOO  OO  OO OO   OOOO    OO OO   OO  OO\nLOO      OO      OO      OO      OOOOOOOO\nMOO    OOOOO  OOOOOOOOOOOOO OO OOOO    OO\nNOOO   OOOOOO  OOOO OO OOOO  OOOOOO   OOO\nO OOOOOO OO    OOOO    OOOO    OO OOOOOO\nPOOOOOOO OO    OOOOOOOOO OO      OO\nQ OOOOOO OO    OOOO OO OOOO  OOOO OOOOOOO\nROOOOOOO OO    OOOOOOOOO OO   OO OO    OO\n\\OO       OO       OO       OO       OO\nS OOOOOO OOO    O  OOOO  O    OOO OOOOOO\nTOOOOOOOO   OO      OO      OO      OO\nUOO    OOOO    OOOO    OOOO    OO OOOOOO\nVOO    OOOO    OOOO    OO OO  OO    OO\nWOO    OOOO OO OOOOOOOOOOOOO  OOOOO    OO\nXOO    OO OO  OO   OOOO   OO  OO OO    OO\nYOO    OO OO  OO   OOOO     OO      OO\nZOOOOOOOO     OO    OO    OO     OOOOOOOO\n0  OOOO   OO  OO  OO  OO  OO  OO   OOOO\n1    O     OOO      OO      OO    OOOOOO\n2  OOOO   OO  OO     OO     OO    OOOOOO\n3 OOOO   OO  OO     OO   OO  OO   OOOO\n4  OOOO   OO OO  OOOOOOO     OO      OO\n5 OOOOOO  OO        OOO   OO  OO   OOOO\n6  OO     OO      OOOOO   OO  OO   OOOO\n7 OOOOOO     OO     OO     OO     OO\n8  OOOO   OO  OO   OOOO   OO  OO   OOOO\n9  OOOO   OO  OO   OOOOO      OO     OO\n./ ADD NAME=BAN4TBLE 0103-84356-84356-1525-00095-00095-00000-GD02150\n\n\u00a2   OO    OOOOOO OO    OOOO      OO      OO    OO OOOOOO    OO\n.                                                OO      OO\n<      OO    OO    OO    OO      OO        OO        OO        OO\n(      OO     OO     OO     OO      OO       OO       OO       OO\n+           OO      OO   OOOOOOOOOOOOOOOO   OO      OO\n|   OO      OO      OO      OO      OO      OO      OO      OO\n&  OOO    OO OO   OO OO    OOO    OOOO OOOO  OOO OO  OOO  OOOO OO\n!   OO      OO      OO      OO      OO      OO              OO\n$   OO    OOOOOO OO OO OOOOOOO      OOOOOOO OO OO OOOOOO    OO\n*\n)OO       OO       OO       OO      OO     OO     OO     OO\n;                 OO      OO              OO      OO     O\n\u00ac                        OOOOOOOO      OO\n-                        OOOOOOOO\n/      OO     OO     OO     OO     OO     OO     OO\n\u00a6   OO      OO      OO                      OO      OO      OO\n,                                         OO      OO     O\n%OOO    OOOO   OO     OO     OO     OO     OO     OO  OOOOO   OOO\n_                                                        OOOOOOOO\n>OO        OO        OO        OO      OO    OO    OO    OO\n?  OOOO   OO  OO      OO     OO     OO      OO              OO\n`\n:                 OO      OO              OO      OO\n# OO  OO  OO  OO OOOOOOOO OO  OO  OO  OO OOOOOOOO OO  OO  OO  OO\n@ OOOOOO OO    OOOO OO OOOO OO OOOO OOOOOOO       OOOOOO\n'     OOO      OO     O\n=                OOOOOOOOOOOOOOOO\n\"OOO  OOO OO   OOO    O\na OOOOOO OO    OOOO    OOOOOOOOOOOO    OOOO    OOOO    OOOO    OO\nbOOOOOOO OO    OOOO    OOOOOOOOO OO    OOOO    OOOO    OOOOOOOOO\nc OOOOOO OO    OOOO      OO      OO      OO      OO    OO OOOOOO\ndOOOOOOO OO    OOOO    OOOO    OOOO    OOOO    OOOO    OOOOOOOOO\neOOOOOOOOOO      OO      OOOOO   OO      OO      OO      OOOOOOOO\nfOOOOOOOOOO      OO      OOOO    OO      OO      OO      OO\ng OOOOOO OO    OOOO      OO      OO   OOOOO    OOOO    OO OOOOOO\nhOO    OOOO    OOOO    OOOOOOOOOOOO    OOOO    OOOO    OOOO    OO\niOOOOOOOO   OO      OO      OO      OO      OO      OO   OOOOOOOO\nj      OO      OO      OO      OO      OO      OOOO    OO OOOOOO\nkOO   OO OO  OO  OO OO   OOOO    OO OO   OO  OO  OO   OO OO    OO\nlOO      OO      OO      OO      OO      OO      OO      OOOOOOOO\nmO      OOO    OOOOO  OOOOOOOOOOOOO OO OOOO    OOOO    OOOO    OO\nnOO    OOOOO   OOOOOO  OOOO OO OOOO  OOOOOO   OOOOO    OOOO     O\no OOOOOO OO    OOOO    OOOO    OOOO    OOOO    OOOO    OO OOOOOO\npOOOOOOO OO    OOOO    OOOOOOOOO OO      OO      OO      OO\nq OOOOOO OO    OOOO    OOOO    OOOO    OOOO OO OOOO  OOOO OOOOOO\nrOOOOOOO OO    OOOO    OOOOOOOOO OO OO   OO  OO  OO   OO OO    OO\n~\ns OOOOOO OO    OOOO       OOO        OOO       OOOO    OO OOOOOO\ntOOOOOOOO   OO      OO      OO      OO      OO      OO      OO\nuOO    OOOO    OOOO    OOOO    OOOO    OOOO    OOOO    OO OOOOOO\nvOO    OOOO    OOOO    OOOO    OOOO    OOOO    OO OO  OO    OO\nwOO    OOOO    OOOO    OOOO OO OOOOOOOOOOOOO  OOOOO    OOO      O\nxOO    OOOO    OO OO  OO   OOOO    OOOO   OO  OO OO    OOOO    OO\nyOO    OOOO    OO OO  OO   OOOO     OO      OO      OO      OO\nzOOOOOOOO     OO     OO    OOOOO    OO     OO     OO     OOOOOOOO\n{  OOOOOO  OO      OO     OO      OO       OO      OO      OOOOOO\nA OOOOOO OO    OOOO    OOOOOOOOOOOO    OOOO    OOOO    OOOO    OO\nBOOOOOOO OO    OOOO    OOOOOOOOO OO    OOOO    OOOO    OOOOOOOOO\nC OOOOOO OO    OOOO      OO      OO      OO      OO    OO OOOOOO\nDOOOOOOO OO    OOOO    OOOO    OOOO    OOOO    OOOO    OOOOOOOOO\nEOOOOOOOOOO      OO      OOOOO   OO      OO      OO      OOOOOOOO\nFOOOOOOOOOO      OO      OOOO    OO      OO      OO      OO\nG OOOOOO OO    OOOO      OO      OO   OOOOO    OOOO    OO OOOOOO\nHOO    OOOO    OOOO    OOOOOOOOOOOO    OOOO    OOOO    OOOO    OO\nIOOOOOOOO   OO      OO      OO      OO      OO      OO   OOOOOOOO\n}OOOOO       OO      OO       OO      OO     OO      OO  OOOOOO\nJ      OO      OO      OO      OO      OO      OOOO    OO OOOOOO\nKOO   OO OO  OO  OO OO   OOOO    OO OO   OO  OO  OO   OO OO    OO\nLOO      OO      OO      OO      OO      OO      OO      OOOOOOOO\nMO      OOO    OOOOO  OOOOOOOOOOOOO OO OOOO    OOOO    OOOO    OO\nNOO    OOOOO   OOOOOO  OOOO OO OOOO  OOOOOO   OOOOO    OOOO     O\nO OOOOOO OO    OOOO    OOOO    OOOO    OOOO    OOOO    OO OOOOOO\nPOOOOOOO OO    OOOO    OOOOOOOOO OO      OO      OO      OO\nQ OOOOOO OO    OOOO    OOOO    OOOO    OOOO OO OOOO  OOOO OOOOOO\nROOOOOOO OO    OOOO    OOOOOOOOO OO OO   OO  OO  OO   OO OO    OO\n\\OO       OO       OO       OO       OO       OO\nS OOOOOO OO    OOOO       OOO        OOO       OOOO    OO OOOOOO\nTOOOOOOOO   OO      OO      OO      OO      OO      OO      OO\nUOO    OOOO    OOOO    OOOO    OOOO    OOOO    OOOO    OO OOOOOO\nVOO    OOOO    OOOO    OOOO    OOOO    OOOO    OO OO  OO    OO\nWOO    OOOO    OOOO    OOOO OO OOOOOOOOOOOOO  OOOOO    OOO      O\nXOO    OOOO    OO OO  OO   OOOO    OOOO   OO  OO OO    OOOO    OO\nYOO    OOOO    OO OO  OO   OOOO     OO      OO      OO      OO\nZOOOOOOOO     OO     OO    OOOOO    OO     OO     OO     OOOOOOOO\n0  OOOO   OO  OO  OO  OO  OO  OO  OO  OO  OO  OO  OO  OO   OOOO\n1    O     OOO      OO      OO      OO      OO      OO    OOOOOO\n2  OOOO   OO  OO      OO     OO     OO     OO     OO      OOOOOO\n3 OOOOOO     OO     OO    OOOO       OO      OO  OO  OO   OOOO\n4   OO     OO     OO OO   OOOOOO     OO      OO      OO      OO\n5 OOOOOO  OO      OOOOO   O   OO      OO      OO  OO  OO   OOOO\n6   OO     OO     OO      OO      OOOOO   OO  OO  OO  OO   OOOO\n7 OOOOOO     OO     OO     OO     OO      OO      OO      OO\n8  OOOO   OO  OO   OOOO   OO  OO  OO  OO  OO  OO  OO  OO   OOOO\n9  OOOO   OO  OO  OO  OO   OOOOO      OO     OO     OO     OO\n./ ADD NAME=CICSTATS 0112-85108-85262-0918-00079-00063-00079-JS02150\n FILE FILEIN FB 124\n  SMF64TME     4           (END'TIME)\n  SMF64DTE     4 PD\n  SMF64JBN     8           (JOB NAME)\n  JOBPRFIX     3 9\n  CICS_REGION  1 12\n  SMF64RST     4 17\n  FILLER       1\n  SMF64RSD     3 PD        (JOB'DATE)\n  SMF64DNM     44          (VSAM DSN)\n  SMF64NLR     4 BI Z      (RECORD'TOTAL)\n  SMF64NFS     4 BI Z      (BYTES'NOT'USED)\n  FILLER       2\n  SMF64NCS     2 BI Z      (TOT'CI'SPLT)\n  FILLER       2\n  SMF64NAS     2 BI Z      (TOT'CA'SPLT)\n  SMF64DDE     4 BI Z      (REC'DEL)\n  SMF64DIN     4 BI Z      (REC'INS)\n  SMF64DUP     4 BI Z      (REC'UPD)\n  SMF64DRE     4 BI Z      (REC'READ)\n  SMF64DFS     4 BI\n  FILLER       2\n  SMF64DCS     2 BI Z      (JOB'CI'SPLITS)\n  FILLER       2\n  SMF64DAS     2 BI Z      (JOB'CA'SPLITS)\n  FILLER       1\n  SMF64DEP     3 BI Z      (JOB'EXCPS)\n  FILLER       1 BI\n  SMF64XTN     1 BI Z      (EX'TNS)\n  SMF64VSR     6           (VOLSER)\nWORKAREA\n  PARMHOLD     7\n  PREFIX1      3  1\n  PREFIX1A     1  4\n  PREFIX2      3  4\n  PREFIX2A     1  7\n*                    PARMS COULD BE  AAACIC  (AGENCY & ALL CICS)\n*                                    AAACICX (AGENCY & SPECIFIC CICS)\n*                                    CIC     (ALL CICS)\n*                                    CICX    (SPECIFIC CICS)\n  NONREAD      4  BI  Z  (UPDATES'INSERTS'DELETES)\n  KILOWASTE    4  BI  Z  (UNUSED'KILO'BYTES)\n  IF SMF64DEP GT 20 GOTO SORTEM ELSE REJECT ENDIF\nSORTEM:\n  MOVE DYLPARM TO PARMHOLD\n  SORT FILEIN USING SMF64JBN SMF64DEP D\n  IF JOBPRFIX NE 'CIC' REJECT ENDIF\n  IF PREFIX1 NE 'CIC' GOTO CHK2 ENDIF\n  IF PREFIX1A EQ ' ' GOTO DOIT ENDIF\n  IF PREFIX1A EQ CICS_REGION GOTO DOIT ELSE REJECT ENDIF\nCHK2:\n  IF PREFIX2A EQ ' ' GOTO DOIT ENDIF\n  IF PREFIX2A EQ CICS_REGION GOTO DOIT ELSE REJECT ENDIF\nDOIT:\n   NONREAD = SMF64DDE + SMF64DIN + SMF64DUP\n   KILOWASTE = SMF64NFS / 1000\n  REPORT 150 WIDE\n  CONTROL SMF64JBN\n  LIST SUPPRESS SMF64JBN SUPPRESS SMF64RSD\n   SMF64DEP\n   SMF64NLR\n   SMF64DNM\n   SMF64VSR\n   SMF64DRE\n   NONREAD\n   SMF64NCS\n   SMF64NAS\n   SMF64XTN\n   SMF64TME\n   KILOWASTE WITH 1 BEFORE\n  ON CHANGE SMF64JBN\n  LIST 'TOTALS' AT SMF64JBN SUM SMF64DEP\n                            SUM SMF64DRE\n                            SUM NONREAD\n                            WITH 2 BEFORE AND WITH EJECT AFTER\n T1 'VSAM ACTIVITY BY CICS REGION'\n T1+5 DYLDATE\n T1+125 DYLPAGE\n T2 ' '\n./ ADD NAME=DIAL21   0101-80179-80183-0824-00001-00002-00001-JS02150\nDUMMY\n./ ADD NAME=DIAL22   0101-80179-80183-0825-00001-00002-00001-JS02150\nDUMMY\n./ ADD NAME=DIAL26   0101-80175-80183-0824-00001-00002-00001-JS02150\nDUMMY\n./ ADD NAME=DIAL7    0100-80183-80183-0825-00001-00001-00000-JS02150\nDUMMY\n./ ADD NAME=DLFR901A 0100-84061-84061-1121-00001-00001-00000-JS02150\n VERIFY FILE(VRFY1)\n./ ADD NAME=DLFR901B 0100-84061-84061-1122-00001-00001-00000-JS02150\n VERIFY FILE(VRFY2)\n./ ADD NAME=DLFR904  0100-84061-84061-1345-00008-00008-00000-JS02150\nC          00080\nFA\nFJ             R\nD     3  A1                   EQ3  V.IM                 REJ\nD     3  A1                   EQ3  VX'4B8994'           REJ\nD     3  A1                   EQ3  VX'4BC994'           REJ\nD     3  A1                   EQ3  VX'4B89D4'           REJ\nD     80 A1                     80 R1                   OUTOUT\n./ ADD NAME=DLFR905  0101-84061-84069-1059-00002-00002-00000-JS02150\n   AUTH 1\n   SCRIPT FROM(INGO) (FILE(FRMTOUT)) TWOPASS\n./ ADD NAME=DLF2DOC1 0100-85015-85015-1649-00049-00049-00000-GD02150\n*****************************************************************************\n*    PROGRAM PURPOSE: DISECT RECORD, WRITING OUT 80 BYTE CHUNCKS\n*****************************************************************************\nOPTION STRUCTURED\nFILE INFILE VB 255 LENGTH INLEN        ;INPUT FILE, VARIABLE BLOCKED 255\n   INCHAR 1\nFILE OUTFILE OUTPUT FROM OUTFILE FB 80 ;OUTPUT FILE, FIXED BLOCKED 80\n   OUTCHAR 1\n   OUTREC 80 1\nWORKAREA\n   LEN1       3 NU          ;LENGTH OF CHUNK OF INPUT RECORD BEING WRITTEN OUT\n   LEN2       3 NU                 ;LENGTH OF REMAINING INPUT RECORD\n   SEVENTYTWO 3 NU VALUE 72 REINIT ;DISPLACEMENT OF 72 FROM INDEX START\n***********************************************************************\n*    NEXT RECORD READ HERE BY DYL280\n***********************************************************************\nLEN2 = INLEN      ;INITIALIZE LENGTH OF REMAINING INPUT RECORD TO FULL LENGTH\nINW = 0           ;INITIALIZE PARSE POINT IN INPUT RECORD\nDOWHILE LEN2 GT 0  ;ANYTHING LEFT TO OUTPUT?\n   INX = INW       ;INITIALIZE PARSE POINT IN INPUT RECORD\n   DYLCOUNT1 = 0   ;INITIALIZE CHUNK LENGTH ACCUMULATOR\n*****************************************************************************\n*           REST OF INPUT RECORD FIT IN 72?\n*****************************************************************************\n   IF LEN2 LE 72\n      LEN1 = LEN2          ;SET CHUNK LENGTH TO REMAINING RECORD LENGTH\n*****************************************************************************\n*           NO? THEN SET CHUNK LENGTH TO 72 OR LOCATION OF LAST BLANK\n*****************************************************************************\n   ELSE\n      LEN1 = 72                      ;SET CHUNK LENGTH TO 72\n      DOWHILE INX LT SEVENTYTWO      ;LOOK FOR BLANK CLOSEST TO 72\n         DYLCOUNT1 = DYLCOUNT1 + 1   ;ACCUMULATE LENGTH OF CHUNK TO BE MOVED\n         IF INCHAR (INX) EQ SPACE    ;BLANK POSITION?\n            LEN1 = DYLCOUNT1         ;SET CHUNK LENGTH TO ACCUMLATOR\n            ENDIF\n         INX = INX + 1\n         ENDDO\n      ENDIF\n*****************************************************************************\n*           WRITE OUT THE CHUNK\n*****************************************************************************\n   MOVE INCHAR (INW) LENGTH LEN1 TO OUTCHAR ;MOVE CHUNK TO OUTPUT\n   WRITE OUTFILE                            ;WRITE OUTPUT\n   MOVE SPACE TO OUTREC                     ;CLEAR OUTPUT BUFFER\n   INW = INW + LEN1      ;INCREMENT PARSE POINT BY LENGTH OF CHUNCK WRITTEN\n   LEN2 = INLEN - INW    ;DECREMENT REMAINING RECORD LENGTH BY CHUNK MOVED\n   SEVENTYTWO = INW + 72 ;COMPUTE OFFSET FOR NEXT 72 BYTE CHUNK\n   ENDDO\n./ ADD NAME=DLF2DOC3 0106-86013-86013-1456-00023-00022-00000-GD02150\nOPTION STRUCTURED\nFILE INFILE LENGTH INLEN\n   SCRIPTAG  11  10\n   ENDTAG     8  7\n   GOODREC   79  8\nFILE OUTFILE OUTPUT FROM OUTFILE FB 80\n   FILLER     1  1 VALUE ' '\n   OUTREC    79  2\nREAD INFILE\nDOWHILE SCRIPTAG NE 'SCRIPT FROM'\n   MOVE SPACE TO INFILE LENGTH 256\n   READ INFILE\n   ENDDO\nMOVE SPACE TO INFILE LENGTH 256\nREAD INFILE\nDOWHILE ENDTAG NE 'DSMEXC09'\n   MOVE SPACE TO OUTREC\n   MOVE GOODREC TO OUTREC LENGTH INLEN\n   WRITE OUTFILE\n   MOVE SPACE TO INFILE LENGTH 256\n   READ INFILE\n   ENDDO\nSTOP\n./ ADD NAME=DSNSTATS 0108-85108-88270-1309-00072-00067-00016-HG00155\n FILE FILEIN FB 124\n  SMF64TME     4           (STEP'END)\n  SMF64DTE     4 PD\n  SMF64JBN     8           (JOB NAME)\n  JOBPRFIX     3 9\n  FILLER       2 12\n  JOBSUFIX     3 14\n  SMF64RST     4 17        (TIME)\n  FILLER       1\n  SMF64RSD     3 PD        (JOB'DATE)\n  SMF64DNM     44          (VSAM DSN)\n  FILLER       1\n  SMF64NLR     3 BI Z      (RECD'TOTL)\n  SMF64NFS     4 BI\n  FILLER       2 BI\n  SMF64NCS     2 BI Z      (TOT'CI'SPLT)\n  FILLER       2\n  SMF64NAS     2 BI Z      (TOT'CA'SPLT)\n  FILLER       1 BI\n  SMF64DDE     3 BI Z      (REC'DEL)\n  FILLER       1 BI\n  SMF64DIN     3 BI Z      (REC'INS)\n  FILLER       1 BI\n  SMF64DUP     3 BI Z      (REC'UPD)\n  FILLER       1\n  SMF64DRE     3 BI Z      (REC'READ)\n  SMF64DFS     4 BI\n  FILLER       2\n  SMF64DCS     2 BI Z      (JOB'CI'SPLITS)\n  FILLER       2\n  SMF64DAS     2 BI Z      (JOB'CA'SPLITS)\n  FILLER       1\n  SMF64DEP     3 BI Z      (JOB'EXCPS)\n  FILLER       1 BI\n  SMF64XTN     1 BI Z      (EX'TNS)\n  SMF64VSR     6           (VOLSER)\nWORKAREA\n   AGENCY       3\n   NONREAD      3  BI  Z  (UPDTS'INSRTS'DELS)\n  ON ONE\n  MOVE DYLPARM TO AGENCY\n  ENDONE\n  IF JOBSUFIX NE AGENCY REJECT ENDIF\n  IF JOBSUFIX EQ '155' AND JOBPRFIX EQ 'CIC' REJECT ENDIF\n  IF SMF64DEP GT 200 GOTO SORTEM ELSE REJECT ENDIF\nSORTEM:\n  SORT FILEIN USING SMF64DNM SMF64RSD SMF64TME\n  REPORT 145 WIDE\n  CONTROL SMF64DNM\n   NONREAD = SMF64DDE + SMF64DIN + SMF64DUP\n  LIST SUPPRESS SMF64DNM SUPPRESS SMF64RSD\n   SMF64TME\n   SMF64JBN\n   SMF64VSR\n   SMF64NLR\n   SMF64DEP\n   SMF64DRE\n   NONREAD\n   SMF64XTN\n   SMF64NCS\n   SMF64NAS\n   SMF64XTN\n                        WITH 1 BEFORE\n  ON CHANGE SMF64DNM\n  LIST 'TOTALS' AT SMF64JBN SUM SMF64DEP\n                            SUM SMF64DRE\n                            SUM NONREAD\n                            WITH 2 BEFORE AND WITH 2 AFTER\n T1 'VSAM ACTIVITY BY DSN SHOWING SUMMARY FILE STATUS'\n T1+5 DYLDATE\n T1+125 DYLPAGE\n T2 ' '\n./ ADD NAME=DYLABEL,SSI=00005123                   17OCT89 12.48.04\n$IF FREE\n$DEFAULT       #1=4     #2=6     #3=33     #4=132\n               #5=NULL           #6=1      #7=NULL\n$DEND\n*    #1 - NUMBER OF LABELS ACROSS THE PAGE - A NUMERIC VALUE\n*         OR DATANAME, LIMIT IS BASED ON THE LABEL SIZE & REPORT WIDTH\n*    #2 - NUMBER OF PRINT LINES PER LABEL - A NUMERIC VALUE\n*         OR DATANAME, LIMIT IS 9\n*    #3 - SIZE OF LABEL - A NUMERIC VALUE, LIMIT IS LE REPORT WIDTH\n*    #4 - WIDTH OF PRINTER - A NUMERIC VALUE, LIMIT IS 204\n*    #5 - PAGE EJECT OR SPACE 0-9 LINES AFTER PRINTING LAST LINE\n*       - 'EJECT' OR NUMERIC VALUES OF 0 THROUGH 9\n*    #6 - EVERY NTH RECORD IS SELECTED - A NUMERIC VALUE OR DATANAME\n*    #7 - LIMIT THE LABELS - A NUMERIC VALUE OR DATANAME\n*       - MAXIMUM IS 999,999,999\n*    #8 - LINE 1 FIELD - A DATANAME OR A LITERAL\n*    #9 - LINE 2 FIELD - A DATANAME OR A LITERAL\n*    #A - LINE 3 FIELD - A DATANAME OR A LITERAL\n*    #B - LINE 4 FIELD - A DATANAME OR A LITERAL\n*    #C - LINE 5 FIELD - A DATANAME OR A LITERAL\n*    #D - LINE 6 FIELD - A DATANAME OR A LITERAL\n*    #E - LINE 7 FIELD - A DATANAME OR A LITERAL\n*    #F - LINE 8 FIELD - A DATANAME OR A LITERAL\n*    #G - LINE 9 FIELD - A DATANAME OR A LITERAL\nWORKAREA\n    DYL#ZSELNO      2  PD   VALUE 0\n    DYL#ZSZLBL      2  PD   VALUE 0\n    DYL#ZLIMIT      5  PD   VALUE 0\n    DYL#ZLBLCT      2  PD   VALUE 0\n    DYL#ZLINES      2  PD   VALUE 9\n    DYL#ZERR       30       VALUE 'CHECK YOUR VARIABLE INPUT(S) !'\nWORKAREA\n$IF  #8\n    DYL#ZLINE1      #4\n$IFE\n$IF  #9\n    DYL#ZLINE2      #4\n$IFE\n$IF  #A\n    DYL#ZLINE3      #4\n$IFE\n$IF  #B\n    DYL#ZLINE4      #4\n$IFE\n$IF  #C\n    DYL#ZLINE5      #4\n$IFE\n$IF  #D\n    DYL#ZLINE6      #4\n$IFE\n$IF  #E\n    DYL#ZLINE7      #4\n$IFE\n$IF  #F\n    DYL#ZLINE8      #4\n$IFE\n$IF  #G\n    DYL#ZLINE9      #4\n$IFE\n$IF  #8\n    REDEFINE   DYL#ZLINE1     DYL#ZL1LBL    #3\n$IFE\n$IF  #9\n    REDEFINE   DYL#ZLINE2     DYL#ZL2LBL    #3\n$IFE\n$IF  #A\n    REDEFINE   DYL#ZLINE3     DYL#ZL3LBL    #3\n$IFE\n$IF  #B\n    REDEFINE   DYL#ZLINE4     DYL#ZL4LBL    #3\n$IFE\n$IF  #C\n    REDEFINE   DYL#ZLINE5     DYL#ZL5LBL    #3\n$IFE\n$IF  #D\n    REDEFINE   DYL#ZLINE6     DYL#ZL6LBL    #3\n$IFE\n$IF  #E\n    REDEFINE   DYL#ZLINE7     DYL#ZL7LBL    #3\n$IFE\n$IF  #F\n    REDEFINE   DYL#ZLINE8     DYL#ZL8LBL    #3\n$IFE\n$IF  #G\n    REDEFINE   DYL#ZLINE9     DYL#ZL9LBL    #3\n$IFE\n*\nON ONE     MOVE  #3        TO   DYL#ZSZLBL\n           IF    DYL#ZLINES    LT   #2\n$IF  #6\n           OR    DYL#ZSELNO   EQ   #6\n$IFE\n$IF  #7\n           OR    DYL#ZLIMIT     EQ   #7\n$IFE\n           OR    DYL#ZLIMIT     EQ   #1\n           OR    DYL#ZSZLBL     GT   #4\n           OR    DYL#ZSZLBL     EQ   0\n                 PRINT     DYL#ZERR     STOP      ENDIF\nENDONE\n*\n$IF  #6\n    DYL#ZSELNO   =   DYL#ZSELNO    +  1\n    IF   DYL#ZSELNO   LT   #6    REJECT   ENDIF\n    DYL#ZSELNO   =   0\n$IFE\n**********************************************************************\n*   SAVE DATA OF RECORD(S) IN WORKAREA                               *\n**********************************************************************\n$IF  #8\n    MOVE   #8    TO     DYL#ZL1LBL (INW)\n$IFE\n$IF  #9\n    MOVE   #9    TO     DYL#ZL2LBL (INW)\n$IFE\n$IF  #A\n    MOVE   #A    TO     DYL#ZL3LBL (INW)\n$IFE\n$IF  #B\n    MOVE   #B    TO     DYL#ZL4LBL (INW)\n$IFE\n$IF  #C\n    MOVE   #C    TO     DYL#ZL5LBL (INW)\n$IFE\n$IF  #D\n    MOVE   #D    TO     DYL#ZL6LBL (INW)\n$IFE\n$IF  #E\n    MOVE   #E    TO     DYL#ZL7LBL (INW)\n$IFE\n$IF  #F\n    MOVE   #F    TO     DYL#ZL8LBL (INW)\n$IFE\n$IF  #G\n    MOVE   #G    TO     DYL#ZL9LBL (INW)\n$IFE\n*\n$IF  #7\n    DYL#ZLIMIT    =      DYL#ZLIMIT    +      1\n    IF      DYL#ZLIMIT   LT   #7    GOTO   DYL#ZCONT   ENDIF\n    STOP\n$IFE\n**********************************************************************\n*   PRINT THE LABELS WHEN THE RIGHT AMOUNT IS ACCUMULATED            *\n**********************************************************************\nDYL#ZCONT:\n    INW      =      INW      +     #3\n    DYL#ZLBLCT   =      DYL#ZLBLCT   +      1\n    IF    DYL#ZLBLCT    LT      #1     ACCEPT   ENDIF\n    PERFORM    DYL#ZPROD   TO    DYL#ZPRODX\n    DYL#ZLBLCT   =      0\n    INW      =      0\n    INX      =      #2       *      #4\n    MOVE     SPACES     TO     DYL#ZLINE1     LENGTH    INX\n    ACCEPT\n*\n*\nREPORT   #4   WIDE\nDYL#ZPROD:\n$IF  #8\n             LIST    DYL#ZLINE1   AT    1\n$IFE\n$IF  #9\n             LIST    DYL#ZLINE2   AT    1\n$IFE\n$IF  #A\n             LIST    DYL#ZLINE3   AT    1\n$IFE\n$IF  #B\n             LIST    DYL#ZLINE4   AT    1\n$IFE\n$IF  #C\n             LIST    DYL#ZLINE5   AT    1\n$IFE\n$IF  #D\n             LIST    DYL#ZLINE6   AT    1\n$IFE\n$IF  #E\n             LIST    DYL#ZLINE7   AT    1\n$IFE\n$IF  #F\n             LIST    DYL#ZLINE8   AT    1\n$IFE\n$IF  #G\n             LIST    DYL#ZLINE9   AT    1\n$IFE\n$IF  #5\n                     WITH    #5    AFTER\n$IFE\nDYL#ZPRODX:\n\nON FINAL\n$IF  #8\n             LIST    DYL#ZLINE1   AT    1\n$IFE\n$IF  #9\n             LIST    DYL#ZLINE2   AT    1\n$IFE\n$IF  #A\n             LIST    DYL#ZLINE3   AT    1\n$IFE\n$IF  #B\n             LIST    DYL#ZLINE4   AT    1\n$IFE\n$IF  #C\n             LIST    DYL#ZLINE5   AT    1\n$IFE\n$IF  #D\n             LIST    DYL#ZLINE6   AT    1\n$IFE\n$IF  #E\n             LIST    DYL#ZLINE7   AT    1\n$IFE\n$IF  #F\n             LIST    DYL#ZLINE8   AT    1\n$IFE\n$IF  #G\n             LIST    DYL#ZLINE9   AT    1\n$IFE\n$IF  #5\n                     WITH    #5    AFTER\n$IFE\n$IF FIXED\n*  DYLABEL NOT VALID EXCEPT WITH DYL-280/DYL-280 II\n./ ADD NAME=DYLETTER 0112-85003-85009-0802-00274-00254-00030-GD02150\nOPTION STRUCTURED\nREPORT1\nFILE LETTERIN LENGTH INLEN\nINREC   80\nINCHAR   1 1\nFILE TEMPFILE OUTPUT FROM TEMPFILE VB 160 LENGTH OUTLEN\nOUTREC 160\nOUTCHAR  1 1\nWORKAREA\n   APOST 1   VALUE \"'\"\n   QUOT  1   VALUE '\"'\nINX = 0\nINZ = 0\nINW = 79\nDOWHILE INW GT 0 AND INCHAR (INW) EQ SPACE\n   INW = INW - 1\n   ENDDO\nDOWHILE INX LE INW\n   CASE INCHAR (INX)\n      WHEN EQ APOST\n         MOVE QUOT TO OUTCHAR (INZ)\n         INZ = INZ + 1\n         MOVE APOST TO OUTCHAR (INZ)\n         INZ = INZ + 1\n         MOVE QUOT TO OUTCHAR (INZ)\n         INZ = INZ + 1\n         INX = INX + 1\n      WHEN EQ QUOT\n         MOVE APOST TO OUTCHAR (INZ)\n         INZ = INZ + 1\n         MOVE QUOT TO OUTCHAR (INZ)\n         INZ = INZ + 1\n         MOVE APOST TO OUTCHAR (INZ)\n         INZ = INZ + 1\n         INX = INX + 1\n      ELSE\n         MOVE INCHAR (INX) TO OUTCHAR (INZ)\n         INZ = INZ + 1\n         INX = INX + 1\n      ENDCASE\n   ENDDO\nOUTLEN = INZ\nWRITE TEMPFILE\nREPORT2\nFILE TEMPFILE VB 160 STATUS LETTERSTAT LENGTH INLEN COUNT INCOUNT\n   INREC     160\n   INCHAR      1 1\nFILE CODEOUT FB 80 OUTPUT FROM CODEOUT\n   OUTREC     80\n   LTDLABEL    5 1\n   OUTTEXT    75\nWORKAREA\n   SPACELINE   6\n      FILLER   4 1    VALUE '@(SP'\n      SPACEAMT 1\n      FILLER   1      VALUE ')'\nWORKAREA\n   OUTFIXED   80\n      FILLER   1 1    VALUE '@'\n      OUTPOS1  2\n      FILLER   1      VALUE ' '\n      OUTAT   76      VALUE ' '\nWORKAREA\n   DOLLARDEF   53     VALUE '$DEFAULT #1=1 #2=NULL #3=NULL #4=NULL'\n                            ' #5=NULL #6=NULL'\nWORKAREA\n   OUTPOS       2 NU  VALUE 0\n   MOVELEN      2 NU  VALUE 0\nWORKAREA\n   CHECKIT    160     VALUE ' '\nREAD TEMPFILE\nMOVE INREC LENGTH INLEN TO CHECKIT\nMOVE DOLLARDEF TO OUTREC\nWRITE CODEOUT\nMOVE SPACE TO OUTREC\nMOVE '$DEND' TO OUTREC\nWRITE CODEOUT\nMOVE SPACE TO OUTREC\nMOVE 'OPTION COLUMNS 1 80' TO OUTREC\nWRITE CODEOUT\nMOVE SPACE TO OUTREC\nMOVE 'LTH #1' TO OUTREC\nWRITE CODEOUT\nMOVE SPACE TO OUTREC\nMOVE '$IF #2' TO OUTREC\nWRITE CODEOUT\nMOVE SPACE TO OUTREC\nMOVE '#2 WIDE' TO OUTREC\nWRITE CODEOUT\nMOVE SPACE TO OUTREC\nMOVE '$IFE' TO OUTREC\nWRITE CODEOUT\nMOVE SPACE TO OUTREC\nMOVE '$IF #3' TO OUTREC\nWRITE CODEOUT\nMOVE SPACE TO OUTREC\nMOVE '#3 LONG' TO OUTREC\nWRITE CODEOUT\nMOVE SPACE TO OUTREC\nMOVE '$IFE' TO OUTREC\nWRITE CODEOUT\nMOVE SPACE TO OUTREC\nMOVE '$IF #4' TO OUTREC\nWRITE CODEOUT\nMOVE SPACE TO OUTREC\nMOVE 'NOEJECT' TO OUTREC\nWRITE CODEOUT\nMOVE SPACE TO OUTREC\nMOVE '$IFE' TO OUTREC\nWRITE CODEOUT\nMOVE SPACE TO OUTREC\nMOVE '$IF #5' TO OUTREC\nWRITE CODEOUT\nMOVE SPACE TO OUTREC\nMOVE 'INDENT #5' TO OUTREC\nWRITE CODEOUT\nMOVE SPACE TO OUTREC\nMOVE '$IFE' TO OUTREC\nWRITE CODEOUT\nMOVE SPACE TO OUTREC\nMOVE '$IF #6' TO OUTREC\nWRITE CODEOUT\nMOVE SPACE TO OUTREC\nMOVE 'IDLENGTH #6' TO OUTREC\nWRITE CODEOUT\nMOVE SPACE TO OUTREC\nMOVE '$IFE' TO OUTREC\nWRITE CODEOUT\nMOVE SPACE TO OUTREC\nMOVE '$IF #7' TO OUTREC\nWRITE CODEOUT\nMOVE SPACE TO OUTREC\nMOVE 'LASER#7' TO OUTREC\nWRITE CODEOUT\nMOVE SPACE TO OUTREC\nMOVE '$IFE' TO OUTREC\nWRITE CODEOUT\nMOVE SPACE TO OUTREC\nMOVE 'LTD  ' TO LTDLABEL\nDOWHILE LETTERSTAT NE 'E'\n   DOWHILE CHECKIT EQ SPACE\n      DYLCOUNT1 = DYLCOUNT1 + 1\n      IF DYLCOUNT1 GT 9\n         MOVE '@(SP10)' TO OUTTEXT\n         WRITE CODEOUT\n         MOVE SPACE TO OUTTEXT\n         DYLCOUNT1 = 1\n         ENDIF\n      READ TEMPFILE\n      MOVE SPACE TO CHECKIT\n      MOVE INREC LENGTH INLEN TO CHECKIT\n      ENDDO\n   IF DYLCOUNT1 GT 0\n      SPACEAMT = DYLCOUNT1 + 1\n      MOVE SPACELINE TO OUTTEXT\n      WRITE CODEOUT\n      MOVE SPACE TO OUTTEXT\n      DYLCOUNT1 = 0\n      ENDIF\n   PERFORM CNTBLANKS TO ENDCOUNT\n   IF DYLCOUNT3 GT 3\n      PERFORM ASISOUT TO ENDASIS\n   ELSE\n      PERFORM TEXTOUT TO ENDTEXT\n      ENDIF\n   READ TEMPFILE\n   MOVE SPACE TO CHECKIT\n   MOVE INREC LENGTH INLEN TO CHECKIT\n   ENDDO\nCNTBLANKS:\n   INX = 0\n   DYLCOUNT2 = 0\n   DYLCOUNT3 = 0\n   DOWHILE INX LT INLEN\n      IF INCHAR (INX) EQ SPACE\n         DYLCOUNT2 = DYLCOUNT2 + 1\n      ELSE\n         IF DYLCOUNT2 GT DYLCOUNT3\n            DYLCOUNT3 = DYLCOUNT2\n            ENDIF\n         DYLCOUNT2 = 0\n         ENDIF\n      INX = INX + 1\n      ENDDO\nENDCOUNT:\nASISOUT:\n   MOVE '@(ASIS) @1' TO OUTTEXT\n   WRITE CODEOUT\n   MOVE SPACE TO OUTREC\n   INX = 0\n   DOWHILE INCHAR (INX) NE '@' AND INX LT INLEN\n      INX = INX + 1\n      ENDDO\n   IF INX GT 0\n      IF INX LT 80\n         MOVE INCHAR LENGTH INX TO OUTREC\n      ELSE\n         MOVE INCHAR LENGTH 80 TO OUTREC\n         ENDIF\n      IF CODEOUT EQ SPACE\n         MOVE X'00' TO CODEOUT\n         ENDIF\n      WRITE CODEOUT\n      MOVE SPACE TO OUTREC\n      IF INX GE 80\n         INW = 80\n         MOVE INCHAR (INW) LENGTH INX TO OUTREC\n         IF CODEOUT EQ SPACE\n            MOVE X'00' TO CODEOUT\n            ENDIF\n         WRITE CODEOUT\n         MOVE SPACE TO OUTREC\n         ENDIF\n      ENDIF\n   DOWHILE INX LT INLEN\n      INW = INX\n      MOVELEN = 0\n      DOWHILE INCHAR (INX) NE SPACE AND INX LT INLEN\n         MOVELEN = MOVELEN + 1\n         INX = INX + 1\n         ENDDO\n      OUTPOS = INW + 1\n      MOVE OUTPOS TO OUTPOS1\n      MOVE INCHAR (INW) LENGTH MOVELEN TO OUTAT\n      MOVE OUTFIXED TO OUTREC\n      WRITE CODEOUT\n      MOVE SPACE TO OUTREC\n      MOVE SPACE TO OUTAT\n      DOWHILE INCHAR (INX) EQ SPACE AND INX LT INLEN\n         INX = INX + 1\n         ENDDO\n      ENDDO\n   MOVE SPACE TO OUTTEXT\n   MOVE 'LTD  ' TO LTDLABEL\nENDASIS:\nTEXTOUT:\n   IF INLEN GT 74\n      PERFORM WRITESPLIT TO ENDSPLIT\n   ELSE\n      MOVE INREC LENGTH INLEN TO OUTTEXT\n      WRITE CODEOUT\n      MOVE SPACE TO OUTTEXT\n      ENDIF\nENDTEXT:\nWRITESPLIT:\n   PERFORM FINDLAST TO ENDLAST\n   INX = INX + 1\n   MOVE INCHAR LENGTH INX TO OUTTEXT\n   WRITE CODEOUT\n   MOVE SPACE TO OUTTEXT\n   INX = INX - 1\n   MOVE INCHAR (INX) LENGTH DYLCOUNT4 TO OUTTEXT\n   WRITE CODEOUT\n   MOVE SPACE TO OUTTEXT\nENDSPLIT:\nFINDLAST:\n   DYLCOUNT4 = 0\n   INX = 79\n   DOUNTIL (INX LT 75 AND INCHAR (INX) EQ SPACE) OR INX EQ 0\n      DYLCOUNT4 = DYLCOUNT4 + 1\n      INX = INX - 1\n      ENDDO\n   IF INX EQ 0 AND INCHAR (INX) NE SPACE\n      LIST 'RECORD' ' NOT PARSEABLE' ' -NUMBER:' INCOUNT ()\n      STOP\n      ENDIF\nENDLAST:\nON END OF INPUT\n   MOVE 'ENDLTD' TO OUTREC\n   WRITE CODEOUT\n   MOVE SPACE TO OUTREC\n   MOVE 'OPTION COLUMNS 1 72' TO OUTREC\n   WRITE CODEOUT\n   STOP\n./ ADD NAME=DYLLISTC 0111-83237-83241-1646-00098-00092-00000-GD02150\nOPTION STRUCTURED\nFILE DUMMFILE DUMMY\nFILE LISTFILE VB LENGTH LISTLEN STATUS INEOF\n   COLUMN1TAG  9   9\n   RECTOTAL   12  21\n   COLUMN2TAG 12  38\n   HURBA      12  50\n   COLUMN4TAG  6  96\n   CISIZE      5 115\n   CIPERCA     5 115\n   INXLEVELS   5 115\nWORKAREA\n   CISIZFND    3     VALUE 'NO '\n   CICAFND     3     VALUE 'NO '\n   HURBAFND    3     VALUE 'NO '\n   RECTOFND    3     VALUE 'NO '\nWORKAREA\n   VDEFINE     7     VALUE 'VDEFINE'\n   VPUT        4     VALUE 'VPUT'\n   VARNAME    10     VALUE ' '\n   CHAR        4     VALUE 'CHAR'\n   LEN         4  BI VALUE 0\nWORKAREA\n   WKRECTOT   12\n   WKHURBA    12\n   WKCISIZE    5\n   WKCIPERCA   5\n   WKINXLVL    5\nON ONE\n   READ LISTFILE\n   MOVE '(LCISIZE)' TO VARNAME\n   MOVE 5 TO LEN\n   CALL ISPLINK USING VDEFINE VARNAME WKCISIZE CHAR LEN\n   MOVE '(LRECTOT)' TO VARNAME\n   MOVE 12 TO LEN\n   CALL ISPLINK USING VDEFINE VARNAME WKRECTOT CHAR LEN\n   MOVE '(LHURBA)' TO VARNAME\n   CALL ISPLINK USING VDEFINE VARNAME WKHURBA CHAR LEN\n   MOVE '(LINXLVL)' TO VARNAME\n   MOVE 5 TO LEN\n   CALL ISPLINK USING VDEFINE VARNAME WKINXLVL CHAR LEN\n   MOVE '(LCIPERCA)' TO VARNAME\n   CALL ISPLINK USING VDEFINE VARNAME WKCIPERCA CHAR LEN\nENDONE\nDOWHILE INEOF NE 'E'\n   IF LISTLEN GT 118\n      PERFORM CHECKMISC TO ENDMISC\n      ENDIF\n   IF LISTLEN GT 60\n      PERFORM CHECKHURB TO ENDHURB\n      ENDIF\n   IF LISTLEN GT 31\n      PERFORM CHECKREC  TO ENDREC\n      ENDIF\n   READ LISTFILE\n   ENDDO\nMOVE '(LCISIZE)' TO VARNAME\nCALL ISPLINK USING VPUT VARNAME\nMOVE '(LCIPERCA)' TO VARNAME\nCALL ISPLINK USING VPUT VARNAME\nMOVE '(LINXLVL)' TO VARNAME\nCALL ISPLINK USING VPUT VARNAME\nMOVE '(LRECTOT)' TO VARNAME\nCALL ISPLINK USING VPUT VARNAME\nMOVE '(LHURBA)' TO VARNAME\nCALL ISPLINK USING VPUT VARNAME\nSTOP\nCHECKMISC:\n   IF COLUMN4TAG EQ 'CISIZE'\n      AND CISIZFND EQ 'NO '\n      MOVE CISIZE TO WKCISIZE\n      MOVE 'YES' TO CISIZFND\n      ENDIF\n   IF COLUMN4TAG EQ 'CI/CA-'\n      AND CICAFND EQ 'NO '\n      MOVE CIPERCA TO WKCIPERCA\n      MOVE 'YES' TO CICAFND\n      ENDIF\n   IF COLUMN4TAG EQ 'LEVELS'\n      MOVE INXLEVELS TO WKINXLVL\n      ENDIF\nENDMISC:\nCHECKHURB:\n   IF COLUMN2TAG EQ 'HI-USED-RBA-'\n      AND HURBAFND EQ 'NO '\n      MOVE HURBA TO WKHURBA\n      MOVE 'YES' TO HURBAFND\n      ENDIF\nENDHURB:\nCHECKREC:\n   IF COLUMN1TAG EQ 'REC-TOTAL'\n      IF RECTOFND EQ 'YES'\n         MOVE RECTOTAL TO WKRECTOT\n      ELSE\n         MOVE 'YES' TO RECTOFND\n         ENDIF\n      ENDIF\nENDREC:\n./ ADD NAME=DYLPRT   1700-85128-85128-1006-00008-00008-00000-REL17\n$DEFAULT #2=NULL\n$DEND\n$IF #2\nIF INCOUNT GT #2\n   STOP\n   ENDIF\n$IFE\n#1 #0\n./ ADD NAME=DYLSEL   1700-85128-85128-1006-00038-00038-00000-REL17\n$DEFAULT #0=DYLONE  #1=EQ   #2=1    #3=NULL #4=NULL #5=NULL #6=NULL\n #7=NULL #8=NULL #9=NULL #A=NULL #B=NULL #C=NULL #D=NULL #E=NULL\n #F=NULL #G=NULL #H=NULL #I=NULL #J=NULL #K=NULL #L=NULL #M=NULL\n #N=NULL #O=NULL #P=NULL #Q=NULL #R=NULL #S=NULL #T=NULL #U=NULL\n$DEND\nIF #0\n   #1\n   #2\n   #3\n   #4\n   #5\n   #6\n   #7\n   #8\n   #9\n   #A\n   #B\n   #C\n   #D\n   #E\n   #F\n   #G\n   #H\n   #I\n   #J\n   #K\n   #L\n   #M\n   #N\n   #O\n   #P\n   #Q\n   #R\n   #S\n   #T\n   #U\n NEXT\n ELSE REJECT ENDIF\n./ ADD NAME=DYLSPR1  1700-85128-85128-1006-00095-00095-00000-REL17\n$DEFAULT  #0=NULL #1=NULL #2=NULL #3=NULL #4=NULL #5=NULL #6=NULL\n #7=TOTAL #8=NULL #9=NULL #A=NULL #B=NULL #C=NULL #D=NULL #E=NULL\n #F=NULL  #G=NULL #H=NULL #I=NULL #J=NULL #K=NULL #L=NULL #M=NULL\n #N=NULL  #O=NULL #P=NULL #Q=NULL #R=NULL #S=NULL #T=NULL #U=NULL\n #V=NULL  #W=NULL #X=NULL\n$DEND\nWORKAREA\n   LINETOT 7 PD 2 E (#7) VALUE 0 REINIT\n   UNDRSCORE  3     VALUE 'NO '\n   COLHOLDER 15     (CONTROL FIELD) VALUE ' '\nWORKAREA\n   BRKNAME1  21     VALUE ' #0'\n   BRKNAME2  21     VALUE ' #1'\n   BRKNAME3  21     VALUE ' #2'\n   BRKNAME4  21     VALUE ' #3'\n   BRKNAME5  21     VALUE ' #4'\n   BRKNAME6  21     VALUE ' #5'\nWORKAREA\n   USEBREAK1 15  ()\n   USEBREAK2 15  ()\n   USEBREAK3 15  ()\n   USEBREAK4 15  ()\n   USEBREAK5 15  ()\n   USEBREAK6 15  ()\nWORKAREA\n   WRKBREAK  20\n   BRKCHAR    1 1\nWORKAREA\n   USEBRK    20\n   USECHAR    1 1\nON ONE\n   MOVE BRKNAME1 TO WRKBREAK\n   PERFORM PARSEBRK TO ENDPARSE\n   MOVE USEBRK TO USEBREAK1\n   MOVE BRKNAME2 TO WRKBREAK\n   PERFORM PARSEBRK TO ENDPARSE\n   MOVE USEBRK TO USEBREAK2\n   MOVE BRKNAME3 TO WRKBREAK\n   PERFORM PARSEBRK TO ENDPARSE\n   MOVE USEBRK TO USEBREAK3\n   MOVE BRKNAME4 TO WRKBREAK\n   PERFORM PARSEBRK TO ENDPARSE\n   MOVE USEBRK TO USEBREAK4\n   MOVE BRKNAME5 TO WRKBREAK\n   PERFORM PARSEBRK TO ENDPARSE\n   MOVE USEBRK TO USEBREAK5\n   MOVE BRKNAME6 TO WRKBREAK\n   PERFORM PARSEBRK TO ENDPARSE\n   MOVE USEBRK TO USEBREAK6\n   ENDONE\n$IF #0\nSORT #6 USING\n   #5\n   #4\n   #3\n   #2\n   #1\n   #0\nCONTROL\n   #0\n   #1\n   #2\n   #3\n   #4\n   #5\n$IFE\nPERFORM TOTALIT TO ENDTOT\nLIST #8\n#9\n#A\n#B\n#C\n#D\n#E\n#F\n#G\n#H\n#I\n#J\n#K\n#L\n#M\n#N\n#O\n#P\n#Q\n#R\n#S\n#T\n#U\n#V\n#W\n#X\nLINETOT\nCOLHOLDER\n./ ADD NAME=DYLSPR2  1700-85128-85128-1006-00327-00327-00000-REL17\n$DEFAULT #0=NULL #1=NULL #2=NULL #3=NULL #4=NULL #5=NULL #6=NULL\n #7=NULL #8=NULL #9=NULL #A=NULL #B=NULL #C=NULL #D=NULL #E=NULL\n #F=NULL #G=NULL #H=NULL #I=NULL #J=NULL #K=NULL #L=NULL #M=NULL\n #N=NULL #O=NULL #P=NULL #Q=NULL #R=NULL #S=NULL #T=NULL #U=NULL\n #V=NULL #W=NULL #X=NULL\n$DEND\nTOTALIT:\nLINETOT = LINETOT\n$IF #8\n   + #8\n$IFE\n$IF #9\n   + #9\n$IFE\n$IF #A\n   + #A\n$IFE\n$IF #B\n   + #B\n$IFE\n$IF #C\n   + #C\n$IFE\n$IF #D\n   + #D\n$IFE\n$IF #E\n   + #E\n$IFE\n$IF #F\n   + #F\n$IFE\n$IF #G\n   + #G\n$IFE\n$IF #H\n   + #H\n$IFE\n$IF #I\n   + #I\n$IFE\n$IF #J\n   + #J\n$IFE\n$IF #K\n   + #K\n$IFE\n$IF #L\n   + #L\n$IFE\n$IF #M\n   + #M\n$IFE\n$IF #N\n   + #N\n$IFE\n$IF #O\n   + #O\n$IFE\n$IF #P\n   + #P\n$IFE\n$IF #Q\n   + #Q\n$IFE\n$IF #R\n   + #R\n$IFE\n$IF #S\n   + #S\n$IFE\n$IF #T\n   + #T\n$IFE\n$IF #U\n   + #U\n$IFE\n$IF #V\n   + #V\n$IFE\n$IF #W\n   + #W\n$IFE\n$IF #X\n   + #X\n$IFE\nENDTOT:\nPARSEBRK:\n   INX = 0\n   INY = 0\n   UNDRSCORE = 'NO '\nLOOP:\n   IF INX LT 20\n      PERFORM MOVEBRK TO ENDBRK\n      GOTO LOOP\n      ENDIF\nENDPARSE:\nMOVEBRK:\n   IF UNDRSCORE EQ 'YES'\n      MOVE BRKCHAR (INX) TO USECHAR (INY)\n      INY = INY + 1\n      ENDIF\n   IF BRKCHAR (INX) EQ '_'\n      MOVE 'YES' TO UNDRSCORE\n      ENDIF\n   INX = INX + 1\nENDBRK:\n$IF #0\nON CHANGE #0\n   LIST SUM(#8\n   #9\n   #A\n   #B\n   #C\n   #D\n   #E\n   #F\n   #G\n   #H\n   #I\n   #J\n   #K\n   #L\n   #M\n   #N\n   #O\n   #P\n   #Q\n   #R\n   #S\n   #T\n   #U\n   #V\n   #W\n   #X\n   LINETOT)\n   USEBREAK1 AT COLHOLDER WITH 2 AFTER\n$IFE\n$IF #1\nON CHANGE #1\n   LIST SUM(#8\n   #9\n   #A\n   #B\n   #C\n   #D\n   #E\n   #F\n   #G\n   #H\n   #I\n   #J\n   #K\n   #L\n   #M\n   #N\n   #O\n   #P\n   #Q\n   #R\n   #S\n   #T\n   #U\n   #V\n   #W\n   #X\n   LINETOT)\n   USEBREAK2 AT COLHOLDER WITH 2 AFTER\n$IFE\n$IF #2\nON CHANGE #2\n   LIST SUM(#8\n   #9\n   #A\n   #B\n   #C\n   #D\n   #E\n   #F\n   #G\n   #H\n   #I\n   #J\n   #K\n   #L\n   #M\n   #N\n   #O\n   #P\n   #Q\n   #R\n   #S\n   #T\n   #U\n   #V\n   #W\n   #X\n   LINETOT)\n   USEBREAK3 AT COLHOLDER WITH 2 AFTER\n$IFE\n$IF #3\nON CHANGE #3\n   LIST SUM(#8\n   #9\n   #A\n   #B\n   #C\n   #D\n   #E\n   #F\n   #G\n   #H\n   #I\n   #J\n   #K\n   #L\n   #M\n   #N\n   #O\n   #P\n   #Q\n   #R\n   #S\n   #T\n   #U\n   #V\n   #W\n   #X\n   LINETOT)\n   USEBREAK4 AT COLHOLDER WITH 2 AFTER\n$IFE\n$IF #4\nON CHANGE #4\n   LIST SUM(#8\n   #9\n   #A\n   #B\n   #C\n   #D\n   #E\n   #F\n   #G\n   #H\n   #I\n   #J\n   #K\n   #L\n   #M\n   #N\n   #O\n   #P\n   #Q\n   #R\n   #S\n   #T\n   #U\n   #V\n   #W\n   #X\n   LINETOT)\n   USEBREAK5 AT COLHOLDER WITH 2 AFTER\n$IFE\n$IF #5\nON CHANGE #5\n   LIST SUM(#8\n   #9\n   #A\n   #B\n   #C\n   #D\n   #E\n   #F\n   #G\n   #H\n   #I\n   #J\n   #K\n   #L\n   #M\n   #N\n   #O\n   #P\n   #Q\n   #R\n   #S\n   #T\n   #U\n   #V\n   #W\n   #X\n   LINETOT)\n   USEBREAK6 AT COLHOLDER WITH 2 AFTER\n$IFE\nON FINAL\n   LIST SUM(#8\n   #9\n   #A\n   #B\n   #C\n   #D\n   #E\n   #F\n   #G\n   #H\n   #I\n   #J\n   #K\n   #L\n   #M\n   #N\n   #O\n   #P\n   #Q\n   #R\n   #S\n   #T\n   #U\n   #V\n   #W\n   #X\n   LINETOT)\n   'FINAL' AT COLHOLDER\nT1\nT1+2 DYLPAGE\nT2\nT2+2 DYLDATE\nT3   '#6'   WITH 4 AFTER\n./ ADD NAME=DYLSRT   1700-85128-85128-1006-00019-00019-00000-REL17\n$DEFAULT #1=NULL #2=NULL #3=NULL #4=NULL #5=NULL #6=NULL #7=NULL\n #8=NULL #9=NULL #A=NULL #B=NULL #C=NULL #D=NULL #E=NULL #F=NULL\n$DEND\nSORT #0 USING\n   #1\n   #2\n   #3\n   #4\n   #5\n   #6\n   #7\n   #8\n   #9\n   #A\n   #B\n   #C\n   #D\n   #E\n   #F\n./ ADD NAME=DYLSTD1  1700-85128-85128-1006-00114-00114-00000-REL17\n$DEFAULT #0=NULL #1=NULL #2=NULL #3=NULL #4=NULL #5=NULL #6=NULL\n #7=NULL #8=NULL #9=NULL #A=NULL #B=NULL #C=NULL #D=NULL #E=NULL\n #F=NULL #G=NULL #H=NULL #I=NULL #J=NULL #K=NULL #L=NULL #M=NULL\n #N=NULL #O=NULL #P=NULL #Q=NULL #R=NULL #S=NULL #T=NULL #U=NULL\n #V=NULL #W=NULL #X=NULL\n$DEND\nWORKAREA\n   COLHOLDER 15 (CONTROL FIELD) VALUE ' '\n   UNDRSCORE  3     VALUE 'NO '\nWORKAREA\n   BRKNAME1  21     VALUE ' #0'\n   BRKNAME2  21     VALUE ' #1'\n   BRKNAME3  21     VALUE ' #2'\n   BRKNAME4  21     VALUE ' #3'\n   BRKNAME5  21     VALUE ' #4'\n   BRKNAME6  21     VALUE ' #5'\nWORKAREA\n   USEBREAK1 15  ()\n   USEBREAK2 15  ()\n   USEBREAK3 15  ()\n   USEBREAK4 15  ()\n   USEBREAK5 15  ()\n   USEBREAK6 15  ()\nWORKAREA\n   WRKBREAK  20\n   BRKCHAR    1 1\nWORKAREA\n   USEBRK    20\n   USECHAR    1 1\nON ONE\n   MOVE BRKNAME1 TO WRKBREAK\n   PERFORM PARSEBRK TO ENDPARSE\n   MOVE USEBRK TO USEBREAK1\n   MOVE BRKNAME2 TO WRKBREAK\n   PERFORM PARSEBRK TO ENDPARSE\n   MOVE USEBRK TO USEBREAK2\n   MOVE BRKNAME3 TO WRKBREAK\n   PERFORM PARSEBRK TO ENDPARSE\n   MOVE USEBRK TO USEBREAK3\n   MOVE BRKNAME4 TO WRKBREAK\n   PERFORM PARSEBRK TO ENDPARSE\n   MOVE USEBRK TO USEBREAK4\n   MOVE BRKNAME5 TO WRKBREAK\n   PERFORM PARSEBRK TO ENDPARSE\n   MOVE USEBRK TO USEBREAK5\n   MOVE BRKNAME6 TO WRKBREAK\n   PERFORM PARSEBRK TO ENDPARSE\n   MOVE USEBRK TO USEBREAK6\n   ENDONE\n$IF #0\nSORT #6 USING\n   #5\n   #4\n   #3\n   #2\n   #1\n   #0\nCONTROL\n   #0\n   #1\n   #2\n   #3\n   #4\n   #5\n$IFE\nLIST #7\n   #8\n   #9\n   #A\n   #B\n   #C\n   #D\n   #E\n   #F\n   #G\n   #H\n   #I\n   #J\n   #K\n   #L\n   #M\n   #N\n   #O\n   #P\n   #Q\n   #R\n   #S\n   #T\n   #U\n   #V\n   #W\n   #X\n   COLHOLDER\nACCEPT\nPARSEBRK:\n   INX = 0\n   INY = 0\n   UNDRSCORE = 'NO '\nLOOP:\n   IF INX LT 20\n      PERFORM MOVEBRK TO ENDBRK\n      GOTO LOOP\n      ENDIF\nENDPARSE:\nMOVEBRK:\n   IF UNDRSCORE EQ 'YES'\n      MOVE BRKCHAR (INX) TO USECHAR (INY)\n      INY = INY + 1\n      ENDIF\n   IF BRKCHAR (INX) EQ '_'\n      MOVE 'YES' TO UNDRSCORE\n      ENDIF\n   INX = INX + 1\nENDBRK:\n./ ADD NAME=DYLSTD2  1700-85128-85128-1006-00228-00228-00000-REL17\n$DEFAULT #0=NULL #1=NULL #2=NULL #3=NULL #4=NULL #5=NULL #6=NULL\n #7=NULL #8=NULL #9=NULL #A=NULL #B=NULL #C=NULL #D=NULL #E=NULL\n #F=NULL #G=NULL #H=NULL #I=NULL #J=NULL #K=NULL #L=NULL #M=NULL\n #N=NULL #O=NULL #P=NULL #Q=NULL #R=NULL #S=NULL #T=NULL #U=NULL\n #V=NULL #W=NULL #X=NULL\n$DEND\n$IF #0\nON CHANGE #0\n   LIST SUM (#7\n   #8\n   #9\n   #A\n   #B\n   #C\n   #D\n   #E\n   #F\n   #G\n   #H\n   #I\n   #J\n   #K\n   #L\n   #M\n   #N\n   #O\n   #P\n   #Q\n   #R\n   #S\n   #T\n   #U\n   #V\n   #W\n   #X)\n   USEBREAK1 AT COLHOLDER WITH 2 AFTER\n$IFE\n$IF #1\nON CHANGE #1\n   LIST SUM (#7\n   #8\n   #9\n   #A\n   #B\n   #C\n   #D\n   #E\n   #F\n   #G\n   #H\n   #I\n   #J\n   #K\n   #L\n   #M\n   #N\n   #O\n   #P\n   #Q\n   #R\n   #S\n   #T\n   #U\n   #V\n   #W\n   #X)\n   USEBREAK2 AT COLHOLDER WITH 2 AFTER\n$IFE\n$IF #2\nON CHANGE #2\n   LIST SUM (#7\n   #8\n   #9\n   #A\n   #B\n   #C\n   #D\n   #E\n   #F\n   #G\n   #H\n   #I\n   #J\n   #K\n   #L\n   #M\n   #N\n   #O\n   #P\n   #Q\n   #R\n   #S\n   #T\n   #U\n   #V\n   #W\n   #X)\n   USEBREAK3 AT COLHOLDER WITH 2 AFTER\n$IFE\n$IF #3\nON CHANGE #3\n   LIST SUM (#7\n   #8\n   #9\n   #A\n   #B\n   #C\n   #D\n   #E\n   #F\n   #G\n   #H\n   #I\n   #J\n   #K\n   #L\n   #M\n   #N\n   #O\n   #P\n   #Q\n   #R\n   #S\n   #T\n   #U\n   #V\n   #W\n   #X)\n   USEBREAK4 AT COLHOLDER WITH 2 AFTER\n$IFE\n$IF #4\nON CHANGE #4\n   LIST SUM (#7\n   #8\n   #9\n   #A\n   #B\n   #C\n   #D\n   #E\n   #F\n   #G\n   #H\n   #I\n   #J\n   #K\n   #L\n   #M\n   #N\n   #O\n   #P\n   #Q\n   #R\n   #S\n   #T\n   #U\n   #V\n   #W\n   #X)\n   USEBREAK5 AT COLHOLDER WITH 2 AFTER\n$IFE\n$IF #5\nON CHANGE #5\n   LIST SUM (#7\n   #8\n   #9\n   #A\n   #B\n   #C\n   #D\n   #E\n   #F\n   #G\n   #H\n   #I\n   #J\n   #K\n   #L\n   #M\n   #N\n   #O\n   #P\n   #Q\n   #R\n   #S\n   #T\n   #U\n   #V\n   #W\n   #X)\n   USEBREAK6 AT COLHOLDER WITH 2 AFTER\n$IFE\n$IF #0\nON FINAL\n   LIST SUM (#7\n   #8\n   #9\n   #A\n   #B\n   #C\n   #D\n   #E\n   #F\n   #G\n   #H\n   #I\n   #J\n   #K\n   #L\n   #M\n   #N\n   #O\n   #P\n   #Q\n   #R\n   #S\n   #T\n   #U\n   #V\n   #W\n   #X)\n   'FINAL' AT COLHOLDER\n$IFE\nT1\nT1+2 DYLPAGE\nT2\nT2+2 DYLDATE\nT3   '#6'   WITH 4 AFTER\n./ ADD NAME=DYLSUM1  1700-85128-85128-1006-00113-00113-00000-REL17\n$DEFAULT #0=NULL #1=NULL #2=NULL #3=NULL #4=NULL #5=NULL #6=NULL\n #7=NULL #8=NULL #9=NULL #A=NULL #B=NULL #C=NULL #D=NULL #E=NULL\n #F=NULL #G=NULL #H=NULL #I=NULL #J=NULL #K=NULL #L=NULL #M=NULL\n #N=NULL #O=NULL #P=NULL #Q=NULL #R=NULL #S=NULL #T=NULL #U=NULL\n #V=NULL #W=NULL #X=NULL\n$DEND\nWORKAREA\n   UNDRSCORE  3     VALUE 'NO '\nWORKAREA\n   BRKNAME1  21     VALUE ' #0'\n   BRKNAME2  21     VALUE ' #1'\n   BRKNAME3  21     VALUE ' #2'\n   BRKNAME4  21     VALUE ' #3'\n   BRKNAME5  21     VALUE ' #4'\n   BRKNAME6  21     VALUE ' #5'\nWORKAREA\n   USEBREAK1 15  (CONTROL FIELD)\n   USEBREAK2 15  ()\n   USEBREAK3 15  ()\n   USEBREAK4 15  ()\n   USEBREAK5 15  ()\n   USEBREAK6 15  ()\nWORKAREA\n   WRKBREAK  20\n   BRKCHAR    1 1\nWORKAREA\n   USEBRK    20\n   USECHAR    1 1\nON ONE\n   MOVE BRKNAME1 TO WRKBREAK\n   PERFORM PARSEBRK TO ENDPARSE\n   MOVE USEBRK TO USEBREAK1\n   MOVE BRKNAME2 TO WRKBREAK\n   PERFORM PARSEBRK TO ENDPARSE\n   MOVE USEBRK TO USEBREAK2\n   MOVE BRKNAME3 TO WRKBREAK\n   PERFORM PARSEBRK TO ENDPARSE\n   MOVE USEBRK TO USEBREAK3\n   MOVE BRKNAME4 TO WRKBREAK\n   PERFORM PARSEBRK TO ENDPARSE\n   MOVE USEBRK TO USEBREAK4\n   MOVE BRKNAME5 TO WRKBREAK\n   PERFORM PARSEBRK TO ENDPARSE\n   MOVE USEBRK TO USEBREAK5\n   MOVE BRKNAME6 TO WRKBREAK\n   PERFORM PARSEBRK TO ENDPARSE\n   MOVE USEBRK TO USEBREAK6\n   ENDONE\n$IF #0\nSORT #6 USING\n   #5\n   #4\n   #3\n   #2\n   #1\n   #0\nCONTROL\n   #0\n   #1\n   #2\n   #3\n   #4\n   #5\n$IFE\nACCEPT\nPARSEBRK:\n   INX = 0\n   INY = 0\n   UNDRSCORE = 'NO '\nLOOP:\n   IF INX LT 20\n      PERFORM MOVEBRK TO ENDBRK\n      GOTO LOOP\n      ENDIF\nENDPARSE:\nMOVEBRK:\n   IF UNDRSCORE EQ 'YES'\n      MOVE BRKCHAR (INX) TO USECHAR (INY)\n      INY = INY + 1\n      ENDIF\n   IF BRKCHAR (INX) EQ '_'\n      MOVE 'YES' TO UNDRSCORE\n      ENDIF\n   INX = INX + 1\nENDBRK:\nON CHANGE #0\n   LIST #8\n   #9\n   #A\n   #B\n   #C\n   #D\n   #E\n   #F\n   #G\n   #H\n   #I\n   #J\n   #K\n   #L\n   #M\n   #N\n   #O\n   #P\n   #Q\n   #R\n   #S\n   #T\n   #U\n   #V\n   #W\n   #X\n   USEBREAK1 WITH 2 AFTER\n./ ADD NAME=DYLSUM2  1700-85128-85128-1006-00196-00196-00000-REL17\n$DEFAULT #0=NULL #1=NULL #2=NULL #3=NULL #4=NULL #5=NULL #6=NULL\n #7=NULL #8=NULL #9=NULL #A=NULL #B=NULL #C=NULL #D=NULL #E=NULL\n #F=NULL #G=NULL #H=NULL #I=NULL #J=NULL #K=NULL #L=NULL #M=NULL\n #N=NULL #O=NULL #P=NULL #Q=NULL #R=NULL #S=NULL #T=NULL #U=NULL\n #V=NULL #W=NULL #X=NULL\n$DEND\n$IF #1\nON CHANGE #1\n   LIST SUM (#8\n   #9\n   #A\n   #B\n   #C\n   #D\n   #E\n   #F\n   #G\n   #H\n   #I\n   #J\n   #K\n   #L\n   #M\n   #N\n   #O\n   #P\n   #Q\n   #R\n   #S\n   #T\n   #U\n   #V\n   #W\n   #X)\n   USEBREAK2 AT USEBREAK1 WITH 2 AFTER\n$IFE\n$IF #2\nON CHANGE #2\n   LIST SUM (#7\n   #8\n   #9\n   #A\n   #B\n   #C\n   #D\n   #E\n   #F\n   #G\n   #H\n   #I\n   #J\n   #K\n   #L\n   #M\n   #N\n   #O\n   #P\n   #Q\n   #R\n   #S\n   #T\n   #U\n   #V\n   #W\n   #X)\n   USEBREAK3 AT USEBREAK1 WITH 2 AFTER\n$IFE\n$IF #3\nON CHANGE #3\n   LIST SUM (#7\n   #8\n   #9\n   #A\n   #B\n   #C\n   #D\n   #E\n   #F\n   #G\n   #H\n   #I\n   #J\n   #K\n   #L\n   #M\n   #N\n   #O\n   #P\n   #Q\n   #R\n   #S\n   #T\n   #U\n   #V\n   #W\n   #X)\n   USEBREAK4 AT USEBREAK1 WITH 2 AFTER\n$IFE\n$IF #4\nON CHANGE #4\n   LIST SUM (#7\n   #8\n   #9\n   #A\n   #B\n   #C\n   #D\n   #E\n   #F\n   #G\n   #H\n   #I\n   #J\n   #K\n   #L\n   #M\n   #N\n   #O\n   #P\n   #Q\n   #R\n   #S\n   #T\n   #U\n   #V\n   #W\n   #X)\n   USEBREAK5 AT USEBREAK1 WITH 2 AFTER\n$IFE\n$IF #5\nON CHANGE #5\n   LIST SUM (#7\n   #8\n   #9\n   #A\n   #B\n   #C\n   #D\n   #E\n   #F\n   #G\n   #H\n   #I\n   #J\n   #K\n   #L\n   #M\n   #N\n   #O\n   #P\n   #Q\n   #R\n   #S\n   #T\n   #U\n   #V\n   #W\n   #X)\n   USEBREAK6 AT USEBREAK1 WITH 2 AFTER\n$IFE\n$IF #1\nON FINAL\n   LIST SUM (#7\n   #8\n   #9\n   #A\n   #B\n   #C\n   #D\n   #E\n   #F\n   #G\n   #H\n   #I\n   #J\n   #K\n   #L\n   #M\n   #N\n   #O\n   #P\n   #Q\n   #R\n   #S\n   #T\n   #U\n   #V\n   #W\n   #X)\n   'FINAL' AT USEBREAK1\n$IFE\nT1\nT1+2 DYLPAGE\nT2\nT2+2 DYLDATE\nT3   '#6'   WITH 4 AFTER\n./ ADD NAME=DYLVER   1700-85128-85128-1006-00056-00056-00000-REL17\nOPTION STRUCTURED\nFILE IN01 STATUS INEOF\n   INLEFT  80  2\n   ERRMSG   5  2\n   COPYMSG  6  6\n   INRIGHT 80 13\n   COMMENT  1 13\n   HEADER   9 13\n   CROSSREF 9 27\n   INREST  52 81\nFILE OUT01 OUTPUT FROM OUT01 FB 80\n  OUTREC 80\n   OUTERR   5  1\n   OUTREST 75  6\nREAD IN01\nDOWHILE COPYMSG EQ 'COPIED' AND INEOF NE 'E'\n   READ IN01\n   ENDDO\nIF CROSSREF EQ 'C R O S S'\n   STOP\n   ENDIF\nON ONE\n  DOUNTIL COMMENT EQ '*' OR INEOF EQ 'E'\n     READ IN01\n     ENDDO\n  ENDONE\nIF HEADER EQ 'D Y L A K'\n   READ IN01\n   IF CROSSREF EQ 'C R O S S'\n      STOP\n      ENDIF\n   READ IN01\n   ENDIF\nIF INLEFT EQ BLANK\n   IF DYLCOUNT1 GT 1\n      DOWHILE INLEFT EQ BLANK AND INEOF NE 'E'\n         READ IN01\n         ENDDO\n      DYLCOUNT1 = 0\n   ELSE\n      DYLCOUNT1 = DYLCOUNT1 + 1\n      ENDIF\n   ENDIF\nIF ERRMSG EQ 'ERROR'\n   MOVE INLEFT TO OUTREC\n   WRITE OUT01\n   MOVE SPACE TO OUTREC\n   MOVE ERRMSG TO OUTERR\n   MOVE INREST TO OUTREST\n   WRITE OUT01\nELSE\n   IF COPYMSG NE 'COPIED'\n      MOVE INRIGHT TO OUTREC\n      WRITE OUT01\n      ENDIF\n   ENDIF\n./ ADD NAME=D04TEXT  0105-84079-84089-1414-00594-00378-00000-GD02150\n               IBM OS Cobol interactive debug reference summary\n\n                 Notation conventions for TESTCOB subcommands\n\n 1. The symbols below are used to define subcommand format. With the exception\n of the hyphen, which may be used as a continuation character under TSO, these\n symbols should not be typed at the terminal.\n\n          NAME                  SYMBOL                 MEANING\n\n       hyphen                     -            joins lower case\n                                               letters, words, and\n                                               symbols to form a single\n                                               variable\n\n       underscore               ______         indicates a default\n                                               option, one you need not\n                                               type if it is the one\n                                               you want\n\n       slash                      //           group related items: you\n                                               MAY choose one of the\n                                               items between slashes\n\n       exclamation point         !!            group related items: you\n                                               MUST choose one of the\n                                               items between exclamation\n                                               marks\n\n       ellipsis                   ...          indicates that the\n                                               preceding item or group\n                                               of items can be repeated\n                                               one or more times in\n                                               succession if you want\n\n 2. Upper case letters, numbers, and symbols other than the ones above must be\n typed exactly as they appear in the format.\n\n 3. Lower case letters represent variable information that is supplied by the\n user.\n1\n\n\n\n\n                 Notation conventions for TESTCOB subcommands\n\n                                 (continued)\n\n 4. The following terms have special meanings in subcommand formats:\n\n    * addr         is a COBOL index-name, a COBOL data-name, or a COBOL\n                   special register\n    * expression   is a relationship expressed in this format:\n\n                   addr-1  operator   !value! !addr-2!\n\n                   (Addr, operator, and value are defined here.)\n    * operator     is one of the following:\n\n                   EQ or =   equal to\n                   GT or >   greater than\n                   LT or <   less than\n                   NE or \u00ac=  not equal to\n                   GE or >=  greater than or equal to\n                   LE or <=  less than or equal to\n\n    * statement    is expressed: line number /.verb number/\n    * symbol       is any character combination that follows the rules\n                   for forming a data-name in the COBOL language.\n    * value        is a literal constant or a figurative constant.\n\n 5. A range of statements, which includes all statements within the range, is\n delimited by two statements separated by a colon:\n                   statement-1:statement-2\n    (this applies to a range of data-names or index-names.)\n 6. A list of statements, which includes only the statements listed, is\n enclosed in parentheses, and each statement is separated from the next by\n commas, blanks, or tabs:\n                   (statement-1,statement-2,statement-3)\n    (this applies to a list of addrs, symbols, and so on.)\n 7. Valid delimiters between operands in all TESTCOB subcommands are blanks,\n commas, and tabs. You can use these interchangeably.\n1\n\n\n\n\n Subcommand/Operands\n\n AT  !statement!\n     !(statement-1/,statement-2/...)!\n     !statement-3:statement-4!\n\n     /(subcommand list)/ /COUNT(n)/\n\n     /NOTIFY/\n+     ______\n     /NONOTIFY/\n\n     statement\n        is the point where you want to establish an AT breakpoint.\n\n     (statement-1,statement-2)\n        are points where you want to establish AT breakpoints. Use this operand\n        if you want to establish AT breakpoints in several NONCONSECUTIVE\n        statements in your program.\n\n     statement-3:statement-4\n        delimit a range of statements where you want to establish AT\n        breakpoints. Using this operand establishes AT breakpoints at every\n        statement, which means at every COBOL verb, between statement-3 and\n        statement-4. Therefore, statement-3 must appear before statement-4 in\n        the program, and both statements must appear in the same program.\n\n     (subcommand list)\n        is a list of one or more TESTCOB subcommands. Each subcommand in the\n        list must be separated from the next by a semicolon.  Also, the list\n        may include AT if you wish. When an AT breakpoint is executed, the\n        system stops program execution and then executes the subcommand list if\n        there is one. Once the subcommand list is executed, control is returned\n        to the terminal where you may enter additional subcommands or cause\n        program execution to resume.\n\n        NOTE: If the Interactive Debug command processor encounters the GO or\n        RUN subcommand in the subcommand list, no additional subcommands will\n        be executed after GO or RUN. In this situation, program execution is\n        resumed. If the END subcommand is encountered in the subcommand list,\n        the command processor immediately terminates the debugging session.\n\n     COUNT(n)\n        is a way to specify that you want the AT breakpoint to cause an\n        interruption every nth time it is encountered during program execution,\n        where n is the value of a positive integer.  (Thus, if COUNT(5) is\n        specified, the FIRST execution of the AT breakpoint occurs the FIFTH\n        time the breakpoint is encountered. The verb at this breakpoint is\n        executed FOUR times, and the interruption occurs before the verb is\n        executed a FIFTH time.)\n\n     NOTIFY\n        means that you want the system to print an identifying message every\n        time the AT breakpoint is executed. To suppress the message, specify\n        NONOTIFY. NOTIFY is the default.\n1\n\n\n\n\n Subcommand/Operands\n\n DROP   /symbol/\n        /(symbol-1/,symbol-2/...)/\n\n     symbol\n        is the same symbol you specified in an EQUATE subcommand.  Specifying\n        this symbol in EQUATE puts it in a special symbol table. Similarly,\n        specifying this symbol in DROP removes it from that table.\n\n        NOTE: If no symbol operand is included in DROP, the entire symbol table\n        is deleted. This eradicates the effect of all EQUATE subcommands that\n        have been entered during your debugging session.\n\n     (symbol-1,symbol-2)\n        is a list of symbols that you want to delete. This operand enables you\n        to remove several symbols from the symbol table in one quick step.\n1\n\n\n\n\n Subcommand/Operands\n\n DUMP\n1\n\n\n\n\n Subcommand/Operands\n\n END\n1\n\n\n\n\n Subcommand/Operands\n\n EQUATE (or EQ)\n\n        symbol\n\n        !data-name!\n        !index-name!\n        !special register!\n\n     symbol\n        is any character conbination that follows the rules for forming a COBOL\n        data-name. It cannot be qualified nor used as a qualifier. NOTE: A\n        symbol cannot be qualified by program-name.\n\n        A symbol can represent only one data-name, index-name, or COBOL special\n        register. If the same symbol is used in a second EQUATE subcommand, the\n        second definition is the only one that the system will recognize and\n        accept. Once a symbol has been defined by an EQUATE subcommand, it is\n        entered into a symbol table. Thereafter, the symbol can be used in any\n        subcommand in place of the data-name, index-name, or special register\n        it represents. The definition is effective until you remove the symbol\n        from the symbol table by using the DROP or RUN subcommand or until you\n        end the debugging session, whichever comes first. If the symbol is\n        defined already in the program, the symbol defined in EQUATE takes\n        priority.\n\n     data-name\n        is any data-name in your program, including a qualified data-name, such\n        as A of B of C.\n\n     index-name\n        is any index-name in your program.\n\n     special register\n        is any one of the COBOL special registers.\n1\n\n\n\n\n Subcommand/Operands\n\n GO\n        !statement!\n\n     statement\n        may correspond to any COBOL verb recognized by TESTCOB, in the\n        currently executing program only.\n1\n\n\n\n\n Subcommand/Operands\n\n HELP (or H)\n\n        /subcommand-name/  /FUNCTION/\n                           /SYNTAX/\n                           /OPERANDS/(list of operands)!\n                           /ALL/\n+                           ___\n\n     subcommand-name\n        is the name of the TESTCOB subcommand that you want to find out how to\n        use. Specifying only a subcommand-name in the operand field will get\n        you an explanation of the function, syntax, and operands of that\n        subcommand. If you omit all operands, the system will display a list of\n        all the TESTCOB subcommands that are available for your use.\n\n     FUNCTION\n        indicates that you want a description of the function of the subcommand\n        you have specified in subcommand-name.\n\n     SYNTAX\n        indicates that you want a description of the syntax of the subcommand\n        you have specified in subcommand-name.\n\n     OPERANDS\n        indicates that you want a description of the operands that are used\n        with the subcommand you have specified in subcommand-name.\n\n     (list-of-operands)\n        is a list of the particular operands that you want described in detail.\n        Each operand in this list must be separated from the next by one or\n        more blanks or by a comma. List-of-operands must be used with OPERANDS\n        in the HELP subcommand as shown above.\n\n     ALL\n        indicates that you want a description of the function, syntax, and\n        operands of the subcommand you have specified in subcommand-name. ALL\n        is the default.\n1\n\n\n\n\n Subcommand/Operands\n\n IF (expression)   !HALT (or HA)!\n                   !GO!\n\n     (expression)\n        is an expression that is evaluated immediately when the IF subcommand\n        is executed. If the two operands in the expression are data-names, they\n        must belong to the same program. The format of an expression is:\n\n           addr-1   operator  !value! !addr-2!\n\n        If addr-2 is used, the data attribute (that is, usage and category)\n        must be identical to that represented by addr-1. If value is used, it\n        must have the same data type as addr-1. For example, if addr-1 is\n        floating-point, the literal must be floating point.\n\n        The rules for comparison, such as collating sequence, truncation, and\n        padding, will be the same as those in the COBOL language.\n\n     HALT\n        or its abbreviation, HA, indicates that you want control returned to\n        the terminal if the expression is true.\n\n     GO\n        indicates that you want to restart program execution if the\n        expression is true.\n1\n\n\n\n\n Subcommand/Operands\n\n LIST or L\n\n        !addr!\n        !(addr-1/,addr-2/...)!\n        !addr-3:addr-4!\n        !ALL!\n\n        /PRINT/\n\n     addr\n        is the data-name, index-name, or COBOL special register whose contents\n        you want desplayed on an output device. If addr is a data-name with a\n        RENAMES clause, the effect will be the same as using the data-name\n        which has been renamed except that the LIST output is displayed in\n        hexadecimal. If addr is a group item, it will be listed, followed by\n        all the group items and elementary items it contains. Items containing\n        data which is invalid for the defined data type will be identified as\n        such and displayed in hexadecimal.\n\n     (addr-1,addr-2)\n        is a list of several data-names, index-names, or COBOL special\n        registers whose contents you want displayed on an output device. The\n        same rules for addr, described above, apply to this operand.\n\n     addr-3:addr-4\n        delimit a range of data-names and index-names whose contents you want\n        displayed on an output device. Addr-3 and addr-4 may be data-names,\n        index-names, or both, but may not be COBOL special registers. The\n        contents of every data-name and index- name between addr-3 and addr-4\n        will be displayed. Addr-3 must appear in the program BEFORE addr-4.\n\n     ALL\n        indicates you want all index names, data names, and COBOL special\n        registers, and the contents of the TGT table displayed. The table is\n        displayed in hexadecimal.\n\n     PRINT\n        indicates that the display is directed to the data set that was\n        specified by the user at the beginning of the debugging session. If\n        PRINT is omitted, the display is directed to the terminal.\n1\n\n\n\n\n Subcommand/Operands\n\n LISTBRKS  /PRINT/\n\n     PRINT\n        indicates that the list is directed to the data set that was specified\n        by the user at the beginning of the debugging session. If PRINT is\n        omitted, the display is directed to the terminal.\n1\n\n\n\n\n Subcommand/Operands\n\n LISTFILE    file-name   /PRINT/\n\n     file-name\n        is an FD name in the source program.\n\n     PRINT\n        indicates that the display is directed to the data set that was\n        specified by the user at the beginning of the debugging session. If\n        PRINT is omitted, the display is directed to the terminal.\n1\n\n\n\n\n Subcommand/Operands\n\n NEXT (or N)\n1\n\n\n\n\n Subcommand/Operands\n\n OFF    /statement/\n        /(statement-1/,statement-2/...)/\n        /statement-3:statement-4/\n\n     statement\n        is the point where you want to remove an AT breakpoint.\n\n     (statement-1,statement-2)\n        are the points where you want to remove AT breakpoints. Use this\n        operand if you want to remove AT breakpoints in several nonconsecutive\n        statements.\n\n     statement-3:statement-4\n        delimit a range of statements where you want to remove all the AT\n        breakpoints. Statement-3 must appear in the program before statement-4.\n        All AT breakpoints are removed in this range whether they were\n        established by one AT or several AT subcommands.\n1\n\n\n\n\n Subcommand/Operands\n\n OFFWN  /identifier/\n        /(identifier-1/,identifier-2/...)/\n\n     identifier\n        is the identifier that you assigned when you entered the WHEN\n        subcommand. You can remove a particular WHEN breakpoint by specifying\n        its unique identifier in the OFFWN subcommand.\n\n     (identifier-1,identifier-2)\n        are the unique identifiers of two WHEN breakpoints that you want to\n        remove. Use this operand to remove several WHEN breakpoints in several\n        nonconsecutive statements. This list can include two or more\n        identifiers.\n\n        NOTE: If no operand appears in the OFFWN subcommand, all WHEN\n        breakpoints are removed.\n1\n\n\n\n\n Subcommand/Operands\n\n QUALIFY (or Q)     program-name\n\n     program-name\n        is a program-name formed according to the COBOL language rules. If the\n        first character of the program-name is a numeric character or a hyphen,\n        you must change it to conform to the COBOL rules.\n1\n\n\n\n\n Subcommand/Operands\n\n RUN (or R)     /statement/\n\n     statement\n        is the point where you wnat program execution to begin; statement may\n        refer to any COBOL verb recognized by TESTCOB and in the program that\n        is executing. If statement is omitted, program execution begins at the\n        point of last interruption.  This statement must appear in the same\n        program in which the last interruption occurred; that is, you cannot\n        transfer control to another program by entering RUN (or GO).\n1\n\n\n\n\n Subcommand/Operands\n\n SET (or S)   addr-1   =   !addr-2!\n                           !value!\n     addr-1\n        is the data-name that is initialized or modified. The contents of\n        addr-2 or value replace the contents of addr-1. Addr-1 cannot contain\n        or be the object of an OCCURS clause with the DEPENDING ON option in\n        your program.\n\n     addr-2\n        represents the contents that are moved to addr-1. The data attribute\n        (that is, usage and category) of addr-2 must be the same as addr-1.\n        Addr-2 and addr-1 must be data-names in the same COBOL program or\n        subprogram. Truncation and padding occurs according to the COBOL rules.\n\n     value\n        must be the same data type (that is, nonnumeric, fixed point, or\n        floating point) as addr-1.\n1\n\n\n\n\n Subcommand/Operands\n\n SOURCE (or SO)   /line number/                    /ddname/\n                  /line number-1:line number -2/\n\n     line number\n        is the line number in your source program that you want to display at\n        the terminal.\n\n     line number-1:line number-2\n        delimit the range of line numbers in your source program that you want\n        to display at the terminal. Thus, all line numbers between line\n        number-1 and line number-2 will be displayed. If no line-number operand\n        is specified in SOURCE, the entire data set is displayed at the\n        terminal. This provides compile-time output that can be used for easy\n        reference during the debugging session.\n\n     ddname\n        is the name of the file that contains the listing of the source program\n        produced at compile time. If ddname is omitted, the program-name of the\n        executing program is used as a default ddname. The program-name is the\n        name that appears in the PROGRMAM-ID paragraph of the source program.\n1\n\n\n\n\n Subcommand/Operands\n\n TRACE (or T)   /ENTRY/  /PRINT/\n                /PARA/\n+                ____\n                /NAME/\n                /OFF/\n\n     ENTRY\n        causes a display of the program-name every time a COBOL program is\n        entered.\n\n     PARA\n        causes a display of the line number of each paragraph and section at\n        the moment the execution of each paragraph and section begins. This is\n        the default.\n\n     NAME\n        causes a display of the paragraph-name and line number at the moment\n        the execution of each paragraph and section begins.\n\n     OFF\n        terminates the effect of a previous TRACE subcommand.  (Entering a RUN\n        subcommand also terminates a previous TRACE.)\n\n     PRINT\n        indicates that the display is directed to the data set that was\n        specified by the user at the beginning of the debugging session. If\n        PRINT is omitted or if there is no PRINT file, the display is directed\n        to the terminal.\n1\n\n\n\n\n Subcommand/Operands\n\n WHEN (or WN)   identifier   !addr!    !(expression)!\n\n     identifier\n        is a user-supplied string of four-or-less alphanumeric characters.\n        Sometime later in the debugging session, you may want to remove a WHEN\n        breakpoint. You use the OFFWN subcommand to do this, and you specify in\n        the operand field of the OFFWN subcommand the identifier of each WHEN\n        breakpoint you want to remove. Therefore, each identifier in a WHEN\n        subcommand must be unique.\n\n        NOTE: An identifier cannot be qualified.\n\n     addr\n        is a data-name whose content or value is evaluated before each COBOL\n        verb is executed. If the value is different from that which it\n        previously contained when the WHEN subcommand was either entered or was\n        last executed, program execution is stopped at that point, and control\n        is returned to the terminal.\n\n     (expression)\n        is an expression that is evaluated before each COBOL verb is executed.\n        If the two operands in the expression are data-names, they must belong\n        to the same program. If the expression is evaluated as being true,\n        program execution is stopped at that point and control is returned to\n        the terminal so you can enter additional subcommands if you wish.\n\n        All true expressions are identified at the terminal by a message that\n        contains the program-name, the statement where the interruption\n        occurred, and the identifier that the user assigned to that WHEN\n        subcommand.\n./ ADD NAME=FILEUSE  0100-82202-82202-1603-00010-00010-00000-JS02150\nC          00080\nFA\nFJ             R\nD     10 A6                   EQ10 VNONVSAM --             REJ\nD     1  V                      1  R1\nD     79 R1                     79 R2\nD     2  A1     B               2  UINW   B\nD     2  V21                  - 2  UINW   B\nD     W  A22                    W  R1                   OUTOUT\nEND\n./ ADD NAME=FILEUSE2 0100-84110-84110-0940-00001-00001-00000-JS02150\n BATCHLOG FILEUSE\n./ ADD NAME=FLAGMEMB 0100-86100-86100-1030-00013-00013-00000-HG88150\nC          81               1\nFA F\nFJ F           R\nD     11 A2                   EQ11 VMEMBER NAME         MEMJCL\n*   ***  IF RECORD IS STANDARD JCL\nDJCL  81 A1                     81 R1\nD     1  V1                     1  UCLR                 OUTOUT\n*   ***  IF RECORD IS MEMBER STATEMENT\nDMEM  8  A15                    8  R4\nD     2  V//                    2  R2\nD     4  V$;.*                  4  R13\nD     1  V1                     1  UCLR                 OUTOUT\nEND\n./ ADD NAME=FRANPROF 0103-85053-86126-1341-00015-00008-00000-JS02150\nREPORT 74 LONG ASA\nFILE MASTR FB 80\n  INCHAR 1\n  DATALINE 80 1  (INFOR)\nIF DYLLINE GT 73 AND INCHAR EQ '1'\n    MOVE SPACE TO INCHAR\nENDIF\nIF INCHAR EQ '1'\n    MOVE SPACE TO INCHAR\n    LIST ' ' AT 1 WITH EJECT AFTER\nENDIF\nLIST DATALINE AT 1\nT1 '              >>>  WDPSC CUSTOMER PROFILE  <<<'  FIXED WITH 4 AFTER\nT1+60 DYLDATE\nFIN\n./ ADD NAME=I94TP490 0100-84111-84111-1141-00001-00001-00000-JS02150\n BATCHLOG I94TP490\n./ ADD NAME=JCLXREF  0100-84110-84110-0947-00001-00001-00000-JS02150\n BATCHLOG JCLXREF\n./ ADD NAME=JCLXREF1                               17OCT89 12.48.04\nC          00080                               0000\nFA F10008000080\nFJ             R\nD   L 1  V0                     2  UINW   B\nD   L 1  V0                     2  UINX   B\nDT1 L 1  U41     W            EQ1  V|                   T2\nD   L 1  U41     W              1  U1      X\nD   L 1  V1                   + 1  U18\nD   L 1  U18                  GT1  V6                   BAD\nD   L 1  V1                   + 2  UINW   B\nD   L 1  V1                   + 2  UINX   B             T1 T1\nDT2 L 1  U18                  EQ1  V6                      BAD\nD   L 1  V1                   + 2  UINW   B\nD   L 1  V0                     2  UINX   B\nDT3 L 1  U41     W            EQ1  V|                   T4\nD   L 1  U41     W              1  U11     X\nD   L 1  V1                   + 1  U19\nD   L 1  U19                  GT1  V5                   BAD\nD   L 1  V1                   + 2  UINW   B\nD   L 1  V1                   + 2  UINX   B             T3 T3\nDT4 L 1  U19                  EQ1  V4                   T5\nD   L 1  U19                  EQ1  V5                      BAD\nDT5 L 16 V LISTPDS DSNAME=      16 R1\nD   L 1  V1                   + 2  UINW   B\nD   L 2  V16                    2  UINX   B\nDT6 L 1  U41     W            EQ1  V|                   T7\nD   L 1  U41     W              1  R1      X\nD   L 1  V1                   + 2  U20\nD   L 2  U20                  GT2  V44                  BAD\nD   L 1  V1                   + 2  UINW   B\nD   L 1  V1                   + 2  UINX   B             T6 T6\nDT7 L 5  V,VOL=                 5  R1      X\nD   L 1  V5                   + 2  UINX   B\nD   L 1  U19                    2  UINY   B\nD   L Y  U11                    Y  R1      X\nD   L 1  U19                  + 2  UINX   B\nD   L 1  V=                     1  R1      X\nD   L 1  V1                   + 2  UINX   B\nD   L 6  U1                     6  R1      X\nD   L 1  V0                     2  URTC   B\nD   L 1  V2                     1  UEOJ                 OUTOUT\nDBADL 1  V8                     2  URTC   B\nD     1  V2                     1  UEOJ                 REJREJ\nEND\n./ ADD NAME=JCLXREF2                               17OCT89 12.48.04\nC           80                MEMBER NAME=\nFA\nFJ             R\nD    115 VPUNCH TYPORG=PO       15 R4\nD    120 V,MAXNAME=600          20 R19\nD    1                        WJ\nD     3   17                  EQ3  U41                     REJ\nD     8   12                    8  U13\nD     65 U1                     65 R4\nD                             WJ\nD     1  VY                     1  U70                  OUTOUT\nD   L 1  U70                  EQ1  VY                      EJ2\nD   L 1  V0                     2  URTC   B             EJ3EJ3\nDEJ2L 1  V8                     2  URTC   B\nDEJ3  1  V2                     1  UEOJ                 REJREJ\n./ ADD NAME=JCLXREF3                               17OCT89 12.48.04\n SORT FIELDS=(16,8,CH,A)\n./ ADD NAME=JCLXREF4                               17OCT89 12.48.04\nC\nFA\nD     6   4                   EQ6  VMEMBER              OUTREJ\nR01 60 80\nT1                        WASHINGTON STATE LIQUOR CONTROL BOARD\nT2                         SUMMARY OF CATALOGUED PROCEDURES\nT2 2 U8011195-1\nP   8  UEDT      15\nP   8   16                  X            PROCEDURE'NUMBER\n./ ADD NAME=JCLXREF5                               17OCT89 12.48.04\nC          80\nFA\nFJ             R\nD     80  2                     80 R1\nD     6  R1                   EQ6  VMEMBER                 OUT\nD     8  R14                    8  U41                  REJREJ\nR01 60         E\nT1                                                 WASHINGTON STATE LIQ\nT1   UOR CONTROL BOARD\nT2                                                        CATALOGUED PR\nT2 2 OCEDURES                                        U8211195-2\nP   8  U41                1 S            PROCEDURE NUMBER\nP   80 R1                   X            JCL STATEMENTS\nP   30 ULDT      2001                   *DATE AND PAGE NUMBER\n./ ADD NAME=JCLXREF6                               17OCT89 12.48.04\nC          148\nFA\nFJ             R\nD      1  1                   EQ1  VP                      S\nDP                            PS                        CP EXT\nD      1  1                       1R1\nD      1 V                        1R2\nD      3 V000                     3R19\nD     6   10                    6  R82\nD      8  2                       8R3                   OUTOUT\nDS     1  1                   EQ  1VS                      D\nD      1  1                       1R1\nD      8  2                       8R11\nD      3 V001                  +  3R19\nD     6  R82                    6  U1\nD                             PS                        CS EXT\nD     6  U1                     6  R82\nD     7   18                    7  R88\nD      8  10                      8R22                  OUTOUT\nDD     1  1                   EQ  1VD                      REJ\nD      1  1                       1R1\nD      8  2                       8R30\nD      44 10                     44R38                  OUTOUT\nDCP   8  V                      8  R11\nD     8  V                      8  R22\nDCS    8 V                        8R30\nD     20 V                       20R38\nD     20 V                       20R58\nD     20 V                       20R78\nD     20 V                       20R98\nD     10 V                       10R118\nDEXT  20 V                       20R128\nR01 60\nT1                                                 WASHINGTON STATE LIQ\nT1   UOR CONTROL BOARD\nT2                                                            SYSTEM RE\nT2 2 PORT                                            U3211195-02\nP   6  R82                  S\nP   8  R3                   S            PROCEDURE\nP   3  R19             Z    S            STEP' NUMBER\nP   8  R11                  S            STEPNAME\nP   8  R22                  S            PROGRAM' NAME\nP   7  R88                  S\nP   8  R30                  S            DDNAME\nP   44 R38                  X            DATA SET NAME\nP   30 ULDT      2001\n./ ADD NAME=JCLXREF7                               17OCT89 12.48.04\n SORT FIELDS=(22,8,A,3,8,A,11,8,A),FORMAT=CH\n./ ADD NAME=JCLXREF8                               17OCT89 12.48.04\nC\nFA\nD     1   1                   EQ1  VS                      REJ\nR01 060090    1 2 2\nT1                               WASHINGTON STATE LIQUOR CONTROL BOARD\nT2                                       PROGRAM CROSS REFERENCE\nT2 2  U3311195-02\nP   7   88                  X\nP   8   22                  S            PROGRAM NUMBER\nP   6   82                  X\nP   8   3                   S            PROCEDURE NAME\nP   8   11                  X            STEP NAME\nP   3   19             E    X            STEP NUMBER\nEND\n./ ADD NAME=JCLXREF9                               17OCT89 12.48.04\n SORT FIELDS=(38,43,A,3,8,A,11,8,A),FORMAT=CH\n./ ADD NAME=JCLXRF0B                               17OCT89 12.48.04\nC          88               1\n*   BUILD OUTPUT RECORDS WITH JOB NAME IN ALL RECORDS RELATED TO A\n*  PARTICULAR NON-CATLGD PROCEDURE FOR PURPOSES OF SORTING AND\n*  SUBSEQUENT REPORTING\nFA F\nFJ F           R   1\nD     3   12                  EQ3  VJOB                    MTR\nD     8   3                     8  R1\nDMTR  80  1                     80 R9                   OUTOUT\n./ ADD NAME=JCLXRF0C                               17OCT89 12.48.04\n   SORT FIELDS=(4,2,CH,A,1,3,CH,A)\n   END\n./ ADD NAME=JCLXRF0D                               17OCT89 12.48.04\nC\nFA\nD     3   20                  EQ3  VJOB                    OUT\nD     8   11                    8  U41                  OUTOUT\nR01 60          E\nT1                                                 WASHINGTON STATE LIQ\nT1   UOR CONTROL BOARD\nT2                                                      NON-CATALOGUED\nT2 2 PROCEDURES                                      U7911195-2\nP   8  U41                1 S            PROCEDURE NUMBER\nP   80  9                   X            JCL STATEMENTS\nP   30 ULDT      2001                   *DATE AND PAGE NUMBER\n./ ADD NAME=JCLXRF10                               17OCT89 12.48.04\nC\nFA\nD     1   1                   EQ1  VD                      REJ\nR01 060       1 2 2\nT1                                                  WASHINGTON STATE LI\nT1   QUOR CONTROL BOARD\nT2       U3411195-02                                        DATA SET CR\nT2 2 OSS REFERENCE                     DATE\nP   43  38               L  S            DATA SET NAME\nP   6   82                  X\nP   8   3                   S            PROCEDURE NAME\nP    8  11                  S            STEP NAME\nP   3   19             E    S            STEP'NUMBER\nP   7   88                  X\nP   8   22                  S            PROGRAM NUMBER\nP   8   30                  X            DD NAME\nP   30 ULDT      2101                   *DATE AND PAGE HEADING\nEND\n./ ADD NAME=JCLXRTWO 0101-83215-83350-1458-00019-00016-00000-JS02150\nC          00080              MEMBER NAME=\nFA\nFJ             R\nD    115 VPUNCH TYPORG=PO       15 R4\nD    120 V,MAXNAME=600          20 R19\nD    1                        WJ\nD     3  U41                  EQ3  VALL                 AWL\nD     3  A6                   EQ3  U41                     REJ\nDAWL  8  A1                     8  U13\nD     40 U1                     40 R4\nD     3  V                      3  R44\nD     22 U44                    22 R47\nD                             WJ\nD     1  VY                     1  U70                  OUTOUT\nD   L 1  U70                  EQ1  VY                      EJ2\nD   L 1  V0                     2  URTC   B             EJ3EJ3\nDEJ2L 1  V8                     2  URTC   B\nDEJ3  1  V2                     1  UEOJ                 REJREJ\nEND\n./ ADD NAME=JOBSTATS 0107-85108-88270-1310-00072-00072-00014-HG00155\n FILE FILEIN FB 124\n  SMF64TME     4           (STEP'END)\n  SMF64DTE     4 PD\n  SMF64JBN     8           (JOB NAME)\n  JOBPRFIX     3 9\n  FILLER       2 12\n  JOBSUFIX     3 14\n  SMF64RST     4 17        (STRT'TIME)\n  FILLER       1\n  SMF64RSD     3 PD        (JOB'DATE)\n  SMF64DNM     44          (VSAM DSN)\n  SMF64NLR     4 BI Z      (RECORD'TOTAL)\n  SMF64NFS     4 BI\n  FILLER       2 BI\n  SMF64NCS     2 BI Z      (TOT'CI'SPLT)\n  FILLER       2\n  SMF64NAS     2 BI Z      (TOT'CA'SPLT)\n  FILLER       1 BI\n  SMF64DDE     3 BI Z      (REC'DEL)\n  FILLER       1 BI\n  SMF64DIN     3 BI Z      (REC'INS)\n  FILLER       1 BI\n  SMF64DUP     3 BI Z      (REC'UPD)\n  FILLER       1\n  SMF64DRE     3 BI Z      (REC'READ)\n  SMF64DFS     4 BI\n  FILLER       2\n  SMF64DCS     2 BI Z      (JOB'CI'SPLT)\n  FILLER       2\n  SMF64DAS     2 BI Z      (JOB'CA'SPLT)\n  FILLER       1\n  SMF64DEP     3 BI Z      (JOB'EXCPS)\n  FILLER       1\n  SMF64XTN     1 BI Z      (EX'TNS)\n  SMF64VSR     6           (VOLSER)\nWORKAREA\n   AGENCY       3\n   NONREAD      3  BI  Z  (UPDTS'INSRTS'DELS)\n  ON ONE\n  MOVE DYLPARM TO AGENCY\n  ENDONE\n  IF JOBSUFIX NE AGENCY REJECT ENDIF\n  IF JOBSUFIX EQ '155' AND JOBPRFIX EQ 'CIC' REJECT ENDIF\n  IF SMF64DEP GT 200 GOTO SORTEM ELSE REJECT ENDIF\nSORTEM:\n  SORT FILEIN USING SMF64JBN SMF64RSD SMF64TME\n   NONREAD = SMF64DDE + SMF64DIN + SMF64DUP\n  REPORT 145 WIDE\n  CONTROL SMF64JBN\n  LIST SUPPRESS SMF64JBN SUPPRESS SMF64RSD\n   SMF64TME\n   SMF64DNM\n   SMF64VSR\n   SMF64NLR\n   SMF64DEP\n   SMF64DRE\n   NONREAD\n   SMF64DAS\n   SMF64DCS\n   SMF64XTN\n                        WITH 1 BEFORE\n  ON CHANGE SMF64JBN\n  LIST 'TOTALS' AT SMF64VSR SUM SMF64DEP\n                            SUM SMF64DRE\n                            SUM NONREAD\n                            SUM SMF64DAS\n                            SUM SMF64DCS\n          WITH 1 BEFORE AND WITH 2 AFTER\n T1 'VSAM ACTIVITY BY JOB SHOWING DETAIL FILE ACTIONS'\n T1+5 DYLDATE\n T1+125 DYLPAGE\n T2 ' '\n./ ADD NAME=KILLGDG  0100-84110-84110-0948-00001-00001-00000-JS02150\n BATCHLOG KILLGDG\n./ ADD NAME=LLINKDYL 0109-80133-80318-1502-00063-00010-00000-JS02150\nC          00080              1\nFA F\nFJ F           R\nD     1  U1                   EQ1  V1                      LB1\nD     7  A45                  EQ7  VLISTIDR                REJ\nD     1  V2                     1  U1                   T1 T1\nDLB1  15 A28                  EQ15 VWAS PRODUCED BY     T2\nD     5  A12                  EQ5  VCSECT               T3\nD     1  A83                  EQ1  V/                   T4 REJ\nDT1   20 V                      20 R1\nD     10 V                      10 R21\nD     20 A57                    20 R31\nD     20 V                      20 R51\nD     10 V                      10 R71\nD                             WJ\nD     1  V                      1  R1\nD     79 R1                     79 R2\nD                             WJ\nD     1  V-                     1  R1\nD     77 R1                     77 R2\nD                             WJ\nD     1  V                      1  R1\nD     79 R1                     79 R2\nD                             WJ                        OUTOUT\nDT2   6  V                      6  R1\nD     34 A7                     34 R7\nD     18 A70                    18 R41\nD     2  A104                   2  U11\nD     3  A92                    3  U13\nD         JTOSDATE            EL    U11,U21\nD     2  U23                    2  R59\nD     1  V/                     1  R61\nD     2  U25                    2  R62\nD     1  V/                     1  R64\nD     2  U21                    2  R65\nD     10 V                      10 R67\nD     4  V                      4  R77\nD                             WJ\nD     1  V                      1  R1\nD     79 R1                     79 R2\nD                             WJ\nD     1  V-                     1  R1\nD     77 R1                     77 R2\nD                             WJ\nD     1  V                      1  R1\nD     79 R1                     79 R2\nD                             WJ                        OUTOUT\nDT3   80 A11                    80 R1\nD                             WJ\nD     1  V                      1  R1\nD     79 R1                     79 R2\nD                             WJ                        OUTOUT\nDT4   2  A81                    2  U11\nD     3  A84                    3  U13\nD         JTOSDATE            EL    U11,U21\nD     68 A11                    68 R1\nD     2  U23                    2  R69\nD     1  V/                     1  R71\nD     2  U25                    2  R72\nD     1  V/                     1  R74\nD     2  U21                    2  R75\nD     4  V                      4  R77\nD                             WJ                        OUTOUT\n./ ADD NAME=LOADXREF 0100-84110-84110-0948-00001-00001-00000-JS02150\n BATCHLOG LOADXREF\n./ ADD NAME=LODXREF1                               17OCT89 12.48.04\n  LISTLOAD OUTPUT=ALL,DDN=OURLIB\n./ ADD NAME=LODXREF2                               17OCT89 12.48.04\n    SORT FIELDS=(1,8,CH,A,9,8,CH,A)\n./ ADD NAME=LODXREF3                               17OCT89 12.48.04\n    SORT FIELDS=(9,8,CH,A,1,8,CH,A)\n./ ADD NAME=MOD2TAPE 0100-84110-84110-0949-00001-00001-00000-JS02150\n BATCHLOG MOD2TAPE\n./ ADD NAME=OPTBLOCK 0100-84157-84157-1537-00001-00001-00000-JS02150\n BATCHLOG OPTBLOCK\n./ ADD NAME=PANRESTR 0100-84110-84110-0950-00001-00001-00000-JS02150\n BATCHLOG PANRESTR\n./ ADD NAME=PROCLIST 0100-84110-84110-0950-00001-00001-00000-JS02150\n BATCHLOG PROCLIST\n./ ADD NAME=PRTCPGM  0100-87213-87213-1043-00021-00021-00000-JS02155\nFILE INCPGM\n   READLINE 80\n   NEWPGE    5 1\nFILE MICMOUSE\n   PRTCHAR   1 1\n   PGMLINE 127 6\nFILE OUTCLIST OUTPUT FROM MICMOUSE\nWORKAREA\n   TOPOFPAGE 1 VALUE 'N'\nIF NEWPGE EQ '/* np'\n   MOVE 'Y' TO TOPOFPAGE\n   REJECT\n   ENDIF\nMOVE SPACE TO MICMOUSE LENGTH 133\nMOVE READLINE TO PGMLINE\nTRANSLATE PGMLINE FROM X'104A4F6370717275768A8E8F9CB1B2'\n                    TO X'6EADBD4F4F1B1F1B1E2D1E1C2D1F1C'\nIF TOPOFPAGE EQ 'Y'\n   MOVE '1' TO PRTCHAR\n   MOVE 'N' TO TOPOFPAGE\n   ENDIF\n./ ADD NAME=PRTLB92A 0103-87260-87261-1328-00036-00011-00000-JS02155\nFILE INREC FB 80 LENGTH LEN1\n     PDS DSNFIELD MEMBER MEMNAME STATUS STATIND\n     MEMREC 80\nFILE OUTRC FB 90 OUTPUT FROM OUTRC\n     OUTREC  90\n        REAL_RECORD 8 31\nWORKAREA\n  LIBRARY_REC 90\n      FILLER 20 1 VALUE '      LIBRARY NAME: '\n      LIBRARY_NAME 44\nWORKAREA\n  DATE_REC 90\n      FILLER 20 1 VALUE '      CURRENT DATE: '\n      PRINT_DATE 8\nMOVE DYLPARM TO LIBRARY_NAME\nMOVE DYLDATE TO PRINT_DATE\nMOVE SPACES TO OUTREC\nWRITE OUTRC\nMOVE SPACES TO OUTREC\nWRITE OUTRC\nMOVE LIBRARY_REC TO OUTREC\nWRITE OUTRC\nMOVE SPACES TO OUTREC\nWRITE OUTRC\nMOVE DATE_REC TO OUTREC\nWRITE OUTRC\nMOVE SPACES TO OUTREC\nWRITE OUTRC\nMOVE SPACES TO OUTREC\nWRITE OUTRC\nREADPDS:\n  READDIR INREC\n  IF STATIND  EQ 'E' STOP ENDIF\n  MOVE MEMNAME TO REAL_RECORD\n  WRITE OUTRC\n  GOTO READPDS\n./ ADD NAME=PRTLB92B 0107-87261-87265-1654-00024-00006-00000-JS02155\nFILE INFILE\n    INREC 84 2\n    LEADING_DASHES 11 2\n    TRAILING_DASHES 11 21\nFILE OUTFILE OUTPUT FROM OUTFILE FB 90\n    OUTREC 84 7\nMOVE SPACES TO OUTFILE LENGTH 90\nON ONE\n   MOVE '1' TO OUTFILE\n   WRITE OUTFILE\n   MOVE SPACES TO OUTFILE LENGTH 90\nENDONE\nIF   LEADING_DASHES EQ '---------- '\n AND TRAILING_DASHES EQ ' ----------'\n   WRITE OUTFILE\n   WRITE OUTFILE\nENDIF\nMOVE INREC TO OUTREC\nWRITE OUTFILE\nIF   LEADING_DASHES EQ '---------- '\n AND TRAILING_DASHES EQ ' ----------'\n   MOVE SPACES TO OUTFILE LENGTH 90\n   WRITE OUTFILE\nENDIF\n./ ADD NAME=PRTLB92C 0101-87264-87265-1011-00001-00002-00000-JS02155\n          089100090   000000N\n./ ADD NAME=PRTLIB90 0100-84110-84110-0952-00001-00001-00000-JS02150\n BATCHLOG PRTLIB90\n./ ADD NAME=RECVPAT  0100-86301-86301-1534-00011-00011-00000-KX00150\nTSOEXEC RECEIVE\nCOPY DSN(DYYDDD.THHMMSS.WORK1)\nCOPY DSN(DYYDDD.THHMMSS.WORK2)\nCOPY DSN(DYYDDD.THHMMSS.WORK3)\nCOPY DSN(DYYDDD.THHMMSS.WORK4)\nCOPY DSN(DYYDDD.THHMMSS.WORK5)\nCOPY DSN(DYYDDD.THHMMSS.WORK6)\nCOPY DSN(DYYDDD.THHMMSS.WORK7)\nCOPY DSN(DYYDDD.THHMMSS.WORK8)\nCOPY DSN(DYYDDD.THHMMSS.WORK9)\nEND\n./ ADD NAME=RELINK   0100-84110-84110-0953-00001-00001-00000-JS02150\n BATCHLOG RELINK\n./ ADD NAME=RJESUBIT 0100-84110-84110-0953-00001-00001-00000-JS02150\n BATCHLOG RJESUBIT\n./ ADD NAME=SPLITTER 0100-84242-84242-1041-00052-00052-00000-JS02150\n$DEFAULT #1=FB #2=80 #3=NULL\n$DEND\nOPTION STRUCTURED\nFILE INFILE #1 #2 COUNT INCOUNT\nFILE OUTFILE1 OUTPUT FROM INFILE\nFILE OUTFILE2 OUTPUT FROM INFILE\nFILE OUTFILE3 OUTPUT FROM INFILE\nFILE OUTFILE4 OUTPUT FROM INFILE\nFILE OUTFILE5 OUTPUT FROM INFILE\nFILE OUTFILE6 OUTPUT FROM INFILE\nFILE OUTFILE7 OUTPUT FROM INFILE\nFILE OUTFILE8 OUTPUT FROM INFILE\nWORKAREA\n  NORECS  9 NU\n  NORECS2 9 NU\n  NORECS3 9 NU\n  NORECS4 9 NU\n  NORECS5 9 NU\n  NORECS6 9 NU\n  NORECS7 9 NU\n  NORECS8 9 NU\nON ONE\n   NORECS = 2800000 / #2\n$IF #3\n   NORECS = #3\n$IFE\n   NORECS2 = NORECS * 2\n   NORECS3 = NORECS * 3\n   NORECS4 = NORECS * 4\n   NORECS5 = NORECS * 5\n   NORECS6 = NORECS * 6\n   NORECS7 = NORECS * 7\n   NORECS8 = NORECS * 8\n   ENDONE\nCASE INCOUNT\n   WHEN LE NORECS\n      WRITE OUTFILE1\n   WHEN LE NORECS2\n      WRITE OUTFILE2\n   WHEN LE NORECS3\n      WRITE OUTFILE3\n   WHEN LE NORECS4\n      WRITE OUTFILE4\n   WHEN LE NORECS5\n      WRITE OUTFILE5\n   WHEN LE NORECS6\n      WRITE OUTFILE6\n   WHEN LE NORECS7\n      WRITE OUTFILE7\n   ELSE\n      WRITE OUTFILE8\n   ENDCASE\n./ ADD NAME=SPLTINPT 0100-84242-84242-1100-00006-00006-00000-JS02150\nFILE INFILE DUMMY\nFILE OUTFILE OUTPUT FROM OUTFILE FB 80\n  RECOUT  80\nMOVE DYLPARM TO RECOUT\nWRITE OUTFILE\nSTOP\n./ ADD NAME=STRCTDYL 0102-85014-85183-1026-00022-00021-00000-GD02150\nSTATEOFF\nOPTION STRUCTURED NOTOTAL\nFILE INFILE COUNT INCOUNT\n   INREC   80\nFILE OUTFILE OUTPUT FROM OUTFILE FB 80\n   OUTREC  80\n   OUTCHAR  1 1\nIF INCOUNT GT 1\n   WRITE OUTFILE\n   ENDIF\nMOVE INREC TO OUTREC\nON END OF INPUT\n   INX = 71\n   DOWHILE OUTCHAR (INX) EQ SPACE AND INX GE 1\n      INX = INX - 1\n      ENDDO\n   IF OUTCHAR (INX) NE ';'\n      INX = INX + 1\n      MOVE ';' TO OUTCHAR (INX)\n      ENDIF\n   WRITE OUTFILE\n   STOP\n./ ADD NAME=STRUCTLC 0100-84110-84110-0954-00001-00001-00000-JS02150\n BATCHLOG STRUCTLC\n./ ADD NAME=STRUCTRM 0101-84110-84110-0955-00001-00001-00000-JS02150\n BATCHLOG STRUCTRM\n./ ADD NAME=STR33RM1 0104-84179-84181-0809-00042-00048-00000-JS02150\n DEF CL-\n      (NAME(VSAMT.EXCHANGE.**** REPLACE ME ****.EDIT)-\n          CYL(1 3)-\n          VOL(338019)-\n          RECSZ(200 200)-\n          NUMD) -\n          CAT(SYS1.USERCATT)\n DEF CL-\n      (NAME(VSAMT.EXCHANGE.**** REPLACE ME ****.CTEXT)-\n          CYL(1 3)-\n          VOL(338019)-\n          RECSZ(88 88)-\n          NUMD) -\n          CAT(SYS1.USERCATT)\n DEF CL-\n      (NAME(VSAMT.EXCHANGE.**** REPLACE ME ****.CENTRY)-\n          CYL(1 3)-\n          VOL(338019)-\n          RECSZ(12 12)-\n          NUMD) -\n          CAT(SYS1.USERCATT)\n DEF CL-\n      (NAME(VSAMT.EXCHANGE.**** REPLACE ME ****.PAGEFILE)-\n          CYL(1 3)-\n          VOL(338019)-\n          RECSZ(88 88)-\n          NUMD) -\n          CAT(SYS1.USERCATT)\n DEF CL-\n      (NAME(VSAMT.EXCHANGE.**** REPLACE ME ****.REFER)-\n          CYL(1 3)-\n          VOL(338019)-\n          RECSZ(159 159)-\n          NUMD) -\n          CAT(SYS1.USERCATT)\n DEF CL-\n      (NAME(VSAMT.EXCHANGE.**** REPLACE ME ****.UNDEF)-\n          CYL(1 3)-\n          VOL(338019)-\n          RECSZ(155 155)-\n          NUMD) -\n          CAT(SYS1.USERCATT)\n./ ADD NAME=STR33RM2 0102-84179-84180-1304-00006-00006-00000-JS02150\n      DEL  (VSAMT.EXCHANGE.**** REPLACE ME ****.EDIT) PURGE CL\n      DEL  (VSAMT.EXCHANGE.**** REPLACE ME ****.CTEXT) PURGE CL\n      DEL  (VSAMT.EXCHANGE.**** REPLACE ME ****.CENTRY) PURGE CL\n      DEL  (VSAMT.EXCHANGE.**** REPLACE ME ****.PAGEFILE) PURGE CL\n      DEL  (VSAMT.EXCHANGE.**** REPLACE ME ****.REFER) PURGE CL\n      DEL  (VSAMT.EXCHANGE.**** REPLACE ME ****.UNDEF) PURGE CL\n./ ADD NAME=TELESORT 0100-84110-84110-0955-00001-00001-00000-JS02150\n BATCHLOG TELESORT\n./ ADD NAME=TSTPRT   0101-84129-84159-1342-00200-00200-00000-KK00150\nLINE  1\nLINE  2\nLINE  3\nLINE  4\nLINE  5\nLINE  6\nLINE  7\nLINE  8\nLINE  9\nLINE 10\nLINE 11\nLINE 12\nLINE 13\nLINE 14\nLINE 15\nLINE 16\nLINE 17\nLINE 18\nLINE 19\nLINE 20\nLINE 21\nLINE 22\nLINE 23\nLINE 24\nLINE 25\nLINE 26\nLINE 27\nLINE 28\nLINE 29\nLINE 30\nLINE 31\nLINE 32\nLINE 33\nLINE 34\nLINE 35\nLINE 36\nLINE 37\nLINE 38\nLINE 39\nLINE 40\nLINE 41\nLINE 42\nLINE 43\nLINE 44\nLINE 45\nLINE 46\nLINE 47\nLINE 48\nLINE 49\nLINE 50\nLINE 51\nLINE 52\nLINE 53\nLINE 54\nLINE 55\nLINE 56\nLINE 57\nLINE 58\nLINE 59\nLINE 60\nLINE 61\nLINE 62\nLINE 63\nLINE 64\nLINE 65\nLINE 66\nLINE 67\nLINE 68\nLINE 69\nLINE 70\nLINE 71\nLINE 72\nLINE 73\nLINE 74\nLINE 75\nLINE 76\nLINE 77\nLINE 78\nLINE 79\nLINE 80\nLINE 81\nLINE 82\nLINE 83\nLINE 84\nLINE 85\nLINE 86\nLINE 87\nLINE 88\nLINE 89\nLINE 90\nLINE 91\nLINE 92\nLINE 93\nLINE 94\nLINE 95\nLINE 96\nLINE 97\nLINE 98\nLINE 99\nLINE100\nLINE101\nLINE102\nLINE103\nLINE104\nLINE105\nLINE106\nLINE107\nLINE108\nLINE109\nLINE110\nLINE111\nLINE112\nLINE113\nLINE114\nLINE115\nLINE116\nLINE117\nLINE118\nLINE119\nLINE120\nLINE121\nLINE122\nLINE123\nLINE124\nLINE125\nLINE126\nLINE127\nLINE128\nLINE129\nLINE130\nLINE131\nLINE132\nLINE133\nLINE134\nLINE135\nLINE136\nLINE137\nLINE138\nLINE139\nLINE140\nLINE141\nLINE142\nLINE143\nLINE144\nLINE145\nLINE146\nLINE147\nLINE148\nLINE149\nLINE150\nLINE151\nLINE152\nLINE153\nLINE154\nLINE155\nLINE156\nLINE157\nLINE158\nLINE159\nLINE160\nLINE161\nLINE162\nLINE163\nLINE164\nLINE165\nLINE166\nLINE167\nLINE168\nLINE169\nLINE170\nLINE171\nLINE172\nLINE173\nLINE174\nLINE175\nLINE176\nLINE177\nLINE178\nLINE179\nLINE180\nLINE181\nLINE182\nLINE183\nLINE184\nLINE185\nLINE186\nLINE187\nLINE188\nLINE189\nLINE190\nLINE191\nLINE192\nLINE193\nLINE194\nLINE195\nLINE196\nLINE197\nLINE198\nLINE199\nLINE200\n./ ADD NAME=UCC11TBL 0101-83252-83252-1355-00001-00001-00000-GD02150\nOPTION RESTORE UCC11TAB\n./ ADD NAME=UCC11TB1 0100-85291-85291-1323-00001-00001-00000-GD02150\nOPTION RESTORE UCC11TA1\n./ ADD NAME=VBCHART  0100-84110-84110-0956-00001-00001-00000-JS02150\n BATCHLOG VBCHART\n./ ADD NAME=VERIFY   1700-85128-85128-1006-00001-00001-00000-REL17\nOPTION VERIFY\n./ ADD NAME=XMIT     0106-87146-87146-1259-00001-00001-00000-GS00150\n~~EOT~~\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PASSDEST": {"ttr": 31493, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x00\\x7f\\x00\\x88\\x00\\x7f\\x12\\x00\\x00h\\x00h\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf2\\xf7\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-01-07T00:00:00", "modifydate": "1988-01-07T12:00:00", "lines": 104, "newlines": 104, "modlines": 0, "user": "FILE270"}, "text": "*\n**************\n*  PASSDEST  *\n**************\n*\n*        THIS IS A PROGRAM TO LOCATE THE DEFAULT DESTINATION FOUND IN\n*        THE PSCB (TSO PROTECTED STEP CONTROL BLOCK) AND THEN VPUT IT\n*        TO THE SHARED VARIABLE POOL WITH VARIABLE NAME &DEFDEST\n*\n         EJECT\n         SPACE 3\n*\n**********************************************\n*                                            *\n*        I N I T I A L I Z A T I O N         *\n*                                            *\n**********************************************\n*\nPASSDEST CSECT\n         SAVE  (14,12)\n         BALR  12,0\n         USING *,12\n         ST    13,SAVEAREA+4\n         LA    13,SAVEAREA\n         B     STARTIT\n         SPACE\nSAVEAREA DC    18F'0'\n         SPACE 3\n********************************************************************\n*        EQUATE RESISTERS 0 THRU 15 TO MORE MEANINGFUL NAMES       *\n********************************************************************\n         SPACE 3\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n         EJECT\n         SPACE 3\n*\n********************************************************************\n*                                                                  *\n*        M A I N   L I N E   L O G I C                             *\n*                                                                  *\n********************************************************************\n*\nSTARTIT  CALL  ISPLINK,(VDEFINE,SPFDEST,THEDEST,CHAR,DESTLEN),VL\n         L     R9,16            R9 ==> ADDRESS OF THE CVT\n         L     R6,0(R9)         R6 ==> ADDRESS OF A DOUBLE WORD\n*                                        POINTING TO THE TCB\n         LA    R5,TCBDWRD       R5 ==> ADDRESS OF DOUBLE WORD TCBDWRD\n         MVC   0(8,R5),0(R6)    MOVE TCB ADDRESSES TO TCBDWRD\n         L     R8,TCBDWRD+4     R8 ==> ADDRESS OF THE TCB\n         L     R7,180(R8)       R7 ==> ADDRESS OF THE JSCB\n         L     R6,264(R7)       R6 ==> ADDRESS OF THE PSCB\n         MVC   THEDEST,40(R6)   MOVE DEFAULT DESTIN TO THEDEST\n         CLI   THEDEST,X'00'    IS FIRST BYTE OF PRINT DEST = X'00'?\n         BNE   DOVPUT           IF NOT, BRANCH TO DOVPUT\n         MVC   THEDEST,=CL8'LOCAL   '\nDOVPUT   CALL  ISPLINK,(VPUT,SPFDEST,SHARED),VL\n         B     SHUTDOWN\n         EJECT\n         SPACE 3\n*\n********************************************************************\n*                                                                  *\n*        E N D  O F   J O B   P R O C E S S I N G                  *\n*                                                                  *\n********************************************************************\n*\nSHUTDOWN LA    R15,0               SET RC = 0\n         L     R13,4(R13)\n         RETURN (14,12),RC=(15)\n         EJECT\n         SPACE 3\n*\n********************************************************************\n*                                                                  *\n*        D A T A   A R E A S                                       *\n*                                                                  *\n********************************************************************\n*\n         SPACE 3\n         DS    0F\nTCBDWRD  DS    D\nTHEDEST  DS    CL8\nVDEFINE  DC    CL7'VDEFINE'\nVPUT     DC    CL4'VPUT'\nCHAR     DC    CL4'CHAR'\nDESTLEN  DC    F'8'\nSPFDEST  DC    CL9'(DEFDEST)'\nSHARED   DC    CL6'SHARED'\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "PASSDSCB": {"ttr": 31496, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x00\\x7f\\x00\\x88\\x00\\x7f\\x12\\x00\\x00\\x94\\x00\\x94\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf2\\xf7\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-01-07T00:00:00", "modifydate": "1988-01-07T12:00:00", "lines": 148, "newlines": 148, "modlines": 0, "user": "FILE270"}, "text": "*          DATA SET 764PASDSCB AT LEVEL 001 AS OF 06/03/80\n         SPACE 3\n********************************************************************\n*        SAVE REGISTERS AND ESTABLISH REGISTER 12 AS BASE REGISTER *\n********************************************************************\n         SPACE 3\nPASSDSCB START\n         SAVE  (14,12),,*\n         LR    12,15\n         USING PASSDSCB,12\n         ST    13,SAVEAREA+4\n         LA    13,SAVEAREA\n         B     STARTIT\n         SPACE\nSAVEAREA DC    18F'0'\n         SPACE 3\n********************************************************************\n*        EQUATE RESISTERS 0 THRU 15 TO MORE MEANINGFUL NAMES       *\n********************************************************************\n         SPACE 3\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n         EJECT\n         SPACE 3\n********************************************************************\n*        INITIALIZATION AND ESTABLISHING DATA AREAS                *\n*        CONTAINING OUR PARAMETERS                                 *\n********************************************************************\n         SPACE 3\nSTARTIT  DS    0D\n         LR    R11,R1                 SAVE REG 1 CONTENTS IN REG 11\n         L     R9,0(R11)\n         MVC   INDSN,0(R9)            PUT PARAMETER #1 INTO INDSN\n         L     R9,4(R11)\n         MVC   INVOL,0(R9)            PUT PARAMETER #2 INTO INVOL\n         EJECT\n         SPACE 3\n********************************************************************\n*        MAIN LINE LOGIC                                           *\n********************************************************************\n         SPACE 3\n         MVC   VALIDSW(3),YESS        MOVE 'YES' TO VALIDSW\n         CLC   INVOL,ALLNINES\n         BE    LOKAYT\n         MVC   VOLSER,INVOL\n         B     OBTANE\nLOKAYT   LOCATE CAMLIST1\n         SPACE 2\n         C     R15,=F'0'              COMPARE REG 15 TO BE = 0\n         BE    RC0                    IF REG 15=0, BRANCH TO RC0\n         MVC   VALIDSW(3),NOPE        MOVE 'NO ' TO VALIDSW\n         MVC   ERRMSG(30),MESS1       MOVE 'DATASET NOT CATALOGED'\n*                                       TO ERRMSG\n         B     SHUTDOWN               BRANCH TO SHUTDOWN\nRC0      CLC   LOCAREA(2),HEX0001     VERIFY THAT THE NUMBER OF\n*                                        VOLUMES COUNT IS 1\n         BE    MATCH                  IF YES, BRANCH TO MATCH\n         MVC   VALIDSW(3),NOPE        MOVE 'NO ' TO VALIDSW\n         MVC   ERRMSG(30),MESS2       MOVE 'FILE IS ON MORE THAN\n*                                       1 VOLUME' TO ERRMSG\n         B     SHUTDOWN               BRANCH TO SHUTDOWN\nMATCH    MVC   VOLSER(6),LOCAREA+6\n         CLI   LOCAREA+4,X'80'        COMPARE LOCAREA+4 TO BE EQUAL\n*                                       TO HEXADECIMAL 80  (THIS\n*                                       INDICATES THAT THE DATASET\n*                                       IS ON TAPE)\n         BNE   OBTANE                 BRANCH TO OBTANE\n         MVC   VALIDSW(3),NOPE        MOVE 'NO ' TO VALIDSW\n         MVC   ERRMSG(30),MESS6\n         SPACE 2\nOBTANE   OBTAIN CAMLIST2\n         SPACE 2\n         C     R15,=F'0'              COMPARE REG 15 TO BE = 0\n         BE    RCODE0                 IF REG 15=0, BRANCH TO RCODE0\n         C     R15,=F'4'              COMPARE REG 15 TO BE = 4\n         BE    RCODE4                 IF REG 15=4, BRANCH TO RCODE4\n         C     R15,=F'8'              COMPARE REG 15 TO BE = 8\n         BE    RCODE8                 IF REG 15=8, BRANCH TO RCODE8\n         MVC   ERRMSG(30),MESS5       MOVE 'OBTAIN MACRO RETURNED\n*                                       RC 12/16' TO ERRMSG\n         B     MOVENOPE\nRCODE4   MVC   ERRMSG(30),MESS3       MOVE 'REQUIRED VOLUME NOT\n*                                       MOUNTED' TO ERRMSG\n         B     MOVENOPE\nRCODE8   MVC   ERRMSG(30),MESS4       MOVE 'FORMAT-1 DSCB NOT FOUND\n*                                       ON VOL' TO ERRMSG\nMOVENOPE MVC   VALIDSW(3),NOPE        MOVE 'NO ' TO VALIDSW\n         B     SHUTDOWN               BRANCH TO SHUTDOWN\nRCODE0   B     SHUTDOWN\n         EJECT\n         SPACE 3\n********************************************************************\n*        LOAD PARAMETERS 3 - 5 AND BRANCH BACK TO CALLING PROGRAM  *\n********************************************************************\n         SPACE 3\nSHUTDOWN L     R9,8(R11)\n         MVC   0(3,R9),VALIDSW        MOVE VALIDSW TO PARAMETER #3\n         L     R9,12(R11)\n         MVC   0(30,R9),ERRMSG        MOVE ERRMSG TO PARAMETER #4\n         L     R9,16(R11)\n         MVC   0(140,R9),OBTAREA      MOVE OBTAREA TO PARAMETER #5\n         L     R13,4(R13)\n         RETURN (14,12)\n         EJECT\n         SPACE 3\n********************************************************************\n*        DATA AREAS                                                *\n********************************************************************\n         SPACE 3\n         DS    0F\nALLNINES DC    CL6'999999'\nINVOL    DS    CL6\nINDSN    DS    CL44\nCAMLIST1 CAMLST NAME,INDSN,,LOCAREA\nLOCAREA  DS    0D\n         DS    265C\n         DS    0D\nCAMLIST2 CAMLST SEARCH,INDSN,VOLSER,OBTAREA\nOBTAREA  DS    0D\n         DS    140C\n         DS    0D\nVALIDSW  DS    CL3\nERRMSG   DS    CL30\nVOLSER   DS    CL6\nHEX0001  DC    X'0001'\nYESS     DC    C'YES'\nNOPE     DC    C'NO '\nMESS1    DC    C'DATASET NOT CATALOGED         '\nMESS2    DC    C'FILE IS ON MORE THAN 1 VOLUME '\nMESS3    DC    C'REQUIRED VOLUME NOT MOUNTED   '\nMESS4    DC    C'FORMAT-1 DSCB NOT FOUND ON VOL'\nMESS5    DC    C'OBTAIN MACRO RETURNED RC 12/16'\nMESS6    DC    C'DATASET ON TAPE               '\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "PFKEYCG$": {"ttr": 31500, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x00\\x7f\\x00\\x88\\x00\\x7f\\x12\\x00\\x00\\xc7\\x00\\xc7\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf2\\xf7\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-01-07T00:00:00", "modifydate": "1988-01-07T12:00:00", "lines": 199, "newlines": 199, "modlines": 0, "user": "FILE270"}, "text": "1                                                        PFKEYCHG.1\n                                                         01/09/84\n\n\n  PROGRAM:       PFKEYCHG\n  AUTHOR:        Gary Duffield\n  AGENCY:        DIS\n  LANGUAGE:      COBOL\n  LOCATION:      Located in a \"system library\".  That is, it can be\n                 executed without supplying STEPLIB.\n  FUNCTION:      Used  with Dialog  Manager to  allow  the user  to\n                 determine which Program Function (PF) Key has been\n                 pressed or  to determine  which function  (such as\n                 END, RETURN, UP, DOWN, LEFT,  RIGHT, etc) has been\n                 requested.\n\n  RUN MODE:      Used under Dialog Manager only.\n\n  This program has two basic uses:\n\n       .    To determine which PF Key has been pressed\n                                or\n       .    To determine which function has been requested, such as\n            PRINT, SPLIT,  END, RETURN,  scrolling UP,  DOWN, LEFT,\n            RIGHT, etc.\n\n  This program works in conjunction  with PFKEYRST.  Place PFKEYCHG\n  at the  beginning of the  Dialog Manager application.   This will\n  permit the determination of the PF Key usage in the Dialog.  When\n  the Dialog  no longer needs  to make this  determination, execute\n  PFKEYRST.   Reference  documentation  of   PFKEYRST  for  further\n  discussion of its purpose.\n\n\n\n\n1                                                        PFKEYCHG.2\n                                                         01/09/84\n\n\n  HOW TO USE THIS PROGRAM\n  _______________________\n\n  Place  the following  Dialog Manager  service in  your CLIST  (or\n  equivalent CALL to ISPLINK if your  function is written in a high\n  level language  program such  as COBOL) just  prior to  the point\n  where you wish to determine the PF Key usage:\n\n       ISPEXEC SELECT PGM(PFKEYCHG) PARM(parm)\n\n            where the PARM may be coded in any one of the following\n            three ways:\n\n                 FORMAT I.   PARM(KEYNO)\n\n                                or\n\n                 FORMAT II.  PARM( )\n                      or no PARM\n\n                                or\n\n                 FORMAT III. PARM(list of functions)\n\n\n\n\n1                                                        PFKEYCHG.3\n                                                         01/09/84\n\n\n  FORMAT I.   PARM(KEYNO)\n\n       Use this format to determine which PF Key was pressed.\n\n       This program will  change all 24 (or 12)  PF Key definitions\n       to >K01 thru >K24 (or >K12).   This program also \"saves\" the\n       original PF Key definitions so  that when the application is\n       terminated,  program PFKEYRST  can  \"restore\"  them back  to\n       their original values.\n\n       The greater than sign (>) causes  the value Kxx to be passed\n       directly to the dialog in  the variable ZCMD.  Therefore, by\n       examining xx, it  is possible to determine which  PF Key was\n       pressed.\n\n  FORMAT II.  PARM( ) or no PARM\n\n       Use  this  format  to  determine  which  function  has  been\n       requested.\n\n       This program will insert the greater  than sign (>) in front\n       of all  24 (or  12) PF Key  definitions.  This  program also\n       \"saves\" the  original PF  Key definitions  so that  when the\n       application is  terminated, program  PFKEYRST can  \"restore\"\n       them back to their original values.\n\n       The greater than  sign (>) causes the  function itself (E.G.\n       END, RETURN, SPLIT, UP, DOWN, LEFT, RIGHT, etc) to be passed\n       directly to the dialog in the variable ZCMD.\n\n\n\n\n1                                                        PFKEYCHG.4\n                                                         01/09/84\n\n\n  FORMAT III  PARM(list of functions)\n\n       Use this format  to determine whether a  particular function\n       (or functions) has been requested.\n\n       This program will insert the greater  than sign (>) in front\n       of only those  functions which are provided in  the PARM and\n       leave all  other PF  Key definitions  intact.  This  program\n       also \"saves\"  the original PF  Key definitions so  that when\n       the  application   is  terminated,   program  PFKEYRST   can\n       \"restore\" them back to their original values.\n\n       The greater than  sign (>) causes the  function itself (E.G.\n       END, RETURN, SPLIT, UP, DOWN, LEFT, RIGHT, etc) to be passed\n       directly to the dialog in the variable ZCMD.\n\n\n\n\n1                                                        PFKEYCHG.5\n                                                         01/09/84\n\n\n  POSSIBLE RETURN CODES FROM PFKEYCHG:\n\n  Return Code                           Meaning\n  -----------         --------------------------------------------\n\n       0              Successful completion\n\n       4              PFKEY  backup   not  made  (one   already  in\n                      existance) (e.g., two  consecutive executions\n                      of PFKEYCHG without  an intervening execution\n                      of PFKEYRST)\n\n       8              Invalid PARM specified.\n                      One of the following reasons:\n\n                      o    More than 15 values specified\n                           in the list\n\n                      o    Value in list greater than 8\n                           characters\n\n                      o    Missing value in list\n                           (e.g. PARM=(UP,,DOWN)\n\n                      o    Invalid value in list\n\n                      o    KEYNO can not be one of the\n                           listed items\n\n\n\n\n1                                                        PFKEYCHG.6\n                                                         01/09/84\n\n  EXAMPLE:  Use PFKEYCHG and PFKEYRST so that the Dialog could\n            detect and process the UP and DOWN scroll keys:\n\n            ISPEXEC SELECT PGM(PFKEYCHG) PARM(UP,DOWN)\n            SET &RC = &LASTCC\n            IF &RC NE 0 THEN DO\n              WRITE ***********************************\n              WRITE *  ERROR IN PFKEYCHG              *\n              WRITE *                                 *\n              WRITE *        RETURN CODE IS &RC       *\n              WRITE ***********************************\n              EXIT\n              ENDO\n\n            ISPEXEC DISPLAY PANEL(your panel name)\n\n  IF &ZCMD = UP THEN\n       do whatever processing that was intended  to be done once it\n       is known  that the scroll UP Key was pressed\n\n  IF &ZCMD = DOWN THEN\n       do whatever processing that was intended  to be done once it\n       is known  that the scroll DOWN Key was pressed\n            .\n            .\n            .\n\n  ENDIT: ISPEXEC SELECT PGM(PFKEYRST)\n         EXIT\n\n\n\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PFKEYCHG": {"ttr": 31747, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x00\\x7f\\x00\\x88\\x00\\x7f\\x12\\x00\\x01\\xa4\\x01\\xa4\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf2\\xf7\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-01-07T00:00:00", "modifydate": "1988-01-07T12:00:00", "lines": 420, "newlines": 420, "modlines": 0, "user": "FILE270"}, "text": "      *******************************\n       ID DIVISION.\n      *******************************\n\n       PROGRAM-ID. PFKEYCHG.\n       AUTHOR.     GARY DUFFIELD.\n       REMARKS.\n                   THIS PROGRAM SAVES THE USERS PFKEY ASSIGNMENTS AND\n        CHANGES THEM TO COMMUNICATE WITH DIALOG MANAGER THROUGH '&ZCMD'.\n           EJECT\n      *******************************\n       ENVIRONMENT DIVISION.\n      *******************************\n\n       CONFIGURATION SECTION.\n\n       INPUT-OUTPUT SECTION.\n\n           EJECT\n      *******************************\n       DATA DIVISION.\n      *******************************\n\n       FILE SECTION.\n\n           EJECT\n\n       WORKING-STORAGE SECTION.\n\n       01  SWITCHES.\n\n           05  PARM-ERROR               PIC XXX        VALUE 'NO '.\n               88  PARM-OKAY                           VALUE 'NO '.\n               88  PARM-NOT-OKAY                       VALUE 'YES'.\n\n           05  CHANGE-TYPE              PIC 9          VALUE 0.\n               88  CHANGE-TO-KEY-NUMBER                VALUE 1.\n               88  CHANGE-LISTED-VALUES                VALUE 2.\n               88  CHANGE-ALL-VALUES                   VALUE 3.\n\n       01  MISC-WORK-FIELDS.\n\n           05  SAVE-CODE                PIC 9(4)       VALUE 0.\n           05  SWITCH-CODE              PIC 9(4)       VALUE 0.\n           05  SAVE-SWITCH              PIC XX         VALUE SPACE.\n           05  ZPFKEY-NUMBER            PIC XX         VALUE SPACE.\n           05  PREFIXED-PFKEY.\n               10  FILLER               PIC X          VALUE '>'.\n               10  WORK-PFKEY           PIC X(43)      VALUE SPACE.\n\n       01  DIALOG-MANAGER-CONTROLS.\n\n           05  CHAR                   PIC X(4)       VALUE 'CHAR'.\n           05  LEN                    PIC S9(8) COMP VALUE +0.\n           05  PROFILE                PIC X(7)       VALUE 'PROFILE'.\n           05  VDEFINE                PIC X(7)       VALUE 'VDEFINE'.\n           05  VGET                   PIC X(4)       VALUE 'VGET'.\n           05  VPUT                   PIC X(4)       VALUE 'VPUT'.\n           05  ZPFKEYS                PIC X(7)       VALUE '(ZKEYS)'.\n           05  ZPFSW                  PIC X(7)       VALUE '(ZPFSW)'.\n\n       01  TABLES.\n\n           05  PARM-TABLE.\n               10  PARM-FIELD OCCURS 15 TIMES\n                   INDEXED BY INX-01   PIC X(8).\n\n           05  HOLD-TABLE.\n               10  HOLD-CHARACTER OCCURS 8 TIMES\n                   INDEXED BY INX-02   PIC X.\n\n           05  PARM-VALUES-TABLE.\n              10  FILLER               PIC X(48)   VALUE\n                 'RCHANGE CURSOR  DOWN    END     RFIND   HELP    '.\n              10  FILLER               PIC X(48)   VALUE\n                 'LEFT    NOP     PRINT   PRINT-HIRETURN  RIGHT   '.\n              10  FILLER               PIC X(24)   VALUE\n                 'SPLIT   SWAP    UP      '.\n\n           05  PARM-VALUE-TABLE REDEFINES PARM-VALUES-TABLE.\n               10  PARM-VALUE OCCURS 15 TIMES\n                   INDEXED BY INX-03   PIC X(8).\n\n           05  SAVE-KEY-NAMES.\n              10  FILLER               PIC X(43)   VALUE\n                 '(ZKEY01,ZKEY02,ZKEY03,ZKEY04,ZKEY05,ZKEY06,'.\n              10  FILLER               PIC X(42)   VALUE\n                 'ZKEY07,ZKEY08,ZKEY09,ZKEY10,ZKEY11,ZKEY12,'.\n              10  FILLER               PIC X(42)   VALUE\n                 'ZKEY13,ZKEY14,ZKEY15,ZKEY16,ZKEY17,ZKEY18,'.\n              10  FILLER               PIC X(42)   VALUE\n                 'ZKEY19,ZKEY20,ZKEY21,ZKEY22,ZKEY23,ZKEY24)'.\n\n           05  SPF-KEY-NAMES.\n               10  FILLER               PIC X(37)   VALUE\n                  '(ZPF01,ZPF02,ZPF03,ZPF04,ZPF05,ZPF06,'.\n               10  FILLER               PIC X(36)   VALUE\n                  'ZPF07,ZPF08,ZPF09,ZPF10,ZPF11,ZPF12,'.\n               10  FILLER               PIC X(36)   VALUE\n                  'ZPF13,ZPF14,ZPF15,ZPF16,ZPF17,ZPF18,'.\n               10  FILLER               PIC X(36)   VALUE\n                  'ZPF19,ZPF20,ZPF21,ZPF22,ZPF23,ZPF24)'.\n\n           05  NUMBERS-FOR-12-KEY.\n               10  FILLER               PIC X(516)  VALUE SPACE.\n               10  FILLER               PIC X(43)   VALUE\n                  '>K01                                       '.\n               10  FILLER               PIC X(43)   VALUE\n                  '>K02                                       '.\n               10  FILLER               PIC X(43)   VALUE\n                  '>K03                                       '.\n               10  FILLER               PIC X(43)   VALUE\n                  '>K04                                       '.\n               10  FILLER               PIC X(43)   VALUE\n                  '>K05                                       '.\n               10  FILLER               PIC X(43)   VALUE\n                  '>K06                                       '.\n               10  FILLER               PIC X(43)   VALUE\n                  '>K07                                       '.\n               10  FILLER               PIC X(43)   VALUE\n                  '>K08                                       '.\n               10  FILLER               PIC X(43)   VALUE\n                  '>K09                                       '.\n               10  FILLER               PIC X(43)   VALUE\n                  '>K10                                       '.\n               10  FILLER               PIC X(43)   VALUE\n                  '>K11                                       '.\n               10  FILLER               PIC X(43)   VALUE\n                  '>K12                                       '.\n\n           05  NUMBERS-FOR-24-KEY.\n               10  FILLER               PIC X(43)   VALUE\n                  '>K01                                       '.\n               10  FILLER               PIC X(43)   VALUE\n                  '>K02                                       '.\n               10  FILLER               PIC X(43)   VALUE\n                  '>K03                                       '.\n               10  FILLER               PIC X(43)   VALUE\n                  '>K04                                       '.\n               10  FILLER               PIC X(43)   VALUE\n                  '>K05                                       '.\n               10  FILLER               PIC X(43)   VALUE\n                  '>K06                                       '.\n               10  FILLER               PIC X(43)   VALUE\n                  '>K07                                       '.\n               10  FILLER               PIC X(43)   VALUE\n                  '>K08                                       '.\n               10  FILLER               PIC X(43)   VALUE\n                  '>K09                                       '.\n               10  FILLER               PIC X(43)   VALUE\n                  '>K10                                       '.\n               10  FILLER               PIC X(43)   VALUE\n                  '>K11                                       '.\n               10  FILLER               PIC X(43)   VALUE\n                  '>K12                                       '.\n               10  FILLER               PIC X(43)   VALUE\n                  '>K13                                       '.\n               10  FILLER               PIC X(43)   VALUE\n                  '>K14                                       '.\n               10  FILLER               PIC X(43)   VALUE\n                  '>K15                                       '.\n               10  FILLER               PIC X(43)   VALUE\n                  '>K16                                       '.\n               10  FILLER               PIC X(43)   VALUE\n                  '>K17                                       '.\n               10  FILLER               PIC X(43)   VALUE\n                  '>K18                                       '.\n               10  FILLER               PIC X(43)   VALUE\n                  '>K19                                       '.\n               10  FILLER               PIC X(43)   VALUE\n                  '>K20                                       '.\n               10  FILLER               PIC X(43)   VALUE\n                  '>K21                                       '.\n               10  FILLER               PIC X(43)   VALUE\n                  '>K22                                       '.\n               10  FILLER               PIC X(43)   VALUE\n                  '>K23                                       '.\n               10  FILLER               PIC X(43)   VALUE\n                  '>K24                                       '.\n\n           05  PFKEY-VALUES.\n               10  PFKEY OCCURS 24 TIMES INDEXED BY INX-04.\n                   15  PFKEY-PREF        PIC X.\n                   15  PFKEY-REST        PIC X(42).\n               EJECT\n      *************************************\n       LINKAGE SECTION.\n      *************************************\n\n       01  PARM-FIELD-IN.\n           05  PARM-LENGTH               PIC S9(4) COMP.\n           05  PARM-IN.\n               10  PARM-CHARACTER OCCURS 134 TIMES\n                   INDEXED BY INX-05         PIC X.\n           EJECT\n      ****************************************\n       PROCEDURE DIVISION USING PARM-FIELD-IN.\n      ****************************************\n       CONTROL-MODULE.\n      *************************************\n\n           PERFORM 0000-INITIALIZE-MODULE.\n           IF PARM-OKAY\n              PERFORM 1000-CHANGE-MODULE\n              PERFORM 2000-TERMINATE-MODULE.\n           MOVE SAVE-CODE TO RETURN-CODE.\n           STOP RUN.\n           EJECT\n      *************************************\n       0000-INITIALIZE-MODULE.\n      *************************************\n\n           MOVE +2 TO LEN.\n           CALL 'ISPLINK' USING VDEFINE\n                                ZPFSW    SAVE-SWITCH   CHAR LEN.\n           MOVE RETURN-CODE TO SAVE-CODE.\n           MOVE SPACE TO PARM-TABLE\n                         HOLD-TABLE.\n           PERFORM 0010-PROCESS-PARM-MODULE.\n           IF PARM-OKAY\n              PERFORM 0020-INITIALIZE-KEYS-MODULE.\n\n      *************************************\n       0010-PROCESS-PARM-MODULE.\n      *************************************\n\n           IF PARM-LENGTH = 0\n              OR PARM-IN = SPACE\n              MOVE 3 TO CHANGE-TYPE\n           ELSE\n              IF PARM-LENGTH > 134\n                 OR PARM-LENGTH = 1\n                 MOVE 'YES' TO PARM-ERROR\n                 MOVE 8 TO SAVE-CODE\n              ELSE\n                 SET INX-01 TO 1\n                 SET INX-05 TO 1\n                 PERFORM 0011-PARSE-PARM-MODULE\n                    UNTIL INX-05 NOT < PARM-LENGTH\n                    OR PARM-NOT-OKAY\n                    OR INX-01 > 15\n                 IF INX-01 > 15\n                    MOVE 'YES' TO PARM-ERROR\n                    MOVE 8 TO SAVE-CODE\n                 ELSE\n                    IF PARM-OKAY\n                       PERFORM 0013-EDIT-PARM-VALUE-MODULE.\n\n      *************************************\n       0011-PARSE-PARM-MODULE.\n      *************************************\n\n           SET INX-02 TO 1.\n           PERFORM 0012-MOVE-PARMCHAR-MODULE\n              VARYING INX-05 FROM INX-05 BY 1\n              UNTIL PARM-CHARACTER (INX-05) = ','\n              OR INX-05 > PARM-LENGTH\n              OR INX-02 > 9.\n           IF INX-02 > 9\n              MOVE 'YES' TO PARM-ERROR\n              MOVE 8 TO SAVE-CODE\n           ELSE\n              IF HOLD-TABLE = SPACE\n                 MOVE 'YES' TO PARM-ERROR\n                 MOVE 8 TO SAVE-CODE\n              ELSE\n                 SET INX-05 UP BY 1\n                 MOVE HOLD-TABLE TO PARM-FIELD (INX-01)\n                 MOVE SPACE TO HOLD-TABLE\n                 SET INX-01 UP BY 1.\n\n      *************************************\n       0012-MOVE-PARMCHAR-MODULE.\n      *************************************\n\n           MOVE PARM-CHARACTER (INX-05) TO HOLD-CHARACTER (INX-02).\n           SET INX-02 UP BY 1.\n\n      *************************************\n       0013-EDIT-PARM-VALUE-MODULE.\n      *************************************\n\n           PERFORM 0014-LOOP-MODULE\n              VARYING INX-01 FROM 1 BY 1\n              UNTIL INX-01 > 15\n              OR PARM-FIELD (INX-01) = 'KEYNO   '\n           IF PARM-FIELD (INX-01) = 'KEYNO   '\n              IF (INX-01 NOT = 1)\n                 OR (PARM-FIELD (INX-01 + 1) NOT = SPACE)\n                 MOVE 'YES' TO PARM-ERROR\n                 MOVE 8 TO SAVE-CODE\n              ELSE\n                 MOVE 1 TO CHANGE-TYPE\n           ELSE\n              MOVE 2 TO CHANGE-TYPE\n              PERFORM 0015-CHECK-PARMLIST-MODULE\n                 VARYING INX-01 FROM 1 BY 1\n                 UNTIL PARM-FIELD (INX-01) = SPACE\n                 OR PARM-NOT-OKAY\n                 OR INX-01 > 15.\n\n      *************************************\n       0014-LOOP-MODULE.\n      *************************************\n\n           EXIT.\n\n      *************************************\n       0015-CHECK-PARMLIST-MODULE.\n      *************************************\n\n           PERFORM 0014-LOOP-MODULE\n              VARYING INX-03 FROM 1 BY 1\n              UNTIL PARM-FIELD (INX-01) = PARM-VALUE (INX-03)\n              OR INX-03 > 15.\n           IF INX-03 > 15\n              MOVE 'YES' TO PARM-ERROR\n              MOVE 8 TO SAVE-CODE.\n\n      *************************************\n       0020-INITIALIZE-KEYS-MODULE.\n      *************************************\n\n           MOVE +43 TO LEN.\n           CALL 'ISPLINK' USING VDEFINE\n                                SAVE-KEY-NAMES PFKEY-VALUES CHAR LEN.\n           IF RETURN-CODE > SAVE-CODE\n              MOVE RETURN-CODE TO SAVE-CODE.\n           CALL 'ISPLINK' USING VDEFINE\n                                SPF-KEY-NAMES  PFKEY-VALUES CHAR LEN.\n           IF RETURN-CODE > SAVE-CODE\n              MOVE RETURN-CODE TO SAVE-CODE.\n           MOVE +2 TO LEN.\n           CALL 'ISPLINK' USING VDEFINE\n                                ZPFKEYS  ZPFKEY-NUMBER CHAR LEN.\n           IF RETURN-CODE > SAVE-CODE\n              MOVE RETURN-CODE TO SAVE-CODE.\n           CALL 'ISPLINK' USING VGET SPF-KEY-NAMES PROFILE.\n           IF RETURN-CODE > SAVE-CODE\n              MOVE RETURN-CODE TO SAVE-CODE.\n           CALL 'ISPLINK' USING VGET ZPFSW.\n           MOVE RETURN-CODE TO SWITCH-CODE.\n           IF SWITCH-CODE = 8\n              OR SAVE-SWITCH = SPACE\n              MOVE 'ON' TO SAVE-SWITCH\n              CALL 'ISPLINK' USING VPUT SAVE-KEY-NAMES\n              CALL 'ISPLINK' USING VPUT ZPFSW\n           ELSE\n              MOVE 4 TO SAVE-CODE.\n           CALL 'ISPLINK' USING VGET ZPFKEYS PROFILE.\n           IF RETURN-CODE > SAVE-CODE\n              MOVE RETURN-CODE TO SAVE-CODE.\n           EJECT\n      *************************************\n       1000-CHANGE-MODULE.\n      *************************************\n\n           IF CHANGE-TO-KEY-NUMBER\n              PERFORM 1010-KEYNO-CHANGE-MODULE\n           ELSE\n              IF CHANGE-LISTED-VALUES\n                 PERFORM 1020-LISTED-VALUES-MODULE\n              ELSE\n                 PERFORM 1030-ALL-VALUES-MODULE.\n           EJECT\n      *************************************\n       1010-KEYNO-CHANGE-MODULE.\n      *************************************\n\n           IF ZPFKEY-NUMBER = '12'\n              MOVE NUMBERS-FOR-12-KEY TO PFKEY-VALUES\n           ELSE\n              MOVE NUMBERS-FOR-24-KEY TO PFKEY-VALUES.\n           EJECT\n      *************************************\n       1020-LISTED-VALUES-MODULE.\n      *************************************\n\n           PERFORM 1021-MODIFY-VALUES-MODULE\n              VARYING INX-04 FROM 1 BY 1\n              UNTIL INX-04 > 24.\n\n      *************************************\n       1021-MODIFY-VALUES-MODULE.\n      *************************************\n\n           IF PFKEY-PREF (INX-04) NOT = '>' AND ':'\n              PERFORM 0014-LOOP-MODULE\n                 VARYING INX-01 FROM 1 BY 1\n                 UNTIL PFKEY (INX-04) = PARM-FIELD (INX-01)\n                 OR INX-01 > 15\n              IF PFKEY (INX-04) = PARM-FIELD (INX-01)\n                 MOVE PFKEY (INX-04) TO WORK-PFKEY\n                 MOVE PREFIXED-PFKEY TO PFKEY (INX-04)\n                 MOVE SPACE TO WORK-PFKEY.\n           EJECT\n      *************************************\n       1030-ALL-VALUES-MODULE.\n      *************************************\n\n           PERFORM 1031-MODIFY-VALUES-MODULE\n              VARYING INX-04 FROM 1 BY 1\n              UNTIL INX-04 > 24.\n\n      *************************************\n       1031-MODIFY-VALUES-MODULE.\n      *************************************\n\n           IF PFKEY-PREF (INX-04) NOT = '>' AND ':'\n              MOVE PFKEY (INX-04) TO WORK-PFKEY\n              MOVE PREFIXED-PFKEY TO PFKEY (INX-04)\n              MOVE SPACE TO WORK-PFKEY.\n           EJECT\n      *************************************\n       2000-TERMINATE-MODULE.\n      *************************************\n\n           CALL 'ISPLINK' USING VPUT SPF-KEY-NAMES PROFILE.\n           IF RETURN-CODE > SAVE-CODE\n              MOVE RETURN-CODE TO SAVE-CODE.\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "PFKEYRS$": {"ttr": 31754, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x00\\x7f\\x00\\x88\\x00\\x7f\\x12\\x00\\x003\\x003\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf2\\xf7\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-01-07T00:00:00", "modifydate": "1988-01-07T12:00:00", "lines": 51, "newlines": 51, "modlines": 0, "user": "FILE270"}, "text": "1                                                        PFKEYRST.1\n                                                         01/09/84\n\n\n  PROGRAM:       PFKEYRST\n  AUTHOR:        Gary Duffield\n  AGENCY:        DIS\n  LANGUAGE:      COBOL\n  LOCATION:      Located in a \"system library\".  That is, it can be\n                 executed without supplying STEPLIB.\n  FUNCTION:      Used with Dialog Manager to \"restore\" the users PF\n                 Key  definitions to  their  original values  after\n                 program PFKEYCHG  modified them.  This program  is\n                 used in conjunction with PFKEYCHG.\n\n  RUN MODE:      Used under Dialog Manager only.\n\n  The  purpose  of  this  program  is   to  \"restore\"  the  PF  Key\n  definitions  back to  their  original  values after  the  program\n  PFKEYCHG was used to temporarily change them.\n\n  This program  is usually executed in  the closing routine  in the\n  Dialog.  This program is used  in conjunction with PFKEYCHG.  For\n  a discussion  on how to use  the program PFKEYCHG,  reference the\n  documentation in this manual for that program.\n\n  HOW TO INVOKE THIS PROGRAM:\n\n       ISPEXEC SELECT PGM(PFKEYRST)\n\n\n\n\n1                                                        PFKEYRST.2\n                                                         01/09/84\n\n\n  POSSIBLE RETURN CODES FROM PFKEYRST:\n\n       Return Code                           Meaning\n       -----------              ----------------------------------\n\n            0                   Successful completion\n\n            4                   No PF Key backup in existance (I.E.\n                                This  program was  invoked  without\n                                first invoking PFKEYCHG)\n\n\n\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PFKEYRST": {"ttr": 31756, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x00\\x7f\\x00\\x88\\x00\\x7f\\x12\\x00\\x00l\\x00l\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf2\\xf7\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-01-07T00:00:00", "modifydate": "1988-01-07T12:00:00", "lines": 108, "newlines": 108, "modlines": 0, "user": "FILE270"}, "text": "      *******************************\n       ID DIVISION.\n      *******************************\n\n       PROGRAM-ID. PFKEYRST.\n       AUTHOR.     GARY DUFFIELD.\n       REMARKS.\n                   THIS PROGRAM RESTORES THE USERS PFKEY ASSIGNMENTS\n           FROM TEMPORARY 'SAVE' VARIABLES IN HIS SHARED VARIABLE POOL.\n           EJECT\n      *******************************\n       ENVIRONMENT DIVISION.\n      *******************************\n\n       CONFIGURATION SECTION.\n\n       INPUT-OUTPUT SECTION.\n\n           EJECT\n      *******************************\n       DATA DIVISION.\n      *******************************\n\n       FILE SECTION.\n\n           EJECT\n\n       WORKING-STORAGE SECTION.\n\n       01  MISC-WORK-FIELDS.\n\n           05  SAVE-CODE                PIC 9(4)       VALUE 0.\n           05  SAVE-SWITCH              PIC XX         VALUE SPACE.\n\n       01  DIALOG-MANAGER-CONTROLS.\n\n           05  CHAR                     PIC X(4)       VALUE 'CHAR'.\n           05  LEN                      PIC S9(8) COMP VALUE +0.\n           05  PROFILE                  PIC X(7)       VALUE 'PROFILE'.\n           05  VDEFINE                  PIC X(7)       VALUE 'VDEFINE'.\n           05  VGET                     PIC X(4)       VALUE 'VGET'.\n           05  VPUT                     PIC X(4)       VALUE 'VPUT'.\n           05  ZPFSW                    PIC X(7)       VALUE '(ZPFSW)'.\n\n       01  TABLES.\n\n           05  SAVE-KEY-NAMES.\n              10  FILLER               PIC X(43)   VALUE\n                 '(ZKEY01,ZKEY02,ZKEY03,ZKEY04,ZKEY05,ZKEY06,'.\n              10  FILLER               PIC X(42)   VALUE\n                 'ZKEY07,ZKEY08,ZKEY09,ZKEY10,ZKEY11,ZKEY12,'.\n              10  FILLER               PIC X(42)   VALUE\n                 'ZKEY13,ZKEY14,ZKEY15,ZKEY16,ZKEY17,ZKEY18,'.\n              10  FILLER               PIC X(42)   VALUE\n                 'ZKEY19,ZKEY20,ZKEY21,ZKEY22,ZKEY23,ZKEY24)'.\n\n           05  SPF-KEY-NAMES.\n               10  FILLER               PIC X(37)   VALUE\n                  '(ZPF01,ZPF02,ZPF03,ZPF04,ZPF05,ZPF06,'.\n               10  FILLER               PIC X(36)   VALUE\n                  'ZPF07,ZPF08,ZPF09,ZPF10,ZPF11,ZPF12,'.\n               10  FILLER               PIC X(36)   VALUE\n                  'ZPF13,ZPF14,ZPF15,ZPF16,ZPF17,ZPF18,'.\n               10  FILLER               PIC X(36)   VALUE\n                  'ZPF19,ZPF20,ZPF21,ZPF22,ZPF23,ZPF24)'.\n\n           05  PFKEY-VALUES.\n               10  PFKEY OCCURS 24 TIMES PIC X(43).\n               EJECT\n      *************************************\n       PROCEDURE DIVISION.\n      *************************************\n       PROCESS-MODULE.\n      *************************************\n\n           MOVE +2 TO LEN.\n           CALL 'ISPLINK' USING VDEFINE\n                                ZPFSW          SAVE-SWITCH  CHAR LEN.\n           MOVE RETURN-CODE TO SAVE-CODE.\n           CALL 'ISPLINK' USING VGET ZPFSW.\n           IF SAVE-SWITCH = 'ON'\n              MOVE SPACE TO SAVE-SWITCH\n              CALL 'ISPLINK' USING VPUT ZPFSW\n              PERFORM 1000-RESTORE-MODULE\n           ELSE\n              MOVE 4 TO RETURN-CODE.\n           STOP RUN.\n\n      *************************************\n       1000-RESTORE-MODULE.\n      *************************************\n\n           MOVE +43 TO LEN.\n           CALL 'ISPLINK' USING VDEFINE\n                                SAVE-KEY-NAMES PFKEY-VALUES CHAR LEN.\n           IF RETURN-CODE > SAVE-CODE\n              MOVE RETURN-CODE TO SAVE-CODE.\n           CALL 'ISPLINK' USING VDEFINE\n                                SPF-KEY-NAMES  PFKEY-VALUES CHAR LEN.\n           IF RETURN-CODE > SAVE-CODE\n              MOVE RETURN-CODE TO SAVE-CODE.\n           CALL 'ISPLINK' USING VGET SAVE-KEY-NAMES.\n           IF RETURN-CODE > SAVE-CODE\n              MOVE RETURN-CODE TO SAVE-CODE.\n           CALL 'ISPLINK' USING VPUT SPF-KEY-NAMES PROFILE.\n           IF RETURN-CODE > SAVE-CODE\n              MOVE RETURN-CODE TO SAVE-CODE.\n           MOVE SAVE-CODE TO RETURN-CODE.\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "PROCLIB": {"ttr": 32003, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x00\\x7f\\x00\\x88\\x00\\x7f\\x12\\x00\\x02\\xd0\\x02\\xd0\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf2\\xf7\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-01-07T00:00:00", "modifydate": "1988-01-07T12:00:00", "lines": 720, "newlines": 720, "modlines": 0, "user": "FILE270"}, "text": "./ ADD NAME=FILEUSE  0107-82200-83276-0949-00035-00035-00000-JS02150\n//FILEUSE   PROC   PREFIX=MUCHTOOLONG,COPIES=1\n//*\n//*\n//STEP1  EXEC  PGM=P33PARM,\n//  PARM='  LISTC LVL(&PREFIX)'\n//*\n//STEPLIB  DD  DISP=SHR,DSN=WDPSC.SHARED.LOAD\n//SYSOUT   DD  SYSOUT=*\n//SYSUT2   DD  UNIT=SYSDA,DISP=(NEW,PASS),DSN=&&LISTC,\n//             SPACE=(TRK,1),\n//             DCB=(RECFM=FB,LRECL=80,BLKSIZE=80)\n//*\n//STEP2  EXEC  PGM=IDCAMS\n//*\n//SYSPRINT DD  UNIT=SYSDA,DISP=(NEW,PASS),DSN=&&SYSPRINT,\n//             SPACE=(CYL,(2,1),RLSE)\n//SYSIN    DD  DISP=(OLD,DELETE),DSN=&&LISTC\n//*\n//STEP3  EXEC  PGM=DYL260\n//*\n//SYSPRINT DD  SYSOUT=*\n//SYS260A  DD  DISP=(OLD,DELETE),DSN=&&SYSPRINT\n//SYS260J  DD  UNIT=SYSDA,DISP=(NEW,PASS),DSN=&&THEDSNS,\n//             SPACE=(TRK,(8,2),RLSE),\n//             DCB=(RECFM=FB,LRECL=80,BLKSIZE=6160)\n//SYSIN    DD  DSN=WDPSC.MASTER.CLIST.PARMS(FILEUSE),DISP=SHR\n//*\n//STEP4  EXEC  PGM=FILEUSE,PARM='&PREFIX       '\n//*\n//STEPLIB  DD  DISP=SHR,DSN=WDPSC.SHARED.LOAD\n//INPUT    DD  DISP=(OLD,DELETE),DSN=&&THEDSNS\n//REPORT   DD  SYSOUT=*,DCB=BLKSIZE=133,COPIES=&COPIES\n//*\n//*\n//*  E N D   O F   P R O C E D U R E\n./ ADD NAME=JCLXREF  0106-83215-86101-0955-00298-00296-00000-JS02150\n//JCLXREF  PROC CA=6,PROCLIB='USER.PROCLIB',\n//    AGENCY='NOAGENCYGIVEN',\n//    SRTWK1=2,SRTWK2=3,\n//    RPT1=0,\n//    RPT2=0,\n//    RPT3=0,\n//    RPT4=0,\n//    RPT5=0,\n//    RPT6=0\n//*\n//*    THIS PROCEDURE IS TO LIST AND XREF JOB CONTROL STATEMENTS\n//*        THAT RESIDE ON A PROCEDURE LIBRARY\n//*\n//*\n//*\n//************************************************************\n//STEP00   EXEC PGM=IEFBR14        FORCE COND CODE 0\n//************************************************************\n//*\n//************************************************************\n//STEP0A   EXEC PGM=FTL\n//************************************************************\n//*\n//MESSAGES  DD SYSOUT=*\n//IN01      DD DUMMY\n//OUT01     DD DSN=&&NONPROC,UNIT=SYSDA,DISP=(NEW,PASS),\n//             DCB=(LRECL=80,BLKSIZE=2400,RECFM=FB),\n//             SPACE=(CYL,(2,2))\n//*\n//************************************************************\n//STEP0B   EXEC PGM=DYL260\n//************************************************************\n//*\n//SYSPRINT  DD SYSOUT=*\n//SYS260A   DD DSN=&&NONPROC,DISP=(OLD,PASS)\n//SYS260J   DD DSN=&&ENONPROC,DISP=(,PASS),UNIT=SYSDA,\n//          SPACE=(CYL,(1,1)),DCB=(LRECL=88,RECFM=FB,BLKSIZE=880)\n//SYSIN     DD DSN=WDPSC.MASTER.CLIST.PARMS(JCLXRF0B),DISP=SHR\n//*\n//************************************************************\n//STEP0C   EXEC PGM=SORT\n//************************************************************\n//*\n//SYSOUT    DD SYSOUT=*\n//SORTLIB   DD DSN=SYS1.SORTLIB,DISP=SHR\n//SORTWK01  DD UNIT=SYSDA,SPACE=(CYL,&SRTWK1,,CONTIG)\n//SORTWK02  DD UNIT=SYSDA,SPACE=(CYL,&SRTWK1,,CONTIG)\n//SORTWK03  DD UNIT=SYSDA,SPACE=(CYL,&SRTWK1,,CONTIG)\n//SORTIN    DD DSN=&&ENONPROC,DISP=(OLD,DELETE)\n//SORTOUT   DD DSN=&&SNONPROC,DISP=(NEW,PASS),UNIT=SYSDA,\n//             SPACE=(CYL,(1,1)),DCB=(LRECL=88,RECFM=FB,BLKSIZE=880)\n//SYSIN     DD DSN=WDPSC.MASTER.CLIST.PARMS(JCLXRF0C),DISP=SHR\n//*\n//************************************************************\n//STEP0D   EXEC PGM=DYL260,COND=(&RPT1,NE,STEP00)\n//************************************************************\n//*\n//SYSPRINT  DD SYSOUT=*\n//SYS260A   DD DSN=&&SNONPROC,DISP=(OLD,PASS)\n//SYS260R   DD SYSOUT=*\n//SYSIN     DD DSN=WDPSC.MASTER.CLIST.PARMS(JCLXRF0D),DISP=SHR\n//*\n//************************************************************\n//STEP1     EXEC PGM=LISTMEMS\n//************************************************************\n//*\n//STEPLIB   DD DSN=WDPSC.SHARED.LOAD,DISP=SHR\n//INPDS     DD DSN=&PROCLIB,DISP=SHR\n//OUTMEMS   DD UNIT=SYSDA,DISP=(NEW,PASS),\n//             DSN=&&PDSLIST,\n//             SPACE=(CYL,(2,1)),\n//             DCB=(LRECL=80,RECFM=FB,BLKSIZE=6160)\n//*\n//*****************************************************************\n//STEP3    EXEC PGM=DYL260,PARM='UA=&AGENCY',\n//            COND=(0,NE,STEP1)\n//*****************************************************************\n//*\n//SYSPRINT  DD SYSOUT=*\n//SYS260A   DD DSN=&&PDSLIST,DISP=(OLD,DELETE)\n//SYS260J   DD DSN=&&MEMBERS,DISP=(NEW,PASS),UNIT=SYSDA,\n//             SPACE=(CYL,(1,1)),DCB=(LRECL=80,BLKSIZE=400,RECFM=FB)\n//SYSIN DD DISP=SHR,DSN=WDPSC.MASTER.CLIST.PARMS(JCLXRTWO)\n//*\n//*****************************************************************\n//STEP4    EXEC PGM=SORT,\n//            COND=((0,NE,STEP1),(0,NE,STEP3))\n//*****************************************************************\n//*\n//SYSOUT    DD SYSOUT=*\n//SORTLIB   DD DSN=SYS1.SORTLIB,DISP=SHR\n//SORTWK01  DD UNIT=SYSDA,SPACE=(CYL,&SRTWK1,,CONTIG)\n//SORTWK02  DD UNIT=SYSDA,SPACE=(CYL,&SRTWK1,,CONTIG)\n//SORTWK03  DD UNIT=SYSDA,SPACE=(CYL,&SRTWK1,,CONTIG)\n//SORTIN    DD DSN=&&MEMBERS,DISP=(OLD,DELETE)\n//SORTOUT   DD DSN=&&PROCS,DISP=(NEW,PASS),UNIT=SYSDA,\n//             SPACE=(CYL,(1,1)),DCB=(LRECL=80,RECFM=FB,BLKSIZE=400)\n//SYSIN DD DISP=SHR,DSN=WDPSC.MASTER.CLIST.PARMS(JCLXREF3)\n//*\n//*****************************************************************\n//STEP5    EXEC PGM=IEBPTPCH,\n//            COND=((0,NE,STEP1),(0,NE,STEP3))\n//*****************************************************************\n//*\n//SYSPRINT  DD SYSOUT=*\n//SYSUT1    DD DSN=&PROCLIB,DISP=SHR\n//SYSIN     DD DSN=&&PROCS,DISP=(OLD,PASS)\n//SYSUT2    DD DSN=&&JCD,DISP=(NEW,PASS),UNIT=SYSDA,\n//             SPACE=(CYL,(10,1),RLSE),\n//             DCB=(LRECL=81,RECFM=FB,BLKSIZE=2430)\n//*\n//*****************************************************************\n//STEP6    EXEC PGM=DYL260,\n//            COND=((0,NE,STEP1),(0,NE,STEP3))\n//*****************************************************************\n//*\n//SYSPRINT  DD SYSOUT=*\n//SYS260A   DD DSN=&&PROCS,DISP=(OLD,DELETE)\n//SYS260R   DD UNIT=SYSDA,DISP=(NEW,CATLG),DSN=&&XREFRPT2,\n//    SPACE=(CYL,(8,2),RLSE),\n//    DCB=(RECFM=FBM,LRECL=133,BLKSIZE=1330)\n//SYSIN DD DISP=SHR,DSN=WDPSC.MASTER.CLIST.PARMS(JCLXREF4)\n//*\n//*****************************************************************\n//STEP7    EXEC PGM=DYL260,\n//            COND=((0,NE,STEP1),(0,NE,STEP3))\n//*****************************************************************\n//*\n//SYSPRINT  DD SYSOUT=*\n//SYS260A   DD DSN=&&JCD,DISP=(OLD,DELETE)\n//SYS260J   DD DSN=&&JCL,DISP=(NEW,PASS),UNIT=SYSDA,\n//             SPACE=(CYL,(5,1)),DCB=(LRECL=80,BLKSIZE=2400,RECFM=FB)\n//SYS260R   DD UNIT=SYSDA,DISP=(NEW,CATLG),DSN=&&XREFRPT3,\n//    SPACE=(CYL,(8,2),RLSE),\n//    DCB=(RECFM=FBM,LRECL=133,BLKSIZE=1330)\n//SYSIN DD DISP=SHR,DSN=WDPSC.MASTER.CLIST.PARMS(JCLXREF5)\n//*\n//*****************************************************************\n//STEP8    EXEC PGM=U3011195,\n//            COND=((0,NE,STEP1),(0,NE,STEP3))\n//*****************************************************************\n//*\n//STEPLIB   DD DSN=WDPSC.SHARED.LOAD,DISP=SHR\n//SYSUDUMP  DD SYSOUT=*\n//FILEIN    DD DSN=&&JCL,DISP=(OLD,DELETE)\n//FILEOUT1  DD DSN=&&RES,DISP=(NEW,PASS),UNIT=SYSDA,\n//             SPACE=(CYL,(5,2)),DCB=(RECFM=FB,BLKSIZE=400)\n//FILEOUT2  DD DSN=&&BKREF,DCB=(BLKSIZE=400,RECFM=FB),\n//             SPACE=(TRK,(5,2)),UNIT=SYSDA,\n//             DISP=(,PASS)\n//*\n//*****************************************************************\n//STEP9    EXEC PGM=U3511195,\n//            COND=((0,NE,STEP1),(0,NE,STEP3))\n//*****************************************************************\n//*\n//STEPLIB   DD DSN=WDPSC.SHARED.LOAD,DISP=SHR\n//SYSUDUMP  DD SYSOUT=*\n//SYSOUT    DD SYSOUT=*\n//FILEIN1   DD DSN=&&RES,DISP=(OLD,DELETE)\n//FILEIN2   DD DSN=&&BKREF,DISP=(OLD,DELETE)\n//FILEOUT   DD DSN=&&RES2,DISP=(NEW,PASS),UNIT=SYSDA,\n//             SPACE=(CYL,(5,2)),DCB=(RECFM=FB,BLKSIZE=400)\n//*\n//*****************************************************************\n//STEP10   EXEC PGM=DYL260,\n//            COND=((0,NE,STEP1),(0,NE,STEP3))\n//*****************************************************************\n//*\n//SYSPRINT  DD SYSOUT=*\n//SYS260A   DD DSN=&&RES2,DISP=(OLD,DELETE)\n//SYS260J   DD DSN=&&RESEXP,DISP=(NEW,PASS),UNIT=SYSDA,\n//             SPACE=(CYL,(&CA,2)),\n//             DCB=(LRECL=148,BLKSIZE=1480,RECFM=FB,DSORG=PS)\n//SYS260R   DD UNIT=SYSDA,DISP=(NEW,CATLG),DSN=&&XREFRPT4,\n//    SPACE=(CYL,(8,2),RLSE),\n//    DCB=(RECFM=FBM,LRECL=133,BLKSIZE=1330)\n//SYSIN DD DISP=SHR,DSN=WDPSC.MASTER.CLIST.PARMS(JCLXREF6)\n//*\n//*****************************************************************\n//STEP11   EXEC PGM=SORT,\n//            COND=((0,NE,STEP1),(0,NE,STEP3))\n//*****************************************************************\n//*\n//SYSOUT    DD SYSOUT=*\n//SORTLIB   DD DSN=SYS1.SORTLIB,DISP=SHR\n//SORTWK01  DD UNIT=SYSDA,SPACE=(CYL,&SRTWK2,,CONTIG)\n//SORTWK02  DD UNIT=SYSDA,SPACE=(CYL,&SRTWK2,,CONTIG)\n//SORTWK03  DD UNIT=SYSDA,SPACE=(CYL,&SRTWK2,,CONTIG)\n//SORTWK04  DD UNIT=SYSDA,SPACE=(CYL,&SRTWK2,,CONTIG)\n//SORTWK05  DD UNIT=SYSDA,SPACE=(CYL,&SRTWK2,,CONTIG)\n//SORTWK06  DD UNIT=SYSDA,SPACE=(CYL,&SRTWK2,,CONTIG)\n//SORTIN    DD DSN=&&RESEXP,DISP=(OLD,PASS)\n//SORTOUT   DD DSN=&&PGMSORT,DISP=(NEW,PASS),UNIT=SYSDA,\n//             SPACE=(CYL,(&CA,2)),\n//             DCB=(LRECL=148,BLKSIZE=1480,RECFM=FB)\n//SYSIN DD DISP=SHR,DSN=WDPSC.MASTER.CLIST.PARMS(JCLXREF7)\n//*\n//*****************************************************************\n//STEP12   EXEC PGM=DYL260,\n//            COND=((0,NE,STEP1),(0,NE,STEP3))\n//*****************************************************************\n//*\n//SYSPRINT  DD SYSOUT=*\n//SYS260A   DD DSN=&&PGMSORT,DISP=(OLD,DELETE)\n//SYS260R   DD UNIT=SYSDA,DISP=(NEW,CATLG),DSN=&&XREFRPT5,\n//    SPACE=(CYL,(8,2),RLSE),\n//    DCB=(RECFM=FBM,LRECL=133,BLKSIZE=1330)\n//SYSIN DD DISP=SHR,DSN=WDPSC.MASTER.CLIST.PARMS(JCLXREF8)\n//*\n//*****************************************************************\n//STEP13   EXEC PGM=SORT,\n//            COND=((0,NE,STEP1),(0,NE,STEP3))\n//*****************************************************************\n//*\n//SYSOUT    DD SYSOUT=*\n//SORTLIB   DD DSN=SYS1.SORTLIB,DISP=SHR\n//SORTWK01  DD UNIT=SYSDA,SPACE=(CYL,&SRTWK2,,CONTIG)\n//SORTWK02  DD UNIT=SYSDA,SPACE=(CYL,&SRTWK2,,CONTIG)\n//SORTWK03  DD UNIT=SYSDA,SPACE=(CYL,&SRTWK2,,CONTIG)\n//SORTWK04  DD UNIT=SYSDA,SPACE=(CYL,&SRTWK2,,CONTIG)\n//SORTWK05  DD UNIT=SYSDA,SPACE=(CYL,&SRTWK2,,CONTIG)\n//SORTWK06  DD UNIT=SYSDA,SPACE=(CYL,&SRTWK2,,CONTIG)\n//SORTIN    DD DSN=&&RESEXP,DISP=(OLD,DELETE)\n//SORTOUT   DD DSN=&&DSSORT,DISP=(NEW,PASS),UNIT=SYSDA,\n//             SPACE=(CYL,(&CA,2)),\n//             DCB=(LRECL=148,BLKSIZE=1480,RECFM=FB)\n//SYSIN DD DISP=SHR,DSN=WDPSC.MASTER.CLIST.PARMS(JCLXREF9)\n//*\n//*****************************************************************\n//STEP14   EXEC PGM=DYL260,\n//            COND=((0,NE,STEP1),(0,NE,STEP3))\n//*****************************************************************\n//*\n//SYSPRINT  DD SYSOUT=*\n//SYS260A   DD DSN=&&DSSORT,DISP=(OLD,DELETE)\n//SYS260R   DD UNIT=SYSDA,DISP=(NEW,CATLG),DSN=&&XREFRPT6,\n//    SPACE=(CYL,(8,2),RLSE),\n//    DCB=(RECFM=FBM,LRECL=133,BLKSIZE=1330)\n//SYSIN DD DISP=SHR,DSN=WDPSC.MASTER.CLIST.PARMS(JCLXRF10)\n//*\n//*****************************************************************\n//STEP15   EXEC PGM=FTL,\n//            COND=((0,NE,STEP1),(0,NE,STEP3),(&RPT2,NE,STEP00))\n//*****************************************************************\n//*\n//STEPLIB   DD DISP=SHR,DSN=WDPSC.SYSLIBRY\n//MESSAGES  DD SYSOUT=*\n//IN01      DD DSN=&&XREFRPT2,DISP=(OLD,DELETE,DELETE)\n//OUT01     DD SYSOUT=*,\n//    DCB=(RECFM=FBM,LRECL=133,BLKSIZE=1330)\n//*\n//*****************************************************************\n//STEP16   EXEC PGM=FTL,\n//            COND=((0,NE,STEP1),(0,NE,STEP3),(&RPT3,NE,STEP00))\n//*****************************************************************\n//*\n//STEPLIB   DD DISP=SHR,DSN=WDPSC.SYSLIBRY\n//MESSAGES  DD SYSOUT=*\n//IN01      DD DSN=&&XREFRPT3,DISP=(OLD,DELETE,DELETE)\n//OUT01     DD SYSOUT=*,\n//    DCB=(RECFM=FBM,LRECL=133,BLKSIZE=1330)\n//*\n//*****************************************************************\n//STEP17   EXEC PGM=FTL,\n//            COND=((0,NE,STEP1),(0,NE,STEP3),(&RPT4,NE,STEP00))\n//*****************************************************************\n//*\n//STEPLIB   DD DISP=SHR,DSN=WDPSC.SYSLIBRY\n//MESSAGES  DD SYSOUT=*\n//IN01      DD DSN=&&XREFRPT4,DISP=(OLD,DELETE,DELETE)\n//OUT01     DD SYSOUT=*,\n//    DCB=(RECFM=FBM,LRECL=133,BLKSIZE=1330)\n//*\n//*****************************************************************\n//STEP18   EXEC PGM=FTL,\n//            COND=((0,NE,STEP1),(0,NE,STEP3),(&RPT5,NE,STEP00))\n//*****************************************************************\n//*\n//STEPLIB   DD DISP=SHR,DSN=WDPSC.SYSLIBRY\n//MESSAGES  DD SYSOUT=*\n//IN01      DD DSN=&&XREFRPT5,DISP=(OLD,DELETE,DELETE)\n//OUT01     DD SYSOUT=*,\n//    DCB=(RECFM=FBM,LRECL=133,BLKSIZE=1330)\n//*\n//*****************************************************************\n//STEP19   EXEC PGM=FTL,\n//            COND=((0,NE,STEP1),(0,NE,STEP3),(&RPT6,NE,STEP00))\n//*****************************************************************\n//*\n//STEPLIB   DD DISP=SHR,DSN=WDPSC.SYSLIBRY\n//MESSAGES  DD SYSOUT=*\n//IN01      DD DSN=&&XREFRPT6,DISP=(OLD,DELETE,DELETE)\n//OUT01     DD SYSOUT=*,\n//    DCB=(RECFM=FBM,LRECL=133,BLKSIZE=1330)\n//*\n//*    E N D   O F   Z E E   P R O C\n//*\n./ ADD NAME=LOADXREF 0109-81090-87120-1335-00349-00350-00034-JS02150\n//LOADXREF PROC LIB2='CTS150.DUMMY.LOADLIB',COPIES=1,\n//     LIB3='CTS150.DUMMY.LOADLIB',\n//     LIB4='CTS150.DUMMY.LOADLIB',\n//     LIB5='CTS150.DUMMY.LOADLIB',\n//     LIB6='CTS150.DUMMY.LOADLIB',\n//     LIB7='CTS150.DUMMY.LOADLIB',\n//     LIB8='CTS150.DUMMY.LOADLIB',\n//     LIB9='CTS150.DUMMY.LOADLIB',\n//    LIB10='CTS150.DUMMY.LOADLIB',\n//    LIB11='CTS150.DUMMY.LOADLIB',\n//    LIB12='CTS150.DUMMY.LOADLIB',\n//    LIB13='CTS150.DUMMY.LOADLIB',\n//    LIB14='CTS150.DUMMY.LOADLIB',\n//    LIB15='CTS150.DUMMY.LOADLIB'\n//*\n//*\n//STEP1  EXEC PGM=AMBLIST\n//SYSPRINT  DD  UNIT=SYSDA,DISP=(NEW,PASS,DELETE),DSN=&&BLIST1,\n//   SPACE=(CYL,(50,20),RLSE),\n//   DCB=(RECFM=FB,LRECL=121,BLKSIZE=6171)\n//OURLIB  DD  DSN=&LIB1,DISP=SHR\n//SYSIN  DD  DSN=WDPSC.MASTER.CLIST.PARMS(LODXREF1),DISP=SHR\n//*      LISTLOAD OUTPUT=ALL,DDN=OURLIB\n//STEP2  EXEC  PGM=LOADEXTR\n//STEPLIB DD  DSN=WDPSC.SYSLIBRY,DISP=SHR\n//SYSOUT   DD  SYSOUT=A\n//SYSUDUMP DD  SYSOUT=A\n//INPUT  DD  DSN=&&BLIST1,DISP=(OLD,DELETE,DELETE),\n//   DCB=(RECFM=FB,LRECL=121,BLKSIZE=6171)\n//OUTPUT    DD  UNIT=SYSDA,DISP=(NEW,PASS,DELETE),DSN=&&EXTR1,\n//   SPACE=(CYL,(2,1),RLSE),\n//   DCB=(RECFM=FB,LRECL=16,BLKSIZE=6224)\n//STEP3  EXEC PGM=AMBLIST\n//SYSPRINT  DD  UNIT=SYSDA,DISP=(NEW,PASS,DELETE),DSN=&&BLIST2,\n//   SPACE=(CYL,(50,20),RLSE),\n//   DCB=(RECFM=FB,LRECL=121,BLKSIZE=6171)\n//OURLIB  DD  DSN=&LIB2,DISP=SHR\n//SYSIN  DD  DSN=WDPSC.MASTER.CLIST.PARMS(LODXREF1),DISP=SHR\n//*      LISTLOAD OUTPUT=ALL,DDN=OURLIB\n//STEP4  EXEC  PGM=LOADEXTR\n//STEPLIB DD  DSN=WDPSC.SYSLIBRY,DISP=SHR\n//SYSOUT   DD  SYSOUT=A\n//SYSUDUMP DD  SYSOUT=A\n//INPUT  DD  DSN=&&BLIST2,DISP=(OLD,DELETE,DELETE),\n//   DCB=(RECFM=FB,LRECL=121,BLKSIZE=6171)\n//OUTPUT    DD  UNIT=SYSDA,DISP=(NEW,PASS,DELETE),DSN=&&EXTR2,\n//   SPACE=(CYL,(2,1),RLSE),\n//   DCB=(RECFM=FB,LRECL=16,BLKSIZE=6224)\n//STEP5  EXEC PGM=AMBLIST\n//SYSPRINT  DD  UNIT=SYSDA,DISP=(NEW,PASS,DELETE),DSN=&&BLIST3,\n//   SPACE=(CYL,(50,20),RLSE),\n//   DCB=(RECFM=FB,LRECL=121,BLKSIZE=6171)\n//OURLIB  DD  DSN=&LIB3,DISP=SHR\n//SYSIN  DD  DSN=WDPSC.MASTER.CLIST.PARMS(LODXREF1),DISP=SHR\n//*      LISTLOAD OUTPUT=ALL,DDN=OURLIB\n//STEP6  EXEC  PGM=LOADEXTR\n//STEPLIB DD  DSN=WDPSC.SYSLIBRY,DISP=SHR\n//SYSOUT   DD  SYSOUT=A\n//SYSUDUMP DD  SYSOUT=A\n//INPUT  DD  DSN=&&BLIST3,DISP=(OLD,DELETE,DELETE),\n//   DCB=(RECFM=FB,LRECL=121,BLKSIZE=6171)\n//OUTPUT    DD  UNIT=SYSDA,DISP=(NEW,PASS,DELETE),DSN=&&EXTR3,\n//   SPACE=(CYL,(2,1),RLSE),\n//   DCB=(RECFM=FB,LRECL=16,BLKSIZE=6224)\n//STEP7  EXEC PGM=AMBLIST\n//SYSPRINT  DD  UNIT=SYSDA,DISP=(NEW,PASS,DELETE),DSN=&&BLIST4,\n//   SPACE=(CYL,(50,20),RLSE),\n//   DCB=(RECFM=FB,LRECL=121,BLKSIZE=6171)\n//OURLIB  DD  DSN=&LIB4,DISP=SHR\n//SYSIN  DD  DSN=WDPSC.MASTER.CLIST.PARMS(LODXREF1),DISP=SHR\n//*      LISTLOAD OUTPUT=ALL,DDN=OURLIB\n//STEP8  EXEC  PGM=LOADEXTR\n//STEPLIB DD  DSN=WDPSC.SYSLIBRY,DISP=SHR\n//SYSOUT   DD  SYSOUT=A\n//SYSUDUMP DD  SYSOUT=A\n//INPUT  DD  DSN=&&BLIST4,DISP=(OLD,DELETE,DELETE),\n//   DCB=(RECFM=FB,LRECL=121,BLKSIZE=6171)\n//OUTPUT    DD  UNIT=SYSDA,DISP=(NEW,PASS,DELETE),DSN=&&EXTR4,\n//   SPACE=(CYL,(2,1),RLSE),\n//   DCB=(RECFM=FB,LRECL=16,BLKSIZE=6224)\n//STEP9  EXEC PGM=AMBLIST\n//SYSPRINT  DD  UNIT=SYSDA,DISP=(NEW,PASS,DELETE),DSN=&&BLIST5,\n//   SPACE=(CYL,(50,20),RLSE),\n//   DCB=(RECFM=FB,LRECL=121,BLKSIZE=6171)\n//OURLIB  DD  DSN=&LIB5,DISP=SHR\n//SYSIN  DD  DSN=WDPSC.MASTER.CLIST.PARMS(LODXREF1),DISP=SHR\n//*      LISTLOAD OUTPUT=ALL,DDN=OURLIB\n//STEP10 EXEC  PGM=LOADEXTR\n//STEPLIB DD  DSN=WDPSC.SYSLIBRY,DISP=SHR\n//SYSOUT   DD  SYSOUT=A\n//SYSUDUMP DD  SYSOUT=A\n//INPUT  DD  DSN=&&BLIST5,DISP=(OLD,DELETE,DELETE),\n//   DCB=(RECFM=FB,LRECL=121,BLKSIZE=6171)\n//OUTPUT    DD  UNIT=SYSDA,DISP=(NEW,PASS,DELETE),DSN=&&EXTR5,\n//   SPACE=(CYL,(2,1),RLSE),\n//   DCB=(RECFM=FB,LRECL=16,BLKSIZE=6224)\n//STEP11 EXEC PGM=AMBLIST\n//SYSPRINT  DD  UNIT=SYSDA,DISP=(NEW,PASS,DELETE),DSN=&&BLIST6,\n//   SPACE=(CYL,(50,20),RLSE),\n//   DCB=(RECFM=FB,LRECL=121,BLKSIZE=6171)\n//OURLIB  DD  DSN=&LIB6,DISP=SHR\n//SYSIN  DD  DSN=WDPSC.MASTER.CLIST.PARMS(LODXREF1),DISP=SHR\n//*      LISTLOAD OUTPUT=ALL,DDN=OURLIB\n//STEP12 EXEC  PGM=LOADEXTR\n//STEPLIB DD  DSN=WDPSC.SYSLIBRY,DISP=SHR\n//SYSOUT   DD  SYSOUT=A\n//SYSUDUMP DD  SYSOUT=A\n//INPUT  DD  DSN=&&BLIST6,DISP=(OLD,DELETE,DELETE),\n//   DCB=(RECFM=FB,LRECL=121,BLKSIZE=6171)\n//OUTPUT    DD  UNIT=SYSDA,DISP=(NEW,PASS,DELETE),DSN=&&EXTR6,\n//   SPACE=(CYL,(2,1),RLSE),\n//   DCB=(RECFM=FB,LRECL=16,BLKSIZE=6224)\n//STEP13 EXEC PGM=AMBLIST\n//SYSPRINT  DD  UNIT=SYSDA,DISP=(NEW,PASS,DELETE),DSN=&&BLIST7,\n//   SPACE=(CYL,(50,20),RLSE),\n//   DCB=(RECFM=FB,LRECL=121,BLKSIZE=6171)\n//OURLIB  DD  DSN=&LIB7,DISP=SHR\n//SYSIN  DD  DSN=WDPSC.MASTER.CLIST.PARMS(LODXREF1),DISP=SHR\n//*      LISTLOAD OUTPUT=ALL,DDN=OURLIB\n//STEP14 EXEC  PGM=LOADEXTR\n//STEPLIB DD  DSN=WDPSC.SYSLIBRY,DISP=SHR\n//SYSOUT   DD  SYSOUT=A\n//SYSUDUMP DD  SYSOUT=A\n//INPUT  DD  DSN=&&BLIST7,DISP=(OLD,DELETE,DELETE),\n//   DCB=(RECFM=FB,LRECL=121,BLKSIZE=6171)\n//OUTPUT    DD  UNIT=SYSDA,DISP=(NEW,PASS,DELETE),DSN=&&EXTR7,\n//   SPACE=(CYL,(2,1),RLSE),\n//   DCB=(RECFM=FB,LRECL=16,BLKSIZE=6224)\n//STEP15 EXEC PGM=AMBLIST\n//SYSPRINT  DD  UNIT=SYSDA,DISP=(NEW,PASS,DELETE),DSN=&&BLIST8,\n//   SPACE=(CYL,(50,20),RLSE),\n//   DCB=(RECFM=FB,LRECL=121,BLKSIZE=6171)\n//OURLIB  DD  DSN=&LIB8,DISP=SHR\n//SYSIN  DD  DSN=WDPSC.MASTER.CLIST.PARMS(LODXREF1),DISP=SHR\n//*      LISTLOAD OUTPUT=ALL,DDN=OURLIB\n//STEP16 EXEC  PGM=LOADEXTR\n//STEPLIB DD  DSN=WDPSC.SYSLIBRY,DISP=SHR\n//SYSOUT   DD  SYSOUT=A\n//SYSUDUMP DD  SYSOUT=A\n//INPUT  DD  DSN=&&BLIST8,DISP=(OLD,DELETE,DELETE),\n//   DCB=(RECFM=FB,LRECL=121,BLKSIZE=6171)\n//OUTPUT    DD  UNIT=SYSDA,DISP=(NEW,PASS,DELETE),DSN=&&EXTR8,\n//   SPACE=(CYL,(2,1),RLSE),\n//   DCB=(RECFM=FB,LRECL=16,BLKSIZE=6224)\n//STEP17 EXEC PGM=AMBLIST\n//SYSPRINT  DD  UNIT=SYSDA,DISP=(NEW,PASS,DELETE),DSN=&&BLIST9,\n//   SPACE=(CYL,(50,20),RLSE),\n//   DCB=(RECFM=FB,LRECL=121,BLKSIZE=6171)\n//OURLIB  DD  DSN=&LIB9,DISP=SHR\n//SYSIN  DD  DSN=WDPSC.MASTER.CLIST.PARMS(LODXREF1),DISP=SHR\n//*      LISTLOAD OUTPUT=ALL,DDN=OURLIB\n//STEP18 EXEC  PGM=LOADEXTR\n//STEPLIB DD  DSN=WDPSC.SYSLIBRY,DISP=SHR\n//SYSOUT   DD  SYSOUT=A\n//SYSUDUMP DD  SYSOUT=A\n//INPUT  DD  DSN=&&BLIST9,DISP=(OLD,DELETE,DELETE),\n//   DCB=(RECFM=FB,LRECL=121,BLKSIZE=6171)\n//OUTPUT    DD  UNIT=SYSDA,DISP=(NEW,PASS,DELETE),DSN=&&EXTR9,\n//   SPACE=(CYL,(2,1),RLSE),\n//   DCB=(RECFM=FB,LRECL=16,BLKSIZE=6224)\n//STEP19 EXEC PGM=AMBLIST\n//SYSPRINT  DD  UNIT=SYSDA,DISP=(NEW,PASS,DELETE),DSN=&&BLIST10,\n//   SPACE=(CYL,(50,20),RLSE),\n//   DCB=(RECFM=FB,LRECL=121,BLKSIZE=6171)\n//OURLIB  DD DSN=&LIB10,DISP=SHR\n//SYSIN  DD  DSN=WDPSC.MASTER.CLIST.PARMS(LODXREF1),DISP=SHR\n//*      LISTLOAD OUTPUT=ALL,DDN=OURLIB\n//STEP20 EXEC  PGM=LOADEXTR\n//STEPLIB DD  DSN=WDPSC.SYSLIBRY,DISP=SHR\n//SYSOUT   DD  SYSOUT=A\n//SYSUDUMP DD  SYSOUT=A\n//INPUT  DD  DSN=&&BLIST10,DISP=(OLD,DELETE,DELETE),\n//   DCB=(RECFM=FB,LRECL=121,BLKSIZE=6171)\n//OUTPUT    DD  UNIT=SYSDA,DISP=(NEW,PASS,DELETE),DSN=&&EXTR10,\n//   SPACE=(CYL,(2,1),RLSE),\n//   DCB=(RECFM=FB,LRECL=16,BLKSIZE=6224)\n//STEP21 EXEC PGM=AMBLIST\n//SYSPRINT  DD  UNIT=SYSDA,DISP=(NEW,PASS,DELETE),DSN=&&BLIST11,\n//   SPACE=(CYL,(50,20),RLSE),\n//   DCB=(RECFM=FB,LRECL=121,BLKSIZE=6171)\n//OURLIB  DD DSN=&LIB11,DISP=SHR\n//SYSIN  DD  DSN=WDPSC.MASTER.CLIST.PARMS(LODXREF1),DISP=SHR\n//*      LISTLOAD OUTPUT=ALL,DDN=OURLIB\n//STEP22 EXEC  PGM=LOADEXTR\n//STEPLIB DD  DSN=WDPSC.SYSLIBRY,DISP=SHR\n//SYSOUT   DD  SYSOUT=A\n//SYSUDUMP DD  SYSOUT=A\n//INPUT  DD  DSN=&&BLIST11,DISP=(OLD,DELETE,DELETE),\n//   DCB=(RECFM=FB,LRECL=121,BLKSIZE=6171)\n//OUTPUT    DD  UNIT=SYSDA,DISP=(NEW,PASS,DELETE),DSN=&&EXTR11,\n//   SPACE=(CYL,(2,1),RLSE),\n//   DCB=(RECFM=FB,LRECL=16,BLKSIZE=6224)\n//STEP23 EXEC PGM=AMBLIST\n//SYSPRINT  DD  UNIT=SYSDA,DISP=(NEW,PASS,DELETE),DSN=&&BLIST12,\n//   SPACE=(CYL,(50,20),RLSE),\n//   DCB=(RECFM=FB,LRECL=121,BLKSIZE=6171)\n//OURLIB  DD DSN=&LIB12,DISP=SHR\n//SYSIN  DD  DSN=WDPSC.MASTER.CLIST.PARMS(LODXREF1),DISP=SHR\n//*      LISTLOAD OUTPUT=ALL,DDN=OURLIB\n//STEP24 EXEC  PGM=LOADEXTR\n//STEPLIB DD  DSN=WDPSC.SYSLIBRY,DISP=SHR\n//SYSOUT   DD  SYSOUT=A\n//SYSUDUMP DD  SYSOUT=A\n//INPUT  DD  DSN=&&BLIST12,DISP=(OLD,DELETE,DELETE),\n//   DCB=(RECFM=FB,LRECL=121,BLKSIZE=6171)\n//OUTPUT    DD  UNIT=SYSDA,DISP=(NEW,PASS,DELETE),DSN=&&EXTR12,\n//   SPACE=(CYL,(2,1),RLSE),\n//   DCB=(RECFM=FB,LRECL=16,BLKSIZE=6224)\n//STEP25 EXEC PGM=AMBLIST\n//SYSPRINT  DD  UNIT=SYSDA,DISP=(NEW,PASS,DELETE),DSN=&&BLIST13,\n//   SPACE=(CYL,(50,20),RLSE),\n//   DCB=(RECFM=FB,LRECL=121,BLKSIZE=6171)\n//OURLIB  DD DSN=&LIB13,DISP=SHR\n//SYSIN  DD  DSN=WDPSC.MASTER.CLIST.PARMS(LODXREF1),DISP=SHR\n//*      LISTLOAD OUTPUT=ALL,DDN=OURLIB\n//STEP26 EXEC  PGM=LOADEXTR\n//STEPLIB DD  DSN=WDPSC.SYSLIBRY,DISP=SHR\n//SYSOUT   DD  SYSOUT=A\n//SYSUDUMP DD  SYSOUT=A\n//INPUT  DD  DSN=&&BLIST13,DISP=(OLD,DELETE,DELETE),\n//   DCB=(RECFM=FB,LRECL=121,BLKSIZE=6171)\n//OUTPUT    DD  UNIT=SYSDA,DISP=(NEW,PASS,DELETE),DSN=&&EXTR13,\n//   SPACE=(CYL,(2,1),RLSE),\n//   DCB=(RECFM=FB,LRECL=16,BLKSIZE=6224)\n//STEP27 EXEC PGM=AMBLIST\n//SYSPRINT  DD  UNIT=SYSDA,DISP=(NEW,PASS,DELETE),DSN=&&BLIST14,\n//   SPACE=(CYL,(50,20),RLSE),\n//   DCB=(RECFM=FB,LRECL=121,BLKSIZE=6171)\n//OURLIB  DD DSN=&LIB14,DISP=SHR\n//SYSIN  DD  DSN=WDPSC.MASTER.CLIST.PARMS(LODXREF1),DISP=SHR\n//*      LISTLOAD OUTPUT=ALL,DDN=OURLIB\n//STEP28 EXEC  PGM=LOADEXTR\n//STEPLIB DD  DSN=WDPSC.SYSLIBRY,DISP=SHR\n//SYSOUT   DD  SYSOUT=A\n//SYSUDUMP DD  SYSOUT=A\n//INPUT  DD  DSN=&&BLIST14,DISP=(OLD,DELETE,DELETE),\n//   DCB=(RECFM=FB,LRECL=121,BLKSIZE=6171)\n//OUTPUT    DD  UNIT=SYSDA,DISP=(NEW,PASS,DELETE),DSN=&&EXTR14,\n//   SPACE=(CYL,(2,1),RLSE),\n//   DCB=(RECFM=FB,LRECL=16,BLKSIZE=6224)\n//STEP29 EXEC PGM=AMBLIST\n//SYSPRINT  DD  UNIT=SYSDA,DISP=(NEW,PASS,DELETE),DSN=&&BLIST15,\n//   SPACE=(CYL,(50,20),RLSE),\n//   DCB=(RECFM=FB,LRECL=121,BLKSIZE=6171)\n//OURLIB  DD DSN=&LIB15,DISP=SHR\n//SYSIN  DD  DSN=WDPSC.MASTER.CLIST.PARMS(LODXREF1),DISP=SHR\n//*      LISTLOAD OUTPUT=ALL,DDN=OURLIB\n//STEP30 EXEC  PGM=LOADEXTR\n//STEPLIB DD  DSN=WDPSC.SYSLIBRY,DISP=SHR\n//SYSOUT   DD  SYSOUT=A\n//SYSUDUMP DD  SYSOUT=A\n//INPUT  DD  DSN=&&BLIST15,DISP=(OLD,DELETE,DELETE),\n//   DCB=(RECFM=FB,LRECL=121,BLKSIZE=6171)\n//OUTPUT    DD  UNIT=SYSDA,DISP=(NEW,PASS,DELETE),DSN=&&EXTR15,\n//   SPACE=(CYL,(2,1),RLSE),\n//   DCB=(RECFM=FB,LRECL=16,BLKSIZE=6224)\n//STEP31 EXEC  PGM=SORT\n//SORTLIB  DD  DSN=SYS1.SORTLIB,DISP=SHR\n//SYSOUT   DD  SYSOUT=A\n//SORTIN DD  DSN=&&EXTR1,DISP=(OLD,DELETE,DELETE),\n//   DCB=(RECFM=FB,LRECL=16,BLKSIZE=6224)\n//       DD  DSN=&&EXTR2,DISP=(OLD,DELETE,DELETE),\n//   DCB=(RECFM=FB,LRECL=16,BLKSIZE=6224)\n//       DD  DSN=&&EXTR3,DISP=(OLD,DELETE,DELETE),\n//   DCB=(RECFM=FB,LRECL=16,BLKSIZE=6224)\n//       DD  DSN=&&EXTR4,DISP=(OLD,DELETE,DELETE),\n//   DCB=(RECFM=FB,LRECL=16,BLKSIZE=6224)\n//       DD  DSN=&&EXTR5,DISP=(OLD,DELETE,DELETE),\n//   DCB=(RECFM=FB,LRECL=16,BLKSIZE=6224)\n//       DD  DSN=&&EXTR6,DISP=(OLD,DELETE,DELETE),\n//   DCB=(RECFM=FB,LRECL=16,BLKSIZE=6224)\n//       DD  DSN=&&EXTR7,DISP=(OLD,DELETE,DELETE),\n//   DCB=(RECFM=FB,LRECL=16,BLKSIZE=6224)\n//       DD  DSN=&&EXTR8,DISP=(OLD,DELETE,DELETE),\n//   DCB=(RECFM=FB,LRECL=16,BLKSIZE=6224)\n//       DD  DSN=&&EXTR9,DISP=(OLD,DELETE,DELETE),\n//   DCB=(RECFM=FB,LRECL=16,BLKSIZE=6224)\n//       DD DSN=&&EXTR10,DISP=(OLD,DELETE,DELETE),\n//   DCB=(RECFM=FB,LRECL=16,BLKSIZE=6224)\n//       DD DSN=&&EXTR11,DISP=(OLD,DELETE,DELETE),\n//   DCB=(RECFM=FB,LRECL=16,BLKSIZE=6224)\n//       DD DSN=&&EXTR12,DISP=(OLD,DELETE,DELETE),\n//   DCB=(RECFM=FB,LRECL=16,BLKSIZE=6224)\n//       DD DSN=&&EXTR13,DISP=(OLD,DELETE,DELETE),\n//   DCB=(RECFM=FB,LRECL=16,BLKSIZE=6224)\n//       DD DSN=&&EXTR14,DISP=(OLD,DELETE,DELETE),\n//   DCB=(RECFM=FB,LRECL=16,BLKSIZE=6224)\n//       DD DSN=&&EXTR15,DISP=(OLD,DELETE,DELETE),\n//   DCB=(RECFM=FB,LRECL=16,BLKSIZE=6224)\n//SORTOUT   DD  UNIT=SYSDA,DISP=(NEW,PASS,DELETE),DSN=&&SORT1,\n//   SPACE=(CYL,(15,5),RLSE),\n//   DCB=(RECFM=FB,LRECL=16,BLKSIZE=6224)\n//SORTWK01  DD  UNIT=SYSDA,SPACE=(CYL,7,,CONTIG)\n//SORTWK02  DD  UNIT=SYSDA,SPACE=(CYL,7,,CONTIG)\n//SORTWK03  DD  UNIT=SYSDA,SPACE=(CYL,7,,CONTIG)\n//SORTWK04  DD  UNIT=SYSDA,SPACE=(CYL,7,,CONTIG)\n//SORTWK05  DD  UNIT=SYSDA,SPACE=(CYL,7,,CONTIG)\n//SORTWK06  DD  UNIT=SYSDA,SPACE=(CYL,7,,CONTIG)\n//SYSIN DD  DSN=WDPSC.MASTER.CLIST.PARMS(LODXREF2),DISP=SHR\n//*    SORT FIELDS=(1,8,CH,A,9,8,CH,A)\n//STEP32 EXEC  PGM=LOADPRNT,PARM='CALLING'\n//STEPLIB DD  DSN=WDPSC.SYSLIBRY,DISP=SHR\n//SYSOUT   DD  SYSOUT=A\n//SYSUDUMP DD  SYSOUT=A\n//EXTRACT DD DSN=&&SORT1,DISP=(OLD,PASS,DELETE),\n//   DCB=(RECFM=FB,LRECL=16,BLKSIZE=6224)\n//REPORT    DD  UNIT=SYSDA,DISP=(NEW,PASS,DELETE),DSN=&&REPT1,\n//   SPACE=(CYL,(15,5),RLSE),\n//   DCB=(RECFM=FBA,LRECL=80,BLKSIZE=6160)\n//STEP33 EXEC PGM=SHIFT90\n//STEPLIB DD  DSN=WDPSC.SYSLIBRY,DISP=SHR\n//INPUT1  DD  DSN=&&REPT1,DISP=(OLD,DELETE,DELETE),\n// DCB=(RECFM=FBA,LRECL=080,BLKSIZE=6160)\n//OUTPUT1 DD  SYSOUT=(A,,0001),CHARS=SC12,\n//   FCB=SC02,FLASH=NULL,COPIES=&COPIES,DEST=LOCAL\n//STEP34 EXEC  PGM=SORT\n//SORTLIB  DD  DSN=SYS1.SORTLIB,DISP=SHR\n//SYSOUT   DD  SYSOUT=A\n//SORTIN DD  DSN=&&SORT1,DISP=(OLD,DELETE,DELETE),\n//   DCB=(RECFM=FB,LRECL=16,BLKSIZE=6224)\n//SORTOUT   DD  UNIT=SYSDA,DISP=(NEW,PASS,DELETE),DSN=&&SORT2,\n//   SPACE=(CYL,(15,5),RLSE),\n//   DCB=(RECFM=FB,LRECL=16,BLKSIZE=6224)\n//SORTWK01  DD  UNIT=SYSDA,SPACE=(CYL,7,,CONTIG)\n//SORTWK02  DD  UNIT=SYSDA,SPACE=(CYL,7,,CONTIG)\n//SORTWK03  DD  UNIT=SYSDA,SPACE=(CYL,7,,CONTIG)\n//SORTWK04  DD  UNIT=SYSDA,SPACE=(CYL,7,,CONTIG)\n//SORTWK05  DD  UNIT=SYSDA,SPACE=(CYL,7,,CONTIG)\n//SORTWK06  DD  UNIT=SYSDA,SPACE=(CYL,7,,CONTIG)\n//SYSIN DD  DSN=WDPSC.MASTER.CLIST.PARMS(LODXREF3),DISP=SHR\n//*    SORT FIELDS=(9,8,CH,A,1,8,CH,A)\n//STEP35 EXEC  PGM=LOADPRNT,PARM='CALLED '\n//STEPLIB DD  DSN=WDPSC.SYSLIBRY,DISP=SHR\n//SYSOUT   DD  SYSOUT=A\n//SYSUDUMP DD  SYSOUT=A\n//EXTRACT DD DSN=&&SORT2,DISP=(OLD,DELETE,DELETE),\n//   DCB=(RECFM=FB,LRECL=16,BLKSIZE=6224)\n//REPORT    DD  UNIT=SYSDA,DISP=(NEW,PASS,DELETE),DSN=&&REPT2,\n//   SPACE=(CYL,(15,5),RLSE),\n//   DCB=(RECFM=FBA,LRECL=80,BLKSIZE=6160)\n//STEP36 EXEC PGM=SHIFT90\n//STEPLIB DD  DSN=WDPSC.SYSLIBRY,DISP=SHR\n//INPUT1  DD  DSN=&&REPT2,DISP=(OLD,DELETE,DELETE),\n// DCB=(RECFM=FBA,LRECL=080,BLKSIZE=6160)\n//OUTPUT1 DD  SYSOUT=(A,,0001),CHARS=SC12,\n//   FCB=SC02,FLASH=NULL,COPIES=&COPIES,DEST=LOCAL\n//*\n//*      E N D   O F   Z E E   P R O C\n//*\n./ ADD NAME=ROTATE90 0114-85275-86177-0818-00034-00032-00000-DN00150\n//ROTATE90 PROC LENGTH=079,LINES=100,INLRECL=080,LEFTMRG=,\n//             CNTRMRG=,TWO=,MERG=,TRNA=,TRNB=,EVENODD=,\n//             ERRORUN=,ASAMACH=,CH1=,CH2=,CH3=,CH4=,CH5=,CH6=,\n//             CH7=,CH8=,CH9=,CH10=,CH11=,CH12=,OUTLREC=101,\n//             CLASS='A',\n//             CHARS=ET89,FCB=F128,COPIES=1,DEPTH=1,FORMS=0001\n//STEP01  EXEC PGM=FTL,REGION=100K,PARM='02'\n//MESSAGES DD  SYSOUT=*\n//IN01     DD  DDNAME=INPUT\n//OUT01    DD  DSN=&&INPUT,DISP=(NEW,PASS),UNIT=SYSSQ,\n//             SPACE=(CYL,(2,1),RLSE)\n//IN02     DD  DDNAME=SYSIN\n//OUT02    DD  DSN=&&SYSIN,DISP=(NEW,PASS),UNIT=SYSSQ,\n//             SPACE=(TRK,1),DCB=(RECFM=FB,LRECL=80,BLKSIZE=80)\n// EXEC PGM=PARMCNVS,REGION=100K,\n// PARM=('&LENGTH,&LINES,&INLRECL,&LEFTMRG,&CNTRMRG,&TWO,&MERG',\n// '&TRNA,&TRNB,&EVENODD,&ERRORUN,&ASAMACH,&CH1,&CH2,&CH3,&CH4',\n// '&CH5,&CH6,&CH7,&CH8,&CH9,&CH10,&CH11,&CH12')\n//SYSPRINT DD  SYSOUT=*\n//SYSOUT   DD  SYSOUT=*\n//STEPLIB  DD  DSN=WDPSC.SHARED.LOAD,DISP=SHR\n//INPUT    DD  DSN=&&SYSIN,DISP=(OLD,DELETE)\n//OUTPUT   DD  DSN=&&PARM,DISP=(NEW,PASS),UNIT=SYSSQ,\n//             SPACE=(TRK,1),DCB=(RECFM=FB,LRECL=80,BLKSIZE=80)\n//STEP03  EXEC PGM=ROTATE90,REGION=100K\n//SYSOUT   DD  SYSOUT=*\n//PRINTPRM DD  SYSOUT=*\n//DATAIN   DD  DSN=&&INPUT,DISP=(OLD,DELETE)\n//PRINT38  DD  SYSOUT=(&CLASS,,&FORMS),CHARS=&CHARS,FCB=&FCB,\n//             FLASH=NULL,\n//             DCB=(LRECL=&OUTLREC,BLKSIZE=&OUTLREC,RECFM=FBA),\n//             COPIES=&COPIES,DEST=LOCAL\n//PARMIN   DD  DSN=&&PARM,DISP=(OLD,DELETE)\n//SYSIN    DD  DUMMY,DCB=LRECL=&DEPTH\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "PROGDQ#": {"ttr": 32261, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x00\\x7f\\x00\\x88\\x00\\x7f\\x12\\x00\\x00f\\x00f\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf2\\xf7\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-01-07T00:00:00", "modifydate": "1988-01-07T12:00:00", "lines": 102, "newlines": 102, "modlines": 0, "user": "FILE270"}, "text": "//GDM00150 JOB (2300,57-D),'WHITE 0677 T',CLASS=E\n/*JOBPARM  O=ADMPRINT\n//*********************************************************************\n//*   NEW GDDM   QUEUE  11/27/85   - DCW\n//*   NEW GDDMR4 QUEUE  10/07/85   - KK\n//*   NEW GDDMR3 QUEUE  11/02/83\n//*   THIS JOB IS TO FORMAT THE GDDM REQUEST QUEUES AND IS FROM:\n//*          SOFTD150.VTAM.LIB.DATA(BILDQG)\n//*SETUP            **** ATTENTION  ****\n//*MESSAGE NOTE: THE GDDM QUEUES MUST BE EMPTY BEFORE RUNNING THIS\n//*MESSAGE JOB BECAUSE IT COMPLETELY REFORMATS THE QUEUE DATASETS AND\n//*MESSAGE ANY REQUESTS OUTSTANDING WILL BE LOST! USE TSO CMD\n//*MESSAGE \"LPQ\" TO LIST THE GDDM PRINT REQUESTS.\n//*MESSAGE ADMPRT81 MUST BE STOPPED IN ORDER TO RUN THIS.\n//*MESSAGE           **** ATTENTION ****\n//*MESSAGE     YOU CAN RESTART ADMPRINT AFTER THIS JOB COMPLETES.\n//*********************************************************************\n//FTL1     EXEC PGM=FTL,REGION=1000K\n//MESSAGES   DD SYSOUT=*\n//OUT01      DD DISP=(NEW,PASS,DELETE),DSN=&PRINTERS,\n//             UNIT=SYSDA,SPACE=(TRK,(1,1),RLSE),\n//             DCB=(RECFM=FB,LRECL=80,BLKSIZE=3200)\n//IN01       DD *\n***********************************************************************\n*                                                                     *\n*              DSPRINT QUEUE SOURCE                                   *\n*                                                                     *\n*    SYNTAX:  COL 1 TO 8 LEFT ADJUSTED - NODE NAME                    *\n*             COL 9 BLANK                                             *\n*             COL 10 DSPRINT FEATURES(CHOOSE LETTER CODE BELOW)       *\n*             COL 11 BLANK                                            *\n*             COL 12 -> COMMENTS                                      *\n*                                                                     *\n*    FEATURE CODES  MACH  VFC  MAX  PLATEN PAGE     MARGIN     BUFFER *\n*                   TYPE      PAGE   WIDTH SIZE   TOP  BOTTOM     C   *\n*                            WIDTH     C    L      L     L            *\n*                              C                                      *\n*                                                                     *\n*              A    3286   NO  132     132   66     2     2      1920 *\n*              B    3286  YES  132     132   66     2     2      1920 *\n*                                                                     *\n*          C - CHARACTERS; L - LINES; VFC - VERTICAL FORMS CONTROL.   *\n***********************************************************************\nHB907    A\nHB90F    A\nHBT01    A\nHLACA    A\nHLAD6    A\nHLAD7    A\nHLAD8    A\nHL289    A\nHL4FF    A\nHL5EE    A\nH200E    A\nL130P    A\nL131P    A\nL205P    A\nL211P    A\nN4M111EP A\nN4M1201P A\nN5N2101P A\nN5T511EP A\nP22P2    A\nQ23P1    A\nQ82P1    A\nS12P1    A\nS12P2    A\nS16P1    A\nS24P2    A\nS31P1    A\nS32P1    A\nS43P1    A\nSD1P1    A\nT42P1    A\nT52P1    A\nT52P2    A\nT91P1    A\nTC1P2    A\nTC4P2    A\nU11P1    A\n//FTL2     EXEC PGM=FTL,REGION=1000K\n//MESSAGES   DD SYSOUT=*\n//IN01       DD DISP=(OLD,PASS,DELETE),DSN=&PRINTERS,\n//             UNIT=SYSDA,SPACE=(TRK,(1,1),RLSE),\n//             DCB=(RECFM=FB,LRECL=80,BLKSIZE=3200)\n//OUT01      DD SYSOUT=*\n//*******************************************************************\n//*******************************************************************\n//*      FORMAT GDDM QUEUE DATASET ON THE 3081 SYSTEM:              *\n//*******************************************************************\n//*******************************************************************\n//Q2       EXEC PGM=PROGDQUE\n//SYSUT1     DD UNIT=WORK,DISP=(NEW,DELETE),SPACE=(TRK,(1,1)),\n//             DCB=(RECFM=F,BLKSIZE=2480,LRECL=2480)\n//SYSUDUMP   DD SYSOUT=*\n//SYSIN      DD DISP=(OLD,PASS,DELETE),DSN=&PRINTERS,\n//             UNIT=SYSDA,SPACE=(TRK,(1,1),RLSE),\n//             DCB=(RECFM=FB,LRECL=80,BLKSIZE=3200)\n//*******************************************************************\n//*                          NAME OF DSPRINT/GDDM QUEUE DATASET     *\n//SYSUT2     DD DISP=OLD,DSN=USER.TSO.GDDM.PRINTQ                   *\n//*******************************************************************\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PROGDQUE": {"ttr": 32264, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x00\\x7f\\x00\\x88\\x00\\x7f\\x12\\x00\\x01\\x01\\x01\\x01\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf2\\xf7\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-01-07T00:00:00", "modifydate": "1988-01-07T12:00:00", "lines": 257, "newlines": 257, "modlines": 0, "user": "FILE270"}, "text": "PROGDQUE CSECT\n***********************************************************************\n*                                                                     *\n*   INITIALIZE FOR EXECUTION USE STANDARD MVS REGISTER CONVENTIONS    *\n*                                                                     *\n***********************************************************************\n         USING *,R12\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n         STM   R14,R12,D12(R13)\n         LR    R12,R15\n         ST    R13,SAVE+D4\n         LA    R5,SAVE\n         ST    R5,D8(R13)\n         LR    R13,R5\n         SPACE\n         CALL  RETURN\n         LTR   R15,R15\n         BNZ   STAB\n         LA    R15,1\nSTAB     ST    R15,TABSIZE\n         SPACE\n***********************************************************************\n*                                                                     *\n*   OPEN SYSIN FILE. OPEN UTILITY FILE. CHECK OPENS.                  *\n*                                                                     *\n***********************************************************************\n         OPEN  (DCB1,(INPUT))\n         LA    R2,D1\n         TM    DCB1+D48,F10\n         BNO   ABEND1               U0001 ABEND\n         OPEN  (DCB2,(OUTPUT))\n         LA    R2,D2\n         TM    DCB1+D48,F10\n         BNO   ABEND1               U0002 ABEND\n***********************************************************************\n*                                                                     *\n*   READ SYSIN AND BUILD TERMINAL TABLES(QABS). WRITE QABS TO SYSUT1. *\n*                                                                     *\n***********************************************************************\nINIT1    L     R5,C0008             POINT PAST QUEUE HEADER IN QAB\n         L     R7,TABSIZE           INDICATE NUMBER OF BLOCKS FOR QABS\n         STH   R7,QABHEAD+D2        MAKE NEXT BLOCK FIRST FREE ELEMENT\n         MVC   QBUF(L8),QABHEAD     MOVE QAB HEADER TO BUFFER.\nQUE1     GET   DCB1,INPUT           READ PRINTER NAME AND TYPE FILE\n         CLI   INPUT,C'*'           IS IT A COMMENT?\n         BE    QUE1                 YES - READ ANOTHER CARD\n         CL    R5,C2456             HAVE WE PREVIOUSLY FILLED THIS QAB?\n         BNH   QUE2                 NO - PROCEED TO BUILD ANCHOR ENTRY\n         PUT   DCB2,QBUF            WRITE THIS QAB TO SYSUT1\n         LA    R2,D3                PREPARE FOR INSUFFICIENT QAB BLOCKS\n         BCT   R7,QUE3              QAB BLOCKS LEFT? YES-INIT NEXT BLK\n         B     ABEND1               NO - U0003 ABEND\nQUE3     MVC   QBUF(L8),ZEROES      INITIALIZE NEXT QAB BLOCK\n         L     R5,C0008             POINT PAST QAB HEADER\nQUE2     LA    R6,QBUF(R5)          ADDRESS THIS ANCHOR BLOCK ENTRY\n         MVC   D0(L8,R6),INPUT      MOVE NODE NAME TO ENTRY\n         MVC   D8(L8,R6),ZEROES     INITIALIZE QUE PTRS TO ZEROES\n         LA    R2,D4                PREPARE FOR UNKNOWN FEATURES COMBO\n         LA    R1,ACODE             R1->TYPE CODE TABLE\nQ4LOOP   CLI   0(R1),X'00'          END OF TABLE?\n         BE    ABEND1               OOPS - U0004 ABEND\n         CLC   0(1,R1),INPUT+D9     IS IT CORRECT ENTRY?\n         BE    SETTYPE              YES - COPY IT TO QAB\n         LA    R1,9(,R1)            R1->NEXT TAB ENTRY\n         B     Q4LOOP               GO CHECK IT OUT\nSETTYPE  MVC   D16(L8,R6),1(R1)     MOVE FEATURES TO ENTRY\n         MVC   INPUT+D9(2),=H'3'    SET A LENGTH VALUE\n         LA    R1,=A(INPUT+D9)      R1->ADDR OF LENGTH,DATA FIELD\n         CALL  RETURN               READ PAGELEN\n         LTR   R15,R15              ANY DATA?\n         BZ    TRYWIDTH             NOPE\n         STC   R15,D16+3(,R6)       SAVE NEW PAGELEN\nTRYWIDTH MVC   INPUT+13(2),=H'3'    SET A LENGTH VALUE\n         LA    R1,=A(INPUT+13)      R1->ADDR OF LENGTH,DATA FIELD\n         CALL  RETURN               READ WIDTH\n         LTR   R15,R15              ANY DATA?\n         BZ    NOWID                NOPE\n         STC   R15,D16+2(,R6)       SAVE NEW PAGELEN\nNOWID    AL    R5,C0024             POINT TO NEXT ENTRY\n         B     QUE1                 GO READ SYSIN\n***********************************************************************\n*                                                                     *\n*   EOF ON SYSIN. CLOSE OUT QABS. FLAG LAST QAB USED AND ZERO REST.   *\n*                                                                     *\n***********************************************************************\nEND1     CL    R5,C2456             PREV ENTRY LAST IN QAB?\n         BH    END1A                YES - GO FLAG AND WRITE QAB\n         LA    R6,QBUF(R5)          ADDRESS THIS ENTRY\n         MVC   D0(L24,R6),ZEROES    ZERO ENTRY\n         AL    R5,C0024             POINT TO NEXT ENTRY\n         B     END1                 GO CHECK FOR LAST ENTRY AGAIN\nEND1A    MVI   QBUF,QABLAST         FLAG QAB AS LAST USED\nEND1B    PUT   DCB2,QBUF            WRITE QAB TO SYSUT1\n         BCT   R7,END2              IS IT LAST ALLOCATED QAB BLOCK?\n         B     QUE10                YES - GO BUILD PQE CHAINS\nEND2     SR    R5,R5                NO - POINT TO BEGINNING OF NEXT QAB\nEND2A    LA    R6,QBUF(R5)          ADDRESS QAB\n         MVC   D0(L80,R6),ZEROES    ZERO 80 BYTES OF QAB\n         CL    R5,C2400             ALL ZIPPED OUT?\n         BE    END1B                YES - WRITE QAB\n         AL    R5,C0080             INCREMENT TO NEXT 80 BYTES\n         B     END2A                GO ZIP IT\n***********************************************************************\n*                                                                     *\n*   INITIALIZE QUEUE BLOCKS FOR FREE ELEMENT CHAINS(PQE).             *\n*                                                                     *\n***********************************************************************\nQUE10    L     R4,TABSIZE           POINT TO BLOCK FOR FIRST PQE\n         L     R7,QUESIZE           NUMBER OF BLOCKS FOR PQES\n         SR    R5,R5                POINT TO FIRST PQE IN THIS BLOCK\nQUE13    LA    R6,QBUF(R5)          ADDRESS THE PQE\n         MVC   D0(L80,R6),ZEROES    ZERO THE ENTRY\n         CL    R5,C2400             IS IT THE LAST PQE IN THIS BLOCK?\n         BNE   QUE11                NO - GO POINT TO NEXT PQE THIS BLK\n         L     R6,TABSIZE           LOAD QAB SIZE\n         AL    R6,QUESIZE           ADD PQE SIZE\n         SL    R6,C0001             SUBTRACT ONE. SHOULD EQUAL LAST BLK\n         CLR   R4,R6                IS IT LAST BLOCK?\n         BNE   QUE14                NO - GO POINT TO FIRST PQE NEXT BLK\n         CL    R7,C0001             DOES PQE BLOCK COUNT CONCUR?\n         BE    QUE12                LAST PQE THIS BLOCK HAS ZERO PTRS\n         LA    R2,D5                CONFLICT ON QUEUE SIZE\n         B     ABEND1               U0005 ABEND\nQUE12    PUT   DCB2,QBUF            WRITE PQE BLOCK TO SYSUT1\n         BCT   R7,QUE13             LAST PQE BLOCK? NO CONTINUE CHAIN\n         L     R6,C2400             POINT TO LAST PQE LAST BLOCK\n         LA    R6,QBUF(R6)          ADDRESS IT\n         CLC   D0(L4,R6),ZEROES     DOES IT POINT NOWHERE?\n         BE    END3                 YES - GO COPY QUEUE\n         LA    R2,D6                BAD POINTER IN LAST PQE IN LAST BLK\n         B     ABEND1               U0006 ABEND\nQUE11    STH   R4,QBUF(R5)          STORE THIS BLK AS NEXT PQE BLK PTR\n         LR    R6,R5                SET UP TO INCREMENT PQE BYTE OFFSET\n         AL    R6,C0080             POINT TO NEXT PQE OFFSET THIS BLOCK\n         STH   R6,QBUF+D2(R5)       STORE NEXT PQE OFFSET IN THIS BLOCK\n         LR    R5,R6                INCREMENT PQE OFFSET PTR TO NEXT\n         B     QUE13                GO BUILD ANOTHER PQE\nQUE14    AL    R4,C0001             INCREMENT BLOCK POINTER\n         STH   R4,QBUF(R5)          STORE NEXT BLK IN THIS PQE BLK PTR\n         SR    R5,R5                POINT TO FIRST PQE NEXT BLOCK\n         B     QUE12                GO BUILD FIRST PQE NEXT BLOCK\n***********************************************************************\n*                                                                     *\n*   CLOSE SYSIN. CLOSE SYSUT1. REOPEN FOR INPUT. OPEN SYSUT2 OUTPUT.  *\n*                                                                     *\n***********************************************************************\nEND3     CLOSE DCB1\n         CLOSE DCB2\n         OPEN  (DCB2,(INPUT))\n         LA    R2,D7\n         TM    DCB2+D48,F10\n         BNO   ABEND1               U0007 ABEND\n         OPEN  (DCB3,(OUTPUT))\n         LA    R2,D8\n         TM    DCB3+D48,F10\n         BNO   ABEND1               U0008 ABEND\n***********************************************************************\n*                                                                     *\n*   COPY NEW QUEUE FROM UTILITY DATA SET TO THE REAL ONE.             *\n*                                                                     *\n***********************************************************************\nEND3A    GET   DCB2,QBUF            READ BLOCK FROM SYSUT1\n         PUT   DCB3,QBUF            WRITE BLOCK TO SYSUT2\n         B     END3A                GO GET ANOTHER BLOCK\n***********************************************************************\n*                                                                     *\n*   UNIVERSAL ABEND MACRO. REGISTER TWO SHOULD CONTAIN ABEND CODE.    *\n*                                                                     *\n***********************************************************************\nABEND1   ABEND (R2),DUMP            ABEND WITH DUMP\n***********************************************************************\n*                                                                     *\n*   EOF ON SYSUT1. CLOSE SYSUT1. CLOSE SYSUT2. SEE YA AROUND.         *\n*                                                                     *\n***********************************************************************\nEND4     CLOSE DCB2\n         CLOSE DCB3\n         L     R13,SAVE+D4\n         LM    R14,R12,D12(R13)\n         LA    R15,D0\n         BR    R14\nDCB1     DCB   DDNAME=SYSIN,DSORG=PS,MACRF=GM,EODAD=END1\nDCB2     DCB   DDNAME=SYSUT1,DSORG=PS,MACRF=(GM,PM),EODAD=END4\nDCB3     DCB   DDNAME=SYSUT2,DSORG=PS,MACRF=PM\nSAVE     DC    18F'0'               STANDARD SAVE AREA SET\nC0001    DC    F'1'                 BASIC BINARY ONE\nC0008    DC    F'8'                 BASIC BINARY EIGHT\nC0024    DC    F'24'                SIZE OF QAB ENTRY\nC0080    DC    F'80'                SIZE OF PQE ENTRY\nC2400    DC    F'2400'              OFFSET TO LAST PQE IN BLOCK\nC2456    DC    F'2456'              OFFSET TO LAST QAB ENTRY IN BLOCK\nTABSIZE  DC    F'1'                 NUMBER OF BLOCKS ALLOCATED FOR QAB\nQUESIZE  DC    F'4'                 NUMBER OF BLOCKS ALLOC FOR PQES\nQABHEAD  DC    X'0002000000000001'  QAB HEADER-20 SEC-START WITH REQ#1\n         SPACE\n*        TABLE OF PRINTER TYPES:\nACODE    DC    C'A'                 TYPE A\nATYPE    DC    X'0600844202028401'  3286 W/O VFC\nBCODE    DC    C'B'                 TYPE B\nBTYPE    DC    X'0600844202028402'  3286 WITH VFC\nCODE1    DC    C'1'                 TYPE 1\nTYPE1    DC    X'0600844202028401'  3286 W/O VFC\nCODE2    DC    C'2'                 TYPE 2\nTYPE2    DC    X'0600844202028402'  3286 WITH VFC\nCODE3    DC    C'3'                 TYPE 3\nTYPE3    DC    X'0600844202028403'  3790 LINE PRTR\nCODE4    DC    C'4'                 TYPE 4\nTYPE4    DC    X'0600844202028404'  3287 W/O VFC\nCODE6    DC    C'6'                 TYPE 6\nTYPE6    DC    X'0600844202028406'  3287 WITH VFC\n         DC    3XL9'00'             SOME ZAPPABLE ENTRIES\nENDTABL  DC    X'00'                END OF THE TABLE\nZEROES   DC    80X'00'              80 BYTES OF BINARY ZERO\nINPUT    DC    80C' '               SYSIN BUFFER\nQBUF     DC    2480X'00'            QUEUE BLOCK BUFFER\n*********  DISPLACEMENT EQUATES  **********\nD0       EQU   0\nD1       EQU   1\nD2       EQU   2\nD3       EQU   3\nD4       EQU   4\nD5       EQU   5\nD6       EQU   6\nD7       EQU   7\nD8       EQU   8\nD9       EQU   9\nD12      EQU   12\nD16      EQU   16\nD48      EQU   48\n*********  LENGTH EQUATES  ****************\nL4       EQU   4\nL8       EQU   8\nL24      EQU   24\nL80      EQU   80\n*********  FLAG EQUATES  ******************\nF10      EQU   16\n*********  BIT  EQUATES  ******************\nQABLAST  EQU   128\n*********  CHAR EQUATES  ******************\nAPRT     EQU   193\nBPRT     EQU   194\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "PSWSAMP": {"ttr": 32269, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x00\\x7f\\x00\\x88\\x00\\x7f\\x12\\x00\\x00k\\x00k\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf2\\xf7\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-01-07T00:00:00", "modifydate": "1988-01-07T12:00:00", "lines": 107, "newlines": 107, "modlines": 0, "user": "FILE270"}, "text": "*          DATA SET CBT932     AT LEVEL 001 AS OF 02/25/79\n* PSWSAMP           VERSION    1.0       WDPSC                          00001\n* PSWSAMP SOURCE IS IN  WDPSC.DN00150.FILE(PSWSAMP)                     00002\n*         IS THE SAMPLE TAKER FOR PACKLIST. THE TECHNIQUE IS TO MOVE    00003\n* THE TRACE TABLE TO AN OUTPUT RECORD. IT DOES NOT MATTER THAT THE      00004\n* MOVE LONG OF THE TABLE CAN BE INTERUPTED. THE VALUES TAKEN AT ANY     00005\n* POINT ARE A SAMPLE, WHETHER INTERUPTED OR NOT.                        00006\n* THE SAMPLE WILL NOT BEGIN UNLESS THE FIRST ENTRY OF THE TABLE IS      00007\n* NOW DIFFERENT THAN THE PREVIOUS SAMPLE. THE SAMPLE RATE IS            00008\n* APPROXIMATELY ONCE EVERY 2.5 SECONDS (THE FIELD HOW LONG CAN BE       00009\n* ADJUSTED).                                                            00010\n* THE TECHNIQUE FOR OVERALL SAMPLING AND END USE IS COVERED IN  THE     00011\n* PACKLIST PROGRAM .                                                    00012\n*                                                                       00013\n* PACKLIST WILL RUN FOR THE TIME INTERVAL SET WITHIN THIS PROGRAM       00014\n* AND THEN WILL AUTOMATICALLY TERMINATE.  IT CAN ALSO BE STOPPED BY     00015\n* REPLYING TO THE WTOR ISSUED.  AT TERMINATION A MESSAGE IS ISSUED      00016\n* SUPPLYING THE NAME OF THE TAPE USED TO COLLECT THE DATA.  THE TAPE    00017\n* IS NOT CATALOGED SO WRITE ITS VOLSER DOWN FOR USE IN PACKLIST WHEN    00018\n* THE OPERATOR CALLS.                                                   00019\n*                                                                       00020\n* INVOKING JCL     AVAILABLE IN 'SYS1.PROCLIB(PSWSAMP)'                 00021\n* //PSWSAMP PROC                                                        00022\n* //SAMPLE  EXEC PGM=PSWSAMP                                            00023\n* //STEPLIB DD DSN=WDPSC.SOFTLOAD,DISP=SHR                              00024\n* //TAPE DD DDNAME=IEFRDER                                              00025\n* //IEFRDER DD DSN=PSWS,UNIT=TAPE,DISP=(,KEEP),LABEL=RETPD=15           00026\n*                                                                       00027\n         PRINT OFF                                                      00028\n         MACRO                                                          00029\n         REGISTER                                                       00030\n         LCLA  &I                                                       00031\n.LOOP    ANOP                                                           00032\nR&I      EQU   &I                                                       00033\n&I       SETA  &I+1                                                     00034\n         AIF   (&I LT 16).LOOP                                          00035\n         MEND                                                           00036\n         PRINT ON                                                       00037\n         TITLE  'PACKLIST   SAMPLE ROUTINE'                             00038\nPSWSAMP CSECT                                                           00039\n         REGISTER              REGISTER EQUATES                         00040\n         SAVE   (14,12),,*     ENTRY SAVE                               00041\n         LR    R12,R15         BASE REGISTER                            00042\n         USING PSWSAMP,R12                                              00043\n         LA    R8,SAVEAREA     SAVE  AREA                               00044\n         ST    R8,8(,R13)      BACK CHAIN                               00045\n         ST    R13,4(,R8)      FORWARD CHAIN                            00046\n         LR    R13,R8                                                   00047\n         TIME  BIN             TIME CHECK                               00048\n         AL    R0,MAXTIME      MAX IS TIME TO RUN                       00049\n         ST    R0,TIME         SAVE FOR REFERENCE                       00050\n* MESSAGE TO OPERATOR SO PROGRAM CAN BE ENDED                           00051\n         WTOR  '*** PSW ACTIVITY SAMPLER, ENTER STOP TO STOP',REPLY,   X00052\n               L'REPLY,ECB,ROUTCDE=(2,11)                               00053\n* CONTROL CONSTANTS                                                     00054\n         L     R4,84           TRACE TABLE POINTER                      00055\n         LM    R4,R5,4(R4)     ENTRIES IN TRACE TABLE                   00056\n         SR    R5,R4        TRACE TABLE LENGTH IN R5                    00057\n         STH   R5,TAPE+82     LRECL                                     00058\n         STH   R5,TAPE+62     BLKSIZE                                   00059\n         GETMAIN R,LV=(R5)     WORK AREA                                00060\n         LR    R6,R1           WORK AREA                                00061\n         LR    R7,R5           LENGTH                                   00062\n         OPEN  (TAPE,(OUTPUT)) OUTPUT FILE                              00063\n         STM   R4,R7,MOVLONG   SAVE REGISTERS FOR LOADING               00064\nREWRITE  LM    R4,R7,MOVLONG   LOAD MOVE REGISTERS                      00065\n         MVCL  R6,R4           MOVE DATA FROM TRACE TABLE TO OUTPUT     00066\n         L     R6,MOVLONG+8    ADDRESS OF OUTPUT AREA                   00067\n         PUT   TAPE,(R6)       EACH COPY IS SEPARATE RECORD             00068\n         CLC   REPLY,STOP      OPERATOR STOPPING SAMPLE                 00069\n         BE    GOHOME          YES                                      00070\n         TIME  BIN             TIME CHECK                               00071\n         CL    R0,TIME         HAS MAX TIME BEEN REACHED                00072\n         BH    GOHOME          YES, THEN STOP                           00073\nWHEN     EQU   *                                                        00074\n         STIMER WAIT,MICVL=HOWLONG   WAIT A FEW SECONDS                 00075\n         CLC   28(4,R4),28(R6)       HAS ENTIRE TRACE TABLE CHANGED     00076\n         BNE   REWRITE               YES                                00077\n         B     WHEN                  NO, WAIT SOME MORE                 00078\nGOHOME   EQU   *                                                        00079\n         L     R4,TAPE+44         GET DEB POINTER                       00080\n         L     R5,32(,R4)         GET UCB ADDRESS                       00081\n         MVC   ENDWTO-6(L'VOLSER),36(R5)   SAVE THE VOLSER              00082\n         WTO   'PLEASE TELL SOFTWARE THAT PSWSAMP HAS BEEN STOPPED',  **00083\n               ROUTCDE=(2,11)                                           00084\n         LA    R1,WTOMSG                                                00085\n         WTO   MF=(E,(1))      OUTPUT VOUME SERIAL NUMBER IN WTO        00086\n         CLOSE TAPE            CLOSE THE OUTPUT FILE                    00087\n         L     R13,SAVEAREA+4                                           00088\n         LM    R14,R12,12(R13)                                          00089\n         SLR   R15,R15                                                  00090\n         BR    R14             RETURN                                   00091\nSAVEAREA DS   18F                                                       00092\nMOVLONG  DC    5F'0'                                                    00093\nMAXTIME  DC    F'90000'                                                 00094\nTIME     DC    F'0'                                                     00095\nSTOP     DC    C'STOP'                                                  00096\nWTOMSG   WTO   'AND THE VOLSER OF THE TAPE IS 000000',MF=L              00097\nENDWTO   EQU   *                                                        00098\nREPLY    DC    CL4' '                                                   00099\nVOLSER   DS    CL6                                                      00100\nECB      DC    F'0'                                                     00101\nWAITBLK  DC    F'0'                                                     00102\nHOWLONG  DS    0D                                                       00103\n         DC    X'0000000244400000'                                      00104\nTAPE     DCB   DDNAME=TAPE,DSORG=PS,MACRF=PM,RECFM=F,BUFNO=1            00105\n         END                                                            00106\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "QUICK": {"ttr": 32515, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x00\\x7f\\x00\\x88\\x00\\x7f\\x12\\x00\\x01\\xe8\\x01\\xe8\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf2\\xf7\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-01-07T00:00:00", "modifydate": "1988-01-07T12:00:00", "lines": 488, "newlines": 488, "modlines": 0, "user": "FILE270"}, "text": "*          DATA SET 761KKQUICK AT LEVEL 001 AS OF 08/30/82\n       IDENTIFICATION DIVISION.\n       PROGRAM-ID. QUICK.\n       ENVIRONMENT DIVISION.\n       INPUT-OUTPUT SECTION.\n       FILE-CONTROL.\n           SELECT FILEOUT ASSIGN UT-S-FILEOUT.\n           SELECT SCREEN  ASSIGN UT-S-SCREEN.\n           SELECT CRSADDR ASSIGN UT-S-CRSADDR.\n\n       DATA DIVISION.\n       FILE SECTION.\n       FD  FILEOUT\n           BLOCK 0\n           LABEL STANDARD.\n       01  FILEOUT-REC PIC X(80).\n\n       FD  SCREEN\n           BLOCK 0\n           LABEL STANDARD.\n       01  SCREEN-REC  PIC X(80).\n\n       FD  CRSADDR\n           BLOCK 0\n           LABEL STANDARD.\n       01  CRSADDR-REC.\n           05  FILLER        PIC XX.\n           05  CRSADDR-LOAD  PIC X(50).\n           05  FILLER        PIC X(28).\n\n       WORKING-STORAGE SECTION.\n       77  WS-SCRUFF         PIC S9(7) COMP-3 VALUE +0.\n       77  WS-SCRUFF2        PIC S9(7) COMP-3 VALUE +0.\n       77  WS-BUILD          PIC S9(7) COMP-3 VALUE +0.\n       77  WS-SCREEN         PIC S9(7) COMP-3 VALUE +0.\n       77  SAVE-ATTR         PIC XX    VALUE SPACE.\n       77  SAVE-SCRUFF2      PIC XX    VALUE SPACE.\n       77  END-OF-LINE       PIC XXX   VALUE SPACE.\n       77  DATA-FLAG         PIC X     VALUE SPACE.\n       77  WS-EOF            PIC X     VALUE SPACE.\n\n       01  SCREEN-VALUES.\n           05  VALUE-1.\n               10  V-1A PIC X(13) VALUE '         LIT1'.\n               10  V-1B PIC X     VALUE SPACE.\n               10  V-1C OCCURS 8 TIMES PIC X.\n           05  VALUE-2.\n               10  V-2A PIC X(15) VALUE '         DC   X'.\n               10  V-2B PIC X     VALUE QUOTE.\n               10  V-2C PIC XX    VALUE 'C3'.\n               10  V-2D PIC X     VALUE QUOTE.\n           05  VALUE-3.\n               10  V-3A PIC X(15) VALUE '         DC   X'.\n               10  V-3B PIC X     VALUE QUOTE.\n               10  V-3C PIC X(20) VALUE '115D7E1140403C404000'.\n               10  V-3D PIC X     VALUE QUOTE.\n           05  VALUE-4.\n               10  V-4A PIC X(15) VALUE '         DC   X'.\n               10  V-4B PIC X     VALUE QUOTE.\n               10  V-4C PIC XX    VALUE '1D'.\n               10  V-4D PIC XX    VALUE 'F8'.\n               10  V-4E PIC X     VALUE QUOTE.\n           05  VALUE-5.\n               10  V-5A PIC X(15) VALUE '         DC   C'.\n               10  V-5B PIC X     VALUE QUOTE.\n           05  VALUE-6.\n               10  V-6A PIC X(13) VALUE '         LIT2'.\n           05  CURSOR-DATA-1.\n               10  FILLER PIC X(15) VALUE '         DC   X'.\n               10  FILLER PIC X     VALUE QUOTE.\n               10  FILLER PIC XX    VALUE '13'.\n               10  FILLER PIC X     VALUE QUOTE.\n           05  CURSOR-DATA-2.\n               10  FILLER PIC X(15) VALUE '         DC   X'.\n               10  FILLER PIC X     VALUE QUOTE.\n               10  FILLER PIC XX    VALUE '11'.\n               10  CURSOR-ADDRESS   PIC XXXX        VALUE '4040'.\n               10  FILLER PIC XX    VALUE '13'.\n               10  FILLER PIC X     VALUE QUOTE.\n           05  ADDRESS-TABLE.\n               10  FILLER PIC X(15) VALUE '         DC   X'.\n               10  FILLER PIC X     VALUE QUOTE.\n               10  FILLER PIC X(6)  VALUE '114040'.\n               10  FILLER PIC X     VALUE QUOTE.\n               10  FILLER PIC X(15) VALUE '         DC   X'.\n               10  FILLER PIC X     VALUE QUOTE.\n               10  FILLER PIC X(6)  VALUE '11C150'.\n               10  FILLER PIC X     VALUE QUOTE.\n               10  FILLER PIC X(15) VALUE '         DC   X'.\n               10  FILLER PIC X     VALUE QUOTE.\n               10  FILLER PIC X(6)  VALUE '11C260'.\n               10  FILLER PIC X     VALUE QUOTE.\n               10  FILLER PIC X(15) VALUE '         DC   X'.\n               10  FILLER PIC X     VALUE QUOTE.\n               10  FILLER PIC X(6)  VALUE '11C3F0'.\n               10  FILLER PIC X     VALUE QUOTE.\n               10  FILLER PIC X(15) VALUE '         DC   X'.\n               10  FILLER PIC X     VALUE QUOTE.\n               10  FILLER PIC X(6)  VALUE '11C540'.\n               10  FILLER PIC X     VALUE QUOTE.\n               10  FILLER PIC X(15) VALUE '         DC   X'.\n               10  FILLER PIC X     VALUE QUOTE.\n               10  FILLER PIC X(6)  VALUE '11C650'.\n               10  FILLER PIC X     VALUE QUOTE.\n               10  FILLER PIC X(15) VALUE '         DC   X'.\n               10  FILLER PIC X     VALUE QUOTE.\n               10  FILLER PIC X(6)  VALUE '11C760'.\n               10  FILLER PIC X     VALUE QUOTE.\n               10  FILLER PIC X(15) VALUE '         DC   X'.\n               10  FILLER PIC X     VALUE QUOTE.\n               10  FILLER PIC X(6)  VALUE '11C8F0'.\n               10  FILLER PIC X     VALUE QUOTE.\n               10  FILLER PIC X(15) VALUE '         DC   X'.\n               10  FILLER PIC X     VALUE QUOTE.\n               10  FILLER PIC X(6)  VALUE '114A40'.\n               10  FILLER PIC X     VALUE QUOTE.\n               10  FILLER PIC X(15) VALUE '         DC   X'.\n               10  FILLER PIC X     VALUE QUOTE.\n               10  FILLER PIC X(6)  VALUE '114B50'.\n               10  FILLER PIC X     VALUE QUOTE.\n               10  FILLER PIC X(15) VALUE '         DC   X'.\n               10  FILLER PIC X     VALUE QUOTE.\n               10  FILLER PIC X(6)  VALUE '114C60'.\n               10  FILLER PIC X     VALUE QUOTE.\n               10  FILLER PIC X(15) VALUE '         DC   X'.\n               10  FILLER PIC X     VALUE QUOTE.\n               10  FILLER PIC X(6)  VALUE '114DF0'.\n               10  FILLER PIC X     VALUE QUOTE.\n               10  FILLER PIC X(15) VALUE '         DC   X'.\n               10  FILLER PIC X     VALUE QUOTE.\n               10  FILLER PIC X(6)  VALUE '114F40'.\n               10  FILLER PIC X     VALUE QUOTE.\n               10  FILLER PIC X(15) VALUE '         DC   X'.\n               10  FILLER PIC X     VALUE QUOTE.\n               10  FILLER PIC X(6)  VALUE '115050'.\n               10  FILLER PIC X     VALUE QUOTE.\n               10  FILLER PIC X(15) VALUE '         DC   X'.\n               10  FILLER PIC X     VALUE QUOTE.\n               10  FILLER PIC X(6)  VALUE '11D160'.\n               10  FILLER PIC X     VALUE QUOTE.\n               10  FILLER PIC X(15) VALUE '         DC   X'.\n               10  FILLER PIC X     VALUE QUOTE.\n               10  FILLER PIC X(6)  VALUE '11D2F0'.\n               10  FILLER PIC X     VALUE QUOTE.\n               10  FILLER PIC X(15) VALUE '         DC   X'.\n               10  FILLER PIC X     VALUE QUOTE.\n               10  FILLER PIC X(6)  VALUE '11D440'.\n               10  FILLER PIC X     VALUE QUOTE.\n               10  FILLER PIC X(15) VALUE '         DC   X'.\n               10  FILLER PIC X     VALUE QUOTE.\n               10  FILLER PIC X(6)  VALUE '11D550'.\n               10  FILLER PIC X     VALUE QUOTE.\n               10  FILLER PIC X(15) VALUE '         DC   X'.\n               10  FILLER PIC X     VALUE QUOTE.\n               10  FILLER PIC X(6)  VALUE '11D660'.\n               10  FILLER PIC X     VALUE QUOTE.\n               10  FILLER PIC X(15) VALUE '         DC   X'.\n               10  FILLER PIC X     VALUE QUOTE.\n               10  FILLER PIC X(6)  VALUE '11D7F0'.\n               10  FILLER PIC X     VALUE QUOTE.\n               10  FILLER PIC X(15) VALUE '         DC   X'.\n               10  FILLER PIC X     VALUE QUOTE.\n               10  FILLER PIC X(6)  VALUE '11D940'.\n               10  FILLER PIC X     VALUE QUOTE.\n               10  FILLER PIC X(15) VALUE '         DC   X'.\n               10  FILLER PIC X     VALUE QUOTE.\n               10  FILLER PIC X(6)  VALUE '115A50'.\n               10  FILLER PIC X     VALUE QUOTE.\n               10  FILLER PIC X(15) VALUE '         DC   X'.\n               10  FILLER PIC X     VALUE QUOTE.\n               10  FILLER PIC X(6)  VALUE '115B60'.\n               10  FILLER PIC X     VALUE QUOTE.\n               10  FILLER PIC X(15) VALUE '         DC   X'.\n               10  FILLER PIC X     VALUE QUOTE.\n               10  FILLER PIC X(6)  VALUE '115CF0'.\n               10  FILLER PIC X     VALUE QUOTE.\n           05  START-ADDRESS REDEFINES ADDRESS-TABLE.\n               10  STARTING-ADDRESS OCCURS 24 TIMES PIC X(23).\n\n       01  CRSADDR-TAB.\n           05  CRSADDR-TABLE OCCURS 24 TIMES.\n               10  CRSADDR-COLUMNS.\n                   15  CRSADDR-80 OCCURS 80 TIMES.\n                       20  FILLER        PIC X.\n                       20  CRSADDR-ENTRY PIC XXXX.\n               10  CRSADDR-LOAD-COLUMNS\n                   REDEFINES CRSADDR-COLUMNS.\n                   15  CRSADDR-LOAD-BLOCK OCCURS 8 TIMES.\n                       20  CRSADDR-LOAD-ENTRY PIC X(50).\n\n       01  BUILD-LINE.\n           05  BUILD-DATA.\n               10  FILLER PIC X(24).\n               10  BUILD-DATA-ATTR PIC XX.\n               10  FILLER PIC X(54).\n           05  BUILD-TABLE REDEFINES BUILD-DATA.\n               10  FILLER PIC X(16).\n               10  BUILD-DATA-TABLE OCCURS 64 TIMES PIC X.\n\n       01  MENU PIC X(2028).\n\n       01  PASSREC.\n           05  IOPARM     VALUE SPACES    PIC X(8).\n           05  OUTLEN PIC S9(4) COMP.\n           05  OUTBUFF.\n               10  FILLER                 PIC X(12).\n               10  OUTBUFF-TABLE OCCURS 24 TIMES.\n                   15  FILLER             PIC X(5).\n                   15  OUTBUFF-ENTRY      PIC X(79).\n           05  INLEN  PIC S9(4) COMP SYNC.\n           05  INBUFF.\n               10  AID-BYTE    PIC X.\n               10  FILLER      PIC X(2027).\n           05  RETLEN                               PIC S9(4) COMP.\n           05  SCRUF.\n               10 SCRUFF OCCURS 24 TIMES.\n                   15  SCRUFF2 OCCURS 80 TIMES PIC X.\n           05  SCRUFF3 REDEFINES SCRUF.\n               10  SCRUFF4 OCCURS 24 TIMES.\n                   15  FILLER PIC X.\n                   15  SCRUFF4-SPACE PIC X(79).\n\n       LINKAGE SECTION.\n\n       01  ARG.\n           05  ARG-LENGTH        PIC S9(4) COMP.\n           05  HIGH-PROTECT      PIC X.\n           05  LOW-PROTECT       PIC X.\n           05  HIGH-UNPROTCT     PIC X.\n           05  LOW-UNPROTCT      PIC X.\n           05  FILLER            PIC X.\n           05  CURSOR            PIC X.\n           05  SCREEN-NAME       OCCURS 8 TIMES PIC X.\n\n       PROCEDURE DIVISION USING ARG.\n\n      ***** LOGIC CONTROL *****\n\n       INIT.\n           PERFORM 050-INITIAL-PROCEDURES.\n\n       SCREEN-INPUT.\n           PERFORM 060-WRITE-SCREEN.\n           CALL 'TRNEOF' USING SCRUF.\n           IF AID-BYTE = '3' OR 'C'\n           MOVE 5 TO RETURN-CODE\n           CLOSE FILEOUT\n           STOP RUN.\n\n       PROCESS-SCRUFF.\n           MOVE +0 TO WS-SCRUFF.\n           PERFORM 070-SCAN-SCRUFF UNTIL WS-SCRUFF > +24.\n           MOVE SPACES TO BUILD-LINE.\n           PERFORM 156-SET-CURSOR-2.\n           MOVE SPACES TO BUILD-LINE.\n           MOVE VALUE-6 TO BUILD-DATA.\n           MOVE BUILD-LINE TO FILEOUT-REC.\n           WRITE FILEOUT-REC.\n\n       EOJ.\n           OPEN OUTPUT SCREEN.\n           PERFORM 041-UNLOAD-SCREEN.\n           CLOSE FILEOUT SCREEN.\n           STOP RUN.\n\n      ***** MODULES *****\n\n       041-UNLOAD-SCREEN SECTION.\n           MOVE +0 TO WS-SCRUFF.\n       041-PROCESS.\n           ADD +1 TO WS-SCRUFF.\n           IF WS-SCRUFF > +24\n                GO TO 041-EXIT.\n           MOVE SCRUFF4-SPACE (WS-SCRUFF) TO SCREEN-REC.\n           WRITE SCREEN-REC.\n           GO TO 041-PROCESS.\n       041-EXIT.\n\n       050-INITIAL-PROCEDURES SECTION.\n           OPEN OUTPUT FILEOUT INPUT SCREEN CRSADDR.\n           CALL 'SCGEN1' USING MENU.\n           MOVE MENU TO OUTBUFF.\n           PERFORM 051-LOAD-OUTBUFF.\n           MOVE +0 TO WS-SCRUFF.\n           PERFORM 053-LOAD-CRSADDR-TABLE 8 TIMES.\n           MOVE ' ' TO WS-EOF.\n           CLOSE SCREEN CRSADDR.\n       050-INITIALIZE-IOPARM.\n           MOVE 'SBXXXXXB' TO IOPARM.\n       050-INITIALIZE-LENGTH.\n           MOVE +2028 TO OUTLEN INLEN.\n       050-INITIALIZE-SCREEN.\n           MOVE SPACES TO BUILD-LINE.\n           PERFORM 180-LOAD-SCREEN-NAME 8 TIMES.\n           MOVE VALUE-1 TO BUILD-DATA.\n           MOVE BUILD-LINE TO FILEOUT-REC.\n           WRITE FILEOUT-REC.\n           MOVE SPACES TO BUILD-LINE.\n           MOVE VALUE-2 TO BUILD-DATA.\n           MOVE BUILD-LINE TO FILEOUT-REC.\n           WRITE FILEOUT-REC.\n           MOVE SPACES TO BUILD-LINE.\n           MOVE VALUE-3 TO BUILD-DATA.\n           MOVE BUILD-LINE TO FILEOUT-REC.\n           WRITE FILEOUT-REC.\n\n       051-LOAD-OUTBUFF SECTION.\n           MOVE +0 TO WS-SCRUFF.\n       051-PROCESS.\n           ADD +1 TO WS-SCRUFF.\n           IF WS-SCRUFF > +24\n                GO TO 051-EXIT.\n           READ SCREEN AT END GO TO 051-EXIT.\n           MOVE SCREEN-REC TO OUTBUFF-ENTRY (WS-SCRUFF).\n           GO TO 051-PROCESS.\n       051-EXIT.\n\n       053-LOAD-CRSADDR-TABLE SECTION.\n           ADD +1 TO WS-SCRUFF2.\n           MOVE +1 TO WS-SCRUFF.\n           PERFORM 053-LOAD-LINE 24 TIMES.\n           GO 053-EXIT.\n       053-LOAD-LINE.\n           READ CRSADDR AT END\n           GO TO 053-EXIT.\n           MOVE CRSADDR-LOAD\n           TO CRSADDR-LOAD-ENTRY (WS-SCRUFF, WS-SCRUFF2).\n           ADD +1 TO WS-SCRUFF.\n       053-EXIT.\n\n       060-WRITE-SCREEN SECTION.\n           MOVE SPACES TO INBUFF.\n           CALL 'FULLSCR3'\n           USING IOPARM OUTLEN OUTBUFF INLEN INBUFF RETLEN SCRUF.\n\n       070-SCAN-SCRUFF SECTION.\n           ADD +1 TO WS-SCRUFF.\n           IF WS-SCRUFF > +24\n           GO TO 070-EXIT.\n           IF SCRUFF4-SPACE (WS-SCRUFF) = SPACES\n           GO TO 070-EXIT.\n           PERFORM 130-SET-ADDRESS.\n           MOVE +1 TO WS-SCRUFF2.\n           MOVE +0 TO WS-BUILD.\n           PERFORM 100-LOCATE-VALUE UNTIL\n           WS-SCRUFF2 > +80 OR END-OF-LINE = 'EOL'.\n           MOVE SPACE TO END-OF-LINE.\n       070-EXIT.\n\n       100-LOCATE-VALUE SECTION.\n           ADD +1 TO WS-SCRUFF2.\n       100-PROCESS.\n           IF SCRUFF2 (WS-SCRUFF, WS-SCRUFF2) = HIGH-PROTECT\n                MOVE 'F8' TO SAVE-ATTR\n                PERFORM 120-GENERATE-LINE\n                GO TO 100-EXIT.\n           IF SCRUFF2 (WS-SCRUFF, WS-SCRUFF2) = LOW-PROTECT\n                MOVE 'F0' TO SAVE-ATTR\n                PERFORM 120-GENERATE-LINE\n                GO TO 100-EXIT.\n           IF SCRUFF2 (WS-SCRUFF, WS-SCRUFF2) = HIGH-UNPROTCT\n                MOVE 'C8' TO SAVE-ATTR\n                PERFORM 120-GENERATE-LINE\n                GO TO 100-EXIT.\n           IF SCRUFF2 (WS-SCRUFF, WS-SCRUFF2) = LOW-UNPROTCT\n                MOVE '40' TO SAVE-ATTR\n                PERFORM 120-GENERATE-LINE\n                GO TO 100-EXIT.\n           IF SCRUFF2 (WS-SCRUFF, WS-SCRUFF2) = '@'\n                MOVE SPACE TO DATA-FLAG\n                ADD +1 TO WS-BUILD\n                MOVE 'EOL' TO END-OF-LINE\n                MOVE QUOTE TO BUILD-DATA-TABLE (WS-BUILD)\n                PERFORM 140-WRITE-BUILD\n                MOVE 'F8' TO V-4D\n                MOVE VALUE-4 TO BUILD-DATA\n                PERFORM 140-WRITE-BUILD\n                GO TO 100-EXIT.\n           IF WS-SCRUFF2 > +80 AND DATA-FLAG = '1'\n                MOVE SPACE TO DATA-FLAG\n                ADD +1 TO WS-BUILD\n                MOVE QUOTE TO BUILD-DATA-TABLE (WS-BUILD)\n                PERFORM 140-WRITE-BUILD\n                GO TO 100-EXIT.\n           IF WS-SCRUFF2 > +80\n                GO TO 100-EXIT.\n           IF SCRUFF2 (WS-SCRUFF, WS-SCRUFF2) = CURSOR\n                PERFORM 125-CURSOR-MOD\n                MOVE SPACE TO SAVE-SCRUFF2\n                GO TO 100-EXIT.\n           MOVE SPACE TO SAVE-SCRUFF2.\n           ADD +1 TO WS-BUILD.\n           IF WS-BUILD > +52\n                PERFORM 160-TABLE-OVERFLOW.\n           MOVE SCRUFF2 (WS-SCRUFF, WS-SCRUFF2) TO\n           BUILD-DATA-TABLE (WS-BUILD).\n           IF SCRUFF2 (WS-SCRUFF, WS-SCRUFF2) NOT = SPACE\n           MOVE '1' TO DATA-FLAG.\n           IF SAVE-ATTR = 'C8' OR '40'\n           MOVE '1' TO DATA-FLAG.\n       100-EXIT.\n\n       125-CURSOR-MOD SECTION.\n           ADD +1 TO WS-SCRUFF2 WS-BUILD.\n           IF SCRUFF2 (WS-SCRUFF, WS-SCRUFF2) = '-' OR ' ' OR '_'\n           OR '.' OR '$' OR 'X'\n           MOVE SCRUFF2 (WS-SCRUFF, WS-SCRUFF2)\n           TO BUILD-DATA-TABLE (WS-BUILD)\n           ELSE\n           MOVE ' ' TO BUILD-DATA-TABLE (WS-BUILD).\n           SUBTRACT +1 FROM WS-SCRUFF2.\n\n       120-GENERATE-LINE SECTION.\n           MOVE SPACE TO DATA-FLAG.\n           IF SAVE-SCRUFF2 = '1'\n                PERFORM 170-DOUBLE-ATTRIBUTE\n                GO TO 120-EXIT.\n           PERFORM 150-NEW-ATTRIBUTE.\n           MOVE '1' TO SAVE-SCRUFF2.\n           MOVE VALUE-5 TO BUILD-DATA.\n       120-EXIT.\n\n       130-SET-ADDRESS SECTION.\n           MOVE STARTING-ADDRESS (WS-SCRUFF) TO BUILD-DATA.\n           PERFORM 140-WRITE-BUILD.\n           MOVE VALUE-5 TO BUILD-DATA.\n\n       140-WRITE-BUILD SECTION.\n           MOVE BUILD-LINE TO FILEOUT-REC.\n           WRITE FILEOUT-REC.\n\n       150-NEW-ATTRIBUTE SECTION.\n           IF WS-SCRUFF2 > +2\n              ADD +1 TO WS-BUILD\n              MOVE QUOTE TO BUILD-DATA-TABLE (WS-BUILD)\n              PERFORM 140-WRITE-BUILD.\n           MOVE +0 TO WS-BUILD.\n           MOVE SAVE-ATTR TO V-4D.\n           MOVE VALUE-4 TO FILEOUT-REC.\n           WRITE FILEOUT-REC.\n           ADD +1 TO WS-SCRUFF2.\n           IF SCRUFF2 (WS-SCRUFF, WS-SCRUFF2) = CURSOR\n               PERFORM 155-SET-CURSOR-1\n               SUBTRACT +1 FROM WS-SCRUFF2\n               PERFORM 200-SEARCH-CRSADDR-TABLE\n               GO TO 150-EXIT.\n           SUBTRACT +1 FROM WS-SCRUFF2.\n       150-EXIT.\n\n       155-SET-CURSOR-1 SECTION.\n           MOVE CURSOR-DATA-1 TO BUILD-DATA.\n           MOVE BUILD-LINE TO FILEOUT-REC.\n           WRITE FILEOUT-REC.\n\n       156-SET-CURSOR-2 SECTION.\n           MOVE CURSOR-DATA-2 TO BUILD-DATA.\n           MOVE BUILD-LINE TO FILEOUT-REC.\n           WRITE FILEOUT-REC.\n\n       160-TABLE-OVERFLOW SECTION.\n           MOVE QUOTE TO BUILD-DATA-TABLE (WS-BUILD).\n           PERFORM 140-WRITE-BUILD.\n           MOVE +1 TO WS-BUILD.\n           MOVE VALUE-5 TO BUILD-DATA.\n\n       170-DOUBLE-ATTRIBUTE SECTION.\n           MOVE '1' TO SAVE-SCRUFF2.\n           MOVE +0 TO WS-BUILD.\n           MOVE SAVE-ATTR TO V-4D.\n           MOVE VALUE-4 TO BUILD-DATA.\n           MOVE BUILD-LINE TO FILEOUT-REC.\n           WRITE FILEOUT-REC.\n           MOVE VALUE-5 TO BUILD-DATA.\n\n       180-LOAD-SCREEN-NAME SECTION.\n           ADD +1 TO WS-SCREEN.\n           IF SCREEN-NAME (WS-SCREEN) NUMERIC\n                MOVE SCREEN-NAME (WS-SCREEN) TO V-1C (WS-SCREEN)\n                GO TO 100-EXIT.\n           IF SCREEN-NAME (WS-SCREEN) ALPHABETIC\n                MOVE SCREEN-NAME (WS-SCREEN) TO V-1C (WS-SCREEN)\n                GO TO 100-EXIT.\n           MOVE SPACES TO V-1C (WS-SCREEN).\n       100-EXIT.\n\n       200-SEARCH-CRSADDR-TABLE SECTION.\n           MOVE CRSADDR-ENTRY (WS-SCRUFF, WS-SCRUFF2)\n           TO CURSOR-ADDRESS.\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "REDIST": {"ttr": 32523, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x00\\x7f\\x00\\x88\\x00\\x7f\\x12\\x00\\x00\\xb2\\x00\\xb2\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf2\\xf7\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-01-07T00:00:00", "modifydate": "1988-01-07T12:00:00", "lines": 178, "newlines": 178, "modlines": 0, "user": "FILE270"}, "text": "//KKR00155 JOB (2100,56-D),'KISER 2215 T',CLASS=H,\n// MSGCLASS=T ,TYPRUN=HOLD\n//JOBCAT DD DISP=SHR,DSN=SYS1.SOFTCAT\n//*\n//*  JOB FROM WDPSC.EXPORT.ALLOFEM(REDIST)\n//*\n//* THIS JOB REBUILDS THE MACLIB,CLIST LIB, ETC FROM THE MEMBERS\n//*  CONTAINING IEBUPDTE FORMAT DATA. IT RESTORES THE SPF STATS\n//*  WHEN RELOADING THEM. IF PDSLOAD FROM THE SHARE TAPE IS NOT\n//*  AVAILABLE, USE JOB REDISTI WHICH USES IEBUPDTE.\n//*\n//*\n//*  ************************************************************\n//*  *                                                          *\n//*  *  CHANGE DSNS OF WDPSC.IMPORT.ALLOFEM                     *\n//*  *                 WDPSC.IMPORT.MACLIB                      *\n//*  *                 WDPSC.IMPORT.CLISTS                      *\n//*  *                 WDPSC.IMPORT.PROCLIB                     *\n//*  *                 WDPSC.IMPORT.PARMLIB                     *\n//*  *                 WDPSC.IMPORT.PANELS                      *\n//*  *                 WDPSC.IMPORT.SKELS                       *\n//*  *                 WDPSC.IMPORT.MSGS                        *\n//*  *                 WDPSC.IMPORT.DOCS                        *\n//*  *                 WDPSC.IMPORT.INDEXES                     *\n//*  *                 WDPSC.IMPORT.CONTROL                     *\n//*  *                 WDPSC.IMPORT.JAN86                       *\n//*  *                                                          *\n//*  *      TO APPROPRIATE STANDARDS FOR THE INSTALLATION       *\n//*  *                                                          *\n//*  * CHANGE STOR01 TO YOUR VOLSER                             *\n//*  *                                                          *\n//*  ************************************************************\n//*\n//PDSLOAD1 EXEC PGM=PDSLOAD\n//*\n//SYSPRINT DD SYSOUT=*\n//SYSUT1 DD DISP=SHR,DSN=WDPSC.IMPORT.ALLOFEM(MACLIB)\n//SYSUT2 DD DISP=(NEW,CATLG),DSN=WDPSC.IMPORT.MACLIB,\n// UNIT=SYSALLDA,SPACE=(TRK,(5,3,20),RLSE),\n// VOL=SER=STOR01,\n// DCB=(RECFM=FB,LRECL=80,BLKSIZE=12960)\n//SYSIN  DD DUMMY\n//*\n//PDSLOAD2 EXEC PGM=PDSLOAD\n//*\n//SYSPRINT DD SYSOUT=*\n//SYSUT1 DD DISP=SHR,DSN=WDPSC.IMPORT.ALLOFEM(CLISTS)\n//SYSUT2 DD DISP=(NEW,CATLG),DSN=WDPSC.IMPORT.CLISTS,\n// UNIT=SYSALLDA,SPACE=(TRK,(5,3,20),RLSE),\n// VOL=SER=STOR01,\n// DCB=(RECFM=FB,LRECL=80,BLKSIZE=12960)\n//*****************************************************************\n//* ***NOTE*** ABOVE BLOCKSIZE IS IMPORTANT BECAUSE OF GENA STEP  *\n//*****************************************************************\n//SYSIN  DD DUMMY\n//*\n//PDSLOAD3 EXEC PGM=PDSLOAD\n//*\n//SYSPRINT DD SYSOUT=*\n//SYSUT1 DD DISP=SHR,DSN=WDPSC.IMPORT.ALLOFEM(PROCLIB)\n//SYSUT2 DD DISP=(NEW,CATLG),DSN=WDPSC.IMPORT.PROCLIB,\n// UNIT=SYSALLDA,SPACE=(TRK,(5,3,20),RLSE),\n// VOL=SER=STOR01,\n// DCB=(RECFM=FB,LRECL=80,BLKSIZE=12960)\n//SYSIN  DD DUMMY\n//*\n//PDSLOAD4 EXEC PGM=PDSLOAD\n//*\n//SYSPRINT DD SYSOUT=*\n//SYSUT1 DD DISP=SHR,DSN=WDPSC.IMPORT.ALLOFEM(PARMLIB)\n//SYSUT2 DD DISP=(NEW,CATLG),DSN=WDPSC.IMPORT.PARMLIB,\n// UNIT=SYSALLDA,SPACE=(TRK,(5,3,20),RLSE),\n// VOL=SER=STOR01,\n// DCB=(RECFM=FB,LRECL=80,BLKSIZE=12960)\n//SYSIN  DD DUMMY\n//*\n//*\n//PDSLOAD5 EXEC PGM=PDSLOAD\n//*\n//SYSPRINT DD SYSOUT=*\n//SYSUT1 DD DISP=SHR,DSN=WDPSC.IMPORT.ALLOFEM(PANELS)\n//SYSUT2 DD DISP=(NEW,CATLG),DSN=WDPSC.IMPORT.PANELS,\n// UNIT=SYSALLDA,SPACE=(TRK,(5,3,20),RLSE),\n// VOL=SER=STOR01,\n// DCB=(RECFM=FB,LRECL=80,BLKSIZE=12960)\n//SYSIN  DD DUMMY\n//*\n//*\n//PDSLOAD6 EXEC PGM=PDSLOAD\n//*\n//SYSPRINT DD SYSOUT=*\n//SYSUT1 DD DISP=SHR,DSN=WDPSC.IMPORT.ALLOFEM(SKELS)\n//SYSUT2 DD DISP=(NEW,CATLG),DSN=WDPSC.IMPORT.SKELS,\n// UNIT=SYSALLDA,SPACE=(TRK,(5,3,20),RLSE),\n// VOL=SER=STOR01,\n// DCB=(RECFM=FB,LRECL=80,BLKSIZE=12960)\n//SYSIN  DD DUMMY\n//*\n//*\n//PDSLOAD7 EXEC PGM=PDSLOAD\n//*\n//SYSPRINT DD SYSOUT=*\n//SYSUT1 DD DISP=SHR,DSN=WDPSC.IMPORT.ALLOFEM(MSGS)\n//SYSUT2 DD DISP=(NEW,CATLG),DSN=WDPSC.IMPORT.MSGS,\n// UNIT=SYSALLDA,SPACE=(TRK,(5,3,20),RLSE),\n// VOL=SER=STOR01,\n// DCB=(RECFM=FB,LRECL=80,BLKSIZE=12960)\n//SYSIN  DD DUMMY\n//*\n//PDSLOAD8 EXEC PGM=PDSLOAD\n//*\n//SYSPRINT DD SYSOUT=*\n//SYSUT1 DD DISP=SHR,DSN=WDPSC.IMPORT.ALLOFEM(DOCLIB)\n//SYSUT2 DD DISP=(NEW,CATLG),DSN=WDPSC.IMPORT.DOCS,\n// UNIT=SYSALLDA,SPACE=(TRK,(5,3,20),RLSE),\n// VOL=SER=STOR01,\n// DCB=(RECFM=FB,LRECL=80,BLKSIZE=12960)\n//SYSIN  DD DUMMY\n//*\n//PDSLOAD9 EXEC PGM=PDSLOAD\n//*\n//SYSPRINT DD SYSOUT=*\n//SYSUT1 DD DISP=SHR,DSN=WDPSC.IMPORT.ALLOFEM(INDEXES)\n//SYSUT2 DD DISP=(NEW,CATLG),DSN=WDPSC.IMPORT.INDEXES,\n// UNIT=SYSALLDA,SPACE=(TRK,(5,3,20),RLSE),\n// VOL=SER=STOR01,\n// DCB=(RECFM=FB,LRECL=80,BLKSIZE=12960)\n//*****************************************************************\n//* ***NOTE*** ABOVE BLOCKSIZE IS IMPORTANT BECAUSE OF GENB STEP  *\n//*****************************************************************\n//SYSIN  DD DUMMY\n//*\n//PDSLOADA EXEC PGM=PDSLOAD\n//*\n//SYSPRINT DD SYSOUT=*\n//SYSUT1 DD DISP=SHR,DSN=WDPSC.IMPORT.ALLOFEM(CONTROL)\n//SYSUT2 DD DISP=(NEW,CATLG),DSN=WDPSC.IMPORT.CONTROL,\n// UNIT=SYSALLDA,SPACE=(TRK,(5,3,20),RLSE),\n// VOL=SER=STOR01,\n// DCB=(RECFM=FB,LRECL=80,BLKSIZE=12960)\n//SYSIN  DD DUMMY\n//*\n//PDSLOADB EXEC PGM=PDSLOAD\n//*\n//SYSPRINT DD SYSOUT=*\n//SYSUT1 DD DISP=SHR,DSN=WDPSC.IMPORT.ALLOFEM(JAN86)\n//SYSUT2 DD DISP=(NEW,CATLG),DSN=WDPSC.IMPORT.JAN86,\n// UNIT=SYSALLDA,SPACE=(TRK,(5,3,20),RLSE),\n// VOL=SER=STOR01,\n// DCB=(RECFM=FB,LRECL=80,BLKSIZE=12960)\n//SYSIN  DD DUMMY\n//*\n//* THE GENA STEP CHANGES THE LRECL ON THE CLIST LIB TO 240.\n//*  IT SHOULD THEN BE COPIED TO A RECFM=VB,LRECL=255 DATASET\n//*  VIA SPF 3.3 BEFORE MEMBERS WITH LINE NUMBERS IN 1-8 WILL\n//*  BE ABLE TO EXECUTE PROPERLY\n//*\n//GENA EXEC PGM=IEBGENER\n//*\n//SYSPRINT DD SYSOUT=*\n//SYSUT2 DD DISP=MOD,DSN=WDPSC.IMPORT.CLISTS(DUMMY),\n//          DCB=(RECFM=FB,LRECL=240,BLKSIZE=12960)\n//SYSUT1 DD DISP=SHR,DSN=WDPSC.IMPORT.ALLOFEM(DUMMY),\n//          DCB=(RECFM=FB,LRECL=240,BLKSIZE=240)\n//SYSIN  DD DUMMY\n//*\n//* THE GENB STEP CHANGES THE LRECL ON THE INDEXES LIB TO 240.\n//*  IT SHOULD THEN BE COPIED TO A RECFM=FB,LRECL=200 DATASET\n//*  VIA SPF 3.3 BEFORE THE TBLHNDLR PROGRAM WILL ACCEPT IT.\n//*\n//GENB EXEC PGM=IEBGENER\n//*\n//SYSPRINT DD SYSOUT=*\n//SYSUT2 DD DISP=MOD,DSN=WDPSC.IMPORT.INDEXES(DUMMY),\n//          DCB=(RECFM=FB,LRECL=240,BLKSIZE=12960)\n//SYSUT1 DD DISP=SHR,DSN=WDPSC.IMPORT.ALLOFEM(DUMMY),\n//          DCB=(RECFM=FB,LRECL=240,BLKSIZE=240)\n//SYSIN  DD DUMMY\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "REDISTI": {"ttr": 32772, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x00\\x7f\\x00\\x88\\x00\\x7f\\x12\\x00\\x00\\xa9\\x00\\xa9\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf2\\xf7\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-01-07T00:00:00", "modifydate": "1988-01-07T12:00:00", "lines": 169, "newlines": 169, "modlines": 0, "user": "FILE270"}, "text": "//KKC00150 JOB (2100,56-D),'KISER 2215 T',CLASS=H,MSGCLASS=T\n/*JOBPARM L=200\n//JOBCAT DD DISP=SHR,DSN=SYS1.SOFTCAT\n//*\n//*  THIS JOB REBUILDS THE MACLIB,CLIST LIB, ETC FROM THE MEMBERS\n//*  CONTAINING IEBUPDTE FORMAT DATA. IT\n//*  DOES NOT RESTORE THE SPF STATS\n//*  WHEN RELOADING THEM. IF PDSLOAD FROM THE SHARE TAPE IS\n//*  AVAILABLE, USE JOB REDIST WHICH USES THAT PROGRAM.\n//*\n//*  ************************************************************\n//*  *                                                          *\n//*  *  CHANGE DSNS OF WDPSC.IMPORT.ALLOFEM                     *\n//*  *                 WDPSC.IMPORT.MACLIB                      *\n//*  *                 WDPSC.IMPORT.CLISTS                      *\n//*  *                 WDPSC.IMPORT.PROCLIB                     *\n//*  *                 WDPSC.IMPORT.PARMLIB                     *\n//*  *                 WDPSC.IMPORT.PANELS                      *\n//*  *                 WDPSC.IMPORT.SKELS                       *\n//*  *                 WDPSC.IMPORT.MSGS                        *\n//*  *                 WDPSC.IMPORT.DOCS                        *\n//*  *                 WDPSC.IMPORT.INDEXES                     *\n//*  *                 WDPSC.IMPORT.CONTROL                     *\n//*  *                 WDPSC.IMPORT.JAN86                       *\n//*  *                                                          *\n//*  *      TO APPROPRIATE STANDARDS FOR THE INSTALLATION       *\n//*  *                                                          *\n//*  *  CHANGE STOR01 TO YOUR VOLSER                            *\n//*  *                                                          *\n//*  ************************************************************\n//*\n//*\n//PDSLOAD1 EXEC PGM=IEBUPDTE,PARM=NEW\n//*\n//SYSPRINT DD SYSOUT=*\n//SYSIN DD DISP=SHR,DSN=WDPSC.IMPORT.ALLOFEM(MACLIB)\n//SYSUT2 DD DISP=(NEW,CATLG),DSN=WDPSC.IMPORT.MACLIB,\n// UNIT=SYSALLDA,SPACE=(TRK,(5,3,20),RLSE),\n// VOL=SER=STOR01,\n// DCB=(RECFM=FB,LRECL=80,BLKSIZE=12960)\n//*\n//PDSLOAD2 EXEC PGM=IEBUPDTE,PARM=NEW\n//*\n//SYSPRINT DD SYSOUT=*\n//SYSIN DD DISP=SHR,DSN=WDPSC.IMPORT.ALLOFEM(CLISTS)\n//SYSUT2 DD DISP=(NEW,CATLG),DSN=WDPSC.IMPORT.CLISTS,\n// UNIT=SYSALLDA,SPACE=(TRK,(5,3,20),RLSE),\n// VOL=SER=STOR01,\n// DCB=(RECFM=FB,LRECL=80,BLKSIZE=12960)\n//*****************************************************************\n//* ***NOTE*** ABOVE BLOCKSIZE IS IMPORTANT BECAUSE OF GENA STEP  *\n//*****************************************************************\n//*\n//PDSLOAD3 EXEC PGM=IEBUPDTE,PARM=NEW\n//*\n//SYSPRINT DD SYSOUT=*\n//SYSIN DD DISP=SHR,DSN=WDPSC.IMPORT.ALLOFEM(PROCLIB)\n//SYSUT2 DD DISP=(NEW,CATLG),DSN=WDPSC.IMPORT.PROCLIB,\n// UNIT=SYSALLDA,SPACE=(TRK,(5,3,20),RLSE),\n// VOL=SER=STOR01,\n// DCB=(RECFM=FB,LRECL=80,BLKSIZE=12960)\n//*\n//PDSLOAD4 EXEC PGM=IEBUPDTE,PARM=NEW\n//*\n//SYSPRINT DD SYSOUT=*\n//SYSIN DD DISP=SHR,DSN=WDPSC.IMPORT.ALLOFEM(PARMLIB)\n//SYSUT2 DD DISP=(NEW,CATLG),DSN=WDPSC.IMPORT.PARMLIB,\n// UNIT=SYSALLDA,SPACE=(TRK,(5,3,20),RLSE),\n// VOL=SER=STOR01,\n// DCB=(RECFM=FB,LRECL=80,BLKSIZE=12960)\n//*\n//*\n//PDSLOAD5 EXEC PGM=IEBUPDTE,PARM=NEW\n//*\n//SYSPRINT DD SYSOUT=*\n//SYSIN DD DISP=SHR,DSN=WDPSC.IMPORT.ALLOFEM(PANELS)\n//SYSUT2 DD DISP=(NEW,CATLG),DSN=WDPSC.IMPORT.PANELS,\n// UNIT=SYSALLDA,SPACE=(TRK,(5,3,20),RLSE),\n// VOL=SER=STOR01,\n// DCB=(RECFM=FB,LRECL=80,BLKSIZE=12960)\n//*\n//*\n//PDSLOAD6 EXEC PGM=IEBUPDTE,PARM=NEW\n//*\n//SYSPRINT DD SYSOUT=*\n//SYSIN DD DISP=SHR,DSN=WDPSC.IMPORT.ALLOFEM(SKELS)\n//SYSUT2 DD DISP=(NEW,CATLG),DSN=WDPSC.IMPORT.SKELS,\n// UNIT=SYSALLDA,SPACE=(TRK,(5,3,20),RLSE),\n// VOL=SER=STOR01,\n// DCB=(RECFM=FB,LRECL=80,BLKSIZE=12960)\n//*\n//*\n//PDSLOAD7 EXEC PGM=IEBUPDTE,PARM=NEW\n//*\n//SYSPRINT DD SYSOUT=*\n//SYSIN DD DISP=SHR,DSN=WDPSC.IMPORT.ALLOFEM(MSGS)\n//SYSUT2 DD DISP=(NEW,CATLG),DSN=WDPSC.IMPORT.MSGS,\n// UNIT=SYSALLDA,SPACE=(TRK,(5,3,20),RLSE),\n// VOL=SER=STOR01,\n// DCB=(RECFM=FB,LRECL=80,BLKSIZE=12960)\n//*\n//PDSLOAD8 EXEC PGM=IEBUPDTE,PARM=NEW\n//*\n//SYSPRINT DD SYSOUT=*\n//SYSIN DD DISP=SHR,DSN=WDPSC.IMPORT.ALLOFEM(DOCLIB)\n//SYSUT2 DD DISP=(NEW,CATLG),DSN=WDPSC.IMPORT.DOCS,\n// UNIT=SYSALLDA,SPACE=(TRK,(5,3,20),RLSE),\n// VOL=SER=STOR01,\n// DCB=(RECFM=FB,LRECL=80,BLKSIZE=12960)\n//*\n//*\n//PDSLOAD9 EXEC PGM=IEBUPDTE,PARM=NEW\n//*\n//SYSPRINT DD SYSOUT=*\n//SYSIN DD DISP=SHR,DSN=WDPSC.IMPORT.ALLOFEM(INDEXES)\n//SYSUT2 DD DISP=(NEW,CATLG),DSN=WDPSC.IMPORT.INDEXES,\n// UNIT=SYSALLDA,SPACE=(TRK,(5,3,20),RLSE),\n// VOL=SER=STOR01,\n// DCB=(RECFM=FB,LRECL=80,BLKSIZE=12960)\n//*****************************************************************\n//* ***NOTE*** ABOVE BLOCKSIZE IS IMPORTANT BECAUSE OF GENB STEP  *\n//*****************************************************************\n//*\n//*\n//PDSLOADA EXEC PGM=IEBUPDTE,PARM=NEW\n//*\n//SYSPRINT DD SYSOUT=*\n//SYSIN DD DISP=SHR,DSN=WDPSC.IMPORT.ALLOFEM(CONTROL)\n//SYSUT2 DD DISP=(NEW,CATLG),DSN=WDPSC.IMPORT.CONTROL,\n// UNIT=SYSALLDA,SPACE=(TRK,(5,3,20),RLSE),\n// VOL=SER=STOR01,\n// DCB=(RECFM=FB,LRECL=80,BLKSIZE=12960)\n//*\n//*\n//PDSLOADB EXEC PGM=IEBUPDTE,PARM=NEW\n//*\n//SYSPRINT DD SYSOUT=*\n//SYSIN DD DISP=SHR,DSN=WDPSC.IMPORT.ALLOFEM(JAN86)\n//SYSUT2 DD DISP=(NEW,CATLG),DSN=WDPSC.IMPORT.JAN86,\n// UNIT=SYSALLDA,SPACE=(TRK,(5,3,20),RLSE),\n// VOL=SER=STOR01,\n// DCB=(RECFM=FB,LRECL=80,BLKSIZE=12960)\n//*\n//* THE GENA STEP CHANGES THE LRECL ON THE CLIST LIB TO 240.\n//*  IT SHOULD THEN BE COPIED TO A RECFM=VB,LRECL=255 DATASET\n//*  VIA SPF 3.3 BEFORE MEMBERS WITH LINE NUMBERS IN 1-8 WILL\n//*  BE ABLE TO EXECUTE PROPERLY\n//*\n//GENA EXEC PGM=IEBGENER\n//*\n//SYSPRINT DD SYSOUT=*\n//SYSUT2 DD DISP=MOD,DSN=WDPSC.IMPORT.CLISTS(DUMMY),\n//          DCB=(RECFM=FB,LRECL=240,BLKSIZE=12960)\n//SYSUT1 DD DISP=SHR,DSN=WDPSC.IMPORT.ALLOFEM(DUMMY),\n//          DCB=(RECFM=FB,LRECL=240,BLKSIZE=240)\n//SYSIN  DD DUMMY\n//*\n//* THE GENB STEP CHANGES THE LRECL ON THE INDEXES LIB TO 240.\n//*  IT SHOULD THEN BE COPIED TO A RECFM=FB,LRECL=200 DATASET\n//*  VIA SPF 3.3 BEFORE THE TBLHNDLR PROGRAM WILL ACCEPT IT.\n//*\n//GENB EXEC PGM=IEBGENER\n//*\n//SYSPRINT DD SYSOUT=*\n//SYSUT2 DD DISP=MOD,DSN=WDPSC.IMPORT.INDEXES(DUMMY),\n//          DCB=(RECFM=FB,LRECL=240,BLKSIZE=12960)\n//SYSUT1 DD DISP=SHR,DSN=WDPSC.IMPORT.ALLOFEM(DUMMY),\n//          DCB=(RECFM=FB,LRECL=240,BLKSIZE=240)\n//SYSIN  DD DUMMY\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "RELSEQ": {"ttr": 32776, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x00\\x7f\\x00\\x88\\x00\\x7f\\x12\\x00\\x00)\\x00)\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf2\\xf7\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-01-07T00:00:00", "modifydate": "1988-01-07T12:00:00", "lines": 41, "newlines": 41, "modlines": 0, "user": "FILE270"}, "text": "*          DATA SET 761KKRELSQ AT LEVEL 001 AS OF 08/30/82\n*              MODIFIED RELSEQ -  11/02/81 - WDPSC\nRELSEQ   CSECT\n         PRINT GEN\n         USING *,12\n         LR    12,15\n         RDJFCB (REL)\n         TM    JFCB+87,X'80'\n         BC    1,OBTAIN\n         WTL   'DISP MUST BE MOD',\n         LA    15,99\n         BR    14\n         SPACE\nOBTAIN   OBTAIN SRCHLIST          GET THE DSCB1\n         LTR   15,15              OK?\n         BZ    GETBND             YES\n         WTL   'DSCB NOT FOUND'\n         LA    15,77\n         BR    14\nGETBND   NI    DSCB+94,X'C0'      NEED 2 BITS\n         NI    JFCB+155,X'3F'     \"\n         OC    JFCB+155(1),DSCB+94  MERGE EM\n         SPACE\nO        OPEN  (REL,OUTPUT),TYPE=J\n         CLOSE REL\n         LA    15,0\n         BR    14\n         EJECT\nREL      DCB   DSORG=PS,DDNAME=REL,MACRF=(W),EXLST=AJ\n         EJECT\nAJ       DS    0F\n         DC    X'87'\n         DC    AL3(JFCB)\n         SPACE\nJFCB     DS    CL176\n         SPACE\nDSCB     DS    XL140\n         SPACE\nSRCHLIST CAMLST SEARCH,JFCB,JFCB+118,DSCB\n         SPACE\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "REPROEN#": {"ttr": 32778, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x00\\x7f\\x00\\x88\\x00\\x7f\\x12\\x00\\x00\"\\x00\"\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf2\\xf7\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-01-07T00:00:00", "modifydate": "1988-01-07T12:00:00", "lines": 34, "newlines": 34, "modlines": 0, "user": "FILE270"}, "text": "//REP00150 JOB (2100,56-D),'DZEIG 0684 T',CLASS=C,TYPRUN=HOLD\n//*\n//*R THIS JOB IS TO BACKUP THE VSAM MASTER CATALOGS FOR S23 AND F06\n/*SETUP      REP00150,2100-56-D,C800K,01\n/*MESSAGE ZEIGLER DE,3-0684,00.10,PD,WDPSC\n/*MESSAGE H.IDCAMS,BACKUP.SYS1.G29MCAT -      -T-O-4-LIB\n/*MESSAGE H.IDCAMS,BACKUP.SYS1.K15MCAT -      -T-O-4-LIB\n/*MESSAGE\n/*MESSAGE  REP00150 AND REQ00150 CAN RUN AT THE SAME\n/*MESSAGE  TIME.\n//*\n//* JOB IS FROM RESOLVE.LIB(REP00150)\n//A EXEC PGM=REPROENQ,REGION=1000K\n//STEPLIB DD DSN=WDPSC.PROGLIB,DISP=SHR\n//STEPCAT DD DSN=SYS1.G29MCAT,DISP=SHR\n//SYSPRINT DD SYSOUT=A\n//SYSUDUMP DD SYSOUT=A\n//ABNLDUMP  DD DUMMY\n//CATIN DD DSN=SYS1.G29MCAT,DISP=SHR,AMP='BUFND=54,BUFNI=2'\n//CATOUT DD  DSN=BACKUP.SYS1.G29MCAT,LABEL=RETPD=5,DISP=(,KEEP),\n// UNIT=TAPE16,DCB=(BUFNO=40,RECFM=VB,LRECL=516,BLKSIZE=15480)\n   REPRO    INFILE(CATIN/PLENARY)    OUTFILE(CATOUT)\n//B EXEC PGM=REPROENQ,REGION=1000K\n//STEPLIB DD DSN=WDPSC.PROGLIB,DISP=SHR\n//STEPCAT DD DSN=SYS1.K15MCAT,DISP=SHR\n//SYSPRINT DD SYSOUT=A\n//SYSUDUMP DD SYSOUT=A\n//ABNLDUMP  DD DUMMY\n//CATIN DD DSN=SYS1.K15MCAT,DISP=SHR,AMP='BUFND=54,BUFNI=2'\n//CATOUT DD  DSN=BACKUP.SYS1.K15MCAT,LABEL=(2,RETPD=5),DISP=(,KEEP),\n// UNIT=TAPE16,DCB=(BUFNO=40,RECFM=VB,LRECL=516,BLKSIZE=15480),\n// VOL=(,RETAIN,REF=*.A.CATOUT)\n   REPRO   INFILE(CATIN/WENGEN)  OUTFILE(CATOUT)\n//*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "REPROENQ": {"ttr": 32780, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x00\\x7f\\x00\\x88\\x00\\x7f\\x12\\x00\\x00?\\x00?\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf2\\xf7\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-01-07T00:00:00", "modifydate": "1988-01-07T12:00:00", "lines": 63, "newlines": 63, "modlines": 0, "user": "FILE270"}, "text": "//DN300150 JOB (2100,56-D),'DPARS 0682 T',CLASS=H,MSGCLASS=A\n//X EXEC ASMHCL,LIBRARY='WDPSC.PROGLIB',LNDSP=SHR,\n//   OPTION1=TERM\nREPROENQ CSECT\n         STM   R14,R12,12(R13)            SAVE REGISTERS\n         LR    R11,R13\n         BALR  R12,0                      LOAD BASE REGISTER\n         USING *,R12\n         B     IDENTITY\n         DC    C'REPROENQ'\n         DC    C'&SYSDATE'\n         DC    C'&SYSTIME'\nIDENTITY DS    0H\n         LA    R13,SAVE                   SAVE AREA\n         ST    R13,8(0,R11)               AND BACK CHAIN\n         ST    R11,4(0,R13)\n         SPACE 5\n         L     R6,540       TCB ADDRESS\n         L     R6,12(,R6)   TIOT ADDRESS\n         LA    R6,24(,R6)   DD ENTRIES WITHIN TIOT\nDDNAME   CLC   4(8,R6),=CL8'STEPCAT'    FIND STEPCAT DDNAME\n         BE    SETUP\n         SR    R7,R7\n         ICM   R7,1,0(R6)\n         BZ    CALLSANS\n         AR    R6,R7\n         B     DDNAME\nSETUP    EQU   *\n         WTO   'CATALOG BACKUP HAS STARTED. ENQUEUE BUILDUP MAY OCCUR OX\n               N THE CATALOG. DO NOT CANCEL',ROUTCDE=(1,2,5),DESC=4\n         ICM   R8,7,17(R6)         UCB  ADDRESS\n         ICM   R7,7,12(R6)         JFCB ADDRESS - 16\n         MVC   RNAME,16(R7)        ADJUST TO JFCB\n         ST    R8,UCBAD         PUT UCB ADDRESS AWAY\n         CLI   RNAME+21,C' '    IS NAME SHORT\n         MVI   RLENGTH,44\n         BNE   RSVX\n         MVI   RLENGTH,20\n*   ISSUE RESERVE/ENQ FOR CATALOG\nRSVX     EQU   *\n         RESERVE (QNAME,RLENGTH,E,00,SYSTEMS),RET=HAVE,UCB=UCBAD\n         B     CALLCON\nCALLSANS WTO   'IDCAMS CALLED WITHOUT RESERVE',ROUTCDE=11\nCALLCON  LINK  EP=IDCAMS,PARAM=(PARMLIST),VL=1\n         LR    R5,R15\n         DEQ   (QNAME,RLENGTH,00),UCB=UCBAD\n         WTO   'CATALOG BACKUP HAS COMPLETED. ENQUEUE BUILDUP SHOULD DIX\n               SSAPEAR',ROUTCDE=(1,2,5),DESC=4\nFINIT    EQU   *                      FINISHED FOR SURE\n         L     R13,SAVE+4\n         LR    R15,R5\n         RETURN  (14,12),T,RC=(15)         AND LEAVE\nSAVE     DS    18F\nPARMLIST DC    F'0'\nUCBAD    DC    F'0'\nQNAME    DC    C'SYSIGGV2'       MAJOR NAME FOR RESERVE\nRLENGTH  DC    X'0'              RNAME LENGTH, MUST BE ADJACENT\nRNAME    DC    CL44' '           MINOR NAME FOR RESERVE\n         REGISTER ,\n         END\n//LKED.SYSIN  DD *\n   SETCODE AC(1)\n   NAME REPROENQ(R)\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "RJETRAN$": {"ttr": 32782, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x00\\x7f\\x00\\x88\\x00\\x7f\\x12\\x00\\x00\\x03\\x00\\x03\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf2\\xf7\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-01-07T00:00:00", "modifydate": "1988-01-07T12:00:00", "lines": 3, "newlines": 3, "modlines": 0, "user": "FILE270"}, "text": "  FUNCTION:      Reassemble records  that have been  transmitted in\n                 80 byte segments via RJE to their original logical\n                 record length.\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "RJETRANS": {"ttr": 32784, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x00\\x7f\\x00\\x88\\x00\\x7f\\x12\\x00\\x00\\xbb\\x00\\xbb\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf2\\xf7\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-01-07T00:00:00", "modifydate": "1988-01-07T12:00:00", "lines": 187, "newlines": 187, "modlines": 0, "user": "FILE270"}, "text": "STATEOFF\nREPORT\nFILE IN01 STATUS END01 INREC1     80\nFILE IN02 STATUS END02 INREC2     80\nFILE IN03 STATUS END03 INREC3     80\nFILE IN04 STATUS END04 INREC4     80\nFILE IN05 STATUS END05 INREC5     80\nFILE IN06 STATUS END06 INREC6     80\nFILE IN07 STATUS END07 INREC7     80\nFILE DUMFILE DUMMY\nFILE OUTFILE OUTPUT FROM OUTFILE FB #1 NULL\n          OUTREC     #1\nWORKAREA  INREC      80\nWORKAREA  PARSEAREA  #2      VALUE ' '\n          LOADREC    80 1\n          WRITEREC   #1 1\nWORKAREA  CHECKAREA  #1\n          SINGLECHAR  1 1\nWORKAREA  FIRSTINBLK  8   PD VALUE 0\n          RECSKIPPED  8   PD VALUE 0\n          TESTMAX     8   PD VALUE 0\n          LASTCHAR    8   PD VALUE 0\n          INRECCOUNT  8   PD VALUE 0\n          FILENO      8   PD VALUE 1\n          ENDSWITCH   1      VALUE ' '\n          TAPENO      1      VALUE ' '\n          INFILE      4      VALUE ' '\nON ONE\n   MOVE DYLPARM TO TAPENO\n   FIRSTINBLK = #2 / 80 + 1\n   LASTCHAR = #1 - 1\nENDONE\nPROCESS:\n   INRECCOUNT = 1\n   ENDSWITCH = ' '\n   IF FILENO LE TAPENO\n      PERFORM DOIT TO ENDIT\n      FILENO = FILENO + 1\n      GOTO PROCESS\n   ELSE\n      GOTO TERMINATE\n      ENDIF\nDOIT:\n      PERFORM READFILE TO ENDFILES\n      IF ENDSWITCH EQ 'E'\n         LIST 'NO RECORDS IN' INFILE ( )\n         MOVE 6 TO DYLRETURN\n         GOTO ENDIT\n      ELSE\n         PERFORM LOAD TO TERMINATE\n         ENDIF\nENDIT:\nLOAD:\n   IF INRECCOUNT EQ FIRSTINBLK\n      GOTO WRITEIT\n      ENDIF\n   MOVE INREC TO LOADREC (INX)\n   INX = INX + 80\n   PERFORM READFILE TO ENDFILES\n   IF ENDSWITCH EQ 'E'\n      GOTO WRITEIT\n      ENDIF\n   INRECCOUNT = INRECCOUNT + 1\n   GOTO LOAD\nWRITEIT:\n   MOVE WRITEREC (INY) TO CHECKAREA\nRECHECK:\n   IF SINGLECHAR (INZ) NE BLANK\n      MOVE WRITEREC (INY) TO OUTREC\n      WRITE OUTFILE\n      INZ = 0\n      GOTO CONTINUE\n      ENDIF\n   IF INZ LT LASTCHAR\n      INZ = INZ + 1\n      GOTO RECHECK\n      ENDIF\n   RECSKIPPED = RECSKIPPED + 1\n   INZ = 0\nCONTINUE:\n   INY = INY + #1\n   TESTMAX = INY + #1\n   IF TESTMAX LE INX GOTO WRITEIT ENDIF\n   INRECCOUNT = 1\n   TESTMAX = 0\n   INX = 0\n   INY = 0\n   PARSEAREA = BLANKS\n   IF ENDSWITCH NE 'E' GOTO LOAD ENDIF\nTERMINATE:\n   LIST  '#1 BYTE RECORDS' 'AND/OR' 'BLOCKFILLER AREAS'\n         'BYPASSED =' RECSKIPPED ( )\n   STOP\nREADFILE:\n   IF FILENO EQ 1\n      PERFORM READ1 TO READ2\n      ENDIF\n   IF FILENO EQ 2\n      PERFORM READ2 TO READ3\n      ENDIF\n   IF FILENO EQ 3\n      PERFORM READ3 TO READ4\n      ENDIF\n   IF FILENO EQ 4\n      PERFORM READ4 TO READ5\n      ENDIF\n   IF FILENO EQ 5\n      PERFORM READ5 TO READ6\n      ENDIF\n   IF FILENO EQ 6\n      PERFORM READ6 TO READ7\n      ENDIF\n   IF FILENO EQ 7\n      PERFORM READ7 TO READ8\n      ENDIF\nENDFILES:\nREAD1:\n   READ IN01\n   IF END01 EQ 'E'\n      MOVE 'E' TO ENDSWITCH\n   ELSE\n      MOVE INREC1 TO INREC\n      ENDIF\nON ONE\n   MOVE 'IN01' TO INFILE\nENDONE\nREAD2:\n   READ IN02\n   IF END02 EQ 'E'\n      MOVE 'E' TO ENDSWITCH\n   ELSE\n      MOVE INREC2 TO INREC\n      ENDIF\nON ONE\n   MOVE 'IN02' TO INFILE\nENDONE\nREAD3:\n   READ IN03\n   IF END03 EQ 'E'\n      MOVE 'E' TO ENDSWITCH\n   ELSE\n      MOVE INREC3 TO INREC\n      ENDIF\nON ONE\n   MOVE 'IN03' TO INFILE\nENDONE\nREAD4:\n   READ IN04\n   IF END04 EQ 'E'\n      MOVE 'E' TO ENDSWITCH\n   ELSE\n      MOVE INREC4 TO INREC\n      ENDIF\nON ONE\n   MOVE 'IN04' TO INFILE\nENDONE\nREAD5:\n   READ IN05\n   IF END05 EQ 'E'\n      MOVE 'E' TO ENDSWITCH\n   ELSE\n      MOVE INREC5 TO INREC\n      ENDIF\nON ONE\n   MOVE 'IN05' TO INFILE\nENDONE\nREAD6:\n   READ IN06\n   IF END06 EQ 'E'\n      MOVE 'E' TO ENDSWITCH\n   ELSE\n      MOVE INREC6 TO INREC\n      ENDIF\nON ONE\n   MOVE 'IN06' TO INFILE\nENDONE\nREAD7:\n   READ IN07\n   IF END07 EQ 'E'\n      MOVE 'E' TO ENDSWITCH\n   ELSE\n      MOVE INREC7 TO INREC\n      ENDIF\nON ONE\n   MOVE 'IN07' TO INFILE\nENDONE\nREAD8:\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "RTSO": {"ttr": 33027, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x00\\x7f\\x00\\x88\\x00\\x7f\\x12\\x00\\x00\\xe8\\x00\\xe8\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf2\\xf7\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-01-07T00:00:00", "modifydate": "1988-01-07T12:00:00", "lines": 232, "newlines": 232, "modlines": 0, "user": "FILE270"}, "text": "RTSO     TITLE     'REMEMBER TSO COMMAND FROM ISPF'\n*        RTSO IMPLEMENTS A \"REMEMBER LAST TSO COMMAND\" FUNCTION\n*        FOR BOTH THE \"TSO\" COMMAND ON THE \"COMMAND ==>\" LINE\n*        AND FOR THE TSO COMMAND PANEL, PRIMARY MENU OPTION 6.\n*        THE TSO COMMAND PANEL CAN BE BROUGHT UP FROM ANY PANEL\n*        BY ENTERING \"TSO\" WITHOUT AN OPERAND, JUST LIKE THE\n*        \"KEYS\" COMMAND.  THE LAST COMMAND ENTERED IS ALWAYS\n*        PRESENTED WHEN THE TSO COMMAND PANEL IS DISPLAYED.\n         SPACE     3\n*        THIS PROGRAM IS FUNCTIONALLY EQUIVALENT TO THIS CLIST:\n*\n*        /*RTSO*/ PROC 1 ZPARM\n*        CONTROL NOFLUSH\n*          IF ('&ZPARM' EQ '') THEN DO\n*            ISPEXEC SELECT PGM(ISRPTC)\n*            END\n*          ELSE DO\n*            SET ZRTSO = &STR(&ZPARM)\n*            ISPEXEC VPUT (ZRTSO) SHARED\n*            ISPEXEC CONTROL ERRORS RETURN\n*            ISPEXEC SELECT CMD(&ZRTSO)\n*            END\n*\n*        IT IS A PROGRAM BECAUSE THE CLIST HAS PROBLEMS WITH\n*        DOUBLED QUOTES, IE. THE USER WOULD HAVE TO DOUBLE ANY\n*        QUOTES ENTERED ON THE COMMAND LINE, AND BECAUSE YOU\n*        CAN'T HAVE AN OPTIONAL CLIST POSITIONAL PARAMETER.\n         SPACE     3\n*        THIS PROGRAM IS INVOKED FROM THE ISP COMMAND TABLE.\n*        THE COMMAND TABLE ENTRY FOR THE CURRENT TSO COMMAND IS:\n*\n*          TSO  0  SELECT CMD(&ZPARM)\n*                    EXECUTE A TSO COMMAND\n*\n*        COMMAND TABLE IS CHANGED (WITH SCREEN 3.9) TO THIS:\n*\n*          TSO       0  ALIAS RTSO\n*                         EXECUTE AND REMEMBER A TSO COMMAND\n*\n*          RTSO      0  SELECT PGM(RTSO) PARM(&ZPARM)\n*                         EXECUTE AND REMEMBER A TSO COMMAND\n*\n*          OTSO      2  SELECT CMD(&ZPARM)\n*                         OLD EXECUTE A TSO COMMAND\n*\n         SPACE     3\n*        THE PARAMETER IS PASSED TO RTSO THE SAME WAY AS THE PARM\n*        FIELD FROM A JCL // EXEC STATEMENT.\n*\n*        THE FUNCTION VARIABLE POOL HAS THE PARAMETER COPIED\n*        INTO IT WITH THE VREPLACE SERVICE (WHICH IS BOTH\n*        REQUIRED FOR AND RESTRICED TO PROGRAMS).\n*\n*        ISPLINK, A PROGRAM PROVIDED WITH DIALOGUE MANAGER,\n*        IS LINK EDITED WITH RTSO TO INTERFACE WITH ISPF.\n*\n*        THE TSO COMMAND PANEL, \"ISRTSO\" MUST BE MODIFIED TO\n*        ASSIGN &RTSO TO &ZCMD AND THEN SAVE ANY NEW &ZCMD VALUE.\n         EJECT\n         MACRO\n         IDBLOCK\n*        THIS MACRO MAKES &SYSDATE AND &SYSTIME AVAILABLE\n         B         28(0,R15EPA)        SKIP OVER ID BLOCK\n         DC        AL1(23),CL8'&SYSECT',CL15'-&SYSDATE.@&SYSTIME'\n         MEND\n         SPACE     3\n         PRINT     ON,GEN,NODATA\nRTSO     CSECT     ,\n         SPACE     1\nR0       EQU       0\nR1       EQU       1\nR1PARM   EQU       1                   PASSED PARAMETER\nR2ZPARM  EQU       2                   ADDRESS OF PARAMETER\nR3ZPARML EQU       3                   LENGTH OF PARAMETER\nR10CODE  EQU       10                  SAVED TSO CMD RETURN CODE\nR12BASE  EQU       12                  BASE REGISTER\nR13SAVE  EQU       13                  SAVE AREA\nR14LINK  EQU       14                  RETURN ADDRESS\nR15EPA   EQU       15                  ENTRY POINT ADDRESS\nR15RC    EQU       15                  RETURN CODE\n         SPACE     3\nPARMS    DSECT     ,\nZPARMAD  DS        A(ZPARMLEN)         ONE WORD PARAMETER LIST\n         SPACE     1\n         ORG       PARMS               REUSE DSECT FOR PARAMETER\nZPARMLEN DC        Y(L'ZPARM)          LENGTH OF STRING\nZPARM    DC        0CL255' '           PASSED STRING KNOWN AS &ZPARM\n         SPACE     1\nRTSO     CSECT     ,\n         EJECT\n*        ENTRY CONVENTIONS\n*\n         IDBLOCK   ,\n         SPACE     1\n         STM       R14LINK,R12BASE,12(R13SAVE)  SAVE CALLER'S REGISTERS\n         LR        R12BASE,R15EPA      COPY BASE REGISTER\n         USING     RTSO,R12BASE        ANNOUNCE ADDRESSIBILITY\n         SPACE     1\n*        SET UP A NEW SAVE AREA\n*\n         LA        R15EPA,SAVEAREA     POINT AT NEW SAVE AREA\n         ST        R13SAVE,4(R15EPA)   CHAIN BACKWARDS\n         ST        R15EPA,8(R13SAVE)   CHAIN FORWARDS\n         LR        R13SAVE,R15EPA      ESTABLISH NEW SAVE AREA\n         SPACE     1\n*        POINT AT THE PARAMETER STRING\n*\n         USING     PARMS,R1PARM        ANNOUNCE ADDRESSIBILITY\n         L         R1PARM,ZPARMAD      POINT AT FIRST PARAMETER\n         USING     ZPARMLEN,R1PARM     ANNOUNCE ADDRESSIBILITY\n         LH        R3ZPARML,ZPARMLEN   PICK UP LENGTH\n         LA        R2ZPARM,ZPARM       POINT AT STRING\n         USING     ZPARM,R2ZPARM       ANNOUNCE ADDRESSIBILITY\n         DROP      R1PARM\n         SPACE     1\n*        DISPLAY PANEL OR EXECUTE PASSED COMMAND?\n*\n         LTR       R3ZPARML,R3ZPARML   NULL STRING?\n         BP        COMMAND             NO--GO SAVE AND EXECUTE\n         SPACE     3\n*        PUT UP STANDARD TSO OPTION 6 PANEL\n*\nPANEL    DS        0H\n         LA        R1PARM,=A(SELECT,SELPGML,SELPGM)\n         L         R15EPA,=V(ISPLINK)  INTERFACE ROUTINE\n         BALR      R14LINK,R15EPA      OFF TO DIALOG MANAGER\n         LR        R10CODE,R15RC       SAVE RETURN CODE\n         SPACE     3\n*        BACK TO CALLER LEAVING THE LAST ISPEXEC RETURN CODE IN R15\n*\nFINISHED DS        0H\n         LR        R15RC,R10CODE       GET RETURN CODE\n         L         R13SAVE,4(R13SAVE)  BACK TO INITIAL SAVE AREA\n         L         R14LINK,12(R13SAVE) GET RETURN ADDRESS\n         LM        R0,R12BASE,20(R13SAVE)  RESTORE CALLER'S REGISTERS\n         BR        R14LINK             BACK TO CALLER\n         EJECT\n*        SAVE ZPARM IN ZRTSO AND THEN EXECUTE AS TSO COMMAND\n*\nCOMMAND  DS        0H\n         SPACE     1\n*        CREATE FUNCTION POOL VARAIBLE\n*\n         ST        R3ZPARML,FWORD      SAVE STRING LENGTH\n         LA        R1PARM,=A(VREPLACE,NAMELIST,FWORD,(R2ZPARM))\n         ST        R2ZPARM,12(R1PARM)  SAVE STRING POINTER\n         L         R15EPA,=V(ISPLINK)  INTERFACE ROUTINE\n         BALR      R14LINK,R15EPA      OFF TO DIALOG MANAGER\n         SPACE     1\n*        SAVE ZCMD IN PROFILE VARIABLE POOL\n*\n         LA        R1PARM,=A(VPUT,NAMELIST,PROFILE)\n         L         R15EPA,=V(ISPLINK)  INTERFACE ROUTINE\n         BALR      R14LINK,R15EPA      OFF TO DIALOG MANAGER\n         SPACE     1\n*        DISABLE ISPF ERROR INTERCEPT\n*\n         LA        R1PARM,=A(CONTROL,ERRORS,RETURN+X'80000000')\n         L         R15EPA,=V(ISPLINK)  INTERFACE ROUTINE\n         BALR      R14LINK,R15EPA      OFF TO DIALOG MANAGER\n         SPACE     1\n*        NOW EXECUTE THE TSO COMMAND\n*\n         LA        R1PARM,=A(SELECT,SELCMDL,SELCMD)\n         L         R15EPA,=V(ISPLINK)  INTERFACE ROUTINE\n         BALR      R14LINK,R15EPA      OFF TO DIALOG MANAGER\n         LR        R10CODE,R15RC       SAVE RETURN CODE\n         SPACE     1\n*        SEE IF EXECUTION GENERATED ANY ERROR MESSAGES\n*\n         LA        R1PARM,=A(VCOPY,ZERRLIST,ZERRSML,ZERRSMAD,LOCATE)\n         L         R15EPA,=V(ISPLINK)  INTERFACE ROUTINE\n         BALR      R14LINK,R15EPA      OFF TO DIALOG MANAGER\n         L         R0,ZERRSML          LENGTH SHOULD BE ZERO\n         AL        R0,ZERRLML          PLUS ANOTHER ZERO LENGTH\n         BZ        FINISHED            NO MESSAGES -- ALL DONE\n         SPACE     1\n*        MESSAGES FROM TSO COMMAND (BAD SYNTAX, ETC...)\n*\n         LA        R1PARM,=A(CONTROL,DISPLAY,LINE+X'80000000')\n         L         R15EPA,=V(ISPLINK)  INTERFACE ROUTINE\n         BALR      R14LINK,R15EPA      OFF TO DIALOG MANAGER\n         SPACE     1\nTRYSHORT DS        0H\n         ICM       R0,15,ZERRSML       PICK UP LENGTH\n         BZ        TRYLONG             SKIP--NO MESSAGE\n         L         R1,ZERRSMAD         POINT AT TEXT\n         TPUT      (1),(0),R           WRITE SHORT MESSAGE\nTRYLONG  DS        0H\n         ICM       R0,15,ZERRLML       PICK UP LENGTH\n         BZ        FINISHED            SKIP--NO MESSAGE\n         L         R1,ZERRLMAD         POINT AT TEXT\n         TPUT      (1),(0),R           WRITE SHORT MESSAGE\n         B         FINISHED            BACK TO CALLER\n         EJECT\n         DC        CL8'SAVEAREA'\nSAVEAREA DC        18A(0)\n         SPACE     1\nSELECT   DC        CL8'SELECT '\nSELPGM   DC        CL40'PGM(ISRPTC) '\nSELPGML  DC        A(L'SELPGM)         EXTRA LENGTH FOR ZAPPING\n         SPACE     1\nVPUT     DC        C'VPUT '\nNAMELIST DC        C'(ZRTSO)'\nFWORD    DC        A(L'ZPARM)\n         SPACE     1\nVREPLACE DC        CL8'VREPLACE'\nPROFILE  DC        CL8'PROFILE '\n         SPACE     1\nCONTROL  DC        CL8'CONTROL '\nERRORS   DC        CL8'ERRORS '\nRETURN   DC        CL8'RETURN '\n         SPACE     1\nSELCMD   DC        C'CMD(&&ZRTSO) '\nSELCMDL  DC        A(L'SELCMD)\n         SPACE     1\nVCOPY    DC        CL8'VCOPY '\nZERRLIST DC        C'(ZERRSM ZERRLM) '\nZERRSML  DC        A(L'ZERRSM)\nZERRLML  DC        A(L'ZERRLM)\nZERRSMAD DC        A(ZERRSM)\nZERRLMAD DC        A(ZERRLM)\nZERRSM   DC        CL24' '\nZERRLM   DC        CL79' '\nLOCATE   DC        C'LOCATE '\n         SPACE     1\nDISPLAY  DC        CL8'DISPLAY '\nLINE     DC        C'LINE '\n         SPACE     3\n         LTORG     ,\n         SPACE     3\n         END       ,\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "R050A90": {"ttr": 33032, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x00\\x7f\\x00\\x88\\x00\\x7f\\x12\\x00\\x01\\xbb\\x01\\xbb\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf2\\xf7\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-01-07T00:00:00", "modifydate": "1988-01-07T12:00:00", "lines": 443, "newlines": 443, "modlines": 0, "user": "FILE270"}, "text": "*                                                                     * 00010\n*          COPIED FROM THE CBT TAPE 07/17/84.                         * 00010\n*          CALLING EXAMPLE IS IN MEMBER CALLCIPH                      * 00010\n*                                                                     * 00010\n*                                                                     * 00010\n*          DATA SET R050A90    AT LEVEL 002 AS OF 01/23/81            * 00010\n*          DATA SET R050A90    AT LEVEL 001 AS OF 01/22/81            * 00001\n*          DATA SET ENCIPH0    AT LEVEL 001 AS OF 03/18/77            * 00002\n         TITLE 'ENCIPHER AND DECIPHER ROUTINE'                          00003\nR050A90  CSECT                                                          00004\n*********************************************************************** 00005\n*        WRITTEN BY CRAIG KILLE OF FAIRCHILD SEMICONDUCTOR 5/5/76     * 00006\n*        USING THE DATA ENCRYPTION ALGORITHM SUBMITTED BY IBM TO      * 00007\n*        THE NATIONAL BUREAU OF STANDARDS AND PUBLISHED IN THE        * 00008\n*        FEDERAL REGISTER, VOL. 40, NO. 52 - MONDAY, MARCH 17, 1975.  * 00009\n*                                                                     * 00010\n*        THE GENERAL PROCEDURE FOR USE IS TO:                         * 00011\n*        (1) CALL THE SETKEY FUNCTION FROM A HOST PROGRAM, PASSING    * 00012\n*            THE START ADDRESS OF THE 8 BYTE KEY TO BE USED IN ALL    * 00013\n*            SUBSEQUENT ENCIPHERING AND/OR DECIPHERING CALLS.         * 00014\n*                                                                     * 00015\n*            COBOL EXAMPLE: CALL 'SETKEY' USING KEY-FIELD.            * 00016\n*                                                                     * 00017\n*            THE KEY FIELD WITHIN THE HOST PROGRAM IS LEFT UNCHANGED. * 00018\n*            THE CALL TO SETKEY NEED BE MADE ONLY ONCE PER EXECUTION  * 00019\n*            OF THE HOST PROGRAM, UNLESS IT IS DESIRED TO CHANGE      * 00020\n*            THE KEY FOR DEFINED GROUPS OF RECORDS, OR TO DECIPHER    * 00021\n*            OR ENCIPHER TWO OR MORE FILES WITHIN THE SAME PROGRAM.   * 00022\n*            IN THE LATTER CASE, IF THE CALLS TO ENCIPH/DECIPH ARE    * 00023\n*            INTERMIXED FOR THE FILES, A CALL TO SETKEY WILL HAVE     * 00024\n*            TO BE MADE BEFORE EACH ENCIPH/DECIPH CALL TO SET UP      * 00025\n*            THE KEY PERMUTATIONS APPROPRIATE TO EACH FILE.           * 00026\n*                                                                     * 00027\n*        (2) CALL THE ENCIPH/DECIPH FUNCTIONS AS NEEDED TO ENCIPHER   * 00028\n*            A DATA RECORD BEFORE WRITING IT TO A DATASET, OR         * 00029\n*            DECIPHER A DATA RECORD AFTER READING IT FROM A DATASET.  * 00030\n*            THE ARGUMENTS PASSED ARE THE START ADDRESS OF THE DATA   * 00031\n*            AREA TO ENCIPHER OR DECIPHER, AND THE ADDRESS OF A       * 00032\n*            FULL WORD BINARY COMPUTATIONAL ITEM THAT CONTAINS THE    * 00033\n*            COUNT OF BYTES TO ENCIPHER OR DECIPHER.  THE RESULT      * 00034\n*            REPLACES THE ORIGINAL DATA; THE COMPUTATIONAL ITEM       * 00035\n*            REMAINS UNCHANGED.                                       * 00036\n*                                                                     * 00037\n*            COBOL EXAMPLE: CALL 'ENCIPH' USING REC-AREA LENGTH56.    * 00038\n*                           CALL 'DECIPH' USING REC-AREA LENGTH72.    * 00039\n*                                                                     * 00040\n*            SINCE THE ALGORITHM WORKS ON 8 BYTES AT A TIME, THE      * 00041\n*            ACTUAL NUMBER OF BYTES ENCIPHERED OR DECIPHERED WILL     * 00042\n*            BE AN INTEGRAL NUMBER OF 8 BYTES THAT IS LESS THAN       * 00043\n*            OR EQUAL TO THE NUMBER PASSED IN ARG2 OF THE CALL.       * 00044\n*            THE GREATEST NUMBER OF BYTES LEFT UNENCIPHERED OR        * 00045\n*            DECIPHERED THEN WOULD BE THE RIGHTMOST 7 BYTES.          * 00046\n*                                                                     * 00047\n* MOD 1 - K TRUE  22JAN81 - CORRECTED BNP TO BM INSTR TO ALLOW 8 BYTE * 00048\n*                           FIELD LENGTH TO BE PROCESSED.             * 00049\n*********************************************************************** 00050\n         EJECT                                                          00051\n*********************************************************************** 00052\n*        REGISTER USAGE                                               * 00053\n*                                                                     * 00054\n*        R1=ADDR OF 1ST BYTE TO ENCIPHER OR DECIPHER                  * 00055\n*        R2=INCR REG. FOR R1 -- 8 BYTES EN/DECIPHERED AT A TIME       * 00056\n*        R3=ADDR OF LAST 8 BYTE BLOCK TO EN/DECIPHER                  * 00057\n*        R4=SCRATCH                                                   * 00058\n*        R5=SCRATCH                                                   * 00059\n*        R6=SCRATCH                                                   * 00060\n*        R7=BYTE ADDR IN PERM0 TO STORE & SCRATCH                     * 00061\n*        R8=INCR REG. FOR R7 -- CONTAINS -1                           * 00062\n*        R9=ADDR-1 OF LEFTMOST BYTE OF PERM0                          * 00063\n*        RA=SCRATCH                                                   * 00064\n*        RB=POINTER TO S1,S2,...S8 CIPHER TABLE                       * 00065\n*        RC=BASE ADDRESS REGISTER                                     * 00066\n*        RD=CONTAINS INTERATION 1...16 FOR FUNCTION PERFORMANCE COUNT * 00067\n*        RE=SCRATCH                                                   * 00068\n*        RF=SCRATCH                                                   * 00069\n*********************************************************************** 00070\nR1       EQU   1                                                        00071\nR2       EQU   2                                                        00072\nR3       EQU   3                                                        00073\nR4       EQU   4                                                        00074\nR5       EQU   5                                                        00075\nR6       EQU   6                                                        00076\nR7       EQU   7                                                        00077\nR8       EQU   8                                                        00078\nR9       EQU   9                                                        00079\nRA       EQU   10                                                       00080\nRB       EQU   11                                                       00081\nRC       EQU   12                                                       00082\nRD       EQU   13                                                       00083\nRE       EQU   14                                                       00084\nRF       EQU   15                                                       00085\n**********************************************************************  00086\n*        ROUTINE STARTS HERE.                                        *  00087\n*        SAVE REGS., SET UP SAVE AREA, & ESTABLISH ADDRESSABILITY    *  00088\n**********************************************************************  00089\n         ENTRY SETKEY                                                   00090\n         ENTRY ENCIPH                                                   00091\n         ENTRY DECIPH                                                   00092\n         USING *,RF                                                     00093\nSETKEY   SAVE  (14,12),,*                                               00094\n         LA    RE,8           CODE 8 FOR SETKEY                         00095\n         L     RC,BASEADDR                                              00096\n         B     INIT                                                     00097\n         DS    0F                                                       00098\n         USING *,RF                                                     00099\nENCIPH   SAVE  (14,12),,*                                               00100\n         SR    RE,RE          CODE 0 FOR ENCIPH                         00101\n         L     RC,BASEADDR                                              00102\n         B     INIT                                                     00103\n         DS    0F                                                       00104\n         USING *,RF                                                     00105\nDECIPH   SAVE  (14,12),,*                                               00106\n         LA    RE,4           CODE 4 FOR DECIPH                         00107\n         L     RC,BASEADDR                                              00108\n         B     INIT                                                     00109\n         DROP  RF                                                       00110\n         USING R050A90,RC                                               00111\nINIT     LR    2,13                                                     00112\n         LA    13,SAVEAREA                                              00113\n         ST    2,SAVEAREA+4                                             00114\n         ST    13,8(,2)                                                 00115\n         B     COMMTAB(RE)    BRANCH TO APPROPRIATE ROUTINE             00116\nBASEADDR DC    A(R050A90)                                               00117\nCOMMTAB  B     ENDECIPH                                                 00118\n         B     ENDECIPH                                                 00119\n*        BRANCH DIRECTLY TO NEXT INSTR. ON SETKEY                       00120\n         EJECT                                                          00121\n**********************************************************************  00122\n*        BUILD 16 KEY PERMUTATIONS FROM ORIGINAL 8 BYTE KEY          *  00123\n**********************************************************************  00124\n         L     R4,0(R1)       (R4)=ADDR OF 8 BYTE KEY PASSED            00125\n         ICM   R6,15,0(R4)    LOAD FIRST 4 BYTES OF KEY                 00126\n         ICM   R7,15,4(R4)    LOAD SECOND 4 BYTES OF KEY                00127\n         L     R8,MINUS1      LOAD INCR REG FOR BXH                     00128\n         LA    R5,KEY64+63    LOAD LAST BYTE ADDRESS                    00129\n         LA    R9,KEY64-1     LOAD ADDR-1 OF LEFTMOST BYTE              00130\nSTOREKEY STC   R7,0(R5)       SET UP KEY AS 64 BYTES RATHER THAN BITS   00131\n         SRDL  R6,1           SHIFT IN NEXT BIT                         00132\n         BXH   R5,R8,STOREKEY                                           00133\n*********************************************************************** 00134\n*        PERFORM CHOICE 1 PERMUTATION ON 64 BYTE KEY FOR 56 BYTE KEY  * 00135\n*********************************************************************** 00136\n         MVC   KEY56,CHOICE1P MOVE IN PATTERN TO EXTRACT KEY            00137\n         TR    KEY56,KEY64    SCRAMBLE ORIGINAL KEY                     00138\n*********************************************************************** 00139\n*        NOW PREPARE A 48 BYTE KEY TO EXCLUSIVE OR TO THE 48 BYTES    * 00140\n*        I WILL CREATE FROM THE RIGHTSIDE OF PERM1 WHEN WORKING       * 00141\n*        WITH THE DATA TO ENCIPHER OR DECIPHER.                       * 00142\n*********************************************************************** 00143\n         SR    RD,RD          SET UP KEYS FOR RD = 0 TO 15              00144\nNEXTKEY  C     RD,=F'2'       IF RD IS 0,1,8, OR 15 SHIFT ONCE          00145\n         BL    SHIFT1         OTHERWISE SHIFT TWICE.                    00146\n         C     RD,=F'8'                                                 00147\n         BL    SHIFT2                                                   00148\n         BE    SHIFT1                                                   00149\n         C     RD,=F'15'                                                00150\n         BE    SHIFT1                                                   00151\nSHIFT2   LA    R4,2           LOAD COUNT TO SHIFT                       00152\n         B     SHIFTIT                                                  00153\nSHIFT1   LA    R4,1                                                     00154\nSHIFTIT  MVC   KEY56-1,KEY56  SHIFT WHOLE KEY LEFT 1 BYTE               00155\n         MVC   BYTE56,BYTE28  AND SIMULATE CIRCULAR SHIFT OF BOTH       00156\n         MVC   BYTE28,BYTEOUT HALVES OF KEY56 BY STUFFING BYTES.        00157\n         BCT   R4,SHIFTIT     GO DO AGAIN IF NECESSARY                  00158\n*********************************************************************** 00159\n*        PERFORM CHOICE 2 ON KEY56 BY EXTRACTING 48 BYTE KEY          * 00160\n*********************************************************************** 00161\n         MVC   KEY48,CHOICE2P MOVE IN PATTERN TO EXTRACT 48 BYTES       00162\n         TR    KEY48,KEY56    EXTRACT                                   00163\n         LR    RF,RD          COMPUTE AREA ADDR FOR STORE               00164\n         M     RE,=F'48'      MULTIPLY BY WIDTH OF KEY                  00165\n         LA    RE,KEY0(RF)    ADD IN BASE ADDR OF KEY0                  00166\n         MVC   0(48,RE),KEY48 MOVE KEY TO CORRECT AREA                  00167\n         LA    RD,1(RD)       INCREMENT RD                              00168\n         C     RD,=F'15'                                                00169\n         BNH   NEXTKEY                                                  00170\n         B     EXUENT         ALL DONE MY JOB, NOW EXIT                 00171\n         EJECT                                                          00172\n*********************************************************************** 00173\n*        COMMON CODE FOR ENCIPHER AND DECIPHER.  ONLY DIFFERENCE      * 00174\n*        IS WHETHER TO USE KEYS 0-15 (ENCIPH) OR 15-0 (DECIPH).       * 00175\n*********************************************************************** 00176\nENDECIPH ST    RE,MODE        SAVE MODE I CAME IN WITH                  00177\n         LM    R2,R3,0(R1)    LOAD ADDR OF 1ST BYTE & LENGTH            00178\n         L     R3,0(R3)       (R2)=ADDR OF START, (R3) = LENGTH         00179\n         N     R3,STRIP       MAKE SURE LENGTH IS MULTIPLE OF 8 BYTES   00180\n         S     R3,=F'8'       GET LENGTH MINUS EIGHT                    00181\n         BM    EXUENT         LEN < 0, FORGET IT                KMTMOD1 00182\n         LR    R1,R2          LOAD START ADDRESS IN REG. 1              00183\n         AR    R3,R2          ADD IN LENGTH-8 FOR ADDR OF LAST 8 BYTES  00184\n         LA    R2,8           LOAD INCREMENT REGISTER                   00185\n         L     R8,MINUS1      LOAD DECREMENT REG. USED THRUOUT FOR BXH  00186\n*********************************************************************** 00187\n*        GRAB NEXT 8 BYTES POINTED TO BY REG. 1 AND SPLIT THE 32 BITS * 00188\n*        IN THOSE 8 BYTES INTO 32 BYTES SO I CAN USE THE TR INST. TO  * 00189\n*        DO THE HARD WORK OF SHIFTING EVERYBODY AROUND.  I MAKE NO    * 00190\n*        ATTEMPT TO ELIMINATE ALL BUT THE RIGHTMOST BIT IN EACH BYTE  * 00191\n*        STORED, BECAUSE THESE OTHER BITS ARE IRRELEVANT IN ALL       * 00192\n*        PROCESS STEPS, AND ARE DISCARDED ON OUTPUT.                  * 00193\n*********************************************************************** 00194\nNEXT8BYT LA    R9,PERM0-1                                               00195\n         LA    R7,64(R9)      R7 INIT. POINTS TO RIGHTMOST BYTE PERM0   00196\n         ICM   R4,15,0(R1)    LOAD 8 BYTES INTO R4 AND R5, ASSUMING     00197\n         ICM   R5,15,4(R1)    NO ALLIGNMENT OTHER THAN BYTE             00198\nBITSTORE STC   R5,0(R7)       STORE BYTE (RIGHTMOST BIT,ONLY,IMPORTANT) 00199\n         SRDL  R4,1           SHIFT IN NEXT BIT                         00200\n         BXH   R7,R8,BITSTORE POINT TO PRIOR BYTE IN PERM0 AND REDO     00201\n*********************************************************************** 00202\n*        PERMUTATION 1: SCRAMBLE ORIGINAL 64 BITS (BYTES NOW)         * 00203\n*********************************************************************** 00204\n         MVC   PERM1,PERM1PAT MOVE IN PATTERN TO SCRAMBLE               00205\n         TR    PERM1,PERM0    SCRAMBLE PERM0 INTO PERM1                 00206\n         L     RE,MODE        DO ITERATION 0-15 FOR ENCIPH,15-0 DECIPH  00207\n         B     STARTAB(RE)                                              00208\nSTARTAB  B     STENCIPH                                                 00209\n         LA    RD,15                                                    00210\n         B     NEXTITER                                                 00211\nSTENCIPH SR    RD,RD                                                    00212\n*********************************************************************** 00213\n*        MAIN LOOP OF PROGRAM WHERE 16 ITERATIONS OF BASTARDIZATION   * 00214\n*        ARE PERFORMED.  AND WITH A SLIGHT OF HAND, GARBAGE RESULTS.  * 00215\n*        FIRST PERFORM FUNCTION 'E' WHICH EXPANDS THE RIGHTMOST 32    * 00216\n*        BYTES OF PERM1 INTO 48.                                      * 00217\n*********************************************************************** 00218\nNEXTITER MVC   RIGHT48,RIGHT48P MOVE IN PATTERN TO EXPAND               00219\n         TR    RIGHT48,PERM1+32 EXPAND RIGHTMOST 32 BYTES TO 48         00220\n**********************************************************************  00221\n*        GET APPROPRIATE KEY TO EXCLUSIVE OR                         *  00222\n**********************************************************************  00223\n         LR    RF,RD          COMPUTE KEY ADDR                          00224\n         M     RE,=F'48'                                                00225\n         LA    RE,KEY0(RF)                                              00226\n         EJECT                                                          00227\n*********************************************************************** 00228\n*        EXCLUSIVE OR THE 48 BYTE RESULTS OF FUNCTION 'E' AND THE KEY * 00229\n*        EXTRACTION.                                                  * 00230\n*********************************************************************** 00231\n         XC    RIGHT48,0(RE)                                            00232\n*********************************************************************** 00233\n*        TREAT THIS RESULT (IN RIGHT48) AS 8 6-BYTE BLOCKS.           * 00234\n*        TRANSLATE SO BYTE 0 & 5 OF EACH BLOCK BECOME BYTE 0 & 1      * 00235\n*        AND BYTES 1 TO 4 BECOME BYTES 2-5.                           * 00236\n*********************************************************************** 00237\n         MVC   KEY48,TICKLE   MOVE IN PATTERN TO TICKLE                 00238\n         TR    KEY48,RIGHT48  TICKLE                                    00239\n*********************************************************************** 00240\n*        NOW, UNFORTUNATELY, I HAVE TO TURN THE BYTES BACK INTO BITS  * 00241\n*        SO THAT I CAN FORM A SIX BIT KEY FOR TABLE LOOK UP INTO      * 00242\n*        THE TABLES S1,S2,...S8.  AFTER THAT EACH 6 BYTE (BIT) BLOCK  * 00243\n*        OF KEY48 WILL BE REPLACED BY THE 4 BIT CODE FOUND IN THE     * 00244\n*        TABLE LOOK UP.  THUS MY 48 BITS BECOME 32 BITS AGAIN.  YIPEE.* 00245\n*        THE TABLES S1,S2,...S8 ARE USED REPECTIVELY FOR THE 1ST,2ND, * 00246\n*        ...8TH BLOCK OF 6 BITS IN KEY48.                             * 00247\n*********************************************************************** 00248\n         LA    R4,KEY48       SET UP BXLE CONTROL                       00249\n         LA    R6,1                                                     00250\n         LA    R7,KEY48+47                                              00251\nSHIFTBIT SLDL  RE,1           SHIFT REGS. 14 & 15 LEFT 1 BIT            00252\n         TM    0(R4),1        IS RIGHTMOST BIT IN BYTE TURNED ON?       00253\n         BNO   NEXTBYTE       NO, SHIFT IN ZERO                         00254\n         O     RF,ONE         OR IN A ONE BIT TO SHIFT                  00255\nNEXTBYTE BXLE  R4,R6,SHIFTBIT                                           00256\n*                                                                       00257\n         SLDL  RE,16          SHIFT 48 BITS FLUSH LEFT IN REGS. 14 & 15 00258\n         SR    R9,R9          ZERO OUT SCRATCH REGISTER 9               00259\n         LA    R4,S1          POINT TO FIRST TABLE FOR 1ST 6 BIT KEY    00260\n         LA    R6,64          SIZE IN BYTES OF TABLE TO JUMP OVER       00261\n         LA    R7,S7          STOP AFTER LAST ODD NUMBERED TABLE        00262\nLOOP     SLL   RA,8           SHIFT OVER BITS CREATED SO FAR            00263\n         LR    R5,RE          GET LEFTMOST 6 BITS OF RE IN R5           00264\n         SRL   R5,26                                                    00265\n         SLDL  RE,6           SHIFT IN NEXT 6 BIT KEY                   00266\n         IC    R9,0(R5,R4)    GET BYTE FROM TABLE S1,S3,S5,S7           00267\n         AR    R4,R6          POINT TO TABLE S2,S4,S6,S8                00268\n         LR    R5,RE          GET LEFTMOST 6 BITS OF RE IN R5           00269\n         SRL   R5,26                                                    00270\n         SLDL  RE,6           SHIFT IN NEXT 6 BIT KEY                   00271\n         IC    RA,0(R5,R4)    GET BYTE FROM TABLE S2,S4,S6,S8           00272\n         SLL   R9,4           SHIFT LEFT HALF BYTE TO POSITION          00273\n         OR    RA,R9          OR LEFT AND RIGHT HALVES OF BYTE          00274\n         BXLE  R4,R6,LOOP     POINT TO S3,S5,S7 AND GO AGAIN            00275\n         EJECT                                                          00276\n*********************************************************************** 00277\n*        REGISTER 10 NOW CONTAINS 32 BITS TO DECODE TO 32 BYTES       * 00278\n*********************************************************************** 00279\n         LA    R7,RIGHT48+31  ADDR FOR FIRST BYTE STORE                 00280\n         LA    R9,RIGHT48-1   ADDR-1 OF LAST BYTE TO STORE. (R8)=-1     00281\nSTOREBIT STC   RA,0(R7)       STORE BYTE (ONLY RIGHTMOST BIT IMPORTANT) 00282\n         SRL   RA,1           SHIFT IN NEXT BIT                         00283\n         BXH   R7,R8,STOREBIT                                           00284\n**********************************************************************  00285\n*        PERFORM PERMUTATION OF RESULTANT 32 BYTES                   *  00286\n**********************************************************************  00287\n         MVC   PERM0(32),PRIMP    MOVE IN PERMUTE PATTERN               00288\n         TR    PERM0(32),RIGHT48  TRANSLATE IN 32 LEFT BYTES OF RGHT    00289\n*********************************************************************** 00290\n*        EXCLUSIVE OR THE COMPLETED PERMUTED RIGHTHALF WITH THE       * 00291\n*        ORIGINAL LEFT HALF, AND THEN PLACE ORIGINAL RIGHT HALF IN    * 00292\n*        LEFT HALF, AND MOVE IN EXCLUSIVE OR RESULT TO RIGHT HALF.    * 00293\n*********************************************************************** 00294\n         XC    PERM0(32),PERM1                                          00295\n         MVC   PERM1(32),PERM1+32  MOVE ORIG. RIGHT TO LEFT HALF        00296\n         MVC   PERM1+32(32),PERM0 MOVE IN EXCL OR RESULT                00297\n         L     RE,MODE        INCR ITER# IF ENCIPH, DECR IF DECIPH      00298\n         B     ENDTAB(RE)                                               00299\nENDTAB   B     ENDENCIP                                                 00300\n         BCTR  RD,0           DECREMENT BECAUSE WE ARE DECIPHERING      00301\n         LTR   RD,RD                                                    00302\n         BNM   NEXTITER       GO UNTIL ITER # IS NEGATIVE               00303\n         B     UNSWITCH       JUMP OUT WHEN DONE                        00304\nENDENCIP LA    RD,1(RD)       INCREMENT BECAUSE WE ARE ENCIPHERING      00305\n         C     RD,=F'15'                                                00306\n         BNH   NEXTITER                                                 00307\n*********************************************************************** 00308\n*        FALL THRU TO HERE WHEN 16 ITERATIONS DONE.  NOW DO FINAL     * 00309\n*        PERMUTATION WHICH IS INVERSE OF FIRST PERMUTATION AND        * 00310\n*        STORE RESULTING 8 BYTES BACK WHERE I GOT THE ORIGINALS FROM. * 00311\n*********************************************************************** 00312\nUNSWITCH MVC   PERM1+32(32),PERM1  LEAVE HALVES UNSWITCHED ON 16TH      00313\n         MVC   PERM1(32),PERM0                                          00314\n         MVC   PERM0,LASTTRAN  MOVE IN INVERSE PATTERN                  00315\n         TR    PERM0,PERM1     PERMUTE PERM1 INTO PERM0 RESULT          00316\n*********************************************************************** 00317\n*        CHANGE BYTES BACK TO BITS FOR THE FINAL TIME                *  00318\n*********************************************************************** 00319\n         LA    R4,PERM0                                                 00320\n         LA    R6,1                                                     00321\n         LA    R7,PERM0+63                                              00322\nSTUFFIT  SLDL  RE,1            SHIFT BITS LEFT ONE                      00323\n         TM    0(R4),1         IS RIGHTMOST BIT OF BYTE A ONE?          00324\n         BNO   BYTENEXT        NO, SHIFT IN ZERO BIT                    00325\n         O     RF,ONE          OR IN A ONE BIT                          00326\nBYTENEXT BXLE  R4,R6,STUFFIT                                            00327\n*                                                                       00328\n         STCM  RE,15,0(R1)     STORE OVER ORIG FIRST 4 BYTES            00329\n         STCM  RF,15,4(R1)     STORE OVER ORIG SECOND 4 BYTES           00330\n         BXLE  R1,R2,NEXT8BYT  GO GET NEXT 8 BYTES UNTIL DONE           00331\n         EJECT                                                          00332\n*********************************************************************** 00333\n*        COMMON EXIT FOR SETKEY, ENCIPH, AND DECIPH.                  * 00334\n*********************************************************************** 00335\nEXUENT   L     RD,SAVEAREA+4   LOAD ADDR OF CALLERS SAVE AREA           00336\n         SR    RF,RF           SET RETURN CODE TO ZERO                  00337\n         RETURN (14,12),RC=(15)                                         00338\n*********************************************************************** 00339\n*        DATA AREAS                                                   * 00340\n*********************************************************************** 00341\nSAVEAREA DS    18F             MY REGISTER SAVE AREA                    00342\nMINUS1   DC    F'-1'                                                    00343\nONE      DC    F'1'                                                     00344\nMODE     DS    F'0'                                                     00345\nSTRIP    DC    X'FFFFFFF8'                                              00346\nKEY0     DS    16CL48                                                   00347\nPERM0    DS    CL64                                                     00348\nPERM1    DS    CL64                                                     00349\nKEY64    DS    CL64                                                     00350\nRIGHT48  DS    CL48                                                     00351\nKEY48    DS    CL48                                                     00352\n****************** BYTEOUT THRU BYTE56 MUST BE TOGETHER ****            00353\nBYTEOUT  DS    CL1                                                      00354\nKEY56    DS    0CL56                                                    00355\n         DS    CL27                                                     00356\nBYTE28   DS    CL1                                                      00357\n         DS    CL27                                                     00358\nBYTE56   DS    CL1                                                      00359\n****************** END OF GROUP                         ****            00360\n*********************************************************************** 00361\n*        TRANSLATION  TABLES                                          * 00362\n*********************************************************************** 00363\nPERM1PAT DS    0CL64                                                    00364\n         DC    AL1(57,49,41,33,25,17,09,01,59,51,43,35,27,19,11,03)     00365\n         DC    AL1(61,53,45,37,29,21,13,05,63,55,47,39,31,23,15,07)     00366\n         DC    AL1(56,48,40,32,24,16,08,00,58,50,42,34,26,18,10,02)     00367\n         DC    AL1(60,52,44,36,28,20,12,04,62,54,46,38,30,22,14,06)     00368\nRIGHT48P DS    0CL48                                                    00369\n         DC    AL1(31,00,01,02,03,04,03,04,05,06,07,08)                 00370\n         DC    AL1(07,08,09,10,11,12,11,12,13,14,15,16)                 00371\n         DC    AL1(15,16,17,18,19,20,19,20,21,22,23,24)                 00372\n         DC    AL1(23,24,25,26,27,28,27,28,29,30,31,00)                 00373\nCHOICE1P DS    0CL56                                                    00374\n         DC    AL1(56,48,40,32,24,16,08,00,57,49,41,33,25,17)           00375\n         DC    AL1(09,01,58,50,42,34,26,18,10,02,59,51,43,35)           00376\n         DC    AL1(62,54,46,38,30,22,14,06,61,53,45,37,29,21)           00377\n         DC    AL1(13,05,60,52,44,36,28,20,12,04,27,19,11,03)           00378\nCHOICE2P DS    0CL48                                                    00379\n         DC    AL1(13,16,10,23,00,04,02,27,14,05,20,09)                 00380\n         DC    AL1(22,18,11,03,25,07,15,06,26,19,12,01)                 00381\n         DC    AL1(40,51,30,36,46,54,29,39,50,44,32,47)                 00382\n         DC    AL1(43,48,38,55,33,52,45,41,49,35,28,31)                 00383\nTICKLE   DS    0CL48                                                    00384\n         DC    AL1(00,05,01,02,03,04,06,11,07,08,09,10)                 00385\n         DC    AL1(12,17,13,14,15,16,18,23,19,20,21,22)                 00386\n         DC    AL1(24,29,25,26,27,28,30,35,31,32,33,34)                 00387\n         DC    AL1(36,41,37,38,39,40,42,47,43,44,45,46)                 00388\nLASTTRAN DS    0CL64                                                    00389\n         DC    AL1(39,07,47,15,55,23,63,31,38,06,46,14,54,22,62,30)     00390\n         DC    AL1(37,05,45,13,53,21,61,29,36,04,44,12,52,20,60,28)     00391\n         DC    AL1(35,03,43,11,51,19,59,27,34,02,42,10,50,18,58,26)     00392\n         DC    AL1(33,01,41,09,49,17,57,25,32,00,40,08,48,16,56,24)     00393\nPRIMP    DS    0CL32                                                    00394\n         DC    AL1(15,06,19,20,28,11,27,16,00,14,22,25,04,17,30,09)     00395\n         DC    AL1(01,07,23,13,31,26,02,08,18,12,29,05,21,10,03,24)     00396\nS1       DS    0CL64                                                    00397\n         DC    AL1(14,04,13,01,02,15,11,08,03,10,06,12,05,09,00,07)     00398\n         DC    AL1(00,15,07,04,14,02,13,01,10,06,12,11,09,05,03,08)     00399\n         DC    AL1(04,01,14,08,13,06,02,11,15,12,09,07,03,10,05,00)     00400\n         DC    AL1(15,12,08,02,04,09,01,07,05,11,03,14,10,00,06,13)     00401\nS2       DS    0CL64                                                    00402\n         DC    AL1(15,01,08,14,06,11,03,04,09,07,02,13,12,00,05,10)     00403\n         DC    AL1(03,13,04,07,15,02,08,14,12,00,01,10,06,09,11,05)     00404\n         DC    AL1(00,14,07,11,10,04,13,01,05,08,12,06,09,03,02,15)     00405\n         DC    AL1(13,08,10,01,03,15,04,02,11,06,07,12,00,05,14,09)     00406\nS3       DS    0CL64                                                    00407\n         DC    AL1(10,00,09,14,06,03,15,05,01,13,12,07,11,04,02,08)     00408\n         DC    AL1(13,07,00,09,03,04,06,10,02,08,05,14,12,11,15,01)     00409\n         DC    AL1(13,06,04,09,08,15,03,00,11,01,02,12,05,10,14,07)     00410\n         DC    AL1(01,10,13,00,06,09,08,07,04,15,14,03,11,05,02,12)     00411\nS4       DS    0CL64                                                    00412\n         DC    AL1(07,13,14,03,00,06,09,10,01,02,08,05,11,12,04,15)     00413\n         DC    AL1(13,08,11,05,06,15,00,03,04,07,02,12,01,10,14,09)     00414\n         DC    AL1(10,06,09,00,12,11,07,13,15,01,03,14,05,02,08,04)     00415\n         DC    AL1(03,15,00,06,10,01,13,08,09,04,05,11,12,07,02,14)     00416\nS5       DS    0CL64                                                    00417\n         DC    AL1(02,12,04,01,07,10,11,06,08,05,03,15,13,00,14,09)     00418\n         DC    AL1(14,11,02,12,04,07,13,01,05,00,15,10,03,09,08,06)     00419\n         DC    AL1(04,02,01,11,10,13,07,08,15,09,12,05,06,03,00,14)     00420\n         DC    AL1(11,08,12,07,01,14,02,13,06,15,00,09,10,04,05,03)     00421\nS6       DS    0CL64                                                    00422\n         DC    AL1(12,01,10,15,09,02,06,08,00,13,03,04,14,07,05,11)     00423\n         DC    AL1(10,15,04,02,07,12,09,05,06,01,13,14,00,11,03,08)     00424\n         DC    AL1(09,14,15,05,02,08,12,03,07,00,04,10,01,13,11,06)     00425\n         DC    AL1(04,03,02,12,09,05,15,10,11,14,01,07,06,00,08,13)     00426\nS7       DS    0CL64                                                    00427\n         DC    AL1(04,11,02,14,15,00,08,13,03,12,09,07,05,10,06,01)     00428\n         DC    AL1(13,00,11,07,04,09,01,10,14,03,05,12,02,15,08,06)     00429\n         DC    AL1(01,04,11,13,12,03,07,14,10,15,06,08,00,05,09,02)     00430\n         DC    AL1(06,11,13,08,01,04,10,07,09,05,00,15,14,02,03,12)     00431\nS8       DS    0CL64                                                    00432\n         DC    AL1(13,02,08,04,06,15,11,01,10,09,03,14,05,00,12,07)     00433\n         DC    AL1(01,15,13,08,10,03,07,04,12,05,06,11,00,14,09,02)     00434\n         DC    AL1(07,11,04,01,09,12,14,02,00,06,10,13,15,03,05,08)     00435\n         DC    AL1(02,01,14,07,04,10,08,13,15,12,09,00,03,05,06,11)     00436\n         END                                                            00437\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "SCAN4HIT": {"ttr": 33285, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x00\\x7f\\x00\\x88\\x00\\x7f\\x12\\x00\\x00\\xb6\\x00\\xb6\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf2\\xf7\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-01-07T00:00:00", "modifydate": "1988-01-07T12:00:00", "lines": 182, "newlines": 182, "modlines": 0, "user": "FILE270"}, "text": "         PRINT ON,NOGEN\n         SPACE 3\n*        THIS PROGRAM IS A SUBROUTINE WHICH WILL SCAN A RECORD OF UP\n*        TO 80 BYTES IN LENGTH FOR AN ARGUMENT OF UP TO 80 BYTES IN\n*        LENGTH AND INFORM THE INVOKER OF WHETHER A MATCH WAS FOUND.\n*\n*        TO CALL THIS PROGRAM, DO THE FOLLOWING :\n*\n*           MOVE YOUR ARGUMENT TO ARGUMENT OF SCAN4HIT-I-O-AREA.\n*           MOVE THE LENGTH OF YOUR ARGUMENT\n*             TO ARGUMENT-LENGTH OF SCAN4HIT-I-O-AREA.\n*           MOVE YOUR RECORD TO BE SCANNED\n*             TO TABLE-ELEMENT OF SCAN4HIT-I-O-AREA.\n*           MOVE THE LENGTH OF YOUR RECORD TO BE SCANNED\n*             TO TABLE-ELEMENT-LENGTH OF SCAN4HIT-I-O-AREA.\n*\n*           CALL 'SCAN4HIT' USING SCAN4HIT-I-O-AREA.\n*\n*           AFTER THE CALL, HIT-SWITCH OF SCAN4HIT-I-O-AREA WILL\n*           CONTAIN EITHER 'YES' OR 'NO '.  'YES' MEANS A MATCH WAS\n*           FOUND AND 'NO ' MEANS A MATCH WAS NOT FOUND.\n*\n*                WHERE:\n*\n*                      01  SCAN4HIT-I-O-AREA.\n*                          05  ARGUMENT              PIC X(80).\n*                          05  ARGUMENT-LENGTH       PIC S9(4) COMP.\n*                          05  TABLE-ELEMENT         PIC X(80).\n*                          05  TABLE-ELEMENT-LENGTH  PIC S9(4) COMP.\n*                          05  HIT-SWITCH            PIC X(3).\n*\n*\n*         RETURN CODES        MEANING\n*         -----------------   -----------------------------------\n*\n*                 0           MATCH WAS FOUND\n*                 4           NO MATCH WAS FOUND\n*                 8           INVALID PARAMETERS PASSED TO PROGRAM\n         EJECT\n         SPACE 3\n*\n**********************************************\n*                                            *\n*        I N I T I A L I Z A T I O N         *\n*                                            *\n**********************************************\n*\nSCAN4HIT CSECT\n         SAVE  (14,12)\n         BALR  12,0\n         USING *,12\n         ST    13,SAVEAREA+4\n         LA    13,SAVEAREA\n         B     STARTIT\n         SPACE\nSAVEAREA DC    18F'0'\n         SPACE 3\n********************************************************************\n*        EQUATE RESISTERS 0 THRU 15 TO MORE MEANINGFUL NAMES       *\n********************************************************************\n         SPACE 3\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n         EJECT\n         SPACE 3\n*\n********************************************************************\n*                                                                  *\n*        SAVE REGISTER 1 IN REGISTER 11 AND LOAD PARAMETER FIELD   *\n*        INTO IOAREA                                               *\n*                                                                  *\n********************************************************************\n*\n         SPACE 3\nSTARTIT  DS    0D\n         LR    R11,R1              SAVE REGISTER 1 CONTENTS IN REG 11\n         L     R9,0(R11)\n         MVC   IOAREA,0(R9)\n*                                        BINARY ZAROES\n         EJECT\n         SPACE 3\n*\n********************************************************************\n*                                                                  *\n*        M A I N   L I N E   L O G I C                             *\n*                                                                  *\n********************************************************************\n*\n         LA    R10,0\n         MVC   ARGLEN,INARGLEN\n         MVC   TBLLEN,INTBLLEN\n         LH    R8,ARGLEN\n         LH    R9,TBLLEN\n         C     R8,=F'1'\n         BL    NOGOOD\n         C     R8,=F'80'\n         BH    NOGOOD\n         C     R9,=F'1'\n         BL    NOGOOD\n         C     R9,=F'80'\n         BH    NOGOOD\n         CR    R8,R9\n         BH    NOGOOD\n         LA    R6,ARGUMENT\n         LA    R7,TBLELMNT\n         S     R8,=F'1'\n         AR    R9,R7\n         SR    R9,R8\n         S     R9,=F'1'\nLOOP     CR    R7,R9\n         BH    NOHIT\n         EX    R8,DOCOMPR\nCHEK     BE    HIT\n         A     R7,=F'1'\n         B     LOOP\nNOHIT    MVC   HITSW,=CL3'NO '\n         LA    R10,4\n         B     SHUTDOWN\nNOGOOD   MVC   HITSW,=CL3'   '\n         LA    R10,8\n         B     SHUTDOWN\nHIT      MVC   HITSW,=CL3'YES'\n         B     SHUTDOWN\nDOCOMPR  CLC   0(0,R6),0(R7)\n         B     CHEK\n         EJECT\n         SPACE 3\n*\n********************************************************************\n*                                                                  *\n*        E N D  O F   J O B   P R O C E S S I N G                  *\n*                                                                  *\n********************************************************************\n*\nSHUTDOWN LR    R15,R10\n         L     R9,0(R11)\n         MVC   0(167,R9),IOAREA\n         L     R13,4(R13)\n         RETURN (14,12),RC=(15)\n         EJECT\n         SPACE 3\n*\n********************************************************************\n*                                                                  *\n*        BREAKDOWN OF IOAREA                                       *\n*                                                                  *\n********************************************************************\n*\nIOAREA   DS    0CL167\nARGUMENT DS    CL80\nINARGLEN DS    CL2\nTBLELMNT DS    CL80\nINTBLLEN DS    CL2\nHITSW    DS    CL3\n         EJECT\n         SPACE 3\n*\n********************************************************************\n*                                                                  *\n*        D A T A   A R E A S                                       *\n*                                                                  *\n********************************************************************\n*\n         SPACE 3\n         DS    0F\nARGLEN   DS    H\nTBLLEN   DS    H\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "SCGEN1": {"ttr": 33289, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x00\\x7f\\x00\\x88\\x00\\x7f\\x12\\x00\\x00M\\x00M\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf2\\xf7\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-01-07T00:00:00", "modifydate": "1988-01-07T12:00:00", "lines": 77, "newlines": 77, "modlines": 0, "user": "FILE270"}, "text": "*          DATA SET 761KKSCGEN AT LEVEL 001 AS OF 08/30/82\n         LIT1  SCGEN1\n         DC   X'C3'\n         DC   X'115D7E1140403C404000'\n         DC   X'1140401DC813'\n         DC   C'                                        '\n         DC   C'                                       '\n         DC   X'11C1501DC8'\n         DC   C'                                        '\n         DC   C'                                       '\n         DC   X'11C2601DC8'\n         DC   C'                                        '\n         DC   C'                                       '\n         DC   X'11C3F01DC8'\n         DC   C'                                        '\n         DC   C'                                       '\n         DC   X'11C5401DC8'\n         DC   C'                                        '\n         DC   C'                                       '\n         DC   X'11C6501DC8'\n         DC   C'                                        '\n         DC   C'                                       '\n         DC   X'11C7601DC8'\n         DC   C'                                        '\n         DC   C'                                       '\n         DC   X'11C8F01DC8'\n         DC   C'                                        '\n         DC   C'                                       '\n         DC   X'114A401DC8'\n         DC   C'                                        '\n         DC   C'                                       '\n         DC   X'114B501DC8'\n         DC   C'                                        '\n         DC   C'                                       '\n         DC   X'114C601DC8'\n         DC   C'                                        '\n         DC   C'                                       '\n         DC   X'114DF01DC8'\n         DC   C'                                        '\n         DC   C'                                       '\n         DC   X'114F401DC8'\n         DC   C'                                        '\n         DC   C'                                       '\n         DC   X'1150501DC8'\n         DC   C'                                        '\n         DC   C'                                       '\n         DC   X'11D1601DC8'\n         DC   C'                                        '\n         DC   C'                                       '\n         DC   X'11D2F01DC8'\n         DC   C'                                        '\n         DC   C'                                       '\n         DC   X'11D4401DC8'\n         DC   C'                                        '\n         DC   C'                                       '\n         DC   X'11D5501DC8'\n         DC   C'                                        '\n         DC   C'                                       '\n         DC   X'11D6601DC8'\n         DC   C'                                        '\n         DC   C'                                       '\n         DC   X'11D7F01DC8'\n         DC   C'                                        '\n         DC   C'                                       '\n         DC   X'11D9401DC8'\n         DC   C'                                        '\n         DC   C'                                       '\n         DC   X'115A501DC8'\n         DC   C'                                        '\n         DC   C'                                       '\n         DC   X'115B601DC8'\n         DC   C'                                        '\n         DC   C'                                       '\n         DC   X'115CF01DC8'\n         DC   C'                                        '\n         DC   C'                                       '\n         LIT2\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "SCXSCAN": {"ttr": 33292, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x00\\x7f\\x00\\x88\\x00\\x7f\\x12\\x00\\x01<\\x01<\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf2\\xf7\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-01-07T00:00:00", "modifydate": "1988-01-07T12:00:00", "lines": 316, "newlines": 316, "modlines": 0, "user": "FILE270"}, "text": "         TITLE 'SCXSCAN - PCFSCAN REPLACEMENT'\n*                                                                 WDPSC\n*        MODIFICATION LOG:                                        WDPSC\n*                                                                 WDPSC\n*           09/30/85 - UPDATE TO ALLOW %X CLISTS                  WDPSC\n*                                                                 WDPSC\n*        NOTE: THIS PROGRAM IS LINKED AS THE ENTRY POINT FOR      WDPSC\n*              IBM MODULE IKJSCAN TO PROVIDE AN X CMD FUNCTION    WDPSC\n*              LIKE THE PCF X FUNCTION                            WDPSC\n*                                                                 WDPSC\n*        NOTE: IF YOU ARE RUNNING ACF2 COMMAND LIMITING LIKE      WDPSC\n*              WE DO, ADD SYSPARM(NNN) TO ASSEMBLY WHERE          WDPSC\n*              NNN IS YOUR ACF2 COMMAND VALIDATION SVC            WDPSC\n*                                                                 WDPSC\n*10/04/85  NOTE: IF YOU ARE ASSEMBLING FOR A TSO/E R2.1 (XA)\n*                SYSTEM, ADD SYSPARM(XATSOE) TO THE ASSEMBLER\n*                OPTIONS AND USE ASSEMBLER H WITH XA MACROS...\n*                THEN LINK THIS INTO IKJTSLAR CHANGING THE IKJSCAN\n*                ENTRY POINT TO NAME IBMSCAN\n*\n         AIF   ('&SYSPARM' NE 'XATSOE').NXA\nIKJSCAN  AMODE ANY\n.NXA     ANOP\nIKJSCAN  ENTERR LEVEL=V1M1\n         SPACE 3\n         BAL   R14,SCAN           FIND COMMAND NAME\n         LTR   R15,R15            OK?\n         BNZ   EXIT               BAD NEWS->EXIT\n         BAL   R14,XCMD           PROCESS IF 'X' REQUESTED\n*\n         BAL   R14,CLEANUP        FIX ECT,CSOA,ETC.\n*\nEXIT     LEAVER\n         EJECT\nSCAN     ST    R14,L1LS\n         LR    R11,R1             R11->CSPL\n         USING CSPL,R11\n         L     R9,CSPLOA          R9->CSOA\n         USING CSOA,R9\n         L     R8,CSPLECT         R8->ECT\n         USING ECT,R8\n         LA    R7,CPPLA           R7->CPPL\n         USING CPPL,R7\n         XC    XFLAG(3),XFLAG     CLEAR FLAGS\n         SPACE 2\nCSCAN    L     R15,=V(IBMSCAN)    R15->IKJSCAN\n         BALR  R14,R15            CALL IBM SCAN\n         ST    R15,SCANRC         SAVE HIS RC\n         LTR   R15,R15            0?\n         BNZ   SCANX              BAD NEWS\n         L     R6,CSOACNM         R6->CMDNAME\n         LTR   R6,R6              ANY CMD?\n         BNZ   XCHK               YES\nNOCMD    OI    NOCMDF,X'FF'       SAY NONE\n         B     SCANX              GET OUT\nXCHK     CLI   0(R6),C'X'         X?\n         BNE   OCMD               NO\n         CLI   CSOALNM+1,1        LEN=1?\n         BNE   OCMD\n*  MOD TO ALLOW X CMD OR %X CLIST:\n         CLI   CSOAFLG,X'04'      X CLIST?\n         BE    OCMD               YUP.\n         CLI   CSOAFLG,X'40'      X BY ITSELF?\n         BE    OCMD               YUP->CAN'T HELP HIM\n         SPACE\nHAVEX    OI    XFLAG,X'FF'        FLAG EXIT REQUESTED\n         MVI   0(R6),C' '         ERASE 'X' CMD\n         L     R5,CSPLCBUF        R5->CBUF\n         XC    2(2,R5),2(R5)      SET OFFSET TO 0\n         B     CSCAN              LOOK AGAIN\n*\nOCMD     CLI   CSOAFLG,X'20'      OK CMD?\n         BH    GOOD               YES\n         CLI   CSOAFLG,X'04'      CLIST?\n         BNE   NOCMD              NO->BAD\n         OI    CLISTF,X'FF'       YES->FLAG CLIST\nGOOD     LH    R5,CSOALNM         R5=LENGTH\n         LTR   R5,R5              OK?\n         BZ    NOCMD              NO\n         STH   R5,CMDLEN          YES SAVE LEN\n         BCTR  R5,R0              R5-1\n         MVC   CMDNAME,=CL8' '    CLR\nMVCMD    MVC   CMDNAME(0),0(R6)   MOVE NAME\n         EX    R5,MVCMD           WITH LENGTH\nSCANX    L     R14,L1LS\n         BR    R14\n         EJECT\nXCMD     ST    R14,L1LS\n         TM    XFLAG,X'FF'        X?\n         BZR   R14                NO\n         TM    NOCMDF,X'FF'       ANY REAL CMD PRESENT?\n         BNZR  R14                NO\n         CLC   CMDNAME,=CL8'TIME' ?\n         BNE   CKEXEC             NO\n         MVC   CMDNAME,=CL8'IKJEFT25'  USE REAL NAME\n         B     ATTCMD             SKIP AUTH CHECK\nCKEXEC   TM    CLISTF,X'FF'       IMPLICIT CLIST?\n         BZ    ACF2BLDL           NO->ISSUE AUTH CHECK\nUEXEC    L     R5,CSPLCBUF        R5->CMD BUFF\n         XC    2(2,R5),2(R5)      CLEAR OFFSET\n         MVC   CMDNAME,=CL8'EXEC' USE EXEC CMD\n         B     ATTCMD             GO ATTACH\nACF2BLDL EQU   *                  ZAP TO ACF2 SVC HERE:\n         AIF   ('&SYSPARM' EQ 'XATSOE').XA1\n         AIF   ('&SYSPARM' NE '').ACF1\n.XA1     MVC   BLDLIST(4),=X'0001000E'  1 ENTRY, 14 BYTES\n         AGO   .NACF1                                             WDPSC\n.ACF1    ANOP                                                     WDPSC\n         MVC   BLDLIST(4),=X'00010008'  1 ENTRY, 8 BYTES (ACF2 CMD LIM)\n.NACF1   ANOP                                                     WDPSC\n         MVC   BLDNAME,CMDNAME    GET CHECK NAME\n         BLDL  0,BLDLIST          SEARCH FOR IT\n         AIF   ('&SYSPARM' EQ 'XATSOE').NACF2\n         AIF   ('&SYSPARM' EQ '').NACF2\n         ORG   *-2\n         SVC   &SYSPARM WDPSC=247 SUBSTITUTE ACF2 CMD LIMIT SVC\n.NACF2   ANOP                                                     WDPSC\n         LTR   R15,R15            FOUND IT?\n         BNZ   UEXEC              NO->TRY IT AS A CLIST\nATTCMD   BAL   R14,ATTACH         YES->ATTACH THE COMMAND\n*\nXX       L     R14,L1LS\n         BR    R14\n         EJECT\nCLEANUP  ST    R14,L1LS\n         TM    XFLAG,X'FF'        WAS X REQ?\n         BZ    NOXC               NO\n         XC    CSOACNM(6),CSOACNM YES->CLEAR CMD INDICATORS\n         MVI   CSOAFLG,CSOANOC    ETC\n         CLC   WASCMD,=CL8'TEST'  UNDER TEST?\n         BNE   XR                 NO\n         MVI   CSOALNM+1,1        TEST MUST HAVE CMD\n         MVI   ECTSCMD,C'W'       SO SET UP PSUEDO 'W' CMD\n         MVI   CSOAFLG,CSOAVNP    NO PARMS\n         LA    R1,ECTSCMD         R1->W\n         ST    R1,CSOACNM         PASS\nXR       SLR   R15,R15            RC=0\n         BR    R14                CONTINUE\nNOXC     L     R15,SCANRC         RESTORE SCAN RC\n         BR    R14\n         EJECT\nATTACH   ST    R14,L2LS\n         MVC   IOPLSTK(12),CSPL   INIT IOPL\n         MVC   WASCMD,ECTPCMD     SAVE CMD NAME\n         MVC   ECTSCMD,=CL8' '    CLEAR SUB CMD\n         MVC   ECTPCMD,CMDNAME    GET NEW PRIME\n         NI    ECTSWS,255-ECTNOPD-ECTATRM\n         TM    CSOAFLG,CSOAVNP    OPS?\n         BZ    CE                 YES\n         OI    ECTSWS,ECTNOPD     NO\n         SPACE\nCE       XC    ECB,ECB            CLEAR AN ECB\n         XC    STXL(SL),STXL      CLR STAX PARM LIST\n         SPACE\n         STAX  STAXEX,USADDR=ECB,REPLACE=NO,MF=(E,STXL)\n         EJECT\n         MVC   CPPLCBUF,CSPLCBUF\n         MVC   CPPLUPT,CSPLUPT\n         MVC   CPPLECT,CSPLECT\n         L     R1,540             R1->TCB\n         L     R1,180(,R1)        R1->JSCB\n         L     R1,264(,R1)        R1->PSCB\n         ST    R1,CPPLPSCB        PASS TO CMD\n         LA    R1,CPPL            R1->CPPL\n         MVC   ATTL(AE-ATTP),ATTP  INIT ATTACH LIST\n         LA    R15,ATTL           R15->ATTACH PARM LIST\n         ATTACH EPLOC=CMDNAME,ECB=ECB,MF=(E,(1)),               XXXXXXXX\n               SF=(E,(15)),ESTAI=(STAIX,ECB)\n         ST    R1,TCBA            SAVE TCB ADDR\n         LTR   R15,R15            OK?\n         BZ    WAITIT             YES->WAIT TIL DONE\n         BAL   R14,ATTERR         NO->CALL ERROR SUB\n         B     ATTX               EXIT\n         EJECT\nWAITIT   WAIT  ECB=ECB\n         DETACH TCBA,STAE=YES\n         STAX\n         MVC   ECTRTCD(3),ECB+1   GET CODE\n         TM    ECB+4,3            ERROR END?\n         BZ    NOERR\n         BAL   R14,CMDERR         CALL CMD ERROR SUBRTN\nNOERR    MVC   ECTSCMD,ECTPCMD    MOVE EXIT CMD TO SUBCMD\n         MVC   ECTPCMD,WASCMD     RESTORE MAJOR CMD NAME\n         EJECT\n*\n*              ISSUE MODE MSG IF  USER WISHES:\n*                                 (NOT NEEDED - 6/17/82)\n*              ACCOUNT,EDIT,PEEK AND TEST HANDLE MODE MSGS THEMSELVES,\n*              EIS61 MAY NEED REWRITING IN EISATTN.\n*\n*        L     R6,CSPLUPT         R6->UPT\n*        USING UPT,R6\n*        TM    UPTSWS,UPTMODE     MODE MSG DESIRED?\n*        BZ    ATTX               NO!\n*        DROP  R6\n*        MVC   MH(4),=X'000C0000' MSG LEN,OFFSET\n*        PUTLINE PARM=PUTL,TERMPUT=EDIT,MF=(E,IOPLSTK),\n*              OUTPUT=(MH,TERM,SINGLE,DATA)\n*\n*        EXIT FROM ATTACH ROUTINE:\n*\nATTX     L     R14,L2LS\n         BR    R14\n         EJECT\n*\n*              ISUUE MESSAGE IF ERROR IN ATTACH:\n*\nATTERR   ST    R14,L3LS\n         ST    R15,ATTRC\n         MVC   MSGA(CMDERR2+2-CMDERRM),CMDERRM MOVE MSG TO WORK\n         LA    R10,MSGA\n         USING CMDERRM,R10\n         MVC   CMDERR1(8),=CL8'ATTACH'\n         UNPK  CMDERR2(3),ATTRC+3(2)\n         TR    CMDERR2(2),TRANS-240\n         TPUT  (R10),CMDERR2+2-CMDERRM\n         DROP  R10\n         L     R14,L3LS\n         BR    R14\n         EJECT\n*\n*              ISSUE MSG IF ABEND OR ATTENTION OCCURED:\n*\nCMDERR   ST    R14,L3LS\n         ST    R15,SCANRC\n         MVC   MSGA(DETMSGE-DETMSG),DETMSG  MOVE MSG TO WORK\n         LA    R10,MSGA\n         USING DETMSG,R10\n         LA    R1,DETMSG1\n         ST    R1,DETMSG+4\n         TM    ECB+4,2            ATTN?\n         BZ    DETABND            NO\n         MVC   DETMSGA(12),=CL12'ATTENTION.' COMPLETE MSG\n         B     DETPUTL\nDETABND  MVC   DETMSGA(6),=CL6'ABEND'\n         UNPK  DETMSGA+6(7),ECB+1(4)\n         TR    DETMSGA+6(6),TRANS-240\n         MVI   DETMSGA+12,C'.'\nDETPUTL  MVC   DETMSGB(8),ECTPCMD MOVE IN CMD NAME\n         DROP  R10\n         PUTLINE PARM=PUTL,TERMPUT=EDIT,MF=(E,IOPLSTK),                X\n               OUTPUT=(MSGA,TERM,SINGLE,INFOR)\n         L     R14,L3LS\n         BR    R14\n         EJECT\nSTAXEX   L     R1,8(R1)           CP ECB ADDR\n         OI    4(R1),2            SET ATTN SWCH\n         POST  (R1),4             POST CP DONE\n         BR    R14\n*\nSTAIX    LA    R3,12\n         USING  *,R15\n         CR    R0,R3              SDWA PRESENT?\n         BE    XSET               NO USE R2\n         USING  SDWA,R1\n         L     R2,SDWAPARM\n         SETRP RC=16\nXSET     OI    4(R2),1            SET ABEND FLG\n         LA    R15,16             CONTINUE ABEND\n         BR    R14\n         DROP  R15,R1\n         EJECT\n*\n*              CONSTANT AREAS:\n*\nTRANS    DC    C'0123456789ABCDEF '\nATTP     ATTACH SHSPV=78,SZERO=NO,SF=L\nAE       EQU   *\n         SPACE 2\n         LTORG\n         SPACE 2\nDETMSG   DC    A(1,DETMSG1)\nDETMSG1  DC    Y(DETMSGE-DETMSG1,0),C'SCXSCAN COMMAND '''\nDETMSGB  DC    C'XXXXXXXX'' TERMINATED DUE TO '\nDETMSGA  DC    C'XXXXXXXXXXX  '\nDETMSGE  EQU   *\nCMDERRM  DC    C'TSO MAIN COMMAND SYSTEM ERROR - SCXSCAN '\nCMDERR1  DC    C'XXXXXXXX ERROR CODE '\nCMDERR2  DC    C'XX '\n         EJECT\nWORKAREA DSECT\nSAVEAREA DS    18F\nSCANRC   DS    F\nATTRC    DS    F\nXFLAG    DS    X\nNOCMDF   DS    X\nCLISTF   DS    X\nCMDLEN   DS    H\nCMDNAME  DS    CL8\nMH       DS    F\nWASCMD   DS    CL8\nL1LS     DS    F\nL2LS     DS    F\nL3LS     DS    F\nBLDLIST  DS    H\n         DS    H\nBLDNAME  DS    CL8\n         DS    F\nECB      DS    D                  ECB AND FLAGS\nCPPLA    DS    4F\nSTXL     STAX  MF=L\nSL       EQU   *-STXL\nATTL     DS    CL(AE-ATTP)\nTCBA     DS    F\nMSGA     DS    CL100\nIOPLSTK  DS    4F\nPUTL     DS    3F\nWORKLEN  EQU   *-WORKAREA\n         EJECT\n         IKJECT\n         IKJUPT\n         IKJCPPL\n         IKJCSPL\n         IKJCSOA\n         IHASDWA\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "SCXSCAN$": {"ttr": 33541, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x00\\x7f\\x00\\x88\\x00\\x7f\\x12\\x00\\x00\\x1b\\x00\\x1b\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf2\\xf7\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-01-07T00:00:00", "modifydate": "1988-01-07T12:00:00", "lines": 27, "newlines": 27, "modlines": 0, "user": "FILE270"}, "text": "++USERMOD (SX00060) /* TSO IKJSCAN FRONTEND FOR 'X' SUBCMD SUPPORT -\n           LINKED INTO IKJTSLAR FOR TSOE R2.1 */ REWORK(19873031).\n++VER (Z038) FMID(JBB2367).\n++JCLIN.\n//XXX00155 JOB (2100,56-D),'KISER 2215 T',CLASS=H,MSGCLASS=T\n//*\n//LKED     EXEC PGM=IEWL,PARM='XREF,LIST,LET,RENT,REFR',REGION=2000K\n//SYSLIN   DD DDNAME=SYSIN\n//SYSLMOD  DD DISP=SHR,DSN=SYS1.LPALIB\n//LPALIB   DD  DISP=SHR,DSN=SYS1.LPALIB\n//SOFTLOAD DD  DISP=SHR,DSN=WDPSC.SOFTLOAD\n//AOST4    DD  DISP=SHR,DSN=SYS1.AOST4\n//SYSUT1   DD UNIT=SYSDA,SPACE=(1024,(50,20))\n//SYSPUNCH DD DSN=&&TEMP,DISP=SHR\n//SYSPRINT DD SYSOUT=*\n//SYSIN DD *\n INCLUDE SOFTLOAD(SCXSCAN)\n CHANGE IKJSCAN(IBMSCAN)\n INCLUDE AOST4(IKJTSLAR)\n ORDER   IKJTSLAR\n MODE    RMODE(24),AMODE(ANY)\n ENTRY   IKJTSLAR\n ALIAS   IKJCT441,IKJEFF02,IKJGETL,IKJPARS,IKJPTGT,IKJPUTL,IKJSCAN\n ALIAS   IKJSTCK\n NAME    IKJTSLAR(R)\n++MOD(SCXSCAN) LKLIB(SOFTLOAD).\n++MOD(IKJTSLAR) LKLIB(AOST4).\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "SERLCON$": {"ttr": 33543, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x00\\x7f\\x00\\x88\\x00\\x7f\\x12\\x00\\x008\\x008\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf2\\xf7\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-01-07T00:00:00", "modifydate": "1988-01-07T12:00:00", "lines": 56, "newlines": 56, "modlines": 0, "user": "FILE270"}, "text": "1                                                        SERLCONV.1\n                                                         06/25/82\n\n\n  PROGRAM:       SERLCONV\n  AUTHOR:        Charles J. Wilson\n  AGENCY:        Dept. of Labor and Industries\n  LANGUAGE:      COBOL\n  LOCATION:      WDPSC.SHARED.LOAD\n  FUNCTION:      Convert serial dates to standard date format after\n                 date validation.\n\n  RUN MODE:      N/A...this is a subroutine.\n\n  This is a subroutine which accepts  a serial date and converts it\n  to a standard date  of the form MMDDYY if and  only if the serial\n  date  is a  valid  date.  A  serial  date is  of  the form  NNNNN\n  representing the displacement from the beginning of the twentieth\n  century.   For example  January  1, 1900  is  serial date  00001,\n  January 2, 1900  is serial date 00002, January 1,  1901 is serial\n  date 00366 (since 1900  was not a leap year), and  so on.  Serial\n  dates  are generated  from standard  dates  by program  STOJCONV.\n  Thus,  this   program  reverses  the  conversion   that  STOJCONV\n  performs.\n\n\n\n\n1                                                        SERLCONV.2\n                                                         06/25/82\n\n\n  HOW TO USE THIS PROGRAM:\n\n  Place the following 01 level into your WORKING STORAGE SECTION:\n\n       01   SERLCONV-I-O-AREA.\n            05   FILLER                        PIC X(8).\n            05   SERIAL-DATE                   PIC X(5).\n            05   STANDARD-DATE                 PIC X(6).\n            05   VALID-INPUT                   PIC X(3).\n\n  Do the following in your PROCEDURE DIVISION:\n\n       MOVE your date to be converted TO\n            SERIAL-DATE OF SERLCONV-I-O-AREA.\n       CALL 'SERLCONV' USING SERLCONV-I-O-AREA.\n       If VALID-INPUT NOT EQUAL 'YES'\n            do your error routine\n       ELSE\n            Your date is now in standard format and is available\n            in STANDARD-DATE OF SERLCONV-I-O-AREA.\n\n\n\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "SERLCONV": {"ttr": 33545, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x00\\x7f\\x00\\x88\\x00\\x7f\\x12\\x00\\x01M\\x01M\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf2\\xf7\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-01-07T00:00:00", "modifydate": "1988-01-07T12:00:00", "lines": 333, "newlines": 333, "modlines": 0, "user": "FILE270"}, "text": "000010 ID DIVISION.                                                     04/14/76\n000020 PROGRAM-ID. SERLCONV.                                            23528SER\n000030 AUTHOR.     CHARLES J. WILSON.                                   L  LV002\n000040 INSTALLATION.  LABOR AND INDUSTRIES.\n000050 DATE-WRITTEN.   JUNE 9, 1975.\n000060 DATE-COMPILED.\n000070 REMARKS.\n000080*****************************************************************\n000090*  THIS PROGRAM IS A CALLED MODULE THAT PERFORMS TWO FUNCTIONS: *\n000100*                                                               *\n000110*    1.  EDITS FOR THE VALIDITY OF THE 5 DIGIT SERIAL DATE THAT\n000120*        IS BEING PASSED TO THIS MODULE AND MOVES 'NO' TO\n000130*        VALID-INPUT OF SERLCONV-I-O-AREA IF THE DATE BEING\n000140*        PASSED CANNOT BE CONVERTED TO STANDARD (MMDDYY) FORMAT.\n000150*        OTHERWISE 'YES' IS MOVED TO VALID-INPUT OF\n000160*        SERLCONV-I-O-AREA.\n000170*\n000180*    2.  THE INPUT SERIAL-DATE IS CONVERTED BY TABLE LOOK-UP\n000190*        TO JULIAN (YYDDD) FORMAT. THIS MODULE THEN CALLS\n000200*        'JTOSDATE' AND AFTER REFORMATTING THE RESULT MOVES IT TO\n000210*        STANDARD-DATE OF SERLCONV-I-O-AREA SO THAT IT IS\n000220*        AVAILABLE TO THE CALLING MODULE.\n000230*\n000240*                                                               *\n000250*****************************************************************\n000260     EJECT\n000270 ENVIRONMENT DIVISION.\n000280 CONFIGURATION SECTION.\n000290 SOURCE-COMPUTER. IBM-370-158.\n000300 OBJECT-COMPUTER. IBM-370-158.\n000310     EJECT\n000320 DATA DIVISION.\n000330\n000340 WORKING-STORAGE SECTION.\n000350\n000360 77  WORK-STOR  VALUE 'WORKING  STORAGE'     PIC X(16).\n000370\n000380 01  INTERMEDIATE-WORK-DATE.\n000390     05  MONTH                               PIC 99.\n000400     05  DAYY                                PIC 99.\n000410     05  YEAR                                PIC 99.\n000420\n000430 01  STANDARD-DATE-WORK.\n000440     05  YEAR                                PIC 99.\n000450     05  MONTH                               PIC 99.\n000460     05  DAYY                                PIC 99.\n000470\n000480\n000490 01  CALCULATE-RESULTS.\n000500     05  QUOTEN.\n000510         10  QUOTENTS                        PIC S99V9.\n000520     05  QUOTEN-BREAK REDEFINES QUOTEN.\n000530         10  QUOT-NUM                        PIC S99V.\n000540         10  QUOT-REMAIN                     PIC SV9.\n000550\n000560 01  JULIAN-DATE-WORK                        PIC 9(05).\n000570     SKIP2\n       01  SERIAL-DATE-CONVERSION-TABLE.\n           05  DATE-TABLE.\n               10  DATE-TABLE-VALUES.\n                   15  YEAR-00     VALUE '00'      PIC X(2).\n                   15  S-V-00      VALUE 00365     PIC 9(5).\n                   15  YEAR-01     VALUE '01'      PIC X(2).\n                   15  S-V-01      VALUE 00730     PIC 9(5).\n                   15  YEAR-02     VALUE '02'      PIC X(2).\n                   15  S-V-02      VALUE 01095     PIC 9(5).\n                   15  YEAR-03     VALUE '03'      PIC X(2).\n                   15  S-V-03      VALUE 01460     PIC 9(5).\n                   15  YEAR-04     VALUE '04'      PIC X(2).\n                   15  S-V-04      VALUE 01826     PIC 9(5).\n                   15  YEAR-05     VALUE '05'      PIC X(2).\n                   15  S-V-05      VALUE 02191     PIC 9(5).\n                   15  YEAR-06     VALUE '06'      PIC X(2).\n                   15  S-V-06      VALUE 02556     PIC 9(5).\n                   15  YEAR-07     VALUE '07'      PIC X(2).\n                   15  S-V-07      VALUE 02921     PIC 9(5).\n                   15  YEAR-08     VALUE '08'      PIC X(2).\n                   15  S-V-08      VALUE 03287     PIC 9(5).\n                   15  YEAR-09     VALUE '09'      PIC X(2).\n                   15  S-V-09      VALUE 03652     PIC 9(5).\n                   15  YEAR-10     VALUE '10'      PIC X(2).\n                   15  S-V-10      VALUE 04017     PIC 9(5).\n                   15  YEAR-11     VALUE '11'      PIC X(2).\n                   15  S-V-11      VALUE 04382     PIC 9(5).\n                   15  YEAR-12     VALUE '12'      PIC X(2).\n                   15  S-V-12      VALUE 04748     PIC 9(5).\n                   15  YEAR-13     VALUE '13'      PIC X(2).\n                   15  S-V-13      VALUE 05113     PIC 9(5).\n                   15  YEAR-14     VALUE '14'      PIC X(2).\n                   15  S-V-14      VALUE 05478     PIC 9(5).\n                   15  YEAR-15     VALUE '15'      PIC X(2).\n                   15  S-V-15      VALUE 05843     PIC 9(5).\n                   15  YEAR-16     VALUE '16'      PIC X(2).\n                   15  S-V-16      VALUE 06209     PIC 9(5).\n                   15  YEAR-17     VALUE '17'      PIC X(2).\n                   15  S-V-17      VALUE 06574     PIC 9(5).\n                   15  YEAR-18     VALUE '18'      PIC X(2).\n                   15  S-V-18      VALUE 06939     PIC 9(5).\n                   15  YEAR-19     VALUE '19'      PIC X(2).\n                   15  S-V-19      VALUE 07304     PIC 9(5).\n                   15  YEAR-20     VALUE '20'      PIC X(2).\n                   15  S-V-20      VALUE 07670     PIC 9(5).\n                   15  YEAR-21     VALUE '21'      PIC X(2).\n                   15  S-V-21      VALUE 08035     PIC 9(5).\n                   15  YEAR-22     VALUE '22'      PIC X(2).\n                   15  S-V-22      VALUE 08400     PIC 9(5).\n                   15  YEAR-23     VALUE '23'      PIC X(2).\n                   15  S-V-23      VALUE 08765     PIC 9(5).\n                   15  YEAR-24     VALUE '24'      PIC X(2).\n                   15  S-V-24      VALUE 09131     PIC 9(5).\n                   15  YEAR-25     VALUE '25'      PIC X(2).\n                   15  S-V-25      VALUE 09496     PIC 9(5).\n                   15  YEAR-26     VALUE '26'      PIC X(2).\n                   15  S-V-26      VALUE 09861     PIC 9(5).\n                   15  YEAR-27     VALUE '27'      PIC X(2).\n                   15  S-V-27      VALUE 10226     PIC 9(5).\n                   15  YEAR-28     VALUE '28'      PIC X(2).\n                   15  S-V-28      VALUE 10592     PIC 9(5).\n                   15  YEAR-29     VALUE '29'      PIC X(2).\n                   15  S-V-29      VALUE 10957     PIC 9(5).\n                   15  YEAR-30     VALUE '30'      PIC X(2).\n                   15  S-V-30      VALUE 11322     PIC 9(5).\n                   15  YEAR-31     VALUE '31'      PIC X(2).\n                   15  S-V-31      VALUE 11687     PIC 9(5).\n                   15  YEAR-32     VALUE '32'      PIC X(2).\n                   15  S-V-32      VALUE 12053     PIC 9(5).\n                   15  YEAR-33     VALUE '33'      PIC X(2).\n                   15  S-V-33      VALUE 12418     PIC 9(5).\n                   15  YEAR-34     VALUE '34'      PIC X(2).\n                   15  S-V-34      VALUE 12783     PIC 9(5).\n                   15  YEAR-35     VALUE '35'      PIC X(2).\n                   15  S-V-35      VALUE 13148     PIC 9(5).\n                   15  YEAR-36     VALUE '36'      PIC X(2).\n                   15  S-V-36      VALUE 13514     PIC 9(5).\n                   15  YEAR-37     VALUE '37'      PIC X(2).\n                   15  S-V-37      VALUE 13879     PIC 9(5).\n                   15  YEAR-38     VALUE '38'      PIC X(2).\n                   15  S-V-38      VALUE 14244     PIC 9(5).\n                   15  YEAR-39     VALUE '39'      PIC X(2).\n                   15  S-V-39      VALUE 14609     PIC 9(5).\n                   15  YEAR-40     VALUE '40'      PIC X(2).\n                   15  S-V-40      VALUE 14975     PIC 9(5).\n                   15  YEAR-41     VALUE '41'      PIC X(2).\n                   15  S-V-41      VALUE 15340     PIC 9(5).\n                   15  YEAR-42     VALUE '42'      PIC X(2).\n                   15  S-V-42      VALUE 15705     PIC 9(5).\n                   15  YEAR-43     VALUE '43'      PIC X(2).\n                   15  S-V-43      VALUE 16070     PIC 9(5).\n                   15  YEAR-44     VALUE '44'      PIC X(2).\n                   15  S-V-44      VALUE 16436     PIC 9(5).\n                   15  YEAR-45     VALUE '45'      PIC X(2).\n                   15  S-V-45      VALUE 16801     PIC 9(5).\n                   15  YEAR-46     VALUE '46'      PIC X(2).\n                   15  S-V-46      VALUE 17166     PIC 9(5).\n                   15  YEAR-47     VALUE '47'      PIC X(2).\n                   15  S-V-47      VALUE 17531     PIC 9(5).\n                   15  YEAR-48     VALUE '48'      PIC X(2).\n                   15  S-V-48      VALUE 17897     PIC 9(5).\n                   15  YEAR-49     VALUE '49'      PIC X(2).\n                   15  S-V-49      VALUE 18262     PIC 9(5).\n                   15  YEAR-50     VALUE '50'      PIC X(2).\n                   15  S-V-50      VALUE 18627     PIC 9(5).\n                   15  YEAR-51     VALUE '51'      PIC X(2).\n                   15  S-V-51      VALUE 18992     PIC 9(5).\n                   15  YEAR-52     VALUE '52'      PIC X(2).\n                   15  S-V-52      VALUE 19358     PIC 9(5).\n                   15  YEAR-53     VALUE '53'      PIC X(2).\n                   15  S-V-53      VALUE 19723     PIC 9(5).\n                   15  YEAR-54     VALUE '54'      PIC X(2).\n                   15  S-V-54      VALUE 20088     PIC 9(5).\n                   15  YEAR-55     VALUE '55'      PIC X(2).\n                   15  S-V-55      VALUE 20453     PIC 9(5).\n                   15  YEAR-56     VALUE '56'      PIC X(2).\n                   15  S-V-56      VALUE 20819     PIC 9(5).\n                   15  YEAR-57     VALUE '57'      PIC X(2).\n                   15  S-V-57      VALUE 21184     PIC 9(5).\n                   15  YEAR-58     VALUE '58'      PIC X(2).\n                   15  S-V-58      VALUE 21549     PIC 9(5).\n                   15  YEAR-59     VALUE '59'      PIC X(2).\n                   15  S-V-59      VALUE 21914     PIC 9(5).\n                   15  YEAR-60     VALUE '60'      PIC X(2).\n                   15  S-V-60      VALUE 22280     PIC 9(5).\n                   15  YEAR-61     VALUE '61'      PIC X(2).\n                   15  S-V-61      VALUE 22645     PIC 9(5).\n                   15  YEAR-62     VALUE '62'      PIC X(2).\n                   15  S-V-62      VALUE 23010     PIC 9(5).\n                   15  YEAR-63     VALUE '63'      PIC X(2).\n                   15  S-V-63      VALUE 23375     PIC 9(5).\n                   15  YEAR-64     VALUE '64'      PIC X(2).\n                   15  S-V-64      VALUE 23741     PIC 9(5).\n                   15  YEAR-65     VALUE '65'      PIC X(2).\n                   15  S-V-65      VALUE 24106     PIC 9(5).\n                   15  YEAR-66     VALUE '66'      PIC X(2).\n                   15  S-V-66      VALUE 24471     PIC 9(5).\n                   15  YEAR-67     VALUE '67'      PIC X(2).\n                   15  S-V-67      VALUE 24836     PIC 9(5).\n                   15  YEAR-68     VALUE '68'      PIC X(2).\n                   15  S-V-68      VALUE 25202     PIC 9(5).\n                   15  YEAR-69     VALUE '69'      PIC X(2).\n                   15  S-V-69      VALUE 25567     PIC 9(5).\n                   15  YEAR-70     VALUE '70'      PIC X(2).\n                   15  S-V-70      VALUE 25932     PIC 9(5).\n                   15  YEAR-71     VALUE '71'      PIC X(2).\n                   15  S-V-71      VALUE 26297     PIC 9(5).\n                   15  YEAR-72     VALUE '72'      PIC X(2).\n                   15  S-V-72      VALUE 26663     PIC 9(5).\n                   15  YEAR-73     VALUE '73'      PIC X(2).\n                   15  S-V-73      VALUE 27029     PIC 9(5).\n                   15  YEAR-74     VALUE '74'      PIC X(2).\n                   15  S-V-74      VALUE 27393     PIC 9(5).\n                   15  YEAR-75     VALUE '75'      PIC X(2).\n                   15  S-V-75      VALUE 27758     PIC 9(5).\n                   15  YEAR-76     VALUE '76'      PIC X(2).\n                   15  S-V-76      VALUE 28124     PIC 9(5).\n                   15  YEAR-77     VALUE '77'      PIC X(2).\n                   15  S-V-77      VALUE 28489     PIC 9(5).\n                   15  YEAR-78     VALUE '78'      PIC X(2).\n                   15  S-V-78      VALUE 28854     PIC 9(5).\n                   15  YEAR-79     VALUE '79'      PIC X(2).\n                   15  S-V-79      VALUE 29219     PIC 9(5).\n                   15  YEAR-80     VALUE '80'      PIC X(2).\n                   15  S-V-80      VALUE 29585     PIC 9(5).\n                   15  YEAR-81     VALUE '81'      PIC X(2).\n                   15  S-V-81      VALUE 29950     PIC 9(5).\n                   15  YEAR-82     VALUE '82'      PIC X(2).\n                   15  S-V-82      VALUE 30315     PIC 9(5).\n                   15  YEAR-83     VALUE '83'      PIC X(2).\n                   15  S-V-83      VALUE 30680     PIC 9(5).\n                   15  YEAR-84     VALUE '84'      PIC X(2).\n                   15  S-V-84      VALUE 31046     PIC 9(5).\n                   15  YEAR-85     VALUE '85'      PIC X(2).\n                   15  S-V-85      VALUE 31411     PIC 9(5).\n                   15  YEAR-86     VALUE '86'      PIC X(2).\n                   15  S-V-86      VALUE 31776     PIC 9(5).\n                   15  YEAR-87     VALUE '87'      PIC X(2).\n                   15  S-V-87      VALUE 32141     PIC 9(5).\n                   15  YEAR-88     VALUE '88'      PIC X(2).\n                   15  S-V-88      VALUE 32507     PIC 9(5).\n                   15  YEAR-89     VALUE '89'      PIC X(2).\n                   15  S-V-89      VALUE 32872     PIC 9(5).\n                   15  YEAR-90     VALUE '90'      PIC X(2).\n                   15  S-V-90      VALUE 33237     PIC 9(5).\n                   15  YEAR-91     VALUE '91'      PIC X(2).\n                   15  S-V-91      VALUE 33602     PIC 9(5).\n                   15  YEAR-92     VALUE '92'      PIC X(2).\n                   15  S-V-92      VALUE 33968     PIC 9(5).\n                   15  YEAR-93     VALUE '93'      PIC X(2).\n                   15  S-V-93      VALUE 34333     PIC 9(5).\n                   15  YEAR-94     VALUE '94'      PIC X(2).\n                   15  S-V-94      VALUE 34698     PIC 9(5).\n                   15  YEAR-95     VALUE '95'      PIC X(2).\n                   15  S-V-95      VALUE 35063     PIC 9(5).\n                   15  YEAR-96     VALUE '96'      PIC X(2).\n                   15  S-V-96      VALUE 35429     PIC 9(5).\n                   15  YEAR-97     VALUE '97'      PIC X(2).\n                   15  S-V-97      VALUE 35794     PIC 9(5).\n                   15  YEAR-98     VALUE '98'      PIC X(2).\n                   15  S-V-98      VALUE 36159     PIC 9(5).\n                   15  YEAR-99     VALUE '99'      PIC X(2).\n                   15  S-V-99      VALUE 36524     PIC 9(5).\n           05  CONVERSION-TABLE REDEFINES DATE-TABLE.\n               10  CONVERSION-VALUES OCCURS 100 TIMES.\n                   15  CONV-YEAR                   PIC X(2).\n                   15  CONV-FACTOR                 PIC 9(5).\n       01  SERIAL-YEAR-X                           PIC X(2).\n       01  SERIAL-YEAR-9 REDEFINES SERIAL-YEAR-X   PIC 9(2).\n       01  BINARY-YEAR     COMPUTATIONAL           PIC S9(4).\n       01  SERIALIZED-DATE                         PIC 9(5).\n       01  YEAR-QUOT       COMPUTATIONAL-3         PIC S9(3).\n       01  YEAR-REM        COMPUTATIONAL-3         PIC S9(3).\n       01  JULIAN-BREAKDOWN.\n           05  JULIAN-YEAR                         PIC 9(2).\n           05  JULIAN-DAY                          PIC 9(3).\n       01  SAVE-SERIAL-DATE                        PIC 9(5).\n       01  SERIAL-DATE-X                           PIC X(5).\n       01  SERIAL-DATE-9 REDEFINES SERIAL-DATE-X   PIC 9(5).\n002790     EJECT\n002800 LINKAGE SECTION.\n002810\n       01  SERLCONV-I-O-AREA.\n           05  MODULE-NAME                         PIC X(8).\n           05  SERIAL-DATE                         PIC X(5).\n           05  STANDARD-DATE                       PIC X(6).\n           05  VALID-INPUT                         PIC X(3).\n\n\n002910     EJECT\n002920 PROCEDURE DIVISION USING SERLCONV-I-O-AREA.\n002930\n002940 0100.\n002950     MOVE 'SERLCONV' TO MODULE-NAME OF SERLCONV-I-O-AREA.\n002960     MOVE SERIAL-DATE OF SERLCONV-I-O-AREA TO SERIAL-DATE-X.\n002970     SKIP2\n002980     IF SERIAL-DATE-X IS NOT NUMERIC\n002990         MOVE 'NO' TO VALID-INPUT OF SERLCONV-I-O-AREA\n003000         GO TO 99900-GOBACK.\n003010     SKIP2\n003020     IF SERIAL-DATE-9 IS LESS THAN 00001\n003030         MOVE 'NO' TO VALID-INPUT OF SERLCONV-I-O-AREA\n003040         GO TO 99900-GOBACK.\n003050     SKIP2\n003060     IF SERIAL-DATE-9 IS GREATER THAN 36524\n003070         MOVE 'NO' TO VALID-INPUT OF SERLCONV-I-O-AREA\n003080         GO TO 99900-GOBACK.\n003090     SKIP2\n003100     MOVE 'YES' TO VALID-INPUT OF SERLCONV-I-O-AREA.\n003110     MOVE SERIAL-DATE-9 TO SAVE-SERIAL-DATE.\n003120     SKIP2\n003130     IF SERIAL-DATE-9 IS GREATER THAN 00059\n003140         ADD 1 TO SAVE-SERIAL-DATE.\n003150     SKIP2\n003160     DIVIDE SERIAL-DATE-9 BY 365.25 GIVING YEAR-QUOT.\n003170     IF YEAR-QUOT IS EQUAL TO ZERO\n003180         MOVE SAVE-SERIAL-DATE TO JULIAN-DATE-WORK\n003190         GO TO 10000-CALL-JTOSDATE.\n003200     MOVE YEAR-QUOT TO BINARY-YEAR.\n003210     SUBTRACT CONV-FACTOR (BINARY-YEAR) FROM SERIAL-DATE-9\n003220         GIVING SERIALIZED-DATE.\n003230     MOVE SERIALIZED-DATE TO JULIAN-BREAKDOWN.\n003240     MOVE YEAR-QUOT TO JULIAN-YEAR OF JULIAN-BREAKDOWN.\n003250     MOVE JULIAN-BREAKDOWN TO JULIAN-DATE-WORK\n003260     GO TO 10000-CALL-JTOSDATE.\n003270     SKIP2\n003280 10000-CALL-JTOSDATE.\n003290     CALL 'JTOSDATE' USING JULIAN-DATE-WORK STANDARD-DATE-WORK.\n003300     MOVE CORR STANDARD-DATE-WORK TO INTERMEDIATE-WORK-DATE.\n003310     MOVE INTERMEDIATE-WORK-DATE TO STANDARD-DATE OF\n003320         SERLCONV-I-O-AREA.\n003330     GO TO 99900-GOBACK.\n003340     SKIP2\n003350 99900-GOBACK.\n003360     SKIP2\n003370     GOBACK.\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "SETRC": {"ttr": 33793, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x00\\x7f\\x00\\x88\\x00\\x7f\\x12\\x00\\x00[\\x00[\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf2\\xf7\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-01-07T00:00:00", "modifydate": "1988-01-07T12:00:00", "lines": 91, "newlines": 91, "modlines": 0, "user": "FILE270"}, "text": "         TITLE 'PROGRAM TO SET COND CODES FOR PROCEDURES,ETC'\n*\n* IF THE PARM FIELD CONTAINS JUST A NUMBER, IT IS RETURNED AS COND CODE\n*\n* IF JUST CHARS, THE FIRST IS CONVERTED TO DECIMAL AND RETURNED.\n*\n* IF A NUMBER FOLLOWED BY CHARS IS PRESENT, THE NUMBER IS USED AS AN\n*    INDEX INTO THE CHAR STRING AND THAT CHAR IS RETURNED.\n*    (A BLANK OR COMMA IMMEDIATELY FOLLOWING THE NUMBER IS IGNORED)\n*\n* IF PARM IS NULL OR CHAR REQUESTED IS NOT PRESENT, CODE IS ZERO\n*\n* LEADING BLANKS ARE IGNORED\n*\n* EXAMPLES:\n*\n*  EXEC PGM=SETRC,PARM='99'    SETS COND CODE = 99\n*\n*  EXEC PGM=SETRC,PARM='A'     SETS COND CODE = 193\n*\n*  EXEC PGM=SETRC,PARM='AB'    SETS COND CODE = 193\n*\n*  EXEC PGM=SETRC,PARM='2,AB'  SETS COND CODE = 194\n*\n*  EXEC PGM=SETRC,PARM='3 ABC' SETS COND CODE = 195\n*\n*  EXEC PGM=SETRC,PARM='3ABC'  SETS COND CODE = 195\n*\n*  EXEC PGM=SETRC,PARM=''      SETS COND CODE = 0\n*\n*  EXEC PGM=SETRC,PARM='3,AB'  SETS COND CODE = 0\n*\n*  EXEC PGM=SETRC,PARM=' $'    SETS COND CODE = 91\n         EJECT\nSETRC    ENTERR LEVEL=V2M1\n         L     R11,0(R1)          R11->PARM FIELD\n         LH    R10,0(R11)         R10= PARM LENGTH\n         LA    R11,1(R11)         R11=R11+1\n         SLR   R9,R9              R9=0\n         SLR   R8,R8              R8=0\nLOOP1    LA    R11,1(R11)         R11=R11+1\n         CLI   0(R11),C' '        SPACE?\n         BNE   DECODE             NO->ASSUME DATA\n         BCT   R10,LOOP1          YES\n         B     NOVAL\n         EJECT\nDECODE   CLI   0(R11),C' '        SPACE?\n         BE    DELIM              YES\n         CLI   0(R11),C','        COMMA?\n         BE    DELIM              YES\n         TM    0(R11),X'F0'       NUMERIC?\n         BNO   DATA               NO->  TERMINATE SCAN\n         SLR   R2,R2              R2=0\n         TRT   0(1,R11),TABLE     GET VALUE\n         MH    R9,=H'10'          R9=R9*10\n         AR    R9,R2              R9=R9+R2\nSKIPPED  LA    R11,1(R11)         R11=R11+1\n         BCT   R10,DECODE         R10=R10-1 >0 -> LOOP FOR NEXT DIGIT\nNRC      LR    R15,R9             R15 = RC FOR MODULE RETURN\n         B QUIT                                                  WDPSC\n*\nDELIM    LA    R11,1(,R11)        R11+1 - SKIP DELIM\n         SH    R10,=H'1'          LENGTH OF REMAINING PARM FLD\nDATA     LTR   R10,R10            ANY CHARS LEFT?\n         BNP   NRC                NOPE.                          WDPSC\n         CR    R9,R10             CHAR REQUESTED PRESENT?        WDPSC\n         BH    NOVAL                 NOT THERE                   WDPSC\n         LTR   R9,R9                       R9 STILL ZERO? (INDEX)\n         BZ    ICIT                        YUP-NO INDEX GIVEN\n         BCTR  R9,R0              CONVERT INDEX TO OFFSET\nICIT     SLR   R15,R15            ZERO RC                        WDPSC\n         IC    R15,0(R9,R11)         R15=CHAR REQUESTED          WDPSC\n         B     LEAVER                ALL DONE                    WDPSC\n*\nNOVAL    EQU   *\nEXIT     SLR   R15,R15            R15=0\nQUIT     EQU   *\nLEAVER   LEAVER\n*\nTABLE    DC    256X'00'\n         ORG   TABLE+X'F0'\n         DC    X'00010203040506070809'\n         ORG\n         LTORG\n*\n*   WORKING STORAGE AREA - DYNAMIC\n*\nWORKAREA DSECT\nSAVEAREA DS    18F\nWORKLEN  EQU   *-WORKAREA\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "SETRC$": {"ttr": 33796, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x00\\x7f\\x00\\x88\\x00\\x7f\\x12\\x00\\x00%\\x00%\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf2\\xf7\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-01-07T00:00:00", "modifydate": "1988-01-07T12:00:00", "lines": 37, "newlines": 37, "modlines": 0, "user": "FILE270"}, "text": "1 10.225                                                          10.225\n0  SETRC Program                                       SETRC Program\n\n FUNCTION\n\n\n  IF THE PARM FIELD CONTAINS JUST A NUMBER, IT IS RETURNED AS COND CODE\n\n  IF JUST CHARS, THE FIRST IS CONVERTED TO DECIMAL AND RETURNED.\n\n  IF A NUMBER FOLLOWED BY CHARS IS PRESENT, THE NUMBER IS USED AS AN\n     INDEX INTO THE CHAR STRING AND THAT CHAR IS RETURNED.\n     (A BLANK OR COMMA IMMEDIATELY FOLLOWING THE NUMBER IS IGNORED)\n\n  IF PARM IS NULL OR CHAR REQUESTED IS NOT PRESENT, CODE IS ZERO\n\n  LEADING BLANKS ARE IGNORED\n\n  EXAMPLES:\n\n   EXEC PGM=SETRC,PARM='99'    SETS COND CODE = 99\n\n   EXEC PGM=SETRC,PARM='A'     SETS COND CODE = 193\n\n   EXEC PGM=SETRC,PARM='AB'    SETS COND CODE = 193\n\n   EXEC PGM=SETRC,PARM='2,AB'  SETS COND CODE = 194\n\n   EXEC PGM=SETRC,PARM='3 ABC' SETS COND CODE = 195\n\n   EXEC PGM=SETRC,PARM='3ABC'  SETS COND CODE = 195\n\n   EXEC PGM=SETRC,PARM=''      SETS COND CODE = 0\n\n   EXEC PGM=SETRC,PARM='3,AB'  SETS COND CODE = 0\n\n   EXEC PGM=SETRC,PARM=' $'    SETS COND CODE = 91\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "SETVAR": {"ttr": 33798, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x00\\x7f\\x00\\x88\\x00\\x7f\\x12\\x00\\x00\\xd7\\x00\\xd7\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf2\\xf7\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-01-07T00:00:00", "modifydate": "1988-01-07T12:00:00", "lines": 215, "newlines": 215, "modlines": 0, "user": "FILE270"}, "text": "SETVAR   TITLE ' - SUBROUTINE TO SET A CLIST VARIABLE'\n* WRITTEN BY KERMIT KISER - WASHINGTON STATE DP SERVICE CENTER (WDPSC)\n*\n*              V1M0 - WRITTEN  DEC 1983 TO REPLACE IKJCT433 SUPERZAP\n*\n*              V2M0 - CHANGED  SEP 1985 TO HANDLE TSO/E IKJCT441 CALL\n*                     CODE SYSPARM(TSOE) IN ASSEMBLER PARM\n*             IGNORE ALL COMMENTS BELOW UNLESS RUNNING BOTH\n*\n*              V2M1 - CHANGED  APR 1986 TO ELIMINATE RENT ERROR WITH\n*                     SYSPARM(TSOE) IN ASSEMBLER PARM\n*                     NOTE THAT IT CAN STILL BE LINKED WITH IKJCT433\n*                     TO RUN ON BOTH TSOE AND NON-TSOE SYSTEMS\n*\n*\n*    V2M2 - CHANGED  AUG 14,1989 TO MAKE TSOE (R1.2+) THE DEFAULT\n*           TARGET FOR ASSEMBLY. USE SYSPARM(TSO) TO ASSEMBLE FOR\n*           PRIOR TSO VERSIONS OR SYSPARM(BOTH) TO ASSEMBLE/LINK FOR\n*           BOTH NEW AND OLD SYSTEMS IN ONE LOAD MODULE.\n*           EXTERNAL REFERENCES TO IKJCT433 ARE NOW WEAK. THIS MAY\n*           ELIMINATE ALL THE CALLS I GET ABOUT UNRESOLVED LINK REFS.\n*           THE COMMENTS BELOW APPLY ONLY FOR VANILLA TSO OR TSOE R1.\n*\n*        SETVAR USES THE IKJUPDT INTERFACE TO IKJCT433\n*              TO PUT A VALUE INTO A CLIST VARIABLE.\n*              IKJUPDT IS AN ENTRY TO CLIST PHASE 2 PROCESSING USED\n*              BY GETLINE TO SET SYSDLM AND SYSDVAL.\n*              IT DOES NOT HAVE CAPABILITY TO CREATE VARIABLES,\n*              HENCE SETVAR ENHANCES IT FOR GENERAL USAGE BY MODIFYING\n*              IT TO INTERCEPT THE LOCATE ROUTINE AND FORCE VARIABLE\n*              CREATION IF NOT ALREADY EXISTING. THIS ROUTINE CAN BE\n*              MADE REENTRANT VERY SIMPLY IF YOU HAVE FICHE HANDY\n*              FOR YOUR LEVEL OF THE IKJCT433 MODULE. (SEE BELOW)\n*\n*\n*        NOTE: UNLESS SYSPARM(RELINK) IS CODED IN THE ASSEMBLER PARMS\n*              FOR THIS MODULE, IT WILL PUNCH LINK EDITOR CONTROL CARDS\n*              TO EXTRACT AND LINK IN CSECT IKJCT433 FROM IBM MODULE\n*              IKJPTGT (VIA DD CARD LPALIB) WHICH IS USED TO LOAD\n*              VALUES INTO CLIST VARIABLES. IN ORDER TO RUN THIS MODULE\n*              AS A REENTRANT SUBROUTINE, USE RENT ON LINKEDIT AND ZAP\n*              THE LOCATE SUBROUTINE IN IKJCT433 TO CREATE VARIABLES\n*              WHICH HAVE NOT YET BEEN DEFINED BY THE CLIST.  IF A ZAP\n*              HAS NOT BEEN APPLIED, THE PROGRAM WILL ONLY BE ABLE TO\n*              UPDATE VARIABLES, NOT CREATE THEM, WHEN USED AS\n*              REENTRANT.\n*\n*        TO ZAP FOR REENTRANT USE:\n*           1) REPLACE INSTRUCTION AT LABEL SAVEMVC IN THIS MODULE WITH\n*              INSTRUCTION AT LOCATE +4 (MVC) IN IKJCT433\n*           2) REPLACE INSTRUCTION AT LOCATE +4 IN IKJCT433 WITH\n*              INSTRUCTIONS AT LABEL OURCODE IN THIS MODULE\n         EJECT\n*\n*//*\n*//* A TSO COMMAND USES SETVAR AS FOLLOWS:\n*//*\n*//*     CALL  SETVAR,(UPT,ECT,ECB,UPLIST)\n*//*\n*//*          UPT = USER PROFILE TABLE       (FROM CPPL)\n*//*          ECT = ENVIRONMENT CONTROL TABLE   \"   \"\n*//*          ECB = COMMAND PROCESSOR ECB\n*//*          UPLIST = A FOUR WORD BLOCK AS BELOW:\n*//*\nUPLIST  DSECT\nLOCPTR  DS  AL4         PTR TO VARIABLE NAME\nLOCLEN  DS  F           LENGTH OF VARIABLE NAME\nVALPTR  DS  A           PTR TO DATA VALUE\nVALLEN  DS  F           LENGTH OF DATA VALUE\n*//*\n*//* EXAMPLE : SET &VAR = &STR(MYDATA)\n*//*    WOULD NEED THE FOLLOWING CONTROL BLOCK PASSED TO SETVAR:\n*//*\n*//*  UPLIST  DS  0XL16\n*//*  LOCPTR  DC  A(=C'VAR')    PTR TO VARIABLE NAME\n*//*  LOCLEN  DC  F'3'          LENGTH OF VARIABLE NAME\n*//*  VALPTR  DC  A(=C'MYDATA') PTR TO DATA VALUE\n*//*  VALLEN  DC  F'6'          LENGTH OF DATA VALUE\n*//*\n         LCLC  &TSOPARM\n&TSOPARM SETC  'TSOE'\n         AIF   ('&SYSPARM' EQ '').CHKTYP\n&TSOPARM SETC  '&SYSPARM'\n.CHKTYP  AIF   ('&TSOPARM' EQ 'RELINK').RELINK\n         AIF   ('&TSOPARM' EQ 'TSOE').RELINK\n         PUNCH ' REPLACE IKJEFT30              '\n         PUNCH ' REPLACE IKJEFT35              '\n         PUNCH ' REPLACE IKJEFT40              '\n         PUNCH ' REPLACE IKJEFT45              '\n         PUNCH ' REPLACE IKJEFT52              '\n         PUNCH ' REPLACE IKJEFT53              '\n         PUNCH ' REPLACE IKJEFT54              '\n         PUNCH ' REPLACE IKJEFT55              '\n         PUNCH ' REPLACE IKJEFT56              '\n         PUNCH ' REPLACE IKJRBBMC              '\n         PUNCH ' REPLACE IKJCT434              '\n         PUNCH ' REPLACE IKJCT436              '\n         PUNCH ' INCLUDE LPALIB(IKJPTGT)       '\n         PUNCH ' ORDER SETVAR                  '\n.RELINK  AIF   ('&TSOPARM' NE 'BOTH').CKTSOE\n&TSOPARM SETC  'TSOE'\n.CKTSOE  AIF   ('&TSOPARM' NE 'TSOE').NTSOE\n         IKJTSVT\nCVTPTR   EQU   16\nCVTTVT   EQU   X'9C'\n.NTSOE   ANOP\n         EJECT\nSETVAR   ENTERR LEVEL=V2M2\n         LR    R11,R1                   R11->IKJUPDT PARM LIST\n         EJECT\n*\n*              SETVAR CONTROL ROUTINE:\n*\nSA       BAL   R14,MODIFY               ZAP IKJCT433 LOCATE TO CALL US\n*\nSB       BAL   R14,CALLUPDT             SET THE VARIABLE VIA IKJUPDT\n*\n         EJECT\n         LEAVER\n         EJECT\nMODIFY   ST    R14,L1LS\n         SPACE 1\n         L     R10,=V(ROUTINES)   R10->IKJCT433 SUBROUTINE TABLE\n         WXTRN ROUTINES\n         LTR   R10,R10            PRESENT?\n         BZR   R14                NOPE\n         AIF   ('&TSOPARM' NE 'TSOE').NTSOEL\n         L     R15,CVTPTR         R15->CVT\n         ICM   R15,15,CVTTVT(R15) R15->TSVT?\n         BZ    GETLOC             NO\n         ICM   R15,15,TSVTVACC-TSVT(R15) R15->IKJCT441?\n         BNZR  R14                YES->TSO/E R2+\n.NTSOEL  ANOP\nLOCATE   EQU   16                 MUST EQUAL OFFSET TO LOCATE ADDR\nGETLOC   L     R10,LOCATE(,R10)   R10->LOCATE SUBRTN\n         CLI   0(R10),X'90'       STM?\n         BNE   CANTZAP            NOPE\n         CLC   4(6,R10),OURCODE   IS ZAP ALREADY ON?\n         BE    SWAPPTR            YUP=SKIP IT\n         CLI   4(R10),X'D2'       MVC?\n         BNE   CANTZAP            NOPE\n         AIF   ('&TSOPARM' NE 'TSOE').NTMVC\n         LA    R14,SAVEMVC                       V2M1\n         MVC   0(6,R14),4(R10)  SAVE THE MVC     V2M1\n.NTMVC   AIF   ('&TSOPARM' EQ 'TSOE').TSKIP1\n         MVC   SAVEMVC(6),4(R10)  SAVE THE MVC\n.TSKIP1  ANOP\n         MVC   4(6,R10),OURCODE  ZAP LOCATE TO CALL US FIRST\n         B     SWAPPTR\n*\nOURCODE  L     R15,0(,R1)        R15->INTERCEPT ADDRESS\n         BALR  R14,R15             CALL INTERCEPT CODE\n         SPACE 1\nSWAPPTR  L     R9,12(,R11)        R9->IKJUPDT PARM BLOCK\n         MVC   SAVEAD(4),0(R9)    SAVE THE NAME PTR\n         MVC   0(4,R9),=A(INTRCPT) PASS OUR INTERCEPT ADDRESS INSTEAD\n         SPACE 1\nCANTZAP  L     R14,L1LS\n         BR    R14\n         EJECT\n*\n* THE INTRCPT ROUTINE TO FORCE CREATION OF A VARIABLE:\n*\nINTRCPT  LR    R0,R14                  SAVE RETURN ADDR IN R0\n         USING INTRCPT,R15             TELL ASSEMBLER ABOUT R15\n         L     R14,4(,R13)             R14->HIGH SAVE=WORKAREA\n         USING WORKAREA,R14            TELL ASSMEBLER\n         MVC   0(4,R1),SAVEAD     RESTORE NAME ADDRESS\n         MVC   8(4,R1),=A(F8)     SET CREATE CODE WE NEEDED!\nSAVEMVC  MVC   0(0,R13),0(R13)    OVERLAID WITH ZAPPED INSTR\n         LR    R14,R0\n         BR    R14\nF8       DC    F'8'\n         DROP  R14,R15\n         EJECT\nCALLUPDT ST    R14,L1LS\n         SPACE 1\n         LR    R1,R11             R1->IKJUPDT PARM LIST\n         AIF   ('&TSOPARM' NE 'TSOE').NTSOE2\n         L     R15,CVTPTR         R15->CVT\n         ICM   R15,15,CVTTVT(R15) R15->TSVT?\n         BZ    CALLUP             NO\n         ICM   R15,15,TSVTVACC-TSVT(R15) R15->IKJCT441?\n         BZ    CALLUP             NO\n         L     R14,12(R1)         R14->UPLIST\n         USING UPLIST,R14\n         CALL  (15),(ECODE,LOCPTR,LOCLEN,VALPTR,VALLEN,TOKEN),       XXX\n               VL,MF=(E,PARM441)\n         SPACE 1\n         L     R14,L1LS\n         BR    R14\nECODE    DC    A(TSVEUPDT)\n.NTSOE2  ANOP\n         SPACE 1\nCALLUP   CALL  IKJUPDT            GIVE HIM CONTROL FOR A WHILE\n         WXTRN IKJUPDT\n         SPACE 1\n         L     R14,L1LS\n         BR    R14\n         EJECT\n         LTORG\n         EJECT\nWORKAREA DSECT\nSAVEAREA DS    18F\nL1LS     DS    F\nL2LS     DS    F\nL3LS     DS    F\n*\nSAVEAD   DS    F\n*\nPARM441  DS    7F\nTOKEN    DS    F\n         SPACE 2\nWORKLEN  EQU   *-WORKAREA\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SETVAR#": {"ttr": 33803, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x00\\x7f\\x00\\x88\\x00\\x7f\\x12\\x00\\x00F\\x00F\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf2\\xf7\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-01-07T00:00:00", "modifydate": "1988-01-07T12:00:00", "lines": 70, "newlines": 70, "modlines": 0, "user": "FILE270"}, "text": "//KKT00150 JOB (2100,56-D),'KISER 2215',CLASS=H,MSGCLASS=T\n//*\n//*  THIS IS A JOB TO LINK THE MODULE CALLED SETVAR WHICH CAN\n//*   BE LINKED TO BY A TSO COMMAND TO PLACE DATA INTO CLIST VARIABLES\n//*   FOR LATER REFERENCE.\n//*\n//*  ****NOTE: THIS STEP IS NOT NEEDED ON A TSOE SYSTEM AS SETVAR USES\n//*            THE IBM DEFINED CLIST VARIABLE INTERFACE IKJCT441 THERE.\n//*\n//*            THIS STEP IS NOT NEEDED IF NO SYSPARM WAS USED IN THE\n//*            JOB WHICH ASSEMBLED SETVAR AND THE LINK STEP HAD A DD\n//*            CARD OF 'LPALIB' FOR THE LIBRARY CONTAINING IKJPTGT...\n//*\n//*   IKJUPDT AND ROUTINES (SETVAR VCONS) ARE ENTRY POINTS IN CSECT\n//*   IKJCT433 OF IBM LOAD MODULE IKJPTGT (PUTGET).\n//*\n//* *******   IGNORE UNRESOLVED SYMBOLS - THEY ARE NORMAL\n//*\n//LKED    EXEC PGM=IEWL,PARM='XREF,LIST,LET,MAP',REGION=500K\n//*\n//*  EXTRACT IKJUPDT (CSECT=IKJCT433) FROM IKJPTGT:\n//*\n//SYSLIN   DD DDNAME=SYSIN\n//SYSLMOD  DD DISP=SHR,DSN=KK00150.MY.LOAD\n//SYSLOLD  DD DISP=SHR,DSN=SYS1.LPALIB      (OR LIB WITH IKJPTGT)\n//SYSUT1   DD UNIT=SYSDA,SPACE=(1024,(50,20))\n//SYSPRINT DD SYSOUT=*\n//SYSIN DD *\n REPLACE IKJEFT30\n REPLACE IKJEFT35\n REPLACE IKJEFT40\n REPLACE IKJEFT45\n REPLACE IKJEFT52\n REPLACE IKJEFT53\n REPLACE IKJEFT54\n REPLACE IKJEFT55\n REPLACE IKJEFT56\n REPLACE IKJRBBMC\n REPLACE IKJCT434\n REPLACE IKJCT436\n INCLUDE SYSLOLD(IKJPTGT)\n INCLUDE SYSLMOD(SETVAR)\n ORDER SETVAR\n ENTRY SETVAR\n NAME SETVAR(R)\n//*\n//* A TSO COMMAND USES SETVAR AS FOLLOWS:\n//*\n//*     LINK  EP=SETVAR,PARAM=(UPT,ECT,ECB,UPLIST)\n//*\n//*           UPT = USER PROFILE TABLE       (FROM CPPL)\n//*           ECT = ENVIRONMENT CONTROL TABLE   \"   \"\n//*           ECB = COMMAND PROCESSOR ECB\n//*           UPLIST = A FOUR WORD BLOCK AS BELOW:\n//*\n//*\n//*   UPLIST  DS  0XL16\n//*   LOCPTR  DS  AL4         PTR TO VARIABLE NAME\n//*   LOCLEN  DS  F           LENGTH OF VARIABLE NAME\n//*   VALPTR  DS  A           PTR TO DATA VALUE\n//*   VALLEN  DS  F           LENGTH OF DATA VALUE\n//*\n//* EXAMPLE : SET &VAR = &STR(MYDATA)\n//*\n//*   UPLIST  DS  0XL16\n//*   LOCPTR  DC  A(=C'VAR')    PTR TO VARIABLE NAME\n//*   LOCLEN  DC  F'3'          LENGTH OF VARIABLE NAME\n//*   VALPTR  DC  A(=C'MYDATA') PTR TO DATA VALUE\n//*   VALLEN  DC  F'6'          LENGTH OF DATA VALUE\n//*\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SHOW": {"ttr": 33805, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x00\\x7f\\x00\\x88\\x00\\x7f\\x12\\x00\\x01B\\x01B\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf2\\xf7\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-01-07T00:00:00", "modifydate": "1988-01-07T12:00:00", "lines": 322, "newlines": 322, "modlines": 0, "user": "FILE270"}, "text": "SHOWNEW  TITLE ' - CP TO REPLACE JTIP SHOW COMMAND.'\n*\n* UPDATED FOR JES 2.1.5 06/05/87 (VERSION V2M0)\n*\n* WRITTEN BY KERMIT KISER - APRIL, 1985\n*\n*   COMMAND FORMATS:     SSCSFLGS:   SSCSULEN: SSCSJOBN: SSCSJOBI:\n*\n*  1. SHOW {UID(ACF2ID)}     X'80'       X'80'       ID     BLANK\n*\n*  2. SHOW JOB(XXXXXXXX)     X'00'       X'8N'  JOBNAME     BLANK\n*                                    N=LENGTH OF JOBNAME SUPPLIED\n*\n*  3. SHOW JOB(NNNN)         X'00'       X'80'    BLANK   F'NNNN'\n*\n*  4. SHOW SYS{(NN)}         X'80'       X'87' ID+TIOT/N    BLANK\n*                          SSCSJOBN= UID WITH SYS # OR TIOT SYS\n*\n*  5. SHOW LIKE(XXXXXXXX)    X'00'       X'CN'  JOBNAME     BLANK\n*                                    N=LENGTH OF JOBNAME SUPPLIED\n*\n*\n*\nSHOW     ENTERR LEVEL=V2M0,CLEAR=YES\n         LR    R11,R1                   R11->CPPL\n         USING CPPL,R11\n         EJECT\n*\n*              SHOWT CONTROL ROUTINE:\n*\nSA       BAL   R14,PB                   PARSE THE INPUT BUFFER\n*\nS1       BAL   R14,INIT                 SET UP SSOB\n*\nS2       BAL   R14,CALLSS               PASS REQUEST TO SUBSYSTEM\n*\nS3       BAL   R14,SHOWEM               EXPLAIN TO THE GUY\n         EJECT\n         LEAVER\n         EJECT\nPB       ST    R14,L1LS\n         MVC   JOBNAME(8),=CL8' '\n         PARSKMD WORK=FASTAREA,PARM=WORKAREA,KEYWORK=KEYWAREA,       XXX\n               UNKFLG=UFLG\n         SPACE 2\n         L     R14,L1LS\n         BR    R14\n         EJECT\nINIT     ST    R14,L1LS\n         L     R1,8(,R11)         R1->PSCB\n         MVC   MPSCB,0(R1)        MAKE A COPY\n         BAL   R14,MODPSCB        MODIFY ?\n         SPACE\n* BUILD SUBSYS REQUEST PARMLIST\n         LA    R10,SSOBAREA       R10->SSOB\n         USING SSOB,R10\n         ST    R10,SSRPL          SET UP PARM LIST\n         OI    SSRPL,X'80'        \"\n         SPACE\n* BUILD SSOB HERE\n         MVC   SSOBID,=C'SSOB'    ID\n         MVC   SSOBLEN,=H'20'     LENGTH\n         MVC   SSOBFUNC,=AL2(SSOBSTAT)\n         LA    R1,SSCSBGN         R1->SSOB EXTENSION\n         ST    R1,SSOBINDV        LINK EM\n         SPACE\n* SSOB CANCEL/STATUS EXTENSION - INIT\n         MVC   SSCSLEN,=X'0028'\n         MVC   SSCSJOBN,=CL8' '\n         MVC   SSCSJOBI,=CL8' '\n         TM    FLAG,X'50'         USER ENTERED JOB()?\n         BZ    SHOWALL            NOPE.\n         TM    FLAG,X'10'         USER ENTERED LIKE()?\n         BZ    CKJOB              NOPE.\n         OI    SSCSULEN,X'C0'        SAY LIKE                    WDPSC\n         B     MVCN                  GO MOVE NAME                WDPSC\nCKJOB    CLI   JOBNAME,C'0'       ID?\n         BNL   JOBID              YUP.\nMVCN     MVC   SSCSJOBN,JOBNAME   GET JOBNAME\n         OC    SSCSULEN(1),JOBAREA+1 SET LENGTH                  WDPSC\n         B     SHOWFLAG\nJOBID    LH    R1,JOBAREA         R1=LENGTH OF ID\n         BCTR  R1,R0              R1-1\nPAKID    PACK  PDW(8),JOBNAME(0)  PACKS ID\n         EX    R1,PAKID           DO IT FOR REAL\n         UNPK  SSCSJOBI,PDW       MAKE CHAR\n         OI    SSCSJOBI+7,X'F0'   IS THIS NEEDED?\n         MVC   SSCSJOBI(3),=C'JOB' PREFIX\n         B     SHOWFLAG\nSHOWALL  MVC   SSCSJOBN(7),MPSCB  GET USERID\n         TM    FLAG,X'08'         USER ENTERED SYSTEM(NN)?\n         BZ    SETID              NOPE.\n         MVC   SSCSJOBN+2(2),SYSNAME UPDATE SYSTEM #             WDPSC\n         MVI   SSCSULEN,X'87'     SET LEN\nSETID    OI    SSCSFLGS,SSCSUSID  SAY USERID PRESENT\nSHOWFLAG DS    0H\n         OI    SSCSULEN,X'80'     SAY SHOW CALLING\n         MVC   SSCSDIMP,=H'15500' PASS RESPONSE AREA LENGTH\n         SPACE 2\n         L     R14,L1LS\n         BR    R14\n         EJECT\nMODPSCB  ST    R14,L2LS\n         LH    R3,OPAREA          R3=LENGTH OF OPER PASSWORD\n         LTR   R3,R3              ANY GIVEN?\n         BZ    CKOPER             NOPE.\n         CLC   OPAREA+2(5),=CL5'BINGO' IS HE OK?\n         BNE   CKOPER                NO SUCH\n         OI    MPSCB+16,X'80'     HE IS OPER!\nCKOPER   TM    MPSCB+16,X'80'     IS HE OPER?\n         BNO   USESYS             NO->RESTRICT HIM\n         LH    R3,SAVEUSER        R3=LENGTH OF USERID SPECIFIED\n         LTR   R3,R3              ANY GIVEN?\n         BZ    USESYS             NOPE.\n         MVC   MPSCB(7),=CL7' '    CLEAR USERID FIELD\nSETUID   MVC   MPSCB(0),SAVEUSER+2 COPY USERID FIELD\n         BCTR  R3,R0              R3-1 FOR EX\n         EX    R3,SETUID          SHOVE IT\n         B     MPX\nUSESYS   L     R1,540                R1->TCB\n         L     R1,12(,R1)            R1->TIOT\n         MVC   MPSCB+2(2),3(R1)      UPDATE SYSID\n         SPACE 2\nMPX      L     R14,L2LS\n         BR    R14\n         EJECT\nCALLSS   ST    R14,L1LS\n         SPACE\n         L     R0,=F'-1'          R0=-1\n         SVC   236                SET JSCB AUTH BIT ON\n         SPACE\n         MVC   MODELIST,SUP       INIT MODE PLIST\n         MODESET MF=(E,MODELIST)  SET SUPER STATE\n         SPACE\n         LA    R1,SSRPL           R1->SUBSYS REQ PARM LIST\n         IEFSSREQ\n         ST    R15,SSRC           SAVE RETURN CODE\n         SPACE\n         MVC   MODELIST,PROB      INIT MODE PLIST\n         MODESET MF=(E,MODELIST)  SET PROBLEM STATE\n         SPACE\n         SLR   R0,R0              R0=0\n         SVC   236                SET JSCB AUTH BIT OFF\n         EJECT\n         L     R15,SSRC           RESTORE RETURN CODE\n         LTR   R15,R15            GOOD REQUEST?\n         BZ    GOODREQ            YUP.\n         CH    R15,=H'20'         RC VALID?\n         BL    RCOK               Y\n         LA    R15,20             BAD ENOUGH\nRCOK     L     R1,MSGTAB1(R15)    R1-> ERROR MSG\n         BAL   R14,PUTLINE        TELL M\n         B     SSX\nGOODREQ  ICM   R15,15,SSOBRETN    R15=SS RETCODE\n         BZ    SSX                OK?\n         CH    R15,=H'28'         RC VALID?\n         BNH   RC2OK              Y\n         LA    R15,32             RESPONSE UNKNOWN\nRC2OK    L     R1,MSGTAB2(R15)    R1->ERRRR MSG\n         BAL   R14,PUTLINE        TELL ER\n         SPACE 2\nSSX      L     R14,L1LS\n         BR    R14\n         SPACE\nMSGTAB1  DS    F\n         DC    A(RC1M4)\n         DC    A(RC1M8)\n         DC    A(RC1M12)\n         DC    A(RC1M16)\n         DC    A(RC1M20)\nRC1M4    DC    AL2(L'RC1IS4),H'0'\nRC1IS4   DC    C'SUBSYSTEM DOES NOT SUPPORT THIS FUNCTION'\nRC1M8    DC    AL2(L'RC1IS8),H'0'\nRC1IS8   DC    C'SUBSYSTEM EXISTS, BUT IS NOT UP'\nRC1M12   DC    AL2(L'RC1IS12),H'0'\nRC1IS12  DC    C'SUBSYSTEM DOES NOT EXIST'\nRC1M16   DC    AL2(L'RC1IS16),H'0'\nRC1IS16  DC    C'FUNCTION NOT COMPLETED-DISASTROUS ERROR'\nRC1M20   DC    AL2(L'RC1IS20),H'0'\nRC1IS20  DC    C'LOGICAL ERROR (BAD SSOB FORMAT,INCORRECT LENGTH,...)'\n         SPACE\nMSGTAB2  DS    F\n         DC    A(RC2M4)\n         DC    A(RC2M8)\n         DC    A(RC2M12)\n         DC    A(RC2M16)\n         DC    A(RC2M20)\n         DC    A(RC2M24)\n         DC    A(RC2M28)\n         DC    A(RC2M32)\nRC2M4    DC    AL2(L'RC2IS4),H'0'\nRC2IS4   DC    C'JOB NAME NOT FOUND'\nRC2M8    DC    AL2(L'RC2IS8),H'0'\nRC2IS8   DC    C'INVALID JOBNAME/JOB ID COMBINATION'\nRC2M12   DC    AL2(L'RC2IS12),H'0'\nRC2IS12  DC    C'JOB NOT CANCELED- DUPLICATE JOBNAMES AND NO ID'\nRC2M16   DC    AL2(L'RC2IS16),H'0'\nRC2IS16  DC    C'STATUS ARRAY TOO SMALL'\nRC2M20   DC    AL2(L'RC2IS20),H'0'\nRC2IS20  DC    C'JOB NOT CANCELLED-JOB ON OUTPUT QUEUE'\nRC2M24   DC    AL2(L'RC2IS20),H'0'\nRC2IS24  DC    C'JOBID WITH INVALID SYNTAX FOR SUBSYSTEM'\nRC2M28   DC    AL2(L'RC2IS20),H'0'\nRC2IS28  DC    C'INVALID CANCEL REQUEST - CANNOT CANCEL ACTIVE TSU/STC'\nRC2M32   DC    AL2(L'RC2IS20),H'0'\nRC2IS32  DC    C'UNKNOWN ERROR IN SUBSYSTEM PROCESSING'\n         EJECT\nSHOWEM   ST    R14,L1LS\n         SPACE\n         LA    R9,SSCSARAY        R9->JQE AREA\n         L     R1,0(R9)           R1=PREFIX LENGTH\n         LA    R2,SA2             R2->FORMAT WORKAREA\n         ST    R2,FJMPL           SAVE\n         LA    R2,16(R9)          R9->QSE AREA\n         ST    R2,FJMPL+8         SAVE ADDR\n         AR    R9,R1              R9->1ST JQE\n         USING JQE,R9\nJQELOOP  EQU   *\n         CLC   0(4,R9),=XL4'00'   END?\n         BE    JQEXIT             YEP.\n         ST    R9,FJMPL+4         PASS JQE\n         LA    R1,FJMPL           R1->FJM PARMLIST\n         CALL  FJM                FORMAT OUTPUT LINE\n         LA    R1,STATLEN         R1->OUTPUT LINE\n         BAL   R14,PUTLINE        TELL IT ALL...\n         LA    R9,JQEBLEN(R9)     R9->NEXT JQE\n         B     JQELOOP            CHK IT.\n         SPACE\nJQEXIT   L     R14,L1LS\n         BR    R14\n         EJECT\nPUTLINE  ST    R14,L3LS\n         SPACE\n         LR    R2,R1              R2->OUTPUT MESSAGE\n         L     R3,CPPLUPT         R3->UPT\n         L     R4,CPPLECT         R4->ECT\n         PUTLINE PARM=PUTLST,UPT=(R3),ECT=(R4),ECB=LOCLECB,       XXXXXX\n               OUTPUT=((2),DATA),MF=(E,IOPL)\n         SPACE\n         CH    R15,=H'4'          NORMAL RETURN?\n         BNH   PLX                YES\n         DS    H'0'\n         DC    C'BAD PUTLINE ERROR OCCURED'\nPLX      L     R14,L3LS\n         BR    R14\n         EJECT\nSTATWORK EQU   *\n         SPACE\nOPLIST   OPERLIST OPER1,OPER2,OPER3,OPER4,OPER5\nOPER1    OPER  UID,X'8000',MINLEN=1,BLANK=YES,SUBFLD=SAVEUSER\nOPER2    OPER  JOB,X'4000',MINLEN=1,BLANK=YES,SUBFLD=JOBAREA\nOPER3    OPER  OPPW,X'2000',MINLEN=3,BLANK=YES,SUBFLD=OPAREA\nOPER4    OPER  LIKE,X'1000',MINLEN=1,BLANK=YES,SUBFLD=JOBAREA\nOPER5    OPER  SYSTEM,X'0800',MINLEN=1,BLANK=YES,SUBFLD=SYSAREA\n         SPACE\n*\nSUP      MODESET MODE=SUP,MF=L\n*\nPROB     MODESET MODE=PROB,MF=L\n*\n         SPACE\n         LTORG\n         EJECT\nWORKAREA DSECT\nSAVEAREA DS    18F\nL1LS     DS    F\nL2LS     DS    F\nL3LS     DS    F\n*\nMODELIST MODESET MODE=SUP,MF=L\n*\nIOPL     DS    4F\nLOCLECB  DS    F\nPUTLST   PUTLINE MF=L\n*\nFJMPL    DS    4F                 FJM PARM LIST: FJMWA,JQE,QSE TAB\n*\n* FJM WORK AREA:\nSA2      DS    18F\nJQEPTR   DS    F\n$QSE1    DS    F\nNODEPTR  DS    F\nPDW      DS    D\nDDW      DS    D\nSTATLEN  DS    H\n         DS    H\nSTATLINE DS    0CL512\n         SPACE\nFASTAREA DS    XL512\n         KPPL\nKEYWAREA DS    20F\n*\nSAVEUSER DS    H                  LENGTH OF UID\n         DS    CL8\nJOBAREA  DS    H                  LENGTH OF JOB NAME\nJOBNAME  DS    CL8\nSYSAREA  DS    H                  LENGTH OF JOB NAME\nSYSNAME  DS    CL8\nOPAREA   DS    H                  LENGTH OF PASSWD\nOPNAME   DS    CL8\nMPSCB    DS    XL72\nMCPPL    DS    4F\n*\nFLAG     DS    F\nUFLG     DS    X\n         SPACE 2\nSSRC     DS    F\nSSRPL    DS    F\nSSOBAREA DS    XL16384            SUBSYS AREAS\n         SPACE 2\nWORKLEN  EQU   *-WORKAREA\n         EJECT\n         IEFJSSOB CS,CONTIG=YES\n         IEFJESCT\nFF       EQU   X'FF'\n         $JQE\n         CVT   DSECT=YES\n         EJECT\n         IKJCPPL\n         EJECT\n         IKJECT\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SHOWFJM": {"ttr": 34053, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x00\\x7f\\x00\\x88\\x00\\x7f\\x12\\x00\\x02G\\x02G\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf2\\xf7\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-01-07T00:00:00", "modifydate": "1988-01-07T12:00:00", "lines": 583, "newlines": 583, "modlines": 0, "user": "FILE270"}, "text": "FJM      TITLE     'FORMAT JQE MESSAGE'\n***********************************************************************\n*                                                                     *\n* UPDATED FOR JES 2.1.5 ON 06/05/87 - KERMIT KISER                    *\n*                                                                     *\n*        ENVIRONMENT   MVS SP 1.3.4  LEVEL 8310                       *\n*                      JES2 FOR SP 1.3.4                              *\n*                                                                     *\n*        ENTRY:  R1->  WORKAREA PTR;                                  *\n*                      JQE PTR;                                       *\n*                      QSE PTR;                                       *\n*                      NODE TAB PTR                                   *\n*                                                                     *\n*                                                                     *\n*                                                                     *\n***********************************************************************\n         MACRO\n&L1      $CFCVE &VALUE=\n         CVD   R0,PDW\n         MVC   DDW,=X'4020202020202020'\n         ED    DDW,PDW+4\n         MEND\n         MACRO\n&L1      $CFRTC &VALUE=\n         LR    R1,R0\n         LA    R1,1(R1)              LEAVE A BLANK               WDPSC\n         LH    R0,2(R15)\n         MVC   0(8,R1),=CL8'LOCAL'\n         LTR   R0,R0                       LOCAL?\n         BZ    X&SYSNDX\n         MVC   0(8,R1),=CL8'R'\n         LA    R1,1(R1)\n         CVD   R0,PDW\n         MVC   DDW,=X'4020202020202020'\n         ED    DDW,PDW+4\n         LA    R15,DDW\n         LA    R0,7\nL&SYSNDX LA    R15,1(R15)\n         CLI  0(R15),C' '\n         BNE   M&SYSNDX\nN&SYSNDX BCT   R0,L&SYSNDX\n         B     X&SYSNDX\nM&SYSNDX MVC   0(1,R1),0(R15)\n         LA    R1,1(R1)\n         B     N&SYSNDX\nX&SYSNDX DS    0H\n         MEND\nJIDMSG   DSECT\n         SPACE 1\nJIDTYPE  DS    CL3                 'JOB', 'STC', OR 'TSU'          @133\nJIDJNO   DS    CL5                 JOBNUMBER WITH LEADING BLANK    @133\n         DS    CL1                 BLANK                           @133\nJIDJNAME DS    CL8                 JOB NAME                        @133\nJIDMSGLN EQU   *-JIDMSG            LENGTH OF DSECT                 @133\n***********************************************************************\nQSEDSECT DSECT\n         SPACE 1\nQSESID   DS    CL4\nQSESIBSY DS    X\nQSESIAFF DS    X\nQSELEN   EQU   *-QSEDSECT\n***********************************************************************\nWORKAREA DSECT\n         SPACE 1\nSAVEAREA DS    18F\nJQEPTR   DS    F\n$QSE1    DS    F\nNODEPTR  DS    F\nPDW      DS    D\nDDW      DS    D\nCOMDWORK EQU   DDW+3\nCOMMAND  DS    XL256\nDASVOLID DS    CL6\nWORKLEN  EQU   *-WORKAREA\n***********************************************************************\nFF       EQU   X'FF'\n         $JQE\nCATTSUCL EQU   X'E0'\nCATTSUID EQU   X'7C'\n         EJECT\nFJM      ENTERWW (1),LEVEL=V1M0\n         EJECT\n         L     R0,8(,R1)\n         ST    R0,$QSE1           SAVE QSE TAB PTR\n         L     R0,12(,R1)\n         ST    R0,NODEPTR         SAVE QSE TAB PTR\n         L     R1,4(,R1)\n         ST    R1,JQEPTR          SAVE JQE PTR\n*    R1 CONTAINS A POINTER TO THE JQE\nCHECK10  EQU   *\n         SPACE     1\n*\n*        INITIALIZE FROM THE COMMAND WORK AREA  ( PCE+A0 )\n*\n         LA        R3,COMMAND+4        ADDRESS FOR JOBID & JOBNAME\n*                                                                     *\n***********************************************************************\n*                                                                     *\n*        COFJMSG - JOB INFORMATION OUTPUT ROUTINE                     *\n*                                                                     *\n*        THE PURPOSE IS TO ISSUE THE HASP608 MESSAGE. IT MIGHT        *\n*        ISSUE THE HASP611 MESSAGE IF 608 CAN NOT BE COMPLETED.       *\n*                                                                     *\n*        ROUTINE COLLECTS JOB INFORMATION INTO THE 'COMMAND' AREA     *\n*        AND INITIATES AN OUTPUT RESPONSE.                            *\n*        $WAIT MAY BE ISSUED.                                         *\n*                                                                     *\n*        REGISTER    ENTRY                 EXIT                       *\n*        R1          JQE ADDRESSABILITY    UNCHANGED                  *\n*        R8          UNKNOWN               LOCAL ADDRESSABILITY       *\n*        R14         RETURN ADDRESS        UNCHANGED                  *\n*        R15         ENTRY ADDRESS         RETURN CODE                *\n*                                          0 - DISPLAY ISSUED         *\n*                                          4 - DISPLAY NOT ISSUED     *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n*        DEFINITIONS FOR JOB INFORMATION MESSAGE (&OPT)               *\n*                                                                     *\n***********************************************************************\n         SPACE 1\nCOFN     EQU   X'01'               DISPLAY NORMAL JOBS\nCOFS     EQU   X'02'               DISPLAY SYSTEM JOBS\nCOFT     EQU   X'04'               DISPLAY LOGON JOBS\nCOFJ     EQU   COFN+COFS+COFT      DISPLAY ALL JOBS\nCOFX     EQU   X'08'               DISPLAY JOBS IN EXECUTION\nCOFD     EQU   X'10'               DISPLAY JOBS ON DEVICES\nCOFA     EQU   COFJ+COFX+COFD      DISPLAY ACTIVE JOBS\nCOFI     EQU   X'20'               DISPLAY PRE-XEQ QUEUED JOBS\nCOFO     EQU   X'40'               DISPLAY POST-XEQ QUEUED JOBS\nCOFP     EQU   X'80'               DISPLAY QUEUED FOR PRT/PUN\nCOFQ     EQU   COFJ+COFI+COFO+COFP DISPLAY QUEUED JOBS\nCOFU     EQU   COFJ+COFI+COFO+COFX+COFP+COFD DISPLAY UNCONDITIONAL\n         EJECT                                                     @133\n***********************************************************************\n*                                                                     *\n*        DEFINITIONS FOR 2ND OPTION FLAG (&OPT2)                      *\n*                                                                     *\n***********************************************************************\n         SPACE 1                                                   @133\nCOFSPLAG EQU   B'00000001'         SPOOL OPERAND SPECIFIED FLAG    @133\n         SPACE 2                                                   @133\n***********************************************************************\n*                                                                     *\n*        DEFINITIONS FOR MESSAGE DEFINED IN COMMAND AREA              *\n*                                                                     *\n***********************************************************************\n         SPACE 1                                                   @133\nCOFJOB   EQU   COMMAND+4,3           TEXT 'JOB', 'STC', OR 'TSU'\nCOFJNO   EQU   COFJOB+3,5          JOB NUMBER WITH LEADING BLANK\nCOFJNAME EQU   COFJNO+6,8          JOB NAME\nCOFQUE   EQU   COFJNAME+9,8        TEXT 'AWAITING'\nCOFQUEC  EQU   COFJNAME+9,9        TEXT 'AWAITING '                SPR2\nCOFQX    EQU   COFQUE+9,9          TEXT 'EXECUTION'\nCOFQXC   EQU   COFQX+10,1          CLASS\nCOFQXU   EQU   COFQX,11            TEXT 'EXECUTION *'\nCOFQXCT  EQU   COFQX,12            TEXT 'CONVERSION *'             SPR2\nCOFQXCTC EQU   COFQXCT+11,1        CLASS IN 'CONVERSION *'         SPR2\nCOFQDUMP EQU   COFQUE+9,4          TEXT 'DUMP'                     SPR2\nCOFQT    EQU   COFQUE+9,7          TEXT 'XMITTER'                  SPR2\nCOFXMT   EQU   COFQT+8,11          EXECUTION NODE (EBCDIC)         SPR2\nCOFPRT   EQU   COFQUE,3            TEXT 'PRT'                      SPR2\nCOFPRTR  EQU   COFPRT+3,12         PRINT NODE/UNIT/REMOTE ROUTING  SPR2\nCOFPUN   EQU   COFPRT+15,3         TEXT 'PUN'                      SPR2\nCOFPUNR  EQU   COFPUN+3,12         PUNCH NODE/UNIT/REMOTE ROUTING  SPR2\nCOFQOUT  EQU   COFQX,6             TEXT 'OUTPUT'                   SPR2\nCOFPURGE EQU   COFQX,5             TEXT 'PURGE'\nCOFPRIO  EQU   COFPUNR+12,4        TEXT 'PRIO'                     SPR2\nCOFPRI   EQU   COFPRIO+5,2         PRIORITY\nCOFFLAGS EQU   COFPRI+3,9          'HOLD', 'PURGE', 'DUPLICATE'\nCOFSID   EQU   COFFLAGS+10,4       FIRST SID NAME\nCOFSIDX  EQU   COFSID+5,24         REST OF SID'S\nCOFINDP  EQU   COFSIDX+25,3        DESIGNATOR FOR INDEPENDENT MODE\nCOFSPMSG EQU   COFINDP+3,18        TEXT ' SPOOL(S) INACTIVE'       @133\nCOFSPHLT EQU   COFINDP+3,17        TEXT ' SPOOL(S) HALTING'        @133\nCOFONPAR EQU   COFSPMSG+18,5       TEXT ' ON ('                    @133\nCOFSPNON EQU   COFONPAR+4,4        TEXT 'NONE'                     @133\nCOFSPLID EQU   COFONPAR+5,L'DASVOLID  VOLSER ID, 6 CHARS           @133\nCOFCOMMA EQU   COFSPLID+L'DASVOLID,1  TEXT ','                     @133\nCOFSPLX  EQU   COFCOMMA+1,218      TEXT FOR THE REST 31 SPOOLS     @133\nCOFOPT   EQU   COFSPLX+218,1       OPTION SPECIFIED                @133\nCOFAFF   EQU   COFOPT+1,1          ACTIVE SID WHEN SPECIFIED       @133\nCOFOPT2  EQU   COFAFF+1,1          2ND OPTION FLAG                 @133\nCOFSEC   EQU   COFOPT2+1,2         SECURITY FIELD FOR $WTO'S       @133\nCOFLNGTH EQU   COFSEC+2,2          LENGTH OF MSG                   @133\nCOFAX    EQU   COFQUE,9            TEXT 'EXECUTING'\nCOFAXC   EQU   COFAX+10,1          CLASS WHEN EXECUTING\nCOFAXCT  EQU   COFAX,12            TEXT 'CONVERTING *'             SPR2\nCOFAXCTC EQU   COFAXCT+11,1        CLASS WHEN CONVERTING           SPR2\nCOFON    EQU   COFAX,2             TEXT 'ON'\nCOFDEV   EQU   COFAX+3,8           TEXT DEVICE NAME\nCOFAXT   EQU   COFDEV+9,COFSPMSG-COFPRIO ACTIVE JOB MSG TRAILER    @133\nCOFQOT   EQU   COFQOUT+7,L'COFAXT  QUEUED FOR OUTPUT TRAILER       @133\nCOFQPT   EQU   COFPURGE+6,L'COFAXT QUEUED FOR PURGE TRAILER        @133\nCOFAXL   EQU   COFPRIO-(COFDEV+9) LENGTH TO SUBTRACT FOR ACTIVE MSG\nCOFQOL   EQU   COFPRIO-(COFQOUT+7) LNG TO SUBTRACT FOR Q'S FOR OUT\nCOFQPL   EQU   COFPRIO-(COFPURGE+6) LNG TO SUBTRACT FOR Q'S FOR PG\n         EJECT\n***********************************************************************\n*                                                                     *\n*        CHECK FOR JOB TYPE AND SPOOL RESIDENCY                       *\n*                                                                     *\n***********************************************************************\n         SPACE 1                                                   @133\n         USING JQE,R5              PROVIDE JQE ADDRESSABILITY       N30\n         SPACE 1                                                   SPR2\nCOFJMSG  EQU   *\n         SPACE 1                                                   SPR2\n*        LA    R4,1                CLEAR WARNING INDICATOR          N30\n         LR    R5,R1               RELOAD JQE ADDRESS             @SPR2\n         LA    R15,COFN            ASSUME BATCH JOB                SPR2\n         TM    JQEFLAG3,JQE3JOB    BATCH JOB...                    SPR2\n         BZ    COFFTYP             BR IF YES                       SPR2\n         LA    R15,COFT            MUST BE A TSU                   SPR2\n         SPACE 1                                                   SPR2\nCOFFTYP  EQU   *\n         SPACE 1                                                   @133\nCOFALLVO TM    JQETYPE,$XEQ        EXECUTION OR CONVERT QUEUE      @133\n         BZ    COFJMT              BRANCH IF NOT\n         CLI   JQETYPE,$XEQ        TEST FOR CONVERTER\n         BNE   COFJMX              NO--TRY FOR EXECUTION\n         EJECT                                                     @133\n***********************************************************************\n*                                                                     *\n*        JOB IN CONVERSION QUEUE                                      *\n*                                                                     *\n***********************************************************************\n         SPACE 1                                                   SPR2\n         BAL   R6,COFJMB           CREATE BASIC MESSAGE             N30\n         BAL   R6,COFJMAFQ         ADD QUEUED SYSTEM NAMES TO MSG   N30\n         MVC   COFAXCT,=C'CONVERTING *'  ASSUMING JOB BUSY SETUP   SPR2\n         MVC   COFAXCTC,JQEJCLAS   ASSUME THIS IS NOT TSU OR STC       C\n                                     AND SET CLASS                 SPR2\n         SPACE 1                                                   @133\nCOFTSUT  CLI   JQEJCLAS,CATTSUCL   IS THIS A TSU...                SPR2\n         BNE   COFBUSY             IF NO - GO TEST BUSY ASSUMPTION SPR2\n         MVI   COFAXCTC,CATTSUID   CHANGE CLASS FOR TSU            SPR2\nCOFBUSY  TM    JQEFLAG1,JQE1BUSY   TEST BUSY ASSUMPTION...         SPR2\n         BNZ   COFQMADS            DISPLAY AND EXIT IF BUSY            C\n                                   OTHERWISE                       SPR2\n         MVC   COFQUEC,=C'AWAITING '    SETUP NOT BUSY             SPR2\n         MVC   COFQXCT,=C'CONVERSION *' FIXED TEXT                 SPR2\n         MVC   COFQXCTC,JQEJCLAS   ASSUME THIS IS NOT A TSU OR STC     C\n                                     AND SET CLASS                 SPR2\n         SPACE 1                                                   @133\nCOFTSUT1 CLI   JQEJCLAS,CATTSUCL   IS THIS A TSU...                SPR2\n         BNE   COFQMADS            IF NO - DISPLAY AND EXIT        SPR2\n         MVI   COFQXCTC,CATTSUID   CHANGE CLASS FOR TSU            SPR2\n         B     COFQMADS            DISPLAY AND EXIT\n         SPACE 1                                                   SPR2\n         EJECT                                                     @133\n***********************************************************************\n*                                                                     *\n*        JOB IN EXECUTION QUEUE - COULD HAVE SOME SPINS IN OUTPUT     *\n*                                                                     *\n***********************************************************************\n         SPACE 1                                                   SPR2\nCOFJMX   TM    JQEFLAG1,JQE1BUSY   TEST FOR ACTIVE\n         BZ    COFJMQX             BR IF NOT\n         BAL   R6,COFJMB           CREATE BASIC MESSAGE             N30\n         IC    R15,JQEFLAG1        PICK-UP ACTIVE BIT\n         BAL   R6,COFJMAFA         ADD ACTIVE SYSTEM NAME TO MSG    N30\n         MVC   COFAXT,COFPRIO      MOVE MSG FOR ACTIVE IN XEQ\n         MVC   COFAX,=C'EXECUTING' SET FIXED TEXT                  SPR2\n         MVC   COFAXC,JQEJCLAS     ASSUME THIS IS NOT TSU OR STC       C\n                                     AND SET CLASS                 SPR2\nCOFTSUT2 CLI   JQEJCLAS,CATTSUCL   IS THIS A TSU...                SPR2\n         BNE   COFJMDAX            IF NO - GO PICK UP CURRENT LEN  SPR2\n         MVI   COFAXC,CATTSUID     CHANGE CLASS FOR TSU            SPR2\n         SPACE 1                                                   SPR2\nCOFJMDAX DS    0H                                                   N30\n         LH    R15,COFLNGTH        PICK UP CURRENT LENGTH          SPR2\n         LA    R0,COFAXL           GET CHANGE IN LENGTH            SPR2\n         SLR   R15,R0              REDUCE LENGTH                   SPR2\n         STH   R15,COFLNGTH        SET NEW LENGTH                  SPR2\n         BAL   R6,COFJWTO          ISSUE MESSAGE TO OPERATOR        N30\n         SPACE 1                                                    N30\nCOFJMDXC DS    0H\n         B     COFJMOK             UNCONDITIONAL RETURN            SPR2\n         EJECT                                                     @133\n***********************************************************************\n*                                                                     *\n*        JOB AWAITING EXECUTION                                       *\n*                                                                     *\n***********************************************************************\n         SPACE 1                                                   SPR2\nCOFJMQX  EQU   *                   CALLER WANT PRE-EXECUTION\n         BAL   R6,COFJMB           CREATE BASIC MESSAGE             N30\n         BAL   R6,COFJMAFQ         ADD QUEUED SYSTEM NAMES TO MSG   N30\n         MVC   COFQUE,=C'AWAITING' SET\n         MVC   COFQX,=C'EXECUTION *' TEXT\n         MVC   COFQXC,JQEJCLAS     ASSUME THIS IS NOT TSU OR STC       C\n                                     AND SET CLASS                 SPR2\nCOFTSUT3 CLI   JQEJCLAS,CATTSUCL   IS THIS A TSU...                SPR2\n         BNE   COFJMDQX            IF NO - GO ISSUE MESSAGE TO OP  SPR2\n         MVI   COFQXC,CATTSUID     CHANGE CLASS FOR TSU            SPR2\nCOFJMDQX DS    0H                  ISSUE QUEUED FOR XEQ MESSAGE\n         BAL   R6,COFJWTO          ISSUE MESSAGE TO OPERATOR        N30\n         B     COFJMDXC            CONTINUE DEVICE SCAN\n         SPACE 1                                                   SPR2\nCOFJMT   CLI   JQETYPE,$XMIT       JOB ON TRANSMISSION QUEUE       SPR2\n         BNE   COFJMD              BRANCH IF NOT ON TRANSMISSION QUEUE\n         TM    JQEFLAG1,JQE1BUSY   IS JOB BUSY                     SPR2\n         BNZ   COFJMD              TRY DEVICE IF YES               SPR2\n         BAL   R6,COFJMB           CREATE BASIC MESSAGE             N30\n         BAL   R6,COFJMAFQ         ADD QUEUED SYSTEM NAMES       @133RY\n         MVC   COFQUE,=C'AWAITING' SET                             SPR2\n         MVC   COFQT(L'JQEXEQND),JQEXEQND  SEPARATE NODE ID        SPR2\n         MVC   COFQT+2(2),$ZEROES  ZERO 'REMOTE' FIELD             SPR2\n         LA    R15,COFQT           POINT TO ROUTE CODE             SPR2\n         LA    R0,COFXMT-1         POINT TO TEXT AREA              SPR2\n        $CFRTC ,                   CONVERT TO EBCDIC               SPR2\n         MVC   COFQT,=C'XMITTER'   TEXT                            SPR2\n         B     COFJMDQX            DISPLAY AND THEN DO ANY SYSOUTS SPR2\n         EJECT\n***********************************************************************\n*                                                                     *\n*        SEARCH FOR DEVICE ACTIVITY                                   *\n*                                                                     *\n***********************************************************************\n         SPACE 1                                                   SPR2\nCOFJMD   EQU   *                                                  @SPR2\n         B     COFJMQO             UNCONDITONAL SKIP IT           @SPR2\n***********************************************************************\n*        JOB QUEUED FOR OUTPUT                                        *\n***********************************************************************\n         SPACE 1\nCOFJMQO  EQU   *                   TEST FOR OUTPUT QUEUED           N30\n         CLI   JQETYPE,$OUTPUT     TEST FOR IN OUTPUT PHASE        SPR2\n         BNE   COFJMQPP            NO--PRT/PUN                     SPR2\n         BAL   R6,COFJMB           CREATE BASIC MESSAGE             N30\n         BAL   R6,COFJMAFQ         ADD QUEUED SYSTEM NAMES TO MSG   N30\n         MVC   COFQUE,=C'      IN'  SET 'IN' IN MSG TEXT           @133\n         TM    JQEFLAG1,JQE1BUSY   TEST FOR BUSY                   @133\n         BNZ   COFJNOP             DISPLAY IN OUTPUT MSG IF YES    @133\n         MVC   COFQUE,=C'AWAITING' SET AWAITING IN TEXT\nCOFJNOP  MVC   COFQOUT,=C'OUTPUT'  SET QUEUED FOR 'OUTPUT'         @133\n         MVC   COFQOT,COFPRIO      MOVE MESSAGE FOR Q'D FOR OUTPUT\n         LH    R15,COFLNGTH        PICK UP CURRENT LENGTH          SPR2\n         LA    R0,COFQOL           GET CHANGE IN LENGTH            SPR2\n         SLR   R15,R0              REDUCE LENGTH                   SPR2\n         STH   R15,COFLNGTH        SET NEW LENGTH                  SPR2\n         B     COFQMADS            AND SEND MESSAGE\n         SPACE 2\n***********************************************************************\n*        TEST FOR JOB ON PRINT/PUNCH QUEUE                            *\n***********************************************************************\n         SPACE 1                                                   SPR2\nCOFJMQPP CLI   JQETYPE,$HARDCPY    TEST FOR QUEUED FOR HARD COPY   SPR2\n         BNE   COFJMQPG            NO--TRY QUEUED FOR PURGE        SPR2\n         BAL   R6,COFJMB           CREATE BASIC MESSAGE             N30\n         MVC   COFPRT,=CL3'PRT'    SET PRINT AND PUNCH             SPR2\n         MVC   COFPUN,=CL3'PUN'     QUEUE IDENTIFIERS              SPR2\n         SPACE 1                                                   SPR2\n         LA    R0,COFPRTR          POINT TO RECEIVE AREA\n         LA    R15,JQEPRTRT        POINT TO PRINT ROUTE FIELD\n        $CFRTC ,                     CONVERT TO PRINTABLE          @133\n         LA    R0,COFPUNR          POINT TO RECEIVE AREA\n         LA    R15,JQEPUNRT        POINT TO PUNCH ROUTE FIELD\n        $CFRTC ,                     CONVERT TO PRINTABLE          @133\n         SPACE 1                                                   SPR2\n         LH    R15,COFLNGTH        PICK UP LENGTH OF MESSAGE       SPR2\n         LA    R14,COFJOB(R15)     POINT TO NEXT AVAILABLE BYTE    SPR2\n         MVC   0(3,R14),=CL3'ANY'  SET AFFINITY TO DEFAULT         SPR2\n         LA    R15,3(,R15)         INCREMENT LENGTH                SPR2\n         STH   R15,COFLNGTH        SET NEW LENGTH                  SPR2\n         B     COFQMADS            AND SEND COMPLETED MESSAGE\n         EJECT\n***********************************************************************\n*                                                                     *\n*        TEST FOR JOB ON PURGE QUEUE                                  *\n*                                                                     *\n***********************************************************************\n         SPACE 1                                                   SPR2\nCOFJMQPG CLI   JQETYPE,$PURGE      ON PURGE QUEUE\n         BNE   COFJMQD             NO--TRY QUEUED FOR DUMP         SPR2\n         BAL   R6,COFJMB           CREATE BASIC MESSAGE            SPR2\n         BAL   R6,COFJMAFQ         ADD QUEUED SYSTEM NAMES TO MSG   N30\n         MVC   COFQUE,=C'AWAITING' SET 'AWAITING' FOR PURGE\n         MVC   COFPURGE,=C'PURGE'  SET FOR 'PURGE' PROCESSOR\n         MVC   COFQPT,COFPRIO      ADJUST MESSAGE FOR PURGE\n         LH    R15,COFLNGTH        PICK UP LENGTH OF MESSAGE       SPR2\n         LA    R0,COFQPL           GET CHANGE IN LENGTH            SPR2\n         SLR   R15,R0              SET NEW LENGTH                  SPR2\n         STH   R15,COFLNGTH        SET NEW LENGTH                  SPR2\n         B     COFQMADS            AND SEND MESSAGE                SPR2\n         SPACE 1                                                   SPR2\n***********************************************************************\n*                                                                     *\n*        TEST FOR JOB ON DUMP QUEUE                                   *\n*                                                                     *\n***********************************************************************\n         SPACE 1                                                   SPR2\nCOFJMQD  CLI   JQETYPE,X'03'       ON OFFLOAD QUEUE...             SPR2\n         BNE   COFJMNOK            EXIT IF NO (NO DISPLAY)         SPR2\n         BAL   R6,COFJMB           CREATE BASIC MESSAGE            SPR2\n         BAL   R6,COFJMAFQ         ADD QUEUED SYSTEM NAMES       @133RY\n         MVC   COFQUE,=C'AWAITING'   INSERT                        SPR2\n         MVC   COFQDUMP,=C'DUMP'      STATUS                       SPR2\n         LH    R15,COFLNGTH        PICK UP LENGTH OF MESSAGE       SPR2\n         SPACE 3                                                   SPR2\nCOFQMADS BAL   R6,COFJWTO          ISSUE FINAL MESSAGE TO OPERATOR  N30\n         SPACE 1                                                    N30\nCOFJMOK  EQU   *                                                    N30\nCOFJMNOK EQU   *\n         XC    COMMAND(4),COMMAND CLEAR PREFIX\n         MVC   COMMAND(2),COFLNGTH SET LEN\n         LEAVEWW\n         EJECT                                                      N30\n***********************************************************************\n*                                                                     *\n*        SUBROUTINE TO CONTINUE DCT SCAN BEGUN BY COFJDCT             *\n*                                                                     *\n***********************************************************************\n         SPACE 1                                                    N30\n***********************************************************************\n*                                                                     *\n*        ADD ACTIVE SYSTEM NAME                                       *\n*                                                                     *\n***********************************************************************\n         SPACE 1\nCOFJMAFA DS    0H                  PICK-UP AFFINITY IN R15 FOR NAME\n         N     R15,=A(JQE1BUSY)    TURN OFF NON-BUSY BITS\n         BCTR  R15,0               LESS ONE FOR DISPLACEMENT\n         MH    R15,=AL2(QSELEN)    TIMES ELEMENT SIZE             @SPR2\n         AL    R15,$QSE1           PLUS TABLE START ADDR\n         SPACE 1                                                   SPR2\n         USING QSEDSECT,R15        QSE ADDRESSABILITY\n         SPACE 1                                                   SPR2\n         LH    R14,COFLNGTH        PICK UP LENGTH                  SPR2\n         LA    R14,COFJOB(R14)     PT TO CURRENT MSG END\n         MVC   0(L'QSESID,R14),QSESID PUT SYSTEM NAME IN MESSAGE\n         LA    R15,COFJOB          PT TO MSG BEGINNING\n         LA    R14,L'QSESID(,R14)  PT TO MSG ENDING\n         SLR   R14,R15             COMPUTE NEW LENGTH\n         STH   R14,COFLNGTH        SET MESSAGE LENGTH              SPR2\n         BR    R6                   AND RETURN                      N30\n         SPACE 1                                                    N30\n         DROP  R15                 DROP QSE ADDRESSABILITY\n         EJECT\n***********************************************************************\n*                                                                     *\n*        SUBROUTINE TO BUILD BASIC JOB INFORMATION MESSAGE            *\n*                                                                     *\n***********************************************************************\n         SPACE 1                                                   SPR2\nCOFJMB   EQU   *\n         LR    R1,R5               SET JQE ADDRESS FOR SUBROUTINE  @133\n         LA    R0,COMMAND+4        SET MESSAGE AREA ADDRESS        @133\n***********************************************************************\n*                                                                     *\n*        COFJID  --  INSERTS THE FOLLOWING STANDARD JOB INFORMATION   *\n*                    INTO A MESSAGE AREA.                             *\n*                                                                     *\n*        JOB TYPE   - JOB,STC,TSU                                     *\n*        JOB NUMBER - JOB NUMBER WITH LEADING BLANK                   *\n*        JOB NAME   - JOBNAME PADDED TO 8 CHARACTERS                  *\n*                                                                     *\n*     REGISTER      ENTRY                   EXIT                      *\n*        R3      ADDRESS OF               ADDRESS OF NEXT             *\n*                  MESSAGE AREA             AVAILABLE BYTE            *\n*        R1      JQE ADDRESS              UNCHANGED                   *\n*                                                                     *\n*     NOTE                                                            *\n*        COMDWORK WILL CONTAIN THE EBCDIC JOB NUMBER                  *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         USING JIDMSG,R3           PROVIDE MESSAGE ADDRESSABILITY  @133\n         SPACE 1\nCOFJID   EQU   *   $SAVE  ,         SAVE CALLER'S REGISTERS\n*      WE NEED TO SAVE SOME REGS HERE (I DON'T KNOW WHERE)\n*        LR    R8,R15              RELOAD BASE ADDRESS             @133\n         LR    R3,R0               POINT TO MESSAGE BUILD AREA     @133\n         MVI   JIDMSG,C' '         INSERT BLANK AND                @133\n         MVC   JIDMSG+1(JIDMSGLN-1),JIDMSG  CLEAR FIELD            @133\n         SPACE 1\n         MVC   JIDTYPE,=C'JOB'     ASSUME BATCH JOB                @133\n         TM    JQEFLAG3,JQE3JOB    IS THIS A BATCH JOB...          @133\n         BZ    COFJIDC               YES - CONTINUE MESSAGE        @133\n         MVC   JIDTYPE,=C'STC'     ASSUME STARTED TASK             @133\n         TM    JQEFLAG3,JQE3STC    IS THIS A STC...                @133\n         BO    COFJIDC               YES - CONTINUE MESSAGE        @133\n         MVC   JIDTYPE,=C'TSU'     NO - MUST BE A TSU              @133\n         EJECT\nCOFJIDC  LH    R0,JQEJOBNO         PICK UP JOB NUMBER              @133\nCOFJIDE $CFCVE  VALUE=(R0)         CONVERT JOB NBR TO EBCDIC       @133\n         MVC   JIDJNO,COMDWORK     MOVE JOB NUMBER TO MSG          @133\n         SPACE 1\n         MVC   JIDJNAME,JQEJNAME   INSERT THE JOB NAME             @133\n         LA    R0,JIDMSGLN(,R3)    POINT TO NEXT AVAIL MSG BYTE    @133\n*\n*     END OF COFJID ROUTINE\n*\n         MVI   COFQUE-1,C' '       BLANK OUT REST OF               @133\n         MVC   COFQUE(COFSPMSG-COFQUE),COFQUE-1  MESSAGE AREA      @133\n         MVC   COFPRIO,=C'PRIO'    SET 'PRIO'\n         SLR   R0,R0               ZERO PRIORITY\n         IC    R0,JQEPRIO          PICK UP PRIORITY * 16\n         SRA   R0,4                DIVIDE BY 16\n        $CFCVE ,                   CONVERT TO EBCDIC\n         MVC   COFPRI,COMDWORK+5-L'COFPRI MOVE PRIORITY\n         LA    R15,COFFLAGS        SET ADDRESS OF NEXT MESSAGE AREA\n         TM    JQEFLAG1,JQE1HLDA+JQE1HLD1+JQE1HLD2+JQE1PURG+JQE1OCAN\n*                                  TEST FOR ANY JOB FLAGS\n         BZ    COFJMBB             NONE--FILL IN THE AFFINITIES\n         MVC   COFFLAGS(4),=C'HOLD'  ASSUME JOB IS HELD\n         LA    R15,5(,R15)         PT TO NEXT AVAILABLE MSG AREA\n         TM    JQEFLAG1,JQE1HLDA+JQE1HLD1  TEST FOR 'HELD'\n         BNZ   COFJMBB             IF HELD--GO TO AFFINITIES FILL-IN\n         MVC   COFFLAGS(5),=C'PURGE'  ASSUME PURGE\n         LA    R15,1(,R15)         PT TO NEXT AVAILABLE MSG AREA\n         TM    JQEFLAG1,JQE1PURG   TEST FOR SAME\n         BO    COFJMBB             YES--FILL-IN AFFINITIES\n         MVC   COFFLAGS(6),=C'CANCEL'  ASSUME 'CANCELLED'\n         LA    R15,1(,R15)         PT TO NEXT AVAILABLE MSG AREA\n         TM    JQEFLAG1,JQE1OCAN   TEST FOR CANCELLED\n         BO    COFJMBB             YES--FILL-IN AFFINITIES\n         MVC   COFFLAGS,=C'DUPLICATE'  MUST BE DUPLICATE JOB NAME\n         LA    R15,3(,R15)         PT TO NEXT AVAILABLE MSG BYTE\n         SPACE 1                                                   @133\nCOFJMBB  DS    0H                  COMPLETE MESSAGE BODY AND SVAE LN\n         LA    R14,COFJOB          GET ADDRESS OF MSG BEGINNING\n         SLR   R15,R14             COMPUTE MESSAGE LENGTH\n         STH   R15,COFLNGTH        SET LENGTH                      SPR2\n         BR    R6                   AND RETURN                      N30\n         EJECT\n***********************************************************************\n*                                                                     *\n*        ADD QUEUED SYSTEM NAMES TO MESSAGE                           *\n*                                                                     *\n***********************************************************************\n         SPACE 1\nCOFJMAFQ LH    R15,COFLNGTH        ADD QUEUED NAMES, GET LENGTH    @133\n         LA    R15,COFJOB(R15)     PT TO CURRENT MSG END\n         TM    JQEFLAG2,JQE2SAF    TEST FOR QUEUED TO 'ANY'\n         BNO   COFJMAF1            NO--PLACE ALL NAMES IN MSG\n         MVC   0(3,R15),=C'ANY'    SET AFFINITY SYS NAMES TO 'ANY'\n         LA    R15,3(,R15)         PT TO NEW END OF MSG\n         B     COFJMAF2            AND EXIT\n         SPACE 1                                                   SPR2\nCOFJMAF1 DS    0H                  ADD SPECIFIC SYS NAMES\n         L     R14,$QSE1           POINT TO 1ST QSE\n         USING QSEDSECT,R14        QSE ADDRESSABILITY\nCOFJMAF3 IC    R2,QSESIAFF         PICK UP SYSTEM AFFINITY BIT    @SPR2\n         EX    R2,COFJMAFF         TEST FOR JOB QUEUED TO THIS SYS\n         BZ    COFJMAF4            NO--SEARCH ALL ELEMENTS\n         MVC   0(L'QSESID,R15),QSESID YES--PUT NAME IN MSG\n         LA    R15,L'QSESID+1(,R15) COMPUTE NEXT NAME LOCATION\nCOFJMAF4 DS    0H                  CYCLE THROUGH ALL ELEMENTS\n*KK      TM    QSESTAT,QSELAST     TEST FOR LAST ELEMENT           SPR2\n         LA    R14,QSELEN(,R14)    BUMP TO NEXT QSE               @SPR2\n         CLC   QSESID,=CL4' '        BLANK                       WDPSC\n         BE    COFKK               NOT LAST LOOP\n         CLC   QSESID,=XL4'00'       ZERO                        WDPSC\n         BZ    COFJMAF3            NOT LAST LOOP\nCOFKK    BCTR  R15,0               REDUCE MSG FOR XTR BLANK\nCOFJMAF2 DS    0H                  TEST FOR 'IND' MODE OF OPERATION\n         TM    JQEFLAG2,JQE2IND    TEST FOR 'IND' MODE\n         BZ    COFJMAF5            NO--SEND MESSAGE AS IS\n         MVC   1(3,R15),=C'IND'    SET 'IND ' MODE IN MESSAGE\n         LA    R15,4(,R15)         PT TO END OF MESSAGE\nCOFJMAF5 DS    0H                  COMPUTE MESSAGE LENGTH\n         LA    R14,COFJOB          PT TO MSG BEGINNING\n         SLR   R15,R14             COMPUTE NEW LENGTH\n         STH   R15,COFLNGTH        SET NEW LENGTH                  SPR2\n         BR    R6                   AND RETURN                      N30\n         SPACE 1\nCOFJMAFF TM    JQEFLAG2,*-*        **** EXECUTE ONLY ****\n         SPACE 1                                                   @133\n         DROP  R14                 DROP QSE ADDRESSABILITY\n         EJECT\n***********************************************************************\n*                                                                     *\n*        SEND MESSAGE FOR JOB ACTIVITY                                *\n*                                                                     *\n***********************************************************************\n         SPACE 1\nCOFJWTO  DS    0H                  CREATE MESSAGE OUTPUT\n         BR    R6                 NOP\n$ZEROES  DC    XL2'00'\n         LTORG     ,\n         END       ,\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "SIMLKOMM": {"ttr": 34309, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x00\\x00\\x00\\x00\\x88\\x00\\x7f\\x00\\x88\\x00\\x7f\\x12\\x00\\x00'\\x00'\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf2\\xf7\\xf0@@@\"", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-01-07T00:00:00", "modifydate": "1988-01-07T12:00:00", "lines": 39, "newlines": 39, "modlines": 0, "user": "FILE270"}, "text": "       ID DIVISION.                                                     12/21/79\n       PROGRAM-ID. SIMLKOMM.                                            764ICSEL\n       AUTHOR.     JEFF SPREHN.                                         CT LV003\n           EJECT\n       ENVIRONMENT DIVISION.\n           EJECT\n       DATA DIVISION.\n\n           EJECT\n       WORKING-STORAGE SECTION.\n\n\n       01  SIMKOMM-MENU                             PIC X(19).\n\n           EJECT\n       01  PASSREC.\n           05  IOPARM          VALUE SPACES         PIC X(8).\n           05  OUTLEN                               PIC S9(4) COMP.\n           05  OUTBUFF                              PIC X(19).\n           05  INLEN                                PIC S9(4) COMP.\n           05  INBUFF                               PIC X(7).\n           05  RETLEN                               PIC S9(4) COMP.\n           05  SCRUFF                               PIC X(1920).\n           EJECT\n       PROCEDURE DIVISION.\n\n           CALL 'SIMKOMM' USING SIMKOMM-MENU.\n\n           MOVE SIMKOMM-MENU TO OUTBUFF.\n\n           MOVE '3OXXXXXB' TO IOPARM.\n           MOVE +19 TO OUTLEN.\n           MOVE +7  TO INLEN.\n           MOVE SPACES TO INBUFF.\n\n           CALL 'FULLSCR3'\n             USING IOPARM OUTLEN OUTBUFF INLEN INBUFF RETLEN SCRUFF.\n\n           GOBACK.\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "SKELS": {"ttr": 34311, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x00\\x7f\\x00\\x88\\x00\\x7f\\x12\\x00\\x00>\\x00>\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf2\\xf7\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-01-07T00:00:00", "modifydate": "1988-01-07T12:00:00", "lines": 62, "newlines": 62, "modlines": 0, "user": "FILE270"}, "text": "./ ADD NAME=DOCPDR90 0100-86188-86188-1747-00023-00023-00000-KX00150\n//&PJN JOB  (&PACCT),'&PPROG',CLASS=&PJOBC,MSGCLASS=X\n/*JOBPARM  LINECT=102,L=100\n//*\n//S1   EXEC PGM=LISTPDS,PARM='DECK,NOLIST'\n//*\n//SYSPRINT DD SYSOUT=*\n//SYSLIST  DD SYSOUT=*\n//SYSLIB DD DISP=SHR,DSN=&PDOCN\n//SYSPUNCH DD DISP=(NEW,PASS),DSN=&&TDOC,\n// UNIT=SYSSQ,SPACE=(CYL,(1,1),RLSE)\n//SYSIN DD DUMMY\n//*\n//M EXEC ROTATE90,\n//       INLRECL=91,\n//       LENGTH=90,\n//       LINES=60,\n//       OUTLREC=121,\n//       CHARS=&PCHSET,\n//       FCB=&PFCB,\n//       COPIES=&PCOPIES,\n//       TRNB=D,\n//       TRNA=&PTRNA\n//INPUT  DD DISP=SHR,DSN=&&TDOC\n./ ADD NAME=DOCR90   0108-86043-86189-1147-00014-00013-00000-KK00150\n//&PJN JOB  (&PACCT),'&PPROG',CLASS=&PJOBC,MSGCLASS=X\n/*JOBPARM  LINECT=102,L=100\n//M EXEC ROTATE90,\n//       INLRECL=86,             WAS 91\n//       LENGTH=85,              WAS 90\n//       LEFTMRG=&PLMRG,         WAS 0\n//       LINES=60,\n//       OUTLREC=121,\n//       CHARS=&PCHSET,\n//       FCB=&PFCB,\n//       COPIES=&PCOPIES,\n//       TRNB=D,\n//       TRNA=&PTRNA\n//INPUT  DD DISP=SHR,DSN=&PDOCN\n./ ADD NAME=FULLUT1  0104-80058-80120-1531-00013-00007-00000-LL02150\nCOMMAND  FULLUT1\n &*FSOPT\n &SCREEN\n &FORLIB\n &ASMSRC\n &ASMLOD\n  CTL1('&ATTR1')\n  CTL2('&ATTR2')\n  CTL3('&ATTR3')\n  CTL4('&ATTR4')\n  CTL5('&ATTR5')\n  CTL6('&ATTR6')\nEND\n./ ADD NAME=FULLUT2  0113-79307-80149-1132-00008-00007-00000-KK00150\nCOMMAND  FULLUT2\n  &SCREEN\n  &ASMLOD\n  SCRUFLG(&*A)\n  IOBUFLG(&*B)\n  SCRNFLG(&*C)\n  DEST(&FU2DEST)\nEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "SMF64EX$": {"ttr": 34313, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x00\\x7f\\x00\\x88\\x00\\x7f\\x12\\x00\\x00:\\x00:\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf2\\xf7\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-01-07T00:00:00", "modifydate": "1988-01-07T12:00:00", "lines": 58, "newlines": 58, "modlines": 0, "user": "FILE270"}, "text": "\n\n\n\n\n\n           PROGRAM NAME: SMF64EXT\n\n\n           AUTHOR:       Howard H. Glastetter\n\n                         WASHINGTON STATE DATA PROCESSING SERVICE CENTER\n\n\n           FUNCTION:     Extract SMF TYPE64 (VSAM activity) records from\n                         daily SMF.  Reformat the records and translate\n                         binary time fields so that high level languages\n                         can easily work with the output file.\n\n           PURPOSE:      SMF Type 64 records give a picture of global\n                         VSAM activity for the time period that the SMF\n                         records were collected.  This data can be sorted\n                         and selected for a variety of useful purposes.\n\n                         1) It can show all VSAM activity by volume.  This\n                            can aid in balancing the work load and selecting\n                            CACHE candidate VSAM at the dataset level.\n\n                         2) VSAM can be sorted by CICS region to see where\n                            the active online VSAM is located.  Contending\n                            datasets can then be seperated - the read only\n                            datasets going to CACHE volumes.\n\n                         3) Fragmented active VSAM can be globally viewed.\n\n                         4) Unusually high VSAM EXCP counts with apparent\n                            low accomplishments (ie the BUFSP is too small)\n                            jump out of the woodwork.\n\n           ADVANTAGE:    The unmanageable process of trying to keep the\n                         VSAM data running efficiently now moves up to\n                         the piont that it's only unwieldly.  Actually\n                         this process can be put into the customers hands\n                         and they can easily monitor their own data.\n\n                         A paper that describes how this process can be used\n                         to build and maintain VSAM volumes that benefit\n                         from CACHE controllers is coming out in the Fall\n                         1986 issue of CMG Transactions.\n\n           NOTE:         A VSAM close of a dataset with an AUX INDEX will\n                         generate duplicate TYPE 64 records for all of the\n                         datasets componants.  Also, when the last job of\n                         the day completes and the VSAM Catalog is closed,\n                         the catalog activity (TYPE 64) record is apparently\n                         posted to that last job.  So, don't spend time\n                         trying to find out why that tiny CICS region is\n                         doing so much activity to the VSAM catalog(s).\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "SMF64EX#": {"ttr": 34315, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x00\\x7f\\x00\\x88\\x00\\x7f\\x12\\x00\\x00\\xba\\x00\\xba\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf2\\xf7\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-01-07T00:00:00", "modifydate": "1988-01-07T12:00:00", "lines": 186, "newlines": 186, "modlines": 0, "user": "FILE270"}, "text": "//         JOB\n//       MSGLEVEL=(1,1),CLASS=H,NOTIFY=HG00150\n//*\n//*\n//*      THIS JOB EXTRACTS SMF TYPE 64 FROM AN SMF FILE\n//*\n//*\n//JOBCAT  DD  DISP=SHR,DSN=SYS1.USERCAT1     (VSAMSMF)\n/*ROUTE PRINT LOCAL\n//*\n//DOITTOIT EXEC VSAMSMF,AGY=954CICW\n//*\n//*  *  *  *  *  *  *  *  *  BUILD SMF64 FILE   *  *  *\n//*\n//XTRACT64 EXEC PGM=SMF64EXT\n//STEPLIB DD DSN=WDPSC.SHARED.LOAD,DISP=SHR\n//FILEIN  DD DSN=XXXXXXXX.VSAMDATA,DISP=SHR,\n//           DCB=(RECFM=VBS,LRECL=32760)\n//FILEOUT DD DSN=EXCHANGE.SMF64.VSAMSTAT,DISP=(,CATLG,DELETE),\n//        DCB=(BLKSIZE=11408,RECFM=FB),UNIT=SYSDA,\n//        SPACE=(CYL,(3,1))\n//PRINTOUT DD SYSOUT=*\n//SYSUDUMP DD SYSOUT=*\n//*\n//*  *  *  *  *  *  *  *  *\n//*  *  *  *  *  *  *  *  *\n//*  *  *  *  *  *  *  *  *\n//*\n//*\n//*\n//*\n//*\n//*\n//         JOB\n//       MSGLEVEL=(1,1),CLASS=H\n//*\n//*\n//*      THIS JOB GIVES A REPORT BY VOLUME OF ALL VSAM DATASETS\n//*      THAT HAD 500 OR MORE EXCPS BY ANY ONE PROCESS.\n//*\n//*\n//JOBCAT  DD  DISP=SHR,DSN=SYS1.USERCAT1\n/*ROUTE PRINT LOCAL\n//STEP1  EXEC DYL280,RGN=512\n//FILEIN DD DSN=EXCHANGE.SMF64.VSAMSTAT,DISP=SHR\n FILE FILEIN FB 124\n  SMF64TME     4 CH        (END'TIME)\n  FILLER       1\n  SMF64DTE     3 PD\n  SMF64JBN     8           (JOB NAME)\n  SMF64RST     4 CH        (START'TIME)\n  SMF64RSD     4 PD\n  SMF64DNM     44          (VSAM DSN)\n  SMF64NLR     4 BI Z      (RECORD'TOTAL)\n  SMF64NFS     4 BI\n  FILLER       2\n  SMF64NCS     2 BI Z      (TOT CI'SPLITS)\n  FILLER       2\n  SMF64NAS     2 BI Z      (TOT CA'SPLITS)\n  SMF64DDE     4 BI Z      (REC'DEL)\n  SMF64DIN     4 BI Z      (REC'INS)\n  SMF64DUP     4 BI Z      (REC'UPD)\n  SMF64DRE     4 BI Z      (REC'READ)\n  SMF64DFS     4 BI\n  FILLER       2\n  SMF64DCS     2 BI Z      (JOB CI'SPLITS)\n  FILLER       2\n  SMF64DAS     2 BI Z      (JOB CA'SPLITS)\n  SMF64DEP     4 BI Z      (JOB'EXCPS)\n  FILLER       1 BI\n  SMF64XTN     1 BI Z      (FILE'XTNS)\n  SMF64VSR     6           (VOLSER)\nWORKAREA\n   NONREAD      3  BI  Z  (UPDTS'INSRTS'DELS)\n  IF SMF64DEP GT 499 GOTO SORTEM ELSE REJECT ENDIF   <------------\nSORTEM:\n  SORT FILEIN USING SMF64VSR SMF64DNM SMF64JBN       <------------\n   NONREAD = SMF64DDE + SMF64DIN + SMF64DUP\n  REPORT 150 WIDE\n  CONTROL SMF64VSR                                   <------------\n  LIST SUPPRESS SMF64VSR SUPPRESS SMF64DTE\n   SMF64DNM\n   SMF64JBN\n   SMF64DEP\n   SMF64NLR\n   SMF64DRE\n   NONREAD\n   SMF64NCS\n   SMF64NAS\n   SMF64XTN\n   SMF64RST\n   SMF64TME\n                        WITH 1 BEFORE AND 1 AFTER\n  ON CHANGE SMF64VSR\n  LIST '-TOTALS-' AT SMF64VSR SUM SMF64DEP\n                              SUM SMF64DRE\n                              SUM NONREAD\n                              WITH 2 BEFORE AND WITH 2 AFTER\n T1 'VSAM ACTIVITY BY VOLUME DURING PRIME SHIFT'\n T1+5 DYLDATE\n T1+125 DYLPAGE\n T2 ' '\n//*\n//*  *  *  *  *  *  *  *  *\n//*  *  *  *  *  *  *  *  *\n//*  *  *  *  *  *  *  *  *\n//*\n//*\n//*\n//*\n//*\n//*\n//         JOB\n//       MSGLEVEL=(1,1),CLASS=H\n//*\n//*\n//*      THIS JOB GIVES A REPORT VSAM DATASETS THAT HAD\n//*      200 OR MORE EXCPS BY A CICS REGION CALLED CICS0150\n//*\n//*\n//JOBCAT  DD  DISP=SHR,DSN=SYS1.USERCAT1                 SMF BY VOLSER\n/*ROUTE PRINT LOCAL\n//STEP1  EXEC DYL280,RGN=512\n//FILEIN DD DSN=EXCHANGE.SMF64.VSAMSTAT,DISP=SHR\n FILE FILEIN FB 124\n  SMF64TME     4 CH        (END'TIME)\n  FILLER       1\n  SMF64DTE     3 PD\n  SMF64JBN     8           (JOB NAME)\n  SMF64RST     4 CH        (START'TIME)\n  SMF64RSD     4 PD\n  SMF64DNM     44          (VSAM DSN)\n  SMF64NLR     4 BI Z      (RECORD'TOTAL)\n  SMF64NFS     4 BI\n  FILLER       2\n  SMF64NCS     2 BI Z      (TOT CI'SPLITS)\n  FILLER       2\n  SMF64NAS     2 BI Z      (TOT CA'SPLITS)\n  FILLER       3\n  SMF64DDE     1 BI Z      (REC'DEL)\n  FILLER       3\n  SMF64DIN     1 BI Z      (REC'INS)\n  FILLER       3\n  SMF64DUP     1 BI Z      (REC'UPD)\n  SMF64DRE     4 BI Z      (REC'READ)\n  SMF64DFS     4 BI\n  FILLER       2\n  SMF64DCS     2 BI Z      (JOB CI'SPLITS)\n  FILLER       2\n  SMF64DAS     2 BI Z      (JOB CA'SPLITS)\n  SMF64DEP     4 BI Z      (JOB'EXCPS)\n  FILLER       1 BI\n  SMF64XTN     1 BI Z      (FILE'XTNS)\n  SMF64VSR     6 CH        (VOLSER)\nWORKAREA\n   NONREAD      3  BI  Z  (UPDTS'INSRTS'DELS)\n  IF SMF64DEP LT 100 REJECT ENDIF\n  IF SMF64JBN EQ 'CICS0150' GOTO SORTEM ELSE REJECT ENDIF <---------\nSORTEM:\n  SORT FILEIN USING SMF64DNM SMF64JBN\n   NONREAD = SMF64DDE + SMF64DIN + SMF64DUP\n  REPORT 150 WIDE\n  LIST SUPPRESS SMF64JBN SUPPRESS SMF64DTE\n   SMF64VSR\n   SMF64DNM\n   SMF64DEP\n   SMF64NLR\n   SMF64DRE\n   SMF64DDE\n   SMF64DIN\n   SMF64DUP\n   SMF64NCS\n   SMF64NAS\n   SMF64XTN\n   SMF64RST\n   SMF64TME\n                        WITH 1 BEFORE AND 1 AFTER\n  ON FINAL\n  LIST '-TOTALS-' AT SMF64DNM SUM SMF64DEP\n                              SUM SMF64DRE\n                              SUM NONREAD\n                              WITH 2 BEFORE AND WITH 2 AFTER\n T1 'VSAM ACTIVITY BY A SINGLE JOB'\n T1+5 DYLDATE\n T1+125 DYLPAGE\n T2 ' '\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "SMF64EXT": {"ttr": 34319, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x00\\x7f\\x00\\x88\\x00\\x7f\\x12\\x00\\x00\\xac\\x00\\xac\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf2\\xf7\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-01-07T00:00:00", "modifydate": "1988-01-07T12:00:00", "lines": 172, "newlines": 172, "modlines": 0, "user": "FILE270"}, "text": "SMF64EXT CSECT\n*\n*\n*        THE PURPOSE OF THIS PROGRAM IS EXTRACT AND REFORMAT SMF 64\n*        RECORD TYPES.  THESE RECORDS SUMMARIZE ACTIVITY THAT OCCURRED\n*        ON VSAM FILES DURING THE PROCESS OF JOB EXECUTIONS.  THIS\n*        DATA SHOULD BE USEFUL DETERMINING WHAT VSAM FILES ARE POORLY\n*        ALLOCATED.  IT SHOULD ALSO BE VERY USEFUL IN IDENTIFYING WHAT\n*        VSAM FILES SHOULD RESIDE ON CACHED VOLUMES.\n*\n*\n*        WRITTEN 02-14-85 BY HOWARD H. GLASTETTER\n*\nR0       EQU   0\nR1       EQU   1         POINTER TO LATEST INPUT RECORD\nR2       EQU   2\nR3       EQU   3         WORK POINTER TO INPUT RECORD\nR4       EQU   4         WORK AREA FOR RR DIVIDE\nR5       EQU   5         *\nR6       EQU   6         *\nR7       EQU   7\nR8       EQU   8         WORK FOR TIME CONVERSION\nR9       EQU   9         *\nR10      EQU   10        SUBROUTINE LINKAGE\nR11      EQU   11\nR12      EQU   12        BASE\nR13      EQU   13        SYSTEM LINKAGE\nR14      EQU   14\nR15      EQU   15\n*\nBEGIN    SAVE  (14,12)       PROGRAM LINKAGE AND INITIATION\n         BALR  12,0\n         USING *,12\n         ST    R13,REGSAVE+4\n         LA    R11,REGSAVE\n         ST    R11,8(R13)\n         LR    R13,R11\n*\n         PRINT ON,NOGEN\n         OPEN  (FILEIN,,FILEOUT,(OUTPUT),PRINTOUT,(OUTPUT))\n*\n         EJECT\nLOOP10   EQU   *\n         GET   FILEIN\n         AP    INCOUNT,=X'1C'\n         LR    R3,R1            POINT R3 TO THE INPUT RECORD\n         CLI   5(R3),X'40'      CHECK FOR RECORD TYPE 64\n         BE    LOOP10A\n         AP    BYPASSES,=X'1C'\n         B     LOOP10\n*\nLOOP10A  EQU   *\n         MVC   BTIME,6(R3)           CONVERT BI TIME TO HHMM CH\n         BAL   R10,TIME40            *   * START TIME *\n         MVC   SMF64TME,HHMMSS       *   SS WILL BE DROPPED\n*\n         MVC   SMF64DTE,10(R3)\n         MVC   SMF64JBN,18(R3)       JOB NAME\n*\n         MVC   BTIME,26(R3)          CONVERT BI TIME TO HHMM CH\n         BAL   R10,TIME40            *   * END TIME *\n         MVC   SMF64RST,HHMMSS       *   SS WILL BE DROPPED\n*\n         MVC   SMF64RSD,30(R3)       JOB START DAY\n         MVC   SMF64DNM,88(R3)       VSAM DSN\n         MVC   SMF64VSR,148(R3)      1ST OCCURANCE OF VOLSER\n*\n         MVC   HALFWORD,138(R3)      POINT PAST EXTENTS\n         AH    R3,HALFWORD           *\n         AH    R3,=H'140'            * ALSO INITIAL SEGMENT\n         SR    R4,R4                 FIND NUMBER OF EXTENTS\n         LH    R5,HALFWORD           *\n         LH    R6,=H'26'             *\n         DR    R4,R6                 *\n         STH   R5,SMF64XTN           PLACE THE NUMBER IN OUTPUT RECORD\n*\n         MVC   SMF64NLR,12(R3)       # OF RECORDS\n         MVC   SMF64NFS,32(R3)       # UNUSED CI\n         MVC   SMF64NCS,36(R3)       TOTAL CONTROL INTERVAL SPLITS\n         MVC   SMF64NAS,40(R3)       TOTAL CONTROL AREA SPLITS\n         MVC   SMF64DDE(32),60(R3)   MOVE LAST 8 FIELDS\n*\nWRITE20  EQU   *\n         PUT   FILEOUT,RCRDOUT\n         AP    OUTCOUNT,=X'1C'\n         B     LOOP10\n*\nEOF30    EQU   *\n         ED    INRECS,INCOUNT\n         ED    OUTRECS,OUTCOUNT\n         ED    BYPRECS,BYPASSES\n         PUT   PRINTOUT,PRINTREC\n         CLOSE (FILEIN,,FILEOUT,,PRINTOUT)\n         L     R13,REGSAVE+4\n         RETURN (14,12),RC=0\n         EJECT\n*\n*****************************************************************\n*  CALCULATE HOURS, MINUTES, SECONDS    *  S U B R O U T I N E  *\n*****************************************************************\n*\nTIME40   EQU   *\n         L     R9,BTIME                REG 9  = STORE CLOCK TIME\n         SLR   R8,R8                   PREP REG 8 FOR WORK\n         D     R8,=F'100'              CONVERT 100S OF SECS TO SECS\n         CVD   R9,DOUBLE               CONVERT SECONDS TO PACKED\n         MVC   WORKTIME(6),DOUBLE+2    MOVE SECONDS TO WORK AREA\n         DP    WORKTIME,=PL3'3600'     CALCULATE HOURS\n*                                    QQQQQSRRRRRS  Q=QUOTIENT R=REMAIN\n*                                    000HHCSSSSSC  H=HOURS S=SECONDS\n         UNPK  HHMMSS(2),WORKTIME+1(2)   CURRENT HOUR\n         OI    HHMMSS+1,X'F0'          NORMALIZE THE SIGN\n*\n         MVC   WORKTIME(3),=XL3'0'     ZERO OUT TOP HALF\n         DP    WORKTIME,=PL2'60'       CALCULATE MINUTES\n*                                    QQQQQQQSRRRS  Q=QUOTIENT R=REMAIN\n*                                    00000MMCSSSC  H=HOURS S=SECONDS\n         UNPK  HHMMSS+2(2),WORKTIME+2(2) THE MINUTES\n         OI    HHMMSS+3,X'F0'          NORMALIZE THE SIGN\n*\n         UNPK  HHMMSS+4(2),WORKTIME+4(2) MOVES REMAINING SECONDS\n         OI    HHMMSS+5,X'F0'          NORMALIZE THE SIGN\n*\n         BR    R10                     RETURN TO MAINLINE\n*\n         EJECT\nREGSAVE  DS    9D\nDOUBLE   DC    D'0'\nBTIME    DC    F'0'\nWORKTIME DC    PL6'0'\nHHMMSS   DC    CL6'0'\nHALFWORD DC    H'0'\nINCOUNT  DC    PL5'0'\nOUTCOUNT DC    PL5'0'\nBYPASSES DC    PL5'0'\n*\nFILEIN   DCB   DDNAME=FILEIN,MACRF=(GL),EODAD=EOF30,DSORG=PS,BFTEK=A\nFILEOUT  DCB   DSORG=PS,LRECL=124,DDNAME=FILEOUT,MACRF=(PM)\nPRINTOUT DCB   DSORG=PS,LRECL=80,DDNAME=PRINTOUT,MACRF=(PM)\n*\nPRINTREC DS    0CL80    OUTPUT RECORD AREA\n         DC    CL8'        '\nINRECS   DC    XL12'402020206B2020206B202020'\n         DC    CL12' INPUT      '\nOUTRECS  DC    XL12'402020206B2020206B202020'\n         DC    CL13' OUTPUT      '\nBYPRECS  DC    XL12'402020206B2020206B202020'\n         DC    CL11' BYPASSED  '\n*\n         DS    0F\nRCRDOUT  DS    0CL124    OUTPUT RECORD AREA\nSMF64TME DS    CL4       JOB END TIME\nSMF64DTE DS    PL4       DATE 00YYDDDF SMF CREATED\nSMF64JBN DS    CL8       JOBNAME\nSMF64RST DS    CL4       JOB START TIME\nSMF64RSD DS    PL4       JOB START  00YYDDDF\nSMF64DNM DS    CL44      VSAM DSN\nSMF64NLR DS    F         NUMBER OF RECORDS IN COMPONANT\nSMF64NFS DS    F         NUMBER OF UNUSED CONTROL INTERVALS\nSMF64NCS DS    F         TOTAL NUMBER OF CONTROL INTERVAL SPLITS\nSMF64NAS DS    F         TOTAL NUMBER OF CONTROL AREA SPLITS\nSMF64DDE DS    F         NUMBER OF RECORDS DELETED BY THIS JOB\nSMF64DIN DS    F         NUMBER OF RECORDS INSERTED BY THIS JOB\nSMF64DUP DS    F         NUMBER OF RECORDS UPDATED BY THIS JOB\nSMF64DRE DS    F         NUMBER OF RECORDS RETRIEVED BY THIS JOB\nSMF64DFS DS    F         CHANGE IN UNUSED CONTROL INTERVALS (+ OR -)\nSMF64DCS DS    F         CONTROL INTERVALS SPLIT BY THIS JOB\nSMF64DAS DS    F         CONTROL AREAS SPLIT BY THIS JOB\nSMF64DEP DS    F         EXCPS DONE BY THIS JOB\nSMF64XTN DS    H         NUMBER OF FILE EXTENTS\nSMF64VSR DS    CL6       VOLSER\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "SMF74MO$": {"ttr": 34564, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x00\\x7f\\x00\\x88\\x00\\x7f\\x12\\x00\\x002\\x002\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf2\\xf7\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-01-07T00:00:00", "modifydate": "1988-01-07T12:00:00", "lines": 50, "newlines": 50, "modlines": 0, "user": "FILE270"}, "text": "\n\n\n\n\n\n\n\n\n\n           PROGRAM NAME: SMF74MOD\n\n\n           AUTHOR:       Howard H. Glastetter   (206) 902-3102\n\n                         WASHINGTON STATE DATA PROCESSING SERVICE CENTER\n\n\n           PURPOSE:      The RMF DIRECT ACCESS DEVICE ACTIVITY REPORT\n                         only reports on DASD within a single CPU.  This\n                         makes it difficult to spot heavy usage of some\n                         volumes that are being accessed by more than\n                         one CPU in a shared DASD environment.  This\n                         program causes the ERBRMFPP program to give a\n                         summary of all shared DASD from all CPUs on\n                         one ERBRMFPP report.\n\n           FUNCTION:     Process SMF Type 74 records, change the CPU\n                         ID on all records to a common name (COMB) and\n                         multiply various fields by the number of CPUs\n                         represented by the RMF Type 74 data.  The CPU\n                         count is passed as a PARM to SMF74MOD.  Both\n                         XA and Non XA SMF Type 74 are modified.  The\n                         IBM ERBRMFPP program can handle both XA and\n                         Non XA SMF Type 74 with the same CPU name to\n                         produce a composite report.\n\n           ADVANTAGE:    The combined report can allow the viewer to\n                         see the effect of all CPUs on a single volume\n                         without adding counts from several reports.\n                         It allows the spotting of very busy devices\n                         that may need attention; but might be missed\n                         due to apparent moderate activity on seperate\n                         DASD within CPU reports.\n\n           NOTE:         The RMF on all CPUs must be collected using\n                         the same cycle time and elapsed time.  If any\n                         CPU needs IPLing during the collection time then\n                         the results will be inaccurate in porportion to\n                         the the CPU down time.\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "SMF74MO#": {"ttr": 34566, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x91\\x13o\\x00\\x91\\x13o\\x14E\\x00g\\x00g\\x00\\x00\\xe3\\xe2\\xd6\\xc3\\xc7\\xd3\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1991-05-16T00:00:00", "modifydate": "1991-05-16T14:45:00", "lines": 103, "newlines": 103, "modlines": 0, "user": "TSOCGLA"}, "text": "//HGX00155 JOB (2100,56-D),'HGLAS 6-1019',TIME=4,\n// CLASS=H,COND=(12,LT),MSGLEVEL=(1,1),REGION=999K,MSGCLASS=F\n/*TITLE 'DASD ACTIVITY'\n/*JOBPARM S=Q1CD\n//OUTPUT OUTPUT DEFAULT=YES,CLASS=F,FORMS=CPRO,JESDS=ALL\n//*  THE ABOVE CARD PUTS THE PRINT OUT TO MICROFICHE\n//*  ROUTE XEQ WSCXA\n//*  THIS JOB RESIDES IN SOFTD155.DAILY.CNTL(HGX00150)\n//*\n//*-----------------------------------------------------------------\n//*  THIS JOB IS AN RMF POST PROCESSOR REPORT FOR HOWARD GLASTETTER\n//*-----------------------------------------------------------------\n//*\n//RMFDASD  EXEC PGM=ERBRMFPP,REGION=800K,TIME=4\n//MFPINPUT DD DSN=SOFTD155.DAILY.RMF(0),DISP=SHR,DCB=BUFNO=10\n//SYSUDUMP DD SYSOUT=*\n//ABNLDUMP DD DUMMY\n//SYSIN    DD *\nSUMMARY(INT,TOT)\nDINTV(0830)\nRTOD(0845,1715)\nSTOD(0845,1715)\nSYSOUT(F)\nREPORTS(DEVICE(DASD,TAPE),CPU,PAGING,PAGESP,CHAN,IOQ)\n//*\n//*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n//* WAS THE BLEND DATASET CREATED TODAY?  RC0=YES RC4=NO RC8=NO FIND\n//*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n//*\n//CHKTODAY EXEC PGM=CHKTODAY,PARM='DPSCD155.BLEND.DATASET'\n//STEPLIB  DD DSN=WDPSC.SHARED.LOAD,DISP=SHR\n//SYSUDUMP DD SYSOUT=*\n//*\n//*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n//*        DELETE IF OLD, ELSE SKIP THIS STEP\n//*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n//*\n//DELSTEP  EXEC PGM=IEFBR14,COND=(4,NE,CHKTODAY)\n//DELETE   DD DSN=DPSCD155.BLEND.DATASET,DISP=(MOD,DELETE)\n//*\n//*  *  *  *  *  *  *  *  RECREATE IF DELETED, ELSE SKIP THIS STEP\n//*\n//*  *  *  *  *  *  *  *  FORCE A PHONY CPU ID CALLED 'COMB' AND\n//*  *  *  *  *  *  *  *  PHONY LCUS BASED OF 1ST 2 BYTES OF DEV ADDRS\n//*  *  *  *  *  *  *  *  AND MULTIPLY CERTAIN FIELDS BY THE NUMBER OF\n//*  *  *  *  *  *  *  *  CPUS CREATING THE RMF74.  THIS ADJUSTS FOR\n//*  *  *  *  *  *  *  *  ITEMS THAT ARE CALCULATED USING INTERVAL\n//*  *  *  *  *  *  *  *  COUNTS.  THE CPU NUMBER IS A PARM TO THE\n//*  *  *  *  *  *  *  *  PROGRAM BELOW.\n//*\n//RMFBLEND EXEC PGM=SMF74ALL,COND=(0,EQ,CHKTODAY),PARM=3,TIME=4\n//STEPLIB  DD DSN=WDPSC.SHARED.LOAD,DISP=SHR\n//PRINTOUT DD SYSOUT=*\n//FILEIN   DD DSN=SOFTD155.DAILY.RMF(0),DISP=SHR,DCB=BUFNO=10\n//*\n//FILEOUT  DD DSN=DPSCD155.BLEND.DATASET,\n//            DISP=(,CATLG,DELETE),\n//            UNIT=SYSDA,SPACE=(CYL,(30,8),RLSE),\n//            DCB=(LRECL=32760,BLKSIZE=23476,BUFNO=6,RECFM=VBS)\n//*\n//*  *  *  *  *  *  *  *  PRINT CPU BLEND REPORT\n//*\n//RMFHG    EXEC PGM=ERBRMFPP,REGION=800K,TIME=4\n//MFPINPUT DD DSN=DPSCD155.BLEND.DATASET,DISP=SHR,DCB=BUFNO=6\n//SYSUDUMP DD SYSOUT=*\n//ABNLDUMP DD DUMMY\n//SYSIN DD *\nSUMMARY(INT,TOT)\nDINTV(0830)\nRTOD(0845,1715)\nSTOD(0845,1715)\nSYSOUT(F)\nREPORTS(DEVICE(DASD))\nSYSID(COMB)\n//*\n//*  *  *  *  *  *  *  *     SPECIAL STEP FOR IBM - (NULLIFIED)\n//\n//RMFCHAN  EXEC PGM=ERBRMFPP,REGION=800K,TIME=4\n//MFPINPUT DD DSN=SOFTD155.DAILY.RMF(0),DISP=SHR,DCB=BUFNO=10\n//SYSUDUMP DD SYSOUT=*\n//ABNLDUMP DD DUMMY\n//SYSIN    DD *\nSUMMARY(INT,TOT)\nDINTV(0015)\nRTOD(1700,2400)\nSTOD(1700,2400)\nSYSOUT(F)\nREPORTS(CHAN)\n//*\n//*  *  *  *  *  *  *  *\n//*\n//*\n//*  *  *  *  *  *   SUBMIT MIKE STEINS JCL\n//*\n//SUBMIT   EXEC FTL\n//IN01     DD DSN=SOFTD155.DAILY.CNTL(SASA4155),DISP=SHR\n//OUT01    DD  SYSOUT=(A,INTRDR),DCB=BLKSIZE=80\n//*\n//*  *  *  *  *  *   SUBMIT IBM POSTPROCESSOR TAPE JOB\n//*\n//IN02     DD DSN=SOFTD155.DAILY.CNTL(IBM00155),DISP=SHR\n//OUT02    DD  SYSOUT=(A,INTRDR),DCB=BLKSIZE=80\n//\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "SMF74MOD": {"ttr": 34569, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x91\\x13o\\x00\\x94\\x04\\x7f\\x18\\x14\\x01$\\x01\"\\x00\\x05\\xe2\\xc2\\xc7\\xc3\\xe2\\xc3@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1991-05-16T00:00:00", "modifydate": "1994-02-16T18:14:00", "lines": 292, "newlines": 290, "modlines": 5, "user": "SBGCSC"}, "text": "SMF74ALL CSECT\n*\n*        THE PURPOSE OF THIS PROGRAM IS TO MODIFY TYPE 74 SMF (DEVICE\n*        ACTIVITY) RECORDS.  THE IDEA IS TO LOOK AT ACTIVITY FROM THE\n*        VIEWPOINT OF THE DEVICE.  THE DEVICE ACTIVITY REPORT IS GIVEN\n*        FROM THE POINT OF VIEW OF THE CPU DRIVING THE DEVICE (IE:\n*        SEPERATE DASD REPORTS ARE PROCUCED FOR EACH SYSTEM).\n*\n*        WHEN MORE THAN ONE CPU IS ACCESSING THE DASD, IT IS BUSIER\n*        THAN THE INDIVIDUAL REPORTS SAY.  THIS PROGRAM CHANGES THE\n*        CPU NAME TO \"COMB\" SO THAT THE RMF REPORTER PROGRAM THINKS\n*        IT IS DEALING WITH ONE CPU.  SINCE THE WASHINGTON STATE\n*        DEPARTMENT OF INFORMATION SERVICES (DIS) IS TAKING MEASURE-\n*        MENTS FROM 3 CPUS, MOST FIELDS ARE MULTIPLIED BY 3 (*) TO\n*        GIVE ACCURACY WHEN THE SAMPLE COUNT IS USED IN CALCULATING\n*        PERCENT BUSY, CONNECT TIME, AND DISCONNECT TIME.  THIS PROGRAM\n*        HANDLES SP AND XA TYPE-74 SMF RECORDS, SINCE THE (ERBRMFPP)\n*        REPORT PROGRAM IS CLEVER ENOUGH TO BLEND BOTH TYPE 74 SMF\n*        RECORDS WHEN THE CPU ID IS THE SAME.\n*\n*        * THIS PROCESS IS MODIFIED TO ACCEPT A PARM THAT INDICATES\n*        THE NUMBER OF CPUS SHARING THE DASD.  THIS PREVENTS HAVING\n*        TO MODIFY THE PROGRAM EVERY TIME THERE IS ONE MORE OR ONE\n*        LESS CPU SHARING THE DASD.  AS OF 12-20-90 WE HAVE 4 LOCICAL\n*        PARTITIONS SHARING COMMON DASD.  WITH AMDAHL MDF AND IBM\n*        PRSM, THIS PARM IS MORE USEFUL THAN ORIGINALLY THOUGHT.\n*\n*        WRITTEN 08-28-86 BY HOWARD H. GLASTETTER\n*\n*        MODIFIED 12-20-90 (HHG) TO ALSO HANDLE ESA RMF TYPE 74.\n*        LITTLE CODE NEEDED TO BE ADDED TO HANDLE ESA.  XA AND ESA\n*        ALSO WILL BE BLENDED BY ERBRMFPP IN A MIXED ENVIRONMENT.\n*        NOT SURE IF SP WILL BE BLENDED WITH ESA, HOWEVER.  I'D\n*        BE INTERESTED IN KNOWING IF ANYONE OUT THERE DOES IT.\n*\nR0       EQU   0\nR1       EQU   1         POINTER TO LATEST INPUT RECORD\nR2       EQU   2         PARM COMMUNICATION\nR3       EQU   3         WORK - INCREMENT THRU\nR4       EQU   4         *    - DEVICE CONTROL DATA SECTION\nR5       EQU   5         *    - VIA BXLE LOGIC\nR6       EQU   6         WORK POINTER TO INPUT RECORD\nR7       EQU   7         *    LENGTH OF INPUT RECORD (EXEC MOVE)\nR8       EQU   8         *    DITTO - AND MULTIPLY FIELDS BY 3\nR9       EQU   9                          * - AND WRITE OUTPUT\nR10      EQU   10        SUBROUTINE LINKAGE\nR11      EQU   11        WORK\nR12      EQU   12        BASE\nR13      EQU   13        SYSTEM LINKAGE\nR14      EQU   14\nR15      EQU   15\n         EJECT\nBEGIN    SAVE  (14,12)       PROGRAM LINKAGE AND INITIATION\n         BALR  12,0\n         USING *,12\n         ST    R13,REGSAVE+4\n         LA    R11,REGSAVE\n         ST    R11,8(R13)\n         LR    R13,R11\n*\n         L     R2,0(R1)            CPU COUNT PARM ADDRESS\n         PACK  PACKNUM,2(1,R2)     PACK IT\n         CVB   R2,PACKNUM          CONVERT IT TO BINARY\n         ST    R2,CPUCOUNT         READY TO USE\n*\n         PRINT ON,NOGEN\n         OPEN  (FILEIN,,FILEOUT,(OUTPUT),PRINTOUT,(OUTPUT))\nRMFLOOP  EQU   *\n         GET   FILEIN\n         AP    INCOUNT,=X'1C'\n         LR    R6,R1               POINT R6 TO THE INPUT RECORD\n         USING SMFRECRD,R6         *--> DOCUMEMTATON ONLY - FOR NOW\n         MVC   14(4,R6),=C'COMB'   GIVE ALL SMF THE SAME (SMF74SID)\n         CLI   5(R6),X'4A'         CHECK (SMF74RTY) FOR TYPE 74\n         BE    LOOP74\n         AP    NONRMF74,=X'1C'\n         LA    R3,RMF70            WHAT OTHER DATA IS COMING IN\n         LA    R4,13\n         LA    R5,RMF245\nWHATISIT EQU   *\n         CLC   4(1,R3),5(R6)\n         BE    ITSTHIS\n         BXLE  R3,R4,WHATISIT\nITSTHIS  EQU   *\n         AP    0(4,R3),=X'1C'      ADD IT TO THE TABLE\n         B     WRITE30             WRITE IT OUT\n         EJECT\nLOOP74   EQU   *\n         AP    RMF74,=X'1C'\n         TM    4(R6),X'1C'   (SMF74FLG) IS THIS XA OR ESA 4.2? HG 10/93\n         BZ    LOOP20              IF NOT, GO TO SP PROCESS\n         CLC   22(2,R6),=H'2'      IS THIS 74 SUBTYPE 2 - 4.2? HG 10/93\n         BE    WRITE30             SKIP, NOT -DASD- TYPE 74    HG 10/93\n*\n**                                 XA OR ESA AT THIS POINT\n*\n         LR    R3,R6               POINT TO DEVICE CONTROL DATA SECTION\n         A     R3,44(R6)           * (SMF74DDS) OFFSET-DEVICE DATA SEC\n         LH    R4,48(R6)           LOAD THE INCREMENT (LENGTH OF DDS)\n*                                  END ADDR CALCULATED BELOW\n         LH    R5,0(R6)            LRECL OF THIS RECORD\n         S     R5,44(R6)    -      * (SMF74DDS) OFFSET-DEVICE DATA SEC\n         SR    R5,R4        -      POINT TO BEGINNING OF LAST ENTRY\n         AR    R5,R3        +  =   END ADDR - BXLE LOGIC NOW PRIMED\nLOOP10   EQU   *\n         STM   R3,R5,BXLESAVE      SETUP BXLE W/I A BXLE\n         LH    R11,0(R3)           HG - 2-11-86  BEGIN CHANGE  ***\n         SRL   R11,4               CREATE LCU FROM DEV ADDR ***\n         STH   R11,2(R3)           HG - 2-11-86  END CHANGE ***\n         LA    R5,68(R3)           PREPARE TO\n         LA    R4,4                MULTIPLY SMF74SSC THRU SMF74NRD\n         LA    R3,20(R3)           BY THREE\nLOOP10A  EQU   *\n         SR    R8,R8\n         L     R9,0(R3)\n         M     R8,CPUCOUNT         MULTIPLY THE FIELD BY THE NUMBER\n         ST    R9,0(R3)            OF CPUS CREATING SMF DATA\n         BXLE  R3,R4,LOOP10A       ANY MORE DEVICES?\n         TM    4(R6),X'0C'         (SMF74FLG) IS THIS XA OR ESA?\n         BO    LOOP10B             IT'S ESA (BITS 4 N 5 ON IF ESA)\n         AP    XAVOLS,=X'1C'       COUNT XA ENTRY MODIFIED\n         B     LOOP10C\nLOOP10B  EQU   *\n         AP    ESAVOLS,=X'1C'      COUNT ESA ENTRY MODIFIED\nLOOP10C  EQU   *\n         LM    R3,R5,BXLESAVE      RESET MAJOR BXLE\n         BXLE  R3,R4,LOOP10        ANY MORE DEVICE ENTRIES?\n         B     WRITE30             NOPE\n         EJECT\n*                                  SP ROUTINE\nLOOP20   EQU   *\n         LA    R3,64(R6)           POINT TO DEVICE DATA SECTION\n         LH    R5,0(R6)            * LRECL OF THIS RECORD\n         SH    R5,=H'52'           * SUBTRACT HEADER LENGTH\n         SH    R5,52(R6)           * SUBTRACT DCDS LENGTH (SMF74SDC)\n         LH    R4,56(R6)           (SMF74SDD) DDS SIZE - BXLE INCRI\n         SR    R5,R4               POINT TO BEGINNING OF LAST ENTRY\n         AR    R5,R3               END ADDR - BXLE LOGIC NOW PRIMED\nLOOP20A  EQU   *\n         STM   R3,R5,BXLESAVE      SETUP BXLE W/I A BXLE\n         LA    R5,0(R4,R3)         POINT TO LAST FIELD OF SEGMENT\n         SH    R5,=H'4'            POINT TO BEGINING OF LAST FIELD\n         LA    R4,4                MULTIPLY SMF74CNT -> (SMF74RDR?)\n         LA    R3,16(R3)           BY THREE\nLOOP20B  EQU   *\n         SR    R8,R8\n         L     R9,0(R3)\n         M     R8,CPUCOUNT         MULTIPLY THE FIELD BY THE NUMBER\n         ST    R9,0(R3)            OF CPUS CREATING SMF DATA\n         BXLE  R3,R4,LOOP20B       ANY MORE FIELD FOR THE DEVICE?\n         AP    SPVOLS,=X'1C'       NO, COUNT ENTRIES MODIFIED\n         LM    R3,R5,BXLESAVE      RESET MAJOR BXLE\n         BXLE  R3,R4,LOOP20A       ANY MORE DEVICE ENTRIES?\n*                                  NOPE, FALL THRU AND WRITE THE RECORD\nWRITE30  EQU   *\n         MVC   FILEOUT+82(2),FILEIN+82  MOVE INLRECL TO OUT LRECL\n         LH    R7,FILEIN+82        SAVE INLRECL FOR OUTPUT MOVE LOGIC\n         PUT   FILEOUT\n         LR    R9,R1               POINT TO OUT ADDR\n         LH    R8,=H'256'          LONGEST MVC LENGTH\n         BAL   R10,MOVIT35         PUT RECORD IN OUTPUT AREA PROVIDED\n         AP    OUTCOUNT,=X'1C'\n         B     RMFLOOP             GET ANOTHER RMF RECORD\n*\nMOVIT35  EQU   *\n         CR    R7,R8               LRECL PORTION GREATER THAN 256?\n         BH    MOVIT35A            YEP\n         CH    R7,=H'0'            IS IT ALL DONE?\n         BE    0(R10)              YEP - IF IT CAN HAPPEN IT WILL\n         BCT   R7,*+4              NOPE, REDUCE LENGTH FOR EXEC MOVE\n         EX    R7,MOVIT35B         MOVE WHAT EVER IS LEFT\n         BR    R10                 OUTPUT RECORD IS IN BUFFER - BYE\nMOVIT35A EQU   *\n         BCT   R8,*+4              REDUCE LENGTH FOR EXEC MOVE\n         EX    R8,MOVIT35B\n         LA    R8,1(R8)            BRING IT BACK TO 256\n         AR    R6,R8               BUMP INPUT POINTER UP 256 BYTES\n         AR    R9,R8               BUMP OUTPUT POINTER UP 256 BYTES\n         SR    R7,R8               RUDUCE AMT LEFT TO MOVE 256 BYTES\n         B     MOVIT35             MOVE ANOTHER CHUNK\nMOVIT35B EQU   *\n         MVC   0(0,R9),0(R6)       R9=OUTPUT, R6=INPUT, L IN R7 OR R8\n         EJECT\nEOF40    EQU   *\n         MVC   PRINTREC,PRINTREC-1     BLANK PRINTLINE\n         BAL   R10,PRINT50\n         LA    R3,INCOUNT\n         LA    R4,52\n         LA    R5,DONTKNOW\nEOF40A   EQU   *                      DUMP A TABLE OF COUNTS\n         ED    EDITWD1,0(R3)\n         ED    EDITWD2,13(R3)\n         ED    EDITWD3,26(R3)\n         ED    EDITWD4,39(R3)\n         MVC   LABEL1,5(R3)           FIELD EXPLANATION FROM TABLE\n         MVC   LABEL2,18(R3)\n         MVC   LABEL3,31(R3)\n         MVC   LABEL4,44(R3)\n         MVC   PRINTREC,ENDLINE\n         BAL   R10,PRINT50\n         BAL   R10,PRINT50\n         BAL   R10,REDOED60\n         BXLE  R3,R4,EOF40A           IS THE COUNT TABLE PROCESSED?\n         BAL   R10,PRINT50            YEP, PRINT RMF74 COUNTS\n         MVC   PRINTREC+23(32),=C'RMF TYPE 74 VOLUME DATA MODIFIED'\n         BAL   R10,PRINT50\n         BAL   R10,PRINT50\n         BAL   R10,REDOED60\n         MVC   LABEL1,=C' ESA    '\n         MVC   LABEL2,=C' XA     '\n         MVC   LABEL3,=C' SP     '\n         MVC   LABEL4,=C' TOTAL  '\n         ED    EDITWD1,ESAVOLS\n         ED    EDITWD2,XAVOLS\n         ED    EDITWD3,SPVOLS\n         AP    ESAVOLS,XAVOLS\n         AP    ESAVOLS,SPVOLS\n         ED    EDITWD4,ESAVOLS\n         MVC   PRINTREC,ENDLINE\n         BAL   R10,PRINT50\n         CLOSE (FILEIN,,FILEOUT,,PRINTOUT)\n         L     R13,REGSAVE+4\n         RETURN (14,12),RC=0\n*\nPRINT50  EQU   *\n         PUT   PRINTOUT,PRINTREC\n         MVC   PRINTREC,PRINTREC-1     BLANK PRINTLINE\n         BR    R10\n*\nREDOED60 EQU   *\n         MVC   EDITWD1,EDITWORD\n         MVC   EDITWD2,EDITWORD\n         MVC   EDITWD3,EDITWORD\n         MVC   EDITWD4,EDITWORD\n         BR    R10\n         EJECT\nREGSAVE  DS    9D\nPACKNUM  DS    D\nCPUCOUNT DC    F'0'\nBXLESAVE DS    3F\nINCOUNT  DC    PL4'0',X'00',CL8' INPUT  '\nOUTCOUNT DC    PL4'0',X'00',CL8' OUTPUT '\nRMF74    DC    PL4'0',X'00',CL8' RMF74  '\nNONRMF74 DC    PL4'0',X'00',CL8' OTHER  '\nRMF70    DC    PL4'0',X'46',CL8' RMF70  '\nRMF71    DC    PL4'0',X'47',CL8' RMF71  '\nRMF72    DC    PL4'0',X'48',CL8' RMF72  '\nRMF73    DC    PL4'0',X'49',CL8' RMF73  '\nRMF75    DC    PL4'0',X'4B',CL8' RMF75  '\nRMF76    DC    PL4'0',X'4C',CL8' RMF76  '\nRMF77    DC    PL4'0',X'4D',CL8' RMF77  '\nRMF78    DC    PL4'0',X'4E',CL8' RMF78  '\nRMF79    DC    PL4'0',X'4F',CL8' RMF79  '\nRMF244   DC    PL4'0',X'F4',CL8' RMF244 '\nRMF245   DC    PL4'0',X'F5',CL8' RMF245 '\nDONTKNOW DC    PL4'0',X'00',CL8' UNKNOWN'\nSPVOLS   DC    PL4'0'\nXAVOLS   DC    PL4'0'\nESAVOLS  DC    PL4'0'\n*\nFILEIN   DCB   DDNAME=FILEIN,MACRF=(GL),EODAD=EOF40,DSORG=PS,BFTEK=A\nFILEOUT  DCB   DSORG=PS,LRECL=32756,DDNAME=FILEOUT,MACRF=(PL),BFTEK=A\nPRINTOUT DCB   DSORG=PS,LRECL=80,DDNAME=PRINTOUT,MACRF=(PM)\n         DC    CL1' '\nPRINTREC DS    CL80    OUTPUT RECORD AREA\nENDLINE  DC    CL2'  '                     TOTALS PRINT RECORD\nEDITWD1  DC    XL10'40206B2020206B202120'\nLABEL1   DC    CL8' INPUT  '\nEDITWD2  DC    XL10'40206B2020206B202120'\nLABEL2   DC    CL8' OUTPUT '\nEDITWD3  DC    XL10'40206B2020206B202120'\nLABEL3   DC    CL8' RMF74  '\nEDITWD4  DC    XL10'40206B2020206B202120'\nLABEL4   DC    CL8' OTHER  '\n         DC    CL6'      '\nEDITWORD DC    XL10'40206B2020206B202120'\n*\n         EJECT\n         DS    0F\nSMFRECRD DSECT\n***********************************************************************\n*                                                                     *\n*             S M F   R E C O R D   T Y P E   7 4                     *\n*                                                                     *\n*                       DEVICE ACTIVITY                               *\n*                                                                     *\n***********************************************************************\n*\n         PRINT ON,GEN\n         ERBSMFR 74\n         EJECT\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SMPEIOF": {"ttr": 34817, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x00\\x7f\\x00\\x88\\x00\\x7f\\x12\\x00\\x00`\\x00`\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf2\\xf7\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-01-07T00:00:00", "modifydate": "1988-01-07T12:00:00", "lines": 96, "newlines": 96, "modlines": 0, "user": "FILE270"}, "text": "SMPEIOF TITLE 'SMPE INTERCEPT TO ROUTE JOB STATUS CHECKS TO IOF'\n*\n*  UPDATED 2/10/88 TO CALL REGULAR ST CMD IF NO OPERANDS(NEW USER PROB)\n*\n*  WRITTEN 4/21/87 BY KERMIT KISER - INSTALLATION CODE WSD (WDPSC)\n*\n*  THIS PROGRAM CAN BE NAMED STATUS AND PLACED IN THE SMPE DIALOG\n*   LOAD LIBRARY TO REROUTE THE STATUS COMMAND CALLS TO A CLIST\n*\n         EJECT\nSMPEIOF  ENTERR LEVEL=V1M1,CLEAR=YES\n         EJECT\n*\n         LR    R11,R1             R11->CPPL\n         USING CPPL,R11\n         L     R9,CPPLECT\n         USING ECT,R9\n         TM    ECTSWS,ECTNOPD     OPERANDS?\n         BNO   USECLIST\n         LOAD  EP=ST\n         LR    R15,R0\n         LR    R1,R11\n         BALR  R14,R15\n         DELETE EP=ST\n         B     RETURN\nUSECLIST EQU   *\n*\n*     BUILD NEW SELECT CMD STRING AND PASS TO ISPF FOR STATUS CLIST\n*\n         L     R1,0(R11)          R1-> CBUF\n         MVI   VA,C' '            A BLANK\n         MVC   VA+1(99),VA        SMEAR\n         MVC   CMDSEL,=C'CMD(%'   GET SET\n         MVI   RP,C')'            A PAREN\n         LH    R2,0(R1)           R2=BUF LENGTH\n         SH    R2,=H'5'           R2=CMD LEN\nMOVCMD   MVC   VA(0),4(R1)        EXED CMD MOVE\n         EX    R2,MOVCMD          MOVE TO NEW BUF\n         CALL  ISPLINK,(=CL8'SELECT',=F'106',CMDSEL),                XXX\n               VL,MF=(E,CL)\n         EJECT\n*\n*     SEE IF A STATUS MESSAGE WAS PASSED BACK FOR PUTLINE OUTPUT\n*\n         CALL  ISPLINK,(=CL8'VCOPY',=C'KSMPSTAT',VL,VP),             XXX\n               VL,MF=(E,CL)\n         LTR   R15,R15\n         BNZ   OOPS               BAD RC\n         EJECT\n*\n*   A STATUS MESSAGE WAS PASSED - WRITE VIA PUTLINE OUTPUT\n*\n         L     R1,VP              R1->OUTPUT MSG\n         L     R2,VL              R2=OUT MSG LEN\n         BCTR  R2,R0              R2-1 FOR EX\nMOVMSG   MVC   PLD(0),0(R1)\n         EX    R2,MOVMSG\n         LA    R2,5(R2)           R2+5 FOR PUTLINE\n         STH   R2,PLBUF\n         USING CPPL,R11\n         L     R2,CPPLUPT\n         L     R3,CPPLECT\n         PUTLINE PARM=PLB,UPT=(R2),ECT=(R3),                          XX\n               ECB=MYECB,OUTPUT=(PLBUF,DATA),MF=(E,IOPL)\n         EJECT\n*\n*        RETURN TO WHOEVER CALLED US:\n*\nRETURN   DS    0H\n         SLR   R15,R15\n         B     RET\nOOPS     DS    0H\n         LA    R15,8\nRET      LEAVER\n         TITLE 'WORKAREAS'\n         LTORG\n*\n*              DYNAMIC WORKAREAS:\n*\nWORKAREA DSECT\nSAVEAREA DS    18F\nVL       DS    F\nVP       DS    F\nCMDSEL   DS    CL5'CMD(%'\nVA       DS    CL100\nRP       DS    C')'\nCL       CALL  ,(0,0,0,0,0,0,0),MF=L\nIOPL     DS    4F\nPLB      PUTLINE MF=L\nMYECB    DS    F\nPLBUF    DS    H,H\nPLD      DS    CL200\nWORKLEN  EQU   *-WORKAREA\n         IKJCPPL\n         IKJECT\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "SPACE": {"ttr": 34820, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x00\\x00\\x00\\x00\\x88\\x00\\x7f\\x00\\x88\\x00\\x7f\\x12\\x00\\x02'\\x02'\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf2\\xf7\\xf0@@@\"", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-01-07T00:00:00", "modifydate": "1988-01-07T12:00:00", "lines": 551, "newlines": 551, "modlines": 0, "user": "FILE270"}, "text": "*          DATA SET 761KKSPACE AT LEVEL 001 AS OF 10/13/80\n         TITLE 'SPACE - DOCUMENTATION'\n         REGISTER\n*.....................................................................*\n*.                                                                   .*\n*.   SPACE                                                           .*\n*.                                                                   .*\n*.....................................................................*\n*.    MODIFIED JAN 20,1984 TO HANDLE 3380 DISKS - *KK2*              .*\n*.    MODIFIED FEB 03,1984 TO HANDLE VOL AND SET CLIST VARIABLES-*KK3**\n*.....................................................................*\n*.                                                                   .*\n*.   1.0  GENERAL DESCRIPTION                                        .*\n*.                                                                   .*\n*.   THIS TSO COMMAND WILL RETURN THE DSORG, ALLOCATION TYPE,        .*\n*.   INITIAL ALLOCATION, SECONDARY ALLOCATION, EXTENTS, UNUSED       .*\n*.   SPACE REMAINING - IN TRACKS, AND THE DATASET NAME.              .*\n*.                                                                   .*\n*.....................................................................*\n*.                                                                   .*\n*.....................................................................*\n*.                                                                   .*\n*.   2.0  COMMAND SYNTAX                                             .*\n*.                                                                   .*\n*.    SPACE 'NAME OF DATASET'   PREFIX ADDED IF DATASET NOT 'QUOTED' .*\n*.          VOL(VOLSER)         IF NOT CATALOGED                     .*\n*.          VAR(VARNAME)        IF DATA TO BE PLACED IN CLIST VARIABLE*\n*.          EXTENTS             IF EACH EXTENT TO BE LISTED          .*\n*.                                                                   .*\n*.....................................................................*\n         TITLE 'SPACE - LIST SPACE COMMAND'\nSPACE    CSECT\n         STM   R14,R12,12(R13)\n         USING SPACE,R15\n         ST    R13,SAVE+4\n         LA    R13,SAVE\n         B     BEGIN\nSAVE     DC    18F'0'\n         DROP  R15\n         USING SAVE,R13\n         TITLE 'SPACE - GETMAIN AND PARSE'\nBEGIN    LR    R4,R1\n         USING CPPL,R4\n         LA    R0,LWORK            GET LENGTH OF WORK AREA\n         AH    R0,=H'4096'         GET EXTRA 4K FOR LOCINDEX WORK\n         ICM   R0,B'1000',=FL1'1'  SUBPOOL 1\n         GETMAIN R,LV=(0)\n         LR    R12,R1               SAVE ADDR OF WORK AREA\n         USING WORKAREA,R12\n         LA    R0,LOCINDXW          POINT TO LOCINDEX WORK AREA\n         ST    R0,PARM+12           SAVE ADDR IN PARM LIST\n         MVI   PARM+12,X'80'        INDICATE END OF PARM LIST\n         MVI   WXTNT+4,X'04'\n         LA    R3,WPPL             GET ADDR OF PPL\n         USING PPL,R3\n         L     R0,CPPLCBUF\n         ST    R0,PPLCBUF          SAVE ADDR OF COMMAND BUFFER\n         L     R0,CPPLUPT\n         ST    R0,PPLUPT           SAVE ADDR OF UPT\n         L     R0,CPPLPSCB\n         L     R10,CPPLUPT         GET ADDR OF UPT\n         LA    R10,16(,R10)             R10-> PREFIX\n         SR    R11,R11\n         IC    R11,7(R10)          GET LENGTH OF USERID\n         BCTR  R11,0\nLECT     L     R0,CPPLECT\n         ST    R0,PPLECT           SAVE ADDR OF ECT\n         LA    R0,CPECB\n         ST    R0,PPLECB           SAVE ADDR OF ECB\n         XC    CPECB,CPECB         CLEAR ECB\n         L     R0,=A(PARSLIST)\n         ST    R0,PPLPCL           SAVE ADDR OF PCL\n         LA    R0,WPDL\n         ST    R0,PPLANS           SAVE ADDR OF PDL AREA\n         XC    PPLUWA,PPLUWA       CLEAR UWA\n         LR    R1,R3               PASS ADDR OF PPL TO PARSE\n         LINK  EP=IKJPARS          LINK TO PARSE SERVICE ROUTINE\n         LTR   R15,R15             PARSE ERROR\n         BNZ   RETC                 YES\n         TM    PPLANS,X'FF'        PARSE ERROR\n         BO    RETC                 YES\n         DROP  R3\n         L     R3,WPDL             GET ADDR OF PDL\n         USING IKJPARMD,R3\n         SPACE\n*              ADDITIONAL PARMS VARIABLE(),VOL(),EXTENTS - *KK3*\n         CLC   EXTENT,=H'0'       EXTENTS REQUESTED?\n         BE    CHKVAR             NOPE.\n         OI    FLAG,X'80'         FLAG EXTENT LIST REQ\nCHKVAR   CLC   VARF,=H'0'         VAR REQ?\n         BE    CHKVOL             NOPE.\n         OI    FLAG,X'40'         FLAG VARIABLE REQ\n         MVC   UUPT,CPPLUPT                                   *KK3*\n         MVC   UECT,CPPLECT                                   *KK3*\n         LH    R4,VARSF+4         R4=VAR NAME LEN\n         ST    R4,VARLEN          SAVE\n         L     R1,VARSF           R1->VAR NAME\n         BCTR  R4,R0              R4-1\nVARM     MVC   VARNAME(0),0(R1)   SAVE VAR NAME\n         EX    R4,VARM            F'SHURE!\nCHKVOL   CLC   VOLUME,=H'0'       VOL REQ?\n         BE    DSNTST             NOPE.\n         OI    FLAG,X'20'         FLAG VOL REQ\n         MVC   VOLS,BLANKS         MOVE BLANKS TO VOLSER WORK AREA\n         LH    R4,VOL+4           R4=VOL LEN\n         BCTR  R4,R0              R4-1\n         L     R1,VOL             R1->VOLSER\nVOLM     MVC   VOLS(0),0(R1)      SAVE VOLSER\n         EX    R4,VOLM            F'SHURE!\n         SPACE\nDSNTST   TM    DSNLIST+6,X'80'      DSNAME SPECIFIED?\n         BO    DSNRTN                YES\n         B     RETC                 NO PARMS - LISTS FOR USERID\n         DROP  R4\n         TITLE 'SPACE - DATASET NAME ROUTINE'\nDSNRTN   LA    R4,DSNLIST           POINT TO DSN LIST\n         TM    FLAG,X'40'         VARIABLE?                   *KK3*\n         BO    DSNAME             YUP.                        *KK3*\n         LA    R0,L'MSG1\n         LA    R1,MSG1\n         SVC   93                  TPUT HEADING\nDSNAME   L     R5,0(R4)             POINT TO DSNAME\n         LH    R6,4(R4)             GET LENGTH OF DSNAME\n         BCTR  R6,0\n         MVI   DSN1,X'40'\n         MVC   DSN1+1(43),DSN1     BLANK DSN WORK AREA\n         LA    R8,DSN1              POINT TO DSN WORK AREA\n         TM    6(R4),X'40'          DSNAME CONTAINED IN QUOTES?\n         BO    MVCDSNAM               YES\n         EX    R11,USIDMVC         MOVE USERID TO WORK AREA\n         LA    R8,1(R11,R8)        BUMP PAST USERID\n         MVI   0(R8),C'.'          MOVE PERIOD TO WORK AREA\n         LA    R8,1(0,R8)          BUMP PAST\nMVCDSNAM EX    R6,DSNMVC           MOVE DSNAME TO WORK AREA\n         TM    FLAG,X'20'         VOL SPECIFIED?              *KK3*\n         BO    BALOBTN            YUP.                        *KK3*\nLOCDSN   OI    FLAG,X'10'\n         LOCATE INDS\n         LTR   R15,R15              DID IT FIND VOL SER\n         BNZ   ERR03                 NO WRITE ERROR MSG\n         NI    FLAG,X'EF'\n         MVC   VOLS(6),BUF1+6      YES - MOVE IN VOL SER\n         SPACE 2\nBALOBTN  BAL   R9,OBTNRTN          LINK TO OBTAIN AND PRINT ROUTINE\n         B     RETC                 YES\n         TITLE 'SPACE - OBTAIN AND PRINT ROUTINES'\n*   READ DSCB1 AND GET SPACE\nOBTNRTN  STM   R2,R11,OBTNSAVE     SAVE CALLER'S REGISTERS\n         MVC   DSNSAVE(44),DSN1\n         MVI   DSN1,X'04'          MOVE 'DSN' FOR F4 DSCB...\n         MVC   DSN1+1(43),DSN1     ...INTO DSN1\n         OBTAIN SERCHCAM\n         CLI   BUF1,X'F4'          DID IT READ OK?\n         BNE   ERRF4               NO\n         MVC   VOLTKCYL(2),BUF1+20 GET NUM OF TRKS/CYL\n         MVC   DSN1(44),DSNSAVE\n         MVI   MSG2,X'40'\n         MVC   MSG2+1(75),MSG2     BLANK MESSAGE AREA\n         OBTAIN SERCHCAM\n         LTR   R15,R15             DID OBTAIN WORK\n         BNZ   ERR03               NO - WRITE ERROR MSG\n         SPACE 2\n         CLI   BUF1,C'1'            IS IT F1 DSCB?\n         BNE   ERR01                NOT F1\n         LA    R9,XTNTS            POINT TO EXTENTS SAVE AREA\n         LH    R6,BUF1+54          GET LAST RELATIVE TRK USED\n         CLI   BUF1+56,X'00'       IS TRK UNUSED?\n         BE    *+8                  YES\n         LA    R6,1(R6)             NO, ANOTHER TRACK\n         STH   R6,LASTTRK          SAVE LAST REL. TRK\n         MVC   DSORG,BUF1+38       SAVE DSORG\nAROUND   EQU   *\n* TEST FOR TYPE OF DSORG AND MOVE TO PRINT LINE\n         CLI   BUF1+38,X'80'        IS IT IS\n         BNE   NIS                  NO\n         MVC   MSG2+2(2),=C'IS'     YES - MOVE IN IS\n         B     GDSO                 BRANCH TO GOT DSORG\nNIS      CLI   BUF1+38,X'40'        IS IT PS\n         BNE   NPS                   NO\n         MVC   MSG2+2(2),=C'PS'      YES-MOVE IN PS\n         B     GDSO                 BRANCH TO GOT DSORG\nNPS      CLI   BUF1+38,X'20'        IS IT DA\n         BNE   NDA                   NO\n         MVC   MSG2+2(2),=C'DA'      YES - MOVE IN DA\n         B     GDSO                 BRANCH TO GOT DSORG\nNDA      CLI   BUF1+38,X'02'        IS IT PO\n         BNE   NPO                   NO\n         MVC   MSG2+2(2),=C'PO'      YES - MOVE IN PO\n         B     GDSO                 BRANCH TO DSORG\nNPO      CLI   BUF1+38,X'01'        IS IT UNMOVEABLE\n         MVC   MSG2+2(2),=C' U'      YES\nGDSO     EQU   *\n         TM    BUF1+50,X'C0'\n         BM    GDSO2\n         BZ    GDSO1\n         MVC   MSG2+7(4),=C'CYLS'\n         MVI   SWITCH,C'X'\n         B     GDSO4\nGDSO1    EQU   *\n         MVC   MSG2+7(4),=C'ABS '\n         MVI   SWITCH,C' '\n         B     GDSO4\nGDSO2    EQU   *\n         TM    BUF1+50,X'80'\n         BZ    GDSO3\n         MVC   MSG2+7(4),=C'TRKS'\n         MVI   SWITCH,C' '\n         B     GDSO4\nGDSO3    EQU   *\n         MVC   MSG2+7(4),=C'BLKS'\n         MVI   SWITCH,C' '\nGDSO4    EQU *\n         ST    R8,REGSAVE\n         LH    R8,BUF1+52\n         CVD   R8,WKD\n         MVC   MSG2+20(4),=X'40202120'\n         ED    MSG2+20(4),WKD+6\n         L     R8,REGSAVE\n         SR    R2,R2                ZERO REG 2\n         IC    R2,BUF1+15           PICK UP NUMBER OF EXTENTS\n         LA    R3,1                 SET EXTENT COUNTER\n         SR    R4,R4                CLEAR R4 TO TRK ACCUMULATION\n         LTR   R2,R2               NO XTNTS? - GDG PATTERN. DSCB\n         BZ    VVALID               YES, BYPASS ACCUMULATE\n         LA    R5,BUF1+61           POINT TO FIRST EXTENT\nVXTLOOP  MVC   0(10,R9),0(R5)      MOVE EXTENT TO SAVE AREA\n         LA    R9,10(R9)           BUMP TO NEXT SAVE AREA\n         MVC   HWK1(2),6(R5)        MOVE HI-CYL TO HWD\n         LH    R0,HWK1              LOAD\n         MVC   HWK1(2),8(R5)        MOVE HI-TRK TO HWD\n         LH    R1,HWK1              LOAD\n         MVC   HWK1(2),2(R5)        MOVE LOW-CYL TO HWD\n         SH    R0,HWK1              SUBTRACT\n         MVC   HWK1(2),4(R5)        MOVE LOW-TRK TO HWD\n         SH    R1,HWK1              SUBTRACT\n         MH    R0,VOLTKCYL          CONVERT CYL TO TRK\n         AR    R1,R0                GET TOTAL MINUS1\n         LA    R4,1(R1,R4)          GET TOTAL AND ACCUMULATE\n         CLI   SWITCH2,C'X'\n         BE    MORE\n         MVI   SWITCH2,C'X'\n         CVD   R4,WKD\n         MVC   TOTAL,WKD\nMORE     EQU   *\n         CR    R3,R2                DONE LAST EXTENT?\n         BE    VVALID               GO TO VVALID IF SO\n         LA    R3,1(R3)             BUMP TO EXTENT COUNTER\n         CH    R3,=H'4'             FOURTH EXTENT?\n         BE    VXT4                   BRANCH IF SO\n         CH    R3,=H'8'             EIGHTTH EXTENT?\n         BE   VXT8\n         LA    R5,10(R5)            ELSE BUMP EXTENT POINTER\n         B     VXTLOOP              AND GO TO NEXT EXTENT\nVXT4     MVC   VTOCCHHR(5),BUF1+91  POINT NEXT DSCH(F2 OR F3)\nVXT4OBT  OBTAIN SEEKCAM\n         CLI   BUF1+44,C'3'         IF IT F3 DSCB\n         BE    VXT4F3               BRANCH IF SO\n         MVC   VTOCCHHR(5),BUF1+135  ELSE ITS F2-POINT TO F3\n         B     VXT4OBT\nVXT4F3   LA    R5,BUF1+4            POINT TO FIRST EXTENT IN F3\n         B     VXTLOOP              CONTINUE LOOP FOR SIZE\nVXT8     LA    R5,BUF1+45           SKIP OVER F3 ID IN F3 DSCB\n         B     VXTLOOP              CONTINUE LOOP FOR SIZE\nVVALID   EQU   *\n* CONVERT SPACE ALLOC AND EDIT IN PRINT LINE\n         CVD   R4,WKD\n         MVC   ALLOCHLD,=X'402020202120'\n         ED    ALLOCHLD(6),WKD+5    BRANCH TO EXTENT CONVERSION\nCVDU     LH    R6,LASTTRK            GET LAST RELATIVE TRACK\n         LR    R7,R4\n         SR    R7,R6                 R7 CONTAINS UNUSED SPACE\n         CVD   R7,WKD               CONVERT DEC R7\n         MVC   MSG2+39(6),MASKED      MOVE IN MASKED FIELD\n         ED    MSG2+39(6),WKD+5       EDIT # TRKD UNUSED\nCVDX     CVD   R2,WKD                   PICK UP # EXTENTS\n         MVC   MSG2+26(4),MASKED      MOVE IN MASKED FIELD\n         ED    MSG2+26(4),WKD+6      EDIT # EXTENTS USED\n         MVC   MSG2+47(44),DSN1     MOVE DSN TO PRINT LINE\n         LH    R1,VOLTKCYL          *KK2*\n         CVD   R1,PDW               *KK2*\n         MVC   TYPE,PDW+6           *KK2*\nTSTSWTCH EQU   *\n         CLI   SWITCH,C' '\n         BE    NOCHG\n         DP    TOTAL,TYPE\n         MVC   MSG2+14(4),=X'F0202020'\n         ED    MSG2+14(4),TOTAL+6\n         MVI   MSG2+15,C'-'\n         MVC   MSG2+11(4),=X'40212020'\n         ED    MSG2+11(4),TOTAL+4\n         PACK  TOTAL,ALLOCHLD+1(5)\n         DP    TOTAL,TYPE\n         MVC   MSG2+33(4),=X'F0202020'\n         ED    MSG2+33(4),TOTAL+6\n         MVI   MSG2+34,C'-'\n         MVC   MSG2+30(4),=X'40212020'\n         ED    MSG2+30(4),TOTAL+4\n         MVI   SWITCH,C' '\n         B     PRINTIT\nNOCHG    EQU   *\n         DP    TOTAL,TYPE\n         MVC   MSG2+14(4),=X'F0202020'\n         ED    MSG2+14(4),TOTAL+6\n         MVI   MSG2+15,C'-'\n         MVC   MSG2+11(4),=X'40212020'\n         ED    MSG2+11(4),TOTAL+4\n         PACK  TOTAL,ALLOCHLD+1(5)\n         DP    TOTAL,TYPE\n         MVC   MSG2+33(4),=X'F0202020'\n         ED    MSG2+33(4),TOTAL+6\n         MVI   MSG2+34,C'-'\n         MVC   MSG2+30(4),=X'40212020'\n         ED    MSG2+30(4),TOTAL+4\nPRINTIT  EQU   *\n         CLC   MSG2+2(2),=C'IS'\n         BNE   PRINTER\n         MVC   MSG2+39(6),=C'      '\nPRINTER  EQU   *\n         MVI   SWITCH2,C' '\n         BAL   R14,SETVAR         SET CLIST VAR IF REQ        *KK3*\n         TM    FLAG,X'40'         WAS IT SET?                 *KK3*\n         BO    TX                 YUP.                        *KK3*\n         TPUT  MSG2,93             WRITE OUT LINE\nTX       TM    FLAG,X'80'          AUTHORIZED USER?\n         BNO   OBTNRET              NO\n         LA    R9,XTNTS            POINT TO EXTENT SAVE AREA\n         MVC   MSG2(6),VOLS        MOVE VOLSER TO MESSAGE AREA\nOUTLOOP  LA    R3,3                SET LOOP CONTROL\n         LA    R4,MSG2+8           POINT TO MESSAGE AREA\n         MVI   MSG2+6,X'40'\n         MVC   MSG2+7(69),MSG2+6   BLANK MESSAGE AREA\nINLOOP   MVC   WXTNT+3(1),1(R9)    MOVE EXTENT # TO WORK AREA\n         UNPK  0(2,R4),WXTNT+3(2)  UNPACK EXTENT #\n         TR    0(1,R4),TRTBL       TRANSLATE EXTENT #\n         MVC   WXTNT(4),2(R9)      MOVE BEGIN XTNT TO WORK AREA\n         UNPK  2(9,R4),WXTNT(5)    UNPACK XTNT\n         TR    2(8,R4),TRTBL       TRANSLATE EXTENT\n         MVC   WXTNT(4),6(R9)      MOVE END XTNT TO WORK AREA\n         UNPK  11(9,R4),WXTNT(5)   UNPACK XTNT\n         TR    11(8,R4),TRTBL      TRANSLATE EXTENT\n         LA    R9,10(R9)           BUMP TO NEXT EXTENT\n         LA    R4,22(R4)           BUMP MESSAGE AREA POINTER\n         BCTR  R2,0                DECREASE # EXTENTS\n         LTR   R2,R2               ANY MORE EXTENTS\n         BZ    *+8                  NO\n         BCT   R3,INLOOP           CONVERT NEXT EXTENT\n         LA    R0,L'MSG2\n         LA    R1,MSG2\n         SVC   93                  TPUT EXTENTS\n         MVC   MSG2(6),BLANKS      BLANK VOLSER\n         LTR   R2,R2               ANY MORE EXTENTS?\n         BNZ   OUTLOOP              YES\nOBTNRET  LM    R2,R11,OBTNSAVE     RELOAD CALLER'S REGISTERS\n         BR    R9                  RETURN TO CALLER\n         SPACE\n*              CLIST VARIABLE SETTING ROUTINE:                *KK3*\nSETVAR   TM    FLAG,X'40'         SET REQ?                    *KK3*\n         BNOR  R14                NOPE.                       *KK3*\n         ST    R14,L2LS                                       *KK3*\n*              BUILD UPDATE CTL LIST:                         *KK3*\n         LA    R1,VARNAME                                     *KK3*\n         ST    R1,VARPTR                                      *KK3*\n         MVC   VALLEN,=F'93'                                  *KK3*\n         LA    R1,MSG2            R1->OUTPUT DATA LINE        *KK3*\n         ST    R1,VALPTR                                      *KK3*\n*              BUILD SETVAR PARM LIST:                        *KK3*\n         LA    R1,UPLIST          R1->SETVAR PARM BLOCK       *KK3*\n         ST    R1,UPPTR           PASS TO SETVAR RTN          *KK3*\n         LA    R1,UECBWD                                      *KK3*\n         ST    R1,UECB                                        *KK3*\n*              CALL  SETVAR SUBROUTINE:                       *KK3*\n         LA    R1,SETPARM                                     *KK3*\n         LINK  EP=SETVAR          SET THE VARIABLE            *KK3*\n         SPACE\n         L     R14,L2LS                                       *KK3*\n         BR    R14                                            *KK3*\n         TITLE 'SPACE - EOJ AND ERROR ROUTINES'\nRETC     EQU   *\n         L     13,SAVE+4           LOAD R13 PREVIOUS SPACE AREA\n         LM    2,12,28(13)         RELOAD REGISTERS\n         L     14,12(13)           LOAD RETURN ADDRESS\n         MVI   12(13),X'FF'        INDICATE CONTROL RETURN CALLING PROG\n         BCR   15,14               RETURN TO CALLING PROGRAM\n         SPACE 3\nERR01    EQU   *\n* NO VALID COMMAND\n         TPUT  ERMSG1,18\n         B     RETC                BRANCH TO RETURN CODE\n* DATASET NAME NOT FOUND\nERR03    MVC   MSG2(L'ERMSG9),ERMSG9\n         MVC   MSG2+L'ERMSG9(44),DSN1\n         LA    R0,L'ERMSG9+44\n         LA    R1,MSG2\n         SVC   93\n         B     RETC\n         SPACE 3\nRDERR    MVC   MSG2(L'ERMSG8),ERMSG8\n         MVC   MSG2+L'ERMSG8(44),DSN1\n         LA    R0,L'ERMSG8+44\n         LA    R1,MSG2\n         SVC   93\n         B     RETC                CONTINUE THRU LOOP\n         SPACE 3\nNOUSER   MVC   MSG2(L'ERMSG3),ERMSG3\n         MVC   MSG2+L'ERMSG3(44),USERID\n         LA    R0,L'ERMSG3+44\n         LA    R1,MSG2\n         SVC   93\n         B     RETC                RETURN TO SYSTEM\n         SPACE 3\nNOTDISK  MVC   MSG2(L'ERMSG6),ERMSG6\n         MVC   MSG2+L'ERMSG6(44),DSN1\n         LA    R0,L'ERMSG6+44\n         LA    R1,MSG2\n         SVC   93\n         B     RETC                PICK UP NEXT DATASET\n         SPACE 3\nMULTIVOL MVC   MSG2(L'ERMSG7),ERMSG7\n         MVC   MSG2+L'ERMSG7(44),DSN1\n         LA    R0,L'ERMSG7+44\n         LA    R1,MSG2\n         SVC   93\n         B     RETC                CONTINUE WITH NEXT DSN\n         SPACE 3\nERRF     EQU   *\n         TPUT  ERMSG10,20\n         B     RETC\nERRF4    EQU   *                   ERROR READING F4\n         TPUT  ERMSG11,21\n         B     RETC\nUSIDMVC  MVC   0(0,R8),0(R10)\nDSNMVC   MVC   0(0,R8),0(R5)\nMVCVOLS  MVC   0(0,R1),0(R5)\n         TITLE 'SPACE - DATA AREAS'\n         LTORG\nENDLIST  DS    0F\n         DC    XL4'FF000000'\n* SETUP CONSTANTS\nVOLDSCTK DC    H'0'                NUM DSCH ON A TRK\nVOLF4CHR DC    XL5'00'             CCHHR OF DSCB\nVOLNO    DC    H'0'                NUM VOLUMES PROCESSED\nPEXCTR   DC    H'0'                CTR FOR TATAL NUM FREE SPACE\nLASTTRK  DC    H'0'\nDSN1     DC    CL44' '              DATASET NAME\nDSNSAVE  DC    CL44' '\nVOLS     DC    CL6' '                 VOLUME SER\nUSERID   DC    CL44' '              USERID\nFLAG     DC    X'00'\nDSORG    DC    X'00'\nBLANKS   DC    CL6' '\nBUF1     DS    0D\n         DS    265C\nTRTBL    EQU   *-240\n         DC    C'0123456789ABCDEF'\nMASKED   DC    XL6'402020202020'   MASK FIELD FOR EDIT\n         SPACE 3\n* MESSAGE TO BE PRINTED\nMSG1     DC  C'DSORG  TYPE   INIT   SEC  EXTS  TOTAL  UNUSED  DSNAME'\nMSG2     DC    CL93' '\nMSG4     DC    C'VOLUME DSCBS EXTENTS TRACKS  VTOC'\n         SPACE 3\n* ERROR MESSAGES\nERMSG1   DC    C'NO VALID COMMAND'\nERMSG3   DC    C'INVALID LEVEL - '\nERMSG6   DC    C'DSN NOT ON DISK - '\nERMSG7   DC    C'DSN ON MULTIVOLUMES - '\nERMSG8   DC    C'ERROR READING CATALOG DSN - '\nERMSG9   DC    C'DSN NOT FOUND - '\nERMSG10  DC    C'UNSUPPORTED KEYWORD'\nERMSG11  DC    C'ERROR READING F4 DSCB'\n         EJECT\n* CAMLST FOR DSCB3\nSEEKCAM  CAMLST SEEK,VTOCCHHR,VOLS,BUF1\n         SPACE 2\n* CAMLST LOCATE DSN OV VOL SER\nINDS     CAMLST NAME,DSN1,,BUF1\n         SPACE 2\n* CAMLST FOR DSCB 1\nSERCHCAM CAMLST SEARCH,DSN1,VOLS,BUF1\n         EJECT\n* CONSTANTS AND WORK AREAS\nHWK1     DC    H'0'                HALF WORD WORK AREA\nVOLTKCYL DC    H'19'               # TRKS/CYL\nVTOCCHHR DC    XL5'0'              TRACK ADDR WORK AREA\nWKD      DC    D'0'                DOUBLE WORK WORK AREA\n         SPACE 3\n* PARM SETUP FOR GETDSN\nPARM     DC    A(USERID)           USERID ADDRESS\n         DC    A(DSN1)             DSN ADDRESS\n         DC    A(VOLS)             VOL SER ADDRESS\n         DC    A(0)                ADDRESS FOR GETMAIN\n         SPACE 3\n* EQUATE REGISTERS\n*        EQUATE\nRCC      EQU   R8\nRHH      EQU   R7\nRR       EQU   R6\n         TITLE 'SPACE - PARSE PARAMETER LIST'\nPARSLIST IKJPARM\nDSNLIST  IKJPOSIT DSNAME,PROMPT='DATA SET NAME'\nVARF     IKJKEYWD\n         IKJNAME 'VARIABLE',SUBFLD=VAR\nVOLUME   IKJKEYWD\n         IKJNAME 'VOLUME',SUBFLD=VLM\nEXTENT   IKJKEYWD\n         IKJNAME 'EXTENTS'\nVAR      IKJSUBF\nVARSF    IKJIDENT 'VARIABLE NAME',OTHER=ANY,MAXLNTH=8\nVLM      IKJSUBF\nVOL      IKJIDENT 'VOLUME',FIRST=ALPHANUM,OTHER=ALPHANUM,MAXLNTH=6\n         IKJENDP\n         IKJPPL\n         IKJCPPL\n         TITLE 'SPACE - WORK AREA'\nWORKAREA DSECT\nWPPL     DS    7A\nCPECB    DS    F\nWPDL     DS    F\nOBTNSAVE DS    10F\nREGSAVE  DS    F\nXTNTS    DS    16XL10\nWXTNT    DS    CL5\nALLOCHLD DS    CL6\nTOTAL    DS    CL8\nSEC      DS    CL4\nEXT      DS    CL4\nTYPE     DS    CL2\nSWITCH   DS    CL1\nSWITCH2  DS    CL1\n         SPACE\nPDW      DS    D\nL2LS     DS    F                                              *KK3*\nVARNAME  DS    CL8                                            *KK3*\nUECBWD   DS    F                                              *KK3*\n         SPACE\nSETPARM  DS    0F                 SETVAR PARM LIST:           *KK3*\nUUPT     DS    F                                              *KK3*\nUECT     DS    F                                              *KK3*\nUECB     DS    F                                              *KK3*\nUPPTR    DS    F                                              *KK3*\n         SPACE\nUPLIST   DS    0F                 UPDATE CTL BLOCK:           *KK3*\nVARPTR   DS    A                                              *KK3*\nVARLEN   DS    F                                              *KK3*\nVALPTR   DS    A                                              *KK3*\nVALLEN   DS    F                                              *KK3*\n         SPACE\n         DS    0D\nLOCINDXW EQU   *\nLWORK    EQU   *-WORKAREA\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "SPACE$": {"ttr": 35075, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x00\\x7f\\x00\\x88\\x00\\x7f\\x12\\x00\\x00\\x1b\\x00\\x1b\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf2\\xf7\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-01-07T00:00:00", "modifydate": "1988-01-07T12:00:00", "lines": 27, "newlines": 27, "modlines": 0, "user": "FILE270"}, "text": "1 10.080\n-                                                          SPACE command\n0Function -\n0The SPACE command is used to obtain information about the amount of\n direct access space occupied by a dataset. The type of allocation, the\n initial allocation, the secondary allocation, the number of extents,\n the total space occupied by the dataset and the number of unused tracks\n are listed. Initial and total allocations are listed in the form of\n CCC-TT where CCC indicates cylinders and TT indicates tracks. Unused\n space is listed in tracks and secondary allocations are listed in\n allocation units, as listed in type of allocation.\n\n Syntax -\n _______________________________________________________________________\n0     Command              Operands\n _______________________________________________________________________\n0     SPACE              dsname   VOL(volser) VAR(varname) EXTENTS\n _______________________________________________________________________\n-Operands -\n0 Required - dataset name.\n-  dsname - specifies the data set name of data set to be examined.\n-  VOL(volser) - specify a volume if dataset not cataloged.\n-  VAR(varname) - if command used from a clist, put output data in\n            this clist variable.\n-  EXTENTS - list extent boundarys in start and end CCHH values.\n-Example -\n0  SPACE   MY.DATASET\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "SPFEXEC": {"ttr": 35077, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x00\\x7f\\x00\\x88\\x00\\x7f\\x12\\x00\\x02\\xc9\\x02\\xc9\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf2\\xf7\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-01-07T00:00:00", "modifydate": "1988-01-07T12:00:00", "lines": 713, "newlines": 713, "modlines": 0, "user": "FILE270"}, "text": "PANLEXIT TITLE 'ISPF DISPLAY PANEL EXIT ROUTINE  '\n**********************************************************************\n*  THIS PROGRAM CREATES AN EXIT FROM PANELS DISPLAYED BY THE         *\n*   ISPF DISPLAY SERVICE.                                            *\n**********************************************************************\n*\n*  NOTE: THIS PROGRAM IS ACTUALLY TWO PROGRAMS SEPARATED WITH AN 'END'\n*        CARD. USE ASM H WITH 'BATCH' PARM OR SEPARATE THE PROGRAMS.\n*\n*  MODIFIED 11/02/87 TO LOAD ISRPCP RATHER THAN CALL.\n*   (V1M8)  AVOID SHIPPING ISRPCP TO CBT TAPE.\n*\n*  MODIFIED 6/25/87 TO FIX A PROBLEM WITH FOCUS CALLS VIA FOCUS\n*   (V1M7)  VARIABLE. COMMAND BUFF END WAS NOT DETECTED PROPERLY.\n*\n*  MODIFIED 5/11/87 TO CALL ISRPCP OR NEWISPF IF AVAILABLE. THIS\n*   (V1M6)  WILL RESTORE THE OLD RB STRUCTURE BY ELIMINATING THE\n*           LINK TO ISPF AND MAKE ACF2 EXEC ACCESS MUCH HAPPIER!\n*\n*  MODIFIED 2/05/87 TO INVOKE ISPF IF NOT ACTIVE. THIS WILL ALLOW\n*   (V1M5)  CURRENT FOCUS, SAS, MEGACALC, ETC APPLICATIONS TO CALL\n*           ISPF FACILITIES AND TSO CLISTS WITHOUT REGARD FOR\n*           WHETHER ISPF IS ALREADY ACTIVE. ALSO ACCEPT IMPLICIT\n*           REQUESTS FOR ISPEXEC SELECT/DISPLAY. ELIMINATE LINKS TO\n*           ISPEXEC SINCE HE IS LINKED IN ALREADY.            - V1M5\n*           THIS FEATURE REQUIRES AN ALIAS OF PXP FOR ISR@PRIM AND\n*           ALLOWS SPFEXEC TO SUBSTITUTE FOR THE 'SPF' CMD (NOT ISPF!)\n*\n*  MODIFIED 7/16/86 TO SET REQUESTED VARIABLE FROM SHARED POOL AND\n*           TO ALLOW ALTERNATE EXIT VARIABLE NAMES (UP TO TEN).\n*           USE &PANLXVN= '(VAR1,VAR2...)' BEFORE CALLING PANLEXIT\n*           TO DEFINE THE ALTERNATE NAMES WHICH THE\n*           EXIT IS TO PROCESS. CONTROL SAVE WILL BE\n*           DONE FOR ALTERNATE EXITS                          - V1M4\n*\n*  MODIFIED 6/12/86 TO SAVE ENVIVRONMENT IF ALTERNATE VARIABLE IS\n*           REQUESTED. NOT SURE WHEN NEEDED! &PANLXSAV WILL\n*           CAUSE SAVE/RESTORE OF DISPLAY ENVIRONMENT         - V1M3\n*\n*  MODIFIED 6/09/86 TO SAVE ENVIVRONMENT IF DISPLAY SERVICE REQUESTED\n*           WARNING: IF CALLING A DIALOG WHICH WILL DISPLAY PANELS,\n*           YOU MUST USE ISPEXEC CONTROL DISPLAY SAVE/RESTORE!- V1M2\n*\n*  MODIFIED 6/05/86 TO CALL EXIT PGMS WITH SAME FUNCTION POOL - V1M1\n*\n*  WRITTEN 5/29/86 BY KERMIT KISER - INST CODE WSD (WDPSC) -    V1M0\n*\n**********************************************************************\n         EJECT\n**********************************************************************\n*\n* PANLEXIT IS CALLED FROM A CLIST LIKE THIS:\n*\n*        ISPEXEC SELECT PGM(PANLEXIT) PARM(REALPGM,REALPARM)\n*\n*    YOU CAN ALSO DO ISPEXEC CALLS WITH THE EXIT FACILITY:\n*\n*        ISPEXEC SELECT PGM(PANLEXIT) PARM(ISPEXEC DISPLAY ....)\n*\n*    YOU CAN ALSO INVOKE TSO COMMANDS WITH THE EXIT FACILITY:\n*\n*        PANLEXIT REALCMD OPERANDS\n*\n* IT IS CALLED FROM A SELECT MENU LIKE THIS:\n*        SELECT PGM(PANLEXIT) PARM(REALPGM,REALPARM)\n*\n**********************************************************************\n*\n* PROGRAM 'REALPGM' IS LINKED TO WITH A PARM VALUE OF 'REALPARM'\n*\n**********************************************************************\n*\n**********************************************************************\n*\n* ANY PANEL DISPLAYED BY THE DIALOG CAN INCLUDE THE FOLLOWING\n*\n*   &PANLEXIT = 'ISPEXEC SELECT CMD(.....)'\n*   &PANLEXIT = 'SELECT CMD(.....)'\n*   &PANLEXIT = 'DISPLAY PANEL(..)'\n*\n*        OR SIMILIAR STRING REQUESTING AN ISPEXEC SERVICE...\n*\n*  THE VARIABLE EXIT DVAREXIT DEFINED HERE FOR VARIABLE PANLEXIT\n*  WILL PASS THE STRING TO ISPEXEC TO EXECUTE AS A DIALOG REQUEST.\n*\n* THIS CREATES AN EXIT FROM THE PANEL TO A DIALOG IF YOU NEED IT!\n* I AM USING IT TO LOG THE DESCRIPTOR STRING IN SMPE MAINT DIALOGS\n* AND TO REROUTE 3.7 VTOC DISPLAY REQUESTS TO FILEAID 3.7 ...\n**********************************************************************\n         EJECT\n**********************************************************************\n*\n* AN ALTERNATE WAY TO CALL AN EXIT IS TO SPECIFY A PROGRAM,PARM COMBO:\n*\n*   &PANLEXIT = 'REALEXIT,EXITPARM........'\n*\n* THE VARIABLE EXIT DVAREXIT WILL LINK TO THE PROGRAM PASSING THE\n* PARM. THIS ALLOWS THE PROGRAM TO USE THE SAME FUNCTION POOL AS THE\n* DIALOG WHICH DISPLAYED THE PANEL...\n*\n*\n*\n*\n***** WARNING ********************************************************\n***** WARNING ********************************************************\n* ISPF USES NON STANDARD LINKAGE TO PROGRAMS NAMED                   *\n*            ISR..... OR ISP.....                                    *\n* TO INTERCEPT PANELS FOR THESE PROGRAMS, THIS PROGRAM MUST BE       *\n*   CALLED WITH AN ISP OR ISR NAME. I GAVE IT AN ALIAS OF ISPDPX.    *\n*                                                                    *\n* ALSO ISPF PADS SHORT PARMS WITH BLANKS, BUT TRUNCATES LONG PARMS   *\n* AT THE FIRST TRAILING                                              *\n* BLANK, WHICH MAY CAUSE PROBLEMS. HERE IS HOW I HAD TO              *\n* CALL ISRUDA (OPTION 3.1): SELECT PGM(ISPDPX) PARM(ISRUDA,ISRUDA1 $)*\n*                                                                    *\n**********************************************************************\n**********************************************************************\n*\n*\n*\n*\n         EJECT\n         MACRO\n         PANLWORK\nWORKAREA DSECT\nSAVEAREA DS    18F\nXADDRESS DS    F\nXSAVE    DS    18F\nSAVESAVE DS    F\nTRSAV    DS    3F\nFLAG     DS    F\n*                                 X'80'  NON-STD PGM LINKAGE\n*                                 X'40'  TSO CMD LINKAGE\n*                                 X'20'  ISP SELECT LINKAGE\nFLAG1    EQU   FLAG+1\n*                                 X'80'  SAVED DISPLAY ENVIRONMENT\n*                                 X'40'  WRITE REQUEST\n*                                 X'20'  VARIABLE REWRITE IN PROCESS\nFLAG2    EQU   FLAG+2                                              V1M5\n*                                 X'80'  ISPEXEC SERVICE REQUEST   V1M5\n*                                 X'40'  IMPLICIT ISPEXEC REQUEST  V1M5\n*                                 X'20'  ISPF WAS NOT ACTIVE       V1M5\n*                                 X'10'  FOCUS CMD() TYPE CALL     V1M5\n*                                 X'08'  SPF OPTION  TYPE CALL     V1M5\nSAVEPP   DS    F\nSAVEOFF  DS    H                                                   V1M5\nXCPPL    DS    4F                                                  V1M5\nSPREFIX  DC    H'0',H'0'                                           V1M5\nSPSTART  DC    C'SPF PGM(SPFEXEC) PARM('                           V1M5\nSPTEXT   DS    CL200                                               V1M5\nSPEND    DS    C')'                                                V1M5\nREALPGM  DS    CL8\nEXITPGM  DS    CL8\nREALPARM DS    F\nDELIM    DS    C\nVNLEN    DS    F                  VNAME LEN\nDEFS     DS    CL24               DEFAULT EXIT VARIABLE NAMES\nVNAMES   DS    CL256              REQUESTED EXIT NAMES\nCVNAME   DS    CL8                CURRENT REQUESTED VAR NAME\nVL1      DS    F                  LENGTH\nVA1      DS    XL256              DATA\nVL2      DS    F                  LENGTH\nVA2      DS    XL256              DATA\nCL       CALL  ,(0,0,0,0,0,0,0),MF=L\nLL       LINK  SF=L               LINK PARM LIST\nLL2      LOAD  SF=L               LOAD PARM LIST\nEXECLIST DS    2A                 PARM LIST FOR ISPEXEC CALL\nEXECLST2 DS    2A                 PARM LIST FOR ISPEXEC CALL\nEXLEN    DS    F                  BUFF LEN FOR ISPEXEC\nVAREA    DS    10XL260            REQUESTED VARIABLES\nWORKLEN  EQU   *-WORKAREA\n         MEND\n         EJECT\nPANLEXIT ENTERR LEVEL=V1M8,CLEAR=YES\n         EJECT\n*\n*  FIRST THING TO DO IS TO ANALYZE THE PARM STRING\n*     FOR NAME OF REAL DIALOG PROGRAM.\n*\n         LR    R11,R1             SAVE PARM PTR\n         L     R1,0(R11)          R1->1ST PARM\n         MVC   REALPGM,=CL256' '  CLEAR EPLOC\n*\n         TM    0(R11),X'80'       ONE PARM?\n         BO    STDPARM            YES->STANDARD LINKAGE WE HOPE\n         OI    FLAG,X'80'         NOT STANDARD PGM LINKAGE\n         CLC   0(2,R1),=C'TLD'    TLD?\n         BE    ISPTYPE\n* ONLY THING LEFT IS TSO COMMAND LINKAGE?\n         OI    FLAG,X'40'         SAY TSO COMMAND  LINKAGE\n         LH    R4,0(R1)           R4=CMD LENGTH\n         SH    R4,=H'4'           R4-4 FOR COMMAND DESCRIPTOR WORD\n         LH    R2,2(R1)           R2=OFFSET TO REAL CMD NAME\n         SR    R4,R2              R4-OFFSET = REMAINING BUFFER LENGTH?\n         BZ    NAMEANAL                                            V1M5\n         LR    R7,R4\n         LA    R3,4(R1,R2)        R3->START SCAN AREA FOR PGM NAME\n         B     SSCAN1\nISPTYPE  OI    FLAG,X'20'         SAY ISP SELECT LINKAGE\n         L     R3,4(R11)          R3->PARM STR\n         LR    R1,R3              R1-> \"    \"\n         LA    R4,8               R4=8  PSUEDO LENGTH\n         LR    R7,R4              R7=\"\n         B     SSCAN\nSTDPARM  L     R3,0(R11)          R3-> PARM STRING\n         LH    R4,0(R3)           R4=PARM LENGTH\n         LR    R7,R4              SAVE LEN\n         LA    R3,2(R3)           R3->PARM STRING START\nSSCAN1   CH    R4,=H'8'           BIG?\n         BNH   SSCAN              START SCAN FOR PGM NAME\n         LA    R4,8               MAX IS 8\nSSCAN    SLR   R5,R5              INDEX=0\n         ST    R3,SAVEPP          SAVE NAME START                  V1M5\nPL       CLI   0(R3),C','         REAL PARM?\n         BE    FNPARM             YUP -> GO FIND NEXT PARM\n         CLI   0(R3),C' '         REAL PARM?\n         BE    FNPARM             YUP ->GO FIND NEXT PARM\n         IC    R6,0(R3)           GET THE CHAR\n         STC   R6,REALPGM(R5)     SAVE IT\n         LA    R5,1(R5)           NEXT SLOT\n         LA    R3,1(R3)           NEXT CHAR\n         BCTR  R7,R0              ADJUST LENGTH\n         BCT   R4,PL              MORE?\n         LTR   R7,R7              MORE MORE?                       V1M7\n         BZ    NAMEANAL           NOPE NOPE.                       V1M7\nFNPARM   CLI   0(R3),C','         COMMA?                           V1M5\n         BE    SKIPSEP            YUP                              V1M5\n         CLI   0(R3),C' '         BLANK?                           V1M5\n         BNE   NAMEANAL                                            V1M5\nSKIPSEP  LA    R3,1(R3)           R3->NEXT CHAR                    V1M5\n         BCT   R7,FNPARM          CNT SEPS                         V1M5\n         EJECT\n*\n*  WE HAVE NOW COPIED THE REAL PROGRAM NAME.\n*\n*  FIRST SET FLAGS BY WHAT WE FOUND:                               V1M5\n*                                                                  V1M5\nNAMEANAL OC    REALPGM,=CL256' '     MAKE SURE UPPER CASE NAME     V1M5\n         CLC   REALPGM(4),=C'CMD('   FOCUS TYPE SPF CALL?          V1M5\n         BE    FFLG                                                V1M5\n         CLC   REALPGM(4),=C'PGM('   FOCUS TYPE SPF CALL?          V1M5\n         BE    FFLG                                                V1M5\n         CLC   REALPGM(6),=C'PANEL(' FOCUS TYPE SPF CALL?          V1M5\n         BE    FFLG                                                V1M5\n         CLC   REALPGM,=CL8' '       FOCUS TYPE SPF CALL?          V1M5\n         BNE   OCHK                                                V1M5\nFFLG     OI    FLAG2,X'10'                                         V1M5\nOCHK     CLI   REALPGM,C'0'          SPF OPTION TYPE CALL?         V1M5\n         BNL   FFLG1                                               V1M5\n         CLI   REALPGM+1,C'.'        SPF OPTION TYPE CALL?         V1M5\n         BE    FFLG1                                               V1M5\n         CLI   REALPGM+1,C' '        SPF OPTION TYPE CALL?         V1M5\n         BE    FFLG1                                               V1M5\n         CLI   REALPGM+2,C' '        SPF OPTION TYPE CALL?         V1M5\n         BE    FFLG1                                               V1M5\n         CLI   REALPGM+2,C'.'        SPF OPTION TYPE CALL?         V1M5\n         BNE   XCHK                                                V1M5\nFFLG1    OI    FLAG2,X'08'                                         V1M5\nXCHK     CLC   REALPGM,=CL8'ISPEXEC'          ISPEXEC?             V1M5\n         BNE   RECHK                                               V1M5\n         OI    FLAG2,X'80'                                         V1M5\nRECHK    CLC   REALPGM,=CL8'SPFEXEC'          ISPEXEC?             V1M5\n         BNE   IMPCHK                                              V1M5\n         OI    FLAG2,X'80'                                         V1M5\nIMPCHK   CLC   REALPGM,=CL8'SELECT'  IMPLICIT ISPEXEC?             V1M5\n         BE    IMPFLG                                              V1M5\n         CLC   REALPGM,=CL8'DISPLAY' IMPLICIT ISPEXEC?             V1M5\n         BNE   PARMFIX                                             V1M5\nIMPFLG   OI    FLAG2,X'C0'                                         V1M5\n         L     R2,SAVEPP          R2->START OF NAME                V1M5\n         SR    R3,R2              R3=SAFE LENGTH                   V1M5\n         BCTR  R3,R0              -1 FOR EX                        V1M5\nFOLD     OC    0(0,R2),=CL256' '                                   V1M5\n         EX    R3,FOLD            THESE NEED TO BE UPPER CASE!     V1M5\n*\nPARMFIX  TM    0(R11),X'80'       ONE PARM?\n         BO    STDPARM2           YUP\n         TM    FLAG,X'40'         TSO?\n         BNO   ISPCHK             NOPE\n         EJECT\n*\n*  PATCH UP THE PARM OR BUFFER PASSED:\n*\n*\n* HANDLE TSO CBUF UPDATE HERE\n*\n         TM    FLAG2,X'58'        IMPLICIT ISPEXEC OR FOCUS?       V1M5\n         BNZ   VDEF                                                V1M5\n         LA    R2,0(R2,R5)        R2=NEW OFFSET TO OPERANDS\n         MVC   SAVEOFF,2(R1)      SAVE OFFSET                      V1M5\n         STH   R2,2(R1)           SET IT\n         B     VDEF\n*\n* HANDLE NON-STANDARD ISPF LINKAGE CALLS HERE\n*\n* NOTE - WE SHOULD BE ABLE TO DO THIS BECAUSE THERE IS NO LENGTH\n*  FIELD HERE TO CAUSE 0C6 ABEND DUE TO ALIGNMENT LIKE WE GET WITH\n*  A STANDARD PARM IF WE MOVE THE LENGTH INSTEAD OF THE DATA STRING.\n*\nISPCHK   MVC   SAVEPP,4(R11)      SAVE ORIGINAL PARM\n         ST    R3,4(R11)          CHANGE ISPF PARM LIST\n         B     VDEF               ALL OK\n*\n* HANDLE STANDARD PARM LINKAGE CALLS HERE\n*\nSTDPARM2 TM    FLAG2,X'58'        IMPLICIT ISPEXEC?                V1M5\n         BNZ   VDEF               DONT SQUEEZE PARM                V1M5\n         STH   R7,0(,R1)          SAVE NEW LENGTH\n         LTR   R7,R7              ANY PARM LEFT?\n         BZ    VDEF               NO->DON'T MOVE IT THEN\nMVC      MVC   2(0,R1),0(R3)      EXECUTED\n         BCTR  R7,R0              FUDGE FOR EX\n         EX    R7,MVC             SHIFT THE PARM\n         EJECT\nVDEF     EQU   *\n*\n*     DEFINE THE REQUESTED PANEL EXIT ROUTINES:\n*\n         MVC   XADDRESS,=V(DVAREXIT)\n         MVC   VNAMES,=CL256' '         BLANKS\n         MVC   VNLEN,=F'256'      INIT NAME LIST LENGTH\n         CALL  ISPLINK,(=C'VCOPY',=CL8'PANLXVN',VNLEN,VNAMES,=C'MOVE'),X\n               VL,MF=(E,CL)\n         CH    R15,=H'20'         ISPF ACTIVE?                     V1M5\n         BE    NOSPF                                               V1M5\n         CH    R15,=H'8'          FOUND IT?\n         BNL   SETDEFS            NOPE\n*\n         CALL  ISPLINK,(=CL8'VDEFINE',VNAMES,VAREA,=CL8'USER',         X\n               =F'260',=CL8' ',XADDRESS),VL,MF=(E,CL)\n         EJECT\n*\n*     DEFINE THE DEFAULT PANEL EXIT ROUTINES:\n*      VARIABLES ARE PANLEXIT AND PANLXSAV\n*       PANLEXIT IS THE ONLY VARIABLE WHICH DOES NOT CAUSE\n*       AN AUTOMATIC CONTROL SAVE (UNLESS FUNCTION = DISPLAY)\n*\nSETDEFS  MVI   VA1,C' '           A BLANK\n         MVC   VA1+1(255),VA1     SMEAR\n         MVI   VA2,C' '           A BLANK\n         MVC   VA2+1(255),VA2     SMEAR\n*\n         MVC   DEFS,=CL24'(PANLEXIT,PANLXSAV)'\n         CALL  ISPLINK,(=CL8'VDEFINE',DEFS,VL1,=CL8'USER',             X\n               =F'260',=CL8' ',XADDRESS),VL,MF=(E,CL)\n         B     REALCALL                                            V1M5\n         EJECT\n*\n*     NEED TO INVOKE ISPF IF NOT ACTIVE:\n*\nNOSPF    OI    FLAG2,X'20'        SAY ISPF CALLED FROM THIS COPY   V1M5\n         MVC   REALPGM,=CL8'ISPF'                                  V1M5\n         MVC   SPTEXT,=CL256' '                                    V1M5\n         MVC   SPREFIX(2),=H'227' MUST HAVE CBUF                   V1M5\n         MVC   SPREFIX+2(2),=H'4' TO START ISPF                    V1M5\n         MVC   SPSTART,=C'SPF PGM(SPFEXEC) PARM('                  V1M5\n         MVC   SPEND,=C')'                                         V1M5\n         TM    FLAG,X'40'         TSO CMD?                         V1M5\n         BNO   NOTCMD                                              V1M5\n         TM    FLAG2,X'18'        FOCUS TYPE?                      V1M5\n         BNZ   REALCALL           CBUF WAS OK                      V1M5\n         L     R1,0(R11)          R1->CBUF                         V1M5\n         LH    R15,0(R1)          R15=CBUF LEN                     V1M5\n         SH    R15,=H'4'          -4                               V1M5\n         LA    R1,2(R1)           +2                               V1M5\n         B     MBUF                                                V1M5\nNOTCMD   L     R1,0(R11)          R1->PARM FIELD                   V1M5\n         LH    R15,0(R1)          R15=PARM LEN                     V1M5\n*  NEED SOME CODE HERE TO BUILD A CPPL- CHECK PDS COMMAND          V1M5\n         LA    R11,XCPPL                                           V1M5\n         L     R14,16             CVT                              V1M5\n         L     R14,0(R14)         CVTTCB                           V1M5\n         L     R14,4(R14)         TCB                              V1M5\n         L     R5,180(R14)        JSCB                             V1M5\n         L     R5,264(R14)        PSCB                             V1M5\n         ST    R14,XCPPL+8                                         V1M5\n         L     R14,52(R14)        UPT                              V1M5\n         ST    R14,XCPPL+4                                         V1M5\n         L     R14,X'21C'         TCB                              V1M5\n         L     R14,X'7C'(R14)     JSTCB                            V1M5\n         L     R14,X'88'(R14)     DAUGHTER                         V1M5\n         L     R14,X'50'(R14)     IKJEFT01 R8                      V1M5\n         L     R14,X'2C'(R14)     ECT                              V1M5\n         ST    R14,XCPPL+12                                        V1M5\nMBUF     MVC   SPTEXT(0),2(R1)                                     V1M5\n         BCTR  R15,R0             -1                               V1M5\n         EX    R15,MBUF           COPY THE PARM TEXT               V1M5\n         LA    R1,SPREFIX                                          V1M5\n         ST    R1,0(R11)          PASS NEW CBUF                    V1M5\n         LR    R1,R11             CPPL                             V1M5\n         WXTRN NEWISPF,ISRPCP,ISPICP   V1M6\nCALLISPF ICM   R15,15,=A(NEWISPF) V1M6\n         BNZ   CALLIT             V1M6\n         ICM   R15,15,=A(ISRPCP)  V1M6\n         BNZ   CALLIT             V1M6\n         ICM   R15,15,=A(ISPICP)  V1M6\n         BNZ   CALLIT             V1M8\n         LR    R14,R1             V1M8\n         LOAD  EP=ISPF,SF=(E,LL2) V1M8\n         LR    R15,R0             V1M8\n         LR    R1,R14             V1M8\n*V1M8    BZ    LINK               V1M6\nCALLIT   BALR  R14,R15            V1M6 START ISPF\n         B     CALLDONE           V1M6\n*V1M6    B     LINK                                                V1M5\n         EJECT\n*\n*     LINK TO DIALOG TO BE INTERCEPTED OR ISPEXEC\n*\nREALCALL L     R15,4(R13)         R15->OLD SAVE AREA\n         LM    R14,R11,12(R15)    RESTORE ALL REGS EXCEPT 12,13\n*                                 (THIS IS ULTRA PROTECTION)\n         TM    FLAG2,X'20'        ISPF ACTIVE YET?                 V1M5\n*V1M6    BO    LINK               NO-> LINK TO ISPF FIRST THEN     V1M5\n         BO    CALLISPF           NO-> CALL    ISPF FIRST THEN     V1M6\n         TM    FLAG2,X'98'        ISPEXEC OR FOCUS TYPE?           V1M5\n         BZ    LINK               NO-> CALL REAL DIALOG            V1M5\n         L     R15,0(R1)          R15->PARM STRING\n         LH    R1,0(R15)          R1=PARM LEN\n         TM    FLAG2,X'18'        FOCUS TYPE SPF REQUEST?          V1M5\n         BNZ   FOCFUDGE           YUP->BUILD A GOOD EXEC BUF       V1M5\n         TM    FLAG,X'40'         TSO CMD?                         V1M5\n         BNO   NOTCMD2                                             V1M5\nGETBUF   SH    R1,=H'4'           LEN-4                            V1M5\n         SH    R1,2(R15)          -OFFSET                          V1M5\n         ST    R1,EXLEN           NEWLEN                           V1M5\n         LA    R1,4(R15)          R1->CMD STR                      V1M5\n         AH    R1,2(R15)          R1->TRUE REQUEST                 V1M5\n         ST    R1,EXECLST2+4      PASS                             V1M5\n         B     CALLEX                                              V1M5\nNOTCMD2  ST    R1,EXLEN           SAVE IT IN A FULLWORD\n         LA    R1,2(R15)          R1->PARM WITHOUT LENGTH FIELD\n         ST    R1,EXECLST2+4      PASS\nCALLEX   OI    EXECLST2+4,X'80'   FLAG\n         LA    R1,EXLEN           R1->NEW LENGTH FIELD\n         ST    R1,EXECLST2        PASS\n         LA    R1,EXECLST2        R1->NEW PARM LIST FOR ISPEXEC\n         CALL  ISPEXEC\n         C     R15,=F'4'          END KEY?                         V1M5\n         BNE   CALLDONE           NOOP                             V1M5\n         TM    FLAG2,X'18'        FOCUS?                           V1M5\n         BZ    CALLDONE           NO                               V1M5\n         SLR   R15,R15            RC=0                             V1M5\n         B     CALLDONE                                            V1M5\n         EJECT\n*\n*   FUDGE THE SELECT OPERAND ETC. , IF MISSING:                    V1M5\n*\nFOCFUDGE EQU   *                                                   V1M5\n         MVC   SPSTART,=CL22'SELECT'                               V1M5\n         MVC   SPTEXT,=CL256' '                                    V1M5\n         MVI   SPEND,C' '                                          V1M5\n         TM    FLAG2,X'08'        OPTION CALL?                     V1M5\n         BNO   NOPT                                                V1M5\n         STM   R15,R1,TRSAV                                        V1M5\n         CALL  ISPLINK,(=C'CONTROL',=CL8'DISPLAY',                 V1M5X\n               =CL8'REFRESH'),VL,MF=(E,CL)                         V1M5\n         LM    R15,R1,TRSAV                                        V1M5\n         MVC   SPSTART,=CL22'SELECT PANEL(PXP) OPT('               V1M5\n         MVI   SPEND,C')'                                          V1M5\nNOPT     TM    FLAG,X'40'         TSO CMD?                         V1M5\n         BO    FOCCMD                                              V1M5\n         BCTR  R1,R0                                               V1M5\n         LA    R2,2(R15)          R2->CMD TEXT                     V1M5\n         B     MCMD                                                V1M5\nFOCCMD   SH    R1,=H'5'           -PREF LEN                        V1M5\n         SH    R1,2(R15)          -OFFSET                          V1M5\n         LA    R2,4(R15)          SKIP PREFIX                      V1M5\n         AH    R2,2(R15)          R2->TRUE CMD TEXT                V1M5\nMCMD     MVC   SPTEXT(0),0(R2)                                     V1M5\n         EX    R1,MCMD            MOVE CMD                         V1M5\n         LA    R1,SPSTART                                          V1M5\n         ST    R1,EXECLST2+4                                       V1M5\n         MVC   EXLEN,=F'223'                                       V1M5\n         B     CALLEX                                              V1M5\n         EJECT\n*\n*        LINK TO REAL DIALOG/PROGRAM IF NEEDED:\n*\nLINK     LINK  EPLOC=REALPGM,SF=(E,LL) CALL REAL DIALOG\nCALLDONE TM    0(R1),X'80'        ONE PARM?\n         BO    RETURN             OK\n         TM    FLAG,X'40'         TSO COMMAND?\n         BO    RETURN             OK\n         MVC   4(4,R1),SAVEPP     RESTORE PARM LIST\n         EJECT\n*\n*        RETURN TO WHOEVER CALLED US:\n*\nRETURN   DS    0H\nRET      LEAVER\n         TITLE 'WORKAREAS'\n         LTORG\n         EJECT\n*\n*              DYNAMIC WORKAREAS:\n*\n         PANLWORK\n         END\nDVAREXIT TITLE 'DISPLAY PANEL VARIABLE EXIT ROUTER'\n*\n         MACRO\n         PANLWORK\nWORKAREA DSECT\nSAVEAREA DS    18F\nXADDRESS DS    F\nXSAVE    DS    18F\nSAVESAVE DS    F\nTRSAV    DS    3F\nFLAG     DS    F\n*                                 X'80'  NON-STD PGM LINKAGE\n*                                 X'40'  TSO CMD LINKAGE\n*                                 X'20'  ISP SELECT LINKAGE\nFLAG1    EQU   FLAG+1\n*                                 X'80'  SAVED DISPLAY ENVIRONMENT\n*                                 X'40'  WRITE REQUEST\n*                                 X'20'  VARIABLE REWRITE IN PROCESS\nFLAG2    EQU   FLAG+2                                              V1M5\n*                                 X'80'  ISPEXEC SERVICE REQUEST   V1M5\n*                                 X'40'  IMPLICIT ISPEXEC REQUEST  V1M5\n*                                 X'20'  ISPF WAS NOT ACTIVE       V1M5\n*                                 X'10'  FOCUS CMD() TYPE CALL     V1M5\n*                                 X'08'  SPF OPTION  TYPE CALL     V1M5\nSAVEPP   DS    F\nSAVEOFF  DS    H                                                   V1M5\nXCPPL    DS    4F                                                  V1M5\nSPREFIX  DC    H'0',H'0'                                           V1M5\nSPSTART  DC    C'SPF PGM(SPFEXEC) PARM('                           V1M5\nSPTEXT   DS    CL200                                               V1M5\nSPEND    DS    C')'                                                V1M5\nREALPGM  DS    CL8\nEXITPGM  DS    CL8\nREALPARM DS    F\nDELIM    DS    C\nVNLEN    DS    F                  VNAME LEN\nDEFS     DS    CL24               DEFAULT EXIT VARIABLE NAMES\nVNAMES   DS    CL256              REQUESTED EXIT NAMES\nCVNAME   DS    CL8                CURRENT REQUESTED VAR NAME\nVL1      DS    F                  LENGTH\nVA1      DS    XL256              DATA\nVL2      DS    F                  LENGTH\nVA2      DS    XL256              DATA\nCL       CALL  ,(0,0,0,0,0,0,0),MF=L\nLL       LINK  SF=L               LINK PARM LIST\nEXECLIST DS    2A                 PARM LIST FOR ISPEXEC CALL\nEXECLST2 DS    2A                 PARM LIST FOR ISPEXEC CALL\nEXLEN    DS    F                  BUFF LEN FOR ISPEXEC\nVAREA    DS    10XL260            REQUESTED VARIABLES\nWORKLEN  EQU   *-WORKAREA\n         MEND\n         EJECT\nDVAREXIT ENTERWW 1,SA=XSAVE,WA=XSAVE,LEVEL=V1M4\n         LR    R11,R1             SAVE PARM PTR\n         EJECT\n         L     R9,16(R11)         R9->LENGTH OF VARIABLE REQUESTED\n         LA    R10,4(R9)          R10->VARIABLE DATA AREA REQUESTED\n*\n         L     R3,4(,R11)         R3->SRVCODE\n         CLC   0(4,R3),=F'0'      READ?\n         BE    READ\n*\n         MVC   CVNAME,=CL8' '     INIT CURRENT VAR NAME\n         L     R1,8(R11)          R1->VAR NAME REQUESTED\n         SLR   R2,R2              R2=0\n         IC    R2,0(R1)           R2=VAR NAME LEN\n         BCTR  R2,R0              R2-1\nNMVC     MVC   CVNAME(0),1(R1)    EXED\n         EX    R2,NMVC            COPY THE CURRENT VARIABLE NAME\n*\n         CLC   0(4,R3),=F'1'      WRITE?\n         BE    WRITE              NO CAN DO ELSE\n         EJECT\n*\n*        RETURN TO WHOEVER CALLED US:\n*\nRETURN   EQU   *\n         TM    FLAG+1,X'40'       WRITE REQUEST?\n         BNO   RESRET             NUP\n         OI    FLAG+1,X'20'       SAY REWRITE PROCESS\n         LR    R8,R10             R8->CURRENT VARIABLE\n         SH    R8,=H'12'          R8->VARIABLE NAME\n         MVC   SAVESAVE,XSAVE+4  VGET WILL CAUSE RECURSION\n         CALL  ISPLINK,(=C'VGET',CVNAME,=C'SHARED'),VL,MF=(E,CL)\n         MVC   XSAVE+4(4),SAVESAVE  VGET WILL CAUSE RECURSION\n         TM    FLAG+1,X'80'       SAVED ENVIRONMENT?\n         BNO   RESRET             NUP\n         CALL  ISPLINK,(=C'CONTROL',=C'DISPLAY',=C'RESTORE'),MF=(E,CL)\nRESRET   NI    FLAG+1,X'00'       RESET FLAGS\nRET0     SLR   R15,R15            RC=0\nRET      LEAVEWW\n         EJECT\n*\n*  READ VARIABLE REQUEST:\n*\nREAD     EQU   *\n         L     R1,20(R11)         R1->SPFDLEN\n         MVC   0(4,R1),0(R9)      SET LEN\n         L     R1,24(R11)         R1->SPFDATAP\n         LA    R2,0(R10)          R2->DATA\n         ST    R2,0(R1)           PASS DATA BACK\n         B     RET0               ALL DONE\n         EJECT\n*\n*   WRITE ROUTINE:\n*\nWRITE    EQU   *\n         OI    FLAG+1,X'40'       SAY WRITE\n         LA    R1,VA1             R1->PRIMARY VARIABLE\n         CR    R1,R10             SAVE REQUEST?\n         BE    REALRITE           NOOP.\n         TM    FLAG+1,X'20'       REWRITE?\n         BO    REALRITE           YUP\n         CALL  ISPLINK,(=C'CONTROL',=C'DISPLAY',=C'SAVE'),MF=(E,CL)\n         OI    FLAG+1,X'80'       SAY SAVED\nREALRITE L     R1,20(R11)         R1->DATA LENGTH  (SPFDLEN)\n         L     R4,0(R1)           R4=DATA LENGTH\n         ST    R4,0(R9)           SAVE LENGTH\n         L     R1,24(R11)         R1->SPFDATAP             (DATA PTR)\n         L     R3,0(R1)           R3->REAL FUNCTION REQUEST  (DATA)\n         LA    R1,0(R9)           R1->NEW PARM LENGTH\n         ST    R1,EXECLIST        PASS IT\n         LA    R1,0(R10)          R1->NEW PARM AREA\n         ST    R1,EXECLIST+4      PASS IT\n         OI    EXECLIST+4,X'80'   SET END FLAG JUST IN CASE\n         LR    R2,R4              R2=DATA LENGTH\n         BCTR  R2,R0              R2-1 FOR EX\nMVC2     MVC   0(0,R10),0(R3)     EXECUTED\n         EX    R2,MVC2            SAVE THE DATA\n         TM    FLAG+1,X'20'       REWRITE?\n         BO    RET0               YUP\n         MVI   DELIM,C','         SAY COMMA DEFAULT DELIMITER\n         EJECT\n*\n*  NEXT THING TO DO IS TO ANALYZE THE PARM STRING\n*     FOR NAME OF REAL DIALOG PROGRAM.\n*\n         MVC   EXITPGM,=CL8' '    CLEAR EPLOC\n         LR    R7,R4              SAVE LEN\n         CH    R4,=H'8'           BIG?\n         BNH   SSCAN              START SCAN FOR PGM NAME\n         LA    R4,8               MAX IS 8\nSSCAN    SLR   R5,R5              INDEX=0\nPL       CLI   0(R3),C','         REAL PARM?\n         BE    REAL               YUP\n         CLI   0(R3),C' '         REAL PARM?\n         BE    REAL               YUP\n         IC    R6,0(R3)           GET THE CHAR\n         STC   R6,EXITPGM(R5)     SAVE IT\n         LA    R5,1(R5)           NEXT SLOT\n         LA    R3,1(R3)           NEXT CHAR\n         BCTR  R7,R0              ADJUST LENGTH\n         BCT   R4,PL              MORE?\n         EJECT\n*\n*  WE HAVE NOW COPIED THE REAL PROGRAM NAME. PATCH UP THE PARM LIST:\n*\nSTDPARM2 LTR   R7,R7              ANYTHING LEFT?\n         BZ    SETPARM\nSMORE    CLI   0(R3),C','         COMMA?\n         BE    REAL               YUP\n         CLI   0(R3),C' '         BLANK?\n         BNE   SETPARM\nREAL     EQU   *\n         MVC   DELIM,0(R3)        SAVE DELIMITER\n         LA    R3,1(R3)           R3->REAL PARM\n         BCTR  R7,R0              SKIP COMMA\nSETPARM  EQU   *\n         CLC   EXITPGM,=CL8'ISPEXEC'  ISPEXEC CALL?\n         BE    SHIFTIT            YUP\n         CLC   EXITPGM,=CL8'DISPLAY'  ISPEXEC DISPLAY CALL?\n         BE    SAVEDISP           YUP\n         CLI   DELIM,C','         COMMA DELIM?\n         BNE   CALLEXEC           NOPE->ASSUME ISPEXEC WANTED\nSHIFTIT  ST    R7,0(R9)           SAVE NEW LENGTH\n         LTR   R7,R7              ANY PARM LEFT?\n         BZ    XCHK               NO->DON'T MOVE IT THEN\nMVC      MVC   0(0,R10),0(R3)     EXECUTED\n         BCTR  R7,R0              FUDGE FOR EX\n         EX    R7,MVC             SHIFT THE PARM\n         EJECT\n*\n*        CALL ANY NON ISPF SUBROUTINE REQUESTED:\n*\nXCHK     EQU   *\n         CLC   EXITPGM,=CL8'ISPEXEC' SERVICE REQUEST?\n         BE    CALLEXEC           NOPE\n         LA    R1,2(R9)           R1->PGM PARM STRING\n         ST    R1,EXECLIST        SAVE ADDR\n         OI    EXECLIST,X'80'     FLAG IT\n         LA    R1,EXECLIST        R1->NEW PARM LIST\n         LINK  EPLOC=EXITPGM,SF=(E,LL)\n         B     RETURN             ALL DONE!\n         EJECT\n*\n*  SAVE THE DISPLAY ENVIRONMENT IF NEEDED, THEN CALL ISPF SUBRTN\n*\nSAVEDISP EQU   *\n         TM    FLAG+1,X'80'       SAVED ALREADY?\n         BO    CALLEXEC           YUP\n         CALL  ISPLINK,(=C'CONTROL',=C'DISPLAY',=C'SAVE'),MF=(E,CL)\n         OI    FLAG+1,X'80'       SAY SAVED\n         SPACE 3\nCALLEXEC LA    R1,EXECLIST\n         CALL  ISPEXEC            TELL ISPF\n         B     RETURN             ALL DONE!\n         TITLE 'WORKAREAS'\n         LTORG\n         EJECT\n*\n*              DYNAMIC WORKAREAS:\n*\n         PANLWORK\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SPFPRINT": {"ttr": 35334, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x00\\x7f\\x00\\x88\\x00\\x7f\\x12\\x00\\x00t\\x00t\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf2\\xf7\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-01-07T00:00:00", "modifydate": "1988-01-07T12:00:00", "lines": 116, "newlines": 116, "modlines": 0, "user": "FILE270"}, "text": "SPFPRINT TITLE 'SPF DSPRINT OPTIONS INTERCEPT   '\n*\n*    11/07/85 - V1M1 MOD TO IGNORE ISPF OPTION 6\n*\nSPFPRINT CSECT\n         SAVE  (14,12),,SPFPRINT-V1M1\n         LR    R12,R15            R12->SPFPRINT\n         USING SPFPRINT,R12\n         L     R14,540            R14->TCB\n         L     R14,132(R14)       R14->MOTHER\n         L     R15,0(R14)         R15->CURRENT MOTHER RB\n         L     R2,12(R15)         R2->CURRENT MOTHER CDE\n         CLC   8(8,R2),=CL8'ISRPTC' ISPF OPTION 6?\n         BE    XCTL               DON'T MESS WITH!\n         L     R15,28(R15)        R15->PREVIOUS RB\n         CR    R14,R15            TCB = RB?\n         BE    XCTL               SORRY, NOT ISPF\n         L     R14,12(R15)        R14->CDE\n         CLC   8(8,R14),=CL8'ISPTASK' SPF CALLING?\n         BE    TRUENTRY           YUP.\nXCTL     L     R15,=V(VPSPRINT)   R15->REAL DSPRINT\n         L     R14,12(,R13)\n         LM    0,12,20(R13)\n         BR    R15                GO TO REAL DSPRINT\n         EJECT\nTRUENTRY EQU   *\n         LR    R5,R1              R5-> PARM LIST\n         L     R0,=A(WORKLEN)     R0=LENGTH OF WORKAREA\n         GETMAIN R,LV=(0)        GET SOME ROOM TO MANUVER\n         USING WORKAREA,R13\n         ST    R13,4(,R1)         HIS SAVEAREA IN MINE\n         ST    R1,8(,R13)         MY SAVEAREA IN HIS\n         LR    R13,R1             R13->MY SAVEAREA/WORKAREA\n         REGEQU\n*\n*     CALLING SEQUENCE (ISPF CALL TO DSPRINT IS INTERCEPTED.):\n*\n*        CALL  'DSPRINT'    -\n*              CBUF\n*              UPT\n*              PSCB\n*              ECT\n*\n         EJECT\n*\n*              GET ANY DSPRINT OPTIONS:\n*\n         MVI   VA,C' '            A BLANK\n         MVC   VA+1(71),VA        SMEAR\n         MVC   VL(4),VLP          SET DATA AREA LENGTHS\n         CALL  ISPLINK,(=CL8'VCOPY',NL,VL,VA,=CL8'MOVE'),VL,MF=(E,CL)\n         LR    R1,R5\n         LTR   R15,R15            RC=0?\n         BNZ   NOPARMS            NO.\n         LR    R10,R5             R10->CPPL\n         USING CPPL,R10\n         EJECT\n*\n*              ADD ANY DSPRINT OPTIONS TO THE COMMAND STRING:\n*\n*              SET UP:\n         MVI   BLANKS,C' '        GET A SPACE CHAR\n         MVC   BLANKS+1(255),BLANKS  SPREAD IT AROUND\n         MVC   CMD,BLANKS         INIT BUFFER\n         L     R6,CPPLCBUF        R6 -> CMD BUFFER\n         MVC   CMD,0(R6)          PUT IT IN OUR CMD AREA\n*        LENGTH LOOP:\n         LA    R1,200             R1=INDEX TO LAST CMD BUF SPOT\n         LA    R15,CMD+199        R15->CMD BUF END\nCLOOP    CLI   0(R15),C' '        BLANK?\n         BNE   CEND               NOPE.\n         BCTR  R15,R0             YUP.\n         BCT   R1,CLOOP           YUP.\nCEND     STH   R1,CMD             PASS IT\n*\n         MVC   PARML(16),CPPL     COPY PARM LIST\n         LA    R3,CMD             R3 -> NEW CMD BUFF\n         ST    R3,PARML           PASS NEW ADDR\n         LA    R1,PARML           R1->NEW PARM LIST\n*\n*\n*        CALL  DSPRINT:\n*\nNOPARMS  L     R15,=V(VPSPRINT)   R15 -> DSPRINT (REAL ONE)\n         BALR  R14,R15            CALL\n         EJECT\n*\n*        RETURN TO WHOEVER CALLED US:\n*\nRETURN   DS    0H\nRET      LEAVER\n         TITLE 'WORKAREAS'\n*\n*              STATIC WORKAREA:\n*\nNL       DC    C'(DSPRTOPT)'\nVLP      DC    F'72'\n         LTORG\n*\n*\n*              DYNAMIC WORKAREAS:\n*\n*\nWORKAREA DSECT\nSAVEAREA DS    18F\nPARML    DS    3F\nBLANKS   DS    CL256\nVL       DS    F'72'\nCMD      DS    CL128\nVA       DS    0H\nOPTAREA  DS    CL72\nCL       CALL  ,(0,0,0,0,0),MF=L\nWORKLEN  EQU   *-WORKAREA\n         EJECT\n         IKJCPPL\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "SPFYFND5": {"ttr": 35337, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x00\\x7f\\x00\\x88\\x00\\x7f\\x12\\x00\\x00\\xc2\\x00\\xc2\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf2\\xf7\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-01-07T00:00:00", "modifydate": "1988-01-07T12:00:00", "lines": 194, "newlines": 194, "modlines": 0, "user": "FILE270"}, "text": "       ID DIVISION.\n       PROGRAM-ID.  SPFYFND5.\n\n      ****************************************************************\n      *                                                              *\n      *   THIS PROGRAM SUPERCEDES SPFYFND4.                          *\n      *                                                              *\n      ****************************************************************\n           EJECT\n       ENVIRONMENT DIVISION.\n       CONFIGURATION SECTION.\n       INPUT-OUTPUT SECTION.\n\n       FILE-CONTROL.\n\n           SELECT  INPUT-FILE          ASSIGN UT-S-CMDOUT1.\n           SELECT  OUTPUT-FILE         ASSIGN UT-S-OUTFILE.\n           EJECT\n       DATA DIVISION.\n\n       FILE SECTION.\n\n       FD  INPUT-FILE\n           LABEL RECORDS ARE   STANDARD\n           RECORDING MODE IS   F\n           RECORD CONTAINS     80 CHARACTERS\n           BLOCK CONTAINS      0 RECORDS\n           DATA RECORDS IS     INPUT-REC.\n\n       01  INPUT-REC                              PIC X(80).\n           EJECT\n\n       FD  OUTPUT-FILE\n           LABEL RECORDS ARE   STANDARD\n           RECORDING MODE IS   F\n           RECORD CONTAINS     80 CHARACTERS\n           BLOCK CONTAINS      0 RECORDS\n           DATA RECORDS IS     OUTPUT-REC.\n\n       01  OUTPUT-REC                              PIC X(80).\n           EJECT\n       WORKING-STORAGE SECTION.\n\n       77  TIME-TO-QUIT     VALUE 'NO '          PIC X(3).\n\n       01  INPUT-REC-WORK.\n           05  FILLER                             PIC X(09).\n           05  BYTES-10-79.\n               10  BYTES-10-18                    PIC X(09).\n               10  FILLER                         PIC X(61).\n           05  FILLER                             PIC X(01).\n\n       01  SCAN4HIT-I-O-AREA.\n           05  ARGUMENT                           PIC X(80).\n           05  ARGUMENT-LENGTH                    PIC S9(4) COMP.\n           05  TABLE-ELEMENT                      PIC X(80).\n           05  TABLE-ELEMENT-LENGTH               PIC S9(4) COMP.\n           05  HIT-SWITCH                         PIC X(03).\n\n\n           EJECT\n      *\n      *    I S P L I N K   P A R A M E T E R S\n      *\n       01  VDEFINE               VALUE 'VDEFINE'   PIC X(7).\n       01  CHAR                  VALUE 'CHAR'      PIC X(4).\n       01  SHARED                VALUE 'SHARED'    PIC X(6).\n       01  VGET                  VALUE 'VGET'      PIC X(4).\n       01  LENGTH-FIELD                            PIC S9(8) COMP.\n           EJECT\n      *\n      *    S P F   S Y M B O L I C   N A M E S\n      *\n       01  SPF-SYMBOLIC-NAMES.\n           05  SPFYSRCH VALUE '(SPFYSRCH)'         PIC X(10).\n           05  SPFYSLEN VALUE '(SPFYSLEN)'         PIC X(10).\n           EJECT\n      *\n      *    C O B O L   V A R I A B L E   N A M E S\n      *\n\n       01  COBOL-VARIABLE-NAMES.\n           05  SPIFFY-SEARCH-ARGUMENT              PIC X(70).\n           05  SPIFFY-ARGUMENT-LENGTH              PIC 9(2).\n           EJECT\n       PROCEDURE DIVISION.\n\n           PERFORM 1000-INITIALIZATION\n              THRU 1999-EXIT-INITIALIZATION.\n\n           PERFORM 2000-MAIN-PROCESS\n              THRU 2999-EXIT-MAIN-PROCESS\n                  UNTIL\n                      TIME-TO-QUIT = 'YES'.\n\n           CLOSE INPUT-FILE\n                OUTPUT-FILE.\n\n           STOP RUN.\n\n           EJECT\n       1000-INITIALIZATION.\n\n           MOVE +70 TO LENGTH-FIELD.\n           CALL 'ISPLINK'\n             USING\n               VDEFINE\n               SPFYSRCH\n               SPIFFY-SEARCH-ARGUMENT\n               CHAR\n               LENGTH-FIELD.\n\n           MOVE +02 TO LENGTH-FIELD.\n           CALL 'ISPLINK'\n             USING\n               VDEFINE\n               SPFYSLEN\n               SPIFFY-ARGUMENT-LENGTH\n               CHAR\n               LENGTH-FIELD.\n\n           CALL 'ISPLINK'\n                USING VGET SPFYSRCH SHARED.\n\n           CALL 'ISPLINK'\n                USING VGET SPFYSLEN SHARED.\n\n           OPEN INPUT INPUT-FILE\n               OUTPUT OUTPUT-FILE.\n\n       1500-INIT-READS.\n\n           PERFORM 3000-READ\n              THRU 3999-EXIT-READ.\n\n           IF TIME-TO-QUIT = 'YES'\n              CLOSE INPUT-FILE\n                    OUTPUT-FILE\n              STOP RUN.\n\n           MOVE 'ATTRIB :' TO ARGUMENT OF SCAN4HIT-I-O-AREA.\n           MOVE +8 TO ARGUMENT-LENGTH OF SCAN4HIT-I-O-AREA.\n           MOVE INPUT-REC TO TABLE-ELEMENT OF SCAN4HIT-I-O-AREA.\n           MOVE +80 TO TABLE-ELEMENT-LENGTH  OF SCAN4HIT-I-O-AREA.\n\n           CALL 'SCAN4HIT' USING SCAN4HIT-I-O-AREA.\n\n           IF HIT-SWITCH OF SCAN4HIT-I-O-AREA = 'YES'\n               GO TO 1500-INIT-READS.\n\n           MOVE INPUT-REC TO INPUT-REC-WORK.\n\n           IF BYTES-10-18 OF INPUT-REC-WORK = 'PF STATS:'\n              PERFORM 3000-READ\n                 THRU 3999-EXIT-READ\n           ELSE\n               GO TO 1500-INIT-READS.\n\n           MOVE SPIFFY-SEARCH-ARGUMENT\n             TO ARGUMENT OF SCAN4HIT-I-O-AREA.\n           MOVE SPIFFY-ARGUMENT-LENGTH\n             TO ARGUMENT-LENGTH OF SCAN4HIT-I-O-AREA.\n           MOVE +80\n             TO TABLE-ELEMENT-LENGTH OF SCAN4HIT-I-O-AREA.\n\n       1999-EXIT-INITIALIZATION.\n           EXIT.\n           EJECT\n       2000-MAIN-PROCESS.\n\n           MOVE INPUT-REC TO INPUT-REC-WORK.\n           MOVE BYTES-10-79 OF INPUT-REC-WORK\n             TO TABLE-ELEMENT OF SCAN4HIT-I-O-AREA.\n\n           CALL 'SCAN4HIT' USING SCAN4HIT-I-O-AREA.\n\n           IF HIT-SWITCH OF SCAN4HIT-I-O-AREA = 'YES'\n                MOVE TABLE-ELEMENT OF SCAN4HIT-I-O-AREA TO OUTPUT-REC\n                WRITE OUTPUT-REC.\n\n           PERFORM 3000-READ\n              THRU 3999-EXIT-READ.\n\n       2999-EXIT-MAIN-PROCESS.\n           EXIT.\n           EJECT\n       3000-READ.\n\n           READ INPUT-FILE\n              AT END\n                MOVE 'YES' TO TIME-TO-QUIT.\n\n       3999-EXIT-READ.\n           EXIT.\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "STACK": {"ttr": 35341, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x00\\x7f\\x00\\x88\\x00\\x7f\\x12\\x00\\x02\\x1e\\x02\\x1e\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf2\\xf7\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-01-07T00:00:00", "modifydate": "1988-01-07T12:00:00", "lines": 542, "newlines": 542, "modlines": 0, "user": "FILE270"}, "text": "         TITLE 'STACK CP - PUT OUTPUT OF TSO CMD TO A FILE'\n*\n*  V1M4 - MODIFIED TO STOP ABEND 001 IN BATCH TMP RUNS - 01/31/85 KK4\n*  V1M5 - MODIFIED TO ALLOW INDD/OUTDD SYNONYMS        - 11/12/86 KK5\n*  V2M0 - MODIFIED TO LOOP W/LINK TO CMDS AS SPEED TEST- 09/06/88 KK6\n*\nSTACK    ENTERR LEVEL=V2M0\n         LR    R11,R1                   R11 -> CPPL\n         USING CPPL,R11\n         EJECT\n**********************************************************************\n*       MAINLINE PROCESSING CONTROL ROUTINE:                         *\n**********************************************************************\n*\n*              FIRST STEP IS EXTRACT OUR OPERANDS FROM COMMAND:\n*\nB4       BAL   R14,PB                   FIX BUFFER\n         LTR   R15,R15                  OK?\n         BNZ   TERMWERR                 NO\n*\n*              NOW GET SET UP\n*\n         L     R6,CPPLECT               R6->ECT\n         USING ECT,R6                                               KK6\n         MVC   TAG,=CL8'NEWISPF'  ALLOWS ISPF XL CMD                KK6\n         MVC   COPYCPPL,CPPL      \"                                 KK6\n         L     R1,CPPLECT         R1->ECT                           KK6\n         MVC   COPYECT(56),0(R1)  SAVE FOR WDPSCXL (IOSRL NEEDED)   KK6\n         LA    R1,COPYECT         R1->NEW ECT                       KK6\n         ST    R1,COPYCPPL+12     CHAIN IT                          KK6\n*\nNXTCMD   BAL   R14,STACKME              STACK AND GET CMD\n         CH    R15,=H'12'         NOWAIT READ FAILED(NO MORE CLISTS)KK6\n         BE    TERM1              YEP... ALL DONE                   KK6\n         CH    R15,=H'16'         EOD? (NESTED CLIST MAY BE DONE)   KK6\n         BE    NXTCMD                                               KK6\n         LTR   R15,R15                  OK?\n         BNZ   TERMWERR                 NO\n*\n         BAL   R14,SCAN                 SCAN FOR A CMD NAME\n         LTR   R15,R15                  OK?\n         BNZ   TERMWERR                 NO\n*\n         CLC   EPNAME,=CL8'STACKEND' END FAST?                      KK6\n         BE    TERM1              OK                                KK6\n         TM    FLAG,X'08'         FAST RUN?                         KK6\n         BNO   TRYATT             NO->NORMAL RUN                    KK6\n*\n*              DO THE CMD\n*\n         BAL   R14,LINKIT         LINK TO CMD IN FAST MODE          KK6\n         B     CHEKFAST                                             KK6\n*\nTRYATT   BAL   R14,ATTACHME             CALL HIM\n*\n*  IF \"FAST\" TYPE REQUEST, AND NOT STACKEND CMD, LOOP TO NXTCMD:    KK6\n*\nCHEKFAST TM    FLAG,X'08'         FAST?                             KK6\n         BO    NXTCMD             YES->LOOP                         KK6\n         EJECT\n*\n*              REMOVE FROM STACK ?:\n*\nTERM1    BAL   R14,UNSTACKM             REMOVE TOP IF WE ADDED\n*\n         L     R15,AECB                 GET CMD RC IF NORMAL\n         SPACE 3\nTERM     LEAVER\n         SPACE 3\nTERMWERR WTP   'ERROR HAS OCCURED IN STACK CMD'\n         B     TERM\n         EJECT\n*\n*        PB -  PROCESS BUFFER TO REMOVE AND FLAG OUR OPERANDS\n*\nPB       ST    R14,L1LS\n*\n*       FIRST BUILD KOMAND-PROCESSING PARAMETER LIST:\n*\nBPI      XC    KPPL(40),KPPL            CLEAR BUFFER PROC PARMLIST\n         L     R10,0(,R11)              R10 -> CBUF\n         ST    R10,CBUFPTR              BUFFER PTR\n         LA    R10,OPLIST               OPERAND LIST\n         ST    R10,OPLSTPTR             PASS IT\n         LA    R9,FLAG                  FLAG AREA\n         ST    R9,FLAGPTR               PASS IT\n         LA    R8,UNKNEX                EXIT FOR OPS NOT IN MY LIST\n         ST    R8,UNKNEXIT              PASS IT\n         LA    R6,L1LS                  WORK AREA FOR EXIT\n         ST    R6,EXITPARM              PASS IT TO THE EXIT\n         LA    R7,FASTAREA              R7 -> OPLEN AREA\n         ST    R7,WORKPASS              LENGTH PTR RETURN AREA\n         XC    OPFLAG,OPFLAG            CLEAR OPERANDS PRESENT FLAG\n*\n*       THEN CALL KMDPARS (PARSE SUBROUTINE):\n*\n         LA    R1,KPPL                  R1 -> BUFFER PROC PARMLIST\nDOPO     CALL  KMDPARS                  PROCESS AN OPERAND\n         LTR   R15,R15                  ANYTHING FOUND?\n         BNZ   BPT                      YES\n         OI    OPFLAG,X'FF'\n*\n*       SAY DONE AND EXIT:\n*\nBPT      SLR   R15,R15                  RC=0\n         L     R14,L1LS\n         BR    R14\n*\n*   THIS EXIT SETS A FLAG IF ANY OPERANDS WHICH ARE NOT KNOWN ARE HERE:\n*\nUNKNEX   L     R1,0(,R1)                R1 -> L1LS\n         USING L1LS,R1\n         OI    UNKNFLAG,X'FF'           SET IT ON\n         SLR   R15,R15                  RC = 0  SAY OK TO CONTINUE\n         BR    R14                      RETURN TO KMDPARS\n         DROP  R1\n         EJECT\n*\n*   THIS EXIT SAVES THE DDNAMES:\n*\nDDINS    LA    R15,12(,R15)\nDDOUTS   LA    R15,12(,R15)\nTASKSV   LA    R15,10(,R15)\nDDSENT   STM   R14,R12,12(R13)          SAVE REGS\n         BALR  R11,R0                   R11->DDSTART\n         USING DDSTART,R11\nDDSTART  LA    R11,0(,R11)              CLR HI BYTE\n         SR    R15,R11                  R15 = 16,8,OR 0\n         L     R10,0(,R1)               R10-> L1LS\n         USING L1LS,R10\n         L     R9,4(,R1)                R9->BPPL\n         USING BPPL,R9\n         L     R8,SUBPTR                R8->SUB FLD\n         LTR   R8,R8                    ANY?\n         BZ    TRUBELL                  NO\n         L     R7,SUBLENPT              R7->SUBFLD LEN\n         LH    R6,0(R7)                 R6=SUBLEN\n         SH    R6,=H'3'                 -3 FOR PARENS AND EX\n         MVC   DDSAVE(8),=CL8' '        BLANK FILL\nRMVC     MVC   DDSAVE(0),1(R8)          EX ED MVC\n         EX    R6,RMVC                  SAVE IT\n         LA    R5,TASKDD(R15)           PT TO CORRECT AREA FOR THIS GUY\n         MVC   0(8,R5),DDSAVE           MOVE HIM TO HIS SLOT\nTRUBELL  LM    R14,R12,12(R13)          RESTORE REGS\n         SLR   R15,R15                  RC = 0  SAY OK TO CONTINUE\n         BR    R14                      RETURN TO KMDPARS\n         DROP  R11\n         DROP  R10\n         DROP  R9\n         USING CPPL,R11\n         EJECT\n*\n*   THIS ROUTINE STACKS THE DATASETS AND GETS THE CMD:\n*\nSTACKME  ST    R14,L1LS\n*\n         TM    FLAG,X'80'               DDIN PRESENT?\n         BO    STCK                     YES->DOIT\nGETPRE   BAL   R14,GETL                 NO-> GET THE CMD FIRST\n         LTR   R15,R15            OK?\n         BNZ   STEX               NO\n         SPACE\nSTCK     TM    FLAG,X'C0'               ANY DD TO STACK?\n         BZ    GETPOST                  NO\nSTACKIT  BAL   R14,ADDIT                YES->DOIT\n         LTR   R15,R15            OK?\n         BNZ   STEX               NO\n         SPACE\nGETPOST  TM    FLAG,X'80'               DDIN PRES?\n         BNO   PUTCK                    NO->WE ALREADY DID THIS\n         BAL   R14,GETL                 YES-> GET CMD\n         LTR   R15,R15            OK?\n         BNZ   STEX               NO\n         SPACE\nPUTCK    TM    FLAG,X'10'               LIST?\n         BNO   STEX\n         BAL   R14,PUTL                 YES-> ECHO CMD\n         SPACE\nSTEX     L     R14,L1LS\n         BR    R14\n         EJECT\n*\n*   THIS ROUTINE STACKS THE DDNAME:\n*\nADDIT    ST    R14,L2LS\n*\n         L     R7,CPPLUPT               R7->UPT\n         TM    FLAG,X'80'               DDIN PRES?\n         BZ    SE2                      NO\n         SPACE 2\nSE       STACK PARM=STPB,UPT=(R7),ECT=(R6),ECB=ECB,                    X\n               DATASET=(OUTDD=DDOUT,CNTL,SEQ,INDD=DDIN),MF=(E,IOPL)\n         SPACE\n         B     ADDX\n         EJECT\n*\nSE2      STACK PARM=STPB,UPT=(R7),ECT=(R6),ECB=ECB,                    X\n               DATASET=(OUTDD=DDOUT,CNTL,SEQ),                         X\n               MF=(E,IOPL)\n         SPACE 3\nADDX     LTR   R15,R15            STACK OK?\n         BNZ   AXT                NO\n         SPACE\n         MVC   SAVESWS,28(R6)  SAVE ECTSWS FIELD - KK4 01/31/85\n         OI    28(R6),X'02'             PRETEND BACKGROUND\n         SPACE\n         L     R5,4(,R6)          R5->IOSRL\n         MVC   SAVELEM(4),4(R5)   SAVE BOTTOM OF STACK PTR\n         MVC   4(4,R5),0(R5)      PRETEND ONLY ONE ELEMENT IN STACK\n*              (PREVENTS SUBTASK FROM TRYING TO DELETE IT)\n         SPACE\nAXT      L     R14,L2LS\n         BR    R14\n         EJECT\nGETL     ST    R14,L2LS\n         L     R7,CPPLUPT               R7->UPT\n         TM    FLAG,X'08'         FAST?                             KK6\n         BO    GETFAST                                              KK6\n         SPACE 3\n         GETLINE  PARM=GTPB,UPT=(R7),ECT=(R6),ECB=ECB,                 X\n               INPUT=(ISTACK,LOGICAL),TERMGET=(EDIT,WAIT),MF=(E,IOPL)\n         B     GX1                                                  KK6\n         EJECT\n*                                                                   KK6\n*  ADD NOWAIT TYPE GETLINE FOR 'FAST' MODE TO DETECT CLIST ENDS:    KK6\n*                                                                   KK6\nGETFAST  GETLINE  PARM=GTPB,UPT=(R7),ECT=(R6),ECB=ECB,                 X\n               INPUT=(ISTACK,LOGICAL),TERMGET=(EDIT,NOWAIT),MF=(E,IOPL)\n         SPACE 3\nGX1      C     R15,=F'4'          RC=4\n         BNE   GETX               NO->LEAVE IT\n         SLR   R15,R15            4 SAME AS 0\n         SPACE 3\nGETX     L     R14,L2LS\n         BR    R14\n         EJECT\nPUTL     ST    R14,L2LS\n         L     R5,GTPB+4\n         SPACE 3\n         PUTLINE  PARM=PUTLIST,UPT=(R7),ECT=(R6),ECB=ECB,              X\n               OUTPUT=((R5),TERM,SINGLE,DATA),MF=(E,IOPL)\n         SPACE 3\nPUTX     L     R14,L2LS\n         BR    R14\n         EJECT\n*\n*        THIS  ROUTINE ATTACHES THE CMD:\n*\nATTACHME ST    R14,L1LS\n*\n*              CALL APPROPRIATE ATTACH SUBRTN:\n*\n         TM    FLAG,X'20'               TASKDD PRES?\n         BNO   NTL                      NO\n         BAL   R14,AWTL                 YES->ATTACH WITH TASKLIB\n         B     AEX                      GOON\n         SPACE\nNTL      BAL   R14,AWNTL                ATTACH W/NO TASKLIB\n         SPACE 2\nAEX      L     R14,L1LS\n         BR    R14\n         EJECT\nSCAN     ST    R14,L2LS\n         LA    R10,CSPLA                R10->CSPL\n         USING CSPL,R10\n         LA    R9,CSOAA                 R9->CSOA\n         USING CSOA,R9\n         XC    CSPLA(9),CSPLA\n         MVC   CSPLUPT,CPPLUPT\n         MVC   CSPLECT,CPPLECT\n         LA    R8,ECB             R8->ECB\n         ST    R8,CSPLECB\n         LA    R7,CSOAF           R7->CSOAF\n         ST    R7,CSPLFLG\n         ST    R9,CSPLOA\n         L     R1,GTPB+4                R1->CBUF\n         ST    R1,CSPLCBUF              PASS CBUF TO SCAN\n         CLI   4(R1),C'0'               FIRST CHAR < 0 ?\n         BL    SCANIT                   YES->NO LINE NUMBER\n         MVC   4(8,R1),=CL8' '          NO->KILL LINE NUMBER\n         SPACE\nSCANIT   LR    R1,R10                   R1->CSPL\n         CALLTSSR EP=IKJSCAN\n         LTR   R15,R15\n         BNZ   SCANEX\n         EJECT\n         TM    CSOAFLG,X'C0'      ANY?\n         BNZ   GCN                YES\nSCANERR  LA    R15,33             NO->RC=33\n         B     SCANEX\nGCN      L     R4,CSOACNM               R4->CMD NAME\n         LTR   R4,R4                    OK?\n         BZ    SCANERR            YES\nGCL      LH    R5,CSOALNM               R5=CMD NAME LEN\n         LTR   R5,R5              R5>0?\n         BNP   SCANERR            NO\n         BCTR  R5,R0                    R5=R5-1 FOR EX\n         MVC   EPNAME,=CL8' '           CLEAR EPNAME AREA\nRM       MVC   EPNAME(0),0(R4)          EX'ED CMDNAME SAVE\n         EX    R5,RM                    DOIT\n         SPACE\n         MVC   ECTPCMD,=CL8' '          CLEAR ECT NAME AREA\nCNS      MVC   ECTPCMD(0),0(R4)         EX'ED CMDNAME SAVE\n         EX    R5,CNS                   DOIT\n         SPACE\n         NI    ECTSWS,255-ECTNOPD SAY OPERANDS\n         CLI   CSOAFLG,X'80'      PRESENT?\n         BE    ISPCHK             YES\n         OI    ECTSWS,ECTNOPD     SAY NO OPERANDS\n         SPACE\nISPCHK   CLC   EPNAME,=CL8'ISPEXEC' ISPF SERVICE CALL ?             KK6\n         BNE   TIMECHK            NO                                KK6\n         MVC   EPNAME,=CL8'SPFEXEC'                                 KK6\n         L     R1,GTPB+4          R1->CBUF                          KK6\n         XC    2(2,R1),2(R1)      RESET OFFSET FOR SPFEXEC SCAN     KK6\n         B     SCANEX                                               KK6\nTIMECHK  CLC   EPNAME,=CL8'TIME'  PSUEDO TIME?                      KK6\n         BNE   SCANEX             NOPE                              KK6\n         MVC   EPNAME,=CL8'IKJEFT25' WE ARE THE TMP!                KK6\nSCANEX   L     R14,L2LS\n         BR    R14\n         EJECT\nLINKIT   ST    R14,L2LS\n         MVC   CPPLCBUF,GTPB+4                                      KK6\n         TM    CSOAFLG,X'04'      CLIST?                            KK6\n         BO    CLIST                                                KK6\nLINK2    EQU   *                                                    KK6\n         LOAD  EPLOC=EPNAME,ERRET=CLIST                             KK6\n         LA    R1,CPPL                                              KK6\n         LINK  EPLOC=EPNAME,SF=(E,LLIST)                            KK6\n         ST    R15,ECTRCDF        SAVE CMD RC                       KK6\n         SLR   R15,R15                                              KK6\n         L     R14,L2LS                                             KK6\n         BR    R14                                                  KK6\nCLIST    MVC   EPNAME,=CL8'EXEC'                                    KK6\n         L     R1,GTPB+4          R1->CBUF                          KK6\n         XC    2(2,R1),2(R1)      RESET OFFSET FOR    EXEC SCAN     KK6\n         B     LINK2                                                KK6\n         EJECT\nAWNTL    ST    R14,L2LS\n         SPACE 2\nAWNTL2   MVC   CPPLCBUF,GTPB+4          PASS CBUF\n         LA    R1,CPPL                  PASS CPPL\n         SPACE\n         XC    ATTACHL(60),ATTACHL\n         ATTACH EPLOC=EPNAME,ECB=AECB,SHSPV=78,SF=(E,ATTACHL)\nACFIN    LTR   R1,R1                    ANY TCB?\n         BZ    AWNTLX                   NO->FASTEXIT\n         ST    R1,TCBADD\n         SPACE 2\n         XC    AECB,AECB                CLEAR ECB\n         WAIT  ECB=AECB                 LET HIM RUN THEN\n         SPACE 2\n         DETACH TCBADD                  REMOVE DEAD TCB\n         SPACE 2\nAWNTLX   L     R14,L2LS\n         BR    R14\n         EJECT\nAWTL     ST    R14,L2LS\n         SPACE\n         MVC   DCBL(96),DCBP            INIT DCB\n         MVC   DCBL+40(8),TASKDD       GET DDNAME\n         MVC   OPENL(4),=X'80000000'    INIT OPEN\n         OPEN  (DCBL,INPUT),MF=(E,OPENL)  OPEN THE TASKLIB\n         TM    DCBL+48,X'10'            DID IT OPEN?\n         BZ    AWNTL2                   NO->DON'T USE IT THEN\n         MVC   CPPLCBUF,GTPB+4          PASS CBUF\n         LA    R1,CPPL                  PASS CPPL\n         SPACE 2\n         XC    ATTACHL(60),ATTACHL\n         ATTACH EPLOC=EPNAME,ECB=AECB,SHSPV=78,DCB=DCBL,               X\n               TASKLIB=DCBL,SF=(E,ATTACHL)\n         SPACE\n         B     ACFIN                    REST IS THE SAME\n         EJECT\n*\n*        THIS  ROUTINE UNSTACKS WHATEVER WE STACKED:\n*\nUNSTACKM ST    R14,L1LS\n*\n         TM    FLAG,X'C0'               ANYTHING STACKED?\n         BZR   R14                      NO->EXIT FAST\n         SPACE 2\n         L     R5,4(,R6)          R5->IOSRL\n         MVC   4(4,R5),SAVELEM    RESTORE TRUE STACK BOTTOM FIRST\n         SPACE 2\n         BAL   R14,DELIT                REMOVE TOP ENTRY\n         SPACE 3\nUSX      L     R14,L1LS\n         BR    R14\n         EJECT\n*\n*        THIS  ROUTINE REMOVES THE TOP ELEMENT ON THE STACK:\n*\nDELIT    ST    R14,L2LS\n*\n         L     R7,CPPLUPT               R7->UPT\n*\nSED      STACK PARM=STPB,UPT=(R7),ECT=(R6),ECB=ECB,                    X\n               DELETE=TOP,MF=(E,IOPL)\n         SPACE 3\n* THIS RETURNS TO FOREGROUND MODE ONLY IF NOT IN BATCH - KK4 01/31/85\n         MVC   28(1,R6),SAVESWS   RESTORE ECTSWS FIELD - KK4 01/31/85\n*KK4     NI    28(R6),X'FD'             RETURN TO FOREGROUND\n         SPACE 3\n         L     R14,L2LS\n         BR    R14\n         EJECT\nSTATWORK EQU   *\n*\n*              STACK DDIN() DDOUT() TASKLIB() LIST\n*\nOPLIST   DC    F'0'                     LIST OF KNOWN OPERANDS:\n         DC    A(OPER1)\n         DC    A(OPER2)\n         DC    A(OPER3)\n         DC    A(OPER4)\n         DC    A(OPER5)   KK5\n         DC    A(OPER6)   KK5\n         DC    A(OPER7)   KK6\n         DC    F'0'\n         DC    F'0'\n         SPACE\nOPER1    DS    0F\n         DC    X'8000'                  BYTE1=FLAG MASK,BYTE2=FLAG BYTE\n         DC    X'8000'                  OPTIONS  (X'80'=TAKE EXIT)\n*                                       OPTIONS  (X'40'=BLANK OUT)\n         DC    A(DDINS)                 EXIT ADDR\n         DC    H'4'                     OPERAND LENGTH\nDDI      DC    CL8'DDIN'                OPERAND NAME\n         SPACE\nOPER2    DS    0F\n         DC    X'4000'\n         DC    X'8000'                  OPTIONS  (X'80'=TAKE EXIT)\n*                                       OPTIONS  (X'40'=BLANK OUT)\n         DC    A(DDOUTS)                EXIT ADDR\n         DC    H'5'\nDDO      DC    CL8'DDOUT'\n         SPACE\nOPER3    DS    0F\n         DC    X'2000'\n         DC    X'8000'                  OPTIONS  (X'80'=TAKE EXIT)\n*                                       OPTIONS  (X'40'=BLANK OUT)\n         DC    A(TASKSV)                EXIT ADDR\n         DC    H'7'\nTASKLB   DC    CL8'TASKLIB'\n         SPACE\nOPER4    DS    0F\n         DC    X'1000'\n         DC    X'0000'                  OPTIONS  (X'80'=TAKE EXIT)\n*                                       OPTIONS  (X'40'=BLANK OUT)\n         DC    A(0)                     EXIT ADDR\n         DC    H'4'\nLIST     DC    CL8'LIST'\n         SPACE\nOPER5    DS    0F                                          KK5\n         DC    X'8000'                  BYTE1=FLAG MASK,BYTE2=FLAG BYTE\n         DC    X'8000'                  OPTIONS  (X'80'=TAKE EXIT)\n*                                       OPTIONS  (X'40'=BLANK OUT)\n         DC    A(DDINS)                 EXIT ADDR\n         DC    H'4'                     OPERAND LENGTH\nDDI2     DC    CL8'INDD'                OPERAND NAME\n         SPACE\nOPER6    DS    0F                                          KK5\n         DC    X'4000'\n         DC    X'8000'                  OPTIONS  (X'80'=TAKE EXIT)\n*                                       OPTIONS  (X'40'=BLANK OUT)\n         DC    A(DDOUTS)                EXIT ADDR\n         DC    H'5'\nDDO2     DC    CL8'OUTDD'\n         SPACE\nOPER7    OPER  FAST,X'0800'                                         KK6\n         SPACE 3\n         LTORG\n         DC    80X'00'                  ZAP AREA\n         EJECT\nDCBP     DCB   DSORG=PO,MACRF=R         PATTERN DCB\n         EJECT\nWORKAREA DSECT\nSAVEAREA DS    18F\nTAG      DC    CL8'NEWISPF'       WDPSCXL MODULE FLAG               KK6\nCOPYCPPL DS    4F                 CPPL COPY FOR WDPSCXL             KK6\nCOPYECT  DS    0D                 CPPL ECT  FOR WDPSCXL             KK6\n         DS    XL64               \"                                 KK6\nL1LS     DS    F\nL2LS     DS    F\nL3LS     DS    F\nL4LS     DS    F\n*\nSAVESWS  DS    X                  SAVE AREA FOR ECTSWS - KK4  01/31/85\n*\nFLAG     DS    F\nOPFLAG   DS    X\nUNKNFLAG DS    X\nSAVELEM  DS    F\nDDSAVE   DC    CL8' '                   DDN SAVE\nTASKDD   DC    CL8' '                   DDN SAVE\nDDOUT    DC    CL8' '                   DDN SAVE\nDDIN     DC    CL8' '                   DDN SAVE\nEPNAME   DC    CL8' '                   EPN SAVE\nTCBADD   DC    F'0'\nLLIST    LINK  EPLOC=L1LS,SF=L                                      KK6\n*\n*              I/O RTN PARM AREA:\n*\nIOPL     DS    4F\nPUTLIST  PUTLINE  MF=L\n*\nSTPB     STACK MF=L\n*\nGTPB     GETLINE MF=L\n*\nECB      DS    F\nAECB     DS    F\n*\n*              CMD SCAN PARM AREA:\n*\nCSPLA    DS    6F\nCSOAA    DS    2F\nCSOAF    DS    F\n*\n         EJECT\nOPENL    OPEN  (DCBL,INPUT),MF=L\n         SPACE 3\nDCBL     DCB   DSORG=PO,MACRF=R         EXECUTION DCB\n         EJECT\nATTACHL  ATTACH EPLOC=EPNAME,ECB=AECB,SHSPV=78,SF=L\n         EJECT\n         KPPL\nFASTAREA DS    XL600                    SOME AREA TO GIVE KMDPARS\n*\nWORKLEN  EQU   *-WORKAREA\n         EJECT\nX        DSECT\n         BPPL\n         EJECT\nMCSPL    IKJCSPL\nMCSOA    IKJCSOA\n         IKJCVT\n         IKJCPPL\n         IKJECT\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "STACK$": {"ttr": 35593, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x00\\x7f\\x00\\x88\\x00\\x7f\\x12\\x00\\x00\\x1c\\x00\\x1c\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf2\\xf7\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-01-07T00:00:00", "modifydate": "1988-01-07T12:00:00", "lines": 28, "newlines": 28, "modlines": 0, "user": "FILE270"}, "text": "1 10.000\n-                                                         STACK cmd\n\n     STACK is a TSO COMMAND PROCESSOR which enables interception of\n PUTGET IO for the duration of the TSO command following STACK. Thus\n the output from a TSO command may be directed to a dataset. STACK\n imitates the TMP to obtain the next TSO command and attach it with\n the IO redirected via the STACK macro. STACK can be used to\n execute a command from a specific library (for example a test version)\n or to call a program using dynamic linkage since the optional TASKDD\n is also used as the tasklib for the duration of the command.\n VIO datasets may be used for the IO files. All operands are optional.\n\n            STACK DDIN(INPUTDD) DDOUT(OUTDD) -\n                  TASKLIB(TASKDD) LIST\n\n                        INPUTDD - DDNAME TO READ COMMAND FROM\n                                         INSTEAD OF NORMAL SOURCE\n                        OUTDD   - DDNAME THE COMMAND OUTPUT SHOULD\n                                         GO TO\n                        TASKDD  - DDNAME THE COMMAND SHOULD BE\n                                         ATTACHED FROM IF DESIRED\n                        LIST    - MEANS DISPLAY THE COMMAND ON THE\n                                         OUTPUT FILE\n                        (ALL OPERANDS ARE OPTIONAL)\n                        (ALL FILE IO MUST BE DONE\n                        VIA PUTGET MODULE TO BE INTERCEPTED)\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "STOJCON$": {"ttr": 35595, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x00\\x7f\\x00\\x88\\x00\\x7f\\x12\\x00\\x00I\\x00I\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf2\\xf7\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-01-07T00:00:00", "modifydate": "1988-01-07T12:00:00", "lines": 73, "newlines": 73, "modlines": 0, "user": "FILE270"}, "text": "1                                                        STOJCONV.1\n                                                         06/25/82\n\n\n  PROGRAM:       STOJCONV\n  AUTHOR:        Jeff Sprehn\n  AGENCY:        WDPSC\n  LANGUAGE:      COBOL\n  LOCATION:      WDPSC.SHARED.LOAD\n  FUNCTION:      Convert  standard dates  of the  form (MMDDYY)  to\n                 Julian and serial after date validation.\n\n  RUN MODE:      N/A...this is a subroutine.\n\n  This is  a subroutine which accepts  a standard date of  the form\n  (MMDDYY) and converts it to two  (2) other types of dates, Julian\n  and serial  if and  only if the  input date is  a valid  date.  A\n  Julian date is of the form YYDDD where  YY is the year and DDD is\n  a  three digit  number  representing  the displacement  from  the\n  beginning  of that  year.  A  serial date  is of  the form  NNNNN\n  representing the displacement from the beginning of the twentieth\n  century.   For example  January  1, 1900  is  serial date  00001,\n  January 2, 1900  is serial date 00002, January 1,  1901 is serial\n  date 00366 (since 1900 was not a leap year), and so on.\n\n  Serial date is a very useful tool  when one wishes to compute the\n  days elapsed between two dates in time when the years may differ.\n  Julian date will not serve this purpose well.  For example; using\n  Julian dates there would be 636 elapsed days between December 31,\n  l979 and  January 1,  1980 (80001 -  79365 =  636) where  in fact\n  there is  only 1.   Using serial dates  rather than  Julian would\n  yield the correct answer of 1.\n\n\n\n\n1                                                        STOJCONV.2\n                                                         06/25/82\n\n\n  This program  is also  an interface to  the CONVDATE  entry point\n  STOJDATE.  STOJDATE will  abend if you supply it  with an invalid\n  date  such as  063279 (there  are only  30 days  in June).   This\n  subroutine (STOJCONV) will completely edit your date first before\n  calling STOJDATE to  obtain your Julian date.  A switch  is to be\n  interrogated to determine the success of that edit.\n\n  HOW TO USE THIS PROGRAM:\n\n  Place the following 0l level into your WORKING STORAGE SECTION:\n\n       01   STOJCONV-I-O-AREA.\n            05   FILLER              PIC X(8).\n            05   IN-STANDARD-DATE    PIC X(6).\n            05   OUT-JULIAN-DATE     PIC 9(5).\n            05   OUT-SERIAL-DATE     PIC 9(5).\n            05   UNSUCCESSFUL-EDIT   PIC X(3).\n\n  Do the following in your PROCEDURE DIVISION:\n\n       MOVE your date to be converted TO IN-STANDARD-DATE OF\n            STOJCONV-I-O-AREA.\n       CALL 'STOJCONV' USING STOJCONV-I-O-AREA.\n       IF UNSUCCESSFUL-EDIT = 'YES'\n            do your error routine\n\n       ELSE\n            your date is now in Julian and serial date format in\n       OUT-JULIAN-DATE and OUT-SERIAL-DATE respectively.\n\n\n\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "STOJCONV": {"ttr": 35841, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x00\\x7f\\x00\\x88\\x00\\x7f\\x12\\x00\\x01\\xac\\x01\\xac\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf2\\xf7\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-01-07T00:00:00", "modifydate": "1988-01-07T12:00:00", "lines": 428, "newlines": 428, "modlines": 0, "user": "FILE270"}, "text": "000010 ID DIVISION.                                                     04/16/76\n000020 PROGRAM-ID.    STOJCONV.                                         23528STO\n000030 AUTHOR.        JEFF SPREHN.                                      JC LV002\n000040 INSTALLATION.  LABOR AND INDUSTRIES.\n000050 DATE-WRITTEN. APRIL 1974.\n000060 DATE-COMPILED.\n000070 REMARKS.\n000080*****************************************************************\n000090*  THIS PROGRAM IS A CALLED MODULE THAT PERFORMS THREE          *\n000100*    FUNCTIONS:                                                 *\n000110*                                                               *\n000120*    1.  EDITS FOR THE VALIDITY OF THE 6 DIGIT DATE (MMDDYY)    *\n000130*        THAT IS BEING PASSED TO THIS MODULE AND MOVES 'YES'    *\n000140*        TO INVALID-INPUT-DATE OF STOJCONV-I-O-AREA             *\n000150*        IF THE DATE BEING PASSED CANNOT BE CONVERTED TO        *\n000160*        JULIAN, ELSE, IF THE DATE CAN BE CONVERTED TO JULIAN,  *\n000170*        IT MOVES 'NO ' TO INVALID-INPUT-DATE OF                *\n000180*        STOJCONV-I-O-AREA.                                     *\n000190*                                                               *\n000200*    2.  CALLS 'STOJDATE' AND MOVES THE RESULTANT JULIAN DATE   *\n000210*        TO JULIAN-DATE OF STOJCONV-I-O-AREA SO THAT            *\n000220*        IT IS AVAILABLE TO THE MAIN-LINE CALLING PROGRAM IF    *\n000230*        AND ONLY IF THE INPUT DATE BEING PASSED TO THIS        *\n000240*        MODULE WAS SUCCESSFULLY VALIDATED.                     *\n000250*                                                               *\n000260*    3.  CONVERTS THE RESULTANT JULIAN DATE TO A SERIAL DATE.   *\n000270*        THE SERIAL DATES START WITH JANUARY 1, 1900, = 1, AND  *\n000280*        RUN THROUGH DECEMBER 31, 1999, = 36524. THIS SERIAL    *\n000290*        DATE IS MOVED TO SERIAL-DATE OF STOJCONV-I-O-AREA ONLY *\n000300*        IF THE INPUT DATE BEING PASSED TO THIS MODULE WAS      *\n000310*        SUCCESSFULLY VALIDATED.                                *\n000320*                                                               *\n000330*                                                               *\n000340*        THEREFORE THIS MODULE CAN BE USED FOR THREE PURPOSES:  *\n000350*                                                               *\n000360*        1.  CONVERT STANDARD DATES OF THE FORM (MMDDYY) TO     *\n000370*            JULIAN WITHOUT FEAR OF AN '0C7'.                   *\n000380*                                                               *\n000390*        2.  VALIDATE DATES OF THE FORM (MMDDYY)   (IN THIS     *\n000400*            CASE, WE ARE NOT CONCERNED WHETHER THIS MODULE     *\n000410*            CALLED 'STOJDATE' OR NOT).                         *\n000420*                                                               *\n000430*        3.  CONVERT STANDARD DATES OF THE FORM (MMDDYY) TO     *\n000440*            A SERIAL DATE TO EASE CALCULATION OF DIFFERENCES   *\n000450*            BETWEEN TWO DATES.                                 *\n000460*                                                               *\n000470*****************************************************************\n000480     EJECT\n000490 ENVIRONMENT DIVISION.\n000500 CONFIGURATION SECTION.\n000510 SOURCE-COMPUTER. IBM-370-158.\n000520 OBJECT-COMPUTER. IBM-370-158.\n000530     EJECT\n000540 DATA DIVISION.\n000550\n000560 WORKING-STORAGE SECTION.\n000570\n000580 77  WORK-STOR  VALUE 'WORKING  STORAGE'     PIC X(16).\n000590\n000600 01  INTERMEDIATE-WORK-DATE.\n000610     05  MONTH                               PIC 99.\n000620     05  DAYY                                PIC 99.\n000630     05  YEAR                                PIC 99.\n000640\n000650 01  STANDARD-DATE.\n000660     05  YEAR                                PIC 99.\n000670     05  MONTH                               PIC 99.\n000680     05  DAYY                                PIC 99.\n000690\n000700 01  INPUT-DATE-VALIDATION.\n000710     05  DATE-BREAK                          PIC X(06).\n000720     05  TEST-DATE-BREAK REDEFINES DATE-BREAK.\n000730         10  MONTH-TEST                      PIC 9(2).\n000740         10  DAYY                            PIC 9(02).\n000750         10  YEAR-CHECK                      PIC 9(02).\n000760\n000770 01  CALCULATE-RESULTS.\n000780     05  QUOTEN.\n000790         10  QUOTENTS                        PIC S99V9.\n000800     05  QUOTEN-BREAK REDEFINES QUOTEN.\n000810         10  QUOT-NUM                        PIC S99V.\n000820         10  QUOT-REMAIN                     PIC SV9.\n000830\n000840 01  JULIAN-DATE-WORK                        PIC 9(05).\n000850     EJECT\n       01  SERIAL-DATE-CONVERSION-TABLE.\n           05  DATE-TABLE.\n               10  DATE-TABLE-VALUES.\n                   15  YEAR-00     VALUE '00'      PIC X(2).\n                   15  S-V-00      VALUE 00365     PIC 9(5).\n                   15  YEAR-01     VALUE '01'      PIC X(2).\n                   15  S-V-01      VALUE 00730     PIC 9(5).\n                   15  YEAR-02     VALUE '02'      PIC X(2).\n                   15  S-V-02      VALUE 01095     PIC 9(5).\n                   15  YEAR-03     VALUE '03'      PIC X(2).\n                   15  S-V-03      VALUE 01460     PIC 9(5).\n                   15  YEAR-04     VALUE '04'      PIC X(2).\n                   15  S-V-04      VALUE 01826     PIC 9(5).\n                   15  YEAR-05     VALUE '05'      PIC X(2).\n                   15  S-V-05      VALUE 02191     PIC 9(5).\n                   15  YEAR-06     VALUE '06'      PIC X(2).\n                   15  S-V-06      VALUE 02556     PIC 9(5).\n                   15  YEAR-07     VALUE '07'      PIC X(2).\n                   15  S-V-07      VALUE 02921     PIC 9(5).\n                   15  YEAR-08     VALUE '08'      PIC X(2).\n                   15  S-V-08      VALUE 03287     PIC 9(5).\n                   15  YEAR-09     VALUE '09'      PIC X(2).\n                   15  S-V-09      VALUE 03652     PIC 9(5).\n                   15  YEAR-10     VALUE '10'      PIC X(2).\n                   15  S-V-10      VALUE 04017     PIC 9(5).\n                   15  YEAR-11     VALUE '11'      PIC X(2).\n                   15  S-V-11      VALUE 04382     PIC 9(5).\n                   15  YEAR-12     VALUE '12'      PIC X(2).\n                   15  S-V-12      VALUE 04748     PIC 9(5).\n                   15  YEAR-13     VALUE '13'      PIC X(2).\n                   15  S-V-13      VALUE 05113     PIC 9(5).\n                   15  YEAR-14     VALUE '14'      PIC X(2).\n                   15  S-V-14      VALUE 05478     PIC 9(5).\n                   15  YEAR-15     VALUE '15'      PIC X(2).\n                   15  S-V-15      VALUE 05843     PIC 9(5).\n                   15  YEAR-16     VALUE '16'      PIC X(2).\n                   15  S-V-16      VALUE 06209     PIC 9(5).\n                   15  YEAR-17     VALUE '17'      PIC X(2).\n                   15  S-V-17      VALUE 06574     PIC 9(5).\n                   15  YEAR-18     VALUE '18'      PIC X(2).\n                   15  S-V-18      VALUE 06939     PIC 9(5).\n                   15  YEAR-19     VALUE '19'      PIC X(2).\n                   15  S-V-19      VALUE 07304     PIC 9(5).\n                   15  YEAR-20     VALUE '20'      PIC X(2).\n                   15  S-V-20      VALUE 07670     PIC 9(5).\n                   15  YEAR-21     VALUE '21'      PIC X(2).\n                   15  S-V-21      VALUE 08035     PIC 9(5).\n                   15  YEAR-22     VALUE '22'      PIC X(2).\n                   15  S-V-22      VALUE 08400     PIC 9(5).\n                   15  YEAR-23     VALUE '23'      PIC X(2).\n                   15  S-V-23      VALUE 08765     PIC 9(5).\n                   15  YEAR-24     VALUE '24'      PIC X(2).\n                   15  S-V-24      VALUE 09131     PIC 9(5).\n                   15  YEAR-25     VALUE '25'      PIC X(2).\n                   15  S-V-25      VALUE 09496     PIC 9(5).\n                   15  YEAR-26     VALUE '26'      PIC X(2).\n                   15  S-V-26      VALUE 09861     PIC 9(5).\n                   15  YEAR-27     VALUE '27'      PIC X(2).\n                   15  S-V-27      VALUE 10226     PIC 9(5).\n                   15  YEAR-28     VALUE '28'      PIC X(2).\n                   15  S-V-28      VALUE 10592     PIC 9(5).\n                   15  YEAR-29     VALUE '29'      PIC X(2).\n                   15  S-V-29      VALUE 10957     PIC 9(5).\n                   15  YEAR-30     VALUE '30'      PIC X(2).\n                   15  S-V-30      VALUE 11322     PIC 9(5).\n                   15  YEAR-31     VALUE '31'      PIC X(2).\n                   15  S-V-31      VALUE 11687     PIC 9(5).\n                   15  YEAR-32     VALUE '32'      PIC X(2).\n                   15  S-V-32      VALUE 12053     PIC 9(5).\n                   15  YEAR-33     VALUE '33'      PIC X(2).\n                   15  S-V-33      VALUE 12418     PIC 9(5).\n                   15  YEAR-34     VALUE '34'      PIC X(2).\n                   15  S-V-34      VALUE 12783     PIC 9(5).\n                   15  YEAR-35     VALUE '35'      PIC X(2).\n                   15  S-V-35      VALUE 13148     PIC 9(5).\n                   15  YEAR-36     VALUE '36'      PIC X(2).\n                   15  S-V-36      VALUE 13514     PIC 9(5).\n                   15  YEAR-37     VALUE '37'      PIC X(2).\n                   15  S-V-37      VALUE 13879     PIC 9(5).\n                   15  YEAR-38     VALUE '38'      PIC X(2).\n                   15  S-V-38      VALUE 14244     PIC 9(5).\n                   15  YEAR-39     VALUE '39'      PIC X(2).\n                   15  S-V-39      VALUE 14609     PIC 9(5).\n                   15  YEAR-40     VALUE '40'      PIC X(2).\n                   15  S-V-40      VALUE 14975     PIC 9(5).\n                   15  YEAR-41     VALUE '41'      PIC X(2).\n                   15  S-V-41      VALUE 15340     PIC 9(5).\n                   15  YEAR-42     VALUE '42'      PIC X(2).\n                   15  S-V-42      VALUE 15705     PIC 9(5).\n                   15  YEAR-43     VALUE '43'      PIC X(2).\n                   15  S-V-43      VALUE 16070     PIC 9(5).\n                   15  YEAR-44     VALUE '44'      PIC X(2).\n                   15  S-V-44      VALUE 16436     PIC 9(5).\n                   15  YEAR-45     VALUE '45'      PIC X(2).\n                   15  S-V-45      VALUE 16801     PIC 9(5).\n                   15  YEAR-46     VALUE '46'      PIC X(2).\n                   15  S-V-46      VALUE 17166     PIC 9(5).\n                   15  YEAR-47     VALUE '47'      PIC X(2).\n                   15  S-V-47      VALUE 17531     PIC 9(5).\n                   15  YEAR-48     VALUE '48'      PIC X(2).\n                   15  S-V-48      VALUE 17897     PIC 9(5).\n                   15  YEAR-49     VALUE '49'      PIC X(2).\n                   15  S-V-49      VALUE 18262     PIC 9(5).\n                   15  YEAR-50     VALUE '50'      PIC X(2).\n                   15  S-V-50      VALUE 18627     PIC 9(5).\n                   15  YEAR-51     VALUE '51'      PIC X(2).\n                   15  S-V-51      VALUE 18992     PIC 9(5).\n                   15  YEAR-52     VALUE '52'      PIC X(2).\n                   15  S-V-52      VALUE 19358     PIC 9(5).\n                   15  YEAR-53     VALUE '53'      PIC X(2).\n                   15  S-V-53      VALUE 19723     PIC 9(5).\n                   15  YEAR-54     VALUE '54'      PIC X(2).\n                   15  S-V-54      VALUE 20088     PIC 9(5).\n                   15  YEAR-55     VALUE '55'      PIC X(2).\n                   15  S-V-55      VALUE 20453     PIC 9(5).\n                   15  YEAR-56     VALUE '56'      PIC X(2).\n                   15  S-V-56      VALUE 20819     PIC 9(5).\n                   15  YEAR-57     VALUE '57'      PIC X(2).\n                   15  S-V-57      VALUE 21184     PIC 9(5).\n                   15  YEAR-58     VALUE '58'      PIC X(2).\n                   15  S-V-58      VALUE 21549     PIC 9(5).\n                   15  YEAR-59     VALUE '59'      PIC X(2).\n                   15  S-V-59      VALUE 21914     PIC 9(5).\n                   15  YEAR-60     VALUE '60'      PIC X(2).\n                   15  S-V-60      VALUE 22280     PIC 9(5).\n                   15  YEAR-61     VALUE '61'      PIC X(2).\n                   15  S-V-61      VALUE 22645     PIC 9(5).\n                   15  YEAR-62     VALUE '62'      PIC X(2).\n                   15  S-V-62      VALUE 23010     PIC 9(5).\n                   15  YEAR-63     VALUE '63'      PIC X(2).\n                   15  S-V-63      VALUE 23375     PIC 9(5).\n                   15  YEAR-64     VALUE '64'      PIC X(2).\n                   15  S-V-64      VALUE 23741     PIC 9(5).\n                   15  YEAR-65     VALUE '65'      PIC X(2).\n                   15  S-V-65      VALUE 24106     PIC 9(5).\n                   15  YEAR-66     VALUE '66'      PIC X(2).\n                   15  S-V-66      VALUE 24471     PIC 9(5).\n                   15  YEAR-67     VALUE '67'      PIC X(2).\n                   15  S-V-67      VALUE 24836     PIC 9(5).\n                   15  YEAR-68     VALUE '68'      PIC X(2).\n                   15  S-V-68      VALUE 25202     PIC 9(5).\n                   15  YEAR-69     VALUE '69'      PIC X(2).\n                   15  S-V-69      VALUE 25567     PIC 9(5).\n                   15  YEAR-70     VALUE '70'      PIC X(2).\n                   15  S-V-70      VALUE 25932     PIC 9(5).\n                   15  YEAR-71     VALUE '71'      PIC X(2).\n                   15  S-V-71      VALUE 26297     PIC 9(5).\n                   15  YEAR-72     VALUE '72'      PIC X(2).\n                   15  S-V-72      VALUE 26663     PIC 9(5).\n                   15  YEAR-73     VALUE '73'      PIC X(2).\n                   15  S-V-73      VALUE 27029     PIC 9(5).\n                   15  YEAR-74     VALUE '74'      PIC X(2).\n                   15  S-V-74      VALUE 27393     PIC 9(5).\n                   15  YEAR-75     VALUE '75'      PIC X(2).\n                   15  S-V-75      VALUE 27758     PIC 9(5).\n                   15  YEAR-76     VALUE '76'      PIC X(2).\n                   15  S-V-76      VALUE 28124     PIC 9(5).\n                   15  YEAR-77     VALUE '77'      PIC X(2).\n                   15  S-V-77      VALUE 28489     PIC 9(5).\n                   15  YEAR-78     VALUE '78'      PIC X(2).\n                   15  S-V-78      VALUE 28854     PIC 9(5).\n                   15  YEAR-79     VALUE '79'      PIC X(2).\n                   15  S-V-79      VALUE 29219     PIC 9(5).\n                   15  YEAR-80     VALUE '80'      PIC X(2).\n                   15  S-V-80      VALUE 29585     PIC 9(5).\n                   15  YEAR-81     VALUE '81'      PIC X(2).\n                   15  S-V-81      VALUE 29950     PIC 9(5).\n                   15  YEAR-82     VALUE '82'      PIC X(2).\n                   15  S-V-82      VALUE 30315     PIC 9(5).\n                   15  YEAR-83     VALUE '83'      PIC X(2).\n                   15  S-V-83      VALUE 30680     PIC 9(5).\n                   15  YEAR-84     VALUE '84'      PIC X(2).\n                   15  S-V-84      VALUE 31046     PIC 9(5).\n                   15  YEAR-85     VALUE '85'      PIC X(2).\n                   15  S-V-85      VALUE 31411     PIC 9(5).\n                   15  YEAR-86     VALUE '86'      PIC X(2).\n                   15  S-V-86      VALUE 31776     PIC 9(5).\n                   15  YEAR-87     VALUE '87'      PIC X(2).\n                   15  S-V-87      VALUE 32141     PIC 9(5).\n                   15  YEAR-88     VALUE '88'      PIC X(2).\n                   15  S-V-88      VALUE 32507     PIC 9(5).\n                   15  YEAR-89     VALUE '89'      PIC X(2).\n                   15  S-V-89      VALUE 32872     PIC 9(5).\n                   15  YEAR-90     VALUE '90'      PIC X(2).\n                   15  S-V-90      VALUE 33237     PIC 9(5).\n                   15  YEAR-91     VALUE '91'      PIC X(2).\n                   15  S-V-91      VALUE 33602     PIC 9(5).\n                   15  YEAR-92     VALUE '92'      PIC X(2).\n                   15  S-V-92      VALUE 33968     PIC 9(5).\n                   15  YEAR-93     VALUE '93'      PIC X(2).\n                   15  S-V-93      VALUE 34333     PIC 9(5).\n                   15  YEAR-94     VALUE '94'      PIC X(2).\n                   15  S-V-94      VALUE 34698     PIC 9(5).\n                   15  YEAR-95     VALUE '95'      PIC X(2).\n                   15  S-V-95      VALUE 35063     PIC 9(5).\n                   15  YEAR-96     VALUE '96'      PIC X(2).\n                   15  S-V-96      VALUE 35429     PIC 9(5).\n                   15  YEAR-97     VALUE '97'      PIC X(2).\n                   15  S-V-97      VALUE 35794     PIC 9(5).\n                   15  YEAR-98     VALUE '98'      PIC X(2).\n                   15  S-V-98      VALUE 36159     PIC 9(5).\n                   15  YEAR-99     VALUE '99'      PIC X(2).\n                   15  S-V-99      VALUE 36524     PIC 9(5).\n           05  CONVERSION-TABLE REDEFINES DATE-TABLE.\n               10  CONVERSION-VALUES OCCURS 100 TIMES.\n                   15  CONV-YEAR                   PIC X(2).\n                   15  CONV-FACTOR                 PIC 9(5).\n       01  SERIAL-YEAR-X                           PIC X(2).\n       01  SERIAL-YEAR-9 REDEFINES SERIAL-YEAR-X   PIC 9(2).\n       01  BINARY-YEAR     COMPUTATIONAL           PIC S9(4).\n       01  SERIALIZED-DATE                         PIC 9(5).\n       01  YEAR-QUOT       COMPUTATIONAL-3         PIC S9(3).\n       01  YEAR-REM        COMPUTATIONAL-3         PIC S9(3).\n       01  JULIAN-BREAKDOWN.\n           05  JULIAN-YEAR                         PIC 9(2).\n           05  JULIAN-DAY                          PIC 9(3).\n       01  SAVE-SERIAL-DATE                        PIC 9(5).\n       01  SERIAL-DATE-X                           PIC X(5).\n       01  SERIAL-DATE-9 REDEFINES SERIAL-DATE-X   PIC 9(5).\n003070 LINKAGE SECTION.\n003080\n       01  STOJCONV-I-O-AREA.\n           05  MODULE-NAME                         PIC X(8).\n           05  INPUT-DATE                          PIC X(6).\n           05  JULIAN-DATE                         PIC X(5).\n           05  SERIAL-DATE                         PIC 9(5).\n           05  INVALID-INPUT-DATE                  PIC X(3).\n\n\n003190     EJECT\n003200 PROCEDURE DIVISION USING STOJCONV-I-O-AREA.\n003210\n003220 0100.\n003230     MOVE 'STOJCONV' TO MODULE-NAME OF STOJCONV-I-O-AREA.\n003240     MOVE INPUT-DATE OF STOJCONV-I-O-AREA\n003250       TO DATE-BREAK OF INPUT-DATE-VALIDATION.\n003260     MOVE 'NO' TO INVALID-INPUT-DATE OF STOJCONV-I-O-AREA.\n003270     PERFORM 15700-VALIDATE-DATE THRU 15799-EXIT-VALIDATE-DATE.\n003280\n003290     IF INVALID-INPUT-DATE OF STOJCONV-I-O-AREA\n003300        EQUAL TO 'YES'\n003310           GO TO 99999-GOBACK.\n003320\n003330     MOVE INPUT-DATE OF STOJCONV-I-O-AREA\n003340       TO INTERMEDIATE-WORK-DATE.\n003350     MOVE CORR INTERMEDIATE-WORK-DATE\n003360       TO STANDARD-DATE.\n003370     CALL 'STOJDATE'\n003380         USING\n003390            STANDARD-DATE\n003400               JULIAN-DATE-WORK.\n003410\n003420     MOVE JULIAN-DATE-WORK TO JULIAN-DATE OF STOJCONV-I-O-AREA.\n003430     SKIP1\n003440     MOVE JULIAN-DATE-WORK TO JULIAN-BREAKDOWN.\n003450     IF JULIAN-YEAR IS EQUAL TO ZERO\n003460         MOVE JULIAN-DATE-WORK TO SERIAL-DATE OF\n003470             STOJCONV-I-O-AREA\n003480         GO TO 10000-YEAR-IS-1900.\n003490     MOVE JULIAN-YEAR TO BINARY-YEAR.\n003500     COMPUTE SERIALIZED-DATE =\n003510         CONV-FACTOR (BINARY-YEAR) + JULIAN-DAY.\n003520     MOVE SERIALIZED-DATE TO SERIAL-DATE OF STOJCONV-I-O-AREA.\n003530     SKIP1\n003540     GO TO 99999-GOBACK.\n003550     SKIP2\n003560 10000-YEAR-IS-1900.\n003570     SKIP2\n003580     IF JULIAN-DAY IS GREATER THAN 00059\n003590         SUBTRACT 1 FROM SERIAL-DATE OF STOJCONV-I-O-AREA.\n003600     SKIP2\n003610     GO TO 99999-GOBACK.\n003620     SKIP2\n003630\n003640\n003650*\n003660*    PARAGRAPHS 15700-VALIDATE-DATE THRU 15799-EXIT-VALIDATE-DATE\n003670*    IS ALWAYS PERFORMED.  IT GUARANTEES THAT THE DATE MOVED TO\n003680*    DATE-BREAK MAY BE PROPERLY CONVERTED TO JULIAN. IF THE DATE\n003690*    FAILS THE VALIDATION, 'YES' IS MOVED TO INVALID-INPUT-DATE.\n003700*\n003710*\n003720 15700-VALIDATE-DATE.\n003730     IF DATE-BREAK  OF  INPUT-DATE-VALIDATION  NOT NUMERIC\n003740         GO TO 15788-REJECT-DATE.\n003750\n003760     IF TEST-DATE-BREAK IS EQUAL TO '022900'\n003770         GO TO 15788-REJECT-DATE.\n003780\n003790     IF MONTH-TEST  OF  INPUT-DATE-VALIDATION\n003800        IS LESS THAN 01 OR GREATER THAN 12\n003810           GO TO 15788-REJECT-DATE.\n003820\n003830     IF DAYY        OF  INPUT-DATE-VALIDATION\n003840        IS LESS THAN 01 OR GREATER THAN 31\n003850           GO TO 15788-REJECT-DATE.\n003860\n003870     IF MONTH-TEST  OF  INPUT-DATE-VALIDATION\n003880             EQUAL TO 01\n003890          OR EQUAL TO 03\n003900          OR EQUAL TO 05\n003910          OR EQUAL TO 07\n003920          OR EQUAL TO 08\n003930          OR EQUAL TO 10\n003940          OR EQUAL TO 12\n003950                 GO TO 15799-EXIT-VALIDATE-DATE.\n003960\n003970     IF MONTH-TEST  OF  INPUT-DATE-VALIDATION\n003980        EQUAL TO 02\n003990           GO TO 15760-FEBRUARY-TEST.\n004000\n004010     IF DAYY        OF  INPUT-DATE-VALIDATION\n004020        GREATER THAN 30\n004030           GO TO 15788-REJECT-DATE.\n004040\n004050     GO TO 15799-EXIT-VALIDATE-DATE.\n004060\n004070 15760-FEBRUARY-TEST.\n004080     MOVE ZERO TO QUOTENTS      OF CALCULATE-RESULTS\n004090                  QUOT-REMAIN   OF CALCULATE-RESULTS\n004100                  QUOT-NUM      OF CALCULATE-RESULTS.\n004110     COMPUTE QUOTENTS = YEAR-CHECK / 04.\n004120\n004130     IF QUOT-REMAIN NOT EQUAL TO ZERO\n004140        THEN\n004150             IF DAYY OF INPUT-DATE-VALIDATION GREATER THAN 28\n004160                GO TO 15788-REJECT-DATE.\n004170\n004180     IF QUOT-REMAIN EQUAL TO ZERO\n004190        THEN\n004200             IF DAYY OF INPUT-DATE-VALIDATION GREATER THAN  29\n004210                GO TO 15788-REJECT-DATE.\n004220\n004230     GO TO 15799-EXIT-VALIDATE-DATE.\n004240\n004250 15788-REJECT-DATE.\n004260     MOVE 'YES' TO INVALID-INPUT-DATE OF STOJCONV-I-O-AREA.\n004270\n004280 15799-EXIT-VALIDATE-DATE.\n004290     EXIT.\n004300\n004310 99999-GOBACK.\n004320     GOBACK.\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "SUBEX": {"ttr": 35849, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x00\\x7f\\x00\\x88\\x00\\x7f\\x12\\x00\\x00C\\x00C\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf2\\xf7\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-01-07T00:00:00", "modifydate": "1988-01-07T12:00:00", "lines": 67, "newlines": 67, "modlines": 0, "user": "FILE270"}, "text": "*          DATA SET 761KKSUBEX AT LEVEL 001 AS OF 10/04/83\n         REGEQU\n         TITLE 'PARSE SUBROUTINE  TO SAVE LEN AND DATA FOR A SUBFIELD'\nSUBEX    CSECT\n         SAVE  (14,12),,SUBEX-V1M0\n         LR    R12,R15            R12->SUBEX\n         USING SUBEX,R12\n         LR    R11,R1             R11->SUBSECT\n         USING SUBSECT,R11\n         LR    R9,R13             R9->OLD SAVE\n         L     R13,SUBWP          R13->NEW SAVE\n         USING SUBWORK,R13\n         ST    R9,SAVE+4\n         ST    R13,8(,R9)\n         L     R10,BPPLP          R10->BPPL\n         USING BPPL,R10\n         EJECT\n         L     R7,OPDESCP         R7->OPER DESCRIPTOR\n         L     R7,4(,R7)\n         L     R7,4(,R7)          R7=SUBFIELD OFFSET\n         L     R6,0(,R11)         R6->USER WORKAREA\n         LA    R7,0(R6,R7)        R7->SUBFIELD AREA\n         LH    R2,0(,R7)          R2=LENGTH OF AREA\n         SH    R2,=H'2'           R2-2 FOR MVI AND EX\n         BNP   NOFILL             NO LENGTH TO FILL\n         MVI   2(R7),C' '         A BLANK\nKMVC1    MVC   3(0,R7),2(R7)      BLANK FILLER\n         EX    R2,KMVC1           FILL IT\n*\nNOFILL   L     R9,SUBPTR          R9->SUBFIELD\n         LTR   R9,R9              ANY?\n         BZ    SETERR             NONE\n*\n         L     R8,SUBLENPT        R8->LENGTH OF SUBFIELD\n         LH    R8,0(,R8)          R8=LEN\n         LTR   R8,R8              >0?\n         BNP   SETERR             NO\n         SH    R8,=H'3'           -3 FOR EX\n         BM    SETERR             OOPS\nSFM      MVC   2(0,R7),1(R9)      EXED MVC\n         EX    R8,SFM             MOVE THE DATA\n         LA    R8,1(,R8)          R8+1\n         STH   R8,0(,R7)          PASS DATA LENGTH\n         EJECT\nSUBXX    SLR   R15,R15            RC=0\nSUBX2    L     13,SAVE+4\n         RETURN (14,12),RC=(15)\n         BR    R14\n         SPACE 3\nSETERR   MVC   0(2,R7),=H'-1'\n         B     SUBXX\n         SPACE 3\n         LTORG\n         EJECT\nSUBWORK  DSECT\nSAVE     DS    18F\nSUBFLG   DS    F\nSUBSECT  DSECT\nXP1      DS    F                  UNKN EXIT PARM\nBPPLP    DS    F                  PTR TO BPPL\nWORKP    DS    F                  PTR TO KMDPARS WORKAREA\n*\nSUBOL    DS    F                  PTR TO SUBWD OPLIST\nSUBWP    DS    F                  PTR TO SUB WORKAREA\nTUX      DS    F                  PTR TO TRUE UNKN EXIT\n         BPPL  DSECT\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "SUPRASM": {"ttr": 35851, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x98)\\x9f\\x00\\x98)\\x9f\\x12@\\x00\\x1f\\x00\\x1f\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf2\\xf7\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1998-10-26T00:00:00", "modifydate": "1998-10-26T12:40:00", "lines": 31, "newlines": 31, "modlines": 0, "user": "FILE270"}, "text": "//JOBCARD HERE...\n//*\n//*     ASM LINKEDIT FROM SOURCE ASM\n//*\n//ASMH EXEC PGM=ASMA90,PARM=(BATCH,OBJECT,NODECK,NOESD,NORLD,TEST)\n//SYSLIB   DD DISP=SHR,DSN=SYS1.MACLIB\n//         DD DISP=SHR,DSN=SYS1.MODGEN\n//         DD DISP=SHR,DSN=CBT.CBT418.FILE270.MACLIB\n//SYSIN    DD DISP=SHR,DSN=CBT.CBT418.FILE270.PDS(SUPRNAME)\n//         DD DISP=SHR,DSN=CBT.CBT418.FILE270.PDS(KMDPARS)\n//         DD DISP=SHR,DSN=CBT.CBT418.FILE270.PDS(KEYEX)\n//         DD DISP=SHR,DSN=CBT.CBT418.FILE270.PDS(OPERSCAN)\n//SYSUT1   DD UNIT=VIO,SPACE=(CYL,2)\n//SYSPRINT DD SYSOUT=*\n//SYSLIN   DD UNIT=VIO,SPACE=(TRK,1),DISP=(,PASS),DCB=BLKSIZE=3200,\n//            DSN=&&TEMP\n//*\n//LKED   EXEC  PGM=HEWLKED,\n//       PARM='TEST,NCAL,MAP,LIST,LET'\n//SYSUT1   DD  UNIT=SYSDA,SPACE=(2048,(200,20))\n//SYSPRINT DD  SYSOUT=*\n//SYSLIB   DD  DISP=SHR,DSN=IBMUSER.LOAD\n//SYSLMOD  DD  DISP=SHR,DSN=IBMUSER.LOAD\n//OBJECT   DD  DISP=(OLD,DELETE),DSN=&&TEMP\n//SYSLIN   DD  *\n INCLUDE OBJECT\n ENTRY   SUPRNAME\n SETCODE AC(1)\n NAME    SUPRNAME(R)\n/*\n\u001a\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "SUPRJCL": {"ttr": 35853, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x98)\\x9f\\x00\\x98)\\x9f\\x12A\\x00\\x1b\\x00\\x1b\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf2\\xf7\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1998-10-26T00:00:00", "modifydate": "1998-10-26T12:41:00", "lines": 27, "newlines": 27, "modlines": 0, "user": "FILE270"}, "text": "//JOBCARD HERE...\n//*\n//DOIT  EXEC PGM=SUPRNAME\n//STEPLIB DD DISP=SHR,DSN=IBMUSER.LOAD\n//SYSPRINT DD SYSOUT=*\n//SYSUDUMP DD SYSOUT=*\n//SYSUT1 DD DISP=(,DELETE),SPACE=(TRK,(1,1)),\n// DCB=(RECFM=FB,LRECL=80,BLKSIZE=80),UNIT=SYSALLDA\n//SYSLIB DD DISP=SHR,DSN=FORMAT4.DSCB,DCB=KEYLEN=44,\n// UNIT=SYSALLDA,VOL=SER=VVVVVV <=== PLACE CORRECT VOLSER HERE\n//*\n//*       RENAME DSNAME=ANY.OLD.NAME\n//*              NEWNAME=ANY.NEW.NAME\n//*\n//*       DELETE DSNAME=ANY.OTHER.NAME\n//*              OR\n//*       SCRATCH DSNAME=ANY.OTHER.NAME\n//*\n//*       ABSDUMP  DSNAME=ANY.NEW.NAME\n//*              OR\n//*       ABSDUMPT DSNAME=ANY.NEW.NAME\n//*\n//*       CCHHR  DSNAME=ANY.NEW.NAME\n//*        VER 00 C1\n//*        REP 00 C2\n//SYSIN DD *\n  ABSDUMP DSNAME=SYS1.PARMLIB\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "SUPRNAM$": {"ttr": 36097, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x00\\x7f\\x00\\x88\\x00\\x7f\\x12\\x00\\x00^\\x00^\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf2\\xf7\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-01-07T00:00:00", "modifydate": "1988-01-07T12:00:00", "lines": 94, "newlines": 94, "modlines": 0, "user": "FILE270"}, "text": "1 10.000\n-                                                         SUPRNAME\n\n         The SUPRNAME program is a frontend processor to SUPERZAP\n which adds some new control cards to the SUPERZAP vanilla cards.\n It allows a dataset to be renamed or scratched with no ENQ contention\n even if the dataset name is allocated to another job. It also allows\n a format one DSCB to be dumped or zapped without knowing the CCHHR\n address in the VTOC.\n\n         *** Warning *** If you do a rename or zap which\n alters the DSNAME of a dataset on an Indexed Vtoc volume, the index\n may not be correct. To insure correctness of the index, use the second\n JCL sample job listed below which will update the Index with operator\n permisssion.\n\n         A control card with ABSDUMPT DSNAME=dsn  or CCHHR DSNAME=dsn\n will have the DSNAME=dsn replaced with the correct CCHHR value for\n the format one DSCB of that dsn.\n\n         The source for this program can be found in PANSPACE as:\n                     761KKSUPRN\n\n SAMPLE JCL and control cards: (may be copied from this document)\n\n //*\n //* update the volser on the SYSLIB card before submitting\n //*\n //S1  EXEC PGM=SUPRNAME\n //STEPLIB DD DISP=SHR,DSN=WDPSC.PROGLIB\n //SYSPRINT DD SYSOUT=*\n //SYSUDUMP DD SYSOUT=*\n //SYSUT1 DD DISP=(,DELETE),SPACE=(TRK,(1,1)),\n // DCB=(RECFM=FB,LRECL=80,BLKSIZE=80),UNIT=SYSSQ\n //SYSLIB DD DISP=SHR,DSN=FORMAT4.DSCB,DCB=KEYLEN=44,\n // UNIT=SYSALLDA,VOL=SER=SYS018 <=== place correct volser here\n //SYSIN DD *\n\n  RENAME DSNAME=ANY.OLD.NAME\n         NEWNAME=ANY.NEW.NAME\n\n  DELETE DSNAME=ANY.OTHER.NAME\n         or\n  SCRATCH DSNAME=ANY.OTHER.NAME\n\n  ABSDUMP  DSNAME=ANY.NEW.NAME\n         or\n  ABSDUMPT DSNAME=ANY.NEW.NAME\n\n  CCHHR  DSNAME=ANY.NEW.NAME\n   VER 00 C1\n   REP 00 C2\n1\n SAMPLE JCL and control cards for indexed vtoc case:\n         (use if altering a dsname on an indexed vtoc)\n\n //*\n //* do a change all SYS007 to the desired volser before submitting\n //*\n /*JOBPARM S=K1K1\n //*\n //*    NOTE!!!!! THIS WILL ASK OPERS FOR 2 REPLYS ****************\n //*\n //* INVOKE THE DEVICE SUPPORT FACILITY PROGRAM\n //*\n //*            CONVERT IXVTOC TO OSVTOC:\n //*\n //S1    EXEC PGM=ICKDSF,TIME=20\n //SYSPRINT  DD SYSOUT=*\n //VSYS007 DD VOL=SER=SYS007,UNIT=SYSALLDA,DISP=SHR,\n //   DSN=SYS1.VTOCIX.VSYS007\n    BUILDIX DDNAME(VSYS007) OSVTOC\n //*\n //*            CALL SUPRNAME TO MODIFY THE VTOC:\n //*\n //S1  EXEC PGM=SUPRNAME\n //STEPLIB DD DISP=SHR,DSN=WDPSC.PROGLIB\n //SYSPRINT DD SYSOUT=*\n //SYSUDUMP DD SYSOUT=*\n //SYSUT1 DD DISP=(,DELETE),SPACE=(TRK,(1,1)),\n // DCB=(RECFM=FB,LRECL=80,BLKSIZE=80),UNIT=SYSSQ\n //SYSLIB DD DISP=SHR,DSN=FORMAT4.DSCB,DCB=KEYLEN=44,\n // UNIT=SYSALLDA,VOL=SER=SYS007\n //SYSIN DD *\n     RENAME DSNAME=WDPSC.ISPF.SKELS2\n           NEWNAME=WDPSC.ISPF.SKELS\n //*\n //*        REBUILD INDEXED VTOC:\n //*\n //START EXEC PGM=ICKDSF,TIME=20\n //SYSPRINT  DD SYSOUT=*\n //VSYS007 DD VOL=SER=SYS007,UNIT=SYSALLDA,DISP=OLD,\n //   DSN=SYS1.VTOCIX.VSYS007\n    BUILDIX DDNAME(VSYS007) IXVTOC\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "SUPRNAME": {"ttr": 36100, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x01\\x00\\x00\\x00\\x88\\x00\\x7f\\x00\\x98)\\x9f\\x12'\\x02'\\x02#\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf2\\xf7\\xf0@@@\"", "ispf": {"version": "01.01", "flags": 0, "createdate": "1988-01-07T00:00:00", "modifydate": "1998-10-26T12:27:00", "lines": 551, "newlines": 547, "modlines": 0, "user": "FILE270"}, "text": "*\n*   @OK - ADJUSTED TO INVOKE COMPATIBLE LEVEL OF COMMAND PARSE MACRO\n*         10/26/98\n*\n*          DATA SET 761KKSUPRN AT LEVEL 001 AS OF 08/30/82\n*\n*  AUTHOR - KERMIT KISER - WASHINGTON STATE DP SERVICE CENTER (WDPSC)\n*\nSUPRNAME ENTERR LEVEL=V3M0\n         LR    R11,R1             R11->PARM LIST\n         SLR   R15,R15            R15=0\n         EJECT\n*\n*        MAINLINE ROUTINE:\n*\n         BAL   R14,INIT           OPEN CONTROL AND MESSAGE FILES\n         BXH   R15,R15,MX         STOP IF FATAL ERROR\n*\n         BAL   R14,PROCNTL        PROCESS ALL REQUESTS\n*\nEODAD    LR    R11,R15            SAVE RC\n         BAL   R14,EOD            CLOSE UP ALL OPEN FILES\n*\n         BAL   R14,SZAP           INVOKE SUPERZAP IF REQUESTED\n*\n         BAL   R14,TERM           DO ANY NEEDED CLEANUP\n*\n         LR    R15,R11            RESTORE RC\n*\n         EJECT\n*\n*        CODE  TO LEAVE SUPRNAME:\n*\nMX       LEAVER\n         EJECT\n*                                 INITIALIZE FILES:\n*\nINIT     ST    R14,L1LS\n*\n         OPEN  (CTLCD,INPUT,MSGDCB,OUTPUT,UT1,OUTPUT)\n         TM    MSGDCB+48,X'10'    MSG FILE OK?\n         BO    MOK                YES\n         ABEND 88                 NO\nMOK      LA    R1,OKM             R1->SUPRNAME IDENT MSG\n         BAL   R14,PUTMSGV        PRINT\n         B     CIF\nOKM      DC    AL2(L'OKMD)\nOKMD     DC    C'1 *** SUPRNAME - DSCB UTILITY - WDPSC VERSION 3.0 '\nCIF      TM    CTLCD+48,X'10'     INPUT FILE OPEN?\n         BO    IOK                YES\n         LA    R1,IOEM            R1->ERR1 MSG\n         BAL   R14,PUTMSGV        TELL\n         LA    R15,44             RC=44\n         B     IX\nIOEM     DC    AL2(L'IOEMD)\nIOEMD    DC    C'2CONTROL FILE CAN NOT BE OPENED. SUPRNAME TERMINATED.'\nIOK      OI    CTLF,X'FF'\n         OI    MSGF,X'FF'\n         TM    UT1+48,X'10'       SYSUT1 OPEN?\n         BNO   GETSER             NO->MAY BE OK\n         OI    UT1F,X'FF'\n*\nGETSER   RDJFCB (VTOCDCB)\n         BXH   R15,R15,IX         EXIT IF CAN'T DO\n         MVC   VOLSER(6),JFCBA+118      GET VOLSER\n*\nIX       L     R14,L1LS\n         BR    R14                EXIT\n         EJECT\nCTLCD    DCB   DDNAME=SYSIN,DSORG=PS,EODAD=EODAD,MACRF=(GM),LRECL=80\nMSGDCB   DCB   DDNAME=SYSPRINT,DSORG=PS,MACRF=(PM),LRECL=133,RECFM=FA\nUT1      DCB   DDNAME=SYSUT1,DSORG=PS,MACRF=(PM),LRECL=80,RECFM=F\nDCBEXITS DC    0F'0',X'87',AL3(JFCBA)\nJFCBA    DS    0F,176X\nVTOCDCB  DCB   DSORG=PSU,DDNAME=SYSLIB,EXLST=DCBEXITS,                 X\n               MACRF=E,RECFM=U,KEYLEN=44\n         EJECT\n*\n*              SUBRTN TO PROCESS  CONTROL CARD REQUESTS:\n*\n*\nPROCNTL  ST    R14,L1LS\n*\nPROLOOP  BAL   R14,READPARS       GET CONTROL CARD\n         BXH   R15,R15,PX         EXIT IF CAN'T DO\n*\n         BAL   R14,PENDCLR        DO ANY REQUESTS COMPLETE\n         BXH   R15,R15,PX         EXIT IF CAN'T DO\n*\n         B     PROLOOP\n*\nPX       L     R14,L1LS\n         BR    R14                EXIT\n*\n         EJECT\n*\n*              SUBRTN TO CLOSE ANY OPEN FILES:\n*\n*\nEOD      ST    R14,L1LS\n*\n         TM    CTLF,X'FF'         CTL FILE OPEN?\n         BZ    NDCK               NO\n         CLOSE (CTLCD)\n*\nNDCK     TM    VDCBF,X'FF'        VTOC OPEN?\n         BZ    UTCK               NO\n         CLOSE (VTOCDCB)\n*\nUTCK     TM    UT1F,X'FF'         UT1  OPEN?\n         BZ    EODX               NO\n         CLOSE (UT1)\n*\n*\nEODX     L     R14,L1LS\n         BR    R14                EXIT\n         EJECT\n*\n*              SUBRTN TO CALL SUPERZAP IF REQUESTED:\n*\n*\nSZAP     ST    R14,L1LS\n*\n         TM    ZAPF,X'FF'         ZAP NEEDED?\n         BZR   R14                NO\n*\n         LINK  EP=AMASPZAP,PARAM=(OPTS,DDNAMES),VL=1\n*\nSZX      L     R14,L1LS\n         BR    R14                EXIT\n*\n*              SUBRTN TO CLEANUP ANYTHING NEEDED:\n*\nTERM     ST    R14,L1LS\n*\n         LA    R1,TMSG\n         BAL   R14,PUTMSGV\n*\n         TM    MSGF,X'FF'         MSG FILE OPEN?\n         BZ    TERMX              NO\n         CLOSE (MSGDCB)\n*\nTERMX    L     R14,L1LS\n         BR    R14\n*\nTMSG     DC    AL2(L'TMSGD)\nTMSGD    DC    C'1*** SUPRNAME PROCESSING COMPLETED. ***'\n         EJECT\n*\n*              SUBRTN TO READ A CARD AND PARSE IT:\n*\nREADPARS ST    R14,L2LS\n*\n         MVC   CMD(133),=CL133' ' CLEAR\n         LA    R1,CMDAREA+4\n         BAL   R14,PUTMSG\n*\n         GET   CTLCD,CMDAREA+5\n*\n         MVC   CMDAREA(4),=H'72,0'\n         LA    R14,CMDAREA        R14->CMD\n         ST    R14,CMDPTR         PASS TO PARSE\n*\n         LA    R1,CMDAREA+4\n         BAL   R14,PUTMSG\n         EJECT\n         PARSKMD CBUF=CMDPTR,EXIT=UNKNEX,FLAG=NFLAG,PARM=UNKNFLAG,     X\n               WORK=FASTAREA,KEYLIST=KEYLIST,KEYWORK=KEYWORK        @OK\n*\n         L     R14,L2LS\n         BR    R14\n         SPACE 3\nUNKNEX   L     R1,0(,R1)\n         OI    0(R1),X'FF'\n         SLR   R15,R15\n         BR    R14\n         EJECT\nPENDCLR  ST    R14,L2LS\n*\n         CLI   CMDAREA+4,C'*'     COMMENT CARD?\n         BNE   NEWCHK             NO\n         LA    R1,CMDAREA+4       R1->CARD\n         BAL   R14,PUTUT1         WRITE IT\n         B     PCX\nNEWCHK   TM    NFLAG,X'FF'        NEW REQUEST?\n         BNZ   CLRCHK             YES\n         TM    KEYFLG,X'FF'       JUST KEYWORDS?\n         BZ    CLRCHK             NO->UNKN OP MAYBE\n         B     CHECKDO\nPCX      MVI   UNKNFLAG,X'00'     RESET UNKNS\n         L     R14,L2LS\n         BR    R14\nCLRCHK   TM    FLAG,X'FF'         ANY PENDING?\n         BZ    CHECKDO            NO->WE ARE OK\n         LA    R1,LERR1           R1->ERROR MSG\n         BAL   R14,PUTMSGV\n         LA    R15,100\n         MVI   ZAPF,X'00'         SAY NO SZAP\n         B     PCX\nLERR1    DC    AL2(L'LERR1M)\nLERR1M   DC    C' NEW OPERATION FOUND BEFORE PREVIOUS COMPLETED.   -----\n                   SUPRNAME TERMINATED.'\n*\nCHECKDO  OC    FLAG(4),NFLAG      SAVE FLAGS\n         XC    NFLAG(4),NFLAG     CLR  FLAGS\n         OC    KEYFLGS(4),KEYFLG  SAVE KEYWD FLAGS\n         XC    KEYFLG(4),KEYFLG   CLEAR FLAG\n         TM    FLAG,X'80'         RENAME OP?\n         BZ    CD2                NO\n         BAL   R14,RENAME         DO IT\n         B     PCX\nCD2      TM    FLAG,X'40'         CCHHR  OP?\n         BZ    CD3                NO\n         BAL   R14,CCHHR          DO IT\n         B     PCX\nCD3      TM    FLAG,X'30'         ABSDUMP OP?\n         BZ    CD5                NO\n         BAL   R14,ABSDUMP        DO IT\n         B     PCX\nCD5      TM    FLAG,X'08'         DELETE  OP?\n         BZ    CD4                NO\n         BAL   R14,DELETE         DO IT\n         B     PCX\nCD4      LA    R1,CMDAREA+4       R1->CARD\n         BAL   R14,PUTUT1         WRITE IT\n         B     PCX\n         EJECT\n         EJECT\nABSDUMP  EQU   *\nCCHHR    ST    R14,L3LS\n         TM    UNKNFLAG,X'FF'     UNKNOWN OPERANDS PRESENT?\n         BZ    MINE\n         MVI   UNKNFLAG,X'00'     RESET FLAG\n         B     JUSTRITE           WRITE THE RECORD TO ZAP ASIS\nMINE     TM    KEYFLGS,X'80'      OLDNAME GIVEN?\n         BNOR  R14                NO->WAIT FOR IT\n         BAL   R14,GETCCHHR       GET CCHHR FOR IT\n         BXH   R15,R15,CX         DSCB FOUND?\n         UNPK  AAC(11),AAH(6)     UNPACK THE CCHHR\n         TR    AAC(10),HTCTAB     MAKE IT CHARACTER\n         MVC   CMD(80),=CL133' '  BLANK FILL\n         SLR   R3,R3              R3=0\n         IC    R3,FLAG            R3=OPCODE\n         SRL   R3,4               R3=OP#\n         BCTR  R3,R0              R3-1 OFFSET\n         MH    R3,=H'10'          R3*10\n         LA    R3,OPTAB(R3)       R3->OP NAME\n         MVC   CMD+1(10),0(R3)    FTN NAME (CCHHR,ABSDUMPT,ABSDUMP)\n         MVC   CMDAREA+15(10),AAC PUT IN ADDR OF DSCB\n         TM    FLAG,X'30'         ABSDUMP?\n         BZ    JUSTRITE           NO\n         MVC   CMDAREA+27(10),AAC PUT IN ADDR OF DSCB\nJUSTRITE LA    R1,CMDAREA+4\n         BAL   R14,PUTUT1         WRITE TO SZAP\n         LA    R1,CMDAREA+4\n         BAL   R14,PUTMSG         WRITE TO PRINT\n         XC    FLAG,FLAG          CLEAR THE FLAGS\n         XC    KEYFLGS,KEYFLGS    CLEAR THE FLAGS\nCX       L     R14,L3LS\n         BR    R14\n*\nOPTAB    DC    CL10'ABSDUMPT'\n         DC    CL10'ABSDUMP'\n         DC    CL10'DUMMY'\n         DC    CL10'CCHHR'\n         EJECT\n*\nRENAME   ST    R14,L4LS\n         TM    KEYFLGS,X'C0'      OLDNAME AND NEWNAME\n         BNOR  R14                NO->WAIT FOR\n         BAL   R14,GETCCHHR       FIND THE DSCB\n         BXH   R15,R15,RX         FOUND?\n*\n         BAL   R14,OPENVTOC       OVEN THE VTOC\n         BXH   R15,R15,RX         OK?\n*\n         BAL   R14,CHDSCB         MODIFY THE DSCB\n         BXH   R15,R15,RX         OK?\n*\n         LA    R1,RNM             R1->RENAME OK MSG\n         BAL   R14,PUTMSGV        WRITE TO PRINT\n         XC    FLAG,FLAG          CLEAR THE FLAGS\n         XC    KEYFLGS,KEYFLGS    CLEAR THE FLAGS\nRX       L     R14,L4LS\n         BR    R14\n*\nRNM      DC    AL2(L'RNMD)\nRNMD     DC    C' RENAME COMPLETED.'\n         EJECT\n*\nGETCCHHR ST    R14,L5LS\n         OBTAIN ODLST             GET CCHHR FOR IT\n         LTR   R15,R15            DSCB FOUND?\n         BNZ   DSCBNF             NO->TELL AND STOP\n         XC    MBBCCHHR,MBBCCHHR\n         MVC   MBBCCHHR+3(5),AAH  SAVE CCHHR\nGAX      L     R14,L5LS\n         BR    R14\n*\nDSCBNF   LA    R1,NFERR           R1->ERR MSG\n         BAL   R14,PUTMSGV        WRITE TO USER\n         LA    R15,200            SAY BAD DEAL\n         MVI   ZAPF,X'00'         SAY NO CAN SZAP\n         B     GAX                TERMINATE\nNFERR    DC    AL2(L'NFERRM)\nNFERRM   DC    C' DSCB NOT FOUND - SUPRNAME TERMINATED.'\n         EJECT\n*\n*\nOPENVTOC ST    R14,L5LS\n         TM    VTOCDCB+48,X'10'   VTOC OPEN?\n         BOR   R14                YES\n*\n         RDJFCB (VTOCDCB)\n         BXH   R15,R15,VOERR      EXIT IF CAN'T DO\n         MVC   VOLSER(6),JFCBA+118      GET VOLSER\n         MVI   JFCBA,X'04'        VTOC\n         MVC   JFCBA+1(43),JFCBA  \"\n         OPEN  (VTOCDCB,(INOUT)),TYPE=J\n         TM    VTOCDCB+48,X'10'   OK?\n         BNO   VOERR              NO\n*\n         L     R1,540             R1->TCB\n         L     R1,12(,R1)         R1->TIOT\n         LH    R14,VTOCDCB+40     R14=TIOT OFFSET\n         LA    R1,16(R1,R14)      R1->TIOT UCB FLD\n         L     R1,0(,R1)          R1->UCB FOR VTOC\n         MVC   SDT(4),16(R1)      SAVE DEVTYPE FOR SCRATCH\n*\nOVX      L     R14,L5LS\n         BR    R14\nVOERR    LA    R1,VOEM\n         BAL   R14,PUTMSGV\n         LA    R15,99\n         B     OVX\nVOEM     DC    AL2(L'VOEMM)\nVOEMM    DC    C' CANNOT OPEN VTOC'\n*\n         EJECT\nCHDSCB   ST    R14,L5LS\n*\n         ENQ   (SYSVTOC,VOLSER,E,6,SYSTEMS),RET=HAVE\n*\n         XDAP  VECB1,RI,VTOCDCB,DSCBA,140,,MBBCCHHR,MF=E\n*\n         WAIT  ECB=VECB1\n*\n         CLC   OLDNAME+4(44),DSCBA\n         BNE   RE1\n         MVC   DSCBA(44),NEWNAME+4\n         EJECT\n         XDAP  VECB2,WI,VTOCDCB,DSCBA,140,,MBBCCHHR,MF=E\n*\n         WAIT  ECB=VECB2\n*\n         DEQ   (SYSVTOC,VOLSER,6,SYSTEMS),RET=HAVE\n*\n         CLI   VECB2,X'7F'        IO OK?\n         BE    CDX                YES\n         DC    H'0',C'EXCP OUTPUT ERROR'\n*\nCDX      L     R14,L5LS\n         BR    R14\n*\nRE1      LA    R1,DRE1\n         BAL   R14,PUTMSGV\n         LA    R15,77\n         B     CDX\nDRE1     DC    AL2(L'DREM)\nDREM     DC    C' DSCB IO ERROR'\n         DS    0F\n         EJECT\n         XDAP  VECB1,RI,MF=L\n         XDAP  VECB2,WI,MF=L\n         EJECT\nDELETE   ST    R14,L3LS\n         TM    KEYFLGS,X'80'      OLDNAME\n         BNOR  R14                NO->WAIT FOR\n         SPACE\n*              CREATE A TEMPORARY DATASET NAME:\n         TIME\n         ST    R0,TOD1            TIME\n         ST    R1,DATE1           DATE\n         UNPK TOD2(9),TOD1(5)\n         UNPK DATE2(8),DATE1(4)\n         MVC   TOD3(7),TOD2\n         MVC   DATE3(7),DATE2+1\n         MVC   NEWNAME+4(44),SDSN\n         MVC   NEWNAME+2(2),=AL2(SDL)\n         OI    KEYFLGS,X'40'      SAY NEWNAME READY\n         SPACE\n         LA    R1,SMSG\n         BAL   R14,PUTMSGV        WRITE FOR TRACE\n         SPACE\n         BAL   R14,RENAME         RENAME DS TO TEMPNAME\n         BXH   R15,R15,DX         OK?\n         EJECT\n         SLR   R0,R0\n         SCRATCH TEMPDSN\n         BXH   R15,R15,BADSCR\n         LA    R1,SOKM            R1->SCRATCH OK MESSAGE\n         BAL   R14,PUTMSGV        TELL EM\n         B     DXOK\nBADSCR   LA    R1,SNOK            R1->BAD SCR MSG\n         BAL   R14,PUTMSGV\n         B     DX\nSOKM     DC    AL2(L'SOKMD)\nSOKMD    DC    C' DATASET SCRATCHED.'\nSNOK     DC    AL2(L'SNOKD)\nSNOKD    DC    C' ERROR: DATASET NOT SCRATCHED. SUPRNAME TERMINATED.'\nDXOK     XC    FLAG,FLAG          CLEAR THE FLAGS\n         XC    KEYFLGS,KEYFLGS    CLEAR THE FLAGS\nDX       L     R14,L3LS\n         BR    R14\n*\nTEMPDSN  CAMLST SCRATCH,SDSN,,SVOL,,OVRD\nTOD1     DS    F\n         DS    H\nTOD2     DS    D\n         DS    H\nDATE1    DS    F\nDATE2    DS    D\nSMSG     DC    AL2(44+L'SMD)\nSMD      DC    C' TEMPNAME IS ->'\nSDSN     DC    C'WIZRD150.SUPRNAME.SCRATCH.D'\nDATE3    DC    CL7' '\n         DC    C'.T'\nTOD3     DC    CL7' '\nSDL      EQU   *-SDSN\n         DC    CL(44-SDL)' '\n         EJECT\nPUTMSG   ST    R14,PMLS\n         LR    R2,R1\n         PUT   MSGDCB,(R2)\n         SLR   R15,R15\n         L     R14,PMLS\n         BR    R14\n         SPACE\nPUTMSGV  ST    R14,PVLS\n         MVI   OUTLINE,C' '\n         MVC   OUTLINE+1(132),OUTLINE\n         LH    R14,0(R1)          R14=MSG LEN\n         LA    R15,2(,R1)         R15->MSG DATA\n         BCTR  R14,R0             R14-1 FOR EX\nMM       MVC   OUTLINE(0),0(R15)\n         EX    R14,MM\n         PUT   MSGDCB,OUTLINE\n         SLR   R15,R15\n         L     R14,PVLS\n         BR    R14\n         SPACE 2\nPUTUT1   ST    R14,PULS\n*\n         TM    UT1F,X'FF'         OPEN?\n         BO    UOK                YES\n         LA    R1,UT1ERR          R1->ERR MSG\n         BAL   R14,PUTMSGV\n         LA    R15,66\n         B     PUX\nUT1ERR   DC    AL2(L'UT1ERRD)\nUT1ERRD  DC    C' ERROR: SYSUT1 DATASET NOT OPEN. SUPRNAME TERMINATED.'\nUOK      OI    ZAPF,X'FF'         SAY ZAP CALL NEEDED\n         LR    R2,R1\n         PUT   UT1,(R2)           WRITE ZAP RECORD\n         SLR   R15,R15\nPUX      L     R14,PULS\n         BR    R14\n         EJECT\n*\n*              STATIC WORK AREA:\n*\nSYSVTOC  DC    CL8'SYSVTOC'\nHTCTAB   EQU   *-240\n         DC    C'0123456789ABCDEF'\nODLST    CAMLST SEARCH,OLDNAME+4,VOLSER,ODAREA\nODAREA   DS    XL140\nAAH      EQU   ODAREA+96\nAAC      DC    CL20' '\n*\nL88      DC    H'88'\nHTC      DC    CL4'HTC'\n*\nSVOL     DC    H'1'\nSDT      DC    XL4'00'\nVOLSER   DS    CL6\nSCODE    DC    H'0'\n*\nPENDFLG  DS    F                  PENDING OP FLAG\nCMDPTR   DS    A\nFLAG     DC    F'0'\nNFLAG    DC    F'0'\nOPFLG    DC    F'0'\nKEYWORK  DS    0F\nKEYSAVE  DS    18F\nKEYFLG   DC    F'0'\nKEYFLGS  DC    F'0'\nOLDNAME  DC    H'44',H'0',CL44' '\nNEWNAME  DC    H'44',H'0',CL44' '\nHEXNAME  DC    CL88' '\nOPTS     DC    H'0'\nDDNAMES  DC    H'48'              6 NAME LIST\n         DC    3XL8'00'           3 DUMMY ENTS\n         DC    CL8'SYSLIB',CL8'SYSUT1',CL8'SYSPRINT'\n         EJECT\nOPLIST   OPERLIST OP1,OP2,OP3,OP4,OP5,OP6\nOP1      OPER  RENAME,X'8000'\nOP2      OPER  CCHHR,X'4000'\nOP3      OPER  ABSDUMP,X'2000'\nOP4      OPER  ABSDUMPT,X'1000'\nOP5      OPER  DELETE,X'0800'\nOP6      OPER  SCRATCH,X'0800'\n*\nKEYLIST  OPERLIST KEY1,KEY2\nKEY1     OPER  DSNAME,X'8000',KEYFLD=OLDNAME\nKEY2     OPER  NEWNAME,X'4000',KEYFLD=NEWNAME\n         LTORG\n         EJECT\nWORKAREA DSECT\nSAVEAREA DS    18F\nL1LS     DS    F\nL2LS     DS    F\nL3LS     DS    F\nL4LS     DS    F\nL5LS     DS    F\nL6LS     DS    F\nL7LS     DS    F\nPVLS     DS    F\nPMLS     DS    F\nPULS     DS    F\n*\nVDCBF    DS    X\nCTLF     DS    X\nMSGF     DS    X\nUT1F     DS    X\nZAPF     DS    X\nUNKNFLAG DS    X\n*\nMBBCCHHR DS    XL8\n*\nCMDAREA  DS    F,CL256            CMD BUF AREA\nCMD      EQU   CMDAREA+4\n*\nFASTAREA DS    XL600              PARSE WORKAREAS\nDSCBA    DS    200X\nOUTLINE  DS    CL133\n         EJECT\n         KPPL\n*\nWORKLEN  EQU   *-WORKAREA\n         BPPL  DSECT\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SYSOUT": {"ttr": 36355, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x00\\x7f\\x00\\x88\\x00\\x7f\\x12\\x00\\x06\\x07\\x06\\x07\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf2\\xf7\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-01-07T00:00:00", "modifydate": "1988-01-07T12:00:00", "lines": 1543, "newlines": 1543, "modlines": 0, "user": "FILE270"}, "text": "*\n*\n************\n*  SYSOUT  *\n************\n*\n*           THIS COMMAND IS USED TO DO DYNAMIC ALLOCATION AS FOLLOWS:\n*\n*           //DDNAME  DD  SYSOUT=(SYSOUT CLASS,,FORM NUMBER),\n*           //   DEST=DESTINATION,COPIES=NUMBER OF COPIES,\n*           //   FCB=FCB,FLASH=FLASH,MODIFY=COPYMOD,\n*           //   CHARS=CHARS,OPTCD=OPTCD\n*\n* ---------------------------------------------------------------------\n*  COMMAND  OPERANDS\n* ---------------------------------------------------------------------\n*  SYSOUT   DDNAME('DDNAME') SYSCLASS('SYSOUT CLASS') -\n*           FORM('FORM #') DEST('DESTINATION') COPIES('NO OF COPIES') -\n*           FCB('FCB') FLASH('FLASH NAME') CHARS('CHARS') -\n*           MODIFY('COPYMOD') OPTCD('OPTCD')\n* ---------------------------------------------------------------------\n*\n*\n*  OPERANDS -\n*\n*     REQUIRED -\n*\n*        DDNAME('DDNAME')         'DDNAME' IS THE DDNAME TO BE USED\n*\n*                                 DDNAME HAS THE FOLLOWING ALIAS:\n*                                        FILE\n*\n*        SYSCLASS('SYSOUT CLASS') 'SYSOUT CLASS' IS THE SYSOUT CLASS OF\n*                                 THE SYSOUT PARAMETER.  NORMALLY 'A',\n*                                 'B', OR 'J'\n*\n*                                 SYSCLASS HAS THE FOLLOWING 2 ALIASES:\n*                                        SYSOUT\n*                                        CLASS\n*\n*     OPTIONAL -\n*\n*\n*        FORM('FORM NUMBER')      'FORM NUMBER' IS THE FORM NUMBER OF\n*                                 THE SYSOUT PARAMETER TO BE USED\n*\n*        DEST('DESTINATION')      'DESTINATION' IS THE DESTINATION\n*                                 PARAMETER TO BE USED\n*\n*        COPIES('NUMBER OF COPIES')   'NUMBER OF COPIES' IS THE DESIRED\n*                                 NUMBER OF COPIES TO BE USED\n         EJECT\n*\n*\n*        FCB('FCB')               'FCB' IS THE 3800 FORMS CONTROL\n*                                    BUFFER TO USE\n*\n*        FLASH('FLASH NAME')      'FLASH NAME' IS THE NAME OF YOUR\n*                                    FORMS OVERLAY (IF THIS PARAMETER\n*                                    IS OMITTED, FORMS OVERLAY 'STD'\n*                                    WILL BE USED. REQUEST 'NULL' IF\n*                                    YOU DO NOT WANT ANY OVERLAY USED.)\n*\n*        CHARS('CHARS')           'CHARS' IS THE CHARACTER ARRANGEMENT\n*                                    TABLE(S) TO USE.  UP TO FOUR\n*                                    CHARACTER ARRANGEMENT TABLES\n*                                    MAY BE SPECIFIED\n*\n*                                      EXAMPLES:\n*\n*                                          CHARS(GS12)\n*\n*                                          CHARS(GS12,AD01)\n*\n*        MODIFY('COPYMOD')        'COPYMOD' IS THE COPY MODIFICATION\n*                                    MODULE TO BE USED. IT OPTIONALLY\n*                                    CAN INCLUDE A CHARS REFERENCE\n*                                    CHARACTER.  IF THIS CHARACTER IS\n*                                    A ZERO, THE FIRST CHARS NAME WILL\n*                                    BE USED IN THE MODIFICATION\n*                                    PROCESS.  IF THIS CHARACTER IS A\n*                                    ONE, THE SECOND CHARS NAME WILL\n*                                    BE USED, ETC.\n*\n*                                      EXAMPLES:\n*\n*                                           MODIFY(SC33)\n*\n*                                           MODIFY(SC33,2)\n*\n*        OPTCD('OPTCD')           'OPTCD' IF USED, CAN ONLY HAVE A\n*                                    VALUE OF 'J'. THIS INDICATES\n*                                    THAT THE SECOND CHARACTER OF\n*                                    EVERY PRINT LINE WILL CONTAIN\n*                                    A CHARS REFERENCE CHARACTER.\n         EJECT\n*\n*\n*        THIS COMMAND WILL ALSO MAKE AVAILABLE TWO VARIABLES THAT AN\n*        INVOKING CLIST MAY INTERROGATE.  BELOW IS A TABLE OF VALUES\n*        AFTER EXECUTION OF THIS COMMAND FOR THESE TWO VARIABLES\n*        &OUTMSG AND &LASTCC (RETURN CODE)\n*\n*        |---------|------------------------------------------------|\n*        | &LASTCC | &OUTMSG                                        |\n*        |---------|------------------------------------------------|\n*        |    0    | SUCCESSFUL COMPLETION                          |\n*        |---------|------------------------------------------------|\n*        |    4    | DDNAME PARAMETER MISSING                       |\n*        |---------|------------------------------------------------|\n*        |    8    | DYNAMIC DEALLOC ERROR (ERR REASON CODE = XXXX) |\n*        |---------|------------------------------------------------|\n*        |    12   | SYSOUT CLASS PARAMETER MISSING                 |\n*        |---------|------------------------------------------------|\n*        |    16   | INVALID FORM NUMBER                            |\n*        |---------|------------------------------------------------|\n*        |    20   | INVALID DESTINATION                            |\n*        |---------|------------------------------------------------|\n*        |    24   | DYNAMIC ALLOC ERROR (ERR REASON CODE = XXXX)   |\n*        |---------|------------------------------------------------|\n*        |    28   | INVALID NUMBER OF COPIES SPECIFIED             |\n*        |---------|------------------------------------------------|\n*        |    32   | INVALID SYSOUT CLASS                           |\n*        |---------|------------------------------------------------|\n*        |    36   | INVALID FCB                                    |\n*        |---------|------------------------------------------------|\n*        |    40   | INVALID FLASH NAME                             |\n*        |---------|------------------------------------------------|\n*        |    44   | INVALID OPTCD                                  |\n*        |---------|------------------------------------------------|\n*        |    48   | INVALID CHARS PARAMETER                        |\n*        |---------|------------------------------------------------|\n*        |    52   | INVALID MODIFY PARAMETER                       |\n*        |---------|------------------------------------------------|\n*        |    96   | INVALID SYNTAX OF ONE OR MORE OPERANDS         |\n*        |---------|------------------------------------------------|\n*\n         EJECT\nSYSOUT   ENTERR\n         LA    R3,BASEREG2   R3 IS TO BE THE SECOND BASE REGISTER\n         USING BASEREG2,R3\n         EJECT\n********************************************************************\n*                                                                  *\n*      M A I N   L I N E   L O G I C   F O R   S Y S O U T P       *\n*                                                                  *\n********************************************************************\n*\n         LR    R11,R1              SAVE THE PARM POINTER\n         LA    R4,0                R4==> 0\n         BAL   R14,DOPARSE         PERFORM THE PARSE SERVICE ROUTINE\n*\n         ST    R11,CPPLADDR        CPPLADDR CONTAINS POINTER TO CPPL\n*\n         CLC   VALIDSW,=C'YES'     WAS PARSE SUCCESFUL ?\n         BNE   INITL               IF NOT, BRANCH TO INITL\n         BAL   R14,GETDDNAM        GET, EDIT, AND STORE DDNAME\n         CLC   VALIDSW,=C'YES'     WAS IT SUCCESFUL ?\n         BNE   INITL               IF NOT, BRANCH TO INITL\n         BAL   R14,GETSYSCL        GET, EDIT, AND STORE SYSOUT CLASS\n         CLC   VALIDSW,=C'YES'     WAS IT SUCCESFUL ?\n         BNE   INITL               IF NOT, BRANCH TO INITL\n         BAL   R14,GETFORM#        GET, EDIT, AND STORE FORM #\n         CLC   VALIDSW,=C'YES'     WAS IT SUCCESFUL ?\n         BNE   INITL               IF NOT, BRANCH TO INITL\n         BAL   R14,GETDEST         GET, EDIT, AND STORE DESTINATION\n         CLC   VALIDSW,=C'YES'     WAS IT SUCCESFUL ?\n         BNE   INITL               IF NOT, BRANCH TO INITL\n         BAL   R14,GETCPYS         GET, EDIT, AND STORE NO OF COPIES\n         CLC   VALIDSW,=C'YES'     WAS IT SUCCESFUL ?\n         BNE   INITL               IF NOT, BRANCH TO INITL\n         BAL   R14,GETFCB          GET, EDIT, AND STORE FCB\n         CLC   VALIDSW,=C'YES'     WAS IT SUCCESFUL ?\n         BNE   INITL               IF NOT, BRANCH TO INITL\n         BAL   R14,GETFLSH         GET, EDIT, AND STORE FLASH\n         CLC   VALIDSW,=C'YES'     WAS IT SUCCESFUL ?\n         BNE   INITL               IF NOT, BRANCH TO INITL\n         BAL   R14,GETCHRS         GET, EDIT, AND STORE CHARS\n         CLC   VALIDSW,=C'YES'     WAS IT SUCCESFUL ?\n         BNE   INITL               IF NOT, BRANCH TO INITL\n         BAL   R14,GETCPMD         GET, EDIT, AND STORE COPYMOD\n         CLC   VALIDSW,=C'YES'     WAS IT SUCCESFUL ?\n         BNE   INITL               IF NOT, BRANCH TO INITL\n         BAL   R14,GETOPCD         GET, EDIT, AND STORE OPTCD\n         CLC   VALIDSW,=C'YES'     WAS IT SUCCESFUL ?\n         BNE   INITL               IF NOT, BRANCH TO INITL\n         BAL   R14,DYNFREE         DO DYNAMIC FREE\n         CLC   VALIDSW,=C'YES'     WAS IT SUCCESFUL ?\n         BNE   INITL               IF NOT, BRANCH TO INITL\n         BAL   R14,DYNALLOK        DO DYNAMIC ALLOCATION\n         CLC   VALIDSW,=C'YES'     WAS IT SUCCESFUL ?\n         BNE   INITL               IF NOT, BRANCH TO INITL\n         MVC   OUTMSG,GOODMSG      MOVE 'SUCCESSFUL COMPLETION'\n*                                    TO OUTMSG\nINITL    BAL   R14,WHOCALLD        PERFORM ROUTINE TO DETERMINE WHETHER\n*                                      THIS CMD WAS INVOKED BY A CLIST\n*                                      OR WAS ENTERED DIRECTLY\n         CLC   BYCLIST,=CL3'YES'   WAS CMD INVOKED BY A CLIST ?\n         BE    BYACLIST            IF SO, BRANCH TO BYACLIST\n         BAL   R14,PUT2TERM        PERFORM ROUTINE TO PUTLINE ERROR\n*                                      MSG TO TERMINAL (IF APPROPRIATE)\n         B     SHUTDOWN            BRANCH TO SHUTDOWN\nBYACLIST BAL   R14,INITLIST        BUILD PARMLIST FOR IKJUPDT\n         BAL   R14,SETOUTMG        SET CLIST VARIABLE OUTMSG\n         B     SHUTDOWN            BRANCH TO SHUTDOWN\n         EJECT\n********************************************************************\n*                                                                  *\n*        P A R S E   I N P U T   C O M M A N D   B U F F E R       *\n*                                                                  *\n********************************************************************\n*\nDOPARSE  ST    R14,SAVEIT1          SAVE REG 14 CONTENTS IN SAVEIT1\n         KKPARSE\n         LTR   R15,R15              RC = 0 ? (I.E PARSE GO OK ?)\n         BNZ   PARSERR              IF NOT, BRANCH TO PARSERR\n         MVC   VALIDSW,=C'YES'      MOVE 'YES' TO VALIDSW\n         L     R10,ANS\n         USING IKJPARMD,R10\n         B     EXITPARS\nPARSERR  MVC   VALIDSW,=C'NO '      MOVE 'NO ' TO VALIDSW\n         LA    R4,96                SET REG 4 = 96\n         MVC   OUTMSG,ERRMSG1       MOVE 'INVALID SYNTAX OF ONE OR\n*                                     MORE OPERANDS' TO OUTMSG\nEXITPARS L     R14,SAVEIT1\n         BR    14\n         EJECT\n********************************************************************\n*                                                                  *\n*        THIS ROUTINE OBTAINS THE DDNAME FROM THE KEYWORD          *\n*        PARAMETER DDNAME, EDITS IT, AND STORES IT INTO ZDDNAME    *\n*                                                                  *\n*        IF THIS PARAMETER IS PROVIDED AND PASSES ALL EDITS        *\n*          THEN IT WILL                                            *\n*              MOVE 'YES' TO VALIDSW                               *\n*              MOVE THE DDNAME TO ZDDNAME                          *\n*              MOVE THE LENGTH OF THE DDNAME TO ZDDNLEN            *\n*        ELSE IT WILL                                              *\n*              MOVE 'NO ' TO VALIDSW                               *\n*              MOVE APPROPRIATE VALUE TO REG 4                     *\n*              MOVE APPROPRIATE MESSAGE TO OUTMSG                  *\n*              MOVE SPACES TO ZDDNAME                              *\n*              MOVE SPACES TO ZDDNLEN                              *\n*                                                                  *\n********************************************************************\n*\nGETDDNAM ST    R14,SAVEIT2             SAVE REG 14 CONTENTS IN SAVEIT2\n         MVC   VALIDSW,=CL3'YES'       MOVE 'YES' TO VALIDSW\n         MVC   ZDDNAME,=CL8' '         MOVE SPACES TO ZDDNAME\n         MVC   ZDDNLEN,=CL2' '         MOVE SPACES TO ZDDNLEN\n         TM    DDNSTRNG+6,X'80'        IS DDNAME PRESENT ?\n         BNO   NODDNAME                IF NOT, BRANCH TO NODDNAME\n         LA    R1,ZDDNAME              R1 ==> ADDRESS OF ZDDNAME\n         L     R8,DDNSTRNG             R8 ==> ADDRESS OF THE DDNAME\n         LH    R7,DDNSTRNG+4           R7 ==> LENGTH OF THE DDNAME\n         S     R7,=F'1'                SUBTRACT 1 FOR EX\n         SPACE 1\nMOVEDDN  MVC   0(0,R1),0(R8)           MOVE THE DDNAME TO ZDDNAME\n         EX    R7,MOVEDDN\n         SPACE 1\n         MVC   ZDDNLEN(2),DDNSTRNG+4   ZDDNLEN ==> LENGTH OF DDNAME\n         B     EXITGDDN                BRANCH TO EXITGDDN\nNODDNAME MVC   VALIDSW,=CL3'NO '       MOVE 'NO ' TO VALIDSW\n         LA    R4,4                    SET REG 4 = 4\n         MVC   OUTMSG,ERRMSG2          MOVE 'MISSING DDNAME' TO OUTMSG\nEXITGDDN L     R14,SAVEIT2\n         BR    R14\n         EJECT\n********************************************************************\n*                                                                  *\n*        THIS ROUTINE OBTAINS THE SYSOUT CLASS FROM THE KEYWORD    *\n*        PARAMETER SYSCLASS, EDITS IT, AND STORES IT INTO ZSYSCLAS *\n*                                                                  *\n*        IF THIS PARAMETER IS PROVIDED AND PASSES ALL EDITS        *\n*          THEN IT WILL                                            *\n*              MOVE 'YES' TO VALIDSW                               *\n*              MOVE THE SYSOUT CLASS TO ZSYSCLAS                   *\n*        ELSE IT WILL                                              *\n*              MOVE 'NO ' TO VALIDSW                               *\n*              MOVE APPROPRIATE VALUE TO REG 4                     *\n*              MOVE APPROPRIATE MESSAGE TO OUTMSG                  *\n*              MOVE SPACE TO ZSYSCLAS                              *\n*                                                                  *\n********************************************************************\n*\nGETSYSCL ST    R14,SAVEIT3             SAVE REG 14 CONTENTS IN SAVEIT3\n         MVC   VALIDSW,=CL3'YES'       MOVE 'YES' TO VALIDSW\n         MVI   ZSYSCLAS,C' '           MOVE SPACE TO ZSYSCLAS\n         TM    SYSSTRNG+6,X'80'        IS SYSOUT CLASS PRESENT ?\n         BNO   NOSYSCLS                IF NOT, BRANCH TO NOSYSCLS\n         LH    R7,SYSSTRNG+4           R7 ==> LENGTH OF SYSOUT CLASS\n         CH    R7,=H'1'                LENGTH OF SYSOUT CLASS = 1 ?\n         BNE   BADSYSCL                IF NOT, BRANCH TO BADSYSCL\n         L     R8,SYSSTRNG             R8 ==> ADDRESS OF SYSOUT CLASS\n         MVC   INBYTE,0(R8)            MOVE SYSOUT CLASS TO INBYTE\n         BAL   R14,EDITBYTE            EDIT THE SYSOUT CLASS\n         CLC   EDITSW,=CL3'YES'        WAS IT VALID ?\n         BNE   BADSYSCL                IF NOT, BRANCH TO BADSYSCL\n         MVC   ZSYSCLAS(1),0(R8)       MOVE SYS CLASS TO ZSYSCLAS\n         B     EXITGSYS                BRANCH TO EXITGDDN\nNOSYSCLS MVC   VALIDSW,=CL3'NO '       MOVE 'NO ' TO VALIDSW\n         LA    R4,12                   SET REG 4 = 12\n         MVC   OUTMSG,ERRMSG4          MOVE 'MISSING SYSOUT CLASS'\n*                                        TO OUTMSG\n         B     EXITGSYS                BRANCH TO EXITGDDN\nBADSYSCL MVC   VALIDSW,=CL3'NO '       MOVE 'NO ' TO VALIDSW\n         LA    R4,32                   SET REG 4 = 32\n         MVC   OUTMSG,ERRMSG9          MOVE 'INVALID SYSOUT CLASS'\n*                                        TO OUTMSG\nEXITGSYS L     R14,SAVEIT3\n         BR    R14\n         EJECT\n********************************************************************\n*                                                                  *\n*        THIS ROUTINE OBTAINS THE FORM NUMBER FROM THE KEYWORD     *\n*        PARAMETER FORM, EDITS IT, AND STORES IT INTO ZFORM#       *\n*                                                                  *\n*        IF (THIS PARAMETER IS PROVIDED AND PASSES ALL EDITS)      *\n*          OR                                                      *\n*           (THIS PARAMETER IS NOT PROVIDED)                       *\n*              THEN IT WILL                                        *\n*                  MOVE 'YES' TO VALIDSW                           *\n*                  MOVE THE FORM NUMBER TO ZFORM#                  *\n*                     (SPACES WHEN FORM NUMBER IS NOT PRESENT)     *\n*        ELSE IT WILL                                              *\n*                  MOVE 'NO ' TO VALIDSW                           *\n*                  MOVE APPROPRIATE VALUE TO REG 4                 *\n*                  MOVE APPROPRIATE MESSAGE TO OUTMSG              *\n*                  MOVE SPACES TO ZFORM#                           *\n*                                                                  *\n********************************************************************\n*\nGETFORM# ST    R14,SAVEIT4             SAVE REG 14 CONTENTS IN SAVEIT4\n         MVC   VALIDSW,=CL3'YES'       MOVE 'YES' TO VALIDSW\n         MVC   ZFORM#,=CL4' '          MOVE SPACES TO ZFORM#\n         TM    FRMSTRNG+6,X'80'        IS FORM NUMBER PRESENT ?\n         BNO   EXITGFRM                IF NOT, BRANCH TO EXITGFRM\n         LH    R7,FRMSTRNG+4           R7 ==> LENGTH OF THE FORM NMBR\n         CH    R7,=H'4'                IS LENGTH OF FORM# = 4\n         BNE   BADFORM#                IF NOT, BRANCH TO BADFORM#\n         L     R8,FRMSTRNG             R8 ==> ADDRESS OF THE FORM NMBR\n         MVC   INBYTE,0(R8)            MOVE BYTE #1 OF FORM# TO INBYTE\n         BAL   R14,EDITBYTE            EDIT BYTE #1 OF FORM#\n         CLC   EDITSW,=CL3'YES'        WAS IT VALID ?\n         BNE   BADFORM#                IF NOT, BRANCH TO BADFORM#\n         MVC   INBYTE,1(R8)            MOVE BYTE #2 OF FORM# TO INBYTE\n         BAL   R14,EDITBYTE            EDIT BYTE #2 OF FORM#\n         CLC   EDITSW,=CL3'YES'        WAS IT VALID ?\n         BNE   BADFORM#                IF NOT, BRANCH TO BADFORM#\n         MVC   INBYTE,2(R8)            MOVE BYTE #3 OF FORM# TO INBYTE\n         BAL   R14,EDITBYTE            EDIT BYTE #3 OF FORM#\n         CLC   EDITSW,=CL3'YES'        WAS IT VALID ?\n         BNE   BADFORM#                IF NOT, BRANCH TO BADFORM#\n         MVC   INBYTE,3(R8)            MOVE BYTE #4 OF FORM# TO INBYTE\n         BAL   R14,EDITBYTE            EDIT BYTE #4 OF FORM#\n         CLC   EDITSW,=CL3'YES'        WAS IT VALID ?\n         BNE   BADFORM#                IF NOT, BRANCH TO BADFORM#\n         MVC   ZFORM#,0(R8)            MOVE FORM NMBR TO ZFORM#\n         B     EXITGFRM                BRANCH TO EXITGFRM\nBADFORM# MVC   VALIDSW,=CL3'NO '       MOVE 'NO ' TO VALIDSW\n         LA    R4,16                   SET REG 4 = 16\n         MVC   OUTMSG,ERRMSG5          MOVE 'INVALID FORM NUMBER'\n*                                        TO OUTMSG\nEXITGFRM L     R14,SAVEIT4\n         BR    R14\n         EJECT\n********************************************************************\n*                                                                  *\n*        THIS ROUTINE OBTAINS THE DESTINATION FROM THE KEYWORD     *\n*        PARAMETER DEST, EDITS IT, AND STORES IT INTO ZDEST        *\n*                                                                  *\n*        IF (THIS PARAMETER IS PROVIDED AND PASSES ALL EDITS)      *\n*          OR                                                      *\n*           (THIS PARAMETER IS NOT PROVIDED)                       *\n*              THEN IT WILL                                        *\n*                  MOVE 'YES' TO VALIDSW                           *\n*                  MOVE THE DESTINATION TO ZDEST                   *\n*                     (SPACES WHEN DESTINATION IS NOT PRESENT)     *\n*                  MOVE THE LENGTH OF THE DESTINATION TO ZDSTLEN   *\n*        ELSE IT WILL                                              *\n*                  MOVE 'NO ' TO VALIDSW                           *\n*                  MOVE APPROPRIATE VALUE TO REG 4                 *\n*                  MOVE APPROPRIATE MESSAGE TO OUTMSG              *\n*                  MOVE SPACES TO ZDEST                            *\n*                  MOVE SPACES TO ZDSTLEN                          *\n*                                                                  *\n********************************************************************\n*\nGETDEST  ST    R14,SAVEIT5             SAVE REG 14 CONTENTS IN SAVEIT5\n         MVC   VALIDSW,=CL3'YES'       MOVE 'YES' TO VALIDSW\n         MVC   ZDEST,=CL8' '           MOVE SPACES TO ZDEST\n         MVC   ZDSTLEN,=CL2' '         MOVE SPACES TO ZDSTLEN\n         TM    DSTSTRNG+6,X'80'        IS DESTINATION PRESENT ?\n         BNO   EXITGDST                IF NOT, BRANCH TO EXITGDST\n         LA    R1,ZDEST                R1 ==> ADDRESS OF ZDEST\n         L     R8,DSTSTRNG             R8 ==> ADDRESS OF DESTINATION\n         CLC   0(5,R8),=CL5'LOCAL'     DEST = LOCAL ?\n         BE    LOADDEST                IF SO, BRANCH TO LOADDEST\n         CLC   0(5,R8),=CL5'WDPSC'     DEST = WDPSC ?\n         BE    LOADDEST                IF SO, BRANCH TO LOADDEST\n         CLC   0(3,R8),=CL3'RMT'       DEST BEGIN WITH 'RMT' ?\n         BE    LOADDEST                IF SO, BRANCH TO LOADDEST\n         CLC   0(6,R8),=CL6'REMOTE'    DEST BEGIN WITH 'REMOTE' ?\n         BE    LOADDEST                IF SO, BRANCH TO LOADDEST\n         B     BADDEST                 BRANCH TO BADDEST\nLOADDEST LH    R7,DSTSTRNG+4           R7 ==> LENGTH OF THE DESTINATION\n         S     R7,=F'1'                SUBTRACT 1 FOR EX\n         SPACE 1\nMOVEDST  MVC   0(0,R1),0(R8)           MOVE THE DESTINATION TO ZDEST\n         EX    R7,MOVEDST\n         SPACE 1\n         MVC   ZDSTLEN(2),DSTSTRNG+4   ZDSTLEN => LENGTH OF DESTINATION\n         B     EXITGDST                BRANCH TO EXITGDST\nBADDEST  MVC   VALIDSW,=CL3'NO '       MOVE 'NO ' TO VALIDSW\n         LA    R4,20                   SET REG 4 = 20\n         MVC   OUTMSG,ERRMSG6          MOVE 'INVALID DESTINATION'\n*                                        TO OUTMSG\nEXITGDST L     R14,SAVEIT5\n         BR    R14\n         EJECT\n********************************************************************\n*                                                                  *\n*        THIS ROUTINE OBTAINS THE NUMBER OF COPIES FROM THE KEYWORD*\n*        PARAMETER COPIES, EDITS IT, AND STORES IT INTO ZCOPIES    *\n*                                                                  *\n*        IF (THIS PARAMETER IS PROVIDED AND PASSES ALL EDITS)      *\n*          OR                                                      *\n*           (THIS PARAMETER IS NOT PROVIDED)                       *\n*              THEN IT WILL                                        *\n*                  MOVE 'YES' TO VALIDSW                           *\n*                  MOVE THE NUMBER OF COPIES TO ZCOPIES            *\n*                      (SPACE WHEN NO OF COPIES IS NOT PRESENT)    *\n*        ELSE IT WILL                                              *\n*                  MOVE 'NO ' TO VALIDSW                           *\n*                  MOVE APPROPRIATE VALUE TO REG 4                 *\n*                  MOVE APPROPRIATE MESSAGE TO OUTMSG              *\n*                  MOVE SPACE TO ZCOPIES                           *\n*                                                                  *\n********************************************************************\n*\nGETCPYS  ST    R14,SAVEIT6             SAVE REG 14 CONTENTS IN SAVEIT6\n         MVC   VALIDSW,=CL3'YES'       MOVE 'YES' TO VALIDSW\n         MVI   ZCOPIES,C' '            MOVE SPACE TO ZCOPIES\n         MVC   INCOPIES,=CL3'000'      MOVE 000 TO INCOPIES\n         TM    CPYSTRNG+6,X'80'        IS NO OF COPIES PRESENT ?\n         BNO   EXITGCPY                IF NOT, BRANCH TO EXITGCPY\n         LH    R7,CPYSTRNG+4           R7 ==> LENGTH OF NO OF COPIES\n         L     R8,CPYSTRNG             R8 ==> ADDRESS OF NO OF COPIES\n         CH    R7,=H'1'                LENGTH OF # OF COPIES = 1 ?\n         BE    CPYLEN1                 IF SO, BRANCH TO CPYLEN1\n         CH    R7,=H'2'                LENGTH OF # OF COPIES = 2 ?\n         BE    CPYLEN2                 IF SO, BRANCH TO CPYLEN2\n         CH    R7,=H'3'                LENGTH OF # OF COPIES = 3 ?\n         BE    CPYLEN3                 IF SO, BRANCH TO CPYLEN3\n         B     NOGUDCPY                BRANCH TO NOGUDCPY\nCPYLEN1  MVC   INCOPIES+2(1),0(R8)     MOVE # OF COPIES TO INCOPIES\n         B     EDITCPYS                BRANCH TO EDITCPYS\nCPYLEN2  MVC   INCOPIES+1(2),0(R8)     MOVE # OF COPIES TO INCOPIES\n         B     EDITCPYS                BRANCH TO EDITCPYS\nCPYLEN3  MVC   INCOPIES(3),0(R8)       MOVE # OF COPIES TO INCOPIES\nEDITCPYS BAL   R14,CNVCPYS             EDIT AND CONVERT # OF COPIES\n         CLC   COPYSW,=CL3'YES'        WAS EDIT AND CONV SUCCESSFUL ?\n         BE    EXITGCPY                IF SO, BRANCH TO EXITGCPY\nNOGUDCPY MVC   VALIDSW,=CL3'NO '       MOVE 'NO ' TO VALIDSW\n         LA    R4,28                   SET REG 4 = 28\n         MVC   OUTMSG,ERRMSG8          MOVE 'INVALID NO OF COPIES'\n*                                        TO OUTMSG\nEXITGCPY L     R14,SAVEIT6\n         BR    R14\n         EJECT\n********************************************************************\n*                                                                  *\n*        THIS ROUTINE OBTAINS THE FCB FROM THE KEYWORD             *\n*        PARAMETER FCB, EDITS IT, AND STORES IT INTO ZFCB          *\n*                                                                  *\n*        IF (THIS PARAMETER IS PROVIDED AND PASSES ALL EDITS)      *\n*          OR                                                      *\n*           (THIS PARAMETER IS NOT PROVIDED)                       *\n*              THEN IT WILL                                        *\n*                  MOVE 'YES' TO VALIDSW                           *\n*                  MOVE THE FCB TO ZFCB                            *\n*                     (SPACES WHEN FCB IS NOT PRESENT)             *\n*                  MOVE THE LENGTH OF THE FCB PARAMETER TO ZFCBLEN *\n*        ELSE IT WILL                                              *\n*                  MOVE 'NO ' TO VALIDSW                           *\n*                  MOVE APPROPRIATE VALUE TO REG 4                 *\n*                  MOVE APPROPRIATE MESSAGE TO OUTMSG              *\n*                  MOVE SPACES TO ZFCB                             *\n*                                                                  *\n********************************************************************\n*\nGETFCB   ST    R14,SAVEIT7             SAVE REG 14 CONTENTS IN SAVEIT7\n         MVC   VALIDSW,=CL3'YES'       MOVE 'YES' TO VALIDSW\n         MVC   ZFCB,=CL4' '            MOVE SPACES TO ZFCB\n         TM    FCBSTRNG+6,X'80'        IS THE FCB PRESENT ?\n         BNO   EXITGFCB                IF NOT, BRANCH TO EXITGFCB\n         LA    R1,ZFCB                 R1 ==> ADDRESS OF ZFCB\n         L     R8,FCBSTRNG             R8 ==> ADDRESS OF THE FCB\n         LH    R7,FCBSTRNG+4           R7 ==> LENGTH OF THE FCB\n         C     R7,=F'1'\n         BL    BADFCB\n         C     R7,=F'4'\n         BH    BADFCB\n         S     R7,=F'1'                SUBTRACT 1 FOR EX\n         SPACE 1\nMOVEFCB  MVC   0(0,R1),0(R8)           MOVE THE FCB TO ZFCB\n         EX    R7,MOVEFCB\n         SPACE 1\n         MVC   ZFCBLEN(2),FCBSTRNG+4   ZFCBLEN ==> LENGTH OF FCB\n         B     EXITGFCB\nBADFCB   MVC   VALIDSW,=CL3'NO '       MOVE 'NO ' TO VALIDSW\n         LA    R4,36                   SET REG 4 = 36\n         MVC   OUTMSG,ERRMSG10         MOVE 'INVALID FCB' TO OUTMSG\nEXITGFCB L     R14,SAVEIT7\n         BR    R14\n         EJECT\n********************************************************************\n*                                                                  *\n*        THIS ROUTINE OBTAINS THE FLASH NAME FROM THE KEYWORD      *\n*        PARAMETER FLASH, EDITS IT, AND STORES IT INTO ZFLASH      *\n*                                                                  *\n*        IF (THIS PARAMETER IS PROVIDED AND PASSES ALL EDITS)      *\n*          OR                                                      *\n*           (THIS PARAMETER IS NOT PROVIDED)                       *\n*              THEN IT WILL                                        *\n*                  MOVE 'YES' TO VALIDSW                           *\n*                  MOVE THE FLASH NAME TO ZFLASH                   *\n*                     (SPACES WHEN FLASH NAME IS NOT PRESENT)      *\n*                  MOVE THE LENGTH OF THE FLASH NAME TO ZFLSHLEN   *\n*        ELSE IT WILL                                              *\n*                  MOVE 'NO ' TO VALIDSW                           *\n*                  MOVE APPROPRIATE VALUE TO REG 4                 *\n*                  MOVE APPROPRIATE MESSAGE TO OUTMSG              *\n*                  MOVE SPACES TO ZFLASH                           *\n*                                                                  *\n********************************************************************\n*\nGETFLSH  ST    R14,SAVEIT8             SAVE REG 14 CONTENTS IN SAVEIT8\n         MVC   VALIDSW,=CL3'YES'       MOVE 'YES' TO VALIDSW\n         MVC   ZFLASH,=CL4' '          MOVE SPACES TO ZFLASH\n         TM    FLHSTRNG+6,X'80'        IS THE FLASH PRESENT ?\n         BNO   EXITGFLH                IF NOT, BRANCH TO EXITGFLH\n         LA    R1,ZFLASH               R1 ==> ADDRESS OF ZFLASH\n         L     R8,FLHSTRNG             R8 ==> ADDRESS OF THE FLASH\n         LH    R7,FLHSTRNG+4           R7 ==> LENGTH OF THE FLASH\n         C     R7,=F'1'\n         BL    BADFLASH\n         C     R7,=F'4'\n         BH    BADFLASH\n         S     R7,=F'1'                SUBTRACT 1 FOR EX\n         SPACE 1\nMOVEFLH  MVC   0(0,R1),0(R8)           MOVE THE FLASH TO ZFLASH\n         EX    R7,MOVEFLH\n         SPACE 1\n         MVC   ZFLSHLEN(2),FLHSTRNG+4  ZFLSHLEN ==> LENGTH OF FLASH\n         B     EXITGFLH\nBADFLASH MVC   VALIDSW,=CL3'NO '       MOVE 'NO ' TO VALIDSW\n         LA    R4,40                   SET REG 4 = 40\n         MVC   OUTMSG,ERRMSG11         MOVE 'INVALID FLASH NAME'\n*                                          TO OUTMSG\nEXITGFLH L     R14,SAVEIT8\n         BR    R14\n         EJECT\n********************************************************************\n*                                                                  *\n*        THIS ROUTINE OBTAINS THE CHARS PARAMETER FROM THE KEYWORD *\n*        PARAMETER CHARS, EDITS IT, AND STORES IT INTO ZCHARS1,    *\n*        ZCHARS2, ZCHARS3, AND ZCHARS4                             *\n*                                                                  *\n*        IF THIS PARAMETER IS PROVIDED AND PASSES ALL EDITS        *\n*              THEN IT WILL                                        *\n*                  MOVE 'YES' TO VALIDSW                           *\n*                  MOVE THE 1ST CHARS PARAMETER TO ZCHARS1         *\n*                  MOVE THE LENGTH OF THE 1ST CHARS                *\n*                      PARAMETER TO ZCHR1LEN                       *\n*                  MOVE THE 2ND CHARS PARAMETER TO ZCHARS2         *\n*                        (SPACES IF ONLY 1 CHARS PARAMETER         *\n*                              IS PRESENT)                         *\n*                  MOVE THE LENGTH OF THE 2ND CHARS                *\n*                      PARAMETER TO ZCHR2LEN IF APPROPRIATE        *\n*                  MOVE THE 3RD CHARS PARAMETER TO ZCHARS3         *\n*                        (SPACES IF ONLY 2 CHARS PARAMETERS        *\n*                             ARE PRESENT)                         *\n*                  MOVE THE LENGTH OF THE 3RD CHARS                *\n*                      PARAMETER TO ZCHR3LEN IF APPROPRIATE        *\n*                  MOVE THE 4TH CHARS PARAMETER TO ZCHARS4         *\n*                        (SPACES IF ONLY 3 CHARS PARAMETERS        *\n*                             ARE PRESENT)                         *\n*                  MOVE THE LENGTH OF THE 4TH CHARS                *\n*                      PARAMETER TO ZCHR4LEN IF APPROPRIATE        *\n*        IF THIS PARAMETER IS NOT PROVIDED                         *\n*              THEN IT WILL                                        *\n*                  MOVE 'YES' TO VALIDSW                           *\n*                  MOVE SPACES TO ZCHARS1                          *\n*        IF THIS PARAMETER IS PROVIDED BUT IS INVALID              *\n*              THEN IT WILL                                        *\n*                  MOVE 'NO ' TO VALIDSW                           *\n*                  MOVE APPROPRIATE VALUE TO REG 4                 *\n*                  MOVE APPROPRIATE MESSAGE TO OUTMSG              *\n*                  MOVE SPACES TO ZCHARS1                          *\n*                                                                  *\n********************************************************************\n*\nGETCHRS  ST    R14,SAVEIT9            SAVE REG 14 CONTENTS IN SAVEIT9\n         MVC   VALIDSW,=CL3'YES'      MOVE 'YES' TO VALIDSW\n         MVC   ZCHARS1,=CL4' '        MOVE SPACES TO ZCHARS1\n         MVC   ZCHARS2,=CL4' '        MOVE SPACES TO ZCHARS2\n         MVC   ZCHARS3,=CL4' '        MOVE SPACES TO ZCHARS3\n         MVC   ZCHARS4,=CL4' '        MOVE SPACES TO ZCHARS4\n         TM    CHRSTRNG+6,X'80'       IS THE CHARS PARAMETER PRESENT ?\n         BNO   EXITGCHR               IF NOT, BRANCH TO EXITGCHR\n         ZAP   WHICHONE,PACKED1       SET WHICHONE = 1\n         LA    R9,CHRSTRNG            R9==> ADDRESS OF CHARS PDE\nCHRSLOOP CP    WHICHONE,PACKED4       WHICHONE GT 4 ?\n         BH    BADCHARS               IF SO, BRANCH TO BADCHARS\n         MVC   PDEWORD1,0(R9)         PDEWORD1==> PTR TO VALUE\n         MVC   PDEWORD2,4(R9)         PDEWORD2==> LENGTH OF VALUE\n         MVC   PDEWORD3,8(R9)         PDEWORD3==> PTR TO NEXT ENTRY\n         LH    R7,PDEWORD2            R7==> LENGTH OF VALUE\n         C     R7,=F'1'\n         BL    BADCHARS\n         C     R7,=F'4'\n         BH    BADCHARS\n         L     R8,PDEWORD1            R8==> ADDRESS OF VALUE\n         BAL   R14,LOADCHRS\n         CLC   PDEWORD3,=XL4'FF000000'  IS THIS LAST ENTRY ?\n         BE    EXITGCHR                 IF SO, BRANCH TO EXITGCHR\n         AP    WHICHONE,PACKED1       ADD 1 TO WHICHONE\n         L     R9,PDEWORD3            R9==> ADDRESS OF NEXT ENTRY\n         B     CHRSLOOP               BRANCH TO CHRSLOOP\n*\n*\n*\nLOADCHRS ST    R14,SAVEIT20           SAVE REG 14 CONTENTS IN SAVEIT20\n         CP    WHICHONE,PACKED1       WHICHONE = 1 ?\n         BE    LOADCHR1               IF SO, BRANCH TO LOADCHR1\n         CP    WHICHONE,PACKED2       WHICHONE = 2 ?\n         BE    LOADCHR2               IF SO, BRANCH TO LOADCHR2\n         CP    WHICHONE,PACKED3       WHICHONE = 3 ?\n         BE    LOADCHR3               IF SO, BRANCH TO LOADCHR3\n         STH   R7,ZCHR4LEN            ZCHR4LEN = LENGTH OF VALUE\n         LA    R1,ZCHARS4             R1==> ADDRESS OF ZCHARS4\n         B     MOVEIT                 BRANCH TO MOVEIT\nLOADCHR1 STH   R7,ZCHR1LEN            ZCHR1LEN = LENGTH OF VALUE\n         LA    R1,ZCHARS1             R1==> ADDRESS OF ZCHARS1\n         B     MOVEIT                 BRANCH TO MOVEIT\nLOADCHR2 STH   R7,ZCHR2LEN            ZCHR2LEN = LENGTH OF VALUE\n         LA    R1,ZCHARS2             R1==> ADDRESS OF ZCHARS2\n         B     MOVEIT                 BRANCH TO MOVEIT\nLOADCHR3 STH   R7,ZCHR3LEN            ZCHR3LEN = LENGTH OF VALUE\n         LA    R1,ZCHARS3             R1==> ADDRESS OF ZCHARS3\nMOVEIT   S     R7,=F'1'               SUBTRACT 1 FOR EX\n         SPACE 1\nMOVECHRS MVC   0(0,R1),0(R8)\n         EX    R7,MOVECHRS\n         SPACE 1\nEXITLCHR L     R14,SAVEIT20\n         BR    R14\n*\n*\n*\nBADCHARS MVC   VALIDSW,=CL3'NO '      MOVE 'NO ' TO VALIDSW\n         LA    R4,48                  SET REG 4 = 48\n         MVC   OUTMSG,ERRMSG13        MOVE 'INVALID CHARS PARAMETER'\n*                                         TO OUTMSG\nEXITGCHR L     R14,SAVEIT9\n         BR    R14\n         EJECT\n********************************************************************\n*                                                                  *\n*        THIS ROUTINE OBTAINS THE COPYMOD FROM THE KEYWORD         *\n*        PARAMETER MODIFY, EDITS IT, AND STORES IT INTO            *\n*        ZMODIFY1, ZMOD1LEN, AND ZMODIFY2                          *\n*                                                                  *\n*        IF THIS PARAMETER IS PROVIDED AND PASSES ALL EDITS        *\n*              THEN IT WILL                                        *\n*                  MOVE 'YES' TO VALIDSW                           *\n*                  MOVE THE COPYMOD NAME TO ZMODIFY1               *\n*                  MOVE THE LENGTH OF THE COPYMOD NAME TO ZMOD1LEN *\n*                  MOVE THE COPYMOD/CHAR REFERENCE SPECIFICATION   *\n*                      (IF APPROPRIATE) TO ZMODIFY2                *\n*        IF THIS PARAMETER IS NOT PROVIDED                         *\n*              THEN IT WILL                                        *\n*                  MOVE 'YES' TO VALIDSW                           *\n*                  MOVE SPACES TO ZMODIFY1                         *\n*                  MOVE SPACE TO ZMODIFY2                          *\n*        IF THIS PARAMETER IS PROVIDED BUT IS INVALID              *\n*              THEN IT WILL                                        *\n*                  MOVE 'NO ' TO VALIDSW                           *\n*                  MOVE APPROPRIATE VALUE TO REG 4                 *\n*                  MOVE APPROPRIATE MESSAGE TO OUTMSG              *\n*                  MOVE SPACES TO ZMODIFY1                         *\n*                                                                  *\n********************************************************************\n*\nGETCPMD  ST    R14,SAVEIT10           SAVE REG 14 CONTENTS IN SAVEIT10\n         MVC   VALIDSW,=CL3'YES'      MOVE 'YES' TO VALIDSW\n         MVC   ZMODIFY1,=CL4' '       MOVE SPACES TO ZMODIFY1\n         MVC   ZMODIFY2,=CL1' '       MOVE SPACE TO ZMODIFY2\n         TM    MODSTRNG+6,X'80'       IS THE MODIFY PARAMTER PRESENT ?\n         BNO   EXITCPMD               IF NOT, BRANCH TO EXITCPMD\n         LA    R9,MODSTRNG            R9==> ADDRESS OF MODIFY PDE\n         MVC   PDEWORD1,0(R9)         PDEWORD1==> PTR TO COPYMOD\n         MVC   PDEWORD2,4(R9)         PDEWORD2==> LENGTH OF COPYMOD\n         MVC   PDEWORD3,8(R9)         PDEWORD3==> PTR TO NEXT ENTRY\n         LH    R7,PDEWORD2            R7==> LENGTH OF COPYMOD\n         C     R7,=F'1'\n         BL    BADCPYMD\n         C     R7,=F'4'\n         BH    BADCPYMD\n         L     R8,PDEWORD1            R8==> ADDRESS OF COPYMOD\n         STH   R7,ZMOD1LEN            ZMOD1LEN = LENGTH OF COPYMOD\n         LA    R1,ZMODIFY1            R1==> ADDRESS OF ZMODIFY1\n         S     R7,=F'1'               SUBTRACT 1 FOR EX\n         SPACE 1\nMOVECPMD MVC   0(0,R1),0(R8)\n         EX    R7,MOVECPMD\n         SPACE 1\n         CLC   PDEWORD3,=XL4'FF000000'  IS THIS LAST ENTRY ?\n         BE    EXITCPMD                 IF SO, BRANCH TO EXITCPMD\n         L     R9,PDEWORD3            R9==> ADDRESS OF NEXT ENTRY\n         MVC   PDEWORD1,0(R9)         PDEWORD1==> PTR TO CHARS REF CHAR\n         MVC   PDEWORD2,4(R9)         PDEWORD2==> LENGTH OF REF CHAR\n         MVC   PDEWORD3,8(R9)         PDEWORD3==> PTR TO NEXT ENTRY\n         LH    R7,PDEWORD2            R7==> LENGTH OF REF CHARACTER\n         C     R7,=F'1'\n         BNE   BADCPYMD\n         L     R8,PDEWORD1            R8==> ADDRESS OF REF CHARACTER\n         CLI   0(R8),C'0'\n         BE    MOVECREF\n         CLI   0(R8),C'1'\n         BE    MOVECREF\n         CLI   0(R8),C'2'\n         BE    MOVECREF\n         CLI   0(R8),C'3'\n         BNE   BADCPYMD\nMOVECREF MVC   ZMODIFY2(1),0(R8)\n         B     EXITCPMD\nBADCPYMD MVC   VALIDSW,=CL3'NO '      MOVE 'NO ' TO VALIDSW\n         LA    R4,52                  SET REG 4 = 52\n         MVC   OUTMSG,ERRMSG14        MOVE 'INVALID MODIFY PARAMETER'\n*                                         TO OUTMSG\nEXITCPMD L     R14,SAVEIT10\n         BR    R14\n         EJECT\n********************************************************************\n*                                                                  *\n*        THIS ROUTINE OBTAINS THE OPTCD FROM THE KEYWORD           *\n*        PARAMETER OPTCD, EDITS IT, AND STORES IT INTO ZOPTCD      *\n*                                                                  *\n*        IF (THIS PARAMETER IS PROVIDED AND PASSES ALL EDITS)      *\n*          OR                                                      *\n*           (THIS PARAMETER IS NOT PROVIDED)                       *\n*              THEN IT WILL                                        *\n*                  MOVE 'YES' TO VALIDSW                           *\n*                  MOVE THE OPTCD TO ZOPTCD                        *\n*                     (SPACES WHEN OPTCD IS NOT PRESENT)           *\n*        ELSE IT WILL                                              *\n*                  MOVE 'NO ' TO VALIDSW                           *\n*                  MOVE APPROPRIATE VALUE TO REG 4                 *\n*                  MOVE APPROPRIATE MESSAGE TO OUTMSG              *\n*                  MOVE SPACES TO ZOPTCD                           *\n*                                                                  *\n********************************************************************\n*\nGETOPCD  ST    R14,SAVEIT11           SAVE REG 14 CONTENTS IN SAVEIT11\nBASEREG2 MVC   VALIDSW,=CL3'YES'      MOVE 'YES' TO VALIDSW\n         MVI   ZOPTCD,C' '            MOVE SPACE TO ZOPTCD\n         TM    OPTSTRNG+6,X'80'       IS THE OPTCD PRESENT ?\n         BNO   EXITGOPT               IF NOT, BRANCH TO EXITGOPT\n         LH    R7,OPTSTRNG+4          R7 ==> LENGTH OF THE OPTCD\n         C     R7,=F'1'\n         BNE   BADOPTCD\n         L     R8,OPTSTRNG            R8 ==> ADDRESS OF THE OPTCD\n         CLC   0(1,R8),=CL1'J'\n         BNE   BADOPTCD\n         MVC   ZOPTCD,0(R8)\n         B     EXITGOPT\nBADOPTCD MVC   VALIDSW,=CL3'NO '       MOVE 'NO ' TO VALIDSW\n         LA    R4,44                   SET REG 4 = 44\n         MVC   OUTMSG,ERRMSG12         MOVE 'INVALID OPTCD' TO OUTMSG\nEXITGOPT L     R14,SAVEIT11\n         BR    R14\n         EJECT\n********************************************************************\n*                                                                  *\n*        D Y N A M I C   U N A L L O C A T I O N                   *\n*                                                                  *\n********************************************************************\n*\nDYNFREE  ST    R14,SAVEIT12            SAVE REG 14 CONTENTS IN SAVEIT12\n         MVC   VALIDSW,=CL3'YES'       MOVE 'YES' TO VALIDSW\n         MVC   FREEUT1A,ZDDNLEN        MOVE LEN OF DDNAME TO FREEUT1A\n         MVC   FREEUT1B,ZDDNAME        MOVE THE DDNAME TO FREEUT1B\n         LA    R1,FREEPARM\n         DYNALLOC                      FREE F(DDNAME)\n         LTR   R15,R15                 TEST REGISTER 15 FOR ZERO\n         BZ    EXITFREE                IF ZERO, BRANCH TO EXITFREE\n         CLC   FREERRCD,=XL2'0438'     DDNAME ALREADY FREED ?\n         BE    EXITFREE                IF SO, BRANCH TO EXITFREE\n         MVC   VALIDSW,=CL3'NO '       MOVE 'NO ' TO VALIDSW\n         MVC   OUTMSG,ERRMSG3          MOVE DYNAMIC DEALLOC ERR MSG\n*                                        TO OUTMSG\n         MVC   HEXINPUT,FREERRCD       LOAD HEXINPUT WITH ERR REASON CD\n         BAL   R14,UNPKHEX             PERFORM ROUTINE TO UNPACK THE\n*                                         ERR REASON CODE INTO HEXOUT\n         MVC   OUTMSG+41(4),HEXOUT     MOVE UNPACKED ERR REASON CODE\n*                                        TO OUTMSG\n         LA    R4,8                    SET R4 TO 8\nEXITFREE L     R14,SAVEIT12\n         BR    R14\n         EJECT\n********************************************************************\n*                                                                  *\n*        D Y N A M I C    A L L O C A T I O N                      *\n*                                                                  *\n********************************************************************\n*\nDYNALLOK ST    R14,SAVEIT13            SAVE REG 14 CONTENTS IN SAVEIT13\n         MVC   VALIDSW,=CL3'YES'       MOVE 'YES' TO VALIDSW\n         BAL   R14,BLDTUNTS            BUILD TEXT UNITS\n         LA    R1,DD1PARM\n         DYNALLOC\n         LTR   R15,R15                 TEST REGISTER 15 FOR ZERO\n         BZ    EXITALLC                IF ZERO, BRANCH TO EXITALLC\n         MVC   VALIDSW,=CL3'NO '       MOVE 'NO ' TO VALIDSW\n         MVC   OUTMSG,ERRMSG7          MOVE DYNAMIC ALLOC ERR MSG\n*                                        TO OUTMSG\n         MVC   HEXINPUT,DD1ERRCD       LOAD HEXINPUT WITH ERR REASON CD\n         BAL   R14,UNPKHEX             PERFORM ROUTINE TO UNPACK THE\n*                                         ERR REASON CODE INTO HEXOUT\n         MVC   OUTMSG+39(4),HEXOUT     MOVE UNPACKED ERR REASON CODE\n*                                        TO OUTMSG\n         LA    R4,24                   SET R4 TO 24\nEXITALLC L     R14,SAVEIT13\n         BR    R14\n         EJECT\n*\n********************************************************************\n*                                                                  *\n*        THIS ROUTINE IS RESPONSIBLE FOR CONVERTING A TWO BYTE     *\n*        BINARY FIELD (SUCH AS X'0438') TO A FOUR BYTE CHARACTER   *\n*        FIELD (SUCH AS 0438)                                      *\n*                                                                  *\n*        BEFORE PERFORMING THIS ROUTINE, MOVE THE TWO BYTE BINARY  *\n*        FIELD TO BE CONVERTED TO HEXINPUT                         *\n*                                                                  *\n*        AFTER PERFORMING THIS ROUTINE, YOUR TWO BYTE BINARY       *\n*        FIELD WILL BE CONVERTED TO 4 CHARACTER BYTES IN HEXOUT    *\n*                                                                  *\n********************************************************************\n*\nUNPKHEX  ST    R14,SAVEIT14            SAVE REG 14 IN SAVEIT14\n         MVC   CHARLEN,=XL2'0004'      CHARLEN IS LENGTH OF HEXOUT\n         MVC   CNVTYPE,=CL3'HTC'       HTC ==> HEX TO CHAR CONVERSION\n         CALL  HEXTRAN,(HEXOUT,HEXINPUT,CHARLEN,CNVTYPE),VL\n         L     R14,SAVEIT14            RESTORE REGISTER 14\n         BR    R14                     RETURN\n         EJECT\n*\n********************************************************************\n*                                                                  *\n*        THIS ROUTINE IS RESPONSIBLE FOR:                          *\n*                                                                  *\n*             1.  EDITING A 3 BYTE FIELD INCOPIES (WHICH IS PASSED *\n*                 TO THIS ROUTINE).  THIS FIELD MUST BE ENTIRELY   *\n*                 NUMERIC, WITH LEADING ZEROS, AND IN THE RANGE    *\n*                 001 THRU 255                                     *\n*                                                                  *\n*                      IF IT PASSES THE EDIT, THIS ROUTINE WILL    *\n*                          MOVE 'YES' TO COPYSW                    *\n*                          DO FUNCTION #2 (THE CONVERSION)\n*                      ELSE IT WILL                                *\n*                          MOVE 'NO ' TO COPYSW                    *\n*                          EXIT THE ROUTINE                        *\n*                                                                  *\n*             2.  CONVERTING THAT 3 BYTE DISPLAY TYPE FIELD TO     *\n*                 A ONE BYTE HEXADECIMAL FIELD ZCOPIES             *\n*                                                                  *\n*                      E.G.                                        *\n*                                                                  *\n*                          IF INCOPIES IS EQUAL TO 014, THEN       *\n*                               ZCOPIES WILL EQUAL X'0E'         *\n*                                                                  *\n********************************************************************\n*\nCNVCPYS  ST    R14,SAVEIT15            SAVE REG 14 IN SAVEIT15\n         MVC   COPYSW,=CL3'YES'        MOVE 'YES' TO COPYSW\n         CLI   INCOPIES,C'0'           BYTE #1 OF COPIES LT '0' ?\n         BL    BADCPYS                 IF SO, BRANCH TO BADCPYS\n         CLI   INCOPIES,C'9'           BYTE #1 OF COPIES GT '9' ?\n         BH    BADCPYS                 IF SO, BRANCH TO BADCPYS\n         CLI   INCOPIES+1,C'0'         BYTE #2 OF COPIES LT '0' ?\n         BL    BADCPYS                 IF SO, BRANCH TO BADCPYS\n         CLI   INCOPIES+1,C'9'         BYTE #2 OF COPIES GT '9' ?\n         BH    BADCPYS                 IF SO, BRANCH TO BADCPYS\n         CLI   INCOPIES+2,C'0'         BYTE #3 OF COPIES LT '0' ?\n         BL    BADCPYS                 IF SO, BRANCH TO BADCPYS\n         CLI   INCOPIES+2,C'9'         BYTE #3 OF COPIES GT '9' ?\n         BH    BADCPYS                 IF SO, BRANCH TO BADCPYS\n         CLC   INCOPIES,=CL3'000'      NO OF COPIES = '000' ?\n         BE    BADCPYS                 IF SO, BRANCH TO BADCPYS\n         PACK  PKDCPYS,INCOPIES        PACK INCOPIES INTO PKDCPYS\n         CVB   R8,PKDCPYS              CONVERT IT TO BINARY\n         C     R8,=F'255'              R8 > 255 ?\n         BH    BADCPYS                 IF SO, BRANCH TO BADCPYS\n         STC   R8,ZCOPIES              STORE # OF COPIES INTO ZCOPIES\n         B     EXITCNV                 BRANCH TO EXITCNV\nBADCPYS  MVC   COPYSW,=CL3'NO '        MOVE 'NO ' TO COPYSW\nEXITCNV  L     R14,SAVEIT15            RESTORE REGISTER 14\n         BR    R14                     RETURN\n         EJECT\n*\n********************************************************************\n*                                                                  *\n*        THIS ROUTINE IS RESPONSIBLE FOR BUILDING THE TEXT UNITS   *\n*        FOR THE DYNAMIC ALLOCATION.                               *\n*                                                                  *\n********************************************************************\n*\nBLDTUNTS ST    R14,SAVEIT16            SAVE REG 14 IN SAVEIT16\n*\n**********************  TEXT UNIT 0001  ***************************\n*\n*........................  DDNAME  ...............................*\n*\n         MVC   TU01KEY,=XL2'0001'\n         MVC   TU01NUM,=XL2'0001'\n         MVC   TU01LEN,ZDDNLEN\n         MVC   TU01PRM,ZDDNAME\n         EJECT\n*\n**********************  TEXT UNIT 0052  ***************************\n*\n*.............  PERMANENTLY ALLOCATED ATTRIBUTE  .................*\n*\n         MVC   TU02KEY,=XL2'0052'\n         MVC   TU02NUM,=XL2'0000'\n         EJECT\n*\n**********************  TEXT UNIT 0018  ***************************\n*\n*......................  SYSOUT CLASS  ...........................*\n*\n         MVC   TU03KEY,=XL2'0018'\n         MVC   TU03NUM,=XL2'0001'\n         MVC   TU03LEN,=XL2'0001'\n         MVC   TU03PRM,ZSYSCLAS\n         EJECT\n*\n**********************  TEXT UNIT 001A  ***************************\n*\n*......................  FORM NUMBER  ............................*\n*\n         MVC   TU04KEY,=XL2'0000'      VOID TEXT UNIT\n*                                         IF FORM # IS NOT PROVIDED\n         CLI   ZFORM#,C' '             IS FORM # PROVIDED ?\n         BE    BLDDEST                 IF NOT, BRANCH TO BLDDEST\n         MVC   TU04KEY,=XL2'001A'\n         MVC   TU04NUM,=XL2'0001'\n         MVC   TU04LEN,=XL2'0004'\n         MVC   TU04PRM,ZFORM#\n         EJECT\n*\n**********************  TEXT UNIT 0058  ***************************\n*\n*......................  DESTINATION  ............................*\n*\nBLDDEST  MVC   TU05KEY,=XL2'0000'      VOID TEXT UNIT IF DESTINATION\n*                                         IS NOT PROVIDED\n         CLI   ZDEST,C' '              IS DESTINATION PROVIDED ?\n         BE    BLDCPYS                 IF NOT, BRANCH TO BLDCPYS\n         MVC   TU05KEY,=XL2'0058'\n         MVC   TU05NUM,=XL2'0001'\n         MVC   TU05LEN,ZDSTLEN\n         MVC   TU05PRM,ZDEST\n         EJECT\n*\n**********************  TEXT UNIT 001D  ***************************\n*\n*........................  COPIES  ...............................*\n*\nBLDCPYS  MVC   TU06KEY,=XL2'0000'      VOID TEXT UNIT IF COPIES\n*                                         IS NOT PROVIDED\n         CLI   ZCOPIES,C' '            IS COPIES PROVIDED ?\n         BE    BLDFLSH                 IF NOT, BRANCH TO BLDFLSH\n         MVC   TU06KEY,=XL2'001D'\n         MVC   TU06NUM,=XL2'0001'\n         MVC   TU06LEN,=XL2'0001'\n         MVC   TU06PRM,ZCOPIES\n         EJECT\n*\n**********************  TEXT UNIT 0067  ***************************\n*\n*.........................  FLASH  ...............................*\n*\nBLDFLSH  MVC   TU07KEY,=XL2'0000'      VOID TEXT UNIT IF FLASH\n*                                         IS NOT PROVIDED\n         CLI   ZFLASH,C' '             IS FLASH PROVIDED ?\n         BE    BLDCPMD                 IF NOT, BRANCH TO BLDCPMD\n         MVC   TU07KEY,=XL2'0067'\n         MVC   TU07NUM,=XL2'0001'\n         MVC   TU07LEN,ZFLSHLEN\n         MVC   TU07PRM,ZFLASH\n         EJECT\n*\n**********************  TEXT UNIT 0069  ***************************\n*\n*........................  COPYMOD  ..............................*\n*\nBLDCPMD  MVC   TU08KEY,=XL2'0000'      VOID TEXT UNIT IF COPYMOD\n*                                         IS NOT PROVIDED\n         CLI   ZMODIFY1,C' '           IS COPYMOD PROVIDED ?\n         BE    BLDCHRS                 IF NOT, BRANCH TO BLDCHRS\n         MVC   TU08KEY,=XL2'0069'\n         MVC   TU08NUM,=XL2'0001'\n         MVC   TU08LEN,ZMOD1LEN\n         MVC   TU08PRM,ZMODIFY1\n         EJECT\n*\n**********************  TEXT UNIT 006A  ***************************\n*\n*............  COPYMOD/CHAR REFERENCE SPECIFICATION  .............*\n*\n         MVC   TU09KEY,=XL2'0000'      VOID TEXT UNIT IF CHARS REF\n*                                         IS NOT PROVIDED\n         CLI   ZMODIFY2,C' '           IS CHARS REFERENCE PROVIDED ?\n         BE    BLDCHRS                 IF NOT, BRANCH TO BLDCHRS\n         MVC   TU09KEY,=XL2'006A'\n         MVC   TU09NUM,=XL2'0001'\n         MVC   TU09LEN,=XL2'0001'\n         CLI   ZMODIFY2,C'0'\n         BE    BLDMOD20\n         CLI   ZMODIFY2,C'1'\n         BE    BLDMOD21\n         CLI   ZMODIFY2,C'2'\n         BE    BLDMOD22\n         MVI   TU09PRM,X'03'\n         B     BLDCHRS\nBLDMOD20 MVI   TU09PRM,X'00'\n         B     BLDCHRS\nBLDMOD21 MVI   TU09PRM,X'01'\n         B     BLDCHRS\nBLDMOD22 MVI   TU09PRM,X'02'\n         EJECT\n*\n**********************  TEXT UNIT 0065  ***************************\n*\n*..............  CHARACTER ARRANGEMENT TABLE(S) ....................*\n*\nBLDCHRS  MVC   TU10KEY,=XL2'0000'      VOID TEXT UNIT IF CHARS\n*                                         IS NOT PROVIDED\n         CLI   ZCHARS1,C' '            IS CHARS PROVIDED ?\n         BE    BLDFCB                  IF NOT, BRANCH TO BLDFCB\n         MVC   TU10KEY,=XL2'0065'\n         LA    R7,1\n         CLI   ZCHARS2,C' '\n         BE    BLDCHRS2\n         A     R7,=F'1'\n         CLI   ZCHARS3,C' '\n         BE    BLDCHRS2\n         A     R7,=F'1'\n         CLI   ZCHARS4,C' '\n         BE    BLDCHRS2\n         A     R7,=F'1'\nBLDCHRS2 STH   R7,CHRSCNT\n         MVC   TU10NUM,CHRSCNT\n         MVC   TU10LN1,ZCHR1LEN\n         MVC   TU10PM1,ZCHARS1\n         CLI   ZCHARS2,C' '\n         BE    BLDFCB\n         MVC   TU10LN2,ZCHR2LEN\n         MVC   TU10PM2,ZCHARS2\n         CLI   ZCHARS3,C' '\n         BE    BLDFCB\n         MVC   TU10LN3,ZCHR3LEN\n         MVC   TU10PM3,ZCHARS3\n         CLI   ZCHARS4,C' '\n         BE    BLDFCB\n         MVC   TU10LN4,ZCHR4LEN\n         MVC   TU10PM4,ZCHARS4\n         EJECT\n*\n**********************  TEXT UNIT 0025  ***************************\n*\n*..........................  FCB  ................................*\n*\nBLDFCB   MVC   TU11KEY,=XL2'0000'      VOID TEXT UNIT IF FCB\n*                                         IS NOT PROVIDED\n         CLI   ZFCB,C' '               IS FCB PROVIDED ?\n         BE    BLDOPCD                 IF NOT, BRANCH TO BLDOPCD\n         MVC   TU11KEY,=XL2'0025'\n         MVC   TU11NUM,=XL2'0001'\n         MVC   TU11LEN,ZFCBLEN\n         MVC   TU11PRM,ZFCB\n         EJECT\n*\n**********************  TEXT UNIT 0045  ***************************\n*\n*.........................  OPTCD  ...............................*\n*\nBLDOPCD  MVC   TU12KEY,=XL2'0000'      VOID TEXT UNIT IF OPTCD\n*                                         IS NOT PROVIDED\n         CLI   ZOPTCD,C' '             IS OPTCD PROVIDED ?\n         BE    EXITBLD                 IF NOT, BRANCH TO EXITBLD\n         MVC   TU12KEY,=XL2'0045'\n         MVC   TU12NUM,=XL2'0001'\n         MVC   TU12LEN,=XL2'0001'\n         MVI   TU12PRM,X'01'\n*\n*\nEXITBLD  L     R14,SAVEIT16            RESTORE REGISTER 14\n         BR    R14                     RETURN\n         EJECT\n********************************************************************\n*                                                                  *\n*        THIS ROUTINE IS RESPONSIBLE FOR EDITING ONE BYTE THAT IS  *\n*        PASSED TO IT IN INBYTE AS FOLLOWS:                        *\n*                                                                  *\n*              IF INBYTE IS IN THE RANGE 0-9 OR A-Z                *\n*                  THEN THIS ROUTINE WILL                          *\n*                        MOVE 'YES' TO EDITSW                      *\n*                  ELSE IT WILL                                    *\n*                        MOVE 'NO ' TO EDITSW                      *\n*                                                                  *\n********************************************************************\n*\nEDITBYTE ST    R14,SAVEIT17            SAVE REG 14 IN SAVEIT17\n         MVC   EDITSW,=CL3'YES'        MOVE 'YES' TO EDITSW\n         CLI   INBYTE,C'A'             SYSOUT CLASS LT 'A'\n         BL    BADBYTE                 IF SO, BRANCH TO BADBYTE\n         CLI   INBYTE,C'Z'             SYSOUT CLASS NOT GT 'Z'\n         BNH   EXITEDIT                IF SO, BRANCH TO EXITEDIT\n         CLI   INBYTE,C'0'             SYSOUT CLASS LT '0'\n         BL    BADBYTE                 IF SO, BRANCH TO BADBYTE\n         CLI   INBYTE,C'9'             SYSOUT CLASS GT '9'\n         BH    BADBYTE                 IF SO, BRANCH TO BADBYTE\n         B     EXITEDIT                BRANCH TO EXITEDIT\nBADBYTE  MVC   EDITSW,=CL3'NO '        MOVE 'NO ' TO EDITSW\nEXITEDIT L     R14,SAVEIT17\n         BR    R14\n         EJECT\n********************************************************************\n*                                                                  *\n*        BUILD UPDTLIST (IKJUPDT PARM LIST)                        *\n*                                                                  *\n********************************************************************\n*\nINITLIST ST    R14,SAVEIT18           SAVE REG 14 CONTENTS IN SAVEIT18\n         MVC   UPDTUPT,CPPLUPT        UPT\n         MVC   UPDTECT,CPPLECT        ECT\n         LA    R9,ECB\n         ST    R9,UPDTECB             ECB\n         LA    R8,UPLIST\n         ST    R8,UPDTUPL             UPLIST\n         L     R14,SAVEIT18\n         BR    R14\n         EJECT\n********************************************************************\n*                                                                  *\n*        BUILD UPDATE PARM LIST FOR &OUTMSG AND CALL IKJUPDT       *\n*                                                                  *\n********************************************************************\n*\nSETOUTMG ST    R14,SAVEIT19        SAVE REG 14 CONTENTS IN SAVEIT19\n         LA    R9,=C'OUTMSG'       R9 ==> ADDRESS OF VAR NAME\n         ST    R9,LOCPTR           STORE ADDR OF VAR NAME IN LOCPTR\n         MVC   LOCLEN,=F'6'        LOCLEN = LENGTH OF VAR NAME\n         LA    R5,OUTMSG           R5 ==> ADDRESS OF VARIABLE\n         ST    R5,VALPTR           STORE ADDRESS OF VARIABLE IN VALPTR\n         MVC   VALLEN,=F'46'       VALLEN = LENGTH OF DATA FIELD\n         LA    R1,UPDTLIST         R1 ==> IKJUPDT PARM LIST\n         CALL  IKJUPDT             DO THE UPDATE\n         L     R14,SAVEIT19\n         BR    R14\n         EJECT\n********************************************************************\n*                                                                  *\n*        THIS ROUTINE IS RESPONSIBLE FOR DETERMINING WHETHER THIS  *\n*        COMMAND WAS INVOKED BY A CLIST OR WAS ENTERED DIRECTLY    *\n*                                                                  *\n*        IF THIS COMMAND WAS INVOKED BY A CLIST,                   *\n*           THEN THIS ROUTINE MOVES 'YES' TO BYCLIST               *\n*                                                                  *\n*        IF THIS COMMAND WAS ENTERED DIRECTLY (SPF 6 OR AT 'READY')*\n*           THEN THIS ROUTINE MOVES 'NO ' TO BYCLIST               *\n*                                                                  *\n********************************************************************\n*\nWHOCALLD ST    R14,SAVEIT21        SAVE REG 14 CONTENTS IN SAVEIT21\n         L     R6,CPPLADDR         R6===> ADDRESS OF CPPL\n         L     R7,12(R6)           R7===> ADDRESS OF ECT\n         L     R8,4(R7)            R8===> ADDRESS OF IOSRL\n         L     R9,0(R8)            R9===> ADDRESS OF TOP OF STACK\n         TM    0(R9),X'08'         ARE WE CALLED BY A CLIST ?\n         BO    CLISTER             IF SO, BRANCH TO CLISTER\n         MVC   BYCLIST,=CL3'NO '   MOVE 'NO ' TO BYCLIST\n         B     EXITWHOC            BRANCH TO EXITWHOC\nCLISTER  MVC   BYCLIST,=CL3'YES'   MOVE 'YES' TO BYCLIST\nEXITWHOC L     R14,SAVEIT21\n         BR    R14\n         EJECT\n********************************************************************\n*                                                                  *\n*        THIS ROUTINE IS RESPONSIBLE FOR WRITING OUTMSG TO THE     *\n*        TERMINAL IF AND ONLY IF AN ERROR HAS OCCURED              *\n*                                                                  *\n********************************************************************\n*\nPUT2TERM ST    R14,SAVEIT22        SAVE REG 14 CONTENTS IN SAVEIT22\n         C     R4,=F'0'            WAS NO ERROR ENCOUNTERED ?\n         BE    EXITPUTT            IF NOT, BRANCH TO EXITPUTT\n*\n         L     R6,CPPLADDR         R6===> ADDRESS OF CPPL\n         L     R10,4(R6)           R10==> ADDRESS OF UPT\n         L     R9,12(R6)           R9===> ADDRESS OF ECT\n         MVC   PUTMSG(2),=H'50'\n         MVC   PUTMSG+2(2),=H'0'\n         MVC   PUTMSG+4(46),OUTMSG\n         LA    R8,PUTMSG           R8===> ADDR OF PUTLINE OUTPUT LINE\n*\n         PUTLINE  PARM=PUTLIST,UPT=(R10),ECT=(R9),ECB=ECB,             X\n               OUTPUT=((R8),TERM,SINGLE,DATA),MF=(E,IOPL)\n*\nEXITPUTT L     R14,SAVEIT22\n         BR    R14\n         EJECT\n********************************************************************\n*                                                                  *\n*        E N D   O F   J O B   R O U T I N E                       *\n*                                                                  *\n********************************************************************\n*\nSHUTDOWN LR   R15,R4\n         LEAVER\n         EJECT\n         SPACE 3\n********************************************************************\n*                                                                  *\n*        D A T A   A R E A   C O N S T A N T S                     *\n*                                                                  *\n********************************************************************\n*\nGOODMSG  DC    CL46'SUCCESSFUL COMPLETION                         '\nERRMSG1  DC    CL46'INVALID SYNTAX OF ONE OR MORE OPERANDS        '\nERRMSG2  DC    CL46'DDNAME PARAMETER MISSING                      '\nERRMSG3  DC    CL46'DYNAMIC DEALLOC ERROR (ERR REASON CODE =     )'\nERRMSG4  DC    CL46'SYSOUT CLASS PARAMETER MISSING                '\nERRMSG5  DC    CL46'INVALID FORM NUMBER                           '\nERRMSG6  DC    CL46'INVALID DESTINATION                           '\nERRMSG7  DC    CL46'DYNAMIC ALLOC ERROR (ERR REASON CODE =     )  '\nERRMSG8  DC    CL46'INVALID NUMBER OF COPIES SPECIFIED            '\nERRMSG9  DC    CL46'INVALID SYSOUT CLASS                          '\nERRMSG10 DC    CL46'INVALID FCB                                   '\nERRMSG11 DC    CL46'INVALID FLASH NAME                            '\nERRMSG12 DC    CL46'INVALID OPTCD (OPTCD J IS ONLY VALID VALUE)   '\nERRMSG13 DC    CL46'INVALID CHARS PARAMETER                       '\nERRMSG14 DC    CL46'INVALID MODIFY PARAMETER                      '\nOUTMSG   DS    CL46\nHEXOUT   DS    CL4\nHEXINPUT DS    XL2\nCHARLEN  DS    BL2\nCNVTYPE  DS    CL3\nWHICHONE DS    PL2\nPACKED1  DC    PL2'1'\nPACKED2  DC    PL2'2'\nPACKED3  DC    PL2'3'\nPACKED4  DC    PL2'4'\nCHRSCNT  DS    H\n*\n*\n*\n*\n         EJECT\n         SPACE 3\n*\n********************************************************************\n*                                                                  *\n*        DATA STRUCTURE FOR FREEING OF DDNAME                      *\n*                                                                  *\n********************************************************************\n*\n         SPACE 3\n         DS    0F\nFREEPARM DC    X'80'         TURN ON HIGH ORDER BIT\n         DC    AL3(FREERB)   ADDRESS OF REQUEST BLOCK\nFREERB   DC    X'14'         S99RBLN (LENGTH OF REQUEST BLOCK)\n         DC    X'02'         S99VERB (REQUEST FOR UNALLOCATION)\n         DC    X'2000'       S99FLAG1 (DO NOT MOUNT VOLUMES)\nFREERRCD DC    X'0000'       S99ERROR (ERROR REASON CODE)\n         DC    X'0000'       S99INFO (INFORMATION REASON CODE)\n         DC    A(FREETUPL)   S99TXTPP (ADDR OF POINTER TO TEXT UNIT)\n         DC    X'00000000'   RESERVED\n         DC    X'00000000'   S99FLAG2\nFREETUPL DC    A(FREEUNT1)   ADDRESS OF TEXT UNIT #1\n         DC    X'80'         TURN ON HIGH ORDER BIT\n         DC    AL3(FREEUNT2) ADDRESS OF TEXT UNIT #2\nFREEUNT1 DC    X'0001'\n         DC    X'0001'\nFREEUT1A DS    BL2           LENGTH OF DDNAME\nFREEUT1B DS    CL8           DDNAME\nFREEUNT2 DC    X'0007'\n         DC    X'0000'       FREE EVEN IF PERM ALLOC ATTR IS ON\n         EJECT\n*\n********************************************************************\n*                                                                  *\n*        DATA STRUCTURE FOR DYNAMIC ALLOCATION                     *\n*                                                                  *\n********************************************************************\n*\n         SPACE 3\n         DS    0F\nDD1PARM  DC    X'80'         TURN ON HIGH ORDER BIT\n         DC    AL3(DD1RB)    ADDRESS OF REQUEST BLOCK\nDD1RB    DC    X'14'         S99RBLN (LENGTH OF REQUEST BLOCK)\n         DC    X'01'         S99VERB (REQUEST FOR DSNAME ALLOC)\n         DC    X'2000'       S99FLAG1 (DO NOT MOUNT VOLUMES)\nDD1ERRCD DC    X'0000'       S99ERROR (ERROR REASON CODE)\n         DC    X'0000'       S99INFO (INFORMATION REASON CODE)\n         DC    A(DD1TUPL)    S99TXTPP (ADDR OF POINTERS TO TEXT UNITS\n         DC    X'00000000'   RESERVED\n         DC    X'00000000'   S99FLAG2\nDD1TUPL  DC    A(TU01KEY)    ADDRESS OF TEXT UNIT #1\n         DC    A(TU02KEY)    ADDRESS OF TEXT UNIT #2\n         DC    A(TU03KEY)    ADDRESS OF TEXT UNIT #3\n         DC    A(TU04KEY)    ADDRESS OF TEXT UNIT #4\n         DC    A(TU05KEY)    ADDRESS OF TEXT UNIT #5\n         DC    A(TU06KEY)    ADDRESS OF TEXT UNIT #6\n         DC    A(TU07KEY)    ADDRESS OF TEXT UNIT #7\n         DC    A(TU08KEY)    ADDRESS OF TEXT UNIT #8\n         DC    A(TU09KEY)    ADDRESS OF TEXT UNIT #9\n         DC    A(TU10KEY)    ADDRESS OF TEXT UNIT #10\n         DC    A(TU11KEY)    ADDRESS OF TEXT UNIT #11\n         DC    XL1'80'       HIGH ORDER BIT OF TEXT UNIT #12\n         DC    AL3(TU12KEY)  ADDRESS OF TEXT UNIT #12\n*\nTU01KEY  DS    XL2           DDNAME\nTU01NUM  DS    XL2\nTU01LEN  DS    XL2\nTU01PRM  DS    CL8\n*\nTU02KEY  DS    XL2           PERMANENTLY ALLOCATED ATTRIBUTE\nTU02NUM  DS    XL2\n*\nTU03KEY  DS    XL2           SYSOUT CLASS\nTU03NUM  DS    XL2\nTU03LEN  DS    XL2\nTU03PRM  DS    CL1\n*\nTU04KEY  DS    XL2           FORM NUMBER\nTU04NUM  DS    XL2\nTU04LEN  DS    XL2\nTU04PRM  DS    CL4\n*\nTU05KEY  DS    XL2           DESTINATION\nTU05NUM  DS    XL2\nTU05LEN  DS    XL2\nTU05PRM  DS    CL8\n*\nTU06KEY  DS    XL2           COPIES\nTU06NUM  DS    XL2\nTU06LEN  DS    XL2\nTU06PRM  DS    CL1\n*\nTU07KEY  DS    XL2           FLASH\nTU07NUM  DS    XL2\nTU07LEN  DS    XL2\nTU07PRM  DS    CL4\n*\nTU08KEY  DS    XL2           COPYMOD\nTU08NUM  DS    XL2\nTU08LEN  DS    XL2\nTU08PRM  DS    CL4\n*\nTU09KEY  DS    XL2           COPYMOD/CHAR REFERENCE SPECIFICATION\nTU09NUM  DS    XL2\nTU09LEN  DS    XL2\nTU09PRM  DS    CL1\n*\nTU10KEY  DS    XL2           CHARS\nTU10NUM  DS    XL2\nTU10LN1  DS    XL2\nTU10PM1  DS    CL4\nTU10LN2  DS    XL2\nTU10PM2  DS    CL4\nTU10LN3  DS    XL2\nTU10PM3  DS    CL4\nTU10LN4  DS    XL2\nTU10PM4  DS    CL4\n*\nTU11KEY  DS    XL2           FCB\nTU11NUM  DS    XL2\nTU11LEN  DS    XL2\nTU11PRM  DS    CL4\n*\nTU12KEY  DS    XL2           OPTCD\nTU12NUM  DS    XL2\nTU12LEN  DS    XL2\nTU12PRM  DS    CL1\n*\n*\n*\n         LTORG\n         EJECT\n         SPACE 3\n********************************************************************\n*                                                                  *\n*        D Y N A M I C   W O R K   A R E A                         *\n*                                                                  *\n********************************************************************\n*\nWORKAREA DSECT\nSAVEAREA DS    18F\nANS      DS    F\nECB      DS    F\nPPLA     DS    7F\nPUTLIST  PUTLINE  MF=L\nIOPL     DS    4F\nCOPYSW   DS    CL3\nPUTMSG   DS    H\n         DS    H\n         DS    CL46\nSAVEIT1  DS    F\nSAVEIT2  DS    F\nSAVEIT3  DS    F\nSAVEIT4  DS    F\nSAVEIT5  DS    F\nSAVEIT6  DS    F\nSAVEIT7  DS    F\nSAVEIT8  DS    F\nSAVEIT9  DS    F\nSAVEIT10 DS    F\nSAVEIT11 DS    F\nSAVEIT12 DS    F\nSAVEIT13 DS    F\nSAVEIT14 DS    F\nSAVEIT15 DS    F\nSAVEIT16 DS    F\nSAVEIT17 DS    F\nSAVEIT18 DS    F\nSAVEIT19 DS    F\nSAVEIT20 DS    F\nSAVEIT21 DS    F\nSAVEIT22 DS    F\nPDEWORD1 DS    F\nPDEWORD2 DS    F\nPDEWORD3 DS    F\nCPPLADDR DS    F\nPKDCPYS  DS    D\nINCOPIES DS    CL3\nEDITSW   DS    CL3\nINBYTE   DS    CL1\nBYCLIST  DS    CL3\nVALIDSW  DS    CL3\nZDDNAME  DS    CL8\nZDDNLEN  DS    H\nZSYSCLAS DS    CL1\nZFORM#   DS    CL4\nZDEST    DS    CL8\nZDSTLEN  DS    H\nZCOPIES  DS    XL1\nZFCB     DS    CL4\nZFCBLEN  DS    H\nZFLASH   DS    CL4\nZFLSHLEN DS    H\nZCHARS1  DS    CL4\nZCHR1LEN DS    H\nZCHARS2  DS    CL4\nZCHR2LEN DS    H\nZCHARS3  DS    CL4\nZCHR3LEN DS    H\nZCHARS4  DS    CL4\nZCHR4LEN DS    H\nZMODIFY1 DS    CL4\nZMOD1LEN DS    H\nZMODIFY2 DS    CL1\nZOPTCD   DS    CL1\n*\nUPDTLIST DS    0F\nUPDTUPT  DS    F\nUPDTECT  DS    F\nUPDTECB  DS    F\nUPDTUPL  DS    F\n*\nUPLIST   DS    0F\nLOCPTR   DS    AL4\nLOCLEN   DS    FL4\nVALPTR   DS    AL4\nVALLEN   DS    FL4\n*\nWORKLEN  EQU   *-WORKAREA\nSYSOUT   CSECT\n         EJECT\n********************************************************************\n*                                                                  *\n*                   P A R S E   M A C R O S                        *\n*                                                                  *\n********************************************************************\n*\nPCL      IKJPARM\nDDNAME   IKJKEYWD\n         IKJNAME 'DDNAME',SUBFLD=DDNAM,ALIAS=('FILE')\nSYSCLASS IKJKEYWD\n         IKJNAME 'SYSCLASS',SUBFLD=SYSCL,ALIAS=('SYSOUT','CLASS')\nFORM     IKJKEYWD\n         IKJNAME 'FORM',SUBFLD=FORMNO\nDEST     IKJKEYWD\n         IKJNAME 'DEST',SUBFLD=DESTIN\nCOPIES   IKJKEYWD\n         IKJNAME 'COPIES',SUBFLD=CPYS\nFCB      IKJKEYWD\n         IKJNAME 'FCB',SUBFLD=FCBSF\nCHARS    IKJKEYWD\n         IKJNAME 'CHARS',SUBFLD=CHARSSF\nFLASH    IKJKEYWD\n         IKJNAME 'FLASH',SUBFLD=FLASHSF\nMODIFY   IKJKEYWD\n         IKJNAME 'MODIFY',SUBFLD=MODIFYSF\nOPTCD    IKJKEYWD\n         IKJNAME 'OPTCD',SUBFLD=OPTCDSF\nDDNAM    IKJSUBF\nDDNSTRNG IKJPOSIT DSNAME,DDNAM\nSYSCL    IKJSUBF\nSYSSTRNG IKJIDENT 'SYS CLASS',FIRST=ANY,OTHER=ANY\nFORMNO   IKJSUBF\nFRMSTRNG IKJIDENT 'FORM NMBR',FIRST=ANY,OTHER=ANY\nDESTIN   IKJSUBF\nDSTSTRNG IKJIDENT 'DESTIN',FIRST=ANY,OTHER=ANY\nCPYS     IKJSUBF\nCPYSTRNG IKJIDENT 'COPIES',FIRST=ANY,OTHER=ANY\nFCBSF    IKJSUBF\nFCBSTRNG IKJIDENT 'FCB',FIRST=ANY,OTHER=ANY\nCHARSSF  IKJSUBF\nCHRSTRNG IKJIDENT 'CHARS',LIST,FIRST=ANY,OTHER=ANY\nFLASHSF  IKJSUBF\nFLHSTRNG IKJIDENT 'FLASH',FIRST=ANY,OTHER=ANY\nMODIFYSF IKJSUBF\nMODSTRNG IKJIDENT 'COPYMOD',LIST,FIRST=ANY,OTHER=ANY\nOPTCDSF  IKJSUBF\nOPTSTRNG IKJIDENT 'OPTCD',FIRST=ANY,OTHER=ANY\n         IKJENDP\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "SYSOUT$": {"ttr": 36872, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x00\\x7f\\x00\\x88\\x00\\x7f\\x12\\x00\\x00\\xdc\\x00\\xdc\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf2\\xf7\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-01-07T00:00:00", "modifydate": "1988-01-07T12:00:00", "lines": 220, "newlines": 220, "modlines": 0, "user": "FILE270"}, "text": "1\n                                                          SYSOUT.1\n                                                          05/02/84\n\n\n\n   COMMAND NAME:       SYSOUT\n   AUTHOR:             Jeff Sprehn\n   AGENCY:             WDPSC\n   FUNCTION:           The  SYSOUT  command  is   used  for  dynamic\n                       allocation   of   a   SYSOUT   dataset   with\n                       specification  of  such  parameters  as  form\n                       number, number of copies,  FCB, CHARS, FLASH,\n                       MODIFY, etc.   The TSO ALLOCATE  command does\n                       not  allow  the specification  of  the  above\n                       mentioned  parameters  to  be  specified  for\n                       SYSOUT datasets.\n\n\n   This command accepts  any or all of the  following parameters and\n   does the allocation:\n\n\n        DDNAME\n        SYSOUT Class\n        Form Number\n        Print Destination\n        Number of Copies\n        FCB\n        FLASH\n        OPTCD\n        Copymod\n        CHARS\n\n1\n\n\n\n                                                          SYSOUT.2\n                                                          05/02/84\n\n\n\n\n   -----------------------------------------------------------------\n   Command Operands\n   -----------------------------------------------------------------\n\n   SYSOUT  DDNAME('ddname') SYSCLASS('sysout class) -\n           FORM('form #') DEST('destination') COPIES('no of copies') -\n           FCB('fcb') FLASH('flash name') CHARS('chars') -\n           MODIFY('copymod') OPTCD('optcd')\n\n   -----------------------------------------------------------------\n\n\n   Operands -\n\n        Required -\n\n             DDNAME('ddname')         'ddname' is  the DDNAME  to be\n                                      used.     DDNAME    has    the\n                                      following alias:\n                                           FILE\n\n\n             SYSCLASS('sysout class') 'sysout class'  is the  SYSOUT\n                                      class of the SYSOUT parameter.\n                                      Normally  'A',  'B',  or  'J'.\n                                      SYSCLASS has the following two\n                                      aliases:\n                                           SYSOUT\n                                           CLASS\n\n\n\n1\n\n\n                                                          SYSOUT.3\n                                                          05/02/84\n\n\n\n        Optional -\n\n\n             FORM('form number')      'form  number'  is   the  form\n                                      number of the SYSOUT parameter\n                                      to be used.\n\n             DEST('destination')      'destination'      is      the\n                                      destination  parameter  to  be\n                                      used.\n\n             COPIES('number of copies')    'number of copies' is the\n                                      desired number of copies to be\n                                      used.\n\n             FCB('fcb')               'fcb'   is  the   3800   forms\n                                      control buffer to use.\n\n             FLASH('flash name')      'flash  name' is  the name  of\n                                      your  forms overlay  (if  this\n                                      parameter  is  omitted,  forms\n                                      overlay  'STD' will  be  used.\n                                      Request  'NULL'  if use  of  a\n                                      blank overlay is desired.)\n\n\n\n\n\n1\n\n\n                                                          SYSOUT.4\n                                                          05/02/84\n\n\n\n             CHARS('chars')           'chars'   is   the   character\n                                      arrangement  table(s) to  use.\n                                      Up    to     four    character\n                                      arrangement   tables  may   be\n                                      specified.\n\n                                      Examples:\n\n                                           CHARS(GS12)\n                                           CHARS(GS12,AD01)\n\n             OPTCD('optcd')           'optcd',  if  used,  can  only\n                                      have  a  value of  'J'.   This\n                                      indicates   that  the   second\n                                      character of every  print line\n                                      will contain a CHARS reference\n                                      character.\n\n             MODIFY('copymod')        'copymod'    is    the    copy\n                                      modification   module  to   be\n                                      used.    It   optionally   can\n                                      include   a  CHARS   reference\n                                      character.  If  this character\n                                      is  a  zero, the  first  CHARS\n                                      name  will  be   used  in  the\n                                      modification process.  If this\n                                      character is a one, the second\n                                      chars name will be used, etc.\n\n                                           Examples:\n\n                                                MODIFY(SC33)\n                                                MODIFY(SC33,2)\n\n\n1\n\n\n\n                                                          SYSOUT.5\n                                                          05/02/84\n\n\n\n   This  command will  also  make available  two  variables that  an\n   invoking CLIST may interrogate.  Below is a table of values after\n   execution of  this command  for these  two variables  &OUTMSG and\n   &LASTCC (return code).\n\n\n         &LASTCC    &OUTMSG\n\n            0       Successful completion\n            4       DDNAME parameter missing\n            8       Dynamic dealloc error (Err reason code = xxxx)\n           12       SYSOUT class parameter missing\n           16       Invalid form number\n           20       Invalid Destination\n           24       Dynamic alloc error (Err reason code = xxxx)\n           28       Invalid number of COPIES specified\n           32       Invalid SYSOUT class\n           36       Invalid FCB\n           40       Invalid FLASH name\n           44       Invalid OPTCD\n           48       Invalid CHARS parameter\n           52       Invalid MODIFY parameter\n           96       Invalid syntax of one or more operands\n\n1\n\n                                                          SYSOUT.6\n                                                          05/02/84\n\n\n\n   Examples -\n\n        1.   Allocate sysout class 'J', form  number 0173, to remote\n             19, and four copies to DDNAME = PRNTOUT.\n\n                  SYSOUT DDNAME(PRNTOUT) SYSCLASS(J) FORM(0173) -\n                       DEST(RMT19) COPIES(4)\n\n\n        2.   Allocate sysout class 'A', with FLASH=NULL, CHARS=GS10,\n             FCB=STD6, to the 3800 Page Printer, to DDNAME=OUTPRINT\n\n                  SYSOUT DDNAME(OUTPRINT) SYSCLASS(A) FLASH(NULL) -\n                       DEST(LOCAL) FCB(STD6) CHARS(GS10)\n\n\n        3.   Allocate sysout class 'A', with CHARS=(GS10,GS12,AD01),\n             MODIFY=(SC33,2), FLASH=NULL,  FCB=WD45, with  15 copies\n             routed to the 3800 Page Printer, to DDNAME=OUT01\n\n                  SYSOUT DDNAME(OUT01) SYSCLASS(A) FLASH(NULL) -\n                       DEST(LOCAL) FCB(WD45) CHARS(GS10,GS12,AD01) -\n                       MODIFY(SC33,2) COPIES(15)\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "TBLHNDLR": {"ttr": 37121, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x00\\x7f\\x00\\x88\\x00\\x7f\\x12\\x00\\x05U\\x05U\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf2\\xf7\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-01-07T00:00:00", "modifydate": "1988-01-07T12:00:00", "lines": 1365, "newlines": 1365, "modlines": 0, "user": "FILE270"}, "text": "       ID DIVISION.\n       PROGRAM-ID.  TBLHNDLR.\n      *************************************************************\n      *                                                           *\n      * 04/06/84 -                                                *\n      * Written by Jeff Sprehn - WDPSC.                           *\n      *                                                           *\n      * 05/20/85 -                                                *\n      * Modified by Kermit Kiser to use a table of select codes   *\n      *  and alternate table display panels:                      *\n      *                                                           *\n      *  Here is sequence to add new \"Z\" select code to accepted  *\n      *  list of select codes:                                    *\n      *                                                           *\n      *  SET ACTTAB = &STR(S,SEL P,PRT Z,ZIP)                     *\n      *  ISPEXEC VPUT ACTTAB SHARED                               *\n      *                                                           *\n      *  Here is sequence to use alternate table display panels:  *\n      *    (names THPNAME1,THPNAME2,THPNAME3 - must be 8 chars)  *\n      *                                                           *\n      *  SET PANAME = &STR(THPNAME)                               *\n      *  ISPEXEC VPUT PANAME SHARED                               *\n      *                                                           *\n      *************************************************************\n           EJECT\n      *************************************************************\n      *                                                           *\n      *     THIS IS A GENERAL PURPOSE DIALOG MANAGER TABLING      *\n      *     SERVICES PROGRAM.  THIS PROGRAM ACCEPTS AN INPUT      *\n      *     FILE WHICH CONTAINS THE TABLE DATA AND THEN BUILDS    *\n      *     AND DISPLAYS A TEMPORARY VIRTUAL STORAGE TABLE.       *\n      *                                                           *\n      *     THE PROGRAM PROCESS TWO (2) ACTION CODES WHICH ARE    *\n      *     AS FOLLOWS:                                           *\n      *                                                           *\n      *          S    DISPLAY DOCUMENTATION MEMBER                *\n      *          P    PRINT DOCUMENTATION MEMBER                  *\n      *                                                           *\n      *     EACH RECORD ON THE INPUT FILE (WHICH BECOMES AN       *\n      *     ENTRY IN THE TABLE) INSTRUCTS THIS PROGRAM WHICH      *\n      *     ISPF SELECT CMD TO INVOKE FOR THE ABOVE TWO           *\n      *     ACTION CODES.                                         *\n      *                                                           *\n      *                                                           *\n      *     INPUT FILE FORMAT                                     *\n      *     .................                                     *\n      *                                                           *\n      *       COLS         CONTENTS                               *\n      *       ---------    ------------------------------------   *\n      *                                                           *\n      *       001 - 002    'D1' FOR FIRST DESCRIPTION LINE        *\n      *                    'D2' FOR 2ND DESCRIPTION LINE IF ANY   *\n      *                    'D3' FOR 3RD DESCRIPTION LINE IF ANY   *\n      *       003 - 003    FILLER                                 *\n      *       004 - 073    DESCRIPTION OF ENTRY (COULD BE 1 - N   *\n      *                      COLUMNS OF DATA REPRESENTED HERE)    *\n      *                      THIS FIELD IS PROTECTED OUTPUT.      *\n      *       074 - 074    FILLER                                 *\n      *       075 - 079    FIRST 5 BYTES OF COMMAND NAME TO BE    *\n      *                      INVOKED IF THIS ENTRY IS SELECTED    *\n      *                      (SPACES IF THIS IS NOT A 'D1' REC)   *\n      *       080 - 080    FILLER                                 *\n      *       081 - 200    PARAMETERS TO PASS TO COMMAND IF THIS  *\n      *                      FIELD IS SELECTED.  THREE PARAMETERS *\n      *                      MUST BE SUPPLIED.                    *\n      *                      (SPACES IF THIS IS NOT A 'D1' REC)   *\n      *                                                           *\n      *   FOR EXAMPLE;                                            *\n      *      IF A RECORD ON THE INPUT FILE HAS 'DOC01' IN         *\n      *      RECORD POSITIONS 75-79:                              *\n      *        THEN                                               *\n      *          THE CLIST DOC01SEL WILL BE INVOKED IF THE USER   *\n      *                             SELECTED ACTION CODE = 'S'    *\n      *                    DOC01PRT WILL BE INVOKED IF THE USER   *\n      *                             SELECTED ACTION CODE = 'P'    *\n      *                                                           *\n      *************************************************************\n           EJECT\n      *************************************************************\n      *                                                           *\n      *                                                           *\n      *                                                           *\n      *     THE FIRST THREE (3) RECORDS ON THE INPUT FILE         *\n      *     HOWEVER MUST CONTAIN PANEL TITLE AND COLUMN HEADING   *\n      *     INFORMATION AS FOLLOWS:                               *\n      *                                                           *\n      *        COLUMNS       CONTENTS                             *\n      *        -------       --------------------------------     *\n      *                                                           *\n      *        001-002       'T1'  FOR THE PANEL TITLE            *\n      *                      'T2'  FOR PANEL COLUMN HEADING #1    *\n      *                      'T3'  FOR PANEL COLUMN HEADING #2    *\n      *        003-003       FILLER                               *\n      *        004-082       TITLE OR COLUMN HEADING              *\n      *        083-200       FILLER                               *\n      *                                                           *\n      *                                                           *\n      *     A PARM MUST BE PASSED TO THIS PROGRAM AS FOLLOWS:     *\n      *                                                           *\n      *        ISPEXEC SELECT PGM(TBLHNDLR) PARM(N,TTTTTTTT)      *\n      *                                                           *\n      *             WHERE:                                        *\n      *                                                           *\n      *                   N = '1' FOR USING PANEL TBLHDLR1        *\n      *                             (SINGLE SPACED ENTRIES)       *\n      *                       '2' FOR USING PANEL TBLHDLR2        *\n      *                             (DOUBLE SPACED ENTRIES)       *\n      *                       '3' FOR USING PANEL TBLHDLR3        *\n      *                             (TRIPLE SPACED ENTRIES)       *\n      *                                                           *\n      *                   TTTTTTTT =  5 - 8 BYTE TABLE NAME       *\n      *                                                           *\n      *                                                           *\n      *                                                           *\n      *     RETURN CODES                                          *\n      *     ............                                          *\n      *                                                           *\n      *         RC         MEANING                                *\n      *         ----       ------------------------------------   *\n      *                                                           *\n      *          0         SUCCESSFUL COMPLETION                  *\n      *          4         T1, T2, T3 RECORD(S) MISSING           *\n      *          8         TBCREATE FAILED                        *\n      *          12        TBADD FAILED                           *\n      *          16        INVALID OR MISSING PARM                *\n      *          20        INVALID INPUT TABLE ENTRY RECORD       *\n      *                                                           *\n      *************************************************************\n           EJECT\n       ENVIRONMENT DIVISION.\n       CONFIGURATION SECTION.\n       INPUT-OUTPUT SECTION.\n\n       FILE-CONTROL.\n\n           SELECT  INPUT-TABLE-FILE        ASSIGN UT-S-TABLEIDX.\n\n           EJECT\n       DATA DIVISION.\n\n       FILE SECTION.\n\n       FD  INPUT-TABLE-FILE\n           LABEL RECORDS ARE   STANDARD\n           RECORDING MODE IS   F\n           RECORD CONTAINS     200 CHARACTERS\n           BLOCK CONTAINS      0 RECORDS\n           DATA RECORDS ARE    TITLES-INPUT-REC\n                               DETAIL-INPUT-REC.\n\n       01  TITLES-INPUT-REC.\n           05  RECORD-ID                          PIC X(02).\n           05  FILLER                             PIC X(01).\n           05  THE-TITLE                          PIC X(79).\n           05  FILLER                             PIC X(118).\n\n       01  DETAIL-INPUT-REC.\n           05  RECORD-ID                          PIC X(02).\n           05  FILLER                             PIC X(01).\n           05  TABLE-ENTRY-DESCRIPTION            PIC X(70).\n           05  FILLER                             PIC X(01).\n           05  SELECT-CMD-NAME-1ST-5BYTES         PIC X(05).\n           05  FILLER                             PIC X(01).\n           05  SELECT-CMD-PARAMETERS              PIC X(120).\n           EJECT\n       WORKING-STORAGE SECTION.\n\n       77  RETURN-CODE-WORK      VALUE 0000       PIC 9(4).\n       77  TBCREATE-RETURN-CODE                   PIC 9(4).\n       77  TBADD-RETURN-CODE                      PIC 9(4).\n       77  TBDISPL-RETURN-CODE                    PIC 9(4).\n       77  CONTINUE-PROCESSING                    PIC X(3).\n       77  TIME-TO-QUIT                           PIC X(3).\n       77  FILE-AT-EOF                            PIC X(3).\n       77  PARAMETER-SUB                          PIC S9(8) COMP.\n       77  FIND-CMD-SUB                           PIC S9(8) COMP.\n       77  SUB1                                   PIC S9(8) COMP.\n       77  SUB2                                   PIC S9(8) COMP.\n       77  PREVIOUS-RECORD-ID                     PIC X(2).\n       77  RECORD-WAS-ADDED                       PIC X(3).\n       77  FIND-ALL                               PIC X(3).\n       77  DOCSYS-3RD-LEVEL-QUAL VALUE 'INDEXES ' PIC X(8).\n       77  RETURN-TO-0010-BEGIN                   PIC X(3).\n\n       01  NO-FIND-A-HIT-MSG.\n           05  FILLER                             PIC X(44)  VALUE\n               '    <<<<!>>>>      No hit was found         '.\n           05  FILLER     VALUE SPACES            PIC X(26).\n\n       01  PARAMETER-TABLE.\n           05  PARAMETER-BYTE OCCURS 121 TIMES    PIC X.\n\n       01  ACTTAB.\n           05  ACTENT         OCCURS 40  TIMES.\n             07  AC                  PIC X.\n             07  FILLER              PIC X.\n             07  ACT                 PIC X(3).\n             07  FILLER              PIC X.\n\n       01  BREAKDOWN-THE-COMMAND.\n           05  BYTE-1                             PIC X(01).\n           05  BYTE-2                             PIC X(01).\n           05  BYTES-3-37.\n               10  BYTES-3-5                      PIC X(03).\n               10  FILLER                         PIC X(32).\n\n       01  FIND-CMD-ARRAY.\n           05  FIND-CMD-BYTE  OCCURS  35 TIMES    PIC X.\n\n       01  ALLOCMEM-DSN-ARRAY.\n           05  ALLOCMEM-DSN-BYTE OCCURS 44 TIMES  PIC X.\n\n       01  GIVEN-QUALIFIER-ARRAY.\n           05  GIVEN-QUALIFIER-BYTE OCCURS 8 TIMES PIC X.\n\n           EJECT\n\n      *\n      *    I S P L I N K   P A R A M E T E R S\n      *\n       01  TBADD                 VALUE 'TBADD'     PIC X(5).\n       01  TBPUT                 VALUE 'TBPUT'     PIC X(5).\n       01  TBTOP                 VALUE 'TBTOP'     PIC X(5).\n       01  TBEND                 VALUE 'TBEND'     PIC X(5).\n       01  TBDISPL-CURSOR-LOC                      PIC X(8).\n       01  TBDISPL               VALUE 'TBDISPL'   PIC X(7).\n       01  TBCREATE              VALUE 'TBCREATE'  PIC X(8).\n       01  TBCREATE-KEYS-LIST    VALUE SPACES      PIC X(8).\n       01  TBCREATE-NAME-LIST-1                    PIC X(36) VALUE\n           '(ACTCODE ENTRYDS1 CMDBUF15 CMDBUFPR)'.\n       01  TBCREATE-NAME-LIST-2                    PIC X(45) VALUE\n           '(ACTCODE ENTRYDS1 ENTRYDS2 CMDBUF15 CMDBUFPR)'.\n       01  TBCREATE-NAME-LIST-3                    PIC X(54) VALUE\n           '(ACTCODE ENTRYDS1 ENTRYDS2 ENTRYDS3 CMDBUF15 CMDBUFPR)'.\n       01  NOWRITE               VALUE 'NOWRITE'   PIC X(7).\n       01  TABLE-NAME            VALUE SPACES      PIC X(8).\n       01  PANEL-NAME.\n           05 THPNAME                              PIC X(7).\n           05 PLINES                               PIC X.\n       01  MESSAGE-ID                              PIC X(8).\n       01  VDEFINE               VALUE 'VDEFINE'   PIC X(7).\n       01  CHAR                  VALUE 'CHAR'      PIC X(4).\n       01  LENGTH-FIELD                            PIC S9(8) COMP.\n       01  KONTROL               VALUE 'CONTROL'   PIC X(7).\n       01  KANCEL                VALUE 'CANCEL'    PIC X(6).\n       01  ERRORS                VALUE 'ERRORS'    PIC X(6).\n       01  RETERN                VALUE 'RETURN'    PIC X(6).\n       01  SELEKT                VALUE 'SELECT'    PIC X(6).\n       01  VGET                  VALUE 'VGET'      PIC X(4).\n       01  VPUT                  VALUE 'VPUT'      PIC X(4).\n       01  PROFYLE               VALUE 'PROFILE'   PIC X(7).\n       01  SHARED                VALUE 'SHARED'    PIC X(6).\n       01  BUFFER.\n           05  FILLER            VALUE 'CMD(%'     PIC X(5).\n           05  SELECT-CMD-NAME.\n               10  SELECT-CMD-NAME-1ST-5BYTES      PIC X(5).\n               10  SELECT-CMD-NAME-LAST-3BYTES     PIC X(3).\n           05  FILLER            VALUE SPACE       PIC X(1).\n           05  REMAINING-SELECT-CMD-BUFFER         PIC X(121).\n           EJECT\n      *\n      *    S P F   S Y M B O L I C   N A M E S\n      *\n       01  SPF-SYMBOLIC-NAMES.\n           05  ZCMD     VALUE '(ZCMD)'             PIC X(6).\n           05  ACTCODE  VALUE '(ACTCODE)'          PIC X(9).\n           05  ENTRYDS1 VALUE '(ENTRYDS1)'         PIC X(10).\n           05  ENTRYDS2 VALUE '(ENTRYDS2)'         PIC X(10).\n           05  ENTRYDS3 VALUE '(ENTRYDS3)'         PIC X(10).\n           05  CMDBUF15 VALUE '(CMDBUF15)'         PIC X(10).\n           05  CMDBUFPR VALUE '(CMDBUFPR)'         PIC X(10).\n           05  PANTITLE VALUE '(PANTITLE)'         PIC X(10).\n           05  PANCOLH1 VALUE '(PANCOLH1)'         PIC X(10).\n           05  PANCOLH2 VALUE '(PANCOLH2)'         PIC X(10).\n           05  DOCSLVL1 VALUE '(DOCSLVL1)'         PIC X(10).\n           05  DOCSLVL2 VALUE '(DOCSLVL2)'         PIC X(10).\n           05  DOCSMEM  VALUE '(DOCSMEM)'          PIC X(9).\n           05  DOCSEXIT VALUE '(DOCSEXIT)'         PIC X(10).\n           05  ZVERB    VALUE '(ZVERB)'            PIC X(7).\n           05  ACTTABLE VALUE '(ACTTAB)'           PIC X(8).\n           05  THPVAR   VALUE '(THPNAME)'          PIC X(9).\n           EJECT\n      *\n      *    C O B O L   V A R I A B L E   N A M E S\n      *\n\n       01  COBOL-VARIABLE-NAMES.\n           05  THE-COMMAND                        PIC X(37).\n           05  ACTION-CODE                        PIC X(1).\n           05  TABLE-ENTRY-DESCRIPTION-1          PIC X(70).\n           05  TABLE-ENTRY-DESCRIPTION-2          PIC X(70).\n           05  TABLE-ENTRY-DESCRIPTION-3          PIC X(70).\n           05  SELECT-CMD-NAME-1ST-5BYTES         PIC X(05).\n           05  SELECT-CMD-PARAMETERS              PIC X(120).\n           05  PANEL-TITLE                        PIC X(79).\n           05  PANEL-COL-HEAD-1                   PIC X(79).\n           05  PANEL-COL-HEAD-2                   PIC X(79).\n           05  DOCSYS-1ST-LEVEL-QUAL              PIC X(8).\n           05  DOCSYS-2ND-LEVEL-QUAL              PIC X(8).\n           05  DOCSYS-INDEXES-MEM-NAME            PIC X(8).\n           05  DOCSYS-EXIT-SWITCH                 PIC X(3).\n           05  END-OR-RETURN-SWITCH               PIC X(6).\n           EJECT\n      *\n      *    S C A N 4 H I T    P A R A M E T E R   A R E A\n      *\n\n       01  SCAN4HIT-I-O-AREA.\n           05  ARGUMENT                            PIC X(80).\n           05  ARGUMENT-LENGTH                     PIC S9(4) COMP.\n           05  TABLE-ELEMENT                       PIC X(80).\n           05  TABLE-ELEMENT-LENGTH                PIC S9(4) COMP.\n           05  HIT-SWITCH                          PIC X(3).\n           EJECT\n      *\n      *    A L L O C M E M    P A R A M E T E R   A R E A\n      *\n\n       01  ALLOCMEM-I-O-AREA.\n           05  DDNAME     VALUE 'TABLEIDX'         PIC X(8).\n           05  DSNAME                              PIC X(44).\n           05  MEMBER-NAME                         PIC X(8).\n           05  SUCCESS-INDICATOR                   PIC 9(2).\n\n           EJECT\n       LINKAGE SECTION.\n\n       01  PARM-AREA.\n           05  PARM-COUNT                             PIC S9(4) COMP.\n           05  PANEL-DESC-LINE-COUNT                  PIC X.\n           05  BYTE-2                                 PIC X.\n           05  PARM-TABLE-NAME.\n               10  BYTES-1-8.\n                   15  BYTES-1-7.\n                       20  BYTES-1-6.\n                           25  BYTES-1-5              PIC X(5).\n                           25  FILLER                 PIC X.\n                       20  FILLER                     PIC X.\n                   15  FILLER                         PIC X.\n           EJECT\n       PROCEDURE DIVISION USING PARM-AREA.\n\n           PERFORM 1000-INITIALIZATION\n              THRU 1499-EXIT-INITIALIZATION.\n\n           IF CONTINUE-PROCESSING NOT EQUAL 'YES'\n                GO TO 0090-QUIT.\n\n           MOVE 'YES' TO FIND-ALL.\n\n       0010-BEGIN.\n\n           CALL 'ISPLINK' USING VGET DOCSEXIT.\n\n           IF DOCSYS-EXIT-SWITCH OF COBOL-VARIABLE-NAMES = 'YES'\n             GO TO 0090-QUIT.\n\n           MOVE 'NO ' TO TIME-TO-QUIT.\n\n           PERFORM 1500-DO-THE-TBCREATE\n              THRU 1599-EXIT-TBCREATE.\n\n           IF CONTINUE-PROCESSING NOT EQUAL 'YES'\n                GO TO 0090-QUIT.\n\n           MOVE 'NO ' TO RECORD-WAS-ADDED.\n\n           PERFORM 2000-LOAD-TABLE\n              THRU 2999-EXIT-LOAD-TABLE\n                    UNTIL\n                       TIME-TO-QUIT = 'YES'\n                    OR\n                       CONTINUE-PROCESSING NOT EQUAL 'YES'.\n\n           CLOSE INPUT-TABLE-FILE.\n\n           IF RECORD-WAS-ADDED = 'YES'\n              NEXT SENTENCE\n           ELSE\n              MOVE SPACE TO ACTION-CODE\n              MOVE NO-FIND-A-HIT-MSG\n                TO TABLE-ENTRY-DESCRIPTION-1 OF COBOL-VARIABLE-NAMES\n              MOVE SPACES\n                TO SELECT-CMD-NAME-1ST-5BYTES OF COBOL-VARIABLE-NAMES\n              MOVE SPACES\n                TO SELECT-CMD-PARAMETERS OF COBOL-VARIABLE-NAMES\n              PERFORM 2500-DO-THE-TBADD\n                 THRU 2599-EXIT-DO-THE-TBADD.\n\n           IF CONTINUE-PROCESSING NOT EQUAL 'YES'\n              GO TO 0090-QUIT.\n\n           CALL 'ISPLINK' USING TBTOP TABLE-NAME.\n           MOVE 'TBLH100 '  TO MESSAGE-ID.\n           MOVE 'ZCMD    ' TO TBDISPL-CURSOR-LOC.\n\n       0050-DISPLAY-TABLE.\n\n           PERFORM 4000-DO-THE-TBDISPL\n              THRU 4999-EXIT-DO-THE-TBDISPL.\n\n           IF CONTINUE-PROCESSING NOT EQUAL 'YES'\n              GO TO 0090-QUIT.\n\n           PERFORM 5000-PROCESS-TABLE\n              THRU 5999-EXIT-PROCESS-TABLE.\n\n           IF RETURN-TO-0010-BEGIN = 'YES'\n               GO TO 0010-BEGIN.\n\n           CALL 'ISPLINK' USING VGET DOCSEXIT.\n\n           IF DOCSYS-EXIT-SWITCH OF COBOL-VARIABLE-NAMES = 'YES'\n               GO TO 0090-QUIT\n           ELSE\n               GO TO 0050-DISPLAY-TABLE.\n\n       0090-QUIT.\n\n           MOVE RETURN-CODE-WORK TO RETURN-CODE.\n\n           STOP RUN.\n           EJECT\n       1000-INITIALIZATION.\n\n           MOVE 'YES' TO CONTINUE-PROCESSING.\n\n      *    START CASE STATEMENT\n\n               IF PANEL-DESC-LINE-COUNT OF PARM-AREA = '1'\n                    MOVE '1' TO PLINES\n           ELSE\n               IF PANEL-DESC-LINE-COUNT OF PARM-AREA = '2'\n                    MOVE '2' TO PLINES\n           ELSE\n               IF PANEL-DESC-LINE-COUNT OF PARM-AREA = '3'\n                    MOVE '3' TO PLINES\n           ELSE\n               MOVE 'NO ' TO CONTINUE-PROCESSING\n               MOVE 0016 TO RETURN-CODE-WORK\n               GO TO 1499-EXIT-INITIALIZATION.\n\n      *    END CASE STATEMENT\n\n           IF BYTE-2 OF PARM-AREA = ','\n               NEXT SENTENCE\n           ELSE\n               MOVE 'NO ' TO CONTINUE-PROCESSING\n               MOVE 0016 TO RETURN-CODE-WORK\n               GO TO 1499-EXIT-INITIALIZATION.\n\n      *    START CASE STATEMENT\n\n               IF  PARM-COUNT = +7\n                   MOVE BYTES-1-5 OF PARM-AREA TO TABLE-NAME\n           ELSE\n               IF  PARM-COUNT = +8\n                   MOVE BYTES-1-6 OF PARM-AREA TO TABLE-NAME\n           ELSE\n               IF  PARM-COUNT = +9\n                   MOVE BYTES-1-7 OF PARM-AREA TO TABLE-NAME\n           ELSE\n               IF  PARM-COUNT = +10\n                   MOVE BYTES-1-8 OF PARM-AREA TO TABLE-NAME\n           ELSE\n               MOVE 'NO ' TO CONTINUE-PROCESSING\n               MOVE 0016 TO RETURN-CODE-WORK\n               GO TO 1499-EXIT-INITIALIZATION.\n\n      *    END CASE STATEMENT\n\n           MOVE +37 TO LENGTH-FIELD.\n           CALL 'ISPLINK'\n                 USING\n                    VDEFINE\n                    ZCMD\n                    THE-COMMAND OF COBOL-VARIABLE-NAMES\n                    CHAR\n                    LENGTH-FIELD.\n\n           MOVE +01 TO LENGTH-FIELD.\n           CALL 'ISPLINK'\n                 USING\n                    VDEFINE\n                    ACTCODE\n                    ACTION-CODE OF COBOL-VARIABLE-NAMES\n                    CHAR\n                    LENGTH-FIELD.\n\n           MOVE +70 TO LENGTH-FIELD.\n           CALL 'ISPLINK'\n               USING\n                  VDEFINE\n                  ENTRYDS1\n                  TABLE-ENTRY-DESCRIPTION-1 OF COBOL-VARIABLE-NAMES\n                  CHAR\n                  LENGTH-FIELD.\n\n           MOVE +70 TO LENGTH-FIELD.\n           CALL 'ISPLINK'\n               USING\n                  VDEFINE\n                  ENTRYDS2\n                  TABLE-ENTRY-DESCRIPTION-2 OF COBOL-VARIABLE-NAMES\n                  CHAR\n                  LENGTH-FIELD.\n\n           MOVE +70 TO LENGTH-FIELD.\n           CALL 'ISPLINK'\n               USING\n                  VDEFINE\n                  ENTRYDS3\n                  TABLE-ENTRY-DESCRIPTION-3 OF COBOL-VARIABLE-NAMES\n                  CHAR\n                  LENGTH-FIELD.\n\n           MOVE +5 TO LENGTH-FIELD.\n           CALL 'ISPLINK'\n               USING\n                  VDEFINE\n                  CMDBUF15\n                  SELECT-CMD-NAME-1ST-5BYTES OF COBOL-VARIABLE-NAMES\n                  CHAR\n                  LENGTH-FIELD.\n\n           MOVE +120 TO LENGTH-FIELD.\n           CALL 'ISPLINK'\n               USING\n                  VDEFINE\n                  CMDBUFPR\n                  SELECT-CMD-PARAMETERS OF COBOL-VARIABLE-NAMES\n                  CHAR\n                  LENGTH-FIELD.\n\n           MOVE +79 TO LENGTH-FIELD.\n           CALL 'ISPLINK'\n               USING\n                  VDEFINE\n                  PANTITLE\n                  PANEL-TITLE OF COBOL-VARIABLE-NAMES\n                  CHAR\n                  LENGTH-FIELD.\n\n           MOVE +79 TO LENGTH-FIELD.\n           CALL 'ISPLINK'\n               USING\n                  VDEFINE\n                  PANCOLH1\n                  PANEL-COL-HEAD-1 OF COBOL-VARIABLE-NAMES\n                  CHAR\n                  LENGTH-FIELD.\n\n           MOVE +79 TO LENGTH-FIELD.\n           CALL 'ISPLINK'\n               USING\n                  VDEFINE\n                  PANCOLH2\n                  PANEL-COL-HEAD-2 OF COBOL-VARIABLE-NAMES\n                  CHAR\n                  LENGTH-FIELD.\n\n           MOVE +8 TO LENGTH-FIELD.\n           CALL 'ISPLINK'\n               USING\n                  VDEFINE\n                  DOCSLVL1\n                  DOCSYS-1ST-LEVEL-QUAL OF COBOL-VARIABLE-NAMES\n                  CHAR\n                  LENGTH-FIELD.\n\n           MOVE +8 TO LENGTH-FIELD.\n           CALL 'ISPLINK'\n               USING\n                  VDEFINE\n                  DOCSLVL2\n                  DOCSYS-2ND-LEVEL-QUAL OF COBOL-VARIABLE-NAMES\n                  CHAR\n                  LENGTH-FIELD.\n\n           MOVE +8 TO LENGTH-FIELD.\n           CALL 'ISPLINK'\n               USING\n                  VDEFINE\n                  DOCSMEM\n                  DOCSYS-INDEXES-MEM-NAME OF COBOL-VARIABLE-NAMES\n                  CHAR\n                  LENGTH-FIELD.\n\n           MOVE +3 TO LENGTH-FIELD.\n           CALL 'ISPLINK'\n               USING\n                  VDEFINE\n                  DOCSEXIT\n                  DOCSYS-EXIT-SWITCH OF COBOL-VARIABLE-NAMES\n                  CHAR\n                  LENGTH-FIELD.\n\n           MOVE +6 TO LENGTH-FIELD.\n           CALL 'ISPLINK'\n               USING\n                  VDEFINE\n                  ZVERB\n                  END-OR-RETURN-SWITCH OF COBOL-VARIABLE-NAMES\n                  CHAR\n                  LENGTH-FIELD.\n\n           MOVE +200 TO LENGTH-FIELD.\n           CALL 'ISPLINK'\n               USING\n                  VDEFINE\n                  ACTTABLE\n                  ACTTAB\n                  CHAR\n                  LENGTH-FIELD.\n\n           CALL 'ISPLINK'\n               USING\n                  VGET\n                  ACTTABLE\n                  SHARED .\n           IF RETURN-CODE = 8\n              MOVE 'S' TO AC(1)\n              MOVE 'P' TO AC(2)\n              MOVE ' ' TO AC(3)\n              MOVE 'SEL' TO ACT (1)\n              MOVE 'PRT' TO ACT (2) .\n\n\n           MOVE +7 TO LENGTH-FIELD.\n           CALL 'ISPLINK'\n               USING\n                  VDEFINE\n                  THPVAR\n                  THPNAME\n                  CHAR\n                  LENGTH-FIELD.\n\n           CALL 'ISPLINK'\n               USING\n                  VGET\n                  THPVAR\n                  SHARED .\n           IF RETURN-CODE = 8\n              MOVE 'TBLHDLR' TO THPNAME.\n\n\n           PERFORM 1800-GEN-ALLOCMEM-FIELDS\n              THRU 1899-EXIT-GEN-FIELDS.\n\n           PERFORM 7000-CALL-ALLOCMEM\n              THRU 7999-EXIT-CALL-ALLOCMEM.\n\n           OPEN INPUT INPUT-TABLE-FILE.\n\n           PERFORM 3000-READ\n              THRU 3999-EXIT-READ.\n\n           IF RECORD-ID OF TITLES-INPUT-REC = 'T1'\n               MOVE THE-TITLE OF TITLES-INPUT-REC\n                 TO PANEL-TITLE\n           ELSE\n               MOVE 'NO ' TO CONTINUE-PROCESSING\n               MOVE 0004 TO RETURN-CODE-WORK\n               GO TO 1499-EXIT-INITIALIZATION.\n\n           PERFORM 3000-READ\n              THRU 3999-EXIT-READ.\n\n           IF RECORD-ID OF TITLES-INPUT-REC = 'T2'\n               MOVE THE-TITLE OF TITLES-INPUT-REC\n                 TO PANEL-COL-HEAD-1\n           ELSE\n               MOVE 'NO ' TO CONTINUE-PROCESSING\n               MOVE 0004 TO RETURN-CODE-WORK\n               GO TO 1499-EXIT-INITIALIZATION.\n\n           PERFORM 3000-READ\n              THRU 3999-EXIT-READ.\n\n           IF RECORD-ID OF TITLES-INPUT-REC = 'T3'\n               MOVE THE-TITLE OF TITLES-INPUT-REC\n                 TO PANEL-COL-HEAD-2\n           ELSE\n               MOVE 'NO ' TO CONTINUE-PROCESSING\n               MOVE 0004 TO RETURN-CODE-WORK\n               GO TO 1499-EXIT-INITIALIZATION.\n\n           CLOSE INPUT-TABLE-FILE.\n\n       1499-EXIT-INITIALIZATION.\n           EXIT.\n           EJECT\n       1500-DO-THE-TBCREATE.\n\n           CALL 'ISPLINK'\n                USING KONTROL ERRORS RETERN.\n\n           CALL 'ISPLINK' USING TBEND TABLE-NAME.\n\n           CALL 'ISPLINK'\n                USING KONTROL ERRORS KANCEL.\n\n      *    START CASE STATEMENT\n\n               IF PANEL-DESC-LINE-COUNT OF PARM-AREA = '1'\n                   CALL 'ISPLINK'\n                        USING TBCREATE\n                              TABLE-NAME\n                              TBCREATE-KEYS-LIST\n                              TBCREATE-NAME-LIST-1\n                              NOWRITE\n           ELSE\n               IF PANEL-DESC-LINE-COUNT OF PARM-AREA = '2'\n                   CALL 'ISPLINK'\n                        USING TBCREATE\n                              TABLE-NAME\n                              TBCREATE-KEYS-LIST\n                              TBCREATE-NAME-LIST-2\n                              NOWRITE\n           ELSE\n               CALL 'ISPLINK'\n                    USING TBCREATE\n                          TABLE-NAME\n                          TBCREATE-KEYS-LIST\n                          TBCREATE-NAME-LIST-3\n                          NOWRITE.\n\n      *    END CASE STATEMENT\n\n           MOVE RETURN-CODE TO TBCREATE-RETURN-CODE.\n\n           IF TBCREATE-RETURN-CODE GREATER THAN 0\n               MOVE 'NO ' TO CONTINUE-PROCESSING\n               MOVE 0008 TO RETURN-CODE-WORK\n               GO TO 1599-EXIT-TBCREATE.\n\n           PERFORM 7000-CALL-ALLOCMEM\n              THRU 7999-EXIT-CALL-ALLOCMEM.\n\n           OPEN INPUT INPUT-TABLE-FILE.\n\n           MOVE 'NO ' TO FILE-AT-EOF.\n\n           PERFORM 3000-READ\n              THRU 3999-EXIT-READ\n                   4 TIMES.\n\n           MOVE 'D0' TO  PREVIOUS-RECORD-ID.\n\n       1599-EXIT-TBCREATE.\n           EXIT.\n           EJECT\n       1800-GEN-ALLOCMEM-FIELDS.\n\n           CALL 'ISPLINK' USING VGET DOCSMEM\n\n           MOVE DOCSYS-INDEXES-MEM-NAME\n             TO MEMBER-NAME OF ALLOCMEM-I-O-AREA.\n\n           TRANSFORM MEMBER-NAME OF ALLOCMEM-I-O-AREA\n             FROM LOW-VALUES TO SPACES.\n\n           CALL 'ISPLINK' USING VGET DOCSLVL1.\n           CALL 'ISPLINK' USING VGET DOCSLVL2.\n\n           TRANSFORM DOCSYS-1ST-LEVEL-QUAL OF COBOL-VARIABLE-NAMES\n             FROM LOW-VALUES TO SPACES.\n           TRANSFORM DOCSYS-2ND-LEVEL-QUAL OF COBOL-VARIABLE-NAMES\n             FROM LOW-VALUES TO SPACES.\n\n           MOVE SPACES TO ALLOCMEM-DSN-ARRAY.\n\n           MOVE DOCSYS-1ST-LEVEL-QUAL OF COBOL-VARIABLE-NAMES\n             TO GIVEN-QUALIFIER-ARRAY.\n\n           MOVE +0 TO SUB1.\n\n       1810-BUMP-SUB1.\n\n           ADD +1 TO SUB1.\n\n           IF  (SUB1 GREATER THAN +8)\n             OR\n               (GIVEN-QUALIFIER-BYTE (SUB1) = SPACE)\n                   NEXT SENTENCE\n           ELSE\n                   MOVE GIVEN-QUALIFIER-BYTE (SUB1)\n                     TO ALLOCMEM-DSN-BYTE (SUB1)\n                   GO TO 1810-BUMP-SUB1.\n\n           MOVE SUB1 TO SUB2.\n\n           MOVE '.' TO ALLOCMEM-DSN-BYTE (SUB2).\n\n           MOVE DOCSYS-2ND-LEVEL-QUAL OF COBOL-VARIABLE-NAMES\n             TO GIVEN-QUALIFIER-ARRAY.\n\n           MOVE +0 TO SUB1.\n\n       1820-BUMP-EM-BOTH.\n\n           ADD +1 TO SUB1.\n           ADD +1 TO SUB2.\n\n           IF  (SUB1 GREATER THAN +8)\n             OR\n               (GIVEN-QUALIFIER-BYTE (SUB1) = SPACE)\n                   NEXT SENTENCE\n           ELSE\n                   MOVE GIVEN-QUALIFIER-BYTE (SUB1)\n                     TO ALLOCMEM-DSN-BYTE (SUB2)\n                   GO TO 1820-BUMP-EM-BOTH.\n\n           MOVE '.' TO ALLOCMEM-DSN-BYTE (SUB2).\n\n           MOVE DOCSYS-3RD-LEVEL-QUAL\n             TO GIVEN-QUALIFIER-ARRAY.\n\n           MOVE +0 TO SUB1.\n\n       1850-BUMP-EM-BOTH-ALSO.\n\n           ADD +1 TO SUB1.\n           ADD +1 TO SUB2.\n\n           IF  (SUB1 GREATER THAN +8)\n             OR\n               (GIVEN-QUALIFIER-BYTE (SUB1) = SPACE)\n                   NEXT SENTENCE\n           ELSE\n                   MOVE GIVEN-QUALIFIER-BYTE (SUB1)\n                     TO ALLOCMEM-DSN-BYTE (SUB2)\n                   GO TO 1850-BUMP-EM-BOTH-ALSO.\n\n           MOVE ALLOCMEM-DSN-ARRAY\n             TO DSNAME OF ALLOCMEM-I-O-AREA.\n\n       1899-EXIT-GEN-FIELDS.\n           EXIT.\n           EJECT\n       2000-LOAD-TABLE.\n\n      *    START CASE STATEMENT\n\n               IF PANEL-DESC-LINE-COUNT OF PARM-AREA = '1'\n                   PERFORM 2100-PANEL-TYPE-TBLHDLR1\n                      THRU 2199-EXIT-TYPE-TBLHDLR1\n                   GO TO 2999-EXIT-LOAD-TABLE\n           ELSE\n               IF PANEL-DESC-LINE-COUNT OF PARM-AREA = '2'\n                   PERFORM 2200-PANEL-TYPE-TBLHDLR2\n                      THRU 2299-EXIT-TYPE-TBLHDLR2\n                   GO TO 2999-EXIT-LOAD-TABLE\n           ELSE\n               PERFORM 2300-PANEL-TYPE-TBLHDLR3\n                  THRU 2399-EXIT-TYPE-TBLHDLR3\n               GO TO 2999-EXIT-LOAD-TABLE.\n\n      *    END CASE STATEMENT\n\n           EJECT\n       2100-PANEL-TYPE-TBLHDLR1.\n\n           IF FILE-AT-EOF = 'YES'\n                MOVE 'YES' TO TIME-TO-QUIT\n                GO TO 2199-EXIT-TYPE-TBLHDLR1.\n\n           IF RECORD-ID OF DETAIL-INPUT-REC = 'D1'\n               NEXT SENTENCE\n           ELSE\n               MOVE 'NO ' TO CONTINUE-PROCESSING\n               MOVE 0020 TO RETURN-CODE-WORK\n               GO TO 2199-EXIT-TYPE-TBLHDLR1.\n\n           IF FIND-ALL = 'YES'\n               GO TO 2150-LOAD-TABLE-ELEMENT.\n\n           MOVE TABLE-ENTRY-DESCRIPTION OF DETAIL-INPUT-REC\n             TO TABLE-ELEMENT OF SCAN4HIT-I-O-AREA.\n\n           TRANSFORM TABLE-ELEMENT OF SCAN4HIT-I-O-AREA\n               FROM\n                'abcdefghijklmnopqrstuvwxyz'\n               TO\n                'ABCDEFGHIJKLMNOPQRSTUVWXYZ'.\n\n           MOVE +70\n             TO TABLE-ELEMENT-LENGTH OF SCAN4HIT-I-O-AREA.\n\n           CALL 'SCAN4HIT' USING SCAN4HIT-I-O-AREA.\n\n           IF HIT-SWITCH OF SCAN4HIT-I-O-AREA = 'YES'\n               GO TO 2150-LOAD-TABLE-ELEMENT\n           ELSE\n               GO TO 2180-TAKE-ZEE-NEXT-READ.\n\n       2150-LOAD-TABLE-ELEMENT.\n\n           MOVE '_' TO ACTION-CODE.\n           MOVE TABLE-ENTRY-DESCRIPTION\n                    OF DETAIL-INPUT-REC\n             TO TABLE-ENTRY-DESCRIPTION-1\n                    OF COBOL-VARIABLE-NAMES.\n           MOVE SELECT-CMD-NAME-1ST-5BYTES\n                    OF DETAIL-INPUT-REC\n             TO SELECT-CMD-NAME-1ST-5BYTES\n                    OF COBOL-VARIABLE-NAMES.\n           MOVE SELECT-CMD-PARAMETERS\n                    OF DETAIL-INPUT-REC\n             TO SELECT-CMD-PARAMETERS\n                    OF COBOL-VARIABLE-NAMES.\n           PERFORM 2500-DO-THE-TBADD\n              THRU 2599-EXIT-DO-THE-TBADD.\n\n           IF TBADD-RETURN-CODE GREATER THAN 0\n               MOVE 'NO ' TO CONTINUE-PROCESSING\n               MOVE 0012 TO RETURN-CODE-WORK\n               GO TO 2199-EXIT-TYPE-TBLHDLR1.\n\n       2180-TAKE-ZEE-NEXT-READ.\n\n           PERFORM 3000-READ\n              THRU 3999-EXIT-READ.\n\n       2199-EXIT-TYPE-TBLHDLR1.\n           EXIT.\n           EJECT\n       2200-PANEL-TYPE-TBLHDLR2.\n\n           IF FILE-AT-EOF = 'YES'\n               MOVE 'YES' TO TIME-TO-QUIT\n               PERFORM 2500-DO-THE-TBADD\n                  THRU 2599-EXIT-DO-THE-TBADD\n               IF TBADD-RETURN-CODE GREATER THAN 0\n                   MOVE 'NO ' TO CONTINUE-PROCESSING\n                   MOVE 0012 TO RETURN-CODE-WORK\n                   GO TO 2299-EXIT-TYPE-TBLHDLR2\n               ELSE\n                   GO TO 2299-EXIT-TYPE-TBLHDLR2\n           ELSE\n               NEXT SENTENCE.\n\n           IF (RECORD-ID OF DETAIL-INPUT-REC = 'D1')\n             AND\n              (PREVIOUS-RECORD-ID NOT = 'D0')\n                   PERFORM 2500-DO-THE-TBADD\n                      THRU 2599-EXIT-DO-THE-TBADD\n                   IF TBADD-RETURN-CODE GREATER THAN 0\n                       MOVE 'NO ' TO CONTINUE-PROCESSING\n                       MOVE 0012 TO RETURN-CODE-WORK\n                       GO TO 2299-EXIT-TYPE-TBLHDLR2\n                   ELSE\n                       NEXT SENTENCE\n           ELSE\n                   NEXT SENTENCE.\n\n           IF RECORD-ID OF DETAIL-INPUT-REC = 'D1'\n               MOVE 'D1' TO PREVIOUS-RECORD-ID\n               MOVE '_' TO ACTION-CODE\n               MOVE TABLE-ENTRY-DESCRIPTION\n                        OF DETAIL-INPUT-REC\n                 TO TABLE-ENTRY-DESCRIPTION-1\n                        OF COBOL-VARIABLE-NAMES\n               MOVE SPACES\n                 TO TABLE-ENTRY-DESCRIPTION-2\n                        OF COBOL-VARIABLE-NAMES\n               MOVE SELECT-CMD-NAME-1ST-5BYTES\n                        OF DETAIL-INPUT-REC\n                 TO SELECT-CMD-NAME-1ST-5BYTES\n                        OF COBOL-VARIABLE-NAMES\n               MOVE SELECT-CMD-PARAMETERS\n                        OF DETAIL-INPUT-REC\n                 TO SELECT-CMD-PARAMETERS\n                        OF COBOL-VARIABLE-NAMES\n               PERFORM 3000-READ\n                  THRU 3999-EXIT-READ\n               GO TO 2299-EXIT-TYPE-TBLHDLR2\n           ELSE\n               NEXT SENTENCE.\n\n           IF RECORD-ID OF DETAIL-INPUT-REC = 'D2'\n               NEXT SENTENCE\n           ELSE\n               MOVE 'NO ' TO CONTINUE-PROCESSING\n               MOVE 0020 TO RETURN-CODE-WORK\n               GO TO 2299-EXIT-TYPE-TBLHDLR2.\n\n           IF PREVIOUS-RECORD-ID = 'D1'\n               MOVE 'D2' TO PREVIOUS-RECORD-ID\n               MOVE TABLE-ENTRY-DESCRIPTION\n                        OF DETAIL-INPUT-REC\n                 TO TABLE-ENTRY-DESCRIPTION-2\n                        OF COBOL-VARIABLE-NAMES\n               PERFORM 3000-READ\n                  THRU 3999-EXIT-READ\n           ELSE\n               MOVE 'NO ' TO CONTINUE-PROCESSING\n               MOVE 0020 TO RETURN-CODE-WORK.\n\n       2299-EXIT-TYPE-TBLHDLR2.\n           EXIT.\n           EJECT\n       2300-PANEL-TYPE-TBLHDLR3.\n\n           IF FILE-AT-EOF = 'YES'\n               MOVE 'YES' TO TIME-TO-QUIT\n               PERFORM 2500-DO-THE-TBADD\n                  THRU 2599-EXIT-DO-THE-TBADD\n               IF TBADD-RETURN-CODE GREATER THAN 0\n                   MOVE 'NO ' TO CONTINUE-PROCESSING\n                   MOVE 0012 TO RETURN-CODE-WORK\n                   GO TO 2399-EXIT-TYPE-TBLHDLR3\n               ELSE\n                   GO TO 2399-EXIT-TYPE-TBLHDLR3\n           ELSE\n               NEXT SENTENCE.\n\n           IF (RECORD-ID OF DETAIL-INPUT-REC = 'D1')\n             AND\n              (PREVIOUS-RECORD-ID NOT = 'D0')\n                   PERFORM 2500-DO-THE-TBADD\n                      THRU 2599-EXIT-DO-THE-TBADD\n                   IF TBADD-RETURN-CODE GREATER THAN 0\n                       MOVE 'NO ' TO CONTINUE-PROCESSING\n                       MOVE 0012 TO RETURN-CODE-WORK\n                       GO TO 2399-EXIT-TYPE-TBLHDLR3\n                   ELSE\n                       NEXT SENTENCE\n           ELSE\n                   NEXT SENTENCE.\n\n           IF RECORD-ID OF DETAIL-INPUT-REC = 'D1'\n               MOVE 'D1' TO PREVIOUS-RECORD-ID\n               MOVE '_' TO ACTION-CODE\n               MOVE TABLE-ENTRY-DESCRIPTION\n                        OF DETAIL-INPUT-REC\n                 TO TABLE-ENTRY-DESCRIPTION-1\n                        OF COBOL-VARIABLE-NAMES\n               MOVE SPACES\n                 TO TABLE-ENTRY-DESCRIPTION-2\n                        OF COBOL-VARIABLE-NAMES\n               MOVE SPACES\n                 TO TABLE-ENTRY-DESCRIPTION-3\n                        OF COBOL-VARIABLE-NAMES\n               MOVE SELECT-CMD-NAME-1ST-5BYTES\n                        OF DETAIL-INPUT-REC\n                 TO SELECT-CMD-NAME-1ST-5BYTES\n                        OF COBOL-VARIABLE-NAMES\n               MOVE SELECT-CMD-PARAMETERS\n                        OF DETAIL-INPUT-REC\n                 TO SELECT-CMD-PARAMETERS\n                        OF COBOL-VARIABLE-NAMES\n               PERFORM 3000-READ\n                  THRU 3999-EXIT-READ\n               GO TO 2399-EXIT-TYPE-TBLHDLR3\n           ELSE\n               NEXT SENTENCE.\n\n           IF RECORD-ID OF DETAIL-INPUT-REC = 'D2' OR 'D3'\n               NEXT SENTENCE\n           ELSE\n               MOVE 'NO ' TO CONTINUE-PROCESSING\n               MOVE 0020 TO RETURN-CODE-WORK\n               GO TO 2399-EXIT-TYPE-TBLHDLR3.\n\n           IF RECORD-ID OF DETAIL-INPUT-REC = 'D2'\n               IF PREVIOUS-RECORD-ID = 'D1'\n                   MOVE 'D2' TO PREVIOUS-RECORD-ID\n                   MOVE TABLE-ENTRY-DESCRIPTION\n                            OF DETAIL-INPUT-REC\n                     TO TABLE-ENTRY-DESCRIPTION-2\n                            OF COBOL-VARIABLE-NAMES\n                   PERFORM 3000-READ\n                      THRU 3999-EXIT-READ\n                   GO TO 2399-EXIT-TYPE-TBLHDLR3\n               ELSE\n                   MOVE 'NO ' TO CONTINUE-PROCESSING\n                   MOVE 0020 TO RETURN-CODE-WORK\n                   GO TO 2399-EXIT-TYPE-TBLHDLR3\n           ELSE\n               NEXT SENTENCE.\n\n           IF PREVIOUS-RECORD-ID = 'D2'\n               MOVE 'D3' TO PREVIOUS-RECORD-ID\n               MOVE TABLE-ENTRY-DESCRIPTION\n                        OF DETAIL-INPUT-REC\n                 TO TABLE-ENTRY-DESCRIPTION-3\n                        OF COBOL-VARIABLE-NAMES\n               PERFORM 3000-READ\n                  THRU 3999-EXIT-READ\n           ELSE\n               MOVE 'NO ' TO CONTINUE-PROCESSING\n               MOVE 0020 TO RETURN-CODE-WORK.\n\n       2399-EXIT-TYPE-TBLHDLR3.\n           EXIT.\n           EJECT\n       2500-DO-THE-TBADD.\n\n           CALL 'ISPLINK' USING TBADD TABLE-NAME.\n\n           MOVE RETURN-CODE TO TBADD-RETURN-CODE.\n\n           MOVE 'YES' TO RECORD-WAS-ADDED.\n\n       2599-EXIT-DO-THE-TBADD.\n           EXIT.\n\n\n       2999-EXIT-LOAD-TABLE.\n           EXIT.\n           EJECT\n       3000-READ.\n\n           READ INPUT-TABLE-FILE\n                AT END\n                    MOVE 'YES' TO FILE-AT-EOF.\n\n       3999-EXIT-READ.\n           EXIT.\n           EJECT\n       4000-DO-THE-TBDISPL.\n\n           IF BYTES-1-5 OF PARM-TABLE-NAME OF PARM-AREA = 'PRIME'\n               CALL 'ISPLINK' USING TBTOP TABLE-NAME.\n\n           CALL 'ISPLINK'\n              USING\n                 TBDISPL\n                 TABLE-NAME\n                 PANEL-NAME\n                 MESSAGE-ID\n                 TBDISPL-CURSOR-LOC.\n\n           MOVE RETURN-CODE TO TBDISPL-RETURN-CODE.\n\n           IF TBDISPL-RETURN-CODE GREATER THAN 0004\n               NEXT SENTENCE\n           ELSE\n               GO TO 4999-EXIT-DO-THE-TBDISPL.\n\n           MOVE 'NO ' TO CONTINUE-PROCESSING.\n\n           CALL 'ISPLINK' USING VGET ZVERB SHARED.\n\n           IF END-OR-RETURN-SWITCH = 'RETURN'\n               MOVE 'YES' TO DOCSYS-EXIT-SWITCH\n               CALL 'ISPLINK' USING VPUT DOCSEXIT.\n\n       4999-EXIT-DO-THE-TBDISPL.\n           EXIT.\n           EJECT\n       5000-PROCESS-TABLE.\n\n           MOVE 'TBLH100 '  TO MESSAGE-ID.\n           MOVE 'ZCMD    ' TO TBDISPL-CURSOR-LOC.\n\n           TRANSFORM ACTION-CODE\n               FROM\n                'abcdefghijklmnopqrstuvwxyz'\n               TO\n                'ABCDEFGHIJKLMNOPQRSTUVWXYZ'.\n\n           IF   (PANEL-DESC-LINE-COUNT OF PARM-AREA = '1')\n             AND\n                (THE-COMMAND NOT EQUAL SPACES)\n                    PERFORM 6000-EYEBALL-ZCMD\n                       THRU 6999-EXIT-EYEBALL-ZCMD\n                    GO TO 5999-EXIT-PROCESS-TABLE.\n\n\n      *    START SELECT CODE SCAN:\n\n           MOVE +1 TO PARAMETER-SUB.\n\n       5100-SCAN-ACTTAB.\n           IF AC (PARAMETER-SUB) = ' '\n               GO TO 5100-SCAN-X.\n           IF ACTION-CODE = AC (PARAMETER-SUB)\n                   MOVE ACT (PARAMETER-SUB)\n                              TO SELECT-CMD-NAME-LAST-3BYTES\n                   CALL 'ISPLINK' USING VPUT ENTRYDS1 PROFYLE\n                   TRANSFORM TABLE-ENTRY-DESCRIPTION-2\n                      FROM LOW-VALUES TO SPACES\n                   CALL 'ISPLINK' USING VPUT ENTRYDS2 PROFYLE\n                   TRANSFORM TABLE-ENTRY-DESCRIPTION-3\n                      FROM LOW-VALUES TO SPACES\n                   CALL 'ISPLINK' USING VPUT ENTRYDS3 PROFYLE\n                   PERFORM 5500-INVOKE-SELECT-CMD\n                      THRU 5599-EXIT-INVOKE-SELECT-CMD\n                   MOVE '_' TO ACTION-CODE\n                   CALL 'ISPLINK' USING TBPUT TABLE-NAME\n                   MOVE 'NO ' TO RETURN-TO-0010-BEGIN\n                   GO TO 5999-EXIT-PROCESS-TABLE\n           ELSE\n                   ADD +1 TO PARAMETER-SUB\n                   GO TO 5100-SCAN-ACTTAB.\n       5100-SCAN-X.\n\n           IF ACTION-CODE = ' ' OR '-' OR '_'\n               MOVE '_' TO ACTION-CODE\n               CALL 'ISPLINK' USING TBPUT TABLE-NAME\n               MOVE 'NO ' TO RETURN-TO-0010-BEGIN\n           ELSE\n               CALL 'ISPLINK' USING TBPUT TABLE-NAME\n               MOVE 'ACTCODE ' TO TBDISPL-CURSOR-LOC\n               MOVE 'TBLH101 '  TO MESSAGE-ID\n               MOVE 'NO ' TO RETURN-TO-0010-BEGIN\n               GO TO 5999-EXIT-PROCESS-TABLE.\n\n\n           IF TBDISPL-RETURN-CODE EQUAL ZEROS\n               GO TO 5999-EXIT-PROCESS-TABLE.\n\n           CALL 'ISPLINK'\n              USING\n                 TBDISPL\n                 TABLE-NAME.\n\n           MOVE RETURN-CODE TO TBDISPL-RETURN-CODE.\n\n           IF TBDISPL-RETURN-CODE GREATER THAN 0004\n               MOVE 'NO ' TO CONTINUE-PROCESSING\n               GO TO 5999-EXIT-PROCESS-TABLE.\n\n           GO TO 5000-PROCESS-TABLE.\n\n           EJECT\n       5500-INVOKE-SELECT-CMD.\n\n           MOVE SELECT-CMD-NAME-1ST-5BYTES OF COBOL-VARIABLE-NAMES\n             TO SELECT-CMD-NAME-1ST-5BYTES OF BUFFER.\n\n           PERFORM 5600-CALCULATE-BUFFER-LENGTH\n              THRU 5699-EXIT-CALC-BUFFER-LENGTH.\n\n           CALL 'ISPLINK'\n              USING\n                 SELEKT\n                 LENGTH-FIELD\n                 BUFFER.\n\n       5599-EXIT-INVOKE-SELECT-CMD.\n           EXIT.\n           EJECT\n       5600-CALCULATE-BUFFER-LENGTH.\n\n           MOVE SPACES TO PARAMETER-TABLE.\n\n           MOVE +15 TO LENGTH-FIELD.\n\n           MOVE SELECT-CMD-PARAMETERS OF COBOL-VARIABLE-NAMES\n             TO PARAMETER-TABLE.\n\n           MOVE +121 TO PARAMETER-SUB.\n\n       5650-DECREMENT-SUBSCRIPT.\n\n           SUBTRACT +1 FROM PARAMETER-SUB.\n\n           IF  (PARAMETER-SUB LESS THAN +1)\n             OR\n               (PARAMETER-BYTE (PARAMETER-SUB) NOT = SPACE)\n                    NEXT SENTENCE\n           ELSE\n                    GO TO 5650-DECREMENT-SUBSCRIPT.\n\n           ADD PARAMETER-SUB TO LENGTH-FIELD.\n\n           ADD +1 TO PARAMETER-SUB.\n           MOVE ')' TO PARAMETER-BYTE (PARAMETER-SUB).\n\n           MOVE PARAMETER-TABLE\n             TO REMAINING-SELECT-CMD-BUFFER OF BUFFER.\n\n       5699-EXIT-CALC-BUFFER-LENGTH.\n           EXIT.\n\n\n       5999-EXIT-PROCESS-TABLE.\n           EXIT.\n           EJECT\n       6000-EYEBALL-ZCMD.\n\n           MOVE 'NO ' TO RETURN-TO-0010-BEGIN.\n\n           MOVE THE-COMMAND TO BREAKDOWN-THE-COMMAND.\n\n           TRANSFORM BREAKDOWN-THE-COMMAND\n               FROM\n                'abcdefghijklmnopqrstuvwxyz'\n               TO\n                'ABCDEFGHIJKLMNOPQRSTUVWXYZ'.\n\n           TRANSFORM BREAKDOWN-THE-COMMAND\n               FROM\n                LOW-VALUES\n               TO\n                SPACES.\n\n           IF   (PANEL-DESC-LINE-COUNT OF PARM-AREA = '1')\n             AND\n                (BYTE-1 OF BREAKDOWN-THE-COMMAND = 'F')\n             AND\n                (BYTE-2 OF BREAKDOWN-THE-COMMAND = SPACE)\n             AND\n                (BYTES-3-37 OF BREAKDOWN-THE-COMMAND NOT = SPACES)\n                    NEXT SENTENCE\n           ELSE\n                    GO TO 6999-EXIT-EYEBALL-ZCMD.\n\n           MOVE 'YES' TO RETURN-TO-0010-BEGIN.\n\n           IF BYTES-3-5 OF BREAKDOWN-THE-COMMAND = 'ALL'\n               MOVE 'YES' TO FIND-ALL\n               GO TO 6999-EXIT-EYEBALL-ZCMD.\n\n           MOVE BYTES-3-37 OF BREAKDOWN-THE-COMMAND\n             TO FIND-CMD-ARRAY.\n\n           MOVE +0 TO FIND-CMD-SUB.\n\n       6100-BUMP-FIND-CMD-SUBSCRIPT.\n\n           ADD +1 TO FIND-CMD-SUB.\n\n           IF  (FIND-CMD-SUB GREATER THAN +35)\n             OR\n               (FIND-CMD-BYTE (FIND-CMD-SUB) = SPACE)\n                    SUBTRACT +1 FROM FIND-CMD-SUB\n           ELSE\n                    GO TO 6100-BUMP-FIND-CMD-SUBSCRIPT.\n\n           MOVE FIND-CMD-SUB\n             TO ARGUMENT-LENGTH OF SCAN4HIT-I-O-AREA.\n\n           MOVE BYTES-3-37 OF BREAKDOWN-THE-COMMAND\n             TO ARGUMENT OF SCAN4HIT-I-O-AREA.\n\n           MOVE 'NO ' TO FIND-ALL.\n\n       6999-EXIT-EYEBALL-ZCMD.\n           EXIT.\n           EJECT\n       7000-CALL-ALLOCMEM.\n\n           CALL 'ALLOCMEM' USING ALLOCMEM-I-O-AREA.\n\n           IF SUCCESS-INDICATOR = 00\n               NEXT SENTENCE\n           ELSE\n               DISPLAY '************  ERROR  *****************'\n               DISPLAY '  '\n               DISPLAY '**** ERROR IN SUBROUTINE ALLOCMEM ****'\n               DISPLAY '  '\n               DISPLAY 'FAILURE TO DYNAMICALLY ALLOCATE THE '\n               DISPLAY 'FOLLOWING DATASET:'\n               DISPLAY '  '\n               DISPLAY '     DSN= ' DSNAME OF ALLOCMEM-I-O-AREA\n               DISPLAY '     MEM= ' MEMBER-NAME\n                  OF ALLOCMEM-I-O-AREA\n               GO TO 0090-QUIT.\n\n       7999-EXIT-CALL-ALLOCMEM.\n           EXIT.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "TERMTYP$": {"ttr": 37636, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x00\\x7f\\x00\\x88\\x00\\x7f\\x12\\x00\\x00\\x1f\\x00\\x1f\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf2\\xf7\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-01-07T00:00:00", "modifydate": "1988-01-07T12:00:00", "lines": 31, "newlines": 31, "modlines": 0, "user": "FILE270"}, "text": "1                                                        TERMTYPE.1\n                                                         06/25/82\n\n\n  PROGRAM:       TERMTYPE\n  AUTHOR:        Kermit Kiser\n  AGENCY:        WDPSC\n  LANGUAGE:      Assembler\n  LOCATION:      WDPSC.SHARED.LOAD\n  FUNCTION:      Determine if a TSO user's  terminal is a 3270 type\n                 terminal or not.\n\n  RUN MODE:      Interactive only\n\n  TERMTYPE  is  a  program  which  can be  called  by  a  CLIST  or\n  application program  executing under TSO to  find out if  the TSO\n  user's terminal is a 3270  type terminal.  A non-zero return-code\n  indicates a 3270 terminal.\n\n  To call from a CLIST:\n       CALL 'WDPSC.SHARED.LOAD(TERMTYPE)'\n\n  To call from a COBOL Program:\n       Call 'TERMTYPE'.\n\n  NOTE:     If the  return code is  not zero,  it is the  number of\n            lines on the 3270 screen, which is normally 24.\n\n\n\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "TERMTYPE": {"ttr": 37638, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x00\\x7f\\x00\\x88\\x00\\x7f\\x12\\x00\\x00\\x17\\x00\\x17\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf2\\xf7\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-01-07T00:00:00", "modifydate": "1988-01-07T12:00:00", "lines": 23, "newlines": 23, "modlines": 0, "user": "FILE270"}, "text": "*          DATA SET 761KKTTYPE AT LEVEL 003 AS OF 02/20/79\n          TITLE  'TERMTYPE - PROGRAM TO INDICATE TERMINAL TYPE'\n*  AUTHOR: KERMIT KISER - WASHINGTON STATE DP SERVICE CENTER (WDPSC).\n*          (206) 902-3119\n*\n* THIS PROGRAM RETURNS A CODE WHICH DEPENDS ON THE TSO USERS TERMINAL:\n*      0 - TERMINAL IS A TTY TYPE\n*     24 - TERMINAL IS A 3270 TYPE\n*  IT CAN BE CALLED FROM A CLIST TO DECIDE WHEN TO USE THE KOMM CMD.\n*  THE RETURN CODE IS THEN PLACED IN CLIST VARIABLE &LASTCC.\n*\n*          DATA SET 761KKTTYPE AT LEVEL 001 AS OF 01/08/79\nTERMTYPE ENTERR\n         GTSIZE\n         LR    R15,R0             R15=SCREEN SIZE=0 IF TTY\n         LEAVER\n*\n*   WORKING STORAGE AREA - DYNAMIC\n*\nWORKAREA DSECT\nSAVEAREA DS    18F\nWORKLEN  EQU   *-WORKAREA\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "TIMECON$": {"ttr": 37640, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x00\\x7f\\x00\\x88\\x00\\x7f\\x12\\x00\\x00[\\x00[\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf2\\xf7\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-01-07T00:00:00", "modifydate": "1988-01-07T12:00:00", "lines": 91, "newlines": 91, "modlines": 0, "user": "FILE270"}, "text": "1                                                        TIMECOND.1\n                                                         03/16/83\n\n\n  PROGRAM:       TIMECOND\n  AUTHOR:        Linda Luebcke\n  AGENCY:        WDPSC\n  LANGUAGE:      Assembler\n  LOCATION:      WDPSC.SHARED.LOAD\n  FUNCTION:      Set a condition code which reflects either the day\n                 of the week,  day of the month, Julian  day of the\n                 year,  month  of the  year,  or  hour of  the  day\n                 depending upon which date or time is specified.\n\n  RUN MODE:      Batch or Interactive\n\n  This program  is intended to  provide information to  control the\n  conditional execution  of other  steps in  a jobstream.   It will\n  sense the day of  the week, month of the year,  Julian day of the\n  year, day of the  month or hour of the day  and set its condition\n  code to  a value reflecting the  result.  This value can  then be\n  tested in succeeding steps to control whether they are executed.\n\n  To execute this program, code the following:\n\n       //stepname EXEC PGM=TIMECOND,PARM='?'\n\n       ? is:     Blank (or no PARM='?') if you wish to know the day\n                      of the week.   Condition Code set is  0-6 for\n                      Sunday-Saturday.\n                 D    if you  wish to  know the  day of  the month.\n                      Condition code set is 1-31.\n                 J    if you  wish to  know the  Julian day  of the\n                      year.  Condition code set is 1-366.\n                 M    if you  wish to know  the month of  the year.\n                      Condition code set is 1-12.\n\n\n\n\n1                                                        TIMECOND.2\n                                                         03/16/83\n\n\n                 H    if  you wish  to know  the hour  of the  day.\n                      Condition code set is 0-23.\n\n  If an  invalid parameter  value is specified,  the job  step will\n  abend with an OC1.\n\n  EXAMPLES:\n\n  1.   Execute program  TUESONLY only  if the  day of  the week  is\n       Tuesday:\n\n            //STEP0   / EXEC PGM=TIMECOND,PARM=' '\n            //STEPLIB DD DSN=WDPSC.SHARED.LOAD,DISP=SHR\n            //STEPX EXEC PGM=TUESONLY,COND=(2,NE,STEP0)\n\n  2.   Execute program  AFTRNOON only  if the time  of day  is past\n       noon:\n\n                 //STEP0   / EXEC PGM=TIMECOND,PARM='H'\n                 //STEPLIB DD DSN=WDPSC.SHARED.LOAD,DISP=SHR\n                 //STEPX EXEC PGM=AFTRNOON,COND=(12,LT,STEP0)\n\n  3.   Execute program PAYDAY only if the  day of the month is 10\n\n            //STEP0   / EXEC PGM=TIMECOND,PARM='D'\n            //STEPLIB DD DSN=WDPSC.SHARED.LOAD,DISP=SHR\n            //STEPX EXEC PGM=PAYDAY,COND=(10,NE,STEP0)\n\n\n\n\n1                                                        TIMECOND.3\n                                                         03/16/83\n\n\n  4.   Execute program SUMTIMES if the day of the week is Friday or\n       if the day of the month is past the 25th of the month:\n\n            //STEP0A EXEC  PGM=TIMECOND,PARM=' '\n            //STEPLIB  DD  DSN=WDPSC.SHARED.LOAD,DISP=SHR\n            //STEP0B EXEC  PGM=TIMECOND,PARM='D'\n            //STEPLIB  DD  DSN=WDPSC.SHARED.LOAD,DISP=SHR\n            //STEPX  EXEC  PGM=SUMTIMES,COND=((5,NE,STEP0A),(25,LT,STEP0B))\n\n\n\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "TIMECOND": {"ttr": 37643, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x00\\x7f\\x00\\x88\\x00\\x7f\\x12\\x00\\x00i\\x00i\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf2\\xf7\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-01-07T00:00:00", "modifydate": "1988-01-07T12:00:00", "lines": 105, "newlines": 105, "modlines": 0, "user": "FILE270"}, "text": "//ASM00150 JOB (2100,56-D),'LLUEB 0679 T',CLASS=H,MSGCLASS=T\n//JOBCAT DD DSN=SYS1.SOFTCAT,DISP=SHR\n//       DD DSN=SYS1.USERCAT1,DISP=SHR\n//A  EXEC ASMFCL,LIBRARY='SYS1.MLPALIB',REGION=1000K,\n//      LIB3='SYS1.AMODGEN',LIB2='WDPSC.MACLIB',\n//      OPTION2='LOAD,MAP'\n//ASM.SYSIN DD *\nTIMECOND ENTERNR\n         L     R2,0(0,R1)              POINT TO SUPPLIED PARM FIELD\n         ICM   R3,3,0(R2)              LENGTH OF PARM SUPPLIED\nNOPARM   BZ    DAYOFWK                 NO PARM = DAY OF WEEK (DEFAULT)\n         CLI   2(R2),C' '              DAY OF WEEK?\n         BE    DAYOFWK\n         SPACE 1\n*\n**   INVOKE THE DATE ROUTINE FOR THE OTHER TYPES\n         LA    R1,PARMTD               POINT TO PARM LIST\n         CALL  TIMEDATE\n*\n         SPACE 1\n         CLI   2(R2),C'D'              DAY OF MONTH?\n         BE    DAYOFMTH\n         CLI   2(R2),C'Y'              YEAR?\n         BE    YEAR\n         CLI   2(R2),C'H'              HOUR OF DAY? - 24 HOUR TIME\n         BE    HOUR\n         CLI   2(R2),C'M'              MONTH OF YEAR?\n         BE    MNTHOFYR\n         CLI   2(R2),C'J'              JULIAN DAY OF YEAR?\n         BE    JULIAN\n         B     PARMERR                 BAD PARM ON EXEC CARD\n         EJECT\n*   THIS SECTION DETERMINES THE DAY OF THE WEEK  -  1 TO 7\nDAYOFWK  DS    0H\n*   INVOKE THE DATE ROUTINE FOR DAY OF WEEK\nGETDATE  LA    R1,PARML\n         CALL  DATE\n         L     R8,DATEAR\n         LA    R9,WKLST\nCKDLOOP  CLC   0(2,R9),=C'XX'           END?\n         BE    BADMESS\n         CLC   0(2,R9),DATEAR\n         BE    GDAYCNT\n         LA    R9,2(R9)\n         B     CKDLOOP\nGDAYCNT  S     R9,=A(WKLST)\n         SRL   R9,1\n         LR    R15,R9\n         B     EXIT\n         EJECT\n*   THIS SECTION DETERMINES THE MONTH OF THE YEAR - 1 THRU 12\nMNTHOFYR DS    0H\n         MVC   CHARS+2(2),STDATEAR+2     PICK UP CHARACTER MONTH\n         B     BINARY\n         SPACE 3\n*   THIS SECTION DETERMINES THE DAY OF THE MONTH - 1 THRU 31\nDAYOFMTH DS    0H\n         MVC   CHARS+2(2),STDATEAR+4     PICK UP DAY OF MONTH\n         B     BINARY\n         SPACE 3\n*   THIS SECTION DETERMINES THE YEAR  -  LAST TWO DIGITS\nYEAR     DS    0H\n         MVC   CHARS+2(2),STDATEAR       PICK UP YEAR\n         B     BINARY\n         SPACE 3\n*   THIS SECTION DETERMINES THE JULIAN DATE\nJULIAN   DS    0H\n         MVC   CHARS+1(3),JDATEAR+2      PICK UP JULIAN DATE\n         B     BINARY\n         SPACE 3\n*   THIS SECTION DETERMINES THE HOUR\nHOUR     DS    0H\n         MVC   CHARS+2(2),TIMEAR        PICK UP HOUR\n         B     BINARY\n         EJECT\n*\n*     CONVERT THE CHARACTER FIELDS TO BINARY FOR THE CONDITION CODE\n*\nBINARY   DS    0H\n         PACK  DOUBLE+5(3),CHARS(4)\n         CVB   R15,DOUBLE\n         SPACE 2\nEXIT     LEAVENR\n         EJECT\n         LTORG\n         SPACE 3\nPARMTD   DC    A(TIMEAR),A(JDATEAR),X'80',AL3(STDATEAR)\nPARML    DC    X'80',AL3(DATEAR)\nDATEAR   DS    0CL28         USED FOR DATE CALL\nTIMEAR   DS    CL8           USED FOR TIMEDATE CALL    HHMMSSHH\nJDATEAR  DS    CL5                                     YYDDD\nSTDATEAR DS    CL6                                     YYMMDD\n         DS    CL9           EXTRA FOR DATE CALL\nWKLST    DC    C'SUMOTUWETHFRSAXX'\nCHARS    DC    C'0000'\nDOUBLE   DS    8X'00'\nBADMESS  DC    X'00',C'THERE ARE ONLY 7 DAYS IN A WEEK, SORRY.'\nPARMERR  DC    X'00',C'EXEC CARD PARM NOT H, D, Y, J, M, BLANK OR NONE'\n         END\n//LKED.SYSLMOD DD DSN=WDPSC.SYSLIBRY,DISP=SHR\n//LKED.SYSLIB DD DSN=WDPSC.SYSLIBRY,DISP=SHR\n//LKED.SYSIN DD *\n   INCLUDE SYSLIB(DATE)\n   INCLUDE SYSLIB(TIMEDATE)\n   NAME TIMECOND(R)\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "TIMEDATE": {"ttr": 37646, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x00\\x7f\\x00\\x88\\x00\\x7f\\x12\\x00\\x00\\x91\\x00\\x91\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf2\\xf7\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-01-07T00:00:00", "modifydate": "1988-01-07T12:00:00", "lines": 145, "newlines": 145, "modlines": 0, "user": "FILE270"}, "text": "*          DATA SET 752ABTIMED AT LEVEL 001 AS OF 07/19/74\n         PUNCH ' ALIAS TIDATE '\n         ENTRY TIDATE         ENTRYPOINT FOR FORTRAN CALLING PROGRAMS\nTIMEDATE CSECT\nTIDATE   EQU   *\n* THIS ROUTINE RETURNS INF IN 3 AREAS PROVIDED BY THE CALLING PROG.\n* AREA ADDRESSES MUST BE GIVEN IN THIS ORDER 1)TIME HHMMSSTH 8 BYTES\n* 2)DATE-YYDDD 5 BYTES 3)DATE-YYMMDD 6 BYTES. ALL INF RETURNED IS ZONED\n* DECTMAL, ALL ZONES=X'F'.\n         SAVE  (14,12)\n         BALR  11,0\n         USING *,11\n         ST    1,PARMADDR               STORE A(ARGLIST)\n         ST    13,SAVE1+4               ADDR HSA IN SAVE1\n         LA    12,SAVE1\n         ST    12,8(13)                 ADDR SAVE1 IN HSA\n         LR    13,12                    ADDR SAVE1 IN R13\nTRYAGAIN TIME  DEC                      R1=DATE=00YYDDDC  C IS SIGN\n*                                       R0=TIME=HHMMSSTH    NO SIGN\n         ST    1,DATI\n         ST    0,TIMI\n         UNPK  DATIU,DATI+1(3)\n         MVZ   DATIU+4(1),=X'FF'        SET ZONE OF LAST DIGIT =F\n         UNPK  TIMIU(9),TIMI(5)\n         PACK  WPYY,DATIU(2)            SET UP YEAR FOR DIVIDE\n         DP    WPYY,=P'4'               QQQSRS\n         CP    WPYY+2(1),=P'0'          TEST REMAINDER=0 (= LEAP YEAR)\n         BC    7,NOTLEAP\n         AP    FEB,=P'1'                SET FEB=29\n         AP    MAXDAYS,=P'1'\nNOTLEAP  PACK  WPDDD,DATIU+2(3)         SET UP DATE FOR MO CALC\n         CP    WPDDD,MAXDAYS\n         BC    2,ERR\n         LA    3,MONTHS\nNXTMO    AP    MONTHCT,=P'1'\n         SP    WPDDD,0(2,3)\n         BC    12,MFOUND                IF 0 OR -VE\n         LA    3,2(3)                   STEP R3 BY 2\n         BC    15,NXTMO\nMFOUND   AP    WPDDD,0(2,3)\n*              AT THIS POINT SHOULD HAVE DATE AS FOLLOWS EG 31 DEC 67\n*                             DATIU     F6F7F3F6F5\n*                             MONTHCT   0125\n*                             WPDDD     000315\n         MVN   MONTHCT+1(1),=X'FF'\n         MVN   WPDDD+2(1),=X'FF'\n         MVC   DATOU(2),DATIU           SET UP YEAR\n         UNPK  DATOU+2(2),MONTHCT       SET UP MONTH\n         UNPK  DATOU+4(2),WPDDD\n         L     1,PARMADDR               A(ARGLIST)\n         L     2,0(1)                   A(ARG1)\n         MVC   0(8,2),TIMIU             FHFHFMFMFSFSFTFH\n         L     2,4(1)\n         MVC   0(5,2),DATIU             FYFYFDFDFD\n         L     2,8(1)\n         MVC   0(6,2),DATOU             FYFYFMFMFDFD\n         BAL   4,RESTORE\n         L     13,SAVE1+4\n       RETURN  (14,12),T,RC=0\nRESTORE  MVI   SW,X'FF'                 RESTORE CONST TO ORIG STATE\n         ZAP   FEB,=P'28'               ROUTINE SHOULD BE REUSEABLE\n         ZAP   MAXDAYS,=P'365'\n         ZAP   MONTHCT,=P'0'\n         BCR   15,4\nERR      WTO   'OPERATOR NOTE. COMPUTER HAS BAD DATE-PLEASE RESET.'\n         BAL   4,RESTORE\n        STIMER WAIT,DINTVL=DURATION\n         BC    15,TRYAGAIN\nSAVE1     DS    18F\nMONTHS   DS    0C\nJAN      DC    P'31'\nFEB      DC    P'28'                    CHANGES\nMAR      DC    P'31'\nAPR      DC    P'30'\nMAY      DC    P'31'\nJUN      DC    P'30'\nJUL      DC    P'31'\nAUG      DC    P'31'\nSEP      DC    P'30'\nOCT      DC    P'31'\nNOV      DC    P'30'\nDEC      DC    P'31'\nMAXDAYS  DC    P'365'                   CHANGES\nMONTHCT  DC    PL2'0'                   CHANGES\n         DS    0D\nDURATION DC    CL8'00001000'\nPARMADDR DC    A(0)\n         DS    0F\nDATI     DS    PL4                      00YYDDDC\nTIMI     DS    PL4                      HHMMSSTH\n         DC    XL1'0F'                  DUMMY PACKED SIGN\nDATIU    DS    CL5                      FYFYFDFDCD\nTIMIU    DS    CL8                      FHFHFMFMFSFSFTFH\n         DS    CL1                      B0   !YTE FOR DUMMY SIGN\nDATYMD   DS    0C\nDATYY    DS    CL2\nDATMM    DS    CL2\nDATDD    DS    CL2\nWPYY     DS    PL3\nWPDDD    DS    PL3\nSW       DC    X'FF'                    CHANGES\nDATOU    DS    CL6\n         END\nTESTDATE CSECT      TEST DRIVER FOR VARIOUS DATE PROGRAMS\n         USING TESTDATE,R15\n         SAVE  (14,12),,*\n         LR    R14,R13\n         ST    R13,SAVE+4\n         CNOP  0,4\n         BAL   R13,AROUND\n         DROP  R15\n         USING SAVE,R13\nSAVE     DC    18A(0)\nAROUND   DS    0H\n         ST    R13,8(R14)\n         CALL  TIMEDATE,(TIME,JDATE,SDATE)\n         ST    R15,RC              SAVE   RETURN CODE\n         NOP   END\n         CNOP  0,4\n         BAL   R1,SVC35\n         DC    AL2(43)        LENGTH\n         DC    XL2'8000'      MCS FLAGS\n         DC    CL6' TIME-'\nTIME     DC    CL8' '\n         DC    CL7' JDATE-'\nJDATE    DC    CL5' '\n         DC    CL7' SDATE-'\nSDATE    DC    CL6' '\n         DC    XL2'0000'      DESCRIPTOR CODES\n         DC    XL2'FFFF'      ROUTING FLAGS\nSVC35    DS    0H\n         SVC   35             WTO SVC\n         SPACE 1\nEND      EQU   *\n         L     R15,RC              RESTORE RETURN CODE\n         L     R13,SAVE+4\n       RETURN  (14,12),T,RC=(15)\nRC       DC    F'2048'\n         SPACE\nR15 EQU 15\nR14 EQU 14\nR13 EQU 13\nR1  EQU 1\nR0  EQU 0\n         END   TESTDATE\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "TN": {"ttr": 37650, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x00\\x7f\\x00\\x88\\x00\\x7f\\x12\\x00\\x00\\x03\\x00\\x03\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf2\\xf7\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-01-07T00:00:00", "modifydate": "1988-01-07T12:00:00", "lines": 3, "newlines": 3, "modlines": 0, "user": "FILE270"}, "text": "*\n* WRITTEN BY KERMIT KISER - WASHINGTON STATE DP SERVICE CENTER (WDPSC)\n*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "TRANS": {"ttr": 37889, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x00\\x7f\\x00\\x88\\x00\\x7f\\x12\\x00\\x00\\xc9\\x00\\xc9\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf2\\xf7\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-01-07T00:00:00", "modifydate": "1988-01-07T12:00:00", "lines": 201, "newlines": 201, "modlines": 0, "user": "FILE270"}, "text": "TRANSLAT TITLE '- TSO COMMAND TO TRANSLATE CLIST STRINGS'\n***********************************************************************\n*  TRANSLAT WILL TRANSLATE CHARACTERS IN A STRING TO OTHER            *\n*  CHARACTERS, OR MAY BE USED TO REORDER CHARACTERS IN A STRING.  IF  *\n*  AN OPTIONAL PAD CHARACTER IS NOT SPECIFIED, THE DEFAULT PAD SPACE  *\n*  WILL BE USED TO PAD THE RETURNED CHARACTER STRING.  THE OPERATION  *\n*  OF TRANSLATE IS THE SAME AS THE REXX FUNCTION TRANSLATE, WITH TWO  *\n*  EXCEPTIONS:                                                        *\n*                                                                     *\n*    (1)  TRANSLAT IS NOT SET UP AS A FUNCTION, AND MUST BE INVOLKED  *\n*    AS A COMMAND, WITH A VARIABLE INITIALIZED WITH THE STRING TO BE  *\n*    TRANSLATED.  THE VARIABLE MUST NOT BE ALLOWED TO SUBSTITUTE ANY  *\n*    VALUE ON INVOCATION; THEREFORE, AN AMPERSAND MUST BE OMITTED.    *\n*    (2)  TRANSLAT DOES NOT PERFORM AN UPPERCASE TRANSLATION IF THE   *\n*    TO AND FROM OPERANDS ARE OMITTED.  THERE IS A TSO/E BUILT-IN     *\n*    FUNCTION &SYSCAPS THAT WILL PERFORM UPPERCASE TRANSLATION.       *\n*                                                                     *\n*  SYNTAX:                                                            *\n*    TRANSLAT STRINGVAR '&TO' '&FROM' '.'   QUOTED STRING             *\n*                   OR                                                *\n*    TRANSLAT STRINGVAR /&TO/&FROM/./       DELIMITED STRING          *\n***********************************************************************\n         EJECT\n         REGS\nTRANSLAT CSECT\n         SAVE  (14,12),,*\n         LR    R12,R15            R12 = BASE REGISTER\n         USING TRANSLAT,R12\n         LR    R11,R1             SAVE CPPL ADDRESS\n         USING CPPL,R11\n         LA    R0,WORKLEN         LENGTH OF WORK AREA TO GETMAIN\n         GETMAIN R,LV=(0)\n         ST    R1,8(,R13)         FORWARD CHAIN\n         ST    R13,4(,R1)         BACKWARD CHAIN\n         LR    R13,R1             SAVEAREA/WORKAREA ADDRESSABILITY\n         USING WORKAREA,R13\n***********************************************************************\n*        PARSE COMMAND PARAMETERS                                     *\n***********************************************************************\n         LA    R10,PPLAREA        ADDRESS THE PARSE PARAMETER LIST\n         USING PPL,R10\n         MVC   PPLUPT,CPPLUPT     INITIALIZE\n         MVC   PPLECT,CPPLECT       PARSE\n         LA    R1,ECB                 PARAMETER\n         ST    R1,PPLECB                LIST\n         MVC   PPLPCL,=A(PARSEPCL)        CONTROL\n         LA    R1,PPLANSR                   FIELDS\n         ST    R1,PPLANS\n         MVC   PPLCBUF,CPPLCBUF\n         SR    R1,R1\n         ST    R1,PPLUWA\n         ST    R1,ECB\n         CALLTSSR EP=IKJPARS,MF=(E,PPL)\n         CH    R15,=H'0'          SUCCESSFUL ?\n         BNE   EXIT16             NO,  PARSE ERROR; RETURN TO TMP\n         L     R10,PPLANSR        YES, ADDRESS PARSE DESCRIPTOR DSECT\n         USING IKJPARMD,R10\n***********************************************************************\n*        MAKE SURE WE HAVE NECESSARY PARAMETERS                       *\n***********************************************************************\nCHKPARMS TM    VARPARM+6,X'80'    \"VARIABLE\" PARM PRESENT?\n         BZ    EXIT12             NO, EXIT RC(12)\n         TM    TOPARM+6,X'80'     \"TO\" PARM PRESENT?\n         BZ    EXIT12             NO, EXIT RC(12)\n         TM    FROMPARM+6,X'80'   \"FROM\" PARM PRESENT?\n         BZ    EXIT12             NO, EXIT RC(12)\n         CLC   TOPARM+4,=X'00000000'  \"TO\" PARM NULL?  (0 LENGTH)\n         BE    EXIT12             NO, EXIT RC(12)\n         TM    PADPARM+6,X'80'    \"PAD\" PARM PRESENT?  (OPTIONAL)\n         BZ    DEFPAD             NO, INITIALIZE WITH DEFAULT PAD\n***********************************************************************\n*        INITIALIZE PAD CHARACTER                                     *\n***********************************************************************\n         L     R4,PADPARM         R4-> PAD CHARACTER\n         MVC   PADCHAR(1),0(R4)   INITIALIZE WITH SPECIFIED PAD CHAR\n         B     GETSTR             GET STRING FROM VARIABLE\nDEFPAD   MVI   PADCHAR,C' '       INITIALIZE WITH DEFAULT PAD CHARACTER\n***********************************************************************\n*        ACCESS STRING FROM CLIST VARIABLE                            *\n***********************************************************************\nGETSTR   L     R4,VARPARM         R4-> VARIABLE NAME CONTAINING STRING\n         LA    R5,VARPARM+4       R5 = LENGTH OF VARIABLE NAME\n         MVC   VARLEN+2(2),0(R5)  LENGTH MUST BE A FULLWORD\n         MVC   TOKEN,=X'00000000' ZERO OUT TOKEN; NOT USED\n         L     R15,CVTPTR\n         L     R15,CVTTVT-CVTMAP(,R15)  ADDRESS VARIABLE ACCESS ROUTINE\n         L     R15,TSVTVACC-TSVT(,R15)\n         ST    R15,CALLADR        SAVE CALL ADDRESS FOR UPDATE\n         LTR   R15,R15            IS TSVT ADDRESS PRESENT?\n         BNZ   CALL441            YES, CALL IKJCT441\nLINK441  LINK  EP=IKJCT441,                                            X\n               PARAM=(=A(TSVERETR),VARPARM,VARLEN,STRPTR,STRLEN,TOKEN),X\n               VL=1,MF=(E,RPPL)\n         B     CHKRCODE           SKIP CALL & CHECK ACCESS RETURN CODE\nCALL441  CALL  (15),                                                   X\n               (=A(TSVERETR),VARPARM,VARLEN,STRPTR,STRLEN,TOKEN),      X\n               VL,MF=(E,RPPL)\nCHKRCODE BXLE  R15,R15,DOTRANS    DO TRANSLATE IF ACCESS SUCCESSFUL\n         C     R15,=F'80'         ARE WE IN A CLIST ENVIRONMENT?\n         BE    EXIT20             NO,  INDICATE ENVIRONMENT ERROR\n         B     EXIT4              YES, INDICATE VARIABLE SCAN ERROR\n***********************************************************************\n*        BUILD TABLE AND PERFORM STRING TRANSLATION                   *\n***********************************************************************\nTABLINIT TRANTAB ,                BUILD NORMAL 256 BYTE CODE TABLE\nDOTRANS  MVC   TRANTABL(256),TABLINIT\n         L     R4,TOPARM          R4-> CHARS TO OVERLAY TABLE WITH\n         LH    R5,TOPARM+4        R5 = NUMBER OF OVERLAY CHARACTERS\n         L     R6,FROMPARM        R6-> CHARS TO OVERLAY IN TABLE\n         LH    R7,FROMPARM+4      R7 = NUMBER OF CHARACTERS TO OVERLAY\n         LA    R9,0               CLEAR R9 FOR TABLE INDEX\nINSRTLP  IC    R8,0(,R4)          R8 = CHAR TO OVERLAY TABLE WITH\n         IC    R9,0(,R6)          R9 = CHAR TO OVERLAY IN TABLE\n         STC   R8,TRANTABL(R9)    OVERLAY CHAR IN TABLE\n         LA    R6,1(,R6)          R6-> NEXT CHAR TO OVERLAY IN TABLE\n         BCT   R5,INSRTCHR        OVERLAY WITH \"TO\" UNTIL EXAUSTED\nINSRTPAD LA    R4,PADCHAR         R4-> PAD CHARACTER TO OVERLAY WITH\n         B     EXCHECK            CHECK FOR EXAUSTED \"FROM\" STRING\nINSRTCHR LA    R4,1(,R4)          R4-> NEXT CHAR TO OVERLAY TABLE WITH\nEXCHECK  BCT   R7,INSRTLP         OVERLAY FOR LENGTH OF \"FROM\" STRING\nTRANS    L     R4,STRPTR          R4-> STRING TO BE TRANSLATED\n         L     R5,STRLEN          R5 = LENGTH OF STRING TO TRANSLATE\n         LA    R6,TRANTABL        R6-> TRANSLATION TABLE\n         EX    R5,EXTRANS         PERFORM STRING TRANSLATION\n***********************************************************************\n*        SET CLIST VARIABLE TO NEW STRING                             *\n***********************************************************************\nSETVAR   L     R4,VARPARM         R4-> VARIABLE NAME CONTAINING STRING\n         LA    R5,VARPARM+4       R5 = LENGTH OF VARIABLE NAME\n         L     R15,CALLADR        GET ADDRESS OF TSVT\n         MVC   TOKEN,=X'00000000' ZERO OUT TOKEN; NOT USED\n         LTR   R15,R15            DOES IT CONTAIN AN ACTUAL ADDRESS?\n         BNZ   CALL4412           YES, CALL IKJCT441\nLINK4412 LINK  EP=IKJCT441,                                            X\n               PARAM=(=A(TSVEUPDT),VARPARM,VARLEN,STRPTR,STRLEN,TOKEN),X\n               VL=1,MF=(E,RPPL)\n         B     CHKRC              SKIP CALL & CHECK UPDATE RETURN CODE\nCALL4412 CALL  (15),                                                   X\n               (=A(TSVEUPDT),VARPARM,VARLEN,STRPTR,STRLEN,TOKEN),      X\n               VL,MF=(E,RPPL)\nCHKRC    BXLE  R15,R15,EXIT0      INDICATE SUCCESSFUL STRING TRANSLATE\n         B     EXIT8              INDICATE VARIABLE UPDATE ERROR\n***********************************************************************\n*        SET RETURN CODE AND RETURN TO TMP                            *\n***********************************************************************\nEXIT0    LA    R15,0              SET RC(0); SUCCESSFUL\n         B     RETURN\nEXIT4    LA    R15,4              SET RC(4); VARIABLE SCAN ERROR\n         B     RETURN\nEXIT8    LA    R15,8              SET RC(8); VARIABLE MODIFY ERROR\n         B     RETURN\nEXIT12   LA    R15,12             SET RC(12); MISSING OR INVALID OPERS\n         B     RETURN\nEXIT16   LA    R15,16             SET RC(16); SEVERE PARSE ERROR\n         B     RETURN\nEXIT20   LA    R15,20             SET RC(20); NOT IN CLIST ENVIRONMENT\nRETURN   LEAVER ,                 RETURN TO TMP\n***********************************************************************\n*        PARAMETER CONTROL LIST                                       *\n***********************************************************************\nPARSEPCL IKJPARM ,                ESTABLISH PDL REFERENCE\nVARPARM  IKJIDENT 'STRING VARIABLE',FIRST=ALPHA,OTHER=ALPHANUM\nDELMTR   IKJPOSIT DELIMITER       DELIMITER BEFORE QSTRINGS\nTOPARM   IKJPOSIT STRING,SQSTRING,ASIS  REPLACEMENT CHARS FOR TRANSLATE\nFROMPARM IKJPOSIT STRING,SQSTRING,ASIS  CHARS TO TRANSLATE IN STRING\nPADPARM  IKJPOSIT STRING,SQSTRING,ASIS  CHARACTER FOR PADDING STRING\n         IKJENDP ,                END OF PCL\n         IKJCPPL ,                CPPL MAPPING\n         IKJPPL ,                 PPL MAPPING\n***********************************************************************\n*        MAP CVT FOR CALLTSSR AND IKJCT441 REFERENCE                  *\n***********************************************************************\n         IKJCVT ,                 GENERATE CVT MAP DSECT\n***********************************************************************\n*        MAP TSO VECTOR TABLE FOR IKJCT441                            *\n***********************************************************************\n         IKJTSVT ,                MAP TSVT\n***********************************************************************\n*        STATIC WORK AREA                                             *\n***********************************************************************\nTRANSLAT CSECT                    PLACE LITERALS IN MAIN CSECT\n         LTORG\nEXTRANS  TR    0(0,R4),0(R6)      EXECUTE STRING TRANSLATION\n***********************************************************************\n*        DYNAMIC WORKAREA                                             *\n***********************************************************************\nWORKAREA DSECT\nSAVEAREA DS    18F                STANDARD REGISTER SAVEAREA\nECB      DS    F                  TSSR COMMUNICATIONS ECB\nPPLAREA  DS    7F                 PARSE PARAMETER LIST\nPPLANSR  DS    F                  ADDRESS OF PDL (RETURNED BY PARSE)\nPADCHAR  DS    CL1                CHARACTER USED TO PAD\nTRANTABL DS    CL256              TRANSLATION TABLE\nVARLEN   DS    F                  LENGTH OF VARIABLE NAME\nSTRPTR   DS    F                  LOCATION OF VARIABLE CONTENTS\nSTRLEN   DS    F                  LENGTH OF VARIABLE CONTENTS (STRING)\nTOKEN    DS    F                  UNUSED, BUT REQUIRED!!!\nCALLADR  DS    F                  TSVT ADDRESS USED FOR IKJCT331 CALL\nRPPL     CALL  ,(0,0,0,0,0,0),MF=L\nWORKLEN  EQU   *-WORKAREA         LENGTH OF AREA TO GETMAIN\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "TRNEOF": {"ttr": 37893, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x00\\x7f\\x00\\x88\\x00\\x7f\\x12\\x00\\x00$\\x00$\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf2\\xf7\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-01-07T00:00:00", "modifydate": "1988-01-07T12:00:00", "lines": 36, "newlines": 36, "modlines": 0, "user": "FILE270"}, "text": "*          DATA SET 761KKTREOF AT LEVEL 001 AS OF 08/30/82\nTRNEOF CSECT\n         B     12(,15)\n         DC    CL8'TRNEOF'\n         STM   14,12,12(13)\n         LR    12,15\n         USING TRNEOF,12\n         L     2,0(,1)\n         TR    0(240,2),TABLE\n         TR    240(240,2),TABLE\n         TR    480(240,2),TABLE\n         TR    720(240,2),TABLE\n         TR    960(240,2),TABLE\n         TR    1200(240,2),TABLE\n         TR    1440(240,2),TABLE\n         TR    1680(240,2),TABLE\n         LM    14,12,12(13)\n         SR    15,15\n         BR    14\nTABLE    DC    X'400102030405060708090A0B0C0D0E0F'\n         DC    X'101112131415161718191A1B1C1D1E1F'\n         DC    X'202122232425262728292A2B2C2D2E2F'\n         DC    X'303132333435363738393A3B3C3D3E3F'\n         DC    X'404142434445464748494A4B4C4D4E4F'\n         DC    X'505152535455565758595A5B5C5D5E5F'\n         DC    X'606162636465666768696A6B6C6D6E6F'\n         DC    X'707172737475767778797A7B7C7D7E7F'\n         DC    X'808182838485868788898A8B8C8D8E8F'\n         DC    X'909192939495969798999A9B9C9D9E9F'\n         DC    X'A0A1A2A3A4A5A6A7A8A9AAABACADAEAF'\n         DC    X'B0B1B2B3B4B5B6B7B8B9BABBBCBDBEBF'\n         DC    X'C0C1C2C3C4C5C6C7C8C9CACBCCCDCECF'\n         DC    X'D0D1D2D3D4D5D6D7D8D9DADBDCDDDEDF'\n         DC    X'E0E1E2E3E4E5E6E7E8E9EAEBECEDEEEF'\n         DC    X'F0F1F2F3F4F5F6F7F8F9FAFBFCFDFEFF'\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "TUBE": {"ttr": 37895, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x00\\x7f\\x00\\x88\\x00\\x7f\\x12\\x00\\x00\\x8d\\x00\\x8d\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf2\\xf7\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-01-07T00:00:00", "modifydate": "1988-01-07T12:00:00", "lines": 141, "newlines": 141, "modlines": 0, "user": "FILE270"}, "text": "000010 IDENTIFICATION DIVISION.                                         08/30/82\n000020 PROGRAM-ID. TUBE.                                                761KKTUB\n000030 ENVIRONMENT DIVISION.                                            E  LV001\n000040 INPUT-OUTPUT SECTION.\n000050 FILE-CONTROL.\n000060     SELECT FILEOUT          ASSIGN UT-S-FILEOUT.\n000070     SELECT JOBSTREAM-FILE   ASSIGN UT-S-JOBSTREM.\n000080 DATA DIVISION.\n000090 FILE SECTION.\n000100 FD  FILEOUT\n000110     BLOCK 0\n000120     LABEL STANDARD.\n000130 01  FILEOUT-REC   PIC X(80).\n000140\n000150 FD  JOBSTREAM-FILE\n000160     BLOCK 0\n000170     LABEL STANDARD.\n000180 01  JOBSTREAM-REC PIC X(80).\n000190\n000200 WORKING-STORAGE SECTION.\n000210\n000220 77  WS-1      PIC S9(7) COMP-3 VALUE +0.\n000230 77  WS-2      PIC S9(7) COMP-3 VALUE +0.\n000240 77  WS-3      PIC S9(7) COMP-3 VALUE +80.\n000250 77  WS-4      PIC S9(7) COMP-3 VALUE +0.\n000260 77  WS-5      PIC S9(7) COMP-3 VALUE +0.\n000270 77  WS-6      PIC S9(7) COMP-3 VALUE +0.\n000280 77  WS-LENGTH PIC S9(4) COMP   VALUE +0.\n000290 77  DDNAME    PIC X(8)         VALUE 'LIBR    '.\n000300\n000310 01  MENU      PIC X(4000).\n000320\n000330 01  PASSREC.\n000340     05  IOPARM      PIC X(8) VALUE SPACES.\n000350     05  OUTLEN      PIC S9(4) COMP.\n000360     05  OUTBUFF     PIC X(4000).\n000370     05  INLEN  PIC S9(4) COMP SYNC.\n000380     05  INBUFF.\n000390         10  INREC PIC X(4000).\n000400     05  RETLEN                               PIC S9(4) COMP.\n000410     05  SCRUF.\n000420         10  SCRUFF OCCURS 24 TIMES PIC X(80).\n000430\n000440 01  SCREEN-LINE.\n000450     05  FILLER      PIC X(20) VALUE '   LENGTH OF SCREEN '.\n000460     05  SCREEN-NAME PIC X(8).\n000470     05  FILLER      PIC XXXX  VALUE ' IS '.\n000480     05  SCREEN-LENGTH   PIC 9999.\n000490     05  FILLER      PIC X(44) VALUE SPACES.\n000500\n000510 01  LINE-TABLE.\n000520     05  LINE-REC OCCURS 50 TIMES PIC X(80).\n000530\n000540 01  LOAD-NAME.\n000550     05  LOAD-MOD OCCURS 8 TIMES PIC X.\n000560\n000570 LINKAGE SECTION.\n000580\n000590 01  ARG.\n000600     05  FILLER    PIC S9(4) COMP.\n000610     05  ARG-NAME.\n000620         10  ARG-MOD OCCURS 8 TIMES PIC X.\n000630\n000640 PROCEDURE DIVISION USING ARG.\n000650\n000660 INIT-PROCEDURES.\n000670     PERFORM 120-INITIAL-PROCEDURES.\n000680\n000690 ACCESS-MOD-NAME.\n000700     PERFORM 130-ACCESS-MODULE-NAME 8 TIMES.\n000710\n000720 ACCESS-SCREEN.\n000730     PERFORM 140-ACCESS-SCREEN.\n000740\n000750 WRITE-SCREEN.\n000760     PERFORM 180-WRITE-SCREEN.\n000770\n000780 LOAD-SCRUFF.\n000790     PERFORM 190-LOAD-SCRUFF 24 TIMES.\n000800\n000810 LOAD-INBUFF.\n000820     MOVE INBUFF TO LINE-TABLE.\n000830     PERFORM 200-LOAD-INBUFF 20 TIMES.\n000840\n000850 LOAD-OUTBUFF.\n000860     PERFORM 205-SCREEN-LINE.\n000870     MOVE OUTBUFF TO LINE-TABLE.\n000880     PERFORM 210-LOAD-OUTBUFF 50 TIMES.\n000890\n000900\n000910 EOF.\n000920     CLOSE FILEOUT JOBSTREAM-FILE.\n000930     STOP RUN.\n000940\n000950 120-INITIAL-PROCEDURES SECTION.\n000960     OPEN OUTPUT FILEOUT JOBSTREAM-FILE.\n000970\n000980 130-ACCESS-MODULE-NAME SECTION.\n000990     ADD +1 TO WS-1.\n001000     IF ARG-MOD (WS-1) NUMERIC\n001010     MOVE ARG-MOD (WS-1) TO LOAD-MOD (WS-1)\n001020     GO TO 130-EXIT.\n001030     IF ARG-MOD (WS-1) ALPHABETIC\n001040     MOVE ARG-MOD (WS-1) TO LOAD-MOD (WS-1)\n001050     GO TO 130-EXIT.\n001060     MOVE SPACE TO LOAD-MOD (WS-1).\n001070 130-EXIT.\n001080\n001090 140-ACCESS-SCREEN SECTION.\n001100     CALL 'GETSCRN' USING DDNAME LOAD-NAME WS-LENGTH MENU.\n001110\n001120 180-WRITE-SCREEN SECTION.\n001130     MOVE 'SBXXXXXB' TO IOPARM.\n001140     MOVE WS-LENGTH TO OUTLEN INLEN.\n001150     MOVE SPACES TO INBUFF OUTBUFF.\n001160     MOVE MENU TO OUTBUFF.\n001170     CALL 'FULLSCR3'\n001180     USING IOPARM OUTLEN OUTBUFF INLEN INBUFF RETLEN SCRUF.\n001190\n001200 190-LOAD-SCRUFF SECTION.\n001210     ADD +1 TO WS-4.\n001220     MOVE SCRUFF (WS-4) TO JOBSTREAM-REC.\n001230     WRITE JOBSTREAM-REC.\n001240\n001250 200-LOAD-INBUFF SECTION.\n001260     ADD +1 TO WS-5.\n001270     MOVE LINE-REC (WS-5) TO FILEOUT-REC.\n001280     WRITE FILEOUT-REC.\n001290\n001300 205-SCREEN-LINE SECTION.\n001310     MOVE WS-LENGTH TO SCREEN-LENGTH.\n001320     MOVE LOAD-NAME TO SCREEN-NAME.\n001330     MOVE SCREEN-LINE TO FILEOUT-REC.\n001340     WRITE FILEOUT-REC.\n001350     MOVE SPACES TO FILEOUT-REC.\n001360     WRITE FILEOUT-REC.\n001370\n001380 210-LOAD-OUTBUFF SECTION.\n001390     ADD +1 TO WS-6.\n001400     MOVE LINE-REC (WS-6) TO FILEOUT-REC.\n001410     WRITE FILEOUT-REC.\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "UCBMAP": {"ttr": 37899, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x00\\x7f\\x00\\x88\\x00\\x7f\\x12\\x00\\x03\\x07\\x03\\x07\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf2\\xf7\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-01-07T00:00:00", "modifydate": "1988-01-07T12:00:00", "lines": 775, "newlines": 775, "modlines": 0, "user": "FILE270"}, "text": "         TITLE 'UCBMAP - DISPLAY DEVICE CHARACTERISTICS'\n*********************************************************************\n*  MODIFIED    -    05/04/84 BY KERMIT KISER FOR DYADICS (*KK1)     *\n*  MODIFIED    -    08/14/86 BY KERMIT KISER FOR IOSVSUCB(*KK2)     *\n*********************************************************************\n*  NAME        -    UCBMAP                                          *\n*                                                                   *\n*  FUNCTION    -    LIST ATTRIBUTES OF A DEVICE                     *\n*                                                                   *\n*  RESTRICTION -    16 CHANNEL SUPPORT                              *\n*                                                                   *\n*  AUTHOR      -    C. LYONS                                        *\n*                                                                   *\n*  DATE        -    01/10/80                                        *\n*                                                                   *\n*  SYNTAX      -    UCBMAP CUU(XYZ) VOL(VOLSER)                     *\n*                                                                   *\n*  ATTRIB      -    RENT                                            *\n*                                                                   *\n*  VERSION     -    1.0                                             *\n*                                                                   *\n*  ERRORS      -    CHANNEL NUMBER TOO HIGH                         *\n*                   INVALID CUU (NOT SYSGENED)                      *\n*                   CUU LENGTH INCORRECT                            *\n*                   VOLSER NOT FOUND                                *\n*                                                                   *\n*  PRIVILEGES  -    PROBLEM PROGRAM, V=V                            *\n*                                                                   *\n*  SYSTEM      -    MVS 3.8 AND MVS/SE2                             *\n*                                                                   *\n*  INPUT       -    R1 -> CPPL                                      *\n*                                                                   *\n*  OUTPUT      -            DEVICE MAP FOR CUU                      *\n*                                                                   *\n*                    STATUS         :  ONLINE                       *\n*                                      ALLOCATED                    *\n*                                      READY                        *\n*                                      NOT RESERVED                 *\n*                                      NOT BUSY                     *\n*                                      STORAGE                      *\n*                                      SHARED                       *\n*                                      021 OPEN DATASETS            *\n*                                                                   *\n*                    UNIT NAMES     :  SYSTSO  SYSDA  3350          *\n*                                                                   *\n*                    CHANNEL PATHS  :  2 PRI ONLINE  CPU 0          *\n*                                      3 SEC OFFLINE                *\n*                                                                   *\n*                    DEVICE TYPE    :  DIRECT ACCESS  - 3070500D    *\n*                                                                   *\n*                    VOLSER         :  TSO001                       *\n*                                                                   *\n*                    UCB ADDRESS    :  0000F214                     *\n*                                                                   *\n*  MACROS      -     FULLSAVE,FULLRTRN,GETMAIN,FREEMAIN,CALLTSSR,   *\n*                    TPUT,PRTLINE,IKJRLSA,IKJPARM,IKJENDP,IKJIDENT  *\n*                                                                   *\n*  DSECTS      -     WORK,CVT,IOCOM,IOX,IKJCPPL,IKJPPL,IEFUCBOB,    *\n*                    JESCT,EDT,CSD,LCH,PDL                          *\n*                                                                   *\n*  REGISTERS   -     R12 = BASE, R4 -> WORK AREA, R7 -> UCB         *\n*                                                                   *\n*  LOGIC       -     1. PARSE CUU AND VOL OPERANDS                  *\n*                    2. IF CUU PRESENT USE IT, ELSE USE VOL         *\n*                    3. SEARCH UCB TABLE, IF VOL BEING USED         *\n*                    4. IF CUU BEING USED:                          *\n*                       CONVERT CUU TO BINARY FORMAT                *\n*                       VALIDATE CUU                                *\n*                       GIVEN VALID CUU, FIND UCB ADDRESS           *\n*                    5. DISPLAY DEVICE CHARACTERISTICS:             *\n*                                                                   *\n*                       STATUS     -  DIRECTLY FROM UCB             *\n*                       UNIT NAMES -  FROM ELIGIBLE DEVICE TABLE    *\n*                       CHAN PATHS -  FROM LCH AND TCH PATH TABLE   *\n*                       DEVICE TYPE-  DIRECTLY FROM UCB             *\n*                       VOLSER     -  DIRECTLY FROM UCB             *\n*                       UCB ADDR   -  FROM UCB LOOKUP TABLE         *\n*                                                                   *\n*  INSTALL     -     ASSEMBLE UCBMAP                                *\n*                    LINK UCBMAP RENT REUS REFR                     *\n*                    PLACE UCBMAP IN LINKLIST LIB OR PLPA           *\n*                                                                   *\n*********************************************************************\n         MACRO\n&LABEL   PRTLINE\n&LABEL   LA    R1,PRTLINE\n         LA    R0,60\n         TPUT  (1),(0),R\n         MVI   PRTLINE,C' '\n         MVC   PRTLINE+1(L'PRTLINE-1),PRTLINE\n         MEND\nUCBMAP   CSECT\n         FULLSAVE RENT=YES\n         REGS  R\n         LR    R3,R1                   SAVE CPPL ADDR\n         USING CPPL,R3\n         GETMAIN R,LV=WORKLEN          GET WORK SPACE\n         LR    R4,R1\n         USING WORK,R4\n*\n*        BUILD PPL AND INVOKE PARSE\n*\n         LA    R5,PARSPARM\n         USING PPL,R5\n         XC    PARSE(PARSELEN),PARSE\n         MVC   PPLUPT,CPPLUPT          UPT\n         MVC   PPLECT,CPPLECT          ECT\n         MVC   PPLCBUF,CPPLCBUF        CIB\n         DROP  R3\n         LA    R1,PARSECB\n         ST    R1,PPLECB               ECB\n         LA    R1,PARSANS\n         ST    R1,PPLANS               PDL\n         L     R1,=A(PCL)\n         ST    R1,PPLPCL               PCL\n         CALLTSSR EP=IKJPARS,MF=(E,(R5))\n         L     R5,PARSANS\n         LTR   R5,R5\n         BP    PARSEOK\n         LA    R1,=CL40'UCBMAP TERMINATED - PARSE ERROR'\n         LA    R0,40\n         TPUT  (1),(0),R               PRINT ERROR IF NECESSARY\n         B     EXIT\n         USING PDL,R5\n*\n*        IF CUU SPECIFIED, THEN USE IT;\n*           ELSE IF VOLSER SPECIFIED, THEN USE IT;\n*                ELSE ERROR.\n*\nPARSEOK  TM    CUUFLG,CUUFOUND         WAS CUU SPECIFIED\n         BO    USECUU\n         TM    VOLFLG,VOLFOUND\n         BO    USEVOL\n         LA    R1,=CL40'UCBMAP TERMINATED - NO OPERAND'\n         LA    R0,40\n         TPUT  (1),(0),R\n         B     EXIT\nUSEVOL   L     R6,VOLPTR               A(VOLSER)\n         LH    R8,VOLLEN               L'VOLSER\n         BCTR  R8,0\n         L     R1,CVTPTR               CVT\n         USING CVT,R1\n*KK2     L     R2,CVTILK2              USB LOOKUP TABLE\n         SR    R3,R3                   FOR ALTERNATE PATH COMPARISON\n*CBLOOP  LH    R7,0(0,R2)              GET UCB ADDRESS            CG\n*KK2     LA    R2,0(0,R2)                                         CG\n*KK2 UCBLOOP SLR R7,R7                                            CG\n         XC    USCNWORK,USCNWORK                     KK2\n         MVI   USCNTYPE,X'00' ALL UCBS               KK2\n         MVC   USCNCALL,CVTUCBSC-CVTMAP(R1)          KK2\n         DROP  R1\nUCBLOOP  L     R15,USCNCALL                          KK2\n         CALL  (15),(USCNWORK,USCNTYPE,USCNADDR),VL,MF=(E,USCNPARM) KK2\n         LTR   R15,R15            FOUND ANY?         KK2\n         BNZ   BADVOL                                KK2\n         ICM   R7,15,USCNADDR      GET UCB ADDRESS   KK2\n*KK2     ICM   R7,3,0(R2)              GET UCB ADDRESS            CG\n*        LTR   R7,R7                                              CG\n*KK2     C     R7,=X'00000000'\n*KK2     BE    UCBNEXT\n*KK2     C     R7,=X'0000FFFF'\n*KK2     BE    BADVOL\n*        BZ    UCBNEXT                                            CG\n*        BM    BADVOL                  IF TABLE DONE, THEN BAD VOLSER\n         USING UCBCMSEG,R7\n         TM    UCBDVCLS,UCB3TAPE+UCB3DACC    TAPE OR DISK?\n         BZ    UCBNEXT\n*KK2     CR    R7,R3                   ALTERNATE PATH?\n*KK2     BNH   UCBNEXT\n*KK2     LR    R3,R7                   FOR NEXT COMPARISON\n         TM    CUUFLG,CUUFOUND    CUU?                            KK2\n         BNO   CKVOL                                              KK2\n         CLC   DEVSAV,13(R7)      CUU MATCH?                      KK2\n         BE    VOLHIT             YUP                             KK2\nCKVOL    EQU   *                                                  KK2\n         EX    R8,COMPVOL\n         BE    VOLHIT                  IF OUR VOLUME, THEN EXIT LOOP\n         B     UCBLOOP\n*KK2 UCBNEXT  LA    R2,2(0,R2)\nUCBNEXT  EQU   *                                                  KK2\n         B     UCBLOOP\nBADVOL   LA    R1,=CL40'UCBMAP TERMINATED - VOLSER NOT FOUND'\n         LA    R0,40\n         TPUT  (1),(0),R\n         B     EXIT\nVOLHIT   ST    R7,UCBADDR              SAVE UCB ADDRESS\n         B     UCBSCAN\nCOMPVOL  CLC   0(*-*,R6),UCBVOLI\n         DROP  R7\n*\n*        CONVERT CUU TO BINARY\n*\nUSECUU   L     R1,CUUPTR               A(CUU)\n         LH    R2,CUULEN               L'CUU\n         DROP  R5\n         LA    R15,3                   FOR COMPARISON\n         CR    R2,R15\n         BE    GOODLEN                 CUU MUST BE 3 CHARS\n         LA    R1,=CL40'UCBMAP TERMINATED - CUU NOT 3 CHARS'\n         LA    R0,40\n         TPUT  (1),(0),R\n         B     EXIT\nGOODLEN  TRT   0(3,R1),HEXCHK          INSURE VALID HEXADECIMAL\n         BZ    HEXOK\n         LA    R1,=CL40'UCBMAP TERMINATED - CUU NOT HEX'\n         LA    R0,40\n         TPUT  (1),(0),R\n         B     EXIT\nHEXOK    MVC   DEVSAV,0(R1)            SAVE DEVICE ADDR\n         B     USEVOL             KK2\n         AGO   .KK2\n         TR    DEVSAV,TRTAB\n         PACK  DEVBIN,DEVSAV           CONVERT CUU TO BINARY\n         L     R1,DEVBIN\n         SRL   R1,4\n         ST    R1,DEVBIN\n*\n*        GIVEN CUU, FIND UCB ADDRESS\n*\n         L     R2,CVTPTR               CVT\n         USING CVT,R2\n         L     R3,CVTIXAVL             IOSCOM\n         USING IOCOM,R3\n         L     R5,IOCOMEX              IOSCOM EXT\n         USING IOX,R5\n         L     R6,DEVBIN               CUU\n         CLM   R6,2,IOXHICH            CHANNEL # OK?\n         BNH   CHANOK\n         LA    R1,=CL40'UCBMAP TERMINATED - CUU CHAN # TOO HIGH'\n         LA    R0,40\n         TPUT  (1),(0),R\n         B     EXIT\n*\n*        DETERMINE IF DEVICE ADDRESS VALID\n*\nCHANOK   LR    R14,R6                  GET CUU IN EVEN/ODD PAIR\n         SRDL  R14,3\n         SRL   R15,29\n         L     R7,IOCUCBBM             GET A(UCB BIT MAP)\n         AR    R7,R14                  GET OFFSET INTO BIT MAP\n         LA    R1,X'80'\n         SRL   R1,0(R15)               SETUP MASK\n         IC    R15,0(R7)               GET BIT MAP BYTE\n         NR    R1,R15                  VALID UNIT?\n         BNZ   UNITOK\n         LA    R1,=CL40'UCBMAP TERMINATED - CUU INVALID'\n         LA    R0,40\n         TPUT  (1),(0),R               PRINT ERROR, IF NECESSARY\n         B     EXIT\n*\n*        LOCATE UCB ADDRESS USING CVTILK1 & CVTILK2\n*\nUNITOK   SRDL  R14,5                   ISOLATE CHANNEL AND CU\n         SRL   R15,28\n         L     R8,CVTILK1\n         IC    R1,0(R14,R8)            GET CHANNEL CONSTANT\n         ALR   R15,R1\n         ALR   R15,R15                 2 * (CHANNEL CONSTANT + CU)\n         LA    R7,15\n         NR    R7,R6                   ISOLATE DEVICE\n         AH    R7,0(R15,R8)\n         ALR   R7,R7                   GET LOOKUP TABLE OFFSET\n         L     R8,CVTILK2\n         LH    R7,0(R7,R8)             GET UCB ADDRESS\n         N     R7,=A(X'0000FFFF')      CLEAN IT\n         ST    R7,UCBADDR\n.KK2     ANOP\n*\n*        DISPLAY DEVICE STATUS INFORMATION\n*\n         USING UCBCMSEG,R7\nUCBSCAN  TPUT  CLEAR,17,FULLSCR        CLEAR SCREEN\n         MVC   PRTLINE,HEADING         PRINT HEADING\n         MVC   PRTCUU,UCBNAME\n         LA    R1,PRTLINE\n         LA    R0,60\n         TPUT  (1),(0),R\n         L     R1,CONSTANT                      *KK1\n         LA    R1,HYPHENS-CBASE(,R1)            *KK1\n         LA    R0,60                            *KK1\n         TPUT  (1),(0),R                        *KK1\n*KK1     TPUT  HYPHENS,60                       *KK1\n         L     R15,CONSTANT\n         MVC   PRTLINE,STATHEAD-CBASE(R15)\n*\n*        ONLINE, OFFLINE OR CHANGING STATUS\n*\n         TM    UCBSTAT,UCBCHGS         DEVICE CHANGING STATUS?\n         BO    STATCHNG\n         TM    UCBSTAT,UCBONLI         DEVICE ONLINE?\n         BO    ONLINE\n         MVC   DEVSTAT,=CL30'OFFLINE'\n         B     PRTSTAT\nSTATCHNG MVC   DEVSTAT,=CL30'CHANGING STATUS'\n         B     PRTSTAT\nONLINE   MVC   DEVSTAT,=CL30'ONLINE'\nPRTSTAT  PRTLINE\n*\n*        ALLOCATED OR NOT ALLOCATED\n*\n         TM    UCBSTAT,UCBALOC\n         BO    ALLOC\n         MVC   DEVSTAT,=CL30'NOT ALLOCATED'\n         B     PRTALLOC\nALLOC    MVC   DEVSTAT,=CL30'ALLOCATED'\nPRTALLOC PRTLINE\n*\n*        READY OR NOT READY\n*\n         TM    UCBFLA,UCBNRY\n         BO    NOTREADY\n         MVC   DEVSTAT,=CL30'READY'\n         B     PRTREADY\nNOTREADY MVC   DEVSTAT,=CL30'NOT READY'\nPRTREADY PRTLINE\n         B     NOCANDO            KK2\n*\n*        BUSY OR NOT BUSY\n*\n         TM    UCBFLA,UCBBSY\n         BO    BUSY\n         MVC   DEVSTAT,=CL30'NOT BUSY'\n         B     PRTBUSY\nBUSY     MVC   DEVSTAT,=CL30'BUSY'\nPRTBUSY  PRTLINE\n*\n*        FOR DASD DEVICES, DISPLAY RESERVE, MOUNT, USE, SHARE STATUS\n*                    AND # OF CURRENT USERS\n*\n         TM    UCBTBYT3,UCB3DACC       DASD DEVICE?\n         BZ    NOTDASD                 NO, OMIT DASD STATUS\n         CLI   UCBVOLI,0               ANYTHING MOUNTED?\n         BE    NOTDASD                 NO, OMIT DASD STATUS\n*\n*        RESERVED, RESERVE PENDING, OR NOT RESERVED\n*\n         TM    UCBFL4,UCBRESVP         RESERVE PENDING\n         BO    RESPEND\n         CLI   UCBSQC,0                RESERVE COUNT = 0?\n         BE    NOTRES\n         MVC   DEVSTAT,=CL30'RESERVED'\n         B     PRTRES\nRESPEND  MVC   DEVSTAT,=CL30'RESERVE PENDING'\n         B     PRTRES\nNOTRES   MVC   DEVSTAT,=CL30'NOT RESERVED'\nPRTRES   PRTLINE\nNOCANDO  EQU   *                  KK2\n*\n*        SHARED OR NOT SHARED\n*\n         TM    UCBTBYT2,UCBRR        SHARED?      AXC\n         BO    SHARED                             AXC\n         MVC   DEVSTAT,=CL30'NOT SHARED'\n         B     PRTSHARE\nSHARED   MVC   DEVSTAT,=CL30'SHARED'\nPRTSHARE PRTLINE\n*\n*        PRIVATE, PUBLIC, OR STORAGE\n*\n         TM    UCBSTAB,UCBBPRV         PRIVATE\n         BO    PRIVATE\n         TM    UCBSTAB,UCBPUB          PUBLIC\n         BO    PUBLIC\n         MVC   DEVSTAT,=CL30'USE=STORAGE'  STORAGE\n         B     PRTUSE\nPRIVATE  MVC   DEVSTAT,=CL30'USE=PRIVATE'\n         B     PRTUSE\nPUBLIC   MVC   DEVSTAT,=CL30'USE=PUBLIC'\nPRTUSE   PRTLINE\n*\n*        PERMANENTLY RESIDENT, RESERVED OR REMOVABLE\n*\n         TM    UCBSTAT,UCBPRES\n         BO    PERM\n         TM    UCBSTAT,UCBRESV\n         BO    RESV\n         MVC   DEVSTAT,=CL30'MOUNT=REMOVABLE'\n         B     PRTMOUNT\nPERM     MVC   DEVSTAT,=CL30'MOUNT=PERMANENTLY RESIDENT'\n         B     PRTMOUNT\nRESV     MVC   DEVSTAT,=CL30'MOUNT=RESERVED'\nPRTMOUNT PRTLINE\n*\n*        NUMBER OF CURRENT USERS\n*\n         SR    R1,R1\n         IC    R1,UCBUSER              # OF CURRENT USERS\n         CVD   R1,DBLWORD\n         MVC   MASK,=X'F0212020'\n         ED    MASK,DBLWORD+6\n         MVC   DEVSTAT(3),MASK+1\n         MVC   DEVSTAT+4(26),=CL26'OPEN DATASETS'\n         PRTLINE\n         DROP  R7\n         B     ALSONOGO           KK2\n*\n*        DISPLAY UNIT NAMES ASSOICATED WITH THIS DEVICE\n*\nNOTDASD  TPUT  BLANK,1\n         L     R15,CONSTANT            FOR ADDRESSABILITY\n         MVC   PRTLINE,UNITHEAD-CBASE(R15)  UNITNAME HEADING\n         MVC   DEVSTAT,BLANK-CBASE(R15)\n         L     R2,CVTPTR               CVT\n         USING CVT,R2\n         L     R2,CVTJESCT             JESCT\n         USING JESCT,R2\n         L     R2,JESEDT               EDT\n         USING EDTHEAD,R2\n         L     R1,LOOKPTR              LOOKUP SECTION\n         DROP  R2\n         USING LOOKSEC,R1\n         L     R3,LOOK#ENT             # UNIT NAME ENTRIES\n         L     R2,LOOKLENT             L'ENTRY\n         ST    R2,ENTRYLEN             SAVE\n         LA    R5,LOOKUNIT             ->UNITNAME\n         USING LOOKUNIT,R5\n         SR    R0,R0                   SETUP PRINT LINE CONTROL\n         STH   R0,NAMECNT\n         LA    R15,DEVSTAT\n         ST    R15,LINEPTR\nUPUT     L     R6,LOOK#GEN             # GENERICS WITHIN UNIT\n         L     R7,LOOKGPTR             ->FIRST GENERIC ENTRY\n         DROP  R5\n         USING GENSEC,R7\nUGEN     L     R8,GEN#GRP              # GROUPS WITHIN GENERIC\n         L     R9,GENGPTR              ->FIRST GROUP POINTER\n         DROP  R7\n         USING GPTRSEC,R9\nUGRP     L     R10,GPTRGRP             ->GROUP SECTION\n         DROP  R9\n         USING GRPSEC,R10\n         L     R11,GRP#UCB             # UCBS WITHIN GROUP\n         L     R14,GRPOUCB             ->FIRST UCB OFFSET\n         DROP  R10\nUCB      LH    R15,0(0,R14)            UCB OFFSET\n         SLL   R15,1                   X 2\n         L     R1,CVTPTR               CVT\n         USING CVT,R1\n         L     R1,CVTILK2              UCB LOOKUP TABLE\n         LH    R1,0(R15,R1)            UCB ADDRESS\n         USING UCBCMSEG,R1\n         L     R2,UCBADDR              OUR UCB\n         CLC   UCBNAME,13(R2)          OUR NAME = THIS UCB\n         DROP  R1\n         BNE   NEXTUCB\n         LH    R0,NAMECNT              COUNT OF DISPLAY NAMES\n         L     R15,LINEPTR             CURRENT LINE PTR\n         C     R0,=F'3'                LINE FILLED?\n         BL    SPACEOK\n         PRTLINE                       YES, PRINT IT\n         SR    R0,R0                   COUNT=0\n         LA    R15,DEVSTAT             NEW LINE POINTER\nSPACEOK  AH    R0,=H'1'                BUMP COUNT\n         STH   R0,NAMECNT              SAVE IT\n         MVC   0(8,R15),0(R5)          MOVE UNIT NAME\n         LA    R15,10(0,R15)           BUMP LINE POINTER\n         ST    R15,LINEPTR             SAVE IT\nNEXTUCB  LA    R14,2(0,R14)            NEXT UCB\n         BCT   R11,UCB\n         LA    R9,4(0,R9)              NEXT GROUP ENTRY\n         BCT   R8,UGRP\n         LA    R7,12(0,R7)             NEXT GENERIC ENTRY\n         BCT   R6,UGEN\n         L     R2,ENTRYLEN\n         LA    R5,0(R2,R5)             NEXT ENTRY\n         BCT   R3,UPUT\n         PRTLINE                       PRINT UNFILLED LINE\n         TPUT  BLANK,1\n*\n*        DISPLAY DEVICE CHANNEL PATHS\n*\n         L     R15,CONSTANT            FOR ADDRESSABILITY\n         MVC   PRTLINE,CHANHEAD-CBASE(R15)\n         L     R7,UCBADDR              GET UCB ADDRESS\n         USING UCBCMSEG,R7\n         MVC   DEVSTAT,BLANK-CBASE(R15)      CPU 0 PATHS\n         MVC   DEVSTAT+14(5),=C'CPU 0'\n         MVC   DEVSTAT+2(3),=C'PRI'\n         SR    R1,R1                   TCH PATH INDEX\n         TM    UCBCHM,UCBPPA           PRIMARY ONLINE?\n         BZ    PRION\n         MVC   DEVSTAT+6(7),=C'OFFLINE'\n         BAL   R10,GETCHAN#\n         B     TRYALT\nPRION    MVC   DEVSTAT+6(6),=C'ONLINE'\n         BAL   R10,GETCHAN#\nTRYALT   TM    UCBFL5,UCBALTPH         ALTERNATE PATH?\n         BZ    TRYMP\n         MVC   DEVSTAT+2(3),=C'SEC'\n         LA    R1,2                    INDEX IN TCH PATH TABLE\n         TM    UCBCHM,UCBSPA           SECONDARY ONLINE?\n         BZ    SECON\n         MVC   DEVSTAT+6(7),=C'OFFLINE'\n         BAL   R10,GETCHAN#\n         B     TRYMP\nSECON    MVC   DEVSTAT+6(6),=C'ONLINE'\n         BAL   R10,GETCHAN#\nTRYMP    L     R1,CVTPTR               CVT\n         USING CVT,R1\n         L     R1,CVTCSD               CSD\n         USING CSD,R1\n         TM    CSDCPUAL,CPU1+X'20'     MP? OR DYADIC - *KK1\n         BZ    DEVTYPE                 DEAL WITH CPU 1\n         TM    CSDCPUAL,CPU1         MP?               *KK1\n         BO    SCPU1                 YES               *KK1\n         MVC   DEVSTAT+14(5),=C'CPU 2'                 *KK1\n         B     *+10                  YES               *KK1\nSCPU1    EQU   *                                       *KK1\n         MVC   DEVSTAT+14(5),=C'CPU 1'\n         DROP  R1\n         SR    R1,R1                   TCH PATH INDEX\n         MVC   DEVSTAT+2(3),=C'PRI'    PRIMARY PATH\n         TM    UCBCHM,UCBPPB           PRIMARY ONLINE?\n         BZ    MPPRION\n         MVC   DEVSTAT+6(7),=C'OFFLINE'\n         BAL   R10,GETCHAN#\n         B     SECMP\nMPPRION  MVC   DEVSTAT+6(6),=C'ONLINE'\n         BAL   R10,GETCHAN#\nSECMP    TM    UCBFL5,UCBALTPH         ALTERNATE PATH?\n         BZ    DEVTYPE\n         MVC   DEVSTAT+2(3),=C'SEC'\n         LA    R1,2                    TCH PATH INDEX\n         TM    UCBCHM,UCBSPB           ALTERNATE ONLINE?\n         BZ    MPALTON\n         MVC   DEVSTAT+6(7),=C'OFFLINE'\n         BAL   R10,GETCHAN#\n         B     DEVTYPE\nMPALTON  MVC   DEVSTAT+6(6),=C'ONLINE'\n         BAL   R10,GETCHAN#\n         B     DEVTYPE\n*\n*        GET CHANNEL NUMBER FROM TCH PATH TABLE\n*\nGETCHAN# L     R5,CVTPTR               CVT\n         USING CVT,R5\n         L     R5,CVTILCH              LCH\n         USING LCH,R5\n         SR    R6,R6\n         IC    R6,UCBLCI               LCH INDEX\n         SLL   R6,5\n         LA    R5,0(R6,R5)             LCH ENTRY\n         L     R6,LCHTCH               TCH PATH TABLE\n         DROP  R5\n         LA    R6,0(R1,R6)             TCH PATH TABLE ENTRY\n         MVC   DEVSTAT(1),0(R6)\n         TR    DEVSTAT(1),HEX          CHANNEL NUMBER\n         PRTLINE                       PRINT TO TERMINAL\n         BR    R10\nALSONOGO EQU   *                  KK2\n*\n*        DISPLAY DEVTYPE FIELD\n*\nDEVTYPE  TPUT  BLANK,1\n         L     R15,CONSTANT            FOR ADDRESSABILITY\n         MVC   PRTLINE,DEVTHEAD-CBASE(R15)  SETUP HEADING\n         TM    UCBDVCLS,UCB3TAPE       DETERMINE DEVICE CLASS\n         BNO   TRYCOMM\n         MVC   DEVSTAT(17),=CL17'TAPE          -  '\n*\n*        TRY TO FIND TAPE DENSITY\n*\n         TM    UCBTBYT2,UCBDUDN2       1600/6250?\n         BZ    TRYDN1\n         MVC   DEVSTAT+5(9),=C'1600/6250'\n         B     TRANTYPE\nTRYDN1   TM    UCBTBYT2,UCBDUDN1       800/1600?\n         BZ    TRY1600\n         MVC   DEVSTAT+6(8),=C'800/1600'\n         B     TRANTYPE\nTRY1600  TM    UCBTBYT1,UCBD1600       1600?\n         BZ    TRY6250\n         MVC   DEVSTAT+10(4),=C'1600'\nTRY6250  TM    UCBTBYT1,UCBD6250       6250?\n         BZ    TRANTYPE\n         MVC   DEVSTAT+10(4),=C'6250'\nTRYCOMM  TM    UCBDVCLS,UCB3COMM\n         BNO   TRYCTC\n         MVC   DEVSTAT(17),=CL17'COMMUNICATION -  '\n         B     TRANTYPE\nTRYCTC   TM    UCBDVCLS,UCB3CTC\n         BNO   TRYDASD\n         MVC   DEVSTAT(17),=CL17'CTC           -  '\n         B     TRANTYPE\nTRYDASD  TM    UCBDVCLS,UCB3DACC\n         BNO   TRYDISP\n         MVC   DEVSTAT(17),=CL17'DASD          -  '\n*\n*        DETERMINE DASD MODEL\n*\n         CLI   UCBTBYT4,X'0D'          3330-11?\n         BE    MOD11\n         CLI   UCBTBYT4,X'0B'          3350?\n         BNE   TRANTYPE\n         MVC   DEVSTAT+10(4),=C'3350'\n         B     TRANTYPE\nMOD11    MVC   DEVSTAT+7(7),=C'3330-11'\n         B     TRANTYPE\nTRYDISP  TM    UCBDVCLS,UCB3DISP\n         BNO   TRYUNIT\n         MVC   DEVSTAT(17),=CL17'DISPLAY       -  '\n         B     TRANTYPE\nTRYUNIT  TM    UCBDVCLS,UCB3UREC\n         BNO   TRYOCR\n         MVC   DEVSTAT(17),=CL17'UNIT RECORD   -  '\n         B     TRANTYPE\nTRYOCR   TM    UCBDVCLS,UCB3CHAR\n         BNO   UNKNOWN\n         MVC   DEVSTAT(17),=CL17'CHARACTER RDR -  '\n         B     TRANTYPE\nUNKNOWN  MVC   DEVSTAT(17),=CL17'UNKNOWN CLASS -  '\nTRANTYPE UNPK  DEVSTAT+17(9),UCBTYP(5)\n         TR    DEVSTAT+17(9),HEX-C'0'  DISPLAY DEVICE TYPE\n         MVI   DEVSTAT+25,C' '\n         PRTLINE\n         TPUT  BLANK,1\n*\n*        FOR TAPE AND DASD, DISPLAY VOLUME SERIAL NUMBER\n*\n         L     R15,CONSTANT\n         MVC   PRTLINE,VOLSHEAD-CBASE(R15)\n         TM    UCBDVCLS,UCB3TAPE+UCB3DACC\n         BZ    DISADDR\n         CLI   UCBVOLI,0\n         BNE   MOVEVOL\n         MVC   DEVSTAT,=CL30'NONE'\n         B     PRTVOL\nMOVEVOL  MVC   DEVSTAT(6),UCBVOLI\nPRTVOL   PRTLINE\n         TPUT  BLANK,1\n*\n*        DISPLAY UCB ADDRESS\n*\nDISADDR  L     R15,CONSTANT\n         MVC   PRTLINE,UCBAHEAD-CBASE(R15)\n         UNPK  DEVSTAT(9),UCBADDR(5)\n         TR    DEVSTAT(8),HEX-C'0'\n         MVI   DEVSTAT+8,C' '\n         PRTLINE\n         TPUT  BLANK,1\n         TITLE 'EXIT CONVENTIONS'\nEXIT     IKJRLSA PARSANS               RELEASE PARSE WORK AREA\n         FREEMAIN R,LV=WORKLEN,A=(R4)  RELEASE WORK AREA\n         FULLRTRN RENT=YES             RETURN\n*\n*        LITERAL POOL\n*\n         LTORG\n         TITLE 'PARSE PCL, CONSTANTS AND DSECTS'\n*\n*        PARSE PARAMETER CONTROL LIST\n*\nPCL      IKJPARM  DSECT=PDL\nX        IKJKEYWD\n         IKJNAME  'VOL',SUBFLD=VOLFLD\nY        IKJKEYWD\n         IKJNAME  'CUU',SUBFLD=CUUFLD\nVOLFLD   IKJSUBF\nVOL      IKJIDENT 'VOLSER',FIRST=ALPHANUM,OTHER=ALPHANUM,MAXLNTH=6\nCUUFLD   IKJSUBF\nCUU      IKJIDENT 'DEVICE ADDRESS',FIRST=NONATNUM,OTHER=NONATNUM,      $\n               MAXLNTH=3\n         IKJENDP\n*\n*        CONSTANTS\n*\nCLEAR    DC   X'27F540115D7E1140403C40400011404013'\nHEX      DC   C'0123456789ABCDEF'\nHEXCHK   DC   256X'FF'\n         ORG  HEXCHK+C'A'\n         DC   X'000000000000'          ABCEDF ARE OK\n         ORG  HEXCHK+C'0'\n         DC   X'00000000000000000000'  0123456789 ARE OK\n         ORG\nTRTAB    DC   (C'A')X'0',X'FAFBFCFDFEFF',41X'0',C'0123456789',6X'0'\n*\nCONSTANT DC   A(HEADING)               BASE LOCATOR FOR CONSTANTS\n*\nCBASE    EQU  *\nHEADING  DC   CL60'          DEVICE MAP FOR XXX'\nBLANK    DC   CL30' '\nHYPHENS  DC   CL60'          ------ --- --- ---'\nVOLSHEAD DC   CL60'VOLUME SERIAL     -  '\nUCBAHEAD DC   CL60'UCB ADDRESS       -  '\nSTATHEAD DC   CL60'STATUS            -  '\nUNITHEAD DC   CL60'UNIT NAMES        -  '\nCHANHEAD DC   CL60'CHANNEL PATHS     -  '\nDEVTHEAD DC   CL60'DEVICE TYPE       -  '\n*\n*        DSECTS\n*\nWORK     DSECT                         WORK AREA\nPARSE    EQU   *\nPARSPARM DS    7A                      PPL\nPARSECB  DS    F                       PARSE ECB\nPARSANS  DS    A                       PDL POINTER\nPARSELEN EQU   *-PARSE\nDBLWORD  DS    D                       WORK\nENTRYLEN DS    F                       L' UNIT NAME ENTRY\nLINEPTR  DS    A                       PRINT LINE CONTROL\nDEVBIN   DS    F                       CUU IN BINARY\nUCBADDR  DS    F                       OUR UCB ADDR\nNAMECNT  DS    H                       PRINT LINE CONTROL\nDEVSAV   DS    CL3                     CUU IN EBCDIC\nMASK     DS    XL4                     EDIT MASK\nPRTLINE  DS    CL60                    PRINT LINE\n         ORG   PRTLINE+22\nDEVSTAT  DS    CL30\n         ORG   PRTLINE+25\nPRTCUU   DS    CL3\n         ORG\n         DS    0D                 KK2\nUSCNWORK DS    XL100              KK2\nUSCNTYPE DS    X                  KK2\nUSCNADDR DS    A                  KK2\nUSCNCALL DS    A                  KK2\nUSCNPARM DS    3A                 KK2\nWORKLEN  EQU   *-WORK\n*\nEDT      DSECT                         EDT\nEDTHEAD  EQU    *\nLOOKPTR  DS     A                      ->LOOKUP SECTION\n         ORG    EDT\nLOOKSEC  EQU    *                      LOOKUP SECTION\nLOOK#ENT DS     F                      # ENTRIES\nLOOKLENT DS     F                      L'ENTRY\nLOOKUNIT DS     CL8                    UNIT NAME\nLOOKVAL  DS     F                      LOOKUP VALUE\nLOOKMPTR DS     A                      ->GROUP MASK ENTRY\nLOOK#GEN DS     F                      # GENERICS\nLOOKGPTR DS     A                      ->GENERIC SECTION\n         ORG    EDT\nGENSEC   EQU    *                      GENERIC SECTION\nGENDEV   DS     XL4                    GENERIC DEVICE TYPE\nGEN#GRP  DS     F                      # GROUPS\nGENGPTR  DS     A                      ->FIRST GROUP POINTER\n         ORG    EDT\nGPTRSEC  EQU    *                      GROUP POINTER SECTION\nGPTRGRP  DS     A                      ->FIRST GROUP ENTRY\n         ORG    EDT\nGRPSEC   EQU    *                      GROUP SECTION ENTRY\nGRPID    DS     F                      ID\nGRP#UCB  DS     F                      # UCBS IN THIS GROUP\nGRPOUCB  DS     A                      ->FIRST UCB ENTRY\n*\nPDL      DSECT\n         ORG   CUU                     PDL CONTINUATION\nCUUPTR   DS    A                       ->CUU\nCUULEN   DS    H                       L'CUU\nCUUFLG   DS    X\nCUUFOUND EQU   X'80'\n         ORG   VOL\nVOLPTR   DS    A                       ->VOL SER\nVOLLEN   DS    H                       L'VOLSER\nVOLFLG   DS    X\nVOLFOUND EQU   X'80'\n*\nLCH      DSECT\n         ORG   LCH+16                  LOGICAL CHANNEL TABLE ENTRY\nLCHTCH   DS    A                       TCH PATH TABLE ADDRESS\n*\nCSD      DSECT\n         ORG   CSD+8                   COMMON SYSTEM DATA AREA\nCSDCPUAL DS    XL2                     CPUS AVAILABLE\nCPU1     EQU   X'40'                   MP INDICATION\n*\n*        PRINT NOGEN\n         CVT   DSECT=YES,PREFIX=NO     CVT\n         IECDIOCM                      IOSCOM\n         IECDIOCX                      IOSCOM EXT\n         IKJCPPL                       CPPL\n         IKJPPL                        PPL\n         IEFUCBOB                      UCB\n         IEFJESCT                      JESCT\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "UCC7MOD": {"ttr": 38155, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x00\\x7f\\x00\\x88\\x00\\x7f\\x12\\x00\\x00&\\x00&\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf2\\xf7\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-01-07T00:00:00", "modifydate": "1988-01-07T12:00:00", "lines": 38, "newlines": 38, "modlines": 0, "user": "FILE270"}, "text": "         EJECT\n*                                                                   KK1\n*KK START OF WDPSC VIRTUAL TERMINAL MOD - 1ST 20 TERMS ANY REMOTE:  KK1\n*        NEXT 20  FOR LOCAL SNA TERMINALS                           KK1\n*                                                                   KK1\n* THIS CODE IS INSERTED INTO UCC7 MODULE SASSLGON DIRECTLY BEFORE   KK1\n*  LABEL INVID (INVALID TERMINAL WTO) TO ALLOW ANY TERMINAL TO      KK1\n*  CONNECT TO UCC7. AS CODED YOU MUST DEFINE FIRST 20 TERMINALS     KK1\n*  AS DUMMY REMOTES AND NEXT 20 AS DUMMY LOCAL SNA TERMINALS.       KK1\n*  OPERATION OF OTHER VTAM TERMINALS DEFINED IS NOT AFFECTED.       KK1\n*                                                                   KK1\n***NOTE- ADD LABEL 'RESTART' TO INSTRUCTION LIKE THE FOLLOWING      KK1\n*        INSTRUCTION BUT ABOVE LABEL 'SCAN' IN SASSLGON:            KK1\n*                                                                   KK1\n         L     R1,VTMIDTA         POINT TO LOGON ID TABLE           KK1\n         LH    R3,=H'21'          LOAD NUMBER OF ENTRIES            KK1\n         BCTR  R3,0               REDUCE FOR ONE EXTRA              KK1\n         CLI   0(R4),C'L'         LOCAL TERM?                       KK1\n         BNE   SCAN2              NO->START SCAN                    KK1\n         AH    R1,=H'240'         SKIP 1ST 20 TERMINALS             KK1\nSCAN2    DS    0H                                                   KK1\n         LA    R1,12(,R1)         POINT TO NEXT TABLE ENTRY         KK1\n         L     R6,8(,R1)          ADDRESS OF UCC7 TERM DEFINITION   KK1\n         TM    TRMVFLG,TRMINCON   CONNECT IN PROCESS...             KK1\n         BNZ   CSCAN                   BIF - SIMLOGON DONE          KK1\n         TM    TRMVFLG,TRMCONN    ALREADY CONNECTED...              KK1\n         BNZ   CSCAN                   BIF - CONNECTED(REJECT LOGON)KK1\n         MVC   0(8,R1),0(R4)      MAKE TABLE ENTRY MATCH USERS ID   KK1\n         MVC   TRMVTMID(8),0(R4)  MAKE TERM VTAMID MATCH            KK1\n         L     R2,TRMADDRC+4      R2->NIB                           KK1\n         USING ISTDNIB,R2                                           KK1\n         MVC   NIBSYM,0(R4)       VTAMID TO NIB                     KK1\n         B     RESTART            START THE NORMAL SCAN AGAIN       KK1\nCSCAN    BCT   R3,SCAN2           CONTINUE SCAN                     KK1\n*                                                                   KK1\n*KK END OF WDPSC VIRTUAL TERMINAL MOD                               KK1\n*                                                                   KK1\n         EJECT\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "UNCLIB$": {"ttr": 38401, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x00\\x7f\\x00\\x88\\x00\\x7f\\x12\\x00\\x00:\\x00:\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf2\\xf7\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-01-07T00:00:00", "modifydate": "1988-01-07T12:00:00", "lines": 58, "newlines": 58, "modlines": 0, "user": "FILE270"}, "text": "1                                                        UNCLIB.1\n                                                         06/25/82\n\n\n  CLIST:              UNCLIB\n  AUTHOR:             Jeff Sprehn\n  AGENCY:             WDPSC\n  FUNCTION:           Deallocate (remove)  a private  CLIST library\n                      previously allocated to your session.\n\n  TERMINAL TYPE: 3270 type or dial-up\n\n  The  UNCLIB CLIST  is  used to  remove  the  given CLIST  library\n  previously  allocated but  to retain  all  other CLIST  libraries\n  allocated to your session.\n\n  Syntax -\n  _________________________________________________________________\n  Command        Operands\n  _________________________________________________________________\n  UNCLIB         dsname\n  _________________________________________________________________\n\n  Operands -\n       Required -\n            dsname:   Dataset   name  of   CLIST   library  to   be\n                      deallocated.\n\n\n\n\n1                                                        UNCLIB.2\n                                                         06/25/82\n\n\n  Example -\n\n       Suppose that the following CLIST libraries are allocated to your\n       session such that their member names may be invoked implicitly:\n                 AGNCY999.MY.CLIST\n                 JD00999.MISC.CLIST\n                 WDPSC.MASTER.CLIST\n                 USER.CLIST\n\n  Then, further suppose that the following CLIST was entered:\n\n                 UNCLIB 'AGNCY999.MY.CLIST'\n\n  Then, in the shown order, the  following CLIST libraries would be\n  allocated to your session after execution of the UNCLIB:\n\n                 JD00999.MISC.CLIST\n                 WDPSC.MASTER.CLIST\n                 USER.CLIST\n\n\n\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "U3011195": {"ttr": 38403, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x94\\x04\\x7f\\x00\\x94\\x04\\x7f\\x17I\\x02\\x87\\x02\\x87\\x00\\x00\\xe2\\xc2\\xc7\\xc3\\xe2\\xc3@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-02-16T00:00:00", "modifydate": "1994-02-16T17:49:00", "lines": 647, "newlines": 647, "modlines": 0, "user": "SBGCSC"}, "text": "U3011195 CSECT\n*\n*\n*             THE PURPOSE OF THIS PROGRAM IS TO EXTRACT INFORMATION\n*        FROM JCL STREAMS AND PLACE IT INTO RECORDS THAT ARE EASILY\n*        WORKED WITH BY HIGHER LEVEL LANGUAGE PROGRAMS.  THESE PRO-\n*        GRAMS WILL CREATE DSN AND PROGRAM CROSS REFERENCE LISTINGS\n*        AS WELL AS AN EASY TO READ JOB STREAM LISTING.  SECONDARY\n*        RECORDS ARE ALSO PRODUCED TO RESOLVE DSN BACKREFS.\n*\n*\n*        WRITTEN: 5-14-75 BY HOWARD GLASTETTER\n*\n*        LATEST FLAG: 06-03-86\n*        PURPOSE: ENTER: F XXXXXX MEM NAME ISN'T GETTING ON PROC\n*                 NO CHANGE MADE; BUT U3011SPC WAS CHANGE FOR A\n*                 SPECIAL PERSONAL EFFORT.\n*        LATEST UPDATE: 01-25-84\n*        PURPOSE: ALLOW SP PARMS TO 1536 (FROM 1024),\n*                 CORRECT SP PGM RESOLVE LOGIC,\n*                 ELIMINATE JCL COMMENT RECORD LOGIC.\n*        PRIOR UPDATE: 12-29-83\n*        PURPOSE: STREAMLINE THE SP RESOLUTION PROCESS.\n*\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2         WORK - ADDR SAVE AREA\nR3       EQU   3         WORK - BXLE LOGIC\nR4       EQU   4         *                   DO NOT ALTER R4\nR5       EQU   5         *\nR6       EQU   6         WORK AIDS SOME BXLE ROUTINES\nR7       EQU   7         WORK FOR EXECUTE MOVE INSTRUCTION - LENGTH\nR8       EQU   8         *                                   TO FIELD\nR9       EQU   9         *                                   FROM FIELD\nR10      EQU   10        SUBROUTINE LINKAGE\nR11      EQU   11        WORK\nR12      EQU   12        BASE\nR13      EQU   13        SYSTEM LINKAGE\nR14      EQU   14\nR15      EQU   15\n         EJECT\nBEGIN    SAVE  (14,12)       PROGRAM LINKAGE AND INITIATION\n         BALR  12,0\n         USING *,12\n         ST    R13,REGSAVE+4\n         LA    R11,REGSAVE\n         ST    R11,8(R13)\n         LR    R13,R11\n*\n         PRINT ON,NOGEN\n         OPEN  (FILEIN,,FILEOUT1,(OUTPUT),FILEOUT2,(OUTPUT))\n         LA    R4,1          PERMANENTLY INIALIZE R4\nLOOP9    EQU   *\n         MVC   RCRDOUT1(161),RCRDOUT1-1\n*\nLOOP10   EQU   *\n         BAL   R10,READ70\nLOOP10A  EQU   *\n         CLC   RCRDIN(2),=C'//'         CHECK FOR NON-JCL\n         BNE   LOOP10\n         LA    R3,RCRDIN+2         SEARCH FOR 'PROC ' STATEMENT\n         LA    R5,RCRDIN+40        PROC STATEMENT SHOULD BE BEFORE HERE\nLOOP10C  EQU   *\n         CLC   0(6,R3),=C' PROC '\n         BE    PRCLP11             FOUND PROC NOW CHECK SYMBOLIC PARMS\n         CLC   0(5,R3),=C' JOB '   TREAT A JOB CARD AS IF IT WERE PROC\n         BE    JOB11AA\n         BXLE  R3,R4,LOOP10C\n*\n         LA    R3,RCRDIN+2\nLOOP10D  EQU   *                   SEARCH FOR STEP AND PGM CARD\n         CLC   0(6,R3),=C' EXEC '\n         BE    STPRG12             HIT, NOW EXTRACT STEP AND PROG NAMES\n         BXLE  R3,R4,LOOP10D\n*\n         LA    R3,RCRDIN+2\nLOOP10E  EQU   *\n         CLC   0(6,R3),=C' PEND '\n         BE    LPEND10F\n         BXLE  R3,R4,LOOP10E\n         B     CHKDD30\nLPEND10F EQU   *              YOU HAVE HIT A PEND AT THIS POINT\n         MVI   OUT1TYPE,C'E'\n         MVC   OUT1PRCN,PROCSAVE                   (XXXXXXXXX)\n         MVC   PROCSAVE(32),PROCSAVE-1\n         B     WRITE20\n*\nJOB11AA  EQU   *                                   (XXXXXXXXXX)\n         MVC   OUT1PRCN+9(5),=C'(JOB)'  INDICATE JOB RATHER THAN PROC\nPRCLP11  EQU   *              PROC LOOP\n         MVC   PROCSAVE(32),PROCSAVE-1\n         LA    R3,RCRDIN+2\n         LA    R5,RCRDIN+9\n         LA    R6,PROCSAVE    FIRST MOVE PROC NAME TO SAVE AREA\nPRCLP11A EQU   *\n         CLI   0(R3),C' '\n         BE    PRCLP11B       YOU HAVE IT ALL-LEAVE\n         MVC   0(1,R6),0(R3)  MOVE A BYTE AT A TIME TO SAVE AREA\n         LA    R6,1(0,R6)\n         BXLE  R3,R4,PRCLP11A\n*                             PROC FULL 8 CHARACTERS ON FALL THRU\nPRCLP11B EQU   *\n         MVI   OUT1TYPE,C'P'\n         MVC   OUT1PRCN,PROCSAVE   PROC CARD NOW CREATED\n         BAL   R10,CLRSP60         BLANK SYMPARM WORK AREA\n         MVI   SPSTRING,C','  COMMA TRIGGERS FUTURE COMPARE OF SP STRNG\n*                                  LETS LOOK FOR SYMBOLIC PARMS\n         LA    R5,RCRDIN+71        PREPARE TO SCAN WHOLE RECORD\n         LA    R6,SPSTRING+1       POINT TO SYM PARM SAVE AREA\n         LA    R7,SPSTRING+1535    POINT PAST LAST BYTE OF STRING\nPRCLP11C EQU   *\n         CLC   0(5,R3),=C' JOB '\n         BE    WRITE20\n         CLC   0(6,R3),=C' PROC '\n         BE    PRCLP11D\n         BXLE  R3,R4,PRCLP11C      YOU WILL NEVER FALL THRU SINCE YOU\n*                                  WOULD NOT BE HERE IF NOT 'PROC' RCRD\n*                                  OR A 'JOB' CARD.\nPRCLP11D EQU   *\n         LA    R3,6(R3)       NOW MOVE PARMS IF ANY\nPRLP11DA EQU   *\n         CLI   0(R3),C' '     SEARCHING FOR FIRST NON BLANK HERE\n         BNE   PRCLP11E\n         BXLE  R3,R4,PRLP11DA\n         B     WRITE20        FALL THRU MEANS NO PARMS\n*\nPRCLP11E EQU   *\n         MVC   0(1,R6),0(R3)  MOVE PARMS TO SYM PARM STRING SAVE AREA\n         LA    R6,1(R6)\n         CR    R6,R7           YOU MAY ONLY HAVE 1.5 K OF SYMBOLICS\n         BE    WRITE20         ANY MORE WILL BE LOST - SORRY\n         BXLE  R3,R4,PRCLP11F\n         B     WRITE20         FALL THRU MEANS YOU HAVE THEM ALL\n*\nPRCLP11F EQU   *\n         CLC   0(2,R3),=C', '      CONTINUE ON NEXT CARD?\n         BE    PRCLP11G            YES\n         CLI   0(R3),C' '\n         BNE   PRCLP11E            BLANK MEANS YOU HAVE THEM ALL\n         B     WRITE20             YOU DO, BYE\nPRCLP11G EQU   *\n         MVI   0(R6),C','     SEPERATE FIRST SP ON NEXT RECORD\n         LA    R6,1(R6)       FROM THE LAST ONE ON THIS RECORD\n         BAL   R10,READ70\n         LA    R3,RCRDIN+3\n         B     PRLP11DA\n         EJECT\n*        YOU ARE MOVING STEP AND PROGRAM NAME AT THIS POINT\n*\nSTPRG12  EQU   *\n         LA    R2,5(R3)           POINT TO AREA PAST ' EXEC '\n         LA    R3,RCRDIN+2\n         LA    R5,RCRDIN+9\n         SR    R7,R7\nSTPRG12A EQU   *              FIRST GET STEPNAME\n         CLI   0(R3),C' '\n         BE    STPRG12B\n         LA    R7,1(R7)\n         BXLE  R3,R4,STPRG12A\n*                             FALL THRU MEANS STEPNAME 8 BYTES LONG\nSTPRG12B EQU   *\n         CH    R7,=H'0'       CHECK FOR NO STEPNAME\n         BNE   STPR12BA\n         MVC   STEPSAVE,=C'*NONAME*'\n         B     STPR12BB\nSTPR12BA EQU   *\n         MVI   STEPSAVE,C' '\n         MVC   STEPSAVE+1(7),STEPSAVE\n         LA    R9,RCRDIN+2\n         LA    R8,STEPSAVE\n         BAL   R10,MOVE100\nSTPR12BB EQU   *\n         MVI   OUT1TYPE,C'S'\n         MVC   OUT1STPN,STEPSAVE\n         LR    R3,R2         POINT TO AREA PAST ' EXEC '\n*                                  NOW FIND PROGRAM NAME\n         LA    R5,RCRDIN+71\nSTPRG12C EQU   *\n         CLI   0(R3),C' '\n         BNE   STPRG12D\n         BXLE  R3,R4,STPRG12C\n*                             SHOULD NEVER FALL THRU\nSTPRG12D EQU   *\n         CLC   0(4,R3),=C'PGM='\n         BE    STPRG12F\n         CLC   0(5,R3),=C'PROC='\n         BE    STPRG12E\n         MVC   OUT1PRGN+9(6),=C'(PROC)' INDICATE PROC RATHER THAN PGM\n         B     STPRG12G       YOU ARE POINTING TO PROC NAME HERE\nSTPRG12E EQU   *\n         LA    R3,1(R3)       ADJUST TO PROC NAME\n         MVC   OUT1PRGN+9(6),=C'(PROC)' INDICATE PROC RATHER THAN PGM\nSTPRG12F EQU   *\n         LA    R3,4(R3)       ADJUST TO PGM NAME\nSTPRG12G LR    R9,R3\nSTPRG12H EQU   *              BEGIN OF PROC OR PGM NAME\n         CLI   0(R3),C' '\n         BE    STPRG12I\n         CLI   0(R3),C','\n         BE    STPRG12I\n         BXLE  R3,R4,STPRG12H\n*                             AS ABOVE SHOULD NOT FALL THRU\nSTPRG12I EQU   *\n         SR    R3,R9\n         LR    R7,R3          LENGTH OF PGM OR PROC NAME\n*              MAY BE MOVING MORE THAN 8 BYTES IF &PGM OR *.PGM.STEP\nSTPRG12J EQU   *\n         LA    R8,OUT1PRGN\n         BAL   R10,MOVE100\n         MVC   PROGSAVE,OUT1PRGN\n         CLI   0(R9),X'50'     FIRST CHECK FOR SYMBOLIC PGM\n         BNE   WRITE20         NOT SP - JUST WRITE IT\n         LA    R8,PARMARG\n         LA    R9,1(R9)        POINT PAST '&'\n         BAL   R10,MOVE100     '&' REQUIRES 1 MORE R7 REDUCTION\n         LA    R7,1(R7)        RESET R7 FOR SYPRM42 PROCESS\n         LA    R8,OUT1PRGN     POINT TO 'TO' AREA\n         LA    R10,STPRG12K\n         B     SYPRM42        DOUBLE THE MILEAGE OF DSN SP ROUTINES\nSTPRG12K EQU   *\n         MVC   PROGSAVE,OUT1PRGN   RESOLVE 'PROGSAVE' TOO\n*\nWRITE20  EQU   *\n         BAL   R10,WRITE80\n         B     LOOP10\n         EJECT\nCHKDD30  EQU   *              FIND DDNAME\n         LA    R3,RCRDIN+2\n         LA    R5,RCRDIN+72\nCHDD30AA EQU   *\n         CLC   0(4,R3),=C' DD '\n         BE    CHKDD30A       IT IS\n         BXLE  R3,R4,CHDD30AA\n*                             FALL THRU MEANS NOT DD RECORD\n         B     CKDSN40        SEE IF DSN RECORD\nCHKDD30A EQU   *\n         CLI   RCRDIN+2,C' '  CONCATINATION?\n         BE    CHKDD30D       YES, MOVE SAVED DDNAME TO RECORD\n*\n         LA    R3,RCRDIN+2    NO, SAVE DD NAME\n         LA    R5,RCRDIN+9\n         SR    R7,R7\nCHKDD30B CLI   0(R3),C' '\n         BE    CHKDD30C       END OF DDNAME\n         LA    R7,1(R7)\n         BXLE  R3,R4,CHKDD30B\n*                             FALL THRU MEANS DDN IS 8 BYTES LONG\nCHKDD30C EQU   *\n         LA    R9,RCRDIN+2\n         LA    R8,DDNSAVE\n         MVI   DDNSAVE,C' '\n         MVC   DDNSAVE+1(7),DDNSAVE\n         BAL   R10,MOVE100     MOVE DDNAME TO SAVE AREA\nCHKDD30D EQU   *\n         MVC   OUT1DDN,DDNSAVE            TO RECORD\n         MVI   OUT1TYPE,C'D'\n*\nCKDSN40  EQU   *              FIND DSN\n         LA    R3,RCRDIN+3\n         LA    R5,RCRDIN+71\nCKDSN40A EQU   *\n         CLC   0(4,R3),=C'DSN='\n         BE    CKDSN40D\n         CLC   0(7,R3),=C'DSNAME='\n         BE    CKDSN40C\n         CLC   0(2,R3),=C', '      CONTINUATION?\n         BE    CKDSN40B\n         BXLE  R3,R4,CKDSN40A\n*                                  NO DSN OR CONTINUATION ON FALL THRU\n         B     LOOP9               START LOOKING FOR SOMETHING ELSE\n*\nCKDSN40B EQU   *              KEEP LOOKING FOR DSN ON CONTINUATION\n         BAL   R10,READ70     RECORDS\n         B     CKDSN40\n*\nCKDSN40C EQU   *\n         LA    R3,3(R3)       ADJUST FOR DSNAME\nCKDSN40D EQU   *\n         LA    R3,4(R3)       ADJUST FOR DSN=\n*\n*                             MOVE DSN NO MATTER WHAT THE FORMAT\nMVDSN41  EQU   *\n         LR    R9,R3\n         SR    R7,R7\nMVDSN41A EQU   *\n         CLI   0(R3),C' '\n         BE    MVDSN41B\n         CLI   0(R3),C','\n         BE    MVDSN41B\n         LA    R7,1(R7)\n         BXLE  R3,R4,MVDSN41A\n*\nMVDSN41B EQU   *\n         LA    R8,OUT1DSN          DSN IN WHATEVER FORMAT NOW IN RCRD 1\n         BAL   R10,MOVE100         R7 DECREMENTED BY 1 HERE\n*\n*                         (1) HHG  12-29-83 SYMPARM RESOLVE REWRITE\n*\n         MVC   WORKDSN,WORKDSN-1   CLEAR WORK DSN AREA\n         LA    R8,WORKDSN          POINT TO BUILD DSN AREA\n         LA    R3,OUT1DSN\n         LA    R5,OUT1DSN+43\nMDSN41BA EQU   *\n         CLC   0(2,R3),=X'5050'    CHECK FOR TEMPDSN\n         BE    WDDDSN50                YEP, YOU'RE THRU\n         CLI   0(R3),X'50'         CHECK FOR SYMPARM\n         BE    MDSN41BD                RESOLVE IT\n         CLC   0(2,R3),=X'4B4B'    CHECK .. AFTER SYMPARM\n         BE    MDSN41BC\n         CLI   0(R3),C' '          BLANK MEANS DSN IS BUILT\n         BE    MDSN41BB\n         MVC   0(1,R8),0(R3)       MOVE BYTE TO WORK DSN\n         LA    R8,1(R8)            POINT TO BUILD DSN AREA NEXT BYTE\nMDSN41BB EQU   *\n         BXLE  R3,R4,MDSN41BA\n*\n         MVC   OUT1DSN,WORKDSN     MOVE RESOLVED DSN BACK TO RECORD\n         B     MDSN41BG            CHECK FOR (+0) GEN\n*                                                    -\nMDSN41BC EQU   *\n         LA    R3,1(R3)            POINT TO BUILD DSN AREA NEXT BYTE\n         MVI   0(R8),C'.'          MOVE DELIMITER INDICATOR\n         LA    R8,1(R8)            POINT TO BUILD DSN AREA NEXT BYTE\n         B     MDSN41BB            BUMP POINTER AND KEEP LOOKING\n*\nMDSN41BD EQU   *                   BUILD THE ARGUMENT\n         SR    R7,R7               LENGTH TO 0\n         MVC   PARMARG,PARMARG-1\n         LA    R9,PARMARG\n         LA    R10,MDSN41BF        BE SURE TO FINISH SEARCH\n         LA    R3,1(R3)            POINT PAST THE &\nMDSN41BE EQU   *\n         MVC   0(1,R9),0(R3)       MOVE BYTE TO WORK DSN\n         LA    R7,1(R7)            UP LENGTH +1\n         LA    R9,1(R9)            POINT TO BUILD ARG AREA NEXT BYTE\n         LA    R3,1(R3)            POINT TO FROM DSN AREA NEXT BYTE\n         CLI   0(R3),C'.'          ARE WE DONE?\n         BE    SYPRM42             YEP\n         CLI   0(R3),C' '\n         BE    SYPRM42             YEP\n         CLI   0(R3),C'('\n         BE    SYPRM42             YEP\n         CLI   0(R3),C')'\n         BE    SYPRM42             YEP\n         CLI   0(R3),X'50'\n         BE    SYPRM42             YEP\n         CR    R3,R5\n         BH    SYPRM42             YEP   THE DSN HAS BEEN EXHAUSTED\n         B     MDSN41BE            NOPE\n*\nMDSN41BF EQU   *                   RETURN HERE AND GO FOR MORE\n         L     R3,SAVE3\n         L     R5,SAVE5\n         AR    R8,R7               UP WORK DSN POINTER\n         LA    R8,1(R8) TO NEXT EMPTY SPACE\n         BCT   R3,MDSN41BB         BXLE ADJUSTMENT AND DOITTOIT\n*\n*                     END (1) HHG  12-29-83 SYMPARM RESOLVE REWRITE\n*\n*                     MUCH REDUNDANT CODE BELOW WAS REMOVED - HHG\n*\n*\nMDSN41BG EQU   *\n*\n         LA    R3,OUT1DSN+1   MAKE ANY '(+0)' = '(0)' -- AID THE XREF\n         LA    R5,OUT1DSN+41\nMDSN41BH EQU   *\n         CLC   0(4,R3),=C'(+0)'\n         BE    MDSN41BI\n         BXLE  R3,R4,MDSN41BH\n         B     MDSN41BJ           FALL THRU MEANS NO '(+0)'\nMDSN41BI EQU   *\n         LA    R3,1(R3)\n         LA    R5,1(R3)\n         MVC   0(2,R3),0(R5)  THIS OVERLAYS THE '+'\n         MVI   1(R5),X'40'    BLANK OUT EXTRA ')'\n*\nMDSN41BJ EQU   *\n         MVC   OUT2DSN,OUT1DSN     DSN NOW IN RECORD2 TO HANDLE BACKREF\n         CLI   0(R9),C'*'          IS THIS A BACK REF?\n         BE    BKREF43             YEP\n         B     WDDDSN50            NOPE\n         EJECT\n*                         (2) HHG  12-29-83 SYMPARM RESOLVE REWRITE\nSYPRM42  EQU   *\n         LA    R9,PARMARG\n         ST    R3,SAVE3       MAINTAIN POINTERS TO ORIGINAL DSN\n         ST    R5,SAVE5       *\n         BCT   R7,*+4         EXEC MOVE ADJUSTMENT\n         ST    R7,SAVE7       *\n         LA    R3,SPSTRING\n         LA    R5,SPSTRING+1535\n*                             END (2) HHG  12-29-83 REWRITE\nSYPR42AA EQU   *\n         CLI   0(R3),C','\n         BNE   SYPR42A1       COMPARE ONLY AFTER ',' DELIMITER\n         LA    R3,1(R3)       OK TO COMPARE - START WITH NEXT BYTE\n         EX    R7,COMP120\n         BE    SYPRM42A       YOU FOUND PARM NOW MOVE DSN\nSYPR42A1 EQU   *\n         BXLE  R3,R4,SYPR42AA\n         B     SYPRM42C       FALL THRU MEANS & IS PART OF DSN\nSYPRM42A EQU   *\n         AR    R3,R7          ADJUST TO REAL DSN\n         CLI   1(R3),C'='     MAKE SURE SP HAS NOT HIT ON AN = PREFIX\n         BNE   SYPR42A1       IT HAS, KEEP LOOKING\n         LA    R3,2(R3)       POINT PAST EQUAL '='  (ADJUST FOR R7)\n         CLI   0(R3),X'7D'    SURROUNDED BY QUOTES\n         BNE   SYPR42A2       NO\n         CLC   0(2,R3),=X'7D7D' YES. CHECK DOUBLE QUOTES FIRST HG 10/93\n         BE    SYPRM42C       PARM IS NULL, DON'T RESOLVE      HG 10/93\n         LA    R3,1(R3)       YES\nSYPR42A2 EQU   *\n         CLI   0(R3),C','     CHECK FOR A NO DEFAULT SITUATION\n         BE    SYPRM42C       I.E. 'PARM=,'\n         CLI   0(R3),C' '     CHECK FOR A NO DEFAULT SITUATION\n         BE    SYPRM42C       I.E. 'PARM= '\n         SR    R7,R7\n         LR    R9,R3        SAVE ADDR OF DEFAULT NAME\nSYPR42AB EQU   *\n         CLI   0(R3),C','\n         BE    SYPRM42B\n         CLI   0(R3),C' '\n         BE    SYPRM42B\n         CLI   0(R3),X'7D'    HAVE YOU HIT AN ENDING QUOTE?\n         BE    SYPRM42B\n         LA    R7,1(R7)\n         BXLE  R3,R4,SYPR42AB FALL THRU SHOULD NOT HAPPEN\nSYPRM42B EQU   *\n         BCT   R7,*+4         EXEC MOVE ADJUSTMENT\n         EX    R7,MOVE110     MOVE DSN FROM SYM PARM STRING\n         BR    R10            BACK TO STPRG12K OR MDSN41BF\nSYPRM42C EQU   *\n         LA    R9,PARMARG-1   MOVE UNRESOLVED PARM TO WORK DSN\n         L     R7,SAVE7       LENGTH OF UNRESOLVED SP\n         LA    R7,1(R7)       EXEC MOVE ADJUSTMENT-PICK UP &\n         EX    R7,MOVE110     MOVE DSN FROM SYM PARM STRING\n         BR    R10            BACK TO STPRG12K OR MDSN41BF\n         EJECT\n*                        CREATE RECORD TO RESOLVE BACK REF\nBKREF43  EQU   *\n         LR    R3,R9     RESTORE TO BEGIN OF DSN\n         SR    R6,R6     USE AS A COUNTER\n         LA    R3,1(R3)  POINT TO 1ST REFERBACK DELIMITER\nBKREF43A EQU   *\n         CLI   0(R3),C'.'     CHECK DELIMITERS\n         BE    BKREF43B       YES\n         CLI   0(R3),C','     CHECK END OF BACK REF\n         BE    BKREF43C       YES\n         CLI   0(R3),C' '\n         BE    BKREF43C       YES\n         BXLE  R3,R4,BKREF43A\n*\nBKREF43B EQU   *\n         LA    R6,1(R6)       INCRIMENT COUNT REGISTER\n         BXLE  R3,R4,BKREF43A\n*                             SHOULD NOT FALL THRU\nBKREF43C EQU   *\n         CH    R6,=H'1'       BACK REF FOR THIS STEP?\n         BNE   BKREF43D\n         LA    R9,2(R9)       YES,POINT TO DDNAME\n         LR    R3,R9     INITIATE LOOP 44A\n         SR    R7,R7     *\n         MVC   OUT2STPR,STEPSAVE  MOVE THIS STEPNAME AS STEP REF\n         B     MVDDR44A\n*\nBKREF43D EQU   *\n         LA    R9,2(R9)            POINT TO PRIOR STEP NAME\n         SR    R7,R7\n         LR    R3,R9\nBKREF43E EQU   *\n         CLI   0(R3),C'.'\n         BE    BKREF43F\n         LA    R7,1(R7)            LENGTH OF STEP NAME\n         BXLE  R3,R4,BKREF43E WILL NOT FALL THRU\n*\nBKREF43F EQU   *\n         LA    R8,OUT2STPR    POINT TO STEP REF\n         BAL   R10,MOVE100    MOVE IT\n         LA    R3,1(R3)       POINT TO PROCSTEP OR DDNAME\n         CH    R6,=H'2'       IS IT DDNAME?\n         BE    MVDDR44        YES\n*                             AT THIS POINT YOU HAVE A PROC STEP\nBKREF43G EQU   *\n         CLI   0(R3),C'.'\n         BE    BKREF43H       YOU HAVE NOW PASSED PROCSTEPNAME\n         BXLE  R3,R4,BKREF43G\n*                             YOU WILL NOT DROP THRU\nBKREF43H EQU   *\n         LA    R3,1(R3)       POINT TO DDNAME\n         EJECT\nMVDDR44  EQU   *\n         SR    R7,R7\n         LR    R9,R3          SAVE DDNAME ADDR\nMVDDR44A EQU   *\n         CLI   0(R3),C','\n         BE    MVDDR44B\n         CLI   0(R3),C' '\n         BE    MVDDR44B\n         LA    R7,1(R7)       LENGTH OF DDNAME\n         BXLE  R3,R4,MVDDR44A\n*                             SHOULD NOT FALL THRU\nMVDDR44B EQU   *\n         LA    R8,OUT2DDNR\n         BAL   R10,MOVE100    MOVE THE BACK REF DDN TO RECORD2\nWTBKRF45 EQU   *\n         MVC   OUT2PRCN,PROCSAVE\n         MVC   OUT2DDN,DDNSAVE\n         MVC   OUT2STPN,STEPSAVE\n         MVI   OUT2TYPE,C'R'\n         BAL   R10,WRITE90\n*                             WRITE RECORD 1 AT THIS POINT\nWDDDSN50 EQU   *\n         MVC   OUT1STPX,STEPSAVE\n         MVC   OUT1PRGX,PROGSAVE\n         MVC   OUT1PRCX,PROCSAVE\n         BAL   R10,WRITE80\n         BAL   R10,READ70\n         LA    R3,RCRDIN+2\n         LA    R5,RCRDIN+72\nNOMODD51 EQU   *                   MAKE SURE THE NEXT CARD IS NOT\n         CLC   0(6,R3),=C' PROC '  A DD CONCATINATION\n         BE    NOMODD52\n         CLC   0(5,R3),=C' JOB '\n         BE    NOMODD52\n         CLC   0(6,R3),=C' PEND '\n         BE    NOMODD53\n         CLC   0(6,R3),=C' EXEC '\n         BE    NOMODD54\n         BXLE  R3,R4,NOMODD51\n*\n         CLI   RCRDIN+2,C'*'\n         BNE   CHKDD30             YOU HAVE ANOTHER DD RECORD HERE\n*                                      OR RESIDUE FROM THE LAST ONE.\n         MVI   DDNSAVE,C' '\n         MVC   DDNSAVE+1(7),DDNSAVE\n         B     LOOP10A\n*\nNOMODD52 EQU   *\n         MVC   PROCSAVE(32),PROCSAVE-1       BLANK SAVE AREAS\nNOMODD53 EQU   *\n         BAL   R10,CLRSP60         BLANK SYMPARM WORK AREA\nNOMODD54 EQU   *\n         MVI   STEPSAVE,C' '\n         MVC   STEPSAVE+1(23),STEPSAVE\n         B     LOOP10A\n         EJECT\n*                   S U B R O U T I N E S\n*\nCLRSP60  EQU   *\n         MVC   SPSTRING(256),SPSTRING-1\n         MVC   SPSTRING+256(256),SPSTRING+255\n         MVC   SPSTRING+512(256),SPSTRING+511\n         MVC   SPSTRING+768(256),SPSTRING+767\n         MVC   SPSTRING+1024(256),SPSTRING+1023\n         MVC   SPSTRING+1280(256),SPSTRING+1279\n         BR    R10\n*\nREAD70   EQU   *\n         GET   FILEIN,RCRDIN\n         CLC   RCRDIN(3),=C'//*'  BYPASS COMMENTS (8-29-83) HG\n         BE    READ70\n         MVI   RCRDIN+71,C' ' BLANK WILL ALWAYS FOLLOW LAST COMMA\n         BR    R10\n*\nWRITE80  EQU   *                  WRITE PRIMARY FILE\n         PUT   FILEOUT1,RCRDOUT1\n         MVC   RCRDOUT1,RCRDOUT1-1\n         BR    R10\n*\nWRITE90  EQU   *                  WRITE SECONDARY FILE\n         PUT   FILEOUT2,RCRDOUT2\n         MVC   RCRDOUT2,RCRDOUT2-1\n         BR    R10\n*\nMOVE100  BCT   R7,MOVE100A        CORRECT LENGTH IN R7\nMOVE100A EX    R7,MOVE110\n         BR    R10\n*\nMOVE110  MVC   0(0,R8),0(R9)      EXECUTED MOVE INSTRUCTION\nCOMP120  CLC   0(0,R3),0(R9)      EXECUTED COMPARE INSTRUCTION\n*\nEOF130   EQU   *\n         CLOSE (FILEIN,,FILEOUT1,,FILEOUT2)\n         L     R13,REGSAVE+4\n         RETURN (14,12),RC=0\n         EJECT\nREGSAVE  DS    9D\nSVDSNLN  DS    F         SAVE AREA FOR DSN LENGTH\nSVPRMWD  DS    F         SAVE AREA FOR DSN ADDR\nSAVE9    DS    F         SAVE AREA FOR ADDR OF SUB PARM SYM PARM\n*\n*                         (3) HHG  12-29-83 SYMPARM RESOLVE REWRITE\n*\nSAVE3    DS    F         SAVE AREA R3\nSAVE5    DS    F         SAVE AREA R5\nSAVE7    DS    F         SAVE AREA R7\n         DC    X'50'\nPARMARG  DS    CL8       SYMBOLIC ARGUMENT WORK AREA\nFILLER   DC    CL32'XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX'\n*\n*                     END (3) HHG  12-29-83 SYMPARM RESOLVE REWRITE\n*\nFILEIN   DCB   DSORG=PS,LRECL=80,DDNAME=FILEIN,MACRF=(GM),EODAD=EOF130\nFILEOUT1 DCB   DSORG=PS,LRECL=80,DDNAME=FILEOUT1,MACRF=(PM)\nFILEOUT2 DCB   DSORG=PS,LRECL=80,DDNAME=FILEOUT2,MACRF=(PM)\n*\nRCRDIN   DS    CL80\n         DC    C' '\nRCRDOUT1 DS    0CL80     PRIMARY OUTPUT FILE\nOUT1TYPE DS    CL1\nOUT1DDN  DS    CL8       THIS DESCRIPTION IS FOR THE TYPE 'D' RECORD.\nOUT1DSN  DS    CL44      IT CONTAINS DDNAME AND DSNAME.\nOUT1STPX DS    CL8       IN ADDITION IT DUPLICATES INFO FOUND IN OTHER\nOUT1PRGX DS    CL8       RECORDS.   IE STEPNAME, PROGNAME AND PROCNAME.\nOUT1PRCX DS    CL8\n         DS    CL3\n*\n         ORG   OUT1DDN   THIS DESCRIPTION IS FOR THE TYPE 'S' RECORD.\nOUT1STPN DS    CL8       IT CONTAINS STEPNAME AND PROGNAME\nOUT1PRGN DS    CL8\n*\n         ORG   OUT1DDN   THIS DESCRIPTION IS FOR THE TYPE 'P' OR 'E'\nOUT1PRCN DS    CL8       RECORD. IT CONTAINS PROCNAME FOR BEGIN OR END\n         ORG\n*\n         DC    C' '\nRCRDOUT2 DS    0CL80     SECONDARY OUTPUT FILE\nOUT2TYPE DS    CL1       IDENTIFIED WITH 'R' FOR REFERBACK.\nOUT2DDN  DS    CL8       DDNAME                 * THIS FILE CAN BE USED\nOUT2DSN  DS    CL36      DSNAME                 * BY A FOLLOWING PROG\nOUT2PRCN DS    CL8        PROC REFERED TO\nOUT2STPN DS    CL8       THIS STEP NAME         * TO RESOLVE DSN BACK\nOUT2STPR DS    CL8       STEP NAME REFERED TO   * REFERENCES\nOUT2DDNR DS    CL8       DD NAME REFERED TO\n         DS    CL3\n         DC    C' '\nSPSTRING DC    1536C' '  SYMBOLIC PARM SAVE AREA\n         DC    C' '\nPROCSAVE DC    CL8' '\nSTEPSAVE DC    CL8' '\nPROGSAVE DC    CL8' '\nDDNSAVE  DC    CL8' '\n         DC    C' '\nWORKDSN  DC    CL44' '   SAVE AREA FOR QUAL  DSNS WITH SYM PARMS\n         END\nDOITTOIT ABEND 16,DUMP,STEP\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "U3511195": {"ttr": 38660, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x00\\x7f\\x00\\x88\\x00\\x7f\\x12\\x00\\x00\\xa0\\x00\\xa0\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf2\\xf7\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-01-07T00:00:00", "modifydate": "1988-01-07T12:00:00", "lines": 160, "newlines": 160, "modlines": 0, "user": "FILE270"}, "text": "000010 ID DIVISION.                                                     08/15/75\n000020 PROGRAM-ID.    U3511195.                                         19511U35\n000030 AUTHOR.        HOWARD H. GLASTETTER.                                LV005\n000040 INSTALLATION.  WASHINGTON STATE LIQUOR CONTROL BOARD.\n000050 DATE-WRITTEN.  JULY 2, 1975\n000060 DATE-COMPILED.\n000070 REMARKS.        THIS PROGRAM CREATES A TABLE OF UNRESOLVED DSN\n000080                 RECORDS.  IT THEN USES DSN RECORDS TO RESOLVE\n000090                 THE TABLE.  THE TABLE IN TURN IS USED TO RESOLVE\n000100                 BACK-REFERENCES IN ANY OF THE FOLLOWING DSN\n000110                 RECORDS THAT REQUIRE RESOLVING.\n000120 ENVIRONMENT DIVISION.\n000130 INPUT-OUTPUT SECTION.\n000140 FILE-CONTROL.\n000150     SELECT      RESOURCE-FILE-IN    ASSIGN  UT-S-FILEIN1.\n000160     SELECT      UNRESOLVED-FILE-IN  ASSIGN  UT-S-FILEIN2.\n000170     SELECT      RESOURCE-FILE-OUT   ASSIGN  UT-S-FILEOUT.\n000180 DATA DIVISION.\n000190 FILE SECTION.\n000200 FD  RESOURCE-FILE-IN\n000210     RECORD CONTAINS 80 CHARACTERS\n000220     BLOCK CONTAINS 0 RECORDS\n000230     LABEL RECORDS ARE STANDARD\n000240     RECORDING MODE IS F\n000250     DATA RECORD IS RESOURCE-RECORD.\n000260 01  RESOURCE-RECORD.\n000270     05  R-TYPE                  PIC X.\n000280         88  DSN-RECORD          VALUE IS 'D'.\n000290     05  R-DDNAME                PIC X(8).\n000300     05  R-DSN                   PIC X(44).\n000310     05  R-DSN-BREAKDOWN REDEFINES R-DSN.\n000320         10  R-REF-INDICATOR     PIC X.\n000330         10  FILLER              PIC X(39).\n000340     05  R-STEPNAME                  PIC X(8).\n000350     05  R-PROGNAME                  PIC X(8).\n000360     05  R-PROCNAME                  PIC X(8).\n000370     05  FILLER                      PIC X(3).\n000380 FD  UNRESOLVED-FILE-IN\n000390     RECORD CONTAINS 80 CHARACTERS\n000400     BLOCK CONTAINS 0 RECORDS\n000410     LABEL RECORDS ARE STANDARD\n000420     RECORDING MODE IS F\n000430     DATA RECORD IS UNRESOLVED-RECORD.\n000440 01  UNRESOLVED-RECORD               PIC X(80).\n000450 FD  RESOURCE-FILE-OUT\n000460     RECORD CONTAINS 80 CHARACTERS\n000470     BLOCK CONTAINS 0 RECORDS\n000480     LABEL RECORDS ARE STANDARD\n000490     RECORDING MODE IS F\n000500     DATA RECORD IS UPDATED-RECORD.\n000510 01  UPDATED-RECORD                 PIC X(80).\n000520 WORKING-STORAGE SECTION.\n000530 77  FILLER      PIC X(28)   VALUE 'WORKING STORAGE STARTS HERE '.\n000540 77  TABLE-COUNT             PIC S9(5)   COMP-3   VALUE ZERO.\n000550 77  TABLE-RECORDS-RESOLVED  PIC S9(5)   COMP-3   VALUE ZERO.\n000560 77  REFERBACK-DSNS-RESOLVED PIC S9(5)   COMP-3   VALUE ZERO.\n000570 77  RECS-IN                 PIC S9(5)   COMP-3   VALUE ZERO.\n000580 77  RECS-OUT                PIC S9(5)   COMP-3   VALUE ZERO.\n000590 77  I                       PIC S9999   COMP SYNC VALUE +1.\n000600 01  BACK-REF-TABLE.\n000610     05  TABLE-ELEMENT   OCCURS  200.\n000620         10  FILLER          PIC X.\n000630         10  TB-DDNAME       PIC X(8).\n000640         10  TB-REF-DSN      PIC X(36).\n000650         10  TB-PROC         PIC X(8).\n000660         10  TB-STEPNAME     PIC X(8).\n000670         10  TB-REF-STEPNAME PIC X(8).\n000680         10  TB-REF-DDNAME   PIC X(8).\n000690         10  FILLER          PIC XXX.\n000700     SKIP2\n000710 01  PROCESS-SWITCHES.\n000720     05  BACK-REF-END        PIC X.\n000730     88  GOOD-BACK-REF       VALUE IS '0'.\n000740     88  TABLE-IS-BUILT      VALUE IS '1'.\n000750     05  RESOURCE-END        PIC X.\n000760     88  GOOD-RESOURCE       VALUE IS '0'.\n000770     88  ALL-RECORDS-PROCESSED   VALUE IS '1'.\n000780     05  RESOLVED-SWITCH     PIC X.\n000790     88  DSN-RESOLVED        VALUE IS '1'.\n000800     EJECT\n000810 PROCEDURE DIVISION.\n000820 LOGIC-CONTROL SECTION.\n000830     PERFORM HOUSEKEEPING-10.\n000840     PERFORM BUILD-TABLE-20 UNTIL TABLE-IS-BUILT.\n000850     PERFORM RESOLVE-TBL-AND-DSNS-30 UNTIL ALL-RECORDS-PROCESSED.\n000860     PERFORM END-JOB-60.\n000870     GOBACK.\n000880 END-OF-LOGIC-CONTROL-SECTION.\n000890     SKIP3\n000900 HOUSEKEEPING-10.\n000910     OPEN INPUT RESOURCE-FILE-IN, UNRESOLVED-FILE-IN\n000920         OUTPUT RESOURCE-FILE-OUT.\n000930         MOVE SPACES TO BACK-REF-TABLE.\n000940         MOVE '000' TO PROCESS-SWITCHES.\n000950     SKIP2\n000960* A.1\n000970     SKIP2\n000980 BUILD-TABLE-20.\n000990     READ UNRESOLVED-FILE-IN\n001000         AT END MOVE '1' TO BACK-REF-END.\n001010     IF GOOD-BACK-REF\n001020         ADD 1 TO TABLE-COUNT\n001030         MOVE UNRESOLVED-RECORD TO TABLE-ELEMENT (TABLE-COUNT).\n001040*    END-IF\n001050 RESOLVE-TBL-AND-DSNS-30.\n001060     READ RESOURCE-FILE-IN\n001070         AT END MOVE '1' TO RESOURCE-END.\n001080     IF GOOD-RESOURCE\n001090         ADD 1 TO RECS-IN\n001100* A.2\n001110         IF DSN-RECORD AND R-REF-INDICATOR NOT = '*'\n001120             THEN\n001130                 PERFORM RESOLVE-TABLE-40\n001140                 VARYING I FROM 1 BY 1 UNTIL I > TABLE-COUNT\n001150* A.3\n001160             ELSE IF DSN-RECORD AND R-REF-INDICATOR = '*'\n001170                    THEN PERFORM RESOLVE-DSN-50\n001180                         VARYING I FROM 1 BY 1 UNTIL DSN-RESOLVED\n001190                         OR I > TABLE-COUNT\n001200                         MOVE 0 TO RESOLVED-SWITCH.\n001210*    END IF\n001220     SKIP2\n001230* A.4\n001240     SKIP2\n001250     IF GOOD-RESOURCE\n001260         WRITE UPDATED-RECORD FROM RESOURCE-RECORD\n001270         ADD 1 TO RECS-OUT.\n001280     SKIP2\n001290* A.2 EXTENDED LOGIC\n001300     SKIP2\n001310 RESOLVE-TABLE-40.\n001320     IF R-DDNAME = TB-REF-DDNAME (I)\n001330     AND R-STEPNAME = TB-REF-STEPNAME (I)\n001340     AND R-PROCNAME = TB-PROC (I)\n001350         THEN\n001360             MOVE R-DSN TO TB-REF-DSN (I)\n001370             ADD 1 TO TABLE-RECORDS-RESOLVED.\n001380     SKIP2\n001390* A.3 EXTENDED LOGIC\n001400     SKIP2\n001410 RESOLVE-DSN-50.\n001420     IF TB-DDNAME (I) = R-DDNAME\n001430     AND TB-STEPNAME (I) = R-STEPNAME\n001440     AND TB-PROC (I) = R-PROCNAME\n001450         MOVE TB-REF-DSN (I) TO R-DSN\n001460         MOVE '1' TO RESOLVED-SWITCH\n001470         ADD 1 TO REFERBACK-DSNS-RESOLVED.\n001480     SKIP2\n001490* A.5\n001500     SKIP2\n001510 END-JOB-60.\n001520     DISPLAY 'U3511195 -- RESOLVE BACKREF PROGRAM CONTROL TOTALS'.\n001530     DISPLAY RECS-IN ' RECORDS IN, ' RECS-OUT ' RECORDS OUT.'\n001540     DISPLAY TABLE-COUNT ' REFERBACK RECORDS, '\n001550             TABLE-RECORDS-RESOLVED ' RESOLVED IN THE TABLE, '\n001560             REFERBACK-DSNS-RESOLVED ' RESOLVED BY THE TABLE.'\n001570     DISPLAY 'THE ABOVE LINES INDICATE ERR IF TOTALS UNEQUAL.'.\n001580     CLOSE RESOURCE-FILE-IN\n001590           UNRESOLVED-FILE-IN\n001600           RESOURCE-FILE-OUT.\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "VOL2DEV$": {"ttr": 38664, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x00\\x7f\\x00\\x88\\x00\\x7f\\x12\\x00\\x00@\\x00@\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf2\\xf7\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-01-07T00:00:00", "modifydate": "1988-01-07T12:00:00", "lines": 64, "newlines": 64, "modlines": 0, "user": "FILE270"}, "text": "1                                                        VOL2DEVT.1\n                                                         06/25/82\n\n\n  PROGRAM:       VOL2DEVT\n  AUTHOR:        Jeff Sprehn\n  AGENCY:        WDPSC\n  LANGUAGE:      Assembler\n  LOCATION:      WDPSC.SHARED.LOAD\n  FUNCTION:      Subroutine which  accepts a  volume serial  number\n                 and returns the device type.\n\n  RUN MODE:      Batch or interactive.\n\n  To call this program, do the following:\n\n  1.   Place the following data area in WORKING STORAGE:\n\n            01   VOL2DEVT-I-O-AREA.\n                 05   VOL-SER-NO                   PIC X(6).\n                 05   DEVICE-TYPE                  PIC X(8).\n                 05   SIGNIF-LENGTH-OF-DEVICE-TYPE PIC S9(3) COMP.\n\n  2.   In the PROCEDURE DIVISION:\n\n       MOVE your 6 digit volume serial number\n            TO VOL-SER-NO OF VOL2DEVT-I-O-AREA.\n       CALL 'VOL2DEVT' USING VOL2DEVT-I-O-AREA.\n\n\n\n\n1                                                        VOL2DEVT.2\n                                                         06/25/82\n\n\n       After the call,  the device type is found  in DEVICE-TYPE of\n       VOL2DEVT-I-O-AREA and  the significant length of  that field\n       will be found in SIGNIF-LENGTH-OF-DEVICE-TYPE.\n\n       Possible return codes are:\n\n            0    SUCCESSFUL COMPLETION\n            4    VOLUME NOT MOUNTED\n            8    UCB ERROR\n           12    NON RECOGNIZABLE UNIT TYPE\n\n  EXAMPLE\n  _______\n\n  Suppose, in a COBOL program we  wish to determine the device type\n  for volume 335071.\n\n  MOVE '335071' TO VOL-SER-NO OF VOL2DEVT-I-O-AREA.\n  CALL 'VOL2DEVT' USING VOL2DEVT-I-O-AREA.\n\n  After the call:\n\n       DEVICE-TYPE will contain '3350    '\n       SIGNIF-LENGTH-OF-DEVICE-TYPE will be +4\n\n\n\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "VOL2DEVT": {"ttr": 38666, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x00\\x7f\\x00\\x88\\x00\\x7f\\x12\\x00\\x00\\x94\\x00\\x94\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf2\\xf7\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-01-07T00:00:00", "modifydate": "1988-01-07T12:00:00", "lines": 148, "newlines": 148, "modlines": 0, "user": "FILE270"}, "text": "*        THIS PROGRAM IS A SUBROUTINE WHICH WILL ACCEPT A VOLUME SERIAL\n*        NUMBER AND PASS BACK TO THE INVOKER THE DEVICE TYPE\n*\n*        TO CALL THIS PROGRAM, DO THE FOLLOWING :\n*\n*           MOVE YOUR VOL SER TO VOL-SER-NO OF VOL2DEVT-I-O-AREA.\n*\n*           CALL 'VOL2DEVT' USING VOL2DEVT-I-O-AREA.\n*\n*           AFTER THE CALL, DEVICE-TYPE WILL CONTAIN THE DEVICE TYPE\n*           AND SIGNIF-LENGTH-OF-DEVICE-TYPE WILL CONTAIN THE\n*           SIGNIFICANT LENGTH OF THE DEVICE TYPE\n*\n*                WHERE:\n*\n*              01  VOL2DEVT-I-O-AREA.\n*                  05  VOL-SER-NO                    PIC X(6).\n*                  05  DEVICE-TYPE                   PIC X(8).\n*                  05  SIGNIF-LENGTH-OF-DEVICE-TYPE  PIC S9(3) COMP.\n*\n*\n*         RETURN CODES        MEANING\n*         -----------------   -----------------------------------\n*\n*                 0           SUCCESSFUL COMPLETION\n*                 4           VOLUME NOT MOUNTED\n*                 12          NON RECOGNIZABLE UNIT TYPE\n*\n*---------------------------------------------------------------------\n*\n*  ACTIVITY LOG:\n*     VERSION 2.0  -  GORDON SCHILLINGER  DIS/CSD             9/9/88\n*                     MODIFIED CODE TO BE RE-ENTERANT\n*\n*---------------------------------------------------------------------\n         EJECT\n**********************************************\n*                                            *\n*        I N I T I A L I Z A T I O N         *\n*                                            *\n**********************************************\nVOL2DEVT ENTERR LEVEL=V_2.0\n         LR    R11,R1\n         L     R9,0(R11)\n         MVC   IOAREA,0(R9)\n         LA    R0,UCBWA\n         LA    R1,DEVCL\n         LA    R2,UCBADD\n         STM   R0,R2,PLIST\n         MVI   UCBPTR,X'80'\n         MVI   DEVCL,X'20'\n         EJECT\n********************************************************************\n*                                                                  *\n*        M A I N   L I N E   L O G I C                             *\n*                                                                  *\n********************************************************************\n         L     R9,16                   ADDRESS OF CVT INTO R9\n         XC    UCBWA,UCBWA             UCB LOOKUP LIST FROM CVT\nUCBSCAN  L     R15,1076(R9)\n         LA    R1,PLIST\n         BALR  R14,R15\n         LTR   R15,R15\n         BNZ   UCBERR1\n         L     R6,UCBADD               GET ADDRESS OF A UCB\n         TM    0(R6),X'80'             IS IT VIO?\n         BO    UCBSCAN                 IF YES, BRANCH TO UCBSCAN\n         TM    3(R6),X'80'             IS IT ONLINE?\n         BNO   UCBSCAN                 IF NOT, BRANCH TO UCBSCAN\n         CLC   VOLSER,28(R6)           TABLE ENTRY VS VOL IN UCB\n         BNE   UCBSCAN                 IF NOT EQUAL, BRANCH TO UCBSCAN\n         CLI   19(R6),X'0B'            3350 DA?\n         BE    D3350                   IF YES, BRANCH TO D3350\n         CLI   19(R6),X'09'            3330 DA?\n         BE    D3330                   IF YES, BRANCH TO D3330\n         CLI   19(R6),X'0D'            3330 DA?\n         BE    D3330                   IF YES, BRANCH TO D3330\n         CLI   19(R6),X'06'            2305 DA?\n         BE    D2305                   IF YES, BRANCH TO D2305\n         CLI   19(R6),X'07'            2305-2 DA?\n         BE    D23052                  IF YES, BRANCH TO D23052\n         CLI   19(R6),X'0E'            3380 DA?\n         BE    D3380                   IF YES, BRANCH TO 3380\n         B     UCBERR2                 WHAT IN THE HECK IS IT THEN?\nUCBERR1  LA    R4,4                   SET R4 = 4\n         B     SHUTDOWN               BRANCH TO SHUTDOWN\nUCBERR2  LA    R4,12                  SET R4 = 12\n         B     SHUTDOWN               BRANCH TO SHUTDOWN\nD3350    MVC   DEVTTYPE,=C'3350    '  MOVE 3350 TO DEVTTYPE\n         LA    R7,4                   ---\n         STH   R7,LEN                    --- DEVTLEN = 4\n         MVC   DEVTLEN,LEN            ---\n         B     ALLGOOD                BRANCH TO ALLGOOD\nD3330    MVC   DEVTTYPE,=C'3330-1  '  MOVE 3330-1 TO DEVTTYPE\n         LA    R7,6                   ---\n         STH   R7,LEN                    --- DEVTLEN = 6\n         MVC   DEVTLEN,LEN            ---\n         B     ALLGOOD                BRANCH TO ALLGOOD\nD2305    MVC   DEVTTYPE,=C'2305    '  MOVE 2305 TO DEVTTYPE\n         LA    R7,4                   ---\n         STH   R7,LEN                    --- DEVTLEN = 4\n         MVC   DEVTLEN,LEN            ---\n         B     ALLGOOD                BRANCH TO ALLGOOD\nD23052   MVC   DEVTTYPE,=C'2305-2  '  MOVE 2305-2 TO DEVTTYPE\n         LA    R7,6                   ---\n         STH   R7,LEN                    --- DEVTLEN = 6\n         MVC   DEVTLEN,LEN            ---\n         B     ALLGOOD                BRANCH TO ALLGOOD\nD3380    MVC   DEVTTYPE,=C'3380    '  MOVE 3380 TO DEVTTYPE\n         LA    R7,4                   ---\n         STH   R7,LEN                    --- DEVTLEN = 4\n         MVC   DEVTLEN,LEN            ---\nALLGOOD  LA    R4,0                   SET R4 = 0\n         B     SHUTDOWN               BRANCH TO SHUTDOWN\n********************************************************************\n*                                                                  *\n*        E N D  O F   J O B   P R O C E S S I N G                  *\n*                                                                  *\n********************************************************************\nSHUTDOWN LR    R15,R4\n         L     R9,0(R11)\n         MVC   0(16,R9),IOAREA\n         L     R13,4(R13)\n         RETURN (14,12),RC=(15)\n         EJECT\n********************************************************************\n*                                                                  *\n*        D A T A   A R E A S                                       *\n*                                                                  *\n********************************************************************\nWORKAREA DSECT\nSAVEAREA DS    18F\nLEN      DS    H\nPLIST    DS    0F\nUCBWAP   DC    A(UCBWA)\nUCBCLP   DC    A(DEVCL)\nUCBPTR   DC    X'80',AL3(UCBADD)\nUCBWA    DS    XL100\nDEVCL    DC    X'20'\nUCBADD   DS    A\n*\nIOAREA   DS    0CL16\nVOLSER   DS    CL6\nDEVTTYPE DS    CL8\nDEVTLEN  DS    CL2\n*\nWORKLEN  EQU   *-WORKAREA\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "VSAMSCAN": {"ttr": 38670, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x00\\x7f\\x00\\x88\\x00\\x7f\\x12\\x00\\x01H\\x01H\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf2\\xf7\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-01-07T00:00:00", "modifydate": "1988-01-07T12:00:00", "lines": 328, "newlines": 328, "modlines": 0, "user": "FILE270"}, "text": "//DNC00150 JOB  (2100,56-D),'DPARS 0682 T',CLASS=H,MSGCLASS=T\n//A EXEC ASMHCL,LIBRARY='WDPSC.TSAEXAM',OPTION2='AC=1',\n//   LNDSP=SHR,OPTION1=TERM\n*\n* THIS PROGRAM READS A CATALOG AND CREATES AN IDCAMS CONTROL CARD TO\n* DELETE THE ENTRY. OTHER PROGRAMS PROCESS THE CONTROL CARD TO\n* DETERMINE VALIDITY.\n*\n* OUTPUT FORMAT\n* COLUMN 2    -  DEL\n* COLUMN 6    -  'DATA SET NAME FROM NONVSAM CATALOG ENTRY'\n* COLUMN      -  NSCR\n* COLUMN 70   -  'FILESEQUENCE NUMBER'\n* COLUMN 73   -  'LAST TWO BYTES OF THE DEVICETYPE VALUE'\n* COLUMN 75   -  'VOLUME SERIAL'\n*\n* A CARD IS PRODUCED FOR EACH NON-VSAM ENTRY IN THE CATALOG\n         SPACE 1\nVSAMSCAN CSECT\n         REGISTER\n         USING *,R15                     USE R15 AS BASE-REGISTER\n         B     START                     BRANCH AROUND DATE\n         DC    C'VSAMSCAN  82/07/30'     MODULE ID AND DATE\n         CNOP  0,4                       START ON FW BOUNDARY\nSTART    STM   R14,R12,12(R13)           STORE ALL REGISTERS\n         ST    R13,SAVE+4                STORE R13 TO SAVE AREA\n         LA    R12,SAVE                  LOAD ADDR OF SAVE-AREA TO R12\n         ST    R12,8(,R13)               STORE R12\n         CNOP  0,4                       SET NEXT INSTR TO FW-BOUNDARY\n         BAL   R13,SAVE+18*4             BRANCH AROUND SAVE AREA\n         USING SAVE,R13,R12              DEFINE BASE REGISTERS\n         DROP  R15                       STOP USING R15 AS BASE-REG\nSAVE     DC    18F'0'                    SAVE AREA\n         LA    R12,2048(,R13)            LOAD BASE-REGISTER\n         LA    R12,2048(,R12)            LOAD BASE-REGISTER\n         L     R1,0(,R1)                 LOAD ADDR OF EXEC PARM-FIELD\n         LH    14,0(,R1)                 LOAD LENGTH OF PARM-FLD\n         LTR   R14,R14                   PARM IN EXEC CARD ?\n         BZ    OPEN                      NO PARMS PASSED, OPEN\n         LA    R3,2(,R1)                 POINT R3 TO PARMLIST\nMOVEPW   C     R14,=F'8'                 PW NOT OVER 8 BYTES?\n         BNH   *+8                       IF SO, MOVE ONLY 8\n         LA    R14,8                     8 MAX\n         BCTR  R14,0                     DECREMENT FOR MVC\n         EX    R14,MOVE                  MOVE PW\n         B     OPEN                      DO OPEN\nMOVE     MVC   PW+1(0),2(R1)             OBJECT FOR EXEC\nOPEN     EQU   *\n         OPEN  (PRINT,(OUTPUT),AMSOUT,(OUTPUT))\n         LTR   R15,R15\n         BNZ   ABEND                     ABEND U0999\n         OPEN  (ACBCAT,INPUT)\n         LTR   R15,R15\n         BZ    A000\n         CLI   ACBCAT+49,X'74'           NEED VERIFY?\n         BNE   ABEND\nA000     VERIFY RPL=RPLDIR\n         LTR   R15,R15                  DID THE VERIFY WORK?\n         BNZ   ABEND\n         MVI   RPLDIR+40,X'42'          PUT DIR,GEN BACK\n         MVI   RPLDIR+41,X'81'          PUT KEY,NSP BACK\n         EJECT\n*        GET INFORMATION FROM THE CATALOG'S SELF DEFINING RECORDS\n         SPACE 1\n         MVC   KEY(4),=X'00000002'       SET KEY TO CAT-CLUSTER ENTRY\n         GET   RPL=RPLDIR                GET CATALOG RECORD\n         LTR   R15,R15\n         BZ    A011\n         LA    R1,998\n         B     ABEND+4                   ABEND U0998\nA011     MVC   Z0(36),CATREC+49          SAVE CAT NAME\n         TRT   CATREC+49(44),TAB3        TEST LENGTH OF CATALOG-NAME\n         BZ    A015\n         LA    R2,CATREC+49               LOAD START ADDR OS DSN\n         SR    R1,R2                       GET LENGTH OF DSN + 2\n         AH    R1,=H'5'                   ADD 2 TO CURRENT LENGTH\nA015     EQU   *\n         MVC   KEY(4),=X'00000003'       SET KEY TO CCR-ENTRY\n         SPACE 1\n*        GET CATALOG CONTROL-RECORD\n         GET   RPL=RPLDIR                GET CCR-RECORD\n         LTR   R15,R15\n         BZ    A021\n         LA    R1,997\n         B     ABEND+4                   ABEND U0997\nA021     CLI   CATREC+44,C'L'            L-RECORD ?\n         BNE   Z010                      NO, END THE PROGRAM\nA025     EQU   *\n         MVC   CCR(256),CATREC           SAVE CCR RECORD\n         MVC   CCR+256(256),CATREC+256   SAVE CCR RECORD\n         SPACE 1\n         CLC   CCR+48(3),CCR+45          COMPARE HU AND NF CI'S\n         BNL   A031                      BRANCH TO USE HU\n         MVC   KEY+1(3),CCR+48           SET KEY TO FIRST UNFORM REC\n         L     R6,KEY                    LOAD KEY\n         BCTR  R6,0                      REDUCE CI-NR BY 1\n         B     A032\nA031     MVC   KEY+1(3),CCR+45           USE HIGH USED KEY\n         L     R6,KEY                    LOAD KEY TO R8\nA032     ST    R6,KEY                    STORE KEY\n         GET   RPL=RPLSEQ                GET LAST FORMATTED RECORD\n         LTR   R15,R15\n         BNZ   LERAD\n         CLI   HKRREC,X'00'              LOW KEY RANGE RECORD ?\n         BE    A035                      YES,GET THE NEXT RECORD\n         MVC   CATREC(256),HKRREC        STORE RECORD\n         MVC   CATREC+256(256),HKRREC+256 STORE RECORD\n         MVC   SNAPID(4),=C'A030'        SET SNAP ID\n         MVI   CCR,C'*'                  MARK BUFFER FOR OUTPUT\n         MVI   CATREC,C'*'               MARK BUFFER FOR OUTPUT\n         B     Z010                      NO,TRY TO FIND OUT WHAT IS WR\nA035     EQU   *\n         MODCB RPL=RPLSEQ,OPTCD=SEQ      MODIFY ACCESS MODE TO SEQ\n         GET   RPL=RPLSEQ                GET NEXT SEQ RECORD\n         LTR   R15,R15\n         BNZ   LERAD\n         CLI   HKRREC,X'40'              FIRST HKRREC ?\n         BNL   A040                      YES,GO FORWARD\n         MVC   SNAPID(4),=C'A035'        SET SNAP IDENTIFICATION\n         B     Z010                      NO,TRY TO FIND OUT WHATS WRONG\nA040     EQU   *\n         MVC   KEY+1(3),CCR+48           SET KEY TO MAX NR OF LKR-CIS\n         B     C020                      BRANCH FORW TO TEST FREE-CHAIN\n         EJECT\n*        READ HKR SEQUENTALLY TO GET ENTRIES CI-NUMBER\n         SPACE 1\nC010     EQU   *\n         GET   RPL=RPLSEQ                GET NEXT HKR RECORD\n         LTR   R15,R15\n         BZ    C020\n         LA    R1,993\n         B     ABEND+4                   ABEND U0993\nC020     EQU   *\n         MVC   KEY+1(3),HKRREC+44        USE CI-NR OF HKR-REC AS S-ARG\n         GET   RPL=RPLDIR                GET THIS LKR-RECORD\n         LTR   R15,R15\n         BZ    C021\n         LA    R1,992\n         B     ABEND+4                   ABEND U0992\nC021     EQU   *\n         CLI   CATREC+44,C'A'            NON-VSAM RECORD  ?\n         BNE   C010                      GET NEXT CATALOG RECORD\n         EJECT\n*        READ NON-VSAM ENTRIES AND VERIFY THEIR POINTERS\n         SPACE 1\nG010     EQU   *\n         CLC   HKRREC(44),CATREC+49      COMPARE DSN IN HKR AND LKR\n         BNE   C010                      READ NEXT IN SEQUENCE\nG020     EQU   *\n         MVC   RX(256),CATREC            SAVE NON-VSAM RECORD\n         MVC   RX+256(256),CATREC+256    SAVE NON-VSAM RECORD\n         MVC   CINUM(4),CATREC           SAVE CI-NUMBER OF A-RECORD\n         SR    R9,R9                       CLEAR R9\n         IC    R9,RX+48                  GET DISP TO HORIZ PTR\n         LA    R10,RX                    POINT TO CAT REC\n         AR    R9,R10                    POINT TO HORIZ PTR\n         LA    R10,5(R9)                 POINT TO # SOF PTRS\n         SR    R9,R9                     CLEAR R9\n         IC    R9,0(,R10)                 GET # SOF PTRS\n         LA    R10,1(,R10)                POINT TO FIRST SOF PTR\n         LR    R6,R9                     SAVE PTR\n         MH    R6,=H'5'                  CALC DISP TO FIRST SOF\n         AR    R6,R10                    POINT TO FIRST SOF\n         B     G030\nG025     EQU   *\n         MVC   RX(256),CATREC            SAVE E-RECORD\n         MVC   RX+256(256),CATREC+256    SAVE E-RECORD\n         SR    R9,R9                       CLEAR R9\n         IC    R9,RX+48                  GET DISP TO HORIZ PTR\n         LA    R10,RX                    POINT TO CAT REC\n         AR    R9,R10                    POINT TO HORIZ PTR\n         LA    R10,5(,R9)                 POINT TO # SOF PTRS\n         SR    R9,R9                     CLEAR R9\n         IC    R9,0(,R10)                 GET # SOF PTRS\n         LA    R10,1(,R10)                POINT TO FIRST SOF PTR\n         LR    R6,R9                     SAVE PTR\n         MH    R6,=H'5'                  CALC DISP TO FIRST SOF\n         AR    R6,R10                    POINT TO FIRST SOF\n         B     G030\nG030     EQU   *\n         TM    3(R10),X'40'               DELETED SOF-POINTER ?\n         BO    G120                      YES,GET NEXT SOF-POINTER\n         TM    3(R10),X'03'               VOLUME INFORMATION SOF ?\n         BO    G040                      YES\n         B     G120                      NO,GET NEXT SOF-POINTER\nG040     EQU   *\n         TM    3(R10),X'80'               SET OF FIELD IN EXT-RECORD ?\n         BO    G120                      YES, SKIP THIS SET OF FIELDS\n         SPACE 1\n*        GET ASSOCIATED RECORD,DESCRIBED IN THIS NON-VSAM RECORD\nG080     EQU   *\n         TM    3(R10),X'03'               VOLUME-INFORMATION SOF ?\n         BNO   C010                      GET NEXT SOF-POINTER IN A-REC\nG085     SR    R4,R4\n         ICM   R4,3,1(R10)               DISPLACEMENT TO SOF\n         LA    R4,0(R4,R6)               ADDRESS OF VOLUME SOF\n         MVC   AMSCARD+72(8),4(R4)       MOVE VOLUME AND DEVICETYPE\n         MVC   AMSDSN(44),HKRREC         MOVE DATA SET NAME\n         LH    R9,12(,R4)                FILESEQUENCE NUMBER\n         CVD   R9,DOUBLWRK\n         UNPK  DOUBLWRK(5),DOUBLWRK+5(3)\n         MVC   AMSCARD+68(3),DOUBLWRK+2\n         OI    AMSCARD+70,C'0'\n         PUT   AMSOUT,AMSCARD\n         B     C010\nG120     EQU   *\n         LA    R10,5(,R10)               LOAD ADDRESS OF NEXT SOF-PTR\n         BCT   R9,G030                   IN THIS NONVSAM-RECORD\n*        DETERMINE IF IN THIS RECORD IS A POINTER TO HORIZ EXT-RECORD\n         SR    R9,R9                     CLEAR R9\n         IC    R9,RX+48                  GET DISPL TO HORIZ PTR\n         LA    R10,RX                    POINT TO RECORD\n         AR    R9,R10                    POINT TO HORIZ PTR\n         CLC   0(5,R9),=X'0000000000'    IS THERE A HORIZ PTR ?\n         BE    C010                      NO\n         MVC   KEY+1(3),0(R9)            SET KEY TO HORIZ EXT REC\nG135     EQU   *\n         GET   RPL=RPLDIR                GET THIS RECORD\n         LTR   R15,R15\n         BNZ   LERAD1                    BRANCH TO LERAD-ROUTINE\n         CLI   CATREC+44,C'E'            EXTEMSION RECORD ?\n         BE    G025                      YES\n         MVC   SNAPID(4),=C'G135'        SET SNAP IDENTIFICATION\n         B     C010                      GET NEXT KKR-RECORD\n         SPACE 3\n         EJECT\n*        LOGICAL-ERROR IN GET-REQUEST,DISPLAY ALL AVAILABLE INFO\n         SPACE 1\nLERAD1   EQU   *\n         LA    R1,496                    SET RETURN CODE\n         B     ABEND+4                   TRY TO GET NEXT HKR-RECORD\n         SPACE 3\nLERAD    EQU   *\n         LA    R1,867                    SET RETURN CODE\n         B     ABEND+4\nZ010     EQU   *\n         CLOSE (ACBCAT)                  CLOSE CATALOG\n         L     R15,RETURN                SET RETURN-CODE\n         L     R13,SAVE+4\n         RETURN (14,12),RC=(15)          RESET REGISTERS\n         BR    14\nABEND    EQU   *\n         ABEND 999,DUMP\nPATCH    DC    10F'0'                    ADD A PATCH AREA\n         EJECT\n*        D E F I N I T I O N S\n         SPACE 1\nPW       DS    0F                        PASSWORD,IF CATALOG PROTECTED\n         DC    XL1'08'                   MAX LENGTH OF PASSWORD\n         DC    CL8'        '\n         DS    0F                        START ON WORD BOUNDARY\nKEYNAME  DS    0D\n         DC    CL4'KEY '                 MARK KEY FIELD\nKEY      DS    0D                        KEY USED FOR DIRECT ACCESS\n         DC    XL4'00000000'             KEY FIELD\nXKEY     DC    XL4'00000000'             EXTERNAL KEY\nCCR      DS    CL512                     SAVE AREA FOR CCR-RECORD\nCCRE     DS    0C\nHKRREC   DS    CL512                     BUFFER FOR HKR-RECORD\nHKRRECE  DS    0C\nRX       DS    CL512                     SAVE-AREA FOR CATALOG RECORD\nRXE      DS    0C\nCATREC   DS    CL512                     BUFFER FOR CATALOG RECORD\nCATRECE  DS    0C                        END OF CATALOG RECORD\nEXTREC   DS    CL512                     BUFFER FOR ASS-EXT RECORD\nEXTRECE  DS    0C\nR2BRANCH DC    F'0'                      REGISTER SAVE-AREA\nR2SAVE   DC    F'0'                      REGISTER SAVE-AREA\nR3SAVE   DC    F'0'                      REGISTER SAVE AREA\nR4SAVE   DC    F'0'                      REGISTER SAVE AREA\nR5SAVE   DC    F'0'                      REGISTER SAVE AREA\nR6SAVE   DC    F'0'                      REGISTER SAVE-AREA\nR7SAVE   DC    F'0'                      REGISTER SAVE-AREA\nR9SAVE   DC    F'0'                      REGISTER SAVE-AREA\nR10SAVE  DC    F'0'                      REGISTER SAVE-AREA\nZ0       DC    CL44' '\n         ORG\nTAB3     DC    XL256'00'                 TABLE USED BY TRT\n         ORG   TAB3+X'40'                SET TEST-BYTE POSITION\n         DC    X'FF'                     BYTE TO BE TESTED\n         ORG\n         DC    CL1' '\n         DS    0D\nMASK     DC    X'402020202020212160'\nSKIPCTR  DC    PL4'0'                    COUNTER USED TO SKIP PAGE\nDUMPCTR  DC    PL4'0'                    COUNTER USED TO DUMP RECORDS\nRETURN   DC    F'0'                      PGM RETURN-CODE\nADDR     DC    F'0'                      FIELD USED BY GETMAIN MACRO\nCHECK    DC    CL1' '                    CHECK BYTE TO MARK READ RECS\nSEQNR    DC    CL1' '                    SAVE-AREA FOR SEQ-NR\nSID      DC    CL1' '                    SEQ-NR FOR PTR BACK TO CLUSTER\nRCHECK   DC    CL1' '                    CHECK-BYTE FOR REGISTER RELOAD\nFOUND    DC    CL1' '                    CHECK-BYTE IF BACKW-PTR FOUND\nHKRBYTE  DC    CL1' '                    SAVE AREA FOR FIRST HKR-BYTE\nCINUM    DC    CL4' '                    SAVE AREA FOR CI-NUMBER\nBADKEY   DC    CL1' '                    CHECKBYTE FOR INVALID KEYS\nGDGNAME  DC    CL44' '                   SAVE AREA FOR GDG BASE NAME\nSNAPID   DC    CL4' '                    SNAP-IDENTIFICATION\nLINE     DC    CL133' '                  LINE USED FOR PRINT-OUTPUT\nAMSCARD  DC    C' DEL '\nAMSDSN   DC    44C' '\n         DC    C' NSCR'\n         DC    26C' '\n         SPACE 4\n*        CONTROL-BLOCK AREA\n         SPACE 1\nACBCAT   ACB   DDNAME=VSAMCAT,AM=VSAM,EXLST=EOD,                       *\n               MACRF=(CNV,KEY,DIR,SEQ,IN),PASSWD=PW\nEOD      EXLST EODAD=Z010\nEOF      EXLST EODAD=Z010\nDOUBLWRK DC    D'0'\nRPL1     DC    CL8'RPLDIR  '             IDENTIFIER FOR RPL\nRPLDIR   RPL   ACB=ACBCAT,AM=VSAM,AREA=CATREC,AREALEN=512,             *\n               OPTCD=(CNV,DIR,GEN),ARG=KEY,KEYLEN=4\nRPLDIRE  DS    0C\n         DS    0D\nRPL2     DC    CL8'RPLSEQ  '             IDENTIFIER FOR RPL\nRPLSEQ   RPL   ACB=ACBCAT,AM=VSAM,AREA=HKRREC,AREALEN=512,             *\n               OPTCD=(KEY,DIR,GEN,NSP,MVE),ARG=KEY,KEYLEN=4\nRPLSEQE  DS    0C\nPRINT    DCB   DSORG=PS,MACRF=PM,DDNAME=SYSPRINT,                      *\n               RECFM=FBM,LRECL=133,BLKSIZE=133\nAMSOUT   DCB   DSORG=PS,MACRF=PM,DDNAME=AMSCARD,                       *\n               RECFM=FB,LRECL=80\n         LTORG\n         END\n//LKED.SYSIN DD *\n    NAME VSAMSCAN(R)\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "WATDSN": {"ttr": 38918, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x00\\x7f\\x00\\x88\\x00\\x7f\\x12\\x00\\x00`\\x00`\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf2\\xf7\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-01-07T00:00:00", "modifydate": "1988-01-07T12:00:00", "lines": 96, "newlines": 96, "modlines": 0, "user": "FILE270"}, "text": "000010 ID DIVISION.\n000020 PROGRAM-ID.  WATDSN.\n000030 AUTHOR.      JEFF SPREHN.\n000040\n000050     EJECT\n000060 ENVIRONMENT DIVISION.\n000070 CONFIGURATION SECTION.\n000080     EJECT\n000090 DATA DIVISION.\n000100\n000110 WORKING-STORAGE SECTION.\n000120\n000121 77  SUB                               PIC S9(4) COMP.\n000122*\n000123*    D S N T A B    P A R A M E T E R S\n000124*\n000125 01  THE-DDNAME                        PIC X(8).\n000126 01  DDNAME-TABLE.\n000127     05  DDNAME-ELEMENT OCCURS 50 TIMES.\n000128         10  FILLER                    PIC X(6).\n000129         10  THE-DSNAME                PIC X(44).\n000130 01  TABLSIZE      VALUE +2500         PIC S9(4) COMP.\n000131 01  DSNSCNT                           PIC S9(4) COMP.\n000132*\n000133*\n000134*\n000135\n000140     EJECT\n001260 LINKAGE SECTION.\n001270\n001280 01  PARM-AREA.\n001290     05  PARM-COUNT                    PIC S9(4) COMP.\n001300     05  PARM-DDNAME                   PIC X(8).\n001330     EJECT\n001340 PROCEDURE DIVISION USING PARM-AREA.\n001350\n001354     MOVE PARM-DDNAME TO THE-DDNAME.\n001355\n001356     CALL 'DSNTAB' USING  THE-DDNAME\n001357                          DDNAME-TABLE\n001358                          TABLSIZE\n001359                          DSNSCNT.\n001360\n001370     IF RETURN-CODE = 4\n001380          DISPLAY '  '\n001381          DISPLAY '   *************************'\n001382          DISPLAY '   *   DDNAME NOT FOUND    *'\n001383          DISPLAY '   *************************'\n001384          DISPLAY '  '\n001385          DISPLAY '  '\n001386          DISPLAY '  '\n001390          STOP RUN.\n001400\n001410     IF RETURN-CODE = 8\n001420          DISPLAY '  '\n001430          DISPLAY '   ******************************************'\n001440          DISPLAY '   *   MORE THAN 50 DATASETS CONCATENATED   *'\n001450          DISPLAY '   *   TO THE GIVEN DDNAME                  *'\n001460          DISPLAY '   ******************************************'\n001461          DISPLAY '  '\n001462          DISPLAY '  '\n001463          STOP RUN.\n001470\n001480     IF RETURN-CODE NOT = 0\n001490          DISPLAY '  '\n001491          DISPLAY '   ***************************************'\n001492          DISPLAY '   *   UNRECOGNIZABLE RETURN CODE FROM   *'\n001493          DISPLAY '   *   DSNTAB (I.E. OTHER THAN 0,4 OR 8) *'\n001494          DISPLAY '   ***************************************'\n001495          DISPLAY '  '\n001496          DISPLAY '  '\n001497          STOP RUN.\n001498\n001500     DISPLAY 'DDNAME: ' THE-DDNAME '  DSNAME: ' THE-DSNAME(1).\n001600\n001700     IF DSNSCNT LESS THAN 2\n001710         DISPLAY '  '\n001711         DISPLAY '  '\n001720         DISPLAY '  '\n001800         STOP RUN.\n001900\n002000     MOVE +2 TO SUB.\n002100\n002200 THE-LOOP.\n002300\n002400     IF SUB GREATER THAN 50\n002500         STOP RUN.\n002600\n002610     IF SUB GREATER THAN DSNSCNT\n002611         DISPLAY '  '\n002612         DISPLAY '  '\n002620         STOP RUN.\n002630\n002640     DISPLAY '                          ' THE-DSNAME(SUB).\n002700     ADD +1 TO SUB.\n002800     GO TO THE-LOOP.\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "WATDSN$": {"ttr": 38921, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x00\\x7f\\x00\\x88\\x00\\x7f\\x12\\x00\\x003\\x003\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf2\\xf7\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-01-07T00:00:00", "modifydate": "1988-01-07T12:00:00", "lines": 51, "newlines": 51, "modlines": 0, "user": "FILE270"}, "text": "1                                                        WATDSN.1\n                                                         06/25/82\n\n\n  CLIST:              WATDSN\n  AUTHOR:             Jeff Sprehn\n  AGENCY:             WDPSC\n  FUNCTION:           Given a  DDNAME, display, in  the appropriate\n                      order, all of  the DSNAMES (if any)  that are\n                      currently allocated to that DDNAME.\n\n  TERMINAL TYPE: 3270 type or dialup\n\n  Syntax -\n  ___________________________________________________________________\n      Command          Operands\n  ___________________________________________________________________\n      WATDSN           ddname\n  ___________________________________________________________________\n\n  Operands -\n    Required -\n      ddname:  DDNAME with which the datasets are allocated to.\n\n  Example:\n\n       To determine the  order of concatenation on  ddname SYSPROC,\n       enter the following:\n\n            WATDSN SYSPROC\n\n\n\n\n1                                                        WATDSN.2\n                                                         06/25/82\n\n\n       The CLIST would return, for example, the following:\n\n            DDNAME:  SYSPROC     DSNAME:  AGNCY999.MY.CLIST\n                                          JC00999.MISC.CLIST\n                                          WDPSC.MASTER.CLIST\n                                          USER.CLIST\n\n   NOTE:\n\n       SYSPROC is the  DDNAME used by your session  which the CLIST\n       libraries  (whose members  may  be  invoked implicitly)  are\n       allocated to.\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "WDPSCXS": {"ttr": 38923, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x00\\x7f\\x00\\x88\\x00\\x7f\\x12\\x00\\x00_\\x00_\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf2\\xf7\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-01-07T00:00:00", "modifydate": "1988-01-07T12:00:00", "lines": 95, "newlines": 95, "modlines": 0, "user": "FILE270"}, "text": "         TITLE 'WDPSCXS - SPF EXIT,LOGOFF MODULE'\n*\n*  V2M2 - MODIFIED 11/9/87 TO USE IBM STACK MACRO (TSOE STACK CHG)\n*\n*  V2M1 - MODIFIED 2/9/87 TO ACCEPT SPFEXEC TYPE ENVIRONMENT\n*\n         EJECT\nWDPSCXS  ENTERR LEVEL=V2M2\n         EJECT\n*\n*              GET CMD PTR AND LENGTH:\n*\n         LR    R11,R1             SAVE PARM PTR\n         L     R10,0(,R1)              R10->PARM AREA              *KK1\n         LH    R9,0(,R10)              R9=PARM LEN                 *KK1\n         LTR   R9,R9              ANY PARM?\n         BZ    EXIT               NO -> GET OUT NOW\n         BCTR  R9,R0               R9-1 FOR EX                     *KK1\n         SPACE\n*\n*    OBTAIN THE COMMAND AREA AND COPY THE COMMAND IN:\n*\nGETMAIN  LA    R0,GETLEN          R0= LENGTH NEEDED\n         O     R0,=X'4E000000'    SUBPOOL=78\n         GETMAIN R,LV=(0)         ASK SYSTEM FOR IT\n         LR    R5,R1              R5 -> LSD AREA\n         USING LSD,R5             TELL ASSEMBLER WE HAVE IT\n         MVI   COMMAND,C' '       BLANK\n         MVC   COMMAND+1(255),COMMAND  SMEAR IT AROUND\n         SPACE\nMCMD     MVC   COMMAND(0),2(R10)  FOR EX                           *KK1\n         EX    R9,MCMD            SAVE THE CMD STRING              *KK1\n         EJECT\n*\n*    HE  WANTS TO ISSUE A CMD SO LETS STACK IT FOR HIM\n*\n         L     R7,540             R7->MY TCB\n         L     R8,132(,R7)        R8->MY MAMA\n         L     R7,112(,R8)        R7->FSA\n         L     R8,8(,R7)          R8->NEXT SAVE AREA\n         CLC   72(8,R8),=CL8'NEWISPF'  IS THIS OUR FRONTEND?\n         BE    GETOLD CPPL        YES WE ARE OK\n         ICM   R8,15,8(R8)        R8->NEXT SA                      V2M1\n         BZ    DEAD                                                V2M1\n         CLC   72(8,R8),=CL8'NEWISPF' ECT AVAIL?                   V2M1\n         BE    GETOLD CPPL        YUP                              V2M1\nDEAD     WTP   'TELL TECH SUPPORT ISPF FRONTEND INACTIVE'\n         LA    R15,20             RC=REAL BAD!\n         B     EXIT               GET OUT NOW\nGETOLD   LA    R8,80(,R8)         R8->NEWISPF SAVED CPPL\n         L     R7,12(,R8)         R7->ECT!\n         LA    R6,ECB             R6 -> ECB        BLOCK.\n*\n*    BUILD THE LSD DESCRIBING THE COMMAND:\n*\n         LA    R4,COMMAND         R4 -> COMMAND\n         ST    R4,LSDADATA        SAVE IT\n         ST    R4,LSDANEXT        \"\n         MVC   LSDRCLEN,=H'256'   RECLEN\n         MVC   LSDTOTLN,=H'256'   TOTAL LEN\n         EJECT\n*\n*    NOW THAT  WE HAVE BUILT IT,LETS PUT IT ON THE STACK\n*\n         STACK PARM=STACKL,UPT=(R8),ECT=(R7),ECB=(R6),              XXXX\n               STORAGE=LSD,MF=(E,IOPL)\n         EJECT\n*\n*\n*    DONE HERE -> RETURN TO SPFPMD MAIN MOD (PMD)\n*\nEXIT     LEAVER\n         EJECT\n*\n*    CONSTANTS AND WORKAREAS\n*\nKVBLOCK  DC    AL1(255)\n         DC    AL1(2)\n         DC    C'XC'\n         DC    F'0'               END FLAG?\n         LTORG\n         SPACE 3\nWORKAREA DSECT\nSAVEAREA DS    18F                SAVEAREA\nCOMSAVE  DS    CL8                COM REF\nPARML    DS    3F                 PARM LIST FOR CKVGET\nIOPL     DS    4F                 IOPL\nECB      DS    F                  ECB\nSTACKL   STACK MF=L               STACK LIST\nWORKLEN  EQU   *-WORKAREA\n         EJECT\nLSD      IKJLSD                   LSD\nCOMMAND  DS    CL256              COMMAND\nGETLEN   EQU   *-LSD\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "WHATDDN": {"ttr": 38926, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x00\\x7f\\x00\\x88\\x00\\x7f\\x12\\x00\\x01\\x03\\x01\\x03\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf2\\xf7\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-01-07T00:00:00", "modifydate": "1988-01-07T12:00:00", "lines": 259, "newlines": 259, "modlines": 0, "user": "FILE270"}, "text": "WHATDDN TITLE '- RETURN DDNAMES WITH DSNAME ALLOCATED IN CLIST VARS'\n***********************************************************************\n*                                                                     *\n* AUTHOR:                                                             *\n*     GORDON SCHILLINGER                                              *\n*     WDPSC, (206) 902-3147                                           *\n*                                                                     *\n*                                                                     *\n* ACTIVITY LOG:                                                       *\n*     VERSION 1 MODIFICATION 0 - AUGUST 31, 1987                      *\n*     VERSION 1 MODIFICATION 1 - NOVEMBEMBER 2, 1987                  *\n*        CORRECTED 0C4 PROBLEM WITH INCORRECT CHECK FOR END OF TIOT   *\n*     VERSION 1 MODIFICATION 2 - NOVEMBEMBER 23, 1987                 *\n*        CORRECTED 0C4 PROBLEM WITH INCORRECT CHECK FOR END OF TIOT   *\n*                                                                     *\n***********************************************************************\n         EJECT\n*  -----------------------------------------------------------------\n*  SYNTAX:\n*      WHATDDN  DSNAME('DSNAME') | ALL |\n*  -----------------------------------------------------------------\n*  OPERANDS -\n*       REQUIRED -\n*           DSNAME('DSNAME') --- 'DSNAME' IS THE DSNAME THAT YOU\n*                                 WISH TO HAVE THE DDNAME(S) WHICH\n*                                 HAVE THE DSNAME ALLOCATED RETURNED\n*       OPTIONAL -\n*           ALL              ---  IF ALL IS SPECIFIED, WHATDDN WILL\n*                                 RETURN ALL OF THE DDNAMES WHICH\n*                                 HAVE THE DSNAME ALLOCATED, IN CLIST\n*                                 VARIABLES &DDNAME1 THRU &DDNAMEN,\n*                                 WHERE N IS A NUMBER FROM ONE TO NINE.\n*                                 (IT IS UNLIKELY THAT THERE WILL BE\n*                                 GREATER THAN NINE DDNAMES WITH DSNAME\n*                                 ALLOCATED; HOWEVER, IF SO, A RETURN\n*                                 CODE WILL REFLECT THIS CONDITION.  )\n*\n*                                 IF ALL IS NOT GIVEN, THEN ONLY THE\n*                                 DDNAME FIRST IN THE CONCATENATION\n*                                 IS RETURNED IN &DDNAME1.\n*\n* RETURN CODES:\n*        |---------|-----------------------------------------------|\n*        | &LASTCC | MEANING                                       |\n*        |---------|-----------------------------------------------|\n*        |    0    | SUCCESSFUL COMPLETION                         |\n*        |---------|-----------------------------------------------|\n*        |    4    | DSNAME NOT ALLOCATED TO ANY DDNAMES           |\n*        |---------|-----------------------------------------------|\n*        |    8    | MORE THAN 9 DDNAMES HAVE ALLOCATED DSNAME     |\n*        |---------|-----------------------------------------------|\n*        |   12    | INVALID SYNTAX OF OPERAND(S)                  |\n*        |---------|-----------------------------------------------|\n         EJECT\nWHATDDN ENTERR LEVEL=V1M2\n         EJECT\n********************************************************************\n*      MAIN PROGRAM LOGIC                                          *\n*           R2  = TIOT PTR                                         *\n*           R5  = CURRENT DSNAME VARIABLE                          *\n*           R6  = PDE VALUE \"ALL\" KEYWORD                          *\n*           R8  = DD ENTRY LENGTH                                  *\n*           R9  = DD ENTRY PTR                                     *\n*           R10 = IKJPARMD PTR                                     *\n********************************************************************\n         LR    R11,R1             SAVE THE PARM POINTER\n         BAL   R14,DOPARSE        PERFORM THE PARSE SERVICE ROUTINE\n         BXLE  R15,R15,PARSEOK    PARSE SUCCESFUL ?\n         LA    R15,12             NO, INVALID SYNTAX; RC(12)\n         BNE   EXIT\nPARSEOK  L     R10,ANS            YES, GET PTR FROM PARSE\n         USING IKJPARMD,R10       ESTABLISH IKJPARMD ADDRESSABILITY\n         TM    DSTRING+6,X'80'    IS DSNAME PRESENT ?\n         BO    FINDD              YES, SEARCH DD ENTRIES\n         LA    R15,12             NO,  INVALID SYNTAX; EXIT RC(12)\n         B     EXIT\nFINDD    L     R1,540             R1-> TCB CURRENTLY RUNNING\n         L     R2,12(,R1)         R2-> TIOT\n         LA    R9,24(,R2)         R9-> FIRST DD IN TIOT\n         LH    R6,ALL             R6 = \"ALL\" KEYWORD POSITIONAL FLAG\n         BAL   R14,INITLIST       BUILD PARMLIST FOR SETVAR\n         MVC   VARNAME,=C'DDNAME' INITILIZE &DSNAME VARIABLE NAME\n         LA    R5,1               INITIALIZE &DSNAME VARIABLE INDEX\nCHKDSN   BAL   R14,CHKALLOC       ROUTINE TO CHECK DATASET ALLOCATION\n         BXH   R15,R15,NEXTDD     IF DSNAME NOT ALLOCATED, GET NEXT DD\n         BAL   R14,SETDDN         PUT DDNAME IN CLIST VARIABLE\n         BXH   R15,R15,SETCOUNT   IF TOO MANY DDNAMES, RC(8)\nCHKALL   CH    R6,=H'1'           \"ALL\" SPECIFIED?   (1ST KEYWD PARM)\n         BE    NEXTDD             YES, PROCESS ANOTHER DD ENTRY\n         LA    R15,0              NO,  EXIT RC(0)\n         B     SETCOUNT           SET DDNCOUNT=1 & EXIT\nNEXTDD   XR    R8,R8              CLEAR REGISTER FOR INDEXING\n         XR    R15,R15            RESET RETURN CODE\n         IC    R8,0(,R9)          R8 = LENGTH OF CURRENT DD ENTRY\n         LA    R9,0(R8,R9)        R9-> NEXT DD ENTRY IN TIOT\n*        CLI   0(,R9),X'00'       END OF TIOT?                          ----V1M0\n*        CLC   36(,R9),=F'0'      END OF TIOT?                          ----V1M1\n         CLC   0(4,R9),=F'0'      END OF TIOT?                          ----V1M2\n         BNE   CHKDSN             NO, CHECK DSNAME FOR ALLOCATION\nSETCOUNT LR    R8,R15             SAVE RETURN CODE\n         BAL   R14,STDDNCNT       SET CLIST VARIABLE &DDNSCNT\n         LTR   R15,R15            ANY VARIABLES SET?\n         BNZ   EXIT               NO,  EXIT RC(4)\n         LR    R15,R8             YES, EXIT PREVIOUS RETURN CODE\nEXIT     LEAVER\n         EJECT\n********************************************************************\n*        PARSE INPUT COMMAND BUFFER                                *\n*             RETURN CODES:                                        *\n*               0 - PARSE SUCCESSFUL                               *\n*               4 - PARSE ERROR ENCOUNTERED                        *\n********************************************************************\nDOPARSE  ST    R14,RETADDR\n         KKPARSE ,                PARSE COMMAND\n         LTR   R15,R15            PARSE GO OK?\n         BZ    EXITPARS           YES, RETURN TO CALLER\n         LA    R15,12             NO,  EXIT RC(12)\n         B     EXITPARS\nEXITPARS L     R14,RETADDR\n         BR    R14\n         EJECT\n********************************************************************\n*        CHECK DDNAME FOR DATASET ALLOCATION                       *\n*             RETURN CODES:                                        *\n*               0 - DATASET ALLOCATED TO CURRENT DDNAME            *\n*               4 - DATASET NOT ALLOCATED TO CURRENT DDNAME        *\n*             WORK REGISTERS = 3,4,7                               *\n********************************************************************\nCHKALLOC ST    R14,RETADDR            SAVE RETURN ADDRESS\n         LA    R15,0                  INITIALIZE RC(0)\n         CLI   4(R9),C' '             DATASET CONCATINATION?\n         BE    CMPDSN                 YES, COMPARE FOR DATASET MATCH\n         MVC   DDNAME(8),4(R9)        RETAIN DDNAME FOR CONCATINATION\nCMPDSN   XR    R7,R7                  CLEAR FOR ICM\n         ICM   R7,7,12(R9)            R9-> JFCB\n         L     R3,DSTRING             R3-> DATASET NAME PASSED\n         LH    R4,DSTRING+4           R4 = DATASET NAME LENGTH\n         BCTR  R4,0                   ADJUST LENGTH FOR EXECUTE\n         EX    R4,COMPARE             DATASET ALLOCATED TO DDNAME?\n         BE    ALLOC                  YES, RC(0)\n         AH    R15,=H'4'              NO,  RC(4)\nALLOC    L     R14,RETADDR            R4-> CALLER\n         BR    R14                    RETURN TO CALLER\nCOMPARE  CLC   0(0,R3),16(R7)\n         EJECT\n********************************************************************\n*        BUILD UPDTLIST (SETVAR PARM LIST)                         *\n*             WORKING REGISTER = 3                                 *\n********************************************************************\nINITLIST ST    R14,RETADDR         SAVE RETURN ADDRESS\n         MVC   UPDTUPT,CPPLUPT     UPT\n         MVC   UPDTECT,CPPLECT     ECT\n         LA    R3,ECB\n         ST    R3,UPDTECB          ECB\n         LA    R3,UPLIST\n         ST    R3,UPDTUPL          UPLIST\n         L     R14,RETADDR\n         BR    14\n         EJECT\n********************************************************************\n*        BUILD UPDATE PARM LIST FOR &DDNAME# AND LINK SETVAR       *\n*             RETURN CODES:                                        *\n*               0 - &DDNAME# VARIABLE SET                          *\n*               4 - VARIABLE NOT SET; LIMIT EXCEEDED               *\n*             WORKING REGISTERS = 3,4                              *\n********************************************************************\nSETDDN   ST    R14,RETADDR        SAVE RETURN ADDRESS\n         LA    R15,0              INITIALIZE RC(0)\n         CH    R5,=H'9'           DO WE HAVE MORE THAN WE CAN HANDLE?\n         BH    TOOMANY\n         LA    R3,VARNAME         R3-> VARIABLE NAME FOR DDNAME\n         ST    R3,LOCPTR\n         IC    R4,INDXTABL(R5)    R4 = INDEX CHARACTER\n         STC   R4,6(,R3)          APPEND INDEX TO &DDNAME\n         MVC   LOCLEN,=F'7'       LENGTH OF VARIABLE NAME\n         LA    R3,DDNAME          R3-> DDNAME\n         ST    R3,VALPTR\n         MVC   VALLEN,=F'8'       LENGTH OF DDNAME\n         LA    R1,UPDTLIST        R1 ==> SETVAR PARM LIST\n         LINK  EP=SETVAR          SET VARIABLE\nBMPINDX  LA    R5,1(,R5)          R5 = INDEX FOR NEXT &DSNAME\n         B     SETDDRET\nTOOMANY  LA    R15,4              RC(4)\nSETDDRET L     R14,RETADDR\n         BR    14                 RETURN TO CALLER\n         EJECT\n********************************************************************\n*        BUILD UPDATE PARM LIST FOR &DDNCOUNT AND LINK SETVAR      *\n*             RETURN CODES:                                        *\n*               0 - &DDNCOUNT SET TO NUMBER OF &DDNAME VARIABLES   *\n*               4 - NO VARIABLES SET; &DDNCOUNT = 0                *\n********************************************************************\nSTDDNCNT ST    R14,RETADDR        SAVE RETURN ADDRESS\n         BCTR  R5,0               R5 = NUMBER OF VARIABLES SET\n         IC    R4,INDXTABL(R5)    R4 = NUMBER OF VARIABLES (CHAR)\n         STC   R4,DDNCOUNT\n         LA    R9,=C'DDNCOUNT'    R9-> VARIABLE NAME\n         ST    R9,LOCPTR\n         MVC   LOCLEN,=F'8'       LENGTH OF VARIABLE NAME\n         LA    R9,DDNCOUNT        R9-> VARIABLE DATA (# DDNAMES)\n         ST    R9,VALPTR\n         MVC   VALLEN,=F'1'       LENGTH OF DATA FIELD\n         LA    R1,UPDTLIST        R1-> SETVAR PARM LIST\n         LINK  EP=SETVAR          SET THE VARIABLE\n         BXH   R5,R5,CNTRET       SET ANY &DDNAME VARIABLES?\n         LA    R15,4              NO,  RC(4)\nCNTRET   L     R14,RETADDR\n         BR    14                 RETURN TO CALLER\n         EJECT\n********************************************************************\n*                    D A T A    A R E A S                          *\n********************************************************************\nLISTKALL CALL  ,(0,0,0,0),VL,MF=L\nINDXTABL DC    CL10'0123456789'\n         LTORG\n         EJECT\n********************************************************************\n*        D Y N A M I C   W O R K   A R E A                         *\n********************************************************************\nWORKAREA DSECT\nSAVEAREA DS    18F\nPPLA     DS    7F\nANS      DS    F\nECB      DS    F\n*\nVARNAME  DS    CL7\nDDNAME   DS    CL8\nDDNCOUNT DS    C\n*UNPKCNT  DS    CL3\n*CVDOPRND DS    D\nRETADDR  DS    F\n*\nUPDTLIST DS    0F\nUPDTUPT  DS    F\nUPDTECT  DS    F\nUPDTECB  DS    F\nUPDTUPL  DS    F\n*\nUPLIST   DS    0F\nLOCPTR   DS    AL4\nLOCLEN   DS    FL4\nVALPTR   DS    AL4\nVALLEN   DS    FL4\nWORKLEN  EQU   *-WORKAREA\nWHATDDN CSECT\n         EJECT\n********************************************************************\n*                   P A R S E   M A C R O S                        *\n********************************************************************\n*\nPCL      IKJPARM\nDSNDWD   IKJKEYWD\n         IKJNAME 'DSNAME',SUBFLD=DSNSUB,ALIAS=('DATASET')\nALL      IKJKEYWD\n         IKJNAME 'ALL'\nDSNSUB   IKJSUBF\nDSTRING  IKJPOSIT DSNAME,USID\n         IKJENDP\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "WHATDSN": {"ttr": 39173, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x00\\x7f\\x00\\x88\\x00\\x7f\\x12\\x00\\x01\\x8e\\x01\\x8e\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf2\\xf7\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-01-07T00:00:00", "modifydate": "1988-01-07T12:00:00", "lines": 398, "newlines": 398, "modlines": 0, "user": "FILE270"}, "text": "*\n* WW     WW  HH   HH      A     TTTTTTTT  DDDDD      SSSS    NN     NN\n* WW     WW  HH   HH     AAA    TTTTTTTT  DD  DD    S    S   NNN    NN\n* WW     WW  HH   HH    AA AA      TT     DD   DD  S         NNNN   NN\n* WW     WW  HHHHHHH    AA AA      TT     DD    DD  S        NN NN  NN\n* WW  W  WW  HHHHHHH   AAAAAAA     TT     DD    DD   SSSS    NN  NN NN\n* WWWW WWWW  HH   HH   AA   AA     TT     DD   DD        S   NN   NNNN\n* WWW   WWW  HH   HH  AA     AA    TT     DD  DD    S     S  NN     NN\n* WW     WW  HH   HH  AA     AA    TT     DDDDD      SSSS    NN      N\n*\n*\n*\n*\n*\n********************************************************************\n*                                                                  *\n*  CHANGE ACTIVITY:                                                *\n*                                                                  *\n*  V1R1M1-                                               01/14/88  *\n*      GORDON SCHILLINGER, WDPSC                                   *\n*      MODIFIED CODE TO BE RE-ENTRANT                              *\n*                                                                  *\n*                                                                  *\n********************************************************************\n         EJECT\n*  -----------------------------------------------------------------\n*  COMMAND     OPERANDS\n*  -----------------------------------------------------------------\n*                                --  --\n*  WHATDSN     DDNAME('DDNAME') | ALL |\n*                                --  --\n*  -----------------------------------------------------------------\n*\n*\n*  OPERANDS -\n*\n*       REQUIRED -\n*\n*           DDNAME('DDNAME') --- 'DDNAME' IS THE DDNAME THAT YOU\n*                                 WISH TO HAVE THE DSNAME(S) THAT\n*                                 IS/ARE ASSOCIATED WITH THAT DDNAME\n*\n*       OPTIONAL -\n*\n*           ALL              ---  IF ALL IS GIVEN, THIS COMMAND WILL\n*                                 RETURN ALL OF THE DSNAMES WHICH\n*                                 MAY BE CONCATENATED TO THE DDNAME\n*                                 IN CLIST VARIABLES &DSNAME1 THRU\n*                                 &DSNAME9 AND &DSNSCNT WILL\n*                                 CONTAIN THE TOTAL NUMBER OF\n*                                 DSNAMES ASSOCIATED WITH THE DDNAME\n*                                 (&DSNSCNT COULD POTENTIALLY CONTAIN\n*                                 A VALUE GREATER THAN 9 HOWEVER)\n*\n*                                 IF ALL IS NOT GIVEN, THEN ONLY\n*                                 THE DSNAME THAT IS CONCATENATED\n*                                 \"AT THE TOP OF THE STACK\" IS GIVEN.\n*                                 IT IS RETURNED IN &DSNAME.\n*\n*\n*        THIS COMMAND WILL ALSO RETURN A VALUE IN REGISTER 15\n*        (THE RETURN CODE) REPRESENTING THE SUCCESS OR NONSUCCESS\n*        OF THIS COMMAND.\n*\n*        |---------|-----------------------------------------------|\n*        | &LASTCC | MEANING                                       |\n*        |---------|-----------------------------------------------|\n*        |    0    | SUCCESSFUL COMPLETION                         |\n*        |---------|-----------------------------------------------|\n*        |    8    | DDNAME NOT ALLOCATED                          |\n*        |---------|-----------------------------------------------|\n*        |   12    | MORE THAN 50 DATASETS CONCATENATED TO DDNAME  |\n*        |---------|-----------------------------------------------|\n*        |   96    | INVALID SYNTAX OF OPERAND(S)                  |\n*        |---------|-----------------------------------------------|\n         EJECT\nWHATDSN ENTERR LEVEL=V1R1M1\n         EJECT\n********************************************************************\n*                                                                  *\n*      M A I N   L I N E   L O G I C   F O R   W H A T D S N       *\n*                                                                  *\n********************************************************************\n*\n         LR    R11,R1              SAVE THE PARM POINTER\n         MVC   RETRNCD(4),=F'0'    SET RETRNCD = 0\n         MVC   PROCESSW,=C'YES'    MOVE 'YES' TO PROCESSW\n         BAL   R14,DOPARSE         PERFORM THE PARSE SERVICE ROUTINE\n         CLC   PROCESSW,=C'YES'    WAS PARSE SUCCESFUL ?\n         BNE   SHUTDOWN            IF NOT, BRANCH TO SHUTDOWN\n         BAL   R14,LOADFLDS        PERFORM ROUTINE TO LOAD THE\n*                                     PARSED FIELDS INTO\n*                                     DDNAME AND ALLOFEM\n         CLC   PROCESSW,=C'YES'    IS ALL OK ?\n         BNE   SHUTDOWN            IF NOT, BRANCH TO SHUTDOWN\n         BAL   R14,GETDSNS         PERFORM ROUTINE TO LOCATE THE\n*                                     DSNAME(S) ASSOCIATED WITH\n*                                     THE DDNAME\n         CLC   PROCESSW,=C'YES'    IS ALL STILL OK ?\n         BNE   SHUTDOWN            IF NOT, BRANCH TO SHUTDOWN\n         BAL   R14,INITLIST        BUILD PARMLIST FOR IKJUPDT\n         BAL   R14,SETDSN          SET CLIST VARIABLE &DSNAME\n         CLC   ALLOFEM,=C'YES'     HAS ALL DSNAMES BEEN REQUESTED ?\n         BNE   SHUTDOWN            IF NOT, BRANCH TO SHUTDOWN\n         BAL   R14,SETEMALL        SET CLIST VARIABLES &DSNAME1\n*                                     THRU &DSNAME9\n         BAL   R14,STDSNCNT        SET CLIST VARIABLE &DSNSCNT\n         B     SHUTDOWN            BRANCH TO SHUTDOWN\n         EJECT\n********************************************************************\n*                                                                  *\n*        P A R S E   I N P U T   C O M M A N D   B U F F E R       *\n*                                                                  *\n********************************************************************\n*\nDOPARSE  ST    R14,SAVEIT1\n         KKPARSE\n         LTR   R15,R15              RC = 0 ? (I.E PARSE GO OK ?)\n         BNZ   PARSERR              IF NOT, BRANCH TO PARSERR\n         L     R10,ANS\n         USING IKJPARMD,R10\n         B     EXITPARS\nPARSERR  MVC   PROCESSW,=C'NO '     MOVE 'NO ' TO PROCESSW\n         MVC   RETRNCD(4),=F'96'    SET RETRNCD = 96\nEXITPARS L     R14,SAVEIT1\n         BR    14\n         EJECT\n********************************************************************\n*                                                                  *\n*        THIS ROUTINE PROCESSES THE PARSED FIELDS AND THEN         *\n*        LOADS THE DATA FIELDS DDNAME AND ALLOFEM                  *\n*                                                                  *\n*        DDNAME WILL CONTAIN THE DDNAME ENTERED BY THE USER IN     *\n*        THE DDNAME KEYWORD                                        *\n*                                                                  *\n*        ALLOFEM WILL CONTAIN 'YES' IF THE USER ENTERED ALL        *\n*        AS A PARAMETER OF THE COMMAND ELSE ALLOFEM WILL           *\n*        CONTAIN 'NO '                                             *\n*                                                                  *\n********************************************************************\n*\nLOADFLDS ST    R14,SAVEIT2\n         TM    DSTRING+6,X'80'         IS DDNAME PRESENT ?\n         BNO   BADDNAME                IF NOT, BRANCH TO BADDNAME\n         MVC   DDNAME,=CL8' '          MOVE SPACES TO DDNAME\n         LA    R6,DDNAME               R6 ==> ADDR OF DATA FIELD DDNAME\n         L     R8,DSTRING              R8 ==> ADDRESS OF THE DDNAME\n         LH    R7,DSTRING+4            R7 ==> LENGTH OF THE DDNAME\n         C     R7,=F'8'\n         BH    BADDNAME\n         S     R7,=F'1'                SUBTRACT 1 FOR EX\n         SPACE 1\nMOVEDDN  MVC   0(0,R6),0(R8)           MOVE THE DDNAME TO DDNAME\n         EX    R7,MOVEDDN\n         SPACE 1\n         CLC   ALL,=XL2'0000'          WAS ALL SPECIFIED ?\n         BE    NOPEALL                 IF NOT, BRANCH TO NOPEALL\n         MVC   ALLOFEM,=CL3'YES'       MOVE 'YES' TO ALLOFEM\n         B     EXITLOAD                BRANCH TO EXITLOAD\nNOPEALL  MVC   ALLOFEM,=CL3'NO '       MOVE 'NO ' TO ALLOFEM\n         B     EXITLOAD                BRANCH TO EXITLOAD\nBADDNAME MVC   PROCESSW,=C'NO '        MOVE 'NO ' TO PROCESSW\n         MVC   RETRNCD(4),=F'96'       SET RETRNCD = 96\nEXITLOAD L     R14,SAVEIT2\n         BR    14\n         EJECT\n*\n********************************************************************\n*                                                                  *\n*        THIS ROUTINE IS RESPONSIBLE FOR DETERMINING WHETHER THE   *\n*        DDNAME PASSED TO IT IS ALLOCATED.  IF IT IS ALLOCATED,    *\n*        THEN THIS ROUTINE PASSES BACK ALL OF THE ASSOCIATED       *\n*        DSNAMES (AND THEIR LENGTHS)                               *\n*                                                                  *\n*        BEFORE PERFORMING THIS ROUTINE, MOVE THE DDNAME TO        *\n*        DDNAME                                                    *\n*                                                                  *\n*        IF THE DDNAME IS ALLOCATED AND THERE ARE NO MORE THAN 50  *\n*        DATASETS CONCATENATED TO THE DDNAME, THEN THIS ROUTINE    *\n*        LOADS THE TABLE DSNSTABL WITH ALL OF THE DSNAMES WHICH    *\n*        ARE ASSOCIATED WITH THE DDNAME.  THE NUMBER OF SIGNIFICANT*\n*        ENTRIES IN THAT TABLE IS IN #OFDSNS (EACH ENTRY IN THE    *\n*        TABLE IS 50 BYTES LONG.  THE LENGTH OF THE DSNAME IS IN   *\n*        BYTES 5-6 AND THE DSNAME IS IN BYTES 7-50)                *\n*                                                                  *\n*        IF THE DDNAME IS NOT ALLOCATED, THEN THIS ROUTINE DOES    *\n*           THE FOLLOWING:                                         *\n*                                                                  *\n*                .  MOVES 'NO ' TO PROCESSW                        *\n*                .  MOVES 8 TO RETRNCD                             *\n*                                                                  *\n*        IF THERE ARE MORE THAN 50 DATASETS CONCATENATED TO THE    *\n*           DDNAME, THEN THIS ROUTINE DOES THE FOLLOWING:          *\n*                                                                  *\n*                .  MOVES 'NO ' TO PROCESSW                        *\n*                .  MOVES 12 TO RETRNCD                            *\n*                                                                  *\n********************************************************************\n*\nGETDSNS  ST    R14,SAVEIT3             SAVE REG 14 IN SAVEIT3\n         CALL  DSNTAB,(DDNAME,DSNSTABL,TABLSIZE,#OFDSNS),VL,           X\n               MF=(E,LISTKALL)\n         C     R15,=F'4'\n         BE    NOTALLOC\n         C     R15,=F'8'\n         BE    TOOMANY\n         B     EXITDSNS\nNOTALLOC MVC   PROCESSW,=CL3'NO '      MOVE 'NO ' TO PROCESSW\n         MVC   RETRNCD(4),=F'8'        SET RETRNCD = 08\n         B     EXITDSNS\nTOOMANY  MVC   PROCESSW,=CL3'NO '      MOVE 'NO ' TO PROCESSW\n         MVC   RETRNCD(4),=F'12'       SET RETRNCD = 12\nEXITDSNS L     R14,SAVEIT3\n         BR    R14\n         EJECT\n********************************************************************\n*                                                                  *\n*        BUILD UPDTLIST (IKJUPDT PARM LIST)                        *\n*                                                                  *\n********************************************************************\n*\nINITLIST ST    R14,SAVEIT4\n         MVC   UPDTUPT,CPPLUPT          UPT\n         MVC   UPDTECT,CPPLECT          ECT\n         LA    R9,ECB\n         ST    R9,UPDTECB               ECB\n         LA    R8,UPLIST\n         ST    R8,UPDTUPL               UPLIST\n         L     R14,SAVEIT4\n         BR    14\n         EJECT\n********************************************************************\n*                                                                  *\n*        BUILD UPDATE PARM LIST FOR &DSNAME AND CALL IKJUPDT       *\n*                                                                  *\n********************************************************************\n*\nSETDSN   ST    R14,SAVEIT5\n         LA    R9,=C'DSNAME'       R9 ==> ADDRESS OF VAR NAME\n         ST    R9,LOCPTR           STORE ADDR OF VAR NAME IN LOCPTR\n         MVC   LOCLEN,=F'6'        LOCLEN = LENGTH OF VAR NAME\n         LA    R5,DSNSTABL+6       R5 ==> ADDRESS OF VARIABLE\n         ST    R5,VALPTR           STORE ADDRESS OF VARIABLE IN VALPTR\n         MVC   DSNLEN(2),DSNSTABL+4\n         LH    R6,DSNLEN\n         ST    R6,VALLEN           VALLEN = LENGTH OF DATA FIELD\n         LA    R1,UPDTLIST         R1 ==> IKJUPDT PARM LIST\n         CALL  IKJUPDT             DO THE UPDATE\n         L     R14,SAVEIT5\n         BR    14\n         EJECT\n********************************************************************\n*                                                                  *\n*        BUILD UPDATE PARM LIST FOR &DSNAME1 THRU &DSNAME9         *\n*                                                                  *\n********************************************************************\n*\nSETEMALL ST    R14,SAVEIT6\n         LA    R9,NAMSTABL\n         LA    R5,DSNSTABL+6\n         LH    R7,#OFDSNS         R7==> NUMBER OF SIGNIFICANT DSNAMES\n         LA    R6,0\nLOOP     A     R6,=F'1'\n         C     R6,=F'9'\n         BH    EXITSETM\n         CR    R6,R7\n         BH    EXITSETM\n         ST    R9,LOCPTR           STORE ADDR OF VAR NAME IN LOCPTR\n         MVC   LOCLEN,=F'7'        LOCLEN = LENGTH OF VAR NAME\n         ST    R5,VALPTR           STORE ADDRESS OF VARIABLE IN VALPTR\n         LR    R8,R5\n         S     R8,=F'2'\n         MVC   VALLEN,=F'0'\n         MVC   VALLEN+2(2),0(R8)\n         LA    R1,UPDTLIST         R1 ==> IKJUPDT PARM LIST\n         CALL  IKJUPDT             DO THE UPDATE\n         A     R9,=F'7'\n         A     R5,=F'50'\n         B     LOOP\nEXITSETM L     R14,SAVEIT6\n         BR    14\n         EJECT\n********************************************************************\n*                                                                  *\n*        BUILD UPDATE PARM LIST FOR &DSNSCNT AND CALL IKJUPDT      *\n*                                                                  *\n********************************************************************\n*\nSTDSNCNT ST    R14,SAVEIT7\n         LH    R5,#OFDSNS\n         CVD   R5,CVDOPRND\n         UNPK  UNPKCNT(3),CVDOPRND+6(2)\n         MVC   DSNSCNT(2),UNPKCNT+1\n         OI    DSNSCNT+1,X'F0'\n         LA    R9,=C'DSNSCNT'      R9 ==> ADDRESS OF VAR NAME\n         ST    R9,LOCPTR           STORE ADDR OF VAR NAME IN LOCPTR\n         MVC   LOCLEN,=F'7'        LOCLEN = LENGTH OF VAR NAME\n         LA    R5,DSNSCNT          R5 ==> ADDRESS OF VARIABLE\n         ST    R5,VALPTR           STORE ADDRESS OF VARIABLE IN VALPTR\n         MVC   VALLEN,=F'2'        VALLEN = LENGTH OF DATA FIELD\n         LA    R1,UPDTLIST         R1 ==> IKJUPDT PARM LIST\n         CALL  IKJUPDT             DO THE UPDATE\n         L     R14,SAVEIT7\n         BR    14\n         EJECT\n********************************************************************\n*                                                                  *\n*        E N D   O F   J O B   R O U T I N E                       *\n*                                                                  *\n********************************************************************\n*\nSHUTDOWN L    R15,RETRNCD\n         LEAVER\n         EJECT\n         SPACE 3\n********************************************************************\n*                                                                  *\n*                    D A T A    A R E A S                          *\n*                                                                  *\n********************************************************************\n*\nTABLSIZE DC    H'2500'\nNAMSTABL DS    0CL63\n         DC    CL7'DSNAME1'\n         DC    CL7'DSNAME2'\n         DC    CL7'DSNAME3'\n         DC    CL7'DSNAME4'\n         DC    CL7'DSNAME5'\n         DC    CL7'DSNAME6'\n         DC    CL7'DSNAME7'\n         DC    CL7'DSNAME8'\n         DC    CL7'DSNAME9'\n         LTORG\n         EJECT\n         SPACE 3\n********************************************************************\n*                                                                  *\n*        D Y N A M I C   W O R K   A R E A                         *\n*                                                                  *\n********************************************************************\n*\nWORKAREA DSECT\nSAVEAREA DS    18F\nPPLA     DS    7F\nANS      DS    F\nECB      DS    F\nDDNAME   DS    CL8\nDSNSCNT  DS    CL2\nPROCESSW DS    CL3\n         DS    0D\nALLOFEM  DS    CL3                                                      *V1R1M1*\nCVDOPRND DS    D\nSAVEIT1  DS    F\nSAVEIT2  DS    F\nSAVEIT3  DS    F\nSAVEIT4  DS    F\nSAVEIT5  DS    F\nSAVEIT6  DS    F\nSAVEIT7  DS    F\n#OFDSNS  DS    H\nDSNSTABL DS    50CL50\nRETRNCD  DS    F\nDSNLEN   DS    H\nUNPKCNT  DS    CL3\n*\nUPDTLIST DS    0F\nUPDTUPT  DS    F\nUPDTECT  DS    F\nUPDTECB  DS    F\nUPDTUPL  DS    F\n*\nUPLIST   DS    0F\nLOCPTR   DS    AL4\nLOCLEN   DS    FL4\nVALPTR   DS    AL4\nVALLEN   DS    FL4\n*\nACCTVAL  DS    CL9\n*\nLISTKALL CALL  ,(0,0,0,0),VL,MF=L                                       *V1R1M1*\nWORKLEN  EQU   *-WORKAREA\nWHATDSN CSECT\n         EJECT\n********************************************************************\n*                                                                  *\n*                   P A R S E   M A C R O S                        *\n*                                                                  *\n********************************************************************\n*\nPCL      IKJPARM\nFILE     IKJKEYWD\n         IKJNAME 'FILE',SUBFLD=DDNAM,ALIAS=('DDNAME')\nALL      IKJKEYWD\n         IKJNAME 'ALL'\nDDNAM    IKJSUBF\nDSTRING  IKJPOSIT DSNAME\n         IKJENDP\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "WHATDSN$": {"ttr": 39425, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x00\\x7f\\x00\\x88\\x00\\x7f\\x12\\x00\\x00O\\x00O\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf2\\xf7\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-01-07T00:00:00", "modifydate": "1988-01-07T12:00:00", "lines": 79, "newlines": 79, "modlines": 0, "user": "FILE270"}, "text": "1                                                        WHATDSN.1\n                                                         01/09/84\n\n\n  COMMAND NAME:       WHATDSN\n  AUTHOR:             Jeff Sprehn\n  AGENCY:             WDPSC\n  FUNCTION:           The WHATDSN  command is  intended for  use in\n                      command procedures.  This  command returns to\n                      the  CLIST the  DSNAME(s)  of the  dataset(s)\n                      which is/are allocated to the DDNAME given.\n\n  This command is used to pass back to the CLIST:\n\n       .    Only the DSNAME of the dataset  which is \"at the top of\n            the  stack\" (if  several datasets  are concatenated  to\n            that DDNAME.\n  OR\n       .    The DSNAME of each and every dataset (up to nine) which\n            are allocated to the DDNAME.\n\n  Syntax -\n  _________________________________________________________________\n       Command        Operand\n  -----------------------------------------------------------------\n       WHATDSN        DDNAME('ddname')  ALL\n  -----------------------------------------------------------------\n\n  Operands -\n\n       Required -\n\n            DDNAME('ddname)     'ddname'  is the  DDNAME for  which\n                                you wish to know the data set name.\n\n                                FILE is an alias for DDNAME.\n\n\n\n\n1                                                        WHATDSN.2\n                                                         01/09/84\n\n\n\n       Optional -\n\n            ALL                 If ALL is given,  this command will\n                                return all of the DSNAMEs which may\n                                be  concatenated to  the DDNAME  in\n                                CLIST  variables  &DSNAME1  through\n                                DSNAME9  and DSNSCNT  will  contain\n                                the   total   number   of   DSNAMEs\n                                associated    with   the    DDNAME.\n                                (&DSNSCNT  may   contain  a   value\n                                greater than nine.)\n\n                                If ALL is NOT  given, then only the\n                                DSNAME that is concatenated \"at the\n                                top of the stack\"  is given.  It is\n                                returned in &DSNAME.\n\n       This command will also return a return code representing the\n       success or nonsuccess of this command.\n\n     +-----------+------------------------------------------------+\n     |  &LASTCC  | Meaning                                        |\n     +-----------+------------------------------------------------+\n     |     0     | Successful completion                          |\n     +-----------+------------------------------------------------+\n     |     8     | DDNAME not allocated                           |\n     +-----------+------------------------------------------------+\n     |    12     | More than 50 datasets concatenated to DDNAME   |\n     +-----------+------------------------------------------------+\n     |    96     | Invalid syntax of operand(s)                   |\n     +-----------+------------------------------------------------+\n\nNOTE:  WHATDSN is now re-entrant\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "WTOPARM": {"ttr": 39428, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x00\\x7f\\x00\\x88\\x00\\x7f\\x12\\x00\\x004\\x004\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf2\\xf7\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-01-07T00:00:00", "modifydate": "1988-01-07T12:00:00", "lines": 52, "newlines": 52, "modlines": 0, "user": "FILE270"}, "text": "*   PROGRAM WHICH DOES A WRITE-TO-OPERATOR FROM DATA IN PARM FIELD\n*   KEITH NEWSOM, WDPSC, 2-20-86\n*\nWTOPARM  CSECT\n         USING *,R15\n         B     GO\n         DC    X'08',CL8'WTOPARM'\nGO       STM   14,12,12(13)\n         LR    12,15\n         USING WTOPARM,R12\n         SPACE 2\n         L     R2,0(R1)        R2 <-- ADDRESS OF PARM FIELD\n         LH    R3,0(R2)        R3 <-- LENGTH OF PARM FIELD\n         LTR   R3,R3           TEST FOR ZERO LENGTH\n         BZ    RETURN            BRANCH IF ZERO\n         SPACE 2\n         BCTR  R3,0            DECREMENT MESSAGE LENGTH\n         EX    R3,MOVE\n         WTO   MF=(E,WTOMSG)\n         SPACE 2\nRETURN   LM    R14,R12,12(R13)  RETURN\n         MVI   12(R13),X'FF'\n         SR    R15,R15\n         BR    R14\n         SPACE 2\nMOVE     MVC   MESSAGE(1),2(R2)\n         EJECT\nWTOMSG   DS    0F\n         DC    Y(LWTOMSG)\n         DC    B'1000000000000000'   MCS FLAGS\nMESSAGE  DC    CL100' '\nLWTOMSG  EQU   *-WTOMSG\n         DC    B'0000000000000000'   DESCRIPTOR CODES\n         DC    B'1100000000000000'   ROUTING CODES\n         SPACE 2\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "WTOPARM$": {"ttr": 39430, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x00\\x7f\\x00\\x88\\x00\\x7f\\x12\\x00\\x00\\x16\\x00\\x16\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf2\\xf7\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-01-07T00:00:00", "modifydate": "1988-01-07T12:00:00", "lines": 22, "newlines": 22, "modlines": 0, "user": "FILE270"}, "text": "1 10.345                                                          10.345\n0  WTOPARM                                                     WTOPARM\n\n     Source is in         ADABAS.LOCAL.SOURCE(WTOPARM)\n     Load Module is in    WDPSC.PROGLIB(WTOPARM)\n\n  FUNCTION:\n    This program is intended for use by internal support staff at\n    WDPSC.  Its purpose is to send a message from your job to the\n    operator. It simply sends the parm field by a WTO macro.\n\n\n  SAMPLE JCL:\n\n//*\n//WTO1  EXEC PGM=WTOPARM,PARM='THANK YOU ---- TECH SERVICES...',\n// COND=(8,EQ,WTOR)\n//STEPLIB DD DSN=WDPSC.PROGLIB,DISP=SHR\n//*\n//WTO2  EXEC PGM=WTOPARM,PARM='PLEASE START G INITS - TECH SERVICES',\n// COND=(0,EQ,WTOR)\n//STEPLIB DD DSN=WDPSC.PROGLIB,DISP=SHR\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "WTORCON$": {"ttr": 39432, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x00\\x00\\x00\\x00\\x88\\x00\\x7f\\x00\\x88\\x00\\x7f\\x12\\x00\\x00'\\x00'\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf2\\xf7\\xf0@@@\"", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-01-07T00:00:00", "modifydate": "1988-01-07T12:00:00", "lines": 39, "newlines": 39, "modlines": 0, "user": "FILE270"}, "text": "1 10.000\n-                                                         WTORCOND\n\n     Source is in         LL00150.MISC.DATA(WTORCOND)\n     Load Module is in    WDPSC.PROGLIB(WTORCOND)\n\n  FUNCTION:\n    This program is intended for use by internal support staff at\n    WDPSC.  Its purpose is to ask a question about the environment\n    which the operations staff can answer with a Y or N.  Based on that\n    answer a jobstep which performs certain functions can be executed\n    or skipped.\n\n  HOW TO USE:\n  - Create a jobstep which executes WTORCOND.\n  - Place the question (up to 38 characters) in its PARM field.\n    The program will supply the phrase 'REPLY Y OR N' and place the\n    supplied question in a WTOR after it.\n  - The operator's reply is analyzed and a condition code is set:\n      0 - reply was Y   8 - reply was N    15 - parm length more than 38\n    If the reply is something other than Y or N the WTOR is reissued.\n  - The condition code can then be tested in a succeeding jobstep.\n\n\n\n  SAMPLE JCL:\n\n //*\n //*  ASK THE OPERATOR A QUESTION ABOUT THE ENVIRONMENT:\n //*      \"REPLY Y OR N.  SHOULD WEEKLY LOGREC BE SUBMITTED?\"\n //*\n //WTOR  EXEC PGM=WTORCOND,PARM='SHOULD WEEKLY LOGREC BE SUBMITTED?'\n //STEPLIB DD DSN=WDPSC.PROGLIB,DISP=SHR\n //*\n //* TEST THE CONDITION CODE SET IN THE PREVIOUS STEP AND ACT ON IT.\n //*\n //TESTER EXEC FTL,COND=(0,NE,WTOR)\n //IN01 DD ...\n //OUT01 DD ......\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "WTORCOND": {"ttr": 39434, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x00\\x7f\\x00\\x88\\x00\\x7f\\x12\\x00\\x00B\\x00B\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf2\\xf7\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-01-07T00:00:00", "modifydate": "1988-01-07T12:00:00", "lines": 66, "newlines": 66, "modlines": 0, "user": "FILE270"}, "text": "//WTO00150 JOB (2100,56-D),'LLUEB 0679 T',CLASS=H,MSGCLASS=T\n//JOBCAT DD DSN=SYS1.SOFTCAT,DISP=SHR\n//       DD DSN=SYS1.USERCAT1,DISP=SHR\n//A  EXEC ASMFCL,LIBRARY='WDPSC.PROGLIB',REGION=1000K,\n//      LIB3='SYS1.AMODGEN',LIB2='WDPSC.MACLIB',\n//      OPTION2='LOAD,MAP'\n//*\n//*               LL00150.MISC.DATA(WTORCOND)\n//*                  WTOR SETS RETURN CODE\n//*\n//ASM.SYSIN DD *\nWTORCOND ENTERNR\n*\n*   THIS PROGRAM TAKES UP TO 38 CHARACTERS FROM A PARM FIELD AND\n*   PLACES THEM IN A WTOR AFTER THE PHRASE 'REPLY Y OR N' TO MAKE\n*   A QUESTION THAT OPERATIONS MUST REPLY TO.\n*\n*   THE REPLY GIVEN IS ANALYZED AND A RETURN CODE IS SET BASED ON IT.\n*    0 - REPLY WAS Y   8 - REPLY WAS N    15 - PARAMETER SIZE ERROR\n*   THE RETURN CODE CAN THEN BE TESTED IN A SUCCEEDING JOBSTEP.\n*\n         SPACE 3\n*   FIND THE PARAMETER AND CHECK IT FOR LENGTH\n         SLR   R3,R3\n         L     R2,0(0,R1)              POINT TO SUPPLIED PARM FIELD\n         ICM   R3,3,0(R2)              LENGTH OF PARM SUPPLIED\n         BZ    BADPARM                  NO PARM\n         CH    R3,=H'38'\n         BH    BADPARM\n         SPACE 3\n*   SET UP AND ISSUE THE WTOR\n         BCTR  R3,0                    SET UP FOR EX USAGE\n         EX    R3,MVCWTOR\nWTOR     WTOR  'REPLY Y OR N.                                        ',X\n               REPLY,1,ECB1,ROUTCDE=(1,2)\n         WAIT  ECB=ECB1 WAIT FOR THE REPLY\n         OI    REPLY,X'40'             MAKE REPLY UPPERCASE\n         CLI   REPLY,C'Y'              YES\n         BE    ZERORC\n         CLI   REPLY,C'N'              NO\n         BE    EIGHTRC\n         SLR   R4,R4                   CLEAR OUT THE ECB\n         ST    R4,ECB1\n         B     WTOR                    BAD REPLY  TRY AGAIN!\n         SPACE 3\n*   RETURN WITH PROPER RETURN CODE SET\nBADPARM  LA    R15,15\n         B     EXIT\nEIGHTRC  LA    R15,8\n         B     EXIT\nZERORC   SLR   R15,R15\nEXIT     LEAVENR\n         EJECT\nMVCWTOR  MVC   WTOR+31(0),2(R2)    MOVE PARM TO WTOR\nREPLY    DC    C' '\nECB1     DC    F'0'\n         LTORG\n         DC    F'0'\n         SPACE 3\n         DC    C'WTORCOND  '\n         DC    C'L. LUEBCKE   4/28/83   COND CODE SET BY WTOR RESPONSE'\n         END\n//LKED.SYSLMOD DD DSN=WDPSC.PROGLIB,DISP=SHR\n//LKED.SYSLIB DD DSN=WDPSC.PROGLIB,DISP=SHR\n//LKED.SYSIN DD *\n   NAME WTORCOND(R)\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "XEQ": {"ttr": 39436, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x00\\x7f\\x00\\x88\\x00\\x7f\\x12\\x00\\x04\\xdf\\x04\\xdf\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf2\\xf7\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-01-07T00:00:00", "modifydate": "1988-01-07T12:00:00", "lines": 1247, "newlines": 1247, "modlines": 0, "user": "FILE270"}, "text": "*************************************************************JFS03NOV77\n*             LATEST UPDATE DATE                             JFS03NOV77\n         LCLC  &DATE                                         JFS03NOV77\n&DATE    SETC  '04JUN82'    ABL                              JFS03NOV77\n&DATE    SETC  '26MAY87'    *KK                              JFS03NOV77\n*************************************************************JFS03NOV77\nDOPG TITLE 'NASA/GSFC -- DOPROG/DOPGM (TSO) COMMAND PROCESSOR (&DATE)'\n*                                                            JFS03NOV77\n**\n** THE DOPROG TSO COMMAND WAS\n** DESIGNED AND DEVELOPED BY J. SCHINDLER (CSC), MARCH 1975\n**   THE DOPROG COMMAND IS BASED ON AN EARLIER VERSION THAT WAS\n**   DESIGNED AND DEVELOPED BY\n**       GENE CZARCINSKI\n**       NASA, GODDARD SPACE FLIGHT CENTER\n**       GREENBELT, MARYLAND\n**\n** UPDATED 10APR77, GENE CZARCINSKI, NASA/GSFC (GT00501)\n**      . RENAME CSECT FROM 'GSFTSODO' TO 'DOPROG' WITH AN\n**        ENTRY POINT OF DOPGM ... MORE CONSISTANCY AND\n**        CLEANER CMDLIB\n**      . CHANGE BASE REG INIT CODE .. IT IS FLAKY AND MAY CAUSE\n**        ERROR*********\n** UPDATED 03NOV77, J. SCHINDLER, (PAC) CSC\n**      . INCLUDED CODE SO THAT THE LATEST UPDATE DATE COULD BE\n**        CHANGED EASILY\n**      . CHANGED THE LOGIC SO THAT THE 2 BYTES FROM THE ATTACH\n**        ECB IS USED AS THE RETURN CODE THAT IS PASSED ON EXIT\n**        FROM THIS COMMAND PROCESSOR\n** UPDATED 18APR80, B. GODFREY, AFDSC\n**      . BALR TO IKJPARS INSTEAD OF LINK, FOR MVS\n**      . REPLACE REGS MACRO WITH 16 EQUATES\n**      . USE UPTPREFX INSTEAD OF PSCBUSER. ADDED IKJUPT MACRO.\n** UPDATED 24MAY82, A. BRUCE LELAND, HITACHI\n**      . PASS ADDRESSES OF THE UPT, PSCB, AND ECT TO THE\n**        INVOKED PROCESSOR IN CASE IT IS A COMMAND PROCESSOR.\n** UPDATED 04JUN82, A. BRUCE LELAND, HITACHI\n**      . ADD CP PARAMETER TO ALLOW A PROMPT FOR COMMAND PROCESSOR\n**        PARAMETERS\n**\n** UPDATED 26MAY87, K. KISER, WA DP SERVICE CTR (INST CODE WSD) *KK\n**      . CHANGE PARM FROM QSTRING TO SQSTRING TO PASS QUOTES\n**        WARNING: PARM STR REQUIRED IF USING KEYWD OPS, MAY BE NULL\n**      . ADD TASKDD KEYWORD TO ALLOW A DDNAME FOR THE TASKLIB -\n**        THE TASKLIB KEYWORD SOMETIMES STEALS PRIOR ALLOCATIONS\n**\n** ATTR - RENT\n** ALIAS - DOPGM\n**\n** COMMAND -\n**\n** DOPROG/DOPGM 'LOAD MOD NAME' ''PARMS'' TASKLIB/LIB('DSLIST')\n**               RC/NORC/ALLRC  CP/NOCP\n**    'LOAD MOD NAME' - NAME OF THE LOAD MODULE TO BE EXECUTED.\n**    ''PARMS'' - PARM FIELD TO BE PASSED TO THE LOAD MODULE, QUOTED\n**               STRING.\n**    TASKLIB('DSLIST') - SPECIFIES THE DATA SET NAME(S) THAT ARE\n**             CONTENATED AND USED FOR THE TASK LIBRARY.\n**    LIB('DSLIST') - SAME AS TASKLIB\n**    RC - SPECIFIES THAT THE NON-ZERO RETURN CODE FROM THE EXECUTED\n**              PROGRAM IS TO BE PRINTED.\n**    NORC - SPECIFIES THAT THE RETURN CODE IS NOT TO BE PRINTED.\n**          (DEFAULT).\n**    ALLRC - SPECIFIES THAT THE RETURN CODE IS TO BE PRINTED.\n**      NOTE - THE RETURN CODE FROM THE EXECUTED PROGRAM IS ALWAYS\n**             PASSED. IF THIS COMMAND PROCESSOR ENCOUNTERS AN ERROR\n**             OR AN ATTENTION IS ENTERED, THE RETURN CODE IS 16.\n**    NOCP - SPECIFIES THAT THE LOAD MODULE IS NOT A COMMAND PROCESSOR\n**          (DEFAULT).\n**    CP   - SPECIFIES THAT THE LOAD MODULE IS A COMMAND PROCESSOR AND\n**           THAT PARAMETERS ARE TO BE PROVIDED IN RESPONSE TO A\n**           PROGRAM PROMPT.  NOTE THAT IF CP IS CODED, ANY PROGRAM\n**           PARM FIELD IS IGNORED.\n**\n**\n** THIS COMMAND PROCESSOR IS DESIGNED TO LOAD AND EXECUTE (ATTACH) A\n** PROGRAM IN ONE OF THE SYSTEM LINK LIBRARIES OR A USER\n** LIBRARY (TASKLIB).\n**\nDOPROG   CSECT\n         ENTRY DOPGM\n*        REGS\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n**\n** FLAGS SETTINGS -\n**\n**       1... ... - RC (PRINT NON-ZERO RETURN CODES)\n**       .1.. .... - ALLRC (PRINT ALL RETURN CODES)\n**       ..1. .... - TASKLIB SPECIFIED\n**       ...1 .... - DSNAME INPUT IN QOUTES\n**       .... 1... - CP PARAMETER WAS CODED\n**       .... .111 - NOT USED\n**\n**\n** FLAGS EQUATES -\n**\nRCFLG    EQU   B'10000000' PRINT NON-ZERO RC FLAG\nALLRCFLG EQU   B'01000000' PRINT ALL RC FLAG\nTASKFLG  EQU   B'00100000' TASKLIB WAS SPECIFIED\nQFLG     EQU   B'00010000' DSNAME WAS INPUT IN QUOTES FLAG\nCPFLG    EQU   B'00001000' CP PARAMETER WAS CODED\n**\nDOPGM    SAVE  (14,12),,DOPROG/DOPGM-GT00501-&DATE\n         LA    R10,0(,R15)    *** INIT BASE REGS ***        GT00501\n         LA    R11,2048                                     GT00501\n         AR    R11,R11                                      GT00501\n         AR    R11,R10                                      GT00501\n         USING DOPROG,R10,R11\n         LR    R9,R1 SAVE CPPL PTR\n         USING CPPL,R9\n         LA    R0,RENTLEN LOAD LENGTH OF RENT DSECT\n         GETMAIN R,LV=(0) SP=0\n         USING SAVE,R1\n         ST    R1,8(R13)\n         ST    R13,4(R1)\n         LR    R13,R1\n         DROP  R1\n         USING SAVE,R13\n**\n** INIT PARSE PARM LIST (PPL)\n**\nBEGIN    LA    R8,PARSEPL\n         USING PPL,R8\n         MVC   PPLUPT,CPPLUPT USER PROFILE TABLE\n         MVC   PPLECT,CPPLECT ENVIRONMENT CONTROL TABLE\n         LA    R2,ECB\n         ST    R2,PPLECB ECB\n         LA    R2,ANSWER\n         ST    R2,PPLANS ADDR OF PDL\n         MVC   PPLCBUF,CPPLCBUF COMMAND BUFFER\n         XC    PPLUWA,PPLUWA USER WORK AREA ADDR\n         MVC   PPLPCL,=A(PPLPARM) PARM CONTROL LIST\n         MVC   UPTA,CPPLUPT       USER PROFILE TABLE\n         MVC   PSCBA,CPPLPSCB     PROTECTED STEP CONTROL BLOCK\n         MVC   ECTA,CPPLECT       ENVIRONMENT CONTROL TABLE\n**\n** INIT STACK IOPL\n**\n         LA    R8,STAKIOPL\n         USING IOPL,R8\n         MVC   IOPLUPT,CPPLUPT\n         MVC   IOPLECT,CPPLECT\n         LA    R2,STAKECB\n         ST    R2,IOPLECB\n** IOPLIOPB WILL BE INIT BY STACK MACRO\n**\n** INIT IOPL\n**\n         LA    R8,IOPLA\n         USING IOPL,R8\n         MVC   IOPLUPT,CPPLUPT\n         MVC   IOPLECT,CPPLECT\n         LA    R2,ECB\n         ST    R2,IOPLECB\n** IOPLIOPB WILL BE INIT BY MACRO\n**\n** INIT DAIR PARM LIST\n         LA    R8,DAIRPL\n         USING DAPL,R8\n         MVC   DAPLUPT,CPPLUPT\n         MVC   DAPLECT,CPPLECT\n         LA    R2,ECB\n         ST    R2,DAPLECB\n         MVC   DAPLPSCB,CPPLPSCB PROTECTED STEP CONTROL BLOCK\n         LA    R2,DAIRPB\n         ST    R2,DAPLDAPB ADDR OF DAIR PARM BLOCK\n**\n** SAVE PREFIX AND LENGTH WITH PERIOD (.)\n**\n         L     R15,CPPLUPT\n         SR    R3,R3\n         IC    R3,UPTPREFL-UPT(,R15)  LENGTH OF PREFIX\n         LA    R15,UPTPREFX-UPT(,R15) ADDRESS OF PREFIX\n         LR    R4,R3\n         BCTR  R3,R0\n         LA    R14,USERID\n         EX    R3,MOVE\n*MOVE    MVC   0(0,R14),0(R15)\n         LA    R3,USERID(R4)\n         MVI   0(R3),C'.' MOVE IN PERIOD\n         LA    R4,1(R4) FOR PERIOB\n         STH   R4,USERIDL\n         DROP  R8,R9\n**\n** INIT PARM BLOCK, ETC.\n**\n         MVC   PTPB(PTREFL),PTREF INIT PUTLINE PARM BLOCK\n         MVC   PGPB(PGREFL),PGREF INIT PUTGET PARM BLOCK\n         MVC   STAK(STAKREFL),STAKREF INIT STACK PARM BLOCK\n         XC    NODDNS,NODDNS INIT NO. OF DDNAMES SPECIFIED BY TASKLIB\n         XC    ANSWER1,ANSWER1\n         MVI   FLAGS,0\n         MVC   EPENTRY(4),=Y(1,58)\n         MVC   EPNAME,BLANKS\n         LA    R2,1\n         ST    R2,OLD ONLY ONE SEGMENT\n**\n** PARSE THE COMMAND\n**\n         XC    ECB,ECB\n         LA    R1,PARSEPL\n         L     R15,16              CVTPTR\n         TM    524(R15),X'80'      IS IKJPARS IN LPA ?\n         BNO   PARSELNK            IF NOT, DO LINK\n         L     R15,524(,R15)       GET ADDRESS OF IKJPARS\n         BALR  R14,R15             CALL PARSE SERVICE ROUTINE\n         B     PARSELTR            BRANCH AROUND LINK\nPARSELNK EQU   *\n         LINK  EP=IKJPARS LINK TO PARSE\nPARSELTR LTR   R15,R15\n         BZ    PARSEOK\n         LA    R0,MSG01\n         BAL   R14,PUTLINE PARSE ERROR\n         B     ERRORRTN\nPARSEOK  DC    0H'0'\n         L     R12,ANSWER\n         USING PDL,R12\n         STM   R14,R12,STAXSAVE+12 SAVE REGS SO STAXEXIT CAN USE\n**             PROGRAM BASE REGS\n         MVC   STAXLIST(STAXREFL),STAXREF\n         LA    R2,STAXSAVE\n         STAX  STAXEXIT,USADDR=(R2),MF=(E,STAXLIST)\n         CLI   CPKEYWD+1,1 CP PARAMETER?\n         BNE   *+8         NO, BRANCH\n         OI    FLAGS,CPFLG YES, SET THE FLAG\n         CLI   RCKEYWD+1,2 TEST FOR NO RC\n         BE    TESTAKW GO TEST FOR TASK LIB\n         BH    SETALLFL\n         OI    FLAGS,RCFLG\n         B     TESTAKW GO TEST FOR TASK LIB\nSETALLFL OI    FLAGS,ALLRCFLG\nTESTAKW  DC    0H'0'\n         CLI   TASKEYWD+1,0 TEST FOR TASKLIB\n         BNE   TLINIT                                               *KK\n         CLI   TASKDD+1,0         DD REQUEST?                       *KK\n         BE    MOVEEP             NOPE                              *KK\n         OI    FLAGS,TASKFLG      NOTE TASK REQ                     *KK\n         MVC   NODDNS,=H'1'       JUST ONE FOR NOW                  *KK\n         L     R15,TASKDDN        R15->TASKLIB DDNAME               *KK\n         LH    R1,TASKDDN+4       R1=DDN LEN                        *KK\n         BCTR  R1,R0              -1 FOR EX                         *KK\n         MVC   DDNAMES(8),=CL8' ' CLEAR                             *KK\nMVDDN    MVC   DDNAMES(0),0(R15)                                    *KK\n         EX    R1,MVDDN           MOVE FOR REAL                     *KK\n         B     MOVEEP             SKIP DDN ALLOCATION               *KK\n         BE    MOVEEP\nTLINIT   EQU   *                                                    *KK\n**\n**INIT PARSEPL WITH DIFFERENT ANSWER ADDR AND COMMAND BUFFER IN\n** CASE THE DATA SET(S) WHOSE NAMES ARE SPECIFIED BY THE TASKLIB\n** KEYWORD ARE NOT IN THE CATALOG, CANT BE ALLOCATED, ETC.\n**\n         OI    FLAGS,TASKFLG\n         LA    R2,ANSWER1\n         ST    R2,PARSEPL+16\n         LA    R2,CMDLEN\n         ST    R2,PARSEPL+20\n         MVC   PARSEPL+12,=A(DSNPPL)\n         LA    R9,TASKDSNA USE R9 AS BASE FOR DSNAME PDE\nTASKLP1  DC    0H'0'\n         NI    FLAGS,255-QFLG\n         L     R15,0(R9) LOAD ADDR OF DSNAME\n         LTR   R15,R15 TEST FOR DSNAME\n         BNZ   TASKB\n**\n** DATA SET NAME ERROR -- PROBABLY MEMBER NAME ONLY\n**\n         TM    14(R9),B'10000000' TEST FOR MEMBER NAME\n         BO    TASKA\n         LA    R0,MSG02 INVALID DSNAME\n         BAL   R14,PUTLINE\n         B     TASKPRMT GO PROMPT FOR ANOTHER DSNAME\nTASKA    OI    FLAGS,QFLG SO ''( ... )'' WILL BE PRINTED\n         LA    R14,CMDBUF\n         MVI   0(R14),C'('\n         LA    R14,1(R14)\n         LA    R2,1\n         LH    R3,12(R9) LOAD LENGTH OF MEMBER NAME\n         AR    R2,R3\n         BCTR  R3,R0\n         L     R15,8(R9) LOAD ADDR OF MEMBER NAME\n         EX    R3,MOVE\n         LA    R14,1(R3,R14)\n         MVI   0(R14),C')'\n         LA    R2,1(R2)\n         STH   R2,CMDOFF\n         LA    R0,CMDOFF\n         LA    R1,MSG03\n         BAL   R14,MSGOUT GO OUTPUT 'DATA SET --- INVALID'\n         B     TASKPRMT GO PROMPT FOR ANOTHER DATA SET NAME\n**\n** DATA SET NAME WAS SPECIFIED, IGNORE MEMBER NAME IF SPECIFIED.\n**\nTASKB    DC    0H'0'\n         TM    6(R9),B'01000000' TEST FOR QUOTES\n         BZ    TASKC\n         OI    FLAGS,QFLG SET QUOTES FLAG\nTASKC    LH    R2,4(R9) LOAD LENGTH OF DATA SET NAME\n         STH   R2,DSNLEN\n         BCTR  R2,R0\n         LA    R14,DSNAME R15= ADDR OF INPUT DSNAME\n         EX    R2,MOVE\n**\n** ALLOC DSNAME\n**\n         LA    R8,DAIRPB\n         USING DAPB08,R8\n         MVC   DA08CD,=X'0008'\n         XC    DA08FLG(6),DA08FLG\n         LA    R2,DSNLEN\n         ST    R2,DA08PDSN\n         MVI   DA08DDN,C' '\n         MVC   DA08DDN+1(23),DA08DDN\n         XC    DA08BLK(16),DA08BLK\n         MVI   DA08MNM,C' '\n         MVC   DA08MNM+1(15),DA08MNM\n         MVI   DA08DSP1,B'00001000' SHR\n         MVI   DA08DPS2,B'00001000' KEEP\n         MVI   DA08DPS3,B'00001000' KEEP\n         XC    DA08CTL(5),DA08CTL\n         TM    FLAGS,QFLG TEST FOR QUOTE\n         BO    *+8\n         OI    DA08CTL,B'00100000' PREFIX USER ID\n         XC    ECB,ECB\n         LA    R1,DAIRPL\n         LINK  EP=IKJEFD00 LINK TO DAIR\n         LTR   R15,R15\n         BZ    TESTPDS\n         CH    R15,=H'8' TEST FOR CATALOG ERROR\n         BNE   TASKDAER\n         CLC   DA08DARC,=X'170C'\n         BNE   TASKCTER\n         TM    FLAGS,QFLG TEST FOR QUOTES\n         BO    TASKDAER\n**\n** SINCE THE DSNAME IS NOT IN QUOTES, APPEND .LOAD AND TRY ALLOC AGAIN\n**\n         LH    R2,DSNLEN\n         LA    R3,DSNAME(R2)\n         MVC   0(5,R3),=C'.LOAD'\n         LA    R2,5(R2)\n         STH   R2,DSNLEN\n         XC    DA08DARC(4),DA08DARC\n         XC    ECB,ECB\n         LA    R1,DAIRPL\n         LINK  EP=IKJEFD00 LINK TO DAIR\n         LTR   R15,R15\n         BZ    TESTPDS\n         LH    R2,DSNLEN\n         SH    R2,=H'5' FOR .LOAAD\n         STH   R2,DSNLEN\n         CH    R15,=H'8' TEST FOR CATALOG ERROR\n         BNE   TASKDAER\nTASKCTER DC    0H'0' CATALOG ERROR\n         LA    R0,DSNLEN\n         LA    R1,MSG06 DSNAME NOT IN CATALOG\n         BAL   R14,MSGOUT\n         B     TASKPRMT GO PROMPT\n**\n** ALLOCATION ERROR\n**\nTASKDAER DC    0H'0'\n         ST    R15,SAVER15\n         LA    R0,DSNLEN\n         LA    R1,MSG25\n         BAL   R14,MSGOUT\n         L     R15,SAVER15\n         CH    R15,=H'12'\n         BH    TESTDARC\n         MVC   WORKBUFF(L'MSG07),MSG07\n         LA    R6,L'MSG07+8\n         STH   R6,WORKLEN\n         XC    WORKOFF,WORKOFF\n         LH    R2,DA08DARC\n         LA    R4,4\n         SR    R5,R5\n         LA    R6,WORKBUFF+L'MSG07-1\nTASKLP2  SRDL  R2,4\n         SRL   R3,28\n         IC    R5,TABLE(R3)\n         STC   R5,0(R4,R6)\n         BCT   R4,TASKLP2\n         LA    R0,WORKLEN\n         BAL   R14,PUTLINE\n         B     TASKPRMT\nTESTDARC DC    0H'0'\n         CH    R15,=H'16'\n         BH    TSTDARC1\n         LA    R0,MSG26  ALLOCATIONS EXCEEDED\n         BAL   R14,PUTLINE\n         B     TASKPRMT\nTSTDARC1 DC    0H'0'\n         MVC   WORKBUFF(L'MSG27),MSG27\n         CVD   R15,DWORK\n         UNPK  DWORK(3),DWORK+6(2)\n         OI    DWORK+2,C'0'\n         MVC   WORKBUFF+L'MSG27(2),DWORK+1\n         LA    R2,L'MSG27+6\n         STH   R2,WORKLEN\n         XC    WORKOFF,WORKOFF\n         LA    R0,WORKLEN\n         BAL   R14,PUTLINE\n         B     TASKPRMT\n**\n** DATA SET IS ALLOCATED, TEST FOR PDS.\n**\nTESTPDS  TM    DA08DSO,B'00000010' TEST FOR PDS\n         BO    SAVEDDN\n         LA    R0,DSNLEN\n         LA    R1,MSG13\n         BAL   R14,MSGOUT DS IS NOT PDS\n         LA    R1,DA08DDN\n         BAL   R14,FREEDDN GO FREE DDNAME\n         B     TASKPRMT\nSAVEDDN  LH    R2,NODDNS SAVE ALLOCATED DDNAME\n         SLL   R2,3 MULTIPLY BY 8\n         LA    R3,DDNAMES(R2)\n         MVC   0(8,R3),DA08DDN SAVE DDNAME\n         DROP  R8\n         LH    R2,NODDNS\n         LA    R2,1(R2)\n         STH   R2,NODDNS\n         CH    R2,=H'10'\n         BL    TASKENLP\n         CLI   24(R9),X'FF' TEST FOR LAST PDE\n         BE    CONCAT  LAST PDE -- GO CONCAT.\n         LA    R0,MSG08  MORE THAN 10 DSNAMES SPECIFIED BY TASKLIB\n         BAL   R14,PUTLINE\n         LA    R2,MSG09\n         ST    R2,OLD+4\n         TCLEARQ INPUT\n         XC    ECB,ECB\n         PUTGET PARM=PGPB,OUTPUT=(OLD,SINGLE,PROMPT),                  X\n               TERMPUT=(EDIT,WAIT,NOHOLD,NOBREAK),                     X\n               TERMGET=(EDIT,WAIT),MF=(E,IOPLA)\n         CH    R15,=H'4'\n         BH    TESTPGRC GO TEST RETURN CODE\n         L     R2,PGPB+12 LOAD ADDR OF INPUT LINE\n         LH    R3,0(R2) LOAD LENGTH OF INPUT LINE\n         CH    R3,=H'4' TEST FOR NULL LINE\n         BNH   CONCAT\n         B     ERRORRTN\n**\n** PROMPT FOR TASK LIBRARY DATA SET NAME\n**\nTASKPRMT LA    R2,MSG04 ENTER TASKLIB DSNAME\n         ST    R2,OLD+4\n         TCLEARQ INPUT\n         XC    ECB,ECB\nTASKPRMA PUTGET PARM=PGPB,OUTPUT=(OLD,SINGLE,PROMPT),                  X\n               TERMPUT=(EDIT,WAIT,NOHOLD,NOBREAK),                     X\n               TERMGET=(EDIT,WAIT),MF=(E,IOPLA)\n         CH    R15,=H'4'\n         BH    TESTPGRC\n         L     R15,PGPB+12 LOAD ADDR OF INPUT LINE\n         LH    R2,0(R15) LOAD LENGTH\n         CH    R2,=H'48' TEST FOR MAX DSN LENGTH\n         BNH   TASKPRMB\n         LR    R0,R2\n         O     R0,=X'01000000' SP=1\n         LR    R1,R15\n         FREEMAIN R,LV=(0),A=(1)\n         LA    R0,MSG05 DSNAME TOO LONG\n         BAL   R14,PUTLINE\n         B     TASKPRMA\nTASKPRMB BCTR  R2,R0\n         LA    R14,CMDLEN\n         EX    R2,MOVE\n         LH    R0,0(R15)\n         O     R0,=X'01000000' SP=1\n         LR    R1,R15\n         FREEMAIN R,LV=(0),A=(1)\n         LH    R2,CMDLEN\n         CH    R2,=H'4' TEST FOR NULL LINE RESPONSE\n         BNH   TASKENLP GO TO END OF LOOP\n         IKJRLSA ANSWER1\n         XC    ECB,ECB\n         LA    R1,PARSEPL\n         LINK  EP=IKJPARS PARSE DSNAME\n         CH    R15,=H'8' TEST FOR ATTN\n         BE    ERRORRTN GO RETURN\n         BH    TASKPRMC\n         CH    R15,=H'4'\n         BNE   TASKPRMD\nTASKPRMC LA    R0,MSG01 PARSE ERROR\n         BAL   R14,PUTLINE\n         B     ERRORRTN\nTASKPRMD L     R15,ANSWER1\n         USING DSNPDL,R15\n         MVC   0(24,R9),NEWDSN OVERLAY OLD PDE WITH NEW ONE\n         B     TASKLP1\n         DROP  R15\n**\n** TEST FOR RETURN CODE FROM PUTGET\n**\nTESTPGRC CH    R15,=H'8'\n         BE    ERRORRTN\n         CH    R15,=H'12'\n         BNE   TESTRC24\n         TPUT  MSG10,MSG10L NO PROMPTING\n         B     ERRORRTN\nTESTRC24 CH    R15,=H'24'\n         BNE   PGRC28\n         TPUT  MSG11,MSG11L INVALID PARMS\n         B     ERRORRTN\nPGRC28   TPUT  MSG12,MSG12L NOT ENOUGH SPACE\n         B     ERRORRTN\n**\n** TEST FOR END OF PDE'S\n**\nTASKENLP CLI   24(R9),X'FF'\n         BE    CONCAT\n         L     R9,24(R9) ADDR OF NEXT PDE\n         B     TASKLP1\n**\n** ALL DATA SETS FOR TASKLIB HAVE BEEN ALLOCATED. NOW CONCATENATE THEM.\n**\nCONCAT   DC    0H'0'\n         LH    R2,NODDNS TEST FOR TASK LIBRARIES\n         CH    R2,=H'1'\n         BE    MOVEEP\n         BH    CONCAT1\n         LA    R0,MSG16\n         BAL   R14,PUTLINE\n         LA    R2,MSG09\n         ST    R2,OLD+4\n         TCLEARQ INPUT\n         XC    ECB,ECB\n         PUTGET PARM=PGPB,OUTPUT=(OLD,SINGLE,PROMPT),                  X\n               TERMPUT=(EDIT,WAIT,NOHOLD,NOBREAK),                     X\n               TERMGET=(EDIT,WAIT),MF=(E,IOPLA)\n         CH    R15,=H'4'\n         BH    TESTPGRC GO TEST RC FROM PUTGET\n         L     R1,PGPB+12 LOAD ADDR OF INPUT LINE\n         LH    R0,0(R1) LOAD LENGTH\n         CH    R0,=H'4' TEST FOR NULL LINE\n         BH    ERRORRTN\n         O     R0,=X'01000000' SP=1\n         FREEMAIN R,LV=(0),A=(1)\n         B     MOVEEP\nCONCAT1  LA    R8,DAIRPB\n         USING DAPB0C,R8\n         MVC   DA0CCD,=X'000C'\n         XC    DA0CFLG(6),DA0CFLG\n         LH    R2,NODDNS\n         STH   R2,DA0CNUMB\n         XC    DA0CNUMB+2(2),DA0CNUMB+2\n         SLL   R2,3 MULTIPLY BY 8\n         BCTR  R2,R0\n         LA    R14,DA0CDDN\n         LA    R15,DDNAMES\n         EX    R2,MOVE\n         DROP  R8\n         XC    ECB,ECB\n         LA    R1,DAIRPL\n         LINK  EP=IKJEFD00 LINK TO DAIR\n         LTR   R15,R15\n         BZ    MOVEEP GO MOVE IN EP NAME\n         LA    R0,MSG14 CONCAT ERROR\n         BAL   R14,PUTLINE\n         B     ERRORRTN\n**\n** HAVE ALLOCATED AND CONCATENATED THE TASK LIBRARIES, WILL NOW\n** MOVE LOAD MOD NAME, MOVE THE PARM FIELD (IF SPECIFIED), OPEN THE\n** TASKLIB DCB, AND ATTACH.\n**\nMOVEEP   DC    0H'0'\n         LH    R2,LOADMOD+4\n         STH   R2,EPNAMEL   SAVE LENGTH OF PROGRAM NAME\n         BCTR  R2,R0\n         L     R15,LOADMOD\n         LA    R14,EPNAME\n         EX    R2,MOVE MOVE EP NAME\n         TM    PARMA+6,B'10000000' TEST FOR PARM FIELD\n         BO    TSTPARML\n         XC    PARMFLDL,PARMFLDL\n         B     TESTTSK\nTSTPARML LH    R2,PARMA+4 LOAD LENGTH OF QSTRING (PARMFIELD)\n         CH    R2,=H'256'\n         BNH   MOVEPARM\n         LA    R0,MSG15 PARM FIELD EXCEEDS 256 BYTES\n         BAL   R14,PUTLINE\n         LA    R2,256\nMOVEPARM STH   R2,PARMFLDL\n         BCTR  R2,R0\n         L     R15,PARMA LOAD ADDR OF QSTRING\n         LA    R14,PARMFLD\n         EX    R2,MOVE MOVE PARM FIELD\n         LH    R2,NODDNS\n         TM    FLAGS,TASKFLG WAS TASKLIB SPECIFIED?\n         BZ    PROMPT        NO, BRANCH\nTESTTSK  DC    0H'0' TEST FOR TASKLIB DSNAMES\n         LH    R2,NODDNS\n         LTR   R2,R2\n         BZ    PROMPT\n         MVC   TASKLIB(SKELDCBL),SKELDCB\n         LA    R8,TASKLIB\n         USING IHADCB,R8\n         MVC   DCBDDNAM,DDNAMES MOVE DDNAME TO DCB\n         DROP  R8\n**\n**  CHECK FOR CP PARAMETER AND PROMPT IF REQUIRED\n**\nPROMPT   TM    FLAGS,CPFLG      CP CODED?\n         BNO   RELEASE          NO, BRANCH\n         L     R1,ECTA          ECT ADDRESS\n         USING ECT,R1\n         MVC   ECTPCMD(8),EPNAME  CHANGE THE PRIMARY COMMAND NAME\n         DROP  R1\n         LA    R2,MSG28\n         ST    R2,OLD+4\n         XC    ECB,ECB\n         PUTGET PARM=PGPB,OUTPUT=(OLD,SINGLE,MODE), ALLOW CLIST SOURCE X\n               TERMPUT=(EDIT,WAIT,NOHOLD,NOBREAK),                     X\n               TERMGET=(EDIT,WAIT),MF=(E,IOPLA)\n         CH    R15,=H'4'\n         BH    TESTPGRC GO TEST RETURN CODE\n         L     R3,PGPB+12 LOAD ADDR OF INPUT LINE\n         LH    R2,0(R3) LOAD LENGTH OF INPUT LINE\n         CH    R2,=H'256'\n         BNH   MOVECP\n         LA    R0,MSG29 COMMAND EXCEEDS 256 BYTES\n         BAL   R14,PUTLINE\n         LA    R2,256\nMOVECP   BCTR  R2,R0\n         LR    R15,R3    ADDRESS OF COMMAND\n         LA    R14,PARMFLDL\n         EX    R2,MOVE MOVE PARM FIELD\n         AH    R2,=H'1'\n         STH   R2,PARMFLDL\n         LR    R1,R3          ADDRESS OF INPUT STRING\n         LH    R0,0(,R1)      LENGTH OF INPUT STRING\n         O     R0,=X'01000000'  SUBPOOL 1\n         FREEMAIN R,LV=(0),A=(1)  FREEMAIN\n         LA    R15,PARMFLDL(R2)   END OF STRING\n         SR    R2,R2          OFFSET TO PARAMTERS\n         LR    R3,R14         POINT TO STRING\n*\nCOMMSRCH CLI   4(R3),X'40'    START OF COMMAND?\n         BNE   COMMSTRT       YES, BRANCH\n         AH    R2,=H'1'\n         AH    R3,=H'1'\n         B     COMMSRCH\nCOMMSTRT CLI   4(R3),X'40'    END OF COMMAND?\n         BE    COMMEND        YES, BRANCH\n         CR    R3,R15         TERMINATOR?\n         BNL   COMMEND        YES, BRANCH\n         AH    R2,=H'1'\n         AH    R3,=H'1'\n         B     COMMSTRT\nCOMMEND  CLI   4(R3),X'40'    START OF OPERANDS?\n         BNE   COMMOPER       YES, BRANCH\n         CR    R3,R15         TERMINATOR?\n         BNL   COMMEND        YES, BRANCH\n         AH    R2,=H'1'\n         AH    R3,=H'1'\n         B     COMMEND\nCOMMOPER STH   R2,PARMFLDL+2  OFFSET TO COMMAND OPERANDS\n**\n** RELEASE PARSE SPACE BEFORE ATTACHING\n**\nRELEASE  DC    0H'0'\n         IKJRLSA ANSWER\n         XC    ANSWER,ANSWER\n         IKJRLSA ANSWER1\n         XC    ANSWER1,ANSWER1\n         SR    R0,R0\n         GETMAIN R,LV=(0) CLEAN UP SEGMENTS\n         MVC   ATTACH(ATREFL),ATREF\n         XC    ECB,ECB\n         LA    R1,PARMFLDL\n         ST    R1,PARMADDR\n         OI    PARMADDR,X'80'\n         TM    FLAGS,CPFLG       COMMAND PROCESSOR?\n         BNO   *+8               NO, BRANCH\n         XI    PARMADDR,X'80'    YES, TURN OFF PARM FLAG BIT\n         TM    FLAGS,TASKFLG TEST FOR TASK LIB\n         BZ    ATTACH1\n         LH    R2,NODDNS\n         LTR   R2,R2\n         BNZ   OPENDCB\nATTACH1  DC    0H'0'\n         BLDL  0,EPENTRY\n         LTR   R15,R15 WAS EP NAME FOUND?\n         BNZ   EPERROR NO - GO PUT OUT MSG\n         LA    R1,PARMADDR\n         LA    R15,ATTACH\n         LA    R2,ECB\n         LA    R3,EPNAME\n         XC    ECB,ECB\n         ATTACH DE=(3),ECB=(2),SHSPL=SPLIST,                           X\n               MF=(E,(1)),SF=(E,(15))\n         B     WAIT\nOPENDCB  DC    0H'0'\n         MVC   OPEN(OPENREFL),OPENREF\n         LA    R1,OPEN\n         LA    R2,TASKLIB\n         OPEN  ((2),(INPUT)),MF=(E,(1))\n         LA    R8,TASKLIB\n         USING IHADCB,R8\n         TM    DCBOFLGS,B'00010000' TEST FOR OPEN\n         BO    OPENOK\n         LA    R0,MSG17 DCB NOT OPEN\n         BAL   R14,PUTLINE\n         B     ERRORRTN\n         DROP  R8\nOPENOK   DC    0H'0'\n         LA    R3,TASKLIB\n         BLDL  (3),EPENTRY\n         LTR   R15,R15\n         BZ    GOTEPOK\nEPERROR  DC    0H'0' PROGRAM NAME NOT FOUND\n         LA    R14,WORKBUFF\n         MVC   0(MSG20L,R14),MSG20  PROGRAM NAME\n         LA    R14,MSG20L(R14)\n         MVI   0(R14),C''''\n         LA    R14,1(R14)\n         LH    R2,EPNAMEL\n         BCTR  R2,R0\n         LA    R15,EPNAME\n         EX    R2,MOVE  EPNAME\n         LA    R14,1(R2,R14)\n         MVI   0(R14),C''''\n         LA    R14,1(R14)\n         MVC   0(MSG21L,R14),MSG21  NOT FOUND\n         LA    R14,MSG21L(R14)\n         LH    R2,NODDNS\n         LTR   R2,R2\n         BZ    EPERROR1\n         MVC   0(4,R14),=C'TASK'\n         B     EPERROR2\nEPERROR1 MVC   0(4,R14),=C'LINK'\nEPERROR2 LA    R14,4(R14)\n         MVC   0(MSG22L,R14),MSG22  LIBRARIES\n         LA    R14,MSG22L(R14)\n         LA    R2,WORKLEN\n         SR    R14,R2\n         STH   R14,WORKLEN\n         XC    WORKOFF,WORKOFF\n         LA    R0,WORKLEN\n         BAL   R14,PUTLINE\nEPERROR3 LA    R2,MSG23\n         ST    R2,OLD+4\n         TCLEARQ INPUT\n         XC    ECB,ECB\n         PUTGET PARM=PGPB,OUTPUT=(OLD,SINGLE,PROMPT),                  X\n               TERMPUT=(EDIT,WAIT,NOHOLD,NOBREAK),                     X\n               TERMGET=(EDIT,WAIT),MF=(E,IOPLA)\n         CH    R15,=H'4'\n         BH    TESTPGRC\n         L     R1,PGPB+12  LOAD ADDR\n         LH    R3,0(R1)\n         SH    R3,=H'4'\n         BNP   ERRORRTN\n         CH    R3,=H'8'\n         BNH   EPERROR4\n         LA    R0,MSG24  PROGRAM NAME EXCEEDS 8 CHAR\n         BAL   R14,PUTLINE\n         B     EPERROR3\nEPERROR4 STH   R3,EPNAMEL  STORE LENGTH OF EP NAME\n         MVC   EPNAME,BLANKS\n         LA    R14,EPNAME\n         LA    R15,4(R1)\n         BCTR  R3,R0\n         EX    R3,MOVE\n         OC    EPNAME,BLANKS UPPER CASE EP NAME\n         LH    R0,0(R1)\n         O     R0,=X'01000000'  SP=1\n         FREEMAIN R,LV=(0),A=(1)\n         LH    R2,NODDNS\n         LTR   R2,R2\n         BNZ   OPENOK\n         B     ATTACH1\nGOTEPOK  DC    0H'0'\n         LA    R1,PARMADDR\n         LA    R15,ATTACH\n         LA    R2,ECB\n         LA    R4,EPNAME\n         XC    ECB,ECB\n         ATTACH DE=(4),ECB=(2),TASKLIB=(3),SHSPL=SPLIST,               X\n               MF=(E,(1)),SF=(E,(15))\nWAIT     ST    R1,TCB\n         LA    R2,ECB\n         WAIT  ECB=(2)\n         DETACH TCB\n         XC    COMPCDE,COMPCDE   CLEAR CONDITION CODE        JFS04NOV77\n         MVC   COMPCDE+2(2),ECB+2  SAVE CONDITION CODE     JFS03NOV77\n         B     RETURN\n**\n** ERROR RETURN. ATTN, ERROR, ETC. WILL CAUSE CONTROL TO BE PASSED TO\n** THIS SECTION.\n**\nERRORRTN DC    0H'0'\n         IKJRLSA ANSWER\n         IKJRLSA ANSWER1\n         XC    STAKECB,STAKECB\n         STACK PARM=STAK,DELETE=ALL,MF=(E,STAKIOPL)\n         XC    COMPCDE,COMPCDE                               JFS03NOV77\n         MVI   COMPCDE+3,16                                  JFS03NOV77\n**\n** CLEAN UP AND RETURN\n**\nRETURN   DC    0H'0'\n         LH    R2,NODDNS ANY DDNAME TO DECONCATENATE?\n         LTR   R2,R2\n         BZ    RETURN1\n         MVC   CLOSE(CLOSREFL),CLOSREF\n         LA    R1,CLOSE\n         LA    R3,TASKLIB\n         CLOSE ((3)),MF=(E,(1))\n         CH    R2,=H'1'\n         BE    FREEUP ONLY ONE\n         LA    R8,DAIRPB\n         USING DAPB10,R8\n         MVC   DA10CD,=X'0010'\n         XC    DA10FLG(6),DA10FLG\n         MVC   DA10DDN,DDNAMES\n         XC    ECB,ECB\n         LA    R1,DAIRPL\n         LINK  EP=IKJEFD00 LINK TO DAIR\n         LTR   R15,R15\n         BZ    FREEUP\n         LA    R0,MSG18 DECONT. ERROR\n         BAL   R14,PUTLINE\n         DROP  R8\n**\n** FREE THE ALLOCATED DDNAMES\n**\nFREEUP   LR    R3,R2\n         BCTR  R3,R0\n         SLL   R3,3\n         LA    R1,DDNAMES(R3)\n         BAL   R14,FREEDDN\n         BCT   R2,FREEUP\nRETURN1  DC 0H'0'                                            JFS03NOV77\n         L     R2,COMPCDE     RETURN CODE FROM ATTACHED PROG JFS03NOV77\n         TM    FLAGS,ALLRCFLG\n         BO    PUTRCOUT\n         TM    FLAGS,RCFLG\n         BZ    RETURN2\n         LTR   R2,R2\n         BZ    RETURN2\n**                                                           JFS03NOV77\n** CONVERT CONDITION CODE FROM BINARY TO EBCDIC AND          JFS04NOV77\n** OUTPUT THE MESSAGE                                        JFS04NOV77\n**                                                           JFS03NOV77\nPUTRCOUT MVC   WORKBUFF(L'MSG19),MSG19\n         CVD   R2,DWORK\n         UNPK  DWORK(5),DWORK+5(3)                           JFS03NOV77\n         OI    DWORK+4,C'0'                                  JFS03NOV77\n         LA    R15,DWORK-1                                   JFS03NOV77\n         LA    R4,5                                          JFS04NOV77\nPUTRC1   LA    R15,1(R15)                                    JFS03NOV77\n         CLI   0(R15),C'0'  FIND NON ZERO                    JFS03NOV77\n         BNE   PUTRC2                                        JFS03NOV77\n         BCT   R4,PUTRC1                                     JFS03NOV77\n         LA    R4,1  SO AT LEAST 1 0 WILL BE OUTPUT          JFS04NOV77\nPUTRC2   LA    R14,WORKBUFF+L'MSG19                          JFS03NOV77\n         BCTR  R4,R0  -1 FOR MVC                             JFS03NOV77\n         EX    R4,MOVE MOVE IN COMP CODE RETURNED            JFS03NOV77\n         LA    R3,L'MSG19+4+1(R4) +4 FOR HEADER,+1 FOR MVC   JFS03NOV77\n         STH   R3,WORKLEN\n         XC    WORKOFF,WORKOFF\n         LA    R0,WORKLEN\n         BAL   R14,PUTLINE\nRETURN2  DC    0H'0'\n         LA    R0,RENTLEN\n         LR    R1,R13\n         L     R13,SAVE+4\n         FREEMAIN R,LV=(0),A=(1)\n         LR    R15,R2 LOAD RETURN CODE\n         RETURN (14,12),T,RC=(15)\n**\n**\n**\nMOVE     MVC   0(0,R14),0(R15)\n**\n**\n**\n** PUTLINE SECTION\n** ON ENTRY - R0 = ADDR OF MSG, R14 = RETURN ADDR\n**\nPUTLINE  DC    0H'0'\n         ST    R14,PTSVE14\n         XC    ECB,ECB\n         PUTLINE PARM=PTPB,OUTPUT=((R0),TERM,SINGLE,DATA),             X\n               TERMPUT=(EDIT,WAIT,NOHOLD,NOBREAK),MF=(E,IOPLA)\n         LTR   R15,R15 TEST FOR ERRORS, ATTN ETC\n         BZ    PTRTN\n         CH    R15,=H'4' TEST FOR ATTN\n         BE    ERRORRTN GO RETURN WITH RC=16\n         TPUT  PTERROR,PTERRORL PUTLINE ERROR\n         B     ERRORRTN\nPTRTN    L     R14,PTSVE14\n         BR    R14\n**\n** END OF PUTLINE SECTION\n**\n**\n** STAX EXIT\n**\nSTAXEXIT SAVE  (14,12)\n         LR    R2,R13 SAVE SAVE ADDR\n         L     R13,8(R1) LOAD ADDR OF STAXSAVE\n         USING STAXSAVE,R13\n         ST    R2,STAXSAVE+4\n         ST    R13,8(R2)\n         LM    R14,R12,STAXSAVE+12 RESTORE REGS\n         LA    R2,ECB\n         POST  (R2),16  SET RC=16\n         XC    STAKECB,STAKECB\n         STACK PARM=STAK,DELETE=ALL,MF=(E,STAKIOPL)\n         TCLEARQ INPUT\n         TCLEARQ OUTPUT\n         L     R13,STAXSAVE+4\n         RETURN (14,12),RC=0\n         USING SAVE,R13 REESTABLISH BASE REG\n**\n** END OF STAXEXIT\n**\n**\n** OUTPUT -- 'DATA SET ---- ' MSG\n** ON ENTRY - R0 = ADDR OF DSNAME, R1 = ADDR OF LAST PART OF MSG,\n** R14 = RETURN ADDR.\n**\nMSGOUT   DC    0H'0'\n         ST    R14,MSGSVE14\n         STM   R2,R8,MSGSVE28\n         LA    R14,WORKBUFF\n         LA    R3,DATAMSGL\n         LA    R15,DATAMSG\n         BCTR  R3,R0\n         EX    R3,MOVE\n*MOVE    MVC   0(0,R14),0(R15)\n         LA    R14,1(R3,R14)\n         MVI   0(R14),C''''\n         LA    R14,1(R14)\n         TM    FLAGS,QFLG TEST FOR QUOTES\n         BZ    MSGOUT1\n         MVI   0(R14),C''''\n         LA    R14,1(R14)\n         B     MSGOUT2\nMSGOUT1  LH    R3,USERIDL LOAD LENGTH OF USER ID\n         LA    R15,USERID\n         BCTR  R3,R0\n         EX    R3,MOVE ID\n         LA    R14,1(R3,R14)\nMSGOUT2  DC    0H'0'\n         LR    R15,R0\n         LH    R3,0(R15) LOAD LENGTH OF DSNAME\n         LA    R15,2(R15)\n         BCTR  R3,R0\n         EX    R3,MOVE\n         LA    R14,1(R3,R14)\n         TM    FLAGS,QFLG\n         BZ    MSGOUT3\n         MVI   0(R14),C''''\n         LA    R14,1(R14)\nMSGOUT3  MVI   0(R14),C''''\n         LA    R14,1(R14)\n         MVI   0(R14),C' '\n         LA    R14,1(R14)\n         LH    R3,0(R1)\n         LA    R15,2(R1) LOAD ADDR DSNAME\n         BCTR  R3,R0\n         EX    R3,MOVE\n         LA    R14,1(R3,R14)\n         LA    R3,WORKLEN\n         SR    R14,R3\n         STH   R14,WORKLEN\n         XC    WORKOFF,WORKOFF\n         LA    R0,WORKLEN\n         BAL   R14,PUTLINE\n         LM    R2,R8,MSGSVE28\n         L     R14,MSGSVE14\n         BR    R14\n**\n** END OF OUTMSG SECTION\n**\n**\n** FREE DATA SETS BY DDNAME SECTION\n** ON ENTRY - R1 = ADDR OF DDNAME, R14 = RETURN ADDR\n**\nFREEDDN  DC    0H'0'\n         STM   R2,R8,FREESV28\n         ST    R14,FREESV14\n         LA    R8,DAIRPB\n         USING DAPB18,R8\n         MVC   DA18CD,=X'0018'\n         XC    DA18FLG(10),DA18FLG\n         MVC   DA18DDN,0(R1) MOVE IN DDNAME\n         MVI   DA18MNM,C' '\n         MVC   DA18MNM+1(9),DA18MNM\n         MVI   DA18DPS2,B'00001000' KEEP\n         MVI   DA18CTL,B'00010000' UNALLOC PERM\n         MVC   DA18JBNM,BLANKS\n         XC    ECB,ECB\n         LA    R1,DAIRPL\n         LINK  EP=IKJEFD00 LINK TO DAIR\n         LM    R2,R8,FREESV28\n         L     R14,FREESV14\n         BR    R14 RETURN\n         DROP  R8\n**\n** END OF FREE DDNAME SECTION\n**\n         EJECT\n**\n** ADDRS, PARM BLOCKS, ETC.\n**\nATREF    ATTACH SF=L\nATREFL  EQU   *-ATREF\nSTAXREF  STAX  STAXEXIT,MF=L\nSTAXREFL EQU   *-STAXREF\nPGREF    PUTGET MF=L\nPGREFL   EQU   *-PGREF\nPTREF    PUTLINE MF=L\nPTREFL   EQU   *-PTREF\nSTAKREF  STACK MF=L\nSTAKREFL EQU   *-STAKREF\nOPENREF  OPEN  (,),MF=L\nOPENREFL EQU   *-OPENREF\nCLOSREF  CLOSE (,),MF=L\nCLOSREFL EQU   *-CLOSREF\n         PRINT NOGEN\nSKELDCB  DCB   DSORG=PO,MACRF=R  SKELETON DCB\nSKELDCBL EQU   *-SKELDCB\nSPLIST   DC    AL1(3,0,1,78) SHARE SUBPOOL LIST\nBLANKS   DC    CL8' '\nTABLE    DC    C'0123456789ABCDEF' CONVERT TABLE\n         EJECT\n**\n** MESSAGES\n**\nMSG01    DC    Y(MSG01L,0)\n         DC    C'PARSE ERROR'\nMSG01L   EQU   *-MSG01\nMSG02    DC    Y(MSG02L,0)\n         DC    C'INVALID DATA SET NAME'\nMSG02L   EQU   *-MSG02\nMSG03    DC    Y(MSG03L)\n         DC    C'IS AN INVALID TASK LIBRARY NAME'\nMSG03L   EQU   *-MSG03-2\nMSG04    DC    Y(MSG04L,0)\n         DC    C' ENTER TASKLIB DATA SET NAME-'\nMSG04L   EQU   *-MSG04\nMSG05    DC    Y(MSG05L,0)\n         DC    C'DATA SET NAME LENGTH EXCEEDS 44 BYTES'\nMSG05L   EQU   *-MSG05\nMSG06    DC    Y(MSG06L)\n         DC    C'NOT IN CATALOG'\nMSG06L   EQU   *-MSG06-2\nMSG07    DC    C'DYNAMIC ALLOCATION ERROR CODE = '\nMSG08    DC    Y(MSG08L,0)\n         DC    C'NO MORE THAN 10 DATA SET NAMES MAY BE SPECIFIED BY THEX\n                TASKLIB KEYWORD'\nMSG08L   EQU   *-MSG08\nMSG09    DC    Y(MSG09L,0)\n         DC    C' ENTER NULL LINE TO CONTINUE, NON-NULL LINE TO STOP-'\nMSG09L   EQU   *-MSG09\nMSG10    DC    C'CANNOT PROMPT, EITHER YOU ARE EXECUTING A CLIST OR YOUX\n               R PROFILE REQUESTS NO PROMPTING.'\nMSG10L   EQU   *-MSG10\nMSG11    DC    C'INVALID PARAMETERS PASSED TO PUTGET'\nMSG11L   EQU   *-MSG11\nMSG12    DC    C'NOT ENOUGH SPACE FOR PUTGET TO OBTAIN OUTPUT BUFFERS'\nMSG12L   EQU   *-MSG12\nMSG13    DC    Y(MSG13L)\n         DC    C'IS NOT PARTITIONED'\nMSG13L   EQU   *-MSG13-2\nMSG14    DC    Y(MSG14L,0)\n         DC    C'ERROR IN CONCATENATING TASK LIBRARIES'\nMSG14L   EQU   *-MSG14\nMSG15    DC    Y(MSG15L,0)\n         DC    C'PARM FIELD SPECIFIED EXCEEDS 256 BYTES, TRUNCATED'\nMSG15L   EQU   *-MSG15\nMSG16    DC    Y(MSG16L,0)\n         DC    C'NO TASK LIBRARIES'\nMSG16L   EQU   *-MSG16\nMSG17    DC    Y(MSG17L,0)\n         DC    C'TASKLIB DCB OPEN ERROR'\nMSG17L   EQU   *-MSG17\nMSG18    DC    Y(MSG18L,0)\n         DC    C'ERROR IN DECONTENATING TASK LIBRARIES'\nMSG18L   EQU   *-MSG18\nMSG19    DC    C'CONDITION CODE = '                          JFS03NOV77\nMSG20    DC    C'PROGRAM NAME '\nMSG20L   EQU   *-MSG20\nMSG21    DC    C' NOT FOUND IN CONCATENATED '\nMSG21L   EQU   *-MSG21\nMSG22    DC    C' LIBRARIES'\nMSG22L   EQU   *-MSG22\nMSG23    DC    Y(MSG23L,0)\n         DC    C' ENTER PROGRAM NAME, OR NULL LINE TO STOP'\nMSG23L   EQU   *-MSG23\nMSG24    DC    Y(MSG24L,0)\n         DC    C'PROGRAM NAME EXCEEDS 8 CHARACTERS'\nMSG24L   EQU   *-MSG24\nMSG25    DC    Y(MSG25L)\n         DC    C'ALLOCATION ERROR'\nMSG25L   EQU   *-MSG25-2\nMSG26    DC    Y(MSG26L,0)\n         DC    C'MAXIMUM NUMBER OF ALLOCATIONS EXCEEDED'\nMSG26L   EQU   *-MSG26\nMSG27    DC    C'DYNAMIC ALLOCATION RETURN CODE = '\nMSG28    DC    Y(MSG28L,0)\n         DC    C'IKJ57090A ENTER COMMAND FOR CP'\nMSG28L   EQU   *-MSG28\nMSG29    DC    Y(MSG29L,0)\n         DC    C'COMMAND EXCEEDS 256 BYTES, TRUNCATED'\nMSG29L   EQU   *-MSG29\nDATAMSG  DC    C'DATA SET '\nDATAMSGL EQU   *-DATAMSG\nPTERROR  DC    C'PUTLINE ERROR'\nPTERRORL EQU   *-PTERROR\n         PRINT GEN\n         EJECT\n**\n** DSECT FOR REENTRANCY\n**\nRENTDSCT DSECT\nSAVE     DS    18F\nSTAXSAVE DS    18F\nDWORK    DS    D\nMSGSVE28 DS    7F\nMSGSVE14 DS    F\nPTSVE14  DS    F\nFREESV28 DS    7F\nFREESV14 DS    F\nSAVER15  DS    F\nIOPLA    DS    4F\nSTAKIOPL DS    4F\nPARMADDR DS    F ADDR OF PARM FIELD\nUPTA     DS    F ADDR OF UPT\nPSCBA    DS    F ADDR OF PSCB\nECTA     DS    F ADDR OF ECT\nSTAKECB  DS    F\nECB      DS    F\nTCB      DS    F\nPARSEPL  DS    7F PARSE PARM LIST\nDAIRPL   DS    5F DAIR PARM LIST\nDAIRPB   DS    25F DAIR PARM BLOCK\nDA0CDDN  EQU   DAIRPB+12 DA0CDDN NOT DEFINED IN CSECT\nANSWER   DS    F\nANSWER1  DS    F\nOLD      DS    F\nCOMPCDE  DS    F                                             JFS04NOV77\n         DS    A\nEPENTRY  DC    Y(1,58) BLDL\nEPNAME   DS    CL8\n         DS    CL58\nWORKLEN  DS    H\nWORKOFF  DS    H\nWORKBUFF DS    CL120\nATTACH   ATTACH SF=L\nSTAXLIST STAX  STAXEXIT,USADDR=STAXSAVE,MF=L\nPGPB     PUTGET MF=L\nPTPB     PUTLINE MF=L\nSTAK     STACK MF=L\nOPEN     OPEN  (,),MF=L\nCLOSE    CLOSE (,),MF=L\nUSERIDL  DS    H\nUSERID   DS    CL8\n         PRINT NOGEN\nTASKLIB  DCB   DSORG=PO,MACRF=R\n         PRINT GEN\nEPNAMEL  DS    H\nCMDLEN   DS    H\nCMDOFF   DS    H\nCMDBUF   DS    CL44\nDSNLEN   DS    H\nDSNAME   DS    CL44\nNODDNS   DS    H\nDDNAMES  DS    10CL8\nPARMFLDL DS    H\nPARMFLD  DS    CL256\nFLAGS    DS    X\nRENTLEN  EQU   *-RENTDSCT\nDOPROG   CSECT\n         PRINT NOGEN\n         EJECT\n**\n** PARAMETER CONTROL LIST FOR PARSE\n**\nPPLPARM  IKJPARM DSECT=PDL\nLOADMOD  IKJIDENT 'LOAD MOD NAME',MAXLNTH=8,FIRST=ALPHA,               X\n               OTHER=ALPHANUM,PROMPT='NAME OF PROGRAM TO BE EXECUTED'\nPARMQ    IKJPOSIT DELIMITER\nPARMA    IKJPOSIT STRING,HELP='PARM FIELD TO BE PASSED TO PROGRAM',    X\n               SQSTRING\nTASKEYWD IKJKEYWD\n         IKJNAME 'TASKLIB',SUBFLD=TASKSUBF\n         IKJNAME 'LIB',SUBFLD=TASKSUBF\nTASKDD   IKJKEYWD\n         IKJNAME 'TASKDDN',SUBFLD=TASKFLD\nRCKEYWD  IKJKEYWD DEFAULT='NORC'\n         IKJNAME 'RC'\n         IKJNAME 'NORC'\n         IKJNAME 'ALLRC'\nCPKEYWD  IKJKEYWD DEFAULT='NOCP'\n         IKJNAME 'CP'\n         IKJNAME 'NOCP'\nTASKSUBF IKJSUBF\nTASKDSNA IKJPOSIT DSNAME,LIST,PROMPT='TASKLIB DATA SET NAME'\nTASKFLD  IKJSUBF\nTASKDDN  IKJPOSIT DSNAME,DDNAM,PROMPT='TASKLIB DDNAME'\n         IKJENDP\n**\n** PARSE PARM CONTROL LIST FOR PROMPT OF TASKLIB DATA SET NAME\n**\nDSNPPL   IKJPARM DSECT=DSNPDL\nNEWDSN   IKJPOSIT DSNAME,PROMPT='TASKLIB DATA SET NAME'\n         IKJENDP\n         PRINT NOGEN\n         EJECT\n**\n** MAPPING DSECTS\n**\n         IKJCPPL\n         IKJIOPL\n         IKJUPT\n         IKJECT\n         IKJPPL\n         IKJDAPL\n         IKJDAP08\n         IKJDAP0C\n         IKJDAP10\n         IKJDAP18\n         DCBD  DSORG=PO\nDOPROG   CSECT\n         LTORG\n         END   DOPROG\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "XJ22SHOW": {"ttr": 39943, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x00\\x7f\\x00\\x88\\x00\\x7f\\x12\\x00\\x01 \\x01 \\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf2\\xf7\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-01-07T00:00:00", "modifydate": "1988-01-07T12:00:00", "lines": 288, "newlines": 288, "modlines": 0, "user": "FILE270"}, "text": "XJ22SHOW TITLE     'TSO STATUS/CANCEL EXIT'\n***********************************************************************\n*                                                                     *\n*        TSO REQUESTS FOR JOB OWNERSHIP VERIFICATION COMES THRU HERE. *\n*                                                                     *\n*        FOR STATUS...                                                *\n*          A REQUEST FOR STATUS FOR A SPECIAL LENGTH USERID WILL BE   *\n*          TREATED AS  THE SHOW COMMAND. INFORMATION IN THE SJB AND   *\n*          SSOB WILL BE USED TO SELECT PARTICULAR JQE'S WHICH WILL    *\n*          BE COPIED INTO THE SSOB? AREA. THE ROUTINE WILL BE EXITED  *\n*          WITH RETURN CODE 16, WHEREUPON THE SHOW COMMAND CODE WILL  *\n*          INTERPRET THE JQE'S.                                       *\n*                                                                     *\n*        INPUT PARAMETERS                                             *\n*                                                                     *\n*        MAINTENANCE HISTORY:                                         *\n*          JET-D1, CHANGES FOR MVS/XA JES2 VERSION 2.1.5.  JET 12/19/86\n*                                                                     *\n***********************************************************************\n         EJECT                                                   JET-D1\n***********************************************************************\n*                                                                     *\n*                    E X I T     R O U T I N E S                      *\n*                                                                     *\n*        RC = 00 - CONTINUE USING ANY ADDITIONAL EXITS                *\n*        RC = 04 - CONTINUE WITHOUT USING ANY ADDITIONAL EXITS        *\n*        RC = 08 - RETURN SINGLE JQE IN R1 MATCHING REQUEST           *\n*        RC = 12 - MUTIPLE JQES FOUND; CALL AGAIN; R1JQE = JQE ADDR   *\n*                - MUTIPLE JQES FOUND; ALL RETURNED; R1JQE = 0        *\n*        RC = 16 - ALL PROCESSING DONE BY EXIT                        *\n*        RC = 20 - JOB NOT FOUND                                      *\n*        RC = 24 - JOBNAME/JOB NUMBER MISMATCH                        *\n*        RC = 28 - DUPLICATE JOBS                                     *\n*        RC = 32 - STATUS BUFFER TOO SMALL                            *\n*        RC = 36 - JOB ON OUTPUT QUEUE (USE \"CANCEL JOBNAME,PURGE\")   *\n*        RC = 40 - INVALID CANCEL REQUEST (PERMISSION DENIED)         *\n*                                                                     *\n***********************************************************************\n         SPACE     1\n         EJECT\n         COPY  $HASPGBL\n         EJECT\nXJ22SHOW $MODULE   SYSP=(NOGEN,GEN,NODATA,NOGEN,NOGEN),                X\n               ENVIRON=JES2,                                           X\n               TITLE='TSO STATUS/CANCEL',                              X\n               RPL,                    MVS RPL DSECT             JET-D1X\n               SSOB,                   SUBSYSTEM OUTPUT BLOCK          X\n               $BUFFER,                HASP BUFFER                     X\n               $CAT,                   CLASS ATTRIBUTE TABLE           X\n               $HASPEQU,               HASP EQUATES                    X\n               $HCT,                   HASP CONTROL TABLE              X\n               $JCT,                   JOB CONTROL TABLE               X\n               $JOE,                   JOB OUTPUT ELEMENT              X\n               $JOT,                   JOB OUTPUT TABLE                X\n               $JQE,                   JOB QUEUE ENTRY                 X\n               $MIT,                   MODULE IDENTIFICATION TABLE     X\n               $PCE,                   PROCESSOR CONTROL ELEMENT       X\n               $QSE,                   SYSTEM DEFINITION               X\n               $RDRWORK,               READER PCE WORK AREA            X\n               $SCAT,                  SYSOUT CLASS ATTRIBUTE TABLE    X\n               $SJB,                   SUBSYSTEM JOB BLOCK             X\n               $TQE,                   TIMMER QUEUE ELEMENT      JET-D1X\n               $TRP,                   TRACE PARAMETER LIST            X\n               $XECB,                  EXTENDED EVENT CONTROL BLOCK    X\n               $XEQWORK,               PCE COMMAND WORK AREA           X\n               $USERCBS                USER CONTROL BLOCKS\n         SPACE     3\n*        SPECIAL EQUATES\nQUENEXT  EQU       JQENEXT-JQE                                   JET-D1\n         TITLE     '&TITLEID -- ENTRY CONVENTIONS'\n***********************************************************************\n*                                                                     *\n*        MAIN ENTRY POINT OF THE EXIT                                 *\n*                                                                     *\n***********************************************************************\n         SPACE     1\nX22SHOW  $ENTRY    BASE=R12\n         SPACE     1\n         $SAVE     TRACE=YES           SAVE CALLER'S REGISTERS\n         LR        R12,R15             LOAD BASE REGISTER\n         L         R8,0(,R1)           POINT AT SUBSYSTEM JOB BLOCK\n         USING     SJB,R8              ANNOUNCE ADDRESSIBILITY   JET-D1\n         SPACE     1\n         $UCT      R9,TROUBLE=EXITRC00\n         SPACE     3\n         MEMDUMP   ID=7,DATA=SJB,LEN=SJBSIZE,NAME=T22-SJB        JET-D1\n         SPACE     3\n*        STATUS OR CANCEL?\n*\n         CLI       SJBTFUNC+1,SSOBSTAT STATUS REQUEST\n         BNE       EXITRC00            NO\n         TITLE     '&TITLEID -- TSO STATUS REQUEST'\n***********************************************************************\n*                                                                     *\n* THE HIGH-ORDER BIT IN SJBTULEN (SSCSULEN) IS SET FOR REQUESTS       *\n* COMING FROM COMMAND  SHOW . AFTER FINDING THAT THIS IS OUR COMMAND, *\n* FURTHER CHECKING IS DONE TO DEFINE WHAT KIND OF INFORMATION IS      *\n* BEING SOUGHT.                                                       *\n*                                                                     *\n*    SJBTULEN                                                         *\n* SS22SHOW   1... ....   SHOW COMMAND REQUEST                         *\n* SS22RVRS   .1.. ....   REVERSE GENERIC REQUEST                      *\n* SS22LENG   .... XXXX   LENGTH OF GENERIC REQUEST, FORWARD OR REVERSE*\n*                                                                     *\n*   SJBTFLGS             FROM SSCSFLGS                                *\n* SSCSUSID  1... ....    USER ID IN SJBTJNAM                          *\n*                                                                     *\n***********************************************************************\n         TM    SJBTULEN,X'80'      IS THIS A SHOW REQUEST?\n         BZ    EXITRC00            PHONY BIT NOT ON\n         SPACE 4\n         XC    SJBFWORD,SJBFWORD\n         SLR   R15,R15            GET LENGTH LOADED\n         ICM   R15,1,SJBTULEN             AND PREPARED\n         N     R15,=F'15'                      FOR LATER\n         ST    R15,SJBDWORK       SAVE USER ID LENGTH\n         TM    SJBTULEN,X'C0'       REVERSE FLAG ON\n         BO    XJ22A300                  YES\n         TM    SJBTFLGS,SSCSUSID    SPECIFIC USER ID\n         BZ    XJ22A100                  NO\n         LTR   R15,R15             ANY LENGTH TO THE USERID\n         BZ    XJ22SERC              SEARCH ON USERID, ALL FIELDS ZERO\n         LA    R15,4\n         ST    R15,SJBFWORD        STORE INDEX IN WORK AREA\n         B     XJ22SERC\nXJ22A100 EQU   *\n         LTR   R15,R15             ANY LENGTH TO THE JOBNAME\n         BZ    XJ22A200            NO, USE JOBID ONLY\n         LA    R15,12\n         ST    R15,SJBFWORD        STORE INDEX IN WORK AREA\n         B     XJ22SERC\nXJ22A200 EQU   *\n         LA    R15,8               JOB ID SEARCH\n         ST    R15,SJBFWORD        STORE INDEX IN WORK AREA\n         B     XJ22SERC\nXJ22A300 EQU   *\n         TM    SJBTFLGS,SSCSUSID   USER ID REQUEST\n         BO    EXITRC00\n         LTR   R15,R15             USERID LENGTH\n         BZ    EXITRC00                HAS TO BE\n         LA    R15,16            REVERSE GENERIC JOBNAME\n         ST    R15,SJBFWORD\n         B     XJ22SERC\n         SPACE 5\nXJ22SERC EQU   *\n*       SEARCH  JOB QUEUE\n         SLR   R15,R15                     PREPARE\n         ST    R15,XEQWORK                    TO SCAN\n         LA    R1,$JQHEADS-$JQHEADL-QUENEXT(R15) ACTIVE QUEUES\n         SPACE\n         L     R7,SJBTAREA          LOCATION OF AREA TO FILL IN\n         LA    R6,JQEBLEN           INDEX LENGTH                 JET-D1\n         CH    R6,SJBTDIMP          JQE LENGTH TO SIZE\n         BNL   EXITRC00   GET OUT, PROBABLY DESERVES A MESSAGE\n         LA    R2,0(R6,R7)            ALSO\n         ST    R7,SJBDWORK+4          SAVE FOR TRACING\n         ST    R6,0(,R7)           SET LENGTH OF INFORMATION ENTRY\n         AH    R7,SJBTDIMP              ADD LENGTH OR AREA\n         SR    R7,R6                DECREASE LIMIT BY INDEX LENGTH\n         SR    R7,R6                         TWICE\n         LR    R4,R6                LOAD FOR MOVE\n         BCTR  R4,0                      DECREASE BY 1\n         L     R3,SJBFWORD         BRANCH\n         B     XJ22SCN\n         SPACE 4\nXJ22SCN0 EQU   *\n         L     R15,XEQWORK         RELOAD INDEX INTO QUEUE HEADERS\n         LA    R15,$JQHEADL(,R15)  ADD TO INDEX INT0 QUEUE HEADERS\n         CL    R15,=A($JQTYPES*$JQHEADL) ANOTHER QUEUE?\n         BH    XJQUEND\n         ST    R15,XEQWORK         SAVE NEW QUEUE HEAD OFFSET\n         LA    R1,$JQHEADS-$JQHEADL-QUENEXT(R15) PREPARE TO SCAN\n         SPACE 1\n         USING JQE,R1                                            JET-D1\nXJ22SCN  EQU   *\n         L     R1,JQENEXT          GET OFFSET OF NEXT JQE\n         N     R1,$ZEROFFF         END OF THIS QUEUE\n         BZ    XJ22SCN0            FIND NEXT QUEUE OF JQE'S\n         AL    R1,$JOBQPTR         CONVERT OFFSET TO ABSOLUTE ADDRESS\n         CLI   JQETYPE,$FREE       IF JQE IS FREE,\n         BE    XJ22SCN                    THEN SKIP IT\n         MEMDUMP   ID=7,DATA=JQE,LEN=JQEBLEN,NAME=T22-JQEA       JET-D1\n         B     XJ22C944(R3)\nXJ22C944 EQU   *\n         B     XJ22C100           0 USER ID/ ACF2 REQUEST\n         B     XJ22C200           4 USE TSO TIOT NAME AS USERID\n         B     XJ22C300           8 JOB ID ONLY\n         B     XJ22C400          12 GENERIC JOB NAME SEARCH\n         B     XJ22C500          16 REVERSE GENERIC SEARCH\n         SPACE 3\nXJ22C100 EQU   *           USER ID TO  JQEOWNER MATCH\n         CLC   SJBTJOBN,JQEOWNER\n         BNE   XJ22SCN\n         B     XJ22MOVE           FOUND ONE\n         SPACE 3\nXJ22C200 EQU   *      SEARCH BASED ON OS KNOWN TSO NAME\n         CLC   SJBTJOBN(2),JQEJNAME\n         BNE   XJ22SCN\n         CLC   SJBTJOBN+2(5),JQEJNAME+3\n         BNE   XJ22SCN\n         B     XJ22MOVE\n         SPACE 3\nXJ22C300 EQU   *          SEARCH ON JOB ID/NUMBER\n         CLC   SJBTJOBI+2(2),JQEJOBNO\n         BNE   XJ22SCN\n         B     XJ22MOVE\n         SPACE 3\nXJ22C400 EQU   *          GENERIC JOB NAME SEARCH\n         L     R15,SJBDWORK\n         BCTR  R15,0\n         EX    R15,XJ22CLC2         CLC  SJBTJOBN,JQEJNAME\n         BNE   XJ22SCN\n         B     XJ22MOVE             YES, GOOD WORK\nXJ22CLC2 CLC   SJBTJOBN(0),JQEJNAME\n         SPACE 3\nXJ22C500 EQU   *\n         LA    R15,8\n         L     R5,SJBDWORK          GET THE LENGTH\n         SR    R15,R5               GET THE OFFSET IN THE JQE\n         LA    R15,JQEJNAME(R15)    POINT INTO JOBNAME\n         BCTR  R5,0\n         EX    R5,XJ22CLC3    CLC   SJBTJOBN,0(R15)\n         BNE   XJ22SCN\n         B     XJ22MOVE\nXJ22CLC3 CLC   SJBTJOBN(0),0(R15)\n         SPACE 3\nXJ22MOVE EQU   *\n         MEMDUMP   ID=7,DATA=JQE,LEN=JQEBLEN,NAME=T22-JQEM       JET-D1\n**\n*COPY THE JQE INTO THE AREA POINTED TO BY THE SSOB AND $SJB\n*\n         EX   R4,XJMOVEIT\n************* MVC  0(0,R2),JQE       MOVE THE JQE\n         BXH  R2,R6,XJQUEND            OUTPUT AREA IS FULL\n         B    XJ22SCN\nXJMOVEIT MVC  0(0,R2),JQE       MOVE THE JQE\n         SPACE 3\nXJQUEND  EQU  *\n*        S    R2,SJBDWORK+4    END - BEGINNING = LENGTH\n*        STH  R2,SJBTDIMR      SEND LENGTH BACK TO REQUESTOR\n         L    R15,$QSE1        LOCATION OF SYSTEM AFFINITY IDS\n         LH   R1,=AL2(QSELEN)  LENGTH OF QSE ENTRY\n         L    R2,SJBDWORK+4    BEGINNING OF RETURN AREA\n         LA   R3,7\n         USING QSE,R15                                           JET-D1\nXJQSEEND EQU  *\n         MVC  16(L'QSESID+2,R2),QSESID   COPY NAME OF SYSTEM\n         AR   R15,R1                ADD LENGTH OF QSE\n         LA   R2,6(,R2)             ADD LENGTH OF QSEID\n         BCT  R3,XJQSEEND           DO IT SEVEN TIMES\n         SLR  R1,R1                    SIGNAL END OF QUEUE\n         B    EXITRC16                   AND MULTIPLE REQUEST\n         EJECT\n         TITLE     '&TITLEID -- EXIT'\n***********************************************************************\n*                                                                     *\n*                    E X I T     R O U T I N E S                      *\n*                                                                     *\n*        RC = 00 - CONTINUE USING ANY ADDITIONAL EXITS                *\n*        RC = 04 - CONTINUE WITHOUT USING ANY ADDITIONAL EXITS        *\n*        RC = 08 - RETURN SINGLE JQE IN R1 MATCHING REQUEST           *\n*        RC = 12 - MUTIPLE JQES FOUND; CALL AGAIN; R1JQE = JQE ADDR   *\n*                - MUTIPLE JQES FOUND; ALL RETURNED; R1JQE = 0        *\n*        RC = 16 - ALL PROCESSING DONE BY EXIT                        *\n*        RC = 20 - JOB NOT FOUND                                      *\n*        RC = 24 - JOBNAME/JOB NUMBER MISMATCH                        *\n*        RC = 28 - DUPLICATE JOBS                                     *\n*        RC = 32 - STATUS BUFFER TOO SMALL                            *\n*        RC = 36 - JOB ON OUTPUT QUEUE (USE \"CANCEL JOBNAME,PURGE\")   *\n*        RC = 40 - INVALID CANCEL REQUEST (PERMISSION DENIED)         *\n*                                                                     *\n***********************************************************************\n         SPACE     1\nEXITRC00 EQU       *\n         MEMDUMP   ID=7,DATA=SJB,LEN=SJBSIZE,NAME=T22-R00       JET-D1\n        $RETURN    RC=0,TRACE=YES      RETURN TO JES2\n         SPACE     3\nEXITRC16 EQU       *\n         REGTRACE  ID=3,NAME=T22EXIT\n         MEMDUMP   ID=7,DATA=SJB,LEN=SJBSIZE,NAME=T22-R16\n         L         R5,SJBTAREA\n         MEMDUMP   ID=7,DATA=(R5),LEN=SJBTDIMP,NAME=T22-T16\n        $RETURN    RC=16,TRACE=YES     RETURN TO JES2\n         SPACE     5\n         LTORG     ,\n         EJECT\n        $MODEND    ,\n         END       ,\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT270/FILE270.XMI", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT270", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}