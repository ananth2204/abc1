{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "SBGOLOB", "INMTNODE": "ZATLAS1", "INMTUID": "A", "INMFTIME": "20200908193423000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 587860, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 27920, "INMRECFM": "FB", "INMDIR": 12, "INMDSNAM": "ZATLAS1.C14.MACLIB", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 587860, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 587860, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"ZATLAS1.C14.MACLIB": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 27920, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3000, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "200249", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\xc0\\x00\\x00\\x05'", "DS1LSTAR": "b'\\x00\\n\\t'", "DS1TRBAL": "b'\\x80\\xf6'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f3\\x80\\x00\\x04\\x97\\xc0`'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f3\\x80\\x00\\x04\\x97\\xc0`'", "b'P\\xf4\\xb2h\\x00\\x00\\x00`\\x00\\x00\\x00`\\x00\\x0e\\x00\\x0f'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"###DOC##": {"ttr": 2308, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x0b\\x00@\\x01\\x17&\\x1f\\x01\\x19\\x16o\\x18%\\x00\\x9e\\x00\\x01\\x00\\x00\\xe2\\xc4\\xd1\\xd9\\xc7@@@@@'", "ispf": {"version": "01.11", "flags": 0, "createdate": "2017-09-18T00:00:00", "modifydate": "2019-06-15T18:25:40", "lines": 158, "newlines": 1, "modlines": 0, "user": "SDJRG"}, "text": "The following macros are part of the Concept 14 structured programming\nmacros which were written by Marvin Kessler in 1970.\nThey have been amended by John Gateley to use branch relative on\ncondition instead of branch on condition.\n\nDO\nDOEXIT\nDOPROC\nELSE\nELSEIF\nENDDO\nENDEVAL\nENDIF\nEVALUATE\nGBLVARS\nGETCC\nIF\nIFPROC\nIFTEST\nOTHERWSE\nPLIST\nPOPINS\nPOPNEST\nPUSHINS\nPUSHLAB\nPUSHNEST\nSTKINS\nTESTNEST\nWHEN\n\nJRGTIOT   Copy of the MVT macro IEFTIOT1\n          amended to make the DSECTs explicit.\n\nThe PRG*  macros are used to create structured programs which can\n          be reentrant. Code RENT=Y.\n\nPRGDEF    Module initialisation\n          This sets up standard linkage and register equates.\n          The modue defaults to AMODE=31 RMODE=ANY but this can\n          be overridden.\n          The following OPSYN commands are used so that any branch\n          statements in macros are converted to branch relative.\n          B          OPSYN BRU\n          BAL        OPSYN BAS\n          BALR       OPSYN BASR\n          The LOCTR statement is used to split the module into #DATA\n          and #CODE sections with the #DATA section first. The #DATA\n          section starts with eye catchers of the module name and\n          the assembly timestamp and is based on register 12.\n          The FSEG parameter indicates the first code segment to\n          be performed. Each code segment reuses register 11 as\n          its base register and this is automatically maintained\n          when other segments are performed using SEGDO.\n          Note, NEVER branch out of a segment as the code base\n          register will then have an invalid value and anything\n          could happen. To exit a segment use SEGQUIT which returns\n          to where the segment was called, or to exit the program\n          use PRGQUIT.\n          If RENT=Y is used the storage defined between PRGDEF and\n          PRGEDEF will be getmained on entry to the program and\n          freemained on exit. If RENT=N then this storage will map\n          over an area in PRGSTAT.\n          Facilities for writing rexx functions are provided by\n          use of REXX=Y and INREX=Y. REXX=Y means that the program\n          will be called as a rexx function and registers 7 to 10\n          will map rexx programming interfaces. INREX=Y means that\n          the program will be called by another REXX aware program\n          and the registers will be maintained.\n          A reentrant form of the WTO macro will be included and\n          the field MESS_TXT should be used to build an output\n          message and WTOX will write this and clear the area to\n          spaces.\n\nPRGEDEF   Module termination - storage defined between these macros\n          is based on register 13 after the save area\n          This handles exit processing and if rexx is active it\n          checks if EVALBLOCK result has been set, if not is is\n          populated with the return code in field R_C.\n          R_C can be populated with SETRC RC=? or PRGQUIT RC=?.\n\nPRGPARM   grap any parameter from R1 - use for JCL invocation\n\nPRGSTAT   Module static storage for constants and DCB.\n          This reestablishes the #DATA LOCTR so that this storage\n          is based on register 12 and comes directly after timestamp.\n\nPRGESTAT  Module end of static storage\n\nPRGEND    Module end\n\nPRGDCBI   Generate code segments for an input file (open,get,close)\n          works with spanned records\n\nPRGDCBO   Generate code segments for an output file (open,put,close)\n          works with spanned records\n\nPRGQUIT   Go directly to the module termination routine\n\nPRGSTEM   Define storage for use in program PROCSTEM which looks\n          after dropping and defining a rexx stem variable\n\nSEGDO     perform a segment of code\n\nSEGS      start a segment of code - when used with PRG* macros\n          the same register is used as code base in all segments\n          so each segment could be up to 4K. Never blow a base.\n\nSEGQUIT   exit from this code segment back to wherever it came from.\n\nSEGE      end of a segment of code\n\nSETRC     set the R_C return code value in PRG*\n\nBEDIT     build an edit pattern to use in ED or EDMK based on the\n          size of the packed decimal field.\n\nXEDIT     build an edit pattern to use in ED or EDMK based on the\n          size of the packed decimal field and actually execute\n          the ED or EDMK.\n\nSTRING    acts like the COBOL STRING verb and allows conversion\n          of integer and packed-decimal values to numeric and\n          register values to hexadecimal display.\n\nSTRINGIT  program used by STRING\n\nTRIM      trim blanks from a variable\n          removes leading and extra blanks from a variable.\n          that is ' A  B ' becomes 'A B   '\n          after completion R15 contains the length of the string\n          ALL=Y can be used to remove all blanks\n          that is ' A  B ' becomes 'AB    '\n\nTRIMIT    program used by TRIM\n\nTSTMP     generate a timestamp from STCKE\n          FORMAT=DB2  - CL26'2017-04-01-12.34.56.789012'\n                 CHAR - CL20'20170401123456789012'\n                 PACK - PL11'020170401123456789012C'\n\nWTOX      does a WTO from MESS_TXT which is defined in PRGDEF\n          and then clears MESS_TXT to spaces unless CLEAR=N\n\nLNKBLD    creates a linked list of getmained storage, see PIPECNT\n          for example usage.\n\nLNKDEL    deletes all the linked list storage\n\nXEDIT     build an edit pattern and execute it\n\nXPACK     pack a character string to hex       C'C1F1' X'A1'\n          uses a translate table that is automatically generated in\n          PRGSTAT if XPACK has been used in the program.\n\nXUNPK     unpack a hex string to character     X'A1' C'C1F1'\n          uses a translate table that is automatically generated in\n          PRGSTAT if XUNPK has been used in the program.\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "BEDIT": {"ttr": 273, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x08\\x00H\\x01\\x170/\\x01\\x170/\\x17\\x11\\x00\\x97\\x00\\x91\\x00\\x00\\xe2\\xc4\\xd1\\xd9\\xc7@@@@@'", "ispf": {"version": "01.08", "flags": 0, "createdate": "2017-10-29T00:00:00", "modifydate": "2017-10-29T17:11:48", "lines": 151, "newlines": 145, "modlines": 0, "user": "SDJRG"}, "text": "         MACRO\n&LABEL   BEDIT &INL,&PAD=' ',&DEC='.',&DECP=0,&THOU=',',&SIGN=\n.**********************************************************************\n.*\n.* Created by John Gateley\n.*\n.*  This macro builds an edit pattern with the name specified\n.*  which can then be copied into the output area and used in\n.*  and ED or EDMK instruction.\n.*  For EDMK &LABEL.S is equated to the offset from the start of\n.*  the significant byte to be put in register 1 before executing.\n.*  &LABEL.D is equated to the offset from the start to the\n.*  decimal point. A comparison of the values in different edit\n.*  patterns can be used to align the decimal point from multiple\n.*  edit patterns to produce a nicely formatted report.\n.*\n.*       &INL  length of the packed field in bytes\n.*\n.*       &PAD  value for pad character       ' '\n.*       &DEC  value for decimal point       '.'\n.*       &DECP number of decimal places\n.*       &THOU value for thousand separator  ','\n.*       &SIGN value for sign, e.g.  SIGN=-  SIGN='-'  SIGN=' (CR)'\n.*\n.*  BEDIT 5                            for PL5\n.*\n.*  BEDIT 5,DECP=2                     for PL5 with two decimals\n.*\n.*  BEDIT 5,THOU=                      to give no separator\n.*\n.*  BEDIT 3,PAD=0,DEC=',',DECP=2,THOU='.',SIGN=' (CR)'\n.*\n.*  BEDIT 4,PAD=' ',DEC='.',DECP=0,THOU=','\n.*\n.*      MVC   LONG_CHAR1,LONG_EDP_1\n.*      LA    R1,LONG_CHAR1\n.*      AHI   R1,LONG_EDP_1L\n.*      EDMK  LONG_CHAR1,LONG_PACK1\n.*      BCTR  R1,0\n.*      MVI   0(R1),C'$'\n.*\n.* LONG_PACK1     DC    PL8'12345678'\n.* LONG_EDP_1     BEDIT 8,DECP=3,SIGN='-'\n.* LONG_CHAR1     DS    CL(L'LONG_EDP_1)\n.*\n&CNT     SETA  0                         * set pattern count to 0\n&CNTMRK  SETA  0                         * set EDMK offset\n&CNTDEC  SETA  0                         * set decimal point offset\n&SEL     SETC  '20'                      * set digit selector\n&SIG     SETC  '21'                      * set significant digit sel\n&PATN    SETC  ''                        * start with empty pattern\n         AIF   ('&PAD' EQ '').NOPAD\n         AIF   ('&PAD'(1,1) EQ '''').QUOT1  * value in quotes\n&MPAD    SETC  '&PAD'\n         AGO   .QUOT1A\n.QUOT1   ANOP\n&MPAD    SETC  '&PAD'(2,K'&PAD-2)\n.QUOT1A  ANOP\n&MPAD    SETC  C2X('&MPAD')              * convert to hex\n&PATN    SETC  '&PATN&MPAD'              * put in pad character\n&MYLEN   SETA  K'&MPAD/2                 * get length of pad\n         AIF   (&MYLEN NE 1).MERR1       * can only be one\n&CNT     SETA  &CNT+&MYLEN               * add to count in pattern\n.NOPAD   ANOP\n.*\n&LENR    SETA  &INL                      * get input length\n&LENR    SETA  &LENR*2                   * multiply by 2\n&LENR    SETA  &LENR-1                   * subtract 1 gives no. digits\n&LENR    SETA  &LENR-&DECP               * subtract number of decimals\n.*\n.AGAIN   ANOP\n         AIF   (&LENR EQ 2).IS2\n&PATN    SETC  '&PATN&SEL'               * put in digit select\n         AGO   .NOT2\n.IS2     ANOP\n&PATN    SETC  '&PATN&SIG'               * put in significant digit\n&CNTMRK  SETA  &CNT+1                    * set significant offset\n.NOT2    ANOP\n&CNT     SETA  &CNT+1                    * add to count in pattern\n&LENR    SETA  &LENR-1                   * subtract 1 from remaining\n         AIF   (&LENR EQ 0).NOAGIN\n&LENT    SETA  (&LENR/3)*3               * divide by 3 and multiply\n.*\n         AIF   ('&THOU' EQ '').NOTHOU    * no thousand separator\n         AIF   (&LENT NE &LENR).NOTHOU   * not multiple of 3 left\n         AIF   ('&THOU'(1,1) EQ '''').QUOT2  * value in quotes\n&MTHOU   SETC  '&THOU'\n         AGO   .QUOT2A\n.QUOT2   ANOP\n&MTHOU   SETC  '&THOU'(2,K'&THOU-2)\n.QUOT2A  ANOP\n&MTHOU   SETC  C2X('&MTHOU')             * convert to hex\n&PATN    SETC  '&PATN&MTHOU'             * put in thousand separator\n&MYLEN   SETA  K'&MTHOU/2                * get length of thou separator\n         AIF   (&MYLEN NE 1).MERR2       * can only be one\n&CNT     SETA  &CNT+&MYLEN               * add to count in pattern\n.NOTHOU  ANOP\n         AIF   (&LENR GT 0).AGAIN        * anything remaining - repeat\n.*\n.NOAGIN  ANOP\n.*\n.* so now we have run out of digits before the decimal place (if any)\n.*\n         AIF   (&DECP EQ 0).TRYSGN       * if none try sign\n         AIF   ('&DEC' EQ '').TRYSGN      * value in quotes\n         AIF   ('&DEC'(1,1) EQ '''').QUOT3  * value in quotes\n&MDEC    SETC  '&DEC'\n         AGO   .QUOT3A\n.QUOT3   ANOP\n&MDEC    SETC  '&DEC'(2,K'&DEC-2)\n.QUOT3A  ANOP\n&MDEC    SETC  C2X('&MDEC')              * convert to hex\n&PATN    SETC  '&PATN&MDEC'              * put in decimal separator\n&CNTDEC  SETA  &CNT                      * set decimal point offset\n&MYLEN   SETA  K'&MDEC/2                 * get length of dec separator\n         AIF   (&MYLEN NE 1).MERR3       * can only be one\n&CNT     SETA  &CNT+&MYLEN               * add to count in pattern\n&LEND    SETA  &DECP                     * copy decimal places\n.*\n.TRYDEC  ANOP\n&PATN    SETC  '&PATN&SEL'               * put in digit select\n&CNT     SETA  &CNT+1                    * add to count in pattern\n&LEND    SETA  &LEND-1                   * reduce decimal place count\n         AIF   (&LEND NE 0).TRYDEC       * places remaining - so loop\n.*\n.TRYSGN  ANOP\n         AIF   ('&SIGN' EQ '').NOSIGN    * sign byte required\n         AIF   ('&SIGN'(1,1) EQ '''').QUOT9  * value in quotes\n&MSIGN   SETC  '&SIGN'\n         AGO   .QUOT9A\n.QUOT9   ANOP\n&MSIGN   SETC  '&SIGN'(2,K'&SIGN-2)\n.QUOT9A  ANOP\n&MSIGN   SETC  C2X('&MSIGN')             * convert to hex\n&PATN    SETC  '&PATN.&MSIGN'            * put in sign value\n&MYLEN   SETA  K'&MSIGN/2                * get length of record area\n&CNT     SETA  &CNT+&MYLEN               * add to count in pattern\n.NOSIGN  ANOP\n.*\n&LABEL   DC    X'&PATN'                  * create edit pattern\n&LABEL.S EQU   &CNTMRK                   * significant digit offset R1\n&LABEL.D EQU   &CNTDEC                   * decimal point offset\n         MEXIT\n.*\n.MERR1   MNOTE 16,'Pad character can only be 1 byte'\n         MEXIT\n.MERR2   MNOTE 16,'Thousand separator can only be 1 byte'\n         DC    'thou=&THOU'\n         MEXIT\n.MERR3   MNOTE 16,'Decimal separator can only be 1 byte'\n         MEND\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "DO": {"ttr": 275, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "         MACRO\n         DO    &P1,&FROM=,&TO=,&BY=,&UNTIL=,&WHILE=\n         LCLA  &POSNO\n         PUSHNEST DO\n.* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n.*                                                                   *\n.*  THE FOLLOWING SECTION HAS BEEN ADDED TO PREVENT MORE THAN ONE    *\n.*  CONDITION FROM BEING SPECIFIED ON A \"DO UNTIL\" OR A \"DO WHILE\" . *\n.*  THE MACRO ONLY EXPECTS ONE CONDITION, BUT DOES NOT REJECT        *\n.*  MULTIPLE CONDITIONS.                                             *\n.*                                                                   *\n.* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n.*\n         AIF   (T'&P1 EQ 'O').CHKPOS    IF NO POSITIONAL PARAMETER\n         AIF   ('&P1' EQ 'INF').EXPAND  IF PARAMETER VALID\n         MNOTE 50,'INVALID PARAMETER \"&P1\"'\n         MNOTE 50,'DO MACRO - EXPANSION TERMINATED'\n         MEXIT\n.*\n.CHKPOS  ANOP\n&POSNO   SETA  N'&SYSLIST            NUMBER OF POSITIONAL PARMS\n         AIF   (&POSNO EQ 0).EXPAND\n         MNOTE 50,'TOO MANY POSITIONAL PARAMETERS SPECIFIED'\n         MNOTE 50,'DO MACRO - EXPANSION TERMINATED'\n         MEXIT\n.*\n.EXPAND  ANOP\n.* * * * *  E N D   O F   A D D E D   S E C T I O N  * * * * * * * * *\n         DOPROC &FROM,&TO,&BY,&UNTIL,&WHILE,&P1\n         MEND\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DOEXIT": {"ttr": 277, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "  MACRO\n  DOEXIT   &P1,&P2,&P3,&P4,&P5,&P6,&P7,&P8,&P9,&P10,                   /\n               &P11,&P12,&P13,&P14,&P15,&P16,&P17,&P18,&P19,&P20,      /\n               &P21,&P22,&P23,&P24,&P25,&P26,&P27,&P28,&P29,&P30,      /\n               &P31,&P32,&P33,&P34,&P35,&P36,&P37,&P38,&P39,&P40,      /\n               &P41,&P42,&P43,&P44,&P45,&P46,&P47,&P48,&P49,&P50,&CC=\n GBLA &CCVAL\n GBLA &CTR\n GBLA &SEQ\n GBLA &AI\n GBLA &CI\n GBLA &II\n GBLA &LI\n GBLA &NI\n GBLA &AIND(50)\n GBLA &CIND1(200)\n GBLA &MULT(50)\n GBLA &ST(51)\n GBLC &CIND2(200)\n GBLC &IIND1(100)\n GBLC &IIND2(100)\n GBLC &I22(100)\n GBLC &I23(100)\n GBLC &I24(100)\n GBLC &IIND3(100)\n GBLC &I32(100)\n GBLC &I33(100)\n GBLC &I34(100)\n GBLC &IIND4(100)\n GBLC &I42(100)\n GBLC &I43(100)\n GBLC &IIND5(100)\n GBLC &LIND(101)\n GBLC &NEST(50)\n GBLC &RIND(50)\n PUSHLAB\n&NEST(&NI) SETC '&NEST(&NI)'(1,4)'DO'\n IFPROC &CC,&P1,&P2,&P3,&P4,&P5,&P6,&P7,&P8,&P9,&P10,                  /\n               &P11,&P12,&P13,&P14,&P15,&P16,&P17,&P18,&P19,&P20,      /\n               &P21,&P22,&P23,&P24,&P25,&P26,&P27,&P28,&P29,&P30,      /\n               &P31,&P32,&P33,&P34,&P35,&P36,&P37,&P38,&P39,&P40,      /\n               &P41,&P42,&P43,&P44,&P45,&P46,&P47,&P48,&P49,&P50\n  MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "DOPROC": {"ttr": 279, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "  MACRO\n  DOPROC &FROM,&TO,&BY,&UNTIL,&WHILE,&P1\n  GBLA  &CCVAL   COND CODE VARIABLE\n  GBLA  &CTR   MACRO PARAMETER COUNTER\n  GBLA  &SEQ   LABEL NUMBER GENERATOR\n  GBLA  &AI   INDEX FOR TOTAL NO. CASES STK\n  GBLA  &CI   INDEX FOR CASE AND LBL NO. STKS\n  GBLA  &II   PTR TO INST STKS\n  GBLA  &LI   INDEX FOR LABEL NUMBER STK\n  GBLA  &NI   PTR TO NEST STK\n  GBLA  &AIND(50)  TOTAL CASES STK\n  GBLA  &CIND1(200)  CASE NUMBER STK\n  GBLA  &MULT(50)  CASE NUMBER MULTIPLIER\n  GBLA  &ST(51)   INST STK INCREASE AT EACH LEVEL\n  GBLC  &CIND2(200)  LABEL NUMBER STK FOR CASES\n  GBLC  &IIND1(100)  INSTRUCTION STK 1\n  GBLC  &IIND2(100)  INSTRUCTION STK 2\n  GBLC  &I22(100)  INSTRUCTION STK 2, 2ND PART\n  GBLC  &I23(100)  INSTRUCTION STK 2, 3RD PART\n  GBLC  &I24(100)  INSTRUCTION STK 2, 4TH PART\n  GBLC  &IIND3(100)  INSTRUCTION STK 3\n  GBLC  &I32(100)  INSTRUCTION STK 3, 2ND PART\n  GBLC  &I33(100)  INSTRUCTION STK 3, 3RD PART\n  GBLC  &I34(100)  INSTRUCTION STK 3, 4TH PART\n  GBLC  &IIND4(100)  INSTRUCTION STK 4\n  GBLC  &I42(100)  INSTRUCTION STK 4, 2ND PART\n  GBLC  &I43(100)  INSTRUCTION STK 4, 3RD PART\n  GBLC  &IIND5(100)  INSTRUCTION NAME STACK\n  GBLC  &LIND(101)  LABEL NUMBER STK\n  GBLC  &NEST(50)  NESTING STK\n  GBLC  &RIND(50)  REG STK FOR CASENTRY MACRO\n  LCLA  &I\n  LCLC  &LCLWK1\n    PUSHLAB\n    PUSHINS (EQU,*,,,,&LIND(&LI))\n&ST(&NI)   SETA    &II+1\n    PUSHLAB\n    AIF  (T'&FROM EQ 'O').NOIND\n  AIF   ('&FROM(3)' EQ '').INCR\n    LA &FROM(3),&LIND(&LI)\n.INCR  ANOP\n&I  SETA  &I+1\n  AIF   ('&SYSLIST(&I,2)' EQ '').TEST\n    AIF ('&SYSLIST(&I,2)'(1,1) EQ '(').GENLR\n      AIF ('&SYSLIST(&I,2)' EQ '0').GENSR\n        AIF ('&SYSLIST(&I,2)'(1,1) EQ '-').NEGVAL\n   AIF (T'&SYSLIST(&I,2) EQ 'N').POSVAL\n     LA  &SYSLIST(&I,1),&SYSLIST(&I,2)\n     AGO .TEST\n.POSVAL   AIF (&SYSLIST(&I,2) GE 4096).TSTMAG\n     LA  &SYSLIST(&I,1),&SYSLIST(&I,2)\n     AGO .TEST\n.TSTMAG   AIF (&SYSLIST(&I,2) GE 32768).FULLIT\n     AGO .HALFLIT\n.NEGVAL        ANOP\n&LCLWK1   SETC '&SYSLIST(&I,2)'(2,7)\n   AIF (&LCLWK1 GE 32768).FULLIT\n.HALFLIT       LHI &SYSLIST(&I,1),&SYSLIST(&I,2)\n   AGO .TEST\n.FULLIT        L &SYSLIST(&I,1),=F'&SYSLIST(&I,2)'\n   AGO .TEST\n.GENSR      SR &SYSLIST(&I,1),&SYSLIST(&I,1)\n        AGO .TEST\n.GENLR    LR &SYSLIST(&I,1),&SYSLIST(&I,2)\n.TEST  AIF   (&I LT 3).INCR\n    AIF  (T'&UNTIL NE 'O').ERRMG2\n.CKWHILE     AIF   (T'&WHILE NE 'O').COMPGEN\n&LIND(&LI) EQU  *\n.POSTIND   AIF  (T'&P1 EQ 'O').GETIND\n      AIF   (T'&BY NE 'O').PFB\n        AIF   (T'&TO NE 'O').PFT\n   AIF   ('&FROM(3)' NE '').BCTRZ\n     PUSHINS (BRCT,&FROM(1),&LIND(&LI))\n   AGO   .ERRMG\n.BCTRZ   PUSHINS (BCTR,&FROM(1),&FROM(3))\n        AGO     .ERRMG\n.PFT        PUSHINS (&P1,&FROM(1),&TO(1),&LIND(&LI))\n      MEXIT\n.PFB      PUSHINS (&P1,&FROM(1),&BY(1),&LIND(&LI))\n    MEXIT\n.GETIND    AIF  ('&FROM(3)' EQ '').BCTR1\n      PUSHINS (BCTR,&FROM(1),&FROM(3))\n    MEXIT\n.BCTR1    AIF  (T'&BY NE 'O').FB\n      AIF   (T'&TO EQ 'O').FONLY\n        PUSHINS (BXLE,&FROM(1),&TO(1),&LIND(&LI))\n      MEXIT\n.FONLY      PUSHINS (BRCT,&FROM(1),&LIND(&LI))\n    MEXIT\n.FB    AIF  (T'&TO NE 'O').FTB\n      AIF   ('&BY(2)' EQ '').GENBXLE\n      AIF   ('&BY(2)'(1,1) NE '-').GENBXLE\n    AGO  .GENBXH\n.FTB    AIF  ('&TO(2)' EQ '' OR '&FROM(2)' EQ '').GENBXLE\n      AIF   ('&FROM(2)'(1,1) EQ '(').GENBXLE\n      AIF   ('&FROM(2)'(1,1) EQ '-').TRYTNEG\n      AIF   (T'&FROM(2) NE 'N').GENBXLE\n      AIF   ('&TO(2)'(1,1) EQ '(').GENBXLE\n      AIF   ('&TO(2)'(1,1) EQ '-').GENBXH\n      AIF   (T'&TO(2) NE 'N').GENBXLE\n      AIF   (&FROM(2) GT &TO(2)).GENBXH\n.GENBXLE   PUSHINS (BXLE,&FROM(1),&BY(1),&LIND(&LI))\n    MEXIT\n.TRYTNEG   AIF  ('&TO(2)'(1,1) NE '-').GENBXLE\n    AIF  ('&FROM(2)'(2,7) GE '&TO(2)'(2,7)).GENBXLE\n.GENBXH    PUSHINS (BXH,&FROM(1),&BY(1),&LIND(&LI))\n    MEXIT\n.NOIND      AIF   (T'&WHILE EQ 'O').NOWHILE\n        AIF   (T'&UNTIL NE 'O').COMPGEN\n.* BC    15,&LIND(&LI)\n   BRC   15,&LIND(&LI)\n   PUSHLAB\n&LI   SETA &LI-1\n&LIND(&LI+1)  EQU  *\n   AIF   ('&WHILE(6)' EQ '').OKSUBL\n     STKINS &WHILE\n     MEXIT\n.OKSUBL   STKINS (&WHILE(1),&WHILE(2),&WHILE(3),&WHILE(4),      X\n        &WHILE(5),&LIND(&LI))\n   AIF   ('&WHILE(2)' EQ '').LABEL\n     PUSHINS (BRC,&CCVAL,&LIND(&LI+1))\n     MEXIT\n.LABEL   PUSHINS   (BRC,&CCVAL,&LIND(&LI+1),,,&LIND(&LI))\n   MEXIT\n.NOWHILE     AIF   (T'&UNTIL EQ 'O').TRYINF\n&LIND(&LI)   EQU   *\n.UNT        STKINS &UNTIL\n        PUSHINS (BRC,15-&CCVAL,&LIND(&LI))\n      MEXIT\n.TRYINF        AIF   ('&P1' NE 'INF').ERRMG1\n&LIND(&LI)  EQU *\n   PUSHINS (BRC,15,&LIND(&LI))\n        MEXIT\n.COMPGEN     AIF   ('&WHILE(6)' EQ '').OK\n        STKINS &WHILE\n        AGO   .BCHINST\n.OK      STKINS (&WHILE(1),&WHILE(2),&WHILE(3),&WHILE(4),        X\n        &WHILE(5),&LIND(&LI))\n      AIF   (N'&WHILE GT 1).ENDCOMP\n&LIND(&LI)     BC    15-&CCVAL,&LIND(&LI-1)\n*&LIND(&LI)     BRC   15-&CCVAL,&LIND(&LI-1)\n        AGO   .FLAGEQU\n.ENDCOMP     ANOP\n&ST(&NI+1)   SETA  &II\n      POPINS &ST(&NI+1)\n.BCHINST     BC    15-&CCVAL,&LIND(&LI-1)\n*.BCHINST     BRC   15-&CCVAL,&LIND(&LI-1)\n.FLAGEQU     ANOP\n&NEST(&NI)   SETC  '   Y'.'&NEST(&NI)'(5,4)\n      AIF   (T'&FROM NE 'O').POSTIND\n    AGO  .UNT\n.ERRMG  MNOTE 4,'POSITIONAL PARAMETER IGNORED. BCT/BCTR LOOP END USED'\n  MEXIT\n.ERRMG2  MNOTE 4,'UNTIL KEYWORD INVALID WITH INDEXING GROUP. IGNORED'\n  AGO   .CKWHILE\n.ERRMG1  MNOTE 4,'NO WHILE,UNTIL,OR INDEXING PARAMETERS ON DO MACRO.'\n  MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "ELSE": {"ttr": 281, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "  MACRO\n  ELSE\n        COPY GBLVARS\n  GBLC  &LASTIF\n  IFTEST ELSE\n&LIND(&LI+1) SETC '&LIND(&LI)'\n&LI  SETA &LI-1\n  PUSHLAB\n.*BC    15,&LIND(&LI)\n  BRC   15,&LIND(&LI)\n&LIND(&LI+1)   EQU   *\n        MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "ELSEIF": {"ttr": 514, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": " MACRO\n ELSEIF  &P1,&P2,&P3,&P4,&P5,&P6,&P7,&P8,&P9,&P10,                     /\n               &P11,&P12,&P13,&P14,&P15,&P16,&P17,&P18,&P19,&P20,      /\n               &P21,&P22,&P23,&P24,&P25,&P26,&P27,&P28,&P29,&P30,      /\n               &P31,&P32,&P33,&P34,&P35,&P36,&P37,&P38,&P39,&P40,      /\n               &P41,&P42,&P43,&P44,&P45,&P46,&P47,&P48,&P49,&P50,&CC=\n  COPY GBLVARS\n  GBLC  &LASTIF\n  IFTEST ELSEIF\n&LIND(&LI+1) SETC '&LIND(&LI)'\n&LI  SETA  &LI-1\n  PUSHLAB\n.*BC   15,&LIND(&LI-1)\n  BRC  15,&LIND(&LI-1)\n&LIND(&LI+1) EQU   *\n  IFPROC &CC,&P1,&P2,&P3,&P4,&P5,&P6,&P7,&P8,&P9,&P10,                 /\n               &P11,&P12,&P13,&P14,&P15,&P16,&P17,&P18,&P19,&P20,      /\n               &P21,&P22,&P23,&P24,&P25,&P26,&P27,&P28,&P29,&P30,      /\n               &P31,&P32,&P33,&P34,&P35,&P36,&P37,&P38,&P39,&P40,      /\n               &P41,&P42,&P43,&P44,&P45,&P46,&P47,&P48,&P49,&P50\n MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "ENDDO": {"ttr": 516, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "  MACRO\n  ENDDO\n  GBLA &ST(51),&NI,&LI,&II\n  POPINS &ST(&NI)\n&II  SETA &II-1\n  POPNEST DO\n&LI  SETA &LI-2\n  MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "ENDEVAL": {"ttr": 518, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "         MACRO\n&LAB     ENDEVAL\n.*\n.* THIS MACRO IS ONE OF A RELATED SET OF MACROS WHICH ENGINEER THE\n.* SELECTED EXECUTION OF CODE DEPENDING ON THE CONTENTS OF A FIELD.\n.*\n.* THE GENERAL STRUCTURE IS AS FOLLOWS -\n.*    EVALUATE OPCODE,OP1(,OP2.REP.TYPE.LTH)\n.*      WHEN   OP2REST,OP2REST\n.*      WHEN   OP2REST-OP2REST,OP2REST\n.*      OTHERWSE\n.*    ENDEVAL\n.*\n.* CURRENT LABEL GENERATION NUMBER FOR EACH POSSIBLE DEPTH\n         GBLA  &ON(16)\n.* CURRENT END LABEL NUMBER FOR EACH POSSIBLE DEPTH\n         GBLA  &OE(16)\n.* CURRENT DEPTH OF OPTION NESTING (1 TO 16)\n         GBLA  &OD\n.* OPTELSE INDICATOR FOR EACH POSSIBLE DEPTH\n         GBLB  &OELSE(16)\n.* OPTION INDICATOR FOR EACH POSSIBLE DEPTH\n         GBLB  &OPTN(16)\n.* OPT INDICATOR FOR EACH POSSIBLE DEPTH\n         GBLB  &OPTI(16)\n.*\n.IF0     AIF   (T'&LAB EQ 'O').END0\n&LAB     EQU   *\n.END0    ANOP\n.IF0A    AIF   (&OD NE 0).END0A\n         MNOTE 16,'UNMATCHED ENDOPT'\n         MEXIT\n.END0A   ANOP\n.IF1     AIF   (&OD LE 16).END1\n         MNOTE 16,'MAX OPTION NESTING OF 16 EXCEEDED'\n         AGO   .REDUCE\n.END1    ANOP\n.* SET OPTION INDICATOR OFF\n&OPTN(&OD) SETB (0)\n.IF3     AIF   ((&OELSE(&OD)) EQ (1)).END3\n.* WHEN NO OPTELSE CLAUSE NEED CURRENT GENERATION NUMBER LABEL\n@D&OD.N&ON(&OD) EQU   *\n.END3    ANOP\n&OELSE(&OD) SETB (0)\n&OPTI(&OD) SETB (0)\n.* SET LABEL FOR STRAIGHT END EXIT\n@D&OD.E&OE(&OD) EQU   *\n.REDUCE  ANOP\n.* REDUCE DEPTH COUNT\n&OD      SETA  &OD-1\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "ENDIF": {"ttr": 520, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "  MACRO\n  ENDIF\n        COPY GBLVARS\n  GBLC  &LASTIF\n  IFTEST ENDIF\n  POPNEST IF\n&LIND(&LI) EQU *\n&LIND(&LI-1) EQU *\n&LI  SETA &LI-2\n  MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "EVALUATE": {"ttr": 522, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "         MACRO\n&LAB     EVALUATE &OPCODE,&OPER1,&OPER2\n.*\n.* THIS MACRO IS ONE OF A RELATED SET OF MACROS WHICH ENGINEER THE\n.* SELECTED EXECUTION OF CODE DEPENDING ON THE CONTENTS OF A FIELD.\n.*\n.* THE GENERAL STRUCTURE IS AS FOLLOWS -\n.*    EVALUATE OPCODE,OP1(,OP2.REP.TYPE.LTH)\n.*      WHEN   OP2REST,OP2REST\n.*      WHEN   OP2REST-OP2REST,OP2REST\n.*      OTHERWSE\n.*    ENDEVAL\n.*\n.* OPCODE FOR EACH POSSIBLE TYPE\n         GBLC  &OP(16)\n.*\n.* COMPONENTS OF OP1 FOR EACH POSSIBLE DEPTH\n         GBLC  &OP1(16)\n.*\n.* OP2.REP.TYPE.LTH FOR EACH POSSIBLE DEPTH\n         GBLC  &OP2(16)\n.*\n.* CURRENT LABEL GENERATION NUMBER FOR EACH POSSIBLE DEPTH\n         GBLA  &ON(16)\n.*\n.* CURRENT END LABEL NUMBER FOR EACH POSSIBLE DEPTH\n         GBLA  &OE(16)\n.*\n.* CURRENT DEPTH OF OPTION NESTING (1 TO 16)\n         GBLA  &OD\n.*\n.* IMMEDIATE INDICATOR FOR EACH POSSIBLE DEPTH\n         GBLB  &OI(16)\n.*\n.* QUOTES INDICATOR FOR EACH POSSIBLE DEPTH\n         GBLB  &OQ(16)\n.*\n.* OPTION INDICATOR FOR EACH POSSIBLE DEPTH\n         GBLB  &OPTN(16)\n.*\n.* STATUS INDICATOR FOR EACH POSSIBLE DEPTH\n         GBLB  &OS(16)\n.*\n.* LOCAL WORK FIELDS\n         LCLA  &A\n         LCLC  &C1,&C2,&C3,&C4,&C5,&C6,&C7,&C8\n.*\n.IF0     AIF   (T'&LAB EQ 'O').END0\n&LAB     EQU   *\n.END0    ANOP\n.IF0A    AIF   (&OD EQ 0).END0A\n.IF0B    AIF   ((&OPTN(&OD)) EQ (0)).END0B\n         MNOTE 16,'DUPLICATE OPTION'\n&OS(&OD) SETB  (1)\n         MEXIT\n.END0B   ANOP\n.END0A   ANOP\n.* INCREMENT COUNT OF DEPTH OF NESTING\n&OD      SETA  &OD+1\n.IF1     AIF   (&OD LE 16).END1\n         MNOTE 16,'MAX OPTION NESTING OF 16 EXCEEDED'\n         MEXIT\n.END1    ANOP\n.* SET OPTION INDICATOR FOR THIS DEPTH (1= OPTION MACRO LAST MET)\n&OPTN(&OD) SETB (1)\n.* ZEROISE STATUS INDICATOR FOR THIS DEPTH (1= OPTION STATEMENT ERROR)\n&OS(&OD) SETB  (0)\n.* ZEROISE IMMEDIATE INDICATOR FOR THIS DEPTH (1= CLI OPCODE)\n&OI(&OD) SETB  (0)\n.* ZEROISE QUOTES INDICATOR FOR THIS DEPTH (1= QUOTES EXPECTED)\n&OQ(&OD) SETB  (0)\n.* INCREMENT LABEL GENERATION NUMBER FOR THIS DEPTH\n&ON(&OD) SETA  &ON(&OD)+1\n.* SAVE LABEL GENERATION NUMBER FOR END LABEL FOR THIS DEPTH\n&OE(&OD) SETA  &ON(&OD)\n.* INCREMENT LABEL GENERATION NUMBER FOR THIS DEPTH\n&ON(&OD) SETA  &ON(&OD)+1\n.IF2A    AIF  (K'&OPCODE GT 0).END2A\n         MNOTE 16,'NO OPCODE SPECIFIED'\n&OS(&OD) SETB  (1)\n         AGO   .MEND\n.END2A   ANOP\n.OKOLTH  AIF   ('&OPCODE'(1,1) EQ 'C').OKC\n         MNOTE 16,'INVALID OPCODE'\n&OS(&OD) SETB  (1)\n         AGO   .MEND\n.OKC     AIF   ('&OPCODE' NE 'CLI').END2AA\n&OI(&OD) SETB  (1)\n.END2AA  ANOP\n&OP(&OD) SETC  '&OPCODE'\n.IF2B    AIF   (T'&OPER1 NE 'O').END2B\n         MNOTE 16,'NO FIRST OPERAND SPECIFIED'\n&OS(&OD) SETB  (1)\n         AGO   .MEND\n.END2B   ANOP\n&OP1(&OD) SETC '&OPER1'\n.IF3     AIF   (T'&OPER2 NE 'O').ELS3\n&OQ(&OD) SETB  (0)\n&OP2(&OD) SETC ''\n         AGO   .END3\n.ELS3    ANOP\n.IF3A    AIF   (K'&OPER2 LE 8).END3A\n         MNOTE 16,'THIRD PARAMETER OVERLONG'\n&OS(&OD) SETB  (1)\n         AGO   .MEND\n.END3A   ANOP\n         AIF   ('&OPER2'(1,1) NE '=').TRYI\n         AIF   ((&OI(&OD)) EQ (0)).TRYSOLO\n         MNOTE 16,'ILLEGAL IMMEDIATE OPERAND'\n&OS(&OD) SETB  (1)\n         AGO   .MEND\n.TRYSOLO AIF   (K'&OPER2 NE 1).OKOP2\n&OQ(&OD) SETB  (0)\n&OP2(&OD) SETC '&OPER2'\n         AGO   .END3\n.TRYI    AIF   ((&OI(&OD)) EQ (1)).OKOP2\n         MNOTE 16,'ILLEGAL LITERAL'\n&OS(&OD) SETB  (1)\n         AGO   .MEND\n.OKOP2   ANOP\n&OQ(&OD) SETB  (1)\n&OP2(&OD) SETC '&OPER2'\n.END3    ANOP\n.MEND    ANOP\n         BRU   @D&OD.N&ON(&OD)\n         MEXIT\n.*\n.*  EXAMPLES OF USING EVALUATE\n.*\n.*  EVALUATE\n.*\n.*  EVALUATE is used to select which of several pieces of code is to\n.*  be executed when that selection depends upon the value of a\n.*  particular field.  In such cases, EVALUATE is more elegant, more\n.*  readable, and more logical than the overused ELSEIF.\n.*  The general format is:\n.*\n.*               EVALUATE opcode,op1(,op2)\n.*                 WHEN op2value\n.*                   code\n.*                 WHEN op2value1-op2value2\n.*                   code\n.*                 WHEN op2value1-op2value2,op2value\n.*                   code\n.*                 OTHERWSE\n.*                   code\n.*               ENDOPT\n.*\n.*  where: 'opcode' is one of - CLC, CLI, CP, CH, C, CLR, CL, CR;\n.*         'op1' is the address of the determinant field;\n.*         'op2' is the constant type and length (if this is common\n.*               to all the WHEN values).\n.*\n.*  The EVALUATE macro declares the type of comparison to be done on\n.*  the determinant field.  It is followed by a series of WHEN clauses,\n.*  each of which specifies a list of values and/or ranges, and heads\n.*  the lines of code to be executed if that WHEN is selected. Only\n.*  one WHEN clause, the first to satisfy the test, will be executed.\n.*  OPTELSE, if coded, should follow the final WHEN (and will often\n.*  head a 'value not found' error procedure).  The OTHERWSE code will\n.*  be executed if none of the WHEN values matches the determinant;\n.*  if there is no match and no OTHERWSE clause, processing continues\n.*  normally, without any of the WHEN clauses having been executed.\n.*  ENDOPT terminates the EVALUATE block.\n.*\n.*  Processing will be most efficient when the WHEN clauses are written\n.*  in order of decreasing probability of selection, and when the\n.*  values within each WHEN are in order of decreasing probability of\n.*  occurrence.\n.*  EVALUATE blocks can be nested to a maximum depth of 16.\n.*  No registers are corrupted by OPTION.\n.*\n.*  The following examples illustrate OPTION's commoner modes of use.\n.*\n.*  1.  EVALUATE CP,COUNT,=P\n.*        WHEN '1'\n.*          code\n.*        WHEN '2'\n.*          code\n.*        WHEN '3','4','5'\n.*          code\n.*        WHEN '6'-'99'\n.*          code\n.*        OTHERWSE\n.*          code\n.*      ENDOPT\n.*\n.*  2.  EVALUATE CP,TAX(3)\n.*        WHEN =P'0'\n.*          code\n.*        WHEN =P'1',=P'1000'\n.*          code\n.*        WHEN PFLDA(3)-PFLDB(5),0(5,R6)\n.*          code\n.*        WHEN PHIGH\n.*          code\n.*      ENDOPT\n.*\n.*  3.  EVALUATE CLI,BDETCRR3,C\n.*        WHEN 'A'\n.*          ZAP ACUSELDS,=P'-5'\n.*        WHEN 'B'\n.*          ZAP ACUSELDS,=P'-4'\n.*        WHEN 'D'\n.*          ZAP ACUSELDS,=P'-2'\n.*        WHEN 'E'\n.*          ZAP ACUSELDS,=P'-1'\n.*        OTHERWSE\n.*          PERFORM ERRSCORE\n.*      ENDOPT\n.*\n.*  4.  EVALUATE CLI,BDETDKCN,X           SELECT BY COMPANY\n.*        WHEN '53'                       COUNTRY GARDEN\n.*          PERFORM CGPOST\n.*        WHEN '26'                       SHOWCASE\n.*          MVI OSNOPPCH,C'0'             NOT YET CHARGED\n.*          ZAP OSNOPANP,=P'150'          POST AND PACK CHARGE\n.*        WHEN '63'                       SHOPPING SENSE\n.*          MVI OSNOPPCH,C'0'             NOT YET CHARGED\n.*          ZAP OSNOPANP,=P'195'          POST AND PACK CHARGE\n.*        OTHERWSE\n.*          IF (CLC,CUSTNO(3),E,=C'184')  BARGAIN BASEMENT\n.*            MVI OSNOPPCH,C'0'           NOT YET CHARGED\n.*            ZAP OSNOPANP,=P'200'        POST AND PACK CHARGE\n.*          ELSE\n.*            IF (CLC,CUSTNO(3),E,=C'183')  NEW HORIZONS\n.*              PERFORM NHPOST\n.*            ENDIF\n.*          ENDIF\n.*      ENDOPT\n.*\n.*  5.  EVALUATE CH,R2,=H\n.*        WHEN '0'\n.*          PERFORM READPBDF\n.*        WHEN '4'\n.*          L R5,0(R1)\n.*          ST R5,PARMADDR\n.*          .\n.*          .\n.*          .\n.*        WHEN '12'\n.*          IF (CLI,FIRSTSW,E,C'Y')\n.*            MVI FIRSTSW,C'N'\n.*          ENDIF\n.*          PERFORM READPBCF\n.*      ENDOPT\n.*\n.*  6.  EVALUATE CLC,ACUSCLUS,=CL2\n.*        WHEN '04','13','14','27'\n.*          MVC C200PRCI,=C'20'\n.*        WHEN '19','24'-'26'\n.*          MVC C200PRCI,=C'30'\n.*        WHEN '10','11','16'-'18','22','29'\n.*          MVC C200PRCI,=C'40'\n.*        WHEN '01','03','07','08','12'\n.*          MVC C200PRCI,=C'50'\n.*        WHEN '05','06','09','15','20','21','23','28','30'\n.*          MVC C200PRCI,=C'60'\n.*        OTHERWSE\n.*          MVC C200PRCI,=C'70'\n.*      ENDOPT\n.*\n.*  In the above example, since the implicit length of ACUSCLUS is\n.*  two bytes, 'OPTION CLC,ACUSCLUS,=C' could have been coded;\n.*  or even 'OPTION CLC,ACUSCLUS' with 'OPT =C'04',=C'13'...'.\n.*\n.*  7.  EVALUATE C,R2\n.*        WHEN =F'0',0(R3)\n.*          code\n.*        WHEN 4(R3)-8(R3)\n.*          code\n.*        WHEN FWORD1-FWORD2\n.*          code\n.*        WHEN =F'4000'-FWORD3\n.*          code\n.*        WHEN =4X'FF'\n.*          code\n.*      ENDOPT\n.*\n.*  8.  EVALUATE CR,R2\n.*        WHEN R6-R7,R8\n.*          code\n.*        WHEN R9\n.*          code\n.*      ENDOPT\n.*\n         MEND\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "GBLVARS": {"ttr": 524, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "   GBLA &CCVAL        COND CODE VARIABLE\n   GBLA &CTR        MACRO PARAMETER COUNTER\n   GBLA &SEQ        LABEL NUMBER GENERATOR\n   GBLA &AI        INDEX FOR TOTAL NO. CASES STK\n   GBLA &CI        INDEX FOR CASE AND LBL NO. STKS\n   GBLA &II        PTR TO INST STKS\n   GBLA &LI        INDEX FOR LABEL NUMBER STK\n   GBLA &NI        PTR TO NEXT STK\n   GBLA &AIND(50)       TOTAL CASES STK\n   GBLA &CIND1(200)       CASE NUMBER STK\n   GBLA &MULT(50)       CASE NUMBER MULTIPLIER\n   GBLA &ST(51)        INST STK INCREASE AT EACH LEVEL\n   GBLC &CIND2(200)       LABEL NUMBER STK FOR CASES\n   GBLC &IIND1(100)       INSTRUCTION STK 1\n   GBLC &IIND2(100)       INSTRUCTION STK 2\n   GBLC &I22(100)       INSTRUCTION STK 2,2ND PART\n   GBLC &I23(100)       INSTRUCTION STK 2,3RD PART\n   GBLC &I24(100)       INSTRUCTION STK 2,4TH PART\n   GBLC &IIND3(100)       INSTRUCTION STK 3\n   GBLC &I32(100)       INSTRUCTION STK 3,2ND PART\n   GBLC &I33(100)       INSTRUCTION STK 3,3RD PART\n   GBLC &I34(100)       INSTRUCTION STK 3,4TH PART\n   GBLC &IIND4(100)       INSTRUCTION STK 4\n   GBLC &I42(100)       INSTRUCTION STK 4,2ND PART\n   GBLC &I43(100)       INSTRUCTION STK 4,3RD PART\n   GBLC &IIND5(100)       INSTRUCTION NAME STACK\n   GBLC &LIND(101)       LABEL NUMBER STK\n   GBLC &NEST(50)       NESTING STK\n   GBLC &RIND(50)       REG STK FOR CASENTRY MACRO\n   GBLC &SEGNAME       SEGMENT NAME\n   GBLC &SEGSTRT       SEGMENT START\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "GETCC": {"ttr": 526, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "  MACRO\n  GETCC &COND\n  GBLA  &CCVAL\n  LCLC  &LWK1\n  AIF   ('&COND'(1,1) LT '0' OR '&COND'(1,1) GT '9').NOTNUM\n&CCVAL    SETA  &COND\n    MEXIT\n.NOTNUM  AIF   (K'&COND NE 1).TWOCHAR\n&LWK1    SETC  '&COND'\n    AGO  .CALCC\n.TWOCHAR AIF   (K'&COND NE 2).INVCOND\n    AIF  ('&COND'(1,1) NE 'N').OTHERMN\n&LWK1      SETC  '&COND'(2,1)\n    AGO  .CALCC\n.OTHERMN   AIF  ('&COND' EQ 'EQ').BC8\n    AIF  ('&COND' EQ 'LT').BC4\n    AIF  ('&COND' NE 'LE').TRYGT\n&CCVAL      SETA  13\n    MEXIT\n.TRYGT    AIF  ('&COND' EQ 'GT').BC2\n    AIF  ('&COND' NE 'GE').INVCOND\n&CCVAL      SETA  11\n    MEXIT\n.CALCC  AIF   ('&LWK1' NE 'O').TRYH\n&CCVAL    SETA 1\n  AGO   .TSTN\n.TRYH  AIF   ('&LWK1' EQ 'P' OR '&LWK1' EQ 'H').BC2\n    AIF ('&LWK1' EQ 'L' OR '&LWK1' EQ 'M').BC4\n      AIF ('&LWK1' EQ 'E' OR '&LWK1' EQ 'Z').BC8\n        AGO   .INVCOND\n.BC8      ANOP\n&CCVAL      SETA 8\n      AGO   .TSTN\n.BC4    ANOP\n&CCVAL    SETA 4\n    AGO  .TSTN\n.BC2  ANOP\n&CCVAL  SETA  2\n.TSTN  AIF   ('&COND'(1,1) NE 'N').DONE\n&CCVAL      SETA  15-&CCVAL\n.DONE  MEXIT\n.INVCOND ANOP\n&CCVAL  SETA  15\n  MNOTE 4,'INVALID CONDITION MNEMONIC. NOP GENERATED'\n  MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "HEXPACK": {"ttr": 528, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "         MACRO\n         HEXPACK &IN,&INL,&OUT\n.**********************************************************************\n.*\n.* September 2015 - John Gateley - Create\n.*\n.*       This macro packs character hexadecimal data into a string.\n.*       so C'C1F16D' becomes X'C1F16D' or C'A1_'\n.*\n.*       In the above example\n.*       HEXPACK =C'C1F16D',6,OUT_TXT\n.*\n.*       If the input length is of the form L'AAA then it cannot be\n.*       checked here, but if it is not then see if even.\n.*\n.*\n.* indicate that HEXPACK macro was used so that the table can be\n.* defined in PRGESTAT\n.*\n         GBLC  &HEXPCK\n&HEXPCK  SETC  'Y'\n         AIF   ('&INL'(1,2) EQ 'L''').NOCHK\n&A       SETA  &INL                      * copy length\n&B       SETA  &A/2                      * divide by 2\n&C       SETA  &B*2                      * multiply by 2\n         AIF   (&A NE &C).NOTEVEN        * not equal means not even\n.*\n.NOCHK   ANOP\n         LA    R14,&IN                   * address of input string\n         LA    R15,&INL                  * length of input string\n         LA    R1,&OUT                   * address of output area\nB#&SYSNDX      DS    0H\n         MVC   HEXPACK_W3(2),0(R14)      * copy two bytes\n         TR    HEXPACK_W3(2),HEXPACK_TABLE-C'A' * Convert to packable\n         PACK  HEXPACK_W2,HEXPACK_W3     * pack it\n         MVC   0(1,R1),HEXPACK_W2        * output one byte\n         LA    R14,2(R14)                * next in input\n         LA    R1,1(R1)                  * next in output\n         AHI   R15,-2                    * subtract the 2 processed\n         BP    B#&SYSNDX                 * positive then go again\n         MEXIT\n.NOTEVEN MNOTE 16,'Length specified is not multiple of 2'\n         MEND\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "HEXUNPK": {"ttr": 530, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "         MACRO\n         HEXUNPK &IN,&INL,&OUT\n.**********************************************************************\n.*\n.* September 2015 - John Gateley - Create\n.*\n.*       This macro unpacks character data into hexadecimal format.\n.*       so X'C1F16D' or C'A1_' becomes C'C1F16D'\n.*\n.*       In the above example\n.*       HEXUNPK =X'C1F16D',3,OUT_TXT\n.*\n.* indicate that HEXUNPK macro was used so that the table can be\n.* defined in PRGESTAT\n.*\n         GBLC  &XUNPCK\n&XUNPCK  SETC  'Y'\n.*\n         LA    R14,&IN                   * address of input string\n         LA    R15,&INL                  * length of input string\n         LA    R1,&OUT                   * address of output area\nB#&SYSNDX      DS    0H\n         MVC   HEXPACK_W2(1),0(R14)      * copy one byte\n         UNPK  HEXPACK_W3,HEXPACK_W2     * UNPK two bytes to three\n         TR    HEXPACK_W3(2),XUNPACK_TAB-240 * convert to displayable\n         MVC   0(2,R1),HEXPACK_W3        * copy to receiver\n         LA    R14,1(,R14)               * next in input\n         LA    R1,2(,R1)                 * next in output\n         BCT   R15,B#&SYSNDX             * subtract and branch\n         MEND\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "IF": {"ttr": 532, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "      MACRO\n      IF &P1,&P2,&P3,&P4,&P5,&P6,&P7,&P8,&P9,&P10,                     /\n               &P11,&P12,&P13,&P14,&P15,&P16,&P17,&P18,&P19,&P20,      /\n               &P21,&P22,&P23,&P24,&P25,&P26,&P27,&P28,&P29,&P30,      /\n               &P31,&P32,&P33,&P34,&P35,&P36,&P37,&P38,&P39,&P40,      /\n               &P41,&P42,&P43,&P44,&P45,&P46,&P47,&P48,&P49,&P50,&CC=\n      COPY  GBLVARS\n      GBLC  &LASTIF\n      IFTEST IF\n      PUSHNEST IF\n      PUSHLAB\n      PUSHLAB\n      IFPROC &CC,&P1,&P2,&P3,&P4,&P5,&P6,&P7,&P8,&P9,&P10,             /\n               &P11,&P12,&P13,&P14,&P15,&P16,&P17,&P18,&P19,&P20,      /\n               &P21,&P22,&P23,&P24,&P25,&P26,&P27,&P28,&P29,&P30,      /\n               &P31,&P32,&P33,&P34,&P35,&P36,&P37,&P38,&P39,&P40,      /\n               &P41,&P42,&P43,&P44,&P45,&P46,&P47,&P48,&P49,&P50\n      MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "IFPROC": {"ttr": 769, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "    MACRO\n    IFPROC\n  GBLA  &CCVAL   COND CODE VARIABLE\n  GBLA  &CTR   MACRO PARAMETER COUNTER\n  GBLA  &SEQ   LABEL NUMBER GENERATOR\n  GBLA  &AI   INDEX FOR TOTAL NO. CASES STK\n  GBLA  &CI   INDEX FOR CASE AND LBL NO. STKS\n  GBLA  &II   PTR TO INST STKS\n  GBLA  &LI   INDEX FOR LABEL NUMBER STK\n  GBLA  &NI   PTR TO NEST STK\n  GBLA  &AIND(50)  TOTAL CASES STK\n  GBLA  &CIND1(200)  CASE NUMBER STK\n  GBLA  &MULT(50)  CASE NUMBER MULTIPLIER\n  GBLA  &ST(51)   INST STK INCREASE AT EACH LEVEL\n  GBLC  &CIND2(200)  LABEL NUMBER STK FOR CASES\n  GBLC  &IIND1(100)  INSTRUCTION STK 1\n  GBLC  &IIND2(100)  INSTRUCTION STK 2\n  GBLC  &I22(100)  INSTRUCTION STK 2, 2ND PART\n  GBLC  &I23(100)  INSTRUCTION STK 2, 3RD PART\n  GBLC  &I24(100)  INSTRUCTION STK 2, 4TH PART\n  GBLC  &IIND3(100)  INSTRUCTION STK 3\n  GBLC  &I32(100)  INSTRUCTION STK 3, 2ND PART\n  GBLC  &I33(100)  INSTRUCTION STK 3, 3RD PART\n  GBLC  &I34(100)  INSTRUCTION STK 3, 4TH PART\n  GBLC  &IIND4(100)  INSTRUCTION STK 4\n  GBLC  &I42(100)  INSTRUCTION STK 4, 2ND PART\n  GBLC  &I43(100)  INSTRUCTION STK 4, 3RD PART\n  GBLC  &IIND5(100)  INSTRUCTION NAME STACK\n  GBLC  &LIND(101)  LABEL NUMBER STK\n  GBLC  &NEST(50)  NESTING STK\n  GBLC  &RIND(50)  REG STK FOR CASENTRY MACRO\n    LCLB &ANDIND,&ORIND\n    PUSHLAB\n&CTR    SETA 2\n&ST(&NI+1) SETA &II+1\n&NEST(&NI) SETC '  R'.'&NEST(&NI)'(4,5)\n    AIF (T'&SYSLIST(1) EQ 'O').LOOP\n    AIF (&SYSLIST(1) LE 0 OR &SYSLIST(1) GE 15).INVALCC\n&CCVAL      SETA &SYSLIST(1)\n      AIF ('&SYSLIST(2)' EQ '').ENDBOOL\n  MNOTE 4,'CC KEYWORD USED. OTHER PARAMETERS IGNORED'\n  AGO .ENDBOOL\n.INVALCC MNOTE 4,'CC OUTSIDE VALID RANGE OF 1 TO 14. NOP GENERATED'\n&CCVAL  SETA  15\n    AGO .ENDBOOL\n.LOOP    STKINS &SYSLIST(&CTR),&SYSLIST(&CTR+1),&SYSLIST(&CTR+2),      /\n               &SYSLIST(&CTR+3),&SYSLIST(&CTR+4)\n    AIF ('&SYSLIST(&CTR+1)' EQ 'AND').ANDPROC\n    AIF ('&SYSLIST(&CTR+1)' NE 'ANDIF').TESTOR\n.ANDPROC     PUSHINS (BRC,15-&CCVAL,&LIND(&LI-1))\n&ANDIND      SETB 1\n      AIF ('&SYSLIST(&CTR+1)' NE 'ANDIF' OR NOT &ORIND).TESTLP\n        POPINS &ST(&NI+1)\n&LIND(&LI)     EQU *\n&ORIND        SETB 0\n&LI        SETA &LI-1\n        PUSHLAB\n      AGO .TESTLP\n.TESTOR    AIF ('&SYSLIST(&CTR+1)' EQ 'OR').ORPROC\n    AIF ('&SYSLIST(&CTR+1)' NE 'ORIF').TESTLP\n.ORPROC      PUSHINS (BRC,&CCVAL,&LIND(&LI))\n&ORIND      SETB 1\n      AIF ('&SYSLIST(&CTR+1)' NE 'ORIF' OR NOT &ANDIND).TESTLP\n        PUSHINS (EQU,*,,,,&LIND(&LI-1))\n&ANDIND        SETB 0\n        PUSHLAB\n&LI        SETA &LI-1\n&LIND(&LI-1)   SETC '&LIND(&LI+1)'\n.TESTLP    ANOP\n&CTR    SETA &CTR+2\n    AIF ('&SYSLIST(&CTR-1)' NE '').LOOP\n.ENDBOOL     AIF ('&NEST(&NI)'(5,4) EQ 'DO').DOEND\n      POPINS &ST(&NI+1)\n.*    BC   15-&CCVAL,&LIND(&LI-1)\n      BRC  15-&CCVAL,&LIND(&LI-1)\n      AIF (NOT &ORIND).POPLBL\n&LIND(&LI)     EQU *\n.POPLBL      ANOP\n&LI      SETA &LI-1\n    MEXIT\n.DOEND    ANOP\n&CTR    SETA  &ST(&NI+1)\n    AGO  .ENDLBL\n.NXTLBL    AIF  ('&IIND3(&CTR)' NE '&LIND(&LI)').INCTR\n&IIND3(&CTR) SETC  '&LIND(&LI-3)'\n.INCTR    ANOP\n&CTR    SETA  &CTR+1\n.ENDLBL    AIF  (&CTR LE &II).NXTLBL\n    POPINS &ST(&NI+1)\n.*  BC   &CCVAL,&LIND(&LI-3)\n    BRC  &CCVAL,&LIND(&LI-3)\n    AIF  (NOT &ANDIND).POP2LBL\n&LIND(&LI-1) EQU  *\n.POP2LBL   ANOP\n&LI    SETA   &LI-2\n&NEST(&NI) SETC  '   Y'.'&NEST(&NI)'(5,4)\n    MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "IFTEST": {"ttr": 771, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "  MACRO\n  IFTEST &THISIF\n  GBLC  &LASTIF\n  COPY  GBLVARS\n.*\n.*   THIS MACRO ENSURES THAT THE 'IF' MACROS HAVE BEEN CODED\n.*   IN A SYNTACTICALLY CORRECT SEQUENCE.\n.*\n  AIF   ('&LASTIF' EQ '').OK\n  AIF   ('&LASTIF' EQ 'ENDIF').OK\n  AIF   ('&THISIF' EQ 'ENDIF').OK\n  AIF   ('&THISIF' EQ 'IF').OK\n  AIF   ('&THISIF' EQ 'ELSEIF' AND '&LASTIF' EQ 'ELSEIF').OK\n  AIF   ('&THISIF' EQ 'ELSEIF' AND '&LASTIF' EQ 'IF').OK\n  AIF   ('&THISIF' EQ 'ELSE' AND '&LASTIF' EQ 'ELSEIF').OK\n  AIF   ('&THISIF' EQ 'ELSE' AND '&LASTIF' EQ 'IF').OK\n MNOTE 8,'ERROR - ''&THISIF'' MACRO INVALID AFTER ''&LASTIF''.'\n  MEXIT\n.*\n.OK  ANOP\n&LASTIF  SETC  '&THISIF'\n  MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "JRGTIOT": {"ttr": 773, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x01\\x01\\x17\\x14\\x7f\\x01\\x17\\x14\\x7f\\x15V\\x00\\xcb\\x00\\xcb\\x00\\x00\\xe2\\xc4\\xd1\\xd9\\xc7@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2017-05-27T00:00:00", "modifydate": "2017-05-27T15:56:01", "lines": 203, "newlines": 203, "modlines": 0, "user": "SDJRG"}, "text": "* % GOTO TIOTBSL;   /*\n*\n*  THIS IS A COPY OF THE PUBLIC DOMAIN MVT MACRO WHICH HAS\n*  BEEN AMENDED TO MAKE THE 2 DSECTS EXPLICIT AND THEREFORE\n*  EASIER TO USE.\n*\n         MACRO\n         JRGTIOT\n*\n*    RELEASE 20, 3/04/71, LEVEL=1\n*    RELEASE 21, 3/05/71, LEVEL=1\n*\nTIOT1    DSECT\nTIOCNJOB DS    CL8  -       JOBNAME\nTIOCSTEP DS    CL16 -       STEPNAME\n***********************************************************************\n**             **\n*   DD ENTRY:             *\n*              *\n* A DD ENTRY INCLUDES A DEVICE ENTRY. BEFORE ALLOCATION, THERE  *\n* MAY BE SEVERAL DEVICE ENTRIES IN EACH DD ENTRY.        *\n**             **\n***********************************************************************\nTIOENTRY EQU   *\nTIOENTRYD DSECT\nTIOELNGH DS    FL1 -        LENGTH OF THIS ENTRY\nTIOESTTA DS    B -        STATUS -A-\nTIOSLTYP EQU   X'80' -        NONSTANDARD LABEL (NOTE 1)\nTIOSPLTP EQU   X'40' -        SPLIT CYLINDER PRIMARY\nTIOSPLTS EQU   X'20' -        SPLIT CYLINDER SECONDARY\nTIOSJBLB EQU   X'10' -        JOBLIB INDICATOR\nTIOSDADS EQU   X'08' -        DADSM ALLOCATION NECESSRY\nTIOSLABL EQU   X'04' -        LABELED/UNLABELED (NOTE 1)\nTIOSDSP1 EQU   X'02' -        DISPOSITION BIT 1\nTIOSDSP2 EQU   X'01' -        DISPOSITION BIT 2\n*\n*   NOTE 1 - IF BOTH BITS TIOSLTYP AND TIOSLABL ARE ON, THE VOLUME\n*      IS A TAPE AND HAS AN 'ANSI' LABEL.\n*\nTIOERLOC DS    0CL2 -        REL. LOC OF POOL\nTIOEWTCT DS    CL1 -        COUNT OF NUMBER OF DEVICES\n*        DURING ALLOCATION STILL ELIGIBLE TO DADSM ALLOCATE\n*        THIS DATA SETS REQUEST\nTIOELINK DS    CL1 -        DURING ALLOCATION OF ALL\n*        BUT POOLS THIS WILL BE A LINK TO THE APPROPRIATE PRIME\n*        SPLIT,UNIT AFFIM,VOL AFFIN OR SUBALLOCATE\n  SPACE 1\n* FOLLOWING BIT MASKS APPLY TO THE 'TIOELINK' FIELD\n  SPACE 1\nTIOSYOUT EQU   X'80' - SYSOUT DATA SET THAT CONTAINS DATA\nTIOTOPEN EQU   X'40' - DATA SET IS OPEN\nTIOTTERM EQU   X'20' - THIS IS A TERMINAL\nTIOEDYNM EQU   X'10' - 'DYNAM' KEYWORD USED\nTIOEQNAM EQU   X'08' - 'QNAME' KEYWORD USED\nTIOESYIN EQU   X'04' -  SYSIN\nTIOESYOT EQU   X'02' -  SYSOUT\nTIOESSDS EQU   X'02' -        ENTRY FOR A SUBSYSTEM DATA SET*\n*\nTIOEDDNM DS    CL8 -        DDNAME\nTIOEJFCB DS    CL3 -        JFCB DISK ADDR\nTIOESTTC DS    B -        STATUS -C-\nTIOSDKCR EQU   X'80' -        CORE/DISK ADDRESS\nTIOSDEFR EQU   X'40' -        DEFERRED MOUNT\nTIOSAFFP EQU   X'20' -        UNIT AFFINITY PRIMARY\nTIOSAFFS EQU   X'10' -        UNIT AFFINITY SECONDARY\nTIOSVOLP EQU   X'08' -        VOLUME AFFINITY PRIMARY\nTIOSVOLS EQU   X'04' -        VOLUME AFFINITY SECONDARY\nTIOSBALP EQU   X'02' -        SUBALLOCATE PRIMARY\nTIOSBALS EQU   X'01' -        SUBALLOCATE SECONDARY\n***********************************************************************\n**             **\n*   DEVICE ENTRIES:            *\n*              *\n*      1. DURING ALLOCATION:           *\n*   ONE DEVICE ENTRY FOR EACH DEVICE REQUIRED, OR FOR    *\n*   EACH PUBLIC DEVICE ELIGIBLE.         *\n*              *\n*      2. DURING PROBLEM PROGRAM:          *\n*   ONE DEVICE ENTRY FOR EACH ALLOCATED DEVICE       *\n*              *\n***********************************************************************\nTIOESTTB DS    B -        STATUS -B-\nTIOSUSED EQU   X'80' -        DATA SET IS ON DEVICE\nTIOSREQD EQU   X'40' -        DATA SET WILL USE DEVICE\nTIOSPVIO EQU   X'20' -        DEVICE VIOLATES SEPARATION\nTIOSVLSR EQU   X'10' -        VOLUME SERIAL PRESENT\nTIOSSETU EQU   X'08' -        SETUP MESSAGE REQUIRED\nTIOSMNTD EQU   X'04' -        MOUNTED\nTIOSUNLD EQU   X'02' -        UNLOAD REQUIRED\nTIOSVERF EQU   X'01' -        VERIFICATION REQUIRED\nTIOEFSRT DS    AL3 -        SRT POINTER\n*  TIOT POOL ENTRY\nPOOLSTAR EQU   *\n  DS    CL1 -\nTIOPNSLT DS    FL1 -        NR.OF SLOTS FOR POOL\n  DS    CL1 -\nTIOPNSRT DS    FL1 -        NR.OF DEVICES (FILLED\n*           SLOTS)\nTIOPPOOL DS    CL8 -        POOL NAME\nTIOPSTTB DS    XL1 -        STATUS OF SLOT\nTIOPSLOT DS    AL3 -        SRT ADDRESS OR EMPTY SLOT\nTIOTFEND DS    CL4 -        FINAL END OF AN ENTRY\n*           OR THE TIOT\n  MEND\n* */ %TIOTBSL:;\n*\n* /* RELEASE 20, 3/04/71, LEVEL=1         */\n* /* RELEASE 21, 3/05/71, LEVEL=1         */\n*\n* DECLARE\n* 1 TIOT1 BASED(TIOTPTR) BDY(WORD),\n*     5 TIOCNJOB CHAR(8),  /*  JOB NAME       */\n*     5 TIOCSTEP CHAR(16);  /*  STEP NAME       */\n*/********************************************************************/\n*/*             */\n*/* DD ENTRY:            */\n*/*             */\n*/* A DD ENTRY INCLUDES A DEVICE ENTRY. BEFORE ALLOCATION, THERE */\n*/* MAY BE SEVERAL DEVICE ENTRIES IN EACH DD ENTRY.       */\n*/*             */\n*/********************************************************************/\n*%IF TIOENPTR=''  %THEN\n*%TIOENPTR='ADDR(TIOT1)+24';\n* DECLARE\n*     1 TIOENTRY   BASED(TIOENPTR),\n*    10 TIOELNGH PTR(8),  /* LENGTH OF THIS ENTRY      */\n*    10 TIOESTTA BIT(8),  /* STATUS -A-       */\n*      11 TIOSLTYP BIT(1), /* NONSTANDARD LABEL (NOTE 1)*/\n*      11 TIOSPLTP BIT(1), /* SPLIT CYLINDER PRIMARY    */\n*      11 TIOSPLTS BIT(1), /* SPLIT CYLINDER SECONDARY  */\n*      11 TIOSJBLB BIT(1), /* JOBLIB INDICATOR      */\n*      11 TIOSDADS BIT(1), /* DADSM ALLOCATION NECESSARY*/\n*      11 TIOSLABL BIT(1), /* LABELED/UNLABELED (NOTE 1)*/\n*      11 TIOSDSP1 BIT(1), /* DISPOSITION BIT 1      */\n*      11 TIOSDSP2 BIT(1), /* DISPOSITION BIT 2      */\n*/*   NOTE 1 - IF BOTH BITS TIOSLTYP AND TIOSLABL ARE ON, THE VOLUME */\n*/*        IS A TAPE AND HAS AN 'ANSI' LABEL.       */\n*    10 TIOERLOC CHAR(2),  /* REL. LOC OF POOL      */\n*    15 TIOEWTCT CHAR(1), /* COUNT OF NUMBER OF DEVICES\n*        DURING ALLOCATION STILL\n*        ELIGIBLE TO DADSM ALLOCATE\n*        THIS DATA SET REQUEST     */\n*    15 TIOELINK CHAR(1), /* DURING ALLOCATION OF\n*        ALL BUT POOLS THIS WILL BE\n*        A LINK TO THE APPROPRIATE\n*        PRIME SPLIT,UNIT AFFIN\n*        VOL.,AFFIN OR SUBALLOCATE */\n*/* FOLLOWING BIT MASKS APPLY TO 'TIOELINK' FIELD */\n*       17 TIOSYOUT BIT(1), /* SYSOUT D.S.THAT HAS DATA */\n*       17 TIOTOPEN BIT(1), /* DATA SET IS OPEN      */\n*       17 TIOTTERM BIT(1), /* THIS IS A TERMINAL      */\n*       17 TIOEDYNM BIT(1), /* 'DYNAM' KEYWORD USED     */\n*       17 TIOEQNAM BIT(1), /* 'QNAME' KEYWORD USED     */\n*       17 * BIT(3),  /* RESERVED */\n*    10 TIOEDDNM CHAR(8),  /* DDNAME       */\n*    10 TIOEJFCB CHAR(3),  /* JFCB DISK ADDR      */\n*    10 TIOESTTC BIT(8),  /* STATUS -C-       */\n*     11 TIOSDKCR BIT(1),  /* CORE/DISK ADDRESS      */\n*     11 TIOSDEFR BIT(1),  /* DEFERRED MOUNT      */\n*     11 TIOSAFFP BIT(1),  /* UNIT AFFINITY PRIMARY     */\n*     11 TIOSAFFS BIT(1),  /* UNIT AFFINITY SECONDARY   */\n*     11 TIOSVOLP BIT(1),  /* VOLUME AFFINITY PRIMARY   */\n*     11 TIOSVOLS BIT(1),  /* VOLUME AFFINITY SECONDARY */\n*     11 TIOSBALP BIT(1),  /* SUBALLOCATE PRIMARY      */\n*     11 TIOSBALS BIT(1),  /* SUBALLOCATE SECONDARY     */\n*/********************************************************************/\n*/*             */\n*/* DEVICE ENTRIES:           */\n*/*             */\n*/*    1. DURING ALLOCATION:          */\n*/*   ONE DEVICE ENTRY FOR EACH DEVICE REQUIRED, OR FOR   */\n*/*   EACH PUBLIC DEVICE ELIGIBLE.        */\n*/*             */\n*/*    2. DURING PROBLEM PROGRAM:         */\n*/*   ONE DEVICE ENTRY FOR EACH ALLOCATED DEVICE      */\n*/*             */\n*/********************************************************************/\n*    10 TIOESTTB BIT(8),  /* STATUS -B-       */\n*     11 TIOSUSED BIT(1),  /* DATA SET IS ON DEVICE     */\n*     11 TIOSREQD BIT(1),  /* DATA SET WILL USE DEVICE  */\n*     11 TIOSPVIO BIT(1),  /* DEVICE VIOLATES SEPARATION*/\n*     11 TIOSVLSR BIT(1),  /* VOLUME SERIAL PRESENT     */\n*     11 TIOSSETU BIT(1),  /* SETUP MESSAGE REQUIRED    */\n*     11 TIOSMNTD BIT(1),  /* MOUNTED       */\n*     11 TIOSUNLD BIT(1),  /* UNLOAD REQUIRED      */\n*     11 TIOSVERF BIT(1),  /* VERIFICATION REQUIRED     */\n*    10 TIOEFSRT PTR(24), /* SRT POINTER       */\n*/********************************************************************/\n*/*             */\n*/*        TIOT POOL ENTRY          */\n*/*             */\n*/********************************************************************/\n*     5 POOLSTAR,\n*    10 *    CHAR(1),\n*    10 TIOPNSLT PTR(8),        /*  NR. OF SLOTS FOR POOL     */\n*    10 *    CHAR(1),\n*    10 TIOPNSRT PTR(8),        /*  NR. OF DEVICES (FILLED\n*          SLOTS)       */\n*    10 TIOPPOOL CHAR(8),  /* POOL NAME       */\n*    10 TIOPSTTB CHAR(1),  /* STATUS OF SLOT      */\n*    10 TIOPSLOT PTR(24),  /* SRT ADDRESS OF EMPTY SLOT */\n*    10 TIOTFEND CHAR(4);  /* FINAL END OF AN ENTRY OR\n*        THE TIOT       */\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "LNKBLD": {"ttr": 2562, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00)\\x01\\x19\\x02\\x9f\\x01\\x19\\x02\\x9f\\x06V\\x00D\\x00D\\x00\\x00\\xe2\\xc4\\xd1\\xd9\\xc7@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2019-01-29T00:00:00", "modifydate": "2019-01-29T06:56:29", "lines": 68, "newlines": 68, "modlines": 0, "user": "SDJRG"}, "text": "         MACRO\n         LNKBLD  &START=,&END=,&NEXT=,&PREV=,&LENGTH=,&LOC=,           /\n               &REG=,&COUNT=\n.**********************************************************************\n.*\n.*       This macro builds a linked list of getmained storage.\n.*\n.*       &START=     holds the address of the first area\n.*       &END=       holds the address of the last area\n.*       &NEXT=      pointer to the next area from this one\n.*       &PREV=      pointer to the previous are from this one\n.*       &LENGTH=    length of the getmained area\n.*       &LOC=       24, 31, ANY\n.*       &REG=       general purpose register to use\n.*       &COUNT=     counter to increment - fullword\n.*\n.*       &END, &PREV and &COUNT are optional\n.*\n         AIF   (T'&START  EQ 'O').NOSTART  * parameter missing\n         AIF   (T'&NEXT   EQ 'O').NONEXT   * parameter missing\n         AIF   (T'&LENGTH EQ 'O').NOLEN    * parameter missing\n         AIF   (T'&REG    EQ 'O').NOREG    * parameter missing\n.*\n         LAY   R1,&LENGTH                  * length of storage area\n         STORAGE OBTAIN,LENGTH=(R1),LOC=&LOC\n         NC    &START,&START               * check anchor is 0\n         JNZ   A&SYSNDX\n         ST    R1,&START                   * save address in start\n         XR    &REG,&REG                   * set current to 0\n         J     B&SYSNDX\nA&SYSNDX       DS    0H\n         ST    R1,&NEXT                    * save address in current\nB&SYSNDX       DS    0H\n         AIF   (T'&END    EQ 'O').NOEND\n         ST    R1,&END                     * set last area address\n.NOEND   ANOP\n         AIF   (T'&PREV   EQ 'O').NOPREV\n         LR    R0,&REG                     * copy current address\n         LR    &REG,R1                     * point to new area\n         LR    R14,&REG                    * copy address\n         LAY   R15,&LENGTH                 * get length\n         XR    R1,R1                       * set fill character + len\n         MVCL  R14,R0                      * wipe to low values\n         ST    R0,&PREV                    * set prev area address\n         AGO   .ENDPREV\n.NOPREV  ANOP\n         LR    &REG,R1                     * point to new area\n         LR    R14,&REG                    * copy address\n         LAY   R15,&LENGTH                 * get length\n         XR    R1,R1                       * set fill character + len\n         MVCL  R14,R0                      * wipe to low values\n.ENDPREV ANOP\n.*\n         AIF   (T'&COUNT  EQ 'O').NOCOUNT\n         L     R1,&COUNT                   * get count of entries\n         LA    R1,1(,R1)                   * add 1\n         ST    R1,&COUNT                   * save count of entries\n.NOCOUNT ANOP\n.*\n         MEXIT\n.NOSTART MNOTE 16,'Start anchor not provided'\n         MEXIT\n.NONEXT  MNOTE 16,'Next field not provided'\n         MEXIT\n.NOLEN   MNOTE 16,'Length not provided'\n         MEXIT\n.NOREG   MNOTE 16,'Register not provided'\n         MEND\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "LNKDEL": {"ttr": 2312, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00W\\x01\\x19\\x02\\x9f\\x01\\x19\\x02\\x9f\\x06V\\x00#\\x00#\\x00\\x00\\xe2\\xc4\\xd1\\xd9\\xc7@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2019-01-29T00:00:00", "modifydate": "2019-01-29T06:56:57", "lines": 35, "newlines": 35, "modlines": 0, "user": "SDJRG"}, "text": "         MACRO\n         LNKDEL  &START=,&NEXT=,&LENGTH=,&REG=\n.**********************************************************************\n.*\n.*       This macro frees a linked list of getmained storage.\n.*       Macro LNKBLD builds the storage.\n.*\n.*       &START=     holds the address of the first area\n.*       &NEXT=      pointer to the next area from this one\n.*       &LENGTH=    length of the getmained area\n.*       &REG=       general purpose register to use\n.*\n         AIF   (T'&START  EQ 'O').NOSTART  * parameter missing\n         AIF   (T'&NEXT   EQ 'O').NONEXT   * parameter missing\n         AIF   (T'&LENGTH EQ 'O').NOLEN    * parameter missing\n         AIF   (T'&REG    EQ 'O').NOREG    * parameter missing\n.*\n         L     &REG,&START                 * point to first entry\nA&SYSNDX       DS    0H\n         LAY   R2,&LENGTH                  * length of storage area\n         LR    R1,&REG                     * copy address\n         L     &REG,&NEXT                  * point to next slot\n         STORAGE RELEASE,LENGTH=(R2),ADDR=(R1)\n         LTR   &REG,&REG                   * check if finished\n         JNZ   A&SYSNDX                    * no so go do next\n.*\n         MEXIT\n.NOSTART MNOTE 16,'Start anchor not provided'\n         MEXIT\n.NONEXT  MNOTE 16,'Next field not provided'\n         MEXIT\n.NOLEN   MNOTE 16,'Length not provided'\n         MEXIT\n.NOREG   MNOTE 16,'Register not provided'\n         MEND\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "OTHERWSE": {"ttr": 775, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "         MACRO\n&LAB     OTHERWSE\n.*\n.* THIS MACRO IS ONE OF A RELATED SET OF MACROS WHICH ENGINEER THE\n.* SELECTED EXECUTION OF CODE DEPENDING ON THE CONTENTS OF A FIELD.\n.*\n.* THE GENERAL STRUCTURE IS AS FOLLOWS -\n.*    EVALUATE OPCODE,OP1(,OP2.REP.TYPE.LTH)\n.*      WHEN   OP2REST,OP2REST\n.*      WHEN   OP2REST-OP2REST,OP2REST\n.*      OTHERWSE\n.*    ENDEVAL\n.*\n.* CURRENT LABEL GENERATION NUMBER FOR EACH POSSIBLE DEPTH\n         GBLA  &ON(16)\n.* CURRENT END LABEL NUMBER FOR EACH POSSIBLE DEPTH\n         GBLA  &OE(16)\n.* CURRENT DEPTH OF OPTION NESTING (1 TO 16)\n         GBLA  &OD\n.* OPTELSE INDICATOR FOR EACH POSSIBLE DEPTH\n         GBLB  &OELSE(16)\n.* OPTION INDICATOR FOR EACH POSSIBLE DEPTH\n         GBLB  &OPTN(16)\n.*\n.IF0     AIF   (T'&LAB EQ 'O').END0\n&LAB     EQU   *\n.END0    ANOP\n.IF0A    AIF   (&OD NE 0).END0A\n         MNOTE 16,'OPTION MISSING'\n         MEXIT\n.END0A   ANOP\n.IF1     AIF   (&OD LE 16).END1\n         MNOTE 16,'MAX OPTION NESTING OF 16 EXCEEDED'\n         MEXIT\n.END1    ANOP\n.* SET EXIT FOR PREVIOUS CODE\n         BRU   @D&OD.E&OE(&OD)\n.* SET LABEL FOR ENTRY\n@D&OD.N&ON(&OD) EQU   *\n.* INCREMENT LABEL GENERATION NUMBER\n&ON(&OD) SETA  &ON(&OD)+1\n.* SET OPTION INDICATOR OFF\n&OPTN(&OD) SETB  (0)\n.IF1A    AIF   ((&OELSE(&OD)) EQ (0)).END1A\n         MNOTE 16,'DUPLICATE OTHERWSE'\n         MEXIT\n.END1A   ANOP\n&OELSE(&OD) SETB (1)\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "PLIST": {"ttr": 777, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": " MACRO\n&NAME  PLIST &P1\n LCLA &NPLIST,&CPLIST\n AIF ('&P1' EQ '').E2\n AIF ('&P1'(1,1) NE '(').E1\n&NPLIST SETA N'&P1\n&CPLIST SETA 1\n&NAME  DS    0F\n.B1 AIF ('&P1(&CPLIST)' EQ '').B2\n  DC    A(&P1(&CPLIST))\n AGO .B3\n.B2  DC    A(0)\n.B3 ANOP\n&CPLIST SETA 1+&CPLIST\n AIF (&CPLIST GT &NPLIST).B4\n AGO .B1\n.B4  ORG   *-4\n  DC    X'80'\n  ORG   *+3\n MEXIT\n.E1 MNOTE 2,'OPND NOT ENCLOSED IN PARENTHESES. STMT IGNORED.'\n MEXIT\n.E2 MNOTE 2,'NO OPND. STATEMEMT IGNORED.'\n MEXIT\n MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "POPINS": {"ttr": 779, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "  MACRO\n  POPINS &P\n  GBLA  &CCVAL   COND CODE VARIABLE\n  GBLA  &CTR   MACRO PARAMETER COUNTER\n  GBLA  &SEQ   LABEL NUMBER GENERATOR\n  GBLA  &AI   INDEX FOR TOTAL NO. CASES STK\n  GBLA  &CI   INDEX FOR CASE AND LBL NO. STKS\n  GBLA  &II   PTR TO INST STKS\n  GBLA  &LI   INDEX FOR LABEL NUMBER STK\n  GBLA  &NI   PTR TO NEST STK\n  GBLA  &AIND(50)  TOTAL CASES STK\n  GBLA  &CIND1(200)  CASE NUMBER STK\n  GBLA  &MULT(50)  CASE NUMBER MULTIPLIER\n  GBLA  &ST(51)   INST STK INCREASE AT EACH LEVEL\n  GBLC  &CIND2(200)  LABEL NUMBER STK FOR CASES\n  GBLC  &IIND1(100)  INSTRUCTION STK 1\n  GBLC  &IIND2(100)  INSTRUCTION STK 2\n  GBLC  &I22(100)  INSTRUCTION STK 2, 2ND PART\n  GBLC  &I23(100)  INSTRUCTION STK 2, 3RD PART\n  GBLC  &I24(100)  INSTRUCTION STK 2, 4TH PART\n  GBLC  &IIND3(100)  INSTRUCTION STK 3\n  GBLC  &I32(100)  INSTRUCTION STK 3, 2ND PART\n  GBLC  &I33(100)  INSTRUCTION STK 3, 3RD PART\n  GBLC  &I34(100)  INSTRUCTION STK 3, 4TH PART\n  GBLC  &IIND4(100)  INSTRUCTION STK 4\n  GBLC  &I42(100)  INSTRUCTION STK 4, 2ND PART\n  GBLC  &I43(100)  INSTRUCTION STK 4, 3RD PART\n  GBLC  &IIND5(100)  INSTRUCTION NAME STACK\n  GBLC  &LIND(101)  LABEL NUMBER STK\n  GBLC  &NEST(50)  NESTING STK\n  GBLC  &RIND(50)  REG STK FOR CASENTRY MACRO\n  LCLA &W\n&W  SETA &P\n  AGO .TEST\n.UNSTACK   AIF ('&IIND3(&W)' EQ '').ONEOP\n      AIF ('&IIND4(&W)' NE '').THREEOP\n&IIND5(&W)     &IIND1(&W) &IIND2(&W)&I22(&W)&I23(&W)&I24(&W),&IIND3(&W)/\n               &I32(&W)&I33(&W)&I34(&W)\n      AGO .INCTR\n.THREEOP       ANOP\n&IIND5(&W)     &IIND1(&W) &IIND2(&W)&I22(&W)&I23(&W)&I24(&W),&IIND3(&W)/\n               &I32(&W)&I33(&W)&I34(&W),&IIND4(&W)&I42(&W)&I43(&W)\n      AGO .INCTR\n.ONEOP    ANOP\n&IIND5(&W)     &IIND1(&W) &IIND2(&W)&I22(&W)&I23(&W)&I24(&W)\n.INCTR    ANOP\n&W    SETA  &W+1\n.TEST  AIF (&W LE &II).UNSTACK\n&II  SETA &P-1\n  AIF ('&NEST(&NI)'(3,1) NE ' ' OR '&NEST(&NI)'(4,1) EQ ' ').NEQ\n&IIND5(&II) &IIND1(&II) &IIND2(&II)\n.NEQ  AIF (&II GT 0 OR (&II EQ 0 AND '&NEST(&NI)'(5,4) EQ 'IF')).END\n  MNOTE 8,'NEGATIVE INSTRUCTION STACK PTR. EXPANSION INVALID.'\n.END  MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "POPNEST": {"ttr": 781, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "  MACRO\n POPNEST &P1\n GBLA &CCVAL       COND CODE VARIABLE\n GBLA &CTR       MACRO PARAMETER COUNTER\n GBLA &SEQ       LABEL NUMBER GENERATOR\n GBLA &AI       INDEX FOR TOTAL NO. CASES STK\n GBLA &CI       INDEX FOR CASE AND LBL NO. STKS\n GBLA &II       PTR TO INST STKS\n GBLA &LI       INDEX FOR LABEL NUMBER STK\n GBLA &NI       PTR TO NEST STK\n GBLA &AIND(50)       TOTAL CASES STK\n GBLA &CIND1(200)      CASE NUMBER STK\n GBLA &MULT(50)       CASE NUMBER MULTIPLIER\n GBLA &ST(51)       INST STK INCREASE AT EACH LEVEL\n GBLC &CIND2(200)      LABEL NUMBER STK FOR CASES\n GBLC &IIND1(100)      INSTRUCTION STK 1\n GBLC &IIND2(100)      INSTRUCTION STK 2\n GBLC &I22(100)       INSTRUCTION STK 2, 2ND PART\n GBLC &I23(100)       INSTRUCTION STK 2, 3RD PART\n GBLC &I24(100)       INSTRUCTION STK 2, 4TH PART\n GBLC &IIND3(100)      INSTRUCTION STK 3\n GBLC &I32(100)       INSTRUCTION STK 3, 2ND PART\n GBLC &I33(100)       INSTRUCTION STK 3, 3RD PART\n GBLC &I34(100)       INSTRUCTION STK 3, 4TH PART\n GBLC &IIND4(100)      INSTRUCTION STK 4\n GBLC &I42(100)       INSTRUCTION STK 4, 2ND PART\n GBLC &I43(100)       INSTRUCTION STK 4, 3RD PART\n GBLC &IIND5(100)      INSTRUCTION NAME STACK\n GBLC &LIND(101)      LABEL NUMBER STK\n GBLC &NEST(50)       NESTING STK\n GBLC &RIND(50)       REG STK FOR CASENTRY MACRO\n LCLC &SUFFIX\n&SUFFIX  SETC  '&NEST(&NI)'(5,4)\n  AIF   ('&NEST(&NI)'(5,4) EQ '&P1').GOOD\n  MNOTE 8,'&SUFFIX MACRO AT SAME LEVEL AS &P1 TERMINATOR.'\n.GOOD  ANOP\n&NI  SETA  &NI-1\n  AIF   (&NI GE 0).OK\n  MNOTE 8,'NEGATIVE NEST STACK POINTER. CHECK NUMBER OF ENDS.'\n.OK  ANOP\n  MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "PRGDCBI": {"ttr": 2053, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x11\\x00G\\x01\\x17\\x11\\x9f\\x01\\x191\\x8f\\x04#\\x01#\\x00S\\x00\\x00\\xe2\\xc4\\xd1\\xd9\\xc7@@@@@'", "ispf": {"version": "01.17", "flags": 0, "createdate": "2017-04-29T00:00:00", "modifydate": "2019-11-14T04:23:47", "lines": 291, "newlines": 83, "modlines": 0, "user": "SDJRG"}, "text": "         MACRO\n         PRGDCBI &DCB=SYSIN,&REC=,&V2F=,&EOF=,&FLAGLEN=,               /\n               &SPANA=,&SPANL=,&SPANM=\n.**********************************************************************\n.*\n.*    Created by John Gateley\n.*\n.*    The easiest way to use this macro is with locate mode on\n.*    the DCB and use the V2F parameter to ensure you get\n.*    a fixed length record padded with spaces. This works with\n.*    either fixed or variable length records.\n.*    If you need to do processing based on the record length\n.*    then use the REC method.\n.*    If you are processing a VBS use the SPAN parameters instead.\n.*\n.*       This macro generates code to work with an input DCB.\n.*\n.* NOTE ==> The EODAD on the DCB should be END_&DCB\n.*\n.*       This macro generates three code segments to do the following\n.*\n.*          OPEN_&DCB              code to open the &DCB\n.*\n.*          GET_&DCB               code to read a record from &DCB\n.*\n.*          CLOSE_&DCB             code to close the &DCB\n.*\n.*       It also generates this segment when processing VBS datasets\n.*       which is for internal use only.\n.*          GET_&DCB._SEGMENT\n.*\n.*     &DCB    the label on the DCB macro.\n.*     &REC    is where the input record will be read into\n.*             if NOT supplied then locate mode will be used and\n.*             R1 will contain the address of the record.\n.*     &V2F    Use this when you do not know if the actual file\n.*             will be fixed or variable, it will give you fixed.\n.*             The record will be read using locate processing\n.*             and copied to the specified data area, padded to\n.*             the right with blanks.\n.*     &FLAGLEN will be set to 'Y' if any records are truncated in\n.*             V2F processing.\n.*     &EOF    should be 1 byte and will be set to 'Y' when the\n.*             end of file has been reached.\n.*     &SPANA     area\n.*     &SPANL     length\n.*     &SPANM     max length\n.*             adds support for VBS datasets.\n.*             To use this facility &SPANA should be a fullword\n.*             containing the address of the record area.\n.*             SPANL should be a fullword and will contain the length\n.*             of the reconstructed record.\n.*             SPANM should be a fullword containing the length of\n.*             the data area pointed to by SPANA.\n.*             It is envisaged that the data area will be getmained\n.*             storage of 1MB to allow plenty of room.\n.*             If a record is > than SPANM then the program will\n.*             end with RC=12.\n.*\n.*    This is an example of the code that should be used for SYSIN\n.*    In this example all we are doing is counting the records.\n.*\n.*    SEGDO OPEN_SYSIN                    open the SYSIN file\n.*    DO INF\n.*      SEGDO GET_SYSIN\n.*    DOEXIT (CLI,EOF_SYSIN,EQ,C'Y')      end of file\n.*      LA    R3,1(,R3)                   increment count\n.*    ENDDO\n.*    SEGDO CLOSE_SYSIN                   close the SYSIN file\n.*\n.*  WARNING - if you have coded MACRF=GL but you get this message\n.*    prgname - PRGDCBI - SYSIN Input DCB not MOV mode\n.*  at run time, check you are not opening the file a second time\n.*  without first closing it.\n.*\n.*          PRGDCBI DCB=SYSIN,EOF=EOF_SYSIN\n.*  SYSIN   DCB   DSORG=PS,DDNAME=SYSIN,MACRF=(GL),EODAD=END_SYSIN\n.*\n         GBLC  &MODNAME\n.*\n         AIF   (T'&EOF NE 'O').EOFOK\n         MNOTE 16,' EOF variable required'\n         MEXIT\n.EOFOK   ANOP\n.*\n SEGS OPEN_&DCB\n*\n   MVI   &EOF,C'N'                     indicate NOT end of file\n*                                      open &DCB\n         AIF   (T'&SPANA NE 'O').ISLOCMD\n         AIF   (T'&V2F NE 'O').ISLOCMD\n         AIF   (T'&REC NE 'O').ISMOVMD\n.*\n.ISLOCMD ANOP\n&TSTMOD  SETC  'LOC'\n*                                      Check MACRF is locate mode\n   IF (TM,&DCB+50,8,Z)\n     MVC   MESS_TXT(L'&DCB._WRONG_MODE),&DCB._WRONG_MODE\n     SEGDO WRITE_LOG\n     PRGQUIT RC=16                     then quit\n   ENDIF\n         AGO   .ENDMOD\n.ISMOVMD ANOP\n&TSTMOD  SETC  'MOV'\n*                                      Check MACRF is move mode\n   IF (TM,&DCB+50,16,Z)\n     MVC   MESS_TXT(L'&DCB._WRONG_MODE),&DCB._WRONG_MODE\n     SEGDO WRITE_LOG\n     PRGQUIT RC=16                     then quit\n   ENDIF\n.ENDMOD  ANOP\n*\n.*       allow for DCB in getmained storage\n   LA    R14,&DCB\n   OPEN  ((R14),INPUT),MODE=31\n.* OPEN  (&DCB,INPUT)\n   IF (LTR,R15,R15,NZ)                 quit if failed, gives RC=16\n     WTO   '//&DCB     DD  ...         must be present in JCL',        /\n               ROUTCDE=11,MCSFLAG=HRDCPY\n     PRGQUIT RC=16\n   ENDIF\n*\n   SEGQUIT\n*\n&DCB._WRONG_MODE   DC    C'&MODNAME - PRGDCBI - &DCB Input DCB not &TST'\n               MOD mode'\n*\n SEGE OPEN_&DCB\n*______________________________________________________________________\n*\n SEGS GET_&DCB\n*\n   MVI   &EOF,C'N'                     indicate NOT end of file\n.*\n   AIF   (T'&SPANA NE 'O').DOSPAN\n.*\n   AIF   (T'&V2F NE 'O').V2FPR1\n   AIF   (T'&REC NE 'O').MOVMOD\n*\n.*       Do GET LOCATE processing\n   GET   &DCB                          get locate mode\n   AGO   .AFT\n.*\n.MOVMOD  ANOP\n.*\n.*       Do GET MOVE processing\n   GET   &DCB,&REC                     get move mode\n   AGO   .AFT\n.*\n.*       Do GET LOCATE and copy to record area\n.V2FPR1  ANOP\n&MYLEN   SETA  L'&V2F                  get length of record area\n   AIF   (&MYLEN GT 256).DOMVCL1       <= 256 so use MVC to\n   MVI   &V2F,C' '                     clear to spaces\n   MVC   &V2F+1(L'&V2F-1),&V2F\n   AGO   .NDMVCL1\n.DOMVCL1   ANOP                        > 256 so use MVCL\n   LA    R0,&V2F                       point to record area\n   LAY   R1,L'&V2F                     get length of record area\n   LA    R15,C' '                      put in a space\n   SLL   R15,24                        slide into high byte\n   MVCL  R0,R14                        wipe to spaces\n.NDMVCL1   ANOP\n.*\n   GET   &DCB\n   LH    R15,&DCB+82                   get record length just read\n   IF (TM,&DCB+36,X'40',NZ)            if variable length\n     LA    R1,4(,R1)                   point past RDW\n     AHI   R15,-4                      subtract RDW from length\n   ENDIF\n   IF (CFI,R15,GT,L'&V2F)              if greater than space available\n     LAY   R15,L'&V2F                  get maximum length\n     AIF   (T'&FLAGLEN EQ 'O').NOFLAG\n     MVI   &FLAGLEN,C'Y'               set truncated flag\n.NOFLAG  ANOP\n   ENDIF\n   IF (CHI,R15,LE,256)                 record small enough for MVC?\n     BCTR  R15,0                       less 1 for execute\n     EX    R15,&DCB._COPY_INREC        copy record\n   ELSE\n     LR    R14,R1                      copy address of input record\n     LR    R1,R15                      copy length\n     LA    R0,&V2F                     point to record area\n     MVCL  R0,R14                      copy record\n   ENDIF\n.AFT     ANOP\n*\n   SEGQUIT                             quit on good read\n*\n   AIF   (T'&V2F EQ 'O').V2FPR2\n&DCB._COPY_INREC   MVC   &V2F.(0),0(R1)\n*\n.V2FPR2  ANOP\nEND_&DCB     DS    0H\n*\n   MVI   &EOF,C'Y'                     set end of file marker\n*\n SEGE GET_&DCB\n.*\n         AGO   .AFTSPAN\n.*\n.*       Do GET LOCATE processing with VBS dataset\n.*\n.DOSPAN  ANOP\n.*\n   AIF   (T'&SPANL EQ 'O').MISSL\n   AIF   (T'&SPANM EQ 'O').MISSM\n.*\n   IF (TM,&DCB+36,X'08',Z)             if not spanned write error\n     MVC   MESS_TXT(L'&DCB._NOT_SPAN),&DCB._NOT_SPAN\n     SEGDO WRITE_LOG\n     PRGQUIT RC=16                     then quit\n   ENDIF\n   L     R0,&SPANA                     point to record area\n   L     R1,&SPANL                     get last record length\n   IF (CFI,R1,EQ,0)                    if 0\n     L     R1,&SPANM                   get maximum length\n   ENDIF\n   XR    R15,R15\n   MVCL  R0,R14                        wipe to low values\n   XC    &SPANL,&SPANL                 set current length to 0\n*\n   ST    R2,#MVCLSAV                   save current R2 value\n*\n   DO INF\n     SEGDO GET_&DCB._SEGMENT\n   DOEXIT (CLI,&EOF,EQ,C'Y')\n     LR    R2,R1                       copy segment address\n     LA    R14,4(,R1)                  point past RDW/SDW\n     LH    R15,0(,R1)                  get segment length\n     AHI   R15,-4                      subtract for RDW/SDW\n     L     R0,&SPANA                   point to start of area\n     A     R0,&SPANL                   add current length\n     LR    R1,R15                      copy segment length\n     A     R1,&SPANL                   add current length\n     ST    R1,&SPANL                   and save total\n     IF (C,R1,GT,&SPANM)               is it too big ?\n       MVC   MESS_TXT(L'&DCB._TOO_BIG),&DCB._TOO_BIG\n       SEGDO WRITE_LOG\n       PRGQUIT RC=16                   then quit\n     ENDIF\n     LR    R1,R15                      copy segment length again\n     MVCL  R0,R14                      copy segment\n   DOEXIT (CLI,2(R2),EQ,0)             single segment in record\n   DOEXIT (CLI,2(R2),EQ,2)             last segment in record\n   ENDDO\n*\n   L     R2,#MVCLSAV                   restore previous R2 value\n*\n   SEGQUIT                             QUIT seg, this keeps error\n*                                      message addressable\n*\n&DCB._TOO_BIG      DC    C'&DCB Input record was too big'\n&DCB._NOT_SPAN     DC    C'&DCB Input file not RECFM=VBS'\n*\n SEGE GET_&DCB\n*______________________________________________________________________\n*\n SEGS GET_&DCB._SEGMENT\n*\n   MVI   &EOF,C'N'\n*\n   GET   &DCB\n*\n   SEGQUIT\n*\nEND_&DCB     DS    0H\n*\n   MVI   &EOF,C'Y'                     set end of file marker\n*\n SEGE GET_&DCB._SEGMENT\n.*\n.AFTSPAN   ANOP\n*______________________________________________________________________\n*\n SEGS CLOSE_&DCB\n*                                      close &DCB\n.*       allow for DCB in getmained storage\n   LA    R14,&DCB\n   CLOSE ((R14)),MODE=31\n.* CLOSE (&DCB)\n*                                      freepool &DCB\n   FREEPOOL &DCB                       ensure buffer pool cleared\n*\n SEGE CLOSE_&DCB\n.*\n         MEXIT\n.MISSL   MNOTE 16,'SPANA defined but not SPANL'\n         MEXIT\n.MISSM   MNOTE 16,'SPANA defined but not SPANM'\n         MEND\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PRGDCBO": {"ttr": 1025, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\n\\x00U\\x01\\x17\\x11\\x9f\\x01\\x18\\x07?\\x113\\x00\\xd6\\x009\\x00\\x00\\xe2\\xc4\\xd1\\xd9\\xc7@@@@@'", "ispf": {"version": "01.10", "flags": 0, "createdate": "2017-04-29T00:00:00", "modifydate": "2018-03-14T11:33:55", "lines": 214, "newlines": 57, "modlines": 0, "user": "SDJRG"}, "text": "         MACRO\n         PRGDCBO &DCB=SYSOUT,&REC=,&CLEAR=Y,&SPANA=,&SPANL=,&SPANW=\n.**********************************************************************\n.*\n.*     Created by John Gateley\n.*\n.*     This macro generates code to work with an output DCB.\n.*\n.*     This macro generates three code segments.\n.*\n.*        OPEN_&DCB                  code to open the &DCB DCB\n.*\n.*        PUT_&DCB                   code to write a line to &DCB\n.*\n.*        CLOSE_&DCB                 code to close the &DCB DCB\n.*\n.*     It also generates this segment when processing VBS datasets\n.*     which is for internal use only.\n.*        PUT_&DCB._SEGMENT\n.*\n.*     &REC=      where the output record will be written from.\n.*     &CLEAR=Y   set &REC to spaces after the record is written.\n.*           =N   leave the record as it is. If the record is variable\n.*                then the RDW will not be set to spaces.\n.*\n.*     &SPANA     area                     DS    F\n.*     &SPANL     length                   DS    F\n.*     &SPANW     12 byte work area        DS    3F\n.*             adds support for VBS datasets.\n.*             To use this facility &SPANA should be a fullword\n.*             containing the address of the record area.\n.*             SPANL should be a fullword and will contain the length\n.*             of the full record.\n.*          When using VBS the DCB should be MACRF=PL\n.*\n.*          PRGDCBO DCB=SYSOUT,REC=MESS_TXT,CLEAR=Y\n.*  SYSOUT  DCB   DSORG=PS,MACRF=PM,DDNAME=SYSOUT,RECFM=FB,LRECL=80\n.*\n         GBLC  &MODNAME\n.*\n         AIF   (T'&SPANA NE 'O').RECOK\n         AIF   (T'&REC NE 'O').RECOK\n         MNOTE 16,' REC= variable required'\n         MEXIT\n.RECOK   ANOP\n.*\n SEGS OPEN_&DCB\n*                                      open &DCB\n         AIF   (T'&SPANA NE 'O').ISLOCMD\n         AIF   (T'&REC NE 'O').ISMOVMD\n.*\n.ISLOCMD ANOP\n&TSTMOD  SETC  'LOC'\n*                                      Check MACRF2 is locate mode\n   IF (TM,&DCB+51,8,Z)\n     MVC   MESS_TXT(L'&DCB._WRONG_MODE),&DCB._WRONG_MODE\n     SEGDO WRITE_LOG\n     PRGQUIT RC=16                     then quit\n   ENDIF\n         AGO   .ENDMOD\n.ISMOVMD ANOP\n&TSTMOD  SETC  'MOV'\n*                                      Check MACRF2 is move mode\n   IF (TM,&DCB+51,16,Z)\n     MVC   MESS_TXT(L'&DCB._WRONG_MODE),&DCB._WRONG_MODE\n     SEGDO WRITE_LOG\n     PRGQUIT RC=16                     then quit\n   ENDIF\n.ENDMOD  ANOP\n*\n.*       allow for DCB in getmained storage\n   LA    R14,&DCB\n   OPEN  ((R14),OUTPUT),MODE=31\n.* OPEN  (&DCB,OUTPUT),MODE=31\n   IF (LTR,R15,R15,NZ)                 quit if failed, gives RC=16\n     WTO   '//&DCB     DD  ...         must be present in JCL',        /\n               ROUTCDE=11,MCSFLAG=HRDCPY\n     PRGQUIT RC=16\n   ENDIF\n*\n   SEGQUIT\n*\n&DCB._WRONG_MODE   DC    C'&MODNAME - PRGDCBO - &DCB Output DCB not &TS'\n               TMOD mode'\n*\n SEGE OPEN_&DCB\n*______________________________________________________________________\n*\n SEGS PUT_&DCB\n*\n   AIF   (T'&SPANA NE 'O').DOSPAN\n.*\n   PUT   &DCB,&REC                     put move mode\n*\n   AIF   ('&CLEAR' EQ 'N').NOCLEAR\n.*\n&MYLEN1  SETA  L'&REC                  get length of record area\n&MYLEN2  SETA  L'&REC-4                get length of record area - RDW\n.*\n   AIF   (&MYLEN1 GT 256).DOMVCL       <= 256 so use MVC to\n   IF (TM,&DCB+36,X'40',NZ)            if variable length\n     MVI   &REC+4,C' '                 clear output record\n     MVC   &REC+5(L'&REC-5),&REC+4     but not RDW\n   ELSE\n     MVI   &REC,C' '                   clear output record\n     MVC   &REC+1(L'&REC-1),&REC\n   ENDIF\n   AGO   .NDMVCL\n.*\n.DOMVCL    ANOP                        > 256 so use MVCL\n.*\n   IF (TM,&DCB+36,X'40',NZ)            if variable length\n     LA    R0,&REC+4                   point to after RDW\n     LAY   R1,&MYLEN2                  get length to clear\n     LA    R8,1\n   ELSE\n     LA    R0,&REC                     point to record area\n     LAY   R1,&MYLEN1                  get length to clear\n     LA    R8,2\n   ENDIF\n   LA    R15,C' '                      put in a space\n   SLL   R15,24                        slide into high byte\n   MVCL  R0,R14                        wipe to spaces\n.*\n.NDMVCL    ANOP\n.*\n.NOCLEAR ANOP\n*\n SEGE PUT_&DCB\n.*\n         AGO   .AFTSPAN\n.*\n.DOSPAN  ANOP\n.*\n   AIF   (T'&SPANL EQ 'O').MISSL\n   AIF   (T'&SPANW EQ 'O').MISSW\n.*\n   IF (TM,&DCB+36,X'08',Z)             if not spanned write error\n     MVC   MESS_TXT(L'&DCB._NOT_SPAN),&DCB._NOT_SPAN\n     SEGDO WRITE_LOG\n     PRGQUIT RC=12                     then quit\n   ENDIF\n   MVC   &SPANW.(4),&SPANA             copy address of record\n   MVC   &SPANW.+4(4),&SPANL           copy length of record\n   MVI   &SPANW.+8,0                   indicate complete record\n*\n   DO INF\n     SEGDO PUT_&DCB._SEGMENT           uses locate mode\n     LR    R14,R1                      save address of output buffer\n     LR    R15,R0                      save length of output buffer\n     AHI   R15,-4                      subtract length of RDW/SDW\n     XC    0(4,R14),0(R14)             clear RDW/SDW in output\n     IF (C,R15,GE,&SPANW.+4)           only or final segment\n       L     R15,&SPANW.+4             set length to write\n       XC    &SPANW.+4(4),&SPANW.+4    show no more after this\n       L     R0,&SPANW                 address to copy from\n       IF (CLI,&SPANW.+8,NE,0)         writing segments\n         MVI   2(R14),2                show last segment\n       ENDIF\n     ELSE\n       L     R1,&SPANW.+4              get length remaining\n       SR    R1,R15                    subtract this length\n       ST    R1,&SPANW.+4              save new length remaining\n       L     R0,&SPANW                 address to copy from\n       L     R1,&SPANW                 address to copy from\n       AR    R1,R15                    add this length\n       ST    R1,&SPANW                 save new address\n       IF (CLI,&SPANW.+8,EQ,0)         writing first segment\n         MVI   2(R14),1                show first segment\n         MVI   &SPANW.+8,1             show first segment written\n       ELSE\n         MVI   2(R14),3                show middle segment\n       ENDIF\n     ENDIF\n     LA    R1,4(,R15)                  add RDW/SDW length\n     STH   R1,0(R14)                   set RDW/SDW length\n     LA    R14,4(,R14)                 point after RDW/SDW in output\n     LR    R1,R15                      copy move length\n     MVCL  R14,R0                      copy the data\n   DOEXIT (CLC,=F'0',EQ,&SPANW.+4)     nothing else to write\n   ENDDO\n*\n   SEGQUIT                             QUIT seg, this keeps error\n*                                      message addressable\n*\n&DCB._NOT_SPAN     DC    C'&DCB Output file not RECFM=VBS'\n*\n SEGE PUT_&DCB\n*______________________________________________________________________\n*\n SEGS PUT_&DCB._SEGMENT\n*\n   PUT   &DCB\n*\n SEGE PUT_&DCB._SEGMENT\n.*\n.AFTSPAN   ANOP\n*______________________________________________________________________\n*\n SEGS CLOSE_&DCB\n*                                      close &DCB\n.*       allow for DCB in getmained storage\n   LA    R14,&DCB\n   CLOSE ((R14)),MODE=31\n.* CLOSE (&DCB),MODE=31\n*\n SEGE CLOSE_&DCB\n.*\n         MEXIT\n.MISSL   MNOTE 16,'SPANA defined but not SPANL'\n         MEXIT\n.MISSW   MNOTE 16,'SPANA defined but not SPANW'\n         MEXIT\n         MEND\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PRGDEF": {"ttr": 2305, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x06\\x00@\\x01\\x17\\x11\\x8f\\x01\\x19'O\\x043\\x01\\x8d\\x01\\x86\\x00\\x00\\xe2\\xc4\\xd1\\xd9\\xc7@@@@@\"", "ispf": {"version": "01.06", "flags": 0, "createdate": "2017-04-28T00:00:00", "modifydate": "2019-10-01T04:33:40", "lines": 397, "newlines": 390, "modlines": 0, "user": "SDJRG"}, "text": "         MACRO\n&LABEL   PRGDEF &FSEG=,&REXX=N,&AMODE=31,&RMODE=ANY,&INREX=N,          /\n               &RENT=N,&MAXSEG=50,&SBAS2=N,&SBAS3=N,&MAXPAR=24,        /\n               &RBAS2=N,&RBAS3=N,&RLOC=ANY,&WTOL=80\n.*\n.*  Created by John Gateley\n.*\n.*  This macro defines the start ot the program and is responsible\n.*  for getting and releasing dynamic storage if RENT=Y is specified.\n.*  RBAS2 and RBAS3 provide for additional reentrant storage\n.*  base registers.\n.*  SBAS2 and SBAS3 provide for additional static storage base\n.*  registers.\n.*\n.*  The assembler LOCTR is used to build the object module with the\n.*  static variables such as literals and constants at the top followed\n.*  by the executable code. Code in the program should be segmented\n.*  using SEGS and SEGE macros and segments should be performed by use\n.*  of the SEGDO macro. A code base register is used to give\n.*  addressability within each segment and is automatically\n.*  maintained on entry to and exit from a segment. Branching to a\n.*  label in another segment will usually cause an 'interesting' abend.\n.*\n.*  Example program layout\n.*\n.*   TITLE 'PROGRAM TITLE'\n.*  NAME  PRGDEF FSEG=MAIN_BIT,REXX=Y,RENT=Y\n.*  DYNAMIC_STORAGE_VARIABLE   DS    F\n.*        PRGEDEF\n.*   SEGS MAIN_BIT\n.*     MVC   ....\n.*     SEGDO SEGMENT_TWO\n.*   SEGE MAIN_BIT\n.*   SEGS SEGMENT_TWO\n.*     MVC   ....\n.*   SEGE SEGMENT_TWO\n.*\n.*        PRGSTAT\n.*  A_CONSTANT   DC    C'SOME TEXT'\n.*        PRGESTAT\n.*        PRGEND\n.*        END\n.*\n.*  An area of re-entrant storage called MESS_TXT is provided and is\n.*  used by the WTOX macro to write to operator, this defaults to\n.*  80 but can be up to 120 and is set by WTOL=80.\n.*  An area is provided for building parameter lists MY_PARM the\n.*  number of fullwords is set by MAXPAR=24.\n.*  REXX=Y automatically includes the macros required for writing\n.*  rexx functions in assembler. INREXX=Y is for rexx functions\n.*  that are not called directly by rexx.\n.*\n.*  Registers used are\n.*             R13            save area and base for re-entrant\n.*                            storage between PRGDEF and PRGEDEF\n.*             R12            base register for static variables which\n.*                            are defined between PRGSTAT and PRGESTAT\n.*             R11            segment code base register\n.*             R10            rexx environment block\n.*             R9             rexx EFPL\n.*             R8             rexx ARGTABLE_ENTRY\n.*             R7             rexx EVALBLOCK\n.*\n.*  Defaults are\n.*             RENT=NO\n.*             CBASE=R11      Code base register set in every segment\n.*             AMODE=31\n.*             RMODE=ANY\n.*             MAXSEG=50      Maximium number of segments in program\n.*             SBAS2=N        No second storage register\n.*             SBAS3=N        No third storage register\n.*             RBAS2=N        No second reentrant register\n.*             RBAS3=N        No third reentrant register\n.*             MAXPAR=24      Parameter list length\n.*             WTOL=80        80 character message area.\n.*\n           GBLC  &MODNAME\n           GBLC  &SETREX\n           GBLC  &INREXX\n           GBLC  &ISRBAS2,&ISRBAS3\n           GBLC  &ISSBAS2,&ISSBAS3\n           GBLC  &SEGSAVA\n           GBLC  &BASSAVA\n           GBLC  &SAMODE\n           GBLC  &ISRENT\n           GBLC  &SCBASER\n           GBLC  &STRWRK\n           GBLA  &SEGCNT\n           GBLA  &SEGMAX\n           GBLA  &PARMAX\n           GBLA  &SCBASEC\n           GBLA  &WHICHM\n           LCLA  &CNT1,&CNT2\n           AIF   ('&LABEL' EQ '').MNOTE1\n           AIF   ('&FSEG' EQ '').MNOTE2\n.*\n*   Change branch link to branch save, ensure clean 31 bit addresses\nBAL        OPSYN BAS\nBALR       OPSYN BASR\n.*\n&MODNAME   SETC  '&LABEL'\n&ISRBAS2   SETC  '&RBAS2'\n&ISRBAS3   SETC  '&RBAS3'\n&ISSBAS2   SETC  '&SBAS2'\n&ISSBAS3   SETC  '&SBAS3'\n&ISRENT    SETC  '&RENT'(1,1)\n&SAMODE    SETC  '&AMODE'\n&SETREX    SETC  '&REXX'(1,1)\n&INREXX    SETC  '&INREX'(1,1)\n&SCBASER   SETC  'R11'\n&STRWRK    SETC  '#STRING_WORK'\n&SEGCNT    SETA  0\n&SCBASEC   SETA  0\n&SEGMAX    SETA  &MAXSEG\n&PARMAX    SETA  &MAXPAR\n&CNT1      SETA  1\n&CNT2      SETA  &PARMAX\n&WHICHM    SETA  5\n*\n&MODNAME   START 0\n           AIF   ('&AMODE' EQ '31').ABIT31\n           AIF   ('&AMODE' NE '24').MNOTE3\n.ABIT24    ANOP\n&MODNAME   AMODE 24\n&MODNAME   RMODE 24\n           AGO   .AFTR\n.ABIT31    ANOP\n&MODNAME   AMODE 31\n           AIF   ('&RMODE' EQ '24').RBIT24\n           AIF   ('&RMODE' EQ 'ANY').RBIT31\n           AGO   .MNOTE4\n.RBIT24    ANOP\n&MODNAME   RMODE 24\n           AGO   .AFTR\n.RBIT31    ANOP\n&MODNAME   RMODE ANY\n.AFTR      ANOP\n*\nR0         EQU   0\nR1         EQU   1\nR2         EQU   2\nR3         EQU   3\nR4         EQU   4\nR5         EQU   5\nR6         EQU   6\n           AIF   ('&SETREX' EQ 'Y').REXEQ\n           AIF   ('&INREXX' EQ 'Y').REXEQ\nR7         EQU   7\nR8         EQU   8\nR9         EQU   9\nR10        EQU   10\n           AGO   .REXEQX\n.REXEQ     ANOP\nR7         EQU   7                   * rexx EVALBLOCK\nR8         EQU   8                   * rexx ARGTABLE_ENTRY\nARG_POINT  EQU   8                   * rexx ARGTABLE_ENTRY alt name\nR9         EQU   9                   * rexx EFPL\nR10        EQU   10                  * rexx ENVBLOCK\n.REXEQX    ANOP\nR11        EQU   11                  * segment base register\nR12        EQU   12                  * module base register\nR13        EQU   13                  * reentrant storage\nR14        EQU   14\nR15        EQU   15\n.*\n           AIF   ('&SETREX' EQ 'N').NOREX1\n           AIF   ('&INREXX' EQ 'Y').MNOTE5\n.NOREX1    ANOP\n*\n           BRUL  BEGIN\n*\n@DATA      LOCTR ,\n           DC    CL10' &MODNAME'\n&AADAT     SETC  '&SYSCLOCK'(1,19)\n           DC    CL20'&AADAT'\n           DC    CL48'Copyright (C) ------------------------'\n           DS    0F\n@CODE      LOCTR ,\nBEGIN      DS    0H\n           STM   R14,R12,12(R13)     * save registers in caller\n           LARL  R12,&MODNAME        * get address of entry point\n*\n           AIF   ('&ISSBAS2' EQ 'N').NOS2BAS\n           AIF   ('&ISSBAS3' EQ 'N').NOS3BAS\n*\n           USING &MODNAME,R12\n           LA    &ISSBAS2,2048(,R12)\n           LA    &ISSBAS2,2048(,&ISSBAS2)\n           USING &MODNAME+4096,&ISSBAS2\n           LA    &ISSBAS3,2048(,&ISSBAS2)\n           LA    &ISSBAS3,2048(,&ISSBAS3)\n           USING (&MODNAME+8192,BEGIN),&ISSBAS3\n           AGO   .ENDSTAT\n*\n.NOS3BAS   ANOP\n           USING &MODNAME,R12\n           LA    &ISSBAS2,2048(,R12)\n           LA    &ISSBAS2,2048(,&ISSBAS2)\n           USING (&MODNAME+4096,BEGIN),&ISSBAS2\n           AGO   .ENDSTAT\n*\n.NOS2BAS   ANOP\n           USING (&MODNAME,BEGIN),R12\n.ENDSTAT   ANOP\n*\n           LR    R9,R1               save parameter address\n           AIF   ('&SETREX' EQ 'N').NO0001\n           LR    R10,R0              save rexx environment block addr\n.NO0001    ANOP\n           AIF   ('&ISRENT' EQ 'Y').RNT001\n*    Note that save area is NOT re-entrant\n           LARL  R2,#RENT_AREA\n           AGO   .RNT002\n.RNT001    ANOP\n*    Note that save area is re-entrant\n           L     R2,#RENTSIZ\n           AIF   ('&RLOC' NE 'ANY').SBIT24\n           AIF   ('&AMODE' EQ '31').SBIT31\n.SBIT24    ANOP\n*          STORAGE OBTAIN,LENGTH=(R2),LOC=24\n           CNOP  0,4\n           BRAS  R15,#GET_LAB\n           DC    BL1'00000000'\n           DC    AL1(0*16)\n           DC    AL1(0)\n           DC    BL1'00010010'\n#GET_LAB   DS    0F\n           LR    0,R2\n           L     15,0(,R15)\n           L     14,16(0,0)\n           L     14,772(14,0)\n           L     14,160(14,0)\n           PC    0(14)\n           AGO   .ESTOR\n.SBIT31    ANOP\n*          STORAGE OBTAIN,LENGTH=(R2),LOC=31\n           CNOP  0,4\n           BRAS  R15,#GET_LAB\n           DC    BL1'00000000'\n           DC    AL1(0*16)\n           DC    AL1(0)\n           DC    BL1'01110010'\n#GET_LAB   DS    0F\n           LR    0,R2\n           L     15,0(,R15)\n           L     14,16(0,0)\n           L     14,772(14,0)\n           L     14,160(14,0)\n           PC    0(14)              get storage\n.ESTOR     ANOP\n           LR    R2,R1               copy storage address\n.RNT002    ANOP\n           LR    R1,R9               restore parameter address\n           ST    R13,4(R2)           chain save areas\n           ST    R2,8(R13)\n           LR    R13,R2\n*\n           AIF   ('&ISRBAS2' EQ 'N').NOR2BAS\n           AIF   ('&ISRBAS3' EQ 'N').NOR3BAS\n*\n           USING #PRGAREA,R13\n           LA    &ISRBAS2,2048(,R13)\n           LA    &ISRBAS2,2048(,&ISRBAS2)\n           USING &PRGAREA+4096,&ISRBAS2\n           LA    &ISRBAS3,2048(,&ISRBAS2)\n           LA    &ISRBAS3,2048(,&ISRBAS3)\n           USING (#PRGAREA+8192,#E_RENT),&ISRBAS3\n           AGO   .ENDRTAT\n*\n.NOR3BAS   ANOP\n           USING #PRGAREA,R13\n           LA    &ISRBAS2,2048(,R13)\n           LA    &ISRBAS2,2048(,&ISRBAS2)\n           USING (#PRGAREA+4096,#E_RENT),&ISRBAS2\n           AGO   .ENDRTAT\n*\n.NOR2BAS   ANOP\n           USING (#PRGAREA,#E_RENT),R13\n.ENDRTAT   ANOP\n*\n           AIF   ('&SETREX' EQ 'N').NO0002\n           LR    R0,R10              restore environment block address\n.NO0002    ANOP\n.*\n           AIF   ('&SETREX' EQ 'N').NOREX2\n           USING ENVBLOCK,R10        use environment block\n           USING EFPL,R9\n           L     R8,EFPLARG\n           USING ARGTABLE_ENTRY,R8\n           L     R7,EFPLEVAL\n           L     R7,0(R7)\n           USING EVALBLOCK,R7\n           STM   R7,R10,#SAV_REX\n           XC    EVALBLOCK_EVLEN,EVALBLOCK_EVLEN\n.NOREX2    ANOP\n           AIF   ('&INREXX' NE 'Y').NOINREX\n           L     R9,4(R13)\n           MVC   #SAV_REX(4*4),#SAV_REX-#PRGAREA(R9)\n           LM    R7,R10,#SAV_REX\n           USING ENVBLOCK,R10\n           USING EFPL,R9\n           USING ARGTABLE_ENTRY,R8\n           USING EVALBLOCK,R7\n.NOINREX   ANOP\n.*\n           XC    R_C,R_C\n           XC    MY_PARM(LEN_MY_PARM),MY_PARM\n           STMH  R0,R15,#HIGH_HALF         * save high registers\n           AIF   ('&ISRENT' NE 'Y').RNT003\n*    initialise obtained storage to low-values if reentrant\n           L     R15,#RENTSIZ              * length of reentrant area\n           AR    R15,R13                   * start of area\n           LA    R14,MY_PARM\n           SR    R15,R14\n           LR    R2,R1\n           XR    R1,R1\n           MVCL  R14,R0                    * wipe to low values\n           LR    R1,R2                     * restore PARM address\n.RNT003    ANOP\n*\n.*\n.*       area for use by the WTOX macro the length of the message\n.*       is set by macro parameter &WTOL which defaults to 80\n.*       permitted values are 80 to 120\n.*\n&A         SETA  &WTOL                     * copy length\n           AIF   (&A LT 80).MNOTE6\n           AIF   (&A GT 120).MNOTE6\n           MVC   #MESS_LEN,=H'&WTOL'       * set length of WTO text\n           MVI   MESS_TEXT,C' '\n           MVC   MESS_TEXT+1(L'MESS_TEXT-1),MESS_TEXT\n.*\n*          copy list form WTO expansion from PRGSTAT static storage\n.*\n           MVC   #ACT_WTO_LIST(L_#PTN_WTO_LIST),#PTN_WTO_LIST\n*\n           ST    R1,#PARM_ADDR             * save input PARM address\n*\n           BRAS  R14,##&FSEG               * go to main code\n*\n           BRU   #AFT_RENT                 * go to clean up\n*\n           DS    0F\n*\n&SEGSAVA   SETC  '#SEG_SAV'\n.*\n           AIF   ('&ISRENT' EQ 'Y').RNT004\n#PRGAREA       DSECT                       * DSECT overlays #RENT_AREA\n           AGO   .RNT005\n.RNT004    ANOP\n#PRGAREA       DSECT                       * DSECT overlays getmained\n.RNT005    ANOP\n#SAVAREA       DS    18F\n#SAV_REX       DS    4F\n#SEG_SAV       DS    &SEGMAX.F             * segment save area\n               AIF   ('&SCBASER' EQ 'N').NOCBAS\n#BAS_SAV       DS    &SEGMAX.F             * segment base reg save\n&BASSAVA       SETC  '#BAS_SAV'\n.NOCBAS        ANOP\nR_C            DS    F\n*\nDOUB_WORD      DS    D\nMY_PARM        DC    &PARMAX.F'0'          * define call parm area\n               ORG   MY_PARM\n.PLOOP         ANOP\nMY_P_&CNT1     DS    F\n&CNT1          SETA  &CNT1+1\n               AIF   (&CNT1 LE &CNT2).PLOOP\n.*\nEND_MY_PARM    EQU   *\nLEN_MY_PARM    EQU   *-MY_PARM\n#MVCLSAV       DC    4F'0'\n#HIGH_HALF     DS    16F                   * high half of registers\nLEN_SAY        DS    F\n#PARM_ADDR     DS    F                     * contents of R1 on entry\nHEXPACK_W2     DS    CL2                   * used in XPACK macro\nHEXPACK_W3     DS    CL3                   * used in XPACK macro\n#STRING_WORK   DS    CL32                  * used in STRING macro\n#ACT_WTO_LIST  DS    CL(L_#PTN_WTO_LIST)   * area for WTOX macro\n#MESS_LEN      DS    H                     * WTOX length\nMESS_TEXT      DS    CL&WTOL               * WTOX text\n               ORG   MESS_TEXT\nMESS_TXT       DS    CL&WTOL               * WTOX text alternate name\n*\n         MEXIT\n.MNOTE1  MNOTE 16,'The program name was not specified in column 1'\n         MEXIT\n.MNOTE2  MNOTE 16,'FSEG parameter was not specified'\n         MEXIT\n.MNOTE3  MNOTE 16,'AMODE not = 31 or 24'\n         MEXIT\n.MNOTE4  MNOTE 16,'RMODE not = ANY or 24'\n         MEXIT\n.MNOTE5  MNOTE 16,'REXX=YES and INREX=YES are mutually exclusive'\n         MEXIT\n.MNOTE6  MNOTE 16,'WTOL= permitted values are between 80 and 120'\n         MEND\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PRGEDEF": {"ttr": 1027, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x06\\x00Q\\x01\\x17\\x14?\\x01\\x18\\x12O\\x03B\\x00M\\x00K\\x00\\x00\\xe2\\xc4\\xd1\\xd9\\xc7@@@@@'", "ispf": {"version": "01.06", "flags": 0, "createdate": "2017-05-23T00:00:00", "modifydate": "2018-05-04T03:42:51", "lines": 77, "newlines": 75, "modlines": 0, "user": "SDJRG"}, "text": "           MACRO\n           PRGEDEF\n           GBLC  &MODNAME\n           GBLC  &SETREX\n           GBLC  &SAMODE\n           GBLC  &INREXX\n           GBLC  &ISRENT\n           GBLA  &WHICHM\n           AIF   ('&WHICHM' NE '5').MNOTE1\n*\n.* Created by John Gateley\n.*\n#PRGAREA   DSECT\n*\n#E_RENT    EQU   *\n*\n&MODNAME   CSECT\n#AFT_RENT  DS    0H                        * start of goback code\n*\n           AIF   ('&SETREX' EQ 'N').NOREX\n           L     R7,#SAV_REX               * point to rexx-evalblock\n           L     R1,R_C                    * get return code\n           LTR   R1,R1\n           BRNZ  #AFT_RENT1                * R_C not zero then use it\n           CLC   EVALBLOCK_EVLEN,=F'0'     * if output length not set\n           BRNE  #AFT_RENT2                *   then use R_C anyway\n#AFT_RENT1 DS    0H\n           CVD   R1,DOUB_WORD              * put R_C into DOUB_WORD\n           MVC   MY_P_7,=X'40202120'\n           LA    R1,MY_P_7+3\n           EDMK  MY_P_7(4),DOUB_WORD+6\n           LA    R2,MY_P_8\n           CP    DOUB_WORD,=P'0'\n           BRNM  *+10\n           BCTR  R1,0\n           MVI   0(R1),C'-'                * set leading minus sign\n           SR    R2,R1\n           ST    R2,EVALBLOCK_EVLEN        * set length of output\n           BCTR  R2,0\n           EX    R2,#RC_SET                * copy return code to output\n           XC    R_C,R_C\n#AFT_RENT2 DS  0H\n.NOREX     ANOP\n           LMH   R0,R15,#HIGH_HALF         * restore high registers\n           AIF   ('&ISRENT' EQ 'Y').RNT001\n           L     R2,R_C                    * get return code\n           L     R13,4(R13)                * get caller save area\n           ST    R2,16(R13)                * save return code in R15\n           AGO   .RNT002\n.RNT001    ANOP\n           L     R0,#RENTSIZ\n           LR    R1,R13\n           L     R2,R_C\n           L     R13,4(R13)\n           ST    R2,16(R13)\n*          STORAGE RELEASE,LENGTH=(R0),ADDR=(R1)\n           CNOP  0,4\n           BRAS  R15,#FRE_LAB\n           DC    BL1'00000000'\n           DC    AL1(0*16)\n           DC    AL1(0)\n           DC    BL1'00000011'\n#FRE_LAB   DS    0F\n           LR    0,R0\n           LR    1,R1\n           L     15,0(,R15)\n           L     14,16(0,0)\n           L     14,772(14,0)\n           L     14,204(14,0)\n           PC    0(14)\n.RNT002    ANOP\n           LM    R14,R12,12(R13)           * load callers + return code\n           BSM   0,R14                     * return to caller\n    EJECT\n         MEXIT\n.MNOTE1  MNOTE 50,'You are mixing your macros - PRGDEF PRGEDEF PRGEND'\n         MEND\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PRGEND": {"ttr": 1029, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x01\\x00\\x00\\x01\\x17\\x14?\\x01\\x18\\x07?\\x11!\\x00'\\x00'\\x00\\x00\\xe2\\xc4\\xd1\\xd9\\xc7@@@@@\"", "ispf": {"version": "01.01", "flags": 0, "createdate": "2017-05-23T00:00:00", "modifydate": "2018-03-14T11:21:00", "lines": 39, "newlines": 39, "modlines": 0, "user": "SDJRG"}, "text": "           MACRO\n           PRGEND\n           GBLC  &MODNAME\n           GBLC  &SETREX\n           GBLC  &INREXX\n           GBLC  &ISRENT\n           GBLC  &SEGNAM\n           GBLA  &WHICHM\n           AIF   ('&WHICHM' NE '5').MNOTE2\n.*\n.* Created by John Gateley\n.*\n&MODNAME   CSECT\n           LTORG\n           AIF   ('&SETREX' EQ 'Y').YESREX\n           AIF   ('&INREXX' EQ 'Y').YESREX\n           AGO   .NOREX1\n.YESREX    ANOP\n           IRXENVB\n           IRXEXTE\n           IRXEFPL\n           IRXARGTB\n           IRXEVALB\n           IRXSHVB\n.NOREX1    ANOP\n*\n&MODNAME   CSECT\n           AIF   ('&ISRENT' EQ 'Y').RNT001\n#RENT_AREA DS    0D\n           DC    (#E_RENT-#PRGAREA)XL1'00'\n#E_E_PROG  EQU   *\n.RNT001    ANOP\n*\n         AIF   ('&SEGNAM' NE '').MNOTE1\n         MEXIT\n.MNOTE1  MNOTE 16,'Unequal number OF SEGS SEGE macros'\n         MEXIT\n.MNOTE2  MNOTE 50,'You are mixing your macros - PRGDEF PRGEDEF PRGEND'\n         MEND\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PRGESTAT": {"ttr": 1031, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00\\x11\\x01\\x17\\x12/\\x01\\x18\\x07?\\x11\\x19\\x00\\x15\\x00\\x1a\\x00\\x00\\xe2\\xc4\\xd1\\xd9\\xc7@@@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "2017-05-02T00:00:00", "modifydate": "2018-03-14T11:19:11", "lines": 21, "newlines": 26, "modlines": 0, "user": "SDJRG"}, "text": "           MACRO\n           PRGESTAT\n           GBLC  &MODNAME\n           GBLA  &WHICHM\n           AIF   ('&WHICHM' NE '5').MNOTE2\n.*\n&MODNAME   CSECT\n           DS    0D\n           LTORG\n*\n.*\n.* Created by John Gateley\n.*\n##STATIC_E     EQU   *\n               DS    0D\n               DC    CL32'&MODNAME ##STATIC END'\n@CODE      LOCTR ,\n*\n         MEXIT\n.MNOTE2  MNOTE 50,'You are mixing your macros - PRGDEF PRGEDEF PRGEND'\n         MEND\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PRGPARM": {"ttr": 1033, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00I\\x01\\x17\\x14?\\x01\\x17\\x14?\\x11\\x15\\x00,\\x00,\\x00\\x00\\xe2\\xc4\\xd1\\xd9\\xc7@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2017-05-23T00:00:00", "modifydate": "2017-05-23T11:15:49", "lines": 44, "newlines": 44, "modlines": 0, "user": "SDJRG"}, "text": "         MACRO\n         PRGPARM &PARM,&LEN=\n.**********************************************************************\n.*\n.*  Created by John Gateley\n.*\n.*     This macro generates the code to get the value of PARM='  '\n.*     in the JCL.\n.*\n.*     &PARM      where the parameter value should be copied to\n.*     &LEN=      a halfword which will contain its length (optional)\n.*\n         AIF   (T'&PARM EQ 'O').NOPARM\n&MYLEN   SETA  L'&PARM\n.*\n   MVI   &PARM,C' '\n   MVC   &PARM+1(L'&PARM-1),&PARM\n.*\n   L     R1,#PARM_ADDR                   restore R1 at entry\n   IF (LTR,R1,R1,NZ)                     parm supplied\n     L     R1,0(,R1)                     get address of it\n.*\n         AIF   (T'&LEN EQ 'O').NOLEN\n.*\n     MVC   &LEN,0(R1)                    copy length of parm\n.*\n.NOLEN   ANOP\n.*\n     IF (CLC,0(2,R1),NE,=H'0')           length not zero\n       LA    R0,2(,R1)                   point R0 after length\n       LH    R1,0(,R1)                   load length\n       IF (CHI,R1,GT,&MYLEN)             > length of receiving field\n         LHI   R1,&MYLEN                 use that length\n       ENDIF\n       LA    R14,&PARM                   point to receiving field\n       LR    R15,R1                      copy length\n       MVCL  R14,R0                      copy PARM value\n     ENDIF\n   ENDIF\n.*\n         MEXIT\n.NOPARM  MNOTE 16,'PARM value not supplied (char 80)'\n         MEXIT\n         MEND\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PRGQUIT": {"ttr": 1035, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x003\\x01\\x17\\x14?\\x01\\x17\\x14?\\x11\\x06\\x00\\x19\\x00\\x19\\x00\\x00\\xe2\\xc4\\xd1\\xd9\\xc7@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2017-05-23T00:00:00", "modifydate": "2017-05-23T11:06:33", "lines": 25, "newlines": 25, "modlines": 0, "user": "SDJRG"}, "text": "           MACRO\n           PRGQUIT &RC=0\n.*\n.* Created by John Gateley\n.*\n           GBLC  &SCBASER\n           GBLC  &BASSAVA\n.*\n           AIF   ('&RC' EQ '0').NOCODE\n.*\n           MVI   R_C+3,&RC\n.*\n.NOCODE    ANOP\n.*\n           AIF   ('&SCBASER' EQ 'N').NOCBASE\n           AIF   ('&SCBASER' EQ '').NOCBASE\n           AIF   ('&BASSAVA' EQ '').MNOTE1\n.*         restore code base register to initial value\n           L     &SCBASER,&BASSAVA\n.NOCBASE   ANOP\n           BRUL  #AFT_RENT\n.*\n           MEXIT\n.MNOTE1    MNOTE 8,'Macro variable \"BASSAVA\" has not been set'\n           MEND\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PRGSTAT": {"ttr": 1037, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x06\\x00B\\x01\\x17\\x11\\x8f\\x01\\x18!\\x8f\\x16V\\x00[\\x006\\x00\\x00\\xe2\\xc4\\xd1\\xd9\\xc7@@@@@'", "ispf": {"version": "01.06", "flags": 0, "createdate": "2017-04-28T00:00:00", "modifydate": "2018-08-06T16:56:42", "lines": 91, "newlines": 54, "modlines": 0, "user": "SDJRG"}, "text": "           MACRO\n           PRGSTAT\n           GBLC  &MODNAME\n           GBLC  &SETREX\n           GBLC  &USETSTMP\n           GBLC  &HEXPCK\n           GBLC  &XUNPCK\n           GBLC  &WRTLOGD\n           GBLC  &WRTLOGU\n           GBLA  &WHICHM\n           AIF   ('&WHICHM' NE '5').MNOTE2\n.*\n.* Created by John Gateley\n.*\n&MODNAME   CSECT\n.*\n.*         see if segment WRITE_LOG is defined\n           AIF   ('&WRTLOGD' EQ 'Y').NOWLOG\n.*         see if segment WRITE_LOG is used but not defined\n           AIF   ('&WRTLOGU' EQ 'N').NOWLOG\n*SEGS WRITE_LOG\n SEGS WRITE_LOG\n*\n*  WTOX\n   WTOX\n*\n*SEGE WRITE_LOG\n SEGE WRITE_LOG\n*\n.NOWLOG    ANOP\n@DATA      LOCTR ,\n##STATIC   DS    0D\n           DC    CL32'&MODNAME ##STATIC START'\n#RENTSIZ   DC    AL4(#E_RENT-#PRGAREA)\n           AIF   ('&SETREX' EQ 'N').NOREX\n#RC_SET    MVC   EVALBLOCK_EVDATA(1),0(R1)\n.NOREX     ANOP\n*\n           AIF   ('&USETSTMP' NE 'Y').NOTIME\n*                 2 0 0 2 - 1 2 - 3 1 - 1 2 : 3 6 : 1 2 . 1 2 3 4 5 6\n##DAT_PAT  DC X'F0202020206020206020206020207A20207A20204B202020202020'\n*\n.NOTIME    ANOP\n.*         define list form of WTO for use in WTOX macro\n.*         WTO   TEXT=(R2),ROUTCDE=11,MCSFLAG=HRDCPY\n#PTN_WTO_LIST    DS    0F\n           DC    AL2(8)\n           DC    B'1000001000010000'\n           DC    AL4(0)\n           DC    AL1(2)\n           DC    B'00000000'\n           DC    AL1(0)\n           DC    AL1(104)\n           DC    B'0000000010000000'\n           DC    AL2(0)\n           DC    AL4(0)\n           DC    AL4(0)\n           DC    AL4(0)\n           DC    B'0000000000000000'\n           DC    AL2(0)\n           DC    XL16'00200000000000000000000000000000'\n           DC    B'0000000000000000'\n           DC    AL2(0)\n           DC    CL8'        '\n           DC    CL8'        '\n           DC    CL8'        '\n           DC    AL4(0)\n           DC    AL4(0)\n           DC    CL8'        '\n           DC    CL8'        '\n           DC    AL4(0)\n           DC    AL4(0)\n           DC    AL4(0)\nL_#PTN_WTO_LIST  EQU   *-#PTN_WTO_LIST\n           DS    0D\n*\n.*       If the macro hexpack has been used then include the\n.*       required storage\n               AIF   ('&HEXPCK' NE 'Y').NOHEXP\nHEXPACK_TABLE  DC    X'AABBCCDDEEFF'           C1-C6\n               DC    41X'0'                    C7-EF\n               DC    X'00112233445566778899'   F0-F9\n*\n.NOHEXP        ANOP\n               AIF   ('&XUNPCK' NE 'Y').NOXUNP\nXUNPACK_TAB    DC    C'0123456789ABCDEF'\n*\n.NOXUNP        ANOP\n         MEXIT\n.MNOTE2  MNOTE 50,'You are mixing your macros - PRGDEF PRGEDEF PRGEND'\n         MEND\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PRGSTEM": {"ttr": 1039, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x05\\x00S\\x01\\x17\\x14\\x7f\\x01\\x17\\x16\\x0f\\x12\\x08\\x00!\\x00\\x1e\\x00\\x00\\xe2\\xc4\\xd1\\xd9\\xc7@@@@@'", "ispf": {"version": "01.05", "flags": 0, "createdate": "2017-05-27T00:00:00", "modifydate": "2017-06-09T12:08:53", "lines": 33, "newlines": 30, "modlines": 0, "user": "SDJRG"}, "text": "         MACRO\n         PRGSTEM &DSECT=N,&PREF=STEM\n.*\n.*       This defines storage for calling program PROCSTEM\n.*       which handles the population of a STEM variable\n.*       on behalf of a REXX assembler function\n.*\n         AIF   ('&DSECT' EQ 'Y').DS1D02\n.*\n&PREF._AREA          DS    0D\n.*\n         AGO   .ST1D02\n.*\n.DS1D02  ANOP\n.*\n&PREF._AREA          DSECT\n.*\n.ST1D02  ANOP\n.*\n&PREF._NAME          DS    CL48\n&PREF._NAME_ADR      DS    F\n&PREF._NAME_LEN      DS    F\n&PREF._MID_NAME      DS    CL20\n&PREF._AFT_DOT       DS    F\n&PREF._ZERO_COUNT    DS    PL4\n&PREF._TEXT_ADR      DS    F\n&PREF._TEXT_LEN      DS    F\n&PREF._MAX_LEN       DS    F\n&PREF._FUNCTION      DS    H\n&PREF._TRIM_VAR      DS    C\n&PREF._BLOCK_LEN     EQU   *-&PREF._NAME\n.*\n         MEND\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PUSHINS": {"ttr": 1281, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "      MACRO\n      PUSHINS &PAM\n  GBLA  &CCVAL   COND CODE VARIABLE\n  GBLA  &CTR   MACRO PARAMETER COUNTER\n  GBLA  &SEQ   LABEL NUMBER GENERATOR\n  GBLA  &AI   INDEX FOR TOTAL NO. CASES STK\n  GBLA  &CI   INDEX FOR CASE AND LBL NO. STKS\n  GBLA  &II   PTR TO INST STKS\n  GBLA  &LI   INDEX FOR LABEL NUMBER STK\n  GBLA  &NI   PTR TO NEST STK\n  GBLA  &AIND(50)  TOTAL CASES STK\n  GBLA  &CIND1(200)  CASE NUMBER STK\n  GBLA  &MULT(50)  CASE NUMBER MULTIPLIER\n  GBLA  &ST(51)   INST STK INCREASE AT EACH LEVEL\n  GBLC  &CIND2(200)  LABEL NUMBER STK FOR CASES\n  GBLC  &IIND1(100)  INSTRUCTION STK 1\n  GBLC  &IIND2(100)  INSTRUCTION STK 2\n  GBLC  &I22(100)  INSTRUCTION STK 2, 2ND PART\n  GBLC  &I23(100)  INSTRUCTION STK 2, 3RD PART\n  GBLC  &I24(100)  INSTRUCTION STK 2, 4TH PART\n  GBLC  &IIND3(100)  INSTRUCTION STK 3\n  GBLC  &I32(100)  INSTRUCTION STK 3, 2ND PART\n  GBLC  &I33(100)  INSTRUCTION STK 3, 3RD PART\n  GBLC  &I34(100)  INSTRUCTION STK 3, 4TH PART\n  GBLC  &IIND4(100)  INSTRUCTION STK 4\n  GBLC  &I42(100)  INSTRUCTION STK 4, 2ND PART\n  GBLC  &I43(100)  INSTRUCTION STK 4, 3RD PART\n  GBLC  &IIND5(100)  INSTRUCTION NAME STACK\n  GBLC  &LIND(101)  LABEL NUMBER STK\n  GBLC  &NEST(50)  NESTING STK\n  GBLC  &RIND(50)  REG STK FOR CASENTRY MACRO\n      LCLA &WK,&I,&J,&K\n&I      SETA  3\n&J      SETA  4\n&K      SETA  4\n      AIF ('&PAM(1)'(1,1) EQ 'B' OR '&PAM(1)' EQ 'EQU').BCH\n        AIF ('&PAM(5)' EQ '').TWOPERS\n   AIF ('&PAM(1)'(1,1) EQ 'C').SETK\n&J     SETA  5\n   AGO .GETCOND\n.TWOPERS       AIF ('&PAM(1)'(1,1) NE 'C').SETK\n&I        SETA  4\n&J        SETA  3\n.SETK        ANOP\n&K        SETA  5\n.GETCOND  GETCC &PAM(&J)\n.BCH      AIF   (&II GE 100).OVERI\n&II        SETA  &II+1\n&IIND1(&II)    SETC '&PAM(1)'\n&IIND2(&II)    SETC '&PAM(2)'(1,8)\n&WK    SETA K'&SYSLIST(1,2)\n    AIF (&WK GE 25).LD24\n&I24(&II)    SETC ''\n      AIF (&WK GE 17).LD23\n&I23(&II)      SETC ''\n        AIF (&WK GE 9).LD22\n&I22(&II)  SETC ''\n   AGO .PAM3\n.LD24        ANOP\n.* &I24(&II)   SETC '&PAM(2)'(25,8)   *** OLD STATEMENT\n.* CHANGE SO THAT OPERAND 2 IS NOT TRUNCATED TO 32 CHARACTERS (TSDER)\n&I24(&II)      SETC '&PAM(2)'(25,&WK)\n.LD23      ANOP\n&I23(&II)    SETC '&PAM(2)'(17,8)\n.LD22    ANOP\n&I22(&II)  SETC  '&PAM(2)'(9,8)\n.PAM3    AIF ('&PAM(&I)' NE '').LD31\n&IIND3(&II)  SETC ''\n      AGO  .BLKOUT3\n.LD31    ANOP\n&IIND3(&II)    SETC '&PAM(&I)'(1,8)\n.BLKOUT3   ANOP\n&WK    SETA K'&SYSLIST(1,&I)\n    AIF (&WK GE 25).LD34\n&I34(&II)    SETC ''\n      AIF (&WK GE 17).LD33\n&I33(&II)      SETC ''\n        AIF (&WK GE 9).LD32\n&I32(&II)  SETC ''\n   AGO .PAM4\n.LD34        ANOP\n.* &I34(&II)   SETC '&PAM(&I)'(25,8)    *** OLD STATEMENT\n.* CHANGE SO THAT OPERAND 4 IS NOT TRUNCATED TO 32 CHARACTERS (TSDER)\n&I34(&II)      SETC '&PAM(&I)'(25,&WK)\n.LD33      ANOP\n&I33(&II)    SETC '&PAM(&I)'(17,8)\n.LD32    ANOP\n&I32(&II)  SETC  '&PAM(&I)'(9,8)\n.PAM4    AIF ('&PAM(&K)' NE '').LD41\n&IIND4(&II)  SETC ''\n      AGO  .BLKOUT4\n.LD41    ANOP\n&IIND4(&II)  SETC '&PAM(&K)'(1,8)\n.BLKOUT4   ANOP\n&WK    SETA K'&SYSLIST(1,&K)\n    AIF (&WK GE 17).LD43\n&I43(&II)    SETC ''\n      AIF (&WK GE 9).LD42\n&I42(&II)      SETC ''\n        AGO .PAM5\n.LD43      ANOP\n&I43(&II)    SETC '&PAM(&K)'(17,8)\n.LD42    ANOP\n&I42(&II)  SETC '&PAM(&K)'(9,8)\n.PAM5    AIF ('&PAM(6)' EQ '').BLKOUT5\n      AIF ('&PAM(6)'(1,4) NE '#@LB').BLKOUT5\n&IIND5(&II)    SETC '&PAM(6)'\n      MEXIT\n.BLKOUT5   ANOP\n&IIND5(&II)  SETC ''\n    MEXIT\n.OVERI  MNOTE 8,'INSTRN STK SIZE EXCEEDED. FURTHER EXPANSIONS INVALID'\n  MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "PUSHLAB": {"ttr": 1283, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "  MACRO\n  PUSHLAB\n  GBLA  &CCVAL   COND CODE VARIABLE\n  GBLA  &CTR   MACRO PARAMETER COUNTER\n  GBLA  &SEQ   LABEL NUMBER GENERATOR\n  GBLA  &AI   INDEX FOR TOTAL NO. CASES STK\n  GBLA  &CI   INDEX FOR CASE AND LBL NO. STKS\n  GBLA  &II   PTR TO INST STKS\n  GBLA  &LI   INDEX FOR LABEL NUMBER STK\n  GBLA  &NI   PTR TO NEST STK\n  GBLA  &AIND(50)  TOTAL CASES STK\n  GBLA  &CIND1(200)  CASE NUMBER STK\n  GBLA  &MULT(50)  CASE NUMBER MULTIPLIER\n  GBLA  &ST(51)   INST STK INCREASE AT EACH LEVEL\n  GBLC  &CIND2(200)  LABEL NUMBER STK FOR CASES\n  GBLC  &IIND1(100)  INSTRUCTION STK 1\n  GBLC  &IIND2(100)  INSTRUCTION STK 2\n  GBLC  &I22(100)  INSTRUCTION STK 2, 2ND PART\n  GBLC  &I23(100)  INSTRUCTION STK 2, 3RD PART\n  GBLC  &I24(100)  INSTRUCTION STK 2, 4TH PART\n  GBLC  &IIND3(100)  INSTRUCTION STK 3\n  GBLC  &I32(100)  INSTRUCTION STK 3, 2ND PART\n  GBLC  &I33(100)  INSTRUCTION STK 3, 3RD PART\n  GBLC  &I34(100)  INSTRUCTION STK 3, 4TH PART\n  GBLC  &IIND4(100)  INSTRUCTION STK 4\n  GBLC  &I42(100)  INSTRUCTION STK 4, 2ND PART\n  GBLC  &I43(100)  INSTRUCTION STK 4, 3RD PART\n  GBLC  &IIND5(100)  INSTRUCTION NAME STACK\n  GBLC  &LIND(101)  LABEL NUMBER STK\n  GBLC  &NEST(50)  NESTING STK\n  GBLC  &RIND(50)  REG STK FOR CASENTRY MACRO\n  AIF   (&LI GE 100).OVER\n&SEQ    SETA  &SEQ+1\n&LI    SETA  &LI+1\n&LIND(&LI) SETC '#@LB&SEQ'\n  MEXIT\n.OVER  MNOTE 8,' LABEL STK SIZE EXCEEDED. FURTHER EXPANSIONS INVALID'\n    MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "PUSHNEST": {"ttr": 1285, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "  MACRO\n PUSHNEST &P1\n GBLA &CCVAL       COND CODE VARIABLE\n GBLA &CTR       MACRO PARAMETER COUNTER\n GBLA &SEQ       LABEL NUMBER GENERATOR\n GBLA &AI       INDEX FOR TOTAL NO> CASES STK\n GBLA &CI       INDEX FOR CASE AND LBL NO. STKS\n GBLA &II       PTR TO INST STKS\n GBLA &LI       INDEX FOR LABEL NUMBER STK\n GBLA &NI       PTR TO NEST STK\n GBLA &AIND(50)       TOTAL CASES STK\n GBLA &CIND1(200)      CASE NUMBER STK\n GBLA &MULT(50)       CASE NUMBER MULTIPLIER\n GBLA &ST(51)       INST STK INCREASE AT EACH LEVEL\n GBLC &CIND2(200)      LABEL NUMBER STK FOR CASES\n GBLC &IIND1(100)      INSTRUCTION STK 1\n GBLC &IIND2(100)      INSTRUCTION STK 2\n GBLC &I22(100)       INSTRUCTION STK 2, 2ND PART\n GBLC &I23(100)       INSTRUCTION STK 2, 3RD PART\n GBLC &I24(100)       INSTRUCTION STK 2, 4TH PART\n GBLC &IIND3(100)      INSTRUCTION STK 3\n GBLC &I32(100)       INSTRUCTION STK 3, 2ND PART\n GBLC &I33(100)       INSTRUCTION STK 3, 3RD PART\n GBLC &I34(100)       INSTRUCTION STK 3, 4TH PART\n GBLC &IIND4(100)      INSTRUCTION STK 4\n GBLC &I42(100)       INSTRUCTION STK 4, 2ND PART\n GBLC &I43(100)       INSTRUCTION STK 4, 3RD PART\n GBLC &IIND5(100)      INSTRUCTION NAME STACK\n GBLC &LIND(101)      LABEL NUMBER STK\n GBLC &NEST(50)       NESTING STK\n GBLC &RIND(50)       REG STK FOR CASENTRY MACRO\n&NI  SETA  &NI+1\n  AIF   (&NI GE 50).OVER\n&NEST(&NI) SETC '    &P1'\n  MEXIT\n.OVER  ANOP\n  MNOTE 8,'NEST STACK SIZE EXCEEDED. FURTHER EXPANSIONS INVALID'\n  MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "RUNPK": {"ttr": 2568, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00B\\x01 \\x03\\x1f\\x01 \\x03\\x1f\\x07D\\x00-\\x00-\\x00\\x00\\xe2\\xc4\\xd1\\xd9\\xc7@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2020-01-31T00:00:00", "modifydate": "2020-01-31T07:44:42", "lines": 45, "newlines": 45, "modlines": 0, "user": "SDJRG"}, "text": "         MACRO\n         RUNPK &REG,&OUT\n.**********************************************************************\n.*\n.* Created by John Gateley\n.*\n.*       This macro unpacks a register into hexadecimal format.\n.*\n.*       Warning it updates byte 9 of the output field\n.*       but then blanks it out.\n.*\n.*       RUNPK R13,OUT_TXT\n.*       RUNPK (R13),OUT_TXT\n.*\n.* this is the table that PRGSTAT will define, if not using PRGDEF\n.* and associated macros then define it yourself\n.*\n.* XUNPACK_TAB    DC    C'0123456789ABCDEF'\n.*\n         AIF    (N'&SYSLIST NE 2).BADPARM\n.*\n.* indicate that RUNPK macro was used so that the table can be\n.* defined in PRGSTAT\n         GBLC  &XUNPCK\n&XUNPCK  SETC  'Y'\n.*\n         AIF   ('&REG'(1,1) EQ '(').REGVAL  * reg in parentheses\n         AGO   .NOTREG\n.REGVAL  ANOP\n&INR     SETC  '&REG'(2,K'&REG-2)\n         AGO   .AFTREG\n.*\n.NOTREG  ANOP\n&INR     SETC  '&REG'\n.*\n.AFTREG  ANOP\n         ST    &INR,&OUT               store into first 4 bytes\n         UNPK  &OUT.(9),&OUT.(5)       unpk 5 into 9\n         MVI   &OUT+8,C' '             blank the ninth byte\n         NC    &OUT.(8),=X'0F0F0F0F0F0F0F0F'   clear the zones\n         TR    &OUT.(8),XUNPACK_TAB    convert to displayable\n         MEXIT\n.BADPARM MNOTE 16,'invalid positional parameters, need 2'\n         MEXIT\n         MEND\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "SEGDO": {"ttr": 1287, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x05\\x01\\x17\\x14?\\x01\\x18&\\x7f\\x10!\\x00\\x17\\x00\\x12\\x00\\x00\\xe2\\xc4\\xd1\\xd9\\xc7@@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2017-05-23T00:00:00", "modifydate": "2018-09-24T10:21:05", "lines": 23, "newlines": 18, "modlines": 0, "user": "SDJRG"}, "text": "         MACRO\n         SEGDO &NAME\n.*\n.* CREATED BY JOHN GATELEY\n.*\n         GBLC  &SEGNAM\n.*\n         AIF   ('&NAME' EQ '').MNOTE1\n         AIF   ('&SEGNAM' EQ '##&NAME').MNOTE2\n.*\n           AIF   ('&NAME' NE 'WRITE_LOG').NOWLOG\n           GBLC  &WRTLOGU\n&WRTLOGU   SETC  'Y'\n.NOWLOG    ANOP\n.*\n         BRAS  R14,##&NAME\n.*\n         MEXIT\n.MNOTE1  MNOTE 8,'SEGMENT NAME OMITTED'\n         MEXIT\n.MNOTE2  MNOTE 8,'THE SEGMENT SPECIFIED IS THE CURRENT ONE'\n         MEXIT\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "SEGE": {"ttr": 1289, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x01\\x00P\\x01\\x17\\x14?\\x01\\x175\\x7f\\x16'\\x00,\\x00,\\x00\\x00\\xe2\\xc4\\xd1\\xd9\\xc7@@@@@\"", "ispf": {"version": "01.01", "flags": 0, "createdate": "2017-05-23T00:00:00", "modifydate": "2017-12-23T16:27:50", "lines": 44, "newlines": 44, "modlines": 0, "user": "SDJRG"}, "text": "           MACRO\n           SEGE  &NAME\n.*\n.* Created by John Gateley\n.*\n           GBLC  &SEGSAVA\n           GBLC  &SEGNAM\n           GBLA  &SEGCNT\n           GBLC  &SCBASER\n           GBLA  &SCBASEC\n           GBLC  &BASSAVA\n           LCLA  &SEGNO\n.*\n           AIF   ('&SEGSAVA' EQ '').MNOTE3\n           AIF   ('&NAME' EQ '').MNOTE1\n           AIF   ('&SEGNAM' NE '##&NAME').MNOTE2\n.*\n&SEGNAM    SETC  ''\n&SEGNO     SETA  &SEGCNT-1\n.*\n           L     R14,&SEGSAVA+(4*&SEGNO)\n           AIF   ('&SCBASER' EQ 'N').NOCBASE\n           AIF   ('&SCBASER' EQ '').NOCBASE\n           AIF   ('&BASSAVA' EQ '').MNOTE4\n#END_CBASE_&SCBASEC  DS    0H\n           L     &SCBASER,&BASSAVA+(4*&SEGNO)\n           DROP  &SCBASER\n.NOCBASE   ANOP\n           BR    R14\n           EJECT\n.*\n           MEXIT\n.MNOTE1    MNOTE 8,'segment name omitted'\n           MEXIT\n.*\n.MNOTE2    MNOTE 8,'segment name does not match previous'\n           MEXIT\n.*\n           MEXIT\n.MNOTE3    MNOTE 8,'macro variable \"SEGSAVA\" has not been set'\n           MEXIT\n.MNOTE4    MNOTE 8,'macro variable \"BASSAVA\" has not been set'\n           MEXIT\n           MEND\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SEGQUIT": {"ttr": 1291, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00P\\x01\\x17\\x14?\\x01\\x17\\x14?\\x11\\x19\\x00!\\x00!\\x00\\x00\\xe2\\xc4\\xd1\\xd9\\xc7@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2017-05-23T00:00:00", "modifydate": "2017-05-23T11:19:50", "lines": 33, "newlines": 33, "modlines": 0, "user": "SDJRG"}, "text": "           MACRO\n           SEGQUIT\n.*\n.* Created by John Gateley\n.*\n           GBLC  &SEGSAVA\n           GBLA  &SEGCNT\n           GBLC  &SCBASER\n           GBLA  &SCBASEC\n           GBLC  &BASSAVA\n           LCLA  &SEGNO\n.*\n           AIF   ('&SEGSAVA' EQ '').MNOTE1\n           AIF   ('&SEGCNT' EQ '0').MNOTE2\n.*\n&SEGNO     SETA  &SEGCNT-1\n.*\n           L     R14,&SEGSAVA+(4*&SEGNO)\n           AIF   ('&SCBASER' EQ 'NO').NOCBASE\n           AIF   ('&SCBASER' EQ '').NOCBASE\n           AIF   ('&BASSAVA' EQ '').MNOTE3\n           L     &SCBASER,&BASSAVA+(4*&SEGNO)\n.NOCBASE   ANOP\n           BR    R14\n.*\n           MEXIT\n.MNOTE1    MNOTE 8,'macro variable \"SEGSAVA\" has not been set'\n           MEXIT\n.MNOTE2    MNOTE 8,'you are not actually in a segment'\n           MEXIT\n.MNOTE3    MNOTE 8,'macro variable \"BASSAVA\" has not been set'\n           MEXIT\n           MEND\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SEGS": {"ttr": 1293, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x05\\x01\\x17\\x14?\\x01\\x18&\\x7f\\x10\"\\x005\\x000\\x00\\x00\\xe2\\xc4\\xd1\\xd9\\xc7@@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2017-05-23T00:00:00", "modifydate": "2018-09-24T10:22:05", "lines": 53, "newlines": 48, "modlines": 0, "user": "SDJRG"}, "text": "           MACRO\n           SEGS &NAME\n.*\n.* Created by John Gateley\n.*\n           GBLC  &SEGSAVA\n           GBLC  &BASSAVA\n           GBLC  &SEGNAM\n           GBLA  &SEGCNT\n           GBLA  &SEGMAX\n           GBLC  &SCBASER\n           GBLA  &SCBASEC\n           AIF   (&SEGMAX NE 0).MAXOK\n&SEGMAX    SETA  50\n.MAXOK     ANOP\n.*\n           AIF   ('&SEGSAVA' EQ '').MNOTE4\n           AIF   ('&SEGNAM' NE '').MNOTE1\n           AIF   ('&NAME' EQ '').MNOTE2\n           AIF   (&SEGCNT EQ &SEGMAX).MNOTE3\n.*\n&SEGNAM    SETC  '##&NAME'\n.*\n           AIF   ('&NAME' NE 'WRITE_LOG').NOWLOG\n           GBLC  &WRTLOGD\n&WRTLOGD   SETC  'Y'\n.NOWLOG    ANOP\n.*\n           DC    H'0'           STOP A FALL INTO THIS SEG\n&SEGNAM    ST    R14,&SEGSAVA+(4*&SEGCNT)\n           AIF   ('&SCBASER' EQ 'N').NOCBASE\n           AIF   ('&SCBASER' EQ '').NOCBASE\n           AIF   ('&BASSAVA' EQ '').MNOTE5\n&SCBASEC   SETA  1+&SCBASEC\n           ST    &SCBASER,&BASSAVA+(4*&SEGCNT)\n           BASR  &SCBASER,0\n           USING (*,#END_CBASE_&SCBASEC),&SCBASER\n.NOCBASE   ANOP\n.*\n&SEGCNT    SETA  1+&SEGCNT\n.*\n           MEXIT\n.MNOTE1    MNOTE 8,'missing SEGE macro, or duplicate SEGS macro'\n           MEXIT\n.MNOTE2    MNOTE 8,'SEGS name omitted'\n           MEXIT\n.MNOTE3    MNOTE 8,'maximum segments exceeded '\n           MEXIT\n.MNOTE4    MNOTE 8,'macro variable \"SEGSAVA\" has not been set'\n           MEXIT\n.MNOTE5    MNOTE 8,'macro variable \"BASSAVA\" has not been set'\n           MEXIT\n           MEND\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SETRC": {"ttr": 1295, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x15\\x01\\x17\\x14?\\x01\\x17\\x14?\\x11 \\x00\\x1b\\x00\\x1b\\x00\\x00\\xe2\\xc4\\xd1\\xd9\\xc7@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2017-05-23T00:00:00", "modifydate": "2017-05-23T11:20:15", "lines": 27, "newlines": 27, "modlines": 0, "user": "SDJRG"}, "text": "           MACRO\n           SETRC &RC=0,&COND=N\n.*\n.* Created by John Gateley\n.*\n           AIF   ('&RC' EQ '0').MAKE0\n           AIF   ('&COND' EQ 'N').NOCOND\n           AIF   ('&COND' NE 'Y').MNOTE1\n           CLI   R_C+3,&RC\n           BH    RC&SYSNDX\n           MVI   R_C+3,&RC\nRC&SYSNDX  DS    0H\n           MEXIT\n.*\n.MAKE0     ANOP\n           XC    R_C,R_C\n           MEXIT\n.*\n.NOCOND    ANOP\n           XC    R_C,R_C\n           MVI   R_C+3,&RC\n           MEXIT\n.*\n.*\n           MEXIT\n.MNOTE1    MNOTE 16,'COND parameter was not Y or N'\n           MEND\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "STKINS": {"ttr": 1297, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "         MACRO\n         STKINS &P1,&P2,&P3,&P4,&P5,&P6\n         COPY  GBLVARS\n         LCLC  &SIGN\n.*\n.* AUGUST 2014 - JOHN GATELEY - ADD SUPPORT FOR TAM AND TP\n.*\n         AIF    ('&P1(2)' EQ '').NOTSUBL\n           AIF ('&P1(6)' EQ '' OR '&P1(6)' EQ '&LIND(&LI)').OKSUBL\n             MNOTE 12,'TOO MANY OPERANDS INSIDE PARENTHESES'\n             MEXIT\n.OKSUBL  AIF   ('&P1(1)' EQ 'TP').TPST\n         AIF   ('&P1(1)' EQ 'TAM').TAM24\n         AIF   ('&P1(3)' EQ '').FILE\n         PUSHINS (&P1(1),&P1(2),&P1(3),&P1(4),&P1(5),&P1(6))\n             MEXIT\n.NOTSUBL AIF   ('&P2' EQ '' OR '&P2' EQ 'OR' OR '&P2' EQ 'AND' OR '&P2'X\n               EQ 'ORIF' OR '&P2' EQ 'ANDIF').SGLOPR\n           AIF ('&P5' EQ 'OR' OR '&P5' EQ 'AND' OR '&P5' EQ 'ORIF' OR  X\n               '&P5' EQ 'ANDIF').TWOPER2\n             PUSHINS (&P1,&P2,&P3,&P4,&P5,&P6)\n&CTR         SETA  &CTR+4\n             MEXIT\n.TWOPER2   PUSHINS (&P1,&P2,&P3,&P4,,&P6)\n&CTR         SETA  &CTR+3\n             MEXIT\n.FILE    AIF   ('&P1(1)'(1,1) EQ '(').FILE1\n&SIGN    SETC  '+'\n.FILE1   AIF   ('&P1(2)' NE 'OPEN').FILE2\n         PUSHINS (TM,X'30'&SIGN&P1(1),X'10',O,&P1(5),&P1(6))\n         MEXIT\n.FILE2   AIF   ('&P1(2)' NE 'NOTOPEN').FILE3\n         PUSHINS (TM,X'30'&SIGN&P1(1),X'10',Z,&P1(5),&P1(6))\n         MEXIT\n.FILE3   AIF   ('&P1(2)' NE 'EOF').FILE4\n         PUSHINS (TM,X'30'&SIGN&P1(1),X'04',O,&P1(5),&P1(6))\n         MEXIT\n.FILE4   AIF   ('&P1(2)' NE 'NOTEOF').FILE5\n         PUSHINS (TM,X'30'&SIGN&P1(1),X'04',Z,&P1(5),&P1(6))\n         MEXIT\n.FILE5   AIF   ('&P1(2)' NE 'ENDPROG').FILE6\n         PUSHINS (CLC,&P1(1),NE,=F'-1',&P1(5),&P1(6))\n         MEXIT\n.FILE6   AIF   ('&P1(2)' NE 'NOTENDPROG').FILE7\n         PUSHINS (CLC,&P1(1),EQ,=F'-1',&P1(5),&P1(6))\n         MEXIT\n.FILE7   AIF   ('&P1(2)' NE 'INERROR').FILE8\n         PUSHINS (CLC,&P1(1),NE,=F'0',&P1(5),&P1(6))\n         MEXIT\n.FILE8   AIF   ('&P1(2)' NE 'NOTINERROR').FILE9\n         PUSHINS (CLC,&P1(1),EQ,=F'0',&P1(5),&P1(6))\n         MEXIT\n.FILE9   AIF   ('&P1(2)' NE 'SYNAD').FILE10\n         PUSHINS (TM,X'2C'&SIGN&P1(1),X'30',O,&P1(5),&P1(6))\n         MEXIT\n.FILE10  AIF   ('&P1(2)' NE 'NOTSYNAD').FILE11\n         PUSHINS (TM,X'2C'&SIGN&P1(1),X'30',Z,&P1(5),&P1(6))\n         MEXIT\n.FILE11  ANOP\n         PUSHINS (TM,0(0),X'00',O,&P1(5),&P1(6))\n         MNOTE 12,'INVALID INSTRUCTION &P1(1),&P1(2) - NOP GENERATED'\n         MEXIT\n.*\n.TPST    ANOP\n         PUSHINS (&P1(1),&P1(2),,&P1(3))\n         MEXIT\n.*\n.TAM24   AIF   ('&P1(2)' NE '24').TAM31\n         PUSHINS (&P1(1),*24,,8)\n         MEXIT\n.TAM31   AIF   ('&P1(2)' NE '31').TAM64\n         PUSHINS (&P1(1),*31,,4)\n         MEXIT\n.TAM64   AIF   ('&P1(2)' NE '64').TAMERR\n         PUSHINS (&P1(1),*64,,1)\n         MEXIT\n.TAMERR  ANOP\n         MNOTE 12,'TAM CAN ONLY TEST 24 31 OR 64'\n         MEXIT\n.*\n.SGLOPR  GETCC  &P1(1)\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "STRING": {"ttr": 1537, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "         MACRO\n         STRING  &OUT=MESS_TXT,&WORK=,&SAVE=MY_PARM,&SLEN=0,           /\n               &PAD=,&PADB=N,&FPAD=0,&NUM0=N\n.**********************************************************************\n.*\n.*       This macro uses program STRINGIT to concatenate the values\n.*       of fields into an area.\n.*\n.*       This macro takes positional parameters in groups of two,\n.*       as many as required. Followed by keyword parameters as\n.*       detailed below.\n.*\n.*       The repeated values are field-name and C,X,B,P,I,U,S or V\n.*         C means just copy it (character)\n.*         X means output hexadecimal display\n.*         B means output binary display\n.*         P means packed decimal input, output numeric display\n.*         I Fullword integer, output numeric display\n.*         U Unsigned fullword integer, output numeric display\n.*         S Halfword small integer, output numeric display\n.*         V Unsigned halfword small integer, output numeric display\n.*\n.*       STRING (field1,c,field2,x,(R4),x),OUT=MESS_TXT,WORK=CL32\n.*\n.*       OUT=    the area in which the string is to be built\n.*\n.*       WORK=   a 32 byte work area for program STRINGIT\n.*       If this is not provided a global macro variable STRWRK\n.*       will be used as the work area. If neither of these is\n.*       provided the macro will fail to expand.\n.*       GBLC  &STRWRK\n.*\n.*\n.*       If the value to be displayed is in a register just use\n.*       register notation in the macro i.e. (R6) and use X or I\n.*       depending on how you want to view the contents\n.*\n.*       STRING (field1,c,(R3),x,(R4),i),OUT=MESS_TXT,PAD=|\n.*\n.*       Note that if you want to use the value of a 64 bit\n.*       register you will need to use STG to place the value into\n.*       an 8 byte field and use that in the macro.\n.*       This is because the actual register value is stored in the\n.*       parameter list instead of an address and the parameter\n.*       list consists of 32 bit words.\n.*\n.*       If the PAD= parameter is specified a pad byte will be\n.*       included between each field which will contain the specified\n.*       value.\n.*       PADB=Y means have a pad byte but make it C' '\n.*       PADB takes precedence over the PAD= macro parameter\n.*\n.*       FPAD is the number of pad bytes to be put at the start\n.*       of the output area, this is to allow the text to be indented.\n.*       Using OUT=MESS_TXT+2 instead of FPAD=2 is not recomended as\n.*       although it will indent by 2 it will cause the macro to think\n.*       that the output field is 4 bytes longer than it is.\n.*       LA    R15,L'MESS_TXT+2 will take the length and add 2 to it\n.*       when the effective length should be L'MESS_TXT-2\n.*\n.*       NUM0=N means do not output leading zeroes from numeric display\n.*       change to Y if you want leading zeroes.\n.*\n.*       If the output message area is not big enough for all the\n.*       required fields then program STRINGIT will abend with a\n.*       suitable message. As the length of the strung output\n.*       will not vary, if this works in test it will work in\n.*       production.\n.*\n.*       The SAVE= parameter specifies an area in which the macro\n.*       builds the parameter list for the call to STRINGIT, this\n.*       defaults to MY_PARM.\n.*\n.*       Note that the last parameter will not have the high order\n.*       bit set on as STRINGIT processing stops when the value\n.*       x'FF' is found in the indicator list. This is because a\n.*       register value could be negative.\n.*\n.*       SLEN= may be used to specify the number of fullwords\n.*       available in the parameter list, this ensures that\n.*       storage after the end of the parameter list is not\n.*       overwritten.\n.*       If this is not provided a global macro variable PARMAX\n.*       will be used as the count of fullwords. If neither of\n.*       these is provided the macro will fail to expand.\n.*\n.*       GBLA  &PARMAX\n.*&PARMAX    SETA  18\n.*\n.*\n.*       After the macro call STRINGIT R1 will contain the address\n.*       of the byte after the last one modified. R15 will be zero.\n.*\n.*       Note that this macro and the STRINGIT program are reentrant.\n.*\n.*\n.*       End of comments, down to business.\n.*\n.*\n&A       SETA  N'&SYSLIST(1)             * get count of values in ( )\n&B       SETA  &A/2                      * divide by 2\n&C       SETA  1\n&D       SETA  1\n&E       SETA  6                         * minimum 6 parameters\n&F       SETA  &B*2                      * multiply by 2\n         AIF   (&F NE &A).NOTEVEN        * not equal means not even\n.*\n         LCLC  &INDS\n         LCLA  &PARMS\n         GBLA  &PARMAX\n         GBLC  &STRWRK\n.*\n         AIF   ('&NUM0' EQ 'Y').NUMOK    * Y is OK\n         AIF   ('&NUM0' EQ 'N').NUMOK    * N is OK\n         AGO   .BADNUM\n.NUMOK   ANOP\n.*\n&PARMS   SETA  &PARMAX\n         AIF   ('&SLEN' EQ '0').NOTSLEN  * default to PARMAX\n&PARMS   SETA  &SLEN\n.NOTSLEN ANOP\n         AIF   (&PARMS EQ 0).NOLEN       * flag expansion error\n         AIF   (&PARMS LT 6).TOOMUCH     * filled up parameter area\n.*\n         AIF   (T'&OUT EQ 'O').NOOUT     * output area provided\n.*\n         AIF   (T'&WORK NE 'O').YESWORK  * work area provided\n         AIF   ('&STRWRK' NE '').STWORK  * default to STRWRK\n         AGO   .NOWORK\n.YESWORK ANOP\n&WRK     SETC  '&WORK'                   * use provided work area\n         AGO   .AFTWORK\n.STWORK  ANOP\n&WRK     SETC  '&STRWRK'\n.AFTWORK ANOP\n.*\n.*       first put in the address of the indicators, followed by\n.*       the start and length of the output area and finally\n.*       the work area address.\n.*\n         LA    R14,I&SYSNDX              * point to list of indicators\n         LA    R15,&OUT                  * address of output string\n         LA    R0,L'&OUT                 * length of output string\n         LA    R1,&WRK                   * work area for STRINGIT\n         STM   R14,R1,&SAVE              * save in parameters 1,2,3 + 4\n         LA    R1,&SAVE+16               * point to fifth parameter\n.*\n.AGAIN   ANOP\n.*                                       * is value in a register?\n&RVAL    SETC  '&SYSLIST(1,&C)'\n         AIF   ('&RVAL'(1,1) EQ '(').REGVAL\n.*                                       * not register notation\n         AIF   ('&RVAL'(1,1) EQ '''').QUOTVAL\n.*                                       * not quoted string\n         LA    R14,&SYSLIST(1,&C)        * sending field\n         LA    R15,L'&SYSLIST(1,&C)      * length\n         AGO   .AFTREG\n.*\n.QUOTVAL ANOP\n&QLEN    SETA  K'&RVAL-2\n         LA    R14,=C&RVAL\n         LA    R15,&QLEN\n         AGO   .AFTREG\n.*\n.REGVAL  ANOP\n&RVAL2   SETC  '&SYSLIST(1,&C)'(2,K'&SYSLIST(1,&C)-2)\n.*                                       * register notation\n         LR    R14,&RVAL2                * copy register value\n         LHI   R15,-4                    * say -4 to show in register\n.*\n.AFTREG  ANOP\n         STM   R14,R15,0(R1)             * save in parameter list\n.*\n         AIF   ('&D' GE '&B').DONE1      * done last value?\n&C       SETA  &C+2\n&D       SETA  &D+1\n&E       SETA  &E+2\n         AIF   (&E GT &PARMS).TOOMUCH    * filled up parameter area\n.DONE0   ANOP\n         LA    R1,8(,R1)                 * point past these two\n         AGO   .AGAIN                    * process next value\n.DONE1   ANOP\n.*\n&A       SETA  N'&SYSLIST(1)             * get count of values\n&B       SETA  &A/2                      * divide by 2\n&C       SETA  1\n&D       SETA  1\n         B     A#&SYSNDX                 * branch past indicators\n.*\n.*   This code builds a string containing all the specified format\n.*   indicators.\n.*\n.AGAIN2  ANOP\n.*\n         AIF   ('&SYSLIST(1,&C+1)' EQ 'C').CHAR\n         AIF   ('&SYSLIST(1,&C+1)' EQ 'c').CHAR\n         AIF   ('&SYSLIST(1,&C+1)' EQ 'X').HEX\n         AIF   ('&SYSLIST(1,&C+1)' EQ 'x').HEX\n         AIF   ('&SYSLIST(1,&C+1)' EQ 'B').BINARY\n         AIF   ('&SYSLIST(1,&C+1)' EQ 'b').BINARY\n         AIF   ('&SYSLIST(1,&C+1)' EQ 'P').PACKED\n         AIF   ('&SYSLIST(1,&C+1)' EQ 'p').PACKED\n         AIF   ('&SYSLIST(1,&C+1)' EQ 'I').INTEGER\n         AIF   ('&SYSLIST(1,&C+1)' EQ 'i').INTEGER\n         AIF   ('&SYSLIST(1,&C+1)' EQ 'U').UINT\n         AIF   ('&SYSLIST(1,&C+1)' EQ 'u').UINT\n         AIF   ('&SYSLIST(1,&C+1)' EQ 'S').SMALL\n         AIF   ('&SYSLIST(1,&C+1)' EQ 's').SMALL\n         AIF   ('&SYSLIST(1,&C+1)' EQ 'V').USMALL\n         AIF   ('&SYSLIST(1,&C+1)' EQ 'v').USMALL\n         AGO   .NEITHER                  * not valid\n.CHAR    ANOP\n&INDS    SETC  '&INDS.C'                 * say character\n         AGO   .DONE3\n.HEX     ANOP\n&INDS    SETC  '&INDS.X'                 * say hexadecimal\n         AGO   .DONE3\n.BINARY  ANOP\n&INDS    SETC  '&INDS.B'                 * say binary\n         AGO   .DONE3\n.PACKED  ANOP\n&INDS    SETC  '&INDS.P'                 * say packed decimal\n         AGO   .DONE3\n.INTEGER ANOP\n&INDS    SETC  '&INDS.I'                 * say integer\n         AGO   .DONE3\n.UINT    ANOP\n&INDS    SETC  '&INDS.U'                 * say unsigned integer\n         AGO   .DONE3\n.SMALL   ANOP\n&INDS    SETC  '&INDS.S'                 * say small integer\n         AGO   .DONE3\n.USMALL  ANOP\n&INDS    SETC  '&INDS.V'                 * say unsigned small integer\n         AGO   .DONE3\n.DONE3   ANOP\n.*\n         AIF   ('&D' GE '&B').DONE4      * done last value?\n&C       SETA  &C+2\n&D       SETA  &D+1\n         AGO   .AGAIN2                   * process next value\n.DONE4   ANOP\n.*\n         AIF   ('&PADB' EQ 'N').TRYPAD\n&UPAD    SETC  'Y '                      * pad with a blank\n         AGO   .ENDPAD\n.TRYPAD  ANOP\n         AIF   (T'&PAD NE 'O').USEPAD    * use provided pad char\n&UPAD    SETC  'N '                      * no padding\n         AGO   .ENDPAD\n.USEPAD  ANOP\n&UPAD    SETC  'Y&PAD'                   * use pad character and value\n.ENDPAD  ANOP\n.*\nI&SYSNDX DC    CL15'&UPAD&FPAD&NUM0'     * Currently 4 bytes of global\n.*                                       * indicators but allow for 15\n         DC    C'&INDS'                  * output all the indicators\n         DC    X'FF'                     * flag end of indicators\nA#&SYSNDX      DS    0H\n         LA    R1,&SAVE                  * point to parameters\n         L     R15,=V(STRINGIT)          * get string routine address\n         BASR  R14,R15                   * and go there\n         MEXIT\n.NOTEVEN MNOTE 16,'Number of positional parameters not even'\n         MEXIT\n.NOOUT   MNOTE 16,'No output area provided OUT='\n         MEXIT\n.BADNUM  MNOTE 16,'NUM0 not equal to Y or N'\n         MEXIT\n.NEITHER MNOTE 16,'Second value must be C,X,B,P,I,U,S or V'\n         MEXIT\n.TOOMUCH MNOTE 16,'Too many values for supplied parameter area'\n         MEXIT\n.NOLEN   MNOTE 16,'Length of parameter area not supplied, SLEN='\n         MEXIT\n.NOWORK  MNOTE 16,'No work area was provided, WORK='\n         MEND\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "STRINGIT": {"ttr": 1539, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x001\\x01\\x17\\x06\\x8f\\x01\\x17\\x14?\\x11 \\x01\\x82\\x01\\x82\\x00\\x00\\xe2\\xc4\\xd1\\xd9\\xc7@@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2017-03-09T00:00:00", "modifydate": "2017-05-23T11:20:31", "lines": 386, "newlines": 386, "modlines": 0, "user": "SDJRG"}, "text": "STRINGIT CSECT\nSTRINGIT AMODE 31\nSTRINGIT RMODE ANY\n*\n* Created by John Gateley\n*\n*   This program is used by the STRING macro to convert fields\n*   to the required format and to put them into the output area.\n*\n*   Note that on return from this program register 1 contains the\n*   address of the byte in the output area after the strung data.\n*\n*   Input parameters generated by the STRING macro are\n*     1, address of a series of format indicators terminated by x'FF'\n*     2, address of output area\n*     3, length of the output area\n*     4, address of a 32 byte work area\n*\n*     5, address of input field\n*     6, length of input field\n*\n*   Parameters 5 and 6 repeat for as many indicators as there are in\n*   the list pointed to by parameter 1\n*\n*   note that this program does not have it's own save area because\n*   it does not call anything and it needs to be re-entrant\n*\n         SAVE  (14,12)                   * save callers registers\n         PRINT OFF\n         YREGS\n         PRINT ON\n         LR    R12,R15                   * copy base address\n         USING STRINGIT,R12\n         LR    R10,R1                    * copy parameter address\n         LM    R3,R6,0(R10)              * load first 4 parameters\n*                              R3    string of output indicators\n*                              R4    address of output field\n*                              R5    length of output field\n*                              R6    work area in caller\n         USING WORKAREA,R6\n         MVC   GLOB_IND,0(R3)        * copy global indicators\n         LA    R3,L'GLOB_IND(,R3)    * point passed global indicators\n         AR    R5,R4                 * point after output field\n         LA    R7,16(,R10)     R7    * point to first address/length\n*\n         CLI   PAD_FRST,C'0'\n         BNH   GO_AGAIN              * no initial pad char\n         PACK  DOUB_WORD,PAD_FRST\n         CVB   R1,DOUB_WORD\n         LA    R4,0(R1,R4)           * point passed initial pad char\n*\nGO_AGAIN DS    0H\n         LM    R8,R9,0(R7)           Get details of next field\n*\n*        if the length in R9 is negative it means that R8 contains\n*        the value to be displayed not the address of the value\n*\n         LTR   R9,R9                     * test R9\n         BP    IS_POS                    * if positive then use it\n         LPR   R9,R9                     * make positive\n         ST    R8,FULL_WORD              * save 32 bit value\n         LA    R8,FULL_WORD              * and point to it\n*\nIS_POS   DS    0H\n*\n         CLI   0(R3),C'X'                * Hex output required\n         BE    HEX_OUT\n*\n         CLI   0(R3),C'B'                * Binary output required\n         BE    BIN_OUT\n*\n         CLI   0(R3),C'P'                * Pack output required\n         BE    PACK_OUT\n*\n         CLI   0(R3),C'I'                * Integer output required\n         BE    INT_OUT\n*\n         CLI   0(R3),C'U'                * Unsigned integer required\n         BE    UINT_OUT\n*\n         CLI   0(R3),C'S'                * Small Int output required\n         BE    SINT_OUT\n*\n         CLI   0(R3),C'V'                * Small unsigned int required\n         BE    VINT_OUT\n*\n*        assume it must be character\n*\n*        Just copy the character value to the output area\n*\nCHAR_OUT DS    0H\n         LA    R1,0(R9,R4)               * point after receiving\n         CR    R1,R5                     * is the output full\n         BNL   OVERFLOW                  * yes error\n*\n         BCTR  R9,0                      * -1 for execute\n         EX    R9,MVC_IT                 * execute the move\n         LA    R4,1(R9,R4)               * point past data copied\n         B     DONE_IT\n*\n*        Take the value and convert to hexadecimal display\n*\nHEX_OUT  DS    0H\n         LR    R2,R9                     * copy sending length\n         SLL   R2,1                      * multiply by 2\n         LA    R1,0(R2,R4)               * point after receiving\n         CR    R1,R5                     * is the output full\n         BNL   OVERFLOW                  * yes error\n*\nHEX_OUT1 DS    0H\n         MVC   WORK2(1),0(R8)            * copy one byte\n         UNPK  WORK3,WORK2               * UNPK two bytes to three\n         TR    WORK3(2),TR_TAB-240       * convert to displayable\n         MVC   0(2,R4),WORK3             * copy to receiver\n         LA    R4,2(,R4)                 * move past output bytes\n         LA    R8,1(,R8)                 * move past input byte\n         BCT   R9,HEX_OUT1               * do next byte\n         B     DONE_IT\n*\n*        Take the value and convert to binary display\n*        This puts the byte into the low byte of register 1 and then\n*        for each iteration of the inner loop moves the next bit into\n*        the low bit of byte three of the register and stores it.\n*        So as the loop progresses the bit values become bytes in\n*        the output string.\n*\nBIN_OUT  DS    0H\n         LR    R2,R9                     * copy sending length\n         SLL   R2,3                      * multiply by 8\n         LA    R1,0(R2,R4)               * point after receiving\n         CR    R1,R5                     * is the output full\n         BNL   OVERFLOW                  * yes error\n*\nBIN_OUT1 DS    0H\n         IC    R1,0(R8)                  * get a byte\n         LR    R14,R4                    * copy output address\n         LA    R15,8                     * 8 bits to a byte\n*\nBIN_OUT2 DS    0H\n         SLA   R1,1                      * slide left 1 bit\n         STCM  R1,2,0(R14)               * store third byte\n         NI    0(R14),1                  * switch of all but right bit\n         LA    R14,1(,R14)               * next output byte\n         BCT   R15,BIN_OUT2              * process next bit\n*\n         OC    0(8,R4),ZONES             * make zoned decimal\n         LA    R4,8(,R4)                 * move past output bytes\n         LA    R8,1(,R8)                 * move past input byte\n         BCT   R9,BIN_OUT1               * do next byte\n         B     DONE_IT\n*\n*        Input is packed convert to numeric display\n*\nPACK_OUT DS    0H\n         LR    R2,R9                     * copy sending length\n         SLL   R2,1                      * multiply by 2\n         LA    R1,0(R2,R4)               * point after receiving\n         CR    R1,R5                     * is the output full\n         BNL   OVERFLOW                  * yes error\n*\n         CHI   R9,8                      * cannot unpk > 8 bytes\n         BH    PACKLONG                  * so abend\n         LR    R1,R9                     * get length of field\n         BCTR  R1,0                      * less 1 for execute\n         LR    R15,R1                    * copy for CP\n         SLL   R15,4                     * left one nibble\n         LR    R2,R9                     * get length of field\n         BCTR  R2,0                      * subtact for EX and sign\n         SLL   R2,1                      * multiply by 2\n         LA    R14,0(R2,R4)              * position to last digit\n         SLL   R2,4                      * left one nibble\n         OR    R1,R2                     * merge lengths\n         EX    R1,UNPK_IT                * unpack data\n         OI    0(R14),X'F0'              * make last digit numeric\n         EX    R15,CP_IT                 * check if negative\n         BL    P_NEG                     * branch negative\n         MVI   1(R14),C'+'\n         B     P_DONE\nP_NEG    DS    0H\n         MVI   1(R14),C'-'\nP_DONE   DS    0H\n*\n*        the following code is to remove leading zeroes, I know I\n*        could have built an edit pattern and executed an edit\n*        instruction but I thought this was easier. Also having a pad\n*        character would increase the size of the output field.\n*\n         CLI   NUM_ZERO,C'Y'             * show leading zeroes\n         BE    P_DONEX                   * they are there\n         LR    R1,R4                     * get address of output\n         LR    R2,R9                     * get length of field\n         BCTR  R2,0                      * subtract 1\n         SLL   R2,1                      * multiply by 2\nP_CHK0   CLI   0(R1),C'0'                * is this byte zero\n         BNE   P_DONEX                   * no so job done\n         MVI   0(R1),C' '                * blank it\n         LA    R1,1(,R1)                 * next byte\n         BCT   R2,P_CHK0                 * check next\nP_DONEX  DS    0H\n         LA    R4,2(,R14)                * move past output bytes\n         B     DONE_IT\n*\n*        Input is integer convert to numeric display\n*\nINT_OUT  DS    0H\n         LA    R1,11(,R4)                * point after receiving\n         CR    R1,R5                     * is the output full\n         BNL   OVERFLOW                  * yes error\n*\n         L     R1,0(R8)                  * get integer value\n         CVD   R1,DOUB_WORD\n         CP    DOUB_WORD,=P'0'\n         BL    I_NEG\n         MVI   10(R4),C'+'\n         B     I_DONE\nI_NEG    DS    0H\n         MVI   10(R4),C'-'\nI_DONE   DS    0H\n         OI    DOUB_WORD+7,X'0F'\n         UNPK  0(10,R4),DOUB_WORD\n         CLI   NUM_ZERO,C'Y'             * show leading zeroes\n         BE    I_DONEX                   * they are there\n         LR    R1,R4                     * get address of output\n         LA    R2,9                      * get length to check\nI_CHK0   CLI   0(R1),C'0'                * is this byte zero\n         BNE   I_DONEX                   * no so job done\n         MVI   0(R1),C' '                * blank it\n         LA    R1,1(,R1)                 * next byte\n         BCT   R2,I_CHK0                 * check next\nI_DONEX  DS    0H\n         LA    R4,11(,R4)                * move past output bytes\n         B     DONE_IT\n*\n*        Input is un-signed integer convert to numeric display\n*\nUINT_OUT DS    0H\n         LA    R1,10(,R4)                * point after receiving\n         CR    R1,R5                     * is the output full\n         BNL   OVERFLOW                  * yes error\n*\n         L     R1,0(R8)                  * get integer value\n         SRL   R1,1                      * divide by 2\n         CVD   R1,DOUB_WORD              * convert to decimal\n         MP    DOUB_WORD,=P'2'           * multiply by 2\n         TM    3(R8),X'01'               * was low bit on\n         BZ    U_DONE\n         AP    DOUB_WORD,=P'1'           * add the one back in\nU_DONE   DS    0H\n         OI    DOUB_WORD+7,X'0F'         * set the sign\n         UNPK  0(10,R4),DOUB_WORD        * unpack the value\n         CLI   NUM_ZERO,C'Y'             * show leading zeroes\n         BE    U_DONEX                   * they are there\n         LR    R1,R4                     * get address of output\n         LA    R2,9                      * get length to check\nU_CHK0   CLI   0(R1),C'0'                * is this byte zero\n         BNE   U_DONEX                   * no so job done\n         MVI   0(R1),C' '                * blank it\n         LA    R1,1(,R1)                 * next byte\n         BCT   R2,U_CHK0                 * check next\nU_DONEX  DS    0H\n         LA    R4,10(,R4)                * move past output bytes\n         B     DONE_IT\n*\n*        Input is small integer convert to numeric display\n*\nSINT_OUT DS    0H\n         LA    R1,6(,R4)                 * point after receiving\n         CR    R1,R5                     * is the output full\n         BNL   OVERFLOW                  * yes error\n*\n         LH    R1,0(R8)                  * get small integer value\n         CVD   R1,DOUB_WORD\n         CP    DOUB_WORD,=P'0'\n         BL    S_NEG\n         MVI   5(R4),C'+'\n         B     S_DONE\nS_NEG    DS    0H\n         MVI   5(R4),C'-'\nS_DONE   DS    0H\n         OI    DOUB_WORD+7,X'0F'\n         UNPK  0(5,R4),DOUB_WORD\n         CLI   NUM_ZERO,C'Y'             * show leading zeroes\n         BE    S_DONEX                   * they are there\n         LR    R1,R4                     * get address of output\n         LA    R2,4                      * get length to check\nS_CHK0   CLI   0(R1),C'0'                * is this byte zero\n         BNE   S_DONEX                   * no so job done\n         MVI   0(R1),C' '                * blank it\n         LA    R1,1(,R1)                 * next byte\n         BCT   R2,S_CHK0                 * check next\nS_DONEX  DS    0H\n         LA    R4,6(,R4)                 * move past output bytes\n         B     DONE_IT\n*\n*        Input is un-signed small integer convert to numeric display\n*\nVINT_OUT DS    0H\n         LA    R1,5(,R4)                 * point after receiving\n         CR    R1,R5                     * is the output full\n         BNL   OVERFLOW                  * yes error\n*\n         ICM   R1,3,0(R8)                * get small unsigned int val\n         CVD   R1,DOUB_WORD\n         OI    DOUB_WORD+7,X'0F'\n         UNPK  0(5,R4),DOUB_WORD\n         CLI   NUM_ZERO,C'Y'             * show leading zeroes\n         BE    V_DONEX                   * they are there\n         LR    R1,R4                     * get address of output\n         LA    R2,4                      * get length to check\nV_CHK0   CLI   0(R4),C'0'                * is this byte zero\n         BNE   V_DONEX                   * no so job done\n         MVI   0(R1),C' '                * blank it\n         LA    R1,1(,R1)                 * next byte\n         BCT   R2,V_CHK0                 * check next\nV_DONEX  DS    0H\n         LA    R4,5(,R4)                 * move past output bytes\n         B     DONE_IT\n*\n*        Processed that pair of address/length values - any more\n*\nDONE_IT  DS    0H\n         LA    R3,1(,R3)                 * point to next indicator\n         CLI   0(R3),X'FF'               * finished ?\n         BE    GO_BACK                   * then goback\n*\n         LA    R7,8(,R7)                 * next pair of addresses\n         CLI   PAD_DING,C'Y'             * any pad characted ?\n         BNE   GO_AGAIN                  * not so go again\n         MVC   0(1,R4),PAD_DING+1        * copy pad character\n         LA    R4,1(,R4)                 * jump past pad\n         B     GO_AGAIN                  * process next\n*\n*        Return to calling program setting R1 to the output byte after\n*        the last byte used.\n*\nGO_BACK  DS    0H\n         ST    R4,4(,R10)                * save current output address\n*                                        * in parameter list\n         LM    R14,R12,12(R13)           * restore callers registers\n         XR    15,15                     * set return code\n         L     R1,4(,R1)                 * retrieve current output adr\n*                                        * from parameter list\n         BR    R14                       * return to caller\n*********\n*\n* error routines\n*\n* There is no room in the output area for the input value so abend\n*\nOVERFLOW DS    0H\n         WTO   'STRINGIT - output overflow detected',                  /\n               ROUTCDE=11,MCSFLAG=HRDCPY\n         B     DO_AB\n*\n* Cannot unpack more than 8 bytes so abend\n*\nPACKLONG DS    0H\n         WTO   'STRINGIT - packed field > 8',                          /\n               ROUTCDE=11,MCSFLAG=HRDCPY\nDO_AB    ABEND 500,DUMP,STEP             * ,REASON=1\n*********\n*\n* storage\n*\nWORKAREA       DSECT\nDOUB_WORD      DS    D\nFULL_WORD      DS    F\nWORK2          DS    CL2\nWORK3          DS    CL3\nGLOB_IND       DS    CL15\n               ORG   GLOB_IND\nPAD_DING       DS    CL2             * pad details  (Y/N + value)\nPAD_FRST       DS    CL1             * pad first value   (numeric)\nNUM_ZERO       DS    CL1             * output numeric leading zeroes\n               ORG\n*\nSTRINGIT       CSECT\nZONES          DC    C'00000000'\nTR_TAB         DC    C'0123456789ABCDEF'\nMVC_IT         MVC   0(1,R4),0(R8)\nUNPK_IT        UNPK  0(1,R4),0(1,R8)\nCP_IT          CP    0(1,R8),=P'0'\n*\n               LTORG\n*\n               END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "TESTNEST": {"ttr": 1793, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "  MACRO\n TESTNEST &P1\n GBLC &PGMNAME\n GBLC &ENDPROG\n GBLC &MODNAME\n GBLC &MODSTRT\n GBLC &ENDMOD\n GBLC &SEGNAME\n GBLC &SEGSTRT\n GBLA &EQUATE\n GBLA &CCVAL\n GBLA &CTR\n GBLA &SEQ\n GBLA &II\n GBLA &LI\n GBLA &NI\n GBLA &ST(51)\n GBLC &IIND1(100)\n GBLC &IIND2(100)\n GBLC &I22(100)\n GBLC &I23(100)\n GBLC &I24(100)\n GBLC &IIND3(100)\n GBLC &I32(100)\n GBLC &I33(100)\n GBLC &I34(100)\n GBLC &IIND4(100)\n GBLC &I42(100)\n GBLC &I43(100)\n GBLC &IIND5(100)\n GBLC &LIND(101)\n GBLC &NEST(50)\n GBLA &AI\n GBLA &CI\n GBLA &AIND(50)\n GBLA &MULT(50)\n GBLA &CIND1(200)\n GBLC &CIND2(200)\n GBLC &RIND(50)\n LCLC &STRUCT\n&STRUCT  SETC  '&NEST(&NI)'(5,4)\n  AIF   ('&STRUCT' EQ '&P1').GOOD\n    MNOTE 8,'&STRUCT STRUCTURE AT SAME LEVEL AS &P1 MACRO SET'\n.GOOD  ANOP\n  MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "TRIM": {"ttr": 1795, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x1e\\x00\\x16\\x01\\x17\\x11\\x1f\\x01\\x18\\x07?\\x11\"\\x00B\\x00+\\x00\\x00\\xe2\\xc4\\xd1\\xd9\\xc7@@@@@'", "ispf": {"version": "01.30", "flags": 0, "createdate": "2017-04-21T00:00:00", "modifydate": "2018-03-14T11:22:16", "lines": 66, "newlines": 43, "modlines": 0, "user": "SDJRG"}, "text": "         MACRO\n         TRIM  &AREA,&LEN,&SAVE=MY_PARM,&ALL=N\n.**********************************************************************\n.*\n.* Created by John Gateley\n.*\n.*       This macro removes leading and extra blanks from a field\n.*       so that         '  some  text    in    a  field       x'\n.*       becomes         'some text in a field x                '\n.*\n.*       Optionally, all blanks can be removed from the field by\n.*       specifying ALL=Y.\n.*\n.*       On return R15 contains the number of occupied bytes\n.*\n.*       &AREA=   the field to trim, can be in a register (R14)\n.*       &LEN=    length of the field, can be in a register (R15)\n.*                it can also be omitted\n.*       &SAVE=   name of parameter list to use\n.*\n.*       TRIM  MY_FIELD,20             length of 20\n.*       TRIM  MY_FIELD                assumes L'MY_FIELD\n.*       LA    R1,MY_FIELD\n.*       LA    R2,L'MY_FIELD\n.*       TRIM  (R1),(R2)\n.*\n         AIF   (T'&LEN NE 'O').USELEN        * parameter missing\n         LA    R15,L'&AREA             use the implied length\n         ST    R15,&SAVE+4             save as second parameter\n         AGO   .NOTREGL\n.*\n.USELEN  ANOP\n         AIF   ('&LEN'(1,1) EQ '(').REGVALL  * value in register\n         LA    R15,&LEN                use the specified length\n         ST    R15,&SAVE+4             save as second parameter\n         AGO   .NOTREGL\n.REGVALL ANOP\n&LENR    SETC  '&LEN'(2,K'&LEN-2)\n         ST    &LENR,&SAVE+4           save length as second parameter\n.NOTREGL ANOP\n.*\n         AIF   ('&AREA'(1,1) EQ '(').REGVALA  * value in register\n         LA    R14,&AREA               point at area\n         ST    R14,&SAVE               save as first parameter\n         AGO   .NOTREGA\n.REGVALA ANOP\n&VALR    SETC  '&AREA'(2,K'&LEN-2)\n         ST    &VALR,&SAVE             save address as first parameter\n.NOTREGA ANOP\n.*\n         AIF   ('&ALL' EQ 'Y').ALLYES\n         LA    R1,0                    do not remove all blanks\n         ST    R1,&SAVE+8\n         AGO   .DOCALL\n.ALLYES  ANOP\n         LA    R1,1                    remove all blanks\n         ST    R1,&SAVE+8\n.DOCALL  ANOP\n         LA    R1,&SAVE                point to parameter list\n         L     R15,=V(TRIMIT)          get program address\n         BASR  R14,R15                 call program\n.*\n         L     R15,&SAVE+4             load amended length\n*        R15 now has the occupied byte count\n.*\n         MEND\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "TRIMIT": {"ttr": 1797, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x05\\x00\\x11\\x01\\x17\\x11\\x8f\\x01\\x18!o\\x16U\\x00f\\x00D\\x00\\x00\\xe2\\xc4\\xd1\\xd9\\xc7@@@@@'", "ispf": {"version": "01.05", "flags": 0, "createdate": "2017-04-28T00:00:00", "modifydate": "2018-08-04T16:55:11", "lines": 102, "newlines": 68, "modlines": 0, "user": "SDJRG"}, "text": "TRIMIT   CSECT\nTRIMIT   AMODE 31\nTRIMIT   RMODE ANY\n*\n*   This program removes leading and extra blanks from a field\n*   so that         '  some  text    in    a  field       x'\n*   becomes         'some text in a field x                '\n*\n*   Optionally, all blanks can be removed from the field by\n*   specifying ALL=Y in the TRIM macro resulting in\n*                   'sometextinafieldx                     '\n*\n*   On return R15 contains the number of occupied bytes\n*\n*   Input parameters generated by the TRIM macro are\n*     1, address of a string which should be trimmed\n*     2, length of the string\n*     3,  0    only remove repeated spaces\n*        >0    remove all spaces\n*\n         SAVE  (14,12)                 save callers registers\n         PRINT OFF\n         YREGS\n         PRINT ON\n         LR    R12,R15                 copy base address\n         USING TRIMIT,R12\n         LR    R9,R1                   copy parameter address\n         LM    R4,R6,0(R9)             get address, length and ind\n         LA    R3,0(R4,R5)             point after string\n         BCTR  R3,0                    point at last byte\n*\n         CHI   R6,0                    if positive\n         BH    TRIM_ALL                trim all blanks\n*\n*  remove repeated spaces\n*\n         LA    R6,1                    flag next blank to be removed\nSTRTLOOP LR    R7,R5                   copy the length\n         BCTR  R7,0                    subtract 1 for remaining length\n         LR    R2,R7                   copy as inner loop count\n         BCTR  R7,0                    subtract 1 for execute\nCOMPARE  CLI   0(R4),C' '              check if this byte blank\n         BNE   SETNO                   no so set flag off\n         CHI   R6,1                    is flag on\n         BNE   SETYES                  no so set flag on\n         LTR   R7,R7                   test remaining length\n         BM    ENDLOOP                 negative then finish\n         EX    R7,SLIDE_LEFT           slide bytes left\n         MVI   0(R3),C' '              blank the last byte\n         BCT   R2,COMPARE              loop to go and test again\n         B     ENDLOOP                 branch past execute to end\nSETYES   LA    R6,1                    flag next blank to be removed\n         B     LOOPIT                  go and loop\nSETNO    LA    R6,0                    flag next blank to be ignored\nLOOPIT   LA    R4,1(,R4)               next byte in field\n         BCT   R5,STRTLOOP             loop to check next byte\n         B     ENDLOOP\n*\n*  remove all spaces\n*\nTRIM_ALL DS    0H\n*\nSTRTLOO2 LR    R7,R5                   copy the length\n         BCTR  R7,0                    subtract 1 for remaining length\n         LR    R2,R7                   copy as inner loop count\n         BCTR  R7,0                    subtract 1 for execute\nCOMPARE2 CLI   0(R4),C' '              check if this byte blank\n         BNE   LOOPIT2                 no so set flag off\n         LTR   R7,R7                   test remaining length\n         BM    ENDLOOP                 negative then finish\n         EX    R7,SLIDE_LEFT           slide bytes left\n         MVI   0(R3),C' '              blank the last byte\n         BCT   R2,COMPARE2             loop to go and test again\n         B     ENDLOOP                 branch past execute to end\nLOOPIT2  LA    R4,1(,R4)               next byte in field\n         BCT   R5,STRTLOO2             loop to check next byte\n*\n*  trim accomplished\n*\nENDLOOP  DS    0H\n*\n*  now get count of occupied bytes\n*\n         LR    R4,R3                   point at last byte\n         L     R5,4(,R9)               get length\nLOOP2    DS    0H\n         CLI   0(R4),C' '              is the byte blank\n         BNE   ENDLOOP2                no so quit\n         BCTR  R4,0                    point to previous byte\n         BCT   R5,LOOP2                loop until 0\nENDLOOP2 DS    0H\n*        R5 now has the occupied byte count\n         ST    R5,4(,R9)               put count in parameter list\n*\nGO_BACK  LM    R14,R12,12(R13)         restore callers registers\n         L     R15,4(,R1)              load occupied byte count\n         BR    R14                     return to caller\n*\nSLIDE_LEFT     MVC   0(0,R4),1(R4)     sliding move instruction\n*\n         LTORG\n         END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "TSTMP": {"ttr": 1799, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x08\\x00\\x15\\x01\\x17\\x11\\x8f\\x01\\x17\\x14?\\x11!\\x00Q\\x00K\\x00\\x00\\xe2\\xc4\\xd1\\xd9\\xc7@@@@@'", "ispf": {"version": "01.08", "flags": 0, "createdate": "2017-04-28T00:00:00", "modifydate": "2017-05-23T11:21:15", "lines": 81, "newlines": 75, "modlines": 0, "user": "SDJRG"}, "text": "         MACRO\n         TSTMP &AREA,&LOCAL=N,&FORMAT=DB2\n.**********************************************************************\n.*\n.* Created by John Gateley\n.*\n.*       This macro uses STCKE to get the time from the system\n.*       and then formats it.\n.*\n.*       &AREA   =  the field to put the timestamp in\n.*       &LOCAL  =  N - just get the timestamp\n.*                  Y - adjust to local time and leap second\n.*       &FORMAT =  DB2  - CL26'2017-04-01-12.34.56.789012'\n.*                  CHAR - CL20'20170401123456789012'\n.*                  PACK - PL11'020170401123456789012C'\n.*\n.*       TSTMP WS_TIMESTAMP\n.*\n         GBLC  &USETSTMP\n&USETSTMP      SETC  'Y'\n.*\n         STCKE #MVCLSAV                store time in PRGDEF field\n.*\n         AIF   ('&LOCAL' EQ 'Y').YESLOC\n         AIF   ('&LOCAL' EQ 'N').NOLOC\n         MNOTE 16,' Invalid LOCAL specified'\n         MEXIT\n.YESLOC  ANOP\n*        L     R1,CVTPTR               point to CVT\n         L     R1,16\n*        L     R1,CVTEXT2-CVT(,R1)     point to extension 2\n         L     R1,328(,R1)\n*        USING CVTXTNT2,R1\n*        LG    R14,CVTLDTO\n         LG    R14,56(,R1)             adjust local time\n*        SG    R14,CVTLSO\n         SG    R14,80(,R1)             adjust leap seconds\n*        DROP  R1\n         LMG   R0,R1,#MVCLSAV          load STCKE output\n         LGR   R15,R14\n         SRAG  R14,R14,8\n         SLLG  R15,R15,(64-8)\n         ALGR  R1,R15\n         ALCGR R0,R14\n         STMG  R0,R1,#MVCLSAV          save amended STCKE output\n.NOLOC   ANOP\n.*\n.*      STCKCONV STCKEVAL=#MVCLSAV,CONVVAL=#MVCLSAV,TIMETYPE=DEC,     /\n         STCKCONV STCKEVAL=#MVCLSAV,CONVVAL=#MVCLSAV,TIMETYPE=DEC,     /\n               DATETYPE=YYYYMMDD,MF=(E,MY_PARM)\n         MVC   #STRING_WORK(4),#MVCLSAV+8    put in correct order\n         MVC   #STRING_WORK+4(6),#MVCLSAV\n         MVI   #STRING_WORK+10,X'0F'\n.*\n         AIF   ('&FORMAT' EQ 'DB2').DODB2\n         AIF   ('&FORMAT' EQ 'CHAR').DOCHAR\n         AIF   ('&FORMAT' EQ 'PACK').DOPACK\n         MNOTE 16,' Invalid FORMAT specified'\n         MEXIT\n.*\n.DOCHAR  ANOP\n         MVC   #MVCLSAV(11),#STRING_WORK     copy out of the way\n         UNPK  #STRING_WORK(15),#MVCLSAV(8)\n         UNPK  #STRING_WORK+14(7),#MVCLSAV+7(4)\n         MVC   &AREA.(20),#STRING_WORK\n         MEXIT\n.*\n.DOPACK  ANOP\n         SRP   #STRING_WORK(11),64-1,0       shift right 1 digit\n         MVC   &AREA.(11),#STRING_WORK\n         MEXIT\n.*\n.DODB2   ANOP\n         MVC   #MVCLSAV(11),#STRING_WORK     copy out of the way\n         MVI   #STRING_WORK,C' '\n         MVC   #STRING_WORK+1(L'#STRING_WORK-1),#STRING_WORK\n         MVC   #STRING_WORK(L'##DAT_PAT),##DAT_PAT\n         ED    #STRING_WORK(L'##DAT_PAT),#MVCLSAV\n         MVC   &AREA.(26),#STRING_WORK+1\n.*\n         MEND\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "WHEN": {"ttr": 1801, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "         MACRO\n&LAB     WHEN\n.*\n.* THIS MACRO IS ONE OF A RELATED SET OF MACROS WHICH ENGINEER THE\n.* SELECTED EXECUTION OF CODE DEPENDING ON THE CONTENTS OF A FIELD.\n.*\n.* THE GENERAL STRUCTURE IS AS FOLLOWS -\n.*    EVALUATE OPCODE,OP1(,OP2.REP.TYPE.LTH)\n.*      WHEN   OP2REST,OP2REST\n.*      WHEN   OP2REST-OP2REST,OP2REST\n.*      OTHERWSE\n.*    ENDEVAL\n.*\n.* OPCODE FOR EACH POSSIBLE DEPTH\n         GBLC  &OP(16)\n.* COMPONENTS OF OPERAND 1 FOR EACH POSSIBLE DEPTH\n         GBLC  &OP1(16)\n.* OPERAND 2 (REP.TYPE.LENGTH) IF ANY - FOR EACH POSSIBLE DEPTH\n         GBLC  &OP2(16)\n.* CURRENT LABEL GENERATION NUMBER FOR EACH POSSIBLE DEPTH\n         GBLA  &ON(16)\n.* CURRENT END LABEL NUMBER FOR EACH POSSIBLE DEPTH\n         GBLA  &OE(16)\n.* CURRENT DEPTH OF OPTION NESTING (1 TO 16)\n         GBLA  &OD\n.* IMMEDIATE INDICATOR FOR EACH POSSIBLE DEPTH\n         GBLB  &OI(16)\n.* QUOTES INDICATOR FOR EACH POSSIBLE DEPTH\n         GBLB  &OQ(16)\n.* STATUS INDICATOR FOR EACH POSSIBLE DEPTH\n         GBLB  &OS(16)\n.* OPTELSE INDICATOR FOR EACH POSSIBLE DEPTH\n         GBLB  &OELSE(16)\n.* OPTION INDICATOR FOR EACH POSSIBLE DEPTH\n         GBLB  &OPTN(16)\n.*\n.* LOCAL WORK FIELDS\n         LCLA  &A,&B,&C,&D,&E,&U\n         LCLC  &L1,&L2,&L3,&L4,&L5,&L6,&L7\n         LCLB  &H,&Z\n.*\n.IF0     AIF   (T'&LAB EQ 'O').END0\n&LAB     EQU   *\n.END0    ANOP\n.IF0A    AIF   (&OD GT 0).END0A\n         MNOTE 16,'OPTION MISSING'\n         MEXIT\n.END0A   ANOP\n.IF1     AIF   (&OD LE 16).END1\n         MNOTE 16,'MAX OPTION NESTING OF 16 EXCEEDED'\n         MEXIT\n.END1    ANOP\n.* SET EXIT FOR PREVIOUS CODE\n         BRU   @D&OD.E&OE(&OD)\n.* SET LABEL FOR ENTRY\n@D&OD.N&ON(&OD) EQU   *\n.* INCREMENT LABEL GENERATION NUMBER\n&ON(&OD) SETA  &ON(&OD)+1\n.* SET OPTION INDICATOR OFF\n&OPTN(&OD) SETB (0)\n.IF1AA   AIF   ((&OELSE(&OD)) EQ (0)).END1AA\n         MNOTE 16,'OPTELSE PRECEDES OPT'\n         MEXIT\n.END1AA  ANOP\n.* SAVE CURRENT LABEL GENERATION NUMBER FOR USER-CODE LABEL\n&U       SETA  &ON(&OD)\n.* INCREMENT LABEL GENERATION NUMBER\n&ON(&OD) SETA  &ON(&OD)+1\n.IF1AB   AIF   ((&OS(&OD)) EQ (0)).END1AB\n         MNOTE 16,'OPTION STATEMENT ERROR'\n         MEXIT\n.END1AB  ANOP\n&A       SETA  N'&SYSLIST\n.IF1B    AIF   (&A NE 0).END1B\n         MNOTE 16,'NO OPT PARAMETERS'\n         MEXIT\n.END1B   ANOP\n&B       SETA  0\n.DO1     AIF   (&A EQ &B).NDO1\n.* DO FOR EACH PARAMETER OF OPT\n&B       SETA  &B+1\n&C       SETA  K'&SYSLIST(&B)\n.IF2     AIF   ((&OQ(&OD)) EQ (0)).ELS2\n         AIF   ('&SYSLIST(&B)'(1,1) NE '''').QMN\n         AIF   ('&SYSLIST(&B)'(&C,1) EQ '''').OKQ\n.QMN     MNOTE 16,'UNQUOTED OPT PARAMETER'\n         MEXIT\n.OKQ     AIF   (&C GT 2).END2\n         MNOTE 16,'NULL QUOTES OPT PARAMETER'\n         MEXIT\n.ELS2    AIF   ('&SYSLIST(&B)'(1,1) NE '''').END2\n         MNOTE 16,'MISQUOTED OPT PARAMETER'\n         MEXIT\n.END2    ANOP\n.* FIND IF THERE IS A RANGE\n&D       SETA  0\n&H       SETB  (0)\n.DO2     AIF   (&C EQ &D).NDO2\n.* DO FOR EACH CHARACTER OF PARAMETER\n&D       SETA  &D+1\n         AIF   ('&SYSLIST(&B)'(&D,1) NE '-').ADO2\n.IF4     AIF   ((&OQ(&OD)) EQ (0)).ELS4\n         AIF   ('&SYSLIST(&B)'(&D-1,1) NE '''').ADO2\n         AIF   ('&SYSLIST(&B)'(&D+1,1) NE '''').ADO2\n         AIF   (&D EQ 2).ADO2\n.* HAVE FOUND A HYPHEN (BETWEEN QUOTES BECAUSE QUOTES ARE CURRENT)\n&H       SETB  (1)\n         AGO   .NDO2\n.ELS4    ANOP\n.* HAVE FOUND A HYPHEN\n&H       SETB  (1)\n         AGO   .NDO2\n.END4    ANOP\n.ADO2    AGO   .DO2\n.NDO2    ANOP\n&L1      SETC  '&OP(&OD)'\n&L2      SETC  '&OP1(&OD)'\n&L3      SETC  '&OP2(&OD)'\n.*\n.* GENERATE LABEL FOR COMPARE CLAUSE IF NOT 1ST AND RANGE NOT PREVIOUS\n.IF5     AIF   (&B EQ 1).END5\n         AIF   ((&Z) EQ (0)).END5\n@D&OD.N&ON(&OD) EQU *\n.* INCREMENT LABEL GENERATION COUNT\n&ON(&OD) SETA  &ON(&OD)+1\n.END5    ANOP\n.* GENERATE COMPARE CLAUSE LOGIC\n.IF6     AIF   ((&H) EQ (0)).ELS6\n.* WHEN A RANGE  &H IS 1 AND &D WILL HOLD HYPHEN OFFSET\n&E       SETA  &D-1\n&L4      SETC  '&SYSLIST(&B)'(1,&E)\n         &L1   &L2,&L3&L4\n         JL    @D&OD.N&ON(&OD)\n&E       SETA  &C-&D\n&L5      SETC  '&SYSLIST(&B)'(&D+1,&E)\n         &L1   &L2,&L3&L5\n.IF7     AIF   (&B EQ &A).ELS7\n.* WHEN NOT LAST CLAUSE GENERATE BRANCH DIRECT TO USER-CODE\n         JNH   @D&OD.N&U\n         AGO   .END7\n.ELS7    ANOP\n.* FOR LAST CLAUSE GENERATE BRANCH TO NEXT OPTION\n         JH    @D&OD.N&ON(&OD)\n.IF7A    AIF   (&A EQ 1).END7A\n.* GENERATE USER-CODE ENTRY LABEL WHEN MORE THAN A SINGLE PARAMETER\n@D&OD.N&U EQU  *\n.END7A   ANOP\n.END7    ANOP\n&Z       SETB  (1)\n         AGO   .END6\n.ELS6    ANOP\n.* HAVE SIMPLE CLAUSE WITH SINGLE TERM\n&L6      SETC  '&SYSLIST(&B)'(1,&C)\n         &L1   &L2,&L3&L6\n.IF8     AIF   (&B EQ &A).ELS8\n.* WHEN NOT LAST CLAUSE GENERATE BRANCH DIRECT TO USER-CODE\n         JE    @D&OD.N&U\n         AGO   .END8\n.ELS8    ANOP\n.* FOR LAST CLAUSE GENERATE BRANCH TO NEXT OPTION\n         JNE   @D&OD.N&ON(&OD)\n.IF9     AIF   (&A EQ 1).END9\n.* GENERATE USER-CODE ENTRY LABEL WHEN MORE THAN A SINGLE PARAMETER\n@D&OD.N&U EQU  *\n.END9    ANOP\n.END8    ANOP\n&Z       SETB  (0)\n.END6    ANOP\n.ADO1    AGO   .DO1\n.NDO1    ANOP\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "WTOX": {"ttr": 1803, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00(\\x01\\x17\\x14?\\x01\\x17\\x14?\\x11!\\x00\\x1c\\x00\\x1c\\x00\\x00\\xe2\\xc4\\xd1\\xd9\\xc7@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2017-05-23T00:00:00", "modifydate": "2017-05-23T11:21:28", "lines": 28, "newlines": 28, "modlines": 0, "user": "SDJRG"}, "text": "           MACRO\n           WTOX  &CLEAR=Y\n.*\n.* Created by John Gateley\n.*\n.* PRGDEF has space for a reentrant WTO macro and PRGSTAT has the list\n.* form which is copied into the reentrant storage at the start of the\n.* program. This ensures that the program can execute correctly in\n.* a program protected environment.\n.*\n.* WTO   TEXT=(R2),ROUTCDE=11,MCSFLAG=HRDCPY,MF=(E,#ACT_WTO_LIST)\n.*\n           ST    R2,#MVCLSAV\n           LA    1,#ACT_WTO_LIST\n           LA    2,#MESS_LEN\n           ST    R2,4(0,1)\n           LR    14,1\n           LH    15,0(1,0)\n           AR    14,15\n           OI    4(14),B'00000000'\n           OI    5(14),B'10000000'\n           SVC   35\n           L     R2,#MVCLSAV\n           AIF   ('&CLEAR' EQ 'N').NOCLR\n           MVI   MESS_TEXT,C' '\n           MVC   MESS_TEXT+1(L'MESS_TEXT-1),MESS_TEXT\n.NOCLR     ANOP\n           MEND\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "XEDIT": {"ttr": 2049, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01<\\x00\\x12\\x01\\x170\\x1f\\x01\\x171\\x7f\\x14G\\x00\\x96\\x00&\\x00\\x00\\xe2\\xc4\\xd1\\xd9\\xc7@@@@@'", "ispf": {"version": "01.60", "flags": 0, "createdate": "2017-10-28T00:00:00", "modifydate": "2017-11-13T14:47:12", "lines": 150, "newlines": 38, "modlines": 0, "user": "SDJRG"}, "text": "         MACRO\n         XEDIT &IN,&INL,&OUT,&PAD=' ',&DEC='.',&DECP=0,                /\n               &THOU=',',&SIGN=,&MARK=\n.**********************************************************************\n.*\n.* Created by John Gateley\n.*\n.*  This macro builds an edit pattern and then EDits the data or\n.*  if SIGN is specified an EDMK is used.\n.*\n.*       &IN   location of the packed field\n.*       &INL  length of the packed field\n.*       &OUT  where to build the edit pattern and put the result\n.*\n.*       &PAD  value for pad character       ' '\n.*       &DEC  value for decimal point       '.'\n.*       &DECP number of decimal places\n.*       &THOU value for thousand separator  ','\n.*       &SIGN value for sign, e.g.  SIGN=-  SIGN='-'  SIGN=' (CR)'\n.*       &MARK if set then use EDMK instead of ED and use the provided\n.*             value in the pattern, e.g. MARK=$\n.*\n.*  XEDIT VAL1_PACK,5,(R6)\n.*\n.*  XEDIT VAL1_PACK,5,(R6),THOU=         for no thousand separator\n.*\n.*  XEDIT VAL1_PACK,5,MESSTXT+10,DECP=2,MARK=$\n.*\n.*  XEDIT VAL1_PACK,3,MESSTXT+10,PAD=0,DEC=',',DECP=2,                /\n.*              THOU='.',SIGN=' (CR)'\n.*  XEDIT VAL2_PACK,4,MESSTXT+10,PAD=' ',DEC='.',DECP=0,              /\n.*              THOU=',',MARK=\u00a2\n.*\n         AIF   ('&OUT'(1,1) EQ '(').REGO1  * value in register\n         LA    R14,&OUT                  * address of output string\n         AGO   .NOREGO1\n.REGO1   ANOP\n&OUTR    SETC  '&IN'(2,K'&IN-2)\n         LR    R14,&OUTR                 * address of output string\n.NOREGO1 ANOP\n.*\n&CNT     SETA  0                         * set pattern count to 0\n&CNTMRK  SETA  0                         * set EDMK offset to 0\n&SEL     SETC  '20'                      * set digit selector\n&SIG     SETC  '21'                      * set significant digit sel\n&PATN    SETC  ''                        * start with empty pattern\n         AIF   ('&PAD' EQ '').NOPAD\n         AIF   ('&PAD'(1,1) EQ '''').QUOT1  * value in quotes\n&MPAD    SETC  '&PAD'\n         AGO   .QUOT1A\n.QUOT1   ANOP\n&MPAD    SETC  '&PAD'(2,K'&PAD-2)\n.QUOT1A  ANOP\n&MPAD    SETC  C2X('&MPAD')              * convert to hex\n&PATN    SETC  '&PATN&MPAD'              * put in pad character\n&MYLEN   SETA  K'&MPAD/2                 * get length of pad\n         AIF   (&MYLEN NE 1).MERR1       * can only be one\n&CNT     SETA  &CNT+&MYLEN               * add to count in pattern\n.NOPAD   ANOP\n.*\n&LENR    SETA  &INL                      * get input length\n&LENR    SETA  &LENR*2                   * multiply by 2\n&LENR    SETA  &LENR-1                   * subtract 1 gives no. digits\n&LENR    SETA  &LENR-&DECP               * subtract number of decimals\n.*\n.AGAIN   ANOP\n         AIF   (&LENR EQ 2).IS2\n&PATN    SETC  '&PATN&SEL'               * put in digit select\n         AGO   .NOT2\n.IS2     ANOP\n&PATN    SETC  '&PATN&SIG'               * put in significant digit\n&CNTMRK  SETA  &CNT+1                    * set significant offset\n.NOT2    ANOP\n&CNT     SETA  &CNT+1                    * add to count in pattern\n&LENR    SETA  &LENR-1                   * subtract 1 from remaining\n         AIF   (&LENR EQ 0).NOAGIN\n&LENT    SETA  (&LENR/3)*3               * divide by 3 and multiply\n.*\n         AIF   ('&THOU' EQ '').NOTHOU    * no thousand separator\n         AIF   (&LENT NE &LENR).NOTHOU   * not multiple of 3 left\n         AIF   ('&THOU'(1,1) EQ '''').QUOT2  * value in quotes\n&MTHOU   SETC  '&THOU'\n         AGO   .QUOT2A\n.QUOT2   ANOP\n&MTHOU   SETC  '&THOU'(2,K'&THOU-2)\n.QUOT2A  ANOP\n&MTHOU   SETC  C2X('&MTHOU')             * convert to hex\n&PATN    SETC  '&PATN&MTHOU'             * put in thousand separator\n&MYLEN   SETA  K'&MTHOU/2                * get length of thou separator\n         AIF   (&MYLEN NE 1).MERR2       * can only be one\n&CNT     SETA  &CNT+&MYLEN               * add to count in pattern\n.NOTHOU  ANOP\n         AIF   (&LENR GT 0).AGAIN        * anything remaining - repeat\n.*\n.NOAGIN  ANOP\n.*\n.* so now we have run out of digits before the decimal place (if any)\n.*\n         AIF   (&DECP EQ 0).TRYSGN       * if none try sign\n         AIF   ('&DEC' EQ '').TRYSGN      * value in quotes\n         AIF   ('&DEC'(1,1) EQ '''').QUOT3  * value in quotes\n&MDEC    SETC  '&DEC'\n         AGO   .QUOT3A\n.QUOT3   ANOP\n&MDEC    SETC  '&DEC'(2,K'&DEC-2)\n.QUOT3A  ANOP\n&MDEC    SETC  C2X('&MDEC')              * convert to hex\n&PATN    SETC  '&PATN&MDEC'              * put in decimal separator\n&MYLEN   SETA  K'&MDEC/2                 * get length of dec separator\n         AIF   (&MYLEN NE 1).MERR3       * can only be one\n&CNT     SETA  &CNT+&MYLEN               * add to count in pattern\n&LEND    SETA  &DECP                     * copy decimal places\n.*\n.TRYDEC  ANOP\n&PATN    SETC  '&PATN&SEL'               * put in digit select\n&CNT     SETA  &CNT+1                    * add to count in pattern\n&LEND    SETA  &LEND-1                   * reduce decimal place count\n         AIF   (&LEND NE 0).TRYDEC       * places remaining - so loop\n.*\n.TRYSGN  ANOP\n         AIF   ('&SIGN' EQ '').NOSIGN    * sign byte required\n         AIF   ('&SIGN'(1,1) EQ '''').QUOT9  * value in quotes\n&MSIGN   SETC  '&SIGN'\n         AGO   .QUOT9A\n.QUOT9   ANOP\n&MSIGN   SETC  '&SIGN'(2,K'&SIGN-2)\n.QUOT9A  ANOP\n&MSIGN   SETC  C2X('&MSIGN')             * convert to hex\n&PATN    SETC  '&PATN.&MSIGN'            * put in sign value\n&MYLEN   SETA  K'&MSIGN/2                * get length of record area\n&CNT     SETA  &CNT+&MYLEN               * add to count in pattern\n.NOSIGN  ANOP\n.*\n         MVC   0(&CNT,R14),=X'&PATN'     * copy pattern to output\n         AIF   ('&MARK' NE '').DOMARK\n         ED    0(&CNT,R14),&IN           * edit value to output\n         MEXIT\n.DOMARK  ANOP\n         LA    R1,&CNTMRK.(,R14)         * set R1 for EDMK\n         EDMK  0(&CNT,R14),&IN           * edit mark value to output\n         BCTR  R1,0                      * back of one byte\n         MVI   0(R1),C'&MARK'            * put in currency sign\n.*\n         MEXIT\n.MERR1   MNOTE 16,'Pad character can only be 1 byte'\n         MEXIT\n.MERR2   MNOTE 16,'Thousand separator can only be 1 byte'\n         MEXIT\n.MERR3   MNOTE 16,'Decimal separator can only be 1 byte'\n         MEND\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "XPACK": {"ttr": 2566, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00\\x00\\x01\\x17\\x06_\\x01 \\x01?\\x13T\\x00@\\x00+\\x00\\x00\\xe2\\xc4\\xd1\\xd9\\xc7@@@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "2017-03-06T00:00:00", "modifydate": "2020-01-13T13:54:00", "lines": 64, "newlines": 43, "modlines": 0, "user": "SDJRG"}, "text": "         MACRO\n         XPACK &IN,&INL,&OUT\n.**********************************************************************\n.*\n.* Created by John Gateley\n.*\n.*       This macro packs character hexadecimal data into a string.\n.*       so C'C1F16D' becomes X'C1F16D' or C'A1_'\n.*\n.*       In the above example\n.*       XPACK =C'C1F16D',6,OUT_TXT\n.*\n.*       Alternatively omit length and L'=C'C1F16D' will be used\n.*       XPACK =C'C1F16D',,OUT_TXT\n.*\n.*       If the input length is of the form L'AAA then it cannot be\n.*       checked here, but if it is not then see if even.\n.*\n.*\n.* indicate that XPACK macro was used so that the table can be\n.* defined in PRGESTAT\n.*\n.* this is the table that PRGESTAT will define\n.* HEXPACK_TABLE  DC    X'AABBCCDDEEFF'           C1-C6\n.*                DC    41X'0'                    C7-EF\n.*                DC    X'00112233445566778899'   F0-F9\n.*\n         AIF    (N'&SYSLIST NE 3).BADPARM\n.*\n         GBLC  &HEXPCK\n&HEXPCK  SETC  'Y'\n.*\n         AIF   (T'&INL EQ 'O').NOCHK     * parameter missing\n         AIF   ('&INL'(1,2) EQ 'L''').NOCHK\n&A       SETA  &INL                      * copy length\n&B       SETA  &A/2                      * divide by 2\n&C       SETA  &B*2                      * multiply by 2\n         AIF   (&A NE &C).NOTEVEN        * not equal means not even\n.*\n.NOCHK   ANOP\n         LA    R14,&IN                   * address of input string\n         AIF   (T'&INL NE 'O').USELEN    * parameter missing\n         LA    R15,L'&IN                 * use the implied length\n         AGO   .NOLEN\n.*\n.USELEN  ANOP\n         LA    R15,&INL                  * length of input string\n.NOLEN   ANOP\n         LA    R1,&OUT                   * address of output area\nB#&SYSNDX      DS    0H\n         MVC   HEXPACK_W3(2),0(R14)      * copy two bytes\n         TR    HEXPACK_W3(2),HEXPACK_TABLE-C'A' * Convert to packable\n         PACK  HEXPACK_W2,HEXPACK_W3     * pack it\n         MVC   0(1,R1),HEXPACK_W2        * output one byte\n         LA    R14,2(R14)                * next in input\n         LA    R1,1(R1)                  * next in output\n         AHI   R15,-2                    * subtract the 2 processed\n         BP    B#&SYSNDX                 * positive then go again\n         MEXIT\n.NOTEVEN MNOTE 16,'Length specified is not multiple of 2'\n         MEXIT\n.BADPARM MNOTE 16,'invalid positional parameters, need 3'\n         MEXIT\n         MEND\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "XUNPK": {"ttr": 2564, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x05\\x00$\\x01\\x17\\x06_\\x01 \\x01?\\x13V\\x00?\\x00'\\x00\\x00\\xe2\\xc4\\xd1\\xd9\\xc7@@@@@\"", "ispf": {"version": "01.05", "flags": 0, "createdate": "2017-03-06T00:00:00", "modifydate": "2020-01-13T13:56:24", "lines": 63, "newlines": 39, "modlines": 0, "user": "SDJRG"}, "text": "         MACRO\n         XUNPK &IN,&INL,&OUT\n.**********************************************************************\n.*\n.* Created by John Gateley\n.*\n.*       This macro unpacks character data into hexadecimal format.\n.*       so X'C1F16D' or C'A1_' becomes C'C1F16D'\n.*\n.*       In the above example\n.*       XUNPK =X'C1F16D',3,OUT_TXT\n.*\n.*       XUNPK FIELDA,,OUT_TXT          generates L'FIELDA for length\n.*\n.*\n.* indicate that XUNPK macro was used so that the table can be\n.* defined in PRGESTAT\n.*\n.* this is the table that PRGESTAT will define\n.* XUNPACK_TAB    DC    C'0123456789ABCDEF'\n.*\n         AIF    (N'&SYSLIST NE 3).BADPARM\n.*\n         GBLC  &XUNPCK\n&XUNPCK  SETC  'Y'\n.*\n         AIF   ('&IN'(1,1) EQ '(').REGVAL   * value in register\n         LA    R14,&IN                   * address of input string\n         AGO   .NOTREG\n.REGVAL  ANOP\n&INR     SETC  '&IN'(2,K'&IN-2)\n         ST    &INR,LEN_SAY              * this exists in PRGDEF\n         LA    R14,LEN_SAY               * address of input string\n         LA    R15,4                     * it is 4 bytes\n         AGO   .LENDON\n.*\n.NOTREG  ANOP\n         AIF   (T'&INL EQ 'O').NOLEN     * parameter missing\n         AIF   ('&INL'(1,1) EQ '(').REGVAL2   * value in register\n         LA    R15,&INL                  * length of input string\n         AGO   .LENDON\n.REGVAL2 ANOP\n&INR2    SETC  '&INL'(2,K'&INL-2)\n         LR    R15,&INR2\n         AGO   .LENDON\n.NOLEN   ANOP\n         LA    R15,L'&IN\n.*\n.LENDON  ANOP\n         LA    R1,&OUT                   * address of output area\nB#&SYSNDX      DS    0H\n         MVC   HEXPACK_W2(1),0(R14)      * copy one byte\n         UNPK  HEXPACK_W3,HEXPACK_W2     * UNPK two bytes to three\n         NC    HEXPACK_W3(2),=X'0F0F'    * clear zones\n         TR    HEXPACK_W3(2),XUNPACK_TAB * convert to displayable\n         MVC   0(2,R1),HEXPACK_W3        * copy to receiver\n         LA    R14,1(,R14)               * next in input\n         LA    R1,2(,R1)                 * next in output\n         BCT   R15,B#&SYSNDX             * subtract and branch\n         MEXIT\n.BADPARM MNOTE 16,'invalid positional parameters, need 3'\n         MEXIT\n         MEND\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT939/CBT.V500.FILE939.PDS/C14MACLB.xmi", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT939/CBT.V500.FILE939.PDS", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}