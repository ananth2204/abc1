{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "ZATLAS1", "INMTNODE": "A", "INMTUID": "ZATLAS1", "INMFTIME": "20200906020641000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 761446, "INMDSORG": "PO", "INMTYPE": "Data Library", "INMLRECL": 80, "INMBLKSZ": 32720, "INMRECFM": "FB", "INMDIR": 1, "INMDSNAM": "ZATLAS1.PCRE2.ASM", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 761446, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 761446, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"ZATLAS1.PCRE2.ASM": {"COPYR1": {"type": "PDSE", "DS1DSORG": 512, "DS1BLKL": 32720, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 8, "DVACLASS": 32, "DVAUNIT": 0, "DVAMAXRC": 32760, "DVACYL": 256, "DVATRK": 256, "DVATRKLN": 65535, "DVAOVHD": 0, "num_header_records": 0}, "COPYR2": {"deb": "b'\\x03\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x00\\x00\\x00\\x04\\x00\\x00\\x00'", "extents": ["b'\\x03\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x00\\x00\\x00\\x04\\x00\\x00\\x00'", "b'\\x00\\rXH\\x00\\x00\\x00\\x00\\x00\\x00\\x00~\\x00\\xff\\x7f\\x00'", "b'\\x00\\rXH\\x00\\x00\\x00\\x7f\\x00\\x00\\x00\\xfd\\x00\\xff\\x7f\\x00'", "b'\\x00\\rXH\\x00\\x00\\x00\\xfe\\x00\\x00\\x00\\xff\\x00\\xff\\x02\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"###DOC##": {"ttr": 47, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\n\\x00F\\x01\\x17&\\x1f\\x01\\x195O\\x07T\\x00d\\x00\\x0b\\x00\\x00\\xe2\\xc4\\xd1\\xd9\\xc7@@@@@'", "ispf": {"version": "01.10", "flags": 0, "createdate": "2017-09-18T00:00:00", "modifydate": "2019-12-20T07:54:46", "lines": 100, "newlines": 11, "modlines": 0, "user": "SDJRG"}, "text": "This code uses the following functions for the C environment\n\n  EDCXHOTL    create C environment with library functions\n  EDCXHOTU    call a C routine\n  EDCXHOTT    terminate C environment\n\nThis method was chosen because the only example that I could find of\nREXX calling C via assembler used this.\n\nSee:-\nArticle \"Calling C functions from Assembler - revisited\"\nby A Rudd printed in issue 208 of Xephon magazine of January 2004\nhttp://www.cbttape.org/xephon/xephonm/mvs0401.pdf\n\n\nIt was thought that there were two distinct scenarios that the\nuse of PCRE from REXX would follow.\n\n1, Parsing a value such as an argument to the REXX program or a\n   single record in a control file.\n2, Performing a regular expression on every record from a file.\n\nTo easily enable these two scenarios two versions of the interface\nbetween REXX and PCRE were developed.\n\nSee #REXPCRE for details of REXXPCRE\nSee #RXPCRE2 for details of RXPCRE2\n\nThe two main REXX functions are\n\nREXXPCRE   -  the rexx function for single execution of the REGEX\n              this combines connect, compile, match, release and\n              disconnect in a single call. It does not do substitute\n              processing.\n              returns 0 - no matches\n                      1 - matches\n                      an error message\n\n\nRXPCRE2    -  the rexx function for multiple executes of the REGEX\n              this is the program which should be called from a\n              rexx program to handle perl compatible regular\n              expressions.\n              It gets the rexx arguments and passes them to RXPCRE2A\n              which is a separate load module which also contains\n              the C code.\n              On first call it loads RXPCRE2A into memory and returns\n              the load address to the calling rexx function so that\n              subsequent calls to this module can use the same\n              version that was previously loaded.\n              Returns from this function depend on the command given\n              Any error messages from the program are written using\n              a call to IRXSAY which is the 'SAY' callable function.\n\n    'CONNECT'    connect to the C environment\n                 returns eight bytes of environment information\n                 or RC=8\n    'COMPILE'    compile a regular expression\n                 returns 19 bytes of compile information\n                 or RC=8\n    'MATCH', 'EXEC'\n    'EXECUTE'    run the regex using the input string, output\n                 will go to the specified stem variable\n                 returns 0 - no matches\n                         1 - matches\n                         8 - error\n    'SUBSTITUTE', 'SUBS'\n                 run the regex and substitute matches with\n                 replacement that could be a string or pattern.\n                 The variable name is used to contain\n                 the output string\n                 returns 0 - no match - rexx variable not set\n                         1 - matched  - rexx variable contains output\n                             string\n                         8 - an error message will be writen using\n                             IRXSAY\n    'RELEASE'    remove the specified regex compilation\n                 returns 0 - OK\n                         8 - error\n    'DISCONNECT' terminate the C environment\n                 returns 0 - OK\n                         8 - error\n\nThere are an additional four programs that are used by the above\n\nRXPCRE2A   -  the sub-routine used by RXPCRE2 which contains the\n              calls to all the C code and should only be called by\n              RXPCRE2 as it uses the rexx environment that exists\n              in that module.\n\nPROCSTEM   -  a sub-routine that manipulates rexx stem variables on\n              behalf of the calling program.\n              Macro PRGSTEM should be used in the calling program\n              to define the interface storage.\n              This also makes use of the rexx environment.\n\nSTRINGIT   -  used by the STRING macro - acts like COBOL STRING.\n\nTRIMIT     -  used by the TRIM macro to remove excess spaces.\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "#REXPCRE": {"ttr": 49, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00(\\x01\\x173o\\x01\\x195O\\x07V\\x00\\xd3\\x00\\xd0\\x00\\x00\\xe2\\xc4\\xd1\\xd9\\xc7@@@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "2017-12-02T00:00:00", "modifydate": "2019-12-20T07:56:28", "lines": 211, "newlines": 208, "modlines": 0, "user": "SDJRG"}, "text": "  How REXXPCRE works.\n\n   This combines connect, compile, match, release and disconnect\n   in a single call. It does not do substitute processing.\n\n   INPUT ARGUMENTS\n     1, the PERL regular expression.\n     2, the string to be worked on.\n     3, a STEM name which will be populated with the output\n     4, an optional OPTION\n                    'g'  -  match all\n                    'i'  -  ignore case\n                    'x'  -  exclude white space\n     5, an optional code-page - e.g.  'IBM-285'\n        if omitted the default local page is used\n     6, 'debug' if debugging required. Needs PCREDUMP DD name.\n\n   OUTPUT\n        if   successfull\n             RC=1    matched  - stem contains output\n             RC=0    no match - stem.0 will be '0'\n        else\n             RC='error message text'\n        endif\n\n   STEM variables output\n        stem.0             count of stem variables\n        stem.STRING.?      matched substrings\n        stem.POS.?         position and length of matches e.g. 3,4\n        stem.NAME.?        named substrings ' ' if none\n\n   DEBUGGING can be done by specifying 'debug' as argument 6.\n             You will also need to allocate the DD name PCREDUMP\n             with DISP=MOD if more than one call to REXXPCRE\n             because each call is a separate unit of work which\n             includes opening and closing the dataset.\n*______________________________________________________________________\n*\n/*REXX*/\n\n  \"ISPEXEC LIBDEF ISPLLIB DATASET ID ('MY.LOAD.LIBRARY') STACK\"\n\n  /*  test 1                                                  */\n\n  reg_ex  = \"(?<char>A)\\g<char>\"\n  the_str = \"AN_AARDWARK_JAKE_AND_aaRDWARK_JACK\"\n  my_stem = \"WANG\"\n  opt_ion = \"gi\"\n\n  say the_str\n\n  drop wang.\n\n  re_sponse = REXXPCRE(reg_ex,the_str,my_stem,opt_ion)\n\n  select\n     when re_sponse = 1 then do\n        say 'wang.0  is  ' wang.0\n        do lo_op_r = 1 to wang.0\n           say  wang.string.lo_op_r\n           say  wang.pos.lo_op_r  '       '  wang.name.lo_op_r\n        end\n       end\n     when re_sponse = 0 then\n        say 'no matches found'\n     Otherwise\n        say 'Error :' re_sponse\n  end\n\n  drop wang.\n\n  say '  '\n\n  /*  test 2                                                  */\n\n  the_str = \"The quick brown fox jumps over the lazy dog.\"\n  the_Str = the_str||\"The quick brown fox jumps over the\"\n  reg_ex  = \"(quick|jump)\"\n  my_stem = \"WANG\"\n\n  say the_str\n\n  /* no option specified but use debug mode                   */\n\n  re_sponse = REXXPCRE(reg_ex,the_str,my_stem,,,'debug')\n\n  select\n     when re_sponse = 1 then do\n        say 'wang.0  is  ' wang.0\n        do lo_op_r = 1 to wang.0\n           say  wang.string.lo_op_r\n           say  wang.pos.lo_op_r  '       '  wang.name.lo_op_r\n        end\n       end\n     when re_sponse = 0 then\n        say 'no matches found'\n     Otherwise\n        say 'Error :' re_sponse\n  end\n\n  drop wang.\n\n  say '  '\n\n  /*  test 3                                                  */\n\n  the_str = \"A fat cat doesn't eat oat but a rat eats bats.\"\n  reg_ex  = \"(at)\"\n  my_stem = \"WANG\"\n  opt_ion = \"g\"\n\n  say the_str\n\n  re_sponse = REXXPCRE(reg_ex,the_str,my_stem,opt_ion)\n\n  select\n     when re_sponse = 1 then do\n        say 'wang.0  is  ' wang.0\n        do lo_op_r = 1 to wang.0\n           say  wang.string.lo_op_r\n           say  wang.pos.lo_op_r  '       '  wang.name.lo_op_r\n        end\n       end\n     when re_sponse = 0 then\n        say 'no matches found'\n     Otherwise\n        say 'Error :' re_sponse\n  end\n\n  drop wang.\n\n  /*  test 4                                                  */\n\n  the_str = \"He_jumps_brown_fox\"\n  reg_ex  = \"(?<first>quick|jumps_+(?<second>brown|over)_+(fox|the))\"\n  my_stem = \"WANG\"\n\n  say the_str\n\n  re_sponse = REXXPCRE(reg_ex,the_str,my_stem,'g')\n\n  select\n     when re_sponse = 1 then do\n        say 'wang.0  is  ' wang.0\n        do lo_op_r = 1 to wang.0\n           say  wang.string.lo_op_r\n           say  wang.pos.lo_op_r  '       '  wang.name.lo_op_r\n        end\n       end\n     when re_sponse = 0 then\n        say 'no matches found'\n     Otherwise\n        say 'Error :' re_sponse\n  end\n\n  /*  test 5                                                  */\n  /*                                                          */\n  /*  this test uses the dollar symbol which is code page     */\n  /*  dependant in EBCDIC. In IBM-037 the dollar is x'5B'     */\n  /*  but in IBM-285 (UK) this is the currency symbol         */\n  /*  for GBP and the dollar is at x'4A' which is the cent    */\n  /*  symbol in IBM-037. Confusing!                           */\n  /*  Internally PCRE2 uses IBM-1047 so to use the dollar     */\n  /*  symbol in the regex we pass a fifth argument which      */\n  /*  is the code page name we are actually using.            */\n  /*  This causes PCRE to convert the regex from IBM-285      */\n  /*  to IBM-1047 before it is compiled, similarly the        */\n  /*  string is converted before the match is done.           */\n\n  /*  NOTE - this argument is only required if you use        */\n  /*         a code page in your terminal emulator which      */\n  /*         is NOT the same as the default local code page.  */\n  /*         Normal processing by PCRE is to convert the      */\n  /*         REGEX and string from the default local code     */\n  /*         page to IBM-1047.                                */\n  /*         IBM-1047 is used by the mainframe C compiler.    */\n\n  pa_rm    = \"INDSN(DSNAME(MEMBER))\"\n\n  reg_ex  = \"\\((.*)\\)\u00a2\"\n  opt_ion = \"g\"\n  code_pg = \"IBM-285'\n\n  say pa_rm\n  say reg_ex\n\n  re_sponse = REXXPCRE(reg_ex,pa_rm,'wang',opt_ion,code_pg)\n\n  select\n     when re_sponse = 1 then do\n        say 'wang.0  is  ' wang.0\n        do lo_op_r = 1 to wang.0\n           var_1  =  substr(wang_string.lo_op_r,1,30)\n           var_2  =  substr(wang_pos.lo_op_r,1,10)\n           var_3  =  wang_name.lo_op_r\n           say  var_1 var_2 var_3\n        end\n       end\n     when re_sponse = 0 then\n        say 'no matches found'\n     Otherwise\n        say 'Error :' re_sponse\n  end\n\n  drop wang.\n\n  \"ispexec libdef ispllib \"\n\n  exit\n*______________________________________________________________________\n*\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "#RXPCRE2": {"ttr": 51, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x06\\x009\\x01\\x173o\\x01\\x195O\\x08\\x01\\x00\\xa7\\x00\\x8f\\x00\\x00\\xe2\\xc4\\xd1\\xd9\\xc7@@@@@'", "ispf": {"version": "01.06", "flags": 0, "createdate": "2017-12-02T00:00:00", "modifydate": "2019-12-20T08:01:39", "lines": 167, "newlines": 143, "modlines": 0, "user": "SDJRG"}, "text": "  How RXPCRE2 works.\n\n  This program RXPCRE2 is a rexx function and RXPCRE2A is a helper.\n  On the 'connect' call RXPCRE2A is loaded into memory and the\n  address of the program is returned, this enables the program to\n  be found on subsequent calls.\n  The 'disconnect' function terminates the C environment and deletes\n  RXPCRE2A from memory.\n\n\n  There are 5 calls to the function\n\n\n  1, CONNECT\n     Establish the C environment with or without debug.\n     If OK returns an eight byte environment handle which should\n     be used in subsequent calls to the function.\n     An optional third parameter is the code page that is being used,\n     this defaults to a z/OS environment variable but can be set\n     byt the user.\n     If DEBUG is specified then the DDNAME PCREDUMP must be allocated\n     with DISP=MOD as the dataset will be opened and closed on\n     every call.\n\n     Returns 0 if OK\n             8 if failed - an error message will be writen using IRXSAY\n\n       r_c     = RXPCRE2('connect','pcre_env')\n       r_c     = RXPCRE2('connect','pcre_env',,'debug')\n       r_c     = RXPCRE2('connect','pcre_env')\n       r_c     = RXPCRE2('connect','pcre_env','IBM-285','debug')\n\n       if  r_c  > 0 then exit\n\n\n  2, COMPILE\n     Compile a PCRE regular expression.\n     This returns an nineteen byte compile handle which should\n     be used in subsequent calls to the function.\n     Options can be specified\n                  'g'  repeat search\n                  'i'  ignore case\n                  'x'  exclude white space\n     Note that multiple regular expressions can be compiled and\n     then executed in turn.\n\n     Returns 0 if OK\n             8 if failed - an error message will be writen using IRXSAY\n\n       reg_ex  = \"(?<char>A)\\g<char>\"\n\n       r_c     = RXPCRE2('compile',pcre_env,reg_ex,'pcre_comp','g')\n\n       if  r_c  > 0 then exit\n\n\n  3, MATCH - aliases EXECUTE and EXEC\n     Process the compiled expression, repeat this call as required.\n     The STEM name is used as the first part of the output\n     'WANG' will give  WANG.0         the count of matches\n                       WANG_STRING.?  the sub-strings\n                       WANG_POS.?     the positions within the string\n                       WANG_NAME.?    named sub-strings (blank if none)\n\n     returns  0     no match - stem.string.0 will be '0'\n              1     matched  - stem.string.? contains output\n              8     an error message will be writen using IRXSAY\n\n       the_str   = \"AN_AARDWARK_JAKE_AND_AARDWARK_JACK\"\n       my_stem   = \"WANG\"\n\n       r_c = RXPCRE2('execute',pcre_env,pcre_comp,the_str,my_stem)\n\n     This call can be repeated as many times as required.\n\n\n  4, SUBSTITUTE - alias SUBS\n     This is similar to EXECUTE but uses the routine SUBSTIT2\n     instead of MATCH2 and requires an additional input containing\n     the substitute string.\n     The variable name is used to contain the output string\n\n     returns  0     no match - rexx variable not set\n              1     matched  - rexx variable contains output string\n              8     an error message will be writen using IRXSAY\n\n       reg_ex      \"cat|dog\"\n       the_str     \"the dog sat on the cat's dog\"\n       subs_str    \"horse\"\n       my_var    = \"WANG\"\n\n       r_c = RXPCRE2('substitute',pcre_env,pcre_comp,the_str,,\n                     my_var,subs_str)\n\n     This call can be repeated as many times as required.\n\n\n  5, RELEASE\n     Release the compiled storage for a specified compile.\n     Returns 0 if successfull.\n             8 if failed - an error message will be writen using IRXSAY\n\n       re_lease  = RXPCRE2('release',pcre_env,pcre_comp)\n\n\n  6, DISCONNECT\n     Terminate the C environment.\n     Returns 0 if successfull.\n             8 if failed - an error message will be writen using IRXSAY\n\n       r_c     = RXPCRE2('disconnect',pcre_env)\n\n\n  NOTE if any call fails then all storage and compile handles will\n       be released and the C environment will be terminated.\n       Do not attempt to continue after this.\n*______________________________________________________________________\n*\n     STEM variables output\n          stem.0             count of stem variables\n          stem_STRING.?      matched substrings\n          stem_POS.?         position and length of matches e.g. 3,4\n          stem_NAME.?        named substrings ' ' if none\n\n     these stem values will contain the same as stem.0\n          stem_STRING.0\n          stem_POS.0\n          stem_NAME.0\n*______________________________________________________________________\n*\n          PCRELIB\n\n   When running in batch the LOAD macro will try to find the requested\n   module/program object in the STEPLIB or JOBLIB concatenation\n   which will contain the PDSE library containing RXPCRE2A. This works.\n\n   In ISPF the library would be concatenated to ISPLLIB which will\n   allow RXPCRE2 to be loaded, however, when this tries to load\n   RXPCRE2A the STEPLIB would be used and would fail.\n   It should be possible to put the program library in the ISPLLIB\n   concatenation and amend all references to PCRELIB to ISPLLIB\n   but this will not work when ISPLLIB is modified using LIBDEF as\n   the library is not added to the actual ISPLLIB but to another\n   DDNAME which is logically concatenated by ISPF.\n\n   For the above reasons PCRELIB is used. If it is not present in the\n   task IO table the program will not attempt to use it.\n\n       /* allow RXPCRE2 to be loaded by REXX */\n       \"ISPEXEC LIBDEF ISPLLIB DATASET ID ('SDJRG.LOADLIB.POBJ')\"\n       if rc /= 0 then do\n          say 'allocation to ispllib failed.'\n          exit\n       end\n       /* allow RXPCRE2A to be loaded by RXPCRE2A */\n       \"ALLOC FI(PCRELIB)  DA('?????.LOADLIB.POBJ') SHR\"\n       if rc /= 0 then do\n          say 'allocation to PCRELIB failed.'\n          exit\n       end\n\n       ...\n\n       \"FREE FILE(PCRELIB)\"\n       \"ISPEXEC LIBDEF ISPLLIB \"\n*______________________________________________________________________\n*\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PROCSTEM": {"ttr": 31, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x0c\\x00\"\\x01\\x17%\\x9f\\x01\\x18&O\\x17\"\\x02\\x0c\\x02\\x19\\x00\\x00\\xe2\\xc4\\xd1\\xd9\\xc7@@@@@'", "ispf": {"version": "01.12", "flags": 0, "createdate": "2017-09-16T00:00:00", "modifydate": "2018-09-21T17:22:22", "lines": 524, "newlines": 537, "modlines": 0, "user": "SDJRG"}, "text": " TITLE 'PROCSTEM - REXX Inner program for STEM manipulation'\n*\nPROCSTEM PRGDEF FSEG=MAIN_BIT,INREX=Y\n*______________________________________________________________________\n*\n* Written by John Gateley - use at your own risk\n*\n* This program handles STEM variable manipulation for an outer\n* REXX function. All modules in the assembler calling chain should\n* have INREX=Y except the top level which should have REXX=Y.\n*\n*   STEM_FUNCTION   =   1   drop variable then set stem.0 to 0\n*                       2   set a stem variable with the number in\n*                           STEM_ZERO_COUNT, this is automatically\n*                           incremented so if you want to reset a\n*                           previous value set this to the count-1\n*                       3   set STEM.0 to STEM_ZERO_COUNT\n*                       4   get STEM.0 value\n*                       5   get next STEM.? value\n*                      21   scan stem to get max var length and count\n*                      31   drop all vars > STEM_ZERO_COUNT and\n*                           then set STEM.0 to input STEM_ZERO_COUNT\n*\n* If you have multiple stems in your program then use the PRGSTEM\n* macro with PREF=???? to generate seperate storage for each one.\n*\n* If you want multi-part stem names you can have them,\n* use STEM_MID_NAME for the middle part.\n* Do not include a '.' in STEM_MID_NAME.\n* This is because the DROP processing can get confused.\n*\n* If you have this\n*              WANG.0\n*              WANG_NAME.?\n*              WANG_POS.?\n* then WANG_NAME.0 and WANG_POS.0 will also be maintained and\n*\n* The following should be set before function 1\n*     STEM_NAME_ADR\n*     STEM_NAME_LEN\n*     STEM_MID_NAME                    if required\n*     Do not initialise STEM_ZERO_COUNT it needs to be invalid packed\n*     on the first call as the code checks for this.\n*\n* The following should be set before function 2\n*     STEM_TEXT_ADR\n*     STEM_TEXT_LEN\n*     STEM_TRIM_VAR                    Y if spaces should be removed\n*\n*                    the parameter area used to call irxexcom\nIX_PARM              DS    4F\nSAVE_R14             DS    F\n*\nVAR_TEXT             DS    CL8\n*\n                     DS    0D\nORIGINAL_COUNT       DS    PL8\n*\nERR_NO               DS    CL1\nJUST_LOOKING         DS    CL1\n*\nPARM_AREA            DS    (SHVBLEN)XL1\n*\n        PRGEDEF\n*\n                     USING STEM_AREA,R5\n                     USING SHVBLOCK,R6\n*______________________________________________________________________\n*\n SEGS MAIN_BIT\n*\n   L     R5,0(R1)\n   XC    IX_PARM(4*4),IX_PARM\n   LA    R1,=CL8'IRXEXCOM'\n   ST    R1,IX_PARM\n   LA    R6,PARM_AREA\n*\n   IF (TP,STEM_ZERO_COUNT,NZ)          first time in ?\n     ZAP   STEM_ZERO_COUNT,=P'0'       initialise count\n     MVI   STEM_NAME,C' '\n     MVC   STEM_NAME+1(L'STEM_NAME-1),STEM_NAME\n     L     R15,STEM_NAME_ADR           address of name\n     L     R14,STEM_NAME_LEN           length of name\n     BCTR  R14,0                       minus 1\n     LA    R1,STEM_NAME                point to stem name\n     EX    R14,COPY_STEM_NAME          copy input name to working\n     LA    R1,1(R14,R1)                point after copied name\n     MVI   0(R1),C'.'                  add a period\n     LA    R1,1(,R1)                   point after\n     ST    R1,STEM_AFT_DOT             store addr of this byte\n     L     R2,STEM_NAME_LEN            get length of name\n     IF (CLC,STEM_MID_NAME,GT,SPACES)  is there a middle part ?\n       LR    R15,R1                    point at current end\n       BCTR  R15,0                     back one\n       MVI   0(R15),C'_'               replace dot with underscore\n       LA    R14,STEM_MID_NAME         point at it\n       LA    R15,L'STEM_MID_NAME       get length of field\n       DO FROM=(R15)\n       DOEXIT (CLI,0(R14),LE,C' ')     quit when <= blank\n         MVC   0(1,R1),0(R14)          copy one byte\n         LA    R1,1(,R1)               next output byte\n         LA    R2,1(,R2)               add to length\n         LA    R14,1(,R14)             next input byte\n       ENDDO\n       MVI   0(R1),C'.'                add a period\n       LA    R1,1(,R1)                 point after period\n       LA    R2,1(,R2)                 add to length\n       ST    R1,STEM_AFT_DOT           store addr of this byte\n     ENDIF\n     LA    R2,2(,R2)                   add 2 for .0\n     ST    R2,STEM_NAME_LEN            save actual length\n   ENDIF\n*\n   LA    R15,STEM_NAME+L'STEM_NAME\n   L     R14,STEM_AFT_DOT\n   SR    R15,R14                       calc length remaining\n   DO FROM=(R15)\n     MVI   0(R14),C' '                 blank out rest of name\n     LA    R14,1(,R14)\n   ENDDO\n   OC    STEM_NAME,SPACES\n*\n   MVC   SHVNEXT,=F'0'\n   MVC   SHVUSER,=F'0'\n   MVI   SHVCODE,SHVSYSET              command is set variable\n   MVC   SHVBUFL,=F'0'\n   LA    R1,STEM_NAME                  point to stem name\n   ST    R1,SHVNAMA                    store in function call\n*\n   IF (CLHHSI,STEM_FUNCTION,EQ,1)\n     SEGDO DROP_ENTIRE_STEM            drop the stem.\n     MVI   SHVCODE,SHVSTORE            reset command to store variable\n     SEGDO INIT_STEM_ZERO              initialise stem.0\n   ELSEIF (CLHHSI,STEM_FUNCTION,EQ,2)\n     SEGDO SET_STEM_LINE               create new variable\n   ELSEIF (CLHHSI,STEM_FUNCTION,EQ,3)\n     SEGDO SET_STEM_ZERO               set stem.0 with the total\n   ELSEIF (CLHHSI,STEM_FUNCTION,EQ,4)\n     SEGDO GET_STEM_ZERO               get stem.0 value\n   ELSEIF (CLHHSI,STEM_FUNCTION,EQ,5)\n     SEGDO GET_STEM_LINE               get next stem.? value\n   ELSEIF (CLHHSI,STEM_FUNCTION,EQ,21)\n     SEGDO GET_STEM_TOTALS             get max var length and count\n   ELSEIF (CLHHSI,STEM_FUNCTION,EQ,31)\n     SEGDO DROP_EXCESS_VARS            drop unused stem members\n   ELSE\n     MVC   MESS_TXT(22),=CL22'PROCSTEM invalid call'\n     SEGDO CALL_IRXSAY\n     PRGQUIT RC=8                      invalid function so quit\n   ENDIF\n*\n SEGE MAIN_BIT\n*______________________________________________________________________\n*\n SEGS GET_STEM_TOTALS\n*\n   SEGDO GET_STEM_ZERO\n*\n   L     R1,STEM_TEXT_LEN              length of variable returned\n   L     R14,STEM_TEXT_ADR\n   BCTR  R1,0\n   EX    R1,PACK_STEM_0                save number of items\n   ZAP   DOUB_WORD,STEM_ZERO_COUNT\n   CVB   R14,DOUB_WORD\n   XR    R4,R4\n   ZAP   STEM_ZERO_COUNT,=P'0'         initialise count\n   MVI   JUST_LOOKING,C'Y'\n   DO FROM=(R14)\n     ST    R14,SAVE_R14\n     LA    R15,STEM_NAME+L'STEM_NAME\n     L     R14,STEM_AFT_DOT\n     SR    R15,R14                       calc length remaining\n     DO FROM=(R15)\n       MVI   0(R14),C' '                 blank out rest of name\n       LA    R14,1(,R14)\n     ENDDO\n     SEGDO GET_STEM_LINE\n     IF (C,R4,LT,STEM_TEXT_LEN)\n       L     R4,STEM_TEXT_LEN\n     ENDIF\n     L     R14,SAVE_R14\n   ENDDO\n   NI    JUST_LOOKING,0\n   ST    R4,STEM_MAX_LEN\n*\n SEGE GET_STEM_TOTALS\n*______________________________________________________________________\n*\n SEGS DROP_EXCESS_VARS\n*\n*  After a sort with a sum statement there can be redundant stem\n*  variables, this routine removes them.\n*\n   ZAP   ORIGINAL_COUNT,STEM_ZERO_COUNT  original count\n*\n   SEGDO GET_STEM_ZERO                 get current count\n*\n   L     R1,STEM_TEXT_LEN              length of variable returned\n   L     R14,STEM_TEXT_ADR\n   BCTR  R1,0\n   EX    R1,PACK_STEM_0                copy current value\n   SP    ORIGINAL_COUNT,STEM_ZERO_COUNT\n   CVB   R4,ORIGINAL_COUNT             now has difference in value\n*\n   DO FROM=(R4)\n     AP    STEM_ZERO_COUNT,=P'1'       increment variable number\n     LA    R15,STEM_NAME+L'STEM_NAME\n     L     R14,STEM_AFT_DOT\n     SR    R15,R14                     calc length remaining\n     DO FROM=(R15)\n       MVI   0(R14),C' '               blank out rest of name\n       LA    R14,1(,R14)\n     ENDDO\n     SEGDO DROP_STEM_VARIABLE\n   ENDDO\n*\n SEGE DROP_EXCESS_VARS\n*______________________________________________________________________\n*\n SEGS DROP_ENTIRE_STEM\n*\n   MVC   SHVNEXT,=F'0'\n   MVC   SHVUSER,=F'0'\n   MVI   SHVCODE,SHVDROPV              command is drop variable\n   MVC   SHVBUFL,=F'0'\n   MVC   SHVVALA,=F'0'\n   MVC   SHVVALL,=F'0'\n   LA    R1,STEM_NAME                  point to stem name\n   ST    R1,SHVNAMA                    store in function call\n   L     R1,STEM_NAME_LEN              get length including .0\n   BCTR  R1,0                          drop the 0\n   ST    R1,SHVNAML                    use as length\n*\n   SEGDO CALL_IRXEXCOM\n*\n   IF (LTR,R15,R15,NZ)\n     MVC   MESS_TXT(L'E_D_STEM_0),E_D_STEM_0\n     XUNPK (R15),4,MESS_TXT+L'E_D_STEM_0\n     SEGDO CALL_IRXSAY\n     PRGQUIT RC=8\n   ENDIF\n*\n SEGE DROP_ENTIRE_STEM\n*______________________________________________________________________\n*\n SEGS DROP_STEM_VARIABLE\n*\n   MVC   SHVNEXT,=F'0'\n   MVC   SHVUSER,=F'0'\n   MVI   SHVCODE,SHVDROPV              command is drop variable\n   MVC   SHVBUFL,=F'0'\n   MVC   SHVVALA,=F'0'\n   MVC   SHVVALL,=F'0'\n   MVC   VAR_TEXT,=X'4020202020202120' copy edit pattern\n   LA    R1,VAR_TEXT+L'VAR_TEXT-1      point to last digit\n   EDMK  VAR_TEXT,STEM_ZERO_COUNT      edit number into mask\n   LA    R2,VAR_TEXT+L'VAR_TEXT-1      point at last byte\n   SR    R2,R1                         get length for execute\n   L     R3,STEM_AFT_DOT\n   EX    R2,COPY_VAR_NUMB              copy number after STEM.\n   LA    R3,1(R2,R3)                   point past copied stuff\n   LA    R1,STEM_NAME\n   SR    R3,R1\n   ST    R3,SHVNAML\n*\n   SEGDO CALL_IRXEXCOM\n*\n   IF (LTR,R15,R15,NZ)\n     MVC   MESS_TXT(L'E_D_STEM_LINE),E_D_STEM_LINE\n     XUNPK (R15),4,MESS_TXT+L'E_D_STEM_LINE\n     SEGDO CALL_IRXSAY\n     PRGQUIT RC=8\n   ENDIF\n*\n SEGE DROP_STEM_VARIABLE\n*______________________________________________________________________\n*\n SEGS INIT_STEM_ZERO\n*\n   L     R1,STEM_AFT_DOT\n   MVI   0(R1),C'0'\n   MVC   SHVNAML,STEM_NAME_LEN\n\n   LA    R1,=C'0'                      set STEM.0 to '0'\n   ST    R1,SHVVALA\n   LA    R1,1                          length of 1\n   ST    R1,SHVVALL\n*\n   SEGDO CALL_IRXEXCOM\n*\n   IF (LTR,R15,R15,NZ)\n     MVC   MESS_TXT(L'E_I_STEM_0),E_I_STEM_0\n     XUNPK (R15),4,MESS_TXT+L'E_I_STEM_0\n     SEGDO CALL_IRXSAY\n     PRGQUIT RC=8\n   ENDIF\n*\n SEGE INIT_STEM_ZERO\n*______________________________________________________________________\n*\n SEGS SET_STEM_LINE\n*\n   AP    STEM_ZERO_COUNT,=P'1'         increment count\n   MVC   VAR_TEXT,=X'4020202020202120' copy edit pattern\n   LA    R1,VAR_TEXT+L'VAR_TEXT-1      point to last digit\n   EDMK  VAR_TEXT,STEM_ZERO_COUNT      edit number into mask\n   LA    R2,VAR_TEXT+L'VAR_TEXT-1      point at last byte\n   SR    R2,R1                         get length for execute\n   L     R3,STEM_AFT_DOT\n   EX    R2,COPY_VAR_NUMB              copy number after STEM.\n   LA    R3,1(R2,R3)                   point past copied stuff\n   LA    R1,STEM_NAME\n   SR    R3,R1\n   ST    R3,SHVNAML\n   IF (CLI,STEM_TRIM_VAR,EQ,C'Y')      want to remove all blanks ?\n     MVC   SHVVALA,STEM_TEXT_ADR       copy address of value\n     L     R14,STEM_TEXT_ADR           point to value\n     L     R15,STEM_TEXT_LEN           get length of value\n     TRIM  (R14),(R15),ALL=Y           remove all blanks\n     ST    R15,SHVVALL                 R15 has length of the result\n   ELSE\n     MVC   SHVVALA,STEM_TEXT_ADR       copy address\n     MVC   SHVVALL,STEM_TEXT_LEN       copy length\n   ENDIF\n*\n   SEGDO CALL_IRXEXCOM\n*\n   IF (LTR,R15,R15,NZ)\n     MVC   MESS_TXT(L'E_S_STEM_LINE),E_S_STEM_LINE\n     XUNPK (R15),4,MESS_TXT+L'E_S_STEM_LINE\n     SEGDO CALL_IRXSAY\n     PRGQUIT RC=8\n   ENDIF\n*\n SEGE SET_STEM_LINE\n*______________________________________________________________________\n*\n SEGS SET_STEM_ZERO\n*\n   L     R1,STEM_AFT_DOT\n   MVI   0(R1),C'0'                    STEM.0\n   MVC   SHVNAML,STEM_NAME_LEN\n\n   MVC   VAR_TEXT,=X'4020202020202120'\n   LA    R1,VAR_TEXT+L'VAR_TEXT-1\n   EDMK  VAR_TEXT,STEM_ZERO_COUNT\n   LA    R2,VAR_TEXT+L'VAR_TEXT\n   SR    R2,R1                         calc length of value\n   ST    R1,SHVVALA                    store address of value\n   ST    R2,SHVVALL                    store length of value\n*\n   SEGDO CALL_IRXEXCOM\n*\n   IF (LTR,R15,R15,NZ)\n     MVC   MESS_TXT(L'E_S_STEM_ZERO),E_S_STEM_ZERO\n     XUNPK (R15),4,MESS_TXT+L'E_S_STEM_ZERO\n     SEGDO CALL_IRXSAY\n     PRGQUIT RC=8\n   ENDIF\n*\n SEGE SET_STEM_ZERO\n*______________________________________________________________________\n*\n SEGS GET_STEM_ZERO\n*\n   LA    R1,STEM_NAME                  point to stem name\n   ST    R1,SHVNAMA                    store in function call\n   MVC   SHVNEXT,=F'0'\n   MVC   SHVUSER,=F'0'\n   MVI   SHVCODE,SHVFETCH              command is fetch variable\n   MVC   SHVBUFL,STEM_MAX_LEN\n   MVC   SHVVALL,=F'0'\n   MVC   SHVVALA,STEM_TEXT_ADR\n*\n   L     R1,STEM_AFT_DOT\n   MVI   0(R1),C'0'                    STEM.0\n   MVC   SHVNAML,STEM_NAME_LEN\n*\n   SEGDO CALL_IRXEXCOM\n*\n   IF (LTR,R15,R15,NZ)\n     MVC   MESS_TXT(L'E_G_STEM_ZERO),E_G_STEM_ZERO\n     XUNPK (R15),4,MESS_TXT+L'E_G_STEM_ZERO\n     SEGDO CALL_IRXSAY\n     PRGQUIT RC=8\n   ELSEIF (CLI,SHVRET,EQ,SHVNEWV)\n     MVC   MESS_TXT(L'NEW_VARIABLE_3),NEW_VARIABLE_3\n     SEGDO CALL_IRXSAY\n     MVC   MESS_TXT(L'STEM_NAME),STEM_NAME\n     SEGDO CALL_IRXSAY\n   ENDIF\n   MVC   STEM_TEXT_LEN,SHVVALL\n*\n SEGE GET_STEM_ZERO\n*______________________________________________________________________\n*\n SEGS GET_STEM_LINE\n*\n   LA    R1,STEM_NAME                  point to stem name\n   ST    R1,SHVNAMA                    store in function call\n   MVC   SHVNEXT,=F'0'\n   MVC   SHVUSER,=F'0'\n   MVI   SHVCODE,SHVFETCH              command is fetch variable\n   MVC   SHVBUFL,STEM_MAX_LEN          copy length\n   MVC   SHVVALA,STEM_TEXT_ADR         copy address\n   MVC   SHVVALL,=F'0'\n*\n   AP    STEM_ZERO_COUNT,=P'1'         increment count\n   MVC   VAR_TEXT,=X'4020202020202120' copy edit pattern\n   LA    R1,VAR_TEXT+L'VAR_TEXT-1      point to last digit\n   EDMK  VAR_TEXT,STEM_ZERO_COUNT      edit number into mask\n   LA    R2,VAR_TEXT+L'VAR_TEXT-1      point at last byte\n   SR    R2,R1                         get length for execute\n   L     R3,STEM_AFT_DOT\n   EX    R2,COPY_VAR_NUMB              copy number after STEM.\n   LA    R3,1(R2,R3)                   point past copied stuff\n   LA    R1,STEM_NAME\n   SR    R3,R1\n   ST    R3,SHVNAML\n*\n   SEGDO CALL_IRXEXCOM\n*\n   IF (LTR,R15,R15,NZ)\n     IF (CFI,R15,EQ,4),AND,(CLI,JUST_LOOKING,EQ,C'Y'),AND,             /\n               (CLI,SHVRET,EQ,SHVTRUNC)\n* do not mind truncation as we only want the variable length\n     ELSE\n       MVC   MESS_TXT(L'ERR_STEM_LINE),ERR_STEM_LINE\n       XUNPK (R15),4,MESS_TXT+L'ERR_STEM_LINE\n       MVC   MESS_TXT+L'ERR_STEM_LINE+9(7),=C'SHVRET='\n       MVC   MESS_TXT+L'ERR_STEM_LINE+16(1),SHVRET\n       SEGDO CALL_IRXSAY\n       MVC   MESS_TXT(L'STEM_NAME),STEM_NAME\n       SEGDO CALL_IRXSAY\n       PRGQUIT RC=8\n     ENDIF\n   ELSEIF (CLI,SHVRET,EQ,SHVNEWV)\n     MVC   MESS_TXT(L'NEW_VARIABLE_1),NEW_VARIABLE_1\n     SEGDO CALL_IRXSAY\n     MVC   MESS_TXT(L'NEW_VARIABLE_2),NEW_VARIABLE_2\n     SEGDO CALL_IRXSAY\n     MVC   MESS_TXT(L'STEM_NAME),STEM_NAME\n     SEGDO CALL_IRXSAY\n     PRGQUIT RC=8\n   ENDIF\n   MVC   STEM_TEXT_LEN,SHVVALL\n*\n SEGE GET_STEM_LINE\n*______________________________________________________________________\n*\n SEGS CALL_IRXEXCOM\n*\n   LA    R1,PARM_AREA\n   ST    R1,IX_PARM+12\n   OI    IX_PARM+12,X'80'\n   L     R0,#SAV_REX+12                rexx environment block addr\n   LA    R1,IX_PARM\n   USING IRXEXTE,15\n   L     15,ENVBLOCK_IRXEXTE\n   L     15,IRXEXCOM\n   DROP  15\n   BASR  14,15\n*\n SEGE CALL_IRXEXCOM\n*______________________________________________________________________\n*\n SEGS CALL_IRXSAY\n*\n   LA    R1,=CL8'WRITE'\n   ST    R1,MY_P_1\n   LA    R1,MESS_TXT\n   ST    R1,MY_P_8\n   LA    R1,MY_P_8\n   ST    R1,MY_P_2\n   LA    R1,L'MESS_TXT\n   ST    R1,MY_P_9\n   LA    R1,MY_P_9\n   ST    R1,MY_P_3\n   OI    MY_P_3,X'80'\n   L     R0,#SAV_REX+12                rexx environment block addr\n   LA    R1,MY_PARM\n   USING IRXEXTE,15\n   L     15,ENVBLOCK_IRXEXTE\n   L     15,IRXSAY\n   DROP  15\n   BASR  14,15\n   IF (LTR,R15,R15,NZ)\n     ST    R15,R_C\n     SEGDO WRITE_LOG\n     MVC   MESS_TXT(19),=C'Return code on SAY='\n     XUNPK R_C,4,MESS_TXT+19\n     SEGDO WRITE_LOG\n   ENDIF\n   MVI   MESS_TXT,C' '\n   MVC   MESS_TXT+1(L'MESS_TXT-1),MESS_TXT\n*\n SEGE CALL_IRXSAY\n*______________________________________________________________________\n*\n               PRGSTAT\n*\nCOPY_STEM_NAME MVC   0(1,R1),0(R15)\nCOPY_VAR_NUMB  MVC   0(1,R3),0(R1)\nPACK_STEM_0    PACK  STEM_ZERO_COUNT,0(0,R14)\n*\nE_D_STEM_0     DC    C'Error in drop_stem_zero RC='\nE_I_STEM_0     DC    C'Error in init_stem_zero RC='\nE_D_STEM_LINE  DC    C'Error in drop_stem_line RC='\nE_G_STEM_ZERO  DC    C'Error in get_stem_zero  RC='\nE_S_STEM_LINE  DC    C'Error in set_stem_line  RC='\nE_S_STEM_ZERO  DC    C'Error in set_stem_zero  RC='\nERR_STEM_LINE  DC    C'Error reading stem.? RC='\nNEW_VARIABLE_1 DC    C'Warning - the fetched variable was created'\nNEW_VARIABLE_2 DC    C'The STEM.0 count is probably incorrect'\nNEW_VARIABLE_3 DC    C'Warning - the fetched variable was created'\nSPACES         DC    80CL1' '\n*\n               LTORG\n*\n               PRGSTEM DSECT=Y\n*\n               PRGESTAT\n               PRGEND\n               END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "REXXPCRE": {"ttr": 87, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01!\\x004\\x01\\x17\\x15\\x0f\\x01 \"?\\x10&\\x05V\\x05-\\x00\\x00\\xe2\\xc4\\xd1\\xd9\\xc7@@@@@'", "ispf": {"version": "01.33", "flags": 0, "createdate": "2017-05-30T00:00:00", "modifydate": "2020-08-10T10:26:34", "lines": 1366, "newlines": 1325, "modlines": 0, "user": "SDJRG"}, "text": " TITLE 'REXXPCRE - REXX FUNCTION FOR PERL COMPATIBLE REGEX'\n PRINT GEN\nREXXPCRE PRGDEF FSEG=MAIN_BIT,REXX=Y,RMODE=24\n*______________________________________________________________________\n*\n* This is the PEXXPCRE interface between the Rexx language on z/OS\n* and the PCRE2 - regex processing library on same platform.\n* Version 0.3\n* Contributed by:   John Gateley  January 2017.\n* Amended     by:   John Gateley  June 2017 (use sub-module for stem)\n* Amended     by:   John Gateley  Nov. 2017 (add code page argument\n*                                            and swap result values\n*                                            1 = match\n*                                            2 = no match)\n* Copyright (c) 2017, John Gateley.\n* All rights reserved.\n*\n*______________________________________________________________________\n*\n* Redistribution and use in source and binary forms, with or\n* without modification, are permitted provided that the following\n* conditions are met:\n*\n*  1. Redistributions of source code must retain the above\n*  copyright notice, this list of conditions and the following\n*  disclaimer.\n*\n*  2. Redistributions in binary form must reproduce the above\n*  copyright notice, this list of conditions and the following\n*  disclaimer in the documentation and/or other materials\n*  provided with the distribution.\n*\n*  3. Neither the name of the University of Cambridge nor the\n*  names of its contributors may be used to endorse or promote\n*  products derived from this software without specific prior\n*  written permission.\n*\n* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND\n* CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES,\n* INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n* MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n* DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR\n* CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n* SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n* NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n* HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n* CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR\n* OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,\n* EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*______________________________________________________________________\n*\n* This program acts as a REXX function and is designed to be used\n* with the z/OS port of 'PCRE2 - Perl Compatible Regular Expressions'\n* which was created by Ze'ev Atlas.\n*\n* This program was written by John Gateley in January 2017\n*\n* To assemble this program you will need to supplied macros and will\n* also need to assemble module STRINGIT which is used in STRING macro.\n*\n* An article \"Calling C functions from Assembler - revisited\"\n* by A Rudd printed in issue 208 of Xephon magazine of January 2004\n* was very useful when I wrote this program.\n* http://www.cbttape.org/xephon/xephonm/mvs0401.pdf\n*\n*    INPUT ARGUMENTS\n*      1, the PERL expression\n*      2, the string to be worked on\n*      3, a STEM name which will be populated with the output\n*      4, an optional OPTION\n*                     'g'  -  match all\n*                     'i'  -  ignore case\n*                     'x'  -  exclude white space\n*      5, an optional code-page - e.g.  'IBM-285'\n*         if omitted the default local page is used\n*      6, 'debug' if debugging required. Needs PCREDUMP DD name.\n*\n*    OUTPUT\n*         if   successfull\n*              RC=1    matched  - stem contains output\n*              RC=0    no match - stem.0 will be '0'\n*         else\n*              RC='error message text'\n*         endif\n*\n*    STEM variables output\n*         stem.0             count of stem variables\n*         stem.STRING.?      matched substrings\n*         stem.POS.?         position and length of matches e.g. 3,4\n*         stem.NAME.?        named substrings ' ' if none\n*\n*    DEBUGGING can be done by specifying 'debug' as argument 6.\n*              You will also need to allocate the DD name PCREDUMP\n*              with DISP=MOD if more than one call to REXXPCRE\n*              because each call is a separate unit of work which\n*              includes opening and closing the dataset.\n*______________________________________________________________________\n*\n* EXAMPLE USAGE (please rely on the latest code in the accompanied\n* Rexx program TRYPCRE1)\n*\n* /*REXX*/\n*\n*   \"ISPEXEC LIBDEF ISPLLIB DATASET ID ('MY.LOAD.LIBRARY') STACK\"\n*\n*   /*  test 1                                                  */\n*\n*   reg_ex  = \"(?<char>A)\\g<char>\"\n*   the_str = \"AN_AARDWARK_JAKE_AND_aaRDWARK_JACK\"\n*   my_stem = \"WANG\"\n*   opt_ion = \"gi\"\n*   code_pg = \"IBM-285'\n*\n*   say the_str\n*\n*   drop wang.\n*\n*   re_sponse = REXXPCRE(reg_ex,the_str,my_stem,opt_ion)\n*\n*   select\n*      when re_sponse = 1 then do\n*         say 'wang.0  is  ' wang.0\n*         do lo_op_r = 1 to wang.0\n*            say  wang.string.lo_op_r\n*            say  wang.pos.lo_op_r  '       '  wang.name.lo_op_r\n*         end\n*        end\n*      when re_sponse = 0 then\n*         say 'no matches found'\n*      Otherwise\n*         say 'Error :' re_sponse\n*   end\n*\n*   drop wang.\n*\n*   say '  '\n*\n*   /*  test 2                                                  */\n*\n*   the_str = \"The quick brown fox jumps over the lazy dog.\"\n*   the_Str = the_str||\"The quick brown fox jumps over the\"\n*   reg_ex  = \"(quick|jump)\"\n*   my_stem = \"WANG\"\n*\n*   say the_str\n*\n*   /* no option specified but use debug mode                   */\n*\n*   re_sponse = REXXPCRE(reg_ex,the_str,my_stem,,,'debug')\n*\n*   select\n*      when re_sponse = 1 then do\n*         say 'wang.0  is  ' wang.0\n*         do lo_op_r = 1 to wang.0\n*            say  wang.string.lo_op_r\n*            say  wang.pos.lo_op_r  '       '  wang.name.lo_op_r\n*         end\n*        end\n*      when re_sponse = 0 then\n*         say 'no matches found'\n*      Otherwise\n*         say 'Error :' re_sponse\n*   end\n*\n*   drop wang.\n*\n*   say '  '\n*\n*   /*  test 3                                                  */\n*\n*   the_str = \"A fat cat doesn't eat oat but a rat eats bats.\"\n*   reg_ex  = \"(at)\"\n*   my_stem = \"WANG\"\n*   opt_ion = \"g\"\n*\n*   say the_str\n*\n*   re_sponse = REXXPCRE(reg_ex,the_str,my_stem,opt_ion)\n*\n*   select\n*      when re_sponse = 1 then do\n*         say 'wang.0  is  ' wang.0\n*         do lo_op_r = 1 to wang.0\n*            say  wang.string.lo_op_r\n*            say  wang.pos.lo_op_r  '       '  wang.name.lo_op_r\n*         end\n*        end\n*      when re_sponse = 0 then\n*         say 'no matches found'\n*      Otherwise\n*         say 'Error :' re_sponse\n*   end\n*\n*   drop wang.\n*\n*   /*  test 4                                                  */\n*\n*   the_str = \"He_jumps_brown_fox\"\n*   reg_ex  = \"(?<first>quick|jumps_+(?<second>brown|over)_+(fox|the))\"\n*   my_stem = \"WANG\"\n*\n*   say the_str\n*\n*   re_sponse = REXXPCRE(reg_ex,the_str,my_stem,'g')\n*\n*   select\n*      when re_sponse = 1 then do\n*         say 'wang.0  is  ' wang.0\n*         do lo_op_r = 1 to wang.0\n*            say  wang.string.lo_op_r\n*            say  wang.pos.lo_op_r  '       '  wang.name.lo_op_r\n*         end\n*        end\n*      when re_sponse = 0 then\n*         say 'no matches found'\n*      Otherwise\n*         say 'Error :' re_sponse\n*   end\n*\n*   /*  test 5                                                  */\n*   /*                                                          */\n*   /*  this test uses the dollar symbol which is code page     */\n*   /*  dependant in EBCDIC. In IBM-037 the dollar is x'5B'     */\n*   /*  but in IBM-285 (UK) this is the currency symbol         */\n*   /*  for GBP and the dollar is at x'4A' which is the cent    */\n*   /*  symbol in IBM-037. Confusing!                           */\n*   /*  Internally PCRE2 uses IBM-1047 so to use the dollar     */\n*   /*  symbol in the regex we pass a fifth argument which      */\n*   /*  is the code page name we are actually using.            */\n*   /*  This causes PCRE to convert the regex from IBM-285      */\n*   /*  to IBM-1047 before it is compiled, similarly the        */\n*   /*  string is converted before the match is done.           */\n*\n*   /*  NOTE - this argument is only required if you use        */\n*   /*         a code page in your terminal emulator which      */\n*   /*         is NOT the same as the default local code page.  */\n*   /*         Normal processing by PCRE is to convert the      */\n*   /*         REGEX and string from the default local code     */\n*   /*         page to IBM-1047.                                */\n*   /*         IBM-1047 is used by the mainframe C compiler.    */\n*\n*   pa_rm    = \"INDSN(DSNAME(MEMBER))\"\n*\n*   reg_ex  = \"\\((.*)\\)\u00a2\"\n*   opt_ion = \"g\"\n*\n*   say pa_rm\n*   say reg_ex\n*\n*   re_sponse = REXXPCRE(reg_ex,pa_rm,'wang',opt_ion,'IBM-285')\n*\n*   select\n*      when re_sponse = 1 then do\n*         say 'wang.0  is  ' wang.0\n*         do lo_op_r = 1 to wang.0\n*            var_1  =  substr(wang_string.lo_op_r,1,30)\n*            var_2  =  substr(wang_pos.lo_op_r,1,10)\n*            var_3  =  wang_name.lo_op_r\n*            say  var_1 var_2 var_3\n*         end\n*        end\n*      when re_sponse = 0 then\n*         say 'no matches found'\n*      Otherwise\n*         say 'Error :' re_sponse\n*   end\n*\n*   drop wang.\n*\n*   \"ispexec libdef ispllib \"\n*\n*   exit\n*______________________________________________________________________\n*\n*  REENTRANT STORAGE\n*\nREG_EX_ADDR          DS    F           details of supplied REGEX\nREG_EX_LEN           DS    F\nREG_EX_END           DS    F\nTHE_STR_ADDR         DS    F           details of supplied string\nTHE_STR_LENGTH       DS    F\nTHE_STR_END          DS    F\nCODEPAGE_PTR         DS    F\nCODEPAGE_LEN         DS    F\nCODEPAGE_RES         DS    F\nCONV_REGEX_ADDR      DS    F\nCONV_REGEX_LEN       DS    F\nCONV_SUBJECT_PTR     DS    F\nCONV_SUBJECT_LEN     DS    F\n*\nPCREWS_ERRORNUMBER   DS    F           PCRE working storage\nPCREWS_ERROROFFSET   DS    F\nPCREWS_RE_PTR        DS    F\nPCREWS_MATCH_DATA    DS    F\nPCREWS_NULL_PTR      DS    F\nPCREWS_PATTERN_PTR   DS    F\nPCREWS_SUBJECT_PTR   DS    F\nPCREWS_SUBJECT_LEN   DS    F\nPCREWS_RC            DS    F\nPCREWS_OVECTOR       DS    F\nPCREWS_NAMECOUNT     DS    F\nPCREWS_NAME_TABLE    DS    F\nPCREWS_NAME_ENTSZ    DS    F\nPCRE2_INFO_NAMECOUNT EQU   17\nPCRE2_INFO_NAM_ENTSZ EQU   18\nPCRE2_INFO_NAMETABLE EQU   19\n*\nHIGHEST_MATCH        DS    F           address of highest match\nCURRENT_ADDRESS      DS    F\nCURRENT_COUNT        DS    F\n*\nHANDLE               DS    A           address of the C environment\nFUNC_NAME            DS    A           C function to be called\nCONVERT_HANDLE       DS    A           address of code-page converter\n*\n                     PRGSTEM PREF=ROOT       for  STEM.0\n                     PRGSTEM PREF=POS             STEM.POS.?\n                     PRGSTEM PREF=NAMED           STEM.NAME.?\n                     PRGSTEM PREF=STRING          STEM.STRING.?\n*\n*    The parameter area used to call IRXEXCOM (shared variable access)\nIX_PARM              DS    4F\n*\nVAR_TEXT             DC    CL8' '\nVAR_POINT            DC    H'0'\nFIRST_SET_MATCH      DC    PL4'0'      stem count at start of search\n*\nERR_NO               DS    CL1         some indicators\nREPEAT_SRCH          DS    CL1\nIGNORE_CASE          DS    CL1\nEXCLUDE_WHITE        DS    CL1\nC_ENV_SETUP          DS    CL1\nCONV_SETUP           DS    CL1\nREGX_COMPILED        DS    CL1\nMATCH_DONE           DS    CL1\nDEBUG_MODE           DS    CL1\nPCREDUMP_OPEN        DS    CL1\nWORK_32              DS    CL32        32 bytes used when debugging\nCALL_STEM_MESS       DS    CL26        error message for PROCSTEM call\nERR_BUFFER           DS    CL256       area for error message\n*\nSTEM_POS             DS    F           position in string\nSTEM_LEN             DS    F           length of substring\nMAX_STEM_LEN         EQU   2048        max length of a stem variable\nSTEM_TEXT            DS    CL(MAX_STEM_LEN)   storage for stem value\n*\n        PRGEDEF\n*______________________________________________________________________\n*\n SEGS MAIN_BIT\n*\n   ZAP   FIRST_SET_MATCH,=P'0'         initialise\n*\n   SEGDO GET_ARGUMENTS\n*\n   SEGDO INIT_STEM_VARIABLES\n*\n   IF (CLI,DEBUG_MODE,EQ,C'Y')\n     OPEN  (PCREDUMP,OUTPUT)           open output file\n     IF (LTR,15,R15,NZ)                error on open\n       MVI   ERR_NO,16\n       SEGDO NOT_VALID\n     ENDIF\n     MVI   PCREDUMP_OPEN,C'Y'          flag as open\n     SEGDO WRITE_PCREDUMP              write blank line\n     MVC   MESS_TXT(22),=C'Rexx function starting'\n     SEGDO WRITE_PCREDUMP              write MESS_TXT to PCREDUMP\n     MVC   MESS_TXT(12),=C'Repeat srch='\n     MVC   MESS_TXT+12(1),REPEAT_SRCH\n     SEGDO WRITE_PCREDUMP\n     MVC   MESS_TXT(12),=C'Ignore case='\n     MVC   MESS_TXT+12(1),IGNORE_CASE\n     SEGDO WRITE_PCREDUMP\n     MVC   MESS_TXT(14),=C'Exclude white='\n     MVC   MESS_TXT+14(1),EXCLUDE_WHITE\n     SEGDO WRITE_PCREDUMP\n   ENDIF\n*\n   SEGDO SET_C_ENVIRONMENT\n*\n   MVC   PCREWS_PATTERN_PTR,REG_EX_ADDR\n   MVC   PCREWS_SUBJECT_PTR,THE_STR_ADDR\n   MVC   PCREWS_SUBJECT_LEN,THE_STR_LENGTH\n*\n   SEGDO COMPILE_REGEX\n*\n   IF (CLC,PCREWS_RE_PTR,EQ,=F'0')\n     SEGDO COMPILE_ERROR\n   ENDIF\n   IF (CLI,DEBUG_MODE,EQ,C'Y')\n     MVC   MESS_TXT(14),=C'REGEX compiled'\n     SEGDO WRITE_PCREDUMP\n   ENDIF\n   MVI   REGX_COMPILED,C'Y'            flag as compiled\n*\n   SEGDO CREATE_MATCH_BLOCK\n   IF (CLI,DEBUG_MODE,EQ,C'Y')\n     MVC   MESS_TXT(19),=C'Match block created'\n     SEGDO WRITE_PCREDUMP\n   ENDIF\n*\n   MVC   FUNC_NAME,=V(ZCSCONVS)        set C function required\n   L     R14,CONVERT_HANDLE            code page conversion handle\n   L     R15,PCREWS_SUBJECT_PTR        string to convert\n   L     R0,PCREWS_SUBJECT_LEN         length of string\n   LA    R1,CONV_SUBJECT_PTR           field for converted address\n   LA    R2,CONV_SUBJECT_LEN           field for converted length\n   STM   R14,R2,MY_P_3                 save parameters\n   SEGDO CALL_C_FUNCTION               go and compile it\n   IF (CLI,DEBUG_MODE,EQ,C'Y')\n     MVC   MESS_TXT(20),=CL20'STRING converted'\n     XUNPK CONV_SUBJECT_PTR,4,MESS_TXT+20\n     XUNPK CONV_SUBJECT_LEN,4,MESS_TXT+30\n     SEGDO WRITE_PCREDUMP\n   ENDIF\n*\n   SEGDO DO_FIRST_MATCH\n*\n   IF (CLI,REPEAT_SRCH,EQ,C'Y')\n     IF (CLI,DEBUG_MODE,EQ,C'Y')\n       MVC   MESS_TXT(15),=C'Trying for more'\n       SEGDO WRITE_PCREDUMP\n     ENDIF\n     DO INF\n     DOEXIT (CLC,HIGHEST_MATCH,EQ,=F'0')\n       SEGDO TRY_FOR_MORE\n     ENDDO\n   ENDIF\n*\n   SEGDO END_C_ENVIRONMENT\n*\n   IF (CLI,DEBUG_MODE,EQ,C'Y')\n     MVC   MESS_TXT(20),=C'Rexx function ending'\n     SEGDO WRITE_PCREDUMP\n     CLOSE PCREDUMP                    close output file\n   ENDIF\n*\n SEGE MAIN_BIT\n*______________________________________________________________________\n*\n SEGS COMPILE_REGEX\n*\n*  convert the REGEX to code-page 1047\n*\n   MVC   FUNC_NAME,=V(ZCSCONVP)        set C function required\n   L     R14,CONVERT_HANDLE\n   L     R15,REG_EX_ADDR\n   L     R0,REG_EX_LEN\n   LA    R1,CONV_REGEX_ADDR\n   LA    R2,CONV_REGEX_LEN\n   STM   R14,R2,MY_P_3                 save parameters\n   SEGDO CALL_C_FUNCTION               go and compile it\n   IF (CLI,DEBUG_MODE,EQ,C'Y')\n     MVC   MESS_TXT(20),=CL20'REGEX converted'\n     XUNPK CONV_REGEX_ADDR,4,MESS_TXT+20\n     XUNPK CONV_REGEX_LEN,4,MESS_TXT+30\n     SEGDO WRITE_PCREDUMP\n   ENDIF\n*\n*  compile the REGEX\n*\n   MVC   FUNC_NAME,=V(COMPILE2)        set C function required\n*  L     R14,REG_EX_ADDR               address of REGEX\n*  LHI   R15,-1                        -1\n   L     R14,CONV_REGEX_ADDR           address of REGEX\n   L     R15,CONV_REGEX_LEN            length of REGEX\n   LA    R0,0                          0 = no options\n   IF (CLI,IGNORE_CASE,EQ,C'Y')\n     A     R0,PCRE2_CASELESS           add ignore case value\n   ENDIF\n   IF (CLI,EXCLUDE_WHITE,EQ,C'Y')\n     A     R0,PCRE2_EXTENDED           add exclude white space\n   ENDIF\n   LA    R1,PCREWS_ERRORNUMBER         error number field\n   LA    R2,PCREWS_ERROROFFSET         error offfset field\n   LA    R3,0                          0\n   STM   R14,R3,MY_P_3                 save parameters\n   SEGDO CALL_C_FUNCTION               go and compile it\n   ST    R15,PCREWS_RE_PTR             save returned address\n*\n SEGE COMPILE_REGEX\n*______________________________________________________________________\n*\n SEGS CREATE_MATCH_BLOCK\n*\n*  create a block to hold results of the REGEX\n*\n   MVC   FUNC_NAME,=V(MATCDCFP)        set C function\n   L     R14,PCREWS_RE_PTR\n   L     R15,PCREWS_NULL_PTR\n   STM   R14,R15,MY_P_3                save parameters\n   SEGDO CALL_C_FUNCTION\n   ST    R15,PCREWS_MATCH_DATA         save returned address\n*\n SEGE CREATE_MATCH_BLOCK\n*______________________________________________________________________\n*\n SEGS DO_FIRST_MATCH\n*\n*  see if there is a match for the REGEX in the supplied string\n*\n   MVI   MATCH_DONE,C'Y'               flag matching\n   MVC   FUNC_NAME,=V(MATCH2)          set C function\n   L     R14,PCREWS_RE_PTR\n   L     R15,PCREWS_SUBJECT_PTR\n   L     R0,PCREWS_SUBJECT_LEN\n   LA    R1,0\n   LA    R2,0\n   L     R3,PCREWS_MATCH_DATA\n   L     R4,PCREWS_NULL_PTR\n   STM   R14,R4,MY_P_3                 save parameters\n   SEGDO CALL_C_FUNCTION\n   ST    R15,PCREWS_RC                 save returned value\n   IF (CLI,DEBUG_MODE,EQ,C'Y')\n     STRING ('First match return was ',C,PCREWS_RC,X)\n     SEGDO WRITE_PCREDUMP\n   ENDIF\n   L     R15,PCREWS_RC                 reload RC (write changes R15)\n   IF (LTR,R15,R15,M)                  < 0\n     IF (CHI,R15,EQ,-1)\n       IF (CLI,DEBUG_MODE,EQ,C'Y')\n         MVC   MESS_TXT(8),=C'No match'\n         SEGDO WRITE_PCREDUMP\n       ENDIF\n     ELSE\n       STRING (ERR_13,C,PCREWS_RC,I)\n       MVC   EVALBLOCK_EVDATA(80),MESS_TXT\n       LA    R1,80\n       ST    R1,EVALBLOCK_EVLEN        return 'error message'\n     ENDIF\n     SEGQUIT                           and quit this segment\n   ENDIF\n*\n   MVC   FUNC_NAME,=V(GETOVEPT)        set C function\n   L     R1,PCREWS_MATCH_DATA\n   ST    R1,MY_P_3                     save parameter\n   SEGDO CALL_C_FUNCTION\n   ST    R15,PCREWS_OVECTOR\n*\n*  See if output vector wasn't big enough. This should not happen,\n*  because we used pcre2_match_data_create_from_pattern() above.\n*\n   IF (CLC,PCREWS_RC,EQ,=F'0')\n     MVC   MESS_TXT(L'ERR_17),ERR_17\n     IF (CLI,DEBUG_MODE,EQ,C'Y')\n       SEGDO WRITE_PCREDUMP\n     ELSE\n       SEGDO CALL_IRXSAY\n     ENDIF\n   ENDIF\n*\n   SETRC RC=1                          return '1' when something found\n*\n   SEGDO OUTPUT_MATCH_RESULTS\n*\n   SEGDO TRY_NAMED_SUBSTRING\n*\n SEGE DO_FIRST_MATCH\n*______________________________________________________________________\n*\n SEGS TRY_FOR_MORE\n*\n*  g option specified so try for more matches\n*\n   MVC   FUNC_NAME,=V(MATCH2)          set C function\n   L     R14,PCREWS_RE_PTR\n   L     R15,PCREWS_SUBJECT_PTR\n   L     R0,PCREWS_SUBJECT_LEN\n   L     R1,HIGHEST_MATCH\n   LA    R2,0\n   L     R6,PCREWS_OVECTOR             point to output vector\n   IF (CLC,0(4,R6),EQ,4(R6))           empty string ?\n     L     R2,PCRE2_ANCHORED           set options in R2\n     A     R2,PCRE2_NOT_EMPTY\n   ENDIF\n   L     R3,PCREWS_MATCH_DATA\n   L     R4,PCREWS_NULL_PTR\n   STM   R14,R4,MY_P_3                 save parameters\n   SEGDO CALL_C_FUNCTION\n   ST    R15,PCREWS_RC\n   IF (CLI,DEBUG_MODE,EQ,C'Y')\n     STRING ('Next match return was ',C,PCREWS_RC,X)\n     SEGDO WRITE_PCREDUMP\n   ENDIF\n   L     R15,PCREWS_RC\n   IF (LTR,R15,R15,NP)                 < 1\n     XC    HIGHEST_MATCH,HIGHEST_MATCH   flag no more matches\n     IF (CHI,R15,EQ,-1)\n       SEGQUIT                         found all the matches\n     ELSE\n       STRING (ERR_13,C,PCREWS_RC,I)\n       MVC   EVALBLOCK_EVDATA(80),MESS_TXT\n       LA    R1,80\n       ST    R1,EVALBLOCK_EVLEN        return 'error message'\n     ENDIF\n     SEGQUIT                           and quit this segment\n   ENDIF\n*\n   MVC   FUNC_NAME,=V(GETOVEPT)        set C function\n   L     R1,PCREWS_MATCH_DATA\n   ST    R1,MY_P_3                     save parameter\n   SEGDO CALL_C_FUNCTION\n   ST    R15,PCREWS_OVECTOR\n*\n*  See if output vector wasn't big enough. This should not happen,\n*  because we used pcre2_match_data_create_from_pattern() above.\n*\n   IF (CLC,PCREWS_RC,EQ,=F'0')\n     MVC   MESS_TXT(22),=C'Ovector not big enough'\n     IF (CLI,DEBUG_MODE,EQ,C'Y')\n       SEGDO WRITE_PCREDUMP\n     ELSE\n       SEGDO CALL_IRXSAY\n     ENDIF\n   ENDIF\n*\n   SEGDO OUTPUT_MATCH_RESULTS\n*\n   SEGDO TRY_NAMED_SUBSTRING\n*\n SEGE TRY_FOR_MORE\n*______________________________________________________________________\n*\n SEGS OUTPUT_MATCH_RESULTS\n*\n*  output the results of the REGEX match\n*\n*  When bytes 4 and 5 match the expression the values returned are\n*  3 and 5. So length of match is (5-3).\n*\n   XC    HIGHEST_MATCH,HIGHEST_MATCH   set to zero\n*\n   IF (CLI,DEBUG_MODE,EQ,C'Y')\n     L     R6,PCREWS_OVECTOR           point to output vector\n     L     R3,PCREWS_RC                count of values\n     DO FROM=(R3)\n       LM    R4,R5,0(R6)               offset and end of match\n       STRING ('Ovector',C,(R4),X,(R4),I,(R5),X,(R5),I),PADB=Y\n       SEGDO WRITE_PCREDUMP\n       LA    R6,8(,R6)                 point past this pair of values\n     ENDDO\n   ENDIF\n*\n   ZAP   FIRST_SET_MATCH,POS_ZERO_COUNT  save current variable count\n*\n   L     R6,PCREWS_OVECTOR             point to output vector\n   L     R3,PCREWS_RC                  count of values\n   DO FROM=(R3)\n     LM    R4,R5,0(R6)                 offset and end of match\n     IF (C,R5,GT,HIGHEST_MATCH)        keep highest position\n       ST    R5,HIGHEST_MATCH\n     ENDIF\n     IF (C,R5,GE,THE_STR_LENGTH)       at end of string\n       XC    HIGHEST_MATCH,HIGHEST_MATCH   set to zero\n     ENDIF\n     IF (CR,R5,EQ,R6)                  match is empty string\n       XC    HIGHEST_MATCH,HIGHEST_MATCH   set to zero\n     ENDIF\n     SR    R5,R4                       get length\n     IF (CFI,R5,GT,MAX_STEM_LEN)       string to long\n       MVI   ERR_NO,11\n       SEGDO NOT_VALID\n     ENDIF\n     IF (CLI,DEBUG_MODE,EQ,C'Y')\n       STRING ('Match succeeded at offset ',C,(R4),I,                  /\n               ' length ',C,(R5),I)\n       SEGDO WRITE_PCREDUMP\n     ENDIF\n     LA    R4,1(,R4)                   convert offset to position\n     ST    R4,STEM_POS                 save position\n     BCTR  R4,0                        back to offset\n     ST    R5,STEM_LEN                 save length\n     L     R1,THE_STR_ADDR             get address of string\n     LA    R4,0(R1,R4)                 point to first matching byte\n     LA    R14,STEM_TEXT               area for stem value\n     LR    R15,R5                      copy length\n     MVCL  R14,R4                      copy fragment to output area\n     ST    R6,CURRENT_ADDRESS          save current position\n     ST    R3,CURRENT_COUNT            save current count\n     SEGDO STEM_LINE                   go output stem line\n     L     R6,CURRENT_ADDRESS          restore position\n     L     R3,CURRENT_COUNT            restore count\n     LA    R6,8(,R6)                   point past this pair of values\n   ENDDO\n*\n SEGE OUTPUT_MATCH_RESULTS\n*______________________________________________________________________\n*\n SEGS TRY_NAMED_SUBSTRING\n*\n*  see if there is a named substring available in this match\n*\n   MVC   FUNC_NAME,=V(PATTERN2)\n   L     R14,PCREWS_RE_PTR\n   LA    R15,PCRE2_INFO_NAMECOUNT\n   LA    R0,PCREWS_NAMECOUNT\n   STM   R14,R0,MY_P_3\n   SEGDO CALL_C_FUNCTION\n   IF (CLI,DEBUG_MODE,EQ,C'Y')\n     STRING   ('Name count is ',C,PCREWS_NAMECOUNT,I)\n     SEGDO WRITE_PCREDUMP\n   ENDIF\n   IF (CLC,PCREWS_NAMECOUNT,GT,=F'0')  got some names?\n     IF (CLI,DEBUG_MODE,EQ,C'Y')\n       MVC   MESS_TXT(16),=C'Named substrings'\n       SEGDO WRITE_PCREDUMP\n     ENDIF\n     MVC   FUNC_NAME,=V(PATTERN2)\n     L     R14,PCREWS_RE_PTR\n     LA    R15,PCRE2_INFO_NAMETABLE\n     LA    R0,PCREWS_NAME_TABLE\n     STM   R14,R0,MY_P_3\n     SEGDO CALL_C_FUNCTION\n     MVC   FUNC_NAME,=V(PATTERN2)\n     L     R14,PCREWS_RE_PTR\n     LA    R15,PCRE2_INFO_NAM_ENTSZ\n     LA    R0,PCREWS_NAME_ENTSZ\n     STM   R14,R0,MY_P_3\n     SEGDO CALL_C_FUNCTION\n     IF (CLI,DEBUG_MODE,EQ,C'Y')\n       STRING   ('Name size is  ',C,PCREWS_NAME_ENTSZ,I)\n       SEGDO WRITE_PCREDUMP\n     ENDIF\n     IF (CLI,DEBUG_MODE,EQ,C'Y')\n       L     R4,PCREWS_NAME_TABLE\n       MVC   WORK_32,0(R4)\n       STRING   ('Name table is ',C,WORK_32,X)\n       SEGDO WRITE_PCREDUMP\n     ENDIF\n     L     R5,PCREWS_NAMECOUNT         get count of names\n     L     R4,PCREWS_NAME_TABLE        point to name table\n     DO FROM=(R5)                      loop counter\n       LH    R1,0(R4)                  get array offset\n       CVD   R1,DOUB_WORD              convert to decimal\n       AP    DOUB_WORD,FIRST_SET_MATCH add start of this set results\n       L     R1,PCREWS_NAME_ENTSZ      length of name entry\n       AHI   R1,-2                     -2 for halfword variable number\n       AHI   R1,-1                     -1 for EX (and the null)\n       ST    R1,STEM_LEN               save length of text\n       EX    R1,COPY_NAME_TEXT         copy text could end in nulls\n       IF (CLI,DEBUG_MODE,EQ,C'Y')\n         STRING (STEM_LEN,I)\n         MVC   MESS_TXT+14(32),STEM_TEXT\n         SEGDO WRITE_PCREDUMP\n       ENDIF\n       L     R1,STEM_LEN               restore in case debug\n       LA    R14,STEM_TEXT             point at output area\n       LA    R14,0(R1,R14)             point after last output byte\n       BCTR  R14,0                     now pointing at last\n       DO FROM=(R1)                    loop count on output length\n       DOEXIT (CLI,0(R14),GT,X'00')    quit when not null\n         BCTR  R14,0                   point back a byte\n       ENDDO\n       ST    R1,STEM_LEN               save new length of text\n       IF (CLI,DEBUG_MODE,EQ,C'Y')\n         STRING (STEM_LEN,I)\n         MVC   MESS_TXT+14(32),STEM_TEXT\n         SEGDO WRITE_PCREDUMP\n       ENDIF\n       SEGDO STEM_LINE_NAME\n       A     R4,PCREWS_NAME_ENTSZ      next entry in name table\n     ENDDO\n   ENDIF\n*\n SEGE TRY_NAMED_SUBSTRING\n*______________________________________________________________________\n*\n SEGS COMPILE_ERROR\n*\n*  error occured compiling the REGEX - output message\n*\n   MVC   FUNC_NAME,=V(GETERROR)        set C function\n   L     R14,PCREWS_ERRORNUMBER        get error number\n   LA    R15,ERR_BUFFER                boint to buffer\n   LHI   R0,256                        length is 356 bytes\n   STM   R14,R0,MY_P_3                 save in parameter list\n   SEGDO CALL_C_FUNCTION\n   STRING (ERR_14,C,PCREWS_ERROROFFSET,I)\n   MVC   EVALBLOCK_EVDATA(60),MESS_TXT set return value\n   MVC   EVALBLOCK_EVDATA+61(190),ERR_BUFFER\n   LA    R1,250                        which is length 250\n   ST    R1,EVALBLOCK_EVLEN            set length of returned value\n   SEGDO END_C_ENVIRONMENT\n   IF (CLI,DEBUG_MODE,EQ,C'Y'),AND,(CLI,PCREDUMP_OPEN,EQ,C'Y')\n     CLOSE PCREDUMP\n   ENDIF\n   PRGQUIT                             quit the program\n*\n SEGE COMPILE_ERROR\n*______________________________________________________________________\n*\n SEGS GET_ARGUMENTS\n*\n*  reads the arguments provided to this rexx function\n*\n   MVI   REPEAT_SRCH,C'N'              indicate option not set\n   MVI   IGNORE_CASE,C'N'              indicate option not set\n   MVI   EXCLUDE_WHITE,C'N'            indicate option not set\n*\n*  first argument should be the REGEX\n*\n   IF (CLC,ARGTABLE_ARGSTRING_PTR,EQ,=8X'FF')\n     MVI   ERR_NO,1\n     SEGDO NOT_VALID\n   ELSEIF (CLC,ARGTABLE_ARGSTRING_LENGTH,EQ,=F'0')\n     MVI   ERR_NO,2\n     SEGDO NOT_VALID\n   ENDIF\n   MVC   REG_EX_ADDR,ARGTABLE_ARGSTRING_PTR    address of argument\n   MVC   REG_EX_LEN,ARGTABLE_ARGSTRING_LENGTH  length or argument\n*\n*  second argument should be the string to work on\n*\n   LA    ARG_POINT,ARGTABLE_NEXT       check for second argument\n   IF (CLC,ARGTABLE_ARGSTRING_PTR,EQ,=8X'FF')\n     MVI   ERR_NO,3\n     SEGDO NOT_VALID\n   ELSEIF (CLC,ARGTABLE_ARGSTRING_LENGTH,EQ,=F'0')\n     MVI   ERR_NO,4\n     SEGDO NOT_VALID\n   ENDIF\n   L     R14,ARGTABLE_ARGSTRING_PTR\n   L     R15,ARGTABLE_ARGSTRING_LENGTH\n   LA    R0,0(R14,R15)                 point after last byte\n   BCTR  R0,0                          back one byte\n   STM   R14,R0,THE_STR_ADDR           set address, length and end\n*\n*  third argument should be the STEM name to populate\n*\n   LA    ARG_POINT,ARGTABLE_NEXT       check for third argument\n   IF (CLC,ARGTABLE_ARGSTRING_PTR,EQ,=8X'FF')\n     MVI   ERR_NO,5                    must have stem name\n     SEGDO NOT_VALID\n   ELSEIF (CLC,ARGTABLE_ARGSTRING_LENGTH,EQ,=F'0')\n     MVI   ERR_NO,6                    zero length argument\n     SEGDO NOT_VALID\n   ELSEIF (CLC,ARGTABLE_ARGSTRING_LENGTH,GT,=F'20')\n     MVI   ERR_NO,7                    arbitary max length\n     SEGDO NOT_VALID\n   ENDIF\n*\n   MVC   ROOT_NAME_ADR,ARGTABLE_ARGSTRING_PTR\n   MVC   ROOT_NAME_LEN,ARGTABLE_ARGSTRING_LENGTH\n   MVC   POS_NAME_ADR,ARGTABLE_ARGSTRING_PTR\n   MVC   POS_NAME_LEN,ARGTABLE_ARGSTRING_LENGTH\n   MVC   NAMED_NAME_ADR,ARGTABLE_ARGSTRING_PTR\n   MVC   NAMED_NAME_LEN,ARGTABLE_ARGSTRING_LENGTH\n   MVC   STRING_NAME_ADR,ARGTABLE_ARGSTRING_PTR\n   MVC   STRING_NAME_LEN,ARGTABLE_ARGSTRING_LENGTH\n*\n*  fourth argument is optional and can be 0 length\n*\n   LA    ARG_POINT,ARGTABLE_NEXT       check for fourth argument\n   IF (CLC,ARGTABLE_ARGSTRING_PTR,EQ,=8X'FF')\n     SEGQUIT                           * not provided so carry on\n   ELSEIF (CLC,ARGTABLE_ARGSTRING_LENGTH,GT,=F'20')\n     MVI   ERR_NO,8                    arbitary max length\n     SEGDO NOT_VALID\n   ELSEIF (CLC,ARGTABLE_ARGSTRING_LENGTH,NE,=F'0')  not 0 length\n     L     R14,ARGTABLE_ARGSTRING_PTR  address of argument\n     L     R15,ARGTABLE_ARGSTRING_LENGTH length or argument\n*\n*  about to look for options currently  G/g  I/i  X/x\n*\n     DO FROM=(R15)                     R15 has length of argument\n       IF (CLI,0(R14),EQ,C'G')         check for repeat search\n         MVI   REPEAT_SRCH,C'Y'        flag as found\n       ELSEIF (CLI,0(R14),EQ,C'g')     check for repeat search\n         MVI   REPEAT_SRCH,C'Y'        flag as found\n       ELSEIF (CLI,0(R14),EQ,C'I')     check for ignore case\n         MVI   IGNORE_CASE,C'Y'        flag as found\n       ELSEIF (CLI,0(R14),EQ,C'i')     check for ignore case\n         MVI   IGNORE_CASE,C'Y'        flag as found\n       ELSEIF (CLI,0(R14),EQ,C'X')     check for exclude white space\n         MVI   EXCLUDE_WHITE,C'Y'      flag as found\n       ELSEIF (CLI,0(R14),EQ,C'x')     check for exclude white space\n         MVI   EXCLUDE_WHITE,C'Y'      flag as found\n       ELSE\n         MVI   ERR_NO,9                unknown option value\n         SEGDO NOT_VALID\n       ENDIF\n       LA    R14,1(,R14)               next byte in argument\n     ENDDO\n   ENDIF\n*\n*  fifth argument is optional and can be 0 length\n*\n   LA    ARG_POINT,ARGTABLE_NEXT       check for fifth argument\n   IF (CLC,ARGTABLE_ARGSTRING_PTR,EQ,=8X'FF')\n     SEGQUIT                           * not provided so carry on\n   ELSEIF (CLC,ARGTABLE_ARGSTRING_LENGTH,NE,=F'0')  not 0 length\n     MVC   CODEPAGE_PTR,ARGTABLE_ARGSTRING_PTR     address of argument\n     MVC   CODEPAGE_LEN,ARGTABLE_ARGSTRING_LENGTH  length oF argument\n   ENDIF\n*\n*  sixth argument is optional but must be 'debug'\n*\n   LA    ARG_POINT,ARGTABLE_NEXT       check for fifth argument\n   IF (CLC,ARGTABLE_ARGSTRING_PTR,NE,=8X'FF')\n     IF (CLC,ARGTABLE_ARGSTRING_LENGTH,NE,=F'0')\n       IF (CLC,ARGTABLE_ARGSTRING_LENGTH,NE,=F'5')\n         MVI   ERR_NO,10                 fifth argument <> 5 bytes\n         SEGDO NOT_VALID\n       ENDIF\n       L     R14,ARGTABLE_ARGSTRING_PTR  address of argument\n       MVC   WORK_32(5),0(R14)           copy argument\n       OC    WORK_32(5),=C'     '        make upper case\n       IF (CLC,=C'DEBUG',EQ,WORK_32)     check for DEBUG\n         MVI   DEBUG_MODE,C'Y'           flag debug mode\n       ENDIF\n       MVC   WORK_32(5),=C'     '        clear to spaces\n     ENDIF\n   ENDIF\n*\n SEGE GET_ARGUMENTS\n*______________________________________________________________________\n*\n SEGS INIT_STEM_VARIABLES\n*\n   MVI   ROOT_TRIM_VAR,C'N'            do not trim spaces from var\n   MVHHI ROOT_FUNCTION,1               init STEM.0\n   LA    R1,ROOT_AREA                  point to STEM. area\n   SEGDO CALL_PROCSTEM\n*\n   MVI   POS_TRIM_VAR,C'Y'             do trim spaces from var\n   MVC   POS_MID_NAME,=CL20'POS'       specify required .MIDDLE.\n   MVHHI POS_FUNCTION,1                init STEM.POS.0\n   LA    R1,POS_AREA                   point to STEM.POS. area\n   SEGDO CALL_PROCSTEM\n*\n   MVI   NAMED_TRIM_VAR,C'N'           do not trim spaces from var\n   MVC   NAMED_MID_NAME,=CL20'NAME'\n   MVHHI NAMED_FUNCTION,1              init STEM.NAME.0\n   LA    R1,NAMED_AREA                 point to STEM.NAME. area\n   SEGDO CALL_PROCSTEM\n*\n   MVI   STRING_TRIM_VAR,C'N'          do not trim spaces from var\n   MVC   STRING_MID_NAME,=CL20'STRING'\n   MVHHI STRING_FUNCTION,1             init STEM.STRING.0\n   LA    R1,STRING_AREA                point to STEM.STRING. area\n   SEGDO CALL_PROCSTEM\n*\n SEGE INIT_STEM_VARIABLES\n*______________________________________________________________________\n*\n SEGS STEM_LINE\n*\n*  sets stem.STRING.? to the substring of the input string\n*  sets stem.NAME.?   to ' '\n*  sets stem.POS.?    to 'x,y'         position,length\n*\n*  output the stem.STRING.? variable\n*\n   LA    R1,STEM_TEXT                  address of stem text\n   ST    R1,STRING_TEXT_ADR            store address\n   MVC   STRING_TEXT_LEN,STEM_LEN      copy length\n   MVHHI STRING_FUNCTION,2             set STEM.STRING.? value\n   LA    R1,STRING_AREA                point to PRGSTEM expansion\n   MVC   CALL_STEM_MESS,=CL26'Error in stem.string line'\n   SEGDO CALL_PROCSTEM\n*\n*  output the stem.POS.? variable\n*\n   LA    R1,STEM_TEXT                  address of stem text\n   ST    R1,POS_TEXT_ADR               store address\n   STRING (STEM_POS,I,',',C,STEM_LEN,I),OUT=STEM_TEXT\n*                                      output from string is 23 bytes\n*                                      '         4+,         2+'\n   LA    R1,22                         required length\n   MVI   STEM_TEXT+10,C' '             make middle '+' into ' '\n   ST    R1,POS_TEXT_LEN               set length\n   MVHHI POS_FUNCTION,2                set STEM.POS.? value\n   LA    R1,POS_AREA                   point to PRGSTEM expansion\n   MVC   CALL_STEM_MESS,=CL26'Error in stem.pos line'\n   SEGDO CALL_PROCSTEM\n*\n*  output the stem.NAME.? variable as just ' ' for now\n*\n   LA    R1,STEM_TEXT                  point to text\n   MVI   STEM_TEXT,C' '                make blank\n   ST    R1,NAMED_TEXT_ADR             store address\n   LA    R1,1                          required length\n   ST    R1,NAMED_TEXT_LEN             set length\n   MVHHI NAMED_FUNCTION,2              set STEM value\n   LA    R1,NAMED_AREA                 point to PRGSTEM expansion\n   MVC   CALL_STEM_MESS,=CL26'Error in stem.name 1 line'\n   SEGDO CALL_PROCSTEM\n*\n*  output the stem.? variable as just ' '\n*\n   LA    R1,STEM_TEXT                  point to text\n   MVI   STEM_TEXT,C' '                make blank\n   ST    R1,ROOT_TEXT_ADR              store address\n   LA    R1,1                          required length\n   ST    R1,ROOT_TEXT_LEN              set length\n   MVHHI ROOT_FUNCTION,2               set STEM value\n   LA    R1,ROOT_AREA                  point to PRGSTEM expansion\n   MVC   CALL_STEM_MESS,=CL26'Error in stem.     line'\n   SEGDO CALL_PROCSTEM\n*\n*  set stem.0 to the current count\n*\n   SEGDO STEM_ZERO                     update stem.0 with new value\n*\n SEGE STEM_LINE\n*______________________________________________________________________\n*\n SEGS STEM_LINE_NAME\n*\n*  previously created stem.NAME.? variable as ' '\n*  now it is time to put in the real value\n*\n   LA    R1,STEM_TEXT                  point to text\n   ST    R1,NAMED_TEXT_ADR             store address\n   MVC   NAMED_TEXT_LEN,STEM_LEN       copy length\n   MVHHI NAMED_FUNCTION,2              set STEM value\n   ZAP   NAMED_ZERO_COUNT,DOUB_WORD+4(4)  put in variable number\n   LA    R1,NAMED_AREA                 point to PRGSTEM expansion\n   MVC   CALL_STEM_MESS,=CL26'Error in stem.name 2 line'\n   SEGDO CALL_PROCSTEM\n*\n   ZAP   NAMED_ZERO_COUNT,POS_ZERO_COUNT   put back MAX value\n*\n SEGE STEM_LINE_NAME\n*______________________________________________________________________\n*\n SEGS STEM_ZERO\n*\n*  populate stem.pos.0 with current stem count\n*\n   MVHHI POS_FUNCTION,3                set STEM.POS.0 to total lines\n   LA    R1,POS_AREA\n   MVC   CALL_STEM_MESS,=CL26'Error in stem.pos  zero'\n   SEGDO CALL_PROCSTEM\n*\n*  keep all the other STEMs in line\n*\n   ZAP   ROOT_ZERO_COUNT,POS_ZERO_COUNT\n   MVHHI ROOT_FUNCTION,3               set STEM.0 to total lines\n   LA    R1,ROOT_AREA\n   MVC   CALL_STEM_MESS,=CL26'Error in stem.     zero'\n   SEGDO CALL_PROCSTEM\n*\n   ZAP   NAMED_ZERO_COUNT,POS_ZERO_COUNT\n   MVHHI NAMED_FUNCTION,3              set STEM.NAME.0 to total lines\n   LA    R1,NAMED_AREA\n   MVC   CALL_STEM_MESS,=CL26'Error in stem.name zero'\n   SEGDO CALL_PROCSTEM\n*\n   ZAP   STRING_ZERO_COUNT,POS_ZERO_COUNT\n   MVHHI STRING_FUNCTION,3             set STEM.STRING.0 to total lines\n   LA    R1,STRING_AREA\n   MVC   CALL_STEM_MESS,=CL26'Error in stem.string zero'\n   SEGDO CALL_PROCSTEM\n*\n SEGE STEM_ZERO\n*______________________________________________________________________\n*\n SEGS CALL_PROCSTEM\n*\n*  R1 should already point to the required PRGSTEM macro expansion\n   ST    R1,MY_P_1                     save as first parm\n   LA    R1,MY_PARM                    point to parameter list\n   L     R15,=V(PROCSTEM)              get program address\n   BASR  R14,R15                       go and set stem value\n   IF (LTR,R15,R15,NZ)                 error ?\n     ST    R15,R_C                     save return code\n     STRING (CALL_STEM_MESS,C,R_C,I)\n     IF (CLI,DEBUG_MODE,EQ,C'Y')\n       SEGDO WRITE_PCREDUMP\n     ELSE\n       SEGDO CALL_IRXSAY\n     ENDIF\n     SEGDO END_C_ENVIRONMENT\n     IF (CLI,DEBUG_MODE,EQ,C'Y'),AND,(CLI,PCREDUMP_OPEN,EQ,C'Y')\n       CLOSE PCREDUMP\n     ENDIF\n     PRGQUIT                           get out of program\n   ENDIF\n*\n SEGE CALL_PROCSTEM\n*______________________________________________________________________\n*\n SEGS NOT_VALID\n*\n*  an error occured so set error message as output from REXX function\n*\n   MVC   EVALBLOCK_EVLEN,=F'30'        set length of returned value\n   IF (CLI,ERR_NO,EQ,1)\n     MVC   EVALBLOCK_EVDATA(L'ERR_1),ERR_1\n     LA    R1,L'ERR_1\n   ELSEIF (CLI,ERR_NO,EQ,2)\n     MVC   EVALBLOCK_EVDATA(L'ERR_2),ERR_2\n     LA    R1,L'ERR_2\n   ELSEIF (CLI,ERR_NO,EQ,3)\n     MVC   EVALBLOCK_EVDATA(L'ERR_3),ERR_3\n     LA    R1,L'ERR_3\n   ELSEIF (CLI,ERR_NO,EQ,4)\n     MVC   EVALBLOCK_EVDATA(L'ERR_4),ERR_4\n     LA    R1,L'ERR_4\n   ELSEIF (CLI,ERR_NO,EQ,5)\n     MVC   EVALBLOCK_EVDATA(L'ERR_5),ERR_5\n     LA    R1,L'ERR_5\n   ELSEIF (CLI,ERR_NO,EQ,6)\n     MVC   EVALBLOCK_EVDATA(L'ERR_6),ERR_6\n     LA    R1,L'ERR_6\n   ELSEIF (CLI,ERR_NO,EQ,7)\n     MVC   EVALBLOCK_EVDATA(L'ERR_7),ERR_7\n     LA    R1,L'ERR_7\n   ELSEIF (CLI,ERR_NO,EQ,8)\n     MVC   EVALBLOCK_EVDATA(L'ERR_8),ERR_8\n     LA    R1,L'ERR_8\n   ELSEIF (CLI,ERR_NO,EQ,9)\n     MVC   EVALBLOCK_EVDATA(L'ERR_9),ERR_9\n     LA    R1,L'ERR_9\n   ELSEIF (CLI,ERR_NO,EQ,10)\n     MVC   EVALBLOCK_EVDATA(L'ERR_10),ERR_10\n     LA    R1,L'ERR_10\n   ELSEIF (CLI,ERR_NO,EQ,11)\n     MVC   EVALBLOCK_EVDATA(L'ERR_11),ERR_11\n     LA    R1,L'ERR_11\n   ELSEIF (CLI,ERR_NO,EQ,16)\n     MVC   EVALBLOCK_EVDATA(L'ERR_16),ERR_16\n     LA    R1,L'ERR_16\n   ELSE    this should never happen\n     MVC   EVALBLOCK_EVDATA(30),=CL30'Unknown error, RC='\n     XR    R1,R1\n     IC    R1,ERR_NO\n     CVD   R1,DOUB_WORD\n     OI    DOUB_WORD+7,X'0F'\n     UNPK  EVALBLOCK_EVDATA+18(4),DOUB_WORD\n     XC    R_C,R_C\n     LA    R1,30\n   ENDIF\n   ST    R1,EVALBLOCK_EVLEN            Set length of returned value\n*\n   IF (CLI,C_ENV_SETUP,EQ,C'Y')\n     SEGDO END_C_ENVIRONMENT\n   ENDIF\n*\n   IF (CLI,DEBUG_MODE,EQ,C'Y'),AND,(CLI,PCREDUMP_OPEN,EQ,C'Y')\n     CLOSE PCREDUMP\n   ENDIF\n   PRGQUIT                             get out of program\n*\n SEGE NOT_VALID\n*______________________________________________________________________\n*\n SEGS SET_C_ENVIRONMENT\n*\n*  set up C environment with librarian functionality\n*\n   LA    R1,HANDLE                     address for returned handle\n   ST    R1,MY_P_1\n   LA    R1,STKSIZE                    stack size\n   ST    R1,MY_P_2\n   LA    R1,STKLOC                     stack location\n   ST    R1,MY_P_3\n   OI    MY_P_3,X'80'                  set VL flag\n   LA    R1,MY_PARM                    address of argument list\n   L     R15,=V(EDCXHOTL)\n   BASR  R14,R15                       go set up C environment\n*\n   IF (CLI,DEBUG_MODE,EQ,C'Y')\n     MVC   MESS_TXT(22),=C'C environment obtained'\n     SEGDO WRITE_PCREDUMP\n   ENDIF\n*\n   MVC   FUNC_NAME,=V(ZCSINIT)\n   LA    R14,CONVERT_HANDLE            return address of code pages\n   L     R15,CODEPAGE_PTR              may be 0 if not specified\n*                                      0 means current code page\n   L     R0,CODEPAGE_LEN               length of code page name\n   LHI   R1,2048                       max size of pattern\n   LHI   R2,8192                       max size of string\n   STM   R14,R1,MY_P_3                 save in parameter list\n   SEGDO CALL_C_FUNCTION\n   ST    R15,CODEPAGE_RES\n   IF (CLI,DEBUG_MODE,EQ,C'Y'),AND,(CLI,PCREDUMP_OPEN,EQ,C'Y')\n     MVC   MESS_TXT(20),=CL20'init convert routine'\n     XUNPK (R15),4,MESS_TXT+25\n     XUNPK CONVERT_HANDLE,4,MESS_TXT+35\n     IF (CLC,CODEPAGE_RES,NE,=F'0')\n       MVC   MESS_TXT+45(8),=C'- FAILED'\n     ENDIF\n     L     R1,CODEPAGE_PTR\n     IF (LTR,R1,R1,NZ)\n       L     R2,CODEPAGE_LEN\n       IF (CHI,R2,GT,30)               allow max of 30 characters\n         LA    R2,30\n       ENDIF\n       BCTR  R2,0\n       EX    R2,COPY_CODEPAGE\n     ELSE\n       MVC   MESS_TXT+55(7),=C'DEFAULT'\n     ENDIF\n     SEGDO WRITE_PCREDUMP\n   ENDIF\n   IF (CLC,CODEPAGE_RES,NE,=F'0')\n     SEGDO END_C_ENVIRONMENT\n     IF (CLI,DEBUG_MODE,EQ,C'Y'),AND,(CLI,PCREDUMP_OPEN,EQ,C'Y')\n       CLOSE PCREDUMP\n     ENDIF\n     MVC   EVALBLOCK_EVDATA(L'ERR_15),ERR_15\n     LA    R1,L'ERR_15\n     ST    R1,EVALBLOCK_EVLEN            set length of returned value\n     PRGQUIT                             quit the program\n   ENDIF\n   MVI   CONV_SETUP,C'Y'\n*\n SEGE SET_C_ENVIRONMENT\n*______________________________________________________________________\n*\n SEGS END_C_ENVIRONMENT\n*\n*  terminate C environment after cleaning up\n*\n   IF (CLI,MATCH_DONE,EQ,C'Y')\n     MVC   FUNC_NAME,=V(MATCHDFR)      free any matches\n     L     R1,PCREWS_MATCH_DATA\n     ST    R1,MY_P_3\n     SEGDO CALL_C_FUNCTION\n     IF (CLI,DEBUG_MODE,EQ,C'Y')\n       MVC   MESS_TXT(15),=C'Called MATCHDFR'\n       SEGDO WRITE_PCREDUMP\n     ENDIF\n   ENDIF\n*\n   IF (CLI,REGX_COMPILED,EQ,C'Y')\n     MVC   FUNC_NAME,=V(CODEFREE)      free compiled code\n     L     R1,PCREWS_RE_PTR\n     ST    R1,MY_P_3\n     SEGDO CALL_C_FUNCTION\n     IF (CLI,DEBUG_MODE,EQ,C'Y')\n       MVC   MESS_TXT(15),=C'Called CODEFREE'\n       SEGDO WRITE_PCREDUMP\n     ENDIF\n   ENDIF\n   IF (CLI,CONV_SETUP,EQ,C'Y')\n     MVI   CONV_SETUP,0\n     MVC   FUNC_NAME,=V(ZCSRLSE)\n     L     R14,CONVERT_HANDLE            return address of code pages\n     ST    R14,MY_P_3                    save in parameter list\n     SEGDO CALL_C_FUNCTION\n     IF (CLI,DEBUG_MODE,EQ,C'Y')\n       MVC   MESS_TXT(30),=CL30'release convert routine'\n       SEGDO WRITE_PCREDUMP\n     ENDIF\n   ENDIF\n*\n*  terminate C environment with librarian functionality\n*\n   LA    R1,HANDLE\n   ST    R1,MY_P_1\n   OI    MY_P_1,X'80'                  set VL flag\n   LA    R1,MY_PARM\n   L     R15,=V(EDCXHOTT)\n   BASR  R14,R15                       terminate C environment\n   IF (CLI,DEBUG_MODE,EQ,C'Y')\n     MVC   MESS_TXT(22),=C'C environment released'\n     SEGDO WRITE_PCREDUMP\n   ENDIF\n*\n SEGE END_C_ENVIRONMENT\n*______________________________________________________________________\n*\n SEGS CALL_C_FUNCTION\n*\n*  parameters from 3 onward are set so just add handle and function\n*\n   LA    R1,HANDLE                     address of C environment\n   ST    R1,MY_P_1\n   LA    R1,FUNC_NAME                  function name\n   ST    R1,MY_P_2\n   LA    R1,MY_PARM                    point to parameters\n   L     R15,=V(EDCXHOTU)\n   BASR  R14,R15\n   MVI   C_ENV_SETUP,C'Y'\n*\n SEGE CALL_C_FUNCTION\n*______________________________________________________________________\n*\n SEGS CALL_IRXSAY\n*\n   LA    R1,=CL8'WRITE'\n   ST    R1,MY_P_1\n   LA    R1,MESS_TXT\n   ST    R1,MY_P_8\n   LA    R1,MY_P_8\n   ST    R1,MY_P_2\n   LA    R1,L'MESS_TXT\n   ST    R1,MY_P_9\n   LA    R1,MY_P_9\n   ST    R1,MY_P_3\n   OI    MY_P_3,X'80'\n   L     R0,#SAV_REX+12                rexx environment block addr\n   LA    R1,MY_PARM\n   USING IRXEXTE,15\n   L     15,ENVBLOCK_IRXEXTE\n   L     15,IRXSAY\n   DROP  15\n   BASR  14,15\n   IF (LTR,R15,R15,NZ)\n     ST    R15,R_C\n     SEGDO WRITE_LOG                   write original message\n     MVC   MESS_TXT(L'ERR_12),ERR_12\n     XUNPK R_C,4,MESS_TXT+19\n     SEGDO WRITE_LOG                   then this error message\n   ENDIF\n   MVI   MESS_TXT,C' '\n   MVC   MESS_TXT+1(L'MESS_TXT-1),MESS_TXT\n*\n SEGE CALL_IRXSAY\n*______________________________________________________________________\n*\n SEGS WRITE_PCREDUMP\n*\n   PUT   PCREDUMP,MESS_TXT             output text to PCREDUMP\n   MVI   MESS_TXT,C' '                 clear message line\n   MVC   MESS_TXT+1(L'MESS_TXT-1),MESS_TXT\n*\n SEGE WRITE_PCREDUMP\n*______________________________________________________________________\n*\n               PRGSTAT\n*\nPCREDUMP DCB   DSORG=PS,DDNAME=PCREDUMP,LRECL=80,MACRF=(PM),RECFM=FB\n*\nERR_1  DC  C'REXXPCRE-001 - REGEX (argument 1) not supplied'\nERR_2  DC  C'REXXPCRE-002 - REGEX (argument 1) was zero length'\nERR_3  DC  C'REXXPCRE-003 - STRING (argument 2) not supplied'\nERR_4  DC  C'REXXPCRE-004 - STRING (argument 2) was zero length'\nERR_5  DC  C'REXXPCRE-005 - STEM NAME (argument 3) not supplied'\nERR_6  DC  C'REXXPCRE-006 - STEM NAME (argument 3) was zero length'\nERR_7  DC  C'REXXPCRE-007 - STEM NAME (argument 3) > 20 bytes'\nERR_8  DC  C'REXXPCRE-008 - OPTIONS (argument 4) > 20 bytes'\nERR_9  DC  C'REXXPCRE-009 - OPTIONS (argument 4) not recognised'\nERR_10 DC  C'REXXPCRE-010 - DEBUG (argument 6) <> 5 bytes'\nERR_11 DC  C'REXXPCRE-011 - Output value longer than 2048'\nERR_12 DC  C'REXXPCRE-012 - Return code on SAY='\nERR_13 DC  C'REXXPCRE-013 - Matching error '\nERR_14 DC  C'REXXPCRE-014 - PCRE2 compilation failed at offset '\nERR_15 DC  C'REXXPCRE-015 - Code page failure (argument 5)'\nERR_16 DC  C'REXXPCRE-016 - Debug specified but DD name PCREDUMP not al/\n               located'\nERR_17 DC  C'REXXPCRE-017 - Ovector not big enough'\n*\nSTKSIZE        DC    F'4096'     stack size\nSTKLOC         DC    F'1'        stack location (0 < 16MB, 1 >= 16MB)\n*\nCOPY_NAME_TEXT MVC   STEM_TEXT(1),2(R4)\nDO_MOVE        MVC   0(1,R3),0(R1)\nCOPY_CODEPAGE  MVC   MESS_TXT+55(0),0(R1)\n*\n                     DS    0F          ensure fullword aligned\nPCRE2_CASELESS       DC    X'00000008'\nPCRE2_EXTENDED       DC    X'00000080'\nPCRE2_NOT_EMPTY      DC    X'00000008'\nPCRE2_ANCHORED       DC    X'80000000'\n*\n               LTORG\n*\n               PRGESTAT\n               PRGEND\n               END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "RXPCRE2": {"ttr": 89, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01+\\x00\\x00\\x01\\x17(?\\x01 \"?\\x10%\\x04\\xbf\\x03\\xb6\\x00\\x00\\xe2\\xc4\\xd1\\xd9\\xc7@@@@@'", "ispf": {"version": "01.43", "flags": 0, "createdate": "2017-10-10T00:00:00", "modifydate": "2020-08-10T10:25:00", "lines": 1215, "newlines": 950, "modlines": 0, "user": "SDJRG"}, "text": " TITLE 'RXPCRE2 - REXX FUNCTION FOR PERL COMPATIBLE REGEX'\n PRINT GEN\nRXPCRE2  PRGDEF FSEG=MAIN_BIT,REXX=Y,RMODE=24\n*______________________________________________________________________\n*\n* This is the RXPCRE2 interface between the Rexx language on z/OS\n* and the PCRE2 - regex processing library on same platform.\n*\n* Version 0.1\n* Contributed by:   John Gateley  September 2017.\n* Copyright (c) 2017, John Gateley.\n* All rights reserved.\n* 2019-dec      :   add substitute function\n*               :   move PCREDUMP DCB to RXPCRE2 to allow RMODE=31\n*                   for load module RXPCRE2A\n*______________________________________________________________________\n*\n* Redistribution and use in source and binary forms, with or\n* without modification, are permitted provided that the following\n* conditions are met:\n*\n*  1. Redistributions of source code must retain the above\n*  copyright notice, this list of conditions and the following\n*  disclaimer.\n*\n*  2. Redistributions in binary form must reproduce the above\n*  copyright notice, this list of conditions and the following\n*  disclaimer in the documentation and/or other materials\n*  provided with the distribution.\n*\n*  3. Neither the name of the University of Cambridge nor the\n*  names of its contributors may be used to endorse or promote\n*  products derived from this software without specific prior\n*  written permission.\n*\n* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND\n* CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES,\n* INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n* MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n* DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR\n* CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n* SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n* NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n* HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n* CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR\n* OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,\n* EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*______________________________________________________________________\n*\n* This program acts as a REXX function and is designed to be used\n* with the z/OS port of 'PCRE2 - Perl Compatible Regular Expressions'\n* which was created by Ze'ev Atlas.\n*\n* This program was written by John Gateley in September 2017.\n*\n* To assemble these programs you will need to supplied macros and will\n* also need to assemble modules STRINGIT which is used in STRING macro\n* and TRIMIT which is used by the TRIM macro.\n*______________________________________________________________________\n*\n* How it works.\n*\n* This program RXPCRE2 is a rexx function and RXPCRE2A is a helper.\n* On the 'connect' call RXPCRE2A is loaded into memory and the\n* address of the program is returned, this enables the program to\n* be found on subsequent calls.\n* The 'disconnect' function terminates the C environment and deletes\n* RXPCRE2A from memory.\n*\n*\n* There are 6 calls to the function\n*\n*\n* 1, CONNECT\n*    Establish the C environment with or without debug.\n*    If OK returns an eight byte environment handle which should\n*    be used in subsequent calls to the function.\n*    An optional third parameter is the code page that is being used,\n*    this defaults to a z/OS environment variable but can be set\n*    byt the user.\n*    If DEBUG is specified then the DDNAME PCREDUMP must be allocated\n*    with DISP=MOD as the dataset will be opened and closed on\n*    every call.\n*    Additional PCRE options can be specified using a stem variable\n*    as the fifth parameter\n*    op_t.1 = 'PCRE2_DOLLAR_ENDONLY'\n*    op_t.2 = 'PCRE2_DOTALL'\n*    op_t.3 = 'PCRE2_DUPNAMES'\n*    op_t.0 = '3'\n*\n*    Returns 0 if OK\n*            8 if failed - an error message will be writen using IRXSAY\n*\n*      r_c     = RXPCRE2('connect','pcre_env')\n*      r_c     = RXPCRE2('connect','pcre_env',,'debug')\n*      r_c     = RXPCRE2('connect','pcre_env')\n*      r_c     = RXPCRE2('connect','pcre_env',IBM-285,'debug','op_t')\n*\n*      if  r_c  > 0 then exit\n*\n*\n* 2, COMPILE\n*    Compile the PCRE regular expression.\n*    This returns an nineteen byte compile handle which should\n*    be used in subsequent calls to the function.\n*    Note that the reg_ex must be null terminated.\n*    Options can be specified\n*                 'g'  repeat search\n*                 'i'  ignore case\n*                 'x'  exclude white space\n*\n*    Returns 0 if OK\n*            8 if failed - an error message will be writen using IRXSAY\n*\n*      reg_ex  = \"(?<char>A)\\g<char>\"||'00'x\n*\n*      r_c     = RXPCRE2('compile',pcre_env,reg_ex,'pcre_comp','g')\n*\n*      if  r_c  > 0 then exit\n*\n*\n* 3, MATCH - alias EXEC and EXECUTE\n*    Process the compiled expression, repeat this call as required.\n*    The STEM name is used as the first part of the output\n*    'WANG' will give  WANG.0         the count of matches\n*                      WANG_STRING.?  the sub-strings\n*                      WANG_POS.?     the positions within the string\n*                      WANG_NAME.?    named sub-strings (blank if none)\n*\n*    returns  0     no match - stem.string.0 will be '0'\n*             1     matched  - stem.string.? contains output\n*             8     an error message will be writen using IRXSAY\n*\n*      the_str   = \"AN_AARDWARK_JAKE_AND_AARDWARK_JACK\"\n*      my_stem   = \"WANG\"\n*\n*      r_c = RXPCRE2('execute',pcre_env,pcre_comp,the_str,my_stem)\n*\n*    This call can be repeated as many times as required.\n*\n*\n* 4, SUBSTITUTE - alias SUBS\n*    This is similar to EXECUTE but uses the routine SUBSTIT2\n*    instead of MATCH2 and requires an additional input containing\n*    the substitute string.\n*    The variable name is used to contain the output string\n*\n*    returns  0     no match - rexx variable not set\n*             1     matched  - rexx variable contains output string\n*             8     an error message will be writen using IRXSAY\n*\n*      reg_ex      \"cat|dog\"\n*      the_str     \"the dog sat on the cat's dog\"\n*      subs_str    \"horse\"\n*      my_var    = \"WANG\"\n*\n*      r_c = RXPCRE2('substitute',pcre_env,pcre_comp,the_str,,\n*                    my_var,subs_str)\n*\n*    This call can be repeated as many times as required.\n*\n*\n* 5, RELEASE\n*    Release the compile storage\n*    Returns 0 if successfull.\n*            8 if failed - an error message will be writen using IRXSAY\n*\n*      re_lease  = RXPCRE2('release',pcre_env,pcre_comp)\n*\n*\n* 6, DISCONNECT\n*    Terminate the C environment.\n*    Returns 0 if successfull.\n*            8 if failed - an error message will be writen using IRXSAY\n*\n*      r_c     = RXPCRE2('disconnect',pcre_env)\n*\n*\n* NOTE if any call fails then the C environment will be terminated.\n*______________________________________________________________________\n*\n*    STEM variables output\n*         stem.0             count of stem variables\n*         stem_STRING.?      matched substrings\n*         stem_POS.?         position and length of matches e.g. 3,4\n*         stem_NAME.?        named substrings ' ' if none\n*\n*    these stem values will contain the same as stem.0\n*         stem_STRING.0\n*         stem_POS.0\n*         stem_NAME.0\n*______________________________________________________________________\n*\n*         PCRELIB\n*\n*  When running in batch the LOAD macro will try to find the requested\n*  module/program object in the STEPLIB or JOBLIB concatenation\n*  which will contain the PDSE library containing RXPCRE2A. This works.\n*\n*  In ISPF the library would be concatenated to ISPLLIB which will\n*  allow RXPCRE2 to be loaded, however, when this tries to load\n*  RXPCRE2A the STEPLIB would be used and would fail.\n*  It should be possible to put the program library in the ISPLLIB\n*  concatenation and amend all references to PCRELIB to ISPLLIB\n*  but this will not work when ISPLLIB is modified using LIBDEF as\n*  the library is not added to the actual ISPLLIB but to another\n*  DDNAME which is logically concatenated by ISPF.\n*\n*  For the above reasons PCRELIB is used. If it is not present in the\n*  task IO table the program will not attempt to use it.\n*\n*      /* allow RXPCRE2 to be loaded by REXX */\n*      \"ISPEXEC LIBDEF ISPLLIB DATASET ID ('SDJRG.LOADLIB.POBJ')\"\n*      if rc /= 0 then do\n*         say 'allocation to ispllib failed.'\n*         exit\n*      end\n*      /* allow RXPCRE2A to be loaded by RXPCRE2A */\n*      \"ALLOC FI(PCRELIB)  DA('?????.LOADLIB.POBJ') SHR\"\n*      if rc /= 0 then do\n*         say 'allocation to PCRELIB failed.'\n*         exit\n*      end\n*\n*      ...\n*\n*      \"FREE FILE(PCRELIB)\"\n*      \"ISPEXEC LIBDEF ISPLLIB \"\n*______________________________________________________________________\n*\n*  REENTRANT STORAGE\n*\nLOAD_ADDRESS         DS    F\nLOAD_ADDR_CHAR       DS    CL8\n*\nCOMPILE_CHAR         DS    CL19\n                     DS    0F\nCOMPILE_DATA         DS    CL11\n                     ORG   COMPILE_DATA\nPCREWS_RE_PTR        DS    F\nPCREWS_MATCH_DATA    DS    F\nREPEAT_SRCH          DS    CL1         flags\nIGNORE_CASE          DS    CL1\nEXCLUDE_WHITE        DS    CL1\n                     ORG\n*\nREG_EX_ADDR          DS    F           details of supplied REGEX\nREG_EX_LENGTH        DS    F\nREG_EX_END           DS    F\nTHE_STR_ADDR         DS    F           details of supplied string\nTHE_STR_LENGTH       DS    F\nTHE_STR_END          DS    F\nSUBS_STR_ADDR        DS    F           details of substitute string\nSUBS_STR_LENGTH      DS    F\nSUBS_STR_END         DS    F\nSTEM_NAME_ADR        DS    F           rexx stem or variable name\nSTEM_NAME_LEN        DS    F\nCODEPAGE_PTR         DS    F\nCODEPAGE_LEN         DS    F\nOPTION_WORD          DS    F\nENV_H_LEN            DS    F\nENV_H_NAME           DS    CL20\nCOMP_LEN             DS    F\nCOMP_NAME            DS    CL20\n*\nTHE_COMMAND          DS    CL20        input command\nWORK_32              DS    CL32        32 bytes of work area\n*\nFREE_C_NEEDED        DS    CL1         flag if C environment exists\nERR_NO               DS    CL1         some indicators\nDEBUG_MODE           DS    CL1\n*\n*                    the parameter area used to call irxexcom\nIX_PARM              DS    4F\nPARM_AREA            DS    (SHVBLEN)XL1\n*\n        PRGEDEF\n*\n        USING SHVBLOCK,R6\n*______________________________________________________________________\n*\n SEGS MAIN_BIT\n*\n   XC    OPTION_WORD,OPTION_WORD       clear options\n*\n   SEGDO GET_FIRST_ARGUMENT            into THE_COMMAND\n*\n*  some commands have alternatives so set the actual command here\n*\n   IF (CLC,=C'COMP ',EQ,THE_COMMAND)         alias for COMPILE\n     MVC   THE_COMMAND,=CL20'COMPILE'\n   ELSEIF (CLC,=C'EXECUTE ',EQ,THE_COMMAND)  alias for MATCH\n     MVC   THE_COMMAND,=CL20'MATCH'\n   ELSEIF (CLC,=C'EXEC ',EQ,THE_COMMAND)     alias for MATCH\n     MVC   THE_COMMAND,=CL20'MATCH'\n   ELSEIF (CLC,=C'SUBS ',EQ,THE_COMMAND)     alias for SUBSTITUTE\n     MVC   THE_COMMAND,=CL20'SUBSTITUTE'\n   ENDIF\n*\n   IF (CLC,=C'CONNECT ',EQ,THE_COMMAND)\n     SEGDO GET_CONNECT_ARGUMENTS\n     SEGDO CONNECT_PROCESS\n   ELSEIF (CLC,=C'COMPILE ',EQ,THE_COMMAND)\n     MVI   FREE_C_NEEDED,C'Y'\n     SEGDO GET_COMPILE_ARGUMENTS\n     SEGDO COMPILE_PROCESS\n   ELSEIF (CLC,=C'MATCH ',EQ,THE_COMMAND)\n     MVI   FREE_C_NEEDED,C'Y'\n     SEGDO GET_MATCH_ARGUMENTS\n     SEGDO MATCH_PROCESS\n   ELSEIF (CLC,=C'SUBSTITUTE ',EQ,THE_COMMAND)\n     MVI   FREE_C_NEEDED,C'Y'\n     SEGDO GET_SUBSTITUTE_ARGUMENTS\n     SEGDO SUBSTITUTE_PROCESS\n   ELSEIF (CLC,=C'RELEASE ',EQ,THE_COMMAND)\n     MVI   FREE_C_NEEDED,C'Y'\n     SEGDO GET_RELEASE_ARGUMENTS\n     SEGDO RELEASE_PROCESS\n   ELSEIF (CLC,=C'DISCONNECT ',EQ,THE_COMMAND)\n     SEGDO DISCONNECT_PROCESS\n     SEGDO DELETE_RXPCRE2A\n   ELSE\n     MVI   ERR_NO,1                    invalid command\n     SEGDO NOT_VALID\n   ENDIF\n*\n SEGE MAIN_BIT\n*______________________________________________________________________\n*\n SEGS GET_FIRST_ARGUMENT\n*\n*  first argument should be the command\n*\n   IF (CLC,ARGTABLE_ARGSTRING_PTR,EQ,=8X'FF')\n     MVI   ERR_NO,2\n     SEGDO NOT_VALID\n   ELSEIF (CLC,ARGTABLE_ARGSTRING_LENGTH,EQ,=F'0')\n     MVI   ERR_NO,3\n     SEGDO NOT_VALID\n   ELSEIF (CLC,ARGTABLE_ARGSTRING_LENGTH,GT,=F'20')\n     MVI   ERR_NO,4                    arbitary max length\n     SEGDO NOT_VALID\n   ENDIF\n   L     R14,ARGTABLE_ARGSTRING_PTR    address of argument\n   L     R15,ARGTABLE_ARGSTRING_LENGTH length or argument\n   BCTR  R15,0                         length less one\n   MVC   THE_COMMAND,SPACES            initialise\n   EX    R15,COPY_COMMAND              copy the command\n   OC    THE_COMMAND,SPACES            make uppercase\n*\n   IF (CLC,=C'CONNECT ',NE,THE_COMMAND)\n*\n*    next argument should be the environment which is 8 bytes.\n*\n     LA    ARG_POINT,ARGTABLE_NEXT     check for environment\n     IF (CLC,ARGTABLE_ARGSTRING_PTR,EQ,=8X'FF')\n       MVI   ERR_NO,5\n       SEGDO NOT_VALID\n     ELSEIF (CLC,ARGTABLE_ARGSTRING_LENGTH,NE,=F'8')\n       MVI   ERR_NO,6\n       SEGDO NOT_VALID\n     ENDIF\n     L     R14,ARGTABLE_ARGSTRING_PTR  address of argument\n     MVC   LOAD_ADDR_CHAR,0(R14)       copy it\n     XPACK LOAD_ADDR_CHAR,8,LOAD_ADDRESS   pack into 4 bytes\n   ENDIF\n*\n SEGE GET_FIRST_ARGUMENT\n*______________________________________________________________________\n*\n SEGS GET_CONNECT_ARGUMENTS\n*\n*  first argument should be the name for the environment handle\n*\n   LA    ARG_POINT,ARGTABLE_NEXT       check for environment name\n   IF (CLC,ARGTABLE_ARGSTRING_PTR,EQ,=8X'FF')\n     MVI   ERR_NO,51                   must have variable name\n     SEGDO NOT_VALID\n   ELSEIF (CLC,ARGTABLE_ARGSTRING_LENGTH,EQ,=F'0')\n     MVI   ERR_NO,52                   zero length argument\n     SEGDO NOT_VALID\n   ELSEIF (CLC,ARGTABLE_ARGSTRING_LENGTH,GT,=F'20')\n     MVI   ERR_NO,53                   arbitary max length\n     SEGDO NOT_VALID\n   ENDIF\n*\n   L     R14,ARGTABLE_ARGSTRING_PTR    address of argument\n   L     R15,ARGTABLE_ARGSTRING_LENGTH\n   ST    R15,ENV_H_LEN                 save length\n   MVC   ENV_H_NAME,SPACES             set to spaces\n   BCTR  R15,0                         minus 1 for execute\n   EX    R15,COPY_ENV_H\n   OC    ENV_H_NAME,SPACES             make uppercase\n   IF (CLC,=C'DEBUG',EQ,ENV_H_NAME)    check not DEBUG\n     MVI   ERR_NO,54                   cannot use debug for handle\n     SEGDO NOT_VALID\n   ENDIF\n*\n*  second argument is the optional code-page can be omitted.\n*\n   LA    ARG_POINT,ARGTABLE_NEXT       check for debug argument\n   IF (CLC,ARGTABLE_ARGSTRING_PTR,NE,=8X'FF')\n     IF (CLC,ARGTABLE_ARGSTRING_LENGTH,NE,=F'0')\n       MVC   CODEPAGE_PTR,ARGTABLE_ARGSTRING_PTR\n       MVC   CODEPAGE_LEN,ARGTABLE_ARGSTRING_LENGTH\n     ENDIF\n   ENDIF\n*\n*  third argument is the optional debug command\n*\n   LA    ARG_POINT,ARGTABLE_NEXT       check for debug argument\n   IF (CLC,ARGTABLE_ARGSTRING_PTR,NE,=8X'FF')\n     IF (CLC,ARGTABLE_ARGSTRING_LENGTH,NE,=F'0')\n       IF (CLC,ARGTABLE_ARGSTRING_LENGTH,NE,=F'5')\n         MVI   ERR_NO,7                  third argument <> 5 bytes\n         SEGDO NOT_VALID\n       ENDIF\n       L     R14,ARGTABLE_ARGSTRING_PTR  address of argument\n       MVC   WORK_32(5),0(R14)           copy argument\n       OC    WORK_32(5),SPACES           make upper case\n       IF (CLC,=C'DEBUG',EQ,WORK_32)     check for DEBUG\n         MVI   THE_COMMAND+7,C'D'        flag debug mode\n       ELSE\n         MVI   ERR_NO,7                  third argument <> 5 bytes\n         SEGDO NOT_VALID\n       ENDIF\n       MVC   WORK_32(5),=C'     '        clear to spaces\n     ENDIF\n   ENDIF\n*\n SEGE GET_CONNECT_ARGUMENTS\n*______________________________________________________________________\n*\n SEGS GET_COMPILE_ARGUMENTS\n*\n   MVI   REPEAT_SRCH,C'N'              indicate option not set\n   MVI   IGNORE_CASE,C'N'              indicate option not set\n   MVI   EXCLUDE_WHITE,C'N'            indicate option not set\n*\n*  first argument should be the REGEX\n*\n   LA    ARG_POINT,ARGTABLE_NEXT\n   IF (CLC,ARGTABLE_ARGSTRING_PTR,EQ,=8X'FF')\n     MVI   ERR_NO,8\n     SEGDO NOT_VALID\n   ELSEIF (CLC,ARGTABLE_ARGSTRING_LENGTH,EQ,=F'0')\n     MVI   ERR_NO,9\n     SEGDO NOT_VALID\n   ENDIF\n   L     R14,ARGTABLE_ARGSTRING_PTR    address of argument\n   L     R15,ARGTABLE_ARGSTRING_LENGTH length or argument\n   LA    R0,0(R14,R15)                 point after last byte\n   BCTR  R0,0                          back one byte\n   STM   R14,R0,REG_EX_ADDR            set address, length and end\n   LR    R1,R0                         copy address of last byte\n*\n*  second argument should be the name for the compile handle\n*\n   LA    ARG_POINT,ARGTABLE_NEXT       check for compile name\n   IF (CLC,ARGTABLE_ARGSTRING_PTR,EQ,=8X'FF')\n     MVI   ERR_NO,61                   must have variable name\n     SEGDO NOT_VALID\n   ELSEIF (CLC,ARGTABLE_ARGSTRING_LENGTH,EQ,=F'0')\n     MVI   ERR_NO,62                   zero length argument\n     SEGDO NOT_VALID\n   ELSEIF (CLC,ARGTABLE_ARGSTRING_LENGTH,GT,=F'20')\n     MVI   ERR_NO,63                   arbitary max length\n     SEGDO NOT_VALID\n   ENDIF\n*\n   L     R14,ARGTABLE_ARGSTRING_PTR    address of argument\n   L     R15,ARGTABLE_ARGSTRING_LENGTH\n   ST    R15,COMP_LEN                  save length\n   MVC   COMP_NAME,SPACES              set to spaces\n   BCTR  R15,0                         minus 1 for execute\n   EX    R15,COPY_COMP\n   OC    COMP_NAME,SPACES              make uppercase\n   IF (CLC,=C'DEBUG',EQ,COMP_NAME)     check not DEBUG\n     MVI   ERR_NO,64                   cannot use debug for compile\n     SEGDO NOT_VALID\n   ENDIF\n*\n*  third argument is the compile options\n*\n   LA    ARG_POINT,ARGTABLE_NEXT       check for fourth argument\n   IF (CLC,ARGTABLE_ARGSTRING_PTR,EQ,=8X'FF')\n*    NOP                               nothing there\n   ELSEIF (CLC,ARGTABLE_ARGSTRING_LENGTH,GT,=F'20')\n     MVI   ERR_NO,11                   arbitary max length\n     SEGDO NOT_VALID\n   ELSE\n     L     R14,ARGTABLE_ARGSTRING_PTR  address of argument\n     L     R15,ARGTABLE_ARGSTRING_LENGTH length or argument\n     LA    R1,0(R14,R15)               point after last byte\n     BCTR  R1,0                        back one byte\n     IF (CLI,0(R1),EQ,X'00')           NULL terminated\n       MVI   ERR_NO,12                 yes so error\n       SEGDO NOT_VALID\n     ENDIF\n*\n*  about to look for options currently  G/g  I/i  X/x\n*\n     DO FROM=(R15)                     R15 has length of argument\n       IF (CLI,0(R14),EQ,C'G')         check for repeat search\n         MVI   REPEAT_SRCH,C'Y'        flag as found\n       ELSEIF (CLI,0(R14),EQ,C'g')     check for repeat search\n         MVI   REPEAT_SRCH,C'Y'        flag as found\n       ELSEIF (CLI,0(R14),EQ,C'I')     check for ignore case\n         MVI   IGNORE_CASE,C'Y'        flag as found\n       ELSEIF (CLI,0(R14),EQ,C'i')     check for ignore case\n         MVI   IGNORE_CASE,C'Y'        flag as found\n       ELSEIF (CLI,0(R14),EQ,C'X')     check for exclude white space\n         MVI   EXCLUDE_WHITE,C'Y'      flag as found\n       ELSEIF (CLI,0(R14),EQ,C'x')     check for exclude white space\n         MVI   EXCLUDE_WHITE,C'Y'      flag as found\n       ELSE\n         MVI   ERR_NO,13               unknown option value\n         SEGDO NOT_VALID\n       ENDIF\n       LA    R14,1(,R14)               next byte in argument\n     ENDDO\n*\n*  fourth argument is the optional OPTIONS word in hex display\n*\n     LA    ARG_POINT,ARGTABLE_NEXT       check for option argument\n     IF (CLC,ARGTABLE_ARGSTRING_PTR,NE,=8X'FF')\n       IF (CLC,ARGTABLE_ARGSTRING_LENGTH,NE,=F'8')\n         MVI   ERR_NO,80\n         SEGDO NOT_VALID\n       ELSE\n         L     R3,ARGTABLE_ARGSTRING_PTR\n         XPACK 0(R3),8,OPTION_WORD\n       ENDIF\n     ENDIF\n   ENDIF\n*\n SEGE GET_COMPILE_ARGUMENTS\n*______________________________________________________________________\n*\n SEGS GET_MATCH_ARGUMENTS\n*\n*  first argument should be the compile information\n*\n   LA    ARG_POINT,ARGTABLE_NEXT\n   IF (CLC,ARGTABLE_ARGSTRING_PTR,EQ,=8X'FF')\n     MVI   ERR_NO,14\n     SEGDO NOT_VALID\n   ELSEIF (CLC,ARGTABLE_ARGSTRING_LENGTH,NE,=F'19')\n     MVI   ERR_NO,15\n     SEGDO NOT_VALID\n   ENDIF\n   L     R14,ARGTABLE_ARGSTRING_PTR    address of argument\n   MVC   COMPILE_CHAR,0(R14)           copy it\n   XPACK COMPILE_CHAR,16,COMPILE_DATA\n   MVC   COMPILE_DATA+8(3),COMPILE_CHAR+16\n*\n*  second argument should be the string to work on\n*\n   LA    ARG_POINT,ARGTABLE_NEXT       check for second argument\n   IF (CLC,ARGTABLE_ARGSTRING_PTR,EQ,=8X'FF')\n     MVI   ERR_NO,16\n     SEGDO NOT_VALID\n   ELSEIF (CLC,ARGTABLE_ARGSTRING_LENGTH,EQ,=F'0')\n     MVI   ERR_NO,17\n     SEGDO NOT_VALID\n   ENDIF\n   L     R14,ARGTABLE_ARGSTRING_PTR\n   L     R15,ARGTABLE_ARGSTRING_LENGTH\n   LA    R0,0(R14,R15)                 point after last byte\n   BCTR  R0,0                          back one byte\n   STM   R14,R0,THE_STR_ADDR           set address, length and end\n*\n*  third argument should be the STEM name to populate\n*\n   LA    ARG_POINT,ARGTABLE_NEXT       check for third argument\n   IF (CLC,ARGTABLE_ARGSTRING_PTR,EQ,=8X'FF')\n     MVI   ERR_NO,18                   must have stem name\n     SEGDO NOT_VALID\n   ELSEIF (CLC,ARGTABLE_ARGSTRING_LENGTH,EQ,=F'0')\n     MVI   ERR_NO,19                   zero length argument\n     SEGDO NOT_VALID\n   ELSEIF (CLC,ARGTABLE_ARGSTRING_LENGTH,GT,=F'20')\n     MVI   ERR_NO,20                   arbitary max length\n     SEGDO NOT_VALID\n   ENDIF\n*\n   MVC   STEM_NAME_ADR,ARGTABLE_ARGSTRING_PTR\n   MVC   STEM_NAME_LEN,ARGTABLE_ARGSTRING_LENGTH\n*\n*  fourth argument is the optional OPTIONS word in hex display\n*\n   LA    ARG_POINT,ARGTABLE_NEXT\n   IF (CLC,ARGTABLE_ARGSTRING_PTR,NE,=8X'FF')\n     IF (CLC,ARGTABLE_ARGSTRING_LENGTH,NE,=F'8')\n       MVI   ERR_NO,80\n       SEGDO NOT_VALID\n     ELSE\n       L     R3,ARGTABLE_ARGSTRING_PTR\n       MVC   MESS_TXT(20),=CL20'MATCH   INPUT'\n       MVC   MESS_TXT+20(8),0(R3)\n       XPACK 0(R3),8,OPTION_WORD\n     ENDIF\n   ENDIF\n*\n SEGE GET_MATCH_ARGUMENTS\n*______________________________________________________________________\n*\n SEGS GET_SUBSTITUTE_ARGUMENTS\n*\n*  first argument should be the compile information\n*\n   LA    ARG_POINT,ARGTABLE_NEXT\n   IF (CLC,ARGTABLE_ARGSTRING_PTR,EQ,=8X'FF')\n     MVI   ERR_NO,71\n     SEGDO NOT_VALID\n   ELSEIF (CLC,ARGTABLE_ARGSTRING_LENGTH,NE,=F'19')\n     MVI   ERR_NO,72\n     SEGDO NOT_VALID\n   ENDIF\n   L     R14,ARGTABLE_ARGSTRING_PTR    address of argument\n   MVC   COMPILE_CHAR,0(R14)           copy it\n   XPACK COMPILE_CHAR,16,COMPILE_DATA\n   MVC   COMPILE_DATA+8(3),COMPILE_CHAR+16\n*\n*  second argument should be the string to work on\n*\n   LA    ARG_POINT,ARGTABLE_NEXT       check for second argument\n   IF (CLC,ARGTABLE_ARGSTRING_PTR,EQ,=8X'FF')\n     MVI   ERR_NO,73\n     SEGDO NOT_VALID\n   ELSEIF (CLC,ARGTABLE_ARGSTRING_LENGTH,EQ,=F'0')\n     MVI   ERR_NO,74\n     SEGDO NOT_VALID\n   ENDIF\n   L     R14,ARGTABLE_ARGSTRING_PTR\n   L     R15,ARGTABLE_ARGSTRING_LENGTH\n   LA    R0,0(R14,R15)                 point after last byte\n   BCTR  R0,0                          back one byte\n   STM   R14,R0,THE_STR_ADDR           set address, length and end\n*\n*  third argument should be the variable name to populate\n*\n   LA    ARG_POINT,ARGTABLE_NEXT       check for third argument\n   IF (CLC,ARGTABLE_ARGSTRING_PTR,EQ,=8X'FF')\n     MVI   ERR_NO,75                   must have variable name\n     SEGDO NOT_VALID\n   ELSEIF (CLC,ARGTABLE_ARGSTRING_LENGTH,EQ,=F'0')\n     MVI   ERR_NO,76                   zero length argument\n     SEGDO NOT_VALID\n   ELSEIF (CLC,ARGTABLE_ARGSTRING_LENGTH,GT,=F'20')\n     MVI   ERR_NO,77                   arbitary max length\n     SEGDO NOT_VALID\n   ENDIF\n   MVC   STEM_NAME_ADR,ARGTABLE_ARGSTRING_PTR\n   MVC   STEM_NAME_LEN,ARGTABLE_ARGSTRING_LENGTH\n*\n*  fourth argument should be the substitute string\n*\n   LA    ARG_POINT,ARGTABLE_NEXT       check for fourth argument\n   IF (CLC,ARGTABLE_ARGSTRING_PTR,EQ,=8X'FF')\n     MVI   ERR_NO,78                   must have substitute string\n     SEGDO NOT_VALID\n   ELSEIF (CLC,ARGTABLE_ARGSTRING_LENGTH,EQ,=F'0')\n     MVI   ERR_NO,79                   zero length argument\n     SEGDO NOT_VALID\n   ENDIF\n   L     R14,ARGTABLE_ARGSTRING_PTR\n   L     R15,ARGTABLE_ARGSTRING_LENGTH\n   LA    R0,0(R14,R15)                 point after last byte\n   BCTR  R0,0                          back one byte\n   STM   R14,R0,SUBS_STR_ADDR          set address, length and end\n*\n*  fifth argument is the optional OPTIONS word in hex display\n*\n   LA    ARG_POINT,ARGTABLE_NEXT\n   IF (CLC,ARGTABLE_ARGSTRING_PTR,NE,=8X'FF')\n     IF (CLC,ARGTABLE_ARGSTRING_LENGTH,NE,=F'8')\n       MVI   ERR_NO,80\n       SEGDO NOT_VALID\n     ELSE\n       L     R3,ARGTABLE_ARGSTRING_PTR\n       MVC   MESS_TXT(20),=CL20'SUBST   INPUT'\n       MVC   MESS_TXT+20(8),0(R3)\n       XPACK 0(R3),8,OPTION_WORD\n     ENDIF\n   ENDIF\n*\n SEGE GET_SUBSTITUTE_ARGUMENTS\n*______________________________________________________________________\n*\n SEGS GET_RELEASE_ARGUMENTS\n*\n*  first argument should be the compile information\n*\n   LA    ARG_POINT,ARGTABLE_NEXT\n   IF (CLC,ARGTABLE_ARGSTRING_PTR,EQ,=8X'FF')\n     MVI   ERR_NO,21\n     SEGDO NOT_VALID\n   ELSEIF (CLC,ARGTABLE_ARGSTRING_LENGTH,NE,=F'19')\n     MVI   ERR_NO,22\n     SEGDO NOT_VALID\n   ENDIF\n   L     R14,ARGTABLE_ARGSTRING_PTR    address of argument\n   MVC   COMPILE_CHAR,0(R14)           copy it\n   XPACK COMPILE_CHAR,16,COMPILE_DATA\n*\n SEGE GET_RELEASE_ARGUMENTS\n*______________________________________________________________________\n*\n SEGS CONNECT_PROCESS\n*\n   SEGDO CHECK_FOR_PCRELIB\n   IF (CLI,PCRELIB_THERE,EQ,C'Y')      DDNAME is available\n     OPEN  (PCRELIB,INPUT)             open the load library\n     IF (LTR,R15,R15,Z)\n       LOAD  EP=RXPCRE2A,DCB=PCRELIB,ERRET=*+4\n       IF (LTR,R15,R15,NZ)\n         MVC   MESS_TXT(L'C_P_MS1),C_P_MS1\n         SEGDO CALL_IRXSAY             output error message\n         CLOSE PCRELIB                 close the load library\n         PRGQUIT RC=8                  quit RC=0\n       ENDIF\n       ST    R0,LOAD_ADDRESS           save address of program\n       CLOSE PCRELIB                   close the load library\n     ELSE\n       MVC   MESS_TXT(L'C_P_MS2),C_P_MS2\n       SEGDO CALL_IRXSAY               output error message\n       PRGQUIT RC=8                    quit RC=8\n     ENDIF\n   ELSE                                load library was not there\n     LOAD  EP=RXPCRE2A                 so just try normal load\n     IF (LTR,R15,R15,NZ)\n       MVC   MESS_TXT(L'C_P_MS3),C_P_MS3\n       SEGDO CALL_IRXSAY               output error message\n       PRGQUIT RC=8                    quit RC=8\n     ENDIF\n     ST    R0,LOAD_ADDRESS             save address of program\n   ENDIF\n   XUNPK LOAD_ADDRESS,4,LOAD_ADDR_CHAR   convert address to character\n*\n   LA    R1,THE_COMMAND            point to the command\n   ST    R1,MY_P_1                 save in parm-list\n   LA    R1,CODEPAGE_PTR           get code page value (if any)\n   ST    R1,MY_P_2                 save in parm-list\n   LA    R1,PCREDUMP               address of DCB\n   ST    R1,MY_P_20                save it\n   L     R15,LOAD_ADDRESS          get program address\n   LA    R1,MY_PARM                point to parm-list\n   BASR  R14,R15                   call RXPCRE2A\n   IF (LTR,R15,R15,NZ)\n     SEGDO DELETE_RXPCRE2A\n     PRGQUIT RC=8\n   ENDIF\n*\n   SEGDO SET_ENV_HANDLE\n*\n SEGE CONNECT_PROCESS\n*______________________________________________________________________\n*\n SEGS COMPILE_PROCESS\n*\n   LA    R1,THE_COMMAND            point to the command\n   ST    R1,MY_P_1\n   LA    R1,REG_EX_ADDR            point to the regex\n   ST    R1,MY_P_2\n   LA    R1,COMPILE_DATA           point to output compile address\n   ST    R1,MY_P_3\n   LA    R1,OPTION_WORD            get options value (if any)\n   ST    R1,MY_P_4                 save in parm-list\n   LA    R1,PCREDUMP               address of DCB\n   ST    R1,MY_P_20                save it\n   L     R15,LOAD_ADDRESS          get program address\n   LA    R1,MY_PARM\n   BASR  R14,R15                   call RXPCRE2A\n   IF (LTR,R15,R15,NZ)\n     SEGDO DELETE_RXPCRE2A\n     PRGQUIT RC=8\n   ENDIF\n*\n   XUNPK COMPILE_DATA,8,COMPILE_CHAR           unpack compile handle\n   MVC   COMPILE_CHAR+16(3),COMPILE_DATA+8     put indicators on end\n   SEGDO SET_COMPILE_HANDLE\n*\n SEGE COMPILE_PROCESS\n*______________________________________________________________________\n*\n SEGS MATCH_PROCESS\n*\n   LA    R1,THE_COMMAND            point to the command\n   ST    R1,MY_P_1\n   LA    R1,COMPILE_DATA           point to the compile handle\n   ST    R1,MY_P_2\n   MVC   MY_P_3,THE_STR_ADDR       string address\n   MVC   MY_P_4,THE_STR_LENGTH     string length\n   MVC   MY_P_5,THE_STR_END        end of string address\n   MVC   MY_P_6,STEM_NAME_ADR      stem name address\n   MVC   MY_P_7,STEM_NAME_LEN      stem name length\n   LA    R1,OPTION_WORD            get options value (if any)\n   ST    R1,MY_P_8                 save in parm-list\n   LA    R1,PCREDUMP               address of DCB\n   ST    R1,MY_P_20                save it\n   L     R15,LOAD_ADDRESS          get program address\n   LA    R1,MY_PARM\n   BASR  R14,R15                   call RXPCRE2A\n   ST    R15,R_C                   save return code 1 or 0\n   IF (CHI,R15,GT,1)\n     SEGDO DELETE_RXPCRE2A\n     PRGQUIT RC=8\n   ENDIF\n*\n*  If RXPCRE2A set an error message in EVALBLOCK then it will\n*  have priority over the contents of R_C. If not PRGEDEF will\n*  put the return code into EVALBLOCK.\n*\n SEGE MATCH_PROCESS\n*______________________________________________________________________\n*\n SEGS SUBSTITUTE_PROCESS\n*\n   LA    R1,THE_COMMAND            point to the command\n   ST    R1,MY_P_1\n   LA    R1,COMPILE_DATA           point to the compile handle\n   ST    R1,MY_P_2\n   MVC   MY_P_3,THE_STR_ADDR       string address\n   MVC   MY_P_4,THE_STR_LENGTH     string length\n   MVC   MY_P_5,THE_STR_END        end of string address\n   MVC   MY_P_6,STEM_NAME_ADR      stem name address\n   MVC   MY_P_7,STEM_NAME_LEN      stem name length\n   MVC   MY_P_8,SUBS_STR_ADDR      substitute string address\n   MVC   MY_P_9,SUBS_STR_LENGTH    substitute string length\n   MVC   MY_P_10,THE_STR_END       substitute end of string address\n   LA    R1,OPTION_WORD            get options value (if any)\n   ST    R1,MY_P_11                save in parm-list\n   LA    R1,PCREDUMP               address of DCB\n   ST    R1,MY_P_20                save it\n   L     R15,LOAD_ADDRESS          get program address\n   LA    R1,MY_PARM\n   BASR  R14,R15                   call RXPCRE2A\n   ST    R15,R_C                   save return code 1 or 0\n   IF (CHI,R15,GT,1)\n     SEGDO DELETE_RXPCRE2A\n     PRGQUIT RC=8\n   ENDIF\n*\n*  If RXPCRE2A set an error message in EVALBLOCK then it will\n*  have priority over the contents of R_C. If not PRGEDEF will\n*  put the return code into EVALBLOCK.\n*\n SEGE SUBSTITUTE_PROCESS\n*______________________________________________________________________\n*\n SEGS RELEASE_PROCESS\n*\n   LA    R1,THE_COMMAND            point to the command\n   ST    R1,MY_P_1\n   LA    R1,COMPILE_DATA           point to the compile handle\n   ST    R1,MY_P_2\n   LA    R1,PCREDUMP               address of DCB\n   ST    R1,MY_P_20                save it\n   L     R15,LOAD_ADDRESS          get program address\n   LA    R1,MY_PARM\n   BASR  R14,R15                   call RXPCRE2A\n   IF (LTR,R15,R15,NZ)\n     SEGDO DELETE_RXPCRE2A\n     PRGQUIT RC=8\n   ENDIF\n*\n SEGE RELEASE_PROCESS\n*______________________________________________________________________\n*\n SEGS DISCONNECT_PROCESS\n*\n   LA    R1,=CL20'DISCONNECT'      point to the command\n   ST    R1,MY_P_1\n   LA    R1,PCREDUMP               address of DCB\n   ST    R1,MY_P_20                save it\n   L     R15,LOAD_ADDRESS          get program address\n   LA    R1,MY_PARM\n   BASR  R14,R15                   call RXPCRE2A\n   IF (LTR,R15,R15,NZ)\n     SEGDO DELETE_RXPCRE2A\n     SETRC RC=8\n   ENDIF\n*\n SEGE DISCONNECT_PROCESS\n*______________________________________________________________________\n*\n SEGS NOT_VALID\n*\n*  an error occured so set error message as output from REXX function\n*\n   IF (CLI,ERR_NO,EQ,1)\n     MVC   MESS_TXT(L'MESS_1),MESS_1\n   ELSEIF (CLI,ERR_NO,EQ,2)\n     MVC   MESS_TXT(L'MESS_2),MESS_2\n   ELSEIF (CLI,ERR_NO,EQ,3)\n     MVC   MESS_TXT(L'MESS_3),MESS_3\n   ELSEIF (CLI,ERR_NO,EQ,4)\n     MVC   MESS_TXT(L'MESS_4),MESS_4\n   ELSEIF (CLI,ERR_NO,EQ,5)\n     MVC   MESS_TXT(L'MESS_5),MESS_5\n   ELSEIF (CLI,ERR_NO,EQ,6)\n     MVC   MESS_TXT(L'MESS_6),MESS_6\n   ELSEIF (CLI,ERR_NO,EQ,7)\n     MVC   MESS_TXT(L'MESS_7),MESS_7\n   ELSEIF (CLI,ERR_NO,EQ,8)\n     MVC   MESS_TXT(L'MESS_8),MESS_8\n   ELSEIF (CLI,ERR_NO,EQ,9)\n     MVC   MESS_TXT(L'MESS_9),MESS_9\n   ELSEIF (CLI,ERR_NO,EQ,10)\n     MVC   MESS_TXT(L'MESS_10),MESS_10\n   ELSEIF (CLI,ERR_NO,EQ,11)\n     MVC   MESS_TXT(L'MESS_11),MESS_11\n   ELSEIF (CLI,ERR_NO,EQ,12)\n     MVC   MESS_TXT(L'MESS_12),MESS_12\n   ELSEIF (CLI,ERR_NO,EQ,13)\n     MVC   MESS_TXT(L'MESS_13),MESS_13\n   ELSEIF (CLI,ERR_NO,EQ,14)\n     MVC   MESS_TXT(L'MESS_14),MESS_14\n   ELSEIF (CLI,ERR_NO,EQ,15)\n     MVC   MESS_TXT(L'MESS_15),MESS_15\n   ELSEIF (CLI,ERR_NO,EQ,16)\n     MVC   MESS_TXT(L'MESS_16),MESS_16\n   ELSEIF (CLI,ERR_NO,EQ,17)\n     MVC   MESS_TXT(L'MESS_17),MESS_17\n   ELSEIF (CLI,ERR_NO,EQ,18)\n     MVC   MESS_TXT(L'MESS_18),MESS_18\n   ELSEIF (CLI,ERR_NO,EQ,19)\n     MVC   MESS_TXT(L'MESS_19),MESS_19\n   ELSEIF (CLI,ERR_NO,EQ,20)\n     MVC   MESS_TXT(L'MESS_20),MESS_20\n   ELSEIF (CLI,ERR_NO,EQ,21)\n     MVC   MESS_TXT(L'MESS_21),MESS_21\n   ELSEIF (CLI,ERR_NO,EQ,22)\n     MVC   MESS_TXT(L'MESS_22),MESS_22\n   ELSEIF (CLI,ERR_NO,EQ,51)\n     MVC   MESS_TXT(L'MESS_51),MESS_51\n   ELSEIF (CLI,ERR_NO,EQ,52)\n     MVC   MESS_TXT(L'MESS_52),MESS_52\n   ELSEIF (CLI,ERR_NO,EQ,53)\n     MVC   MESS_TXT(L'MESS_53),MESS_53\n   ELSEIF (CLI,ERR_NO,EQ,54)\n     MVC   MESS_TXT(L'MESS_54),MESS_54\n   ELSEIF (CLI,ERR_NO,EQ,61)\n     MVC   MESS_TXT(L'MESS_61),MESS_61\n   ELSEIF (CLI,ERR_NO,EQ,62)\n     MVC   MESS_TXT(L'MESS_62),MESS_62\n   ELSEIF (CLI,ERR_NO,EQ,63)\n     MVC   MESS_TXT(L'MESS_63),MESS_63\n   ELSEIF (CLI,ERR_NO,EQ,64)\n     MVC   MESS_TXT(L'MESS_64),MESS_64\n   ELSEIF (CLI,ERR_NO,EQ,71)\n     MVC   MESS_TXT(L'MESS_71),MESS_71\n   ELSEIF (CLI,ERR_NO,EQ,72)\n     MVC   MESS_TXT(L'MESS_72),MESS_72\n   ELSEIF (CLI,ERR_NO,EQ,73)\n     MVC   MESS_TXT(L'MESS_73),MESS_73\n   ELSEIF (CLI,ERR_NO,EQ,74)\n     MVC   MESS_TXT(L'MESS_74),MESS_74\n   ELSEIF (CLI,ERR_NO,EQ,75)\n     MVC   MESS_TXT(L'MESS_75),MESS_75\n   ELSEIF (CLI,ERR_NO,EQ,76)\n     MVC   MESS_TXT(L'MESS_76),MESS_76\n   ELSEIF (CLI,ERR_NO,EQ,77)\n     MVC   MESS_TXT(L'MESS_77),MESS_77\n   ELSEIF (CLI,ERR_NO,EQ,78)\n     MVC   MESS_TXT(L'MESS_78),MESS_78\n   ELSEIF (CLI,ERR_NO,EQ,79)\n     MVC   MESS_TXT(L'MESS_79),MESS_79\n   ELSEIF (CLI,ERR_NO,EQ,80)\n     MVC   MESS_TXT(L'MESS_80),MESS_80\n*\n   ELSE    this should never happen\n     MVC   MESS_TXT(L'UN_KNOWN),UN_KNOWN\n     XUNPK ERR_NO,1,MESS_TXT+L'UN_KNOWN\n   ENDIF\n   SEGDO CALL_IRXSAY\n   IF (CLI,FREE_C_NEEDED,EQ,C'Y')\n     SEGDO DISCONNECT_PROCESS\n   ENDIF\n   SEGDO DELETE_RXPCRE2A\n   PRGQUIT RC=8                        quit with RC=8\n*\n SEGE NOT_VALID\n*______________________________________________________________________\n*\n SEGS CHECK_FOR_PCRELIB\n*\n   L     R2,ATIOT                      task I/O table address there ?\n   IF (LTR,R2,R2,Z)                    no\n     EXTRACT ATIOT,'S',FIELDS=(TIOT)   get it\n     L     R2,ATIOT\n   ENDIF\n   USING TIOT1,R2\n*\n   LA    R4,TIOENTRY\n   DROP  R2\n   USING TIOENTRYD,R4\n   XR    R2,R2                         length register\n   DO INF\n     ICM   R2,1,TIOELNGH               get entry length\n   DOEXIT (LTR,R2,R2,Z)                zero length, DDNAME not found\n   DOEXIT (CLC,TIOEDDNM,EQ,=CL8'PCRELIB')\n     AR   R4,R2                        next entry\n   ENDDO\n*\n   IF (LTR,R2,R2,Z)                    could not find DDNAME\n     MVI   PCRELIB_THERE,C'N'\n   ELSE\n     MVI   PCRELIB_THERE,C'Y'\n   ENDIF\n*\n SEGE CHECK_FOR_PCRELIB\n*______________________________________________________________________\n*\n SEGS SET_ENV_HANDLE\n*\n   XC    IX_PARM(4*4),IX_PARM\n   LA    R1,=CL8'IRXEXCOM'\n   ST    R1,IX_PARM\n   LA    R6,PARM_AREA\n   MVC   SHVNEXT,=F'0'\n   MVC   SHVUSER,=F'0'\n   MVC   SHVBUFL,=F'0'\n   MVI   SHVCODE,SHVSTORE              set command to store variable\n*\n   LA    R1,ENV_H_NAME                 point to env handle name\n   ST    R1,SHVNAMA                    store in function call\n   MVC   SHVNAML,ENV_H_LEN             copy length of the name\n   LA    R1,LOAD_ADDR_CHAR             point to environment handle\n   LA    R2,8                          get it's length\n   ST    R1,SHVVALA                    store address of value\n   ST    R2,SHVVALL                    store length of value\n*\n   SEGDO CALL_IRXEXCOM\n*\n   IF (LTR,R15,R15,NZ)\n     MVC   MESS_TXT(L'E_S_ENV),E_S_ENV\n     XUNPK (R15),4,MESS_TXT+L'E_S_ENV\n     SEGDO CALL_IRXSAY\n     PRGQUIT RC=8\n   ENDIF\n*\n SEGE SET_ENV_HANDLE\n*______________________________________________________________________\n*\n SEGS SET_COMPILE_HANDLE\n*\n   XC    IX_PARM(4*4),IX_PARM\n   LA    R1,=CL8'IRXEXCOM'\n   ST    R1,IX_PARM\n   LA    R6,PARM_AREA\n   MVC   SHVNEXT,=F'0'\n   MVC   SHVUSER,=F'0'\n   MVC   SHVBUFL,=F'0'\n   MVI   SHVCODE,SHVSTORE              set command to store variable\n*\n   LA    R1,COMP_NAME                  point to compile handle name\n   ST    R1,SHVNAMA                    store in function call\n   MVC   SHVNAML,COMP_LEN              copy length of the name\n   LA    R1,COMPILE_CHAR               point to compile handle\n   LA    R2,19                         get it's length\n   ST    R1,SHVVALA                    store address of value\n   ST    R2,SHVVALL                    store length of value\n*\n   SEGDO CALL_IRXEXCOM\n*\n   IF (LTR,R15,R15,NZ)\n     MVC   MESS_TXT(L'E_S_CMP),E_S_CMP\n     XUNPK (R15),4,MESS_TXT+L'E_S_CMP\n     SEGDO CALL_IRXSAY\n     PRGQUIT RC=8\n   ENDIF\n*\n SEGE SET_COMPILE_HANDLE\n*______________________________________________________________________\n*\n SEGS CALL_IRXEXCOM\n*\n   LA    R1,PARM_AREA\n   ST    R1,IX_PARM+12\n   OI    IX_PARM+12,X'80'\n   L     R0,#SAV_REX+12                rexx environment block addr\n   LA    R1,IX_PARM\n   USING IRXEXTE,15\n   L     15,ENVBLOCK_IRXEXTE\n   L     15,IRXEXCOM\n   DROP  15\n   BASR  14,15\n*\n SEGE CALL_IRXEXCOM\n*______________________________________________________________________\n*\n SEGS CALL_IRXSAY\n*\n   LA    R1,=CL8'WRITE'\n   ST    R1,MY_P_1\n   LA    R1,MESS_TXT\n   ST    R1,MY_P_8\n   LA    R1,MY_P_8\n   ST    R1,MY_P_2\n   LA    R1,L'MESS_TXT\n   ST    R1,MY_P_9\n   LA    R1,MY_P_9\n   ST    R1,MY_P_3\n   OI    MY_P_3,X'80'\n   L     R0,#SAV_REX+12                rexx environment block addr\n   LA    R1,MY_PARM\n   USING IRXEXTE,15\n   L     15,ENVBLOCK_IRXEXTE\n   L     15,IRXSAY\n   DROP  15\n   BASR  14,15\n   IF (LTR,R15,R15,NZ)\n     ST    R15,R_C\n     SEGDO WRITE_LOG                   write original message\n     MVC   MESS_TXT(L'SAY_ERR),SAY_ERR\n     XUNPK R_C,4,MESS_TXT+19\n     SEGDO WRITE_LOG                   then this error message\n   ENDIF\n   MVI   MESS_TXT,C' '\n   MVC   MESS_TXT+1(L'MESS_TXT-1),MESS_TXT\n*\n SEGE CALL_IRXSAY\n*______________________________________________________________________\n*\n SEGS DELETE_RXPCRE2A\n*\n   DELETE EP=RXPCRE2A\n*\n SEGE DELETE_RXPCRE2A\n*______________________________________________________________________\n*\n SEGS WRITE_LOG\n*\n*  this does WTO from MESS_TXT and then clears it to spaces\n*\n   WTOX\n*\n SEGE WRITE_LOG\n*______________________________________________________________________\n*\n               PRGSTAT\n*\nSPACES         DC    CL20' '\n*\nATIOT          DS    F\nPCRELIB_THERE  DS    C\n*\nPCRELIB  DCB   DDNAME=PCRELIB,DSORG=PO,MACRF=R\nPCREDUMP DCB   DSORG=PS,DDNAME=PCREDUMP,LRECL=80,MACRF=(PM),RECFM=FB\n*\nCOPY_COMMAND   MVC   THE_COMMAND(0),0(R14)\nCOPY_ENV_H     MVC   ENV_H_NAME(0),0(R14)\nCOPY_COMP      MVC   COMP_NAME(0),0(R14)\n*\nE_S_ENV  DC C'RXPCRE2-001 - Error in set environment handle RC='\nE_S_CMP  DC C'RXPCRE2-002 - Error in set compile handle RC='\n*\nC_P_MS1  DC C'RXPCRE2-003 - Could not find RXPCRE2A in PRCELIB'\nC_P_MS2  DC C'RXPCRE2-004 - Could not open PCRELIB'\nC_P_MS3  DC C'RXPCRE2-005 - Could not find RXPCRE2A'\nSAY_ERR  DC C'RXPCRE2-006 - Return code on SAY='\n*\nMESS_1   DC C'RXPCRE2-007 - invalid command specified'\nMESS_2   DC C'RXPCRE2-008 - command not specified'\nMESS_3   DC C'RXPCRE2-009 - command length was 0'\nMESS_4   DC C'RXPCRE2-010 - command greater than 20 bytes'\nMESS_5   DC C'RXPCRE2-011 - environment not specified as argument 2'\nMESS_6   DC C'RXPCRE2-012 - environment length was not 8 bytes'\nMESS_7   DC C'RXPCRE2-013 connect - debug command not ''debug'''\nMESS_8   DC C'RXPCRE2-014 compile - regex not specified'\nMESS_9   DC C'RXPCRE2-015 compile - regex length was 0'\nMESS_10  DC C'RXPCRE2-016 compile - regex not null terminated'\nMESS_11  DC C'RXPCRE2-017 compile - options > 20 bytes'\nMESS_12  DC C'RXPCRE2-018 compile - options were null terminated'\nMESS_13  DC C'RXPCRE2-019 compile - options not recognised'\nMESS_14  DC C'RXPCRE2-020 execute - argument compile result not passed'\nMESS_15  DC C'RXPCRE2-021 execute - argument compile result invalid'\nMESS_16  DC C'RXPCRE2-022 execute - string to test is missing'\nMESS_17  DC C'RXPCRE2-023 execute - string to test has zero length'\nMESS_18  DC C'RXPCRE2-024 execute - stem name not available'\nMESS_19  DC C'RXPCRE2-025 execute - stem name has 0 length'\nMESS_20  DC C'RXPCRE2-026 execute - stem name > 20 bytes'\nMESS_21  DC C'RXPCRE2-027 release - compile result not passed'\nMESS_22  DC C'RXPCRE2-028 release - compile result invalid length'\nMESS_51  DC C'RXPCRE2-029 connect - env handle not specified'\nMESS_52  DC C'RXPCRE2-030 connect - env handle length was 0'\nMESS_53  DC C'RXPCRE2-031 connect - env handle > 20 bytes'\nMESS_54  DC C'RXPCRE2-032 connect - env handle was DEBUG'\nMESS_61  DC C'RXPCRE2-033 connect - comp handle not specified'\nMESS_62  DC C'RXPCRE2-034 connect - comp handle length was 0'\nMESS_63  DC C'RXPCRE2-035 connect - comp handle > 20 bytes'\nMESS_64  DC C'RXPCRE2-036 connect - comp handle was DEBUG'\nMESS_71  DC C'RXPCRE2-037 subst - argument compile result not passed'\nMESS_72  DC C'RXPCRE2-038 subst - argument compile result invalid'\nMESS_73  DC C'RXPCRE2-039 subst - string to test is missing'\nMESS_74  DC C'RXPCRE2-040 subst - string to test has zero length'\nMESS_75  DC C'RXPCRE2-041 subst - variable name not available'\nMESS_76  DC C'RXPCRE2-042 subst - variable name has 0 length'\nMESS_77  DC C'RXPCRE2-043 subst - variable name > 20 bytes'\nMESS_78  DC C'RXPCRE2-044 subst - subs string not available'\nMESS_79  DC C'RXPCRE2-045 subst - subs string has 0 length'\nMESS_80  DC C'RXPCRE2-080 option input is not 8 bytes long'\nUN_KNOWN DC C'RXPCRE2-nnn - unknown error, RC='\n*\n               LTORG\n*\n*              copy of MVT IEFTIOT amended to make DSECTs explicit\n               JRGTIOT\n*\n               PRGESTAT\n               PRGEND\n               END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "RXPCRE2A": {"ttr": 83, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01c\\x00\\x13\\x01\\x17(?\\x01 \\x03\\x1f\\x07U\\x06R\\x03\\xd1\\x00\\x00\\xe2\\xc4\\xd1\\xd9\\xc7@@@@@'", "ispf": {"version": "01.99", "flags": 0, "createdate": "2017-10-10T00:00:00", "modifydate": "2020-01-31T07:55:13", "lines": 1618, "newlines": 977, "modlines": 0, "user": "SDJRG"}, "text": " TITLE 'RXPCRE2A - C HANDLER FOR PERL COMPATIBLE REGEX'\n PRINT GEN\nRXPCRE2A PRGDEF FSEG=MAIN_BIT,INREX=Y                *,RMODE=24\n*______________________________________________________________________\n*\n* This is a sub-routine used by RXPCRE2 to execute the REGEX C\n* functions. It should NEVER be called directly.\n*\n* Version 0.2\n* Contributed by:   John Gateley  November 2017.\n* 2019-dec      :   add substitute function\n*               :   move PCREDUMP DCB to RXPCRE2 to allow RMODE=31\n*                   for this load module\n*               :   improve housekeeping in case release calls have\n*                   not been done\n*\n* Copyright (c) 2017, John Gateley.\n* All rights reserved.\n*______________________________________________________________________\n*\n* Redistribution and use in source and binary forms, with or\n* without modification, are permitted provided that the following\n* conditions are met:\n*\n*  1. Redistributions of source code must retain the above\n*  copyright notice, this list of conditions and the following\n*  disclaimer.\n*\n*  2. Redistributions in binary form must reproduce the above\n*  copyright notice, this list of conditions and the following\n*  disclaimer in the documentation and/or other materials\n*  provided with the distribution.\n*\n*  3. Neither the name of the University of Cambridge nor the\n*  names of its contributors may be used to endorse or promote\n*  products derived from this software without specific prior\n*  written permission.\n*\n* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND\n* CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES,\n* INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n* MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n* DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR\n* CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n* SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n* NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n* HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n* CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR\n* OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,\n* EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*______________________________________________________________________\n*\n* An article \"Calling C functions from Assembler - revisited\"\n* by A Rudd printed in issue 208 of Xephon magazine of January 2004\n* was very useful when I wrote this program.\n* http://www.cbttape.org/xephon/xephonm/mvs0401.pdf\n*\n* As this was the only example I could find of a rexx function\n* written in assembler that called C, I used the same method.\n* CEEPIPI may also work, I do not know.\n*______________________________________________________________________\n*\n*\n*    STEM variables output\n*         stem.0             count of stem variables\n*         stem_STRING.?      matched substrings\n*         stem_POS.?         position and length of matches e.g. 3,4\n*         stem_NAME.?        named substrings ' ' if none\n*______________________________________________________________________\n*\n*  REENTRANT STORAGE\n*\n*                    Define some maximums\nMAX_NUM_COMPILES     EQU   12          max simultaneous compiles\nMAX_STEM_LEN         EQU   2048        max length of a stem variable\n*\nTHE_STR_ADDR         DS    F           details of supplied string\nTHE_STR_LENGTH       DS    F\nTHE_STR_END          DS    F\nSUBS_STR_ADDR        DS    F           details of substitute string\nSUBS_STR_LEN         DS    F\nSUBS_STR_END         DS    F\nSUBST_OUT_PTR        DS    F           pointer to substitute output\nSUBST_OUT_LEN        DS    F           length of substitute output\nREG_EX_ADDR          DS    F           details of supplied REGEX\nREG_EX_LEN           DS    F\nREG_EX_END           DS    F\nCONV_REGEX_ADDR      DS    F\nCONV_REGEX_LEN       DS    F\nCONV_SUBJECT_PTR     DS    F\nCONV_SUBJECT_LEN     DS    F\nCONV_SUBST_PTR       DS    F\nCONV_SUBST_LEN       DS    F\nCONV_BACK_PTR        DS    F\nCONV_BACK_LEN        DS    F\n*\nOPTION_WORD          DS    F\n*\nPCREWS_ERRORNUMBER   DS    F           PCRE working storage\nPCREWS_ERROROFFSET   DS    F\nPCREWS_RE_PTR        DS    F\nPCREWS_MATCH_DATA    DS    F\nPCREWS_NULL_PTR      DS    F\nPCREWS_PATTERN_PTR   DS    F\nPCREWS_SUBJECT_PTR   DS    F\nPCREWS_SUBJECT_LEN   DS    F\nPCREWS_RC            DS    F\nPCREWS_OVECTOR       DS    F\nPCREWS_NAMECOUNT     DS    F\nPCREWS_NAME_TABLE    DS    F\nPCREWS_NAME_ENTSZ    DS    F\nPCREWS_OPTION_BITS   DS    F\nPCRE2_INFO_NAMECOUNT EQU   17\nPCRE2_INFO_NAM_ENTSZ EQU   18\nPCRE2_INFO_NAMETABLE EQU   19\nPCRE2_SUBSTITUTE_GLOBAL    EQU   256\n*\nHIGHEST_MATCH        DS    F           address of highest match\nCURRENT_ADDRESS      DS    F\nCURRENT_COUNT        DS    F\nNUMBER_OF_PARMS      DS    H\nDUMP_CALL            DS    C\nPROGRAM_CALL         DS    CL8\n*\nIX_PARM              DS    4F\nPARM_AREA            DS    (SHVBLEN)XL1\n*\nSAVE_R4_R5           DS    2F          temporary reg save\n*\nFUNC_NAME            DS    A           C function to be called\n*\nFIRST_SET_MATCH      DS    PL4         stem count at start of search\n*\nERR_NO               DS    CL1         some indicators\nREPEAT_SRCH          DS    CL1\nIGNORE_CASE          DS    CL1\nEXCLUDE_WHITE        DS    CL1\nWORK_32              DS    CL32        32 bytes used when debugging\nCALL_STEM_MESS       DS    CL26        error message for PROCSTEM call\nERR_BUFFER           DS    CL256       area for error message\n*\nSTEM_POS             DS    F           position in string\nSTEM_LEN             DS    F           length of substring\nSTEM_TEXT            DS    CL(MAX_STEM_LEN)   storage for stem value\n*\nMAP_HANDLES    DSECT\nTHIS_COMPILE   DS    A\nTHIS_MATCH     DS    A\n*\n        PRGEDEF\n*______________________________________________________________________\n*\n SEGS MAIN_BIT\n*\n   LR    R8,R1                         copy input parameter address\n*\n   IF (CLI,DEBUG_MODE,EQ,C'Y')         can be set on first call\n     L     R9,76(,R8)                  copy DCB address in RXPCRE2\n     OPEN  ((R9),OUTPUT),MODE=31       open output file\n     IF (LTR,15,R15,NZ)                error on open\n       MVI   ERR_NO,88\n       SEGDO NOT_VALID\n     ENDIF\n     SEGDO WRITE_PCREDUMP              write blank line to PCREDUMP\n     MVC   MESS_TXT(30),=CL30'RXPCRE2A - starting again'\n     SEGDO WRITE_PCREDUMP              write MESS_TXT to PCREDUMP\n   ENDIF\n*\n   L     R2,0(,R8)                     get command address\n   IF (CLI,DEBUG_MODE,EQ,C'Y')         can be set on first call\n     MVC   MESS_TXT(11),=C'RXPCRE2A - '\n     MVC   MESS_TXT+11(20),0(R2)       output command\n     SEGDO WRITE_PCREDUMP              write MESS_TXT to PCREDUMP\n   ENDIF\n   IF (CLC,=C'CONNECT ',EQ,0(R2))\n     SEGDO SET_C_ENVIRONMENT\n   ELSEIF (CLC,=C'CONNECTD ',EQ,0(R2))\n     MVI   DEBUG_MODE,C'Y'\n     L     R9,76(,R8)                  copy DCB address in RXPCRE2\n     OPEN  ((R9),OUTPUT),MODE=31       open output file\n     IF (LTR,15,R15,NZ)                error on open\n       MVI   ERR_NO,88\n       SEGDO NOT_VALID\n     ENDIF\n     MVI   PCREDUMP_OPEN,C'Y'          flag as open\n     SEGDO WRITE_PCREDUMP              write blank line\n     MVC   MESS_TXT(20),=CL20'RXPCRE2A - starting'\n     SEGDO WRITE_PCREDUMP              write MESS_TXT to PCREDUMP\n     SEGDO SET_C_ENVIRONMENT\n   ELSEIF (CLC,=C'COMPILE ',EQ,0(R2))\n     LH    R1,TOT_COMPILES               increment count of compiles\n     IF (CHI,R1,NL,MAX_NUM_COMPILES)\n       MVI   ERR_NO,56\n       SEGDO NOT_VALID\n     ENDIF\n     SEGDO COMPILE_REGEX\n   ELSEIF (CLC,=C'MATCH ',EQ,0(R2))\n     SEGDO MATCH_REGEX\n   ELSEIF (CLC,=C'SUBSTITUTE ',EQ,0(R2))\n     SEGDO SUBSTITUTE_REGEX\n   ELSEIF (CLC,=C'RELEASE ',EQ,0(R2))\n     SEGDO RELEASE_REGEX\n   ELSEIF (CLC,=C'DISCONNECT ',EQ,0(R2))\n     SEGDO END_C_ENVIRONMENT\n   ELSE\n     MVI   ERR_NO,55\n     SEGDO NOT_VALID\n   ENDIF\n*\n   IF (CLI,DEBUG_MODE,EQ,C'Y')\n     MVC   MESS_TXT(20),=CL20'RXPCRE2A - ending'\n     SEGDO WRITE_PCREDUMP\n     CLOSE ((R9)),MODE=31              close output file\n     IF (CFI,R15,NE,0)\n       MVC   MESS_TXT(22),=CL22'RXPCRE2A close failed'\n       XUNPK (R15),,MESS_TXT+22\n       SEGDO WRITE_LOG\n     ENDIF\n   ENDIF\n*\n SEGE MAIN_BIT\n*______________________________________________________________________\n*\n SEGS COMPILE_REGEX\n*\n*  compile the REGEX\n*\n   L     R1,4(R8)                      point to REGEX details\n   MVC   REG_EX_ADDR,0(R1)\n   MVC   REG_EX_LEN,4(R1)\n   MVC   REG_EX_END,8(R1)\n*\n   L     R1,8(,R8)                     point to options\n   MVC   REPEAT_SRCH,8(R1)             and copy them\n   MVC   IGNORE_CASE,9(R1)\n   MVC   EXCLUDE_WHITE,10(R1)\n*\n   L     R1,12(,R8)                    point to option word\n   MVC   OPTION_WORD,0(R1)             and copy it\n*\n   IF (CLI,DEBUG_MODE,EQ,C'Y')\n     MVC   MESS_TXT(20),=CL20'before REGEX conv'\n     XUNPK CONVERT_HANDLE,4,MESS_TXT+20\n     SEGDO WRITE_PCREDUMP\n   ENDIF\n   MVC   FUNC_NAME,=V(ZCSCONVP)        set C function required\n   L     R14,CONVERT_HANDLE\n   L     R15,REG_EX_ADDR\n   L     R0,REG_EX_LEN\n   LA    R1,CONV_REGEX_ADDR\n   LA    R2,CONV_REGEX_LEN\n   STM   R14,R2,MY_P_3                 save parameters\n   IF (CLI,DEBUG_MODE,EQ,C'Y')\n     MVC   NUMBER_OF_PARMS,=H'5'\n     MVC   PROGRAM_CALL,=CL8'ZCSCONVP'\n   ENDIF\n   SEGDO CALL_C_FUNCTION               go and compile it\n   IF (CLI,DEBUG_MODE,EQ,C'Y')\n     MVC   MESS_TXT(20),=CL20'REGEX converted'\n     XUNPK CONV_REGEX_ADDR,4,MESS_TXT+20\n     XUNPK CONV_REGEX_LEN,4,MESS_TXT+30\n     SEGDO WRITE_PCREDUMP\n     MVC   NUMBER_OF_PARMS,=H'6'\n     MVC   PROGRAM_CALL,=CL8'COMPILE2'\n   ENDIF\n*\n   MVC   FUNC_NAME,=V(COMPILE2)        set C function required\n   L     R14,CONV_REGEX_ADDR           address of REGEX\n   L     R15,CONV_REGEX_LEN            length of REGEX\n   LA    R0,0                          0 = no options\n   IF (CLI,IGNORE_CASE,EQ,C'Y')\n     O     R0,PCRE2_CASELESS           add ignore case value\n   ENDIF\n   IF (CLI,EXCLUDE_WHITE,EQ,C'Y')\n     O     R0,PCRE2_EXTENDED           add exclude white space\n   ENDIF\n   O     R0,OPTION_WORD                add specified compile options\n   LA    R1,PCREWS_ERRORNUMBER         error number field\n   LA    R2,PCREWS_ERROROFFSET         error offfset field\n   LA    R3,0                          0\n   STM   R14,R3,MY_P_3                 save parameters\n   SEGDO CALL_C_FUNCTION               go and compile it\n   ST    R15,PCREWS_RE_PTR             save returned address\n   L     R1,8(R8)\n   ST    R15,0(R1)                     and save in caller\n*\n   IF (CLC,PCREWS_RE_PTR,EQ,=F'0')\n     SEGDO COMPILE_ERROR\n   ENDIF\n   IF (CLI,DEBUG_MODE,EQ,C'Y')\n     MVC   MESS_TXT(14),=C'REGEX compiled'\n     XUNPK PCREWS_RE_PTR,4,MESS_TXT+20\n     SEGDO WRITE_PCREDUMP\n   ENDIF\n*\n   SEGDO CREATE_MATCH_BLOCK\n   IF (CLI,DEBUG_MODE,EQ,C'Y')\n     MVC   MESS_TXT(19),=C'Match block created'\n     SEGDO WRITE_PCREDUMP\n   ENDIF\n*\n   PUSH  USING\n   USING MAP_HANDLES,R14\n   LA    R14,ALL_THE_COMPILES\n   LA    R15,MAX_NUM_COMPILES\n   DO FROM=(R15)\n   DOEXIT (CLC,=F'0',EQ,THIS_COMPILE)\n     LA    R14,8(,R14)\n   ENDDO\n   L     R1,8(R8)\n   MVC   THIS_COMPILE,0(R1)            copy compile handle\n   MVC   THIS_MATCH,4(R1)              copy match block handle\n   LH    R1,TOT_COMPILES               increment count of compiles\n   LA    R1,1(,R1)\n   STH   R1,TOT_COMPILES\n   POP   USING\n*\n SEGE COMPILE_REGEX\n*______________________________________________________________________\n*\n SEGS MATCH_REGEX\n*\n*  R8 points to A(pcre_comp) str_adr str_len stem_name stem_len option\n*\n   L     R1,4(R8)                      address in caller\n   MVC   PCREWS_RE_PTR,0(R1)           compile block\n   MVC   PCREWS_MATCH_DATA,4(R1)       match block\n   MVC   REPEAT_SRCH,8(R1)             copy options\n   MVC   IGNORE_CASE,9(R1)\n   MVC   EXCLUDE_WHITE,10(R1)\n*\n   MVC   PCREWS_SUBJECT_PTR,8(R8)      string address\n   MVC   PCREWS_SUBJECT_LEN,12(R8)     string length\n   MVC   THE_STR_ADDR,8(R8)\n   MVC   THE_STR_LENGTH,12(R8)\n   MVC   THE_STR_END,16(R8)\n   MVC   ROOT_NAME_ADR,20(R8)          stem name\n   MVC   ROOT_NAME_LEN,24(R8)          stem length\n   MVC   POS_NAME_ADR,20(R8)           stem name\n   MVC   POS_NAME_LEN,24(R8)           stem length\n   MVC   NAMED_NAME_ADR,20(R8)         Stem name\n   MVC   NAMED_NAME_LEN,24(R8)         Stem length\n   MVC   STRING_NAME_ADR,20(R8)        stem name\n   MVC   STRING_NAME_LEN,24(R8)        stem length\n*\n   L     R1,28(,R8)                    point to option word\n   MVC   OPTION_WORD,0(R1)             and copy it\n*\n   MVC   FUNC_NAME,=V(ZCSCONVS)        set C function required\n   L     R14,CONVERT_HANDLE            code page conversion handle\n   L     R15,PCREWS_SUBJECT_PTR        string to convert\n   L     R0,PCREWS_SUBJECT_LEN         length of string\n   LA    R1,CONV_SUBJECT_PTR           field for converted address\n   LA    R2,CONV_SUBJECT_LEN           field for converted length\n   STM   R14,R2,MY_P_3                 save parameters\n   IF (CLI,DEBUG_MODE,EQ,C'Y')\n     MVC   NUMBER_OF_PARMS,=H'5'\n     MVC   PROGRAM_CALL,=CL8'ZCSCONVS'\n   ENDIF\n   SEGDO CALL_C_FUNCTION               go and compile it\n   IF (CLI,DEBUG_MODE,EQ,C'Y')\n     MVC   MESS_TXT(20),=CL20'STRING converted'\n     XUNPK CONV_SUBJECT_PTR,4,MESS_TXT+20\n     XUNPK CONV_SUBJECT_LEN,4,MESS_TXT+30\n     SEGDO WRITE_PCREDUMP\n   ENDIF\n*\n   XC    ROOT_ZERO_COUNT,ROOT_ZERO_COUNT   trigger init process\n   MVI   ROOT_TRIM_VAR,C'N'            do not trim spaces from var\n   MVHHI ROOT_FUNCTION,1               init STEM.0\n   LA    R1,ROOT_AREA                  point to STEM. area\n   SEGDO CALL_PROCSTEM\n*\n   XC    POS_ZERO_COUNT,POS_ZERO_COUNT\n   MVI   POS_TRIM_VAR,C'Y'             do trim spaces from var\n   MVC   POS_MID_NAME,=CL20'POS'       specify required .MIDDLE.\n   MVHHI POS_FUNCTION,1                init STEM.POS.0\n   LA    R1,POS_AREA                   point to STEM.POS. area\n   SEGDO CALL_PROCSTEM\n*\n   XC    NAMED_ZERO_COUNT,NAMED_ZERO_COUNT\n   MVI   NAMED_TRIM_VAR,C'N'           do not trim spaces from var\n   MVC   NAMED_MID_NAME,=CL20'NAME'\n   MVHHI NAMED_FUNCTION,1              init STEM.NAME.0\n   LA    R1,NAMED_AREA                 point to STEM.NAME. area\n   SEGDO CALL_PROCSTEM\n*\n   XC    STRING_ZERO_COUNT,STRING_ZERO_COUNT\n   MVI   STRING_TRIM_VAR,C'N'          do not trim spaces from var\n   MVC   STRING_MID_NAME,=CL20'STRING'\n   MVHHI STRING_FUNCTION,1             init STEM.STRING.0\n   LA    R1,STRING_AREA                point to STEM.STRING. area\n   SEGDO CALL_PROCSTEM\n*\n   IF (CLI,DEBUG_MODE,EQ,C'Y')\n     MVC   MESS_TXT(12),=C'Repeat srch='\n     MVC   MESS_TXT+12(1),REPEAT_SRCH\n     SEGDO WRITE_PCREDUMP\n     MVC   MESS_TXT(12),=C'Ignore case='\n     MVC   MESS_TXT+12(1),IGNORE_CASE\n     SEGDO WRITE_PCREDUMP\n     MVC   MESS_TXT(14),=C'Exclude white='\n     MVC   MESS_TXT+14(1),EXCLUDE_WHITE\n     SEGDO WRITE_PCREDUMP\n   ENDIF\n*\n   ZAP   FIRST_SET_MATCH,=P'0'         initialise\n*\n   SEGDO DO_FIRST_MATCH\n*\n   IF (CLI,REPEAT_SRCH,EQ,C'Y')\n     IF (CLI,DEBUG_MODE,EQ,C'Y')\n       MVC   MESS_TXT(15),=C'Trying for more'\n       SEGDO WRITE_PCREDUMP\n     ENDIF\n     DO INF\n     DOEXIT (CLC,HIGHEST_MATCH,EQ,=F'0')\n       SEGDO TRY_FOR_MORE_MATCH\n     ENDDO\n   ENDIF\n*\n   IF (CP,ROOT_ZERO_COUNT,GT,=P'0')\n     SETRC RC=1                    RC=1 - some matches\n   ENDIF                  else     RC=0 - no matches\n*\n SEGE MATCH_REGEX\n*______________________________________________________________________\n*\n SEGS SUBSTITUTE_REGEX\n*\n*  R8 points to A(pcre_comp) str_adr str_len var_name var_len option\n*               subs_str_adr subs_str_len\n*\n   IF (CLI,INIT_SUBS_DONE,NE,C'Y')\n     SEGDO INIT_SUBS_CONVERSION\n   ENDIF\n*\n   L     R1,4(R8)                      address in caller\n   MVC   PCREWS_RE_PTR,0(R1)           compile block\n   MVC   PCREWS_MATCH_DATA,4(R1)       match block\n   MVC   REPEAT_SRCH,8(R1)             copy options\n   MVC   IGNORE_CASE,9(R1)\n   MVC   EXCLUDE_WHITE,10(R1)\n*\n   MVC   PCREWS_SUBJECT_PTR,8(R8)      string address\n   MVC   PCREWS_SUBJECT_LEN,12(R8)     string length\n   MVC   THE_STR_ADDR,8(R8)\n   MVC   THE_STR_LENGTH,12(R8)\n   MVC   THE_STR_END,16(R8)\n   MVC   VAR_NAME_ADDR,20(R8)          variable name\n   MVC   VAR_NAME_LEN,24(R8)           variable name length\n   MVC   SUBS_STR_ADDR,28(R8)\n   MVC   SUBS_STR_LEN,32(R8)\n*\n   L     R1,40(,R8)                    point to option word\n   MVC   OPTION_WORD,0(R1)             and copy it\n*\n   MVC   FUNC_NAME,=V(ZCSCONVS)        set C function required\n   L     R14,CONVERT_HANDLE            code page conversion handle\n   L     R15,PCREWS_SUBJECT_PTR        string to convert\n   L     R0,PCREWS_SUBJECT_LEN         length of string\n   LA    R1,CONV_SUBJECT_PTR           field for converted address\n   LA    R2,CONV_SUBJECT_LEN           field for converted length\n   STM   R14,R2,MY_P_3                 save parameters\n   IF (CLI,DEBUG_MODE,EQ,C'Y')\n     MVC   NUMBER_OF_PARMS,=H'5'\n     MVC   PROGRAM_CALL,=CL8'ZCSCONVS'\n   ENDIF\n   SEGDO CALL_C_FUNCTION               go and compile it\n   IF (CLI,DEBUG_MODE,EQ,C'Y')\n     MVC   MESS_TXT(20),=CL20'STRING converted'\n     XUNPK CONV_SUBJECT_PTR,4,MESS_TXT+20\n     XUNPK CONV_SUBJECT_LEN,4,MESS_TXT+30\n     SEGDO WRITE_PCREDUMP\n   ENDIF\n*\n   MVC   FUNC_NAME,=V(ZCSCONVR)        set C function required\n   L     R14,CONVERT_HANDLE            code page conversion handle\n   L     R15,SUBS_STR_ADDR             string to convert\n   L     R0,SUBS_STR_LEN               length of string\n   LA    R1,CONV_SUBST_PTR             field for converted address\n   LA    R2,CONV_SUBST_LEN             field for converted length\n   STM   R14,R2,MY_P_3                 save parameters\n   IF (CLI,DEBUG_MODE,EQ,C'Y')\n     MVC   NUMBER_OF_PARMS,=H'5'\n     MVC   PROGRAM_CALL,=CL8'ZCSCONVR'\n   ENDIF\n   SEGDO CALL_C_FUNCTION               go and compile it\n   IF (CLI,DEBUG_MODE,EQ,C'Y')\n     MVC   MESS_TXT(20),=CL20'SUBST converted'\n     XUNPK CONV_SUBJECT_PTR,4,MESS_TXT+20\n     XUNPK CONV_SUBJECT_LEN,4,MESS_TXT+30\n     SEGDO WRITE_PCREDUMP\n   ENDIF\n*\n   IF (CLI,DEBUG_MODE,EQ,C'Y')\n     MVC   MESS_TXT(12),=C'Repeat srch='\n     MVC   MESS_TXT+12(1),REPEAT_SRCH\n     SEGDO WRITE_PCREDUMP\n     MVC   MESS_TXT(12),=C'Ignore case='\n     MVC   MESS_TXT+12(1),IGNORE_CASE\n     SEGDO WRITE_PCREDUMP\n     MVC   MESS_TXT(14),=C'Exclude white='\n     MVC   MESS_TXT+14(1),EXCLUDE_WHITE\n     SEGDO WRITE_PCREDUMP\n   ENDIF\n*\n   SEGDO DO_THE_SUBSTITUTE\n*\n SEGE SUBSTITUTE_REGEX\n*______________________________________________________________________\n*\n SEGS CREATE_MATCH_BLOCK\n*\n*  create a block to hold results of the REGEX\n*\n   MVC   FUNC_NAME,=V(MATCDCFP)        set C function\n   L     R14,PCREWS_RE_PTR\n   L     R15,PCREWS_NULL_PTR\n   STM   R14,R15,MY_P_3                save parameters\n   IF (CLI,DEBUG_MODE,EQ,C'Y')\n     MVC   NUMBER_OF_PARMS,=H'2'\n     MVC   PROGRAM_CALL,=CL8'MATCDCFP'\n   ENDIF\n   SEGDO CALL_C_FUNCTION\n   ST    R15,PCREWS_MATCH_DATA         save returned address\n   L     R1,8(R8)\n   ST    R15,4(R1)                     and save in caller\n*\n   IF (CLI,DEBUG_MODE,EQ,C'Y')\n     MVC   MESS_TXT(14),=C'match block is'\n     XUNPK PCREWS_MATCH_DATA,4,MESS_TXT+20\n     SEGDO WRITE_PCREDUMP\n   ENDIF\n*\n SEGE CREATE_MATCH_BLOCK\n*______________________________________________________________________\n*\n SEGS DO_FIRST_MATCH\n*\n*  see if there is a match for the REGEX in the supplied string\n*\n   MVC   FUNC_NAME,=V(MATCH2)          set C function\n   L     R14,PCREWS_RE_PTR\n   L     R15,CONV_SUBJECT_PTR\n   L     R0,CONV_SUBJECT_LEN\n   LA    R1,0\n   LA    R2,0\n   O     R2,OPTION_WORD                add specified match options\n   L     R3,PCREWS_MATCH_DATA\n   L     R4,PCREWS_NULL_PTR\n   STM   R14,R4,MY_P_3                 save parameters\n   IF (CLI,DEBUG_MODE,EQ,C'Y')\n     MVC   NUMBER_OF_PARMS,=H'7'\n     MVC   PROGRAM_CALL,=CL8'MATCH2'\n   ENDIF\n   SEGDO CALL_C_FUNCTION\n   ST    R15,PCREWS_RC                 save returned value\n   IF (CLI,DEBUG_MODE,EQ,C'Y')\n     STRING ('First match return was ',C,PCREWS_RC,X)\n     SEGDO WRITE_PCREDUMP\n   ENDIF\n   L     R15,PCREWS_RC                 reload RC (write changes R15)\n   IF (LTR,R15,R15,M)                  < 0\n     IF (CHI,R15,EQ,-1)\n       IF (CLI,DEBUG_MODE,EQ,C'Y')\n         MVC   MESS_TXT(8),=C'No match'\n         SEGDO WRITE_PCREDUMP\n       ENDIF\n     ELSE\n       STRING ('Matching error ',C,PCREWS_RC,I)\n       MVI   ERR_NO,99\n       SEGDO NOT_VALID\n     ENDIF\n     SEGQUIT                           and quit this segment\n   ENDIF\n*\n   MVC   FUNC_NAME,=V(GETOVEPT)        set C function\n   L     R1,PCREWS_MATCH_DATA\n   ST    R1,MY_P_3                     save parameter\n   IF (CLI,DEBUG_MODE,EQ,C'Y')\n     MVC   NUMBER_OF_PARMS,=H'1'\n     MVC   PROGRAM_CALL,=CL8'GETOVEPT'\n   ENDIF\n   SEGDO CALL_C_FUNCTION\n   ST    R15,PCREWS_OVECTOR\n*\n*  See if output vector wasn't big enough. This should not happen,\n*  because we used pcre2_match_data_create_from_pattern() above.\n*\n   IF (CLC,PCREWS_RC,EQ,=F'0')\n     MVC   MESS_TXT(37),=C'RXPCRE2A-011 - Ovector not big enough'\n     SEGDO CALL_IRXSAY\n     IF (CLI,DEBUG_MODE,EQ,C'Y')\n       MVC   MESS_TXT(22),=C'Ovector not big enough'\n       SEGDO WRITE_PCREDUMP\n     ENDIF\n   ENDIF\n*\n   SEGDO OUTPUT_MATCH_RESULTS\n*\n   SEGDO TRY_NAMED_SUBSTRING\n*\n SEGE DO_FIRST_MATCH\n*______________________________________________________________________\n*\n SEGS TRY_FOR_MORE_MATCH\n*\n*  g option specified so try for more matches\n*\n   MVC   FUNC_NAME,=V(MATCH2)          set C function\n   L     R14,PCREWS_RE_PTR\n   L     R15,CONV_SUBJECT_PTR\n   L     R0,CONV_SUBJECT_LEN\n   L     R1,HIGHEST_MATCH\n   LA    R2,0\n   O     R2,OPTION_WORD                add specified match options\n   L     R6,PCREWS_OVECTOR             point to output vector\n   IF (CLC,0(4,R6),EQ,4(R6))           empty string ?\n     L     R2,PCRE2_ANCHORED           set options in R2\n     O     R2,PCRE2_NOT_EMPTY\n   ENDIF\n   L     R3,PCREWS_MATCH_DATA\n   L     R4,PCREWS_NULL_PTR\n   STM   R14,R4,MY_P_3                 save parameters\n   IF (CLI,DEBUG_MODE,EQ,C'Y')\n     MVC   NUMBER_OF_PARMS,=H'7'\n     MVC   PROGRAM_CALL,=CL8'MATCH2'\n   ENDIF\n   SEGDO CALL_C_FUNCTION\n   ST    R15,PCREWS_RC\n   IF (CLI,DEBUG_MODE,EQ,C'Y')\n     STRING ('Next match return was ',C,PCREWS_RC,X)\n     SEGDO WRITE_PCREDUMP\n   ENDIF\n   L     R15,PCREWS_RC\n   IF (LTR,R15,R15,NP)                 < 1\n     XC    HIGHEST_MATCH,HIGHEST_MATCH   flag no more matches\n     IF (CHI,R15,EQ,-1)\n       SEGQUIT                         found all the matches\n     ELSE\n       STRING ('Matching error ',C,PCREWS_RC,I)\n       MVI   ERR_NO,99\n       SEGDO NOT_VALID\n     ENDIF\n     SEGQUIT                           and quit this segment\n   ENDIF\n*\n   MVC   FUNC_NAME,=V(GETOVEPT)        set C function\n   L     R1,PCREWS_MATCH_DATA\n   ST    R1,MY_P_3                     save parameter\n   IF (CLI,DEBUG_MODE,EQ,C'Y')\n     MVC   NUMBER_OF_PARMS,=H'1'\n     MVC   PROGRAM_CALL,=CL8'GETOVEPT'\n   ENDIF\n   SEGDO CALL_C_FUNCTION\n   ST    R15,PCREWS_OVECTOR\n*\n*  See if output vector wasn't big enough. This should not happen,\n*  because we used pcre2_match_data_create_from_pattern() above.\n*\n   IF (CLC,PCREWS_RC,EQ,=F'0')\n     MVC   MESS_TXT(37),=C'RXPCRE2A-012 - Ovector not big enough'\n     SEGDO CALL_IRXSAY\n     IF (CLI,DEBUG_MODE,EQ,C'Y')\n       MVC   MESS_TXT(22),=C'Ovector not big enough'\n       SEGDO WRITE_PCREDUMP\n     ENDIF\n   ENDIF\n*\n   SEGDO OUTPUT_MATCH_RESULTS\n*\n   SEGDO TRY_NAMED_SUBSTRING\n*\n SEGE TRY_FOR_MORE_MATCH\n*______________________________________________________________________\n*\n SEGS OUTPUT_MATCH_RESULTS\n*\n*  output the results of the REGEX match\n*\n*  When bytes 4 and 5 match the expression the values returned are\n*  3 and 5. So length of match is (5-3).\n*\n   XC    HIGHEST_MATCH,HIGHEST_MATCH   set to zero\n*\n   IF (CLI,DEBUG_MODE,EQ,C'Y')\n     L     R6,PCREWS_OVECTOR           point to output vector\n     L     R3,PCREWS_RC                count of values\n     DO FROM=(R3)\n       LM    R4,R5,0(R6)               offset and end of match\n       STRING ('Ovector',C,(R4),X,(R4),I,(R5),X,(R5),I),PADB=Y\n       SEGDO WRITE_PCREDUMP\n       LA    R6,8(,R6)                 point past this pair of values\n     ENDDO\n   ENDIF\n*\n   ZAP   FIRST_SET_MATCH,POS_ZERO_COUNT  save current variable count\n*\n   L     R6,PCREWS_OVECTOR             point to output vector\n   L     R3,PCREWS_RC                  count of values\n   DO FROM=(R3)\n     LM    R4,R5,0(R6)                 offset and end of match\n     IF (C,R5,GT,HIGHEST_MATCH)        keep highest position\n       ST    R5,HIGHEST_MATCH\n     ENDIF\n     IF (C,R5,GE,THE_STR_LENGTH)       at end of string\n       XC    HIGHEST_MATCH,HIGHEST_MATCH   set to zero\n     ENDIF\n     IF (CR,R5,EQ,R6)                  match is empty string\n       XC    HIGHEST_MATCH,HIGHEST_MATCH   set to zero\n     ENDIF\n     SR    R5,R4                       get length\n*    IF (CFI,R5,GT,MAX_STEM_LEN)       string to long\n*      MVI   ERR_NO,31\n*      SEGDO NOT_VALID\n*    ENDIF\n     IF (CLI,DEBUG_MODE,EQ,C'Y')\n       STRING ('Match succeeded at offset ',C,(R4),I,                  /\n               ' length ',C,(R5),I)\n       SEGDO WRITE_PCREDUMP\n     ENDIF\n     LA    R4,1(,R4)                   convert offset to position\n     ST    R4,STEM_POS                 save position\n     BCTR  R4,0                        back to offset\n     ST    R5,STEM_LEN                 save length\n     L     R1,THE_STR_ADDR             get address of string\n     LA    R4,0(R1,R4)                 point to first matching byte\n*    now R4 points to the text\n*    and R5 has the length\n     STM   R4,R5,SAVE_R4_R5\n     LA    R14,STEM_TEXT               area for stem value\n     LR    R15,R5                      copy length\n     IF (CFI,R15,GT,MAX_STEM_LEN)      string to long\n       L     R15,MAX_STEM_LEN          truncate in STEM_TEXT but we\n     ENDIF                             output the full string\n     MVCL  R14,R4                      copy fragment to STEM_TEXT\n     LM    R4,R5,SAVE_R4_R5\n     ST    R6,CURRENT_ADDRESS          save current position\n     ST    R3,CURRENT_COUNT            save current count\n     SEGDO STEM_LINE                   go output stem line\n     L     R6,CURRENT_ADDRESS          restore position\n     L     R3,CURRENT_COUNT            restore count\n     LA    R6,8(,R6)                   point past this pair of values\n   ENDDO\n*\n SEGE OUTPUT_MATCH_RESULTS\n*______________________________________________________________________\n*\n SEGS TRY_NAMED_SUBSTRING\n*\n*  see if there is a named substring available in this match\n*\n   MVC   FUNC_NAME,=V(PATTERN2)\n   L     R14,PCREWS_RE_PTR\n   LA    R15,PCRE2_INFO_NAMECOUNT\n   LA    R0,PCREWS_NAMECOUNT\n   STM   R14,R0,MY_P_3\n   IF (CLI,DEBUG_MODE,EQ,C'Y')\n     MVC   NUMBER_OF_PARMS,=H'3'\n     MVC   PROGRAM_CALL,=CL8'PATTERN2'\n   ENDIF\n   SEGDO CALL_C_FUNCTION\n   IF (CLI,DEBUG_MODE,EQ,C'Y')\n     STRING   ('Name count is ',C,PCREWS_NAMECOUNT,I)\n     SEGDO WRITE_PCREDUMP\n   ENDIF\n   IF (CLC,PCREWS_NAMECOUNT,GT,=F'0')  got some names?\n     IF (CLI,DEBUG_MODE,EQ,C'Y')\n       MVC   MESS_TXT(16),=C'Named substrings'\n       SEGDO WRITE_PCREDUMP\n     ENDIF\n     MVC   FUNC_NAME,=V(PATTERN2)\n     L     R14,PCREWS_RE_PTR\n     LA    R15,PCRE2_INFO_NAMETABLE\n     LA    R0,PCREWS_NAME_TABLE\n     STM   R14,R0,MY_P_3\n     IF (CLI,DEBUG_MODE,EQ,C'Y')\n       MVC   NUMBER_OF_PARMS,=H'3'\n       MVC   PROGRAM_CALL,=CL8'PATTERN2'\n     ENDIF\n     SEGDO CALL_C_FUNCTION\n     MVC   FUNC_NAME,=V(PATTERN2)\n     L     R14,PCREWS_RE_PTR\n     LA    R15,PCRE2_INFO_NAM_ENTSZ\n     LA    R0,PCREWS_NAME_ENTSZ\n     STM   R14,R0,MY_P_3\n     IF (CLI,DEBUG_MODE,EQ,C'Y')\n       MVC   NUMBER_OF_PARMS,=H'3'\n       MVC   PROGRAM_CALL,=CL8'PATTERN2'\n     ENDIF\n     SEGDO CALL_C_FUNCTION\n     IF (CLI,DEBUG_MODE,EQ,C'Y')\n       STRING   ('Name size is  ',C,PCREWS_NAME_ENTSZ,I)\n       SEGDO WRITE_PCREDUMP\n     ENDIF\n     IF (CLI,DEBUG_MODE,EQ,C'Y')\n       L     R4,PCREWS_NAME_TABLE\n       MVC   WORK_32,0(R4)\n       STRING   ('Name table is ',C,WORK_32,X)\n       SEGDO WRITE_PCREDUMP\n     ENDIF\n     L     R5,PCREWS_NAMECOUNT         get count of names\n     L     R4,PCREWS_NAME_TABLE        point to name table\n     DO FROM=(R5)                      loop counter\n       LH    R1,0(R4)                  get array offset\n       CVD   R1,DOUB_WORD              convert to decimal\n       AP    DOUB_WORD,FIRST_SET_MATCH add start of this set results\n       L     R1,PCREWS_NAME_ENTSZ      length of name entry\n       AHI   R1,-2                     -2 for halfword variable number\n       AHI   R1,-1                     -1 for EX (and the null)\n       ST    R1,STEM_LEN               save length of text\n       EX    R1,COPY_NAME_TEXT         copy text could end in nulls\n       IF (CLI,DEBUG_MODE,EQ,C'Y')\n         STRING (STEM_LEN,I)\n         MVC   MESS_TXT+14(32),STEM_TEXT\n         SEGDO WRITE_PCREDUMP\n       ENDIF\n       L     R1,STEM_LEN               restore in case debug\n       LA    R14,STEM_TEXT             point at output area\n       LA    R14,0(R1,R14)             point after last output byte\n       BCTR  R14,0                     now pointing at last\n       DO FROM=(R1)                    loop count on output length\n       DOEXIT (CLI,0(R14),GT,X'00')    quit when not null\n         BCTR  R14,0                   point back a byte\n       ENDDO\n       ST    R1,STEM_LEN               save new length of text\n       IF (CLI,DEBUG_MODE,EQ,C'Y')\n         STRING (STEM_LEN,I)\n         MVC   MESS_TXT+14(32),STEM_TEXT\n         SEGDO WRITE_PCREDUMP\n       ENDIF\n       SEGDO STEM_LINE_NAME\n       A     R4,PCREWS_NAME_ENTSZ      next entry in name table\n     ENDDO\n   ENDIF\n*\n SEGE TRY_NAMED_SUBSTRING\n*______________________________________________________________________\n*\n SEGS DO_THE_SUBSTITUTE\n*\n*  see if there is a match for the REGEX in the supplied string\n*\n   LA    R15,0\n   IF (CLI,REPEAT_SRCH,EQ,C'Y')\n     LA    R15,PCRE2_SUBSTITUTE_GLOBAL\n   ENDIF\n   O     R15,OPTION_WORD\n   ST    R15,PCREWS_OPTION_BITS\n*\n   MVC   FUNC_NAME,=V(SUBSTIT2)        set C function\n   L     R14,PCREWS_RE_PTR\n   L     R15,CONV_SUBJECT_PTR\n   L     R0,CONV_SUBJECT_LEN\n   LA    R1,0\n   L     R2,PCREWS_OPTION_BITS\n   L     R3,PCREWS_MATCH_DATA\n   L     R4,PCREWS_NULL_PTR\n   STM   R14,R4,MY_P_3                 save parameters\n   L     R14,CONV_SUBST_PTR\n   L     R15,CONV_SUBST_LEN\n   L     R0,SUBST_OUT_PTR\n*  LA    R1,256\n*  ST    R1,SUBST_OUT_LEN\n   MVC   SUBST_OUT_LEN,SUBST_OUT_MAX_LEN\n   LA    R1,SUBST_OUT_LEN\n   STM   R14,R1,MY_P_10                save parameters\n   IF (CLI,DEBUG_MODE,EQ,C'Y')\n     MVC   NUMBER_OF_PARMS,=H'11'\n     MVC   PROGRAM_CALL,=CL8'SUBSTIT2'\n   ENDIF\n   MVI   DUMP_CALL,C'Y'\n   SEGDO CALL_C_FUNCTION\n   ST    R15,PCREWS_RC                 save returned value\n   IF (CLI,DEBUG_MODE,EQ,C'Y')\n     STRING ('Substitute return was ',C,PCREWS_RC,X)\n     XUNPK SUBST_OUT_PTR,4,MESS_TXT+40\n     XUNPK SUBST_OUT_LEN,4,MESS_TXT+50\n     SEGDO WRITE_PCREDUMP\n   ENDIF\n   L     R15,PCREWS_RC                 reload RC (write changes R15)\n   IF (CHI,R15,GE,1)\n     SETRC RC=1                    RC=1 - some matches\n   ENDIF                  else     RC=0 - no matches\n   IF (LTR,R15,R15,M)                  < 0\n     IF (CHI,R15,EQ,-1)\n       IF (CLI,DEBUG_MODE,EQ,C'Y')\n         MVC   MESS_TXT(8),=C'No subst'\n         SEGDO WRITE_PCREDUMP\n       ENDIF\n     ELSE\n       SEGDO SUBSTITUTE_ERROR\n*      control does not return to here\n     ENDIF\n     SEGQUIT                           and quit this segment\n   ENDIF\n*\n   MVC   FUNC_NAME,=V(ZCSCONVB)        set C function required\n   L     R14,CONVERT_HANDLE            code page conversion handle\n   L     R15,SUBST_OUT_PTR             string to convert\n   L     R0,SUBST_OUT_LEN              length of string\n   LA    R1,CONV_BACK_PTR              field for converted address\n   LA    R2,CONV_BACK_LEN              field for converted length\n   STM   R14,R2,MY_P_3                 save parameters\n   IF (CLI,DEBUG_MODE,EQ,C'Y')\n     MVC   NUMBER_OF_PARMS,=H'5'\n     MVC   PROGRAM_CALL,=CL8'ZCSCONVB'\n   ENDIF\n   SEGDO CALL_C_FUNCTION               go and compile it\n   IF (CLI,DEBUG_MODE,EQ,C'Y')\n     MVC   MESS_TXT(20),=CL20'SUBST converted'\n     XUNPK CONV_SUBJECT_PTR,4,MESS_TXT+20\n     XUNPK CONV_SUBJECT_LEN,4,MESS_TXT+30\n     SEGDO WRITE_PCREDUMP\n   ENDIF\n*\n   SEGDO OUTPUT_A_VARIABLE\n*\n SEGE DO_THE_SUBSTITUTE\n*______________________________________________________________________\n*\n SEGS COMPILE_ERROR\n*\n*  error occured compiling the REGEX - output message\n*\n   MVC   FUNC_NAME,=V(GETERROR)        set C function\n   L     R14,PCREWS_ERRORNUMBER        get error number\n   LA    R15,ERR_BUFFER                boint to buffer\n   LHI   R0,256                        length is 256 bytes\n   STM   R14,R0,MY_P_3                 save in parameter list\n   IF (CLI,DEBUG_MODE,EQ,C'Y')\n     MVC   NUMBER_OF_PARMS,=H'3'\n     MVC   PROGRAM_CALL,=CL8'GETERROR'\n   ENDIF\n   SEGDO CALL_C_FUNCTION\n   STRING     ('RXPCRE2A-013 - PCRE2 compilation failed at offset ',C, /\n               PCREWS_ERROROFFSET,I)\n   SEGDO CALL_IRXSAY\n   STRING     ('               error number was ',C,                   /\n               PCREWS_ERRORNUMBER,I)\n   SEGDO CALL_IRXSAY\n   MVC   MESS_TXT,ERR_BUFFER\n   SEGDO CALL_IRXSAY\n   IF (CLC,ERR_BUFFER+80(80),GT,SPACES)\n     MVC   MESS_TXT,ERR_BUFFER+80\n     SEGDO CALL_IRXSAY\n     IF (CLC,ERR_BUFFER+160(30),GT,SPACES)\n       MVC   MESS_TXT(30),ERR_BUFFER+160\n       SEGDO CALL_IRXSAY\n     ENDIF\n   ENDIF\n   IF (CLI,C_ENV_SETUP,EQ,C'Y')\n     SEGDO END_C_ENVIRONMENT\n   ENDIF\n   IF (CLI,DEBUG_MODE,EQ,C'Y'),AND,(CLI,PCREDUMP_OPEN,EQ,C'Y')\n     CLOSE ((R9)),MODE=31              close output file\n   ENDIF\n   PRGQUIT RC=8                        quit the program\n*\n SEGE COMPILE_ERROR\n*______________________________________________________________________\n*\n SEGS SUBSTITUTE_ERROR\n*\n*  error occured in substitute REGEX - output message\n*\n   MVC   FUNC_NAME,=V(GETERROR)        set C function\n   L     R14,PCREWS_RC                 get error number\n   LA    R15,ERR_BUFFER                boint to buffer\n   LHI   R0,256                        length is 256 bytes\n   STM   R14,R0,MY_P_3                 save in parameter list\n   IF (CLI,DEBUG_MODE,EQ,C'Y')\n     MVC   NUMBER_OF_PARMS,=H'3'\n     MVC   PROGRAM_CALL,=CL8'GETERROR'\n   ENDIF\n   SEGDO CALL_C_FUNCTION\n   STRING     ('RXPCRE2A-016 - PCRE2 substitute failed ',C)\n   SEGDO CALL_IRXSAY\n   STRING     ('               return code was  ',C,PCREWS_RC,I)\n   SEGDO CALL_IRXSAY\n   MVC   MESS_TXT,ERR_BUFFER\n   SEGDO CALL_IRXSAY\n   IF (CLC,ERR_BUFFER+80(80),GT,SPACES)\n     MVC   MESS_TXT,ERR_BUFFER+80\n     SEGDO CALL_IRXSAY\n     IF (CLC,ERR_BUFFER+160(30),GT,SPACES)\n       MVC   MESS_TXT(30),ERR_BUFFER+160\n       SEGDO CALL_IRXSAY\n     ENDIF\n   ENDIF\n   IF (CLI,C_ENV_SETUP,EQ,C'Y')\n     SEGDO END_C_ENVIRONMENT\n   ENDIF\n   IF (CLI,DEBUG_MODE,EQ,C'Y'),AND,(CLI,PCREDUMP_OPEN,EQ,C'Y')\n     CLOSE ((R9)),MODE=31              close output file\n   ENDIF\n   PRGQUIT RC=8                        quit the program\n*\n SEGE SUBSTITUTE_ERROR\n*______________________________________________________________________\n*\n SEGS STEM_LINE\n*\n*  sets stem.STRING.? to the substring of the input string\n*  sets stem.NAME.?   to ' '\n*  sets stem.POS.?    to 'x,y'         position,length\n*\n*  output the stem.STRING.? variable\n*\n   ST    R4,STRING_TEXT_ADR            store address\n   ST    R5,STRING_TEXT_LEN            store length\n   MVHHI STRING_FUNCTION,2             set STEM.STRING.? value\n   LA    R1,STRING_AREA                point to PRGSTEM expansion\n   MVC   CALL_STEM_MESS,=CL26'Error in stem.string line'\n   SEGDO CALL_PROCSTEM\n*\n*  output the stem.POS.? variable\n*\n   LA    R1,STEM_TEXT                  address of stem text\n   ST    R1,POS_TEXT_ADR               store address\n   STRING (STEM_POS,I,',',C,STEM_LEN,I),OUT=STEM_TEXT\n*                                      output from string is 23 bytes\n*                                      '         4+,         2+'\n   LA    R1,22                         required length\n   MVI   STEM_TEXT+10,C' '             make middle '+' into ' '\n   ST    R1,POS_TEXT_LEN               set length\n   MVHHI POS_FUNCTION,2                set STEM.POS.? value\n   LA    R1,POS_AREA                   point to PRGSTEM expansion\n   MVC   CALL_STEM_MESS,=CL26'Error in stem.pos line'\n   SEGDO CALL_PROCSTEM\n*\n*  output the stem.NAME.? variable as just ' ' for now\n*\n   LA    R1,STEM_TEXT                  point to text\n   MVI   STEM_TEXT,C' '                make blank\n   ST    R1,NAMED_TEXT_ADR             store address\n   LA    R1,1                          required length\n   ST    R1,NAMED_TEXT_LEN             set length\n   MVHHI NAMED_FUNCTION,2              set STEM value\n   LA    R1,NAMED_AREA                 point to PRGSTEM expansion\n   MVC   CALL_STEM_MESS,=CL26'Error in stem.name 1 line'\n   SEGDO CALL_PROCSTEM\n*\n*  output the stem.? variable as just ' '\n*\n   LA    R1,STEM_TEXT                  point to text\n   MVI   STEM_TEXT,C' '                make blank\n   ST    R1,ROOT_TEXT_ADR              store address\n   LA    R1,1                          required length\n   ST    R1,ROOT_TEXT_LEN              set length\n   MVHHI ROOT_FUNCTION,2               set STEM value\n   LA    R1,ROOT_AREA                  point to PRGSTEM expansion\n   MVC   CALL_STEM_MESS,=CL26'Error in stem.     line'\n   SEGDO CALL_PROCSTEM\n*\n*  set stem.0 to the current count\n*\n   SEGDO STEM_ZERO                     update stem.0 with new value\n*\n SEGE STEM_LINE\n*______________________________________________________________________\n*\n SEGS STEM_LINE_NAME\n*\n*  previously created stem.NAME.? variable as ' '\n*  now it is time to put in the real value\n*\n   LA    R1,STEM_TEXT                  point to text\n   ST    R1,NAMED_TEXT_ADR             store address\n   MVC   NAMED_TEXT_LEN,STEM_LEN       copy length\n   MVHHI NAMED_FUNCTION,2              set STEM value\n   ZAP   NAMED_ZERO_COUNT,DOUB_WORD+4(4)  put in variable number\n   LA    R1,NAMED_AREA                 point to PRGSTEM expansion\n   MVC   CALL_STEM_MESS,=CL26'Error in stem.name 2 line'\n   SEGDO CALL_PROCSTEM\n*\n   ZAP   NAMED_ZERO_COUNT,POS_ZERO_COUNT   put back MAX value\n*\n SEGE STEM_LINE_NAME\n*______________________________________________________________________\n*\n SEGS STEM_ZERO\n*\n*  populate stem.pos.0 with current stem count\n*\n   MVHHI POS_FUNCTION,3                set STEM.POS.0 to total lines\n   LA    R1,POS_AREA\n   MVC   CALL_STEM_MESS,=CL26'Error in stem.pos  zero'\n   SEGDO CALL_PROCSTEM\n*\n*  keep all the other STEMs in line\n*\n   ZAP   ROOT_ZERO_COUNT,POS_ZERO_COUNT\n   MVHHI ROOT_FUNCTION,3               set STEM.0 to total lines\n   LA    R1,ROOT_AREA\n   MVC   CALL_STEM_MESS,=CL26'Error in stem.     zero'\n   SEGDO CALL_PROCSTEM\n*\n   ZAP   NAMED_ZERO_COUNT,POS_ZERO_COUNT\n   MVHHI NAMED_FUNCTION,3              set STEM.NAME.0 to total lines\n   LA    R1,NAMED_AREA\n   MVC   CALL_STEM_MESS,=CL26'Error in stem.name zero'\n   SEGDO CALL_PROCSTEM\n*\n   ZAP   STRING_ZERO_COUNT,POS_ZERO_COUNT\n   MVHHI STRING_FUNCTION,3             set STEM.STRING.0 to total lines\n   LA    R1,STRING_AREA\n   MVC   CALL_STEM_MESS,=CL26'Error in stem.string zero'\n   SEGDO CALL_PROCSTEM\n*\n SEGE STEM_ZERO\n*______________________________________________________________________\n*\n SEGS CALL_PROCSTEM\n*\n*  R1 should already point to the required PRGSTEM macro expansion\n   ST    R1,MY_P_1                     save as first parm\n   LA    R1,MY_PARM                    point to parameter list\n   L     R15,=V(PROCSTEM)              get program address\n   BASR  R14,R15                       go and set stem value\n   IF (LTR,R15,R15,NZ)                 error ?\n     STRING (CALL_STEM_MESS,C,R_C,I)\n     MVI   ERR_NO,99\n     SEGDO NOT_VALID\n   ENDIF\n   XC    MY_PARM(LEN_MY_PARM),MY_PARM  clear parm list after call\n*\n SEGE CALL_PROCSTEM\n*______________________________________________________________________\n*\n SEGS SET_C_ENVIRONMENT\n*\n*  set up C environment with librarian functionality\n*\n   IF (CLI,DEBUG_MODE,EQ,C'Y')\n     MVC   MESS_TXT(30),=CL30'RXPCRE2A - get C environment'\n     SEGDO WRITE_PCREDUMP              write MESS_TXT to PCREDUMP\n   ENDIF\n*\n   L     R1,4(,R8)                     point to code page (if any)\n   MVC   CODEPAGE_PTR,0(R1)            copy details\n   MVC   CODEPAGE_LEN,4(R1)\n*\n   LA    R1,HANDLE                     address for returned handle\n   ST    R1,MY_P_1\n   LA    R1,STKSIZE                    stack size\n   ST    R1,MY_P_2\n   LA    R1,STKLOC                     stack location\n   ST    R1,MY_P_3\n   OI    MY_P_3,X'80'                  set VL flag\n   LA    R1,MY_PARM                    address of argument list\n   L     R15,=V(EDCXHOTL)\n   BASR  R14,R15                       go set up C environment\n*\n   IF (CLI,DEBUG_MODE,EQ,C'Y')\n     MVC   MESS_TXT(30),=CL30'RXPCRE2A - C environment got'\n     SEGDO WRITE_PCREDUMP\n   ENDIF\n   MVI   C_ENV_SETUP,C'Y'\n   XC    ALL_THE_COMPILES(L_ALL_THE_COMPILES),ALL_THE_COMPILES\n   XC    TOT_COMPILES,TOT_COMPILES\n*\n   SEGDO INIT_CONVERSION_ROUTINE\n*\n   MVI   INIT_SUBS_DONE,C'N'\n*\n SEGE SET_C_ENVIRONMENT\n*______________________________________________________________________\n*\n SEGS INIT_CONVERSION_ROUTINE\n*\n   MVC   FUNC_NAME,=V(ZCSINIT)\n   LA    R14,CONVERT_HANDLE            return address of code pages\n   L     R15,CODEPAGE_PTR              may be 0 if not specified\n*                                      0 means current code page\n   L     R0,CODEPAGE_LEN               length of code page name\n   LHI   R1,0                          max size of pattern - default\n   LHI   R2,0                          max size of string  - default\n*  LHI   R1,2048                       max size of pattern\n*  LHI   R2,8192                       max size of string\n   STM   R14,R2,MY_P_3                 save in parameter list\n   IF (CLI,DEBUG_MODE,EQ,C'Y')\n     MVC   NUMBER_OF_PARMS,=H'5'\n     MVC   PROGRAM_CALL,=CL8'ZCSINIT'\n   ENDIF\n   SEGDO CALL_C_FUNCTION\n   ST    R15,R_C\n   IF (CLI,DEBUG_MODE,EQ,C'Y'),AND,(CLI,PCREDUMP_OPEN,EQ,C'Y')\n     MVC   MESS_TXT(23),=CL23'RXPCRE2A - init convert'\n     XUNPK (R15),4,MESS_TXT+25\n     XUNPK CONVERT_HANDLE,4,MESS_TXT+35\n     IF (CLC,R_C,NE,=F'0')\n       MVC   MESS_TXT+45(8),=C'- FAILED'\n     ENDIF\n     L     R1,CODEPAGE_PTR\n     IF (LTR,R1,R1,NZ)\n       L     R2,CODEPAGE_LEN\n       IF (CHI,R2,GT,30)               allow max of 30 characters\n         LA    R2,30\n       ENDIF\n       BCTR  R2,0\n       EX    R2,COPY_CODEPAGE\n     ELSE\n       MVC   MESS_TXT+55(7),=C'DEFAULT'\n     ENDIF\n     SEGDO WRITE_PCREDUMP\n   ENDIF\n   IF (CLC,R_C,NE,=F'0')\n     SEGDO END_C_ENVIRONMENT\n     IF (CLI,DEBUG_MODE,EQ,C'Y'),AND,(CLI,PCREDUMP_OPEN,EQ,C'Y')\n       CLOSE ((R9)),MODE=31            close output file\n     ENDIF\n     MVC   MESS_TXT(32),=C'RXPCRE2A-014 - Code page failure'\n     SEGDO CALL_IRXSAY\n     PRGQUIT RC=8                        get out of program RC=8\n   ENDIF\n*\n SEGE INIT_CONVERSION_ROUTINE\n*______________________________________________________________________\n*\n SEGS INIT_SUBS_CONVERSION\n*\n   MVC   SUBST_OUT_MAX_LEN,=A(16*1024)\n   MVC   FUNC_NAME,=V(ZCSINIS)\n   L     R14,CONVERT_HANDLE            return address of code pages\n*  LHI   R15,2048                      max replacement size\n*  LHI   R0,8192                       max substitute size\n*  STM   R14,R0,MY_P_3                 save in parameter list\n   LHI   R15,0                         max replacement size - default\n   LHI   R0,0                          max substitute size  - default\n   LA    R1,SUBST_OUT_PTR              address of substitute output\n   STM   R14,R1,MY_P_3                 save in parameter list\n   IF (CLI,DEBUG_MODE,EQ,C'Y')\n     MVC   NUMBER_OF_PARMS,=H'4'\n     MVC   PROGRAM_CALL,=CL8'ZCSINIS'\n   ENDIF\n   MVI   DUMP_CALL,C'Y'\n   SEGDO CALL_C_FUNCTION\n   ST    R15,R_C\n   IF (CLI,DEBUG_MODE,EQ,C'Y'),AND,(CLI,PCREDUMP_OPEN,EQ,C'Y')\n     MVC   MESS_TXT(24),=CL24'RXPCRE2A - inits convert'\n     XUNPK (R15),4,MESS_TXT+26\n     XUNPK CONVERT_HANDLE,4,MESS_TXT+36\n     IF (CLC,R_C,NE,=F'0')\n       MVC   MESS_TXT+46(8),=C'- FAILED'\n     ENDIF\n     SEGDO WRITE_PCREDUMP\n     L     R3,CONVERT_HANDLE\n     XUNPK 0(R3),30,MESS_TXT+10\n     SEGDO WRITE_PCREDUMP\n     XUNPK 30(R3),30,MESS_TXT+10\n     SEGDO WRITE_PCREDUMP\n   ENDIF\n   IF (CLC,R_C,NE,=F'0')\n     SEGDO END_C_ENVIRONMENT\n     IF (CLI,DEBUG_MODE,EQ,C'Y'),AND,(CLI,PCREDUMP_OPEN,EQ,C'Y')\n       CLOSE ((R9)),MODE=31            close output file\n     ENDIF\n     MVC   MESS_TXT(32),=C'RXPCRE2A-015 - init subs failure'\n     SEGDO CALL_IRXSAY\n     PRGQUIT RC=8                      get out of program RC=8\n   ENDIF\n*\n   MVI   INIT_SUBS_DONE,C'Y'\n*\n SEGE INIT_SUBS_CONVERSION\n*______________________________________________________________________\n*\n SEGS RELEASE_REGEX\n*\n*  release match block and regex compile\n*\n   L     R1,4(R8)                      address in caller\n   MVC   PCREWS_RE_PTR,0(R1)           compile block\n   MVC   PCREWS_MATCH_DATA,4(R1)       match block\n   MVC   FUNC_NAME,=V(MATCHDFR)        free any matches\n   L     R1,PCREWS_MATCH_DATA\n   ST    R1,MY_P_3\n   IF (CLI,DEBUG_MODE,EQ,C'Y')\n     MVC   NUMBER_OF_PARMS,=H'1'\n     MVC   PROGRAM_CALL,=CL8'MATCHDFR'\n   ENDIF\n   SEGDO CALL_C_FUNCTION\n   IF (CLI,DEBUG_MODE,EQ,C'Y')\n     MVC   MESS_TXT(15),=C'Called MATCHDFR'\n     XUNPK PCREWS_MATCH_DATA,4,MESS_TXT+20\n     SEGDO WRITE_PCREDUMP\n   ENDIF\n*\n   MVC   FUNC_NAME,=V(CODEFREE)        free compiled code\n   L     R1,PCREWS_RE_PTR\n   ST    R1,MY_P_3\n   IF (CLI,DEBUG_MODE,EQ,C'Y')\n     MVC   NUMBER_OF_PARMS,=H'1'\n     MVC   PROGRAM_CALL,=CL8'CODEFREE'\n   ENDIF\n   SEGDO CALL_C_FUNCTION\n   IF (CLI,DEBUG_MODE,EQ,C'Y')\n     MVC   MESS_TXT(15),=C'Called CODEFREE'\n     XUNPK PCREWS_RE_PTR,4,MESS_TXT+20\n     SEGDO WRITE_PCREDUMP\n   ENDIF\n*\n   PUSH  USING\n   USING MAP_HANDLES,R14\n   LA    R14,ALL_THE_COMPILES\n   LA    R15,MAX_NUM_COMPILES\n   DO FROM=(R15)\n   DOEXIT (CLC,PCREWS_RE_PTR,EQ,THIS_COMPILE)\n     LA    R14,8(,R14)\n   ENDDO\n   IF (CHI,R15,NE,0)\n     XC    THIS_COMPILE,THIS_COMPILE   copy compile handle\n     XC    THIS_MATCH,THIS_MATCH       copy match block handle\n     LH    R1,TOT_COMPILES             decrement count of compiles\n     BCTR  R1,0\n     STH   R1,TOT_COMPILES\n   ELSE\n     MVC   MESS_TXT(20),=CL20'RXPCRE2A miss release'\n     SEGDO WRITE_LOG\n   ENDIF\n   POP   USING\n*\n SEGE RELEASE_REGEX\n*______________________________________________________________________\n*\n SEGS END_C_ENVIRONMENT\n*\n   IF (CLC,=H'0',NE,TOT_COMPILES)\n     SEGDO RELEASE_ALL_REGEX\n   ENDIF\n*\n   SEGDO RELEASE_CONVERSION_AREA\n*\n*  terminate C environment with librarian functionality\n*\n   LA    R1,HANDLE\n   ST    R1,MY_P_1\n   OI    MY_P_1,X'80'                  set VL flag\n   LA    R1,MY_PARM\n   L     R15,=V(EDCXHOTT)\n   BASR  R14,R15                       terminate C environment\n   IF (CLI,DEBUG_MODE,EQ,C'Y')\n     MVC   MESS_TXT(33),=C'RXPCRE2A - C environment released'\n     SEGDO WRITE_PCREDUMP\n   ENDIF\n   MVI   C_ENV_SETUP,C'N'\n   MVI   INIT_SUBS_DONE,C'N'\n   XC    TOT_COMPILES,TOT_COMPILES\n*\n SEGE END_C_ENVIRONMENT\n*______________________________________________________________________\n*\n SEGS RELEASE_ALL_REGEX\n*\n*  release all remaining matches and regex compiles\n*\n   STM   R4,R5,SAVE_R4_R5\n   PUSH  USING\n   USING MAP_HANDLES,R4\n   LA    R4,ALL_THE_COMPILES\n   LA    R5,MAX_NUM_COMPILES\n   DO FROM=(R5)\n     IF (CLC,=F'0',NE,THIS_MATCH)\n       MVC   FUNC_NAME,=V(MATCHDFR)    free any matches\n       L     R1,THIS_MATCH\n       ST    R1,MY_P_3\n       IF (CLI,DEBUG_MODE,EQ,C'Y')\n         MVC   NUMBER_OF_PARMS,=H'1'\n         MVC   PROGRAM_CALL,=CL8'MATCHDFR'\n       ENDIF\n       SEGDO CALL_C_FUNCTION\n       IF (CLI,DEBUG_MODE,EQ,C'Y')\n         MVC   MESS_TXT(15),=C'Called MATCHDFR'\n         XUNPK THIS_MATCH,4,MESS_TXT+20\n         SEGDO WRITE_PCREDUMP\n       ENDIF\n       XC    THIS_MATCH,THIS_MATCH     clear match block handle\n     ENDIF\n     IF (CLC,=F'0',NE,THIS_COMPILE)\n       MVC   FUNC_NAME,=V(CODEFREE)    free compiled code\n       L     R1,THIS_COMPILE\n       ST    R1,MY_P_3\n       IF (CLI,DEBUG_MODE,EQ,C'Y')\n         MVC   NUMBER_OF_PARMS,=H'1'\n         MVC   PROGRAM_CALL,=CL8'CODEFREE'\n       ENDIF\n       SEGDO CALL_C_FUNCTION\n       IF (CLI,DEBUG_MODE,EQ,C'Y')\n         MVC   MESS_TXT(15),=C'Called CODEFREE'\n         XUNPK THIS_COMPILE,4,MESS_TXT+20\n         SEGDO WRITE_PCREDUMP\n       ENDIF\n       XC    THIS_COMPILE,THIS_COMPILE clear compile handle\n     ENDIF\n     LA    R4,8(,R4)\n   ENDDO\n   XC    TOT_COMPILES,TOT_COMPILES     clear count\n   POP   USING\n   LM    R4,R5,SAVE_R4_R5\n*\n SEGE RELEASE_ALL_REGEX\n*______________________________________________________________________\n*\n SEGS RELEASE_CONVERSION_AREA\n*\n   MVC   FUNC_NAME,=V(ZCSRLSE)\n   L     R14,CONVERT_HANDLE            return address of code pages\n   ST    R14,MY_P_3                    save in parameter list\n   IF (CLI,DEBUG_MODE,EQ,C'Y')\n     MVC   NUMBER_OF_PARMS,=H'1'\n     MVC   PROGRAM_CALL,=CL8'ZCSRLSE'\n   ENDIF\n   SEGDO CALL_C_FUNCTION\n   IF (CLI,DEBUG_MODE,EQ,C'Y')\n     MVC   MESS_TXT(30),=CL30'RXPCRE2A - rlse convert'\n     XUNPK (R15),4,MESS_TXT+32\n     XUNPK CONVERT_HANDLE,4,MESS_TXT+32\n     SEGDO WRITE_PCREDUMP\n   ENDIF\n*\n SEGE RELEASE_CONVERSION_AREA\n*______________________________________________________________________\n*\n SEGS CALL_C_FUNCTION\n*\n*  parameters from 3 onward are set so just add handle and function\n*\n   IF (CLI,DUMP_CALL,EQ,C'Y')\n     IF (CLI,DEBUG_MODE,EQ,C'Y'),AND,(CLI,PCREDUMP_OPEN,EQ,C'Y')\n       MVC   MESS_TXT(15),=C'RXPCRE2A - CALL'\n       MVC   MESS_TXT+16(8),PROGRAM_CALL\n       XUNPK FUNC_NAME,,MESS_TXT+30\n       SEGDO WRITE_PCREDUMP            write MESS_TXT to PCREDUMP\n       LH    R3,NUMBER_OF_PARMS\n       LA    R4,MY_P_3\n       IF (CFI,R3,GT,0)\n         DO FROM=(R3)\n           XUNPK 0(R4),4,MESS_TXT+11\n           SEGDO WRITE_PCREDUMP        write MESS_TXT to PCREDUMP\n           LA    R4,4(,R4)\n         ENDDO\n       ENDIF\n     ENDIF\n   ENDIF\n   MVI   DUMP_CALL,C' '\n   LA    R1,HANDLE                     address of C environment\n   ST    R1,MY_P_1\n   LA    R1,FUNC_NAME                  function name\n   ST    R1,MY_P_2\n   LA    R1,MY_PARM                    point to parameters\n   L     R15,=V(EDCXHOTU)              call required C function\n   BASR  R14,R15\n   XC    MY_PARM(LEN_MY_PARM),MY_PARM  clear parm list after call\n*\n SEGE CALL_C_FUNCTION\n*______________________________________________________________________\n*\n SEGS NOT_VALID\n*\n*  an error occured so set error message as output from REXX function\n*\n   IF (CLI,ERR_NO,EQ,55)\n     MVC   MESS_TXT(L'INV_COMMAND),INV_COMMAND\n   ELSEIF (CLI,ERR_NO,EQ,56)\n     MVC   MESS_TXT(L'MAX_COM_PIL),MAX_COM_PIL\n   ELSEIF (CLI,ERR_NO,EQ,88)\n     MVC   MESS_TXT(L'DEBUG_ERROR),DEBUG_ERROR\n   ELSEIF (CLI,ERR_NO,EQ,99)\n*    message is already set\n   ELSE    this should never happen\n     MVC   MESS_TXT(L'UN_KNOWN),UN_KNOWN\n     XUNPK ERR_NO,1,MESS_TXT+L'UN_KNOWN\n   ENDIF\n   SEGDO CALL_IRXSAY\n   IF (CLI,C_ENV_SETUP,EQ,C'Y')\n     SEGDO END_C_ENVIRONMENT\n   ENDIF\n   IF (CLI,DEBUG_MODE,EQ,C'Y'),AND,(CLI,PCREDUMP_OPEN,EQ,C'Y')\n     CLOSE ((R9)),MODE=31              close output file\n   ENDIF\n   PRGQUIT RC=8                        get out of program RC=8\n*\n SEGE NOT_VALID\n*______________________________________________________________________\n*\n SEGS WRITE_PCREDUMP\n*\n   PUT   (R9),MESS_TXT                 output text to PCREDUMP\n   MVI   MESS_TXT,C' '                 clear message line\n   MVC   MESS_TXT+1(L'MESS_TXT-1),MESS_TXT\n*\n SEGE WRITE_PCREDUMP\n*______________________________________________________________________\n*\n SEGS OUTPUT_A_VARIABLE\n*\n   LA    R1,=CL8'IRXEXCOM'\n   ST    R1,IX_PARM\n   LA    R6,PARM_AREA\n   USING SHVBLOCK,R6\n   MVC   SHVNEXT,=F'0'\n   MVC   SHVUSER,=F'0'\n   MVI   SHVCODE,SHVSTORE              store a variable\n   MVC   SHVBUFL,=F'0'\n   MVC   SHVNAMA,VAR_NAME_ADDR         variable name\n   MVC   SHVNAML,VAR_NAME_LEN          variable length\n*\n   MVC   SHVVALA,CONV_BACK_PTR         value address\n   MVC   SHVVALL,CONV_BACK_LEN         value length\n   LA    R1,PARM_AREA\n   ST    R1,IX_PARM+12\n   OI    IX_PARM+12,X'80'\n\n   LR    R0,R10                        copy rexx environment addr\n   LA    R1,IX_PARM\n   USING IRXEXTE,15\n   L     15,ENVBLOCK_IRXEXTE\n   L     15,IRXEXCOM                   get addr of variable access\n   DROP  15\n   BASR  14,15                         go set the variable\n*\n   IF (LTR,R15,R15,NZ)\n     MVC   EVALBLOCK_EVDATA(20),=CL20'Error in SET_VAR RC='\n     XUNPK (R15),,EVALBLOCK_EVDATA+20\n     LA    R1,30                       length of error message\n     ST    R1,EVALBLOCK_EVLEN\n     PRGQUIT\n   ENDIF\n*\n SEGE OUTPUT_A_VARIABLE\n*______________________________________________________________________\n*\n SEGS CALL_IRXSAY\n*\n   LA    R1,=CL8'WRITE'\n   ST    R1,MY_P_1\n   LA    R1,MESS_TXT\n   ST    R1,MY_P_8\n   LA    R1,MY_P_8\n   ST    R1,MY_P_2\n   LA    R1,L'MESS_TXT\n   ST    R1,MY_P_9\n   LA    R1,MY_P_9\n   ST    R1,MY_P_3\n   OI    MY_P_3,X'80'\n   L     R0,#SAV_REX+12                rexx environment block addr\n   LA    R1,MY_PARM\n   USING IRXEXTE,15\n   L     15,ENVBLOCK_IRXEXTE\n   L     15,IRXSAY\n   DROP  15\n   BASR  14,15\n   XC    MY_PARM(LEN_MY_PARM),MY_PARM  clear parm list after call\n   IF (LTR,R15,R15,NZ)\n     ST    R15,R_C\n     SEGDO WRITE_LOG\n     MVC   MESS_TXT(L'E_ON_SAY),E_ON_SAY\n     XUNPK R_C,4,MESS_TXT+19\n     SEGDO WRITE_LOG\n   ENDIF\n   MVI   MESS_TXT,C' '\n   MVC   MESS_TXT+1(L'MESS_TXT-1),MESS_TXT\n*\n SEGE CALL_IRXSAY\n*______________________________________________________________________\n*\n               PRGSTAT\n*\nHANDLE         DS    A           address of the C environment\nCONVERT_HANDLE DS    A           address of the conversion data\nCODEPAGE_PTR   DS    A           points to codepage name\nCODEPAGE_LEN   DS    A           length of codepage name\nSUBST_OUT_MAX_LEN    DS    F     pointer to substitute output\nVAR_NAME_ADDR  DS    A           address of rexx variable name\nVAR_NAME_LEN   DS    F           length of rexx variable name\nALL_THE_COMPILES     DS    (MAX_NUM_COMPILES)D   all current compiles\nL_ALL_THE_COMPILES   EQU   *-ALL_THE_COMPILES\nTOT_COMPILES   DS    H\nPCREDUMP_OPEN  DS    CL1         flag dataset open\nINIT_SUBS_DONE DS    CL1\nC_ENV_SETUP    DS    CL1\nDEBUG_MODE     DS    CL1\nE_ON_SAY       DC    C'RXPCRE2A-001 - Return code on SAY='\nDEBUG_ERROR    DC    C'RXPCRE2A-002 - debug specified but DD name PCRED/\n               UMP not allocated'\nINV_COMMAND    DC    C'RXPCRE2A-003 - Invalid command'\nMAX_COM_PIL    DC    C'RXPCRE2A-004 - Max compiles exceeded'\nUN_KNOWN       DC    C'RXPCRE2A-nnn - Unknown error, RC='\n*\nSTKSIZE        DC    F'4096'     stack size\nSTKLOC         DC    F'1'        stack location (0 < 16MB, 1 >= 16MB)\n*\nCOPY_NAME_TEXT MVC   STEM_TEXT(1),2(R4)\nCOPY_CODEPAGE  MVC   MESS_TXT+55(0),0(R1)\n*\nSPACES         DC    CL80' '\n*\n*        Areas for populating rexx stem variables\n*\n                     PRGSTEM PREF=ROOT       for  STEM.0\n                     PRGSTEM PREF=POS             STEM.POS.?\n                     PRGSTEM PREF=NAMED           STEM.NAME.?\n                     PRGSTEM PREF=STRING          STEM.STRING.?\n*\n                     DS    0F          ensure fullword aligned\nPCRE2_CASELESS       DC    X'00000008'\nPCRE2_EXTENDED       DC    X'00000080'\nPCRE2_NOT_EMPTY      DC    X'00000008'\nPCRE2_ANCHORED       DC    X'80000000'\n*\n               LTORG\n*\n               PRGESTAT\n               PRGEND\n               END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "RXPCRE2O": {"ttr": 81, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x018\\x00\\x07\\x01 \\x02\\x0f\\x01 \\x03\\x1f\\x08\\x02\\x02\\x01\\x01i\\x00\\x00\\xe2\\xc4\\xd1\\xd9\\xc7@@@@@'", "ispf": {"version": "01.56", "flags": 0, "createdate": "2020-01-20T00:00:00", "modifydate": "2020-01-31T08:02:07", "lines": 513, "newlines": 361, "modlines": 0, "user": "SDJRG"}, "text": " TITLE 'RXPCRE2O - REXX FUNCTION FOR PERL COMPATIBLE REGEX'\n PRINT GEN\nRXPCRE2O PRGDEF FSEG=MAIN_BIT,REXX=Y\n*______________________________________________________________________\n*\n* This program is used to create an option word (unsigned integer)\n* containing the bit patterns which match the specified options.\n*\n* Version 0.1\n* Contributed by:   John Gateley  January 2020.\n* Copyright (c) 2020, John Gateley.\n* All rights reserved.\n*______________________________________________________________________\n*\n* Redistribution and use in source and binary forms, with or\n* without modification, are permitted provided that the following\n* conditions are met:\n*\n*  1. Redistributions of source code must retain the above\n*  copyright notice, this list of conditions and the following\n*  disclaimer.\n*\n*  2. Redistributions in binary form must reproduce the above\n*  copyright notice, this list of conditions and the following\n*  disclaimer in the documentation and/or other materials\n*  provided with the distribution.\n*\n*  3. Neither the name of the University of Cambridge nor the\n*  names of its contributors may be used to endorse or promote\n*  products derived from this software without specific prior\n*  written permission.\n*\n* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND\n* CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES,\n* INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n* MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n* DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR\n* CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n* SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n* NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n* HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n* CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR\n* OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,\n* EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*______________________________________________________________________\n*\n* This program acts as a REXX function and is designed to be used\n* with the z/OS port of 'PCRE2 - Perl Compatible Regular Expressions'\n* which was created by Ze'ev Atlas.\n*\n* This program was written by John Gateley in January 2020.\n*\n* To assemble these programs you will need to supplied macros and will\n* also need to assemble modules STRINGIT which is used in STRING macro\n* and TRIMIT which is used by the TRIM macro.\n*______________________________________________________________________\n*\n* How it works.\n*\n* This program RXPCRE2O is a rexx function and is used to create\n* option integers for the processing in RXPCRE2.\n*\n*\n* There is one call to the function\n*\n*      r_c     = RXPCRE2O('OP_T','VAR_NAM')\n*\n*    OP_T      the name of a stem variable which contains the options\n*              to be used.\n*    VAR_NAME  the name of a rexx variable which will contain the\n*              resulting option bit values.\n*              This will be 8 bytes of hexadecimal display\n*\n*    op_t.1 = 'PCRE2_DOLLAR_ENDONLY'\n*    op_t.2 = 'PCRE2_DOTALL'\n*    op_t.3 = 'PCRE2_DUPNAMES'\n*    op_t.0 = '3'\n*\n*    Returns 0 if OK\n*            8 if failed - an error message will be writen using IRXSAY\n*______________________________________________________________________\n*\n*  REENTRANT STORAGE\n*\nTABLE_CNT            DS    F\nTABLE_LEN            DS    F\nTABLE_ADR            DS    A\nVAR_NAME_ADR         DS    F\nVAR_NAME_LEN         DS    F\nVAR_NAME             DS    CL20\nVAR_CONTENT          DS    CL8\nSET_THE_OPTIONS      DS    F\nINPUT_VAR_TEXT       DS    CL(L'PCRE_OPTION)\nERR_NO               DS    CL1\n*\n*                    the parameter area used to call irxexcom\nIX_PARM              DS    4F\nPARM_AREA            DS    (SHVBLEN)XL1\n*\n        PRGEDEF\n*\n        USING PCRE_OPTIONS,R4\n        USING SHVBLOCK,R6\n*______________________________________________________________________\n*\n SEGS MAIN_BIT\n*\n   XC    THE_STEM_AREA(THE_STEM_BLOCK_LEN),THE_STEM_AREA\n*\n   SEGDO GET_THE_ARGUMENTS             read both arguments\n*\n   XC    SET_THE_OPTIONS,SET_THE_OPTIONS\n*\n   LA    R1,INPUT_VAR_TEXT             point to variable area\n   ST    R1,THE_STEM_TEXT_ADR          save address\n   LA    R1,L'INPUT_VAR_TEXT           length of variable area\n   ST    R1,THE_STEM_MAX_LEN           save length\n*\n   MVI   THE_STEM_TRIM_VAR,C'N'        do not strip spaces\n*\n   SEGDO COPY_STEM_TO_MEMORY\n*\n   PUSH  USING\nTHIS     USING PCRE_OPTIONS,R8         map DSECT with prefix\n*\n   L     R5,TABLE_CNT                  reload table count\n   L     R8,TABLE_ADR                  point to table\n   BCTR  R5,0                          count - 1\n   IF (LTR,R5,R5,P)                    at least 2 for compare ?\n     DO FROM=(R5)                      for each input option\n       LA    R4,THIS.PCRE_NEXT         point at next in table\n       LR    R3,R5                     copy loop count\n       DO FROM=(R3)\n*        if mixing compile and none compile options\n         IF (CLI,THIS.PCRE_COMPILE,EQ,C'C'),AND,                       /\n               (CLI,PCRE_COMPILE,NE,C'C')\n*          it is not valid\n*          unless they are these types in which case\n           IF (CLC,=C'CMD',EQ,THIS.PCRE_COMPILE),AND,                  /\n               (CLC,=C' MD',EQ,PCRE_COMPILE)\n*            oh! actually it is valid\n           ELSE\n             MVC   MESS_TXT(L'PCRE_OPTION),THIS.PCRE_OPTION\n             MVC   MESS_TXT+40(L'PCRE_OPTION),PCRE_OPTION\n             SEGDO CALL_IRXSAY\n             MVI   ERR_NO,10           dont mix compile/match with sub\n             SEGDO NOT_VALID           quits program\n           ENDIF\n*        if mixing compile and none compile options\n         ELSEIF (CLI,THIS.PCRE_COMPILE,NE,C'C'),AND,                   /\n               (CLI,PCRE_COMPILE,EQ,C'C')\n*          it is not valid\n*          unless they are these types in which case\n           IF (CLC,=C' MD',EQ,THIS.PCRE_COMPILE),AND,                  /\n               (CLC,=C'CMD',EQ,PCRE_COMPILE)\n*            oh! actually it is valid\n           ELSE\n             MVC   MESS_TXT(L'PCRE_OPTION),THIS.PCRE_OPTION\n             MVC   MESS_TXT+40(L'PCRE_OPTION),PCRE_OPTION\n             SEGDO CALL_IRXSAY\n             MVI   ERR_NO,10           dont mix compile/match with sub\n             SEGDO NOT_VALID           quits program\n           ENDIF\n         ENDIF\n         LA    R4,PCRE_NEXT            next in inner loop\n       ENDDO\n       LA    R8,THIS.PCRE_NEXT         next in outer loop\n     ENDDO\n   ENDIF\n*\n   L     R5,TABLE_CNT                  reload table count\n   L     R8,TABLE_ADR                  point to table\n   DO FROM=(R5)                        for each input option\n     OC    SET_THE_OPTIONS,THIS.PCRE_BITS or in this bit setting\n     LA    R8,THIS.PCRE_NEXT           next in loop\n   ENDDO\n*\n   POP   USING\n*\n   XUNPK SET_THE_OPTIONS,4,VAR_CONTENT\n   SEGDO OUTPUT_A_VARIABLE\n*\n   L     R3,TABLE_ADR                  load table address\n   L     R2,TABLE_LEN                  load table total length\n   STORAGE RELEASE,LENGTH=(R2),ADDR=(R3)\n*\n SEGE MAIN_BIT\n*______________________________________________________________________\n*\n SEGS COPY_STEM_TO_MEMORY\n*\n   MVHHI THE_STEM_FUNCTION,21          get STEM max length + count\n   SEGDO CALL_PROCSTEM\n*\n   ZAP   DOUB_WORD,THE_STEM_ZERO_COUNT get number of stems\n   CVB   R5,DOUB_WORD\n   ST    R5,TABLE_CNT                  save table count\n   LR    R2,R5                         count\n   MHI   R2,PCRE_LEN                   muliply by length of DSECT\n   ST    R2,TABLE_LEN                  save total length of table\n   STORAGE OBTAIN,LENGTH=(R2),LOC=BELOW\n   ST    R1,TABLE_ADR                  save table address\n   LR    R8,R1                         point to table\n*\n   PUSH  USING\nTHIS     USING PCRE_OPTIONS,R8         map DSECT with prefix\n*\n   ZAP   THE_STEM_ZERO_COUNT,=P'0'     tell PROCSTEM to start at first\n   DO FROM=(R5)\n     MVI   INPUT_VAR_TEXT,C' '         clear input variable area\n     MVC   INPUT_VAR_TEXT+1(L'INPUT_VAR_TEXT-1),INPUT_VAR_TEXT\n     MVHHI THE_STEM_FUNCTION,5         get stem.? next\n     SEGDO CALL_PROCSTEM\n*\n     LA    R4,PCRE_ALL_OPTIONS         point to all valid options\n     LA    R3,PCRE_ALL_OPTION_COUNT    get count of options\n     DO FROM=(R3)\n     DOEXIT (CLC,PCRE_OPTION,EQ,INPUT_VAR_TEXT)  option matched\n       LA    R4,PCRE_NEXT\n     ENDDO\n     IF (LTR,R3,R3,NP)                 did not find the option\n       MVI   ERR_NO,8                  not a valid option\n       SEGDO NOT_VALID                 quits program\n     ENDIF\n     IF (CLI,PCRE_ZOS,NE,C'Z')         not available on z/OS\n       MVI   ERR_NO,9                  not available of z/OS\n       SEGDO NOT_VALID                 quits program\n     ENDIF\n     MVC   THIS.PCRE_OPTION,INPUT_VAR_TEXT\n     MVC   THIS.PCRE_BITS,PCRE_BITS\n     MVC   THIS.PCRE_FLAGS,PCRE_FLAGS\n     LA    R8,THIS.PCRE_NEXT           point to next available slot\n   ENDDO\n*\n   POP   USING\n*\n SEGE COPY_STEM_TO_MEMORY\n*______________________________________________________________________\n*\n SEGS GET_THE_ARGUMENTS\n*\n*  first argument should be the stem name\n*\n   IF (CLC,ARGTABLE_ARGSTRING_PTR,EQ,=8X'FF')\n     MVI   ERR_NO,1\n     SEGDO NOT_VALID\n   ELSEIF (CLC,ARGTABLE_ARGSTRING_LENGTH,EQ,=F'0')\n     MVI   ERR_NO,2\n     SEGDO NOT_VALID\n   ELSEIF (CLC,ARGTABLE_ARGSTRING_LENGTH,GT,=F'20')\n     MVI   ERR_NO,3                    arbitary max length\n     SEGDO NOT_VALID\n   ENDIF\n   MVC   THE_STEM_NAME_ADR,ARGTABLE_ARGSTRING_PTR\n   MVC   THE_STEM_NAME_LEN,ARGTABLE_ARGSTRING_LENGTH\n*\n*  see if input was 'help' in which case output all options and quit\n*                    HELP\n   IF (CLC,THE_STEM_NAME_LEN,EQ,=F'4')\n     L     R1,THE_STEM_NAME_ADR\n     MVC   INPUT_VAR_TEXT(4),0(R1)     copy parameter\n     OC    INPUT_VAR_TEXT(4),SPACES    ensure uppercase\n     IF (CLC,=C'HELP',EQ,INPUT_VAR_TEXT)\n       SEGDO OUTPUT_ALL_VALID          output all valid\n       PRGQUIT RC=0                    and quit\n     ENDIF\n   ENDIF\n*\n*  second argument should be the output variable name\n*\n   LA    ARG_POINT,ARGTABLE_NEXT       check for environment\n   IF (CLC,ARGTABLE_ARGSTRING_PTR,EQ,=8X'FF')\n     MVI   ERR_NO,4\n     SEGDO NOT_VALID\n   ELSEIF (CLC,ARGTABLE_ARGSTRING_LENGTH,EQ,=F'0')\n     MVI   ERR_NO,5\n     SEGDO NOT_VALID\n   ELSEIF (CLC,ARGTABLE_ARGSTRING_LENGTH,GT,=F'20')\n     MVI   ERR_NO,6                    arbitary max length\n     SEGDO NOT_VALID\n   ENDIF\n   MVC   VAR_NAME_ADR,ARGTABLE_ARGSTRING_PTR\n   MVC   VAR_NAME_LEN,ARGTABLE_ARGSTRING_LENGTH\n*\n   L     R14,VAR_NAME_ADR\n   L     R15,VAR_NAME_LEN\n   BCTR  R15,0\n   MVC   VAR_NAME,SPACES\n   EX    R15,COPY_VAR_NAME\n   OC    VAR_NAME,SPACES               make uppercase\n*\n SEGE GET_THE_ARGUMENTS\n*______________________________________________________________________\n*\n SEGS OUTPUT_A_VARIABLE\n*\n   LA    R1,=CL8'IRXEXCOM'\n   ST    R1,IX_PARM\n   LA    R6,PARM_AREA\n   USING SHVBLOCK,R6\n   MVC   SHVNEXT,=F'0'\n   MVC   SHVUSER,=F'0'\n   MVI   SHVCODE,SHVSTORE              store a variable\n   MVC   SHVBUFL,=F'0'\n   LA    R1,VAR_NAME                   name of variable\n   ST    R1,SHVNAMA\n   MVC   SHVNAML,VAR_NAME_LEN          variable length\n*\n   LA    R1,VAR_CONTENT\n   ST    R1,SHVVALA                    value address\n   MVC   SHVVALL,=F'8'                 value length\n   LA    R1,PARM_AREA\n   ST    R1,IX_PARM+12\n   OI    IX_PARM+12,X'80'\n\n   LR    R0,R10                        copy rexx environment addr\n   LA    R1,IX_PARM\n   USING IRXEXTE,15\n   L     15,ENVBLOCK_IRXEXTE\n   L     15,IRXEXCOM                   get addr of variable access\n   DROP  15\n   BASR  14,15                         go set the variable\n*\n   IF (LTR,R15,R15,NZ)\n     MVC   EVALBLOCK_EVDATA(20),=CL20'Error in SET_VAR RC='\n     XUNPK (R15),,EVALBLOCK_EVDATA+20\n     LA    R1,30                       length of error message\n     ST    R1,EVALBLOCK_EVLEN\n     IF (CLC,TABLE_CNT,NE,=F'0')\n       L     R3,TABLE_ADR              load table address\n       L     R2,TABLE_LEN              load table total length\n       STORAGE RELEASE,LENGTH=(R2),ADDR=(R3)\n     ENDIF\n     PRGQUIT\n*\n   ENDIF\n*\n SEGE OUTPUT_A_VARIABLE\n*______________________________________________________________________\n*\n SEGS CALL_IRXEXCOM\n*\n   LA    R1,PARM_AREA\n   ST    R1,IX_PARM+12\n   OI    IX_PARM+12,X'80'\n   L     R0,#SAV_REX+12                rexx environment block addr\n   LA    R1,IX_PARM\n   USING IRXEXTE,15\n   L     15,ENVBLOCK_IRXEXTE\n   L     15,IRXEXCOM\n   DROP  15\n   BASR  14,15\n*\n SEGE CALL_IRXEXCOM\n*______________________________________________________________________\n*\n SEGS CALL_PROCSTEM\n*\n   LA    R1,THE_STEM_AREA              point to PRGSTEM area INPUT\n   ST    R1,MY_P_1                     save as first parm\n   LA    R1,MY_PARM                    point to parameter list\n   L     R15,=V(PROCSTEM)              get program address\n   BASR  R14,R15                       go and set stem value\n   IF (LTR,R15,R15,NZ)                 error ?\n     ST    R15,R_C                     set return code\n     IF (CLC,TABLE_CNT,NE,=F'0')\n       L     R3,TABLE_ADR              load table address\n       L     R2,TABLE_LEN              load table total length\n       STORAGE RELEASE,LENGTH=(R2),ADDR=(R3)\n     ENDIF\n     PRGQUIT                           QUIT\n   ENDIF\n*\n SEGE CALL_PROCSTEM\n*______________________________________________________________________\n*\n SEGS NOT_VALID\n*\n*  an error occured so set error message as output from REXX function\n*\n   IF (CLI,ERR_NO,EQ,1)\n     MVC   MESS_TXT(L'MESS_1),MESS_1\n   ELSEIF (CLI,ERR_NO,EQ,2)\n     MVC   MESS_TXT(L'MESS_2),MESS_2\n   ELSEIF (CLI,ERR_NO,EQ,3)\n     MVC   MESS_TXT(L'MESS_3),MESS_3\n   ELSEIF (CLI,ERR_NO,EQ,4)\n     MVC   MESS_TXT(L'MESS_4),MESS_4\n   ELSEIF (CLI,ERR_NO,EQ,5)\n     MVC   MESS_TXT(L'MESS_5),MESS_5\n   ELSEIF (CLI,ERR_NO,EQ,6)\n     MVC   MESS_TXT(L'MESS_6),MESS_6\n   ELSEIF (CLI,ERR_NO,EQ,8)\n     MVC   MESS_TXT(L'MESS_8),MESS_8\n     MVC   MESS_TXT+L'MESS_8(L'INPUT_VAR_TEXT),INPUT_VAR_TEXT\n   ELSEIF (CLI,ERR_NO,EQ,9)\n     MVC   MESS_TXT(L'MESS_9),MESS_9\n     MVC   MESS_TXT+L'MESS_9(L'INPUT_VAR_TEXT),INPUT_VAR_TEXT\n   ELSEIF (CLI,ERR_NO,EQ,10)\n     MVC   MESS_TXT(L'MESS_10),MESS_10\n*\n   ELSE    this should never happen\n     MVC   MESS_TXT(L'UN_KNOWN),UN_KNOWN\n     XUNPK ERR_NO,1,MESS_TXT+L'UN_KNOWN\n   ENDIF\n   SEGDO CALL_IRXSAY\n*\n   IF (CLC,TABLE_CNT,NE,=F'0')\n     L     R3,TABLE_ADR                load table address\n     L     R2,TABLE_LEN                load table total length\n     STORAGE RELEASE,LENGTH=(R2),ADDR=(R3)\n   ENDIF\n   PRGQUIT RC=8\n*\n SEGE NOT_VALID\n*______________________________________________________________________\n*\n SEGS OUTPUT_ALL_VALID\n*\n*  this outputs all valid options\n*\n   MVC   MESS_TXT(L'VAL_ID),VAL_ID\n   SEGDO CALL_IRXSAY\n   LA    R4,PCRE_ALL_OPTIONS\n   LA    R3,PCRE_ALL_OPTION_COUNT\n   DO FROM=(R3)\n     IF (CLI,PCRE_ZOS,EQ,C'Z')       available on z/OS\n       MVC   MESS_TXT(L'PCRE_OPTION),PCRE_OPTION\n       MVC   MESS_TXT+L'PCRE_OPTION+1(L'PCRE_FLAGS),PCRE_FLAGS\n       SEGDO CALL_IRXSAY\n     ENDIF\n     LA    R4,PCRE_NEXT\n   ENDDO\n*\n SEGE OUTPUT_ALL_VALID\n*______________________________________________________________________\n*\n SEGS CALL_IRXSAY\n*\n   LA    R1,=CL8'WRITE'\n   ST    R1,MY_P_1\n   LA    R1,MESS_TXT\n   ST    R1,MY_P_8\n   LA    R1,MY_P_8\n   ST    R1,MY_P_2\n   LA    R1,L'MESS_TXT\n   ST    R1,MY_P_9\n   LA    R1,MY_P_9\n   ST    R1,MY_P_3\n   OI    MY_P_3,X'80'\n   L     R0,#SAV_REX+12                rexx environment block addr\n   LA    R1,MY_PARM\n   USING IRXEXTE,15\n   L     15,ENVBLOCK_IRXEXTE\n   L     15,IRXSAY\n   DROP  15\n   BASR  14,15\n   IF (LTR,R15,R15,NZ)\n     ST    R15,R_C\n     SEGDO WRITE_LOG                   write original message\n     MVC   MESS_TXT(L'SAY_ERR),SAY_ERR\n     XUNPK R_C,4,MESS_TXT+19\n     SEGDO WRITE_LOG                   then this error message\n   ENDIF\n   MVI   MESS_TXT,C' '\n   MVC   MESS_TXT+1(L'MESS_TXT-1),MESS_TXT\n*\n SEGE CALL_IRXSAY\n*______________________________________________________________________\n*\n SEGS WRITE_LOG\n*\n*  this does WTO from MESS_TXT and then clears it to spaces\n*\n   WTOX\n*\n SEGE WRITE_LOG\n*______________________________________________________________________\n*\n               PRGSTAT\n*\nCOPY_VAR_NAME  MVC   VAR_NAME(0),0(R14)\n*\n               PRGSTEM PREF=THE_STEM\n*\nSPACES   DC CL20' '\nMESS_1   DC C'RXPCRE2O-001 - stem name not specified'\nMESS_2   DC C'RXPCRE2O-002 - stem name length was 0'\nMESS_3   DC C'RXPCRE2O-003 - stem name greater than 20 bytes'\nMESS_4   DC C'RXPCRE2O-004 - variable name not specified'\nMESS_5   DC C'RXPCRE2O-005 - variable name length was 0'\nMESS_6   DC C'RXPCRE2O-006 - variable name greater than 20 bytes'\nSAY_ERR  DC C'RXPCRE2O-007 - Return code on SAY='\nMESS_8   DC C'RXPCRE2O-008 - option not valid - '\nMESS_9   DC C'RXPCRE2O-009 - option not valid on z/OS - '\nMESS_10  DC C'RXPCRE2O-010 - do not mix compile options with run time'\nUN_KNOWN DC C'RXPCRE2O-nnn - unknown error, RC='\n*\nVAL_ID   DC C'Valid options are :-'\n*\n               LTORG\n*______________________________________________________________________\n*\n*  the following copybook contains all possible options that can be\n*  set when using PCRE2 and a DSECT which maps them.\n*\n         COPY  RXPC2CPY\n*______________________________________________________________________\n*\n               PRGESTAT\n               PRGEND\n               END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "RXPC2CPY": {"ttr": 85, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x06\\x00\\x08\\x01 \\x01\\x7f\\x01 \\x13\\x0f#R\\x00a\\x00F\\x00\\x00\\xe9\\xc1\\xe3\\xd3\\xc1\\xe2\\xf1@@@'", "ispf": {"version": "01.06", "flags": 0, "createdate": "2020-01-17T00:00:00", "modifydate": "2020-05-09T23:52:08", "lines": 97, "newlines": 70, "modlines": 0, "user": "ZATLAS1"}, "text": "*   This copybook contains all the options that can be used in PCRE2.\n*   DSECT PCRE_OPTIONS is included which matches the definitions,\n*   see the end of this copybook.\n*\nPCRE_ALL_OPTIONS     DS    0F\n*     Option\n*                                           bit_pattern\n*                                                         Compile\n*                                                          Match\n*                                                           DFA_match\n*                                                            Substitite\n*                                                             Context\n*                                                              ZOS\n DC C'PCRE2_ANCHORED                      ',X'80000000',C'CMD  Z'\nPCRE_OPTION_LEN      EQU   *-PCRE_ALL_OPTIONS\n DC C'PCRE2_NO_UTF_CHECK                  ',X'40000000',C'CMD  Z'\n DC C'PCRE2_ENDANCHORED                   ',X'20000000',C'CMD  Z'\n DC C'PCRE2_ALLOW_EMPTY_CLASS             ',X'00000001',C'C    Z'\n DC C'PCRE2_ALT_BSUX                      ',X'00000002',C'C    Z'\n DC C'PCRE2_AUTO_CALLOUT                  ',X'00000004',C'C    Z'\n DC C'PCRE2_CASELESS                      ',X'00000008',C'C    Z'\n DC C'PCRE2_DOLLAR_ENDONLY                ',X'00000010',C'C    Z'\n DC C'PCRE2_DOTALL                        ',X'00000020',C'C    Z'\n DC C'PCRE2_DUPNAMES                      ',X'00000040',C'C    Z'\n DC C'PCRE2_EXTENDED                      ',X'00000080',C'C    Z'\n DC C'PCRE2_FIRSTLINE                     ',X'00000100',C'C    Z'\n DC C'PCRE2_MATCH_UNSET_BACKREF           ',X'00000200',C'C    Z'\n DC C'PCRE2_MULTILINE                     ',X'00000400',C'C    Z'\n DC C'PCRE2_NEVER_UCP                     ',X'00000800',C'C    Z'\n DC C'PCRE2_NEVER_UTF                     ',X'00001000',C'C    Z'\n DC C'PCRE2_NO_AUTO_CAPTURE               ',X'00002000',C'C    Z'\n DC C'PCRE2_NO_AUTO_POSSESS               ',X'00004000',C'C    Z'\n DC C'PCRE2_NO_DOTSTAR_ANCHOR             ',X'00008000',C'C    Z'\n DC C'PCRE2_NO_START_OPTIMIZE             ',X'00010000',C'C    Z'\n DC C'PCRE2_UCP                           ',X'00020000',C'C     '\n DC C'PCRE2_UNGREEDY                      ',X'00040000',C'C    Z'\n DC C'PCRE2_UTF                           ',X'00080000',C'C     '\n DC C'PCRE2_NEVER_BACKSLASH_C             ',X'00100000',C'C    Z'\n DC C'PCRE2_ALT_CIRCUMFLEX                ',X'00200000',C'C    Z'\n DC C'PCRE2_ALT_VERBNAMES                 ',X'00400000',C'C    Z'\n DC C'PCRE2_USE_OFFSET_LIMIT              ',X'00800000',C'C    Z'\n DC C'PCRE2_EXTENDED_MORE                 ',X'01000000',C'C    Z'\n DC C'PCRE2_LITERAL                       ',X'02000000',C'C    Z'\n DC C'PCRE2_MATCH_INVALID_UTF             ',X'04000000',C'C     '\n DC C'PCRE2_EXTRA_ALLOW_SURROGATE_ESCAPES ',X'00000001',C'C     '\n DC C'PCRE2_EXTRA_BAD_ESCAPE_IS_LITERAL   ',X'00000002',C'C     '\n DC C'PCRE2_EXTRA_MATCH_WORD              ',X'00000004',C'C     '\n DC C'PCRE2_EXTRA_MATCH_LINE              ',X'00000008',C'C     '\n DC C'PCRE2_EXTRA_ESCAPED_CR_IS_LF        ',X'00000010',C'C     '\n DC C'PCRE2_EXTRA_ALT_BSUX                ',X'00000020',C'C     '\n DC C'PCRE2_JIT_COMPLETE                  ',X'00000001',C'C     '\n DC C'PCRE2_JIT_PARTIAL_SOFT              ',X'00000002',C'C     '\n DC C'PCRE2_JIT_PARTIAL_HARD              ',X'00000004',C'C     '\n DC C'PCRE2_JIT_INVALID_UTF               ',X'00000100',C'C     '\n DC C'PCRE2_NOTBOL                        ',X'00000001',C' MDS Z'\n DC C'PCRE2_NOTEOL                        ',X'00000002',C' MDS Z'\n DC C'PCRE2_NOTEMPTY                      ',X'00000004',C' MDS Z'\n DC C'PCRE2_NOTEMPTY_ATSTART              ',X'00000008',C' MDS Z'\n DC C'PCRE2_PARTIAL_SOFT                  ',X'00000010',C' MDS Z'\n DC C'PCRE2_PARTIAL_HARD                  ',X'00000020',C' MDS Z'\n DC C'PCRE2_DFA_RESTART                   ',X'00000040',C'  D   '\n DC C'PCRE2_DFA_SHORTEST                  ',X'00000080',C'  D   '\n DC C'PCRE2_SUBSTITUTE_GLOBAL             ',X'00000100',C'   S Z'\n DC C'PCRE2_SUBSTITUTE_EXTENDED           ',X'00000200',C'   S Z'\n DC C'PCRE2_SUBSTITUTE_UNSET_EMPTY        ',X'00000400',C'   S Z'\n DC C'PCRE2_SUBSTITUTE_UNKNOWN_UNSET      ',X'00000800',C'   S Z'\n DC C'PCRE2_SUBSTITUTE_OVERFLOW_LENGTH    ',X'00001000',C'   S Z'\n DC C'PCRE2_NO_JIT                        ',X'00002000',C' M S Z'\n DC C'PCRE2_COPY_MATCHED_SUBJECT          ',X'00004000',C' MDS Z'\n DC C'PCRE2_CONVERT_UTF                   ',X'00000001',C'    C '\n DC C'PCRE2_CONVERT_NO_UTF_CHECK          ',X'00000002',C'    C '\n DC C'PCRE2_CONVERT_POSIX_BASIC           ',X'00000004',C'    C '\n DC C'PCRE2_CONVERT_POSIX_EXTENDED        ',X'00000008',C'    C '\n DC C'PCRE2_CONVERT_GLOB                  ',X'00000010',C'    C '\n DC C'PCRE2_CONVERT_GLOB_NO_WILD_SEPARATOR',X'00000030',C'    C '\n DC C'PCRE2_CONVERT_GLOB_NO_STARSTAR      ',X'00000050',C'    C '\n DC C'PCRE2_SUBSTITUTE_LITERALARSTAR      ',X'00008000',C'   S Z'\n DC C'PCRE2_SUBSTITUTE_MATCHEDARSTAR      ',X'00010000',C'   S Z'\n DC C'PCRE2_SUBSTITUTE_REPLACEMENT_ONLY   ',X'00020000',C'   S Z'\n*\n*  calculate count of all options, total length / item length\n*\nPCRE_ALL_OPTION_COUNT      EQU   (*-PCRE_ALL_OPTIONS)/PCRE_OPTION_LEN\n*\nPCRE_OPTIONS     DSECT\nPCRE_OPTION      DS    CL36            text value of the option\nPCRE_BITS        DS    XL4             bit setting\nPCRE_FLAGS       DS    0CL6            6 flag bytes showing where used\nPCRE_COMPILE     DS    CL1             can use in compile\nPCRE_MATCH       DS    CL1             can use in match\nPCRE_DFA_MATCH   DS    CL1             can use in DFA match\nPCRE_SUBSTITUTE  DS    CL1             can use in substitute\nPCRE_CONTEXT     DS    CL1             can use in context\nPCRE_ZOS         DS    CL1             valid in z/OS\nPCRE_NEXT        EQU   *               address of next option\nPCRE_LEN         EQU   *-PCRE_OPTIONS  length of DSECT\n*\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "STRINGIT": {"ttr": 39, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00W\\x01\\x17\\x00\\x9f\\x01\\x17\\x00\\x9f\\x145\\x01w\\x01w\\x00\\x00\\xc7\\xc1\\xe3\\xc5\\xd3\\xc5\\xe8@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2017-01-09T00:00:00", "modifydate": "2017-01-09T14:35:57", "lines": 375, "newlines": 375, "modlines": 0, "user": "GATELEY"}, "text": "STRINGIT CSECT\nSTRINGIT AMODE 31\nSTRINGIT RMODE ANY\n*\n*   This program is used by the STRING macro to convert fields\n*   to the required format and to put them into the output area.\n*\n*   Note that on return from this program register 1 contains the\n*   address of the byte in the output area after the strung data.\n*\n*   Input parameters generated by the STRING macro are\n*     1, address of a series of format indicators terminated by x'FF'\n*     2, address of output area\n*     3, length of the output area\n*     4, address of a 32 byte work area\n*\n*     5, address of input field\n*     6, length of input field\n*\n*   Parameters 4 and 5 repeat for as many indicators as there are in\n*   the list pointed to by parameter 1\n*\n*   note that this program does not have it's own save area because\n*   it does not call anything and it needs to be re-entrant\n*\n         SAVE  (14,12)                   * save callers registers\n         PRINT OFF\n         YREGS\n         PRINT ON\n         LR    R12,R15                   * copy base address\n         USING STRINGIT,R12\n         LR    R10,R1                    * copy parameter address\n         LM    R3,R6,0(R10)              * load first 4 parameters\n*                              R3    string of output indicators\n*                              R4    address of output field\n*                              R5    length of output field\n*                              R6    work area in caller\n         USING WORKAREA,R6\n         MVC   GLOB_IND,0(R3)        * copy global indicators\n         LA    R3,L'GLOB_IND(,R3)    * point passed global indicators\n         AR    R5,R4                 * point after output field\n         LA    R7,16(,R10)     R7    * point to first address/length\n*\n         CLI   PAD_FRST,C'0'\n         BNH   GO_AGAIN              * no initial pad char\n         PACK  DOUB_WORD,PAD_FRST\n         CVB   R1,DOUB_WORD\n         LA    R4,0(R1,R4)           * point passed initial pad char\n*\nGO_AGAIN DS    0H\n         LM    R8,R9,0(R7)           Get details of next field\n*\n*        if the length in R9 is negative it means that R8 contains\n*        the value to be displayed not the address of the value\n*\n         LTR   R9,R9                     * test R9\n         BP    IS_POS                    * if positive then use it\n         LPR   R9,R9                     * make positive\n         ST    R8,FULL_WORD              * save 32 bit value\n         LA    R8,FULL_WORD              * and point to it\n*\nIS_POS   DS    0H\n*\n         CLI   0(R3),C'X'                * Hex output required\n         BE    HEX_OUT\n*\n         CLI   0(R3),C'B'                * Binary output required\n         BE    BIN_OUT\n*\n         CLI   0(R3),C'P'                * Pack output required\n         BE    PACK_OUT\n*\n         CLI   0(R3),C'I'                * Integer output required\n         BE    INT_OUT\n*\n         CLI   0(R3),C'U'                * Unsigned integer required\n         BE    UINT_OUT\n*\n         CLI   0(R3),C'S'                * Small Int output required\n         BE    SINT_OUT\n*\n         CLI   0(R3),C'V'                * Small unsigned int required\n         BE    VINT_OUT\n*\n*        assume it must be character\n*\n*        Just copy the character value to the output area\n*\nCHAR_OUT DS    0H\n         LA    R1,0(R9,R4)               * point after receiving\n         CR    R1,R5                     * is the output full\n         BNL   OVERFLOW                  * yes error\n*\n         BCTR  R9,0                      * -1 for execute\n         EX    R9,MVC_IT                 * execute the move\n         LA    R4,1(R9,R4)               * point past data copied\n         B     DONE_IT\n*\n*        Take the value and convert to hexadecimal display\n*\nHEX_OUT  DS    0H\n         LR    R2,R9                     * copy sending length\n         SLL   R2,1                      * multiply by 2\n         LA    R1,0(R2,R4)               * point after receiving\n         CR    R1,R5                     * is the output full\n         BNL   OVERFLOW                  * yes error\n*\nHEX_OUT1 DS    0H\n         MVC   WORK2(1),0(R8)            * copy one byte\n         UNPK  WORK3,WORK2               * UNPK two bytes to three\n         TR    WORK3(2),TR_TAB-240       * convert to displayable\n         MVC   0(2,R4),WORK3             * copy to receiver\n         LA    R4,2(,R4)                 * move past output bytes\n         LA    R8,1(,R8)                 * move past input byte\n         BCT   R9,HEX_OUT1               * do next byte\n         B     DONE_IT\n*\n*        Take the value and convert to binary display\n*        This puts the byte into the low byte of register 1 and then\n*        for each iteration of the inner loop moves the next bit into\n*        the low bit of byte three of the register and stores it.\n*        So as the loop progresses the bit values become bytes in\n*        the output string.\n*\nBIN_OUT  DS    0H\n         LR    R2,R9                     * copy sending length\n         SLL   R2,3                      * multiply by 8\n         LA    R1,0(R2,R4)               * point after receiving\n         CR    R1,R5                     * is the output full\n         BNL   OVERFLOW                  * yes error\n*\nBIN_OUT1 DS    0H\n         IC    R1,0(R8)                  * get a byte\n         LR    R14,R4                    * copy output address\n         LA    R15,8                     * 8 bits to a byte\n*\nBIN_OUT2 DS    0H\n         SLA   R1,1                      * slide left 1 bit\n         STCM  R1,2,0(R14)               * store third byte\n         NI    0(R14),1                  * switch of all but right bit\n         LA    R14,1(,R14)               * next output byte\n         BCT   R15,BIN_OUT2              * process next bit\n*\n         OC    0(8,R4),ZONES             * make zoned decimal\n         LA    R4,8(,R4)                 * move past output bytes\n         LA    R8,1(,R8)                 * move past input byte\n         BCT   R9,BIN_OUT1               * do next byte\n         B     DONE_IT\n*\n*        Input is packed convert to numeric display\n*\nPACK_OUT DS    0H\n         LR    R2,R9                     * copy sending length\n         SLL   R2,1                      * multiply by 2\n         LA    R1,0(R2,R4)               * point after receiving\n         CR    R1,R5                     * is the output full\n         BNL   OVERFLOW                  * yes error\n*\n         LR    R1,R9                     * get length of field\n         BCTR  R1,0                      * less 1 for execute\n         LR    R15,R1                    * copy for CP\n         SLL   R15,4                     * left one nibble\n         LR    R2,R9                     * get length of field\n         BCTR  R2,0                      * subtact for EX and sign\n         SLL   R2,1                      * multiply by 2\n         LA    R14,0(R2,R4)              * position to last digit\n         SLL   R2,4                      * left one nibble\n         OR    R1,R2                     * merge lengths\n         EX    R1,UNPK_IT                * unpack data\n         OI    0(R14),X'F0'              * make last digit numeric\n         EX    R15,CP_IT                 * check if negative\n         BL    P_NEG                     * branch negative\n         MVI   1(R14),C'+'\n         B     P_DONE\nP_NEG    DS    0H\n         MVI   1(R14),C'-'\nP_DONE   DS    0H\n*\n*        the following code is to remove leading zeroes, I know I\n*        could have built an edit pattern and executed an edit\n*        instruction but I thought this was easier. Also having a pad\n*        character would increase the size of the output field.\n*\n         CLI   NUM_ZERO,C'Y'             * show leading zeroes\n         BE    P_DONEX                   * they are there\n         LR    R1,R4                     * get address of output\n         LR    R2,R9                     * get length of field\n         BCTR  R2,0                      * subtract 1\n         SLL   R2,1                      * multiply by 2\nP_CHK0   CLI   0(R1),C'0'                * is this byte zero\n         BNE   P_DONEX                   * no so job done\n         MVI   0(R1),C' '                * blank it\n         LA    R1,1(,R1)                 * next byte\n         BCT   R2,P_CHK0                 * check next\nP_DONEX  DS    0H\n         LA    R4,2(,R14)                * move past output bytes\n         B     DONE_IT\n*\n*        Input is integer convert to numeric display\n*\nINT_OUT  DS    0H\n         LA    R1,11(,R4)                * point after receiving\n         CR    R1,R5                     * is the output full\n         BNL   OVERFLOW                  * yes error\n*\n         L     R1,0(R8)                  * get integer value\n         CVD   R1,DOUB_WORD\n         CP    DOUB_WORD,=P'0'\n         BL    I_NEG\n         MVI   10(R4),C'+'\n         B     I_DONE\nI_NEG    DS    0H\n         MVI   10(R4),C'-'\nI_DONE   DS    0H\n         OI    DOUB_WORD+7,X'0F'\n         UNPK  0(10,R4),DOUB_WORD\n         CLI   NUM_ZERO,C'Y'             * show leading zeroes\n         BE    I_DONEX                   * they are there\n         LR    R1,R4                     * get address of output\n         LA    R2,9                      * get length to check\nI_CHK0   CLI   0(R1),C'0'                * is this byte zero\n         BNE   I_DONEX                   * no so job done\n         MVI   0(R1),C' '                * blank it\n         LA    R1,1(,R1)                 * next byte\n         BCT   R2,I_CHK0                 * check next\nI_DONEX  DS    0H\n         LA    R4,11(,R4)                * move past output bytes\n         B     DONE_IT\n*\n*        Input is un-signed integer convert to numeric display\n*\nUINT_OUT DS    0H\n         LA    R1,10(,R4)                * point after receiving\n         CR    R1,R5                     * is the output full\n         BNL   OVERFLOW                  * yes error\n*\n         L     R1,0(R8)                  * get integer value\n         SRL   R1,1                      * divide by 2\n         CVD   R1,DOUB_WORD              * convert to decimal\n         MP    DOUB_WORD,=P'2'           * multiply by 2\n         TM    3(R8),X'01'               * was low bit on\n         BZ    U_DONE\n         AP    DOUB_WORD,=P'1'           * add the one back in\nU_DONE   DS    0H\n         OI    DOUB_WORD+7,X'0F'         * set the sign\n         UNPK  0(10,R4),DOUB_WORD        * unpack the value\n         CLI   NUM_ZERO,C'Y'             * show leading zeroes\n         BE    U_DONEX                   * they are there\n         LR    R1,R4                     * get address of output\n         LA    R2,9                      * get length to check\nU_CHK0   CLI   0(R1),C'0'                * is this byte zero\n         BNE   U_DONEX                   * no so job done\n         MVI   0(R1),C' '                * blank it\n         LA    R1,1(,R1)                 * next byte\n         BCT   R2,U_CHK0                 * check next\nU_DONEX  DS    0H\n         LA    R4,10(,R4)                * move past output bytes\n         B     DONE_IT\n*\n*        Input is small integer convert to numeric display\n*\nSINT_OUT DS    0H\n         LA    R1,6(,R4)                 * point after receiving\n         CR    R1,R5                     * is the output full\n         BNL   OVERFLOW                  * yes error\n*\n         LH    R1,0(R8)                  * get small integer value\n         CVD   R1,DOUB_WORD\n         CP    DOUB_WORD,=P'0'\n         BL    S_NEG\n         MVI   5(R4),C'+'\n         B     S_DONE\nS_NEG    DS    0H\n         MVI   5(R4),C'-'\nS_DONE   DS    0H\n         OI    DOUB_WORD+7,X'0F'\n         UNPK  0(5,R4),DOUB_WORD\n         CLI   NUM_ZERO,C'Y'             * show leading zeroes\n         BE    S_DONEX                   * they are there\n         LR    R1,R4                     * get address of output\n         LA    R2,4                      * get length to check\nS_CHK0   CLI   0(R1),C'0'                * is this byte zero\n         BNE   S_DONEX                   * no so job done\n         MVI   0(R1),C' '                * blank it\n         LA    R1,1(,R1)                 * next byte\n         BCT   R2,S_CHK0                 * check next\nS_DONEX  DS    0H\n         LA    R4,6(,R4)                 * move past output bytes\n         B     DONE_IT\n*\n*        Input is un-signed small integer convert to numeric display\n*\nVINT_OUT DS    0H\n         LA    R1,5(,R4)                 * point after receiving\n         CR    R1,R5                     * is the output full\n         BNL   OVERFLOW                  * yes error\n*\n         ICM   R1,3,0(R8)                * get small unsigned int val\n         CVD   R1,DOUB_WORD\n         OI    DOUB_WORD+7,X'0F'\n         UNPK  0(5,R4),DOUB_WORD\n         CLI   NUM_ZERO,C'Y'             * show leading zeroes\n         BE    V_DONEX                   * they are there\n         LR    R1,R4                     * get address of output\n         LA    R2,4                      * get length to check\nV_CHK0   CLI   0(R4),C'0'                * is this byte zero\n         BNE   V_DONEX                   * no so job done\n         MVI   0(R1),C' '                * blank it\n         LA    R1,1(,R1)                 * next byte\n         BCT   R2,V_CHK0                 * check next\nV_DONEX  DS    0H\n         LA    R4,5(,R4)                 * move past output bytes\n         B     DONE_IT\n*\n*        Processed that pair of address/length values - any more\n*\nDONE_IT  DS    0H\n         LA    R3,1(,R3)                 * point to next indicator\n         CLI   0(R3),X'FF'               * finished ?\n         BE    GO_BACK                   * then goback\n*\n         LA    R7,8(,R7)                 * next pair of addresses\n         CLI   PAD_DING,C'Y'             * any pad characted ?\n         BNE   GO_AGAIN                  * not so go again\n         MVC   0(1,R4),PAD_DING+1        * copy pad character\n         LA    R4,1(,R4)                 * jump past pad\n         B     GO_AGAIN                  * process next\n*\n*        Return to calling program setting R1 to the output byte after\n*        the last byte used.\n*\nGO_BACK  DS    0H\n         ST    R4,4(,R10)                * save current output address\n*                                        * in parameter list\n         LM    R14,R12,12(R13)           * restore callers registers\n         XR    15,15                     * set return code\n         L     R1,4(,R1)                 * retrieve current output adr\n*                                        * from parameter list\n         BR    R14                       * return to caller\n*********\n*\n* error routine\n*\n* There is no room in the output area for the input value so abend\n*\nOVERFLOW DS    0H\n         WTO   'STRINGIT - output overflow detected',                  /\n               ROUTCDE=11,MCSFLAG=HRDCPY\n         ABEND 500,DUMP,STEP             * ,REASON=1\n*********\n*\n* storage\n*\nWORKAREA       DSECT\nDOUB_WORD      DS    D\nFULL_WORD      DS    F\nWORK2          DS    CL2\nWORK3          DS    CL3\nGLOB_IND       DS    CL15\n               ORG   GLOB_IND\nPAD_DING       DS    CL2             * pad details  (Y/N + value)\nPAD_FRST       DS    CL1             * pad first value   (numeric)\nNUM_ZERO       DS    CL1             * output numeric leading zeroes\n               ORG\n*\nSTRINGIT       CSECT\nZONES          DC    C'00000000'\nTR_TAB         DC    C'0123456789ABCDEF'\nMVC_IT         MVC   0(1,R4),0(R8)\nUNPK_IT        UNPK  0(1,R4),0(1,R8)\nCP_IT          CP    0(1,R8),=P'0'\n*\n               LTORG\n*\n               END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "TRIMIT": {"ttr": 73, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x10\\x01 \\x02/\\x01 \\x02/\\x074\\x00f\\x00f\\x00\\x00\\xe2\\xc4\\xd1\\xd9\\xc7@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2020-01-22T00:00:00", "modifydate": "2020-01-22T07:34:10", "lines": 102, "newlines": 102, "modlines": 0, "user": "SDJRG"}, "text": "TRIMIT   CSECT\nTRIMIT   AMODE 31\nTRIMIT   RMODE ANY\n*\n*   This program removes leading and extra blanks from a field\n*   so that         '  some  text    in    a  field       x'\n*   becomes         'some text in a field x                '\n*\n*   Optionally, all blanks can be removed from the field by\n*   specifying ALL=Y in the TRIM macro resulting in\n*                   'sometextinafieldx                     '\n*\n*   On return R15 contains the number of occupied bytes\n*\n*   Input parameters generated by the TRIM macro are\n*     1, address of a string which should be trimmed\n*     2, length of the string\n*     3,  0    only remove repeated spaces\n*        >0    remove all spaces\n*\n         SAVE  (14,12)                 save callers registers\n         PRINT OFF\n         YREGS\n         PRINT ON\n         LR    R12,R15                 copy base address\n         USING TRIMIT,R12\n         LR    R9,R1                   copy parameter address\n         LM    R4,R6,0(R9)             get address, length and ind\n         LA    R3,0(R4,R5)             point after string\n         BCTR  R3,0                    point at last byte\n*\n         CHI   R6,0                    if positive\n         BH    TRIM_ALL                trim all blanks\n*\n*  remove repeated spaces\n*\n         LA    R6,1                    flag next blank to be removed\nSTRTLOOP LR    R7,R5                   copy the length\n         BCTR  R7,0                    subtract 1 for remaining length\n         LR    R2,R7                   copy as inner loop count\n         BCTR  R7,0                    subtract 1 for execute\nCOMPARE  CLI   0(R4),C' '              check if this byte blank\n         BNE   SETNO                   no so set flag off\n         CHI   R6,1                    is flag on\n         BNE   SETYES                  no so set flag on\n         LTR   R7,R7                   test remaining length\n         BM    ENDLOOP                 negative then finish\n         EX    R7,SLIDE_LEFT           slide bytes left\n         MVI   0(R3),C' '              blank the last byte\n         BCT   R2,COMPARE              loop to go and test again\n         B     ENDLOOP                 branch past execute to end\nSETYES   LA    R6,1                    flag next blank to be removed\n         B     LOOPIT                  go and loop\nSETNO    LA    R6,0                    flag next blank to be ignored\nLOOPIT   LA    R4,1(,R4)               next byte in field\n         BCT   R5,STRTLOOP             loop to check next byte\n         B     ENDLOOP\n*\n*  remove all spaces\n*\nTRIM_ALL DS    0H\n*\nSTRTLOO2 LR    R7,R5                   copy the length\n         BCTR  R7,0                    subtract 1 for remaining length\n         LR    R2,R7                   copy as inner loop count\n         BCTR  R7,0                    subtract 1 for execute\nCOMPARE2 CLI   0(R4),C' '              check if this byte blank\n         BNE   LOOPIT2                 no so set flag off\n         LTR   R7,R7                   test remaining length\n         BM    ENDLOOP                 negative then finish\n         EX    R7,SLIDE_LEFT           slide bytes left\n         MVI   0(R3),C' '              blank the last byte\n         BCT   R2,COMPARE2             loop to go and test again\n         B     ENDLOOP                 branch past execute to end\nLOOPIT2  LA    R4,1(,R4)               next byte in field\n         BCT   R5,STRTLOO2             loop to check next byte\n*\n*  trim accomplished\n*\nENDLOOP  DS    0H\n*\n*  now get count of occupied bytes\n*\n         LR    R4,R3                   point at last byte\n         L     R5,4(,R9)               get length\nLOOP2    DS    0H\n         CLI   0(R4),C' '              is the byte blank\n         BNE   ENDLOOP2                no so quit\n         BCTR  R4,0                    point to previous byte\n         BCT   R5,LOOP2                loop until 0\nENDLOOP2 DS    0H\n*        R5 now has the occupied byte count\n         ST    R5,4(,R9)               put count in parameter list\n*\nGO_BACK  LM    R14,R12,12(R13)         restore callers registers\n         L     R15,4(,R1)              load occupied byte count\n         BR    R14                     return to caller\n*\nSLIDE_LEFT     MVC   0(0,R4),1(R4)     sliding move instruction\n*\n         LTORG\n         END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT939/CBT.V500.FILE939.PDS/ASM.xmi", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT939/CBT.V500.FILE939.PDS", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}