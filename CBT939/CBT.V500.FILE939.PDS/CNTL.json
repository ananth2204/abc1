{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "ZATLAS1", "INMTNODE": "A", "INMTUID": "ZATLAS1", "INMFTIME": "20200906020714000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 399360, "INMDSORG": "PO", "INMTYPE": "Data Library", "INMLRECL": 80, "INMBLKSZ": 32720, "INMRECFM": "FB", "INMDIR": 1, "INMDSNAM": "ZATLAS1.PCRE2.CNTLLIB", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 399360, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 399360, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"ZATLAS1.PCRE2.CNTLLIB": {"COPYR1": {"type": "PDSE", "DS1DSORG": 512, "DS1BLKL": 32720, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 8, "DVACLASS": 32, "DVAUNIT": 0, "DVAMAXRC": 32760, "DVACYL": 256, "DVATRK": 256, "DVATRKLN": 65535, "DVAOVHD": 0, "num_header_records": 0}, "COPYR2": {"deb": "b'\\x03\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x00\\x00\\x00\\x04\\x00\\x00\\x00'", "extents": ["b'\\x03\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x00\\x00\\x00\\x04\\x00\\x00\\x00'", "b'\\x00\\rXH\\x00\\x00\\x00\\x00\\x00\\x00\\x00~\\x00\\xff\\x7f\\x00'", "b'\\x00\\rXH\\x00\\x00\\x00\\x7f\\x00\\x00\\x00\\xfd\\x00\\xff\\x7f\\x00'", "b'\\x00\\rXH\\x00\\x00\\x00\\xfe\\x00\\x00\\x00\\xff\\x00\\xff\\x02\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$INSTALL": {"ttr": 277, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\t\\x00R\\x01 \\x15\\x9f\\x01 \\x16?#Y\\x00\\x88\\x00\\x07\\x00\\x00\\xe9\\xc1\\xe3\\xd3\\xc1\\xe2\\xf1@@@'", "ispf": {"version": "01.09", "flags": 0, "createdate": "2020-06-07T00:00:00", "modifydate": "2020-06-11T23:59:52", "lines": 136, "newlines": 7, "modlines": 0, "user": "ZATLAS1"}, "text": "/* this rexx exec is expected to be invoked by the EXEC command\n   thus:\n\n   EXec 'dsname($INSTALL)'\n\n   Prompting will occur for hlq and optional volser.\n\n   and it will then issue the TSO RECEIVE command for the\n   the following members to create these new data sets:\n\n   Member       Dataset\n   ASM          hlq.ASM\n   CNTL         hlq.CNTL\n   COB          hlq.COB\n   C14MACLB     hlq.C14MACLB\n   JCL          hlq.JCL\n   LOADLIB      hlq.LOADLIB\n   SRCE         hlq.SRCE\n   TESTLIB      hlq.TESTLIB\n\n   You will then need to copy these datasets/members into\n   datasets for production use.\n\n   After these data sets are created several of the members\n   of this install data set will be browsed.\n   */\n\n  parse source x1 x2 x3 x4 dsn .\n\n  if dsn = '?' then do\n    say 'This exec must be executed via EX lib($install) EX, try again.'\n    exit 8\n  end\n\n  x = PROMPT(\"ON\") /* enable prompting */\n\n  say \"Enter desired hlq for target data sets\",\n    \"(default is\" sysvar(\"syspref\")\".PCRE2.NEW):\"\n  pull hlq\n  hlq = strip(hlq)\n\n  if hlq = \"\" then hlq = sysvar(\"syspref\")\".PCRE2.NEW\"\n  hlq = translate(hlq)\n\n  say \"Enter optional volser for target data sets\",\n    \"default is to allow standard allocation to\",\n    \"find a volume.\"\n  pull volser\n  volser = strip(volser)\n\n  say \"Enter optional SYSOUT class for RECEIVE messages,\" ,\n    \"a null SYSOUT class is recommended.\"\n  pull sysout\n  sysout = strip(sysout)\n  if sysout <> \"\" then sys = \"sysout(\"sysout\")\"\n  else sys = \"\"\n\n  if volser <> \"\" then vol = \"vol(\"volser\")\"\n  else vol = \"\"\n\n  Say \"Using HLQ:\" hlq\n  if vol <> \"\" then\n  Say \"Using Volser:\" volser\n\n/* ----------------------------------------------- *\n * Check for an ISPF environment and then check to *\n * see if the receive target datasets exist. If so *\n * then compress  them before the receive.         *\n * ----------------------------------------------- */\n  if sysvar('sysispf') = \"ACTIVE\" then do\n    Address ISPEXEC\n    call do_comp   \"'\"hlq\".ASM'\"\n    call do_comp   \"'\"hlq\".CNTL'\"\n    call do_comp   \"'\"hlq\".COB'\"\n    call do_comp   \"'\"hlq\".C14MACLB'\"\n    call do_comp   \"'\"hlq\".JCL'\"\n    call do_comp   \"'\"hlq\".LOADLIB'\"\n    call do_comp   \"'\"hlq\".SRCE'\"\n    call do_comp   \"'\"hlq\".TESTLIB'\"\n    Address TSO\n  end\n\n/* ------------------------------------------------------------ *\n * Process the TSO RECEIVE command on all the pertinent members *\n * ------------------------------------------------------------ */\n  queue \"dsn('\"hlq\".asm')\" vol sys\n  \"Receive inds('\"dsn\"(asm)')\"\n  queue \"dsn('\"hlq\".CNTL')\" vol sys\n  \"Receive inds('\"dsn\"(cntl)')\"\n  queue \"dsn('\"hlq\".COB')\" vol sys\n  \"Receive inds('\"dsn\"(cob)')\"\n  queue \"dsn('\"hlq\".C14MACLB')\" vol sys\n  \"Receive inds('\"dsn\"(c14maclb)')\"\n  queue \"dsn('\"hlq\".JCL')\" vol sys\n  \"Receive inds('\"dsn\"(jcl)')\"\n  queue \"dsn('\"hlq\".LOADLIB')\" vol sys\n  \"Receive inds('\"dsn\"(loadlib)')\"\n  queue \"dsn('\"hlq\".SRCE')\" vol sys\n  \"Receive inds('\"dsn\"(srce)')\"\n  queue \"dsn('\"hlq\".TESTLIB')\" vol sys\n  \"Receive inds('\"dsn\"(testlib)')\"\n\n/* -------------------------------------------- *\n * If ISPF is active show key members in Browse *\n * -------------------------------------------- */\n  if sysvar('sysispf') <> \"ACTIVE\" then exit\n  Address ISPEXEC\n  \"Browse dataset('\"hlq\".JCL(LICENCE)')\"\n  if rc > 0 then say zerrlm\n/*\"Browse dataset('\"dsn\"(REXXAPI)')\"\n  \"Browse dataset('\"dsn\"($EBCDIC)')\" */\n  \"Browse dataset('\"hlq\".JCL(REXXAPI)')\"\n  \"Browse dataset('\"hlq\".JCL(PCRE2DOC)')\"\n\n/* ------------------------------------------------- *\n * Now display a list of the received datasets using *\n * ISPF LMM services (ISPF 3.4)                      *\n * ------------------------------------------------- */\n  Address ISPExec\n  if vol <> \"\" then lmvol = \"VOLUME(\"vol\")\"\n  else lmvol = \"\"\n  \"LMDINIT LISTID(LISTID) LEVEL(\"hlq\")\" lmvol\n  \"LMDDISP LISTID(\"ListId\") Confirm(Yes)\",\n    \"View(Volume)\"\n  \"LMDFREE LISTID(\"ListId\")\"\n\n  Exit\n\nDo_Comp: procedure\n  arg compdsn\n  if sysdsn(compdsn) /= 'OK' then return\n  say \"Compressing:\"  compdsn\n  \"LMInit dataid(compress) enq(exclu) dataset(\"compdsn\")\"\n  \"LMComp Dataid(\"compress\")\"\n  \"LMFree Dataid(\"compress\")\"\n  return\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ADDMEM": {"ttr": 9, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* REXX - mimic simple IEBUPDTE ./ ADD operation for FB/VB and\n   whatever LRECL input/output on a z/OS/TSO environment.\n   Note that this utility is very limited in nature and there was no\n   attempt to optimize its operation.\n   This utility supports only the ./ ADD NAME=member operation of IEBUPDTE\n   It assumes that the output library is pre-allocated and is the same format\n   as the input file.  It intends to support only RECFM=F|FB|V|VB           */\n/* Version 0.2\n   This version does not rely on stem variable to store the member before\n   copying.  Also, it would ignore input records before the first\n   './ ADD NAME=something'*/\n/* Version 0.3\n   Do not translate tagged lines '<TAG>' (allow for preserving the\n   circumflex) */\n/*           Copyright (c) 2012 Ze'ev Atlas\n\n-----------------------------------------------------------------------------\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n\n    * Redistributions of source code must retain the above copyright notice,\n      this list of conditions and the following disclaimer.\n\n    * Redistributions in binary form must reproduce the above copyright\n      notice, this list of conditions and the following disclaimer in the\n      documentation and/or other materials provided with the distribution.\n\n    * Neither the name of the University of Cambridge nor the names of its\n      contributors may be used to endorse or promote products derived from\n      this software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\nAND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\nIMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\nARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\nLIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\nCONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\nSUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\nINTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\nCONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\nARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\nPOSSIBILITY OF SUCH DAMAGE.\n-----------------------------------------------------------------------------\n*/\n  MAIN:\n   /* usage: Rexx addmem input-file-name output-lib-name*/\n   PARSE ARG ifile olib .\n   say \"ADDMEM-001 add input file\" ifile \"to library\" olib\n   call A00_OPTIONAL\n   Call A01_OPEN_FILES\n   Call B01_INITIALISATION\n   Call C01_PROCESS\n   Call D01_TERMINATION\n   Call EXITCMD\n\n   Return\n\n  A00_OPTIONAL:\n   \"execio * diskr TRANSLAT (stem parmin. finis\"\n   p=0\n   if parmin.0 > 0 then\n   do\n      tistr = ''\n      tostr = ''\n      p = 1\n      do while p \\> parmin.0\n         parse var parmin.p pi po\n          interpret \"ti=\" pi\n          interpret \"to=\" po\n          tistr=tistr || ti\n          tostr=tostr || to\n          p = p+1\n      end\n   end\n\n   return\n\n  A01_OPEN_FILES:\n    \"ALLOC F(INFILE) DA('\" || ifile || \"') SHR REU\"\n    /* check for RC */\n    IF RC \\= 0 THEN\n       call DIE 'alloc input failed' RC\n    \"execio 1 diskr INFILE (\"\n    /* check for RC */\n    if RC = 2 then\n    do\n       say \"ADDMEM-002 EMPTY input file\" ifile\n       Final_RC = RC\n       call EXITCMD\n    end\n    IF RC \\= 0 THEN\n       call DIE 'open input failed' RC\n    parse pull iline\n\n   return\n\n B01_INITIALISATION:\n\n    Final_RC = 0\n    openfile = 0\n\n   Return\n\n EXITCMD:\n    /* To show the return code when running in ispf */\n    If Final_RC = 0 Then\n       Do\n         Say \"ADDMEM-005 Successful Completition \"\n       End\n    Else\n       Say \"ADDMEM-006 Unsuccessful Completition\"\n    Exit Final_RC\n\n   Return\n\nC01_PROCESS:\n    do forever\n      if substr(iline, 1, 3) = './ ' then\n      do\n         if openfile = 1 then\n         do\n            \"execio 0 diskw OUTFILE (finis\"\n            /* check for RC */\n            IF RC \\= 0 THEN\n               call DIE 'close output failed for member ' || vmember       RC\n            \"FREE FI(OUTFILE)\"\n            IF RC \\= 0 THEN\n               call DIE 'free output failed for member ' || vmember RC\n            openfile = 0\n         end\n         do\n            nop\n         end\n         parse VAR iline . vadd vname '=' vmember .\n         \"ALLOC F(OUTFILE) DA('\" || olib || \"(\" || vmember || \")') SHR REU\"\n         /* check for RC */\n         IF RC \\= 0 THEN\n               call DIE 'alloc output failed for member ' || vmember RC\n         drop orecs.\n         orecs.0 = 0\n         say \"ADDMEM-004 adding member\" vmember\n         openfile = 1\n      end\n      else\n      \"execio 1 diskr INFILE (\"\n      /*if eof leave*/\n      if RC = 2 then\n         leave\n      /* check for RC */\n      IF RC \\= 0 THEN\n            call DIE 'read input failed' RC\n      parse pull iline\n      if p > 0 then\n      do\n         /* Do not translate tagged lines */\n         if pos('<TAG>',iline) = 0 then\n         do\n            iline = translate(iline,tostr,tistr)\n         end\n      end\n      if substr(iline, 1, 3) \\= './ ' then\n      do\n          queue iline\n          if openfile = 1 then\n          do\n             \"execio 1 diskw OUTFILE  \"\n             IF RC \\= 0 THEN\n                  call DIE 'write output failed for member ' || vmember  RC\n          end\n          else\n          do\n             DIE \"No member available for line: \" iline\n          end\n      end\n   end\n\n    Return\n\n D01_Termination:\n   if openfile = 1 then\n   do\n      \"execio 0 diskw OUTFILE (finis\"\n      /* check for RC */\n      IF RC \\= 0 THEN\n               call DIE 'close output failed for member ' || vmember       RC\n      \"FREE FI(OUTFILE)\"\n      IF RC \\= 0 THEN\n               call DIE 'free output failed for member ' || vmember RC\n      openfile = 0\n   end\n   \"execio 0 diskr INFILE (finis\"\n   IF RC \\= 0 THEN\n               call DIE 'close input failed' RC\n   /* check for RC */\n    \"FREE FI(INFILE)\"\n    IF RC \\= 0 THEN\n               call DIE 'free input failed' RC\n    final_RC=0\n\n   Return\n\nDIE:\n   parse arg msg vrc .\n   say \"ADDMEM-003\" || msg vrc\n\n   final_RC = vrc\n   call EXITCMD\n\n   return\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "AUTOPOS2": {"ttr": 263, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": " INCLUDE SYSLIB(TABLES2)\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "COMPILE2": {"ttr": 251, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": " INCLUDE SYSLIB(STRINGU2)\n INCLUDE SYSLIB(NEWLINE2)\n INCLUDE SYSLIB(TABLES2)\n INCLUDE SYSLIB(JITCOMP2)\n INCLUDE SYSLIB(CONTEXT2)\n INCLUDE SYSLIB(CHARTAB2)\n INCLUDE SYSLIB(VALIDUT2)\n INCLUDE SYSLIB(FINDBRA2)\n INCLUDE SYSLIB(AUTOPOS2)\n INCLUDE SYSLIB(STUDY2)\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CONFIG2": {"ttr": 271, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": " INCLUDE SYSLIB(STRINGU2)\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CONTEXT2": {"ttr": 265, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": " INCLUDE SYSLIB(CHARTAB2)\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CONVERT2": {"ttr": 269, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": " INCLUDE SYSLIB(STRINGU2)\n INCLUDE SYSLIB(CONTEXT2)\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "DFAMATC2": {"ttr": 255, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": " INCLUDE SYSLIB(TABLES2)\n INCLUDE SYSLIB(NEWLINE2)\n INCLUDE SYSLIB(XCLASS2)\n INCLUDE SYSLIB(STRINGU2)\n INCLUDE SYSLIB(CONTEXT2)\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "FINDBRA2": {"ttr": 259, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": " INCLUDE SYSLIB(TABLES2)\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "FUZZSUP2": {"ttr": 233, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": " INCLUDE SYSLIB(COMPILE2)\n INCLUDE SYSLIB(MATCHDA2)\n INCLUDE SYSLIB(CONTEXT2)\n INCLUDE SYSLIB(MATCH2)\n INCLUDE SYSLIB(DFAMATC2)\n INCLUDE SYSLIB(ERROR2)\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "IBMSAMPL": {"ttr": 11, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00%\\x01\\x16\\x00o\\x01\\x16\\x00o\\x00&\\x00\\x01\\x00\\x01\\x00\\x00\\xe9\\xc1\\xe3\\xd3\\xc1\\xe2\\xf1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-01-06T00:00:00", "modifydate": "2016-01-06T00:26:25", "lines": 1, "newlines": 1, "modlines": 0, "user": "ZATLAS1"}, "text": " INCLUDE SYSLIB(PC2POSIX)\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "MATCHDA2": {"ttr": 257, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": " INCLUDE SYSLIB(CONTEXT2)\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "MATCH2": {"ttr": 267, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": " INCLUDE SYSLIB(TABLES2)\n INCLUDE SYSLIB(NEWLINE2)\n INCLUDE SYSLIB(SCRIPTR2)\n INCLUDE SYSLIB(STRINGU2)\n INCLUDE SYSLIB(CONTEXT2)\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "OPTINHDR": {"ttr": 87, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00A\\x01 \\x00\\x9f\\x01 \\x00\\x9f#\"\\x00\\x01\\x00\\x01\\x00\\x00\\xe9\\xc1\\xe3\\xd3\\xc1\\xe2\\xf1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2020-01-09T00:00:00", "modifydate": "2020-01-09T23:22:41", "lines": 1, "newlines": 1, "modlines": 0, "user": "ZATLAS1"}, "text": "OPTION,BIT,COMPILE,MATCH,DFA_MATCH,SUBSTITUTE,CONTEXT,ZOS\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "OPTIONS2": {"ttr": 273, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00\\x05\\x01 \\x01\\x1f\\x01 \\x13\\x8f!\\x07\\x00I\\x00;\\x00\\x00\\xe9\\xc1\\xe3\\xd3\\xc1\\xe2\\xf1@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "2020-01-11T00:00:00", "modifydate": "2020-05-17T21:07:05", "lines": 73, "newlines": 59, "modlines": 0, "user": "ZATLAS1"}, "text": "*     Option\n*                                     bit pattern\n*                                                  Compile\n*                                                     Match\n*                                                        DFA_match\n*                                                           Substitute\n*                                                              Context\n*                                                                 ZOS\nPCRE2_ANCHORED                      \u00a6 0x80000000 \u00a6 C\u00a6 M\u00a6 D\u00a6  \u00a6  \u00a6 Z\nPCRE2_NO_UTF_CHECK                  \u00a6 0x40000000 \u00a6 C\u00a6 M\u00a6 D\u00a6  \u00a6  \u00a6 Z\nPCRE2_ENDANCHORED                   \u00a6 0x20000000 \u00a6 C\u00a6 M\u00a6 D\u00a6  \u00a6  \u00a6 Z\nPCRE2_ALLOW_EMPTY_CLASS             \u00a6 0x00000001 \u00a6 C\u00a6  \u00a6  \u00a6  \u00a6  \u00a6 Z\nPCRE2_ALT_BSUX                      \u00a6 0x00000002 \u00a6 C\u00a6  \u00a6  \u00a6  \u00a6  \u00a6 Z\nPCRE2_AUTO_CALLOUT                  \u00a6 0x00000004 \u00a6 C\u00a6  \u00a6  \u00a6  \u00a6  \u00a6 Z\nPCRE2_CASELESS                      \u00a6 0x00000008 \u00a6 C\u00a6  \u00a6  \u00a6  \u00a6  \u00a6 Z\nPCRE2_DOLLAR_ENDONLY                \u00a6 0x00000010 \u00a6 C\u00a6 M\u00a6 D\u00a6  \u00a6  \u00a6 Z\nPCRE2_DOTALL                        \u00a6 0x00000020 \u00a6 C\u00a6  \u00a6  \u00a6  \u00a6  \u00a6 Z\nPCRE2_DUPNAMES                      \u00a6 0x00000040 \u00a6 C\u00a6  \u00a6  \u00a6  \u00a6  \u00a6 Z\nPCRE2_EXTENDED                      \u00a6 0x00000080 \u00a6 C\u00a6  \u00a6  \u00a6  \u00a6  \u00a6 Z\nPCRE2_FIRSTLINE                     \u00a6 0x00000100 \u00a6 C\u00a6 M\u00a6 D\u00a6  \u00a6  \u00a6 Z\nPCRE2_MATCH_UNSET_BACKREF           \u00a6 0x00000200 \u00a6 C\u00a6 M\u00a6  \u00a6  \u00a6  \u00a6 Z\nPCRE2_MULTILINE                     \u00a6 0x00000400 \u00a6 C\u00a6  \u00a6  \u00a6  \u00a6  \u00a6 Z\nPCRE2_NEVER_UCP                     \u00a6 0x00000800 \u00a6 C\u00a6  \u00a6  \u00a6  \u00a6  \u00a6 Z\nPCRE2_NEVER_UTF                     \u00a6 0x00001000 \u00a6 C\u00a6  \u00a6  \u00a6  \u00a6  \u00a6 Z\nPCRE2_NO_AUTO_CAPTURE               \u00a6 0x00002000 \u00a6 C\u00a6  \u00a6  \u00a6  \u00a6  \u00a6 Z\nPCRE2_NO_AUTO_POSSESS               \u00a6 0x00004000 \u00a6 C\u00a6  \u00a6  \u00a6  \u00a6  \u00a6 Z\nPCRE2_NO_DOTSTAR_ANCHOR             \u00a6 0x00008000 \u00a6 C\u00a6  \u00a6  \u00a6  \u00a6  \u00a6 Z\nPCRE2_NO_START_OPTIMIZE             \u00a6 0x00010000 \u00a6 C\u00a6 M\u00a6 D\u00a6  \u00a6  \u00a6 Z\nPCRE2_UCP                           \u00a6 0x00020000 \u00a6 C\u00a6 M\u00a6 D\u00a6  \u00a6  \u00a6\nPCRE2_UNGREEDY                      \u00a6 0x00040000 \u00a6 C\u00a6  \u00a6  \u00a6  \u00a6  \u00a6 Z\nPCRE2_UTF                           \u00a6 0x00080000 \u00a6 C\u00a6 M\u00a6 D\u00a6  \u00a6  \u00a6\nPCRE2_NEVER_BACKSLASH_C             \u00a6 0x00100000 \u00a6 C\u00a6  \u00a6  \u00a6  \u00a6  \u00a6 Z\nPCRE2_ALT_CIRCUMFLEX                \u00a6 0x00200000 \u00a6 C\u00a6 M\u00a6 D\u00a6  \u00a6  \u00a6 Z\nPCRE2_ALT_VERBNAMES                 \u00a6 0x00400000 \u00a6 C\u00a6  \u00a6  \u00a6  \u00a6  \u00a6 Z\nPCRE2_USE_OFFSET_LIMIT              \u00a6 0x00800000 \u00a6 C\u00a6 M\u00a6 D\u00a6  \u00a6  \u00a6 Z\nPCRE2_EXTENDED_MORE                 \u00a6 0x01000000 \u00a6 C\u00a6  \u00a6  \u00a6  \u00a6  \u00a6 Z\nPCRE2_LITERAL                       \u00a6 0x02000000 \u00a6 C\u00a6  \u00a6  \u00a6  \u00a6  \u00a6 Z\nPCRE2_MATCH_INVALID_UTF             \u00a6 0x04000000 \u00a6 C\u00a6 M\u00a6 D\u00a6  \u00a6  \u00a6 Z\nPCRE2_EXTRA_ALLOW_SURROGATE_ESCAPES \u00a6 0x00000001 \u00a6 C\u00a6  \u00a6  \u00a6  \u00a6  \u00a6\nPCRE2_EXTRA_BAD_ESCAPE_IS_LITERAL   \u00a6 0x00000002 \u00a6 C\u00a6  \u00a6  \u00a6  \u00a6  \u00a6\nPCRE2_EXTRA_MATCH_WORD              \u00a6 0x00000004 \u00a6 C\u00a6  \u00a6  \u00a6  \u00a6  \u00a6\nPCRE2_EXTRA_MATCH_LINE              \u00a6 0x00000008 \u00a6 C\u00a6  \u00a6  \u00a6  \u00a6  \u00a6\nPCRE2_EXTRA_ESCAPED_CR_IS_LF        \u00a6 0x00000010 \u00a6 C\u00a6  \u00a6  \u00a6  \u00a6  \u00a6\nPCRE2_EXTRA_ALT_BSUX                \u00a6 0x00000020 \u00a6 C\u00a6  \u00a6  \u00a6  \u00a6  \u00a6\nPCRE2_JIT_COMPLETE                  \u00a6 0x00000001 \u00a6 C\u00a6  \u00a6  \u00a6  \u00a6  \u00a6\nPCRE2_JIT_PARTIAL_SOFT              \u00a6 0x00000002 \u00a6 C\u00a6  \u00a6  \u00a6  \u00a6  \u00a6\nPCRE2_JIT_PARTIAL_HARD              \u00a6 0x00000004 \u00a6 C\u00a6  \u00a6  \u00a6  \u00a6  \u00a6\nPCRE2_JIT_INVALID_UTF               \u00a6 0x00000100 \u00a6 C\u00a6  \u00a6  \u00a6  \u00a6  \u00a6\nPCRE2_NOTBOL                        \u00a6 0x00000001 \u00a6  \u00a6 M\u00a6 D\u00a6 S\u00a6  \u00a6 Z\nPCRE2_NOTEOL                        \u00a6 0x00000002 \u00a6  \u00a6 M\u00a6 D\u00a6 S\u00a6  \u00a6 Z\nPCRE2_NOTEMPTY                      \u00a6 0x00000004 \u00a6  \u00a6 M\u00a6 D\u00a6 S\u00a6  \u00a6 Z\nPCRE2_NOTEMPTY_ATSTART              \u00a6 0x00000008 \u00a6  \u00a6 M\u00a6 D\u00a6 S\u00a6  \u00a6 Z\nPCRE2_PARTIAL_SOFT                  \u00a6 0x00000010 \u00a6  \u00a6 M\u00a6 D\u00a6 S\u00a6  \u00a6 Z\nPCRE2_PARTIAL_HARD                  \u00a6 0x00000020 \u00a6  \u00a6 M\u00a6 D\u00a6 S\u00a6  \u00a6 Z\nPCRE2_DFA_RESTART                   \u00a6 0x00000040 \u00a6  \u00a6  \u00a6 D\u00a6  \u00a6  \u00a6\nPCRE2_DFA_SHORTEST                  \u00a6 0x00000080 \u00a6  \u00a6  \u00a6 D\u00a6  \u00a6  \u00a6\nPCRE2_SUBSTITUTE_GLOBAL             \u00a6 0x00000100 \u00a6  \u00a6  \u00a6  \u00a6 S\u00a6  \u00a6 Z\nPCRE2_SUBSTITUTE_EXTENDED           \u00a6 0x00000200 \u00a6  \u00a6  \u00a6  \u00a6 S\u00a6  \u00a6 Z\nPCRE2_SUBSTITUTE_UNSET_EMPTY        \u00a6 0x00000400 \u00a6  \u00a6  \u00a6  \u00a6 S\u00a6  \u00a6 Z\nPCRE2_SUBSTITUTE_UNKNOWN_UNSET      \u00a6 0x00000800 \u00a6  \u00a6  \u00a6  \u00a6 S\u00a6  \u00a6 Z\nPCRE2_SUBSTITUTE_OVERFLOW_LENGTH    \u00a6 0x00001000 \u00a6  \u00a6  \u00a6  \u00a6 S\u00a6  \u00a6 Z\nPCRE2_NO_JIT                        \u00a6 0x00002000 \u00a6  \u00a6 M\u00a6  \u00a6 S\u00a6  \u00a6 Z\nPCRE2_COPY_MATCHED_SUBJECT          \u00a6 0x00004000 \u00a6  \u00a6 M\u00a6 D\u00a6 S\u00a6  \u00a6 Z\nPCRE2_CONVERT_UTF                   \u00a6 0x00000001 \u00a6  \u00a6  \u00a6  \u00a6  \u00a6 C\u00a6\nPCRE2_CONVERT_NO_UTF_CHECK          \u00a6 0x00000002 \u00a6  \u00a6  \u00a6  \u00a6  \u00a6 C\u00a6\nPCRE2_CONVERT_POSIX_BASIC           \u00a6 0x00000004 \u00a6  \u00a6  \u00a6  \u00a6  \u00a6 C\u00a6\nPCRE2_CONVERT_POSIX_EXTENDED        \u00a6 0x00000008 \u00a6  \u00a6  \u00a6  \u00a6  \u00a6 C\u00a6\nPCRE2_CONVERT_GLOB                  \u00a6 0x00000010 \u00a6  \u00a6  \u00a6  \u00a6  \u00a6 C\u00a6\nPCRE2_CONVERT_GLOB_NO_WILD_SEPARATOR\u00a6 0x00000030 \u00a6  \u00a6  \u00a6  \u00a6  \u00a6 C\u00a6\nPCRE2_CONVERT_GLOB_NO_STARSTAR      \u00a6 0x00000050 \u00a6  \u00a6  \u00a6  \u00a6  \u00a6 C\u00a6\nPCRE2_SUBSTITUTE_LITERALARSTAR      \u00a6 0x00008000 \u00a6  \u00a6  \u00a6  \u00a6 S\u00a6  \u00a6 Z\nPCRE2_SUBSTITUTE_MATCHEDARSTAR      \u00a6 0x00010000 \u00a6  \u00a6  \u00a6  \u00a6 S\u00a6  \u00a6 Z\nPCRE2_SUBSTITUTE_REPLACEMENT_ONLY   \u00a6 0x00020000 \u00a6  \u00a6  \u00a6  \u00a6 S\u00a6  \u00a6 Z\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PATTERN2": {"ttr": 247, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": " INCLUDE SYSLIB(TABLES2)\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "PCH2UPDT": {"ttr": 13, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x0f\\x00\\x00\\x01\\x15'_\\x01\\x15(\\x1f#\\x03\\x00\\x9f\\x00\\xbf\\x00\\x00\\xe9\\xc1\\xe3\\xd3\\xc1\\xe2\\xf1@@@\"", "ispf": {"version": "01.15", "flags": 0, "createdate": "2015-10-02T00:00:00", "modifydate": "2015-10-08T23:03:00", "lines": 159, "newlines": 191, "modlines": 0, "user": "ZATLAS1"}, "text": "/* REXX - Convert PUNCH output to IEBUPTE input */\n/* Version 0.1 */\n/*---------------------------------------------------------------\n * Copyright (c) 2015 Ze'ev Atlas\n * Please refer to the LICENSE document to see all other\n * applicable copyrights.\n *\n *---------------------------------------------------------------\n *Redistribution and use in source and binary forms, with or\n *without modification, are permitted provided that the following\n *conditions are met:\n\n * 1. Redistributions of source code must retain the above\n * copyright notice, this list of conditions and the following\n * disclaimer.\n\n * 2. Redistributions in binary form must reproduce the above\n * copyright notice, this list of conditions and the following\n * disclaimer in the documentation and/or other materials\n * provided with the distribution.\n\n * 3. Neither the name of the University of Cambridge nor the\n * names of its contributors may be used to endorse or promote\n * products derived from this software without specific prior\n * written permission.\n\n *THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND\n *CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES,\n *INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n *MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n *DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR\n *CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n *SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n *NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n *LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n *HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n *CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR\n *OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,\n *EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *-------------------------------------------------------------*/\n  MAIN:\n   /* usage: Rexx addmem input-file-name output-lib-name*/\n   PARSE ARG ifile ofile .\n     say \"PCH2UPDT-001 ocnvert punch file\" ifile \"to IEBUPDTE\" ofile\n     Call A01_OPEN_FILES\n     Call B01_INITIALISATION\n     Call C01_PROCESS\n     Call D01_TERMINATION\n     Call EXITCMD\n\n     Return\n\n  A01_OPEN_FILES:\n     /*say \": ALLOC FI(SYSUT1) DSN (\" ifile \") SHR\"*/\n     \"ALLOC FI(SYSUT1) DSN (\" ifile \") SHR\"\n     /* check for RC */\n     IF RC \\= 0 THEN\n        call DIE 'alloc input failed' RC\n     \"execio 1 diskr SYSUT1 (\"\n     /* check for RC */\n     if RC = 2 then\n     do\n        say \"PCH2UPDT-002 EMPTY input file\"\n        Final_RC = RC\n        call EXITCMD\n     end\n     IF RC \\= 0 THEN\n        call DIE 'open input failed' RC\n     openfile = 1\n     parse pull iline\n\n     /*say \": ALLOC FI(SYSUT2) DSN (\" ofile \") OLD\"*/\n     \"ALLOC FI(SYSUT2) DSN (\" ofile \") OLD\"\n     /* check for RC */\n     IF RC \\= 0 THEN\n        call DIE 'alloc output failed' RC\n\n     return\n\n B01_INITIALISATION:\n\n    Final_RC = 0\n\n    Return\n\n EXITCMD:\n    /* To show the return code when running in ispf */\n    If Final_RC = 0 Then\n       Do\n         Say \"PCH2UPDT-005 Successful Completition \" || RC\n       End\n    Else\n       Say \"PCH2UPDT-006 Unsuccessful Completition \" || RC\n    Exit Final_RC\n\n   Return\n\n C01_PROCESS:\n    do forever\n       if substr(iline, 1, 14) = 'VMEMBER NAME  ' then\n       do\n          membername = substr(iline, 15, 8)\n          outline = './ REPL NAME=' || membername\n          PUSH outline\n          \"EXECIO * DISKW SYSUT2 \"\n             IF RC \\= 0 THEN\n        call DIE 'write output failed for command ' || membername RC\n       end\n       else\n       do\n           outline = substr(iline,2,80)\n           PUSH outline\n           \"EXECIO * DISKW SYSUT2 \"\n              IF RC \\= 0 THEN\n        call DIE 'write output failed for member ' || membername RC\n       end\n       \"execio 1 diskr SYSUT1 \"\n       /*if eof leave*/\n       if RC = 2 then\n          leave\n       /* check for RC */\n       IF RC \\= 0 THEN\n             call DIE 'read input failed' RC\n       parse pull iline\n    end\n\n    Return\n\n D01_Termination:\n   if openfile = 1 then\n   do\n      \"execio 0 diskw SYSUT2 (finis\"\n      /* check for RC */\n      IF RC \\= 0 THEN\n               call DIE 'close output failed ' || RC\n      \"FREE DDNAME(SYSUT2)\"\n      IF RC \\= 0 THEN\n               call DIE 'free output failed for member ' || RC\n      openfile = 0\n   end\n   \"execio 0 diskr SYSUT1 (finis\"\n   IF RC \\= 0 THEN\n               call DIE 'close input failed' RC\n   /* check for RC */\n    \"FREE DDNAME(SYSUT1)\"\n    IF RC \\= 0 THEN\n               call DIE 'free input failed' RC\n    final_RC=0\n\n   Return\n\nDIE:\n   parse arg msg vrc .\n   say \"PCH2UPDT-003 \" || msg vrc\n\n   final_RC = vrc\n   call EXITCMD\n\n   return\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PCOBAPI2": {"ttr": 261, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": " INCLUDE SYSLIB(MAKETAB2)\n INCLUDE SYSLIB(CONFIG2)\n INCLUDE SYSLIB(CONTEXT2)\n INCLUDE SYSLIB(COMPILE2)\n INCLUDE SYSLIB(PATTERN2)\n INCLUDE SYSLIB(MATCHDA2)\n INCLUDE SYSLIB(DFAMATC2)\n INCLUDE SYSLIB(MATCH2)\n INCLUDE SYSLIB(SUBSTRI2)\n INCLUDE SYSLIB(SERIALI2)\n INCLUDE SYSLIB(SUBSTIT2)\n INCLUDE SYSLIB(CONVERT2)\n INCLUDE SYSLIB(JITCOMP2)\n INCLUDE SYSLIB(ERROR2)\n INCLUDE SYSLIB(PCRZFUNC)\n INCLUDE SYSLIB(PC2POSIX)\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "PCR2DEMO": {"ttr": 239, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": " INCLUDE SYSLIB(COMPILE2)\n INCLUDE SYSLIB(ERROR2)\n INCLUDE SYSLIB(MATCHDA2)\n INCLUDE SYSLIB(MATCH2)\n INCLUDE SYSLIB(PATTERN2)\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "PCR2GREP": {"ttr": 253, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": " INCLUDE SYSLIB(COMPILE2)\n INCLUDE SYSLIB(MATCH2)\n INCLUDE SYSLIB(MATCHDA2)\n INCLUDE SYSLIB(ERROR2)\n INCLUDE SYSLIB(PCRZFUNC)\n INCLUDE SYSLIB(CONFIG2)\n INCLUDE SYSLIB(CONTEXT2)\n INCLUDE SYSLIB(MAKETAB2)\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "PCR2TEST": {"ttr": 235, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": " INCLUDE SYSLIB(ERROR2)\n INCLUDE SYSLIB(PATTERN2)\n INCLUDE SYSLIB(MAKETAB2)\n INCLUDE SYSLIB(CONTEXT2)\n INCLUDE SYSLIB(PC2POSIX)\n INCLUDE SYSLIB(CONVERT2)\n INCLUDE SYSLIB(COMPILE2)\n INCLUDE SYSLIB(JITCOMP2)\n INCLUDE SYSLIB(SERIALI2)\n INCLUDE SYSLIB(CONFIG2)\n INCLUDE SYSLIB(SUBSTRI2)\n INCLUDE SYSLIB(DFAMATC2)\n INCLUDE SYSLIB(MATCH2)\n INCLUDE SYSLIB(MATCHDA2)\n INCLUDE SYSLIB(SUBSTIT2)\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "PC2POSIX": {"ttr": 237, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": " INCLUDE SYSLIB(MATCH2)\n INCLUDE SYSLIB(MATCHDA2)\n INCLUDE SYSLIB(COMPILE2)\n INCLUDE SYSLIB(PATTERN2)\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "RXPCREMB": {"ttr": 73, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x0b\\x00\\x07\\x01\\x194\\x7f\\x01\\x194\\x8f\\x17\\x14\\x00Y\\x005\\x00\\x00\\xe2\\xc4\\xd1\\xd9\\xc7@@@@@'", "ispf": {"version": "01.11", "flags": 0, "createdate": "2019-12-13T00:00:00", "modifydate": "2019-12-14T17:14:07", "lines": 89, "newlines": 53, "modlines": 0, "user": "SDJRG"}, "text": "/*REXX*/\n\n  reg_ex    = \"cat|dog\"\n  the_str   = \"the dog's cat sat on the cat's dog\"\n  subs_str  = \"horse\"\n  my_var    = \"WANG\"\n  opt_ion   = \"g\"\n\n\n  re_sponse = RXPCRE2('connect','pcre_env',,'debug')\n\n  if re_sponse \\= 0 then exit\n\n  say 'pcre_env     = ' pcre_env\n\n  re_sponse = RXPCRE2('compile',pcre_env,reg_ex,'pcre_comp1',opt_ion)\n\n  if re_sponse \\= 0 then exit\n\n  say 'pcre_comp1   = ' pcre_comp1\n\n  re_sponse = RXPCRE2('compile',pcre_env,reg_ex,'pcre_comp2')\n\n  if re_sponse \\= 0 then exit\n\n  say 'pcre_comp2   = ' pcre_comp2\n\n\n  say '  '\n  say reg_ex\n  say the_str\n  say subs_str\n\n  pcre_subs = RXPCRE2('subs',pcre_env,pcre_comp1,,\n                      the_str,my_var,subs_str)\n\n  say 'pcre_subs    = ' pcre_subs\n\n  select\n     when pcre_subs = 1 then do\n         say 'output with -g is'\n         say ':' || wang || ':'\n       end\n     when pcre_subs = 0 then\n       say 'no matches found'\n     Otherwise do\n         say 'Error :' pcre_subs\n         exit\n       end\n  end\n\n  say ' '\n\n  pcre_subs = RXPCRE2('subs',pcre_env,pcre_comp2,,\n                      the_str,my_var,subs_str)\n\n  say 'pcre_subs    = ' pcre_subs\n\n  select\n     when pcre_subs = 1 then do\n         say 'output without -g is'\n         say ':' || wang || ':'\n       end\n     when pcre_subs = 0 then\n       say 'no matches found'\n     Otherwise do\n         say 'Error :' pcre_subs\n         exit\n       end\n  end\n\n  say ' '\n\n  re_lease  = RXPCRE2('release',pcre_env,pcre_comp1)\n\n  say 're_lease1    = ' re_lease\n\n  re_lease  = RXPCRE2('release',pcre_env,pcre_comp2)\n\n  say 're_lease2    = ' re_lease\n\n  say ' '\n\n  te_rm     = RXPCRE2('disconnect',pcre_env)\n\n  say 'te_rm        = ' te_rm\n\n  exit\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "RXPCRE2B": {"ttr": 71, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x01\\x00\\x19\\x01\\x194\\x8f\\x01\\x194\\x8f\\x17\\x14\\x01&\\x01'\\x00\\x00\\xe2\\xc4\\xd1\\xd9\\xc7@@@@@\"", "ispf": {"version": "01.01", "flags": 0, "createdate": "2019-12-14T00:00:00", "modifydate": "2019-12-14T17:14:19", "lines": 294, "newlines": 295, "modlines": 0, "user": "SDJRG"}, "text": "/*REXX*/\n\n  the_str1 = \"The quick brown fox jumps over the lazy dog.\"\n  the_str1 = the_str1||\"The quick brown fox jumps over the\"\n  the_str2 = \"The brown quick fox over the lazy dog jumps.\"\n  the_str2 = the_str2||\"The brown quick fox over the jumps\"\n  the_str3 = \"The slow brown fox walks past the lazy dog.\"\n  the_str4 = \"The slow brown fox walks quickly past the lazy dog.\"\n\n  reg_ex_9  = \"(?<char>A)\\g<char>\"    /* ||'00'x */\n  the_str9  = \"AN_AARDWARK_JAKE_AND_a AARDWARK_JACK\"\n  the_str9a = \"ANnn_AARDWARK_JAKE_AND_a lower AARDWARK_JACK\"\n  opt_ion_9 = \"gix\"\n  reg_ex  = \"(quick|jump)\"            /* ||'00'x */\n  my_stem = \"WANG\"\n  opt_ion = \"g\"\n\n/*\n  say '  '\n\n  say ' first the old version +++++++++++++++++++++++++++ '\n\n  say '  '\n\n\n  say reg_ex\n  say the_str1\n\n  re_sponse = REXXPCRE(reg_ex,the_str1,my_stem,opt_ion,,'debug')\n\n  select\n     when re_sponse = 1 then do\n        say 'wang.0  is  ' wang.0\n        do lo_op_r = 1 to wang.0\n           var_1  =  substr(wang_string.lo_op_r,1,30)\n           var_2  =  substr(wang_pos.lo_op_r,1,10)\n           var_3  =  wang_name.lo_op_r\n           say  var_1 var_2 var_3\n        end\n       end\n     when re_sponse = 0 then\n        say 'no matches found'\n     Otherwise\n        say 'Error :' re_sponse\n  end\n\n\n  reg_ex  = \"(quick|jump)\"\n  opt_ion = \"g\"\n\n  say reg_ex\n  say the_str2\n\n  re_sponse = REXXPCRE(reg_ex,the_str2,my_stem,opt_ion,,'debug')\n\n  select\n     when re_sponse = 1 then do\n        say 'wang.0  is  ' wang.0\n        do lo_op_r = 1 to wang.0\n           var_1  =  substr(wang_string.lo_op_r,1,30)\n           var_2  =  substr(wang_pos.lo_op_r,1,10)\n           var_3  =  wang_name.lo_op_r\n           say  var_1 var_2 var_3\n        end\n       end\n     when re_sponse = 0 then\n        say 'no matches found'\n     Otherwise\n        say 'Error :' re_sponse\n  end\n\n\n  say '  '\n\n  say ' now the new version +++++++++++++++++++++++++++ '\n\n  say '  '\n*/\n  my_stem = \"wang\"\n\n  re_sponse = RXPCRE2('connect','pcre_env',,'debug')\n\n  if re_sponse \\= 0 then exit\n\n  say 'pcre_env     = ' pcre_env\n\n  re_sponse = RXPCRE2('compile',pcre_env,reg_ex,'pcre_comp',opt_ion)\n\n  if re_sponse \\= 0 then exit\n\n  say 'pcre_comp    = ' pcre_comp\n\n  re_sponse = RXPCRE2('compile',pcre_env,reg_ex_9,,\n                      'pcre_comp_9',opt_ion_9)\n\n  if re_sponse \\= 0 then exit\n\n  say 'pcre_comp_9  = ' pcre_comp_9\n\n  /*\n     so now we have 2 seperate compilations which we should be\n     able to use alternately\n  */\n\n  say '  '\n  say reg_ex\n  say the_str1\n\n  /* note the double comma to tell rexx the parameters are\n     continued on the next line                               */\n\n  pcre_exec = RXPCRE2('execute',pcre_env,pcre_comp,,\n                      the_str1,my_stem)\n\n  say 'pcre_exec    = ' pcre_exec\n\n  say 'wang.0      is  ' wang.0\n  say 'wang_pos.0  is  ' wang_pos.0\n\n  select\n     when pcre_exec = 1 then do\n        say 'wang.0  is  ' wang.0\n        do lo_op_r = 1 to wang.0\n           var_1  =  substr(wang_string.lo_op_r,1,30)\n           var_2  =  substr(wang_pos.lo_op_r,1,10)\n           var_3  =  wang_name.lo_op_r\n           say  var_1 var_2 var_3\n        end\n       end\n     when pcre_exec = 0 then\n        say 'no matches found'\n     Otherwise\n        say 'Error :' pcre_exec\n  end\n\n  say ' '\n  say reg_ex_9\n  say the_str9\n\n  pcre_exec_9 = RXPCRE2('execute',pcre_env,pcre_comp_9,,\n                        the_str9,my_stem)\n\n  say 'pcre_exec_9  = ' pcre_exec_9\n\n  say 'wang.0      is  ' wang.0\n  say 'wang_pos.0  is  ' wang_pos.0\n\n  select\n     when pcre_exec_9 = 1 then do\n        say 'wang.0  is  ' wang.0\n        do lo_op_r = 1 to wang.0\n           var_1  =  substr(wang_string.lo_op_r,1,30)\n           var_2  =  substr(wang_pos.lo_op_r,1,10)\n           var_3  =  wang_name.lo_op_r\n           say  var_1 var_2 var_3\n        end\n       end\n     when pcre_exec_9 = 0 then\n        say 'no matches found'\n     Otherwise\n        say 'Error :' pcre_exec_9\n  end\n\n  say ' '\n  say reg_ex\n  say the_str2\n\n\n  pcre_exec = RXPCRE2('execute',pcre_env,pcre_comp,the_str2,my_stem)\n\n  say 'pcre_exec    = ' pcre_exec\n\n  say 'wang.0      is  ' wang.0\n  say 'wang_pos.0  is  ' wang_pos.0\n\n  select\n     when pcre_exec = 1 then do\n        say 'wang.0  is  ' wang.0\n        do lo_op_r = 1 to wang.0\n           var_1  =  substr(wang_string.lo_op_r,1,30)\n           var_2  =  substr(wang_pos.lo_op_r,1,10)\n           var_3  =  wang_name.lo_op_r\n           say  var_1 var_2 var_3\n        end\n       end\n     when pcre_exec = 0 then\n        say 'no matches found'\n     Otherwise\n        say 'Error :' pcre_exec\n  end\n\n  say ' '\n  say reg_ex_9\n  say the_str9a\n\n  pcre_exec_9 = RXPCRE2('execute',pcre_env,pcre_comp_9,,\n                        the_str9a,my_stem)\n\n  say 'pcre_exec_9  = ' pcre_exec_9\n\n  say 'wang.0      is  ' wang.0\n  say 'wang_pos.0  is  ' wang_pos.0\n\n  select\n     when pcre_exec_9 = 1 then do\n        say 'wang.0  is  ' wang.0\n        do lo_op_r = 1 to wang.0\n           var_1  =  substr(wang_string.lo_op_r,1,30)\n           var_2  =  substr(wang_pos.lo_op_r,1,10)\n           var_3  =  wang_name.lo_op_r\n           say  var_1 var_2 var_3\n        end\n       end\n     when pcre_exec_9 = 0 then\n        say 'no matches found'\n     Otherwise\n        say 'Error :' pcre_exec_9\n  end\n\n  say ' '\n  say reg_ex\n  say the_str3\n\n  pcre_exec = RXPCRE2('execute',pcre_env,pcre_comp,the_str3,my_stem)\n\n  say 'pcre_exec    = ' pcre_exec\n\n  say 'wang.0      is  ' wang.0\n  say 'wang_pos.0  is  ' wang_pos.0\n\n  select\n     when pcre_exec = 1 then do\n        say 'wang.0  is  ' wang.0\n        do lo_op_r = 1 to wang.0\n           var_1  =  substr(wang_string.lo_op_r,1,30)\n           var_2  =  substr(wang_pos.lo_op_r,1,10)\n           var_3  =  wang_name.lo_op_r\n           say  var_1 var_2 var_3\n        end\n       end\n     when pcre_exec = 0 then\n        say 'no matches found'\n     Otherwise\n        say 'Error :' pcre_exec\n  end\n\n  say ' '\n  say reg_ex\n  say the_str4\n\n  pcre_exec = RXPCRE2('execute',pcre_env,pcre_comp,the_str4,my_stem)\n\n  say 'pcre_exec    = ' pcre_exec\n\n  say 'wang.0      is  ' wang.0\n  say 'wang_pos.0  is  ' wang_pos.0\n\n  select\n     when pcre_exec = 1 then do\n        say 'wang.0  is  ' wang.0\n        do lo_op_r = 1 to wang.0\n           var_1  =  substr(wang_string.lo_op_r,1,30)\n           var_2  =  substr(wang_pos.lo_op_r,1,10)\n           var_3  =  wang_name.lo_op_r\n           say  var_1 var_2 var_3\n        end\n       end\n     when pcre_exec = 0 then\n        say 'no matches found'\n     Otherwise\n        say 'Error :' pcre_exec\n  end\n\n\n  say ' '\n\n  re_lease  = RXPCRE2('release',pcre_env,pcre_comp)\n\n  say 're_lease     = ' re_lease\n\n  say ' '\n\n  re_lease_9 = RXPCRE2('release',pcre_env,pcre_comp_9)\n\n  say 're_lease_9   = ' re_lease\n\n  say ' '\n\n  te_rm     = RXPCRE2('disconnect',pcre_env)\n\n  say 'te_rm        = ' te_rm\n\n  exit\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "RXPCSUB": {"ttr": 99, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\n\\x00Q\\x01\\x195/\\x01 \\x02\\x0f\\x11A\\x00e\\x00Y\\x00\\x00\\xe2\\xc4\\xd1\\xd9\\xc7@@@@@'", "ispf": {"version": "01.10", "flags": 0, "createdate": "2019-12-18T00:00:00", "modifydate": "2020-01-20T11:41:51", "lines": 101, "newlines": 89, "modlines": 0, "user": "SDJRG"}, "text": "/*REXX*/\n\n  reg_ex    = \"(\\d)\\.(\\d)\"\n  the_str   = \"100.05 one hundred.zero five 217.35\"\n  subs_str  = \"\u00a2{1},\u00a2{2}\"\n  my_var    = \"WANG\"\n  opt_ion   = \"g\"\n\n  /* set some options in a stem  */\n  op_t.1 = 'PCRE2_DOLLAR_ENDONLY'\n  op_t.2 = 'PCRE2_DOTALL'\n  op_t.3 = 'PCRE2_DUPNAMES'\n  op_t.4 = 'PCRE2_NOTEMPTY'\n  op_t.0 = '4'\n\n  re_sponse = RXPCRE2O('op_t','op_wrd1')\n  say 'rc from RXPCRE2O was ' re_sponse\n\n  if re_sponse \\= 0 then exit\n\n  say 'option word  = ' op_wrd1\n\n  re_sponse = RXPCRE2('connect','pcre_env','IBM-285','debug')\n\n  if re_sponse \\= 0 then exit\n\n  re_sponse = RXPCRE2('compile',pcre_env,reg_ex,'pcre_comp1',,\n                      opt_ion,op_wrd1)\n\n  if re_sponse \\= 0 then exit\n\n  say 'pcre_comp1   = ' pcre_comp1\n\n  re_sponse = RXPCRE2('compile',pcre_env,reg_ex,'pcre_comp2')\n\n  if re_sponse \\= 0 then exit\n\n  say 'pcre_comp2   = ' pcre_comp2\n\n\n  say '  '\n  say reg_ex\n  say the_str\n  say subs_str\n\n  pcre_subs = RXPCRE2('subs',pcre_env,pcre_comp1,,\n                      the_str,my_var,subs_str)\n\n  say 'pcre_subs    = ' pcre_subs\n\n  select\n     when pcre_subs = 1 then do\n         say 'output with -g is'\n         say ':' || wang || ':'\n       end\n     when pcre_subs = 0 then\n       say 'no matches found'\n     Otherwise do\n         say 'Error :' pcre_subs\n         exit\n       end\n  end\n\n  say ' '\n\n  pcre_subs = RXPCRE2('subs',pcre_env,pcre_comp2,,\n                      the_str,my_var,subs_str)\n\n  say 'pcre_subs    = ' pcre_subs\n\n  select\n     when pcre_subs = 1 then do\n         say 'output without -g is'\n         say ':' || wang || ':'\n       end\n     when pcre_subs = 0 then\n       say 'no matches found'\n     Otherwise do\n         say 'Error :' pcre_subs\n         exit\n       end\n  end\n\n  say ' '\n/*\n  re_lease  = RXPCRE2('release',pcre_env,pcre_comp1)\n\n  say 're_lease1    = ' re_lease\n\n  re_lease  = RXPCRE2('release',pcre_env,pcre_comp2)\n\n  say 're_lease2    = ' re_lease\n\n  say ' '\n*/\n  te_rm     = RXPCRE2('disconnect',pcre_env)\n\n  say 'te_rm        = ' te_rm\n\n  exit\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "RXPCSUBA": {"ttr": 137, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x08\\x00@\\x01 \\x02\\x0f\\x01 \\x02?\"S\\x00s\\x00e\\x00\\x00\\xe9\\xc1\\xe3\\xd3\\xc1\\xe2\\xf1@@@'", "ispf": {"version": "01.08", "flags": 0, "createdate": "2020-01-20T00:00:00", "modifydate": "2020-01-23T22:53:40", "lines": 115, "newlines": 101, "modlines": 0, "user": "ZATLAS1"}, "text": "/*REXX*/\n/* Ze'ev's test platform */\n\n  reg_ex    = \"(\\d)\\.(\\d)\"\n  the_str   = \"100.05 one hundred.zero five 217.35\"\n  subs_str  = \"\u00a2{1},\u00a2{2}\"\n  my_var    = \"WANG\"\n  opt_ion   = \"g\"\n\n  /* set some options in a stem  */\n  op_t.1 = 'PCRE2_NO_UTF_CHECK'\n  op_t.2 = 'PCRE2_EXTENDED_MORE'\n  op_t.3 = 'PCRE2_NEVER_UCP'\n  op_t.4 = 'PCRE2_MULTILINE'\n  op_t.0 = '4'\n  /* set some options in a stem  */\n  op_t1.1 = 'PCRE2_NOTBOL'\n  op_t1.2 = 'PCRE2_NOTEOL'\n  op_t1.3 = 'PCRE2_NOTEMPTY'\n  op_t1.4 = 'PCRE2_NO_JIT'\n  op_t1.0 = '4'\n\n  re_sponse = RXPCRE2O('op_t','op_wrd1')\n  say 'rc from RXPCRE2O was ' re_sponse\n\n  if re_sponse \\= 0 then exit\n\n  say 'option word  = ' op_wrd1\n\n  re_sponse = RXPCRE2O('op_t1','op_wrd2')\n  say 'rc from RXPCRE2O was ' re_sponse\n\n  if re_sponse \\= 0 then exit\n\n  say 'option word2  = ' op_wrd2\n\n  re_sponse = RXPCRE2('connect','pcre_env','IBM-285') /*,'debug')*/\n\n  if re_sponse \\= 0 then exit\n\n  re_sponse = RXPCRE2('compile',pcre_env,reg_ex,'pcre_comp1',,\n                      opt_ion,op_wrd1)\n\n  if re_sponse \\= 0 then exit\n\n  say 'pcre_comp1   = ' pcre_comp1\n\n  re_sponse = RXPCRE2('compile',pcre_env,reg_ex,'pcre_comp2')\n\n  if re_sponse \\= 0 then exit\n\n  say 'pcre_comp2   = ' pcre_comp2\n\n\n  say '  '\n  say reg_ex\n  say the_str\n  say subs_str\n\n  pcre_subs = RXPCRE2('subs',pcre_env,pcre_comp1,,\n                      the_str,my_var,subs_str,op_wrd2)\n\n  say 'pcre_subs    = ' pcre_subs\n\n  select\n     when pcre_subs = 1 then do\n         say 'output with -g is'\n         say ':' || wang || ':'\n       end\n     when pcre_subs = 0 then\n       say 'no matches found'\n     Otherwise do\n         say 'Error :' pcre_subs\n         exit\n       end\n  end\n\n  say ' '\n\n  pcre_subs = RXPCRE2('subs',pcre_env,pcre_comp2,,\n                      the_str,my_var,subs_str,op_wrd2)\n\n  say 'pcre_subs    = ' pcre_subs\n\n  select\n     when pcre_subs = 1 then do\n         say 'output without -g is'\n         say ':' || wang || ':'\n       end\n     when pcre_subs = 0 then\n       say 'no matches found'\n     Otherwise do\n         say 'Error :' pcre_subs\n         exit\n       end\n  end\n\n  say ' '\n/*\n  re_lease  = RXPCRE2('release',pcre_env,pcre_comp1)\n\n  say 're_lease1    = ' re_lease\n\n  re_lease  = RXPCRE2('release',pcre_env,pcre_comp2)\n\n  say 're_lease2    = ' re_lease\n\n  say ' '\n*/\n  te_rm     = RXPCRE2('disconnect',pcre_env)\n\n  say 'te_rm        = ' te_rm\n\n  exit\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "RXPRSNT1": {"ttr": 375, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x10\\x00Q\\x01 \"?\\x01 #/\"2\\x00$\\x00H\\x00\\x00\\xe9\\xc1\\xe3\\xd3\\xc1\\xe2\\xf1@@@'", "ispf": {"version": "01.16", "flags": 0, "createdate": "2020-08-10T00:00:00", "modifydate": "2020-08-19T22:32:51", "lines": 36, "newlines": 72, "modlines": 0, "user": "ZATLAS1"}, "text": " /* REXX */\n /* crude tests, used to create the ppt */\n call on failure name err1\n /*REG_EX  =\"(Mr\\.\\s(John|Alfred)\\s(?:Sr\\.|Jr\\.))\"\n REG_EX  =\"(?<paren1>Mr\\.\\s(?<paren2>John|Alfred)\\s(?:Sr\\.|Jr\\.))\"\n */\n REG_EX  =\"(?<paren1>Mr\\.\\s(?<paren2>John|Alfred)\\s\"\n REG_EX = REG_EX || \"(?<paren3>Sr\\.|Jr\\.)?)\"\n\n /*THE_STR1 = \"Alfred went to visit Mr. John Jr. and Mr. Alfred sr.\"\n */\n THE_STR1 = \"Alfred went to visit Mr. John Jr. and Mr. Alfred III\"\n say \"now the third parentheses are capturing but optional\"\n MY_STEM = \"WANG\"\n OPT_ION = \"gi\"\n say   REG_EX\n say   THE_STR1\n say   OPT_ION\n\n /*re_sponse = REXXPCRE(reg_ex,the_str1,my_stem,opt_ion,,'debug')*/\n   re_sponse = REXXPCRE(reg_ex,the_str1,my_stem,opt_ion)\n SAY WANG.0\n do  i = 1 to wang.0\n   say\n   say i\n   SAY WANG_string.i\n   SAY WANG_pos.i\n   SAY WANG_name.i\n end\n\n exit\n err1:\n    say 'failure at ' sigl\n    say condition()\n    say condition('D')\n    return\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "RXPRSNT2": {"ttr": 367, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x05\\x00U\\x01 \"?\\x01 \"\\x9f!\\'\\x00H\\x00H\\x00\\x00\\xe9\\xc1\\xe3\\xd3\\xc1\\xe2\\xf1@@@'", "ispf": {"version": "01.05", "flags": 0, "createdate": "2020-08-10T00:00:00", "modifydate": "2020-08-16T21:27:55", "lines": 72, "newlines": 72, "modlines": 0, "user": "ZATLAS1"}, "text": " /* REXX */\n /* crude tests, used to create the ppt */\n call on failure name err1\n REG_EX  = \"(QUICK|JUMP)\"\n THE_STR1 = \"THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG.\"\n MY_STEM = \"WANG\"\n OPT_ION = \"gi\"\n\n  my_stem = \"wang\"\n\n/*re_sponse = RXPCRE2('connect','pcre_env','IBM-1047','debug')*/\n  re_sponse = RXPCRE2('connect','pcre_env')\n\n  if re_sponse \\= 0 then exit\n\n  say 'pcre_env     = ' pcre_env\n\n  re_sponse = RXPCRE2('compile',pcre_env,reg_ex,'pcre_comp',opt_ion)\n\n  if re_sponse \\= 0 then exit\n\n  say 'pcre_comp    = ' pcre_comp\n\n\n  say '  '\n  say reg_ex\n  say the_str1\n\n  /* note the double comma to tell rexx the parameters are\n     continued on the next line                               */\n\n  pcre_exec = RXPCRE2('execute',pcre_env,pcre_comp,,\n                      the_str1,my_stem)\n\n  say 'pcre_exec    = ' pcre_exec\n\n  say 'wang.0      is  ' wang.0\n  say 'wang_pos.0  is  ' wang_pos.0\n\n  select\n     when pcre_exec = 1 then do\n        say 'wang.0  is  ' wang.0\n        do lo_op_r = 1 to wang.0\n           var_1  =  substr(wang_string.lo_op_r,1,30)\n           var_2  =  substr(wang_pos.lo_op_r,1,10)\n           var_3  =  wang_name.lo_op_r\n           say  var_1 var_2 var_3\n        end\n       end\n     when pcre_exec = 0 then\n        say 'no matches found'\n     Otherwise\n        say 'Error :' pcre_exec\n  end\n\n  say ' '\n\n SAY WANG.0\n do  i = 1 to wang.0\n   say\n   say i\n   SAY WANG_string.i\n   SAY WANG_pos.i\n   SAY WANG_name.i\n end\n\n exit\n err1:\n    say 'failure at ' sigl\n    say condition()\n    say condition('D')\n    return\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SERIALI2": {"ttr": 243, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": " INCLUDE SYSLIB(CONTEXT2)\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "SPLITLIB": {"ttr": 15, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x12\\x00(\\x01\\x156\\x1f\\x01\\x156\\x1f\\x19\\x19\\x00[\\x00\\x17\\x00\\x00\\xe9\\xc1\\xe3\\xd3\\xc1\\xe2\\xf1@@@'", "ispf": {"version": "01.18", "flags": 0, "createdate": "2015-12-27T00:00:00", "modifydate": "2015-12-27T19:19:28", "lines": 91, "newlines": 23, "modlines": 0, "user": "ZATLAS1"}, "text": "/* REXX  SPLIT PDS OF ANY ATTRIBUTES                *\n * THEPDS = \"'USERID.ABC.XYZ'\"                      *\n * Relies on \"LISTDS \"THEPDS\" MEMBERS\" to produce   *\n * 1 USERID.ABC.XYZ                                 *\n * 2 --RECFM-LRECL-BLKSIZE-DSORG                    *\n * 3   VB    255   27998   PO                       *\n * 4 --VOLUMES--                                    *\n * 5   VOLSER                                       *\n * 6 --MEMBERS--                                    *\n * 7   AMEMBER1                                     */\n/* REXX - GENERATE ./ ADD NAME= OUTPUT */\n/* Version 0.1 */\n/*---------------------------------------------------------------\n * Copyright (c) 2015 Ze'ev Atlas\n * Please refer to the LICENSE document to see all other\n * applicable copyrights.\n *\n *---------------------------------------------------------------\n *Redistribution and use in source and binary forms, with or\n *without modification, are permitted provided that the following\n *conditions are met:\n\n * 1. Redistributions of source code must retain the above\n * copyright notice, this list of conditions and the following\n * disclaimer.\n\n * 2. Redistributions in binary form must reproduce the above\n * copyright notice, this list of conditions and the following\n * disclaimer in the documentation and/or other materials\n * provided with the distribution.\n\n * 3. Neither the name of the University of Cambridge nor the\n * names of its contributors may be used to endorse or promote\n * products derived from this software without specific prior\n * written permission.\n\n *THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND\n *CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES,\n *INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n *MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n *DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR\n *CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n *SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n *NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n *LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n *HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n *CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR\n *OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,\n *EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *-------------------------------------------------------------*/\n\nPARSE ARG THEPDS .\nX = OUTTRAP('ML.')\n\"LISTDS \"THEPDS\" MEMBERS\"\nX = OUTTRAP('OFF')\nPARSE VAR ML.3 RECFM LRECL .\nSAY THEPDS RECFM LRECL\nTHEFLAT = THEPDS || \".SPLIT\"\nRECFM = SUBSTR(RECFM,1,1)\n\"ALLOC FI(XXOUT) DA(\"THEFLAT\") SHR NEW SPACE(30,15) CYL\n DSORG(PS) RECFM(\" RECFM \", B) LRECL(\" LRECL \")\"\nDO N = 7 TO ML.0\n  PARSE VAR ML.N MEMBER\n  MEMBER=STRIP(MEMBER)\n  dotslash.1 =  \"./ ADD NAME=\" || MEMBER\n  /*say dotslash.1 */\n  \"EXECIO 1 DISKW XXOUT (STEM dotslash.\"\n  IF RC \\= 0 THEN\n     call DIE 'WRITE ADD STATEMENT failed' RC\n  THEMEMBER = THEPDS || \"(\" || MEMBER || \")\"\n  /*say themember */\n  \"alloc shr file(input) dataset(\" THEMEMBER \")\"\n  \"execio * diskr input (stem input. finis)\"\n  IF RC \\= 0 THEN\n     call DIE 'READ MEMBER failed' RC\n  say member input.0 \"LINES READ\"\n  \"free file(input)\"\n  \"EXECIO\" input.0 \"DISKW XXOUT (STEM INPUT.\"\n  IF RC \\= 0 THEN\n     call DIE 'WRITE MEMBER failed' RC\nEND\n\"EXECIO 0 DISKW XXOUT ( FINIS\"\nIF RC \\= 0 THEN\n   call DIE 'CLOSE OUTPUT failed' RC\nEXIT 0\nDIE:\n   parse arg msg vrc .\n   say \"SPLITLIB-003 \" || msg vrc\n\n   EXIT vrc\n   return\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "STUDY2": {"ttr": 241, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": " INCLUDE SYSLIB(TABLES2)\n INCLUDE SYSLIB(UCD2)\n INCLUDE SYSLIB(FINDBRA2)\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "SUBSTIT2": {"ttr": 245, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": " INCLUDE SYSLIB(COMPILE2)\n INCLUDE SYSLIB(MATCHDA2)\n INCLUDE SYSLIB(STRINGU2)\n INCLUDE SYSLIB(MATCH2)\n INCLUDE SYSLIB(SUBSTRI2)\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "SUBSTRI2": {"ttr": 249, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": " INCLUDE SYSLIB(CONTEXT2)\n INCLUDE SYSLIB(STRINGU2)\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "TESTIN1": {"ttr": 83, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x14\\x01\\x196_\\x01 \\x00\\x1f R\\x00\\x03\\x00\\x03\\x00\\x03\\xe9\\xc1\\xe3\\xd3\\xc1\\xe2\\xf1@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2019-12-31T00:00:00", "modifydate": "2020-01-01T20:52:14", "lines": 3, "newlines": 3, "modlines": 3, "user": "ZATLAS1"}, "text": "(\\d)\\.(\\d)\n\u00a2100.05 one hundred.zero five \u00a2217.35\n\u00a2{1},\u00a2{2}\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "TRYPCRE1": {"ttr": 67, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x0b\\x006\\x01\\x17\\x04?\\x01\\x19\\x12\\x9f\\x17'\\x00\\xe0\\x00\\xc6\\x00\\x00\\xe9\\xc1\\xe3\\xd3\\xc1\\xe2\\xf1@@@\"", "ispf": {"version": "01.11", "flags": 0, "createdate": "2017-02-12T00:00:00", "modifydate": "2019-05-09T17:27:36", "lines": 224, "newlines": 198, "modlines": 0, "user": "ZATLAS1"}, "text": " /*REXX*/\n\n /*\n  This is a sample code on how to use the PEXXPCRE interface between\n  the Rexx language on z/OS and the PCRE2 - regex processing library\n  on same platform.\n  Version 0.1\n  Contributed by:   John Gateley  January 2017.\n  Copyright (c) 2017, John Gateley.\n  All rights reserved.\n\n  ---------------------------------------------------------------\n  Redistribution and use in source and binary forms, with or\n  without modification, are permitted provided that the following\n  conditions are met:\n\n   1. Redistributions of source code must retain the above\n   copyright notice, this list of conditions and the following\n   disclaimer.\n\n   2. Redistributions in binary form must reproduce the above\n   copyright notice, this list of conditions and the following\n   disclaimer in the documentation and/or other materials\n   provided with the distribution.\n\n   3. Neither the name of the University of Cambridge nor the\n   names of its contributors may be used to endorse or promote\n   products derived from this software without specific prior\n   written permission.\n\n  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND\n  CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES,\n  INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR\n  CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n  HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR\n  OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,\n  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n /* when running under TSO we first need to add the load libraries\n   to the ISPLLIB concatenation\n\n   \"ISPEXEC LIBDEF ISPLLIB DATASET ID ('MY.LOAD.LIBRARY') STACK\"      */\n\n /* in the distro environment it would be:\n   \"ISPEXEC LIBDEF ISPLLIB DATASET ID ('ZATLAS1.PCRE2.LOADLIB') STACK\"\n\n */\n\n   /*  test 1                                                  */\n\n   reg_ex  = \"(?<char>A)\\g<char>\"\n   the_str = \"AN_AARDWARK_JAKE_AND_aaRDWARK_JACK\"\n   my_stem = \"WANG\"\n   opt_ion = \"gi\"\n   code_pg = \"IBM-285\"\n\n   say the_str\n\n   drop wang.\n\n   re_sponse = REXXPCRE(reg_ex,the_str,my_stem,opt_ion)\n\n   select\n      when re_sponse = 1 then do\n         say 'wang.0  is  ' wang.0\n         do lo_op_r = 1 to wang.0\n            say  wang.string.lo_op_r\n            say  wang.pos.lo_op_r  '       '  wang.name.lo_op_r\n         end\n        end\n      when re_sponse = 0 then\n         say 'no matches found'\n      Otherwise\n         say 'Error :' re_sponse\n   end\n\n   drop wang.\n\n   say '  '\n\n   /*  test 2                                                  */\n\n   the_str = \"The quick brown fox jumps over the lazy dog.\"\n   the_Str = the_str||\"The quick brown fox jumps over the\"\n   reg_ex  = \"(quick|jump)\"\n   my_stem = \"WANG\"\n\n   say the_str\n\n   /* no option specified but use debug mode                   */\n\n   re_sponse = REXXPCRE(reg_ex,the_str,my_stem,,,'debug')\n\n   select\n      when re_sponse = 1 then do\n         say 'wang.0  is  ' wang.0\n         do lo_op_r = 1 to wang.0\n            say  wang.string.lo_op_r\n            say  wang.pos.lo_op_r  '       '  wang.name.lo_op_r\n         end\n        end\n      when re_sponse = 0 then\n         say 'no matches found'\n      Otherwise\n         say 'Error :' re_sponse\n   end\n\n   drop wang.\n\n   say '  '\n\n   /*  test 3                                                  */\n\n   the_str = \"A fat cat doesn't eat oat but a rat eats bats.\"\n   reg_ex  = \"(at)\"\n   my_stem = \"WANG\"\n   opt_ion = \"g\"\n\n   say the_str\n\n   re_sponse = REXXPCRE(reg_ex,the_str,my_stem,opt_ion)\n\n   select\n      when re_sponse = 1 then do\n         say 'wang.0  is  ' wang.0\n         do lo_op_r = 1 to wang.0\n            say  wang.string.lo_op_r\n            say  wang.pos.lo_op_r  '       '  wang.name.lo_op_r\n         end\n        end\n      when re_sponse = 0 then\n         say 'no matches found'\n      Otherwise\n         say 'Error :' re_sponse\n   end\n\n   drop wang.\n\n   /*  test 4                                                  */\n\n   the_str = \"He_jumps_brown_fox\"\n   reg_ex  = \"(?<first>quick|jumps_+(?<second>brown|over)_+(fox|the))\"\n   my_stem = \"WANG\"\n\n   say the_str\n\n   re_sponse = REXXPCRE(reg_ex,the_str,my_stem,'g')\n\n   select\n      when re_sponse = 1 then do\n         say 'wang.0  is  ' wang.0\n         do lo_op_r = 1 to wang.0\n            say  wang.string.lo_op_r\n            say  wang.pos.lo_op_r  '       '  wang.name.lo_op_r\n         end\n        end\n      when re_sponse = 0 then\n         say 'no matches found'\n      Otherwise\n         say 'Error :' re_sponse\n   end\n\n   /*  test 5                                                  */\n   /*                                                          */\n   /*  this test uses the dollar symbol which is code page     */\n   /*  dependant in EBCDIC. In IBM-037 the dollar is x'5B'     */\n   /*  but in IBM-285 (UK) this is the currency symbol         */\n   /*  for GBP and the dollar is at x'4A' which is the cent    */\n   /*  symbol in IBM-037. Confusing!                           */\n   /*  Internally PCRE2 uses IBM-1047 so to use the dollar     */\n   /*  symbol in the regex we pass a fifth argument which      */\n   /*  is the code page name we are actually using.            */\n   /*  This causes PCRE to convert the regex from IBM-285      */\n   /*  to IBM-1047 before it is compiled, similarly the        */\n   /*  string is converted before the match is done.           */\n\n   /*  NOTE - this argument is only required if you use        */\n   /*         a code page in your terminal emulator which      */\n   /*         is NOT the same as the default local code page.  */\n   /*         Normal processing by PCRE is to convert the      */\n   /*         REGEX and string from the default local code     */\n   /*         page to IBM-1047.                                */\n   /*         IBM-1047 is used by the mainframe C compiler.    */\n\n   pa_rm    = \"INDSN(DSNAME(MEMBER))\"\n\n   reg_ex  = \"\\((.*)\\)\u00a2\"\n   opt_ion = \"g\"\n\n   say pa_rm\n   say reg_ex\n\n   re_sponse = REXXPCRE(reg_ex,pa_rm,'wang',opt_ion,'IBM-285')\n\n   select\n      when re_sponse = 1 then do\n         say 'wang.0  is  ' wang.0\n         do lo_op_r = 1 to wang.0\n            var_1  =  substr(wang_string.lo_op_r,1,30)\n            var_2  =  substr(wang_pos.lo_op_r,1,10)\n            var_3  =  wang_name.lo_op_r\n            say  var_1 var_2 var_3\n         end\n        end\n      when re_sponse = 0 then\n         say 'no matches found'\n      Otherwise\n         say 'Error :' re_sponse\n   end\n\n   drop wang.\n\n /* under TSO, (see above) add this\n   \"ispexec libdef ispllib \"\n */\n\n   exit\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT939/CBT.V500.FILE939.PDS/CNTL.xmi", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT939/CBT.V500.FILE939.PDS", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}