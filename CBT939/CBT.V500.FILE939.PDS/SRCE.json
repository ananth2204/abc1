{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "ZATLAS1", "INMTNODE": "A", "INMTUID": "ZATLAS1", "INMFTIME": "20200906020836000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 3762304, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 255, "INMBLKSZ": 27998, "INMRECFM": "VB", "INMDIR": 8, "INMDSNAM": "ZATLAS1.PCRE2.SRCE", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 3762304, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 3762304, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"ZATLAS1.PCRE2.SRCE": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 27998, "DS1LRECL": 255, "DS1RECFM": "VB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12304, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3000, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "200246", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\x0f'", "DS1LSTAR": "b'\\x009\\x04'", "DS1TRBAL": "b'^*'"}, "COPYR2": {"deb": "b'\\r\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x0c\\xd0\\x00\\x04z\\xebH'", "extents": ["b'\\r\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x0c\\xd0\\x00\\x04z\\xebH'", "b'P|\\xf28\\x00\\x00\\x00\\x96\\x00\\x00\\x00\\x9d\\x00\\x0e\\x00x'", "b'P|\\xf28\\x00\\x00\\x00\\\\\\x00\\x00\\x00\\\\\\x00\\x0e\\x00\\x0f'", "b'P|\\xf28\\x00\\x00\\x00]\\x00\\x00\\x00]\\x00\\x0e\\x00\\x0f'", "b'X|\\xf28\\x00\\x00\\x0bO\\x00\\n\\x0bP\\x00\\t\\x00\\x0f'", "b'X|\\xf28\\x00\\x00\\x0bP\\x00\\n\\x0bQ\\x00\\t\\x00\\x0f'", "b'X|\\xf28\\x00\\x00\\x0bQ\\x00\\n\\x0bR\\x00\\t\\x00\\x0f'", "b'X|\\xf28\\x00\\x00\\x0bR\\x00\\n\\x0bS\\x00\\t\\x00\\x0f'", "b'X|\\xf28\\x00\\x00\\x0bS\\x00\\n\\x0bT\\x00\\t\\x00\\x0f'", "b'X|\\xf28\\x00\\x00\\x0bT\\x00\\n\\x0bU\\x00\\t\\x00\\x0f'", "b'X|\\xf28\\x00\\x00\\x0be\\x00\\n\\x0bf\\x00\\t\\x00\\x0f'", "b'X|\\xf28\\x00\\x00\\x0bf\\x00\\n\\x0bg\\x00\\t\\x00\\x0f'", "b'X|\\xf28\\x00\\x00\\x0bg\\x00\\n\\x0bh\\x00\\t\\x00\\x0f'", "b'X|\\xf28\\x00\\x00\\x0bh\\x00\\n\\x0bi\\x00\\t\\x00\\x0f'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"AUTOPOS2": {"ttr": 12545, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "\n/*************************************************\n*      Perl-Compatible Regular Expressions       *\n*************************************************/\n\n/* PCRE is a library of functions to support regular expressions whose syntax\nand semantics are as close as possible to those of the Perl 5 language.\n\n                       Written by Philip Hazel\n     Original API code Copyright (c) 1997-2012 University of Cambridge\n          New API code Copyright (c) 2016-2020 University of Cambridge\n\n-----------------------------------------------------------------------------\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n\n    * Redistributions of source code must retain the above copyright notice,\n      this list of conditions and the following disclaimer.\n\n    * Redistributions in binary form must reproduce the above copyright\n      notice, this list of conditions and the following disclaimer in the\n      documentation and/or other materials provided with the distribution.\n\n    * Neither the name of the University of Cambridge nor the names of its\n      contributors may be used to endorse or promote products derived from\n      this software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\nAND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\nIMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\nARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\nLIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\nCONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\nSUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\nINTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\nCONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\nARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\nPOSSIBILITY OF SUCH DAMAGE.\n-----------------------------------------------------------------------------\n*/\n\n/* This module contains functions that scan a compiled pattern and change\nrepeats into possessive repeats where possible. */\n\n\n#ifdef HAVE_CONFIG_H\n#include \"CONFIG.h\"\n#endif\n\n\n#include \"INTERNA2.h\"\n\n\n/*************************************************\n*        Tables for auto-possessification        *\n*************************************************/\n\n/* This table is used to check whether auto-possessification is possible\nbetween adjacent character-type opcodes. The left-hand (repeated) opcode is\nused to select the row, and the right-hand opcode is use to select the column.\nA value of 1 means that auto-possessification is OK. For example, the second\nvalue in the first row means that \\D+\\d can be turned into \\D++\\d.\n\nThe Unicode property types (\\P and \\p) have to be present to fill out the table\nbecause of what their opcode values are, but the table values should always be\nzero because property types are handled separately in the code. The last four\ncolumns apply to items that cannot be repeated, so there is no need to have\nrows for them. Note that OP_DIGIT etc. are generated only when PCRE_UCP is\n*not* set. When it is set, \\d etc. are converted into OP_(NOT_)PROP codes. */\n\n#define APTROWS (LAST_AUTOTAB_LEFT_OP - FIRST_AUTOTAB_OP + 1)\n#define APTCOLS (LAST_AUTOTAB_RIGHT_OP - FIRST_AUTOTAB_OP + 1)\n\nstatic const uint8_t autoposstab\u00ddAPTROWS\u00a8\u00ddAPTCOLS\u00a8 = {\n/* \\D \\d \\S \\s \\W \\w  . .+ \\C \\P \\p \\R \\H \\h \\V \\v \\X \\Z \\z  $ $M */\n  { 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0 },  /* \\D */\n  { 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1 },  /* \\d */\n  { 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1 },  /* \\S */\n  { 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0 },  /* \\s */\n  { 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0 },  /* \\W */\n  { 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1 },  /* \\w */\n  { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0 },  /* .  */\n  { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0 },  /* .+ */\n  { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0 },  /* \\C */\n  { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },  /* \\P */\n  { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },  /* \\p */\n  { 0, 1, 0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0 },  /* \\R */\n  { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0 },  /* \\H */\n  { 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 1, 0, 0 },  /* \\h */\n  { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 0 },  /* \\V */\n  { 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0 },  /* \\v */\n  { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0 }   /* \\X */\n};\n\n#ifdef SUPPORT_UNICODE\n/* This table is used to check whether auto-possessification is possible\nbetween adjacent Unicode property opcodes (OP_PROP and OP_NOTPROP). The\nleft-hand (repeated) opcode is used to select the row, and the right-hand\nopcode is used to select the column. The values are as follows:\n\n  0   Always return FALSE (never auto-possessify)\n  1   Character groups are distinct (possessify if both are OP_PROP)\n  2   Check character categories in the same group (general or particular)\n  3   TRUE if the two opcodes are not the same (PROP vs NOTPROP)\n\n  4   Check left general category vs right particular category\n  5   Check right general category vs left particular category\n\n  6   Left alphanum vs right general category\n  7   Left space vs right general category\n  8   Left word vs right general category\n\n  9   Right alphanum vs left general category\n 10   Right space vs left general category\n 11   Right word vs left general category\n\n 12   Left alphanum vs right particular category\n 13   Left space vs right particular category\n 14   Left word vs right particular category\n\n 15   Right alphanum vs left particular category\n 16   Right space vs left particular category\n 17   Right word vs left particular category\n*/\n\nstatic const uint8_t propposstab\u00ddPT_TABSIZE\u00a8\u00ddPT_TABSIZE\u00a8 = {\n/* ANY LAMP GC  PC  SC ALNUM SPACE PXSPACE WORD CLIST UCNC */\n  { 0,  0,  0,  0,  0,    0,    0,      0,   0,    0,   0 },  /* PT_ANY */\n  { 0,  3,  0,  0,  0,    3,    1,      1,   0,    0,   0 },  /* PT_LAMP */\n  { 0,  0,  2,  4,  0,    9,   10,     10,  11,    0,   0 },  /* PT_GC */\n  { 0,  0,  5,  2,  0,   15,   16,     16,  17,    0,   0 },  /* PT_PC */\n  { 0,  0,  0,  0,  2,    0,    0,      0,   0,    0,   0 },  /* PT_SC */\n  { 0,  3,  6, 12,  0,    3,    1,      1,   0,    0,   0 },  /* PT_ALNUM */\n  { 0,  1,  7, 13,  0,    1,    3,      3,   1,    0,   0 },  /* PT_SPACE */\n  { 0,  1,  7, 13,  0,    1,    3,      3,   1,    0,   0 },  /* PT_PXSPACE */\n  { 0,  0,  8, 14,  0,    0,    1,      1,   3,    0,   0 },  /* PT_WORD */\n  { 0,  0,  0,  0,  0,    0,    0,      0,   0,    0,   0 },  /* PT_CLIST */\n  { 0,  0,  0,  0,  0,    0,    0,      0,   0,    0,   3 }   /* PT_UCNC */\n};\n\n/* This table is used to check whether auto-possessification is possible\nbetween adjacent Unicode property opcodes (OP_PROP and OP_NOTPROP) when one\nspecifies a general category and the other specifies a particular category. The\nrow is selected by the general category and the column by the particular\ncategory. The value is 1 if the particular category is not part of the general\ncategory. */\n\nstatic const uint8_t catposstab\u00dd7\u00a8\u00dd30\u00a8 = {\n/* Cc Cf Cn Co Cs Ll Lm Lo Lt Lu Mc Me Mn Nd Nl No Pc Pd Pe Pf Pi Po Ps Sc Sk Sm So Zl Zp Zs */\n  { 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 },  /* C */\n  { 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 },  /* L */\n  { 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 },  /* M */\n  { 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 },  /* N */\n  { 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1 },  /* P */\n  { 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1 },  /* S */\n  { 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0 }   /* Z */\n};\n\n/* This table is used when checking ALNUM, (PX)SPACE, SPACE, and WORD against\na general or particular category. The properties in each row are those\nthat apply to the character set in question. Duplication means that a little\nunnecessary work is done when checking, but this keeps things much simpler\nbecause they can all use the same code. For more details see the comment where\nthis table is used.\n\nNote: SPACE and PXSPACE used to be different because Perl excluded VT from\n\"space\", but from Perl 5.18 it's included, so both categories are treated the\nsame here. */\n\nstatic const uint8_t posspropstab\u00dd3\u00a8\u00dd4\u00a8 = {\n  { ucp_L, ucp_N, ucp_N, ucp_Nl },  /* ALNUM, 3rd and 4th values redundant */\n  { ucp_Z, ucp_Z, ucp_C, ucp_Cc },  /* SPACE and PXSPACE, 2nd value redundant */\n  { ucp_L, ucp_N, ucp_P, ucp_Po }   /* WORD */\n};\n#endif  /* SUPPORT_UNICODE */\n\n\n\n#ifdef SUPPORT_UNICODE\n/*************************************************\n*        Check a character and a property        *\n*************************************************/\n\n/* This function is called by compare_opcodes() when a property item is\nadjacent to a fixed character.\n\nArguments:\n  c            the character\n  ptype        the property type\n  pdata        the data for the type\n  negated      TRUE if it's a negated property (\\P or \\p{\u00ac)\n\nReturns:       TRUE if auto-possessifying is OK\n*/\n\nstatic BOOL\ncheck_char_prop(uint32_t c, unsigned int ptype, unsigned int pdata,\n  BOOL negated)\n{\nconst uint32_t *p;\nconst ucd_record *prop = GET_UCD(c);\n\nswitch(ptype)\n  {\n  case PT_LAMP:\n  return (prop->chartype == ucp_Lu ||\n          prop->chartype == ucp_Ll ||\n          prop->chartype == ucp_Lt) == negated;\n\n  case PT_GC:\n  return (pdata == PRIV(ucp_gentype)\u00ddprop->chartype\u00a8) == negated;\n\n  case PT_PC:\n  return (pdata == prop->chartype) == negated;\n\n  case PT_SC:\n  return (pdata == prop->script) == negated;\n\n  /* These are specials */\n\n  case PT_ALNUM:\n  return (PRIV(ucp_gentype)\u00ddprop->chartype\u00a8 == ucp_L ||\n          PRIV(ucp_gentype)\u00ddprop->chartype\u00a8 == ucp_N) == negated;\n\n  /* Perl space used to exclude VT, but from Perl 5.18 it is included, which\n  means that Perl space and POSIX space are now identical. PCRE was changed\n  at release 8.34. */\n\n  case PT_SPACE:    /* Perl space */\n  case PT_PXSPACE:  /* POSIX space */\n  switch(c)\n    {\n    HSPACE_CASES:\n    VSPACE_CASES:\n    return negated;\n\n    default:\n    return (PRIV(ucp_gentype)\u00ddprop->chartype\u00a8 == ucp_Z) == negated;\n    }\n  break;  /* Control never reaches here */\n\n  case PT_WORD:\n  return (PRIV(ucp_gentype)\u00ddprop->chartype\u00a8 == ucp_L ||\n          PRIV(ucp_gentype)\u00ddprop->chartype\u00a8 == ucp_N ||\n          c == CHAR_UNDERSCORE) == negated;\n\n  case PT_CLIST:\n  p = PRIV(ucd_caseless_sets) + prop->caseset;\n  for (;;)\n    {\n    if (c < *p) return !negated;\n    if (c == *p++) return negated;\n    }\n  break;  /* Control never reaches here */\n  }\n\nreturn FALSE;\n}\n#endif  /* SUPPORT_UNICODE */\n\n\n\n/*************************************************\n*        Base opcode of repeated opcodes         *\n*************************************************/\n\n/* Returns the base opcode for repeated single character type opcodes. If the\nopcode is not a repeated character type, it returns with the original value.\n\nArguments:  c opcode\nReturns:    base opcode for the type\n*/\n\nstatic PCRE2_UCHAR\nget_repeat_base(PCRE2_UCHAR c)\n{\nreturn (c > OP_TYPEPOSUPTO)? c :\n       (c >= OP_TYPESTAR)?   OP_TYPESTAR :\n       (c >= OP_NOTSTARI)?   OP_NOTSTARI :\n       (c >= OP_NOTSTAR)?    OP_NOTSTAR :\n       (c >= OP_STARI)?      OP_STARI :\n                             OP_STAR;\n}\n\n\n/*************************************************\n*        Fill the character property list        *\n*************************************************/\n\n/* Checks whether the code points to an opcode that can take part in auto-\npossessification, and if so, fills a list with its properties.\n\nArguments:\n  code        points to start of expression\n  utf         TRUE if in UTF mode\n  ucp         TRUE if in UCP mode\n  fcc         points to the case-flipping table\n  list        points to output list\n              list\u00dd0\u00a8 will be filled with the opcode\n              list\u00dd1\u00a8 will be non-zero if this opcode\n                can match an empty character string\n              list\u00dd2..7\u00a8 depends on the opcode\n\nReturns:      points to the start of the next opcode if *code is accepted\n              NULL if *code is not accepted\n*/\n\nstatic PCRE2_SPTR\nget_chr_property_list(PCRE2_SPTR code, BOOL utf, BOOL ucp, const uint8_t *fcc,\n  uint32_t *list)\n{\nPCRE2_UCHAR c = *code;\nPCRE2_UCHAR base;\nPCRE2_SPTR end;\nuint32_t chr;\n\n#ifdef SUPPORT_UNICODE\nuint32_t *clist_dest;\nconst uint32_t *clist_src;\n#else\n(void)utf;    /* Suppress \"unused parameter\" compiler warnings */\n(void)ucp;\n#endif\n\nlist\u00dd0\u00a8 = c;\nlist\u00dd1\u00a8 = FALSE;\ncode++;\n\nif (c >= OP_STAR && c <= OP_TYPEPOSUPTO)\n  {\n  base = get_repeat_base(c);\n  c -= (base - OP_STAR);\n\n  if (c == OP_UPTO || c == OP_MINUPTO || c == OP_EXACT || c == OP_POSUPTO)\n    code += IMM2_SIZE;\n\n  list\u00dd1\u00a8 = (c != OP_PLUS && c != OP_MINPLUS && c != OP_EXACT &&\n             c != OP_POSPLUS);\n\n  switch(base)\n    {\n    case OP_STAR:\n    list\u00dd0\u00a8 = OP_CHAR;\n    break;\n\n    case OP_STARI:\n    list\u00dd0\u00a8 = OP_CHARI;\n    break;\n\n    case OP_NOTSTAR:\n    list\u00dd0\u00a8 = OP_NOT;\n    break;\n\n    case OP_NOTSTARI:\n    list\u00dd0\u00a8 = OP_NOTI;\n    break;\n\n    case OP_TYPESTAR:\n    list\u00dd0\u00a8 = *code;\n    code++;\n    break;\n    }\n  c = list\u00dd0\u00a8;\n  }\n\nswitch(c)\n  {\n  case OP_NOT_DIGIT:\n  case OP_DIGIT:\n  case OP_NOT_WHITESPACE:\n  case OP_WHITESPACE:\n  case OP_NOT_WORDCHAR:\n  case OP_WORDCHAR:\n  case OP_ANY:\n  case OP_ALLANY:\n  case OP_ANYNL:\n  case OP_NOT_HSPACE:\n  case OP_HSPACE:\n  case OP_NOT_VSPACE:\n  case OP_VSPACE:\n  case OP_EXTUNI:\n  case OP_EODN:\n  case OP_EOD:\n  case OP_DOLL:\n  case OP_DOLLM:\n  return code;\n\n  case OP_CHAR:\n  case OP_NOT:\n  GETCHARINCTEST(chr, code);\n  list\u00dd2\u00a8 = chr;\n  list\u00dd3\u00a8 = NOTACHAR;\n  return code;\n\n  case OP_CHARI:\n  case OP_NOTI:\n  list\u00dd0\u00a8 = (c == OP_CHARI) ? OP_CHAR : OP_NOT;\n  GETCHARINCTEST(chr, code);\n  list\u00dd2\u00a8 = chr;\n\n#ifdef SUPPORT_UNICODE\n  if (chr < 128 || (chr < 256 && !utf && !ucp))\n    list\u00dd3\u00a8 = fcc\u00ddchr\u00a8;\n  else\n    list\u00dd3\u00a8 = UCD_OTHERCASE(chr);\n#elif defined SUPPORT_WIDE_CHARS\n  list\u00dd3\u00a8 = (chr < 256) ? fcc\u00ddchr\u00a8 : chr;\n#else\n  list\u00dd3\u00a8 = fcc\u00ddchr\u00a8;\n#endif\n\n  /* The othercase might be the same value. */\n\n  if (chr == list\u00dd3\u00a8)\n    list\u00dd3\u00a8 = NOTACHAR;\n  else\n    list\u00dd4\u00a8 = NOTACHAR;\n  return code;\n\n#ifdef SUPPORT_UNICODE\n  case OP_PROP:\n  case OP_NOTPROP:\n  if (code\u00dd0\u00a8 != PT_CLIST)\n    {\n    list\u00dd2\u00a8 = code\u00dd0\u00a8;\n    list\u00dd3\u00a8 = code\u00dd1\u00a8;\n    return code + 2;\n    }\n\n  /* Convert only if we have enough space. */\n\n  clist_src = PRIV(ucd_caseless_sets) + code\u00dd1\u00a8;\n  clist_dest = list + 2;\n  code += 2;\n\n  do {\n     if (clist_dest >= list + 8)\n       {\n       /* Early return if there is not enough space. This should never\n       happen, since all clists are shorter than 5 character now. */\n       list\u00dd2\u00a8 = code\u00dd0\u00a8;\n       list\u00dd3\u00a8 = code\u00dd1\u00a8;\n       return code;\n       }\n     *clist_dest++ = *clist_src;\n     }\n  while(*clist_src++ != NOTACHAR);\n\n  /* All characters are stored. The terminating NOTACHAR is copied from the\n  clist itself. */\n\n  list\u00dd0\u00a8 = (c == OP_PROP) ? OP_CHAR : OP_NOT;\n  return code;\n#endif\n\n  case OP_NCLASS:\n  case OP_CLASS:\n#ifdef SUPPORT_WIDE_CHARS\n  case OP_XCLASS:\n  if (c == OP_XCLASS)\n    end = code + GET(code, 0) - 1;\n  else\n#endif\n    end = code + 32 / sizeof(PCRE2_UCHAR);\n\n  switch(*end)\n    {\n    case OP_CRSTAR:\n    case OP_CRMINSTAR:\n    case OP_CRQUERY:\n    case OP_CRMINQUERY:\n    case OP_CRPOSSTAR:\n    case OP_CRPOSQUERY:\n    list\u00dd1\u00a8 = TRUE;\n    end++;\n    break;\n\n    case OP_CRPLUS:\n    case OP_CRMINPLUS:\n    case OP_CRPOSPLUS:\n    end++;\n    break;\n\n    case OP_CRRANGE:\n    case OP_CRMINRANGE:\n    case OP_CRPOSRANGE:\n    list\u00dd1\u00a8 = (GET2(end, 1) == 0);\n    end += 1 + 2 * IMM2_SIZE;\n    break;\n    }\n  list\u00dd2\u00a8 = (uint32_t)(end - code);\n  return end;\n  }\nreturn NULL;    /* Opcode not accepted */\n}\n\n\n\n/*************************************************\n*    Scan further character sets for match       *\n*************************************************/\n\n/* Checks whether the base and the current opcode have a common character, in\nwhich case the base cannot be possessified.\n\nArguments:\n  code        points to the byte code\n  utf         TRUE in UTF mode\n  ucp         TRUE in UCP mode\n  cb          compile data block\n  base_list   the data list of the base opcode\n  base_end    the end of the base opcode\n  rec_limit   points to recursion depth counter\n\nReturns:      TRUE if the auto-possessification is possible\n*/\n\nstatic BOOL\ncompare_opcodes(PCRE2_SPTR code, BOOL utf, BOOL ucp, const compile_block *cb,\n  const uint32_t *base_list, PCRE2_SPTR base_end, int *rec_limit)\n{\nPCRE2_UCHAR c;\nuint32_t list\u00dd8\u00a8;\nconst uint32_t *chr_ptr;\nconst uint32_t *ochr_ptr;\nconst uint32_t *list_ptr;\nPCRE2_SPTR next_code;\n#ifdef SUPPORT_WIDE_CHARS\nPCRE2_SPTR xclass_flags;\n#endif\nconst uint8_t *class_bitset;\nconst uint8_t *set1, *set2, *set_end;\nuint32_t chr;\nBOOL accepted, invert_bits;\nBOOL entered_a_group = FALSE;\n\nif (--(*rec_limit) <= 0) return FALSE;  /* Recursion has gone too deep */\n\n/* Note: the base_list\u00dd1\u00a8 contains whether the current opcode has a greedy\n(represented by a non-zero value) quantifier. This is a different from\nother character type lists, which store here that the character iterator\nmatches to an empty string (also represented by a non-zero value). */\n\nfor(;;)\n  {\n  /* All operations move the code pointer forward.\n  Therefore infinite recursions are not possible. */\n\n  c = *code;\n\n  /* Skip over callouts */\n\n  if (c == OP_CALLOUT)\n    {\n    code += PRIV(OP_lengths)\u00ddc\u00a8;\n    continue;\n    }\n\n  if (c == OP_CALLOUT_STR)\n    {\n    code += GET(code, 1 + 2*LINK_SIZE);\n    continue;\n    }\n\n  /* At the end of a branch, skip to the end of the group. */\n\n  if (c == OP_ALT)\n    {\n    do code += GET(code, 1); while (*code == OP_ALT);\n    c = *code;\n    }\n\n  /* Inspect the next opcode. */\n\n  switch(c)\n    {\n    /* We can always possessify a greedy iterator at the end of the pattern,\n    which is reached after skipping over the final OP_KET. A non-greedy\n    iterator must never be possessified. */\n\n    case OP_END:\n    return base_list\u00dd1\u00a8 != 0;\n\n    /* When an iterator is at the end of certain kinds of group we can inspect\n    what follows the group by skipping over the closing ket. Note that this\n    does not apply to OP_KETRMAX or OP_KETRMIN because what follows any given\n    iteration is variable (could be another iteration or could be the next\n    item). As these two opcodes are not listed in the next switch, they will\n    end up as the next code to inspect, and return FALSE by virtue of being\n    unsupported. */\n\n    case OP_KET:\n    case OP_KETRPOS:\n    /* The non-greedy case cannot be converted to a possessive form. */\n\n    if (base_list\u00dd1\u00a8 == 0) return FALSE;\n\n    /* If the bracket is capturing it might be referenced by an OP_RECURSE\n    so its last iterator can never be possessified if the pattern contains\n    recursions. (This could be improved by keeping a list of group numbers that\n    are called by recursion.) */\n\n    switch(*(code - GET(code, 1)))\n      {\n      case OP_CBRA:\n      case OP_SCBRA:\n      case OP_CBRAPOS:\n      case OP_SCBRAPOS:\n      if (cb->had_recurse) return FALSE;\n      break;\n\n      /* A script run might have to backtrack if the iterated item can match\n      characters from more than one script. So give up unless repeating an\n      explicit character. */\n\n      case OP_SCRIPT_RUN:\n      if (base_list\u00dd0\u00a8 != OP_CHAR && base_list\u00dd0\u00a8 != OP_CHARI)\n        return FALSE;\n      break;\n\n      /* Atomic sub-patterns and assertions can always auto-possessify their\n      last iterator. However, if the group was entered as a result of checking\n      a previous iterator, this is not possible. */\n\n      case OP_ASSERT:\n      case OP_ASSERT_NOT:\n      case OP_ASSERTBACK:\n      case OP_ASSERTBACK_NOT:\n      case OP_ONCE:\n      return !entered_a_group;\n\n      /* Non-atomic assertions - don't possessify last iterator. This needs\n      more thought. */\n\n      case OP_ASSERT_NA:\n      case OP_ASSERTBACK_NA:\n      return FALSE;\n      }\n\n    /* Skip over the bracket and inspect what comes next. */\n\n    code += PRIV(OP_lengths)\u00ddc\u00a8;\n    continue;\n\n    /* Handle cases where the next item is a group. */\n\n    case OP_ONCE:\n    case OP_BRA:\n    case OP_CBRA:\n    next_code = code + GET(code, 1);\n    code += PRIV(OP_lengths)\u00ddc\u00a8;\n\n    /* Check each branch. We have to recurse a level for all but the last\n    branch. */\n\n    while (*next_code == OP_ALT)\n      {\n      if (!compare_opcodes(code, utf, ucp, cb, base_list, base_end, rec_limit))\n        return FALSE;\n      code = next_code + 1 + LINK_SIZE;\n      next_code += GET(next_code, 1);\n      }\n\n    entered_a_group = TRUE;\n    continue;\n\n    case OP_BRAZERO:\n    case OP_BRAMINZERO:\n\n    next_code = code + 1;\n    if (*next_code != OP_BRA && *next_code != OP_CBRA &&\n        *next_code != OP_ONCE) return FALSE;\n\n    do next_code += GET(next_code, 1); while (*next_code == OP_ALT);\n\n    /* The bracket content will be checked by the OP_BRA/OP_CBRA case above. */\n\n    next_code += 1 + LINK_SIZE;\n    if (!compare_opcodes(next_code, utf, ucp, cb, base_list, base_end,\n         rec_limit))\n      return FALSE;\n\n    code += PRIV(OP_lengths)\u00ddc\u00a8;\n    continue;\n\n    /* The next opcode does not need special handling; fall through and use it\n    to see if the base can be possessified. */\n\n    default:\n    break;\n    }\n\n  /* We now have the next appropriate opcode to compare with the base. Check\n  for a supported opcode, and load its properties. */\n\n  code = get_chr_property_list(code, utf, ucp, cb->fcc, list);\n  if (code == NULL) return FALSE;    /* Unsupported */\n\n  /* If either opcode is a small character list, set pointers for comparing\n  characters from that list with another list, or with a property. */\n\n  if (base_list\u00dd0\u00a8 == OP_CHAR)\n    {\n    chr_ptr = base_list + 2;\n    list_ptr = list;\n    }\n  else if (list\u00dd0\u00a8 == OP_CHAR)\n    {\n    chr_ptr = list + 2;\n    list_ptr = base_list;\n    }\n\n  /* Character bitsets can also be compared to certain opcodes. */\n\n  else if (base_list\u00dd0\u00a8 == OP_CLASS || list\u00dd0\u00a8 == OP_CLASS\n#if PCRE2_CODE_UNIT_WIDTH == 8\n      /* In 8 bit, non-UTF mode, OP_CLASS and OP_NCLASS are the same. */\n      || (!utf && (base_list\u00dd0\u00a8 == OP_NCLASS || list\u00dd0\u00a8 == OP_NCLASS))\n#endif\n      )\n    {\n#if PCRE2_CODE_UNIT_WIDTH == 8\n    if (base_list\u00dd0\u00a8 == OP_CLASS || (!utf && base_list\u00dd0\u00a8 == OP_NCLASS))\n#else\n    if (base_list\u00dd0\u00a8 == OP_CLASS)\n#endif\n      {\n      set1 = (uint8_t *)(base_end - base_list\u00dd2\u00a8);\n      list_ptr = list;\n      }\n    else\n      {\n      set1 = (uint8_t *)(code - list\u00dd2\u00a8);\n      list_ptr = base_list;\n      }\n\n    invert_bits = FALSE;\n    switch(list_ptr\u00dd0\u00a8)\n      {\n      case OP_CLASS:\n      case OP_NCLASS:\n      set2 = (uint8_t *)\n        ((list_ptr == list ? code : base_end) - list_ptr\u00dd2\u00a8);\n      break;\n\n#ifdef SUPPORT_WIDE_CHARS\n      case OP_XCLASS:\n      xclass_flags = (list_ptr == list ? code : base_end) - list_ptr\u00dd2\u00a8 + LINK_SIZE;\n      if ((*xclass_flags & XCL_HASPROP) != 0) return FALSE;\n      if ((*xclass_flags & XCL_MAP) == 0)\n        {\n        /* No bits are set for characters < 256. */\n        if (list\u00dd1\u00a8 == 0) return (*xclass_flags & XCL_NOT) == 0;\n        /* Might be an empty repeat. */\n        continue;\n        }\n      set2 = (uint8_t *)(xclass_flags + 1);\n      break;\n#endif\n\n      case OP_NOT_DIGIT:\n      invert_bits = TRUE;\n      /* Fall through */\n      case OP_DIGIT:\n      set2 = (uint8_t *)(cb->cbits + cbit_digit);\n      break;\n\n      case OP_NOT_WHITESPACE:\n      invert_bits = TRUE;\n      /* Fall through */\n      case OP_WHITESPACE:\n      set2 = (uint8_t *)(cb->cbits + cbit_space);\n      break;\n\n      case OP_NOT_WORDCHAR:\n      invert_bits = TRUE;\n      /* Fall through */\n      case OP_WORDCHAR:\n      set2 = (uint8_t *)(cb->cbits + cbit_word);\n      break;\n\n      default:\n      return FALSE;\n      }\n\n    /* Because the bit sets are unaligned bytes, we need to perform byte\n    comparison here. */\n\n    set_end = set1 + 32;\n    if (invert_bits)\n      {\n      do\n        {\n        if ((*set1++ & ~(*set2++)) != 0) return FALSE;\n        }\n      while (set1 < set_end);\n      }\n    else\n      {\n      do\n        {\n        if ((*set1++ & *set2++) != 0) return FALSE;\n        }\n      while (set1 < set_end);\n      }\n\n    if (list\u00dd1\u00a8 == 0) return TRUE;\n    /* Might be an empty repeat. */\n    continue;\n    }\n\n  /* Some property combinations also acceptable. Unicode property opcodes are\n  processed specially; the rest can be handled with a lookup table. */\n\n  else\n    {\n    uint32_t leftop, rightop;\n\n    leftop = base_list\u00dd0\u00a8;\n    rightop = list\u00dd0\u00a8;\n\n#ifdef SUPPORT_UNICODE\n    accepted = FALSE; /* Always set in non-unicode case. */\n    if (leftop == OP_PROP || leftop == OP_NOTPROP)\n      {\n      if (rightop == OP_EOD)\n        accepted = TRUE;\n      else if (rightop == OP_PROP || rightop == OP_NOTPROP)\n        {\n        int n;\n        const uint8_t *p;\n        BOOL same = leftop == rightop;\n        BOOL lisprop = leftop == OP_PROP;\n        BOOL risprop = rightop == OP_PROP;\n        BOOL bothprop = lisprop && risprop;\n\n        /* There's a table that specifies how each combination is to be\n        processed:\n          0   Always return FALSE (never auto-possessify)\n          1   Character groups are distinct (possessify if both are OP_PROP)\n          2   Check character categories in the same group (general or particular)\n          3   Return TRUE if the two opcodes are not the same\n          ... see comments below\n        */\n\n        n = propposstab\u00ddbase_list\u00dd2\u00a8\u00a8\u00ddlist\u00dd2\u00a8\u00a8;\n        switch(n)\n          {\n          case 0: break;\n          case 1: accepted = bothprop; break;\n          case 2: accepted = (base_list\u00dd3\u00a8 == list\u00dd3\u00a8) != same; break;\n          case 3: accepted = !same; break;\n\n          case 4:  /* Left general category, right particular category */\n          accepted = risprop && catposstab\u00ddbase_list\u00dd3\u00a8\u00a8\u00ddlist\u00dd3\u00a8\u00a8 == same;\n          break;\n\n          case 5:  /* Right general category, left particular category */\n          accepted = lisprop && catposstab\u00ddlist\u00dd3\u00a8\u00a8\u00ddbase_list\u00dd3\u00a8\u00a8 == same;\n          break;\n\n          /* This code is logically tricky. Think hard before fiddling with it.\n          The posspropstab table has four entries per row. Each row relates to\n          one of PCRE's special properties such as ALNUM or SPACE or WORD.\n          Only WORD actually needs all four entries, but using repeats for the\n          others means they can all use the same code below.\n\n          The first two entries in each row are Unicode general categories, and\n          apply always, because all the characters they include are part of the\n          PCRE character set. The third and fourth entries are a general and a\n          particular category, respectively, that include one or more relevant\n          characters. One or the other is used, depending on whether the check\n          is for a general or a particular category. However, in both cases the\n          category contains more characters than the specials that are defined\n          for the property being tested against. Therefore, it cannot be used\n          in a NOTPROP case.\n\n          Example: the row for WORD contains ucp_L, ucp_N, ucp_P, ucp_Po.\n          Underscore is covered by ucp_P or ucp_Po. */\n\n          case 6:  /* Left alphanum vs right general category */\n          case 7:  /* Left space vs right general category */\n          case 8:  /* Left word vs right general category */\n          p = posspropstab\u00ddn-6\u00a8;\n          accepted = risprop && lisprop ==\n            (list\u00dd3\u00a8 != p\u00dd0\u00a8 &&\n             list\u00dd3\u00a8 != p\u00dd1\u00a8 &&\n            (list\u00dd3\u00a8 != p\u00dd2\u00a8 || !lisprop));\n          break;\n\n          case 9:   /* Right alphanum vs left general category */\n          case 10:  /* Right space vs left general category */\n          case 11:  /* Right word vs left general category */\n          p = posspropstab\u00ddn-9\u00a8;\n          accepted = lisprop && risprop ==\n            (base_list\u00dd3\u00a8 != p\u00dd0\u00a8 &&\n             base_list\u00dd3\u00a8 != p\u00dd1\u00a8 &&\n            (base_list\u00dd3\u00a8 != p\u00dd2\u00a8 || !risprop));\n          break;\n\n          case 12:  /* Left alphanum vs right particular category */\n          case 13:  /* Left space vs right particular category */\n          case 14:  /* Left word vs right particular category */\n          p = posspropstab\u00ddn-12\u00a8;\n          accepted = risprop && lisprop ==\n            (catposstab\u00ddp\u00dd0\u00a8\u00a8\u00ddlist\u00dd3\u00a8\u00a8 &&\n             catposstab\u00ddp\u00dd1\u00a8\u00a8\u00ddlist\u00dd3\u00a8\u00a8 &&\n            (list\u00dd3\u00a8 != p\u00dd3\u00a8 || !lisprop));\n          break;\n\n          case 15:  /* Right alphanum vs left particular category */\n          case 16:  /* Right space vs left particular category */\n          case 17:  /* Right word vs left particular category */\n          p = posspropstab\u00ddn-15\u00a8;\n          accepted = lisprop && risprop ==\n            (catposstab\u00ddp\u00dd0\u00a8\u00a8\u00ddbase_list\u00dd3\u00a8\u00a8 &&\n             catposstab\u00ddp\u00dd1\u00a8\u00a8\u00ddbase_list\u00dd3\u00a8\u00a8 &&\n            (base_list\u00dd3\u00a8 != p\u00dd3\u00a8 || !risprop));\n          break;\n          }\n        }\n      }\n\n    else\n#endif  /* SUPPORT_UNICODE */\n\n    accepted = leftop >= FIRST_AUTOTAB_OP && leftop <= LAST_AUTOTAB_LEFT_OP &&\n           rightop >= FIRST_AUTOTAB_OP && rightop <= LAST_AUTOTAB_RIGHT_OP &&\n           autoposstab\u00ddleftop - FIRST_AUTOTAB_OP\u00a8\u00ddrightop - FIRST_AUTOTAB_OP\u00a8;\n\n    if (!accepted) return FALSE;\n\n    if (list\u00dd1\u00a8 == 0) return TRUE;\n    /* Might be an empty repeat. */\n    continue;\n    }\n\n  /* Control reaches here only if one of the items is a small character list.\n  All characters are checked against the other side. */\n\n  do\n    {\n    chr = *chr_ptr;\n\n    switch(list_ptr\u00dd0\u00a8)\n      {\n      case OP_CHAR:\n      ochr_ptr = list_ptr + 2;\n      do\n        {\n        if (chr == *ochr_ptr) return FALSE;\n        ochr_ptr++;\n        }\n      while(*ochr_ptr != NOTACHAR);\n      break;\n\n      case OP_NOT:\n      ochr_ptr = list_ptr + 2;\n      do\n        {\n        if (chr == *ochr_ptr)\n          break;\n        ochr_ptr++;\n        }\n      while(*ochr_ptr != NOTACHAR);\n      if (*ochr_ptr == NOTACHAR) return FALSE;   /* Not found */\n      break;\n\n      /* Note that OP_DIGIT etc. are generated only when PCRE2_UCP is *not*\n      set. When it is set, \\d etc. are converted into OP_(NOT_)PROP codes. */\n\n      case OP_DIGIT:\n      if (chr < 256 && (cb->ctypes\u00ddchr\u00a8 & ctype_digit) != 0) return FALSE;\n      break;\n\n      case OP_NOT_DIGIT:\n      if (chr > 255 || (cb->ctypes\u00ddchr\u00a8 & ctype_digit) == 0) return FALSE;\n      break;\n\n      case OP_WHITESPACE:\n      if (chr < 256 && (cb->ctypes\u00ddchr\u00a8 & ctype_space) != 0) return FALSE;\n      break;\n\n      case OP_NOT_WHITESPACE:\n      if (chr > 255 || (cb->ctypes\u00ddchr\u00a8 & ctype_space) == 0) return FALSE;\n      break;\n\n      case OP_WORDCHAR:\n      if (chr < 255 && (cb->ctypes\u00ddchr\u00a8 & ctype_word) != 0) return FALSE;\n      break;\n\n      case OP_NOT_WORDCHAR:\n      if (chr > 255 || (cb->ctypes\u00ddchr\u00a8 & ctype_word) == 0) return FALSE;\n      break;\n\n      case OP_HSPACE:\n      switch(chr)\n        {\n        HSPACE_CASES: return FALSE;\n        default: break;\n        }\n      break;\n\n      case OP_NOT_HSPACE:\n      switch(chr)\n        {\n        HSPACE_CASES: break;\n        default: return FALSE;\n        }\n      break;\n\n      case OP_ANYNL:\n      case OP_VSPACE:\n      switch(chr)\n        {\n        VSPACE_CASES: return FALSE;\n        default: break;\n        }\n      break;\n\n      case OP_NOT_VSPACE:\n      switch(chr)\n        {\n        VSPACE_CASES: break;\n        default: return FALSE;\n        }\n      break;\n\n      case OP_DOLL:\n      case OP_EODN:\n      switch (chr)\n        {\n        case CHAR_CR:\n        case CHAR_LF:\n        case CHAR_VT:\n        case CHAR_FF:\n        case CHAR_NEL:\n#ifndef EBCDIC\n        case 0x2028:\n        case 0x2029:\n#endif  /* Not EBCDIC */\n        return FALSE;\n        }\n      break;\n\n      case OP_EOD:    /* Can always possessify before \\z */\n      break;\n\n#ifdef SUPPORT_UNICODE\n      case OP_PROP:\n      case OP_NOTPROP:\n      if (!check_char_prop(chr, list_ptr\u00dd2\u00a8, list_ptr\u00dd3\u00a8,\n            list_ptr\u00dd0\u00a8 == OP_NOTPROP))\n        return FALSE;\n      break;\n#endif\n\n      case OP_NCLASS:\n      if (chr > 255) return FALSE;\n      /* Fall through */\n\n      case OP_CLASS:\n      if (chr > 255) break;\n      class_bitset = (uint8_t *)\n        ((list_ptr == list ? code : base_end) - list_ptr\u00dd2\u00a8);\n      if ((class_bitset\u00ddchr >> 3\u00a8 & (1u << (chr & 7))) != 0) return FALSE;\n      break;\n\n#ifdef SUPPORT_WIDE_CHARS\n      case OP_XCLASS:\n      if (PRIV(xclass)(chr, (list_ptr == list ? code : base_end) -\n          list_ptr\u00dd2\u00a8 + LINK_SIZE, utf)) return FALSE;\n      break;\n#endif\n\n      default:\n      return FALSE;\n      }\n\n    chr_ptr++;\n    }\n  while(*chr_ptr != NOTACHAR);\n\n  /* At least one character must be matched from this opcode. */\n\n  if (list\u00dd1\u00a8 == 0) return TRUE;\n  }\n\n/* Control never reaches here. There used to be a fail-save return FALSE; here,\nbut some compilers complain about an unreachable statement. */\n}\n\n\n\n/*************************************************\n*    Scan compiled regex for auto-possession     *\n*************************************************/\n\n/* Replaces single character iterations with their possessive alternatives\nif appropriate. This function modifies the compiled opcode! Hitting a\nnon-existent opcode may indicate a bug in PCRE2, but it can also be caused if a\nbad UTF string was compiled with PCRE2_NO_UTF_CHECK. The rec_limit catches\noverly complicated or large patterns. In these cases, the check just stops,\nleaving the remainder of the pattern unpossessified.\n\nArguments:\n  code        points to start of the byte code\n  cb          compile data block\n\nReturns:      0 for success\n              -1 if a non-existant opcode is encountered\n*/\n\nint\nPRIV(auto_possessify)(PCRE2_UCHAR *code, const compile_block *cb)\n{\nPCRE2_UCHAR c;\nPCRE2_SPTR end;\nPCRE2_UCHAR *repeat_opcode;\nuint32_t list\u00dd8\u00a8;\nint rec_limit = 1000;  /* Was 10,000 but clang+ASAN uses a lot of stack. */\nBOOL utf = (cb->external_options & PCRE2_UTF) != 0;\nBOOL ucp = (cb->external_options & PCRE2_UCP) != 0;\n\nfor (;;)\n  {\n  c = *code;\n\n  if (c >= OP_TABLE_LENGTH) return -1;   /* Something gone wrong */\n\n  if (c >= OP_STAR && c <= OP_TYPEPOSUPTO)\n    {\n    c -= get_repeat_base(c) - OP_STAR;\n    end = (c <= OP_MINUPTO) ?\n      get_chr_property_list(code, utf, ucp, cb->fcc, list) : NULL;\n    list\u00dd1\u00a8 = c == OP_STAR || c == OP_PLUS || c == OP_QUERY || c == OP_UPTO;\n\n    if (end != NULL && compare_opcodes(end, utf, ucp, cb, list, end,\n        &rec_limit))\n      {\n      switch(c)\n        {\n        case OP_STAR:\n        *code += OP_POSSTAR - OP_STAR;\n        break;\n\n        case OP_MINSTAR:\n        *code += OP_POSSTAR - OP_MINSTAR;\n        break;\n\n        case OP_PLUS:\n        *code += OP_POSPLUS - OP_PLUS;\n        break;\n\n        case OP_MINPLUS:\n        *code += OP_POSPLUS - OP_MINPLUS;\n        break;\n\n        case OP_QUERY:\n        *code += OP_POSQUERY - OP_QUERY;\n        break;\n\n        case OP_MINQUERY:\n        *code += OP_POSQUERY - OP_MINQUERY;\n        break;\n\n        case OP_UPTO:\n        *code += OP_POSUPTO - OP_UPTO;\n        break;\n\n        case OP_MINUPTO:\n        *code += OP_POSUPTO - OP_MINUPTO;\n        break;\n        }\n      }\n    c = *code;\n    }\n  else if (c == OP_CLASS || c == OP_NCLASS || c == OP_XCLASS)\n    {\n#ifdef SUPPORT_WIDE_CHARS\n    if (c == OP_XCLASS)\n      repeat_opcode = code + GET(code, 1);\n    else\n#endif\n      repeat_opcode = code + 1 + (32 / sizeof(PCRE2_UCHAR));\n\n    c = *repeat_opcode;\n    if (c >= OP_CRSTAR && c <= OP_CRMINRANGE)\n      {\n      /* end must not be NULL. */\n      end = get_chr_property_list(code, utf, ucp, cb->fcc, list);\n\n      list\u00dd1\u00a8 = (c & 1) == 0;\n\n      if (compare_opcodes(end, utf, ucp, cb, list, end, &rec_limit))\n        {\n        switch (c)\n          {\n          case OP_CRSTAR:\n          case OP_CRMINSTAR:\n          *repeat_opcode = OP_CRPOSSTAR;\n          break;\n\n          case OP_CRPLUS:\n          case OP_CRMINPLUS:\n          *repeat_opcode = OP_CRPOSPLUS;\n          break;\n\n          case OP_CRQUERY:\n          case OP_CRMINQUERY:\n          *repeat_opcode = OP_CRPOSQUERY;\n          break;\n\n          case OP_CRRANGE:\n          case OP_CRMINRANGE:\n          *repeat_opcode = OP_CRPOSRANGE;\n          break;\n          }\n        }\n      }\n    c = *code;\n    }\n\n  switch(c)\n    {\n    case OP_END:\n    return 0;\n\n    case OP_TYPESTAR:\n    case OP_TYPEMINSTAR:\n    case OP_TYPEPLUS:\n    case OP_TYPEMINPLUS:\n    case OP_TYPEQUERY:\n    case OP_TYPEMINQUERY:\n    case OP_TYPEPOSSTAR:\n    case OP_TYPEPOSPLUS:\n    case OP_TYPEPOSQUERY:\n    if (code\u00dd1\u00a8 == OP_PROP || code\u00dd1\u00a8 == OP_NOTPROP) code += 2;\n    break;\n\n    case OP_TYPEUPTO:\n    case OP_TYPEMINUPTO:\n    case OP_TYPEEXACT:\n    case OP_TYPEPOSUPTO:\n    if (code\u00dd1 + IMM2_SIZE\u00a8 == OP_PROP || code\u00dd1 + IMM2_SIZE\u00a8 == OP_NOTPROP)\n      code += 2;\n    break;\n\n    case OP_CALLOUT_STR:\n    code += GET(code, 1 + 2*LINK_SIZE);\n    break;\n\n#ifdef SUPPORT_WIDE_CHARS\n    case OP_XCLASS:\n    code += GET(code, 1);\n    break;\n#endif\n\n    case OP_MARK:\n    case OP_COMMIT_ARG:\n    case OP_PRUNE_ARG:\n    case OP_SKIP_ARG:\n    case OP_THEN_ARG:\n    code += code\u00dd1\u00a8;\n    break;\n    }\n\n  /* Add in the fixed length from the table */\n\n  code += PRIV(OP_lengths)\u00ddc\u00a8;\n\n  /* In UTF-8 and UTF-16 modes, opcodes that are followed by a character may be\n  followed by a multi-byte character. The length in the table is a minimum, so\n  we have to arrange to skip the extra code units. */\n\n#ifdef MAYBE_UTF_MULTI\n  if (utf) switch(c)\n    {\n    case OP_CHAR:\n    case OP_CHARI:\n    case OP_NOT:\n    case OP_NOTI:\n    case OP_STAR:\n    case OP_MINSTAR:\n    case OP_PLUS:\n    case OP_MINPLUS:\n    case OP_QUERY:\n    case OP_MINQUERY:\n    case OP_UPTO:\n    case OP_MINUPTO:\n    case OP_EXACT:\n    case OP_POSSTAR:\n    case OP_POSPLUS:\n    case OP_POSQUERY:\n    case OP_POSUPTO:\n    case OP_STARI:\n    case OP_MINSTARI:\n    case OP_PLUSI:\n    case OP_MINPLUSI:\n    case OP_QUERYI:\n    case OP_MINQUERYI:\n    case OP_UPTOI:\n    case OP_MINUPTOI:\n    case OP_EXACTI:\n    case OP_POSSTARI:\n    case OP_POSPLUSI:\n    case OP_POSQUERYI:\n    case OP_POSUPTOI:\n    case OP_NOTSTAR:\n    case OP_NOTMINSTAR:\n    case OP_NOTPLUS:\n    case OP_NOTMINPLUS:\n    case OP_NOTQUERY:\n    case OP_NOTMINQUERY:\n    case OP_NOTUPTO:\n    case OP_NOTMINUPTO:\n    case OP_NOTEXACT:\n    case OP_NOTPOSSTAR:\n    case OP_NOTPOSPLUS:\n    case OP_NOTPOSQUERY:\n    case OP_NOTPOSUPTO:\n    case OP_NOTSTARI:\n    case OP_NOTMINSTARI:\n    case OP_NOTPLUSI:\n    case OP_NOTMINPLUSI:\n    case OP_NOTQUERYI:\n    case OP_NOTMINQUERYI:\n    case OP_NOTUPTOI:\n    case OP_NOTMINUPTOI:\n    case OP_NOTEXACTI:\n    case OP_NOTPOSSTARI:\n    case OP_NOTPOSPLUSI:\n    case OP_NOTPOSQUERYI:\n    case OP_NOTPOSUPTOI:\n    if (HAS_EXTRALEN(code\u00dd-1\u00a8)) code += GET_EXTRALEN(code\u00dd-1\u00a8);\n    break;\n    }\n#else\n  (void)(utf);  /* Keep compiler happy by referencing function argument */\n#endif  /* SUPPORT_WIDE_CHARS */\n  }\n}\n\n/* End of pcre2_auto_possess.c */\n/*autoconv-0001 C:\\projects\\pcre2-10.35\\src\\pcre2_auto_possess.c converted to AUTOPOS2*/\n/*autoconv-0011 AUTOPOS2 line: 46 config.h replaced by CONFIG.h*/\n/*autoconv-0011 AUTOPOS2 line: 50 pcre2_internal.h replaced by INTERNA2.h*/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CHARTAB2": {"ttr": 14595, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/*************************************************\n*      Perl-Compatible Regular Expressions       *\n*************************************************/\n\n/* This file was automatically written by the pcre2_dftables auxiliary\nprogram. It contains character tables that are used when no external\ntables are passed to PCRE2 by the application that calls it. The tables\nare used only for characters whose code values are less than 256. */\n\n/* This set of tables was written in the C locale. */\n\n/* The pcre2_ftables program (which is distributed with PCRE2) can be used\nto build alternative versions of this file. This is necessary if you are\nrunning in an EBCDIC environment, or if you want to default to a different\nencoding, for example ISO-8859-1. When pcre2_dftables is run, it creates\nthese tables in the \"C\" locale by default. This happens automatically if\nPCRE2 is configured with --enable-rebuild-chartables. However, you can run\npcre2_dftables manually with the -L option to build tables using the LC_ALL\nlocale. */\n\n/* For z/OS, config.h is forced */\n#ifndef HAVE_CONFIG_H\n#define HAVE_CONFIG_H 1\n#endif\n\n/* The following #include is present because without it gcc 4.x may remove\nthe array definition from the final binary if PCRE2 is built into a static\nlibrary and dead code stripping is activated. This leads to link errors.\nPulling in the header ensures that the array gets flagged as \"someone\noutside this compilation unit might reference this\" and so it will always\nbe supplied to the linker. */\n\n#ifdef HAVE_CONFIG_H\n#include \"CONFIG.h\"\n#endif\n\n#include \"INTERNA2.h\"\n\nconst uint8_t PRIV(default_tables)\u00dd\u00a8 = {\n\n/* This table is a lower casing table. */\n\n    0,  1,  2,  3,  4,  5,  6,  7,\n    8,  9, 10, 11, 12, 13, 14, 15,\n   16, 17, 18, 19, 20, 21, 22, 23,\n   24, 25, 26, 27, 28, 29, 30, 31,\n   32, 33, 34, 35, 36, 37, 38, 39,\n   40, 41, 42, 43, 44, 45, 46, 47,\n   48, 49, 50, 51, 52, 53, 54, 55,\n   56, 57, 58, 59, 60, 61, 62, 63,\n   64, 65, 66, 67, 68, 69, 70, 71,\n   72, 73, 74, 75, 76, 77, 78, 79,\n   80, 81, 82, 83, 84, 85, 86, 87,\n   88, 89, 90, 91, 92, 93, 94, 95,\n   96, 97, 98, 99,100,101,102,103,\n  104,105,106,107,108,109,110,111,\n  112,113,114,115,116,117,118,119,\n  120,121,122,123,124,125,126,127,\n  128,129,130,131,132,133,134,135,\n  136,137,138,139,140,141,142,143,\n  144,145,146,147,148,149,150,151,\n  152,153,154,155,156,157,158,159,\n  160,161,162,163,164,165,166,167,\n  168,169,170,171,172,173,174,175,\n  176,177,178,179,180,181,182,183,\n  184,185,186,187,188,189,190,191,\n  192,129,130,131,132,133,134,135,\n  136,137,202,203,204,205,206,207,\n  208,145,146,147,148,149,150,151,\n  152,153,218,219,220,221,222,223,\n  224,225,162,163,164,165,166,167,\n  168,169,234,235,236,237,238,239,\n  240,241,242,243,244,245,246,247,\n  248,249,250,251,252,253,254,255,\n\n/* This table is a case flipping table. */\n\n    0,  1,  2,  3,  4,  5,  6,  7,\n    8,  9, 10, 11, 12, 13, 14, 15,\n   16, 17, 18, 19, 20, 21, 22, 23,\n   24, 25, 26, 27, 28, 29, 30, 31,\n   32, 33, 34, 35, 36, 37, 38, 39,\n   40, 41, 42, 43, 44, 45, 46, 47,\n   48, 49, 50, 51, 52, 53, 54, 55,\n   56, 57, 58, 59, 60, 61, 62, 63,\n   64, 65, 66, 67, 68, 69, 70, 71,\n   72, 73, 74, 75, 76, 77, 78, 79,\n   80, 81, 82, 83, 84, 85, 86, 87,\n   88, 89, 90, 91, 92, 93, 94, 95,\n   96, 97, 98, 99,100,101,102,103,\n  104,105,106,107,108,109,110,111,\n  112,113,114,115,116,117,118,119,\n  120,121,122,123,124,125,126,127,\n  128,193,194,195,196,197,198,199,\n  200,201,138,139,140,141,142,143,\n  144,209,210,211,212,213,214,215,\n  216,217,154,155,156,157,158,159,\n  160,161,226,227,228,229,230,231,\n  232,233,170,171,172,173,174,175,\n  176,177,178,179,180,181,182,183,\n  184,185,186,187,188,189,190,191,\n  192,129,130,131,132,133,134,135,\n  136,137,202,203,204,205,206,207,\n  208,145,146,147,148,149,150,151,\n  152,153,218,219,220,221,222,223,\n  224,225,162,163,164,165,166,167,\n  168,169,234,235,236,237,238,239,\n  240,241,242,243,244,245,246,247,\n  248,249,250,251,252,253,254,255,\n\n/* This table contains bit maps for various character classes. Each map is 32\nbytes long and the bits run from the least significant end of each byte. The\nclasses that have their own maps are: space, xdigit, digit, upper, lower, word,\ngraph, print, punct, and cntrl. Other classes are built from combinations. */\n\n  0x20,0x38,0x20,0x00,0x00,0x00,0x00,0x00,  /* space */\n  0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n\n  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* xdigit */\n  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  0x7e,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  0x7e,0x00,0x00,0x00,0x00,0x00,0xff,0x03,\n\n  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* digit */\n  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  0x00,0x00,0x00,0x00,0x00,0x00,0xff,0x03,\n\n  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* upper */\n  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  0xfe,0x03,0xfe,0x03,0xfc,0x03,0x00,0x00,\n\n  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* lower */\n  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  0xfe,0x03,0xfe,0x03,0xfc,0x03,0x00,0x00,\n  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n\n  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* word */\n  0x00,0x00,0x00,0x00,0x00,0x20,0x00,0x00,\n  0xfe,0x03,0xfe,0x03,0xfc,0x03,0x00,0x00,\n  0xfe,0x03,0xfe,0x03,0xfc,0x03,0xff,0x03,\n\n  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* graph */\n  0x00,0xfc,0x01,0xfc,0x03,0xfc,0x00,0xfe,\n  0xfe,0x03,0xfe,0x03,0xfe,0x23,0x00,0x20,\n  0xff,0x03,0xff,0x03,0xfd,0x03,0xff,0x03,\n\n  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* print */\n  0x01,0xfc,0x01,0xfc,0x03,0xfc,0x00,0xfe,\n  0xfe,0x03,0xfe,0x03,0xfe,0x23,0x00,0x20,\n  0xff,0x03,0xff,0x03,0xfd,0x03,0xff,0x03,\n\n  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* punct */\n  0x00,0xfc,0x01,0xfc,0x03,0xfc,0x00,0xfe,\n  0x00,0x00,0x00,0x00,0x02,0x20,0x00,0x20,\n  0x01,0x00,0x01,0x00,0x01,0x00,0x00,0x00,\n\n  0xff,0xff,0xff,0xff,0xff,0xfd,0xfc,0xbf,  /* cntrl */\n  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n\n/* This table identifies various classes of character by individual bits:\n  0x01   white space character\n  0x02   letter\n  0x04   lower case letter\n  0x08   decimal digit\n  0x10   alphanumeric or '_'\n*/\n\n  0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x00, /*   0-  7 */\n  0x00,0x00,0x00,0x01,0x01,0x01,0x00,0x00, /*   8- 15 */\n  0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x00, /*  16- 23 */\n  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, /*  24- 31 */\n  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, /*  32- 39 */\n  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, /*  40- 47 */\n  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, /*  48- 55 */\n  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, /*  56- 63 */\n  0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00, /*    - 71 */\n  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, /*  72- |  */\n  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, /*  & - 87 */\n  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, /*  88- \u00ac  */\n  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, /*  - -103 */\n  0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x00, /* 104- ?  */\n  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, /* 112-119 */\n  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, /* 120- \"  */\n  0x00,0x16,0x16,0x16,0x16,0x16,0x16,0x16, /* 128- g  */\n  0x16,0x16,0x00,0x00,0x00,0x00,0x00,0x00, /*  h -143 */\n  0x00,0x16,0x16,0x16,0x16,0x16,0x16,0x16, /* 144- p  */\n  0x16,0x16,0x00,0x00,0x00,0x00,0x00,0x00, /*  q -159 */\n  0x00,0x00,0x16,0x16,0x16,0x16,0x16,0x16, /* 160- x  */\n  0x16,0x16,0x00,0x00,0x00,0x00,0x00,0x00, /*  y -175 */\n  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, /* 176-183 */\n  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, /* 184-191 */\n  0x00,0x12,0x12,0x12,0x12,0x12,0x12,0x12, /*  { - G  */\n  0x12,0x12,0x00,0x00,0x00,0x00,0x00,0x00, /*  H -207 */\n  0x00,0x12,0x12,0x12,0x12,0x12,0x12,0x12, /*  } - P  */\n  0x12,0x12,0x00,0x00,0x00,0x00,0x00,0x00, /*  Q -223 */\n  0x00,0x00,0x12,0x12,0x12,0x12,0x12,0x12, /*  \\ - X  */\n  0x12,0x12,0x00,0x00,0x00,0x00,0x00,0x00, /*  Y -239 */\n  0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18, /*  0 - 7  */\n  0x18,0x18,0x00,0x00,0x00,0x00,0x00,0x00};/*  8 -255 */\n\n/* End of pcre2_chartables.c */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "COMPILE2": {"ttr": 6405, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "\n/*************************************************\n*      Perl-Compatible Regular Expressions       *\n*************************************************/\n\n/* PCRE is a library of functions to support regular expressions whose syntax\nand semantics are as close as possible to those of the Perl 5 language.\n\n                       Written by Philip Hazel\n     Original API code Copyright (c) 1997-2012 University of Cambridge\n          New API code Copyright (c) 2016-2020 University of Cambridge\n\n-----------------------------------------------------------------------------\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n\n    * Redistributions of source code must retain the above copyright notice,\n      this list of conditions and the following disclaimer.\n\n    * Redistributions in binary form must reproduce the above copyright\n      notice, this list of conditions and the following disclaimer in the\n      documentation and/or other materials provided with the distribution.\n\n    * Neither the name of the University of Cambridge nor the names of its\n      contributors may be used to endorse or promote products derived from\n      this software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\nAND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\nIMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\nARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\nLIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\nCONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\nSUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\nINTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\nCONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\nARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\nPOSSIBILITY OF SUCH DAMAGE.\n-----------------------------------------------------------------------------\n*/\n\n\n#ifdef HAVE_CONFIG_H\n#include \"CONFIG.h\"\n#endif\n\n#define NLBLOCK cb             /* Block containing newline information */\n#define PSSTART start_pattern  /* Field containing processed string start */\n#define PSEND   end_pattern    /* Field containing processed string end */\n\n#include \"INTERNA2.h\"\n\n/* In rare error cases debugging might require calling pcre2_printint(). */\n\n#if 0\n#ifdef EBCDIC\n#define PRINTABLE(c) ((c) >= 64 && (c) < 255)\n#else\n#define PRINTABLE(c) ((c) >= 32 && (c) < 127)\n#endif\n#include \"PRINTIN2.c\"\n#define DEBUG_CALL_PRINTINT\n#endif\n\n/* Other debugging code can be enabled by these defines. */\n\n/* #define DEBUG_SHOW_CAPTURES */\n/* #define DEBUG_SHOW_PARSED */\n\n/* There are a few things that vary with different code unit sizes. Handle them\nby defining macros in order to minimize #if usage. */\n\n#if PCRE2_CODE_UNIT_WIDTH == 8\n#define STRING_UTFn_RIGHTPAR     STRING_UTF8_RIGHTPAR, 5\n#define XDIGIT(c)                xdigitab\u00ddc\u00a8\n\n#else  /* Either 16-bit or 32-bit */\n#define XDIGIT(c)                (MAX_255(c)? xdigitab\u00ddc\u00a8 : 0xff)\n\n#if PCRE2_CODE_UNIT_WIDTH == 16\n#define STRING_UTFn_RIGHTPAR     STRING_UTF16_RIGHTPAR, 6\n\n#else  /* 32-bit */\n#define STRING_UTFn_RIGHTPAR     STRING_UTF32_RIGHTPAR, 6\n#endif\n#endif\n\n/* Macros to store and retrieve a PCRE2_SIZE value in the parsed pattern, which\nconsists of uint32_t elements. Assume that if uint32_t can't hold it, two of\nthem will be able to (i.e. assume a 64-bit world). */\n\n#if PCRE2_SIZE_MAX <= UINT32_MAX\n#define PUTOFFSET(s,p) *p++ = s\n#define GETOFFSET(s,p) s = *p++\n#define GETPLUSOFFSET(s,p) s = *(++p)\n#define READPLUSOFFSET(s,p) s = p\u00dd1\u00a8\n#define SKIPOFFSET(p) p++\n#define SIZEOFFSET 1\n#else\n#define PUTOFFSET(s,p) \\\n  { *p++ = (uint32_t)(s >> 32); *p++ = (uint32_t)(s & 0xffffffff); }\n#define GETOFFSET(s,p) \\\n  { s = ((PCRE2_SIZE)p\u00dd0\u00a8 << 32) | (PCRE2_SIZE)p\u00dd1\u00a8; p += 2; }\n#define GETPLUSOFFSET(s,p) \\\n  { s = ((PCRE2_SIZE)p\u00dd1\u00a8 << 32) | (PCRE2_SIZE)p\u00dd2\u00a8; p += 2; }\n#define READPLUSOFFSET(s,p) \\\n  { s = ((PCRE2_SIZE)p\u00dd1\u00a8 << 32) | (PCRE2_SIZE)p\u00dd2\u00a8; }\n#define SKIPOFFSET(p) p += 2\n#define SIZEOFFSET 2\n#endif\n\n/* Macros for manipulating elements of the parsed pattern vector. */\n\n#define META_CODE(x)   (x & 0xffff0000u)\n#define META_DATA(x)   (x & 0x0000ffffu)\n#define META_DIFF(x,y) ((x-y)>>16)\n\n/* Function definitions to allow mutual recursion */\n\n#ifdef SUPPORT_UNICODE\nstatic unsigned int\n  add_list_to_class_internal(uint8_t *, PCRE2_UCHAR **, uint32_t,\n    compile_block *, const uint32_t *, unsigned int);\n#endif\n\nstatic int\n  compile_regex(uint32_t, PCRE2_UCHAR **, uint32_t **, int *, uint32_t,\n    uint32_t *, int32_t *, uint32_t *, int32_t *, branch_chain *,\n    compile_block *, PCRE2_SIZE *);\n\nstatic int\n  get_branchlength(uint32_t **, int *, int *, parsed_recurse_check *,\n    compile_block *);\n\nstatic BOOL\n  set_lookbehind_lengths(uint32_t **, int *, int *, parsed_recurse_check *,\n    compile_block *);\n\nstatic int\n  check_lookbehinds(uint32_t *, uint32_t **, parsed_recurse_check *,\n    compile_block *);\n\n\n/*************************************************\n*      Code parameters and static tables         *\n*************************************************/\n\n#define MAX_GROUP_NUMBER   65535u\n#define MAX_REPEAT_COUNT   65535u\n#define REPEAT_UNLIMITED   (MAX_REPEAT_COUNT+1)\n\n/* COMPILE_WORK_SIZE specifies the size of stack workspace, which is used in\ndifferent ways in the different pattern scans. The parsing and group-\nidentifying pre-scan uses it to handle nesting, and needs it to be 16-bit\naligned for this. Having defined the size in code units, we set up\nC16_WORK_SIZE as the number of elements in the 16-bit vector.\n\nDuring the first compiling phase, when determining how much memory is required,\nthe regex is partly compiled into this space, but the compiled parts are\ndiscarded as soon as they can be, so that hopefully there will never be an\noverrun. The code does, however, check for an overrun, which can occur for\npathological patterns. The size of the workspace depends on LINK_SIZE because\nthe length of compiled items varies with this.\n\nIn the real compile phase, this workspace is not currently used. */\n\n#define COMPILE_WORK_SIZE (3000*LINK_SIZE)   /* Size in code units */\n\n#define C16_WORK_SIZE \\\n  ((COMPILE_WORK_SIZE * sizeof(PCRE2_UCHAR))/sizeof(uint16_t))\n\n/* A uint32_t vector is used for caching information about the size of\ncapturing groups, to improve performance. A default is created on the stack of\nthis size. */\n\n#define GROUPINFO_DEFAULT_SIZE 256\n\n/* The overrun tests check for a slightly smaller size so that they detect the\noverrun before it actually does run off the end of the data block. */\n\n#define WORK_SIZE_SAFETY_MARGIN (100)\n\n/* This value determines the size of the initial vector that is used for\nremembering named groups during the pre-compile. It is allocated on the stack,\nbut if it is too small, it is expanded, in a similar way to the workspace. The\nvalue is the number of slots in the list. */\n\n#define NAMED_GROUP_LIST_SIZE  20\n\n/* The pre-compiling pass over the pattern creates a parsed pattern in a vector\nof uint32_t. For short patterns this lives on the stack, with this size. Heap\nmemory is used for longer patterns. */\n\n#define PARSED_PATTERN_DEFAULT_SIZE 1024\n\n/* Maximum length value to check against when making sure that the variable\nthat holds the compiled pattern length does not overflow. We make it a bit less\nthan INT_MAX to allow for adding in group terminating code units, so that we\ndon't have to check them every time. */\n\n#define OFLOW_MAX (INT_MAX - 20)\n\n/* Code values for parsed patterns, which are stored in a vector of 32-bit\nunsigned ints. Values less than META_END are literal data values. The coding\nfor identifying the item is in the top 16-bits, leaving 16 bits for the\nadditional data that some of them need. The META_CODE, META_DATA, and META_DIFF\nmacros are used to manipulate parsed pattern elements.\n\nNOTE: When these definitions are changed, the table of extra lengths for each\ncode (meta_extra_lengths, just below) must be updated to remain in step. */\n\n#define META_END              0x80000000u  /* End of pattern */\n\n#define META_ALT              0x80010000u  /* alternation */\n#define META_ATOMIC           0x80020000u  /* atomic group */\n#define META_BACKREF          0x80030000u  /* Back ref */\n#define META_BACKREF_BYNAME   0x80040000u  /* \\k'name' */\n#define META_BIGVALUE         0x80050000u  /* Next is a literal > META_END */\n#define META_CALLOUT_NUMBER   0x80060000u  /* (?C with numerical argument */\n#define META_CALLOUT_STRING   0x80070000u  /* (?C with string argument */\n#define META_CAPTURE          0x80080000u  /* Capturing parenthesis */\n#define META_CIRCUMFLEX       0x80090000u  /* \u00ac metacharacter */\n#define META_CLASS            0x800a0000u  /* start non-empty class */\n#define META_CLASS_EMPTY      0x800b0000u  /* empty class */\n#define META_CLASS_EMPTY_NOT  0x800c0000u  /* negative empty class */\n#define META_CLASS_END        0x800d0000u  /* end of non-empty class */\n#define META_CLASS_NOT        0x800e0000u  /* start non-empty negative class */\n#define META_COND_ASSERT      0x800f0000u  /* (?(?assertion)... */\n#define META_COND_DEFINE      0x80100000u  /* (?(DEFINE)... */\n#define META_COND_NAME        0x80110000u  /* (?(<name>)... */\n#define META_COND_NUMBER      0x80120000u  /* (?(digits)... */\n#define META_COND_RNAME       0x80130000u  /* (?(R&name)... */\n#define META_COND_RNUMBER     0x80140000u  /* (?(Rdigits)... */\n#define META_COND_VERSION     0x80150000u  /* (?(VERSION<op>x.y)... */\n#define META_DOLLAR           0x80160000u  /* $ metacharacter */\n#define META_DOT              0x80170000u  /* . metacharacter */\n#define META_ESCAPE           0x80180000u  /* \\d and friends */\n#define META_KET              0x80190000u  /* closing parenthesis */\n#define META_NOCAPTURE        0x801a0000u  /* no capture parens */\n#define META_OPTIONS          0x801b0000u  /* (?i) and friends */\n#define META_POSIX            0x801c0000u  /* POSIX class item */\n#define META_POSIX_NEG        0x801d0000u  /* negative POSIX class item */\n#define META_RANGE_ESCAPED    0x801e0000u  /* range with at least one escape */\n#define META_RANGE_LITERAL    0x801f0000u  /* range defined literally */\n#define META_RECURSE          0x80200000u  /* Recursion */\n#define META_RECURSE_BYNAME   0x80210000u  /* (?&name) */\n#define META_SCRIPT_RUN       0x80220000u  /* (*script_run:...) */\n\n/* These must be kept together to make it easy to check that an assertion\nis present where expected in a conditional group. */\n\n#define META_LOOKAHEAD        0x80230000u  /* (?= */\n#define META_LOOKAHEADNOT     0x80240000u  /* (?! */\n#define META_LOOKBEHIND       0x80250000u  /* (?<= */\n#define META_LOOKBEHINDNOT    0x80260000u  /* (?<! */\n\n/* These cannot be conditions */\n\n#define META_LOOKAHEAD_NA     0x80270000u  /* (*napla: */\n#define META_LOOKBEHIND_NA    0x80280000u  /* (*naplb: */\n\n/* These must be kept in this order, with consecutive values, and the _ARG\nversions of COMMIT, PRUNE, SKIP, and THEN immediately after their non-argument\nversions. */\n\n#define META_MARK             0x80290000u  /* (*MARK) */\n#define META_ACCEPT           0x802a0000u  /* (*ACCEPT) */\n#define META_FAIL             0x802b0000u  /* (*FAIL) */\n#define META_COMMIT           0x802c0000u  /* These               */\n#define META_COMMIT_ARG       0x802d0000u  /*   pairs             */\n#define META_PRUNE            0x802e0000u  /*     must            */\n#define META_PRUNE_ARG        0x802f0000u  /*       be            */\n#define META_SKIP             0x80300000u  /*         kept        */\n#define META_SKIP_ARG         0x80310000u  /*           in        */\n#define META_THEN             0x80320000u  /*             this    */\n#define META_THEN_ARG         0x80330000u  /*               order */\n\n/* These must be kept in groups of adjacent 3 values, and all together. */\n\n#define META_ASTERISK         0x80340000u  /* *  */\n#define META_ASTERISK_PLUS    0x80350000u  /* *+ */\n#define META_ASTERISK_QUERY   0x80360000u  /* *? */\n#define META_PLUS             0x80370000u  /* +  */\n#define META_PLUS_PLUS        0x80380000u  /* ++ */\n#define META_PLUS_QUERY       0x80390000u  /* +? */\n#define META_QUERY            0x803a0000u  /* ?  */\n#define META_QUERY_PLUS       0x803b0000u  /* ?+ */\n#define META_QUERY_QUERY      0x803c0000u  /* ?? */\n#define META_MINMAX           0x803d0000u  /* {n,m}  repeat */\n#define META_MINMAX_PLUS      0x803e0000u  /* {n,m}+ repeat */\n#define META_MINMAX_QUERY     0x803f0000u  /* {n,m}? repeat */\n\n#define META_FIRST_QUANTIFIER META_ASTERISK\n#define META_LAST_QUANTIFIER  META_MINMAX_QUERY\n\n/* This is a special \"meta code\" that is used only to distinguish (*asr: from\n(*sr: in the table of aphabetic assertions. It is never stored in the parsed\npattern because (*asr: is turned into (*sr:(*atomic: at that stage. There is\ntherefore no need for it to have a length entry, so use a high value. */\n\n#define META_ATOMIC_SCRIPT_RUN 0x8fff0000u\n\n/* Table of extra lengths for each of the meta codes. Must be kept in step with\nthe definitions above. For some items these values are a basic length to which\na variable amount has to be added. */\n\nstatic unsigned char meta_extra_lengths\u00dd\u00a8 = {\n  0,             /* META_END */\n  0,             /* META_ALT */\n  0,             /* META_ATOMIC */\n  0,             /* META_BACKREF - more if group is >= 10 */\n  1+SIZEOFFSET,  /* META_BACKREF_BYNAME */\n  1,             /* META_BIGVALUE */\n  3,             /* META_CALLOUT_NUMBER */\n  3+SIZEOFFSET,  /* META_CALLOUT_STRING */\n  0,             /* META_CAPTURE */\n  0,             /* META_CIRCUMFLEX */\n  0,             /* META_CLASS */\n  0,             /* META_CLASS_EMPTY */\n  0,             /* META_CLASS_EMPTY_NOT */\n  0,             /* META_CLASS_END */\n  0,             /* META_CLASS_NOT */\n  0,             /* META_COND_ASSERT */\n  SIZEOFFSET,    /* META_COND_DEFINE */\n  1+SIZEOFFSET,  /* META_COND_NAME */\n  1+SIZEOFFSET,  /* META_COND_NUMBER */\n  1+SIZEOFFSET,  /* META_COND_RNAME */\n  1+SIZEOFFSET,  /* META_COND_RNUMBER */\n  3,             /* META_COND_VERSION */\n  0,             /* META_DOLLAR */\n  0,             /* META_DOT */\n  0,             /* META_ESCAPE - more for ESC_P, ESC_p, ESC_g, ESC_k */\n  0,             /* META_KET */\n  0,             /* META_NOCAPTURE */\n  1,             /* META_OPTIONS */\n  1,             /* META_POSIX */\n  1,             /* META_POSIX_NEG */\n  0,             /* META_RANGE_ESCAPED */\n  0,             /* META_RANGE_LITERAL */\n  SIZEOFFSET,    /* META_RECURSE */\n  1+SIZEOFFSET,  /* META_RECURSE_BYNAME */\n  0,             /* META_SCRIPT_RUN */\n  0,             /* META_LOOKAHEAD */\n  0,             /* META_LOOKAHEADNOT */\n  SIZEOFFSET,    /* META_LOOKBEHIND */\n  SIZEOFFSET,    /* META_LOOKBEHINDNOT */\n  0,             /* META_LOOKAHEAD_NA */\n  SIZEOFFSET,    /* META_LOOKBEHIND_NA */\n  1,             /* META_MARK - plus the string length */\n  0,             /* META_ACCEPT */\n  0,             /* META_FAIL */\n  0,             /* META_COMMIT */\n  1,             /* META_COMMIT_ARG - plus the string length */\n  0,             /* META_PRUNE */\n  1,             /* META_PRUNE_ARG - plus the string length */\n  0,             /* META_SKIP */\n  1,             /* META_SKIP_ARG - plus the string length */\n  0,             /* META_THEN */\n  1,             /* META_THEN_ARG - plus the string length */\n  0,             /* META_ASTERISK */\n  0,             /* META_ASTERISK_PLUS */\n  0,             /* META_ASTERISK_QUERY */\n  0,             /* META_PLUS */\n  0,             /* META_PLUS_PLUS */\n  0,             /* META_PLUS_QUERY */\n  0,             /* META_QUERY */\n  0,             /* META_QUERY_PLUS */\n  0,             /* META_QUERY_QUERY */\n  2,             /* META_MINMAX */\n  2,             /* META_MINMAX_PLUS */\n  2              /* META_MINMAX_QUERY */\n};\n\n/* Types for skipping parts of a parsed pattern. */\n\nenum { PSKIP_ALT, PSKIP_CLASS, PSKIP_KET };\n\n/* Macro for setting individual bits in class bitmaps. It took some\nexperimenting to figure out how to stop gcc 5.3.0 from warning with\n-Wconversion. This version gets a warning:\n\n  #define SETBIT(a,b) a\u00dd(b)/8\u00a8 |= (uint8_t)(1u << ((b)&7))\n\nLet's hope the apparently less efficient version isn't actually so bad if the\ncompiler is clever with identical subexpressions. */\n\n#define SETBIT(a,b) a\u00dd(b)/8\u00a8 = (uint8_t)(a\u00dd(b)/8\u00a8 | (1u << ((b)&7)))\n\n/* Private flags added to firstcu and reqcu. */\n\n#define REQ_CASELESS    (1u << 0)       /* Indicates caselessness */\n#define REQ_VARY        (1u << 1)       /* reqcu followed non-literal item */\n/* Negative values for the firstcu and reqcu flags */\n#define REQ_UNSET       (-2)            /* Not yet found anything */\n#define REQ_NONE        (-1)            /* Found not fixed char */\n\n/* These flags are used in the groupinfo vector. */\n\n#define GI_SET_FIXED_LENGTH    0x80000000u\n#define GI_NOT_FIXED_LENGTH    0x40000000u\n#define GI_FIXED_LENGTH_MASK   0x0000ffffu\n\n/* This simple test for a decimal digit works for both ASCII/Unicode and EBCDIC\nand is fast (a good compiler can turn it into a subtraction and unsigned\ncomparison). */\n\n#define IS_DIGIT(x) ((x) >= CHAR_0 && (x) <= CHAR_9)\n\n/* Table to identify hex digits. The tables in chartables are dependent on the\nlocale, and may mark arbitrary characters as digits. We want to recognize only\n0-9, a-z, and A-Z as hex digits, which is why we have a private table here. It\ncosts 256 bytes, but it is a lot faster than doing character value tests (at\nleast in some simple cases I timed), and in some applications one wants PCRE2\nto compile efficiently as well as match efficiently. The value in the table is\nthe binary hex digit value, or 0xff for non-hex digits. */\n\n/* This is the \"normal\" case, for ASCII systems, and EBCDIC systems running in\nUTF-8 mode. */\n\n#ifndef EBCDIC\nstatic const uint8_t xdigitab\u00dd\u00a8 =\n  {\n  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff, /*   0-  7 */\n  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff, /*   8- 15 */\n  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff, /*  16- 23 */\n  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff, /*  24- 31 */\n  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff, /*    - '  */\n  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff, /*  ( - /  */\n  0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07, /*  0 - 7  */\n  0x08,0x09,0xff,0xff,0xff,0xff,0xff,0xff, /*  8 - ?  */\n  0xff,0x0a,0x0b,0x0c,0x0d,0x0e,0x0f,0xff, /*  @ - G  */\n  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff, /*  H - O  */\n  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff, /*  P - W  */\n  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff, /*  X - _  */\n  0xff,0x0a,0x0b,0x0c,0x0d,0x0e,0x0f,0xff, /*  ` - g  */\n  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff, /*  h - o  */\n  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff, /*  p - w  */\n  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff, /*  x -127 */\n  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff, /* 128-135 */\n  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff, /* 136-143 */\n  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff, /* 144-151 */\n  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff, /* 152-159 */\n  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff, /* 160-167 */\n  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff, /* 168-175 */\n  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff, /* 176-183 */\n  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff, /* 184-191 */\n  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff, /* 192-199 */\n  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff, /* 2ff-207 */\n  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff, /* 208-215 */\n  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff, /* 216-223 */\n  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff, /* 224-231 */\n  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff, /* 232-239 */\n  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff, /* 240-247 */\n  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff};/* 248-255 */\n\n#else\n\n/* This is the \"abnormal\" case, for EBCDIC systems not running in UTF-8 mode. */\n\nstatic const uint8_t xdigitab\u00dd\u00a8 =\n  {\n  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff, /*   0-  7  0 */\n  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff, /*   8- 15    */\n  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff, /*  16- 23 10 */\n  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff, /*  24- 31    */\n  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff, /*  32- 39 20 */\n  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff, /*  40- 47    */\n  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff, /*  48- 55 30 */\n  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff, /*  56- 63    */\n  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff, /*    - 71 40 */\n  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff, /*  72- |     */\n  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff, /*  & - 87 50 */\n  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff, /*  88- 95    */\n  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff, /*  - -103 60 */\n  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff, /* 104- ?     */\n  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff, /* 112-119 70 */\n  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff, /* 120- \"     */\n  0xff,0x0a,0x0b,0x0c,0x0d,0x0e,0x0f,0xff, /* 128- g  80 */\n  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff, /*  h -143    */\n  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff, /* 144- p  90 */\n  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff, /*  q -159    */\n  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff, /* 160- x  A0 */\n  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff, /*  y -175    */\n  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff, /*  \u00ac -183 B0 */\n  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff, /* 184-191    */\n  0xff,0x0a,0x0b,0x0c,0x0d,0x0e,0x0f,0xff, /*  { - G  C0 */\n  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff, /*  H -207    */\n  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff, /*  } - P  D0 */\n  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff, /*  Q -223    */\n  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff, /*  \\ - X  E0 */\n  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff, /*  Y -239    */\n  0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07, /*  0 - 7  F0 */\n  0x08,0x09,0xff,0xff,0xff,0xff,0xff,0xff};/*  8 -255    */\n#endif  /* EBCDIC */\n\n\n/* Table for handling alphanumeric escaped characters. Positive returns are\nsimple data values; negative values are for special things like \\d and so on.\nZero means further processing is needed (for things like \\x), or the escape is\ninvalid. */\n\n/* This is the \"normal\" table for ASCII systems or for EBCDIC systems running\nin UTF-8 mode. It runs from '0' to 'z'. */\n\n#ifndef EBCDIC\n#define ESCAPES_FIRST       CHAR_0\n#define ESCAPES_LAST        CHAR_z\n#define UPPER_CASE(c)       (c-32)\n\nstatic const short int escapes\u00dd\u00a8 = {\n     0,                       0,\n     0,                       0,\n     0,                       0,\n     0,                       0,\n     0,                       0,\n     CHAR_COLON,              CHAR_SEMICOLON,\n     CHAR_LESS_THAN_SIGN,     CHAR_EQUALS_SIGN,\n     CHAR_GREATER_THAN_SIGN,  CHAR_QUESTION_MARK,\n     CHAR_COMMERCIAL_AT,      -ESC_A,\n     -ESC_B,                  -ESC_C,\n     -ESC_D,                  -ESC_E,\n     0,                       -ESC_G,\n     -ESC_H,                  0,\n     0,                       -ESC_K,\n     0,                       0,\n     -ESC_N,                  0,\n     -ESC_P,                  -ESC_Q,\n     -ESC_R,                  -ESC_S,\n     0,                       0,\n     -ESC_V,                  -ESC_W,\n     -ESC_X,                  0,\n     -ESC_Z,                  CHAR_LEFT_SQUARE_BRACKET,\n     CHAR_BACKSLASH,          CHAR_RIGHT_SQUARE_BRACKET,\n     CHAR_CIRCUMFLEX_ACCENT,  CHAR_UNDERSCORE,\n     CHAR_GRAVE_ACCENT,       CHAR_BEL,\n     -ESC_b,                  0,\n     -ESC_d,                  CHAR_ESC,\n     CHAR_FF,                 0,\n     -ESC_h,                  0,\n     0,                       -ESC_k,\n     0,                       0,\n     CHAR_LF,                 0,\n     -ESC_p,                  0,\n     CHAR_CR,                 -ESC_s,\n     CHAR_HT,                 0,\n     -ESC_v,                  -ESC_w,\n     0,                       0,\n     -ESC_z\n};\n\n#else\n\n/* This is the \"abnormal\" table for EBCDIC systems without UTF-8 support.\nIt runs from 'a' to '9'. For some minimal testing of EBCDIC features, the code\nis sometimes compiled on an ASCII system. In this case, we must not use CHAR_a\nbecause it is defined as 'a', which of course picks up the ASCII value. */\n\n#if 'a' == 0x81                    /* Check for a real EBCDIC environment */\n#define ESCAPES_FIRST       CHAR_a\n#define ESCAPES_LAST        CHAR_9\n#define UPPER_CASE(c)       (c+64)\n#else                              /* Testing in an ASCII environment */\n#define ESCAPES_FIRST  ((unsigned char)'\\x81')   /* EBCDIC 'a' */\n#define ESCAPES_LAST   ((unsigned char)'\\xf9')   /* EBCDIC '9' */\n#define UPPER_CASE(c)  (c-32)\n#endif\n\nstatic const short int escapes\u00dd\u00a8 = {\n/*  80 */         CHAR_BEL, -ESC_b,       0, -ESC_d, CHAR_ESC, CHAR_FF,      0,\n/*  88 */ -ESC_h,        0,      0,     '{',      0,        0,       0,      0,\n/*  90 */      0,        0, -ESC_k,       0,      0,  CHAR_LF,       0, -ESC_p,\n/*  98 */      0,  CHAR_CR,      0,     '}',      0,        0,       0,      0,\n/*  A0 */      0,      '~', -ESC_s, CHAR_HT,      0,   -ESC_v,  -ESC_w,      0,\n/*  A8 */      0,   -ESC_z,      0,       0,      0,      '\u00dd',       0,      0,\n/*  B0 */      0,        0,      0,       0,      0,        0,       0,      0,\n/*  B8 */      0,        0,      0,       0,      0,      '\u00a8',     '=',    '-',\n/*  C0 */    '{',   -ESC_A, -ESC_B,  -ESC_C, -ESC_D,   -ESC_E,       0, -ESC_G,\n/*  C8 */ -ESC_H,        0,      0,       0,      0,        0,       0,      0,\n/*  D0 */    '}',        0, -ESC_K,       0,      0,   -ESC_N,       0, -ESC_P,\n/*  D8 */ -ESC_Q,   -ESC_R,      0,       0,      0,        0,       0,      0,\n/*  E0 */   '\\\\',        0, -ESC_S,       0,      0,   -ESC_V,  -ESC_W, -ESC_X,\n/*  E8 */      0,   -ESC_Z,      0,       0,      0,        0,       0,      0,\n/*  F0 */      0,        0,      0,       0,      0,        0,       0,      0,\n/*  F8 */      0,        0\n};\n\n/* We also need a table of characters that may follow \\c in an EBCDIC\nenvironment for characters 0-31. */\n\nstatic unsigned char ebcdic_escape_c\u00dd\u00a8 = \"@ABCDEFGHIJKLMNOPQRSTUVWXYZ\u00dd\\\\\u00a8\u00ac_\";\n\n#endif   /* EBCDIC */\n\n\n/* Table of special \"verbs\" like (*PRUNE). This is a short table, so it is\nsearched linearly. Put all the names into a single string, in order to reduce\nthe number of relocations when a shared library is dynamically linked. The\nstring is built from string macros so that it works in UTF-8 mode on EBCDIC\nplatforms. */\n\ntypedef struct verbitem {\n  unsigned int len;          /* Length of verb name */\n  uint32_t meta;             /* Base META_ code */\n  int has_arg;               /* Argument requirement */\n} verbitem;\n\nstatic const char verbnames\u00dd\u00a8 =\n  \"\\0\"                       /* Empty name is a shorthand for MARK */\n  STRING_MARK0\n  STRING_ACCEPT0\n  STRING_F0\n  STRING_FAIL0\n  STRING_COMMIT0\n  STRING_PRUNE0\n  STRING_SKIP0\n  STRING_THEN;\n\nstatic const verbitem verbs\u00dd\u00a8 = {\n  { 0, META_MARK,   +1 },  /* > 0 => must have an argument */\n  { 4, META_MARK,   +1 },\n  { 6, META_ACCEPT, -1 },  /* < 0 => Optional argument, convert to pre-MARK */\n  { 1, META_FAIL,   -1 },\n  { 4, META_FAIL,   -1 },\n  { 6, META_COMMIT,  0 },\n  { 5, META_PRUNE,   0 },  /* Optional argument; bump META code if found */\n  { 4, META_SKIP,    0 },\n  { 4, META_THEN,    0 }\n};\n\nstatic const int verbcount = sizeof(verbs)/sizeof(verbitem);\n\n/* Verb opcodes, indexed by their META code offset from META_MARK. */\n\nstatic const uint32_t verbops\u00dd\u00a8 = {\n  OP_MARK, OP_ACCEPT, OP_FAIL, OP_COMMIT, OP_COMMIT_ARG, OP_PRUNE,\n  OP_PRUNE_ARG, OP_SKIP, OP_SKIP_ARG, OP_THEN, OP_THEN_ARG };\n\n/* Table of \"alpha assertions\" like (*pla:...), similar to the (*VERB) table. */\n\ntypedef struct alasitem {\n  unsigned int len;          /* Length of name */\n  uint32_t meta;             /* Base META_ code */\n} alasitem;\n\nstatic const char alasnames\u00dd\u00a8 =\n  STRING_pla0\n  STRING_plb0\n  STRING_napla0\n  STRING_naplb0\n  STRING_nla0\n  STRING_nlb0\n  STRING_positive_lookahead0\n  STRING_positive_lookbehind0\n  STRING_non_atomic_positive_lookahead0\n  STRING_non_atomic_positive_lookbehind0\n  STRING_negative_lookahead0\n  STRING_negative_lookbehind0\n  STRING_atomic0\n  STRING_sr0\n  STRING_asr0\n  STRING_script_run0\n  STRING_atomic_script_run;\n\nstatic const alasitem alasmeta\u00dd\u00a8 = {\n  {  3, META_LOOKAHEAD         },\n  {  3, META_LOOKBEHIND        },\n  {  5, META_LOOKAHEAD_NA      },\n  {  5, META_LOOKBEHIND_NA     },\n  {  3, META_LOOKAHEADNOT      },\n  {  3, META_LOOKBEHINDNOT     },\n  { 18, META_LOOKAHEAD         },\n  { 19, META_LOOKBEHIND        },\n  { 29, META_LOOKAHEAD_NA      },\n  { 30, META_LOOKBEHIND_NA     },\n  { 18, META_LOOKAHEADNOT      },\n  { 19, META_LOOKBEHINDNOT     },\n  {  6, META_ATOMIC            },\n  {  2, META_SCRIPT_RUN        }, /* sr = script run */\n  {  3, META_ATOMIC_SCRIPT_RUN }, /* asr = atomic script run */\n  { 10, META_SCRIPT_RUN        }, /* script run */\n  { 17, META_ATOMIC_SCRIPT_RUN }  /* atomic script run */\n};\n\nstatic const int alascount = sizeof(alasmeta)/sizeof(alasitem);\n\n/* Offsets from OP_STAR for case-independent and negative repeat opcodes. */\n\nstatic uint32_t chartypeoffset\u00dd\u00a8 = {\n  OP_STAR - OP_STAR,    OP_STARI - OP_STAR,\n  OP_NOTSTAR - OP_STAR, OP_NOTSTARI - OP_STAR };\n\n/* Tables of names of POSIX character classes and their lengths. The names are\nnow all in a single string, to reduce the number of relocations when a shared\nlibrary is dynamically loaded. The list of lengths is terminated by a zero\nlength entry. The first three must be alpha, lower, upper, as this is assumed\nfor handling case independence. The indices for graph, print, and punct are\nneeded, so identify them. */\n\nstatic const char posix_names\u00dd\u00a8 =\n  STRING_alpha0 STRING_lower0 STRING_upper0 STRING_alnum0\n  STRING_ascii0 STRING_blank0 STRING_cntrl0 STRING_digit0\n  STRING_graph0 STRING_print0 STRING_punct0 STRING_space0\n  STRING_word0  STRING_xdigit;\n\nstatic const uint8_t posix_name_lengths\u00dd\u00a8 = {\n  5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 4, 6, 0 };\n\n#define PC_GRAPH  8\n#define PC_PRINT  9\n#define PC_PUNCT 10\n\n/* Table of class bit maps for each POSIX class. Each class is formed from a\nbase map, with an optional addition or removal of another map. Then, for some\nclasses, there is some additional tweaking: for \u00dd:blank:\u00a8 the vertical space\ncharacters are removed, and for \u00dd:alpha:\u00a8 and \u00dd:alnum:\u00a8 the underscore\ncharacter is removed. The triples in the table consist of the base map offset,\nsecond map offset or -1 if no second map, and a non-negative value for map\naddition or a negative value for map subtraction (if there are two maps). The\nabsolute value of the third field has these meanings: 0 => no tweaking, 1 =>\nremove vertical space characters, 2 => remove underscore. */\n\nstatic const int posix_class_maps\u00dd\u00a8 = {\n  cbit_word,  cbit_digit, -2,             /* alpha */\n  cbit_lower, -1,          0,             /* lower */\n  cbit_upper, -1,          0,             /* upper */\n  cbit_word,  -1,          2,             /* alnum - word without underscore */\n  cbit_print, cbit_cntrl,  0,             /* ascii */\n  cbit_space, -1,          1,             /* blank - a GNU extension */\n  cbit_cntrl, -1,          0,             /* cntrl */\n  cbit_digit, -1,          0,             /* digit */\n  cbit_graph, -1,          0,             /* graph */\n  cbit_print, -1,          0,             /* print */\n  cbit_punct, -1,          0,             /* punct */\n  cbit_space, -1,          0,             /* space */\n  cbit_word,  -1,          0,             /* word - a Perl extension */\n  cbit_xdigit,-1,          0              /* xdigit */\n};\n\n#ifdef SUPPORT_UNICODE\n\n/* The POSIX class Unicode property substitutes that are used in UCP mode must\nbe in the order of the POSIX class names, defined above. */\n\nstatic int posix_substitutes\u00dd\u00a8 = {\n  PT_GC, ucp_L,     /* alpha */\n  PT_PC, ucp_Ll,    /* lower */\n  PT_PC, ucp_Lu,    /* upper */\n  PT_ALNUM, 0,      /* alnum */\n  -1, 0,            /* ascii, treat as non-UCP */\n  -1, 1,            /* blank, treat as \\h */\n  PT_PC, ucp_Cc,    /* cntrl */\n  PT_PC, ucp_Nd,    /* digit */\n  PT_PXGRAPH, 0,    /* graph */\n  PT_PXPRINT, 0,    /* print */\n  PT_PXPUNCT, 0,    /* punct */\n  PT_PXSPACE, 0,    /* space */   /* Xps is POSIX space, but from 8.34 */\n  PT_WORD, 0,       /* word  */   /* Perl and POSIX space are the same */\n  -1, 0             /* xdigit, treat as non-UCP */\n};\n#define POSIX_SUBSIZE (sizeof(posix_substitutes) / (2*sizeof(uint32_t)))\n#endif  /* SUPPORT_UNICODE */\n\n/* Masks for checking option settings. When PCRE2_LITERAL is set, only a subset\nare allowed. */\n\n#define PUBLIC_LITERAL_COMPILE_OPTIONS \\\n  (PCRE2_ANCHORED|PCRE2_AUTO_CALLOUT|PCRE2_CASELESS|PCRE2_ENDANCHORED| \\\n   PCRE2_FIRSTLINE|PCRE2_LITERAL|PCRE2_MATCH_INVALID_UTF| \\\n   PCRE2_NO_START_OPTIMIZE|PCRE2_NO_UTF_CHECK|PCRE2_USE_OFFSET_LIMIT|PCRE2_UTF)\n\n#define PUBLIC_COMPILE_OPTIONS \\\n  (PUBLIC_LITERAL_COMPILE_OPTIONS| \\\n   PCRE2_ALLOW_EMPTY_CLASS|PCRE2_ALT_BSUX|PCRE2_ALT_CIRCUMFLEX| \\\n   PCRE2_ALT_VERBNAMES|PCRE2_DOLLAR_ENDONLY|PCRE2_DOTALL|PCRE2_DUPNAMES| \\\n   PCRE2_EXTENDED|PCRE2_EXTENDED_MORE|PCRE2_MATCH_UNSET_BACKREF| \\\n   PCRE2_MULTILINE|PCRE2_NEVER_BACKSLASH_C|PCRE2_NEVER_UCP| \\\n   PCRE2_NEVER_UTF|PCRE2_NO_AUTO_CAPTURE|PCRE2_NO_AUTO_POSSESS| \\\n   PCRE2_NO_DOTSTAR_ANCHOR|PCRE2_UCP|PCRE2_UNGREEDY)\n\n#define PUBLIC_LITERAL_COMPILE_EXTRA_OPTIONS \\\n   (PCRE2_EXTRA_MATCH_LINE|PCRE2_EXTRA_MATCH_WORD)\n\n#define PUBLIC_COMPILE_EXTRA_OPTIONS \\\n   (PUBLIC_LITERAL_COMPILE_EXTRA_OPTIONS| \\\n    PCRE2_EXTRA_ALLOW_SURROGATE_ESCAPES|PCRE2_EXTRA_BAD_ESCAPE_IS_LITERAL| \\\n    PCRE2_EXTRA_ESCAPED_CR_IS_LF|PCRE2_EXTRA_ALT_BSUX)\n\n/* Compile time error code numbers. They are given names so that they can more\neasily be tracked. When a new number is added, the tables called eint1 and\neint2 in pcre2posix.c may need to be updated, and a new error text must be\nadded to compile_error_texts in pcre2_error.c. */\n\nenum { ERR0 = COMPILE_ERROR_BASE,\n       ERR1,  ERR2,  ERR3,  ERR4,  ERR5,  ERR6,  ERR7,  ERR8,  ERR9,  ERR10,\n       ERR11, ERR12, ERR13, ERR14, ERR15, ERR16, ERR17, ERR18, ERR19, ERR20,\n       ERR21, ERR22, ERR23, ERR24, ERR25, ERR26, ERR27, ERR28, ERR29, ERR30,\n       ERR31, ERR32, ERR33, ERR34, ERR35, ERR36, ERR37, ERR38, ERR39, ERR40,\n       ERR41, ERR42, ERR43, ERR44, ERR45, ERR46, ERR47, ERR48, ERR49, ERR50,\n       ERR51, ERR52, ERR53, ERR54, ERR55, ERR56, ERR57, ERR58, ERR59, ERR60,\n       ERR61, ERR62, ERR63, ERR64, ERR65, ERR66, ERR67, ERR68, ERR69, ERR70,\n       ERR71, ERR72, ERR73, ERR74, ERR75, ERR76, ERR77, ERR78, ERR79, ERR80,\n       ERR81, ERR82, ERR83, ERR84, ERR85, ERR86, ERR87, ERR88, ERR89, ERR90,\n       ERR91, ERR92, ERR93, ERR94, ERR95, ERR96, ERR97, ERR98 };\n\n/* This is a table of start-of-pattern options such as (*UTF) and settings such\nas (*LIMIT_MATCH=nnnn) and (*CRLF). For completeness and backward\ncompatibility, (*UTFn) is supported in the relevant libraries, but (*UTF) is\ngeneric and always supported. */\n\nenum { PSO_OPT,     /* Value is an option bit */\n       PSO_FLG,     /* Value is a flag bit */\n       PSO_NL,      /* Value is a newline type */\n       PSO_BSR,     /* Value is a \\R type */\n       PSO_LIMH,    /* Read integer value for heap limit */\n       PSO_LIMM,    /* Read integer value for match limit */\n       PSO_LIMD };  /* Read integer value for depth limit */\n\ntypedef struct pso {\n  const uint8_t *name;\n  uint16_t length;\n  uint16_t type;\n  uint32_t value;\n} pso;\n\n/* NB: STRING_UTFn_RIGHTPAR contains the length as well */\n\nstatic pso pso_list\u00dd\u00a8 = {\n  { (uint8_t *)STRING_UTFn_RIGHTPAR,                  PSO_OPT, PCRE2_UTF },\n  { (uint8_t *)STRING_UTF_RIGHTPAR,                4, PSO_OPT, PCRE2_UTF },\n  { (uint8_t *)STRING_UCP_RIGHTPAR,                4, PSO_OPT, PCRE2_UCP },\n  { (uint8_t *)STRING_NOTEMPTY_RIGHTPAR,           9, PSO_FLG, PCRE2_NOTEMPTY_SET },\n  { (uint8_t *)STRING_NOTEMPTY_ATSTART_RIGHTPAR,  17, PSO_FLG, PCRE2_NE_ATST_SET },\n  { (uint8_t *)STRING_NO_AUTO_POSSESS_RIGHTPAR,   16, PSO_OPT, PCRE2_NO_AUTO_POSSESS },\n  { (uint8_t *)STRING_NO_DOTSTAR_ANCHOR_RIGHTPAR, 18, PSO_OPT, PCRE2_NO_DOTSTAR_ANCHOR },\n  { (uint8_t *)STRING_NO_JIT_RIGHTPAR,             7, PSO_FLG, PCRE2_NOJIT },\n  { (uint8_t *)STRING_NO_START_OPT_RIGHTPAR,      13, PSO_OPT, PCRE2_NO_START_OPTIMIZE },\n  { (uint8_t *)STRING_LIMIT_HEAP_EQ,              11, PSO_LIMH, 0 },\n  { (uint8_t *)STRING_LIMIT_MATCH_EQ,             12, PSO_LIMM, 0 },\n  { (uint8_t *)STRING_LIMIT_DEPTH_EQ,             12, PSO_LIMD, 0 },\n  { (uint8_t *)STRING_LIMIT_RECURSION_EQ,         16, PSO_LIMD, 0 },\n  { (uint8_t *)STRING_CR_RIGHTPAR,                 3, PSO_NL,  PCRE2_NEWLINE_CR },\n  { (uint8_t *)STRING_LF_RIGHTPAR,                 3, PSO_NL,  PCRE2_NEWLINE_LF },\n  { (uint8_t *)STRING_CRLF_RIGHTPAR,               5, PSO_NL,  PCRE2_NEWLINE_CRLF },\n  { (uint8_t *)STRING_ANY_RIGHTPAR,                4, PSO_NL,  PCRE2_NEWLINE_ANY },\n  { (uint8_t *)STRING_NUL_RIGHTPAR,                4, PSO_NL,  PCRE2_NEWLINE_NUL },\n  { (uint8_t *)STRING_ANYCRLF_RIGHTPAR,            8, PSO_NL,  PCRE2_NEWLINE_ANYCRLF },\n  { (uint8_t *)STRING_BSR_ANYCRLF_RIGHTPAR,       12, PSO_BSR, PCRE2_BSR_ANYCRLF },\n  { (uint8_t *)STRING_BSR_UNICODE_RIGHTPAR,       12, PSO_BSR, PCRE2_BSR_UNICODE }\n};\n\n/* This table is used when converting repeating opcodes into possessified\nversions as a result of an explicit possessive quantifier such as ++. A zero\nvalue means there is no possessified version - in those cases the item in\nquestion must be wrapped in ONCE brackets. The table is truncated at OP_CALLOUT\nbecause all relevant opcodes are less than that. */\n\nstatic const uint8_t opcode_possessify\u00dd\u00a8 = {\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,   /* 0 - 15  */\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,   /* 16 - 31 */\n\n  0,                       /* NOTI */\n  OP_POSSTAR, 0,           /* STAR, MINSTAR */\n  OP_POSPLUS, 0,           /* PLUS, MINPLUS */\n  OP_POSQUERY, 0,          /* QUERY, MINQUERY */\n  OP_POSUPTO, 0,           /* UPTO, MINUPTO */\n  0,                       /* EXACT */\n  0, 0, 0, 0,              /* POS{STAR,PLUS,QUERY,UPTO} */\n\n  OP_POSSTARI, 0,          /* STARI, MINSTARI */\n  OP_POSPLUSI, 0,          /* PLUSI, MINPLUSI */\n  OP_POSQUERYI, 0,         /* QUERYI, MINQUERYI */\n  OP_POSUPTOI, 0,          /* UPTOI, MINUPTOI */\n  0,                       /* EXACTI */\n  0, 0, 0, 0,              /* POS{STARI,PLUSI,QUERYI,UPTOI} */\n\n  OP_NOTPOSSTAR, 0,        /* NOTSTAR, NOTMINSTAR */\n  OP_NOTPOSPLUS, 0,        /* NOTPLUS, NOTMINPLUS */\n  OP_NOTPOSQUERY, 0,       /* NOTQUERY, NOTMINQUERY */\n  OP_NOTPOSUPTO, 0,        /* NOTUPTO, NOTMINUPTO */\n  0,                       /* NOTEXACT */\n  0, 0, 0, 0,              /* NOTPOS{STAR,PLUS,QUERY,UPTO} */\n\n  OP_NOTPOSSTARI, 0,       /* NOTSTARI, NOTMINSTARI */\n  OP_NOTPOSPLUSI, 0,       /* NOTPLUSI, NOTMINPLUSI */\n  OP_NOTPOSQUERYI, 0,      /* NOTQUERYI, NOTMINQUERYI */\n  OP_NOTPOSUPTOI, 0,       /* NOTUPTOI, NOTMINUPTOI */\n  0,                       /* NOTEXACTI */\n  0, 0, 0, 0,              /* NOTPOS{STARI,PLUSI,QUERYI,UPTOI} */\n\n  OP_TYPEPOSSTAR, 0,       /* TYPESTAR, TYPEMINSTAR */\n  OP_TYPEPOSPLUS, 0,       /* TYPEPLUS, TYPEMINPLUS */\n  OP_TYPEPOSQUERY, 0,      /* TYPEQUERY, TYPEMINQUERY */\n  OP_TYPEPOSUPTO, 0,       /* TYPEUPTO, TYPEMINUPTO */\n  0,                       /* TYPEEXACT */\n  0, 0, 0, 0,              /* TYPEPOS{STAR,PLUS,QUERY,UPTO} */\n\n  OP_CRPOSSTAR, 0,         /* CRSTAR, CRMINSTAR */\n  OP_CRPOSPLUS, 0,         /* CRPLUS, CRMINPLUS */\n  OP_CRPOSQUERY, 0,        /* CRQUERY, CRMINQUERY */\n  OP_CRPOSRANGE, 0,        /* CRRANGE, CRMINRANGE */\n  0, 0, 0, 0,              /* CRPOS{STAR,PLUS,QUERY,RANGE} */\n\n  0, 0, 0,                 /* CLASS, NCLASS, XCLASS */\n  0, 0,                    /* REF, REFI */\n  0, 0,                    /* DNREF, DNREFI */\n  0, 0                     /* RECURSE, CALLOUT */\n};\n\n\n#ifdef DEBUG_SHOW_PARSED\n/*************************************************\n*     Show the parsed pattern for debugging      *\n*************************************************/\n\n/* For debugging the pre-scan, this code, which outputs the parsed data vector,\ncan be enabled. */\n\nstatic void show_parsed(compile_block *cb)\n{\nuint32_t *pptr = cb->parsed_pattern;\n\nfor (;;)\n  {\n  int max, min;\n  PCRE2_SIZE offset;\n  uint32_t i;\n  uint32_t length;\n  uint32_t meta_arg = META_DATA(*pptr);\n\n  fprintf(stderr, \"+++ %02d %.8x \", (int)(pptr - cb->parsed_pattern), *pptr);\n\n  if (*pptr < META_END)\n    {\n    if (*pptr > 32 && *pptr < 128) fprintf(stderr, \"%c\", *pptr);\n    pptr++;\n    }\n\n  else switch (META_CODE(*pptr++))\n    {\n    default:\n    fprintf(stderr, \"**** OOPS - unknown META value - giving up ****\\n\");\n    return;\n\n    case META_END:\n    fprintf(stderr, \"META_END\\n\");\n    return;\n\n    case META_CAPTURE:\n    fprintf(stderr, \"META_CAPTURE %d\", meta_arg);\n    break;\n\n    case META_RECURSE:\n    GETOFFSET(offset, pptr);\n    fprintf(stderr, \"META_RECURSE %d %zd\", meta_arg, offset);\n    break;\n\n    case META_BACKREF:\n    if (meta_arg < 10)\n      offset = cb->small_ref_offset\u00ddmeta_arg\u00a8;\n    else\n      GETOFFSET(offset, pptr);\n    fprintf(stderr, \"META_BACKREF %d %zd\", meta_arg, offset);\n    break;\n\n    case META_ESCAPE:\n    if (meta_arg == ESC_P || meta_arg == ESC_p)\n      {\n      uint32_t ptype = *pptr >> 16;\n      uint32_t pvalue = *pptr++ & 0xffff;\n      fprintf(stderr, \"META \\\\%c %d %d\", (meta_arg == ESC_P)? 'P':'p',\n        ptype, pvalue);\n      }\n    else\n      {\n      uint32_t cc;\n      /* There's just one escape we might have here that isn't negated in the\n      escapes table. */\n      if (meta_arg == ESC_g) cc = CHAR_g;\n      else for (cc = ESCAPES_FIRST; cc <= ESCAPES_LAST; cc++)\n        {\n        if (meta_arg == (uint32_t)(-escapes\u00ddcc - ESCAPES_FIRST\u00a8)) break;\n        }\n      if (cc > ESCAPES_LAST) cc = CHAR_QUESTION_MARK;\n      fprintf(stderr, \"META \\\\%c\", cc);\n      }\n    break;\n\n    case META_MINMAX:\n    min = *pptr++;\n    max = *pptr++;\n    if (max != REPEAT_UNLIMITED)\n      fprintf(stderr, \"META {%d,%d}\", min, max);\n    else\n      fprintf(stderr, \"META {%d,}\", min);\n    break;\n\n    case META_MINMAX_QUERY:\n    min = *pptr++;\n    max = *pptr++;\n    if (max != REPEAT_UNLIMITED)\n      fprintf(stderr, \"META {%d,%d}?\", min, max);\n    else\n      fprintf(stderr, \"META {%d,}?\", min);\n    break;\n\n    case META_MINMAX_PLUS:\n    min = *pptr++;\n    max = *pptr++;\n    if (max != REPEAT_UNLIMITED)\n      fprintf(stderr, \"META {%d,%d}+\", min, max);\n    else\n      fprintf(stderr, \"META {%d,}+\", min);\n    break;\n\n    case META_BIGVALUE: fprintf(stderr, \"META_BIGVALUE %.8x\", *pptr++); break;\n    case META_CIRCUMFLEX: fprintf(stderr, \"META_CIRCUMFLEX\"); break;\n    case META_COND_ASSERT: fprintf(stderr, \"META_COND_ASSERT\"); break;\n    case META_DOLLAR: fprintf(stderr, \"META_DOLLAR\"); break;\n    case META_DOT: fprintf(stderr, \"META_DOT\"); break;\n    case META_ASTERISK: fprintf(stderr, \"META *\"); break;\n    case META_ASTERISK_QUERY: fprintf(stderr, \"META *?\"); break;\n    case META_ASTERISK_PLUS: fprintf(stderr, \"META *+\"); break;\n    case META_PLUS: fprintf(stderr, \"META +\"); break;\n    case META_PLUS_QUERY: fprintf(stderr, \"META +?\"); break;\n    case META_PLUS_PLUS: fprintf(stderr, \"META ++\"); break;\n    case META_QUERY: fprintf(stderr, \"META ?\"); break;\n    case META_QUERY_QUERY: fprintf(stderr, \"META ??\"); break;\n    case META_QUERY_PLUS: fprintf(stderr, \"META ?+\"); break;\n\n    case META_ATOMIC: fprintf(stderr, \"META (?>\"); break;\n    case META_NOCAPTURE: fprintf(stderr, \"META (?:\"); break;\n    case META_LOOKAHEAD: fprintf(stderr, \"META (?=\"); break;\n    case META_LOOKAHEADNOT: fprintf(stderr, \"META (?!\"); break;\n    case META_LOOKAHEAD_NA: fprintf(stderr, \"META (*napla:\"); break;\n    case META_SCRIPT_RUN: fprintf(stderr, \"META (*sr:\"); break;\n    case META_KET: fprintf(stderr, \"META )\"); break;\n    case META_ALT: fprintf(stderr, \"META | %d\", meta_arg); break;\n\n    case META_CLASS: fprintf(stderr, \"META \u00dd\"); break;\n    case META_CLASS_NOT: fprintf(stderr, \"META \u00dd\u00ac\"); break;\n    case META_CLASS_END: fprintf(stderr, \"META \u00a8\"); break;\n    case META_CLASS_EMPTY: fprintf(stderr, \"META \u00dd\u00a8\"); break;\n    case META_CLASS_EMPTY_NOT: fprintf(stderr, \"META \u00dd\u00ac\u00a8\"); break;\n\n    case META_RANGE_LITERAL: fprintf(stderr, \"META - (literal)\"); break;\n    case META_RANGE_ESCAPED: fprintf(stderr, \"META - (escaped)\"); break;\n\n    case META_POSIX: fprintf(stderr, \"META_POSIX %d\", *pptr++); break;\n    case META_POSIX_NEG: fprintf(stderr, \"META_POSIX_NEG %d\", *pptr++); break;\n\n    case META_ACCEPT: fprintf(stderr, \"META (*ACCEPT)\"); break;\n    case META_FAIL: fprintf(stderr, \"META (*FAIL)\"); break;\n    case META_COMMIT: fprintf(stderr, \"META (*COMMIT)\"); break;\n    case META_PRUNE: fprintf(stderr, \"META (*PRUNE)\"); break;\n    case META_SKIP: fprintf(stderr, \"META (*SKIP)\"); break;\n    case META_THEN: fprintf(stderr, \"META (*THEN)\"); break;\n\n    case META_OPTIONS: fprintf(stderr, \"META_OPTIONS 0x%02x\", *pptr++); break;\n\n    case META_LOOKBEHIND:\n    fprintf(stderr, \"META (?<= %d offset=\", meta_arg);\n    GETOFFSET(offset, pptr);\n    fprintf(stderr, \"%zd\", offset);\n    break;\n\n    case META_LOOKBEHIND_NA:\n    fprintf(stderr, \"META (*naplb: %d offset=\", meta_arg);\n    GETOFFSET(offset, pptr);\n    fprintf(stderr, \"%zd\", offset);\n    break;\n\n    case META_LOOKBEHINDNOT:\n    fprintf(stderr, \"META (?<! %d offset=\", meta_arg);\n    GETOFFSET(offset, pptr);\n    fprintf(stderr, \"%zd\", offset);\n    break;\n\n    case META_CALLOUT_NUMBER:\n    fprintf(stderr, \"META (?C%d) next=%d/%d\", pptr\u00dd2\u00a8, pptr\u00dd0\u00a8,\n       pptr\u00dd1\u00a8);\n    pptr += 3;\n    break;\n\n    case META_CALLOUT_STRING:\n      {\n      uint32_t patoffset = *pptr++;    /* Offset of next pattern item */\n      uint32_t patlength = *pptr++;    /* Length of next pattern item */\n      fprintf(stderr, \"META (?Cstring) length=%d offset=\", *pptr++);\n      GETOFFSET(offset, pptr);\n      fprintf(stderr, \"%zd next=%d/%d\", offset, patoffset, patlength);\n      }\n    break;\n\n    case META_RECURSE_BYNAME:\n    fprintf(stderr, \"META (?(&name) length=%d offset=\", *pptr++);\n    GETOFFSET(offset, pptr);\n    fprintf(stderr, \"%zd\", offset);\n    break;\n\n    case META_BACKREF_BYNAME:\n    fprintf(stderr, \"META_BACKREF_BYNAME length=%d offset=\", *pptr++);\n    GETOFFSET(offset, pptr);\n    fprintf(stderr, \"%zd\", offset);\n    break;\n\n    case META_COND_NUMBER:\n    fprintf(stderr, \"META_COND_NUMBER %d offset=\", pptr\u00ddSIZEOFFSET\u00a8);\n    GETOFFSET(offset, pptr);\n    fprintf(stderr, \"%zd\", offset);\n    pptr++;\n    break;\n\n    case META_COND_DEFINE:\n    fprintf(stderr, \"META (?(DEFINE) offset=\");\n    GETOFFSET(offset, pptr);\n    fprintf(stderr, \"%zd\", offset);\n    break;\n\n    case META_COND_VERSION:\n    fprintf(stderr, \"META (?(VERSION%s\", (*pptr++ == 0)? \"=\" : \">=\");\n    fprintf(stderr, \"%d.\", *pptr++);\n    fprintf(stderr, \"%d)\", *pptr++);\n    break;\n\n    case META_COND_NAME:\n    fprintf(stderr, \"META (?(<name>) length=%d offset=\", *pptr++);\n    GETOFFSET(offset, pptr);\n    fprintf(stderr, \"%zd\", offset);\n    break;\n\n    case META_COND_RNAME:\n    fprintf(stderr, \"META (?(R&name) length=%d offset=\", *pptr++);\n    GETOFFSET(offset, pptr);\n    fprintf(stderr, \"%zd\", offset);\n    break;\n\n    /* This is kept as a name, because it might be. */\n\n    case META_COND_RNUMBER:\n    fprintf(stderr, \"META (?(Rnumber) length=%d offset=\", *pptr++);\n    GETOFFSET(offset, pptr);\n    fprintf(stderr, \"%zd\", offset);\n    break;\n\n    case META_MARK:\n    fprintf(stderr, \"META (*MARK:\");\n    goto SHOWARG;\n\n    case META_COMMIT_ARG:\n    fprintf(stderr, \"META (*COMMIT:\");\n    goto SHOWARG;\n\n    case META_PRUNE_ARG:\n    fprintf(stderr, \"META (*PRUNE:\");\n    goto SHOWARG;\n\n    case META_SKIP_ARG:\n    fprintf(stderr, \"META (*SKIP:\");\n    goto SHOWARG;\n\n    case META_THEN_ARG:\n    fprintf(stderr, \"META (*THEN:\");\n    SHOWARG:\n    length = *pptr++;\n    for (i = 0; i < length; i++)\n      {\n      uint32_t cc = *pptr++;\n      if (cc > 32 && cc < 128) fprintf(stderr, \"%c\", cc);\n        else fprintf(stderr, \"\\\\x{%x}\", cc);\n      }\n    fprintf(stderr, \") length=%u\", length);\n    break;\n    }\n  fprintf(stderr, \"\\n\");\n  }\nreturn;\n}\n#endif  /* DEBUG_SHOW_PARSED */\n\n\n\n/*************************************************\n*               Copy compiled code               *\n*************************************************/\n\n/* Compiled JIT code cannot be copied, so the new compiled block has no\nassociated JIT data. */\n\nPCRE2_EXP_DEFN pcre2_code * PCRE2_CALL_CONVENTION\npcre2_code_copy(const pcre2_code *code)\n{\nPCRE2_SIZE* ref_count;\npcre2_code *newcode;\n\nif (code == NULL) return NULL;\nnewcode = code->memctl.malloc(code->blocksize, code->memctl.memory_data);\nif (newcode == NULL) return NULL;\nmemcpy(newcode, code, code->blocksize);\nnewcode->executable_jit = NULL;\n\n/* If the code is one that has been deserialized, increment the reference count\nin the decoded tables. */\n\nif ((code->flags & PCRE2_DEREF_TABLES) != 0)\n  {\n  ref_count = (PCRE2_SIZE *)(code->tables + TABLES_LENGTH);\n  (*ref_count)++;\n  }\n\nreturn newcode;\n}\n\n\n\n/*************************************************\n*     Copy compiled code and character tables    *\n*************************************************/\n\n/* Compiled JIT code cannot be copied, so the new compiled block has no\nassociated JIT data. This version of code_copy also makes a separate copy of\nthe character tables. */\n\nPCRE2_EXP_DEFN pcre2_code * PCRE2_CALL_CONVENTION\npcre2_code_copy_with_tables(const pcre2_code *code)\n{\nPCRE2_SIZE* ref_count;\npcre2_code *newcode;\nuint8_t *newtables;\n\nif (code == NULL) return NULL;\nnewcode = code->memctl.malloc(code->blocksize, code->memctl.memory_data);\nif (newcode == NULL) return NULL;\nmemcpy(newcode, code, code->blocksize);\nnewcode->executable_jit = NULL;\n\nnewtables = code->memctl.malloc(TABLES_LENGTH + sizeof(PCRE2_SIZE),\n  code->memctl.memory_data);\nif (newtables == NULL)\n  {\n  code->memctl.free((void *)newcode, code->memctl.memory_data);\n  return NULL;\n  }\nmemcpy(newtables, code->tables, TABLES_LENGTH);\nref_count = (PCRE2_SIZE *)(newtables + TABLES_LENGTH);\n*ref_count = 1;\n\nnewcode->tables = newtables;\nnewcode->flags |= PCRE2_DEREF_TABLES;\nreturn newcode;\n}\n\n\n\n/*************************************************\n*               Free compiled code               *\n*************************************************/\n\nPCRE2_EXP_DEFN void PCRE2_CALL_CONVENTION\npcre2_code_free(pcre2_code *code)\n{\nPCRE2_SIZE* ref_count;\n\nif (code != NULL)\n  {\n  if (code->executable_jit != NULL)\n    PRIV(jit_free)(code->executable_jit, &code->memctl);\n\n  if ((code->flags & PCRE2_DEREF_TABLES) != 0)\n    {\n    /* Decoded tables belong to the codes after deserialization, and they must\n    be freed when there are no more references to them. The *ref_count should\n    always be > 0. */\n\n    ref_count = (PCRE2_SIZE *)(code->tables + TABLES_LENGTH);\n    if (*ref_count > 0)\n      {\n      (*ref_count)--;\n      if (*ref_count == 0)\n        code->memctl.free((void *)code->tables, code->memctl.memory_data);\n      }\n    }\n\n  code->memctl.free(code, code->memctl.memory_data);\n  }\n}\n\n\n\n/*************************************************\n*         Read a number, possibly signed         *\n*************************************************/\n\n/* This function is used to read numbers in the pattern. The initial pointer\nmust be the sign or first digit of the number. When relative values (introduced\nby + or -) are allowed, they are relative group numbers, and the result must be\ngreater than zero.\n\nArguments:\n  ptrptr      points to the character pointer variable\n  ptrend      points to the end of the input string\n  allow_sign  if < 0, sign not allowed; if >= 0, sign is relative to this\n  max_value   the largest number allowed\n  max_error   the error to give for an over-large number\n  intptr      where to put the result\n  errcodeptr  where to put an error code\n\nReturns:      TRUE  - a number was read\n              FALSE - errorcode == 0 => no number was found\n                      errorcode != 0 => an error occurred\n*/\n\nstatic BOOL\nread_number(PCRE2_SPTR *ptrptr, PCRE2_SPTR ptrend, int32_t allow_sign,\n  uint32_t max_value, uint32_t max_error, int *intptr, int *errorcodeptr)\n{\nint sign = 0;\nuint32_t n = 0;\nPCRE2_SPTR ptr = *ptrptr;\nBOOL yield = FALSE;\n\n*errorcodeptr = 0;\n\nif (allow_sign >= 0 && ptr < ptrend)\n  {\n  if (*ptr == CHAR_PLUS)\n    {\n    sign = +1;\n    max_value -= allow_sign;\n    ptr++;\n    }\n  else if (*ptr == CHAR_MINUS)\n    {\n    sign = -1;\n    ptr++;\n    }\n  }\n\nif (ptr >= ptrend || !IS_DIGIT(*ptr)) return FALSE;\nwhile (ptr < ptrend && IS_DIGIT(*ptr))\n  {\n  n = n * 10 + *ptr++ - CHAR_0;\n  if (n > max_value)\n    {\n    *errorcodeptr = max_error;\n    goto EXIT;\n    }\n  }\n\nif (allow_sign >= 0 && sign != 0)\n  {\n  if (n == 0)\n    {\n    *errorcodeptr = ERR26;  /* +0 and -0 are not allowed */\n    goto EXIT;\n    }\n\n  if (sign > 0) n += allow_sign;\n  else if ((int)n > allow_sign)\n    {\n    *errorcodeptr = ERR15;  /* Non-existent subpattern */\n    goto EXIT;\n    }\n  else n = allow_sign + 1 - n;\n  }\n\nyield = TRUE;\n\nEXIT:\n*intptr = n;\n*ptrptr = ptr;\nreturn yield;\n}\n\n\n\n/*************************************************\n*         Read repeat counts                     *\n*************************************************/\n\n/* Read an item of the form {n,m} and return the values if non-NULL pointers\nare supplied. Repeat counts must be less than 65536 (MAX_REPEAT_COUNT); a\nlarger value is used for \"unlimited\". We have to use signed arguments for\nread_number() because it is capable of returning a signed value.\n\nArguments:\n  ptrptr         points to pointer to character after'{'\n  ptrend         pointer to end of input\n  minp           if not NULL, pointer to int for min\n  maxp           if not NULL, pointer to int for max (-1 if no max)\n                 returned as -1 if no max\n  errorcodeptr   points to error code variable\n\nReturns:         FALSE if not a repeat quantifier, errorcode set zero\n                 FALSE on error, with errorcode set non-zero\n                 TRUE on success, with pointer updated to point after '}'\n*/\n\nstatic BOOL\nread_repeat_counts(PCRE2_SPTR *ptrptr, PCRE2_SPTR ptrend, uint32_t *minp,\n  uint32_t *maxp, int *errorcodeptr)\n{\nPCRE2_SPTR p = *ptrptr;\nBOOL yield = FALSE;\nint32_t min = 0;\nint32_t max = REPEAT_UNLIMITED; /* This value is larger than MAX_REPEAT_COUNT */\n\n/* NB read_number() initializes the error code to zero. The only error is for a\nnumber that is too big. */\n\nif (!read_number(&p, ptrend, -1, MAX_REPEAT_COUNT, ERR5, &min, errorcodeptr))\n  goto EXIT;\n\nif (p >= ptrend) goto EXIT;\n\nif (*p == CHAR_RIGHT_CURLY_BRACKET)\n  {\n  p++;\n  max = min;\n  }\n\nelse\n  {\n  if (*p++ != CHAR_COMMA || p >= ptrend) goto EXIT;\n  if (*p != CHAR_RIGHT_CURLY_BRACKET)\n    {\n    if (!read_number(&p, ptrend, -1, MAX_REPEAT_COUNT, ERR5, &max,\n        errorcodeptr) || p >= ptrend ||  *p != CHAR_RIGHT_CURLY_BRACKET)\n      goto EXIT;\n    if (max < min)\n      {\n      *errorcodeptr = ERR4;\n      goto EXIT;\n      }\n    }\n  p++;\n  }\n\nyield = TRUE;\nif (minp != NULL) *minp = (uint32_t)min;\nif (maxp != NULL) *maxp = (uint32_t)max;\n\n/* Update the pattern pointer on success, or after an error, but not when\nthe result is \"not a repeat quantifier\". */\n\nEXIT:\nif (yield || *errorcodeptr != 0) *ptrptr = p;\nreturn yield;\n}\n\n\n\n/*************************************************\n*            Handle escapes                      *\n*************************************************/\n\n/* This function is called when a \\ has been encountered. It either returns a\npositive value for a simple escape such as \\d, or 0 for a data character, which\nis placed in chptr. A backreference to group n is returned as negative n. On\nentry, ptr is pointing at the character after \\. On exit, it points after the\nfinal code unit of the escape sequence.\n\nThis function is also called from pcre2_substitute() to handle escape sequences\nin replacement strings. In this case, the cb argument is NULL, and in the case\nof escapes that have further processing, only sequences that define a data\ncharacter are recognised. The isclass argument is not relevant; the options\nargument is the final value of the compiled pattern's options.\n\nArguments:\n  ptrptr         points to the input position pointer\n  ptrend         points to the end of the input\n  chptr          points to a returned data character\n  errorcodeptr   points to the errorcode variable (containing zero)\n  options        the current options bits\n  isclass        TRUE if inside a character class\n  cb             compile data block or NULL when called from pcre2_substitute()\n\nReturns:         zero => a data character\n                 positive => a special escape sequence\n                 negative => a numerical back reference\n                 on error, errorcodeptr is set non-zero\n*/\n\nint\nPRIV(check_escape)(PCRE2_SPTR *ptrptr, PCRE2_SPTR ptrend, uint32_t *chptr,\n  int *errorcodeptr, uint32_t options, uint32_t extra_options, BOOL isclass,\n  compile_block *cb)\n{\nBOOL utf = (options & PCRE2_UTF) != 0;\nPCRE2_SPTR ptr = *ptrptr;\nuint32_t c, cc;\nint escape = 0;\nint i;\n\n/* If backslash is at the end of the string, it's an error. */\n\nif (ptr >= ptrend)\n  {\n  *errorcodeptr = ERR1;\n  return 0;\n  }\n\nGETCHARINCTEST(c, ptr);         /* Get character value, increment pointer */\n*errorcodeptr = 0;              /* Be optimistic */\n\n/* Non-alphanumerics are literals, so we just leave the value in c. An initial\nvalue test saves a memory lookup for code points outside the alphanumeric\nrange. */\n\nif (c < ESCAPES_FIRST || c > ESCAPES_LAST) {}  /* Definitely literal */\n\n/* Otherwise, do a table lookup. Non-zero values need little processing here. A\npositive value is a literal value for something like \\n. A negative value is\nthe negation of one of the ESC_ macros that is passed back for handling by the\ncalling function. Some extra checking is needed for \\N because only \\N{U+dddd}\nis supported. If the value is zero, further processing is handled below. */\n\nelse if ((i = escapes\u00ddc - ESCAPES_FIRST\u00a8) != 0)\n  {\n  if (i > 0)\n    {\n    c = (uint32_t)i;\n    if (c == CHAR_CR && (extra_options & PCRE2_EXTRA_ESCAPED_CR_IS_LF) != 0)\n      c = CHAR_LF;\n    }\n  else  /* Negative table entry */\n    {\n    escape = -i;                    /* Else return a special escape */\n    if (cb != NULL && (escape == ESC_P || escape == ESC_p || escape == ESC_X))\n      cb->external_flags |= PCRE2_HASBKPORX;   /* Note \\P, \\p, or \\X */\n\n    /* Perl supports \\N{name} for character names and \\N{U+dddd} for numerical\n    Unicode code points, as well as plain \\N for \"not newline\". PCRE does not\n    support \\N{name}. However, it does support quantification such as \\N{2,3},\n    so if \\N{ is not followed by U+dddd we check for a quantifier. */\n\n    if (escape == ESC_N && ptr < ptrend && *ptr == CHAR_LEFT_CURLY_BRACKET)\n      {\n      PCRE2_SPTR p = ptr + 1;\n\n      /* \\N{U+ can be handled by the \\x{ code. However, this construction is\n      not valid in EBCDIC environments because it specifies a Unicode\n      character, not a codepoint in the local code. For example \\N{U+0041}\n      must be \"A\" in all environments. Also, in Perl, \\N{U+ forces Unicode\n      casing semantics for the entire pattern, so allow it only in UTF (i.e.\n      Unicode) mode. */\n\n      if (ptrend - p > 1 && *p == CHAR_U && p\u00dd1\u00a8 == CHAR_PLUS)\n        {\n#ifdef EBCDIC\n        *errorcodeptr = ERR93;\n#else\n        if (utf)\n          {\n          ptr = p + 1;\n          escape = 0;   /* Not a fancy escape after all */\n          goto COME_FROM_NU;\n          }\n        else *errorcodeptr = ERR93;\n#endif\n        }\n\n      /* Give an error if what follows is not a quantifier, but don't override\n      an error set by the quantifier reader (e.g. number overflow). */\n\n      else\n        {\n        if (!read_repeat_counts(&p, ptrend, NULL, NULL, errorcodeptr) &&\n             *errorcodeptr == 0)\n          *errorcodeptr = ERR37;\n        }\n      }\n    }\n  }\n\n/* Escapes that need further processing, including those that are unknown, have\na zero entry in the lookup table. When called from pcre2_substitute(), only \\c,\n\\o, and \\x are recognized (\\u and \\U can never appear as they are used for case\nforcing). */\n\nelse\n  {\n  int s;\n  PCRE2_SPTR oldptr;\n  BOOL overflow;\n  BOOL alt_bsux =\n    ((options & PCRE2_ALT_BSUX) | (extra_options & PCRE2_EXTRA_ALT_BSUX)) != 0;\n\n  /* Filter calls from pcre2_substitute(). */\n\n  if (cb == NULL)\n    {\n    if (c != CHAR_c && c != CHAR_o && c != CHAR_x)\n      {\n      *errorcodeptr = ERR3;\n      return 0;\n      }\n    alt_bsux = FALSE;   /* Do not modify \\x handling */\n    }\n\n  switch (c)\n    {\n    /* A number of Perl escapes are not handled by PCRE. We give an explicit\n    error. */\n\n    case CHAR_F:\n    case CHAR_l:\n    case CHAR_L:\n    *errorcodeptr = ERR37;\n    break;\n\n    /* \\u is unrecognized when neither PCRE2_ALT_BSUX nor PCRE2_EXTRA_ALT_BSUX\n    is set. Otherwise, \\u must be followed by exactly four hex digits or, if\n    PCRE2_EXTRA_ALT_BSUX is set, by any number of hex digits in braces.\n    Otherwise it is a lowercase u letter. This gives some compatibility with\n    ECMAScript (aka JavaScript). */\n\n    case CHAR_u:\n    if (!alt_bsux) *errorcodeptr = ERR37; else\n      {\n      uint32_t xc;\n\n      if (ptr >= ptrend) break;\n      if (*ptr == CHAR_LEFT_CURLY_BRACKET &&\n          (extra_options & PCRE2_EXTRA_ALT_BSUX) != 0)\n        {\n        PCRE2_SPTR hptr = ptr + 1;\n        cc = 0;\n\n        while (hptr < ptrend && (xc = XDIGIT(*hptr)) != 0xff)\n          {\n          if ((cc & 0xf0000000) != 0)  /* Test for 32-bit overflow */\n            {\n            *errorcodeptr = ERR77;\n            ptr = hptr;   /* Show where */\n            break;        /* *hptr != } will cause another break below */\n            }\n          cc = (cc << 4) | xc;\n          hptr++;\n          }\n\n        if (hptr == ptr + 1 ||   /* No hex digits */\n            hptr >= ptrend ||    /* Hit end of input */\n            *hptr != CHAR_RIGHT_CURLY_BRACKET)  /* No } terminator */\n          break;         /* Hex escape not recognized */\n\n        c = cc;          /* Accept the code point */\n        ptr = hptr + 1;\n        }\n\n      else  /* Must be exactly 4 hex digits */\n        {\n        if (ptrend - ptr < 4) break;               /* Less than 4 chars */\n        if ((cc = XDIGIT(ptr\u00dd0\u00a8)) == 0xff) break;  /* Not a hex digit */\n        if ((xc = XDIGIT(ptr\u00dd1\u00a8)) == 0xff) break;  /* Not a hex digit */\n        cc = (cc << 4) | xc;\n        if ((xc = XDIGIT(ptr\u00dd2\u00a8)) == 0xff) break;  /* Not a hex digit */\n        cc = (cc << 4) | xc;\n        if ((xc = XDIGIT(ptr\u00dd3\u00a8)) == 0xff) break;  /* Not a hex digit */\n        c = (cc << 4) | xc;\n        ptr += 4;\n        }\n\n      if (utf)\n        {\n        if (c > 0x10ffffU) *errorcodeptr = ERR77;\n        else\n          if (c >= 0xd800 && c <= 0xdfff &&\n              (extra_options & PCRE2_EXTRA_ALLOW_SURROGATE_ESCAPES) == 0)\n                *errorcodeptr = ERR73;\n        }\n      else if (c > MAX_NON_UTF_CHAR) *errorcodeptr = ERR77;\n      }\n    break;\n\n    /* \\U is unrecognized unless PCRE2_ALT_BSUX or PCRE2_EXTRA_ALT_BSUX is set,\n    in which case it is an upper case letter. */\n\n    case CHAR_U:\n    if (!alt_bsux) *errorcodeptr = ERR37;\n    break;\n\n    /* In a character class, \\g is just a literal \"g\". Outside a character\n    class, \\g must be followed by one of a number of specific things:\n\n    (1) A number, either plain or braced. If positive, it is an absolute\n    backreference. If negative, it is a relative backreference. This is a Perl\n    5.10 feature.\n\n    (2) Perl 5.10 also supports \\g{name} as a reference to a named group. This\n    is part of Perl's movement towards a unified syntax for back references. As\n    this is synonymous with \\k{name}, we fudge it up by pretending it really\n    was \\k{name}.\n\n    (3) For Oniguruma compatibility we also support \\g followed by a name or a\n    number either in angle brackets or in single quotes. However, these are\n    (possibly recursive) subroutine calls, _not_ backreferences. We return\n    the ESC_g code.\n\n    Summary: Return a negative number for a numerical back reference, ESC_k for\n    a named back reference, and ESC_g for a named or numbered subroutine call.\n    */\n\n    case CHAR_g:\n    if (isclass) break;\n\n    if (ptr >= ptrend)\n      {\n      *errorcodeptr = ERR57;\n      break;\n      }\n\n    if (*ptr == CHAR_LESS_THAN_SIGN || *ptr == CHAR_APOSTROPHE)\n      {\n      escape = ESC_g;\n      break;\n      }\n\n    /* If there is a brace delimiter, try to read a numerical reference. If\n    there isn't one, assume we have a name and treat it as \\k. */\n\n    if (*ptr == CHAR_LEFT_CURLY_BRACKET)\n      {\n      PCRE2_SPTR p = ptr + 1;\n      if (!read_number(&p, ptrend, cb->bracount, MAX_GROUP_NUMBER, ERR61, &s,\n          errorcodeptr))\n        {\n        if (*errorcodeptr == 0) escape = ESC_k;  /* No number found */\n        break;\n        }\n      if (p >= ptrend || *p != CHAR_RIGHT_CURLY_BRACKET)\n        {\n        *errorcodeptr = ERR57;\n        break;\n        }\n      ptr = p + 1;\n      }\n\n    /* Read an undelimited number */\n\n    else\n      {\n      if (!read_number(&ptr, ptrend, cb->bracount, MAX_GROUP_NUMBER, ERR61, &s,\n          errorcodeptr))\n        {\n        if (*errorcodeptr == 0) *errorcodeptr = ERR57;  /* No number found */\n        break;\n        }\n      }\n\n    if (s <= 0)\n      {\n      *errorcodeptr = ERR15;\n      break;\n      }\n\n    escape = -s;\n    break;\n\n    /* The handling of escape sequences consisting of a string of digits\n    starting with one that is not zero is not straightforward. Perl has changed\n    over the years. Nowadays \\g{} for backreferences and \\o{} for octal are\n    recommended to avoid the ambiguities in the old syntax.\n\n    Outside a character class, the digits are read as a decimal number. If the\n    number is less than 10, or if there are that many previous extracting left\n    brackets, it is a back reference. Otherwise, up to three octal digits are\n    read to form an escaped character code. Thus \\123 is likely to be octal 123\n    (cf \\0123, which is octal 012 followed by the literal 3).\n\n    Inside a character class, \\ followed by a digit is always either a literal\n    8 or 9 or an octal number. */\n\n    case CHAR_1: case CHAR_2: case CHAR_3: case CHAR_4: case CHAR_5:\n    case CHAR_6: case CHAR_7: case CHAR_8: case CHAR_9:\n\n    if (!isclass)\n      {\n      oldptr = ptr;\n      ptr--;   /* Back to the digit */\n      if (!read_number(&ptr, ptrend, -1, INT_MAX/10 - 1, ERR61, &s,\n          errorcodeptr))\n        break;\n\n      /* \\1 to \\9 are always back references. \\8x and \\9x are too; \\1x to \\7x\n      are octal escapes if there are not that many previous captures. */\n\n      if (s < 10 || oldptr\u00dd-1\u00a8 >= CHAR_8 || s <= (int)cb->bracount)\n        {\n        if (s > (int)MAX_GROUP_NUMBER) *errorcodeptr = ERR61;\n          else escape = -s;     /* Indicates a back reference */\n        break;\n        }\n      ptr = oldptr;      /* Put the pointer back and fall through */\n      }\n\n    /* Handle a digit following \\ when the number is not a back reference, or\n    we are within a character class. If the first digit is 8 or 9, Perl used to\n    generate a binary zero and then treat the digit as a following literal. At\n    least by Perl 5.18 this changed so as not to insert the binary zero. */\n\n    if (c >= CHAR_8) break;\n\n    /* Fall through */\n\n    /* \\0 always starts an octal number, but we may drop through to here with a\n    larger first octal digit. The original code used just to take the least\n    significant 8 bits of octal numbers (I think this is what early Perls used\n    to do). Nowadays we allow for larger numbers in UTF-8 mode and 16-bit mode,\n    but no more than 3 octal digits. */\n\n    case CHAR_0:\n    c -= CHAR_0;\n    while(i++ < 2 && ptr < ptrend && *ptr >= CHAR_0 && *ptr <= CHAR_7)\n        c = c * 8 + *ptr++ - CHAR_0;\n#if PCRE2_CODE_UNIT_WIDTH == 8\n    if (!utf && c > 0xff) *errorcodeptr = ERR51;\n#endif\n    break;\n\n    /* \\o is a relatively new Perl feature, supporting a more general way of\n    specifying character codes in octal. The only supported form is \\o{ddd}. */\n\n    case CHAR_o:\n    if (ptr >= ptrend || *ptr++ != CHAR_LEFT_CURLY_BRACKET)\n      {\n      ptr--;\n      *errorcodeptr = ERR55;\n      }\n    else if (ptr >= ptrend || *ptr == CHAR_RIGHT_CURLY_BRACKET)\n      *errorcodeptr = ERR78;\n    else\n      {\n      c = 0;\n      overflow = FALSE;\n      while (ptr < ptrend && *ptr >= CHAR_0 && *ptr <= CHAR_7)\n        {\n        cc = *ptr++;\n        if (c == 0 && cc == CHAR_0) continue;     /* Leading zeroes */\n#if PCRE2_CODE_UNIT_WIDTH == 32\n        if (c >= 0x20000000l) { overflow = TRUE; break; }\n#endif\n        c = (c << 3) + (cc - CHAR_0);\n#if PCRE2_CODE_UNIT_WIDTH == 8\n        if (c > (utf ? 0x10ffffU : 0xffU)) { overflow = TRUE; break; }\n#elif PCRE2_CODE_UNIT_WIDTH == 16\n        if (c > (utf ? 0x10ffffU : 0xffffU)) { overflow = TRUE; break; }\n#elif PCRE2_CODE_UNIT_WIDTH == 32\n        if (utf && c > 0x10ffffU) { overflow = TRUE; break; }\n#endif\n        }\n      if (overflow)\n        {\n        while (ptr < ptrend && *ptr >= CHAR_0 && *ptr <= CHAR_7) ptr++;\n        *errorcodeptr = ERR34;\n        }\n      else if (ptr < ptrend && *ptr++ == CHAR_RIGHT_CURLY_BRACKET)\n        {\n        if (utf && c >= 0xd800 && c <= 0xdfff &&\n            (extra_options & PCRE2_EXTRA_ALLOW_SURROGATE_ESCAPES) == 0)\n          {\n          ptr--;\n          *errorcodeptr = ERR73;\n          }\n        }\n      else\n        {\n        ptr--;\n        *errorcodeptr = ERR64;\n        }\n      }\n    break;\n\n    /* When PCRE2_ALT_BSUX or PCRE2_EXTRA_ALT_BSUX is set, \\x must be followed\n    by two hexadecimal digits. Otherwise it is a lowercase x letter. */\n\n    case CHAR_x:\n    if (alt_bsux)\n      {\n      uint32_t xc;\n      if (ptrend - ptr < 2) break;               /* Less than 2 characters */\n      if ((cc = XDIGIT(ptr\u00dd0\u00a8)) == 0xff) break;  /* Not a hex digit */\n      if ((xc = XDIGIT(ptr\u00dd1\u00a8)) == 0xff) break;  /* Not a hex digit */\n      c = (cc << 4) | xc;\n      ptr += 2;\n      }\n\n    /* Handle \\x in Perl's style. \\x{ddd} is a character code which can be\n    greater than 0xff in UTF-8 or non-8bit mode, but only if the ddd are hex\n    digits. If not, { used to be treated as a data character. However, Perl\n    seems to read hex digits up to the first non-such, and ignore the rest, so\n    that, for example \\x{zz} matches a binary zero. This seems crazy, so PCRE\n    now gives an error. */\n\n    else\n      {\n      if (ptr < ptrend && *ptr == CHAR_LEFT_CURLY_BRACKET)\n        {\n#ifndef EBCDIC\n        COME_FROM_NU:\n#endif\n        if (++ptr >= ptrend || *ptr == CHAR_RIGHT_CURLY_BRACKET)\n          {\n          *errorcodeptr = ERR78;\n          break;\n          }\n        c = 0;\n        overflow = FALSE;\n\n        while (ptr < ptrend && (cc = XDIGIT(*ptr)) != 0xff)\n          {\n          ptr++;\n          if (c == 0 && cc == 0) continue;   /* Leading zeroes */\n#if PCRE2_CODE_UNIT_WIDTH == 32\n          if (c >= 0x10000000l) { overflow = TRUE; break; }\n#endif\n          c = (c << 4) | cc;\n          if ((utf && c > 0x10ffffU) || (!utf && c > MAX_NON_UTF_CHAR))\n            {\n            overflow = TRUE;\n            break;\n            }\n          }\n\n        if (overflow)\n          {\n          while (ptr < ptrend && XDIGIT(*ptr) != 0xff) ptr++;\n          *errorcodeptr = ERR34;\n          }\n        else if (ptr < ptrend && *ptr++ == CHAR_RIGHT_CURLY_BRACKET)\n          {\n          if (utf && c >= 0xd800 && c <= 0xdfff &&\n              (extra_options & PCRE2_EXTRA_ALLOW_SURROGATE_ESCAPES) == 0)\n            {\n            ptr--;\n            *errorcodeptr = ERR73;\n            }\n          }\n\n        /* If the sequence of hex digits does not end with '}', give an error.\n        We used just to recognize this construct and fall through to the normal\n        \\x handling, but nowadays Perl gives an error, which seems much more\n        sensible, so we do too. */\n\n        else\n          {\n          ptr--;\n          *errorcodeptr = ERR67;\n          }\n        }   /* End of \\x{} processing */\n\n      /* Read a up to two hex digits after \\x */\n\n      else\n        {\n        c = 0;\n        if (ptr >= ptrend || (cc = XDIGIT(*ptr)) == 0xff) break;  /* Not a hex digit */\n        ptr++;\n        c = cc;\n        if (ptr >= ptrend || (cc = XDIGIT(*ptr)) == 0xff) break;  /* Not a hex digit */\n        ptr++;\n        c = (c << 4) | cc;\n        }     /* End of \\xdd handling */\n      }       /* End of Perl-style \\x handling */\n    break;\n\n    /* The handling of \\c is different in ASCII and EBCDIC environments. In an\n    ASCII (or Unicode) environment, an error is given if the character\n    following \\c is not a printable ASCII character. Otherwise, the following\n    character is upper-cased if it is a letter, and after that the 0x40 bit is\n    flipped. The result is the value of the escape.\n\n    In an EBCDIC environment the handling of \\c is compatible with the\n    specification in the perlebcdic document. The following character must be\n    a letter or one of small number of special characters. These provide a\n    means of defining the character values 0-31.\n\n    For testing the EBCDIC handling of \\c in an ASCII environment, recognize\n    the EBCDIC value of 'c' explicitly. */\n\n#if defined EBCDIC && 'a' != 0x81\n    case 0x83:\n#else\n    case CHAR_c:\n#endif\n    if (ptr >= ptrend)\n      {\n      *errorcodeptr = ERR2;\n      break;\n      }\n    c = *ptr;\n    if (c >= CHAR_a && c <= CHAR_z) c = UPPER_CASE(c);\n\n    /* Handle \\c in an ASCII/Unicode environment. */\n\n#ifndef EBCDIC    /* ASCII/UTF-8 coding */\n    if (c < 32 || c > 126)  /* Excludes all non-printable ASCII */\n      {\n      *errorcodeptr = ERR68;\n      break;\n      }\n    c \u00ac= 0x40;\n\n    /* Handle \\c in an EBCDIC environment. The special case \\c? is converted to\n    255 (0xff) or 95 (0x5f) if other characters suggest we are using the\n    POSIX-BC encoding. (This is the way Perl indicates that it handles \\c?.)\n    The other valid sequences correspond to a list of specific characters. */\n\n#else\n    if (c == CHAR_QUESTION_MARK)\n      c = ('\\\\' == 188 && '`' == 74)? 0x5f : 0xff;\n    else\n      {\n      for (i = 0; i < 32; i++)\n        {\n        if (c == ebcdic_escape_c\u00ddi\u00a8) break;\n        }\n      if (i < 32) c = i; else *errorcodeptr = ERR68;\n      }\n#endif  /* EBCDIC */\n\n    ptr++;\n    break;\n\n    /* Any other alphanumeric following \\ is an error. Perl gives an error only\n    if in warning mode, but PCRE doesn't have a warning mode. */\n\n    default:\n    *errorcodeptr = ERR3;\n    *ptrptr = ptr - 1;     /* Point to the character at fault */\n    return 0;\n    }\n  }\n\n/* Set the pointer to the next character before returning. */\n\n*ptrptr = ptr;\n*chptr = c;\nreturn escape;\n}\n\n\n\n#ifdef SUPPORT_UNICODE\n/*************************************************\n*               Handle \\P and \\p                 *\n*************************************************/\n\n/* This function is called after \\P or \\p has been encountered, provided that\nPCRE2 is compiled with support for UTF and Unicode properties. On entry, the\ncontents of ptrptr are pointing after the P or p. On exit, it is left pointing\nafter the final code unit of the escape sequence.\n\nArguments:\n  ptrptr         the pattern position pointer\n  negptr         a boolean that is set TRUE for negation else FALSE\n  ptypeptr       an unsigned int that is set to the type value\n  pdataptr       an unsigned int that is set to the detailed property value\n  errorcodeptr   the error code variable\n  cb             the compile data\n\nReturns:         TRUE if the type value was found, or FALSE for an invalid type\n*/\n\nstatic BOOL\nget_ucp(PCRE2_SPTR *ptrptr, BOOL *negptr, uint16_t *ptypeptr,\n  uint16_t *pdataptr, int *errorcodeptr, compile_block *cb)\n{\nPCRE2_UCHAR c;\nPCRE2_SIZE i, bot, top;\nPCRE2_SPTR ptr = *ptrptr;\nPCRE2_UCHAR name\u00dd32\u00a8;\n\nif (ptr >= cb->end_pattern) goto ERROR_RETURN;\nc = *ptr++;\n*negptr = FALSE;\n\n/* \\P or \\p can be followed by a name in {}, optionally preceded by \u00ac for\nnegation. */\n\nif (c == CHAR_LEFT_CURLY_BRACKET)\n  {\n  if (ptr >= cb->end_pattern) goto ERROR_RETURN;\n  if (*ptr == CHAR_CIRCUMFLEX_ACCENT)\n    {\n    *negptr = TRUE;\n    ptr++;\n    }\n  for (i = 0; i < (int)(sizeof(name) / sizeof(PCRE2_UCHAR)) - 1; i++)\n    {\n    if (ptr >= cb->end_pattern) goto ERROR_RETURN;\n    c = *ptr++;\n    if (c == CHAR_NUL) goto ERROR_RETURN;\n    if (c == CHAR_RIGHT_CURLY_BRACKET) break;\n    name\u00ddi\u00a8 = c;\n    }\n  if (c != CHAR_RIGHT_CURLY_BRACKET) goto ERROR_RETURN;\n  name\u00ddi\u00a8 = 0;\n  }\n\n/* Otherwise there is just one following character, which must be an ASCII\nletter. */\n\nelse if (MAX_255(c) && (cb->ctypes\u00ddc\u00a8 & ctype_letter) != 0)\n  {\n  name\u00dd0\u00a8 = c;\n  name\u00dd1\u00a8 = 0;\n  }\nelse goto ERROR_RETURN;\n\n*ptrptr = ptr;\n\n/* Search for a recognized property name using binary chop. */\n\nbot = 0;\ntop = PRIV(utt_size);\n\nwhile (bot < top)\n  {\n  int r;\n  i = (bot + top) >> 1;\n  r = PRIV(strcmp_c8)(name, PRIV(utt_names) + PRIV(utt)\u00ddi\u00a8.name_offset);\n  if (r == 0)\n    {\n    *ptypeptr = PRIV(utt)\u00ddi\u00a8.type;\n    *pdataptr = PRIV(utt)\u00ddi\u00a8.value;\n    return TRUE;\n    }\n  if (r > 0) bot = i + 1; else top = i;\n  }\n*errorcodeptr = ERR47;   /* Unrecognized name */\nreturn FALSE;\n\nERROR_RETURN:            /* Malformed \\P or \\p */\n*errorcodeptr = ERR46;\n*ptrptr = ptr;\nreturn FALSE;\n}\n#endif\n\n\n\n/*************************************************\n*           Check for POSIX class syntax         *\n*************************************************/\n\n/* This function is called when the sequence \"\u00dd:\" or \"\u00dd.\" or \"\u00dd=\" is\nencountered in a character class. It checks whether this is followed by a\nsequence of characters terminated by a matching \":\u00a8\" or \".\u00a8\" or \"=\u00a8\". If we\nreach an unescaped '\u00a8' without the special preceding character, return FALSE.\n\nOriginally, this function only recognized a sequence of letters between the\nterminators, but it seems that Perl recognizes any sequence of characters,\nthough of course unknown POSIX names are subsequently rejected. Perl gives an\n\"Unknown POSIX class\" error for \u00dd:f\\oo:\u00a8 for example, where previously PCRE\ndidn't consider this to be a POSIX class. Likewise for \u00dd:1234:\u00a8.\n\nThe problem in trying to be exactly like Perl is in the handling of escapes. We\nhave to be sure that \u00ddabc\u00dd:x\\\u00a8pqr\u00a8 is *not* treated as containing a POSIX\nclass, but \u00ddabc\u00dd:x\\\u00a8pqr:\u00a8\u00a8 is (so that an error can be generated). The code\nbelow handles the special cases \\\\ and \\\u00a8, but does not try to do any other\nescape processing. This makes it different from Perl for cases such as\n\u00dd:l\\ower:\u00a8 where Perl recognizes it as the POSIX class \"lower\" but PCRE does\nnot recognize \"l\\ower\". This is a lesser evil than not diagnosing bad classes\nwhen Perl does, I think.\n\nA user pointed out that PCRE was rejecting \u00dd:a\u00dd:digit:\u00a8\u00a8 whereas Perl was not.\nIt seems that the appearance of a nested POSIX class supersedes an apparent\nexternal class. For example, \u00dd:a\u00dd:digit:\u00a8b:\u00a8 matches \"a\", \"b\", \":\", or\na digit. This is handled by returning FALSE if the start of a new group with\nthe same terminator is encountered, since the next closing sequence must close\nthe nested group, not the outer one.\n\nIn Perl, unescaped square brackets may also appear as part of class names. For\nexample, \u00dd:a\u00dd:abc\u00a8b:\u00a8 gives unknown POSIX class \"\u00dd:abc\u00a8b:\u00a8\". However, for\n\u00dd:a\u00dd:abc\u00a8b\u00a8\u00ddb:\u00a8 it gives unknown POSIX class \"\u00dd:abc\u00a8b\u00a8\u00ddb:\u00a8\", which does not\nseem right at all. PCRE does not allow closing square brackets in POSIX class\nnames.\n\nArguments:\n  ptr      pointer to the character after the initial \u00dd (colon, dot, equals)\n  ptrend   pointer to the end of the pattern\n  endptr   where to return a pointer to the terminating ':', '.', or '='\n\nReturns:   TRUE or FALSE\n*/\n\nstatic BOOL\ncheck_posix_syntax(PCRE2_SPTR ptr, PCRE2_SPTR ptrend, PCRE2_SPTR *endptr)\n{\nPCRE2_UCHAR terminator;  /* Don't combine these lines; the Solaris cc */\nterminator = *ptr++;     /* compiler warns about \"non-constant\" initializer. */\n\nfor (; ptrend - ptr >= 2; ptr++)\n  {\n  if (*ptr == CHAR_BACKSLASH &&\n      (ptr\u00dd1\u00a8 == CHAR_RIGHT_SQUARE_BRACKET || ptr\u00dd1\u00a8 == CHAR_BACKSLASH))\n    ptr++;\n\n  else if ((*ptr == CHAR_LEFT_SQUARE_BRACKET && ptr\u00dd1\u00a8 == terminator) ||\n            *ptr == CHAR_RIGHT_SQUARE_BRACKET) return FALSE;\n\n  else if (*ptr == terminator && ptr\u00dd1\u00a8 == CHAR_RIGHT_SQUARE_BRACKET)\n    {\n    *endptr = ptr;\n    return TRUE;\n    }\n  }\n\nreturn FALSE;\n}\n\n\n\n/*************************************************\n*          Check POSIX class name                *\n*************************************************/\n\n/* This function is called to check the name given in a POSIX-style class entry\nsuch as \u00dd:alnum:\u00a8.\n\nArguments:\n  ptr        points to the first letter\n  len        the length of the name\n\nReturns:     a value representing the name, or -1 if unknown\n*/\n\nstatic int\ncheck_posix_name(PCRE2_SPTR ptr, int len)\n{\nconst char *pn = posix_names;\nint yield = 0;\nwhile (posix_name_lengths\u00ddyield\u00a8 != 0)\n  {\n  if (len == posix_name_lengths\u00ddyield\u00a8 &&\n    PRIV(strncmp_c8)(ptr, pn, (unsigned int)len) == 0) return yield;\n  pn += posix_name_lengths\u00ddyield\u00a8 + 1;\n  yield++;\n  }\nreturn -1;\n}\n\n\n\n/*************************************************\n*       Read a subpattern or VERB name           *\n*************************************************/\n\n/* This function is called from parse_regex() below whenever it needs to read\nthe name of a subpattern or a (*VERB) or an (*alpha_assertion). The initial\npointer must be to the character before the name. If that character is '*' we\nare reading a verb or alpha assertion name. The pointer is updated to point\nafter the name, for a VERB or alpha assertion name, or after tha name's\nterminator for a subpattern name. Returning both the offset and the name\npointer is redundant information, but some callers use one and some the other,\nso it is simplest just to return both.\n\nArguments:\n  ptrptr      points to the character pointer variable\n  ptrend      points to the end of the input string\n  utf         true if the input is UTF-encoded\n  terminator  the terminator of a subpattern name must be this\n  offsetptr   where to put the offset from the start of the pattern\n  nameptr     where to put a pointer to the name in the input\n  namelenptr  where to put the length of the name\n  errcodeptr  where to put an error code\n  cb          pointer to the compile data block\n\nReturns:    TRUE if a name was read\n            FALSE otherwise, with error code set\n*/\n\nstatic BOOL\nread_name(PCRE2_SPTR *ptrptr, PCRE2_SPTR ptrend, BOOL utf, uint32_t terminator,\n  PCRE2_SIZE *offsetptr, PCRE2_SPTR *nameptr, uint32_t *namelenptr,\n  int *errorcodeptr, compile_block *cb)\n{\nPCRE2_SPTR ptr = *ptrptr;\nBOOL is_group = (*ptr != CHAR_ASTERISK);\n\nif (++ptr >= ptrend)               /* No characters in name */\n  {\n  *errorcodeptr = is_group? ERR62: /* Subpattern name expected */\n                            ERR60; /* Verb not recognized or malformed */\n  goto FAILED;\n  }\n\n*nameptr = ptr;\n*offsetptr = (PCRE2_SIZE)(ptr - cb->start_pattern);\n\n/* In UTF mode, a group name may contain letters and decimal digits as defined\nby Unicode properties, and underscores, but must not start with a digit. */\n\n#ifdef SUPPORT_UNICODE\nif (utf && is_group)\n  {\n  uint32_t c, type;\n\n  GETCHAR(c, ptr);\n  type = UCD_CHARTYPE(c);\n\n  if (type == ucp_Nd)\n    {\n    *errorcodeptr = ERR44;\n    goto FAILED;\n    }\n\n  for(;;)\n    {\n    if (type != ucp_Nd && PRIV(ucp_gentype)\u00ddtype\u00a8 != ucp_L &&\n        c != CHAR_UNDERSCORE) break;\n    ptr++;\n    FORWARDCHARTEST(ptr, ptrend);\n    if (ptr >= ptrend) break;\n    GETCHAR(c, ptr);\n    type = UCD_CHARTYPE(c);\n    }\n  }\nelse\n#else\n(void)utf;  /* Avoid compiler warning */\n#endif      /* SUPPORT_UNICODE */\n\n/* Handle non-group names and group names in non-UTF modes. A group name must\nnot start with a digit. If either of the others start with a digit it just\nwon't be recognized. */\n\n  {\n  if (is_group && IS_DIGIT(*ptr))\n    {\n    *errorcodeptr = ERR44;\n    goto FAILED;\n    }\n\n  while (ptr < ptrend && MAX_255(*ptr) && (cb->ctypes\u00dd*ptr\u00a8 & ctype_word) != 0)\n    {\n    ptr++;\n    }\n  }\n\n/* Check name length */\n\nif (ptr > *nameptr + MAX_NAME_SIZE)\n  {\n  *errorcodeptr = ERR48;\n  goto FAILED;\n  }\n*namelenptr = ptr - *nameptr;\n\n/* Subpattern names must not be empty, and their terminator is checked here.\n(What follows a verb or alpha assertion name is checked separately.) */\n\nif (is_group)\n  {\n  if (ptr == *nameptr)\n    {\n    *errorcodeptr = ERR62;   /* Subpattern name expected */\n    goto FAILED;\n    }\n  if (ptr >= ptrend || *ptr != (PCRE2_UCHAR)terminator)\n    {\n    *errorcodeptr = ERR42;\n    goto FAILED;\n    }\n  ptr++;\n  }\n\n*ptrptr = ptr;\nreturn TRUE;\n\nFAILED:\n*ptrptr = ptr;\nreturn FALSE;\n}\n\n\n\n/*************************************************\n*          Manage callouts at start of cycle     *\n*************************************************/\n\n/* At the start of a new item in parse_regex() we are able to record the\ndetails of the previous item in a prior callout, and also to set up an\nautomatic callout if enabled. Avoid having two adjacent automatic callouts,\nwhich would otherwise happen for items such as \\Q that contribute nothing to\nthe parsed pattern.\n\nArguments:\n  ptr              current pattern pointer\n  pcalloutptr      points to a pointer to previous callout, or NULL\n  auto_callout     TRUE if auto_callouts are enabled\n  parsed_pattern   the parsed pattern pointer\n  cb               compile block\n\nReturns: possibly updated parsed_pattern pointer.\n*/\n\nstatic uint32_t *\nmanage_callouts(PCRE2_SPTR ptr, uint32_t **pcalloutptr, BOOL auto_callout,\n  uint32_t *parsed_pattern, compile_block *cb)\n{\nuint32_t *previous_callout = *pcalloutptr;\n\nif (previous_callout != NULL) previous_callout\u00dd2\u00a8 = (uint32_t)(ptr -\n  cb->start_pattern - (PCRE2_SIZE)previous_callout\u00dd1\u00a8);\n\nif (!auto_callout) previous_callout = NULL; else\n  {\n  if (previous_callout == NULL ||\n      previous_callout != parsed_pattern - 4 ||\n      previous_callout\u00dd3\u00a8 != 255)\n    {\n    previous_callout = parsed_pattern;  /* Set up new automatic callout */\n    parsed_pattern += 4;\n    previous_callout\u00dd0\u00a8 = META_CALLOUT_NUMBER;\n    previous_callout\u00dd2\u00a8 = 0;\n    previous_callout\u00dd3\u00a8 = 255;\n    }\n  previous_callout\u00dd1\u00a8 = (uint32_t)(ptr - cb->start_pattern);\n  }\n\n*pcalloutptr = previous_callout;\nreturn parsed_pattern;\n}\n\n\n\n/*************************************************\n*      Parse regex and identify named groups     *\n*************************************************/\n\n/* This function is called first of all. It scans the pattern and does two\nthings: (1) It identifies capturing groups and makes a table of named capturing\ngroups so that information about them is fully available to both the compiling\nscans. (2) It writes a parsed version of the pattern with comments omitted and\nescapes processed into the parsed_pattern vector.\n\nArguments:\n  ptr             points to the start of the pattern\n  options         compiling dynamic options (may change during the scan)\n  has_lookbehind  points to a boolean, set TRUE if a lookbehind is found\n  cb              pointer to the compile data block\n\nReturns:   zero on success or a non-zero error code, with the\n             error offset placed in the cb field\n*/\n\n/* A structure and some flags for dealing with nested groups. */\n\ntypedef struct nest_save {\n  uint16_t  nest_depth;\n  uint16_t  reset_group;\n  uint16_t  max_group;\n  uint16_t  flags;\n  uint32_t  options;\n} nest_save;\n\n#define NSF_RESET          0x0001u\n#define NSF_CONDASSERT     0x0002u\n#define NSF_ATOMICSR       0x0004u\n\n/* Options that are changeable within the pattern must be tracked during\nparsing. Some (e.g. PCRE2_EXTENDED) are implemented entirely during parsing,\nbut all must be tracked so that META_OPTIONS items set the correct values for\nthe main compiling phase. */\n\n#define PARSE_TRACKED_OPTIONS (PCRE2_CASELESS|PCRE2_DOTALL|PCRE2_DUPNAMES| \\\n  PCRE2_EXTENDED|PCRE2_EXTENDED_MORE|PCRE2_MULTILINE|PCRE2_NO_AUTO_CAPTURE| \\\n  PCRE2_UNGREEDY)\n\n/* States used for analyzing ranges in character classes. The two OK values\nmust be last. */\n\nenum { RANGE_NO, RANGE_STARTED, RANGE_OK_ESCAPED, RANGE_OK_LITERAL };\n\n/* Only in 32-bit mode can there be literals > META_END. A macro encapsulates\nthe storing of literal values in the main parsed pattern, where they can always\nbe quantified. */\n\n#if PCRE2_CODE_UNIT_WIDTH == 32\n#define PARSED_LITERAL(c, p) \\\n  { \\\n  if (c >= META_END) *p++ = META_BIGVALUE; \\\n  *p++ = c; \\\n  okquantifier = TRUE; \\\n  }\n#else\n#define PARSED_LITERAL(c, p) *p++ = c; okquantifier = TRUE;\n#endif\n\n/* Here's the actual function. */\n\nstatic int parse_regex(PCRE2_SPTR ptr, uint32_t options, BOOL *has_lookbehind,\n  compile_block *cb)\n{\nuint32_t c;\nuint32_t delimiter;\nuint32_t namelen;\nuint32_t class_range_state;\nuint32_t *verblengthptr = NULL;     /* Value avoids compiler warning */\nuint32_t *verbstartptr = NULL;\nuint32_t *previous_callout = NULL;\nuint32_t *parsed_pattern = cb->parsed_pattern;\nuint32_t *parsed_pattern_end = cb->parsed_pattern_end;\nuint32_t meta_quantifier = 0;\nuint32_t add_after_mark = 0;\nuint32_t extra_options = cb->cx->extra_options;\nuint16_t nest_depth = 0;\nint after_manual_callout = 0;\nint expect_cond_assert = 0;\nint errorcode = 0;\nint escape;\nint i;\nBOOL inescq = FALSE;\nBOOL inverbname = FALSE;\nBOOL utf = (options & PCRE2_UTF) != 0;\nBOOL auto_callout = (options & PCRE2_AUTO_CALLOUT) != 0;\nBOOL isdupname;\nBOOL negate_class;\nBOOL okquantifier = FALSE;\nPCRE2_SPTR thisptr;\nPCRE2_SPTR name;\nPCRE2_SPTR ptrend = cb->end_pattern;\nPCRE2_SPTR verbnamestart = NULL;    /* Value avoids compiler warning */\nnamed_group *ng;\nnest_save *top_nest, *end_nests;\n\n/* Insert leading items for word and line matching (features provided for the\nbenefit of pcre2grep). */\n\nif ((extra_options & PCRE2_EXTRA_MATCH_LINE) != 0)\n  {\n  *parsed_pattern++ = META_CIRCUMFLEX;\n  *parsed_pattern++ = META_NOCAPTURE;\n  }\nelse if ((extra_options & PCRE2_EXTRA_MATCH_WORD) != 0)\n  {\n  *parsed_pattern++ = META_ESCAPE + ESC_b;\n  *parsed_pattern++ = META_NOCAPTURE;\n  }\n\n/* If the pattern is actually a literal string, process it separately to avoid\ncluttering up the main loop. */\n\nif ((options & PCRE2_LITERAL) != 0)\n  {\n  while (ptr < ptrend)\n    {\n    if (parsed_pattern >= parsed_pattern_end)\n      {\n      errorcode = ERR63;  /* Internal error (parsed pattern overflow) */\n      goto FAILED;\n      }\n    thisptr = ptr;\n    GETCHARINCTEST(c, ptr);\n    if (auto_callout)\n      parsed_pattern = manage_callouts(thisptr, &previous_callout,\n        auto_callout, parsed_pattern, cb);\n    PARSED_LITERAL(c, parsed_pattern);\n    }\n  goto PARSED_END;\n  }\n\n/* Process a real regex which may contain meta-characters. */\n\ntop_nest = NULL;\nend_nests = (nest_save *)(cb->start_workspace + cb->workspace_size);\n\n/* The size of the nest_save structure might not be a factor of the size of the\nworkspace. Therefore we must round down end_nests so as to correctly avoid\ncreating a nest_save that spans the end of the workspace. */\n\nend_nests = (nest_save *)((char *)end_nests -\n  ((cb->workspace_size * sizeof(PCRE2_UCHAR)) % sizeof(nest_save)));\n\n/* PCRE2_EXTENDED_MORE implies PCRE2_EXTENDED */\n\nif ((options & PCRE2_EXTENDED_MORE) != 0) options |= PCRE2_EXTENDED;\n\n/* Now scan the pattern */\n\nwhile (ptr < ptrend)\n  {\n  int prev_expect_cond_assert;\n  uint32_t min_repeat, max_repeat;\n  uint32_t set, unset, *optset;\n  uint32_t terminator;\n  uint32_t prev_meta_quantifier;\n  BOOL prev_okquantifier;\n  PCRE2_SPTR tempptr;\n  PCRE2_SIZE offset;\n\n  if (parsed_pattern >= parsed_pattern_end)\n    {\n    errorcode = ERR63;  /* Internal error (parsed pattern overflow) */\n    goto FAILED;\n    }\n\n  if (nest_depth > cb->cx->parens_nest_limit)\n    {\n    errorcode = ERR19;\n    goto FAILED;        /* Parentheses too deeply nested */\n    }\n\n  /* Get next input character, save its position for callout handling. */\n\n  thisptr = ptr;\n  GETCHARINCTEST(c, ptr);\n\n  /* Copy quoted literals until \\E, allowing for the possibility of automatic\n  callouts, except when processing a (*VERB) \"name\".  */\n\n  if (inescq)\n    {\n    if (c == CHAR_BACKSLASH && ptr < ptrend && *ptr == CHAR_E)\n      {\n      inescq = FALSE;\n      ptr++;   /* Skip E */\n      }\n    else\n      {\n      if (expect_cond_assert > 0)   /* A literal is not allowed if we are */\n        {                           /* expecting a conditional assertion, */\n        ptr--;                      /* but an empty \\Q\\E sequence is OK.  */\n        errorcode = ERR28;\n        goto FAILED;\n        }\n      if (inverbname)\n        {                          /* Don't use PARSED_LITERAL() because it */\n#if PCRE2_CODE_UNIT_WIDTH == 32    /* sets okquantifier. */\n        if (c >= META_END) *parsed_pattern++ = META_BIGVALUE;\n#endif\n        *parsed_pattern++ = c;\n        }\n      else\n        {\n        if (after_manual_callout-- <= 0)\n          parsed_pattern = manage_callouts(thisptr, &previous_callout,\n            auto_callout, parsed_pattern, cb);\n        PARSED_LITERAL(c, parsed_pattern);\n        }\n      meta_quantifier = 0;\n      }\n    continue;  /* Next character */\n    }\n\n  /* If we are processing the \"name\" part of a (*VERB:NAME) item, all\n  characters up to the closing parenthesis are literals except when\n  PCRE2_ALT_VERBNAMES is set. That causes backslash interpretation, but only \\Q\n  and \\E and escaped characters are allowed (no character types such as \\d). If\n  PCRE2_EXTENDED is also set, we must ignore white space and # comments. Do\n  this by not entering the special (*VERB:NAME) processing - they are then\n  picked up below. Note that c is a character, not a code unit, so we must not\n  use MAX_255 to test its size because MAX_255 tests code units and is assumed\n  TRUE in 8-bit mode. */\n\n  if (inverbname &&\n       (\n        /* EITHER: not both options set */\n        ((options & (PCRE2_EXTENDED | PCRE2_ALT_VERBNAMES)) !=\n                    (PCRE2_EXTENDED | PCRE2_ALT_VERBNAMES)) ||\n#ifdef SUPPORT_UNICODE\n        /* OR: character > 255 AND not Unicode Pattern White Space */\n        (c > 255 && (c|1) != 0x200f && (c|1) != 0x2029) ||\n#endif\n        /* OR: not a # comment or isspace() white space */\n        (c < 256 && c != CHAR_NUMBER_SIGN && (cb->ctypes\u00ddc\u00a8 & ctype_space) == 0\n#ifdef SUPPORT_UNICODE\n        /* and not CHAR_NEL when Unicode is supported */\n          && c != CHAR_NEL\n#endif\n       )))\n    {\n    PCRE2_SIZE verbnamelength;\n\n    switch(c)\n      {\n      default:                     /* Don't use PARSED_LITERAL() because it */\n#if PCRE2_CODE_UNIT_WIDTH == 32    /* sets okquantifier. */\n      if (c >= META_END) *parsed_pattern++ = META_BIGVALUE;\n#endif\n      *parsed_pattern++ = c;\n      break;\n\n      case CHAR_RIGHT_PARENTHESIS:\n      inverbname = FALSE;\n      /* This is the length in characters */\n      verbnamelength = (PCRE2_SIZE)(parsed_pattern - verblengthptr - 1);\n      /* But the limit on the length is in code units */\n      if (ptr - verbnamestart - 1 > (int)MAX_MARK)\n        {\n        ptr--;\n        errorcode = ERR76;\n        goto FAILED;\n        }\n      *verblengthptr = (uint32_t)verbnamelength;\n\n      /* If this name was on a verb such as (*ACCEPT) which does not continue,\n      a (*MARK) was generated for the name. We now add the original verb as the\n      next item. */\n\n      if (add_after_mark != 0)\n        {\n        *parsed_pattern++ = add_after_mark;\n        add_after_mark = 0;\n        }\n      break;\n\n      case CHAR_BACKSLASH:\n      if ((options & PCRE2_ALT_VERBNAMES) != 0)\n        {\n        escape = PRIV(check_escape)(&ptr, ptrend, &c, &errorcode, options,\n          cb->cx->extra_options, FALSE, cb);\n        if (errorcode != 0) goto FAILED;\n        }\n      else escape = 0;   /* Treat all as literal */\n\n      switch(escape)\n        {\n        case 0:                    /* Don't use PARSED_LITERAL() because it */\n#if PCRE2_CODE_UNIT_WIDTH == 32    /* sets okquantifier. */\n        if (c >= META_END) *parsed_pattern++ = META_BIGVALUE;\n#endif\n        *parsed_pattern++ = c;\n        break;\n\n        case ESC_Q:\n        inescq = TRUE;\n        break;\n\n        case ESC_E:           /* Ignore */\n        break;\n\n        default:\n        errorcode = ERR40;    /* Invalid in verb name */\n        goto FAILED;\n        }\n      }\n    continue;   /* Next character in pattern */\n    }\n\n  /* Not a verb name character. At this point we must process everything that\n  must not change the quantification state. This is mainly comments, but we\n  handle \\Q and \\E here as well, so that an item such as A\\Q\\E+ is treated as\n  A+, as in Perl. An isolated \\E is ignored. */\n\n  if (c == CHAR_BACKSLASH && ptr < ptrend)\n    {\n    if (*ptr == CHAR_Q || *ptr == CHAR_E)\n      {\n      inescq = *ptr == CHAR_Q;\n      ptr++;\n      continue;\n      }\n    }\n\n  /* Skip over whitespace and # comments in extended mode. Note that c is a\n  character, not a code unit, so we must not use MAX_255 to test its size\n  because MAX_255 tests code units and is assumed TRUE in 8-bit mode. The\n  whitespace characters are those designated as \"Pattern White Space\" by\n  Unicode, which are the isspace() characters plus CHAR_NEL (newline), which is\n  U+0085 in Unicode, plus U+200E, U+200F, U+2028, and U+2029. These are a\n  subset of space characters that match \\h and \\v. */\n\n  if ((options & PCRE2_EXTENDED) != 0)\n    {\n    if (c < 256 && (cb->ctypes\u00ddc\u00a8 & ctype_space) != 0) continue;\n#ifdef SUPPORT_UNICODE\n    if (c == CHAR_NEL || (c|1) == 0x200f || (c|1) == 0x2029) continue;\n#endif\n    if (c == CHAR_NUMBER_SIGN)\n      {\n      while (ptr < ptrend)\n        {\n        if (IS_NEWLINE(ptr))      /* For non-fixed-length newline cases, */\n          {                       /* IS_NEWLINE sets cb->nllen. */\n          ptr += cb->nllen;\n          break;\n          }\n        ptr++;\n#ifdef SUPPORT_UNICODE\n        if (utf) FORWARDCHARTEST(ptr, ptrend);\n#endif\n        }\n      continue;  /* Next character in pattern */\n      }\n    }\n\n  /* Skip over bracketed comments */\n\n  if (c == CHAR_LEFT_PARENTHESIS && ptrend - ptr >= 2 &&\n      ptr\u00dd0\u00a8 == CHAR_QUESTION_MARK && ptr\u00dd1\u00a8 == CHAR_NUMBER_SIGN)\n    {\n    while (++ptr < ptrend && *ptr != CHAR_RIGHT_PARENTHESIS);\n    if (ptr >= ptrend)\n      {\n      errorcode = ERR18;  /* A special error for missing ) in a comment */\n      goto FAILED;        /* to make it easier to debug. */\n      }\n    ptr++;\n    continue;  /* Next character in pattern */\n    }\n\n  /* If the next item is not a quantifier, fill in length of any previous\n  callout and create an auto callout if required. */\n\n  if (c != CHAR_ASTERISK && c != CHAR_PLUS && c != CHAR_QUESTION_MARK &&\n       (c != CHAR_LEFT_CURLY_BRACKET ||\n         (tempptr = ptr,\n         !read_repeat_counts(&tempptr, ptrend, NULL, NULL, &errorcode))))\n    {\n    if (after_manual_callout-- <= 0)\n      parsed_pattern = manage_callouts(thisptr, &previous_callout, auto_callout,\n        parsed_pattern, cb);\n    }\n\n  /* If expect_cond_assert is 2, we have just passed (?( and are expecting an\n  assertion, possibly preceded by a callout. If the value is 1, we have just\n  had the callout and expect an assertion. There must be at least 3 more\n  characters in all cases. When expect_cond_assert is 2, we know that the\n  current character is an opening parenthesis, as otherwise we wouldn't be\n  here. However, when it is 1, we need to check, and it's easiest just to check\n  always. Note that expect_cond_assert may be negative, since all callouts just\n  decrement it. */\n\n  if (expect_cond_assert > 0)\n    {\n    BOOL ok = c == CHAR_LEFT_PARENTHESIS && ptrend - ptr >= 3 &&\n              (ptr\u00dd0\u00a8 == CHAR_QUESTION_MARK || ptr\u00dd0\u00a8 == CHAR_ASTERISK);\n    if (ok)\n      {\n      if (ptr\u00dd0\u00a8 == CHAR_ASTERISK)  /* New alpha assertion format, possibly */\n        {\n        ok = MAX_255(ptr\u00dd1\u00a8) && (cb->ctypes\u00ddptr\u00dd1\u00a8\u00a8 & ctype_lcletter) != 0;\n        }\n      else switch(ptr\u00dd1\u00a8)  /* Traditional symbolic format */\n        {\n        case CHAR_C:\n        ok = expect_cond_assert == 2;\n        break;\n\n        case CHAR_EQUALS_SIGN:\n        case CHAR_EXCLAMATION_MARK:\n        break;\n\n        case CHAR_LESS_THAN_SIGN:\n        ok = ptr\u00dd2\u00a8 == CHAR_EQUALS_SIGN || ptr\u00dd2\u00a8 == CHAR_EXCLAMATION_MARK;\n        break;\n\n        default:\n        ok = FALSE;\n        }\n      }\n\n    if (!ok)\n      {\n      ptr--;   /* Adjust error offset */\n      errorcode = ERR28;\n      goto FAILED;\n      }\n    }\n\n  /* Remember whether we are expecting a conditional assertion, and set the\n  default for this item. */\n\n  prev_expect_cond_assert = expect_cond_assert;\n  expect_cond_assert = 0;\n\n  /* Remember quantification status for the previous significant item, then set\n  default for this item. */\n\n  prev_okquantifier = okquantifier;\n  prev_meta_quantifier = meta_quantifier;\n  okquantifier = FALSE;\n  meta_quantifier = 0;\n\n  /* If the previous significant item was a quantifier, adjust the parsed code\n  if there is a following modifier. The base meta value is always followed by\n  the PLUS and QUERY values, in that order. We do this here rather than after\n  reading a quantifier so that intervening comments and /x whitespace can be\n  ignored without having to replicate code. */\n\n  if (prev_meta_quantifier != 0 && (c == CHAR_QUESTION_MARK || c == CHAR_PLUS))\n    {\n    parsed_pattern\u00dd(prev_meta_quantifier == META_MINMAX)? -3 : -1\u00a8 =\n      prev_meta_quantifier + ((c == CHAR_QUESTION_MARK)?\n        0x00020000u : 0x00010000u);\n    continue;  /* Next character in pattern */\n    }\n\n\n  /* Process the next item in the main part of a pattern. */\n\n  switch(c)\n    {\n    default:              /* Non-special character */\n    PARSED_LITERAL(c, parsed_pattern);\n    break;\n\n\n    /* ---- Escape sequence ---- */\n\n    case CHAR_BACKSLASH:\n    tempptr = ptr;\n    escape = PRIV(check_escape)(&ptr, ptrend, &c, &errorcode, options,\n      cb->cx->extra_options, FALSE, cb);\n    if (errorcode != 0)\n      {\n      ESCAPE_FAILED:\n      if ((extra_options & PCRE2_EXTRA_BAD_ESCAPE_IS_LITERAL) == 0)\n        goto FAILED;\n      ptr = tempptr;\n      if (ptr >= ptrend) c = CHAR_BACKSLASH; else\n        {\n        GETCHARINCTEST(c, ptr);   /* Get character value, increment pointer */\n        }\n      escape = 0;                 /* Treat as literal character */\n      }\n\n    /* The escape was a data escape or literal character. */\n\n    if (escape == 0)\n      {\n      PARSED_LITERAL(c, parsed_pattern);\n      }\n\n    /* The escape was a back (or forward) reference. We keep the offset in\n    order to give a more useful diagnostic for a bad forward reference. For\n    references to groups numbered less than 10 we can't use more than two items\n    in parsed_pattern because they may be just two characters in the input (and\n    in a 64-bit world an offset may need two elements). So for them, the offset\n    of the first occurrent is held in a special vector. */\n\n    else if (escape < 0)\n      {\n      offset = (PCRE2_SIZE)(ptr - cb->start_pattern - 1);\n      escape = -escape;\n      *parsed_pattern++ = META_BACKREF | (uint32_t)escape;\n      if (escape < 10)\n        {\n        if (cb->small_ref_offset\u00ddescape\u00a8 == PCRE2_UNSET)\n          cb->small_ref_offset\u00ddescape\u00a8 = offset;\n        }\n      else\n        {\n        PUTOFFSET(offset, parsed_pattern);\n        }\n      okquantifier = TRUE;\n      }\n\n    /* The escape was a character class such as \\d etc. or other special\n    escape indicator such as \\A or \\X. Most of them generate just a single\n    parsed item, but \\P and \\p are followed by a 16-bit type and a 16-bit\n    value. They are supported only when Unicode is available. The type and\n    value are packed into a single 32-bit value so that the whole sequences\n    uses only two elements in the parsed_vector. This is because the same\n    coding is used if \\d (for example) is turned into \\p{Nd} when PCRE2_UCP is\n    set.\n\n    There are also some cases where the escape sequence is followed by a name:\n    \\k{name}, \\k<name>, and \\k'name' are backreferences by name, and \\g<name>\n    and \\g'name' are subroutine calls by name; \\g{name} is a synonym for\n    \\k{name}. Note that \\g<number> and \\g'number' are handled by check_escape()\n    and returned as a negative value (handled above). A name is coded as an\n    offset into the pattern and a length. */\n\n    else switch (escape)\n      {\n      case ESC_C:\n#ifdef NEVER_BACKSLASH_C\n      errorcode = ERR85;\n      goto ESCAPE_FAILED;\n#else\n      if ((options & PCRE2_NEVER_BACKSLASH_C) != 0)\n        {\n        errorcode = ERR83;\n        goto ESCAPE_FAILED;\n        }\n#endif\n      okquantifier = TRUE;\n      *parsed_pattern++ = META_ESCAPE + escape;\n      break;\n\n      case ESC_X:\n#ifndef SUPPORT_UNICODE\n      errorcode = ERR45;   /* Supported only with Unicode support */\n      goto ESCAPE_FAILED;\n#endif\n      case ESC_H:\n      case ESC_h:\n      case ESC_N:\n      case ESC_R:\n      case ESC_V:\n      case ESC_v:\n      okquantifier = TRUE;\n      *parsed_pattern++ = META_ESCAPE + escape;\n      break;\n\n      default:  /* \\A, \\B, \\b, \\G, \\K, \\Z, \\z cannot be quantified. */\n      *parsed_pattern++ = META_ESCAPE + escape;\n      break;\n\n      /* Escapes that change in UCP mode. Note that PCRE2_UCP will never be set\n      without Unicode support because it is checked when pcre2_compile() is\n      called. */\n\n      case ESC_d:\n      case ESC_D:\n      case ESC_s:\n      case ESC_S:\n      case ESC_w:\n      case ESC_W:\n      okquantifier = TRUE;\n      if ((options & PCRE2_UCP) == 0)\n        {\n        *parsed_pattern++ = META_ESCAPE + escape;\n        }\n      else\n        {\n        *parsed_pattern++ = META_ESCAPE +\n          ((escape == ESC_d || escape == ESC_s || escape == ESC_w)?\n            ESC_p : ESC_P);\n        switch(escape)\n          {\n          case ESC_d:\n          case ESC_D:\n          *parsed_pattern++ = (PT_PC << 16) | ucp_Nd;\n          break;\n\n          case ESC_s:\n          case ESC_S:\n          *parsed_pattern++ = PT_SPACE << 16;\n          break;\n\n          case ESC_w:\n          case ESC_W:\n          *parsed_pattern++ = PT_WORD << 16;\n          break;\n          }\n        }\n      break;\n\n      /* Unicode property matching */\n\n      case ESC_P:\n      case ESC_p:\n#ifdef SUPPORT_UNICODE\n        {\n        BOOL negated;\n        uint16_t ptype = 0, pdata = 0;\n        if (!get_ucp(&ptr, &negated, &ptype, &pdata, &errorcode, cb))\n          goto ESCAPE_FAILED;\n        if (negated) escape = (escape == ESC_P)? ESC_p : ESC_P;\n        *parsed_pattern++ = META_ESCAPE + escape;\n        *parsed_pattern++ = (ptype << 16) | pdata;\n        okquantifier = TRUE;\n        }\n#else\n      errorcode = ERR45;\n      goto ESCAPE_FAILED;\n#endif\n      break;  /* End \\P and \\p */\n\n      /* When \\g is used with quotes or angle brackets as delimiters, it is a\n      numerical or named subroutine call, and control comes here. When used\n      with brace delimiters it is a numberical back reference and does not come\n      here because check_escape() returns it directly as a reference. \\k is\n      always a named back reference. */\n\n      case ESC_g:\n      case ESC_k:\n      if (ptr >= ptrend || (*ptr != CHAR_LEFT_CURLY_BRACKET &&\n          *ptr != CHAR_LESS_THAN_SIGN && *ptr != CHAR_APOSTROPHE))\n        {\n        errorcode = (escape == ESC_g)? ERR57 : ERR69;\n        goto ESCAPE_FAILED;\n        }\n      terminator = (*ptr == CHAR_LESS_THAN_SIGN)?\n        CHAR_GREATER_THAN_SIGN : (*ptr == CHAR_APOSTROPHE)?\n        CHAR_APOSTROPHE : CHAR_RIGHT_CURLY_BRACKET;\n\n      /* For a non-braced \\g, check for a numerical recursion. */\n\n      if (escape == ESC_g && terminator != CHAR_RIGHT_CURLY_BRACKET)\n        {\n        PCRE2_SPTR p = ptr + 1;\n\n        if (read_number(&p, ptrend, cb->bracount, MAX_GROUP_NUMBER, ERR61, &i,\n            &errorcode))\n          {\n          if (p >= ptrend || *p != terminator)\n            {\n            errorcode = ERR57;\n            goto ESCAPE_FAILED;\n            }\n          ptr = p;\n          goto SET_RECURSION;\n          }\n        if (errorcode != 0) goto ESCAPE_FAILED;\n        }\n\n      /* Not a numerical recursion */\n\n      if (!read_name(&ptr, ptrend, utf, terminator, &offset, &name, &namelen,\n          &errorcode, cb)) goto ESCAPE_FAILED;\n\n      /* \\k and \\g when used with braces are back references, whereas \\g used\n      with quotes or angle brackets is a recursion */\n\n      *parsed_pattern++ =\n        (escape == ESC_k || terminator == CHAR_RIGHT_CURLY_BRACKET)?\n          META_BACKREF_BYNAME : META_RECURSE_BYNAME;\n      *parsed_pattern++ = namelen;\n\n      PUTOFFSET(offset, parsed_pattern);\n      okquantifier = TRUE;\n      break;  /* End special escape processing */\n      }\n    break;    /* End escape sequence processing */\n\n\n    /* ---- Single-character special items ---- */\n\n    case CHAR_CIRCUMFLEX_ACCENT:\n    *parsed_pattern++ = META_CIRCUMFLEX;\n    break;\n\n    case CHAR_DOLLAR_SIGN:\n    *parsed_pattern++ = META_DOLLAR;\n    break;\n\n    case CHAR_DOT:\n    *parsed_pattern++ = META_DOT;\n    okquantifier = TRUE;\n    break;\n\n\n    /* ---- Single-character quantifiers ---- */\n\n    case CHAR_ASTERISK:\n    meta_quantifier = META_ASTERISK;\n    goto CHECK_QUANTIFIER;\n\n    case CHAR_PLUS:\n    meta_quantifier = META_PLUS;\n    goto CHECK_QUANTIFIER;\n\n    case CHAR_QUESTION_MARK:\n    meta_quantifier = META_QUERY;\n    goto CHECK_QUANTIFIER;\n\n\n    /* ---- Potential {n,m} quantifier ---- */\n\n    case CHAR_LEFT_CURLY_BRACKET:\n    if (!read_repeat_counts(&ptr, ptrend, &min_repeat, &max_repeat,\n        &errorcode))\n      {\n      if (errorcode != 0) goto FAILED;     /* Error in quantifier. */\n      PARSED_LITERAL(c, parsed_pattern);   /* Not a quantifier */\n      break;                               /* No more quantifier processing */\n      }\n    meta_quantifier = META_MINMAX;\n    /* Fall through */\n\n\n    /* ---- Quantifier post-processing ---- */\n\n    /* Check that a quantifier is allowed after the previous item. */\n\n    CHECK_QUANTIFIER:\n    if (!prev_okquantifier)\n      {\n      errorcode = ERR9;\n      goto FAILED_BACK;\n      }\n\n    /* Most (*VERB)s are not allowed to be quantified, but an ungreedy\n    quantifier can be useful for (*ACCEPT) - meaning \"succeed on backtrack\", a\n    sort of negated (*COMMIT). We therefore allow (*ACCEPT) to be quantified by\n    wrapping it in non-capturing brackets, but we have to allow for a preceding\n    (*MARK) for when (*ACCEPT) has an argument. */\n\n    if (parsed_pattern\u00dd-1\u00a8 == META_ACCEPT)\n      {\n      uint32_t *p;\n      for (p = parsed_pattern - 1; p >= verbstartptr; p--) p\u00dd1\u00a8 = p\u00dd0\u00a8;\n      *verbstartptr = META_NOCAPTURE;\n      parsed_pattern\u00dd1\u00a8 = META_KET;\n      parsed_pattern += 2;\n      }\n\n    /* Now we can put the quantifier into the parsed pattern vector. At this\n    stage, we have only the basic quantifier. The check for a following + or ?\n    modifier happens at the top of the loop, after any intervening comments\n    have been removed. */\n\n    *parsed_pattern++ = meta_quantifier;\n    if (c == CHAR_LEFT_CURLY_BRACKET)\n      {\n      *parsed_pattern++ = min_repeat;\n      *parsed_pattern++ = max_repeat;\n      }\n    break;\n\n\n    /* ---- Character class ---- */\n\n    case CHAR_LEFT_SQUARE_BRACKET:\n    okquantifier = TRUE;\n\n    /* In another (POSIX) regex library, the ugly syntax \u00dd\u00dd:<:\u00a8\u00a8 and \u00dd\u00dd:>:\u00a8\u00a8 is\n    used for \"start of word\" and \"end of word\". As these are otherwise illegal\n    sequences, we don't break anything by recognizing them. They are replaced\n    by \\b(?=\\w) and \\b(?<=\\w) respectively. Sequences like \u00dda\u00dd:<:\u00a8\u00a8 are\n    erroneous and are handled by the normal code below. */\n\n    if (ptrend - ptr >= 6 &&\n         (PRIV(strncmp_c8)(ptr, STRING_WEIRD_STARTWORD, 6) == 0 ||\n          PRIV(strncmp_c8)(ptr, STRING_WEIRD_ENDWORD, 6) == 0))\n      {\n      *parsed_pattern++ = META_ESCAPE + ESC_b;\n\n      if (ptr\u00dd2\u00a8 == CHAR_LESS_THAN_SIGN)\n        {\n        *parsed_pattern++ = META_LOOKAHEAD;\n        }\n      else\n        {\n        *parsed_pattern++ = META_LOOKBEHIND;\n        *has_lookbehind = TRUE;\n\n        /* The offset is used only for the \"non-fixed length\" error; this won't\n        occur here, so just store zero. */\n\n        PUTOFFSET((PCRE2_SIZE)0, parsed_pattern);\n        }\n\n      if ((options & PCRE2_UCP) == 0)\n        *parsed_pattern++ = META_ESCAPE + ESC_w;\n      else\n        {\n        *parsed_pattern++ = META_ESCAPE + ESC_p;\n        *parsed_pattern++ = PT_WORD << 16;\n        }\n      *parsed_pattern++ = META_KET;\n      ptr += 6;\n      break;\n      }\n\n    /* PCRE supports POSIX class stuff inside a class. Perl gives an error if\n    they are encountered at the top level, so we'll do that too. */\n\n    if (ptr < ptrend && (*ptr == CHAR_COLON || *ptr == CHAR_DOT ||\n         *ptr == CHAR_EQUALS_SIGN) &&\n        check_posix_syntax(ptr, ptrend, &tempptr))\n      {\n      errorcode = (*ptr-- == CHAR_COLON)? ERR12 : ERR13;\n      goto FAILED;\n      }\n\n    /* Process a regular character class. If the first character is '\u00ac', set\n    the negation flag. If the first few characters (either before or after \u00ac)\n    are \\Q\\E or \\E or space or tab in extended-more mode, we skip them too.\n    This makes for compatibility with Perl. */\n\n    negate_class = FALSE;\n    while (ptr < ptrend)\n      {\n      GETCHARINCTEST(c, ptr);\n      if (c == CHAR_BACKSLASH)\n        {\n        if (ptr < ptrend && *ptr == CHAR_E) ptr++;\n        else if (ptrend - ptr >= 3 &&\n             PRIV(strncmp_c8)(ptr, STR_Q STR_BACKSLASH STR_E, 3) == 0)\n          ptr += 3;\n        else\n          break;\n        }\n      else if ((options & PCRE2_EXTENDED_MORE) != 0 &&\n               (c == CHAR_SPACE || c == CHAR_HT))  /* Note: just these two */\n        continue;\n      else if (!negate_class && c == CHAR_CIRCUMFLEX_ACCENT)\n        negate_class = TRUE;\n      else break;\n      }\n\n    /* Now the real contents of the class; c has the first \"real\" character.\n    Empty classes are permitted only if the option is set. */\n\n    if (c == CHAR_RIGHT_SQUARE_BRACKET &&\n        (cb->external_options & PCRE2_ALLOW_EMPTY_CLASS) != 0)\n      {\n      *parsed_pattern++ = negate_class? META_CLASS_EMPTY_NOT : META_CLASS_EMPTY;\n      break;  /* End of class processing */\n      }\n\n    /* Process a non-empty class. */\n\n    *parsed_pattern++ = negate_class? META_CLASS_NOT : META_CLASS;\n    class_range_state = RANGE_NO;\n\n    /* In an EBCDIC environment, Perl treats alphabetic ranges specially\n    because there are holes in the encoding, and simply using the range A-Z\n    (for example) would include the characters in the holes. This applies only\n    to ranges where both values are literal; \u00dd\\xC1-\\xE9\u00a8 is different to \u00ddA-Z\u00a8\n    in this respect. In order to accommodate this, we keep track of whether\n    character values are literal or not, and a state variable for handling\n    ranges. */\n\n    /* Loop for the contents of the class */\n\n    for (;;)\n      {\n      BOOL char_is_literal = TRUE;\n\n      /* Inside \\Q...\\E everything is literal except \\E */\n\n      if (inescq)\n        {\n        if (c == CHAR_BACKSLASH && ptr < ptrend && *ptr == CHAR_E)\n          {\n          inescq = FALSE;                   /* Reset literal state */\n          ptr++;                            /* Skip the 'E' */\n          goto CLASS_CONTINUE;\n          }\n        goto CLASS_LITERAL;\n        }\n\n      /* Skip over space and tab (only) in extended-more mode. */\n\n      if ((options & PCRE2_EXTENDED_MORE) != 0 &&\n          (c == CHAR_SPACE || c == CHAR_HT))\n        goto CLASS_CONTINUE;\n\n      /* Handle POSIX class names. Perl allows a negation extension of the\n      form \u00dd:\u00acname:\u00a8. A square bracket that doesn't match the syntax is\n      treated as a literal. We also recognize the POSIX constructions\n      \u00dd.ch.\u00a8 and \u00dd=ch=\u00a8 (\"collating elements\") and fault them, as Perl\n      5.6 and 5.8 do. */\n\n      if (c == CHAR_LEFT_SQUARE_BRACKET &&\n          ptrend - ptr >= 3 &&\n          (*ptr == CHAR_COLON || *ptr == CHAR_DOT ||\n           *ptr == CHAR_EQUALS_SIGN) &&\n          check_posix_syntax(ptr, ptrend, &tempptr))\n        {\n        BOOL posix_negate = FALSE;\n        int posix_class;\n\n        /* Perl treats a hyphen before a POSIX class as a literal, not the\n        start of a range. However, it gives a warning in its warning mode. PCRE\n        does not have a warning mode, so we give an error, because this is\n        likely an error on the user's part. */\n\n        if (class_range_state == RANGE_STARTED)\n          {\n          errorcode = ERR50;\n          goto FAILED;\n          }\n\n        if (*ptr != CHAR_COLON)\n          {\n          errorcode = ERR13;\n          goto FAILED_BACK;\n          }\n\n        if (*(++ptr) == CHAR_CIRCUMFLEX_ACCENT)\n          {\n          posix_negate = TRUE;\n          ptr++;\n          }\n\n        posix_class = check_posix_name(ptr, (int)(tempptr - ptr));\n        if (posix_class < 0)\n          {\n          errorcode = ERR30;\n          goto FAILED;\n          }\n        ptr = tempptr + 2;\n\n        /* Perl treats a hyphen after a POSIX class as a literal, not the\n        start of a range. However, it gives a warning in its warning mode\n        unless the hyphen is the last character in the class. PCRE does not\n        have a warning mode, so we give an error, because this is likely an\n        error on the user's part. */\n\n        if (ptr < ptrend - 1 && *ptr == CHAR_MINUS &&\n            ptr\u00dd1\u00a8 != CHAR_RIGHT_SQUARE_BRACKET)\n          {\n          errorcode = ERR50;\n          goto FAILED;\n          }\n\n        /* Set \"a hyphen is not the start of a range\" for the -\u00a8 case, and also\n        in case the POSIX class is followed by \\E or \\Q\\E (possibly repeated -\n        fuzzers do that kind of thing) and *then* a hyphen. This causes that\n        hyphen to be treated as a literal. I don't think it's worth setting up\n        special apparatus to do otherwise. */\n\n        class_range_state = RANGE_NO;\n\n        /* When PCRE2_UCP is set, some of the POSIX classes are converted to\n        use Unicode properties \\p or \\P or, in one case, \\h or \\H. The\n        substitutes table has two values per class, containing the type and\n        value of a \\p or \\P item. The special cases are specified with a\n        negative type: a non-zero value causes \\h or \\H to be used, and a zero\n        value falls through to behave like a non-UCP POSIX class. */\n\n#ifdef SUPPORT_UNICODE\n        if ((options & PCRE2_UCP) != 0)\n          {\n          int ptype = posix_substitutes\u00dd2*posix_class\u00a8;\n          int pvalue = posix_substitutes\u00dd2*posix_class + 1\u00a8;\n          if (ptype >= 0)\n            {\n            *parsed_pattern++ = META_ESCAPE + (posix_negate? ESC_P : ESC_p);\n            *parsed_pattern++ = (ptype << 16) | pvalue;\n            goto CLASS_CONTINUE;\n            }\n\n          if (pvalue != 0)\n            {\n            *parsed_pattern++ = META_ESCAPE + (posix_negate? ESC_H : ESC_h);\n            goto CLASS_CONTINUE;\n            }\n\n          /* Fall through */\n          }\n#endif  /* SUPPORT_UNICODE */\n\n        /* Non-UCP POSIX class */\n\n        *parsed_pattern++ = posix_negate? META_POSIX_NEG : META_POSIX;\n        *parsed_pattern++ = posix_class;\n        }\n\n      /* Handle potential start of range */\n\n      else if (c == CHAR_MINUS && class_range_state >= RANGE_OK_ESCAPED)\n        {\n        *parsed_pattern++ = (class_range_state == RANGE_OK_LITERAL)?\n          META_RANGE_LITERAL : META_RANGE_ESCAPED;\n        class_range_state = RANGE_STARTED;\n        }\n\n      /* Handle a literal character */\n\n      else if (c != CHAR_BACKSLASH)\n        {\n        CLASS_LITERAL:\n        if (class_range_state == RANGE_STARTED)\n          {\n          if (c == parsed_pattern\u00dd-2\u00a8)       /* Optimize one-char range */\n            parsed_pattern--;\n          else if (parsed_pattern\u00dd-2\u00a8 > c)   /* Check range is in order */\n            {\n            errorcode = ERR8;\n            goto FAILED_BACK;\n            }\n          else\n            {\n            if (!char_is_literal && parsed_pattern\u00dd-1\u00a8 == META_RANGE_LITERAL)\n              parsed_pattern\u00dd-1\u00a8 = META_RANGE_ESCAPED;\n            PARSED_LITERAL(c, parsed_pattern);\n            }\n          class_range_state = RANGE_NO;\n          }\n        else  /* Potential start of range */\n          {\n          class_range_state = char_is_literal?\n            RANGE_OK_LITERAL : RANGE_OK_ESCAPED;\n          PARSED_LITERAL(c, parsed_pattern);\n          }\n        }\n\n      /* Handle escapes in a class */\n\n      else\n        {\n        tempptr = ptr;\n        escape = PRIV(check_escape)(&ptr, ptrend, &c, &errorcode, options,\n          cb->cx->extra_options, TRUE, cb);\n\n        if (errorcode != 0)\n          {\n          if ((extra_options & PCRE2_EXTRA_BAD_ESCAPE_IS_LITERAL) == 0)\n            goto FAILED;\n          ptr = tempptr;\n          if (ptr >= ptrend) c = CHAR_BACKSLASH; else\n            {\n            GETCHARINCTEST(c, ptr);   /* Get character value, increment pointer */\n            }\n          escape = 0;                 /* Treat as literal character */\n          }\n\n        switch(escape)\n          {\n          case 0:  /* Escaped character code point is in c */\n          char_is_literal = FALSE;\n          goto CLASS_LITERAL;\n\n          case ESC_b:\n          c = CHAR_BS;    /* \\b is backspace in a class */\n          char_is_literal = FALSE;\n          goto CLASS_LITERAL;\n\n          case ESC_Q:\n          inescq = TRUE;  /* Enter literal mode */\n          goto CLASS_CONTINUE;\n\n          case ESC_E:     /* Ignore orphan \\E */\n          goto CLASS_CONTINUE;\n\n          case ESC_B:     /* Always an error in a class */\n          case ESC_R:\n          case ESC_X:\n          errorcode = ERR7;\n          ptr--;\n          goto FAILED;\n          }\n\n        /* The second part of a range can be a single-character escape\n        sequence (detected above), but not any of the other escapes. Perl\n        treats a hyphen as a literal in such circumstances. However, in Perl's\n        warning mode, a warning is given, so PCRE now faults it, as it is\n        almost certainly a mistake on the user's part. */\n\n        if (class_range_state == RANGE_STARTED)\n          {\n          errorcode = ERR50;\n          goto FAILED;  /* Not CLASS_ESCAPE_FAILED; always an error */\n          }\n\n        /* Of the remaining escapes, only those that define characters are\n        allowed in a class. None may start a range. */\n\n        class_range_state = RANGE_NO;\n        switch(escape)\n          {\n          case ESC_N:\n          errorcode = ERR71;\n          goto FAILED;\n\n          case ESC_H:\n          case ESC_h:\n          case ESC_V:\n          case ESC_v:\n          *parsed_pattern++ = META_ESCAPE + escape;\n          break;\n\n          /* These escapes are converted to Unicode property tests when\n          PCRE2_UCP is set. */\n\n          case ESC_d:\n          case ESC_D:\n          case ESC_s:\n          case ESC_S:\n          case ESC_w:\n          case ESC_W:\n          if ((options & PCRE2_UCP) == 0)\n            {\n            *parsed_pattern++ = META_ESCAPE + escape;\n            }\n          else\n            {\n            *parsed_pattern++ = META_ESCAPE +\n              ((escape == ESC_d || escape == ESC_s || escape == ESC_w)?\n                ESC_p : ESC_P);\n            switch(escape)\n              {\n              case ESC_d:\n              case ESC_D:\n              *parsed_pattern++ = (PT_PC << 16) | ucp_Nd;\n              break;\n\n              case ESC_s:\n              case ESC_S:\n              *parsed_pattern++ = PT_SPACE << 16;\n              break;\n\n              case ESC_w:\n              case ESC_W:\n              *parsed_pattern++ = PT_WORD << 16;\n              break;\n              }\n            }\n          break;\n\n          /* Explicit Unicode property matching */\n\n          case ESC_P:\n          case ESC_p:\n#ifdef SUPPORT_UNICODE\n            {\n            BOOL negated;\n            uint16_t ptype = 0, pdata = 0;\n            if (!get_ucp(&ptr, &negated, &ptype, &pdata, &errorcode, cb))\n              goto FAILED;\n            if (negated) escape = (escape == ESC_P)? ESC_p : ESC_P;\n            *parsed_pattern++ = META_ESCAPE + escape;\n            *parsed_pattern++ = (ptype << 16) | pdata;\n            }\n#else\n          errorcode = ERR45;\n          goto FAILED;\n#endif\n          break;  /* End \\P and \\p */\n\n          default:    /* All others are not allowed in a class */\n          errorcode = ERR7;\n          ptr--;\n          goto FAILED;\n          }\n\n        /* Perl gives a warning unless a following hyphen is the last character\n        in the class. PCRE throws an error. */\n\n        if (ptr < ptrend - 1 && *ptr == CHAR_MINUS &&\n            ptr\u00dd1\u00a8 != CHAR_RIGHT_SQUARE_BRACKET)\n          {\n          errorcode = ERR50;\n          goto FAILED;\n          }\n        }\n\n      /* Proceed to next thing in the class. */\n\n      CLASS_CONTINUE:\n      if (ptr >= ptrend)\n        {\n        errorcode = ERR6;  /* Missing terminating '\u00a8' */\n        goto FAILED;\n        }\n      GETCHARINCTEST(c, ptr);\n      if (c == CHAR_RIGHT_SQUARE_BRACKET && !inescq) break;\n      }     /* End of class-processing loop */\n\n    /* -\u00a8 at the end of a class is a literal '-' */\n\n    if (class_range_state == RANGE_STARTED)\n      {\n      parsed_pattern\u00dd-1\u00a8 = CHAR_MINUS;\n      class_range_state = RANGE_NO;\n      }\n\n    *parsed_pattern++ = META_CLASS_END;\n    break;  /* End of character class */\n\n\n    /* ---- Opening parenthesis ---- */\n\n    case CHAR_LEFT_PARENTHESIS:\n    if (ptr >= ptrend) goto UNCLOSED_PARENTHESIS;\n\n    /* If ( is not followed by ? it is either a capture or a special verb or an\n    alpha assertion or a positive non-atomic lookahead. */\n\n    if (*ptr != CHAR_QUESTION_MARK)\n      {\n      const char *vn;\n\n      /* Handle capturing brackets (or non-capturing if auto-capture is turned\n      off). */\n\n      if (*ptr != CHAR_ASTERISK)\n        {\n        nest_depth++;\n        if ((options & PCRE2_NO_AUTO_CAPTURE) == 0)\n          {\n          if (cb->bracount >= MAX_GROUP_NUMBER)\n            {\n            errorcode = ERR97;\n            goto FAILED;\n            }\n          cb->bracount++;\n          *parsed_pattern++ = META_CAPTURE | cb->bracount;\n          }\n        else *parsed_pattern++ = META_NOCAPTURE;\n        }\n\n      /* Do nothing for (* followed by end of pattern or ) so it gives a \"bad\n      quantifier\" error rather than \"(*MARK) must have an argument\". */\n\n      else if (ptrend - ptr <= 1 || (c = ptr\u00dd1\u00a8) == CHAR_RIGHT_PARENTHESIS)\n        break;\n\n      /* Handle \"alpha assertions\" such as (*pla:...). Most of these are\n      synonyms for the historical symbolic assertions, but the script run and\n      non-atomic lookaround ones are new. They are distinguished by starting\n      with a lower case letter. Checking both ends of the alphabet makes this\n      work in all character codes. */\n\n      else if (CHMAX_255(c) && (cb->ctypes\u00ddc\u00a8 & ctype_lcletter) != 0)\n        {\n        uint32_t meta;\n\n        vn = alasnames;\n        if (!read_name(&ptr, ptrend, utf, 0, &offset, &name, &namelen,\n          &errorcode, cb)) goto FAILED;\n        if (ptr >= ptrend || *ptr != CHAR_COLON)\n          {\n          errorcode = ERR95;  /* Malformed */\n          goto FAILED;\n          }\n\n        /* Scan the table of alpha assertion names */\n\n        for (i = 0; i < alascount; i++)\n          {\n          if (namelen == alasmeta\u00ddi\u00a8.len &&\n              PRIV(strncmp_c8)(name, vn, namelen) == 0)\n            break;\n          vn += alasmeta\u00ddi\u00a8.len + 1;\n          }\n\n        if (i >= alascount)\n          {\n          errorcode = ERR95;  /* Alpha assertion not recognized */\n          goto FAILED;\n          }\n\n        /* Check for expecting an assertion condition. If so, only atomic\n        lookaround assertions are valid. */\n\n        meta = alasmeta\u00ddi\u00a8.meta;\n        if (prev_expect_cond_assert > 0 &&\n            (meta < META_LOOKAHEAD || meta > META_LOOKBEHINDNOT))\n          {\n          errorcode = (meta == META_LOOKAHEAD_NA || meta == META_LOOKBEHIND_NA)?\n            ERR98 : ERR28;  /* (Atomic) assertion expected */\n          goto FAILED;\n          }\n\n        /* The lookaround alphabetic synonyms can mostly be handled by jumping\n        to the code that handles the traditional symbolic forms. */\n\n        switch(meta)\n          {\n          default:\n          errorcode = ERR89;  /* Unknown code; should never occur because */\n          goto FAILED;        /* the meta values come from a table above. */\n\n          case META_ATOMIC:\n          goto ATOMIC_GROUP;\n\n          case META_LOOKAHEAD:\n          goto POSITIVE_LOOK_AHEAD;\n\n          case META_LOOKAHEAD_NA:\n          goto POSITIVE_NONATOMIC_LOOK_AHEAD;\n\n          case META_LOOKAHEADNOT:\n          goto NEGATIVE_LOOK_AHEAD;\n\n          case META_LOOKBEHIND:\n          case META_LOOKBEHINDNOT:\n          case META_LOOKBEHIND_NA:\n          *parsed_pattern++ = meta;\n          ptr--;\n          goto POST_LOOKBEHIND;\n\n          /* The script run facilities are handled here. Unicode support is\n          required (give an error if not, as this is a security issue). Always\n          record a META_SCRIPT_RUN item. Then, for the atomic version, insert\n          META_ATOMIC and remember that we need two META_KETs at the end. */\n\n          case META_SCRIPT_RUN:\n          case META_ATOMIC_SCRIPT_RUN:\n#ifdef SUPPORT_UNICODE\n          *parsed_pattern++ = META_SCRIPT_RUN;\n          nest_depth++;\n          ptr++;\n          if (meta == META_ATOMIC_SCRIPT_RUN)\n            {\n            *parsed_pattern++ = META_ATOMIC;\n            if (top_nest == NULL) top_nest = (nest_save *)(cb->start_workspace);\n            else if (++top_nest >= end_nests)\n              {\n              errorcode = ERR84;\n              goto FAILED;\n              }\n            top_nest->nest_depth = nest_depth;\n            top_nest->flags = NSF_ATOMICSR;\n            top_nest->options = options & PARSE_TRACKED_OPTIONS;\n            }\n          break;\n#else  /* SUPPORT_UNICODE */\n          errorcode = ERR96;\n          goto FAILED;\n#endif\n          }\n        }\n\n\n      /* ---- Handle (*VERB) and (*VERB:NAME) ---- */\n\n      else\n        {\n        vn = verbnames;\n        if (!read_name(&ptr, ptrend, utf, 0, &offset, &name, &namelen,\n          &errorcode, cb)) goto FAILED;\n        if (ptr >= ptrend || (*ptr != CHAR_COLON &&\n                              *ptr != CHAR_RIGHT_PARENTHESIS))\n          {\n          errorcode = ERR60;  /* Malformed */\n          goto FAILED;\n          }\n\n        /* Scan the table of verb names */\n\n        for (i = 0; i < verbcount; i++)\n          {\n          if (namelen == verbs\u00ddi\u00a8.len &&\n              PRIV(strncmp_c8)(name, vn, namelen) == 0)\n            break;\n          vn += verbs\u00ddi\u00a8.len + 1;\n          }\n\n        if (i >= verbcount)\n          {\n          errorcode = ERR60;  /* Verb not recognized */\n          goto FAILED;\n          }\n\n        /* An empty argument is treated as no argument. */\n\n        if (*ptr == CHAR_COLON && ptr + 1 < ptrend &&\n             ptr\u00dd1\u00a8 == CHAR_RIGHT_PARENTHESIS)\n          ptr++;    /* Advance to the closing parens */\n\n        /* Check for mandatory non-empty argument; this is (*MARK) */\n\n        if (verbs\u00ddi\u00a8.has_arg > 0 && *ptr != CHAR_COLON)\n          {\n          errorcode = ERR66;\n          goto FAILED;\n          }\n\n        /* Remember where this verb, possibly with a preceding (*MARK), starts,\n        for handling quantified (*ACCEPT). */\n\n        verbstartptr = parsed_pattern;\n        okquantifier = (verbs\u00ddi\u00a8.meta == META_ACCEPT);\n\n        /* It appears that Perl allows any characters whatsoever, other than a\n        closing parenthesis, to appear in arguments (\"names\"), so we no longer\n        insist on letters, digits, and underscores. Perl does not, however, do\n        any interpretation within arguments, and has no means of including a\n        closing parenthesis. PCRE supports escape processing but only when it\n        is requested by an option. We set inverbname TRUE here, and let the\n        main loop take care of this so that escape and \\x processing is done by\n        the main code above. */\n\n        if (*ptr++ == CHAR_COLON)   /* Skip past : or ) */\n          {\n          /* Some optional arguments can be treated as a preceding (*MARK) */\n\n          if (verbs\u00ddi\u00a8.has_arg < 0)\n            {\n            add_after_mark = verbs\u00ddi\u00a8.meta;\n            *parsed_pattern++ = META_MARK;\n            }\n\n          /* The remaining verbs with arguments (except *MARK) need a different\n          opcode. */\n\n          else\n            {\n            *parsed_pattern++ = verbs\u00ddi\u00a8.meta +\n              ((verbs\u00ddi\u00a8.meta != META_MARK)? 0x00010000u:0);\n            }\n\n          /* Set up for reading the name in the main loop. */\n\n          verblengthptr = parsed_pattern++;\n          verbnamestart = ptr;\n          inverbname = TRUE;\n          }\n        else  /* No verb \"name\" argument */\n          {\n          *parsed_pattern++ = verbs\u00ddi\u00a8.meta;\n          }\n        }     /* End of (*VERB) handling */\n      break;  /* Done with this parenthesis */\n      }       /* End of groups that don't start with (? */\n\n\n    /* ---- Items starting (? ---- */\n\n    /* The type of item is determined by what follows (?. Handle (?| and option\n    changes under \"default\" because both need a new block on the nest stack.\n    Comments starting with (?# are handled above. Note that there is some\n    ambiguity about the sequence (?- because if a digit follows it's a relative\n    recursion or subroutine call whereas otherwise it's an option unsetting. */\n\n    if (++ptr >= ptrend) goto UNCLOSED_PARENTHESIS;\n\n    switch(*ptr)\n      {\n      default:\n      if (*ptr == CHAR_MINUS && ptrend - ptr > 1 && IS_DIGIT(ptr\u00dd1\u00a8))\n        goto RECURSION_BYNUMBER;  /* The + case is handled by CHAR_PLUS */\n\n      /* We now have either (?| or a (possibly empty) option setting,\n      optionally followed by a non-capturing group. */\n\n      nest_depth++;\n      if (top_nest == NULL) top_nest = (nest_save *)(cb->start_workspace);\n      else if (++top_nest >= end_nests)\n        {\n        errorcode = ERR84;\n        goto FAILED;\n        }\n      top_nest->nest_depth = nest_depth;\n      top_nest->flags = 0;\n      top_nest->options = options & PARSE_TRACKED_OPTIONS;\n\n      /* Start of non-capturing group that resets the capture count for each\n      branch. */\n\n      if (*ptr == CHAR_VERTICAL_LINE)\n        {\n        top_nest->reset_group = (uint16_t)cb->bracount;\n        top_nest->max_group = (uint16_t)cb->bracount;\n        top_nest->flags |= NSF_RESET;\n        cb->external_flags |= PCRE2_DUPCAPUSED;\n        *parsed_pattern++ = META_NOCAPTURE;\n        ptr++;\n        }\n\n      /* Scan for options imnsxJU to be set or unset. */\n\n      else\n        {\n        BOOL hyphenok = TRUE;\n        uint32_t oldoptions = options;\n\n        top_nest->reset_group = 0;\n        top_nest->max_group = 0;\n        set = unset = 0;\n        optset = &set;\n\n        /* \u00ac at the start unsets imnsx and disables the subsequent use of - */\n\n        if (ptr < ptrend && *ptr == CHAR_CIRCUMFLEX_ACCENT)\n          {\n          options &= ~(PCRE2_CASELESS|PCRE2_MULTILINE|PCRE2_NO_AUTO_CAPTURE|\n                       PCRE2_DOTALL|PCRE2_EXTENDED|PCRE2_EXTENDED_MORE);\n          hyphenok = FALSE;\n          ptr++;\n          }\n\n        while (ptr < ptrend && *ptr != CHAR_RIGHT_PARENTHESIS &&\n                               *ptr != CHAR_COLON)\n          {\n          switch (*ptr++)\n            {\n            case CHAR_MINUS:\n            if (!hyphenok)\n              {\n              errorcode = ERR94;\n              ptr--;  /* Correct the offset */\n              goto FAILED;\n              }\n            optset = &unset;\n            hyphenok = FALSE;\n            break;\n\n            case CHAR_J:  /* Record that it changed in the external options */\n            *optset |= PCRE2_DUPNAMES;\n            cb->external_flags |= PCRE2_JCHANGED;\n            break;\n\n            case CHAR_i: *optset |= PCRE2_CASELESS; break;\n            case CHAR_m: *optset |= PCRE2_MULTILINE; break;\n            case CHAR_n: *optset |= PCRE2_NO_AUTO_CAPTURE; break;\n            case CHAR_s: *optset |= PCRE2_DOTALL; break;\n            case CHAR_U: *optset |= PCRE2_UNGREEDY; break;\n\n            /* If x appears twice it sets the extended extended option. */\n\n            case CHAR_x:\n            *optset |= PCRE2_EXTENDED;\n            if (ptr < ptrend && *ptr == CHAR_x)\n              {\n              *optset |= PCRE2_EXTENDED_MORE;\n              ptr++;\n              }\n            break;\n\n            default:\n            errorcode = ERR11;\n            ptr--;    /* Correct the offset */\n            goto FAILED;\n            }\n          }\n\n        /* If we are setting extended without extended-more, ensure that any\n        existing extended-more gets unset. Also, unsetting extended must also\n        unset extended-more. */\n\n        if ((set & (PCRE2_EXTENDED|PCRE2_EXTENDED_MORE)) == PCRE2_EXTENDED ||\n            (unset & PCRE2_EXTENDED) != 0)\n          unset |= PCRE2_EXTENDED_MORE;\n\n        options = (options | set) & (~unset);\n\n        /* If the options ended with ')' this is not the start of a nested\n        group with option changes, so the options change at this level.\n        In this case, if the previous level set up a nest block, discard the\n        one we have just created. Otherwise adjust it for the previous level.\n        If the options ended with ':' we are starting a non-capturing group,\n        possibly with an options setting. */\n\n        if (ptr >= ptrend) goto UNCLOSED_PARENTHESIS;\n        if (*ptr++ == CHAR_RIGHT_PARENTHESIS)\n          {\n          nest_depth--;  /* This is not a nested group after all. */\n          if (top_nest > (nest_save *)(cb->start_workspace) &&\n              (top_nest-1)->nest_depth == nest_depth) top_nest--;\n          else top_nest->nest_depth = nest_depth;\n          }\n        else *parsed_pattern++ = META_NOCAPTURE;\n\n        /* If nothing changed, no need to record. */\n\n        if (options != oldoptions)\n          {\n          *parsed_pattern++ = META_OPTIONS;\n          *parsed_pattern++ = options;\n          }\n        }     /* End options processing */\n      break;  /* End default case after (? */\n\n\n      /* ---- Python syntax support ---- */\n\n      case CHAR_P:\n      if (++ptr >= ptrend) goto UNCLOSED_PARENTHESIS;\n\n      /* (?P<name> is the same as (?<name>, which defines a named group. */\n\n      if (*ptr == CHAR_LESS_THAN_SIGN)\n        {\n        terminator = CHAR_GREATER_THAN_SIGN;\n        goto DEFINE_NAME;\n        }\n\n      /* (?P>name) is the same as (?&name), which is a recursion or subroutine\n      call. */\n\n      if (*ptr == CHAR_GREATER_THAN_SIGN) goto RECURSE_BY_NAME;\n\n      /* (?P=name) is the same as \\k<name>, a back reference by name. Anything\n      else after (?P is an error. */\n\n      if (*ptr != CHAR_EQUALS_SIGN)\n        {\n        errorcode = ERR41;\n        goto FAILED;\n        }\n      if (!read_name(&ptr, ptrend, utf, CHAR_RIGHT_PARENTHESIS, &offset, &name,\n          &namelen, &errorcode, cb)) goto FAILED;\n      *parsed_pattern++ = META_BACKREF_BYNAME;\n      *parsed_pattern++ = namelen;\n      PUTOFFSET(offset, parsed_pattern);\n      okquantifier = TRUE;\n      break;   /* End of (?P processing */\n\n\n      /* ---- Recursion/subroutine calls by number ---- */\n\n      case CHAR_R:\n      i = 0;         /* (?R) == (?R0) */\n      ptr++;\n      if (ptr >= ptrend || *ptr != CHAR_RIGHT_PARENTHESIS)\n        {\n        errorcode = ERR58;\n        goto FAILED;\n        }\n      goto SET_RECURSION;\n\n      /* An item starting (?- followed by a digit comes here via the \"default\"\n      case because (?- followed by a non-digit is an options setting. */\n\n      case CHAR_PLUS:\n      if (ptrend - ptr < 2 || !IS_DIGIT(ptr\u00dd1\u00a8))\n        {\n        errorcode = ERR29;   /* Missing number */\n        goto FAILED;\n        }\n      /* Fall through */\n\n      case CHAR_0: case CHAR_1: case CHAR_2: case CHAR_3: case CHAR_4:\n      case CHAR_5: case CHAR_6: case CHAR_7: case CHAR_8: case CHAR_9:\n      RECURSION_BYNUMBER:\n      if (!read_number(&ptr, ptrend,\n          (IS_DIGIT(*ptr))? -1:(int)(cb->bracount), /* + and - are relative */\n          MAX_GROUP_NUMBER, ERR61,\n          &i, &errorcode)) goto FAILED;\n      if (i < 0)  /* NB (?0) is permitted */\n        {\n        errorcode = ERR15;   /* Unknown group */\n        goto FAILED_BACK;\n        }\n      if (ptr >= ptrend || *ptr != CHAR_RIGHT_PARENTHESIS)\n        goto UNCLOSED_PARENTHESIS;\n\n      SET_RECURSION:\n      *parsed_pattern++ = META_RECURSE | (uint32_t)i;\n      offset = (PCRE2_SIZE)(ptr - cb->start_pattern);\n      ptr++;\n      PUTOFFSET(offset, parsed_pattern);\n      okquantifier = TRUE;\n      break;  /* End of recursive call by number handling */\n\n\n      /* ---- Recursion/subroutine calls by name ---- */\n\n      case CHAR_AMPERSAND:\n      RECURSE_BY_NAME:\n      if (!read_name(&ptr, ptrend, utf, CHAR_RIGHT_PARENTHESIS, &offset, &name,\n          &namelen, &errorcode, cb)) goto FAILED;\n      *parsed_pattern++ = META_RECURSE_BYNAME;\n      *parsed_pattern++ = namelen;\n      PUTOFFSET(offset, parsed_pattern);\n      okquantifier = TRUE;\n      break;\n\n      /* ---- Callout with numerical or string argument ---- */\n\n      case CHAR_C:\n      if (++ptr >= ptrend) goto UNCLOSED_PARENTHESIS;\n\n      /* If the previous item was a condition starting (?(? an assertion,\n      optionally preceded by a callout, is expected. This is checked later on,\n      during actual compilation. However we need to identify this kind of\n      assertion in this pass because it must not be qualified. The value of\n      expect_cond_assert is set to 2 after (?(? is processed. We decrement it\n      for a callout - still leaving a positive value that identifies the\n      assertion. Multiple callouts or any other items will make it zero or\n      less, which doesn't matter because they will cause an error later. */\n\n      expect_cond_assert = prev_expect_cond_assert - 1;\n\n      /* If previous_callout is not NULL, it means this follows a previous\n      callout. If it was a manual callout, do nothing; this means its \"length\n      of next pattern item\" field will remain zero. If it was an automatic\n      callout, abolish it. */\n\n      if (previous_callout != NULL && (options & PCRE2_AUTO_CALLOUT) != 0 &&\n          previous_callout == parsed_pattern - 4 &&\n          parsed_pattern\u00dd-1\u00a8 == 255)\n        parsed_pattern = previous_callout;\n\n      /* Save for updating next pattern item length, and skip one item before\n      completing. */\n\n      previous_callout = parsed_pattern;\n      after_manual_callout = 1;\n\n      /* Handle a string argument; specific delimiter is required. */\n\n      if (*ptr != CHAR_RIGHT_PARENTHESIS && !IS_DIGIT(*ptr))\n        {\n        PCRE2_SIZE calloutlength;\n        PCRE2_SPTR startptr = ptr;\n\n        delimiter = 0;\n        for (i = 0; PRIV(callout_start_delims)\u00ddi\u00a8 != 0; i++)\n          {\n          if (*ptr == PRIV(callout_start_delims)\u00ddi\u00a8)\n            {\n            delimiter = PRIV(callout_end_delims)\u00ddi\u00a8;\n            break;\n            }\n          }\n        if (delimiter == 0)\n          {\n          errorcode = ERR82;\n          goto FAILED;\n          }\n\n        *parsed_pattern = META_CALLOUT_STRING;\n        parsed_pattern += 3;   /* Skip pattern info */\n\n        for (;;)\n          {\n          if (++ptr >= ptrend)\n            {\n            errorcode = ERR81;\n            ptr = startptr;   /* To give a more useful message */\n            goto FAILED;\n            }\n          if (*ptr == delimiter && (++ptr >= ptrend || *ptr != delimiter))\n            break;\n          }\n\n        calloutlength = (PCRE2_SIZE)(ptr - startptr);\n        if (calloutlength > UINT32_MAX)\n          {\n          errorcode = ERR72;\n          goto FAILED;\n          }\n        *parsed_pattern++ = (uint32_t)calloutlength;\n        offset = (PCRE2_SIZE)(startptr - cb->start_pattern);\n        PUTOFFSET(offset, parsed_pattern);\n        }\n\n      /* Handle a callout with an optional numerical argument, which must be\n      less than or equal to 255. A missing argument gives 0. */\n\n      else\n        {\n        int n = 0;\n        *parsed_pattern = META_CALLOUT_NUMBER;     /* Numerical callout */\n        parsed_pattern += 3;                       /* Skip pattern info */\n        while (ptr < ptrend && IS_DIGIT(*ptr))\n          {\n          n = n * 10 + *ptr++ - CHAR_0;\n          if (n > 255)\n            {\n            errorcode = ERR38;\n            goto FAILED;\n            }\n          }\n        *parsed_pattern++ = n;\n        }\n\n      /* Both formats must have a closing parenthesis */\n\n      if (ptr >= ptrend || *ptr != CHAR_RIGHT_PARENTHESIS)\n        {\n        errorcode = ERR39;\n        goto FAILED;\n        }\n      ptr++;\n\n      /* Remember the offset to the next item in the pattern, and set a default\n      length. This should get updated after the next item is read. */\n\n      previous_callout\u00dd1\u00a8 = (uint32_t)(ptr - cb->start_pattern);\n      previous_callout\u00dd2\u00a8 = 0;\n      break;                  /* End callout */\n\n\n      /* ---- Conditional group ---- */\n\n      /* A condition can be an assertion, a number (referring to a numbered\n      group's having been set), a name (referring to a named group), or 'R',\n      referring to overall recursion. R<digits> and R&name are also permitted\n      for recursion state tests. Numbers may be preceded by + or - to specify a\n      relative group number.\n\n      There are several syntaxes for testing a named group: (?(name)) is used\n      by Python; Perl 5.10 onwards uses (?(<name>) or (?('name')).\n\n      There are two unfortunate ambiguities. 'R' can be the recursive thing or\n      the name 'R' (and similarly for 'R' followed by digits). 'DEFINE' can be\n      the Perl DEFINE feature or the Python named test. We look for a name\n      first; if not found, we try the other case.\n\n      For compatibility with auto-callouts, we allow a callout to be specified\n      before a condition that is an assertion. */\n\n      case CHAR_LEFT_PARENTHESIS:\n      if (++ptr >= ptrend) goto UNCLOSED_PARENTHESIS;\n      nest_depth++;\n\n      /* If the next character is ? or * there must be an assertion next\n      (optionally preceded by a callout). We do not check this here, but\n      instead we set expect_cond_assert to 2. If this is still greater than\n      zero (callouts decrement it) when the next assertion is read, it will be\n      marked as a condition that must not be repeated. A value greater than\n      zero also causes checking that an assertion (possibly with callout)\n      follows. */\n\n      if (*ptr == CHAR_QUESTION_MARK || *ptr == CHAR_ASTERISK)\n        {\n        *parsed_pattern++ = META_COND_ASSERT;\n        ptr--;   /* Pull pointer back to the opening parenthesis. */\n        expect_cond_assert = 2;\n        break;  /* End of conditional */\n        }\n\n      /* Handle (?(\u00dd+-\u00a8number)... */\n\n      if (read_number(&ptr, ptrend, cb->bracount, MAX_GROUP_NUMBER, ERR61, &i,\n          &errorcode))\n        {\n        if (i <= 0)\n          {\n          errorcode = ERR15;\n          goto FAILED;\n          }\n        *parsed_pattern++ = META_COND_NUMBER;\n        offset = (PCRE2_SIZE)(ptr - cb->start_pattern - 2);\n        PUTOFFSET(offset, parsed_pattern);\n        *parsed_pattern++ = i;\n        }\n      else if (errorcode != 0) goto FAILED;   /* Number too big */\n\n      /* No number found. Handle the special case (?(VERSION\u00dd>\u00a8=n.m)... */\n\n      else if (ptrend - ptr >= 10 &&\n               PRIV(strncmp_c8)(ptr, STRING_VERSION, 7) == 0 &&\n               ptr\u00dd7\u00a8 != CHAR_RIGHT_PARENTHESIS)\n        {\n        uint32_t ge = 0;\n        int major = 0;\n        int minor = 0;\n\n        ptr += 7;\n        if (*ptr == CHAR_GREATER_THAN_SIGN)\n          {\n          ge = 1;\n          ptr++;\n          }\n\n        /* NOTE: cannot write IS_DIGIT(*(++ptr)) here because IS_DIGIT\n        references its argument twice. */\n\n        if (*ptr != CHAR_EQUALS_SIGN || (ptr++, !IS_DIGIT(*ptr)))\n          goto BAD_VERSION_CONDITION;\n\n        if (!read_number(&ptr, ptrend, -1, 1000, ERR79, &major, &errorcode))\n          goto FAILED;\n\n        if (ptr >= ptrend) goto BAD_VERSION_CONDITION;\n        if (*ptr == CHAR_DOT)\n          {\n          if (++ptr >= ptrend || !IS_DIGIT(*ptr)) goto BAD_VERSION_CONDITION;\n          minor = (*ptr++ - CHAR_0) * 10;\n          if (IS_DIGIT(*ptr)) minor += *ptr++ - CHAR_0;\n          if (ptr >= ptrend || *ptr != CHAR_RIGHT_PARENTHESIS)\n            goto BAD_VERSION_CONDITION;\n          }\n\n        *parsed_pattern++ = META_COND_VERSION;\n        *parsed_pattern++ = ge;\n        *parsed_pattern++ = major;\n        *parsed_pattern++ = minor;\n        }\n\n      /* All the remaining cases now require us to read a name. We cannot at\n      this stage distinguish ambiguous cases such as (?(R12) which might be a\n      recursion test by number or a name, because the named groups have not yet\n      all been identified. Those cases are treated as names, but given a\n      different META code. */\n\n      else\n        {\n        BOOL was_r_ampersand = FALSE;\n\n        if (*ptr == CHAR_R && ptrend - ptr > 1 && ptr\u00dd1\u00a8 == CHAR_AMPERSAND)\n          {\n          terminator = CHAR_RIGHT_PARENTHESIS;\n          was_r_ampersand = TRUE;\n          ptr++;\n          }\n        else if (*ptr == CHAR_LESS_THAN_SIGN)\n          terminator = CHAR_GREATER_THAN_SIGN;\n        else if (*ptr == CHAR_APOSTROPHE)\n          terminator = CHAR_APOSTROPHE;\n        else\n          {\n          terminator = CHAR_RIGHT_PARENTHESIS;\n          ptr--;   /* Point to char before name */\n          }\n        if (!read_name(&ptr, ptrend, utf, terminator, &offset, &name, &namelen,\n            &errorcode, cb)) goto FAILED;\n\n        /* Handle (?(R&name) */\n\n        if (was_r_ampersand)\n          {\n          *parsed_pattern = META_COND_RNAME;\n          ptr--;   /* Back to closing parens */\n          }\n\n        /* Handle (?(name). If the name is \"DEFINE\" we identify it with a\n        special code. Likewise if the name consists of R followed only by\n        digits. Otherwise, handle it like a quoted name. */\n\n        else if (terminator == CHAR_RIGHT_PARENTHESIS)\n          {\n          if (namelen == 6 && PRIV(strncmp_c8)(name, STRING_DEFINE, 6) == 0)\n            *parsed_pattern = META_COND_DEFINE;\n          else\n            {\n            for (i = 1; i < (int)namelen; i++)\n              if (!IS_DIGIT(name\u00ddi\u00a8)) break;\n            *parsed_pattern = (*name == CHAR_R && i >= (int)namelen)?\n              META_COND_RNUMBER : META_COND_NAME;\n            }\n          ptr--;   /* Back to closing parens */\n          }\n\n        /* Handle (?('name') or (?(<name>) */\n\n        else *parsed_pattern = META_COND_NAME;\n\n        /* All these cases except DEFINE end with the name length and offset;\n        DEFINE just has an offset (for the \"too many branches\" error). */\n\n        if (*parsed_pattern++ != META_COND_DEFINE) *parsed_pattern++ = namelen;\n        PUTOFFSET(offset, parsed_pattern);\n        }  /* End cases that read a name */\n\n      /* Check the closing parenthesis of the condition */\n\n      if (ptr >= ptrend || *ptr != CHAR_RIGHT_PARENTHESIS)\n        {\n        errorcode = ERR24;\n        goto FAILED;\n        }\n      ptr++;\n      break;  /* End of condition processing */\n\n\n      /* ---- Atomic group ---- */\n\n      case CHAR_GREATER_THAN_SIGN:\n      ATOMIC_GROUP:                          /* Come from (*atomic: */\n      *parsed_pattern++ = META_ATOMIC;\n      nest_depth++;\n      ptr++;\n      break;\n\n\n      /* ---- Lookahead assertions ---- */\n\n      case CHAR_EQUALS_SIGN:\n      POSITIVE_LOOK_AHEAD:                   /* Come from (*pla: */\n      *parsed_pattern++ = META_LOOKAHEAD;\n      ptr++;\n      goto POST_ASSERTION;\n\n      case CHAR_ASTERISK:\n      POSITIVE_NONATOMIC_LOOK_AHEAD:         /* Come from (?* */\n      *parsed_pattern++ = META_LOOKAHEAD_NA;\n      ptr++;\n      goto POST_ASSERTION;\n\n      case CHAR_EXCLAMATION_MARK:\n      NEGATIVE_LOOK_AHEAD:                   /* Come from (*nla: */\n      *parsed_pattern++ = META_LOOKAHEADNOT;\n      ptr++;\n      goto POST_ASSERTION;\n\n\n      /* ---- Lookbehind assertions ---- */\n\n      /* (?< followed by = or ! or * is a lookbehind assertion. Otherwise (?<\n      is the start of the name of a capturing group. */\n\n      case CHAR_LESS_THAN_SIGN:\n      if (ptrend - ptr <= 1 ||\n         (ptr\u00dd1\u00a8 != CHAR_EQUALS_SIGN &&\n          ptr\u00dd1\u00a8 != CHAR_EXCLAMATION_MARK &&\n          ptr\u00dd1\u00a8 != CHAR_ASTERISK))\n        {\n        terminator = CHAR_GREATER_THAN_SIGN;\n        goto DEFINE_NAME;\n        }\n      *parsed_pattern++ = (ptr\u00dd1\u00a8 == CHAR_EQUALS_SIGN)?\n        META_LOOKBEHIND : (ptr\u00dd1\u00a8 == CHAR_EXCLAMATION_MARK)?\n        META_LOOKBEHINDNOT : META_LOOKBEHIND_NA;\n\n      POST_LOOKBEHIND:           /* Come from (*plb: (*naplb: and (*nlb: */\n      *has_lookbehind = TRUE;\n      offset = (PCRE2_SIZE)(ptr - cb->start_pattern - 2);\n      PUTOFFSET(offset, parsed_pattern);\n      ptr += 2;\n      /* Fall through */\n\n      /* If the previous item was a condition starting (?(? an assertion,\n      optionally preceded by a callout, is expected. This is checked later on,\n      during actual compilation. However we need to identify this kind of\n      assertion in this pass because it must not be qualified. The value of\n      expect_cond_assert is set to 2 after (?(? is processed. We decrement it\n      for a callout - still leaving a positive value that identifies the\n      assertion. Multiple callouts or any other items will make it zero or\n      less, which doesn't matter because they will cause an error later. */\n\n      POST_ASSERTION:\n      nest_depth++;\n      if (prev_expect_cond_assert > 0)\n        {\n        if (top_nest == NULL) top_nest = (nest_save *)(cb->start_workspace);\n        else if (++top_nest >= end_nests)\n          {\n          errorcode = ERR84;\n          goto FAILED;\n          }\n        top_nest->nest_depth = nest_depth;\n        top_nest->flags = NSF_CONDASSERT;\n        top_nest->options = options & PARSE_TRACKED_OPTIONS;\n        }\n      break;\n\n\n      /* ---- Define a named group ---- */\n\n      /* A named group may be defined as (?'name') or (?<name>). In the latter\n      case we jump to DEFINE_NAME from the disambiguation of (?< above with the\n      terminator set to '>'. */\n\n      case CHAR_APOSTROPHE:\n      terminator = CHAR_APOSTROPHE;    /* Terminator */\n\n      DEFINE_NAME:\n      if (!read_name(&ptr, ptrend, utf, terminator, &offset, &name, &namelen,\n          &errorcode, cb)) goto FAILED;\n\n      /* We have a name for this capturing group. It is also assigned a number,\n      which is its primary means of identification. */\n\n      if (cb->bracount >= MAX_GROUP_NUMBER)\n        {\n        errorcode = ERR97;\n        goto FAILED;\n        }\n      cb->bracount++;\n      *parsed_pattern++ = META_CAPTURE | cb->bracount;\n      nest_depth++;\n\n      /* Check not too many names */\n\n      if (cb->names_found >= MAX_NAME_COUNT)\n        {\n        errorcode = ERR49;\n        goto FAILED;\n        }\n\n      /* Adjust the entry size to accommodate the longest name found. */\n\n      if (namelen + IMM2_SIZE + 1 > cb->name_entry_size)\n        cb->name_entry_size = (uint16_t)(namelen + IMM2_SIZE + 1);\n\n      /* Scan the list to check for duplicates. For duplicate names, if the\n      number is the same, break the loop, which causes the name to be\n      discarded; otherwise, if DUPNAMES is not set, give an error.\n      If it is set, allow the name with a different number, but continue\n      scanning in case this is a duplicate with the same number. For\n      non-duplicate names, give an error if the number is duplicated. */\n\n      isdupname = FALSE;\n      ng = cb->named_groups;\n      for (i = 0; i < cb->names_found; i++, ng++)\n        {\n        if (namelen == ng->length &&\n            PRIV(strncmp)(name, ng->name, (PCRE2_SIZE)namelen) == 0)\n          {\n          if (ng->number == cb->bracount) break;\n          if ((options & PCRE2_DUPNAMES) == 0)\n            {\n            errorcode = ERR43;\n            goto FAILED;\n            }\n          isdupname = ng->isdup = TRUE;     /* Mark as a duplicate */\n          cb->dupnames = TRUE;              /* Duplicate names exist */\n          }\n        else if (ng->number == cb->bracount)\n          {\n          errorcode = ERR65;\n          goto FAILED;\n          }\n        }\n\n      if (i < cb->names_found) break;   /* Ignore duplicate with same number */\n\n      /* Increase the list size if necessary */\n\n      if (cb->names_found >= cb->named_group_list_size)\n        {\n        uint32_t newsize = cb->named_group_list_size * 2;\n        named_group *newspace =\n          cb->cx->memctl.malloc(newsize * sizeof(named_group),\n          cb->cx->memctl.memory_data);\n        if (newspace == NULL)\n          {\n          errorcode = ERR21;\n          goto FAILED;\n          }\n\n        memcpy(newspace, cb->named_groups,\n          cb->named_group_list_size * sizeof(named_group));\n        if (cb->named_group_list_size > NAMED_GROUP_LIST_SIZE)\n          cb->cx->memctl.free((void *)cb->named_groups,\n          cb->cx->memctl.memory_data);\n        cb->named_groups = newspace;\n        cb->named_group_list_size = newsize;\n        }\n\n      /* Add this name to the list */\n\n      cb->named_groups\u00ddcb->names_found\u00a8.name = name;\n      cb->named_groups\u00ddcb->names_found\u00a8.length = (uint16_t)namelen;\n      cb->named_groups\u00ddcb->names_found\u00a8.number = cb->bracount;\n      cb->named_groups\u00ddcb->names_found\u00a8.isdup = (uint16_t)isdupname;\n      cb->names_found++;\n      break;\n      }        /* End of (? switch */\n    break;     /* End of ( handling */\n\n\n    /* ---- Branch terminators ---- */\n\n    /* Alternation: reset the capture count if we are in a (?| group. */\n\n    case CHAR_VERTICAL_LINE:\n    if (top_nest != NULL && top_nest->nest_depth == nest_depth &&\n        (top_nest->flags & NSF_RESET) != 0)\n      {\n      if (cb->bracount > top_nest->max_group)\n        top_nest->max_group = (uint16_t)cb->bracount;\n      cb->bracount = top_nest->reset_group;\n      }\n    *parsed_pattern++ = META_ALT;\n    break;\n\n    /* End of group; reset the capture count to the maximum if we are in a (?|\n    group and/or reset the options that are tracked during parsing. Disallow\n    quantifier for a condition that is an assertion. */\n\n    case CHAR_RIGHT_PARENTHESIS:\n    okquantifier = TRUE;\n    if (top_nest != NULL && top_nest->nest_depth == nest_depth)\n      {\n      options = (options & ~PARSE_TRACKED_OPTIONS) | top_nest->options;\n      if ((top_nest->flags & NSF_RESET) != 0 &&\n          top_nest->max_group > cb->bracount)\n        cb->bracount = top_nest->max_group;\n      if ((top_nest->flags & NSF_CONDASSERT) != 0)\n        okquantifier = FALSE;\n\n      if ((top_nest->flags & NSF_ATOMICSR) != 0)\n        {\n        *parsed_pattern++ = META_KET;\n        }\n\n      if (top_nest == (nest_save *)(cb->start_workspace)) top_nest = NULL;\n        else top_nest--;\n      }\n    if (nest_depth == 0)    /* Unmatched closing parenthesis */\n      {\n      errorcode = ERR22;\n      goto FAILED_BACK;\n      }\n    nest_depth--;\n    *parsed_pattern++ = META_KET;\n    break;\n    }  /* End of switch on pattern character */\n  }    /* End of main character scan loop */\n\n/* End of pattern reached. Check for missing ) at the end of a verb name. */\n\nif (inverbname && ptr >= ptrend)\n  {\n  errorcode = ERR60;\n  goto FAILED;\n  }\n\n/* Manage callout for the final item */\n\nPARSED_END:\nparsed_pattern = manage_callouts(ptr, &previous_callout, auto_callout,\n  parsed_pattern, cb);\n\n/* Insert trailing items for word and line matching (features provided for the\nbenefit of pcre2grep). */\n\nif ((extra_options & PCRE2_EXTRA_MATCH_LINE) != 0)\n  {\n  *parsed_pattern++ = META_KET;\n  *parsed_pattern++ = META_DOLLAR;\n  }\nelse if ((extra_options & PCRE2_EXTRA_MATCH_WORD) != 0)\n  {\n  *parsed_pattern++ = META_KET;\n  *parsed_pattern++ = META_ESCAPE + ESC_b;\n  }\n\n/* Terminate the parsed pattern, then return success if all groups are closed.\nOtherwise we have unclosed parentheses. */\n\nif (parsed_pattern >= parsed_pattern_end)\n  {\n  errorcode = ERR63;  /* Internal error (parsed pattern overflow) */\n  goto FAILED;\n  }\n\n*parsed_pattern = META_END;\nif (nest_depth == 0) return 0;\n\nUNCLOSED_PARENTHESIS:\nerrorcode = ERR14;\n\n/* Come here for all failures. */\n\nFAILED:\ncb->erroroffset = (PCRE2_SIZE)(ptr - cb->start_pattern);\nreturn errorcode;\n\n/* Some errors need to indicate the previous character. */\n\nFAILED_BACK:\nptr--;\ngoto FAILED;\n\n/* This failure happens several times. */\n\nBAD_VERSION_CONDITION:\nerrorcode = ERR79;\ngoto FAILED;\n}\n\n\n\n/*************************************************\n*       Find first significant opcode            *\n*************************************************/\n\n/* This is called by several functions that scan a compiled expression looking\nfor a fixed first character, or an anchoring opcode etc. It skips over things\nthat do not influence this. For some calls, it makes sense to skip negative\nforward and all backward assertions, and also the \\b assertion; for others it\ndoes not.\n\nArguments:\n  code         pointer to the start of the group\n  skipassert   TRUE if certain assertions are to be skipped\n\nReturns:       pointer to the first significant opcode\n*/\n\nstatic const PCRE2_UCHAR*\nfirst_significant_code(PCRE2_SPTR code, BOOL skipassert)\n{\nfor (;;)\n  {\n  switch ((int)*code)\n    {\n    case OP_ASSERT_NOT:\n    case OP_ASSERTBACK:\n    case OP_ASSERTBACK_NOT:\n    case OP_ASSERTBACK_NA:\n    if (!skipassert) return code;\n    do code += GET(code, 1); while (*code == OP_ALT);\n    code += PRIV(OP_lengths)\u00dd*code\u00a8;\n    break;\n\n    case OP_WORD_BOUNDARY:\n    case OP_NOT_WORD_BOUNDARY:\n    if (!skipassert) return code;\n    /* Fall through */\n\n    case OP_CALLOUT:\n    case OP_CREF:\n    case OP_DNCREF:\n    case OP_RREF:\n    case OP_DNRREF:\n    case OP_FALSE:\n    case OP_TRUE:\n    code += PRIV(OP_lengths)\u00dd*code\u00a8;\n    break;\n\n    case OP_CALLOUT_STR:\n    code += GET(code, 1 + 2*LINK_SIZE);\n    break;\n\n    case OP_SKIPZERO:\n    code += 2 + GET(code, 2) + LINK_SIZE;\n    break;\n\n    case OP_COND:\n    case OP_SCOND:\n    if (code\u00dd1+LINK_SIZE\u00a8 != OP_FALSE ||   /* Not DEFINE */\n        code\u00ddGET(code, 1)\u00a8 != OP_KET)      /* More than one branch */\n      return code;\n    code += GET(code, 1) + 1 + LINK_SIZE;\n    break;\n\n    case OP_MARK:\n    case OP_COMMIT_ARG:\n    case OP_PRUNE_ARG:\n    case OP_SKIP_ARG:\n    case OP_THEN_ARG:\n    code += code\u00dd1\u00a8 + PRIV(OP_lengths)\u00dd*code\u00a8;\n    break;\n\n    default:\n    return code;\n    }\n  }\n/* Control never reaches here */\n}\n\n\n\n#ifdef SUPPORT_UNICODE\n/*************************************************\n*           Get othercase range                  *\n*************************************************/\n\n/* This function is passed the start and end of a class range in UCP mode. It\nsearches up the characters, looking for ranges of characters in the \"other\"\ncase. Each call returns the next one, updating the start address. A character\nwith multiple other cases is returned on its own with a special return value.\n\nArguments:\n  cptr        points to starting character value; updated\n  d           end value\n  ocptr       where to put start of othercase range\n  odptr       where to put end of othercase range\n\nYield:        -1 when no more\n               0 when a range is returned\n              >0 the CASESET offset for char with multiple other cases\n                in this case, ocptr contains the original\n*/\n\nstatic int\nget_othercase_range(uint32_t *cptr, uint32_t d, uint32_t *ocptr,\n  uint32_t *odptr)\n{\nuint32_t c, othercase, next;\nunsigned int co;\n\n/* Find the first character that has an other case. If it has multiple other\ncases, return its case offset value. */\n\nfor (c = *cptr; c <= d; c++)\n  {\n  if ((co = UCD_CASESET(c)) != 0)\n    {\n    *ocptr = c++;   /* Character that has the set */\n    *cptr = c;      /* Rest of input range */\n    return (int)co;\n    }\n  if ((othercase = UCD_OTHERCASE(c)) != c) break;\n  }\n\nif (c > d) return -1;  /* Reached end of range */\n\n/* Found a character that has a single other case. Search for the end of the\nrange, which is either the end of the input range, or a character that has zero\nor more than one other cases. */\n\n*ocptr = othercase;\nnext = othercase + 1;\n\nfor (++c; c <= d; c++)\n  {\n  if ((co = UCD_CASESET(c)) != 0 || UCD_OTHERCASE(c) != next) break;\n  next++;\n  }\n\n*odptr = next - 1;     /* End of othercase range */\n*cptr = c;             /* Rest of input range */\nreturn 0;\n}\n#endif  /* SUPPORT_UNICODE */\n\n\n\n/*************************************************\n* Add a character or range to a class (internal) *\n*************************************************/\n\n/* This function packages up the logic of adding a character or range of\ncharacters to a class. The character values in the arguments will be within the\nvalid values for the current mode (8-bit, 16-bit, UTF, etc). This function is\ncalled only from within the \"add to class\" group of functions, some of which\nare recursive and mutually recursive. The external entry point is\nadd_to_class().\n\nArguments:\n  classbits     the bit map for characters < 256\n  uchardptr     points to the pointer for extra data\n  options       the options word\n  cb            compile data\n  start         start of range character\n  end           end of range character\n\nReturns:        the number of < 256 characters added\n                the pointer to extra data is updated\n*/\n\nstatic unsigned int\nadd_to_class_internal(uint8_t *classbits, PCRE2_UCHAR **uchardptr,\n  uint32_t options, compile_block *cb, uint32_t start, uint32_t end)\n{\nuint32_t c;\nuint32_t classbits_end = (end <= 0xff ? end : 0xff);\nunsigned int n8 = 0;\n\n/* If caseless matching is required, scan the range and process alternate\ncases. In Unicode, there are 8-bit characters that have alternate cases that\nare greater than 255 and vice-versa. Sometimes we can just extend the original\nrange. */\n\nif ((options & PCRE2_CASELESS) != 0)\n  {\n#ifdef SUPPORT_UNICODE\n  if ((options & (PCRE2_UTF|PCRE2_UCP)) != 0)\n    {\n    int rc;\n    uint32_t oc, od;\n\n    options &= ~PCRE2_CASELESS;   /* Remove for recursive calls */\n    c = start;\n\n    while ((rc = get_othercase_range(&c, end, &oc, &od)) >= 0)\n      {\n      /* Handle a single character that has more than one other case. */\n\n      if (rc > 0) n8 += add_list_to_class_internal(classbits, uchardptr, options, cb,\n        PRIV(ucd_caseless_sets) + rc, oc);\n\n      /* Do nothing if the other case range is within the original range. */\n\n      else if (oc >= cb->class_range_start && od <= cb->class_range_end) continue;\n\n      /* Extend the original range if there is overlap, noting that if oc < c, we\n      can't have od > end because a subrange is always shorter than the basic\n      range. Otherwise, use a recursive call to add the additional range. */\n\n      else if (oc < start && od >= start - 1) start = oc; /* Extend downwards */\n      else if (od > end && oc <= end + 1)\n        {\n        end = od;       /* Extend upwards */\n        if (end > classbits_end) classbits_end = (end <= 0xff ? end : 0xff);\n        }\n      else n8 += add_to_class_internal(classbits, uchardptr, options, cb, oc, od);\n      }\n    }\n  else\n#endif  /* SUPPORT_UNICODE */\n\n  /* Not UTF mode */\n\n  for (c = start; c <= classbits_end; c++)\n    {\n    SETBIT(classbits, cb->fcc\u00ddc\u00a8);\n    n8++;\n    }\n  }\n\n/* Now handle the originally supplied range. Adjust the final value according\nto the bit length - this means that the same lists of (e.g.) horizontal spaces\ncan be used in all cases. */\n\nif ((options & PCRE2_UTF) == 0 && end > MAX_NON_UTF_CHAR)\n  end = MAX_NON_UTF_CHAR;\n\nif (start > cb->class_range_start && end < cb->class_range_end) return n8;\n\n/* Use the bitmap for characters < 256. Otherwise use extra data.*/\n\nfor (c = start; c <= classbits_end; c++)\n  {\n  /* Regardless of start, c will always be <= 255. */\n  SETBIT(classbits, c);\n  n8++;\n  }\n\n#ifdef SUPPORT_WIDE_CHARS\nif (start <= 0xff) start = 0xff + 1;\n\nif (end >= start)\n  {\n  PCRE2_UCHAR *uchardata = *uchardptr;\n\n#ifdef SUPPORT_UNICODE\n  if ((options & PCRE2_UTF) != 0)\n    {\n    if (start < end)\n      {\n      *uchardata++ = XCL_RANGE;\n      uchardata += PRIV(ord2utf)(start, uchardata);\n      uchardata += PRIV(ord2utf)(end, uchardata);\n      }\n    else if (start == end)\n      {\n      *uchardata++ = XCL_SINGLE;\n      uchardata += PRIV(ord2utf)(start, uchardata);\n      }\n    }\n  else\n#endif  /* SUPPORT_UNICODE */\n\n  /* Without UTF support, character values are constrained by the bit length,\n  and can only be > 256 for 16-bit and 32-bit libraries. */\n\n#if PCRE2_CODE_UNIT_WIDTH == 8\n    {}\n#else\n  if (start < end)\n    {\n    *uchardata++ = XCL_RANGE;\n    *uchardata++ = start;\n    *uchardata++ = end;\n    }\n  else if (start == end)\n    {\n    *uchardata++ = XCL_SINGLE;\n    *uchardata++ = start;\n    }\n#endif  /* PCRE2_CODE_UNIT_WIDTH == 8 */\n  *uchardptr = uchardata;   /* Updata extra data pointer */\n  }\n#else  /* SUPPORT_WIDE_CHARS */\n  (void)uchardptr;          /* Avoid compiler warning */\n#endif /* SUPPORT_WIDE_CHARS */\n\nreturn n8;    /* Number of 8-bit characters */\n}\n\n\n\n#ifdef SUPPORT_UNICODE\n/*************************************************\n* Add a list of characters to a class (internal) *\n*************************************************/\n\n/* This function is used for adding a list of case-equivalent characters to a\nclass when in UTF mode. This function is called only from within\nadd_to_class_internal(), with which it is mutually recursive.\n\nArguments:\n  classbits     the bit map for characters < 256\n  uchardptr     points to the pointer for extra data\n  options       the options word\n  cb            contains pointers to tables etc.\n  p             points to row of 32-bit values, terminated by NOTACHAR\n  except        character to omit; this is used when adding lists of\n                  case-equivalent characters to avoid including the one we\n                  already know about\n\nReturns:        the number of < 256 characters added\n                the pointer to extra data is updated\n*/\n\nstatic unsigned int\nadd_list_to_class_internal(uint8_t *classbits, PCRE2_UCHAR **uchardptr,\n  uint32_t options, compile_block *cb, const uint32_t *p, unsigned int except)\n{\nunsigned int n8 = 0;\nwhile (p\u00dd0\u00a8 < NOTACHAR)\n  {\n  unsigned int n = 0;\n  if (p\u00dd0\u00a8 != except)\n    {\n    while(p\u00ddn+1\u00a8 == p\u00dd0\u00a8 + n + 1) n++;\n    n8 += add_to_class_internal(classbits, uchardptr, options, cb, p\u00dd0\u00a8, p\u00ddn\u00a8);\n    }\n  p += n + 1;\n  }\nreturn n8;\n}\n#endif\n\n\n\n/*************************************************\n*   External entry point for add range to class  *\n*************************************************/\n\n/* This function sets the overall range so that the internal functions can try\nto avoid duplication when handling case-independence.\n\nArguments:\n  classbits     the bit map for characters < 256\n  uchardptr     points to the pointer for extra data\n  options       the options word\n  cb            compile data\n  start         start of range character\n  end           end of range character\n\nReturns:        the number of < 256 characters added\n                the pointer to extra data is updated\n*/\n\nstatic unsigned int\nadd_to_class(uint8_t *classbits, PCRE2_UCHAR **uchardptr, uint32_t options,\n  compile_block *cb, uint32_t start, uint32_t end)\n{\ncb->class_range_start = start;\ncb->class_range_end = end;\nreturn add_to_class_internal(classbits, uchardptr, options, cb, start, end);\n}\n\n\n/*************************************************\n*   External entry point for add list to class   *\n*************************************************/\n\n/* This function is used for adding a list of horizontal or vertical whitespace\ncharacters to a class. The list must be in order so that ranges of characters\ncan be detected and handled appropriately. This function sets the overall range\nso that the internal functions can try to avoid duplication when handling\ncase-independence.\n\nArguments:\n  classbits     the bit map for characters < 256\n  uchardptr     points to the pointer for extra data\n  options       the options word\n  cb            contains pointers to tables etc.\n  p             points to row of 32-bit values, terminated by NOTACHAR\n  except        character to omit; this is used when adding lists of\n                  case-equivalent characters to avoid including the one we\n                  already know about\n\nReturns:        the number of < 256 characters added\n                the pointer to extra data is updated\n*/\n\nstatic unsigned int\nadd_list_to_class(uint8_t *classbits, PCRE2_UCHAR **uchardptr, uint32_t options,\n  compile_block *cb, const uint32_t *p, unsigned int except)\n{\nunsigned int n8 = 0;\nwhile (p\u00dd0\u00a8 < NOTACHAR)\n  {\n  unsigned int n = 0;\n  if (p\u00dd0\u00a8 != except)\n    {\n    while(p\u00ddn+1\u00a8 == p\u00dd0\u00a8 + n + 1) n++;\n    cb->class_range_start = p\u00dd0\u00a8;\n    cb->class_range_end = p\u00ddn\u00a8;\n    n8 += add_to_class_internal(classbits, uchardptr, options, cb, p\u00dd0\u00a8, p\u00ddn\u00a8);\n    }\n  p += n + 1;\n  }\nreturn n8;\n}\n\n\n\n/*************************************************\n*    Add characters not in a list to a class     *\n*************************************************/\n\n/* This function is used for adding the complement of a list of horizontal or\nvertical whitespace to a class. The list must be in order.\n\nArguments:\n  classbits     the bit map for characters < 256\n  uchardptr     points to the pointer for extra data\n  options       the options word\n  cb            contains pointers to tables etc.\n  p             points to row of 32-bit values, terminated by NOTACHAR\n\nReturns:        the number of < 256 characters added\n                the pointer to extra data is updated\n*/\n\nstatic unsigned int\nadd_not_list_to_class(uint8_t *classbits, PCRE2_UCHAR **uchardptr,\n  uint32_t options, compile_block *cb, const uint32_t *p)\n{\nBOOL utf = (options & PCRE2_UTF) != 0;\nunsigned int n8 = 0;\nif (p\u00dd0\u00a8 > 0)\n  n8 += add_to_class(classbits, uchardptr, options, cb, 0, p\u00dd0\u00a8 - 1);\nwhile (p\u00dd0\u00a8 < NOTACHAR)\n  {\n  while (p\u00dd1\u00a8 == p\u00dd0\u00a8 + 1) p++;\n  n8 += add_to_class(classbits, uchardptr, options, cb, p\u00dd0\u00a8 + 1,\n    (p\u00dd1\u00a8 == NOTACHAR) ? (utf ? 0x10ffffu : 0xffffffffu) : p\u00dd1\u00a8 - 1);\n  p++;\n  }\nreturn n8;\n}\n\n\n\n/*************************************************\n*    Find details of duplicate group names       *\n*************************************************/\n\n/* This is called from compile_branch() when it needs to know the index and\ncount of duplicates in the names table when processing named backreferences,\neither directly, or as conditions.\n\nArguments:\n  name          points to the name\n  length        the length of the name\n  indexptr      where to put the index\n  countptr      where to put the count of duplicates\n  errorcodeptr  where to put an error code\n  cb            the compile block\n\nReturns:        TRUE if OK, FALSE if not, error code set\n*/\n\nstatic BOOL\nfind_dupname_details(PCRE2_SPTR name, uint32_t length, int *indexptr,\n  int *countptr, int *errorcodeptr, compile_block *cb)\n{\nuint32_t i, groupnumber;\nint count;\nPCRE2_UCHAR *slot = cb->name_table;\n\n/* Find the first entry in the table */\n\nfor (i = 0; i < cb->names_found; i++)\n  {\n  if (PRIV(strncmp)(name, slot+IMM2_SIZE, length) == 0 &&\n      slot\u00ddIMM2_SIZE+length\u00a8 == 0) break;\n  slot += cb->name_entry_size;\n  }\n\n/* This should not occur, because this function is called only when we know we\nhave duplicate names. Give an internal error. */\n\nif (i >= cb->names_found)\n  {\n  *errorcodeptr = ERR53;\n  cb->erroroffset = name - cb->start_pattern;\n  return FALSE;\n  }\n\n/* Record the index and then see how many duplicates there are, updating the\nbackref map and maximum back reference as we do. */\n\n*indexptr = i;\ncount = 0;\n\nfor (;;)\n  {\n  count++;\n  groupnumber = GET2(slot,0);\n  cb->backref_map |= (groupnumber < 32)? (1u << groupnumber) : 1;\n  if (groupnumber > cb->top_backref) cb->top_backref = groupnumber;\n  if (++i >= cb->names_found) break;\n  slot += cb->name_entry_size;\n  if (PRIV(strncmp)(name, slot+IMM2_SIZE, length) != 0 ||\n    (slot+IMM2_SIZE)\u00ddlength\u00a8 != 0) break;\n  }\n\n*countptr = count;\nreturn TRUE;\n}\n\n\n\n/*************************************************\n*           Compile one branch                   *\n*************************************************/\n\n/* Scan the parsed pattern, compiling it into the a vector of PCRE2_UCHAR. If\nthe options are changed during the branch, the pointer is used to change the\nexternal options bits. This function is used during the pre-compile phase when\nwe are trying to find out the amount of memory needed, as well as during the\nreal compile phase. The value of lengthptr distinguishes the two phases.\n\nArguments:\n  optionsptr        pointer to the option bits\n  codeptr           points to the pointer to the current code point\n  pptrptr           points to the current parsed pattern pointer\n  errorcodeptr      points to error code variable\n  firstcuptr        place to put the first required code unit\n  firstcuflagsptr   place to put the first code unit flags, or a negative number\n  reqcuptr          place to put the last required code unit\n  reqcuflagsptr     place to put the last required code unit flags, or a negative number\n  bcptr             points to current branch chain\n  cb                contains pointers to tables etc.\n  lengthptr         NULL during the real compile phase\n                    points to length accumulator during pre-compile phase\n\nReturns:            0 There's been an error, *errorcodeptr is non-zero\n                   +1 Success, this branch must match at least one character\n                   -1 Success, this branch may match an empty string\n*/\n\nstatic int\ncompile_branch(uint32_t *optionsptr, PCRE2_UCHAR **codeptr, uint32_t **pptrptr,\n  int *errorcodeptr, uint32_t *firstcuptr, int32_t *firstcuflagsptr,\n  uint32_t *reqcuptr, int32_t *reqcuflagsptr, branch_chain *bcptr,\n  compile_block *cb, PCRE2_SIZE *lengthptr)\n{\nint bravalue = 0;\nint okreturn = -1;\nint group_return = 0;\nuint32_t repeat_min = 0, repeat_max = 0;      /* To please picky compilers */\nuint32_t greedy_default, greedy_non_default;\nuint32_t repeat_type, op_type;\nuint32_t options = *optionsptr;               /* May change dynamically */\nuint32_t firstcu, reqcu;\nuint32_t zeroreqcu, zerofirstcu;\nuint32_t escape;\nuint32_t *pptr = *pptrptr;\nuint32_t meta, meta_arg;\nint32_t firstcuflags, reqcuflags;\nint32_t zeroreqcuflags, zerofirstcuflags;\nint32_t req_caseopt, reqvary, tempreqvary;\nPCRE2_SIZE offset = 0;\nPCRE2_SIZE length_prevgroup = 0;\nPCRE2_UCHAR *code = *codeptr;\nPCRE2_UCHAR *last_code = code;\nPCRE2_UCHAR *orig_code = code;\nPCRE2_UCHAR *tempcode;\nPCRE2_UCHAR *previous = NULL;\nPCRE2_UCHAR op_previous;\nBOOL groupsetfirstcu = FALSE;\nBOOL had_accept = FALSE;\nBOOL matched_char = FALSE;\nBOOL previous_matched_char = FALSE;\nBOOL reset_caseful = FALSE;\nconst uint8_t *cbits = cb->cbits;\nuint8_t classbits\u00dd32\u00a8;\n\n/* We can fish out the UTF setting once and for all into a BOOL, but we must\nnot do this for other options (e.g. PCRE2_EXTENDED) because they may change\ndynamically as we process the pattern. */\n\n#ifdef SUPPORT_UNICODE\nBOOL utf = (options & PCRE2_UTF) != 0;\nBOOL ucp = (options & PCRE2_UCP) != 0;\n#else  /* No Unicode support */\nBOOL utf = FALSE;\n#endif\n\n/* Helper variables for OP_XCLASS opcode (for characters > 255). We define\nclass_uchardata always so that it can be passed to add_to_class() always,\nthough it will not be used in non-UTF 8-bit cases. This avoids having to supply\nalternative calls for the different cases. */\n\nPCRE2_UCHAR *class_uchardata;\n#ifdef SUPPORT_WIDE_CHARS\nBOOL xclass;\nPCRE2_UCHAR *class_uchardata_base;\n#endif\n\n/* Set up the default and non-default settings for greediness */\n\ngreedy_default = ((options & PCRE2_UNGREEDY) != 0);\ngreedy_non_default = greedy_default \u00ac 1;\n\n/* Initialize no first unit, no required unit. REQ_UNSET means \"no char\nmatching encountered yet\". It gets changed to REQ_NONE if we hit something that\nmatches a non-fixed first unit; reqcu just remains unset if we never find one.\n\nWhen we hit a repeat whose minimum is zero, we may have to adjust these values\nto take the zero repeat into account. This is implemented by setting them to\nzerofirstcu and zeroreqcu when such a repeat is encountered. The individual\nitem types that can be repeated set these backoff variables appropriately. */\n\nfirstcu = reqcu = zerofirstcu = zeroreqcu = 0;\nfirstcuflags = reqcuflags = zerofirstcuflags = zeroreqcuflags = REQ_UNSET;\n\n/* The variable req_caseopt contains either the REQ_CASELESS value or zero,\naccording to the current setting of the caseless flag. The REQ_CASELESS value\nleaves the lower 28 bit empty. It is added into the firstcu or reqcu variables\nto record the case status of the value. This is used only for ASCII characters.\n*/\n\nreq_caseopt = ((options & PCRE2_CASELESS) != 0)? REQ_CASELESS:0;\n\n/* Switch on next META item until the end of the branch */\n\nfor (;; pptr++)\n  {\n#ifdef SUPPORT_WIDE_CHARS\n  BOOL xclass_has_prop;\n#endif\n  BOOL negate_class;\n  BOOL should_flip_negation;\n  BOOL match_all_or_no_wide_chars;\n  BOOL possessive_quantifier;\n  BOOL note_group_empty;\n  int class_has_8bitchar;\n  int i;\n  uint32_t mclength;\n  uint32_t skipunits;\n  uint32_t subreqcu, subfirstcu;\n  uint32_t groupnumber;\n  uint32_t verbarglen, verbculen;\n  int32_t subreqcuflags, subfirstcuflags;  /* Must be signed */\n  open_capitem *oc;\n  PCRE2_UCHAR mcbuffer\u00dd8\u00a8;\n\n  /* Get next META item in the pattern and its potential argument. */\n\n  meta = META_CODE(*pptr);\n  meta_arg = META_DATA(*pptr);\n\n  /* If we are in the pre-compile phase, accumulate the length used for the\n  previous cycle of this loop, unless the next item is a quantifier. */\n\n  if (lengthptr != NULL)\n    {\n    if (code > cb->start_workspace + cb->workspace_size -\n        WORK_SIZE_SAFETY_MARGIN)                       /* Check for overrun */\n      {\n      *errorcodeptr = (code >= cb->start_workspace + cb->workspace_size)?\n        ERR52 : ERR86;\n      return 0;\n      }\n\n    /* There is at least one situation where code goes backwards: this is the\n    case of a zero quantifier after a class (e.g. \u00ddab\u00a8{0}). When the quantifier\n    is processed, the whole class is eliminated. However, it is created first,\n    so we have to allow memory for it. Therefore, don't ever reduce the length\n    at this point. */\n\n    if (code < last_code) code = last_code;\n\n    /* If the next thing is not a quantifier, we add the length of the previous\n    item into the total, and reset the code pointer to the start of the\n    workspace. Otherwise leave the previous item available to be quantified. */\n\n    if (meta < META_ASTERISK || meta > META_MINMAX_QUERY)\n      {\n      if (OFLOW_MAX - *lengthptr < (PCRE2_SIZE)(code - orig_code))\n        {\n        *errorcodeptr = ERR20;   /* Integer overflow */\n        return 0;\n        }\n      *lengthptr += (PCRE2_SIZE)(code - orig_code);\n      if (*lengthptr > MAX_PATTERN_SIZE)\n        {\n        *errorcodeptr = ERR20;   /* Pattern is too large */\n        return 0;\n        }\n      code = orig_code;\n      }\n\n    /* Remember where this code item starts so we can catch the \"backwards\"\n    case above next time round. */\n\n    last_code = code;\n    }\n\n  /* Process the next parsed pattern item. If it is not a quantifier, remember\n  where it starts so that it can be quantified when a quantifier follows.\n  Checking for the legality of quantifiers happens in parse_regex(), except for\n  a quantifier after an assertion that is a condition. */\n\n  if (meta < META_ASTERISK || meta > META_MINMAX_QUERY)\n    {\n    previous = code;\n    if (matched_char && !had_accept) okreturn = 1;\n    }\n\n  previous_matched_char = matched_char;\n  matched_char = FALSE;\n  note_group_empty = FALSE;\n  skipunits = 0;         /* Default value for most subgroups */\n\n  switch(meta)\n    {\n    /* ===================================================================*/\n    /* The branch terminates at pattern end or | or ) */\n\n    case META_END:\n    case META_ALT:\n    case META_KET:\n    *firstcuptr = firstcu;\n    *firstcuflagsptr = firstcuflags;\n    *reqcuptr = reqcu;\n    *reqcuflagsptr = reqcuflags;\n    *codeptr = code;\n    *pptrptr = pptr;\n    return okreturn;\n\n\n    /* ===================================================================*/\n    /* Handle single-character metacharacters. In multiline mode, \u00ac disables\n    the setting of any following char as a first character. */\n\n    case META_CIRCUMFLEX:\n    if ((options & PCRE2_MULTILINE) != 0)\n      {\n      if (firstcuflags == REQ_UNSET)\n        zerofirstcuflags = firstcuflags = REQ_NONE;\n      *code++ = OP_CIRCM;\n      }\n    else *code++ = OP_CIRC;\n    break;\n\n    case META_DOLLAR:\n    *code++ = ((options & PCRE2_MULTILINE) != 0)? OP_DOLLM : OP_DOLL;\n    break;\n\n    /* There can never be a first char if '.' is first, whatever happens about\n    repeats. The value of reqcu doesn't change either. */\n\n    case META_DOT:\n    matched_char = TRUE;\n    if (firstcuflags == REQ_UNSET) firstcuflags = REQ_NONE;\n    zerofirstcu = firstcu;\n    zerofirstcuflags = firstcuflags;\n    zeroreqcu = reqcu;\n    zeroreqcuflags = reqcuflags;\n    *code++ = ((options & PCRE2_DOTALL) != 0)? OP_ALLANY: OP_ANY;\n    break;\n\n\n    /* ===================================================================*/\n    /* Empty character classes are allowed if PCRE2_ALLOW_EMPTY_CLASS is set.\n    Otherwise, an initial '\u00a8' is taken as a data character. When empty classes\n    are allowed, \u00dd\u00a8 must always fail, so generate OP_FAIL, whereas \u00dd\u00ac\u00a8 must\n    match any character, so generate OP_ALLANY. */\n\n    case META_CLASS_EMPTY:\n    case META_CLASS_EMPTY_NOT:\n    matched_char = TRUE;\n    *code++ = (meta == META_CLASS_EMPTY_NOT)? OP_ALLANY : OP_FAIL;\n    if (firstcuflags == REQ_UNSET) firstcuflags = REQ_NONE;\n    zerofirstcu = firstcu;\n    zerofirstcuflags = firstcuflags;\n    break;\n\n\n    /* ===================================================================*/\n    /* Non-empty character class. If the included characters are all < 256, we\n    build a 32-byte bitmap of the permitted characters, except in the special\n    case where there is only one such character. For negated classes, we build\n    the map as usual, then invert it at the end. However, we use a different\n    opcode so that data characters > 255 can be handled correctly.\n\n    If the class contains characters outside the 0-255 range, a different\n    opcode is compiled. It may optionally have a bit map for characters < 256,\n    but those above are are explicitly listed afterwards. A flag code unit\n    tells whether the bitmap is present, and whether this is a negated class or\n    not. */\n\n    case META_CLASS_NOT:\n    case META_CLASS:\n    matched_char = TRUE;\n    negate_class = meta == META_CLASS_NOT;\n\n    /* We can optimize the case of a single character in a class by generating\n    OP_CHAR or OP_CHARI if it's positive, or OP_NOT or OP_NOTI if it's\n    negative. In the negative case there can be no first char if this item is\n    first, whatever repeat count may follow. In the case of reqcu, save the\n    previous value for reinstating. */\n\n    /* NOTE: at present this optimization is not effective if the only\n    character in a class in 32-bit, non-UCP mode has its top bit set. */\n\n    if (pptr\u00dd1\u00a8 < META_END && pptr\u00dd2\u00a8 == META_CLASS_END)\n      {\n#ifdef SUPPORT_UNICODE\n      uint32_t d;\n#endif\n      uint32_t c = pptr\u00dd1\u00a8;\n\n      pptr += 2;                 /* Move on to class end */\n      if (meta == META_CLASS)    /* A positive one-char class can be */\n        {                        /* handled as a normal literal character. */\n        meta = c;                /* Set up the character */\n        goto NORMAL_CHAR_SET;\n        }\n\n      /* Handle a negative one-character class */\n\n      zeroreqcu = reqcu;\n      zeroreqcuflags = reqcuflags;\n      if (firstcuflags == REQ_UNSET) firstcuflags = REQ_NONE;\n      zerofirstcu = firstcu;\n      zerofirstcuflags = firstcuflags;\n\n      /* For caseless UTF or UCP mode, check whether this character has more\n      than one other case. If so, generate a special OP_NOTPROP item instead of\n      OP_NOTI. */\n\n#ifdef SUPPORT_UNICODE\n      if ((utf||ucp) && (options & PCRE2_CASELESS) != 0 &&\n          (d = UCD_CASESET(c)) != 0)\n        {\n        *code++ = OP_NOTPROP;\n        *code++ = PT_CLIST;\n        *code++ = d;\n        break;   /* We are finished with this class */\n        }\n#endif\n      /* Char has only one other case, or UCP not available */\n\n      *code++ = ((options & PCRE2_CASELESS) != 0)? OP_NOTI: OP_NOT;\n      code += PUTCHAR(c, code);\n      break;   /* We are finished with this class */\n      }        /* End of 1-char optimization */\n\n    /* Handle character classes that contain more than just one literal\n    character. If there are exactly two characters in a positive class, see if\n    they are case partners. This can be optimized to generate a caseless single\n    character match (which also sets first/required code units if relevant). */\n\n    if (meta == META_CLASS && pptr\u00dd1\u00a8 < META_END && pptr\u00dd2\u00a8 < META_END &&\n        pptr\u00dd3\u00a8 == META_CLASS_END)\n      {\n      uint32_t c = pptr\u00dd1\u00a8;\n\n#ifdef SUPPORT_UNICODE\n      if (UCD_CASESET(c) == 0)\n#endif\n        {\n        uint32_t d;\n\n#ifdef SUPPORT_UNICODE\n        if ((utf || ucp) && c > 127) d = UCD_OTHERCASE(c); else\n#endif\n          {\n#if PCRE2_CODE_UNIT_WIDTH != 8\n          if (c > 255) d = c; else\n#endif\n          d = TABLE_GET(c, cb->fcc, c);\n          }\n\n        if (c != d && pptr\u00dd2\u00a8 == d)\n          {\n          pptr += 3;                 /* Move on to class end */\n          meta = c;\n          if ((options & PCRE2_CASELESS) == 0)\n            {\n            reset_caseful = TRUE;\n            options |= PCRE2_CASELESS;\n            req_caseopt = REQ_CASELESS;\n            }\n          goto CLASS_CASELESS_CHAR;\n          }\n        }\n      }\n\n    /* If a non-extended class contains a negative special such as \\S, we need\n    to flip the negation flag at the end, so that support for characters > 255\n    works correctly (they are all included in the class). An extended class may\n    need to insert specific matching or non-matching code for wide characters.\n    */\n\n    should_flip_negation = match_all_or_no_wide_chars = FALSE;\n\n    /* Extended class (xclass) will be used when characters > 255\n    might match. */\n\n#ifdef SUPPORT_WIDE_CHARS\n    xclass = FALSE;\n    class_uchardata = code + LINK_SIZE + 2;   /* For XCLASS items */\n    class_uchardata_base = class_uchardata;   /* Save the start */\n#endif\n\n    /* For optimization purposes, we track some properties of the class:\n    class_has_8bitchar will be non-zero if the class contains at least one\n    character with a code point less than 256; xclass_has_prop will be TRUE if\n    Unicode property checks are present in the class. */\n\n    class_has_8bitchar = 0;\n#ifdef SUPPORT_WIDE_CHARS\n    xclass_has_prop = FALSE;\n#endif\n\n    /* Initialize the 256-bit (32-byte) bit map to all zeros. We build the map\n    in a temporary bit of memory, in case the class contains fewer than two\n    8-bit characters because in that case the compiled code doesn't use the bit\n    map. */\n\n    memset(classbits, 0, 32 * sizeof(uint8_t));\n\n    /* Process items until META_CLASS_END is reached. */\n\n    while ((meta = *(++pptr)) != META_CLASS_END)\n      {\n      /* Handle POSIX classes such as \u00dd:alpha:\u00a8 etc. */\n\n      if (meta == META_POSIX || meta == META_POSIX_NEG)\n        {\n        BOOL local_negate = (meta == META_POSIX_NEG);\n        int posix_class = *(++pptr);\n        int taboffset, tabopt;\n        uint8_t pbits\u00dd32\u00a8;\n\n        should_flip_negation = local_negate;  /* Note negative special */\n\n        /* If matching is caseless, upper and lower are converted to alpha.\n        This relies on the fact that the class table starts with alpha,\n        lower, upper as the first 3 entries. */\n\n        if ((options & PCRE2_CASELESS) != 0 && posix_class <= 2)\n          posix_class = 0;\n\n        /* When PCRE2_UCP is set, some of the POSIX classes are converted to\n        different escape sequences that use Unicode properties \\p or \\P.\n        Others that are not available via \\p or \\P have to generate\n        XCL_PROP/XCL_NOTPROP directly, which is done here. */\n\n#ifdef SUPPORT_UNICODE\n        if ((options & PCRE2_UCP) != 0) switch(posix_class)\n          {\n          case PC_GRAPH:\n          case PC_PRINT:\n          case PC_PUNCT:\n          *class_uchardata++ = local_negate? XCL_NOTPROP : XCL_PROP;\n          *class_uchardata++ = (PCRE2_UCHAR)\n            ((posix_class == PC_GRAPH)? PT_PXGRAPH :\n             (posix_class == PC_PRINT)? PT_PXPRINT : PT_PXPUNCT);\n          *class_uchardata++ = 0;\n          xclass_has_prop = TRUE;\n          goto CONTINUE_CLASS;\n\n          /* For the other POSIX classes (ascii, xdigit) we are going to\n          fall through to the non-UCP case and build a bit map for\n          characters with code points less than 256. However, if we are in\n          a negated POSIX class, characters with code points greater than\n          255 must either all match or all not match, depending on whether\n          the whole class is not or is negated. For example, for\n          \u00dd\u00dd:\u00acascii:\u00a8... they must all match, whereas for \u00dd\u00ac\u00dd:\u00acxdigit:\u00a8...\n          they must not.\n\n          In the special case where there are no xclass items, this is\n          automatically handled by the use of OP_CLASS or OP_NCLASS, but an\n          explicit range is needed for OP_XCLASS. Setting a flag here\n          causes the range to be generated later when it is known that\n          OP_XCLASS is required. In the 8-bit library this is relevant only in\n          utf mode, since no wide characters can exist otherwise. */\n\n          default:\n#if PCRE2_CODE_UNIT_WIDTH == 8\n          if (utf)\n#endif\n          match_all_or_no_wide_chars |= local_negate;\n          break;\n          }\n#endif  /* SUPPORT_UNICODE */\n\n        /* In the non-UCP case, or when UCP makes no difference, we build the\n        bit map for the POSIX class in a chunk of local store because we may\n        be adding and subtracting from it, and we don't want to subtract bits\n        that may be in the main map already. At the end we or the result into\n        the bit map that is being built. */\n\n        posix_class *= 3;\n\n        /* Copy in the first table (always present) */\n\n        memcpy(pbits, cbits + posix_class_maps\u00ddposix_class\u00a8,\n          32 * sizeof(uint8_t));\n\n        /* If there is a second table, add or remove it as required. */\n\n        taboffset = posix_class_maps\u00ddposix_class + 1\u00a8;\n        tabopt = posix_class_maps\u00ddposix_class + 2\u00a8;\n\n        if (taboffset >= 0)\n          {\n          if (tabopt >= 0)\n            for (i = 0; i < 32; i++) pbits\u00ddi\u00a8 |= cbits\u00dd(int)i + taboffset\u00a8;\n          else\n            for (i = 0; i < 32; i++) pbits\u00ddi\u00a8 &= ~cbits\u00dd(int)i + taboffset\u00a8;\n          }\n\n        /* Now see if we need to remove any special characters. An option\n        value of 1 removes vertical space and 2 removes underscore. */\n\n        if (tabopt < 0) tabopt = -tabopt;\n        if (tabopt == 1) pbits\u00dd1\u00a8 &= ~0x3c;\n          else if (tabopt == 2) pbits\u00dd11\u00a8 &= 0x7f;\n\n        /* Add the POSIX table or its complement into the main table that is\n        being built and we are done. */\n\n        if (local_negate)\n          for (i = 0; i < 32; i++) classbits\u00ddi\u00a8 |= ~pbits\u00ddi\u00a8;\n        else\n          for (i = 0; i < 32; i++) classbits\u00ddi\u00a8 |= pbits\u00ddi\u00a8;\n\n        /* Every class contains at least one < 256 character. */\n\n        class_has_8bitchar = 1;\n        goto CONTINUE_CLASS;    /* End of POSIX handling */\n        }\n\n      /* Other than POSIX classes, the only items we should encounter are\n      \\d-type escapes and literal characters (possibly as ranges). */\n\n      if (meta == META_BIGVALUE)\n        {\n        meta = *(++pptr);\n        goto CLASS_LITERAL;\n        }\n\n      /* Any other non-literal must be an escape */\n\n      if (meta >= META_END)\n        {\n        if (META_CODE(meta) != META_ESCAPE)\n          {\n#ifdef DEBUG_SHOW_PARSED\n          fprintf(stderr, \"** Unrecognized parsed pattern item 0x%.8x \"\n                          \"in character class\\n\", meta);\n#endif\n          *errorcodeptr = ERR89;  /* Internal error - unrecognized. */\n          return 0;\n          }\n        escape = META_DATA(meta);\n\n        /* Every class contains at least one < 256 character. */\n\n        class_has_8bitchar++;\n\n        switch(escape)\n          {\n          case ESC_d:\n          for (i = 0; i < 32; i++) classbits\u00ddi\u00a8 |= cbits\u00ddi+cbit_digit\u00a8;\n          break;\n\n          case ESC_D:\n          should_flip_negation = TRUE;\n          for (i = 0; i < 32; i++) classbits\u00ddi\u00a8 |= ~cbits\u00ddi+cbit_digit\u00a8;\n          break;\n\n          case ESC_w:\n          for (i = 0; i < 32; i++) classbits\u00ddi\u00a8 |= cbits\u00ddi+cbit_word\u00a8;\n          break;\n\n          case ESC_W:\n          should_flip_negation = TRUE;\n          for (i = 0; i < 32; i++) classbits\u00ddi\u00a8 |= ~cbits\u00ddi+cbit_word\u00a8;\n          break;\n\n          /* Perl 5.004 onwards omitted VT from \\s, but restored it at Perl\n          5.18. Before PCRE 8.34, we had to preserve the VT bit if it was\n          previously set by something earlier in the character class.\n          Luckily, the value of CHAR_VT is 0x0b in both ASCII and EBCDIC, so\n          we could just adjust the appropriate bit. From PCRE 8.34 we no\n          longer treat \\s and \\S specially. */\n\n          case ESC_s:\n          for (i = 0; i < 32; i++) classbits\u00ddi\u00a8 |= cbits\u00ddi+cbit_space\u00a8;\n          break;\n\n          case ESC_S:\n          should_flip_negation = TRUE;\n          for (i = 0; i < 32; i++) classbits\u00ddi\u00a8 |= ~cbits\u00ddi+cbit_space\u00a8;\n          break;\n\n          /* When adding the horizontal or vertical space lists to a class, or\n          their complements, disable PCRE2_CASELESS, because it justs wastes\n          time, and in the \"not-x\" UTF cases can create unwanted duplicates in\n          the XCLASS list (provoked by characters that have more than one other\n          case and by both cases being in the same \"not-x\" sublist). */\n\n          case ESC_h:\n          (void)add_list_to_class(classbits, &class_uchardata,\n            options & ~PCRE2_CASELESS, cb, PRIV(hspace_list), NOTACHAR);\n          break;\n\n          case ESC_H:\n          (void)add_not_list_to_class(classbits, &class_uchardata,\n            options & ~PCRE2_CASELESS, cb, PRIV(hspace_list));\n          break;\n\n          case ESC_v:\n          (void)add_list_to_class(classbits, &class_uchardata,\n            options & ~PCRE2_CASELESS, cb, PRIV(vspace_list), NOTACHAR);\n          break;\n\n          case ESC_V:\n          (void)add_not_list_to_class(classbits, &class_uchardata,\n            options & ~PCRE2_CASELESS, cb, PRIV(vspace_list));\n          break;\n\n          /* If Unicode is not supported, \\P and \\p are not allowed and are\n          faulted at parse time, so will never appear here. */\n\n#ifdef SUPPORT_UNICODE\n          case ESC_p:\n          case ESC_P:\n            {\n            uint32_t ptype = *(++pptr) >> 16;\n            uint32_t pdata = *pptr & 0xffff;\n            *class_uchardata++ = (escape == ESC_p)? XCL_PROP : XCL_NOTPROP;\n            *class_uchardata++ = ptype;\n            *class_uchardata++ = pdata;\n            xclass_has_prop = TRUE;\n            class_has_8bitchar--;                /* Undo! */\n            }\n          break;\n#endif\n          }\n\n        goto CONTINUE_CLASS;\n        }  /* End handling \\d-type escapes */\n\n      /* A literal character may be followed by a range meta. At parse time\n      there are checks for out-of-order characters, for ranges where the two\n      characters are equal, and for hyphens that cannot indicate a range. At\n      this point, therefore, no checking is needed. */\n\n      else\n        {\n        uint32_t c, d;\n\n        CLASS_LITERAL:\n        c = d = meta;\n\n        /* Remember if \\r or \\n were explicitly used */\n\n        if (c == CHAR_CR || c == CHAR_NL) cb->external_flags |= PCRE2_HASCRORLF;\n\n        /* Process a character range */\n\n        if (pptr\u00dd1\u00a8 == META_RANGE_LITERAL || pptr\u00dd1\u00a8 == META_RANGE_ESCAPED)\n          {\n#ifdef EBCDIC\n          BOOL range_is_literal = (pptr\u00dd1\u00a8 == META_RANGE_LITERAL);\n#endif\n          pptr += 2;\n          d = *pptr;\n          if (d == META_BIGVALUE) d = *(++pptr);\n\n          /* Remember an explicit \\r or \\n, and add the range to the class. */\n\n          if (d == CHAR_CR || d == CHAR_NL) cb->external_flags |= PCRE2_HASCRORLF;\n\n          /* In an EBCDIC environment, Perl treats alphabetic ranges specially\n          because there are holes in the encoding, and simply using the range\n          A-Z (for example) would include the characters in the holes. This\n          applies only to literal ranges; \u00dd\\xC1-\\xE9\u00a8 is different to \u00ddA-Z\u00a8. */\n\n#ifdef EBCDIC\n          if (range_is_literal &&\n               (cb->ctypes\u00ddc\u00a8 & ctype_letter) != 0 &&\n               (cb->ctypes\u00ddd\u00a8 & ctype_letter) != 0 &&\n               (c <= CHAR_z) == (d <= CHAR_z))\n            {\n            uint32_t uc = (d <= CHAR_z)? 0 : 64;\n            uint32_t C = c - uc;\n            uint32_t D = d - uc;\n\n            if (C <= CHAR_i)\n              {\n              class_has_8bitchar +=\n                add_to_class(classbits, &class_uchardata, options, cb, C + uc,\n                  ((D < CHAR_i)? D : CHAR_i) + uc);\n              C = CHAR_j;\n              }\n\n            if (C <= D && C <= CHAR_r)\n              {\n              class_has_8bitchar +=\n                add_to_class(classbits, &class_uchardata, options, cb, C + uc,\n                  ((D < CHAR_r)? D : CHAR_r) + uc);\n              C = CHAR_s;\n              }\n\n            if (C <= D)\n              {\n              class_has_8bitchar +=\n                add_to_class(classbits, &class_uchardata, options, cb, C + uc,\n                  D + uc);\n              }\n            }\n          else\n#endif\n          /* Not an EBCDIC special range */\n\n          class_has_8bitchar +=\n            add_to_class(classbits, &class_uchardata, options, cb, c, d);\n          goto CONTINUE_CLASS;   /* Go get the next char in the class */\n          }  /* End of range handling */\n\n\n        /* Handle a single character. */\n\n        class_has_8bitchar +=\n          add_to_class(classbits, &class_uchardata, options, cb, meta, meta);\n        }\n\n      /* Continue to the next item in the class. */\n\n      CONTINUE_CLASS:\n\n#ifdef SUPPORT_WIDE_CHARS\n      /* If any wide characters or Unicode properties have been encountered,\n      set xclass = TRUE. Then, in the pre-compile phase, accumulate the length\n      of the extra data and reset the pointer. This is so that very large\n      classes that contain a zillion wide characters or Unicode property tests\n      do not overwrite the workspace (which is on the stack). */\n\n      if (class_uchardata > class_uchardata_base)\n        {\n        xclass = TRUE;\n        if (lengthptr != NULL)\n          {\n          *lengthptr += class_uchardata - class_uchardata_base;\n          class_uchardata = class_uchardata_base;\n          }\n        }\n#endif\n\n      continue;  /* Needed to avoid error when not supporting wide chars */\n      }   /* End of main class-processing loop */\n\n    /* If this class is the first thing in the branch, there can be no first\n    char setting, whatever the repeat count. Any reqcu setting must remain\n    unchanged after any kind of repeat. */\n\n    if (firstcuflags == REQ_UNSET) firstcuflags = REQ_NONE;\n    zerofirstcu = firstcu;\n    zerofirstcuflags = firstcuflags;\n    zeroreqcu = reqcu;\n    zeroreqcuflags = reqcuflags;\n\n    /* If there are characters with values > 255, or Unicode property settings\n    (\\p or \\P), we have to compile an extended class, with its own opcode,\n    unless there were no property settings and there was a negated special such\n    as \\S in the class, and PCRE2_UCP is not set, because in that case all\n    characters > 255 are in or not in the class, so any that were explicitly\n    given as well can be ignored.\n\n    In the UCP case, if certain negated POSIX classes (\u00dd:\u00acascii:\u00a8 or\n    \u00dd\u00ac:xdigit:\u00a8) were present in a class, we either have to match or not match\n    all wide characters (depending on whether the whole class is or is not\n    negated). This requirement is indicated by match_all_or_no_wide_chars being\n    true. We do this by including an explicit range, which works in both cases.\n    This applies only in UTF and 16-bit and 32-bit non-UTF modes, since there\n    cannot be any wide characters in 8-bit non-UTF mode.\n\n    When there *are* properties in a positive UTF-8 or any 16-bit or 32_bit\n    class where \\S etc is present without PCRE2_UCP, causing an extended class\n    to be compiled, we make sure that all characters > 255 are included by\n    forcing match_all_or_no_wide_chars to be true.\n\n    If, when generating an xclass, there are no characters < 256, we can omit\n    the bitmap in the actual compiled code. */\n\n#ifdef SUPPORT_WIDE_CHARS  /* Defined for 16/32 bits, or 8-bit with Unicode */\n    if (xclass && (\n#ifdef SUPPORT_UNICODE\n        (options & PCRE2_UCP) != 0 ||\n#endif\n        xclass_has_prop || !should_flip_negation))\n      {\n      if (match_all_or_no_wide_chars || (\n#if PCRE2_CODE_UNIT_WIDTH == 8\n           utf &&\n#endif\n           should_flip_negation && !negate_class && (options & PCRE2_UCP) == 0))\n        {\n        *class_uchardata++ = XCL_RANGE;\n        if (utf)   /* Will always be utf in the 8-bit library */\n          {\n          class_uchardata += PRIV(ord2utf)(0x100, class_uchardata);\n          class_uchardata += PRIV(ord2utf)(MAX_UTF_CODE_POINT, class_uchardata);\n          }\n        else       /* Can only happen for the 16-bit & 32-bit libraries */\n          {\n#if PCRE2_CODE_UNIT_WIDTH == 16\n          *class_uchardata++ = 0x100;\n          *class_uchardata++ = 0xffffu;\n#elif PCRE2_CODE_UNIT_WIDTH == 32\n          *class_uchardata++ = 0x100;\n          *class_uchardata++ = 0xffffffffu;\n#endif\n          }\n        }\n      *class_uchardata++ = XCL_END;    /* Marks the end of extra data */\n      *code++ = OP_XCLASS;\n      code += LINK_SIZE;\n      *code = negate_class? XCL_NOT:0;\n      if (xclass_has_prop) *code |= XCL_HASPROP;\n\n      /* If the map is required, move up the extra data to make room for it;\n      otherwise just move the code pointer to the end of the extra data. */\n\n      if (class_has_8bitchar > 0)\n        {\n        *code++ |= XCL_MAP;\n        (void)memmove(code + (32 / sizeof(PCRE2_UCHAR)), code,\n          CU2BYTES(class_uchardata - code));\n        if (negate_class && !xclass_has_prop)\n          {\n          /* Using 255 \u00ac instead of ~ avoids clang sanitize warning. */\n          for (i = 0; i < 32; i++) classbits\u00ddi\u00a8 = 255 \u00ac classbits\u00ddi\u00a8;\n          }\n        memcpy(code, classbits, 32);\n        code = class_uchardata + (32 / sizeof(PCRE2_UCHAR));\n        }\n      else code = class_uchardata;\n\n      /* Now fill in the complete length of the item */\n\n      PUT(previous, 1, (int)(code - previous));\n      break;   /* End of class handling */\n      }\n#endif  /* SUPPORT_WIDE_CHARS */\n\n    /* If there are no characters > 255, or they are all to be included or\n    excluded, set the opcode to OP_CLASS or OP_NCLASS, depending on whether the\n    whole class was negated and whether there were negative specials such as \\S\n    (non-UCP) in the class. Then copy the 32-byte map into the code vector,\n    negating it if necessary. */\n\n    *code++ = (negate_class == should_flip_negation) ? OP_CLASS : OP_NCLASS;\n    if (lengthptr == NULL)    /* Save time in the pre-compile phase */\n      {\n      if (negate_class)\n        {\n       /* Using 255 \u00ac instead of ~ avoids clang sanitize warning. */\n       for (i = 0; i < 32; i++) classbits\u00ddi\u00a8 = 255 \u00ac classbits\u00ddi\u00a8;\n       }\n      memcpy(code, classbits, 32);\n      }\n    code += 32 / sizeof(PCRE2_UCHAR);\n    break;  /* End of class processing */\n\n\n    /* ===================================================================*/\n    /* Deal with (*VERB)s. */\n\n    /* Check for open captures before ACCEPT and close those that are within\n    the same assertion level, also converting ACCEPT to ASSERT_ACCEPT in an\n    assertion. In the first pass, just accumulate the length required;\n    otherwise hitting (*ACCEPT) inside many nested parentheses can cause\n    workspace overflow. Do not set firstcu after *ACCEPT. */\n\n    case META_ACCEPT:\n    cb->had_accept = had_accept = TRUE;\n    for (oc = cb->open_caps;\n         oc != NULL && oc->assert_depth >= cb->assert_depth;\n         oc = oc->next)\n      {\n      if (lengthptr != NULL)\n        {\n        *lengthptr += CU2BYTES(1) + IMM2_SIZE;\n        }\n      else\n        {\n        *code++ = OP_CLOSE;\n        PUT2INC(code, 0, oc->number);\n        }\n      }\n    *code++ = (cb->assert_depth > 0)? OP_ASSERT_ACCEPT : OP_ACCEPT;\n    if (firstcuflags == REQ_UNSET) firstcuflags = REQ_NONE;\n    break;\n\n    case META_PRUNE:\n    case META_SKIP:\n    cb->had_pruneorskip = TRUE;\n    /* Fall through */\n    case META_COMMIT:\n    case META_FAIL:\n    *code++ = verbops\u00dd(meta - META_MARK) >> 16\u00a8;\n    break;\n\n    case META_THEN:\n    cb->external_flags |= PCRE2_HASTHEN;\n    *code++ = OP_THEN;\n    break;\n\n    /* Handle verbs with arguments. Arguments can be very long, especially in\n    16- and 32-bit modes, and can overflow the workspace in the first pass.\n    However, the argument length is constrained to be small enough to fit in\n    one code unit. This check happens in parse_regex(). In the first pass,\n    instead of putting the argument into memory, we just update the length\n    counter and set up an empty argument. */\n\n    case META_THEN_ARG:\n    cb->external_flags |= PCRE2_HASTHEN;\n    goto VERB_ARG;\n\n    case META_PRUNE_ARG:\n    case META_SKIP_ARG:\n    cb->had_pruneorskip = TRUE;\n    /* Fall through */\n    case META_MARK:\n    case META_COMMIT_ARG:\n    VERB_ARG:\n    *code++ = verbops\u00dd(meta - META_MARK) >> 16\u00a8;\n    /* The length is in characters. */\n    verbarglen = *(++pptr);\n    verbculen = 0;\n    tempcode = code++;\n    for (i = 0; i < (int)verbarglen; i++)\n      {\n      meta = *(++pptr);\n#ifdef SUPPORT_UNICODE\n      if (utf) mclength = PRIV(ord2utf)(meta, mcbuffer); else\n#endif\n        {\n        mclength = 1;\n        mcbuffer\u00dd0\u00a8 = meta;\n        }\n      if (lengthptr != NULL) *lengthptr += mclength; else\n        {\n        memcpy(code, mcbuffer, CU2BYTES(mclength));\n        code += mclength;\n        verbculen += mclength;\n        }\n      }\n\n    *tempcode = verbculen;   /* Fill in the code unit length */\n    *code++ = 0;             /* Terminating zero */\n    break;\n\n\n    /* ===================================================================*/\n    /* Handle options change. The new setting must be passed back for use in\n    subsequent branches. Reset the greedy defaults and the case value for\n    firstcu and reqcu. */\n\n    case META_OPTIONS:\n    *optionsptr = options = *(++pptr);\n    greedy_default = ((options & PCRE2_UNGREEDY) != 0);\n    greedy_non_default = greedy_default \u00ac 1;\n    req_caseopt = ((options & PCRE2_CASELESS) != 0)? REQ_CASELESS : 0;\n    break;\n\n\n    /* ===================================================================*/\n    /* Handle conditional subpatterns. The case of (?(Rdigits) is ambiguous\n    because it could be a numerical check on recursion, or a name check on a\n    group's being set. The pre-pass sets up META_COND_RNUMBER as a name so that\n    we can handle it either way. We first try for a name; if not found, process\n    the number. */\n\n    case META_COND_RNUMBER:   /* (?(Rdigits) */\n    case META_COND_NAME:      /* (?(name) or (?'name') or ?(<name>) */\n    case META_COND_RNAME:     /* (?(R&name) - test for recursion */\n    bravalue = OP_COND;\n      {\n      int count, index;\n      PCRE2_SPTR name;\n      named_group *ng = cb->named_groups;\n      uint32_t length = *(++pptr);\n\n      GETPLUSOFFSET(offset, pptr);\n      name = cb->start_pattern + offset;\n\n      /* In the first pass, the names generated in the pre-pass are available,\n      but the main name table has not yet been created. Scan the list of names\n      generated in the pre-pass in order to get a number and whether or not\n      this name is duplicated. If it is not duplicated, we can handle it as a\n      numerical group. */\n\n      for (i = 0; i < cb->names_found; i++, ng++)\n        {\n        if (length == ng->length &&\n            PRIV(strncmp)(name, ng->name, length) == 0)\n          {\n          if (!ng->isdup)\n            {\n            code\u00dd1+LINK_SIZE\u00a8 = (meta == META_COND_RNAME)? OP_RREF : OP_CREF;\n            PUT2(code, 2+LINK_SIZE, ng->number);\n            if (ng->number > cb->top_backref) cb->top_backref = ng->number;\n            skipunits = 1+IMM2_SIZE;\n            goto GROUP_PROCESS_NOTE_EMPTY;\n            }\n          break;  /* Found a duplicated name */\n          }\n        }\n\n      /* If the name was not found we have a bad reference, unless we are\n      dealing with R<digits>, which is treated as a recursion test by number.\n      */\n\n      if (i >= cb->names_found)\n        {\n        groupnumber = 0;\n        if (meta == META_COND_RNUMBER)\n          {\n          for (i = 1; i < (int)length; i++)\n            {\n            groupnumber = groupnumber * 10 + name\u00ddi\u00a8 - CHAR_0;\n            if (groupnumber > MAX_GROUP_NUMBER)\n              {\n              *errorcodeptr = ERR61;\n              cb->erroroffset = offset + i;\n              return 0;\n              }\n            }\n          }\n\n        if (meta != META_COND_RNUMBER || groupnumber > cb->bracount)\n          {\n          *errorcodeptr = ERR15;\n          cb->erroroffset = offset;\n          return 0;\n          }\n\n        /* (?Rdigits) treated as a recursion reference by number. A value of\n        zero (which is the result of both (?R) and (?R0)) means \"any\", and is\n        translated into RREF_ANY (which is 0xffff). */\n\n        if (groupnumber == 0) groupnumber = RREF_ANY;\n        code\u00dd1+LINK_SIZE\u00a8 = OP_RREF;\n        PUT2(code, 2+LINK_SIZE, groupnumber);\n        skipunits = 1+IMM2_SIZE;\n        goto GROUP_PROCESS_NOTE_EMPTY;\n        }\n\n      /* A duplicated name was found. Note that if an R<digits> name is found\n      (META_COND_RNUMBER), it is a reference test, not a recursion test. */\n\n      code\u00dd1+LINK_SIZE\u00a8 = (meta == META_COND_RNAME)? OP_RREF : OP_CREF;\n\n      /* We have a duplicated name. In the compile pass we have to search the\n      main table in order to get the index and count values. */\n\n      count = 0;  /* Values for first pass (avoids compiler warning) */\n      index = 0;\n      if (lengthptr == NULL && !find_dupname_details(name, length, &index,\n            &count, errorcodeptr, cb)) return 0;\n\n      /* Add one to the opcode to change CREF/RREF into DNCREF/DNRREF and\n      insert appropriate data values. */\n\n      code\u00dd1+LINK_SIZE\u00a8++;\n      skipunits = 1+2*IMM2_SIZE;\n      PUT2(code, 2+LINK_SIZE, index);\n      PUT2(code, 2+LINK_SIZE+IMM2_SIZE, count);\n      }\n    goto GROUP_PROCESS_NOTE_EMPTY;\n\n    /* The DEFINE condition is always false. Its internal groups may never\n    be called, so matched_char must remain false, hence the jump to\n    GROUP_PROCESS rather than GROUP_PROCESS_NOTE_EMPTY. */\n\n    case META_COND_DEFINE:\n    bravalue = OP_COND;\n    GETPLUSOFFSET(offset, pptr);\n    code\u00dd1+LINK_SIZE\u00a8 = OP_DEFINE;\n    skipunits = 1;\n    goto GROUP_PROCESS;\n\n    /* Conditional test of a group's being set. */\n\n    case META_COND_NUMBER:\n    bravalue = OP_COND;\n    GETPLUSOFFSET(offset, pptr);\n    groupnumber = *(++pptr);\n    if (groupnumber > cb->bracount)\n      {\n      *errorcodeptr = ERR15;\n      cb->erroroffset = offset;\n      return 0;\n      }\n    if (groupnumber > cb->top_backref) cb->top_backref = groupnumber;\n    offset -= 2;   /* Point at initial ( for too many branches error */\n    code\u00dd1+LINK_SIZE\u00a8 = OP_CREF;\n    skipunits = 1+IMM2_SIZE;\n    PUT2(code, 2+LINK_SIZE, groupnumber);\n    goto GROUP_PROCESS_NOTE_EMPTY;\n\n    /* Test for the PCRE2 version. */\n\n    case META_COND_VERSION:\n    bravalue = OP_COND;\n    if (pptr\u00dd1\u00a8 > 0)\n      code\u00dd1+LINK_SIZE\u00a8 = ((PCRE2_MAJOR > pptr\u00dd2\u00a8) ||\n        (PCRE2_MAJOR == pptr\u00dd2\u00a8 && PCRE2_MINOR >= pptr\u00dd3\u00a8))?\n          OP_TRUE : OP_FALSE;\n    else\n      code\u00dd1+LINK_SIZE\u00a8 = (PCRE2_MAJOR == pptr\u00dd2\u00a8 && PCRE2_MINOR == pptr\u00dd3\u00a8)?\n        OP_TRUE : OP_FALSE;\n    skipunits = 1;\n    pptr += 3;\n    goto GROUP_PROCESS_NOTE_EMPTY;\n\n    /* The condition is an assertion, possibly preceded by a callout. */\n\n    case META_COND_ASSERT:\n    bravalue = OP_COND;\n    goto GROUP_PROCESS_NOTE_EMPTY;\n\n\n    /* ===================================================================*/\n    /* Handle all kinds of nested bracketed groups. The non-capturing,\n    non-conditional cases are here; others come to GROUP_PROCESS via goto. */\n\n    case META_LOOKAHEAD:\n    bravalue = OP_ASSERT;\n    cb->assert_depth += 1;\n    goto GROUP_PROCESS;\n\n    case META_LOOKAHEAD_NA:\n    bravalue = OP_ASSERT_NA;\n    cb->assert_depth += 1;\n    goto GROUP_PROCESS;\n\n    /* Optimize (?!) to (*FAIL) unless it is quantified - which is a weird\n    thing to do, but Perl allows all assertions to be quantified, and when\n    they contain capturing parentheses there may be a potential use for\n    this feature. Not that that applies to a quantified (?!) but we allow\n    it for uniformity. */\n\n    case META_LOOKAHEADNOT:\n    if (pptr\u00dd1\u00a8 == META_KET &&\n         (pptr\u00dd2\u00a8 < META_ASTERISK || pptr\u00dd2\u00a8 > META_MINMAX_QUERY))\n      {\n      *code++ = OP_FAIL;\n      pptr++;\n      }\n    else\n      {\n      bravalue = OP_ASSERT_NOT;\n      cb->assert_depth += 1;\n      goto GROUP_PROCESS;\n      }\n    break;\n\n    case META_LOOKBEHIND:\n    bravalue = OP_ASSERTBACK;\n    cb->assert_depth += 1;\n    goto GROUP_PROCESS;\n\n    case META_LOOKBEHINDNOT:\n    bravalue = OP_ASSERTBACK_NOT;\n    cb->assert_depth += 1;\n    goto GROUP_PROCESS;\n\n    case META_LOOKBEHIND_NA:\n    bravalue = OP_ASSERTBACK_NA;\n    cb->assert_depth += 1;\n    goto GROUP_PROCESS;\n\n    case META_ATOMIC:\n    bravalue = OP_ONCE;\n    goto GROUP_PROCESS_NOTE_EMPTY;\n\n    case META_SCRIPT_RUN:\n    bravalue = OP_SCRIPT_RUN;\n    goto GROUP_PROCESS_NOTE_EMPTY;\n\n    case META_NOCAPTURE:\n    bravalue = OP_BRA;\n    /* Fall through */\n\n    /* Process nested bracketed regex. The nesting depth is maintained for the\n    benefit of the stackguard function. The test for too deep nesting is now\n    done in parse_regex(). Assertion and DEFINE groups come to GROUP_PROCESS;\n    others come to GROUP_PROCESS_NOTE_EMPTY, to indicate that we need to take\n    note of whether or not they may match an empty string. */\n\n    GROUP_PROCESS_NOTE_EMPTY:\n    note_group_empty = TRUE;\n\n    GROUP_PROCESS:\n    cb->parens_depth += 1;\n    *code = bravalue;\n    pptr++;\n    tempcode = code;\n    tempreqvary = cb->req_varyopt;        /* Save value before group */\n    length_prevgroup = 0;                 /* Initialize for pre-compile phase */\n\n    if ((group_return =\n         compile_regex(\n         options,                         /* The option state */\n         &tempcode,                       /* Where to put code (updated) */\n         &pptr,                           /* Input pointer (updated) */\n         errorcodeptr,                    /* Where to put an error message */\n         skipunits,                       /* Skip over bracket number */\n         &subfirstcu,                     /* For possible first char */\n         &subfirstcuflags,\n         &subreqcu,                       /* For possible last char */\n         &subreqcuflags,\n         bcptr,                           /* Current branch chain */\n         cb,                              /* Compile data block */\n         (lengthptr == NULL)? NULL :      /* Actual compile phase */\n           &length_prevgroup              /* Pre-compile phase */\n         )) == 0)\n      return 0;  /* Error */\n\n    cb->parens_depth -= 1;\n\n    /* If that was a non-conditional significant group (not an assertion, not a\n    DEFINE) that matches at least one character, then the current item matches\n    a character. Conditionals are handled below. */\n\n    if (note_group_empty && bravalue != OP_COND && group_return > 0)\n      matched_char = TRUE;\n\n    /* If we've just compiled an assertion, pop the assert depth. */\n\n    if (bravalue >= OP_ASSERT && bravalue <= OP_ASSERTBACK_NA)\n      cb->assert_depth -= 1;\n\n    /* At the end of compiling, code is still pointing to the start of the\n    group, while tempcode has been updated to point past the end of the group.\n    The parsed pattern pointer (pptr) is on the closing META_KET.\n\n    If this is a conditional bracket, check that there are no more than\n    two branches in the group, or just one if it's a DEFINE group. We do this\n    in the real compile phase, not in the pre-pass, where the whole group may\n    not be available. */\n\n    if (bravalue == OP_COND && lengthptr == NULL)\n      {\n      PCRE2_UCHAR *tc = code;\n      int condcount = 0;\n\n      do {\n         condcount++;\n         tc += GET(tc,1);\n         }\n      while (*tc != OP_KET);\n\n      /* A DEFINE group is never obeyed inline (the \"condition\" is always\n      false). It must have only one branch. Having checked this, change the\n      opcode to OP_FALSE. */\n\n      if (code\u00ddLINK_SIZE+1\u00a8 == OP_DEFINE)\n        {\n        if (condcount > 1)\n          {\n          cb->erroroffset = offset;\n          *errorcodeptr = ERR54;\n          return 0;\n          }\n        code\u00ddLINK_SIZE+1\u00a8 = OP_FALSE;\n        bravalue = OP_DEFINE;   /* A flag to suppress char handling below */\n        }\n\n      /* A \"normal\" conditional group. If there is just one branch, we must not\n      make use of its firstcu or reqcu, because this is equivalent to an\n      empty second branch. Also, it may match an empty string. If there are two\n      branches, this item must match a character if the group must. */\n\n      else\n        {\n        if (condcount > 2)\n          {\n          cb->erroroffset = offset;\n          *errorcodeptr = ERR27;\n          return 0;\n          }\n        if (condcount == 1) subfirstcuflags = subreqcuflags = REQ_NONE;\n          else if (group_return > 0) matched_char = TRUE;\n        }\n      }\n\n    /* In the pre-compile phase, update the length by the length of the group,\n    less the brackets at either end. Then reduce the compiled code to just a\n    set of non-capturing brackets so that it doesn't use much memory if it is\n    duplicated by a quantifier.*/\n\n    if (lengthptr != NULL)\n      {\n      if (OFLOW_MAX - *lengthptr < length_prevgroup - 2 - 2*LINK_SIZE)\n        {\n        *errorcodeptr = ERR20;\n        return 0;\n        }\n      *lengthptr += length_prevgroup - 2 - 2*LINK_SIZE;\n      code++;   /* This already contains bravalue */\n      PUTINC(code, 0, 1 + LINK_SIZE);\n      *code++ = OP_KET;\n      PUTINC(code, 0, 1 + LINK_SIZE);\n      break;    /* No need to waste time with special character handling */\n      }\n\n    /* Otherwise update the main code pointer to the end of the group. */\n\n    code = tempcode;\n\n    /* For a DEFINE group, required and first character settings are not\n    relevant. */\n\n    if (bravalue == OP_DEFINE) break;\n\n    /* Handle updating of the required and first code units for other types of\n    group. Update for normal brackets of all kinds, and conditions with two\n    branches (see code above). If the bracket is followed by a quantifier with\n    zero repeat, we have to back off. Hence the definition of zeroreqcu and\n    zerofirstcu outside the main loop so that they can be accessed for the back\n    off. */\n\n    zeroreqcu = reqcu;\n    zeroreqcuflags = reqcuflags;\n    zerofirstcu = firstcu;\n    zerofirstcuflags = firstcuflags;\n    groupsetfirstcu = FALSE;\n\n    if (bravalue >= OP_ONCE)  /* Not an assertion */\n      {\n      /* If we have not yet set a firstcu in this branch, take it from the\n      subpattern, remembering that it was set here so that a repeat of more\n      than one can replicate it as reqcu if necessary. If the subpattern has\n      no firstcu, set \"none\" for the whole branch. In both cases, a zero\n      repeat forces firstcu to \"none\". */\n\n      if (firstcuflags == REQ_UNSET && subfirstcuflags != REQ_UNSET)\n        {\n        if (subfirstcuflags >= 0)\n          {\n          firstcu = subfirstcu;\n          firstcuflags = subfirstcuflags;\n          groupsetfirstcu = TRUE;\n          }\n        else firstcuflags = REQ_NONE;\n        zerofirstcuflags = REQ_NONE;\n        }\n\n      /* If firstcu was previously set, convert the subpattern's firstcu\n      into reqcu if there wasn't one, using the vary flag that was in\n      existence beforehand. */\n\n      else if (subfirstcuflags >= 0 && subreqcuflags < 0)\n        {\n        subreqcu = subfirstcu;\n        subreqcuflags = subfirstcuflags | tempreqvary;\n        }\n\n      /* If the subpattern set a required code unit (or set a first code unit\n      that isn't really the first code unit - see above), set it. */\n\n      if (subreqcuflags >= 0)\n        {\n        reqcu = subreqcu;\n        reqcuflags = subreqcuflags;\n        }\n      }\n\n    /* For a forward assertion, we take the reqcu, if set, provided that the\n    group has also set a firstcu. This can be helpful if the pattern that\n    follows the assertion doesn't set a different char. For example, it's\n    useful for /(?=abcde).+/. We can't set firstcu for an assertion, however\n    because it leads to incorrect effect for patterns such as /(?=a)a.+/ when\n    the \"real\" \"a\" would then become a reqcu instead of a firstcu. This is\n    overcome by a scan at the end if there's no firstcu, looking for an\n    asserted first char. A similar effect for patterns like /(?=.*X)X$/ means\n    we must only take the reqcu when the group also set a firstcu. Otherwise,\n    in that example, 'X' ends up set for both. */\n\n    else if ((bravalue == OP_ASSERT || bravalue == OP_ASSERT_NA) &&\n             subreqcuflags >= 0 && subfirstcuflags >= 0)\n      {\n      reqcu = subreqcu;\n      reqcuflags = subreqcuflags;\n      }\n\n    break;  /* End of nested group handling */\n\n\n    /* ===================================================================*/\n    /* Handle named backreferences and recursions. */\n\n    case META_BACKREF_BYNAME:\n    case META_RECURSE_BYNAME:\n      {\n      int count, index;\n      PCRE2_SPTR name;\n      BOOL is_dupname = FALSE;\n      named_group *ng = cb->named_groups;\n      uint32_t length = *(++pptr);\n\n      GETPLUSOFFSET(offset, pptr);\n      name = cb->start_pattern + offset;\n\n      /* In the first pass, the names generated in the pre-pass are available,\n      but the main name table has not yet been created. Scan the list of names\n      generated in the pre-pass in order to get a number and whether or not\n      this name is duplicated. */\n\n      groupnumber = 0;\n      for (i = 0; i < cb->names_found; i++, ng++)\n        {\n        if (length == ng->length &&\n            PRIV(strncmp)(name, ng->name, length) == 0)\n          {\n          is_dupname = ng->isdup;\n          groupnumber = ng->number;\n\n          /* For a recursion, that's all that is needed. We can now go to\n          the code that handles numerical recursion, applying it to the first\n          group with the given name. */\n\n          if (meta == META_RECURSE_BYNAME)\n            {\n            meta_arg = groupnumber;\n            goto HANDLE_NUMERICAL_RECURSION;\n            }\n\n          /* For a back reference, update the back reference map and the\n          maximum back reference. */\n\n          cb->backref_map |= (groupnumber < 32)? (1u << groupnumber) : 1;\n          if (groupnumber > cb->top_backref)\n            cb->top_backref = groupnumber;\n          }\n        }\n\n      /* If the name was not found we have a bad reference. */\n\n      if (groupnumber == 0)\n        {\n        *errorcodeptr = ERR15;\n        cb->erroroffset = offset;\n        return 0;\n        }\n\n      /* If a back reference name is not duplicated, we can handle it as\n      a numerical reference. */\n\n      if (!is_dupname)\n        {\n        meta_arg = groupnumber;\n        goto HANDLE_SINGLE_REFERENCE;\n        }\n\n      /* If a back reference name is duplicated, we generate a different\n      opcode to a numerical back reference. In the second pass we must\n      search for the index and count in the final name table. */\n\n      count = 0;  /* Values for first pass (avoids compiler warning) */\n      index = 0;\n      if (lengthptr == NULL && !find_dupname_details(name, length, &index,\n            &count, errorcodeptr, cb)) return 0;\n\n      if (firstcuflags == REQ_UNSET) firstcuflags = REQ_NONE;\n      *code++ = ((options & PCRE2_CASELESS) != 0)? OP_DNREFI : OP_DNREF;\n      PUT2INC(code, 0, index);\n      PUT2INC(code, 0, count);\n      }\n    break;\n\n\n    /* ===================================================================*/\n    /* Handle a numerical callout. */\n\n    case META_CALLOUT_NUMBER:\n    code\u00dd0\u00a8 = OP_CALLOUT;\n    PUT(code, 1, pptr\u00dd1\u00a8);               /* Offset to next pattern item */\n    PUT(code, 1 + LINK_SIZE, pptr\u00dd2\u00a8);   /* Length of next pattern item */\n    code\u00dd1 + 2*LINK_SIZE\u00a8 = pptr\u00dd3\u00a8;\n    pptr += 3;\n    code += PRIV(OP_lengths)\u00ddOP_CALLOUT\u00a8;\n    break;\n\n\n    /* ===================================================================*/\n    /* Handle a callout with a string argument. In the pre-pass we just compute\n    the length without generating anything. The length in pptr\u00dd3\u00a8 includes both\n    delimiters; in the actual compile only the first one is copied, but a\n    terminating zero is added. Any doubled delimiters within the string make\n    this an overestimate, but it is not worth bothering about. */\n\n    case META_CALLOUT_STRING:\n    if (lengthptr != NULL)\n      {\n      *lengthptr += pptr\u00dd3\u00a8 + (1 + 4*LINK_SIZE);\n      pptr += 3;\n      SKIPOFFSET(pptr);\n      }\n\n    /* In the real compile we can copy the string. The starting delimiter is\n     included so that the client can discover it if they want. We also pass the\n     start offset to help a script language give better error messages. */\n\n    else\n      {\n      PCRE2_SPTR pp;\n      uint32_t delimiter;\n      uint32_t length = pptr\u00dd3\u00a8;\n      PCRE2_UCHAR *callout_string = code + (1 + 4*LINK_SIZE);\n\n      code\u00dd0\u00a8 = OP_CALLOUT_STR;\n      PUT(code, 1, pptr\u00dd1\u00a8);               /* Offset to next pattern item */\n      PUT(code, 1 + LINK_SIZE, pptr\u00dd2\u00a8);   /* Length of next pattern item */\n\n      pptr += 3;\n      GETPLUSOFFSET(offset, pptr);         /* Offset to string in pattern */\n      pp = cb->start_pattern + offset;\n      delimiter = *callout_string++ = *pp++;\n      if (delimiter == CHAR_LEFT_CURLY_BRACKET)\n        delimiter = CHAR_RIGHT_CURLY_BRACKET;\n      PUT(code, 1 + 3*LINK_SIZE, (int)(offset + 1));  /* One after delimiter */\n\n      /* The syntax of the pattern was checked in the parsing scan. The length\n      includes both delimiters, but we have passed the opening one just above,\n      so we reduce length before testing it. The test is for > 1 because we do\n      not want to copy the final delimiter. This also ensures that pp\u00dd1\u00a8 is\n      accessible. */\n\n      while (--length > 1)\n        {\n        if (*pp == delimiter && pp\u00dd1\u00a8 == delimiter)\n          {\n          *callout_string++ = delimiter;\n          pp += 2;\n          length--;\n          }\n        else *callout_string++ = *pp++;\n        }\n      *callout_string++ = CHAR_NUL;\n\n      /* Set the length of the entire item, the advance to its end. */\n\n      PUT(code, 1 + 2*LINK_SIZE, (int)(callout_string - code));\n      code = callout_string;\n      }\n    break;\n\n\n    /* ===================================================================*/\n    /* Handle repetition. The different types are all sorted out in the parsing\n    pass. */\n\n    case META_MINMAX_PLUS:\n    case META_MINMAX_QUERY:\n    case META_MINMAX:\n    repeat_min = *(++pptr);\n    repeat_max = *(++pptr);\n    goto REPEAT;\n\n    case META_ASTERISK:\n    case META_ASTERISK_PLUS:\n    case META_ASTERISK_QUERY:\n    repeat_min = 0;\n    repeat_max = REPEAT_UNLIMITED;\n    goto REPEAT;\n\n    case META_PLUS:\n    case META_PLUS_PLUS:\n    case META_PLUS_QUERY:\n    repeat_min = 1;\n    repeat_max = REPEAT_UNLIMITED;\n    goto REPEAT;\n\n    case META_QUERY:\n    case META_QUERY_PLUS:\n    case META_QUERY_QUERY:\n    repeat_min = 0;\n    repeat_max = 1;\n\n    REPEAT:\n    if (previous_matched_char && repeat_min > 0) matched_char = TRUE;\n\n    /* Remember whether this is a variable length repeat, and default to\n    single-char opcodes. */\n\n    reqvary = (repeat_min == repeat_max)? 0 : REQ_VARY;\n    op_type = 0;\n\n    /* Adjust first and required code units for a zero repeat. */\n\n    if (repeat_min == 0)\n      {\n      firstcu = zerofirstcu;\n      firstcuflags = zerofirstcuflags;\n      reqcu = zeroreqcu;\n      reqcuflags = zeroreqcuflags;\n      }\n\n    /* Note the greediness and possessiveness. */\n\n    switch (meta)\n      {\n      case META_MINMAX_PLUS:\n      case META_ASTERISK_PLUS:\n      case META_PLUS_PLUS:\n      case META_QUERY_PLUS:\n      repeat_type = 0;                  /* Force greedy */\n      possessive_quantifier = TRUE;\n      break;\n\n      case META_MINMAX_QUERY:\n      case META_ASTERISK_QUERY:\n      case META_PLUS_QUERY:\n      case META_QUERY_QUERY:\n      repeat_type = greedy_non_default;\n      possessive_quantifier = FALSE;\n      break;\n\n      default:\n      repeat_type = greedy_default;\n      possessive_quantifier = FALSE;\n      break;\n      }\n\n    /* Save start of previous item, in case we have to move it up in order to\n    insert something before it, and remember what it was. */\n\n    tempcode = previous;\n    op_previous = *previous;\n\n    /* Now handle repetition for the different types of item. If the repeat\n    minimum and the repeat maximum are both 1, we can ignore the quantifier for\n    non-parenthesized items, as they have only one alternative. For anything in\n    parentheses, we must not ignore if {1} is possessive. */\n\n    switch (op_previous)\n      {\n      /* If previous was a character or negated character match, abolish the\n      item and generate a repeat item instead. If a char item has a minimum of\n      more than one, ensure that it is set in reqcu - it might not be if a\n      sequence such as x{3} is the first thing in a branch because the x will\n      have gone into firstcu instead.  */\n\n      case OP_CHAR:\n      case OP_CHARI:\n      case OP_NOT:\n      case OP_NOTI:\n      if (repeat_max == 1 && repeat_min == 1) goto END_REPEAT;\n      op_type = chartypeoffset\u00ddop_previous - OP_CHAR\u00a8;\n\n      /* Deal with UTF characters that take up more than one code unit. */\n\n#ifdef MAYBE_UTF_MULTI\n      if (utf && NOT_FIRSTCU(code\u00dd-1\u00a8))\n        {\n        PCRE2_UCHAR *lastchar = code - 1;\n        BACKCHAR(lastchar);\n        mclength = (uint32_t)(code - lastchar);   /* Length of UTF character */\n        memcpy(mcbuffer, lastchar, CU2BYTES(mclength));  /* Save the char */\n        }\n      else\n#endif  /* MAYBE_UTF_MULTI */\n\n      /* Handle the case of a single code unit - either with no UTF support, or\n      with UTF disabled, or for a single-code-unit UTF character. */\n        {\n        mcbuffer\u00dd0\u00a8 = code\u00dd-1\u00a8;\n        mclength = 1;\n        if (op_previous <= OP_CHARI && repeat_min > 1)\n          {\n          reqcu = mcbuffer\u00dd0\u00a8;\n          reqcuflags = req_caseopt | cb->req_varyopt;\n          }\n        }\n      goto OUTPUT_SINGLE_REPEAT;  /* Code shared with single character types */\n\n      /* If previous was a character class or a back reference, we put the\n      repeat stuff after it, but just skip the item if the repeat was {0,0}. */\n\n#ifdef SUPPORT_WIDE_CHARS\n      case OP_XCLASS:\n#endif\n      case OP_CLASS:\n      case OP_NCLASS:\n      case OP_REF:\n      case OP_REFI:\n      case OP_DNREF:\n      case OP_DNREFI:\n\n      if (repeat_max == 0)\n        {\n        code = previous;\n        goto END_REPEAT;\n        }\n      if (repeat_max == 1 && repeat_min == 1) goto END_REPEAT;\n\n      if (repeat_min == 0 && repeat_max == REPEAT_UNLIMITED)\n        *code++ = OP_CRSTAR + repeat_type;\n      else if (repeat_min == 1 && repeat_max == REPEAT_UNLIMITED)\n        *code++ = OP_CRPLUS + repeat_type;\n      else if (repeat_min == 0 && repeat_max == 1)\n        *code++ = OP_CRQUERY + repeat_type;\n      else\n        {\n        *code++ = OP_CRRANGE + repeat_type;\n        PUT2INC(code, 0, repeat_min);\n        if (repeat_max == REPEAT_UNLIMITED) repeat_max = 0;  /* 2-byte encoding for max */\n        PUT2INC(code, 0, repeat_max);\n        }\n      break;\n\n      /* If previous is OP_FAIL, it was generated by an empty class \u00dd\u00a8\n      (PCRE2_ALLOW_EMPTY_CLASS is set). The other ways in which OP_FAIL can be\n      generated, that is by (*FAIL) or (?!), disallow a quantifier at parse\n      time. We can just ignore this repeat. */\n\n      case OP_FAIL:\n      goto END_REPEAT;\n\n      /* Prior to 10.30, repeated recursions were wrapped in OP_ONCE brackets\n      because pcre2_match() could not handle backtracking into recursively\n      called groups. Now that this backtracking is available, we no longer need\n      to do this. However, we still need to replicate recursions as we do for\n      groups so as to have independent backtracking points. We can replicate\n      for the minimum number of repeats directly. For optional repeats we now\n      wrap the recursion in OP_BRA brackets and make use of the bracket\n      repetition. */\n\n      case OP_RECURSE:\n      if (repeat_max == 1 && repeat_min == 1 && !possessive_quantifier)\n        goto END_REPEAT;\n\n      /* Generate unwrapped repeats for a non-zero minimum, except when the\n      minimum is 1 and the maximum unlimited, because that can be handled with\n      OP_BRA terminated by OP_KETRMAX/MIN. When the maximum is equal to the\n      minimum, we just need to generate the appropriate additional copies.\n      Otherwise we need to generate one more, to simulate the situation when\n      the minimum is zero. */\n\n      if (repeat_min > 0 && (repeat_min != 1 || repeat_max != REPEAT_UNLIMITED))\n        {\n        int replicate = repeat_min;\n        if (repeat_min == repeat_max) replicate--;\n\n        /* In the pre-compile phase, we don't actually do the replication. We\n        just adjust the length as if we had. Do some paranoid checks for\n        potential integer overflow. The INT64_OR_DOUBLE type is a 64-bit\n        integer type when available, otherwise double. */\n\n        if (lengthptr != NULL)\n          {\n          PCRE2_SIZE delta = replicate*(1 + LINK_SIZE);\n          if ((INT64_OR_DOUBLE)replicate*\n                (INT64_OR_DOUBLE)(1 + LINK_SIZE) >\n                  (INT64_OR_DOUBLE)INT_MAX ||\n              OFLOW_MAX - *lengthptr < delta)\n            {\n            *errorcodeptr = ERR20;\n            return 0;\n            }\n          *lengthptr += delta;\n          }\n\n        else for (i = 0; i < replicate; i++)\n          {\n          memcpy(code, previous, CU2BYTES(1 + LINK_SIZE));\n          previous = code;\n          code += 1 + LINK_SIZE;\n          }\n\n        /* If the number of repeats is fixed, we are done. Otherwise, adjust\n        the counts and fall through. */\n\n        if (repeat_min == repeat_max) break;\n        if (repeat_max != REPEAT_UNLIMITED) repeat_max -= repeat_min;\n        repeat_min = 0;\n        }\n\n      /* Wrap the recursion call in OP_BRA brackets. */\n\n      (void)memmove(previous + 1 + LINK_SIZE, previous, CU2BYTES(1 + LINK_SIZE));\n      op_previous = *previous = OP_BRA;\n      PUT(previous, 1, 2 + 2*LINK_SIZE);\n      previous\u00dd2 + 2*LINK_SIZE\u00a8 = OP_KET;\n      PUT(previous, 3 + 2*LINK_SIZE, 2 + 2*LINK_SIZE);\n      code += 2 + 2 * LINK_SIZE;\n      length_prevgroup = 3 + 3*LINK_SIZE;\n      group_return = -1;  /* Set \"may match empty string\" */\n\n      /* Now treat as a repeated OP_BRA. */\n      /* Fall through */\n\n      /* If previous was a bracket group, we may have to replicate it in\n      certain cases. Note that at this point we can encounter only the \"basic\"\n      bracket opcodes such as BRA and CBRA, as this is the place where they get\n      converted into the more special varieties such as BRAPOS and SBRA.\n      Originally, PCRE did not allow repetition of assertions, but now it does,\n      for Perl compatibility. */\n\n      case OP_ASSERT:\n      case OP_ASSERT_NOT:\n      case OP_ASSERT_NA:\n      case OP_ASSERTBACK:\n      case OP_ASSERTBACK_NOT:\n      case OP_ASSERTBACK_NA:\n      case OP_ONCE:\n      case OP_SCRIPT_RUN:\n      case OP_BRA:\n      case OP_CBRA:\n      case OP_COND:\n        {\n        int len = (int)(code - previous);\n        PCRE2_UCHAR *bralink = NULL;\n        PCRE2_UCHAR *brazeroptr = NULL;\n\n        if (repeat_max == 1 && repeat_min == 1 && !possessive_quantifier)\n          goto END_REPEAT;\n\n        /* Repeating a DEFINE group (or any group where the condition is always\n        FALSE and there is only one branch) is pointless, but Perl allows the\n        syntax, so we just ignore the repeat. */\n\n        if (op_previous == OP_COND && previous\u00ddLINK_SIZE+1\u00a8 == OP_FALSE &&\n            previous\u00ddGET(previous, 1)\u00a8 != OP_ALT)\n          goto END_REPEAT;\n\n        /* Perl allows all assertions to be quantified, and when they contain\n        capturing parentheses and/or are optional there are potential uses for\n        this feature. PCRE2 used to force the maximum quantifier to 1 on the\n        invalid grounds that further repetition was never useful. This was\n        always a bit pointless, since an assertion could be wrapped with a\n        repeated group to achieve the effect. General repetition is now\n        permitted, but if the maximum is unlimited it is set to one more than\n        the minimum. */\n\n        if (op_previous < OP_ONCE)    /* Assertion */\n          {\n          if (repeat_max == REPEAT_UNLIMITED) repeat_max = repeat_min + 1;\n          }\n\n        /* The case of a zero minimum is special because of the need to stick\n        OP_BRAZERO in front of it, and because the group appears once in the\n        data, whereas in other cases it appears the minimum number of times. For\n        this reason, it is simplest to treat this case separately, as otherwise\n        the code gets far too messy. There are several special subcases when the\n        minimum is zero. */\n\n        if (repeat_min == 0)\n          {\n          /* If the maximum is also zero, we used to just omit the group from\n          the output altogether, like this:\n\n          ** if (repeat_max == 0)\n          **   {\n          **   code = previous;\n          **   goto END_REPEAT;\n          **   }\n\n          However, that fails when a group or a subgroup within it is\n          referenced as a subroutine from elsewhere in the pattern, so now we\n          stick in OP_SKIPZERO in front of it so that it is skipped on\n          execution. As we don't have a list of which groups are referenced, we\n          cannot do this selectively.\n\n          If the maximum is 1 or unlimited, we just have to stick in the\n          BRAZERO and do no more at this point. */\n\n          if (repeat_max <= 1 || repeat_max == REPEAT_UNLIMITED)\n            {\n            (void)memmove(previous + 1, previous, CU2BYTES(len));\n            code++;\n            if (repeat_max == 0)\n              {\n              *previous++ = OP_SKIPZERO;\n              goto END_REPEAT;\n              }\n            brazeroptr = previous;    /* Save for possessive optimizing */\n            *previous++ = OP_BRAZERO + repeat_type;\n            }\n\n          /* If the maximum is greater than 1 and limited, we have to replicate\n          in a nested fashion, sticking OP_BRAZERO before each set of brackets.\n          The first one has to be handled carefully because it's the original\n          copy, which has to be moved up. The remainder can be handled by code\n          that is common with the non-zero minimum case below. We have to\n          adjust the value or repeat_max, since one less copy is required. */\n\n          else\n            {\n            int linkoffset;\n            (void)memmove(previous + 2 + LINK_SIZE, previous, CU2BYTES(len));\n            code += 2 + LINK_SIZE;\n            *previous++ = OP_BRAZERO + repeat_type;\n            *previous++ = OP_BRA;\n\n            /* We chain together the bracket link offset fields that have to be\n            filled in later when the ends of the brackets are reached. */\n\n            linkoffset = (bralink == NULL)? 0 : (int)(previous - bralink);\n            bralink = previous;\n            PUTINC(previous, 0, linkoffset);\n            }\n\n          if (repeat_max != REPEAT_UNLIMITED) repeat_max--;\n          }\n\n        /* If the minimum is greater than zero, replicate the group as many\n        times as necessary, and adjust the maximum to the number of subsequent\n        copies that we need. */\n\n        else\n          {\n          if (repeat_min > 1)\n            {\n            /* In the pre-compile phase, we don't actually do the replication.\n            We just adjust the length as if we had. Do some paranoid checks for\n            potential integer overflow. The INT64_OR_DOUBLE type is a 64-bit\n            integer type when available, otherwise double. */\n\n            if (lengthptr != NULL)\n              {\n              PCRE2_SIZE delta = (repeat_min - 1)*length_prevgroup;\n              if ((INT64_OR_DOUBLE)(repeat_min - 1)*\n                    (INT64_OR_DOUBLE)length_prevgroup >\n                      (INT64_OR_DOUBLE)INT_MAX ||\n                  OFLOW_MAX - *lengthptr < delta)\n                {\n                *errorcodeptr = ERR20;\n                return 0;\n                }\n              *lengthptr += delta;\n              }\n\n            /* This is compiling for real. If there is a set first code unit\n            for the group, and we have not yet set a \"required code unit\", set\n            it. */\n\n            else\n              {\n              if (groupsetfirstcu && reqcuflags < 0)\n                {\n                reqcu = firstcu;\n                reqcuflags = firstcuflags;\n                }\n              for (i = 1; (uint32_t)i < repeat_min; i++)\n                {\n                memcpy(code, previous, CU2BYTES(len));\n                code += len;\n                }\n              }\n            }\n\n          if (repeat_max != REPEAT_UNLIMITED) repeat_max -= repeat_min;\n          }\n\n        /* This code is common to both the zero and non-zero minimum cases. If\n        the maximum is limited, it replicates the group in a nested fashion,\n        remembering the bracket starts on a stack. In the case of a zero\n        minimum, the first one was set up above. In all cases the repeat_max\n        now specifies the number of additional copies needed. Again, we must\n        remember to replicate entries on the forward reference list. */\n\n        if (repeat_max != REPEAT_UNLIMITED)\n          {\n          /* In the pre-compile phase, we don't actually do the replication. We\n          just adjust the length as if we had. For each repetition we must add\n          1 to the length for BRAZERO and for all but the last repetition we\n          must add 2 + 2*LINKSIZE to allow for the nesting that occurs. Do some\n          paranoid checks to avoid integer overflow. The INT64_OR_DOUBLE type\n          is a 64-bit integer type when available, otherwise double. */\n\n          if (lengthptr != NULL && repeat_max > 0)\n            {\n            PCRE2_SIZE delta = repeat_max*(length_prevgroup + 1 + 2 + 2*LINK_SIZE) -\n                        2 - 2*LINK_SIZE;   /* Last one doesn't nest */\n            if ((INT64_OR_DOUBLE)repeat_max *\n                  (INT64_OR_DOUBLE)(length_prevgroup + 1 + 2 + 2*LINK_SIZE)\n                    > (INT64_OR_DOUBLE)INT_MAX ||\n                OFLOW_MAX - *lengthptr < delta)\n              {\n              *errorcodeptr = ERR20;\n              return 0;\n              }\n            *lengthptr += delta;\n            }\n\n          /* This is compiling for real */\n\n          else for (i = repeat_max - 1; i >= 0; i--)\n            {\n            *code++ = OP_BRAZERO + repeat_type;\n\n            /* All but the final copy start a new nesting, maintaining the\n            chain of brackets outstanding. */\n\n            if (i != 0)\n              {\n              int linkoffset;\n              *code++ = OP_BRA;\n              linkoffset = (bralink == NULL)? 0 : (int)(code - bralink);\n              bralink = code;\n              PUTINC(code, 0, linkoffset);\n              }\n\n            memcpy(code, previous, CU2BYTES(len));\n            code += len;\n            }\n\n          /* Now chain through the pending brackets, and fill in their length\n          fields (which are holding the chain links pro tem). */\n\n          while (bralink != NULL)\n            {\n            int oldlinkoffset;\n            int linkoffset = (int)(code - bralink + 1);\n            PCRE2_UCHAR *bra = code - linkoffset;\n            oldlinkoffset = GET(bra, 1);\n            bralink = (oldlinkoffset == 0)? NULL : bralink - oldlinkoffset;\n            *code++ = OP_KET;\n            PUTINC(code, 0, linkoffset);\n            PUT(bra, 1, linkoffset);\n            }\n          }\n\n        /* If the maximum is unlimited, set a repeater in the final copy. For\n        SCRIPT_RUN and ONCE brackets, that's all we need to do. However,\n        possessively repeated ONCE brackets can be converted into non-capturing\n        brackets, as the behaviour of (?:xx)++ is the same as (?>xx)++ and this\n        saves having to deal with possessive ONCEs specially.\n\n        Otherwise, when we are doing the actual compile phase, check to see\n        whether this group is one that could match an empty string. If so,\n        convert the initial operator to the S form (e.g. OP_BRA -> OP_SBRA) so\n        that runtime checking can be done. \u00ddThis check is also applied to ONCE\n        and SCRIPT_RUN groups at runtime, but in a different way.\u00a8\n\n        Then, if the quantifier was possessive and the bracket is not a\n        conditional, we convert the BRA code to the POS form, and the KET code\n        to KETRPOS. (It turns out to be convenient at runtime to detect this\n        kind of subpattern at both the start and at the end.) The use of\n        special opcodes makes it possible to reduce greatly the stack usage in\n        pcre2_match(). If the group is preceded by OP_BRAZERO, convert this to\n        OP_BRAPOSZERO.\n\n        Then, if the minimum number of matches is 1 or 0, cancel the possessive\n        flag so that the default action below, of wrapping everything inside\n        atomic brackets, does not happen. When the minimum is greater than 1,\n        there will be earlier copies of the group, and so we still have to wrap\n        the whole thing. */\n\n        else\n          {\n          PCRE2_UCHAR *ketcode = code - 1 - LINK_SIZE;\n          PCRE2_UCHAR *bracode = ketcode - GET(ketcode, 1);\n\n          /* Convert possessive ONCE brackets to non-capturing */\n\n          if (*bracode == OP_ONCE && possessive_quantifier) *bracode = OP_BRA;\n\n          /* For non-possessive ONCE and for SCRIPT_RUN brackets, all we need\n          to do is to set the KET. */\n\n          if (*bracode == OP_ONCE || *bracode == OP_SCRIPT_RUN)\n            *ketcode = OP_KETRMAX + repeat_type;\n\n          /* Handle non-SCRIPT_RUN and non-ONCE brackets and possessive ONCEs\n          (which have been converted to non-capturing above). */\n\n          else\n            {\n            /* In the compile phase, adjust the opcode if the group can match\n            an empty string. For a conditional group with only one branch, the\n            value of group_return will not show \"could be empty\", so we must\n            check that separately. */\n\n            if (lengthptr == NULL)\n              {\n              if (group_return < 0) *bracode += OP_SBRA - OP_BRA;\n              if (*bracode == OP_COND && bracode\u00ddGET(bracode,1)\u00a8 != OP_ALT)\n                *bracode = OP_SCOND;\n              }\n\n            /* Handle possessive quantifiers. */\n\n            if (possessive_quantifier)\n              {\n              /* For COND brackets, we wrap the whole thing in a possessively\n              repeated non-capturing bracket, because we have not invented POS\n              versions of the COND opcodes. */\n\n              if (*bracode == OP_COND || *bracode == OP_SCOND)\n                {\n                int nlen = (int)(code - bracode);\n                (void)memmove(bracode + 1 + LINK_SIZE, bracode, CU2BYTES(nlen));\n                code += 1 + LINK_SIZE;\n                nlen += 1 + LINK_SIZE;\n                *bracode = (*bracode == OP_COND)? OP_BRAPOS : OP_SBRAPOS;\n                *code++ = OP_KETRPOS;\n                PUTINC(code, 0, nlen);\n                PUT(bracode, 1, nlen);\n                }\n\n              /* For non-COND brackets, we modify the BRA code and use KETRPOS. */\n\n              else\n                {\n                *bracode += 1;              /* Switch to xxxPOS opcodes */\n                *ketcode = OP_KETRPOS;\n                }\n\n              /* If the minimum is zero, mark it as possessive, then unset the\n              possessive flag when the minimum is 0 or 1. */\n\n              if (brazeroptr != NULL) *brazeroptr = OP_BRAPOSZERO;\n              if (repeat_min < 2) possessive_quantifier = FALSE;\n              }\n\n            /* Non-possessive quantifier */\n\n            else *ketcode = OP_KETRMAX + repeat_type;\n            }\n          }\n        }\n      break;\n\n      /* If previous was a character type match (\\d or similar), abolish it and\n      create a suitable repeat item. The code is shared with single-character\n      repeats by setting op_type to add a suitable offset into repeat_type.\n      Note the the Unicode property types will be present only when\n      SUPPORT_UNICODE is defined, but we don't wrap the little bits of code\n      here because it just makes it horribly messy. */\n\n      default:\n      if (op_previous >= OP_EODN)   /* Not a character type - internal error */\n        {\n        *errorcodeptr = ERR10;\n        return 0;\n        }\n      else\n        {\n        int prop_type, prop_value;\n        PCRE2_UCHAR *oldcode;\n\n        if (repeat_max == 1 && repeat_min == 1) goto END_REPEAT;\n\n        op_type = OP_TYPESTAR - OP_STAR;      /* Use type opcodes */\n        mclength = 0;                         /* Not a character */\n\n        if (op_previous == OP_PROP || op_previous == OP_NOTPROP)\n          {\n          prop_type = previous\u00dd1\u00a8;\n          prop_value = previous\u00dd2\u00a8;\n          }\n        else\n          {\n          /* Come here from just above with a character in mcbuffer/mclength. */\n          OUTPUT_SINGLE_REPEAT:\n          prop_type = prop_value = -1;\n          }\n\n        /* At this point, if prop_type == prop_value == -1 we either have a\n        character in mcbuffer when mclength is greater than zero, or we have\n        mclength zero, in which case there is a non-property character type in\n        op_previous. If prop_type/value are not negative, we have a property\n        character type in op_previous. */\n\n        oldcode = code;                   /* Save where we were */\n        code = previous;                  /* Usually overwrite previous item */\n\n        /* If the maximum is zero then the minimum must also be zero; Perl allows\n        this case, so we do too - by simply omitting the item altogether. */\n\n        if (repeat_max == 0) goto END_REPEAT;\n\n        /* Combine the op_type with the repeat_type */\n\n        repeat_type += op_type;\n\n        /* A minimum of zero is handled either as the special case * or ?, or as\n        an UPTO, with the maximum given. */\n\n        if (repeat_min == 0)\n          {\n          if (repeat_max == REPEAT_UNLIMITED) *code++ = OP_STAR + repeat_type;\n            else if (repeat_max == 1) *code++ = OP_QUERY + repeat_type;\n          else\n            {\n            *code++ = OP_UPTO + repeat_type;\n            PUT2INC(code, 0, repeat_max);\n            }\n          }\n\n        /* A repeat minimum of 1 is optimized into some special cases. If the\n        maximum is unlimited, we use OP_PLUS. Otherwise, the original item is\n        left in place and, if the maximum is greater than 1, we use OP_UPTO with\n        one less than the maximum. */\n\n        else if (repeat_min == 1)\n          {\n          if (repeat_max == REPEAT_UNLIMITED)\n            *code++ = OP_PLUS + repeat_type;\n          else\n            {\n            code = oldcode;  /* Leave previous item in place */\n            if (repeat_max == 1) goto END_REPEAT;\n            *code++ = OP_UPTO + repeat_type;\n            PUT2INC(code, 0, repeat_max - 1);\n            }\n          }\n\n        /* The case {n,n} is just an EXACT, while the general case {n,m} is\n        handled as an EXACT followed by an UPTO or STAR or QUERY. */\n\n        else\n          {\n          *code++ = OP_EXACT + op_type;  /* NB EXACT doesn't have repeat_type */\n          PUT2INC(code, 0, repeat_min);\n\n          /* Unless repeat_max equals repeat_min, fill in the data for EXACT,\n          and then generate the second opcode. For a repeated Unicode property\n          match, there are two extra values that define the required property,\n          and mclength is set zero to indicate this. */\n\n          if (repeat_max != repeat_min)\n            {\n            if (mclength > 0)\n              {\n              memcpy(code, mcbuffer, CU2BYTES(mclength));\n              code += mclength;\n              }\n            else\n              {\n              *code++ = op_previous;\n              if (prop_type >= 0)\n                {\n                *code++ = prop_type;\n                *code++ = prop_value;\n                }\n              }\n\n            /* Now set up the following opcode */\n\n            if (repeat_max == REPEAT_UNLIMITED)\n              *code++ = OP_STAR + repeat_type;\n            else\n              {\n              repeat_max -= repeat_min;\n              if (repeat_max == 1)\n                {\n                *code++ = OP_QUERY + repeat_type;\n                }\n              else\n                {\n                *code++ = OP_UPTO + repeat_type;\n                PUT2INC(code, 0, repeat_max);\n                }\n              }\n            }\n          }\n\n        /* Fill in the character or character type for the final opcode. */\n\n        if (mclength > 0)\n          {\n          memcpy(code, mcbuffer, CU2BYTES(mclength));\n          code += mclength;\n          }\n        else\n          {\n          *code++ = op_previous;\n          if (prop_type >= 0)\n            {\n            *code++ = prop_type;\n            *code++ = prop_value;\n            }\n          }\n        }\n      break;\n      }  /* End of switch on different op_previous values */\n\n\n    /* If the character following a repeat is '+', possessive_quantifier is\n    TRUE. For some opcodes, there are special alternative opcodes for this\n    case. For anything else, we wrap the entire repeated item inside OP_ONCE\n    brackets. Logically, the '+' notation is just syntactic sugar, taken from\n    Sun's Java package, but the special opcodes can optimize it.\n\n    Some (but not all) possessively repeated subpatterns have already been\n    completely handled in the code just above. For them, possessive_quantifier\n    is always FALSE at this stage. Note that the repeated item starts at\n    tempcode, not at previous, which might be the first part of a string whose\n    (former) last char we repeated. */\n\n    if (possessive_quantifier)\n      {\n      int len;\n\n      /* Possessifying an EXACT quantifier has no effect, so we can ignore it.\n      However, QUERY, STAR, or UPTO may follow (for quantifiers such as {5,6},\n      {5,}, or {5,10}). We skip over an EXACT item; if the length of what\n      remains is greater than zero, there's a further opcode that can be\n      handled. If not, do nothing, leaving the EXACT alone. */\n\n      switch(*tempcode)\n        {\n        case OP_TYPEEXACT:\n        tempcode += PRIV(OP_lengths)\u00dd*tempcode\u00a8 +\n          ((tempcode\u00dd1 + IMM2_SIZE\u00a8 == OP_PROP\n          || tempcode\u00dd1 + IMM2_SIZE\u00a8 == OP_NOTPROP)? 2 : 0);\n        break;\n\n        /* CHAR opcodes are used for exacts whose count is 1. */\n\n        case OP_CHAR:\n        case OP_CHARI:\n        case OP_NOT:\n        case OP_NOTI:\n        case OP_EXACT:\n        case OP_EXACTI:\n        case OP_NOTEXACT:\n        case OP_NOTEXACTI:\n        tempcode += PRIV(OP_lengths)\u00dd*tempcode\u00a8;\n#ifdef SUPPORT_UNICODE\n        if (utf && HAS_EXTRALEN(tempcode\u00dd-1\u00a8))\n          tempcode += GET_EXTRALEN(tempcode\u00dd-1\u00a8);\n#endif\n        break;\n\n        /* For the class opcodes, the repeat operator appears at the end;\n        adjust tempcode to point to it. */\n\n        case OP_CLASS:\n        case OP_NCLASS:\n        tempcode += 1 + 32/sizeof(PCRE2_UCHAR);\n        break;\n\n#ifdef SUPPORT_WIDE_CHARS\n        case OP_XCLASS:\n        tempcode += GET(tempcode, 1);\n        break;\n#endif\n        }\n\n      /* If tempcode is equal to code (which points to the end of the repeated\n      item), it means we have skipped an EXACT item but there is no following\n      QUERY, STAR, or UPTO; the value of len will be 0, and we do nothing. In\n      all other cases, tempcode will be pointing to the repeat opcode, and will\n      be less than code, so the value of len will be greater than 0. */\n\n      len = (int)(code - tempcode);\n      if (len > 0)\n        {\n        unsigned int repcode = *tempcode;\n\n        /* There is a table for possessifying opcodes, all of which are less\n        than OP_CALLOUT. A zero entry means there is no possessified version.\n        */\n\n        if (repcode < OP_CALLOUT && opcode_possessify\u00ddrepcode\u00a8 > 0)\n          *tempcode = opcode_possessify\u00ddrepcode\u00a8;\n\n        /* For opcode without a special possessified version, wrap the item in\n        ONCE brackets. */\n\n        else\n          {\n          (void)memmove(tempcode + 1 + LINK_SIZE, tempcode, CU2BYTES(len));\n          code += 1 + LINK_SIZE;\n          len += 1 + LINK_SIZE;\n          tempcode\u00dd0\u00a8 = OP_ONCE;\n          *code++ = OP_KET;\n          PUTINC(code, 0, len);\n          PUT(tempcode, 1, len);\n          }\n        }\n      }\n\n    /* We set the \"follows varying string\" flag for subsequently encountered\n    reqcus if it isn't already set and we have just passed a varying length\n    item. */\n\n    END_REPEAT:\n    cb->req_varyopt |= reqvary;\n    break;\n\n\n    /* ===================================================================*/\n    /* Handle a 32-bit data character with a value greater than META_END. */\n\n    case META_BIGVALUE:\n    pptr++;\n    goto NORMAL_CHAR;\n\n\n    /* ===============================================================*/\n    /* Handle a back reference by number, which is the meta argument. The\n    pattern offsets for back references to group numbers less than 10 are held\n    in a special vector, to avoid using more than two parsed pattern elements\n    in 64-bit environments. We only need the offset to the first occurrence,\n    because if that doesn't fail, subsequent ones will also be OK. */\n\n    case META_BACKREF:\n    if (meta_arg < 10) offset = cb->small_ref_offset\u00ddmeta_arg\u00a8;\n      else GETPLUSOFFSET(offset, pptr);\n\n    if (meta_arg > cb->bracount)\n      {\n      cb->erroroffset = offset;\n      *errorcodeptr = ERR15;  /* Non-existent subpattern */\n      return 0;\n      }\n\n    /* Come here from named backref handling when the reference is to a\n    single group (that is, not to a duplicated name). The back reference\n    data will have already been updated. We must disable firstcu if not\n    set, to cope with cases like (?=(\\w+))\\1: which would otherwise set ':'\n    later. */\n\n    HANDLE_SINGLE_REFERENCE:\n    if (firstcuflags == REQ_UNSET) zerofirstcuflags = firstcuflags = REQ_NONE;\n    *code++ = ((options & PCRE2_CASELESS) != 0)? OP_REFI : OP_REF;\n    PUT2INC(code, 0, meta_arg);\n\n    /* Update the map of back references, and keep the highest one. We\n    could do this in parse_regex() for numerical back references, but not\n    for named back references, because we don't know the numbers to which\n    named back references refer. So we do it all in this function. */\n\n    cb->backref_map |= (meta_arg < 32)? (1u << meta_arg) : 1;\n    if (meta_arg > cb->top_backref) cb->top_backref = meta_arg;\n    break;\n\n\n    /* ===============================================================*/\n    /* Handle recursion by inserting the number of the called group (which is\n    the meta argument) after OP_RECURSE. At the end of compiling the pattern is\n    scanned and these numbers are replaced by offsets within the pattern. It is\n    done like this to avoid problems with forward references and adjusting\n    offsets when groups are duplicated and moved (as discovered in previous\n    implementations). Note that a recursion does not have a set first\n    character. */\n\n    case META_RECURSE:\n    GETPLUSOFFSET(offset, pptr);\n    if (meta_arg > cb->bracount)\n      {\n      cb->erroroffset = offset;\n      *errorcodeptr = ERR15;  /* Non-existent subpattern */\n      return 0;\n      }\n    HANDLE_NUMERICAL_RECURSION:\n    *code = OP_RECURSE;\n    PUT(code, 1, meta_arg);\n    code += 1 + LINK_SIZE;\n    groupsetfirstcu = FALSE;\n    cb->had_recurse = TRUE;\n    if (firstcuflags == REQ_UNSET) firstcuflags = REQ_NONE;\n    zerofirstcu = firstcu;\n    zerofirstcuflags = firstcuflags;\n    break;\n\n\n    /* ===============================================================*/\n    /* Handle capturing parentheses; the number is the meta argument. */\n\n    case META_CAPTURE:\n    bravalue = OP_CBRA;\n    skipunits = IMM2_SIZE;\n    PUT2(code, 1+LINK_SIZE, meta_arg);\n    cb->lastcapture = meta_arg;\n    goto GROUP_PROCESS_NOTE_EMPTY;\n\n\n    /* ===============================================================*/\n    /* Handle escape sequence items. For ones like \\d, the ESC_values are\n    arranged to be the same as the corresponding OP_values in the default case\n    when PCRE2_UCP is not set (which is the only case in which they will appear\n    here).\n\n    Note: \\Q and \\E are never seen here, as they were dealt with in\n    parse_pattern(). Neither are numerical back references or recursions, which\n    were turned into META_BACKREF or META_RECURSE items, respectively. \\k and\n    \\g, when followed by names, are turned into META_BACKREF_BYNAME or\n    META_RECURSE_BYNAME. */\n\n    case META_ESCAPE:\n\n    /* We can test for escape sequences that consume a character because their\n    values lie between ESC_b and ESC_Z; this may have to change if any new ones\n    are ever created. For these sequences, we disable the setting of a first\n    character if it hasn't already been set. */\n\n    if (meta_arg > ESC_b && meta_arg < ESC_Z)\n      {\n      matched_char = TRUE;\n      if (firstcuflags == REQ_UNSET) firstcuflags = REQ_NONE;\n      }\n\n    /* Set values to reset to if this is followed by a zero repeat. */\n\n    zerofirstcu = firstcu;\n    zerofirstcuflags = firstcuflags;\n    zeroreqcu = reqcu;\n    zeroreqcuflags = reqcuflags;\n\n    /* If Unicode is not supported, \\P and \\p are not allowed and are\n    faulted at parse time, so will never appear here. */\n\n#ifdef SUPPORT_UNICODE\n    if (meta_arg == ESC_P || meta_arg == ESC_p)\n      {\n      uint32_t ptype = *(++pptr) >> 16;\n      uint32_t pdata = *pptr & 0xffff;\n\n      /* The special case of \\p{Any} is compiled to OP_ALLANY so as to benefit\n      from the auto-anchoring code. */\n\n      if (meta_arg == ESC_p && ptype == PT_ANY)\n        {\n        *code++ = OP_ALLANY;\n        }\n      else\n        {\n        *code++ = (meta_arg == ESC_p)? OP_PROP : OP_NOTPROP;\n        *code++ = ptype;\n        *code++ = pdata;\n        }\n      break;  /* End META_ESCAPE */\n      }\n#endif\n\n    /* For the rest (including \\X when Unicode is supported - if not it's\n    faulted at parse time), the OP value is the escape value when PCRE2_UCP is\n    not set; if it is set, these escapes do not show up here because they are\n    converted into Unicode property tests in parse_regex(). Note that \\b and \\B\n    do a one-character lookbehind, and \\A also behaves as if it does. */\n\n    if (meta_arg == ESC_C) cb->external_flags |= PCRE2_HASBKC; /* Record */\n    if ((meta_arg == ESC_b || meta_arg == ESC_B || meta_arg == ESC_A) &&\n         cb->max_lookbehind == 0)\n      cb->max_lookbehind = 1;\n\n    /* In non-UTF mode, and for both 32-bit modes, we turn \\C into OP_ALLANY\n    instead of OP_ANYBYTE so that it works in DFA mode and in lookbehinds. */\n\n#if PCRE2_CODE_UNIT_WIDTH == 32\n    *code++ = (meta_arg == ESC_C)? OP_ALLANY : meta_arg;\n#else\n    *code++ = (!utf && meta_arg == ESC_C)? OP_ALLANY : meta_arg;\n#endif\n    break;  /* End META_ESCAPE */\n\n\n    /* ===================================================================*/\n    /* Handle an unrecognized meta value. A parsed pattern value less than\n    META_END is a literal. Otherwise we have a problem. */\n\n    default:\n    if (meta >= META_END)\n      {\n#ifdef DEBUG_SHOW_PARSED\n      fprintf(stderr, \"** Unrecognized parsed pattern item 0x%.8x\\n\", *pptr);\n#endif\n      *errorcodeptr = ERR89;  /* Internal error - unrecognized. */\n      return 0;\n      }\n\n    /* Handle a literal character. We come here by goto in the case of a\n    32-bit, non-UTF character whose value is greater than META_END. */\n\n    NORMAL_CHAR:\n    meta = *pptr;     /* Get the full 32 bits */\n    NORMAL_CHAR_SET:  /* Character is already in meta */\n    matched_char = TRUE;\n\n    /* For caseless UTF or UCP mode, check whether this character has more than\n    one other case. If so, generate a special OP_PROP item instead of OP_CHARI.\n    */\n\n#ifdef SUPPORT_UNICODE\n    if ((utf||ucp) && (options & PCRE2_CASELESS) != 0)\n      {\n      uint32_t caseset = UCD_CASESET(meta);\n      if (caseset != 0)\n        {\n        *code++ = OP_PROP;\n        *code++ = PT_CLIST;\n        *code++ = caseset;\n        if (firstcuflags == REQ_UNSET)\n          firstcuflags = zerofirstcuflags = REQ_NONE;\n        break;  /* End handling this meta item */\n        }\n      }\n#endif\n\n    /* Caseful matches, or caseless and not one of the multicase characters. We\n    come here by goto in the case of a positive class that contains only\n    case-partners of a character with just two cases; matched_char has already\n    been set TRUE and options fudged if necessary. */\n\n    CLASS_CASELESS_CHAR:\n\n    /* Get the character's code units into mcbuffer, with the length in\n    mclength. When not in UTF mode, the length is always 1. */\n\n#ifdef SUPPORT_UNICODE\n    if (utf) mclength = PRIV(ord2utf)(meta, mcbuffer); else\n#endif\n      {\n      mclength = 1;\n      mcbuffer\u00dd0\u00a8 = meta;\n      }\n\n    /* Generate the appropriate code */\n\n    *code++ = ((options & PCRE2_CASELESS) != 0)? OP_CHARI : OP_CHAR;\n    memcpy(code, mcbuffer, CU2BYTES(mclength));\n    code += mclength;\n\n    /* Remember if \\r or \\n were seen */\n\n    if (mcbuffer\u00dd0\u00a8 == CHAR_CR || mcbuffer\u00dd0\u00a8 == CHAR_NL)\n      cb->external_flags |= PCRE2_HASCRORLF;\n\n    /* Set the first and required code units appropriately. If no previous\n    first code unit, set it from this character, but revert to none on a zero\n    repeat. Otherwise, leave the firstcu value alone, and don't change it on\n    a zero repeat. */\n\n    if (firstcuflags == REQ_UNSET)\n      {\n      zerofirstcuflags = REQ_NONE;\n      zeroreqcu = reqcu;\n      zeroreqcuflags = reqcuflags;\n\n      /* If the character is more than one code unit long, we can set a single\n      firstcu only if it is not to be matched caselessly. Multiple possible\n      starting code units may be picked up later in the studying code. */\n\n      if (mclength == 1 || req_caseopt == 0)\n        {\n        firstcu = mcbuffer\u00dd0\u00a8;\n        firstcuflags = req_caseopt;\n        if (mclength != 1)\n          {\n          reqcu = code\u00dd-1\u00a8;\n          reqcuflags = cb->req_varyopt;\n          }\n        }\n      else firstcuflags = reqcuflags = REQ_NONE;\n      }\n\n    /* firstcu was previously set; we can set reqcu only if the length is\n    1 or the matching is caseful. */\n\n    else\n      {\n      zerofirstcu = firstcu;\n      zerofirstcuflags = firstcuflags;\n      zeroreqcu = reqcu;\n      zeroreqcuflags = reqcuflags;\n      if (mclength == 1 || req_caseopt == 0)\n        {\n        reqcu = code\u00dd-1\u00a8;\n        reqcuflags = req_caseopt | cb->req_varyopt;\n        }\n      }\n\n    /* If caselessness was temporarily instated, reset it. */\n\n    if (reset_caseful)\n      {\n      options &= ~PCRE2_CASELESS;\n      req_caseopt = 0;\n      reset_caseful = FALSE;\n      }\n\n    break;    /* End literal character handling */\n    }         /* End of big switch */\n  }           /* End of big loop */\n\n/* Control never reaches here. */\n}\n\n\n\n/*************************************************\n*   Compile regex: a sequence of alternatives    *\n*************************************************/\n\n/* On entry, pptr is pointing past the bracket meta, but on return it points to\nthe closing bracket or META_END. The code variable is pointing at the code unit\ninto which the BRA operator has been stored. This function is used during the\npre-compile phase when we are trying to find out the amount of memory needed,\nas well as during the real compile phase. The value of lengthptr distinguishes\nthe two phases.\n\nArguments:\n  options           option bits, including any changes for this subpattern\n  codeptr           -> the address of the current code pointer\n  pptrptr           -> the address of the current parsed pattern pointer\n  errorcodeptr      -> pointer to error code variable\n  skipunits         skip this many code units at start (for brackets and OP_COND)\n  firstcuptr        place to put the first required code unit\n  firstcuflagsptr   place to put the first code unit flags, or a negative number\n  reqcuptr          place to put the last required code unit\n  reqcuflagsptr     place to put the last required code unit flags, or a negative number\n  bcptr             pointer to the chain of currently open branches\n  cb                points to the data block with tables pointers etc.\n  lengthptr         NULL during the real compile phase\n                    points to length accumulator during pre-compile phase\n\nReturns:            0 There has been an error\n                   +1 Success, this group must match at least one character\n                   -1 Success, this group may match an empty string\n*/\n\nstatic int\ncompile_regex(uint32_t options, PCRE2_UCHAR **codeptr, uint32_t **pptrptr,\n  int *errorcodeptr, uint32_t skipunits, uint32_t *firstcuptr,\n  int32_t *firstcuflagsptr, uint32_t *reqcuptr,int32_t *reqcuflagsptr,\n  branch_chain *bcptr, compile_block *cb, PCRE2_SIZE *lengthptr)\n{\nPCRE2_UCHAR *code = *codeptr;\nPCRE2_UCHAR *last_branch = code;\nPCRE2_UCHAR *start_bracket = code;\nBOOL lookbehind;\nopen_capitem capitem;\nint capnumber = 0;\nint okreturn = 1;\nuint32_t *pptr = *pptrptr;\nuint32_t firstcu, reqcu;\nuint32_t lookbehindlength;\nint32_t firstcuflags, reqcuflags;\nuint32_t branchfirstcu, branchreqcu;\nint32_t branchfirstcuflags, branchreqcuflags;\nPCRE2_SIZE length;\nbranch_chain bc;\n\n/* If set, call the external function that checks for stack availability. */\n\nif (cb->cx->stack_guard != NULL &&\n    cb->cx->stack_guard(cb->parens_depth, cb->cx->stack_guard_data))\n  {\n  *errorcodeptr= ERR33;\n  return 0;\n  }\n\n/* Miscellaneous initialization */\n\nbc.outer = bcptr;\nbc.current_branch = code;\n\nfirstcu = reqcu = 0;\nfirstcuflags = reqcuflags = REQ_UNSET;\n\n/* Accumulate the length for use in the pre-compile phase. Start with the\nlength of the BRA and KET and any extra code units that are required at the\nbeginning. We accumulate in a local variable to save frequent testing of\nlengthptr for NULL. We cannot do this by looking at the value of 'code' at the\nstart and end of each alternative, because compiled items are discarded during\nthe pre-compile phase so that the workspace is not exceeded. */\n\nlength = 2 + 2*LINK_SIZE + skipunits;\n\n/* Remember if this is a lookbehind assertion, and if it is, save its length\nand skip over the pattern offset. */\n\nlookbehind = *code == OP_ASSERTBACK ||\n             *code == OP_ASSERTBACK_NOT ||\n             *code == OP_ASSERTBACK_NA;\n\nif (lookbehind)\n  {\n  lookbehindlength = META_DATA(pptr\u00dd-1\u00a8);\n  pptr += SIZEOFFSET;\n  }\nelse lookbehindlength = 0;\n\n/* If this is a capturing subpattern, add to the chain of open capturing items\nso that we can detect them if (*ACCEPT) is encountered. Note that only OP_CBRA\nneed be tested here; changing this opcode to one of its variants, e.g.\nOP_SCBRAPOS, happens later, after the group has been compiled. */\n\nif (*code == OP_CBRA)\n  {\n  capnumber = GET2(code, 1 + LINK_SIZE);\n  capitem.number = capnumber;\n  capitem.next = cb->open_caps;\n  capitem.assert_depth = cb->assert_depth;\n  cb->open_caps = &capitem;\n  }\n\n/* Offset is set zero to mark that this bracket is still open */\n\nPUT(code, 1, 0);\ncode += 1 + LINK_SIZE + skipunits;\n\n/* Loop for each alternative branch */\n\nfor (;;)\n  {\n  int branch_return;\n\n  /* Insert OP_REVERSE if this is as lookbehind assertion. */\n\n  if (lookbehind && lookbehindlength > 0)\n    {\n    *code++ = OP_REVERSE;\n    PUTINC(code, 0, lookbehindlength);\n    length += 1 + LINK_SIZE;\n    }\n\n  /* Now compile the branch; in the pre-compile phase its length gets added\n  into the length. */\n\n  if ((branch_return =\n        compile_branch(&options, &code, &pptr, errorcodeptr, &branchfirstcu,\n          &branchfirstcuflags, &branchreqcu, &branchreqcuflags, &bc,\n          cb, (lengthptr == NULL)? NULL : &length)) == 0)\n    return 0;\n\n  /* If a branch can match an empty string, so can the whole group. */\n\n  if (branch_return < 0) okreturn = -1;\n\n  /* In the real compile phase, there is some post-processing to be done. */\n\n  if (lengthptr == NULL)\n    {\n    /* If this is the first branch, the firstcu and reqcu values for the\n    branch become the values for the regex. */\n\n    if (*last_branch != OP_ALT)\n      {\n      firstcu = branchfirstcu;\n      firstcuflags = branchfirstcuflags;\n      reqcu = branchreqcu;\n      reqcuflags = branchreqcuflags;\n      }\n\n    /* If this is not the first branch, the first char and reqcu have to\n    match the values from all the previous branches, except that if the\n    previous value for reqcu didn't have REQ_VARY set, it can still match,\n    and we set REQ_VARY for the group from this branch's value. */\n\n    else\n      {\n      /* If we previously had a firstcu, but it doesn't match the new branch,\n      we have to abandon the firstcu for the regex, but if there was\n      previously no reqcu, it takes on the value of the old firstcu. */\n\n      if (firstcuflags != branchfirstcuflags || firstcu != branchfirstcu)\n        {\n        if (firstcuflags >= 0)\n          {\n          if (reqcuflags < 0)\n            {\n            reqcu = firstcu;\n            reqcuflags = firstcuflags;\n            }\n          }\n        firstcuflags = REQ_NONE;\n        }\n\n      /* If we (now or from before) have no firstcu, a firstcu from the\n      branch becomes a reqcu if there isn't a branch reqcu. */\n\n      if (firstcuflags < 0 && branchfirstcuflags >= 0 &&\n          branchreqcuflags < 0)\n        {\n        branchreqcu = branchfirstcu;\n        branchreqcuflags = branchfirstcuflags;\n        }\n\n      /* Now ensure that the reqcus match */\n\n      if (((reqcuflags & ~REQ_VARY) != (branchreqcuflags & ~REQ_VARY)) ||\n          reqcu != branchreqcu)\n        reqcuflags = REQ_NONE;\n      else\n        {\n        reqcu = branchreqcu;\n        reqcuflags |= branchreqcuflags; /* To \"or\" REQ_VARY if present */\n        }\n      }\n    }\n\n  /* Handle reaching the end of the expression, either ')' or end of pattern.\n  In the real compile phase, go back through the alternative branches and\n  reverse the chain of offsets, with the field in the BRA item now becoming an\n  offset to the first alternative. If there are no alternatives, it points to\n  the end of the group. The length in the terminating ket is always the length\n  of the whole bracketed item. Return leaving the pointer at the terminating\n  char. */\n\n  if (META_CODE(*pptr) != META_ALT)\n    {\n    if (lengthptr == NULL)\n      {\n      PCRE2_SIZE branch_length = code - last_branch;\n      do\n        {\n        PCRE2_SIZE prev_length = GET(last_branch, 1);\n        PUT(last_branch, 1, branch_length);\n        branch_length = prev_length;\n        last_branch -= branch_length;\n        }\n      while (branch_length > 0);\n      }\n\n    /* Fill in the ket */\n\n    *code = OP_KET;\n    PUT(code, 1, (int)(code - start_bracket));\n    code += 1 + LINK_SIZE;\n\n    /* If it was a capturing subpattern, remove the block from the chain. */\n\n    if (capnumber > 0) cb->open_caps = cb->open_caps->next;\n\n    /* Set values to pass back */\n\n    *codeptr = code;\n    *pptrptr = pptr;\n    *firstcuptr = firstcu;\n    *firstcuflagsptr = firstcuflags;\n    *reqcuptr = reqcu;\n    *reqcuflagsptr = reqcuflags;\n    if (lengthptr != NULL)\n      {\n      if (OFLOW_MAX - *lengthptr < length)\n        {\n        *errorcodeptr = ERR20;\n        return 0;\n        }\n      *lengthptr += length;\n      }\n    return okreturn;\n    }\n\n  /* Another branch follows. In the pre-compile phase, we can move the code\n  pointer back to where it was for the start of the first branch. (That is,\n  pretend that each branch is the only one.)\n\n  In the real compile phase, insert an ALT node. Its length field points back\n  to the previous branch while the bracket remains open. At the end the chain\n  is reversed. It's done like this so that the start of the bracket has a\n  zero offset until it is closed, making it possible to detect recursion. */\n\n  if (lengthptr != NULL)\n    {\n    code = *codeptr + 1 + LINK_SIZE + skipunits;\n    length += 1 + LINK_SIZE;\n    }\n  else\n    {\n    *code = OP_ALT;\n    PUT(code, 1, (int)(code - last_branch));\n    bc.current_branch = last_branch = code;\n    code += 1 + LINK_SIZE;\n    }\n\n  /* Set the lookbehind length (if not in a lookbehind the value will be zero)\n  and then advance past the vertical bar. */\n\n  lookbehindlength = META_DATA(*pptr);\n  pptr++;\n  }\n/* Control never reaches here */\n}\n\n\n\n/*************************************************\n*          Check for anchored pattern            *\n*************************************************/\n\n/* Try to find out if this is an anchored regular expression. Consider each\nalternative branch. If they all start with OP_SOD or OP_CIRC, or with a bracket\nall of whose alternatives start with OP_SOD or OP_CIRC (recurse ad lib), then\nit's anchored. However, if this is a multiline pattern, then only OP_SOD will\nbe found, because \u00ac generates OP_CIRCM in that mode.\n\nWe can also consider a regex to be anchored if OP_SOM starts all its branches.\nThis is the code for \\G, which means \"match at start of match position, taking\ninto account the match offset\".\n\nA branch is also implicitly anchored if it starts with .* and DOTALL is set,\nbecause that will try the rest of the pattern at all possible matching points,\nso there is no point trying again.... er ....\n\n.... except when the .* appears inside capturing parentheses, and there is a\nsubsequent back reference to those parentheses. We haven't enough information\nto catch that case precisely.\n\nAt first, the best we could do was to detect when .* was in capturing brackets\nand the highest back reference was greater than or equal to that level.\nHowever, by keeping a bitmap of the first 31 back references, we can catch some\nof the more common cases more precisely.\n\n... A second exception is when the .* appears inside an atomic group, because\nthis prevents the number of characters it matches from being adjusted.\n\nArguments:\n  code           points to start of the compiled pattern\n  bracket_map    a bitmap of which brackets we are inside while testing; this\n                   handles up to substring 31; after that we just have to take\n                   the less precise approach\n  cb             points to the compile data block\n  atomcount      atomic group level\n  inassert       TRUE if in an assertion\n\nReturns:     TRUE or FALSE\n*/\n\nstatic BOOL\nis_anchored(PCRE2_SPTR code, unsigned int bracket_map, compile_block *cb,\n  int atomcount, BOOL inassert)\n{\ndo {\n   PCRE2_SPTR scode = first_significant_code(\n     code + PRIV(OP_lengths)\u00dd*code\u00a8, FALSE);\n   int op = *scode;\n\n   /* Non-capturing brackets */\n\n   if (op == OP_BRA  || op == OP_BRAPOS ||\n       op == OP_SBRA || op == OP_SBRAPOS)\n     {\n     if (!is_anchored(scode, bracket_map, cb, atomcount, inassert))\n       return FALSE;\n     }\n\n   /* Capturing brackets */\n\n   else if (op == OP_CBRA  || op == OP_CBRAPOS ||\n            op == OP_SCBRA || op == OP_SCBRAPOS)\n     {\n     int n = GET2(scode, 1+LINK_SIZE);\n     int new_map = bracket_map | ((n < 32)? (1u << n) : 1);\n     if (!is_anchored(scode, new_map, cb, atomcount, inassert)) return FALSE;\n     }\n\n   /* Positive forward assertion */\n\n   else if (op == OP_ASSERT || op == OP_ASSERT_NA)\n     {\n     if (!is_anchored(scode, bracket_map, cb, atomcount, TRUE)) return FALSE;\n     }\n\n   /* Condition. If there is no second branch, it can't be anchored. */\n\n   else if (op == OP_COND || op == OP_SCOND)\n     {\n     if (scode\u00ddGET(scode,1)\u00a8 != OP_ALT) return FALSE;\n     if (!is_anchored(scode, bracket_map, cb, atomcount, inassert))\n       return FALSE;\n     }\n\n   /* Atomic groups */\n\n   else if (op == OP_ONCE)\n     {\n     if (!is_anchored(scode, bracket_map, cb, atomcount + 1, inassert))\n       return FALSE;\n     }\n\n   /* .* is not anchored unless DOTALL is set (which generates OP_ALLANY) and\n   it isn't in brackets that are or may be referenced or inside an atomic\n   group or an assertion. Also the pattern must not contain *PRUNE or *SKIP,\n   because these break the feature. Consider, for example, /(?s).*?(*PRUNE)b/\n   with the subject \"aab\", which matches \"b\", i.e. not at the start of a line.\n   There is also an option that disables auto-anchoring. */\n\n   else if ((op == OP_TYPESTAR || op == OP_TYPEMINSTAR ||\n             op == OP_TYPEPOSSTAR))\n     {\n     if (scode\u00dd1\u00a8 != OP_ALLANY || (bracket_map & cb->backref_map) != 0 ||\n         atomcount > 0 || cb->had_pruneorskip || inassert ||\n         (cb->external_options & PCRE2_NO_DOTSTAR_ANCHOR) != 0)\n       return FALSE;\n     }\n\n   /* Check for explicit anchoring */\n\n   else if (op != OP_SOD && op != OP_SOM && op != OP_CIRC) return FALSE;\n\n   code += GET(code, 1);\n   }\nwhile (*code == OP_ALT);   /* Loop for each alternative */\nreturn TRUE;\n}\n\n\n\n/*************************************************\n*         Check for starting with \u00ac or .*        *\n*************************************************/\n\n/* This is called to find out if every branch starts with \u00ac or .* so that\n\"first char\" processing can be done to speed things up in multiline\nmatching and for non-DOTALL patterns that start with .* (which must start at\nthe beginning or after \\n). As in the case of is_anchored() (see above), we\nhave to take account of back references to capturing brackets that contain .*\nbecause in that case we can't make the assumption. Also, the appearance of .*\ninside atomic brackets or in an assertion, or in a pattern that contains *PRUNE\nor *SKIP does not count, because once again the assumption no longer holds.\n\nArguments:\n  code           points to start of the compiled pattern or a group\n  bracket_map    a bitmap of which brackets we are inside while testing; this\n                   handles up to substring 31; after that we just have to take\n                   the less precise approach\n  cb             points to the compile data\n  atomcount      atomic group level\n  inassert       TRUE if in an assertion\n\nReturns:         TRUE or FALSE\n*/\n\nstatic BOOL\nis_startline(PCRE2_SPTR code, unsigned int bracket_map, compile_block *cb,\n  int atomcount, BOOL inassert)\n{\ndo {\n   PCRE2_SPTR scode = first_significant_code(\n     code + PRIV(OP_lengths)\u00dd*code\u00a8, FALSE);\n   int op = *scode;\n\n   /* If we are at the start of a conditional assertion group, *both* the\n   conditional assertion *and* what follows the condition must satisfy the test\n   for start of line. Other kinds of condition fail. Note that there may be an\n   auto-callout at the start of a condition. */\n\n   if (op == OP_COND)\n     {\n     scode += 1 + LINK_SIZE;\n\n     if (*scode == OP_CALLOUT) scode += PRIV(OP_lengths)\u00ddOP_CALLOUT\u00a8;\n       else if (*scode == OP_CALLOUT_STR) scode += GET(scode, 1 + 2*LINK_SIZE);\n\n     switch (*scode)\n       {\n       case OP_CREF:\n       case OP_DNCREF:\n       case OP_RREF:\n       case OP_DNRREF:\n       case OP_FAIL:\n       case OP_FALSE:\n       case OP_TRUE:\n       return FALSE;\n\n       default:     /* Assertion */\n       if (!is_startline(scode, bracket_map, cb, atomcount, TRUE)) return FALSE;\n       do scode += GET(scode, 1); while (*scode == OP_ALT);\n       scode += 1 + LINK_SIZE;\n       break;\n       }\n     scode = first_significant_code(scode, FALSE);\n     op = *scode;\n     }\n\n   /* Non-capturing brackets */\n\n   if (op == OP_BRA  || op == OP_BRAPOS ||\n       op == OP_SBRA || op == OP_SBRAPOS)\n     {\n     if (!is_startline(scode, bracket_map, cb, atomcount, inassert))\n       return FALSE;\n     }\n\n   /* Capturing brackets */\n\n   else if (op == OP_CBRA  || op == OP_CBRAPOS ||\n            op == OP_SCBRA || op == OP_SCBRAPOS)\n     {\n     int n = GET2(scode, 1+LINK_SIZE);\n     int new_map = bracket_map | ((n < 32)? (1u << n) : 1);\n     if (!is_startline(scode, new_map, cb, atomcount, inassert)) return FALSE;\n     }\n\n   /* Positive forward assertions */\n\n   else if (op == OP_ASSERT || op == OP_ASSERT_NA)\n     {\n     if (!is_startline(scode, bracket_map, cb, atomcount, TRUE))\n       return FALSE;\n     }\n\n   /* Atomic brackets */\n\n   else if (op == OP_ONCE)\n     {\n     if (!is_startline(scode, bracket_map, cb, atomcount + 1, inassert))\n       return FALSE;\n     }\n\n   /* .* means \"start at start or after \\n\" if it isn't in atomic brackets or\n   brackets that may be referenced or an assertion, and as long as the pattern\n   does not contain *PRUNE or *SKIP, because these break the feature. Consider,\n   for example, /.*?a(*PRUNE)b/ with the subject \"aab\", which matches \"ab\",\n   i.e. not at the start of a line. There is also an option that disables this\n   optimization. */\n\n   else if (op == OP_TYPESTAR || op == OP_TYPEMINSTAR || op == OP_TYPEPOSSTAR)\n     {\n     if (scode\u00dd1\u00a8 != OP_ANY || (bracket_map & cb->backref_map) != 0 ||\n         atomcount > 0 || cb->had_pruneorskip || inassert ||\n         (cb->external_options & PCRE2_NO_DOTSTAR_ANCHOR) != 0)\n       return FALSE;\n     }\n\n   /* Check for explicit circumflex; anything else gives a FALSE result. Note\n   in particular that this includes atomic brackets OP_ONCE because the number\n   of characters matched by .* cannot be adjusted inside them. */\n\n   else if (op != OP_CIRC && op != OP_CIRCM) return FALSE;\n\n   /* Move on to the next alternative */\n\n   code += GET(code, 1);\n   }\nwhile (*code == OP_ALT);  /* Loop for each alternative */\nreturn TRUE;\n}\n\n\n\n/*************************************************\n*   Scan compiled regex for recursion reference  *\n*************************************************/\n\n/* This function scans through a compiled pattern until it finds an instance of\nOP_RECURSE.\n\nArguments:\n  code        points to start of expression\n  utf         TRUE in UTF mode\n\nReturns:      pointer to the opcode for OP_RECURSE, or NULL if not found\n*/\n\nstatic PCRE2_SPTR\nfind_recurse(PCRE2_SPTR code, BOOL utf)\n{\nfor (;;)\n  {\n  PCRE2_UCHAR c = *code;\n  if (c == OP_END) return NULL;\n  if (c == OP_RECURSE) return code;\n\n  /* XCLASS is used for classes that cannot be represented just by a bit map.\n  This includes negated single high-valued characters. CALLOUT_STR is used for\n  callouts with string arguments. In both cases the length in the table is\n  zero; the actual length is stored in the compiled code. */\n\n  if (c == OP_XCLASS) code += GET(code, 1);\n    else if (c == OP_CALLOUT_STR) code += GET(code, 1 + 2*LINK_SIZE);\n\n  /* Otherwise, we can get the item's length from the table, except that for\n  repeated character types, we have to test for \\p and \\P, which have an extra\n  two code units of parameters, and for MARK/PRUNE/SKIP/THEN with an argument,\n  we must add in its length. */\n\n  else\n    {\n    switch(c)\n      {\n      case OP_TYPESTAR:\n      case OP_TYPEMINSTAR:\n      case OP_TYPEPLUS:\n      case OP_TYPEMINPLUS:\n      case OP_TYPEQUERY:\n      case OP_TYPEMINQUERY:\n      case OP_TYPEPOSSTAR:\n      case OP_TYPEPOSPLUS:\n      case OP_TYPEPOSQUERY:\n      if (code\u00dd1\u00a8 == OP_PROP || code\u00dd1\u00a8 == OP_NOTPROP) code += 2;\n      break;\n\n      case OP_TYPEPOSUPTO:\n      case OP_TYPEUPTO:\n      case OP_TYPEMINUPTO:\n      case OP_TYPEEXACT:\n      if (code\u00dd1 + IMM2_SIZE\u00a8 == OP_PROP || code\u00dd1 + IMM2_SIZE\u00a8 == OP_NOTPROP)\n        code += 2;\n      break;\n\n      case OP_MARK:\n      case OP_COMMIT_ARG:\n      case OP_PRUNE_ARG:\n      case OP_SKIP_ARG:\n      case OP_THEN_ARG:\n      code += code\u00dd1\u00a8;\n      break;\n      }\n\n    /* Add in the fixed length from the table */\n\n    code += PRIV(OP_lengths)\u00ddc\u00a8;\n\n    /* In UTF-8 and UTF-16 modes, opcodes that are followed by a character may\n    be followed by a multi-unit character. The length in the table is a\n    minimum, so we have to arrange to skip the extra units. */\n\n#ifdef MAYBE_UTF_MULTI\n    if (utf) switch(c)\n      {\n      case OP_CHAR:\n      case OP_CHARI:\n      case OP_NOT:\n      case OP_NOTI:\n      case OP_EXACT:\n      case OP_EXACTI:\n      case OP_NOTEXACT:\n      case OP_NOTEXACTI:\n      case OP_UPTO:\n      case OP_UPTOI:\n      case OP_NOTUPTO:\n      case OP_NOTUPTOI:\n      case OP_MINUPTO:\n      case OP_MINUPTOI:\n      case OP_NOTMINUPTO:\n      case OP_NOTMINUPTOI:\n      case OP_POSUPTO:\n      case OP_POSUPTOI:\n      case OP_NOTPOSUPTO:\n      case OP_NOTPOSUPTOI:\n      case OP_STAR:\n      case OP_STARI:\n      case OP_NOTSTAR:\n      case OP_NOTSTARI:\n      case OP_MINSTAR:\n      case OP_MINSTARI:\n      case OP_NOTMINSTAR:\n      case OP_NOTMINSTARI:\n      case OP_POSSTAR:\n      case OP_POSSTARI:\n      case OP_NOTPOSSTAR:\n      case OP_NOTPOSSTARI:\n      case OP_PLUS:\n      case OP_PLUSI:\n      case OP_NOTPLUS:\n      case OP_NOTPLUSI:\n      case OP_MINPLUS:\n      case OP_MINPLUSI:\n      case OP_NOTMINPLUS:\n      case OP_NOTMINPLUSI:\n      case OP_POSPLUS:\n      case OP_POSPLUSI:\n      case OP_NOTPOSPLUS:\n      case OP_NOTPOSPLUSI:\n      case OP_QUERY:\n      case OP_QUERYI:\n      case OP_NOTQUERY:\n      case OP_NOTQUERYI:\n      case OP_MINQUERY:\n      case OP_MINQUERYI:\n      case OP_NOTMINQUERY:\n      case OP_NOTMINQUERYI:\n      case OP_POSQUERY:\n      case OP_POSQUERYI:\n      case OP_NOTPOSQUERY:\n      case OP_NOTPOSQUERYI:\n      if (HAS_EXTRALEN(code\u00dd-1\u00a8)) code += GET_EXTRALEN(code\u00dd-1\u00a8);\n      break;\n      }\n#else\n    (void)(utf);  /* Keep compiler happy by referencing function argument */\n#endif  /* MAYBE_UTF_MULTI */\n    }\n  }\n}\n\n\n\n/*************************************************\n*    Check for asserted fixed first code unit    *\n*************************************************/\n\n/* During compilation, the \"first code unit\" settings from forward assertions\nare discarded, because they can cause conflicts with actual literals that\nfollow. However, if we end up without a first code unit setting for an\nunanchored pattern, it is worth scanning the regex to see if there is an\ninitial asserted first code unit. If all branches start with the same asserted\ncode unit, or with a non-conditional bracket all of whose alternatives start\nwith the same asserted code unit (recurse ad lib), then we return that code\nunit, with the flags set to zero or REQ_CASELESS; otherwise return zero with\nREQ_NONE in the flags.\n\nArguments:\n  code       points to start of compiled pattern\n  flags      points to the first code unit flags\n  inassert   non-zero if in an assertion\n\nReturns:     the fixed first code unit, or 0 with REQ_NONE in flags\n*/\n\nstatic uint32_t\nfind_firstassertedcu(PCRE2_SPTR code, int32_t *flags, uint32_t inassert)\n{\nuint32_t c = 0;\nint cflags = REQ_NONE;\n\n*flags = REQ_NONE;\ndo {\n   uint32_t d;\n   int dflags;\n   int xl = (*code == OP_CBRA || *code == OP_SCBRA ||\n             *code == OP_CBRAPOS || *code == OP_SCBRAPOS)? IMM2_SIZE:0;\n   PCRE2_SPTR scode = first_significant_code(code + 1+LINK_SIZE + xl, TRUE);\n   PCRE2_UCHAR op = *scode;\n\n   switch(op)\n     {\n     default:\n     return 0;\n\n     case OP_BRA:\n     case OP_BRAPOS:\n     case OP_CBRA:\n     case OP_SCBRA:\n     case OP_CBRAPOS:\n     case OP_SCBRAPOS:\n     case OP_ASSERT:\n     case OP_ASSERT_NA:\n     case OP_ONCE:\n     case OP_SCRIPT_RUN:\n     d = find_firstassertedcu(scode, &dflags, inassert +\n       ((op == OP_ASSERT || op == OP_ASSERT_NA)?1:0));\n     if (dflags < 0)\n       return 0;\n     if (cflags < 0) { c = d; cflags = dflags; }\n       else if (c != d || cflags != dflags) return 0;\n     break;\n\n     case OP_EXACT:\n     scode += IMM2_SIZE;\n     /* Fall through */\n\n     case OP_CHAR:\n     case OP_PLUS:\n     case OP_MINPLUS:\n     case OP_POSPLUS:\n     if (inassert == 0) return 0;\n     if (cflags < 0) { c = scode\u00dd1\u00a8; cflags = 0; }\n       else if (c != scode\u00dd1\u00a8) return 0;\n     break;\n\n     case OP_EXACTI:\n     scode += IMM2_SIZE;\n     /* Fall through */\n\n     case OP_CHARI:\n     case OP_PLUSI:\n     case OP_MINPLUSI:\n     case OP_POSPLUSI:\n     if (inassert == 0) return 0;\n\n     /* If the character is more than one code unit long, we cannot set its\n     first code unit when matching caselessly. Later scanning may pick up\n     multiple code units. */\n\n#ifdef SUPPORT_UNICODE\n#if PCRE2_CODE_UNIT_WIDTH == 8\n     if (scode\u00dd1\u00a8 >= 0x80) return 0;\n#elif PCRE2_CODE_UNIT_WIDTH == 16\n     if (scode\u00dd1\u00a8 >= 0xd800 && scode\u00dd1\u00a8 <= 0xdfff) return 0;\n#endif\n#endif\n\n     if (cflags < 0) { c = scode\u00dd1\u00a8; cflags = REQ_CASELESS; }\n       else if (c != scode\u00dd1\u00a8) return 0;\n     break;\n     }\n\n   code += GET(code, 1);\n   }\nwhile (*code == OP_ALT);\n\n*flags = cflags;\nreturn c;\n}\n\n\n\n/*************************************************\n*     Add an entry to the name/number table      *\n*************************************************/\n\n/* This function is called between compiling passes to add an entry to the\nname/number table, maintaining alphabetical order. Checking for permitted\nand forbidden duplicates has already been done.\n\nArguments:\n  cb           the compile data block\n  name         the name to add\n  length       the length of the name\n  groupno      the group number\n  tablecount   the count of names in the table so far\n\nReturns:       nothing\n*/\n\nstatic void\nadd_name_to_table(compile_block *cb, PCRE2_SPTR name, int length,\n  unsigned int groupno, uint32_t tablecount)\n{\nuint32_t i;\nPCRE2_UCHAR *slot = cb->name_table;\n\nfor (i = 0; i < tablecount; i++)\n  {\n  int crc = memcmp(name, slot+IMM2_SIZE, CU2BYTES(length));\n  if (crc == 0 && slot\u00ddIMM2_SIZE+length\u00a8 != 0)\n    crc = -1; /* Current name is a substring */\n\n  /* Make space in the table and break the loop for an earlier name. For a\n  duplicate or later name, carry on. We do this for duplicates so that in the\n  simple case (when ?(| is not used) they are in order of their numbers. In all\n  cases they are in the order in which they appear in the pattern. */\n\n  if (crc < 0)\n    {\n    (void)memmove(slot + cb->name_entry_size, slot,\n      CU2BYTES((tablecount - i) * cb->name_entry_size));\n    break;\n    }\n\n  /* Continue the loop for a later or duplicate name */\n\n  slot += cb->name_entry_size;\n  }\n\nPUT2(slot, 0, groupno);\nmemcpy(slot + IMM2_SIZE, name, CU2BYTES(length));\n\n/* Add a terminating zero and fill the rest of the slot with zeroes so that\nthe memory is all initialized. Otherwise valgrind moans about uninitialized\nmemory when saving serialized compiled patterns. */\n\nmemset(slot + IMM2_SIZE + length, 0,\n  CU2BYTES(cb->name_entry_size - length - IMM2_SIZE));\n}\n\n\n\n/*************************************************\n*             Skip in parsed pattern             *\n*************************************************/\n\n/* This function is called to skip parts of the parsed pattern when finding the\nlength of a lookbehind branch. It is called after (*ACCEPT) and (*FAIL) to find\nthe end of the branch, it is called to skip over an internal lookaround or\n(DEFINE) group, and it is also called to skip to the end of a class, during\nwhich it will never encounter nested groups (but there's no need to have\nspecial code for that).\n\nWhen called to find the end of a branch or group, pptr must point to the first\nmeta code inside the branch, not the branch-starting code. In other cases it\ncan point to the item that causes the function to be called.\n\nArguments:\n  pptr       current pointer to skip from\n  skiptype   PSKIP_CLASS when skipping to end of class\n             PSKIP_ALT when META_ALT ends the skip\n             PSKIP_KET when only META_KET ends the skip\n\nReturns:     new value of pptr\n             NULL if META_END is reached - should never occur\n               or for an unknown meta value - likewise\n*/\n\nstatic uint32_t *\nparsed_skip(uint32_t *pptr, uint32_t skiptype)\n{\nuint32_t nestlevel = 0;\n\nfor (;; pptr++)\n  {\n  uint32_t meta = META_CODE(*pptr);\n\n  switch(meta)\n    {\n    default:  /* Just skip over most items */\n    if (meta < META_END) continue;  /* Literal */\n    break;\n\n    /* This should never occur. */\n\n    case META_END:\n    return NULL;\n\n    /* The data for these items is variable in length. */\n\n    case META_BACKREF:  /* Offset is present only if group >= 10 */\n    if (META_DATA(*pptr) >= 10) pptr += SIZEOFFSET;\n    break;\n\n    case META_ESCAPE:   /* A few escapes are followed by data items. */\n    switch (META_DATA(*pptr))\n      {\n      case ESC_P:\n      case ESC_p:\n      pptr += 1;\n      break;\n\n      case ESC_g:\n      case ESC_k:\n      pptr += 1 + SIZEOFFSET;\n      break;\n      }\n    break;\n\n    case META_MARK:     /* Add the length of the name. */\n    case META_COMMIT_ARG:\n    case META_PRUNE_ARG:\n    case META_SKIP_ARG:\n    case META_THEN_ARG:\n    pptr += pptr\u00dd1\u00a8;\n    break;\n\n    /* These are the \"active\" items in this loop. */\n\n    case META_CLASS_END:\n    if (skiptype == PSKIP_CLASS) return pptr;\n    break;\n\n    case META_ATOMIC:\n    case META_CAPTURE:\n    case META_COND_ASSERT:\n    case META_COND_DEFINE:\n    case META_COND_NAME:\n    case META_COND_NUMBER:\n    case META_COND_RNAME:\n    case META_COND_RNUMBER:\n    case META_COND_VERSION:\n    case META_LOOKAHEAD:\n    case META_LOOKAHEADNOT:\n    case META_LOOKAHEAD_NA:\n    case META_LOOKBEHIND:\n    case META_LOOKBEHINDNOT:\n    case META_LOOKBEHIND_NA:\n    case META_NOCAPTURE:\n    case META_SCRIPT_RUN:\n    nestlevel++;\n    break;\n\n    case META_ALT:\n    if (nestlevel == 0 && skiptype == PSKIP_ALT) return pptr;\n    break;\n\n    case META_KET:\n    if (nestlevel == 0) return pptr;\n    nestlevel--;\n    break;\n    }\n\n  /* The extra data item length for each meta is in a table. */\n\n  meta = (meta >> 16) & 0x7fff;\n  if (meta >= sizeof(meta_extra_lengths)) return NULL;\n  pptr += meta_extra_lengths\u00ddmeta\u00a8;\n  }\n/* Control never reaches here */\nreturn pptr;\n}\n\n\n\n/*************************************************\n*       Find length of a parsed group            *\n*************************************************/\n\n/* This is called for nested groups within a branch of a lookbehind whose\nlength is being computed. If all the branches in the nested group have the same\nlength, that is OK. On entry, the pointer must be at the first element after\nthe group initializing code. On exit it points to OP_KET. Caching is used to\nimprove processing speed when the same capturing group occurs many times.\n\nArguments:\n  pptrptr     pointer to pointer in the parsed pattern\n  isinline    FALSE if a reference or recursion; TRUE for inline group\n  errcodeptr  pointer to the errorcode\n  lcptr       pointer to the loop counter\n  group       number of captured group or -1 for a non-capturing group\n  recurses    chain of recurse_check to catch mutual recursion\n  cb          pointer to the compile data\n\nReturns:      the group length or a negative number\n*/\n\nstatic int\nget_grouplength(uint32_t **pptrptr, BOOL isinline, int *errcodeptr, int *lcptr,\n   int group, parsed_recurse_check *recurses, compile_block *cb)\n{\nint branchlength;\nint grouplength = -1;\n\n/* The cache can be used only if there is no possibility of there being two\ngroups with the same number. We do not need to set the end pointer for a group\nthat is being processed as a back reference or recursion, but we must do so for\nan inline group. */\n\nif (group > 0 && (cb->external_flags & PCRE2_DUPCAPUSED) == 0)\n  {\n  uint32_t groupinfo = cb->groupinfo\u00ddgroup\u00a8;\n  if ((groupinfo & GI_NOT_FIXED_LENGTH) != 0) return -1;\n  if ((groupinfo & GI_SET_FIXED_LENGTH) != 0)\n    {\n    if (isinline) *pptrptr = parsed_skip(*pptrptr, PSKIP_KET);\n    return groupinfo & GI_FIXED_LENGTH_MASK;\n    }\n  }\n\n/* Scan the group. In this case we find the end pointer of necessity. */\n\nfor(;;)\n  {\n  branchlength = get_branchlength(pptrptr, errcodeptr, lcptr, recurses, cb);\n  if (branchlength < 0) goto ISNOTFIXED;\n  if (grouplength == -1) grouplength = branchlength;\n    else if (grouplength != branchlength) goto ISNOTFIXED;\n  if (**pptrptr == META_KET) break;\n  *pptrptr += 1;   /* Skip META_ALT */\n  }\n\nif (group > 0)\n  cb->groupinfo\u00ddgroup\u00a8 |= (uint32_t)(GI_SET_FIXED_LENGTH | grouplength);\nreturn grouplength;\n\nISNOTFIXED:\nif (group > 0) cb->groupinfo\u00ddgroup\u00a8 |= GI_NOT_FIXED_LENGTH;\nreturn -1;\n}\n\n\n\n/*************************************************\n*        Find length of a parsed branch          *\n*************************************************/\n\n/* Return a fixed length for a branch in a lookbehind, giving an error if the\nlength is not fixed. On entry, *pptrptr points to the first element inside the\nbranch. On exit it is set to point to the ALT or KET.\n\nArguments:\n  pptrptr     pointer to pointer in the parsed pattern\n  errcodeptr  pointer to error code\n  lcptr       pointer to loop counter\n  recurses    chain of recurse_check to catch mutual recursion\n  cb          pointer to compile block\n\nReturns:      the length, or a negative value on error\n*/\n\nstatic int\nget_branchlength(uint32_t **pptrptr, int *errcodeptr, int *lcptr,\n  parsed_recurse_check *recurses, compile_block *cb)\n{\nint branchlength = 0;\nint grouplength;\nuint32_t lastitemlength = 0;\nuint32_t *pptr = *pptrptr;\nPCRE2_SIZE offset;\nparsed_recurse_check this_recurse;\n\n/* A large and/or complex regex can take too long to process. This can happen\nmore often when (?| groups are present in the pattern because their length\ncannot be cached. */\n\nif ((*lcptr)++ > 2000)\n  {\n  *errcodeptr = ERR35;  /* Lookbehind is too complicated */\n  return -1;\n  }\n\n/* Scan the branch, accumulating the length. */\n\nfor (;; pptr++)\n  {\n  parsed_recurse_check *r;\n  uint32_t *gptr, *gptrend;\n  uint32_t escape;\n  uint32_t group = 0;\n  uint32_t itemlength = 0;\n\n  if (*pptr < META_END)\n    {\n    itemlength = 1;\n    }\n\n  else switch (META_CODE(*pptr))\n    {\n    case META_KET:\n    case META_ALT:\n    goto EXIT;\n\n    /* (*ACCEPT) and (*FAIL) terminate the branch, but we must skip to the\n    actual termination. */\n\n    case META_ACCEPT:\n    case META_FAIL:\n    pptr = parsed_skip(pptr, PSKIP_ALT);\n    if (pptr == NULL) goto PARSED_SKIP_FAILED;\n    goto EXIT;\n\n    case META_MARK:\n    case META_COMMIT_ARG:\n    case META_PRUNE_ARG:\n    case META_SKIP_ARG:\n    case META_THEN_ARG:\n    pptr += pptr\u00dd1\u00a8 + 1;\n    break;\n\n    case META_CIRCUMFLEX:\n    case META_COMMIT:\n    case META_DOLLAR:\n    case META_PRUNE:\n    case META_SKIP:\n    case META_THEN:\n    break;\n\n    case META_OPTIONS:\n    pptr += 1;\n    break;\n\n    case META_BIGVALUE:\n    itemlength = 1;\n    pptr += 1;\n    break;\n\n    case META_CLASS:\n    case META_CLASS_NOT:\n    itemlength = 1;\n    pptr = parsed_skip(pptr, PSKIP_CLASS);\n    if (pptr == NULL) goto PARSED_SKIP_FAILED;\n    break;\n\n    case META_CLASS_EMPTY_NOT:\n    case META_DOT:\n    itemlength = 1;\n    break;\n\n    case META_CALLOUT_NUMBER:\n    pptr += 3;\n    break;\n\n    case META_CALLOUT_STRING:\n    pptr += 3 + SIZEOFFSET;\n    break;\n\n    /* Only some escapes consume a character. Of those, \\R and \\X are never\n    allowed because they might match more than character. \\C is allowed only in\n    32-bit and non-UTF 8/16-bit modes. */\n\n    case META_ESCAPE:\n    escape = META_DATA(*pptr);\n    if (escape == ESC_R || escape == ESC_X) return -1;\n    if (escape > ESC_b && escape < ESC_Z)\n      {\n#if PCRE2_CODE_UNIT_WIDTH != 32\n      if ((cb->external_options & PCRE2_UTF) != 0 && escape == ESC_C)\n        {\n        *errcodeptr = ERR36;\n        return -1;\n        }\n#endif\n      itemlength = 1;\n      if (escape == ESC_p || escape == ESC_P) pptr++;  /* Skip prop data */\n      }\n    break;\n\n    /* Lookaheads do not contribute to the length of this branch, but they may\n    contain lookbehinds within them whose lengths need to be set. */\n\n    case META_LOOKAHEAD:\n    case META_LOOKAHEADNOT:\n    case META_LOOKAHEAD_NA:\n    *errcodeptr = check_lookbehinds(pptr + 1, &pptr, recurses, cb);\n    if (*errcodeptr != 0) return -1;\n\n    /* Ignore any qualifiers that follow a lookahead assertion. */\n\n    switch (pptr\u00dd1\u00a8)\n      {\n      case META_ASTERISK:\n      case META_ASTERISK_PLUS:\n      case META_ASTERISK_QUERY:\n      case META_PLUS:\n      case META_PLUS_PLUS:\n      case META_PLUS_QUERY:\n      case META_QUERY:\n      case META_QUERY_PLUS:\n      case META_QUERY_QUERY:\n      pptr++;\n      break;\n\n      case META_MINMAX:\n      case META_MINMAX_PLUS:\n      case META_MINMAX_QUERY:\n      pptr += 3;\n      break;\n\n      default:\n      break;\n      }\n    break;\n\n    /* A nested lookbehind does not contribute any length to this lookbehind,\n    but must itself be checked and have its lengths set. */\n\n    case META_LOOKBEHIND:\n    case META_LOOKBEHINDNOT:\n    case META_LOOKBEHIND_NA:\n    if (!set_lookbehind_lengths(&pptr, errcodeptr, lcptr, recurses, cb))\n      return -1;\n    break;\n\n    /* Back references and recursions are handled by very similar code. At this\n    stage, the names generated in the parsing pass are available, but the main\n    name table has not yet been created. So for the named varieties, scan the\n    list of names in order to get the number of the first one in the pattern,\n    and whether or not this name is duplicated. */\n\n    case META_BACKREF_BYNAME:\n    if ((cb->external_options & PCRE2_MATCH_UNSET_BACKREF) != 0)\n      goto ISNOTFIXED;\n    /* Fall through */\n\n    case META_RECURSE_BYNAME:\n      {\n      int i;\n      PCRE2_SPTR name;\n      BOOL is_dupname = FALSE;\n      named_group *ng = cb->named_groups;\n      uint32_t meta_code = META_CODE(*pptr);\n      uint32_t length = *(++pptr);\n\n      GETPLUSOFFSET(offset, pptr);\n      name = cb->start_pattern + offset;\n      for (i = 0; i < cb->names_found; i++, ng++)\n        {\n        if (length == ng->length && PRIV(strncmp)(name, ng->name, length) == 0)\n          {\n          group = ng->number;\n          is_dupname = ng->isdup;\n          break;\n          }\n        }\n\n      if (group == 0)\n        {\n        *errcodeptr = ERR15;  /* Non-existent subpattern */\n        cb->erroroffset = offset;\n        return -1;\n        }\n\n      /* A numerical back reference can be fixed length if duplicate capturing\n      groups are not being used. A non-duplicate named back reference can also\n      be handled. */\n\n      if (meta_code == META_RECURSE_BYNAME ||\n          (!is_dupname && (cb->external_flags & PCRE2_DUPCAPUSED) == 0))\n        goto RECURSE_OR_BACKREF_LENGTH;  /* Handle as a numbered version. */\n      }\n    goto ISNOTFIXED;                     /* Duplicate name or number */\n\n    /* The offset values for back references < 10 are in a separate vector\n    because otherwise they would use more than two parsed pattern elements on\n    64-bit systems. */\n\n    case META_BACKREF:\n    if ((cb->external_options & PCRE2_MATCH_UNSET_BACKREF) != 0 ||\n        (cb->external_flags & PCRE2_DUPCAPUSED) != 0)\n      goto ISNOTFIXED;\n    group = META_DATA(*pptr);\n    if (group < 10)\n      {\n      offset = cb->small_ref_offset\u00ddgroup\u00a8;\n      goto RECURSE_OR_BACKREF_LENGTH;\n      }\n\n    /* Fall through */\n    /* For groups >= 10 - picking up group twice does no harm. */\n\n    /* A true recursion implies not fixed length, but a subroutine call may\n    be OK. Back reference \"recursions\" are also failed. */\n\n    case META_RECURSE:\n    group = META_DATA(*pptr);\n    GETPLUSOFFSET(offset, pptr);\n\n    RECURSE_OR_BACKREF_LENGTH:\n    if (group > cb->bracount)\n      {\n      cb->erroroffset = offset;\n      *errcodeptr = ERR15;  /* Non-existent subpattern */\n      return -1;\n      }\n    if (group == 0) goto ISNOTFIXED;  /* Local recursion */\n    for (gptr = cb->parsed_pattern; *gptr != META_END; gptr++)\n      {\n      if (META_CODE(*gptr) == META_BIGVALUE) gptr++;\n        else if (*gptr == (META_CAPTURE | group)) break;\n      }\n\n    /* We must start the search for the end of the group at the first meta code\n    inside the group. Otherwise it will be treated as an enclosed group. */\n\n    gptrend = parsed_skip(gptr + 1, PSKIP_KET);\n    if (gptrend == NULL) goto PARSED_SKIP_FAILED;\n    if (pptr > gptr && pptr < gptrend) goto ISNOTFIXED;  /* Local recursion */\n    for (r = recurses; r != NULL; r = r->prev) if (r->groupptr == gptr) break;\n    if (r != NULL) goto ISNOTFIXED;   /* Mutual recursion */\n    this_recurse.prev = recurses;\n    this_recurse.groupptr = gptr;\n\n    /* We do not need to know the position of the end of the group, that is,\n    gptr is not used after the call to get_grouplength(). Setting the second\n    argument FALSE stops it scanning for the end when the length can be found\n    in the cache. */\n\n    gptr++;\n    grouplength = get_grouplength(&gptr, FALSE, errcodeptr, lcptr, group,\n      &this_recurse, cb);\n    if (grouplength < 0)\n      {\n      if (*errcodeptr == 0) goto ISNOTFIXED;\n      return -1;  /* Error already set */\n      }\n    itemlength = grouplength;\n    break;\n\n    /* A (DEFINE) group is never obeyed inline and so it does not contribute to\n    the length of this branch. Skip from the following item to the next\n    unpaired ket. */\n\n    case META_COND_DEFINE:\n    pptr = parsed_skip(pptr + 1, PSKIP_KET);\n    break;\n\n    /* Check other nested groups - advance past the initial data for each type\n    and then seek a fixed length with get_grouplength(). */\n\n    case META_COND_NAME:\n    case META_COND_NUMBER:\n    case META_COND_RNAME:\n    case META_COND_RNUMBER:\n    pptr += 2 + SIZEOFFSET;\n    goto CHECK_GROUP;\n\n    case META_COND_ASSERT:\n    pptr += 1;\n    goto CHECK_GROUP;\n\n    case META_COND_VERSION:\n    pptr += 4;\n    goto CHECK_GROUP;\n\n    case META_CAPTURE:\n    group = META_DATA(*pptr);\n    /* Fall through */\n\n    case META_ATOMIC:\n    case META_NOCAPTURE:\n    case META_SCRIPT_RUN:\n    pptr++;\n    CHECK_GROUP:\n    grouplength = get_grouplength(&pptr, TRUE, errcodeptr, lcptr, group,\n      recurses, cb);\n    if (grouplength < 0) return -1;\n    itemlength = grouplength;\n    break;\n\n    /* Exact repetition is OK; variable repetition is not. A repetition of zero\n    must subtract the length that has already been added. */\n\n    case META_MINMAX:\n    case META_MINMAX_PLUS:\n    case META_MINMAX_QUERY:\n    if (pptr\u00dd1\u00a8 == pptr\u00dd2\u00a8)\n      {\n      switch(pptr\u00dd1\u00a8)\n        {\n        case 0:\n        branchlength -= lastitemlength;\n        break;\n\n        case 1:\n        itemlength = 0;\n        break;\n\n        default:  /* Check for integer overflow */\n        if (lastitemlength != 0 &&  /* Should not occur, but just in case */\n            INT_MAX/lastitemlength < pptr\u00dd1\u00a8 - 1)\n          {\n          *errcodeptr = ERR87;  /* Integer overflow; lookbehind too big */\n          return -1;\n          }\n        itemlength = (pptr\u00dd1\u00a8 - 1) * lastitemlength;\n        break;\n        }\n      pptr += 2;\n      break;\n      }\n    /* Fall through */\n\n    /* Any other item means this branch does not have a fixed length. */\n\n    default:\n    ISNOTFIXED:\n    *errcodeptr = ERR25;   /* Not fixed length */\n    return -1;\n    }\n\n  /* Add the item length to the branchlength, checking for integer overflow and\n  for the branch length exceeding the limit. */\n\n  if (INT_MAX - branchlength < (int)itemlength ||\n      (branchlength += itemlength) > LOOKBEHIND_MAX)\n    {\n    *errcodeptr = ERR87;\n    return -1;\n    }\n\n  /* Save this item length for use if the next item is a quantifier. */\n\n  lastitemlength = itemlength;\n  }\n\nEXIT:\n*pptrptr = pptr;\nreturn branchlength;\n\nPARSED_SKIP_FAILED:\n*errcodeptr = ERR90;\nreturn -1;\n}\n\n\n\n/*************************************************\n*        Set lengths in a lookbehind             *\n*************************************************/\n\n/* This function is called for each lookbehind, to set the lengths in its\nbranches. An error occurs if any branch does not have a fixed length that is\nless than the maximum (65535). On exit, the pointer must be left on the final\nket.\n\nThe function also maintains the max_lookbehind value. Any lookbehind branch\nthat contains a nested lookbehind may actually look further back than the\nlength of the branch. The additional amount is passed back from\nget_branchlength() as an \"extra\" value.\n\nArguments:\n  pptrptr     pointer to pointer in the parsed pattern\n  errcodeptr  pointer to error code\n  lcptr       pointer to loop counter\n  recurses    chain of recurse_check to catch mutual recursion\n  cb          pointer to compile block\n\nReturns:      TRUE if all is well\n              FALSE otherwise, with error code and offset set\n*/\n\nstatic BOOL\nset_lookbehind_lengths(uint32_t **pptrptr, int *errcodeptr, int *lcptr,\n  parsed_recurse_check *recurses, compile_block *cb)\n{\nPCRE2_SIZE offset;\nint branchlength;\nuint32_t *bptr = *pptrptr;\n\nREADPLUSOFFSET(offset, bptr);  /* Offset for error messages */\n*pptrptr += SIZEOFFSET;\n\ndo\n  {\n  *pptrptr += 1;\n  branchlength = get_branchlength(pptrptr, errcodeptr, lcptr, recurses, cb);\n  if (branchlength < 0)\n    {\n    /* The errorcode and offset may already be set from a nested lookbehind. */\n    if (*errcodeptr == 0) *errcodeptr = ERR25;\n    if (cb->erroroffset == PCRE2_UNSET) cb->erroroffset = offset;\n    return FALSE;\n    }\n  if (branchlength > cb->max_lookbehind) cb->max_lookbehind = branchlength;\n  *bptr |= branchlength;  /* branchlength never more than 65535 */\n  bptr = *pptrptr;\n  }\nwhile (*bptr == META_ALT);\n\nreturn TRUE;\n}\n\n\n\n/*************************************************\n*         Check parsed pattern lookbehinds       *\n*************************************************/\n\n/* This function is called at the end of parsing a pattern if any lookbehinds\nwere encountered. It scans the parsed pattern for them, calling\nset_lookbehind_lengths() for each one. At the start, the errorcode is zero and\nthe error offset is marked unset. The enables the functions above not to\noverride settings from deeper nestings.\n\nThis function is called recursively from get_branchlength() for lookaheads in\norder to process any lookbehinds that they may contain. It stops when it hits a\nnon-nested closing parenthesis in this case, returning a pointer to it.\n\nArguments\n  pptr      points to where to start (start of pattern or start of lookahead)\n  retptr    if not NULL, return the ket pointer here\n  recurses  chain of recurse_check to catch mutual recursion\n  cb        points to the compile block\n\nReturns:    0 on success, or an errorcode (cb->erroroffset will be set)\n*/\n\nstatic int\ncheck_lookbehinds(uint32_t *pptr, uint32_t **retptr,\n  parsed_recurse_check *recurses, compile_block *cb)\n{\nint errorcode = 0;\nint loopcount = 0;\nint nestlevel = 0;\n\ncb->erroroffset = PCRE2_UNSET;\n\nfor (; *pptr != META_END; pptr++)\n  {\n  if (*pptr < META_END) continue;  /* Literal */\n\n  switch (META_CODE(*pptr))\n    {\n    default:\n    return ERR70;  /* Unrecognized meta code */\n\n    case META_ESCAPE:\n    if (*pptr - META_ESCAPE == ESC_P || *pptr - META_ESCAPE == ESC_p)\n      pptr += 1;\n    break;\n\n    case META_KET:\n    if (--nestlevel < 0)\n      {\n      if (retptr != NULL) *retptr = pptr;\n      return 0;\n      }\n    break;\n\n    case META_ATOMIC:\n    case META_CAPTURE:\n    case META_COND_ASSERT:\n    case META_LOOKAHEAD:\n    case META_LOOKAHEADNOT:\n    case META_LOOKAHEAD_NA:\n    case META_NOCAPTURE:\n    case META_SCRIPT_RUN:\n    nestlevel++;\n    break;\n\n    case META_ACCEPT:\n    case META_ALT:\n    case META_ASTERISK:\n    case META_ASTERISK_PLUS:\n    case META_ASTERISK_QUERY:\n    case META_BACKREF:\n    case META_CIRCUMFLEX:\n    case META_CLASS:\n    case META_CLASS_EMPTY:\n    case META_CLASS_EMPTY_NOT:\n    case META_CLASS_END:\n    case META_CLASS_NOT:\n    case META_COMMIT:\n    case META_DOLLAR:\n    case META_DOT:\n    case META_FAIL:\n    case META_PLUS:\n    case META_PLUS_PLUS:\n    case META_PLUS_QUERY:\n    case META_PRUNE:\n    case META_QUERY:\n    case META_QUERY_PLUS:\n    case META_QUERY_QUERY:\n    case META_RANGE_ESCAPED:\n    case META_RANGE_LITERAL:\n    case META_SKIP:\n    case META_THEN:\n    break;\n\n    case META_RECURSE:\n    pptr += SIZEOFFSET;\n    break;\n\n    case META_BACKREF_BYNAME:\n    case META_RECURSE_BYNAME:\n    pptr += 1 + SIZEOFFSET;\n    break;\n\n    case META_COND_DEFINE:\n    pptr += SIZEOFFSET;\n    nestlevel++;\n    break;\n\n    case META_COND_NAME:\n    case META_COND_NUMBER:\n    case META_COND_RNAME:\n    case META_COND_RNUMBER:\n    pptr += 1 + SIZEOFFSET;\n    nestlevel++;\n    break;\n\n    case META_COND_VERSION:\n    pptr += 3;\n    nestlevel++;\n    break;\n\n    case META_CALLOUT_STRING:\n    pptr += 3 + SIZEOFFSET;\n    break;\n\n    case META_BIGVALUE:\n    case META_OPTIONS:\n    case META_POSIX:\n    case META_POSIX_NEG:\n    pptr += 1;\n    break;\n\n    case META_MINMAX:\n    case META_MINMAX_QUERY:\n    case META_MINMAX_PLUS:\n    pptr += 2;\n    break;\n\n    case META_CALLOUT_NUMBER:\n    pptr += 3;\n    break;\n\n    case META_MARK:\n    case META_COMMIT_ARG:\n    case META_PRUNE_ARG:\n    case META_SKIP_ARG:\n    case META_THEN_ARG:\n    pptr += 1 + pptr\u00dd1\u00a8;\n    break;\n\n    case META_LOOKBEHIND:\n    case META_LOOKBEHINDNOT:\n    case META_LOOKBEHIND_NA:\n    if (!set_lookbehind_lengths(&pptr, &errorcode, &loopcount, recurses, cb))\n      return errorcode;\n    break;\n    }\n  }\n\nreturn 0;\n}\n\n\n\n/*************************************************\n*     External function to compile a pattern     *\n*************************************************/\n\n/* This function reads a regular expression in the form of a string and returns\na pointer to a block of store holding a compiled version of the expression.\n\nArguments:\n  pattern       the regular expression\n  patlen        the length of the pattern, or PCRE2_ZERO_TERMINATED\n  options       option bits\n  errorptr      pointer to errorcode\n  erroroffset   pointer to error offset\n  ccontext      points to a compile context or is NULL\n\nReturns:        pointer to compiled data block, or NULL on error,\n                with errorcode and erroroffset set\n*/\n\nPCRE2_EXP_DEFN pcre2_code * PCRE2_CALL_CONVENTION\npcre2_compile(PCRE2_SPTR pattern, PCRE2_SIZE patlen, uint32_t options,\n   int *errorptr, PCRE2_SIZE *erroroffset, pcre2_compile_context *ccontext)\n{\nBOOL utf;                             /* Set TRUE for UTF mode */\nBOOL ucp;                             /* Set TRUE for UCP mode */\nBOOL has_lookbehind = FALSE;          /* Set TRUE if a lookbehind is found */\nBOOL zero_terminated;                 /* Set TRUE for zero-terminated pattern */\npcre2_real_code *re = NULL;           /* What we will return */\ncompile_block cb;                     /* \"Static\" compile-time data */\nconst uint8_t *tables;                /* Char tables base pointer */\n\nPCRE2_UCHAR *code;                    /* Current pointer in compiled code */\nPCRE2_SPTR codestart;                 /* Start of compiled code */\nPCRE2_SPTR ptr;                       /* Current pointer in pattern */\nuint32_t *pptr;                       /* Current pointer in parsed pattern */\n\nPCRE2_SIZE length = 1;                /* Allow for final END opcode */\nPCRE2_SIZE usedlength;                /* Actual length used */\nPCRE2_SIZE re_blocksize;              /* Size of memory block */\nPCRE2_SIZE big32count = 0;            /* 32-bit literals >= 0x80000000 */\nPCRE2_SIZE parsed_size_needed;        /* Needed for parsed pattern */\n\nint32_t firstcuflags, reqcuflags;     /* Type of first/req code unit */\nuint32_t firstcu, reqcu;              /* Value of first/req code unit */\nuint32_t setflags = 0;                /* NL and BSR set flags */\n\nuint32_t skipatstart;                 /* When checking (*UTF) etc */\nuint32_t limit_heap  = UINT32_MAX;\nuint32_t limit_match = UINT32_MAX;    /* Unset match limits */\nuint32_t limit_depth = UINT32_MAX;\n\nint newline = 0;                      /* Unset; can be set by the pattern */\nint bsr = 0;                          /* Unset; can be set by the pattern */\nint errorcode = 0;                    /* Initialize to avoid compiler warn */\nint regexrc;                          /* Return from compile */\n\nuint32_t i;                           /* Local loop counter */\n\n/* Comments at the head of this file explain about these variables. */\n\nuint32_t stack_groupinfo\u00ddGROUPINFO_DEFAULT_SIZE\u00a8;\nuint32_t stack_parsed_pattern\u00ddPARSED_PATTERN_DEFAULT_SIZE\u00a8;\nnamed_group named_groups\u00ddNAMED_GROUP_LIST_SIZE\u00a8;\n\n/* The workspace is used in different ways in the different compiling phases.\nIt needs to be 16-bit aligned for the preliminary parsing scan. */\n\nuint32_t c16workspace\u00ddC16_WORK_SIZE\u00a8;\nPCRE2_UCHAR *cworkspace = (PCRE2_UCHAR *)c16workspace;\n\n\n/* -------------- Check arguments and set up the pattern ----------------- */\n\n/* There must be error code and offset pointers. */\n\nif (errorptr == NULL || erroroffset == NULL) return NULL;\n*errorptr = ERR0;\n*erroroffset = 0;\n\n/* There must be a pattern! */\n\nif (pattern == NULL)\n  {\n  *errorptr = ERR16;\n  return NULL;\n  }\n\n/* A NULL compile context means \"use a default context\" */\n\nif (ccontext == NULL)\n  ccontext = (pcre2_compile_context *)(&PRIV(default_compile_context));\n\n/* PCRE2_MATCH_INVALID_UTF implies UTF */\n\nif ((options & PCRE2_MATCH_INVALID_UTF) != 0) options |= PCRE2_UTF;\n\n/* Check that all undefined public option bits are zero. */\n\nif ((options & ~PUBLIC_COMPILE_OPTIONS) != 0 ||\n    (ccontext->extra_options & ~PUBLIC_COMPILE_EXTRA_OPTIONS) != 0)\n  {\n  *errorptr = ERR17;\n  return NULL;\n  }\n\nif ((options & PCRE2_LITERAL) != 0 &&\n    ((options & ~PUBLIC_LITERAL_COMPILE_OPTIONS) != 0 ||\n     (ccontext->extra_options & ~PUBLIC_LITERAL_COMPILE_EXTRA_OPTIONS) != 0))\n  {\n  *errorptr = ERR92;\n  return NULL;\n  }\n\n/* A zero-terminated pattern is indicated by the special length value\nPCRE2_ZERO_TERMINATED. Check for an overlong pattern. */\n\nif ((zero_terminated = (patlen == PCRE2_ZERO_TERMINATED)))\n  patlen = PRIV(strlen)(pattern);\n\nif (patlen > ccontext->max_pattern_length)\n  {\n  *errorptr = ERR88;\n  return NULL;\n  }\n\n/* From here on, all returns from this function should end up going via the\nEXIT label. */\n\n\n/* ------------ Initialize the \"static\" compile data -------------- */\n\ntables = (ccontext->tables != NULL)? ccontext->tables : PRIV(default_tables);\n\ncb.lcc = tables + lcc_offset;          /* Individual */\ncb.fcc = tables + fcc_offset;          /*   character */\ncb.cbits = tables + cbits_offset;      /*      tables */\ncb.ctypes = tables + ctypes_offset;\n\ncb.assert_depth = 0;\ncb.bracount = 0;\ncb.cx = ccontext;\ncb.dupnames = FALSE;\ncb.end_pattern = pattern + patlen;\ncb.erroroffset = 0;\ncb.external_flags = 0;\ncb.external_options = options;\ncb.groupinfo = stack_groupinfo;\ncb.had_recurse = FALSE;\ncb.lastcapture = 0;\ncb.max_lookbehind = 0;\ncb.name_entry_size = 0;\ncb.name_table = NULL;\ncb.named_groups = named_groups;\ncb.named_group_list_size = NAMED_GROUP_LIST_SIZE;\ncb.names_found = 0;\ncb.open_caps = NULL;\ncb.parens_depth = 0;\ncb.parsed_pattern = stack_parsed_pattern;\ncb.req_varyopt = 0;\ncb.start_code = cworkspace;\ncb.start_pattern = pattern;\ncb.start_workspace = cworkspace;\ncb.workspace_size = COMPILE_WORK_SIZE;\n\n/* Maximum back reference and backref bitmap. The bitmap records up to 31 back\nreferences to help in deciding whether (.*) can be treated as anchored or not.\n*/\n\ncb.top_backref = 0;\ncb.backref_map = 0;\n\n/* Escape sequences \\1 to \\9 are always back references, but as they are only\ntwo characters long, only two elements can be used in the parsed_pattern\nvector. The first contains the reference, and we'd like to use the second to\nrecord the offset in the pattern, so that forward references to non-existent\ngroups can be diagnosed later with an offset. However, on 64-bit systems,\nPCRE2_SIZE won't fit. Instead, we have a vector of offsets for the first\noccurrence of \\1 to \\9, indexed by the second parsed_pattern value. All other\nreferences have enough space for the offset to be put into the parsed pattern.\n*/\n\nfor (i = 0; i < 10; i++) cb.small_ref_offset\u00ddi\u00a8 = PCRE2_UNSET;\n\n\n/* --------------- Start looking at the pattern --------------- */\n\n/* Unless PCRE2_LITERAL is set, check for global one-time option settings at\nthe start of the pattern, and remember the offset to the actual regex. With\nvalgrind support, make the terminator of a zero-terminated pattern\ninaccessible. This catches bugs that would otherwise only show up for\nnon-zero-terminated patterns. */\n\n#ifdef SUPPORT_VALGRIND\nif (zero_terminated) VALGRIND_MAKE_MEM_NOACCESS(pattern + patlen, CU2BYTES(1));\n#endif\n\nptr = pattern;\nskipatstart = 0;\n\nif ((options & PCRE2_LITERAL) == 0)\n  {\n  while (patlen - skipatstart >= 2 &&\n         ptr\u00ddskipatstart\u00a8 == CHAR_LEFT_PARENTHESIS &&\n         ptr\u00ddskipatstart+1\u00a8 == CHAR_ASTERISK)\n    {\n    for (i = 0; i < sizeof(pso_list)/sizeof(pso); i++)\n      {\n      uint32_t c, pp;\n      pso *p = pso_list + i;\n\n      if (patlen - skipatstart - 2 >= p->length &&\n          PRIV(strncmp_c8)(ptr + skipatstart + 2, (char *)(p->name),\n            p->length) == 0)\n        {\n        skipatstart += p->length + 2;\n        switch(p->type)\n          {\n          case PSO_OPT:\n          cb.external_options |= p->value;\n          break;\n\n          case PSO_FLG:\n          setflags |= p->value;\n          break;\n\n          case PSO_NL:\n          newline = p->value;\n          setflags |= PCRE2_NL_SET;\n          break;\n\n          case PSO_BSR:\n          bsr = p->value;\n          setflags |= PCRE2_BSR_SET;\n          break;\n\n          case PSO_LIMM:\n          case PSO_LIMD:\n          case PSO_LIMH:\n          c = 0;\n          pp = skipatstart;\n          if (!IS_DIGIT(ptr\u00ddpp\u00a8))\n            {\n            errorcode = ERR60;\n            ptr += pp;\n            goto HAD_EARLY_ERROR;\n            }\n          while (IS_DIGIT(ptr\u00ddpp\u00a8))\n            {\n            if (c > UINT32_MAX / 10 - 1) break;   /* Integer overflow */\n            c = c*10 + (ptr\u00ddpp++\u00a8 - CHAR_0);\n            }\n          if (ptr\u00ddpp++\u00a8 != CHAR_RIGHT_PARENTHESIS)\n            {\n            errorcode = ERR60;\n            ptr += pp;\n            goto HAD_EARLY_ERROR;\n            }\n          if (p->type == PSO_LIMH) limit_heap = c;\n            else if (p->type == PSO_LIMM) limit_match = c;\n            else limit_depth = c;\n          skipatstart += pp - skipatstart;\n          break;\n          }\n        break;   /* Out of the table scan loop */\n        }\n      }\n    if (i >= sizeof(pso_list)/sizeof(pso)) break;   /* Out of pso loop */\n    }\n  }\n\n/* End of pattern-start options; advance to start of real regex. */\n\nptr += skipatstart;\n\n/* Can't support UTF or UCP if PCRE2 was built without Unicode support. */\n\n#ifndef SUPPORT_UNICODE\nif ((cb.external_options & (PCRE2_UTF|PCRE2_UCP)) != 0)\n  {\n  errorcode = ERR32;\n  goto HAD_EARLY_ERROR;\n  }\n#endif\n\n/* Check UTF. We have the original options in 'options', with that value as\nmodified by (*UTF) etc in cb->external_options. The extra option\nPCRE2_EXTRA_ALLOW_SURROGATE_ESCAPES is not permitted in UTF-16 mode because the\nsurrogate code points cannot be represented in UTF-16. */\n\nutf = (cb.external_options & PCRE2_UTF) != 0;\nif (utf)\n  {\n  if ((options & PCRE2_NEVER_UTF) != 0)\n    {\n    errorcode = ERR74;\n    goto HAD_EARLY_ERROR;\n    }\n  if ((options & PCRE2_NO_UTF_CHECK) == 0 &&\n       (errorcode = PRIV(valid_utf)(pattern, patlen, erroroffset)) != 0)\n    goto HAD_ERROR;  /* Offset was set by valid_utf() */\n\n#if PCRE2_CODE_UNIT_WIDTH == 16\n  if ((ccontext->extra_options & PCRE2_EXTRA_ALLOW_SURROGATE_ESCAPES) != 0)\n    {\n    errorcode = ERR91;\n    goto HAD_EARLY_ERROR;\n    }\n#endif\n  }\n\n/* Check UCP lockout. */\n\nucp = (cb.external_options & PCRE2_UCP) != 0;\nif (ucp && (cb.external_options & PCRE2_NEVER_UCP) != 0)\n  {\n  errorcode = ERR75;\n  goto HAD_EARLY_ERROR;\n  }\n\n/* Process the BSR setting. */\n\nif (bsr == 0) bsr = ccontext->bsr_convention;\n\n/* Process the newline setting. */\n\nif (newline == 0) newline = ccontext->newline_convention;\ncb.nltype = NLTYPE_FIXED;\nswitch(newline)\n  {\n  case PCRE2_NEWLINE_CR:\n  cb.nllen = 1;\n  cb.nl\u00dd0\u00a8 = CHAR_CR;\n  break;\n\n  case PCRE2_NEWLINE_LF:\n  cb.nllen = 1;\n  cb.nl\u00dd0\u00a8 = CHAR_NL;\n  break;\n\n  case PCRE2_NEWLINE_NUL:\n  cb.nllen = 1;\n  cb.nl\u00dd0\u00a8 = CHAR_NUL;\n  break;\n\n  case PCRE2_NEWLINE_CRLF:\n  cb.nllen = 2;\n  cb.nl\u00dd0\u00a8 = CHAR_CR;\n  cb.nl\u00dd1\u00a8 = CHAR_NL;\n  break;\n\n  case PCRE2_NEWLINE_ANY:\n  cb.nltype = NLTYPE_ANY;\n  break;\n\n  case PCRE2_NEWLINE_ANYCRLF:\n  cb.nltype = NLTYPE_ANYCRLF;\n  break;\n\n  default:\n  errorcode = ERR56;\n  goto HAD_EARLY_ERROR;\n  }\n\n/* Pre-scan the pattern to do two things: (1) Discover the named groups and\ntheir numerical equivalents, so that this information is always available for\nthe remaining processing. (2) At the same time, parse the pattern and put a\nprocessed version into the parsed_pattern vector. This has escapes interpreted\nand comments removed (amongst other things).\n\nIn all but one case, when PCRE2_AUTO_CALLOUT is not set, the number of unsigned\n32-bit ints in the parsed pattern is bounded by the length of the pattern plus\none (for the terminator) plus four if PCRE2_EXTRA_WORD or PCRE2_EXTRA_LINE is\nset. The exceptional case is when running in 32-bit, non-UTF mode, when literal\ncharacters greater than META_END (0x80000000) have to be coded as two units. In\nthis case, therefore, we scan the pattern to check for such values. */\n\n#if PCRE2_CODE_UNIT_WIDTH == 32\nif (!utf)\n  {\n  PCRE2_SPTR p;\n  for (p = ptr; p < cb.end_pattern; p++) if (*p >= META_END) big32count++;\n  }\n#endif\n\n/* Ensure that the parsed pattern buffer is big enough. When PCRE2_AUTO_CALLOUT\nis set we have to assume a numerical callout (4 elements) for each character\nplus one at the end. This is overkill, but memory is plentiful these days. For\nmany smaller patterns the vector on the stack (which was set up above) can be\nused. */\n\nparsed_size_needed = patlen - skipatstart + big32count;\n\nif ((ccontext->extra_options &\n     (PCRE2_EXTRA_MATCH_WORD|PCRE2_EXTRA_MATCH_LINE)) != 0)\n  parsed_size_needed += 4;\n\nif ((options & PCRE2_AUTO_CALLOUT) != 0)\n  parsed_size_needed = (parsed_size_needed + 1) * 5;\n\nif (parsed_size_needed >= PARSED_PATTERN_DEFAULT_SIZE)\n  {\n  uint32_t *heap_parsed_pattern = ccontext->memctl.malloc(\n    (parsed_size_needed + 1) * sizeof(uint32_t), ccontext->memctl.memory_data);\n  if (heap_parsed_pattern == NULL)\n    {\n    *errorptr = ERR21;\n    goto EXIT;\n    }\n  cb.parsed_pattern = heap_parsed_pattern;\n  }\ncb.parsed_pattern_end = cb.parsed_pattern + parsed_size_needed + 1;\n\n/* Do the parsing scan. */\n\nerrorcode = parse_regex(ptr, cb.external_options, &has_lookbehind, &cb);\nif (errorcode != 0) goto HAD_CB_ERROR;\n\n/* Workspace is needed to remember information about numbered groups: whether a\ngroup can match an empty string and what its fixed length is. This is done to\navoid the possibility of recursive references causing very long compile times\nwhen checking these features. Unnumbered groups do not have this exposure since\nthey cannot be referenced. We use an indexed vector for this purpose. If there\nare sufficiently few groups, the default vector on the stack, as set up above,\ncan be used. Otherwise we have to get/free a special vector. The vector must be\ninitialized to zero. */\n\nif (cb.bracount >= GROUPINFO_DEFAULT_SIZE)\n  {\n  cb.groupinfo = ccontext->memctl.malloc(\n    (cb.bracount + 1)*sizeof(uint32_t), ccontext->memctl.memory_data);\n  if (cb.groupinfo == NULL)\n    {\n    errorcode = ERR21;\n    cb.erroroffset = 0;\n    goto HAD_CB_ERROR;\n    }\n  }\nmemset(cb.groupinfo, 0, (cb.bracount + 1) * sizeof(uint32_t));\n\n/* If there were any lookbehinds, scan the parsed pattern to figure out their\nlengths. */\n\nif (has_lookbehind)\n  {\n  errorcode = check_lookbehinds(cb.parsed_pattern, NULL, NULL, &cb);\n  if (errorcode != 0) goto HAD_CB_ERROR;\n  }\n\n/* For debugging, there is a function that shows the parsed data vector. */\n\n#ifdef DEBUG_SHOW_PARSED\nfprintf(stderr, \"+++ Pre-scan complete:\\n\");\nshow_parsed(&cb);\n#endif\n\n/* For debugging capturing information this code can be enabled. */\n\n#ifdef DEBUG_SHOW_CAPTURES\n  {\n  named_group *ng = cb.named_groups;\n  fprintf(stderr, \"+++Captures: %d\\n\", cb.bracount);\n  for (i = 0; i < cb.names_found; i++, ng++)\n    {\n    fprintf(stderr, \"+++%3d %.*s\\n\", ng->number, ng->length, ng->name);\n    }\n  }\n#endif\n\n/* Pretend to compile the pattern while actually just accumulating the amount\nof memory required in the 'length' variable. This behaviour is triggered by\npassing a non-NULL final argument to compile_regex(). We pass a block of\nworkspace (cworkspace) for it to compile parts of the pattern into; the\ncompiled code is discarded when it is no longer needed, so hopefully this\nworkspace will never overflow, though there is a test for its doing so.\n\nOn error, errorcode will be set non-zero, so we don't need to look at the\nresult of the function. The initial options have been put into the cb block,\nbut we still have to pass a separate options variable (the first argument)\nbecause the options may change as the pattern is processed. */\n\ncb.erroroffset = patlen;   /* For any subsequent errors that do not set it */\npptr = cb.parsed_pattern;\ncode = cworkspace;\n*code = OP_BRA;\n\n(void)compile_regex(cb.external_options, &code, &pptr, &errorcode, 0, &firstcu,\n   &firstcuflags, &reqcu, &reqcuflags, NULL, &cb, &length);\n\nif (errorcode != 0) goto HAD_CB_ERROR;  /* Offset is in cb.erroroffset */\n\n/* This should be caught in compile_regex(), but just in case... */\n\nif (length > MAX_PATTERN_SIZE)\n  {\n  errorcode = ERR20;\n  goto HAD_CB_ERROR;\n  }\n\n/* Compute the size of, and then get and initialize, the data block for storing\nthe compiled pattern and names table. Integer overflow should no longer be\npossible because nowadays we limit the maximum value of cb.names_found and\ncb.name_entry_size. */\n\nre_blocksize = sizeof(pcre2_real_code) +\n  CU2BYTES(length +\n  (PCRE2_SIZE)cb.names_found * (PCRE2_SIZE)cb.name_entry_size);\nre = (pcre2_real_code *)\n  ccontext->memctl.malloc(re_blocksize, ccontext->memctl.memory_data);\nif (re == NULL)\n  {\n  errorcode = ERR21;\n  goto HAD_CB_ERROR;\n  }\n\n/* The compiler may put padding at the end of the pcre2_real_code structure in\norder to round it up to a multiple of 4 or 8 bytes. This means that when a\ncompiled pattern is copied (for example, when serialized) undefined bytes are\nread, and this annoys debuggers such as valgrind. To avoid this, we explicitly\nwrite to the last 8 bytes of the structure before setting the fields. */\n\nmemset((char *)re + sizeof(pcre2_real_code) - 8, 0, 8);\nre->memctl = ccontext->memctl;\nre->tables = tables;\nre->executable_jit = NULL;\nmemset(re->start_bitmap, 0, 32 * sizeof(uint8_t));\nre->blocksize = re_blocksize;\nre->magic_number = MAGIC_NUMBER;\nre->compile_options = options;\nre->overall_options = cb.external_options;\nre->extra_options = ccontext->extra_options;\nre->flags = PCRE2_CODE_UNIT_WIDTH/8 | cb.external_flags | setflags;\nre->limit_heap = limit_heap;\nre->limit_match = limit_match;\nre->limit_depth = limit_depth;\nre->first_codeunit = 0;\nre->last_codeunit = 0;\nre->bsr_convention = bsr;\nre->newline_convention = newline;\nre->max_lookbehind = 0;\nre->minlength = 0;\nre->top_bracket = 0;\nre->top_backref = 0;\nre->name_entry_size = cb.name_entry_size;\nre->name_count = cb.names_found;\n\n/* The basic block is immediately followed by the name table, and the compiled\ncode follows after that. */\n\ncodestart = (PCRE2_SPTR)((uint8_t *)re + sizeof(pcre2_real_code)) +\n  re->name_entry_size * re->name_count;\n\n/* Update the compile data block for the actual compile. The starting points of\nthe name/number translation table and of the code are passed around in the\ncompile data block. The start/end pattern and initial options are already set\nfrom the pre-compile phase, as is the name_entry_size field. */\n\ncb.parens_depth = 0;\ncb.assert_depth = 0;\ncb.lastcapture = 0;\ncb.name_table = (PCRE2_UCHAR *)((uint8_t *)re + sizeof(pcre2_real_code));\ncb.start_code = codestart;\ncb.req_varyopt = 0;\ncb.had_accept = FALSE;\ncb.had_pruneorskip = FALSE;\ncb.open_caps = NULL;\n\n/* If any named groups were found, create the name/number table from the list\ncreated in the pre-pass. */\n\nif (cb.names_found > 0)\n  {\n  named_group *ng = cb.named_groups;\n  for (i = 0; i < cb.names_found; i++, ng++)\n    add_name_to_table(&cb, ng->name, ng->length, ng->number, i);\n  }\n\n/* Set up a starting, non-extracting bracket, then compile the expression. On\nerror, errorcode will be set non-zero, so we don't need to look at the result\nof the function here. */\n\npptr = cb.parsed_pattern;\ncode = (PCRE2_UCHAR *)codestart;\n*code = OP_BRA;\nregexrc = compile_regex(re->overall_options, &code, &pptr, &errorcode, 0,\n  &firstcu, &firstcuflags, &reqcu, &reqcuflags, NULL, &cb, NULL);\nif (regexrc < 0) re->flags |= PCRE2_MATCH_EMPTY;\nre->top_bracket = cb.bracount;\nre->top_backref = cb.top_backref;\nre->max_lookbehind = cb.max_lookbehind;\n\nif (cb.had_accept)\n  {\n  reqcu = 0;                     /* Must disable after (*ACCEPT) */\n  reqcuflags = REQ_NONE;\n  re->flags |= PCRE2_HASACCEPT;  /* Disables minimum length */\n  }\n\n/* Fill in the final opcode and check for disastrous overflow. If no overflow,\nbut the estimated length exceeds the really used length, adjust the value of\nre->blocksize, and if valgrind support is configured, mark the extra allocated\nmemory as unaddressable, so that any out-of-bound reads can be detected. */\n\n*code++ = OP_END;\nusedlength = code - codestart;\nif (usedlength > length) errorcode = ERR23; else\n  {\n  re->blocksize -= CU2BYTES(length - usedlength);\n#ifdef SUPPORT_VALGRIND\n  VALGRIND_MAKE_MEM_NOACCESS(code, CU2BYTES(length - usedlength));\n#endif\n  }\n\n/* Scan the pattern for recursion/subroutine calls and convert the group\nnumbers into offsets. Maintain a small cache so that repeated groups containing\nrecursions are efficiently handled. */\n\n#define RSCAN_CACHE_SIZE 8\n\nif (errorcode == 0 && cb.had_recurse)\n  {\n  PCRE2_UCHAR *rcode;\n  PCRE2_SPTR rgroup;\n  unsigned int ccount = 0;\n  int start = RSCAN_CACHE_SIZE;\n  recurse_cache rc\u00ddRSCAN_CACHE_SIZE\u00a8;\n\n  for (rcode = (PCRE2_UCHAR *)find_recurse(codestart, utf);\n       rcode != NULL;\n       rcode = (PCRE2_UCHAR *)find_recurse(rcode + 1 + LINK_SIZE, utf))\n    {\n    int p, groupnumber;\n\n    groupnumber = (int)GET(rcode, 1);\n    if (groupnumber == 0) rgroup = codestart; else\n      {\n      PCRE2_SPTR search_from = codestart;\n      rgroup = NULL;\n      for (i = 0, p = start; i < ccount; i++, p = (p + 1) & 7)\n        {\n        if (groupnumber == rc\u00ddp\u00a8.groupnumber)\n          {\n          rgroup = rc\u00ddp\u00a8.group;\n          break;\n          }\n\n        /* Group n+1 must always start to the right of group n, so we can save\n        search time below when the new group number is greater than any of the\n        previously found groups. */\n\n        if (groupnumber > rc\u00ddp\u00a8.groupnumber) search_from = rc\u00ddp\u00a8.group;\n        }\n\n      if (rgroup == NULL)\n        {\n        rgroup = PRIV(find_bracket)(search_from, utf, groupnumber);\n        if (rgroup == NULL)\n          {\n          errorcode = ERR53;\n          break;\n          }\n        if (--start < 0) start = RSCAN_CACHE_SIZE - 1;\n        rc\u00ddstart\u00a8.groupnumber = groupnumber;\n        rc\u00ddstart\u00a8.group = rgroup;\n        if (ccount < RSCAN_CACHE_SIZE) ccount++;\n        }\n      }\n\n    PUT(rcode, 1, rgroup - codestart);\n    }\n  }\n\n/* In rare debugging situations we sometimes need to look at the compiled code\nat this stage. */\n\n#ifdef DEBUG_CALL_PRINTINT\npcre2_printint(re, stderr, TRUE);\nfprintf(stderr, \"Length=%lu Used=%lu\\n\", length, usedlength);\n#endif\n\n/* Unless disabled, check whether any single character iterators can be\nauto-possessified. The function overwrites the appropriate opcode values, so\nthe type of the pointer must be cast. NOTE: the intermediate variable \"temp\" is\nused in this code because at least one compiler gives a warning about loss of\n\"const\" attribute if the cast (PCRE2_UCHAR *)codestart is used directly in the\nfunction call. */\n\nif (errorcode == 0 && (re->overall_options & PCRE2_NO_AUTO_POSSESS) == 0)\n  {\n  PCRE2_UCHAR *temp = (PCRE2_UCHAR *)codestart;\n  if (PRIV(auto_possessify)(temp, &cb) != 0) errorcode = ERR80;\n  }\n\n/* Failed to compile, or error while post-processing. */\n\nif (errorcode != 0) goto HAD_CB_ERROR;\n\n/* Successful compile. If the anchored option was not passed, set it if\nwe can determine that the pattern is anchored by virtue of \u00ac characters or \\A\nor anything else, such as starting with non-atomic .* when DOTALL is set and\nthere are no occurrences of *PRUNE or *SKIP (though there is an option to\ndisable this case). */\n\nif ((re->overall_options & PCRE2_ANCHORED) == 0 &&\n     is_anchored(codestart, 0, &cb, 0, FALSE))\n  re->overall_options |= PCRE2_ANCHORED;\n\n/* Set up the first code unit or startline flag, the required code unit, and\nthen study the pattern. This code need not be obeyed if PCRE2_NO_START_OPTIMIZE\nis set, as the data it would create will not be used. Note that a first code\nunit (but not the startline flag) is useful for anchored patterns because it\ncan still give a quick \"no match\" and also avoid searching for a last code\nunit. */\n\nif ((re->overall_options & PCRE2_NO_START_OPTIMIZE) == 0)\n  {\n  int minminlength = 0;  /* For minimal minlength from first/required CU */\n\n  /* If we do not have a first code unit, see if there is one that is asserted\n  (these are not saved during the compile because they can cause conflicts with\n  actual literals that follow). */\n\n  if (firstcuflags < 0)\n    firstcu = find_firstassertedcu(codestart, &firstcuflags, 0);\n\n  /* Save the data for a first code unit. The existence of one means the\n  minimum length must be at least 1. */\n\n  if (firstcuflags >= 0)\n    {\n    re->first_codeunit = firstcu;\n    re->flags |= PCRE2_FIRSTSET;\n    minminlength++;\n\n    /* Handle caseless first code units. */\n\n    if ((firstcuflags & REQ_CASELESS) != 0)\n      {\n      if (firstcu < 128 || (!utf && !ucp && firstcu < 255))\n        {\n        if (cb.fcc\u00ddfirstcu\u00a8 != firstcu) re->flags |= PCRE2_FIRSTCASELESS;\n        }\n\n      /* The first code unit is > 128 in UTF or UCP mode, or > 255 otherwise.\n      In 8-bit UTF mode, codepoints in the range 128-255 are introductory code\n      points and cannot have another case, but if UCP is set they may do. */\n\n#ifdef SUPPORT_UNICODE\n#if PCRE2_CODE_UNIT_WIDTH == 8\n      else if (ucp && !utf && UCD_OTHERCASE(firstcu) != firstcu)\n        re->flags |= PCRE2_FIRSTCASELESS;\n#else\n      else if ((utf || ucp) && firstcu <= MAX_UTF_CODE_POINT &&\n               UCD_OTHERCASE(firstcu) != firstcu)\n        re->flags |= PCRE2_FIRSTCASELESS;\n#endif\n#endif  /* SUPPORT_UNICODE */\n      }\n    }\n\n  /* When there is no first code unit, for non-anchored patterns, see if we can\n  set the PCRE2_STARTLINE flag. This is helpful for multiline matches when all\n  branches start with \u00ac and also when all branches start with non-atomic .* for\n  non-DOTALL matches when *PRUNE and SKIP are not present. (There is an option\n  that disables this case.) */\n\n  else if ((re->overall_options & PCRE2_ANCHORED) == 0 &&\n           is_startline(codestart, 0, &cb, 0, FALSE))\n    re->flags |= PCRE2_STARTLINE;\n\n  /* Handle the \"required code unit\", if one is set. In the UTF case we can\n  increment the minimum minimum length only if we are sure this really is a\n  different character and not a non-starting code unit of the first character,\n  because the minimum length count is in characters, not code units. */\n\n  if (reqcuflags >= 0)\n    {\n#if PCRE2_CODE_UNIT_WIDTH == 16\n    if ((re->overall_options & PCRE2_UTF) == 0 ||   /* Not UTF */\n        firstcuflags < 0 ||                         /* First not set */\n        (firstcu & 0xf800) != 0xd800 ||             /* First not surrogate */\n        (reqcu & 0xfc00) != 0xdc00)                 /* Req not low surrogate */\n#elif PCRE2_CODE_UNIT_WIDTH == 8\n    if ((re->overall_options & PCRE2_UTF) == 0 ||   /* Not UTF */\n        firstcuflags < 0 ||                         /* First not set */\n        (firstcu & 0x80) == 0 ||                    /* First is ASCII */\n        (reqcu & 0x80) == 0)                        /* Req is ASCII */\n#endif\n      {\n      minminlength++;\n      }\n\n    /* In the case of an anchored pattern, set up the value only if it follows\n    a variable length item in the pattern. */\n\n    if ((re->overall_options & PCRE2_ANCHORED) == 0 ||\n        (reqcuflags & REQ_VARY) != 0)\n      {\n      re->last_codeunit = reqcu;\n      re->flags |= PCRE2_LASTSET;\n\n      /* Handle caseless required code units as for first code units (above). */\n\n      if ((reqcuflags & REQ_CASELESS) != 0)\n        {\n        if (reqcu < 128 || (!utf && !ucp && reqcu < 255))\n          {\n          if (cb.fcc\u00ddreqcu\u00a8 != reqcu) re->flags |= PCRE2_LASTCASELESS;\n          }\n#ifdef SUPPORT_UNICODE\n#if PCRE2_CODE_UNIT_WIDTH == 8\n      else if (ucp && !utf && UCD_OTHERCASE(reqcu) != reqcu)\n        re->flags |= PCRE2_LASTCASELESS;\n#else\n      else if ((utf || ucp) && reqcu <= MAX_UTF_CODE_POINT &&\n               UCD_OTHERCASE(reqcu) != reqcu)\n        re->flags |= PCRE2_LASTCASELESS;\n#endif\n#endif  /* SUPPORT_UNICODE */\n        }\n      }\n    }\n\n  /* Study the compiled pattern to set up information such as a bitmap of\n  starting code units and a minimum matching length. */\n\n  if (PRIV(study)(re) != 0)\n    {\n    errorcode = ERR31;\n    goto HAD_CB_ERROR;\n    }\n\n  /* If study() set a bitmap of starting code units, it implies a minimum\n  length of at least one. */\n\n  if ((re->flags & PCRE2_FIRSTMAPSET) != 0 && minminlength == 0)\n    minminlength = 1;\n\n  /* If the minimum length set (or not set) by study() is less than the minimum\n  implied by required code units, override it. */\n\n  if (re->minlength < minminlength) re->minlength = minminlength;\n  }   /* End of start-of-match optimizations. */\n\n/* Control ends up here in all cases. When running under valgrind, make a\npattern's terminating zero defined again. If memory was obtained for the parsed\nversion of the pattern, free it before returning. Also free the list of named\ngroups if a larger one had to be obtained, and likewise the group information\nvector. */\n\nEXIT:\n#ifdef SUPPORT_VALGRIND\nif (zero_terminated) VALGRIND_MAKE_MEM_DEFINED(pattern + patlen, CU2BYTES(1));\n#endif\nif (cb.parsed_pattern != stack_parsed_pattern)\n  ccontext->memctl.free(cb.parsed_pattern, ccontext->memctl.memory_data);\nif (cb.named_group_list_size > NAMED_GROUP_LIST_SIZE)\n  ccontext->memctl.free((void *)cb.named_groups, ccontext->memctl.memory_data);\nif (cb.groupinfo != stack_groupinfo)\n  ccontext->memctl.free((void *)cb.groupinfo, ccontext->memctl.memory_data);\nreturn re;    /* Will be NULL after an error */\n\n/* Errors discovered in parse_regex() set the offset value in the compile\nblock. Errors discovered before it is called must compute it from the ptr\nvalue. After parse_regex() is called, the offset in the compile block is set to\nthe end of the pattern, but certain errors in compile_regex() may reset it if\nan offset is available in the parsed pattern. */\n\nHAD_CB_ERROR:\nptr = pattern + cb.erroroffset;\n\nHAD_EARLY_ERROR:\n*erroroffset = ptr - pattern;\n\nHAD_ERROR:\n*errorptr = errorcode;\npcre2_code_free(re);\nre = NULL;\ngoto EXIT;\n}\n\n/* End of pcre2_compile.c */\n/*autoconv-0001 C:\\projects\\pcre2-10.35\\src\\pcre2_compile.c converted to COMPILE2*/\n/*autoconv-0011 COMPILE2 line: 43 config.h replaced by CONFIG.h*/\n/*autoconv-0011 COMPILE2 line: 50 pcre2_internal.h replaced by INTERNA2.h*/\n/*autoconv-0011 COMPILE2 line: 60 pcre2_printint.c replaced by PRINTIN2.c*/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CONFIG": {"ttr": 14337, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "\n\n/* src/config.h.  Generated from config.h.in by configure.  */\n/* src/config.h.in.  Generated from configure.ac by autoheader.  */\n\n/* PCRE2 is written in Standard C, but there are a few non-standard things it\ncan cope with, allowing it to run on SunOS4 and other \"close to standard\"\nsystems.\n\nIn environments that support the GNU autotools, config.h.in is converted into\nconfig.h by the \"configure\" script. In environments that use CMake,\nconfig-cmake.in is converted into config.h. If you are going to build PCRE2 \"by\nhand\" without using \"configure\" or CMake, you should copy the distributed\nconfig.h.generic to config.h, and edit the macro definitions to be the way you\nneed them. You must then add -DHAVE_CONFIG_H to all of your compile commands,\nso that config.h is included at the start of every source.\n\nAlternatively, you can avoid editing by using -D on the compiler command line\nto set the macro values. In this case, you do not have to set -DHAVE_CONFIG_H,\nbut if you do, default values will be taken from config.h for non-boolean\nmacros that are not defined on the command line.\n\nBoolean macros such as HAVE_STDLIB_H and SUPPORT_PCRE2_8 should either be\ndefined (conventionally to 1) for TRUE, and not defined at all for FALSE. All\nsuch macros are listed as a commented #undef in config.h.generic. Macros such\nas MATCH_LIMIT, whose actual value is relevant, have defaults defined, but are\nsurrounded by #ifndef/#endif lines so that the value can be overridden by -D.\n\nPCRE2 uses memmove() if HAVE_MEMMOVE is defined; otherwise it uses bcopy() if\nHAVE_BCOPY is defined. If your system has neither bcopy() nor memmove(), make\nsure both macros are undefined; an emulation function will then be used. */\n\n/* By default, the \\R escape sequence matches any Unicode line ending\n   character or sequence of characters. If BSR_ANYCRLF is defined (to any\n   value), this is changed so that backslash-R matches only CR, LF, or CRLF.\n   The build-time default can be overridden by the user of PCRE2 at runtime.\n   */\n/* #undef BSR_ANYCRLF */\n/* This config.h was generated manually from config.h.grnrric for native z/OS.\nVersion 0.3 (for PCRE2)\nChanges by Ze'ev Atlas 2015.\nThe purpose of this particular version is for porting into native z/OS without\nUSS (Unix Services) and with EBCDIC in whatever flavor as the character set.\nThis version supports EBCDIC only.  That implies by default (dictated by the\npcre package) neither UTF-8, nor UTF-16 support.  Thus, also No support for any\nIBM DBCS has been attempted!\nAlso\n* this version does not support C++!\n* this version does not support JIT! #It was decided that JIT should never be\n  supported in z/OS.\nSee documentation for details */\n/* ZA - general z/OS signal - also in OPTFILE*/\n#ifndef NATIVE_ZOS\n#define NATIVE_ZOS 1\n#endif\n/* ZA - EBCDIC codepage used */\n/* Change your target EBCDIC codepage to 1 and leave the rest as 0.\n   These definitions might not be needed and if so would be deprecated\n   and removed in subsequent releases.  Current version compiles under\n   IBM1140 (037) and the definition is not used anywhere in the code */\n/* Common in US */\n#define IBM1047 0\n/* Hebrew */\n#define IBM424 0\n/* Greek */\n#define IBM875 0\n/* Turkish */\n#define IBM1026 0\n/* Older US version 037 */\n#define IBM1140 1\n/* CP500 */\n#define IBM1148 0\n/* UK - maybe superseded by CP500 - investigate */\n#define IBM285 0\n#if IBM1047 + IBM424 + IBM875 + IBM1026 + IBM1140 + IBM1148 + IBM285 != 1\n#error please define one and only one EBCDIC codepage\n#endif\n/* Define to any value to disable the use of the z and t modifiers in\n   formatting settings such as %zu or %td (this is rarely needed). */\n/* #undef DISABLE_PERCENT_ZT */\n\n/* If you are compiling for a system that uses EBCDIC instead of ASCII\n   character codes, define this macro to any value. When EBCDIC is set, PCRE2\n   assumes that all input strings are in EBCDIC. If you do not define this\n   macro, PCRE2 will assume input strings are ASCII or UTF-8/16/32 Unicode. It\n   is not possible to build a version of PCRE2 that supports both EBCDIC and\n   UTF-8/16/32. */\n/* ZA - define EBCDIC for native z/OS - also in OPTFILE*/\n#define EBCDIC 1\n\n/* In an EBCDIC environment, define this macro to any value to arrange for the\n   NL character to be 0x25 instead of the default 0x15. NL plays the role that\n   LF does in an ASCII/Unicode environment. */\n/* ZA - IBM implemented the NL 0x15 to be the definite New Line rather than LF\n   or CR or CRLF.  Thus never #define EBCDIC_NL25, otherwise \\n will not work\n   correctly */\n#undef EBCDIC_NL25\n\n/* Define this if your compiler supports __attribute__((uninitialized)) */\n/* #undef HAVE_ATTRIBUTE_UNINITIALIZED */\n\n/* Define to 1 if you have the `bcopy' function. */\n#define HAVE_BCOPY 1\n\n/* Define to 1 if you have the <bzlib.h> header file. */\n#define HAVE_BZLIB_H 1\n\n/* Define to 1 if you have the <dirent.h> header file. */\n/* ZA - not available in z/OS*/\n/* #undef HAVE_DIRENT_H */\n\n/* Define to 1 if you have the <dlfcn.h> header file. */\n#define HAVE_DLFCN_H 1\n\n/* Define to 1 if you have the <editline/readline.h> header file. */\n/* #undef HAVE_EDITLINE_READLINE_H */\n\n/* Define to 1 if you have the <edit/readline/readline.h> header file. */\n/* #undef HAVE_EDIT_READLINE_READLINE_H */\n\n/* Define to 1 if you have the <inttypes.h> header file. */\n#define HAVE_INTTYPES_H 1\n\n/* Define to 1 if you have the <limits.h> header file. */\n#define HAVE_LIMITS_H 1\n\n/* Define to 1 if you have the `memfd_create' function. */\n/* #undef HAVE_MEMFD_CREATE */\n\n/* Define to 1 if you have the `memmove' function. */\n#define HAVE_MEMMOVE 1\n\n/* Define to 1 if you have the <memory.h> header file. */\n#define HAVE_MEMORY_H 1\n\n/* Define to 1 if you have the `mkostemp' function. */\n/* #undef HAVE_MKOSTEMP */\n/* Define if you have POSIX threads libraries and header files. */\n/* #undef HAVE_PTHREAD */\n\n/* Have PTHREAD_PRIO_INHERIT. */\n/* #undef HAVE_PTHREAD_PRIO_INHERIT */\n\n/* Define to 1 if you have the <readline/history.h> header file. */\n/* #undef HAVE_READLINE_HISTORY_H */\n\n/* Define to 1 if you have the <readline/readline.h> header file. */\n/* #undef HAVE_READLINE_READLINE_H */\n\n/* Define to 1 if you have the `secure_getenv' function. */\n/* #undef HAVE_SECURE_GETENV */\n\n/* Define to 1 if you have the <stdint.h> header file. */\n/* ZA - This requires also LANGLVL(EXTC99) */\n#define HAVE_STDINT_H 1\n\n/* Define to 1 if you have the <stdlib.h> header file. */\n#define HAVE_STDLIB_H 1\n\n/* Define to 1 if you have the `strerror' function. */\n#define HAVE_STRERROR 1\n\n/* Define to 1 if you have the <strings.h> header file. */\n#define HAVE_STRINGS_H 1\n\n/* Define to 1 if you have the <string.h> header file. */\n#define HAVE_STRING_H 1\n\n/* Define to 1 if you have the <sys/stat.h> header file. */\n#define HAVE_SYS_STAT_H 1\n\n/* Define to 1 if you have the <sys/types.h> header file. */\n#define HAVE_SYS_TYPES_H 1\n\n/* Define to 1 if you have the <sys/wait.h> header file. */\n#define HAVE_SYS_WAIT_H\n\n/* Define to 1 if you have the <unistd.h> header file. */\n#define HAVE_UNISTD_H 1\n\n/* Define to 1 if the compiler supports simple visibility declarations. */\n/* #undef HAVE_VISIBILITY */\n\n/* Define to 1 if you have the <windows.h> header file. */\n/* #undef HAVE_WINDOWS_H */\n\n/* Define to 1 if you have the <zlib.h> header file. */\n#define HAVE_ZLIB_H 1\n\n/* This limits the amount of memory that may be used while matching a pattern.\n   It applies to both pcre2_match() and pcre2_dfa_match(). It does not apply\n   to JIT matching. The value is in kibibytes (units of 1024 bytes). */\n#ifndef HEAP_LIMIT\n#define HEAP_LIMIT\n#endif\n\n/* The value of LINK_SIZE determines the number of bytes used to store links\n   as offsets within the compiled regex. The default is 2, which allows for\n   compiled patterns up to 65535 code units long. This covers the vast\n   majority of cases. However, PCRE2 can also be compiled to use 3 or 4 bytes\n   instead. This allows for longer patterns in extreme cases. */\n#ifndef LINK_SIZE\n#define LINK_SIZE 2\n#endif\n\n/* Define to the sub-directory where libtool stores uninstalled libraries. */\n/* This is ignored unless you are using libtool. */\n#ifndef LT_OBJDIR\n#define LT_OBJDIR \".libs/\"\n#endif\n\n/* The value of MATCH_LIMIT determines the default number of times the\n   pcre2_match() function can record a backtrack position during a single\n   matching attempt. The value is also used to limit a loop counter in\n   pcre2_dfa_match(). There is a runtime interface for setting a different\n   limit. The limit exists in order to catch runaway regular expressions that\n   take for ever to determine that they do not match. The default is set very\n   large so that it does not accidentally catch legitimate cases. */\n#ifndef MATCH_LIMIT\n#define MATCH_LIMIT\n#endif\n\n/* The above limit applies to all backtracks, whether or not they are nested.\n   In some environments it is desirable to limit the nesting of backtracking\n   (that is, the depth of tree that is searched) more strictly, in order to\n   restrict the maximum amount of heap memory that is used. The value of\n   MATCH_LIMIT_DEPTH provides this facility. To have any useful effect, it\n   must be less than the value of MATCH_LIMIT. The default is to use the same\n   value as MATCH_LIMIT. There is a runtime method for setting a different\n   limit. In the case of pcre2_dfa_match(), this limit controls the depth of\n   the internal nested function calls that are used for pattern recursions,\n   lookarounds, and atomic groups. */\n#ifndef MATCH_LIMIT_DEPTH\n#define MATCH_LIMIT_DEPTH MATCH_LIMIT\n#endif\n\n/* This limit is parameterized just in case anybody ever wants to change it.\n   Care must be taken if it is increased, because it guards against integer\n   overflow caused by enormously large patterns. */\n#ifndef MAX_NAME_COUNT\n#define MAX_NAME_COUNT 10000\n#endif\n\n/* This limit is parameterized just in case anybody ever wants to change it.\n   Care must be taken if it is increased, because it guards against integer\n   overflow caused by enormously large patterns. */\n#ifndef MAX_NAME_SIZE\n#define MAX_NAME_SIZE 32\n#endif\n/* Defining NEVER_BACKSLASH_C locks out the use of \\C in all patterns. */\n#undef NEVER_BACKSLASH_C\n\n/* The value of NEWLINE_DEFAULT determines the default newline character\n   sequence. PCRE2 client programs can override this by selecting other values\n   at run time. The valid values are 1 (CR), 2 (LF), 3 (CRLF), 4 (ANY), 5\n   (ANYCRLF), and 6 (NUL). */\n#ifndef NEWLINE_DEFAULT\n#define NEWLINE_DEFAULT 2\n#endif\n\n/* Name of package */\n#define PACKAGE \"pcre2\"\n\n/* Define to the address where bug reports for this package should be sent. */\n#define PACKAGE_BUGREPORT \"\"\n\n/* Define to the full name of this package. */\n#define PACKAGE_NAME \"PCRE2\"\n\n/* Define to the full name and version of this package. */\n#define PACKAGE_STRING \"PCRE2 10.35\"\n\n/* Define to the one symbol short name of this package. */\n#define PACKAGE_TARNAME \"pcre2\"\n\n/* Define to the home page for this package. */\n#define PACKAGE_URL \"\"\n\n/* Define to the version of this package. */\n#define PACKAGE_VERSION \"10.35\"\n\n/* The value of PARENS_NEST_LIMIT specifies the maximum depth of nested\n   parentheses (of any kind) in a pattern. This limits the amount of system\n   stack that is used while compiling a pattern. */\n#ifndef PARENS_NEST_LIMIT\n#define PARENS_NEST_LIMIT 250\n#endif\n\n/* The value of PCRE2GREP_BUFSIZE is the starting size of the buffer used by\n   pcre2grep to hold parts of the file it is searching. The buffer will be\n   expanded up to PCRE2GREP_MAX_BUFSIZE if necessary, for files containing\n   very long lines. The actual amount of memory used by pcre2grep is three\n   times this number, because it allows for the buffering of \"before\" and\n   \"after\" lines. */\n#ifndef PCRE2GREP_BUFSIZE\n#define PCRE2GREP_BUFSIZE 20480\n#endif\n\n/* The value of PCRE2GREP_MAX_BUFSIZE specifies the maximum size of the buffer\n   used by pcre2grep to hold parts of the file it is searching. The actual\n   amount of memory used by pcre2grep is three times this number, because it\n   allows for the buffering of \"before\" and \"after\" lines. */\n#ifndef PCRE2GREP_MAX_BUFSIZE\n#define PCRE2GREP_MAX_BUFSIZE 1048576\n#endif\n\n/* Define to any value to include debugging code. */\n/* #undef PCRE2_DEBUG */\n\n/* to make a symbol visible */\n#undef PCRE2_EXP_DECL\n\n\n/* If you are compiling for a system other than a Unix-like system or\n   Win32, and it needs some magic to be inserted before the definition\n   of a function that is exported by the library, define this macro to\n   contain the relevant magic. If you do not define this macro, a suitable\n    __declspec value is used for Windows systems; in other environments\n   \"extern\" is used for a C compiler and \"extern C\" for a C++ compiler.\n   This macro apears at the start of every exported function that is part\n   of the external API. It does not appear on functions that are \"external\"\n   in the C sense, but which are internal to the library. */\n/* #undef PCRE2_EXP_DEFN */\n\n/* Define to any value if linking statically (TODO: make nice with Libtool) */\n/* #undef PCRE2_STATIC */\n\n/* Define to necessary symbol if this constant uses a non-standard name on\n   your system. */\n/* #undef PTHREAD_CREATE_JOINABLE */\n\n/* Define to any non-zero number to enable support for SELinux compatible\n   executable memory allocator in JIT. Note that this will have no effect\n   unless SUPPORT_JIT is also defined. */\n/* #undef SLJIT_PROT_EXECUTABLE_ALLOCATOR */\n\n/* Define to 1 if you have the ANSI C header files. */\n#define STDC_HEADERS 1\n\n/* Define to any value to enable support for Just-In-Time compiling. */\n/* ZA - undef for z/OS - also in OPTFILE */\n#undef SUPPORT_JIT\n\n/* Define to any value to allow pcre2grep to be linked with libbz2, so that it\n   is able to handle .bz2 files. */\n/* #undef SUPPORT_LIBBZ2 */\n\n/* Define to any value to allow pcre2test to be linked with libedit. */\n/* #undef SUPPORT_LIBEDIT */\n\n/* Define to any value to allow pcre2test to be linked with libreadline. */\n/* #undef SUPPORT_LIBREADLINE */\n\n/* Define to any value to allow pcre2grep to be linked with libz, so that it\n   is able to handle .gz files. */\n/* #undef SUPPORT_LIBZ */\n\n/* Define to any value to enable callout script support in pcre2grep. */\n#undef SUPPORT_PCRE2GREP_CALLOUT\n\n/* Define to any value to enable fork support in pcre2grep callout scripts.\n   This will have no effect unless SUPPORT_PCRE2GREP_CALLOUT is also defined.\n   */\n/* #undef SUPPORT_PCRE2GREP_CALLOUT_FORK */\n\n/* Define to any value to enable JIT support in pcre2grep. Note that this will\n   have no effect unless SUPPORT_JIT is also defined. */\n/* #undef SUPPORT_PCRE2GREP_JIT */\n\n/* Define to any value to enable the 16 bit PCRE2 library. */\n/* #undef SUPPORT_PCRE2_16 */\n\n/* Define to any value to enable the 32 bit PCRE2 library. */\n/* #undef SUPPORT_PCRE2_32 */\n/* Define to any value to enable the 8 bit PCRE2 library. */\n#define SUPPORT_PCRE2_8 /**/\n\n/* Define to any value to enable support for Unicode and UTF encoding. This\n   will work even in an EBCDIC environment, but it is incompatible with the\n   EBCDIC macro. That is, PCRE2 can support *either* EBCDIC code *or*\n   ASCII/Unicode, but not both at once. */\n/* #undef SUPPORT_UNICODE */\n\n/* Define to any value for valgrind support to find invalid memory reads. */\n/* #undef SUPPORT_VALGRIND */\n\n/* Enable extensions on AIX 3, Interix.  */\n/*#ifndef _ALL_SOURCE\n# define _ALL_SOURCE 1\n#endif*/\n/* Enable GNU extensions on systems that have them.  */\n/*#ifndef _GNU_SOURCE\n# define _GNU_SOURCE 1\n#endif*/\n/* Enable threading extensions on Solaris.  */\n/*#ifndef _POSIX_PTHREAD_SEMANTICS\n# define _POSIX_PTHREAD_SEMANTICS 1\n#endif*/\n/* Enable extensions on HP NonStop.  */\n/*#ifndef _TANDEM_SOURCE\n# define _TANDEM_SOURCE 1\n#endif*/\n/* Enable general extensions on Solaris.  */\n/*#ifndef __EXTENSIONS__\n# define __EXTENSIONS__ 1\n#endif*/\n\n/* Version number of package */\n#define VERSION \"10.35\"\n\n/* Define to 1 if on MINIX. */\n/* #undef _MINIX */\n\n/* Define to 2 if the system does not provide POSIX.1 features except with\n   this defined. */\n/* #undef _POSIX_1_SOURCE */\n\n/* Define to 1 if you need to in order for `stat' and other things to work. */\n/* #undef _POSIX_SOURCE */\n/* Define to empty if `const' does not conform to ANSI C. */\n/* #undef const */\n\n/* Define to the type of a signed integer type of width exactly 64 bits if\n   such a type exists and the standard includes do not define it. */\n/* #undef int64_t */\n\n/* Define to `unsigned int' if <sys/types.h> does not define. */\n/* #undef size_t */\n\n/* The condition below allows confining the effects of NATIVE_ZOS within\n   the config.h so the rest of the program would compile without it.  The\n   main use of that is in PCREGREP, if we want to ignore the effects of\n   the z/OS specific file system and use it as pure Unix, or as a primitive\n   OS (if we also do not configure DEF(HAVE_SYS_STAT_H), DEF(HAVE_DIRENT_H)\n   and DEF(HAVE_SYS_TYPES_H).  Include such definition in OPTFILE. */\n#ifdef NATIVE_ZOS_OFF\n#undef NATIVE_ZOS\n#endif\n/* Include the automatically generated #pragma map statements*/\n#include \"PCRPRGMA.H\"\n/*autoconv-0021 C:\\projects\\pcre2port\\config.h copied to config*/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CONFIG2": {"ttr": 521, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "\n/*************************************************\n*      Perl-Compatible Regular Expressions       *\n*************************************************/\n\n/* PCRE is a library of functions to support regular expressions whose syntax\nand semantics are as close as possible to those of the Perl 5 language.\n\n                       Written by Philip Hazel\n     Original API code Copyright (c) 1997-2012 University of Cambridge\n          New API code Copyright (c) 2016-2020 University of Cambridge\n\n-----------------------------------------------------------------------------\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n\n    * Redistributions of source code must retain the above copyright notice,\n      this list of conditions and the following disclaimer.\n\n    * Redistributions in binary form must reproduce the above copyright\n      notice, this list of conditions and the following disclaimer in the\n      documentation and/or other materials provided with the distribution.\n\n    * Neither the name of the University of Cambridge nor the names of its\n      contributors may be used to endorse or promote products derived from\n      this software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\nAND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\nIMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\nARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\nLIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\nCONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\nSUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\nINTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\nCONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\nARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\nPOSSIBILITY OF SUCH DAMAGE.\n-----------------------------------------------------------------------------\n*/\n\n#ifdef HAVE_CONFIG_H\n#include \"CONFIG.h\"\n#endif\n\n/* Save the configured link size, which is in bytes. In 16-bit and 32-bit modes\nits value gets changed by pcre2_intmodedep.h (included by pcre2_internal.h) to\nbe in code units. */\n\nstatic int configured_link_size = LINK_SIZE;\n\n#include \"INTERNA2.h\"\n\n/* These macros are the standard way of turning unquoted text into C strings.\nThey allow macros like PCRE2_MAJOR to be defined without quotes, which is\nconvenient for user programs that want to test their values. */\n\n#define STRING(a)  # a\n#define XSTRING(s) STRING(s)\n\n\n/*************************************************\n* Return info about what features are configured *\n*************************************************/\n\n/* If where is NULL, the length of memory required is returned.\n\nArguments:\n  what             what information is required\n  where            where to put the information\n\nReturns:           0 if a numerical value is returned\n                   >= 0 if a string value\n                   PCRE2_ERROR_BADOPTION if \"where\" not recognized\n                     or JIT target requested when JIT not enabled\n*/\n\nPCRE2_EXP_DEFN int PCRE2_CALL_CONVENTION\npcre2_config(uint32_t what, void *where)\n{\nif (where == NULL)  /* Requests a length */\n  {\n  switch(what)\n    {\n    default:\n    return PCRE2_ERROR_BADOPTION;\n\n    case PCRE2_CONFIG_BSR:\n    case PCRE2_CONFIG_COMPILED_WIDTHS:\n    case PCRE2_CONFIG_DEPTHLIMIT:\n    case PCRE2_CONFIG_HEAPLIMIT:\n    case PCRE2_CONFIG_JIT:\n    case PCRE2_CONFIG_LINKSIZE:\n    case PCRE2_CONFIG_MATCHLIMIT:\n    case PCRE2_CONFIG_NEVER_BACKSLASH_C:\n    case PCRE2_CONFIG_NEWLINE:\n    case PCRE2_CONFIG_PARENSLIMIT:\n    case PCRE2_CONFIG_STACKRECURSE:    /* Obsolete */\n    case PCRE2_CONFIG_TABLES_LENGTH:\n    case PCRE2_CONFIG_UNICODE:\n    return sizeof(uint32_t);\n\n    /* These are handled below */\n\n    case PCRE2_CONFIG_JITTARGET:\n    case PCRE2_CONFIG_UNICODE_VERSION:\n    case PCRE2_CONFIG_VERSION:\n    break;\n    }\n  }\n\nswitch (what)\n  {\n  default:\n  return PCRE2_ERROR_BADOPTION;\n\n  case PCRE2_CONFIG_BSR:\n#ifdef BSR_ANYCRLF\n  *((uint32_t *)where) = PCRE2_BSR_ANYCRLF;\n#else\n  *((uint32_t *)where) = PCRE2_BSR_UNICODE;\n#endif\n  break;\n\n  case PCRE2_CONFIG_COMPILED_WIDTHS:\n  *((uint32_t *)where) = 0\n#ifdef SUPPORT_PCRE2_8\n  + 1\n#endif\n#ifdef SUPPORT_PCRE2_16\n  + 2\n#endif\n#ifdef SUPPORT_PCRE2_32\n  + 4\n#endif\n  ;\n  break;\n\n  case PCRE2_CONFIG_DEPTHLIMIT:\n  *((uint32_t *)where) = MATCH_LIMIT_DEPTH;\n  break;\n\n  case PCRE2_CONFIG_HEAPLIMIT:\n  *((uint32_t *)where) = HEAP_LIMIT;\n  break;\n\n  case PCRE2_CONFIG_JIT:\n#ifdef SUPPORT_JIT\n  *((uint32_t *)where) = 1;\n#else\n  *((uint32_t *)where) = 0;\n#endif\n  break;\n\n  case PCRE2_CONFIG_JITTARGET:\n#ifdef SUPPORT_JIT\n    {\n    const char *v = PRIV(jit_get_target)();\n    return (int)(1 + ((where == NULL)?\n      strlen(v) : PRIV(strcpy_c8)((PCRE2_UCHAR *)where, v)));\n    }\n#else\n  return PCRE2_ERROR_BADOPTION;\n#endif\n\n  case PCRE2_CONFIG_LINKSIZE:\n  *((uint32_t *)where) = (uint32_t)configured_link_size;\n  break;\n\n  case PCRE2_CONFIG_MATCHLIMIT:\n  *((uint32_t *)where) = MATCH_LIMIT;\n  break;\n\n  case PCRE2_CONFIG_NEWLINE:\n  *((uint32_t *)where) = NEWLINE_DEFAULT;\n  break;\n\n  case PCRE2_CONFIG_NEVER_BACKSLASH_C:\n#ifdef NEVER_BACKSLASH_C\n  *((uint32_t *)where) = 1;\n#else\n  *((uint32_t *)where) = 0;\n#endif\n  break;\n\n  case PCRE2_CONFIG_PARENSLIMIT:\n  *((uint32_t *)where) = PARENS_NEST_LIMIT;\n  break;\n\n  /* This is now obsolete. The stack is no longer used via recursion for\n  handling backtracking in pcre2_match(). */\n\n  case PCRE2_CONFIG_STACKRECURSE:\n  *((uint32_t *)where) = 0;\n  break;\n\n  case PCRE2_CONFIG_TABLES_LENGTH:\n  *((uint32_t *)where) = TABLES_LENGTH;\n  break;\n\n  case PCRE2_CONFIG_UNICODE_VERSION:\n    {\n#if defined SUPPORT_UNICODE\n    const char *v = PRIV(unicode_version);\n#else\n    const char *v = \"Unicode not supported\";\n#endif\n    return (int)(1 + ((where == NULL)?\n      strlen(v) : PRIV(strcpy_c8)((PCRE2_UCHAR *)where, v)));\n   }\n  break;\n\n  case PCRE2_CONFIG_UNICODE:\n#if defined SUPPORT_UNICODE\n  *((uint32_t *)where) = 1;\n#else\n  *((uint32_t *)where) = 0;\n#endif\n  break;\n\n  /* The hackery in setting \"v\" below is to cope with the case when\n  PCRE2_PRERELEASE is set to an empty string (which it is for real releases).\n  If the second alternative is used in this case, it does not leave a space\n  before the date. On the other hand, if all four macros are put into a single\n  XSTRING when PCRE2_PRERELEASE is not empty, an unwanted space is inserted.\n  There are problems using an \"obvious\" approach like this:\n\n     XSTRING(PCRE2_MAJOR) \".\" XSTRING(PCRE_MINOR)\n     XSTRING(PCRE2_PRERELEASE) \" \" XSTRING(PCRE_DATE)\n\n  because, when PCRE2_PRERELEASE is empty, this leads to an attempted expansion\n  of STRING(). The C standard states: \"If (before argument substitution) any\n  argument consists of no preprocessing tokens, the behavior is undefined.\" It\n  turns out the gcc treats this case as a single empty string - which is what\n  we really want - but Visual C grumbles about the lack of an argument for the\n  macro. Unfortunately, both are within their rights. As there seems to be no\n  way to test for a macro's value being empty at compile time, we have to\n  resort to a runtime test. */\n\n  case PCRE2_CONFIG_VERSION:\n    {\n    const char *v = (XSTRING(Z PCRE2_PRERELEASE)\u00dd1\u00a8 == 0)?\n      XSTRING(PCRE2_MAJOR.PCRE2_MINOR PCRE2_DATE) :\n      XSTRING(PCRE2_MAJOR.PCRE2_MINOR) XSTRING(PCRE2_PRERELEASE PCRE2_DATE);\n    return (int)(1 + ((where == NULL)?\n      strlen(v) : PRIV(strcpy_c8)((PCRE2_UCHAR *)where, v)));\n    }\n  }\n\nreturn 0;\n}\n\n/* End of pcre2_config.c */\n/*autoconv-0001 C:\\projects\\pcre2-10.35\\src\\pcre2_config.c converted to CONFIG2*/\n/*autoconv-0011 CONFIG2 line: 42 config.h replaced by CONFIG.h*/\n/*autoconv-0011 CONFIG2 line: 51 pcre2_internal.h replaced by INTERNA2.h*/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CONTEXT2": {"ttr": 6401, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "\n/*************************************************\n*      Perl-Compatible Regular Expressions       *\n*************************************************/\n\n/* PCRE is a library of functions to support regular expressions whose syntax\nand semantics are as close as possible to those of the Perl 5 language.\n\n                       Written by Philip Hazel\n     Original API code Copyright (c) 1997-2012 University of Cambridge\n          New API code Copyright (c) 2016-2018 University of Cambridge\n\n-----------------------------------------------------------------------------\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n\n    * Redistributions of source code must retain the above copyright notice,\n      this list of conditions and the following disclaimer.\n\n    * Redistributions in binary form must reproduce the above copyright\n      notice, this list of conditions and the following disclaimer in the\n      documentation and/or other materials provided with the distribution.\n\n    * Neither the name of the University of Cambridge nor the names of its\n      contributors may be used to endorse or promote products derived from\n      this software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\nAND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\nIMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\nARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\nLIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\nCONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\nSUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\nINTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\nCONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\nARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\nPOSSIBILITY OF SUCH DAMAGE.\n-----------------------------------------------------------------------------\n*/\n\n\n#ifdef HAVE_CONFIG_H\n#include \"CONFIG.h\"\n#endif\n\n#include \"INTERNA2.h\"\n\n\n\n/*************************************************\n*          Default malloc/free functions         *\n*************************************************/\n\n/* Ignore the \"user data\" argument in each case. */\n\nstatic void *default_malloc(size_t size, void *data)\n{\n(void)data;\nreturn malloc(size);\n}\n\n\nstatic void default_free(void *block, void *data)\n{\n(void)data;\nfree(block);\n}\n\n\n\n/*************************************************\n*        Get a block and save memory control     *\n*************************************************/\n\n/* This internal function is called to get a block of memory in which the\nmemory control data is to be stored at the start for future use.\n\nArguments:\n  size        amount of memory required\n  memctl      pointer to a memctl block or NULL\n\nReturns:      pointer to memory or NULL on failure\n*/\n\nextern void *\nPRIV(memctl_malloc)(size_t size, pcre2_memctl *memctl)\n{\npcre2_memctl *newmemctl;\nvoid *yield = (memctl == NULL)? malloc(size) :\n  memctl->malloc(size, memctl->memory_data);\nif (yield == NULL) return NULL;\nnewmemctl = (pcre2_memctl *)yield;\nif (memctl == NULL)\n  {\n  newmemctl->malloc = default_malloc;\n  newmemctl->free = default_free;\n  newmemctl->memory_data = NULL;\n  }\nelse *newmemctl = *memctl;\nreturn yield;\n}\n\n\n\n/*************************************************\n*          Create and initialize contexts        *\n*************************************************/\n\n/* Initializing for compile and match contexts is done in separate, private\nfunctions so that these can be called from functions such as pcre2_compile()\nwhen an external context is not supplied. The initializing functions have an\noption to set up default memory management. */\n\nPCRE2_EXP_DEFN pcre2_general_context * PCRE2_CALL_CONVENTION\npcre2_general_context_create(void *(*private_malloc)(size_t, void *),\n  void (*private_free)(void *, void *), void *memory_data)\n{\npcre2_general_context *gcontext;\nif (private_malloc == NULL) private_malloc = default_malloc;\nif (private_free == NULL) private_free = default_free;\ngcontext = private_malloc(sizeof(pcre2_real_general_context), memory_data);\nif (gcontext == NULL) return NULL;\ngcontext->memctl.malloc = private_malloc;\ngcontext->memctl.free = private_free;\ngcontext->memctl.memory_data = memory_data;\nreturn gcontext;\n}\n\n\n/* A default compile context is set up to save having to initialize at run time\nwhen no context is supplied to the compile function. */\n\nconst pcre2_compile_context PRIV(default_compile_context) = {\n  { default_malloc, default_free, NULL },    /* Default memory handling */\n  NULL,                                      /* Stack guard */\n  NULL,                                      /* Stack guard data */\n  PRIV(default_tables),                      /* Character tables */\n  PCRE2_UNSET,                               /* Max pattern length */\n  BSR_DEFAULT,                               /* Backslash R default */\n  NEWLINE_DEFAULT,                           /* Newline convention */\n  PARENS_NEST_LIMIT,                         /* As it says */\n  0 };                                       /* Extra options */\n\n/* The create function copies the default into the new memory, but must\noverride the default memory handling functions if a gcontext was provided. */\n\nPCRE2_EXP_DEFN pcre2_compile_context * PCRE2_CALL_CONVENTION\npcre2_compile_context_create(pcre2_general_context *gcontext)\n{\npcre2_compile_context *ccontext = PRIV(memctl_malloc)(\n  sizeof(pcre2_real_compile_context), (pcre2_memctl *)gcontext);\nif (ccontext == NULL) return NULL;\n*ccontext = PRIV(default_compile_context);\nif (gcontext != NULL)\n  *((pcre2_memctl *)ccontext) = *((pcre2_memctl *)gcontext);\nreturn ccontext;\n}\n\n\n/* A default match context is set up to save having to initialize at run time\nwhen no context is supplied to a match function. */\n\nconst pcre2_match_context PRIV(default_match_context) = {\n  { default_malloc, default_free, NULL },\n#ifdef SUPPORT_JIT\n  NULL,          /* JIT callback */\n  NULL,          /* JIT callback data */\n#endif\n  NULL,          /* Callout function */\n  NULL,          /* Callout data */\n  NULL,          /* Substitute callout function */\n  NULL,          /* Substitute callout data */\n  PCRE2_UNSET,   /* Offset limit */\n  HEAP_LIMIT,\n  MATCH_LIMIT,\n  MATCH_LIMIT_DEPTH };\n\n/* The create function copies the default into the new memory, but must\noverride the default memory handling functions if a gcontext was provided. */\n\nPCRE2_EXP_DEFN pcre2_match_context * PCRE2_CALL_CONVENTION\npcre2_match_context_create(pcre2_general_context *gcontext)\n{\npcre2_match_context *mcontext = PRIV(memctl_malloc)(\n  sizeof(pcre2_real_match_context), (pcre2_memctl *)gcontext);\nif (mcontext == NULL) return NULL;\n*mcontext = PRIV(default_match_context);\nif (gcontext != NULL)\n  *((pcre2_memctl *)mcontext) = *((pcre2_memctl *)gcontext);\nreturn mcontext;\n}\n\n\n/* A default convert context is set up to save having to initialize at run time\nwhen no context is supplied to the convert function. */\n\nconst pcre2_convert_context PRIV(default_convert_context) = {\n  { default_malloc, default_free, NULL },    /* Default memory handling */\n#ifdef _WIN32\n  CHAR_BACKSLASH,                            /* Default path separator */\n  CHAR_GRAVE_ACCENT                          /* Default escape character */\n#else  /* Not Windows */\n  CHAR_SLASH,                                /* Default path separator */\n  CHAR_BACKSLASH                             /* Default escape character */\n#endif\n  };\n\n/* The create function copies the default into the new memory, but must\noverride the default memory handling functions if a gcontext was provided. */\n\nPCRE2_EXP_DEFN pcre2_convert_context * PCRE2_CALL_CONVENTION\npcre2_convert_context_create(pcre2_general_context *gcontext)\n{\npcre2_convert_context *ccontext = PRIV(memctl_malloc)(\n  sizeof(pcre2_real_convert_context), (pcre2_memctl *)gcontext);\nif (ccontext == NULL) return NULL;\n*ccontext = PRIV(default_convert_context);\nif (gcontext != NULL)\n  *((pcre2_memctl *)ccontext) = *((pcre2_memctl *)gcontext);\nreturn ccontext;\n}\n\n\n/*************************************************\n*              Context copy functions            *\n*************************************************/\n\nPCRE2_EXP_DEFN pcre2_general_context * PCRE2_CALL_CONVENTION\npcre2_general_context_copy(pcre2_general_context *gcontext)\n{\npcre2_general_context *new =\n  gcontext->memctl.malloc(sizeof(pcre2_real_general_context),\n  gcontext->memctl.memory_data);\nif (new == NULL) return NULL;\nmemcpy(new, gcontext, sizeof(pcre2_real_general_context));\nreturn new;\n}\n\n\nPCRE2_EXP_DEFN pcre2_compile_context * PCRE2_CALL_CONVENTION\npcre2_compile_context_copy(pcre2_compile_context *ccontext)\n{\npcre2_compile_context *new =\n  ccontext->memctl.malloc(sizeof(pcre2_real_compile_context),\n  ccontext->memctl.memory_data);\nif (new == NULL) return NULL;\nmemcpy(new, ccontext, sizeof(pcre2_real_compile_context));\nreturn new;\n}\n\n\nPCRE2_EXP_DEFN pcre2_match_context * PCRE2_CALL_CONVENTION\npcre2_match_context_copy(pcre2_match_context *mcontext)\n{\npcre2_match_context *new =\n  mcontext->memctl.malloc(sizeof(pcre2_real_match_context),\n  mcontext->memctl.memory_data);\nif (new == NULL) return NULL;\nmemcpy(new, mcontext, sizeof(pcre2_real_match_context));\nreturn new;\n}\n\n\n\nPCRE2_EXP_DEFN pcre2_convert_context * PCRE2_CALL_CONVENTION\npcre2_convert_context_copy(pcre2_convert_context *ccontext)\n{\npcre2_convert_context *new =\n  ccontext->memctl.malloc(sizeof(pcre2_real_convert_context),\n  ccontext->memctl.memory_data);\nif (new == NULL) return NULL;\nmemcpy(new, ccontext, sizeof(pcre2_real_convert_context));\nreturn new;\n}\n\n\n/*************************************************\n*              Context free functions            *\n*************************************************/\n\nPCRE2_EXP_DEFN void PCRE2_CALL_CONVENTION\npcre2_general_context_free(pcre2_general_context *gcontext)\n{\nif (gcontext != NULL)\n  gcontext->memctl.free(gcontext, gcontext->memctl.memory_data);\n}\n\n\nPCRE2_EXP_DEFN void PCRE2_CALL_CONVENTION\npcre2_compile_context_free(pcre2_compile_context *ccontext)\n{\nif (ccontext != NULL)\n  ccontext->memctl.free(ccontext, ccontext->memctl.memory_data);\n}\n\n\nPCRE2_EXP_DEFN void PCRE2_CALL_CONVENTION\npcre2_match_context_free(pcre2_match_context *mcontext)\n{\nif (mcontext != NULL)\n  mcontext->memctl.free(mcontext, mcontext->memctl.memory_data);\n}\n\n\nPCRE2_EXP_DEFN void PCRE2_CALL_CONVENTION\npcre2_convert_context_free(pcre2_convert_context *ccontext)\n{\nif (ccontext != NULL)\n  ccontext->memctl.free(ccontext, ccontext->memctl.memory_data);\n}\n\n\n/*************************************************\n*             Set values in contexts             *\n*************************************************/\n\n/* All these functions return 0 for success or PCRE2_ERROR_BADDATA if invalid\ndata is given. Only some of the functions are able to test the validity of the\ndata. */\n\n\n/* ------------ Compile context ------------ */\n\nPCRE2_EXP_DEFN int PCRE2_CALL_CONVENTION\npcre2_set_character_tables(pcre2_compile_context *ccontext,\n  const uint8_t *tables)\n{\nccontext->tables = tables;\nreturn 0;\n}\n\nPCRE2_EXP_DEFN int PCRE2_CALL_CONVENTION\npcre2_set_bsr(pcre2_compile_context *ccontext, uint32_t value)\n{\nswitch(value)\n  {\n  case PCRE2_BSR_ANYCRLF:\n  case PCRE2_BSR_UNICODE:\n  ccontext->bsr_convention = value;\n  return 0;\n\n  default:\n  return PCRE2_ERROR_BADDATA;\n  }\n}\n\nPCRE2_EXP_DEFN int PCRE2_CALL_CONVENTION\npcre2_set_max_pattern_length(pcre2_compile_context *ccontext, PCRE2_SIZE length)\n{\nccontext->max_pattern_length = length;\nreturn 0;\n}\n\nPCRE2_EXP_DEFN int PCRE2_CALL_CONVENTION\npcre2_set_newline(pcre2_compile_context *ccontext, uint32_t newline)\n{\nswitch(newline)\n  {\n  case PCRE2_NEWLINE_CR:\n  case PCRE2_NEWLINE_LF:\n  case PCRE2_NEWLINE_CRLF:\n  case PCRE2_NEWLINE_ANY:\n  case PCRE2_NEWLINE_ANYCRLF:\n  case PCRE2_NEWLINE_NUL:\n  ccontext->newline_convention = newline;\n  return 0;\n\n  default:\n  return PCRE2_ERROR_BADDATA;\n  }\n}\n\nPCRE2_EXP_DEFN int PCRE2_CALL_CONVENTION\npcre2_set_parens_nest_limit(pcre2_compile_context *ccontext, uint32_t limit)\n{\nccontext->parens_nest_limit = limit;\nreturn 0;\n}\n\nPCRE2_EXP_DEFN int PCRE2_CALL_CONVENTION\npcre2_set_compile_extra_options(pcre2_compile_context *ccontext, uint32_t options)\n{\nccontext->extra_options = options;\nreturn 0;\n}\n\nPCRE2_EXP_DEFN int PCRE2_CALL_CONVENTION\npcre2_set_compile_recursion_guard(pcre2_compile_context *ccontext,\n  int (*guard)(uint32_t, void *), void *user_data)\n{\nccontext->stack_guard = guard;\nccontext->stack_guard_data = user_data;\nreturn 0;\n}\n\n\n/* ------------ Match context ------------ */\n\nPCRE2_EXP_DEFN int PCRE2_CALL_CONVENTION\npcre2_set_callout(pcre2_match_context *mcontext,\n  int (*callout)(pcre2_callout_block *, void *), void *callout_data)\n{\nmcontext->callout = callout;\nmcontext->callout_data = callout_data;\nreturn 0;\n}\n\nPCRE2_EXP_DEFN int PCRE2_CALL_CONVENTION\npcre2_set_substitute_callout(pcre2_match_context *mcontext,\n  int (*substitute_callout)(pcre2_substitute_callout_block *, void *),\n    void *substitute_callout_data)\n{\nmcontext->substitute_callout = substitute_callout;\nmcontext->substitute_callout_data = substitute_callout_data;\nreturn 0;\n}\n\nPCRE2_EXP_DEFN int PCRE2_CALL_CONVENTION\npcre2_set_heap_limit(pcre2_match_context *mcontext, uint32_t limit)\n{\nmcontext->heap_limit = limit;\nreturn 0;\n}\n\nPCRE2_EXP_DEFN int PCRE2_CALL_CONVENTION\npcre2_set_match_limit(pcre2_match_context *mcontext, uint32_t limit)\n{\nmcontext->match_limit = limit;\nreturn 0;\n}\n\nPCRE2_EXP_DEFN int PCRE2_CALL_CONVENTION\npcre2_set_depth_limit(pcre2_match_context *mcontext, uint32_t limit)\n{\nmcontext->depth_limit = limit;\nreturn 0;\n}\n\nPCRE2_EXP_DEFN int PCRE2_CALL_CONVENTION\npcre2_set_offset_limit(pcre2_match_context *mcontext, PCRE2_SIZE limit)\n{\nmcontext->offset_limit = limit;\nreturn 0;\n}\n\n/* This function became obsolete at release 10.30. It is kept as a synonym for\nbackwards compatibility. */\n\nPCRE2_EXP_DEFN int PCRE2_CALL_CONVENTION\npcre2_set_recursion_limit(pcre2_match_context *mcontext, uint32_t limit)\n{\nreturn pcre2_set_depth_limit(mcontext, limit);\n}\n\nPCRE2_EXP_DEFN int PCRE2_CALL_CONVENTION\npcre2_set_recursion_memory_management(pcre2_match_context *mcontext,\n  void *(*mymalloc)(size_t, void *), void (*myfree)(void *, void *),\n  void *mydata)\n{\n(void)mcontext;\n(void)mymalloc;\n(void)myfree;\n(void)mydata;\nreturn 0;\n}\n\n/* ------------ Convert context ------------ */\n\nPCRE2_EXP_DEFN int PCRE2_CALL_CONVENTION\npcre2_set_glob_separator(pcre2_convert_context *ccontext, uint32_t separator)\n{\nif (separator != CHAR_SLASH && separator != CHAR_BACKSLASH &&\n    separator != CHAR_DOT) return PCRE2_ERROR_BADDATA;\nccontext->glob_separator = separator;\nreturn 0;\n}\n\nPCRE2_EXP_DEFN int PCRE2_CALL_CONVENTION\npcre2_set_glob_escape(pcre2_convert_context *ccontext, uint32_t escape)\n{\nif (escape > 255 || (escape != 0 && !ispunct(escape)))\n  return PCRE2_ERROR_BADDATA;\nccontext->glob_escape = escape;\nreturn 0;\n}\n\n/* End of pcre2_context.c */\n\n/*autoconv-0001 C:\\projects\\pcre2-10.35\\src\\pcre2_context.c converted to CONTEXT2*/\n/*autoconv-0011 CONTEXT2 line: 43 config.h replaced by CONFIG.h*/\n/*autoconv-0011 CONTEXT2 line: 46 pcre2_internal.h replaced by INTERNA2.h*/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CONVERT2": {"ttr": 3587, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "\n/*************************************************\n*      Perl-Compatible Regular Expressions       *\n*************************************************/\n\n/* PCRE is a library of functions to support regular expressions whose syntax\nand semantics are as close as possible to those of the Perl 5 language.\n\n                       Written by Philip Hazel\n     Original API code Copyright (c) 1997-2012 University of Cambridge\n          New API code Copyright (c) 2016-2018 University of Cambridge\n\n-----------------------------------------------------------------------------\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n\n    * Redistributions of source code must retain the above copyright notice,\n      this list of conditions and the following disclaimer.\n\n    * Redistributions in binary form must reproduce the above copyright\n      notice, this list of conditions and the following disclaimer in the\n      documentation and/or other materials provided with the distribution.\n\n    * Neither the name of the University of Cambridge nor the names of its\n      contributors may be used to endorse or promote products derived from\n      this software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\nAND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\nIMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\nARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\nLIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\nCONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\nSUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\nINTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\nCONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\nARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\nPOSSIBILITY OF SUCH DAMAGE.\n-----------------------------------------------------------------------------\n*/\n\n\n#ifdef HAVE_CONFIG_H\n#include \"CONFIG.h\"\n#endif\n\n#include \"INTERNA2.h\"\n\n#define TYPE_OPTIONS (PCRE2_CONVERT_GLOB| \\\n  PCRE2_CONVERT_POSIX_BASIC|PCRE2_CONVERT_POSIX_EXTENDED)\n\n#define ALL_OPTIONS (PCRE2_CONVERT_UTF|PCRE2_CONVERT_NO_UTF_CHECK| \\\n  PCRE2_CONVERT_GLOB_NO_WILD_SEPARATOR| \\\n  PCRE2_CONVERT_GLOB_NO_STARSTAR| \\\n  TYPE_OPTIONS)\n\n#define DUMMY_BUFFER_SIZE 100\n\n/* Generated pattern fragments */\n\n#define STR_BACKSLASH_A STR_BACKSLASH STR_A\n#define STR_BACKSLASH_z STR_BACKSLASH STR_z\n#define STR_COLON_RIGHT_SQUARE_BRACKET STR_COLON STR_RIGHT_SQUARE_BRACKET\n#define STR_DOT_STAR_LOOKBEHIND STR_DOT STR_ASTERISK STR_LEFT_PARENTHESIS STR_QUESTION_MARK STR_LESS_THAN_SIGN STR_EQUALS_SIGN\n#define STR_LOOKAHEAD_NOT_DOT STR_LEFT_PARENTHESIS STR_QUESTION_MARK STR_EXCLAMATION_MARK STR_BACKSLASH STR_DOT STR_RIGHT_PARENTHESIS\n#define STR_QUERY_s STR_LEFT_PARENTHESIS STR_QUESTION_MARK STR_s STR_RIGHT_PARENTHESIS\n#define STR_STAR_NUL STR_LEFT_PARENTHESIS STR_ASTERISK STR_N STR_U STR_L STR_RIGHT_PARENTHESIS\n\n/* States for range and POSIX processing */\n\nenum { RANGE_NOT_STARTED, RANGE_STARTING, RANGE_STARTED };\nenum { POSIX_START_REGEX, POSIX_ANCHORED, POSIX_NOT_BRACKET,\n       POSIX_CLASS_NOT_STARTED, POSIX_CLASS_STARTING, POSIX_CLASS_STARTED };\n\n/* Macro to add a character string to the output buffer, checking for overflow. */\n\n#define PUTCHARS(string) \\\n  { \\\n  for (s = (char *)(string); *s != 0; s++) \\\n    { \\\n    if (p >= endp) return PCRE2_ERROR_NOMEMORY; \\\n    *p++ = *s; \\\n    } \\\n  }\n\n/* Literals that must be escaped: \\ ? * + | . \u00ac $ { } \u00dd \u00a8 ( ) */\n\nstatic const char *pcre2_escaped_literals =\n  STR_BACKSLASH STR_QUESTION_MARK STR_ASTERISK STR_PLUS\n  STR_VERTICAL_LINE STR_DOT STR_CIRCUMFLEX_ACCENT STR_DOLLAR_SIGN\n  STR_LEFT_CURLY_BRACKET STR_RIGHT_CURLY_BRACKET\n  STR_LEFT_SQUARE_BRACKET STR_RIGHT_SQUARE_BRACKET\n  STR_LEFT_PARENTHESIS STR_RIGHT_PARENTHESIS;\n\n/* Recognized escaped metacharacters in POSIX basic patterns. */\n\nstatic const char *posix_meta_escapes =\n  STR_LEFT_PARENTHESIS STR_RIGHT_PARENTHESIS\n  STR_LEFT_CURLY_BRACKET STR_RIGHT_CURLY_BRACKET\n  STR_1 STR_2 STR_3 STR_4 STR_5 STR_6 STR_7 STR_8 STR_9;\n\n\n\n/*************************************************\n*           Convert a POSIX pattern              *\n*************************************************/\n\n/* This function handles both basic and extended POSIX patterns.\n\nArguments:\n  pattype        the pattern type\n  pattern        the pattern\n  plength        length in code units\n  utf            TRUE if UTF\n  use_buffer     where to put the output\n  use_length     length of use_buffer\n  bufflenptr     where to put the used length\n  dummyrun       TRUE if a dummy run\n  ccontext       the convert context\n\nReturns:         0 => success\n                !0 => error code\n*/\n\nstatic int\nconvert_posix(uint32_t pattype, PCRE2_SPTR pattern, PCRE2_SIZE plength,\n  BOOL utf, PCRE2_UCHAR *use_buffer, PCRE2_SIZE use_length,\n  PCRE2_SIZE *bufflenptr, BOOL dummyrun, pcre2_convert_context *ccontext)\n{\nchar *s;\nPCRE2_SPTR posix = pattern;\nPCRE2_UCHAR *p = use_buffer;\nPCRE2_UCHAR *pp = p;\nPCRE2_UCHAR *endp = p + use_length - 1;  /* Allow for trailing zero */\nPCRE2_SIZE convlength = 0;\n\nuint32_t bracount = 0;\nuint32_t posix_state = POSIX_START_REGEX;\nuint32_t lastspecial = 0;\nBOOL extended = (pattype & PCRE2_CONVERT_POSIX_EXTENDED) != 0;\nBOOL nextisliteral = FALSE;\n\n(void)utf;       /* Not used when Unicode not supported */\n(void)ccontext;  /* Not currently used */\n\n/* Initialize default for error offset as end of input. */\n\n*bufflenptr = plength;\nPUTCHARS(STR_STAR_NUL);\n\n/* Now scan the input. */\n\nwhile (plength > 0)\n  {\n  uint32_t c, sc;\n  int clength = 1;\n\n  /* Add in the length of the last item, then, if in the dummy run, pull the\n  pointer back to the start of the (temporary) buffer and then remember the\n  start of the next item. */\n\n  convlength += p - pp;\n  if (dummyrun) p = use_buffer;\n  pp = p;\n\n  /* Pick up the next character */\n\n#ifndef SUPPORT_UNICODE\n  c = *posix;\n#else\n  GETCHARLENTEST(c, posix, clength);\n#endif\n  posix += clength;\n  plength -= clength;\n\n  sc = nextisliteral? 0 : c;\n  nextisliteral = FALSE;\n\n  /* Handle a character within a class. */\n\n  if (posix_state >= POSIX_CLASS_NOT_STARTED)\n    {\n    if (c == CHAR_RIGHT_SQUARE_BRACKET)\n      {\n      PUTCHARS(STR_RIGHT_SQUARE_BRACKET);\n      posix_state = POSIX_NOT_BRACKET;\n      }\n\n    /* Not the end of the class */\n\n    else\n      {\n      switch (posix_state)\n        {\n        case POSIX_CLASS_STARTED:\n        if (c <= 127 && islower(c)) break;  /* Remain in started state */\n        posix_state = POSIX_CLASS_NOT_STARTED;\n        if (c == CHAR_COLON  && plength > 0 &&\n            *posix == CHAR_RIGHT_SQUARE_BRACKET)\n          {\n          PUTCHARS(STR_COLON_RIGHT_SQUARE_BRACKET);\n          plength--;\n          posix++;\n          continue;    /* With next character after :\u00a8 */\n          }\n        /* Fall through */\n\n        case POSIX_CLASS_NOT_STARTED:\n        if (c == CHAR_LEFT_SQUARE_BRACKET)\n          posix_state = POSIX_CLASS_STARTING;\n        break;\n\n        case POSIX_CLASS_STARTING:\n        if (c == CHAR_COLON) posix_state = POSIX_CLASS_STARTED;\n        break;\n        }\n\n      if (c == CHAR_BACKSLASH) PUTCHARS(STR_BACKSLASH);\n      if (p + clength > endp) return PCRE2_ERROR_NOMEMORY;\n      memcpy(p, posix - clength, CU2BYTES(clength));\n      p += clength;\n      }\n    }\n\n  /* Handle a character not within a class. */\n\n  else switch(sc)\n    {\n    case CHAR_LEFT_SQUARE_BRACKET:\n    PUTCHARS(STR_LEFT_SQUARE_BRACKET);\n\n#ifdef NEVER\n    /* We could handle special cases \u00dd\u00dd:<:\u00a8\u00a8 and \u00dd\u00dd:>:\u00a8\u00a8 (which PCRE does\n    support) but they are not part of POSIX 1003.1. */\n\n    if (plength >= 6)\n      {\n      if (posix\u00dd0\u00a8 == CHAR_LEFT_SQUARE_BRACKET &&\n          posix\u00dd1\u00a8 == CHAR_COLON &&\n          (posix\u00dd2\u00a8 == CHAR_LESS_THAN_SIGN ||\n           posix\u00dd2\u00a8 == CHAR_GREATER_THAN_SIGN) &&\n          posix\u00dd3\u00a8 == CHAR_COLON &&\n          posix\u00dd4\u00a8 == CHAR_RIGHT_SQUARE_BRACKET &&\n          posix\u00dd5\u00a8 == CHAR_RIGHT_SQUARE_BRACKET)\n        {\n        if (p + 6 > endp) return PCRE2_ERROR_NOMEMORY;\n        memcpy(p, posix, CU2BYTES(6));\n        p += 6;\n        posix += 6;\n        plength -= 6;\n        continue;  /* With next character */\n        }\n      }\n#endif\n\n    /* Handle start of \"normal\" character classes */\n\n    posix_state = POSIX_CLASS_NOT_STARTED;\n\n    /* Handle \u00ac and \u00a8 as first characters */\n\n    if (plength > 0)\n      {\n      if (*posix == CHAR_CIRCUMFLEX_ACCENT)\n        {\n        posix++;\n        plength--;\n        PUTCHARS(STR_CIRCUMFLEX_ACCENT);\n        }\n      if (plength > 0 && *posix == CHAR_RIGHT_SQUARE_BRACKET)\n        {\n        posix++;\n        plength--;\n        PUTCHARS(STR_RIGHT_SQUARE_BRACKET);\n        }\n      }\n    break;\n\n    case CHAR_BACKSLASH:\n    if (plength == 0) return PCRE2_ERROR_END_BACKSLASH;\n    if (extended) nextisliteral = TRUE; else\n      {\n      if (*posix < 127 && strchr(posix_meta_escapes, *posix) != NULL)\n        {\n        if (isdigit(*posix)) PUTCHARS(STR_BACKSLASH);\n        if (p + 1 > endp) return PCRE2_ERROR_NOMEMORY;\n        lastspecial = *p++ = *posix++;\n        plength--;\n        }\n      else nextisliteral = TRUE;\n      }\n    break;\n\n    case CHAR_RIGHT_PARENTHESIS:\n    if (!extended || bracount == 0) goto ESCAPE_LITERAL;\n    bracount--;\n    goto COPY_SPECIAL;\n\n    case CHAR_LEFT_PARENTHESIS:\n    bracount++;\n    /* Fall through */\n\n    case CHAR_QUESTION_MARK:\n    case CHAR_PLUS:\n    case CHAR_LEFT_CURLY_BRACKET:\n    case CHAR_RIGHT_CURLY_BRACKET:\n    case CHAR_VERTICAL_LINE:\n    if (!extended) goto ESCAPE_LITERAL;\n    /* Fall through */\n\n    case CHAR_DOT:\n    case CHAR_DOLLAR_SIGN:\n    posix_state = POSIX_NOT_BRACKET;\n    COPY_SPECIAL:\n    lastspecial = c;\n    if (p + 1 > endp) return PCRE2_ERROR_NOMEMORY;\n    *p++ = c;\n    break;\n\n    case CHAR_ASTERISK:\n    if (lastspecial != CHAR_ASTERISK)\n      {\n      if (!extended && (posix_state < POSIX_NOT_BRACKET ||\n          lastspecial == CHAR_LEFT_PARENTHESIS))\n        goto ESCAPE_LITERAL;\n      goto COPY_SPECIAL;\n      }\n    break;   /* Ignore second and subsequent asterisks */\n\n    case CHAR_CIRCUMFLEX_ACCENT:\n    if (extended) goto COPY_SPECIAL;\n    if (posix_state == POSIX_START_REGEX ||\n        lastspecial == CHAR_LEFT_PARENTHESIS)\n      {\n      posix_state = POSIX_ANCHORED;\n      goto COPY_SPECIAL;\n      }\n    /* Fall through */\n\n    default:\n    if (c < 128 && strchr(pcre2_escaped_literals, c) != NULL)\n      {\n      ESCAPE_LITERAL:\n      PUTCHARS(STR_BACKSLASH);\n      }\n    lastspecial = 0xff;  /* Indicates nothing special */\n    if (p + clength > endp) return PCRE2_ERROR_NOMEMORY;\n    memcpy(p, posix - clength, CU2BYTES(clength));\n    p += clength;\n    posix_state = POSIX_NOT_BRACKET;\n    break;\n    }\n  }\n\nif (posix_state >= POSIX_CLASS_NOT_STARTED)\n  return PCRE2_ERROR_MISSING_SQUARE_BRACKET;\nconvlength += p - pp;        /* Final segment */\n*bufflenptr = convlength;\n*p++ = 0;\nreturn 0;\n}\n\n\n/*************************************************\n*           Convert a glob pattern               *\n*************************************************/\n\n/* Context for writing the output into a buffer. */\n\ntypedef struct pcre2_output_context {\n  PCRE2_UCHAR *output;                  /* current output position */\n  PCRE2_SPTR output_end;                /* output end */\n  PCRE2_SIZE output_size;               /* size of the output */\n  uint8_t out_str\u00dd8\u00a8;                   /* string copied to the output */\n} pcre2_output_context;\n\n\n/* Write a character into the output.\n\nArguments:\n  out            output context\n  chr            the next character\n*/\n\nstatic void\nconvert_glob_write(pcre2_output_context *out, PCRE2_UCHAR chr)\n{\nout->output_size++;\n\nif (out->output < out->output_end)\n  *out->output++ = chr;\n}\n\n\n/* Write a string into the output.\n\nArguments:\n  out            output context\n  length         length of out->out_str\n*/\n\nstatic void\nconvert_glob_write_str(pcre2_output_context *out, PCRE2_SIZE length)\n{\nuint8_t *out_str = out->out_str;\nPCRE2_UCHAR *output = out->output;\nPCRE2_SPTR output_end = out->output_end;\nPCRE2_SIZE output_size = out->output_size;\n\ndo\n  {\n  output_size++;\n\n  if (output < output_end)\n    *output++ = *out_str++;\n  }\nwhile (--length != 0);\n\nout->output = output;\nout->output_size = output_size;\n}\n\n\n/* Prints the separator into the output.\n\nArguments:\n  out            output context\n  separator      glob separator\n  with_escape    backslash is needed before separator\n*/\n\nstatic void\nconvert_glob_print_separator(pcre2_output_context *out,\n  PCRE2_UCHAR separator, BOOL with_escape)\n{\nif (with_escape)\n  convert_glob_write(out, CHAR_BACKSLASH);\n\nconvert_glob_write(out, separator);\n}\n\n\n/* Prints a wildcard into the output.\n\nArguments:\n  out            output context\n  separator      glob separator\n  with_escape    backslash is needed before separator\n*/\n\nstatic void\nconvert_glob_print_wildcard(pcre2_output_context *out,\n  PCRE2_UCHAR separator, BOOL with_escape)\n{\nout->out_str\u00dd0\u00a8 = CHAR_LEFT_SQUARE_BRACKET;\nout->out_str\u00dd1\u00a8 = CHAR_CIRCUMFLEX_ACCENT;\nconvert_glob_write_str(out, 2);\n\nconvert_glob_print_separator(out, separator, with_escape);\n\nconvert_glob_write(out, CHAR_RIGHT_SQUARE_BRACKET);\n}\n\n\n/* Parse a posix class.\n\nArguments:\n  from           starting point of scanning the range\n  pattern_end    end of pattern\n  out            output context\n\nReturns:  >0 => class index\n          0  => malformed class\n*/\n\nstatic int\nconvert_glob_parse_class(PCRE2_SPTR *from, PCRE2_SPTR pattern_end,\n  pcre2_output_context *out)\n{\nstatic const char *posix_classes = \"alnum:alpha:ascii:blank:cntrl:digit:\"\n  \"graph:lower:print:punct:space:upper:word:xdigit:\";\nPCRE2_SPTR start = *from + 1;\nPCRE2_SPTR pattern = start;\nconst char *class_ptr;\nPCRE2_UCHAR c;\nint class_index;\n\nwhile (TRUE)\n  {\n  if (pattern >= pattern_end) return 0;\n\n  c = *pattern++;\n\n  if (c < CHAR_a || c > CHAR_z) break;\n  }\n\nif (c != CHAR_COLON || pattern >= pattern_end ||\n    *pattern != CHAR_RIGHT_SQUARE_BRACKET)\n  return 0;\n\nclass_ptr = posix_classes;\nclass_index = 1;\n\nwhile (TRUE)\n  {\n  if (*class_ptr == CHAR_NUL) return 0;\n\n  pattern = start;\n\n  while (*pattern == (PCRE2_UCHAR) *class_ptr)\n    {\n    if (*pattern == CHAR_COLON)\n      {\n      pattern += 2;\n      start -= 2;\n\n      do convert_glob_write(out, *start++); while (start < pattern);\n\n      *from = pattern;\n      return class_index;\n      }\n    pattern++;\n    class_ptr++;\n    }\n\n  while (*class_ptr != CHAR_COLON) class_ptr++;\n  class_ptr++;\n  class_index++;\n  }\n}\n\n/* Checks whether the character is in the class.\n\nArguments:\n  class_index    class index\n  c              character\n\nReturns:   !0 => character is found in the class\n            0 => otherwise\n*/\n\nstatic BOOL\nconvert_glob_char_in_class(int class_index, PCRE2_UCHAR c)\n{\nswitch (class_index)\n  {\n  case 1: return isalnum(c);\n  case 2: return isalpha(c);\n  case 3: return 1;\n  case 4: return c == CHAR_HT || c == CHAR_SPACE;\n  case 5: return iscntrl(c);\n  case 6: return isdigit(c);\n  case 7: return isgraph(c);\n  case 8: return islower(c);\n  case 9: return isprint(c);\n  case 10: return ispunct(c);\n  case 11: return isspace(c);\n  case 12: return isupper(c);\n  case 13: return isalnum(c) || c == CHAR_UNDERSCORE;\n  default: return isxdigit(c);\n  }\n}\n\n/* Parse a range of characters.\n\nArguments:\n  from           starting point of scanning the range\n  pattern_end    end of pattern\n  out            output context\n  separator      glob separator\n  with_escape    backslash is needed before separator\n\nReturns:         0 => success\n                !0 => error code\n*/\n\nstatic int\nconvert_glob_parse_range(PCRE2_SPTR *from, PCRE2_SPTR pattern_end,\n  pcre2_output_context *out, BOOL utf, PCRE2_UCHAR separator,\n  BOOL with_escape, PCRE2_UCHAR escape, BOOL no_wildsep)\n{\nBOOL is_negative = FALSE;\nBOOL separator_seen = FALSE;\nBOOL has_prev_c;\nPCRE2_SPTR pattern = *from;\nPCRE2_SPTR char_start = NULL;\nuint32_t c, prev_c;\nint len, class_index;\n\n(void)utf; /* Avoid compiler warning. */\n\nif (pattern >= pattern_end)\n  {\n  *from = pattern;\n  return PCRE2_ERROR_MISSING_SQUARE_BRACKET;\n  }\n\nif (*pattern == CHAR_EXCLAMATION_MARK\n    || *pattern == CHAR_CIRCUMFLEX_ACCENT)\n  {\n  pattern++;\n\n  if (pattern >= pattern_end)\n    {\n    *from = pattern;\n    return PCRE2_ERROR_MISSING_SQUARE_BRACKET;\n    }\n\n  is_negative = TRUE;\n\n  out->out_str\u00dd0\u00a8 = CHAR_LEFT_SQUARE_BRACKET;\n  out->out_str\u00dd1\u00a8 = CHAR_CIRCUMFLEX_ACCENT;\n  len = 2;\n\n  if (!no_wildsep)\n    {\n    if (with_escape)\n      {\n      out->out_str\u00ddlen\u00a8 = CHAR_BACKSLASH;\n      len++;\n      }\n    out->out_str\u00ddlen\u00a8 = (uint8_t) separator;\n    }\n\n  convert_glob_write_str(out, len + 1);\n  }\nelse\n  convert_glob_write(out, CHAR_LEFT_SQUARE_BRACKET);\n\nhas_prev_c = FALSE;\nprev_c = 0;\n\nif (*pattern == CHAR_RIGHT_SQUARE_BRACKET)\n  {\n  out->out_str\u00dd0\u00a8 = CHAR_BACKSLASH;\n  out->out_str\u00dd1\u00a8 = CHAR_RIGHT_SQUARE_BRACKET;\n  convert_glob_write_str(out, 2);\n  has_prev_c = TRUE;\n  prev_c = CHAR_RIGHT_SQUARE_BRACKET;\n  pattern++;\n  }\n\nwhile (pattern < pattern_end)\n  {\n  char_start = pattern;\n  GETCHARINCTEST(c, pattern);\n\n  if (c == CHAR_RIGHT_SQUARE_BRACKET)\n    {\n    convert_glob_write(out, c);\n\n    if (!is_negative && !no_wildsep && separator_seen)\n      {\n      out->out_str\u00dd0\u00a8 = CHAR_LEFT_PARENTHESIS;\n      out->out_str\u00dd1\u00a8 = CHAR_QUESTION_MARK;\n      out->out_str\u00dd2\u00a8 = CHAR_LESS_THAN_SIGN;\n      out->out_str\u00dd3\u00a8 = CHAR_EXCLAMATION_MARK;\n      convert_glob_write_str(out, 4);\n\n      convert_glob_print_separator(out, separator, with_escape);\n      convert_glob_write(out, CHAR_RIGHT_PARENTHESIS);\n      }\n\n    *from = pattern;\n    return 0;\n    }\n\n  if (pattern >= pattern_end) break;\n\n  if (c == CHAR_LEFT_SQUARE_BRACKET && *pattern == CHAR_COLON)\n    {\n    *from = pattern;\n    class_index = convert_glob_parse_class(from, pattern_end, out);\n\n    if (class_index != 0)\n      {\n      pattern = *from;\n\n      has_prev_c = FALSE;\n      prev_c = 0;\n\n      if (!is_negative &&\n          convert_glob_char_in_class (class_index, separator))\n        separator_seen = TRUE;\n      continue;\n      }\n    }\n  else if (c == CHAR_MINUS && has_prev_c &&\n           *pattern != CHAR_RIGHT_SQUARE_BRACKET)\n    {\n    convert_glob_write(out, CHAR_MINUS);\n\n    char_start = pattern;\n    GETCHARINCTEST(c, pattern);\n\n    if (pattern >= pattern_end) break;\n\n    if (escape != 0 && c == escape)\n      {\n      char_start = pattern;\n      GETCHARINCTEST(c, pattern);\n      }\n    else if (c == CHAR_LEFT_SQUARE_BRACKET && *pattern == CHAR_COLON)\n      {\n      *from = pattern;\n      return PCRE2_ERROR_CONVERT_SYNTAX;\n      }\n\n    if (prev_c > c)\n      {\n      *from = pattern;\n      return PCRE2_ERROR_CONVERT_SYNTAX;\n      }\n\n    if (prev_c < separator && separator < c) separator_seen = TRUE;\n\n    has_prev_c = FALSE;\n    prev_c = 0;\n    }\n  else\n    {\n    if (escape != 0 && c == escape)\n      {\n      char_start = pattern;\n      GETCHARINCTEST(c, pattern);\n\n      if (pattern >= pattern_end) break;\n      }\n\n    has_prev_c = TRUE;\n    prev_c = c;\n    }\n\n  if (c == CHAR_LEFT_SQUARE_BRACKET || c == CHAR_RIGHT_SQUARE_BRACKET ||\n      c == CHAR_BACKSLASH || c == CHAR_MINUS)\n    convert_glob_write(out, CHAR_BACKSLASH);\n\n  if (c == separator) separator_seen = TRUE;\n\n  do convert_glob_write(out, *char_start++); while (char_start < pattern);\n  }\n\n*from = pattern;\nreturn PCRE2_ERROR_MISSING_SQUARE_BRACKET;\n}\n\n\n/* Prints a (*COMMIT) into the output.\n\nArguments:\n  out            output context\n*/\n\nstatic void\nconvert_glob_print_commit(pcre2_output_context *out)\n{\nout->out_str\u00dd0\u00a8 = CHAR_LEFT_PARENTHESIS;\nout->out_str\u00dd1\u00a8 = CHAR_ASTERISK;\nout->out_str\u00dd2\u00a8 = CHAR_C;\nout->out_str\u00dd3\u00a8 = CHAR_O;\nout->out_str\u00dd4\u00a8 = CHAR_M;\nout->out_str\u00dd5\u00a8 = CHAR_M;\nout->out_str\u00dd6\u00a8 = CHAR_I;\nout->out_str\u00dd7\u00a8 = CHAR_T;\nconvert_glob_write_str(out, 8);\nconvert_glob_write(out, CHAR_RIGHT_PARENTHESIS);\n}\n\n\n/* Bash glob converter.\n\nArguments:\n  pattype        the pattern type\n  pattern        the pattern\n  plength        length in code units\n  utf            TRUE if UTF\n  use_buffer     where to put the output\n  use_length     length of use_buffer\n  bufflenptr     where to put the used length\n  dummyrun       TRUE if a dummy run\n  ccontext       the convert context\n\nReturns:         0 => success\n                !0 => error code\n*/\n\nstatic int\nconvert_glob(uint32_t options, PCRE2_SPTR pattern, PCRE2_SIZE plength,\n  BOOL utf, PCRE2_UCHAR *use_buffer, PCRE2_SIZE use_length,\n  PCRE2_SIZE *bufflenptr, BOOL dummyrun, pcre2_convert_context *ccontext)\n{\npcre2_output_context out;\nPCRE2_SPTR pattern_start = pattern;\nPCRE2_SPTR pattern_end = pattern + plength;\nPCRE2_UCHAR separator = ccontext->glob_separator;\nPCRE2_UCHAR escape = ccontext->glob_escape;\nPCRE2_UCHAR c;\nBOOL no_wildsep = (options & PCRE2_CONVERT_GLOB_NO_WILD_SEPARATOR) != 0;\nBOOL no_starstar = (options & PCRE2_CONVERT_GLOB_NO_STARSTAR) != 0;\nBOOL in_atomic = FALSE;\nBOOL after_starstar = FALSE;\nBOOL no_slash_z = FALSE;\nBOOL with_escape, is_start, after_separator;\nint result = 0;\n\n(void)utf; /* Avoid compiler warning. */\n\n#ifdef SUPPORT_UNICODE\nif (utf && (separator >= 128 || escape >= 128))\n  {\n  /* Currently only ASCII characters are supported. */\n  *bufflenptr = 0;\n  return PCRE2_ERROR_CONVERT_SYNTAX;\n  }\n#endif\n\nwith_escape = strchr(pcre2_escaped_literals, separator) != NULL;\n\n/* Initialize default for error offset as end of input. */\nout.output = use_buffer;\nout.output_end = use_buffer + use_length;\nout.output_size = 0;\n\nout.out_str\u00dd0\u00a8 = CHAR_LEFT_PARENTHESIS;\nout.out_str\u00dd1\u00a8 = CHAR_QUESTION_MARK;\nout.out_str\u00dd2\u00a8 = CHAR_s;\nout.out_str\u00dd3\u00a8 = CHAR_RIGHT_PARENTHESIS;\nconvert_glob_write_str(&out, 4);\n\nis_start = TRUE;\n\nif (pattern < pattern_end && pattern\u00dd0\u00a8 == CHAR_ASTERISK)\n  {\n  if (no_wildsep)\n    is_start = FALSE;\n  else if (!no_starstar && pattern + 1 < pattern_end &&\n           pattern\u00dd1\u00a8 == CHAR_ASTERISK)\n    is_start = FALSE;\n  }\n\nif (is_start)\n  {\n  out.out_str\u00dd0\u00a8 = CHAR_BACKSLASH;\n  out.out_str\u00dd1\u00a8 = CHAR_A;\n  convert_glob_write_str(&out, 2);\n  }\n\nwhile (pattern < pattern_end)\n  {\n  c = *pattern++;\n\n  if (c == CHAR_ASTERISK)\n    {\n    is_start = pattern == pattern_start + 1;\n\n    if (in_atomic)\n      {\n      convert_glob_write(&out, CHAR_RIGHT_PARENTHESIS);\n      in_atomic = FALSE;\n      }\n\n    if (!no_starstar && pattern < pattern_end && *pattern == CHAR_ASTERISK)\n      {\n      after_separator = is_start || (pattern\u00dd-2\u00a8 == separator);\n\n      do pattern++; while (pattern < pattern_end &&\n                           *pattern == CHAR_ASTERISK);\n\n      if (pattern >= pattern_end)\n        {\n        no_slash_z = TRUE;\n        break;\n        }\n\n      after_starstar = TRUE;\n\n      if (after_separator && escape != 0 && *pattern == escape &&\n          pattern + 1 < pattern_end && pattern\u00dd1\u00a8 == separator)\n        pattern++;\n\n      if (is_start)\n        {\n        if (*pattern != separator) continue;\n\n        out.out_str\u00dd0\u00a8 = CHAR_LEFT_PARENTHESIS;\n        out.out_str\u00dd1\u00a8 = CHAR_QUESTION_MARK;\n        out.out_str\u00dd2\u00a8 = CHAR_COLON;\n        out.out_str\u00dd3\u00a8 = CHAR_BACKSLASH;\n        out.out_str\u00dd4\u00a8 = CHAR_A;\n        out.out_str\u00dd5\u00a8 = CHAR_VERTICAL_LINE;\n        convert_glob_write_str(&out, 6);\n\n        convert_glob_print_separator(&out, separator, with_escape);\n        convert_glob_write(&out, CHAR_RIGHT_PARENTHESIS);\n\n        pattern++;\n        continue;\n        }\n\n      convert_glob_print_commit(&out);\n\n      if (!after_separator || *pattern != separator)\n        {\n        out.out_str\u00dd0\u00a8 = CHAR_DOT;\n        out.out_str\u00dd1\u00a8 = CHAR_ASTERISK;\n        out.out_str\u00dd2\u00a8 = CHAR_QUESTION_MARK;\n        convert_glob_write_str(&out, 3);\n        continue;\n        }\n\n      out.out_str\u00dd0\u00a8 = CHAR_LEFT_PARENTHESIS;\n      out.out_str\u00dd1\u00a8 = CHAR_QUESTION_MARK;\n      out.out_str\u00dd2\u00a8 = CHAR_COLON;\n      out.out_str\u00dd3\u00a8 = CHAR_DOT;\n      out.out_str\u00dd4\u00a8 = CHAR_ASTERISK;\n      out.out_str\u00dd5\u00a8 = CHAR_QUESTION_MARK;\n\n      convert_glob_write_str(&out, 6);\n\n      convert_glob_print_separator(&out, separator, with_escape);\n\n      out.out_str\u00dd0\u00a8 = CHAR_RIGHT_PARENTHESIS;\n      out.out_str\u00dd1\u00a8 = CHAR_QUESTION_MARK;\n      out.out_str\u00dd2\u00a8 = CHAR_QUESTION_MARK;\n      convert_glob_write_str(&out, 3);\n\n      pattern++;\n      continue;\n      }\n\n    if (pattern < pattern_end && *pattern == CHAR_ASTERISK)\n      {\n      do pattern++; while (pattern < pattern_end &&\n                           *pattern == CHAR_ASTERISK);\n      }\n\n    if (no_wildsep)\n      {\n      if (pattern >= pattern_end)\n        {\n        no_slash_z = TRUE;\n        break;\n        }\n\n      /* Start check must be after the end check. */\n      if (is_start) continue;\n      }\n\n    if (!is_start)\n      {\n      if (after_starstar)\n        {\n        out.out_str\u00dd0\u00a8 = CHAR_LEFT_PARENTHESIS;\n        out.out_str\u00dd1\u00a8 = CHAR_QUESTION_MARK;\n        out.out_str\u00dd2\u00a8 = CHAR_GREATER_THAN_SIGN;\n        convert_glob_write_str(&out, 3);\n        in_atomic = TRUE;\n        }\n      else\n        convert_glob_print_commit(&out);\n      }\n\n    if (no_wildsep)\n      convert_glob_write(&out, CHAR_DOT);\n    else\n      convert_glob_print_wildcard(&out, separator, with_escape);\n\n    out.out_str\u00dd0\u00a8 = CHAR_ASTERISK;\n    out.out_str\u00dd1\u00a8 = CHAR_QUESTION_MARK;\n    if (pattern >= pattern_end)\n      out.out_str\u00dd1\u00a8 = CHAR_PLUS;\n    convert_glob_write_str(&out, 2);\n    continue;\n    }\n\n  if (c == CHAR_QUESTION_MARK)\n    {\n    if (no_wildsep)\n      convert_glob_write(&out, CHAR_DOT);\n    else\n      convert_glob_print_wildcard(&out, separator, with_escape);\n    continue;\n    }\n\n  if (c == CHAR_LEFT_SQUARE_BRACKET)\n    {\n    result = convert_glob_parse_range(&pattern, pattern_end,\n      &out, utf, separator, with_escape, escape, no_wildsep);\n    if (result != 0) break;\n    continue;\n    }\n\n  if (escape != 0 && c == escape)\n    {\n    if (pattern >= pattern_end)\n      {\n      result = PCRE2_ERROR_CONVERT_SYNTAX;\n      break;\n      }\n    c = *pattern++;\n    }\n\n  if (c < 128 && strchr(pcre2_escaped_literals, c) != NULL)\n    convert_glob_write(&out, CHAR_BACKSLASH);\n\n  convert_glob_write(&out, c);\n  }\n\nif (result == 0)\n  {\n  if (!no_slash_z)\n    {\n    out.out_str\u00dd0\u00a8 = CHAR_BACKSLASH;\n    out.out_str\u00dd1\u00a8 = CHAR_z;\n    convert_glob_write_str(&out, 2);\n    }\n\n  if (in_atomic)\n    convert_glob_write(&out, CHAR_RIGHT_PARENTHESIS);\n\n  convert_glob_write(&out, CHAR_NUL);\n\n  if (!dummyrun && out.output_size != (PCRE2_SIZE) (out.output - use_buffer))\n    result = PCRE2_ERROR_NOMEMORY;\n  }\n\nif (result != 0)\n  {\n  *bufflenptr = pattern - pattern_start;\n  return result;\n  }\n\n*bufflenptr = out.output_size - 1;\nreturn 0;\n}\n\n\n/*************************************************\n*                Convert pattern                 *\n*************************************************/\n\n/* This is the external-facing function for converting other forms of pattern\ninto PCRE2 regular expression patterns. On error, the bufflenptr argument is\nused to return an offset in the original pattern.\n\nArguments:\n  pattern     the input pattern\n  plength     length of input, or PCRE2_ZERO_TERMINATED\n  options     options bits\n  buffptr     pointer to pointer to output buffer\n  bufflenptr  pointer to length of output buffer\n  ccontext    convert context or NULL\n\nReturns:      0 for success, else an error code (+ve or -ve)\n*/\n\nPCRE2_EXP_DEFN int PCRE2_CALL_CONVENTION\npcre2_pattern_convert(PCRE2_SPTR pattern, PCRE2_SIZE plength, uint32_t options,\n  PCRE2_UCHAR **buffptr, PCRE2_SIZE *bufflenptr,\n  pcre2_convert_context *ccontext)\n{\nint i, rc;\nPCRE2_UCHAR dummy_buffer\u00ddDUMMY_BUFFER_SIZE\u00a8;\nPCRE2_UCHAR *use_buffer = dummy_buffer;\nPCRE2_SIZE use_length = DUMMY_BUFFER_SIZE;\nBOOL utf = (options & PCRE2_CONVERT_UTF) != 0;\nuint32_t pattype = options & TYPE_OPTIONS;\n\nif (pattern == NULL || bufflenptr == NULL) return PCRE2_ERROR_NULL;\n\nif ((options & ~ALL_OPTIONS) != 0 ||        /* Undefined bit set */\n    (pattype & (~pattype+1)) != pattype ||  /* More than one type set */\n    pattype == 0)                           /* No type set */\n  {\n  *bufflenptr = 0;                          /* Error offset */\n  return PCRE2_ERROR_BADOPTION;\n  }\n\nif (plength == PCRE2_ZERO_TERMINATED) plength = PRIV(strlen)(pattern);\nif (ccontext == NULL) ccontext =\n  (pcre2_convert_context *)(&PRIV(default_convert_context));\n\n/* Check UTF if required. */\n\n#ifndef SUPPORT_UNICODE\nif (utf)\n  {\n  *bufflenptr = 0;  /* Error offset */\n  return PCRE2_ERROR_UNICODE_NOT_SUPPORTED;\n  }\n#else\nif (utf && (options & PCRE2_CONVERT_NO_UTF_CHECK) == 0)\n  {\n  PCRE2_SIZE erroroffset;\n  rc = PRIV(valid_utf)(pattern, plength, &erroroffset);\n  if (rc != 0)\n    {\n    *bufflenptr = erroroffset;\n    return rc;\n    }\n  }\n#endif\n\n/* If buffptr is not NULL, and what it points to is not NULL, we are being\nprovided with a buffer and a length, so set them as the buffer to use. */\n\nif (buffptr != NULL && *buffptr != NULL)\n  {\n  use_buffer = *buffptr;\n  use_length = *bufflenptr;\n  }\n\n/* Call an individual converter, either just once (if a buffer was provided or\njust the length is needed), or twice (if a memory allocation is required). */\n\nfor (i = 0; i < 2; i++)\n  {\n  PCRE2_UCHAR *allocated;\n  BOOL dummyrun = buffptr == NULL || *buffptr == NULL;\n\n  switch(pattype)\n    {\n    case PCRE2_CONVERT_GLOB:\n    rc = convert_glob(options & ~PCRE2_CONVERT_GLOB, pattern, plength, utf,\n      use_buffer, use_length, bufflenptr, dummyrun, ccontext);\n    break;\n\n    case PCRE2_CONVERT_POSIX_BASIC:\n    case PCRE2_CONVERT_POSIX_EXTENDED:\n    rc = convert_posix(pattype, pattern, plength, utf, use_buffer, use_length,\n      bufflenptr, dummyrun, ccontext);\n    break;\n\n    default:\n    *bufflenptr = 0;  /* Error offset */\n    return PCRE2_ERROR_INTERNAL;\n    }\n\n  if (rc != 0 ||           /* Error */\n      buffptr == NULL ||   /* Just the length is required */\n      *buffptr != NULL)    /* Buffer was provided or allocated */\n    return rc;\n\n  /* Allocate memory for the buffer, with hidden space for an allocator at\n  the start. The next time round the loop runs the conversion for real. */\n\n  allocated = PRIV(memctl_malloc)(sizeof(pcre2_memctl) +\n    (*bufflenptr + 1)*PCRE2_CODE_UNIT_WIDTH, (pcre2_memctl *)ccontext);\n  if (allocated == NULL) return PCRE2_ERROR_NOMEMORY;\n  *buffptr = (PCRE2_UCHAR *)(((char *)allocated) + sizeof(pcre2_memctl));\n\n  use_buffer = *buffptr;\n  use_length = *bufflenptr + 1;\n  }\n\n/* Control should never get here. */\n\nreturn PCRE2_ERROR_INTERNAL;\n}\n\n\n/*************************************************\n*            Free converted pattern              *\n*************************************************/\n\n/* This frees a converted pattern that was put in newly-allocated memory.\n\nArgument:   the converted pattern\nReturns:    nothing\n*/\n\nPCRE2_EXP_DEFN void PCRE2_CALL_CONVENTION\npcre2_converted_pattern_free(PCRE2_UCHAR *converted)\n{\nif (converted != NULL)\n  {\n  pcre2_memctl *memctl =\n    (pcre2_memctl *)((char *)converted - sizeof(pcre2_memctl));\n  memctl->free(memctl, memctl->memory_data);\n  }\n}\n\n/* End of pcre2_convert.c */\n/*autoconv-0001 C:\\projects\\pcre2-10.35\\src\\pcre2_convert.c converted to CONVERT2*/\n/*autoconv-0011 CONVERT2 line: 43 config.h replaced by CONFIG.h*/\n/*autoconv-0011 CONVERT2 line: 46 pcre2_internal.h replaced by INTERNA2.h*/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DFAMATC2": {"ttr": 5381, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "\n/*************************************************\n*      Perl-Compatible Regular Expressions       *\n*************************************************/\n\n/* PCRE is a library of functions to support regular expressions whose syntax\nand semantics are as close as possible to those of the Perl 5 language.\n\n                       Written by Philip Hazel\n     Original API code Copyright (c) 1997-2012 University of Cambridge\n          New API code Copyright (c) 2016-2020 University of Cambridge\n\n-----------------------------------------------------------------------------\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n\n    * Redistributions of source code must retain the above copyright notice,\n      this list of conditions and the following disclaimer.\n\n    * Redistributions in binary form must reproduce the above copyright\n      notice, this list of conditions and the following disclaimer in the\n      documentation and/or other materials provided with the distribution.\n\n    * Neither the name of the University of Cambridge nor the names of its\n      contributors may be used to endorse or promote products derived from\n      this software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\nAND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\nIMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\nARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\nLIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\nCONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\nSUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\nINTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\nCONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\nARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\nPOSSIBILITY OF SUCH DAMAGE.\n-----------------------------------------------------------------------------\n*/\n\n\n/* This module contains the external function pcre2_dfa_match(), which is an\nalternative matching function that uses a sort of DFA algorithm (not a true\nFSM). This is NOT Perl-compatible, but it has advantages in certain\napplications. */\n\n\n/* NOTE ABOUT PERFORMANCE: A user of this function sent some code that improved\nthe performance of his patterns greatly. I could not use it as it stood, as it\nwas not thread safe, and made assumptions about pattern sizes. Also, it caused\ntest 7 to loop, and test 9 to crash with a segfault.\n\nThe issue is the check for duplicate states, which is done by a simple linear\nsearch up the state list. (Grep for \"duplicate\" below to find the code.) For\nmany patterns, there will never be many states active at one time, so a simple\nlinear search is fine. In patterns that have many active states, it might be a\nbottleneck. The suggested code used an indexing scheme to remember which states\nhad previously been used for each character, and avoided the linear search when\nit knew there was no chance of a duplicate. This was implemented when adding\nstates to the state lists.\n\nI wrote some thread-safe, not-limited code to try something similar at the time\nof checking for duplicates (instead of when adding states), using index vectors\non the stack. It did give a 13% improvement with one specially constructed\npattern for certain subject strings, but on other strings and on many of the\nsimpler patterns in the test suite it did worse. The major problem, I think,\nwas the extra time to initialize the index. This had to be done for each call\nof internal_dfa_match(). (The supplied patch used a static vector, initialized\nonly once - I suspect this was the cause of the problems with the tests.)\n\nOverall, I concluded that the gains in some cases did not outweigh the losses\nin others, so I abandoned this code. */\n\n\n#ifdef HAVE_CONFIG_H\n#include \"CONFIG.h\"\n#endif\n\n#define NLBLOCK mb             /* Block containing newline information */\n#define PSSTART start_subject  /* Field containing processed string start */\n#define PSEND   end_subject    /* Field containing processed string end */\n\n#include \"INTERNA2.h\"\n\n#define PUBLIC_DFA_MATCH_OPTIONS \\\n  (PCRE2_ANCHORED|PCRE2_ENDANCHORED|PCRE2_NOTBOL|PCRE2_NOTEOL|PCRE2_NOTEMPTY| \\\n   PCRE2_NOTEMPTY_ATSTART|PCRE2_NO_UTF_CHECK|PCRE2_PARTIAL_HARD| \\\n   PCRE2_PARTIAL_SOFT|PCRE2_DFA_SHORTEST|PCRE2_DFA_RESTART| \\\n   PCRE2_COPY_MATCHED_SUBJECT)\n\n\n/*************************************************\n*      Code parameters and static tables         *\n*************************************************/\n\n/* These are offsets that are used to turn the OP_TYPESTAR and friends opcodes\ninto others, under special conditions. A gap of 20 between the blocks should be\nenough. The resulting opcodes don't have to be less than 256 because they are\nnever stored, so we push them well clear of the normal opcodes. */\n\n#define OP_PROP_EXTRA       300\n#define OP_EXTUNI_EXTRA     320\n#define OP_ANYNL_EXTRA      340\n#define OP_HSPACE_EXTRA     360\n#define OP_VSPACE_EXTRA     380\n\n\n/* This table identifies those opcodes that are followed immediately by a\ncharacter that is to be tested in some way. This makes it possible to\ncentralize the loading of these characters. In the case of Type * etc, the\n\"character\" is the opcode for \\D, \\d, \\S, \\s, \\W, or \\w, which will always be a\nsmall value. Non-zero values in the table are the offsets from the opcode where\nthe character is to be found. ***NOTE*** If the start of this table is\nmodified, the three tables that follow must also be modified. */\n\nstatic const uint8_t coptable\u00dd\u00a8 = {\n  0,                             /* End                                    */\n  0, 0, 0, 0, 0,                 /* \\A, \\G, \\K, \\B, \\b                     */\n  0, 0, 0, 0, 0, 0,              /* \\D, \\d, \\S, \\s, \\W, \\w                 */\n  0, 0, 0,                       /* Any, AllAny, Anybyte                   */\n  0, 0,                          /* \\P, \\p                                 */\n  0, 0, 0, 0, 0,                 /* \\R, \\H, \\h, \\V, \\v                     */\n  0,                             /* \\X                                     */\n  0, 0, 0, 0, 0, 0,              /* \\Z, \\z, $, $M, \u00ac, \u00acM                   */\n  1,                             /* Char                                   */\n  1,                             /* Chari                                  */\n  1,                             /* not                                    */\n  1,                             /* noti                                   */\n  /* Positive single-char repeats                                          */\n  1, 1, 1, 1, 1, 1,              /* *, *?, +, +?, ?, ??                    */\n  1+IMM2_SIZE, 1+IMM2_SIZE,      /* upto, minupto                          */\n  1+IMM2_SIZE,                   /* exact                                  */\n  1, 1, 1, 1+IMM2_SIZE,          /* *+, ++, ?+, upto+                      */\n  1, 1, 1, 1, 1, 1,              /* *I, *?I, +I, +?I, ?I, ??I              */\n  1+IMM2_SIZE, 1+IMM2_SIZE,      /* upto I, minupto I                      */\n  1+IMM2_SIZE,                   /* exact I                                */\n  1, 1, 1, 1+IMM2_SIZE,          /* *+I, ++I, ?+I, upto+I                  */\n  /* Negative single-char repeats - only for chars < 256                   */\n  1, 1, 1, 1, 1, 1,              /* NOT *, *?, +, +?, ?, ??                */\n  1+IMM2_SIZE, 1+IMM2_SIZE,      /* NOT upto, minupto                      */\n  1+IMM2_SIZE,                   /* NOT exact                              */\n  1, 1, 1, 1+IMM2_SIZE,          /* NOT *+, ++, ?+, upto+                  */\n  1, 1, 1, 1, 1, 1,              /* NOT *I, *?I, +I, +?I, ?I, ??I          */\n  1+IMM2_SIZE, 1+IMM2_SIZE,      /* NOT upto I, minupto I                  */\n  1+IMM2_SIZE,                   /* NOT exact I                            */\n  1, 1, 1, 1+IMM2_SIZE,          /* NOT *+I, ++I, ?+I, upto+I              */\n  /* Positive type repeats                                                 */\n  1, 1, 1, 1, 1, 1,              /* Type *, *?, +, +?, ?, ??               */\n  1+IMM2_SIZE, 1+IMM2_SIZE,      /* Type upto, minupto                     */\n  1+IMM2_SIZE,                   /* Type exact                             */\n  1, 1, 1, 1+IMM2_SIZE,          /* Type *+, ++, ?+, upto+                 */\n  /* Character class & ref repeats                                         */\n  0, 0, 0, 0, 0, 0,              /* *, *?, +, +?, ?, ??                    */\n  0, 0,                          /* CRRANGE, CRMINRANGE                    */\n  0, 0, 0, 0,                    /* Possessive *+, ++, ?+, CRPOSRANGE      */\n  0,                             /* CLASS                                  */\n  0,                             /* NCLASS                                 */\n  0,                             /* XCLASS - variable length               */\n  0,                             /* REF                                    */\n  0,                             /* REFI                                   */\n  0,                             /* DNREF                                  */\n  0,                             /* DNREFI                                 */\n  0,                             /* RECURSE                                */\n  0,                             /* CALLOUT                                */\n  0,                             /* CALLOUT_STR                            */\n  0,                             /* Alt                                    */\n  0,                             /* Ket                                    */\n  0,                             /* KetRmax                                */\n  0,                             /* KetRmin                                */\n  0,                             /* KetRpos                                */\n  0,                             /* Reverse                                */\n  0,                             /* Assert                                 */\n  0,                             /* Assert not                             */\n  0,                             /* Assert behind                          */\n  0,                             /* Assert behind not                      */\n  0,                             /* NA assert                              */\n  0,                             /* NA assert behind                       */\n  0,                             /* ONCE                                   */\n  0,                             /* SCRIPT_RUN                             */\n  0, 0, 0, 0, 0,                 /* BRA, BRAPOS, CBRA, CBRAPOS, COND       */\n  0, 0, 0, 0, 0,                 /* SBRA, SBRAPOS, SCBRA, SCBRAPOS, SCOND  */\n  0, 0,                          /* CREF, DNCREF                           */\n  0, 0,                          /* RREF, DNRREF                           */\n  0, 0,                          /* FALSE, TRUE                            */\n  0, 0, 0,                       /* BRAZERO, BRAMINZERO, BRAPOSZERO        */\n  0, 0, 0,                       /* MARK, PRUNE, PRUNE_ARG                 */\n  0, 0, 0, 0,                    /* SKIP, SKIP_ARG, THEN, THEN_ARG         */\n  0, 0,                          /* COMMIT, COMMIT_ARG                     */\n  0, 0, 0,                       /* FAIL, ACCEPT, ASSERT_ACCEPT            */\n  0, 0, 0                        /* CLOSE, SKIPZERO, DEFINE                */\n};\n\n/* This table identifies those opcodes that inspect a character. It is used to\nremember the fact that a character could have been inspected when the end of\nthe subject is reached. ***NOTE*** If the start of this table is modified, the\ntwo tables that follow must also be modified. */\n\nstatic const uint8_t poptable\u00dd\u00a8 = {\n  0,                             /* End                                    */\n  0, 0, 0, 1, 1,                 /* \\A, \\G, \\K, \\B, \\b                     */\n  1, 1, 1, 1, 1, 1,              /* \\D, \\d, \\S, \\s, \\W, \\w                 */\n  1, 1, 1,                       /* Any, AllAny, Anybyte                   */\n  1, 1,                          /* \\P, \\p                                 */\n  1, 1, 1, 1, 1,                 /* \\R, \\H, \\h, \\V, \\v                     */\n  1,                             /* \\X                                     */\n  0, 0, 0, 0, 0, 0,              /* \\Z, \\z, $, $M, \u00ac, \u00acM                   */\n  1,                             /* Char                                   */\n  1,                             /* Chari                                  */\n  1,                             /* not                                    */\n  1,                             /* noti                                   */\n  /* Positive single-char repeats                                          */\n  1, 1, 1, 1, 1, 1,              /* *, *?, +, +?, ?, ??                    */\n  1, 1, 1,                       /* upto, minupto, exact                   */\n  1, 1, 1, 1,                    /* *+, ++, ?+, upto+                      */\n  1, 1, 1, 1, 1, 1,              /* *I, *?I, +I, +?I, ?I, ??I              */\n  1, 1, 1,                       /* upto I, minupto I, exact I             */\n  1, 1, 1, 1,                    /* *+I, ++I, ?+I, upto+I                  */\n  /* Negative single-char repeats - only for chars < 256                   */\n  1, 1, 1, 1, 1, 1,              /* NOT *, *?, +, +?, ?, ??                */\n  1, 1, 1,                       /* NOT upto, minupto, exact               */\n  1, 1, 1, 1,                    /* NOT *+, ++, ?+, upto+                  */\n  1, 1, 1, 1, 1, 1,              /* NOT *I, *?I, +I, +?I, ?I, ??I          */\n  1, 1, 1,                       /* NOT upto I, minupto I, exact I         */\n  1, 1, 1, 1,                    /* NOT *+I, ++I, ?+I, upto+I              */\n  /* Positive type repeats                                                 */\n  1, 1, 1, 1, 1, 1,              /* Type *, *?, +, +?, ?, ??               */\n  1, 1, 1,                       /* Type upto, minupto, exact              */\n  1, 1, 1, 1,                    /* Type *+, ++, ?+, upto+                 */\n  /* Character class & ref repeats                                         */\n  1, 1, 1, 1, 1, 1,              /* *, *?, +, +?, ?, ??                    */\n  1, 1,                          /* CRRANGE, CRMINRANGE                    */\n  1, 1, 1, 1,                    /* Possessive *+, ++, ?+, CRPOSRANGE      */\n  1,                             /* CLASS                                  */\n  1,                             /* NCLASS                                 */\n  1,                             /* XCLASS - variable length               */\n  0,                             /* REF                                    */\n  0,                             /* REFI                                   */\n  0,                             /* DNREF                                  */\n  0,                             /* DNREFI                                 */\n  0,                             /* RECURSE                                */\n  0,                             /* CALLOUT                                */\n  0,                             /* CALLOUT_STR                            */\n  0,                             /* Alt                                    */\n  0,                             /* Ket                                    */\n  0,                             /* KetRmax                                */\n  0,                             /* KetRmin                                */\n  0,                             /* KetRpos                                */\n  0,                             /* Reverse                                */\n  0,                             /* Assert                                 */\n  0,                             /* Assert not                             */\n  0,                             /* Assert behind                          */\n  0,                             /* Assert behind not                      */\n  0,                             /* NA assert                              */\n  0,                             /* NA assert behind                       */\n  0,                             /* ONCE                                   */\n  0,                             /* SCRIPT_RUN                             */\n  0, 0, 0, 0, 0,                 /* BRA, BRAPOS, CBRA, CBRAPOS, COND       */\n  0, 0, 0, 0, 0,                 /* SBRA, SBRAPOS, SCBRA, SCBRAPOS, SCOND  */\n  0, 0,                          /* CREF, DNCREF                           */\n  0, 0,                          /* RREF, DNRREF                           */\n  0, 0,                          /* FALSE, TRUE                            */\n  0, 0, 0,                       /* BRAZERO, BRAMINZERO, BRAPOSZERO        */\n  0, 0, 0,                       /* MARK, PRUNE, PRUNE_ARG                 */\n  0, 0, 0, 0,                    /* SKIP, SKIP_ARG, THEN, THEN_ARG         */\n  0, 0,                          /* COMMIT, COMMIT_ARG                     */\n  0, 0, 0,                       /* FAIL, ACCEPT, ASSERT_ACCEPT            */\n  0, 0, 0                        /* CLOSE, SKIPZERO, DEFINE                */\n};\n\n/* These 2 tables allow for compact code for testing for \\D, \\d, \\S, \\s, \\W,\nand \\w */\n\nstatic const uint8_t toptable1\u00dd\u00a8 = {\n  0, 0, 0, 0, 0, 0,\n  ctype_digit, ctype_digit,\n  ctype_space, ctype_space,\n  ctype_word,  ctype_word,\n  0, 0                            /* OP_ANY, OP_ALLANY */\n};\n\nstatic const uint8_t toptable2\u00dd\u00a8 = {\n  0, 0, 0, 0, 0, 0,\n  ctype_digit, 0,\n  ctype_space, 0,\n  ctype_word,  0,\n  1, 1                            /* OP_ANY, OP_ALLANY */\n};\n\n\n/* Structure for holding data about a particular state, which is in effect the\ncurrent data for an active path through the match tree. It must consist\nentirely of ints because the working vector we are passed, and which we put\nthese structures in, is a vector of ints. */\n\ntypedef struct stateblock {\n  int offset;                     /* Offset to opcode (-ve has meaning) */\n  int count;                      /* Count for repeats */\n  int data;                       /* Some use extra data */\n} stateblock;\n\n#define INTS_PER_STATEBLOCK  (int)(sizeof(stateblock)/sizeof(int))\n\n\n/* Before version 10.32 the recursive calls of internal_dfa_match() were passed\nlocal working space and output vectors that were created on the stack. This has\ncaused issues for some patterns, especially in small-stack environments such as\nWindows. A new scheme is now in use which sets up a vector on the stack, but if\nthis is too small, heap memory is used, up to the heap_limit. The main\nparameters are all numbers of ints because the workspace is a vector of ints.\n\nThe size of the starting stack vector, DFA_START_RWS_SIZE, is in bytes, and is\ndefined in pcre2_internal.h so as to be available to pcre2test when it is\nfinding the minimum heap requirement for a match. */\n\n#define OVEC_UNIT  (sizeof(PCRE2_SIZE)/sizeof(int))\n\n#define RWS_BASE_SIZE   (DFA_START_RWS_SIZE/sizeof(int))  /* Stack vector */\n#define RWS_RSIZE       1000                    /* Work size for recursion */\n#define RWS_OVEC_RSIZE  (1000*OVEC_UNIT)        /* Ovector for recursion */\n#define RWS_OVEC_OSIZE  (2*OVEC_UNIT)           /* Ovector in other cases */\n\n/* This structure is at the start of each workspace block. */\n\ntypedef struct RWS_anchor {\n  struct RWS_anchor *next;\n  uint32_t size;  /* Number of ints */\n  uint32_t free;  /* Number of ints */\n} RWS_anchor;\n\n#define RWS_ANCHOR_SIZE (sizeof(RWS_anchor)/sizeof(int))\n\n\n\n/*************************************************\n*               Process a callout                *\n*************************************************/\n\n/* This function is called to perform a callout.\n\nArguments:\n  code              current code pointer\n  offsets           points to current capture offsets\n  current_subject   start of current subject match\n  ptr               current position in subject\n  mb                the match block\n  extracode         extra code offset when called from condition\n  lengthptr         where to return the callout length\n\nReturns:            the return from the callout\n*/\n\nstatic int\ndo_callout(PCRE2_SPTR code, PCRE2_SIZE *offsets, PCRE2_SPTR current_subject,\n  PCRE2_SPTR ptr, dfa_match_block *mb, PCRE2_SIZE extracode,\n  PCRE2_SIZE *lengthptr)\n{\npcre2_callout_block *cb = mb->cb;\n\n*lengthptr = (code\u00ddextracode\u00a8 == OP_CALLOUT)?\n  (PCRE2_SIZE)PRIV(OP_lengths)\u00ddOP_CALLOUT\u00a8 :\n  (PCRE2_SIZE)GET(code, 1 + 2*LINK_SIZE + extracode);\n\nif (mb->callout == NULL) return 0;    /* No callout provided */\n\n/* Fixed fields in the callout block are set once and for all at the start of\nmatching. */\n\ncb->offset_vector    = offsets;\ncb->start_match      = (PCRE2_SIZE)(current_subject - mb->start_subject);\ncb->current_position = (PCRE2_SIZE)(ptr - mb->start_subject);\ncb->pattern_position = GET(code, 1 + extracode);\ncb->next_item_length = GET(code, 1 + LINK_SIZE + extracode);\n\nif (code\u00ddextracode\u00a8 == OP_CALLOUT)\n  {\n  cb->callout_number = code\u00dd1 + 2*LINK_SIZE + extracode\u00a8;\n  cb->callout_string_offset = 0;\n  cb->callout_string = NULL;\n  cb->callout_string_length = 0;\n  }\nelse\n  {\n  cb->callout_number = 0;\n  cb->callout_string_offset = GET(code, 1 + 3*LINK_SIZE + extracode);\n  cb->callout_string = code + (1 + 4*LINK_SIZE + extracode) + 1;\n  cb->callout_string_length = *lengthptr - (1 + 4*LINK_SIZE) - 2;\n  }\n\nreturn (mb->callout)(cb, mb->callout_data);\n}\n\n\n\n/*************************************************\n*         Expand local workspace memory          *\n*************************************************/\n\n/* This function is called when internal_dfa_match() is about to be called\nrecursively and there is insufficient working space left in the current\nworkspace block. If there's an existing next block, use it; otherwise get a new\nblock unless the heap limit is reached.\n\nArguments:\n  rwsptr     pointer to block pointer (updated)\n  ovecsize   space needed for an ovector\n  mb         the match block\n\nReturns:     0 rwsptr has been updated\n            !0 an error code\n*/\n\nstatic int\nmore_workspace(RWS_anchor **rwsptr, unsigned int ovecsize, dfa_match_block *mb)\n{\nRWS_anchor *rws = *rwsptr;\nRWS_anchor *new;\n\nif (rws->next != NULL)\n  {\n  new = rws->next;\n  }\n\n/* Sizes in the RWS_anchor blocks are in units of sizeof(int), but\nmb->heap_limit and mb->heap_used are in kibibytes. Play carefully, to avoid\noverflow. */\n\nelse\n  {\n  uint32_t newsize = (rws->size >= UINT32_MAX/2)? UINT32_MAX/2 : rws->size * 2;\n  uint32_t newsizeK = newsize/(1024/sizeof(int));\n\n  if (newsizeK + mb->heap_used > mb->heap_limit)\n    newsizeK = (uint32_t)(mb->heap_limit - mb->heap_used);\n  newsize = newsizeK*(1024/sizeof(int));\n\n  if (newsize < RWS_RSIZE + ovecsize + RWS_ANCHOR_SIZE)\n    return PCRE2_ERROR_HEAPLIMIT;\n  new = mb->memctl.malloc(newsize*sizeof(int), mb->memctl.memory_data);\n  if (new == NULL) return PCRE2_ERROR_NOMEMORY;\n  mb->heap_used += newsizeK;\n  new->next = NULL;\n  new->size = newsize;\n  rws->next = new;\n  }\n\nnew->free = new->size - RWS_ANCHOR_SIZE;\n*rwsptr = new;\nreturn 0;\n}\n\n\n\n/*************************************************\n*     Match a Regular Expression - DFA engine    *\n*************************************************/\n\n/* This internal function applies a compiled pattern to a subject string,\nstarting at a given point, using a DFA engine. This function is called from the\nexternal one, possibly multiple times if the pattern is not anchored. The\nfunction calls itself recursively for some kinds of subpattern.\n\nArguments:\n  mb                the match_data block with fixed information\n  this_start_code   the opening bracket of this subexpression's code\n  current_subject   where we currently are in the subject string\n  start_offset      start offset in the subject string\n  offsets           vector to contain the matching string offsets\n  offsetcount       size of same\n  workspace         vector of workspace\n  wscount           size of same\n  rlevel            function call recursion level\n\nReturns:            > 0 => number of match offset pairs placed in offsets\n                    = 0 => offsets overflowed; longest matches are present\n                     -1 => failed to match\n                   < -1 => some kind of unexpected problem\n\nThe following macros are used for adding states to the two state vectors (one\nfor the current character, one for the following character). */\n\n#define ADD_ACTIVE(x,y) \\\n  if (active_count++ < wscount) \\\n    { \\\n    next_active_state->offset = (x); \\\n    next_active_state->count  = (y); \\\n    next_active_state++; \\\n    } \\\n  else return PCRE2_ERROR_DFA_WSSIZE\n\n#define ADD_ACTIVE_DATA(x,y,z) \\\n  if (active_count++ < wscount) \\\n    { \\\n    next_active_state->offset = (x); \\\n    next_active_state->count  = (y); \\\n    next_active_state->data   = (z); \\\n    next_active_state++; \\\n    } \\\n  else return PCRE2_ERROR_DFA_WSSIZE\n\n#define ADD_NEW(x,y) \\\n  if (new_count++ < wscount) \\\n    { \\\n    next_new_state->offset = (x); \\\n    next_new_state->count  = (y); \\\n    next_new_state++; \\\n    } \\\n  else return PCRE2_ERROR_DFA_WSSIZE\n\n#define ADD_NEW_DATA(x,y,z) \\\n  if (new_count++ < wscount) \\\n    { \\\n    next_new_state->offset = (x); \\\n    next_new_state->count  = (y); \\\n    next_new_state->data   = (z); \\\n    next_new_state++; \\\n    } \\\n  else return PCRE2_ERROR_DFA_WSSIZE\n\n/* And now, here is the code */\n\nstatic int\ninternal_dfa_match(\n  dfa_match_block *mb,\n  PCRE2_SPTR this_start_code,\n  PCRE2_SPTR current_subject,\n  PCRE2_SIZE start_offset,\n  PCRE2_SIZE *offsets,\n  uint32_t offsetcount,\n  int *workspace,\n  int wscount,\n  uint32_t rlevel,\n  int *RWS)\n{\nstateblock *active_states, *new_states, *temp_states;\nstateblock *next_active_state, *next_new_state;\nconst uint8_t *ctypes, *lcc, *fcc;\nPCRE2_SPTR ptr;\nPCRE2_SPTR end_code;\ndfa_recursion_info new_recursive;\nint active_count, new_count, match_count;\n\n/* Some fields in the mb block are frequently referenced, so we load them into\nindependent variables in the hope that this will perform better. */\n\nPCRE2_SPTR start_subject = mb->start_subject;\nPCRE2_SPTR end_subject = mb->end_subject;\nPCRE2_SPTR start_code = mb->start_code;\n\n#ifdef SUPPORT_UNICODE\nBOOL utf = (mb->poptions & PCRE2_UTF) != 0;\nBOOL utf_or_ucp = utf || (mb->poptions & PCRE2_UCP) != 0;\n#else\nBOOL utf = FALSE;\n#endif\n\nBOOL reset_could_continue = FALSE;\n\nif (mb->match_call_count++ >= mb->match_limit) return PCRE2_ERROR_MATCHLIMIT;\nif (rlevel++ > mb->match_limit_depth) return PCRE2_ERROR_DEPTHLIMIT;\noffsetcount &= (uint32_t)(-2);  /* Round down */\n\nwscount -= 2;\nwscount = (wscount - (wscount % (INTS_PER_STATEBLOCK * 2))) /\n          (2 * INTS_PER_STATEBLOCK);\n\nctypes = mb->tables + ctypes_offset;\nlcc = mb->tables + lcc_offset;\nfcc = mb->tables + fcc_offset;\n\nmatch_count = PCRE2_ERROR_NOMATCH;   /* A negative number */\n\nactive_states = (stateblock *)(workspace + 2);\nnext_new_state = new_states = active_states + wscount;\nnew_count = 0;\n\n/* The first thing in any (sub) pattern is a bracket of some sort. Push all\nthe alternative states onto the list, and find out where the end is. This\nmakes is possible to use this function recursively, when we want to stop at a\nmatching internal ket rather than at the end.\n\nIf we are dealing with a backward assertion we have to find out the maximum\namount to move back, and set up each alternative appropriately. */\n\nif (*this_start_code == OP_ASSERTBACK || *this_start_code == OP_ASSERTBACK_NOT)\n  {\n  size_t max_back = 0;\n  size_t gone_back;\n\n  end_code = this_start_code;\n  do\n    {\n    size_t back = (size_t)GET(end_code, 2+LINK_SIZE);\n    if (back > max_back) max_back = back;\n    end_code += GET(end_code, 1);\n    }\n  while (*end_code == OP_ALT);\n\n  /* If we can't go back the amount required for the longest lookbehind\n  pattern, go back as far as we can; some alternatives may still be viable. */\n\n#ifdef SUPPORT_UNICODE\n  /* In character mode we have to step back character by character */\n\n  if (utf)\n    {\n    for (gone_back = 0; gone_back < max_back; gone_back++)\n      {\n      if (current_subject <= start_subject) break;\n      current_subject--;\n      ACROSSCHAR(current_subject > start_subject, current_subject,\n        current_subject--);\n      }\n    }\n  else\n#endif\n\n  /* In byte-mode we can do this quickly. */\n\n    {\n    size_t current_offset = (size_t)(current_subject - start_subject);\n    gone_back = (current_offset < max_back)? current_offset : max_back;\n    current_subject -= gone_back;\n    }\n\n  /* Save the earliest consulted character */\n\n  if (current_subject < mb->start_used_ptr)\n    mb->start_used_ptr = current_subject;\n\n  /* Now we can process the individual branches. There will be an OP_REVERSE at\n  the start of each branch, except when the length of the branch is zero. */\n\n  end_code = this_start_code;\n  do\n    {\n    uint32_t revlen = (end_code\u00dd1+LINK_SIZE\u00a8 == OP_REVERSE)? 1 + LINK_SIZE : 0;\n    size_t back = (revlen == 0)? 0 : (size_t)GET(end_code, 2+LINK_SIZE);\n    if (back <= gone_back)\n      {\n      int bstate = (int)(end_code - start_code + 1 + LINK_SIZE + revlen);\n      ADD_NEW_DATA(-bstate, 0, (int)(gone_back - back));\n      }\n    end_code += GET(end_code, 1);\n    }\n  while (*end_code == OP_ALT);\n }\n\n/* This is the code for a \"normal\" subpattern (not a backward assertion). The\nstart of a whole pattern is always one of these. If we are at the top level,\nwe may be asked to restart matching from the same point that we reached for a\nprevious partial match. We still have to scan through the top-level branches to\nfind the end state. */\n\nelse\n  {\n  end_code = this_start_code;\n\n  /* Restarting */\n\n  if (rlevel == 1 && (mb->moptions & PCRE2_DFA_RESTART) != 0)\n    {\n    do { end_code += GET(end_code, 1); } while (*end_code == OP_ALT);\n    new_count = workspace\u00dd1\u00a8;\n    if (!workspace\u00dd0\u00a8)\n      memcpy(new_states, active_states, (size_t)new_count * sizeof(stateblock));\n    }\n\n  /* Not restarting */\n\n  else\n    {\n    int length = 1 + LINK_SIZE +\n      ((*this_start_code == OP_CBRA || *this_start_code == OP_SCBRA ||\n        *this_start_code == OP_CBRAPOS || *this_start_code == OP_SCBRAPOS)\n        ? IMM2_SIZE:0);\n    do\n      {\n      ADD_NEW((int)(end_code - start_code + length), 0);\n      end_code += GET(end_code, 1);\n      length = 1 + LINK_SIZE;\n      }\n    while (*end_code == OP_ALT);\n    }\n  }\n\nworkspace\u00dd0\u00a8 = 0;    /* Bit indicating which vector is current */\n\n/* Loop for scanning the subject */\n\nptr = current_subject;\nfor (;;)\n  {\n  int i, j;\n  int clen, dlen;\n  uint32_t c, d;\n  int forced_fail = 0;\n  BOOL partial_newline = FALSE;\n  BOOL could_continue = reset_could_continue;\n  reset_could_continue = FALSE;\n\n  if (ptr > mb->last_used_ptr) mb->last_used_ptr = ptr;\n\n  /* Make the new state list into the active state list and empty the\n  new state list. */\n\n  temp_states = active_states;\n  active_states = new_states;\n  new_states = temp_states;\n  active_count = new_count;\n  new_count = 0;\n\n  workspace\u00dd0\u00a8 \u00ac= 1;              /* Remember for the restarting feature */\n  workspace\u00dd1\u00a8 = active_count;\n\n  /* Set the pointers for adding new states */\n\n  next_active_state = active_states + active_count;\n  next_new_state = new_states;\n\n  /* Load the current character from the subject outside the loop, as many\n  different states may want to look at it, and we assume that at least one\n  will. */\n\n  if (ptr < end_subject)\n    {\n    clen = 1;        /* Number of data items in the character */\n#ifdef SUPPORT_UNICODE\n    GETCHARLENTEST(c, ptr, clen);\n#else\n    c = *ptr;\n#endif  /* SUPPORT_UNICODE */\n    }\n  else\n    {\n    clen = 0;        /* This indicates the end of the subject */\n    c = NOTACHAR;    /* This value should never actually be used */\n    }\n\n  /* Scan up the active states and act on each one. The result of an action\n  may be to add more states to the currently active list (e.g. on hitting a\n  parenthesis) or it may be to put states on the new list, for considering\n  when we move the character pointer on. */\n\n  for (i = 0; i < active_count; i++)\n    {\n    stateblock *current_state = active_states + i;\n    BOOL caseless = FALSE;\n    PCRE2_SPTR code;\n    uint32_t codevalue;\n    int state_offset = current_state->offset;\n    int rrc;\n    int count;\n\n    /* A negative offset is a special case meaning \"hold off going to this\n    (negated) state until the number of characters in the data field have\n    been skipped\". If the could_continue flag was passed over from a previous\n    state, arrange for it to passed on. */\n\n    if (state_offset < 0)\n      {\n      if (current_state->data > 0)\n        {\n        ADD_NEW_DATA(state_offset, current_state->count,\n          current_state->data - 1);\n        if (could_continue) reset_could_continue = TRUE;\n        continue;\n        }\n      else\n        {\n        current_state->offset = state_offset = -state_offset;\n        }\n      }\n\n    /* Check for a duplicate state with the same count, and skip if found.\n    See the note at the head of this module about the possibility of improving\n    performance here. */\n\n    for (j = 0; j < i; j++)\n      {\n      if (active_states\u00ddj\u00a8.offset == state_offset &&\n          active_states\u00ddj\u00a8.count == current_state->count)\n        goto NEXT_ACTIVE_STATE;\n      }\n\n    /* The state offset is the offset to the opcode */\n\n    code = start_code + state_offset;\n    codevalue = *code;\n\n    /* If this opcode inspects a character, but we are at the end of the\n    subject, remember the fact for use when testing for a partial match. */\n\n    if (clen == 0 && poptable\u00ddcodevalue\u00a8 != 0)\n      could_continue = TRUE;\n\n    /* If this opcode is followed by an inline character, load it. It is\n    tempting to test for the presence of a subject character here, but that\n    is wrong, because sometimes zero repetitions of the subject are\n    permitted.\n\n    We also use this mechanism for opcodes such as OP_TYPEPLUS that take an\n    argument that is not a data character - but is always one byte long because\n    the values are small. We have to take special action to deal with  \\P, \\p,\n    \\H, \\h, \\V, \\v and \\X in this case. To keep the other cases fast, convert\n    these ones to new opcodes. */\n\n    if (coptable\u00ddcodevalue\u00a8 > 0)\n      {\n      dlen = 1;\n#ifdef SUPPORT_UNICODE\n      if (utf) { GETCHARLEN(d, (code + coptable\u00ddcodevalue\u00a8), dlen); } else\n#endif  /* SUPPORT_UNICODE */\n      d = code\u00ddcoptable\u00ddcodevalue\u00a8\u00a8;\n      if (codevalue >= OP_TYPESTAR)\n        {\n        switch(d)\n          {\n          case OP_ANYBYTE: return PCRE2_ERROR_DFA_UITEM;\n          case OP_NOTPROP:\n          case OP_PROP: codevalue += OP_PROP_EXTRA; break;\n          case OP_ANYNL: codevalue += OP_ANYNL_EXTRA; break;\n          case OP_EXTUNI: codevalue += OP_EXTUNI_EXTRA; break;\n          case OP_NOT_HSPACE:\n          case OP_HSPACE: codevalue += OP_HSPACE_EXTRA; break;\n          case OP_NOT_VSPACE:\n          case OP_VSPACE: codevalue += OP_VSPACE_EXTRA; break;\n          default: break;\n          }\n        }\n      }\n    else\n      {\n      dlen = 0;         /* Not strictly necessary, but compilers moan */\n      d = NOTACHAR;     /* if these variables are not set. */\n      }\n\n\n    /* Now process the individual opcodes */\n\n    switch (codevalue)\n      {\n/* ========================================================================== */\n      /* These cases are never obeyed. This is a fudge that causes a compile-\n      time error if the vectors coptable or poptable, which are indexed by\n      opcode, are not the correct length. It seems to be the only way to do\n      such a check at compile time, as the sizeof() operator does not work\n      in the C preprocessor. */\n\n      case OP_TABLE_LENGTH:\n      case OP_TABLE_LENGTH +\n        ((sizeof(coptable) == OP_TABLE_LENGTH) &&\n         (sizeof(poptable) == OP_TABLE_LENGTH)):\n      return 0;\n\n/* ========================================================================== */\n      /* Reached a closing bracket. If not at the end of the pattern, carry\n      on with the next opcode. For repeating opcodes, also add the repeat\n      state. Note that KETRPOS will always be encountered at the end of the\n      subpattern, because the possessive subpattern repeats are always handled\n      using recursive calls. Thus, it never adds any new states.\n\n      At the end of the (sub)pattern, unless we have an empty string and\n      PCRE2_NOTEMPTY is set, or PCRE2_NOTEMPTY_ATSTART is set and we are at the\n      start of the subject, save the match data, shifting up all previous\n      matches so we always have the longest first. */\n\n      case OP_KET:\n      case OP_KETRMIN:\n      case OP_KETRMAX:\n      case OP_KETRPOS:\n      if (code != end_code)\n        {\n        ADD_ACTIVE(state_offset + 1 + LINK_SIZE, 0);\n        if (codevalue != OP_KET)\n          {\n          ADD_ACTIVE(state_offset - (int)GET(code, 1), 0);\n          }\n        }\n      else\n        {\n        if (ptr > current_subject ||\n            ((mb->moptions & PCRE2_NOTEMPTY) == 0 &&\n              ((mb->moptions & PCRE2_NOTEMPTY_ATSTART) == 0 ||\n                current_subject > start_subject + mb->start_offset)))\n          {\n          if (match_count < 0) match_count = (offsetcount >= 2)? 1 : 0;\n            else if (match_count > 0 && ++match_count * 2 > (int)offsetcount)\n              match_count = 0;\n          count = ((match_count == 0)? (int)offsetcount : match_count * 2) - 2;\n          if (count > 0) (void)memmove(offsets + 2, offsets,\n            (size_t)count * sizeof(PCRE2_SIZE));\n          if (offsetcount >= 2)\n            {\n            offsets\u00dd0\u00a8 = (PCRE2_SIZE)(current_subject - start_subject);\n            offsets\u00dd1\u00a8 = (PCRE2_SIZE)(ptr - start_subject);\n            }\n          if ((mb->moptions & PCRE2_DFA_SHORTEST) != 0) return match_count;\n          }\n        }\n      break;\n\n/* ========================================================================== */\n      /* These opcodes add to the current list of states without looking\n      at the current character. */\n\n      /*-----------------------------------------------------------------*/\n      case OP_ALT:\n      do { code += GET(code, 1); } while (*code == OP_ALT);\n      ADD_ACTIVE((int)(code - start_code), 0);\n      break;\n\n      /*-----------------------------------------------------------------*/\n      case OP_BRA:\n      case OP_SBRA:\n      do\n        {\n        ADD_ACTIVE((int)(code - start_code + 1 + LINK_SIZE), 0);\n        code += GET(code, 1);\n        }\n      while (*code == OP_ALT);\n      break;\n\n      /*-----------------------------------------------------------------*/\n      case OP_CBRA:\n      case OP_SCBRA:\n      ADD_ACTIVE((int)(code - start_code + 1 + LINK_SIZE + IMM2_SIZE),  0);\n      code += GET(code, 1);\n      while (*code == OP_ALT)\n        {\n        ADD_ACTIVE((int)(code - start_code + 1 + LINK_SIZE),  0);\n        code += GET(code, 1);\n        }\n      break;\n\n      /*-----------------------------------------------------------------*/\n      case OP_BRAZERO:\n      case OP_BRAMINZERO:\n      ADD_ACTIVE(state_offset + 1, 0);\n      code += 1 + GET(code, 2);\n      while (*code == OP_ALT) code += GET(code, 1);\n      ADD_ACTIVE((int)(code - start_code + 1 + LINK_SIZE), 0);\n      break;\n\n      /*-----------------------------------------------------------------*/\n      case OP_SKIPZERO:\n      code += 1 + GET(code, 2);\n      while (*code == OP_ALT) code += GET(code, 1);\n      ADD_ACTIVE((int)(code - start_code + 1 + LINK_SIZE), 0);\n      break;\n\n      /*-----------------------------------------------------------------*/\n      case OP_CIRC:\n      if (ptr == start_subject && (mb->moptions & PCRE2_NOTBOL) == 0)\n        { ADD_ACTIVE(state_offset + 1, 0); }\n      break;\n\n      /*-----------------------------------------------------------------*/\n      case OP_CIRCM:\n      if ((ptr == start_subject && (mb->moptions & PCRE2_NOTBOL) == 0) ||\n          ((ptr != end_subject || (mb->poptions & PCRE2_ALT_CIRCUMFLEX) != 0 )\n            && WAS_NEWLINE(ptr)))\n        { ADD_ACTIVE(state_offset + 1, 0); }\n      break;\n\n      /*-----------------------------------------------------------------*/\n      case OP_EOD:\n      if (ptr >= end_subject)\n        {\n        if ((mb->moptions & PCRE2_PARTIAL_HARD) != 0)\n          return PCRE2_ERROR_PARTIAL;\n        else { ADD_ACTIVE(state_offset + 1, 0); }\n        }\n      break;\n\n      /*-----------------------------------------------------------------*/\n      case OP_SOD:\n      if (ptr == start_subject) { ADD_ACTIVE(state_offset + 1, 0); }\n      break;\n\n      /*-----------------------------------------------------------------*/\n      case OP_SOM:\n      if (ptr == start_subject + start_offset) { ADD_ACTIVE(state_offset + 1, 0); }\n      break;\n\n\n/* ========================================================================== */\n      /* These opcodes inspect the next subject character, and sometimes\n      the previous one as well, but do not have an argument. The variable\n      clen contains the length of the current character and is zero if we are\n      at the end of the subject. */\n\n      /*-----------------------------------------------------------------*/\n      case OP_ANY:\n      if (clen > 0 && !IS_NEWLINE(ptr))\n        {\n        if (ptr + 1 >= mb->end_subject &&\n            (mb->moptions & (PCRE2_PARTIAL_HARD)) != 0 &&\n            NLBLOCK->nltype == NLTYPE_FIXED &&\n            NLBLOCK->nllen == 2 &&\n            c == NLBLOCK->nl\u00dd0\u00a8)\n          {\n          could_continue = partial_newline = TRUE;\n          }\n        else\n          {\n          ADD_NEW(state_offset + 1, 0);\n          }\n        }\n      break;\n\n      /*-----------------------------------------------------------------*/\n      case OP_ALLANY:\n      if (clen > 0)\n        { ADD_NEW(state_offset + 1, 0); }\n      break;\n\n      /*-----------------------------------------------------------------*/\n      case OP_EODN:\n      if (clen == 0 || (IS_NEWLINE(ptr) && ptr == end_subject - mb->nllen))\n        {\n        if ((mb->moptions & PCRE2_PARTIAL_HARD) != 0)\n          return PCRE2_ERROR_PARTIAL;\n        ADD_ACTIVE(state_offset + 1, 0);\n        }\n      break;\n\n      /*-----------------------------------------------------------------*/\n      case OP_DOLL:\n      if ((mb->moptions & PCRE2_NOTEOL) == 0)\n        {\n        if (clen == 0 && (mb->moptions & PCRE2_PARTIAL_HARD) != 0)\n          could_continue = TRUE;\n        else if (clen == 0 ||\n            ((mb->poptions & PCRE2_DOLLAR_ENDONLY) == 0 && IS_NEWLINE(ptr) &&\n               (ptr == end_subject - mb->nllen)\n            ))\n          { ADD_ACTIVE(state_offset + 1, 0); }\n        else if (ptr + 1 >= mb->end_subject &&\n                 (mb->moptions & (PCRE2_PARTIAL_HARD|PCRE2_PARTIAL_SOFT)) != 0 &&\n                 NLBLOCK->nltype == NLTYPE_FIXED &&\n                 NLBLOCK->nllen == 2 &&\n                 c == NLBLOCK->nl\u00dd0\u00a8)\n          {\n          if ((mb->moptions & PCRE2_PARTIAL_HARD) != 0)\n            {\n            reset_could_continue = TRUE;\n            ADD_NEW_DATA(-(state_offset + 1), 0, 1);\n            }\n          else could_continue = partial_newline = TRUE;\n          }\n        }\n      break;\n\n      /*-----------------------------------------------------------------*/\n      case OP_DOLLM:\n      if ((mb->moptions & PCRE2_NOTEOL) == 0)\n        {\n        if (clen == 0 && (mb->moptions & PCRE2_PARTIAL_HARD) != 0)\n          could_continue = TRUE;\n        else if (clen == 0 ||\n            ((mb->poptions & PCRE2_DOLLAR_ENDONLY) == 0 && IS_NEWLINE(ptr)))\n          { ADD_ACTIVE(state_offset + 1, 0); }\n        else if (ptr + 1 >= mb->end_subject &&\n                 (mb->moptions & (PCRE2_PARTIAL_HARD|PCRE2_PARTIAL_SOFT)) != 0 &&\n                 NLBLOCK->nltype == NLTYPE_FIXED &&\n                 NLBLOCK->nllen == 2 &&\n                 c == NLBLOCK->nl\u00dd0\u00a8)\n          {\n          if ((mb->moptions & PCRE2_PARTIAL_HARD) != 0)\n            {\n            reset_could_continue = TRUE;\n            ADD_NEW_DATA(-(state_offset + 1), 0, 1);\n            }\n          else could_continue = partial_newline = TRUE;\n          }\n        }\n      else if (IS_NEWLINE(ptr))\n        { ADD_ACTIVE(state_offset + 1, 0); }\n      break;\n\n      /*-----------------------------------------------------------------*/\n\n      case OP_DIGIT:\n      case OP_WHITESPACE:\n      case OP_WORDCHAR:\n      if (clen > 0 && c < 256 &&\n            ((ctypes\u00ddc\u00a8 & toptable1\u00ddcodevalue\u00a8) \u00ac toptable2\u00ddcodevalue\u00a8) != 0)\n        { ADD_NEW(state_offset + 1, 0); }\n      break;\n\n      /*-----------------------------------------------------------------*/\n      case OP_NOT_DIGIT:\n      case OP_NOT_WHITESPACE:\n      case OP_NOT_WORDCHAR:\n      if (clen > 0 && (c >= 256 ||\n            ((ctypes\u00ddc\u00a8 & toptable1\u00ddcodevalue\u00a8) \u00ac toptable2\u00ddcodevalue\u00a8) != 0))\n        { ADD_NEW(state_offset + 1, 0); }\n      break;\n\n      /*-----------------------------------------------------------------*/\n      case OP_WORD_BOUNDARY:\n      case OP_NOT_WORD_BOUNDARY:\n        {\n        int left_word, right_word;\n\n        if (ptr > start_subject)\n          {\n          PCRE2_SPTR temp = ptr - 1;\n          if (temp < mb->start_used_ptr) mb->start_used_ptr = temp;\n#if defined SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH != 32\n          if (utf) { BACKCHAR(temp); }\n#endif\n          GETCHARTEST(d, temp);\n#ifdef SUPPORT_UNICODE\n          if ((mb->poptions & PCRE2_UCP) != 0)\n            {\n            if (d == '_') left_word = TRUE; else\n              {\n              uint32_t cat = UCD_CATEGORY(d);\n              left_word = (cat == ucp_L || cat == ucp_N);\n              }\n            }\n          else\n#endif\n          left_word = d < 256 && (ctypes\u00ddd\u00a8 & ctype_word) != 0;\n          }\n        else left_word = FALSE;\n\n        if (clen > 0)\n          {\n          if (ptr >= mb->last_used_ptr)\n            {\n            PCRE2_SPTR temp = ptr + 1;\n#if defined SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH != 32\n            if (utf) { FORWARDCHARTEST(temp, mb->end_subject); }\n#endif\n            mb->last_used_ptr = temp;\n            }\n#ifdef SUPPORT_UNICODE\n          if ((mb->poptions & PCRE2_UCP) != 0)\n            {\n            if (c == '_') right_word = TRUE; else\n              {\n              uint32_t cat = UCD_CATEGORY(c);\n              right_word = (cat == ucp_L || cat == ucp_N);\n              }\n            }\n          else\n#endif\n          right_word = c < 256 && (ctypes\u00ddc\u00a8 & ctype_word) != 0;\n          }\n        else right_word = FALSE;\n\n        if ((left_word == right_word) == (codevalue == OP_NOT_WORD_BOUNDARY))\n          { ADD_ACTIVE(state_offset + 1, 0); }\n        }\n      break;\n\n\n      /*-----------------------------------------------------------------*/\n      /* Check the next character by Unicode property. We will get here only\n      if the support is in the binary; otherwise a compile-time error occurs.\n      */\n\n#ifdef SUPPORT_UNICODE\n      case OP_PROP:\n      case OP_NOTPROP:\n      if (clen > 0)\n        {\n        BOOL OK;\n        const uint32_t *cp;\n        const ucd_record * prop = GET_UCD(c);\n        switch(code\u00dd1\u00a8)\n          {\n          case PT_ANY:\n          OK = TRUE;\n          break;\n\n          case PT_LAMP:\n          OK = prop->chartype == ucp_Lu || prop->chartype == ucp_Ll ||\n               prop->chartype == ucp_Lt;\n          break;\n\n          case PT_GC:\n          OK = PRIV(ucp_gentype)\u00ddprop->chartype\u00a8 == code\u00dd2\u00a8;\n          break;\n\n          case PT_PC:\n          OK = prop->chartype == code\u00dd2\u00a8;\n          break;\n\n          case PT_SC:\n          OK = prop->script == code\u00dd2\u00a8;\n          break;\n\n          /* These are specials for combination cases. */\n\n          case PT_ALNUM:\n          OK = PRIV(ucp_gentype)\u00ddprop->chartype\u00a8 == ucp_L ||\n               PRIV(ucp_gentype)\u00ddprop->chartype\u00a8 == ucp_N;\n          break;\n\n          /* Perl space used to exclude VT, but from Perl 5.18 it is included,\n          which means that Perl space and POSIX space are now identical. PCRE\n          was changed at release 8.34. */\n\n          case PT_SPACE:    /* Perl space */\n          case PT_PXSPACE:  /* POSIX space */\n          switch(c)\n            {\n            HSPACE_CASES:\n            VSPACE_CASES:\n            OK = TRUE;\n            break;\n\n            default:\n            OK = PRIV(ucp_gentype)\u00ddprop->chartype\u00a8 == ucp_Z;\n            break;\n            }\n          break;\n\n          case PT_WORD:\n          OK = PRIV(ucp_gentype)\u00ddprop->chartype\u00a8 == ucp_L ||\n               PRIV(ucp_gentype)\u00ddprop->chartype\u00a8 == ucp_N ||\n               c == CHAR_UNDERSCORE;\n          break;\n\n          case PT_CLIST:\n          cp = PRIV(ucd_caseless_sets) + code\u00dd2\u00a8;\n          for (;;)\n            {\n            if (c < *cp) { OK = FALSE; break; }\n            if (c == *cp++) { OK = TRUE; break; }\n            }\n          break;\n\n          case PT_UCNC:\n          OK = c == CHAR_DOLLAR_SIGN || c == CHAR_COMMERCIAL_AT ||\n               c == CHAR_GRAVE_ACCENT || (c >= 0xa0 && c <= 0xd7ff) ||\n               c >= 0xe000;\n          break;\n\n          /* Should never occur, but keep compilers from grumbling. */\n\n          default:\n          OK = codevalue != OP_PROP;\n          break;\n          }\n\n        if (OK == (codevalue == OP_PROP)) { ADD_NEW(state_offset + 3, 0); }\n        }\n      break;\n#endif\n\n\n\n/* ========================================================================== */\n      /* These opcodes likewise inspect the subject character, but have an\n      argument that is not a data character. It is one of these opcodes:\n      OP_ANY, OP_ALLANY, OP_DIGIT, OP_NOT_DIGIT, OP_WHITESPACE, OP_NOT_SPACE,\n      OP_WORDCHAR, OP_NOT_WORDCHAR. The value is loaded into d. */\n\n      case OP_TYPEPLUS:\n      case OP_TYPEMINPLUS:\n      case OP_TYPEPOSPLUS:\n      count = current_state->count;  /* Already matched */\n      if (count > 0) { ADD_ACTIVE(state_offset + 2, 0); }\n      if (clen > 0)\n        {\n        if (d == OP_ANY && ptr + 1 >= mb->end_subject &&\n            (mb->moptions & (PCRE2_PARTIAL_HARD)) != 0 &&\n            NLBLOCK->nltype == NLTYPE_FIXED &&\n            NLBLOCK->nllen == 2 &&\n            c == NLBLOCK->nl\u00dd0\u00a8)\n          {\n          could_continue = partial_newline = TRUE;\n          }\n        else if ((c >= 256 && d != OP_DIGIT && d != OP_WHITESPACE && d != OP_WORDCHAR) ||\n            (c < 256 &&\n              (d != OP_ANY || !IS_NEWLINE(ptr)) &&\n              ((ctypes\u00ddc\u00a8 & toptable1\u00ddd\u00a8) \u00ac toptable2\u00ddd\u00a8) != 0))\n          {\n          if (count > 0 && codevalue == OP_TYPEPOSPLUS)\n            {\n            active_count--;            /* Remove non-match possibility */\n            next_active_state--;\n            }\n          count++;\n          ADD_NEW(state_offset, count);\n          }\n        }\n      break;\n\n      /*-----------------------------------------------------------------*/\n      case OP_TYPEQUERY:\n      case OP_TYPEMINQUERY:\n      case OP_TYPEPOSQUERY:\n      ADD_ACTIVE(state_offset + 2, 0);\n      if (clen > 0)\n        {\n        if (d == OP_ANY && ptr + 1 >= mb->end_subject &&\n            (mb->moptions & (PCRE2_PARTIAL_HARD)) != 0 &&\n            NLBLOCK->nltype == NLTYPE_FIXED &&\n            NLBLOCK->nllen == 2 &&\n            c == NLBLOCK->nl\u00dd0\u00a8)\n          {\n          could_continue = partial_newline = TRUE;\n          }\n        else if ((c >= 256 && d != OP_DIGIT && d != OP_WHITESPACE && d != OP_WORDCHAR) ||\n            (c < 256 &&\n              (d != OP_ANY || !IS_NEWLINE(ptr)) &&\n              ((ctypes\u00ddc\u00a8 & toptable1\u00ddd\u00a8) \u00ac toptable2\u00ddd\u00a8) != 0))\n          {\n          if (codevalue == OP_TYPEPOSQUERY)\n            {\n            active_count--;            /* Remove non-match possibility */\n            next_active_state--;\n            }\n          ADD_NEW(state_offset + 2, 0);\n          }\n        }\n      break;\n\n      /*-----------------------------------------------------------------*/\n      case OP_TYPESTAR:\n      case OP_TYPEMINSTAR:\n      case OP_TYPEPOSSTAR:\n      ADD_ACTIVE(state_offset + 2, 0);\n      if (clen > 0)\n        {\n        if (d == OP_ANY && ptr + 1 >= mb->end_subject &&\n            (mb->moptions & (PCRE2_PARTIAL_HARD)) != 0 &&\n            NLBLOCK->nltype == NLTYPE_FIXED &&\n            NLBLOCK->nllen == 2 &&\n            c == NLBLOCK->nl\u00dd0\u00a8)\n          {\n          could_continue = partial_newline = TRUE;\n          }\n        else if ((c >= 256 && d != OP_DIGIT && d != OP_WHITESPACE && d != OP_WORDCHAR) ||\n            (c < 256 &&\n              (d != OP_ANY || !IS_NEWLINE(ptr)) &&\n              ((ctypes\u00ddc\u00a8 & toptable1\u00ddd\u00a8) \u00ac toptable2\u00ddd\u00a8) != 0))\n          {\n          if (codevalue == OP_TYPEPOSSTAR)\n            {\n            active_count--;            /* Remove non-match possibility */\n            next_active_state--;\n            }\n          ADD_NEW(state_offset, 0);\n          }\n        }\n      break;\n\n      /*-----------------------------------------------------------------*/\n      case OP_TYPEEXACT:\n      count = current_state->count;  /* Number already matched */\n      if (clen > 0)\n        {\n        if (d == OP_ANY && ptr + 1 >= mb->end_subject &&\n            (mb->moptions & (PCRE2_PARTIAL_HARD)) != 0 &&\n            NLBLOCK->nltype == NLTYPE_FIXED &&\n            NLBLOCK->nllen == 2 &&\n            c == NLBLOCK->nl\u00dd0\u00a8)\n          {\n          could_continue = partial_newline = TRUE;\n          }\n        else if ((c >= 256 && d != OP_DIGIT && d != OP_WHITESPACE && d != OP_WORDCHAR) ||\n            (c < 256 &&\n              (d != OP_ANY || !IS_NEWLINE(ptr)) &&\n              ((ctypes\u00ddc\u00a8 & toptable1\u00ddd\u00a8) \u00ac toptable2\u00ddd\u00a8) != 0))\n          {\n          if (++count >= (int)GET2(code, 1))\n            { ADD_NEW(state_offset + 1 + IMM2_SIZE + 1, 0); }\n          else\n            { ADD_NEW(state_offset, count); }\n          }\n        }\n      break;\n\n      /*-----------------------------------------------------------------*/\n      case OP_TYPEUPTO:\n      case OP_TYPEMINUPTO:\n      case OP_TYPEPOSUPTO:\n      ADD_ACTIVE(state_offset + 2 + IMM2_SIZE, 0);\n      count = current_state->count;  /* Number already matched */\n      if (clen > 0)\n        {\n        if (d == OP_ANY && ptr + 1 >= mb->end_subject &&\n            (mb->moptions & (PCRE2_PARTIAL_HARD)) != 0 &&\n            NLBLOCK->nltype == NLTYPE_FIXED &&\n            NLBLOCK->nllen == 2 &&\n            c == NLBLOCK->nl\u00dd0\u00a8)\n          {\n          could_continue = partial_newline = TRUE;\n          }\n        else if ((c >= 256 && d != OP_DIGIT && d != OP_WHITESPACE && d != OP_WORDCHAR) ||\n            (c < 256 &&\n              (d != OP_ANY || !IS_NEWLINE(ptr)) &&\n              ((ctypes\u00ddc\u00a8 & toptable1\u00ddd\u00a8) \u00ac toptable2\u00ddd\u00a8) != 0))\n          {\n          if (codevalue == OP_TYPEPOSUPTO)\n            {\n            active_count--;           /* Remove non-match possibility */\n            next_active_state--;\n            }\n          if (++count >= (int)GET2(code, 1))\n            { ADD_NEW(state_offset + 2 + IMM2_SIZE, 0); }\n          else\n            { ADD_NEW(state_offset, count); }\n          }\n        }\n      break;\n\n/* ========================================================================== */\n      /* These are virtual opcodes that are used when something like\n      OP_TYPEPLUS has OP_PROP, OP_NOTPROP, OP_ANYNL, or OP_EXTUNI as its\n      argument. It keeps the code above fast for the other cases. The argument\n      is in the d variable. */\n\n#ifdef SUPPORT_UNICODE\n      case OP_PROP_EXTRA + OP_TYPEPLUS:\n      case OP_PROP_EXTRA + OP_TYPEMINPLUS:\n      case OP_PROP_EXTRA + OP_TYPEPOSPLUS:\n      count = current_state->count;           /* Already matched */\n      if (count > 0) { ADD_ACTIVE(state_offset + 4, 0); }\n      if (clen > 0)\n        {\n        BOOL OK;\n        const uint32_t *cp;\n        const ucd_record * prop = GET_UCD(c);\n        switch(code\u00dd2\u00a8)\n          {\n          case PT_ANY:\n          OK = TRUE;\n          break;\n\n          case PT_LAMP:\n          OK = prop->chartype == ucp_Lu || prop->chartype == ucp_Ll ||\n            prop->chartype == ucp_Lt;\n          break;\n\n          case PT_GC:\n          OK = PRIV(ucp_gentype)\u00ddprop->chartype\u00a8 == code\u00dd3\u00a8;\n          break;\n\n          case PT_PC:\n          OK = prop->chartype == code\u00dd3\u00a8;\n          break;\n\n          case PT_SC:\n          OK = prop->script == code\u00dd3\u00a8;\n          break;\n\n          /* These are specials for combination cases. */\n\n          case PT_ALNUM:\n          OK = PRIV(ucp_gentype)\u00ddprop->chartype\u00a8 == ucp_L ||\n               PRIV(ucp_gentype)\u00ddprop->chartype\u00a8 == ucp_N;\n          break;\n\n          /* Perl space used to exclude VT, but from Perl 5.18 it is included,\n          which means that Perl space and POSIX space are now identical. PCRE\n          was changed at release 8.34. */\n\n          case PT_SPACE:    /* Perl space */\n          case PT_PXSPACE:  /* POSIX space */\n          switch(c)\n            {\n            HSPACE_CASES:\n            VSPACE_CASES:\n            OK = TRUE;\n            break;\n\n            default:\n            OK = PRIV(ucp_gentype)\u00ddprop->chartype\u00a8 == ucp_Z;\n            break;\n            }\n          break;\n\n          case PT_WORD:\n          OK = PRIV(ucp_gentype)\u00ddprop->chartype\u00a8 == ucp_L ||\n               PRIV(ucp_gentype)\u00ddprop->chartype\u00a8 == ucp_N ||\n               c == CHAR_UNDERSCORE;\n          break;\n\n          case PT_CLIST:\n          cp = PRIV(ucd_caseless_sets) + code\u00dd3\u00a8;\n          for (;;)\n            {\n            if (c < *cp) { OK = FALSE; break; }\n            if (c == *cp++) { OK = TRUE; break; }\n            }\n          break;\n\n          case PT_UCNC:\n          OK = c == CHAR_DOLLAR_SIGN || c == CHAR_COMMERCIAL_AT ||\n               c == CHAR_GRAVE_ACCENT || (c >= 0xa0 && c <= 0xd7ff) ||\n               c >= 0xe000;\n          break;\n\n          /* Should never occur, but keep compilers from grumbling. */\n\n          default:\n          OK = codevalue != OP_PROP;\n          break;\n          }\n\n        if (OK == (d == OP_PROP))\n          {\n          if (count > 0 && codevalue == OP_PROP_EXTRA + OP_TYPEPOSPLUS)\n            {\n            active_count--;           /* Remove non-match possibility */\n            next_active_state--;\n            }\n          count++;\n          ADD_NEW(state_offset, count);\n          }\n        }\n      break;\n\n      /*-----------------------------------------------------------------*/\n      case OP_EXTUNI_EXTRA + OP_TYPEPLUS:\n      case OP_EXTUNI_EXTRA + OP_TYPEMINPLUS:\n      case OP_EXTUNI_EXTRA + OP_TYPEPOSPLUS:\n      count = current_state->count;  /* Already matched */\n      if (count > 0) { ADD_ACTIVE(state_offset + 2, 0); }\n      if (clen > 0)\n        {\n        int ncount = 0;\n        if (count > 0 && codevalue == OP_EXTUNI_EXTRA + OP_TYPEPOSPLUS)\n          {\n          active_count--;           /* Remove non-match possibility */\n          next_active_state--;\n          }\n        (void)PRIV(extuni)(c, ptr + clen, mb->start_subject, end_subject, utf,\n          &ncount);\n        count++;\n        ADD_NEW_DATA(-state_offset, count, ncount);\n        }\n      break;\n#endif\n\n      /*-----------------------------------------------------------------*/\n      case OP_ANYNL_EXTRA + OP_TYPEPLUS:\n      case OP_ANYNL_EXTRA + OP_TYPEMINPLUS:\n      case OP_ANYNL_EXTRA + OP_TYPEPOSPLUS:\n      count = current_state->count;  /* Already matched */\n      if (count > 0) { ADD_ACTIVE(state_offset + 2, 0); }\n      if (clen > 0)\n        {\n        int ncount = 0;\n        switch (c)\n          {\n          case CHAR_VT:\n          case CHAR_FF:\n          case CHAR_NEL:\n#ifndef EBCDIC\n          case 0x2028:\n          case 0x2029:\n#endif  /* Not EBCDIC */\n          if (mb->bsr_convention == PCRE2_BSR_ANYCRLF) break;\n          goto ANYNL01;\n\n          case CHAR_CR:\n          if (ptr + 1 < end_subject && UCHAR21TEST(ptr + 1) == CHAR_LF) ncount = 1;\n          /* Fall through */\n\n          ANYNL01:\n          case CHAR_LF:\n          if (count > 0 && codevalue == OP_ANYNL_EXTRA + OP_TYPEPOSPLUS)\n            {\n            active_count--;           /* Remove non-match possibility */\n            next_active_state--;\n            }\n          count++;\n          ADD_NEW_DATA(-state_offset, count, ncount);\n          break;\n\n          default:\n          break;\n          }\n        }\n      break;\n\n      /*-----------------------------------------------------------------*/\n      case OP_VSPACE_EXTRA + OP_TYPEPLUS:\n      case OP_VSPACE_EXTRA + OP_TYPEMINPLUS:\n      case OP_VSPACE_EXTRA + OP_TYPEPOSPLUS:\n      count = current_state->count;  /* Already matched */\n      if (count > 0) { ADD_ACTIVE(state_offset + 2, 0); }\n      if (clen > 0)\n        {\n        BOOL OK;\n        switch (c)\n          {\n          VSPACE_CASES:\n          OK = TRUE;\n          break;\n\n          default:\n          OK = FALSE;\n          break;\n          }\n\n        if (OK == (d == OP_VSPACE))\n          {\n          if (count > 0 && codevalue == OP_VSPACE_EXTRA + OP_TYPEPOSPLUS)\n            {\n            active_count--;           /* Remove non-match possibility */\n            next_active_state--;\n            }\n          count++;\n          ADD_NEW_DATA(-state_offset, count, 0);\n          }\n        }\n      break;\n\n      /*-----------------------------------------------------------------*/\n      case OP_HSPACE_EXTRA + OP_TYPEPLUS:\n      case OP_HSPACE_EXTRA + OP_TYPEMINPLUS:\n      case OP_HSPACE_EXTRA + OP_TYPEPOSPLUS:\n      count = current_state->count;  /* Already matched */\n      if (count > 0) { ADD_ACTIVE(state_offset + 2, 0); }\n      if (clen > 0)\n        {\n        BOOL OK;\n        switch (c)\n          {\n          HSPACE_CASES:\n          OK = TRUE;\n          break;\n\n          default:\n          OK = FALSE;\n          break;\n          }\n\n        if (OK == (d == OP_HSPACE))\n          {\n          if (count > 0 && codevalue == OP_HSPACE_EXTRA + OP_TYPEPOSPLUS)\n            {\n            active_count--;           /* Remove non-match possibility */\n            next_active_state--;\n            }\n          count++;\n          ADD_NEW_DATA(-state_offset, count, 0);\n          }\n        }\n      break;\n\n      /*-----------------------------------------------------------------*/\n#ifdef SUPPORT_UNICODE\n      case OP_PROP_EXTRA + OP_TYPEQUERY:\n      case OP_PROP_EXTRA + OP_TYPEMINQUERY:\n      case OP_PROP_EXTRA + OP_TYPEPOSQUERY:\n      count = 4;\n      goto QS1;\n\n      case OP_PROP_EXTRA + OP_TYPESTAR:\n      case OP_PROP_EXTRA + OP_TYPEMINSTAR:\n      case OP_PROP_EXTRA + OP_TYPEPOSSTAR:\n      count = 0;\n\n      QS1:\n\n      ADD_ACTIVE(state_offset + 4, 0);\n      if (clen > 0)\n        {\n        BOOL OK;\n        const uint32_t *cp;\n        const ucd_record * prop = GET_UCD(c);\n        switch(code\u00dd2\u00a8)\n          {\n          case PT_ANY:\n          OK = TRUE;\n          break;\n\n          case PT_LAMP:\n          OK = prop->chartype == ucp_Lu || prop->chartype == ucp_Ll ||\n            prop->chartype == ucp_Lt;\n          break;\n\n          case PT_GC:\n          OK = PRIV(ucp_gentype)\u00ddprop->chartype\u00a8 == code\u00dd3\u00a8;\n          break;\n\n          case PT_PC:\n          OK = prop->chartype == code\u00dd3\u00a8;\n          break;\n\n          case PT_SC:\n          OK = prop->script == code\u00dd3\u00a8;\n          break;\n\n          /* These are specials for combination cases. */\n\n          case PT_ALNUM:\n          OK = PRIV(ucp_gentype)\u00ddprop->chartype\u00a8 == ucp_L ||\n               PRIV(ucp_gentype)\u00ddprop->chartype\u00a8 == ucp_N;\n          break;\n\n          /* Perl space used to exclude VT, but from Perl 5.18 it is included,\n          which means that Perl space and POSIX space are now identical. PCRE\n          was changed at release 8.34. */\n\n          case PT_SPACE:    /* Perl space */\n          case PT_PXSPACE:  /* POSIX space */\n          switch(c)\n            {\n            HSPACE_CASES:\n            VSPACE_CASES:\n            OK = TRUE;\n            break;\n\n            default:\n            OK = PRIV(ucp_gentype)\u00ddprop->chartype\u00a8 == ucp_Z;\n            break;\n            }\n          break;\n\n          case PT_WORD:\n          OK = PRIV(ucp_gentype)\u00ddprop->chartype\u00a8 == ucp_L ||\n               PRIV(ucp_gentype)\u00ddprop->chartype\u00a8 == ucp_N ||\n               c == CHAR_UNDERSCORE;\n          break;\n\n          case PT_CLIST:\n          cp = PRIV(ucd_caseless_sets) + code\u00dd3\u00a8;\n          for (;;)\n            {\n            if (c < *cp) { OK = FALSE; break; }\n            if (c == *cp++) { OK = TRUE; break; }\n            }\n          break;\n\n          case PT_UCNC:\n          OK = c == CHAR_DOLLAR_SIGN || c == CHAR_COMMERCIAL_AT ||\n               c == CHAR_GRAVE_ACCENT || (c >= 0xa0 && c <= 0xd7ff) ||\n               c >= 0xe000;\n          break;\n\n          /* Should never occur, but keep compilers from grumbling. */\n\n          default:\n          OK = codevalue != OP_PROP;\n          break;\n          }\n\n        if (OK == (d == OP_PROP))\n          {\n          if (codevalue == OP_PROP_EXTRA + OP_TYPEPOSSTAR ||\n              codevalue == OP_PROP_EXTRA + OP_TYPEPOSQUERY)\n            {\n            active_count--;           /* Remove non-match possibility */\n            next_active_state--;\n            }\n          ADD_NEW(state_offset + count, 0);\n          }\n        }\n      break;\n\n      /*-----------------------------------------------------------------*/\n      case OP_EXTUNI_EXTRA + OP_TYPEQUERY:\n      case OP_EXTUNI_EXTRA + OP_TYPEMINQUERY:\n      case OP_EXTUNI_EXTRA + OP_TYPEPOSQUERY:\n      count = 2;\n      goto QS2;\n\n      case OP_EXTUNI_EXTRA + OP_TYPESTAR:\n      case OP_EXTUNI_EXTRA + OP_TYPEMINSTAR:\n      case OP_EXTUNI_EXTRA + OP_TYPEPOSSTAR:\n      count = 0;\n\n      QS2:\n\n      ADD_ACTIVE(state_offset + 2, 0);\n      if (clen > 0)\n        {\n        int ncount = 0;\n        if (codevalue == OP_EXTUNI_EXTRA + OP_TYPEPOSSTAR ||\n            codevalue == OP_EXTUNI_EXTRA + OP_TYPEPOSQUERY)\n          {\n          active_count--;           /* Remove non-match possibility */\n          next_active_state--;\n          }\n        (void)PRIV(extuni)(c, ptr + clen, mb->start_subject, end_subject, utf,\n          &ncount);\n        ADD_NEW_DATA(-(state_offset + count), 0, ncount);\n        }\n      break;\n#endif\n\n      /*-----------------------------------------------------------------*/\n      case OP_ANYNL_EXTRA + OP_TYPEQUERY:\n      case OP_ANYNL_EXTRA + OP_TYPEMINQUERY:\n      case OP_ANYNL_EXTRA + OP_TYPEPOSQUERY:\n      count = 2;\n      goto QS3;\n\n      case OP_ANYNL_EXTRA + OP_TYPESTAR:\n      case OP_ANYNL_EXTRA + OP_TYPEMINSTAR:\n      case OP_ANYNL_EXTRA + OP_TYPEPOSSTAR:\n      count = 0;\n\n      QS3:\n      ADD_ACTIVE(state_offset + 2, 0);\n      if (clen > 0)\n        {\n        int ncount = 0;\n        switch (c)\n          {\n          case CHAR_VT:\n          case CHAR_FF:\n          case CHAR_NEL:\n#ifndef EBCDIC\n          case 0x2028:\n          case 0x2029:\n#endif  /* Not EBCDIC */\n          if (mb->bsr_convention == PCRE2_BSR_ANYCRLF) break;\n          goto ANYNL02;\n\n          case CHAR_CR:\n          if (ptr + 1 < end_subject && UCHAR21TEST(ptr + 1) == CHAR_LF) ncount = 1;\n          /* Fall through */\n\n          ANYNL02:\n          case CHAR_LF:\n          if (codevalue == OP_ANYNL_EXTRA + OP_TYPEPOSSTAR ||\n              codevalue == OP_ANYNL_EXTRA + OP_TYPEPOSQUERY)\n            {\n            active_count--;           /* Remove non-match possibility */\n            next_active_state--;\n            }\n          ADD_NEW_DATA(-(state_offset + (int)count), 0, ncount);\n          break;\n\n          default:\n          break;\n          }\n        }\n      break;\n\n      /*-----------------------------------------------------------------*/\n      case OP_VSPACE_EXTRA + OP_TYPEQUERY:\n      case OP_VSPACE_EXTRA + OP_TYPEMINQUERY:\n      case OP_VSPACE_EXTRA + OP_TYPEPOSQUERY:\n      count = 2;\n      goto QS4;\n\n      case OP_VSPACE_EXTRA + OP_TYPESTAR:\n      case OP_VSPACE_EXTRA + OP_TYPEMINSTAR:\n      case OP_VSPACE_EXTRA + OP_TYPEPOSSTAR:\n      count = 0;\n\n      QS4:\n      ADD_ACTIVE(state_offset + 2, 0);\n      if (clen > 0)\n        {\n        BOOL OK;\n        switch (c)\n          {\n          VSPACE_CASES:\n          OK = TRUE;\n          break;\n\n          default:\n          OK = FALSE;\n          break;\n          }\n        if (OK == (d == OP_VSPACE))\n          {\n          if (codevalue == OP_VSPACE_EXTRA + OP_TYPEPOSSTAR ||\n              codevalue == OP_VSPACE_EXTRA + OP_TYPEPOSQUERY)\n            {\n            active_count--;           /* Remove non-match possibility */\n            next_active_state--;\n            }\n          ADD_NEW_DATA(-(state_offset + (int)count), 0, 0);\n          }\n        }\n      break;\n\n      /*-----------------------------------------------------------------*/\n      case OP_HSPACE_EXTRA + OP_TYPEQUERY:\n      case OP_HSPACE_EXTRA + OP_TYPEMINQUERY:\n      case OP_HSPACE_EXTRA + OP_TYPEPOSQUERY:\n      count = 2;\n      goto QS5;\n\n      case OP_HSPACE_EXTRA + OP_TYPESTAR:\n      case OP_HSPACE_EXTRA + OP_TYPEMINSTAR:\n      case OP_HSPACE_EXTRA + OP_TYPEPOSSTAR:\n      count = 0;\n\n      QS5:\n      ADD_ACTIVE(state_offset + 2, 0);\n      if (clen > 0)\n        {\n        BOOL OK;\n        switch (c)\n          {\n          HSPACE_CASES:\n          OK = TRUE;\n          break;\n\n          default:\n          OK = FALSE;\n          break;\n          }\n\n        if (OK == (d == OP_HSPACE))\n          {\n          if (codevalue == OP_HSPACE_EXTRA + OP_TYPEPOSSTAR ||\n              codevalue == OP_HSPACE_EXTRA + OP_TYPEPOSQUERY)\n            {\n            active_count--;           /* Remove non-match possibility */\n            next_active_state--;\n            }\n          ADD_NEW_DATA(-(state_offset + (int)count), 0, 0);\n          }\n        }\n      break;\n\n      /*-----------------------------------------------------------------*/\n#ifdef SUPPORT_UNICODE\n      case OP_PROP_EXTRA + OP_TYPEEXACT:\n      case OP_PROP_EXTRA + OP_TYPEUPTO:\n      case OP_PROP_EXTRA + OP_TYPEMINUPTO:\n      case OP_PROP_EXTRA + OP_TYPEPOSUPTO:\n      if (codevalue != OP_PROP_EXTRA + OP_TYPEEXACT)\n        { ADD_ACTIVE(state_offset + 1 + IMM2_SIZE + 3, 0); }\n      count = current_state->count;  /* Number already matched */\n      if (clen > 0)\n        {\n        BOOL OK;\n        const uint32_t *cp;\n        const ucd_record * prop = GET_UCD(c);\n        switch(code\u00dd1 + IMM2_SIZE + 1\u00a8)\n          {\n          case PT_ANY:\n          OK = TRUE;\n          break;\n\n          case PT_LAMP:\n          OK = prop->chartype == ucp_Lu || prop->chartype == ucp_Ll ||\n            prop->chartype == ucp_Lt;\n          break;\n\n          case PT_GC:\n          OK = PRIV(ucp_gentype)\u00ddprop->chartype\u00a8 == code\u00dd1 + IMM2_SIZE + 2\u00a8;\n          break;\n\n          case PT_PC:\n          OK = prop->chartype == code\u00dd1 + IMM2_SIZE + 2\u00a8;\n          break;\n\n          case PT_SC:\n          OK = prop->script == code\u00dd1 + IMM2_SIZE + 2\u00a8;\n          break;\n\n          /* These are specials for combination cases. */\n\n          case PT_ALNUM:\n          OK = PRIV(ucp_gentype)\u00ddprop->chartype\u00a8 == ucp_L ||\n               PRIV(ucp_gentype)\u00ddprop->chartype\u00a8 == ucp_N;\n          break;\n\n          /* Perl space used to exclude VT, but from Perl 5.18 it is included,\n          which means that Perl space and POSIX space are now identical. PCRE\n          was changed at release 8.34. */\n\n          case PT_SPACE:    /* Perl space */\n          case PT_PXSPACE:  /* POSIX space */\n          switch(c)\n            {\n            HSPACE_CASES:\n            VSPACE_CASES:\n            OK = TRUE;\n            break;\n\n            default:\n            OK = PRIV(ucp_gentype)\u00ddprop->chartype\u00a8 == ucp_Z;\n            break;\n            }\n          break;\n\n          case PT_WORD:\n          OK = PRIV(ucp_gentype)\u00ddprop->chartype\u00a8 == ucp_L ||\n               PRIV(ucp_gentype)\u00ddprop->chartype\u00a8 == ucp_N ||\n               c == CHAR_UNDERSCORE;\n          break;\n\n          case PT_CLIST:\n          cp = PRIV(ucd_caseless_sets) + code\u00dd1 + IMM2_SIZE + 2\u00a8;\n          for (;;)\n            {\n            if (c < *cp) { OK = FALSE; break; }\n            if (c == *cp++) { OK = TRUE; break; }\n            }\n          break;\n\n          case PT_UCNC:\n          OK = c == CHAR_DOLLAR_SIGN || c == CHAR_COMMERCIAL_AT ||\n               c == CHAR_GRAVE_ACCENT || (c >= 0xa0 && c <= 0xd7ff) ||\n               c >= 0xe000;\n          break;\n\n          /* Should never occur, but keep compilers from grumbling. */\n\n          default:\n          OK = codevalue != OP_PROP;\n          break;\n          }\n\n        if (OK == (d == OP_PROP))\n          {\n          if (codevalue == OP_PROP_EXTRA + OP_TYPEPOSUPTO)\n            {\n            active_count--;           /* Remove non-match possibility */\n            next_active_state--;\n            }\n          if (++count >= (int)GET2(code, 1))\n            { ADD_NEW(state_offset + 1 + IMM2_SIZE + 3, 0); }\n          else\n            { ADD_NEW(state_offset, count); }\n          }\n        }\n      break;\n\n      /*-----------------------------------------------------------------*/\n      case OP_EXTUNI_EXTRA + OP_TYPEEXACT:\n      case OP_EXTUNI_EXTRA + OP_TYPEUPTO:\n      case OP_EXTUNI_EXTRA + OP_TYPEMINUPTO:\n      case OP_EXTUNI_EXTRA + OP_TYPEPOSUPTO:\n      if (codevalue != OP_EXTUNI_EXTRA + OP_TYPEEXACT)\n        { ADD_ACTIVE(state_offset + 2 + IMM2_SIZE, 0); }\n      count = current_state->count;  /* Number already matched */\n      if (clen > 0)\n        {\n        PCRE2_SPTR nptr;\n        int ncount = 0;\n        if (codevalue == OP_EXTUNI_EXTRA + OP_TYPEPOSUPTO)\n          {\n          active_count--;           /* Remove non-match possibility */\n          next_active_state--;\n          }\n        nptr = PRIV(extuni)(c, ptr + clen, mb->start_subject, end_subject, utf,\n          &ncount);\n        if (nptr >= end_subject && (mb->moptions & PCRE2_PARTIAL_HARD) != 0)\n            reset_could_continue = TRUE;\n        if (++count >= (int)GET2(code, 1))\n          { ADD_NEW_DATA(-(state_offset + 2 + IMM2_SIZE), 0, ncount); }\n        else\n          { ADD_NEW_DATA(-state_offset, count, ncount); }\n        }\n      break;\n#endif\n\n      /*-----------------------------------------------------------------*/\n      case OP_ANYNL_EXTRA + OP_TYPEEXACT:\n      case OP_ANYNL_EXTRA + OP_TYPEUPTO:\n      case OP_ANYNL_EXTRA + OP_TYPEMINUPTO:\n      case OP_ANYNL_EXTRA + OP_TYPEPOSUPTO:\n      if (codevalue != OP_ANYNL_EXTRA + OP_TYPEEXACT)\n        { ADD_ACTIVE(state_offset + 2 + IMM2_SIZE, 0); }\n      count = current_state->count;  /* Number already matched */\n      if (clen > 0)\n        {\n        int ncount = 0;\n        switch (c)\n          {\n          case CHAR_VT:\n          case CHAR_FF:\n          case CHAR_NEL:\n#ifndef EBCDIC\n          case 0x2028:\n          case 0x2029:\n#endif  /* Not EBCDIC */\n          if (mb->bsr_convention == PCRE2_BSR_ANYCRLF) break;\n          goto ANYNL03;\n\n          case CHAR_CR:\n          if (ptr + 1 < end_subject && UCHAR21TEST(ptr + 1) == CHAR_LF) ncount = 1;\n          /* Fall through */\n\n          ANYNL03:\n          case CHAR_LF:\n          if (codevalue == OP_ANYNL_EXTRA + OP_TYPEPOSUPTO)\n            {\n            active_count--;           /* Remove non-match possibility */\n            next_active_state--;\n            }\n          if (++count >= (int)GET2(code, 1))\n            { ADD_NEW_DATA(-(state_offset + 2 + IMM2_SIZE), 0, ncount); }\n          else\n            { ADD_NEW_DATA(-state_offset, count, ncount); }\n          break;\n\n          default:\n          break;\n          }\n        }\n      break;\n\n      /*-----------------------------------------------------------------*/\n      case OP_VSPACE_EXTRA + OP_TYPEEXACT:\n      case OP_VSPACE_EXTRA + OP_TYPEUPTO:\n      case OP_VSPACE_EXTRA + OP_TYPEMINUPTO:\n      case OP_VSPACE_EXTRA + OP_TYPEPOSUPTO:\n      if (codevalue != OP_VSPACE_EXTRA + OP_TYPEEXACT)\n        { ADD_ACTIVE(state_offset + 2 + IMM2_SIZE, 0); }\n      count = current_state->count;  /* Number already matched */\n      if (clen > 0)\n        {\n        BOOL OK;\n        switch (c)\n          {\n          VSPACE_CASES:\n          OK = TRUE;\n          break;\n\n          default:\n          OK = FALSE;\n          }\n\n        if (OK == (d == OP_VSPACE))\n          {\n          if (codevalue == OP_VSPACE_EXTRA + OP_TYPEPOSUPTO)\n            {\n            active_count--;           /* Remove non-match possibility */\n            next_active_state--;\n            }\n          if (++count >= (int)GET2(code, 1))\n            { ADD_NEW_DATA(-(state_offset + 2 + IMM2_SIZE), 0, 0); }\n          else\n            { ADD_NEW_DATA(-state_offset, count, 0); }\n          }\n        }\n      break;\n\n      /*-----------------------------------------------------------------*/\n      case OP_HSPACE_EXTRA + OP_TYPEEXACT:\n      case OP_HSPACE_EXTRA + OP_TYPEUPTO:\n      case OP_HSPACE_EXTRA + OP_TYPEMINUPTO:\n      case OP_HSPACE_EXTRA + OP_TYPEPOSUPTO:\n      if (codevalue != OP_HSPACE_EXTRA + OP_TYPEEXACT)\n        { ADD_ACTIVE(state_offset + 2 + IMM2_SIZE, 0); }\n      count = current_state->count;  /* Number already matched */\n      if (clen > 0)\n        {\n        BOOL OK;\n        switch (c)\n          {\n          HSPACE_CASES:\n          OK = TRUE;\n          break;\n\n          default:\n          OK = FALSE;\n          break;\n          }\n\n        if (OK == (d == OP_HSPACE))\n          {\n          if (codevalue == OP_HSPACE_EXTRA + OP_TYPEPOSUPTO)\n            {\n            active_count--;           /* Remove non-match possibility */\n            next_active_state--;\n            }\n          if (++count >= (int)GET2(code, 1))\n            { ADD_NEW_DATA(-(state_offset + 2 + IMM2_SIZE), 0, 0); }\n          else\n            { ADD_NEW_DATA(-state_offset, count, 0); }\n          }\n        }\n      break;\n\n/* ========================================================================== */\n      /* These opcodes are followed by a character that is usually compared\n      to the current subject character; it is loaded into d. We still get\n      here even if there is no subject character, because in some cases zero\n      repetitions are permitted. */\n\n      /*-----------------------------------------------------------------*/\n      case OP_CHAR:\n      if (clen > 0 && c == d) { ADD_NEW(state_offset + dlen + 1, 0); }\n      break;\n\n      /*-----------------------------------------------------------------*/\n      case OP_CHARI:\n      if (clen == 0) break;\n\n#ifdef SUPPORT_UNICODE\n      if (utf_or_ucp)\n        {\n        if (c == d) { ADD_NEW(state_offset + dlen + 1, 0); } else\n          {\n          unsigned int othercase;\n          if (c < 128)\n            othercase = fcc\u00ddc\u00a8;\n          else\n            othercase = UCD_OTHERCASE(c);\n          if (d == othercase) { ADD_NEW(state_offset + dlen + 1, 0); }\n          }\n        }\n      else\n#endif  /* SUPPORT_UNICODE */\n      /* Not UTF or UCP mode */\n        {\n        if (TABLE_GET(c, lcc, c) == TABLE_GET(d, lcc, d))\n          { ADD_NEW(state_offset + 2, 0); }\n        }\n      break;\n\n\n#ifdef SUPPORT_UNICODE\n      /*-----------------------------------------------------------------*/\n      /* This is a tricky one because it can match more than one character.\n      Find out how many characters to skip, and then set up a negative state\n      to wait for them to pass before continuing. */\n\n      case OP_EXTUNI:\n      if (clen > 0)\n        {\n        int ncount = 0;\n        PCRE2_SPTR nptr = PRIV(extuni)(c, ptr + clen, mb->start_subject,\n          end_subject, utf, &ncount);\n        if (nptr >= end_subject && (mb->moptions & PCRE2_PARTIAL_HARD) != 0)\n            reset_could_continue = TRUE;\n        ADD_NEW_DATA(-(state_offset + 1), 0, ncount);\n        }\n      break;\n#endif\n\n      /*-----------------------------------------------------------------*/\n      /* This is a tricky like EXTUNI because it too can match more than one\n      character (when CR is followed by LF). In this case, set up a negative\n      state to wait for one character to pass before continuing. */\n\n      case OP_ANYNL:\n      if (clen > 0) switch(c)\n        {\n        case CHAR_VT:\n        case CHAR_FF:\n        case CHAR_NEL:\n#ifndef EBCDIC\n        case 0x2028:\n        case 0x2029:\n#endif  /* Not EBCDIC */\n        if (mb->bsr_convention == PCRE2_BSR_ANYCRLF) break;\n        /* Fall through */\n\n        case CHAR_LF:\n        ADD_NEW(state_offset + 1, 0);\n        break;\n\n        case CHAR_CR:\n        if (ptr + 1 >= end_subject)\n          {\n          ADD_NEW(state_offset + 1, 0);\n          if ((mb->moptions & PCRE2_PARTIAL_HARD) != 0)\n            reset_could_continue = TRUE;\n          }\n        else if (UCHAR21TEST(ptr + 1) == CHAR_LF)\n          {\n          ADD_NEW_DATA(-(state_offset + 1), 0, 1);\n          }\n        else\n          {\n          ADD_NEW(state_offset + 1, 0);\n          }\n        break;\n        }\n      break;\n\n      /*-----------------------------------------------------------------*/\n      case OP_NOT_VSPACE:\n      if (clen > 0) switch(c)\n        {\n        VSPACE_CASES:\n        break;\n\n        default:\n        ADD_NEW(state_offset + 1, 0);\n        break;\n        }\n      break;\n\n      /*-----------------------------------------------------------------*/\n      case OP_VSPACE:\n      if (clen > 0) switch(c)\n        {\n        VSPACE_CASES:\n        ADD_NEW(state_offset + 1, 0);\n        break;\n\n        default:\n        break;\n        }\n      break;\n\n      /*-----------------------------------------------------------------*/\n      case OP_NOT_HSPACE:\n      if (clen > 0) switch(c)\n        {\n        HSPACE_CASES:\n        break;\n\n        default:\n        ADD_NEW(state_offset + 1, 0);\n        break;\n        }\n      break;\n\n      /*-----------------------------------------------------------------*/\n      case OP_HSPACE:\n      if (clen > 0) switch(c)\n        {\n        HSPACE_CASES:\n        ADD_NEW(state_offset + 1, 0);\n        break;\n\n        default:\n        break;\n        }\n      break;\n\n      /*-----------------------------------------------------------------*/\n      /* Match a negated single character casefully. */\n\n      case OP_NOT:\n      if (clen > 0 && c != d) { ADD_NEW(state_offset + dlen + 1, 0); }\n      break;\n\n      /*-----------------------------------------------------------------*/\n      /* Match a negated single character caselessly. */\n\n      case OP_NOTI:\n      if (clen > 0)\n        {\n        uint32_t otherd;\n#ifdef SUPPORT_UNICODE\n        if (utf_or_ucp && d >= 128)\n          otherd = UCD_OTHERCASE(d);\n        else\n#endif  /* SUPPORT_UNICODE */\n        otherd = TABLE_GET(d, fcc, d);\n        if (c != d && c != otherd)\n          { ADD_NEW(state_offset + dlen + 1, 0); }\n        }\n      break;\n\n      /*-----------------------------------------------------------------*/\n      case OP_PLUSI:\n      case OP_MINPLUSI:\n      case OP_POSPLUSI:\n      case OP_NOTPLUSI:\n      case OP_NOTMINPLUSI:\n      case OP_NOTPOSPLUSI:\n      caseless = TRUE;\n      codevalue -= OP_STARI - OP_STAR;\n\n      /* Fall through */\n      case OP_PLUS:\n      case OP_MINPLUS:\n      case OP_POSPLUS:\n      case OP_NOTPLUS:\n      case OP_NOTMINPLUS:\n      case OP_NOTPOSPLUS:\n      count = current_state->count;  /* Already matched */\n      if (count > 0) { ADD_ACTIVE(state_offset + dlen + 1, 0); }\n      if (clen > 0)\n        {\n        uint32_t otherd = NOTACHAR;\n        if (caseless)\n          {\n#ifdef SUPPORT_UNICODE\n          if (utf_or_ucp && d >= 128)\n            otherd = UCD_OTHERCASE(d);\n          else\n#endif  /* SUPPORT_UNICODE */\n          otherd = TABLE_GET(d, fcc, d);\n          }\n        if ((c == d || c == otherd) == (codevalue < OP_NOTSTAR))\n          {\n          if (count > 0 &&\n              (codevalue == OP_POSPLUS || codevalue == OP_NOTPOSPLUS))\n            {\n            active_count--;             /* Remove non-match possibility */\n            next_active_state--;\n            }\n          count++;\n          ADD_NEW(state_offset, count);\n          }\n        }\n      break;\n\n      /*-----------------------------------------------------------------*/\n      case OP_QUERYI:\n      case OP_MINQUERYI:\n      case OP_POSQUERYI:\n      case OP_NOTQUERYI:\n      case OP_NOTMINQUERYI:\n      case OP_NOTPOSQUERYI:\n      caseless = TRUE;\n      codevalue -= OP_STARI - OP_STAR;\n      /* Fall through */\n      case OP_QUERY:\n      case OP_MINQUERY:\n      case OP_POSQUERY:\n      case OP_NOTQUERY:\n      case OP_NOTMINQUERY:\n      case OP_NOTPOSQUERY:\n      ADD_ACTIVE(state_offset + dlen + 1, 0);\n      if (clen > 0)\n        {\n        uint32_t otherd = NOTACHAR;\n        if (caseless)\n          {\n#ifdef SUPPORT_UNICODE\n          if (utf_or_ucp && d >= 128)\n            otherd = UCD_OTHERCASE(d);\n          else\n#endif  /* SUPPORT_UNICODE */\n          otherd = TABLE_GET(d, fcc, d);\n          }\n        if ((c == d || c == otherd) == (codevalue < OP_NOTSTAR))\n          {\n          if (codevalue == OP_POSQUERY || codevalue == OP_NOTPOSQUERY)\n            {\n            active_count--;            /* Remove non-match possibility */\n            next_active_state--;\n            }\n          ADD_NEW(state_offset + dlen + 1, 0);\n          }\n        }\n      break;\n\n      /*-----------------------------------------------------------------*/\n      case OP_STARI:\n      case OP_MINSTARI:\n      case OP_POSSTARI:\n      case OP_NOTSTARI:\n      case OP_NOTMINSTARI:\n      case OP_NOTPOSSTARI:\n      caseless = TRUE;\n      codevalue -= OP_STARI - OP_STAR;\n      /* Fall through */\n      case OP_STAR:\n      case OP_MINSTAR:\n      case OP_POSSTAR:\n      case OP_NOTSTAR:\n      case OP_NOTMINSTAR:\n      case OP_NOTPOSSTAR:\n      ADD_ACTIVE(state_offset + dlen + 1, 0);\n      if (clen > 0)\n        {\n        uint32_t otherd = NOTACHAR;\n        if (caseless)\n          {\n#ifdef SUPPORT_UNICODE\n          if (utf_or_ucp && d >= 128)\n            otherd = UCD_OTHERCASE(d);\n          else\n#endif  /* SUPPORT_UNICODE */\n          otherd = TABLE_GET(d, fcc, d);\n          }\n        if ((c == d || c == otherd) == (codevalue < OP_NOTSTAR))\n          {\n          if (codevalue == OP_POSSTAR || codevalue == OP_NOTPOSSTAR)\n            {\n            active_count--;            /* Remove non-match possibility */\n            next_active_state--;\n            }\n          ADD_NEW(state_offset, 0);\n          }\n        }\n      break;\n\n      /*-----------------------------------------------------------------*/\n      case OP_EXACTI:\n      case OP_NOTEXACTI:\n      caseless = TRUE;\n      codevalue -= OP_STARI - OP_STAR;\n      /* Fall through */\n      case OP_EXACT:\n      case OP_NOTEXACT:\n      count = current_state->count;  /* Number already matched */\n      if (clen > 0)\n        {\n        uint32_t otherd = NOTACHAR;\n        if (caseless)\n          {\n#ifdef SUPPORT_UNICODE\n          if (utf_or_ucp && d >= 128)\n            otherd = UCD_OTHERCASE(d);\n          else\n#endif  /* SUPPORT_UNICODE */\n          otherd = TABLE_GET(d, fcc, d);\n          }\n        if ((c == d || c == otherd) == (codevalue < OP_NOTSTAR))\n          {\n          if (++count >= (int)GET2(code, 1))\n            { ADD_NEW(state_offset + dlen + 1 + IMM2_SIZE, 0); }\n          else\n            { ADD_NEW(state_offset, count); }\n          }\n        }\n      break;\n\n      /*-----------------------------------------------------------------*/\n      case OP_UPTOI:\n      case OP_MINUPTOI:\n      case OP_POSUPTOI:\n      case OP_NOTUPTOI:\n      case OP_NOTMINUPTOI:\n      case OP_NOTPOSUPTOI:\n      caseless = TRUE;\n      codevalue -= OP_STARI - OP_STAR;\n      /* Fall through */\n      case OP_UPTO:\n      case OP_MINUPTO:\n      case OP_POSUPTO:\n      case OP_NOTUPTO:\n      case OP_NOTMINUPTO:\n      case OP_NOTPOSUPTO:\n      ADD_ACTIVE(state_offset + dlen + 1 + IMM2_SIZE, 0);\n      count = current_state->count;  /* Number already matched */\n      if (clen > 0)\n        {\n        uint32_t otherd = NOTACHAR;\n        if (caseless)\n          {\n#ifdef SUPPORT_UNICODE\n          if (utf_or_ucp && d >= 128)\n            otherd = UCD_OTHERCASE(d);\n          else\n#endif  /* SUPPORT_UNICODE */\n          otherd = TABLE_GET(d, fcc, d);\n          }\n        if ((c == d || c == otherd) == (codevalue < OP_NOTSTAR))\n          {\n          if (codevalue == OP_POSUPTO || codevalue == OP_NOTPOSUPTO)\n            {\n            active_count--;             /* Remove non-match possibility */\n            next_active_state--;\n            }\n          if (++count >= (int)GET2(code, 1))\n            { ADD_NEW(state_offset + dlen + 1 + IMM2_SIZE, 0); }\n          else\n            { ADD_NEW(state_offset, count); }\n          }\n        }\n      break;\n\n\n/* ========================================================================== */\n      /* These are the class-handling opcodes */\n\n      case OP_CLASS:\n      case OP_NCLASS:\n      case OP_XCLASS:\n        {\n        BOOL isinclass = FALSE;\n        int next_state_offset;\n        PCRE2_SPTR ecode;\n\n        /* For a simple class, there is always just a 32-byte table, and we\n        can set isinclass from it. */\n\n        if (codevalue != OP_XCLASS)\n          {\n          ecode = code + 1 + (32 / sizeof(PCRE2_UCHAR));\n          if (clen > 0)\n            {\n            isinclass = (c > 255)? (codevalue == OP_NCLASS) :\n              ((((uint8_t *)(code + 1))\u00ddc/8\u00a8 & (1u << (c&7))) != 0);\n            }\n          }\n\n        /* An extended class may have a table or a list of single characters,\n        ranges, or both, and it may be positive or negative. There's a\n        function that sorts all this out. */\n\n        else\n         {\n         ecode = code + GET(code, 1);\n         if (clen > 0) isinclass = PRIV(xclass)(c, code + 1 + LINK_SIZE, utf);\n         }\n\n        /* At this point, isinclass is set for all kinds of class, and ecode\n        points to the byte after the end of the class. If there is a\n        quantifier, this is where it will be. */\n\n        next_state_offset = (int)(ecode - start_code);\n\n        switch (*ecode)\n          {\n          case OP_CRSTAR:\n          case OP_CRMINSTAR:\n          case OP_CRPOSSTAR:\n          ADD_ACTIVE(next_state_offset + 1, 0);\n          if (isinclass)\n            {\n            if (*ecode == OP_CRPOSSTAR)\n              {\n              active_count--;           /* Remove non-match possibility */\n              next_active_state--;\n              }\n            ADD_NEW(state_offset, 0);\n            }\n          break;\n\n          case OP_CRPLUS:\n          case OP_CRMINPLUS:\n          case OP_CRPOSPLUS:\n          count = current_state->count;  /* Already matched */\n          if (count > 0) { ADD_ACTIVE(next_state_offset + 1, 0); }\n          if (isinclass)\n            {\n            if (count > 0 && *ecode == OP_CRPOSPLUS)\n              {\n              active_count--;           /* Remove non-match possibility */\n              next_active_state--;\n              }\n            count++;\n            ADD_NEW(state_offset, count);\n            }\n          break;\n\n          case OP_CRQUERY:\n          case OP_CRMINQUERY:\n          case OP_CRPOSQUERY:\n          ADD_ACTIVE(next_state_offset + 1, 0);\n          if (isinclass)\n            {\n            if (*ecode == OP_CRPOSQUERY)\n              {\n              active_count--;           /* Remove non-match possibility */\n              next_active_state--;\n              }\n            ADD_NEW(next_state_offset + 1, 0);\n            }\n          break;\n\n          case OP_CRRANGE:\n          case OP_CRMINRANGE:\n          case OP_CRPOSRANGE:\n          count = current_state->count;  /* Already matched */\n          if (count >= (int)GET2(ecode, 1))\n            { ADD_ACTIVE(next_state_offset + 1 + 2 * IMM2_SIZE, 0); }\n          if (isinclass)\n            {\n            int max = (int)GET2(ecode, 1 + IMM2_SIZE);\n\n            if (*ecode == OP_CRPOSRANGE && count >= (int)GET2(ecode, 1))\n              {\n              active_count--;           /* Remove non-match possibility */\n              next_active_state--;\n              }\n\n            if (++count >= max && max != 0)   /* Max 0 => no limit */\n              { ADD_NEW(next_state_offset + 1 + 2 * IMM2_SIZE, 0); }\n            else\n              { ADD_NEW(state_offset, count); }\n            }\n          break;\n\n          default:\n          if (isinclass) { ADD_NEW(next_state_offset, 0); }\n          break;\n          }\n        }\n      break;\n\n/* ========================================================================== */\n      /* These are the opcodes for fancy brackets of various kinds. We have\n      to use recursion in order to handle them. The \"always failing\" assertion\n      (?!) is optimised to OP_FAIL when compiling, so we have to support that,\n      though the other \"backtracking verbs\" are not supported. */\n\n      case OP_FAIL:\n      forced_fail++;    /* Count FAILs for multiple states */\n      break;\n\n      case OP_ASSERT:\n      case OP_ASSERT_NOT:\n      case OP_ASSERTBACK:\n      case OP_ASSERTBACK_NOT:\n        {\n        int rc;\n        int *local_workspace;\n        PCRE2_SIZE *local_offsets;\n        PCRE2_SPTR endasscode = code + GET(code, 1);\n        RWS_anchor *rws = (RWS_anchor *)RWS;\n\n        if (rws->free < RWS_RSIZE + RWS_OVEC_OSIZE)\n          {\n          rc = more_workspace(&rws, RWS_OVEC_OSIZE, mb);\n          if (rc != 0) return rc;\n          RWS = (int *)rws;\n          }\n\n        local_offsets = (PCRE2_SIZE *)(RWS + rws->size - rws->free);\n        local_workspace = ((int *)local_offsets) + RWS_OVEC_OSIZE;\n        rws->free -= RWS_RSIZE + RWS_OVEC_OSIZE;\n\n        while (*endasscode == OP_ALT) endasscode += GET(endasscode, 1);\n\n        rc = internal_dfa_match(\n          mb,                                   /* static match data */\n          code,                                 /* this subexpression's code */\n          ptr,                                  /* where we currently are */\n          (PCRE2_SIZE)(ptr - start_subject),    /* start offset */\n          local_offsets,                        /* offset vector */\n          RWS_OVEC_OSIZE/OVEC_UNIT,             /* size of same */\n          local_workspace,                      /* workspace vector */\n          RWS_RSIZE,                            /* size of same */\n          rlevel,                               /* function recursion level */\n          RWS);                                 /* recursion workspace */\n\n        rws->free += RWS_RSIZE + RWS_OVEC_OSIZE;\n\n        if (rc < 0 && rc != PCRE2_ERROR_NOMATCH) return rc;\n        if ((rc >= 0) == (codevalue == OP_ASSERT || codevalue == OP_ASSERTBACK))\n            { ADD_ACTIVE((int)(endasscode + LINK_SIZE + 1 - start_code), 0); }\n        }\n      break;\n\n      /*-----------------------------------------------------------------*/\n      case OP_COND:\n      case OP_SCOND:\n        {\n        int codelink = (int)GET(code, 1);\n        PCRE2_UCHAR condcode;\n\n        /* Because of the way auto-callout works during compile, a callout item\n        is inserted between OP_COND and an assertion condition. This does not\n        happen for the other conditions. */\n\n        if (code\u00ddLINK_SIZE + 1\u00a8 == OP_CALLOUT\n            || code\u00ddLINK_SIZE + 1\u00a8 == OP_CALLOUT_STR)\n          {\n          PCRE2_SIZE callout_length;\n          rrc = do_callout(code, offsets, current_subject, ptr, mb,\n            1 + LINK_SIZE, &callout_length);\n          if (rrc < 0) return rrc;                 /* Abandon */\n          if (rrc > 0) break;                      /* Fail this thread */\n          code += callout_length;                  /* Skip callout data */\n          }\n\n        condcode = code\u00ddLINK_SIZE+1\u00a8;\n\n        /* Back reference conditions and duplicate named recursion conditions\n        are not supported */\n\n        if (condcode == OP_CREF || condcode == OP_DNCREF ||\n            condcode == OP_DNRREF)\n          return PCRE2_ERROR_DFA_UCOND;\n\n        /* The DEFINE condition is always false, and the assertion (?!) is\n        converted to OP_FAIL. */\n\n        if (condcode == OP_FALSE || condcode == OP_FAIL)\n          { ADD_ACTIVE(state_offset + codelink + LINK_SIZE + 1, 0); }\n\n        /* There is also an always-true condition */\n\n        else if (condcode == OP_TRUE)\n          { ADD_ACTIVE(state_offset + LINK_SIZE + 2, 0); }\n\n        /* The only supported version of OP_RREF is for the value RREF_ANY,\n        which means \"test if in any recursion\". We can't test for specifically\n        recursed groups. */\n\n        else if (condcode == OP_RREF)\n          {\n          unsigned int value = GET2(code, LINK_SIZE + 2);\n          if (value != RREF_ANY) return PCRE2_ERROR_DFA_UCOND;\n          if (mb->recursive != NULL)\n            { ADD_ACTIVE(state_offset + LINK_SIZE + 2 + IMM2_SIZE, 0); }\n          else { ADD_ACTIVE(state_offset + codelink + LINK_SIZE + 1, 0); }\n          }\n\n        /* Otherwise, the condition is an assertion */\n\n        else\n          {\n          int rc;\n          int *local_workspace;\n          PCRE2_SIZE *local_offsets;\n          PCRE2_SPTR asscode = code + LINK_SIZE + 1;\n          PCRE2_SPTR endasscode = asscode + GET(asscode, 1);\n          RWS_anchor *rws = (RWS_anchor *)RWS;\n\n          if (rws->free < RWS_RSIZE + RWS_OVEC_OSIZE)\n            {\n            rc = more_workspace(&rws, RWS_OVEC_OSIZE, mb);\n            if (rc != 0) return rc;\n            RWS = (int *)rws;\n            }\n\n          local_offsets = (PCRE2_SIZE *)(RWS + rws->size - rws->free);\n          local_workspace = ((int *)local_offsets) + RWS_OVEC_OSIZE;\n          rws->free -= RWS_RSIZE + RWS_OVEC_OSIZE;\n\n          while (*endasscode == OP_ALT) endasscode += GET(endasscode, 1);\n\n          rc = internal_dfa_match(\n            mb,                                   /* fixed match data */\n            asscode,                              /* this subexpression's code */\n            ptr,                                  /* where we currently are */\n            (PCRE2_SIZE)(ptr - start_subject),    /* start offset */\n            local_offsets,                        /* offset vector */\n            RWS_OVEC_OSIZE/OVEC_UNIT,             /* size of same */\n            local_workspace,                      /* workspace vector */\n            RWS_RSIZE,                            /* size of same */\n            rlevel,                               /* function recursion level */\n            RWS);                                 /* recursion workspace */\n\n          rws->free += RWS_RSIZE + RWS_OVEC_OSIZE;\n\n          if (rc < 0 && rc != PCRE2_ERROR_NOMATCH) return rc;\n          if ((rc >= 0) ==\n                (condcode == OP_ASSERT || condcode == OP_ASSERTBACK))\n            { ADD_ACTIVE((int)(endasscode + LINK_SIZE + 1 - start_code), 0); }\n          else\n            { ADD_ACTIVE(state_offset + codelink + LINK_SIZE + 1, 0); }\n          }\n        }\n      break;\n\n      /*-----------------------------------------------------------------*/\n      case OP_RECURSE:\n        {\n        int rc;\n        int *local_workspace;\n        PCRE2_SIZE *local_offsets;\n        RWS_anchor *rws = (RWS_anchor *)RWS;\n        dfa_recursion_info *ri;\n        PCRE2_SPTR callpat = start_code + GET(code, 1);\n        uint32_t recno = (callpat == mb->start_code)? 0 :\n          GET2(callpat, 1 + LINK_SIZE);\n\n        if (rws->free < RWS_RSIZE + RWS_OVEC_RSIZE)\n          {\n          rc = more_workspace(&rws, RWS_OVEC_RSIZE, mb);\n          if (rc != 0) return rc;\n          RWS = (int *)rws;\n          }\n\n        local_offsets = (PCRE2_SIZE *)(RWS + rws->size - rws->free);\n        local_workspace = ((int *)local_offsets) + RWS_OVEC_RSIZE;\n        rws->free -= RWS_RSIZE + RWS_OVEC_RSIZE;\n\n        /* Check for repeating a recursion without advancing the subject\n        pointer. This should catch convoluted mutual recursions. (Some simple\n        cases are caught at compile time.) */\n\n        for (ri = mb->recursive; ri != NULL; ri = ri->prevrec)\n          if (recno == ri->group_num && ptr == ri->subject_position)\n            return PCRE2_ERROR_RECURSELOOP;\n\n        /* Remember this recursion and where we started it so as to\n        catch infinite loops. */\n\n        new_recursive.group_num = recno;\n        new_recursive.subject_position = ptr;\n        new_recursive.prevrec = mb->recursive;\n        mb->recursive = &new_recursive;\n\n        rc = internal_dfa_match(\n          mb,                                   /* fixed match data */\n          callpat,                              /* this subexpression's code */\n          ptr,                                  /* where we currently are */\n          (PCRE2_SIZE)(ptr - start_subject),    /* start offset */\n          local_offsets,                        /* offset vector */\n          RWS_OVEC_RSIZE/OVEC_UNIT,             /* size of same */\n          local_workspace,                      /* workspace vector */\n          RWS_RSIZE,                            /* size of same */\n          rlevel,                               /* function recursion level */\n          RWS);                                 /* recursion workspace */\n\n        rws->free += RWS_RSIZE + RWS_OVEC_RSIZE;\n        mb->recursive = new_recursive.prevrec;  /* Done this recursion */\n\n        /* Ran out of internal offsets */\n\n        if (rc == 0) return PCRE2_ERROR_DFA_RECURSE;\n\n        /* For each successful matched substring, set up the next state with a\n        count of characters to skip before trying it. Note that the count is in\n        characters, not bytes. */\n\n        if (rc > 0)\n          {\n          for (rc = rc*2 - 2; rc >= 0; rc -= 2)\n            {\n            PCRE2_SIZE charcount = local_offsets\u00ddrc+1\u00a8 - local_offsets\u00ddrc\u00a8;\n#if defined SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH != 32\n            if (utf)\n              {\n              PCRE2_SPTR p = start_subject + local_offsets\u00ddrc\u00a8;\n              PCRE2_SPTR pp = start_subject + local_offsets\u00ddrc+1\u00a8;\n              while (p < pp) if (NOT_FIRSTCU(*p++)) charcount--;\n              }\n#endif\n            if (charcount > 0)\n              {\n              ADD_NEW_DATA(-(state_offset + LINK_SIZE + 1), 0,\n                (int)(charcount - 1));\n              }\n            else\n              {\n              ADD_ACTIVE(state_offset + LINK_SIZE + 1, 0);\n              }\n            }\n          }\n        else if (rc != PCRE2_ERROR_NOMATCH) return rc;\n        }\n      break;\n\n      /*-----------------------------------------------------------------*/\n      case OP_BRAPOS:\n      case OP_SBRAPOS:\n      case OP_CBRAPOS:\n      case OP_SCBRAPOS:\n      case OP_BRAPOSZERO:\n        {\n        int rc;\n        int *local_workspace;\n        PCRE2_SIZE *local_offsets;\n        PCRE2_SIZE charcount, matched_count;\n        PCRE2_SPTR local_ptr = ptr;\n        RWS_anchor *rws = (RWS_anchor *)RWS;\n        BOOL allow_zero;\n\n        if (rws->free < RWS_RSIZE + RWS_OVEC_OSIZE)\n          {\n          rc = more_workspace(&rws, RWS_OVEC_OSIZE, mb);\n          if (rc != 0) return rc;\n          RWS = (int *)rws;\n          }\n\n        local_offsets = (PCRE2_SIZE *)(RWS + rws->size - rws->free);\n        local_workspace = ((int *)local_offsets) + RWS_OVEC_OSIZE;\n        rws->free -= RWS_RSIZE + RWS_OVEC_OSIZE;\n\n        if (codevalue == OP_BRAPOSZERO)\n          {\n          allow_zero = TRUE;\n          codevalue = *(++code);  /* Codevalue will be one of above BRAs */\n          }\n        else allow_zero = FALSE;\n\n        /* Loop to match the subpattern as many times as possible as if it were\n        a complete pattern. */\n\n        for (matched_count = 0;; matched_count++)\n          {\n          rc = internal_dfa_match(\n            mb,                                   /* fixed match data */\n            code,                                 /* this subexpression's code */\n            local_ptr,                            /* where we currently are */\n            (PCRE2_SIZE)(ptr - start_subject),    /* start offset */\n            local_offsets,                        /* offset vector */\n            RWS_OVEC_OSIZE/OVEC_UNIT,             /* size of same */\n            local_workspace,                      /* workspace vector */\n            RWS_RSIZE,                            /* size of same */\n            rlevel,                               /* function recursion level */\n            RWS);                                 /* recursion workspace */\n\n          /* Failed to match */\n\n          if (rc < 0)\n            {\n            if (rc != PCRE2_ERROR_NOMATCH) return rc;\n            break;\n            }\n\n          /* Matched: break the loop if zero characters matched. */\n\n          charcount = local_offsets\u00dd1\u00a8 - local_offsets\u00dd0\u00a8;\n          if (charcount == 0) break;\n          local_ptr += charcount;    /* Advance temporary position ptr */\n          }\n\n        rws->free += RWS_RSIZE + RWS_OVEC_OSIZE;\n\n        /* At this point we have matched the subpattern matched_count\n        times, and local_ptr is pointing to the character after the end of the\n        last match. */\n\n        if (matched_count > 0 || allow_zero)\n          {\n          PCRE2_SPTR end_subpattern = code;\n          int next_state_offset;\n\n          do { end_subpattern += GET(end_subpattern, 1); }\n            while (*end_subpattern == OP_ALT);\n          next_state_offset =\n            (int)(end_subpattern - start_code + LINK_SIZE + 1);\n\n          /* Optimization: if there are no more active states, and there\n          are no new states yet set up, then skip over the subject string\n          right here, to save looping. Otherwise, set up the new state to swing\n          into action when the end of the matched substring is reached. */\n\n          if (i + 1 >= active_count && new_count == 0)\n            {\n            ptr = local_ptr;\n            clen = 0;\n            ADD_NEW(next_state_offset, 0);\n            }\n          else\n            {\n            PCRE2_SPTR p = ptr;\n            PCRE2_SPTR pp = local_ptr;\n            charcount = (PCRE2_SIZE)(pp - p);\n#if defined SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH != 32\n            if (utf) while (p < pp) if (NOT_FIRSTCU(*p++)) charcount--;\n#endif\n            ADD_NEW_DATA(-next_state_offset, 0, (int)(charcount - 1));\n            }\n          }\n        }\n      break;\n\n      /*-----------------------------------------------------------------*/\n      case OP_ONCE:\n        {\n        int rc;\n        int *local_workspace;\n        PCRE2_SIZE *local_offsets;\n        RWS_anchor *rws = (RWS_anchor *)RWS;\n\n        if (rws->free < RWS_RSIZE + RWS_OVEC_OSIZE)\n          {\n          rc = more_workspace(&rws, RWS_OVEC_OSIZE, mb);\n          if (rc != 0) return rc;\n          RWS = (int *)rws;\n          }\n\n        local_offsets = (PCRE2_SIZE *)(RWS + rws->size - rws->free);\n        local_workspace = ((int *)local_offsets) + RWS_OVEC_OSIZE;\n        rws->free -= RWS_RSIZE + RWS_OVEC_OSIZE;\n\n        rc = internal_dfa_match(\n          mb,                                   /* fixed match data */\n          code,                                 /* this subexpression's code */\n          ptr,                                  /* where we currently are */\n          (PCRE2_SIZE)(ptr - start_subject),    /* start offset */\n          local_offsets,                        /* offset vector */\n          RWS_OVEC_OSIZE/OVEC_UNIT,             /* size of same */\n          local_workspace,                      /* workspace vector */\n          RWS_RSIZE,                            /* size of same */\n          rlevel,                               /* function recursion level */\n          RWS);                                 /* recursion workspace */\n\n        rws->free += RWS_RSIZE + RWS_OVEC_OSIZE;\n\n        if (rc >= 0)\n          {\n          PCRE2_SPTR end_subpattern = code;\n          PCRE2_SIZE charcount = local_offsets\u00dd1\u00a8 - local_offsets\u00dd0\u00a8;\n          int next_state_offset, repeat_state_offset;\n\n          do { end_subpattern += GET(end_subpattern, 1); }\n            while (*end_subpattern == OP_ALT);\n          next_state_offset =\n            (int)(end_subpattern - start_code + LINK_SIZE + 1);\n\n          /* If the end of this subpattern is KETRMAX or KETRMIN, we must\n          arrange for the repeat state also to be added to the relevant list.\n          Calculate the offset, or set -1 for no repeat. */\n\n          repeat_state_offset = (*end_subpattern == OP_KETRMAX ||\n                                 *end_subpattern == OP_KETRMIN)?\n            (int)(end_subpattern - start_code - GET(end_subpattern, 1)) : -1;\n\n          /* If we have matched an empty string, add the next state at the\n          current character pointer. This is important so that the duplicate\n          checking kicks in, which is what breaks infinite loops that match an\n          empty string. */\n\n          if (charcount == 0)\n            {\n            ADD_ACTIVE(next_state_offset, 0);\n            }\n\n          /* Optimization: if there are no more active states, and there\n          are no new states yet set up, then skip over the subject string\n          right here, to save looping. Otherwise, set up the new state to swing\n          into action when the end of the matched substring is reached. */\n\n          else if (i + 1 >= active_count && new_count == 0)\n            {\n            ptr += charcount;\n            clen = 0;\n            ADD_NEW(next_state_offset, 0);\n\n            /* If we are adding a repeat state at the new character position,\n            we must fudge things so that it is the only current state.\n            Otherwise, it might be a duplicate of one we processed before, and\n            that would cause it to be skipped. */\n\n            if (repeat_state_offset >= 0)\n              {\n              next_active_state = active_states;\n              active_count = 0;\n              i = -1;\n              ADD_ACTIVE(repeat_state_offset, 0);\n              }\n            }\n          else\n            {\n#if defined SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH != 32\n            if (utf)\n              {\n              PCRE2_SPTR p = start_subject + local_offsets\u00dd0\u00a8;\n              PCRE2_SPTR pp = start_subject + local_offsets\u00dd1\u00a8;\n              while (p < pp) if (NOT_FIRSTCU(*p++)) charcount--;\n              }\n#endif\n            ADD_NEW_DATA(-next_state_offset, 0, (int)(charcount - 1));\n            if (repeat_state_offset >= 0)\n              { ADD_NEW_DATA(-repeat_state_offset, 0, (int)(charcount - 1)); }\n            }\n          }\n        else if (rc != PCRE2_ERROR_NOMATCH) return rc;\n        }\n      break;\n\n\n/* ========================================================================== */\n      /* Handle callouts */\n\n      case OP_CALLOUT:\n      case OP_CALLOUT_STR:\n        {\n        PCRE2_SIZE callout_length;\n        rrc = do_callout(code, offsets, current_subject, ptr, mb, 0,\n          &callout_length);\n        if (rrc < 0) return rrc;   /* Abandon */\n        if (rrc == 0)\n          { ADD_ACTIVE(state_offset + (int)callout_length, 0); }\n        }\n      break;\n\n\n/* ========================================================================== */\n      default:        /* Unsupported opcode */\n      return PCRE2_ERROR_DFA_UITEM;\n      }\n\n    NEXT_ACTIVE_STATE: continue;\n\n    }      /* End of loop scanning active states */\n\n  /* We have finished the processing at the current subject character. If no\n  new states have been set for the next character, we have found all the\n  matches that we are going to find. If partial matching has been requested,\n  check for appropriate conditions.\n\n  The \"forced_ fail\" variable counts the number of (*F) encountered for the\n  character. If it is equal to the original active_count (saved in\n  workspace\u00dd1\u00a8) it means that (*F) was found on every active state. In this\n  case we don't want to give a partial match.\n\n  The \"could_continue\" variable is true if a state could have continued but\n  for the fact that the end of the subject was reached. */\n\n  if (new_count <= 0)\n    {\n    if (could_continue &&                            /* Some could go on, and */\n        forced_fail != workspace\u00dd1\u00a8 &&               /* Not all forced fail & */\n        (                                            /* either... */\n        (mb->moptions & PCRE2_PARTIAL_HARD) != 0      /* Hard partial */\n        ||                                           /* or... */\n        ((mb->moptions & PCRE2_PARTIAL_SOFT) != 0 &&  /* Soft partial and */\n         match_count < 0)                             /* no matches */\n        ) &&                                         /* And... */\n        (\n        partial_newline ||                   /* Either partial NL */\n          (                                  /* or ... */\n          ptr >= end_subject &&              /* End of subject and */\n            (                                  /* either */\n            ptr > mb->start_used_ptr ||        /* Inspected non-empty string */\n            mb->allowemptypartial              /* or pattern has lookbehind */\n            )                                  /* or could match empty */\n          )\n        ))\n      match_count = PCRE2_ERROR_PARTIAL;\n    break;  /* Exit from loop along the subject string */\n    }\n\n  /* One or more states are active for the next character. */\n\n  ptr += clen;    /* Advance to next subject character */\n  }               /* Loop to move along the subject string */\n\n/* Control gets here from \"break\" a few lines above. If we have a match and\nPCRE2_ENDANCHORED is set, the match fails. */\n\nif (match_count >= 0 &&\n    ((mb->moptions | mb->poptions) & PCRE2_ENDANCHORED) != 0 &&\n    ptr < end_subject)\n  match_count = PCRE2_ERROR_NOMATCH;\n\nreturn match_count;\n}\n\n\n\n/*************************************************\n*     Match a pattern using the DFA algorithm    *\n*************************************************/\n\n/* This function matches a compiled pattern to a subject string, using the\nalternate matching algorithm that finds all matches at once.\n\nArguments:\n  code          points to the compiled pattern\n  subject       subject string\n  length        length of subject string\n  startoffset   where to start matching in the subject\n  options       option bits\n  match_data    points to a match data structure\n  gcontext      points to a match context\n  workspace     pointer to workspace\n  wscount       size of workspace\n\nReturns:        > 0 => number of match offset pairs placed in offsets\n                = 0 => offsets overflowed; longest matches are present\n                 -1 => failed to match\n               < -1 => some kind of unexpected problem\n*/\n\nPCRE2_EXP_DEFN int PCRE2_CALL_CONVENTION\npcre2_dfa_match(const pcre2_code *code, PCRE2_SPTR subject, PCRE2_SIZE length,\n  PCRE2_SIZE start_offset, uint32_t options, pcre2_match_data *match_data,\n  pcre2_match_context *mcontext, int *workspace, PCRE2_SIZE wscount)\n{\nint rc;\nint was_zero_terminated = 0;\n\nconst pcre2_real_code *re = (const pcre2_real_code *)code;\n\nPCRE2_SPTR start_match;\nPCRE2_SPTR end_subject;\nPCRE2_SPTR bumpalong_limit;\nPCRE2_SPTR req_cu_ptr;\n\nBOOL utf, anchored, startline, firstline;\nBOOL has_first_cu = FALSE;\nBOOL has_req_cu = FALSE;\n\n#if PCRE2_CODE_UNIT_WIDTH == 8\nBOOL memchr_not_found_first_cu = FALSE;\nBOOL memchr_not_found_first_cu2 = FALSE;\n#endif\n\nPCRE2_UCHAR first_cu = 0;\nPCRE2_UCHAR first_cu2 = 0;\nPCRE2_UCHAR req_cu = 0;\nPCRE2_UCHAR req_cu2 = 0;\n\nconst uint8_t *start_bits = NULL;\n\n/* We need to have mb pointing to a match block, because the IS_NEWLINE macro\nis used below, and it expects NLBLOCK to be defined as a pointer. */\n\npcre2_callout_block cb;\ndfa_match_block actual_match_block;\ndfa_match_block *mb = &actual_match_block;\n\n/* Set up a starting block of memory for use during recursive calls to\ninternal_dfa_match(). By putting this on the stack, it minimizes resource use\nin the case when it is not needed. If this is too small, more memory is\nobtained from the heap. At the start of each block is an anchor structure.*/\n\nint base_recursion_workspace\u00ddRWS_BASE_SIZE\u00a8;\nRWS_anchor *rws = (RWS_anchor *)base_recursion_workspace;\nrws->next = NULL;\nrws->size = RWS_BASE_SIZE;\nrws->free = RWS_BASE_SIZE - RWS_ANCHOR_SIZE;\n\n/* A length equal to PCRE2_ZERO_TERMINATED implies a zero-terminated\nsubject string. */\n\nif (length == PCRE2_ZERO_TERMINATED)\n  {\n  length = PRIV(strlen)(subject);\n  was_zero_terminated = 1;\n  }\n\n/* Plausibility checks */\n\nif ((options & ~PUBLIC_DFA_MATCH_OPTIONS) != 0) return PCRE2_ERROR_BADOPTION;\nif (re == NULL || subject == NULL || workspace == NULL || match_data == NULL)\n  return PCRE2_ERROR_NULL;\nif (wscount < 20) return PCRE2_ERROR_DFA_WSSIZE;\nif (start_offset > length) return PCRE2_ERROR_BADOFFSET;\n\n/* Partial matching and PCRE2_ENDANCHORED are currently not allowed at the same\ntime. */\n\nif ((options & (PCRE2_PARTIAL_HARD|PCRE2_PARTIAL_SOFT)) != 0 &&\n   ((re->overall_options | options) & PCRE2_ENDANCHORED) != 0)\n  return PCRE2_ERROR_BADOPTION;\n\n/* Invalid UTF support is not available for DFA matching. */\n\nif ((re->overall_options & PCRE2_MATCH_INVALID_UTF) != 0)\n  return PCRE2_ERROR_DFA_UINVALID_UTF;\n\n/* Check that the first field in the block is the magic number. If it is not,\nreturn with PCRE2_ERROR_BADMAGIC. */\n\nif (re->magic_number != MAGIC_NUMBER) return PCRE2_ERROR_BADMAGIC;\n\n/* Check the code unit width. */\n\nif ((re->flags & PCRE2_MODE_MASK) != PCRE2_CODE_UNIT_WIDTH/8)\n  return PCRE2_ERROR_BADMODE;\n\n/* PCRE2_NOTEMPTY and PCRE2_NOTEMPTY_ATSTART are match-time flags in the\noptions variable for this function. Users of PCRE2 who are not calling the\nfunction directly would like to have a way of setting these flags, in the same\nway that they can set pcre2_compile() flags like PCRE2_NO_AUTOPOSSESS with\nconstructions like (*NO_AUTOPOSSESS). To enable this, (*NOTEMPTY) and\n(*NOTEMPTY_ATSTART) set bits in the pattern's \"flag\" function which can now be\ntransferred to the options for this function. The bits are guaranteed to be\nadjacent, but do not have the same values. This bit of Boolean trickery assumes\nthat the match-time bits are not more significant than the flag bits. If by\naccident this is not the case, a compile-time division by zero error will\noccur. */\n\n#define FF (PCRE2_NOTEMPTY_SET|PCRE2_NE_ATST_SET)\n#define OO (PCRE2_NOTEMPTY|PCRE2_NOTEMPTY_ATSTART)\noptions |= (re->flags & FF) / ((FF & (~FF+1)) / (OO & (~OO+1)));\n#undef FF\n#undef OO\n\n/* If restarting after a partial match, do some sanity checks on the contents\nof the workspace. */\n\nif ((options & PCRE2_DFA_RESTART) != 0)\n  {\n  if ((workspace\u00dd0\u00a8 & (-2)) != 0 || workspace\u00dd1\u00a8 < 1 ||\n    workspace\u00dd1\u00a8 > (int)((wscount - 2)/INTS_PER_STATEBLOCK))\n      return PCRE2_ERROR_DFA_BADRESTART;\n  }\n\n/* Set some local values */\n\nutf = (re->overall_options & PCRE2_UTF) != 0;\nstart_match = subject + start_offset;\nend_subject = subject + length;\nreq_cu_ptr = start_match - 1;\nanchored = (options & (PCRE2_ANCHORED|PCRE2_DFA_RESTART)) != 0 ||\n  (re->overall_options & PCRE2_ANCHORED) != 0;\n\n/* The \"must be at the start of a line\" flags are used in a loop when finding\nwhere to start. */\n\nstartline = (re->flags & PCRE2_STARTLINE) != 0;\nfirstline = (re->overall_options & PCRE2_FIRSTLINE) != 0;\nbumpalong_limit = end_subject;\n\n/* Initialize and set up the fixed fields in the callout block, with a pointer\nin the match block. */\n\nmb->cb = &cb;\ncb.version = 2;\ncb.subject = subject;\ncb.subject_length = (PCRE2_SIZE)(end_subject - subject);\ncb.callout_flags = 0;\ncb.capture_top      = 1;      /* No capture support */\ncb.capture_last     = 0;\ncb.mark             = NULL;   /* No (*MARK) support */\n\n/* Get data from the match context, if present, and fill in the remaining\nfields in the match block. It is an error to set an offset limit without\nsetting the flag at compile time. */\n\nif (mcontext == NULL)\n  {\n  mb->callout = NULL;\n  mb->memctl = re->memctl;\n  mb->match_limit = PRIV(default_match_context).match_limit;\n  mb->match_limit_depth = PRIV(default_match_context).depth_limit;\n  mb->heap_limit = PRIV(default_match_context).heap_limit;\n  }\nelse\n  {\n  if (mcontext->offset_limit != PCRE2_UNSET)\n    {\n    if ((re->overall_options & PCRE2_USE_OFFSET_LIMIT) == 0)\n      return PCRE2_ERROR_BADOFFSETLIMIT;\n    bumpalong_limit = subject + mcontext->offset_limit;\n    }\n  mb->callout = mcontext->callout;\n  mb->callout_data = mcontext->callout_data;\n  mb->memctl = mcontext->memctl;\n  mb->match_limit = mcontext->match_limit;\n  mb->match_limit_depth = mcontext->depth_limit;\n  mb->heap_limit = mcontext->heap_limit;\n  }\n\nif (mb->match_limit > re->limit_match)\n  mb->match_limit = re->limit_match;\n\nif (mb->match_limit_depth > re->limit_depth)\n  mb->match_limit_depth = re->limit_depth;\n\nif (mb->heap_limit > re->limit_heap)\n  mb->heap_limit = re->limit_heap;\n\nmb->start_code = (PCRE2_UCHAR *)((uint8_t *)re + sizeof(pcre2_real_code)) +\n  re->name_count * re->name_entry_size;\nmb->tables = re->tables;\nmb->start_subject = subject;\nmb->end_subject = end_subject;\nmb->start_offset = start_offset;\nmb->allowemptypartial = (re->max_lookbehind > 0) ||\n  (re->flags & PCRE2_MATCH_EMPTY) != 0;\nmb->moptions = options;\nmb->poptions = re->overall_options;\nmb->match_call_count = 0;\nmb->heap_used = 0;\n\n/* Process the \\R and newline settings. */\n\nmb->bsr_convention = re->bsr_convention;\nmb->nltype = NLTYPE_FIXED;\nswitch(re->newline_convention)\n  {\n  case PCRE2_NEWLINE_CR:\n  mb->nllen = 1;\n  mb->nl\u00dd0\u00a8 = CHAR_CR;\n  break;\n\n  case PCRE2_NEWLINE_LF:\n  mb->nllen = 1;\n  mb->nl\u00dd0\u00a8 = CHAR_NL;\n  break;\n\n  case PCRE2_NEWLINE_NUL:\n  mb->nllen = 1;\n  mb->nl\u00dd0\u00a8 = CHAR_NUL;\n  break;\n\n  case PCRE2_NEWLINE_CRLF:\n  mb->nllen = 2;\n  mb->nl\u00dd0\u00a8 = CHAR_CR;\n  mb->nl\u00dd1\u00a8 = CHAR_NL;\n  break;\n\n  case PCRE2_NEWLINE_ANY:\n  mb->nltype = NLTYPE_ANY;\n  break;\n\n  case PCRE2_NEWLINE_ANYCRLF:\n  mb->nltype = NLTYPE_ANYCRLF;\n  break;\n\n  default: return PCRE2_ERROR_INTERNAL;\n  }\n\n/* Check a UTF string for validity if required. For 8-bit and 16-bit strings,\nwe must also check that a starting offset does not point into the middle of a\nmultiunit character. We check only the portion of the subject that is going to\nbe inspected during matching - from the offset minus the maximum back reference\nto the given length. This saves time when a small part of a large subject is\nbeing matched by the use of a starting offset. Note that the maximum lookbehind\nis a number of characters, not code units. */\n\n#ifdef SUPPORT_UNICODE\nif (utf && (options & PCRE2_NO_UTF_CHECK) == 0)\n  {\n  PCRE2_SPTR check_subject = start_match;  /* start_match includes offset */\n\n  if (start_offset > 0)\n    {\n#if PCRE2_CODE_UNIT_WIDTH != 32\n    unsigned int i;\n    if (start_match < end_subject && NOT_FIRSTCU(*start_match))\n      return PCRE2_ERROR_BADUTFOFFSET;\n    for (i = re->max_lookbehind; i > 0 && check_subject > subject; i--)\n      {\n      check_subject--;\n      while (check_subject > subject &&\n#if PCRE2_CODE_UNIT_WIDTH == 8\n      (*check_subject & 0xc0) == 0x80)\n#else  /* 16-bit */\n      (*check_subject & 0xfc00) == 0xdc00)\n#endif /* PCRE2_CODE_UNIT_WIDTH == 8 */\n        check_subject--;\n      }\n#else   /* In the 32-bit library, one code unit equals one character. */\n    check_subject -= re->max_lookbehind;\n    if (check_subject < subject) check_subject = subject;\n#endif  /* PCRE2_CODE_UNIT_WIDTH != 32 */\n    }\n\n  /* Validate the relevant portion of the subject. After an error, adjust the\n  offset to be an absolute offset in the whole string. */\n\n  match_data->rc = PRIV(valid_utf)(check_subject,\n    length - (PCRE2_SIZE)(check_subject - subject), &(match_data->startchar));\n  if (match_data->rc != 0)\n    {\n    match_data->startchar += (PCRE2_SIZE)(check_subject - subject);\n    return match_data->rc;\n    }\n  }\n#endif  /* SUPPORT_UNICODE */\n\n/* Set up the first code unit to match, if available. If there's no first code\nunit there may be a bitmap of possible first characters. */\n\nif ((re->flags & PCRE2_FIRSTSET) != 0)\n  {\n  has_first_cu = TRUE;\n  first_cu = first_cu2 = (PCRE2_UCHAR)(re->first_codeunit);\n  if ((re->flags & PCRE2_FIRSTCASELESS) != 0)\n    {\n    first_cu2 = TABLE_GET(first_cu, mb->tables + fcc_offset, first_cu);\n#ifdef SUPPORT_UNICODE\n#if PCRE2_CODE_UNIT_WIDTH == 8\n    if (first_cu > 127 && !utf && (re->overall_options & PCRE2_UCP) != 0)\n      first_cu2 = (PCRE2_UCHAR)UCD_OTHERCASE(first_cu);\n#else\n    if (first_cu > 127 && (utf || (re->overall_options & PCRE2_UCP) != 0))\n      first_cu2 = (PCRE2_UCHAR)UCD_OTHERCASE(first_cu);\n#endif\n#endif  /* SUPPORT_UNICODE */\n    }\n  }\nelse\n  if (!startline && (re->flags & PCRE2_FIRSTMAPSET) != 0)\n    start_bits = re->start_bitmap;\n\n/* There may be a \"last known required code unit\" set. */\n\nif ((re->flags & PCRE2_LASTSET) != 0)\n  {\n  has_req_cu = TRUE;\n  req_cu = req_cu2 = (PCRE2_UCHAR)(re->last_codeunit);\n  if ((re->flags & PCRE2_LASTCASELESS) != 0)\n    {\n    req_cu2 = TABLE_GET(req_cu, mb->tables + fcc_offset, req_cu);\n#ifdef SUPPORT_UNICODE\n#if PCRE2_CODE_UNIT_WIDTH == 8\n    if (req_cu > 127 && !utf && (re->overall_options & PCRE2_UCP) != 0)\n      req_cu2 = (PCRE2_UCHAR)UCD_OTHERCASE(req_cu);\n#else\n    if (req_cu > 127 && (utf || (re->overall_options & PCRE2_UCP) != 0))\n      req_cu2 = (PCRE2_UCHAR)UCD_OTHERCASE(req_cu);\n#endif\n#endif  /* SUPPORT_UNICODE */\n    }\n  }\n\n/* If the match data block was previously used with PCRE2_COPY_MATCHED_SUBJECT,\nfree the memory that was obtained. */\n\nif ((match_data->flags & PCRE2_MD_COPIED_SUBJECT) != 0)\n  {\n  match_data->memctl.free((void *)match_data->subject,\n    match_data->memctl.memory_data);\n  match_data->flags &= ~PCRE2_MD_COPIED_SUBJECT;\n  }\n\n/* Fill in fields that are always returned in the match data. */\n\nmatch_data->code = re;\nmatch_data->subject = NULL;  /* Default for no match */\nmatch_data->mark = NULL;\nmatch_data->matchedby = PCRE2_MATCHEDBY_DFA_INTERPRETER;\n\n/* Call the main matching function, looping for a non-anchored regex after a\nfailed match. If not restarting, perform certain optimizations at the start of\na match. */\n\nfor (;;)\n  {\n  /* ----------------- Start of match optimizations ---------------- */\n\n  /* There are some optimizations that avoid running the match if a known\n  starting point is not found, or if a known later code unit is not present.\n  However, there is an option (settable at compile time) that disables\n  these, for testing and for ensuring that all callouts do actually occur.\n  The optimizations must also be avoided when restarting a DFA match. */\n\n  if ((re->overall_options & PCRE2_NO_START_OPTIMIZE) == 0 &&\n      (options & PCRE2_DFA_RESTART) == 0)\n    {\n    /* If firstline is TRUE, the start of the match is constrained to the first\n    line of a multiline string. That is, the match must be before or at the\n    first newline following the start of matching. Temporarily adjust\n    end_subject so that we stop the optimization scans for a first code unit\n    immediately after the first character of a newline (the first code unit can\n    legitimately be a newline). If the match fails at the newline, later code\n    breaks this loop. */\n\n    if (firstline)\n      {\n      PCRE2_SPTR t = start_match;\n#ifdef SUPPORT_UNICODE\n      if (utf)\n        {\n        while (t < end_subject && !IS_NEWLINE(t))\n          {\n          t++;\n          ACROSSCHAR(t < end_subject, t, t++);\n          }\n        }\n      else\n#endif\n      while (t < end_subject && !IS_NEWLINE(t)) t++;\n      end_subject = t;\n      }\n\n    /* Anchored: check the first code unit if one is recorded. This may seem\n    pointless but it can help in detecting a no match case without scanning for\n    the required code unit. */\n\n    if (anchored)\n      {\n      if (has_first_cu || start_bits != NULL)\n        {\n        BOOL ok = start_match < end_subject;\n        if (ok)\n          {\n          PCRE2_UCHAR c = UCHAR21TEST(start_match);\n          ok = has_first_cu && (c == first_cu || c == first_cu2);\n          if (!ok && start_bits != NULL)\n            {\n#if PCRE2_CODE_UNIT_WIDTH != 8\n            if (c > 255) c = 255;\n#endif\n            ok = (start_bits\u00ddc/8\u00a8 & (1u << (c&7))) != 0;\n            }\n          }\n        if (!ok) break;\n        }\n      }\n\n    /* Not anchored. Advance to a unique first code unit if there is one. In\n    8-bit mode, the use of memchr() gives a big speed up, even though we have\n    to call it twice in caseless mode, in order to find the earliest occurrence\n    of the character in either of its cases. If a call to memchr() that\n    searches the rest of the subject fails to find one case, remember that in\n    order not to keep on repeating the search. This can make a huge difference\n    when the strings are very long and only one case is present. */\n\n    else\n      {\n      if (has_first_cu)\n        {\n        if (first_cu != first_cu2)  /* Caseless */\n          {\n#if PCRE2_CODE_UNIT_WIDTH != 8\n          PCRE2_UCHAR smc;\n          while (start_match < end_subject &&\n                (smc = UCHAR21TEST(start_match)) != first_cu &&\n                  smc != first_cu2)\n            start_match++;\n\n#else  /* 8-bit code units */\n          PCRE2_SPTR pp1 = NULL;\n          PCRE2_SPTR pp2 = NULL;\n          PCRE2_SIZE cu2size = end_subject - start_match;\n\n          if (!memchr_not_found_first_cu)\n            {\n            pp1 = memchr(start_match, first_cu, end_subject - start_match);\n            if (pp1 == NULL) memchr_not_found_first_cu = TRUE;\n              else cu2size = pp1 - start_match;\n            }\n\n          /* If pp1 is not NULL, we have arranged to search only as far as pp1,\n          to see if the other case is earlier, so we can set \"not found\" only\n          when both searches have returned NULL. */\n\n          if (!memchr_not_found_first_cu2)\n            {\n            pp2 = memchr(start_match, first_cu2, cu2size);\n            memchr_not_found_first_cu2 = (pp2 == NULL && pp1 == NULL);\n            }\n\n          if (pp1 == NULL)\n            start_match = (pp2 == NULL)? end_subject : pp2;\n          else\n            start_match = (pp2 == NULL || pp1 < pp2)? pp1 : pp2;\n#endif\n          }\n\n        /* The caseful case */\n\n        else\n          {\n#if PCRE2_CODE_UNIT_WIDTH != 8\n          while (start_match < end_subject && UCHAR21TEST(start_match) !=\n                 first_cu)\n            start_match++;\n#else  /* 8-bit code units */\n          start_match = memchr(start_match, first_cu, end_subject - start_match);\n          if (start_match == NULL) start_match = end_subject;\n#endif\n          }\n\n        /* If we can't find the required code unit, having reached the true end\n        of the subject, break the bumpalong loop, to force a match failure,\n        except when doing partial matching, when we let the next cycle run at\n        the end of the subject. To see why, consider the pattern /(?<=abc)def/,\n        which partially matches \"abc\", even though the string does not contain\n        the starting character \"d\". If we have not reached the true end of the\n        subject (PCRE2_FIRSTLINE caused end_subject to be temporarily modified)\n        we also let the cycle run, because the matching string is legitimately\n        allowed to start with the first code unit of a newline. */\n\n        if ((mb->moptions & (PCRE2_PARTIAL_HARD|PCRE2_PARTIAL_SOFT)) == 0 &&\n            start_match >= mb->end_subject)\n          break;\n        }\n\n      /* If there's no first code unit, advance to just after a linebreak for a\n      multiline match if required. */\n\n      else if (startline)\n        {\n        if (start_match > mb->start_subject + start_offset)\n          {\n#ifdef SUPPORT_UNICODE\n          if (utf)\n            {\n            while (start_match < end_subject && !WAS_NEWLINE(start_match))\n              {\n              start_match++;\n              ACROSSCHAR(start_match < end_subject, start_match, start_match++);\n              }\n            }\n          else\n#endif\n          while (start_match < end_subject && !WAS_NEWLINE(start_match))\n            start_match++;\n\n          /* If we have just passed a CR and the newline option is ANY or\n          ANYCRLF, and we are now at a LF, advance the match position by one\n          more code unit. */\n\n          if (start_match\u00dd-1\u00a8 == CHAR_CR &&\n               (mb->nltype == NLTYPE_ANY || mb->nltype == NLTYPE_ANYCRLF) &&\n               start_match < end_subject &&\n               UCHAR21TEST(start_match) == CHAR_NL)\n            start_match++;\n          }\n        }\n\n      /* If there's no first code unit or a requirement for a multiline line\n      start, advance to a non-unique first code unit if any have been\n      identified. The bitmap contains only 256 bits. When code units are 16 or\n      32 bits wide, all code units greater than 254 set the 255 bit. */\n\n      else if (start_bits != NULL)\n        {\n        while (start_match < end_subject)\n          {\n          uint32_t c = UCHAR21TEST(start_match);\n#if PCRE2_CODE_UNIT_WIDTH != 8\n          if (c > 255) c = 255;\n#endif\n          if ((start_bits\u00ddc/8\u00a8 & (1u << (c&7))) != 0) break;\n          start_match++;\n          }\n\n        /* See comment above in first_cu checking about the next line. */\n\n        if ((mb->moptions & (PCRE2_PARTIAL_HARD|PCRE2_PARTIAL_SOFT)) == 0 &&\n            start_match >= mb->end_subject)\n          break;\n        }\n      }  /* End of first code unit handling */\n\n    /* Restore fudged end_subject */\n\n    end_subject = mb->end_subject;\n\n    /* The following two optimizations are disabled for partial matching. */\n\n    if ((mb->moptions & (PCRE2_PARTIAL_HARD|PCRE2_PARTIAL_SOFT)) == 0)\n      {\n      PCRE2_SPTR p;\n\n      /* The minimum matching length is a lower bound; no actual string of that\n      length may actually match the pattern. Although the value is, strictly,\n      in characters, we treat it as code units to avoid spending too much time\n      in this optimization. */\n\n      if (end_subject - start_match < re->minlength) goto NOMATCH_EXIT;\n\n      /* If req_cu is set, we know that that code unit must appear in the\n      subject for the match to succeed. If the first code unit is set, req_cu\n      must be later in the subject; otherwise the test starts at the match\n      point. This optimization can save a huge amount of backtracking in\n      patterns with nested unlimited repeats that aren't going to match.\n      Writing separate code for cased/caseless versions makes it go faster, as\n      does using an autoincrement and backing off on a match. As in the case of\n      the first code unit, using memchr() in the 8-bit library gives a big\n      speed up. Unlike the first_cu check above, we do not need to call\n      memchr() twice in the caseless case because we only need to check for the\n      presence of the character in either case, not find the first occurrence.\n\n      The search can be skipped if the code unit was found later than the\n      current starting point in a previous iteration of the bumpalong loop.\n\n      HOWEVER: when the subject string is very, very long, searching to its end\n      can take a long time, and give bad performance on quite ordinary\n      patterns. This showed up when somebody was matching something like\n      /\u00ac\\d+C/ on a 32-megabyte string... so we don't do this when the string is\n      sufficiently long, but it's worth searching a lot more for unanchored\n      patterns. */\n\n      p = start_match + (has_first_cu? 1:0);\n      if (has_req_cu && p > req_cu_ptr)\n        {\n        PCRE2_SIZE check_length = end_subject - start_match;\n\n        if (check_length < REQ_CU_MAX ||\n              (!anchored && check_length < REQ_CU_MAX * 1000))\n          {\n          if (req_cu != req_cu2)  /* Caseless */\n            {\n#if PCRE2_CODE_UNIT_WIDTH != 8\n            while (p < end_subject)\n              {\n              uint32_t pp = UCHAR21INCTEST(p);\n              if (pp == req_cu || pp == req_cu2) { p--; break; }\n              }\n#else  /* 8-bit code units */\n            PCRE2_SPTR pp = p;\n            p = memchr(pp, req_cu, end_subject - pp);\n            if (p == NULL)\n              {\n              p = memchr(pp, req_cu2, end_subject - pp);\n              if (p == NULL) p = end_subject;\n              }\n#endif /* PCRE2_CODE_UNIT_WIDTH != 8 */\n            }\n\n          /* The caseful case */\n\n          else\n            {\n#if PCRE2_CODE_UNIT_WIDTH != 8\n            while (p < end_subject)\n              {\n              if (UCHAR21INCTEST(p) == req_cu) { p--; break; }\n              }\n\n#else  /* 8-bit code units */\n            p = memchr(p, req_cu, end_subject - p);\n            if (p == NULL) p = end_subject;\n#endif\n            }\n\n          /* If we can't find the required code unit, break the matching loop,\n          forcing a match failure. */\n\n          if (p >= end_subject) break;\n\n          /* If we have found the required code unit, save the point where we\n          found it, so that we don't search again next time round the loop if\n          the start hasn't passed this code unit yet. */\n\n          req_cu_ptr = p;\n          }\n        }\n      }\n    }\n\n  /* ------------ End of start of match optimizations ------------ */\n\n  /* Give no match if we have passed the bumpalong limit. */\n\n  if (start_match > bumpalong_limit) break;\n\n  /* OK, now we can do the business */\n\n  mb->start_used_ptr = start_match;\n  mb->last_used_ptr = start_match;\n  mb->recursive = NULL;\n\n  rc = internal_dfa_match(\n    mb,                           /* fixed match data */\n    mb->start_code,               /* this subexpression's code */\n    start_match,                  /* where we currently are */\n    start_offset,                 /* start offset in subject */\n    match_data->ovector,          /* offset vector */\n    (uint32_t)match_data->oveccount * 2,  /* actual size of same */\n    workspace,                    /* workspace vector */\n    (int)wscount,                 /* size of same */\n    0,                            /* function recurse level */\n    base_recursion_workspace);    /* initial workspace for recursion */\n\n  /* Anything other than \"no match\" means we are done, always; otherwise, carry\n  on only if not anchored. */\n\n  if (rc != PCRE2_ERROR_NOMATCH || anchored)\n    {\n    if (rc == PCRE2_ERROR_PARTIAL && match_data->oveccount > 0)\n      {\n      match_data->ovector\u00dd0\u00a8 = (PCRE2_SIZE)(start_match - subject);\n      match_data->ovector\u00dd1\u00a8 = (PCRE2_SIZE)(end_subject - subject);\n      }\n    match_data->leftchar = (PCRE2_SIZE)(mb->start_used_ptr - subject);\n    match_data->rightchar = (PCRE2_SIZE)( mb->last_used_ptr - subject);\n    match_data->startchar = (PCRE2_SIZE)(start_match - subject);\n    match_data->rc = rc;\n\n    if (rc >= 0 &&(options & PCRE2_COPY_MATCHED_SUBJECT) != 0)\n      {\n      length = CU2BYTES(length + was_zero_terminated);\n      match_data->subject = match_data->memctl.malloc(length,\n        match_data->memctl.memory_data);\n      if (match_data->subject == NULL) return PCRE2_ERROR_NOMEMORY;\n      memcpy((void *)match_data->subject, subject, length);\n      match_data->flags |= PCRE2_MD_COPIED_SUBJECT;\n      }\n    else\n      {\n      if (rc >= 0 || rc == PCRE2_ERROR_PARTIAL) match_data->subject = subject;\n      }\n    goto EXIT;\n    }\n\n  /* Advance to the next subject character unless we are at the end of a line\n  and firstline is set. */\n\n  if (firstline && IS_NEWLINE(start_match)) break;\n  start_match++;\n#ifdef SUPPORT_UNICODE\n  if (utf)\n    {\n    ACROSSCHAR(start_match < end_subject, start_match, start_match++);\n    }\n#endif\n  if (start_match > end_subject) break;\n\n  /* If we have just passed a CR and we are now at a LF, and the pattern does\n  not contain any explicit matches for \\r or \\n, and the newline option is CRLF\n  or ANY or ANYCRLF, advance the match position by one more character. */\n\n  if (UCHAR21TEST(start_match - 1) == CHAR_CR &&\n      start_match < end_subject &&\n      UCHAR21TEST(start_match) == CHAR_NL &&\n      (re->flags & PCRE2_HASCRORLF) == 0 &&\n        (mb->nltype == NLTYPE_ANY ||\n         mb->nltype == NLTYPE_ANYCRLF ||\n         mb->nllen == 2))\n    start_match++;\n\n  }   /* \"Bumpalong\" loop */\n\nNOMATCH_EXIT:\nrc = PCRE2_ERROR_NOMATCH;\n\nEXIT:\nwhile (rws->next != NULL)\n  {\n  RWS_anchor *next = rws->next;\n  rws->next = next->next;\n  mb->memctl.free(next, mb->memctl.memory_data);\n  }\n\nreturn rc;\n}\n\n/* End of pcre2_dfa_match.c */\n/*autoconv-0001 C:\\projects\\pcre2-10.35\\src\\pcre2_dfa_match.c converted to DFAMATC2*/\n/*autoconv-0011 DFAMATC2 line: 76 config.h replaced by CONFIG.h*/\n/*autoconv-0011 DFAMATC2 line: 83 pcre2_internal.h replaced by INTERNA2.h*/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DFTABLES": {"ttr": 5377, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "\n/*************************************************\n*      Perl-Compatible Regular Expressions       *\n*************************************************/\n\n/* PCRE is a library of functions to support regular expressions whose syntax\nand semantics are as close as possible to those of the Perl 5 language.\n\n                       Written by Philip Hazel\n     Original API code Copyright (c) 1997-2012 University of Cambridge\n          New API code Copyright (c) 2016-2020 University of Cambridge\n\n-----------------------------------------------------------------------------\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n\n    * Redistributions of source code must retain the above copyright notice,\n      this list of conditions and the following disclaimer.\n\n    * Redistributions in binary form must reproduce the above copyright\n      notice, this list of conditions and the following disclaimer in the\n      documentation and/or other materials provided with the distribution.\n\n    * Neither the name of the University of Cambridge nor the names of its\n      contributors may be used to endorse or promote products derived from\n      this software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\nAND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\nIMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\nARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\nLIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\nCONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\nSUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\nINTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\nCONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\nARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\nPOSSIBILITY OF SUCH DAMAGE.\n-----------------------------------------------------------------------------\n*/\n\n\n/* This is a freestanding support program to generate a file containing\ncharacter tables for PCRE2. The tables are built using the pcre2_maketables()\nfunction, which is part of the PCRE2 API. By default, the system's \"C\" locale\nis used rather than what the building user happens to have set, but the -L\noption can be used to select the current locale from the LC_ALL environment\nvariable. By default, the tables are written in source form, but if -b is\ngiven, they are written in binary. */\n\n#ifdef HAVE_CONFIG_H\n#include \"CONFIG.h\"\n#endif\n\n#include <ctype.h>\n#include <stdio.h>\n#include <string.h>\n#include <locale.h>\n\n#define PCRE2_CODE_UNIT_WIDTH 0   /* Must be set, but not relevant here */\n#include \"INTERNA2.h\"\n\n#define PCRE2_DFTABLES            /* pcre2_maketables.c notices this */\n#include \"MAKETAB2.c\"\n\n\nstatic char *classlist\u00dd\u00a8 =\n  {\n  \"space\", \"xdigit\", \"digit\", \"upper\", \"lower\",\n  \"word\", \"graph\", \"print\", \"punct\", \"cntrl\"\n  };\n\n\n\n/*************************************************\n*                  Usage                         *\n*************************************************/\n\nstatic void\nusage(void)\n{\n(void)fprintf(stderr,\n  \"Usage: pcre2_dftables \u00ddoptions\u00a8 <output file>\\n\"\n  \"  -b    Write output in binary (default is source code)\\n\"\n  \"  -L    Use locale from LC_ALL (default is \\\"C\\\" locale)\\n\"\n  );\n}\n\n\n\n/*************************************************\n*                Entry point                     *\n*************************************************/\n\nint main(int argc, char **argv)\n{\nFILE *f;\nint i;\nint nclass = 0;\nBOOL binary = FALSE;\nchar *env = \"C\";\nconst unsigned char *tables;\nconst unsigned char *base_of_tables;\n\n/* Process options */\n\nfor (i = 1; i < argc; i++)\n  {\n  unsigned char *arg = (unsigned char *)argv\u00ddi\u00a8;\n  if (*arg != '-') break;\n\n  if (strcmp(arg, \"-help\") == 0 || strcmp(arg, \"--help\") == 0)\n    {\n    usage();\n    return 0;\n    }\n\n  else if (strcmp(arg, \"-L\") == 0)\n    {\n    if (setlocale(LC_ALL, \"\") == NULL)\n      {\n      (void)fprintf(stderr, \"pcre2_dftables: setlocale() failed\\n\");\n      return 1;\n      }\n    env = getenv(\"LC_ALL\");\n    }\n\n  else if (strcmp(arg, \"-b\") == 0)\n    binary = TRUE;\n\n  else\n    {\n    (void)fprintf(stderr, \"pcre2_dftables: unrecognized option %s\\n\", arg);\n    return 1;\n    }\n  }\n\nif (i != argc - 1)\n  {\n  (void)fprintf(stderr, \"pcre2_dftables: one filename argument is required\\n\");\n  return 1;\n  }\n\n/* Make the tables */\n\ntables = maketables();\nbase_of_tables = tables;\n\nf = fopen(argv\u00ddi\u00a8, \"w\");\nif (f == NULL)\n  {\n  fprintf(stderr, \"pcre2_dftables: failed to open %s for writing\\n\", argv\u00dd1\u00a8);\n  return 1;\n  }\n\n/* If -b was specified, we write the tables in binary. */\n\nif (binary)\n  {\n  int yield = 0;\n  size_t len = fwrite(tables, 1, TABLES_LENGTH, f);\n  if (len != TABLES_LENGTH)\n    {\n    (void)fprintf(stderr, \"pcre2_dftables: fwrite() returned wrong length %d \"\n     \"instead of %d\\n\", (int)len, TABLES_LENGTH);\n    yield = 1;\n    }\n  fclose(f);\n  free((void *)base_of_tables);\n  return yield;\n  }\n\n/* Write the tables as source code for inclusion in the PCRE2 library. There\nare several fprintf() calls here, because gcc in pedantic mode complains about\nthe very long string otherwise. */\n\n(void)fprintf(f,\n  \"/*************************************************\\n\"\n  \"*      Perl-Compatible Regular Expressions       *\\n\"\n  \"*************************************************/\\n\\n\"\n  \"/* This file was automatically written by the pcre2_dftables auxiliary\\n\"\n  \"program. It contains character tables that are used when no external\\n\"\n  \"tables are passed to PCRE2 by the application that calls it. The tables\\n\"\n  \"are used only for characters whose code values are less than 256. */\\n\\n\");\n\n(void)fprintf(f,\n  \"/* This set of tables was written in the %s locale. */\\n\\n\", env);\n\n(void)fprintf(f,\n  \"/* The pcre2_ftables program (which is distributed with PCRE2) can be used\\n\"\n  \"to build alternative versions of this file. This is necessary if you are\\n\"\n  \"running in an EBCDIC environment, or if you want to default to a different\\n\"\n  \"encoding, for example ISO-8859-1. When pcre2_dftables is run, it creates\\n\"\n  \"these tables in the \\\"C\\\" locale by default. This happens automatically if\\n\"\n  \"PCRE2 is configured with --enable-rebuild-chartables. However, you can run\\n\"\n  \"pcre2_dftables manually with the -L option to build tables using the LC_ALL\\n\"\n  \"locale. */\\n\\n\");\n\n/* Force config.h in z/OS */\n\n#if defined NATIVE_ZOS\n(void)fprintf(f,\n  \"/* For z/OS, config.h is forced */\\n\"\n  \"#ifndef HAVE_CONFIG_H\\n\"\n  \"#define HAVE_CONFIG_H 1\\n\"\n  \"#endif\\n\\n\");\n#endif\n\n(void)fprintf(f,\n  \"/* The following #include is present because without it gcc 4.x may remove\\n\"\n  \"the array definition from the final binary if PCRE2 is built into a static\\n\"\n  \"library and dead code stripping is activated. This leads to link errors.\\n\"\n  \"Pulling in the header ensures that the array gets flagged as \\\"someone\\n\"\n  \"outside this compilation unit might reference this\\\" and so it will always\\n\"\n  \"be supplied to the linker. */\\n\\n\");\n\n(void)fprintf(f,\n  \"#ifdef HAVE_CONFIG_H\\n\"\n  \"#include \\\"CONFIG.h\\\"\\n\"\n  \"#endif\\n\\n\"\n  \"#include \\\"INTERNA2.h\\\"\\n\\n\");\n\n(void)fprintf(f,\n  \"const uint8_t PRIV(default_tables)\u00dd\u00a8 = {\\n\\n\"\n  \"/* This table is a lower casing table. */\\n\\n\");\n\n(void)fprintf(f, \"  \");\nfor (i = 0; i < 256; i++)\n  {\n  if ((i & 7) == 0 && i != 0) fprintf(f, \"\\n  \");\n  fprintf(f, \"%3d\", *tables++);\n  if (i != 255) fprintf(f, \",\");\n  }\n(void)fprintf(f, \",\\n\\n\");\n\n(void)fprintf(f, \"/* This table is a case flipping table. */\\n\\n\");\n\n(void)fprintf(f, \"  \");\nfor (i = 0; i < 256; i++)\n  {\n  if ((i & 7) == 0 && i != 0) fprintf(f, \"\\n  \");\n  fprintf(f, \"%3d\", *tables++);\n  if (i != 255) fprintf(f, \",\");\n  }\n(void)fprintf(f, \",\\n\\n\");\n\n(void)fprintf(f,\n  \"/* This table contains bit maps for various character classes. Each map is 32\\n\"\n  \"bytes long and the bits run from the least significant end of each byte. The\\n\"\n  \"classes that have their own maps are: space, xdigit, digit, upper, lower, word,\\n\"\n  \"graph, print, punct, and cntrl. Other classes are built from combinations. */\\n\\n\");\n\n(void)fprintf(f, \"  \");\nfor (i = 0; i < cbit_length; i++)\n  {\n  if ((i & 7) == 0 && i != 0)\n    {\n    if ((i & 31) == 0) (void)fprintf(f, \"\\n\");\n    if ((i & 24) == 8) (void)fprintf(f, \"  /* %s */\", classlist\u00ddnclass++\u00a8);\n    (void)fprintf(f, \"\\n  \");\n    }\n  (void)fprintf(f, \"0x%02x\", *tables++);\n  if (i != cbit_length - 1) (void)fprintf(f, \",\");\n  }\n(void)fprintf(f, \",\\n\\n\");\n\n(void)fprintf(f,\n  \"/* This table identifies various classes of character by individual bits:\\n\"\n  \"  0x%02x   white space character\\n\"\n  \"  0x%02x   letter\\n\"\n  \"  0x%02x   lower case letter\\n\"\n  \"  0x%02x   decimal digit\\n\"\n  \"  0x%02x   alphanumeric or '_'\\n*/\\n\\n\",\n  ctype_space, ctype_letter, ctype_lcletter, ctype_digit, ctype_word);\n\n(void)fprintf(f, \"  \");\nfor (i = 0; i < 256; i++)\n  {\n  if ((i & 7) == 0 && i != 0)\n    {\n    (void)fprintf(f, \" /* \");\n    if (isprint(i-8)) (void)fprintf(f, \" %c -\", i-8);\n      else (void)fprintf(f, \"%3d-\", i-8);\n    if (isprint(i-1)) (void)fprintf(f, \" %c \", i-1);\n      else (void)fprintf(f, \"%3d\", i-1);\n    (void)fprintf(f, \" */\\n  \");\n    }\n  (void)fprintf(f, \"0x%02x\", *tables++);\n  if (i != 255) (void)fprintf(f, \",\");\n  }\n\n(void)fprintf(f, \"};/* \");\nif (isprint(i-8)) (void)fprintf(f, \" %c -\", i-8);\n  else (void)fprintf(f, \"%3d-\", i-8);\nif (isprint(i-1)) (void)fprintf(f, \" %c \", i-1);\n  else (void)fprintf(f, \"%3d\", i-1);\n(void)fprintf(f, \" */\\n\\n/* End of pcre2_chartables.c */\\n\");\n\nfclose(f);\nfree((void *)base_of_tables);\nreturn 0;\n}\n\n/* End of pcre2_dftables.c */\n/*autoconv-0001 C:\\projects\\pcre2-10.35\\src\\pcre2_dftables.c converted to DFTABLES*/\n/*autoconv-0011 DFTABLES line: 51 config.h replaced by CONFIG.h*/\n/*autoconv-0011 DFTABLES line: 60 pcre2_internal.h replaced by INTERNA2.h*/\n/*autoconv-0011 DFTABLES line: 63 pcre2_maketables.c replaced by MAKETAB2.c*/\n/*autoconv-0015 DFTABLES line: 148 fopen \"wb\" replaced by \"w\"*/\n/*autoconv-0011 DFTABLES line: 218 config.h replaced by CONFIG.h*/\n/*autoconv-0011 DFTABLES line: 220 pcre2_internal.h replaced by INTERNA2.h*/\n", "mimetype": "text/x-c", "datatype": "ebcdic", "extension": ".x-c"}, "ECHO": {"ttr": 2820, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "\n/*  $OpenBSD: echo.c,v 1.10 2015/10/09 01:37:06 deraadt Exp $ */\n/*  $NetBSD: echo.c,v 1.6 1995/03/21 09:04:27 cgd Exp $ */\n\n/*\n * Copyright (c) 1989, 1993\n *  The Regents of the University of California.  All rights\n *  reserved.\n *\n * Redistribution and use in source and binary forms, with or\n * without modification, are permitted provided that the\n * following conditions are met:\n * 1. Redistributions of source code must retain the above\n *    copyright notice, this list of conditions and the\n *    following disclaimer.\n * 2. Redistributions in binary form must reproduce the above\n *    copyright notice, this list of conditions and the\n *    following disclaimer in the documentation and/or other\n *    materials provided with the distribution.\n * 3. Neither the name of the University nor the names of its\n *    contributors may be used to endorse or promote products\n *    derived from this software without specific prior written\n *    permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS\n * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,\n * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY\n * AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO\n * EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY\n * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED\n * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF\n * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include <stdio.h>\n#include <string.h>\n#include <unistd.h>\n/*#include <err.h>*/\n\n/* ARGSUSED */\nint\nmain(int argc, char *argv\u00dd\u00a8)\n{\n    int nflag;\n\n    /*if (pledge(\"stdio\", NULL) == -1)\n        err(1, \"pledge\");*/\n\n    /* This utility may NOT do getopt(3) option parsing. */\n    if (*++argv && !strcmp(*argv, \"-n\")) {\n        ++argv;\n        nflag = 1;\n    }\n    else\n        nflag = 0;\n\n    while (*argv) {\n        (void)fputs(*argv, stdout);\n        if (*++argv)\n            putchar(' ');\n    }\n    if (!nflag)\n        putchar('\\n');\n\n    return 0;\n}\n/*autoconv-0001 C:\\projects\\pcre2port\\echo.c converted to ECHO*/\n", "mimetype": "text/x-c", "datatype": "ebcdic", "extension": ".x-c"}, "ERROR2": {"ttr": 2307, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "\n/*************************************************\n*      Perl-Compatible Regular Expressions       *\n*************************************************/\n\n/* PCRE is a library of functions to support regular expressions whose syntax\nand semantics are as close as possible to those of the Perl 5 language.\n\n                       Written by Philip Hazel\n     Original API code Copyright (c) 1997-2012 University of Cambridge\n          New API code Copyright (c) 2016-2019 University of Cambridge\n\n-----------------------------------------------------------------------------\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n\n    * Redistributions of source code must retain the above copyright notice,\n      this list of conditions and the following disclaimer.\n\n    * Redistributions in binary form must reproduce the above copyright\n      notice, this list of conditions and the following disclaimer in the\n      documentation and/or other materials provided with the distribution.\n\n    * Neither the name of the University of Cambridge nor the names of its\n      contributors may be used to endorse or promote products derived from\n      this software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\nAND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\nIMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\nARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\nLIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\nCONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\nSUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\nINTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\nCONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\nARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\nPOSSIBILITY OF SUCH DAMAGE.\n-----------------------------------------------------------------------------\n*/\n\n\n#ifdef HAVE_CONFIG_H\n#include \"CONFIG.h\"\n#endif\n\n#include \"INTERNA2.h\"\n\n#define STRING(a)  # a\n#define XSTRING(s) STRING(s)\n\n/* The texts of compile-time error messages. Compile-time error numbers start\nat COMPILE_ERROR_BASE (100).\n\nThis used to be a table of strings, but in order to reduce the number of\nrelocations needed when a shared library is loaded dynamically, it is now one\nlong string. We cannot use a table of offsets, because the lengths of inserts\nsuch as XSTRING(MAX_NAME_SIZE) are not known. Instead,\npcre2_get_error_message() counts through to the one it wants - this isn't a\nperformance issue because these strings are used only when there is an error.\n\nEach substring ends with \\0 to insert a null character. This includes the final\nsubstring, so that the whole string ends with \\0\\0, which can be detected when\ncounting through. */\n\nstatic const unsigned char compile_error_texts\u00dd\u00a8 =\n  \"no error\\0\"\n  \"\\\\ at end of pattern\\0\"\n  \"\\\\c at end of pattern\\0\"\n  \"unrecognized character follows \\\\\\0\"\n  \"numbers out of order in {} quantifier\\0\"\n  /* 5 */\n  \"number too big in {} quantifier\\0\"\n  \"missing terminating \u00a8 for character class\\0\"\n  \"escape sequence is invalid in character class\\0\"\n  \"range out of order in character class\\0\"\n  \"quantifier does not follow a repeatable item\\0\"\n  /* 10 */\n  \"internal error: unexpected repeat\\0\"\n  \"unrecognized character after (? or (?-\\0\"\n  \"POSIX named classes are supported only within a class\\0\"\n  \"POSIX collating elements are not supported\\0\"\n  \"missing closing parenthesis\\0\"\n  /* 15 */\n  \"reference to non-existent subpattern\\0\"\n  \"pattern passed as NULL\\0\"\n  \"unrecognised compile-time option bit(s)\\0\"\n  \"missing ) after (?# comment\\0\"\n  \"parentheses are too deeply nested\\0\"\n  /* 20 */\n  \"regular expression is too large\\0\"\n  \"failed to allocate heap memory\\0\"\n  \"unmatched closing parenthesis\\0\"\n  \"internal error: code overflow\\0\"\n  \"missing closing parenthesis for condition\\0\"\n  /* 25 */\n  \"lookbehind assertion is not fixed length\\0\"\n  \"a relative value of zero is not allowed\\0\"\n  \"conditional subpattern contains more than two branches\\0\"\n  \"assertion expected after (?( or (?(?C)\\0\"\n  \"digit expected after (?+ or (?-\\0\"\n  /* 30 */\n  \"unknown POSIX class name\\0\"\n  \"internal error in pcre2_study(): should not occur\\0\"\n  \"this version of PCRE2 does not have Unicode support\\0\"\n  \"parentheses are too deeply nested (stack check)\\0\"\n  \"character code point value in \\\\x{} or \\\\o{} is too large\\0\"\n  /* 35 */\n  \"lookbehind is too complicated\\0\"\n  \"\\\\C is not allowed in a lookbehind assertion in UTF-\" XSTRING(PCRE2_CODE_UNIT_WIDTH) \" mode\\0\"\n  \"PCRE2 does not support \\\\F, \\\\L, \\\\l, \\\\N{name}, \\\\U, or \\\\u\\0\"\n  \"number after (?C is greater than 255\\0\"\n  \"closing parenthesis for (?C expected\\0\"\n  /* 40 */\n  \"invalid escape sequence in (*VERB) name\\0\"\n  \"unrecognized character after (?P\\0\"\n  \"syntax error in subpattern name (missing terminator?)\\0\"\n  \"two named subpatterns have the same name (PCRE2_DUPNAMES not set)\\0\"\n  \"subpattern name must start with a non-digit\\0\"\n  /* 45 */\n  \"this version of PCRE2 does not have support for \\\\P, \\\\p, or \\\\X\\0\"\n  \"malformed \\\\P or \\\\p sequence\\0\"\n  \"unknown property name after \\\\P or \\\\p\\0\"\n  \"subpattern name is too long (maximum \" XSTRING(MAX_NAME_SIZE) \" code units)\\0\"\n  \"too many named subpatterns (maximum \" XSTRING(MAX_NAME_COUNT) \")\\0\"\n  /* 50 */\n  \"invalid range in character class\\0\"\n  \"octal value is greater than \\\\377 in 8-bit non-UTF-8 mode\\0\"\n  \"internal error: overran compiling workspace\\0\"\n  \"internal error: previously-checked referenced subpattern not found\\0\"\n  \"DEFINE subpattern contains more than one branch\\0\"\n  /* 55 */\n  \"missing opening brace after \\\\o\\0\"\n  \"internal error: unknown newline setting\\0\"\n  \"\\\\g is not followed by a braced, angle-bracketed, or quoted name/number or by a plain number\\0\"\n  \"(?R (recursive pattern call) must be followed by a closing parenthesis\\0\"\n  /* \"an argument is not allowed for (*ACCEPT), (*FAIL), or (*COMMIT)\\0\" */\n  \"obsolete error (should not occur)\\0\"  /* Was the above */\n  /* 60 */\n  \"(*VERB) not recognized or malformed\\0\"\n  \"subpattern number is too big\\0\"\n  \"subpattern name expected\\0\"\n  \"internal error: parsed pattern overflow\\0\"\n  \"non-octal character in \\\\o{} (closing brace missing?)\\0\"\n  /* 65 */\n  \"different names for subpatterns of the same number are not allowed\\0\"\n  \"(*MARK) must have an argument\\0\"\n  \"non-hex character in \\\\x{} (closing brace missing?)\\0\"\n#ifndef EBCDIC\n  \"\\\\c must be followed by a printable ASCII character\\0\"\n#else\n  \"\\\\c must be followed by a letter or one of \u00dd\\\\\u00a8\u00ac_?\\0\"\n#endif\n  \"\\\\k is not followed by a braced, angle-bracketed, or quoted name\\0\"\n  /* 70 */\n  \"internal error: unknown meta code in check_lookbehinds()\\0\"\n  \"\\\\N is not supported in a class\\0\"\n  \"callout string is too long\\0\"\n  \"disallowed Unicode code point (>= 0xd800 && <= 0xdfff)\\0\"\n  \"using UTF is disabled by the application\\0\"\n  /* 75 */\n  \"using UCP is disabled by the application\\0\"\n  \"name is too long in (*MARK), (*PRUNE), (*SKIP), or (*THEN)\\0\"\n  \"character code point value in \\\\u.... sequence is too large\\0\"\n  \"digits missing in \\\\x{} or \\\\o{} or \\\\N{U+}\\0\"\n  \"syntax error or number too big in (?(VERSION condition\\0\"\n  /* 80 */\n  \"internal error: unknown opcode in auto_possessify()\\0\"\n  \"missing terminating delimiter for callout with string argument\\0\"\n  \"unrecognized string delimiter follows (?C\\0\"\n  \"using \\\\C is disabled by the application\\0\"\n  \"(?| and/or (?J: or (?x: parentheses are too deeply nested\\0\"\n  /* 85 */\n  \"using \\\\C is disabled in this PCRE2 library\\0\"\n  \"regular expression is too complicated\\0\"\n  \"lookbehind assertion is too long\\0\"\n  \"pattern string is longer than the limit set by the application\\0\"\n  \"internal error: unknown code in parsed pattern\\0\"\n  /* 90 */\n  \"internal error: bad code value in parsed_skip()\\0\"\n  \"PCRE2_EXTRA_ALLOW_SURROGATE_ESCAPES is not allowed in UTF-16 mode\\0\"\n  \"invalid option bits with PCRE2_LITERAL\\0\"\n  \"\\\\N{U+dddd} is supported only in Unicode (UTF) mode\\0\"\n  \"invalid hyphen in option setting\\0\"\n  /* 95 */\n  \"(*alpha_assertion) not recognized\\0\"\n  \"script runs require Unicode support, which this version of PCRE2 does not have\\0\"\n  \"too many capturing groups (maximum 65535)\\0\"\n  \"atomic assertion expected after (?( or (?(?C)\\0\"\n  ;\n\n/* Match-time and UTF error texts are in the same format. */\n\nstatic const unsigned char match_error_texts\u00dd\u00a8 =\n  \"no error\\0\"\n  \"no match\\0\"\n  \"partial match\\0\"\n  \"UTF-8 error: 1 byte missing at end\\0\"\n  \"UTF-8 error: 2 bytes missing at end\\0\"\n  /* 5 */\n  \"UTF-8 error: 3 bytes missing at end\\0\"\n  \"UTF-8 error: 4 bytes missing at end\\0\"\n  \"UTF-8 error: 5 bytes missing at end\\0\"\n  \"UTF-8 error: byte 2 top bits not 0x80\\0\"\n  \"UTF-8 error: byte 3 top bits not 0x80\\0\"\n  /* 10 */\n  \"UTF-8 error: byte 4 top bits not 0x80\\0\"\n  \"UTF-8 error: byte 5 top bits not 0x80\\0\"\n  \"UTF-8 error: byte 6 top bits not 0x80\\0\"\n  \"UTF-8 error: 5-byte character is not allowed (RFC 3629)\\0\"\n  \"UTF-8 error: 6-byte character is not allowed (RFC 3629)\\0\"\n  /* 15 */\n  \"UTF-8 error: code points greater than 0x10ffff are not defined\\0\"\n  \"UTF-8 error: code points 0xd800-0xdfff are not defined\\0\"\n  \"UTF-8 error: overlong 2-byte sequence\\0\"\n  \"UTF-8 error: overlong 3-byte sequence\\0\"\n  \"UTF-8 error: overlong 4-byte sequence\\0\"\n  /* 20 */\n  \"UTF-8 error: overlong 5-byte sequence\\0\"\n  \"UTF-8 error: overlong 6-byte sequence\\0\"\n  \"UTF-8 error: isolated byte with 0x80 bit set\\0\"\n  \"UTF-8 error: illegal byte (0xfe or 0xff)\\0\"\n  \"UTF-16 error: missing low surrogate at end\\0\"\n  /* 25 */\n  \"UTF-16 error: invalid low surrogate\\0\"\n  \"UTF-16 error: isolated low surrogate\\0\"\n  \"UTF-32 error: code points 0xd800-0xdfff are not defined\\0\"\n  \"UTF-32 error: code points greater than 0x10ffff are not defined\\0\"\n  \"bad data value\\0\"\n  /* 30 */\n  \"patterns do not all use the same character tables\\0\"\n  \"magic number missing\\0\"\n  \"pattern compiled in wrong mode: 8/16/32-bit error\\0\"\n  \"bad offset value\\0\"\n  \"bad option value\\0\"\n  /* 35 */\n  \"invalid replacement string\\0\"\n  \"bad offset into UTF string\\0\"\n  \"callout error code\\0\"              /* Never returned by PCRE2 itself */\n  \"invalid data in workspace for DFA restart\\0\"\n  \"too much recursion for DFA matching\\0\"\n  /* 40 */\n  \"backreference condition or recursion test is not supported for DFA matching\\0\"\n  \"function is not supported for DFA matching\\0\"\n  \"pattern contains an item that is not supported for DFA matching\\0\"\n  \"workspace size exceeded in DFA matching\\0\"\n  \"internal error - pattern overwritten?\\0\"\n  /* 45 */\n  \"bad JIT option\\0\"\n  \"JIT stack limit reached\\0\"\n  \"match limit exceeded\\0\"\n  \"no more memory\\0\"\n  \"unknown substring\\0\"\n  /* 50 */\n  \"non-unique substring name\\0\"\n  \"NULL argument passed\\0\"\n  \"nested recursion at the same subject position\\0\"\n  \"matching depth limit exceeded\\0\"\n  \"requested value is not available\\0\"\n  /* 55 */\n  \"requested value is not set\\0\"\n  \"offset limit set without PCRE2_USE_OFFSET_LIMIT\\0\"\n  \"bad escape sequence in replacement string\\0\"\n  \"expected closing curly bracket in replacement string\\0\"\n  \"bad substitution in replacement string\\0\"\n  /* 60 */\n  \"match with end before start or start moved backwards is not supported\\0\"\n  \"too many replacements (more than INT_MAX)\\0\"\n  \"bad serialized data\\0\"\n  \"heap limit exceeded\\0\"\n  \"invalid syntax\\0\"\n  /* 65 */\n  \"internal error - duplicate substitution match\\0\"\n  \"PCRE2_MATCH_INVALID_UTF is not supported for DFA matching\\0\"\n  ;\n\n\n/*************************************************\n*            Return error message                *\n*************************************************/\n\n/* This function copies an error message into a buffer whose units are of an\nappropriate width. Error numbers are positive for compile-time errors, and\nnegative for match-time errors (except for UTF errors), but the numbers are all\ndistinct.\n\nArguments:\n  enumber       error number\n  buffer        where to put the message (zero terminated)\n  size          size of the buffer in code units\n\nReturns:        length of message if all is well\n                negative on error\n*/\n\nPCRE2_EXP_DEFN int PCRE2_CALL_CONVENTION\npcre2_get_error_message(int enumber, PCRE2_UCHAR *buffer, PCRE2_SIZE size)\n{\nconst unsigned char *message;\nPCRE2_SIZE i;\nint n;\n\nif (size == 0) return PCRE2_ERROR_NOMEMORY;\n\nif (enumber >= COMPILE_ERROR_BASE)  /* Compile error */\n  {\n  message = compile_error_texts;\n  n = enumber - COMPILE_ERROR_BASE;\n  }\nelse if (enumber < 0)               /* Match or UTF error */\n  {\n  message = match_error_texts;\n  n = -enumber;\n  }\nelse                                /* Invalid error number */\n  {\n  message = (unsigned char *)\"\\0\";  /* Empty message list */\n  n = 1;\n  }\n\nfor (; n > 0; n--)\n  {\n  while (*message++ != CHAR_NUL) {};\n  if (*message == CHAR_NUL) return PCRE2_ERROR_BADDATA;\n  }\n\nfor (i = 0; *message != 0; i++)\n  {\n  if (i >= size - 1)\n    {\n    buffer\u00ddi\u00a8 = 0;     /* Terminate partial message */\n    return PCRE2_ERROR_NOMEMORY;\n    }\n  buffer\u00ddi\u00a8 = *message++;\n  }\n\nbuffer\u00ddi\u00a8 = 0;\nreturn (int)i;\n}\n\n/* End of pcre2_error.c */\n/*autoconv-0001 C:\\projects\\pcre2-10.35\\src\\pcre2_error.c converted to ERROR2*/\n/*autoconv-0011 ERROR2 line: 43 config.h replaced by CONFIG.h*/\n/*autoconv-0011 ERROR2 line: 46 pcre2_internal.h replaced by INTERNA2.h*/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "FINDBRA2": {"ttr": 519, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "\n/*************************************************\n*      Perl-Compatible Regular Expressions       *\n*************************************************/\n\n/* PCRE is a library of functions to support regular expressions whose syntax\nand semantics are as close as possible to those of the Perl 5 language.\n\n                       Written by Philip Hazel\n     Original API code Copyright (c) 1997-2012 University of Cambridge\n          New API code Copyright (c) 2016-2018 University of Cambridge\n\n-----------------------------------------------------------------------------\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n\n    * Redistributions of source code must retain the above copyright notice,\n      this list of conditions and the following disclaimer.\n\n    * Redistributions in binary form must reproduce the above copyright\n      notice, this list of conditions and the following disclaimer in the\n      documentation and/or other materials provided with the distribution.\n\n    * Neither the name of the University of Cambridge nor the names of its\n      contributors may be used to endorse or promote products derived from\n      this software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\nAND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\nIMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\nARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\nLIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\nCONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\nSUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\nINTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\nCONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\nARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\nPOSSIBILITY OF SUCH DAMAGE.\n-----------------------------------------------------------------------------\n*/\n\n\n/* This module contains a single function that scans through a compiled pattern\nuntil it finds a capturing bracket with the given number, or, if the number is\nnegative, an instance of OP_REVERSE for a lookbehind. The function is called\nfrom pcre2_compile.c and also from pcre2_study.c when finding the minimum\nmatching length. */\n\n\n#ifdef HAVE_CONFIG_H\n#include \"CONFIG.h\"\n#endif\n\n#include \"INTERNA2.h\"\n\n\n/*************************************************\n*    Scan compiled regex for specific bracket    *\n*************************************************/\n\n/*\nArguments:\n  code        points to start of expression\n  utf         TRUE in UTF mode\n  number      the required bracket number or negative to find a lookbehind\n\nReturns:      pointer to the opcode for the bracket, or NULL if not found\n*/\n\nPCRE2_SPTR\nPRIV(find_bracket)(PCRE2_SPTR code, BOOL utf, int number)\n{\nfor (;;)\n  {\n  PCRE2_UCHAR c = *code;\n\n  if (c == OP_END) return NULL;\n\n  /* XCLASS is used for classes that cannot be represented just by a bit map.\n  This includes negated single high-valued characters. CALLOUT_STR is used for\n  callouts with string arguments. In both cases the length in the table is\n  zero; the actual length is stored in the compiled code. */\n\n  if (c == OP_XCLASS) code += GET(code, 1);\n    else if (c == OP_CALLOUT_STR) code += GET(code, 1 + 2*LINK_SIZE);\n\n  /* Handle lookbehind */\n\n  else if (c == OP_REVERSE)\n    {\n    if (number < 0) return (PCRE2_UCHAR *)code;\n    code += PRIV(OP_lengths)\u00ddc\u00a8;\n    }\n\n  /* Handle capturing bracket */\n\n  else if (c == OP_CBRA || c == OP_SCBRA ||\n           c == OP_CBRAPOS || c == OP_SCBRAPOS)\n    {\n    int n = (int)GET2(code, 1+LINK_SIZE);\n    if (n == number) return (PCRE2_UCHAR *)code;\n    code += PRIV(OP_lengths)\u00ddc\u00a8;\n    }\n\n  /* Otherwise, we can get the item's length from the table, except that for\n  repeated character types, we have to test for \\p and \\P, which have an extra\n  two bytes of parameters, and for MARK/PRUNE/SKIP/THEN with an argument, we\n  must add in its length. */\n\n  else\n    {\n    switch(c)\n      {\n      case OP_TYPESTAR:\n      case OP_TYPEMINSTAR:\n      case OP_TYPEPLUS:\n      case OP_TYPEMINPLUS:\n      case OP_TYPEQUERY:\n      case OP_TYPEMINQUERY:\n      case OP_TYPEPOSSTAR:\n      case OP_TYPEPOSPLUS:\n      case OP_TYPEPOSQUERY:\n      if (code\u00dd1\u00a8 == OP_PROP || code\u00dd1\u00a8 == OP_NOTPROP) code += 2;\n      break;\n\n      case OP_TYPEUPTO:\n      case OP_TYPEMINUPTO:\n      case OP_TYPEEXACT:\n      case OP_TYPEPOSUPTO:\n      if (code\u00dd1 + IMM2_SIZE\u00a8 == OP_PROP || code\u00dd1 + IMM2_SIZE\u00a8 == OP_NOTPROP)\n        code += 2;\n      break;\n\n      case OP_MARK:\n      case OP_COMMIT_ARG:\n      case OP_PRUNE_ARG:\n      case OP_SKIP_ARG:\n      case OP_THEN_ARG:\n      code += code\u00dd1\u00a8;\n      break;\n      }\n\n    /* Add in the fixed length from the table */\n\n    code += PRIV(OP_lengths)\u00ddc\u00a8;\n\n  /* In UTF-8 and UTF-16 modes, opcodes that are followed by a character may be\n  followed by a multi-byte character. The length in the table is a minimum, so\n  we have to arrange to skip the extra bytes. */\n\n#ifdef MAYBE_UTF_MULTI\n    if (utf) switch(c)\n      {\n      case OP_CHAR:\n      case OP_CHARI:\n      case OP_NOT:\n      case OP_NOTI:\n      case OP_EXACT:\n      case OP_EXACTI:\n      case OP_NOTEXACT:\n      case OP_NOTEXACTI:\n      case OP_UPTO:\n      case OP_UPTOI:\n      case OP_NOTUPTO:\n      case OP_NOTUPTOI:\n      case OP_MINUPTO:\n      case OP_MINUPTOI:\n      case OP_NOTMINUPTO:\n      case OP_NOTMINUPTOI:\n      case OP_POSUPTO:\n      case OP_POSUPTOI:\n      case OP_NOTPOSUPTO:\n      case OP_NOTPOSUPTOI:\n      case OP_STAR:\n      case OP_STARI:\n      case OP_NOTSTAR:\n      case OP_NOTSTARI:\n      case OP_MINSTAR:\n      case OP_MINSTARI:\n      case OP_NOTMINSTAR:\n      case OP_NOTMINSTARI:\n      case OP_POSSTAR:\n      case OP_POSSTARI:\n      case OP_NOTPOSSTAR:\n      case OP_NOTPOSSTARI:\n      case OP_PLUS:\n      case OP_PLUSI:\n      case OP_NOTPLUS:\n      case OP_NOTPLUSI:\n      case OP_MINPLUS:\n      case OP_MINPLUSI:\n      case OP_NOTMINPLUS:\n      case OP_NOTMINPLUSI:\n      case OP_POSPLUS:\n      case OP_POSPLUSI:\n      case OP_NOTPOSPLUS:\n      case OP_NOTPOSPLUSI:\n      case OP_QUERY:\n      case OP_QUERYI:\n      case OP_NOTQUERY:\n      case OP_NOTQUERYI:\n      case OP_MINQUERY:\n      case OP_MINQUERYI:\n      case OP_NOTMINQUERY:\n      case OP_NOTMINQUERYI:\n      case OP_POSQUERY:\n      case OP_POSQUERYI:\n      case OP_NOTPOSQUERY:\n      case OP_NOTPOSQUERYI:\n      if (HAS_EXTRALEN(code\u00dd-1\u00a8)) code += GET_EXTRALEN(code\u00dd-1\u00a8);\n      break;\n      }\n#else\n    (void)(utf);  /* Keep compiler happy by referencing function argument */\n#endif  /* MAYBE_UTF_MULTI */\n    }\n  }\n}\n\n/* End of pcre2_find_bracket.c */\n/*autoconv-0001 C:\\projects\\pcre2-10.35\\src\\pcre2_find_bracket.c converted to FINDBRA2*/\n/*autoconv-0011 FINDBRA2 line: 50 config.h replaced by CONFIG.h*/\n/*autoconv-0011 FINDBRA2 line: 53 pcre2_internal.h replaced by INTERNA2.h*/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "FUZZSUP2": {"ttr": 12292, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "\n/***************************************************************************\nFuzzer driver for PCRE2. Given an arbitrary string of bytes and a length, it\ntries to compile and match it, deriving options from the string itself. If\nSTANDALONE is defined, a main program that calls the driver with the contents\nof specified files is compiled, and commentary on what is happening is output.\nIf an argument starts with '=' the rest of it it is taken as a literal string\nrather than a file name. This allows easy testing of short strings.\n\nWritten by Philip Hazel, October 2016\n***************************************************************************/\n\n#include <errno.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define PCRE2_CODE_UNIT_WIDTH 8\n#include \"PCRE2.h\"\n\n#define MAX_MATCH_SIZE 1000\n\n#define DFA_WORKSPACE_COUNT 100\n\n#define ALLOWED_COMPILE_OPTIONS \\\n  (PCRE2_ANCHORED|PCRE2_ALLOW_EMPTY_CLASS|PCRE2_ALT_BSUX|PCRE2_ALT_CIRCUMFLEX| \\\n   PCRE2_ALT_VERBNAMES|PCRE2_AUTO_CALLOUT|PCRE2_CASELESS|PCRE2_DOLLAR_ENDONLY| \\\n   PCRE2_DOTALL|PCRE2_DUPNAMES|PCRE2_ENDANCHORED|PCRE2_EXTENDED|PCRE2_FIRSTLINE| \\\n   PCRE2_MATCH_UNSET_BACKREF|PCRE2_MULTILINE|PCRE2_NEVER_BACKSLASH_C| \\\n   PCRE2_NO_AUTO_CAPTURE| \\\n   PCRE2_NO_AUTO_POSSESS|PCRE2_NO_DOTSTAR_ANCHOR|PCRE2_NO_START_OPTIMIZE| \\\n   PCRE2_UCP|PCRE2_UNGREEDY|PCRE2_USE_OFFSET_LIMIT| \\\n   PCRE2_UTF)\n\n#define ALLOWED_MATCH_OPTIONS \\\n  (PCRE2_ANCHORED|PCRE2_ENDANCHORED|PCRE2_NOTBOL|PCRE2_NOTEOL|PCRE2_NOTEMPTY| \\\n   PCRE2_NOTEMPTY_ATSTART|PCRE2_PARTIAL_HARD| \\\n   PCRE2_PARTIAL_SOFT|PCRE2_NO_JIT)\n\n/* This is the callout function. Its only purpose is to halt matching if there\nare more than 100 callouts, as one way of stopping too much time being spent on\nfruitless matches. The callout data is a pointer to the counter. */\n\nstatic int callout_function(pcre2_callout_block *cb, void *callout_data)\n{\n(void)cb;  /* Avoid unused parameter warning */\n*((uint32_t *)callout_data) += 1;\nreturn (*((uint32_t *)callout_data) > 100)? PCRE2_ERROR_CALLOUT : 0;\n}\n\n/* Putting in this apparently unnecessary prototype prevents gcc from giving a\n\"no previous prototype\" warning when compiling at high warning level. */\n\nint LLVMFuzzerTestOneInput(const unsigned char *, size_t);\n\n/* Here's the driving function. */\n\nint LLVMFuzzerTestOneInput(const unsigned char *data, size_t size)\n{\nuint32_t compile_options;\nuint32_t match_options;\npcre2_match_data *match_data = NULL;\npcre2_match_context *match_context = NULL;\nsize_t match_size;\nint dfa_workspace\u00ddDFA_WORKSPACE_COUNT\u00a8;\nint r1, r2;\nint i;\n\nif (size < 1) return 0;\n\n/* Limiting the length of the subject for matching stops fruitless searches\nin large trees taking too much time. */\n\nmatch_size = (size > MAX_MATCH_SIZE)? MAX_MATCH_SIZE : size;\n\n/* Figure out some options to use. Initialize the random number to ensure\nrepeatability. Ensure that we get a 32-bit unsigned random number for testing\noptions. (RAND_MAX is required to be at least 32767, but is commonly\n2147483647, which excludes the top bit.) */\n\nsrand((unsigned int)(data\u00ddsize/2\u00a8));\nr1 = rand();\nr2 = rand();\n\n/* Ensure that all undefined option bits are zero (waste of time trying them)\nand also that PCRE2_NO_UTF_CHECK is unset, as there is no guarantee that the\ninput is UTF-8. Also unset PCRE2_NEVER_UTF and PCRE2_NEVER_UCP as there is no\nreason to disallow UTF and UCP. Force PCRE2_NEVER_BACKSLASH_C to be set because\n\\C in random patterns is highly likely to cause a crash. */\n\ncompile_options =\n  ((((uint32_t)r1 << 16) | ((uint32_t)r2 & 0xffff)) & ALLOWED_COMPILE_OPTIONS) |\n  PCRE2_NEVER_BACKSLASH_C;\n\nmatch_options =\n  ((((uint32_t)r1 << 16) | ((uint32_t)r2 & 0xffff)) & ALLOWED_MATCH_OPTIONS);\n\n/* Discard partial matching if PCRE2_ENDANCHORED is set, because they are not\nallowed together and just give an immediate error return. */\n\nif (((compile_options|match_options) & PCRE2_ENDANCHORED) != 0)\n  match_options &= ~(PCRE2_PARTIAL_HARD|PCRE2_PARTIAL_SOFT);\n\n/* Do the compile with and without the options, and after a successful compile,\nlikewise do the match with and without the options. */\n\nfor (i = 0; i < 2; i++)\n  {\n  uint32_t callout_count;\n  int errorcode;\n  PCRE2_SIZE erroroffset;\n  pcre2_code *code;\n\n#ifdef STANDALONE\n  printf(\"Compile options %.8x never_backslash_c\", compile_options);\n  printf(\"%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s\\n\",\n    ((compile_options & PCRE2_ALT_BSUX) != 0)? \",alt_bsux\" : \"\",\n    ((compile_options & PCRE2_ALT_CIRCUMFLEX) != 0)? \",alt_circumflex\" : \"\",\n    ((compile_options & PCRE2_ALT_VERBNAMES) != 0)? \",alt_verbnames\" : \"\",\n    ((compile_options & PCRE2_ALLOW_EMPTY_CLASS) != 0)? \",allow_empty_class\" : \"\",\n    ((compile_options & PCRE2_ANCHORED) != 0)? \",anchored\" : \"\",\n    ((compile_options & PCRE2_AUTO_CALLOUT) != 0)? \",auto_callout\" : \"\",\n    ((compile_options & PCRE2_CASELESS) != 0)? \",caseless\" : \"\",\n    ((compile_options & PCRE2_DOLLAR_ENDONLY) != 0)? \",dollar_endonly\" : \"\",\n    ((compile_options & PCRE2_DOTALL) != 0)? \",dotall\" : \"\",\n    ((compile_options & PCRE2_DUPNAMES) != 0)? \",dupnames\" : \"\",\n    ((compile_options & PCRE2_ENDANCHORED) != 0)? \",endanchored\" : \"\",\n    ((compile_options & PCRE2_EXTENDED) != 0)? \",extended\" : \"\",\n    ((compile_options & PCRE2_FIRSTLINE) != 0)? \",firstline\" : \"\",\n    ((compile_options & PCRE2_MATCH_UNSET_BACKREF) != 0)? \",match_unset_backref\" : \"\",\n    ((compile_options & PCRE2_MULTILINE) != 0)? \",multiline\" : \"\",\n    ((compile_options & PCRE2_NEVER_UCP) != 0)? \",never_ucp\" : \"\",\n    ((compile_options & PCRE2_NEVER_UTF) != 0)? \",never_utf\" : \"\",\n    ((compile_options & PCRE2_NO_AUTO_CAPTURE) != 0)? \",no_auto_capture\" : \"\",\n    ((compile_options & PCRE2_NO_AUTO_POSSESS) != 0)? \",no_auto_possess\" : \"\",\n    ((compile_options & PCRE2_NO_DOTSTAR_ANCHOR) != 0)? \",no_dotstar_anchor\" : \"\",\n    ((compile_options & PCRE2_NO_UTF_CHECK) != 0)? \",no_utf_check\" : \"\",\n    ((compile_options & PCRE2_NO_START_OPTIMIZE) != 0)? \",no_start_optimize\" : \"\",\n    ((compile_options & PCRE2_UCP) != 0)? \",ucp\" : \"\",\n    ((compile_options & PCRE2_UNGREEDY) != 0)? \",ungreedy\" : \"\",\n    ((compile_options & PCRE2_USE_OFFSET_LIMIT) != 0)? \",use_offset_limit\" : \"\",\n    ((compile_options & PCRE2_UTF) != 0)? \",utf\" : \"\");\n#endif\n\n  code = pcre2_compile((PCRE2_SPTR)data, (PCRE2_SIZE)size, compile_options,\n    &errorcode, &erroroffset, NULL);\n\n  /* Compilation succeeded */\n\n  if (code != NULL)\n    {\n    int j;\n    uint32_t save_match_options = match_options;\n\n    /* Create match data and context blocks only when we first need them. Set\n    low match and depth limits to avoid wasting too much searching large\n    pattern trees. Almost all matches are going to fail. */\n\n    if (match_data == NULL)\n      {\n      match_data = pcre2_match_data_create(32, NULL);\n      if (match_data == NULL)\n        {\n#ifdef STANDALONE\n        printf(\"** Failed to create match data block\\n\");\n#endif\n        return 0;\n        }\n      }\n\n    if (match_context == NULL)\n      {\n      match_context = pcre2_match_context_create(NULL);\n      if (match_context == NULL)\n        {\n#ifdef STANDALONE\n        printf(\"** Failed to create match context block\\n\");\n#endif\n        return 0;\n        }\n      (void)pcre2_set_match_limit(match_context, 100);\n      (void)pcre2_set_depth_limit(match_context, 100);\n      (void)pcre2_set_callout(match_context, callout_function, &callout_count);\n      }\n\n    /* Match twice, with and without options. */\n\n    for (j = 0; j < 2; j++)\n      {\n#ifdef STANDALONE\n      printf(\"Match options %.8x\", match_options);\n      printf(\"%s%s%s%s%s%s%s%s%s%s\\n\",\n        ((match_options & PCRE2_ANCHORED) != 0)? \",anchored\" : \"\",\n        ((match_options & PCRE2_ENDANCHORED) != 0)? \",endanchored\" : \"\",\n        ((match_options & PCRE2_NO_JIT) != 0)? \",no_jit\" : \"\",\n        ((match_options & PCRE2_NO_UTF_CHECK) != 0)? \",no_utf_check\" : \"\",\n        ((match_options & PCRE2_NOTBOL) != 0)? \",notbol\" : \"\",\n        ((match_options & PCRE2_NOTEMPTY) != 0)? \",notempty\" : \"\",\n        ((match_options & PCRE2_NOTEMPTY_ATSTART) != 0)? \",notempty_atstart\" : \"\",\n        ((match_options & PCRE2_NOTEOL) != 0)? \",noteol\" : \"\",\n        ((match_options & PCRE2_PARTIAL_HARD) != 0)? \",partial_hard\" : \"\",\n        ((match_options & PCRE2_PARTIAL_SOFT) != 0)? \",partial_soft\" : \"\");\n#endif\n\n      callout_count = 0;\n      errorcode = pcre2_match(code, (PCRE2_SPTR)data, (PCRE2_SIZE)match_size, 0,\n        match_options, match_data, match_context);\n\n#ifdef STANDALONE\n      if (errorcode >= 0) printf(\"Match returned %d\\n\", errorcode); else\n        {\n        unsigned char buffer\u00dd256\u00a8;\n        pcre2_get_error_message(errorcode, buffer, 256);\n        printf(\"Match failed: error %d: %s\\n\", errorcode, buffer);\n        }\n#endif\n\n      match_options = 0;  /* For second time */\n      }\n\n    /* Match with DFA twice, with and without options. */\n\n    match_options = save_match_options & ~PCRE2_NO_JIT;  /* Not valid for DFA */\n\n    for (j = 0; j < 2; j++)\n      {\n#ifdef STANDALONE\n      printf(\"DFA match options %.8x\", match_options);\n      printf(\"%s%s%s%s%s%s%s%s%s\\n\",\n        ((match_options & PCRE2_ANCHORED) != 0)? \",anchored\" : \"\",\n        ((match_options & PCRE2_ENDANCHORED) != 0)? \",endanchored\" : \"\",\n        ((match_options & PCRE2_NO_UTF_CHECK) != 0)? \",no_utf_check\" : \"\",\n        ((match_options & PCRE2_NOTBOL) != 0)? \",notbol\" : \"\",\n        ((match_options & PCRE2_NOTEMPTY) != 0)? \",notempty\" : \"\",\n        ((match_options & PCRE2_NOTEMPTY_ATSTART) != 0)? \",notempty_atstart\" : \"\",\n        ((match_options & PCRE2_NOTEOL) != 0)? \",noteol\" : \"\",\n        ((match_options & PCRE2_PARTIAL_HARD) != 0)? \",partial_hard\" : \"\",\n        ((match_options & PCRE2_PARTIAL_SOFT) != 0)? \",partial_soft\" : \"\");\n#endif\n\n      callout_count = 0;\n      errorcode = pcre2_dfa_match(code, (PCRE2_SPTR)data,\n        (PCRE2_SIZE)match_size, 0, match_options, match_data, match_context,\n        dfa_workspace, DFA_WORKSPACE_COUNT);\n\n#ifdef STANDALONE\n      if (errorcode >= 0) printf(\"Match returned %d\\n\", errorcode); else\n        {\n        unsigned char buffer\u00dd256\u00a8;\n        pcre2_get_error_message(errorcode, buffer, 256);\n        printf(\"Match failed: error %d: %s\\n\", errorcode, buffer);\n        }\n#endif\n\n      match_options = 0;  /* For second time */\n      }\n\n    match_options = save_match_options;  /* Reset for the second compile */\n    pcre2_code_free(code);\n    }\n\n  /* Compilation failed */\n\n  else\n    {\n    unsigned char buffer\u00dd256\u00a8;\n    pcre2_get_error_message(errorcode, buffer, 256);\n#ifdef STANDALONE\n    printf(\"Error %d at offset %lu: %s\\n\", errorcode, erroroffset, buffer);\n#else\n    if (strstr((const char *)buffer, \"internal error\") != NULL) abort();\n#endif\n    }\n\n  compile_options = PCRE2_NEVER_BACKSLASH_C;  /* For second time */\n  }\n\nif (match_data != NULL) pcre2_match_data_free(match_data);\nif (match_context != NULL) pcre2_match_context_free(match_context);\n\nreturn 0;\n}\n\n\n/* Optional main program.  */\n\n#ifdef STANDALONE\nint main(int argc, char **argv)\n{\nint i;\n\nif (argc < 2)\n  {\n  printf(\"** No arguments given\\n\");\n  return 0;\n  }\n\nfor (i = 1; i < argc; i++)\n  {\n  size_t filelen;\n  size_t readsize;\n  unsigned char *buffer;\n  FILE *f;\n\n  /* Handle a literal string. Copy to an exact size buffer so that checks for\n  overrunning work. */\n\n  if (argv\u00ddi\u00a8\u00dd0\u00a8 == '=')\n    {\n    readsize = strlen(argv\u00ddi\u00a8) - 1;\n    printf(\"------ <Literal> ------\\n\");\n    printf(\"Length = %lu\\n\", readsize);\n    printf(\"%.*s\\n\", (int)readsize, argv\u00ddi\u00a8+1);\n    buffer = (unsigned char *)malloc(readsize);\n    if (buffer == NULL)\n      printf(\"** Failed to allocate %lu bytes of memory\\n\", readsize);\n    else\n      {\n      memcpy(buffer, argv\u00ddi\u00a8+1, readsize);\n      LLVMFuzzerTestOneInput(buffer, readsize);\n      free(buffer);\n      }\n    continue;\n    }\n\n  /* Handle a string given in a file */\n\n  f = fopen(argv\u00ddi\u00a8, \"r\");\n  if (f == NULL)\n    {\n    printf(\"** Failed to open %s: %s\\n\", argv\u00ddi\u00a8, strerror(errno));\n    continue;\n    }\n\n  printf(\"------ %s ------\\n\", argv\u00ddi\u00a8);\n\n  fseek(f, 0, SEEK_END);\n  filelen = ftell(f);\n  fseek(f, 0, SEEK_SET);\n\n  buffer = (unsigned char *)malloc(filelen);\n  if (buffer == NULL)\n    {\n    printf(\"** Failed to allocate %lu bytes of memory\\n\", filelen);\n    fclose(f);\n    continue;\n    }\n\n  readsize = fread(buffer, 1, filelen, f);\n  fclose(f);\n\n  if (readsize != filelen)\n    printf(\"** File size is %lu but fread() returned %lu\\n\", filelen, readsize);\n  else\n    {\n    printf(\"Length = %lu\\n\", filelen);\n    LLVMFuzzerTestOneInput(buffer, filelen);\n    }\n  free(buffer);\n  }\n\nreturn 0;\n}\n#endif  /* STANDALONE */\n\n/* End */\n/*autoconv-0001 C:\\projects\\pcre2-10.35\\src\\pcre2_fuzzsupport.c converted to FUZZSUP2*/\n/*autoconv-0011 FUZZSUP2 line: 18 pcre2.h replaced by PCRE2.h*/\n/*autoconv-0015 FUZZSUP2 line: 327 fopen \"rb\" replaced by \"r\"*/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "IBMSAMPL": {"ttr": 2822, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "\n\n/*\n An adaptation of some code samples provided by IBM in their published\n documentation of the POSIX functions.  This adaptation  was done for\n the sole purpose of demonstrating the difference between PCRE2 and\n POSIX.  This code is provided strictly for demonstration  purpose and\n should not be used for any other purpose.  For any other use, please\n consult with IBM copyright notes.\n-----------------------------------------------------------------------\nTHIS SOFTWARE IS PROVIDED \"AS IS\" AND ANY EXPRESS OR IMPLIED\nWARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\nMERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN\nNO EVENT SHALL THE PROVIDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\nINDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\nSERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\nHOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\nSTRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\nIN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\nPOSSIBILITY OF SUCH DAMAGE.\n */\n/* This header invokes PCRE2 headers to make the compiler\n use the PCRE2 equivalents of the traditional POSIX functions*/\n#include \"PC2PSXAP.h\"\n#ifdef COMPILE_WITH_PCRE2\nstatic unsigned char SHOULD_PRODUCE\u00dd\u00a8 = \"oneself\";\n#else\nstatic unsigned char SHOULD_PRODUCE\u00dd\u00a8 = \"oneselfsufficient\";\n#endif\n\n#include <locale.h>\n#include <stdio.h>\n#include <stdlib.h>\n\nmain() {\n    regex_t    preg;\n    char       *string = \"oneselfsufficient \";\n    char       *pattern = \"one(self|selfsufficient)\";\n    int        rc;\n    char       buffer\u00dd100\u00a8;\n    size_t     nmatch = 2;\n    regmatch_t pmatch\u00dd2\u00a8;\n\n printf(\"+++ %s %s\\n\", COMPILE_OPTION, SHOULD_PRODUCE);\n\n    if ((rc = regcomp(&preg, pattern, REG_EXTENDED)) != 0) {\n       regerror(rc, &preg, buffer, 100);\n       printf(\"regcomp() failed with '%s'\\n\", buffer);\n       exit(1);\n    }\n\n    if ((rc = regexec(&preg, string, nmatch, pmatch, 0)) != 0) {\n       printf(\"failed to ERE match '%s' with '%s',returning %d.\\n\",\n       string, pattern, rc);\n       exit (2);\n    }\n      printf(\"With the whole expression, \"\n             \"a matched substring \\\"%.*s\\\" is found at position %d to %d.\\n\",\n             pmatch\u00dd0\u00a8.rm_eo - pmatch\u00dd0\u00a8.rm_so, &string\u00ddpmatch\u00dd0\u00a8.rm_so\u00a8,\n             pmatch\u00dd0\u00a8.rm_so, pmatch\u00dd0\u00a8.rm_eo - 1);\n      printf(\"With the sub-expression, \"\n             \"a matched substring \\\"%.*s\\\" is found at position %d to %d.\\n\",\n             pmatch\u00dd1\u00a8.rm_eo - pmatch\u00dd1\u00a8.rm_so, &string\u00ddpmatch\u00dd1\u00a8.rm_so\u00a8,\n             pmatch\u00dd1\u00a8.rm_so, pmatch\u00dd1\u00a8.rm_eo - 1);\n    regfree(&preg);\n}\n/*autoconv-0001 C:\\projects\\pcre2port\\IBMSAMPL.c converted to IBMSAMPL*/\n", "mimetype": "text/x-c", "datatype": "ebcdic", "extension": ".x-c"}, "INTERNA2": {"ttr": 4097, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "\n/*************************************************\n*      Perl-Compatible Regular Expressions       *\n*************************************************/\n\n/* PCRE2 is a library of functions to support regular expressions whose syntax\nand semantics are as close as possible to those of the Perl 5 language.\n\n                       Written by Philip Hazel\n     Original API code Copyright (c) 1997-2012 University of Cambridge\n          New API code Copyright (c) 2016-2020 University of Cambridge\n\n-----------------------------------------------------------------------------\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n\n    * Redistributions of source code must retain the above copyright notice,\n      this list of conditions and the following disclaimer.\n\n    * Redistributions in binary form must reproduce the above copyright\n      notice, this list of conditions and the following disclaimer in the\n      documentation and/or other materials provided with the distribution.\n\n    * Neither the name of the University of Cambridge nor the names of its\n      contributors may be used to endorse or promote products derived from\n      this software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\nAND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\nIMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\nARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\nLIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\nCONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\nSUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\nINTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\nCONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\nARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\nPOSSIBILITY OF SUCH DAMAGE.\n-----------------------------------------------------------------------------\n*/\n\n#ifndef PCRE2_INTERNAL_H_IDEMPOTENT_GUARD\n#define PCRE2_INTERNAL_H_IDEMPOTENT_GUARD\n\n/* We do not support both EBCDIC and Unicode at the same time. The \"configure\"\nscript prevents both being selected, but not everybody uses \"configure\". EBCDIC\nis only supported for the 8-bit library, but the check for this has to be later\nin this file, because the first part is not width-dependent, and is included by\npcre2test.c with CODE_UNIT_WIDTH == 0. */\n\n#if defined EBCDIC && defined SUPPORT_UNICODE\n#error The use of both EBCDIC and SUPPORT_UNICODE is not supported.\n#endif\n\n/* Standard C headers */\n\n#include <ctype.h>\n#include <limits.h>\n#include <stddef.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n/* Macros to make boolean values more obvious. The #ifndef is to pacify\ncompiler warnings in environments where these macros are defined elsewhere.\nUnfortunately, there is no way to do the same for the typedef. */\n\ntypedef int BOOL;\n#ifndef FALSE\n#define FALSE   0\n#define TRUE    1\n#endif\n\n/* Valgrind (memcheck) support */\n\n#ifdef SUPPORT_VALGRIND\n#include <valgrind/memcheck.h>\n#endif\n\n/* -ftrivial-auto-var-init support supports initializing all local variables\nto avoid some classes of bug, but this can cause an unacceptable slowdown\nfor large on-stack arrays in hot functions. This macro lets us annotate\nsuch arrays. */\n\n#ifdef HAVE_ATTRIBUTE_UNINITIALIZED\n#define PCRE2_KEEP_UNINITIALIZED __attribute__((uninitialized))\n#else\n#define PCRE2_KEEP_UNINITIALIZED\n#endif\n\n/* Older versions of MSVC lack snprintf(). This define allows for\nwarning/error-free compilation and testing with MSVC compilers back to at least\nMSVC 10/2010. Except for VC6 (which is missing some fundamentals and fails). */\n\n#if defined(_MSC_VER) && (_MSC_VER < 1900)\n#define snprintf _snprintf\n#endif\n\n/* When compiling a DLL for Windows, the exported symbols have to be declared\nusing some MS magic. I found some useful information on this web page:\nhttp://msdn2.microsoft.com/en-us/library/y4h7bcy6(VS.80).aspx. According to the\ninformation there, using __declspec(dllexport) without \"extern\" we have a\ndefinition; with \"extern\" we have a declaration. The settings here override the\nsetting in pcre2.h (which is included below); it defines only PCRE2_EXP_DECL,\nwhich is all that is needed for applications (they just import the symbols). We\nuse:\n\n  PCRE2_EXP_DECL    for declarations\n  PCRE2_EXP_DEFN    for definitions\n\nThe reason for wrapping this in #ifndef PCRE2_EXP_DECL is so that pcre2test,\nwhich is an application, but needs to import this file in order to \"peek\" at\ninternals, can #include pcre2.h first to get an application's-eye view.\n\nIn principle, people compiling for non-Windows, non-Unix-like (i.e. uncommon,\nspecial-purpose environments) might want to stick other stuff in front of\nexported symbols. That's why, in the non-Windows case, we set PCRE2_EXP_DEFN\nonly if it is not already set. */\n\n#ifndef PCRE2_EXP_DECL\n#  ifdef _WIN32\n#    ifndef PCRE2_STATIC\n#      define PCRE2_EXP_DECL       extern __declspec(dllexport)\n#      define PCRE2_EXP_DEFN       __declspec(dllexport)\n#    else\n#      define PCRE2_EXP_DECL       extern\n#      define PCRE2_EXP_DEFN\n#    endif\n#  else\n#    ifdef __cplusplus\n#      define PCRE2_EXP_DECL       extern \"C\"\n#    else\n#      define PCRE2_EXP_DECL       extern\n#    endif\n#    ifndef PCRE2_EXP_DEFN\n#      define PCRE2_EXP_DEFN       PCRE2_EXP_DECL\n#    endif\n#  endif\n#endif\n\n/* Include the public PCRE2 header and the definitions of UCP character\nproperty values. This must follow the setting of PCRE2_EXP_DECL above. */\n\n#include \"PCRE2.h\"\n#include \"UCP2.h\"\n\n/* When PCRE2 is compiled as a C++ library, the subject pointer can be replaced\nwith a custom type. This makes it possible, for example, to allow pcre2_match()\nto process subject strings that are discontinuous by using a smart pointer\nclass. It must always be possible to inspect all of the subject string in\npcre2_match() because of the way it backtracks. */\n\n/* WARNING: This is as yet untested for PCRE2. */\n\n#ifdef CUSTOM_SUBJECT_PTR\n#undef PCRE2_SPTR\n#define PCRE2_SPTR CUSTOM_SUBJECT_PTR\n#endif\n\n/* When checking for integer overflow in pcre2_compile(), we need to handle\nlarge integers. If a 64-bit integer type is available, we can use that.\nOtherwise we have to cast to double, which of course requires floating point\narithmetic. Handle this by defining a macro for the appropriate type. */\n\n#if defined INT64_MAX || defined int64_t\n#define INT64_OR_DOUBLE int64_t\n#else\n#define INT64_OR_DOUBLE double\n#endif\n\n/* External (in the C sense) functions and tables that are private to the\nlibraries are always referenced using the PRIV macro. This makes it possible\nfor pcre2test.c to include some of the source files from the libraries using a\ndifferent PRIV definition to avoid name clashes. It also makes it clear in the\ncode that a non-static object is being referenced. */\n\n#ifndef PRIV\n#define PRIV(name) _pcre2_##name\n#endif\n\n/* When compiling for use with the Virtual Pascal compiler, these functions\nneed to have their names changed. PCRE2 must be compiled with the -DVPCOMPAT\noption on the command line. */\n\n#ifdef VPCOMPAT\n#define strlen(s)        _strlen(s)\n#define strncmp(s1,s2,m) _strncmp(s1,s2,m)\n#define memcmp(s,c,n)    _memcmp(s,c,n)\n#define memcpy(d,s,n)    _memcpy(d,s,n)\n#define memmove(d,s,n)   _memmove(d,s,n)\n#define memset(s,c,n)    _memset(s,c,n)\n#else  /* VPCOMPAT */\n\n/* Otherwise, to cope with SunOS4 and other systems that lack memmove(), define\na macro that calls an emulating function. */\n\n#ifndef HAVE_MEMMOVE\n#undef  memmove          /* Some systems may have a macro */\n#define memmove(a, b, c) PRIV(memmove)(a, b, c)\n#endif   /* not HAVE_MEMMOVE */\n#endif   /* not VPCOMPAT */\n\n/* This is an unsigned int value that no UTF character can ever have, as\nUnicode doesn't go beyond 0x0010ffff. */\n\n#define NOTACHAR 0xffffffff\n\n/* This is the largest valid UTF/Unicode code point. */\n\n#define MAX_UTF_CODE_POINT 0x10ffff\n\n/* Compile-time positive error numbers (all except UTF errors, which are\nnegative) start at this value. It should probably never be changed, in case\nsome application is checking for specific numbers. There is a copy of this\n#define in pcre2posix.c (which now no longer includes this file). Ideally, a\nway of having a single definition should be found, but as the number is\nunlikely to change, this is not a pressing issue. The original reason for\nhaving a base other than 0 was to keep the absolute values of compile-time and\nrun-time error numbers numerically different, but in the event the code does\nnot rely on this. */\n\n#define COMPILE_ERROR_BASE 100\n\n/* The initial frames vector for remembering backtracking points in\npcre2_match() is allocated on the system stack, of this size (bytes). The size\nmust be a multiple of sizeof(PCRE2_SPTR) in all environments, so making it a\nmultiple of 8 is best. Typical frame sizes are a few hundred bytes (it depends\non the number of capturing parentheses) so 20KiB handles quite a few frames. A\nlarger vector on the heap is obtained for patterns that need more frames. The\nmaximum size of this can be limited. */\n\n#define START_FRAMES_SIZE 20480\n\n/* Similarly, for DFA matching, an initial internal workspace vector is\nallocated on the stack. */\n\n#define DFA_START_RWS_SIZE 30720\n\n/* Define the default BSR convention. */\n\n#ifdef BSR_ANYCRLF\n#define BSR_DEFAULT PCRE2_BSR_ANYCRLF\n#else\n#define BSR_DEFAULT PCRE2_BSR_UNICODE\n#endif\n\n\n/* ---------------- Basic UTF-8 macros ---------------- */\n\n/* These UTF-8 macros are always defined because they are used in pcre2test for\nhandling wide characters in 16-bit and 32-bit modes, even if an 8-bit library\nis not supported. */\n\n/* Tests whether a UTF-8 code point needs extra bytes to decode. */\n\n#define HASUTF8EXTRALEN(c) ((c) >= 0xc0)\n\n/* The following macros were originally written in the form of loops that used\ndata from the tables whose names start with PRIV(utf8_table). They were\nrewritten by a user so as not to use loops, because in some environments this\ngives a significant performance advantage, and it seems never to do any harm.\n*/\n\n/* Base macro to pick up the remaining bytes of a UTF-8 character, not\nadvancing the pointer. */\n\n#define GETUTF8(c, eptr) \\\n    { \\\n    if ((c & 0x20u) == 0) \\\n      c = ((c & 0x1fu) << 6) | (eptr\u00dd1\u00a8 & 0x3fu); \\\n    else if ((c & 0x10u) == 0) \\\n      c = ((c & 0x0fu) << 12) | ((eptr\u00dd1\u00a8 & 0x3fu) << 6) | (eptr\u00dd2\u00a8 & 0x3fu); \\\n    else if ((c & 0x08u) == 0) \\\n      c = ((c & 0x07u) << 18) | ((eptr\u00dd1\u00a8 & 0x3fu) << 12) | \\\n      ((eptr\u00dd2\u00a8 & 0x3fu) << 6) | (eptr\u00dd3\u00a8 & 0x3fu); \\\n    else if ((c & 0x04u) == 0) \\\n      c = ((c & 0x03u) << 24) | ((eptr\u00dd1\u00a8 & 0x3fu) << 18) | \\\n          ((eptr\u00dd2\u00a8 & 0x3fu) << 12) | ((eptr\u00dd3\u00a8 & 0x3fu) << 6) | \\\n          (eptr\u00dd4\u00a8 & 0x3fu); \\\n    else \\\n      c = ((c & 0x01u) << 30) | ((eptr\u00dd1\u00a8 & 0x3fu) << 24) | \\\n          ((eptr\u00dd2\u00a8 & 0x3fu) << 18) | ((eptr\u00dd3\u00a8 & 0x3fu) << 12) | \\\n          ((eptr\u00dd4\u00a8 & 0x3fu) << 6) | (eptr\u00dd5\u00a8 & 0x3fu); \\\n    }\n\n/* Base macro to pick up the remaining bytes of a UTF-8 character, advancing\nthe pointer. */\n\n#define GETUTF8INC(c, eptr) \\\n    { \\\n    if ((c & 0x20u) == 0) \\\n      c = ((c & 0x1fu) << 6) | (*eptr++ & 0x3fu); \\\n    else if ((c & 0x10u) == 0) \\\n      { \\\n      c = ((c & 0x0fu) << 12) | ((*eptr & 0x3fu) << 6) | (eptr\u00dd1\u00a8 & 0x3fu); \\\n      eptr += 2; \\\n      } \\\n    else if ((c & 0x08u) == 0) \\\n      { \\\n      c = ((c & 0x07u) << 18) | ((*eptr & 0x3fu) << 12) | \\\n          ((eptr\u00dd1\u00a8 & 0x3fu) << 6) | (eptr\u00dd2\u00a8 & 0x3fu); \\\n      eptr += 3; \\\n      } \\\n    else if ((c & 0x04u) == 0) \\\n      { \\\n      c = ((c & 0x03u) << 24) | ((*eptr & 0x3fu) << 18) | \\\n          ((eptr\u00dd1\u00a8 & 0x3fu) << 12) | ((eptr\u00dd2\u00a8 & 0x3fu) << 6) | \\\n          (eptr\u00dd3\u00a8 & 0x3fu); \\\n      eptr += 4; \\\n      } \\\n    else \\\n      { \\\n      c = ((c & 0x01u) << 30) | ((*eptr & 0x3fu) << 24) | \\\n          ((eptr\u00dd1\u00a8 & 0x3fu) << 18) | ((eptr\u00dd2\u00a8 & 0x3fu) << 12) | \\\n          ((eptr\u00dd3\u00a8 & 0x3fu) << 6) | (eptr\u00dd4\u00a8 & 0x3fu); \\\n      eptr += 5; \\\n      } \\\n    }\n\n/* Base macro to pick up the remaining bytes of a UTF-8 character, not\nadvancing the pointer, incrementing the length. */\n\n#define GETUTF8LEN(c, eptr, len) \\\n    { \\\n    if ((c & 0x20u) == 0) \\\n      { \\\n      c = ((c & 0x1fu) << 6) | (eptr\u00dd1\u00a8 & 0x3fu); \\\n      len++; \\\n      } \\\n    else if ((c & 0x10u)  == 0) \\\n      { \\\n      c = ((c & 0x0fu) << 12) | ((eptr\u00dd1\u00a8 & 0x3fu) << 6) | (eptr\u00dd2\u00a8 & 0x3fu); \\\n      len += 2; \\\n      } \\\n    else if ((c & 0x08u)  == 0) \\\n      {\\\n      c = ((c & 0x07u) << 18) | ((eptr\u00dd1\u00a8 & 0x3fu) << 12) | \\\n          ((eptr\u00dd2\u00a8 & 0x3fu) << 6) | (eptr\u00dd3\u00a8 & 0x3fu); \\\n      len += 3; \\\n      } \\\n    else if ((c & 0x04u)  == 0) \\\n      { \\\n      c = ((c & 0x03u) << 24) | ((eptr\u00dd1\u00a8 & 0x3fu) << 18) | \\\n          ((eptr\u00dd2\u00a8 & 0x3fu) << 12) | ((eptr\u00dd3\u00a8 & 0x3fu) << 6) | \\\n          (eptr\u00dd4\u00a8 & 0x3fu); \\\n      len += 4; \\\n      } \\\n    else \\\n      {\\\n      c = ((c & 0x01u) << 30) | ((eptr\u00dd1\u00a8 & 0x3fu) << 24) | \\\n          ((eptr\u00dd2\u00a8 & 0x3fu) << 18) | ((eptr\u00dd3\u00a8 & 0x3fu) << 12) | \\\n          ((eptr\u00dd4\u00a8 & 0x3fu) << 6) | (eptr\u00dd5\u00a8 & 0x3fu); \\\n      len += 5; \\\n      } \\\n    }\n\n/* --------------- Whitespace macros ---------------- */\n\n/* Tests for Unicode horizontal and vertical whitespace characters must check a\nnumber of different values. Using a switch statement for this generates the\nfastest code (no loop, no memory access), and there are several places in the\ninterpreter code where this happens. In order to ensure that all the case lists\nremain in step, we use macros so that there is only one place where the lists\nare defined.\n\nThese values are also required as lists in pcre2_compile.c when processing \\h,\n\\H, \\v and \\V in a character class. The lists are defined in pcre2_tables.c,\nbut macros that define the values are here so that all the definitions are\ntogether. The lists must be in ascending character order, terminated by\nNOTACHAR (which is 0xffffffff).\n\nAny changes should ensure that the various macros are kept in step with each\nother. NOTE: The values also appear in pcre2_jit_compile.c. */\n\n/* -------------- ASCII/Unicode environments -------------- */\n\n#ifndef EBCDIC\n\n/* Character U+180E (Mongolian Vowel Separator) is not included in the list of\nspaces in the Unicode file PropList.txt, and Perl does not recognize it as a\nspace. However, in many other sources it is listed as a space and has been in\nPCRE (both APIs) for a long time. */\n\n#define HSPACE_LIST \\\n  CHAR_HT, CHAR_SPACE, CHAR_NBSP, \\\n  0x1680, 0x180e, 0x2000, 0x2001, 0x2002, 0x2003, 0x2004, 0x2005, \\\n  0x2006, 0x2007, 0x2008, 0x2009, 0x200A, 0x202f, 0x205f, 0x3000, \\\n  NOTACHAR\n\n#define HSPACE_MULTIBYTE_CASES \\\n  case 0x1680:  /* OGHAM SPACE MARK */ \\\n  case 0x180e:  /* MONGOLIAN VOWEL SEPARATOR */ \\\n  case 0x2000:  /* EN QUAD */ \\\n  case 0x2001:  /* EM QUAD */ \\\n  case 0x2002:  /* EN SPACE */ \\\n  case 0x2003:  /* EM SPACE */ \\\n  case 0x2004:  /* THREE-PER-EM SPACE */ \\\n  case 0x2005:  /* FOUR-PER-EM SPACE */ \\\n  case 0x2006:  /* SIX-PER-EM SPACE */ \\\n  case 0x2007:  /* FIGURE SPACE */ \\\n  case 0x2008:  /* PUNCTUATION SPACE */ \\\n  case 0x2009:  /* THIN SPACE */ \\\n  case 0x200A:  /* HAIR SPACE */ \\\n  case 0x202f:  /* NARROW NO-BREAK SPACE */ \\\n  case 0x205f:  /* MEDIUM MATHEMATICAL SPACE */ \\\n  case 0x3000   /* IDEOGRAPHIC SPACE */\n\n#define HSPACE_BYTE_CASES \\\n  case CHAR_HT: \\\n  case CHAR_SPACE: \\\n  case CHAR_NBSP\n\n#define HSPACE_CASES \\\n  HSPACE_BYTE_CASES: \\\n  HSPACE_MULTIBYTE_CASES\n\n#define VSPACE_LIST \\\n  CHAR_LF, CHAR_VT, CHAR_FF, CHAR_CR, CHAR_NEL, 0x2028, 0x2029, NOTACHAR\n\n#define VSPACE_MULTIBYTE_CASES \\\n  case 0x2028:    /* LINE SEPARATOR */ \\\n  case 0x2029     /* PARAGRAPH SEPARATOR */\n\n#define VSPACE_BYTE_CASES \\\n  case CHAR_LF: \\\n  case CHAR_VT: \\\n  case CHAR_FF: \\\n  case CHAR_CR: \\\n  case CHAR_NEL\n\n#define VSPACE_CASES \\\n  VSPACE_BYTE_CASES: \\\n  VSPACE_MULTIBYTE_CASES\n\n/* -------------- EBCDIC environments -------------- */\n\n#else\n#define HSPACE_LIST CHAR_HT, CHAR_SPACE, CHAR_NBSP, NOTACHAR\n\n#define HSPACE_BYTE_CASES \\\n  case CHAR_HT: \\\n  case CHAR_SPACE: \\\n  case CHAR_NBSP\n\n#define HSPACE_CASES HSPACE_BYTE_CASES\n\n#ifdef EBCDIC_NL25\n#define VSPACE_LIST \\\n  CHAR_VT, CHAR_FF, CHAR_CR, CHAR_NEL, CHAR_LF, NOTACHAR\n#else\n#define VSPACE_LIST \\\n  CHAR_VT, CHAR_FF, CHAR_CR, CHAR_LF, CHAR_NEL, NOTACHAR\n#endif\n\n#define VSPACE_BYTE_CASES \\\n  case CHAR_LF: \\\n  case CHAR_VT: \\\n  case CHAR_FF: \\\n  case CHAR_CR: \\\n  case CHAR_NEL\n\n#define VSPACE_CASES VSPACE_BYTE_CASES\n#endif  /* EBCDIC */\n\n/* -------------- End of whitespace macros -------------- */\n\n\n/* PCRE2 is able to support several different kinds of newline (CR, LF, CRLF,\n\"any\" and \"anycrlf\" at present). The following macros are used to package up\ntesting for newlines. NLBLOCK, PSSTART, and PSEND are defined in the various\nmodules to indicate in which datablock the parameters exist, and what the\nstart/end of string field names are. */\n\n#define NLTYPE_FIXED    0     /* Newline is a fixed length string */\n#define NLTYPE_ANY      1     /* Newline is any Unicode line ending */\n#define NLTYPE_ANYCRLF  2     /* Newline is CR, LF, or CRLF */\n\n/* This macro checks for a newline at the given position */\n\n#define IS_NEWLINE(p) \\\n  ((NLBLOCK->nltype != NLTYPE_FIXED)? \\\n    ((p) < NLBLOCK->PSEND && \\\n     PRIV(is_newline)((p), NLBLOCK->nltype, NLBLOCK->PSEND, \\\n       &(NLBLOCK->nllen), utf)) \\\n    : \\\n    ((p) <= NLBLOCK->PSEND - NLBLOCK->nllen && \\\n     UCHAR21TEST(p) == NLBLOCK->nl\u00dd0\u00a8 && \\\n     (NLBLOCK->nllen == 1 || UCHAR21TEST(p+1) == NLBLOCK->nl\u00dd1\u00a8)       \\\n    ) \\\n  )\n\n/* This macro checks for a newline immediately preceding the given position */\n\n#define WAS_NEWLINE(p) \\\n  ((NLBLOCK->nltype != NLTYPE_FIXED)? \\\n    ((p) > NLBLOCK->PSSTART && \\\n     PRIV(was_newline)((p), NLBLOCK->nltype, NLBLOCK->PSSTART, \\\n       &(NLBLOCK->nllen), utf)) \\\n    : \\\n    ((p) >= NLBLOCK->PSSTART + NLBLOCK->nllen && \\\n     UCHAR21TEST(p - NLBLOCK->nllen) == NLBLOCK->nl\u00dd0\u00a8 &&              \\\n     (NLBLOCK->nllen == 1 || UCHAR21TEST(p - NLBLOCK->nllen + 1) == NLBLOCK->nl\u00dd1\u00a8) \\\n    ) \\\n  )\n\n/* Private flags containing information about the compiled pattern. The first\nthree must not be changed, because whichever is set is actually the number of\nbytes in a code unit in that mode. */\n\n#define PCRE2_MODE8         0x00000001  /* compiled in 8 bit mode */\n#define PCRE2_MODE16        0x00000002  /* compiled in 16 bit mode */\n#define PCRE2_MODE32        0x00000004  /* compiled in 32 bit mode */\n#define PCRE2_FIRSTSET      0x00000010  /* first_code unit is set */\n#define PCRE2_FIRSTCASELESS 0x00000020  /* caseless first code unit */\n#define PCRE2_FIRSTMAPSET   0x00000040  /* bitmap of first code units is set */\n#define PCRE2_LASTSET       0x00000080  /* last code unit is set */\n#define PCRE2_LASTCASELESS  0x00000100  /* caseless last code unit */\n#define PCRE2_STARTLINE     0x00000200  /* start after \\n for multiline */\n#define PCRE2_JCHANGED      0x00000400  /* j option used in pattern */\n#define PCRE2_HASCRORLF     0x00000800  /* explicit \\r or \\n in pattern */\n#define PCRE2_HASTHEN       0x00001000  /* pattern contains (*THEN) */\n#define PCRE2_MATCH_EMPTY   0x00002000  /* pattern can match empty string */\n#define PCRE2_BSR_SET       0x00004000  /* BSR was set in the pattern */\n#define PCRE2_NL_SET        0x00008000  /* newline was set in the pattern */\n#define PCRE2_NOTEMPTY_SET  0x00010000  /* (*NOTEMPTY) used        ) keep */\n#define PCRE2_NE_ATST_SET   0x00020000  /* (*NOTEMPTY_ATSTART) used) together */\n#define PCRE2_DEREF_TABLES  0x00040000  /* release character tables */\n#define PCRE2_NOJIT         0x00080000  /* (*NOJIT) used */\n#define PCRE2_HASBKPORX     0x00100000  /* contains \\P, \\p, or \\X */\n#define PCRE2_DUPCAPUSED    0x00200000  /* contains (?| */\n#define PCRE2_HASBKC        0x00400000  /* contains \\C */\n#define PCRE2_HASACCEPT     0x00800000  /* contains (*ACCEPT) */\n\n#define PCRE2_MODE_MASK     (PCRE2_MODE8 | PCRE2_MODE16 | PCRE2_MODE32)\n\n/* Values for the matchedby field in a match data block. */\n\nenum { PCRE2_MATCHEDBY_INTERPRETER,     /* pcre2_match() */\n       PCRE2_MATCHEDBY_DFA_INTERPRETER, /* pcre2_dfa_match() */\n       PCRE2_MATCHEDBY_JIT };           /* pcre2_jit_match() */\n\n/* Values for the flags field in a match data block. */\n\n#define PCRE2_MD_COPIED_SUBJECT  0x01u\n\n/* Magic number to provide a small check against being handed junk. */\n\n#define MAGIC_NUMBER  0x50435245UL   /* 'PCRE' */\n\n/* The maximum remaining length of subject we are prepared to search for a\nreq_unit match from an anchored pattern. In 8-bit mode, memchr() is used and is\nmuch faster than the search loop that has to be used in 16-bit and 32-bit\nmodes. */\n\n#if PCRE2_CODE_UNIT_WIDTH == 8\n#define REQ_CU_MAX       5000\n#else\n#define REQ_CU_MAX       2000\n#endif\n\n/* Offsets for the bitmap tables in the cbits set of tables. Each table\ncontains a set of bits for a class map. Some classes are built by combining\nthese tables. */\n\n#define cbit_space     0      /* \u00dd:space:\u00a8 or \\s */\n#define cbit_xdigit   32      /* \u00dd:xdigit:\u00a8 */\n#define cbit_digit    64      /* \u00dd:digit:\u00a8 or \\d */\n#define cbit_upper    96      /* \u00dd:upper:\u00a8 */\n#define cbit_lower   128      /* \u00dd:lower:\u00a8 */\n#define cbit_word    160      /* \u00dd:word:\u00a8 or \\w */\n#define cbit_graph   192      /* \u00dd:graph:\u00a8 */\n#define cbit_print   224      /* \u00dd:print:\u00a8 */\n#define cbit_punct   256      /* \u00dd:punct:\u00a8 */\n#define cbit_cntrl   288      /* \u00dd:cntrl:\u00a8 */\n#define cbit_length  320      /* Length of the cbits table */\n\n/* Bit definitions for entries in the ctypes table. Do not change these values\nwithout checking pcre2_jit_compile.c, which has an assertion to ensure that\nctype_word has the value 16. */\n\n#define ctype_space    0x01\n#define ctype_letter   0x02\n#define ctype_lcletter 0x04\n#define ctype_digit    0x08\n#define ctype_word     0x10    /* alphanumeric or '_' */\n\n/* Offsets of the various tables from the base tables pointer, and\ntotal length of the tables. */\n\n#define lcc_offset      0                           /* Lower case */\n#define fcc_offset    256                           /* Flip case */\n#define cbits_offset  512                           /* Character classes */\n#define ctypes_offset (cbits_offset + cbit_length)  /* Character types */\n#define TABLES_LENGTH (ctypes_offset + 256)\n\n\n/* -------------------- Character and string names ------------------------ */\n\n/* If PCRE2 is to support UTF-8 on EBCDIC platforms, we cannot use normal\ncharacter constants like '*' because the compiler would emit their EBCDIC code,\nwhich is different from their ASCII/UTF-8 code. Instead we define macros for\nthe characters so that they always use the ASCII/UTF-8 code when UTF-8 support\nis enabled. When UTF-8 support is not enabled, the definitions use character\nliterals. Both character and string versions of each character are needed, and\nthere are some longer strings as well.\n\nThis means that, on EBCDIC platforms, the PCRE2 library can handle either\nEBCDIC, or UTF-8, but not both. To support both in the same compiled library\nwould need different lookups depending on whether PCRE2_UTF was set or not.\nThis would make it impossible to use characters in switch/case statements,\nwhich would reduce performance. For a theoretical use (which nobody has asked\nfor) in a minority area (EBCDIC platforms), this is not sensible. Any\napplication that did need both could compile two versions of the library, using\nmacros to give the functions distinct names. */\n\n#ifndef SUPPORT_UNICODE\n\n/* UTF-8 support is not enabled; use the platform-dependent character literals\nso that PCRE2 works in both ASCII and EBCDIC environments, but only in non-UTF\nmode. Newline characters are problematic in EBCDIC. Though it has CR and LF\ncharacters, a common practice has been to use its NL (0x15) character as the\nline terminator in C-like processing environments. However, sometimes the LF\n(0x25) character is used instead, according to this Unicode document:\n\nhttp://unicode.org/standard/reports/tr13/tr13-5.html\n\nPCRE2 defaults EBCDIC NL to 0x15, but has a build-time option to select 0x25\ninstead. Whichever is *not* chosen is defined as NEL.\n\nIn both ASCII and EBCDIC environments, CHAR_NL and CHAR_LF are synonyms for the\nsame code point. */\n\n#ifdef EBCDIC\n\n#ifndef EBCDIC_NL25\n#define CHAR_NL                     '\\x15'\n#define CHAR_NEL                    '\\x25'\n#define STR_NL                      \"\\x15\"\n#define STR_NEL                     \"\\x25\"\n#else\n#define CHAR_NL                     '\\x25'\n#define CHAR_NEL                    '\\x15'\n#define STR_NL                      \"\\x25\"\n#define STR_NEL                     \"\\x15\"\n#endif\n\n#define CHAR_LF                     CHAR_NL\n#define STR_LF                      STR_NL\n\n#define CHAR_ESC                    '\\047'\n#define CHAR_DEL                    '\\007'\n#define CHAR_NBSP                   ((unsigned char)'\\x41')\n#define STR_ESC                     \"\\047\"\n#define STR_DEL                     \"\\007\"\n\n#else  /* Not EBCDIC */\n\n/* In ASCII/Unicode, linefeed is '\\n' and we equate this to NL for\ncompatibility. NEL is the Unicode newline character; make sure it is\na positive value. */\n\n#define CHAR_LF                     '\\n'\n#define CHAR_NL                     CHAR_LF\n#define CHAR_NEL                    ((unsigned char)'\\x85')\n#define CHAR_ESC                    '\\033'\n#define CHAR_DEL                    '\\177'\n#define CHAR_NBSP                   ((unsigned char)'\\xa0')\n\n#define STR_LF                      \"\\n\"\n#define STR_NL                      STR_LF\n#define STR_NEL                     \"\\x85\"\n#define STR_ESC                     \"\\033\"\n#define STR_DEL                     \"\\177\"\n\n#endif  /* EBCDIC */\n\n/* The remaining definitions work in both environments. */\n\n#define CHAR_NUL                    '\\0'\n#define CHAR_HT                     '\\t'\n#define CHAR_VT                     '\\v'\n#define CHAR_FF                     '\\f'\n#define CHAR_CR                     '\\r'\n#define CHAR_BS                     '\\b'\n#define CHAR_BEL                    '\\a'\n\n#define CHAR_SPACE                  ' '\n#define CHAR_EXCLAMATION_MARK       '!'\n#define CHAR_QUOTATION_MARK         '\"'\n#define CHAR_NUMBER_SIGN            '#'\n#define CHAR_DOLLAR_SIGN            '$'\n#define CHAR_PERCENT_SIGN           '%'\n#define CHAR_AMPERSAND              '&'\n#define CHAR_APOSTROPHE             '\\''\n#define CHAR_LEFT_PARENTHESIS       '('\n#define CHAR_RIGHT_PARENTHESIS      ')'\n#define CHAR_ASTERISK               '*'\n#define CHAR_PLUS                   '+'\n#define CHAR_COMMA                  ','\n#define CHAR_MINUS                  '-'\n#define CHAR_DOT                    '.'\n#define CHAR_SLASH                  '/'\n#define CHAR_0                      '0'\n#define CHAR_1                      '1'\n#define CHAR_2                      '2'\n#define CHAR_3                      '3'\n#define CHAR_4                      '4'\n#define CHAR_5                      '5'\n#define CHAR_6                      '6'\n#define CHAR_7                      '7'\n#define CHAR_8                      '8'\n#define CHAR_9                      '9'\n#define CHAR_COLON                  ':'\n#define CHAR_SEMICOLON              ';'\n#define CHAR_LESS_THAN_SIGN         '<'\n#define CHAR_EQUALS_SIGN            '='\n#define CHAR_GREATER_THAN_SIGN      '>'\n#define CHAR_QUESTION_MARK          '?'\n#define CHAR_COMMERCIAL_AT          '@'\n#define CHAR_A                      'A'\n#define CHAR_B                      'B'\n#define CHAR_C                      'C'\n#define CHAR_D                      'D'\n#define CHAR_E                      'E'\n#define CHAR_F                      'F'\n#define CHAR_G                      'G'\n#define CHAR_H                      'H'\n#define CHAR_I                      'I'\n#define CHAR_J                      'J'\n#define CHAR_K                      'K'\n#define CHAR_L                      'L'\n#define CHAR_M                      'M'\n#define CHAR_N                      'N'\n#define CHAR_O                      'O'\n#define CHAR_P                      'P'\n#define CHAR_Q                      'Q'\n#define CHAR_R                      'R'\n#define CHAR_S                      'S'\n#define CHAR_T                      'T'\n#define CHAR_U                      'U'\n#define CHAR_V                      'V'\n#define CHAR_W                      'W'\n#define CHAR_X                      'X'\n#define CHAR_Y                      'Y'\n#define CHAR_Z                      'Z'\n#define CHAR_LEFT_SQUARE_BRACKET    '\u00dd'\n#define CHAR_BACKSLASH              '\\\\'\n#define CHAR_RIGHT_SQUARE_BRACKET   '\u00a8'\n#define CHAR_CIRCUMFLEX_ACCENT      '\u00ac'\n#define CHAR_UNDERSCORE             '_'\n#define CHAR_GRAVE_ACCENT           '`'\n#define CHAR_a                      'a'\n#define CHAR_b                      'b'\n#define CHAR_c                      'c'\n#define CHAR_d                      'd'\n#define CHAR_e                      'e'\n#define CHAR_f                      'f'\n#define CHAR_g                      'g'\n#define CHAR_h                      'h'\n#define CHAR_i                      'i'\n#define CHAR_j                      'j'\n#define CHAR_k                      'k'\n#define CHAR_l                      'l'\n#define CHAR_m                      'm'\n#define CHAR_n                      'n'\n#define CHAR_o                      'o'\n#define CHAR_p                      'p'\n#define CHAR_q                      'q'\n#define CHAR_r                      'r'\n#define CHAR_s                      's'\n#define CHAR_t                      't'\n#define CHAR_u                      'u'\n#define CHAR_v                      'v'\n#define CHAR_w                      'w'\n#define CHAR_x                      'x'\n#define CHAR_y                      'y'\n#define CHAR_z                      'z'\n#define CHAR_LEFT_CURLY_BRACKET     '{'\n#define CHAR_VERTICAL_LINE          '|'\n#define CHAR_RIGHT_CURLY_BRACKET    '}'\n#define CHAR_TILDE                  '~'\n\n#define STR_HT                      \"\\t\"\n#define STR_VT                      \"\\v\"\n#define STR_FF                      \"\\f\"\n#define STR_CR                      \"\\r\"\n#define STR_BS                      \"\\b\"\n#define STR_BEL                     \"\\a\"\n\n#define STR_SPACE                   \" \"\n#define STR_EXCLAMATION_MARK        \"!\"\n#define STR_QUOTATION_MARK          \"\\\"\"\n#define STR_NUMBER_SIGN             \"#\"\n#define STR_DOLLAR_SIGN             \"$\"\n#define STR_PERCENT_SIGN            \"%\"\n#define STR_AMPERSAND               \"&\"\n#define STR_APOSTROPHE              \"'\"\n#define STR_LEFT_PARENTHESIS        \"(\"\n#define STR_RIGHT_PARENTHESIS       \")\"\n#define STR_ASTERISK                \"*\"\n#define STR_PLUS                    \"+\"\n#define STR_COMMA                   \",\"\n#define STR_MINUS                   \"-\"\n#define STR_DOT                     \".\"\n#define STR_SLASH                   \"/\"\n#define STR_0                       \"0\"\n#define STR_1                       \"1\"\n#define STR_2                       \"2\"\n#define STR_3                       \"3\"\n#define STR_4                       \"4\"\n#define STR_5                       \"5\"\n#define STR_6                       \"6\"\n#define STR_7                       \"7\"\n#define STR_8                       \"8\"\n#define STR_9                       \"9\"\n#define STR_COLON                   \":\"\n#define STR_SEMICOLON               \";\"\n#define STR_LESS_THAN_SIGN          \"<\"\n#define STR_EQUALS_SIGN             \"=\"\n#define STR_GREATER_THAN_SIGN       \">\"\n#define STR_QUESTION_MARK           \"?\"\n#define STR_COMMERCIAL_AT           \"@\"\n#define STR_A                       \"A\"\n#define STR_B                       \"B\"\n#define STR_C                       \"C\"\n#define STR_D                       \"D\"\n#define STR_E                       \"E\"\n#define STR_F                       \"F\"\n#define STR_G                       \"G\"\n#define STR_H                       \"H\"\n#define STR_I                       \"I\"\n#define STR_J                       \"J\"\n#define STR_K                       \"K\"\n#define STR_L                       \"L\"\n#define STR_M                       \"M\"\n#define STR_N                       \"N\"\n#define STR_O                       \"O\"\n#define STR_P                       \"P\"\n#define STR_Q                       \"Q\"\n#define STR_R                       \"R\"\n#define STR_S                       \"S\"\n#define STR_T                       \"T\"\n#define STR_U                       \"U\"\n#define STR_V                       \"V\"\n#define STR_W                       \"W\"\n#define STR_X                       \"X\"\n#define STR_Y                       \"Y\"\n#define STR_Z                       \"Z\"\n#define STR_LEFT_SQUARE_BRACKET     \"\u00dd\"\n#define STR_BACKSLASH               \"\\\\\"\n#define STR_RIGHT_SQUARE_BRACKET    \"\u00a8\"\n#define STR_CIRCUMFLEX_ACCENT       \"\u00ac\"\n#define STR_UNDERSCORE              \"_\"\n#define STR_GRAVE_ACCENT            \"`\"\n#define STR_a                       \"a\"\n#define STR_b                       \"b\"\n#define STR_c                       \"c\"\n#define STR_d                       \"d\"\n#define STR_e                       \"e\"\n#define STR_f                       \"f\"\n#define STR_g                       \"g\"\n#define STR_h                       \"h\"\n#define STR_i                       \"i\"\n#define STR_j                       \"j\"\n#define STR_k                       \"k\"\n#define STR_l                       \"l\"\n#define STR_m                       \"m\"\n#define STR_n                       \"n\"\n#define STR_o                       \"o\"\n#define STR_p                       \"p\"\n#define STR_q                       \"q\"\n#define STR_r                       \"r\"\n#define STR_s                       \"s\"\n#define STR_t                       \"t\"\n#define STR_u                       \"u\"\n#define STR_v                       \"v\"\n#define STR_w                       \"w\"\n#define STR_x                       \"x\"\n#define STR_y                       \"y\"\n#define STR_z                       \"z\"\n#define STR_LEFT_CURLY_BRACKET      \"{\"\n#define STR_VERTICAL_LINE           \"|\"\n#define STR_RIGHT_CURLY_BRACKET     \"}\"\n#define STR_TILDE                   \"~\"\n\n#define STRING_ACCEPT0               \"ACCEPT\\0\"\n#define STRING_COMMIT0               \"COMMIT\\0\"\n#define STRING_F0                    \"F\\0\"\n#define STRING_FAIL0                 \"FAIL\\0\"\n#define STRING_MARK0                 \"MARK\\0\"\n#define STRING_PRUNE0                \"PRUNE\\0\"\n#define STRING_SKIP0                 \"SKIP\\0\"\n#define STRING_THEN                  \"THEN\"\n\n#define STRING_atomic0               \"atomic\\0\"\n#define STRING_pla0                  \"pla\\0\"\n#define STRING_plb0                  \"plb\\0\"\n#define STRING_napla0                \"napla\\0\"\n#define STRING_naplb0                \"naplb\\0\"\n#define STRING_nla0                  \"nla\\0\"\n#define STRING_nlb0                  \"nlb\\0\"\n#define STRING_sr0                   \"sr\\0\"\n#define STRING_asr0                  \"asr\\0\"\n#define STRING_positive_lookahead0   \"positive_lookahead\\0\"\n#define STRING_positive_lookbehind0  \"positive_lookbehind\\0\"\n#define STRING_non_atomic_positive_lookahead0   \"non_atomic_positive_lookahead\\0\"\n#define STRING_non_atomic_positive_lookbehind0  \"non_atomic_positive_lookbehind\\0\"\n#define STRING_negative_lookahead0   \"negative_lookahead\\0\"\n#define STRING_negative_lookbehind0  \"negative_lookbehind\\0\"\n#define STRING_script_run0           \"script_run\\0\"\n#define STRING_atomic_script_run     \"atomic_script_run\"\n\n#define STRING_alpha0                \"alpha\\0\"\n#define STRING_lower0                \"lower\\0\"\n#define STRING_upper0                \"upper\\0\"\n#define STRING_alnum0                \"alnum\\0\"\n#define STRING_ascii0                \"ascii\\0\"\n#define STRING_blank0                \"blank\\0\"\n#define STRING_cntrl0                \"cntrl\\0\"\n#define STRING_digit0                \"digit\\0\"\n#define STRING_graph0                \"graph\\0\"\n#define STRING_print0                \"print\\0\"\n#define STRING_punct0                \"punct\\0\"\n#define STRING_space0                \"space\\0\"\n#define STRING_word0                 \"word\\0\"\n#define STRING_xdigit                \"xdigit\"\n\n#define STRING_DEFINE                \"DEFINE\"\n#define STRING_VERSION               \"VERSION\"\n#define STRING_WEIRD_STARTWORD       \"\u00dd:<:\u00a8\u00a8\"\n#define STRING_WEIRD_ENDWORD         \"\u00dd:>:\u00a8\u00a8\"\n\n#define STRING_CR_RIGHTPAR                \"CR)\"\n#define STRING_LF_RIGHTPAR                \"LF)\"\n#define STRING_CRLF_RIGHTPAR              \"CRLF)\"\n#define STRING_ANY_RIGHTPAR               \"ANY)\"\n#define STRING_ANYCRLF_RIGHTPAR           \"ANYCRLF)\"\n#define STRING_NUL_RIGHTPAR               \"NUL)\"\n#define STRING_BSR_ANYCRLF_RIGHTPAR       \"BSR_ANYCRLF)\"\n#define STRING_BSR_UNICODE_RIGHTPAR       \"BSR_UNICODE)\"\n#define STRING_UTF8_RIGHTPAR              \"UTF8)\"\n#define STRING_UTF16_RIGHTPAR             \"UTF16)\"\n#define STRING_UTF32_RIGHTPAR             \"UTF32)\"\n#define STRING_UTF_RIGHTPAR               \"UTF)\"\n#define STRING_UCP_RIGHTPAR               \"UCP)\"\n#define STRING_NO_AUTO_POSSESS_RIGHTPAR   \"NO_AUTO_POSSESS)\"\n#define STRING_NO_DOTSTAR_ANCHOR_RIGHTPAR \"NO_DOTSTAR_ANCHOR)\"\n#define STRING_NO_JIT_RIGHTPAR            \"NO_JIT)\"\n#define STRING_NO_START_OPT_RIGHTPAR      \"NO_START_OPT)\"\n#define STRING_NOTEMPTY_RIGHTPAR          \"NOTEMPTY)\"\n#define STRING_NOTEMPTY_ATSTART_RIGHTPAR  \"NOTEMPTY_ATSTART)\"\n#define STRING_LIMIT_HEAP_EQ              \"LIMIT_HEAP=\"\n#define STRING_LIMIT_MATCH_EQ             \"LIMIT_MATCH=\"\n#define STRING_LIMIT_DEPTH_EQ             \"LIMIT_DEPTH=\"\n#define STRING_LIMIT_RECURSION_EQ         \"LIMIT_RECURSION=\"\n#define STRING_MARK                       \"MARK\"\n\n#else  /* SUPPORT_UNICODE */\n\n/* UTF-8 support is enabled; always use UTF-8 (=ASCII) character codes. This\nworks in both modes non-EBCDIC platforms, and on EBCDIC platforms in UTF-8 mode\nonly. */\n\n#define CHAR_HT                     '\\011'\n#define CHAR_VT                     '\\013'\n#define CHAR_FF                     '\\014'\n#define CHAR_CR                     '\\015'\n#define CHAR_LF                     '\\012'\n#define CHAR_NL                     CHAR_LF\n#define CHAR_NEL                    ((unsigned char)'\\x85')\n#define CHAR_BS                     '\\010'\n#define CHAR_BEL                    '\\007'\n#define CHAR_ESC                    '\\033'\n#define CHAR_DEL                    '\\177'\n\n#define CHAR_NUL                    '\\0'\n#define CHAR_SPACE                  '\\040'\n#define CHAR_EXCLAMATION_MARK       '\\041'\n#define CHAR_QUOTATION_MARK         '\\042'\n#define CHAR_NUMBER_SIGN            '\\043'\n#define CHAR_DOLLAR_SIGN            '\\044'\n#define CHAR_PERCENT_SIGN           '\\045'\n#define CHAR_AMPERSAND              '\\046'\n#define CHAR_APOSTROPHE             '\\047'\n#define CHAR_LEFT_PARENTHESIS       '\\050'\n#define CHAR_RIGHT_PARENTHESIS      '\\051'\n#define CHAR_ASTERISK               '\\052'\n#define CHAR_PLUS                   '\\053'\n#define CHAR_COMMA                  '\\054'\n#define CHAR_MINUS                  '\\055'\n#define CHAR_DOT                    '\\056'\n#define CHAR_SLASH                  '\\057'\n#define CHAR_0                      '\\060'\n#define CHAR_1                      '\\061'\n#define CHAR_2                      '\\062'\n#define CHAR_3                      '\\063'\n#define CHAR_4                      '\\064'\n#define CHAR_5                      '\\065'\n#define CHAR_6                      '\\066'\n#define CHAR_7                      '\\067'\n#define CHAR_8                      '\\070'\n#define CHAR_9                      '\\071'\n#define CHAR_COLON                  '\\072'\n#define CHAR_SEMICOLON              '\\073'\n#define CHAR_LESS_THAN_SIGN         '\\074'\n#define CHAR_EQUALS_SIGN            '\\075'\n#define CHAR_GREATER_THAN_SIGN      '\\076'\n#define CHAR_QUESTION_MARK          '\\077'\n#define CHAR_COMMERCIAL_AT          '\\100'\n#define CHAR_A                      '\\101'\n#define CHAR_B                      '\\102'\n#define CHAR_C                      '\\103'\n#define CHAR_D                      '\\104'\n#define CHAR_E                      '\\105'\n#define CHAR_F                      '\\106'\n#define CHAR_G                      '\\107'\n#define CHAR_H                      '\\110'\n#define CHAR_I                      '\\111'\n#define CHAR_J                      '\\112'\n#define CHAR_K                      '\\113'\n#define CHAR_L                      '\\114'\n#define CHAR_M                      '\\115'\n#define CHAR_N                      '\\116'\n#define CHAR_O                      '\\117'\n#define CHAR_P                      '\\120'\n#define CHAR_Q                      '\\121'\n#define CHAR_R                      '\\122'\n#define CHAR_S                      '\\123'\n#define CHAR_T                      '\\124'\n#define CHAR_U                      '\\125'\n#define CHAR_V                      '\\126'\n#define CHAR_W                      '\\127'\n#define CHAR_X                      '\\130'\n#define CHAR_Y                      '\\131'\n#define CHAR_Z                      '\\132'\n#define CHAR_LEFT_SQUARE_BRACKET    '\\133'\n#define CHAR_BACKSLASH              '\\134'\n#define CHAR_RIGHT_SQUARE_BRACKET   '\\135'\n#define CHAR_CIRCUMFLEX_ACCENT      '\\136'\n#define CHAR_UNDERSCORE             '\\137'\n#define CHAR_GRAVE_ACCENT           '\\140'\n#define CHAR_a                      '\\141'\n#define CHAR_b                      '\\142'\n#define CHAR_c                      '\\143'\n#define CHAR_d                      '\\144'\n#define CHAR_e                      '\\145'\n#define CHAR_f                      '\\146'\n#define CHAR_g                      '\\147'\n#define CHAR_h                      '\\150'\n#define CHAR_i                      '\\151'\n#define CHAR_j                      '\\152'\n#define CHAR_k                      '\\153'\n#define CHAR_l                      '\\154'\n#define CHAR_m                      '\\155'\n#define CHAR_n                      '\\156'\n#define CHAR_o                      '\\157'\n#define CHAR_p                      '\\160'\n#define CHAR_q                      '\\161'\n#define CHAR_r                      '\\162'\n#define CHAR_s                      '\\163'\n#define CHAR_t                      '\\164'\n#define CHAR_u                      '\\165'\n#define CHAR_v                      '\\166'\n#define CHAR_w                      '\\167'\n#define CHAR_x                      '\\170'\n#define CHAR_y                      '\\171'\n#define CHAR_z                      '\\172'\n#define CHAR_LEFT_CURLY_BRACKET     '\\173'\n#define CHAR_VERTICAL_LINE          '\\174'\n#define CHAR_RIGHT_CURLY_BRACKET    '\\175'\n#define CHAR_TILDE                  '\\176'\n#define CHAR_NBSP                   ((unsigned char)'\\xa0')\n\n#define STR_HT                      \"\\011\"\n#define STR_VT                      \"\\013\"\n#define STR_FF                      \"\\014\"\n#define STR_CR                      \"\\015\"\n#define STR_NL                      \"\\012\"\n#define STR_BS                      \"\\010\"\n#define STR_BEL                     \"\\007\"\n#define STR_ESC                     \"\\033\"\n#define STR_DEL                     \"\\177\"\n\n#define STR_SPACE                   \"\\040\"\n#define STR_EXCLAMATION_MARK        \"\\041\"\n#define STR_QUOTATION_MARK          \"\\042\"\n#define STR_NUMBER_SIGN             \"\\043\"\n#define STR_DOLLAR_SIGN             \"\\044\"\n#define STR_PERCENT_SIGN            \"\\045\"\n#define STR_AMPERSAND               \"\\046\"\n#define STR_APOSTROPHE              \"\\047\"\n#define STR_LEFT_PARENTHESIS        \"\\050\"\n#define STR_RIGHT_PARENTHESIS       \"\\051\"\n#define STR_ASTERISK                \"\\052\"\n#define STR_PLUS                    \"\\053\"\n#define STR_COMMA                   \"\\054\"\n#define STR_MINUS                   \"\\055\"\n#define STR_DOT                     \"\\056\"\n#define STR_SLASH                   \"\\057\"\n#define STR_0                       \"\\060\"\n#define STR_1                       \"\\061\"\n#define STR_2                       \"\\062\"\n#define STR_3                       \"\\063\"\n#define STR_4                       \"\\064\"\n#define STR_5                       \"\\065\"\n#define STR_6                       \"\\066\"\n#define STR_7                       \"\\067\"\n#define STR_8                       \"\\070\"\n#define STR_9                       \"\\071\"\n#define STR_COLON                   \"\\072\"\n#define STR_SEMICOLON               \"\\073\"\n#define STR_LESS_THAN_SIGN          \"\\074\"\n#define STR_EQUALS_SIGN             \"\\075\"\n#define STR_GREATER_THAN_SIGN       \"\\076\"\n#define STR_QUESTION_MARK           \"\\077\"\n#define STR_COMMERCIAL_AT           \"\\100\"\n#define STR_A                       \"\\101\"\n#define STR_B                       \"\\102\"\n#define STR_C                       \"\\103\"\n#define STR_D                       \"\\104\"\n#define STR_E                       \"\\105\"\n#define STR_F                       \"\\106\"\n#define STR_G                       \"\\107\"\n#define STR_H                       \"\\110\"\n#define STR_I                       \"\\111\"\n#define STR_J                       \"\\112\"\n#define STR_K                       \"\\113\"\n#define STR_L                       \"\\114\"\n#define STR_M                       \"\\115\"\n#define STR_N                       \"\\116\"\n#define STR_O                       \"\\117\"\n#define STR_P                       \"\\120\"\n#define STR_Q                       \"\\121\"\n#define STR_R                       \"\\122\"\n#define STR_S                       \"\\123\"\n#define STR_T                       \"\\124\"\n#define STR_U                       \"\\125\"\n#define STR_V                       \"\\126\"\n#define STR_W                       \"\\127\"\n#define STR_X                       \"\\130\"\n#define STR_Y                       \"\\131\"\n#define STR_Z                       \"\\132\"\n#define STR_LEFT_SQUARE_BRACKET     \"\\133\"\n#define STR_BACKSLASH               \"\\134\"\n#define STR_RIGHT_SQUARE_BRACKET    \"\\135\"\n#define STR_CIRCUMFLEX_ACCENT       \"\\136\"\n#define STR_UNDERSCORE              \"\\137\"\n#define STR_GRAVE_ACCENT            \"\\140\"\n#define STR_a                       \"\\141\"\n#define STR_b                       \"\\142\"\n#define STR_c                       \"\\143\"\n#define STR_d                       \"\\144\"\n#define STR_e                       \"\\145\"\n#define STR_f                       \"\\146\"\n#define STR_g                       \"\\147\"\n#define STR_h                       \"\\150\"\n#define STR_i                       \"\\151\"\n#define STR_j                       \"\\152\"\n#define STR_k                       \"\\153\"\n#define STR_l                       \"\\154\"\n#define STR_m                       \"\\155\"\n#define STR_n                       \"\\156\"\n#define STR_o                       \"\\157\"\n#define STR_p                       \"\\160\"\n#define STR_q                       \"\\161\"\n#define STR_r                       \"\\162\"\n#define STR_s                       \"\\163\"\n#define STR_t                       \"\\164\"\n#define STR_u                       \"\\165\"\n#define STR_v                       \"\\166\"\n#define STR_w                       \"\\167\"\n#define STR_x                       \"\\170\"\n#define STR_y                       \"\\171\"\n#define STR_z                       \"\\172\"\n#define STR_LEFT_CURLY_BRACKET      \"\\173\"\n#define STR_VERTICAL_LINE           \"\\174\"\n#define STR_RIGHT_CURLY_BRACKET     \"\\175\"\n#define STR_TILDE                   \"\\176\"\n\n#define STRING_ACCEPT0               STR_A STR_C STR_C STR_E STR_P STR_T \"\\0\"\n#define STRING_COMMIT0               STR_C STR_O STR_M STR_M STR_I STR_T \"\\0\"\n#define STRING_F0                    STR_F \"\\0\"\n#define STRING_FAIL0                 STR_F STR_A STR_I STR_L \"\\0\"\n#define STRING_MARK0                 STR_M STR_A STR_R STR_K \"\\0\"\n#define STRING_PRUNE0                STR_P STR_R STR_U STR_N STR_E \"\\0\"\n#define STRING_SKIP0                 STR_S STR_K STR_I STR_P \"\\0\"\n#define STRING_THEN                  STR_T STR_H STR_E STR_N\n\n#define STRING_atomic0               STR_a STR_t STR_o STR_m STR_i STR_c \"\\0\"\n#define STRING_pla0                  STR_p STR_l STR_a \"\\0\"\n#define STRING_plb0                  STR_p STR_l STR_b \"\\0\"\n#define STRING_napla0                STR_n STR_a STR_p STR_l STR_a \"\\0\"\n#define STRING_naplb0                STR_n STR_a STR_p STR_l STR_b \"\\0\"\n#define STRING_nla0                  STR_n STR_l STR_a \"\\0\"\n#define STRING_nlb0                  STR_n STR_l STR_b \"\\0\"\n#define STRING_sr0                   STR_s STR_r \"\\0\"\n#define STRING_asr0                  STR_a STR_s STR_r \"\\0\"\n#define STRING_positive_lookahead0   STR_p STR_o STR_s STR_i STR_t STR_i STR_v STR_e STR_UNDERSCORE STR_l STR_o STR_o STR_k STR_a STR_h STR_e STR_a STR_d \"\\0\"\n#define STRING_positive_lookbehind0  STR_p STR_o STR_s STR_i STR_t STR_i STR_v STR_e STR_UNDERSCORE STR_l STR_o STR_o STR_k STR_b STR_e STR_h STR_i STR_n STR_d \"\\0\"\n#define STRING_non_atomic_positive_lookahead0   STR_n STR_o STR_n STR_UNDERSCORE STR_a STR_t STR_o STR_m STR_i STR_c STR_UNDERSCORE STR_p STR_o STR_s STR_i STR_t STR_i STR_v STR_e STR_UNDERSCORE STR_l STR_o STR_o STR_k STR_a STR_h STR_e STR_a STR_d \"\\\n0\"\n#define STRING_non_atomic_positive_lookbehind0  STR_n STR_o STR_n STR_UNDERSCORE STR_a STR_t STR_o STR_m STR_i STR_c STR_UNDERSCORE STR_p STR_o STR_s STR_i STR_t STR_i STR_v STR_e STR_UNDERSCORE STR_l STR_o STR_o STR_k STR_b STR_e STR_h STR_i STR_n ST\nR_d \"\\0\"\n#define STRING_negative_lookahead0   STR_n STR_e STR_g STR_a STR_t STR_i STR_v STR_e STR_UNDERSCORE STR_l STR_o STR_o STR_k STR_a STR_h STR_e STR_a STR_d \"\\0\"\n#define STRING_negative_lookbehind0  STR_n STR_e STR_g STR_a STR_t STR_i STR_v STR_e STR_UNDERSCORE STR_l STR_o STR_o STR_k STR_b STR_e STR_h STR_i STR_n STR_d \"\\0\"\n#define STRING_script_run0           STR_s STR_c STR_r STR_i STR_p STR_t STR_UNDERSCORE STR_r STR_u STR_n \"\\0\"\n#define STRING_atomic_script_run     STR_a STR_t STR_o STR_m STR_i STR_c STR_UNDERSCORE STR_s STR_c STR_r STR_i STR_p STR_t STR_UNDERSCORE STR_r STR_u STR_n\n\n#define STRING_alpha0                STR_a STR_l STR_p STR_h STR_a \"\\0\"\n#define STRING_lower0                STR_l STR_o STR_w STR_e STR_r \"\\0\"\n#define STRING_upper0                STR_u STR_p STR_p STR_e STR_r \"\\0\"\n#define STRING_alnum0                STR_a STR_l STR_n STR_u STR_m \"\\0\"\n#define STRING_ascii0                STR_a STR_s STR_c STR_i STR_i \"\\0\"\n#define STRING_blank0                STR_b STR_l STR_a STR_n STR_k \"\\0\"\n#define STRING_cntrl0                STR_c STR_n STR_t STR_r STR_l \"\\0\"\n#define STRING_digit0                STR_d STR_i STR_g STR_i STR_t \"\\0\"\n#define STRING_graph0                STR_g STR_r STR_a STR_p STR_h \"\\0\"\n#define STRING_print0                STR_p STR_r STR_i STR_n STR_t \"\\0\"\n#define STRING_punct0                STR_p STR_u STR_n STR_c STR_t \"\\0\"\n#define STRING_space0                STR_s STR_p STR_a STR_c STR_e \"\\0\"\n#define STRING_word0                 STR_w STR_o STR_r STR_d       \"\\0\"\n#define STRING_xdigit                STR_x STR_d STR_i STR_g STR_i STR_t\n\n#define STRING_DEFINE                STR_D STR_E STR_F STR_I STR_N STR_E\n#define STRING_VERSION               STR_V STR_E STR_R STR_S STR_I STR_O STR_N\n#define STRING_WEIRD_STARTWORD       STR_LEFT_SQUARE_BRACKET STR_COLON STR_LESS_THAN_SIGN STR_COLON STR_RIGHT_SQUARE_BRACKET STR_RIGHT_SQUARE_BRACKET\n#define STRING_WEIRD_ENDWORD         STR_LEFT_SQUARE_BRACKET STR_COLON STR_GREATER_THAN_SIGN STR_COLON STR_RIGHT_SQUARE_BRACKET STR_RIGHT_SQUARE_BRACKET\n\n#define STRING_CR_RIGHTPAR                STR_C STR_R STR_RIGHT_PARENTHESIS\n#define STRING_LF_RIGHTPAR                STR_L STR_F STR_RIGHT_PARENTHESIS\n#define STRING_CRLF_RIGHTPAR              STR_C STR_R STR_L STR_F STR_RIGHT_PARENTHESIS\n#define STRING_ANY_RIGHTPAR               STR_A STR_N STR_Y STR_RIGHT_PARENTHESIS\n#define STRING_ANYCRLF_RIGHTPAR           STR_A STR_N STR_Y STR_C STR_R STR_L STR_F STR_RIGHT_PARENTHESIS\n#define STRING_NUL_RIGHTPAR               STR_N STR_U STR_L STR_RIGHT_PARENTHESIS\n#define STRING_BSR_ANYCRLF_RIGHTPAR       STR_B STR_S STR_R STR_UNDERSCORE STR_A STR_N STR_Y STR_C STR_R STR_L STR_F STR_RIGHT_PARENTHESIS\n#define STRING_BSR_UNICODE_RIGHTPAR       STR_B STR_S STR_R STR_UNDERSCORE STR_U STR_N STR_I STR_C STR_O STR_D STR_E STR_RIGHT_PARENTHESIS\n#define STRING_UTF8_RIGHTPAR              STR_U STR_T STR_F STR_8 STR_RIGHT_PARENTHESIS\n#define STRING_UTF16_RIGHTPAR             STR_U STR_T STR_F STR_1 STR_6 STR_RIGHT_PARENTHESIS\n#define STRING_UTF32_RIGHTPAR             STR_U STR_T STR_F STR_3 STR_2 STR_RIGHT_PARENTHESIS\n#define STRING_UTF_RIGHTPAR               STR_U STR_T STR_F STR_RIGHT_PARENTHESIS\n#define STRING_UCP_RIGHTPAR               STR_U STR_C STR_P STR_RIGHT_PARENTHESIS\n#define STRING_NO_AUTO_POSSESS_RIGHTPAR   STR_N STR_O STR_UNDERSCORE STR_A STR_U STR_T STR_O STR_UNDERSCORE STR_P STR_O STR_S STR_S STR_E STR_S STR_S STR_RIGHT_PARENTHESIS\n#define STRING_NO_DOTSTAR_ANCHOR_RIGHTPAR STR_N STR_O STR_UNDERSCORE STR_D STR_O STR_T STR_S STR_T STR_A STR_R STR_UNDERSCORE STR_A STR_N STR_C STR_H STR_O STR_R STR_RIGHT_PARENTHESIS\n#define STRING_NO_JIT_RIGHTPAR            STR_N STR_O STR_UNDERSCORE STR_J STR_I STR_T STR_RIGHT_PARENTHESIS\n#define STRING_NO_START_OPT_RIGHTPAR      STR_N STR_O STR_UNDERSCORE STR_S STR_T STR_A STR_R STR_T STR_UNDERSCORE STR_O STR_P STR_T STR_RIGHT_PARENTHESIS\n#define STRING_NOTEMPTY_RIGHTPAR          STR_N STR_O STR_T STR_E STR_M STR_P STR_T STR_Y STR_RIGHT_PARENTHESIS\n#define STRING_NOTEMPTY_ATSTART_RIGHTPAR  STR_N STR_O STR_T STR_E STR_M STR_P STR_T STR_Y STR_UNDERSCORE STR_A STR_T STR_S STR_T STR_A STR_R STR_T STR_RIGHT_PARENTHESIS\n#define STRING_LIMIT_HEAP_EQ              STR_L STR_I STR_M STR_I STR_T STR_UNDERSCORE STR_H STR_E STR_A STR_P STR_EQUALS_SIGN\n#define STRING_LIMIT_MATCH_EQ             STR_L STR_I STR_M STR_I STR_T STR_UNDERSCORE STR_M STR_A STR_T STR_C STR_H STR_EQUALS_SIGN\n#define STRING_LIMIT_DEPTH_EQ             STR_L STR_I STR_M STR_I STR_T STR_UNDERSCORE STR_D STR_E STR_P STR_T STR_H STR_EQUALS_SIGN\n#define STRING_LIMIT_RECURSION_EQ         STR_L STR_I STR_M STR_I STR_T STR_UNDERSCORE STR_R STR_E STR_C STR_U STR_R STR_S STR_I STR_O STR_N STR_EQUALS_SIGN\n#define STRING_MARK                       STR_M STR_A STR_R STR_K\n\n#endif  /* SUPPORT_UNICODE */\n\n/* -------------------- End of character and string names -------------------*/\n\n/* -------------------- Definitions for compiled patterns -------------------*/\n\n/* Codes for different types of Unicode property */\n\n#define PT_ANY        0    /* Any property - matches all chars */\n#define PT_LAMP       1    /* L& - the union of Lu, Ll, Lt */\n#define PT_GC         2    /* Specified general characteristic (e.g. L) */\n#define PT_PC         3    /* Specified particular characteristic (e.g. Lu) */\n#define PT_SC         4    /* Script (e.g. Han) */\n#define PT_ALNUM      5    /* Alphanumeric - the union of L and N */\n#define PT_SPACE      6    /* Perl space - Z plus 9,10,12,13 */\n#define PT_PXSPACE    7    /* POSIX space - Z plus 9,10,11,12,13 */\n#define PT_WORD       8    /* Word - L plus N plus underscore */\n#define PT_CLIST      9    /* Pseudo-property: match character list */\n#define PT_UCNC      10    /* Universal Character nameable character */\n#define PT_TABSIZE   11    /* Size of square table for autopossessify tests */\n\n/* The following special properties are used only in XCLASS items, when POSIX\nclasses are specified and PCRE2_UCP is set - in other words, for Unicode\nhandling of these classes. They are not available via the \\p or \\P escapes like\nthose in the above list, and so they do not take part in the autopossessifying\ntable. */\n\n#define PT_PXGRAPH   11    /* \u00dd:graph:\u00a8 - characters that mark the paper */\n#define PT_PXPRINT   12    /* \u00dd:print:\u00a8 - \u00dd:graph:\u00a8 plus non-control spaces */\n#define PT_PXPUNCT   13    /* \u00dd:punct:\u00a8 - punctuation characters */\n\n/* Flag bits and data types for the extended class (OP_XCLASS) for classes that\ncontain characters with values greater than 255. */\n\n#define XCL_NOT       0x01    /* Flag: this is a negative class */\n#define XCL_MAP       0x02    /* Flag: a 32-byte map is present */\n#define XCL_HASPROP   0x04    /* Flag: property checks are present. */\n\n#define XCL_END       0    /* Marks end of individual items */\n#define XCL_SINGLE    1    /* Single item (one multibyte char) follows */\n#define XCL_RANGE     2    /* A range (two multibyte chars) follows */\n#define XCL_PROP      3    /* Unicode property (2-byte property code follows) */\n#define XCL_NOTPROP   4    /* Unicode inverted property (ditto) */\n\n/* These are escaped items that aren't just an encoding of a particular data\nvalue such as \\n. They must have non-zero values, as check_escape() returns 0\nfor a data character. In the escapes\u00dd\u00a8 table in pcre2_compile.c their values\nare negated in order to distinguish them from data values.\n\nThey must appear here in the same order as in the opcode definitions below, up\nto ESC_z. There's a dummy for OP_ALLANY because it corresponds to \".\" in DOTALL\nmode rather than an escape sequence. It is also used for \u00dd\u00ac\u00a8 in JavaScript\ncompatibility mode, and for \\C in non-utf mode. In non-DOTALL mode, \".\" behaves\nlike \\N.\n\nNegative numbers are used to encode a backreference (\\1, \\2, \\3, etc.) in\ncheck_escape(). There are tests in the code for an escape greater than ESC_b\nand less than ESC_Z to detect the types that may be repeated. These are the\ntypes that consume characters. If any new escapes are put in between that don't\nconsume a character, that code will have to change. */\n\nenum { ESC_A = 1, ESC_G, ESC_K, ESC_B, ESC_b, ESC_D, ESC_d, ESC_S, ESC_s,\n       ESC_W, ESC_w, ESC_N, ESC_dum, ESC_C, ESC_P, ESC_p, ESC_R, ESC_H,\n       ESC_h, ESC_V, ESC_v, ESC_X, ESC_Z, ESC_z,\n       ESC_E, ESC_Q, ESC_g, ESC_k };\n\n\n/********************** Opcode definitions ******************/\n\n/****** NOTE NOTE NOTE ******\n\nStarting from 1 (i.e. after OP_END), the values up to OP_EOD must correspond in\norder to the list of escapes immediately above. Furthermore, values up to\nOP_DOLLM must not be changed without adjusting the table called autoposstab in\npcre2_auto_possess.c.\n\nWhenever this list is updated, the two macro definitions that follow must be\nupdated to match. The possessification table called \"opcode_possessify\" in\npcre2_compile.c must also be updated, and also the tables called \"coptable\"\nand \"poptable\" in pcre2_dfa_match.c.\n\n****** NOTE NOTE NOTE ******/\n\n\n/* The values between FIRST_AUTOTAB_OP and LAST_AUTOTAB_RIGHT_OP, inclusive,\nare used in a table for deciding whether a repeated character type can be\nauto-possessified. */\n\n#define FIRST_AUTOTAB_OP       OP_NOT_DIGIT\n#define LAST_AUTOTAB_LEFT_OP   OP_EXTUNI\n#define LAST_AUTOTAB_RIGHT_OP  OP_DOLLM\n\nenum {\n  OP_END,            /* 0 End of pattern */\n\n  /* Values corresponding to backslashed metacharacters */\n\n  OP_SOD,            /* 1 Start of data: \\A */\n  OP_SOM,            /* 2 Start of match (subject + offset): \\G */\n  OP_SET_SOM,        /* 3 Set start of match (\\K) */\n  OP_NOT_WORD_BOUNDARY,  /*  4 \\B */\n  OP_WORD_BOUNDARY,      /*  5 \\b */\n  OP_NOT_DIGIT,          /*  6 \\D */\n  OP_DIGIT,              /*  7 \\d */\n  OP_NOT_WHITESPACE,     /*  8 \\S */\n  OP_WHITESPACE,         /*  9 \\s */\n  OP_NOT_WORDCHAR,       /* 10 \\W */\n  OP_WORDCHAR,           /* 11 \\w */\n\n  OP_ANY,            /* 12 Match any character except newline (\\N) */\n  OP_ALLANY,         /* 13 Match any character */\n  OP_ANYBYTE,        /* 14 Match any byte (\\C); different to OP_ANY for UTF-8 */\n  OP_NOTPROP,        /* 15 \\P (not Unicode property) */\n  OP_PROP,           /* 16 \\p (Unicode property) */\n  OP_ANYNL,          /* 17 \\R (any newline sequence) */\n  OP_NOT_HSPACE,     /* 18 \\H (not horizontal whitespace) */\n  OP_HSPACE,         /* 19 \\h (horizontal whitespace) */\n  OP_NOT_VSPACE,     /* 20 \\V (not vertical whitespace) */\n  OP_VSPACE,         /* 21 \\v (vertical whitespace) */\n  OP_EXTUNI,         /* 22 \\X (extended Unicode sequence */\n  OP_EODN,           /* 23 End of data or \\n at end of data (\\Z) */\n  OP_EOD,            /* 24 End of data (\\z) */\n\n  /* Line end assertions */\n\n  OP_DOLL,           /* 25 End of line - not multiline */\n  OP_DOLLM,          /* 26 End of line - multiline */\n  OP_CIRC,           /* 27 Start of line - not multiline */\n  OP_CIRCM,          /* 28 Start of line - multiline */\n\n  /* Single characters; caseful must precede the caseless ones, and these\n  must remain in this order, and adjacent. */\n\n  OP_CHAR,           /* 29 Match one character, casefully */\n  OP_CHARI,          /* 30 Match one character, caselessly */\n  OP_NOT,            /* 31 Match one character, not the given one, casefully */\n  OP_NOTI,           /* 32 Match one character, not the given one, caselessly */\n\n  /* The following sets of 13 opcodes must always be kept in step because\n  the offset from the first one is used to generate the others. */\n\n  /* Repeated characters; caseful must precede the caseless ones */\n\n  OP_STAR,           /* 33 The maximizing and minimizing versions of */\n  OP_MINSTAR,        /* 34 these six opcodes must come in pairs, with */\n  OP_PLUS,           /* 35 the minimizing one second. */\n  OP_MINPLUS,        /* 36 */\n  OP_QUERY,          /* 37 */\n  OP_MINQUERY,       /* 38 */\n\n  OP_UPTO,           /* 39 From 0 to n matches of one character, caseful*/\n  OP_MINUPTO,        /* 40 */\n  OP_EXACT,          /* 41 Exactly n matches */\n\n  OP_POSSTAR,        /* 42 Possessified star, caseful */\n  OP_POSPLUS,        /* 43 Possessified plus, caseful */\n  OP_POSQUERY,       /* 44 Posesssified query, caseful */\n  OP_POSUPTO,        /* 45 Possessified upto, caseful */\n\n  /* Repeated characters; caseless must follow the caseful ones */\n\n  OP_STARI,          /* 46 */\n  OP_MINSTARI,       /* 47 */\n  OP_PLUSI,          /* 48 */\n  OP_MINPLUSI,       /* 49 */\n  OP_QUERYI,         /* 50 */\n  OP_MINQUERYI,      /* 51 */\n\n  OP_UPTOI,          /* 52 From 0 to n matches of one character, caseless */\n  OP_MINUPTOI,       /* 53 */\n  OP_EXACTI,         /* 54 */\n\n  OP_POSSTARI,       /* 55 Possessified star, caseless */\n  OP_POSPLUSI,       /* 56 Possessified plus, caseless */\n  OP_POSQUERYI,      /* 57 Posesssified query, caseless */\n  OP_POSUPTOI,       /* 58 Possessified upto, caseless */\n\n  /* The negated ones must follow the non-negated ones, and match them */\n  /* Negated repeated character, caseful; must precede the caseless ones */\n\n  OP_NOTSTAR,        /* 59 The maximizing and minimizing versions of */\n  OP_NOTMINSTAR,     /* 60 these six opcodes must come in pairs, with */\n  OP_NOTPLUS,        /* 61 the minimizing one second. They must be in */\n  OP_NOTMINPLUS,     /* 62 exactly the same order as those above. */\n  OP_NOTQUERY,       /* 63 */\n  OP_NOTMINQUERY,    /* 64 */\n\n  OP_NOTUPTO,        /* 65 From 0 to n matches, caseful */\n  OP_NOTMINUPTO,     /* 66 */\n  OP_NOTEXACT,       /* 67 Exactly n matches */\n\n  OP_NOTPOSSTAR,     /* 68 Possessified versions, caseful */\n  OP_NOTPOSPLUS,     /* 69 */\n  OP_NOTPOSQUERY,    /* 70 */\n  OP_NOTPOSUPTO,     /* 71 */\n\n  /* Negated repeated character, caseless; must follow the caseful ones */\n\n  OP_NOTSTARI,       /* 72 */\n  OP_NOTMINSTARI,    /* 73 */\n  OP_NOTPLUSI,       /* 74 */\n  OP_NOTMINPLUSI,    /* 75 */\n  OP_NOTQUERYI,      /* 76 */\n  OP_NOTMINQUERYI,   /* 77 */\n\n  OP_NOTUPTOI,       /* 78 From 0 to n matches, caseless */\n  OP_NOTMINUPTOI,    /* 79 */\n  OP_NOTEXACTI,      /* 80 Exactly n matches */\n\n  OP_NOTPOSSTARI,    /* 81 Possessified versions, caseless */\n  OP_NOTPOSPLUSI,    /* 82 */\n  OP_NOTPOSQUERYI,   /* 83 */\n  OP_NOTPOSUPTOI,    /* 84 */\n\n  /* Character types */\n\n  OP_TYPESTAR,       /* 85 The maximizing and minimizing versions of */\n  OP_TYPEMINSTAR,    /* 86 these six opcodes must come in pairs, with */\n  OP_TYPEPLUS,       /* 87 the minimizing one second. These codes must */\n  OP_TYPEMINPLUS,    /* 88 be in exactly the same order as those above. */\n  OP_TYPEQUERY,      /* 89 */\n  OP_TYPEMINQUERY,   /* 90 */\n\n  OP_TYPEUPTO,       /* 91 From 0 to n matches */\n  OP_TYPEMINUPTO,    /* 92 */\n  OP_TYPEEXACT,      /* 93 Exactly n matches */\n\n  OP_TYPEPOSSTAR,    /* 94 Possessified versions */\n  OP_TYPEPOSPLUS,    /* 95 */\n  OP_TYPEPOSQUERY,   /* 96 */\n  OP_TYPEPOSUPTO,    /* 97 */\n\n  /* These are used for character classes and back references; only the\n  first six are the same as the sets above. */\n\n  OP_CRSTAR,         /* 98 The maximizing and minimizing versions of */\n  OP_CRMINSTAR,      /* 99 all these opcodes must come in pairs, with */\n  OP_CRPLUS,         /* 100 the minimizing one second. These codes must */\n  OP_CRMINPLUS,      /* 101 be in exactly the same order as those above. */\n  OP_CRQUERY,        /* 102 */\n  OP_CRMINQUERY,     /* 103 */\n\n  OP_CRRANGE,        /* 104 These are different to the three sets above. */\n  OP_CRMINRANGE,     /* 105 */\n\n  OP_CRPOSSTAR,      /* 106 Possessified versions */\n  OP_CRPOSPLUS,      /* 107 */\n  OP_CRPOSQUERY,     /* 108 */\n  OP_CRPOSRANGE,     /* 109 */\n\n  /* End of quantifier opcodes */\n\n  OP_CLASS,          /* 110 Match a character class, chars < 256 only */\n  OP_NCLASS,         /* 111 Same, but the bitmap was created from a negative\n                              class - the difference is relevant only when a\n                              character > 255 is encountered. */\n  OP_XCLASS,         /* 112 Extended class for handling > 255 chars within the\n                              class. This does both positive and negative. */\n  OP_REF,            /* 113 Match a back reference, casefully */\n  OP_REFI,           /* 114 Match a back reference, caselessly */\n  OP_DNREF,          /* 115 Match a duplicate name backref, casefully */\n  OP_DNREFI,         /* 116 Match a duplicate name backref, caselessly */\n  OP_RECURSE,        /* 117 Match a numbered subpattern (possibly recursive) */\n  OP_CALLOUT,        /* 118 Call out to external function if provided */\n  OP_CALLOUT_STR,    /* 119 Call out with string argument */\n\n  OP_ALT,            /* 120 Start of alternation */\n  OP_KET,            /* 121 End of group that doesn't have an unbounded repeat */\n  OP_KETRMAX,        /* 122 These two must remain together and in this */\n  OP_KETRMIN,        /* 123 order. They are for groups the repeat for ever. */\n  OP_KETRPOS,        /* 124 Possessive unlimited repeat. */\n\n  /* The assertions must come before BRA, CBRA, ONCE, and COND. */\n\n  OP_REVERSE,        /* 125 Move pointer back - used in lookbehind assertions */\n  OP_ASSERT,         /* 126 Positive lookahead */\n  OP_ASSERT_NOT,     /* 127 Negative lookahead */\n  OP_ASSERTBACK,     /* 128 Positive lookbehind */\n  OP_ASSERTBACK_NOT, /* 129 Negative lookbehind */\n  OP_ASSERT_NA,      /* 130 Positive non-atomic lookahead */\n  OP_ASSERTBACK_NA,  /* 131 Positive non-atomic lookbehind */\n\n  /* ONCE, SCRIPT_RUN, BRA, BRAPOS, CBRA, CBRAPOS, and COND must come\n  immediately after the assertions, with ONCE first, as there's a test for >=\n  ONCE for a subpattern that isn't an assertion. The POS versions must\n  immediately follow the non-POS versions in each case. */\n\n  OP_ONCE,           /* 132 Atomic group, contains captures */\n  OP_SCRIPT_RUN,     /* 133 Non-capture, but check characters' scripts */\n  OP_BRA,            /* 134 Start of non-capturing bracket */\n  OP_BRAPOS,         /* 135 Ditto, with unlimited, possessive repeat */\n  OP_CBRA,           /* 136 Start of capturing bracket */\n  OP_CBRAPOS,        /* 137 Ditto, with unlimited, possessive repeat */\n  OP_COND,           /* 138 Conditional group */\n\n  /* These five must follow the previous five, in the same order. There's a\n  check for >= SBRA to distinguish the two sets. */\n\n  OP_SBRA,           /* 139 Start of non-capturing bracket, check empty  */\n  OP_SBRAPOS,        /* 149 Ditto, with unlimited, possessive repeat */\n  OP_SCBRA,          /* 141 Start of capturing bracket, check empty */\n  OP_SCBRAPOS,       /* 142 Ditto, with unlimited, possessive repeat */\n  OP_SCOND,          /* 143 Conditional group, check empty */\n\n  /* The next two pairs must (respectively) be kept together. */\n\n  OP_CREF,           /* 144 Used to hold a capture number as condition */\n  OP_DNCREF,         /* 145 Used to point to duplicate names as a condition */\n  OP_RREF,           /* 146 Used to hold a recursion number as condition */\n  OP_DNRREF,         /* 147 Used to point to duplicate names as a condition */\n  OP_FALSE,          /* 148 Always false (used by DEFINE and VERSION) */\n  OP_TRUE,           /* 149 Always true (used by VERSION) */\n\n  OP_BRAZERO,        /* 150 These two must remain together and in this */\n  OP_BRAMINZERO,     /* 151 order. */\n  OP_BRAPOSZERO,     /* 152 */\n\n  /* These are backtracking control verbs */\n\n  OP_MARK,           /* 153 always has an argument */\n  OP_PRUNE,          /* 154 */\n  OP_PRUNE_ARG,      /* 155 same, but with argument */\n  OP_SKIP,           /* 156 */\n  OP_SKIP_ARG,       /* 157 same, but with argument */\n  OP_THEN,           /* 158 */\n  OP_THEN_ARG,       /* 159 same, but with argument */\n  OP_COMMIT,         /* 160 */\n  OP_COMMIT_ARG,     /* 161 same, but with argument */\n\n  /* These are forced failure and success verbs. FAIL and ACCEPT do accept an\n  argument, but these cases can be compiled as, for example, (*MARK:X)(*FAIL)\n  without the need for a special opcode. */\n\n  OP_FAIL,           /* 162 */\n  OP_ACCEPT,         /* 163 */\n  OP_ASSERT_ACCEPT,  /* 164 Used inside assertions */\n  OP_CLOSE,          /* 165 Used before OP_ACCEPT to close open captures */\n\n  /* This is used to skip a subpattern with a {0} quantifier */\n\n  OP_SKIPZERO,       /* 166 */\n\n  /* This is used to identify a DEFINE group during compilation so that it can\n  be checked for having only one branch. It is changed to OP_FALSE before\n  compilation finishes. */\n\n  OP_DEFINE,         /* 167 */\n\n  /* This is not an opcode, but is used to check that tables indexed by opcode\n  are the correct length, in order to catch updating errors - there have been\n  some in the past. */\n\n  OP_TABLE_LENGTH\n\n};\n\n/* *** NOTE NOTE NOTE *** Whenever the list above is updated, the two macro\ndefinitions that follow must also be updated to match. There are also tables\ncalled \"opcode_possessify\" in pcre2_compile.c and \"coptable\" and \"poptable\" in\npcre2_dfa_match.c that must be updated. */\n\n\n/* This macro defines textual names for all the opcodes. These are used only\nfor debugging, and some of them are only partial names. The macro is referenced\nonly in pcre2_printint.c, which fills out the full names in many cases (and in\nsome cases doesn't actually use these names at all). */\n\n#define OP_NAME_LIST \\\n  \"End\", \"\\\\A\", \"\\\\G\", \"\\\\K\", \"\\\\B\", \"\\\\b\", \"\\\\D\", \"\\\\d\",         \\\n  \"\\\\S\", \"\\\\s\", \"\\\\W\", \"\\\\w\", \"Any\", \"AllAny\", \"Anybyte\",         \\\n  \"notprop\", \"prop\", \"\\\\R\", \"\\\\H\", \"\\\\h\", \"\\\\V\", \"\\\\v\",           \\\n  \"extuni\",  \"\\\\Z\", \"\\\\z\",                                        \\\n  \"$\", \"$\", \"\u00ac\", \"\u00ac\", \"char\", \"chari\", \"not\", \"noti\",             \\\n  \"*\", \"*?\", \"+\", \"+?\", \"?\", \"??\",                                \\\n  \"{\", \"{\", \"{\",                                                  \\\n  \"*+\",\"++\", \"?+\", \"{\",                                           \\\n  \"*\", \"*?\", \"+\", \"+?\", \"?\", \"??\",                                \\\n  \"{\", \"{\", \"{\",                                                  \\\n  \"*+\",\"++\", \"?+\", \"{\",                                           \\\n  \"*\", \"*?\", \"+\", \"+?\", \"?\", \"??\",                                \\\n  \"{\", \"{\", \"{\",                                                  \\\n  \"*+\",\"++\", \"?+\", \"{\",                                           \\\n  \"*\", \"*?\", \"+\", \"+?\", \"?\", \"??\",                                \\\n  \"{\", \"{\", \"{\",                                                  \\\n  \"*+\",\"++\", \"?+\", \"{\",                                           \\\n  \"*\", \"*?\", \"+\", \"+?\", \"?\", \"??\", \"{\", \"{\", \"{\",                 \\\n  \"*+\",\"++\", \"?+\", \"{\",                                           \\\n  \"*\", \"*?\", \"+\", \"+?\", \"?\", \"??\", \"{\", \"{\",                      \\\n  \"*+\",\"++\", \"?+\", \"{\",                                           \\\n  \"class\", \"nclass\", \"xclass\", \"Ref\", \"Refi\", \"DnRef\", \"DnRefi\",  \\\n  \"Recurse\", \"Callout\", \"CalloutStr\",                             \\\n  \"Alt\", \"Ket\", \"KetRmax\", \"KetRmin\", \"KetRpos\",                  \\\n  \"Reverse\", \"Assert\", \"Assert not\",                              \\\n  \"Assert back\", \"Assert back not\",                               \\\n  \"Non-atomic assert\", \"Non-atomic assert back\",                  \\\n  \"Once\",                                                         \\\n  \"Script run\",                                                   \\\n  \"Bra\", \"BraPos\", \"CBra\", \"CBraPos\",                             \\\n  \"Cond\",                                                         \\\n  \"SBra\", \"SBraPos\", \"SCBra\", \"SCBraPos\",                         \\\n  \"SCond\",                                                        \\\n  \"Cond ref\", \"Cond dnref\", \"Cond rec\", \"Cond dnrec\",             \\\n  \"Cond false\", \"Cond true\",                                      \\\n  \"Brazero\", \"Braminzero\", \"Braposzero\",                          \\\n  \"*MARK\", \"*PRUNE\", \"*PRUNE\", \"*SKIP\", \"*SKIP\",                  \\\n  \"*THEN\", \"*THEN\", \"*COMMIT\", \"*COMMIT\", \"*FAIL\",                \\\n  \"*ACCEPT\", \"*ASSERT_ACCEPT\",                                    \\\n  \"Close\", \"Skip zero\", \"Define\"\n\n\n/* This macro defines the length of fixed length operations in the compiled\nregex. The lengths are used when searching for specific things, and also in the\ndebugging printing of a compiled regex. We use a macro so that it can be\ndefined close to the definitions of the opcodes themselves.\n\nAs things have been extended, some of these are no longer fixed lenths, but are\nminima instead. For example, the length of a single-character repeat may vary\nin UTF-8 mode. The code that uses this table must know about such things. */\n\n#define OP_LENGTHS \\\n  1,                             /* End                                    */ \\\n  1, 1, 1, 1, 1,                 /* \\A, \\G, \\K, \\B, \\b                     */ \\\n  1, 1, 1, 1, 1, 1,              /* \\D, \\d, \\S, \\s, \\W, \\w                 */ \\\n  1, 1, 1,                       /* Any, AllAny, Anybyte                   */ \\\n  3, 3,                          /* \\P, \\p                                 */ \\\n  1, 1, 1, 1, 1,                 /* \\R, \\H, \\h, \\V, \\v                     */ \\\n  1,                             /* \\X                                     */ \\\n  1, 1, 1, 1, 1, 1,              /* \\Z, \\z, $, $M \u00ac, \u00acM                    */ \\\n  2,                             /* Char  - the minimum length             */ \\\n  2,                             /* Chari  - the minimum length            */ \\\n  2,                             /* not                                    */ \\\n  2,                             /* noti                                   */ \\\n  /* Positive single-char repeats                             ** These are */ \\\n  2, 2, 2, 2, 2, 2,              /* *, *?, +, +?, ?, ??       ** minima in */ \\\n  2+IMM2_SIZE, 2+IMM2_SIZE,      /* upto, minupto             ** mode      */ \\\n  2+IMM2_SIZE,                   /* exact                                  */ \\\n  2, 2, 2, 2+IMM2_SIZE,          /* *+, ++, ?+, upto+                      */ \\\n  2, 2, 2, 2, 2, 2,              /* *I, *?I, +I, +?I, ?I, ??I ** UTF-8     */ \\\n  2+IMM2_SIZE, 2+IMM2_SIZE,      /* upto I, minupto I                      */ \\\n  2+IMM2_SIZE,                   /* exact I                                */ \\\n  2, 2, 2, 2+IMM2_SIZE,          /* *+I, ++I, ?+I, upto+I                  */ \\\n  /* Negative single-char repeats - only for chars < 256                   */ \\\n  2, 2, 2, 2, 2, 2,              /* NOT *, *?, +, +?, ?, ??                */ \\\n  2+IMM2_SIZE, 2+IMM2_SIZE,      /* NOT upto, minupto                      */ \\\n  2+IMM2_SIZE,                   /* NOT exact                              */ \\\n  2, 2, 2, 2+IMM2_SIZE,          /* Possessive NOT *, +, ?, upto           */ \\\n  2, 2, 2, 2, 2, 2,              /* NOT *I, *?I, +I, +?I, ?I, ??I          */ \\\n  2+IMM2_SIZE, 2+IMM2_SIZE,      /* NOT upto I, minupto I                  */ \\\n  2+IMM2_SIZE,                   /* NOT exact I                            */ \\\n  2, 2, 2, 2+IMM2_SIZE,          /* Possessive NOT *I, +I, ?I, upto I      */ \\\n  /* Positive type repeats                                                 */ \\\n  2, 2, 2, 2, 2, 2,              /* Type *, *?, +, +?, ?, ??               */ \\\n  2+IMM2_SIZE, 2+IMM2_SIZE,      /* Type upto, minupto                     */ \\\n  2+IMM2_SIZE,                   /* Type exact                             */ \\\n  2, 2, 2, 2+IMM2_SIZE,          /* Possessive *+, ++, ?+, upto+           */ \\\n  /* Character class & ref repeats                                         */ \\\n  1, 1, 1, 1, 1, 1,              /* *, *?, +, +?, ?, ??                    */ \\\n  1+2*IMM2_SIZE, 1+2*IMM2_SIZE,  /* CRRANGE, CRMINRANGE                    */ \\\n  1, 1, 1, 1+2*IMM2_SIZE,        /* Possessive *+, ++, ?+, CRPOSRANGE      */ \\\n  1+(32/sizeof(PCRE2_UCHAR)),    /* CLASS                                  */ \\\n  1+(32/sizeof(PCRE2_UCHAR)),    /* NCLASS                                 */ \\\n  0,                             /* XCLASS - variable length               */ \\\n  1+IMM2_SIZE,                   /* REF                                    */ \\\n  1+IMM2_SIZE,                   /* REFI                                   */ \\\n  1+2*IMM2_SIZE,                 /* DNREF                                  */ \\\n  1+2*IMM2_SIZE,                 /* DNREFI                                 */ \\\n  1+LINK_SIZE,                   /* RECURSE                                */ \\\n  1+2*LINK_SIZE+1,               /* CALLOUT                                */ \\\n  0,                             /* CALLOUT_STR - variable length          */ \\\n  1+LINK_SIZE,                   /* Alt                                    */ \\\n  1+LINK_SIZE,                   /* Ket                                    */ \\\n  1+LINK_SIZE,                   /* KetRmax                                */ \\\n  1+LINK_SIZE,                   /* KetRmin                                */ \\\n  1+LINK_SIZE,                   /* KetRpos                                */ \\\n  1+LINK_SIZE,                   /* Reverse                                */ \\\n  1+LINK_SIZE,                   /* Assert                                 */ \\\n  1+LINK_SIZE,                   /* Assert not                             */ \\\n  1+LINK_SIZE,                   /* Assert behind                          */ \\\n  1+LINK_SIZE,                   /* Assert behind not                      */ \\\n  1+LINK_SIZE,                   /* NA Assert                              */ \\\n  1+LINK_SIZE,                   /* NA Assert behind                       */ \\\n  1+LINK_SIZE,                   /* ONCE                                   */ \\\n  1+LINK_SIZE,                   /* SCRIPT_RUN                             */ \\\n  1+LINK_SIZE,                   /* BRA                                    */ \\\n  1+LINK_SIZE,                   /* BRAPOS                                 */ \\\n  1+LINK_SIZE+IMM2_SIZE,         /* CBRA                                   */ \\\n  1+LINK_SIZE+IMM2_SIZE,         /* CBRAPOS                                */ \\\n  1+LINK_SIZE,                   /* COND                                   */ \\\n  1+LINK_SIZE,                   /* SBRA                                   */ \\\n  1+LINK_SIZE,                   /* SBRAPOS                                */ \\\n  1+LINK_SIZE+IMM2_SIZE,         /* SCBRA                                  */ \\\n  1+LINK_SIZE+IMM2_SIZE,         /* SCBRAPOS                               */ \\\n  1+LINK_SIZE,                   /* SCOND                                  */ \\\n  1+IMM2_SIZE, 1+2*IMM2_SIZE,    /* CREF, DNCREF                           */ \\\n  1+IMM2_SIZE, 1+2*IMM2_SIZE,    /* RREF, DNRREF                           */ \\\n  1, 1,                          /* FALSE, TRUE                            */ \\\n  1, 1, 1,                       /* BRAZERO, BRAMINZERO, BRAPOSZERO        */ \\\n  3, 1, 3,                       /* MARK, PRUNE, PRUNE_ARG                 */ \\\n  1, 3,                          /* SKIP, SKIP_ARG                         */ \\\n  1, 3,                          /* THEN, THEN_ARG                         */ \\\n  1, 3,                          /* COMMIT, COMMIT_ARG                     */ \\\n  1, 1, 1,                       /* FAIL, ACCEPT, ASSERT_ACCEPT            */ \\\n  1+IMM2_SIZE, 1,                /* CLOSE, SKIPZERO                        */ \\\n  1                              /* DEFINE                                 */\n\n/* A magic value for OP_RREF to indicate the \"any recursion\" condition. */\n\n#define RREF_ANY  0xffff\n\n\n/* ---------- Private structures that are mode-independent. ---------- */\n\n/* Structure to hold data for custom memory management. */\n\ntypedef struct pcre2_memctl {\n  void *    (*malloc)(size_t, void *);\n  void      (*free)(void *, void *);\n  void      *memory_data;\n} pcre2_memctl;\n\n/* Structure for building a chain of open capturing subpatterns during\ncompiling, so that instructions to close them can be compiled when (*ACCEPT) is\nencountered. */\n\ntypedef struct open_capitem {\n  struct open_capitem *next;    /* Chain link */\n  uint16_t number;              /* Capture number */\n  uint16_t assert_depth;        /* Assertion depth when opened */\n} open_capitem;\n\n/* Layout of the UCP type table that translates property names into types and\ncodes. Each entry used to point directly to a name, but to reduce the number of\nrelocations in shared libraries, it now has an offset into a single string\ninstead. */\n\ntypedef struct {\n  uint16_t name_offset;\n  uint16_t type;\n  uint16_t value;\n} ucp_type_table;\n\n/* Unicode character database (UCD) record format */\n\ntypedef struct {\n  uint8_t script;     /* ucp_Arabic, etc. */\n  uint8_t chartype;   /* ucp_Cc, etc. (general categories) */\n  uint8_t gbprop;     /* ucp_gbControl, etc. (grapheme break property) */\n  uint8_t caseset;    /* offset to multichar other cases or zero */\n  int32_t other_case; /* offset to other case, or zero if none */\n  int16_t scriptx;    /* script extension value */\n  int16_t dummy;      /* spare - to round to multiple of 4 bytes */\n} ucd_record;\n\n/* UCD access macros */\n\n#define UCD_BLOCK_SIZE 128\n#define REAL_GET_UCD(ch) (PRIV(ucd_records) + \\\n        PRIV(ucd_stage2)\u00ddPRIV(ucd_stage1)\u00dd(int)(ch) / UCD_BLOCK_SIZE\u00a8 * \\\n        UCD_BLOCK_SIZE + (int)(ch) % UCD_BLOCK_SIZE\u00a8)\n\n#if PCRE2_CODE_UNIT_WIDTH == 32\n#define GET_UCD(ch) ((ch > MAX_UTF_CODE_POINT)? \\\n  PRIV(dummy_ucd_record) : REAL_GET_UCD(ch))\n#else\n#define GET_UCD(ch) REAL_GET_UCD(ch)\n#endif\n\n#define UCD_CHARTYPE(ch)    GET_UCD(ch)->chartype\n#define UCD_SCRIPT(ch)      GET_UCD(ch)->script\n#define UCD_CATEGORY(ch)    PRIV(ucp_gentype)\u00ddUCD_CHARTYPE(ch)\u00a8\n#define UCD_GRAPHBREAK(ch)  GET_UCD(ch)->gbprop\n#define UCD_CASESET(ch)     GET_UCD(ch)->caseset\n#define UCD_OTHERCASE(ch)   ((uint32_t)((int)ch + (int)(GET_UCD(ch)->other_case)))\n#define UCD_SCRIPTX(ch)     GET_UCD(ch)->scriptx\n\n/* Header for serialized pcre2 codes. */\n\ntypedef struct pcre2_serialized_data {\n  uint32_t magic;\n  uint32_t version;\n  uint32_t config;\n  int32_t  number_of_codes;\n} pcre2_serialized_data;\n\n\n\n/* ----------------- Items that need PCRE2_CODE_UNIT_WIDTH ----------------- */\n\n/* When this file is included by pcre2test, PCRE2_CODE_UNIT_WIDTH is defined as\n0, so the following items are omitted. */\n\n#if defined PCRE2_CODE_UNIT_WIDTH && PCRE2_CODE_UNIT_WIDTH != 0\n\n/* EBCDIC is supported only for the 8-bit library. */\n\n#if defined EBCDIC && PCRE2_CODE_UNIT_WIDTH != 8\n#error EBCDIC is not supported for the 16-bit or 32-bit libraries\n#endif\n\n/* This is the largest non-UTF code point. */\n\n#define MAX_NON_UTF_CHAR (0xffffffffU >> (32 - PCRE2_CODE_UNIT_WIDTH))\n\n/* Internal shared data tables and variables. These are used by more than one\nof the exported public functions. They have to be \"external\" in the C sense,\nbut are not part of the PCRE2 public API. Although the data for some of them is\nidentical in all libraries, they must have different names so that multiple\nlibraries can be simultaneously linked to a single application. However, UTF-8\ntables are needed only when compiling the 8-bit library. */\n\n#if PCRE2_CODE_UNIT_WIDTH == 8\nextern const int              PRIV(utf8_table1)\u00dd\u00a8;\nextern const int              PRIV(utf8_table1_size);\nextern const int              PRIV(utf8_table2)\u00dd\u00a8;\nextern const int              PRIV(utf8_table3)\u00dd\u00a8;\nextern const uint8_t          PRIV(utf8_table4)\u00dd\u00a8;\n#endif\n\n#define _pcre2_OP_lengths              PCRE2_SUFFIX(_pcre2_OP_lengths_)\n#define _pcre2_callout_end_delims      PCRE2_SUFFIX(_pcre2_callout_end_delims_)\n#define _pcre2_callout_start_delims    PCRE2_SUFFIX(_pcre2_callout_start_delims_)\n#define _pcre2_default_compile_context PCRE2_SUFFIX(_pcre2_default_compile_context_)\n#define _pcre2_default_convert_context PCRE2_SUFFIX(_pcre2_default_convert_context_)\n#define _pcre2_default_match_context   PCRE2_SUFFIX(_pcre2_default_match_context_)\n#define _pcre2_default_tables          PCRE2_SUFFIX(_pcre2_default_tables_)\n#if PCRE2_CODE_UNIT_WIDTH == 32\n#define _pcre2_dummy_ucd_record        PCRE2_SUFFIX(_pcre2_dummy_ucd_record_)\n#endif\n#define _pcre2_hspace_list             PCRE2_SUFFIX(_pcre2_hspace_list_)\n#define _pcre2_vspace_list             PCRE2_SUFFIX(_pcre2_vspace_list_)\n#define _pcre2_ucd_caseless_sets       PCRE2_SUFFIX(_pcre2_ucd_caseless_sets_)\n#define _pcre2_ucd_digit_sets          PCRE2_SUFFIX(_pcre2_ucd_digit_sets_)\n#define _pcre2_ucd_script_sets         PCRE2_SUFFIX(_pcre2_ucd_script_sets_)\n#define _pcre2_ucd_records             PCRE2_SUFFIX(_pcre2_ucd_records_)\n#define _pcre2_ucd_stage1              PCRE2_SUFFIX(_pcre2_ucd_stage1_)\n#define _pcre2_ucd_stage2              PCRE2_SUFFIX(_pcre2_ucd_stage2_)\n#define _pcre2_ucp_gbtable             PCRE2_SUFFIX(_pcre2_ucp_gbtable_)\n#define _pcre2_ucp_gentype             PCRE2_SUFFIX(_pcre2_ucp_gentype_)\n#define _pcre2_ucp_typerange           PCRE2_SUFFIX(_pcre2_ucp_typerange_)\n#define _pcre2_unicode_version         PCRE2_SUFFIX(_pcre2_unicode_version_)\n#define _pcre2_utt                     PCRE2_SUFFIX(_pcre2_utt_)\n#define _pcre2_utt_names               PCRE2_SUFFIX(_pcre2_utt_names_)\n#define _pcre2_utt_size                PCRE2_SUFFIX(_pcre2_utt_size_)\n\nextern const uint8_t                   PRIV(OP_lengths)\u00dd\u00a8;\nextern const uint32_t                  PRIV(callout_end_delims)\u00dd\u00a8;\nextern const uint32_t                  PRIV(callout_start_delims)\u00dd\u00a8;\nextern const pcre2_compile_context     PRIV(default_compile_context);\nextern const pcre2_convert_context     PRIV(default_convert_context);\nextern const pcre2_match_context       PRIV(default_match_context);\nextern const uint8_t                   PRIV(default_tables)\u00dd\u00a8;\nextern const uint32_t                  PRIV(hspace_list)\u00dd\u00a8;\nextern const uint32_t                  PRIV(vspace_list)\u00dd\u00a8;\nextern const uint32_t                  PRIV(ucd_caseless_sets)\u00dd\u00a8;\nextern const uint32_t                  PRIV(ucd_digit_sets)\u00dd\u00a8;\nextern const uint8_t                   PRIV(ucd_script_sets)\u00dd\u00a8;\nextern const ucd_record                PRIV(ucd_records)\u00dd\u00a8;\n#if PCRE2_CODE_UNIT_WIDTH == 32\nextern const ucd_record                PRIV(dummy_ucd_record)\u00dd\u00a8;\n#endif\nextern const uint16_t                  PRIV(ucd_stage1)\u00dd\u00a8;\nextern const uint16_t                  PRIV(ucd_stage2)\u00dd\u00a8;\nextern const uint32_t                  PRIV(ucp_gbtable)\u00dd\u00a8;\nextern const uint32_t                  PRIV(ucp_gentype)\u00dd\u00a8;\n#ifdef SUPPORT_JIT\nextern const int                       PRIV(ucp_typerange)\u00dd\u00a8;\n#endif\nextern const char                     *PRIV(unicode_version);\nextern const ucp_type_table            PRIV(utt)\u00dd\u00a8;\nextern const char                      PRIV(utt_names)\u00dd\u00a8;\nextern const size_t                    PRIV(utt_size);\n\n/* Mode-dependent macros and hidden and private structures are defined in a\nseparate file so that pcre2test can include them at all supported widths. When\ncompiling the library, PCRE2_CODE_UNIT_WIDTH will be defined, and we can\ninclude them at the appropriate width, after setting up suffix macros for the\nprivate structures. */\n\n#define branch_chain                 PCRE2_SUFFIX(branch_chain_)\n#define compile_block                PCRE2_SUFFIX(compile_block_)\n#define dfa_match_block              PCRE2_SUFFIX(dfa_match_block_)\n#define match_block                  PCRE2_SUFFIX(match_block_)\n#define named_group                  PCRE2_SUFFIX(named_group_)\n\n#include \"INTMODE2.h\"\n\n/* Private \"external\" functions. These are internal functions that are called\nfrom modules other than the one in which they are defined. They have to be\n\"external\" in the C sense, but are not part of the PCRE2 public API. They are\nnot referenced from pcre2test, and must not be defined when no code unit width\nis available. */\n\n#define _pcre2_auto_possessify       PCRE2_SUFFIX(_pcre2_auto_possessify_)\n#define _pcre2_check_escape          PCRE2_SUFFIX(_pcre2_check_escape_)\n#define _pcre2_extuni                PCRE2_SUFFIX(_pcre2_extuni_)\n#define _pcre2_find_bracket          PCRE2_SUFFIX(_pcre2_find_bracket_)\n#define _pcre2_is_newline            PCRE2_SUFFIX(_pcre2_is_newline_)\n#define _pcre2_jit_free_rodata       PCRE2_SUFFIX(_pcre2_jit_free_rodata_)\n#define _pcre2_jit_free              PCRE2_SUFFIX(_pcre2_jit_free_)\n#define _pcre2_jit_get_size          PCRE2_SUFFIX(_pcre2_jit_get_size_)\n#define _pcre2_jit_get_target        PCRE2_SUFFIX(_pcre2_jit_get_target_)\n#define _pcre2_memctl_malloc         PCRE2_SUFFIX(_pcre2_memctl_malloc_)\n#define _pcre2_ord2utf               PCRE2_SUFFIX(_pcre2_ord2utf_)\n#define _pcre2_script_run            PCRE2_SUFFIX(_pcre2_script_run_)\n#define _pcre2_strcmp                PCRE2_SUFFIX(_pcre2_strcmp_)\n#define _pcre2_strcmp_c8             PCRE2_SUFFIX(_pcre2_strcmp_c8_)\n#define _pcre2_strcpy_c8             PCRE2_SUFFIX(_pcre2_strcpy_c8_)\n#define _pcre2_strlen                PCRE2_SUFFIX(_pcre2_strlen_)\n#define _pcre2_strncmp               PCRE2_SUFFIX(_pcre2_strncmp_)\n#define _pcre2_strncmp_c8            PCRE2_SUFFIX(_pcre2_strncmp_c8_)\n#define _pcre2_study                 PCRE2_SUFFIX(_pcre2_study_)\n#define _pcre2_valid_utf             PCRE2_SUFFIX(_pcre2_valid_utf_)\n#define _pcre2_was_newline           PCRE2_SUFFIX(_pcre2_was_newline_)\n#define _pcre2_xclass                PCRE2_SUFFIX(_pcre2_xclass_)\n\nextern int          _pcre2_auto_possessify(PCRE2_UCHAR *,\n                      const compile_block *);\nextern int          _pcre2_check_escape(PCRE2_SPTR *, PCRE2_SPTR, uint32_t *,\n                      int *, uint32_t, uint32_t, BOOL, compile_block *);\nextern PCRE2_SPTR   _pcre2_extuni(uint32_t, PCRE2_SPTR, PCRE2_SPTR, PCRE2_SPTR,\n                      BOOL, int *);\nextern PCRE2_SPTR   _pcre2_find_bracket(PCRE2_SPTR, BOOL, int);\nextern BOOL         _pcre2_is_newline(PCRE2_SPTR, uint32_t, PCRE2_SPTR,\n                      uint32_t *, BOOL);\nextern void         _pcre2_jit_free_rodata(void *, void *);\nextern void         _pcre2_jit_free(void *, pcre2_memctl *);\nextern size_t       _pcre2_jit_get_size(void *);\nconst char *        _pcre2_jit_get_target(void);\nextern void *       _pcre2_memctl_malloc(size_t, pcre2_memctl *);\nextern unsigned int _pcre2_ord2utf(uint32_t, PCRE2_UCHAR *);\nextern BOOL         _pcre2_script_run(PCRE2_SPTR, PCRE2_SPTR, BOOL);\nextern int          _pcre2_strcmp(PCRE2_SPTR, PCRE2_SPTR);\nextern int          _pcre2_strcmp_c8(PCRE2_SPTR, const char *);\nextern PCRE2_SIZE   _pcre2_strcpy_c8(PCRE2_UCHAR *, const char *);\nextern PCRE2_SIZE   _pcre2_strlen(PCRE2_SPTR);\nextern int          _pcre2_strncmp(PCRE2_SPTR, PCRE2_SPTR, size_t);\nextern int          _pcre2_strncmp_c8(PCRE2_SPTR, const char *, size_t);\nextern int          _pcre2_study(pcre2_real_code *);\nextern int          _pcre2_valid_utf(PCRE2_SPTR, PCRE2_SIZE, PCRE2_SIZE *);\nextern BOOL         _pcre2_was_newline(PCRE2_SPTR, uint32_t, PCRE2_SPTR,\n                      uint32_t *, BOOL);\nextern BOOL         _pcre2_xclass(uint32_t, PCRE2_SPTR, BOOL);\n\n/* This function is needed only when memmove() is not available. */\n\n#if !defined(VPCOMPAT) && !defined(HAVE_MEMMOVE)\n#define _pcre2_memmove               PCRE2_SUFFIX(_pcre2_memmove)\nextern void *       _pcre2_memmove(void *, const void *, size_t);\n#endif\n\n#endif  /* PCRE2_CODE_UNIT_WIDTH */\n#endif  /* PCRE2_INTERNAL_H_IDEMPOTENT_GUARD */\n\n/* End of pcre2_internal.h */\n/*autoconv-0001 C:\\projects\\pcre2-10.35\\src\\pcre2_internal.h converted to INTERNA2*/\n/*autoconv-0011 INTERNA2 line: 143 pcre2.h replaced by PCRE2.h*/\n/*autoconv-0011 INTERNA2 line: 144 pcre2_ucp.h replaced by UCP2.h*/\n/*autoconv-0011 INTERNA2 line: 1935 pcre2_intmodedep.h replaced by INTMODE2.h*/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "INTMODE2": {"ttr": 3335, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "\n/*************************************************\n*      Perl-Compatible Regular Expressions       *\n*************************************************/\n\n/* PCRE is a library of functions to support regular expressions whose syntax\nand semantics are as close as possible to those of the Perl 5 language.\n\n                       Written by Philip Hazel\n     Original API code Copyright (c) 1997-2012 University of Cambridge\n          New API code Copyright (c) 2016-2018 University of Cambridge\n\n-----------------------------------------------------------------------------\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n\n    * Redistributions of source code must retain the above copyright notice,\n      this list of conditions and the following disclaimer.\n\n    * Redistributions in binary form must reproduce the above copyright\n      notice, this list of conditions and the following disclaimer in the\n      documentation and/or other materials provided with the distribution.\n\n    * Neither the name of the University of Cambridge nor the names of its\n      contributors may be used to endorse or promote products derived from\n      this software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\nAND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\nIMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\nARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\nLIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\nCONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\nSUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\nINTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\nCONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\nARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\nPOSSIBILITY OF SUCH DAMAGE.\n-----------------------------------------------------------------------------\n*/\n\n\n/* This module contains mode-dependent macro and structure definitions. The\nfile is #included by pcre2_internal.h if PCRE2_CODE_UNIT_WIDTH is defined.\nThese mode-dependent items are kept in a separate file so that they can also be\n#included multiple times for different code unit widths by pcre2test in order\nto have access to the hidden structures at all supported widths.\n\nSome of the mode-dependent macros are required at different widths for\ndifferent parts of the pcre2test code (in particular, the included\npcre_printint.c file). We undefine them here so that they can be re-defined for\nmultiple inclusions. Not all of these are used in pcre2test, but it's easier\njust to undefine them all. */\n\n#undef ACROSSCHAR\n#undef BACKCHAR\n#undef BYTES2CU\n#undef CHMAX_255\n#undef CU2BYTES\n#undef FORWARDCHAR\n#undef FORWARDCHARTEST\n#undef GET\n#undef GET2\n#undef GETCHAR\n#undef GETCHARINC\n#undef GETCHARINCTEST\n#undef GETCHARLEN\n#undef GETCHARLENTEST\n#undef GETCHARTEST\n#undef GET_EXTRALEN\n#undef HAS_EXTRALEN\n#undef IMM2_SIZE\n#undef MAX_255\n#undef MAX_MARK\n#undef MAX_PATTERN_SIZE\n#undef MAX_UTF_SINGLE_CU\n#undef NOT_FIRSTCU\n#undef PUT\n#undef PUT2\n#undef PUT2INC\n#undef PUTCHAR\n#undef PUTINC\n#undef TABLE_GET\n\n\n\n/* -------------------------- MACROS ----------------------------- */\n\n/* PCRE keeps offsets in its compiled code as at least 16-bit quantities\n(always stored in big-endian order in 8-bit mode) by default. These are used,\nfor example, to link from the start of a subpattern to its alternatives and its\nend. The use of 16 bits per offset limits the size of an 8-bit compiled regex\nto around 64K, which is big enough for almost everybody. However, I received a\nrequest for an even bigger limit. For this reason, and also to make the code\neasier to maintain, the storing and loading of offsets from the compiled code\nunit string is now handled by the macros that are defined here.\n\nThe macros are controlled by the value of LINK_SIZE. This defaults to 2, but\nvalues of 3 or 4 are also supported. */\n\n/* ------------------- 8-bit support  ------------------ */\n\n#if PCRE2_CODE_UNIT_WIDTH == 8\n\n#if LINK_SIZE == 2\n#define PUT(a,n,d)   \\\n  (a\u00ddn\u00a8 = (PCRE2_UCHAR)((d) >> 8)), \\\n  (a\u00dd(n)+1\u00a8 = (PCRE2_UCHAR)((d) & 255))\n#define GET(a,n) \\\n  (unsigned int)(((a)\u00ddn\u00a8 << 8) | (a)\u00dd(n)+1\u00a8)\n#define MAX_PATTERN_SIZE (1 << 16)\n\n#elif LINK_SIZE == 3\n#define PUT(a,n,d)       \\\n  (a\u00ddn\u00a8 = (PCRE2_UCHAR)((d) >> 16)),    \\\n  (a\u00dd(n)+1\u00a8 = (PCRE2_UCHAR)((d) >> 8)), \\\n  (a\u00dd(n)+2\u00a8 = (PCRE2_UCHAR)((d) & 255))\n#define GET(a,n) \\\n  (unsigned int)(((a)\u00ddn\u00a8 << 16) | ((a)\u00dd(n)+1\u00a8 << 8) | (a)\u00dd(n)+2\u00a8)\n#define MAX_PATTERN_SIZE (1 << 24)\n\n#elif LINK_SIZE == 4\n#define PUT(a,n,d)        \\\n  (a\u00ddn\u00a8 = (PCRE2_UCHAR)((d) >> 24)),     \\\n  (a\u00dd(n)+1\u00a8 = (PCRE2_UCHAR)((d) >> 16)), \\\n  (a\u00dd(n)+2\u00a8 = (PCRE2_UCHAR)((d) >> 8)),  \\\n  (a\u00dd(n)+3\u00a8 = (PCRE2_UCHAR)((d) & 255))\n#define GET(a,n) \\\n  (unsigned int)(((a)\u00ddn\u00a8 << 24) | ((a)\u00dd(n)+1\u00a8 << 16) | ((a)\u00dd(n)+2\u00a8 << 8) | (a)\u00dd(n)+3\u00a8)\n#define MAX_PATTERN_SIZE (1 << 30)   /* Keep it positive */\n\n#else\n#error LINK_SIZE must be 2, 3, or 4\n#endif\n\n\n/* ------------------- 16-bit support  ------------------ */\n\n#elif PCRE2_CODE_UNIT_WIDTH == 16\n\n#if LINK_SIZE == 2\n#undef LINK_SIZE\n#define LINK_SIZE 1\n#define PUT(a,n,d)   \\\n  (a\u00ddn\u00a8 = (PCRE2_UCHAR)(d))\n#define GET(a,n) \\\n  (a\u00ddn\u00a8)\n#define MAX_PATTERN_SIZE (1 << 16)\n\n#elif LINK_SIZE == 3 || LINK_SIZE == 4\n#undef LINK_SIZE\n#define LINK_SIZE 2\n#define PUT(a,n,d)   \\\n  (a\u00ddn\u00a8 = (PCRE2_UCHAR)((d) >> 16)), \\\n  (a\u00dd(n)+1\u00a8 = (PCRE2_UCHAR)((d) & 65535))\n#define GET(a,n) \\\n  (unsigned int)(((a)\u00ddn\u00a8 << 16) | (a)\u00dd(n)+1\u00a8)\n#define MAX_PATTERN_SIZE (1 << 30)  /* Keep it positive */\n\n#else\n#error LINK_SIZE must be 2, 3, or 4\n#endif\n\n\n/* ------------------- 32-bit support  ------------------ */\n\n#elif PCRE2_CODE_UNIT_WIDTH == 32\n#undef LINK_SIZE\n#define LINK_SIZE 1\n#define PUT(a,n,d)   \\\n  (a\u00ddn\u00a8 = (d))\n#define GET(a,n) \\\n  (a\u00ddn\u00a8)\n#define MAX_PATTERN_SIZE (1 << 30)  /* Keep it positive */\n\n#else\n#error Unsupported compiling mode\n#endif\n\n\n/* --------------- Other mode-specific macros ----------------- */\n\n/* PCRE uses some other (at least) 16-bit quantities that do not change when\nthe size of offsets changes. There are used for repeat counts and for other\nthings such as capturing parenthesis numbers in back references.\n\nDefine the number of code units required to hold a 16-bit count/offset, and\nmacros to load and store such a value. For reasons that I do not understand,\nthe expression in the 8-bit GET2 macro is treated by gcc as a signed\nexpression, even when a is declared as unsigned. It seems that any kind of\narithmetic results in a signed value. Hence the cast. */\n\n#if PCRE2_CODE_UNIT_WIDTH == 8\n#define IMM2_SIZE 2\n#define GET2(a,n) (unsigned int)(((a)\u00ddn\u00a8 << 8) | (a)\u00dd(n)+1\u00a8)\n#define PUT2(a,n,d) a\u00ddn\u00a8 = (d) >> 8, a\u00dd(n)+1\u00a8 = (d) & 255\n\n#else  /* Code units are 16 or 32 bits */\n#define IMM2_SIZE 1\n#define GET2(a,n) a\u00ddn\u00a8\n#define PUT2(a,n,d) a\u00ddn\u00a8 = d\n#endif\n\n/* Other macros that are different for 8-bit mode. The MAX_255 macro checks\nwhether its argument, which is assumed to be one code unit, is less than 256.\nThe CHMAX_255 macro does not assume one code unit. The maximum length of a MARK\nname must fit in one code unit; currently it is set to 255 or 65535. The\nTABLE_GET macro is used to access elements of tables containing exactly 256\nitems. Its argument is a code unit. When code points can be greater than 255, a\ncheck is needed before accessing these tables. */\n\n#if PCRE2_CODE_UNIT_WIDTH == 8\n#define MAX_255(c) TRUE\n#define MAX_MARK ((1u << 8) - 1)\n#define TABLE_GET(c, table, default) ((table)\u00ddc\u00a8)\n#ifdef SUPPORT_UNICODE\n#define SUPPORT_WIDE_CHARS\n#define CHMAX_255(c) ((c) <= 255u)\n#else\n#define CHMAX_255(c) TRUE\n#endif  /* SUPPORT_UNICODE */\n\n#else  /* Code units are 16 or 32 bits */\n#define CHMAX_255(c) ((c) <= 255u)\n#define MAX_255(c) ((c) <= 255u)\n#define MAX_MARK ((1u << 16) - 1)\n#define SUPPORT_WIDE_CHARS\n#define TABLE_GET(c, table, default) (MAX_255(c)? ((table)\u00ddc\u00a8):(default))\n#endif\n\n\n/* ----------------- Character-handling macros ----------------- */\n\n/* There is a proposed future special \"UTF-21\" mode, in which only the lowest\n21 bits of a 32-bit character are interpreted as UTF, with the remaining 11\nhigh-order bits available to the application for other uses. In preparation for\nthe future implementation of this mode, there are macros that load a data item\nand, if in this special mode, mask it to 21 bits. These macros all have names\nstarting with UCHAR21. In all other modes, including the normal 32-bit\nlibrary, the macros all have the same simple definitions. When the new mode is\nimplemented, it is expected that these definitions will be varied appropriately\nusing #ifdef when compiling the library that supports the special mode. */\n\n#define UCHAR21(eptr)        (*(eptr))\n#define UCHAR21TEST(eptr)    (*(eptr))\n#define UCHAR21INC(eptr)     (*(eptr)++)\n#define UCHAR21INCTEST(eptr) (*(eptr)++)\n\n/* When UTF encoding is being used, a character is no longer just a single\nbyte in 8-bit mode or a single short in 16-bit mode. The macros for character\nhandling generate simple sequences when used in the basic mode, and more\ncomplicated ones for UTF characters. GETCHARLENTEST and other macros are not\nused when UTF is not supported. To make sure they can never even appear when\nUTF support is omitted, we don't even define them. */\n\n#ifndef SUPPORT_UNICODE\n\n/* #define MAX_UTF_SINGLE_CU */\n/* #define HAS_EXTRALEN(c) */\n/* #define GET_EXTRALEN(c) */\n/* #define NOT_FIRSTCU(c) */\n#define GETCHAR(c, eptr) c = *eptr;\n#define GETCHARTEST(c, eptr) c = *eptr;\n#define GETCHARINC(c, eptr) c = *eptr++;\n#define GETCHARINCTEST(c, eptr) c = *eptr++;\n#define GETCHARLEN(c, eptr, len) c = *eptr;\n#define PUTCHAR(c, p) (*p = c, 1)\n/* #define GETCHARLENTEST(c, eptr, len) */\n/* #define BACKCHAR(eptr) */\n/* #define FORWARDCHAR(eptr) */\n/* #define FORWARCCHARTEST(eptr,end) */\n/* #define ACROSSCHAR(condition, eptr, action) */\n\n#else   /* SUPPORT_UNICODE */\n\n/* ------------------- 8-bit support  ------------------ */\n\n#if PCRE2_CODE_UNIT_WIDTH == 8\n#define MAYBE_UTF_MULTI          /* UTF chars may use multiple code units */\n\n/* The largest UTF code point that can be encoded as a single code unit. */\n\n#define MAX_UTF_SINGLE_CU 127\n\n/* Tests whether the code point needs extra characters to decode. */\n\n#define HAS_EXTRALEN(c) HASUTF8EXTRALEN(c)\n\n/* Returns with the additional number of characters if IS_MULTICHAR(c) is TRUE.\nOtherwise it has an undefined behaviour. */\n\n#define GET_EXTRALEN(c) (PRIV(utf8_table4)\u00dd(c) & 0x3fu\u00a8)\n\n/* Returns TRUE, if the given value is not the first code unit of a UTF\nsequence. */\n\n#define NOT_FIRSTCU(c) (((c) & 0xc0u) == 0x80u)\n\n/* Get the next UTF-8 character, not advancing the pointer. This is called when\nwe know we are in UTF-8 mode. */\n\n#define GETCHAR(c, eptr) \\\n  c = *eptr; \\\n  if (c >= 0xc0u) GETUTF8(c, eptr);\n\n/* Get the next UTF-8 character, testing for UTF-8 mode, and not advancing the\npointer. */\n\n#define GETCHARTEST(c, eptr) \\\n  c = *eptr; \\\n  if (utf && c >= 0xc0u) GETUTF8(c, eptr);\n\n/* Get the next UTF-8 character, advancing the pointer. This is called when we\nknow we are in UTF-8 mode. */\n\n#define GETCHARINC(c, eptr) \\\n  c = *eptr++; \\\n  if (c >= 0xc0u) GETUTF8INC(c, eptr);\n\n/* Get the next character, testing for UTF-8 mode, and advancing the pointer.\nThis is called when we don't know if we are in UTF-8 mode. */\n\n#define GETCHARINCTEST(c, eptr) \\\n  c = *eptr++; \\\n  if (utf && c >= 0xc0u) GETUTF8INC(c, eptr);\n\n/* Get the next UTF-8 character, not advancing the pointer, incrementing length\nif there are extra bytes. This is called when we know we are in UTF-8 mode. */\n\n#define GETCHARLEN(c, eptr, len) \\\n  c = *eptr; \\\n  if (c >= 0xc0u) GETUTF8LEN(c, eptr, len);\n\n/* Get the next UTF-8 character, testing for UTF-8 mode, not advancing the\npointer, incrementing length if there are extra bytes. This is called when we\ndo not know if we are in UTF-8 mode. */\n\n#define GETCHARLENTEST(c, eptr, len) \\\n  c = *eptr; \\\n  if (utf && c >= 0xc0u) GETUTF8LEN(c, eptr, len);\n\n/* If the pointer is not at the start of a character, move it back until\nit is. This is called only in UTF-8 mode - we don't put a test within the macro\nbecause almost all calls are already within a block of UTF-8 only code. */\n\n#define BACKCHAR(eptr) while((*eptr & 0xc0u) == 0x80u) eptr--\n\n/* Same as above, just in the other direction. */\n#define FORWARDCHAR(eptr) while((*eptr & 0xc0u) == 0x80u) eptr++\n#define FORWARDCHARTEST(eptr,end) while(eptr < end && (*eptr & 0xc0u) == 0x80u) eptr++\n\n/* Same as above, but it allows a fully customizable form. */\n#define ACROSSCHAR(condition, eptr, action) \\\n  while((condition) && ((*eptr) & 0xc0u) == 0x80u) action\n\n/* Deposit a character into memory, returning the number of code units. */\n\n#define PUTCHAR(c, p) ((utf && c > MAX_UTF_SINGLE_CU)? \\\n  PRIV(ord2utf)(c,p) : (*p = c, 1))\n\n\n/* ------------------- 16-bit support  ------------------ */\n\n#elif PCRE2_CODE_UNIT_WIDTH == 16\n#define MAYBE_UTF_MULTI          /* UTF chars may use multiple code units */\n\n/* The largest UTF code point that can be encoded as a single code unit. */\n\n#define MAX_UTF_SINGLE_CU 65535\n\n/* Tests whether the code point needs extra characters to decode. */\n\n#define HAS_EXTRALEN(c) (((c) & 0xfc00u) == 0xd800u)\n\n/* Returns with the additional number of characters if IS_MULTICHAR(c) is TRUE.\nOtherwise it has an undefined behaviour. */\n\n#define GET_EXTRALEN(c) 1\n\n/* Returns TRUE, if the given value is not the first code unit of a UTF\nsequence. */\n\n#define NOT_FIRSTCU(c) (((c) & 0xfc00u) == 0xdc00u)\n\n/* Base macro to pick up the low surrogate of a UTF-16 character, not\nadvancing the pointer. */\n\n#define GETUTF16(c, eptr) \\\n   { c = (((c & 0x3ffu) << 10) | (eptr\u00dd1\u00a8 & 0x3ffu)) + 0x10000u; }\n\n/* Get the next UTF-16 character, not advancing the pointer. This is called when\nwe know we are in UTF-16 mode. */\n\n#define GETCHAR(c, eptr) \\\n  c = *eptr; \\\n  if ((c & 0xfc00u) == 0xd800u) GETUTF16(c, eptr);\n\n/* Get the next UTF-16 character, testing for UTF-16 mode, and not advancing the\npointer. */\n\n#define GETCHARTEST(c, eptr) \\\n  c = *eptr; \\\n  if (utf && (c & 0xfc00u) == 0xd800u) GETUTF16(c, eptr);\n\n/* Base macro to pick up the low surrogate of a UTF-16 character, advancing\nthe pointer. */\n\n#define GETUTF16INC(c, eptr) \\\n   { c = (((c & 0x3ffu) << 10) | (*eptr++ & 0x3ffu)) + 0x10000u; }\n\n/* Get the next UTF-16 character, advancing the pointer. This is called when we\nknow we are in UTF-16 mode. */\n\n#define GETCHARINC(c, eptr) \\\n  c = *eptr++; \\\n  if ((c & 0xfc00u) == 0xd800u) GETUTF16INC(c, eptr);\n\n/* Get the next character, testing for UTF-16 mode, and advancing the pointer.\nThis is called when we don't know if we are in UTF-16 mode. */\n\n#define GETCHARINCTEST(c, eptr) \\\n  c = *eptr++; \\\n  if (utf && (c & 0xfc00u) == 0xd800u) GETUTF16INC(c, eptr);\n\n/* Base macro to pick up the low surrogate of a UTF-16 character, not\nadvancing the pointer, incrementing the length. */\n\n#define GETUTF16LEN(c, eptr, len) \\\n   { c = (((c & 0x3ffu) << 10) | (eptr\u00dd1\u00a8 & 0x3ffu)) + 0x10000u; len++; }\n\n/* Get the next UTF-16 character, not advancing the pointer, incrementing\nlength if there is a low surrogate. This is called when we know we are in\nUTF-16 mode. */\n\n#define GETCHARLEN(c, eptr, len) \\\n  c = *eptr; \\\n  if ((c & 0xfc00u) == 0xd800u) GETUTF16LEN(c, eptr, len);\n\n/* Get the next UTF-816character, testing for UTF-16 mode, not advancing the\npointer, incrementing length if there is a low surrogate. This is called when\nwe do not know if we are in UTF-16 mode. */\n\n#define GETCHARLENTEST(c, eptr, len) \\\n  c = *eptr; \\\n  if (utf && (c & 0xfc00u) == 0xd800u) GETUTF16LEN(c, eptr, len);\n\n/* If the pointer is not at the start of a character, move it back until\nit is. This is called only in UTF-16 mode - we don't put a test within the\nmacro because almost all calls are already within a block of UTF-16 only\ncode. */\n\n#define BACKCHAR(eptr) if ((*eptr & 0xfc00u) == 0xdc00u) eptr--\n\n/* Same as above, just in the other direction. */\n#define FORWARDCHAR(eptr) if ((*eptr & 0xfc00u) == 0xdc00u) eptr++\n#define FORWARDCHARTEST(eptr,end) if (eptr < end && (*eptr & 0xfc00u) == 0xdc00u) eptr++\n\n/* Same as above, but it allows a fully customizable form. */\n#define ACROSSCHAR(condition, eptr, action) \\\n  if ((condition) && ((*eptr) & 0xfc00u) == 0xdc00u) action\n\n/* Deposit a character into memory, returning the number of code units. */\n\n#define PUTCHAR(c, p) ((utf && c > MAX_UTF_SINGLE_CU)? \\\n  PRIV(ord2utf)(c,p) : (*p = c, 1))\n\n\n/* ------------------- 32-bit support  ------------------ */\n\n#else\n\n/* These are trivial for the 32-bit library, since all UTF-32 characters fit\ninto one PCRE2_UCHAR unit. */\n\n#define MAX_UTF_SINGLE_CU (0x10ffffu)\n#define HAS_EXTRALEN(c) (0)\n#define GET_EXTRALEN(c) (0)\n#define NOT_FIRSTCU(c) (0)\n\n/* Get the next UTF-32 character, not advancing the pointer. This is called when\nwe know we are in UTF-32 mode. */\n\n#define GETCHAR(c, eptr) \\\n  c = *(eptr);\n\n/* Get the next UTF-32 character, testing for UTF-32 mode, and not advancing the\npointer. */\n\n#define GETCHARTEST(c, eptr) \\\n  c = *(eptr);\n\n/* Get the next UTF-32 character, advancing the pointer. This is called when we\nknow we are in UTF-32 mode. */\n\n#define GETCHARINC(c, eptr) \\\n  c = *((eptr)++);\n\n/* Get the next character, testing for UTF-32 mode, and advancing the pointer.\nThis is called when we don't know if we are in UTF-32 mode. */\n\n#define GETCHARINCTEST(c, eptr) \\\n  c = *((eptr)++);\n\n/* Get the next UTF-32 character, not advancing the pointer, not incrementing\nlength (since all UTF-32 is of length 1). This is called when we know we are in\nUTF-32 mode. */\n\n#define GETCHARLEN(c, eptr, len) \\\n  GETCHAR(c, eptr)\n\n/* Get the next UTF-32character, testing for UTF-32 mode, not advancing the\npointer, not incrementing the length (since all UTF-32 is of length 1).\nThis is called when we do not know if we are in UTF-32 mode. */\n\n#define GETCHARLENTEST(c, eptr, len) \\\n  GETCHARTEST(c, eptr)\n\n/* If the pointer is not at the start of a character, move it back until\nit is. This is called only in UTF-32 mode - we don't put a test within the\nmacro because almost all calls are already within a block of UTF-32 only\ncode.\n\nThese are all no-ops since all UTF-32 characters fit into one pcre_uchar. */\n\n#define BACKCHAR(eptr) do { } while (0)\n\n/* Same as above, just in the other direction. */\n\n#define FORWARDCHAR(eptr) do { } while (0)\n#define FORWARDCHARTEST(eptr,end) do { } while (0)\n\n/* Same as above, but it allows a fully customizable form. */\n\n#define ACROSSCHAR(condition, eptr, action) do { } while (0)\n\n/* Deposit a character into memory, returning the number of code units. */\n\n#define PUTCHAR(c, p) (*p = c, 1)\n\n#endif  /* UTF-32 character handling */\n#endif  /* SUPPORT_UNICODE */\n\n\n/* Mode-dependent macros that have the same definition in all modes. */\n\n#define CU2BYTES(x)     ((x)*((PCRE2_CODE_UNIT_WIDTH/8)))\n#define BYTES2CU(x)     ((x)/((PCRE2_CODE_UNIT_WIDTH/8)))\n#define PUTINC(a,n,d)   PUT(a,n,d), a += LINK_SIZE\n#define PUT2INC(a,n,d)  PUT2(a,n,d), a += IMM2_SIZE\n\n\n/* ----------------------- HIDDEN STRUCTURES ----------------------------- */\n\n/* NOTE: All these structures *must* start with a pcre2_memctl structure. The\ncode that uses them is simpler because it assumes this. */\n\n/* The real general context structure. At present it holds only data for custom\nmemory control. */\n\ntypedef struct pcre2_real_general_context {\n  pcre2_memctl memctl;\n} pcre2_real_general_context;\n\n/* The real compile context structure */\n\ntypedef struct pcre2_real_compile_context {\n  pcre2_memctl memctl;\n  int (*stack_guard)(uint32_t, void *);\n  void *stack_guard_data;\n  const uint8_t *tables;\n  PCRE2_SIZE max_pattern_length;\n  uint16_t bsr_convention;\n  uint16_t newline_convention;\n  uint32_t parens_nest_limit;\n  uint32_t extra_options;\n} pcre2_real_compile_context;\n\n/* The real match context structure. */\n\ntypedef struct pcre2_real_match_context {\n  pcre2_memctl memctl;\n#ifdef SUPPORT_JIT\n  pcre2_jit_callback jit_callback;\n  void *jit_callback_data;\n#endif\n  int    (*callout)(pcre2_callout_block *, void *);\n  void    *callout_data;\n  int    (*substitute_callout)(pcre2_substitute_callout_block *, void *);\n  void    *substitute_callout_data;\n  PCRE2_SIZE offset_limit;\n  uint32_t heap_limit;\n  uint32_t match_limit;\n  uint32_t depth_limit;\n} pcre2_real_match_context;\n\n/* The real convert context structure. */\n\ntypedef struct pcre2_real_convert_context {\n  pcre2_memctl memctl;\n  uint32_t glob_separator;\n  uint32_t glob_escape;\n} pcre2_real_convert_context;\n\n/* The real compiled code structure. The type for the blocksize field is\ndefined specially because it is required in pcre2_serialize_decode() when\ncopying the size from possibly unaligned memory into a variable of the same\ntype. Use a macro rather than a typedef to avoid compiler warnings when this\nfile is included multiple times by pcre2test. LOOKBEHIND_MAX specifies the\nlargest lookbehind that is supported. (OP_REVERSE in a pattern has a 16-bit\nargument in 8-bit and 16-bit modes, so we need no more than a 16-bit field\nhere.) */\n\n#undef  CODE_BLOCKSIZE_TYPE\n#define CODE_BLOCKSIZE_TYPE size_t\n\n#undef  LOOKBEHIND_MAX\n#define LOOKBEHIND_MAX UINT16_MAX\n\ntypedef struct pcre2_real_code {\n  pcre2_memctl memctl;            /* Memory control fields */\n  const uint8_t *tables;          /* The character tables */\n  void    *executable_jit;        /* Pointer to JIT code */\n  uint8_t  start_bitmap\u00dd32\u00a8;      /* Bitmap for starting code unit < 256 */\n  CODE_BLOCKSIZE_TYPE blocksize;  /* Total (bytes) that was malloc-ed */\n  uint32_t magic_number;          /* Paranoid and endianness check */\n  uint32_t compile_options;       /* Options passed to pcre2_compile() */\n  uint32_t overall_options;       /* Options after processing the pattern */\n  uint32_t extra_options;         /* Taken from compile_context */\n  uint32_t flags;                 /* Various state flags */\n  uint32_t limit_heap;            /* Limit set in the pattern */\n  uint32_t limit_match;           /* Limit set in the pattern */\n  uint32_t limit_depth;           /* Limit set in the pattern */\n  uint32_t first_codeunit;        /* Starting code unit */\n  uint32_t last_codeunit;         /* This codeunit must be seen */\n  uint16_t bsr_convention;        /* What \\R matches */\n  uint16_t newline_convention;    /* What is a newline? */\n  uint16_t max_lookbehind;        /* Longest lookbehind (characters) */\n  uint16_t minlength;             /* Minimum length of match */\n  uint16_t top_bracket;           /* Highest numbered group */\n  uint16_t top_backref;           /* Highest numbered back reference */\n  uint16_t name_entry_size;       /* Size (code units) of table entries */\n  uint16_t name_count;            /* Number of name entries in the table */\n} pcre2_real_code;\n\n/* The real match data structure. Define ovector as large as it can ever\nactually be so that array bound checkers don't grumble. Memory for this\nstructure is obtained by calling pcre2_match_data_create(), which sets the size\nas the offset of ovector plus a pair of elements for each capturable string, so\nthe size varies from call to call. As the maximum number of capturing\nsubpatterns is 65535 we must allow for 65536 strings to include the overall\nmatch. (See also the heapframe structure below.) */\n\ntypedef struct pcre2_real_match_data {\n  pcre2_memctl     memctl;\n  const pcre2_real_code *code;    /* The pattern used for the match */\n  PCRE2_SPTR       subject;       /* The subject that was matched */\n  PCRE2_SPTR       mark;          /* Pointer to last mark */\n  PCRE2_SIZE       leftchar;      /* Offset to leftmost code unit */\n  PCRE2_SIZE       rightchar;     /* Offset to rightmost code unit */\n  PCRE2_SIZE       startchar;     /* Offset to starting code unit */\n  uint8_t          matchedby;     /* Type of match (normal, JIT, DFA) */\n  uint8_t          flags;         /* Various flags */\n  uint16_t         oveccount;     /* Number of pairs */\n  int              rc;            /* The return code from the match */\n  PCRE2_SIZE       ovector\u00dd131072\u00a8; /* Must be last in the structure */\n} pcre2_real_match_data;\n\n\n/* ----------------------- PRIVATE STRUCTURES ----------------------------- */\n\n/* These structures are not needed for pcre2test. */\n\n#ifndef PCRE2_PCRE2TEST\n\n/* Structures for checking for mutual recursion when scanning compiled or\nparsed code. */\n\ntypedef struct recurse_check {\n  struct recurse_check *prev;\n  PCRE2_SPTR group;\n} recurse_check;\n\ntypedef struct parsed_recurse_check {\n  struct parsed_recurse_check *prev;\n  uint32_t *groupptr;\n} parsed_recurse_check;\n\n/* Structure for building a cache when filling in recursion offsets. */\n\ntypedef struct recurse_cache {\n  PCRE2_SPTR group;\n  int groupnumber;\n} recurse_cache;\n\n/* Structure for maintaining a chain of pointers to the currently incomplete\nbranches, for testing for left recursion while compiling. */\n\ntypedef struct branch_chain {\n  struct branch_chain *outer;\n  PCRE2_UCHAR *current_branch;\n} branch_chain;\n\n/* Structure for building a list of named groups during the first pass of\ncompiling. */\n\ntypedef struct named_group {\n  PCRE2_SPTR   name;          /* Points to the name in the pattern */\n  uint32_t     number;        /* Group number */\n  uint16_t     length;        /* Length of the name */\n  uint16_t     isdup;         /* TRUE if a duplicate */\n} named_group;\n\n/* Structure for passing \"static\" information around between the functions\ndoing the compiling, so that they are thread-safe. */\n\ntypedef struct compile_block {\n  pcre2_real_compile_context *cx;  /* Points to the compile context */\n  const uint8_t *lcc;              /* Points to lower casing table */\n  const uint8_t *fcc;              /* Points to case-flipping table */\n  const uint8_t *cbits;            /* Points to character type table */\n  const uint8_t *ctypes;           /* Points to table of type maps */\n  PCRE2_SPTR start_workspace;      /* The start of working space */\n  PCRE2_SPTR start_code;           /* The start of the compiled code */\n  PCRE2_SPTR start_pattern;        /* The start of the pattern */\n  PCRE2_SPTR end_pattern;          /* The end of the pattern */\n  PCRE2_UCHAR *name_table;         /* The name/number table */\n  PCRE2_SIZE workspace_size;       /* Size of workspace */\n  PCRE2_SIZE small_ref_offset\u00dd10\u00a8; /* Offsets for \\1 to \\9 */\n  PCRE2_SIZE erroroffset;          /* Offset of error in pattern */\n  uint16_t names_found;            /* Number of entries so far */\n  uint16_t name_entry_size;        /* Size of each entry */\n  uint16_t parens_depth;           /* Depth of nested parentheses */\n  uint16_t assert_depth;           /* Depth of nested assertions */\n  open_capitem *open_caps;         /* Chain of open capture items */\n  named_group *named_groups;       /* Points to vector in pre-compile */\n  uint32_t named_group_list_size;  /* Number of entries in the list */\n  uint32_t external_options;       /* External (initial) options */\n  uint32_t external_flags;         /* External flag bits to be set */\n  uint32_t bracount;               /* Count of capturing parentheses */\n  uint32_t lastcapture;            /* Last capture encountered */\n  uint32_t *parsed_pattern;        /* Parsed pattern buffer */\n  uint32_t *parsed_pattern_end;    /* Parsed pattern should not get here */\n  uint32_t *groupinfo;             /* Group info vector */\n  uint32_t top_backref;            /* Maximum back reference */\n  uint32_t backref_map;            /* Bitmap of low back refs */\n  uint32_t nltype;                 /* Newline type */\n  uint32_t nllen;                  /* Newline string length */\n  uint32_t class_range_start;      /* Overall class range start */\n  uint32_t class_range_end;        /* Overall class range end */\n  PCRE2_UCHAR nl\u00dd4\u00a8;               /* Newline string when fixed length */\n  int  max_lookbehind;             /* Maximum lookbehind (characters) */\n  int  req_varyopt;                /* \"After variable item\" flag for reqbyte */\n  BOOL had_accept;                 /* (*ACCEPT) encountered */\n  BOOL had_pruneorskip;            /* (*PRUNE) or (*SKIP) encountered */\n  BOOL had_recurse;                /* Had a recursion or subroutine call */\n  BOOL dupnames;                   /* Duplicate names exist */\n} compile_block;\n\n/* Structure for keeping the properties of the in-memory stack used\nby the JIT matcher. */\n\ntypedef struct pcre2_real_jit_stack {\n  pcre2_memctl memctl;\n  void* stack;\n} pcre2_real_jit_stack;\n\n/* Structure for items in a linked list that represents an explicit recursive\ncall within the pattern when running pcre_dfa_match(). */\n\ntypedef struct dfa_recursion_info {\n  struct dfa_recursion_info *prevrec;\n  PCRE2_SPTR subject_position;\n  uint32_t group_num;\n} dfa_recursion_info;\n\n/* Structure for \"stack\" frames that are used for remembering backtracking\npositions during matching. As these are used in a vector, with the ovector item\nbeing extended, the size of the structure must be a multiple of PCRE2_SIZE. The\nonly way to check this at compile time is to force an error by generating an\narray with a negative size. By putting this in a typedef (which is never used),\nwe don't generate any code when all is well. */\n\ntypedef struct heapframe {\n\n  /* The first set of fields are variables that have to be preserved over calls\n  to RRMATCH(), but which do not need to be copied to new frames. */\n\n  PCRE2_SPTR ecode;          /* The current position in the pattern */\n  PCRE2_SPTR temp_sptr\u00dd2\u00a8;   /* Used for short-term PCRE_SPTR values */\n  PCRE2_SIZE length;         /* Used for character, string, or code lengths */\n  PCRE2_SIZE back_frame;     /* Amount to subtract on RRETURN */\n  PCRE2_SIZE temp_size;      /* Used for short-term PCRE2_SIZE values */\n  uint32_t rdepth;           /* \"Recursion\" depth */\n  uint32_t group_frame_type; /* Type information for group frames */\n  uint32_t temp_32\u00dd4\u00a8;       /* Used for short-term 32-bit or BOOL values */\n  uint8_t return_id;         /* Where to go on in internal \"return\" */\n  uint8_t op;                /* Processing opcode */\n\n  /* At this point, the structure is 16-bit aligned. On most architectures\n  the alignment requirement for a pointer will ensure that the eptr field below\n  is 32-bit or 64-bit aligned. However, on m68k it is fine to have a pointer\n  that is 16-bit aligned. We must therefore ensure that what comes between here\n  and eptr is an odd multiple of 16 bits so as to get back into 32-bit\n  alignment. This happens naturally when PCRE2_UCHAR is 8 bits wide, but needs\n  fudges in the other cases. In the 32-bit case the padding comes first so that\n  the occu field itself is 32-bit aligned. Without the padding, this structure\n  is no longer a multiple of PCRE2_SIZE on m68k, and the check below fails. */\n\n#if PCRE2_CODE_UNIT_WIDTH == 8\n  PCRE2_UCHAR occu\u00dd6\u00a8;       /* Used for other case code units */\n#elif PCRE2_CODE_UNIT_WIDTH == 16\n  PCRE2_UCHAR occu\u00dd2\u00a8;       /* Used for other case code units */\n  uint8_t unused\u00dd2\u00a8;         /* Ensure 32-bit alignment (see above) */\n#else\n  uint8_t unused\u00dd2\u00a8;         /* Ensure 32-bit alignment (see above) */\n  PCRE2_UCHAR occu\u00dd1\u00a8;       /* Used for other case code units */\n#endif\n\n  /* The rest have to be copied from the previous frame whenever a new frame\n  becomes current. The final field is specified as a large vector so that\n  runtime array bound checks don't catch references to it. However, for any\n  specific call to pcre2_match() the memory allocated for each frame structure\n  allows for exactly the right size ovector for the number of capturing\n  parentheses. (See also the comment for pcre2_real_match_data above.) */\n\n  PCRE2_SPTR eptr;           /* MUST BE FIRST */\n  PCRE2_SPTR start_match;    /* Can be adjusted by \\K */\n  PCRE2_SPTR mark;           /* Most recent mark on the success path */\n  uint32_t current_recurse;  /* Current (deepest) recursion number */\n  uint32_t capture_last;     /* Most recent capture */\n  PCRE2_SIZE last_group_offset;  /* Saved offset to most recent group frame */\n  PCRE2_SIZE offset_top;     /* Offset after highest capture */\n  PCRE2_SIZE ovector\u00dd131072\u00a8; /* Must be last in the structure */\n} heapframe;\n\n/* This typedef is a check that the size of the heapframe structure is a\nmultiple of PCRE2_SIZE. See various comments above. */\n\ntypedef char check_heapframe_size\u00dd\n  ((sizeof(heapframe) % sizeof(PCRE2_SIZE)) == 0)? (+1):(-1)\u00a8;\n\n/* Structure for passing \"static\" information around between the functions\ndoing traditional NFA matching (pcre2_match() and friends). */\n\ntypedef struct match_block {\n  pcre2_memctl memctl;            /* For general use */\n  PCRE2_SIZE frame_vector_size;   /* Size of a backtracking frame */\n  heapframe *match_frames;        /* Points to vector of frames */\n  heapframe *match_frames_top;    /* Points after the end of the vector */\n  heapframe *stack_frames;        /* The original vector on the stack */\n  PCRE2_SIZE heap_limit;          /* As it says */\n  uint32_t match_limit;           /* As it says */\n  uint32_t match_limit_depth;     /* As it says */\n  uint32_t match_call_count;      /* Number of times a new frame is created */\n  BOOL hitend;                    /* Hit the end of the subject at some point */\n  BOOL hasthen;                   /* Pattern contains (*THEN) */\n  BOOL allowemptypartial;         /* Allow empty hard partial */\n  const uint8_t *lcc;             /* Points to lower casing table */\n  const uint8_t *fcc;             /* Points to case-flipping table */\n  const uint8_t *ctypes;          /* Points to table of type maps */\n  PCRE2_SIZE start_offset;        /* The start offset value */\n  PCRE2_SIZE end_offset_top;      /* Highwater mark at end of match */\n  uint16_t partial;               /* PARTIAL options */\n  uint16_t bsr_convention;        /* \\R interpretation */\n  uint16_t name_count;            /* Number of names in name table */\n  uint16_t name_entry_size;       /* Size of entry in names table */\n  PCRE2_SPTR name_table;          /* Table of group names */\n  PCRE2_SPTR start_code;          /* For use when recursing */\n  PCRE2_SPTR start_subject;       /* Start of the subject string */\n  PCRE2_SPTR check_subject;       /* Where UTF-checked from */\n  PCRE2_SPTR end_subject;         /* End of the subject string */\n  PCRE2_SPTR end_match_ptr;       /* Subject position at end match */\n  PCRE2_SPTR start_used_ptr;      /* Earliest consulted character */\n  PCRE2_SPTR last_used_ptr;       /* Latest consulted character */\n  PCRE2_SPTR mark;                /* Mark pointer to pass back on success */\n  PCRE2_SPTR nomatch_mark;        /* Mark pointer to pass back on failure */\n  PCRE2_SPTR verb_ecode_ptr;      /* For passing back info */\n  PCRE2_SPTR verb_skip_ptr;       /* For passing back a (*SKIP) name */\n  uint32_t verb_current_recurse;  /* Current recurse when (*VERB) happens */\n  uint32_t moptions;              /* Match options */\n  uint32_t poptions;              /* Pattern options */\n  uint32_t skip_arg_count;        /* For counting SKIP_ARGs */\n  uint32_t ignore_skip_arg;       /* For re-run when SKIP arg name not found */\n  uint32_t nltype;                /* Newline type */\n  uint32_t nllen;                 /* Newline string length */\n  PCRE2_UCHAR nl\u00dd4\u00a8;              /* Newline string when fixed */\n  pcre2_callout_block *cb;        /* Points to a callout block */\n  void  *callout_data;            /* To pass back to callouts */\n  int (*callout)(pcre2_callout_block *,void *);  /* Callout function or NULL */\n} match_block;\n\n/* A similar structure is used for the same purpose by the DFA matching\nfunctions. */\n\ntypedef struct dfa_match_block {\n  pcre2_memctl memctl;            /* For general use */\n  PCRE2_SPTR start_code;          /* Start of the compiled pattern */\n  PCRE2_SPTR start_subject ;      /* Start of the subject string */\n  PCRE2_SPTR end_subject;         /* End of subject string */\n  PCRE2_SPTR start_used_ptr;      /* Earliest consulted character */\n  PCRE2_SPTR last_used_ptr;       /* Latest consulted character */\n  const uint8_t *tables;          /* Character tables */\n  PCRE2_SIZE start_offset;        /* The start offset value */\n  PCRE2_SIZE heap_limit;          /* As it says */\n  PCRE2_SIZE heap_used;           /* As it says */\n  uint32_t match_limit;           /* As it says */\n  uint32_t match_limit_depth;     /* As it says */\n  uint32_t match_call_count;      /* Number of calls of internal function */\n  uint32_t moptions;              /* Match options */\n  uint32_t poptions;              /* Pattern options */\n  uint32_t nltype;                /* Newline type */\n  uint32_t nllen;                 /* Newline string length */\n  BOOL allowemptypartial;         /* Allow empty hard partial */\n  PCRE2_UCHAR nl\u00dd4\u00a8;              /* Newline string when fixed */\n  uint16_t bsr_convention;        /* \\R interpretation */\n  pcre2_callout_block *cb;        /* Points to a callout block */\n  void *callout_data;             /* To pass back to callouts */\n  int (*callout)(pcre2_callout_block *,void *);  /* Callout function or NULL */\n  dfa_recursion_info *recursive;  /* Linked list of recursion data */\n} dfa_match_block;\n\n#endif  /* PCRE2_PCRE2TEST */\n\n/* End of pcre2_intmodedep.h */\n/*autoconv-0001 C:\\projects\\pcre2-10.35\\src\\pcre2_intmodedep.h converted to INTMODE2*/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "JITCOMP2": {"ttr": 10241, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "\n/*************************************************\n*      Perl-Compatible Regular Expressions       *\n*************************************************/\n\n/* PCRE is a library of functions to support regular expressions whose syntax\nand semantics are as close as possible to those of the Perl 5 language.\n\n                       Written by Philip Hazel\n                    This module by Zoltan Herczeg\n     Original API code Copyright (c) 1997-2012 University of Cambridge\n          New API code Copyright (c) 2016-2019 University of Cambridge\n\n-----------------------------------------------------------------------------\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n\n    * Redistributions of source code must retain the above copyright notice,\n      this list of conditions and the following disclaimer.\n\n    * Redistributions in binary form must reproduce the above copyright\n      notice, this list of conditions and the following disclaimer in the\n      documentation and/or other materials provided with the distribution.\n\n    * Neither the name of the University of Cambridge nor the names of its\n      contributors may be used to endorse or promote products derived from\n      this software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\nAND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\nIMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\nARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\nLIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\nCONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\nSUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\nINTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\nCONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\nARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\nPOSSIBILITY OF SUCH DAMAGE.\n-----------------------------------------------------------------------------\n*/\n\n#ifdef HAVE_CONFIG_H\n#include \"CONFIG.h\"\n#endif\n\n#include \"INTERNA2.h\"\n\n#ifdef SUPPORT_JIT\n\n/* All-in-one: Since we use the JIT compiler only from here,\nwe just include it. This way we don't need to touch the build\nsystem files. */\n\n#define SLJIT_CONFIG_AUTO 1\n#define SLJIT_CONFIG_STATIC 1\n#define SLJIT_VERBOSE 0\n\n#ifdef PCRE2_DEBUG\n#define SLJIT_DEBUG 1\n#else\n#define SLJIT_DEBUG 0\n#endif\n\n#define SLJIT_MALLOC(size, allocator_data) pcre2_jit_malloc(size, allocator_data)\n#define SLJIT_FREE(ptr, allocator_data) pcre2_jit_free(ptr, allocator_data)\n\nstatic void * pcre2_jit_malloc(size_t size, void *allocator_data)\n{\npcre2_memctl *allocator = ((pcre2_memctl*)allocator_data);\nreturn allocator->malloc(size, allocator->memory_data);\n}\n\nstatic void pcre2_jit_free(void *ptr, void *allocator_data)\n{\npcre2_memctl *allocator = ((pcre2_memctl*)allocator_data);\nallocator->free(ptr, allocator->memory_data);\n}\n\n#include \"sljit/sljitLir.c\"\n\n#if defined SLJIT_CONFIG_UNSUPPORTED && SLJIT_CONFIG_UNSUPPORTED\n#error Unsupported architecture\n#endif\n\n/* Defines for debugging purposes. */\n\n/* 1 - Use unoptimized capturing brackets.\n   2 - Enable capture_last_ptr (includes option 1). */\n/* #define DEBUG_FORCE_UNOPTIMIZED_CBRAS 2 */\n\n/* 1 - Always have a control head. */\n/* #define DEBUG_FORCE_CONTROL_HEAD 1 */\n\n/* Allocate memory for the regex stack on the real machine stack.\nFast, but limited size. */\n#define MACHINE_STACK_SIZE 32768\n\n/* Growth rate for stack allocated by the OS. Should be the multiply\nof page size. */\n#define STACK_GROWTH_RATE 8192\n\n/* Enable to check that the allocation could destroy temporaries. */\n#if defined SLJIT_DEBUG && SLJIT_DEBUG\n#define DESTROY_REGISTERS 1\n#endif\n\n/*\nShort summary about the backtracking mechanism empolyed by the jit code generator:\n\nThe code generator follows the recursive nature of the PERL compatible regular\nexpressions. The basic blocks of regular expressions are condition checkers\nwhose execute different commands depending on the result of the condition check.\nThe relationship between the operators can be horizontal (concatenation) and\nvertical (sub-expression) (See struct backtrack_common for more details).\n\n  'ab' - 'a' and 'b' regexps are concatenated\n  'a+' - 'a' is the sub-expression of the '+' operator\n\nThe condition checkers are boolean (true/false) checkers. Machine code is generated\nfor the checker itself and for the actions depending on the result of the checker.\nThe 'true' case is called as the matching path (expected path), and the other is called as\nthe 'backtrack' path. Branch instructions are expesive for all CPUs, so we avoid taken\nbranches on the matching path.\n\n Greedy star operator (*) :\n   Matching path: match happens.\n   Backtrack path: match failed.\n Non-greedy star operator (*?) :\n   Matching path: no need to perform a match.\n   Backtrack path: match is required.\n\nThe following example shows how the code generated for a capturing bracket\nwith two alternatives. Let A, B, C, D are arbirary regular expressions, and\nwe have the following regular expression:\n\n   A(B|C)D\n\nThe generated code will be the following:\n\n A matching path\n '(' matching path (pushing arguments to the stack)\n B matching path\n ')' matching path (pushing arguments to the stack)\n D matching path\n return with successful match\n\n D backtrack path\n ')' backtrack path (If we arrived from \"C\" jump to the backtrack of \"C\")\n B backtrack path\n C expected path\n jump to D matching path\n C backtrack path\n A backtrack path\n\n Notice, that the order of backtrack code paths are the opposite of the fast\n code paths. In this way the topmost value on the stack is always belong\n to the current backtrack code path. The backtrack path must check\n whether there is a next alternative. If so, it needs to jump back to\n the matching path eventually. Otherwise it needs to clear out its own stack\n frame and continue the execution on the backtrack code paths.\n*/\n\n/*\nSaved stack frames:\n\nAtomic blocks and asserts require reloading the values of private data\nwhen the backtrack mechanism performed. Because of OP_RECURSE, the data\nare not necessarly known in compile time, thus we need a dynamic restore\nmechanism.\n\nThe stack frames are stored in a chain list, and have the following format:\n(\u00dd capturing bracket offset \u00a8\u00dd start value \u00a8\u00dd end value \u00a8)+ ... \u00dd 0 \u00a8 \u00dd previous head \u00a8\n\nThus we can restore the private data to a particular point in the stack.\n*/\n\ntypedef struct jit_arguments {\n  /* Pointers first. */\n  struct sljit_stack *stack;\n  PCRE2_SPTR str;\n  PCRE2_SPTR begin;\n  PCRE2_SPTR end;\n  pcre2_match_data *match_data;\n  PCRE2_SPTR startchar_ptr;\n  PCRE2_UCHAR *mark_ptr;\n  int (*callout)(pcre2_callout_block *, void *);\n  void *callout_data;\n  /* Everything else after. */\n  sljit_uw offset_limit;\n  sljit_u32 limit_match;\n  sljit_u32 oveccount;\n  sljit_u32 options;\n} jit_arguments;\n\n#define JIT_NUMBER_OF_COMPILE_MODES 3\n\ntypedef struct executable_functions {\n  void *executable_funcs\u00ddJIT_NUMBER_OF_COMPILE_MODES\u00a8;\n  void *read_only_data_heads\u00ddJIT_NUMBER_OF_COMPILE_MODES\u00a8;\n  sljit_uw executable_sizes\u00ddJIT_NUMBER_OF_COMPILE_MODES\u00a8;\n  sljit_u32 top_bracket;\n  sljit_u32 limit_match;\n} executable_functions;\n\ntypedef struct jump_list {\n  struct sljit_jump *jump;\n  struct jump_list *next;\n} jump_list;\n\ntypedef struct stub_list {\n  struct sljit_jump *start;\n  struct sljit_label *quit;\n  struct stub_list *next;\n} stub_list;\n\nenum frame_types {\n  no_frame = -1,\n  no_stack = -2\n};\n\nenum control_types {\n  type_mark = 0,\n  type_then_trap = 1\n};\n\nenum  early_fail_types {\n  type_skip = 0,\n  type_fail = 1,\n  type_fail_range = 2\n};\n\ntypedef int (SLJIT_FUNC *jit_function)(jit_arguments *args);\n\n/* The following structure is the key data type for the recursive\ncode generator. It is allocated by compile_matchingpath, and contains\nthe arguments for compile_backtrackingpath. Must be the first member\nof its descendants. */\ntypedef struct backtrack_common {\n  /* Concatenation stack. */\n  struct backtrack_common *prev;\n  jump_list *nextbacktracks;\n  /* Internal stack (for component operators). */\n  struct backtrack_common *top;\n  jump_list *topbacktracks;\n  /* Opcode pointer. */\n  PCRE2_SPTR cc;\n} backtrack_common;\n\ntypedef struct assert_backtrack {\n  backtrack_common common;\n  jump_list *condfailed;\n  /* Less than 0 if a frame is not needed. */\n  int framesize;\n  /* Points to our private memory word on the stack. */\n  int private_data_ptr;\n  /* For iterators. */\n  struct sljit_label *matchingpath;\n} assert_backtrack;\n\ntypedef struct bracket_backtrack {\n  backtrack_common common;\n  /* Where to coninue if an alternative is successfully matched. */\n  struct sljit_label *alternative_matchingpath;\n  /* For rmin and rmax iterators. */\n  struct sljit_label *recursive_matchingpath;\n  /* For greedy ? operator. */\n  struct sljit_label *zero_matchingpath;\n  /* Contains the branches of a failed condition. */\n  union {\n    /* Both for OP_COND, OP_SCOND. */\n    jump_list *condfailed;\n    assert_backtrack *assert;\n    /* For OP_ONCE. Less than 0 if not needed. */\n    int framesize;\n    /* For brackets with >3 alternatives. */\n    struct sljit_put_label *matching_put_label;\n  } u;\n  /* Points to our private memory word on the stack. */\n  int private_data_ptr;\n} bracket_backtrack;\n\ntypedef struct bracketpos_backtrack {\n  backtrack_common common;\n  /* Points to our private memory word on the stack. */\n  int private_data_ptr;\n  /* Reverting stack is needed. */\n  int framesize;\n  /* Allocated stack size. */\n  int stacksize;\n} bracketpos_backtrack;\n\ntypedef struct braminzero_backtrack {\n  backtrack_common common;\n  struct sljit_label *matchingpath;\n} braminzero_backtrack;\n\ntypedef struct char_iterator_backtrack {\n  backtrack_common common;\n  /* Next iteration. */\n  struct sljit_label *matchingpath;\n  union {\n    jump_list *backtracks;\n    struct {\n      unsigned int othercasebit;\n      PCRE2_UCHAR chr;\n      BOOL enabled;\n    } charpos;\n  } u;\n} char_iterator_backtrack;\n\ntypedef struct ref_iterator_backtrack {\n  backtrack_common common;\n  /* Next iteration. */\n  struct sljit_label *matchingpath;\n} ref_iterator_backtrack;\n\ntypedef struct recurse_entry {\n  struct recurse_entry *next;\n  /* Contains the function entry label. */\n  struct sljit_label *entry_label;\n  /* Contains the function entry label. */\n  struct sljit_label *backtrack_label;\n  /* Collects the entry calls until the function is not created. */\n  jump_list *entry_calls;\n  /* Collects the backtrack calls until the function is not created. */\n  jump_list *backtrack_calls;\n  /* Points to the starting opcode. */\n  sljit_sw start;\n} recurse_entry;\n\ntypedef struct recurse_backtrack {\n  backtrack_common common;\n  /* Return to the matching path. */\n  struct sljit_label *matchingpath;\n  /* Recursive pattern. */\n  recurse_entry *entry;\n  /* Pattern is inlined. */\n  BOOL inlined_pattern;\n} recurse_backtrack;\n\n#define OP_THEN_TRAP OP_TABLE_LENGTH\n\ntypedef struct then_trap_backtrack {\n  backtrack_common common;\n  /* If then_trap is not NULL, this structure contains the real\n  then_trap for the backtracking path. */\n  struct then_trap_backtrack *then_trap;\n  /* Points to the starting opcode. */\n  sljit_sw start;\n  /* Exit point for the then opcodes of this alternative. */\n  jump_list *quit;\n  /* Frame size of the current alternative. */\n  int framesize;\n} then_trap_backtrack;\n\n#define MAX_N_CHARS 12\n#define MAX_DIFF_CHARS 5\n\ntypedef struct fast_forward_char_data {\n  /* Number of characters in the chars array, 255 for any character. */\n  sljit_u8 count;\n  /* Number of last UTF-8 characters in the chars array. */\n  sljit_u8 last_count;\n  /* Available characters in the current position. */\n  PCRE2_UCHAR chars\u00ddMAX_DIFF_CHARS\u00a8;\n} fast_forward_char_data;\n\n#define MAX_CLASS_RANGE_SIZE 4\n#define MAX_CLASS_CHARS_SIZE 3\n\ntypedef struct compiler_common {\n  /* The sljit ceneric compiler. */\n  struct sljit_compiler *compiler;\n  /* Compiled regular expression. */\n  pcre2_real_code *re;\n  /* First byte code. */\n  PCRE2_SPTR start;\n  /* Maps private data offset to each opcode. */\n  sljit_s32 *private_data_ptrs;\n  /* Chain list of read-only data ptrs. */\n  void *read_only_data_head;\n  /* Tells whether the capturing bracket is optimized. */\n  sljit_u8 *optimized_cbracket;\n  /* Tells whether the starting offset is a target of then. */\n  sljit_u8 *then_offsets;\n  /* Current position where a THEN must jump. */\n  then_trap_backtrack *then_trap;\n  /* Starting offset of private data for capturing brackets. */\n  sljit_s32 cbra_ptr;\n  /* Output vector starting point. Must be divisible by 2. */\n  sljit_s32 ovector_start;\n  /* Points to the starting character of the current match. */\n  sljit_s32 start_ptr;\n  /* Last known position of the requested byte. */\n  sljit_s32 req_char_ptr;\n  /* Head of the last recursion. */\n  sljit_s32 recursive_head_ptr;\n  /* First inspected character for partial matching.\n     (Needed for avoiding zero length partial matches.) */\n  sljit_s32 start_used_ptr;\n  /* Starting pointer for partial soft matches. */\n  sljit_s32 hit_start;\n  /* Pointer of the match end position. */\n  sljit_s32 match_end_ptr;\n  /* Points to the marked string. */\n  sljit_s32 mark_ptr;\n  /* Recursive control verb management chain. */\n  sljit_s32 control_head_ptr;\n  /* Points to the last matched capture block index. */\n  sljit_s32 capture_last_ptr;\n  /* Fast forward skipping byte code pointer. */\n  PCRE2_SPTR fast_forward_bc_ptr;\n  /* Locals used by fast fail optimization. */\n  sljit_s32 early_fail_start_ptr;\n  sljit_s32 early_fail_end_ptr;\n\n  /* Flipped and lower case tables. */\n  const sljit_u8 *fcc;\n  sljit_sw lcc;\n  /* Mode can be PCRE2_JIT_COMPLETE and others. */\n  int mode;\n  /* TRUE, when empty match is accepted for partial matching. */\n  BOOL allow_empty_partial;\n  /* TRUE, when minlength is greater than 0. */\n  BOOL might_be_empty;\n  /* \\K is found in the pattern. */\n  BOOL has_set_som;\n  /* (*SKIP:arg) is found in the pattern. */\n  BOOL has_skip_arg;\n  /* (*THEN) is found in the pattern. */\n  BOOL has_then;\n  /* (*SKIP) or (*SKIP:arg) is found in lookbehind assertion. */\n  BOOL has_skip_in_assert_back;\n  /* Quit is redirected by recurse, negative assertion, or positive assertion in conditional block. */\n  BOOL local_quit_available;\n  /* Currently in a positive assertion. */\n  BOOL in_positive_assertion;\n  /* Newline control. */\n  int nltype;\n  sljit_u32 nlmax;\n  sljit_u32 nlmin;\n  int newline;\n  int bsr_nltype;\n  sljit_u32 bsr_nlmax;\n  sljit_u32 bsr_nlmin;\n  /* Dollar endonly. */\n  int endonly;\n  /* Tables. */\n  sljit_sw ctypes;\n  /* Named capturing brackets. */\n  PCRE2_SPTR name_table;\n  sljit_sw name_count;\n  sljit_sw name_entry_size;\n\n  /* Labels and jump lists. */\n  struct sljit_label *partialmatchlabel;\n  struct sljit_label *quit_label;\n  struct sljit_label *abort_label;\n  struct sljit_label *accept_label;\n  struct sljit_label *ff_newline_shortcut;\n  stub_list *stubs;\n  recurse_entry *entries;\n  recurse_entry *currententry;\n  jump_list *partialmatch;\n  jump_list *quit;\n  jump_list *positive_assertion_quit;\n  jump_list *abort;\n  jump_list *failed_match;\n  jump_list *accept;\n  jump_list *calllimit;\n  jump_list *stackalloc;\n  jump_list *revertframes;\n  jump_list *wordboundary;\n  jump_list *anynewline;\n  jump_list *hspace;\n  jump_list *vspace;\n  jump_list *casefulcmp;\n  jump_list *caselesscmp;\n  jump_list *reset_match;\n  BOOL unset_backref;\n  BOOL alt_circumflex;\n#ifdef SUPPORT_UNICODE\n  BOOL utf;\n  BOOL invalid_utf;\n  BOOL ucp;\n  /* Points to saving area for iref. */\n  sljit_s32 iref_ptr;\n  jump_list *getucd;\n  jump_list *getucdtype;\n#if PCRE2_CODE_UNIT_WIDTH == 8\n  jump_list *utfreadchar;\n  jump_list *utfreadtype8;\n  jump_list *utfpeakcharback;\n#endif\n#if PCRE2_CODE_UNIT_WIDTH == 8 || PCRE2_CODE_UNIT_WIDTH == 16\n  jump_list *utfreadchar_invalid;\n  jump_list *utfreadnewline_invalid;\n  jump_list *utfmoveback_invalid;\n  jump_list *utfpeakcharback_invalid;\n#endif\n#endif /* SUPPORT_UNICODE */\n} compiler_common;\n\n/* For byte_sequence_compare. */\n\ntypedef struct compare_context {\n  int length;\n  int sourcereg;\n#if defined SLJIT_UNALIGNED && SLJIT_UNALIGNED\n  int ucharptr;\n  union {\n    sljit_s32 asint;\n    sljit_u16 asushort;\n#if PCRE2_CODE_UNIT_WIDTH == 8\n    sljit_u8 asbyte;\n    sljit_u8 asuchars\u00dd4\u00a8;\n#elif PCRE2_CODE_UNIT_WIDTH == 16\n    sljit_u16 asuchars\u00dd2\u00a8;\n#elif PCRE2_CODE_UNIT_WIDTH == 32\n    sljit_u32 asuchars\u00dd1\u00a8;\n#endif\n  } c;\n  union {\n    sljit_s32 asint;\n    sljit_u16 asushort;\n#if PCRE2_CODE_UNIT_WIDTH == 8\n    sljit_u8 asbyte;\n    sljit_u8 asuchars\u00dd4\u00a8;\n#elif PCRE2_CODE_UNIT_WIDTH == 16\n    sljit_u16 asuchars\u00dd2\u00a8;\n#elif PCRE2_CODE_UNIT_WIDTH == 32\n    sljit_u32 asuchars\u00dd1\u00a8;\n#endif\n  } oc;\n#endif\n} compare_context;\n\n/* Undefine sljit macros. */\n#undef CMP\n\n/* Used for accessing the elements of the stack. */\n#define STACK(i)      ((i) * (int)sizeof(sljit_sw))\n\n#ifdef SLJIT_PREF_SHIFT_REG\n#if SLJIT_PREF_SHIFT_REG == SLJIT_R2\n/* Nothing. */\n#elif SLJIT_PREF_SHIFT_REG == SLJIT_R3\n#define SHIFT_REG_IS_R3\n#else\n#error \"Unsupported shift register\"\n#endif\n#endif\n\n#define TMP1          SLJIT_R0\n#ifdef SHIFT_REG_IS_R3\n#define TMP2          SLJIT_R3\n#define TMP3          SLJIT_R2\n#else\n#define TMP2          SLJIT_R2\n#define TMP3          SLJIT_R3\n#endif\n#define STR_PTR       SLJIT_R1\n#define STR_END       SLJIT_S0\n#define STACK_TOP     SLJIT_S1\n#define STACK_LIMIT   SLJIT_S2\n#define COUNT_MATCH   SLJIT_S3\n#define ARGUMENTS     SLJIT_S4\n#define RETURN_ADDR   SLJIT_R4\n\n#if (defined SLJIT_CONFIG_X86_32 && SLJIT_CONFIG_X86_32)\n#define HAS_VIRTUAL_REGISTERS 1\n#else\n#define HAS_VIRTUAL_REGISTERS 0\n#endif\n\n/* Local space layout. */\n/* These two locals can be used by the current opcode. */\n#define LOCALS0          (0 * sizeof(sljit_sw))\n#define LOCALS1          (1 * sizeof(sljit_sw))\n/* Two local variables for possessive quantifiers (char1 cannot use them). */\n#define POSSESSIVE0      (2 * sizeof(sljit_sw))\n#define POSSESSIVE1      (3 * sizeof(sljit_sw))\n/* Max limit of recursions. */\n#define LIMIT_MATCH      (4 * sizeof(sljit_sw))\n/* The output vector is stored on the stack, and contains pointers\nto characters. The vector data is divided into two groups: the first\ngroup contains the start / end character pointers, and the second is\nthe start pointers when the end of the capturing group has not yet reached. */\n#define OVECTOR_START    (common->ovector_start)\n#define OVECTOR(i)       (OVECTOR_START + (i) * (sljit_sw)sizeof(sljit_sw))\n#define OVECTOR_PRIV(i)  (common->cbra_ptr + (i) * (sljit_sw)sizeof(sljit_sw))\n#define PRIVATE_DATA(cc) (common->private_data_ptrs\u00dd(cc) - common->start\u00a8)\n\n#if PCRE2_CODE_UNIT_WIDTH == 8\n#define MOV_UCHAR  SLJIT_MOV_U8\n#define IN_UCHARS(x) (x)\n#elif PCRE2_CODE_UNIT_WIDTH == 16\n#define MOV_UCHAR  SLJIT_MOV_U16\n#define UCHAR_SHIFT (1)\n#define IN_UCHARS(x) ((x) * 2)\n#elif PCRE2_CODE_UNIT_WIDTH == 32\n#define MOV_UCHAR  SLJIT_MOV_U32\n#define UCHAR_SHIFT (2)\n#define IN_UCHARS(x) ((x) * 4)\n#else\n#error Unsupported compiling mode\n#endif\n\n/* Shortcuts. */\n#define DEFINE_COMPILER \\\n  struct sljit_compiler *compiler = common->compiler\n#define OP1(op, dst, dstw, src, srcw) \\\n  sljit_emit_op1(compiler, (op), (dst), (dstw), (src), (srcw))\n#define OP2(op, dst, dstw, src1, src1w, src2, src2w) \\\n  sljit_emit_op2(compiler, (op), (dst), (dstw), (src1), (src1w), (src2), (src2w))\n#define OP_SRC(op, src, srcw) \\\n  sljit_emit_op_src(compiler, (op), (src), (srcw))\n#define LABEL() \\\n  sljit_emit_label(compiler)\n#define JUMP(type) \\\n  sljit_emit_jump(compiler, (type))\n#define JUMPTO(type, label) \\\n  sljit_set_label(sljit_emit_jump(compiler, (type)), (label))\n#define JUMPHERE(jump) \\\n  sljit_set_label((jump), sljit_emit_label(compiler))\n#define SET_LABEL(jump, label) \\\n  sljit_set_label((jump), (label))\n#define CMP(type, src1, src1w, src2, src2w) \\\n  sljit_emit_cmp(compiler, (type), (src1), (src1w), (src2), (src2w))\n#define CMPTO(type, src1, src1w, src2, src2w, label) \\\n  sljit_set_label(sljit_emit_cmp(compiler, (type), (src1), (src1w), (src2), (src2w)), (label))\n#define OP_FLAGS(op, dst, dstw, type) \\\n  sljit_emit_op_flags(compiler, (op), (dst), (dstw), (type))\n#define CMOV(type, dst_reg, src, srcw) \\\n  sljit_emit_cmov(compiler, (type), (dst_reg), (src), (srcw))\n#define GET_LOCAL_BASE(dst, dstw, offset) \\\n  sljit_get_local_base(compiler, (dst), (dstw), (offset))\n\n#define READ_CHAR_MAX 0x7fffffff\n\n#define INVALID_UTF_CHAR -1\n#define UNASSIGNED_UTF_CHAR 888\n\n#if defined SUPPORT_UNICODE\n#if PCRE2_CODE_UNIT_WIDTH == 8\n\n#define GETCHARINC_INVALID(c, ptr, end, invalid_action) \\\n  { \\\n  if (ptr\u00dd0\u00a8 <= 0x7f) \\\n    c = *ptr++; \\\n  else if (ptr + 1 < end && ptr\u00dd1\u00a8 >= 0x80 && ptr\u00dd1\u00a8 < 0xc0) \\\n    { \\\n    c = ptr\u00dd1\u00a8 - 0x80; \\\n    \\\n    if (ptr\u00dd0\u00a8 >= 0xc2 && ptr\u00dd0\u00a8 <= 0xdf) \\\n      { \\\n      c |= (ptr\u00dd0\u00a8 - 0xc0) << 6; \\\n      ptr += 2; \\\n      } \\\n    else if (ptr + 2 < end && ptr\u00dd2\u00a8 >= 0x80 && ptr\u00dd2\u00a8 < 0xc0) \\\n      { \\\n      c = c << 6 | (ptr\u00dd2\u00a8 - 0x80); \\\n      \\\n      if (ptr\u00dd0\u00a8 >= 0xe0 && ptr\u00dd0\u00a8 <= 0xef) \\\n        { \\\n        c |= (ptr\u00dd0\u00a8 - 0xe0) << 12; \\\n        ptr += 3; \\\n        \\\n        if (c < 0x800 || (c >= 0xd800 && c < 0xe000)) \\\n          { \\\n          invalid_action; \\\n          } \\\n        } \\\n      else if (ptr + 3 < end && ptr\u00dd3\u00a8 >= 0x80 && ptr\u00dd3\u00a8 < 0xc0) \\\n        { \\\n        c = c << 6 | (ptr\u00dd3\u00a8 - 0x80); \\\n        \\\n        if (ptr\u00dd0\u00a8 >= 0xf0 && ptr\u00dd0\u00a8 <= 0xf4) \\\n          { \\\n          c |= (ptr\u00dd0\u00a8 - 0xf0) << 18; \\\n          ptr += 4; \\\n          \\\n          if (c >= 0x110000 || c < 0x10000) \\\n            { \\\n            invalid_action; \\\n            } \\\n          } \\\n        else \\\n          { \\\n          invalid_action; \\\n          } \\\n        } \\\n      else \\\n        { \\\n        invalid_action; \\\n        } \\\n      } \\\n    else \\\n      { \\\n      invalid_action; \\\n      } \\\n    } \\\n  else \\\n    { \\\n    invalid_action; \\\n    } \\\n  }\n\n#define GETCHARBACK_INVALID(c, ptr, start, invalid_action) \\\n  { \\\n  c = ptr\u00dd-1\u00a8; \\\n  if (c <= 0x7f) \\\n    ptr--; \\\n  else if (ptr - 1 > start && ptr\u00dd-1\u00a8 >= 0x80 && ptr\u00dd-1\u00a8 < 0xc0) \\\n    { \\\n    c -= 0x80; \\\n    \\\n    if (ptr\u00dd-2\u00a8 >= 0xc2 && ptr\u00dd-2\u00a8 <= 0xdf) \\\n      { \\\n      c |= (ptr\u00dd-2\u00a8 - 0xc0) << 6; \\\n      ptr -= 2; \\\n      } \\\n    else if (ptr - 2 > start && ptr\u00dd-2\u00a8 >= 0x80 && ptr\u00dd-2\u00a8 < 0xc0) \\\n      { \\\n      c = c << 6 | (ptr\u00dd-2\u00a8 - 0x80); \\\n      \\\n      if (ptr\u00dd-3\u00a8 >= 0xe0 && ptr\u00dd-3\u00a8 <= 0xef) \\\n        { \\\n        c |= (ptr\u00dd-3\u00a8 - 0xe0) << 12; \\\n        ptr -= 3; \\\n        \\\n        if (c < 0x800 || (c >= 0xd800 && c < 0xe000)) \\\n          { \\\n          invalid_action; \\\n          } \\\n        } \\\n      else if (ptr - 3 > start && ptr\u00dd-3\u00a8 >= 0x80 && ptr\u00dd-3\u00a8 < 0xc0) \\\n        { \\\n        c = c << 6 | (ptr\u00dd-3\u00a8 - 0x80); \\\n        \\\n        if (ptr\u00dd-4\u00a8 >= 0xf0 && ptr\u00dd-4\u00a8 <= 0xf4) \\\n          { \\\n          c |= (ptr\u00dd-4\u00a8 - 0xf0) << 18; \\\n          ptr -= 4; \\\n          \\\n          if (c >= 0x110000 || c < 0x10000) \\\n            { \\\n            invalid_action; \\\n            } \\\n          } \\\n        else \\\n          { \\\n          invalid_action; \\\n          } \\\n        } \\\n      else \\\n        { \\\n        invalid_action; \\\n        } \\\n      } \\\n    else \\\n      { \\\n      invalid_action; \\\n      } \\\n    } \\\n  else \\\n    { \\\n    invalid_action; \\\n    } \\\n  }\n\n#elif PCRE2_CODE_UNIT_WIDTH == 16\n\n#define GETCHARINC_INVALID(c, ptr, end, invalid_action) \\\n  { \\\n  if (ptr\u00dd0\u00a8 < 0xd800 || ptr\u00dd0\u00a8 >= 0xe000) \\\n    c = *ptr++; \\\n  else if (ptr\u00dd0\u00a8 < 0xdc00 && ptr + 1 < end && ptr\u00dd1\u00a8 >= 0xdc00 && ptr\u00dd1\u00a8 < 0xe000) \\\n    { \\\n    c = (((ptr\u00dd0\u00a8 - 0xd800) << 10) | (ptr\u00dd1\u00a8 - 0xdc00)) + 0x10000; \\\n    ptr += 2; \\\n    } \\\n  else \\\n    { \\\n    invalid_action; \\\n    } \\\n  }\n\n#define GETCHARBACK_INVALID(c, ptr, start, invalid_action) \\\n  { \\\n  c = ptr\u00dd-1\u00a8; \\\n  if (c < 0xd800 || c >= 0xe000) \\\n    ptr--; \\\n  else if (c >= 0xdc00 && ptr - 1 > start && ptr\u00dd-2\u00a8 >= 0xd800 && ptr\u00dd-2\u00a8 < 0xdc00) \\\n    { \\\n    c = (((ptr\u00dd-2\u00a8 - 0xd800) << 10) | (c - 0xdc00)) + 0x10000; \\\n    ptr -= 2; \\\n    } \\\n  else \\\n    { \\\n    invalid_action; \\\n    } \\\n  }\n\n\n#elif PCRE2_CODE_UNIT_WIDTH == 32\n\n#define GETCHARINC_INVALID(c, ptr, end, invalid_action) \\\n  { \\\n  if (ptr\u00dd0\u00a8 < 0xd800 || (ptr\u00dd0\u00a8 >= 0xe000 && ptr\u00dd0\u00a8 < 0x110000)) \\\n    c = *ptr++; \\\n  else \\\n    { \\\n    invalid_action; \\\n    } \\\n  }\n\n#define GETCHARBACK_INVALID(c, ptr, start, invalid_action) \\\n  { \\\n  c = ptr\u00dd-1\u00a8; \\\n  if (ptr\u00dd-1\u00a8 < 0xd800 || (ptr\u00dd-1\u00a8 >= 0xe000 && ptr\u00dd-1\u00a8 < 0x110000)) \\\n    ptr--; \\\n  else \\\n    { \\\n    invalid_action; \\\n    } \\\n  }\n\n#endif /* PCRE2_CODE_UNIT_WIDTH == \u00dd8|16|32\u00a8 */\n#endif /* SUPPORT_UNICODE */\n\nstatic PCRE2_SPTR bracketend(PCRE2_SPTR cc)\n{\nSLJIT_ASSERT((*cc >= OP_ASSERT && *cc <= OP_ASSERTBACK_NA) || (*cc >= OP_ONCE && *cc <= OP_SCOND));\ndo cc += GET(cc, 1); while (*cc == OP_ALT);\nSLJIT_ASSERT(*cc >= OP_KET && *cc <= OP_KETRPOS);\ncc += 1 + LINK_SIZE;\nreturn cc;\n}\n\nstatic int no_alternatives(PCRE2_SPTR cc)\n{\nint count = 0;\nSLJIT_ASSERT((*cc >= OP_ASSERT && *cc <= OP_ASSERTBACK_NA) || (*cc >= OP_ONCE && *cc <= OP_SCOND));\ndo\n  {\n  cc += GET(cc, 1);\n  count++;\n  }\nwhile (*cc == OP_ALT);\nSLJIT_ASSERT(*cc >= OP_KET && *cc <= OP_KETRPOS);\nreturn count;\n}\n\n/* Functions whose might need modification for all new supported opcodes:\n next_opcode\n check_opcode_types\n set_private_data_ptrs\n get_framesize\n init_frame\n get_recurse_data_length\n copy_recurse_data\n compile_matchingpath\n compile_backtrackingpath\n*/\n\nstatic PCRE2_SPTR next_opcode(compiler_common *common, PCRE2_SPTR cc)\n{\nSLJIT_UNUSED_ARG(common);\nswitch(*cc)\n  {\n  case OP_SOD:\n  case OP_SOM:\n  case OP_SET_SOM:\n  case OP_NOT_WORD_BOUNDARY:\n  case OP_WORD_BOUNDARY:\n  case OP_NOT_DIGIT:\n  case OP_DIGIT:\n  case OP_NOT_WHITESPACE:\n  case OP_WHITESPACE:\n  case OP_NOT_WORDCHAR:\n  case OP_WORDCHAR:\n  case OP_ANY:\n  case OP_ALLANY:\n  case OP_NOTPROP:\n  case OP_PROP:\n  case OP_ANYNL:\n  case OP_NOT_HSPACE:\n  case OP_HSPACE:\n  case OP_NOT_VSPACE:\n  case OP_VSPACE:\n  case OP_EXTUNI:\n  case OP_EODN:\n  case OP_EOD:\n  case OP_CIRC:\n  case OP_CIRCM:\n  case OP_DOLL:\n  case OP_DOLLM:\n  case OP_CRSTAR:\n  case OP_CRMINSTAR:\n  case OP_CRPLUS:\n  case OP_CRMINPLUS:\n  case OP_CRQUERY:\n  case OP_CRMINQUERY:\n  case OP_CRRANGE:\n  case OP_CRMINRANGE:\n  case OP_CRPOSSTAR:\n  case OP_CRPOSPLUS:\n  case OP_CRPOSQUERY:\n  case OP_CRPOSRANGE:\n  case OP_CLASS:\n  case OP_NCLASS:\n  case OP_REF:\n  case OP_REFI:\n  case OP_DNREF:\n  case OP_DNREFI:\n  case OP_RECURSE:\n  case OP_CALLOUT:\n  case OP_ALT:\n  case OP_KET:\n  case OP_KETRMAX:\n  case OP_KETRMIN:\n  case OP_KETRPOS:\n  case OP_REVERSE:\n  case OP_ASSERT:\n  case OP_ASSERT_NOT:\n  case OP_ASSERTBACK:\n  case OP_ASSERTBACK_NOT:\n  case OP_ASSERT_NA:\n  case OP_ASSERTBACK_NA:\n  case OP_ONCE:\n  case OP_SCRIPT_RUN:\n  case OP_BRA:\n  case OP_BRAPOS:\n  case OP_CBRA:\n  case OP_CBRAPOS:\n  case OP_COND:\n  case OP_SBRA:\n  case OP_SBRAPOS:\n  case OP_SCBRA:\n  case OP_SCBRAPOS:\n  case OP_SCOND:\n  case OP_CREF:\n  case OP_DNCREF:\n  case OP_RREF:\n  case OP_DNRREF:\n  case OP_FALSE:\n  case OP_TRUE:\n  case OP_BRAZERO:\n  case OP_BRAMINZERO:\n  case OP_BRAPOSZERO:\n  case OP_PRUNE:\n  case OP_SKIP:\n  case OP_THEN:\n  case OP_COMMIT:\n  case OP_FAIL:\n  case OP_ACCEPT:\n  case OP_ASSERT_ACCEPT:\n  case OP_CLOSE:\n  case OP_SKIPZERO:\n  return cc + PRIV(OP_lengths)\u00dd*cc\u00a8;\n\n  case OP_CHAR:\n  case OP_CHARI:\n  case OP_NOT:\n  case OP_NOTI:\n  case OP_STAR:\n  case OP_MINSTAR:\n  case OP_PLUS:\n  case OP_MINPLUS:\n  case OP_QUERY:\n  case OP_MINQUERY:\n  case OP_UPTO:\n  case OP_MINUPTO:\n  case OP_EXACT:\n  case OP_POSSTAR:\n  case OP_POSPLUS:\n  case OP_POSQUERY:\n  case OP_POSUPTO:\n  case OP_STARI:\n  case OP_MINSTARI:\n  case OP_PLUSI:\n  case OP_MINPLUSI:\n  case OP_QUERYI:\n  case OP_MINQUERYI:\n  case OP_UPTOI:\n  case OP_MINUPTOI:\n  case OP_EXACTI:\n  case OP_POSSTARI:\n  case OP_POSPLUSI:\n  case OP_POSQUERYI:\n  case OP_POSUPTOI:\n  case OP_NOTSTAR:\n  case OP_NOTMINSTAR:\n  case OP_NOTPLUS:\n  case OP_NOTMINPLUS:\n  case OP_NOTQUERY:\n  case OP_NOTMINQUERY:\n  case OP_NOTUPTO:\n  case OP_NOTMINUPTO:\n  case OP_NOTEXACT:\n  case OP_NOTPOSSTAR:\n  case OP_NOTPOSPLUS:\n  case OP_NOTPOSQUERY:\n  case OP_NOTPOSUPTO:\n  case OP_NOTSTARI:\n  case OP_NOTMINSTARI:\n  case OP_NOTPLUSI:\n  case OP_NOTMINPLUSI:\n  case OP_NOTQUERYI:\n  case OP_NOTMINQUERYI:\n  case OP_NOTUPTOI:\n  case OP_NOTMINUPTOI:\n  case OP_NOTEXACTI:\n  case OP_NOTPOSSTARI:\n  case OP_NOTPOSPLUSI:\n  case OP_NOTPOSQUERYI:\n  case OP_NOTPOSUPTOI:\n  cc += PRIV(OP_lengths)\u00dd*cc\u00a8;\n#ifdef SUPPORT_UNICODE\n  if (common->utf && HAS_EXTRALEN(cc\u00dd-1\u00a8)) cc += GET_EXTRALEN(cc\u00dd-1\u00a8);\n#endif\n  return cc;\n\n  /* Special cases. */\n  case OP_TYPESTAR:\n  case OP_TYPEMINSTAR:\n  case OP_TYPEPLUS:\n  case OP_TYPEMINPLUS:\n  case OP_TYPEQUERY:\n  case OP_TYPEMINQUERY:\n  case OP_TYPEUPTO:\n  case OP_TYPEMINUPTO:\n  case OP_TYPEEXACT:\n  case OP_TYPEPOSSTAR:\n  case OP_TYPEPOSPLUS:\n  case OP_TYPEPOSQUERY:\n  case OP_TYPEPOSUPTO:\n  return cc + PRIV(OP_lengths)\u00dd*cc\u00a8 - 1;\n\n  case OP_ANYBYTE:\n#ifdef SUPPORT_UNICODE\n  if (common->utf) return NULL;\n#endif\n  return cc + 1;\n\n  case OP_CALLOUT_STR:\n  return cc + GET(cc, 1 + 2*LINK_SIZE);\n\n#if defined SUPPORT_UNICODE || PCRE2_CODE_UNIT_WIDTH != 8\n  case OP_XCLASS:\n  return cc + GET(cc, 1);\n#endif\n\n  case OP_MARK:\n  case OP_COMMIT_ARG:\n  case OP_PRUNE_ARG:\n  case OP_SKIP_ARG:\n  case OP_THEN_ARG:\n  return cc + 1 + 2 + cc\u00dd1\u00a8;\n\n  default:\n  SLJIT_UNREACHABLE();\n  return NULL;\n  }\n}\n\nstatic BOOL check_opcode_types(compiler_common *common, PCRE2_SPTR cc, PCRE2_SPTR ccend)\n{\nint count;\nPCRE2_SPTR slot;\nPCRE2_SPTR assert_back_end = cc - 1;\nPCRE2_SPTR assert_na_end = cc - 1;\n\n/* Calculate important variables (like stack size) and checks whether all opcodes are supported. */\nwhile (cc < ccend)\n  {\n  switch(*cc)\n    {\n    case OP_SET_SOM:\n    common->has_set_som = TRUE;\n    common->might_be_empty = TRUE;\n    cc += 1;\n    break;\n\n    case OP_REFI:\n#ifdef SUPPORT_UNICODE\n    if (common->iref_ptr == 0)\n      {\n      common->iref_ptr = common->ovector_start;\n      common->ovector_start += 3 * sizeof(sljit_sw);\n      }\n#endif /* SUPPORT_UNICODE */\n    /* Fall through. */\n    case OP_REF:\n    common->optimized_cbracket\u00ddGET2(cc, 1)\u00a8 = 0;\n    cc += 1 + IMM2_SIZE;\n    break;\n\n    case OP_ASSERT_NA:\n    case OP_ASSERTBACK_NA:\n    slot = bracketend(cc);\n    if (slot > assert_na_end)\n      assert_na_end = slot;\n    cc += 1 + LINK_SIZE;\n    break;\n\n    case OP_CBRAPOS:\n    case OP_SCBRAPOS:\n    common->optimized_cbracket\u00ddGET2(cc, 1 + LINK_SIZE)\u00a8 = 0;\n    cc += 1 + LINK_SIZE + IMM2_SIZE;\n    break;\n\n    case OP_COND:\n    case OP_SCOND:\n    /* Only AUTO_CALLOUT can insert this opcode. We do\n       not intend to support this case. */\n    if (cc\u00dd1 + LINK_SIZE\u00a8 == OP_CALLOUT || cc\u00dd1 + LINK_SIZE\u00a8 == OP_CALLOUT_STR)\n      return FALSE;\n    cc += 1 + LINK_SIZE;\n    break;\n\n    case OP_CREF:\n    common->optimized_cbracket\u00ddGET2(cc, 1)\u00a8 = 0;\n    cc += 1 + IMM2_SIZE;\n    break;\n\n    case OP_DNREF:\n    case OP_DNREFI:\n    case OP_DNCREF:\n    count = GET2(cc, 1 + IMM2_SIZE);\n    slot = common->name_table + GET2(cc, 1) * common->name_entry_size;\n    while (count-- > 0)\n      {\n      common->optimized_cbracket\u00ddGET2(slot, 0)\u00a8 = 0;\n      slot += common->name_entry_size;\n      }\n    cc += 1 + 2 * IMM2_SIZE;\n    break;\n\n    case OP_RECURSE:\n    /* Set its value only once. */\n    if (common->recursive_head_ptr == 0)\n      {\n      common->recursive_head_ptr = common->ovector_start;\n      common->ovector_start += sizeof(sljit_sw);\n      }\n    cc += 1 + LINK_SIZE;\n    break;\n\n    case OP_CALLOUT:\n    case OP_CALLOUT_STR:\n    if (common->capture_last_ptr == 0)\n      {\n      common->capture_last_ptr = common->ovector_start;\n      common->ovector_start += sizeof(sljit_sw);\n      }\n    cc += (*cc == OP_CALLOUT) ? PRIV(OP_lengths)\u00ddOP_CALLOUT\u00a8 : GET(cc, 1 + 2*LINK_SIZE);\n    break;\n\n    case OP_ASSERTBACK:\n    slot = bracketend(cc);\n    if (slot > assert_back_end)\n      assert_back_end = slot;\n    cc += 1 + LINK_SIZE;\n    break;\n\n    case OP_THEN_ARG:\n    common->has_then = TRUE;\n    common->control_head_ptr = 1;\n    /* Fall through. */\n\n    case OP_COMMIT_ARG:\n    case OP_PRUNE_ARG:\n    if (cc < assert_na_end)\n      return FALSE;\n    /* Fall through */\n    case OP_MARK:\n    if (common->mark_ptr == 0)\n      {\n      common->mark_ptr = common->ovector_start;\n      common->ovector_start += sizeof(sljit_sw);\n      }\n    cc += 1 + 2 + cc\u00dd1\u00a8;\n    break;\n\n    case OP_THEN:\n    common->has_then = TRUE;\n    common->control_head_ptr = 1;\n    cc += 1;\n    break;\n\n    case OP_SKIP:\n    if (cc < assert_back_end)\n      common->has_skip_in_assert_back = TRUE;\n    if (cc < assert_na_end)\n      return FALSE;\n    cc += 1;\n    break;\n\n    case OP_SKIP_ARG:\n    common->control_head_ptr = 1;\n    common->has_skip_arg = TRUE;\n    if (cc < assert_back_end)\n      common->has_skip_in_assert_back = TRUE;\n    if (cc < assert_na_end)\n      return FALSE;\n    cc += 1 + 2 + cc\u00dd1\u00a8;\n    break;\n\n    case OP_PRUNE:\n    case OP_COMMIT:\n    case OP_ASSERT_ACCEPT:\n    if (cc < assert_na_end)\n      return FALSE;\n    cc++;\n    break;\n\n    default:\n    cc = next_opcode(common, cc);\n    if (cc == NULL)\n      return FALSE;\n    break;\n    }\n  }\nreturn TRUE;\n}\n\n#define EARLY_FAIL_ENHANCE_MAX (1 + 1)\n\n/*\nstart:\n  0 - skip / early fail allowed\n  1 - only early fail with range allowed\n  >1 - (start - 1) early fail is processed\n\nreturn: current number of iterators enhanced with fast fail\n*/\nstatic int detect_early_fail(compiler_common *common, PCRE2_SPTR cc, int *private_data_start, sljit_s32 depth, int start)\n{\nPCRE2_SPTR next_alt;\nPCRE2_SPTR end;\nPCRE2_SPTR accelerated_start;\nint result = 0;\nint count;\nBOOL fast_forward_allowed = TRUE;\n\nSLJIT_ASSERT(*cc == OP_ONCE || *cc == OP_BRA || *cc == OP_CBRA);\nSLJIT_ASSERT(*cc != OP_CBRA || common->optimized_cbracket\u00ddGET2(cc, 1 + LINK_SIZE)\u00a8 != 0);\nSLJIT_ASSERT(start < EARLY_FAIL_ENHANCE_MAX);\n\ndo\n  {\n  count = start;\n  next_alt = cc + GET(cc, 1);\n  cc += 1 + LINK_SIZE + ((*cc == OP_CBRA) ? IMM2_SIZE : 0);\n\n  while (TRUE)\n    {\n    accelerated_start = NULL;\n\n    switch(*cc)\n      {\n      case OP_SOD:\n      case OP_SOM:\n      case OP_SET_SOM:\n      case OP_NOT_WORD_BOUNDARY:\n      case OP_WORD_BOUNDARY:\n      case OP_EODN:\n      case OP_EOD:\n      case OP_CIRC:\n      case OP_CIRCM:\n      case OP_DOLL:\n      case OP_DOLLM:\n      /* Zero width assertions. */\n      cc++;\n      continue;\n\n      case OP_NOT_DIGIT:\n      case OP_DIGIT:\n      case OP_NOT_WHITESPACE:\n      case OP_WHITESPACE:\n      case OP_NOT_WORDCHAR:\n      case OP_WORDCHAR:\n      case OP_ANY:\n      case OP_ALLANY:\n      case OP_ANYBYTE:\n      case OP_NOT_HSPACE:\n      case OP_HSPACE:\n      case OP_NOT_VSPACE:\n      case OP_VSPACE:\n      fast_forward_allowed = FALSE;\n      cc++;\n      continue;\n\n      case OP_ANYNL:\n      case OP_EXTUNI:\n      fast_forward_allowed = FALSE;\n      if (count == 0)\n        count = 1;\n      cc++;\n      continue;\n\n      case OP_NOTPROP:\n      case OP_PROP:\n      fast_forward_allowed = FALSE;\n      cc += 1 + 2;\n      continue;\n\n      case OP_CHAR:\n      case OP_CHARI:\n      case OP_NOT:\n      case OP_NOTI:\n      fast_forward_allowed = FALSE;\n      cc += 2;\n#ifdef SUPPORT_UNICODE\n      if (common->utf && HAS_EXTRALEN(cc\u00dd-1\u00a8)) cc += GET_EXTRALEN(cc\u00dd-1\u00a8);\n#endif\n      continue;\n\n      case OP_TYPESTAR:\n      case OP_TYPEMINSTAR:\n      case OP_TYPEPLUS:\n      case OP_TYPEMINPLUS:\n      case OP_TYPEPOSSTAR:\n      case OP_TYPEPOSPLUS:\n      /* The type or prop opcode is skipped in the next iteration. */\n      cc += 1;\n\n      if (cc\u00dd0\u00a8 != OP_ANYNL && cc\u00dd0\u00a8 != OP_EXTUNI)\n        {\n        accelerated_start = cc - 1;\n        break;\n        }\n\n      if (count == 0)\n        count = 1;\n      fast_forward_allowed = FALSE;\n      continue;\n\n      case OP_TYPEUPTO:\n      case OP_TYPEMINUPTO:\n      case OP_TYPEEXACT:\n      case OP_TYPEPOSUPTO:\n      cc += IMM2_SIZE;\n      /* Fall through */\n\n      case OP_TYPEQUERY:\n      case OP_TYPEMINQUERY:\n      case OP_TYPEPOSQUERY:\n      /* The type or prop opcode is skipped in the next iteration. */\n      fast_forward_allowed = FALSE;\n      if (count == 0)\n        count = 1;\n      cc += 1;\n      continue;\n\n      case OP_STAR:\n      case OP_MINSTAR:\n      case OP_PLUS:\n      case OP_MINPLUS:\n      case OP_POSSTAR:\n      case OP_POSPLUS:\n\n      case OP_STARI:\n      case OP_MINSTARI:\n      case OP_PLUSI:\n      case OP_MINPLUSI:\n      case OP_POSSTARI:\n      case OP_POSPLUSI:\n\n      case OP_NOTSTAR:\n      case OP_NOTMINSTAR:\n      case OP_NOTPLUS:\n      case OP_NOTMINPLUS:\n      case OP_NOTPOSSTAR:\n      case OP_NOTPOSPLUS:\n\n      case OP_NOTSTARI:\n      case OP_NOTMINSTARI:\n      case OP_NOTPLUSI:\n      case OP_NOTMINPLUSI:\n      case OP_NOTPOSSTARI:\n      case OP_NOTPOSPLUSI:\n      accelerated_start = cc;\n      cc += 2;\n#ifdef SUPPORT_UNICODE\n      if (common->utf && HAS_EXTRALEN(cc\u00dd-1\u00a8)) cc += GET_EXTRALEN(cc\u00dd-1\u00a8);\n#endif\n      break;\n\n      case OP_UPTO:\n      case OP_MINUPTO:\n      case OP_EXACT:\n      case OP_POSUPTO:\n      case OP_UPTOI:\n      case OP_MINUPTOI:\n      case OP_EXACTI:\n      case OP_POSUPTOI:\n      case OP_NOTUPTO:\n      case OP_NOTMINUPTO:\n      case OP_NOTEXACT:\n      case OP_NOTPOSUPTO:\n      case OP_NOTUPTOI:\n      case OP_NOTMINUPTOI:\n      case OP_NOTEXACTI:\n      case OP_NOTPOSUPTOI:\n      cc += IMM2_SIZE;\n      /* Fall through */\n\n      case OP_QUERY:\n      case OP_MINQUERY:\n      case OP_POSQUERY:\n      case OP_QUERYI:\n      case OP_MINQUERYI:\n      case OP_POSQUERYI:\n      case OP_NOTQUERY:\n      case OP_NOTMINQUERY:\n      case OP_NOTPOSQUERY:\n      case OP_NOTQUERYI:\n      case OP_NOTMINQUERYI:\n      case OP_NOTPOSQUERYI:\n      fast_forward_allowed = FALSE;\n      if (count == 0)\n        count = 1;\n      cc += 2;\n#ifdef SUPPORT_UNICODE\n      if (common->utf && HAS_EXTRALEN(cc\u00dd-1\u00a8)) cc += GET_EXTRALEN(cc\u00dd-1\u00a8);\n#endif\n      continue;\n\n      case OP_CLASS:\n      case OP_NCLASS:\n#if defined SUPPORT_UNICODE || PCRE2_CODE_UNIT_WIDTH != 8\n      case OP_XCLASS:\n      accelerated_start = cc;\n      cc += ((*cc == OP_XCLASS) ? GET(cc, 1) : (unsigned int)(1 + (32 / sizeof(PCRE2_UCHAR))));\n#else\n      accelerated_start = cc;\n      cc += (1 + (32 / sizeof(PCRE2_UCHAR)));\n#endif\n\n      switch (*cc)\n        {\n        case OP_CRSTAR:\n        case OP_CRMINSTAR:\n        case OP_CRPLUS:\n        case OP_CRMINPLUS:\n        case OP_CRPOSSTAR:\n        case OP_CRPOSPLUS:\n        cc++;\n        break;\n\n        case OP_CRRANGE:\n        case OP_CRMINRANGE:\n        case OP_CRPOSRANGE:\n        cc += 2 * IMM2_SIZE;\n        /* Fall through */\n        case OP_CRQUERY:\n        case OP_CRMINQUERY:\n        case OP_CRPOSQUERY:\n        cc++;\n        if (count == 0)\n          count = 1;\n        /* Fall through */\n        default:\n        accelerated_start = NULL;\n        fast_forward_allowed = FALSE;\n        break;\n        }\n      continue;\n\n      case OP_ONCE:\n      case OP_BRA:\n      case OP_CBRA:\n      end = cc + GET(cc, 1);\n\n      if (*end == OP_KET && PRIVATE_DATA(end) == 0)\n        {\n        if (*cc == OP_CBRA)\n          {\n          if (common->optimized_cbracket\u00ddGET2(cc, 1 + LINK_SIZE)\u00a8 == 0)\n            break;\n          cc += IMM2_SIZE;\n          }\n\n        cc += 1 + LINK_SIZE;\n        continue;\n        }\n\n      fast_forward_allowed = FALSE;\n      if (depth >= 4)\n        break;\n\n      end = bracketend(cc) - (1 + LINK_SIZE);\n      if (*end != OP_KET || PRIVATE_DATA(end) != 0)\n        break;\n\n      if (*cc == OP_CBRA && common->optimized_cbracket\u00ddGET2(cc, 1 + LINK_SIZE)\u00a8 == 0)\n        break;\n\n      count = detect_early_fail(common, cc, private_data_start, depth + 1, count);\n      if (count < EARLY_FAIL_ENHANCE_MAX)\n        {\n        cc = end + (1 + LINK_SIZE);\n        continue;\n        }\n      break;\n\n      case OP_KET:\n      SLJIT_ASSERT(PRIVATE_DATA(cc) == 0);\n      if (cc >= next_alt)\n        break;\n      cc += 1 + LINK_SIZE;\n      continue;\n      }\n\n    if (accelerated_start != NULL)\n      {\n      if (count == 0)\n        {\n        count++;\n\n        if (fast_forward_allowed && *next_alt == OP_KET)\n          {\n          common->fast_forward_bc_ptr = accelerated_start;\n          common->private_data_ptrs\u00dd(accelerated_start + 1) - common->start\u00a8 = ((*private_data_start) << 3) | type_skip;\n          *private_data_start += sizeof(sljit_sw);\n          }\n        else\n          {\n          common->private_data_ptrs\u00dd(accelerated_start + 1) - common->start\u00a8 = ((*private_data_start) << 3) | type_fail;\n\n          if (common->early_fail_start_ptr == 0)\n            common->early_fail_start_ptr = *private_data_start;\n\n          *private_data_start += sizeof(sljit_sw);\n          common->early_fail_end_ptr = *private_data_start;\n\n          if (*private_data_start > SLJIT_MAX_LOCAL_SIZE)\n            return EARLY_FAIL_ENHANCE_MAX;\n          }\n        }\n      else\n        {\n        common->private_data_ptrs\u00dd(accelerated_start + 1) - common->start\u00a8 = ((*private_data_start) << 3) | type_fail_range;\n\n        if (common->early_fail_start_ptr == 0)\n          common->early_fail_start_ptr = *private_data_start;\n\n        *private_data_start += 2 * sizeof(sljit_sw);\n        common->early_fail_end_ptr = *private_data_start;\n\n        if (*private_data_start > SLJIT_MAX_LOCAL_SIZE)\n          return EARLY_FAIL_ENHANCE_MAX;\n        }\n\n      count++;\n\n      if (count < EARLY_FAIL_ENHANCE_MAX)\n        continue;\n      }\n\n    break;\n    }\n\n  if (*cc != OP_ALT && *cc != OP_KET)\n    result = EARLY_FAIL_ENHANCE_MAX;\n  else if (result < count)\n    result = count;\n\n  fast_forward_allowed = FALSE;\n  cc = next_alt;\n  }\nwhile (*cc == OP_ALT);\n\nreturn result;\n}\n\nstatic int get_class_iterator_size(PCRE2_SPTR cc)\n{\nsljit_u32 min;\nsljit_u32 max;\nswitch(*cc)\n  {\n  case OP_CRSTAR:\n  case OP_CRPLUS:\n  return 2;\n\n  case OP_CRMINSTAR:\n  case OP_CRMINPLUS:\n  case OP_CRQUERY:\n  case OP_CRMINQUERY:\n  return 1;\n\n  case OP_CRRANGE:\n  case OP_CRMINRANGE:\n  min = GET2(cc, 1);\n  max = GET2(cc, 1 + IMM2_SIZE);\n  if (max == 0)\n    return (*cc == OP_CRRANGE) ? 2 : 1;\n  max -= min;\n  if (max > 2)\n    max = 2;\n  return max;\n\n  default:\n  return 0;\n  }\n}\n\nstatic BOOL detect_repeat(compiler_common *common, PCRE2_SPTR begin)\n{\nPCRE2_SPTR end = bracketend(begin);\nPCRE2_SPTR next;\nPCRE2_SPTR next_end;\nPCRE2_SPTR max_end;\nPCRE2_UCHAR type;\nsljit_sw length = end - begin;\nsljit_s32 min, max, i;\n\n/* Detect fixed iterations first. */\nif (end\u00dd-(1 + LINK_SIZE)\u00a8 != OP_KET)\n  return FALSE;\n\n/* Already detected repeat. */\nif (common->private_data_ptrs\u00ddend - common->start - LINK_SIZE\u00a8 != 0)\n  return TRUE;\n\nnext = end;\nmin = 1;\nwhile (1)\n  {\n  if (*next != *begin)\n    break;\n  next_end = bracketend(next);\n  if (next_end - next != length || memcmp(begin, next, IN_UCHARS(length)) != 0)\n    break;\n  next = next_end;\n  min++;\n  }\n\nif (min == 2)\n  return FALSE;\n\nmax = 0;\nmax_end = next;\nif (*next == OP_BRAZERO || *next == OP_BRAMINZERO)\n  {\n  type = *next;\n  while (1)\n    {\n    if (next\u00dd0\u00a8 != type || next\u00dd1\u00a8 != OP_BRA || next\u00dd2 + LINK_SIZE\u00a8 != *begin)\n      break;\n    next_end = bracketend(next + 2 + LINK_SIZE);\n    if (next_end - next != (length + 2 + LINK_SIZE) || memcmp(begin, next + 2 + LINK_SIZE, IN_UCHARS(length)) != 0)\n      break;\n    next = next_end;\n    max++;\n    }\n\n  if (next\u00dd0\u00a8 == type && next\u00dd1\u00a8 == *begin && max >= 1)\n    {\n    next_end = bracketend(next + 1);\n    if (next_end - next == (length + 1) && memcmp(begin, next + 1, IN_UCHARS(length)) == 0)\n      {\n      for (i = 0; i < max; i++, next_end += 1 + LINK_SIZE)\n        if (*next_end != OP_KET)\n          break;\n\n      if (i == max)\n        {\n        common->private_data_ptrs\u00ddmax_end - common->start - LINK_SIZE\u00a8 = next_end - max_end;\n        common->private_data_ptrs\u00ddmax_end - common->start - LINK_SIZE + 1\u00a8 = (type == OP_BRAZERO) ? OP_UPTO : OP_MINUPTO;\n        /* +2 the original and the last. */\n        common->private_data_ptrs\u00ddmax_end - common->start - LINK_SIZE + 2\u00a8 = max + 2;\n        if (min == 1)\n          return TRUE;\n        min--;\n        max_end -= (1 + LINK_SIZE) + GET(max_end, -LINK_SIZE);\n        }\n      }\n    }\n  }\n\nif (min >= 3)\n  {\n  common->private_data_ptrs\u00ddend - common->start - LINK_SIZE\u00a8 = max_end - end;\n  common->private_data_ptrs\u00ddend - common->start - LINK_SIZE + 1\u00a8 = OP_EXACT;\n  common->private_data_ptrs\u00ddend - common->start - LINK_SIZE + 2\u00a8 = min;\n  return TRUE;\n  }\n\nreturn FALSE;\n}\n\n#define CASE_ITERATOR_PRIVATE_DATA_1 \\\n    case OP_MINSTAR: \\\n    case OP_MINPLUS: \\\n    case OP_QUERY: \\\n    case OP_MINQUERY: \\\n    case OP_MINSTARI: \\\n    case OP_MINPLUSI: \\\n    case OP_QUERYI: \\\n    case OP_MINQUERYI: \\\n    case OP_NOTMINSTAR: \\\n    case OP_NOTMINPLUS: \\\n    case OP_NOTQUERY: \\\n    case OP_NOTMINQUERY: \\\n    case OP_NOTMINSTARI: \\\n    case OP_NOTMINPLUSI: \\\n    case OP_NOTQUERYI: \\\n    case OP_NOTMINQUERYI:\n\n#define CASE_ITERATOR_PRIVATE_DATA_2A \\\n    case OP_STAR: \\\n    case OP_PLUS: \\\n    case OP_STARI: \\\n    case OP_PLUSI: \\\n    case OP_NOTSTAR: \\\n    case OP_NOTPLUS: \\\n    case OP_NOTSTARI: \\\n    case OP_NOTPLUSI:\n\n#define CASE_ITERATOR_PRIVATE_DATA_2B \\\n    case OP_UPTO: \\\n    case OP_MINUPTO: \\\n    case OP_UPTOI: \\\n    case OP_MINUPTOI: \\\n    case OP_NOTUPTO: \\\n    case OP_NOTMINUPTO: \\\n    case OP_NOTUPTOI: \\\n    case OP_NOTMINUPTOI:\n\n#define CASE_ITERATOR_TYPE_PRIVATE_DATA_1 \\\n    case OP_TYPEMINSTAR: \\\n    case OP_TYPEMINPLUS: \\\n    case OP_TYPEQUERY: \\\n    case OP_TYPEMINQUERY:\n\n#define CASE_ITERATOR_TYPE_PRIVATE_DATA_2A \\\n    case OP_TYPESTAR: \\\n    case OP_TYPEPLUS:\n\n#define CASE_ITERATOR_TYPE_PRIVATE_DATA_2B \\\n    case OP_TYPEUPTO: \\\n    case OP_TYPEMINUPTO:\n\nstatic void set_private_data_ptrs(compiler_common *common, int *private_data_start, PCRE2_SPTR ccend)\n{\nPCRE2_SPTR cc = common->start;\nPCRE2_SPTR alternative;\nPCRE2_SPTR end = NULL;\nint private_data_ptr = *private_data_start;\nint space, size, bracketlen;\nBOOL repeat_check = TRUE;\n\nwhile (cc < ccend)\n  {\n  space = 0;\n  size = 0;\n  bracketlen = 0;\n  if (private_data_ptr > SLJIT_MAX_LOCAL_SIZE)\n    break;\n\n  if (repeat_check && (*cc == OP_ONCE || *cc == OP_BRA || *cc == OP_CBRA || *cc == OP_COND))\n    {\n    if (detect_repeat(common, cc))\n      {\n      /* These brackets are converted to repeats, so no global\n      based single character repeat is allowed. */\n      if (cc >= end)\n        end = bracketend(cc);\n      }\n    }\n  repeat_check = TRUE;\n\n  switch(*cc)\n    {\n    case OP_KET:\n    if (common->private_data_ptrs\u00ddcc + 1 - common->start\u00a8 != 0)\n      {\n      common->private_data_ptrs\u00ddcc - common->start\u00a8 = private_data_ptr;\n      private_data_ptr += sizeof(sljit_sw);\n      cc += common->private_data_ptrs\u00ddcc + 1 - common->start\u00a8;\n      }\n    cc += 1 + LINK_SIZE;\n    break;\n\n    case OP_ASSERT:\n    case OP_ASSERT_NOT:\n    case OP_ASSERTBACK:\n    case OP_ASSERTBACK_NOT:\n    case OP_ASSERT_NA:\n    case OP_ASSERTBACK_NA:\n    case OP_ONCE:\n    case OP_SCRIPT_RUN:\n    case OP_BRAPOS:\n    case OP_SBRA:\n    case OP_SBRAPOS:\n    case OP_SCOND:\n    common->private_data_ptrs\u00ddcc - common->start\u00a8 = private_data_ptr;\n    private_data_ptr += sizeof(sljit_sw);\n    bracketlen = 1 + LINK_SIZE;\n    break;\n\n    case OP_CBRAPOS:\n    case OP_SCBRAPOS:\n    common->private_data_ptrs\u00ddcc - common->start\u00a8 = private_data_ptr;\n    private_data_ptr += sizeof(sljit_sw);\n    bracketlen = 1 + LINK_SIZE + IMM2_SIZE;\n    break;\n\n    case OP_COND:\n    /* Might be a hidden SCOND. */\n    alternative = cc + GET(cc, 1);\n    if (*alternative == OP_KETRMAX || *alternative == OP_KETRMIN)\n      {\n      common->private_data_ptrs\u00ddcc - common->start\u00a8 = private_data_ptr;\n      private_data_ptr += sizeof(sljit_sw);\n      }\n    bracketlen = 1 + LINK_SIZE;\n    break;\n\n    case OP_BRA:\n    bracketlen = 1 + LINK_SIZE;\n    break;\n\n    case OP_CBRA:\n    case OP_SCBRA:\n    bracketlen = 1 + LINK_SIZE + IMM2_SIZE;\n    break;\n\n    case OP_BRAZERO:\n    case OP_BRAMINZERO:\n    case OP_BRAPOSZERO:\n    repeat_check = FALSE;\n    size = 1;\n    break;\n\n    CASE_ITERATOR_PRIVATE_DATA_1\n    space = 1;\n    size = -2;\n    break;\n\n    CASE_ITERATOR_PRIVATE_DATA_2A\n    space = 2;\n    size = -2;\n    break;\n\n    CASE_ITERATOR_PRIVATE_DATA_2B\n    space = 2;\n    size = -(2 + IMM2_SIZE);\n    break;\n\n    CASE_ITERATOR_TYPE_PRIVATE_DATA_1\n    space = 1;\n    size = 1;\n    break;\n\n    CASE_ITERATOR_TYPE_PRIVATE_DATA_2A\n    if (cc\u00dd1\u00a8 != OP_ANYNL && cc\u00dd1\u00a8 != OP_EXTUNI)\n      space = 2;\n    size = 1;\n    break;\n\n    case OP_TYPEUPTO:\n    if (cc\u00dd1 + IMM2_SIZE\u00a8 != OP_ANYNL && cc\u00dd1 + IMM2_SIZE\u00a8 != OP_EXTUNI)\n      space = 2;\n    size = 1 + IMM2_SIZE;\n    break;\n\n    case OP_TYPEMINUPTO:\n    space = 2;\n    size = 1 + IMM2_SIZE;\n    break;\n\n    case OP_CLASS:\n    case OP_NCLASS:\n    space = get_class_iterator_size(cc + size);\n    size = 1 + 32 / sizeof(PCRE2_UCHAR);\n    break;\n\n#if defined SUPPORT_UNICODE || PCRE2_CODE_UNIT_WIDTH != 8\n    case OP_XCLASS:\n    space = get_class_iterator_size(cc + size);\n    size = GET(cc, 1);\n    break;\n#endif\n\n    default:\n    cc = next_opcode(common, cc);\n    SLJIT_ASSERT(cc != NULL);\n    break;\n    }\n\n  /* Character iterators, which are not inside a repeated bracket,\n     gets a private slot instead of allocating it on the stack. */\n  if (space > 0 && cc >= end)\n    {\n    common->private_data_ptrs\u00ddcc - common->start\u00a8 = private_data_ptr;\n    private_data_ptr += sizeof(sljit_sw) * space;\n    }\n\n  if (size != 0)\n    {\n    if (size < 0)\n      {\n      cc += -size;\n#ifdef SUPPORT_UNICODE\n      if (common->utf && HAS_EXTRALEN(cc\u00dd-1\u00a8)) cc += GET_EXTRALEN(cc\u00dd-1\u00a8);\n#endif\n      }\n    else\n      cc += size;\n    }\n\n  if (bracketlen > 0)\n    {\n    if (cc >= end)\n      {\n      end = bracketend(cc);\n      if (end\u00dd-1 - LINK_SIZE\u00a8 == OP_KET)\n        end = NULL;\n      }\n    cc += bracketlen;\n    }\n  }\n*private_data_start = private_data_ptr;\n}\n\n/* Returns with a frame_types (always < 0) if no need for frame. */\nstatic int get_framesize(compiler_common *common, PCRE2_SPTR cc, PCRE2_SPTR ccend, BOOL recursive, BOOL *needs_control_head)\n{\nint length = 0;\nint possessive = 0;\nBOOL stack_restore = FALSE;\nBOOL setsom_found = recursive;\nBOOL setmark_found = recursive;\n/* The last capture is a local variable even for recursions. */\nBOOL capture_last_found = FALSE;\n\n#if defined DEBUG_FORCE_CONTROL_HEAD && DEBUG_FORCE_CONTROL_HEAD\nSLJIT_ASSERT(common->control_head_ptr != 0);\n*needs_control_head = TRUE;\n#else\n*needs_control_head = FALSE;\n#endif\n\nif (ccend == NULL)\n  {\n  ccend = bracketend(cc) - (1 + LINK_SIZE);\n  if (!recursive && (*cc == OP_CBRAPOS || *cc == OP_SCBRAPOS))\n    {\n    possessive = length = (common->capture_last_ptr != 0) ? 5 : 3;\n    /* This is correct regardless of common->capture_last_ptr. */\n    capture_last_found = TRUE;\n    }\n  cc = next_opcode(common, cc);\n  }\n\nSLJIT_ASSERT(cc != NULL);\nwhile (cc < ccend)\n  switch(*cc)\n    {\n    case OP_SET_SOM:\n    SLJIT_ASSERT(common->has_set_som);\n    stack_restore = TRUE;\n    if (!setsom_found)\n      {\n      length += 2;\n      setsom_found = TRUE;\n      }\n    cc += 1;\n    break;\n\n    case OP_MARK:\n    case OP_COMMIT_ARG:\n    case OP_PRUNE_ARG:\n    case OP_THEN_ARG:\n    SLJIT_ASSERT(common->mark_ptr != 0);\n    stack_restore = TRUE;\n    if (!setmark_found)\n      {\n      length += 2;\n      setmark_found = TRUE;\n      }\n    if (common->control_head_ptr != 0)\n      *needs_control_head = TRUE;\n    cc += 1 + 2 + cc\u00dd1\u00a8;\n    break;\n\n    case OP_RECURSE:\n    stack_restore = TRUE;\n    if (common->has_set_som && !setsom_found)\n      {\n      length += 2;\n      setsom_found = TRUE;\n      }\n    if (common->mark_ptr != 0 && !setmark_found)\n      {\n      length += 2;\n      setmark_found = TRUE;\n      }\n    if (common->capture_last_ptr != 0 && !capture_last_found)\n      {\n      length += 2;\n      capture_last_found = TRUE;\n      }\n    cc += 1 + LINK_SIZE;\n    break;\n\n    case OP_CBRA:\n    case OP_CBRAPOS:\n    case OP_SCBRA:\n    case OP_SCBRAPOS:\n    stack_restore = TRUE;\n    if (common->capture_last_ptr != 0 && !capture_last_found)\n      {\n      length += 2;\n      capture_last_found = TRUE;\n      }\n    length += 3;\n    cc += 1 + LINK_SIZE + IMM2_SIZE;\n    break;\n\n    case OP_THEN:\n    stack_restore = TRUE;\n    if (common->control_head_ptr != 0)\n      *needs_control_head = TRUE;\n    cc ++;\n    break;\n\n    default:\n    stack_restore = TRUE;\n    /* Fall through. */\n\n    case OP_NOT_WORD_BOUNDARY:\n    case OP_WORD_BOUNDARY:\n    case OP_NOT_DIGIT:\n    case OP_DIGIT:\n    case OP_NOT_WHITESPACE:\n    case OP_WHITESPACE:\n    case OP_NOT_WORDCHAR:\n    case OP_WORDCHAR:\n    case OP_ANY:\n    case OP_ALLANY:\n    case OP_ANYBYTE:\n    case OP_NOTPROP:\n    case OP_PROP:\n    case OP_ANYNL:\n    case OP_NOT_HSPACE:\n    case OP_HSPACE:\n    case OP_NOT_VSPACE:\n    case OP_VSPACE:\n    case OP_EXTUNI:\n    case OP_EODN:\n    case OP_EOD:\n    case OP_CIRC:\n    case OP_CIRCM:\n    case OP_DOLL:\n    case OP_DOLLM:\n    case OP_CHAR:\n    case OP_CHARI:\n    case OP_NOT:\n    case OP_NOTI:\n\n    case OP_EXACT:\n    case OP_POSSTAR:\n    case OP_POSPLUS:\n    case OP_POSQUERY:\n    case OP_POSUPTO:\n\n    case OP_EXACTI:\n    case OP_POSSTARI:\n    case OP_POSPLUSI:\n    case OP_POSQUERYI:\n    case OP_POSUPTOI:\n\n    case OP_NOTEXACT:\n    case OP_NOTPOSSTAR:\n    case OP_NOTPOSPLUS:\n    case OP_NOTPOSQUERY:\n    case OP_NOTPOSUPTO:\n\n    case OP_NOTEXACTI:\n    case OP_NOTPOSSTARI:\n    case OP_NOTPOSPLUSI:\n    case OP_NOTPOSQUERYI:\n    case OP_NOTPOSUPTOI:\n\n    case OP_TYPEEXACT:\n    case OP_TYPEPOSSTAR:\n    case OP_TYPEPOSPLUS:\n    case OP_TYPEPOSQUERY:\n    case OP_TYPEPOSUPTO:\n\n    case OP_CLASS:\n    case OP_NCLASS:\n    case OP_XCLASS:\n\n    case OP_CALLOUT:\n    case OP_CALLOUT_STR:\n\n    cc = next_opcode(common, cc);\n    SLJIT_ASSERT(cc != NULL);\n    break;\n    }\n\n/* Possessive quantifiers can use a special case. */\nif (SLJIT_UNLIKELY(possessive == length))\n  return stack_restore ? no_frame : no_stack;\n\nif (length > 0)\n  return length + 1;\nreturn stack_restore ? no_frame : no_stack;\n}\n\nstatic void init_frame(compiler_common *common, PCRE2_SPTR cc, PCRE2_SPTR ccend, int stackpos, int stacktop)\n{\nDEFINE_COMPILER;\nBOOL setsom_found = FALSE;\nBOOL setmark_found = FALSE;\n/* The last capture is a local variable even for recursions. */\nBOOL capture_last_found = FALSE;\nint offset;\n\n/* >= 1 + shortest item size (2) */\nSLJIT_UNUSED_ARG(stacktop);\nSLJIT_ASSERT(stackpos >= stacktop + 2);\n\nstackpos = STACK(stackpos);\nif (ccend == NULL)\n  {\n  ccend = bracketend(cc) - (1 + LINK_SIZE);\n  if (*cc != OP_CBRAPOS && *cc != OP_SCBRAPOS)\n    cc = next_opcode(common, cc);\n  }\n\nSLJIT_ASSERT(cc != NULL);\nwhile (cc < ccend)\n  switch(*cc)\n    {\n    case OP_SET_SOM:\n    SLJIT_ASSERT(common->has_set_som);\n    if (!setsom_found)\n      {\n      OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(SLJIT_SP), OVECTOR(0));\n      OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), stackpos, SLJIT_IMM, -OVECTOR(0));\n      stackpos -= (int)sizeof(sljit_sw);\n      OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), stackpos, TMP1, 0);\n      stackpos -= (int)sizeof(sljit_sw);\n      setsom_found = TRUE;\n      }\n    cc += 1;\n    break;\n\n    case OP_MARK:\n    case OP_COMMIT_ARG:\n    case OP_PRUNE_ARG:\n    case OP_THEN_ARG:\n    SLJIT_ASSERT(common->mark_ptr != 0);\n    if (!setmark_found)\n      {\n      OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(SLJIT_SP), common->mark_ptr);\n      OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), stackpos, SLJIT_IMM, -common->mark_ptr);\n      stackpos -= (int)sizeof(sljit_sw);\n      OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), stackpos, TMP1, 0);\n      stackpos -= (int)sizeof(sljit_sw);\n      setmark_found = TRUE;\n      }\n    cc += 1 + 2 + cc\u00dd1\u00a8;\n    break;\n\n    case OP_RECURSE:\n    if (common->has_set_som && !setsom_found)\n      {\n      OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(SLJIT_SP), OVECTOR(0));\n      OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), stackpos, SLJIT_IMM, -OVECTOR(0));\n      stackpos -= (int)sizeof(sljit_sw);\n      OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), stackpos, TMP1, 0);\n      stackpos -= (int)sizeof(sljit_sw);\n      setsom_found = TRUE;\n      }\n    if (common->mark_ptr != 0 && !setmark_found)\n      {\n      OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(SLJIT_SP), common->mark_ptr);\n      OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), stackpos, SLJIT_IMM, -common->mark_ptr);\n      stackpos -= (int)sizeof(sljit_sw);\n      OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), stackpos, TMP1, 0);\n      stackpos -= (int)sizeof(sljit_sw);\n      setmark_found = TRUE;\n      }\n    if (common->capture_last_ptr != 0 && !capture_last_found)\n      {\n      OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(SLJIT_SP), common->capture_last_ptr);\n      OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), stackpos, SLJIT_IMM, -common->capture_last_ptr);\n      stackpos -= (int)sizeof(sljit_sw);\n      OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), stackpos, TMP1, 0);\n      stackpos -= (int)sizeof(sljit_sw);\n      capture_last_found = TRUE;\n      }\n    cc += 1 + LINK_SIZE;\n    break;\n\n    case OP_CBRA:\n    case OP_CBRAPOS:\n    case OP_SCBRA:\n    case OP_SCBRAPOS:\n    if (common->capture_last_ptr != 0 && !capture_last_found)\n      {\n      OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(SLJIT_SP), common->capture_last_ptr);\n      OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), stackpos, SLJIT_IMM, -common->capture_last_ptr);\n      stackpos -= (int)sizeof(sljit_sw);\n      OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), stackpos, TMP1, 0);\n      stackpos -= (int)sizeof(sljit_sw);\n      capture_last_found = TRUE;\n      }\n    offset = (GET2(cc, 1 + LINK_SIZE)) << 1;\n    OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), stackpos, SLJIT_IMM, OVECTOR(offset));\n    stackpos -= (int)sizeof(sljit_sw);\n    OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(SLJIT_SP), OVECTOR(offset));\n    OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(SLJIT_SP), OVECTOR(offset + 1));\n    OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), stackpos, TMP1, 0);\n    stackpos -= (int)sizeof(sljit_sw);\n    OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), stackpos, TMP2, 0);\n    stackpos -= (int)sizeof(sljit_sw);\n\n    cc += 1 + LINK_SIZE + IMM2_SIZE;\n    break;\n\n    default:\n    cc = next_opcode(common, cc);\n    SLJIT_ASSERT(cc != NULL);\n    break;\n    }\n\nOP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), stackpos, SLJIT_IMM, 0);\nSLJIT_ASSERT(stackpos == STACK(stacktop));\n}\n\n#define RECURSE_TMP_REG_COUNT 3\n\ntypedef struct delayed_mem_copy_status {\n  struct sljit_compiler *compiler;\n  int store_bases\u00ddRECURSE_TMP_REG_COUNT\u00a8;\n  int store_offsets\u00ddRECURSE_TMP_REG_COUNT\u00a8;\n  int tmp_regs\u00ddRECURSE_TMP_REG_COUNT\u00a8;\n  int saved_tmp_regs\u00ddRECURSE_TMP_REG_COUNT\u00a8;\n  int next_tmp_reg;\n} delayed_mem_copy_status;\n\nstatic void delayed_mem_copy_init(delayed_mem_copy_status *status, compiler_common *common)\n{\nint i;\n\nfor (i = 0; i < RECURSE_TMP_REG_COUNT; i++)\n  {\n  SLJIT_ASSERT(status->tmp_regs\u00ddi\u00a8 >= 0);\n  SLJIT_ASSERT(sljit_get_register_index(status->saved_tmp_regs\u00ddi\u00a8) < 0 || status->tmp_regs\u00ddi\u00a8 == status->saved_tmp_regs\u00ddi\u00a8);\n\n  status->store_bases\u00ddi\u00a8 = -1;\n  }\nstatus->next_tmp_reg = 0;\nstatus->compiler = common->compiler;\n}\n\nstatic void delayed_mem_copy_move(delayed_mem_copy_status *status, int load_base, sljit_sw load_offset,\n  int store_base, sljit_sw store_offset)\n{\nstruct sljit_compiler *compiler = status->compiler;\nint next_tmp_reg = status->next_tmp_reg;\nint tmp_reg = status->tmp_regs\u00ddnext_tmp_reg\u00a8;\n\nSLJIT_ASSERT(load_base > 0 && store_base > 0);\n\nif (status->store_bases\u00ddnext_tmp_reg\u00a8 == -1)\n  {\n  /* Preserve virtual registers. */\n  if (sljit_get_register_index(status->saved_tmp_regs\u00ddnext_tmp_reg\u00a8) < 0)\n    OP1(SLJIT_MOV, status->saved_tmp_regs\u00ddnext_tmp_reg\u00a8, 0, tmp_reg, 0);\n  }\nelse\n  OP1(SLJIT_MOV, SLJIT_MEM1(status->store_bases\u00ddnext_tmp_reg\u00a8), status->store_offsets\u00ddnext_tmp_reg\u00a8, tmp_reg, 0);\n\nOP1(SLJIT_MOV, tmp_reg, 0, SLJIT_MEM1(load_base), load_offset);\nstatus->store_bases\u00ddnext_tmp_reg\u00a8 = store_base;\nstatus->store_offsets\u00ddnext_tmp_reg\u00a8 = store_offset;\n\nstatus->next_tmp_reg = (next_tmp_reg + 1) % RECURSE_TMP_REG_COUNT;\n}\n\nstatic void delayed_mem_copy_finish(delayed_mem_copy_status *status)\n{\nstruct sljit_compiler *compiler = status->compiler;\nint next_tmp_reg = status->next_tmp_reg;\nint tmp_reg, saved_tmp_reg, i;\n\nfor (i = 0; i < RECURSE_TMP_REG_COUNT; i++)\n  {\n  if (status->store_bases\u00ddnext_tmp_reg\u00a8 != -1)\n    {\n    tmp_reg = status->tmp_regs\u00ddnext_tmp_reg\u00a8;\n    saved_tmp_reg = status->saved_tmp_regs\u00ddnext_tmp_reg\u00a8;\n\n    OP1(SLJIT_MOV, SLJIT_MEM1(status->store_bases\u00ddnext_tmp_reg\u00a8), status->store_offsets\u00ddnext_tmp_reg\u00a8, tmp_reg, 0);\n\n    /* Restore virtual registers. */\n    if (sljit_get_register_index(saved_tmp_reg) < 0)\n      OP1(SLJIT_MOV, tmp_reg, 0, saved_tmp_reg, 0);\n    }\n\n  next_tmp_reg = (next_tmp_reg + 1) % RECURSE_TMP_REG_COUNT;\n  }\n}\n\n#undef RECURSE_TMP_REG_COUNT\n\nstatic int get_recurse_data_length(compiler_common *common, PCRE2_SPTR cc, PCRE2_SPTR ccend,\n  BOOL *needs_control_head, BOOL *has_quit, BOOL *has_accept)\n{\nint length = 1;\nint size;\nPCRE2_SPTR alternative;\nBOOL quit_found = FALSE;\nBOOL accept_found = FALSE;\nBOOL setsom_found = FALSE;\nBOOL setmark_found = FALSE;\nBOOL capture_last_found = FALSE;\nBOOL control_head_found = FALSE;\n\n#if defined DEBUG_FORCE_CONTROL_HEAD && DEBUG_FORCE_CONTROL_HEAD\nSLJIT_ASSERT(common->control_head_ptr != 0);\ncontrol_head_found = TRUE;\n#endif\n\n/* Calculate the sum of the private machine words. */\nwhile (cc < ccend)\n  {\n  size = 0;\n  switch(*cc)\n    {\n    case OP_SET_SOM:\n    SLJIT_ASSERT(common->has_set_som);\n    setsom_found = TRUE;\n    cc += 1;\n    break;\n\n    case OP_RECURSE:\n    if (common->has_set_som)\n      setsom_found = TRUE;\n    if (common->mark_ptr != 0)\n      setmark_found = TRUE;\n    if (common->capture_last_ptr != 0)\n      capture_last_found = TRUE;\n    cc += 1 + LINK_SIZE;\n    break;\n\n    case OP_KET:\n    if (PRIVATE_DATA(cc) != 0)\n      {\n      length++;\n      SLJIT_ASSERT(PRIVATE_DATA(cc + 1) != 0);\n      cc += PRIVATE_DATA(cc + 1);\n      }\n    cc += 1 + LINK_SIZE;\n    break;\n\n    case OP_ASSERT:\n    case OP_ASSERT_NOT:\n    case OP_ASSERTBACK:\n    case OP_ASSERTBACK_NOT:\n    case OP_ASSERT_NA:\n    case OP_ASSERTBACK_NA:\n    case OP_ONCE:\n    case OP_SCRIPT_RUN:\n    case OP_BRAPOS:\n    case OP_SBRA:\n    case OP_SBRAPOS:\n    case OP_SCOND:\n    length++;\n    SLJIT_ASSERT(PRIVATE_DATA(cc) != 0);\n    cc += 1 + LINK_SIZE;\n    break;\n\n    case OP_CBRA:\n    case OP_SCBRA:\n    length += 2;\n    if (common->capture_last_ptr != 0)\n      capture_last_found = TRUE;\n    if (common->optimized_cbracket\u00ddGET2(cc, 1 + LINK_SIZE)\u00a8 == 0)\n      length++;\n    cc += 1 + LINK_SIZE + IMM2_SIZE;\n    break;\n\n    case OP_CBRAPOS:\n    case OP_SCBRAPOS:\n    length += 2 + 2;\n    if (common->capture_last_ptr != 0)\n      capture_last_found = TRUE;\n    cc += 1 + LINK_SIZE + IMM2_SIZE;\n    break;\n\n    case OP_COND:\n    /* Might be a hidden SCOND. */\n    alternative = cc + GET(cc, 1);\n    if (*alternative == OP_KETRMAX || *alternative == OP_KETRMIN)\n      length++;\n    cc += 1 + LINK_SIZE;\n    break;\n\n    CASE_ITERATOR_PRIVATE_DATA_1\n    if (PRIVATE_DATA(cc) != 0)\n      length++;\n    cc += 2;\n#ifdef SUPPORT_UNICODE\n    if (common->utf && HAS_EXTRALEN(cc\u00dd-1\u00a8)) cc += GET_EXTRALEN(cc\u00dd-1\u00a8);\n#endif\n    break;\n\n    CASE_ITERATOR_PRIVATE_DATA_2A\n    if (PRIVATE_DATA(cc) != 0)\n      length += 2;\n    cc += 2;\n#ifdef SUPPORT_UNICODE\n    if (common->utf && HAS_EXTRALEN(cc\u00dd-1\u00a8)) cc += GET_EXTRALEN(cc\u00dd-1\u00a8);\n#endif\n    break;\n\n    CASE_ITERATOR_PRIVATE_DATA_2B\n    if (PRIVATE_DATA(cc) != 0)\n      length += 2;\n    cc += 2 + IMM2_SIZE;\n#ifdef SUPPORT_UNICODE\n    if (common->utf && HAS_EXTRALEN(cc\u00dd-1\u00a8)) cc += GET_EXTRALEN(cc\u00dd-1\u00a8);\n#endif\n    break;\n\n    CASE_ITERATOR_TYPE_PRIVATE_DATA_1\n    if (PRIVATE_DATA(cc) != 0)\n      length++;\n    cc += 1;\n    break;\n\n    CASE_ITERATOR_TYPE_PRIVATE_DATA_2A\n    if (PRIVATE_DATA(cc) != 0)\n      length += 2;\n    cc += 1;\n    break;\n\n    CASE_ITERATOR_TYPE_PRIVATE_DATA_2B\n    if (PRIVATE_DATA(cc) != 0)\n      length += 2;\n    cc += 1 + IMM2_SIZE;\n    break;\n\n    case OP_CLASS:\n    case OP_NCLASS:\n#if defined SUPPORT_UNICODE || PCRE2_CODE_UNIT_WIDTH != 8\n    case OP_XCLASS:\n    size = (*cc == OP_XCLASS) ? GET(cc, 1) : 1 + 32 / (int)sizeof(PCRE2_UCHAR);\n#else\n    size = 1 + 32 / (int)sizeof(PCRE2_UCHAR);\n#endif\n    if (PRIVATE_DATA(cc) != 0)\n      length += get_class_iterator_size(cc + size);\n    cc += size;\n    break;\n\n    case OP_MARK:\n    case OP_COMMIT_ARG:\n    case OP_PRUNE_ARG:\n    case OP_THEN_ARG:\n    SLJIT_ASSERT(common->mark_ptr != 0);\n    if (!setmark_found)\n      setmark_found = TRUE;\n    if (common->control_head_ptr != 0)\n      control_head_found = TRUE;\n    if (*cc != OP_MARK)\n      quit_found = TRUE;\n\n    cc += 1 + 2 + cc\u00dd1\u00a8;\n    break;\n\n    case OP_PRUNE:\n    case OP_SKIP:\n    case OP_COMMIT:\n    quit_found = TRUE;\n    cc++;\n    break;\n\n    case OP_SKIP_ARG:\n    quit_found = TRUE;\n    cc += 1 + 2 + cc\u00dd1\u00a8;\n    break;\n\n    case OP_THEN:\n    SLJIT_ASSERT(common->control_head_ptr != 0);\n    quit_found = TRUE;\n    if (!control_head_found)\n      control_head_found = TRUE;\n    cc++;\n    break;\n\n    case OP_ACCEPT:\n    case OP_ASSERT_ACCEPT:\n    accept_found = TRUE;\n    cc++;\n    break;\n\n    default:\n    cc = next_opcode(common, cc);\n    SLJIT_ASSERT(cc != NULL);\n    break;\n    }\n  }\nSLJIT_ASSERT(cc == ccend);\n\nif (control_head_found)\n  length++;\nif (capture_last_found)\n  length++;\nif (quit_found)\n  {\n  if (setsom_found)\n    length++;\n  if (setmark_found)\n    length++;\n  }\n\n*needs_control_head = control_head_found;\n*has_quit = quit_found;\n*has_accept = accept_found;\nreturn length;\n}\n\nenum copy_recurse_data_types {\n  recurse_copy_from_global,\n  recurse_copy_private_to_global,\n  recurse_copy_shared_to_global,\n  recurse_copy_kept_shared_to_global,\n  recurse_swap_global\n};\n\nstatic void copy_recurse_data(compiler_common *common, PCRE2_SPTR cc, PCRE2_SPTR ccend,\n  int type, int stackptr, int stacktop, BOOL has_quit)\n{\ndelayed_mem_copy_status status;\nPCRE2_SPTR alternative;\nsljit_sw private_srcw\u00dd2\u00a8;\nsljit_sw shared_srcw\u00dd3\u00a8;\nsljit_sw kept_shared_srcw\u00dd2\u00a8;\nint private_count, shared_count, kept_shared_count;\nint from_sp, base_reg, offset, i;\nBOOL setsom_found = FALSE;\nBOOL setmark_found = FALSE;\nBOOL capture_last_found = FALSE;\nBOOL control_head_found = FALSE;\n\n#if defined DEBUG_FORCE_CONTROL_HEAD && DEBUG_FORCE_CONTROL_HEAD\nSLJIT_ASSERT(common->control_head_ptr != 0);\ncontrol_head_found = TRUE;\n#endif\n\nswitch (type)\n  {\n  case recurse_copy_from_global:\n  from_sp = TRUE;\n  base_reg = STACK_TOP;\n  break;\n\n  case recurse_copy_private_to_global:\n  case recurse_copy_shared_to_global:\n  case recurse_copy_kept_shared_to_global:\n  from_sp = FALSE;\n  base_reg = STACK_TOP;\n  break;\n\n  default:\n  SLJIT_ASSERT(type == recurse_swap_global);\n  from_sp = FALSE;\n  base_reg = TMP2;\n  break;\n  }\n\nstackptr = STACK(stackptr);\nstacktop = STACK(stacktop);\n\nstatus.tmp_regs\u00dd0\u00a8 = TMP1;\nstatus.saved_tmp_regs\u00dd0\u00a8 = TMP1;\n\nif (base_reg != TMP2)\n  {\n  status.tmp_regs\u00dd1\u00a8 = TMP2;\n  status.saved_tmp_regs\u00dd1\u00a8 = TMP2;\n  }\nelse\n  {\n  status.saved_tmp_regs\u00dd1\u00a8 = RETURN_ADDR;\n  if (HAS_VIRTUAL_REGISTERS)\n    status.tmp_regs\u00dd1\u00a8 = STR_PTR;\n  else\n    status.tmp_regs\u00dd1\u00a8 = RETURN_ADDR;\n  }\n\nstatus.saved_tmp_regs\u00dd2\u00a8 = TMP3;\nif (HAS_VIRTUAL_REGISTERS)\n  status.tmp_regs\u00dd2\u00a8 = STR_END;\nelse\n  status.tmp_regs\u00dd2\u00a8 = TMP3;\n\ndelayed_mem_copy_init(&status, common);\n\nif (type != recurse_copy_shared_to_global && type != recurse_copy_kept_shared_to_global)\n  {\n  SLJIT_ASSERT(type == recurse_copy_from_global || type == recurse_copy_private_to_global || type == recurse_swap_global);\n\n  if (!from_sp)\n    delayed_mem_copy_move(&status, base_reg, stackptr, SLJIT_SP, common->recursive_head_ptr);\n\n  if (from_sp || type == recurse_swap_global)\n    delayed_mem_copy_move(&status, SLJIT_SP, common->recursive_head_ptr, base_reg, stackptr);\n  }\n\nstackptr += sizeof(sljit_sw);\n\n#if defined DEBUG_FORCE_CONTROL_HEAD && DEBUG_FORCE_CONTROL_HEAD\nif (type != recurse_copy_shared_to_global)\n  {\n  if (!from_sp)\n    delayed_mem_copy_move(&status, base_reg, stackptr, SLJIT_SP, common->control_head_ptr);\n\n  if (from_sp || type == recurse_swap_global)\n    delayed_mem_copy_move(&status, SLJIT_SP, common->control_head_ptr, base_reg, stackptr);\n  }\n\nstackptr += sizeof(sljit_sw);\n#endif\n\nwhile (cc < ccend)\n  {\n  private_count = 0;\n  shared_count = 0;\n  kept_shared_count = 0;\n\n  switch(*cc)\n    {\n    case OP_SET_SOM:\n    SLJIT_ASSERT(common->has_set_som);\n    if (has_quit && !setsom_found)\n      {\n      kept_shared_srcw\u00dd0\u00a8 = OVECTOR(0);\n      kept_shared_count = 1;\n      setsom_found = TRUE;\n      }\n    cc += 1;\n    break;\n\n    case OP_RECURSE:\n    if (has_quit)\n      {\n      if (common->has_set_som && !setsom_found)\n        {\n        kept_shared_srcw\u00dd0\u00a8 = OVECTOR(0);\n        kept_shared_count = 1;\n        setsom_found = TRUE;\n        }\n      if (common->mark_ptr != 0 && !setmark_found)\n        {\n        kept_shared_srcw\u00ddkept_shared_count\u00a8 = common->mark_ptr;\n        kept_shared_count++;\n        setmark_found = TRUE;\n        }\n      }\n    if (common->capture_last_ptr != 0 && !capture_last_found)\n      {\n      shared_srcw\u00dd0\u00a8 = common->capture_last_ptr;\n      shared_count = 1;\n      capture_last_found = TRUE;\n      }\n    cc += 1 + LINK_SIZE;\n    break;\n\n    case OP_KET:\n    if (PRIVATE_DATA(cc) != 0)\n      {\n      private_count = 1;\n      private_srcw\u00dd0\u00a8 = PRIVATE_DATA(cc);\n      SLJIT_ASSERT(PRIVATE_DATA(cc + 1) != 0);\n      cc += PRIVATE_DATA(cc + 1);\n      }\n    cc += 1 + LINK_SIZE;\n    break;\n\n    case OP_ASSERT:\n    case OP_ASSERT_NOT:\n    case OP_ASSERTBACK:\n    case OP_ASSERTBACK_NOT:\n    case OP_ASSERT_NA:\n    case OP_ASSERTBACK_NA:\n    case OP_ONCE:\n    case OP_SCRIPT_RUN:\n    case OP_BRAPOS:\n    case OP_SBRA:\n    case OP_SBRAPOS:\n    case OP_SCOND:\n    private_count = 1;\n    private_srcw\u00dd0\u00a8 = PRIVATE_DATA(cc);\n    cc += 1 + LINK_SIZE;\n    break;\n\n    case OP_CBRA:\n    case OP_SCBRA:\n    offset = (GET2(cc, 1 + LINK_SIZE)) << 1;\n    shared_srcw\u00dd0\u00a8 = OVECTOR(offset);\n    shared_srcw\u00dd1\u00a8 = OVECTOR(offset + 1);\n    shared_count = 2;\n\n    if (common->capture_last_ptr != 0 && !capture_last_found)\n      {\n      shared_srcw\u00dd2\u00a8 = common->capture_last_ptr;\n      shared_count = 3;\n      capture_last_found = TRUE;\n      }\n\n    if (common->optimized_cbracket\u00ddGET2(cc, 1 + LINK_SIZE)\u00a8 == 0)\n      {\n      private_count = 1;\n      private_srcw\u00dd0\u00a8 = OVECTOR_PRIV(GET2(cc, 1 + LINK_SIZE));\n      }\n    cc += 1 + LINK_SIZE + IMM2_SIZE;\n    break;\n\n    case OP_CBRAPOS:\n    case OP_SCBRAPOS:\n    offset = (GET2(cc, 1 + LINK_SIZE)) << 1;\n    shared_srcw\u00dd0\u00a8 = OVECTOR(offset);\n    shared_srcw\u00dd1\u00a8 = OVECTOR(offset + 1);\n    shared_count = 2;\n\n    if (common->capture_last_ptr != 0 && !capture_last_found)\n      {\n      shared_srcw\u00dd2\u00a8 = common->capture_last_ptr;\n      shared_count = 3;\n      capture_last_found = TRUE;\n      }\n\n    private_count = 2;\n    private_srcw\u00dd0\u00a8 = PRIVATE_DATA(cc);\n    private_srcw\u00dd1\u00a8 = OVECTOR_PRIV(GET2(cc, 1 + LINK_SIZE));\n    cc += 1 + LINK_SIZE + IMM2_SIZE;\n    break;\n\n    case OP_COND:\n    /* Might be a hidden SCOND. */\n    alternative = cc + GET(cc, 1);\n    if (*alternative == OP_KETRMAX || *alternative == OP_KETRMIN)\n      {\n      private_count = 1;\n      private_srcw\u00dd0\u00a8 = PRIVATE_DATA(cc);\n      }\n    cc += 1 + LINK_SIZE;\n    break;\n\n    CASE_ITERATOR_PRIVATE_DATA_1\n    if (PRIVATE_DATA(cc))\n      {\n      private_count = 1;\n      private_srcw\u00dd0\u00a8 = PRIVATE_DATA(cc);\n      }\n    cc += 2;\n#ifdef SUPPORT_UNICODE\n    if (common->utf && HAS_EXTRALEN(cc\u00dd-1\u00a8)) cc += GET_EXTRALEN(cc\u00dd-1\u00a8);\n#endif\n    break;\n\n    CASE_ITERATOR_PRIVATE_DATA_2A\n    if (PRIVATE_DATA(cc))\n      {\n      private_count = 2;\n      private_srcw\u00dd0\u00a8 = PRIVATE_DATA(cc);\n      private_srcw\u00dd1\u00a8 = PRIVATE_DATA(cc) + sizeof(sljit_sw);\n      }\n    cc += 2;\n#ifdef SUPPORT_UNICODE\n    if (common->utf && HAS_EXTRALEN(cc\u00dd-1\u00a8)) cc += GET_EXTRALEN(cc\u00dd-1\u00a8);\n#endif\n    break;\n\n    CASE_ITERATOR_PRIVATE_DATA_2B\n    if (PRIVATE_DATA(cc))\n      {\n      private_count = 2;\n      private_srcw\u00dd0\u00a8 = PRIVATE_DATA(cc);\n      private_srcw\u00dd1\u00a8 = PRIVATE_DATA(cc) + sizeof(sljit_sw);\n      }\n    cc += 2 + IMM2_SIZE;\n#ifdef SUPPORT_UNICODE\n    if (common->utf && HAS_EXTRALEN(cc\u00dd-1\u00a8)) cc += GET_EXTRALEN(cc\u00dd-1\u00a8);\n#endif\n    break;\n\n    CASE_ITERATOR_TYPE_PRIVATE_DATA_1\n    if (PRIVATE_DATA(cc))\n      {\n      private_count = 1;\n      private_srcw\u00dd0\u00a8 = PRIVATE_DATA(cc);\n      }\n    cc += 1;\n    break;\n\n    CASE_ITERATOR_TYPE_PRIVATE_DATA_2A\n    if (PRIVATE_DATA(cc))\n      {\n      private_count = 2;\n      private_srcw\u00dd0\u00a8 = PRIVATE_DATA(cc);\n      private_srcw\u00dd1\u00a8 = private_srcw\u00dd0\u00a8 + sizeof(sljit_sw);\n      }\n    cc += 1;\n    break;\n\n    CASE_ITERATOR_TYPE_PRIVATE_DATA_2B\n    if (PRIVATE_DATA(cc))\n      {\n      private_count = 2;\n      private_srcw\u00dd0\u00a8 = PRIVATE_DATA(cc);\n      private_srcw\u00dd1\u00a8 = private_srcw\u00dd0\u00a8 + sizeof(sljit_sw);\n      }\n    cc += 1 + IMM2_SIZE;\n    break;\n\n    case OP_CLASS:\n    case OP_NCLASS:\n#if defined SUPPORT_UNICODE || PCRE2_CODE_UNIT_WIDTH != 8\n    case OP_XCLASS:\n    i = (*cc == OP_XCLASS) ? GET(cc, 1) : 1 + 32 / (int)sizeof(PCRE2_UCHAR);\n#else\n    i = 1 + 32 / (int)sizeof(PCRE2_UCHAR);\n#endif\n    if (PRIVATE_DATA(cc) != 0)\n      switch(get_class_iterator_size(cc + i))\n        {\n        case 1:\n        private_count = 1;\n        private_srcw\u00dd0\u00a8 = PRIVATE_DATA(cc);\n        break;\n\n        case 2:\n        private_count = 2;\n        private_srcw\u00dd0\u00a8 = PRIVATE_DATA(cc);\n        private_srcw\u00dd1\u00a8 = private_srcw\u00dd0\u00a8 + sizeof(sljit_sw);\n        break;\n\n        default:\n        SLJIT_UNREACHABLE();\n        break;\n        }\n    cc += i;\n    break;\n\n    case OP_MARK:\n    case OP_COMMIT_ARG:\n    case OP_PRUNE_ARG:\n    case OP_THEN_ARG:\n    SLJIT_ASSERT(common->mark_ptr != 0);\n    if (has_quit && !setmark_found)\n      {\n      kept_shared_srcw\u00dd0\u00a8 = common->mark_ptr;\n      kept_shared_count = 1;\n      setmark_found = TRUE;\n      }\n    if (common->control_head_ptr != 0 && !control_head_found)\n      {\n      private_srcw\u00dd0\u00a8 = common->control_head_ptr;\n      private_count = 1;\n      control_head_found = TRUE;\n      }\n    cc += 1 + 2 + cc\u00dd1\u00a8;\n    break;\n\n    case OP_THEN:\n    SLJIT_ASSERT(common->control_head_ptr != 0);\n    if (!control_head_found)\n      {\n      private_srcw\u00dd0\u00a8 = common->control_head_ptr;\n      private_count = 1;\n      control_head_found = TRUE;\n      }\n    cc++;\n    break;\n\n    default:\n    cc = next_opcode(common, cc);\n    SLJIT_ASSERT(cc != NULL);\n    break;\n    }\n\n  if (type != recurse_copy_shared_to_global && type != recurse_copy_kept_shared_to_global)\n    {\n    SLJIT_ASSERT(type == recurse_copy_from_global || type == recurse_copy_private_to_global || type == recurse_swap_global);\n\n    for (i = 0; i < private_count; i++)\n      {\n      SLJIT_ASSERT(private_srcw\u00ddi\u00a8 != 0);\n\n      if (!from_sp)\n        delayed_mem_copy_move(&status, base_reg, stackptr, SLJIT_SP, private_srcw\u00ddi\u00a8);\n\n      if (from_sp || type == recurse_swap_global)\n        delayed_mem_copy_move(&status, SLJIT_SP, private_srcw\u00ddi\u00a8, base_reg, stackptr);\n\n      stackptr += sizeof(sljit_sw);\n      }\n    }\n  else\n    stackptr += sizeof(sljit_sw) * private_count;\n\n  if (type != recurse_copy_private_to_global && type != recurse_copy_kept_shared_to_global)\n    {\n    SLJIT_ASSERT(type == recurse_copy_from_global || type == recurse_copy_shared_to_global || type == recurse_swap_global);\n\n    for (i = 0; i < shared_count; i++)\n      {\n      SLJIT_ASSERT(shared_srcw\u00ddi\u00a8 != 0);\n\n      if (!from_sp)\n        delayed_mem_copy_move(&status, base_reg, stackptr, SLJIT_SP, shared_srcw\u00ddi\u00a8);\n\n      if (from_sp || type == recurse_swap_global)\n        delayed_mem_copy_move(&status, SLJIT_SP, shared_srcw\u00ddi\u00a8, base_reg, stackptr);\n\n      stackptr += sizeof(sljit_sw);\n      }\n    }\n  else\n    stackptr += sizeof(sljit_sw) * shared_count;\n\n  if (type != recurse_copy_private_to_global && type != recurse_swap_global)\n    {\n    SLJIT_ASSERT(type == recurse_copy_from_global || type == recurse_copy_shared_to_global || type == recurse_copy_kept_shared_to_global);\n\n    for (i = 0; i < kept_shared_count; i++)\n      {\n      SLJIT_ASSERT(kept_shared_srcw\u00ddi\u00a8 != 0);\n\n      if (!from_sp)\n        delayed_mem_copy_move(&status, base_reg, stackptr, SLJIT_SP, kept_shared_srcw\u00ddi\u00a8);\n\n      if (from_sp || type == recurse_swap_global)\n        delayed_mem_copy_move(&status, SLJIT_SP, kept_shared_srcw\u00ddi\u00a8, base_reg, stackptr);\n\n      stackptr += sizeof(sljit_sw);\n      }\n    }\n  else\n    stackptr += sizeof(sljit_sw) * kept_shared_count;\n  }\n\nSLJIT_ASSERT(cc == ccend && stackptr == stacktop);\n\ndelayed_mem_copy_finish(&status);\n}\n\nstatic SLJIT_INLINE PCRE2_SPTR set_then_offsets(compiler_common *common, PCRE2_SPTR cc, sljit_u8 *current_offset)\n{\nPCRE2_SPTR end = bracketend(cc);\nBOOL has_alternatives = cc\u00ddGET(cc, 1)\u00a8 == OP_ALT;\n\n/* Assert captures then. */\nif (*cc >= OP_ASSERT && *cc <= OP_ASSERTBACK_NA)\n  current_offset = NULL;\n/* Conditional block does not. */\nif (*cc == OP_COND || *cc == OP_SCOND)\n  has_alternatives = FALSE;\n\ncc = next_opcode(common, cc);\nif (has_alternatives)\n  current_offset = common->then_offsets + (cc - common->start);\n\nwhile (cc < end)\n  {\n  if ((*cc >= OP_ASSERT && *cc <= OP_ASSERTBACK_NA) || (*cc >= OP_ONCE && *cc <= OP_SCOND))\n    cc = set_then_offsets(common, cc, current_offset);\n  else\n    {\n    if (*cc == OP_ALT && has_alternatives)\n      current_offset = common->then_offsets + (cc + 1 + LINK_SIZE - common->start);\n    if (*cc >= OP_THEN && *cc <= OP_THEN_ARG && current_offset != NULL)\n      *current_offset = 1;\n    cc = next_opcode(common, cc);\n    }\n  }\n\nreturn end;\n}\n\n#undef CASE_ITERATOR_PRIVATE_DATA_1\n#undef CASE_ITERATOR_PRIVATE_DATA_2A\n#undef CASE_ITERATOR_PRIVATE_DATA_2B\n#undef CASE_ITERATOR_TYPE_PRIVATE_DATA_1\n#undef CASE_ITERATOR_TYPE_PRIVATE_DATA_2A\n#undef CASE_ITERATOR_TYPE_PRIVATE_DATA_2B\n\nstatic SLJIT_INLINE BOOL is_powerof2(unsigned int value)\n{\nreturn (value & (value - 1)) == 0;\n}\n\nstatic SLJIT_INLINE void set_jumps(jump_list *list, struct sljit_label *label)\n{\nwhile (list)\n  {\n  /* sljit_set_label is clever enough to do nothing\n  if either the jump or the label is NULL. */\n  SET_LABEL(list->jump, label);\n  list = list->next;\n  }\n}\n\nstatic SLJIT_INLINE void add_jump(struct sljit_compiler *compiler, jump_list **list, struct sljit_jump *jump)\n{\njump_list *list_item = sljit_alloc_memory(compiler, sizeof(jump_list));\nif (list_item)\n  {\n  list_item->next = *list;\n  list_item->jump = jump;\n  *list = list_item;\n  }\n}\n\nstatic void add_stub(compiler_common *common, struct sljit_jump *start)\n{\nDEFINE_COMPILER;\nstub_list *list_item = sljit_alloc_memory(compiler, sizeof(stub_list));\n\nif (list_item)\n  {\n  list_item->start = start;\n  list_item->quit = LABEL();\n  list_item->next = common->stubs;\n  common->stubs = list_item;\n  }\n}\n\nstatic void flush_stubs(compiler_common *common)\n{\nDEFINE_COMPILER;\nstub_list *list_item = common->stubs;\n\nwhile (list_item)\n  {\n  JUMPHERE(list_item->start);\n  add_jump(compiler, &common->stackalloc, JUMP(SLJIT_FAST_CALL));\n  JUMPTO(SLJIT_JUMP, list_item->quit);\n  list_item = list_item->next;\n  }\ncommon->stubs = NULL;\n}\n\nstatic SLJIT_INLINE void count_match(compiler_common *common)\n{\nDEFINE_COMPILER;\n\nOP2(SLJIT_SUB | SLJIT_SET_Z, COUNT_MATCH, 0, COUNT_MATCH, 0, SLJIT_IMM, 1);\nadd_jump(compiler, &common->calllimit, JUMP(SLJIT_ZERO));\n}\n\nstatic SLJIT_INLINE void allocate_stack(compiler_common *common, int size)\n{\n/* May destroy all locals and registers except TMP2. */\nDEFINE_COMPILER;\n\nSLJIT_ASSERT(size > 0);\nOP2(SLJIT_SUB, STACK_TOP, 0, STACK_TOP, 0, SLJIT_IMM, size * sizeof(sljit_sw));\n#ifdef DESTROY_REGISTERS\nOP1(SLJIT_MOV, TMP1, 0, SLJIT_IMM, 12345);\nOP1(SLJIT_MOV, TMP3, 0, TMP1, 0);\nOP1(SLJIT_MOV, RETURN_ADDR, 0, TMP1, 0);\nOP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), LOCALS0, TMP1, 0);\nOP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), LOCALS1, TMP1, 0);\n#endif\nadd_stub(common, CMP(SLJIT_LESS, STACK_TOP, 0, STACK_LIMIT, 0));\n}\n\nstatic SLJIT_INLINE void free_stack(compiler_common *common, int size)\n{\nDEFINE_COMPILER;\n\nSLJIT_ASSERT(size > 0);\nOP2(SLJIT_ADD, STACK_TOP, 0, STACK_TOP, 0, SLJIT_IMM, size * sizeof(sljit_sw));\n}\n\nstatic sljit_uw * allocate_read_only_data(compiler_common *common, sljit_uw size)\n{\nDEFINE_COMPILER;\nsljit_uw *result;\n\nif (SLJIT_UNLIKELY(sljit_get_compiler_error(compiler)))\n  return NULL;\n\nresult = (sljit_uw *)SLJIT_MALLOC(size + sizeof(sljit_uw), compiler->allocator_data);\nif (SLJIT_UNLIKELY(result == NULL))\n  {\n  sljit_set_compiler_memory_error(compiler);\n  return NULL;\n  }\n\n*(void**)result = common->read_only_data_head;\ncommon->read_only_data_head = (void *)result;\nreturn result + 1;\n}\n\nstatic SLJIT_INLINE void reset_ovector(compiler_common *common, int length)\n{\nDEFINE_COMPILER;\nstruct sljit_label *loop;\nsljit_s32 i;\n\n/* At this point we can freely use all temporary registers. */\nSLJIT_ASSERT(length > 1);\n/* TMP1 returns with begin - 1. */\nOP2(SLJIT_SUB, SLJIT_R0, 0, SLJIT_MEM1(SLJIT_S0), SLJIT_OFFSETOF(jit_arguments, begin), SLJIT_IMM, IN_UCHARS(1));\nif (length < 8)\n  {\n  for (i = 1; i < length; i++)\n    OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), OVECTOR(i), SLJIT_R0, 0);\n  }\nelse\n  {\n  if (sljit_emit_mem(compiler, SLJIT_MOV | SLJIT_MEM_SUPP | SLJIT_MEM_STORE | SLJIT_MEM_PRE, SLJIT_R0, SLJIT_MEM1(SLJIT_R1), sizeof(sljit_sw)) == SLJIT_SUCCESS)\n    {\n    GET_LOCAL_BASE(SLJIT_R1, 0, OVECTOR_START);\n    OP1(SLJIT_MOV, SLJIT_R2, 0, SLJIT_IMM, length - 1);\n    loop = LABEL();\n    sljit_emit_mem(compiler, SLJIT_MOV | SLJIT_MEM_STORE | SLJIT_MEM_PRE, SLJIT_R0, SLJIT_MEM1(SLJIT_R1), sizeof(sljit_sw));\n    OP2(SLJIT_SUB | SLJIT_SET_Z, SLJIT_R2, 0, SLJIT_R2, 0, SLJIT_IMM, 1);\n    JUMPTO(SLJIT_NOT_ZERO, loop);\n    }\n  else\n    {\n    GET_LOCAL_BASE(SLJIT_R1, 0, OVECTOR_START + sizeof(sljit_sw));\n    OP1(SLJIT_MOV, SLJIT_R2, 0, SLJIT_IMM, length - 1);\n    loop = LABEL();\n    OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_R1), 0, SLJIT_R0, 0);\n    OP2(SLJIT_ADD, SLJIT_R1, 0, SLJIT_R1, 0, SLJIT_IMM, sizeof(sljit_sw));\n    OP2(SLJIT_SUB | SLJIT_SET_Z, SLJIT_R2, 0, SLJIT_R2, 0, SLJIT_IMM, 1);\n    JUMPTO(SLJIT_NOT_ZERO, loop);\n    }\n  }\n}\n\nstatic SLJIT_INLINE void reset_early_fail(compiler_common *common)\n{\nDEFINE_COMPILER;\nsljit_u32 size = (sljit_u32)(common->early_fail_end_ptr - common->early_fail_start_ptr);\nsljit_u32 uncleared_size;\nsljit_s32 src = SLJIT_IMM;\nsljit_s32 i;\nstruct sljit_label *loop;\n\nSLJIT_ASSERT(common->early_fail_start_ptr < common->early_fail_end_ptr);\n\nif (size == sizeof(sljit_sw))\n  {\n  OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), common->early_fail_start_ptr, SLJIT_IMM, 0);\n  return;\n  }\n\nif (sljit_get_register_index(TMP3) >= 0 && !sljit_has_cpu_feature(SLJIT_HAS_ZERO_REGISTER))\n  {\n  OP1(SLJIT_MOV, TMP3, 0, SLJIT_IMM, 0);\n  src = TMP3;\n  }\n\nif (size <= 6 * sizeof(sljit_sw))\n  {\n  for (i = common->early_fail_start_ptr; i < common->early_fail_end_ptr; i += sizeof(sljit_sw))\n    OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), i, src, 0);\n  return;\n  }\n\nGET_LOCAL_BASE(TMP1, 0, common->early_fail_start_ptr);\n\nuncleared_size = ((size / sizeof(sljit_sw)) % 3) * sizeof(sljit_sw);\n\nOP2(SLJIT_ADD, TMP2, 0, TMP1, 0, SLJIT_IMM, size - uncleared_size);\n\nloop = LABEL();\nOP1(SLJIT_MOV, SLJIT_MEM1(TMP1), 0, src, 0);\nOP2(SLJIT_ADD, TMP1, 0, TMP1, 0, SLJIT_IMM, 3 * sizeof(sljit_sw));\nOP1(SLJIT_MOV, SLJIT_MEM1(TMP1), -2 * (sljit_sw)sizeof(sljit_sw), src, 0);\nOP1(SLJIT_MOV, SLJIT_MEM1(TMP1), -1 * (sljit_sw)sizeof(sljit_sw), src, 0);\nCMPTO(SLJIT_LESS, TMP1, 0, TMP2, 0, loop);\n\nif (uncleared_size >= sizeof(sljit_sw))\n  OP1(SLJIT_MOV, SLJIT_MEM1(TMP1), 0, src, 0);\n\nif (uncleared_size >= 2 * sizeof(sljit_sw))\n  OP1(SLJIT_MOV, SLJIT_MEM1(TMP1), sizeof(sljit_sw), src, 0);\n}\n\nstatic SLJIT_INLINE void do_reset_match(compiler_common *common, int length)\n{\nDEFINE_COMPILER;\nstruct sljit_label *loop;\nint i;\n\nSLJIT_ASSERT(length > 1);\n/* OVECTOR(1) contains the \"string begin - 1\" constant. */\nif (length > 2)\n  OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(SLJIT_SP), OVECTOR(1));\nif (length < 8)\n  {\n  for (i = 2; i < length; i++)\n    OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), OVECTOR(i), TMP1, 0);\n  }\nelse\n  {\n  if (sljit_emit_mem(compiler, SLJIT_MOV | SLJIT_MEM_SUPP | SLJIT_MEM_STORE | SLJIT_MEM_PRE, TMP1, SLJIT_MEM1(TMP2), sizeof(sljit_sw)) == SLJIT_SUCCESS)\n    {\n    GET_LOCAL_BASE(TMP2, 0, OVECTOR_START + sizeof(sljit_sw));\n    OP1(SLJIT_MOV, STACK_TOP, 0, SLJIT_IMM, length - 2);\n    loop = LABEL();\n    sljit_emit_mem(compiler, SLJIT_MOV | SLJIT_MEM_STORE | SLJIT_MEM_PRE, TMP1, SLJIT_MEM1(TMP2), sizeof(sljit_sw));\n    OP2(SLJIT_SUB | SLJIT_SET_Z, STACK_TOP, 0, STACK_TOP, 0, SLJIT_IMM, 1);\n    JUMPTO(SLJIT_NOT_ZERO, loop);\n    }\n  else\n    {\n    GET_LOCAL_BASE(TMP2, 0, OVECTOR_START + 2 * sizeof(sljit_sw));\n    OP1(SLJIT_MOV, STACK_TOP, 0, SLJIT_IMM, length - 2);\n    loop = LABEL();\n    OP1(SLJIT_MOV, SLJIT_MEM1(TMP2), 0, TMP1, 0);\n    OP2(SLJIT_ADD, TMP2, 0, TMP2, 0, SLJIT_IMM, sizeof(sljit_sw));\n    OP2(SLJIT_SUB | SLJIT_SET_Z, STACK_TOP, 0, STACK_TOP, 0, SLJIT_IMM, 1);\n    JUMPTO(SLJIT_NOT_ZERO, loop);\n    }\n  }\n\nif (!HAS_VIRTUAL_REGISTERS)\n  OP1(SLJIT_MOV, STACK_TOP, 0, SLJIT_MEM1(ARGUMENTS), SLJIT_OFFSETOF(jit_arguments, stack));\nelse\n  OP1(SLJIT_MOV, STACK_TOP, 0, ARGUMENTS, 0);\n\nif (common->mark_ptr != 0)\n  OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), common->mark_ptr, SLJIT_IMM, 0);\nif (common->control_head_ptr != 0)\n  OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), common->control_head_ptr, SLJIT_IMM, 0);\nif (HAS_VIRTUAL_REGISTERS)\n  OP1(SLJIT_MOV, STACK_TOP, 0, SLJIT_MEM1(STACK_TOP), SLJIT_OFFSETOF(jit_arguments, stack));\n\nOP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(SLJIT_SP), common->start_ptr);\nOP1(SLJIT_MOV, STACK_TOP, 0, SLJIT_MEM1(STACK_TOP), SLJIT_OFFSETOF(struct sljit_stack, end));\n}\n\nstatic sljit_sw SLJIT_FUNC do_search_mark(sljit_sw *current, PCRE2_SPTR skip_arg)\n{\nwhile (current != NULL)\n  {\n  switch (current\u00dd1\u00a8)\n    {\n    case type_then_trap:\n    break;\n\n    case type_mark:\n    if (PRIV(strcmp)(skip_arg, (PCRE2_SPTR)current\u00dd2\u00a8) == 0)\n      return current\u00dd3\u00a8;\n    break;\n\n    default:\n    SLJIT_UNREACHABLE();\n    break;\n    }\n  SLJIT_ASSERT(current\u00dd0\u00a8 == 0 || current < (sljit_sw*)current\u00dd0\u00a8);\n  current = (sljit_sw*)current\u00dd0\u00a8;\n  }\nreturn 0;\n}\n\nstatic SLJIT_INLINE void copy_ovector(compiler_common *common, int topbracket)\n{\nDEFINE_COMPILER;\nstruct sljit_label *loop;\nBOOL has_pre;\n\n/* At this point we can freely use all registers. */\nOP1(SLJIT_MOV, SLJIT_S2, 0, SLJIT_MEM1(SLJIT_SP), OVECTOR(1));\nOP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), OVECTOR(1), STR_PTR, 0);\n\nif (HAS_VIRTUAL_REGISTERS)\n  {\n  OP1(SLJIT_MOV, SLJIT_R0, 0, ARGUMENTS, 0);\n  OP1(SLJIT_MOV, SLJIT_S0, 0, SLJIT_MEM1(SLJIT_SP), common->start_ptr);\n  if (common->mark_ptr != 0)\n    OP1(SLJIT_MOV, SLJIT_R2, 0, SLJIT_MEM1(SLJIT_SP), common->mark_ptr);\n  OP1(SLJIT_MOV_U32, SLJIT_R1, 0, SLJIT_MEM1(SLJIT_R0), SLJIT_OFFSETOF(jit_arguments, oveccount));\n  OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_R0), SLJIT_OFFSETOF(jit_arguments, startchar_ptr), SLJIT_S0, 0);\n  if (common->mark_ptr != 0)\n    OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_R0), SLJIT_OFFSETOF(jit_arguments, mark_ptr), SLJIT_R2, 0);\n  OP2(SLJIT_ADD, SLJIT_R2, 0, SLJIT_MEM1(SLJIT_R0), SLJIT_OFFSETOF(jit_arguments, match_data),\n    SLJIT_IMM, SLJIT_OFFSETOF(pcre2_match_data, ovector) - sizeof(PCRE2_SIZE));\n  }\nelse\n  {\n  OP1(SLJIT_MOV, SLJIT_S0, 0, SLJIT_MEM1(SLJIT_SP), common->start_ptr);\n  OP1(SLJIT_MOV, SLJIT_R2, 0, SLJIT_MEM1(ARGUMENTS), SLJIT_OFFSETOF(jit_arguments, match_data));\n  if (common->mark_ptr != 0)\n    OP1(SLJIT_MOV, SLJIT_R0, 0, SLJIT_MEM1(SLJIT_SP), common->mark_ptr);\n  OP1(SLJIT_MOV_U32, SLJIT_R1, 0, SLJIT_MEM1(ARGUMENTS), SLJIT_OFFSETOF(jit_arguments, oveccount));\n  OP1(SLJIT_MOV, SLJIT_MEM1(ARGUMENTS), SLJIT_OFFSETOF(jit_arguments, startchar_ptr), SLJIT_S0, 0);\n  if (common->mark_ptr != 0)\n    OP1(SLJIT_MOV, SLJIT_MEM1(ARGUMENTS), SLJIT_OFFSETOF(jit_arguments, mark_ptr), SLJIT_R0, 0);\n  OP2(SLJIT_ADD, SLJIT_R2, 0, SLJIT_R2, 0, SLJIT_IMM, SLJIT_OFFSETOF(pcre2_match_data, ovector) - sizeof(PCRE2_SIZE));\n  }\n\nhas_pre = sljit_emit_mem(compiler, SLJIT_MOV | SLJIT_MEM_SUPP | SLJIT_MEM_PRE, SLJIT_S1, SLJIT_MEM1(SLJIT_S0), sizeof(sljit_sw)) == SLJIT_SUCCESS;\n\nGET_LOCAL_BASE(SLJIT_S0, 0, OVECTOR_START - (has_pre ? sizeof(sljit_sw) : 0));\nOP1(SLJIT_MOV, SLJIT_R0, 0, SLJIT_MEM1(HAS_VIRTUAL_REGISTERS ? SLJIT_R0 : ARGUMENTS), SLJIT_OFFSETOF(jit_arguments, begin));\n\nloop = LABEL();\n\nif (has_pre)\n  sljit_emit_mem(compiler, SLJIT_MOV | SLJIT_MEM_PRE, SLJIT_S1, SLJIT_MEM1(SLJIT_S0), sizeof(sljit_sw));\nelse\n  {\n  OP1(SLJIT_MOV, SLJIT_S1, 0, SLJIT_MEM1(SLJIT_S0), 0);\n  OP2(SLJIT_ADD, SLJIT_S0, 0, SLJIT_S0, 0, SLJIT_IMM, sizeof(sljit_sw));\n  }\n\nOP2(SLJIT_ADD, SLJIT_R2, 0, SLJIT_R2, 0, SLJIT_IMM, sizeof(PCRE2_SIZE));\nOP2(SLJIT_SUB, SLJIT_S1, 0, SLJIT_S1, 0, SLJIT_R0, 0);\n/* Copy the integer value to the output buffer */\n#if PCRE2_CODE_UNIT_WIDTH == 16 || PCRE2_CODE_UNIT_WIDTH == 32\nOP2(SLJIT_ASHR, SLJIT_S1, 0, SLJIT_S1, 0, SLJIT_IMM, UCHAR_SHIFT);\n#endif\n\nSLJIT_ASSERT(sizeof(PCRE2_SIZE) == 4 || sizeof(PCRE2_SIZE) == 8);\nOP1(((sizeof(PCRE2_SIZE) == 4) ? SLJIT_MOV_U32 : SLJIT_MOV), SLJIT_MEM1(SLJIT_R2), 0, SLJIT_S1, 0);\n\nOP2(SLJIT_SUB | SLJIT_SET_Z, SLJIT_R1, 0, SLJIT_R1, 0, SLJIT_IMM, 1);\nJUMPTO(SLJIT_NOT_ZERO, loop);\n\n/* Calculate the return value, which is the maximum ovector value. */\nif (topbracket > 1)\n  {\n  if (sljit_emit_mem(compiler, SLJIT_MOV | SLJIT_MEM_SUPP | SLJIT_MEM_PRE, SLJIT_R2, SLJIT_MEM1(SLJIT_R0), -(2 * (sljit_sw)sizeof(sljit_sw))) == SLJIT_SUCCESS)\n    {\n    GET_LOCAL_BASE(SLJIT_R0, 0, OVECTOR_START + topbracket * 2 * sizeof(sljit_sw));\n    OP1(SLJIT_MOV, SLJIT_R1, 0, SLJIT_IMM, topbracket + 1);\n\n    /* OVECTOR(0) is never equal to SLJIT_S2. */\n    loop = LABEL();\n    sljit_emit_mem(compiler, SLJIT_MOV | SLJIT_MEM_PRE, SLJIT_R2, SLJIT_MEM1(SLJIT_R0), -(2 * (sljit_sw)sizeof(sljit_sw)));\n    OP2(SLJIT_SUB, SLJIT_R1, 0, SLJIT_R1, 0, SLJIT_IMM, 1);\n    CMPTO(SLJIT_EQUAL, SLJIT_R2, 0, SLJIT_S2, 0, loop);\n    OP1(SLJIT_MOV, SLJIT_RETURN_REG, 0, SLJIT_R1, 0);\n    }\n  else\n    {\n    GET_LOCAL_BASE(SLJIT_R0, 0, OVECTOR_START + (topbracket - 1) * 2 * sizeof(sljit_sw));\n    OP1(SLJIT_MOV, SLJIT_R1, 0, SLJIT_IMM, topbracket + 1);\n\n    /* OVECTOR(0) is never equal to SLJIT_S2. */\n    loop = LABEL();\n    OP1(SLJIT_MOV, SLJIT_R2, 0, SLJIT_MEM1(SLJIT_R0), 0);\n    OP2(SLJIT_SUB, SLJIT_R0, 0, SLJIT_R0, 0, SLJIT_IMM, 2 * (sljit_sw)sizeof(sljit_sw));\n    OP2(SLJIT_SUB, SLJIT_R1, 0, SLJIT_R1, 0, SLJIT_IMM, 1);\n    CMPTO(SLJIT_EQUAL, SLJIT_R2, 0, SLJIT_S2, 0, loop);\n    OP1(SLJIT_MOV, SLJIT_RETURN_REG, 0, SLJIT_R1, 0);\n    }\n  }\nelse\n  OP1(SLJIT_MOV, SLJIT_RETURN_REG, 0, SLJIT_IMM, 1);\n}\n\nstatic SLJIT_INLINE void return_with_partial_match(compiler_common *common, struct sljit_label *quit)\n{\nDEFINE_COMPILER;\nsljit_s32 mov_opcode;\nsljit_s32 arguments_reg = !HAS_VIRTUAL_REGISTERS ? ARGUMENTS : SLJIT_R1;\n\nSLJIT_COMPILE_ASSERT(STR_END == SLJIT_S0, str_end_must_be_saved_reg0);\nSLJIT_ASSERT(common->start_used_ptr != 0 && common->start_ptr != 0\n  && (common->mode == PCRE2_JIT_PARTIAL_SOFT ? common->hit_start != 0 : common->hit_start == 0));\n\nif (arguments_reg != ARGUMENTS)\n  OP1(SLJIT_MOV, arguments_reg, 0, ARGUMENTS, 0);\nOP1(SLJIT_MOV, SLJIT_R2, 0, SLJIT_MEM1(SLJIT_SP),\n  common->mode == PCRE2_JIT_PARTIAL_SOFT ? common->hit_start : common->start_ptr);\nOP1(SLJIT_MOV, SLJIT_RETURN_REG, 0, SLJIT_IMM, PCRE2_ERROR_PARTIAL);\n\n/* Store match begin and end. */\nOP1(SLJIT_MOV, SLJIT_S1, 0, SLJIT_MEM1(arguments_reg), SLJIT_OFFSETOF(jit_arguments, begin));\nOP1(SLJIT_MOV, SLJIT_MEM1(arguments_reg), SLJIT_OFFSETOF(jit_arguments, startchar_ptr), SLJIT_R2, 0);\nOP1(SLJIT_MOV, SLJIT_R1, 0, SLJIT_MEM1(arguments_reg), SLJIT_OFFSETOF(jit_arguments, match_data));\n\nmov_opcode = (sizeof(PCRE2_SIZE) == 4) ? SLJIT_MOV_U32 : SLJIT_MOV;\n\nOP2(SLJIT_SUB, SLJIT_R2, 0, SLJIT_R2, 0, SLJIT_S1, 0);\n#if PCRE2_CODE_UNIT_WIDTH == 16 || PCRE2_CODE_UNIT_WIDTH == 32\nOP2(SLJIT_ASHR, SLJIT_R2, 0, SLJIT_R2, 0, SLJIT_IMM, UCHAR_SHIFT);\n#endif\nOP1(mov_opcode, SLJIT_MEM1(SLJIT_R1), SLJIT_OFFSETOF(pcre2_match_data, ovector), SLJIT_R2, 0);\n\nOP2(SLJIT_SUB, STR_END, 0, STR_END, 0, SLJIT_S1, 0);\n#if PCRE2_CODE_UNIT_WIDTH == 16 || PCRE2_CODE_UNIT_WIDTH == 32\nOP2(SLJIT_ASHR, STR_END, 0, STR_END, 0, SLJIT_IMM, UCHAR_SHIFT);\n#endif\nOP1(mov_opcode, SLJIT_MEM1(SLJIT_R1), SLJIT_OFFSETOF(pcre2_match_data, ovector) + sizeof(PCRE2_SIZE), STR_END, 0);\n\nJUMPTO(SLJIT_JUMP, quit);\n}\n\nstatic SLJIT_INLINE void check_start_used_ptr(compiler_common *common)\n{\n/* May destroy TMP1. */\nDEFINE_COMPILER;\nstruct sljit_jump *jump;\n\nif (common->mode == PCRE2_JIT_PARTIAL_SOFT)\n  {\n  /* The value of -1 must be kept for start_used_ptr! */\n  OP2(SLJIT_ADD, TMP1, 0, SLJIT_MEM1(SLJIT_SP), common->start_used_ptr, SLJIT_IMM, 1);\n  /* Jumps if start_used_ptr < STR_PTR, or start_used_ptr == -1. Although overwriting\n  is not necessary if start_used_ptr == STR_PTR, it does not hurt as well. */\n  jump = CMP(SLJIT_LESS_EQUAL, TMP1, 0, STR_PTR, 0);\n  OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), common->start_used_ptr, STR_PTR, 0);\n  JUMPHERE(jump);\n  }\nelse if (common->mode == PCRE2_JIT_PARTIAL_HARD)\n  {\n  jump = CMP(SLJIT_LESS_EQUAL, SLJIT_MEM1(SLJIT_SP), common->start_used_ptr, STR_PTR, 0);\n  OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), common->start_used_ptr, STR_PTR, 0);\n  JUMPHERE(jump);\n  }\n}\n\nstatic SLJIT_INLINE BOOL char_has_othercase(compiler_common *common, PCRE2_SPTR cc)\n{\n/* Detects if the character has an othercase. */\nunsigned int c;\n\n#ifdef SUPPORT_UNICODE\nif (common->utf || common->ucp)\n  {\n  if (common->utf)\n    {\n    GETCHAR(c, cc);\n    }\n  else\n    c = *cc;\n\n  if (c > 127)\n    return c != UCD_OTHERCASE(c);\n\n  return common->fcc\u00ddc\u00a8 != c;\n  }\nelse\n#endif\n  c = *cc;\nreturn MAX_255(c) ? common->fcc\u00ddc\u00a8 != c : FALSE;\n}\n\nstatic SLJIT_INLINE unsigned int char_othercase(compiler_common *common, unsigned int c)\n{\n/* Returns with the othercase. */\n#ifdef SUPPORT_UNICODE\nif ((common->utf || common->ucp) && c > 127)\n  return UCD_OTHERCASE(c);\n#endif\nreturn TABLE_GET(c, common->fcc, c);\n}\n\nstatic unsigned int char_get_othercase_bit(compiler_common *common, PCRE2_SPTR cc)\n{\n/* Detects if the character and its othercase has only 1 bit difference. */\nunsigned int c, oc, bit;\n#if defined SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH == 8\nint n;\n#endif\n\n#ifdef SUPPORT_UNICODE\nif (common->utf || common->ucp)\n  {\n  if (common->utf)\n    {\n    GETCHAR(c, cc);\n    }\n  else\n    c = *cc;\n\n  if (c <= 127)\n    oc = common->fcc\u00ddc\u00a8;\n  else\n    oc = UCD_OTHERCASE(c);\n  }\nelse\n  {\n  c = *cc;\n  oc = TABLE_GET(c, common->fcc, c);\n  }\n#else\nc = *cc;\noc = TABLE_GET(c, common->fcc, c);\n#endif\n\nSLJIT_ASSERT(c != oc);\n\nbit = c \u00ac oc;\n/* Optimized for English alphabet. */\nif (c <= 127 && bit == 0x20)\n  return (0 << 8) | 0x20;\n\n/* Since c != oc, they must have at least 1 bit difference. */\nif (!is_powerof2(bit))\n  return 0;\n\n#if PCRE2_CODE_UNIT_WIDTH == 8\n\n#ifdef SUPPORT_UNICODE\nif (common->utf && c > 127)\n  {\n  n = GET_EXTRALEN(*cc);\n  while ((bit & 0x3f) == 0)\n    {\n    n--;\n    bit >>= 6;\n    }\n  return (n << 8) | bit;\n  }\n#endif /* SUPPORT_UNICODE */\nreturn (0 << 8) | bit;\n\n#elif PCRE2_CODE_UNIT_WIDTH == 16 || PCRE2_CODE_UNIT_WIDTH == 32\n\n#ifdef SUPPORT_UNICODE\nif (common->utf && c > 65535)\n  {\n  if (bit >= (1u << 10))\n    bit >>= 10;\n  else\n    return (bit < 256) ? ((2 << 8) | bit) : ((3 << 8) | (bit >> 8));\n  }\n#endif /* SUPPORT_UNICODE */\nreturn (bit < 256) ? ((0u << 8) | bit) : ((1u << 8) | (bit >> 8));\n\n#endif /* PCRE2_CODE_UNIT_WIDTH == \u00dd8|16|32\u00a8 */\n}\n\nstatic void check_partial(compiler_common *common, BOOL force)\n{\n/* Checks whether a partial matching is occurred. Does not modify registers. */\nDEFINE_COMPILER;\nstruct sljit_jump *jump = NULL;\n\nSLJIT_ASSERT(!force || common->mode != PCRE2_JIT_COMPLETE);\n\nif (common->mode == PCRE2_JIT_COMPLETE)\n  return;\n\nif (!force && !common->allow_empty_partial)\n  jump = CMP(SLJIT_GREATER_EQUAL, SLJIT_MEM1(SLJIT_SP), common->start_used_ptr, STR_PTR, 0);\nelse if (common->mode == PCRE2_JIT_PARTIAL_SOFT)\n  jump = CMP(SLJIT_EQUAL, SLJIT_MEM1(SLJIT_SP), common->start_used_ptr, SLJIT_IMM, -1);\n\nif (common->mode == PCRE2_JIT_PARTIAL_SOFT)\n  OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), common->hit_start, SLJIT_IMM, 0);\nelse\n  {\n  if (common->partialmatchlabel != NULL)\n    JUMPTO(SLJIT_JUMP, common->partialmatchlabel);\n  else\n    add_jump(compiler, &common->partialmatch, JUMP(SLJIT_JUMP));\n  }\n\nif (jump != NULL)\n  JUMPHERE(jump);\n}\n\nstatic void check_str_end(compiler_common *common, jump_list **end_reached)\n{\n/* Does not affect registers. Usually used in a tight spot. */\nDEFINE_COMPILER;\nstruct sljit_jump *jump;\n\nif (common->mode == PCRE2_JIT_COMPLETE)\n  {\n  add_jump(compiler, end_reached, CMP(SLJIT_GREATER_EQUAL, STR_PTR, 0, STR_END, 0));\n  return;\n  }\n\njump = CMP(SLJIT_LESS, STR_PTR, 0, STR_END, 0);\nif (common->mode == PCRE2_JIT_PARTIAL_SOFT)\n  {\n  add_jump(compiler, end_reached, CMP(SLJIT_GREATER_EQUAL, SLJIT_MEM1(SLJIT_SP), common->start_used_ptr, STR_PTR, 0));\n  OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), common->hit_start, SLJIT_IMM, 0);\n  add_jump(compiler, end_reached, JUMP(SLJIT_JUMP));\n  }\nelse\n  {\n  add_jump(compiler, end_reached, CMP(SLJIT_GREATER_EQUAL, SLJIT_MEM1(SLJIT_SP), common->start_used_ptr, STR_PTR, 0));\n  if (common->partialmatchlabel != NULL)\n    JUMPTO(SLJIT_JUMP, common->partialmatchlabel);\n  else\n    add_jump(compiler, &common->partialmatch, JUMP(SLJIT_JUMP));\n  }\nJUMPHERE(jump);\n}\n\nstatic void detect_partial_match(compiler_common *common, jump_list **backtracks)\n{\nDEFINE_COMPILER;\nstruct sljit_jump *jump;\n\nif (common->mode == PCRE2_JIT_COMPLETE)\n  {\n  add_jump(compiler, backtracks, CMP(SLJIT_GREATER_EQUAL, STR_PTR, 0, STR_END, 0));\n  return;\n  }\n\n/* Partial matching mode. */\njump = CMP(SLJIT_LESS, STR_PTR, 0, STR_END, 0);\nif (!common->allow_empty_partial)\n  add_jump(compiler, backtracks, CMP(SLJIT_GREATER_EQUAL, SLJIT_MEM1(SLJIT_SP), common->start_used_ptr, STR_PTR, 0));\nelse if (common->mode == PCRE2_JIT_PARTIAL_SOFT)\n  add_jump(compiler, backtracks, CMP(SLJIT_EQUAL, SLJIT_MEM1(SLJIT_SP), common->start_used_ptr, SLJIT_IMM, -1));\n\nif (common->mode == PCRE2_JIT_PARTIAL_SOFT)\n  {\n  OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), common->hit_start, SLJIT_IMM, 0);\n  add_jump(compiler, backtracks, JUMP(SLJIT_JUMP));\n  }\nelse\n  {\n  if (common->partialmatchlabel != NULL)\n    JUMPTO(SLJIT_JUMP, common->partialmatchlabel);\n  else\n    add_jump(compiler, &common->partialmatch, JUMP(SLJIT_JUMP));\n  }\nJUMPHERE(jump);\n}\n\nstatic void process_partial_match(compiler_common *common)\n{\nDEFINE_COMPILER;\nstruct sljit_jump *jump;\n\n/* Partial matching mode. */\nif (common->mode == PCRE2_JIT_PARTIAL_SOFT)\n  {\n  jump = CMP(SLJIT_GREATER_EQUAL, SLJIT_MEM1(SLJIT_SP), common->start_used_ptr, STR_PTR, 0);\n  OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), common->hit_start, SLJIT_IMM, 0);\n  JUMPHERE(jump);\n  }\nelse if (common->mode == PCRE2_JIT_PARTIAL_HARD)\n  {\n  if (common->partialmatchlabel != NULL)\n    CMPTO(SLJIT_LESS, SLJIT_MEM1(SLJIT_SP), common->start_used_ptr, STR_PTR, 0, common->partialmatchlabel);\n  else\n    add_jump(compiler, &common->partialmatch, CMP(SLJIT_LESS, SLJIT_MEM1(SLJIT_SP), common->start_used_ptr, STR_PTR, 0));\n  }\n}\n\nstatic void detect_partial_match_to(compiler_common *common, struct sljit_label *label)\n{\nDEFINE_COMPILER;\n\nCMPTO(SLJIT_LESS, STR_PTR, 0, STR_END, 0, label);\nprocess_partial_match(common);\n}\n\nstatic void peek_char(compiler_common *common, sljit_u32 max, sljit_s32 dst, sljit_sw dstw, jump_list **backtracks)\n{\n/* Reads the character into TMP1, keeps STR_PTR.\nDoes not check STR_END. TMP2, dst, RETURN_ADDR Destroyed. */\nDEFINE_COMPILER;\n#if defined SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH != 32\nstruct sljit_jump *jump;\n#endif /* SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH != 32 */\n\nSLJIT_UNUSED_ARG(max);\nSLJIT_UNUSED_ARG(dst);\nSLJIT_UNUSED_ARG(dstw);\nSLJIT_UNUSED_ARG(backtracks);\n\nOP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(0));\n\n#ifdef SUPPORT_UNICODE\n#if PCRE2_CODE_UNIT_WIDTH == 8\nif (common->utf)\n  {\n  if (max < 128) return;\n\n  jump = CMP(SLJIT_LESS, TMP1, 0, SLJIT_IMM, 0x80);\n  OP1(SLJIT_MOV, dst, dstw, STR_PTR, 0);\n  OP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n  add_jump(compiler, common->invalid_utf ? &common->utfreadchar_invalid : &common->utfreadchar, JUMP(SLJIT_FAST_CALL));\n  OP1(SLJIT_MOV, STR_PTR, 0, dst, dstw);\n  if (backtracks && common->invalid_utf)\n    add_jump(compiler, backtracks, CMP(SLJIT_EQUAL, TMP1, 0, SLJIT_IMM, INVALID_UTF_CHAR));\n  JUMPHERE(jump);\n  }\n#elif PCRE2_CODE_UNIT_WIDTH == 16\nif (common->utf)\n  {\n  if (max < 0xd800) return;\n\n  OP2(SLJIT_SUB, TMP2, 0, TMP1, 0, SLJIT_IMM, 0xd800);\n\n  if (common->invalid_utf)\n    {\n    jump = CMP(SLJIT_GREATER_EQUAL, TMP2, 0, SLJIT_IMM, 0xe000 - 0xd800);\n    OP1(SLJIT_MOV, dst, dstw, STR_PTR, 0);\n    OP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n    add_jump(compiler, &common->utfreadchar_invalid, JUMP(SLJIT_FAST_CALL));\n    OP1(SLJIT_MOV, STR_PTR, 0, dst, dstw);\n    if (backtracks && common->invalid_utf)\n      add_jump(compiler, backtracks, CMP(SLJIT_EQUAL, TMP1, 0, SLJIT_IMM, INVALID_UTF_CHAR));\n    }\n  else\n    {\n    /* TMP2 contains the high surrogate. */\n    jump = CMP(SLJIT_GREATER_EQUAL, TMP2, 0, SLJIT_IMM, 0xdc00 - 0xd800);\n    OP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(1));\n    OP2(SLJIT_SHL, TMP2, 0, TMP2, 0, SLJIT_IMM, 10);\n    OP2(SLJIT_ADD, TMP1, 0, TMP1, 0, SLJIT_IMM, 0x10000 - 0xdc00);\n    OP2(SLJIT_ADD, TMP1, 0, TMP1, 0, TMP2, 0);\n    }\n\n  JUMPHERE(jump);\n  }\n#elif PCRE2_CODE_UNIT_WIDTH == 32\nif (common->invalid_utf)\n  {\n  if (max < 0xd800) return;\n\n  if (backtracks != NULL)\n    {\n    OP2(SLJIT_SUB, TMP2, 0, TMP1, 0, SLJIT_IMM, 0xd800);\n    add_jump(compiler, backtracks, CMP(SLJIT_GREATER_EQUAL, TMP1, 0, SLJIT_IMM, 0x110000));\n    add_jump(compiler, backtracks, CMP(SLJIT_LESS, TMP2, 0, SLJIT_IMM, 0xe000 - 0xd800));\n    }\n  else\n    {\n    OP2(SLJIT_SUB, TMP2, 0, TMP1, 0, SLJIT_IMM, 0xd800);\n    OP2(SLJIT_SUB | SLJIT_SET_GREATER_EQUAL, SLJIT_UNUSED, 0, TMP1, 0, SLJIT_IMM, 0x110000);\n    CMOV(SLJIT_GREATER_EQUAL, TMP1, SLJIT_IMM, INVALID_UTF_CHAR);\n    OP2(SLJIT_SUB | SLJIT_SET_LESS, SLJIT_UNUSED, 0, TMP2, 0, SLJIT_IMM, 0xe000 - 0xd800);\n    CMOV(SLJIT_LESS, TMP1, SLJIT_IMM, INVALID_UTF_CHAR);\n    }\n  }\n#endif /* PCRE2_CODE_UNIT_WIDTH == \u00dd8|16|32\u00a8 */\n#endif /* SUPPORT_UNICODE */\n}\n\nstatic void peek_char_back(compiler_common *common, sljit_u32 max, jump_list **backtracks)\n{\n/* Reads one character back without moving STR_PTR. TMP2 must\ncontain the start of the subject buffer. Affects TMP1, TMP2, and RETURN_ADDR. */\nDEFINE_COMPILER;\n\n#if defined SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH != 32\nstruct sljit_jump *jump;\n#endif /* SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH != 32 */\n\nSLJIT_UNUSED_ARG(max);\nSLJIT_UNUSED_ARG(backtracks);\n\nOP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(-1));\n\n#ifdef SUPPORT_UNICODE\n#if PCRE2_CODE_UNIT_WIDTH == 8\nif (common->utf)\n  {\n  if (max < 128) return;\n\n  jump = CMP(SLJIT_LESS, TMP1, 0, SLJIT_IMM, 0x80);\n  if (common->invalid_utf)\n    {\n    add_jump(compiler, &common->utfpeakcharback_invalid, JUMP(SLJIT_FAST_CALL));\n    if (backtracks != NULL)\n      add_jump(compiler, backtracks, CMP(SLJIT_EQUAL, TMP1, 0, SLJIT_IMM, INVALID_UTF_CHAR));\n    }\n  else\n    add_jump(compiler, &common->utfpeakcharback, JUMP(SLJIT_FAST_CALL));\n  JUMPHERE(jump);\n  }\n#elif PCRE2_CODE_UNIT_WIDTH == 16\nif (common->utf)\n  {\n  if (max < 0xd800) return;\n\n  if (common->invalid_utf)\n    {\n    jump = CMP(SLJIT_LESS, TMP1, 0, SLJIT_IMM, 0xd800);\n    add_jump(compiler, &common->utfpeakcharback_invalid, JUMP(SLJIT_FAST_CALL));\n    if (backtracks != NULL)\n      add_jump(compiler, backtracks, CMP(SLJIT_EQUAL, TMP1, 0, SLJIT_IMM, INVALID_UTF_CHAR));\n    }\n  else\n    {\n    OP2(SLJIT_SUB, TMP2, 0, TMP1, 0, SLJIT_IMM, 0xdc00);\n    jump = CMP(SLJIT_GREATER_EQUAL, TMP2, 0, SLJIT_IMM, 0xe000 - 0xdc00);\n    /* TMP2 contains the low surrogate. */\n    OP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(-2));\n    OP2(SLJIT_ADD, TMP2, 0, TMP2, 0, SLJIT_IMM, 0x10000);\n    OP2(SLJIT_SUB, TMP1, 0, TMP1, 0, SLJIT_IMM, 0xd800);\n    OP2(SLJIT_SHL, TMP1, 0, TMP1, 0, SLJIT_IMM, 10);\n    OP2(SLJIT_ADD, TMP1, 0, TMP1, 0, TMP2, 0);\n    }\n    JUMPHERE(jump);\n  }\n#elif PCRE2_CODE_UNIT_WIDTH == 32\nif (common->invalid_utf)\n  {\n  OP2(SLJIT_SUB, TMP2, 0, TMP1, 0, SLJIT_IMM, 0xd800);\n  add_jump(compiler, backtracks, CMP(SLJIT_GREATER_EQUAL, TMP1, 0, SLJIT_IMM, 0x110000));\n  add_jump(compiler, backtracks, CMP(SLJIT_LESS, TMP2, 0, SLJIT_IMM, 0xe000 - 0xd800));\n  }\n#endif /* PCRE2_CODE_UNIT_WIDTH == \u00dd8|16|32\u00a8 */\n#endif /* SUPPORT_UNICODE */\n}\n\n#define READ_CHAR_UPDATE_STR_PTR 0x1\n#define READ_CHAR_UTF8_NEWLINE 0x2\n#define READ_CHAR_NEWLINE (READ_CHAR_UPDATE_STR_PTR | READ_CHAR_UTF8_NEWLINE)\n#define READ_CHAR_VALID_UTF 0x4\n\nstatic void read_char(compiler_common *common, sljit_u32 min, sljit_u32 max,\n  jump_list **backtracks, sljit_u32 options)\n{\n/* Reads the precise value of a character into TMP1, if the character is\nbetween min and max (c >= min && c <= max). Otherwise it returns with a value\noutside the range. Does not check STR_END. */\nDEFINE_COMPILER;\n#if defined SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH != 32\nstruct sljit_jump *jump;\n#endif\n#if defined SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH == 8\nstruct sljit_jump *jump2;\n#endif\n\nSLJIT_UNUSED_ARG(min);\nSLJIT_UNUSED_ARG(max);\nSLJIT_UNUSED_ARG(backtracks);\nSLJIT_UNUSED_ARG(options);\nSLJIT_ASSERT(min <= max);\n\nOP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(0));\nOP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n\n#ifdef SUPPORT_UNICODE\n#if PCRE2_CODE_UNIT_WIDTH == 8\nif (common->utf)\n  {\n  if (max < 128 && !(options & READ_CHAR_UPDATE_STR_PTR)) return;\n\n  if (common->invalid_utf && !(options & READ_CHAR_VALID_UTF))\n    {\n    jump = CMP(SLJIT_LESS, TMP1, 0, SLJIT_IMM, 0x80);\n\n    if (options & READ_CHAR_UTF8_NEWLINE)\n      add_jump(compiler, &common->utfreadnewline_invalid, JUMP(SLJIT_FAST_CALL));\n    else\n      add_jump(compiler, &common->utfreadchar_invalid, JUMP(SLJIT_FAST_CALL));\n\n    if (backtracks != NULL)\n      add_jump(compiler, backtracks, CMP(SLJIT_EQUAL, TMP1, 0, SLJIT_IMM, INVALID_UTF_CHAR));\n    JUMPHERE(jump);\n    return;\n    }\n\n  jump = CMP(SLJIT_LESS, TMP1, 0, SLJIT_IMM, 0xc0);\n  if (min >= 0x10000)\n    {\n    OP2(SLJIT_SUB, TMP2, 0, TMP1, 0, SLJIT_IMM, 0xf0);\n    if (options & READ_CHAR_UPDATE_STR_PTR)\n      OP1(SLJIT_MOV_U8, RETURN_ADDR, 0, SLJIT_MEM1(TMP1), (sljit_sw)PRIV(utf8_table4) - 0xc0);\n    OP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(0));\n    jump2 = CMP(SLJIT_GREATER, TMP2, 0, SLJIT_IMM, 0x7);\n    OP2(SLJIT_SHL, TMP2, 0, TMP2, 0, SLJIT_IMM, 6);\n    OP2(SLJIT_AND, TMP1, 0, TMP1, 0, SLJIT_IMM, 0x3f);\n    OP2(SLJIT_OR, TMP1, 0, TMP1, 0, TMP2, 0);\n    OP1(MOV_UCHAR, TMP2, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(1));\n    OP2(SLJIT_SHL, TMP1, 0, TMP1, 0, SLJIT_IMM, 6);\n    OP2(SLJIT_AND, TMP2, 0, TMP2, 0, SLJIT_IMM, 0x3f);\n    OP2(SLJIT_OR, TMP1, 0, TMP1, 0, TMP2, 0);\n    OP1(MOV_UCHAR, TMP2, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(2));\n    if (!(options & READ_CHAR_UPDATE_STR_PTR))\n      OP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(3));\n    OP2(SLJIT_SHL, TMP1, 0, TMP1, 0, SLJIT_IMM, 6);\n    OP2(SLJIT_AND, TMP2, 0, TMP2, 0, SLJIT_IMM, 0x3f);\n    OP2(SLJIT_OR, TMP1, 0, TMP1, 0, TMP2, 0);\n    JUMPHERE(jump2);\n    if (options & READ_CHAR_UPDATE_STR_PTR)\n      OP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, RETURN_ADDR, 0);\n    }\n  else if (min >= 0x800 && max <= 0xffff)\n    {\n    OP2(SLJIT_SUB, TMP2, 0, TMP1, 0, SLJIT_IMM, 0xe0);\n    if (options & READ_CHAR_UPDATE_STR_PTR)\n      OP1(SLJIT_MOV_U8, RETURN_ADDR, 0, SLJIT_MEM1(TMP1), (sljit_sw)PRIV(utf8_table4) - 0xc0);\n    OP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(0));\n    jump2 = CMP(SLJIT_GREATER, TMP2, 0, SLJIT_IMM, 0xf);\n    OP2(SLJIT_SHL, TMP2, 0, TMP2, 0, SLJIT_IMM, 6);\n    OP2(SLJIT_AND, TMP1, 0, TMP1, 0, SLJIT_IMM, 0x3f);\n    OP2(SLJIT_OR, TMP1, 0, TMP1, 0, TMP2, 0);\n    OP1(MOV_UCHAR, TMP2, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(1));\n    if (!(options & READ_CHAR_UPDATE_STR_PTR))\n      OP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(2));\n    OP2(SLJIT_SHL, TMP1, 0, TMP1, 0, SLJIT_IMM, 6);\n    OP2(SLJIT_AND, TMP2, 0, TMP2, 0, SLJIT_IMM, 0x3f);\n    OP2(SLJIT_OR, TMP1, 0, TMP1, 0, TMP2, 0);\n    JUMPHERE(jump2);\n    if (options & READ_CHAR_UPDATE_STR_PTR)\n      OP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, RETURN_ADDR, 0);\n    }\n  else if (max >= 0x800)\n    {\n    add_jump(compiler, &common->utfreadchar, JUMP(SLJIT_FAST_CALL));\n    }\n  else if (max < 128)\n    {\n    OP1(SLJIT_MOV_U8, TMP2, 0, SLJIT_MEM1(TMP1), (sljit_sw)PRIV(utf8_table4) - 0xc0);\n    OP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, TMP2, 0);\n    }\n  else\n    {\n    OP1(MOV_UCHAR, TMP2, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(0));\n    if (!(options & READ_CHAR_UPDATE_STR_PTR))\n      OP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n    else\n      OP1(SLJIT_MOV_U8, RETURN_ADDR, 0, SLJIT_MEM1(TMP1), (sljit_sw)PRIV(utf8_table4) - 0xc0);\n    OP2(SLJIT_AND, TMP1, 0, TMP1, 0, SLJIT_IMM, 0x3f);\n    OP2(SLJIT_SHL, TMP1, 0, TMP1, 0, SLJIT_IMM, 6);\n    OP2(SLJIT_AND, TMP2, 0, TMP2, 0, SLJIT_IMM, 0x3f);\n    OP2(SLJIT_OR, TMP1, 0, TMP1, 0, TMP2, 0);\n    if (options & READ_CHAR_UPDATE_STR_PTR)\n      OP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, RETURN_ADDR, 0);\n    }\n  JUMPHERE(jump);\n  }\n#elif PCRE2_CODE_UNIT_WIDTH == 16\nif (common->utf)\n  {\n  if (max < 0xd800 && !(options & READ_CHAR_UPDATE_STR_PTR)) return;\n\n  if (common->invalid_utf && !(options & READ_CHAR_VALID_UTF))\n    {\n    OP2(SLJIT_SUB, TMP2, 0, TMP1, 0, SLJIT_IMM, 0xd800);\n    jump = CMP(SLJIT_GREATER_EQUAL, TMP2, 0, SLJIT_IMM, 0xe000 - 0xd800);\n\n    if (options & READ_CHAR_UTF8_NEWLINE)\n      add_jump(compiler, &common->utfreadnewline_invalid, JUMP(SLJIT_FAST_CALL));\n    else\n      add_jump(compiler, &common->utfreadchar_invalid, JUMP(SLJIT_FAST_CALL));\n\n    if (backtracks != NULL)\n      add_jump(compiler, backtracks, CMP(SLJIT_EQUAL, TMP1, 0, SLJIT_IMM, INVALID_UTF_CHAR));\n    JUMPHERE(jump);\n    return;\n    }\n\n  if (max >= 0x10000)\n    {\n    OP2(SLJIT_SUB, TMP2, 0, TMP1, 0, SLJIT_IMM, 0xd800);\n    jump = CMP(SLJIT_GREATER_EQUAL, TMP2, 0, SLJIT_IMM, 0xdc00 - 0xd800);\n    /* TMP2 contains the high surrogate. */\n    OP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(0));\n    OP2(SLJIT_SHL, TMP2, 0, TMP2, 0, SLJIT_IMM, 10);\n    OP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n    OP2(SLJIT_ADD, TMP1, 0, TMP1, 0, SLJIT_IMM, 0x10000 - 0xdc00);\n    OP2(SLJIT_ADD, TMP1, 0, TMP1, 0, TMP2, 0);\n    JUMPHERE(jump);\n    return;\n    }\n\n  /* Skip low surrogate if necessary. */\n  OP2(SLJIT_SUB, TMP2, 0, TMP1, 0, SLJIT_IMM, 0xd800);\n\n  if (sljit_has_cpu_feature(SLJIT_HAS_CMOV) && !HAS_VIRTUAL_REGISTERS)\n    {\n    if (options & READ_CHAR_UPDATE_STR_PTR)\n      OP2(SLJIT_ADD, RETURN_ADDR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n    OP2(SLJIT_SUB | SLJIT_SET_LESS, SLJIT_UNUSED, 0, TMP2, 0, SLJIT_IMM, 0x400);\n    if (options & READ_CHAR_UPDATE_STR_PTR)\n      CMOV(SLJIT_LESS, STR_PTR, RETURN_ADDR, 0);\n    if (max >= 0xd800)\n      CMOV(SLJIT_LESS, TMP1, SLJIT_IMM, 0x10000);\n    }\n  else\n    {\n    jump = CMP(SLJIT_GREATER_EQUAL, TMP2, 0, SLJIT_IMM, 0x400);\n    if (options & READ_CHAR_UPDATE_STR_PTR)\n      OP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n    if (max >= 0xd800)\n      OP1(SLJIT_MOV, TMP1, 0, SLJIT_IMM, 0x10000);\n    JUMPHERE(jump);\n    }\n  }\n#elif PCRE2_CODE_UNIT_WIDTH == 32\nif (common->invalid_utf)\n  {\n  if (backtracks != NULL)\n    {\n    OP2(SLJIT_SUB, TMP2, 0, TMP1, 0, SLJIT_IMM, 0xd800);\n    add_jump(compiler, backtracks, CMP(SLJIT_GREATER_EQUAL, TMP1, 0, SLJIT_IMM, 0x110000));\n    add_jump(compiler, backtracks, CMP(SLJIT_LESS, TMP2, 0, SLJIT_IMM, 0xe000 - 0xd800));\n    }\n  else\n    {\n    OP2(SLJIT_SUB, TMP2, 0, TMP1, 0, SLJIT_IMM, 0xd800);\n    OP2(SLJIT_SUB | SLJIT_SET_GREATER_EQUAL, SLJIT_UNUSED, 0, TMP1, 0, SLJIT_IMM, 0x110000);\n    CMOV(SLJIT_GREATER_EQUAL, TMP1, SLJIT_IMM, INVALID_UTF_CHAR);\n    OP2(SLJIT_SUB | SLJIT_SET_LESS, SLJIT_UNUSED, 0, TMP2, 0, SLJIT_IMM, 0xe000 - 0xd800);\n    CMOV(SLJIT_LESS, TMP1, SLJIT_IMM, INVALID_UTF_CHAR);\n    }\n  }\n#endif /* PCRE2_CODE_UNIT_WIDTH == \u00dd8|16|32\u00a8 */\n#endif /* SUPPORT_UNICODE */\n}\n\n#if defined SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH == 8\n\nstatic BOOL is_char7_bitset(const sljit_u8 *bitset, BOOL nclass)\n{\n/* Tells whether the character codes below 128 are enough\nto determine a match. */\nconst sljit_u8 value = nclass ? 0xff : 0;\nconst sljit_u8 *end = bitset + 32;\n\nbitset += 16;\ndo\n  {\n  if (*bitset++ != value)\n    return FALSE;\n  }\nwhile (bitset < end);\nreturn TRUE;\n}\n\nstatic void read_char7_type(compiler_common *common, jump_list **backtracks, BOOL negated)\n{\n/* Reads the precise character type of a character into TMP1, if the character\nis less than 128. Otherwise it returns with zero. Does not check STR_END. The\nfull_read argument tells whether characters above max are accepted or not. */\nDEFINE_COMPILER;\nstruct sljit_jump *jump;\n\nSLJIT_ASSERT(common->utf);\n\nOP1(MOV_UCHAR, TMP2, 0, SLJIT_MEM1(STR_PTR), 0);\nOP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n\n/* All values > 127 are zero in ctypes. */\nOP1(SLJIT_MOV_U8, TMP1, 0, SLJIT_MEM1(TMP2), common->ctypes);\n\nif (negated)\n  {\n  jump = CMP(SLJIT_LESS, TMP2, 0, SLJIT_IMM, 0x80);\n\n  if (common->invalid_utf)\n    {\n    add_jump(compiler, &common->utfreadchar_invalid, JUMP(SLJIT_FAST_CALL));\n    add_jump(compiler, backtracks, CMP(SLJIT_EQUAL, TMP1, 0, SLJIT_IMM, INVALID_UTF_CHAR));\n    OP1(SLJIT_MOV, TMP1, 0, SLJIT_IMM, 0);\n    }\n  else\n    {\n    OP1(SLJIT_MOV_U8, TMP2, 0, SLJIT_MEM1(TMP2), (sljit_sw)PRIV(utf8_table4) - 0xc0);\n    OP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, TMP2, 0);\n    }\n  JUMPHERE(jump);\n  }\n}\n\n#endif /* SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH == 8 */\n\nstatic void read_char8_type(compiler_common *common, jump_list **backtracks, BOOL negated)\n{\n/* Reads the character type into TMP1, updates STR_PTR. Does not check STR_END. */\nDEFINE_COMPILER;\n#if defined SUPPORT_UNICODE || PCRE2_CODE_UNIT_WIDTH != 8\nstruct sljit_jump *jump;\n#endif\n#if defined SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH == 8\nstruct sljit_jump *jump2;\n#endif\n\nSLJIT_UNUSED_ARG(backtracks);\nSLJIT_UNUSED_ARG(negated);\n\nOP1(MOV_UCHAR, TMP2, 0, SLJIT_MEM1(STR_PTR), 0);\nOP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n\n#if defined SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH == 8\nif (common->utf)\n  {\n  /* The result of this read may be unused, but saves an \"else\" part. */\n  OP1(SLJIT_MOV_U8, TMP1, 0, SLJIT_MEM1(TMP2), common->ctypes);\n  jump = CMP(SLJIT_LESS, TMP2, 0, SLJIT_IMM, 0x80);\n\n  if (!negated)\n    {\n    if (common->invalid_utf)\n      add_jump(compiler, backtracks, CMP(SLJIT_GREATER_EQUAL, STR_PTR, 0, STR_END, 0));\n\n    OP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(0));\n    OP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n    OP2(SLJIT_SUB, TMP2, 0, TMP2, 0, SLJIT_IMM, 0xc2);\n    if (common->invalid_utf)\n      add_jump(compiler, backtracks, CMP(SLJIT_GREATER_EQUAL, TMP2, 0, SLJIT_IMM, 0xe0 - 0xc2));\n\n    OP2(SLJIT_SHL, TMP2, 0, TMP2, 0, SLJIT_IMM, 6);\n    OP2(SLJIT_ADD, TMP2, 0, TMP2, 0, TMP1, 0);\n    OP2(SLJIT_SUB, TMP1, 0, TMP1, 0, SLJIT_IMM, 0x80);\n    if (common->invalid_utf)\n      add_jump(compiler, backtracks, CMP(SLJIT_GREATER_EQUAL, TMP2, 0, SLJIT_IMM, 0x40));\n\n    OP1(SLJIT_MOV, TMP1, 0, SLJIT_IMM, 0);\n    jump2 = CMP(SLJIT_GREATER, TMP2, 0, SLJIT_IMM, 255);\n    OP1(SLJIT_MOV_U8, TMP1, 0, SLJIT_MEM1(TMP2), common->ctypes);\n    JUMPHERE(jump2);\n    }\n  else if (common->invalid_utf)\n    {\n    add_jump(compiler, &common->utfreadchar_invalid, JUMP(SLJIT_FAST_CALL));\n    OP1(SLJIT_MOV, TMP2, 0, TMP1, 0);\n    add_jump(compiler, backtracks, CMP(SLJIT_EQUAL, TMP1, 0, SLJIT_IMM, INVALID_UTF_CHAR));\n\n    OP1(SLJIT_MOV, TMP1, 0, SLJIT_IMM, 0);\n    jump2 = CMP(SLJIT_GREATER, TMP2, 0, SLJIT_IMM, 255);\n    OP1(SLJIT_MOV_U8, TMP1, 0, SLJIT_MEM1(TMP2), common->ctypes);\n    JUMPHERE(jump2);\n    }\n  else\n    add_jump(compiler, &common->utfreadtype8, JUMP(SLJIT_FAST_CALL));\n\n  JUMPHERE(jump);\n  return;\n  }\n#endif /* SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH == 8 */\n\n#if defined SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH == 32\nif (common->invalid_utf && negated)\n  add_jump(compiler, backtracks, CMP(SLJIT_GREATER_EQUAL, TMP2, 0, SLJIT_IMM, 0x110000));\n#endif /* SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH == 32 */\n\n#if PCRE2_CODE_UNIT_WIDTH != 8\n/* The ctypes array contains only 256 values. */\nOP1(SLJIT_MOV, TMP1, 0, SLJIT_IMM, 0);\njump = CMP(SLJIT_GREATER, TMP2, 0, SLJIT_IMM, 255);\n#endif /* PCRE2_CODE_UNIT_WIDTH != 8 */\nOP1(SLJIT_MOV_U8, TMP1, 0, SLJIT_MEM1(TMP2), common->ctypes);\n#if PCRE2_CODE_UNIT_WIDTH != 8\nJUMPHERE(jump);\n#endif /* PCRE2_CODE_UNIT_WIDTH != 8 */\n\n#if defined SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH == 16\nif (common->utf && negated)\n  {\n  /* Skip low surrogate if necessary. */\n  if (!common->invalid_utf)\n    {\n    OP2(SLJIT_SUB, TMP2, 0, TMP2, 0, SLJIT_IMM, 0xd800);\n\n    if (sljit_has_cpu_feature(SLJIT_HAS_CMOV) && !HAS_VIRTUAL_REGISTERS)\n      {\n      OP2(SLJIT_ADD, RETURN_ADDR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n      OP2(SLJIT_SUB | SLJIT_SET_LESS, SLJIT_UNUSED, 0, TMP2, 0, SLJIT_IMM, 0x400);\n      CMOV(SLJIT_LESS, STR_PTR, RETURN_ADDR, 0);\n      }\n    else\n      {\n      jump = CMP(SLJIT_GREATER_EQUAL, TMP2, 0, SLJIT_IMM, 0x400);\n      OP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n      JUMPHERE(jump);\n      }\n    return;\n    }\n\n  OP2(SLJIT_SUB, TMP2, 0, TMP2, 0, SLJIT_IMM, 0xd800);\n  jump = CMP(SLJIT_GREATER_EQUAL, TMP2, 0, SLJIT_IMM, 0xe000 - 0xd800);\n  add_jump(compiler, backtracks, CMP(SLJIT_GREATER_EQUAL, TMP2, 0, SLJIT_IMM, 0x400));\n  add_jump(compiler, backtracks, CMP(SLJIT_GREATER_EQUAL, STR_PTR, 0, STR_END, 0));\n\n  OP1(MOV_UCHAR, TMP2, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(0));\n  OP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n  OP2(SLJIT_SUB, TMP2, 0, TMP2, 0, SLJIT_IMM, 0xdc00);\n  add_jump(compiler, backtracks, CMP(SLJIT_GREATER_EQUAL, TMP2, 0, SLJIT_IMM, 0x400));\n\n  JUMPHERE(jump);\n  return;\n  }\n#endif /* SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH == 16 */\n}\n\nstatic void move_back(compiler_common *common, jump_list **backtracks, BOOL must_be_valid)\n{\n/* Goes one character back. Affects STR_PTR and TMP1. If must_be_valid is TRUE,\nTMP2 is not used. Otherwise TMP2 must contain the start of the subject buffer,\nand it is destroyed. Does not modify STR_PTR for invalid character sequences. */\nDEFINE_COMPILER;\n\nSLJIT_UNUSED_ARG(backtracks);\nSLJIT_UNUSED_ARG(must_be_valid);\n\n#if defined SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH != 32\nstruct sljit_jump *jump;\n#endif\n\n#ifdef SUPPORT_UNICODE\n#if PCRE2_CODE_UNIT_WIDTH == 8\nstruct sljit_label *label;\n\nif (common->utf)\n  {\n  if (!must_be_valid && common->invalid_utf)\n    {\n    OP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(STR_PTR), -IN_UCHARS(1));\n    OP2(SLJIT_SUB, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n    jump = CMP(SLJIT_LESS, TMP1, 0, SLJIT_IMM, 0x80);\n    add_jump(compiler, &common->utfmoveback_invalid, JUMP(SLJIT_FAST_CALL));\n    if (backtracks != NULL)\n      add_jump(compiler, backtracks, CMP(SLJIT_EQUAL, TMP1, 0, SLJIT_IMM, 0));\n    JUMPHERE(jump);\n    return;\n    }\n\n  label = LABEL();\n  OP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(STR_PTR), -IN_UCHARS(1));\n  OP2(SLJIT_SUB, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n  OP2(SLJIT_AND, TMP1, 0, TMP1, 0, SLJIT_IMM, 0xc0);\n  CMPTO(SLJIT_EQUAL, TMP1, 0, SLJIT_IMM, 0x80, label);\n  return;\n  }\n#elif PCRE2_CODE_UNIT_WIDTH == 16\nif (common->utf)\n  {\n  OP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(STR_PTR), -IN_UCHARS(1));\n  OP2(SLJIT_SUB, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n\n  if (!must_be_valid && common->invalid_utf)\n    {\n    OP2(SLJIT_SUB, TMP1, 0, TMP1, 0, SLJIT_IMM, 0xd800);\n    jump = CMP(SLJIT_GREATER_EQUAL, TMP1, 0, SLJIT_IMM, 0xe000 - 0xd800);\n    add_jump(compiler, &common->utfmoveback_invalid, JUMP(SLJIT_FAST_CALL));\n    if (backtracks != NULL)\n      add_jump(compiler, backtracks, CMP(SLJIT_EQUAL, TMP1, 0, SLJIT_IMM, 0));\n    JUMPHERE(jump);\n    return;\n    }\n\n  /* Skip low surrogate if necessary. */\n  OP2(SLJIT_AND, TMP1, 0, TMP1, 0, SLJIT_IMM, 0xfc00);\n  OP2(SLJIT_SUB | SLJIT_SET_Z, SLJIT_UNUSED, 0, TMP1, 0, SLJIT_IMM, 0xdc00);\n  OP_FLAGS(SLJIT_MOV, TMP1, 0, SLJIT_EQUAL);\n  OP2(SLJIT_SHL, TMP1, 0, TMP1, 0, SLJIT_IMM, UCHAR_SHIFT);\n  OP2(SLJIT_SUB, STR_PTR, 0, STR_PTR, 0, TMP1, 0);\n  return;\n  }\n#elif PCRE2_CODE_UNIT_WIDTH == 32\nif (common->invalid_utf && !must_be_valid)\n  {\n  OP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(STR_PTR), -IN_UCHARS(1));\n  if (backtracks != NULL)\n    {\n    add_jump(compiler, backtracks, CMP(SLJIT_GREATER_EQUAL, TMP1, 0, SLJIT_IMM, 0x110000));\n    OP2(SLJIT_SUB, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n    return;\n    }\n\n  OP2(SLJIT_SUB | SLJIT_SET_LESS, SLJIT_UNUSED, 0, TMP1, 0, SLJIT_IMM, 0x110000);\n  OP_FLAGS(SLJIT_MOV, TMP1, 0, SLJIT_LESS);\n  OP2(SLJIT_SHL,  TMP1, 0, TMP1, 0, SLJIT_IMM, UCHAR_SHIFT);\n  OP2(SLJIT_SUB, STR_PTR, 0, STR_PTR, 0, TMP1, 0);\n  return;\n  }\n#endif /* PCRE2_CODE_UNIT_WIDTH == \u00dd8|16|32\u00a8 */\n#endif /* SUPPORT_UNICODE */\nOP2(SLJIT_SUB, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n}\n\nstatic void check_newlinechar(compiler_common *common, int nltype, jump_list **backtracks, BOOL jumpifmatch)\n{\n/* Character comes in TMP1. Checks if it is a newline. TMP2 may be destroyed. */\nDEFINE_COMPILER;\nstruct sljit_jump *jump;\n\nif (nltype == NLTYPE_ANY)\n  {\n  add_jump(compiler, &common->anynewline, JUMP(SLJIT_FAST_CALL));\n  sljit_set_current_flags(compiler, SLJIT_SET_Z);\n  add_jump(compiler, backtracks, JUMP(jumpifmatch ? SLJIT_NOT_ZERO : SLJIT_ZERO));\n  }\nelse if (nltype == NLTYPE_ANYCRLF)\n  {\n  if (jumpifmatch)\n    {\n    add_jump(compiler, backtracks, CMP(SLJIT_EQUAL, TMP1, 0, SLJIT_IMM, CHAR_CR));\n    add_jump(compiler, backtracks, CMP(SLJIT_EQUAL, TMP1, 0, SLJIT_IMM, CHAR_NL));\n    }\n  else\n    {\n    jump = CMP(SLJIT_EQUAL, TMP1, 0, SLJIT_IMM, CHAR_CR);\n    add_jump(compiler, backtracks, CMP(SLJIT_NOT_EQUAL, TMP1, 0, SLJIT_IMM, CHAR_NL));\n    JUMPHERE(jump);\n    }\n  }\nelse\n  {\n  SLJIT_ASSERT(nltype == NLTYPE_FIXED && common->newline < 256);\n  add_jump(compiler, backtracks, CMP(jumpifmatch ? SLJIT_EQUAL : SLJIT_NOT_EQUAL, TMP1, 0, SLJIT_IMM, common->newline));\n  }\n}\n\n#ifdef SUPPORT_UNICODE\n\n#if PCRE2_CODE_UNIT_WIDTH == 8\nstatic void do_utfreadchar(compiler_common *common)\n{\n/* Fast decoding a UTF-8 character. TMP1 contains the first byte\nof the character (>= 0xc0). Return char value in TMP1. */\nDEFINE_COMPILER;\nstruct sljit_jump *jump;\n\nsljit_emit_fast_enter(compiler, RETURN_ADDR, 0);\nOP1(MOV_UCHAR, TMP2, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(0));\nOP2(SLJIT_SHL, TMP1, 0, TMP1, 0, SLJIT_IMM, 6);\nOP2(SLJIT_AND, TMP2, 0, TMP2, 0, SLJIT_IMM, 0x3f);\nOP2(SLJIT_OR, TMP1, 0, TMP1, 0, TMP2, 0);\n\n/* Searching for the first zero. */\nOP2(SLJIT_AND | SLJIT_SET_Z, SLJIT_UNUSED, 0, TMP1, 0, SLJIT_IMM, 0x800);\njump = JUMP(SLJIT_NOT_ZERO);\n/* Two byte sequence. */\nOP2(SLJIT_XOR, TMP1, 0, TMP1, 0, SLJIT_IMM, 0x3000);\nOP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\nOP_SRC(SLJIT_FAST_RETURN, RETURN_ADDR, 0);\n\nJUMPHERE(jump);\nOP1(MOV_UCHAR, TMP2, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(1));\nOP2(SLJIT_SHL, TMP1, 0, TMP1, 0, SLJIT_IMM, 6);\nOP2(SLJIT_AND, TMP2, 0, TMP2, 0, SLJIT_IMM, 0x3f);\nOP2(SLJIT_OR, TMP1, 0, TMP1, 0, TMP2, 0);\n\nOP2(SLJIT_AND | SLJIT_SET_Z, SLJIT_UNUSED, 0, TMP1, 0, SLJIT_IMM, 0x10000);\njump = JUMP(SLJIT_NOT_ZERO);\n/* Three byte sequence. */\nOP2(SLJIT_XOR, TMP1, 0, TMP1, 0, SLJIT_IMM, 0xe0000);\nOP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(2));\nOP_SRC(SLJIT_FAST_RETURN, RETURN_ADDR, 0);\n\n/* Four byte sequence. */\nJUMPHERE(jump);\nOP1(MOV_UCHAR, TMP2, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(2));\nOP2(SLJIT_XOR, TMP1, 0, TMP1, 0, SLJIT_IMM, 0xf0000);\nOP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(3));\nOP2(SLJIT_SHL, TMP1, 0, TMP1, 0, SLJIT_IMM, 6);\nOP2(SLJIT_AND, TMP2, 0, TMP2, 0, SLJIT_IMM, 0x3f);\nOP2(SLJIT_OR, TMP1, 0, TMP1, 0, TMP2, 0);\nOP_SRC(SLJIT_FAST_RETURN, RETURN_ADDR, 0);\n}\n\nstatic void do_utfreadtype8(compiler_common *common)\n{\n/* Fast decoding a UTF-8 character type. TMP2 contains the first byte\nof the character (>= 0xc0). Return value in TMP1. */\nDEFINE_COMPILER;\nstruct sljit_jump *jump;\nstruct sljit_jump *compare;\n\nsljit_emit_fast_enter(compiler, RETURN_ADDR, 0);\n\nOP2(SLJIT_AND | SLJIT_SET_Z, SLJIT_UNUSED, 0, TMP2, 0, SLJIT_IMM, 0x20);\njump = JUMP(SLJIT_NOT_ZERO);\n/* Two byte sequence. */\nOP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(0));\nOP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\nOP2(SLJIT_AND, TMP2, 0, TMP2, 0, SLJIT_IMM, 0x1f);\n/* The upper 5 bits are known at this point. */\ncompare = CMP(SLJIT_GREATER, TMP2, 0, SLJIT_IMM, 0x3);\nOP2(SLJIT_SHL, TMP2, 0, TMP2, 0, SLJIT_IMM, 6);\nOP2(SLJIT_AND, TMP1, 0, TMP1, 0, SLJIT_IMM, 0x3f);\nOP2(SLJIT_OR, TMP2, 0, TMP2, 0, TMP1, 0);\nOP1(SLJIT_MOV_U8, TMP1, 0, SLJIT_MEM1(TMP2), common->ctypes);\nOP_SRC(SLJIT_FAST_RETURN, RETURN_ADDR, 0);\n\nJUMPHERE(compare);\nOP1(SLJIT_MOV, TMP1, 0, SLJIT_IMM, 0);\nOP_SRC(SLJIT_FAST_RETURN, RETURN_ADDR, 0);\n\n/* We only have types for characters less than 256. */\nJUMPHERE(jump);\nOP1(SLJIT_MOV_U8, TMP2, 0, SLJIT_MEM1(TMP2), (sljit_sw)PRIV(utf8_table4) - 0xc0);\nOP1(SLJIT_MOV, TMP1, 0, SLJIT_IMM, 0);\nOP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, TMP2, 0);\nOP_SRC(SLJIT_FAST_RETURN, RETURN_ADDR, 0);\n}\n\nstatic void do_utfreadchar_invalid(compiler_common *common)\n{\n/* Slow decoding a UTF-8 character. TMP1 contains the first byte\nof the character (>= 0xc0). Return char value in TMP1. STR_PTR is\nundefined for invalid characters. */\nDEFINE_COMPILER;\nsljit_s32 i;\nsljit_s32 has_cmov = sljit_has_cpu_feature(SLJIT_HAS_CMOV);\nstruct sljit_jump *jump;\nstruct sljit_jump *buffer_end_close;\nstruct sljit_label *three_byte_entry;\nstruct sljit_label *exit_invalid_label;\nstruct sljit_jump *exit_invalid\u00dd11\u00a8;\n\nsljit_emit_fast_enter(compiler, RETURN_ADDR, 0);\n\nOP2(SLJIT_SUB, TMP1, 0, TMP1, 0, SLJIT_IMM, 0xc2);\n\n/* Usually more than 3 characters remained in the subject buffer. */\nOP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(3));\n\n/* Not a valid start of a multi-byte sequence, no more bytes read. */\nexit_invalid\u00dd0\u00a8 = CMP(SLJIT_GREATER_EQUAL, TMP1, 0, SLJIT_IMM, 0xf5 - 0xc2);\n\nbuffer_end_close = CMP(SLJIT_GREATER, STR_PTR, 0, STR_END, 0);\n\nOP1(MOV_UCHAR, TMP2, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(-3));\nOP2(SLJIT_SHL, TMP1, 0, TMP1, 0, SLJIT_IMM, 6);\n/* If TMP2 is in 0x80-0xbf range, TMP1 is also increased by (0x2 << 6). */\nOP2(SLJIT_ADD, TMP1, 0, TMP1, 0, TMP2, 0);\nOP2(SLJIT_SUB, TMP2, 0, TMP2, 0, SLJIT_IMM, 0x80);\nexit_invalid\u00dd1\u00a8 = CMP(SLJIT_GREATER_EQUAL, TMP2, 0, SLJIT_IMM, 0x40);\n\nOP2(SLJIT_AND | SLJIT_SET_Z, SLJIT_UNUSED, 0, TMP1, 0, SLJIT_IMM, 0x800);\njump = JUMP(SLJIT_NOT_ZERO);\n\nOP2(SLJIT_SUB, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(2));\nOP_SRC(SLJIT_FAST_RETURN, RETURN_ADDR, 0);\n\nJUMPHERE(jump);\n\n/* Three-byte sequence. */\nOP1(MOV_UCHAR, TMP2, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(-2));\nOP2(SLJIT_SHL, TMP1, 0, TMP1, 0, SLJIT_IMM, 6);\nOP2(SLJIT_SUB, TMP2, 0, TMP2, 0, SLJIT_IMM, 0x80);\nOP2(SLJIT_OR, TMP1, 0, TMP1, 0, TMP2, 0);\nif (has_cmov)\n  {\n  OP2(SLJIT_SUB | SLJIT_SET_GREATER_EQUAL, SLJIT_UNUSED, 0, TMP2, 0, SLJIT_IMM, 0x40);\n  CMOV(SLJIT_GREATER_EQUAL, TMP1, SLJIT_IMM, 0x20000);\n  exit_invalid\u00dd2\u00a8 = NULL;\n  }\nelse\n  exit_invalid\u00dd2\u00a8 = CMP(SLJIT_GREATER_EQUAL, TMP2, 0, SLJIT_IMM, 0x40);\n\nOP2(SLJIT_AND | SLJIT_SET_Z, SLJIT_UNUSED, 0, TMP1, 0, SLJIT_IMM, 0x10000);\njump = JUMP(SLJIT_NOT_ZERO);\n\nthree_byte_entry = LABEL();\n\nOP2(SLJIT_SUB, TMP1, 0, TMP1, 0, SLJIT_IMM, 0x2d800);\nif (has_cmov)\n  {\n  OP2(SLJIT_SUB | SLJIT_SET_LESS, SLJIT_UNUSED, 0, TMP1, 0, SLJIT_IMM, 0x800);\n  CMOV(SLJIT_LESS, TMP1, SLJIT_IMM, INVALID_UTF_CHAR - 0xd800);\n  exit_invalid\u00dd3\u00a8 = NULL;\n  }\nelse\n  exit_invalid\u00dd3\u00a8 = CMP(SLJIT_LESS, TMP1, 0, SLJIT_IMM, 0x800);\nOP2(SLJIT_ADD, TMP1, 0, TMP1, 0, SLJIT_IMM, 0xd800);\nOP2(SLJIT_SUB, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n\nif (has_cmov)\n  {\n  OP2(SLJIT_SUB | SLJIT_SET_LESS, SLJIT_UNUSED, 0, TMP1, 0, SLJIT_IMM, 0x800);\n  CMOV(SLJIT_LESS, TMP1, SLJIT_IMM, INVALID_UTF_CHAR);\n  exit_invalid\u00dd4\u00a8 = NULL;\n  }\nelse\n  exit_invalid\u00dd4\u00a8 = CMP(SLJIT_LESS, TMP1, 0, SLJIT_IMM, 0x800);\nOP_SRC(SLJIT_FAST_RETURN, RETURN_ADDR, 0);\n\nJUMPHERE(jump);\n\n/* Four-byte sequence. */\nOP1(MOV_UCHAR, TMP2, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(-1));\nOP2(SLJIT_SHL, TMP1, 0, TMP1, 0, SLJIT_IMM, 6);\nOP2(SLJIT_SUB, TMP2, 0, TMP2, 0, SLJIT_IMM, 0x80);\nOP2(SLJIT_OR, TMP1, 0, TMP1, 0, TMP2, 0);\nif (has_cmov)\n  {\n  OP2(SLJIT_SUB | SLJIT_SET_GREATER_EQUAL, SLJIT_UNUSED, 0, TMP2, 0, SLJIT_IMM, 0x40);\n  CMOV(SLJIT_GREATER_EQUAL, TMP1, SLJIT_IMM, 0);\n  exit_invalid\u00dd5\u00a8 = NULL;\n  }\nelse\n  exit_invalid\u00dd5\u00a8 = CMP(SLJIT_GREATER_EQUAL, TMP2, 0, SLJIT_IMM, 0x40);\n\nOP2(SLJIT_SUB, TMP1, 0, TMP1, 0, SLJIT_IMM, 0xc10000);\nif (has_cmov)\n  {\n  OP2(SLJIT_SUB | SLJIT_SET_GREATER_EQUAL, SLJIT_UNUSED, 0, TMP1, 0, SLJIT_IMM, 0x100000);\n  CMOV(SLJIT_GREATER_EQUAL, TMP1, SLJIT_IMM, INVALID_UTF_CHAR - 0x10000);\n  exit_invalid\u00dd6\u00a8 = NULL;\n  }\nelse\n  exit_invalid\u00dd6\u00a8 = CMP(SLJIT_GREATER_EQUAL, TMP1, 0, SLJIT_IMM, 0x100000);\n\nOP2(SLJIT_ADD, TMP1, 0, TMP1, 0, SLJIT_IMM, 0x10000);\nOP_SRC(SLJIT_FAST_RETURN, RETURN_ADDR, 0);\n\nJUMPHERE(buffer_end_close);\nOP2(SLJIT_SUB, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(2));\nexit_invalid\u00dd7\u00a8 = CMP(SLJIT_GREATER, STR_PTR, 0, STR_END, 0);\n\n/* Two-byte sequence. */\nOP1(MOV_UCHAR, TMP2, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(-1));\nOP2(SLJIT_SHL, TMP1, 0, TMP1, 0, SLJIT_IMM, 6);\n/* If TMP2 is in 0x80-0xbf range, TMP1 is also increased by (0x2 << 6). */\nOP2(SLJIT_ADD, TMP1, 0, TMP1, 0, TMP2, 0);\nOP2(SLJIT_SUB, TMP2, 0, TMP2, 0, SLJIT_IMM, 0x80);\nexit_invalid\u00dd8\u00a8 = CMP(SLJIT_GREATER_EQUAL, TMP2, 0, SLJIT_IMM, 0x40);\n\nOP2(SLJIT_AND | SLJIT_SET_Z, SLJIT_UNUSED, 0, TMP1, 0, SLJIT_IMM, 0x800);\njump = JUMP(SLJIT_NOT_ZERO);\n\nOP_SRC(SLJIT_FAST_RETURN, RETURN_ADDR, 0);\n\n/* Three-byte sequence. */\nJUMPHERE(jump);\nexit_invalid\u00dd9\u00a8 = CMP(SLJIT_GREATER_EQUAL, STR_PTR, 0, STR_END, 0);\n\nOP1(MOV_UCHAR, TMP2, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(0));\nOP2(SLJIT_SHL, TMP1, 0, TMP1, 0, SLJIT_IMM, 6);\nOP2(SLJIT_SUB, TMP2, 0, TMP2, 0, SLJIT_IMM, 0x80);\nOP2(SLJIT_OR, TMP1, 0, TMP1, 0, TMP2, 0);\nif (has_cmov)\n  {\n  OP2(SLJIT_SUB | SLJIT_SET_GREATER_EQUAL, SLJIT_UNUSED, 0, TMP2, 0, SLJIT_IMM, 0x40);\n  CMOV(SLJIT_GREATER_EQUAL, TMP1, SLJIT_IMM, INVALID_UTF_CHAR);\n  exit_invalid\u00dd10\u00a8 = NULL;\n  }\nelse\n  exit_invalid\u00dd10\u00a8 = CMP(SLJIT_GREATER_EQUAL, TMP2, 0, SLJIT_IMM, 0x40);\n\n/* One will be substracted from STR_PTR later. */\nOP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(2));\n\n/* Four byte sequences are not possible. */\nCMPTO(SLJIT_LESS, TMP1, 0, SLJIT_IMM, 0x30000, three_byte_entry);\n\nexit_invalid_label = LABEL();\nfor (i = 0; i < 11; i++)\n  sljit_set_label(exit_invalid\u00ddi\u00a8, exit_invalid_label);\n\nOP1(SLJIT_MOV, TMP1, 0, SLJIT_IMM, INVALID_UTF_CHAR);\nOP_SRC(SLJIT_FAST_RETURN, RETURN_ADDR, 0);\n}\n\nstatic void do_utfreadnewline_invalid(compiler_common *common)\n{\n/* Slow decoding a UTF-8 character, specialized for newlines.\nTMP1 contains the first byte of the character (>= 0xc0). Return\nchar value in TMP1. */\nDEFINE_COMPILER;\nstruct sljit_label *loop;\nstruct sljit_label *skip_start;\nstruct sljit_label *three_byte_exit;\nstruct sljit_jump *jump\u00dd5\u00a8;\n\nsljit_emit_fast_enter(compiler, RETURN_ADDR, 0);\n\nif (common->nltype != NLTYPE_ANY)\n  {\n  SLJIT_ASSERT(common->nltype != NLTYPE_FIXED || common->newline < 128);\n\n  /* All newlines are ascii, just skip intermediate octets. */\n  jump\u00dd0\u00a8 = CMP(SLJIT_GREATER_EQUAL, STR_PTR, 0, STR_END, 0);\n  loop = LABEL();\n  OP1(MOV_UCHAR, TMP2, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(0));\n  OP2(SLJIT_AND, TMP2, 0, TMP2, 0, SLJIT_IMM, 0xc0);\n  CMPTO(SLJIT_EQUAL, TMP2, 0, SLJIT_IMM, 0x80, loop);\n  OP2(SLJIT_SUB, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n\n  JUMPHERE(jump\u00dd0\u00a8);\n\n  OP1(SLJIT_MOV, TMP1, 0, SLJIT_IMM, INVALID_UTF_CHAR);\n  OP_SRC(SLJIT_FAST_RETURN, RETURN_ADDR, 0);\n  return;\n  }\n\njump\u00dd0\u00a8 = CMP(SLJIT_GREATER_EQUAL, STR_PTR, 0, STR_END, 0);\nOP1(MOV_UCHAR, TMP2, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(0));\nOP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n\njump\u00dd1\u00a8 = CMP(SLJIT_EQUAL, TMP1, 0, SLJIT_IMM, 0xc2);\njump\u00dd2\u00a8 = CMP(SLJIT_EQUAL, TMP1, 0, SLJIT_IMM, 0xe2);\n\nskip_start = LABEL();\nOP2(SLJIT_AND, TMP2, 0, TMP2, 0, SLJIT_IMM, 0xc0);\njump\u00dd3\u00a8 = CMP(SLJIT_NOT_EQUAL, TMP2, 0, SLJIT_IMM, 0x80);\n\n/* Skip intermediate octets. */\nloop = LABEL();\njump\u00dd4\u00a8 = CMP(SLJIT_GREATER_EQUAL, STR_PTR, 0, STR_END, 0);\nOP1(MOV_UCHAR, TMP2, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(0));\nOP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\nOP2(SLJIT_AND, TMP2, 0, TMP2, 0, SLJIT_IMM, 0xc0);\nCMPTO(SLJIT_EQUAL, TMP2, 0, SLJIT_IMM, 0x80, loop);\n\nJUMPHERE(jump\u00dd3\u00a8);\nOP2(SLJIT_SUB, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n\nthree_byte_exit = LABEL();\nJUMPHERE(jump\u00dd0\u00a8);\nJUMPHERE(jump\u00dd4\u00a8);\n\nOP1(SLJIT_MOV, TMP1, 0, SLJIT_IMM, INVALID_UTF_CHAR);\nOP_SRC(SLJIT_FAST_RETURN, RETURN_ADDR, 0);\n\n/* Two byte long newline: 0x85. */\nJUMPHERE(jump\u00dd1\u00a8);\nCMPTO(SLJIT_NOT_EQUAL, TMP2, 0, SLJIT_IMM, 0x85, skip_start);\n\nOP1(SLJIT_MOV, TMP1, 0, SLJIT_IMM, 0x85);\nOP_SRC(SLJIT_FAST_RETURN, RETURN_ADDR, 0);\n\n/* Three byte long newlines: 0x2028 and 0x2029. */\nJUMPHERE(jump\u00dd2\u00a8);\nCMPTO(SLJIT_NOT_EQUAL, TMP2, 0, SLJIT_IMM, 0x80, skip_start);\nCMPTO(SLJIT_GREATER_EQUAL, STR_PTR, 0, STR_END, 0, three_byte_exit);\n\nOP1(MOV_UCHAR, TMP2, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(0));\nOP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n\nOP2(SLJIT_SUB, TMP1, 0, TMP2, 0, SLJIT_IMM, 0x80);\nCMPTO(SLJIT_GREATER_EQUAL, TMP1, 0, SLJIT_IMM, 0x40, skip_start);\n\nOP1(SLJIT_MOV, TMP2, 0, SLJIT_IMM, 0x2000);\nOP2(SLJIT_OR, TMP1, 0, TMP1, 0, TMP2, 0);\nOP_SRC(SLJIT_FAST_RETURN, RETURN_ADDR, 0);\n}\n\nstatic void do_utfmoveback_invalid(compiler_common *common)\n{\n/* Goes one character back. */\nDEFINE_COMPILER;\nsljit_s32 i;\nstruct sljit_jump *jump;\nstruct sljit_jump *buffer_start_close;\nstruct sljit_label *exit_ok_label;\nstruct sljit_label *exit_invalid_label;\nstruct sljit_jump *exit_invalid\u00dd7\u00a8;\n\nsljit_emit_fast_enter(compiler, RETURN_ADDR, 0);\n\nOP2(SLJIT_SUB, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(3));\nexit_invalid\u00dd0\u00a8 = CMP(SLJIT_GREATER_EQUAL, TMP1, 0, SLJIT_IMM, 0xc0);\n\n/* Two-byte sequence. */\nbuffer_start_close = CMP(SLJIT_LESS, STR_PTR, 0, TMP2, 0);\n\nOP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(2));\n\nOP2(SLJIT_SUB, TMP1, 0, TMP1, 0, SLJIT_IMM, 0xc0);\njump = CMP(SLJIT_GREATER_EQUAL, TMP1, 0, SLJIT_IMM, 0x20);\n\nOP1(SLJIT_MOV, TMP1, 0, SLJIT_IMM, 1);\nOP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(2));\nOP_SRC(SLJIT_FAST_RETURN, RETURN_ADDR, 0);\n\n/* Three-byte sequence. */\nJUMPHERE(jump);\nexit_invalid\u00dd1\u00a8 = CMP(SLJIT_LESS, TMP1, 0, SLJIT_IMM, -0x40);\n\nOP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(1));\n\nOP2(SLJIT_SUB, TMP1, 0, TMP1, 0, SLJIT_IMM, 0xe0);\njump = CMP(SLJIT_GREATER_EQUAL, TMP1, 0, SLJIT_IMM, 0x10);\n\nOP1(SLJIT_MOV, TMP1, 0, SLJIT_IMM, 1);\nOP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\nOP_SRC(SLJIT_FAST_RETURN, RETURN_ADDR, 0);\n\n/* Four-byte sequence. */\nJUMPHERE(jump);\nOP2(SLJIT_ADD, TMP1, 0, TMP1, 0, SLJIT_IMM, 0xe0 - 0x80);\nexit_invalid\u00dd2\u00a8 = CMP(SLJIT_GREATER_EQUAL, TMP1, 0, SLJIT_IMM, 0x40);\n\nOP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(0));\nOP2(SLJIT_SUB, TMP1, 0, TMP1, 0, SLJIT_IMM, 0xf0);\nexit_invalid\u00dd3\u00a8 = CMP(SLJIT_GREATER_EQUAL, TMP1, 0, SLJIT_IMM, 0x05);\n\nexit_ok_label = LABEL();\nOP1(SLJIT_MOV, TMP1, 0, SLJIT_IMM, 1);\nOP_SRC(SLJIT_FAST_RETURN, RETURN_ADDR, 0);\n\n/* Two-byte sequence. */\nJUMPHERE(buffer_start_close);\nOP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(2));\n\nexit_invalid\u00dd4\u00a8 = CMP(SLJIT_LESS, STR_PTR, 0, TMP2, 0);\n\nOP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(0));\n\nOP2(SLJIT_SUB, TMP1, 0, TMP1, 0, SLJIT_IMM, 0xc0);\nCMPTO(SLJIT_LESS, TMP1, 0, SLJIT_IMM, 0x20, exit_ok_label);\n\n/* Three-byte sequence. */\nOP2(SLJIT_SUB, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\nexit_invalid\u00dd5\u00a8 = CMP(SLJIT_LESS, TMP1, 0, SLJIT_IMM, -0x40);\nexit_invalid\u00dd6\u00a8 = CMP(SLJIT_LESS, STR_PTR, 0, TMP2, 0);\n\nOP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(0));\n\nOP2(SLJIT_SUB, TMP1, 0, TMP1, 0, SLJIT_IMM, 0xe0);\nCMPTO(SLJIT_LESS, TMP1, 0, SLJIT_IMM, 0x10, exit_ok_label);\n\n/* Four-byte sequences are not possible. */\n\nexit_invalid_label = LABEL();\nsljit_set_label(exit_invalid\u00dd5\u00a8, exit_invalid_label);\nsljit_set_label(exit_invalid\u00dd6\u00a8, exit_invalid_label);\nOP1(SLJIT_MOV, TMP1, 0, SLJIT_IMM, 0);\nOP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(3));\nOP_SRC(SLJIT_FAST_RETURN, RETURN_ADDR, 0);\n\nJUMPHERE(exit_invalid\u00dd4\u00a8);\n/* -2 + 4 = 2 */\nOP2(SLJIT_SUB, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(2));\n\nexit_invalid_label = LABEL();\nfor (i = 0; i < 4; i++)\n  sljit_set_label(exit_invalid\u00ddi\u00a8, exit_invalid_label);\nOP1(SLJIT_MOV, TMP1, 0, SLJIT_IMM, 0);\nOP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(4));\nOP_SRC(SLJIT_FAST_RETURN, RETURN_ADDR, 0);\n}\n\nstatic void do_utfpeakcharback(compiler_common *common)\n{\n/* Peak a character back. Does not modify STR_PTR. */\nDEFINE_COMPILER;\nstruct sljit_jump *jump\u00dd2\u00a8;\n\nsljit_emit_fast_enter(compiler, RETURN_ADDR, 0);\n\nOP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(-2));\nOP2(SLJIT_SUB, TMP1, 0, TMP1, 0, SLJIT_IMM, 0xc0);\njump\u00dd0\u00a8 = CMP(SLJIT_LESS, TMP1, 0, SLJIT_IMM, 0x20);\n\nOP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(-3));\nOP2(SLJIT_SUB, TMP1, 0, TMP1, 0, SLJIT_IMM, 0xe0);\njump\u00dd1\u00a8 = CMP(SLJIT_LESS, TMP1, 0, SLJIT_IMM, 0x10);\n\nOP1(MOV_UCHAR, TMP2, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(-4));\nOP2(SLJIT_ADD, TMP1, 0, TMP1, 0, SLJIT_IMM, 0xe0 - 0x80);\nOP2(SLJIT_SUB, TMP2, 0, TMP2, 0, SLJIT_IMM, 0xf0);\nOP2(SLJIT_SHL, TMP2, 0, TMP2, 0, SLJIT_IMM, 6);\nOP2(SLJIT_OR, TMP1, 0, TMP1, 0, TMP2, 0);\n\nJUMPHERE(jump\u00dd1\u00a8);\nOP1(MOV_UCHAR, TMP2, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(-2));\nOP2(SLJIT_SHL, TMP1, 0, TMP1, 0, SLJIT_IMM, 6);\nOP2(SLJIT_SUB, TMP2, 0, TMP2, 0, SLJIT_IMM, 0x80);\nOP2(SLJIT_OR, TMP1, 0, TMP1, 0, TMP2, 0);\n\nJUMPHERE(jump\u00dd0\u00a8);\nOP1(MOV_UCHAR, TMP2, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(-1));\nOP2(SLJIT_SHL, TMP1, 0, TMP1, 0, SLJIT_IMM, 6);\nOP2(SLJIT_SUB, TMP2, 0, TMP2, 0, SLJIT_IMM, 0x80);\nOP2(SLJIT_OR, TMP1, 0, TMP1, 0, TMP2, 0);\n\nOP_SRC(SLJIT_FAST_RETURN, RETURN_ADDR, 0);\n}\n\nstatic void do_utfpeakcharback_invalid(compiler_common *common)\n{\n/* Peak a character back. Does not modify STR_PTR. */\nDEFINE_COMPILER;\nsljit_s32 i;\nsljit_s32 has_cmov = sljit_has_cpu_feature(SLJIT_HAS_CMOV);\nstruct sljit_jump *jump\u00dd2\u00a8;\nstruct sljit_label *two_byte_entry;\nstruct sljit_label *three_byte_entry;\nstruct sljit_label *exit_invalid_label;\nstruct sljit_jump *exit_invalid\u00dd8\u00a8;\n\nsljit_emit_fast_enter(compiler, RETURN_ADDR, 0);\n\nOP2(SLJIT_ADD, TMP2, 0, TMP2, 0, SLJIT_IMM, IN_UCHARS(3));\nexit_invalid\u00dd0\u00a8 = CMP(SLJIT_GREATER_EQUAL, TMP1, 0, SLJIT_IMM, 0xc0);\njump\u00dd0\u00a8 = CMP(SLJIT_GREATER_EQUAL, TMP2, 0, STR_PTR, 0);\n\n/* Two-byte sequence. */\nOP1(MOV_UCHAR, TMP2, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(-2));\nOP2(SLJIT_SUB, TMP2, 0, TMP2, 0, SLJIT_IMM, 0xc2);\njump\u00dd1\u00a8 = CMP(SLJIT_GREATER_EQUAL, TMP2, 0, SLJIT_IMM, 0x1e);\n\ntwo_byte_entry = LABEL();\nOP2(SLJIT_SHL, TMP2, 0, TMP2, 0, SLJIT_IMM, 6);\n/* If TMP1 is in 0x80-0xbf range, TMP1 is also increased by (0x2 << 6). */\nOP2(SLJIT_ADD, TMP1, 0, TMP1, 0, TMP2, 0);\nOP_SRC(SLJIT_FAST_RETURN, RETURN_ADDR, 0);\n\nJUMPHERE(jump\u00dd1\u00a8);\nOP2(SLJIT_ADD, TMP2, 0, TMP2, 0, SLJIT_IMM, 0xc2 - 0x80);\nOP2(SLJIT_SUB, TMP1, 0, TMP1, 0, SLJIT_IMM, 0x80);\nexit_invalid\u00dd1\u00a8 = CMP(SLJIT_GREATER_EQUAL, TMP2, 0, SLJIT_IMM, 0x40);\nOP2(SLJIT_SHL, TMP2, 0, TMP2, 0, SLJIT_IMM, 6);\nOP2(SLJIT_OR, TMP1, 0, TMP1, 0, TMP2, 0);\n\n/* Three-byte sequence. */\nOP1(MOV_UCHAR, TMP2, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(-3));\nOP2(SLJIT_SUB, TMP2, 0, TMP2, 0, SLJIT_IMM, 0xe0);\njump\u00dd1\u00a8 = CMP(SLJIT_GREATER_EQUAL, TMP2, 0, SLJIT_IMM, 0x10);\n\nthree_byte_entry = LABEL();\nOP2(SLJIT_SHL, TMP2, 0, TMP2, 0, SLJIT_IMM, 12);\nOP2(SLJIT_OR, TMP1, 0, TMP1, 0, TMP2, 0);\n\nOP2(SLJIT_SUB, TMP1, 0, TMP1, 0, SLJIT_IMM, 0xd800);\nif (has_cmov)\n  {\n  OP2(SLJIT_SUB | SLJIT_SET_LESS, SLJIT_UNUSED, 0, TMP1, 0, SLJIT_IMM, 0x800);\n  CMOV(SLJIT_LESS, TMP1, SLJIT_IMM, -0xd800);\n  exit_invalid\u00dd2\u00a8 = NULL;\n  }\nelse\n  exit_invalid\u00dd2\u00a8 = CMP(SLJIT_LESS, TMP1, 0, SLJIT_IMM, 0x800);\n\nOP2(SLJIT_ADD, TMP1, 0, TMP1, 0, SLJIT_IMM, 0xd800);\nif (has_cmov)\n  {\n  OP2(SLJIT_SUB | SLJIT_SET_LESS, SLJIT_UNUSED, 0, TMP1, 0, SLJIT_IMM, 0x800);\n  CMOV(SLJIT_LESS, TMP1, SLJIT_IMM, INVALID_UTF_CHAR);\n  exit_invalid\u00dd3\u00a8 = NULL;\n  }\nelse\n  exit_invalid\u00dd3\u00a8 = CMP(SLJIT_LESS, TMP1, 0, SLJIT_IMM, 0x800);\n\nOP_SRC(SLJIT_FAST_RETURN, RETURN_ADDR, 0);\n\nJUMPHERE(jump\u00dd1\u00a8);\nOP2(SLJIT_ADD, TMP2, 0, TMP2, 0, SLJIT_IMM, 0xe0 - 0x80);\nexit_invalid\u00dd4\u00a8 = CMP(SLJIT_GREATER_EQUAL, TMP2, 0, SLJIT_IMM, 0x40);\nOP2(SLJIT_SHL, TMP2, 0, TMP2, 0, SLJIT_IMM, 12);\nOP2(SLJIT_OR, TMP1, 0, TMP1, 0, TMP2, 0);\n\n/* Four-byte sequence. */\nOP1(MOV_UCHAR, TMP2, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(-4));\nOP2(SLJIT_SUB, TMP1, 0, TMP1, 0, SLJIT_IMM, 0x10000);\nOP2(SLJIT_SUB, TMP2, 0, TMP2, 0, SLJIT_IMM, 0xf0);\nOP2(SLJIT_SHL, TMP2, 0, TMP2, 0, SLJIT_IMM, 18);\n/* ADD is used instead of OR because of the SUB 0x10000 above. */\nOP2(SLJIT_ADD, TMP1, 0, TMP1, 0, TMP2, 0);\n\nif (has_cmov)\n  {\n  OP2(SLJIT_SUB | SLJIT_SET_GREATER_EQUAL, SLJIT_UNUSED, 0, TMP1, 0, SLJIT_IMM, 0x100000);\n  CMOV(SLJIT_GREATER_EQUAL, TMP1, SLJIT_IMM, INVALID_UTF_CHAR - 0x10000);\n  exit_invalid\u00dd5\u00a8 = NULL;\n  }\nelse\n  exit_invalid\u00dd5\u00a8 = CMP(SLJIT_GREATER_EQUAL, TMP1, 0, SLJIT_IMM, 0x100000);\n\nOP2(SLJIT_ADD, TMP1, 0, TMP1, 0, SLJIT_IMM, 0x10000);\nOP_SRC(SLJIT_FAST_RETURN, RETURN_ADDR, 0);\n\nJUMPHERE(jump\u00dd0\u00a8);\nOP2(SLJIT_SUB, TMP2, 0, TMP2, 0, SLJIT_IMM, IN_UCHARS(1));\njump\u00dd0\u00a8 = CMP(SLJIT_GREATER_EQUAL, TMP2, 0, STR_PTR, 0);\n\n/* Two-byte sequence. */\nOP1(MOV_UCHAR, TMP2, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(-2));\nOP2(SLJIT_SUB, TMP2, 0, TMP2, 0, SLJIT_IMM, 0xc2);\nCMPTO(SLJIT_LESS, TMP2, 0, SLJIT_IMM, 0x1e, two_byte_entry);\n\nOP2(SLJIT_ADD, TMP2, 0, TMP2, 0, SLJIT_IMM, 0xc2 - 0x80);\nOP2(SLJIT_SUB, TMP1, 0, TMP1, 0, SLJIT_IMM, 0x80);\nexit_invalid\u00dd6\u00a8 = CMP(SLJIT_GREATER_EQUAL, TMP2, 0, SLJIT_IMM, 0x40);\nOP2(SLJIT_SHL, TMP2, 0, TMP2, 0, SLJIT_IMM, 6);\nOP2(SLJIT_OR, TMP1, 0, TMP1, 0, TMP2, 0);\n\n/* Three-byte sequence. */\nOP1(MOV_UCHAR, TMP2, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(-3));\nOP2(SLJIT_SUB, TMP2, 0, TMP2, 0, SLJIT_IMM, 0xe0);\nCMPTO(SLJIT_LESS, TMP2, 0, SLJIT_IMM, 0x10, three_byte_entry);\n\nOP1(SLJIT_MOV, TMP1, 0, SLJIT_IMM, INVALID_UTF_CHAR);\nOP_SRC(SLJIT_FAST_RETURN, RETURN_ADDR, 0);\n\nJUMPHERE(jump\u00dd0\u00a8);\nexit_invalid\u00dd7\u00a8 = CMP(SLJIT_GREATER, TMP2, 0, STR_PTR, 0);\n\n/* Two-byte sequence. */\nOP1(MOV_UCHAR, TMP2, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(-2));\nOP2(SLJIT_SUB, TMP2, 0, TMP2, 0, SLJIT_IMM, 0xc2);\nCMPTO(SLJIT_LESS, TMP2, 0, SLJIT_IMM, 0x1e, two_byte_entry);\n\nexit_invalid_label = LABEL();\nfor (i = 0; i < 8; i++)\n  sljit_set_label(exit_invalid\u00ddi\u00a8, exit_invalid_label);\n\nOP1(SLJIT_MOV, TMP1, 0, SLJIT_IMM, INVALID_UTF_CHAR);\nOP_SRC(SLJIT_FAST_RETURN, RETURN_ADDR, 0);\n}\n\n#endif /* PCRE2_CODE_UNIT_WIDTH == 8 */\n\n#if PCRE2_CODE_UNIT_WIDTH == 16\n\nstatic void do_utfreadchar_invalid(compiler_common *common)\n{\n/* Slow decoding a UTF-16 character. TMP1 contains the first half\nof the character (>= 0xd800). Return char value in TMP1. STR_PTR is\nundefined for invalid characters. */\nDEFINE_COMPILER;\nstruct sljit_jump *exit_invalid\u00dd3\u00a8;\n\nsljit_emit_fast_enter(compiler, RETURN_ADDR, 0);\n\n/* TMP2 contains the high surrogate. */\nexit_invalid\u00dd0\u00a8 = CMP(SLJIT_GREATER_EQUAL, TMP1, 0, SLJIT_IMM, 0xdc00);\nexit_invalid\u00dd1\u00a8 = CMP(SLJIT_GREATER_EQUAL, STR_PTR, 0, STR_END, 0);\n\nOP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(0));\nOP2(SLJIT_SHL, TMP2, 0, TMP2, 0, SLJIT_IMM, 10);\nOP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n\nOP2(SLJIT_SUB, TMP1, 0, TMP1, 0, SLJIT_IMM, 0xdc00);\nOP2(SLJIT_ADD, TMP2, 0, TMP2, 0, SLJIT_IMM, 0x10000);\nexit_invalid\u00dd2\u00a8 = CMP(SLJIT_GREATER_EQUAL, TMP1, 0, SLJIT_IMM, 0x400);\n\nOP2(SLJIT_ADD, TMP1, 0, TMP1, 0, TMP2, 0);\nOP_SRC(SLJIT_FAST_RETURN, RETURN_ADDR, 0);\n\nJUMPHERE(exit_invalid\u00dd0\u00a8);\nJUMPHERE(exit_invalid\u00dd1\u00a8);\nJUMPHERE(exit_invalid\u00dd2\u00a8);\nOP1(SLJIT_MOV, TMP1, 0, SLJIT_IMM, INVALID_UTF_CHAR);\nOP_SRC(SLJIT_FAST_RETURN, RETURN_ADDR, 0);\n}\n\nstatic void do_utfreadnewline_invalid(compiler_common *common)\n{\n/* Slow decoding a UTF-16 character, specialized for newlines.\nTMP1 contains the first half of the character (>= 0xd800). Return\nchar value in TMP1. */\n\nDEFINE_COMPILER;\nstruct sljit_jump *exit_invalid\u00dd2\u00a8;\n\nsljit_emit_fast_enter(compiler, RETURN_ADDR, 0);\n\n/* TMP2 contains the high surrogate. */\nexit_invalid\u00dd0\u00a8 = CMP(SLJIT_GREATER_EQUAL, STR_PTR, 0, STR_END, 0);\n\nOP1(MOV_UCHAR, TMP2, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(0));\nexit_invalid\u00dd1\u00a8 = CMP(SLJIT_GREATER_EQUAL, TMP1, 0, SLJIT_IMM, 0xdc00);\n\nOP2(SLJIT_SUB, TMP2, 0, TMP2, 0, SLJIT_IMM, 0xdc00);\nOP2(SLJIT_SUB | SLJIT_SET_LESS, SLJIT_UNUSED, 0, TMP2, 0, SLJIT_IMM, 0x400);\nOP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_LESS);\nOP1(SLJIT_MOV, TMP1, 0, SLJIT_IMM, 0x10000);\nOP2(SLJIT_SHL, TMP2, 0, TMP2, 0, SLJIT_IMM, UCHAR_SHIFT);\nOP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, TMP2, 0);\n\nOP_SRC(SLJIT_FAST_RETURN, RETURN_ADDR, 0);\n\nJUMPHERE(exit_invalid\u00dd0\u00a8);\nJUMPHERE(exit_invalid\u00dd1\u00a8);\nOP1(SLJIT_MOV, TMP1, 0, SLJIT_IMM, INVALID_UTF_CHAR);\nOP_SRC(SLJIT_FAST_RETURN, RETURN_ADDR, 0);\n}\n\nstatic void do_utfmoveback_invalid(compiler_common *common)\n{\n/* Goes one character back. */\nDEFINE_COMPILER;\nstruct sljit_jump *exit_invalid\u00dd3\u00a8;\n\nsljit_emit_fast_enter(compiler, RETURN_ADDR, 0);\n\nexit_invalid\u00dd0\u00a8 = CMP(SLJIT_LESS, TMP1, 0, SLJIT_IMM, 0x400);\nexit_invalid\u00dd1\u00a8 = CMP(SLJIT_GREATER_EQUAL, TMP2, 0, STR_PTR, 0);\n\nOP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(-1));\nOP2(SLJIT_SUB, TMP1, 0, TMP1, 0, SLJIT_IMM, 0xd800);\nexit_invalid\u00dd2\u00a8 = CMP(SLJIT_GREATER_EQUAL, TMP1, 0, SLJIT_IMM, 0x400);\n\nOP2(SLJIT_SUB, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\nOP1(SLJIT_MOV, TMP1, 0, SLJIT_IMM, 1);\nOP_SRC(SLJIT_FAST_RETURN, RETURN_ADDR, 0);\n\nJUMPHERE(exit_invalid\u00dd0\u00a8);\nJUMPHERE(exit_invalid\u00dd1\u00a8);\nJUMPHERE(exit_invalid\u00dd2\u00a8);\n\nOP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\nOP1(SLJIT_MOV, TMP1, 0, SLJIT_IMM, 0);\nOP_SRC(SLJIT_FAST_RETURN, RETURN_ADDR, 0);\n}\n\nstatic void do_utfpeakcharback_invalid(compiler_common *common)\n{\n/* Peak a character back. Does not modify STR_PTR. */\nDEFINE_COMPILER;\nstruct sljit_jump *jump;\nstruct sljit_jump *exit_invalid\u00dd3\u00a8;\n\nsljit_emit_fast_enter(compiler, RETURN_ADDR, 0);\n\njump = CMP(SLJIT_GREATER_EQUAL, TMP1, 0, SLJIT_IMM, 0xe000);\nOP2(SLJIT_ADD, TMP2, 0, TMP2, 0, SLJIT_IMM, IN_UCHARS(1));\nexit_invalid\u00dd0\u00a8 = CMP(SLJIT_LESS, TMP1, 0, SLJIT_IMM, 0xdc00);\nexit_invalid\u00dd1\u00a8 = CMP(SLJIT_GREATER_EQUAL, TMP2, 0, STR_PTR, 0);\n\nOP1(MOV_UCHAR, TMP2, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(-2));\nOP2(SLJIT_ADD, TMP1, 0, TMP1, 0, SLJIT_IMM, 0x10000 - 0xdc00);\nOP2(SLJIT_SUB, TMP2, 0, TMP2, 0, SLJIT_IMM, 0xd800);\nexit_invalid\u00dd2\u00a8 = CMP(SLJIT_GREATER_EQUAL, TMP2, 0, SLJIT_IMM, 0x400);\nOP2(SLJIT_SHL, TMP2, 0, TMP2, 0, SLJIT_IMM, 10);\nOP2(SLJIT_ADD, TMP1, 0, TMP1, 0, TMP2, 0);\n\nJUMPHERE(jump);\nOP_SRC(SLJIT_FAST_RETURN, RETURN_ADDR, 0);\n\nJUMPHERE(exit_invalid\u00dd0\u00a8);\nJUMPHERE(exit_invalid\u00dd1\u00a8);\nJUMPHERE(exit_invalid\u00dd2\u00a8);\n\nOP1(SLJIT_MOV, TMP1, 0, SLJIT_IMM, INVALID_UTF_CHAR);\nOP_SRC(SLJIT_FAST_RETURN, RETURN_ADDR, 0);\n}\n\n#endif /* PCRE2_CODE_UNIT_WIDTH == 16 */\n\n/* UCD_BLOCK_SIZE must be 128 (see the assert below). */\n#define UCD_BLOCK_MASK 127\n#define UCD_BLOCK_SHIFT 7\n\nstatic void do_getucd(compiler_common *common)\n{\n/* Search the UCD record for the character comes in TMP1.\nReturns chartype in TMP1 and UCD offset in TMP2. */\nDEFINE_COMPILER;\n#if PCRE2_CODE_UNIT_WIDTH == 32\nstruct sljit_jump *jump;\n#endif\n\n#if defined SLJIT_DEBUG && SLJIT_DEBUG\n/* dummy_ucd_record */\nconst ucd_record *record = GET_UCD(UNASSIGNED_UTF_CHAR);\nSLJIT_ASSERT(record->script == ucp_Unknown && record->chartype == ucp_Cn && record->gbprop == ucp_gbOther);\nSLJIT_ASSERT(record->caseset == 0 && record->other_case == 0);\n#endif\n\nSLJIT_ASSERT(UCD_BLOCK_SIZE == 128 && sizeof(ucd_record) == 12);\n\nsljit_emit_fast_enter(compiler, RETURN_ADDR, 0);\n\n#if PCRE2_CODE_UNIT_WIDTH == 32\nif (!common->utf)\n  {\n  jump = CMP(SLJIT_LESS, TMP1, 0, SLJIT_IMM, MAX_UTF_CODE_POINT + 1);\n  OP1(SLJIT_MOV, TMP1, 0, SLJIT_IMM, UNASSIGNED_UTF_CHAR);\n  JUMPHERE(jump);\n  }\n#endif\n\nOP2(SLJIT_LSHR, TMP2, 0, TMP1, 0, SLJIT_IMM, UCD_BLOCK_SHIFT);\nOP2(SLJIT_SHL, TMP2, 0, TMP2, 0, SLJIT_IMM, 1);\nOP1(SLJIT_MOV_U16, TMP2, 0, SLJIT_MEM1(TMP2), (sljit_sw)PRIV(ucd_stage1));\nOP2(SLJIT_AND, TMP1, 0, TMP1, 0, SLJIT_IMM, UCD_BLOCK_MASK);\nOP2(SLJIT_SHL, TMP2, 0, TMP2, 0, SLJIT_IMM, UCD_BLOCK_SHIFT);\nOP2(SLJIT_ADD, TMP1, 0, TMP1, 0, TMP2, 0);\nOP1(SLJIT_MOV, TMP2, 0, SLJIT_IMM, (sljit_sw)PRIV(ucd_stage2));\nOP1(SLJIT_MOV_U16, TMP2, 0, SLJIT_MEM2(TMP2, TMP1), 1);\nOP_SRC(SLJIT_FAST_RETURN, RETURN_ADDR, 0);\n}\n\nstatic void do_getucdtype(compiler_common *common)\n{\n/* Search the UCD record for the character comes in TMP1.\nReturns chartype in TMP1 and UCD offset in TMP2. */\nDEFINE_COMPILER;\n#if PCRE2_CODE_UNIT_WIDTH == 32\nstruct sljit_jump *jump;\n#endif\n\n#if defined SLJIT_DEBUG && SLJIT_DEBUG\n/* dummy_ucd_record */\nconst ucd_record *record = GET_UCD(UNASSIGNED_UTF_CHAR);\nSLJIT_ASSERT(record->script == ucp_Unknown && record->chartype == ucp_Cn && record->gbprop == ucp_gbOther);\nSLJIT_ASSERT(record->caseset == 0 && record->other_case == 0);\n#endif\n\nSLJIT_ASSERT(UCD_BLOCK_SIZE == 128 && sizeof(ucd_record) == 12);\n\nsljit_emit_fast_enter(compiler, RETURN_ADDR, 0);\n\n#if PCRE2_CODE_UNIT_WIDTH == 32\nif (!common->utf)\n  {\n  jump = CMP(SLJIT_LESS, TMP1, 0, SLJIT_IMM, MAX_UTF_CODE_POINT + 1);\n  OP1(SLJIT_MOV, TMP1, 0, SLJIT_IMM, UNASSIGNED_UTF_CHAR);\n  JUMPHERE(jump);\n  }\n#endif\n\nOP2(SLJIT_LSHR, TMP2, 0, TMP1, 0, SLJIT_IMM, UCD_BLOCK_SHIFT);\nOP2(SLJIT_SHL, TMP2, 0, TMP2, 0, SLJIT_IMM, 1);\nOP1(SLJIT_MOV_U16, TMP2, 0, SLJIT_MEM1(TMP2), (sljit_sw)PRIV(ucd_stage1));\nOP2(SLJIT_AND, TMP1, 0, TMP1, 0, SLJIT_IMM, UCD_BLOCK_MASK);\nOP2(SLJIT_SHL, TMP2, 0, TMP2, 0, SLJIT_IMM, UCD_BLOCK_SHIFT);\nOP2(SLJIT_ADD, TMP1, 0, TMP1, 0, TMP2, 0);\nOP1(SLJIT_MOV, TMP2, 0, SLJIT_IMM, (sljit_sw)PRIV(ucd_stage2));\nOP1(SLJIT_MOV_U16, TMP2, 0, SLJIT_MEM2(TMP2, TMP1), 1);\n\n/* TMP2 is multiplied by 12. Same as (TMP2 << 2) + ((TMP2 << 2) << 1). */\nOP1(SLJIT_MOV, TMP1, 0, SLJIT_IMM, (sljit_sw)PRIV(ucd_records) + SLJIT_OFFSETOF(ucd_record, chartype));\nOP2(SLJIT_SHL, TMP2, 0, TMP2, 0, SLJIT_IMM, 2);\nOP2(SLJIT_ADD, TMP1, 0, TMP1, 0, TMP2, 0);\nOP1(SLJIT_MOV_U8, TMP1, 0, SLJIT_MEM2(TMP1, TMP2), 1);\n\nOP_SRC(SLJIT_FAST_RETURN, RETURN_ADDR, 0);\n}\n\n#endif /* SUPPORT_UNICODE */\n\nstatic SLJIT_INLINE struct sljit_label *mainloop_entry(compiler_common *common)\n{\nDEFINE_COMPILER;\nstruct sljit_label *mainloop;\nstruct sljit_label *newlinelabel = NULL;\nstruct sljit_jump *start;\nstruct sljit_jump *end = NULL;\nstruct sljit_jump *end2 = NULL;\n#if defined SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH != 32\nstruct sljit_label *loop;\nstruct sljit_jump *jump;\n#endif /* SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH != 32 */\njump_list *newline = NULL;\nsljit_u32 overall_options = common->re->overall_options;\nBOOL hascrorlf = (common->re->flags & PCRE2_HASCRORLF) != 0;\nBOOL newlinecheck = FALSE;\nBOOL readuchar = FALSE;\n\nif (!(hascrorlf || (overall_options & PCRE2_FIRSTLINE) != 0)\n    && (common->nltype == NLTYPE_ANY || common->nltype == NLTYPE_ANYCRLF || common->newline > 255))\n  newlinecheck = TRUE;\n\nSLJIT_ASSERT(common->abort_label == NULL);\n\nif ((overall_options & PCRE2_FIRSTLINE) != 0)\n  {\n  /* Search for the end of the first line. */\n  SLJIT_ASSERT(common->match_end_ptr != 0);\n  OP1(SLJIT_MOV, TMP3, 0, STR_PTR, 0);\n\n  if (common->nltype == NLTYPE_FIXED && common->newline > 255)\n    {\n    mainloop = LABEL();\n    OP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n    end = CMP(SLJIT_GREATER_EQUAL, STR_PTR, 0, STR_END, 0);\n    OP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(-1));\n    OP1(MOV_UCHAR, TMP2, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(0));\n    CMPTO(SLJIT_NOT_EQUAL, TMP1, 0, SLJIT_IMM, (common->newline >> 8) & 0xff, mainloop);\n    CMPTO(SLJIT_NOT_EQUAL, TMP2, 0, SLJIT_IMM, common->newline & 0xff, mainloop);\n    JUMPHERE(end);\n    OP2(SLJIT_SUB, SLJIT_MEM1(SLJIT_SP), common->match_end_ptr, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n    }\n  else\n    {\n    end = CMP(SLJIT_GREATER_EQUAL, STR_PTR, 0, STR_END, 0);\n    mainloop = LABEL();\n    /* Continual stores does not cause data dependency. */\n    OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), common->match_end_ptr, STR_PTR, 0);\n    read_char(common, common->nlmin, common->nlmax, NULL, READ_CHAR_NEWLINE);\n    check_newlinechar(common, common->nltype, &newline, TRUE);\n    CMPTO(SLJIT_LESS, STR_PTR, 0, STR_END, 0, mainloop);\n    JUMPHERE(end);\n    OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), common->match_end_ptr, STR_PTR, 0);\n    set_jumps(newline, LABEL());\n    }\n\n  OP1(SLJIT_MOV, STR_PTR, 0, TMP3, 0);\n  }\nelse if ((overall_options & PCRE2_USE_OFFSET_LIMIT) != 0)\n  {\n  /* Check whether offset limit is set and valid. */\n  SLJIT_ASSERT(common->match_end_ptr != 0);\n\n  if (HAS_VIRTUAL_REGISTERS)\n    {\n    OP1(SLJIT_MOV, TMP1, 0, ARGUMENTS, 0);\n    OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(TMP1), SLJIT_OFFSETOF(jit_arguments, offset_limit));\n    }\n  else\n    OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(ARGUMENTS), SLJIT_OFFSETOF(jit_arguments, offset_limit));\n\n  OP1(SLJIT_MOV, TMP2, 0, STR_END, 0);\n  end = CMP(SLJIT_EQUAL, TMP1, 0, SLJIT_IMM, (sljit_sw) PCRE2_UNSET);\n  if (HAS_VIRTUAL_REGISTERS)\n    OP1(SLJIT_MOV, TMP2, 0, ARGUMENTS, 0);\n  else\n    OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(ARGUMENTS), SLJIT_OFFSETOF(jit_arguments, begin));\n\n#if PCRE2_CODE_UNIT_WIDTH == 16 || PCRE2_CODE_UNIT_WIDTH == 32\n  OP2(SLJIT_SHL, TMP1, 0, TMP1, 0, SLJIT_IMM, UCHAR_SHIFT);\n#endif /* PCRE2_CODE_UNIT_WIDTH == \u00dd16|32\u00a8 */\n  if (HAS_VIRTUAL_REGISTERS)\n    OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(TMP2), SLJIT_OFFSETOF(jit_arguments, begin));\n\n  OP2(SLJIT_ADD, TMP2, 0, TMP2, 0, TMP1, 0);\n  end2 = CMP(SLJIT_LESS_EQUAL, TMP2, 0, STR_END, 0);\n  OP1(SLJIT_MOV, TMP2, 0, STR_END, 0);\n  JUMPHERE(end2);\n  OP1(SLJIT_MOV, SLJIT_RETURN_REG, 0, SLJIT_IMM, PCRE2_ERROR_NOMATCH);\n  add_jump(compiler, &common->abort, CMP(SLJIT_LESS, TMP2, 0, STR_PTR, 0));\n  JUMPHERE(end);\n  OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), common->match_end_ptr, TMP2, 0);\n  }\n\nstart = JUMP(SLJIT_JUMP);\n\nif (newlinecheck)\n  {\n  newlinelabel = LABEL();\n  OP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n  end = CMP(SLJIT_GREATER_EQUAL, STR_PTR, 0, STR_END, 0);\n  OP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(STR_PTR), 0);\n  OP2(SLJIT_SUB | SLJIT_SET_Z, SLJIT_UNUSED, 0, TMP1, 0, SLJIT_IMM, common->newline & 0xff);\n  OP_FLAGS(SLJIT_MOV, TMP1, 0, SLJIT_EQUAL);\n#if PCRE2_CODE_UNIT_WIDTH == 16 || PCRE2_CODE_UNIT_WIDTH == 32\n  OP2(SLJIT_SHL, TMP1, 0, TMP1, 0, SLJIT_IMM, UCHAR_SHIFT);\n#endif /* PCRE2_CODE_UNIT_WIDTH == \u00dd16|32\u00a8 */\n  OP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, TMP1, 0);\n  end2 = JUMP(SLJIT_JUMP);\n  }\n\nmainloop = LABEL();\n\n/* Increasing the STR_PTR here requires one less jump in the most common case. */\n#if defined SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH != 32\nif (common->utf && !common->invalid_utf) readuchar = TRUE;\n#endif /* SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH != 32 */\nif (newlinecheck) readuchar = TRUE;\n\nif (readuchar)\n  OP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(STR_PTR), 0);\n\nif (newlinecheck)\n  CMPTO(SLJIT_EQUAL, TMP1, 0, SLJIT_IMM, (common->newline >> 8) & 0xff, newlinelabel);\n\nOP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n#if defined SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH != 32\n#if PCRE2_CODE_UNIT_WIDTH == 8\nif (common->invalid_utf)\n  {\n  /* Skip continuation code units. */\n  loop = LABEL();\n  jump = CMP(SLJIT_GREATER_EQUAL, STR_PTR, 0, STR_END, 0);\n  OP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(STR_PTR), 0);\n  OP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n  OP2(SLJIT_SUB, TMP1, 0, TMP1, 0, SLJIT_IMM, 0x80);\n  CMPTO(SLJIT_LESS, TMP1, 0, SLJIT_IMM, 0x40, loop);\n  OP2(SLJIT_SUB, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n  JUMPHERE(jump);\n  }\nelse if (common->utf)\n  {\n  jump = CMP(SLJIT_LESS, TMP1, 0, SLJIT_IMM, 0xc0);\n  OP1(SLJIT_MOV_U8, TMP1, 0, SLJIT_MEM1(TMP1), (sljit_sw)PRIV(utf8_table4) - 0xc0);\n  OP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, TMP1, 0);\n  JUMPHERE(jump);\n  }\n#elif PCRE2_CODE_UNIT_WIDTH == 16\nif (common->invalid_utf)\n  {\n  /* Skip continuation code units. */\n  loop = LABEL();\n  jump = CMP(SLJIT_GREATER_EQUAL, STR_PTR, 0, STR_END, 0);\n  OP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(STR_PTR), 0);\n  OP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n  OP2(SLJIT_SUB, TMP1, 0, TMP1, 0, SLJIT_IMM, 0xdc00);\n  CMPTO(SLJIT_LESS, TMP1, 0, SLJIT_IMM, 0x400, loop);\n  OP2(SLJIT_SUB, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n  JUMPHERE(jump);\n  }\nelse if (common->utf)\n  {\n  OP2(SLJIT_SUB, TMP1, 0, TMP1, 0, SLJIT_IMM, 0xd800);\n\n  if (sljit_has_cpu_feature(SLJIT_HAS_CMOV))\n    {\n    OP2(SLJIT_ADD, TMP2, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n    OP2(SLJIT_SUB | SLJIT_SET_LESS, SLJIT_UNUSED, 0, TMP1, 0, SLJIT_IMM, 0x400);\n    CMOV(SLJIT_LESS, STR_PTR, TMP2, 0);\n    }\n  else\n    {\n    OP2(SLJIT_SUB | SLJIT_SET_LESS, SLJIT_UNUSED, 0, TMP1, 0, SLJIT_IMM, 0x400);\n    OP_FLAGS(SLJIT_MOV, TMP1, 0, SLJIT_LESS);\n    OP2(SLJIT_SHL, TMP1, 0, TMP1, 0, SLJIT_IMM, UCHAR_SHIFT);\n    OP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, TMP1, 0);\n    }\n  }\n#endif /* PCRE2_CODE_UNIT_WIDTH == \u00dd8|16\u00a8 */\n#endif /* SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH != 32 */\nJUMPHERE(start);\n\nif (newlinecheck)\n  {\n  JUMPHERE(end);\n  JUMPHERE(end2);\n  }\n\nreturn mainloop;\n}\n\n\nstatic SLJIT_INLINE void add_prefix_char(PCRE2_UCHAR chr, fast_forward_char_data *chars, BOOL last)\n{\nsljit_u32 i, count = chars->count;\n\nif (count == 255)\n  return;\n\nif (count == 0)\n  {\n  chars->count = 1;\n  chars->chars\u00dd0\u00a8 = chr;\n\n  if (last)\n    chars->last_count = 1;\n  return;\n  }\n\nfor (i = 0; i < count; i++)\n  if (chars->chars\u00ddi\u00a8 == chr)\n    return;\n\nif (count >= MAX_DIFF_CHARS)\n  {\n  chars->count = 255;\n  return;\n  }\n\nchars->chars\u00ddcount\u00a8 = chr;\nchars->count = count + 1;\n\nif (last)\n  chars->last_count++;\n}\n\nstatic int scan_prefix(compiler_common *common, PCRE2_SPTR cc, fast_forward_char_data *chars, int max_chars, sljit_u32 *rec_count)\n{\n/* Recursive function, which scans prefix literals. */\nBOOL last, any, class, caseless;\nint len, repeat, len_save, consumed = 0;\nsljit_u32 chr; /* Any unicode character. */\nsljit_u8 *bytes, *bytes_end, byte;\nPCRE2_SPTR alternative, cc_save, oc;\n#if defined SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH == 8\nPCRE2_UCHAR othercase\u00dd4\u00a8;\n#elif defined SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH == 16\nPCRE2_UCHAR othercase\u00dd2\u00a8;\n#else\nPCRE2_UCHAR othercase\u00dd1\u00a8;\n#endif\n\nrepeat = 1;\nwhile (TRUE)\n  {\n  if (*rec_count == 0)\n    return 0;\n  (*rec_count)--;\n\n  last = TRUE;\n  any = FALSE;\n  class = FALSE;\n  caseless = FALSE;\n\n  switch (*cc)\n    {\n    case OP_CHARI:\n    caseless = TRUE;\n    /* Fall through */\n    case OP_CHAR:\n    last = FALSE;\n    cc++;\n    break;\n\n    case OP_SOD:\n    case OP_SOM:\n    case OP_SET_SOM:\n    case OP_NOT_WORD_BOUNDARY:\n    case OP_WORD_BOUNDARY:\n    case OP_EODN:\n    case OP_EOD:\n    case OP_CIRC:\n    case OP_CIRCM:\n    case OP_DOLL:\n    case OP_DOLLM:\n    /* Zero width assertions. */\n    cc++;\n    continue;\n\n    case OP_ASSERT:\n    case OP_ASSERT_NOT:\n    case OP_ASSERTBACK:\n    case OP_ASSERTBACK_NOT:\n    case OP_ASSERT_NA:\n    case OP_ASSERTBACK_NA:\n    cc = bracketend(cc);\n    continue;\n\n    case OP_PLUSI:\n    case OP_MINPLUSI:\n    case OP_POSPLUSI:\n    caseless = TRUE;\n    /* Fall through */\n    case OP_PLUS:\n    case OP_MINPLUS:\n    case OP_POSPLUS:\n    cc++;\n    break;\n\n    case OP_EXACTI:\n    caseless = TRUE;\n    /* Fall through */\n    case OP_EXACT:\n    repeat = GET2(cc, 1);\n    last = FALSE;\n    cc += 1 + IMM2_SIZE;\n    break;\n\n    case OP_QUERYI:\n    case OP_MINQUERYI:\n    case OP_POSQUERYI:\n    caseless = TRUE;\n    /* Fall through */\n    case OP_QUERY:\n    case OP_MINQUERY:\n    case OP_POSQUERY:\n    len = 1;\n    cc++;\n#ifdef SUPPORT_UNICODE\n    if (common->utf && HAS_EXTRALEN(*cc)) len += GET_EXTRALEN(*cc);\n#endif\n    max_chars = scan_prefix(common, cc + len, chars, max_chars, rec_count);\n    if (max_chars == 0)\n      return consumed;\n    last = FALSE;\n    break;\n\n    case OP_KET:\n    cc += 1 + LINK_SIZE;\n    continue;\n\n    case OP_ALT:\n    cc += GET(cc, 1);\n    continue;\n\n    case OP_ONCE:\n    case OP_BRA:\n    case OP_BRAPOS:\n    case OP_CBRA:\n    case OP_CBRAPOS:\n    alternative = cc + GET(cc, 1);\n    while (*alternative == OP_ALT)\n      {\n      max_chars = scan_prefix(common, alternative + 1 + LINK_SIZE, chars, max_chars, rec_count);\n      if (max_chars == 0)\n        return consumed;\n      alternative += GET(alternative, 1);\n      }\n\n    if (*cc == OP_CBRA || *cc == OP_CBRAPOS)\n      cc += IMM2_SIZE;\n    cc += 1 + LINK_SIZE;\n    continue;\n\n    case OP_CLASS:\n#if defined SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH == 8\n    if (common->utf && !is_char7_bitset((const sljit_u8 *)(cc + 1), FALSE))\n      return consumed;\n#endif\n    class = TRUE;\n    break;\n\n    case OP_NCLASS:\n#if defined SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH != 32\n    if (common->utf) return consumed;\n#endif\n    class = TRUE;\n    break;\n\n#if defined SUPPORT_UNICODE || PCRE2_CODE_UNIT_WIDTH != 8\n    case OP_XCLASS:\n#if defined SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH != 32\n    if (common->utf) return consumed;\n#endif\n    any = TRUE;\n    cc += GET(cc, 1);\n    break;\n#endif\n\n    case OP_DIGIT:\n#if defined SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH == 8\n    if (common->utf && !is_char7_bitset((const sljit_u8 *)common->ctypes - cbit_length + cbit_digit, FALSE))\n      return consumed;\n#endif\n    any = TRUE;\n    cc++;\n    break;\n\n    case OP_WHITESPACE:\n#if defined SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH == 8\n    if (common->utf && !is_char7_bitset((const sljit_u8 *)common->ctypes - cbit_length + cbit_space, FALSE))\n      return consumed;\n#endif\n    any = TRUE;\n    cc++;\n    break;\n\n    case OP_WORDCHAR:\n#if defined SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH == 8\n    if (common->utf && !is_char7_bitset((const sljit_u8 *)common->ctypes - cbit_length + cbit_word, FALSE))\n      return consumed;\n#endif\n    any = TRUE;\n    cc++;\n    break;\n\n    case OP_NOT:\n    case OP_NOTI:\n    cc++;\n    /* Fall through. */\n    case OP_NOT_DIGIT:\n    case OP_NOT_WHITESPACE:\n    case OP_NOT_WORDCHAR:\n    case OP_ANY:\n    case OP_ALLANY:\n#if defined SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH != 32\n    if (common->utf) return consumed;\n#endif\n    any = TRUE;\n    cc++;\n    break;\n\n#ifdef SUPPORT_UNICODE\n    case OP_NOTPROP:\n    case OP_PROP:\n#if PCRE2_CODE_UNIT_WIDTH != 32\n    if (common->utf) return consumed;\n#endif\n    any = TRUE;\n    cc += 1 + 2;\n    break;\n#endif\n\n    case OP_TYPEEXACT:\n    repeat = GET2(cc, 1);\n    cc += 1 + IMM2_SIZE;\n    continue;\n\n    case OP_NOTEXACT:\n    case OP_NOTEXACTI:\n#if defined SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH != 32\n    if (common->utf) return consumed;\n#endif\n    any = TRUE;\n    repeat = GET2(cc, 1);\n    cc += 1 + IMM2_SIZE + 1;\n    break;\n\n    default:\n    return consumed;\n    }\n\n  if (any)\n    {\n    do\n      {\n      chars->count = 255;\n\n      consumed++;\n      if (--max_chars == 0)\n        return consumed;\n      chars++;\n      }\n    while (--repeat > 0);\n\n    repeat = 1;\n    continue;\n    }\n\n  if (class)\n    {\n    bytes = (sljit_u8*) (cc + 1);\n    cc += 1 + 32 / sizeof(PCRE2_UCHAR);\n\n    switch (*cc)\n      {\n      case OP_CRSTAR:\n      case OP_CRMINSTAR:\n      case OP_CRPOSSTAR:\n      case OP_CRQUERY:\n      case OP_CRMINQUERY:\n      case OP_CRPOSQUERY:\n      max_chars = scan_prefix(common, cc + 1, chars, max_chars, rec_count);\n      if (max_chars == 0)\n        return consumed;\n      break;\n\n      default:\n      case OP_CRPLUS:\n      case OP_CRMINPLUS:\n      case OP_CRPOSPLUS:\n      break;\n\n      case OP_CRRANGE:\n      case OP_CRMINRANGE:\n      case OP_CRPOSRANGE:\n      repeat = GET2(cc, 1);\n      if (repeat <= 0)\n        return consumed;\n      break;\n      }\n\n    do\n      {\n      if (bytes\u00dd31\u00a8 & 0x80)\n        chars->count = 255;\n      else if (chars->count != 255)\n        {\n        bytes_end = bytes + 32;\n        chr = 0;\n        do\n          {\n          byte = *bytes++;\n          SLJIT_ASSERT((chr & 0x7) == 0);\n          if (byte == 0)\n            chr += 8;\n          else\n            {\n            do\n              {\n              if ((byte & 0x1) != 0)\n                add_prefix_char(chr, chars, TRUE);\n              byte >>= 1;\n              chr++;\n              }\n            while (byte != 0);\n            chr = (chr + 7) & ~7;\n            }\n          }\n        while (chars->count != 255 && bytes < bytes_end);\n        bytes = bytes_end - 32;\n        }\n\n      consumed++;\n      if (--max_chars == 0)\n        return consumed;\n      chars++;\n      }\n    while (--repeat > 0);\n\n    switch (*cc)\n      {\n      case OP_CRSTAR:\n      case OP_CRMINSTAR:\n      case OP_CRPOSSTAR:\n      return consumed;\n\n      case OP_CRQUERY:\n      case OP_CRMINQUERY:\n      case OP_CRPOSQUERY:\n      cc++;\n      break;\n\n      case OP_CRRANGE:\n      case OP_CRMINRANGE:\n      case OP_CRPOSRANGE:\n      if (GET2(cc, 1) != GET2(cc, 1 + IMM2_SIZE))\n        return consumed;\n      cc += 1 + 2 * IMM2_SIZE;\n      break;\n      }\n\n    repeat = 1;\n    continue;\n    }\n\n  len = 1;\n#ifdef SUPPORT_UNICODE\n  if (common->utf && HAS_EXTRALEN(*cc)) len += GET_EXTRALEN(*cc);\n#endif\n\n  if (caseless && char_has_othercase(common, cc))\n    {\n#ifdef SUPPORT_UNICODE\n    if (common->utf)\n      {\n      GETCHAR(chr, cc);\n      if ((int)PRIV(ord2utf)(char_othercase(common, chr), othercase) != len)\n        return consumed;\n      }\n    else\n#endif\n      {\n      chr = *cc;\n#ifdef SUPPORT_UNICODE\n      if (common->ucp && chr > 127)\n        othercase\u00dd0\u00a8 = UCD_OTHERCASE(chr);\n      else\n#endif\n        othercase\u00dd0\u00a8 = TABLE_GET(chr, common->fcc, chr);\n      }\n    }\n  else\n    {\n    caseless = FALSE;\n    othercase\u00dd0\u00a8 = 0; /* Stops compiler warning - PH */\n    }\n\n  len_save = len;\n  cc_save = cc;\n  while (TRUE)\n    {\n    oc = othercase;\n    do\n      {\n      len--;\n      consumed++;\n\n      chr = *cc;\n      add_prefix_char(*cc, chars, len == 0);\n\n      if (caseless)\n        add_prefix_char(*oc, chars, len == 0);\n\n      if (--max_chars == 0)\n        return consumed;\n      chars++;\n      cc++;\n      oc++;\n      }\n    while (len > 0);\n\n    if (--repeat == 0)\n      break;\n\n    len = len_save;\n    cc = cc_save;\n    }\n\n  repeat = 1;\n  if (last)\n    return consumed;\n  }\n}\n\n#if defined SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH != 32\nstatic void jumpto_if_not_utf_char_start(struct sljit_compiler *compiler, sljit_s32 reg, struct sljit_label *label)\n{\n#if PCRE2_CODE_UNIT_WIDTH == 8\nOP2(SLJIT_AND, reg, 0, reg, 0, SLJIT_IMM, 0xc0);\nCMPTO(SLJIT_EQUAL, reg, 0, SLJIT_IMM, 0x80, label);\n#elif PCRE2_CODE_UNIT_WIDTH == 16\nOP2(SLJIT_AND, reg, 0, reg, 0, SLJIT_IMM, 0xfc00);\nCMPTO(SLJIT_EQUAL, reg, 0, SLJIT_IMM, 0xdc00, label);\n#else\n#error \"Unknown code width\"\n#endif\n}\n#endif\n\n#include \"JITSIMD2.h\"\n\n#ifdef JIT_HAS_FAST_FORWARD_CHAR_PAIR_SIMD\n\nstatic BOOL check_fast_forward_char_pair_simd(compiler_common *common, fast_forward_char_data *chars, int max)\n{\n  sljit_s32 i, j, max_i = 0, max_j = 0;\n  sljit_u32 max_pri = 0;\n  PCRE2_UCHAR a1, a2, a_pri, b1, b2, b_pri;\n\n  for (i = max - 1; i >= 1; i--)\n    {\n    if (chars\u00ddi\u00a8.last_count > 2)\n      {\n      a1 = chars\u00ddi\u00a8.chars\u00dd0\u00a8;\n      a2 = chars\u00ddi\u00a8.chars\u00dd1\u00a8;\n      a_pri = chars\u00ddi\u00a8.last_count;\n\n      j = i - max_fast_forward_char_pair_offset();\n      if (j < 0)\n        j = 0;\n\n      while (j < i)\n        {\n        b_pri = chars\u00ddj\u00a8.last_count;\n        if (b_pri > 2 && a_pri + b_pri >= max_pri)\n          {\n          b1 = chars\u00ddj\u00a8.chars\u00dd0\u00a8;\n          b2 = chars\u00ddj\u00a8.chars\u00dd1\u00a8;\n\n          if (a1 != b1 && a1 != b2 && a2 != b1 && a2 != b2)\n            {\n            max_pri = a_pri + b_pri;\n            max_i = i;\n            max_j = j;\n            }\n          }\n        j++;\n        }\n      }\n    }\n\nif (max_pri == 0)\n  return FALSE;\n\nfast_forward_char_pair_simd(common, max_i, chars\u00ddmax_i\u00a8.chars\u00dd0\u00a8, chars\u00ddmax_i\u00a8.chars\u00dd1\u00a8, max_j, chars\u00ddmax_j\u00a8.chars\u00dd0\u00a8, chars\u00ddmax_j\u00a8.chars\u00dd1\u00a8);\nreturn TRUE;\n}\n\n#endif /* JIT_HAS_FAST_FORWARD_CHAR_PAIR_SIMD */\n\nstatic void fast_forward_first_char2(compiler_common *common, PCRE2_UCHAR char1, PCRE2_UCHAR char2, sljit_s32 offset)\n{\nDEFINE_COMPILER;\nstruct sljit_label *start;\nstruct sljit_jump *match;\nstruct sljit_jump *partial_quit;\nPCRE2_UCHAR mask;\nBOOL has_match_end = (common->match_end_ptr != 0);\n\nSLJIT_ASSERT(common->mode == PCRE2_JIT_COMPLETE || offset == 0);\n\nif (has_match_end)\n  OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(SLJIT_SP), common->match_end_ptr);\n\nif (offset > 0)\n  OP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(offset));\n\nif (has_match_end)\n  {\n  OP1(SLJIT_MOV, TMP3, 0, STR_END, 0);\n\n  OP2(SLJIT_ADD, TMP1, 0, TMP1, 0, SLJIT_IMM, IN_UCHARS(offset + 1));\n  OP2(SLJIT_SUB | SLJIT_SET_GREATER, SLJIT_UNUSED, 0, STR_END, 0, TMP1, 0);\n  CMOV(SLJIT_GREATER, STR_END, TMP1, 0);\n  }\n\n#ifdef JIT_HAS_FAST_FORWARD_CHAR_SIMD\n\nif (JIT_HAS_FAST_FORWARD_CHAR_SIMD)\n  {\n  fast_forward_char_simd(common, char1, char2, offset);\n\n  if (offset > 0)\n    OP2(SLJIT_SUB, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(offset));\n\n  if (has_match_end)\n    OP1(SLJIT_MOV, STR_END, 0, TMP3, 0);\n  return;\n  }\n\n#endif\n\nstart = LABEL();\n\npartial_quit = CMP(SLJIT_GREATER_EQUAL, STR_PTR, 0, STR_END, 0);\nif (common->mode == PCRE2_JIT_COMPLETE)\n  add_jump(compiler, &common->failed_match, partial_quit);\n\nOP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(STR_PTR), 0);\nOP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n\nif (char1 == char2)\n  CMPTO(SLJIT_NOT_EQUAL, TMP1, 0, SLJIT_IMM, char1, start);\nelse\n  {\n  mask = char1 \u00ac char2;\n  if (is_powerof2(mask))\n    {\n    OP2(SLJIT_OR, TMP1, 0, TMP1, 0, SLJIT_IMM, mask);\n    CMPTO(SLJIT_NOT_EQUAL, TMP1, 0, SLJIT_IMM, char1 | mask, start);\n    }\n  else\n    {\n    match = CMP(SLJIT_EQUAL, TMP1, 0, SLJIT_IMM, char1);\n    CMPTO(SLJIT_NOT_EQUAL, TMP1, 0, SLJIT_IMM, char2, start);\n    JUMPHERE(match);\n    }\n  }\n\n#if defined SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH != 32\nif (common->utf && offset > 0)\n  {\n  OP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(-(offset + 1)));\n  jumpto_if_not_utf_char_start(compiler, TMP1, start);\n  }\n#endif\n\nOP2(SLJIT_SUB, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(offset + 1));\n\nif (common->mode != PCRE2_JIT_COMPLETE)\n  JUMPHERE(partial_quit);\n\nif (has_match_end)\n  OP1(SLJIT_MOV, STR_END, 0, TMP3, 0);\n}\n\nstatic SLJIT_INLINE BOOL fast_forward_first_n_chars(compiler_common *common)\n{\nDEFINE_COMPILER;\nstruct sljit_label *start;\nstruct sljit_jump *match;\nfast_forward_char_data chars\u00ddMAX_N_CHARS\u00a8;\nsljit_s32 offset;\nPCRE2_UCHAR mask;\nPCRE2_UCHAR *char_set, *char_set_end;\nint i, max, from;\nint range_right = -1, range_len;\nsljit_u8 *update_table = NULL;\nBOOL in_range;\nsljit_u32 rec_count;\n\nfor (i = 0; i < MAX_N_CHARS; i++)\n  {\n  chars\u00ddi\u00a8.count = 0;\n  chars\u00ddi\u00a8.last_count = 0;\n  }\n\nrec_count = 10000;\nmax = scan_prefix(common, common->start, chars, MAX_N_CHARS, &rec_count);\n\nif (max < 1)\n  return FALSE;\n\n/* Convert last_count to priority. */\nfor (i = 0; i < max; i++)\n  {\n  SLJIT_ASSERT(chars\u00ddi\u00a8.count > 0 && chars\u00ddi\u00a8.last_count <= chars\u00ddi\u00a8.count);\n\n  if (chars\u00ddi\u00a8.count == 1)\n    {\n    chars\u00ddi\u00a8.last_count = (chars\u00ddi\u00a8.last_count == 1) ? 7 : 5;\n    /* Simplifies algorithms later. */\n    chars\u00ddi\u00a8.chars\u00dd1\u00a8 = chars\u00ddi\u00a8.chars\u00dd0\u00a8;\n    }\n  else if (chars\u00ddi\u00a8.count == 2)\n    {\n    SLJIT_ASSERT(chars\u00ddi\u00a8.chars\u00dd0\u00a8 != chars\u00ddi\u00a8.chars\u00dd1\u00a8);\n\n    if (is_powerof2(chars\u00ddi\u00a8.chars\u00dd0\u00a8 \u00ac chars\u00ddi\u00a8.chars\u00dd1\u00a8))\n      chars\u00ddi\u00a8.last_count = (chars\u00ddi\u00a8.last_count == 2) ? 6 : 4;\n    else\n      chars\u00ddi\u00a8.last_count = (chars\u00ddi\u00a8.last_count == 2) ? 3 : 2;\n    }\n  else\n    chars\u00ddi\u00a8.last_count = (chars\u00ddi\u00a8.count == 255) ? 0 : 1;\n  }\n\n#ifdef JIT_HAS_FAST_FORWARD_CHAR_PAIR_SIMD\nif (JIT_HAS_FAST_FORWARD_CHAR_PAIR_SIMD && check_fast_forward_char_pair_simd(common, chars, max))\n  return TRUE;\n#endif\n\nin_range = FALSE;\n/* Prevent compiler \"uninitialized\" warning */\nfrom = 0;\nrange_len = 4 /* minimum length */ - 1;\nfor (i = 0; i <= max; i++)\n  {\n  if (in_range && (i - from) > range_len && (chars\u00ddi - 1\u00a8.count < 255))\n    {\n    range_len = i - from;\n    range_right = i - 1;\n    }\n\n  if (i < max && chars\u00ddi\u00a8.count < 255)\n    {\n    SLJIT_ASSERT(chars\u00ddi\u00a8.count > 0);\n    if (!in_range)\n      {\n      in_range = TRUE;\n      from = i;\n      }\n    }\n  else\n    in_range = FALSE;\n  }\n\nif (range_right >= 0)\n  {\n  update_table = (sljit_u8 *)allocate_read_only_data(common, 256);\n  if (update_table == NULL)\n    return TRUE;\n  memset(update_table, IN_UCHARS(range_len), 256);\n\n  for (i = 0; i < range_len; i++)\n    {\n    SLJIT_ASSERT(chars\u00ddrange_right - i\u00a8.count > 0 && chars\u00ddrange_right - i\u00a8.count < 255);\n\n    char_set = chars\u00ddrange_right - i\u00a8.chars;\n    char_set_end = char_set + chars\u00ddrange_right - i\u00a8.count;\n    do\n      {\n      if (update_table\u00dd(*char_set) & 0xff\u00a8 > IN_UCHARS(i))\n        update_table\u00dd(*char_set) & 0xff\u00a8 = IN_UCHARS(i);\n      char_set++;\n      }\n    while (char_set < char_set_end);\n    }\n  }\n\noffset = -1;\n/* Scan forward. */\nfor (i = 0; i < max; i++)\n  {\n  if (range_right == i)\n    continue;\n\n  if (offset == -1)\n    {\n    if (chars\u00ddi\u00a8.last_count >= 2)\n      offset = i;\n    }\n  else if (chars\u00ddoffset\u00a8.last_count < chars\u00ddi\u00a8.last_count)\n    offset = i;\n  }\n\nSLJIT_ASSERT(offset == -1 || (chars\u00ddoffset\u00a8.count >= 1 && chars\u00ddoffset\u00a8.count <= 2));\n\nif (range_right < 0)\n  {\n  if (offset < 0)\n    return FALSE;\n  /* Works regardless the value is 1 or 2. */\n  fast_forward_first_char2(common, chars\u00ddoffset\u00a8.chars\u00dd0\u00a8, chars\u00ddoffset\u00a8.chars\u00dd1\u00a8, offset);\n  return TRUE;\n  }\n\nSLJIT_ASSERT(range_right != offset);\n\nif (common->match_end_ptr != 0)\n  {\n  OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(SLJIT_SP), common->match_end_ptr);\n  OP1(SLJIT_MOV, TMP3, 0, STR_END, 0);\n  OP2(SLJIT_SUB | SLJIT_SET_LESS, STR_END, 0, STR_END, 0, SLJIT_IMM, IN_UCHARS(max));\n  add_jump(compiler, &common->failed_match, JUMP(SLJIT_LESS));\n  OP2(SLJIT_SUB | SLJIT_SET_GREATER, SLJIT_UNUSED, 0, STR_END, 0, TMP1, 0);\n  CMOV(SLJIT_GREATER, STR_END, TMP1, 0);\n  }\nelse\n  {\n  OP2(SLJIT_SUB | SLJIT_SET_LESS, STR_END, 0, STR_END, 0, SLJIT_IMM, IN_UCHARS(max));\n  add_jump(compiler, &common->failed_match, JUMP(SLJIT_LESS));\n  }\n\nSLJIT_ASSERT(range_right >= 0);\n\nif (!HAS_VIRTUAL_REGISTERS)\n  OP1(SLJIT_MOV, RETURN_ADDR, 0, SLJIT_IMM, (sljit_sw)update_table);\n\nstart = LABEL();\nadd_jump(compiler, &common->failed_match, CMP(SLJIT_GREATER, STR_PTR, 0, STR_END, 0));\n\n#if PCRE2_CODE_UNIT_WIDTH == 8 || (defined SLJIT_LITTLE_ENDIAN && SLJIT_LITTLE_ENDIAN)\nOP1(SLJIT_MOV_U8, TMP1, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(range_right));\n#else\nOP1(SLJIT_MOV_U8, TMP1, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(range_right + 1) - 1);\n#endif\n\nif (!HAS_VIRTUAL_REGISTERS)\n  OP1(SLJIT_MOV_U8, TMP1, 0, SLJIT_MEM2(RETURN_ADDR, TMP1), 0);\nelse\n  OP1(SLJIT_MOV_U8, TMP1, 0, SLJIT_MEM1(TMP1), (sljit_sw)update_table);\n\nOP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, TMP1, 0);\nCMPTO(SLJIT_NOT_EQUAL, TMP1, 0, SLJIT_IMM, 0, start);\n\nif (offset >= 0)\n  {\n  OP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(offset));\n  OP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n\n  if (chars\u00ddoffset\u00a8.count == 1)\n    CMPTO(SLJIT_NOT_EQUAL, TMP1, 0, SLJIT_IMM, chars\u00ddoffset\u00a8.chars\u00dd0\u00a8, start);\n  else\n    {\n    mask = chars\u00ddoffset\u00a8.chars\u00dd0\u00a8 \u00ac chars\u00ddoffset\u00a8.chars\u00dd1\u00a8;\n    if (is_powerof2(mask))\n      {\n      OP2(SLJIT_OR, TMP1, 0, TMP1, 0, SLJIT_IMM, mask);\n      CMPTO(SLJIT_NOT_EQUAL, TMP1, 0, SLJIT_IMM, chars\u00ddoffset\u00a8.chars\u00dd0\u00a8 | mask, start);\n      }\n    else\n      {\n      match = CMP(SLJIT_EQUAL, TMP1, 0, SLJIT_IMM, chars\u00ddoffset\u00a8.chars\u00dd0\u00a8);\n      CMPTO(SLJIT_NOT_EQUAL, TMP1, 0, SLJIT_IMM, chars\u00ddoffset\u00a8.chars\u00dd1\u00a8, start);\n      JUMPHERE(match);\n      }\n    }\n  }\n\n#if defined SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH != 32\nif (common->utf && offset != 0)\n  {\n  if (offset < 0)\n    {\n    OP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(STR_PTR), 0);\n    OP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n    }\n  else\n    OP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(-1));\n\n  jumpto_if_not_utf_char_start(compiler, TMP1, start);\n\n  if (offset < 0)\n    OP2(SLJIT_SUB, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n  }\n#endif\n\nif (offset >= 0)\n  OP2(SLJIT_SUB, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n\nif (common->match_end_ptr != 0)\n  OP1(SLJIT_MOV, STR_END, 0, TMP3, 0);\nelse\n  OP2(SLJIT_ADD, STR_END, 0, STR_END, 0, SLJIT_IMM, IN_UCHARS(max));\nreturn TRUE;\n}\n\nstatic SLJIT_INLINE void fast_forward_first_char(compiler_common *common)\n{\nPCRE2_UCHAR first_char = (PCRE2_UCHAR)(common->re->first_codeunit);\nPCRE2_UCHAR oc;\n\noc = first_char;\nif ((common->re->flags & PCRE2_FIRSTCASELESS) != 0)\n  {\n  oc = TABLE_GET(first_char, common->fcc, first_char);\n#if defined SUPPORT_UNICODE\n  if (first_char > 127 && (common->utf || common->ucp))\n    oc = UCD_OTHERCASE(first_char);\n#endif\n  }\n\nfast_forward_first_char2(common, first_char, oc, 0);\n}\n\nstatic SLJIT_INLINE void fast_forward_newline(compiler_common *common)\n{\nDEFINE_COMPILER;\nstruct sljit_label *loop;\nstruct sljit_jump *lastchar;\nstruct sljit_jump *firstchar;\nstruct sljit_jump *quit;\nstruct sljit_jump *foundcr = NULL;\nstruct sljit_jump *notfoundnl;\njump_list *newline = NULL;\n\nif (common->match_end_ptr != 0)\n  {\n  OP1(SLJIT_MOV, TMP3, 0, STR_END, 0);\n  OP1(SLJIT_MOV, STR_END, 0, SLJIT_MEM1(SLJIT_SP), common->match_end_ptr);\n  }\n\nif (common->nltype == NLTYPE_FIXED && common->newline > 255)\n  {\n  lastchar = CMP(SLJIT_GREATER_EQUAL, STR_PTR, 0, STR_END, 0);\n  if (HAS_VIRTUAL_REGISTERS)\n    {\n    OP1(SLJIT_MOV, TMP1, 0, ARGUMENTS, 0);\n    OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(TMP1), SLJIT_OFFSETOF(jit_arguments, str));\n    OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(TMP1), SLJIT_OFFSETOF(jit_arguments, begin));\n    }\n  else\n    {\n    OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(ARGUMENTS), SLJIT_OFFSETOF(jit_arguments, str));\n    OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(ARGUMENTS), SLJIT_OFFSETOF(jit_arguments, begin));\n    }\n  firstchar = CMP(SLJIT_LESS_EQUAL, STR_PTR, 0, TMP2, 0);\n\n  OP2(SLJIT_ADD, TMP1, 0, TMP1, 0, SLJIT_IMM, IN_UCHARS(2));\n  OP2(SLJIT_SUB | SLJIT_SET_GREATER_EQUAL, SLJIT_UNUSED, 0, STR_PTR, 0, TMP1, 0);\n  OP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_GREATER_EQUAL);\n#if PCRE2_CODE_UNIT_WIDTH == 16 || PCRE2_CODE_UNIT_WIDTH == 32\n  OP2(SLJIT_SHL, TMP2, 0, TMP2, 0, SLJIT_IMM, UCHAR_SHIFT);\n#endif\n  OP2(SLJIT_SUB, STR_PTR, 0, STR_PTR, 0, TMP2, 0);\n\n  loop = LABEL();\n  OP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n  quit = CMP(SLJIT_GREATER_EQUAL, STR_PTR, 0, STR_END, 0);\n  OP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(-2));\n  OP1(MOV_UCHAR, TMP2, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(-1));\n  CMPTO(SLJIT_NOT_EQUAL, TMP1, 0, SLJIT_IMM, (common->newline >> 8) & 0xff, loop);\n  CMPTO(SLJIT_NOT_EQUAL, TMP2, 0, SLJIT_IMM, common->newline & 0xff, loop);\n\n  JUMPHERE(quit);\n  JUMPHERE(firstchar);\n  JUMPHERE(lastchar);\n\n  if (common->match_end_ptr != 0)\n    OP1(SLJIT_MOV, STR_END, 0, TMP3, 0);\n  return;\n  }\n\nif (HAS_VIRTUAL_REGISTERS)\n  {\n  OP1(SLJIT_MOV, TMP1, 0, ARGUMENTS, 0);\n  OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(TMP1), SLJIT_OFFSETOF(jit_arguments, str));\n  }\nelse\n  OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(ARGUMENTS), SLJIT_OFFSETOF(jit_arguments, str));\n\n/* Example: match /\u00ac/ to \\r\\n from offset 1. */\nfirstchar = CMP(SLJIT_LESS_EQUAL, STR_PTR, 0, TMP2, 0);\nmove_back(common, NULL, FALSE);\n\nloop = LABEL();\ncommon->ff_newline_shortcut = loop;\n\nread_char(common, common->nlmin, common->nlmax, NULL, READ_CHAR_NEWLINE);\nlastchar = CMP(SLJIT_GREATER_EQUAL, STR_PTR, 0, STR_END, 0);\nif (common->nltype == NLTYPE_ANY || common->nltype == NLTYPE_ANYCRLF)\n  foundcr = CMP(SLJIT_EQUAL, TMP1, 0, SLJIT_IMM, CHAR_CR);\ncheck_newlinechar(common, common->nltype, &newline, FALSE);\nset_jumps(newline, loop);\n\nif (common->nltype == NLTYPE_ANY || common->nltype == NLTYPE_ANYCRLF)\n  {\n  quit = JUMP(SLJIT_JUMP);\n  JUMPHERE(foundcr);\n  notfoundnl = CMP(SLJIT_GREATER_EQUAL, STR_PTR, 0, STR_END, 0);\n  OP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(STR_PTR), 0);\n  OP2(SLJIT_SUB | SLJIT_SET_Z, SLJIT_UNUSED, 0, TMP1, 0, SLJIT_IMM, CHAR_NL);\n  OP_FLAGS(SLJIT_MOV, TMP1, 0, SLJIT_EQUAL);\n#if PCRE2_CODE_UNIT_WIDTH == 16 || PCRE2_CODE_UNIT_WIDTH == 32\n  OP2(SLJIT_SHL, TMP1, 0, TMP1, 0, SLJIT_IMM, UCHAR_SHIFT);\n#endif\n  OP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, TMP1, 0);\n  JUMPHERE(notfoundnl);\n  JUMPHERE(quit);\n  }\nJUMPHERE(lastchar);\nJUMPHERE(firstchar);\n\nif (common->match_end_ptr != 0)\n  OP1(SLJIT_MOV, STR_END, 0, TMP3, 0);\n}\n\nstatic BOOL optimize_class(compiler_common *common, const sljit_u8 *bits, BOOL nclass, BOOL invert, jump_list **backtracks);\n\nstatic SLJIT_INLINE void fast_forward_start_bits(compiler_common *common)\n{\nDEFINE_COMPILER;\nconst sljit_u8 *start_bits = common->re->start_bitmap;\nstruct sljit_label *start;\nstruct sljit_jump *partial_quit;\n#if PCRE2_CODE_UNIT_WIDTH != 8\nstruct sljit_jump *found = NULL;\n#endif\njump_list *matches = NULL;\n\nif (common->match_end_ptr != 0)\n  {\n  OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(SLJIT_SP), common->match_end_ptr);\n  OP1(SLJIT_MOV, RETURN_ADDR, 0, STR_END, 0);\n  OP2(SLJIT_ADD, TMP1, 0, TMP1, 0, SLJIT_IMM, IN_UCHARS(1));\n  OP2(SLJIT_SUB | SLJIT_SET_GREATER, SLJIT_UNUSED, 0, STR_END, 0, TMP1, 0);\n  CMOV(SLJIT_GREATER, STR_END, TMP1, 0);\n  }\n\nstart = LABEL();\n\npartial_quit = CMP(SLJIT_GREATER_EQUAL, STR_PTR, 0, STR_END, 0);\nif (common->mode == PCRE2_JIT_COMPLETE)\n  add_jump(compiler, &common->failed_match, partial_quit);\n\nOP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(STR_PTR), 0);\nOP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n\nif (!optimize_class(common, start_bits, (start_bits\u00dd31\u00a8 & 0x80) != 0, FALSE, &matches))\n  {\n#if PCRE2_CODE_UNIT_WIDTH != 8\n  if ((start_bits\u00dd31\u00a8 & 0x80) != 0)\n    found = CMP(SLJIT_GREATER_EQUAL, TMP1, 0, SLJIT_IMM, 255);\n  else\n    CMPTO(SLJIT_GREATER_EQUAL, TMP1, 0, SLJIT_IMM, 255, start);\n#elif defined SUPPORT_UNICODE\n  if (common->utf && is_char7_bitset(start_bits, FALSE))\n    CMPTO(SLJIT_GREATER, TMP1, 0, SLJIT_IMM, 127, start);\n#endif\n  OP2(SLJIT_AND, TMP2, 0, TMP1, 0, SLJIT_IMM, 0x7);\n  OP2(SLJIT_LSHR, TMP1, 0, TMP1, 0, SLJIT_IMM, 3);\n  OP1(SLJIT_MOV_U8, TMP1, 0, SLJIT_MEM1(TMP1), (sljit_sw)start_bits);\n  if (!HAS_VIRTUAL_REGISTERS)\n    {\n    OP2(SLJIT_SHL, TMP3, 0, SLJIT_IMM, 1, TMP2, 0);\n    OP2(SLJIT_AND | SLJIT_SET_Z, SLJIT_UNUSED, 0, TMP1, 0, TMP3, 0);\n    }\n  else\n    {\n    OP2(SLJIT_SHL, TMP2, 0, SLJIT_IMM, 1, TMP2, 0);\n    OP2(SLJIT_AND | SLJIT_SET_Z, SLJIT_UNUSED, 0, TMP1, 0, TMP2, 0);\n    }\n  JUMPTO(SLJIT_ZERO, start);\n  }\nelse\n  set_jumps(matches, start);\n\n#if PCRE2_CODE_UNIT_WIDTH != 8\nif (found != NULL)\n  JUMPHERE(found);\n#endif\n\nOP2(SLJIT_SUB, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n\nif (common->mode != PCRE2_JIT_COMPLETE)\n  JUMPHERE(partial_quit);\n\nif (common->match_end_ptr != 0)\n  OP1(SLJIT_MOV, STR_END, 0, RETURN_ADDR, 0);\n}\n\nstatic SLJIT_INLINE jump_list *search_requested_char(compiler_common *common, PCRE2_UCHAR req_char, BOOL caseless, BOOL has_firstchar)\n{\nDEFINE_COMPILER;\nstruct sljit_label *loop;\nstruct sljit_jump *toolong;\nstruct sljit_jump *already_found;\nstruct sljit_jump *found;\nstruct sljit_jump *found_oc = NULL;\njump_list *not_found = NULL;\nsljit_u32 oc, bit;\n\nSLJIT_ASSERT(common->req_char_ptr != 0);\nOP2(SLJIT_ADD, TMP2, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(REQ_CU_MAX) * 100);\nOP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(SLJIT_SP), common->req_char_ptr);\ntoolong = CMP(SLJIT_LESS, TMP2, 0, STR_END, 0);\nalready_found = CMP(SLJIT_LESS, STR_PTR, 0, TMP1, 0);\n\nif (has_firstchar)\n  OP2(SLJIT_ADD, TMP1, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\nelse\n  OP1(SLJIT_MOV, TMP1, 0, STR_PTR, 0);\n\noc = req_char;\nif (caseless)\n  {\n  oc = TABLE_GET(req_char, common->fcc, req_char);\n#if defined SUPPORT_UNICODE\n  if (req_char > 127 && (common->utf || common->ucp))\n    oc = UCD_OTHERCASE(req_char);\n#endif\n  }\n\n#ifdef JIT_HAS_FAST_REQUESTED_CHAR_SIMD\nif (JIT_HAS_FAST_REQUESTED_CHAR_SIMD)\n  {\n  not_found = fast_requested_char_simd(common, req_char, oc);\n  }\nelse\n#endif\n  {\n  loop = LABEL();\n  add_jump(compiler, &not_found, CMP(SLJIT_GREATER_EQUAL, TMP1, 0, STR_END, 0));\n\n  OP1(MOV_UCHAR, TMP2, 0, SLJIT_MEM1(TMP1), 0);\n\n  if (req_char == oc)\n    found = CMP(SLJIT_EQUAL, TMP2, 0, SLJIT_IMM, req_char);\n  else\n    {\n    bit = req_char \u00ac oc;\n    if (is_powerof2(bit))\n      {\n       OP2(SLJIT_OR, TMP2, 0, TMP2, 0, SLJIT_IMM, bit);\n      found = CMP(SLJIT_EQUAL, TMP2, 0, SLJIT_IMM, req_char | bit);\n      }\n    else\n      {\n      found = CMP(SLJIT_EQUAL, TMP2, 0, SLJIT_IMM, req_char);\n      found_oc = CMP(SLJIT_EQUAL, TMP2, 0, SLJIT_IMM, oc);\n      }\n    }\n  OP2(SLJIT_ADD, TMP1, 0, TMP1, 0, SLJIT_IMM, IN_UCHARS(1));\n  JUMPTO(SLJIT_JUMP, loop);\n\n  JUMPHERE(found);\n  if (found_oc)\n    JUMPHERE(found_oc);\n  }\n\nOP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), common->req_char_ptr, TMP1, 0);\n\nJUMPHERE(already_found);\nJUMPHERE(toolong);\nreturn not_found;\n}\n\nstatic void do_revertframes(compiler_common *common)\n{\nDEFINE_COMPILER;\nstruct sljit_jump *jump;\nstruct sljit_label *mainloop;\n\nsljit_emit_fast_enter(compiler, RETURN_ADDR, 0);\nGET_LOCAL_BASE(TMP1, 0, 0);\n\n/* Drop frames until we reach STACK_TOP. */\nmainloop = LABEL();\nOP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(STACK_TOP), -sizeof(sljit_sw));\njump = CMP(SLJIT_SIG_LESS_EQUAL, TMP2, 0, SLJIT_IMM, 0);\n\nOP2(SLJIT_ADD, TMP2, 0, TMP2, 0, TMP1, 0);\nif (HAS_VIRTUAL_REGISTERS)\n  {\n  OP1(SLJIT_MOV, SLJIT_MEM1(TMP2), 0, SLJIT_MEM1(STACK_TOP), -(2 * sizeof(sljit_sw)));\n  OP1(SLJIT_MOV, SLJIT_MEM1(TMP2), sizeof(sljit_sw), SLJIT_MEM1(STACK_TOP), -(3 * sizeof(sljit_sw)));\n  OP2(SLJIT_SUB, STACK_TOP, 0, STACK_TOP, 0, SLJIT_IMM, 3 * sizeof(sljit_sw));\n  }\nelse\n  {\n  OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(STACK_TOP), -(2 * sizeof(sljit_sw)));\n  OP1(SLJIT_MOV, TMP3, 0, SLJIT_MEM1(STACK_TOP), -(3 * sizeof(sljit_sw)));\n  OP2(SLJIT_SUB, STACK_TOP, 0, STACK_TOP, 0, SLJIT_IMM, 3 * sizeof(sljit_sw));\n  OP1(SLJIT_MOV, SLJIT_MEM1(TMP2), 0, TMP1, 0);\n  GET_LOCAL_BASE(TMP1, 0, 0);\n  OP1(SLJIT_MOV, SLJIT_MEM1(TMP2), sizeof(sljit_sw), TMP3, 0);\n  }\nJUMPTO(SLJIT_JUMP, mainloop);\n\nJUMPHERE(jump);\njump = CMP(SLJIT_NOT_ZERO /* SIG_LESS */, TMP2, 0, SLJIT_IMM, 0);\n/* End of reverting values. */\nOP_SRC(SLJIT_FAST_RETURN, RETURN_ADDR, 0);\n\nJUMPHERE(jump);\nOP1(SLJIT_NEG, TMP2, 0, TMP2, 0);\nOP2(SLJIT_ADD, TMP2, 0, TMP2, 0, TMP1, 0);\nif (HAS_VIRTUAL_REGISTERS)\n  {\n  OP1(SLJIT_MOV, SLJIT_MEM1(TMP2), 0, SLJIT_MEM1(STACK_TOP), -(2 * sizeof(sljit_sw)));\n  OP2(SLJIT_SUB, STACK_TOP, 0, STACK_TOP, 0, SLJIT_IMM, 2 * sizeof(sljit_sw));\n  }\nelse\n  {\n  OP1(SLJIT_MOV, TMP3, 0, SLJIT_MEM1(STACK_TOP), -(2 * sizeof(sljit_sw)));\n  OP2(SLJIT_SUB, STACK_TOP, 0, STACK_TOP, 0, SLJIT_IMM, 2 * sizeof(sljit_sw));\n  OP1(SLJIT_MOV, SLJIT_MEM1(TMP2), 0, TMP3, 0);\n  }\nJUMPTO(SLJIT_JUMP, mainloop);\n}\n\nstatic void check_wordboundary(compiler_common *common)\n{\nDEFINE_COMPILER;\nstruct sljit_jump *skipread;\njump_list *skipread_list = NULL;\n#ifdef SUPPORT_UNICODE\nstruct sljit_label *valid_utf;\njump_list *invalid_utf1 = NULL;\n#endif /* SUPPORT_UNICODE */\njump_list *invalid_utf2 = NULL;\n#if PCRE2_CODE_UNIT_WIDTH != 8 || defined SUPPORT_UNICODE\nstruct sljit_jump *jump;\n#endif /* PCRE2_CODE_UNIT_WIDTH != 8 || SUPPORT_UNICODE */\n\nSLJIT_COMPILE_ASSERT(ctype_word == 0x10, ctype_word_must_be_16);\n\nsljit_emit_fast_enter(compiler, SLJIT_MEM1(SLJIT_SP), LOCALS0);\n/* Get type of the previous char, and put it to TMP3. */\nOP1(SLJIT_MOV, TMP1, 0, ARGUMENTS, 0);\nOP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(TMP1), SLJIT_OFFSETOF(jit_arguments, begin));\nOP1(SLJIT_MOV, TMP3, 0, SLJIT_IMM, 0);\nskipread = CMP(SLJIT_LESS_EQUAL, STR_PTR, 0, TMP2, 0);\n\n#ifdef SUPPORT_UNICODE\nif (common->invalid_utf)\n  {\n  peek_char_back(common, READ_CHAR_MAX, &invalid_utf1);\n\n  if (common->mode != PCRE2_JIT_COMPLETE)\n    {\n    OP1(SLJIT_MOV, TMP2, 0, STR_PTR, 0);\n    move_back(common, NULL, TRUE);\n    check_start_used_ptr(common);\n    OP1(SLJIT_MOV, STR_PTR, 0, TMP2, 0);\n    }\n  }\nelse\n#endif /* SUPPORT_UNICODE */\n  {\n  if (common->mode == PCRE2_JIT_COMPLETE)\n    peek_char_back(common, READ_CHAR_MAX, NULL);\n  else\n    {\n    move_back(common, NULL, TRUE);\n    check_start_used_ptr(common);\n    read_char(common, 0, READ_CHAR_MAX, NULL, READ_CHAR_UPDATE_STR_PTR);\n    }\n  }\n\n/* Testing char type. */\n#ifdef SUPPORT_UNICODE\nif (common->ucp)\n  {\n  OP1(SLJIT_MOV, TMP2, 0, SLJIT_IMM, 1);\n  jump = CMP(SLJIT_EQUAL, TMP1, 0, SLJIT_IMM, CHAR_UNDERSCORE);\n  add_jump(compiler, &common->getucdtype, JUMP(SLJIT_FAST_CALL));\n  OP2(SLJIT_SUB, TMP1, 0, TMP1, 0, SLJIT_IMM, ucp_Ll);\n  OP2(SLJIT_SUB | SLJIT_SET_LESS_EQUAL, SLJIT_UNUSED, 0, TMP1, 0, SLJIT_IMM, ucp_Lu - ucp_Ll);\n  OP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_LESS_EQUAL);\n  OP2(SLJIT_SUB, TMP1, 0, TMP1, 0, SLJIT_IMM, ucp_Nd - ucp_Ll);\n  OP2(SLJIT_SUB | SLJIT_SET_LESS_EQUAL, SLJIT_UNUSED, 0, TMP1, 0, SLJIT_IMM, ucp_No - ucp_Nd);\n  OP_FLAGS(SLJIT_OR, TMP2, 0, SLJIT_LESS_EQUAL);\n  JUMPHERE(jump);\n  OP1(SLJIT_MOV, TMP3, 0, TMP2, 0);\n  }\nelse\n#endif /* SUPPORT_UNICODE */\n  {\n#if PCRE2_CODE_UNIT_WIDTH != 8\n  jump = CMP(SLJIT_GREATER, TMP1, 0, SLJIT_IMM, 255);\n#elif defined SUPPORT_UNICODE\n  /* Here TMP3 has already been zeroed. */\n  jump = NULL;\n  if (common->utf)\n    jump = CMP(SLJIT_GREATER, TMP1, 0, SLJIT_IMM, 255);\n#endif /* PCRE2_CODE_UNIT_WIDTH == 8 */\n  OP1(SLJIT_MOV_U8, TMP1, 0, SLJIT_MEM1(TMP1), common->ctypes);\n  OP2(SLJIT_LSHR, TMP1, 0, TMP1, 0, SLJIT_IMM, 4 /* ctype_word */);\n  OP2(SLJIT_AND, TMP3, 0, TMP1, 0, SLJIT_IMM, 1);\n#if PCRE2_CODE_UNIT_WIDTH != 8\n  JUMPHERE(jump);\n#elif defined SUPPORT_UNICODE\n  if (jump != NULL)\n    JUMPHERE(jump);\n#endif /* PCRE2_CODE_UNIT_WIDTH == 8 */\n  }\nJUMPHERE(skipread);\n\nOP1(SLJIT_MOV, TMP2, 0, SLJIT_IMM, 0);\ncheck_str_end(common, &skipread_list);\npeek_char(common, READ_CHAR_MAX, SLJIT_MEM1(SLJIT_SP), LOCALS1, &invalid_utf2);\n\n/* Testing char type. This is a code duplication. */\n#ifdef SUPPORT_UNICODE\n\nvalid_utf = LABEL();\n\nif (common->ucp)\n  {\n  OP1(SLJIT_MOV, TMP2, 0, SLJIT_IMM, 1);\n  jump = CMP(SLJIT_EQUAL, TMP1, 0, SLJIT_IMM, CHAR_UNDERSCORE);\n  add_jump(compiler, &common->getucdtype, JUMP(SLJIT_FAST_CALL));\n  OP2(SLJIT_SUB, TMP1, 0, TMP1, 0, SLJIT_IMM, ucp_Ll);\n  OP2(SLJIT_SUB | SLJIT_SET_LESS_EQUAL, SLJIT_UNUSED, 0, TMP1, 0, SLJIT_IMM, ucp_Lu - ucp_Ll);\n  OP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_LESS_EQUAL);\n  OP2(SLJIT_SUB, TMP1, 0, TMP1, 0, SLJIT_IMM, ucp_Nd - ucp_Ll);\n  OP2(SLJIT_SUB | SLJIT_SET_LESS_EQUAL, SLJIT_UNUSED, 0, TMP1, 0, SLJIT_IMM, ucp_No - ucp_Nd);\n  OP_FLAGS(SLJIT_OR, TMP2, 0, SLJIT_LESS_EQUAL);\n  JUMPHERE(jump);\n  }\nelse\n#endif /* SUPPORT_UNICODE */\n  {\n#if PCRE2_CODE_UNIT_WIDTH != 8\n  /* TMP2 may be destroyed by peek_char. */\n  OP1(SLJIT_MOV, TMP2, 0, SLJIT_IMM, 0);\n  jump = CMP(SLJIT_GREATER, TMP1, 0, SLJIT_IMM, 255);\n#elif defined SUPPORT_UNICODE\n  OP1(SLJIT_MOV, TMP2, 0, SLJIT_IMM, 0);\n  jump = NULL;\n  if (common->utf)\n    jump = CMP(SLJIT_GREATER, TMP1, 0, SLJIT_IMM, 255);\n#endif\n  OP1(SLJIT_MOV_U8, TMP2, 0, SLJIT_MEM1(TMP1), common->ctypes);\n  OP2(SLJIT_LSHR, TMP2, 0, TMP2, 0, SLJIT_IMM, 4 /* ctype_word */);\n  OP2(SLJIT_AND, TMP2, 0, TMP2, 0, SLJIT_IMM, 1);\n#if PCRE2_CODE_UNIT_WIDTH != 8\n  JUMPHERE(jump);\n#elif defined SUPPORT_UNICODE\n  if (jump != NULL)\n    JUMPHERE(jump);\n#endif /* PCRE2_CODE_UNIT_WIDTH == 8 */\n  }\nset_jumps(skipread_list, LABEL());\n\nOP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(SLJIT_SP), LOCALS0);\nOP2(SLJIT_XOR | SLJIT_SET_Z, TMP2, 0, TMP2, 0, TMP3, 0);\nOP_SRC(SLJIT_FAST_RETURN, TMP1, 0);\n\n#ifdef SUPPORT_UNICODE\nif (common->invalid_utf)\n  {\n  set_jumps(invalid_utf1, LABEL());\n\n  peek_char(common, READ_CHAR_MAX, SLJIT_MEM1(SLJIT_SP), LOCALS1, NULL);\n  CMPTO(SLJIT_NOT_EQUAL, TMP1, 0, SLJIT_IMM, INVALID_UTF_CHAR, valid_utf);\n\n  OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(SLJIT_SP), LOCALS0);\n  OP1(SLJIT_MOV, TMP2, 0, SLJIT_IMM, -1);\n  OP_SRC(SLJIT_FAST_RETURN, TMP1, 0);\n\n  set_jumps(invalid_utf2, LABEL());\n  OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(SLJIT_SP), LOCALS0);\n  OP1(SLJIT_MOV, TMP2, 0, TMP3, 0);\n  OP_SRC(SLJIT_FAST_RETURN, TMP1, 0);\n  }\n#endif /* SUPPORT_UNICODE */\n}\n\nstatic BOOL optimize_class_ranges(compiler_common *common, const sljit_u8 *bits, BOOL nclass, BOOL invert, jump_list **backtracks)\n{\n/* May destroy TMP1. */\nDEFINE_COMPILER;\nint ranges\u00ddMAX_CLASS_RANGE_SIZE\u00a8;\nsljit_u8 bit, cbit, all;\nint i, byte, length = 0;\n\nbit = bits\u00dd0\u00a8 & 0x1;\n/* All bits will be zero or one (since bit is zero or one). */\nall = -bit;\n\nfor (i = 0; i < 256; )\n  {\n  byte = i >> 3;\n  if ((i & 0x7) == 0 && bits\u00ddbyte\u00a8 == all)\n    i += 8;\n  else\n    {\n    cbit = (bits\u00ddbyte\u00a8 >> (i & 0x7)) & 0x1;\n    if (cbit != bit)\n      {\n      if (length >= MAX_CLASS_RANGE_SIZE)\n        return FALSE;\n      ranges\u00ddlength\u00a8 = i;\n      length++;\n      bit = cbit;\n      all = -cbit;\n      }\n    i++;\n    }\n  }\n\nif (((bit == 0) && nclass) || ((bit == 1) && !nclass))\n  {\n  if (length >= MAX_CLASS_RANGE_SIZE)\n    return FALSE;\n  ranges\u00ddlength\u00a8 = 256;\n  length++;\n  }\n\nif (length < 0 || length > 4)\n  return FALSE;\n\nbit = bits\u00dd0\u00a8 & 0x1;\nif (invert) bit \u00ac= 0x1;\n\n/* No character is accepted. */\nif (length == 0 && bit == 0)\n  add_jump(compiler, backtracks, JUMP(SLJIT_JUMP));\n\nswitch(length)\n  {\n  case 0:\n  /* When bit != 0, all characters are accepted. */\n  return TRUE;\n\n  case 1:\n  add_jump(compiler, backtracks, CMP(bit == 0 ? SLJIT_LESS : SLJIT_GREATER_EQUAL, TMP1, 0, SLJIT_IMM, ranges\u00dd0\u00a8));\n  return TRUE;\n\n  case 2:\n  if (ranges\u00dd0\u00a8 + 1 != ranges\u00dd1\u00a8)\n    {\n    OP2(SLJIT_SUB, TMP1, 0, TMP1, 0, SLJIT_IMM, ranges\u00dd0\u00a8);\n    add_jump(compiler, backtracks, CMP(bit != 0 ? SLJIT_LESS : SLJIT_GREATER_EQUAL, TMP1, 0, SLJIT_IMM, ranges\u00dd1\u00a8 - ranges\u00dd0\u00a8));\n    }\n  else\n    add_jump(compiler, backtracks, CMP(bit != 0 ? SLJIT_EQUAL : SLJIT_NOT_EQUAL, TMP1, 0, SLJIT_IMM, ranges\u00dd0\u00a8));\n  return TRUE;\n\n  case 3:\n  if (bit != 0)\n    {\n    add_jump(compiler, backtracks, CMP(SLJIT_GREATER_EQUAL, TMP1, 0, SLJIT_IMM, ranges\u00dd2\u00a8));\n    if (ranges\u00dd0\u00a8 + 1 != ranges\u00dd1\u00a8)\n      {\n      OP2(SLJIT_SUB, TMP1, 0, TMP1, 0, SLJIT_IMM, ranges\u00dd0\u00a8);\n      add_jump(compiler, backtracks, CMP(SLJIT_LESS, TMP1, 0, SLJIT_IMM, ranges\u00dd1\u00a8 - ranges\u00dd0\u00a8));\n      }\n    else\n      add_jump(compiler, backtracks, CMP(SLJIT_EQUAL, TMP1, 0, SLJIT_IMM, ranges\u00dd0\u00a8));\n    return TRUE;\n    }\n\n  add_jump(compiler, backtracks, CMP(SLJIT_LESS, TMP1, 0, SLJIT_IMM, ranges\u00dd0\u00a8));\n  if (ranges\u00dd1\u00a8 + 1 != ranges\u00dd2\u00a8)\n    {\n    OP2(SLJIT_SUB, TMP1, 0, TMP1, 0, SLJIT_IMM, ranges\u00dd1\u00a8);\n    add_jump(compiler, backtracks, CMP(SLJIT_LESS, TMP1, 0, SLJIT_IMM, ranges\u00dd2\u00a8 - ranges\u00dd1\u00a8));\n    }\n  else\n    add_jump(compiler, backtracks, CMP(SLJIT_EQUAL, TMP1, 0, SLJIT_IMM, ranges\u00dd1\u00a8));\n  return TRUE;\n\n  case 4:\n  if ((ranges\u00dd1\u00a8 - ranges\u00dd0\u00a8) == (ranges\u00dd3\u00a8 - ranges\u00dd2\u00a8)\n      && (ranges\u00dd0\u00a8 | (ranges\u00dd2\u00a8 - ranges\u00dd0\u00a8)) == ranges\u00dd2\u00a8\n      && (ranges\u00dd1\u00a8 & (ranges\u00dd2\u00a8 - ranges\u00dd0\u00a8)) == 0\n      && is_powerof2(ranges\u00dd2\u00a8 - ranges\u00dd0\u00a8))\n    {\n    SLJIT_ASSERT((ranges\u00dd0\u00a8 & (ranges\u00dd2\u00a8 - ranges\u00dd0\u00a8)) == 0 && (ranges\u00dd2\u00a8 & ranges\u00dd3\u00a8 & (ranges\u00dd2\u00a8 - ranges\u00dd0\u00a8)) != 0);\n    OP2(SLJIT_OR, TMP1, 0, TMP1, 0, SLJIT_IMM, ranges\u00dd2\u00a8 - ranges\u00dd0\u00a8);\n    if (ranges\u00dd2\u00a8 + 1 != ranges\u00dd3\u00a8)\n      {\n      OP2(SLJIT_SUB, TMP1, 0, TMP1, 0, SLJIT_IMM, ranges\u00dd2\u00a8);\n      add_jump(compiler, backtracks, CMP(bit != 0 ? SLJIT_LESS : SLJIT_GREATER_EQUAL, TMP1, 0, SLJIT_IMM, ranges\u00dd3\u00a8 - ranges\u00dd2\u00a8));\n      }\n    else\n      add_jump(compiler, backtracks, CMP(bit != 0 ? SLJIT_EQUAL : SLJIT_NOT_EQUAL, TMP1, 0, SLJIT_IMM, ranges\u00dd2\u00a8));\n    return TRUE;\n    }\n\n  if (bit != 0)\n    {\n    i = 0;\n    if (ranges\u00dd0\u00a8 + 1 != ranges\u00dd1\u00a8)\n      {\n      OP2(SLJIT_SUB, TMP1, 0, TMP1, 0, SLJIT_IMM, ranges\u00dd0\u00a8);\n      add_jump(compiler, backtracks, CMP(SLJIT_LESS, TMP1, 0, SLJIT_IMM, ranges\u00dd1\u00a8 - ranges\u00dd0\u00a8));\n      i = ranges\u00dd0\u00a8;\n      }\n    else\n      add_jump(compiler, backtracks, CMP(SLJIT_EQUAL, TMP1, 0, SLJIT_IMM, ranges\u00dd0\u00a8));\n\n    if (ranges\u00dd2\u00a8 + 1 != ranges\u00dd3\u00a8)\n      {\n      OP2(SLJIT_SUB, TMP1, 0, TMP1, 0, SLJIT_IMM, ranges\u00dd2\u00a8 - i);\n      add_jump(compiler, backtracks, CMP(SLJIT_LESS, TMP1, 0, SLJIT_IMM, ranges\u00dd3\u00a8 - ranges\u00dd2\u00a8));\n      }\n    else\n      add_jump(compiler, backtracks, CMP(SLJIT_EQUAL, TMP1, 0, SLJIT_IMM, ranges\u00dd2\u00a8 - i));\n    return TRUE;\n    }\n\n  OP2(SLJIT_SUB, TMP1, 0, TMP1, 0, SLJIT_IMM, ranges\u00dd0\u00a8);\n  add_jump(compiler, backtracks, CMP(SLJIT_GREATER_EQUAL, TMP1, 0, SLJIT_IMM, ranges\u00dd3\u00a8 - ranges\u00dd0\u00a8));\n  if (ranges\u00dd1\u00a8 + 1 != ranges\u00dd2\u00a8)\n    {\n    OP2(SLJIT_SUB, TMP1, 0, TMP1, 0, SLJIT_IMM, ranges\u00dd1\u00a8 - ranges\u00dd0\u00a8);\n    add_jump(compiler, backtracks, CMP(SLJIT_LESS, TMP1, 0, SLJIT_IMM, ranges\u00dd2\u00a8 - ranges\u00dd1\u00a8));\n    }\n  else\n    add_jump(compiler, backtracks, CMP(SLJIT_EQUAL, TMP1, 0, SLJIT_IMM, ranges\u00dd1\u00a8 - ranges\u00dd0\u00a8));\n  return TRUE;\n\n  default:\n  SLJIT_UNREACHABLE();\n  return FALSE;\n  }\n}\n\nstatic BOOL optimize_class_chars(compiler_common *common, const sljit_u8 *bits, BOOL nclass, BOOL invert, jump_list **backtracks)\n{\n/* May destroy TMP1. */\nDEFINE_COMPILER;\nuint16_t char_list\u00ddMAX_CLASS_CHARS_SIZE\u00a8;\nuint8_t byte;\nsljit_s32 type;\nint i, j, k, len, c;\n\nif (!sljit_has_cpu_feature(SLJIT_HAS_CMOV))\n  return FALSE;\n\nlen = 0;\n\nfor (i = 0; i < 32; i++)\n  {\n  byte = bits\u00ddi\u00a8;\n\n  if (nclass)\n    byte = ~byte;\n\n  j = 0;\n  while (byte != 0)\n    {\n    if (byte & 0x1)\n      {\n      c = i * 8 + j;\n\n      k = len;\n\n      if ((c & 0x20) != 0)\n        {\n        for (k = 0; k < len; k++)\n          if (char_list\u00ddk\u00a8 == c - 0x20)\n            {\n            char_list\u00ddk\u00a8 |= 0x120;\n            break;\n            }\n        }\n\n      if (k == len)\n        {\n        if (len >= MAX_CLASS_CHARS_SIZE)\n          return FALSE;\n\n        char_list\u00ddlen++\u00a8 = (uint16_t) c;\n        }\n      }\n\n    byte >>= 1;\n    j++;\n    }\n  }\n\nif (len == 0) return FALSE;  /* Should never occur, but stops analyzers complaining. */\n\ni = 0;\nj = 0;\n\nif (char_list\u00dd0\u00a8 == 0)\n  {\n  i++;\n  OP2(SLJIT_SUB | SLJIT_SET_Z, SLJIT_UNUSED, 0, TMP1, 0, SLJIT_IMM, 0);\n  OP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_ZERO);\n  }\nelse\n  OP1(SLJIT_MOV, TMP2, 0, SLJIT_IMM, 0);\n\nwhile (i < len)\n  {\n  if ((char_list\u00ddi\u00a8 & 0x100) != 0)\n    j++;\n  else\n    {\n    OP2(SLJIT_SUB | SLJIT_SET_Z, SLJIT_UNUSED, 0, TMP1, 0, SLJIT_IMM, char_list\u00ddi\u00a8);\n    CMOV(SLJIT_ZERO, TMP2, TMP1, 0);\n    }\n  i++;\n  }\n\nif (j != 0)\n  {\n  OP2(SLJIT_OR, TMP1, 0, TMP1, 0, SLJIT_IMM, 0x20);\n\n  for (i = 0; i < len; i++)\n    if ((char_list\u00ddi\u00a8 & 0x100) != 0)\n      {\n      j--;\n      OP2(SLJIT_SUB | SLJIT_SET_Z, SLJIT_UNUSED, 0, TMP1, 0, SLJIT_IMM, char_list\u00ddi\u00a8 & 0xff);\n      CMOV(SLJIT_ZERO, TMP2, TMP1, 0);\n      }\n  }\n\nif (invert)\n  nclass = !nclass;\n\ntype = nclass ? SLJIT_NOT_EQUAL : SLJIT_EQUAL;\nadd_jump(compiler, backtracks, CMP(type, TMP2, 0, SLJIT_IMM, 0));\nreturn TRUE;\n}\n\nstatic BOOL optimize_class(compiler_common *common, const sljit_u8 *bits, BOOL nclass, BOOL invert, jump_list **backtracks)\n{\n/* May destroy TMP1. */\nif (optimize_class_ranges(common, bits, nclass, invert, backtracks))\n  return TRUE;\nreturn optimize_class_chars(common, bits, nclass, invert, backtracks);\n}\n\nstatic void check_anynewline(compiler_common *common)\n{\n/* Check whether TMP1 contains a newline character. TMP2 destroyed. */\nDEFINE_COMPILER;\n\nsljit_emit_fast_enter(compiler, RETURN_ADDR, 0);\n\nOP2(SLJIT_SUB, TMP1, 0, TMP1, 0, SLJIT_IMM, 0x0a);\nOP2(SLJIT_SUB | SLJIT_SET_LESS_EQUAL, SLJIT_UNUSED, 0, TMP1, 0, SLJIT_IMM, 0x0d - 0x0a);\nOP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_LESS_EQUAL);\nOP2(SLJIT_SUB | SLJIT_SET_Z, SLJIT_UNUSED, 0, TMP1, 0, SLJIT_IMM, 0x85 - 0x0a);\n#if defined SUPPORT_UNICODE || PCRE2_CODE_UNIT_WIDTH == 16 || PCRE2_CODE_UNIT_WIDTH == 32\n#if PCRE2_CODE_UNIT_WIDTH == 8\nif (common->utf)\n  {\n#endif\n  OP_FLAGS(SLJIT_OR, TMP2, 0, SLJIT_EQUAL);\n  OP2(SLJIT_OR, TMP1, 0, TMP1, 0, SLJIT_IMM, 0x1);\n  OP2(SLJIT_SUB | SLJIT_SET_Z, SLJIT_UNUSED, 0, TMP1, 0, SLJIT_IMM, 0x2029 - 0x0a);\n#if PCRE2_CODE_UNIT_WIDTH == 8\n  }\n#endif\n#endif /* SUPPORT_UNICODE || PCRE2_CODE_UNIT_WIDTH == \u00dd16|32\u00a8 */\nOP_FLAGS(SLJIT_OR | SLJIT_SET_Z, TMP2, 0, SLJIT_EQUAL);\nOP_SRC(SLJIT_FAST_RETURN, RETURN_ADDR, 0);\n}\n\nstatic void check_hspace(compiler_common *common)\n{\n/* Check whether TMP1 contains a newline character. TMP2 destroyed. */\nDEFINE_COMPILER;\n\nsljit_emit_fast_enter(compiler, RETURN_ADDR, 0);\n\nOP2(SLJIT_SUB | SLJIT_SET_Z, SLJIT_UNUSED, 0, TMP1, 0, SLJIT_IMM, 0x09);\nOP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_EQUAL);\nOP2(SLJIT_SUB | SLJIT_SET_Z, SLJIT_UNUSED, 0, TMP1, 0, SLJIT_IMM, 0x20);\nOP_FLAGS(SLJIT_OR, TMP2, 0, SLJIT_EQUAL);\nOP2(SLJIT_SUB | SLJIT_SET_Z, SLJIT_UNUSED, 0, TMP1, 0, SLJIT_IMM, 0xa0);\n#if defined SUPPORT_UNICODE || PCRE2_CODE_UNIT_WIDTH == 16 || PCRE2_CODE_UNIT_WIDTH == 32\n#if PCRE2_CODE_UNIT_WIDTH == 8\nif (common->utf)\n  {\n#endif\n  OP_FLAGS(SLJIT_OR, TMP2, 0, SLJIT_EQUAL);\n  OP2(SLJIT_SUB | SLJIT_SET_Z, SLJIT_UNUSED, 0, TMP1, 0, SLJIT_IMM, 0x1680);\n  OP_FLAGS(SLJIT_OR, TMP2, 0, SLJIT_EQUAL);\n  OP2(SLJIT_SUB | SLJIT_SET_Z, SLJIT_UNUSED, 0, TMP1, 0, SLJIT_IMM, 0x180e);\n  OP_FLAGS(SLJIT_OR, TMP2, 0, SLJIT_EQUAL);\n  OP2(SLJIT_SUB, TMP1, 0, TMP1, 0, SLJIT_IMM, 0x2000);\n  OP2(SLJIT_SUB | SLJIT_SET_LESS_EQUAL, SLJIT_UNUSED, 0, TMP1, 0, SLJIT_IMM, 0x200A - 0x2000);\n  OP_FLAGS(SLJIT_OR, TMP2, 0, SLJIT_LESS_EQUAL);\n  OP2(SLJIT_SUB | SLJIT_SET_Z, SLJIT_UNUSED, 0, TMP1, 0, SLJIT_IMM, 0x202f - 0x2000);\n  OP_FLAGS(SLJIT_OR, TMP2, 0, SLJIT_EQUAL);\n  OP2(SLJIT_SUB | SLJIT_SET_Z, SLJIT_UNUSED, 0, TMP1, 0, SLJIT_IMM, 0x205f - 0x2000);\n  OP_FLAGS(SLJIT_OR, TMP2, 0, SLJIT_EQUAL);\n  OP2(SLJIT_SUB | SLJIT_SET_Z, SLJIT_UNUSED, 0, TMP1, 0, SLJIT_IMM, 0x3000 - 0x2000);\n#if PCRE2_CODE_UNIT_WIDTH == 8\n  }\n#endif\n#endif /* SUPPORT_UNICODE || PCRE2_CODE_UNIT_WIDTH == \u00dd16|32\u00a8 */\nOP_FLAGS(SLJIT_OR | SLJIT_SET_Z, TMP2, 0, SLJIT_EQUAL);\n\nOP_SRC(SLJIT_FAST_RETURN, RETURN_ADDR, 0);\n}\n\nstatic void check_vspace(compiler_common *common)\n{\n/* Check whether TMP1 contains a newline character. TMP2 destroyed. */\nDEFINE_COMPILER;\n\nsljit_emit_fast_enter(compiler, RETURN_ADDR, 0);\n\nOP2(SLJIT_SUB, TMP1, 0, TMP1, 0, SLJIT_IMM, 0x0a);\nOP2(SLJIT_SUB | SLJIT_SET_LESS_EQUAL, SLJIT_UNUSED, 0, TMP1, 0, SLJIT_IMM, 0x0d - 0x0a);\nOP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_LESS_EQUAL);\nOP2(SLJIT_SUB | SLJIT_SET_Z, SLJIT_UNUSED, 0, TMP1, 0, SLJIT_IMM, 0x85 - 0x0a);\n#if defined SUPPORT_UNICODE || PCRE2_CODE_UNIT_WIDTH == 16 || PCRE2_CODE_UNIT_WIDTH == 32\n#if PCRE2_CODE_UNIT_WIDTH == 8\nif (common->utf)\n  {\n#endif\n  OP_FLAGS(SLJIT_OR, TMP2, 0, SLJIT_EQUAL);\n  OP2(SLJIT_OR, TMP1, 0, TMP1, 0, SLJIT_IMM, 0x1);\n  OP2(SLJIT_SUB | SLJIT_SET_Z, SLJIT_UNUSED, 0, TMP1, 0, SLJIT_IMM, 0x2029 - 0x0a);\n#if PCRE2_CODE_UNIT_WIDTH == 8\n  }\n#endif\n#endif /* SUPPORT_UNICODE || PCRE2_CODE_UNIT_WIDTH == \u00dd16|32\u00a8 */\nOP_FLAGS(SLJIT_OR | SLJIT_SET_Z, TMP2, 0, SLJIT_EQUAL);\n\nOP_SRC(SLJIT_FAST_RETURN, RETURN_ADDR, 0);\n}\n\nstatic void do_casefulcmp(compiler_common *common)\n{\nDEFINE_COMPILER;\nstruct sljit_jump *jump;\nstruct sljit_label *label;\nint char1_reg;\nint char2_reg;\n\nif (HAS_VIRTUAL_REGISTERS)\n  {\n  char1_reg = STR_END;\n  char2_reg = STACK_TOP;\n  }\nelse\n  {\n  char1_reg = TMP3;\n  char2_reg = RETURN_ADDR;\n  }\n\nsljit_emit_fast_enter(compiler, SLJIT_MEM1(SLJIT_SP), LOCALS0);\nOP2(SLJIT_SUB, STR_PTR, 0, STR_PTR, 0, TMP2, 0);\n\nif (char1_reg == STR_END)\n  {\n  OP1(SLJIT_MOV, TMP3, 0, char1_reg, 0);\n  OP1(SLJIT_MOV, RETURN_ADDR, 0, char2_reg, 0);\n  }\n\nif (sljit_emit_mem(compiler, MOV_UCHAR | SLJIT_MEM_SUPP | SLJIT_MEM_POST, char1_reg, SLJIT_MEM1(TMP1), IN_UCHARS(1)) == SLJIT_SUCCESS)\n  {\n  label = LABEL();\n  sljit_emit_mem(compiler, MOV_UCHAR | SLJIT_MEM_POST, char1_reg, SLJIT_MEM1(TMP1), IN_UCHARS(1));\n  sljit_emit_mem(compiler, MOV_UCHAR | SLJIT_MEM_POST, char2_reg, SLJIT_MEM1(STR_PTR), IN_UCHARS(1));\n  jump = CMP(SLJIT_NOT_EQUAL, char1_reg, 0, char2_reg, 0);\n  OP2(SLJIT_SUB | SLJIT_SET_Z, TMP2, 0, TMP2, 0, SLJIT_IMM, IN_UCHARS(1));\n  JUMPTO(SLJIT_NOT_ZERO, label);\n\n  JUMPHERE(jump);\n  OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(SLJIT_SP), LOCALS0);\n  }\nelse if (sljit_emit_mem(compiler, MOV_UCHAR | SLJIT_MEM_SUPP | SLJIT_MEM_PRE, char1_reg, SLJIT_MEM1(TMP1), IN_UCHARS(1)) == SLJIT_SUCCESS)\n  {\n  OP2(SLJIT_SUB, TMP1, 0, TMP1, 0, SLJIT_IMM, IN_UCHARS(1));\n  OP2(SLJIT_SUB, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n\n  label = LABEL();\n  sljit_emit_mem(compiler, MOV_UCHAR | SLJIT_MEM_PRE, char1_reg, SLJIT_MEM1(TMP1), IN_UCHARS(1));\n  sljit_emit_mem(compiler, MOV_UCHAR | SLJIT_MEM_PRE, char2_reg, SLJIT_MEM1(STR_PTR), IN_UCHARS(1));\n  jump = CMP(SLJIT_NOT_EQUAL, char1_reg, 0, char2_reg, 0);\n  OP2(SLJIT_SUB | SLJIT_SET_Z, TMP2, 0, TMP2, 0, SLJIT_IMM, IN_UCHARS(1));\n  JUMPTO(SLJIT_NOT_ZERO, label);\n\n  JUMPHERE(jump);\n  OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(SLJIT_SP), LOCALS0);\n  OP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n  }\nelse\n  {\n  label = LABEL();\n  OP1(MOV_UCHAR, char1_reg, 0, SLJIT_MEM1(TMP1), 0);\n  OP1(MOV_UCHAR, char2_reg, 0, SLJIT_MEM1(STR_PTR), 0);\n  OP2(SLJIT_ADD, TMP1, 0, TMP1, 0, SLJIT_IMM, IN_UCHARS(1));\n  OP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n  jump = CMP(SLJIT_NOT_EQUAL, char1_reg, 0, char2_reg, 0);\n  OP2(SLJIT_SUB | SLJIT_SET_Z, TMP2, 0, TMP2, 0, SLJIT_IMM, IN_UCHARS(1));\n  JUMPTO(SLJIT_NOT_ZERO, label);\n\n  JUMPHERE(jump);\n  OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(SLJIT_SP), LOCALS0);\n  }\n\nif (char1_reg == STR_END)\n  {\n  OP1(SLJIT_MOV, char1_reg, 0, TMP3, 0);\n  OP1(SLJIT_MOV, char2_reg, 0, RETURN_ADDR, 0);\n  }\n\nOP_SRC(SLJIT_FAST_RETURN, TMP1, 0);\n}\n\nstatic void do_caselesscmp(compiler_common *common)\n{\nDEFINE_COMPILER;\nstruct sljit_jump *jump;\nstruct sljit_label *label;\nint char1_reg = STR_END;\nint char2_reg;\nint lcc_table;\nint opt_type = 0;\n\nif (HAS_VIRTUAL_REGISTERS)\n  {\n  char2_reg = STACK_TOP;\n  lcc_table = STACK_LIMIT;\n  }\nelse\n  {\n  char2_reg = RETURN_ADDR;\n  lcc_table = TMP3;\n  }\n\nif (sljit_emit_mem(compiler, MOV_UCHAR | SLJIT_MEM_SUPP | SLJIT_MEM_POST, char1_reg, SLJIT_MEM1(TMP1), IN_UCHARS(1)) == SLJIT_SUCCESS)\n  opt_type = 1;\nelse if (sljit_emit_mem(compiler, MOV_UCHAR | SLJIT_MEM_SUPP | SLJIT_MEM_PRE, char1_reg, SLJIT_MEM1(TMP1), IN_UCHARS(1)) == SLJIT_SUCCESS)\n  opt_type = 2;\n\nsljit_emit_fast_enter(compiler, SLJIT_MEM1(SLJIT_SP), LOCALS0);\nOP2(SLJIT_SUB, STR_PTR, 0, STR_PTR, 0, TMP2, 0);\n\nOP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), LOCALS1, char1_reg, 0);\n\nif (char2_reg == STACK_TOP)\n  {\n  OP1(SLJIT_MOV, TMP3, 0, char2_reg, 0);\n  OP1(SLJIT_MOV, RETURN_ADDR, 0, lcc_table, 0);\n  }\n\nOP1(SLJIT_MOV, lcc_table, 0, SLJIT_IMM, common->lcc);\n\nif (opt_type == 1)\n  {\n  label = LABEL();\n  sljit_emit_mem(compiler, MOV_UCHAR | SLJIT_MEM_POST, char1_reg, SLJIT_MEM1(TMP1), IN_UCHARS(1));\n  sljit_emit_mem(compiler, MOV_UCHAR | SLJIT_MEM_POST, char2_reg, SLJIT_MEM1(STR_PTR), IN_UCHARS(1));\n  }\nelse if (opt_type == 2)\n  {\n  OP2(SLJIT_SUB, TMP1, 0, TMP1, 0, SLJIT_IMM, IN_UCHARS(1));\n  OP2(SLJIT_SUB, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n\n  label = LABEL();\n  sljit_emit_mem(compiler, MOV_UCHAR | SLJIT_MEM_PRE, char1_reg, SLJIT_MEM1(TMP1), IN_UCHARS(1));\n  sljit_emit_mem(compiler, MOV_UCHAR | SLJIT_MEM_PRE, char2_reg, SLJIT_MEM1(STR_PTR), IN_UCHARS(1));\n  }\nelse\n  {\n  label = LABEL();\n  OP1(MOV_UCHAR, char1_reg, 0, SLJIT_MEM1(TMP1), 0);\n  OP1(MOV_UCHAR, char2_reg, 0, SLJIT_MEM1(STR_PTR), 0);\n  OP2(SLJIT_ADD, TMP1, 0, TMP1, 0, SLJIT_IMM, IN_UCHARS(1));\n  }\n\n#if PCRE2_CODE_UNIT_WIDTH != 8\njump = CMP(SLJIT_GREATER, char1_reg, 0, SLJIT_IMM, 255);\n#endif\nOP1(SLJIT_MOV_U8, char1_reg, 0, SLJIT_MEM2(lcc_table, char1_reg), 0);\n#if PCRE2_CODE_UNIT_WIDTH != 8\nJUMPHERE(jump);\njump = CMP(SLJIT_GREATER, char2_reg, 0, SLJIT_IMM, 255);\n#endif\nOP1(SLJIT_MOV_U8, char2_reg, 0, SLJIT_MEM2(lcc_table, char2_reg), 0);\n#if PCRE2_CODE_UNIT_WIDTH != 8\nJUMPHERE(jump);\n#endif\n\nif (opt_type == 0)\n  OP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n\njump = CMP(SLJIT_NOT_EQUAL, char1_reg, 0, char2_reg, 0);\nOP2(SLJIT_SUB | SLJIT_SET_Z, TMP2, 0, TMP2, 0, SLJIT_IMM, IN_UCHARS(1));\nJUMPTO(SLJIT_NOT_ZERO, label);\n\nJUMPHERE(jump);\nOP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(SLJIT_SP), LOCALS0);\n\nif (opt_type == 2)\n  OP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n\nif (char2_reg == STACK_TOP)\n  {\n  OP1(SLJIT_MOV, char2_reg, 0, TMP3, 0);\n  OP1(SLJIT_MOV, lcc_table, 0, RETURN_ADDR, 0);\n  }\n\nOP1(SLJIT_MOV, char1_reg, 0, SLJIT_MEM1(SLJIT_SP), LOCALS1);\nOP_SRC(SLJIT_FAST_RETURN, TMP1, 0);\n}\n\nstatic PCRE2_SPTR byte_sequence_compare(compiler_common *common, BOOL caseless, PCRE2_SPTR cc,\n    compare_context *context, jump_list **backtracks)\n{\nDEFINE_COMPILER;\nunsigned int othercasebit = 0;\nPCRE2_SPTR othercasechar = NULL;\n#ifdef SUPPORT_UNICODE\nint utflength;\n#endif\n\nif (caseless && char_has_othercase(common, cc))\n  {\n  othercasebit = char_get_othercase_bit(common, cc);\n  SLJIT_ASSERT(othercasebit);\n  /* Extracting bit difference info. */\n#if PCRE2_CODE_UNIT_WIDTH == 8\n  othercasechar = cc + (othercasebit >> 8);\n  othercasebit &= 0xff;\n#elif PCRE2_CODE_UNIT_WIDTH == 16 || PCRE2_CODE_UNIT_WIDTH == 32\n  /* Note that this code only handles characters in the BMP. If there\n  ever are characters outside the BMP whose othercase differs in only one\n  bit from itself (there currently are none), this code will need to be\n  revised for PCRE2_CODE_UNIT_WIDTH == 32. */\n  othercasechar = cc + (othercasebit >> 9);\n  if ((othercasebit & 0x100) != 0)\n    othercasebit = (othercasebit & 0xff) << 8;\n  else\n    othercasebit &= 0xff;\n#endif /* PCRE2_CODE_UNIT_WIDTH == \u00dd8|16|32\u00a8 */\n  }\n\nif (context->sourcereg == -1)\n  {\n#if PCRE2_CODE_UNIT_WIDTH == 8\n#if defined SLJIT_UNALIGNED && SLJIT_UNALIGNED\n  if (context->length >= 4)\n    OP1(SLJIT_MOV_S32, TMP1, 0, SLJIT_MEM1(STR_PTR), -context->length);\n  else if (context->length >= 2)\n    OP1(SLJIT_MOV_U16, TMP1, 0, SLJIT_MEM1(STR_PTR), -context->length);\n  else\n#endif\n    OP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(STR_PTR), -context->length);\n#elif PCRE2_CODE_UNIT_WIDTH == 16\n#if defined SLJIT_UNALIGNED && SLJIT_UNALIGNED\n  if (context->length >= 4)\n    OP1(SLJIT_MOV_S32, TMP1, 0, SLJIT_MEM1(STR_PTR), -context->length);\n  else\n#endif\n    OP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(STR_PTR), -context->length);\n#elif PCRE2_CODE_UNIT_WIDTH == 32\n  OP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(STR_PTR), -context->length);\n#endif /* PCRE2_CODE_UNIT_WIDTH == \u00dd8|16|32\u00a8 */\n  context->sourcereg = TMP2;\n  }\n\n#ifdef SUPPORT_UNICODE\nutflength = 1;\nif (common->utf && HAS_EXTRALEN(*cc))\n  utflength += GET_EXTRALEN(*cc);\n\ndo\n  {\n#endif\n\n  context->length -= IN_UCHARS(1);\n#if (defined SLJIT_UNALIGNED && SLJIT_UNALIGNED) && (PCRE2_CODE_UNIT_WIDTH == 8 || PCRE2_CODE_UNIT_WIDTH == 16)\n\n  /* Unaligned read is supported. */\n  if (othercasebit != 0 && othercasechar == cc)\n    {\n    context->c.asuchars\u00ddcontext->ucharptr\u00a8 = *cc | othercasebit;\n    context->oc.asuchars\u00ddcontext->ucharptr\u00a8 = othercasebit;\n    }\n  else\n    {\n    context->c.asuchars\u00ddcontext->ucharptr\u00a8 = *cc;\n    context->oc.asuchars\u00ddcontext->ucharptr\u00a8 = 0;\n    }\n  context->ucharptr++;\n\n#if PCRE2_CODE_UNIT_WIDTH == 8\n  if (context->ucharptr >= 4 || context->length == 0 || (context->ucharptr == 2 && context->length == 1))\n#else\n  if (context->ucharptr >= 2 || context->length == 0)\n#endif\n    {\n    if (context->length >= 4)\n      OP1(SLJIT_MOV_S32, context->sourcereg, 0, SLJIT_MEM1(STR_PTR), -context->length);\n    else if (context->length >= 2)\n      OP1(SLJIT_MOV_U16, context->sourcereg, 0, SLJIT_MEM1(STR_PTR), -context->length);\n#if PCRE2_CODE_UNIT_WIDTH == 8\n    else if (context->length >= 1)\n      OP1(SLJIT_MOV_U8, context->sourcereg, 0, SLJIT_MEM1(STR_PTR), -context->length);\n#endif /* PCRE2_CODE_UNIT_WIDTH == 8 */\n    context->sourcereg = context->sourcereg == TMP1 ? TMP2 : TMP1;\n\n    switch(context->ucharptr)\n      {\n      case 4 / sizeof(PCRE2_UCHAR):\n      if (context->oc.asint != 0)\n        OP2(SLJIT_OR, context->sourcereg, 0, context->sourcereg, 0, SLJIT_IMM, context->oc.asint);\n      add_jump(compiler, backtracks, CMP(SLJIT_NOT_EQUAL, context->sourcereg, 0, SLJIT_IMM, context->c.asint | context->oc.asint));\n      break;\n\n      case 2 / sizeof(PCRE2_UCHAR):\n      if (context->oc.asushort != 0)\n        OP2(SLJIT_OR, context->sourcereg, 0, context->sourcereg, 0, SLJIT_IMM, context->oc.asushort);\n      add_jump(compiler, backtracks, CMP(SLJIT_NOT_EQUAL, context->sourcereg, 0, SLJIT_IMM, context->c.asushort | context->oc.asushort));\n      break;\n\n#if PCRE2_CODE_UNIT_WIDTH == 8\n      case 1:\n      if (context->oc.asbyte != 0)\n        OP2(SLJIT_OR, context->sourcereg, 0, context->sourcereg, 0, SLJIT_IMM, context->oc.asbyte);\n      add_jump(compiler, backtracks, CMP(SLJIT_NOT_EQUAL, context->sourcereg, 0, SLJIT_IMM, context->c.asbyte | context->oc.asbyte));\n      break;\n#endif\n\n      default:\n      SLJIT_UNREACHABLE();\n      break;\n      }\n    context->ucharptr = 0;\n    }\n\n#else\n\n  /* Unaligned read is unsupported or in 32 bit mode. */\n  if (context->length >= 1)\n    OP1(MOV_UCHAR, context->sourcereg, 0, SLJIT_MEM1(STR_PTR), -context->length);\n\n  context->sourcereg = context->sourcereg == TMP1 ? TMP2 : TMP1;\n\n  if (othercasebit != 0 && othercasechar == cc)\n    {\n    OP2(SLJIT_OR, context->sourcereg, 0, context->sourcereg, 0, SLJIT_IMM, othercasebit);\n    add_jump(compiler, backtracks, CMP(SLJIT_NOT_EQUAL, context->sourcereg, 0, SLJIT_IMM, *cc | othercasebit));\n    }\n  else\n    add_jump(compiler, backtracks, CMP(SLJIT_NOT_EQUAL, context->sourcereg, 0, SLJIT_IMM, *cc));\n\n#endif\n\n  cc++;\n#ifdef SUPPORT_UNICODE\n  utflength--;\n  }\nwhile (utflength > 0);\n#endif\n\nreturn cc;\n}\n\n#if defined SUPPORT_UNICODE || PCRE2_CODE_UNIT_WIDTH != 8\n\n#define SET_TYPE_OFFSET(value) \\\n  if ((value) != typeoffset) \\\n    { \\\n    if ((value) < typeoffset) \\\n      OP2(SLJIT_ADD, typereg, 0, typereg, 0, SLJIT_IMM, typeoffset - (value)); \\\n    else \\\n      OP2(SLJIT_SUB, typereg, 0, typereg, 0, SLJIT_IMM, (value) - typeoffset); \\\n    } \\\n  typeoffset = (value);\n\n#define SET_CHAR_OFFSET(value) \\\n  if ((value) != charoffset) \\\n    { \\\n    if ((value) < charoffset) \\\n      OP2(SLJIT_ADD, TMP1, 0, TMP1, 0, SLJIT_IMM, (sljit_sw)(charoffset - (value))); \\\n    else \\\n      OP2(SLJIT_SUB, TMP1, 0, TMP1, 0, SLJIT_IMM, (sljit_sw)((value) - charoffset)); \\\n    } \\\n  charoffset = (value);\n\nstatic PCRE2_SPTR compile_char1_matchingpath(compiler_common *common, PCRE2_UCHAR type, PCRE2_SPTR cc, jump_list **backtracks, BOOL check_str_ptr);\n\nstatic void compile_xclass_matchingpath(compiler_common *common, PCRE2_SPTR cc, jump_list **backtracks)\n{\nDEFINE_COMPILER;\njump_list *found = NULL;\njump_list **list = (cc\u00dd0\u00a8 & XCL_NOT) == 0 ? &found : backtracks;\nsljit_uw c, charoffset, max = 256, min = READ_CHAR_MAX;\nstruct sljit_jump *jump = NULL;\nPCRE2_SPTR ccbegin;\nint compares, invertcmp, numberofcmps;\n#if defined SUPPORT_UNICODE && (PCRE2_CODE_UNIT_WIDTH == 8 || PCRE2_CODE_UNIT_WIDTH == 16)\nBOOL utf = common->utf;\n#endif /* SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH == \u00dd8|16\u00a8 */\n\n#ifdef SUPPORT_UNICODE\nBOOL needstype = FALSE, needsscript = FALSE, needschar = FALSE;\nBOOL charsaved = FALSE;\nint typereg = TMP1;\nconst sljit_u32 *other_cases;\nsljit_uw typeoffset;\n#endif /* SUPPORT_UNICODE */\n\n/* Scanning the necessary info. */\ncc++;\nccbegin = cc;\ncompares = 0;\n\nif (cc\u00dd-1\u00a8 & XCL_MAP)\n  {\n  min = 0;\n  cc += 32 / sizeof(PCRE2_UCHAR);\n  }\n\nwhile (*cc != XCL_END)\n  {\n  compares++;\n  if (*cc == XCL_SINGLE)\n    {\n    cc ++;\n    GETCHARINCTEST(c, cc);\n    if (c > max) max = c;\n    if (c < min) min = c;\n#ifdef SUPPORT_UNICODE\n    needschar = TRUE;\n#endif /* SUPPORT_UNICODE */\n    }\n  else if (*cc == XCL_RANGE)\n    {\n    cc ++;\n    GETCHARINCTEST(c, cc);\n    if (c < min) min = c;\n    GETCHARINCTEST(c, cc);\n    if (c > max) max = c;\n#ifdef SUPPORT_UNICODE\n    needschar = TRUE;\n#endif /* SUPPORT_UNICODE */\n    }\n#ifdef SUPPORT_UNICODE\n  else\n    {\n    SLJIT_ASSERT(*cc == XCL_PROP || *cc == XCL_NOTPROP);\n    cc++;\n    if (*cc == PT_CLIST)\n      {\n      other_cases = PRIV(ucd_caseless_sets) + cc\u00dd1\u00a8;\n      while (*other_cases != NOTACHAR)\n        {\n        if (*other_cases > max) max = *other_cases;\n        if (*other_cases < min) min = *other_cases;\n        other_cases++;\n        }\n      }\n    else\n      {\n      max = READ_CHAR_MAX;\n      min = 0;\n      }\n\n    switch(*cc)\n      {\n      case PT_ANY:\n      /* Any either accepts everything or ignored. */\n      if (cc\u00dd-1\u00a8 == XCL_PROP)\n        {\n        compile_char1_matchingpath(common, OP_ALLANY, cc, backtracks, FALSE);\n        if (list == backtracks)\n          add_jump(compiler, backtracks, JUMP(SLJIT_JUMP));\n        return;\n        }\n      break;\n\n      case PT_LAMP:\n      case PT_GC:\n      case PT_PC:\n      case PT_ALNUM:\n      needstype = TRUE;\n      break;\n\n      case PT_SC:\n      needsscript = TRUE;\n      break;\n\n      case PT_SPACE:\n      case PT_PXSPACE:\n      case PT_WORD:\n      case PT_PXGRAPH:\n      case PT_PXPRINT:\n      case PT_PXPUNCT:\n      needstype = TRUE;\n      needschar = TRUE;\n      break;\n\n      case PT_CLIST:\n      case PT_UCNC:\n      needschar = TRUE;\n      break;\n\n      default:\n      SLJIT_UNREACHABLE();\n      break;\n      }\n    cc += 2;\n    }\n#endif /* SUPPORT_UNICODE */\n  }\nSLJIT_ASSERT(compares > 0);\n\n/* We are not necessary in utf mode even in 8 bit mode. */\ncc = ccbegin;\nif ((cc\u00dd-1\u00a8 & XCL_NOT) != 0)\n  read_char(common, min, max, backtracks, READ_CHAR_UPDATE_STR_PTR);\nelse\n  {\n#ifdef SUPPORT_UNICODE\n  read_char(common, min, max, (needstype || needsscript) ? backtracks : NULL, 0);\n#else /* !SUPPORT_UNICODE */\n  read_char(common, min, max, NULL, 0);\n#endif /* SUPPORT_UNICODE */\n  }\n\nif ((cc\u00dd-1\u00a8 & XCL_HASPROP) == 0)\n  {\n  if ((cc\u00dd-1\u00a8 & XCL_MAP) != 0)\n    {\n    jump = CMP(SLJIT_GREATER, TMP1, 0, SLJIT_IMM, 255);\n    if (!optimize_class(common, (const sljit_u8 *)cc, (((const sljit_u8 *)cc)\u00dd31\u00a8 & 0x80) != 0, TRUE, &found))\n      {\n      OP2(SLJIT_AND, TMP2, 0, TMP1, 0, SLJIT_IMM, 0x7);\n      OP2(SLJIT_LSHR, TMP1, 0, TMP1, 0, SLJIT_IMM, 3);\n      OP1(SLJIT_MOV_U8, TMP1, 0, SLJIT_MEM1(TMP1), (sljit_sw)cc);\n      OP2(SLJIT_SHL, TMP2, 0, SLJIT_IMM, 1, TMP2, 0);\n      OP2(SLJIT_AND | SLJIT_SET_Z, SLJIT_UNUSED, 0, TMP1, 0, TMP2, 0);\n      add_jump(compiler, &found, JUMP(SLJIT_NOT_ZERO));\n      }\n\n    add_jump(compiler, backtracks, JUMP(SLJIT_JUMP));\n    JUMPHERE(jump);\n\n    cc += 32 / sizeof(PCRE2_UCHAR);\n    }\n  else\n    {\n    OP2(SLJIT_SUB, TMP2, 0, TMP1, 0, SLJIT_IMM, min);\n    add_jump(compiler, (cc\u00dd-1\u00a8 & XCL_NOT) == 0 ? backtracks : &found, CMP(SLJIT_GREATER, TMP2, 0, SLJIT_IMM, max - min));\n    }\n  }\nelse if ((cc\u00dd-1\u00a8 & XCL_MAP) != 0)\n  {\n  OP1(SLJIT_MOV, RETURN_ADDR, 0, TMP1, 0);\n#ifdef SUPPORT_UNICODE\n  charsaved = TRUE;\n#endif /* SUPPORT_UNICODE */\n  if (!optimize_class(common, (const sljit_u8 *)cc, FALSE, TRUE, list))\n    {\n#if PCRE2_CODE_UNIT_WIDTH == 8\n    jump = NULL;\n    if (common->utf)\n#endif /* PCRE2_CODE_UNIT_WIDTH == 8 */\n      jump = CMP(SLJIT_GREATER, TMP1, 0, SLJIT_IMM, 255);\n\n    OP2(SLJIT_AND, TMP2, 0, TMP1, 0, SLJIT_IMM, 0x7);\n    OP2(SLJIT_LSHR, TMP1, 0, TMP1, 0, SLJIT_IMM, 3);\n    OP1(SLJIT_MOV_U8, TMP1, 0, SLJIT_MEM1(TMP1), (sljit_sw)cc);\n    OP2(SLJIT_SHL, TMP2, 0, SLJIT_IMM, 1, TMP2, 0);\n    OP2(SLJIT_AND | SLJIT_SET_Z, SLJIT_UNUSED, 0, TMP1, 0, TMP2, 0);\n    add_jump(compiler, list, JUMP(SLJIT_NOT_ZERO));\n\n#if PCRE2_CODE_UNIT_WIDTH == 8\n    if (common->utf)\n#endif /* PCRE2_CODE_UNIT_WIDTH == 8 */\n      JUMPHERE(jump);\n    }\n\n  OP1(SLJIT_MOV, TMP1, 0, RETURN_ADDR, 0);\n  cc += 32 / sizeof(PCRE2_UCHAR);\n  }\n\n#ifdef SUPPORT_UNICODE\nif (needstype || needsscript)\n  {\n  if (needschar && !charsaved)\n    OP1(SLJIT_MOV, RETURN_ADDR, 0, TMP1, 0);\n\n#if PCRE2_CODE_UNIT_WIDTH == 32\n  if (!common->utf)\n    {\n    jump = CMP(SLJIT_LESS, TMP1, 0, SLJIT_IMM, MAX_UTF_CODE_POINT + 1);\n    OP1(SLJIT_MOV, TMP1, 0, SLJIT_IMM, UNASSIGNED_UTF_CHAR);\n    JUMPHERE(jump);\n    }\n#endif /* PCRE2_CODE_UNIT_WIDTH == 32 */\n\n  OP2(SLJIT_LSHR, TMP2, 0, TMP1, 0, SLJIT_IMM, UCD_BLOCK_SHIFT);\n  OP2(SLJIT_SHL, TMP2, 0, TMP2, 0, SLJIT_IMM, 1);\n  OP1(SLJIT_MOV_U16, TMP2, 0, SLJIT_MEM1(TMP2), (sljit_sw)PRIV(ucd_stage1));\n  OP2(SLJIT_AND, TMP1, 0, TMP1, 0, SLJIT_IMM, UCD_BLOCK_MASK);\n  OP2(SLJIT_SHL, TMP2, 0, TMP2, 0, SLJIT_IMM, UCD_BLOCK_SHIFT);\n  OP2(SLJIT_ADD, TMP1, 0, TMP1, 0, TMP2, 0);\n  OP1(SLJIT_MOV, TMP2, 0, SLJIT_IMM, (sljit_sw)PRIV(ucd_stage2));\n  OP1(SLJIT_MOV_U16, TMP2, 0, SLJIT_MEM2(TMP2, TMP1), 1);\n\n  /* Before anything else, we deal with scripts. */\n  if (needsscript)\n    {\n    OP2(SLJIT_SHL, TMP1, 0, TMP2, 0, SLJIT_IMM, 3);\n    OP2(SLJIT_SHL, TMP2, 0, TMP2, 0, SLJIT_IMM, 2);\n    OP2(SLJIT_ADD, TMP1, 0, TMP1, 0, TMP2, 0);\n\n    OP1(SLJIT_MOV_U8, TMP1, 0, SLJIT_MEM1(TMP1), (sljit_sw)PRIV(ucd_records) + SLJIT_OFFSETOF(ucd_record, script));\n\n    ccbegin = cc;\n\n    while (*cc != XCL_END)\n      {\n      if (*cc == XCL_SINGLE)\n        {\n        cc ++;\n        GETCHARINCTEST(c, cc);\n        }\n      else if (*cc == XCL_RANGE)\n        {\n        cc ++;\n        GETCHARINCTEST(c, cc);\n        GETCHARINCTEST(c, cc);\n        }\n      else\n        {\n        SLJIT_ASSERT(*cc == XCL_PROP || *cc == XCL_NOTPROP);\n        cc++;\n        if (*cc == PT_SC)\n          {\n          compares--;\n          invertcmp = (compares == 0 && list != backtracks);\n          if (cc\u00dd-1\u00a8 == XCL_NOTPROP)\n            invertcmp \u00ac= 0x1;\n          jump = CMP(SLJIT_EQUAL \u00ac invertcmp, TMP1, 0, SLJIT_IMM, (int)cc\u00dd1\u00a8);\n          add_jump(compiler, compares > 0 ? list : backtracks, jump);\n          }\n        cc += 2;\n        }\n      }\n\n    cc = ccbegin;\n    }\n\n  if (needschar)\n    OP1(SLJIT_MOV, TMP1, 0, RETURN_ADDR, 0);\n\n  if (needstype)\n    {\n    if (!needschar)\n      {\n      OP2(SLJIT_SHL, TMP1, 0, TMP2, 0, SLJIT_IMM, 3);\n      OP2(SLJIT_SHL, TMP2, 0, TMP2, 0, SLJIT_IMM, 2);\n      OP2(SLJIT_ADD, TMP1, 0, TMP1, 0, TMP2, 0);\n\n      OP1(SLJIT_MOV_U8, TMP1, 0, SLJIT_MEM1(TMP1), (sljit_sw)PRIV(ucd_records) + SLJIT_OFFSETOF(ucd_record, chartype));\n      }\n    else\n      {\n      OP2(SLJIT_SHL, TMP1, 0, TMP2, 0, SLJIT_IMM, 2);\n      OP2(SLJIT_SHL, TMP2, 0, TMP2, 0, SLJIT_IMM, 3);\n      OP2(SLJIT_ADD, TMP2, 0, TMP2, 0, TMP1, 0);\n\n      OP1(SLJIT_MOV, TMP1, 0, RETURN_ADDR, 0);\n      OP1(SLJIT_MOV_U8, RETURN_ADDR, 0, SLJIT_MEM1(TMP2), (sljit_sw)PRIV(ucd_records) + SLJIT_OFFSETOF(ucd_record, chartype));\n      typereg = RETURN_ADDR;\n      }\n    }\n  }\n#endif /* SUPPORT_UNICODE */\n\n/* Generating code. */\ncharoffset = 0;\nnumberofcmps = 0;\n#ifdef SUPPORT_UNICODE\ntypeoffset = 0;\n#endif /* SUPPORT_UNICODE */\n\nwhile (*cc != XCL_END)\n  {\n  compares--;\n  invertcmp = (compares == 0 && list != backtracks);\n  jump = NULL;\n\n  if (*cc == XCL_SINGLE)\n    {\n    cc ++;\n    GETCHARINCTEST(c, cc);\n\n    if (numberofcmps < 3 && (*cc == XCL_SINGLE || *cc == XCL_RANGE))\n      {\n      OP2(SLJIT_SUB | SLJIT_SET_Z, SLJIT_UNUSED, 0, TMP1, 0, SLJIT_IMM, (sljit_sw)(c - charoffset));\n      OP_FLAGS(numberofcmps == 0 ? SLJIT_MOV : SLJIT_OR, TMP2, 0, SLJIT_EQUAL);\n      numberofcmps++;\n      }\n    else if (numberofcmps > 0)\n      {\n      OP2(SLJIT_SUB | SLJIT_SET_Z, SLJIT_UNUSED, 0, TMP1, 0, SLJIT_IMM, (sljit_sw)(c - charoffset));\n      OP_FLAGS(SLJIT_OR | SLJIT_SET_Z, TMP2, 0, SLJIT_EQUAL);\n      jump = JUMP(SLJIT_NOT_ZERO \u00ac invertcmp);\n      numberofcmps = 0;\n      }\n    else\n      {\n      jump = CMP(SLJIT_EQUAL \u00ac invertcmp, TMP1, 0, SLJIT_IMM, (sljit_sw)(c - charoffset));\n      numberofcmps = 0;\n      }\n    }\n  else if (*cc == XCL_RANGE)\n    {\n    cc ++;\n    GETCHARINCTEST(c, cc);\n    SET_CHAR_OFFSET(c);\n    GETCHARINCTEST(c, cc);\n\n    if (numberofcmps < 3 && (*cc == XCL_SINGLE || *cc == XCL_RANGE))\n      {\n      OP2(SLJIT_SUB | SLJIT_SET_LESS_EQUAL, SLJIT_UNUSED, 0, TMP1, 0, SLJIT_IMM, (sljit_sw)(c - charoffset));\n      OP_FLAGS(numberofcmps == 0 ? SLJIT_MOV : SLJIT_OR, TMP2, 0, SLJIT_LESS_EQUAL);\n      numberofcmps++;\n      }\n    else if (numberofcmps > 0)\n      {\n      OP2(SLJIT_SUB | SLJIT_SET_LESS_EQUAL, SLJIT_UNUSED, 0, TMP1, 0, SLJIT_IMM, (sljit_sw)(c - charoffset));\n      OP_FLAGS(SLJIT_OR | SLJIT_SET_Z, TMP2, 0, SLJIT_LESS_EQUAL);\n      jump = JUMP(SLJIT_NOT_ZERO \u00ac invertcmp);\n      numberofcmps = 0;\n      }\n    else\n      {\n      jump = CMP(SLJIT_LESS_EQUAL \u00ac invertcmp, TMP1, 0, SLJIT_IMM, (sljit_sw)(c - charoffset));\n      numberofcmps = 0;\n      }\n    }\n#ifdef SUPPORT_UNICODE\n  else\n    {\n    SLJIT_ASSERT(*cc == XCL_PROP || *cc == XCL_NOTPROP);\n    if (*cc == XCL_NOTPROP)\n      invertcmp \u00ac= 0x1;\n    cc++;\n    switch(*cc)\n      {\n      case PT_ANY:\n      if (!invertcmp)\n        jump = JUMP(SLJIT_JUMP);\n      break;\n\n      case PT_LAMP:\n      OP2(SLJIT_SUB | SLJIT_SET_Z, SLJIT_UNUSED, 0, typereg, 0, SLJIT_IMM, ucp_Lu - typeoffset);\n      OP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_EQUAL);\n      OP2(SLJIT_SUB | SLJIT_SET_Z, SLJIT_UNUSED, 0, typereg, 0, SLJIT_IMM, ucp_Ll - typeoffset);\n      OP_FLAGS(SLJIT_OR, TMP2, 0, SLJIT_EQUAL);\n      OP2(SLJIT_SUB | SLJIT_SET_Z, SLJIT_UNUSED, 0, typereg, 0, SLJIT_IMM, ucp_Lt - typeoffset);\n      OP_FLAGS(SLJIT_OR | SLJIT_SET_Z, TMP2, 0, SLJIT_EQUAL);\n      jump = JUMP(SLJIT_NOT_ZERO \u00ac invertcmp);\n      break;\n\n      case PT_GC:\n      c = PRIV(ucp_typerange)\u00dd(int)cc\u00dd1\u00a8 * 2\u00a8;\n      SET_TYPE_OFFSET(c);\n      jump = CMP(SLJIT_LESS_EQUAL \u00ac invertcmp, typereg, 0, SLJIT_IMM, PRIV(ucp_typerange)\u00dd(int)cc\u00dd1\u00a8 * 2 + 1\u00a8 - c);\n      break;\n\n      case PT_PC:\n      jump = CMP(SLJIT_EQUAL \u00ac invertcmp, typereg, 0, SLJIT_IMM, (int)cc\u00dd1\u00a8 - typeoffset);\n      break;\n\n      case PT_SC:\n      compares++;\n      /* Do nothing. */\n      break;\n\n      case PT_SPACE:\n      case PT_PXSPACE:\n      SET_CHAR_OFFSET(9);\n      OP2(SLJIT_SUB | SLJIT_SET_LESS_EQUAL, SLJIT_UNUSED, 0, TMP1, 0, SLJIT_IMM, 0xd - 0x9);\n      OP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_LESS_EQUAL);\n\n      OP2(SLJIT_SUB | SLJIT_SET_Z, SLJIT_UNUSED, 0, TMP1, 0, SLJIT_IMM, 0x85 - 0x9);\n      OP_FLAGS(SLJIT_OR, TMP2, 0, SLJIT_EQUAL);\n\n      OP2(SLJIT_SUB | SLJIT_SET_Z, SLJIT_UNUSED, 0, TMP1, 0, SLJIT_IMM, 0x180e - 0x9);\n      OP_FLAGS(SLJIT_OR, TMP2, 0, SLJIT_EQUAL);\n\n      SET_TYPE_OFFSET(ucp_Zl);\n      OP2(SLJIT_SUB | SLJIT_SET_LESS_EQUAL, SLJIT_UNUSED, 0, typereg, 0, SLJIT_IMM, ucp_Zs - ucp_Zl);\n      OP_FLAGS(SLJIT_OR | SLJIT_SET_Z, TMP2, 0, SLJIT_LESS_EQUAL);\n      jump = JUMP(SLJIT_NOT_ZERO \u00ac invertcmp);\n      break;\n\n      case PT_WORD:\n      OP2(SLJIT_SUB | SLJIT_SET_Z, SLJIT_UNUSED, 0, TMP1, 0, SLJIT_IMM, (sljit_sw)(CHAR_UNDERSCORE - charoffset));\n      OP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_EQUAL);\n      /* Fall through. */\n\n      case PT_ALNUM:\n      SET_TYPE_OFFSET(ucp_Ll);\n      OP2(SLJIT_SUB | SLJIT_SET_LESS_EQUAL, SLJIT_UNUSED, 0, typereg, 0, SLJIT_IMM, ucp_Lu - ucp_Ll);\n      OP_FLAGS((*cc == PT_ALNUM) ? SLJIT_MOV : SLJIT_OR, TMP2, 0, SLJIT_LESS_EQUAL);\n      SET_TYPE_OFFSET(ucp_Nd);\n      OP2(SLJIT_SUB | SLJIT_SET_LESS_EQUAL, SLJIT_UNUSED, 0, typereg, 0, SLJIT_IMM, ucp_No - ucp_Nd);\n      OP_FLAGS(SLJIT_OR | SLJIT_SET_Z, TMP2, 0, SLJIT_LESS_EQUAL);\n      jump = JUMP(SLJIT_NOT_ZERO \u00ac invertcmp);\n      break;\n\n      case PT_CLIST:\n      other_cases = PRIV(ucd_caseless_sets) + cc\u00dd1\u00a8;\n\n      /* At least three characters are required.\n         Otherwise this case would be handled by the normal code path. */\n      SLJIT_ASSERT(other_cases\u00dd0\u00a8 != NOTACHAR && other_cases\u00dd1\u00a8 != NOTACHAR && other_cases\u00dd2\u00a8 != NOTACHAR);\n      SLJIT_ASSERT(other_cases\u00dd0\u00a8 < other_cases\u00dd1\u00a8 && other_cases\u00dd1\u00a8 < other_cases\u00dd2\u00a8);\n\n      /* Optimizing character pairs, if their difference is power of 2. */\n      if (is_powerof2(other_cases\u00dd1\u00a8 \u00ac other_cases\u00dd0\u00a8))\n        {\n        if (charoffset == 0)\n          OP2(SLJIT_OR, TMP2, 0, TMP1, 0, SLJIT_IMM, other_cases\u00dd1\u00a8 \u00ac other_cases\u00dd0\u00a8);\n        else\n          {\n          OP2(SLJIT_ADD, TMP2, 0, TMP1, 0, SLJIT_IMM, (sljit_sw)charoffset);\n          OP2(SLJIT_OR, TMP2, 0, TMP2, 0, SLJIT_IMM, other_cases\u00dd1\u00a8 \u00ac other_cases\u00dd0\u00a8);\n          }\n        OP2(SLJIT_SUB | SLJIT_SET_Z, SLJIT_UNUSED, 0, TMP2, 0, SLJIT_IMM, other_cases\u00dd1\u00a8);\n        OP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_EQUAL);\n        other_cases += 2;\n        }\n      else if (is_powerof2(other_cases\u00dd2\u00a8 \u00ac other_cases\u00dd1\u00a8))\n        {\n        if (charoffset == 0)\n          OP2(SLJIT_OR, TMP2, 0, TMP1, 0, SLJIT_IMM, other_cases\u00dd2\u00a8 \u00ac other_cases\u00dd1\u00a8);\n        else\n          {\n          OP2(SLJIT_ADD, TMP2, 0, TMP1, 0, SLJIT_IMM, (sljit_sw)charoffset);\n          OP2(SLJIT_OR, TMP2, 0, TMP2, 0, SLJIT_IMM, other_cases\u00dd1\u00a8 \u00ac other_cases\u00dd0\u00a8);\n          }\n        OP2(SLJIT_SUB | SLJIT_SET_Z, SLJIT_UNUSED, 0, TMP2, 0, SLJIT_IMM, other_cases\u00dd2\u00a8);\n        OP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_EQUAL);\n\n        OP2(SLJIT_SUB | SLJIT_SET_Z, SLJIT_UNUSED, 0, TMP1, 0, SLJIT_IMM, (sljit_sw)(other_cases\u00dd0\u00a8 - charoffset));\n        OP_FLAGS(SLJIT_OR | ((other_cases\u00dd3\u00a8 == NOTACHAR) ? SLJIT_SET_Z : 0), TMP2, 0, SLJIT_EQUAL);\n\n        other_cases += 3;\n        }\n      else\n        {\n        OP2(SLJIT_SUB | SLJIT_SET_Z, SLJIT_UNUSED, 0, TMP1, 0, SLJIT_IMM, (sljit_sw)(*other_cases++ - charoffset));\n        OP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_EQUAL);\n        }\n\n      while (*other_cases != NOTACHAR)\n        {\n        OP2(SLJIT_SUB | SLJIT_SET_Z, SLJIT_UNUSED, 0, TMP1, 0, SLJIT_IMM, (sljit_sw)(*other_cases++ - charoffset));\n        OP_FLAGS(SLJIT_OR | ((*other_cases == NOTACHAR) ? SLJIT_SET_Z : 0), TMP2, 0, SLJIT_EQUAL);\n        }\n      jump = JUMP(SLJIT_NOT_ZERO \u00ac invertcmp);\n      break;\n\n      case PT_UCNC:\n      OP2(SLJIT_SUB | SLJIT_SET_Z, SLJIT_UNUSED, 0, TMP1, 0, SLJIT_IMM, (sljit_sw)(CHAR_DOLLAR_SIGN - charoffset));\n      OP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_EQUAL);\n      OP2(SLJIT_SUB | SLJIT_SET_Z, SLJIT_UNUSED, 0, TMP1, 0, SLJIT_IMM, (sljit_sw)(CHAR_COMMERCIAL_AT - charoffset));\n      OP_FLAGS(SLJIT_OR, TMP2, 0, SLJIT_EQUAL);\n      OP2(SLJIT_SUB | SLJIT_SET_Z, SLJIT_UNUSED, 0, TMP1, 0, SLJIT_IMM, (sljit_sw)(CHAR_GRAVE_ACCENT - charoffset));\n      OP_FLAGS(SLJIT_OR, TMP2, 0, SLJIT_EQUAL);\n\n      SET_CHAR_OFFSET(0xa0);\n      OP2(SLJIT_SUB | SLJIT_SET_LESS_EQUAL, SLJIT_UNUSED, 0, TMP1, 0, SLJIT_IMM, (sljit_sw)(0xd7ff - charoffset));\n      OP_FLAGS(SLJIT_OR, TMP2, 0, SLJIT_LESS_EQUAL);\n      SET_CHAR_OFFSET(0);\n      OP2(SLJIT_SUB | SLJIT_SET_GREATER_EQUAL, SLJIT_UNUSED, 0, TMP1, 0, SLJIT_IMM, 0xe000 - 0);\n      OP_FLAGS(SLJIT_OR | SLJIT_SET_Z, TMP2, 0, SLJIT_GREATER_EQUAL);\n      jump = JUMP(SLJIT_NOT_ZERO \u00ac invertcmp);\n      break;\n\n      case PT_PXGRAPH:\n      /* C and Z groups are the farthest two groups. */\n      SET_TYPE_OFFSET(ucp_Ll);\n      OP2(SLJIT_SUB | SLJIT_SET_GREATER, SLJIT_UNUSED, 0, typereg, 0, SLJIT_IMM, ucp_So - ucp_Ll);\n      OP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_GREATER);\n\n      jump = CMP(SLJIT_NOT_EQUAL, typereg, 0, SLJIT_IMM, ucp_Cf - ucp_Ll);\n\n      /* In case of ucp_Cf, we overwrite the result. */\n      SET_CHAR_OFFSET(0x2066);\n      OP2(SLJIT_SUB | SLJIT_SET_LESS_EQUAL, SLJIT_UNUSED, 0, TMP1, 0, SLJIT_IMM, 0x2069 - 0x2066);\n      OP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_LESS_EQUAL);\n\n      OP2(SLJIT_SUB | SLJIT_SET_Z, SLJIT_UNUSED, 0, TMP1, 0, SLJIT_IMM, 0x061c - 0x2066);\n      OP_FLAGS(SLJIT_OR, TMP2, 0, SLJIT_EQUAL);\n\n      OP2(SLJIT_SUB | SLJIT_SET_Z, SLJIT_UNUSED, 0, TMP1, 0, SLJIT_IMM, 0x180e - 0x2066);\n      OP_FLAGS(SLJIT_OR, TMP2, 0, SLJIT_EQUAL);\n\n      JUMPHERE(jump);\n      jump = CMP(SLJIT_ZERO \u00ac invertcmp, TMP2, 0, SLJIT_IMM, 0);\n      break;\n\n      case PT_PXPRINT:\n      /* C and Z groups are the farthest two groups. */\n      SET_TYPE_OFFSET(ucp_Ll);\n      OP2(SLJIT_SUB | SLJIT_SET_GREATER, SLJIT_UNUSED, 0, typereg, 0, SLJIT_IMM, ucp_So - ucp_Ll);\n      OP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_GREATER);\n\n      OP2(SLJIT_SUB | SLJIT_SET_Z, SLJIT_UNUSED, 0, typereg, 0, SLJIT_IMM, ucp_Zs - ucp_Ll);\n      OP_FLAGS(SLJIT_AND, TMP2, 0, SLJIT_NOT_EQUAL);\n\n      jump = CMP(SLJIT_NOT_EQUAL, typereg, 0, SLJIT_IMM, ucp_Cf - ucp_Ll);\n\n      /* In case of ucp_Cf, we overwrite the result. */\n      SET_CHAR_OFFSET(0x2066);\n      OP2(SLJIT_SUB | SLJIT_SET_LESS_EQUAL, SLJIT_UNUSED, 0, TMP1, 0, SLJIT_IMM, 0x2069 - 0x2066);\n      OP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_LESS_EQUAL);\n\n      OP2(SLJIT_SUB | SLJIT_SET_Z, SLJIT_UNUSED, 0, TMP1, 0, SLJIT_IMM, 0x061c - 0x2066);\n      OP_FLAGS(SLJIT_OR, TMP2, 0, SLJIT_EQUAL);\n\n      JUMPHERE(jump);\n      jump = CMP(SLJIT_ZERO \u00ac invertcmp, TMP2, 0, SLJIT_IMM, 0);\n      break;\n\n      case PT_PXPUNCT:\n      SET_TYPE_OFFSET(ucp_Sc);\n      OP2(SLJIT_SUB | SLJIT_SET_LESS_EQUAL, SLJIT_UNUSED, 0, typereg, 0, SLJIT_IMM, ucp_So - ucp_Sc);\n      OP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_LESS_EQUAL);\n\n      SET_CHAR_OFFSET(0);\n      OP2(SLJIT_SUB | SLJIT_SET_LESS_EQUAL, SLJIT_UNUSED, 0, TMP1, 0, SLJIT_IMM, 0x7f);\n      OP_FLAGS(SLJIT_AND, TMP2, 0, SLJIT_LESS_EQUAL);\n\n      SET_TYPE_OFFSET(ucp_Pc);\n      OP2(SLJIT_SUB | SLJIT_SET_LESS_EQUAL, SLJIT_UNUSED, 0, typereg, 0, SLJIT_IMM, ucp_Ps - ucp_Pc);\n      OP_FLAGS(SLJIT_OR | SLJIT_SET_Z, TMP2, 0, SLJIT_LESS_EQUAL);\n      jump = JUMP(SLJIT_NOT_ZERO \u00ac invertcmp);\n      break;\n\n      default:\n      SLJIT_UNREACHABLE();\n      break;\n      }\n    cc += 2;\n    }\n#endif /* SUPPORT_UNICODE */\n\n  if (jump != NULL)\n    add_jump(compiler, compares > 0 ? list : backtracks, jump);\n  }\n\nif (found != NULL)\n  set_jumps(found, LABEL());\n}\n\n#undef SET_TYPE_OFFSET\n#undef SET_CHAR_OFFSET\n\n#endif\n\nstatic PCRE2_SPTR compile_simple_assertion_matchingpath(compiler_common *common, PCRE2_UCHAR type, PCRE2_SPTR cc, jump_list **backtracks)\n{\nDEFINE_COMPILER;\nint length;\nstruct sljit_jump *jump\u00dd4\u00a8;\n#ifdef SUPPORT_UNICODE\nstruct sljit_label *label;\n#endif /* SUPPORT_UNICODE */\n\nswitch(type)\n  {\n  case OP_SOD:\n  if (HAS_VIRTUAL_REGISTERS)\n    {\n    OP1(SLJIT_MOV, TMP1, 0, ARGUMENTS, 0);\n    OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(TMP1), SLJIT_OFFSETOF(jit_arguments, begin));\n    }\n  else\n    OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(ARGUMENTS), SLJIT_OFFSETOF(jit_arguments, begin));\n  add_jump(compiler, backtracks, CMP(SLJIT_NOT_EQUAL, STR_PTR, 0, TMP1, 0));\n  return cc;\n\n  case OP_SOM:\n  if (HAS_VIRTUAL_REGISTERS)\n    {\n    OP1(SLJIT_MOV, TMP1, 0, ARGUMENTS, 0);\n    OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(TMP1), SLJIT_OFFSETOF(jit_arguments, str));\n    }\n  else\n    OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(ARGUMENTS), SLJIT_OFFSETOF(jit_arguments, str));\n  add_jump(compiler, backtracks, CMP(SLJIT_NOT_EQUAL, STR_PTR, 0, TMP1, 0));\n  return cc;\n\n  case OP_NOT_WORD_BOUNDARY:\n  case OP_WORD_BOUNDARY:\n  add_jump(compiler, &common->wordboundary, JUMP(SLJIT_FAST_CALL));\n#ifdef SUPPORT_UNICODE\n  if (common->invalid_utf)\n    {\n    add_jump(compiler, backtracks, CMP((type == OP_NOT_WORD_BOUNDARY) ? SLJIT_NOT_EQUAL : SLJIT_SIG_LESS_EQUAL, TMP2, 0, SLJIT_IMM, 0));\n    return cc;\n    }\n#endif /* SUPPORT_UNICODE */\n  sljit_set_current_flags(compiler, SLJIT_SET_Z);\n  add_jump(compiler, backtracks, JUMP(type == OP_NOT_WORD_BOUNDARY ? SLJIT_NOT_ZERO : SLJIT_ZERO));\n  return cc;\n\n  case OP_EODN:\n  /* Requires rather complex checks. */\n  jump\u00dd0\u00a8 = CMP(SLJIT_GREATER_EQUAL, STR_PTR, 0, STR_END, 0);\n  if (common->nltype == NLTYPE_FIXED && common->newline > 255)\n    {\n    OP2(SLJIT_ADD, TMP2, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(2));\n    OP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(0));\n    if (common->mode == PCRE2_JIT_COMPLETE)\n      add_jump(compiler, backtracks, CMP(SLJIT_NOT_EQUAL, TMP2, 0, STR_END, 0));\n    else\n      {\n      jump\u00dd1\u00a8 = CMP(SLJIT_EQUAL, TMP2, 0, STR_END, 0);\n      OP2(SLJIT_SUB | SLJIT_SET_LESS, SLJIT_UNUSED, 0, TMP2, 0, STR_END, 0);\n      OP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_LESS);\n      OP2(SLJIT_SUB | SLJIT_SET_Z, SLJIT_UNUSED, 0, TMP1, 0, SLJIT_IMM, (common->newline >> 8) & 0xff);\n      OP_FLAGS(SLJIT_OR | SLJIT_SET_Z, TMP2, 0, SLJIT_NOT_EQUAL);\n      add_jump(compiler, backtracks, JUMP(SLJIT_NOT_EQUAL));\n      check_partial(common, TRUE);\n      add_jump(compiler, backtracks, JUMP(SLJIT_JUMP));\n      JUMPHERE(jump\u00dd1\u00a8);\n      }\n    OP1(MOV_UCHAR, TMP2, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(1));\n    add_jump(compiler, backtracks, CMP(SLJIT_NOT_EQUAL, TMP1, 0, SLJIT_IMM, (common->newline >> 8) & 0xff));\n    add_jump(compiler, backtracks, CMP(SLJIT_NOT_EQUAL, TMP2, 0, SLJIT_IMM, common->newline & 0xff));\n    }\n  else if (common->nltype == NLTYPE_FIXED)\n    {\n    OP2(SLJIT_ADD, TMP2, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n    OP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(0));\n    add_jump(compiler, backtracks, CMP(SLJIT_NOT_EQUAL, TMP2, 0, STR_END, 0));\n    add_jump(compiler, backtracks, CMP(SLJIT_NOT_EQUAL, TMP1, 0, SLJIT_IMM, common->newline));\n    }\n  else\n    {\n    OP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(0));\n    jump\u00dd1\u00a8 = CMP(SLJIT_NOT_EQUAL, TMP1, 0, SLJIT_IMM, CHAR_CR);\n    OP2(SLJIT_ADD, TMP2, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(2));\n    OP2(SLJIT_SUB | SLJIT_SET_Z | SLJIT_SET_GREATER, SLJIT_UNUSED, 0, TMP2, 0, STR_END, 0);\n    jump\u00dd2\u00a8 = JUMP(SLJIT_GREATER);\n    add_jump(compiler, backtracks, JUMP(SLJIT_NOT_EQUAL) /* LESS */);\n    /* Equal. */\n    OP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(1));\n    jump\u00dd3\u00a8 = CMP(SLJIT_EQUAL, TMP1, 0, SLJIT_IMM, CHAR_NL);\n    add_jump(compiler, backtracks, JUMP(SLJIT_JUMP));\n\n    JUMPHERE(jump\u00dd1\u00a8);\n    if (common->nltype == NLTYPE_ANYCRLF)\n      {\n      OP2(SLJIT_ADD, TMP2, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n      add_jump(compiler, backtracks, CMP(SLJIT_LESS, TMP2, 0, STR_END, 0));\n      add_jump(compiler, backtracks, CMP(SLJIT_NOT_EQUAL, TMP1, 0, SLJIT_IMM, CHAR_NL));\n      }\n    else\n      {\n      OP1(SLJIT_MOV, TMP3, 0, STR_PTR, 0);\n      read_char(common, common->nlmin, common->nlmax, backtracks, READ_CHAR_UPDATE_STR_PTR);\n      add_jump(compiler, backtracks, CMP(SLJIT_NOT_EQUAL, STR_PTR, 0, STR_END, 0));\n      add_jump(compiler, &common->anynewline, JUMP(SLJIT_FAST_CALL));\n      sljit_set_current_flags(compiler, SLJIT_SET_Z);\n      add_jump(compiler, backtracks, JUMP(SLJIT_ZERO));\n      OP1(SLJIT_MOV, STR_PTR, 0, TMP3, 0);\n      }\n    JUMPHERE(jump\u00dd2\u00a8);\n    JUMPHERE(jump\u00dd3\u00a8);\n    }\n  JUMPHERE(jump\u00dd0\u00a8);\n  if (common->mode != PCRE2_JIT_COMPLETE)\n    check_partial(common, TRUE);\n  return cc;\n\n  case OP_EOD:\n  add_jump(compiler, backtracks, CMP(SLJIT_LESS, STR_PTR, 0, STR_END, 0));\n  if (common->mode != PCRE2_JIT_COMPLETE)\n    check_partial(common, TRUE);\n  return cc;\n\n  case OP_DOLL:\n  if (HAS_VIRTUAL_REGISTERS)\n    {\n    OP1(SLJIT_MOV, TMP2, 0, ARGUMENTS, 0);\n    OP2(SLJIT_AND32 | SLJIT_SET_Z, SLJIT_UNUSED, 0, SLJIT_MEM1(TMP2), SLJIT_OFFSETOF(jit_arguments, options), SLJIT_IMM, PCRE2_NOTEOL);\n    }\n  else\n    OP2(SLJIT_AND32 | SLJIT_SET_Z, SLJIT_UNUSED, 0, SLJIT_MEM1(ARGUMENTS), SLJIT_OFFSETOF(jit_arguments, options), SLJIT_IMM, PCRE2_NOTEOL);\n  add_jump(compiler, backtracks, JUMP(SLJIT_NOT_ZERO32));\n\n  if (!common->endonly)\n    compile_simple_assertion_matchingpath(common, OP_EODN, cc, backtracks);\n  else\n    {\n    add_jump(compiler, backtracks, CMP(SLJIT_LESS, STR_PTR, 0, STR_END, 0));\n    check_partial(common, FALSE);\n    }\n  return cc;\n\n  case OP_DOLLM:\n  jump\u00dd1\u00a8 = CMP(SLJIT_LESS, STR_PTR, 0, STR_END, 0);\n  if (HAS_VIRTUAL_REGISTERS)\n    {\n    OP1(SLJIT_MOV, TMP2, 0, ARGUMENTS, 0);\n    OP2(SLJIT_AND32 | SLJIT_SET_Z, SLJIT_UNUSED, 0, SLJIT_MEM1(TMP2), SLJIT_OFFSETOF(jit_arguments, options), SLJIT_IMM, PCRE2_NOTEOL);\n    }\n  else\n    OP2(SLJIT_AND32 | SLJIT_SET_Z, SLJIT_UNUSED, 0, SLJIT_MEM1(ARGUMENTS), SLJIT_OFFSETOF(jit_arguments, options), SLJIT_IMM, PCRE2_NOTEOL);\n  add_jump(compiler, backtracks, JUMP(SLJIT_NOT_ZERO32));\n  check_partial(common, FALSE);\n  jump\u00dd0\u00a8 = JUMP(SLJIT_JUMP);\n  JUMPHERE(jump\u00dd1\u00a8);\n\n  if (common->nltype == NLTYPE_FIXED && common->newline > 255)\n    {\n    OP2(SLJIT_ADD, TMP2, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(2));\n    OP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(0));\n    if (common->mode == PCRE2_JIT_COMPLETE)\n      add_jump(compiler, backtracks, CMP(SLJIT_GREATER, TMP2, 0, STR_END, 0));\n    else\n      {\n      jump\u00dd1\u00a8 = CMP(SLJIT_LESS_EQUAL, TMP2, 0, STR_END, 0);\n      /* STR_PTR = STR_END - IN_UCHARS(1) */\n      add_jump(compiler, backtracks, CMP(SLJIT_NOT_EQUAL, TMP1, 0, SLJIT_IMM, (common->newline >> 8) & 0xff));\n      check_partial(common, TRUE);\n      add_jump(compiler, backtracks, JUMP(SLJIT_JUMP));\n      JUMPHERE(jump\u00dd1\u00a8);\n      }\n\n    OP1(MOV_UCHAR, TMP2, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(1));\n    add_jump(compiler, backtracks, CMP(SLJIT_NOT_EQUAL, TMP1, 0, SLJIT_IMM, (common->newline >> 8) & 0xff));\n    add_jump(compiler, backtracks, CMP(SLJIT_NOT_EQUAL, TMP2, 0, SLJIT_IMM, common->newline & 0xff));\n    }\n  else\n    {\n    peek_char(common, common->nlmax, TMP3, 0, NULL);\n    check_newlinechar(common, common->nltype, backtracks, FALSE);\n    }\n  JUMPHERE(jump\u00dd0\u00a8);\n  return cc;\n\n  case OP_CIRC:\n  if (HAS_VIRTUAL_REGISTERS)\n    {\n    OP1(SLJIT_MOV, TMP2, 0, ARGUMENTS, 0);\n    OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(TMP2), SLJIT_OFFSETOF(jit_arguments, begin));\n    add_jump(compiler, backtracks, CMP(SLJIT_GREATER, STR_PTR, 0, TMP1, 0));\n    OP2(SLJIT_AND32 | SLJIT_SET_Z, SLJIT_UNUSED, 0, SLJIT_MEM1(TMP2), SLJIT_OFFSETOF(jit_arguments, options), SLJIT_IMM, PCRE2_NOTBOL);\n    add_jump(compiler, backtracks, JUMP(SLJIT_NOT_ZERO32));\n    }\n  else\n    {\n    OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(ARGUMENTS), SLJIT_OFFSETOF(jit_arguments, begin));\n    add_jump(compiler, backtracks, CMP(SLJIT_GREATER, STR_PTR, 0, TMP1, 0));\n    OP2(SLJIT_AND32 | SLJIT_SET_Z, SLJIT_UNUSED, 0, SLJIT_MEM1(ARGUMENTS), SLJIT_OFFSETOF(jit_arguments, options), SLJIT_IMM, PCRE2_NOTBOL);\n    add_jump(compiler, backtracks, JUMP(SLJIT_NOT_ZERO32));\n    }\n  return cc;\n\n  case OP_CIRCM:\n  /* TMP2 might be used by peek_char_back. */\n  if (HAS_VIRTUAL_REGISTERS)\n    {\n    OP1(SLJIT_MOV, TMP1, 0, ARGUMENTS, 0);\n    OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(TMP1), SLJIT_OFFSETOF(jit_arguments, begin));\n    jump\u00dd1\u00a8 = CMP(SLJIT_GREATER, STR_PTR, 0, TMP2, 0);\n    OP2(SLJIT_AND32 | SLJIT_SET_Z, SLJIT_UNUSED, 0, SLJIT_MEM1(TMP1), SLJIT_OFFSETOF(jit_arguments, options), SLJIT_IMM, PCRE2_NOTBOL);\n    }\n  else\n    {\n    OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(ARGUMENTS), SLJIT_OFFSETOF(jit_arguments, begin));\n    jump\u00dd1\u00a8 = CMP(SLJIT_GREATER, STR_PTR, 0, TMP2, 0);\n    OP2(SLJIT_AND32 | SLJIT_SET_Z, SLJIT_UNUSED, 0, SLJIT_MEM1(ARGUMENTS), SLJIT_OFFSETOF(jit_arguments, options), SLJIT_IMM, PCRE2_NOTBOL);\n    }\n  add_jump(compiler, backtracks, JUMP(SLJIT_NOT_ZERO32));\n  jump\u00dd0\u00a8 = JUMP(SLJIT_JUMP);\n  JUMPHERE(jump\u00dd1\u00a8);\n\n  if (!common->alt_circumflex)\n    add_jump(compiler, backtracks, CMP(SLJIT_GREATER_EQUAL, STR_PTR, 0, STR_END, 0));\n\n  if (common->nltype == NLTYPE_FIXED && common->newline > 255)\n    {\n    OP2(SLJIT_SUB, TMP1, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(2));\n    add_jump(compiler, backtracks, CMP(SLJIT_LESS, TMP1, 0, TMP2, 0));\n    OP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(-2));\n    OP1(MOV_UCHAR, TMP2, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(-1));\n    add_jump(compiler, backtracks, CMP(SLJIT_NOT_EQUAL, TMP1, 0, SLJIT_IMM, (common->newline >> 8) & 0xff));\n    add_jump(compiler, backtracks, CMP(SLJIT_NOT_EQUAL, TMP2, 0, SLJIT_IMM, common->newline & 0xff));\n    }\n  else\n    {\n    peek_char_back(common, common->nlmax, backtracks);\n    check_newlinechar(common, common->nltype, backtracks, FALSE);\n    }\n  JUMPHERE(jump\u00dd0\u00a8);\n  return cc;\n\n  case OP_REVERSE:\n  length = GET(cc, 0);\n  if (length == 0)\n    return cc + LINK_SIZE;\n  if (HAS_VIRTUAL_REGISTERS)\n    {\n    OP1(SLJIT_MOV, TMP1, 0, ARGUMENTS, 0);\n    OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(TMP1), SLJIT_OFFSETOF(jit_arguments, begin));\n    }\n  else\n    OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(ARGUMENTS), SLJIT_OFFSETOF(jit_arguments, begin));\n#ifdef SUPPORT_UNICODE\n  if (common->utf)\n    {\n    OP1(SLJIT_MOV, TMP3, 0, SLJIT_IMM, length);\n    label = LABEL();\n    add_jump(compiler, backtracks, CMP(SLJIT_LESS_EQUAL, STR_PTR, 0, TMP2, 0));\n    move_back(common, backtracks, FALSE);\n    OP2(SLJIT_SUB | SLJIT_SET_Z, TMP3, 0, TMP3, 0, SLJIT_IMM, 1);\n    JUMPTO(SLJIT_NOT_ZERO, label);\n    }\n  else\n#endif\n    {\n    OP2(SLJIT_SUB, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(length));\n    add_jump(compiler, backtracks, CMP(SLJIT_LESS, STR_PTR, 0, TMP2, 0));\n    }\n  check_start_used_ptr(common);\n  return cc + LINK_SIZE;\n  }\nSLJIT_UNREACHABLE();\nreturn cc;\n}\n\n#ifdef SUPPORT_UNICODE\n\n#if PCRE2_CODE_UNIT_WIDTH != 32\n\nstatic PCRE2_SPTR SLJIT_FUNC do_extuni_utf(jit_arguments *args, PCRE2_SPTR cc)\n{\nPCRE2_SPTR start_subject = args->begin;\nPCRE2_SPTR end_subject = args->end;\nint lgb, rgb, ricount;\nPCRE2_SPTR prevcc, endcc, bptr;\nBOOL first = TRUE;\nuint32_t c;\n\nprevcc = cc;\nendcc = NULL;\ndo\n  {\n  GETCHARINC(c, cc);\n  rgb = UCD_GRAPHBREAK(c);\n\n  if (first)\n    {\n    lgb = rgb;\n    endcc = cc;\n    first = FALSE;\n    continue;\n    }\n\n  if ((PRIV(ucp_gbtable)\u00ddlgb\u00a8 & (1 << rgb)) == 0)\n    break;\n\n  /* Not breaking between Regional Indicators is allowed only if there\n  are an even number of preceding RIs. */\n\n  if (lgb == ucp_gbRegionalIndicator && rgb == ucp_gbRegionalIndicator)\n    {\n    ricount = 0;\n    bptr = prevcc;\n\n    /* bptr is pointing to the left-hand character */\n    while (bptr > start_subject)\n      {\n      bptr--;\n      BACKCHAR(bptr);\n      GETCHAR(c, bptr);\n\n      if (UCD_GRAPHBREAK(c) != ucp_gbRegionalIndicator)\n        break;\n\n      ricount++;\n      }\n\n    if ((ricount & 1) != 0) break;  /* Grapheme break required */\n    }\n\n  /* If Extend or ZWJ follows Extended_Pictographic, do not update lgb; this\n  allows any number of them before a following Extended_Pictographic. */\n\n  if ((rgb != ucp_gbExtend && rgb != ucp_gbZWJ) ||\n       lgb != ucp_gbExtended_Pictographic)\n    lgb = rgb;\n\n  prevcc = endcc;\n  endcc = cc;\n  }\nwhile (cc < end_subject);\n\nreturn endcc;\n}\n\n#endif /* PCRE2_CODE_UNIT_WIDTH != 32 */\n\nstatic PCRE2_SPTR SLJIT_FUNC do_extuni_utf_invalid(jit_arguments *args, PCRE2_SPTR cc)\n{\nPCRE2_SPTR start_subject = args->begin;\nPCRE2_SPTR end_subject = args->end;\nint lgb, rgb, ricount;\nPCRE2_SPTR prevcc, endcc, bptr;\nBOOL first = TRUE;\nuint32_t c;\n\nprevcc = cc;\nendcc = NULL;\ndo\n  {\n  GETCHARINC_INVALID(c, cc, end_subject, break);\n  rgb = UCD_GRAPHBREAK(c);\n\n  if (first)\n    {\n    lgb = rgb;\n    endcc = cc;\n    first = FALSE;\n    continue;\n    }\n\n  if ((PRIV(ucp_gbtable)\u00ddlgb\u00a8 & (1 << rgb)) == 0)\n    break;\n\n  /* Not breaking between Regional Indicators is allowed only if there\n  are an even number of preceding RIs. */\n\n  if (lgb == ucp_gbRegionalIndicator && rgb == ucp_gbRegionalIndicator)\n    {\n    ricount = 0;\n    bptr = prevcc;\n\n    /* bptr is pointing to the left-hand character */\n    while (bptr > start_subject)\n      {\n      GETCHARBACK_INVALID(c, bptr, start_subject, break);\n\n      if (UCD_GRAPHBREAK(c) != ucp_gbRegionalIndicator)\n        break;\n\n      ricount++;\n      }\n\n    if ((ricount & 1) != 0)\n      break;  /* Grapheme break required */\n    }\n\n  /* If Extend or ZWJ follows Extended_Pictographic, do not update lgb; this\n  allows any number of them before a following Extended_Pictographic. */\n\n  if ((rgb != ucp_gbExtend && rgb != ucp_gbZWJ) ||\n       lgb != ucp_gbExtended_Pictographic)\n    lgb = rgb;\n\n  prevcc = endcc;\n  endcc = cc;\n  }\nwhile (cc < end_subject);\n\nreturn endcc;\n}\n\nstatic PCRE2_SPTR SLJIT_FUNC do_extuni_no_utf(jit_arguments *args, PCRE2_SPTR cc)\n{\nPCRE2_SPTR start_subject = args->begin;\nPCRE2_SPTR end_subject = args->end;\nint lgb, rgb, ricount;\nPCRE2_SPTR bptr;\nuint32_t c;\n\n/* Patch by PH */\n/* GETCHARINC(c, cc); */\nc = *cc++;\n\n#if PCRE2_CODE_UNIT_WIDTH == 32\nif (c >= 0x110000)\n  return NULL;\n#endif /* PCRE2_CODE_UNIT_WIDTH == 32 */\nlgb = UCD_GRAPHBREAK(c);\n\nwhile (cc < end_subject)\n  {\n  c = *cc;\n#if PCRE2_CODE_UNIT_WIDTH == 32\n  if (c >= 0x110000)\n    break;\n#endif /* PCRE2_CODE_UNIT_WIDTH == 32 */\n  rgb = UCD_GRAPHBREAK(c);\n\n  if ((PRIV(ucp_gbtable)\u00ddlgb\u00a8 & (1 << rgb)) == 0)\n    break;\n\n  /* Not breaking between Regional Indicators is allowed only if there\n  are an even number of preceding RIs. */\n\n  if (lgb == ucp_gbRegionalIndicator && rgb == ucp_gbRegionalIndicator)\n    {\n    ricount = 0;\n    bptr = cc - 1;\n\n    /* bptr is pointing to the left-hand character */\n    while (bptr > start_subject)\n      {\n      bptr--;\n      c = *bptr;\n#if PCRE2_CODE_UNIT_WIDTH == 32\n      if (c >= 0x110000)\n        break;\n#endif /* PCRE2_CODE_UNIT_WIDTH == 32 */\n\n      if (UCD_GRAPHBREAK(c) != ucp_gbRegionalIndicator) break;\n\n      ricount++;\n      }\n\n    if ((ricount & 1) != 0)\n      break;  /* Grapheme break required */\n    }\n\n  /* If Extend or ZWJ follows Extended_Pictographic, do not update lgb; this\n  allows any number of them before a following Extended_Pictographic. */\n\n  if ((rgb != ucp_gbExtend && rgb != ucp_gbZWJ) ||\n       lgb != ucp_gbExtended_Pictographic)\n    lgb = rgb;\n\n  cc++;\n  }\n\nreturn cc;\n}\n\n#endif /* SUPPORT_UNICODE */\n\nstatic PCRE2_SPTR compile_char1_matchingpath(compiler_common *common, PCRE2_UCHAR type, PCRE2_SPTR cc, jump_list **backtracks, BOOL check_str_ptr)\n{\nDEFINE_COMPILER;\nint length;\nunsigned int c, oc, bit;\ncompare_context context;\nstruct sljit_jump *jump\u00dd3\u00a8;\njump_list *end_list;\n#ifdef SUPPORT_UNICODE\nPCRE2_UCHAR propdata\u00dd5\u00a8;\n#endif /* SUPPORT_UNICODE */\n\nswitch(type)\n  {\n  case OP_NOT_DIGIT:\n  case OP_DIGIT:\n  /* Digits are usually 0-9, so it is worth to optimize them. */\n  if (check_str_ptr)\n    detect_partial_match(common, backtracks);\n#if defined SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH == 8\n  if (common->utf && is_char7_bitset((const sljit_u8*)common->ctypes - cbit_length + cbit_digit, FALSE))\n    read_char7_type(common, backtracks, type == OP_NOT_DIGIT);\n  else\n#endif\n    read_char8_type(common, backtracks, type == OP_NOT_DIGIT);\n    /* Flip the starting bit in the negative case. */\n  OP2(SLJIT_AND | SLJIT_SET_Z, SLJIT_UNUSED, 0, TMP1, 0, SLJIT_IMM, ctype_digit);\n  add_jump(compiler, backtracks, JUMP(type == OP_DIGIT ? SLJIT_ZERO : SLJIT_NOT_ZERO));\n  return cc;\n\n  case OP_NOT_WHITESPACE:\n  case OP_WHITESPACE:\n  if (check_str_ptr)\n    detect_partial_match(common, backtracks);\n#if defined SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH == 8\n  if (common->utf && is_char7_bitset((const sljit_u8*)common->ctypes - cbit_length + cbit_space, FALSE))\n    read_char7_type(common, backtracks, type == OP_NOT_WHITESPACE);\n  else\n#endif\n    read_char8_type(common, backtracks, type == OP_NOT_WHITESPACE);\n  OP2(SLJIT_AND | SLJIT_SET_Z, SLJIT_UNUSED, 0, TMP1, 0, SLJIT_IMM, ctype_space);\n  add_jump(compiler, backtracks, JUMP(type == OP_WHITESPACE ? SLJIT_ZERO : SLJIT_NOT_ZERO));\n  return cc;\n\n  case OP_NOT_WORDCHAR:\n  case OP_WORDCHAR:\n  if (check_str_ptr)\n    detect_partial_match(common, backtracks);\n#if defined SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH == 8\n  if (common->utf && is_char7_bitset((const sljit_u8*)common->ctypes - cbit_length + cbit_word, FALSE))\n    read_char7_type(common, backtracks, type == OP_NOT_WORDCHAR);\n  else\n#endif\n    read_char8_type(common, backtracks, type == OP_NOT_WORDCHAR);\n  OP2(SLJIT_AND | SLJIT_SET_Z, SLJIT_UNUSED, 0, TMP1, 0, SLJIT_IMM, ctype_word);\n  add_jump(compiler, backtracks, JUMP(type == OP_WORDCHAR ? SLJIT_ZERO : SLJIT_NOT_ZERO));\n  return cc;\n\n  case OP_ANY:\n  if (check_str_ptr)\n    detect_partial_match(common, backtracks);\n  read_char(common, common->nlmin, common->nlmax, backtracks, READ_CHAR_UPDATE_STR_PTR);\n  if (common->nltype == NLTYPE_FIXED && common->newline > 255)\n    {\n    jump\u00dd0\u00a8 = CMP(SLJIT_NOT_EQUAL, TMP1, 0, SLJIT_IMM, (common->newline >> 8) & 0xff);\n    end_list = NULL;\n    if (common->mode != PCRE2_JIT_PARTIAL_HARD)\n      add_jump(compiler, &end_list, CMP(SLJIT_GREATER_EQUAL, STR_PTR, 0, STR_END, 0));\n    else\n      check_str_end(common, &end_list);\n\n    OP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(STR_PTR), 0);\n    add_jump(compiler, backtracks, CMP(SLJIT_EQUAL, TMP1, 0, SLJIT_IMM, common->newline & 0xff));\n    set_jumps(end_list, LABEL());\n    JUMPHERE(jump\u00dd0\u00a8);\n    }\n  else\n    check_newlinechar(common, common->nltype, backtracks, TRUE);\n  return cc;\n\n  case OP_ALLANY:\n  if (check_str_ptr)\n    detect_partial_match(common, backtracks);\n#ifdef SUPPORT_UNICODE\n  if (common->utf)\n    {\n    if (common->invalid_utf)\n      {\n      read_char(common, 0, READ_CHAR_MAX, backtracks, READ_CHAR_UPDATE_STR_PTR);\n      return cc;\n      }\n\n#if PCRE2_CODE_UNIT_WIDTH == 8 || PCRE2_CODE_UNIT_WIDTH == 16\n    OP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(STR_PTR), 0);\n    OP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n#if PCRE2_CODE_UNIT_WIDTH == 8\n    jump\u00dd0\u00a8 = CMP(SLJIT_LESS, TMP1, 0, SLJIT_IMM, 0xc0);\n    OP1(SLJIT_MOV_U8, TMP1, 0, SLJIT_MEM1(TMP1), (sljit_sw)PRIV(utf8_table4) - 0xc0);\n    OP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, TMP1, 0);\n#elif PCRE2_CODE_UNIT_WIDTH == 16\n    jump\u00dd0\u00a8 = CMP(SLJIT_LESS, TMP1, 0, SLJIT_IMM, 0xd800);\n    OP2(SLJIT_AND, TMP1, 0, TMP1, 0, SLJIT_IMM, 0xfc00);\n    OP2(SLJIT_SUB | SLJIT_SET_Z, SLJIT_UNUSED, 0, TMP1, 0, SLJIT_IMM, 0xd800);\n    OP_FLAGS(SLJIT_MOV, TMP1, 0, SLJIT_EQUAL);\n    OP2(SLJIT_SHL, TMP1, 0, TMP1, 0, SLJIT_IMM, 1);\n    OP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, TMP1, 0);\n#endif /* PCRE2_CODE_UNIT_WIDTH == 8 */\n    JUMPHERE(jump\u00dd0\u00a8);\n    return cc;\n#endif /* PCRE2_CODE_UNIT_WIDTH == \u00dd8|16\u00a8 */\n    }\n#endif /* SUPPORT_UNICODE */\n  OP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n  return cc;\n\n  case OP_ANYBYTE:\n  if (check_str_ptr)\n    detect_partial_match(common, backtracks);\n  OP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n  return cc;\n\n#ifdef SUPPORT_UNICODE\n  case OP_NOTPROP:\n  case OP_PROP:\n  propdata\u00dd0\u00a8 = XCL_HASPROP;\n  propdata\u00dd1\u00a8 = type == OP_NOTPROP ? XCL_NOTPROP : XCL_PROP;\n  propdata\u00dd2\u00a8 = cc\u00dd0\u00a8;\n  propdata\u00dd3\u00a8 = cc\u00dd1\u00a8;\n  propdata\u00dd4\u00a8 = XCL_END;\n  if (check_str_ptr)\n    detect_partial_match(common, backtracks);\n  compile_xclass_matchingpath(common, propdata, backtracks);\n  return cc + 2;\n#endif\n\n  case OP_ANYNL:\n  if (check_str_ptr)\n    detect_partial_match(common, backtracks);\n  read_char(common, common->bsr_nlmin, common->bsr_nlmax, NULL, 0);\n  jump\u00dd0\u00a8 = CMP(SLJIT_NOT_EQUAL, TMP1, 0, SLJIT_IMM, CHAR_CR);\n  /* We don't need to handle soft partial matching case. */\n  end_list = NULL;\n  if (common->mode != PCRE2_JIT_PARTIAL_HARD)\n    add_jump(compiler, &end_list, CMP(SLJIT_GREATER_EQUAL, STR_PTR, 0, STR_END, 0));\n  else\n    check_str_end(common, &end_list);\n  OP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(STR_PTR), 0);\n  jump\u00dd1\u00a8 = CMP(SLJIT_NOT_EQUAL, TMP1, 0, SLJIT_IMM, CHAR_NL);\n  OP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n  jump\u00dd2\u00a8 = JUMP(SLJIT_JUMP);\n  JUMPHERE(jump\u00dd0\u00a8);\n  check_newlinechar(common, common->bsr_nltype, backtracks, FALSE);\n  set_jumps(end_list, LABEL());\n  JUMPHERE(jump\u00dd1\u00a8);\n  JUMPHERE(jump\u00dd2\u00a8);\n  return cc;\n\n  case OP_NOT_HSPACE:\n  case OP_HSPACE:\n  if (check_str_ptr)\n    detect_partial_match(common, backtracks);\n\n  if (type == OP_NOT_HSPACE)\n    read_char(common, 0x9, 0x3000, backtracks, READ_CHAR_UPDATE_STR_PTR);\n  else\n    read_char(common, 0x9, 0x3000, NULL, 0);\n\n  add_jump(compiler, &common->hspace, JUMP(SLJIT_FAST_CALL));\n  sljit_set_current_flags(compiler, SLJIT_SET_Z);\n  add_jump(compiler, backtracks, JUMP(type == OP_NOT_HSPACE ? SLJIT_NOT_ZERO : SLJIT_ZERO));\n  return cc;\n\n  case OP_NOT_VSPACE:\n  case OP_VSPACE:\n  if (check_str_ptr)\n    detect_partial_match(common, backtracks);\n\n  if (type == OP_NOT_VSPACE)\n    read_char(common, 0xa, 0x2029, backtracks, READ_CHAR_UPDATE_STR_PTR);\n  else\n    read_char(common, 0xa, 0x2029, NULL, 0);\n\n  add_jump(compiler, &common->vspace, JUMP(SLJIT_FAST_CALL));\n  sljit_set_current_flags(compiler, SLJIT_SET_Z);\n  add_jump(compiler, backtracks, JUMP(type == OP_NOT_VSPACE ? SLJIT_NOT_ZERO : SLJIT_ZERO));\n  return cc;\n\n#ifdef SUPPORT_UNICODE\n  case OP_EXTUNI:\n  if (check_str_ptr)\n    detect_partial_match(common, backtracks);\n\n  SLJIT_ASSERT(TMP1 == SLJIT_R0 && STR_PTR == SLJIT_R1);\n  OP1(SLJIT_MOV, SLJIT_R0, 0, ARGUMENTS, 0);\n\n#if PCRE2_CODE_UNIT_WIDTH != 32\n  sljit_emit_icall(compiler, SLJIT_CALL, SLJIT_RET(SW) | SLJIT_ARG1(SW) | SLJIT_ARG2(SW), SLJIT_IMM,\n    common->utf ? (common->invalid_utf ? SLJIT_FUNC_OFFSET(do_extuni_utf_invalid) : SLJIT_FUNC_OFFSET(do_extuni_utf)) : SLJIT_FUNC_OFFSET(do_extuni_no_utf));\n  if (common->invalid_utf)\n    add_jump(compiler, backtracks, CMP(SLJIT_EQUAL, SLJIT_RETURN_REG, 0, SLJIT_IMM, 0));\n#else\n  sljit_emit_icall(compiler, SLJIT_CALL, SLJIT_RET(SW) | SLJIT_ARG1(SW) | SLJIT_ARG2(SW), SLJIT_IMM,\n    common->invalid_utf ? SLJIT_FUNC_OFFSET(do_extuni_utf_invalid) : SLJIT_FUNC_OFFSET(do_extuni_no_utf));\n  if (!common->utf || common->invalid_utf)\n    add_jump(compiler, backtracks, CMP(SLJIT_EQUAL, SLJIT_RETURN_REG, 0, SLJIT_IMM, 0));\n#endif\n\n  OP1(SLJIT_MOV, STR_PTR, 0, SLJIT_RETURN_REG, 0);\n\n  if (common->mode == PCRE2_JIT_PARTIAL_HARD)\n    {\n    jump\u00dd0\u00a8 = CMP(SLJIT_LESS, SLJIT_RETURN_REG, 0, STR_END, 0);\n    /* Since we successfully read a char above, partial matching must occure. */\n    check_partial(common, TRUE);\n    JUMPHERE(jump\u00dd0\u00a8);\n    }\n  return cc;\n#endif\n\n  case OP_CHAR:\n  case OP_CHARI:\n  length = 1;\n#ifdef SUPPORT_UNICODE\n  if (common->utf && HAS_EXTRALEN(*cc)) length += GET_EXTRALEN(*cc);\n#endif\n\n  if (check_str_ptr && common->mode != PCRE2_JIT_COMPLETE)\n    detect_partial_match(common, backtracks);\n\n  if (type == OP_CHAR || !char_has_othercase(common, cc) || char_get_othercase_bit(common, cc) != 0)\n    {\n    OP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(length));\n    if (length > 1 || (check_str_ptr && common->mode == PCRE2_JIT_COMPLETE))\n      add_jump(compiler, backtracks, CMP(SLJIT_GREATER, STR_PTR, 0, STR_END, 0));\n\n    context.length = IN_UCHARS(length);\n    context.sourcereg = -1;\n#if defined SLJIT_UNALIGNED && SLJIT_UNALIGNED\n    context.ucharptr = 0;\n#endif\n    return byte_sequence_compare(common, type == OP_CHARI, cc, &context, backtracks);\n    }\n\n#ifdef SUPPORT_UNICODE\n  if (common->utf)\n    {\n    GETCHAR(c, cc);\n    }\n  else\n#endif\n    c = *cc;\n\n  SLJIT_ASSERT(type == OP_CHARI && char_has_othercase(common, cc));\n\n  if (check_str_ptr && common->mode == PCRE2_JIT_COMPLETE)\n    add_jump(compiler, backtracks, CMP(SLJIT_GREATER_EQUAL, STR_PTR, 0, STR_END, 0));\n\n  oc = char_othercase(common, c);\n  read_char(common, c < oc ? c : oc, c > oc ? c : oc, NULL, 0);\n\n  SLJIT_ASSERT(!is_powerof2(c \u00ac oc));\n\n  if (sljit_has_cpu_feature(SLJIT_HAS_CMOV))\n    {\n    OP2(SLJIT_SUB | SLJIT_SET_Z, SLJIT_UNUSED, 0, TMP1, 0, SLJIT_IMM, oc);\n    CMOV(SLJIT_EQUAL, TMP1, SLJIT_IMM, c);\n    add_jump(compiler, backtracks, CMP(SLJIT_NOT_EQUAL, TMP1, 0, SLJIT_IMM, c));\n    }\n  else\n    {\n    jump\u00dd0\u00a8 = CMP(SLJIT_EQUAL, TMP1, 0, SLJIT_IMM, c);\n    add_jump(compiler, backtracks, CMP(SLJIT_NOT_EQUAL, TMP1, 0, SLJIT_IMM, oc));\n    JUMPHERE(jump\u00dd0\u00a8);\n    }\n  return cc + length;\n\n  case OP_NOT:\n  case OP_NOTI:\n  if (check_str_ptr)\n    detect_partial_match(common, backtracks);\n\n  length = 1;\n#ifdef SUPPORT_UNICODE\n  if (common->utf)\n    {\n#if PCRE2_CODE_UNIT_WIDTH == 8\n    c = *cc;\n    if (c < 128 && !common->invalid_utf)\n      {\n      OP1(SLJIT_MOV_U8, TMP1, 0, SLJIT_MEM1(STR_PTR), 0);\n      if (type == OP_NOT || !char_has_othercase(common, cc))\n        add_jump(compiler, backtracks, CMP(SLJIT_EQUAL, TMP1, 0, SLJIT_IMM, c));\n      else\n        {\n        /* Since UTF8 code page is fixed, we know that c is in \u00dda-z\u00a8 or \u00ddA-Z\u00a8 range. */\n        OP2(SLJIT_OR, TMP2, 0, TMP1, 0, SLJIT_IMM, 0x20);\n        add_jump(compiler, backtracks, CMP(SLJIT_EQUAL, TMP2, 0, SLJIT_IMM, c | 0x20));\n        }\n      /* Skip the variable-length character. */\n      OP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n      jump\u00dd0\u00a8 = CMP(SLJIT_LESS, TMP1, 0, SLJIT_IMM, 0xc0);\n      OP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(TMP1), (sljit_sw)PRIV(utf8_table4) - 0xc0);\n      OP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, TMP1, 0);\n      JUMPHERE(jump\u00dd0\u00a8);\n      return cc + 1;\n      }\n    else\n#endif /* PCRE2_CODE_UNIT_WIDTH == 8 */\n      {\n      GETCHARLEN(c, cc, length);\n      }\n    }\n  else\n#endif /* SUPPORT_UNICODE */\n    c = *cc;\n\n  if (type == OP_NOT || !char_has_othercase(common, cc))\n    {\n    read_char(common, c, c, backtracks, READ_CHAR_UPDATE_STR_PTR);\n    add_jump(compiler, backtracks, CMP(SLJIT_EQUAL, TMP1, 0, SLJIT_IMM, c));\n    }\n  else\n    {\n    oc = char_othercase(common, c);\n    read_char(common, c < oc ? c : oc, c > oc ? c : oc, backtracks, READ_CHAR_UPDATE_STR_PTR);\n    bit = c \u00ac oc;\n    if (is_powerof2(bit))\n      {\n      OP2(SLJIT_OR, TMP1, 0, TMP1, 0, SLJIT_IMM, bit);\n      add_jump(compiler, backtracks, CMP(SLJIT_EQUAL, TMP1, 0, SLJIT_IMM, c | bit));\n      }\n    else\n      {\n      add_jump(compiler, backtracks, CMP(SLJIT_EQUAL, TMP1, 0, SLJIT_IMM, c));\n      add_jump(compiler, backtracks, CMP(SLJIT_EQUAL, TMP1, 0, SLJIT_IMM, oc));\n      }\n    }\n  return cc + length;\n\n  case OP_CLASS:\n  case OP_NCLASS:\n  if (check_str_ptr)\n    detect_partial_match(common, backtracks);\n\n#if defined SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH == 8\n  bit = (common->utf && is_char7_bitset((const sljit_u8 *)cc, type == OP_NCLASS)) ? 127 : 255;\n  if (type == OP_NCLASS)\n    read_char(common, 0, bit, backtracks, READ_CHAR_UPDATE_STR_PTR);\n  else\n    read_char(common, 0, bit, NULL, 0);\n#else\n  if (type == OP_NCLASS)\n    read_char(common, 0, 255, backtracks, READ_CHAR_UPDATE_STR_PTR);\n  else\n    read_char(common, 0, 255, NULL, 0);\n#endif\n\n  if (optimize_class(common, (const sljit_u8 *)cc, type == OP_NCLASS, FALSE, backtracks))\n    return cc + 32 / sizeof(PCRE2_UCHAR);\n\n#if defined SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH == 8\n  jump\u00dd0\u00a8 = NULL;\n  if (common->utf)\n    {\n    jump\u00dd0\u00a8 = CMP(SLJIT_GREATER, TMP1, 0, SLJIT_IMM, bit);\n    if (type == OP_CLASS)\n      {\n      add_jump(compiler, backtracks, jump\u00dd0\u00a8);\n      jump\u00dd0\u00a8 = NULL;\n      }\n    }\n#elif PCRE2_CODE_UNIT_WIDTH != 8\n  jump\u00dd0\u00a8 = CMP(SLJIT_GREATER, TMP1, 0, SLJIT_IMM, 255);\n  if (type == OP_CLASS)\n    {\n    add_jump(compiler, backtracks, jump\u00dd0\u00a8);\n    jump\u00dd0\u00a8 = NULL;\n    }\n#endif /* SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH == 8 */\n\n  OP2(SLJIT_AND, TMP2, 0, TMP1, 0, SLJIT_IMM, 0x7);\n  OP2(SLJIT_LSHR, TMP1, 0, TMP1, 0, SLJIT_IMM, 3);\n  OP1(SLJIT_MOV_U8, TMP1, 0, SLJIT_MEM1(TMP1), (sljit_sw)cc);\n  OP2(SLJIT_SHL, TMP2, 0, SLJIT_IMM, 1, TMP2, 0);\n  OP2(SLJIT_AND | SLJIT_SET_Z, SLJIT_UNUSED, 0, TMP1, 0, TMP2, 0);\n  add_jump(compiler, backtracks, JUMP(SLJIT_ZERO));\n\n#if defined SUPPORT_UNICODE || PCRE2_CODE_UNIT_WIDTH != 8\n  if (jump\u00dd0\u00a8 != NULL)\n    JUMPHERE(jump\u00dd0\u00a8);\n#endif\n  return cc + 32 / sizeof(PCRE2_UCHAR);\n\n#if defined SUPPORT_UNICODE || PCRE2_CODE_UNIT_WIDTH == 16 || PCRE2_CODE_UNIT_WIDTH == 32\n  case OP_XCLASS:\n  if (check_str_ptr)\n    detect_partial_match(common, backtracks);\n  compile_xclass_matchingpath(common, cc + LINK_SIZE, backtracks);\n  return cc + GET(cc, 0) - 1;\n#endif\n  }\nSLJIT_UNREACHABLE();\nreturn cc;\n}\n\nstatic SLJIT_INLINE PCRE2_SPTR compile_charn_matchingpath(compiler_common *common, PCRE2_SPTR cc, PCRE2_SPTR ccend, jump_list **backtracks)\n{\n/* This function consumes at least one input character. */\n/* To decrease the number of length checks, we try to concatenate the fixed length character sequences. */\nDEFINE_COMPILER;\nPCRE2_SPTR ccbegin = cc;\ncompare_context context;\nint size;\n\ncontext.length = 0;\ndo\n  {\n  if (cc >= ccend)\n    break;\n\n  if (*cc == OP_CHAR)\n    {\n    size = 1;\n#ifdef SUPPORT_UNICODE\n    if (common->utf && HAS_EXTRALEN(cc\u00dd1\u00a8))\n      size += GET_EXTRALEN(cc\u00dd1\u00a8);\n#endif\n    }\n  else if (*cc == OP_CHARI)\n    {\n    size = 1;\n#ifdef SUPPORT_UNICODE\n    if (common->utf)\n      {\n      if (char_has_othercase(common, cc + 1) && char_get_othercase_bit(common, cc + 1) == 0)\n        size = 0;\n      else if (HAS_EXTRALEN(cc\u00dd1\u00a8))\n        size += GET_EXTRALEN(cc\u00dd1\u00a8);\n      }\n    else\n#endif\n    if (char_has_othercase(common, cc + 1) && char_get_othercase_bit(common, cc + 1) == 0)\n      size = 0;\n    }\n  else\n    size = 0;\n\n  cc += 1 + size;\n  context.length += IN_UCHARS(size);\n  }\nwhile (size > 0 && context.length <= 128);\n\ncc = ccbegin;\nif (context.length > 0)\n  {\n  /* We have a fixed-length byte sequence. */\n  OP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, context.length);\n  add_jump(compiler, backtracks, CMP(SLJIT_GREATER, STR_PTR, 0, STR_END, 0));\n\n  context.sourcereg = -1;\n#if defined SLJIT_UNALIGNED && SLJIT_UNALIGNED\n  context.ucharptr = 0;\n#endif\n  do cc = byte_sequence_compare(common, *cc == OP_CHARI, cc + 1, &context, backtracks); while (context.length > 0);\n  return cc;\n  }\n\n/* A non-fixed length character will be checked if length == 0. */\nreturn compile_char1_matchingpath(common, *cc, cc + 1, backtracks, TRUE);\n}\n\n/* Forward definitions. */\nstatic void compile_matchingpath(compiler_common *, PCRE2_SPTR, PCRE2_SPTR, backtrack_common *);\nstatic void compile_backtrackingpath(compiler_common *, struct backtrack_common *);\n\n#define PUSH_BACKTRACK(size, ccstart, error) \\\n  do \\\n    { \\\n    backtrack = sljit_alloc_memory(compiler, (size)); \\\n    if (SLJIT_UNLIKELY(sljit_get_compiler_error(compiler))) \\\n      return error; \\\n    memset(backtrack, 0, size); \\\n    backtrack->prev = parent->top; \\\n    backtrack->cc = (ccstart); \\\n    parent->top = backtrack; \\\n    } \\\n  while (0)\n\n#define PUSH_BACKTRACK_NOVALUE(size, ccstart) \\\n  do \\\n    { \\\n    backtrack = sljit_alloc_memory(compiler, (size)); \\\n    if (SLJIT_UNLIKELY(sljit_get_compiler_error(compiler))) \\\n      return; \\\n    memset(backtrack, 0, size); \\\n    backtrack->prev = parent->top; \\\n    backtrack->cc = (ccstart); \\\n    parent->top = backtrack; \\\n    } \\\n  while (0)\n\n#define BACKTRACK_AS(type) ((type *)backtrack)\n\nstatic void compile_dnref_search(compiler_common *common, PCRE2_SPTR cc, jump_list **backtracks)\n{\n/* The OVECTOR offset goes to TMP2. */\nDEFINE_COMPILER;\nint count = GET2(cc, 1 + IMM2_SIZE);\nPCRE2_SPTR slot = common->name_table + GET2(cc, 1) * common->name_entry_size;\nunsigned int offset;\njump_list *found = NULL;\n\nSLJIT_ASSERT(*cc == OP_DNREF || *cc == OP_DNREFI);\n\nOP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(SLJIT_SP), OVECTOR(1));\n\ncount--;\nwhile (count-- > 0)\n  {\n  offset = GET2(slot, 0) << 1;\n  GET_LOCAL_BASE(TMP2, 0, OVECTOR(offset));\n  add_jump(compiler, &found, CMP(SLJIT_NOT_EQUAL, SLJIT_MEM1(SLJIT_SP), OVECTOR(offset), TMP1, 0));\n  slot += common->name_entry_size;\n  }\n\noffset = GET2(slot, 0) << 1;\nGET_LOCAL_BASE(TMP2, 0, OVECTOR(offset));\nif (backtracks != NULL && !common->unset_backref)\n  add_jump(compiler, backtracks, CMP(SLJIT_EQUAL, SLJIT_MEM1(SLJIT_SP), OVECTOR(offset), TMP1, 0));\n\nset_jumps(found, LABEL());\n}\n\nstatic void compile_ref_matchingpath(compiler_common *common, PCRE2_SPTR cc, jump_list **backtracks, BOOL withchecks, BOOL emptyfail)\n{\nDEFINE_COMPILER;\nBOOL ref = (*cc == OP_REF || *cc == OP_REFI);\nint offset = 0;\nstruct sljit_jump *jump = NULL;\nstruct sljit_jump *partial;\nstruct sljit_jump *nopartial;\n#if defined SUPPORT_UNICODE\nstruct sljit_label *loop;\nstruct sljit_label *caseless_loop;\njump_list *no_match = NULL;\nint source_reg = COUNT_MATCH;\nint source_end_reg = ARGUMENTS;\nint char1_reg = STACK_LIMIT;\n#endif /* SUPPORT_UNICODE */\n\nif (ref)\n  {\n  offset = GET2(cc, 1) << 1;\n  OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(SLJIT_SP), OVECTOR(offset));\n  /* OVECTOR(1) contains the \"string begin - 1\" constant. */\n  if (withchecks && !common->unset_backref)\n    add_jump(compiler, backtracks, CMP(SLJIT_EQUAL, TMP1, 0, SLJIT_MEM1(SLJIT_SP), OVECTOR(1)));\n  }\nelse\n  OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(TMP2), 0);\n\n#if defined SUPPORT_UNICODE\nif (common->utf && *cc == OP_REFI)\n  {\n  SLJIT_ASSERT(common->iref_ptr != 0);\n\n  if (ref)\n    OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(SLJIT_SP), OVECTOR(offset + 1));\n  else\n    OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(TMP2), sizeof(sljit_sw));\n\n  if (withchecks && emptyfail)\n    add_jump(compiler, backtracks, CMP(SLJIT_EQUAL, TMP1, 0, TMP2, 0));\n\n  OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), common->iref_ptr, source_reg, 0);\n  OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), common->iref_ptr + sizeof(sljit_sw), source_end_reg, 0);\n  OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), common->iref_ptr + sizeof(sljit_sw) * 2, char1_reg, 0);\n\n  OP1(SLJIT_MOV, source_reg, 0, TMP1, 0);\n  OP1(SLJIT_MOV, source_end_reg, 0, TMP2, 0);\n\n  loop = LABEL();\n  jump = CMP(SLJIT_GREATER_EQUAL, source_reg, 0, source_end_reg, 0);\n  partial = CMP(SLJIT_GREATER_EQUAL, STR_PTR, 0, STR_END, 0);\n\n  /* Read original character. It must be a valid UTF character. */\n  OP1(SLJIT_MOV, TMP3, 0, STR_PTR, 0);\n  OP1(SLJIT_MOV, STR_PTR, 0, source_reg, 0);\n\n  read_char(common, 0, READ_CHAR_MAX, NULL, READ_CHAR_UPDATE_STR_PTR | READ_CHAR_VALID_UTF);\n\n  OP1(SLJIT_MOV, source_reg, 0, STR_PTR, 0);\n  OP1(SLJIT_MOV, STR_PTR, 0, TMP3, 0);\n  OP1(SLJIT_MOV, char1_reg, 0, TMP1, 0);\n\n  /* Read second character. */\n  read_char(common, 0, READ_CHAR_MAX, &no_match, READ_CHAR_UPDATE_STR_PTR);\n\n  CMPTO(SLJIT_EQUAL, TMP1, 0, char1_reg, 0, loop);\n\n  OP1(SLJIT_MOV, TMP3, 0, TMP1, 0);\n\n  add_jump(compiler, &common->getucd, JUMP(SLJIT_FAST_CALL));\n\n  OP2(SLJIT_SHL, TMP1, 0, TMP2, 0, SLJIT_IMM, 2);\n  OP2(SLJIT_SHL, TMP2, 0, TMP2, 0, SLJIT_IMM, 3);\n  OP2(SLJIT_ADD, TMP2, 0, TMP2, 0, TMP1, 0);\n\n  OP2(SLJIT_ADD, TMP2, 0, TMP2, 0, SLJIT_IMM, (sljit_sw)PRIV(ucd_records));\n\n  OP1(SLJIT_MOV_S32, TMP1, 0, SLJIT_MEM1(TMP2), SLJIT_OFFSETOF(ucd_record, other_case));\n  OP1(SLJIT_MOV_U8, TMP2, 0, SLJIT_MEM1(TMP2), SLJIT_OFFSETOF(ucd_record, caseset));\n  OP2(SLJIT_ADD, TMP1, 0, TMP1, 0, TMP3, 0);\n  CMPTO(SLJIT_EQUAL, TMP1, 0, char1_reg, 0, loop);\n\n  add_jump(compiler, &no_match, CMP(SLJIT_EQUAL, TMP2, 0, SLJIT_IMM, 0));\n  OP2(SLJIT_SHL, TMP2, 0, TMP2, 0, SLJIT_IMM, 2);\n  OP2(SLJIT_ADD, TMP2, 0, TMP2, 0, SLJIT_IMM, (sljit_sw)PRIV(ucd_caseless_sets));\n\n  caseless_loop = LABEL();\n  OP1(SLJIT_MOV_U32, TMP1, 0, SLJIT_MEM1(TMP2), 0);\n  OP2(SLJIT_ADD, TMP2, 0, TMP2, 0, SLJIT_IMM, sizeof(uint32_t));\n  OP2(SLJIT_SUB | SLJIT_SET_Z | SLJIT_SET_LESS, SLJIT_UNUSED, 0, TMP1, 0, char1_reg, 0);\n  JUMPTO(SLJIT_EQUAL, loop);\n  JUMPTO(SLJIT_LESS, caseless_loop);\n\n  set_jumps(no_match, LABEL());\n  if (common->mode == PCRE2_JIT_COMPLETE)\n    JUMPHERE(partial);\n\n  OP1(SLJIT_MOV, source_reg, 0, SLJIT_MEM1(SLJIT_SP), common->iref_ptr);\n  OP1(SLJIT_MOV, source_end_reg, 0, SLJIT_MEM1(SLJIT_SP), common->iref_ptr + sizeof(sljit_sw));\n  OP1(SLJIT_MOV, char1_reg, 0, SLJIT_MEM1(SLJIT_SP), common->iref_ptr + sizeof(sljit_sw) * 2);\n  add_jump(compiler, backtracks, JUMP(SLJIT_JUMP));\n\n  if (common->mode != PCRE2_JIT_COMPLETE)\n    {\n    JUMPHERE(partial);\n    OP1(SLJIT_MOV, source_reg, 0, SLJIT_MEM1(SLJIT_SP), common->iref_ptr);\n    OP1(SLJIT_MOV, source_end_reg, 0, SLJIT_MEM1(SLJIT_SP), common->iref_ptr + sizeof(sljit_sw));\n    OP1(SLJIT_MOV, char1_reg, 0, SLJIT_MEM1(SLJIT_SP), common->iref_ptr + sizeof(sljit_sw) * 2);\n\n    check_partial(common, FALSE);\n    add_jump(compiler, backtracks, JUMP(SLJIT_JUMP));\n    }\n\n  JUMPHERE(jump);\n  OP1(SLJIT_MOV, source_reg, 0, SLJIT_MEM1(SLJIT_SP), common->iref_ptr);\n  OP1(SLJIT_MOV, source_end_reg, 0, SLJIT_MEM1(SLJIT_SP), common->iref_ptr + sizeof(sljit_sw));\n  OP1(SLJIT_MOV, char1_reg, 0, SLJIT_MEM1(SLJIT_SP), common->iref_ptr + sizeof(sljit_sw) * 2);\n  return;\n  }\nelse\n#endif /* SUPPORT_UNICODE */\n  {\n  if (ref)\n    OP2(SLJIT_SUB | SLJIT_SET_Z, TMP2, 0, SLJIT_MEM1(SLJIT_SP), OVECTOR(offset + 1), TMP1, 0);\n  else\n    OP2(SLJIT_SUB | SLJIT_SET_Z, TMP2, 0, SLJIT_MEM1(TMP2), sizeof(sljit_sw), TMP1, 0);\n\n  if (withchecks)\n    jump = JUMP(SLJIT_ZERO);\n\n  OP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, TMP2, 0);\n  partial = CMP(SLJIT_GREATER, STR_PTR, 0, STR_END, 0);\n  if (common->mode == PCRE2_JIT_COMPLETE)\n    add_jump(compiler, backtracks, partial);\n\n  add_jump(compiler, *cc == OP_REF ? &common->casefulcmp : &common->caselesscmp, JUMP(SLJIT_FAST_CALL));\n  add_jump(compiler, backtracks, CMP(SLJIT_NOT_EQUAL, TMP2, 0, SLJIT_IMM, 0));\n\n  if (common->mode != PCRE2_JIT_COMPLETE)\n    {\n    nopartial = JUMP(SLJIT_JUMP);\n    JUMPHERE(partial);\n    /* TMP2 -= STR_END - STR_PTR */\n    OP2(SLJIT_SUB, TMP2, 0, TMP2, 0, STR_PTR, 0);\n    OP2(SLJIT_ADD, TMP2, 0, TMP2, 0, STR_END, 0);\n    partial = CMP(SLJIT_EQUAL, TMP2, 0, SLJIT_IMM, 0);\n    OP1(SLJIT_MOV, STR_PTR, 0, STR_END, 0);\n    add_jump(compiler, *cc == OP_REF ? &common->casefulcmp : &common->caselesscmp, JUMP(SLJIT_FAST_CALL));\n    add_jump(compiler, backtracks, CMP(SLJIT_NOT_EQUAL, TMP2, 0, SLJIT_IMM, 0));\n    JUMPHERE(partial);\n    check_partial(common, FALSE);\n    add_jump(compiler, backtracks, JUMP(SLJIT_JUMP));\n    JUMPHERE(nopartial);\n    }\n  }\n\nif (jump != NULL)\n  {\n  if (emptyfail)\n    add_jump(compiler, backtracks, jump);\n  else\n    JUMPHERE(jump);\n  }\n}\n\nstatic SLJIT_INLINE PCRE2_SPTR compile_ref_iterator_matchingpath(compiler_common *common, PCRE2_SPTR cc, backtrack_common *parent)\n{\nDEFINE_COMPILER;\nBOOL ref = (*cc == OP_REF || *cc == OP_REFI);\nbacktrack_common *backtrack;\nPCRE2_UCHAR type;\nint offset = 0;\nstruct sljit_label *label;\nstruct sljit_jump *zerolength;\nstruct sljit_jump *jump = NULL;\nPCRE2_SPTR ccbegin = cc;\nint min = 0, max = 0;\nBOOL minimize;\n\nPUSH_BACKTRACK(sizeof(ref_iterator_backtrack), cc, NULL);\n\nif (ref)\n  offset = GET2(cc, 1) << 1;\nelse\n  cc += IMM2_SIZE;\ntype = cc\u00dd1 + IMM2_SIZE\u00a8;\n\nSLJIT_COMPILE_ASSERT((OP_CRSTAR & 0x1) == 0, crstar_opcode_must_be_even);\nminimize = (type & 0x1) != 0;\nswitch(type)\n  {\n  case OP_CRSTAR:\n  case OP_CRMINSTAR:\n  min = 0;\n  max = 0;\n  cc += 1 + IMM2_SIZE + 1;\n  break;\n  case OP_CRPLUS:\n  case OP_CRMINPLUS:\n  min = 1;\n  max = 0;\n  cc += 1 + IMM2_SIZE + 1;\n  break;\n  case OP_CRQUERY:\n  case OP_CRMINQUERY:\n  min = 0;\n  max = 1;\n  cc += 1 + IMM2_SIZE + 1;\n  break;\n  case OP_CRRANGE:\n  case OP_CRMINRANGE:\n  min = GET2(cc, 1 + IMM2_SIZE + 1);\n  max = GET2(cc, 1 + IMM2_SIZE + 1 + IMM2_SIZE);\n  cc += 1 + IMM2_SIZE + 1 + 2 * IMM2_SIZE;\n  break;\n  default:\n  SLJIT_UNREACHABLE();\n  break;\n  }\n\nif (!minimize)\n  {\n  if (min == 0)\n    {\n    allocate_stack(common, 2);\n    if (ref)\n      OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(SLJIT_SP), OVECTOR(offset));\n    OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(0), STR_PTR, 0);\n    OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(1), SLJIT_IMM, 0);\n    /* Temporary release of STR_PTR. */\n    OP2(SLJIT_ADD, STACK_TOP, 0, STACK_TOP, 0, SLJIT_IMM, sizeof(sljit_sw));\n    /* Handles both invalid and empty cases. Since the minimum repeat,\n    is zero the invalid case is basically the same as an empty case. */\n    if (ref)\n      zerolength = CMP(SLJIT_EQUAL, TMP1, 0, SLJIT_MEM1(SLJIT_SP), OVECTOR(offset + 1));\n    else\n      {\n      compile_dnref_search(common, ccbegin, NULL);\n      OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(TMP2), 0);\n      OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), POSSESSIVE1, TMP2, 0);\n      zerolength = CMP(SLJIT_EQUAL, TMP1, 0, SLJIT_MEM1(TMP2), sizeof(sljit_sw));\n      }\n    /* Restore if not zero length. */\n    OP2(SLJIT_SUB, STACK_TOP, 0, STACK_TOP, 0, SLJIT_IMM, sizeof(sljit_sw));\n    }\n  else\n    {\n    allocate_stack(common, 1);\n    if (ref)\n      OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(SLJIT_SP), OVECTOR(offset));\n    OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(0), SLJIT_IMM, 0);\n    if (ref)\n      {\n      add_jump(compiler, &backtrack->topbacktracks, CMP(SLJIT_EQUAL, TMP1, 0, SLJIT_MEM1(SLJIT_SP), OVECTOR(1)));\n      zerolength = CMP(SLJIT_EQUAL, TMP1, 0, SLJIT_MEM1(SLJIT_SP), OVECTOR(offset + 1));\n      }\n    else\n      {\n      compile_dnref_search(common, ccbegin, &backtrack->topbacktracks);\n      OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(TMP2), 0);\n      OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), POSSESSIVE1, TMP2, 0);\n      zerolength = CMP(SLJIT_EQUAL, TMP1, 0, SLJIT_MEM1(TMP2), sizeof(sljit_sw));\n      }\n    }\n\n  if (min > 1 || max > 1)\n    OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), POSSESSIVE0, SLJIT_IMM, 0);\n\n  label = LABEL();\n  if (!ref)\n    OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(SLJIT_SP), POSSESSIVE1);\n  compile_ref_matchingpath(common, ccbegin, &backtrack->topbacktracks, FALSE, FALSE);\n\n  if (min > 1 || max > 1)\n    {\n    OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(SLJIT_SP), POSSESSIVE0);\n    OP2(SLJIT_ADD, TMP1, 0, TMP1, 0, SLJIT_IMM, 1);\n    OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), POSSESSIVE0, TMP1, 0);\n    if (min > 1)\n      CMPTO(SLJIT_LESS, TMP1, 0, SLJIT_IMM, min, label);\n    if (max > 1)\n      {\n      jump = CMP(SLJIT_GREATER_EQUAL, TMP1, 0, SLJIT_IMM, max);\n      allocate_stack(common, 1);\n      OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(0), STR_PTR, 0);\n      JUMPTO(SLJIT_JUMP, label);\n      JUMPHERE(jump);\n      }\n    }\n\n  if (max == 0)\n    {\n    /* Includes min > 1 case as well. */\n    allocate_stack(common, 1);\n    OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(0), STR_PTR, 0);\n    JUMPTO(SLJIT_JUMP, label);\n    }\n\n  JUMPHERE(zerolength);\n  BACKTRACK_AS(ref_iterator_backtrack)->matchingpath = LABEL();\n\n  count_match(common);\n  return cc;\n  }\n\nallocate_stack(common, ref ? 2 : 3);\nif (ref)\n  OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(SLJIT_SP), OVECTOR(offset));\nOP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(0), SLJIT_IMM, 0);\nif (type != OP_CRMINSTAR)\n  OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(1), SLJIT_IMM, 0);\n\nif (min == 0)\n  {\n  /* Handles both invalid and empty cases. Since the minimum repeat,\n  is zero the invalid case is basically the same as an empty case. */\n  if (ref)\n    zerolength = CMP(SLJIT_EQUAL, TMP1, 0, SLJIT_MEM1(SLJIT_SP), OVECTOR(offset + 1));\n  else\n    {\n    compile_dnref_search(common, ccbegin, NULL);\n    OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(TMP2), 0);\n    OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(2), TMP2, 0);\n    zerolength = CMP(SLJIT_EQUAL, TMP1, 0, SLJIT_MEM1(TMP2), sizeof(sljit_sw));\n    }\n  /* Length is non-zero, we can match real repeats. */\n  OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(0), STR_PTR, 0);\n  jump = JUMP(SLJIT_JUMP);\n  }\nelse\n  {\n  if (ref)\n    {\n    add_jump(compiler, &backtrack->topbacktracks, CMP(SLJIT_EQUAL, TMP1, 0, SLJIT_MEM1(SLJIT_SP), OVECTOR(1)));\n    zerolength = CMP(SLJIT_EQUAL, TMP1, 0, SLJIT_MEM1(SLJIT_SP), OVECTOR(offset + 1));\n    }\n  else\n    {\n    compile_dnref_search(common, ccbegin, &backtrack->topbacktracks);\n    OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(TMP2), 0);\n    OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(2), TMP2, 0);\n    zerolength = CMP(SLJIT_EQUAL, TMP1, 0, SLJIT_MEM1(TMP2), sizeof(sljit_sw));\n    }\n  }\n\nBACKTRACK_AS(ref_iterator_backtrack)->matchingpath = LABEL();\nif (max > 0)\n  add_jump(compiler, &backtrack->topbacktracks, CMP(SLJIT_GREATER_EQUAL, SLJIT_MEM1(STACK_TOP), STACK(1), SLJIT_IMM, max));\n\nif (!ref)\n  OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(STACK_TOP), STACK(2));\ncompile_ref_matchingpath(common, ccbegin, &backtrack->topbacktracks, TRUE, TRUE);\nOP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(0), STR_PTR, 0);\n\nif (min > 1)\n  {\n  OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(STACK_TOP), STACK(1));\n  OP2(SLJIT_ADD, TMP1, 0, TMP1, 0, SLJIT_IMM, 1);\n  OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(1), TMP1, 0);\n  CMPTO(SLJIT_LESS, TMP1, 0, SLJIT_IMM, min, BACKTRACK_AS(ref_iterator_backtrack)->matchingpath);\n  }\nelse if (max > 0)\n  OP2(SLJIT_ADD, SLJIT_MEM1(STACK_TOP), STACK(1), SLJIT_MEM1(STACK_TOP), STACK(1), SLJIT_IMM, 1);\n\nif (jump != NULL)\n  JUMPHERE(jump);\nJUMPHERE(zerolength);\n\ncount_match(common);\nreturn cc;\n}\n\nstatic SLJIT_INLINE PCRE2_SPTR compile_recurse_matchingpath(compiler_common *common, PCRE2_SPTR cc, backtrack_common *parent)\n{\nDEFINE_COMPILER;\nbacktrack_common *backtrack;\nrecurse_entry *entry = common->entries;\nrecurse_entry *prev = NULL;\nsljit_sw start = GET(cc, 1);\nPCRE2_SPTR start_cc;\nBOOL needs_control_head;\n\nPUSH_BACKTRACK(sizeof(recurse_backtrack), cc, NULL);\n\n/* Inlining simple patterns. */\nif (get_framesize(common, common->start + start, NULL, TRUE, &needs_control_head) == no_stack)\n  {\n  start_cc = common->start + start;\n  compile_matchingpath(common, next_opcode(common, start_cc), bracketend(start_cc) - (1 + LINK_SIZE), backtrack);\n  BACKTRACK_AS(recurse_backtrack)->inlined_pattern = TRUE;\n  return cc + 1 + LINK_SIZE;\n  }\n\nwhile (entry != NULL)\n  {\n  if (entry->start == start)\n    break;\n  prev = entry;\n  entry = entry->next;\n  }\n\nif (entry == NULL)\n  {\n  entry = sljit_alloc_memory(compiler, sizeof(recurse_entry));\n  if (SLJIT_UNLIKELY(sljit_get_compiler_error(compiler)))\n    return NULL;\n  entry->next = NULL;\n  entry->entry_label = NULL;\n  entry->backtrack_label = NULL;\n  entry->entry_calls = NULL;\n  entry->backtrack_calls = NULL;\n  entry->start = start;\n\n  if (prev != NULL)\n    prev->next = entry;\n  else\n    common->entries = entry;\n  }\n\nBACKTRACK_AS(recurse_backtrack)->entry = entry;\n\nif (entry->entry_label == NULL)\n  add_jump(compiler, &entry->entry_calls, JUMP(SLJIT_FAST_CALL));\nelse\n  JUMPTO(SLJIT_FAST_CALL, entry->entry_label);\n/* Leave if the match is failed. */\nadd_jump(compiler, &backtrack->topbacktracks, CMP(SLJIT_EQUAL, TMP1, 0, SLJIT_IMM, 0));\nBACKTRACK_AS(recurse_backtrack)->matchingpath = LABEL();\nreturn cc + 1 + LINK_SIZE;\n}\n\nstatic sljit_s32 SLJIT_FUNC do_callout(struct jit_arguments *arguments, pcre2_callout_block *callout_block, PCRE2_SPTR *jit_ovector)\n{\nPCRE2_SPTR begin;\nPCRE2_SIZE *ovector;\nsljit_u32 oveccount, capture_top;\n\nif (arguments->callout == NULL)\n  return 0;\n\nSLJIT_COMPILE_ASSERT(sizeof (PCRE2_SIZE) <= sizeof (sljit_sw), pcre2_size_must_be_lower_than_sljit_sw_size);\n\nbegin = arguments->begin;\novector = (PCRE2_SIZE*)(callout_block + 1);\noveccount = callout_block->capture_top;\n\nSLJIT_ASSERT(oveccount >= 1);\n\ncallout_block->version = 2;\ncallout_block->callout_flags = 0;\n\n/* Offsets in subject. */\ncallout_block->subject_length = arguments->end - arguments->begin;\ncallout_block->start_match = jit_ovector\u00dd0\u00a8 - begin;\ncallout_block->current_position = (PCRE2_SPTR)callout_block->offset_vector - begin;\ncallout_block->subject = begin;\n\n/* Convert and copy the JIT offset vector to the ovector array. */\ncallout_block->capture_top = 1;\ncallout_block->offset_vector = ovector;\n\novector\u00dd0\u00a8 = PCRE2_UNSET;\novector\u00dd1\u00a8 = PCRE2_UNSET;\novector += 2;\njit_ovector += 2;\ncapture_top = 1;\n\n/* Convert pointers to sizes. */\nwhile (--oveccount != 0)\n  {\n  capture_top++;\n\n  ovector\u00dd0\u00a8 = (PCRE2_SIZE)(jit_ovector\u00dd0\u00a8 - begin);\n  ovector\u00dd1\u00a8 = (PCRE2_SIZE)(jit_ovector\u00dd1\u00a8 - begin);\n\n  if (ovector\u00dd0\u00a8 != PCRE2_UNSET)\n    callout_block->capture_top = capture_top;\n\n  ovector += 2;\n  jit_ovector += 2;\n  }\n\nreturn (arguments->callout)(callout_block, arguments->callout_data);\n}\n\n#define CALLOUT_ARG_OFFSET(arg) \\\n    SLJIT_OFFSETOF(pcre2_callout_block, arg)\n\nstatic SLJIT_INLINE PCRE2_SPTR compile_callout_matchingpath(compiler_common *common, PCRE2_SPTR cc, backtrack_common *parent)\n{\nDEFINE_COMPILER;\nbacktrack_common *backtrack;\nsljit_s32 mov_opcode;\nunsigned int callout_length = (*cc == OP_CALLOUT)\n    ? PRIV(OP_lengths)\u00ddOP_CALLOUT\u00a8 : GET(cc, 1 + 2 * LINK_SIZE);\nsljit_sw value1;\nsljit_sw value2;\nsljit_sw value3;\nsljit_uw callout_arg_size = (common->re->top_bracket + 1) * 2 * sizeof(sljit_sw);\n\nPUSH_BACKTRACK(sizeof(backtrack_common), cc, NULL);\n\ncallout_arg_size = (sizeof(pcre2_callout_block) + callout_arg_size + sizeof(sljit_sw) - 1) / sizeof(sljit_sw);\n\nallocate_stack(common, callout_arg_size);\n\nSLJIT_ASSERT(common->capture_last_ptr != 0);\nOP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(SLJIT_SP), common->capture_last_ptr);\nOP1(SLJIT_MOV, TMP1, 0, ARGUMENTS, 0);\nvalue1 = (*cc == OP_CALLOUT) ? cc\u00dd1 + 2 * LINK_SIZE\u00a8 : 0;\nOP1(SLJIT_MOV_U32, SLJIT_MEM1(STACK_TOP), CALLOUT_ARG_OFFSET(callout_number), SLJIT_IMM, value1);\nOP1(SLJIT_MOV_U32, SLJIT_MEM1(STACK_TOP), CALLOUT_ARG_OFFSET(capture_last), TMP2, 0);\nOP1(SLJIT_MOV_U32, SLJIT_MEM1(STACK_TOP), CALLOUT_ARG_OFFSET(capture_top), SLJIT_IMM, common->re->top_bracket + 1);\n\n/* These pointer sized fields temporarly stores internal variables. */\nOP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), CALLOUT_ARG_OFFSET(offset_vector), STR_PTR, 0);\n\nif (common->mark_ptr != 0)\n  OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(TMP1), SLJIT_OFFSETOF(jit_arguments, mark_ptr));\nmov_opcode = (sizeof(PCRE2_SIZE) == 4) ? SLJIT_MOV_U32 : SLJIT_MOV;\nOP1(mov_opcode, SLJIT_MEM1(STACK_TOP), CALLOUT_ARG_OFFSET(pattern_position), SLJIT_IMM, GET(cc, 1));\nOP1(mov_opcode, SLJIT_MEM1(STACK_TOP), CALLOUT_ARG_OFFSET(next_item_length), SLJIT_IMM, GET(cc, 1 + LINK_SIZE));\n\nif (*cc == OP_CALLOUT)\n  {\n  value1 = 0;\n  value2 = 0;\n  value3 = 0;\n  }\nelse\n  {\n  value1 = (sljit_sw) (cc + (1 + 4*LINK_SIZE) + 1);\n  value2 = (callout_length - (1 + 4*LINK_SIZE + 2));\n  value3 = (sljit_sw) (GET(cc, 1 + 3*LINK_SIZE));\n  }\n\nOP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), CALLOUT_ARG_OFFSET(callout_string), SLJIT_IMM, value1);\nOP1(mov_opcode, SLJIT_MEM1(STACK_TOP), CALLOUT_ARG_OFFSET(callout_string_length), SLJIT_IMM, value2);\nOP1(mov_opcode, SLJIT_MEM1(STACK_TOP), CALLOUT_ARG_OFFSET(callout_string_offset), SLJIT_IMM, value3);\nOP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), CALLOUT_ARG_OFFSET(mark), (common->mark_ptr != 0) ? TMP2 : SLJIT_IMM, 0);\n\nSLJIT_ASSERT(TMP1 == SLJIT_R0 && STR_PTR == SLJIT_R1);\n\n/* Needed to save important temporary registers. */\nOP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), LOCALS0, STR_PTR, 0);\n/* SLJIT_R0 = arguments */\nOP1(SLJIT_MOV, SLJIT_R1, 0, STACK_TOP, 0);\nGET_LOCAL_BASE(SLJIT_R2, 0, OVECTOR_START);\nsljit_emit_icall(compiler, SLJIT_CALL, SLJIT_RET(S32) | SLJIT_ARG1(SW) | SLJIT_ARG2(SW) | SLJIT_ARG3(SW), SLJIT_IMM, SLJIT_FUNC_OFFSET(do_callout));\nOP1(SLJIT_MOV, STR_PTR, 0, SLJIT_MEM1(SLJIT_SP), LOCALS0);\nfree_stack(common, callout_arg_size);\n\n/* Check return value. */\nOP2(SLJIT_SUB32 | SLJIT_SET_Z | SLJIT_SET_SIG_GREATER, SLJIT_UNUSED, 0, SLJIT_RETURN_REG, 0, SLJIT_IMM, 0);\nadd_jump(compiler, &backtrack->topbacktracks, JUMP(SLJIT_SIG_GREATER32));\nif (common->abort_label == NULL)\n  add_jump(compiler, &common->abort, JUMP(SLJIT_NOT_EQUAL32) /* SIG_LESS */);\nelse\n  JUMPTO(SLJIT_NOT_EQUAL32 /* SIG_LESS */, common->abort_label);\nreturn cc + callout_length;\n}\n\n#undef CALLOUT_ARG_SIZE\n#undef CALLOUT_ARG_OFFSET\n\nstatic SLJIT_INLINE BOOL assert_needs_str_ptr_saving(PCRE2_SPTR cc)\n{\nwhile (TRUE)\n  {\n  switch (*cc)\n    {\n    case OP_CALLOUT_STR:\n    cc += GET(cc, 1 + 2*LINK_SIZE);\n    break;\n\n    case OP_NOT_WORD_BOUNDARY:\n    case OP_WORD_BOUNDARY:\n    case OP_CIRC:\n    case OP_CIRCM:\n    case OP_DOLL:\n    case OP_DOLLM:\n    case OP_CALLOUT:\n    case OP_ALT:\n    cc += PRIV(OP_lengths)\u00dd*cc\u00a8;\n    break;\n\n    case OP_KET:\n    return FALSE;\n\n    default:\n    return TRUE;\n    }\n  }\n}\n\nstatic PCRE2_SPTR compile_assert_matchingpath(compiler_common *common, PCRE2_SPTR cc, assert_backtrack *backtrack, BOOL conditional)\n{\nDEFINE_COMPILER;\nint framesize;\nint extrasize;\nBOOL local_quit_available = FALSE;\nBOOL needs_control_head;\nint private_data_ptr;\nbacktrack_common altbacktrack;\nPCRE2_SPTR ccbegin;\nPCRE2_UCHAR opcode;\nPCRE2_UCHAR bra = OP_BRA;\njump_list *tmp = NULL;\njump_list **target = (conditional) ? &backtrack->condfailed : &backtrack->common.topbacktracks;\njump_list **found;\n/* Saving previous accept variables. */\nBOOL save_local_quit_available = common->local_quit_available;\nBOOL save_in_positive_assertion = common->in_positive_assertion;\nthen_trap_backtrack *save_then_trap = common->then_trap;\nstruct sljit_label *save_quit_label = common->quit_label;\nstruct sljit_label *save_accept_label = common->accept_label;\njump_list *save_quit = common->quit;\njump_list *save_positive_assertion_quit = common->positive_assertion_quit;\njump_list *save_accept = common->accept;\nstruct sljit_jump *jump;\nstruct sljit_jump *brajump = NULL;\n\n/* Assert captures then. */\ncommon->then_trap = NULL;\n\nif (*cc == OP_BRAZERO || *cc == OP_BRAMINZERO)\n  {\n  SLJIT_ASSERT(!conditional);\n  bra = *cc;\n  cc++;\n  }\nprivate_data_ptr = PRIVATE_DATA(cc);\nSLJIT_ASSERT(private_data_ptr != 0);\nframesize = get_framesize(common, cc, NULL, FALSE, &needs_control_head);\nbacktrack->framesize = framesize;\nbacktrack->private_data_ptr = private_data_ptr;\nopcode = *cc;\nSLJIT_ASSERT(opcode >= OP_ASSERT && opcode <= OP_ASSERTBACK_NOT);\nfound = (opcode == OP_ASSERT || opcode == OP_ASSERTBACK) ? &tmp : target;\nccbegin = cc;\ncc += GET(cc, 1);\n\nif (bra == OP_BRAMINZERO)\n  {\n  /* This is a braminzero backtrack path. */\n  OP1(SLJIT_MOV, STR_PTR, 0, SLJIT_MEM1(STACK_TOP), STACK(0));\n  free_stack(common, 1);\n  brajump = CMP(SLJIT_EQUAL, STR_PTR, 0, SLJIT_IMM, 0);\n  }\n\nif (framesize < 0)\n  {\n  extrasize = 1;\n  if (bra == OP_BRA && !assert_needs_str_ptr_saving(ccbegin + 1 + LINK_SIZE))\n    extrasize = 0;\n\n  if (needs_control_head)\n    extrasize++;\n\n  if (framesize == no_frame)\n    OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), private_data_ptr, STACK_TOP, 0);\n\n  if (extrasize > 0)\n    allocate_stack(common, extrasize);\n\n  if (needs_control_head)\n    OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(SLJIT_SP), common->control_head_ptr);\n\n  if (extrasize > 0)\n    OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(0), STR_PTR, 0);\n\n  if (needs_control_head)\n    {\n    SLJIT_ASSERT(extrasize == 2);\n    OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), common->control_head_ptr, SLJIT_IMM, 0);\n    OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(1), TMP1, 0);\n    }\n  }\nelse\n  {\n  extrasize = needs_control_head ? 3 : 2;\n  allocate_stack(common, framesize + extrasize);\n\n  OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(SLJIT_SP), private_data_ptr);\n  OP2(SLJIT_ADD, TMP2, 0, STACK_TOP, 0, SLJIT_IMM, (framesize + extrasize) * sizeof(sljit_sw));\n  OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), private_data_ptr, TMP2, 0);\n  if (needs_control_head)\n    OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(SLJIT_SP), common->control_head_ptr);\n  OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(0), STR_PTR, 0);\n\n  if (needs_control_head)\n    {\n    OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(2), TMP1, 0);\n    OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(1), TMP2, 0);\n    OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), common->control_head_ptr, SLJIT_IMM, 0);\n    }\n  else\n    OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(1), TMP1, 0);\n\n  init_frame(common, ccbegin, NULL, framesize + extrasize - 1, extrasize);\n  }\n\nmemset(&altbacktrack, 0, sizeof(backtrack_common));\nif (conditional || (opcode == OP_ASSERT_NOT || opcode == OP_ASSERTBACK_NOT))\n  {\n  /* Control verbs cannot escape from these asserts. */\n  local_quit_available = TRUE;\n  common->local_quit_available = TRUE;\n  common->quit_label = NULL;\n  common->quit = NULL;\n  }\n\ncommon->in_positive_assertion = (opcode == OP_ASSERT || opcode == OP_ASSERTBACK);\ncommon->positive_assertion_quit = NULL;\n\nwhile (1)\n  {\n  common->accept_label = NULL;\n  common->accept = NULL;\n  altbacktrack.top = NULL;\n  altbacktrack.topbacktracks = NULL;\n\n  if (*ccbegin == OP_ALT && extrasize > 0)\n    OP1(SLJIT_MOV, STR_PTR, 0, SLJIT_MEM1(STACK_TOP), STACK(0));\n\n  altbacktrack.cc = ccbegin;\n  compile_matchingpath(common, ccbegin + 1 + LINK_SIZE, cc, &altbacktrack);\n  if (SLJIT_UNLIKELY(sljit_get_compiler_error(compiler)))\n    {\n    if (local_quit_available)\n      {\n      common->local_quit_available = save_local_quit_available;\n      common->quit_label = save_quit_label;\n      common->quit = save_quit;\n      }\n    common->in_positive_assertion = save_in_positive_assertion;\n    common->then_trap = save_then_trap;\n    common->accept_label = save_accept_label;\n    common->positive_assertion_quit = save_positive_assertion_quit;\n    common->accept = save_accept;\n    return NULL;\n    }\n  common->accept_label = LABEL();\n  if (common->accept != NULL)\n    set_jumps(common->accept, common->accept_label);\n\n  /* Reset stack. */\n  if (framesize < 0)\n    {\n    if (framesize == no_frame)\n      OP1(SLJIT_MOV, STACK_TOP, 0, SLJIT_MEM1(SLJIT_SP), private_data_ptr);\n    else if (extrasize > 0)\n      free_stack(common, extrasize);\n\n    if (needs_control_head)\n      OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), common->control_head_ptr, SLJIT_MEM1(STACK_TOP), STACK(-1));\n    }\n  else\n    {\n    if ((opcode != OP_ASSERT_NOT && opcode != OP_ASSERTBACK_NOT) || conditional)\n      {\n      /* We don't need to keep the STR_PTR, only the previous private_data_ptr. */\n      OP2(SLJIT_SUB, STACK_TOP, 0, SLJIT_MEM1(SLJIT_SP), private_data_ptr, SLJIT_IMM, (framesize + 1) * sizeof(sljit_sw));\n      if (needs_control_head)\n        OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), common->control_head_ptr, SLJIT_MEM1(STACK_TOP), STACK(-1));\n      }\n    else\n      {\n      OP1(SLJIT_MOV, STACK_TOP, 0, SLJIT_MEM1(SLJIT_SP), private_data_ptr);\n      if (needs_control_head)\n        OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), common->control_head_ptr, SLJIT_MEM1(STACK_TOP), STACK(-framesize - 2));\n      add_jump(compiler, &common->revertframes, JUMP(SLJIT_FAST_CALL));\n      OP2(SLJIT_ADD, STACK_TOP, 0, STACK_TOP, 0, SLJIT_IMM, (framesize - 1) * sizeof(sljit_sw));\n      }\n    }\n\n  if (opcode == OP_ASSERT_NOT || opcode == OP_ASSERTBACK_NOT)\n    {\n    /* We know that STR_PTR was stored on the top of the stack. */\n    if (conditional)\n      {\n      if (extrasize > 0)\n        OP1(SLJIT_MOV, STR_PTR, 0, SLJIT_MEM1(STACK_TOP), needs_control_head ? STACK(-2) : STACK(-1));\n      }\n    else if (bra == OP_BRAZERO)\n      {\n      if (framesize < 0)\n        OP1(SLJIT_MOV, STR_PTR, 0, SLJIT_MEM1(STACK_TOP), STACK(-extrasize));\n      else\n        {\n        OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(STACK_TOP), STACK(-framesize - 1));\n        OP1(SLJIT_MOV, STR_PTR, 0, SLJIT_MEM1(STACK_TOP), STACK(-framesize - extrasize));\n        OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), private_data_ptr, TMP1, 0);\n        }\n      OP2(SLJIT_SUB, STACK_TOP, 0, STACK_TOP, 0, SLJIT_IMM, sizeof(sljit_sw));\n      OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(0), SLJIT_IMM, 0);\n      }\n    else if (framesize >= 0)\n      {\n      /* For OP_BRA and OP_BRAMINZERO. */\n      OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), private_data_ptr, SLJIT_MEM1(STACK_TOP), STACK(-framesize - 1));\n      }\n    }\n  add_jump(compiler, found, JUMP(SLJIT_JUMP));\n\n  compile_backtrackingpath(common, altbacktrack.top);\n  if (SLJIT_UNLIKELY(sljit_get_compiler_error(compiler)))\n    {\n    if (local_quit_available)\n      {\n      common->local_quit_available = save_local_quit_available;\n      common->quit_label = save_quit_label;\n      common->quit = save_quit;\n      }\n    common->in_positive_assertion = save_in_positive_assertion;\n    common->then_trap = save_then_trap;\n    common->accept_label = save_accept_label;\n    common->positive_assertion_quit = save_positive_assertion_quit;\n    common->accept = save_accept;\n    return NULL;\n    }\n  set_jumps(altbacktrack.topbacktracks, LABEL());\n\n  if (*cc != OP_ALT)\n    break;\n\n  ccbegin = cc;\n  cc += GET(cc, 1);\n  }\n\nif (local_quit_available)\n  {\n  SLJIT_ASSERT(common->positive_assertion_quit == NULL);\n  /* Makes the check less complicated below. */\n  common->positive_assertion_quit = common->quit;\n  }\n\n/* None of them matched. */\nif (common->positive_assertion_quit != NULL)\n  {\n  jump = JUMP(SLJIT_JUMP);\n  set_jumps(common->positive_assertion_quit, LABEL());\n  SLJIT_ASSERT(framesize != no_stack);\n  if (framesize < 0)\n    OP2(SLJIT_SUB, STACK_TOP, 0, SLJIT_MEM1(SLJIT_SP), private_data_ptr, SLJIT_IMM, extrasize * sizeof(sljit_sw));\n  else\n    {\n    OP1(SLJIT_MOV, STACK_TOP, 0, SLJIT_MEM1(SLJIT_SP), private_data_ptr);\n    add_jump(compiler, &common->revertframes, JUMP(SLJIT_FAST_CALL));\n    OP2(SLJIT_SUB, STACK_TOP, 0, STACK_TOP, 0, SLJIT_IMM, (extrasize + 1) * sizeof(sljit_sw));\n    }\n  JUMPHERE(jump);\n  }\n\nif (needs_control_head)\n  OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), common->control_head_ptr, SLJIT_MEM1(STACK_TOP), STACK(1));\n\nif (opcode == OP_ASSERT || opcode == OP_ASSERTBACK)\n  {\n  /* Assert is failed. */\n  if ((conditional && extrasize > 0) || bra == OP_BRAZERO)\n    OP1(SLJIT_MOV, STR_PTR, 0, SLJIT_MEM1(STACK_TOP), STACK(0));\n\n  if (framesize < 0)\n    {\n    /* The topmost item should be 0. */\n    if (bra == OP_BRAZERO)\n      {\n      if (extrasize == 2)\n        free_stack(common, 1);\n      OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(0), SLJIT_IMM, 0);\n      }\n    else if (extrasize > 0)\n      free_stack(common, extrasize);\n    }\n  else\n    {\n    OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(STACK_TOP), STACK(extrasize - 1));\n    /* The topmost item should be 0. */\n    if (bra == OP_BRAZERO)\n      {\n      free_stack(common, framesize + extrasize - 1);\n      OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(0), SLJIT_IMM, 0);\n      }\n    else\n      free_stack(common, framesize + extrasize);\n    OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), private_data_ptr, TMP1, 0);\n    }\n  jump = JUMP(SLJIT_JUMP);\n  if (bra != OP_BRAZERO)\n    add_jump(compiler, target, jump);\n\n  /* Assert is successful. */\n  set_jumps(tmp, LABEL());\n  if (framesize < 0)\n    {\n    /* We know that STR_PTR was stored on the top of the stack. */\n    if (extrasize > 0)\n      OP1(SLJIT_MOV, STR_PTR, 0, SLJIT_MEM1(STACK_TOP), STACK(-extrasize));\n\n    /* Keep the STR_PTR on the top of the stack. */\n    if (bra == OP_BRAZERO)\n      {\n      OP2(SLJIT_SUB, STACK_TOP, 0, STACK_TOP, 0, SLJIT_IMM, sizeof(sljit_sw));\n      if (extrasize == 2)\n        OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(0), STR_PTR, 0);\n      }\n    else if (bra == OP_BRAMINZERO)\n      {\n      OP2(SLJIT_SUB, STACK_TOP, 0, STACK_TOP, 0, SLJIT_IMM, sizeof(sljit_sw));\n      OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(0), SLJIT_IMM, 0);\n      }\n    }\n  else\n    {\n    if (bra == OP_BRA)\n      {\n      /* We don't need to keep the STR_PTR, only the previous private_data_ptr. */\n      OP2(SLJIT_SUB, STACK_TOP, 0, SLJIT_MEM1(SLJIT_SP), private_data_ptr, SLJIT_IMM, (framesize + 1) * sizeof(sljit_sw));\n      OP1(SLJIT_MOV, STR_PTR, 0, SLJIT_MEM1(STACK_TOP), STACK(-extrasize + 1));\n      }\n    else\n      {\n      /* We don't need to keep the STR_PTR, only the previous private_data_ptr. */\n      OP2(SLJIT_SUB, STACK_TOP, 0, SLJIT_MEM1(SLJIT_SP), private_data_ptr, SLJIT_IMM, (framesize + 2) * sizeof(sljit_sw));\n      if (extrasize == 2)\n        {\n        OP1(SLJIT_MOV, STR_PTR, 0, SLJIT_MEM1(STACK_TOP), STACK(0));\n        if (bra == OP_BRAMINZERO)\n          OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(0), SLJIT_IMM, 0);\n        }\n      else\n        {\n        SLJIT_ASSERT(extrasize == 3);\n        OP1(SLJIT_MOV, STR_PTR, 0, SLJIT_MEM1(STACK_TOP), STACK(-1));\n        OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(0), bra == OP_BRAZERO ? STR_PTR : SLJIT_IMM, 0);\n        }\n      }\n    }\n\n  if (bra == OP_BRAZERO)\n    {\n    backtrack->matchingpath = LABEL();\n    SET_LABEL(jump, backtrack->matchingpath);\n    }\n  else if (bra == OP_BRAMINZERO)\n    {\n    JUMPTO(SLJIT_JUMP, backtrack->matchingpath);\n    JUMPHERE(brajump);\n    if (framesize >= 0)\n      {\n      OP1(SLJIT_MOV, STACK_TOP, 0, SLJIT_MEM1(SLJIT_SP), private_data_ptr);\n      add_jump(compiler, &common->revertframes, JUMP(SLJIT_FAST_CALL));\n      OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(STACK_TOP), STACK(-2));\n      OP2(SLJIT_ADD, STACK_TOP, 0, STACK_TOP, 0, SLJIT_IMM, (framesize - 1) * sizeof(sljit_sw));\n      OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), private_data_ptr, TMP1, 0);\n      }\n    set_jumps(backtrack->common.topbacktracks, LABEL());\n    }\n  }\nelse\n  {\n  /* AssertNot is successful. */\n  if (framesize < 0)\n    {\n    if (extrasize > 0)\n      OP1(SLJIT_MOV, STR_PTR, 0, SLJIT_MEM1(STACK_TOP), STACK(0));\n\n    if (bra != OP_BRA)\n      {\n      if (extrasize == 2)\n        free_stack(common, 1);\n      OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(0), SLJIT_IMM, 0);\n      }\n    else if (extrasize > 0)\n      free_stack(common, extrasize);\n    }\n  else\n    {\n    OP1(SLJIT_MOV, STR_PTR, 0, SLJIT_MEM1(STACK_TOP), STACK(0));\n    OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(STACK_TOP), STACK(extrasize - 1));\n    /* The topmost item should be 0. */\n    if (bra != OP_BRA)\n      {\n      free_stack(common, framesize + extrasize - 1);\n      OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(0), SLJIT_IMM, 0);\n      }\n    else\n      free_stack(common, framesize + extrasize);\n    OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), private_data_ptr, TMP1, 0);\n    }\n\n  if (bra == OP_BRAZERO)\n    backtrack->matchingpath = LABEL();\n  else if (bra == OP_BRAMINZERO)\n    {\n    JUMPTO(SLJIT_JUMP, backtrack->matchingpath);\n    JUMPHERE(brajump);\n    }\n\n  if (bra != OP_BRA)\n    {\n    SLJIT_ASSERT(found == &backtrack->common.topbacktracks);\n    set_jumps(backtrack->common.topbacktracks, LABEL());\n    backtrack->common.topbacktracks = NULL;\n    }\n  }\n\nif (local_quit_available)\n  {\n  common->local_quit_available = save_local_quit_available;\n  common->quit_label = save_quit_label;\n  common->quit = save_quit;\n  }\ncommon->in_positive_assertion = save_in_positive_assertion;\ncommon->then_trap = save_then_trap;\ncommon->accept_label = save_accept_label;\ncommon->positive_assertion_quit = save_positive_assertion_quit;\ncommon->accept = save_accept;\nreturn cc + 1 + LINK_SIZE;\n}\n\nstatic SLJIT_INLINE void match_once_common(compiler_common *common, PCRE2_UCHAR ket, int framesize, int private_data_ptr, BOOL has_alternatives, BOOL needs_control_head)\n{\nDEFINE_COMPILER;\nint stacksize;\n\nif (framesize < 0)\n  {\n  if (framesize == no_frame)\n    OP1(SLJIT_MOV, STACK_TOP, 0, SLJIT_MEM1(SLJIT_SP), private_data_ptr);\n  else\n    {\n    stacksize = needs_control_head ? 1 : 0;\n    if (ket != OP_KET || has_alternatives)\n      stacksize++;\n\n    if (stacksize > 0)\n      free_stack(common, stacksize);\n    }\n\n  if (needs_control_head)\n    OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(STACK_TOP), (ket != OP_KET || has_alternatives) ? STACK(-2) : STACK(-1));\n\n  /* TMP2 which is set here used by OP_KETRMAX below. */\n  if (ket == OP_KETRMAX)\n    OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(STACK_TOP), STACK(-1));\n  else if (ket == OP_KETRMIN)\n    {\n    /* Move the STR_PTR to the private_data_ptr. */\n    OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), private_data_ptr, SLJIT_MEM1(STACK_TOP), STACK(-1));\n    }\n  }\nelse\n  {\n  stacksize = (ket != OP_KET || has_alternatives) ? 2 : 1;\n  OP2(SLJIT_SUB, STACK_TOP, 0, SLJIT_MEM1(SLJIT_SP), private_data_ptr, SLJIT_IMM, (framesize + stacksize) * sizeof(sljit_sw));\n  if (needs_control_head)\n    OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(STACK_TOP), STACK(-1));\n\n  if (ket == OP_KETRMAX)\n    {\n    /* TMP2 which is set here used by OP_KETRMAX below. */\n    OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(STACK_TOP), STACK(0));\n    }\n  }\nif (needs_control_head)\n  OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), common->control_head_ptr, TMP1, 0);\n}\n\nstatic SLJIT_INLINE int match_capture_common(compiler_common *common, int stacksize, int offset, int private_data_ptr)\n{\nDEFINE_COMPILER;\n\nif (common->capture_last_ptr != 0)\n  {\n  OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(SLJIT_SP), common->capture_last_ptr);\n  OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), common->capture_last_ptr, SLJIT_IMM, offset >> 1);\n  OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(stacksize), TMP1, 0);\n  stacksize++;\n  }\nif (common->optimized_cbracket\u00ddoffset >> 1\u00a8 == 0)\n  {\n  OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(SLJIT_SP), OVECTOR(offset));\n  OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(SLJIT_SP), OVECTOR(offset + 1));\n  OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(stacksize), TMP1, 0);\n  OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(SLJIT_SP), private_data_ptr);\n  OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(stacksize + 1), TMP2, 0);\n  OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), OVECTOR(offset + 1), STR_PTR, 0);\n  OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), OVECTOR(offset), TMP1, 0);\n  stacksize += 2;\n  }\nreturn stacksize;\n}\n\nstatic PCRE2_SPTR SLJIT_FUNC do_script_run(PCRE2_SPTR ptr, PCRE2_SPTR endptr)\n{\n  if (PRIV(script_run)(ptr, endptr, FALSE))\n    return endptr;\n  return NULL;\n}\n\n#ifdef SUPPORT_UNICODE\n\nstatic PCRE2_SPTR SLJIT_FUNC do_script_run_utf(PCRE2_SPTR ptr, PCRE2_SPTR endptr)\n{\n  if (PRIV(script_run)(ptr, endptr, TRUE))\n    return endptr;\n  return NULL;\n}\n\n#endif /* SUPPORT_UNICODE */\n\nstatic SLJIT_INLINE void match_script_run_common(compiler_common *common, int private_data_ptr, backtrack_common *parent)\n{\nDEFINE_COMPILER;\n\nSLJIT_ASSERT(TMP1 == SLJIT_R0 && STR_PTR == SLJIT_R1);\n\nOP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(SLJIT_SP), private_data_ptr);\n#ifdef SUPPORT_UNICODE\nsljit_emit_icall(compiler, SLJIT_CALL, SLJIT_RET(SW) | SLJIT_ARG1(SW) | SLJIT_ARG2(SW), SLJIT_IMM,\n  common->utf ? SLJIT_FUNC_OFFSET(do_script_run_utf) : SLJIT_FUNC_OFFSET(do_script_run));\n#else\nsljit_emit_icall(compiler, SLJIT_CALL, SLJIT_RET(SW) | SLJIT_ARG1(SW) | SLJIT_ARG2(SW), SLJIT_IMM, SLJIT_FUNC_OFFSET(do_script_run));\n#endif\n\nOP1(SLJIT_MOV, STR_PTR, 0, SLJIT_RETURN_REG, 0);\nadd_jump(compiler, parent->top != NULL ? &parent->top->nextbacktracks : &parent->topbacktracks, CMP(SLJIT_EQUAL, SLJIT_RETURN_REG, 0, SLJIT_IMM, 0));\n}\n\n/*\n  Handling bracketed expressions is probably the most complex part.\n\n  Stack layout naming characters:\n    S - Push the current STR_PTR\n    0 - Push a 0 (NULL)\n    A - Push the current STR_PTR. Needed for restoring the STR_PTR\n        before the next alternative. Not pushed if there are no alternatives.\n    M - Any values pushed by the current alternative. Can be empty, or anything.\n    C - Push the previous OVECTOR(i), OVECTOR(i+1) and OVECTOR_PRIV(i) to the stack.\n    L - Push the previous local (pointed by localptr) to the stack\n   () - opional values stored on the stack\n  ()* - optonal, can be stored multiple times\n\n  The following list shows the regular expression templates, their PCRE byte codes\n  and stack layout supported by pcre-sljit.\n\n  (?:)                     OP_BRA     | OP_KET                A M\n  ()                       OP_CBRA    | OP_KET                C M\n  (?:)+                    OP_BRA     | OP_KETRMAX        0   A M S   ( A M S )*\n                           OP_SBRA    | OP_KETRMAX        0   L M S   ( L M S )*\n  (?:)+?                   OP_BRA     | OP_KETRMIN        0   A M S   ( A M S )*\n                           OP_SBRA    | OP_KETRMIN        0   L M S   ( L M S )*\n  ()+                      OP_CBRA    | OP_KETRMAX        0   C M S   ( C M S )*\n                           OP_SCBRA   | OP_KETRMAX        0   C M S   ( C M S )*\n  ()+?                     OP_CBRA    | OP_KETRMIN        0   C M S   ( C M S )*\n                           OP_SCBRA   | OP_KETRMIN        0   C M S   ( C M S )*\n  (?:)?    OP_BRAZERO    | OP_BRA     | OP_KET            S ( A M 0 )\n  (?:)??   OP_BRAMINZERO | OP_BRA     | OP_KET            S ( A M 0 )\n  ()?      OP_BRAZERO    | OP_CBRA    | OP_KET            S ( C M 0 )\n  ()??     OP_BRAMINZERO | OP_CBRA    | OP_KET            S ( C M 0 )\n  (?:)*    OP_BRAZERO    | OP_BRA     | OP_KETRMAX      S 0 ( A M S )*\n           OP_BRAZERO    | OP_SBRA    | OP_KETRMAX      S 0 ( L M S )*\n  (?:)*?   OP_BRAMINZERO | OP_BRA     | OP_KETRMIN      S 0 ( A M S )*\n           OP_BRAMINZERO | OP_SBRA    | OP_KETRMIN      S 0 ( L M S )*\n  ()*      OP_BRAZERO    | OP_CBRA    | OP_KETRMAX      S 0 ( C M S )*\n           OP_BRAZERO    | OP_SCBRA   | OP_KETRMAX      S 0 ( C M S )*\n  ()*?     OP_BRAMINZERO | OP_CBRA    | OP_KETRMIN      S 0 ( C M S )*\n           OP_BRAMINZERO | OP_SCBRA   | OP_KETRMIN      S 0 ( C M S )*\n\n\n  Stack layout naming characters:\n    A - Push the alternative index (starting from 0) on the stack.\n        Not pushed if there is no alternatives.\n    M - Any values pushed by the current alternative. Can be empty, or anything.\n\n  The next list shows the possible content of a bracket:\n  (|)     OP_*BRA    | OP_ALT ...         M A\n  (?()|)  OP_*COND   | OP_ALT             M A\n  (?>|)   OP_ONCE    | OP_ALT ...         \u00ddstack trace\u00a8 M A\n                                          Or nothing, if trace is unnecessary\n*/\n\nstatic PCRE2_SPTR compile_bracket_matchingpath(compiler_common *common, PCRE2_SPTR cc, backtrack_common *parent)\n{\nDEFINE_COMPILER;\nbacktrack_common *backtrack;\nPCRE2_UCHAR opcode;\nint private_data_ptr = 0;\nint offset = 0;\nint i, stacksize;\nint repeat_ptr = 0, repeat_length = 0;\nint repeat_type = 0, repeat_count = 0;\nPCRE2_SPTR ccbegin;\nPCRE2_SPTR matchingpath;\nPCRE2_SPTR slot;\nPCRE2_UCHAR bra = OP_BRA;\nPCRE2_UCHAR ket;\nassert_backtrack *assert;\nBOOL has_alternatives;\nBOOL needs_control_head = FALSE;\nstruct sljit_jump *jump;\nstruct sljit_jump *skip;\nstruct sljit_label *rmax_label = NULL;\nstruct sljit_jump *braminzero = NULL;\n\nPUSH_BACKTRACK(sizeof(bracket_backtrack), cc, NULL);\n\nif (*cc == OP_BRAZERO || *cc == OP_BRAMINZERO)\n  {\n  bra = *cc;\n  cc++;\n  opcode = *cc;\n  }\n\nopcode = *cc;\nccbegin = cc;\nmatchingpath = bracketend(cc) - 1 - LINK_SIZE;\nket = *matchingpath;\nif (ket == OP_KET && PRIVATE_DATA(matchingpath) != 0)\n  {\n  repeat_ptr = PRIVATE_DATA(matchingpath);\n  repeat_length = PRIVATE_DATA(matchingpath + 1);\n  repeat_type = PRIVATE_DATA(matchingpath + 2);\n  repeat_count = PRIVATE_DATA(matchingpath + 3);\n  SLJIT_ASSERT(repeat_length != 0 && repeat_type != 0 && repeat_count != 0);\n  if (repeat_type == OP_UPTO)\n    ket = OP_KETRMAX;\n  if (repeat_type == OP_MINUPTO)\n    ket = OP_KETRMIN;\n  }\n\nmatchingpath = ccbegin + 1 + LINK_SIZE;\nSLJIT_ASSERT(ket == OP_KET || ket == OP_KETRMAX || ket == OP_KETRMIN);\nSLJIT_ASSERT(!((bra == OP_BRAZERO && ket == OP_KETRMIN) || (bra == OP_BRAMINZERO && ket == OP_KETRMAX)));\ncc += GET(cc, 1);\n\nhas_alternatives = *cc == OP_ALT;\nif (SLJIT_UNLIKELY(opcode == OP_COND || opcode == OP_SCOND))\n  {\n  SLJIT_COMPILE_ASSERT(OP_DNRREF == OP_RREF + 1 && OP_FALSE == OP_RREF + 2 && OP_TRUE == OP_RREF + 3,\n    compile_time_checks_must_be_grouped_together);\n  has_alternatives = ((*matchingpath >= OP_RREF && *matchingpath <= OP_TRUE) || *matchingpath == OP_FAIL) ? FALSE : TRUE;\n  }\n\nif (SLJIT_UNLIKELY(opcode == OP_COND) && (*cc == OP_KETRMAX || *cc == OP_KETRMIN))\n  opcode = OP_SCOND;\n\nif (opcode == OP_CBRA || opcode == OP_SCBRA)\n  {\n  /* Capturing brackets has a pre-allocated space. */\n  offset = GET2(ccbegin, 1 + LINK_SIZE);\n  if (common->optimized_cbracket\u00ddoffset\u00a8 == 0)\n    {\n    private_data_ptr = OVECTOR_PRIV(offset);\n    offset <<= 1;\n    }\n  else\n    {\n    offset <<= 1;\n    private_data_ptr = OVECTOR(offset);\n    }\n  BACKTRACK_AS(bracket_backtrack)->private_data_ptr = private_data_ptr;\n  matchingpath += IMM2_SIZE;\n  }\nelse if (opcode == OP_ASSERT_NA || opcode == OP_ASSERTBACK_NA || opcode == OP_ONCE || opcode == OP_SCRIPT_RUN || opcode == OP_SBRA || opcode == OP_SCOND)\n  {\n  /* Other brackets simply allocate the next entry. */\n  private_data_ptr = PRIVATE_DATA(ccbegin);\n  SLJIT_ASSERT(private_data_ptr != 0);\n  BACKTRACK_AS(bracket_backtrack)->private_data_ptr = private_data_ptr;\n  if (opcode == OP_ONCE)\n    BACKTRACK_AS(bracket_backtrack)->u.framesize = get_framesize(common, ccbegin, NULL, FALSE, &needs_control_head);\n  }\n\n/* Instructions before the first alternative. */\nstacksize = 0;\nif (ket == OP_KETRMAX || (ket == OP_KETRMIN && bra != OP_BRAMINZERO))\n  stacksize++;\nif (bra == OP_BRAZERO)\n  stacksize++;\n\nif (stacksize > 0)\n  allocate_stack(common, stacksize);\n\nstacksize = 0;\nif (ket == OP_KETRMAX || (ket == OP_KETRMIN && bra != OP_BRAMINZERO))\n  {\n  OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(stacksize), SLJIT_IMM, 0);\n  stacksize++;\n  }\n\nif (bra == OP_BRAZERO)\n  OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(stacksize), STR_PTR, 0);\n\nif (bra == OP_BRAMINZERO)\n  {\n  /* This is a backtrack path! (Since the try-path of OP_BRAMINZERO matches to the empty string) */\n  OP1(SLJIT_MOV, STR_PTR, 0, SLJIT_MEM1(STACK_TOP), STACK(0));\n  if (ket != OP_KETRMIN)\n    {\n    free_stack(common, 1);\n    braminzero = CMP(SLJIT_EQUAL, STR_PTR, 0, SLJIT_IMM, 0);\n    }\n  else if (opcode == OP_ONCE || opcode >= OP_SBRA)\n    {\n    jump = CMP(SLJIT_NOT_EQUAL, STR_PTR, 0, SLJIT_IMM, 0);\n    OP1(SLJIT_MOV, STR_PTR, 0, SLJIT_MEM1(STACK_TOP), STACK(1));\n    /* Nothing stored during the first run. */\n    skip = JUMP(SLJIT_JUMP);\n    JUMPHERE(jump);\n    /* Checking zero-length iteration. */\n    if (opcode != OP_ONCE || BACKTRACK_AS(bracket_backtrack)->u.framesize < 0)\n      {\n      /* When we come from outside, private_data_ptr contains the previous STR_PTR. */\n      braminzero = CMP(SLJIT_EQUAL, STR_PTR, 0, SLJIT_MEM1(SLJIT_SP), private_data_ptr);\n      }\n    else\n      {\n      /* Except when the whole stack frame must be saved. */\n      OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(SLJIT_SP), private_data_ptr);\n      braminzero = CMP(SLJIT_EQUAL, STR_PTR, 0, SLJIT_MEM1(TMP1), STACK(-BACKTRACK_AS(bracket_backtrack)->u.framesize - 2));\n      }\n    JUMPHERE(skip);\n    }\n  else\n    {\n    jump = CMP(SLJIT_NOT_EQUAL, STR_PTR, 0, SLJIT_IMM, 0);\n    OP1(SLJIT_MOV, STR_PTR, 0, SLJIT_MEM1(STACK_TOP), STACK(1));\n    JUMPHERE(jump);\n    }\n  }\n\nif (repeat_type != 0)\n  {\n  OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), repeat_ptr, SLJIT_IMM, repeat_count);\n  if (repeat_type == OP_EXACT)\n    rmax_label = LABEL();\n  }\n\nif (ket == OP_KETRMIN)\n  BACKTRACK_AS(bracket_backtrack)->recursive_matchingpath = LABEL();\n\nif (ket == OP_KETRMAX)\n  {\n  rmax_label = LABEL();\n  if (has_alternatives && opcode >= OP_BRA && opcode < OP_SBRA && repeat_type == 0)\n    BACKTRACK_AS(bracket_backtrack)->alternative_matchingpath = rmax_label;\n  }\n\n/* Handling capturing brackets and alternatives. */\nif (opcode == OP_ONCE)\n  {\n  stacksize = 0;\n  if (needs_control_head)\n    {\n    OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(SLJIT_SP), common->control_head_ptr);\n    stacksize++;\n    }\n\n  if (BACKTRACK_AS(bracket_backtrack)->u.framesize < 0)\n    {\n    /* Neither capturing brackets nor recursions are found in the block. */\n    if (ket == OP_KETRMIN)\n      {\n      stacksize += 2;\n      if (!needs_control_head)\n        OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(SLJIT_SP), private_data_ptr);\n      }\n    else\n      {\n      if (BACKTRACK_AS(bracket_backtrack)->u.framesize == no_frame)\n        OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), private_data_ptr, STACK_TOP, 0);\n      if (ket == OP_KETRMAX || has_alternatives)\n        stacksize++;\n      }\n\n    if (stacksize > 0)\n      allocate_stack(common, stacksize);\n\n    stacksize = 0;\n    if (needs_control_head)\n      {\n      stacksize++;\n      OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(0), TMP2, 0);\n      }\n\n    if (ket == OP_KETRMIN)\n      {\n      if (needs_control_head)\n        OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(SLJIT_SP), private_data_ptr);\n      OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(stacksize), STR_PTR, 0);\n      if (BACKTRACK_AS(bracket_backtrack)->u.framesize == no_frame)\n        OP2(SLJIT_ADD, SLJIT_MEM1(SLJIT_SP), private_data_ptr, STACK_TOP, 0, SLJIT_IMM, needs_control_head ? (2 * sizeof(sljit_sw)) : sizeof(sljit_sw));\n      OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(stacksize + 1), TMP2, 0);\n      }\n    else if (ket == OP_KETRMAX || has_alternatives)\n      OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(stacksize), STR_PTR, 0);\n    }\n  else\n    {\n    if (ket != OP_KET || has_alternatives)\n      stacksize++;\n\n    stacksize += BACKTRACK_AS(bracket_backtrack)->u.framesize + 1;\n    allocate_stack(common, stacksize);\n\n    if (needs_control_head)\n      OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(0), TMP2, 0);\n\n    OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(SLJIT_SP), private_data_ptr);\n    OP2(SLJIT_ADD, TMP2, 0, STACK_TOP, 0, SLJIT_IMM, stacksize * sizeof(sljit_sw));\n\n    stacksize = needs_control_head ? 1 : 0;\n    if (ket != OP_KET || has_alternatives)\n      {\n      OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(stacksize), STR_PTR, 0);\n      OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), private_data_ptr, TMP2, 0);\n      stacksize++;\n      OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(stacksize), TMP1, 0);\n      }\n    else\n      {\n      OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), private_data_ptr, TMP2, 0);\n      OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(stacksize), TMP1, 0);\n      }\n    init_frame(common, ccbegin, NULL, BACKTRACK_AS(bracket_backtrack)->u.framesize + stacksize, stacksize + 1);\n    }\n  }\nelse if (opcode == OP_CBRA || opcode == OP_SCBRA)\n  {\n  /* Saving the previous values. */\n  if (common->optimized_cbracket\u00ddoffset >> 1\u00a8 != 0)\n    {\n    SLJIT_ASSERT(private_data_ptr == OVECTOR(offset));\n    allocate_stack(common, 2);\n    OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(SLJIT_SP), private_data_ptr);\n    OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(SLJIT_SP), private_data_ptr + sizeof(sljit_sw));\n    OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), private_data_ptr, STR_PTR, 0);\n    OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(0), TMP1, 0);\n    OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(1), TMP2, 0);\n    }\n  else\n    {\n    OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(SLJIT_SP), private_data_ptr);\n    allocate_stack(common, 1);\n    OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), private_data_ptr, STR_PTR, 0);\n    OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(0), TMP2, 0);\n    }\n  }\nelse if (opcode == OP_ASSERT_NA || opcode == OP_ASSERTBACK_NA || opcode == OP_SCRIPT_RUN || opcode == OP_SBRA || opcode == OP_SCOND)\n  {\n  /* Saving the previous value. */\n  OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(SLJIT_SP), private_data_ptr);\n  allocate_stack(common, 1);\n  OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), private_data_ptr, STR_PTR, 0);\n  OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(0), TMP2, 0);\n  }\nelse if (has_alternatives)\n  {\n  /* Pushing the starting string pointer. */\n  allocate_stack(common, 1);\n  OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(0), STR_PTR, 0);\n  }\n\n/* Generating code for the first alternative. */\nif (opcode == OP_COND || opcode == OP_SCOND)\n  {\n  if (*matchingpath == OP_CREF)\n    {\n    SLJIT_ASSERT(has_alternatives);\n    add_jump(compiler, &(BACKTRACK_AS(bracket_backtrack)->u.condfailed),\n      CMP(SLJIT_EQUAL, SLJIT_MEM1(SLJIT_SP), OVECTOR(GET2(matchingpath, 1) << 1), SLJIT_MEM1(SLJIT_SP), OVECTOR(1)));\n    matchingpath += 1 + IMM2_SIZE;\n    }\n  else if (*matchingpath == OP_DNCREF)\n    {\n    SLJIT_ASSERT(has_alternatives);\n\n    i = GET2(matchingpath, 1 + IMM2_SIZE);\n    slot = common->name_table + GET2(matchingpath, 1) * common->name_entry_size;\n    OP1(SLJIT_MOV, TMP3, 0, STR_PTR, 0);\n    OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(SLJIT_SP), OVECTOR(1));\n    OP2(SLJIT_SUB | SLJIT_SET_Z, TMP2, 0, SLJIT_MEM1(SLJIT_SP), OVECTOR(GET2(slot, 0) << 1), TMP1, 0);\n    slot += common->name_entry_size;\n    i--;\n    while (i-- > 0)\n      {\n      OP2(SLJIT_SUB, STR_PTR, 0, SLJIT_MEM1(SLJIT_SP), OVECTOR(GET2(slot, 0) << 1), TMP1, 0);\n      OP2(SLJIT_OR | SLJIT_SET_Z, TMP2, 0, TMP2, 0, STR_PTR, 0);\n      slot += common->name_entry_size;\n      }\n    OP1(SLJIT_MOV, STR_PTR, 0, TMP3, 0);\n    add_jump(compiler, &(BACKTRACK_AS(bracket_backtrack)->u.condfailed), JUMP(SLJIT_ZERO));\n    matchingpath += 1 + 2 * IMM2_SIZE;\n    }\n  else if ((*matchingpath >= OP_RREF && *matchingpath <= OP_TRUE) || *matchingpath == OP_FAIL)\n    {\n    /* Never has other case. */\n    BACKTRACK_AS(bracket_backtrack)->u.condfailed = NULL;\n    SLJIT_ASSERT(!has_alternatives);\n\n    if (*matchingpath == OP_TRUE)\n      {\n      stacksize = 1;\n      matchingpath++;\n      }\n    else if (*matchingpath == OP_FALSE || *matchingpath == OP_FAIL)\n      stacksize = 0;\n    else if (*matchingpath == OP_RREF)\n      {\n      stacksize = GET2(matchingpath, 1);\n      if (common->currententry == NULL)\n        stacksize = 0;\n      else if (stacksize == RREF_ANY)\n        stacksize = 1;\n      else if (common->currententry->start == 0)\n        stacksize = stacksize == 0;\n      else\n        stacksize = stacksize == (int)GET2(common->start, common->currententry->start + 1 + LINK_SIZE);\n\n      if (stacksize != 0)\n        matchingpath += 1 + IMM2_SIZE;\n      }\n    else\n      {\n      if (common->currententry == NULL || common->currententry->start == 0)\n        stacksize = 0;\n      else\n        {\n        stacksize = GET2(matchingpath, 1 + IMM2_SIZE);\n        slot = common->name_table + GET2(matchingpath, 1) * common->name_entry_size;\n        i = (int)GET2(common->start, common->currententry->start + 1 + LINK_SIZE);\n        while (stacksize > 0)\n          {\n          if ((int)GET2(slot, 0) == i)\n            break;\n          slot += common->name_entry_size;\n          stacksize--;\n          }\n        }\n\n      if (stacksize != 0)\n        matchingpath += 1 + 2 * IMM2_SIZE;\n      }\n\n      /* The stacksize == 0 is a common \"else\" case. */\n      if (stacksize == 0)\n        {\n        if (*cc == OP_ALT)\n          {\n          matchingpath = cc + 1 + LINK_SIZE;\n          cc += GET(cc, 1);\n          }\n        else\n          matchingpath = cc;\n        }\n    }\n  else\n    {\n    SLJIT_ASSERT(has_alternatives && *matchingpath >= OP_ASSERT && *matchingpath <= OP_ASSERTBACK_NOT);\n    /* Similar code as PUSH_BACKTRACK macro. */\n    assert = sljit_alloc_memory(compiler, sizeof(assert_backtrack));\n    if (SLJIT_UNLIKELY(sljit_get_compiler_error(compiler)))\n      return NULL;\n    memset(assert, 0, sizeof(assert_backtrack));\n    assert->common.cc = matchingpath;\n    BACKTRACK_AS(bracket_backtrack)->u.assert = assert;\n    matchingpath = compile_assert_matchingpath(common, matchingpath, assert, TRUE);\n    }\n  }\n\ncompile_matchingpath(common, matchingpath, cc, backtrack);\nif (SLJIT_UNLIKELY(sljit_get_compiler_error(compiler)))\n  return NULL;\n\nif (opcode == OP_ASSERT_NA || opcode == OP_ASSERTBACK_NA)\n  OP1(SLJIT_MOV, STR_PTR, 0, SLJIT_MEM1(SLJIT_SP), private_data_ptr);\n\nif (opcode == OP_ONCE)\n  match_once_common(common, ket, BACKTRACK_AS(bracket_backtrack)->u.framesize, private_data_ptr, has_alternatives, needs_control_head);\n\nif (opcode == OP_SCRIPT_RUN)\n  match_script_run_common(common, private_data_ptr, backtrack);\n\nstacksize = 0;\nif (repeat_type == OP_MINUPTO)\n  {\n  /* We need to preserve the counter. TMP2 will be used below. */\n  OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(SLJIT_SP), repeat_ptr);\n  stacksize++;\n  }\nif (ket != OP_KET || bra != OP_BRA)\n  stacksize++;\nif (offset != 0)\n  {\n  if (common->capture_last_ptr != 0)\n    stacksize++;\n  if (common->optimized_cbracket\u00ddoffset >> 1\u00a8 == 0)\n    stacksize += 2;\n  }\nif (has_alternatives && opcode != OP_ONCE)\n  stacksize++;\n\nif (stacksize > 0)\n  allocate_stack(common, stacksize);\n\nstacksize = 0;\nif (repeat_type == OP_MINUPTO)\n  {\n  /* TMP2 was set above. */\n  OP2(SLJIT_SUB, SLJIT_MEM1(STACK_TOP), STACK(stacksize), TMP2, 0, SLJIT_IMM, 1);\n  stacksize++;\n  }\n\nif (ket != OP_KET || bra != OP_BRA)\n  {\n  if (ket != OP_KET)\n    OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(stacksize), STR_PTR, 0);\n  else\n    OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(stacksize), SLJIT_IMM, 0);\n  stacksize++;\n  }\n\nif (offset != 0)\n  stacksize = match_capture_common(common, stacksize, offset, private_data_ptr);\n\n/* Skip and count the other alternatives. */\ni = 1;\nwhile (*cc == OP_ALT)\n  {\n  cc += GET(cc, 1);\n  i++;\n  }\n\nif (has_alternatives)\n  {\n  if (opcode != OP_ONCE)\n    {\n    if (i <= 3)\n      OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(stacksize), SLJIT_IMM, 0);\n    else\n      BACKTRACK_AS(bracket_backtrack)->u.matching_put_label = sljit_emit_put_label(compiler, SLJIT_MEM1(STACK_TOP), STACK(stacksize));\n    }\n  if (ket != OP_KETRMAX)\n    BACKTRACK_AS(bracket_backtrack)->alternative_matchingpath = LABEL();\n  }\n\n/* Must be after the matchingpath label. */\nif (offset != 0 && common->optimized_cbracket\u00ddoffset >> 1\u00a8 != 0)\n  {\n  SLJIT_ASSERT(private_data_ptr == OVECTOR(offset + 0));\n  OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), OVECTOR(offset + 1), STR_PTR, 0);\n  }\n\nif (ket == OP_KETRMAX)\n  {\n  if (repeat_type != 0)\n    {\n    if (has_alternatives)\n      BACKTRACK_AS(bracket_backtrack)->alternative_matchingpath = LABEL();\n    OP2(SLJIT_SUB | SLJIT_SET_Z, SLJIT_MEM1(SLJIT_SP), repeat_ptr, SLJIT_MEM1(SLJIT_SP), repeat_ptr, SLJIT_IMM, 1);\n    JUMPTO(SLJIT_NOT_ZERO, rmax_label);\n    /* Drop STR_PTR for greedy plus quantifier. */\n    if (opcode != OP_ONCE)\n      free_stack(common, 1);\n    }\n  else if (opcode < OP_BRA || opcode >= OP_SBRA)\n    {\n    if (has_alternatives)\n      BACKTRACK_AS(bracket_backtrack)->alternative_matchingpath = LABEL();\n\n    /* Checking zero-length iteration. */\n    if (opcode != OP_ONCE)\n      {\n      /* This case includes opcodes such as OP_SCRIPT_RUN. */\n      CMPTO(SLJIT_NOT_EQUAL, SLJIT_MEM1(SLJIT_SP), private_data_ptr, STR_PTR, 0, rmax_label);\n      /* Drop STR_PTR for greedy plus quantifier. */\n      if (bra != OP_BRAZERO)\n        free_stack(common, 1);\n      }\n    else\n      /* TMP2 must contain the starting STR_PTR. */\n      CMPTO(SLJIT_NOT_EQUAL, TMP2, 0, STR_PTR, 0, rmax_label);\n    }\n  else\n    JUMPTO(SLJIT_JUMP, rmax_label);\n  BACKTRACK_AS(bracket_backtrack)->recursive_matchingpath = LABEL();\n  }\n\nif (repeat_type == OP_EXACT)\n  {\n  count_match(common);\n  OP2(SLJIT_SUB | SLJIT_SET_Z, SLJIT_MEM1(SLJIT_SP), repeat_ptr, SLJIT_MEM1(SLJIT_SP), repeat_ptr, SLJIT_IMM, 1);\n  JUMPTO(SLJIT_NOT_ZERO, rmax_label);\n  }\nelse if (repeat_type == OP_UPTO)\n  {\n  /* We need to preserve the counter. */\n  OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(SLJIT_SP), repeat_ptr);\n  allocate_stack(common, 1);\n  OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(0), TMP2, 0);\n  }\n\nif (bra == OP_BRAZERO)\n  BACKTRACK_AS(bracket_backtrack)->zero_matchingpath = LABEL();\n\nif (bra == OP_BRAMINZERO)\n  {\n  /* This is a backtrack path! (From the viewpoint of OP_BRAMINZERO) */\n  JUMPTO(SLJIT_JUMP, ((braminzero_backtrack *)parent)->matchingpath);\n  if (braminzero != NULL)\n    {\n    JUMPHERE(braminzero);\n    /* We need to release the end pointer to perform the\n    backtrack for the zero-length iteration. When\n    framesize is < 0, OP_ONCE will do the release itself. */\n    if (opcode == OP_ONCE && BACKTRACK_AS(bracket_backtrack)->u.framesize >= 0)\n      {\n      OP1(SLJIT_MOV, STACK_TOP, 0, SLJIT_MEM1(SLJIT_SP), private_data_ptr);\n      add_jump(compiler, &common->revertframes, JUMP(SLJIT_FAST_CALL));\n      OP2(SLJIT_ADD, STACK_TOP, 0, STACK_TOP, 0, SLJIT_IMM, (BACKTRACK_AS(bracket_backtrack)->u.framesize - 1) * sizeof(sljit_sw));\n      }\n    else if (ket == OP_KETRMIN && opcode != OP_ONCE)\n      free_stack(common, 1);\n    }\n  /* Continue to the normal backtrack. */\n  }\n\nif ((ket != OP_KET && bra != OP_BRAMINZERO) || bra == OP_BRAZERO)\n  count_match(common);\n\ncc += 1 + LINK_SIZE;\n\nif (opcode == OP_ONCE)\n  {\n  /* We temporarily encode the needs_control_head in the lowest bit.\n     Note: on the target architectures of SLJIT the ((x << 1) >> 1) returns\n     the same value for small signed numbers (including negative numbers). */\n  BACKTRACK_AS(bracket_backtrack)->u.framesize = (int)((unsigned)BACKTRACK_AS(bracket_backtrack)->u.framesize << 1) | (needs_control_head ? 1 : 0);\n  }\nreturn cc + repeat_length;\n}\n\nstatic PCRE2_SPTR compile_bracketpos_matchingpath(compiler_common *common, PCRE2_SPTR cc, backtrack_common *parent)\n{\nDEFINE_COMPILER;\nbacktrack_common *backtrack;\nPCRE2_UCHAR opcode;\nint private_data_ptr;\nint cbraprivptr = 0;\nBOOL needs_control_head;\nint framesize;\nint stacksize;\nint offset = 0;\nBOOL zero = FALSE;\nPCRE2_SPTR ccbegin = NULL;\nint stack; /* Also contains the offset of control head. */\nstruct sljit_label *loop = NULL;\nstruct jump_list *emptymatch = NULL;\n\nPUSH_BACKTRACK(sizeof(bracketpos_backtrack), cc, NULL);\nif (*cc == OP_BRAPOSZERO)\n  {\n  zero = TRUE;\n  cc++;\n  }\n\nopcode = *cc;\nprivate_data_ptr = PRIVATE_DATA(cc);\nSLJIT_ASSERT(private_data_ptr != 0);\nBACKTRACK_AS(bracketpos_backtrack)->private_data_ptr = private_data_ptr;\nswitch(opcode)\n  {\n  case OP_BRAPOS:\n  case OP_SBRAPOS:\n  ccbegin = cc + 1 + LINK_SIZE;\n  break;\n\n  case OP_CBRAPOS:\n  case OP_SCBRAPOS:\n  offset = GET2(cc, 1 + LINK_SIZE);\n  /* This case cannot be optimized in the same was as\n  normal capturing brackets. */\n  SLJIT_ASSERT(common->optimized_cbracket\u00ddoffset\u00a8 == 0);\n  cbraprivptr = OVECTOR_PRIV(offset);\n  offset <<= 1;\n  ccbegin = cc + 1 + LINK_SIZE + IMM2_SIZE;\n  break;\n\n  default:\n  SLJIT_UNREACHABLE();\n  break;\n  }\n\nframesize = get_framesize(common, cc, NULL, FALSE, &needs_control_head);\nBACKTRACK_AS(bracketpos_backtrack)->framesize = framesize;\nif (framesize < 0)\n  {\n  if (offset != 0)\n    {\n    stacksize = 2;\n    if (common->capture_last_ptr != 0)\n      stacksize++;\n    }\n  else\n    stacksize = 1;\n\n  if (needs_control_head)\n    stacksize++;\n  if (!zero)\n    stacksize++;\n\n  BACKTRACK_AS(bracketpos_backtrack)->stacksize = stacksize;\n  allocate_stack(common, stacksize);\n  if (framesize == no_frame)\n    OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), private_data_ptr, STACK_TOP, 0);\n\n  stack = 0;\n  if (offset != 0)\n    {\n    stack = 2;\n    OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(SLJIT_SP), OVECTOR(offset));\n    OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(SLJIT_SP), OVECTOR(offset + 1));\n    OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(0), TMP1, 0);\n    if (common->capture_last_ptr != 0)\n      OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(SLJIT_SP), common->capture_last_ptr);\n    OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(1), TMP2, 0);\n    if (needs_control_head)\n      OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(SLJIT_SP), common->control_head_ptr);\n    if (common->capture_last_ptr != 0)\n      {\n      OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(2), TMP1, 0);\n      stack = 3;\n      }\n    }\n  else\n    {\n    if (needs_control_head)\n      OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(SLJIT_SP), common->control_head_ptr);\n    OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(0), STR_PTR, 0);\n    stack = 1;\n    }\n\n  if (needs_control_head)\n    stack++;\n  if (!zero)\n    OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(stack), SLJIT_IMM, 1);\n  if (needs_control_head)\n    {\n    stack--;\n    OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(stack), TMP2, 0);\n    }\n  }\nelse\n  {\n  stacksize = framesize + 1;\n  if (!zero)\n    stacksize++;\n  if (needs_control_head)\n    stacksize++;\n  if (offset == 0)\n    stacksize++;\n  BACKTRACK_AS(bracketpos_backtrack)->stacksize = stacksize;\n\n  allocate_stack(common, stacksize);\n  OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(SLJIT_SP), private_data_ptr);\n  if (needs_control_head)\n    OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(SLJIT_SP), common->control_head_ptr);\n  OP2(SLJIT_ADD, SLJIT_MEM1(SLJIT_SP), private_data_ptr, STACK_TOP, 0, SLJIT_IMM, stacksize * sizeof(sljit_sw));\n\n  stack = 0;\n  if (!zero)\n    {\n    OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(0), SLJIT_IMM, 1);\n    stack = 1;\n    }\n  if (needs_control_head)\n    {\n    OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(stack), TMP2, 0);\n    stack++;\n    }\n  if (offset == 0)\n    {\n    OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(stack), STR_PTR, 0);\n    stack++;\n    }\n  OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(stack), TMP1, 0);\n  init_frame(common, cc, NULL, stacksize - 1, stacksize - framesize);\n  stack -= 1 + (offset == 0);\n  }\n\nif (offset != 0)\n  OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), cbraprivptr, STR_PTR, 0);\n\nloop = LABEL();\nwhile (*cc != OP_KETRPOS)\n  {\n  backtrack->top = NULL;\n  backtrack->topbacktracks = NULL;\n  cc += GET(cc, 1);\n\n  compile_matchingpath(common, ccbegin, cc, backtrack);\n  if (SLJIT_UNLIKELY(sljit_get_compiler_error(compiler)))\n    return NULL;\n\n  if (framesize < 0)\n    {\n    if (framesize == no_frame)\n      OP1(SLJIT_MOV, STACK_TOP, 0, SLJIT_MEM1(SLJIT_SP), private_data_ptr);\n\n    if (offset != 0)\n      {\n      OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(SLJIT_SP), cbraprivptr);\n      OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), OVECTOR(offset + 1), STR_PTR, 0);\n      OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), cbraprivptr, STR_PTR, 0);\n      if (common->capture_last_ptr != 0)\n        OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), common->capture_last_ptr, SLJIT_IMM, offset >> 1);\n      OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), OVECTOR(offset), TMP1, 0);\n      }\n    else\n      {\n      if (opcode == OP_SBRAPOS)\n        OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(STACK_TOP), STACK(0));\n      OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(0), STR_PTR, 0);\n      }\n\n    /* Even if the match is empty, we need to reset the control head. */\n    if (needs_control_head)\n      OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), common->control_head_ptr, SLJIT_MEM1(STACK_TOP), STACK(stack));\n\n    if (opcode == OP_SBRAPOS || opcode == OP_SCBRAPOS)\n      add_jump(compiler, &emptymatch, CMP(SLJIT_EQUAL, TMP1, 0, STR_PTR, 0));\n\n    if (!zero)\n      OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(stacksize - 1), SLJIT_IMM, 0);\n    }\n  else\n    {\n    if (offset != 0)\n      {\n      OP2(SLJIT_SUB, STACK_TOP, 0, SLJIT_MEM1(SLJIT_SP), private_data_ptr, SLJIT_IMM, stacksize * sizeof(sljit_sw));\n      OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(SLJIT_SP), cbraprivptr);\n      OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), OVECTOR(offset + 1), STR_PTR, 0);\n      OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), cbraprivptr, STR_PTR, 0);\n      if (common->capture_last_ptr != 0)\n        OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), common->capture_last_ptr, SLJIT_IMM, offset >> 1);\n      OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), OVECTOR(offset), TMP1, 0);\n      }\n    else\n      {\n      OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(SLJIT_SP), private_data_ptr);\n      OP2(SLJIT_SUB, STACK_TOP, 0, TMP2, 0, SLJIT_IMM, stacksize * sizeof(sljit_sw));\n      if (opcode == OP_SBRAPOS)\n        OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(TMP2), STACK(-framesize - 2));\n      OP1(SLJIT_MOV, SLJIT_MEM1(TMP2), STACK(-framesize - 2), STR_PTR, 0);\n      }\n\n    /* Even if the match is empty, we need to reset the control head. */\n    if (needs_control_head)\n      OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), common->control_head_ptr, SLJIT_MEM1(STACK_TOP), STACK(stack));\n\n    if (opcode == OP_SBRAPOS || opcode == OP_SCBRAPOS)\n      add_jump(compiler, &emptymatch, CMP(SLJIT_EQUAL, TMP1, 0, STR_PTR, 0));\n\n    if (!zero)\n      {\n      if (framesize < 0)\n        OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(stacksize - 1), SLJIT_IMM, 0);\n      else\n        OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(0), SLJIT_IMM, 0);\n      }\n    }\n\n  JUMPTO(SLJIT_JUMP, loop);\n  flush_stubs(common);\n\n  compile_backtrackingpath(common, backtrack->top);\n  if (SLJIT_UNLIKELY(sljit_get_compiler_error(compiler)))\n    return NULL;\n  set_jumps(backtrack->topbacktracks, LABEL());\n\n  if (framesize < 0)\n    {\n    if (offset != 0)\n      OP1(SLJIT_MOV, STR_PTR, 0, SLJIT_MEM1(SLJIT_SP), cbraprivptr);\n    else\n      OP1(SLJIT_MOV, STR_PTR, 0, SLJIT_MEM1(STACK_TOP), STACK(0));\n    }\n  else\n    {\n    if (offset != 0)\n      {\n      /* Last alternative. */\n      if (*cc == OP_KETRPOS)\n        OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(SLJIT_SP), private_data_ptr);\n      OP1(SLJIT_MOV, STR_PTR, 0, SLJIT_MEM1(SLJIT_SP), cbraprivptr);\n      }\n    else\n      {\n      OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(SLJIT_SP), private_data_ptr);\n      OP1(SLJIT_MOV, STR_PTR, 0, SLJIT_MEM1(TMP2), STACK(-framesize - 2));\n      }\n    }\n\n  if (*cc == OP_KETRPOS)\n    break;\n  ccbegin = cc + 1 + LINK_SIZE;\n  }\n\n/* We don't have to restore the control head in case of a failed match. */\n\nbacktrack->topbacktracks = NULL;\nif (!zero)\n  {\n  if (framesize < 0)\n    add_jump(compiler, &backtrack->topbacktracks, CMP(SLJIT_NOT_EQUAL, SLJIT_MEM1(STACK_TOP), STACK(stacksize - 1), SLJIT_IMM, 0));\n  else /* TMP2 is set to \u00ddprivate_data_ptr\u00a8 above. */\n    add_jump(compiler, &backtrack->topbacktracks, CMP(SLJIT_NOT_EQUAL, SLJIT_MEM1(TMP2), STACK(-stacksize), SLJIT_IMM, 0));\n  }\n\n/* None of them matched. */\nset_jumps(emptymatch, LABEL());\ncount_match(common);\nreturn cc + 1 + LINK_SIZE;\n}\n\nstatic SLJIT_INLINE PCRE2_SPTR get_iterator_parameters(compiler_common *common, PCRE2_SPTR cc, PCRE2_UCHAR *opcode, PCRE2_UCHAR *type, sljit_u32 *max, sljit_u32 *exact, PCRE2_SPTR *end)\n{\nint class_len;\n\n*opcode = *cc;\n*exact = 0;\n\nif (*opcode >= OP_STAR && *opcode <= OP_POSUPTO)\n  {\n  cc++;\n  *type = OP_CHAR;\n  }\nelse if (*opcode >= OP_STARI && *opcode <= OP_POSUPTOI)\n  {\n  cc++;\n  *type = OP_CHARI;\n  *opcode -= OP_STARI - OP_STAR;\n  }\nelse if (*opcode >= OP_NOTSTAR && *opcode <= OP_NOTPOSUPTO)\n  {\n  cc++;\n  *type = OP_NOT;\n  *opcode -= OP_NOTSTAR - OP_STAR;\n  }\nelse if (*opcode >= OP_NOTSTARI && *opcode <= OP_NOTPOSUPTOI)\n  {\n  cc++;\n  *type = OP_NOTI;\n  *opcode -= OP_NOTSTARI - OP_STAR;\n  }\nelse if (*opcode >= OP_TYPESTAR && *opcode <= OP_TYPEPOSUPTO)\n  {\n  cc++;\n  *opcode -= OP_TYPESTAR - OP_STAR;\n  *type = OP_END;\n  }\nelse\n  {\n  SLJIT_ASSERT(*opcode == OP_CLASS || *opcode == OP_NCLASS || *opcode == OP_XCLASS);\n  *type = *opcode;\n  cc++;\n  class_len = (*type < OP_XCLASS) ? (int)(1 + (32 / sizeof(PCRE2_UCHAR))) : GET(cc, 0);\n  *opcode = cc\u00ddclass_len - 1\u00a8;\n\n  if (*opcode >= OP_CRSTAR && *opcode <= OP_CRMINQUERY)\n    {\n    *opcode -= OP_CRSTAR - OP_STAR;\n    *end = cc + class_len;\n\n    if (*opcode == OP_PLUS || *opcode == OP_MINPLUS)\n      {\n      *exact = 1;\n      *opcode -= OP_PLUS - OP_STAR;\n      }\n    }\n  else if (*opcode >= OP_CRPOSSTAR && *opcode <= OP_CRPOSQUERY)\n    {\n    *opcode -= OP_CRPOSSTAR - OP_POSSTAR;\n    *end = cc + class_len;\n\n    if (*opcode == OP_POSPLUS)\n      {\n      *exact = 1;\n      *opcode = OP_POSSTAR;\n      }\n    }\n  else\n    {\n    SLJIT_ASSERT(*opcode == OP_CRRANGE || *opcode == OP_CRMINRANGE || *opcode == OP_CRPOSRANGE);\n    *max = GET2(cc, (class_len + IMM2_SIZE));\n    *exact = GET2(cc, class_len);\n\n    if (*max == 0)\n      {\n      if (*opcode == OP_CRPOSRANGE)\n        *opcode = OP_POSSTAR;\n      else\n        *opcode -= OP_CRRANGE - OP_STAR;\n      }\n    else\n      {\n      *max -= *exact;\n      if (*max == 0)\n        *opcode = OP_EXACT;\n      else if (*max == 1)\n        {\n        if (*opcode == OP_CRPOSRANGE)\n          *opcode = OP_POSQUERY;\n        else\n          *opcode -= OP_CRRANGE - OP_QUERY;\n        }\n      else\n        {\n        if (*opcode == OP_CRPOSRANGE)\n          *opcode = OP_POSUPTO;\n        else\n          *opcode -= OP_CRRANGE - OP_UPTO;\n        }\n      }\n    *end = cc + class_len + 2 * IMM2_SIZE;\n    }\n  return cc;\n  }\n\nswitch(*opcode)\n  {\n  case OP_EXACT:\n  *exact = GET2(cc, 0);\n  cc += IMM2_SIZE;\n  break;\n\n  case OP_PLUS:\n  case OP_MINPLUS:\n  *exact = 1;\n  *opcode -= OP_PLUS - OP_STAR;\n  break;\n\n  case OP_POSPLUS:\n  *exact = 1;\n  *opcode = OP_POSSTAR;\n  break;\n\n  case OP_UPTO:\n  case OP_MINUPTO:\n  case OP_POSUPTO:\n  *max = GET2(cc, 0);\n  cc += IMM2_SIZE;\n  break;\n  }\n\nif (*type == OP_END)\n  {\n  *type = *cc;\n  *end = next_opcode(common, cc);\n  cc++;\n  return cc;\n  }\n\n*end = cc + 1;\n#ifdef SUPPORT_UNICODE\nif (common->utf && HAS_EXTRALEN(*cc)) *end += GET_EXTRALEN(*cc);\n#endif\nreturn cc;\n}\n\nstatic PCRE2_SPTR compile_iterator_matchingpath(compiler_common *common, PCRE2_SPTR cc, backtrack_common *parent)\n{\nDEFINE_COMPILER;\nbacktrack_common *backtrack;\nPCRE2_UCHAR opcode;\nPCRE2_UCHAR type;\nsljit_u32 max = 0, exact;\nsljit_s32 early_fail_ptr = PRIVATE_DATA(cc + 1);\nsljit_s32 early_fail_type;\nBOOL charpos_enabled;\nPCRE2_UCHAR charpos_char;\nunsigned int charpos_othercasebit;\nPCRE2_SPTR end;\njump_list *no_match = NULL;\njump_list *no_char1_match = NULL;\nstruct sljit_jump *jump = NULL;\nstruct sljit_label *label;\nint private_data_ptr = PRIVATE_DATA(cc);\nint base = (private_data_ptr == 0) ? SLJIT_MEM1(STACK_TOP) : SLJIT_MEM1(SLJIT_SP);\nint offset0 = (private_data_ptr == 0) ? STACK(0) : private_data_ptr;\nint offset1 = (private_data_ptr == 0) ? STACK(1) : private_data_ptr + (int)sizeof(sljit_sw);\nint tmp_base, tmp_offset;\n#if defined SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH != 32\nBOOL use_tmp;\n#endif\n\nPUSH_BACKTRACK(sizeof(char_iterator_backtrack), cc, NULL);\n\nearly_fail_type = (early_fail_ptr & 0x7);\nearly_fail_ptr >>= 3;\n\n/* During recursion, these optimizations are disabled. */\nif (common->early_fail_start_ptr == 0)\n  {\n  early_fail_ptr = 0;\n  early_fail_type = type_skip;\n  }\n\nSLJIT_ASSERT(common->fast_forward_bc_ptr != NULL || early_fail_ptr == 0\n  || (early_fail_ptr >= common->early_fail_start_ptr && early_fail_ptr <= common->early_fail_end_ptr));\n\nif (early_fail_type == type_fail)\n  add_jump(compiler, &backtrack->topbacktracks, CMP(SLJIT_LESS_EQUAL, STR_PTR, 0, SLJIT_MEM1(SLJIT_SP), early_fail_ptr));\n\ncc = get_iterator_parameters(common, cc, &opcode, &type, &max, &exact, &end);\n\nif (type != OP_EXTUNI)\n  {\n  tmp_base = TMP3;\n  tmp_offset = 0;\n  }\nelse\n  {\n  tmp_base = SLJIT_MEM1(SLJIT_SP);\n  tmp_offset = POSSESSIVE0;\n  }\n\n/* Handle fixed part first. */\nif (exact > 1)\n  {\n  SLJIT_ASSERT(early_fail_ptr == 0);\n\n  if (common->mode == PCRE2_JIT_COMPLETE\n#ifdef SUPPORT_UNICODE\n      && !common->utf\n#endif\n      && type != OP_ANYNL && type != OP_EXTUNI)\n    {\n    OP2(SLJIT_ADD, TMP1, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(exact));\n    add_jump(compiler, &backtrack->topbacktracks, CMP(SLJIT_GREATER, TMP1, 0, STR_END, 0));\n    OP1(SLJIT_MOV, tmp_base, tmp_offset, SLJIT_IMM, exact);\n    label = LABEL();\n    compile_char1_matchingpath(common, type, cc, &backtrack->topbacktracks, FALSE);\n    OP2(SLJIT_SUB | SLJIT_SET_Z, tmp_base, tmp_offset, tmp_base, tmp_offset, SLJIT_IMM, 1);\n    JUMPTO(SLJIT_NOT_ZERO, label);\n    }\n  else\n    {\n    OP1(SLJIT_MOV, tmp_base, tmp_offset, SLJIT_IMM, exact);\n    label = LABEL();\n    compile_char1_matchingpath(common, type, cc, &backtrack->topbacktracks, TRUE);\n    OP2(SLJIT_SUB | SLJIT_SET_Z, tmp_base, tmp_offset, tmp_base, tmp_offset, SLJIT_IMM, 1);\n    JUMPTO(SLJIT_NOT_ZERO, label);\n    }\n  }\nelse if (exact == 1)\n  {\n  compile_char1_matchingpath(common, type, cc, &backtrack->topbacktracks, TRUE);\n\n  if (early_fail_type == type_fail_range)\n    {\n    OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(SLJIT_SP), early_fail_ptr);\n    OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(SLJIT_SP), early_fail_ptr + (int)sizeof(sljit_sw));\n    OP2(SLJIT_SUB, TMP1, 0, TMP1, 0, TMP2, 0);\n    OP2(SLJIT_SUB, TMP2, 0, STR_PTR, 0, TMP2, 0);\n    add_jump(compiler, &backtrack->topbacktracks, CMP(SLJIT_LESS_EQUAL, TMP2, 0, TMP1, 0));\n\n    OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), early_fail_ptr + (int)sizeof(sljit_sw), STR_PTR, 0);\n    }\n  }\n\nswitch(opcode)\n  {\n  case OP_STAR:\n  case OP_UPTO:\n  SLJIT_ASSERT(early_fail_ptr == 0 || opcode == OP_STAR);\n\n  if (type == OP_ANYNL || type == OP_EXTUNI)\n    {\n    SLJIT_ASSERT(private_data_ptr == 0);\n    SLJIT_ASSERT(early_fail_ptr == 0);\n\n    allocate_stack(common, 2);\n    OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(0), STR_PTR, 0);\n    OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(1), SLJIT_IMM, 0);\n\n    if (opcode == OP_UPTO)\n      OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), POSSESSIVE0, SLJIT_IMM, max);\n\n    label = LABEL();\n    compile_char1_matchingpath(common, type, cc, &BACKTRACK_AS(char_iterator_backtrack)->u.backtracks, TRUE);\n    if (opcode == OP_UPTO)\n      {\n      OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(SLJIT_SP), POSSESSIVE0);\n      OP2(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, TMP1, 0, SLJIT_IMM, 1);\n      jump = JUMP(SLJIT_ZERO);\n      OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), POSSESSIVE0, TMP1, 0);\n      }\n\n    /* We cannot use TMP3 because of allocate_stack. */\n    allocate_stack(common, 1);\n    OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(0), STR_PTR, 0);\n    JUMPTO(SLJIT_JUMP, label);\n    if (jump != NULL)\n      JUMPHERE(jump);\n    BACKTRACK_AS(char_iterator_backtrack)->matchingpath = LABEL();\n    break;\n    }\n#ifdef SUPPORT_UNICODE\n  else if (type == OP_ALLANY && !common->invalid_utf)\n#else\n  else if (type == OP_ALLANY)\n#endif\n    {\n    if (opcode == OP_STAR)\n      {\n      if (private_data_ptr == 0)\n        allocate_stack(common, 2);\n\n      OP1(SLJIT_MOV, base, offset0, STR_END, 0);\n      OP1(SLJIT_MOV, base, offset1, STR_PTR, 0);\n\n      OP1(SLJIT_MOV, STR_PTR, 0, STR_END, 0);\n      process_partial_match(common);\n\n      if (early_fail_ptr != 0)\n        OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), early_fail_ptr, STR_END, 0);\n      BACKTRACK_AS(char_iterator_backtrack)->matchingpath = LABEL();\n      break;\n      }\n#ifdef SUPPORT_UNICODE\n    else if (!common->utf)\n#else\n    else\n#endif\n      {\n      if (private_data_ptr == 0)\n        allocate_stack(common, 2);\n\n      OP1(SLJIT_MOV, base, offset1, STR_PTR, 0);\n      OP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(max));\n\n      if (common->mode == PCRE2_JIT_COMPLETE)\n        {\n        OP2(SLJIT_SUB | SLJIT_SET_GREATER, SLJIT_UNUSED, 0, STR_PTR, 0, STR_END, 0);\n        CMOV(SLJIT_GREATER, STR_PTR, STR_END, 0);\n        }\n      else\n        {\n        jump = CMP(SLJIT_LESS_EQUAL, STR_PTR, 0, STR_END, 0);\n        process_partial_match(common);\n        JUMPHERE(jump);\n        }\n\n      OP1(SLJIT_MOV, base, offset0, STR_PTR, 0);\n\n      if (early_fail_ptr != 0)\n        OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), early_fail_ptr, STR_PTR, 0);\n      BACKTRACK_AS(char_iterator_backtrack)->matchingpath = LABEL();\n      break;\n      }\n    }\n\n  charpos_enabled = FALSE;\n  charpos_char = 0;\n  charpos_othercasebit = 0;\n\n  if ((type != OP_CHAR && type != OP_CHARI) && (*end == OP_CHAR || *end == OP_CHARI))\n    {\n#ifdef SUPPORT_UNICODE\n    charpos_enabled = !common->utf || !HAS_EXTRALEN(end\u00dd1\u00a8);\n#else\n    charpos_enabled = TRUE;\n#endif\n    if (charpos_enabled && *end == OP_CHARI && char_has_othercase(common, end + 1))\n      {\n      charpos_othercasebit = char_get_othercase_bit(common, end + 1);\n      if (charpos_othercasebit == 0)\n        charpos_enabled = FALSE;\n      }\n\n    if (charpos_enabled)\n      {\n      charpos_char = end\u00dd1\u00a8;\n      /* Consume the OP_CHAR opcode. */\n      end += 2;\n#if PCRE2_CODE_UNIT_WIDTH == 8\n      SLJIT_ASSERT((charpos_othercasebit >> 8) == 0);\n#elif PCRE2_CODE_UNIT_WIDTH == 16 || PCRE2_CODE_UNIT_WIDTH == 32\n      SLJIT_ASSERT((charpos_othercasebit >> 9) == 0);\n      if ((charpos_othercasebit & 0x100) != 0)\n        charpos_othercasebit = (charpos_othercasebit & 0xff) << 8;\n#endif\n      if (charpos_othercasebit != 0)\n        charpos_char |= charpos_othercasebit;\n\n      BACKTRACK_AS(char_iterator_backtrack)->u.charpos.enabled = TRUE;\n      BACKTRACK_AS(char_iterator_backtrack)->u.charpos.chr = charpos_char;\n      BACKTRACK_AS(char_iterator_backtrack)->u.charpos.othercasebit = charpos_othercasebit;\n      }\n    }\n\n  if (charpos_enabled)\n    {\n    if (opcode == OP_UPTO)\n      OP1(SLJIT_MOV, tmp_base, tmp_offset, SLJIT_IMM, max + 1);\n\n    /* Search the first instance of charpos_char. */\n    jump = JUMP(SLJIT_JUMP);\n    label = LABEL();\n    if (opcode == OP_UPTO)\n      {\n      OP2(SLJIT_SUB | SLJIT_SET_Z, tmp_base, tmp_offset, tmp_base, tmp_offset, SLJIT_IMM, 1);\n      add_jump(compiler, &backtrack->topbacktracks, JUMP(SLJIT_ZERO));\n      }\n    compile_char1_matchingpath(common, type, cc, &backtrack->topbacktracks, FALSE);\n    if (early_fail_ptr != 0)\n      OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), early_fail_ptr, STR_PTR, 0);\n    JUMPHERE(jump);\n\n    detect_partial_match(common, &backtrack->topbacktracks);\n    OP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(0));\n    if (charpos_othercasebit != 0)\n      OP2(SLJIT_OR, TMP1, 0, TMP1, 0, SLJIT_IMM, charpos_othercasebit);\n    CMPTO(SLJIT_NOT_EQUAL, TMP1, 0, SLJIT_IMM, charpos_char, label);\n\n    if (private_data_ptr == 0)\n      allocate_stack(common, 2);\n    OP1(SLJIT_MOV, base, offset0, STR_PTR, 0);\n    OP1(SLJIT_MOV, base, offset1, STR_PTR, 0);\n\n    if (opcode == OP_UPTO)\n      {\n      OP2(SLJIT_SUB | SLJIT_SET_Z, tmp_base, tmp_offset, tmp_base, tmp_offset, SLJIT_IMM, 1);\n      add_jump(compiler, &no_match, JUMP(SLJIT_ZERO));\n      }\n\n    /* Search the last instance of charpos_char. */\n    label = LABEL();\n    compile_char1_matchingpath(common, type, cc, &no_match, FALSE);\n    if (early_fail_ptr != 0)\n      OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), early_fail_ptr, STR_PTR, 0);\n    detect_partial_match(common, &no_match);\n    OP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(0));\n    if (charpos_othercasebit != 0)\n      OP2(SLJIT_OR, TMP1, 0, TMP1, 0, SLJIT_IMM, charpos_othercasebit);\n\n    if (opcode == OP_STAR)\n      {\n      CMPTO(SLJIT_NOT_EQUAL, TMP1, 0, SLJIT_IMM, charpos_char, label);\n      OP1(SLJIT_MOV, base, offset0, STR_PTR, 0);\n      JUMPTO(SLJIT_JUMP, label);\n      }\n    else\n      {\n      jump = CMP(SLJIT_NOT_EQUAL, TMP1, 0, SLJIT_IMM, charpos_char);\n      OP1(SLJIT_MOV, base, offset0, STR_PTR, 0);\n      JUMPHERE(jump);\n      OP2(SLJIT_SUB | SLJIT_SET_Z, tmp_base, tmp_offset, tmp_base, tmp_offset, SLJIT_IMM, 1);\n      JUMPTO(SLJIT_NOT_ZERO, label);\n      }\n\n    set_jumps(no_match, LABEL());\n    OP2(SLJIT_ADD, STR_PTR, 0, base, offset0, SLJIT_IMM, IN_UCHARS(1));\n    OP1(SLJIT_MOV, base, offset0, STR_PTR, 0);\n    }\n  else\n    {\n    if (private_data_ptr == 0)\n      allocate_stack(common, 2);\n\n    OP1(SLJIT_MOV, base, offset1, STR_PTR, 0);\n#if defined SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH != 32\n    use_tmp = (!HAS_VIRTUAL_REGISTERS && opcode == OP_STAR);\n    SLJIT_ASSERT(!use_tmp || tmp_base == TMP3);\n\n    if (common->utf)\n      OP1(SLJIT_MOV, use_tmp ? TMP3 : base, use_tmp ? 0 : offset0, STR_PTR, 0);\n#endif\n    if (opcode == OP_UPTO)\n      OP1(SLJIT_MOV, tmp_base, tmp_offset, SLJIT_IMM, max);\n\n    detect_partial_match(common, &no_match);\n    label = LABEL();\n    compile_char1_matchingpath(common, type, cc, &no_char1_match, FALSE);\n#if defined SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH != 32\n    if (common->utf)\n      OP1(SLJIT_MOV, use_tmp ? TMP3 : base, use_tmp ? 0 : offset0, STR_PTR, 0);\n#endif\n\n    if (opcode == OP_UPTO)\n      {\n      OP2(SLJIT_SUB | SLJIT_SET_Z, tmp_base, tmp_offset, tmp_base, tmp_offset, SLJIT_IMM, 1);\n      add_jump(compiler, &no_match, JUMP(SLJIT_ZERO));\n      }\n\n    detect_partial_match_to(common, label);\n    OP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n\n    set_jumps(no_char1_match, LABEL());\n#if defined SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH != 32\n    if (common->utf)\n      {\n      set_jumps(no_match, LABEL());\n      if (use_tmp)\n        {\n        OP1(SLJIT_MOV, STR_PTR, 0, TMP3, 0);\n        OP1(SLJIT_MOV, base, offset0, TMP3, 0);\n        }\n      else\n        OP1(SLJIT_MOV, STR_PTR, 0, base, offset0);\n      }\n    else\n#endif\n      {\n      OP2(SLJIT_SUB, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n      set_jumps(no_match, LABEL());\n      OP1(SLJIT_MOV, base, offset0, STR_PTR, 0);\n      }\n\n    if (early_fail_ptr != 0)\n      OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), early_fail_ptr, STR_PTR, 0);\n    }\n\n  BACKTRACK_AS(char_iterator_backtrack)->matchingpath = LABEL();\n  break;\n\n  case OP_MINSTAR:\n  if (private_data_ptr == 0)\n    allocate_stack(common, 1);\n  OP1(SLJIT_MOV, base, offset0, STR_PTR, 0);\n  BACKTRACK_AS(char_iterator_backtrack)->matchingpath = LABEL();\n  if (early_fail_ptr != 0)\n    OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), early_fail_ptr, STR_PTR, 0);\n  break;\n\n  case OP_MINUPTO:\n  SLJIT_ASSERT(early_fail_ptr == 0);\n  if (private_data_ptr == 0)\n    allocate_stack(common, 2);\n  OP1(SLJIT_MOV, base, offset0, STR_PTR, 0);\n  OP1(SLJIT_MOV, base, offset1, SLJIT_IMM, max + 1);\n  BACKTRACK_AS(char_iterator_backtrack)->matchingpath = LABEL();\n  break;\n\n  case OP_QUERY:\n  case OP_MINQUERY:\n  SLJIT_ASSERT(early_fail_ptr == 0);\n  if (private_data_ptr == 0)\n    allocate_stack(common, 1);\n  OP1(SLJIT_MOV, base, offset0, STR_PTR, 0);\n  if (opcode == OP_QUERY)\n    compile_char1_matchingpath(common, type, cc, &BACKTRACK_AS(char_iterator_backtrack)->u.backtracks, TRUE);\n  BACKTRACK_AS(char_iterator_backtrack)->matchingpath = LABEL();\n  break;\n\n  case OP_EXACT:\n  break;\n\n  case OP_POSSTAR:\n#if defined SUPPORT_UNICODE\n  if (type == OP_ALLANY && !common->invalid_utf)\n#else\n  if (type == OP_ALLANY)\n#endif\n    {\n    OP1(SLJIT_MOV, STR_PTR, 0, STR_END, 0);\n    process_partial_match(common);\n    if (early_fail_ptr != 0)\n      OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), early_fail_ptr, STR_END, 0);\n    break;\n    }\n\n#if defined SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH != 32\n  if (common->utf)\n    {\n    OP1(SLJIT_MOV, tmp_base, tmp_offset, STR_PTR, 0);\n    detect_partial_match(common, &no_match);\n    label = LABEL();\n    compile_char1_matchingpath(common, type, cc, &no_match, FALSE);\n    OP1(SLJIT_MOV, tmp_base, tmp_offset, STR_PTR, 0);\n    detect_partial_match_to(common, label);\n\n    set_jumps(no_match, LABEL());\n    OP1(SLJIT_MOV, STR_PTR, 0, tmp_base, tmp_offset);\n    if (early_fail_ptr != 0)\n      {\n      if (!HAS_VIRTUAL_REGISTERS && tmp_base == TMP3)\n        OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), early_fail_ptr, TMP3, 0);\n      else\n        OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), early_fail_ptr, STR_PTR, 0);\n      }\n    break;\n    }\n#endif\n\n  detect_partial_match(common, &no_match);\n  label = LABEL();\n  compile_char1_matchingpath(common, type, cc, &no_char1_match, FALSE);\n  detect_partial_match_to(common, label);\n  OP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n\n  set_jumps(no_char1_match, LABEL());\n  OP2(SLJIT_SUB, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n  set_jumps(no_match, LABEL());\n  if (early_fail_ptr != 0)\n    OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), early_fail_ptr, STR_PTR, 0);\n  break;\n\n  case OP_POSUPTO:\n  SLJIT_ASSERT(early_fail_ptr == 0);\n#if defined SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH != 32\n  if (common->utf)\n    {\n    OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), POSSESSIVE1, STR_PTR, 0);\n    OP1(SLJIT_MOV, tmp_base, tmp_offset, SLJIT_IMM, max);\n\n    detect_partial_match(common, &no_match);\n    label = LABEL();\n    compile_char1_matchingpath(common, type, cc, &no_match, FALSE);\n    OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), POSSESSIVE1, STR_PTR, 0);\n    OP2(SLJIT_SUB | SLJIT_SET_Z, tmp_base, tmp_offset, tmp_base, tmp_offset, SLJIT_IMM, 1);\n    add_jump(compiler, &no_match, JUMP(SLJIT_ZERO));\n    detect_partial_match_to(common, label);\n\n    set_jumps(no_match, LABEL());\n    OP1(SLJIT_MOV, STR_PTR, 0, SLJIT_MEM1(SLJIT_SP), POSSESSIVE1);\n    break;\n    }\n#endif\n\n  if (type == OP_ALLANY)\n    {\n    OP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(max));\n\n    if (common->mode == PCRE2_JIT_COMPLETE)\n      {\n      OP2(SLJIT_SUB | SLJIT_SET_GREATER, SLJIT_UNUSED, 0, STR_PTR, 0, STR_END, 0);\n      CMOV(SLJIT_GREATER, STR_PTR, STR_END, 0);\n      }\n    else\n      {\n      jump = CMP(SLJIT_LESS_EQUAL, STR_PTR, 0, STR_END, 0);\n      process_partial_match(common);\n      JUMPHERE(jump);\n      }\n    break;\n    }\n\n  OP1(SLJIT_MOV, tmp_base, tmp_offset, SLJIT_IMM, max);\n\n  detect_partial_match(common, &no_match);\n  label = LABEL();\n  compile_char1_matchingpath(common, type, cc, &no_char1_match, FALSE);\n  OP2(SLJIT_SUB | SLJIT_SET_Z, tmp_base, tmp_offset, tmp_base, tmp_offset, SLJIT_IMM, 1);\n  add_jump(compiler, &no_match, JUMP(SLJIT_ZERO));\n  detect_partial_match_to(common, label);\n  OP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n\n  set_jumps(no_char1_match, LABEL());\n  OP2(SLJIT_SUB, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n  set_jumps(no_match, LABEL());\n  break;\n\n  case OP_POSQUERY:\n  SLJIT_ASSERT(early_fail_ptr == 0);\n  OP1(SLJIT_MOV, tmp_base, tmp_offset, STR_PTR, 0);\n  compile_char1_matchingpath(common, type, cc, &no_match, TRUE);\n  OP1(SLJIT_MOV, tmp_base, tmp_offset, STR_PTR, 0);\n  set_jumps(no_match, LABEL());\n  OP1(SLJIT_MOV, STR_PTR, 0, tmp_base, tmp_offset);\n  break;\n\n  default:\n  SLJIT_UNREACHABLE();\n  break;\n  }\n\ncount_match(common);\nreturn end;\n}\n\nstatic SLJIT_INLINE PCRE2_SPTR compile_fail_accept_matchingpath(compiler_common *common, PCRE2_SPTR cc, backtrack_common *parent)\n{\nDEFINE_COMPILER;\nbacktrack_common *backtrack;\n\nPUSH_BACKTRACK(sizeof(backtrack_common), cc, NULL);\n\nif (*cc == OP_FAIL)\n  {\n  add_jump(compiler, &backtrack->topbacktracks, JUMP(SLJIT_JUMP));\n  return cc + 1;\n  }\n\nif (*cc == OP_ACCEPT && common->currententry == NULL && (common->re->overall_options & PCRE2_ENDANCHORED) != 0)\n  add_jump(compiler, &common->reset_match, CMP(SLJIT_NOT_EQUAL, STR_PTR, 0, STR_END, 0));\n\nif (*cc == OP_ASSERT_ACCEPT || common->currententry != NULL || !common->might_be_empty)\n  {\n  /* No need to check notempty conditions. */\n  if (common->accept_label == NULL)\n    add_jump(compiler, &common->accept, JUMP(SLJIT_JUMP));\n  else\n    JUMPTO(SLJIT_JUMP, common->accept_label);\n  return cc + 1;\n  }\n\nif (common->accept_label == NULL)\n  add_jump(compiler, &common->accept, CMP(SLJIT_NOT_EQUAL, STR_PTR, 0, SLJIT_MEM1(SLJIT_SP), OVECTOR(0)));\nelse\n  CMPTO(SLJIT_NOT_EQUAL, STR_PTR, 0, SLJIT_MEM1(SLJIT_SP), OVECTOR(0), common->accept_label);\n\nif (HAS_VIRTUAL_REGISTERS)\n  {\n  OP1(SLJIT_MOV, TMP1, 0, ARGUMENTS, 0);\n  OP1(SLJIT_MOV_U32, TMP2, 0, SLJIT_MEM1(TMP1), SLJIT_OFFSETOF(jit_arguments, options));\n  }\nelse\n  OP1(SLJIT_MOV_U32, TMP2, 0, SLJIT_MEM1(ARGUMENTS), SLJIT_OFFSETOF(jit_arguments, options));\n\nOP2(SLJIT_AND | SLJIT_SET_Z, SLJIT_UNUSED, 0, TMP2, 0, SLJIT_IMM, PCRE2_NOTEMPTY);\nadd_jump(compiler, &backtrack->topbacktracks, JUMP(SLJIT_NOT_ZERO));\nOP2(SLJIT_AND | SLJIT_SET_Z, SLJIT_UNUSED, 0, TMP2, 0, SLJIT_IMM, PCRE2_NOTEMPTY_ATSTART);\nif (common->accept_label == NULL)\n  add_jump(compiler, &common->accept, JUMP(SLJIT_ZERO));\nelse\n  JUMPTO(SLJIT_ZERO, common->accept_label);\n\nOP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(HAS_VIRTUAL_REGISTERS ? TMP1 : ARGUMENTS), SLJIT_OFFSETOF(jit_arguments, str));\nif (common->accept_label == NULL)\n  add_jump(compiler, &common->accept, CMP(SLJIT_NOT_EQUAL, TMP2, 0, STR_PTR, 0));\nelse\n  CMPTO(SLJIT_NOT_EQUAL, TMP2, 0, STR_PTR, 0, common->accept_label);\nadd_jump(compiler, &backtrack->topbacktracks, JUMP(SLJIT_JUMP));\nreturn cc + 1;\n}\n\nstatic SLJIT_INLINE PCRE2_SPTR compile_close_matchingpath(compiler_common *common, PCRE2_SPTR cc)\n{\nDEFINE_COMPILER;\nint offset = GET2(cc, 1);\nBOOL optimized_cbracket = common->optimized_cbracket\u00ddoffset\u00a8 != 0;\n\n/* Data will be discarded anyway... */\nif (common->currententry != NULL)\n  return cc + 1 + IMM2_SIZE;\n\nif (!optimized_cbracket)\n  OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(SLJIT_SP), OVECTOR_PRIV(offset));\noffset <<= 1;\nOP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), OVECTOR(offset + 1), STR_PTR, 0);\nif (!optimized_cbracket)\n  OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), OVECTOR(offset), TMP1, 0);\nreturn cc + 1 + IMM2_SIZE;\n}\n\nstatic SLJIT_INLINE PCRE2_SPTR compile_control_verb_matchingpath(compiler_common *common, PCRE2_SPTR cc, backtrack_common *parent)\n{\nDEFINE_COMPILER;\nbacktrack_common *backtrack;\nPCRE2_UCHAR opcode = *cc;\nPCRE2_SPTR ccend = cc + 1;\n\nif (opcode == OP_COMMIT_ARG || opcode == OP_PRUNE_ARG ||\n    opcode == OP_SKIP_ARG || opcode == OP_THEN_ARG)\n  ccend += 2 + cc\u00dd1\u00a8;\n\nPUSH_BACKTRACK(sizeof(backtrack_common), cc, NULL);\n\nif (opcode == OP_SKIP)\n  {\n  allocate_stack(common, 1);\n  OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(0), STR_PTR, 0);\n  return ccend;\n  }\n\nif (opcode == OP_COMMIT_ARG || opcode == OP_PRUNE_ARG || opcode == OP_THEN_ARG)\n  {\n  if (HAS_VIRTUAL_REGISTERS)\n    OP1(SLJIT_MOV, TMP1, 0, ARGUMENTS, 0);\n  OP1(SLJIT_MOV, TMP2, 0, SLJIT_IMM, (sljit_sw)(cc + 2));\n  OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), common->mark_ptr, TMP2, 0);\n  OP1(SLJIT_MOV, SLJIT_MEM1(HAS_VIRTUAL_REGISTERS ? TMP1 : ARGUMENTS), SLJIT_OFFSETOF(jit_arguments, mark_ptr), TMP2, 0);\n  }\n\nreturn ccend;\n}\n\nstatic PCRE2_UCHAR then_trap_opcode\u00dd1\u00a8 = { OP_THEN_TRAP };\n\nstatic SLJIT_INLINE void compile_then_trap_matchingpath(compiler_common *common, PCRE2_SPTR cc, PCRE2_SPTR ccend, backtrack_common *parent)\n{\nDEFINE_COMPILER;\nbacktrack_common *backtrack;\nBOOL needs_control_head;\nint size;\n\nPUSH_BACKTRACK_NOVALUE(sizeof(then_trap_backtrack), cc);\ncommon->then_trap = BACKTRACK_AS(then_trap_backtrack);\nBACKTRACK_AS(then_trap_backtrack)->common.cc = then_trap_opcode;\nBACKTRACK_AS(then_trap_backtrack)->start = (sljit_sw)(cc - common->start);\nBACKTRACK_AS(then_trap_backtrack)->framesize = get_framesize(common, cc, ccend, FALSE, &needs_control_head);\n\nsize = BACKTRACK_AS(then_trap_backtrack)->framesize;\nsize = 3 + (size < 0 ? 0 : size);\n\nOP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(SLJIT_SP), common->control_head_ptr);\nallocate_stack(common, size);\nif (size > 3)\n  OP2(SLJIT_ADD, SLJIT_MEM1(SLJIT_SP), common->control_head_ptr, STACK_TOP, 0, SLJIT_IMM, (size - 3) * sizeof(sljit_sw));\nelse\n  OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), common->control_head_ptr, STACK_TOP, 0);\nOP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(size - 1), SLJIT_IMM, BACKTRACK_AS(then_trap_backtrack)->start);\nOP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(size - 2), SLJIT_IMM, type_then_trap);\nOP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(size - 3), TMP2, 0);\n\nsize = BACKTRACK_AS(then_trap_backtrack)->framesize;\nif (size >= 0)\n  init_frame(common, cc, ccend, size - 1, 0);\n}\n\nstatic void compile_matchingpath(compiler_common *common, PCRE2_SPTR cc, PCRE2_SPTR ccend, backtrack_common *parent)\n{\nDEFINE_COMPILER;\nbacktrack_common *backtrack;\nBOOL has_then_trap = FALSE;\nthen_trap_backtrack *save_then_trap = NULL;\n\nSLJIT_ASSERT(*ccend == OP_END || (*ccend >= OP_ALT && *ccend <= OP_KETRPOS));\n\nif (common->has_then && common->then_offsets\u00ddcc - common->start\u00a8 != 0)\n  {\n  SLJIT_ASSERT(*ccend != OP_END && common->control_head_ptr != 0);\n  has_then_trap = TRUE;\n  save_then_trap = common->then_trap;\n  /* Tail item on backtrack. */\n  compile_then_trap_matchingpath(common, cc, ccend, parent);\n  }\n\nwhile (cc < ccend)\n  {\n  switch(*cc)\n    {\n    case OP_SOD:\n    case OP_SOM:\n    case OP_NOT_WORD_BOUNDARY:\n    case OP_WORD_BOUNDARY:\n    case OP_EODN:\n    case OP_EOD:\n    case OP_DOLL:\n    case OP_DOLLM:\n    case OP_CIRC:\n    case OP_CIRCM:\n    case OP_REVERSE:\n    cc = compile_simple_assertion_matchingpath(common, *cc, cc + 1, parent->top != NULL ? &parent->top->nextbacktracks : &parent->topbacktracks);\n    break;\n\n    case OP_NOT_DIGIT:\n    case OP_DIGIT:\n    case OP_NOT_WHITESPACE:\n    case OP_WHITESPACE:\n    case OP_NOT_WORDCHAR:\n    case OP_WORDCHAR:\n    case OP_ANY:\n    case OP_ALLANY:\n    case OP_ANYBYTE:\n    case OP_NOTPROP:\n    case OP_PROP:\n    case OP_ANYNL:\n    case OP_NOT_HSPACE:\n    case OP_HSPACE:\n    case OP_NOT_VSPACE:\n    case OP_VSPACE:\n    case OP_EXTUNI:\n    case OP_NOT:\n    case OP_NOTI:\n    cc = compile_char1_matchingpath(common, *cc, cc + 1, parent->top != NULL ? &parent->top->nextbacktracks : &parent->topbacktracks, TRUE);\n    break;\n\n    case OP_SET_SOM:\n    PUSH_BACKTRACK_NOVALUE(sizeof(backtrack_common), cc);\n    OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(SLJIT_SP), OVECTOR(0));\n    allocate_stack(common, 1);\n    OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), OVECTOR(0), STR_PTR, 0);\n    OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(0), TMP2, 0);\n    cc++;\n    break;\n\n    case OP_CHAR:\n    case OP_CHARI:\n    if (common->mode == PCRE2_JIT_COMPLETE)\n      cc = compile_charn_matchingpath(common, cc, ccend, parent->top != NULL ? &parent->top->nextbacktracks : &parent->topbacktracks);\n    else\n      cc = compile_char1_matchingpath(common, *cc, cc + 1, parent->top != NULL ? &parent->top->nextbacktracks : &parent->topbacktracks, TRUE);\n    break;\n\n    case OP_STAR:\n    case OP_MINSTAR:\n    case OP_PLUS:\n    case OP_MINPLUS:\n    case OP_QUERY:\n    case OP_MINQUERY:\n    case OP_UPTO:\n    case OP_MINUPTO:\n    case OP_EXACT:\n    case OP_POSSTAR:\n    case OP_POSPLUS:\n    case OP_POSQUERY:\n    case OP_POSUPTO:\n    case OP_STARI:\n    case OP_MINSTARI:\n    case OP_PLUSI:\n    case OP_MINPLUSI:\n    case OP_QUERYI:\n    case OP_MINQUERYI:\n    case OP_UPTOI:\n    case OP_MINUPTOI:\n    case OP_EXACTI:\n    case OP_POSSTARI:\n    case OP_POSPLUSI:\n    case OP_POSQUERYI:\n    case OP_POSUPTOI:\n    case OP_NOTSTAR:\n    case OP_NOTMINSTAR:\n    case OP_NOTPLUS:\n    case OP_NOTMINPLUS:\n    case OP_NOTQUERY:\n    case OP_NOTMINQUERY:\n    case OP_NOTUPTO:\n    case OP_NOTMINUPTO:\n    case OP_NOTEXACT:\n    case OP_NOTPOSSTAR:\n    case OP_NOTPOSPLUS:\n    case OP_NOTPOSQUERY:\n    case OP_NOTPOSUPTO:\n    case OP_NOTSTARI:\n    case OP_NOTMINSTARI:\n    case OP_NOTPLUSI:\n    case OP_NOTMINPLUSI:\n    case OP_NOTQUERYI:\n    case OP_NOTMINQUERYI:\n    case OP_NOTUPTOI:\n    case OP_NOTMINUPTOI:\n    case OP_NOTEXACTI:\n    case OP_NOTPOSSTARI:\n    case OP_NOTPOSPLUSI:\n    case OP_NOTPOSQUERYI:\n    case OP_NOTPOSUPTOI:\n    case OP_TYPESTAR:\n    case OP_TYPEMINSTAR:\n    case OP_TYPEPLUS:\n    case OP_TYPEMINPLUS:\n    case OP_TYPEQUERY:\n    case OP_TYPEMINQUERY:\n    case OP_TYPEUPTO:\n    case OP_TYPEMINUPTO:\n    case OP_TYPEEXACT:\n    case OP_TYPEPOSSTAR:\n    case OP_TYPEPOSPLUS:\n    case OP_TYPEPOSQUERY:\n    case OP_TYPEPOSUPTO:\n    cc = compile_iterator_matchingpath(common, cc, parent);\n    break;\n\n    case OP_CLASS:\n    case OP_NCLASS:\n    if (cc\u00dd1 + (32 / sizeof(PCRE2_UCHAR))\u00a8 >= OP_CRSTAR && cc\u00dd1 + (32 / sizeof(PCRE2_UCHAR))\u00a8 <= OP_CRPOSRANGE)\n      cc = compile_iterator_matchingpath(common, cc, parent);\n    else\n      cc = compile_char1_matchingpath(common, *cc, cc + 1, parent->top != NULL ? &parent->top->nextbacktracks : &parent->topbacktracks, TRUE);\n    break;\n\n#if defined SUPPORT_UNICODE || PCRE2_CODE_UNIT_WIDTH == 16 || PCRE2_CODE_UNIT_WIDTH == 32\n    case OP_XCLASS:\n    if (*(cc + GET(cc, 1)) >= OP_CRSTAR && *(cc + GET(cc, 1)) <= OP_CRPOSRANGE)\n      cc = compile_iterator_matchingpath(common, cc, parent);\n    else\n      cc = compile_char1_matchingpath(common, *cc, cc + 1, parent->top != NULL ? &parent->top->nextbacktracks : &parent->topbacktracks, TRUE);\n    break;\n#endif\n\n    case OP_REF:\n    case OP_REFI:\n    if (cc\u00dd1 + IMM2_SIZE\u00a8 >= OP_CRSTAR && cc\u00dd1 + IMM2_SIZE\u00a8 <= OP_CRPOSRANGE)\n      cc = compile_ref_iterator_matchingpath(common, cc, parent);\n    else\n      {\n      compile_ref_matchingpath(common, cc, parent->top != NULL ? &parent->top->nextbacktracks : &parent->topbacktracks, TRUE, FALSE);\n      cc += 1 + IMM2_SIZE;\n      }\n    break;\n\n    case OP_DNREF:\n    case OP_DNREFI:\n    if (cc\u00dd1 + 2 * IMM2_SIZE\u00a8 >= OP_CRSTAR && cc\u00dd1 + 2 * IMM2_SIZE\u00a8 <= OP_CRPOSRANGE)\n      cc = compile_ref_iterator_matchingpath(common, cc, parent);\n    else\n      {\n      compile_dnref_search(common, cc, parent->top != NULL ? &parent->top->nextbacktracks : &parent->topbacktracks);\n      compile_ref_matchingpath(common, cc, parent->top != NULL ? &parent->top->nextbacktracks : &parent->topbacktracks, TRUE, FALSE);\n      cc += 1 + 2 * IMM2_SIZE;\n      }\n    break;\n\n    case OP_RECURSE:\n    cc = compile_recurse_matchingpath(common, cc, parent);\n    break;\n\n    case OP_CALLOUT:\n    case OP_CALLOUT_STR:\n    cc = compile_callout_matchingpath(common, cc, parent);\n    break;\n\n    case OP_ASSERT:\n    case OP_ASSERT_NOT:\n    case OP_ASSERTBACK:\n    case OP_ASSERTBACK_NOT:\n    PUSH_BACKTRACK_NOVALUE(sizeof(assert_backtrack), cc);\n    cc = compile_assert_matchingpath(common, cc, BACKTRACK_AS(assert_backtrack), FALSE);\n    break;\n\n    case OP_BRAMINZERO:\n    PUSH_BACKTRACK_NOVALUE(sizeof(braminzero_backtrack), cc);\n    cc = bracketend(cc + 1);\n    if (*(cc - 1 - LINK_SIZE) != OP_KETRMIN)\n      {\n      allocate_stack(common, 1);\n      OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(0), STR_PTR, 0);\n      }\n    else\n      {\n      allocate_stack(common, 2);\n      OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(0), SLJIT_IMM, 0);\n      OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(1), STR_PTR, 0);\n      }\n    BACKTRACK_AS(braminzero_backtrack)->matchingpath = LABEL();\n    count_match(common);\n    break;\n\n    case OP_ASSERT_NA:\n    case OP_ASSERTBACK_NA:\n    case OP_ONCE:\n    case OP_SCRIPT_RUN:\n    case OP_BRA:\n    case OP_CBRA:\n    case OP_COND:\n    case OP_SBRA:\n    case OP_SCBRA:\n    case OP_SCOND:\n    cc = compile_bracket_matchingpath(common, cc, parent);\n    break;\n\n    case OP_BRAZERO:\n    if (cc\u00dd1\u00a8 > OP_ASSERTBACK_NOT)\n      cc = compile_bracket_matchingpath(common, cc, parent);\n    else\n      {\n      PUSH_BACKTRACK_NOVALUE(sizeof(assert_backtrack), cc);\n      cc = compile_assert_matchingpath(common, cc, BACKTRACK_AS(assert_backtrack), FALSE);\n      }\n    break;\n\n    case OP_BRAPOS:\n    case OP_CBRAPOS:\n    case OP_SBRAPOS:\n    case OP_SCBRAPOS:\n    case OP_BRAPOSZERO:\n    cc = compile_bracketpos_matchingpath(common, cc, parent);\n    break;\n\n    case OP_MARK:\n    PUSH_BACKTRACK_NOVALUE(sizeof(backtrack_common), cc);\n    SLJIT_ASSERT(common->mark_ptr != 0);\n    OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(SLJIT_SP), common->mark_ptr);\n    allocate_stack(common, common->has_skip_arg ? 5 : 1);\n    if (HAS_VIRTUAL_REGISTERS)\n      OP1(SLJIT_MOV, TMP1, 0, ARGUMENTS, 0);\n    OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(common->has_skip_arg ? 4 : 0), TMP2, 0);\n    OP1(SLJIT_MOV, TMP2, 0, SLJIT_IMM, (sljit_sw)(cc + 2));\n    OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), common->mark_ptr, TMP2, 0);\n    OP1(SLJIT_MOV, SLJIT_MEM1(HAS_VIRTUAL_REGISTERS ? TMP1 : ARGUMENTS), SLJIT_OFFSETOF(jit_arguments, mark_ptr), TMP2, 0);\n    if (common->has_skip_arg)\n      {\n      OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(SLJIT_SP), common->control_head_ptr);\n      OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), common->control_head_ptr, STACK_TOP, 0);\n      OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(1), SLJIT_IMM, type_mark);\n      OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(2), SLJIT_IMM, (sljit_sw)(cc + 2));\n      OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(3), STR_PTR, 0);\n      OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(0), TMP1, 0);\n      }\n    cc += 1 + 2 + cc\u00dd1\u00a8;\n    break;\n\n    case OP_PRUNE:\n    case OP_PRUNE_ARG:\n    case OP_SKIP:\n    case OP_SKIP_ARG:\n    case OP_THEN:\n    case OP_THEN_ARG:\n    case OP_COMMIT:\n    case OP_COMMIT_ARG:\n    cc = compile_control_verb_matchingpath(common, cc, parent);\n    break;\n\n    case OP_FAIL:\n    case OP_ACCEPT:\n    case OP_ASSERT_ACCEPT:\n    cc = compile_fail_accept_matchingpath(common, cc, parent);\n    break;\n\n    case OP_CLOSE:\n    cc = compile_close_matchingpath(common, cc);\n    break;\n\n    case OP_SKIPZERO:\n    cc = bracketend(cc + 1);\n    break;\n\n    default:\n    SLJIT_UNREACHABLE();\n    return;\n    }\n  if (cc == NULL)\n    return;\n  }\n\nif (has_then_trap)\n  {\n  /* Head item on backtrack. */\n  PUSH_BACKTRACK_NOVALUE(sizeof(then_trap_backtrack), cc);\n  BACKTRACK_AS(then_trap_backtrack)->common.cc = then_trap_opcode;\n  BACKTRACK_AS(then_trap_backtrack)->then_trap = common->then_trap;\n  common->then_trap = save_then_trap;\n  }\nSLJIT_ASSERT(cc == ccend);\n}\n\n#undef PUSH_BACKTRACK\n#undef PUSH_BACKTRACK_NOVALUE\n#undef BACKTRACK_AS\n\n#define COMPILE_BACKTRACKINGPATH(current) \\\n  do \\\n    { \\\n    compile_backtrackingpath(common, (current)); \\\n    if (SLJIT_UNLIKELY(sljit_get_compiler_error(compiler))) \\\n      return; \\\n    } \\\n  while (0)\n\n#define CURRENT_AS(type) ((type *)current)\n\nstatic void compile_iterator_backtrackingpath(compiler_common *common, struct backtrack_common *current)\n{\nDEFINE_COMPILER;\nPCRE2_SPTR cc = current->cc;\nPCRE2_UCHAR opcode;\nPCRE2_UCHAR type;\nsljit_u32 max = 0, exact;\nstruct sljit_label *label = NULL;\nstruct sljit_jump *jump = NULL;\njump_list *jumplist = NULL;\nPCRE2_SPTR end;\nint private_data_ptr = PRIVATE_DATA(cc);\nint base = (private_data_ptr == 0) ? SLJIT_MEM1(STACK_TOP) : SLJIT_MEM1(SLJIT_SP);\nint offset0 = (private_data_ptr == 0) ? STACK(0) : private_data_ptr;\nint offset1 = (private_data_ptr == 0) ? STACK(1) : private_data_ptr + (int)sizeof(sljit_sw);\n\ncc = get_iterator_parameters(common, cc, &opcode, &type, &max, &exact, &end);\n\nswitch(opcode)\n  {\n  case OP_STAR:\n  case OP_UPTO:\n  if (type == OP_ANYNL || type == OP_EXTUNI)\n    {\n    SLJIT_ASSERT(private_data_ptr == 0);\n    set_jumps(CURRENT_AS(char_iterator_backtrack)->u.backtracks, LABEL());\n    OP1(SLJIT_MOV, STR_PTR, 0, SLJIT_MEM1(STACK_TOP), STACK(0));\n    free_stack(common, 1);\n    CMPTO(SLJIT_NOT_EQUAL, STR_PTR, 0, SLJIT_IMM, 0, CURRENT_AS(char_iterator_backtrack)->matchingpath);\n    }\n  else\n    {\n    if (CURRENT_AS(char_iterator_backtrack)->u.charpos.enabled)\n      {\n      OP1(SLJIT_MOV, STR_PTR, 0, base, offset0);\n      OP1(SLJIT_MOV, TMP2, 0, base, offset1);\n      OP2(SLJIT_SUB, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n\n      jump = CMP(SLJIT_LESS_EQUAL, STR_PTR, 0, TMP2, 0);\n      label = LABEL();\n      OP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(-1));\n      OP1(SLJIT_MOV, base, offset0, STR_PTR, 0);\n      if (CURRENT_AS(char_iterator_backtrack)->u.charpos.othercasebit != 0)\n        OP2(SLJIT_OR, TMP1, 0, TMP1, 0, SLJIT_IMM, CURRENT_AS(char_iterator_backtrack)->u.charpos.othercasebit);\n      CMPTO(SLJIT_EQUAL, TMP1, 0, SLJIT_IMM, CURRENT_AS(char_iterator_backtrack)->u.charpos.chr, CURRENT_AS(char_iterator_backtrack)->matchingpath);\n      move_back(common, NULL, TRUE);\n      CMPTO(SLJIT_GREATER, STR_PTR, 0, TMP2, 0, label);\n      }\n    else\n      {\n      OP1(SLJIT_MOV, STR_PTR, 0, base, offset0);\n      jump = CMP(SLJIT_LESS_EQUAL, STR_PTR, 0, base, offset1);\n      move_back(common, NULL, TRUE);\n      OP1(SLJIT_MOV, base, offset0, STR_PTR, 0);\n      JUMPTO(SLJIT_JUMP, CURRENT_AS(char_iterator_backtrack)->matchingpath);\n      }\n    JUMPHERE(jump);\n    if (private_data_ptr == 0)\n      free_stack(common, 2);\n    }\n  break;\n\n  case OP_MINSTAR:\n  OP1(SLJIT_MOV, STR_PTR, 0, base, offset0);\n  compile_char1_matchingpath(common, type, cc, &jumplist, TRUE);\n  OP1(SLJIT_MOV, base, offset0, STR_PTR, 0);\n  JUMPTO(SLJIT_JUMP, CURRENT_AS(char_iterator_backtrack)->matchingpath);\n  set_jumps(jumplist, LABEL());\n  if (private_data_ptr == 0)\n    free_stack(common, 1);\n  break;\n\n  case OP_MINUPTO:\n  OP1(SLJIT_MOV, TMP1, 0, base, offset1);\n  OP1(SLJIT_MOV, STR_PTR, 0, base, offset0);\n  OP2(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, TMP1, 0, SLJIT_IMM, 1);\n  add_jump(compiler, &jumplist, JUMP(SLJIT_ZERO));\n\n  OP1(SLJIT_MOV, base, offset1, TMP1, 0);\n  compile_char1_matchingpath(common, type, cc, &jumplist, TRUE);\n  OP1(SLJIT_MOV, base, offset0, STR_PTR, 0);\n  JUMPTO(SLJIT_JUMP, CURRENT_AS(char_iterator_backtrack)->matchingpath);\n\n  set_jumps(jumplist, LABEL());\n  if (private_data_ptr == 0)\n    free_stack(common, 2);\n  break;\n\n  case OP_QUERY:\n  OP1(SLJIT_MOV, STR_PTR, 0, base, offset0);\n  OP1(SLJIT_MOV, base, offset0, SLJIT_IMM, 0);\n  CMPTO(SLJIT_NOT_EQUAL, STR_PTR, 0, SLJIT_IMM, 0, CURRENT_AS(char_iterator_backtrack)->matchingpath);\n  jump = JUMP(SLJIT_JUMP);\n  set_jumps(CURRENT_AS(char_iterator_backtrack)->u.backtracks, LABEL());\n  OP1(SLJIT_MOV, STR_PTR, 0, base, offset0);\n  OP1(SLJIT_MOV, base, offset0, SLJIT_IMM, 0);\n  JUMPTO(SLJIT_JUMP, CURRENT_AS(char_iterator_backtrack)->matchingpath);\n  JUMPHERE(jump);\n  if (private_data_ptr == 0)\n    free_stack(common, 1);\n  break;\n\n  case OP_MINQUERY:\n  OP1(SLJIT_MOV, STR_PTR, 0, base, offset0);\n  OP1(SLJIT_MOV, base, offset0, SLJIT_IMM, 0);\n  jump = CMP(SLJIT_EQUAL, STR_PTR, 0, SLJIT_IMM, 0);\n  compile_char1_matchingpath(common, type, cc, &jumplist, TRUE);\n  JUMPTO(SLJIT_JUMP, CURRENT_AS(char_iterator_backtrack)->matchingpath);\n  set_jumps(jumplist, LABEL());\n  JUMPHERE(jump);\n  if (private_data_ptr == 0)\n    free_stack(common, 1);\n  break;\n\n  case OP_EXACT:\n  case OP_POSSTAR:\n  case OP_POSQUERY:\n  case OP_POSUPTO:\n  break;\n\n  default:\n  SLJIT_UNREACHABLE();\n  break;\n  }\n\nset_jumps(current->topbacktracks, LABEL());\n}\n\nstatic SLJIT_INLINE void compile_ref_iterator_backtrackingpath(compiler_common *common, struct backtrack_common *current)\n{\nDEFINE_COMPILER;\nPCRE2_SPTR cc = current->cc;\nBOOL ref = (*cc == OP_REF || *cc == OP_REFI);\nPCRE2_UCHAR type;\n\ntype = cc\u00ddref ? 1 + IMM2_SIZE : 1 + 2 * IMM2_SIZE\u00a8;\n\nif ((type & 0x1) == 0)\n  {\n  /* Maximize case. */\n  set_jumps(current->topbacktracks, LABEL());\n  OP1(SLJIT_MOV, STR_PTR, 0, SLJIT_MEM1(STACK_TOP), STACK(0));\n  free_stack(common, 1);\n  CMPTO(SLJIT_NOT_EQUAL, STR_PTR, 0, SLJIT_IMM, 0, CURRENT_AS(ref_iterator_backtrack)->matchingpath);\n  return;\n  }\n\nOP1(SLJIT_MOV, STR_PTR, 0, SLJIT_MEM1(STACK_TOP), STACK(0));\nCMPTO(SLJIT_NOT_EQUAL, STR_PTR, 0, SLJIT_IMM, 0, CURRENT_AS(ref_iterator_backtrack)->matchingpath);\nset_jumps(current->topbacktracks, LABEL());\nfree_stack(common, ref ? 2 : 3);\n}\n\nstatic SLJIT_INLINE void compile_recurse_backtrackingpath(compiler_common *common, struct backtrack_common *current)\n{\nDEFINE_COMPILER;\nrecurse_entry *entry;\n\nif (!CURRENT_AS(recurse_backtrack)->inlined_pattern)\n  {\n  entry = CURRENT_AS(recurse_backtrack)->entry;\n  if (entry->backtrack_label == NULL)\n    add_jump(compiler, &entry->backtrack_calls, JUMP(SLJIT_FAST_CALL));\n  else\n    JUMPTO(SLJIT_FAST_CALL, entry->backtrack_label);\n  CMPTO(SLJIT_NOT_EQUAL, TMP1, 0, SLJIT_IMM, 0, CURRENT_AS(recurse_backtrack)->matchingpath);\n  }\nelse\n  compile_backtrackingpath(common, current->top);\n\nset_jumps(current->topbacktracks, LABEL());\n}\n\nstatic void compile_assert_backtrackingpath(compiler_common *common, struct backtrack_common *current)\n{\nDEFINE_COMPILER;\nPCRE2_SPTR cc = current->cc;\nPCRE2_UCHAR bra = OP_BRA;\nstruct sljit_jump *brajump = NULL;\n\nSLJIT_ASSERT(*cc != OP_BRAMINZERO);\nif (*cc == OP_BRAZERO)\n  {\n  bra = *cc;\n  cc++;\n  }\n\nif (bra == OP_BRAZERO)\n  {\n  SLJIT_ASSERT(current->topbacktracks == NULL);\n  OP1(SLJIT_MOV, STR_PTR, 0, SLJIT_MEM1(STACK_TOP), STACK(0));\n  }\n\nif (CURRENT_AS(assert_backtrack)->framesize < 0)\n  {\n  set_jumps(current->topbacktracks, LABEL());\n\n  if (bra == OP_BRAZERO)\n    {\n    OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(0), SLJIT_IMM, 0);\n    CMPTO(SLJIT_NOT_EQUAL, STR_PTR, 0, SLJIT_IMM, 0, CURRENT_AS(assert_backtrack)->matchingpath);\n    free_stack(common, 1);\n    }\n  return;\n  }\n\nif (bra == OP_BRAZERO)\n  {\n  if (*cc == OP_ASSERT_NOT || *cc == OP_ASSERTBACK_NOT)\n    {\n    OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(0), SLJIT_IMM, 0);\n    CMPTO(SLJIT_NOT_EQUAL, STR_PTR, 0, SLJIT_IMM, 0, CURRENT_AS(assert_backtrack)->matchingpath);\n    free_stack(common, 1);\n    return;\n    }\n  free_stack(common, 1);\n  brajump = CMP(SLJIT_EQUAL, STR_PTR, 0, SLJIT_IMM, 0);\n  }\n\nif (*cc == OP_ASSERT || *cc == OP_ASSERTBACK)\n  {\n  OP1(SLJIT_MOV, STACK_TOP, 0, SLJIT_MEM1(SLJIT_SP), CURRENT_AS(assert_backtrack)->private_data_ptr);\n  add_jump(compiler, &common->revertframes, JUMP(SLJIT_FAST_CALL));\n  OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(STACK_TOP), STACK(-2));\n  OP2(SLJIT_ADD, STACK_TOP, 0, STACK_TOP, 0, SLJIT_IMM, (CURRENT_AS(assert_backtrack)->framesize - 1) * sizeof(sljit_sw));\n  OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), CURRENT_AS(assert_backtrack)->private_data_ptr, TMP1, 0);\n\n  set_jumps(current->topbacktracks, LABEL());\n  }\nelse\n  set_jumps(current->topbacktracks, LABEL());\n\nif (bra == OP_BRAZERO)\n  {\n  /* We know there is enough place on the stack. */\n  OP2(SLJIT_SUB, STACK_TOP, 0, STACK_TOP, 0, SLJIT_IMM, sizeof(sljit_sw));\n  OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(0), SLJIT_IMM, 0);\n  JUMPTO(SLJIT_JUMP, CURRENT_AS(assert_backtrack)->matchingpath);\n  JUMPHERE(brajump);\n  }\n}\n\nstatic void compile_bracket_backtrackingpath(compiler_common *common, struct backtrack_common *current)\n{\nDEFINE_COMPILER;\nint opcode, stacksize, alt_count, alt_max;\nint offset = 0;\nint private_data_ptr = CURRENT_AS(bracket_backtrack)->private_data_ptr;\nint repeat_ptr = 0, repeat_type = 0, repeat_count = 0;\nPCRE2_SPTR cc = current->cc;\nPCRE2_SPTR ccbegin;\nPCRE2_SPTR ccprev;\nPCRE2_UCHAR bra = OP_BRA;\nPCRE2_UCHAR ket;\nassert_backtrack *assert;\nBOOL has_alternatives;\nBOOL needs_control_head = FALSE;\nstruct sljit_jump *brazero = NULL;\nstruct sljit_jump *next_alt = NULL;\nstruct sljit_jump *once = NULL;\nstruct sljit_jump *cond = NULL;\nstruct sljit_label *rmin_label = NULL;\nstruct sljit_label *exact_label = NULL;\nstruct sljit_put_label *put_label = NULL;\n\nif (*cc == OP_BRAZERO || *cc == OP_BRAMINZERO)\n  {\n  bra = *cc;\n  cc++;\n  }\n\nopcode = *cc;\nccbegin = bracketend(cc) - 1 - LINK_SIZE;\nket = *ccbegin;\nif (ket == OP_KET && PRIVATE_DATA(ccbegin) != 0)\n  {\n  repeat_ptr = PRIVATE_DATA(ccbegin);\n  repeat_type = PRIVATE_DATA(ccbegin + 2);\n  repeat_count = PRIVATE_DATA(ccbegin + 3);\n  SLJIT_ASSERT(repeat_type != 0 && repeat_count != 0);\n  if (repeat_type == OP_UPTO)\n    ket = OP_KETRMAX;\n  if (repeat_type == OP_MINUPTO)\n    ket = OP_KETRMIN;\n  }\nccbegin = cc;\ncc += GET(cc, 1);\nhas_alternatives = *cc == OP_ALT;\nif (SLJIT_UNLIKELY(opcode == OP_COND) || SLJIT_UNLIKELY(opcode == OP_SCOND))\n  has_alternatives = (ccbegin\u00dd1 + LINK_SIZE\u00a8 >= OP_ASSERT && ccbegin\u00dd1 + LINK_SIZE\u00a8 <= OP_ASSERTBACK_NOT) || CURRENT_AS(bracket_backtrack)->u.condfailed != NULL;\nif (opcode == OP_CBRA || opcode == OP_SCBRA)\n  offset = (GET2(ccbegin, 1 + LINK_SIZE)) << 1;\nif (SLJIT_UNLIKELY(opcode == OP_COND) && (*cc == OP_KETRMAX || *cc == OP_KETRMIN))\n  opcode = OP_SCOND;\n\nalt_max = has_alternatives ? no_alternatives(ccbegin) : 0;\n\n/* Decoding the needs_control_head in framesize. */\nif (opcode == OP_ONCE)\n  {\n  needs_control_head = (CURRENT_AS(bracket_backtrack)->u.framesize & 0x1) != 0;\n  CURRENT_AS(bracket_backtrack)->u.framesize >>= 1;\n  }\n\nif (ket != OP_KET && repeat_type != 0)\n  {\n  /* TMP1 is used in OP_KETRMIN below. */\n  OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(STACK_TOP), STACK(0));\n  free_stack(common, 1);\n  if (repeat_type == OP_UPTO)\n    OP2(SLJIT_ADD, SLJIT_MEM1(SLJIT_SP), repeat_ptr, TMP1, 0, SLJIT_IMM, 1);\n  else\n    OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), repeat_ptr, TMP1, 0);\n  }\n\nif (ket == OP_KETRMAX)\n  {\n  if (bra == OP_BRAZERO)\n    {\n    OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(STACK_TOP), STACK(0));\n    free_stack(common, 1);\n    brazero = CMP(SLJIT_EQUAL, TMP1, 0, SLJIT_IMM, 0);\n    }\n  }\nelse if (ket == OP_KETRMIN)\n  {\n  if (bra != OP_BRAMINZERO)\n    {\n    OP1(SLJIT_MOV, STR_PTR, 0, SLJIT_MEM1(STACK_TOP), STACK(0));\n    if (repeat_type != 0)\n      {\n      /* TMP1 was set a few lines above. */\n      CMPTO(SLJIT_NOT_EQUAL, TMP1, 0, SLJIT_IMM, 0, CURRENT_AS(bracket_backtrack)->recursive_matchingpath);\n      /* Drop STR_PTR for non-greedy plus quantifier. */\n      if (opcode != OP_ONCE)\n        free_stack(common, 1);\n      }\n    else if (opcode >= OP_SBRA || opcode == OP_ONCE)\n      {\n      /* Checking zero-length iteration. */\n      if (opcode != OP_ONCE || CURRENT_AS(bracket_backtrack)->u.framesize < 0)\n        CMPTO(SLJIT_NOT_EQUAL, STR_PTR, 0, SLJIT_MEM1(SLJIT_SP), private_data_ptr, CURRENT_AS(bracket_backtrack)->recursive_matchingpath);\n      else\n        {\n        OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(SLJIT_SP), private_data_ptr);\n        CMPTO(SLJIT_NOT_EQUAL, STR_PTR, 0, SLJIT_MEM1(TMP1), STACK(-CURRENT_AS(bracket_backtrack)->u.framesize - 2), CURRENT_AS(bracket_backtrack)->recursive_matchingpath);\n        }\n      /* Drop STR_PTR for non-greedy plus quantifier. */\n      if (opcode != OP_ONCE)\n        free_stack(common, 1);\n      }\n    else\n      JUMPTO(SLJIT_JUMP, CURRENT_AS(bracket_backtrack)->recursive_matchingpath);\n    }\n  rmin_label = LABEL();\n  if (repeat_type != 0)\n    OP2(SLJIT_ADD, SLJIT_MEM1(SLJIT_SP), repeat_ptr, SLJIT_MEM1(SLJIT_SP), repeat_ptr, SLJIT_IMM, 1);\n  }\nelse if (bra == OP_BRAZERO)\n  {\n  OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(STACK_TOP), STACK(0));\n  free_stack(common, 1);\n  brazero = CMP(SLJIT_NOT_EQUAL, TMP1, 0, SLJIT_IMM, 0);\n  }\nelse if (repeat_type == OP_EXACT)\n  {\n  OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), repeat_ptr, SLJIT_IMM, 1);\n  exact_label = LABEL();\n  }\n\nif (offset != 0)\n  {\n  if (common->capture_last_ptr != 0)\n    {\n    SLJIT_ASSERT(common->optimized_cbracket\u00ddoffset >> 1\u00a8 == 0);\n    OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(STACK_TOP), STACK(0));\n    OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(STACK_TOP), STACK(1));\n    OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), common->capture_last_ptr, TMP1, 0);\n    OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(STACK_TOP), STACK(2));\n    free_stack(common, 3);\n    OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), OVECTOR(offset), TMP2, 0);\n    OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), OVECTOR(offset + 1), TMP1, 0);\n    }\n  else if (common->optimized_cbracket\u00ddoffset >> 1\u00a8 == 0)\n    {\n    OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(STACK_TOP), STACK(0));\n    OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(STACK_TOP), STACK(1));\n    free_stack(common, 2);\n    OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), OVECTOR(offset), TMP1, 0);\n    OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), OVECTOR(offset + 1), TMP2, 0);\n    }\n  }\n\nif (SLJIT_UNLIKELY(opcode == OP_ONCE))\n  {\n  if (CURRENT_AS(bracket_backtrack)->u.framesize >= 0)\n    {\n    OP1(SLJIT_MOV, STACK_TOP, 0, SLJIT_MEM1(SLJIT_SP), private_data_ptr);\n    add_jump(compiler, &common->revertframes, JUMP(SLJIT_FAST_CALL));\n    OP2(SLJIT_ADD, STACK_TOP, 0, STACK_TOP, 0, SLJIT_IMM, (CURRENT_AS(bracket_backtrack)->u.framesize - 1) * sizeof(sljit_sw));\n    }\n  once = JUMP(SLJIT_JUMP);\n  }\nelse if (SLJIT_UNLIKELY(opcode == OP_COND) || SLJIT_UNLIKELY(opcode == OP_SCOND))\n  {\n  if (has_alternatives)\n    {\n    /* Always exactly one alternative. */\n    OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(STACK_TOP), STACK(0));\n    free_stack(common, 1);\n\n    alt_max = 2;\n    next_alt = CMP(SLJIT_NOT_EQUAL, TMP1, 0, SLJIT_IMM, 0);\n    }\n  }\nelse if (has_alternatives)\n  {\n  OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(STACK_TOP), STACK(0));\n  free_stack(common, 1);\n\n  if (alt_max > 3)\n    {\n    sljit_emit_ijump(compiler, SLJIT_JUMP, TMP1, 0);\n\n    SLJIT_ASSERT(CURRENT_AS(bracket_backtrack)->u.matching_put_label);\n    sljit_set_put_label(CURRENT_AS(bracket_backtrack)->u.matching_put_label, LABEL());\n    sljit_emit_op0(compiler, SLJIT_ENDBR);\n    }\n  else\n    next_alt = CMP(SLJIT_NOT_EQUAL, TMP1, 0, SLJIT_IMM, 0);\n  }\n\nCOMPILE_BACKTRACKINGPATH(current->top);\nif (current->topbacktracks)\n  set_jumps(current->topbacktracks, LABEL());\n\nif (SLJIT_UNLIKELY(opcode == OP_COND) || SLJIT_UNLIKELY(opcode == OP_SCOND))\n  {\n  /* Conditional block always has at most one alternative. */\n  if (ccbegin\u00dd1 + LINK_SIZE\u00a8 >= OP_ASSERT && ccbegin\u00dd1 + LINK_SIZE\u00a8 <= OP_ASSERTBACK_NOT)\n    {\n    SLJIT_ASSERT(has_alternatives);\n    assert = CURRENT_AS(bracket_backtrack)->u.assert;\n    if (assert->framesize >= 0 && (ccbegin\u00dd1 + LINK_SIZE\u00a8 == OP_ASSERT || ccbegin\u00dd1 + LINK_SIZE\u00a8 == OP_ASSERTBACK))\n      {\n      OP1(SLJIT_MOV, STACK_TOP, 0, SLJIT_MEM1(SLJIT_SP), assert->private_data_ptr);\n      add_jump(compiler, &common->revertframes, JUMP(SLJIT_FAST_CALL));\n      OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(STACK_TOP), STACK(-2));\n      OP2(SLJIT_ADD, STACK_TOP, 0, STACK_TOP, 0, SLJIT_IMM, (assert->framesize - 1) * sizeof(sljit_sw));\n      OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), assert->private_data_ptr, TMP1, 0);\n      }\n    cond = JUMP(SLJIT_JUMP);\n    set_jumps(CURRENT_AS(bracket_backtrack)->u.assert->condfailed, LABEL());\n    }\n  else if (CURRENT_AS(bracket_backtrack)->u.condfailed != NULL)\n    {\n    SLJIT_ASSERT(has_alternatives);\n    cond = JUMP(SLJIT_JUMP);\n    set_jumps(CURRENT_AS(bracket_backtrack)->u.condfailed, LABEL());\n    }\n  else\n    SLJIT_ASSERT(!has_alternatives);\n  }\n\nif (has_alternatives)\n  {\n  alt_count = 1;\n  do\n    {\n    current->top = NULL;\n    current->topbacktracks = NULL;\n    current->nextbacktracks = NULL;\n    /* Conditional blocks always have an additional alternative, even if it is empty. */\n    if (*cc == OP_ALT)\n      {\n      ccprev = cc + 1 + LINK_SIZE;\n      cc += GET(cc, 1);\n      if (opcode != OP_COND && opcode != OP_SCOND)\n        {\n        if (opcode != OP_ONCE)\n          {\n          if (private_data_ptr != 0)\n            OP1(SLJIT_MOV, STR_PTR, 0, SLJIT_MEM1(SLJIT_SP), private_data_ptr);\n          else\n            OP1(SLJIT_MOV, STR_PTR, 0, SLJIT_MEM1(STACK_TOP), STACK(0));\n          }\n        else\n          OP1(SLJIT_MOV, STR_PTR, 0, SLJIT_MEM1(STACK_TOP), STACK(needs_control_head ? 1 : 0));\n        }\n      compile_matchingpath(common, ccprev, cc, current);\n      if (SLJIT_UNLIKELY(sljit_get_compiler_error(compiler)))\n        return;\n\n      if (opcode == OP_ASSERT_NA || opcode == OP_ASSERTBACK_NA)\n        OP1(SLJIT_MOV, STR_PTR, 0, SLJIT_MEM1(SLJIT_SP), private_data_ptr);\n\n      if (opcode == OP_SCRIPT_RUN)\n        match_script_run_common(common, private_data_ptr, current);\n      }\n\n    /* Instructions after the current alternative is successfully matched. */\n    /* There is a similar code in compile_bracket_matchingpath. */\n    if (opcode == OP_ONCE)\n      match_once_common(common, ket, CURRENT_AS(bracket_backtrack)->u.framesize, private_data_ptr, has_alternatives, needs_control_head);\n\n    stacksize = 0;\n    if (repeat_type == OP_MINUPTO)\n      {\n      /* We need to preserve the counter. TMP2 will be used below. */\n      OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(SLJIT_SP), repeat_ptr);\n      stacksize++;\n      }\n    if (ket != OP_KET || bra != OP_BRA)\n      stacksize++;\n    if (offset != 0)\n      {\n      if (common->capture_last_ptr != 0)\n        stacksize++;\n      if (common->optimized_cbracket\u00ddoffset >> 1\u00a8 == 0)\n        stacksize += 2;\n      }\n    if (opcode != OP_ONCE)\n      stacksize++;\n\n    if (stacksize > 0)\n      allocate_stack(common, stacksize);\n\n    stacksize = 0;\n    if (repeat_type == OP_MINUPTO)\n      {\n      /* TMP2 was set above. */\n      OP2(SLJIT_SUB, SLJIT_MEM1(STACK_TOP), STACK(stacksize), TMP2, 0, SLJIT_IMM, 1);\n      stacksize++;\n      }\n\n    if (ket != OP_KET || bra != OP_BRA)\n      {\n      if (ket != OP_KET)\n        OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(stacksize), STR_PTR, 0);\n      else\n        OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(stacksize), SLJIT_IMM, 0);\n      stacksize++;\n      }\n\n    if (offset != 0)\n      stacksize = match_capture_common(common, stacksize, offset, private_data_ptr);\n\n    if (opcode != OP_ONCE)\n      {\n      if (alt_max <= 3)\n        OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(stacksize), SLJIT_IMM, alt_count);\n      else\n        put_label = sljit_emit_put_label(compiler, SLJIT_MEM1(STACK_TOP), STACK(stacksize));\n      }\n\n    if (offset != 0 && ket == OP_KETRMAX && common->optimized_cbracket\u00ddoffset >> 1\u00a8 != 0)\n      {\n      /* If ket is not OP_KETRMAX, this code path is executed after the jump to alternative_matchingpath. */\n      SLJIT_ASSERT(private_data_ptr == OVECTOR(offset + 0));\n      OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), OVECTOR(offset + 1), STR_PTR, 0);\n      }\n\n    JUMPTO(SLJIT_JUMP, CURRENT_AS(bracket_backtrack)->alternative_matchingpath);\n\n    if (opcode != OP_ONCE)\n      {\n      if (alt_max <= 3)\n        {\n        JUMPHERE(next_alt);\n        alt_count++;\n        if (alt_count < alt_max)\n          {\n          SLJIT_ASSERT(alt_count == 2 && alt_max == 3);\n          next_alt = CMP(SLJIT_NOT_EQUAL, TMP1, 0, SLJIT_IMM, 1);\n          }\n        }\n      else\n        {\n        sljit_set_put_label(put_label, LABEL());\n        sljit_emit_op0(compiler, SLJIT_ENDBR);\n        }\n      }\n\n    COMPILE_BACKTRACKINGPATH(current->top);\n    if (current->topbacktracks)\n      set_jumps(current->topbacktracks, LABEL());\n    SLJIT_ASSERT(!current->nextbacktracks);\n    }\n  while (*cc == OP_ALT);\n\n  if (cond != NULL)\n    {\n    SLJIT_ASSERT(opcode == OP_COND || opcode == OP_SCOND);\n    assert = CURRENT_AS(bracket_backtrack)->u.assert;\n    if ((ccbegin\u00dd1 + LINK_SIZE\u00a8 == OP_ASSERT_NOT || ccbegin\u00dd1 + LINK_SIZE\u00a8 == OP_ASSERTBACK_NOT) && assert->framesize >= 0)\n      {\n      OP1(SLJIT_MOV, STACK_TOP, 0, SLJIT_MEM1(SLJIT_SP), assert->private_data_ptr);\n      add_jump(compiler, &common->revertframes, JUMP(SLJIT_FAST_CALL));\n      OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(STACK_TOP), STACK(-2));\n      OP2(SLJIT_ADD, STACK_TOP, 0, STACK_TOP, 0, SLJIT_IMM, (assert->framesize - 1) * sizeof(sljit_sw));\n      OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), assert->private_data_ptr, TMP1, 0);\n      }\n    JUMPHERE(cond);\n    }\n\n  /* Free the STR_PTR. */\n  if (private_data_ptr == 0)\n    free_stack(common, 1);\n  }\n\nif (offset != 0)\n  {\n  /* Using both tmp register is better for instruction scheduling. */\n  if (common->optimized_cbracket\u00ddoffset >> 1\u00a8 != 0)\n    {\n    OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(STACK_TOP), STACK(0));\n    OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(STACK_TOP), STACK(1));\n    free_stack(common, 2);\n    OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), OVECTOR(offset), TMP1, 0);\n    OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), OVECTOR(offset + 1), TMP2, 0);\n    }\n  else\n    {\n    OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(STACK_TOP), STACK(0));\n    free_stack(common, 1);\n    OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), private_data_ptr, TMP1, 0);\n    }\n  }\nelse if (opcode == OP_ASSERT_NA || opcode == OP_ASSERTBACK_NA || opcode == OP_SCRIPT_RUN || opcode == OP_SBRA || opcode == OP_SCOND)\n  {\n  OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), private_data_ptr, SLJIT_MEM1(STACK_TOP), STACK(0));\n  free_stack(common, 1);\n  }\nelse if (opcode == OP_ONCE)\n  {\n  cc = ccbegin + GET(ccbegin, 1);\n  stacksize = needs_control_head ? 1 : 0;\n\n  if (CURRENT_AS(bracket_backtrack)->u.framesize >= 0)\n    {\n    /* Reset head and drop saved frame. */\n    stacksize += CURRENT_AS(bracket_backtrack)->u.framesize + ((ket != OP_KET || *cc == OP_ALT) ? 2 : 1);\n    }\n  else if (ket == OP_KETRMAX || (*cc == OP_ALT && ket != OP_KETRMIN))\n    {\n    /* The STR_PTR must be released. */\n    stacksize++;\n    }\n\n  if (stacksize > 0)\n    free_stack(common, stacksize);\n\n  JUMPHERE(once);\n  /* Restore previous private_data_ptr */\n  if (CURRENT_AS(bracket_backtrack)->u.framesize >= 0)\n    OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), private_data_ptr, SLJIT_MEM1(STACK_TOP), STACK(-CURRENT_AS(bracket_backtrack)->u.framesize - 1));\n  else if (ket == OP_KETRMIN)\n    {\n    OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(STACK_TOP), STACK(1));\n    /* See the comment below. */\n    free_stack(common, 2);\n    OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), private_data_ptr, TMP1, 0);\n    }\n  }\n\nif (repeat_type == OP_EXACT)\n  {\n  OP2(SLJIT_ADD, TMP1, 0, SLJIT_MEM1(SLJIT_SP), repeat_ptr, SLJIT_IMM, 1);\n  OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), repeat_ptr, TMP1, 0);\n  CMPTO(SLJIT_LESS_EQUAL, TMP1, 0, SLJIT_IMM, repeat_count, exact_label);\n  }\nelse if (ket == OP_KETRMAX)\n  {\n  OP1(SLJIT_MOV, STR_PTR, 0, SLJIT_MEM1(STACK_TOP), STACK(0));\n  if (bra != OP_BRAZERO)\n    free_stack(common, 1);\n\n  CMPTO(SLJIT_NOT_EQUAL, STR_PTR, 0, SLJIT_IMM, 0, CURRENT_AS(bracket_backtrack)->recursive_matchingpath);\n  if (bra == OP_BRAZERO)\n    {\n    OP1(SLJIT_MOV, STR_PTR, 0, SLJIT_MEM1(STACK_TOP), STACK(1));\n    JUMPTO(SLJIT_JUMP, CURRENT_AS(bracket_backtrack)->zero_matchingpath);\n    JUMPHERE(brazero);\n    free_stack(common, 1);\n    }\n  }\nelse if (ket == OP_KETRMIN)\n  {\n  OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(STACK_TOP), STACK(0));\n\n  /* OP_ONCE removes everything in case of a backtrack, so we don't\n  need to explicitly release the STR_PTR. The extra release would\n  affect badly the free_stack(2) above. */\n  if (opcode != OP_ONCE)\n    free_stack(common, 1);\n  CMPTO(SLJIT_NOT_EQUAL, TMP1, 0, SLJIT_IMM, 0, rmin_label);\n  if (opcode == OP_ONCE)\n    free_stack(common, bra == OP_BRAMINZERO ? 2 : 1);\n  else if (bra == OP_BRAMINZERO)\n    free_stack(common, 1);\n  }\nelse if (bra == OP_BRAZERO)\n  {\n  OP1(SLJIT_MOV, STR_PTR, 0, SLJIT_MEM1(STACK_TOP), STACK(0));\n  JUMPTO(SLJIT_JUMP, CURRENT_AS(bracket_backtrack)->zero_matchingpath);\n  JUMPHERE(brazero);\n  }\n}\n\nstatic SLJIT_INLINE void compile_bracketpos_backtrackingpath(compiler_common *common, struct backtrack_common *current)\n{\nDEFINE_COMPILER;\nint offset;\nstruct sljit_jump *jump;\n\nif (CURRENT_AS(bracketpos_backtrack)->framesize < 0)\n  {\n  if (*current->cc == OP_CBRAPOS || *current->cc == OP_SCBRAPOS)\n    {\n    offset = (GET2(current->cc, 1 + LINK_SIZE)) << 1;\n    OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(STACK_TOP), STACK(0));\n    OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(STACK_TOP), STACK(1));\n    OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), OVECTOR(offset), TMP1, 0);\n    if (common->capture_last_ptr != 0)\n      OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(STACK_TOP), STACK(2));\n    OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), OVECTOR(offset + 1), TMP2, 0);\n    if (common->capture_last_ptr != 0)\n      OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), common->capture_last_ptr, TMP1, 0);\n    }\n  set_jumps(current->topbacktracks, LABEL());\n  free_stack(common, CURRENT_AS(bracketpos_backtrack)->stacksize);\n  return;\n  }\n\nOP1(SLJIT_MOV, STACK_TOP, 0, SLJIT_MEM1(SLJIT_SP), CURRENT_AS(bracketpos_backtrack)->private_data_ptr);\nadd_jump(compiler, &common->revertframes, JUMP(SLJIT_FAST_CALL));\nOP2(SLJIT_ADD, STACK_TOP, 0, STACK_TOP, 0, SLJIT_IMM, (CURRENT_AS(bracketpos_backtrack)->framesize - 1) * sizeof(sljit_sw));\n\nif (current->topbacktracks)\n  {\n  jump = JUMP(SLJIT_JUMP);\n  set_jumps(current->topbacktracks, LABEL());\n  /* Drop the stack frame. */\n  free_stack(common, CURRENT_AS(bracketpos_backtrack)->stacksize);\n  JUMPHERE(jump);\n  }\nOP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), CURRENT_AS(bracketpos_backtrack)->private_data_ptr, SLJIT_MEM1(STACK_TOP), STACK(-CURRENT_AS(bracketpos_backtrack)->framesize - 1));\n}\n\nstatic SLJIT_INLINE void compile_braminzero_backtrackingpath(compiler_common *common, struct backtrack_common *current)\n{\nassert_backtrack backtrack;\n\ncurrent->top = NULL;\ncurrent->topbacktracks = NULL;\ncurrent->nextbacktracks = NULL;\nif (current->cc\u00dd1\u00a8 > OP_ASSERTBACK_NOT)\n  {\n  /* Manual call of compile_bracket_matchingpath and compile_bracket_backtrackingpath. */\n  compile_bracket_matchingpath(common, current->cc, current);\n  compile_bracket_backtrackingpath(common, current->top);\n  }\nelse\n  {\n  memset(&backtrack, 0, sizeof(backtrack));\n  backtrack.common.cc = current->cc;\n  backtrack.matchingpath = CURRENT_AS(braminzero_backtrack)->matchingpath;\n  /* Manual call of compile_assert_matchingpath. */\n  compile_assert_matchingpath(common, current->cc, &backtrack, FALSE);\n  }\nSLJIT_ASSERT(!current->nextbacktracks && !current->topbacktracks);\n}\n\nstatic SLJIT_INLINE void compile_control_verb_backtrackingpath(compiler_common *common, struct backtrack_common *current)\n{\nDEFINE_COMPILER;\nPCRE2_UCHAR opcode = *current->cc;\nstruct sljit_label *loop;\nstruct sljit_jump *jump;\n\nif (opcode == OP_THEN || opcode == OP_THEN_ARG)\n  {\n  if (common->then_trap != NULL)\n    {\n    SLJIT_ASSERT(common->control_head_ptr != 0);\n\n    OP1(SLJIT_MOV, STACK_TOP, 0, SLJIT_MEM1(SLJIT_SP), common->control_head_ptr);\n    OP1(SLJIT_MOV, TMP1, 0, SLJIT_IMM, type_then_trap);\n    OP1(SLJIT_MOV, TMP2, 0, SLJIT_IMM, common->then_trap->start);\n    jump = JUMP(SLJIT_JUMP);\n\n    loop = LABEL();\n    OP1(SLJIT_MOV, STACK_TOP, 0, SLJIT_MEM1(STACK_TOP), STACK(0));\n    JUMPHERE(jump);\n    CMPTO(SLJIT_NOT_EQUAL, SLJIT_MEM1(STACK_TOP), STACK(1), TMP1, 0, loop);\n    CMPTO(SLJIT_NOT_EQUAL, SLJIT_MEM1(STACK_TOP), STACK(2), TMP2, 0, loop);\n    add_jump(compiler, &common->then_trap->quit, JUMP(SLJIT_JUMP));\n    return;\n    }\n  else if (!common->local_quit_available && common->in_positive_assertion)\n    {\n    add_jump(compiler, &common->positive_assertion_quit, JUMP(SLJIT_JUMP));\n    return;\n    }\n  }\n\nif (common->local_quit_available)\n  {\n  /* Abort match with a fail. */\n  if (common->quit_label == NULL)\n    add_jump(compiler, &common->quit, JUMP(SLJIT_JUMP));\n  else\n    JUMPTO(SLJIT_JUMP, common->quit_label);\n  return;\n  }\n\nif (opcode == OP_SKIP_ARG)\n  {\n  SLJIT_ASSERT(common->control_head_ptr != 0 && TMP1 == SLJIT_R0 && STR_PTR == SLJIT_R1);\n  OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(SLJIT_SP), common->control_head_ptr);\n  OP1(SLJIT_MOV, SLJIT_R1, 0, SLJIT_IMM, (sljit_sw)(current->cc + 2));\n  sljit_emit_icall(compiler, SLJIT_CALL, SLJIT_RET(SW) | SLJIT_ARG1(SW) | SLJIT_ARG2(SW), SLJIT_IMM, SLJIT_FUNC_OFFSET(do_search_mark));\n\n  OP1(SLJIT_MOV, STR_PTR, 0, SLJIT_R0, 0);\n  add_jump(compiler, &common->reset_match, CMP(SLJIT_NOT_EQUAL, SLJIT_R0, 0, SLJIT_IMM, 0));\n  return;\n  }\n\nif (opcode == OP_SKIP)\n  OP1(SLJIT_MOV, STR_PTR, 0, SLJIT_MEM1(STACK_TOP), STACK(0));\nelse\n  OP1(SLJIT_MOV, STR_PTR, 0, SLJIT_IMM, 0);\nadd_jump(compiler, &common->reset_match, JUMP(SLJIT_JUMP));\n}\n\nstatic SLJIT_INLINE void compile_then_trap_backtrackingpath(compiler_common *common, struct backtrack_common *current)\n{\nDEFINE_COMPILER;\nstruct sljit_jump *jump;\nint size;\n\nif (CURRENT_AS(then_trap_backtrack)->then_trap)\n  {\n  common->then_trap = CURRENT_AS(then_trap_backtrack)->then_trap;\n  return;\n  }\n\nsize = CURRENT_AS(then_trap_backtrack)->framesize;\nsize = 3 + (size < 0 ? 0 : size);\n\nOP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(STACK_TOP), STACK(size - 3));\nfree_stack(common, size);\njump = JUMP(SLJIT_JUMP);\n\nset_jumps(CURRENT_AS(then_trap_backtrack)->quit, LABEL());\n/* STACK_TOP is set by THEN. */\nif (CURRENT_AS(then_trap_backtrack)->framesize >= 0)\n  {\n  add_jump(compiler, &common->revertframes, JUMP(SLJIT_FAST_CALL));\n  OP2(SLJIT_ADD, STACK_TOP, 0, STACK_TOP, 0, SLJIT_IMM, (CURRENT_AS(then_trap_backtrack)->framesize - 1) * sizeof(sljit_sw));\n  }\nOP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(STACK_TOP), STACK(0));\nfree_stack(common, 3);\n\nJUMPHERE(jump);\nOP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), common->control_head_ptr, TMP1, 0);\n}\n\nstatic void compile_backtrackingpath(compiler_common *common, struct backtrack_common *current)\n{\nDEFINE_COMPILER;\nthen_trap_backtrack *save_then_trap = common->then_trap;\n\nwhile (current)\n  {\n  if (current->nextbacktracks != NULL)\n    set_jumps(current->nextbacktracks, LABEL());\n  switch(*current->cc)\n    {\n    case OP_SET_SOM:\n    OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(STACK_TOP), STACK(0));\n    free_stack(common, 1);\n    OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), OVECTOR(0), TMP1, 0);\n    break;\n\n    case OP_STAR:\n    case OP_MINSTAR:\n    case OP_PLUS:\n    case OP_MINPLUS:\n    case OP_QUERY:\n    case OP_MINQUERY:\n    case OP_UPTO:\n    case OP_MINUPTO:\n    case OP_EXACT:\n    case OP_POSSTAR:\n    case OP_POSPLUS:\n    case OP_POSQUERY:\n    case OP_POSUPTO:\n    case OP_STARI:\n    case OP_MINSTARI:\n    case OP_PLUSI:\n    case OP_MINPLUSI:\n    case OP_QUERYI:\n    case OP_MINQUERYI:\n    case OP_UPTOI:\n    case OP_MINUPTOI:\n    case OP_EXACTI:\n    case OP_POSSTARI:\n    case OP_POSPLUSI:\n    case OP_POSQUERYI:\n    case OP_POSUPTOI:\n    case OP_NOTSTAR:\n    case OP_NOTMINSTAR:\n    case OP_NOTPLUS:\n    case OP_NOTMINPLUS:\n    case OP_NOTQUERY:\n    case OP_NOTMINQUERY:\n    case OP_NOTUPTO:\n    case OP_NOTMINUPTO:\n    case OP_NOTEXACT:\n    case OP_NOTPOSSTAR:\n    case OP_NOTPOSPLUS:\n    case OP_NOTPOSQUERY:\n    case OP_NOTPOSUPTO:\n    case OP_NOTSTARI:\n    case OP_NOTMINSTARI:\n    case OP_NOTPLUSI:\n    case OP_NOTMINPLUSI:\n    case OP_NOTQUERYI:\n    case OP_NOTMINQUERYI:\n    case OP_NOTUPTOI:\n    case OP_NOTMINUPTOI:\n    case OP_NOTEXACTI:\n    case OP_NOTPOSSTARI:\n    case OP_NOTPOSPLUSI:\n    case OP_NOTPOSQUERYI:\n    case OP_NOTPOSUPTOI:\n    case OP_TYPESTAR:\n    case OP_TYPEMINSTAR:\n    case OP_TYPEPLUS:\n    case OP_TYPEMINPLUS:\n    case OP_TYPEQUERY:\n    case OP_TYPEMINQUERY:\n    case OP_TYPEUPTO:\n    case OP_TYPEMINUPTO:\n    case OP_TYPEEXACT:\n    case OP_TYPEPOSSTAR:\n    case OP_TYPEPOSPLUS:\n    case OP_TYPEPOSQUERY:\n    case OP_TYPEPOSUPTO:\n    case OP_CLASS:\n    case OP_NCLASS:\n#if defined SUPPORT_UNICODE || PCRE2_CODE_UNIT_WIDTH != 8\n    case OP_XCLASS:\n#endif\n    compile_iterator_backtrackingpath(common, current);\n    break;\n\n    case OP_REF:\n    case OP_REFI:\n    case OP_DNREF:\n    case OP_DNREFI:\n    compile_ref_iterator_backtrackingpath(common, current);\n    break;\n\n    case OP_RECURSE:\n    compile_recurse_backtrackingpath(common, current);\n    break;\n\n    case OP_ASSERT:\n    case OP_ASSERT_NOT:\n    case OP_ASSERTBACK:\n    case OP_ASSERTBACK_NOT:\n    compile_assert_backtrackingpath(common, current);\n    break;\n\n    case OP_ASSERT_NA:\n    case OP_ASSERTBACK_NA:\n    case OP_ONCE:\n    case OP_SCRIPT_RUN:\n    case OP_BRA:\n    case OP_CBRA:\n    case OP_COND:\n    case OP_SBRA:\n    case OP_SCBRA:\n    case OP_SCOND:\n    compile_bracket_backtrackingpath(common, current);\n    break;\n\n    case OP_BRAZERO:\n    if (current->cc\u00dd1\u00a8 > OP_ASSERTBACK_NOT)\n      compile_bracket_backtrackingpath(common, current);\n    else\n      compile_assert_backtrackingpath(common, current);\n    break;\n\n    case OP_BRAPOS:\n    case OP_CBRAPOS:\n    case OP_SBRAPOS:\n    case OP_SCBRAPOS:\n    case OP_BRAPOSZERO:\n    compile_bracketpos_backtrackingpath(common, current);\n    break;\n\n    case OP_BRAMINZERO:\n    compile_braminzero_backtrackingpath(common, current);\n    break;\n\n    case OP_MARK:\n    OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(STACK_TOP), STACK(common->has_skip_arg ? 4 : 0));\n    if (common->has_skip_arg)\n      OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(STACK_TOP), STACK(0));\n    free_stack(common, common->has_skip_arg ? 5 : 1);\n    OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), common->mark_ptr, TMP1, 0);\n    if (common->has_skip_arg)\n      OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), common->control_head_ptr, TMP2, 0);\n    break;\n\n    case OP_THEN:\n    case OP_THEN_ARG:\n    case OP_PRUNE:\n    case OP_PRUNE_ARG:\n    case OP_SKIP:\n    case OP_SKIP_ARG:\n    compile_control_verb_backtrackingpath(common, current);\n    break;\n\n    case OP_COMMIT:\n    case OP_COMMIT_ARG:\n    if (!common->local_quit_available)\n      OP1(SLJIT_MOV, SLJIT_RETURN_REG, 0, SLJIT_IMM, PCRE2_ERROR_NOMATCH);\n    if (common->quit_label == NULL)\n      add_jump(compiler, &common->quit, JUMP(SLJIT_JUMP));\n    else\n      JUMPTO(SLJIT_JUMP, common->quit_label);\n    break;\n\n    case OP_CALLOUT:\n    case OP_CALLOUT_STR:\n    case OP_FAIL:\n    case OP_ACCEPT:\n    case OP_ASSERT_ACCEPT:\n    set_jumps(current->topbacktracks, LABEL());\n    break;\n\n    case OP_THEN_TRAP:\n    /* A virtual opcode for then traps. */\n    compile_then_trap_backtrackingpath(common, current);\n    break;\n\n    default:\n    SLJIT_UNREACHABLE();\n    break;\n    }\n  current = current->prev;\n  }\ncommon->then_trap = save_then_trap;\n}\n\nstatic SLJIT_INLINE void compile_recurse(compiler_common *common)\n{\nDEFINE_COMPILER;\nPCRE2_SPTR cc = common->start + common->currententry->start;\nPCRE2_SPTR ccbegin = cc + 1 + LINK_SIZE + (*cc == OP_BRA ? 0 : IMM2_SIZE);\nPCRE2_SPTR ccend = bracketend(cc) - (1 + LINK_SIZE);\nBOOL needs_control_head;\nBOOL has_quit;\nBOOL has_accept;\nint private_data_size = get_recurse_data_length(common, ccbegin, ccend, &needs_control_head, &has_quit, &has_accept);\nint alt_count, alt_max, local_size;\nbacktrack_common altbacktrack;\njump_list *match = NULL;\nstruct sljit_jump *next_alt = NULL;\nstruct sljit_jump *accept_exit = NULL;\nstruct sljit_label *quit;\nstruct sljit_put_label *put_label = NULL;\n\n/* Recurse captures then. */\ncommon->then_trap = NULL;\n\nSLJIT_ASSERT(*cc == OP_BRA || *cc == OP_CBRA || *cc == OP_CBRAPOS || *cc == OP_SCBRA || *cc == OP_SCBRAPOS);\n\nalt_max = no_alternatives(cc);\nalt_count = 0;\n\n/* Matching path. */\nSLJIT_ASSERT(common->currententry->entry_label == NULL && common->recursive_head_ptr != 0);\ncommon->currententry->entry_label = LABEL();\nset_jumps(common->currententry->entry_calls, common->currententry->entry_label);\n\nsljit_emit_fast_enter(compiler, TMP2, 0);\ncount_match(common);\n\nlocal_size = (alt_max > 1) ? 2 : 1;\n\n/* (Reversed) stack layout:\n   \u00ddprivate data\u00a8\u00ddreturn address\u00a8\u00ddoptional: str ptr\u00a8 ... \u00ddoptional: alternative index\u00a8\u00ddrecursive_head_ptr\u00a8 */\n\nallocate_stack(common, private_data_size + local_size);\n/* Save return address. */\nOP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(local_size - 1), TMP2, 0);\n\ncopy_recurse_data(common, ccbegin, ccend, recurse_copy_from_global, local_size, private_data_size + local_size, has_quit);\n\n/* This variable is saved and restored all time when we enter or exit from a recursive context. */\nOP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), common->recursive_head_ptr, STACK_TOP, 0);\n\nif (needs_control_head)\n  OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), common->control_head_ptr, SLJIT_IMM, 0);\n\nif (alt_max > 1)\n  OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(0), STR_PTR, 0);\n\nmemset(&altbacktrack, 0, sizeof(backtrack_common));\ncommon->quit_label = NULL;\ncommon->accept_label = NULL;\ncommon->quit = NULL;\ncommon->accept = NULL;\naltbacktrack.cc = ccbegin;\ncc += GET(cc, 1);\nwhile (1)\n  {\n  altbacktrack.top = NULL;\n  altbacktrack.topbacktracks = NULL;\n\n  if (altbacktrack.cc != ccbegin)\n    OP1(SLJIT_MOV, STR_PTR, 0, SLJIT_MEM1(STACK_TOP), STACK(0));\n\n  compile_matchingpath(common, altbacktrack.cc, cc, &altbacktrack);\n  if (SLJIT_UNLIKELY(sljit_get_compiler_error(compiler)))\n    return;\n\n  allocate_stack(common, (alt_max > 1 || has_accept) ? 2 : 1);\n  OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(SLJIT_SP), common->recursive_head_ptr);\n\n  if (alt_max > 1 || has_accept)\n    {\n    if (alt_max > 3)\n      put_label = sljit_emit_put_label(compiler, SLJIT_MEM1(STACK_TOP), STACK(1));\n    else\n      OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(1), SLJIT_IMM, alt_count);\n    }\n\n  add_jump(compiler, &match, JUMP(SLJIT_JUMP));\n\n  if (alt_count == 0)\n    {\n    /* Backtracking path entry. */\n    SLJIT_ASSERT(common->currententry->backtrack_label == NULL);\n    common->currententry->backtrack_label = LABEL();\n    set_jumps(common->currententry->backtrack_calls, common->currententry->backtrack_label);\n\n    sljit_emit_fast_enter(compiler, TMP1, 0);\n\n    if (has_accept)\n      accept_exit = CMP(SLJIT_EQUAL, SLJIT_MEM1(STACK_TOP), STACK(1), SLJIT_IMM, -1);\n\n    OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(STACK_TOP), STACK(0));\n    /* Save return address. */\n    OP1(SLJIT_MOV, SLJIT_MEM1(TMP2), STACK(local_size - 1), TMP1, 0);\n\n    copy_recurse_data(common, ccbegin, ccend, recurse_swap_global, local_size, private_data_size + local_size, has_quit);\n\n    if (alt_max > 1)\n      {\n      OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(STACK_TOP), STACK(1));\n      free_stack(common, 2);\n\n      if (alt_max > 3)\n        {\n        sljit_emit_ijump(compiler, SLJIT_JUMP, TMP1, 0);\n        sljit_set_put_label(put_label, LABEL());\n        sljit_emit_op0(compiler, SLJIT_ENDBR);\n        }\n      else\n        next_alt = CMP(SLJIT_NOT_EQUAL, TMP1, 0, SLJIT_IMM, 0);\n      }\n    else\n      free_stack(common, has_accept ? 2 : 1);\n    }\n  else if (alt_max > 3)\n    {\n    sljit_set_put_label(put_label, LABEL());\n    sljit_emit_op0(compiler, SLJIT_ENDBR);\n    }\n  else\n    {\n    JUMPHERE(next_alt);\n    if (alt_count + 1 < alt_max)\n      {\n      SLJIT_ASSERT(alt_count == 1 && alt_max == 3);\n      next_alt = CMP(SLJIT_NOT_EQUAL, TMP1, 0, SLJIT_IMM, 1);\n      }\n    }\n\n  alt_count++;\n\n  compile_backtrackingpath(common, altbacktrack.top);\n  if (SLJIT_UNLIKELY(sljit_get_compiler_error(compiler)))\n    return;\n  set_jumps(altbacktrack.topbacktracks, LABEL());\n\n  if (*cc != OP_ALT)\n    break;\n\n  altbacktrack.cc = cc + 1 + LINK_SIZE;\n  cc += GET(cc, 1);\n  }\n\n/* No alternative is matched. */\n\nquit = LABEL();\n\ncopy_recurse_data(common, ccbegin, ccend, recurse_copy_private_to_global, local_size, private_data_size + local_size, has_quit);\n\nOP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(STACK_TOP), STACK(local_size - 1));\nfree_stack(common, private_data_size + local_size);\nOP1(SLJIT_MOV, TMP1, 0, SLJIT_IMM, 0);\nOP_SRC(SLJIT_FAST_RETURN, TMP2, 0);\n\nif (common->quit != NULL)\n  {\n  SLJIT_ASSERT(has_quit);\n\n  set_jumps(common->quit, LABEL());\n  OP1(SLJIT_MOV, STACK_TOP, 0, SLJIT_MEM1(SLJIT_SP), common->recursive_head_ptr);\n  copy_recurse_data(common, ccbegin, ccend, recurse_copy_shared_to_global, local_size, private_data_size + local_size, has_quit);\n  JUMPTO(SLJIT_JUMP, quit);\n  }\n\nif (has_accept)\n  {\n  JUMPHERE(accept_exit);\n  free_stack(common, 2);\n\n  /* Save return address. */\n  OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(local_size - 1), TMP1, 0);\n\n  copy_recurse_data(common, ccbegin, ccend, recurse_copy_kept_shared_to_global, local_size, private_data_size + local_size, has_quit);\n\n  OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(STACK_TOP), STACK(local_size - 1));\n  free_stack(common, private_data_size + local_size);\n  OP1(SLJIT_MOV, TMP1, 0, SLJIT_IMM, 0);\n  OP_SRC(SLJIT_FAST_RETURN, TMP2, 0);\n  }\n\nif (common->accept != NULL)\n  {\n  SLJIT_ASSERT(has_accept);\n\n  set_jumps(common->accept, LABEL());\n\n  OP1(SLJIT_MOV, STACK_TOP, 0, SLJIT_MEM1(SLJIT_SP), common->recursive_head_ptr);\n  OP1(SLJIT_MOV, TMP2, 0, STACK_TOP, 0);\n\n  allocate_stack(common, 2);\n  OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(1), SLJIT_IMM, -1);\n  }\n\nset_jumps(match, LABEL());\n\nOP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(0), TMP2, 0);\n\ncopy_recurse_data(common, ccbegin, ccend, recurse_swap_global, local_size, private_data_size + local_size, has_quit);\n\nOP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(TMP2), STACK(local_size - 1));\nOP1(SLJIT_MOV, TMP1, 0, SLJIT_IMM, 1);\nOP_SRC(SLJIT_FAST_RETURN, TMP2, 0);\n}\n\n#undef COMPILE_BACKTRACKINGPATH\n#undef CURRENT_AS\n\n#define PUBLIC_JIT_COMPILE_CONFIGURATION_OPTIONS \\\n  (PCRE2_JIT_INVALID_UTF)\n\nstatic int jit_compile(pcre2_code *code, sljit_u32 mode)\n{\npcre2_real_code *re = (pcre2_real_code *)code;\nstruct sljit_compiler *compiler;\nbacktrack_common rootbacktrack;\ncompiler_common common_data;\ncompiler_common *common = &common_data;\nconst sljit_u8 *tables = re->tables;\nvoid *allocator_data = &re->memctl;\nint private_data_size;\nPCRE2_SPTR ccend;\nexecutable_functions *functions;\nvoid *executable_func;\nsljit_uw executable_size;\nsljit_uw total_length;\nstruct sljit_label *mainloop_label = NULL;\nstruct sljit_label *continue_match_label;\nstruct sljit_label *empty_match_found_label = NULL;\nstruct sljit_label *empty_match_backtrack_label = NULL;\nstruct sljit_label *reset_match_label;\nstruct sljit_label *quit_label;\nstruct sljit_jump *jump;\nstruct sljit_jump *minlength_check_failed = NULL;\nstruct sljit_jump *empty_match = NULL;\nstruct sljit_jump *end_anchor_failed = NULL;\njump_list *reqcu_not_found = NULL;\n\nSLJIT_ASSERT(tables);\n\n#if HAS_VIRTUAL_REGISTERS == 1\nSLJIT_ASSERT(sljit_get_register_index(TMP3) < 0 && sljit_get_register_index(ARGUMENTS) < 0 && sljit_get_register_index(RETURN_ADDR) < 0);\n#elif HAS_VIRTUAL_REGISTERS == 0\nSLJIT_ASSERT(sljit_get_register_index(TMP3) >= 0 && sljit_get_register_index(ARGUMENTS) >= 0 && sljit_get_register_index(RETURN_ADDR) >= 0);\n#else\n#error \"Invalid value for HAS_VIRTUAL_REGISTERS\"\n#endif\n\nmemset(&rootbacktrack, 0, sizeof(backtrack_common));\nmemset(common, 0, sizeof(compiler_common));\ncommon->re = re;\ncommon->name_table = (PCRE2_SPTR)((uint8_t *)re + sizeof(pcre2_real_code));\nrootbacktrack.cc = common->name_table + re->name_count * re->name_entry_size;\n\n#ifdef SUPPORT_UNICODE\ncommon->invalid_utf = (mode & PCRE2_JIT_INVALID_UTF) != 0;\n#endif /* SUPPORT_UNICODE */\nmode &= ~PUBLIC_JIT_COMPILE_CONFIGURATION_OPTIONS;\n\ncommon->start = rootbacktrack.cc;\ncommon->read_only_data_head = NULL;\ncommon->fcc = tables + fcc_offset;\ncommon->lcc = (sljit_sw)(tables + lcc_offset);\ncommon->mode = mode;\ncommon->might_be_empty = (re->minlength == 0) || (re->flags & PCRE2_MATCH_EMPTY);\ncommon->allow_empty_partial = (re->max_lookbehind > 0) || (re->flags & PCRE2_MATCH_EMPTY);\ncommon->nltype = NLTYPE_FIXED;\nswitch(re->newline_convention)\n  {\n  case PCRE2_NEWLINE_CR: common->newline = CHAR_CR; break;\n  case PCRE2_NEWLINE_LF: common->newline = CHAR_NL; break;\n  case PCRE2_NEWLINE_CRLF: common->newline = (CHAR_CR << 8) | CHAR_NL; break;\n  case PCRE2_NEWLINE_ANY: common->newline = (CHAR_CR << 8) | CHAR_NL; common->nltype = NLTYPE_ANY; break;\n  case PCRE2_NEWLINE_ANYCRLF: common->newline = (CHAR_CR << 8) | CHAR_NL; common->nltype = NLTYPE_ANYCRLF; break;\n  case PCRE2_NEWLINE_NUL: common->newline = CHAR_NUL; break;\n  default: return PCRE2_ERROR_INTERNAL;\n  }\ncommon->nlmax = READ_CHAR_MAX;\ncommon->nlmin = 0;\nif (re->bsr_convention == PCRE2_BSR_UNICODE)\n  common->bsr_nltype = NLTYPE_ANY;\nelse if (re->bsr_convention == PCRE2_BSR_ANYCRLF)\n  common->bsr_nltype = NLTYPE_ANYCRLF;\nelse\n  {\n#ifdef BSR_ANYCRLF\n  common->bsr_nltype = NLTYPE_ANYCRLF;\n#else\n  common->bsr_nltype = NLTYPE_ANY;\n#endif\n  }\ncommon->bsr_nlmax = READ_CHAR_MAX;\ncommon->bsr_nlmin = 0;\ncommon->endonly = (re->overall_options & PCRE2_DOLLAR_ENDONLY) != 0;\ncommon->ctypes = (sljit_sw)(tables + ctypes_offset);\ncommon->name_count = re->name_count;\ncommon->name_entry_size = re->name_entry_size;\ncommon->unset_backref = (re->overall_options & PCRE2_MATCH_UNSET_BACKREF) != 0;\ncommon->alt_circumflex = (re->overall_options & PCRE2_ALT_CIRCUMFLEX) != 0;\n#ifdef SUPPORT_UNICODE\n/* PCRE_UTF\u00dd16|32\u00a8 have the same value as PCRE_UTF8. */\ncommon->utf = (re->overall_options & PCRE2_UTF) != 0;\ncommon->ucp = (re->overall_options & PCRE2_UCP) != 0;\nif (common->utf)\n  {\n  if (common->nltype == NLTYPE_ANY)\n    common->nlmax = 0x2029;\n  else if (common->nltype == NLTYPE_ANYCRLF)\n    common->nlmax = (CHAR_CR > CHAR_NL) ? CHAR_CR : CHAR_NL;\n  else\n    {\n    /* We only care about the first newline character. */\n    common->nlmax = common->newline & 0xff;\n    }\n\n  if (common->nltype == NLTYPE_FIXED)\n    common->nlmin = common->newline & 0xff;\n  else\n    common->nlmin = (CHAR_CR < CHAR_NL) ? CHAR_CR : CHAR_NL;\n\n  if (common->bsr_nltype == NLTYPE_ANY)\n    common->bsr_nlmax = 0x2029;\n  else\n    common->bsr_nlmax = (CHAR_CR > CHAR_NL) ? CHAR_CR : CHAR_NL;\n  common->bsr_nlmin = (CHAR_CR < CHAR_NL) ? CHAR_CR : CHAR_NL;\n  }\nelse\n  common->invalid_utf = FALSE;\n#endif /* SUPPORT_UNICODE */\nccend = bracketend(common->start);\n\n/* Calculate the local space size on the stack. */\ncommon->ovector_start = LIMIT_MATCH + sizeof(sljit_sw);\ncommon->optimized_cbracket = (sljit_u8 *)SLJIT_MALLOC(re->top_bracket + 1, allocator_data);\nif (!common->optimized_cbracket)\n  return PCRE2_ERROR_NOMEMORY;\n#if defined DEBUG_FORCE_UNOPTIMIZED_CBRAS && DEBUG_FORCE_UNOPTIMIZED_CBRAS == 1\nmemset(common->optimized_cbracket, 0, re->top_bracket + 1);\n#else\nmemset(common->optimized_cbracket, 1, re->top_bracket + 1);\n#endif\n\nSLJIT_ASSERT(*common->start == OP_BRA && ccend\u00dd-(1 + LINK_SIZE)\u00a8 == OP_KET);\n#if defined DEBUG_FORCE_UNOPTIMIZED_CBRAS && DEBUG_FORCE_UNOPTIMIZED_CBRAS == 2\ncommon->capture_last_ptr = common->ovector_start;\ncommon->ovector_start += sizeof(sljit_sw);\n#endif\nif (!check_opcode_types(common, common->start, ccend))\n  {\n  SLJIT_FREE(common->optimized_cbracket, allocator_data);\n  return PCRE2_ERROR_NOMEMORY;\n  }\n\n/* Checking flags and updating ovector_start. */\nif (mode == PCRE2_JIT_COMPLETE && (re->flags & PCRE2_LASTSET) != 0 && (re->overall_options & PCRE2_NO_START_OPTIMIZE) == 0)\n  {\n  common->req_char_ptr = common->ovector_start;\n  common->ovector_start += sizeof(sljit_sw);\n  }\nif (mode != PCRE2_JIT_COMPLETE)\n  {\n  common->start_used_ptr = common->ovector_start;\n  common->ovector_start += sizeof(sljit_sw);\n  if (mode == PCRE2_JIT_PARTIAL_SOFT)\n    {\n    common->hit_start = common->ovector_start;\n    common->ovector_start += sizeof(sljit_sw);\n    }\n  }\nif ((re->overall_options & (PCRE2_FIRSTLINE | PCRE2_USE_OFFSET_LIMIT)) != 0)\n  {\n  common->match_end_ptr = common->ovector_start;\n  common->ovector_start += sizeof(sljit_sw);\n  }\n#if defined DEBUG_FORCE_CONTROL_HEAD && DEBUG_FORCE_CONTROL_HEAD\ncommon->control_head_ptr = 1;\n#endif\nif (common->control_head_ptr != 0)\n  {\n  common->control_head_ptr = common->ovector_start;\n  common->ovector_start += sizeof(sljit_sw);\n  }\nif (common->has_set_som)\n  {\n  /* Saving the real start pointer is necessary. */\n  common->start_ptr = common->ovector_start;\n  common->ovector_start += sizeof(sljit_sw);\n  }\n\n/* Aligning ovector to even number of sljit words. */\nif ((common->ovector_start & sizeof(sljit_sw)) != 0)\n  common->ovector_start += sizeof(sljit_sw);\n\nif (common->start_ptr == 0)\n  common->start_ptr = OVECTOR(0);\n\n/* Capturing brackets cannot be optimized if callouts are allowed. */\nif (common->capture_last_ptr != 0)\n  memset(common->optimized_cbracket, 0, re->top_bracket + 1);\n\nSLJIT_ASSERT(!(common->req_char_ptr != 0 && common->start_used_ptr != 0));\ncommon->cbra_ptr = OVECTOR_START + (re->top_bracket + 1) * 2 * sizeof(sljit_sw);\n\ntotal_length = ccend - common->start;\ncommon->private_data_ptrs = (sljit_s32 *)SLJIT_MALLOC(total_length * (sizeof(sljit_s32) + (common->has_then ? 1 : 0)), allocator_data);\nif (!common->private_data_ptrs)\n  {\n  SLJIT_FREE(common->optimized_cbracket, allocator_data);\n  return PCRE2_ERROR_NOMEMORY;\n  }\nmemset(common->private_data_ptrs, 0, total_length * sizeof(sljit_s32));\n\nprivate_data_size = common->cbra_ptr + (re->top_bracket + 1) * sizeof(sljit_sw);\nset_private_data_ptrs(common, &private_data_size, ccend);\nif ((re->overall_options & PCRE2_ANCHORED) == 0 && (re->overall_options & PCRE2_NO_START_OPTIMIZE) == 0 && !common->has_skip_in_assert_back)\n  detect_early_fail(common, common->start, &private_data_size, 0, 0);\n\nSLJIT_ASSERT(common->early_fail_start_ptr <= common->early_fail_end_ptr);\n\nif (private_data_size > SLJIT_MAX_LOCAL_SIZE)\n  {\n  SLJIT_FREE(common->private_data_ptrs, allocator_data);\n  SLJIT_FREE(common->optimized_cbracket, allocator_data);\n  return PCRE2_ERROR_NOMEMORY;\n  }\n\nif (common->has_then)\n  {\n  common->then_offsets = (sljit_u8 *)(common->private_data_ptrs + total_length);\n  memset(common->then_offsets, 0, total_length);\n  set_then_offsets(common, common->start, NULL);\n  }\n\ncompiler = sljit_create_compiler(allocator_data);\nif (!compiler)\n  {\n  SLJIT_FREE(common->optimized_cbracket, allocator_data);\n  SLJIT_FREE(common->private_data_ptrs, allocator_data);\n  return PCRE2_ERROR_NOMEMORY;\n  }\ncommon->compiler = compiler;\n\n/* Main pcre_jit_exec entry. */\nsljit_emit_enter(compiler, 0, SLJIT_ARG1(SW), 5, 5, 0, 0, private_data_size);\n\n/* Register init. */\nreset_ovector(common, (re->top_bracket + 1) * 2);\nif (common->req_char_ptr != 0)\n  OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), common->req_char_ptr, SLJIT_R0, 0);\n\nOP1(SLJIT_MOV, ARGUMENTS, 0, SLJIT_S0, 0);\nOP1(SLJIT_MOV, TMP1, 0, SLJIT_S0, 0);\nOP1(SLJIT_MOV, STR_PTR, 0, SLJIT_MEM1(TMP1), SLJIT_OFFSETOF(jit_arguments, str));\nOP1(SLJIT_MOV, STR_END, 0, SLJIT_MEM1(TMP1), SLJIT_OFFSETOF(jit_arguments, end));\nOP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(TMP1), SLJIT_OFFSETOF(jit_arguments, stack));\nOP1(SLJIT_MOV_U32, TMP1, 0, SLJIT_MEM1(TMP1), SLJIT_OFFSETOF(jit_arguments, limit_match));\nOP1(SLJIT_MOV, STACK_TOP, 0, SLJIT_MEM1(TMP2), SLJIT_OFFSETOF(struct sljit_stack, end));\nOP1(SLJIT_MOV, STACK_LIMIT, 0, SLJIT_MEM1(TMP2), SLJIT_OFFSETOF(struct sljit_stack, start));\nOP2(SLJIT_ADD, TMP1, 0, TMP1, 0, SLJIT_IMM, 1);\nOP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), LIMIT_MATCH, TMP1, 0);\n\nif (common->early_fail_start_ptr < common->early_fail_end_ptr)\n  reset_early_fail(common);\n\nif (mode == PCRE2_JIT_PARTIAL_SOFT)\n  OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), common->hit_start, SLJIT_IMM, -1);\nif (common->mark_ptr != 0)\n  OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), common->mark_ptr, SLJIT_IMM, 0);\nif (common->control_head_ptr != 0)\n  OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), common->control_head_ptr, SLJIT_IMM, 0);\n\n/* Main part of the matching */\nif ((re->overall_options & PCRE2_ANCHORED) == 0)\n  {\n  mainloop_label = mainloop_entry(common);\n  continue_match_label = LABEL();\n  /* Forward search if possible. */\n  if ((re->overall_options & PCRE2_NO_START_OPTIMIZE) == 0)\n    {\n    if (mode == PCRE2_JIT_COMPLETE && fast_forward_first_n_chars(common))\n      ;\n    else if ((re->flags & PCRE2_FIRSTSET) != 0)\n      fast_forward_first_char(common);\n    else if ((re->flags & PCRE2_STARTLINE) != 0)\n      fast_forward_newline(common);\n    else if ((re->flags & PCRE2_FIRSTMAPSET) != 0)\n      fast_forward_start_bits(common);\n    }\n  }\nelse\n  continue_match_label = LABEL();\n\nif (mode == PCRE2_JIT_COMPLETE && re->minlength > 0 && (re->overall_options & PCRE2_NO_START_OPTIMIZE) == 0)\n  {\n  OP1(SLJIT_MOV, SLJIT_RETURN_REG, 0, SLJIT_IMM, PCRE2_ERROR_NOMATCH);\n  OP2(SLJIT_ADD, TMP2, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(re->minlength));\n  minlength_check_failed = CMP(SLJIT_GREATER, TMP2, 0, STR_END, 0);\n  }\nif (common->req_char_ptr != 0)\n  reqcu_not_found = search_requested_char(common, (PCRE2_UCHAR)(re->last_codeunit), (re->flags & PCRE2_LASTCASELESS) != 0, (re->flags & PCRE2_FIRSTSET) != 0);\n\n/* Store the current STR_PTR in OVECTOR(0). */\nOP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), OVECTOR(0), STR_PTR, 0);\n/* Copy the limit of allowed recursions. */\nOP1(SLJIT_MOV, COUNT_MATCH, 0, SLJIT_MEM1(SLJIT_SP), LIMIT_MATCH);\nif (common->capture_last_ptr != 0)\n  OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), common->capture_last_ptr, SLJIT_IMM, 0);\nif (common->fast_forward_bc_ptr != NULL)\n  OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), PRIVATE_DATA(common->fast_forward_bc_ptr + 1) >> 3, STR_PTR, 0);\n\nif (common->start_ptr != OVECTOR(0))\n  OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), common->start_ptr, STR_PTR, 0);\n\n/* Copy the beginning of the string. */\nif (mode == PCRE2_JIT_PARTIAL_SOFT)\n  {\n  jump = CMP(SLJIT_NOT_EQUAL, SLJIT_MEM1(SLJIT_SP), common->hit_start, SLJIT_IMM, -1);\n  OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), common->start_used_ptr, STR_PTR, 0);\n  JUMPHERE(jump);\n  }\nelse if (mode == PCRE2_JIT_PARTIAL_HARD)\n  OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), common->start_used_ptr, STR_PTR, 0);\n\ncompile_matchingpath(common, common->start, ccend, &rootbacktrack);\nif (SLJIT_UNLIKELY(sljit_get_compiler_error(compiler)))\n  {\n  sljit_free_compiler(compiler);\n  SLJIT_FREE(common->optimized_cbracket, allocator_data);\n  SLJIT_FREE(common->private_data_ptrs, allocator_data);\n  PRIV(jit_free_rodata)(common->read_only_data_head, allocator_data);\n  return PCRE2_ERROR_NOMEMORY;\n  }\n\nif ((re->overall_options & PCRE2_ENDANCHORED) != 0)\n  end_anchor_failed = CMP(SLJIT_NOT_EQUAL, STR_PTR, 0, STR_END, 0);\n\nif (common->might_be_empty)\n  {\n  empty_match = CMP(SLJIT_EQUAL, STR_PTR, 0, SLJIT_MEM1(SLJIT_SP), OVECTOR(0));\n  empty_match_found_label = LABEL();\n  }\n\ncommon->accept_label = LABEL();\nif (common->accept != NULL)\n  set_jumps(common->accept, common->accept_label);\n\n/* This means we have a match. Update the ovector. */\ncopy_ovector(common, re->top_bracket + 1);\ncommon->quit_label = common->abort_label = LABEL();\nif (common->quit != NULL)\n  set_jumps(common->quit, common->quit_label);\nif (common->abort != NULL)\n  set_jumps(common->abort, common->abort_label);\nif (minlength_check_failed != NULL)\n  SET_LABEL(minlength_check_failed, common->abort_label);\n\nsljit_emit_op0(compiler, SLJIT_SKIP_FRAMES_BEFORE_RETURN);\nsljit_emit_return(compiler, SLJIT_MOV, SLJIT_RETURN_REG, 0);\n\nif (common->failed_match != NULL)\n  {\n  SLJIT_ASSERT(common->mode == PCRE2_JIT_COMPLETE);\n  set_jumps(common->failed_match, LABEL());\n  OP1(SLJIT_MOV, SLJIT_RETURN_REG, 0, SLJIT_IMM, PCRE2_ERROR_NOMATCH);\n  JUMPTO(SLJIT_JUMP, common->abort_label);\n  }\n\nif ((re->overall_options & PCRE2_ENDANCHORED) != 0)\n  JUMPHERE(end_anchor_failed);\n\nif (mode != PCRE2_JIT_COMPLETE)\n  {\n  common->partialmatchlabel = LABEL();\n  set_jumps(common->partialmatch, common->partialmatchlabel);\n  return_with_partial_match(common, common->quit_label);\n  }\n\nif (common->might_be_empty)\n  empty_match_backtrack_label = LABEL();\ncompile_backtrackingpath(common, rootbacktrack.top);\nif (SLJIT_UNLIKELY(sljit_get_compiler_error(compiler)))\n  {\n  sljit_free_compiler(compiler);\n  SLJIT_FREE(common->optimized_cbracket, allocator_data);\n  SLJIT_FREE(common->private_data_ptrs, allocator_data);\n  PRIV(jit_free_rodata)(common->read_only_data_head, allocator_data);\n  return PCRE2_ERROR_NOMEMORY;\n  }\n\nSLJIT_ASSERT(rootbacktrack.prev == NULL);\nreset_match_label = LABEL();\n\nif (mode == PCRE2_JIT_PARTIAL_SOFT)\n  {\n  /* Update hit_start only in the first time. */\n  jump = CMP(SLJIT_NOT_EQUAL, SLJIT_MEM1(SLJIT_SP), common->hit_start, SLJIT_IMM, 0);\n  OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(SLJIT_SP), common->start_ptr);\n  OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), common->start_used_ptr, SLJIT_IMM, -1);\n  OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), common->hit_start, TMP1, 0);\n  JUMPHERE(jump);\n  }\n\n/* Check we have remaining characters. */\nif ((re->overall_options & PCRE2_ANCHORED) == 0 && common->match_end_ptr != 0)\n  {\n  OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(SLJIT_SP), common->match_end_ptr);\n  }\n\nOP1(SLJIT_MOV, STR_PTR, 0, SLJIT_MEM1(SLJIT_SP),\n    (common->fast_forward_bc_ptr != NULL) ? (PRIVATE_DATA(common->fast_forward_bc_ptr + 1) >> 3) : common->start_ptr);\n\nif ((re->overall_options & PCRE2_ANCHORED) == 0)\n  {\n  if (common->ff_newline_shortcut != NULL)\n    {\n    /* There cannot be more newlines if PCRE2_FIRSTLINE is set. */\n    if ((re->overall_options & PCRE2_FIRSTLINE) == 0)\n      {\n      if (common->match_end_ptr != 0)\n        {\n        OP1(SLJIT_MOV, TMP3, 0, STR_END, 0);\n        OP1(SLJIT_MOV, STR_END, 0, TMP1, 0);\n        CMPTO(SLJIT_LESS, STR_PTR, 0, TMP1, 0, common->ff_newline_shortcut);\n        OP1(SLJIT_MOV, STR_END, 0, TMP3, 0);\n        }\n      else\n        CMPTO(SLJIT_LESS, STR_PTR, 0, STR_END, 0, common->ff_newline_shortcut);\n      }\n    }\n  else\n    CMPTO(SLJIT_LESS, STR_PTR, 0, (common->match_end_ptr == 0) ? STR_END : TMP1, 0, mainloop_label);\n  }\n\n/* No more remaining characters. */\nif (reqcu_not_found != NULL)\n  set_jumps(reqcu_not_found, LABEL());\n\nif (mode == PCRE2_JIT_PARTIAL_SOFT)\n  CMPTO(SLJIT_NOT_EQUAL, SLJIT_MEM1(SLJIT_SP), common->hit_start, SLJIT_IMM, -1, common->partialmatchlabel);\n\nOP1(SLJIT_MOV, SLJIT_RETURN_REG, 0, SLJIT_IMM, PCRE2_ERROR_NOMATCH);\nJUMPTO(SLJIT_JUMP, common->quit_label);\n\nflush_stubs(common);\n\nif (common->might_be_empty)\n  {\n  JUMPHERE(empty_match);\n  OP1(SLJIT_MOV, TMP1, 0, ARGUMENTS, 0);\n  OP1(SLJIT_MOV_U32, TMP2, 0, SLJIT_MEM1(TMP1), SLJIT_OFFSETOF(jit_arguments, options));\n  OP2(SLJIT_AND | SLJIT_SET_Z, SLJIT_UNUSED, 0, TMP2, 0, SLJIT_IMM, PCRE2_NOTEMPTY);\n  JUMPTO(SLJIT_NOT_ZERO, empty_match_backtrack_label);\n  OP2(SLJIT_AND | SLJIT_SET_Z, SLJIT_UNUSED, 0, TMP2, 0, SLJIT_IMM, PCRE2_NOTEMPTY_ATSTART);\n  JUMPTO(SLJIT_ZERO, empty_match_found_label);\n  OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(TMP1), SLJIT_OFFSETOF(jit_arguments, str));\n  CMPTO(SLJIT_NOT_EQUAL, TMP2, 0, STR_PTR, 0, empty_match_found_label);\n  JUMPTO(SLJIT_JUMP, empty_match_backtrack_label);\n  }\n\ncommon->fast_forward_bc_ptr = NULL;\ncommon->early_fail_start_ptr = 0;\ncommon->early_fail_end_ptr = 0;\ncommon->currententry = common->entries;\ncommon->local_quit_available = TRUE;\nquit_label = common->quit_label;\nwhile (common->currententry != NULL)\n  {\n  /* Might add new entries. */\n  compile_recurse(common);\n  if (SLJIT_UNLIKELY(sljit_get_compiler_error(compiler)))\n    {\n    sljit_free_compiler(compiler);\n    SLJIT_FREE(common->optimized_cbracket, allocator_data);\n    SLJIT_FREE(common->private_data_ptrs, allocator_data);\n    PRIV(jit_free_rodata)(common->read_only_data_head, allocator_data);\n    return PCRE2_ERROR_NOMEMORY;\n    }\n  flush_stubs(common);\n  common->currententry = common->currententry->next;\n  }\ncommon->local_quit_available = FALSE;\ncommon->quit_label = quit_label;\n\n/* Allocating stack, returns with PCRE_ERROR_JIT_STACKLIMIT if fails. */\n/* This is a (really) rare case. */\nset_jumps(common->stackalloc, LABEL());\n/* RETURN_ADDR is not a saved register. */\nsljit_emit_fast_enter(compiler, SLJIT_MEM1(SLJIT_SP), LOCALS0);\n\nSLJIT_ASSERT(TMP1 == SLJIT_R0 && STR_PTR == SLJIT_R1);\n\nOP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), LOCALS1, STR_PTR, 0);\nOP1(SLJIT_MOV, SLJIT_R0, 0, ARGUMENTS, 0);\nOP2(SLJIT_SUB, SLJIT_R1, 0, STACK_LIMIT, 0, SLJIT_IMM, STACK_GROWTH_RATE);\nOP1(SLJIT_MOV, SLJIT_R0, 0, SLJIT_MEM1(SLJIT_R0), SLJIT_OFFSETOF(jit_arguments, stack));\nOP1(SLJIT_MOV, STACK_LIMIT, 0, TMP2, 0);\n\nsljit_emit_icall(compiler, SLJIT_CALL, SLJIT_RET(SW) | SLJIT_ARG1(SW) | SLJIT_ARG2(SW), SLJIT_IMM, SLJIT_FUNC_OFFSET(sljit_stack_resize));\n\njump = CMP(SLJIT_EQUAL, SLJIT_RETURN_REG, 0, SLJIT_IMM, 0);\nOP1(SLJIT_MOV, TMP2, 0, STACK_LIMIT, 0);\nOP1(SLJIT_MOV, STACK_LIMIT, 0, SLJIT_RETURN_REG, 0);\nOP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(SLJIT_SP), LOCALS0);\nOP1(SLJIT_MOV, STR_PTR, 0, SLJIT_MEM1(SLJIT_SP), LOCALS1);\nOP_SRC(SLJIT_FAST_RETURN, TMP1, 0);\n\n/* Allocation failed. */\nJUMPHERE(jump);\n/* We break the return address cache here, but this is a really rare case. */\nOP1(SLJIT_MOV, SLJIT_RETURN_REG, 0, SLJIT_IMM, PCRE2_ERROR_JIT_STACKLIMIT);\nJUMPTO(SLJIT_JUMP, common->quit_label);\n\n/* Call limit reached. */\nset_jumps(common->calllimit, LABEL());\nOP1(SLJIT_MOV, SLJIT_RETURN_REG, 0, SLJIT_IMM, PCRE2_ERROR_MATCHLIMIT);\nJUMPTO(SLJIT_JUMP, common->quit_label);\n\nif (common->revertframes != NULL)\n  {\n  set_jumps(common->revertframes, LABEL());\n  do_revertframes(common);\n  }\nif (common->wordboundary != NULL)\n  {\n  set_jumps(common->wordboundary, LABEL());\n  check_wordboundary(common);\n  }\nif (common->anynewline != NULL)\n  {\n  set_jumps(common->anynewline, LABEL());\n  check_anynewline(common);\n  }\nif (common->hspace != NULL)\n  {\n  set_jumps(common->hspace, LABEL());\n  check_hspace(common);\n  }\nif (common->vspace != NULL)\n  {\n  set_jumps(common->vspace, LABEL());\n  check_vspace(common);\n  }\nif (common->casefulcmp != NULL)\n  {\n  set_jumps(common->casefulcmp, LABEL());\n  do_casefulcmp(common);\n  }\nif (common->caselesscmp != NULL)\n  {\n  set_jumps(common->caselesscmp, LABEL());\n  do_caselesscmp(common);\n  }\nif (common->reset_match != NULL)\n  {\n  set_jumps(common->reset_match, LABEL());\n  do_reset_match(common, (re->top_bracket + 1) * 2);\n  CMPTO(SLJIT_GREATER, STR_PTR, 0, TMP1, 0, continue_match_label);\n  OP1(SLJIT_MOV, STR_PTR, 0, TMP1, 0);\n  JUMPTO(SLJIT_JUMP, reset_match_label);\n  }\n#ifdef SUPPORT_UNICODE\n#if PCRE2_CODE_UNIT_WIDTH == 8\nif (common->utfreadchar != NULL)\n  {\n  set_jumps(common->utfreadchar, LABEL());\n  do_utfreadchar(common);\n  }\nif (common->utfreadtype8 != NULL)\n  {\n  set_jumps(common->utfreadtype8, LABEL());\n  do_utfreadtype8(common);\n  }\nif (common->utfpeakcharback != NULL)\n  {\n  set_jumps(common->utfpeakcharback, LABEL());\n  do_utfpeakcharback(common);\n  }\n#endif /* PCRE2_CODE_UNIT_WIDTH == 8 */\n#if PCRE2_CODE_UNIT_WIDTH == 8 || PCRE2_CODE_UNIT_WIDTH == 16\nif (common->utfreadchar_invalid != NULL)\n  {\n  set_jumps(common->utfreadchar_invalid, LABEL());\n  do_utfreadchar_invalid(common);\n  }\nif (common->utfreadnewline_invalid != NULL)\n  {\n  set_jumps(common->utfreadnewline_invalid, LABEL());\n  do_utfreadnewline_invalid(common);\n  }\nif (common->utfmoveback_invalid)\n  {\n  set_jumps(common->utfmoveback_invalid, LABEL());\n  do_utfmoveback_invalid(common);\n  }\nif (common->utfpeakcharback_invalid)\n  {\n  set_jumps(common->utfpeakcharback_invalid, LABEL());\n  do_utfpeakcharback_invalid(common);\n  }\n#endif /* PCRE2_CODE_UNIT_WIDTH == 8 || PCRE2_CODE_UNIT_WIDTH == 16 */\nif (common->getucd != NULL)\n  {\n  set_jumps(common->getucd, LABEL());\n  do_getucd(common);\n  }\nif (common->getucdtype != NULL)\n  {\n  set_jumps(common->getucdtype, LABEL());\n  do_getucdtype(common);\n  }\n#endif /* SUPPORT_UNICODE */\n\nSLJIT_FREE(common->optimized_cbracket, allocator_data);\nSLJIT_FREE(common->private_data_ptrs, allocator_data);\n\nexecutable_func = sljit_generate_code(compiler);\nexecutable_size = sljit_get_generated_code_size(compiler);\nsljit_free_compiler(compiler);\n\nif (executable_func == NULL)\n  {\n  PRIV(jit_free_rodata)(common->read_only_data_head, allocator_data);\n  return PCRE2_ERROR_NOMEMORY;\n  }\n\n/* Reuse the function descriptor if possible. */\nif (re->executable_jit != NULL)\n  functions = (executable_functions *)re->executable_jit;\nelse\n  {\n  functions = SLJIT_MALLOC(sizeof(executable_functions), allocator_data);\n  if (functions == NULL)\n    {\n    /* This case is highly unlikely since we just recently\n    freed a lot of memory. Not impossible though. */\n    sljit_free_code(executable_func);\n    PRIV(jit_free_rodata)(common->read_only_data_head, allocator_data);\n    return PCRE2_ERROR_NOMEMORY;\n    }\n  memset(functions, 0, sizeof(executable_functions));\n  functions->top_bracket = re->top_bracket + 1;\n  functions->limit_match = re->limit_match;\n  re->executable_jit = functions;\n  }\n\n/* Turn mode into an index. */\nif (mode == PCRE2_JIT_COMPLETE)\n  mode = 0;\nelse\n  mode = (mode == PCRE2_JIT_PARTIAL_SOFT) ? 1 : 2;\n\nSLJIT_ASSERT(mode < JIT_NUMBER_OF_COMPILE_MODES);\nfunctions->executable_funcs\u00ddmode\u00a8 = executable_func;\nfunctions->read_only_data_heads\u00ddmode\u00a8 = common->read_only_data_head;\nfunctions->executable_sizes\u00ddmode\u00a8 = executable_size;\nreturn 0;\n}\n\n#endif\n\n/*************************************************\n*        JIT compile a Regular Expression        *\n*************************************************/\n\n/* This function used JIT to convert a previously-compiled pattern into machine\ncode.\n\nArguments:\n  code          a compiled pattern\n  options       JIT option bits\n\nReturns:        0: success or (*NOJIT) was used\n               <0: an error code\n*/\n\n#define PUBLIC_JIT_COMPILE_OPTIONS \\\n  (PCRE2_JIT_COMPLETE|PCRE2_JIT_PARTIAL_SOFT|PCRE2_JIT_PARTIAL_HARD|PCRE2_JIT_INVALID_UTF)\n\nPCRE2_EXP_DEFN int PCRE2_CALL_CONVENTION\npcre2_jit_compile(pcre2_code *code, uint32_t options)\n{\npcre2_real_code *re = (pcre2_real_code *)code;\n\nif (code == NULL)\n  return PCRE2_ERROR_NULL;\n\nif ((options & ~PUBLIC_JIT_COMPILE_OPTIONS) != 0)\n  return PCRE2_ERROR_JIT_BADOPTION;\n\n/* Support for invalid UTF was first introduced in JIT, with the option\nPCRE2_JIT_INVALID_UTF. Later, support was added to the interpreter, and the\ncompile-time option PCRE2_MATCH_INVALID_UTF was created. This is now the\npreferred feature, with the earlier option deprecated. However, for backward\ncompatibility, if the earlier option is set, it forces the new option so that\nif JIT matching falls back to the interpreter, there is still support for\ninvalid UTF. However, if this function has already been successfully called\nwithout PCRE2_JIT_INVALID_UTF and without PCRE2_MATCH_INVALID_UTF (meaning that\nnon-invalid-supporting JIT code was compiled), give an error.\n\nIf in the future support for PCRE2_JIT_INVALID_UTF is withdrawn, the following\nactions are needed:\n\n  1. Remove the definition from pcre2.h.in and from the list in\n     PUBLIC_JIT_COMPILE_OPTIONS above.\n\n  2. Replace PCRE2_JIT_INVALID_UTF with a local flag in this module.\n\n  3. Replace PCRE2_JIT_INVALID_UTF in pcre2_jit_test.c.\n\n  4. Delete the following short block of code. The setting of \"re\" and\n     \"functions\" can be moved into the JIT-only block below, but if that is\n     done, (void)re and (void)functions will be needed in the non-JIT case, to\n     avoid compiler warnings.\n*/\n\n#ifdef SUPPORT_JIT\nexecutable_functions *functions = (executable_functions *)re->executable_jit;\nstatic int executable_allocator_is_working = 0;\n#endif\n\nif ((options & PCRE2_JIT_INVALID_UTF) != 0)\n  {\n  if ((re->overall_options & PCRE2_MATCH_INVALID_UTF) == 0)\n    {\n#ifdef SUPPORT_JIT\n    if (functions != NULL) return PCRE2_ERROR_JIT_BADOPTION;\n#endif\n    re->overall_options |= PCRE2_MATCH_INVALID_UTF;\n    }\n  }\n\n/* The above tests are run with and without JIT support. This means that\nPCRE2_JIT_INVALID_UTF propagates back into the regex options (ensuring\ninterpreter support) even in the absence of JIT. But now, if there is no JIT\nsupport, give an error return. */\n\n#ifndef SUPPORT_JIT\nreturn PCRE2_ERROR_JIT_BADOPTION;\n#else  /* SUPPORT_JIT */\n\n/* There is JIT support. Do the necessary. */\n\nif ((re->flags & PCRE2_NOJIT) != 0) return 0;\n\nif (executable_allocator_is_working == 0)\n  {\n  /* Checks whether the executable allocator is working. This check\n     might run multiple times in multi-threaded environments, but the\n     result should not be affected by it. */\n  void *ptr = SLJIT_MALLOC_EXEC(32);\n\n  executable_allocator_is_working = -1;\n\n  if (ptr != NULL)\n    {\n    SLJIT_FREE_EXEC(((sljit_u8*)(ptr)) + SLJIT_EXEC_OFFSET(ptr));\n    executable_allocator_is_working = 1;\n    }\n  }\n\nif (executable_allocator_is_working < 0)\n  return PCRE2_ERROR_NOMEMORY;\n\nif ((re->overall_options & PCRE2_MATCH_INVALID_UTF) != 0)\n  options |= PCRE2_JIT_INVALID_UTF;\n\nif ((options & PCRE2_JIT_COMPLETE) != 0 && (functions == NULL\n    || functions->executable_funcs\u00dd0\u00a8 == NULL)) {\n  uint32_t excluded_options = (PCRE2_JIT_PARTIAL_SOFT | PCRE2_JIT_PARTIAL_HARD);\n  int result = jit_compile(code, options & ~excluded_options);\n  if (result != 0)\n    return result;\n  }\n\nif ((options & PCRE2_JIT_PARTIAL_SOFT) != 0 && (functions == NULL\n    || functions->executable_funcs\u00dd1\u00a8 == NULL)) {\n  uint32_t excluded_options = (PCRE2_JIT_COMPLETE | PCRE2_JIT_PARTIAL_HARD);\n  int result = jit_compile(code, options & ~excluded_options);\n  if (result != 0)\n    return result;\n  }\n\nif ((options & PCRE2_JIT_PARTIAL_HARD) != 0 && (functions == NULL\n    || functions->executable_funcs\u00dd2\u00a8 == NULL)) {\n  uint32_t excluded_options = (PCRE2_JIT_COMPLETE | PCRE2_JIT_PARTIAL_SOFT);\n  int result = jit_compile(code, options & ~excluded_options);\n  if (result != 0)\n    return result;\n  }\n\nreturn 0;\n\n#endif  /* SUPPORT_JIT */\n}\n\n/* JIT compiler uses an all-in-one approach. This improves security,\n   since the code generator functions are not exported. */\n\n#define INCLUDED_FROM_PCRE2_JIT_COMPILE\n\n#include \"JITMATC2.c\"\n#include \"JITMISC2.c\"\n\n/* End of pcre2_jit_compile.c */\n/*autoconv-0001 C:\\projects\\pcre2-10.35\\src\\pcre2_jit_compile.c converted to JITCOMP2*/\n/*autoconv-0011 JITCOMP2 line: 43 config.h replaced by CONFIG.h*/\n/*autoconv-0011 JITCOMP2 line: 46 pcre2_internal.h replaced by INTERNA2.h*/\n/*autoconv-0011 JITCOMP2 line: 5783 pcre2_jit_simd_inc.h replaced by JITSIMD2.h*/\n/*autoconv-0011 JITCOMP2 line: 14151 pcre2_jit_match.c replaced by JITMATC2.c*/\n/*autoconv-0011 JITCOMP2 line: 14152 pcre2_jit_misc.c replaced by JITMISC2.c*/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "JITMATC2": {"ttr": 5126, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "\n/*************************************************\n*      Perl-Compatible Regular Expressions       *\n*************************************************/\n\n/* PCRE is a library of functions to support regular expressions whose syntax\nand semantics are as close as possible to those of the Perl 5 language.\n\n                       Written by Philip Hazel\n     Original API code Copyright (c) 1997-2012 University of Cambridge\n          New API code Copyright (c) 2016-2018 University of Cambridge\n\n-----------------------------------------------------------------------------\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n\n    * Redistributions of source code must retain the above copyright notice,\n      this list of conditions and the following disclaimer.\n\n    * Redistributions in binary form must reproduce the above copyright\n      notice, this list of conditions and the following disclaimer in the\n      documentation and/or other materials provided with the distribution.\n\n    * Neither the name of the University of Cambridge nor the names of its\n      contributors may be used to endorse or promote products derived from\n      this software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\nAND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\nIMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\nARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\nLIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\nCONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\nSUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\nINTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\nCONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\nARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\nPOSSIBILITY OF SUCH DAMAGE.\n-----------------------------------------------------------------------------\n*/\n\n#ifndef INCLUDED_FROM_PCRE2_JIT_COMPILE\n#error This file must be included from pcre2_jit_compile.c.\n#endif\n\n#ifdef SUPPORT_JIT\n\nstatic SLJIT_NOINLINE int jit_machine_stack_exec(jit_arguments *arguments, jit_function executable_func)\n{\nsljit_u8 local_space\u00ddMACHINE_STACK_SIZE\u00a8;\nstruct sljit_stack local_stack;\n\nlocal_stack.min_start = local_space;\nlocal_stack.start = local_space;\nlocal_stack.end = local_space + MACHINE_STACK_SIZE;\nlocal_stack.top = local_space + MACHINE_STACK_SIZE;\narguments->stack = &local_stack;\nreturn executable_func(arguments);\n}\n\n#endif\n\n\n/*************************************************\n*              Do a JIT pattern match            *\n*************************************************/\n\n/* This function runs a JIT pattern match.\n\nArguments:\n  code            points to the compiled expression\n  subject         points to the subject string\n  length          length of subject string (may contain binary zeros)\n  start_offset    where to start in the subject string\n  options         option bits\n  match_data      points to a match_data block\n  mcontext        points to a match context\n\nReturns:          > 0 => success; value is the number of ovector pairs filled\n                  = 0 => success, but ovector is not big enough\n                   -1 => failed to match (PCRE_ERROR_NOMATCH)\n                 < -1 => some kind of unexpected problem\n*/\n\nPCRE2_EXP_DEFN int PCRE2_CALL_CONVENTION\npcre2_jit_match(const pcre2_code *code, PCRE2_SPTR subject, PCRE2_SIZE length,\n  PCRE2_SIZE start_offset, uint32_t options, pcre2_match_data *match_data,\n  pcre2_match_context *mcontext)\n{\n#ifndef SUPPORT_JIT\n\n(void)code;\n(void)subject;\n(void)length;\n(void)start_offset;\n(void)options;\n(void)match_data;\n(void)mcontext;\nreturn PCRE2_ERROR_JIT_BADOPTION;\n\n#else  /* SUPPORT_JIT */\n\npcre2_real_code *re = (pcre2_real_code *)code;\nexecutable_functions *functions = (executable_functions *)re->executable_jit;\npcre2_jit_stack *jit_stack;\nuint32_t oveccount = match_data->oveccount;\nuint32_t max_oveccount;\nunion {\n   void *executable_func;\n   jit_function call_executable_func;\n} convert_executable_func;\njit_arguments arguments;\nint rc;\nint index = 0;\n\nif ((options & PCRE2_PARTIAL_HARD) != 0)\n  index = 2;\nelse if ((options & PCRE2_PARTIAL_SOFT) != 0)\n  index = 1;\n\nif (functions == NULL || functions->executable_funcs\u00ddindex\u00a8 == NULL)\n  return PCRE2_ERROR_JIT_BADOPTION;\n\n/* Sanity checks should be handled by pcre_exec. */\narguments.str = subject + start_offset;\narguments.begin = subject;\narguments.end = subject + length;\narguments.match_data = match_data;\narguments.startchar_ptr = subject;\narguments.mark_ptr = NULL;\narguments.options = options;\n\nif (mcontext != NULL)\n  {\n  arguments.callout = mcontext->callout;\n  arguments.callout_data = mcontext->callout_data;\n  arguments.offset_limit = mcontext->offset_limit;\n  arguments.limit_match = (mcontext->match_limit < re->limit_match)?\n    mcontext->match_limit : re->limit_match;\n  if (mcontext->jit_callback != NULL)\n    jit_stack = mcontext->jit_callback(mcontext->jit_callback_data);\n  else\n    jit_stack = (pcre2_jit_stack *)mcontext->jit_callback_data;\n  }\nelse\n  {\n  arguments.callout = NULL;\n  arguments.callout_data = NULL;\n  arguments.offset_limit = PCRE2_UNSET;\n  arguments.limit_match = (MATCH_LIMIT < re->limit_match)?\n    MATCH_LIMIT : re->limit_match;\n  jit_stack = NULL;\n  }\n\n\nmax_oveccount = functions->top_bracket;\nif (oveccount > max_oveccount)\n  oveccount = max_oveccount;\narguments.oveccount = oveccount << 1;\n\n\nconvert_executable_func.executable_func = functions->executable_funcs\u00ddindex\u00a8;\nif (jit_stack != NULL)\n  {\n  arguments.stack = (struct sljit_stack *)(jit_stack->stack);\n  rc = convert_executable_func.call_executable_func(&arguments);\n  }\nelse\n  rc = jit_machine_stack_exec(&arguments, convert_executable_func.call_executable_func);\n\nif (rc > (int)oveccount)\n  rc = 0;\nmatch_data->code = re;\nmatch_data->subject = (rc >= 0 || rc == PCRE2_ERROR_PARTIAL)? subject : NULL;\nmatch_data->rc = rc;\nmatch_data->startchar = arguments.startchar_ptr - subject;\nmatch_data->leftchar = 0;\nmatch_data->rightchar = 0;\nmatch_data->mark = arguments.mark_ptr;\nmatch_data->matchedby = PCRE2_MATCHEDBY_JIT;\n\nreturn match_data->rc;\n\n#endif  /* SUPPORT_JIT */\n}\n\n/* End of pcre2_jit_match.c */\n/*autoconv-0001 C:\\projects\\pcre2-10.35\\src\\pcre2_jit_match.c converted to JITMATC2*/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "JITMISC2": {"ttr": 517, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "\n/*************************************************\n*      Perl-Compatible Regular Expressions       *\n*************************************************/\n\n/* PCRE is a library of functions to support regular expressions whose syntax\nand semantics are as close as possible to those of the Perl 5 language.\n\n                       Written by Philip Hazel\n     Original API code Copyright (c) 1997-2012 University of Cambridge\n         New API code Copyright (c) 2016 University of Cambridge\n\n-----------------------------------------------------------------------------\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n\n    * Redistributions of source code must retain the above copyright notice,\n      this list of conditions and the following disclaimer.\n\n    * Redistributions in binary form must reproduce the above copyright\n      notice, this list of conditions and the following disclaimer in the\n      documentation and/or other materials provided with the distribution.\n\n    * Neither the name of the University of Cambridge nor the names of its\n      contributors may be used to endorse or promote products derived from\n      this software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\nAND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\nIMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\nARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\nLIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\nCONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\nSUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\nINTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\nCONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\nARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\nPOSSIBILITY OF SUCH DAMAGE.\n-----------------------------------------------------------------------------\n*/\n\n\n#ifndef INCLUDED_FROM_PCRE2_JIT_COMPILE\n#error This file must be included from pcre2_jit_compile.c.\n#endif\n\n\n\n/*************************************************\n*           Free JIT read-only data              *\n*************************************************/\n\nvoid\nPRIV(jit_free_rodata)(void *current, void *allocator_data)\n{\n#ifndef SUPPORT_JIT\n(void)current;\n(void)allocator_data;\n#else  /* SUPPORT_JIT */\nvoid *next;\n\nSLJIT_UNUSED_ARG(allocator_data);\n\nwhile (current != NULL)\n  {\n  next = *(void**)current;\n  SLJIT_FREE(current, allocator_data);\n  current = next;\n  }\n\n#endif /* SUPPORT_JIT */\n}\n\n/*************************************************\n*           Free JIT compiled code               *\n*************************************************/\n\nvoid\nPRIV(jit_free)(void *executable_jit, pcre2_memctl *memctl)\n{\n#ifndef SUPPORT_JIT\n(void)executable_jit;\n(void)memctl;\n#else  /* SUPPORT_JIT */\n\nexecutable_functions *functions = (executable_functions *)executable_jit;\nvoid *allocator_data = memctl;\nint i;\n\nfor (i = 0; i < JIT_NUMBER_OF_COMPILE_MODES; i++)\n  {\n  if (functions->executable_funcs\u00ddi\u00a8 != NULL)\n    sljit_free_code(functions->executable_funcs\u00ddi\u00a8);\n  PRIV(jit_free_rodata)(functions->read_only_data_heads\u00ddi\u00a8, allocator_data);\n  }\n\nSLJIT_FREE(functions, allocator_data);\n\n#endif /* SUPPORT_JIT */\n}\n\n\n/*************************************************\n*            Free unused JIT memory              *\n*************************************************/\n\nPCRE2_EXP_DEFN void PCRE2_CALL_CONVENTION\npcre2_jit_free_unused_memory(pcre2_general_context *gcontext)\n{\n#ifndef SUPPORT_JIT\n(void)gcontext;     /* Suppress warning */\n#else  /* SUPPORT_JIT */\nSLJIT_UNUSED_ARG(gcontext);\nsljit_free_unused_memory_exec();\n#endif  /* SUPPORT_JIT */\n}\n\n\n\n/*************************************************\n*            Allocate a JIT stack                *\n*************************************************/\n\nPCRE2_EXP_DEFN pcre2_jit_stack * PCRE2_CALL_CONVENTION\npcre2_jit_stack_create(size_t startsize, size_t maxsize,\n  pcre2_general_context *gcontext)\n{\n#ifndef SUPPORT_JIT\n\n(void)gcontext;\n(void)startsize;\n(void)maxsize;\nreturn NULL;\n\n#else  /* SUPPORT_JIT */\n\npcre2_jit_stack *jit_stack;\n\nif (startsize < 1 || maxsize < 1)\n  return NULL;\nif (startsize > maxsize)\n  startsize = maxsize;\nstartsize = (startsize + STACK_GROWTH_RATE - 1) & ~(STACK_GROWTH_RATE - 1);\nmaxsize = (maxsize + STACK_GROWTH_RATE - 1) & ~(STACK_GROWTH_RATE - 1);\n\njit_stack = PRIV(memctl_malloc)(sizeof(pcre2_real_jit_stack), (pcre2_memctl *)gcontext);\nif (jit_stack == NULL) return NULL;\njit_stack->stack = sljit_allocate_stack(startsize, maxsize, &jit_stack->memctl);\nif (jit_stack->stack == NULL)\n  {\n  jit_stack->memctl.free(jit_stack, jit_stack->memctl.memory_data);\n  return NULL;\n  }\nreturn jit_stack;\n\n#endif\n}\n\n\n/*************************************************\n*         Assign a JIT stack to a pattern        *\n*************************************************/\n\nPCRE2_EXP_DEFN void PCRE2_CALL_CONVENTION\npcre2_jit_stack_assign(pcre2_match_context *mcontext, pcre2_jit_callback callback,\n  void *callback_data)\n{\n#ifndef SUPPORT_JIT\n(void)mcontext;\n(void)callback;\n(void)callback_data;\n#else  /* SUPPORT_JIT */\n\nif (mcontext == NULL) return;\nmcontext->jit_callback = callback;\nmcontext->jit_callback_data = callback_data;\n\n#endif  /* SUPPORT_JIT */\n}\n\n\n/*************************************************\n*               Free a JIT stack                 *\n*************************************************/\n\nPCRE2_EXP_DEFN void PCRE2_CALL_CONVENTION\npcre2_jit_stack_free(pcre2_jit_stack *jit_stack)\n{\n#ifndef SUPPORT_JIT\n(void)jit_stack;\n#else  /* SUPPORT_JIT */\nif (jit_stack != NULL)\n  {\n  sljit_free_stack((struct sljit_stack *)(jit_stack->stack), &jit_stack->memctl);\n  jit_stack->memctl.free(jit_stack, jit_stack->memctl.memory_data);\n  }\n#endif  /* SUPPORT_JIT */\n}\n\n\n/*************************************************\n*               Get target CPU type              *\n*************************************************/\n\nconst char*\nPRIV(jit_get_target)(void)\n{\n#ifndef SUPPORT_JIT\nreturn \"JIT is not supported\";\n#else  /* SUPPORT_JIT */\nreturn sljit_get_platform_name();\n#endif  /* SUPPORT_JIT */\n}\n\n\n/*************************************************\n*              Get size of JIT code              *\n*************************************************/\n\nsize_t\nPRIV(jit_get_size)(void *executable_jit)\n{\n#ifndef SUPPORT_JIT\n(void)executable_jit;\nreturn 0;\n#else  /* SUPPORT_JIT */\nsljit_uw *executable_sizes = ((executable_functions *)executable_jit)->executable_sizes;\nSLJIT_COMPILE_ASSERT(JIT_NUMBER_OF_COMPILE_MODES == 3, number_of_compile_modes_changed);\nreturn executable_sizes\u00dd0\u00a8 + executable_sizes\u00dd1\u00a8 + executable_sizes\u00dd2\u00a8;\n#endif\n}\n\n/* End of pcre2_jit_misc.c */\n/*autoconv-0001 C:\\projects\\pcre2-10.35\\src\\pcre2_jit_misc.c converted to JITMISC2*/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "JITNEON2": {"ttr": 1797, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "\n/*************************************************\n*      Perl-Compatible Regular Expressions       *\n*************************************************/\n\n/* PCRE is a library of functions to support regular expressions whose syntax\nand semantics are as close as possible to those of the Perl 5 language.\n\n                       Written by Philip Hazel\n            This module by Zoltan Herczeg and Sebastian Pop\n     Original API code Copyright (c) 1997-2012 University of Cambridge\n          New API code Copyright (c) 2016-2019 University of Cambridge\n\n-----------------------------------------------------------------------------\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n\n    * Redistributions of source code must retain the above copyright notice,\n      this list of conditions and the following disclaimer.\n\n    * Redistributions in binary form must reproduce the above copyright\n      notice, this list of conditions and the following disclaimer in the\n      documentation and/or other materials provided with the distribution.\n\n    * Neither the name of the University of Cambridge nor the names of its\n      contributors may be used to endorse or promote products derived from\n      this software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\nAND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\nIMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\nARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\nLIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\nCONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\nSUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\nINTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\nCONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\nARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\nPOSSIBILITY OF SUCH DAMAGE.\n-----------------------------------------------------------------------------\n*/\n\n# if defined(FFCS)\n#  if defined(FF_UTF)\n#   define FF_FUN ffcs_utf\n#  else\n#   define FF_FUN ffcs\n#  endif\n\n# elif defined(FFCS_2)\n#  if defined(FF_UTF)\n#   define FF_FUN ffcs_2_utf\n#  else\n#   define FF_FUN ffcs_2\n#  endif\n\n# elif defined(FFCS_MASK)\n#  if defined(FF_UTF)\n#   define FF_FUN ffcs_mask_utf\n#  else\n#   define FF_FUN ffcs_mask\n#  endif\n\n# elif defined(FFCPS_0)\n#  if defined (FF_UTF)\n#   define FF_FUN ffcps_0_utf\n#  else\n#   define FF_FUN ffcps_0\n#  endif\n\n# elif defined (FFCPS_1)\n#  if defined (FF_UTF)\n#   define FF_FUN ffcps_1_utf\n#  else\n#   define FF_FUN ffcps_1\n#  endif\n\n# elif defined (FFCPS_DEFAULT)\n#  if defined (FF_UTF)\n#   define FF_FUN ffcps_default_utf\n#  else\n#   define FF_FUN ffcps_default\n#  endif\n# endif\n\nstatic sljit_u8* SLJIT_FUNC FF_FUN(sljit_u8 *str_end, sljit_u8 *str_ptr, sljit_uw offs1, sljit_uw offs2, sljit_uw chars)\n#undef FF_FUN\n{\nquad_word qw;\nint_char ic;\nic.x = chars;\n\n#if defined(FFCS)\nsljit_u8 c1 = ic.c.c1;\nvect_t vc1 = VDUPQ(c1);\n\n#elif defined(FFCS_2)\nsljit_u8 c1 = ic.c.c1;\nvect_t vc1 = VDUPQ(c1);\nsljit_u8 c2 = ic.c.c2;\nvect_t vc2 = VDUPQ(c2);\n\n#elif defined(FFCS_MASK)\nsljit_u8 c1 = ic.c.c1;\nvect_t vc1 = VDUPQ(c1);\nsljit_u8 mask = ic.c.c2;\nvect_t vmask = VDUPQ(mask);\n#endif\n\n#if defined(FFCPS)\ncompare_type compare1_type = compare_match1;\ncompare_type compare2_type = compare_match1;\nvect_t cmp1a, cmp1b, cmp2a, cmp2b;\nconst sljit_u32 diff = IN_UCHARS(offs1 - offs2);\nPCRE2_UCHAR char1a = ic.c.c1;\nPCRE2_UCHAR char2a = ic.c.c3;\n\n# ifdef FFCPS_CHAR1A2A\ncmp1a = VDUPQ(char1a);\ncmp2a = VDUPQ(char2a);\ncmp1b = VDUPQ(0); /* to avoid errors on older compilers -Werror=maybe-uninitialized */\ncmp2b = VDUPQ(0); /* to avoid errors on older compilers -Werror=maybe-uninitialized */\n# else\nPCRE2_UCHAR char1b = ic.c.c2;\nPCRE2_UCHAR char2b = ic.c.c4;\nif (char1a == char1b)\n  {\n  cmp1a = VDUPQ(char1a);\n  cmp1b = VDUPQ(0); /* to avoid errors on older compilers -Werror=maybe-uninitialized */\n  }\nelse\n  {\n  sljit_u32 bit1 = char1a \u00ac char1b;\n  if (is_powerof2(bit1))\n    {\n    compare1_type = compare_match1i;\n    cmp1a = VDUPQ(char1a | bit1);\n    cmp1b = VDUPQ(bit1);\n    }\n  else\n    {\n    compare1_type = compare_match2;\n    cmp1a = VDUPQ(char1a);\n    cmp1b = VDUPQ(char1b);\n    }\n  }\n\nif (char2a == char2b)\n  {\n  cmp2a = VDUPQ(char2a);\n  cmp2b = VDUPQ(0); /* to avoid errors on older compilers -Werror=maybe-uninitialized */\n  }\nelse\n  {\n  sljit_u32 bit2 = char2a \u00ac char2b;\n  if (is_powerof2(bit2))\n    {\n    compare2_type = compare_match1i;\n    cmp2a = VDUPQ(char2a | bit2);\n    cmp2b = VDUPQ(bit2);\n    }\n  else\n    {\n    compare2_type = compare_match2;\n    cmp2a = VDUPQ(char2a);\n    cmp2b = VDUPQ(char2b);\n    }\n  }\n# endif\n\nstr_ptr += IN_UCHARS(offs1);\n#endif\n\n#if PCRE2_CODE_UNIT_WIDTH != 8\nvect_t char_mask = VDUPQ(0xff);\n#endif\n\n#if defined(FF_UTF)\nrestart:;\n#endif\n\n#if defined(FFCPS)\nsljit_u8 *p1 = str_ptr - diff;\n#endif\nsljit_s32 align_offset = ((uint64_t)str_ptr & 0xf);\nstr_ptr = (sljit_u8 *) ((uint64_t)str_ptr & ~0xf);\nvect_t data = VLD1Q(str_ptr);\n#if PCRE2_CODE_UNIT_WIDTH != 8\ndata = VANDQ(data, char_mask);\n#endif\n\n#if defined(FFCS)\nvect_t eq = VCEQQ(data, vc1);\n\n#elif defined(FFCS_2)\nvect_t eq1 = VCEQQ(data, vc1);\nvect_t eq2 = VCEQQ(data, vc2);\nvect_t eq = VORRQ(eq1, eq2);\n\n#elif defined(FFCS_MASK)\nvect_t eq = VORRQ(data, vmask);\neq = VCEQQ(eq, vc1);\n\n#elif defined(FFCPS)\n# if defined(FFCPS_DIFF1)\nvect_t prev_data = data;\n# endif\n\nvect_t data2;\nif (p1 < str_ptr)\n  {\n  data2 = VLD1Q(str_ptr - diff);\n#if PCRE2_CODE_UNIT_WIDTH != 8\n  data2 = VANDQ(data2, char_mask);\n#endif\n  }\nelse\n  data2 = shift_left_n_lanes(data, offs1 - offs2);\n\nif (compare1_type == compare_match1)\n  data = VCEQQ(data, cmp1a);\nelse\n  data = fast_forward_char_pair_compare(compare1_type, data, cmp1a, cmp1b);\n\nif (compare2_type == compare_match1)\n  data2 = VCEQQ(data2, cmp2a);\nelse\n  data2 = fast_forward_char_pair_compare(compare2_type, data2, cmp2a, cmp2b);\n\nvect_t eq = VANDQ(data, data2);\n#endif\n\nVST1Q(qw.mem, eq);\n/* Ignore matches before the first STR_PTR. */\nif (align_offset < 8)\n  {\n  qw.dw\u00dd0\u00a8 >>= align_offset * 8;\n  if (qw.dw\u00dd0\u00a8)\n    {\n    str_ptr += align_offset + __builtin_ctzll(qw.dw\u00dd0\u00a8) / 8;\n    goto match;\n    }\n  if (qw.dw\u00dd1\u00a8)\n    {\n    str_ptr += 8 + __builtin_ctzll(qw.dw\u00dd1\u00a8) / 8;\n    goto match;\n    }\n  }\nelse\n  {\n  qw.dw\u00dd1\u00a8 >>= (align_offset - 8) * 8;\n  if (qw.dw\u00dd1\u00a8)\n    {\n    str_ptr += align_offset + __builtin_ctzll(qw.dw\u00dd1\u00a8) / 8;\n    goto match;\n    }\n  }\nstr_ptr += 16;\n\nwhile (str_ptr < str_end)\n  {\n  vect_t orig_data = VLD1Q(str_ptr);\n#if PCRE2_CODE_UNIT_WIDTH != 8\n  orig_data = VANDQ(orig_data, char_mask);\n#endif\n  data = orig_data;\n\n#if defined(FFCS)\n  eq = VCEQQ(data, vc1);\n\n#elif defined(FFCS_2)\n  eq1 = VCEQQ(data, vc1);\n  eq2 = VCEQQ(data, vc2);\n  eq = VORRQ(eq1, eq2);\n\n#elif defined(FFCS_MASK)\n  eq = VORRQ(data, vmask);\n  eq = VCEQQ(eq, vc1);\n#endif\n\n#if defined(FFCPS)\n# if defined (FFCPS_DIFF1)\n  data2 = VEXTQ(prev_data, data, VECTOR_FACTOR - 1);\n# else\n  data2 = VLD1Q(str_ptr - diff);\n#  if PCRE2_CODE_UNIT_WIDTH != 8\n  data2 = VANDQ(data2, char_mask);\n#  endif\n# endif\n\n# ifdef FFCPS_CHAR1A2A\n  data = VCEQQ(data, cmp1a);\n  data2 = VCEQQ(data2, cmp2a);\n# else\n  if (compare1_type == compare_match1)\n    data = VCEQQ(data, cmp1a);\n  else\n    data = fast_forward_char_pair_compare(compare1_type, data, cmp1a, cmp1b);\n  if (compare2_type == compare_match1)\n    data2 = VCEQQ(data2, cmp2a);\n  else\n    data2 = fast_forward_char_pair_compare(compare2_type, data2, cmp2a, cmp2b);\n# endif\n\n  eq = VANDQ(data, data2);\n#endif\n\n  VST1Q(qw.mem, eq);\n  if (qw.dw\u00dd0\u00a8)\n    str_ptr += __builtin_ctzll(qw.dw\u00dd0\u00a8) / 8;\n  else if (qw.dw\u00dd1\u00a8)\n    str_ptr += 8 + __builtin_ctzll(qw.dw\u00dd1\u00a8) / 8;\n  else {\n    str_ptr += 16;\n#if defined (FFCPS_DIFF1)\n    prev_data = orig_data;\n#endif\n    continue;\n  }\n\nmatch:;\n  if (str_ptr >= str_end)\n    /* Failed match. */\n    return NULL;\n\n#if defined(FF_UTF)\n  if (utf_continue(str_ptr + IN_UCHARS(-offs1)))\n    {\n    /* Not a match. */\n    str_ptr += IN_UCHARS(1);\n    goto restart;\n    }\n#endif\n\n  /* Match. */\n#if defined (FFCPS)\n  str_ptr -= IN_UCHARS(offs1);\n#endif\n  return str_ptr;\n  }\n\n/* Failed match. */\nreturn NULL;\n}\n/*autoconv-0001 C:\\projects\\pcre2-10.35\\src\\pcre2_jit_neon_inc.h converted to JITNEON2*/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "JITSIMD2": {"ttr": 3841, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "\n/*************************************************\n*      Perl-Compatible Regular Expressions       *\n*************************************************/\n\n/* PCRE is a library of functions to support regular expressions whose syntax\nand semantics are as close as possible to those of the Perl 5 language.\n\n                       Written by Philip Hazel\n                    This module by Zoltan Herczeg\n     Original API code Copyright (c) 1997-2012 University of Cambridge\n          New API code Copyright (c) 2016-2019 University of Cambridge\n\n-----------------------------------------------------------------------------\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n\n    * Redistributions of source code must retain the above copyright notice,\n      this list of conditions and the following disclaimer.\n\n    * Redistributions in binary form must reproduce the above copyright\n      notice, this list of conditions and the following disclaimer in the\n      documentation and/or other materials provided with the distribution.\n\n    * Neither the name of the University of Cambridge nor the names of its\n      contributors may be used to endorse or promote products derived from\n      this software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\nAND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\nIMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\nARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\nLIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\nCONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\nSUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\nINTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\nCONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\nARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\nPOSSIBILITY OF SUCH DAMAGE.\n-----------------------------------------------------------------------------\n*/\n\n#if (defined SLJIT_CONFIG_X86 && SLJIT_CONFIG_X86) && !(defined SUPPORT_VALGRIND)\n\n#if defined SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH != 32\nstatic struct sljit_jump *jump_if_utf_char_start(struct sljit_compiler *compiler, sljit_s32 reg)\n{\n#if PCRE2_CODE_UNIT_WIDTH == 8\nOP2(SLJIT_AND, reg, 0, reg, 0, SLJIT_IMM, 0xc0);\nreturn CMP(SLJIT_NOT_EQUAL, reg, 0, SLJIT_IMM, 0x80);\n#elif PCRE2_CODE_UNIT_WIDTH == 16\nOP2(SLJIT_AND, reg, 0, reg, 0, SLJIT_IMM, 0xfc00);\nreturn CMP(SLJIT_NOT_EQUAL, reg, 0, SLJIT_IMM, 0xdc00);\n#else\n#error \"Unknown code width\"\n#endif\n}\n#endif\n\nstatic sljit_s32 character_to_int32(PCRE2_UCHAR chr)\n{\nsljit_u32 value = chr;\n#if PCRE2_CODE_UNIT_WIDTH == 8\n#define SSE2_COMPARE_TYPE_INDEX 0\nreturn (sljit_s32)((value << 24) | (value << 16) | (value << 8) | value);\n#elif PCRE2_CODE_UNIT_WIDTH == 16\n#define SSE2_COMPARE_TYPE_INDEX 1\nreturn (sljit_s32)((value << 16) | value);\n#elif PCRE2_CODE_UNIT_WIDTH == 32\n#define SSE2_COMPARE_TYPE_INDEX 2\nreturn (sljit_s32)(value);\n#else\n#error \"Unsupported unit width\"\n#endif\n}\n\nstatic void load_from_mem_sse2(struct sljit_compiler *compiler, sljit_s32 dst_xmm_reg, sljit_s32 src_general_reg, sljit_s8 offset)\n{\nsljit_u8 instruction\u00dd5\u00a8;\n\nSLJIT_ASSERT(dst_xmm_reg < 8);\nSLJIT_ASSERT(src_general_reg < 8);\n\n/* MOVDQA xmm1, xmm2/m128 */\ninstruction\u00dd0\u00a8 = ((sljit_u8)offset & 0xf) == 0 ? 0x66 : 0xf3;\ninstruction\u00dd1\u00a8 = 0x0f;\ninstruction\u00dd2\u00a8 = 0x6f;\n\nif (offset == 0)\n  {\n  instruction\u00dd3\u00a8 = (dst_xmm_reg << 3) | src_general_reg;\n  sljit_emit_op_custom(compiler, instruction, 4);\n  return;\n  }\n\ninstruction\u00dd3\u00a8 = 0x40 | (dst_xmm_reg << 3) | src_general_reg;\ninstruction\u00dd4\u00a8 = (sljit_u8)offset;\nsljit_emit_op_custom(compiler, instruction, 5);\n}\n\ntypedef enum {\n    sse2_compare_match1,\n    sse2_compare_match1i,\n    sse2_compare_match2,\n} sse2_compare_type;\n\nstatic void fast_forward_char_pair_sse2_compare(struct sljit_compiler *compiler, sse2_compare_type compare_type,\n  int step, sljit_s32 dst_ind, sljit_s32 cmp1_ind, sljit_s32 cmp2_ind, sljit_s32 tmp_ind)\n{\nsljit_u8 instruction\u00dd4\u00a8;\ninstruction\u00dd0\u00a8 = 0x66;\ninstruction\u00dd1\u00a8 = 0x0f;\n\nSLJIT_ASSERT(step >= 0 && step <= 3);\n\nif (compare_type != sse2_compare_match2)\n  {\n  if (step == 0)\n    {\n    if (compare_type == sse2_compare_match1i)\n      {\n      /* POR xmm1, xmm2/m128 */\n      /* instruction\u00dd0\u00a8 = 0x66; */\n      /* instruction\u00dd1\u00a8 = 0x0f; */\n      instruction\u00dd2\u00a8 = 0xeb;\n      instruction\u00dd3\u00a8 = 0xc0 | (dst_ind << 3) | cmp2_ind;\n      sljit_emit_op_custom(compiler, instruction, 4);\n      }\n    return;\n    }\n\n  if (step != 2)\n    return;\n\n  /* PCMPEQB/W/D xmm1, xmm2/m128 */\n  /* instruction\u00dd0\u00a8 = 0x66; */\n  /* instruction\u00dd1\u00a8 = 0x0f; */\n  instruction\u00dd2\u00a8 = 0x74 + SSE2_COMPARE_TYPE_INDEX;\n  instruction\u00dd3\u00a8 = 0xc0 | (dst_ind << 3) | cmp1_ind;\n  sljit_emit_op_custom(compiler, instruction, 4);\n  return;\n  }\n\nswitch (step)\n  {\n  case 0:\n  /* MOVDQA xmm1, xmm2/m128 */\n  /* instruction\u00dd0\u00a8 = 0x66; */\n  /* instruction\u00dd1\u00a8 = 0x0f; */\n  instruction\u00dd2\u00a8 = 0x6f;\n  instruction\u00dd3\u00a8 = 0xc0 | (tmp_ind << 3) | dst_ind;\n  sljit_emit_op_custom(compiler, instruction, 4);\n  return;\n\n  case 1:\n  /* PCMPEQB/W/D xmm1, xmm2/m128 */\n  /* instruction\u00dd0\u00a8 = 0x66; */\n  /* instruction\u00dd1\u00a8 = 0x0f; */\n  instruction\u00dd2\u00a8 = 0x74 + SSE2_COMPARE_TYPE_INDEX;\n  instruction\u00dd3\u00a8 = 0xc0 | (dst_ind << 3) | cmp1_ind;\n  sljit_emit_op_custom(compiler, instruction, 4);\n  return;\n\n  case 2:\n  /* PCMPEQB/W/D xmm1, xmm2/m128 */\n  /* instruction\u00dd0\u00a8 = 0x66; */\n  /* instruction\u00dd1\u00a8 = 0x0f; */\n  instruction\u00dd2\u00a8 = 0x74 + SSE2_COMPARE_TYPE_INDEX;\n  instruction\u00dd3\u00a8 = 0xc0 | (tmp_ind << 3) | cmp2_ind;\n  sljit_emit_op_custom(compiler, instruction, 4);\n  return;\n\n  case 3:\n  /* POR xmm1, xmm2/m128 */\n  /* instruction\u00dd0\u00a8 = 0x66; */\n  /* instruction\u00dd1\u00a8 = 0x0f; */\n  instruction\u00dd2\u00a8 = 0xeb;\n  instruction\u00dd3\u00a8 = 0xc0 | (dst_ind << 3) | tmp_ind;\n  sljit_emit_op_custom(compiler, instruction, 4);\n  return;\n  }\n}\n\n#define JIT_HAS_FAST_FORWARD_CHAR_SIMD (sljit_has_cpu_feature(SLJIT_HAS_SSE2))\n\nstatic void fast_forward_char_simd(compiler_common *common, PCRE2_UCHAR char1, PCRE2_UCHAR char2, sljit_s32 offset)\n{\nDEFINE_COMPILER;\nstruct sljit_label *start;\n#if defined SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH != 32\nstruct sljit_label *restart;\n#endif\nstruct sljit_jump *quit;\nstruct sljit_jump *partial_quit\u00dd2\u00a8;\nsse2_compare_type compare_type = sse2_compare_match1;\nsljit_u8 instruction\u00dd8\u00a8;\nsljit_s32 tmp1_reg_ind = sljit_get_register_index(TMP1);\nsljit_s32 str_ptr_reg_ind = sljit_get_register_index(STR_PTR);\nsljit_s32 data_ind = 0;\nsljit_s32 tmp_ind = 1;\nsljit_s32 cmp1_ind = 2;\nsljit_s32 cmp2_ind = 3;\nsljit_u32 bit = 0;\nint i;\n\nSLJIT_UNUSED_ARG(offset);\n\nif (char1 != char2)\n  {\n  bit = char1 \u00ac char2;\n  compare_type = sse2_compare_match1i;\n\n  if (!is_powerof2(bit))\n    {\n    bit = 0;\n    compare_type = sse2_compare_match2;\n    }\n  }\n\npartial_quit\u00dd0\u00a8 = CMP(SLJIT_GREATER_EQUAL, STR_PTR, 0, STR_END, 0);\nif (common->mode == PCRE2_JIT_COMPLETE)\n  add_jump(compiler, &common->failed_match, partial_quit\u00dd0\u00a8);\n\n/* First part (unaligned start) */\n\nOP1(SLJIT_MOV, TMP1, 0, SLJIT_IMM, character_to_int32(char1 | bit));\n\nSLJIT_ASSERT(tmp1_reg_ind < 8);\n\n/* MOVD xmm, r/m32 */\ninstruction\u00dd0\u00a8 = 0x66;\ninstruction\u00dd1\u00a8 = 0x0f;\ninstruction\u00dd2\u00a8 = 0x6e;\ninstruction\u00dd3\u00a8 = 0xc0 | (cmp1_ind << 3) | tmp1_reg_ind;\nsljit_emit_op_custom(compiler, instruction, 4);\n\nif (char1 != char2)\n  {\n  OP1(SLJIT_MOV, TMP1, 0, SLJIT_IMM, character_to_int32(bit != 0 ? bit : char2));\n\n  /* MOVD xmm, r/m32 */\n  instruction\u00dd3\u00a8 = 0xc0 | (cmp2_ind << 3) | tmp1_reg_ind;\n  sljit_emit_op_custom(compiler, instruction, 4);\n  }\n\nOP1(SLJIT_MOV, TMP2, 0, STR_PTR, 0);\n\n/* PSHUFD xmm1, xmm2/m128, imm8 */\n/* instruction\u00dd0\u00a8 = 0x66; */\n/* instruction\u00dd1\u00a8 = 0x0f; */\ninstruction\u00dd2\u00a8 = 0x70;\ninstruction\u00dd3\u00a8 = 0xc0 | (cmp1_ind << 3) | cmp1_ind;\ninstruction\u00dd4\u00a8 = 0;\nsljit_emit_op_custom(compiler, instruction, 5);\n\nif (char1 != char2)\n  {\n  /* PSHUFD xmm1, xmm2/m128, imm8 */\n  instruction\u00dd3\u00a8 = 0xc0 | (cmp2_ind << 3) | cmp2_ind;\n  sljit_emit_op_custom(compiler, instruction, 5);\n  }\n\n#if defined SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH != 32\nrestart = LABEL();\n#endif\nOP2(SLJIT_AND, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, ~0xf);\nOP2(SLJIT_AND, TMP2, 0, TMP2, 0, SLJIT_IMM, 0xf);\n\nload_from_mem_sse2(compiler, data_ind, str_ptr_reg_ind, 0);\nfor (i = 0; i < 4; i++)\n  fast_forward_char_pair_sse2_compare(compiler, compare_type, i, data_ind, cmp1_ind, cmp2_ind, tmp_ind);\n\n/* PMOVMSKB reg, xmm */\n/* instruction\u00dd0\u00a8 = 0x66; */\n/* instruction\u00dd1\u00a8 = 0x0f; */\ninstruction\u00dd2\u00a8 = 0xd7;\ninstruction\u00dd3\u00a8 = 0xc0 | (tmp1_reg_ind << 3) | data_ind;\nsljit_emit_op_custom(compiler, instruction, 4);\n\nOP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, TMP2, 0);\nOP2(SLJIT_LSHR, TMP1, 0, TMP1, 0, TMP2, 0);\n\nquit = CMP(SLJIT_NOT_ZERO, TMP1, 0, SLJIT_IMM, 0);\n\nOP2(SLJIT_SUB, STR_PTR, 0, STR_PTR, 0, TMP2, 0);\n\n/* Second part (aligned) */\nstart = LABEL();\n\nOP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, 16);\n\npartial_quit\u00dd1\u00a8 = CMP(SLJIT_GREATER_EQUAL, STR_PTR, 0, STR_END, 0);\nif (common->mode == PCRE2_JIT_COMPLETE)\n  add_jump(compiler, &common->failed_match, partial_quit\u00dd1\u00a8);\n\nload_from_mem_sse2(compiler, data_ind, str_ptr_reg_ind, 0);\nfor (i = 0; i < 4; i++)\n  fast_forward_char_pair_sse2_compare(compiler, compare_type, i, data_ind, cmp1_ind, cmp2_ind, tmp_ind);\n\n/* PMOVMSKB reg, xmm */\n/* instruction\u00dd0\u00a8 = 0x66; */\n/* instruction\u00dd1\u00a8 = 0x0f; */\ninstruction\u00dd2\u00a8 = 0xd7;\ninstruction\u00dd3\u00a8 = 0xc0 | (tmp1_reg_ind << 3) | data_ind;\nsljit_emit_op_custom(compiler, instruction, 4);\n\nCMPTO(SLJIT_ZERO, TMP1, 0, SLJIT_IMM, 0, start);\n\nJUMPHERE(quit);\n\n/* BSF r32, r/m32 */\ninstruction\u00dd0\u00a8 = 0x0f;\ninstruction\u00dd1\u00a8 = 0xbc;\ninstruction\u00dd2\u00a8 = 0xc0 | (tmp1_reg_ind << 3) | tmp1_reg_ind;\nsljit_emit_op_custom(compiler, instruction, 3);\n\nOP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, TMP1, 0);\n\nif (common->mode != PCRE2_JIT_COMPLETE)\n  {\n  JUMPHERE(partial_quit\u00dd0\u00a8);\n  JUMPHERE(partial_quit\u00dd1\u00a8);\n  OP2(SLJIT_SUB | SLJIT_SET_GREATER, SLJIT_UNUSED, 0, STR_PTR, 0, STR_END, 0);\n  CMOV(SLJIT_GREATER, STR_PTR, STR_END, 0);\n  }\nelse\n  add_jump(compiler, &common->failed_match, CMP(SLJIT_GREATER_EQUAL, STR_PTR, 0, STR_END, 0));\n\n#if defined SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH != 32\nif (common->utf && offset > 0)\n  {\n  SLJIT_ASSERT(common->mode == PCRE2_JIT_COMPLETE);\n\n  OP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(-offset));\n\n  quit = jump_if_utf_char_start(compiler, TMP1);\n\n  OP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n  add_jump(compiler, &common->failed_match, CMP(SLJIT_GREATER_EQUAL, STR_PTR, 0, STR_END, 0));\n  OP1(SLJIT_MOV, TMP2, 0, STR_PTR, 0);\n  JUMPTO(SLJIT_JUMP, restart);\n\n  JUMPHERE(quit);\n  }\n#endif\n}\n\n#define JIT_HAS_FAST_REQUESTED_CHAR_SIMD (sljit_has_cpu_feature(SLJIT_HAS_SSE2))\n\nstatic jump_list *fast_requested_char_simd(compiler_common *common, PCRE2_UCHAR char1, PCRE2_UCHAR char2)\n{\nDEFINE_COMPILER;\nstruct sljit_label *start;\nstruct sljit_jump *quit;\njump_list *not_found = NULL;\nsse2_compare_type compare_type = sse2_compare_match1;\nsljit_u8 instruction\u00dd8\u00a8;\nsljit_s32 tmp1_reg_ind = sljit_get_register_index(TMP1);\nsljit_s32 str_ptr_reg_ind = sljit_get_register_index(STR_PTR);\nsljit_s32 data_ind = 0;\nsljit_s32 tmp_ind = 1;\nsljit_s32 cmp1_ind = 2;\nsljit_s32 cmp2_ind = 3;\nsljit_u32 bit = 0;\nint i;\n\nif (char1 != char2)\n  {\n  bit = char1 \u00ac char2;\n  compare_type = sse2_compare_match1i;\n\n  if (!is_powerof2(bit))\n    {\n    bit = 0;\n    compare_type = sse2_compare_match2;\n    }\n  }\n\nadd_jump(compiler, &not_found, CMP(SLJIT_GREATER_EQUAL, TMP1, 0, STR_END, 0));\nOP1(SLJIT_MOV, TMP2, 0, TMP1, 0);\nOP1(SLJIT_MOV, TMP3, 0, STR_PTR, 0);\n\n/* First part (unaligned start) */\n\nOP1(SLJIT_MOV, TMP1, 0, SLJIT_IMM, character_to_int32(char1 | bit));\n\nSLJIT_ASSERT(tmp1_reg_ind < 8);\n\n/* MOVD xmm, r/m32 */\ninstruction\u00dd0\u00a8 = 0x66;\ninstruction\u00dd1\u00a8 = 0x0f;\ninstruction\u00dd2\u00a8 = 0x6e;\ninstruction\u00dd3\u00a8 = 0xc0 | (cmp1_ind << 3) | tmp1_reg_ind;\nsljit_emit_op_custom(compiler, instruction, 4);\n\nif (char1 != char2)\n  {\n  OP1(SLJIT_MOV, TMP1, 0, SLJIT_IMM, character_to_int32(bit != 0 ? bit : char2));\n\n  /* MOVD xmm, r/m32 */\n  instruction\u00dd3\u00a8 = 0xc0 | (cmp2_ind << 3) | tmp1_reg_ind;\n  sljit_emit_op_custom(compiler, instruction, 4);\n  }\n\nOP1(SLJIT_MOV, STR_PTR, 0, TMP2, 0);\n\n/* PSHUFD xmm1, xmm2/m128, imm8 */\n/* instruction\u00dd0\u00a8 = 0x66; */\n/* instruction\u00dd1\u00a8 = 0x0f; */\ninstruction\u00dd2\u00a8 = 0x70;\ninstruction\u00dd3\u00a8 = 0xc0 | (cmp1_ind << 3) | cmp1_ind;\ninstruction\u00dd4\u00a8 = 0;\nsljit_emit_op_custom(compiler, instruction, 5);\n\nif (char1 != char2)\n  {\n  /* PSHUFD xmm1, xmm2/m128, imm8 */\n  instruction\u00dd3\u00a8 = 0xc0 | (cmp2_ind << 3) | cmp2_ind;\n  sljit_emit_op_custom(compiler, instruction, 5);\n  }\n\nOP2(SLJIT_AND, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, ~0xf);\nOP2(SLJIT_AND, TMP2, 0, TMP2, 0, SLJIT_IMM, 0xf);\n\nload_from_mem_sse2(compiler, data_ind, str_ptr_reg_ind, 0);\nfor (i = 0; i < 4; i++)\n  fast_forward_char_pair_sse2_compare(compiler, compare_type, i, data_ind, cmp1_ind, cmp2_ind, tmp_ind);\n\n/* PMOVMSKB reg, xmm */\n/* instruction\u00dd0\u00a8 = 0x66; */\n/* instruction\u00dd1\u00a8 = 0x0f; */\ninstruction\u00dd2\u00a8 = 0xd7;\ninstruction\u00dd3\u00a8 = 0xc0 | (tmp1_reg_ind << 3) | data_ind;\nsljit_emit_op_custom(compiler, instruction, 4);\n\nOP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, TMP2, 0);\nOP2(SLJIT_LSHR, TMP1, 0, TMP1, 0, TMP2, 0);\n\nquit = CMP(SLJIT_NOT_ZERO, TMP1, 0, SLJIT_IMM, 0);\n\nOP2(SLJIT_SUB, STR_PTR, 0, STR_PTR, 0, TMP2, 0);\n\n/* Second part (aligned) */\nstart = LABEL();\n\nOP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, 16);\n\nadd_jump(compiler, &not_found, CMP(SLJIT_GREATER_EQUAL, STR_PTR, 0, STR_END, 0));\n\nload_from_mem_sse2(compiler, data_ind, str_ptr_reg_ind, 0);\nfor (i = 0; i < 4; i++)\n  fast_forward_char_pair_sse2_compare(compiler, compare_type, i, data_ind, cmp1_ind, cmp2_ind, tmp_ind);\n\n/* PMOVMSKB reg, xmm */\n/* instruction\u00dd0\u00a8 = 0x66; */\n/* instruction\u00dd1\u00a8 = 0x0f; */\ninstruction\u00dd2\u00a8 = 0xd7;\ninstruction\u00dd3\u00a8 = 0xc0 | (tmp1_reg_ind << 3) | data_ind;\nsljit_emit_op_custom(compiler, instruction, 4);\n\nCMPTO(SLJIT_ZERO, TMP1, 0, SLJIT_IMM, 0, start);\n\nJUMPHERE(quit);\n\n/* BSF r32, r/m32 */\ninstruction\u00dd0\u00a8 = 0x0f;\ninstruction\u00dd1\u00a8 = 0xbc;\ninstruction\u00dd2\u00a8 = 0xc0 | (tmp1_reg_ind << 3) | tmp1_reg_ind;\nsljit_emit_op_custom(compiler, instruction, 3);\n\nOP2(SLJIT_ADD, TMP1, 0, TMP1, 0, STR_PTR, 0);\nadd_jump(compiler, &not_found, CMP(SLJIT_GREATER_EQUAL, TMP1, 0, STR_END, 0));\n\nOP1(SLJIT_MOV, STR_PTR, 0, TMP3, 0);\nreturn not_found;\n}\n\n#ifndef _WIN64\n\nstatic SLJIT_INLINE sljit_u32 max_fast_forward_char_pair_offset(void)\n{\n#if PCRE2_CODE_UNIT_WIDTH == 8\nreturn 15;\n#elif PCRE2_CODE_UNIT_WIDTH == 16\nreturn 7;\n#elif PCRE2_CODE_UNIT_WIDTH == 32\nreturn 3;\n#else\n#error \"Unsupported unit width\"\n#endif\n}\n\n#define JIT_HAS_FAST_FORWARD_CHAR_PAIR_SIMD (sljit_has_cpu_feature(SLJIT_HAS_SSE2))\n\nstatic void fast_forward_char_pair_simd(compiler_common *common, sljit_s32 offs1,\n  PCRE2_UCHAR char1a, PCRE2_UCHAR char1b, sljit_s32 offs2, PCRE2_UCHAR char2a, PCRE2_UCHAR char2b)\n{\nDEFINE_COMPILER;\nsse2_compare_type compare1_type = sse2_compare_match1;\nsse2_compare_type compare2_type = sse2_compare_match1;\nsljit_u32 bit1 = 0;\nsljit_u32 bit2 = 0;\nsljit_u32 diff = IN_UCHARS(offs1 - offs2);\nsljit_s32 tmp1_reg_ind = sljit_get_register_index(TMP1);\nsljit_s32 tmp2_reg_ind = sljit_get_register_index(TMP2);\nsljit_s32 str_ptr_reg_ind = sljit_get_register_index(STR_PTR);\nsljit_s32 data1_ind = 0;\nsljit_s32 data2_ind = 1;\nsljit_s32 tmp1_ind = 2;\nsljit_s32 tmp2_ind = 3;\nsljit_s32 cmp1a_ind = 4;\nsljit_s32 cmp1b_ind = 5;\nsljit_s32 cmp2a_ind = 6;\nsljit_s32 cmp2b_ind = 7;\nstruct sljit_label *start;\n#if defined SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH != 32\nstruct sljit_label *restart;\n#endif\nstruct sljit_jump *jump\u00dd2\u00a8;\nsljit_u8 instruction\u00dd8\u00a8;\nint i;\n\nSLJIT_ASSERT(common->mode == PCRE2_JIT_COMPLETE && offs1 > offs2);\nSLJIT_ASSERT(diff <= IN_UCHARS(max_fast_forward_char_pair_offset()));\nSLJIT_ASSERT(tmp1_reg_ind < 8 && tmp2_reg_ind == 1);\n\n/* Initialize. */\nif (common->match_end_ptr != 0)\n  {\n  OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(SLJIT_SP), common->match_end_ptr);\n  OP1(SLJIT_MOV, TMP3, 0, STR_END, 0);\n  OP2(SLJIT_ADD, TMP1, 0, TMP1, 0, SLJIT_IMM, IN_UCHARS(offs1 + 1));\n\n  OP2(SLJIT_SUB | SLJIT_SET_LESS, SLJIT_UNUSED, 0, TMP1, 0, STR_END, 0);\n  CMOV(SLJIT_LESS, STR_END, TMP1, 0);\n  }\n\nOP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(offs1));\nadd_jump(compiler, &common->failed_match, CMP(SLJIT_GREATER_EQUAL, STR_PTR, 0, STR_END, 0));\n\n/* MOVD xmm, r/m32 */\ninstruction\u00dd0\u00a8 = 0x66;\ninstruction\u00dd1\u00a8 = 0x0f;\ninstruction\u00dd2\u00a8 = 0x6e;\n\nif (char1a == char1b)\n  OP1(SLJIT_MOV, TMP1, 0, SLJIT_IMM, character_to_int32(char1a));\nelse\n  {\n  bit1 = char1a \u00ac char1b;\n  if (is_powerof2(bit1))\n    {\n    compare1_type = sse2_compare_match1i;\n    OP1(SLJIT_MOV, TMP1, 0, SLJIT_IMM, character_to_int32(char1a | bit1));\n    OP1(SLJIT_MOV, TMP2, 0, SLJIT_IMM, character_to_int32(bit1));\n    }\n  else\n    {\n    compare1_type = sse2_compare_match2;\n    bit1 = 0;\n    OP1(SLJIT_MOV, TMP1, 0, SLJIT_IMM, character_to_int32(char1a));\n    OP1(SLJIT_MOV, TMP2, 0, SLJIT_IMM, character_to_int32(char1b));\n    }\n  }\n\ninstruction\u00dd3\u00a8 = 0xc0 | (cmp1a_ind << 3) | tmp1_reg_ind;\nsljit_emit_op_custom(compiler, instruction, 4);\n\nif (char1a != char1b)\n  {\n  instruction\u00dd3\u00a8 = 0xc0 | (cmp1b_ind << 3) | tmp2_reg_ind;\n  sljit_emit_op_custom(compiler, instruction, 4);\n  }\n\nif (char2a == char2b)\n  OP1(SLJIT_MOV, TMP1, 0, SLJIT_IMM, character_to_int32(char2a));\nelse\n  {\n  bit2 = char2a \u00ac char2b;\n  if (is_powerof2(bit2))\n    {\n    compare2_type = sse2_compare_match1i;\n    OP1(SLJIT_MOV, TMP1, 0, SLJIT_IMM, character_to_int32(char2a | bit2));\n    OP1(SLJIT_MOV, TMP2, 0, SLJIT_IMM, character_to_int32(bit2));\n    }\n  else\n    {\n    compare2_type = sse2_compare_match2;\n    bit2 = 0;\n    OP1(SLJIT_MOV, TMP1, 0, SLJIT_IMM, character_to_int32(char2a));\n    OP1(SLJIT_MOV, TMP2, 0, SLJIT_IMM, character_to_int32(char2b));\n    }\n  }\n\ninstruction\u00dd3\u00a8 = 0xc0 | (cmp2a_ind << 3) | tmp1_reg_ind;\nsljit_emit_op_custom(compiler, instruction, 4);\n\nif (char2a != char2b)\n  {\n  instruction\u00dd3\u00a8 = 0xc0 | (cmp2b_ind << 3) | tmp2_reg_ind;\n  sljit_emit_op_custom(compiler, instruction, 4);\n  }\n\n/* PSHUFD xmm1, xmm2/m128, imm8 */\n/* instruction\u00dd0\u00a8 = 0x66; */\n/* instruction\u00dd1\u00a8 = 0x0f; */\ninstruction\u00dd2\u00a8 = 0x70;\ninstruction\u00dd4\u00a8 = 0;\n\ninstruction\u00dd3\u00a8 = 0xc0 | (cmp1a_ind << 3) | cmp1a_ind;\nsljit_emit_op_custom(compiler, instruction, 5);\n\nif (char1a != char1b)\n  {\n  instruction\u00dd3\u00a8 = 0xc0 | (cmp1b_ind << 3) | cmp1b_ind;\n  sljit_emit_op_custom(compiler, instruction, 5);\n  }\n\ninstruction\u00dd3\u00a8 = 0xc0 | (cmp2a_ind << 3) | cmp2a_ind;\nsljit_emit_op_custom(compiler, instruction, 5);\n\nif (char2a != char2b)\n  {\n  instruction\u00dd3\u00a8 = 0xc0 | (cmp2b_ind << 3) | cmp2b_ind;\n  sljit_emit_op_custom(compiler, instruction, 5);\n  }\n\n#if defined SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH != 32\nrestart = LABEL();\n#endif\n\nOP2(SLJIT_SUB, TMP1, 0, STR_PTR, 0, SLJIT_IMM, diff);\nOP1(SLJIT_MOV, TMP2, 0, STR_PTR, 0);\nOP2(SLJIT_AND, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, ~0xf);\n\nload_from_mem_sse2(compiler, data1_ind, str_ptr_reg_ind, 0);\n\njump\u00dd0\u00a8 = CMP(SLJIT_GREATER_EQUAL, TMP1, 0, STR_PTR, 0);\n\nload_from_mem_sse2(compiler, data2_ind, str_ptr_reg_ind, -(sljit_s8)diff);\njump\u00dd1\u00a8 = JUMP(SLJIT_JUMP);\n\nJUMPHERE(jump\u00dd0\u00a8);\n\n/* MOVDQA xmm1, xmm2/m128 */\n/* instruction\u00dd0\u00a8 = 0x66; */\n/* instruction\u00dd1\u00a8 = 0x0f; */\ninstruction\u00dd2\u00a8 = 0x6f;\ninstruction\u00dd3\u00a8 = 0xc0 | (data2_ind << 3) | data1_ind;\nsljit_emit_op_custom(compiler, instruction, 4);\n\n/* PSLLDQ xmm1, imm8 */\n/* instruction\u00dd0\u00a8 = 0x66; */\n/* instruction\u00dd1\u00a8 = 0x0f; */\ninstruction\u00dd2\u00a8 = 0x73;\ninstruction\u00dd3\u00a8 = 0xc0 | (7 << 3) | data2_ind;\ninstruction\u00dd4\u00a8 = diff;\nsljit_emit_op_custom(compiler, instruction, 5);\n\nJUMPHERE(jump\u00dd1\u00a8);\n\nOP2(SLJIT_AND, TMP2, 0, TMP2, 0, SLJIT_IMM, 0xf);\n\nfor (i = 0; i < 4; i++)\n  {\n  fast_forward_char_pair_sse2_compare(compiler, compare2_type, i, data2_ind, cmp2a_ind, cmp2b_ind, tmp2_ind);\n  fast_forward_char_pair_sse2_compare(compiler, compare1_type, i, data1_ind, cmp1a_ind, cmp1b_ind, tmp1_ind);\n  }\n\n/* PAND xmm1, xmm2/m128 */\n/* instruction\u00dd0\u00a8 = 0x66; */\n/* instruction\u00dd1\u00a8 = 0x0f; */\ninstruction\u00dd2\u00a8 = 0xdb;\ninstruction\u00dd3\u00a8 = 0xc0 | (data1_ind << 3) | data2_ind;\nsljit_emit_op_custom(compiler, instruction, 4);\n\n/* PMOVMSKB reg, xmm */\n/* instruction\u00dd0\u00a8 = 0x66; */\n/* instruction\u00dd1\u00a8 = 0x0f; */\ninstruction\u00dd2\u00a8 = 0xd7;\ninstruction\u00dd3\u00a8 = 0xc0 | (tmp1_reg_ind << 3) | 0;\nsljit_emit_op_custom(compiler, instruction, 4);\n\n/* Ignore matches before the first STR_PTR. */\nOP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, TMP2, 0);\nOP2(SLJIT_LSHR, TMP1, 0, TMP1, 0, TMP2, 0);\n\njump\u00dd0\u00a8 = CMP(SLJIT_NOT_ZERO, TMP1, 0, SLJIT_IMM, 0);\n\nOP2(SLJIT_SUB, STR_PTR, 0, STR_PTR, 0, TMP2, 0);\n\n/* Main loop. */\nstart = LABEL();\n\nOP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, 16);\nadd_jump(compiler, &common->failed_match, CMP(SLJIT_GREATER_EQUAL, STR_PTR, 0, STR_END, 0));\n\nload_from_mem_sse2(compiler, data1_ind, str_ptr_reg_ind, 0);\nload_from_mem_sse2(compiler, data2_ind, str_ptr_reg_ind, -(sljit_s8)diff);\n\nfor (i = 0; i < 4; i++)\n  {\n  fast_forward_char_pair_sse2_compare(compiler, compare1_type, i, data1_ind, cmp1a_ind, cmp1b_ind, tmp2_ind);\n  fast_forward_char_pair_sse2_compare(compiler, compare2_type, i, data2_ind, cmp2a_ind, cmp2b_ind, tmp1_ind);\n  }\n\n/* PAND xmm1, xmm2/m128 */\n/* instruction\u00dd0\u00a8 = 0x66; */\n/* instruction\u00dd1\u00a8 = 0x0f; */\ninstruction\u00dd2\u00a8 = 0xdb;\ninstruction\u00dd3\u00a8 = 0xc0 | (data1_ind << 3) | data2_ind;\nsljit_emit_op_custom(compiler, instruction, 4);\n\n/* PMOVMSKB reg, xmm */\n/* instruction\u00dd0\u00a8 = 0x66; */\n/* instruction\u00dd1\u00a8 = 0x0f; */\ninstruction\u00dd2\u00a8 = 0xd7;\ninstruction\u00dd3\u00a8 = 0xc0 | (tmp1_reg_ind << 3) | 0;\nsljit_emit_op_custom(compiler, instruction, 4);\n\nCMPTO(SLJIT_ZERO, TMP1, 0, SLJIT_IMM, 0, start);\n\nJUMPHERE(jump\u00dd0\u00a8);\n\n/* BSF r32, r/m32 */\ninstruction\u00dd0\u00a8 = 0x0f;\ninstruction\u00dd1\u00a8 = 0xbc;\ninstruction\u00dd2\u00a8 = 0xc0 | (tmp1_reg_ind << 3) | tmp1_reg_ind;\nsljit_emit_op_custom(compiler, instruction, 3);\n\nOP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, TMP1, 0);\n\nadd_jump(compiler, &common->failed_match, CMP(SLJIT_GREATER_EQUAL, STR_PTR, 0, STR_END, 0));\n\nif (common->match_end_ptr != 0)\n  OP1(SLJIT_MOV, STR_END, 0, SLJIT_MEM1(SLJIT_SP), common->match_end_ptr);\n\n#if defined SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH != 32\nif (common->utf)\n  {\n  OP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(-offs1));\n\n  jump\u00dd0\u00a8 = jump_if_utf_char_start(compiler, TMP1);\n\n  OP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n  CMPTO(SLJIT_LESS, STR_PTR, 0, STR_END, 0, restart);\n\n  add_jump(compiler, &common->failed_match, JUMP(SLJIT_JUMP));\n\n  JUMPHERE(jump\u00dd0\u00a8);\n  }\n#endif\n\nOP2(SLJIT_SUB, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(offs1));\n\nif (common->match_end_ptr != 0)\n  OP1(SLJIT_MOV, STR_END, 0, TMP3, 0);\n}\n\n#endif /* !_WIN64 */\n\n#undef SSE2_COMPARE_TYPE_INDEX\n\n#endif /* SLJIT_CONFIG_X86 && !SUPPORT_VALGRIND */\n\n#if (defined SLJIT_CONFIG_ARM_64 && SLJIT_CONFIG_ARM_64 && (defined __ARM_NEON || defined __ARM_NEON__))\n\n#include <arm_neon.h>\n\ntypedef union {\n  unsigned int x;\n  struct { unsigned char c1, c2, c3, c4; } c;\n} int_char;\n\n#if defined SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH != 32\nstatic SLJIT_INLINE int utf_continue(sljit_u8 *s)\n{\n#if PCRE2_CODE_UNIT_WIDTH == 8\nreturn (*s & 0xc0) == 0x80;\n#elif PCRE2_CODE_UNIT_WIDTH == 16\nreturn (*s & 0xfc00) == 0xdc00;\n#else\n#error \"Unknown code width\"\n#endif\n}\n#endif /* SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH != 32 */\n\n#if PCRE2_CODE_UNIT_WIDTH == 8\n# define VECTOR_FACTOR 16\n# define vect_t uint8x16_t\n# define VLD1Q(X) vld1q_u8((sljit_u8 *)(X))\n# define VCEQQ vceqq_u8\n# define VORRQ vorrq_u8\n# define VST1Q vst1q_u8\n# define VDUPQ vdupq_n_u8\n# define VEXTQ vextq_u8\n# define VANDQ vandq_u8\ntypedef union {\n       uint8_t mem\u00dd16\u00a8;\n       uint64_t dw\u00dd2\u00a8;\n} quad_word;\n#elif PCRE2_CODE_UNIT_WIDTH == 16\n# define VECTOR_FACTOR 8\n# define vect_t uint16x8_t\n# define VLD1Q(X) vld1q_u16((sljit_u16 *)(X))\n# define VCEQQ vceqq_u16\n# define VORRQ vorrq_u16\n# define VST1Q vst1q_u16\n# define VDUPQ vdupq_n_u16\n# define VEXTQ vextq_u16\n# define VANDQ vandq_u16\ntypedef union {\n       uint16_t mem\u00dd8\u00a8;\n       uint64_t dw\u00dd2\u00a8;\n} quad_word;\n#else\n# define VECTOR_FACTOR 4\n# define vect_t uint32x4_t\n# define VLD1Q(X) vld1q_u32((sljit_u32 *)(X))\n# define VCEQQ vceqq_u32\n# define VORRQ vorrq_u32\n# define VST1Q vst1q_u32\n# define VDUPQ vdupq_n_u32\n# define VEXTQ vextq_u32\n# define VANDQ vandq_u32\ntypedef union {\n       uint32_t mem\u00dd4\u00a8;\n       uint64_t dw\u00dd2\u00a8;\n} quad_word;\n#endif\n\n#define FFCS\n#include \"JITNEON2.h\"\n#if defined SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH != 32\n# define FF_UTF\n# include \"JITNEON2.h\"\n# undef FF_UTF\n#endif\n#undef FFCS\n\n#define FFCS_2\n#include \"JITNEON2.h\"\n#if defined SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH != 32\n# define FF_UTF\n# include \"JITNEON2.h\"\n# undef FF_UTF\n#endif\n#undef FFCS_2\n\n#define FFCS_MASK\n#include \"JITNEON2.h\"\n#if defined SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH != 32\n# define FF_UTF\n# include \"JITNEON2.h\"\n# undef FF_UTF\n#endif\n#undef FFCS_MASK\n\n#define JIT_HAS_FAST_FORWARD_CHAR_SIMD 1\n\nstatic void fast_forward_char_simd(compiler_common *common, PCRE2_UCHAR char1, PCRE2_UCHAR char2, sljit_s32 offset)\n{\nDEFINE_COMPILER;\nint_char ic;\nstruct sljit_jump *partial_quit;\n/* Save temporary registers. */\nOP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), LOCALS0, STR_PTR, 0);\nOP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), LOCALS1, TMP3, 0);\n\n/* Prepare function arguments */\nOP1(SLJIT_MOV, SLJIT_R0, 0, STR_END, 0);\nOP1(SLJIT_MOV, SLJIT_R1, 0, STR_PTR, 0);\nOP1(SLJIT_MOV, SLJIT_R2, 0, SLJIT_IMM, offset);\n\nif (char1 == char2)\n  {\n    ic.c.c1 = char1;\n    ic.c.c2 = char2;\n    OP1(SLJIT_MOV, SLJIT_R4, 0, SLJIT_IMM, ic.x);\n\n#if defined SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH != 32\n  if (common->utf && offset > 0)\n    sljit_emit_icall(compiler, SLJIT_CALL, SLJIT_RET(SW) | SLJIT_ARG1(SW) | SLJIT_ARG2(UW) | SLJIT_ARG3(UW) | SLJIT_ARG4(UW),\n                     SLJIT_IMM, SLJIT_FUNC_OFFSET(ffcs_utf));\n  else\n    sljit_emit_icall(compiler, SLJIT_CALL, SLJIT_RET(SW) | SLJIT_ARG1(SW) | SLJIT_ARG2(UW) | SLJIT_ARG3(UW) | SLJIT_ARG4(UW),\n                     SLJIT_IMM, SLJIT_FUNC_OFFSET(ffcs));\n#else\n  sljit_emit_icall(compiler, SLJIT_CALL, SLJIT_RET(SW) | SLJIT_ARG1(SW) | SLJIT_ARG2(UW) | SLJIT_ARG3(UW) | SLJIT_ARG4(UW),\n                   SLJIT_IMM, SLJIT_FUNC_OFFSET(ffcs));\n#endif\n  }\nelse\n  {\n  PCRE2_UCHAR mask = char1 \u00ac char2;\n  if (is_powerof2(mask))\n    {\n    ic.c.c1 = char1 | mask;\n    ic.c.c2 = mask;\n    OP1(SLJIT_MOV, SLJIT_R4, 0, SLJIT_IMM, ic.x);\n\n#if defined SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH != 32\n    if (common->utf && offset > 0)\n      sljit_emit_icall(compiler, SLJIT_CALL, SLJIT_RET(SW) | SLJIT_ARG1(SW) | SLJIT_ARG2(UW) | SLJIT_ARG3(UW) | SLJIT_ARG4(UW),\n                       SLJIT_IMM, SLJIT_FUNC_OFFSET(ffcs_mask_utf));\n    else\n      sljit_emit_icall(compiler, SLJIT_CALL, SLJIT_RET(SW) | SLJIT_ARG1(SW) | SLJIT_ARG2(UW) | SLJIT_ARG3(UW) | SLJIT_ARG4(UW),\n                       SLJIT_IMM, SLJIT_FUNC_OFFSET(ffcs_mask));\n#else\n    sljit_emit_icall(compiler, SLJIT_CALL, SLJIT_RET(SW) | SLJIT_ARG1(SW) | SLJIT_ARG2(UW) | SLJIT_ARG3(UW) | SLJIT_ARG4(UW),\n                     SLJIT_IMM, SLJIT_FUNC_OFFSET(ffcs_mask));\n#endif\n    }\n  else\n    {\n      ic.c.c1 = char1;\n      ic.c.c2 = char2;\n      OP1(SLJIT_MOV, SLJIT_R4, 0, SLJIT_IMM, ic.x);\n\n#if defined SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH != 32\n    if (common->utf && offset > 0)\n      sljit_emit_icall(compiler, SLJIT_CALL, SLJIT_RET(SW) | SLJIT_ARG1(SW) | SLJIT_ARG2(UW) | SLJIT_ARG3(UW) | SLJIT_ARG4(UW),\n                       SLJIT_IMM, SLJIT_FUNC_OFFSET(ffcs_2_utf));\n    else\n      sljit_emit_icall(compiler, SLJIT_CALL, SLJIT_RET(SW) | SLJIT_ARG1(SW) | SLJIT_ARG2(UW) | SLJIT_ARG3(UW) | SLJIT_ARG4(UW),\n                       SLJIT_IMM, SLJIT_FUNC_OFFSET(ffcs_2));\n#else\n    sljit_emit_icall(compiler, SLJIT_CALL, SLJIT_RET(SW) | SLJIT_ARG1(SW) | SLJIT_ARG2(UW) | SLJIT_ARG3(UW) | SLJIT_ARG4(UW),\n                     SLJIT_IMM, SLJIT_FUNC_OFFSET(ffcs_2));\n#endif\n    }\n  }\n/* Restore registers. */\nOP1(SLJIT_MOV, STR_PTR, 0, SLJIT_MEM1(SLJIT_SP), LOCALS0);\nOP1(SLJIT_MOV, TMP3, 0, SLJIT_MEM1(SLJIT_SP), LOCALS1);\n\n/* Check return value. */\npartial_quit = CMP(SLJIT_EQUAL, SLJIT_RETURN_REG, 0, SLJIT_IMM, 0);\nif (common->mode == PCRE2_JIT_COMPLETE)\n  add_jump(compiler, &common->failed_match, partial_quit);\n\n/* Fast forward STR_PTR to the result of memchr. */\nOP1(SLJIT_MOV, STR_PTR, 0, SLJIT_RETURN_REG, 0);\n\nif (common->mode != PCRE2_JIT_COMPLETE)\n  JUMPHERE(partial_quit);\n}\n\ntypedef enum {\n  compare_match1,\n  compare_match1i,\n  compare_match2,\n} compare_type;\n\nstatic inline vect_t fast_forward_char_pair_compare(compare_type ctype, vect_t dst, vect_t cmp1, vect_t cmp2)\n{\nif (ctype == compare_match2)\n  {\n  vect_t tmp = dst;\n  dst = VCEQQ(dst, cmp1);\n  tmp = VCEQQ(tmp, cmp2);\n  dst = VORRQ(dst, tmp);\n  return dst;\n  }\n\nif (ctype == compare_match1i)\n  dst = VORRQ(dst, cmp2);\ndst = VCEQQ(dst, cmp1);\nreturn dst;\n}\n\nstatic SLJIT_INLINE sljit_u32 max_fast_forward_char_pair_offset(void)\n{\n#if PCRE2_CODE_UNIT_WIDTH == 8\nreturn 15;\n#elif PCRE2_CODE_UNIT_WIDTH == 16\nreturn 7;\n#elif PCRE2_CODE_UNIT_WIDTH == 32\nreturn 3;\n#else\n#error \"Unsupported unit width\"\n#endif\n}\n\n/* ARM doesn't have a shift left across lanes. */\nstatic SLJIT_INLINE vect_t shift_left_n_lanes(vect_t a, sljit_u8 n)\n{\nvect_t zero = VDUPQ(0);\nSLJIT_ASSERT(0 < n && n < VECTOR_FACTOR);\n/* VEXTQ takes an immediate as last argument. */\n#define C(X) case X: return VEXTQ(zero, a, VECTOR_FACTOR - X);\nswitch (n)\n  {\n  C(1); C(2); C(3);\n#if PCRE2_CODE_UNIT_WIDTH != 32\n  C(4); C(5); C(6); C(7);\n# if PCRE2_CODE_UNIT_WIDTH != 16\n  C(8); C(9); C(10); C(11); C(12); C(13); C(14); C(15);\n# endif\n#endif\n  default:\n    /* Based on the ASSERT(0 < n && n < VECTOR_FACTOR) above, this won't\n       happen. The return is still here for compilers to not warn. */\n    return a;\n  }\n}\n\n#define FFCPS\n#define FFCPS_DIFF1\n#define FFCPS_CHAR1A2A\n\n#define FFCPS_0\n#include \"JITNEON2.h\"\n#if defined SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH != 32\n# define FF_UTF\n# include \"JITNEON2.h\"\n# undef FF_UTF\n#endif\n#undef FFCPS_0\n\n#undef FFCPS_CHAR1A2A\n\n#define FFCPS_1\n#include \"JITNEON2.h\"\n#if defined SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH != 32\n# define FF_UTF\n# include \"JITNEON2.h\"\n# undef FF_UTF\n#endif\n#undef FFCPS_1\n\n#undef FFCPS_DIFF1\n\n#define FFCPS_DEFAULT\n#include \"JITNEON2.h\"\n#if defined SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH != 32\n# define FF_UTF\n# include \"JITNEON2.h\"\n# undef FF_UTF\n#endif\n#undef FFCPS\n\n#define JIT_HAS_FAST_FORWARD_CHAR_PAIR_SIMD 1\n\nstatic void fast_forward_char_pair_simd(compiler_common *common, sljit_s32 offs1,\n  PCRE2_UCHAR char1a, PCRE2_UCHAR char1b, sljit_s32 offs2, PCRE2_UCHAR char2a, PCRE2_UCHAR char2b)\n{\nDEFINE_COMPILER;\nsljit_u32 diff = IN_UCHARS(offs1 - offs2);\nstruct sljit_jump *partial_quit;\nint_char ic;\nSLJIT_ASSERT(common->mode == PCRE2_JIT_COMPLETE && offs1 > offs2);\nSLJIT_ASSERT(diff <= IN_UCHARS(max_fast_forward_char_pair_offset()));\nSLJIT_ASSERT(compiler->scratches == 5);\n\n/* Save temporary register STR_PTR. */\nOP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), LOCALS0, STR_PTR, 0);\n\n/* Prepare arguments for the function call. */\nif (common->match_end_ptr == 0)\n   OP1(SLJIT_MOV, SLJIT_R0, 0, STR_END, 0);\nelse\n  {\n  OP1(SLJIT_MOV, SLJIT_R0, 0, SLJIT_MEM1(SLJIT_SP), common->match_end_ptr);\n  OP2(SLJIT_ADD, SLJIT_R0, 0, SLJIT_R0, 0, SLJIT_IMM, IN_UCHARS(offs1 + 1));\n\n  OP2(SLJIT_SUB | SLJIT_SET_LESS, SLJIT_UNUSED, 0, STR_END, 0, SLJIT_R0, 0);\n  CMOV(SLJIT_LESS, SLJIT_R0, STR_END, 0);\n  }\n\nOP1(SLJIT_MOV, SLJIT_R1, 0, STR_PTR, 0);\nOP1(SLJIT_MOV_S32, SLJIT_R2, 0, SLJIT_IMM, offs1);\nOP1(SLJIT_MOV_S32, SLJIT_R3, 0, SLJIT_IMM, offs2);\nic.c.c1 = char1a;\nic.c.c2 = char1b;\nic.c.c3 = char2a;\nic.c.c4 = char2b;\nOP1(SLJIT_MOV_U32, SLJIT_R4, 0, SLJIT_IMM, ic.x);\n\nif (diff == 1) {\n  if (char1a == char1b && char2a == char2b) {\n#if defined SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH != 32\n    if (common->utf)\n      sljit_emit_icall(compiler, SLJIT_CALL, SLJIT_RET(SW) | SLJIT_ARG1(SW) | SLJIT_ARG2(SW) | SLJIT_ARG3(SW) | SLJIT_ARG4(SW),\n                       SLJIT_IMM, SLJIT_FUNC_OFFSET(ffcps_0_utf));\n    else\n#endif\n      sljit_emit_icall(compiler, SLJIT_CALL, SLJIT_RET(SW) | SLJIT_ARG1(SW) | SLJIT_ARG2(SW) | SLJIT_ARG3(SW) | SLJIT_ARG4(SW),\n                       SLJIT_IMM, SLJIT_FUNC_OFFSET(ffcps_0));\n  } else {\n#if defined SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH != 32\n    if (common->utf)\n      sljit_emit_icall(compiler, SLJIT_CALL, SLJIT_RET(SW) | SLJIT_ARG1(SW) | SLJIT_ARG2(SW) | SLJIT_ARG3(SW) | SLJIT_ARG4(SW),\n                       SLJIT_IMM, SLJIT_FUNC_OFFSET(ffcps_1_utf));\n    else\n#endif\n      sljit_emit_icall(compiler, SLJIT_CALL, SLJIT_RET(SW) | SLJIT_ARG1(SW) | SLJIT_ARG2(SW) | SLJIT_ARG3(SW) | SLJIT_ARG4(SW),\n                       SLJIT_IMM, SLJIT_FUNC_OFFSET(ffcps_1));\n  }\n} else {\n#if defined SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH != 32\n  if (common->utf)\n    sljit_emit_icall(compiler, SLJIT_CALL, SLJIT_RET(SW) | SLJIT_ARG1(SW) | SLJIT_ARG2(SW) | SLJIT_ARG3(SW) | SLJIT_ARG4(SW),\n                     SLJIT_IMM, SLJIT_FUNC_OFFSET(ffcps_default_utf));\n  else\n#endif\n    sljit_emit_icall(compiler, SLJIT_CALL, SLJIT_RET(SW) | SLJIT_ARG1(SW) | SLJIT_ARG2(SW) | SLJIT_ARG3(SW) | SLJIT_ARG4(SW),\n                     SLJIT_IMM, SLJIT_FUNC_OFFSET(ffcps_default));\n}\n\n/* Restore STR_PTR register. */\nOP1(SLJIT_MOV, STR_PTR, 0, SLJIT_MEM1(SLJIT_SP), LOCALS0);\n\n/* Check return value. */\npartial_quit = CMP(SLJIT_EQUAL, SLJIT_RETURN_REG, 0, SLJIT_IMM, 0);\nadd_jump(compiler, &common->failed_match, partial_quit);\n\n/* Fast forward STR_PTR to the result of memchr. */\nOP1(SLJIT_MOV, STR_PTR, 0, SLJIT_RETURN_REG, 0);\n\nJUMPHERE(partial_quit);\n}\n\n#endif /* SLJIT_CONFIG_ARM_64 && SLJIT_CONFIG_ARM_64 */\n/*autoconv-0001 C:\\projects\\pcre2-10.35\\src\\pcre2_jit_simd_inc.h converted to JITSIMD2*/\n/*autoconv-0011 JITSIMD2 line: 832 pcre2_jit_neon_inc.h replaced by JITNEON2.h*/\n/*autoconv-0011 JITSIMD2 line: 835 pcre2_jit_neon_inc.h replaced by JITNEON2.h*/\n/*autoconv-0011 JITSIMD2 line: 841 pcre2_jit_neon_inc.h replaced by JITNEON2.h*/\n/*autoconv-0011 JITSIMD2 line: 844 pcre2_jit_neon_inc.h replaced by JITNEON2.h*/\n/*autoconv-0011 JITSIMD2 line: 850 pcre2_jit_neon_inc.h replaced by JITNEON2.h*/\n/*autoconv-0011 JITSIMD2 line: 853 pcre2_jit_neon_inc.h replaced by JITNEON2.h*/\n/*autoconv-0011 JITSIMD2 line: 1012 pcre2_jit_neon_inc.h replaced by JITNEON2.h*/\n/*autoconv-0011 JITSIMD2 line: 1015 pcre2_jit_neon_inc.h replaced by JITNEON2.h*/\n/*autoconv-0011 JITSIMD2 line: 1023 pcre2_jit_neon_inc.h replaced by JITNEON2.h*/\n/*autoconv-0011 JITSIMD2 line: 1026 pcre2_jit_neon_inc.h replaced by JITNEON2.h*/\n/*autoconv-0011 JITSIMD2 line: 1034 pcre2_jit_neon_inc.h replaced by JITNEON2.h*/\n/*autoconv-0011 JITSIMD2 line: 1037 pcre2_jit_neon_inc.h replaced by JITNEON2.h*/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "MAKETAB2": {"ttr": 8195, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "\n/*************************************************\n*      Perl-Compatible Regular Expressions       *\n*************************************************/\n\n/* PCRE is a library of functions to support regular expressions whose syntax\nand semantics are as close as possible to those of the Perl 5 language.\n\n                       Written by Philip Hazel\n     Original API code Copyright (c) 1997-2012 University of Cambridge\n          New API code Copyright (c) 2016-2020 University of Cambridge\n\n-----------------------------------------------------------------------------\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n\n    * Redistributions of source code must retain the above copyright notice,\n      this list of conditions and the following disclaimer.\n\n    * Redistributions in binary form must reproduce the above copyright\n      notice, this list of conditions and the following disclaimer in the\n      documentation and/or other materials provided with the distribution.\n\n    * Neither the name of the University of Cambridge nor the names of its\n      contributors may be used to endorse or promote products derived from\n      this software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\nAND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\nIMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\nARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\nLIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\nCONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\nSUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\nINTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\nCONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\nARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\nPOSSIBILITY OF SUCH DAMAGE.\n-----------------------------------------------------------------------------\n*/\n\n\n/* This module contains the external function pcre2_maketables(), which builds\ncharacter tables for PCRE2 in the current locale. The file is compiled on its\nown as part of the PCRE2 library. It is also included in the compilation of\npcre2_dftables.c as a freestanding program, in which case the macro\nPCRE2_DFTABLES is defined. */\n\n#ifndef PCRE2_DFTABLES    /* Compiling the library */\n#  ifdef HAVE_CONFIG_H\n#  include \"CONFIG.h\"\n#  endif\n#  include \"INTERNA2.h\"\n#endif\n\n\n\n/*************************************************\n*           Create PCRE2 character tables        *\n*************************************************/\n\n/* This function builds a set of character tables for use by PCRE2 and returns\na pointer to them. They are build using the ctype functions, and consequently\ntheir contents will depend upon the current locale setting. When compiled as\npart of the library, the store is obtained via a general context malloc, if\nsupplied, but when PCRE2_DFTABLES is defined (when compiling the pcre2_dftables\nfreestanding auxiliary program) malloc() is used, and the function has a\ndifferent name so as not to clash with the prototype in pcre2.h.\n\nArguments:   none when PCRE2_DFTABLES is defined\n               else a PCRE2 general context or NULL\nReturns:     pointer to the contiguous block of data\n               else NULL if memory allocation failed\n*/\n\n#ifdef PCRE2_DFTABLES  /* Included in freestanding pcre2_dftables program */\nstatic const uint8_t *maketables(void)\n{\nuint8_t *yield = (uint8_t *)malloc(TABLES_LENGTH);\n\n#else  /* Not PCRE2_DFTABLES, that is, compiling the library */\nPCRE2_EXP_DEFN const uint8_t * PCRE2_CALL_CONVENTION\npcre2_maketables(pcre2_general_context *gcontext)\n{\nuint8_t *yield = (uint8_t *)((gcontext != NULL)?\n  gcontext->memctl.malloc(TABLES_LENGTH, gcontext->memctl.memory_data) :\n  malloc(TABLES_LENGTH));\n#endif  /* PCRE2_DFTABLES */\n\nint i;\nuint8_t *p;\n\nif (yield == NULL) return NULL;\np = yield;\n\n/* First comes the lower casing table */\n\nfor (i = 0; i < 256; i++) *p++ = tolower(i);\n\n/* Next the case-flipping table */\n\nfor (i = 0; i < 256; i++) *p++ = islower(i)? toupper(i) : tolower(i);\n\n/* Then the character class tables. Don't try to be clever and save effort on\nexclusive ones - in some locales things may be different.\n\nNote that the table for \"space\" includes everything \"isspace\" gives, including\nVT in the default locale. This makes it work for the POSIX class \u00dd:space:\u00a8.\nFrom PCRE1 release 8.34 and for all PCRE2 releases it is also correct for Perl\nspace, because Perl added VT at release 5.18.\n\nNote also that it is possible for a character to be alnum or alpha without\nbeing lower or upper, such as \"male and female ordinals\" (\\xAA and \\xBA) in the\nfr_FR locale (at least under Debian Linux's locales as of 12/2005). So we must\ntest for alnum specially. */\n\nmemset(p, 0, cbit_length);\nfor (i = 0; i < 256; i++)\n  {\n  if (isdigit(i))  p\u00ddcbit_digit  + i/8\u00a8 |= 1u << (i&7);\n  if (isupper(i))  p\u00ddcbit_upper  + i/8\u00a8 |= 1u << (i&7);\n  if (islower(i))  p\u00ddcbit_lower  + i/8\u00a8 |= 1u << (i&7);\n  if (isalnum(i))  p\u00ddcbit_word   + i/8\u00a8 |= 1u << (i&7);\n  if (i == '_')    p\u00ddcbit_word   + i/8\u00a8 |= 1u << (i&7);\n  if (isspace(i))  p\u00ddcbit_space  + i/8\u00a8 |= 1u << (i&7);\n  if (isxdigit(i)) p\u00ddcbit_xdigit + i/8\u00a8 |= 1u << (i&7);\n  if (isgraph(i))  p\u00ddcbit_graph  + i/8\u00a8 |= 1u << (i&7);\n  if (isprint(i))  p\u00ddcbit_print  + i/8\u00a8 |= 1u << (i&7);\n  if (ispunct(i))  p\u00ddcbit_punct  + i/8\u00a8 |= 1u << (i&7);\n  if (iscntrl(i))  p\u00ddcbit_cntrl  + i/8\u00a8 |= 1u << (i&7);\n  }\np += cbit_length;\n\n/* Finally, the character type table. In this, we used to exclude VT from the\nwhite space chars, because Perl didn't recognize it as such for \\s and for\ncomments within regexes. However, Perl changed at release 5.18, so PCRE1\nchanged at release 8.34 and it's always been this way for PCRE2. */\n\nfor (i = 0; i < 256; i++)\n  {\n  int x = 0;\n  if (isspace(i)) x += ctype_space;\n  if (isalpha(i)) x += ctype_letter;\n  if (islower(i)) x += ctype_lcletter;\n  if (isdigit(i)) x += ctype_digit;\n  if (isalnum(i) || i == '_') x += ctype_word;\n  *p++ = x;\n  }\n\nreturn yield;\n}\n\n#ifndef PCRE2_DFTABLES   /* Compiling the library */\nPCRE2_EXP_DEFN void PCRE2_CALL_CONVENTION\npcre2_maketables_free(pcre2_general_context *gcontext, const uint8_t *tables)\n{\n  if (gcontext)\n    gcontext->memctl.free((void *)tables, gcontext->memctl.memory_data);\n  else\n    free((void *)tables);\n}\n#endif\n\n/* End of pcre2_maketables.c */\n/*autoconv-0001 C:\\projects\\pcre2-10.35\\src\\pcre2_maketables.c converted to MAKETAB2*/\n/*autoconv-0011 MAKETAB2 line: 50 config.h replaced by CONFIG.h*/\n/*autoconv-0011 MAKETAB2 line: 52 pcre2_internal.h replaced by INTERNA2.h*/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "MATCHDA2": {"ttr": 3073, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "\n/*************************************************\n*      Perl-Compatible Regular Expressions       *\n*************************************************/\n\n/* PCRE is a library of functions to support regular expressions whose syntax\nand semantics are as close as possible to those of the Perl 5 language.\n\n                       Written by Philip Hazel\n     Original API code Copyright (c) 1997-2012 University of Cambridge\n          New API code Copyright (c) 2016-2019 University of Cambridge\n\n-----------------------------------------------------------------------------\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n\n    * Redistributions of source code must retain the above copyright notice,\n      this list of conditions and the following disclaimer.\n\n    * Redistributions in binary form must reproduce the above copyright\n      notice, this list of conditions and the following disclaimer in the\n      documentation and/or other materials provided with the distribution.\n\n    * Neither the name of the University of Cambridge nor the names of its\n      contributors may be used to endorse or promote products derived from\n      this software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\nAND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\nIMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\nARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\nLIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\nCONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\nSUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\nINTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\nCONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\nARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\nPOSSIBILITY OF SUCH DAMAGE.\n-----------------------------------------------------------------------------\n*/\n\n\n#ifdef HAVE_CONFIG_H\n#include \"CONFIG.h\"\n#endif\n\n#include \"INTERNA2.h\"\n\n\n\n/*************************************************\n*  Create a match data block given ovector size  *\n*************************************************/\n\n/* A minimum of 1 is imposed on the number of ovector pairs. */\n\nPCRE2_EXP_DEFN pcre2_match_data * PCRE2_CALL_CONVENTION\npcre2_match_data_create(uint32_t oveccount, pcre2_general_context *gcontext)\n{\npcre2_match_data *yield;\nif (oveccount < 1) oveccount = 1;\nyield = PRIV(memctl_malloc)(\n  offsetof(pcre2_match_data, ovector) + 2*oveccount*sizeof(PCRE2_SIZE),\n  (pcre2_memctl *)gcontext);\nif (yield == NULL) return NULL;\nyield->oveccount = oveccount;\nyield->flags = 0;\nreturn yield;\n}\n\n\n\n/*************************************************\n*  Create a match data block using pattern data  *\n*************************************************/\n\n/* If no context is supplied, use the memory allocator from the code. */\n\nPCRE2_EXP_DEFN pcre2_match_data * PCRE2_CALL_CONVENTION\npcre2_match_data_create_from_pattern(const pcre2_code *code,\n  pcre2_general_context *gcontext)\n{\nif (gcontext == NULL) gcontext = (pcre2_general_context *)code;\nreturn pcre2_match_data_create(((pcre2_real_code *)code)->top_bracket + 1,\n  gcontext);\n}\n\n\n\n/*************************************************\n*            Free a match data block             *\n*************************************************/\n\nPCRE2_EXP_DEFN void PCRE2_CALL_CONVENTION\npcre2_match_data_free(pcre2_match_data *match_data)\n{\nif (match_data != NULL)\n  {\n  if ((match_data->flags & PCRE2_MD_COPIED_SUBJECT) != 0)\n    match_data->memctl.free((void *)match_data->subject,\n      match_data->memctl.memory_data);\n  match_data->memctl.free(match_data, match_data->memctl.memory_data);\n  }\n}\n\n\n\n/*************************************************\n*         Get last mark in match                 *\n*************************************************/\n\nPCRE2_EXP_DEFN PCRE2_SPTR PCRE2_CALL_CONVENTION\npcre2_get_mark(pcre2_match_data *match_data)\n{\nreturn match_data->mark;\n}\n\n\n\n/*************************************************\n*          Get pointer to ovector                *\n*************************************************/\n\nPCRE2_EXP_DEFN PCRE2_SIZE * PCRE2_CALL_CONVENTION\npcre2_get_ovector_pointer(pcre2_match_data *match_data)\n{\nreturn match_data->ovector;\n}\n\n\n\n/*************************************************\n*          Get number of ovector slots           *\n*************************************************/\n\nPCRE2_EXP_DEFN uint32_t PCRE2_CALL_CONVENTION\npcre2_get_ovector_count(pcre2_match_data *match_data)\n{\nreturn match_data->oveccount;\n}\n\n\n\n/*************************************************\n*         Get starting code unit in match        *\n*************************************************/\n\nPCRE2_EXP_DEFN PCRE2_SIZE PCRE2_CALL_CONVENTION\npcre2_get_startchar(pcre2_match_data *match_data)\n{\nreturn match_data->startchar;\n}\n\n\n\n/*************************************************\n*         Get size of match data block           *\n*************************************************/\n\nPCRE2_EXP_DEFN PCRE2_SIZE PCRE2_CALL_CONVENTION\npcre2_get_match_data_size(pcre2_match_data *match_data)\n{\nreturn offsetof(pcre2_match_data, ovector) +\n  2 * (match_data->oveccount) * sizeof(PCRE2_SIZE);\n}\n\n/* End of pcre2_match_data.c */\n/*autoconv-0001 C:\\projects\\pcre2-10.35\\src\\pcre2_match_data.c converted to MATCHDA2*/\n/*autoconv-0011 MATCHDA2 line: 43 config.h replaced by CONFIG.h*/\n/*autoconv-0011 MATCHDA2 line: 46 pcre2_internal.h replaced by INTERNA2.h*/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "MATCH2": {"ttr": 769, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "\n/*************************************************\n*      Perl-Compatible Regular Expressions       *\n*************************************************/\n\n/* PCRE is a library of functions to support regular expressions whose syntax\nand semantics are as close as possible to those of the Perl 5 language.\n\n                       Written by Philip Hazel\n     Original API code Copyright (c) 1997-2012 University of Cambridge\n          New API code Copyright (c) 2015-2020 University of Cambridge\n\n-----------------------------------------------------------------------------\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n\n    * Redistributions of source code must retain the above copyright notice,\n      this list of conditions and the following disclaimer.\n\n    * Redistributions in binary form must reproduce the above copyright\n      notice, this list of conditions and the following disclaimer in the\n      documentation and/or other materials provided with the distribution.\n\n    * Neither the name of the University of Cambridge nor the names of its\n      contributors may be used to endorse or promote products derived from\n      this software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\nAND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\nIMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\nARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\nLIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\nCONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\nSUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\nINTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\nCONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\nARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\nPOSSIBILITY OF SUCH DAMAGE.\n-----------------------------------------------------------------------------\n*/\n\n\n#ifdef HAVE_CONFIG_H\n#include \"CONFIG.h\"\n#endif\n\n/* These defines enable debugging code */\n\n/* #define DEBUG_FRAMES_DISPLAY */\n/* #define DEBUG_SHOW_OPS */\n/* #define DEBUG_SHOW_RMATCH */\n\n#ifdef DEBUG_FRAME_DISPLAY\n#include <stdarg.h>\n#endif\n\n/* These defines identify the name of the block containing \"static\"\ninformation, and fields within it. */\n\n#define NLBLOCK mb              /* Block containing newline information */\n#define PSSTART start_subject   /* Field containing processed string start */\n#define PSEND   end_subject     /* Field containing processed string end */\n\n#include \"INTERNA2.h\"\n\n#define RECURSE_UNSET 0xffffffffu  /* Bigger than max group number */\n\n/* Masks for identifying the public options that are permitted at match time. */\n\n#define PUBLIC_MATCH_OPTIONS \\\n  (PCRE2_ANCHORED|PCRE2_ENDANCHORED|PCRE2_NOTBOL|PCRE2_NOTEOL|PCRE2_NOTEMPTY| \\\n   PCRE2_NOTEMPTY_ATSTART|PCRE2_NO_UTF_CHECK|PCRE2_PARTIAL_HARD| \\\n   PCRE2_PARTIAL_SOFT|PCRE2_NO_JIT|PCRE2_COPY_MATCHED_SUBJECT)\n\n#define PUBLIC_JIT_MATCH_OPTIONS \\\n   (PCRE2_NO_UTF_CHECK|PCRE2_NOTBOL|PCRE2_NOTEOL|PCRE2_NOTEMPTY|\\\n    PCRE2_NOTEMPTY_ATSTART|PCRE2_PARTIAL_SOFT|PCRE2_PARTIAL_HARD|\\\n    PCRE2_COPY_MATCHED_SUBJECT)\n\n/* Non-error returns from and within the match() function. Error returns are\nexternally defined PCRE2_ERROR_xxx codes, which are all negative. */\n\n#define MATCH_MATCH        1\n#define MATCH_NOMATCH      0\n\n/* Special internal returns used in the match() function. Make them\nsufficiently negative to avoid the external error codes. */\n\n#define MATCH_ACCEPT       (-999)\n#define MATCH_KETRPOS      (-998)\n/* The next 5 must be kept together and in sequence so that a test that checks\nfor any one of them can use a range. */\n#define MATCH_COMMIT       (-997)\n#define MATCH_PRUNE        (-996)\n#define MATCH_SKIP         (-995)\n#define MATCH_SKIP_ARG     (-994)\n#define MATCH_THEN         (-993)\n#define MATCH_BACKTRACK_MAX MATCH_THEN\n#define MATCH_BACKTRACK_MIN MATCH_COMMIT\n\n/* Group frame type values. Zero means the frame is not a group frame. The\nlower 16 bits are used for data (e.g. the capture number). Group frames are\nused for most groups so that information about the start is easily available at\nthe end without having to scan back through intermediate frames (backtrack\npoints). */\n\n#define GF_CAPTURE     0x00010000u\n#define GF_NOCAPTURE   0x00020000u\n#define GF_CONDASSERT  0x00030000u\n#define GF_RECURSE     0x00040000u\n\n/* Masks for the identity and data parts of the group frame type. */\n\n#define GF_IDMASK(a)   ((a) & 0xffff0000u)\n#define GF_DATAMASK(a) ((a) & 0x0000ffffu)\n\n/* Repetition types */\n\nenum { REPTYPE_MIN, REPTYPE_MAX, REPTYPE_POS };\n\n/* Min and max values for the common repeats; a maximum of UINT32_MAX =>\ninfinity. */\n\nstatic const uint32_t rep_min\u00dd\u00a8 = {\n  0, 0,       /* * and *? */\n  1, 1,       /* + and +? */\n  0, 0,       /* ? and ?? */\n  0, 0,       /* dummy placefillers for OP_CR\u00ddMIN\u00a8RANGE */\n  0, 1, 0 };  /* OP_CRPOS{STAR, PLUS, QUERY} */\n\nstatic const uint32_t rep_max\u00dd\u00a8 = {\n  UINT32_MAX, UINT32_MAX,      /* * and *? */\n  UINT32_MAX, UINT32_MAX,      /* + and +? */\n  1, 1,                        /* ? and ?? */\n  0, 0,                        /* dummy placefillers for OP_CR\u00ddMIN\u00a8RANGE */\n  UINT32_MAX, UINT32_MAX, 1 }; /* OP_CRPOS{STAR, PLUS, QUERY} */\n\n/* Repetition types - must include OP_CRPOSRANGE (not needed above) */\n\nstatic const uint32_t rep_typ\u00dd\u00a8 = {\n  REPTYPE_MAX, REPTYPE_MIN,    /* * and *? */\n  REPTYPE_MAX, REPTYPE_MIN,    /* + and +? */\n  REPTYPE_MAX, REPTYPE_MIN,    /* ? and ?? */\n  REPTYPE_MAX, REPTYPE_MIN,    /* OP_CRRANGE and OP_CRMINRANGE */\n  REPTYPE_POS, REPTYPE_POS,    /* OP_CRPOSSTAR, OP_CRPOSPLUS */\n  REPTYPE_POS, REPTYPE_POS };  /* OP_CRPOSQUERY, OP_CRPOSRANGE */\n\n/* Numbers for RMATCH calls at backtracking points. When these lists are\nchanged, the code at RETURN_SWITCH below must be updated in sync.  */\n\nenum { RM1=1, RM2,  RM3,  RM4,  RM5,  RM6,  RM7,  RM8,  RM9,  RM10,\n       RM11,  RM12, RM13, RM14, RM15, RM16, RM17, RM18, RM19, RM20,\n       RM21,  RM22, RM23, RM24, RM25, RM26, RM27, RM28, RM29, RM30,\n       RM31,  RM32, RM33, RM34, RM35, RM36 };\n\n#ifdef SUPPORT_WIDE_CHARS\nenum { RM100=100, RM101 };\n#endif\n\n#ifdef SUPPORT_UNICODE\nenum { RM200=200, RM201, RM202, RM203, RM204, RM205, RM206, RM207,\n       RM208,     RM209, RM210, RM211, RM212, RM213, RM214, RM215,\n       RM216,     RM217, RM218, RM219, RM220, RM221, RM222 };\n#endif\n\n/* Define short names for general fields in the current backtrack frame, which\nis always pointed to by the F variable. Occasional references to fields in\nother frames are written out explicitly. There are also some fields in the\ncurrent frame whose names start with \"temp\" that are used for short-term,\nlocalised backtracking memory. These are #defined with Lxxx names at the point\nof use and undefined afterwards. */\n\n#define Fback_frame        F->back_frame\n#define Fcapture_last      F->capture_last\n#define Fcurrent_recurse   F->current_recurse\n#define Fecode             F->ecode\n#define Feptr              F->eptr\n#define Fgroup_frame_type  F->group_frame_type\n#define Flast_group_offset F->last_group_offset\n#define Flength            F->length\n#define Fmark              F->mark\n#define Frdepth            F->rdepth\n#define Fstart_match       F->start_match\n#define Foffset_top        F->offset_top\n#define Foccu              F->occu\n#define Fop                F->op\n#define Fovector           F->ovector\n#define Freturn_id         F->return_id\n\n\n#ifdef DEBUG_FRAMES_DISPLAY\n/*************************************************\n*      Display current frames and contents       *\n*************************************************/\n\n/* This debugging function displays the current set of frames and their\ncontents. It is not called automatically from anywhere, the intention being\nthat calls can be inserted where necessary when debugging frame-related\nproblems.\n\nArguments:\n  f           the file to write to\n  F           the current top frame\n  P           a previous frame of interest\n  frame_size  the frame size\n  mb          points to the match block\n  s           identification text\n\nReturns:    nothing\n*/\n\nstatic void\ndisplay_frames(FILE *f, heapframe *F, heapframe *P, PCRE2_SIZE frame_size,\n  match_block *mb, const char *s, ...)\n{\nuint32_t i;\nheapframe *Q;\nva_list ap;\nva_start(ap, s);\n\nfprintf(f, \"FRAMES \");\nvfprintf(f, s, ap);\nva_end(ap);\n\nif (P != NULL) fprintf(f, \" P=%lu\",\n  ((char *)P - (char *)(mb->match_frames))/frame_size);\nfprintf(f, \"\\n\");\n\nfor (i = 0, Q = mb->match_frames;\n     Q <= F;\n     i++, Q = (heapframe *)((char *)Q + frame_size))\n  {\n  fprintf(f, \"Frame %d type=%x subj=%lu code=%d back=%lu id=%d\",\n    i, Q->group_frame_type, Q->eptr - mb->start_subject, *(Q->ecode),\n    Q->back_frame, Q->return_id);\n\n  if (Q->last_group_offset == PCRE2_UNSET)\n    fprintf(f, \" lgoffset=unset\\n\");\n  else\n    fprintf(f, \" lgoffset=%lu\\n\",  Q->last_group_offset/frame_size);\n  }\n}\n\n#endif\n\n\n\n/*************************************************\n*                Process a callout               *\n*************************************************/\n\n/* This function is called for all callouts, whether \"standalone\" or at the\nstart of a conditional group. Feptr will be pointing to either OP_CALLOUT or\nOP_CALLOUT_STR. A callout block is allocated in pcre2_match() and initialized\nwith fixed values.\n\nArguments:\n  F          points to the current backtracking frame\n  mb         points to the match block\n  lengthptr  where to return the length of the callout item\n\nReturns:     the return from the callout\n             or 0 if no callout function exists\n*/\n\nstatic int\ndo_callout(heapframe *F, match_block *mb, PCRE2_SIZE *lengthptr)\n{\nint rc;\nPCRE2_SIZE save0, save1;\nPCRE2_SIZE *callout_ovector;\npcre2_callout_block *cb;\n\n*lengthptr = (*Fecode == OP_CALLOUT)?\n  PRIV(OP_lengths)\u00ddOP_CALLOUT\u00a8 : GET(Fecode, 1 + 2*LINK_SIZE);\n\nif (mb->callout == NULL) return 0;   /* No callout function provided */\n\n/* The original matching code (pre 10.30) worked directly with the ovector\npassed by the user, and this was passed to callouts. Now that the working\novector is in the backtracking frame, it no longer needs to reserve space for\nthe overall match offsets (which would waste space in the frame). For backward\ncompatibility, however, we pass capture_top and offset_vector to the callout as\nif for the extended ovector, and we ensure that the first two slots are unset\nby preserving and restoring their current contents. Picky compilers complain if\nreferences such as Fovector\u00dd-2\u00a8 are use directly, so we set up a separate\npointer. */\n\ncallout_ovector = (PCRE2_SIZE *)(Fovector) - 2;\n\n/* The cb->version, cb->subject, cb->subject_length, and cb->start_match fields\nare set externally. The first 3 never change; the last is updated for each\nbumpalong. */\n\ncb = mb->cb;\ncb->capture_top      = (uint32_t)Foffset_top/2 + 1;\ncb->capture_last     = Fcapture_last;\ncb->offset_vector    = callout_ovector;\ncb->mark             = mb->nomatch_mark;\ncb->current_position = (PCRE2_SIZE)(Feptr - mb->start_subject);\ncb->pattern_position = GET(Fecode, 1);\ncb->next_item_length = GET(Fecode, 1 + LINK_SIZE);\n\nif (*Fecode == OP_CALLOUT)  /* Numerical callout */\n  {\n  cb->callout_number = Fecode\u00dd1 + 2*LINK_SIZE\u00a8;\n  cb->callout_string_offset = 0;\n  cb->callout_string = NULL;\n  cb->callout_string_length = 0;\n  }\nelse  /* String callout */\n  {\n  cb->callout_number = 0;\n  cb->callout_string_offset = GET(Fecode, 1 + 3*LINK_SIZE);\n  cb->callout_string = Fecode + (1 + 4*LINK_SIZE) + 1;\n  cb->callout_string_length =\n    *lengthptr - (1 + 4*LINK_SIZE) - 2;\n  }\n\nsave0 = callout_ovector\u00dd0\u00a8;\nsave1 = callout_ovector\u00dd1\u00a8;\ncallout_ovector\u00dd0\u00a8 = callout_ovector\u00dd1\u00a8 = PCRE2_UNSET;\nrc = mb->callout(cb, mb->callout_data);\ncallout_ovector\u00dd0\u00a8 = save0;\ncallout_ovector\u00dd1\u00a8 = save1;\ncb->callout_flags = 0;\nreturn rc;\n}\n\n\n\n/*************************************************\n*          Match a back-reference                *\n*************************************************/\n\n/* This function is called only when it is known that the offset lies within\nthe offsets that have so far been used in the match. Note that in caseless\nUTF-8 mode, the number of subject bytes matched may be different to the number\nof reference bytes. (In theory this could also happen in UTF-16 mode, but it\nseems unlikely.)\n\nArguments:\n  offset      index into the offset vector\n  caseless    TRUE if caseless\n  F           the current backtracking frame pointer\n  mb          points to match block\n  lengthptr   pointer for returning the length matched\n\nReturns:      = 0 sucessful match; number of code units matched is set\n              < 0 no match\n              > 0 partial match\n*/\n\nstatic int\nmatch_ref(PCRE2_SIZE offset, BOOL caseless, heapframe *F, match_block *mb,\n  PCRE2_SIZE *lengthptr)\n{\nPCRE2_SPTR p;\nPCRE2_SIZE length;\nPCRE2_SPTR eptr;\nPCRE2_SPTR eptr_start;\n\n/* Deal with an unset group. The default is no match, but there is an option to\nmatch an empty string. */\n\nif (offset >= Foffset_top || Fovector\u00ddoffset\u00a8 == PCRE2_UNSET)\n  {\n  if ((mb->poptions & PCRE2_MATCH_UNSET_BACKREF) != 0)\n    {\n    *lengthptr = 0;\n    return 0;      /* Match */\n    }\n  else return -1;  /* No match */\n  }\n\n/* Separate the caseless and UTF cases for speed. */\n\neptr = eptr_start = Feptr;\np = mb->start_subject + Fovector\u00ddoffset\u00a8;\nlength = Fovector\u00ddoffset+1\u00a8 - Fovector\u00ddoffset\u00a8;\n\nif (caseless)\n  {\n#if defined SUPPORT_UNICODE\n  BOOL utf = (mb->poptions & PCRE2_UTF) != 0;\n\n  if (utf || (mb->poptions & PCRE2_UCP) != 0)\n    {\n    PCRE2_SPTR endptr = p + length;\n\n    /* Match characters up to the end of the reference. NOTE: the number of\n    code units matched may differ, because in UTF-8 there are some characters\n    whose upper and lower case codes have different numbers of bytes. For\n    example, U+023A (2 bytes in UTF-8) is the upper case version of U+2C65 (3\n    bytes in UTF-8); a sequence of 3 of the former uses 6 bytes, as does a\n    sequence of two of the latter. It is important, therefore, to check the\n    length along the reference, not along the subject (earlier code did this\n    wrong). UCP without uses Unicode properties but without UTF encoding. */\n\n    while (p < endptr)\n      {\n      uint32_t c, d;\n      const ucd_record *ur;\n      if (eptr >= mb->end_subject) return 1;   /* Partial match */\n\n      if (utf)\n        {\n        GETCHARINC(c, eptr);\n        GETCHARINC(d, p);\n        }\n      else\n        {\n        c = *eptr++;\n        d = *p++;\n        }\n\n      ur = GET_UCD(d);\n      if (c != d && c != (uint32_t)((int)d + ur->other_case))\n        {\n        const uint32_t *pp = PRIV(ucd_caseless_sets) + ur->caseset;\n        for (;;)\n          {\n          if (c < *pp) return -1;  /* No match */\n          if (c == *pp++) break;\n          }\n        }\n      }\n    }\n  else\n#endif\n\n  /* Not in UTF or UCP mode */\n    {\n    for (; length > 0; length--)\n      {\n      uint32_t cc, cp;\n      if (eptr >= mb->end_subject) return 1;   /* Partial match */\n      cc = UCHAR21TEST(eptr);\n      cp = UCHAR21TEST(p);\n      if (TABLE_GET(cp, mb->lcc, cp) != TABLE_GET(cc, mb->lcc, cc))\n        return -1;  /* No match */\n      p++;\n      eptr++;\n      }\n    }\n  }\n\n/* In the caseful case, we can just compare the code units, whether or not we\nare in UTF and/or UCP mode. When partial matching, we have to do this unit by\nunit. */\n\nelse\n  {\n  if (mb->partial != 0)\n    {\n    for (; length > 0; length--)\n      {\n      if (eptr >= mb->end_subject) return 1;   /* Partial match */\n      if (UCHAR21INCTEST(p) != UCHAR21INCTEST(eptr)) return -1;  /* No match */\n      }\n    }\n\n  /* Not partial matching */\n\n  else\n    {\n    if ((PCRE2_SIZE)(mb->end_subject - eptr) < length) return 1; /* Partial */\n    if (memcmp(p, eptr, CU2BYTES(length)) != 0) return -1;  /* No match */\n    eptr += length;\n    }\n  }\n\n*lengthptr = eptr - eptr_start;\nreturn 0;  /* Match */\n}\n\n\n\n/******************************************************************************\n*******************************************************************************\n                   \"Recursion\" in the match() function\n\nThe original match() function was highly recursive, but this proved to be the\nsource of a number of problems over the years, mostly because of the relatively\nsmall system stacks that are commonly found. As new features were added to\npatterns, various kludges were invented to reduce the amount of stack used,\nmaking the code hard to understand in places.\n\nA version did exist that used individual frames on the heap instead of calling\nmatch() recursively, but this ran substantially slower. The current version is\na refactoring that uses a vector of frames to remember backtracking points.\nThis runs no slower, and possibly even a bit faster than the original recursive\nimplementation. An initial vector of size START_FRAMES_SIZE (enough for maybe\n50 frames) is allocated on the system stack. If this is not big enough, the\nheap is used for a larger vector.\n\n*******************************************************************************\n******************************************************************************/\n\n\n\n\n/*************************************************\n*       Macros for the match() function          *\n*************************************************/\n\n/* These macros pack up tests that are used for partial matching several times\nin the code. The second one is used when we already know we are past the end of\nthe subject. We set the \"hit end\" flag if the pointer is at the end of the\nsubject and either (a) the pointer is past the earliest inspected character\n(i.e. something has been matched, even if not part of the actual matched\nstring), or (b) the pattern contains a lookbehind. These are the conditions for\nwhich adding more characters may allow the current match to continue.\n\nFor hard partial matching, we immediately return a partial match. Otherwise,\ncarrying on means that a complete match on the current subject will be sought.\nA partial match is returned only if no complete match can be found. */\n\n#define CHECK_PARTIAL()\\\n  if (Feptr >= mb->end_subject) \\\n    { \\\n    SCHECK_PARTIAL(); \\\n    }\n\n#define SCHECK_PARTIAL()\\\n  if (mb->partial != 0 && \\\n      (Feptr > mb->start_used_ptr || mb->allowemptypartial)) \\\n    { \\\n    mb->hitend = TRUE; \\\n    if (mb->partial > 1) return PCRE2_ERROR_PARTIAL; \\\n    }\n\n\n/* These macros are used to implement backtracking. They simulate a recursive\ncall to the match() function by means of a local vector of frames which\nremember the backtracking points. */\n\n#define RMATCH(ra,rb)\\\n  {\\\n  start_ecode = ra;\\\n  Freturn_id = rb;\\\n  goto MATCH_RECURSE;\\\n  L_##rb:;\\\n  }\n\n#define RRETURN(ra)\\\n  {\\\n  rrc = ra;\\\n  goto RETURN_SWITCH;\\\n  }\n\n\n\n/*************************************************\n*         Match from current position            *\n*************************************************/\n\n/* This function is called to run one match attempt at a single starting point\nin the subject.\n\nPerformance note: It might be tempting to extract commonly used fields from the\nmb structure (e.g. end_subject) into individual variables to improve\nperformance. Tests using gcc on a SPARC disproved this; in the first case, it\nmade performance worse.\n\nArguments:\n   start_eptr   starting character in subject\n   start_ecode  starting position in compiled code\n   ovector      pointer to the final output vector\n   oveccount    number of pairs in ovector\n   top_bracket  number of capturing parentheses in the pattern\n   frame_size   size of each backtracking frame\n   mb           pointer to \"static\" variables block\n\nReturns:        MATCH_MATCH if matched            )  these values are >= 0\n                MATCH_NOMATCH if failed to match  )\n                negative MATCH_xxx value for PRUNE, SKIP, etc\n                negative PCRE2_ERROR_xxx value if aborted by an error condition\n                (e.g. stopped by repeated call or depth limit)\n*/\n\nstatic int\nmatch(PCRE2_SPTR start_eptr, PCRE2_SPTR start_ecode, PCRE2_SIZE *ovector,\n  uint16_t oveccount, uint16_t top_bracket, PCRE2_SIZE frame_size,\n  match_block *mb)\n{\n/* Frame-handling variables */\n\nheapframe *F;           /* Current frame pointer */\nheapframe *N = NULL;    /* Temporary frame pointers */\nheapframe *P = NULL;\nheapframe *assert_accept_frame = NULL;  /* For passing back a frame with captures */\nPCRE2_SIZE frame_copy_size;     /* Amount to copy when creating a new frame */\n\n/* Local variables that do not need to be preserved over calls to RRMATCH(). */\n\nPCRE2_SPTR bracode;     /* Temp pointer to start of group */\nPCRE2_SIZE offset;      /* Used for group offsets */\nPCRE2_SIZE length;      /* Used for various length calculations */\n\nint rrc;                /* Return from functions & backtracking \"recursions\" */\n#ifdef SUPPORT_UNICODE\nint proptype;           /* Type of character property */\n#endif\n\nuint32_t i;             /* Used for local loops */\nuint32_t fc;            /* Character values */\nuint32_t number;        /* Used for group and other numbers */\nuint32_t reptype = 0;   /* Type of repetition (0 to avoid compiler warning) */\nuint32_t group_frame_type;  /* Specifies type for new group frames */\n\nBOOL condition;         /* Used in conditional groups */\nBOOL cur_is_word;       /* Used in \"word\" tests */\nBOOL prev_is_word;      /* Used in \"word\" tests */\n\n/* UTF and UCP flags */\n\n#ifdef SUPPORT_UNICODE\nBOOL utf = (mb->poptions & PCRE2_UTF) != 0;\nBOOL ucp = (mb->poptions & PCRE2_UCP) != 0;\n#else\nBOOL utf = FALSE;  /* Required for convenience even when no Unicode support */\n#endif\n\n/* This is the length of the last part of a backtracking frame that must be\ncopied when a new frame is created. */\n\nframe_copy_size = frame_size - offsetof(heapframe, eptr);\n\n/* Set up the first current frame at the start of the vector, and initialize\nfields that are not reset for new frames. */\n\nF = mb->match_frames;\nFrdepth = 0;                        /* \"Recursion\" depth */\nFcapture_last = 0;                  /* Number of most recent capture */\nFcurrent_recurse = RECURSE_UNSET;   /* Not pattern recursing. */\nFstart_match = Feptr = start_eptr;  /* Current data pointer and start match */\nFmark = NULL;                       /* Most recent mark */\nFoffset_top = 0;                    /* End of captures within the frame */\nFlast_group_offset = PCRE2_UNSET;   /* Saved frame of most recent group */\ngroup_frame_type = 0;               /* Not a start of group frame */\ngoto NEW_FRAME;                     /* Start processing with this frame */\n\n/* Come back here when we want to create a new frame for remembering a\nbacktracking point. */\n\nMATCH_RECURSE:\n\n/* Set up a new backtracking frame. If the vector is full, get a new one\non the heap, doubling the size, but constrained by the heap limit. */\n\nN = (heapframe *)((char *)F + frame_size);\nif (N >= mb->match_frames_top)\n  {\n  PCRE2_SIZE newsize = mb->frame_vector_size * 2;\n  heapframe *new;\n\n  if ((newsize / 1024) > mb->heap_limit)\n    {\n    PCRE2_SIZE maxsize = ((mb->heap_limit * 1024)/frame_size) * frame_size;\n    if (mb->frame_vector_size >= maxsize) return PCRE2_ERROR_HEAPLIMIT;\n    newsize = maxsize;\n    }\n\n  new = mb->memctl.malloc(newsize, mb->memctl.memory_data);\n  if (new == NULL) return PCRE2_ERROR_NOMEMORY;\n  memcpy(new, mb->match_frames, mb->frame_vector_size);\n\n  F = (heapframe *)((char *)new + ((char *)F - (char *)mb->match_frames));\n  N = (heapframe *)((char *)F + frame_size);\n\n  if (mb->match_frames != mb->stack_frames)\n    mb->memctl.free(mb->match_frames, mb->memctl.memory_data);\n  mb->match_frames = new;\n  mb->match_frames_top = (heapframe *)((char *)mb->match_frames + newsize);\n  mb->frame_vector_size = newsize;\n  }\n\n#ifdef DEBUG_SHOW_RMATCH\nfprintf(stderr, \"++ RMATCH %2d frame=%d\", Freturn_id, Frdepth + 1);\nif (group_frame_type != 0)\n  {\n  fprintf(stderr, \" type=%x \", group_frame_type);\n  switch (GF_IDMASK(group_frame_type))\n    {\n    case GF_CAPTURE:\n    fprintf(stderr, \"capture=%d\", GF_DATAMASK(group_frame_type));\n    break;\n\n    case GF_NOCAPTURE:\n    fprintf(stderr, \"nocapture op=%d\", GF_DATAMASK(group_frame_type));\n    break;\n\n    case GF_CONDASSERT:\n    fprintf(stderr, \"condassert op=%d\", GF_DATAMASK(group_frame_type));\n    break;\n\n    case GF_RECURSE:\n    fprintf(stderr, \"recurse=%d\", GF_DATAMASK(group_frame_type));\n    break;\n\n    default:\n    fprintf(stderr, \"*** unknown ***\");\n    break;\n    }\n  }\nfprintf(stderr, \"\\n\");\n#endif\n\n/* Copy those fields that must be copied into the new frame, increase the\n\"recursion\" depth (i.e. the new frame's index) and then make the new frame\ncurrent. */\n\nmemcpy((char *)N + offsetof(heapframe, eptr),\n       (char *)F + offsetof(heapframe, eptr),\n       frame_copy_size);\n\nN->rdepth = Frdepth + 1;\nF = N;\n\n/* Carry on processing with a new frame. */\n\nNEW_FRAME:\nFgroup_frame_type = group_frame_type;\nFecode = start_ecode;      /* Starting code pointer */\nFback_frame = frame_size;  /* Default is go back one frame */\n\n/* If this is a special type of group frame, remember its offset for quick\naccess at the end of the group. If this is a recursion, set a new current\nrecursion value. */\n\nif (group_frame_type != 0)\n  {\n  Flast_group_offset = (char *)F - (char *)mb->match_frames;\n  if (GF_IDMASK(group_frame_type) == GF_RECURSE)\n    Fcurrent_recurse = GF_DATAMASK(group_frame_type);\n  group_frame_type = 0;\n  }\n\n\n/* ========================================================================= */\n/* This is the main processing loop. First check that we haven't recorded too\nmany backtracks (search tree is too large), or that we haven't exceeded the\nrecursive depth limit (used too many backtracking frames). If not, process the\nopcodes. */\n\nif (mb->match_call_count++ >= mb->match_limit) return PCRE2_ERROR_MATCHLIMIT;\nif (Frdepth >= mb->match_limit_depth) return PCRE2_ERROR_DEPTHLIMIT;\n\nfor (;;)\n  {\n#ifdef DEBUG_SHOW_OPS\nfprintf(stderr, \"++ op=%d\\n\", *Fecode);\n#endif\n\n  Fop = (uint8_t)(*Fecode);  /* Cast needed for 16-bit and 32-bit modes */\n  switch(Fop)\n    {\n    /* ===================================================================== */\n    /* Before OP_ACCEPT there may be any number of OP_CLOSE opcodes, to close\n    any currently open capturing brackets. Unlike reaching the end of a group,\n    where we know the starting frame is at the top of the chained frames, in\n    this case we have to search back for the relevant frame in case other types\n    of group that use chained frames have intervened. Multiple OP_CLOSEs always\n    come innermost first, which matches the chain order. We can ignore this in\n    a recursion, because captures are not passed out of recursions. */\n\n    case OP_CLOSE:\n    if (Fcurrent_recurse == RECURSE_UNSET)\n      {\n      number = GET2(Fecode, 1);\n      offset = Flast_group_offset;\n      for(;;)\n        {\n        if (offset == PCRE2_UNSET) return PCRE2_ERROR_INTERNAL;\n        N = (heapframe *)((char *)mb->match_frames + offset);\n        P = (heapframe *)((char *)N - frame_size);\n        if (N->group_frame_type == (GF_CAPTURE | number)) break;\n        offset = P->last_group_offset;\n        }\n      offset = (number << 1) - 2;\n      Fcapture_last = number;\n      Fovector\u00ddoffset\u00a8 = P->eptr - mb->start_subject;\n      Fovector\u00ddoffset+1\u00a8 = Feptr - mb->start_subject;\n      if (offset >= Foffset_top) Foffset_top = offset + 2;\n      }\n    Fecode += PRIV(OP_lengths)\u00dd*Fecode\u00a8;\n    break;\n\n\n    /* ===================================================================== */\n    /* Real or forced end of the pattern, assertion, or recursion. In an\n    assertion ACCEPT, update the last used pointer and remember the current\n    frame so that the captures and mark can be fished out of it. */\n\n    case OP_ASSERT_ACCEPT:\n    if (Feptr > mb->last_used_ptr) mb->last_used_ptr = Feptr;\n    assert_accept_frame = F;\n    RRETURN(MATCH_ACCEPT);\n\n    /* If recursing, we have to find the most recent recursion. */\n\n    case OP_ACCEPT:\n    case OP_END:\n\n    /* Handle end of a recursion. */\n\n    if (Fcurrent_recurse != RECURSE_UNSET)\n      {\n      offset = Flast_group_offset;\n      for(;;)\n        {\n        if (offset == PCRE2_UNSET) return PCRE2_ERROR_INTERNAL;\n        N = (heapframe *)((char *)mb->match_frames + offset);\n        P = (heapframe *)((char *)N - frame_size);\n        if (GF_IDMASK(N->group_frame_type) == GF_RECURSE) break;\n        offset = P->last_group_offset;\n        }\n\n      /* N is now the frame of the recursion; the previous frame is at the\n      OP_RECURSE position. Go back there, copying the current subject position\n      and mark, and move on past the OP_RECURSE. */\n\n      P->eptr = Feptr;\n      P->mark = Fmark;\n      F = P;\n      Fecode += 1 + LINK_SIZE;\n      continue;\n      }\n\n    /* Not a recursion. Fail for an empty string match if either PCRE2_NOTEMPTY\n    is set, or if PCRE2_NOTEMPTY_ATSTART is set and we have matched at the\n    start of the subject. In both cases, backtracking will then try other\n    alternatives, if any. */\n\n    if (Feptr == Fstart_match &&\n         ((mb->moptions & PCRE2_NOTEMPTY) != 0 ||\n           ((mb->moptions & PCRE2_NOTEMPTY_ATSTART) != 0 &&\n             Fstart_match == mb->start_subject + mb->start_offset)))\n      RRETURN(MATCH_NOMATCH);\n\n    /* Also fail if PCRE2_ENDANCHORED is set and the end of the match is not\n    the end of the subject. After (*ACCEPT) we fail the entire match (at this\n    position) but backtrack on reaching the end of the pattern. */\n\n    if (Feptr < mb->end_subject &&\n        ((mb->moptions | mb->poptions) & PCRE2_ENDANCHORED) != 0)\n      {\n      if (Fop == OP_END) RRETURN(MATCH_NOMATCH);\n      return MATCH_NOMATCH;\n      }\n\n    /* We have a successful match of the whole pattern. Record the result and\n    then do a direct return from the function. If there is space in the offset\n    vector, set any pairs that follow the highest-numbered captured string but\n    are less than the number of capturing groups in the pattern to PCRE2_UNSET.\n    It is documented that this happens. \"Gaps\" are set to PCRE2_UNSET\n    dynamically. It is only those at the end that need setting here. */\n\n    mb->end_match_ptr = Feptr;           /* Record where we ended */\n    mb->end_offset_top = Foffset_top;    /* and how many extracts were taken */\n    mb->mark = Fmark;                    /* and the last success mark */\n    if (Feptr > mb->last_used_ptr) mb->last_used_ptr = Feptr;\n\n    ovector\u00dd0\u00a8 = Fstart_match - mb->start_subject;\n    ovector\u00dd1\u00a8 = Feptr - mb->start_subject;\n\n    /* Set i to the smaller of the sizes of the external and frame ovectors. */\n\n    i = 2 * ((top_bracket + 1 > oveccount)? oveccount : top_bracket + 1);\n    memcpy(ovector + 2, Fovector, (i - 2) * sizeof(PCRE2_SIZE));\n    while (--i >= Foffset_top + 2) ovector\u00ddi\u00a8 = PCRE2_UNSET;\n    return MATCH_MATCH;  /* Note: NOT RRETURN */\n\n\n    /*===================================================================== */\n    /* Match any single character type except newline; have to take care with\n    CRLF newlines and partial matching. */\n\n    case OP_ANY:\n    if (IS_NEWLINE(Feptr)) RRETURN(MATCH_NOMATCH);\n    if (mb->partial != 0 &&\n        Feptr == mb->end_subject - 1 &&\n        NLBLOCK->nltype == NLTYPE_FIXED &&\n        NLBLOCK->nllen == 2 &&\n        UCHAR21TEST(Feptr) == NLBLOCK->nl\u00dd0\u00a8)\n      {\n      mb->hitend = TRUE;\n      if (mb->partial > 1) return PCRE2_ERROR_PARTIAL;\n      }\n    /* Fall through */\n\n    /* Match any single character whatsoever. */\n\n    case OP_ALLANY:\n    if (Feptr >= mb->end_subject)  /* DO NOT merge the Feptr++ here; it must */\n      {                            /* not be updated before SCHECK_PARTIAL. */\n      SCHECK_PARTIAL();\n      RRETURN(MATCH_NOMATCH);\n      }\n    Feptr++;\n#ifdef SUPPORT_UNICODE\n    if (utf) ACROSSCHAR(Feptr < mb->end_subject, Feptr, Feptr++);\n#endif\n    Fecode++;\n    break;\n\n\n    /* ===================================================================== */\n    /* Match a single code unit, even in UTF mode. This opcode really does\n    match any code unit, even newline. (It really should be called ANYCODEUNIT,\n    of course - the byte name is from pre-16 bit days.) */\n\n    case OP_ANYBYTE:\n    if (Feptr >= mb->end_subject)   /* DO NOT merge the Feptr++ here; it must */\n      {                             /* not be updated before SCHECK_PARTIAL. */\n      SCHECK_PARTIAL();\n      RRETURN(MATCH_NOMATCH);\n      }\n    Feptr++;\n    Fecode++;\n    break;\n\n\n    /* ===================================================================== */\n    /* Match a single character, casefully */\n\n    case OP_CHAR:\n#ifdef SUPPORT_UNICODE\n    if (utf)\n      {\n      Flength = 1;\n      Fecode++;\n      GETCHARLEN(fc, Fecode, Flength);\n      if (Flength > (PCRE2_SIZE)(mb->end_subject - Feptr))\n        {\n        CHECK_PARTIAL();             /* Not SCHECK_PARTIAL() */\n        RRETURN(MATCH_NOMATCH);\n        }\n      for (; Flength > 0; Flength--)\n        {\n        if (*Fecode++ != UCHAR21INC(Feptr)) RRETURN(MATCH_NOMATCH);\n        }\n      }\n    else\n#endif\n\n    /* Not UTF mode */\n      {\n      if (mb->end_subject - Feptr < 1)\n        {\n        SCHECK_PARTIAL();            /* This one can use SCHECK_PARTIAL() */\n        RRETURN(MATCH_NOMATCH);\n        }\n      if (Fecode\u00dd1\u00a8 != *Feptr++) RRETURN(MATCH_NOMATCH);\n      Fecode += 2;\n      }\n    break;\n\n\n    /* ===================================================================== */\n    /* Match a single character, caselessly. If we are at the end of the\n    subject, give up immediately. We get here only when the pattern character\n    has at most one other case. Characters with more than two cases are coded\n    as OP_PROP with the pseudo-property PT_CLIST. */\n\n    case OP_CHARI:\n    if (Feptr >= mb->end_subject)\n      {\n      SCHECK_PARTIAL();\n      RRETURN(MATCH_NOMATCH);\n      }\n\n#ifdef SUPPORT_UNICODE\n    if (utf)\n      {\n      Flength = 1;\n      Fecode++;\n      GETCHARLEN(fc, Fecode, Flength);\n\n      /* If the pattern character's value is < 128, we know that its other case\n      (if any) is also < 128 (and therefore only one code unit long in all\n      code-unit widths), so we can use the fast lookup table. We checked above\n      that there is at least one character left in the subject. */\n\n      if (fc < 128)\n        {\n        uint32_t cc = UCHAR21(Feptr);\n        if (mb->lcc\u00ddfc\u00a8 != TABLE_GET(cc, mb->lcc, cc)) RRETURN(MATCH_NOMATCH);\n        Fecode++;\n        Feptr++;\n        }\n\n      /* Otherwise we must pick up the subject character and use Unicode\n      property support to test its other case. Note that we cannot use the\n      value of \"Flength\" to check for sufficient bytes left, because the other\n      case of the character may have more or fewer code units. */\n\n      else\n        {\n        uint32_t dc;\n        GETCHARINC(dc, Feptr);\n        Fecode += Flength;\n        if (dc != fc && dc != UCD_OTHERCASE(fc)) RRETURN(MATCH_NOMATCH);\n        }\n      }\n\n    /* If UCP is set without UTF we must do the same as above, but with one\n    character per code unit. */\n\n    else if (ucp)\n      {\n      uint32_t cc = UCHAR21(Feptr);\n      fc = Fecode\u00dd1\u00a8;\n      if (fc < 128)\n        {\n        if (mb->lcc\u00ddfc\u00a8 != TABLE_GET(cc, mb->lcc, cc)) RRETURN(MATCH_NOMATCH);\n        }\n      else\n        {\n        if (cc != fc && cc != UCD_OTHERCASE(fc)) RRETURN(MATCH_NOMATCH);\n        }\n      Feptr++;\n      Fecode += 2;\n      }\n\n    else\n#endif   /* SUPPORT_UNICODE */\n\n    /* Not UTF or UCP mode; use the table for characters < 256. */\n      {\n      if (TABLE_GET(Fecode\u00dd1\u00a8, mb->lcc, Fecode\u00dd1\u00a8)\n          != TABLE_GET(*Feptr, mb->lcc, *Feptr)) RRETURN(MATCH_NOMATCH);\n      Feptr++;\n      Fecode += 2;\n      }\n    break;\n\n\n    /* ===================================================================== */\n    /* Match not a single character. */\n\n    case OP_NOT:\n    case OP_NOTI:\n    if (Feptr >= mb->end_subject)\n      {\n      SCHECK_PARTIAL();\n      RRETURN(MATCH_NOMATCH);\n      }\n\n#ifdef SUPPORT_UNICODE\n    if (utf)\n      {\n      uint32_t ch;\n      Fecode++;\n      GETCHARINC(ch, Fecode);\n      GETCHARINC(fc, Feptr);\n      if (ch == fc)\n        {\n        RRETURN(MATCH_NOMATCH);  /* Caseful match */\n        }\n      else if (Fop == OP_NOTI)   /* If caseless */\n        {\n        if (ch > 127)\n          ch = UCD_OTHERCASE(ch);\n        else\n          ch = (mb->fcc)\u00ddch\u00a8;\n        if (ch == fc) RRETURN(MATCH_NOMATCH);\n        }\n      }\n\n    /* UCP without UTF is as above, but with one character per code unit. */\n\n    else if (ucp)\n      {\n      uint32_t ch;\n      fc = UCHAR21INC(Feptr);\n      ch = Fecode\u00dd1\u00a8;\n      Fecode += 2;\n\n      if (ch == fc)\n        {\n        RRETURN(MATCH_NOMATCH);  /* Caseful match */\n        }\n      else if (Fop == OP_NOTI)   /* If caseless */\n        {\n        if (ch > 127)\n          ch = UCD_OTHERCASE(ch);\n        else\n          ch = (mb->fcc)\u00ddch\u00a8;\n        if (ch == fc) RRETURN(MATCH_NOMATCH);\n        }\n      }\n\n    else\n#endif  /* SUPPORT_UNICODE */\n\n    /* Neither UTF nor UCP is set */\n\n      {\n      uint32_t ch = Fecode\u00dd1\u00a8;\n      fc = UCHAR21INC(Feptr);\n      if (ch == fc || (Fop == OP_NOTI && TABLE_GET(ch, mb->fcc, ch) == fc))\n        RRETURN(MATCH_NOMATCH);\n      Fecode += 2;\n      }\n    break;\n\n\n    /* ===================================================================== */\n    /* Match a single character repeatedly. */\n\n#define Loclength    F->temp_size\n#define Lstart_eptr  F->temp_sptr\u00dd0\u00a8\n#define Lcharptr     F->temp_sptr\u00dd1\u00a8\n#define Lmin         F->temp_32\u00dd0\u00a8\n#define Lmax         F->temp_32\u00dd1\u00a8\n#define Lc           F->temp_32\u00dd2\u00a8\n#define Loc          F->temp_32\u00dd3\u00a8\n\n    case OP_EXACT:\n    case OP_EXACTI:\n    Lmin = Lmax = GET2(Fecode, 1);\n    Fecode += 1 + IMM2_SIZE;\n    goto REPEATCHAR;\n\n    case OP_POSUPTO:\n    case OP_POSUPTOI:\n    reptype = REPTYPE_POS;\n    Lmin = 0;\n    Lmax = GET2(Fecode, 1);\n    Fecode += 1 + IMM2_SIZE;\n    goto REPEATCHAR;\n\n    case OP_UPTO:\n    case OP_UPTOI:\n    reptype = REPTYPE_MAX;\n    Lmin = 0;\n    Lmax = GET2(Fecode, 1);\n    Fecode += 1 + IMM2_SIZE;\n    goto REPEATCHAR;\n\n    case OP_MINUPTO:\n    case OP_MINUPTOI:\n    reptype = REPTYPE_MIN;\n    Lmin = 0;\n    Lmax = GET2(Fecode, 1);\n    Fecode += 1 + IMM2_SIZE;\n    goto REPEATCHAR;\n\n    case OP_POSSTAR:\n    case OP_POSSTARI:\n    reptype = REPTYPE_POS;\n    Lmin = 0;\n    Lmax = UINT32_MAX;\n    Fecode++;\n    goto REPEATCHAR;\n\n    case OP_POSPLUS:\n    case OP_POSPLUSI:\n    reptype = REPTYPE_POS;\n    Lmin = 1;\n    Lmax = UINT32_MAX;\n    Fecode++;\n    goto REPEATCHAR;\n\n    case OP_POSQUERY:\n    case OP_POSQUERYI:\n    reptype = REPTYPE_POS;\n    Lmin = 0;\n    Lmax = 1;\n    Fecode++;\n    goto REPEATCHAR;\n\n    case OP_STAR:\n    case OP_STARI:\n    case OP_MINSTAR:\n    case OP_MINSTARI:\n    case OP_PLUS:\n    case OP_PLUSI:\n    case OP_MINPLUS:\n    case OP_MINPLUSI:\n    case OP_QUERY:\n    case OP_QUERYI:\n    case OP_MINQUERY:\n    case OP_MINQUERYI:\n    fc = *Fecode++ - ((Fop < OP_STARI)? OP_STAR : OP_STARI);\n    Lmin = rep_min\u00ddfc\u00a8;\n    Lmax = rep_max\u00ddfc\u00a8;\n    reptype = rep_typ\u00ddfc\u00a8;\n\n    /* Common code for all repeated single-character matches. We first check\n    for the minimum number of characters. If the minimum equals the maximum, we\n    are done. Otherwise, if minimizing, check the rest of the pattern for a\n    match; if there isn't one, advance up to the maximum, one character at a\n    time.\n\n    If maximizing, advance up to the maximum number of matching characters,\n    until Feptr is past the end of the maximum run. If possessive, we are\n    then done (no backing up). Otherwise, match at this position; anything\n    other than no match is immediately returned. For nomatch, back up one\n    character, unless we are matching \\R and the last thing matched was\n    \\r\\n, in which case, back up two code units until we reach the first\n    optional character position.\n\n    The various UTF/non-UTF and caseful/caseless cases are handled separately,\n    for speed. */\n\n    REPEATCHAR:\n#ifdef SUPPORT_UNICODE\n    if (utf)\n      {\n      Flength = 1;\n      Lcharptr = Fecode;\n      GETCHARLEN(fc, Fecode, Flength);\n      Fecode += Flength;\n\n      /* Handle multi-code-unit character matching, caseful and caseless. */\n\n      if (Flength > 1)\n        {\n        uint32_t othercase;\n\n        if (Fop >= OP_STARI &&     /* Caseless */\n            (othercase = UCD_OTHERCASE(fc)) != fc)\n          Loclength = PRIV(ord2utf)(othercase, Foccu);\n        else Loclength = 0;\n\n        for (i = 1; i <= Lmin; i++)\n          {\n          if (Feptr <= mb->end_subject - Flength &&\n            memcmp(Feptr, Lcharptr, CU2BYTES(Flength)) == 0) Feptr += Flength;\n          else if (Loclength > 0 &&\n                   Feptr <= mb->end_subject - Loclength &&\n                   memcmp(Feptr, Foccu, CU2BYTES(Loclength)) == 0)\n            Feptr += Loclength;\n          else\n            {\n            CHECK_PARTIAL();\n            RRETURN(MATCH_NOMATCH);\n            }\n          }\n\n        if (Lmin == Lmax) continue;\n\n        if (reptype == REPTYPE_MIN)\n          {\n          for (;;)\n            {\n            RMATCH(Fecode, RM202);\n            if (rrc != MATCH_NOMATCH) RRETURN(rrc);\n            if (Lmin++ >= Lmax) RRETURN(MATCH_NOMATCH);\n            if (Feptr <= mb->end_subject - Flength &&\n              memcmp(Feptr, Lcharptr, CU2BYTES(Flength)) == 0) Feptr += Flength;\n            else if (Loclength > 0 &&\n                     Feptr <= mb->end_subject - Loclength &&\n                     memcmp(Feptr, Foccu, CU2BYTES(Loclength)) == 0)\n              Feptr += Loclength;\n            else\n              {\n              CHECK_PARTIAL();\n              RRETURN(MATCH_NOMATCH);\n              }\n            }\n          /* Control never gets here */\n          }\n\n        else  /* Maximize */\n          {\n          Lstart_eptr = Feptr;\n          for (i = Lmin; i < Lmax; i++)\n            {\n            if (Feptr <= mb->end_subject - Flength &&\n                memcmp(Feptr, Lcharptr, CU2BYTES(Flength)) == 0)\n              Feptr += Flength;\n            else if (Loclength > 0 &&\n                     Feptr <= mb->end_subject - Loclength &&\n                     memcmp(Feptr, Foccu, CU2BYTES(Loclength)) == 0)\n              Feptr += Loclength;\n            else\n              {\n              CHECK_PARTIAL();\n              break;\n              }\n            }\n\n          /* After \\C in UTF mode, Lstart_eptr might be in the middle of a\n          Unicode character. Use <= Lstart_eptr to ensure backtracking doesn't\n          go too far. */\n\n          if (reptype != REPTYPE_POS) for(;;)\n            {\n            if (Feptr <= Lstart_eptr) break;\n            RMATCH(Fecode, RM203);\n            if (rrc != MATCH_NOMATCH) RRETURN(rrc);\n            Feptr--;\n            BACKCHAR(Feptr);\n            }\n          }\n        break;   /* End of repeated wide character handling */\n        }\n\n      /* Length of UTF character is 1. Put it into the preserved variable and\n      fall through to the non-UTF code. */\n\n      Lc = fc;\n      }\n    else\n#endif  /* SUPPORT_UNICODE */\n\n    /* When not in UTF mode, load a single-code-unit character. Then proceed as\n    above, using Unicode casing if either UTF or UCP is set. */\n\n    Lc = *Fecode++;\n\n    /* Caseless comparison */\n\n    if (Fop >= OP_STARI)\n      {\n#if PCRE2_CODE_UNIT_WIDTH == 8\n#ifdef SUPPORT_UNICODE\n      if (ucp && !utf && Lc > 127) Loc = UCD_OTHERCASE(Lc);\n      else\n#endif  /* SUPPORT_UNICODE */\n      /* Lc will be < 128 in UTF-8 mode. */\n      Loc = mb->fcc\u00ddLc\u00a8;\n#else /* 16-bit & 32-bit */\n#ifdef SUPPORT_UNICODE\n      if ((utf || ucp) && Lc > 127) Loc = UCD_OTHERCASE(Lc);\n      else\n#endif  /* SUPPORT_UNICODE */\n      Loc = TABLE_GET(Lc, mb->fcc, Lc);\n#endif  /* PCRE2_CODE_UNIT_WIDTH == 8 */\n\n      for (i = 1; i <= Lmin; i++)\n        {\n        uint32_t cc;                 /* Faster than PCRE2_UCHAR */\n        if (Feptr >= mb->end_subject)\n          {\n          SCHECK_PARTIAL();\n          RRETURN(MATCH_NOMATCH);\n          }\n        cc = UCHAR21TEST(Feptr);\n        if (Lc != cc && Loc != cc) RRETURN(MATCH_NOMATCH);\n        Feptr++;\n        }\n      if (Lmin == Lmax) continue;\n\n      if (reptype == REPTYPE_MIN)\n        {\n        for (;;)\n          {\n          uint32_t cc;               /* Faster than PCRE2_UCHAR */\n          RMATCH(Fecode, RM25);\n          if (rrc != MATCH_NOMATCH) RRETURN(rrc);\n          if (Lmin++ >= Lmax) RRETURN(MATCH_NOMATCH);\n          if (Feptr >= mb->end_subject)\n            {\n            SCHECK_PARTIAL();\n            RRETURN(MATCH_NOMATCH);\n            }\n          cc = UCHAR21TEST(Feptr);\n          if (Lc != cc && Loc != cc) RRETURN(MATCH_NOMATCH);\n          Feptr++;\n          }\n        /* Control never gets here */\n        }\n\n      else  /* Maximize */\n        {\n        Lstart_eptr = Feptr;\n        for (i = Lmin; i < Lmax; i++)\n          {\n          uint32_t cc;               /* Faster than PCRE2_UCHAR */\n          if (Feptr >= mb->end_subject)\n            {\n            SCHECK_PARTIAL();\n            break;\n            }\n          cc = UCHAR21TEST(Feptr);\n          if (Lc != cc && Loc != cc) break;\n          Feptr++;\n          }\n        if (reptype != REPTYPE_POS) for (;;)\n          {\n          if (Feptr == Lstart_eptr) break;\n          RMATCH(Fecode, RM26);\n          Feptr--;\n          if (rrc != MATCH_NOMATCH) RRETURN(rrc);\n          }\n        }\n      }\n\n    /* Caseful comparisons (includes all multi-byte characters) */\n\n    else\n      {\n      for (i = 1; i <= Lmin; i++)\n        {\n        if (Feptr >= mb->end_subject)\n          {\n          SCHECK_PARTIAL();\n          RRETURN(MATCH_NOMATCH);\n          }\n        if (Lc != UCHAR21INCTEST(Feptr)) RRETURN(MATCH_NOMATCH);\n        }\n\n      if (Lmin == Lmax) continue;\n\n      if (reptype == REPTYPE_MIN)\n        {\n        for (;;)\n          {\n          RMATCH(Fecode, RM27);\n          if (rrc != MATCH_NOMATCH) RRETURN(rrc);\n          if (Lmin++ >= Lmax) RRETURN(MATCH_NOMATCH);\n          if (Feptr >= mb->end_subject)\n            {\n            SCHECK_PARTIAL();\n            RRETURN(MATCH_NOMATCH);\n            }\n          if (Lc != UCHAR21INCTEST(Feptr)) RRETURN(MATCH_NOMATCH);\n          }\n        /* Control never gets here */\n        }\n      else  /* Maximize */\n        {\n        Lstart_eptr = Feptr;\n        for (i = Lmin; i < Lmax; i++)\n          {\n          if (Feptr >= mb->end_subject)\n            {\n            SCHECK_PARTIAL();\n            break;\n            }\n\n          if (Lc != UCHAR21TEST(Feptr)) break;\n          Feptr++;\n          }\n\n        if (reptype != REPTYPE_POS) for (;;)\n          {\n          if (Feptr <= Lstart_eptr) break;\n          RMATCH(Fecode, RM28);\n          Feptr--;\n          if (rrc != MATCH_NOMATCH) RRETURN(rrc);\n          }\n        }\n      }\n    break;\n\n#undef Loclength\n#undef Lstart_eptr\n#undef Lcharptr\n#undef Lmin\n#undef Lmax\n#undef Lc\n#undef Loc\n\n\n    /* ===================================================================== */\n    /* Match a negated single one-byte character repeatedly. This is almost a\n    repeat of the code for a repeated single character, but I haven't found a\n    nice way of commoning these up that doesn't require a test of the\n    positive/negative option for each character match. Maybe that wouldn't add\n    very much to the time taken, but character matching *is* what this is all\n    about... */\n\n#define Lstart_eptr  F->temp_sptr\u00dd0\u00a8\n#define Lmin         F->temp_32\u00dd0\u00a8\n#define Lmax         F->temp_32\u00dd1\u00a8\n#define Lc           F->temp_32\u00dd2\u00a8\n#define Loc          F->temp_32\u00dd3\u00a8\n\n    case OP_NOTEXACT:\n    case OP_NOTEXACTI:\n    Lmin = Lmax = GET2(Fecode, 1);\n    Fecode += 1 + IMM2_SIZE;\n    goto REPEATNOTCHAR;\n\n    case OP_NOTUPTO:\n    case OP_NOTUPTOI:\n    Lmin = 0;\n    Lmax = GET2(Fecode, 1);\n    reptype = REPTYPE_MAX;\n    Fecode += 1 + IMM2_SIZE;\n    goto REPEATNOTCHAR;\n\n    case OP_NOTMINUPTO:\n    case OP_NOTMINUPTOI:\n    Lmin = 0;\n    Lmax = GET2(Fecode, 1);\n    reptype = REPTYPE_MIN;\n    Fecode += 1 + IMM2_SIZE;\n    goto REPEATNOTCHAR;\n\n    case OP_NOTPOSSTAR:\n    case OP_NOTPOSSTARI:\n    reptype = REPTYPE_POS;\n    Lmin = 0;\n    Lmax = UINT32_MAX;\n    Fecode++;\n    goto REPEATNOTCHAR;\n\n    case OP_NOTPOSPLUS:\n    case OP_NOTPOSPLUSI:\n    reptype = REPTYPE_POS;\n    Lmin = 1;\n    Lmax = UINT32_MAX;\n    Fecode++;\n    goto REPEATNOTCHAR;\n\n    case OP_NOTPOSQUERY:\n    case OP_NOTPOSQUERYI:\n    reptype = REPTYPE_POS;\n    Lmin = 0;\n    Lmax = 1;\n    Fecode++;\n    goto REPEATNOTCHAR;\n\n    case OP_NOTPOSUPTO:\n    case OP_NOTPOSUPTOI:\n    reptype = REPTYPE_POS;\n    Lmin = 0;\n    Lmax = GET2(Fecode, 1);\n    Fecode += 1 + IMM2_SIZE;\n    goto REPEATNOTCHAR;\n\n    case OP_NOTSTAR:\n    case OP_NOTSTARI:\n    case OP_NOTMINSTAR:\n    case OP_NOTMINSTARI:\n    case OP_NOTPLUS:\n    case OP_NOTPLUSI:\n    case OP_NOTMINPLUS:\n    case OP_NOTMINPLUSI:\n    case OP_NOTQUERY:\n    case OP_NOTQUERYI:\n    case OP_NOTMINQUERY:\n    case OP_NOTMINQUERYI:\n    fc = *Fecode++ - ((Fop >= OP_NOTSTARI)? OP_NOTSTARI: OP_NOTSTAR);\n    Lmin = rep_min\u00ddfc\u00a8;\n    Lmax = rep_max\u00ddfc\u00a8;\n    reptype = rep_typ\u00ddfc\u00a8;\n\n    /* Common code for all repeated single-character non-matches. */\n\n    REPEATNOTCHAR:\n    GETCHARINCTEST(Lc, Fecode);\n\n    /* The code is duplicated for the caseless and caseful cases, for speed,\n    since matching characters is likely to be quite common. First, ensure the\n    minimum number of matches are present. If Lmin = Lmax, we are done.\n    Otherwise, if minimizing, keep trying the rest of the expression and\n    advancing one matching character if failing, up to the maximum.\n    Alternatively, if maximizing, find the maximum number of characters and\n    work backwards. */\n\n    if (Fop >= OP_NOTSTARI)     /* Caseless */\n      {\n#ifdef SUPPORT_UNICODE\n      if ((utf || ucp) && Lc > 127)\n        Loc = UCD_OTHERCASE(Lc);\n      else\n#endif /* SUPPORT_UNICODE */\n\n      Loc = TABLE_GET(Lc, mb->fcc, Lc);  /* Other case from table */\n\n#ifdef SUPPORT_UNICODE\n      if (utf)\n        {\n        uint32_t d;\n        for (i = 1; i <= Lmin; i++)\n          {\n          if (Feptr >= mb->end_subject)\n            {\n            SCHECK_PARTIAL();\n            RRETURN(MATCH_NOMATCH);\n            }\n          GETCHARINC(d, Feptr);\n          if (Lc == d || Loc == d) RRETURN(MATCH_NOMATCH);\n          }\n        }\n      else\n#endif  /* SUPPORT_UNICODE */\n\n      /* Not UTF mode */\n        {\n        for (i = 1; i <= Lmin; i++)\n          {\n          if (Feptr >= mb->end_subject)\n            {\n            SCHECK_PARTIAL();\n            RRETURN(MATCH_NOMATCH);\n            }\n          if (Lc == *Feptr || Loc == *Feptr) RRETURN(MATCH_NOMATCH);\n          Feptr++;\n          }\n        }\n\n      if (Lmin == Lmax) continue;  /* Finished for exact count */\n\n      if (reptype == REPTYPE_MIN)\n        {\n#ifdef SUPPORT_UNICODE\n        if (utf)\n          {\n          uint32_t d;\n          for (;;)\n            {\n            RMATCH(Fecode, RM204);\n            if (rrc != MATCH_NOMATCH) RRETURN(rrc);\n            if (Lmin++ >= Lmax) RRETURN(MATCH_NOMATCH);\n            if (Feptr >= mb->end_subject)\n              {\n              SCHECK_PARTIAL();\n              RRETURN(MATCH_NOMATCH);\n              }\n            GETCHARINC(d, Feptr);\n            if (Lc == d || Loc == d) RRETURN(MATCH_NOMATCH);\n            }\n          }\n        else\n#endif  /*SUPPORT_UNICODE */\n\n        /* Not UTF mode */\n          {\n          for (;;)\n            {\n            RMATCH(Fecode, RM29);\n            if (rrc != MATCH_NOMATCH) RRETURN(rrc);\n            if (Lmin++ >= Lmax) RRETURN(MATCH_NOMATCH);\n            if (Feptr >= mb->end_subject)\n              {\n              SCHECK_PARTIAL();\n              RRETURN(MATCH_NOMATCH);\n              }\n            if (Lc == *Feptr || Loc == *Feptr) RRETURN(MATCH_NOMATCH);\n            Feptr++;\n            }\n          }\n        /* Control never gets here */\n        }\n\n      /* Maximize case */\n\n      else\n        {\n        Lstart_eptr = Feptr;\n\n#ifdef SUPPORT_UNICODE\n        if (utf)\n          {\n          uint32_t d;\n          for (i = Lmin; i < Lmax; i++)\n            {\n            int len = 1;\n            if (Feptr >= mb->end_subject)\n              {\n              SCHECK_PARTIAL();\n              break;\n              }\n            GETCHARLEN(d, Feptr, len);\n            if (Lc == d || Loc == d) break;\n            Feptr += len;\n            }\n\n          /* After \\C in UTF mode, Lstart_eptr might be in the middle of a\n          Unicode character. Use <= Lstart_eptr to ensure backtracking doesn't\n          go too far. */\n\n          if (reptype != REPTYPE_POS) for(;;)\n            {\n            if (Feptr <= Lstart_eptr) break;\n            RMATCH(Fecode, RM205);\n            if (rrc != MATCH_NOMATCH) RRETURN(rrc);\n            Feptr--;\n            BACKCHAR(Feptr);\n            }\n          }\n        else\n#endif  /* SUPPORT_UNICODE */\n\n        /* Not UTF mode */\n          {\n          for (i = Lmin; i < Lmax; i++)\n            {\n            if (Feptr >= mb->end_subject)\n              {\n              SCHECK_PARTIAL();\n              break;\n              }\n            if (Lc == *Feptr || Loc == *Feptr) break;\n            Feptr++;\n            }\n          if (reptype != REPTYPE_POS) for (;;)\n            {\n            if (Feptr == Lstart_eptr) break;\n            RMATCH(Fecode, RM30);\n            if (rrc != MATCH_NOMATCH) RRETURN(rrc);\n            Feptr--;\n            }\n          }\n        }\n      }\n\n    /* Caseful comparisons */\n\n    else\n      {\n#ifdef SUPPORT_UNICODE\n      if (utf)\n        {\n        uint32_t d;\n        for (i = 1; i <= Lmin; i++)\n          {\n          if (Feptr >= mb->end_subject)\n            {\n            SCHECK_PARTIAL();\n            RRETURN(MATCH_NOMATCH);\n            }\n          GETCHARINC(d, Feptr);\n          if (Lc == d) RRETURN(MATCH_NOMATCH);\n          }\n        }\n      else\n#endif\n      /* Not UTF mode */\n        {\n        for (i = 1; i <= Lmin; i++)\n          {\n          if (Feptr >= mb->end_subject)\n            {\n            SCHECK_PARTIAL();\n            RRETURN(MATCH_NOMATCH);\n            }\n          if (Lc == *Feptr++) RRETURN(MATCH_NOMATCH);\n          }\n        }\n\n      if (Lmin == Lmax) continue;\n\n      if (reptype == REPTYPE_MIN)\n        {\n#ifdef SUPPORT_UNICODE\n        if (utf)\n          {\n          uint32_t d;\n          for (;;)\n            {\n            RMATCH(Fecode, RM206);\n            if (rrc != MATCH_NOMATCH) RRETURN(rrc);\n            if (Lmin++ >= Lmax) RRETURN(MATCH_NOMATCH);\n            if (Feptr >= mb->end_subject)\n              {\n              SCHECK_PARTIAL();\n              RRETURN(MATCH_NOMATCH);\n              }\n            GETCHARINC(d, Feptr);\n            if (Lc == d) RRETURN(MATCH_NOMATCH);\n            }\n          }\n        else\n#endif\n        /* Not UTF mode */\n          {\n          for (;;)\n            {\n            RMATCH(Fecode, RM31);\n            if (rrc != MATCH_NOMATCH) RRETURN(rrc);\n            if (Lmin++ >= Lmax) RRETURN(MATCH_NOMATCH);\n            if (Feptr >= mb->end_subject)\n              {\n              SCHECK_PARTIAL();\n              RRETURN(MATCH_NOMATCH);\n              }\n            if (Lc == *Feptr++) RRETURN(MATCH_NOMATCH);\n            }\n          }\n        /* Control never gets here */\n        }\n\n      /* Maximize case */\n\n      else\n        {\n        Lstart_eptr = Feptr;\n\n#ifdef SUPPORT_UNICODE\n        if (utf)\n          {\n          uint32_t d;\n          for (i = Lmin; i < Lmax; i++)\n            {\n            int len = 1;\n            if (Feptr >= mb->end_subject)\n              {\n              SCHECK_PARTIAL();\n              break;\n              }\n            GETCHARLEN(d, Feptr, len);\n            if (Lc == d) break;\n            Feptr += len;\n            }\n\n          /* After \\C in UTF mode, Lstart_eptr might be in the middle of a\n          Unicode character. Use <= Lstart_eptr to ensure backtracking doesn't\n          go too far. */\n\n          if (reptype != REPTYPE_POS) for(;;)\n            {\n            if (Feptr <= Lstart_eptr) break;\n            RMATCH(Fecode, RM207);\n            if (rrc != MATCH_NOMATCH) RRETURN(rrc);\n            Feptr--;\n            BACKCHAR(Feptr);\n            }\n          }\n        else\n#endif\n        /* Not UTF mode */\n          {\n          for (i = Lmin; i < Lmax; i++)\n            {\n            if (Feptr >= mb->end_subject)\n              {\n              SCHECK_PARTIAL();\n              break;\n              }\n            if (Lc == *Feptr) break;\n            Feptr++;\n            }\n          if (reptype != REPTYPE_POS) for (;;)\n            {\n            if (Feptr == Lstart_eptr) break;\n            RMATCH(Fecode, RM32);\n            if (rrc != MATCH_NOMATCH) RRETURN(rrc);\n            Feptr--;\n            }\n          }\n        }\n      }\n    break;\n\n#undef Lstart_eptr\n#undef Lmin\n#undef Lmax\n#undef Lc\n#undef Loc\n\n\n    /* ===================================================================== */\n    /* Match a bit-mapped character class, possibly repeatedly. These opcodes\n    are used when all the characters in the class have values in the range\n    0-255, and either the matching is caseful, or the characters are in the\n    range 0-127 when UTF processing is enabled. The only difference between\n    OP_CLASS and OP_NCLASS occurs when a data character outside the range is\n    encountered. */\n\n#define Lmin               F->temp_32\u00dd0\u00a8\n#define Lmax               F->temp_32\u00dd1\u00a8\n#define Lstart_eptr        F->temp_sptr\u00dd0\u00a8\n#define Lbyte_map_address  F->temp_sptr\u00dd1\u00a8\n#define Lbyte_map          ((unsigned char *)Lbyte_map_address)\n\n    case OP_NCLASS:\n    case OP_CLASS:\n      {\n      Lbyte_map_address = Fecode + 1;           /* Save for matching */\n      Fecode += 1 + (32 / sizeof(PCRE2_UCHAR)); /* Advance past the item */\n\n      /* Look past the end of the item to see if there is repeat information\n      following. Then obey similar code to character type repeats. */\n\n      switch (*Fecode)\n        {\n        case OP_CRSTAR:\n        case OP_CRMINSTAR:\n        case OP_CRPLUS:\n        case OP_CRMINPLUS:\n        case OP_CRQUERY:\n        case OP_CRMINQUERY:\n        case OP_CRPOSSTAR:\n        case OP_CRPOSPLUS:\n        case OP_CRPOSQUERY:\n        fc = *Fecode++ - OP_CRSTAR;\n        Lmin = rep_min\u00ddfc\u00a8;\n        Lmax = rep_max\u00ddfc\u00a8;\n        reptype = rep_typ\u00ddfc\u00a8;\n        break;\n\n        case OP_CRRANGE:\n        case OP_CRMINRANGE:\n        case OP_CRPOSRANGE:\n        Lmin = GET2(Fecode, 1);\n        Lmax = GET2(Fecode, 1 + IMM2_SIZE);\n        if (Lmax == 0) Lmax = UINT32_MAX;       /* Max 0 => infinity */\n        reptype = rep_typ\u00dd*Fecode - OP_CRSTAR\u00a8;\n        Fecode += 1 + 2 * IMM2_SIZE;\n        break;\n\n        default:               /* No repeat follows */\n        Lmin = Lmax = 1;\n        break;\n        }\n\n      /* First, ensure the minimum number of matches are present. */\n\n#ifdef SUPPORT_UNICODE\n      if (utf)\n        {\n        for (i = 1; i <= Lmin; i++)\n          {\n          if (Feptr >= mb->end_subject)\n            {\n            SCHECK_PARTIAL();\n            RRETURN(MATCH_NOMATCH);\n            }\n          GETCHARINC(fc, Feptr);\n          if (fc > 255)\n            {\n            if (Fop == OP_CLASS) RRETURN(MATCH_NOMATCH);\n            }\n          else\n            if ((Lbyte_map\u00ddfc/8\u00a8 & (1u << (fc&7))) == 0) RRETURN(MATCH_NOMATCH);\n          }\n        }\n      else\n#endif\n      /* Not UTF mode */\n        {\n        for (i = 1; i <= Lmin; i++)\n          {\n          if (Feptr >= mb->end_subject)\n            {\n            SCHECK_PARTIAL();\n            RRETURN(MATCH_NOMATCH);\n            }\n          fc = *Feptr++;\n#if PCRE2_CODE_UNIT_WIDTH != 8\n          if (fc > 255)\n            {\n            if (Fop == OP_CLASS) RRETURN(MATCH_NOMATCH);\n            }\n          else\n#endif\n          if ((Lbyte_map\u00ddfc/8\u00a8 & (1u << (fc&7))) == 0) RRETURN(MATCH_NOMATCH);\n          }\n        }\n\n      /* If Lmax == Lmin we are done. Continue with main loop. */\n\n      if (Lmin == Lmax) continue;\n\n      /* If minimizing, keep testing the rest of the expression and advancing\n      the pointer while it matches the class. */\n\n      if (reptype == REPTYPE_MIN)\n        {\n#ifdef SUPPORT_UNICODE\n        if (utf)\n          {\n          for (;;)\n            {\n            RMATCH(Fecode, RM200);\n            if (rrc != MATCH_NOMATCH) RRETURN(rrc);\n            if (Lmin++ >= Lmax) RRETURN(MATCH_NOMATCH);\n            if (Feptr >= mb->end_subject)\n              {\n              SCHECK_PARTIAL();\n              RRETURN(MATCH_NOMATCH);\n              }\n            GETCHARINC(fc, Feptr);\n            if (fc > 255)\n              {\n              if (Fop == OP_CLASS) RRETURN(MATCH_NOMATCH);\n              }\n            else\n              if ((Lbyte_map\u00ddfc/8\u00a8 & (1u << (fc&7))) == 0) RRETURN(MATCH_NOMATCH);\n            }\n          }\n        else\n#endif\n        /* Not UTF mode */\n          {\n          for (;;)\n            {\n            RMATCH(Fecode, RM23);\n            if (rrc != MATCH_NOMATCH) RRETURN(rrc);\n            if (Lmin++ >= Lmax) RRETURN(MATCH_NOMATCH);\n            if (Feptr >= mb->end_subject)\n              {\n              SCHECK_PARTIAL();\n              RRETURN(MATCH_NOMATCH);\n              }\n            fc = *Feptr++;\n#if PCRE2_CODE_UNIT_WIDTH != 8\n            if (fc > 255)\n              {\n              if (Fop == OP_CLASS) RRETURN(MATCH_NOMATCH);\n              }\n            else\n#endif\n            if ((Lbyte_map\u00ddfc/8\u00a8 & (1u << (fc&7))) == 0) RRETURN(MATCH_NOMATCH);\n            }\n          }\n        /* Control never gets here */\n        }\n\n      /* If maximizing, find the longest possible run, then work backwards. */\n\n      else\n        {\n        Lstart_eptr = Feptr;\n\n#ifdef SUPPORT_UNICODE\n        if (utf)\n          {\n          for (i = Lmin; i < Lmax; i++)\n            {\n            int len = 1;\n            if (Feptr >= mb->end_subject)\n              {\n              SCHECK_PARTIAL();\n              break;\n              }\n            GETCHARLEN(fc, Feptr, len);\n            if (fc > 255)\n              {\n              if (Fop == OP_CLASS) break;\n              }\n            else\n              if ((Lbyte_map\u00ddfc/8\u00a8 & (1u << (fc&7))) == 0) break;\n            Feptr += len;\n            }\n\n          if (reptype == REPTYPE_POS) continue;    /* No backtracking */\n\n          /* After \\C in UTF mode, Lstart_eptr might be in the middle of a\n          Unicode character. Use <= Lstart_eptr to ensure backtracking doesn't\n          go too far. */\n\n          for (;;)\n            {\n            RMATCH(Fecode, RM201);\n            if (rrc != MATCH_NOMATCH) RRETURN(rrc);\n            if (Feptr-- <= Lstart_eptr) break;  /* Tried at original position */\n            BACKCHAR(Feptr);\n            }\n          }\n        else\n#endif\n          /* Not UTF mode */\n          {\n          for (i = Lmin; i < Lmax; i++)\n            {\n            if (Feptr >= mb->end_subject)\n              {\n              SCHECK_PARTIAL();\n              break;\n              }\n            fc = *Feptr;\n#if PCRE2_CODE_UNIT_WIDTH != 8\n            if (fc > 255)\n              {\n              if (Fop == OP_CLASS) break;\n              }\n            else\n#endif\n            if ((Lbyte_map\u00ddfc/8\u00a8 & (1u << (fc&7))) == 0) break;\n            Feptr++;\n            }\n\n          if (reptype == REPTYPE_POS) continue;    /* No backtracking */\n\n          while (Feptr >= Lstart_eptr)\n            {\n            RMATCH(Fecode, RM24);\n            if (rrc != MATCH_NOMATCH) RRETURN(rrc);\n            Feptr--;\n            }\n          }\n\n        RRETURN(MATCH_NOMATCH);\n        }\n      }\n    /* Control never gets here */\n\n#undef Lbyte_map_address\n#undef Lbyte_map\n#undef Lstart_eptr\n#undef Lmin\n#undef Lmax\n\n\n    /* ===================================================================== */\n    /* Match an extended character class. In the 8-bit library, this opcode is\n    encountered only when UTF-8 mode mode is supported. In the 16-bit and\n    32-bit libraries, codepoints greater than 255 may be encountered even when\n    UTF is not supported. */\n\n#define Lstart_eptr  F->temp_sptr\u00dd0\u00a8\n#define Lxclass_data F->temp_sptr\u00dd1\u00a8\n#define Lmin         F->temp_32\u00dd0\u00a8\n#define Lmax         F->temp_32\u00dd1\u00a8\n\n#ifdef SUPPORT_WIDE_CHARS\n    case OP_XCLASS:\n      {\n      Lxclass_data = Fecode + 1 + LINK_SIZE;  /* Save for matching */\n      Fecode += GET(Fecode, 1);               /* Advance past the item */\n\n      switch (*Fecode)\n        {\n        case OP_CRSTAR:\n        case OP_CRMINSTAR:\n        case OP_CRPLUS:\n        case OP_CRMINPLUS:\n        case OP_CRQUERY:\n        case OP_CRMINQUERY:\n        case OP_CRPOSSTAR:\n        case OP_CRPOSPLUS:\n        case OP_CRPOSQUERY:\n        fc = *Fecode++ - OP_CRSTAR;\n        Lmin = rep_min\u00ddfc\u00a8;\n        Lmax = rep_max\u00ddfc\u00a8;\n        reptype = rep_typ\u00ddfc\u00a8;\n        break;\n\n        case OP_CRRANGE:\n        case OP_CRMINRANGE:\n        case OP_CRPOSRANGE:\n        Lmin = GET2(Fecode, 1);\n        Lmax = GET2(Fecode, 1 + IMM2_SIZE);\n        if (Lmax == 0) Lmax = UINT32_MAX;  /* Max 0 => infinity */\n        reptype = rep_typ\u00dd*Fecode - OP_CRSTAR\u00a8;\n        Fecode += 1 + 2 * IMM2_SIZE;\n        break;\n\n        default:               /* No repeat follows */\n        Lmin = Lmax = 1;\n        break;\n        }\n\n      /* First, ensure the minimum number of matches are present. */\n\n      for (i = 1; i <= Lmin; i++)\n        {\n        if (Feptr >= mb->end_subject)\n          {\n          SCHECK_PARTIAL();\n          RRETURN(MATCH_NOMATCH);\n          }\n        GETCHARINCTEST(fc, Feptr);\n        if (!PRIV(xclass)(fc, Lxclass_data, utf)) RRETURN(MATCH_NOMATCH);\n        }\n\n      /* If Lmax == Lmin we can just continue with the main loop. */\n\n      if (Lmin == Lmax) continue;\n\n      /* If minimizing, keep testing the rest of the expression and advancing\n      the pointer while it matches the class. */\n\n      if (reptype == REPTYPE_MIN)\n        {\n        for (;;)\n          {\n          RMATCH(Fecode, RM100);\n          if (rrc != MATCH_NOMATCH) RRETURN(rrc);\n          if (Lmin++ >= Lmax) RRETURN(MATCH_NOMATCH);\n          if (Feptr >= mb->end_subject)\n            {\n            SCHECK_PARTIAL();\n            RRETURN(MATCH_NOMATCH);\n            }\n          GETCHARINCTEST(fc, Feptr);\n          if (!PRIV(xclass)(fc, Lxclass_data, utf)) RRETURN(MATCH_NOMATCH);\n          }\n        /* Control never gets here */\n        }\n\n      /* If maximizing, find the longest possible run, then work backwards. */\n\n      else\n        {\n        Lstart_eptr = Feptr;\n        for (i = Lmin; i < Lmax; i++)\n          {\n          int len = 1;\n          if (Feptr >= mb->end_subject)\n            {\n            SCHECK_PARTIAL();\n            break;\n            }\n#ifdef SUPPORT_UNICODE\n          GETCHARLENTEST(fc, Feptr, len);\n#else\n          fc = *Feptr;\n#endif\n          if (!PRIV(xclass)(fc, Lxclass_data, utf)) break;\n          Feptr += len;\n          }\n\n        if (reptype == REPTYPE_POS) continue;    /* No backtracking */\n\n        /* After \\C in UTF mode, Lstart_eptr might be in the middle of a\n        Unicode character. Use <= Lstart_eptr to ensure backtracking doesn't\n        go too far. */\n\n        for(;;)\n          {\n          RMATCH(Fecode, RM101);\n          if (rrc != MATCH_NOMATCH) RRETURN(rrc);\n          if (Feptr-- <= Lstart_eptr) break;  /* Tried at original position */\n#ifdef SUPPORT_UNICODE\n          if (utf) BACKCHAR(Feptr);\n#endif\n          }\n        RRETURN(MATCH_NOMATCH);\n        }\n\n      /* Control never gets here */\n      }\n#endif  /* SUPPORT_WIDE_CHARS: end of XCLASS */\n\n#undef Lstart_eptr\n#undef Lxclass_data\n#undef Lmin\n#undef Lmax\n\n\n    /* ===================================================================== */\n    /* Match various character types when PCRE2_UCP is not set. These opcodes\n    are not generated when PCRE2_UCP is set - instead appropriate property\n    tests are compiled. */\n\n    case OP_NOT_DIGIT:\n    if (Feptr >= mb->end_subject)\n      {\n      SCHECK_PARTIAL();\n      RRETURN(MATCH_NOMATCH);\n      }\n    GETCHARINCTEST(fc, Feptr);\n    if (CHMAX_255(fc) && (mb->ctypes\u00ddfc\u00a8 & ctype_digit) != 0)\n      RRETURN(MATCH_NOMATCH);\n    Fecode++;\n    break;\n\n    case OP_DIGIT:\n    if (Feptr >= mb->end_subject)\n      {\n      SCHECK_PARTIAL();\n      RRETURN(MATCH_NOMATCH);\n      }\n    GETCHARINCTEST(fc, Feptr);\n    if (!CHMAX_255(fc) || (mb->ctypes\u00ddfc\u00a8 & ctype_digit) == 0)\n      RRETURN(MATCH_NOMATCH);\n    Fecode++;\n    break;\n\n    case OP_NOT_WHITESPACE:\n    if (Feptr >= mb->end_subject)\n      {\n      SCHECK_PARTIAL();\n      RRETURN(MATCH_NOMATCH);\n      }\n    GETCHARINCTEST(fc, Feptr);\n    if (CHMAX_255(fc) && (mb->ctypes\u00ddfc\u00a8 & ctype_space) != 0)\n      RRETURN(MATCH_NOMATCH);\n    Fecode++;\n    break;\n\n    case OP_WHITESPACE:\n    if (Feptr >= mb->end_subject)\n      {\n      SCHECK_PARTIAL();\n      RRETURN(MATCH_NOMATCH);\n      }\n    GETCHARINCTEST(fc, Feptr);\n    if (!CHMAX_255(fc) || (mb->ctypes\u00ddfc\u00a8 & ctype_space) == 0)\n      RRETURN(MATCH_NOMATCH);\n    Fecode++;\n    break;\n\n    case OP_NOT_WORDCHAR:\n    if (Feptr >= mb->end_subject)\n      {\n      SCHECK_PARTIAL();\n      RRETURN(MATCH_NOMATCH);\n      }\n    GETCHARINCTEST(fc, Feptr);\n    if (CHMAX_255(fc) && (mb->ctypes\u00ddfc\u00a8 & ctype_word) != 0)\n      RRETURN(MATCH_NOMATCH);\n    Fecode++;\n    break;\n\n    case OP_WORDCHAR:\n    if (Feptr >= mb->end_subject)\n      {\n      SCHECK_PARTIAL();\n      RRETURN(MATCH_NOMATCH);\n      }\n    GETCHARINCTEST(fc, Feptr);\n    if (!CHMAX_255(fc) || (mb->ctypes\u00ddfc\u00a8 & ctype_word) == 0)\n      RRETURN(MATCH_NOMATCH);\n    Fecode++;\n    break;\n\n    case OP_ANYNL:\n    if (Feptr >= mb->end_subject)\n      {\n      SCHECK_PARTIAL();\n      RRETURN(MATCH_NOMATCH);\n      }\n    GETCHARINCTEST(fc, Feptr);\n    switch(fc)\n      {\n      default: RRETURN(MATCH_NOMATCH);\n\n      case CHAR_CR:\n      if (Feptr >= mb->end_subject)\n        {\n        SCHECK_PARTIAL();\n        }\n      else if (UCHAR21TEST(Feptr) == CHAR_LF) Feptr++;\n      break;\n\n      case CHAR_LF:\n      break;\n\n      case CHAR_VT:\n      case CHAR_FF:\n      case CHAR_NEL:\n#ifndef EBCDIC\n      case 0x2028:\n      case 0x2029:\n#endif  /* Not EBCDIC */\n      if (mb->bsr_convention == PCRE2_BSR_ANYCRLF) RRETURN(MATCH_NOMATCH);\n      break;\n      }\n    Fecode++;\n    break;\n\n    case OP_NOT_HSPACE:\n    if (Feptr >= mb->end_subject)\n      {\n      SCHECK_PARTIAL();\n      RRETURN(MATCH_NOMATCH);\n      }\n    GETCHARINCTEST(fc, Feptr);\n    switch(fc)\n      {\n      HSPACE_CASES: RRETURN(MATCH_NOMATCH);  /* Byte and multibyte cases */\n      default: break;\n      }\n    Fecode++;\n    break;\n\n    case OP_HSPACE:\n    if (Feptr >= mb->end_subject)\n      {\n      SCHECK_PARTIAL();\n      RRETURN(MATCH_NOMATCH);\n      }\n    GETCHARINCTEST(fc, Feptr);\n    switch(fc)\n      {\n      HSPACE_CASES: break;  /* Byte and multibyte cases */\n      default: RRETURN(MATCH_NOMATCH);\n      }\n    Fecode++;\n    break;\n\n    case OP_NOT_VSPACE:\n    if (Feptr >= mb->end_subject)\n      {\n      SCHECK_PARTIAL();\n      RRETURN(MATCH_NOMATCH);\n      }\n    GETCHARINCTEST(fc, Feptr);\n    switch(fc)\n      {\n      VSPACE_CASES: RRETURN(MATCH_NOMATCH);\n      default: break;\n      }\n    Fecode++;\n    break;\n\n    case OP_VSPACE:\n    if (Feptr >= mb->end_subject)\n      {\n      SCHECK_PARTIAL();\n      RRETURN(MATCH_NOMATCH);\n      }\n    GETCHARINCTEST(fc, Feptr);\n    switch(fc)\n      {\n      VSPACE_CASES: break;\n      default: RRETURN(MATCH_NOMATCH);\n      }\n    Fecode++;\n    break;\n\n\n#ifdef SUPPORT_UNICODE\n\n    /* ===================================================================== */\n    /* Check the next character by Unicode property. We will get here only\n    if the support is in the binary; otherwise a compile-time error occurs. */\n\n    case OP_PROP:\n    case OP_NOTPROP:\n    if (Feptr >= mb->end_subject)\n      {\n      SCHECK_PARTIAL();\n      RRETURN(MATCH_NOMATCH);\n      }\n    GETCHARINCTEST(fc, Feptr);\n      {\n      const uint32_t *cp;\n      const ucd_record *prop = GET_UCD(fc);\n\n      switch(Fecode\u00dd1\u00a8)\n        {\n        case PT_ANY:\n        if (Fop == OP_NOTPROP) RRETURN(MATCH_NOMATCH);\n        break;\n\n        case PT_LAMP:\n        if ((prop->chartype == ucp_Lu ||\n             prop->chartype == ucp_Ll ||\n             prop->chartype == ucp_Lt) == (Fop == OP_NOTPROP))\n          RRETURN(MATCH_NOMATCH);\n        break;\n\n        case PT_GC:\n        if ((Fecode\u00dd2\u00a8 != PRIV(ucp_gentype)\u00ddprop->chartype\u00a8) == (Fop == OP_PROP))\n          RRETURN(MATCH_NOMATCH);\n        break;\n\n        case PT_PC:\n        if ((Fecode\u00dd2\u00a8 != prop->chartype) == (Fop == OP_PROP))\n          RRETURN(MATCH_NOMATCH);\n        break;\n\n        case PT_SC:\n        if ((Fecode\u00dd2\u00a8 != prop->script) == (Fop == OP_PROP))\n          RRETURN(MATCH_NOMATCH);\n        break;\n\n        /* These are specials */\n\n        case PT_ALNUM:\n        if ((PRIV(ucp_gentype)\u00ddprop->chartype\u00a8 == ucp_L ||\n             PRIV(ucp_gentype)\u00ddprop->chartype\u00a8 == ucp_N) == (Fop == OP_NOTPROP))\n          RRETURN(MATCH_NOMATCH);\n        break;\n\n        /* Perl space used to exclude VT, but from Perl 5.18 it is included,\n        which means that Perl space and POSIX space are now identical. PCRE\n        was changed at release 8.34. */\n\n        case PT_SPACE:    /* Perl space */\n        case PT_PXSPACE:  /* POSIX space */\n        switch(fc)\n          {\n          HSPACE_CASES:\n          VSPACE_CASES:\n          if (Fop == OP_NOTPROP) RRETURN(MATCH_NOMATCH);\n          break;\n\n          default:\n          if ((PRIV(ucp_gentype)\u00ddprop->chartype\u00a8 == ucp_Z) ==\n            (Fop == OP_NOTPROP)) RRETURN(MATCH_NOMATCH);\n          break;\n          }\n        break;\n\n        case PT_WORD:\n        if ((PRIV(ucp_gentype)\u00ddprop->chartype\u00a8 == ucp_L ||\n             PRIV(ucp_gentype)\u00ddprop->chartype\u00a8 == ucp_N ||\n             fc == CHAR_UNDERSCORE) == (Fop == OP_NOTPROP))\n          RRETURN(MATCH_NOMATCH);\n        break;\n\n        case PT_CLIST:\n        cp = PRIV(ucd_caseless_sets) + Fecode\u00dd2\u00a8;\n        for (;;)\n          {\n          if (fc < *cp)\n            { if (Fop == OP_PROP) { RRETURN(MATCH_NOMATCH); } else break; }\n          if (fc == *cp++)\n            { if (Fop == OP_PROP) break; else { RRETURN(MATCH_NOMATCH); } }\n          }\n        break;\n\n        case PT_UCNC:\n        if ((fc == CHAR_DOLLAR_SIGN || fc == CHAR_COMMERCIAL_AT ||\n             fc == CHAR_GRAVE_ACCENT || (fc >= 0xa0 && fc <= 0xd7ff) ||\n             fc >= 0xe000) == (Fop == OP_NOTPROP))\n          RRETURN(MATCH_NOMATCH);\n        break;\n\n        /* This should never occur */\n\n        default:\n        return PCRE2_ERROR_INTERNAL;\n        }\n\n      Fecode += 3;\n      }\n    break;\n\n\n    /* ===================================================================== */\n    /* Match an extended Unicode sequence. We will get here only if the support\n    is in the binary; otherwise a compile-time error occurs. */\n\n    case OP_EXTUNI:\n    if (Feptr >= mb->end_subject)\n      {\n      SCHECK_PARTIAL();\n      RRETURN(MATCH_NOMATCH);\n      }\n    else\n      {\n      GETCHARINCTEST(fc, Feptr);\n      Feptr = PRIV(extuni)(fc, Feptr, mb->start_subject, mb->end_subject, utf,\n        NULL);\n      }\n    CHECK_PARTIAL();\n    Fecode++;\n    break;\n\n#endif  /* SUPPORT_UNICODE */\n\n\n    /* ===================================================================== */\n    /* Match a single character type repeatedly. Note that the property type\n    does not need to be in a stack frame as it is not used within an RMATCH()\n    loop. */\n\n#define Lstart_eptr  F->temp_sptr\u00dd0\u00a8\n#define Lmin         F->temp_32\u00dd0\u00a8\n#define Lmax         F->temp_32\u00dd1\u00a8\n#define Lctype       F->temp_32\u00dd2\u00a8\n#define Lpropvalue   F->temp_32\u00dd3\u00a8\n\n    case OP_TYPEEXACT:\n    Lmin = Lmax = GET2(Fecode, 1);\n    Fecode += 1 + IMM2_SIZE;\n    goto REPEATTYPE;\n\n    case OP_TYPEUPTO:\n    case OP_TYPEMINUPTO:\n    Lmin = 0;\n    Lmax = GET2(Fecode, 1);\n    reptype = (*Fecode == OP_TYPEMINUPTO)? REPTYPE_MIN : REPTYPE_MAX;\n    Fecode += 1 + IMM2_SIZE;\n    goto REPEATTYPE;\n\n    case OP_TYPEPOSSTAR:\n    reptype = REPTYPE_POS;\n    Lmin = 0;\n    Lmax = UINT32_MAX;\n    Fecode++;\n    goto REPEATTYPE;\n\n    case OP_TYPEPOSPLUS:\n    reptype = REPTYPE_POS;\n    Lmin = 1;\n    Lmax = UINT32_MAX;\n    Fecode++;\n    goto REPEATTYPE;\n\n    case OP_TYPEPOSQUERY:\n    reptype = REPTYPE_POS;\n    Lmin = 0;\n    Lmax = 1;\n    Fecode++;\n    goto REPEATTYPE;\n\n    case OP_TYPEPOSUPTO:\n    reptype = REPTYPE_POS;\n    Lmin = 0;\n    Lmax = GET2(Fecode, 1);\n    Fecode += 1 + IMM2_SIZE;\n    goto REPEATTYPE;\n\n    case OP_TYPESTAR:\n    case OP_TYPEMINSTAR:\n    case OP_TYPEPLUS:\n    case OP_TYPEMINPLUS:\n    case OP_TYPEQUERY:\n    case OP_TYPEMINQUERY:\n    fc = *Fecode++ - OP_TYPESTAR;\n    Lmin = rep_min\u00ddfc\u00a8;\n    Lmax = rep_max\u00ddfc\u00a8;\n    reptype = rep_typ\u00ddfc\u00a8;\n\n    /* Common code for all repeated character type matches. */\n\n    REPEATTYPE:\n    Lctype = *Fecode++;      /* Code for the character type */\n\n#ifdef SUPPORT_UNICODE\n    if (Lctype == OP_PROP || Lctype == OP_NOTPROP)\n      {\n      proptype = *Fecode++;\n      Lpropvalue = *Fecode++;\n      }\n    else proptype = -1;\n#endif\n\n    /* First, ensure the minimum number of matches are present. Use inline\n    code for maximizing the speed, and do the type test once at the start\n    (i.e. keep it out of the loop). The code for UTF mode is separated out for\n    tidiness, except for Unicode property tests. */\n\n    if (Lmin > 0)\n      {\n#ifdef SUPPORT_UNICODE\n      if (proptype >= 0)  /* Property tests in all modes */\n        {\n        switch(proptype)\n          {\n          case PT_ANY:\n          if (Lctype == OP_NOTPROP) RRETURN(MATCH_NOMATCH);\n          for (i = 1; i <= Lmin; i++)\n            {\n            if (Feptr >= mb->end_subject)\n              {\n              SCHECK_PARTIAL();\n              RRETURN(MATCH_NOMATCH);\n              }\n            GETCHARINCTEST(fc, Feptr);\n            }\n          break;\n\n          case PT_LAMP:\n          for (i = 1; i <= Lmin; i++)\n            {\n            int chartype;\n            if (Feptr >= mb->end_subject)\n              {\n              SCHECK_PARTIAL();\n              RRETURN(MATCH_NOMATCH);\n              }\n            GETCHARINCTEST(fc, Feptr);\n            chartype = UCD_CHARTYPE(fc);\n            if ((chartype == ucp_Lu ||\n                 chartype == ucp_Ll ||\n                 chartype == ucp_Lt) == (Lctype == OP_NOTPROP))\n              RRETURN(MATCH_NOMATCH);\n            }\n          break;\n\n          case PT_GC:\n          for (i = 1; i <= Lmin; i++)\n            {\n            if (Feptr >= mb->end_subject)\n              {\n              SCHECK_PARTIAL();\n              RRETURN(MATCH_NOMATCH);\n              }\n            GETCHARINCTEST(fc, Feptr);\n            if ((UCD_CATEGORY(fc) == Lpropvalue) == (Lctype == OP_NOTPROP))\n              RRETURN(MATCH_NOMATCH);\n            }\n          break;\n\n          case PT_PC:\n          for (i = 1; i <= Lmin; i++)\n            {\n            if (Feptr >= mb->end_subject)\n              {\n              SCHECK_PARTIAL();\n              RRETURN(MATCH_NOMATCH);\n              }\n            GETCHARINCTEST(fc, Feptr);\n            if ((UCD_CHARTYPE(fc) == Lpropvalue) == (Lctype == OP_NOTPROP))\n              RRETURN(MATCH_NOMATCH);\n            }\n          break;\n\n          case PT_SC:\n          for (i = 1; i <= Lmin; i++)\n            {\n            if (Feptr >= mb->end_subject)\n              {\n              SCHECK_PARTIAL();\n              RRETURN(MATCH_NOMATCH);\n              }\n            GETCHARINCTEST(fc, Feptr);\n            if ((UCD_SCRIPT(fc) == Lpropvalue) == (Lctype == OP_NOTPROP))\n              RRETURN(MATCH_NOMATCH);\n            }\n          break;\n\n          case PT_ALNUM:\n          for (i = 1; i <= Lmin; i++)\n            {\n            int category;\n            if (Feptr >= mb->end_subject)\n              {\n              SCHECK_PARTIAL();\n              RRETURN(MATCH_NOMATCH);\n              }\n            GETCHARINCTEST(fc, Feptr);\n            category = UCD_CATEGORY(fc);\n            if ((category == ucp_L || category == ucp_N) == (Lctype == OP_NOTPROP))\n              RRETURN(MATCH_NOMATCH);\n            }\n          break;\n\n          /* Perl space used to exclude VT, but from Perl 5.18 it is included,\n          which means that Perl space and POSIX space are now identical. PCRE\n          was changed at release 8.34. */\n\n          case PT_SPACE:    /* Perl space */\n          case PT_PXSPACE:  /* POSIX space */\n          for (i = 1; i <= Lmin; i++)\n            {\n            if (Feptr >= mb->end_subject)\n              {\n              SCHECK_PARTIAL();\n              RRETURN(MATCH_NOMATCH);\n              }\n            GETCHARINCTEST(fc, Feptr);\n            switch(fc)\n              {\n              HSPACE_CASES:\n              VSPACE_CASES:\n              if (Lctype == OP_NOTPROP) RRETURN(MATCH_NOMATCH);\n              break;\n\n              default:\n              if ((UCD_CATEGORY(fc) == ucp_Z) == (Lctype == OP_NOTPROP))\n                RRETURN(MATCH_NOMATCH);\n              break;\n              }\n            }\n          break;\n\n          case PT_WORD:\n          for (i = 1; i <= Lmin; i++)\n            {\n            int category;\n            if (Feptr >= mb->end_subject)\n              {\n              SCHECK_PARTIAL();\n              RRETURN(MATCH_NOMATCH);\n              }\n            GETCHARINCTEST(fc, Feptr);\n            category = UCD_CATEGORY(fc);\n            if ((category == ucp_L || category == ucp_N ||\n                fc == CHAR_UNDERSCORE) == (Lctype == OP_NOTPROP))\n              RRETURN(MATCH_NOMATCH);\n            }\n          break;\n\n          case PT_CLIST:\n          for (i = 1; i <= Lmin; i++)\n            {\n            const uint32_t *cp;\n            if (Feptr >= mb->end_subject)\n              {\n              SCHECK_PARTIAL();\n              RRETURN(MATCH_NOMATCH);\n              }\n            GETCHARINCTEST(fc, Feptr);\n            cp = PRIV(ucd_caseless_sets) + Lpropvalue;\n            for (;;)\n              {\n              if (fc < *cp)\n                {\n                if (Lctype == OP_NOTPROP) break;\n                RRETURN(MATCH_NOMATCH);\n                }\n              if (fc == *cp++)\n                {\n                if (Lctype == OP_NOTPROP) RRETURN(MATCH_NOMATCH);\n                break;\n                }\n              }\n            }\n          break;\n\n          case PT_UCNC:\n          for (i = 1; i <= Lmin; i++)\n            {\n            if (Feptr >= mb->end_subject)\n              {\n              SCHECK_PARTIAL();\n              RRETURN(MATCH_NOMATCH);\n              }\n            GETCHARINCTEST(fc, Feptr);\n            if ((fc == CHAR_DOLLAR_SIGN || fc == CHAR_COMMERCIAL_AT ||\n                 fc == CHAR_GRAVE_ACCENT || (fc >= 0xa0 && fc <= 0xd7ff) ||\n                 fc >= 0xe000) == (Lctype == OP_NOTPROP))\n              RRETURN(MATCH_NOMATCH);\n            }\n          break;\n\n          /* This should not occur */\n\n          default:\n          return PCRE2_ERROR_INTERNAL;\n          }\n        }\n\n      /* Match extended Unicode sequences. We will get here only if the\n      support is in the binary; otherwise a compile-time error occurs. */\n\n      else if (Lctype == OP_EXTUNI)\n        {\n        for (i = 1; i <= Lmin; i++)\n          {\n          if (Feptr >= mb->end_subject)\n            {\n            SCHECK_PARTIAL();\n            RRETURN(MATCH_NOMATCH);\n            }\n          else\n            {\n            GETCHARINCTEST(fc, Feptr);\n            Feptr = PRIV(extuni)(fc, Feptr, mb->start_subject,\n              mb->end_subject, utf, NULL);\n            }\n          CHECK_PARTIAL();\n          }\n        }\n      else\n#endif     /* SUPPORT_UNICODE */\n\n/* Handle all other cases in UTF mode */\n\n#ifdef SUPPORT_UNICODE\n      if (utf) switch(Lctype)\n        {\n        case OP_ANY:\n        for (i = 1; i <= Lmin; i++)\n          {\n          if (Feptr >= mb->end_subject)\n            {\n            SCHECK_PARTIAL();\n            RRETURN(MATCH_NOMATCH);\n            }\n          if (IS_NEWLINE(Feptr)) RRETURN(MATCH_NOMATCH);\n          if (mb->partial != 0 &&\n              Feptr + 1 >= mb->end_subject &&\n              NLBLOCK->nltype == NLTYPE_FIXED &&\n              NLBLOCK->nllen == 2 &&\n              UCHAR21(Feptr) == NLBLOCK->nl\u00dd0\u00a8)\n            {\n            mb->hitend = TRUE;\n            if (mb->partial > 1) return PCRE2_ERROR_PARTIAL;\n            }\n          Feptr++;\n          ACROSSCHAR(Feptr < mb->end_subject, Feptr, Feptr++);\n          }\n        break;\n\n        case OP_ALLANY:\n        for (i = 1; i <= Lmin; i++)\n          {\n          if (Feptr >= mb->end_subject)\n            {\n            SCHECK_PARTIAL();\n            RRETURN(MATCH_NOMATCH);\n            }\n          Feptr++;\n          ACROSSCHAR(Feptr < mb->end_subject, Feptr, Feptr++);\n          }\n        break;\n\n        case OP_ANYBYTE:\n        if (Feptr > mb->end_subject - Lmin) RRETURN(MATCH_NOMATCH);\n        Feptr += Lmin;\n        break;\n\n        case OP_ANYNL:\n        for (i = 1; i <= Lmin; i++)\n          {\n          if (Feptr >= mb->end_subject)\n            {\n            SCHECK_PARTIAL();\n            RRETURN(MATCH_NOMATCH);\n            }\n          GETCHARINC(fc, Feptr);\n          switch(fc)\n            {\n            default: RRETURN(MATCH_NOMATCH);\n\n            case CHAR_CR:\n            if (Feptr < mb->end_subject && UCHAR21(Feptr) == CHAR_LF) Feptr++;\n            break;\n\n            case CHAR_LF:\n            break;\n\n            case CHAR_VT:\n            case CHAR_FF:\n            case CHAR_NEL:\n#ifndef EBCDIC\n            case 0x2028:\n            case 0x2029:\n#endif  /* Not EBCDIC */\n            if (mb->bsr_convention == PCRE2_BSR_ANYCRLF) RRETURN(MATCH_NOMATCH);\n            break;\n            }\n          }\n        break;\n\n        case OP_NOT_HSPACE:\n        for (i = 1; i <= Lmin; i++)\n          {\n          if (Feptr >= mb->end_subject)\n            {\n            SCHECK_PARTIAL();\n            RRETURN(MATCH_NOMATCH);\n            }\n          GETCHARINC(fc, Feptr);\n          switch(fc)\n            {\n            HSPACE_CASES: RRETURN(MATCH_NOMATCH);\n            default: break;\n            }\n          }\n        break;\n\n        case OP_HSPACE:\n        for (i = 1; i <= Lmin; i++)\n          {\n          if (Feptr >= mb->end_subject)\n            {\n            SCHECK_PARTIAL();\n            RRETURN(MATCH_NOMATCH);\n            }\n          GETCHARINC(fc, Feptr);\n          switch(fc)\n            {\n            HSPACE_CASES: break;\n            default: RRETURN(MATCH_NOMATCH);\n            }\n          }\n        break;\n\n        case OP_NOT_VSPACE:\n        for (i = 1; i <= Lmin; i++)\n          {\n          if (Feptr >= mb->end_subject)\n            {\n            SCHECK_PARTIAL();\n            RRETURN(MATCH_NOMATCH);\n            }\n          GETCHARINC(fc, Feptr);\n          switch(fc)\n            {\n            VSPACE_CASES: RRETURN(MATCH_NOMATCH);\n            default: break;\n            }\n          }\n        break;\n\n        case OP_VSPACE:\n        for (i = 1; i <= Lmin; i++)\n          {\n          if (Feptr >= mb->end_subject)\n            {\n            SCHECK_PARTIAL();\n            RRETURN(MATCH_NOMATCH);\n            }\n          GETCHARINC(fc, Feptr);\n          switch(fc)\n            {\n            VSPACE_CASES: break;\n            default: RRETURN(MATCH_NOMATCH);\n            }\n          }\n        break;\n\n        case OP_NOT_DIGIT:\n        for (i = 1; i <= Lmin; i++)\n          {\n          if (Feptr >= mb->end_subject)\n            {\n            SCHECK_PARTIAL();\n            RRETURN(MATCH_NOMATCH);\n            }\n          GETCHARINC(fc, Feptr);\n          if (fc < 128 && (mb->ctypes\u00ddfc\u00a8 & ctype_digit) != 0)\n            RRETURN(MATCH_NOMATCH);\n          }\n        break;\n\n        case OP_DIGIT:\n        for (i = 1; i <= Lmin; i++)\n          {\n          uint32_t cc;\n          if (Feptr >= mb->end_subject)\n            {\n            SCHECK_PARTIAL();\n            RRETURN(MATCH_NOMATCH);\n            }\n          cc = UCHAR21(Feptr);\n          if (cc >= 128 || (mb->ctypes\u00ddcc\u00a8 & ctype_digit) == 0)\n            RRETURN(MATCH_NOMATCH);\n          Feptr++;\n          /* No need to skip more code units - we know it has only one. */\n          }\n        break;\n\n        case OP_NOT_WHITESPACE:\n        for (i = 1; i <= Lmin; i++)\n          {\n          uint32_t cc;\n          if (Feptr >= mb->end_subject)\n            {\n            SCHECK_PARTIAL();\n            RRETURN(MATCH_NOMATCH);\n            }\n          cc = UCHAR21(Feptr);\n          if (cc < 128 && (mb->ctypes\u00ddcc\u00a8 & ctype_space) != 0)\n            RRETURN(MATCH_NOMATCH);\n          Feptr++;\n          ACROSSCHAR(Feptr < mb->end_subject, Feptr, Feptr++);\n          }\n        break;\n\n        case OP_WHITESPACE:\n        for (i = 1; i <= Lmin; i++)\n          {\n          uint32_t cc;\n          if (Feptr >= mb->end_subject)\n            {\n            SCHECK_PARTIAL();\n            RRETURN(MATCH_NOMATCH);\n            }\n          cc = UCHAR21(Feptr);\n          if (cc >= 128 || (mb->ctypes\u00ddcc\u00a8 & ctype_space) == 0)\n            RRETURN(MATCH_NOMATCH);\n          Feptr++;\n          /* No need to skip more code units - we know it has only one. */\n          }\n        break;\n\n        case OP_NOT_WORDCHAR:\n        for (i = 1; i <= Lmin; i++)\n          {\n          uint32_t cc;\n          if (Feptr >= mb->end_subject)\n            {\n            SCHECK_PARTIAL();\n            RRETURN(MATCH_NOMATCH);\n            }\n          cc = UCHAR21(Feptr);\n          if (cc < 128 && (mb->ctypes\u00ddcc\u00a8 & ctype_word) != 0)\n            RRETURN(MATCH_NOMATCH);\n          Feptr++;\n          ACROSSCHAR(Feptr < mb->end_subject, Feptr, Feptr++);\n          }\n        break;\n\n        case OP_WORDCHAR:\n        for (i = 1; i <= Lmin; i++)\n          {\n          uint32_t cc;\n          if (Feptr >= mb->end_subject)\n            {\n            SCHECK_PARTIAL();\n            RRETURN(MATCH_NOMATCH);\n            }\n          cc = UCHAR21(Feptr);\n          if (cc >= 128 || (mb->ctypes\u00ddcc\u00a8 & ctype_word) == 0)\n            RRETURN(MATCH_NOMATCH);\n          Feptr++;\n          /* No need to skip more code units - we know it has only one. */\n          }\n        break;\n\n        default:\n        return PCRE2_ERROR_INTERNAL;\n        }  /* End switch(Lctype) */\n\n      else\n#endif     /* SUPPORT_UNICODE */\n\n      /* Code for the non-UTF case for minimum matching of operators other\n      than OP_PROP and OP_NOTPROP. */\n\n      switch(Lctype)\n        {\n        case OP_ANY:\n        for (i = 1; i <= Lmin; i++)\n          {\n          if (Feptr >= mb->end_subject)\n            {\n            SCHECK_PARTIAL();\n            RRETURN(MATCH_NOMATCH);\n            }\n          if (IS_NEWLINE(Feptr)) RRETURN(MATCH_NOMATCH);\n          if (mb->partial != 0 &&\n              Feptr + 1 >= mb->end_subject &&\n              NLBLOCK->nltype == NLTYPE_FIXED &&\n              NLBLOCK->nllen == 2 &&\n              *Feptr == NLBLOCK->nl\u00dd0\u00a8)\n            {\n            mb->hitend = TRUE;\n            if (mb->partial > 1) return PCRE2_ERROR_PARTIAL;\n            }\n          Feptr++;\n          }\n        break;\n\n        case OP_ALLANY:\n        if (Feptr > mb->end_subject - Lmin)\n          {\n          SCHECK_PARTIAL();\n          RRETURN(MATCH_NOMATCH);\n          }\n        Feptr += Lmin;\n        break;\n\n        /* This OP_ANYBYTE case will never be reached because \\C gets turned\n        into OP_ALLANY in non-UTF mode. Cut out the code so that coverage\n        reports don't complain about it's never being used. */\n\n/*        case OP_ANYBYTE:\n*        if (Feptr > mb->end_subject - Lmin)\n*          {\n*          SCHECK_PARTIAL();\n*          RRETURN(MATCH_NOMATCH);\n*          }\n*        Feptr += Lmin;\n*        break;\n*/\n        case OP_ANYNL:\n        for (i = 1; i <= Lmin; i++)\n          {\n          if (Feptr >= mb->end_subject)\n            {\n            SCHECK_PARTIAL();\n            RRETURN(MATCH_NOMATCH);\n            }\n          switch(*Feptr++)\n            {\n            default: RRETURN(MATCH_NOMATCH);\n\n            case CHAR_CR:\n            if (Feptr < mb->end_subject && *Feptr == CHAR_LF) Feptr++;\n            break;\n\n            case CHAR_LF:\n            break;\n\n            case CHAR_VT:\n            case CHAR_FF:\n            case CHAR_NEL:\n#if PCRE2_CODE_UNIT_WIDTH != 8\n            case 0x2028:\n            case 0x2029:\n#endif\n            if (mb->bsr_convention == PCRE2_BSR_ANYCRLF) RRETURN(MATCH_NOMATCH);\n            break;\n            }\n          }\n        break;\n\n        case OP_NOT_HSPACE:\n        for (i = 1; i <= Lmin; i++)\n          {\n          if (Feptr >= mb->end_subject)\n            {\n            SCHECK_PARTIAL();\n            RRETURN(MATCH_NOMATCH);\n            }\n          switch(*Feptr++)\n            {\n            default: break;\n            HSPACE_BYTE_CASES:\n#if PCRE2_CODE_UNIT_WIDTH != 8\n            HSPACE_MULTIBYTE_CASES:\n#endif\n            RRETURN(MATCH_NOMATCH);\n            }\n          }\n        break;\n\n        case OP_HSPACE:\n        for (i = 1; i <= Lmin; i++)\n          {\n          if (Feptr >= mb->end_subject)\n            {\n            SCHECK_PARTIAL();\n            RRETURN(MATCH_NOMATCH);\n            }\n          switch(*Feptr++)\n            {\n            default: RRETURN(MATCH_NOMATCH);\n            HSPACE_BYTE_CASES:\n#if PCRE2_CODE_UNIT_WIDTH != 8\n            HSPACE_MULTIBYTE_CASES:\n#endif\n            break;\n            }\n          }\n        break;\n\n        case OP_NOT_VSPACE:\n        for (i = 1; i <= Lmin; i++)\n          {\n          if (Feptr >= mb->end_subject)\n            {\n            SCHECK_PARTIAL();\n            RRETURN(MATCH_NOMATCH);\n            }\n          switch(*Feptr++)\n            {\n            VSPACE_BYTE_CASES:\n#if PCRE2_CODE_UNIT_WIDTH != 8\n            VSPACE_MULTIBYTE_CASES:\n#endif\n            RRETURN(MATCH_NOMATCH);\n            default: break;\n            }\n          }\n        break;\n\n        case OP_VSPACE:\n        for (i = 1; i <= Lmin; i++)\n          {\n          if (Feptr >= mb->end_subject)\n            {\n            SCHECK_PARTIAL();\n            RRETURN(MATCH_NOMATCH);\n            }\n          switch(*Feptr++)\n            {\n            default: RRETURN(MATCH_NOMATCH);\n            VSPACE_BYTE_CASES:\n#if PCRE2_CODE_UNIT_WIDTH != 8\n            VSPACE_MULTIBYTE_CASES:\n#endif\n            break;\n            }\n          }\n        break;\n\n        case OP_NOT_DIGIT:\n        for (i = 1; i <= Lmin; i++)\n          {\n          if (Feptr >= mb->end_subject)\n            {\n            SCHECK_PARTIAL();\n            RRETURN(MATCH_NOMATCH);\n            }\n          if (MAX_255(*Feptr) && (mb->ctypes\u00dd*Feptr\u00a8 & ctype_digit) != 0)\n            RRETURN(MATCH_NOMATCH);\n          Feptr++;\n          }\n        break;\n\n        case OP_DIGIT:\n        for (i = 1; i <= Lmin; i++)\n          {\n          if (Feptr >= mb->end_subject)\n            {\n            SCHECK_PARTIAL();\n            RRETURN(MATCH_NOMATCH);\n            }\n          if (!MAX_255(*Feptr) || (mb->ctypes\u00dd*Feptr\u00a8 & ctype_digit) == 0)\n            RRETURN(MATCH_NOMATCH);\n          Feptr++;\n          }\n        break;\n\n        case OP_NOT_WHITESPACE:\n        for (i = 1; i <= Lmin; i++)\n          {\n          if (Feptr >= mb->end_subject)\n            {\n            SCHECK_PARTIAL();\n            RRETURN(MATCH_NOMATCH);\n            }\n          if (MAX_255(*Feptr) && (mb->ctypes\u00dd*Feptr\u00a8 & ctype_space) != 0)\n            RRETURN(MATCH_NOMATCH);\n          Feptr++;\n          }\n        break;\n\n        case OP_WHITESPACE:\n        for (i = 1; i <= Lmin; i++)\n          {\n          if (Feptr >= mb->end_subject)\n            {\n            SCHECK_PARTIAL();\n            RRETURN(MATCH_NOMATCH);\n            }\n          if (!MAX_255(*Feptr) || (mb->ctypes\u00dd*Feptr\u00a8 & ctype_space) == 0)\n            RRETURN(MATCH_NOMATCH);\n          Feptr++;\n          }\n        break;\n\n        case OP_NOT_WORDCHAR:\n        for (i = 1; i <= Lmin; i++)\n          {\n          if (Feptr >= mb->end_subject)\n            {\n            SCHECK_PARTIAL();\n            RRETURN(MATCH_NOMATCH);\n            }\n          if (MAX_255(*Feptr) && (mb->ctypes\u00dd*Feptr\u00a8 & ctype_word) != 0)\n            RRETURN(MATCH_NOMATCH);\n          Feptr++;\n          }\n        break;\n\n        case OP_WORDCHAR:\n        for (i = 1; i <= Lmin; i++)\n          {\n          if (Feptr >= mb->end_subject)\n            {\n            SCHECK_PARTIAL();\n            RRETURN(MATCH_NOMATCH);\n            }\n          if (!MAX_255(*Feptr) || (mb->ctypes\u00dd*Feptr\u00a8 & ctype_word) == 0)\n            RRETURN(MATCH_NOMATCH);\n          Feptr++;\n          }\n        break;\n\n        default:\n        return PCRE2_ERROR_INTERNAL;\n        }\n      }\n\n    /* If Lmin = Lmax we are done. Continue with the main loop. */\n\n    if (Lmin == Lmax) continue;\n\n    /* If minimizing, we have to test the rest of the pattern before each\n    subsequent match. */\n\n    if (reptype == REPTYPE_MIN)\n      {\n#ifdef SUPPORT_UNICODE\n      if (proptype >= 0)\n        {\n        switch(proptype)\n          {\n          case PT_ANY:\n          for (;;)\n            {\n            RMATCH(Fecode, RM208);\n            if (rrc != MATCH_NOMATCH) RRETURN(rrc);\n            if (Lmin++ >= Lmax) RRETURN(MATCH_NOMATCH);\n            if (Feptr >= mb->end_subject)\n              {\n              SCHECK_PARTIAL();\n              RRETURN(MATCH_NOMATCH);\n              }\n            GETCHARINCTEST(fc, Feptr);\n            if (Lctype == OP_NOTPROP) RRETURN(MATCH_NOMATCH);\n            }\n          /* Control never gets here */\n\n          case PT_LAMP:\n          for (;;)\n            {\n            int chartype;\n            RMATCH(Fecode, RM209);\n            if (rrc != MATCH_NOMATCH) RRETURN(rrc);\n            if (Lmin++ >= Lmax) RRETURN(MATCH_NOMATCH);\n            if (Feptr >= mb->end_subject)\n              {\n              SCHECK_PARTIAL();\n              RRETURN(MATCH_NOMATCH);\n              }\n            GETCHARINCTEST(fc, Feptr);\n            chartype = UCD_CHARTYPE(fc);\n            if ((chartype == ucp_Lu ||\n                 chartype == ucp_Ll ||\n                 chartype == ucp_Lt) == (Lctype == OP_NOTPROP))\n              RRETURN(MATCH_NOMATCH);\n            }\n          /* Control never gets here */\n\n          case PT_GC:\n          for (;;)\n            {\n            RMATCH(Fecode, RM210);\n            if (rrc != MATCH_NOMATCH) RRETURN(rrc);\n            if (Lmin++ >= Lmax) RRETURN(MATCH_NOMATCH);\n            if (Feptr >= mb->end_subject)\n              {\n              SCHECK_PARTIAL();\n              RRETURN(MATCH_NOMATCH);\n              }\n            GETCHARINCTEST(fc, Feptr);\n            if ((UCD_CATEGORY(fc) == Lpropvalue) == (Lctype == OP_NOTPROP))\n              RRETURN(MATCH_NOMATCH);\n            }\n          /* Control never gets here */\n\n          case PT_PC:\n          for (;;)\n            {\n            RMATCH(Fecode, RM211);\n            if (rrc != MATCH_NOMATCH) RRETURN(rrc);\n            if (Lmin++ >= Lmax) RRETURN(MATCH_NOMATCH);\n            if (Feptr >= mb->end_subject)\n              {\n              SCHECK_PARTIAL();\n              RRETURN(MATCH_NOMATCH);\n              }\n            GETCHARINCTEST(fc, Feptr);\n            if ((UCD_CHARTYPE(fc) == Lpropvalue) == (Lctype == OP_NOTPROP))\n              RRETURN(MATCH_NOMATCH);\n            }\n          /* Control never gets here */\n\n          case PT_SC:\n          for (;;)\n            {\n            RMATCH(Fecode, RM212);\n            if (rrc != MATCH_NOMATCH) RRETURN(rrc);\n            if (Lmin++ >= Lmax) RRETURN(MATCH_NOMATCH);\n            if (Feptr >= mb->end_subject)\n              {\n              SCHECK_PARTIAL();\n              RRETURN(MATCH_NOMATCH);\n              }\n            GETCHARINCTEST(fc, Feptr);\n            if ((UCD_SCRIPT(fc) == Lpropvalue) == (Lctype == OP_NOTPROP))\n              RRETURN(MATCH_NOMATCH);\n            }\n          /* Control never gets here */\n\n          case PT_ALNUM:\n          for (;;)\n            {\n            int category;\n            RMATCH(Fecode, RM213);\n            if (rrc != MATCH_NOMATCH) RRETURN(rrc);\n            if (Lmin++ >= Lmax) RRETURN(MATCH_NOMATCH);\n            if (Feptr >= mb->end_subject)\n              {\n              SCHECK_PARTIAL();\n              RRETURN(MATCH_NOMATCH);\n              }\n            GETCHARINCTEST(fc, Feptr);\n            category = UCD_CATEGORY(fc);\n            if ((category == ucp_L || category == ucp_N) ==\n                (Lctype == OP_NOTPROP))\n              RRETURN(MATCH_NOMATCH);\n            }\n          /* Control never gets here */\n\n          /* Perl space used to exclude VT, but from Perl 5.18 it is included,\n          which means that Perl space and POSIX space are now identical. PCRE\n          was changed at release 8.34. */\n\n          case PT_SPACE:    /* Perl space */\n          case PT_PXSPACE:  /* POSIX space */\n          for (;;)\n            {\n            RMATCH(Fecode, RM214);\n            if (rrc != MATCH_NOMATCH) RRETURN(rrc);\n            if (Lmin++ >= Lmax) RRETURN(MATCH_NOMATCH);\n            if (Feptr >= mb->end_subject)\n              {\n              SCHECK_PARTIAL();\n              RRETURN(MATCH_NOMATCH);\n              }\n            GETCHARINCTEST(fc, Feptr);\n            switch(fc)\n              {\n              HSPACE_CASES:\n              VSPACE_CASES:\n              if (Lctype == OP_NOTPROP) RRETURN(MATCH_NOMATCH);\n              break;\n\n              default:\n              if ((UCD_CATEGORY(fc) == ucp_Z) == (Lctype == OP_NOTPROP))\n                RRETURN(MATCH_NOMATCH);\n              break;\n              }\n            }\n          /* Control never gets here */\n\n          case PT_WORD:\n          for (;;)\n            {\n            int category;\n            RMATCH(Fecode, RM215);\n            if (rrc != MATCH_NOMATCH) RRETURN(rrc);\n            if (Lmin++ >= Lmax) RRETURN(MATCH_NOMATCH);\n            if (Feptr >= mb->end_subject)\n              {\n              SCHECK_PARTIAL();\n              RRETURN(MATCH_NOMATCH);\n              }\n            GETCHARINCTEST(fc, Feptr);\n            category = UCD_CATEGORY(fc);\n            if ((category == ucp_L ||\n                 category == ucp_N ||\n                 fc == CHAR_UNDERSCORE) == (Lctype == OP_NOTPROP))\n              RRETURN(MATCH_NOMATCH);\n            }\n          /* Control never gets here */\n\n          case PT_CLIST:\n          for (;;)\n            {\n            const uint32_t *cp;\n            RMATCH(Fecode, RM216);\n            if (rrc != MATCH_NOMATCH) RRETURN(rrc);\n            if (Lmin++ >= Lmax) RRETURN(MATCH_NOMATCH);\n            if (Feptr >= mb->end_subject)\n              {\n              SCHECK_PARTIAL();\n              RRETURN(MATCH_NOMATCH);\n              }\n            GETCHARINCTEST(fc, Feptr);\n            cp = PRIV(ucd_caseless_sets) + Lpropvalue;\n            for (;;)\n              {\n              if (fc < *cp)\n                {\n                if (Lctype == OP_NOTPROP) break;\n                RRETURN(MATCH_NOMATCH);\n                }\n              if (fc == *cp++)\n                {\n                if (Lctype == OP_NOTPROP) RRETURN(MATCH_NOMATCH);\n                break;\n                }\n              }\n            }\n          /* Control never gets here */\n\n          case PT_UCNC:\n          for (;;)\n            {\n            RMATCH(Fecode, RM217);\n            if (rrc != MATCH_NOMATCH) RRETURN(rrc);\n            if (Lmin++ >= Lmax) RRETURN(MATCH_NOMATCH);\n            if (Feptr >= mb->end_subject)\n              {\n              SCHECK_PARTIAL();\n              RRETURN(MATCH_NOMATCH);\n              }\n            GETCHARINCTEST(fc, Feptr);\n            if ((fc == CHAR_DOLLAR_SIGN || fc == CHAR_COMMERCIAL_AT ||\n                 fc == CHAR_GRAVE_ACCENT || (fc >= 0xa0 && fc <= 0xd7ff) ||\n                 fc >= 0xe000) == (Lctype == OP_NOTPROP))\n              RRETURN(MATCH_NOMATCH);\n            }\n          /* Control never gets here */\n\n          /* This should never occur */\n          default:\n          return PCRE2_ERROR_INTERNAL;\n          }\n        }\n\n      /* Match extended Unicode sequences. We will get here only if the\n      support is in the binary; otherwise a compile-time error occurs. */\n\n      else if (Lctype == OP_EXTUNI)\n        {\n        for (;;)\n          {\n          RMATCH(Fecode, RM218);\n          if (rrc != MATCH_NOMATCH) RRETURN(rrc);\n          if (Lmin++ >= Lmax) RRETURN(MATCH_NOMATCH);\n          if (Feptr >= mb->end_subject)\n            {\n            SCHECK_PARTIAL();\n            RRETURN(MATCH_NOMATCH);\n            }\n          else\n            {\n            GETCHARINCTEST(fc, Feptr);\n            Feptr = PRIV(extuni)(fc, Feptr, mb->start_subject, mb->end_subject,\n              utf, NULL);\n            }\n          CHECK_PARTIAL();\n          }\n        }\n      else\n#endif     /* SUPPORT_UNICODE */\n\n      /* UTF mode for non-property testing character types. */\n\n#ifdef SUPPORT_UNICODE\n      if (utf)\n        {\n        for (;;)\n          {\n          RMATCH(Fecode, RM219);\n          if (rrc != MATCH_NOMATCH) RRETURN(rrc);\n          if (Lmin++ >= Lmax) RRETURN(MATCH_NOMATCH);\n          if (Feptr >= mb->end_subject)\n            {\n            SCHECK_PARTIAL();\n            RRETURN(MATCH_NOMATCH);\n            }\n          if (Lctype == OP_ANY && IS_NEWLINE(Feptr)) RRETURN(MATCH_NOMATCH);\n          GETCHARINC(fc, Feptr);\n          switch(Lctype)\n            {\n            case OP_ANY:               /* This is the non-NL case */\n            if (mb->partial != 0 &&    /* Take care with CRLF partial */\n                Feptr >= mb->end_subject &&\n                NLBLOCK->nltype == NLTYPE_FIXED &&\n                NLBLOCK->nllen == 2 &&\n                fc == NLBLOCK->nl\u00dd0\u00a8)\n              {\n              mb->hitend = TRUE;\n              if (mb->partial > 1) return PCRE2_ERROR_PARTIAL;\n              }\n            break;\n\n            case OP_ALLANY:\n            case OP_ANYBYTE:\n            break;\n\n            case OP_ANYNL:\n            switch(fc)\n              {\n              default: RRETURN(MATCH_NOMATCH);\n\n              case CHAR_CR:\n              if (Feptr < mb->end_subject && UCHAR21(Feptr) == CHAR_LF) Feptr++;\n              break;\n\n              case CHAR_LF:\n              break;\n\n              case CHAR_VT:\n              case CHAR_FF:\n              case CHAR_NEL:\n#ifndef EBCDIC\n              case 0x2028:\n              case 0x2029:\n#endif  /* Not EBCDIC */\n              if (mb->bsr_convention == PCRE2_BSR_ANYCRLF)\n                RRETURN(MATCH_NOMATCH);\n              break;\n              }\n            break;\n\n            case OP_NOT_HSPACE:\n            switch(fc)\n              {\n              HSPACE_CASES: RRETURN(MATCH_NOMATCH);\n              default: break;\n              }\n            break;\n\n            case OP_HSPACE:\n            switch(fc)\n              {\n              HSPACE_CASES: break;\n              default: RRETURN(MATCH_NOMATCH);\n              }\n            break;\n\n            case OP_NOT_VSPACE:\n            switch(fc)\n              {\n              VSPACE_CASES: RRETURN(MATCH_NOMATCH);\n              default: break;\n              }\n            break;\n\n            case OP_VSPACE:\n            switch(fc)\n              {\n              VSPACE_CASES: break;\n              default: RRETURN(MATCH_NOMATCH);\n              }\n            break;\n\n            case OP_NOT_DIGIT:\n            if (fc < 256 && (mb->ctypes\u00ddfc\u00a8 & ctype_digit) != 0)\n              RRETURN(MATCH_NOMATCH);\n            break;\n\n            case OP_DIGIT:\n            if (fc >= 256 || (mb->ctypes\u00ddfc\u00a8 & ctype_digit) == 0)\n              RRETURN(MATCH_NOMATCH);\n            break;\n\n            case OP_NOT_WHITESPACE:\n            if (fc < 256 && (mb->ctypes\u00ddfc\u00a8 & ctype_space) != 0)\n              RRETURN(MATCH_NOMATCH);\n            break;\n\n            case OP_WHITESPACE:\n            if (fc >= 256 || (mb->ctypes\u00ddfc\u00a8 & ctype_space) == 0)\n              RRETURN(MATCH_NOMATCH);\n            break;\n\n            case OP_NOT_WORDCHAR:\n            if (fc < 256 && (mb->ctypes\u00ddfc\u00a8 & ctype_word) != 0)\n              RRETURN(MATCH_NOMATCH);\n            break;\n\n            case OP_WORDCHAR:\n            if (fc >= 256 || (mb->ctypes\u00ddfc\u00a8 & ctype_word) == 0)\n              RRETURN(MATCH_NOMATCH);\n            break;\n\n            default:\n            return PCRE2_ERROR_INTERNAL;\n            }\n          }\n        }\n      else\n#endif  /* SUPPORT_UNICODE */\n\n      /* Not UTF mode */\n        {\n        for (;;)\n          {\n          RMATCH(Fecode, RM33);\n          if (rrc != MATCH_NOMATCH) RRETURN(rrc);\n          if (Lmin++ >= Lmax) RRETURN(MATCH_NOMATCH);\n          if (Feptr >= mb->end_subject)\n            {\n            SCHECK_PARTIAL();\n            RRETURN(MATCH_NOMATCH);\n            }\n          if (Lctype == OP_ANY && IS_NEWLINE(Feptr))\n            RRETURN(MATCH_NOMATCH);\n          fc = *Feptr++;\n          switch(Lctype)\n            {\n            case OP_ANY:               /* This is the non-NL case */\n            if (mb->partial != 0 &&    /* Take care with CRLF partial */\n                Feptr >= mb->end_subject &&\n                NLBLOCK->nltype == NLTYPE_FIXED &&\n                NLBLOCK->nllen == 2 &&\n                fc == NLBLOCK->nl\u00dd0\u00a8)\n              {\n              mb->hitend = TRUE;\n              if (mb->partial > 1) return PCRE2_ERROR_PARTIAL;\n              }\n            break;\n\n            case OP_ALLANY:\n            case OP_ANYBYTE:\n            break;\n\n            case OP_ANYNL:\n            switch(fc)\n              {\n              default: RRETURN(MATCH_NOMATCH);\n\n              case CHAR_CR:\n              if (Feptr < mb->end_subject && *Feptr == CHAR_LF) Feptr++;\n              break;\n\n              case CHAR_LF:\n              break;\n\n              case CHAR_VT:\n              case CHAR_FF:\n              case CHAR_NEL:\n#if PCRE2_CODE_UNIT_WIDTH != 8\n              case 0x2028:\n              case 0x2029:\n#endif\n              if (mb->bsr_convention == PCRE2_BSR_ANYCRLF)\n                RRETURN(MATCH_NOMATCH);\n              break;\n              }\n            break;\n\n            case OP_NOT_HSPACE:\n            switch(fc)\n              {\n              default: break;\n              HSPACE_BYTE_CASES:\n#if PCRE2_CODE_UNIT_WIDTH != 8\n              HSPACE_MULTIBYTE_CASES:\n#endif\n              RRETURN(MATCH_NOMATCH);\n              }\n            break;\n\n            case OP_HSPACE:\n            switch(fc)\n              {\n              default: RRETURN(MATCH_NOMATCH);\n              HSPACE_BYTE_CASES:\n#if PCRE2_CODE_UNIT_WIDTH != 8\n              HSPACE_MULTIBYTE_CASES:\n#endif\n              break;\n              }\n            break;\n\n            case OP_NOT_VSPACE:\n            switch(fc)\n              {\n              default: break;\n              VSPACE_BYTE_CASES:\n#if PCRE2_CODE_UNIT_WIDTH != 8\n              VSPACE_MULTIBYTE_CASES:\n#endif\n              RRETURN(MATCH_NOMATCH);\n              }\n            break;\n\n            case OP_VSPACE:\n            switch(fc)\n              {\n              default: RRETURN(MATCH_NOMATCH);\n              VSPACE_BYTE_CASES:\n#if PCRE2_CODE_UNIT_WIDTH != 8\n              VSPACE_MULTIBYTE_CASES:\n#endif\n              break;\n              }\n            break;\n\n            case OP_NOT_DIGIT:\n            if (MAX_255(fc) && (mb->ctypes\u00ddfc\u00a8 & ctype_digit) != 0)\n              RRETURN(MATCH_NOMATCH);\n            break;\n\n            case OP_DIGIT:\n            if (!MAX_255(fc) || (mb->ctypes\u00ddfc\u00a8 & ctype_digit) == 0)\n              RRETURN(MATCH_NOMATCH);\n            break;\n\n            case OP_NOT_WHITESPACE:\n            if (MAX_255(fc) && (mb->ctypes\u00ddfc\u00a8 & ctype_space) != 0)\n              RRETURN(MATCH_NOMATCH);\n            break;\n\n            case OP_WHITESPACE:\n            if (!MAX_255(fc) || (mb->ctypes\u00ddfc\u00a8 & ctype_space) == 0)\n              RRETURN(MATCH_NOMATCH);\n            break;\n\n            case OP_NOT_WORDCHAR:\n            if (MAX_255(fc) && (mb->ctypes\u00ddfc\u00a8 & ctype_word) != 0)\n              RRETURN(MATCH_NOMATCH);\n            break;\n\n            case OP_WORDCHAR:\n            if (!MAX_255(fc) || (mb->ctypes\u00ddfc\u00a8 & ctype_word) == 0)\n              RRETURN(MATCH_NOMATCH);\n            break;\n\n            default:\n            return PCRE2_ERROR_INTERNAL;\n            }\n          }\n        }\n      /* Control never gets here */\n      }\n\n    /* If maximizing, it is worth using inline code for speed, doing the type\n    test once at the start (i.e. keep it out of the loop). */\n\n    else\n      {\n      Lstart_eptr = Feptr;  /* Remember where we started */\n\n#ifdef SUPPORT_UNICODE\n      if (proptype >= 0)\n        {\n        switch(proptype)\n          {\n          case PT_ANY:\n          for (i = Lmin; i < Lmax; i++)\n            {\n            int len = 1;\n            if (Feptr >= mb->end_subject)\n              {\n              SCHECK_PARTIAL();\n              break;\n              }\n            GETCHARLENTEST(fc, Feptr, len);\n            if (Lctype == OP_NOTPROP) break;\n            Feptr+= len;\n            }\n          break;\n\n          case PT_LAMP:\n          for (i = Lmin; i < Lmax; i++)\n            {\n            int chartype;\n            int len = 1;\n            if (Feptr >= mb->end_subject)\n              {\n              SCHECK_PARTIAL();\n              break;\n              }\n            GETCHARLENTEST(fc, Feptr, len);\n            chartype = UCD_CHARTYPE(fc);\n            if ((chartype == ucp_Lu ||\n                 chartype == ucp_Ll ||\n                 chartype == ucp_Lt) == (Lctype == OP_NOTPROP))\n              break;\n            Feptr+= len;\n            }\n          break;\n\n          case PT_GC:\n          for (i = Lmin; i < Lmax; i++)\n            {\n            int len = 1;\n            if (Feptr >= mb->end_subject)\n              {\n              SCHECK_PARTIAL();\n              break;\n              }\n            GETCHARLENTEST(fc, Feptr, len);\n            if ((UCD_CATEGORY(fc) == Lpropvalue) == (Lctype == OP_NOTPROP))\n              break;\n            Feptr+= len;\n            }\n          break;\n\n          case PT_PC:\n          for (i = Lmin; i < Lmax; i++)\n            {\n            int len = 1;\n            if (Feptr >= mb->end_subject)\n              {\n              SCHECK_PARTIAL();\n              break;\n              }\n            GETCHARLENTEST(fc, Feptr, len);\n            if ((UCD_CHARTYPE(fc) == Lpropvalue) == (Lctype == OP_NOTPROP))\n              break;\n            Feptr+= len;\n            }\n          break;\n\n          case PT_SC:\n          for (i = Lmin; i < Lmax; i++)\n            {\n            int len = 1;\n            if (Feptr >= mb->end_subject)\n              {\n              SCHECK_PARTIAL();\n              break;\n              }\n            GETCHARLENTEST(fc, Feptr, len);\n            if ((UCD_SCRIPT(fc) == Lpropvalue) == (Lctype == OP_NOTPROP))\n              break;\n            Feptr+= len;\n            }\n          break;\n\n          case PT_ALNUM:\n          for (i = Lmin; i < Lmax; i++)\n            {\n            int category;\n            int len = 1;\n            if (Feptr >= mb->end_subject)\n              {\n              SCHECK_PARTIAL();\n              break;\n              }\n            GETCHARLENTEST(fc, Feptr, len);\n            category = UCD_CATEGORY(fc);\n            if ((category == ucp_L || category == ucp_N) ==\n                (Lctype == OP_NOTPROP))\n              break;\n            Feptr+= len;\n            }\n          break;\n\n          /* Perl space used to exclude VT, but from Perl 5.18 it is included,\n          which means that Perl space and POSIX space are now identical. PCRE\n          was changed at release 8.34. */\n\n          case PT_SPACE:    /* Perl space */\n          case PT_PXSPACE:  /* POSIX space */\n          for (i = Lmin; i < Lmax; i++)\n            {\n            int len = 1;\n            if (Feptr >= mb->end_subject)\n              {\n              SCHECK_PARTIAL();\n              break;\n              }\n            GETCHARLENTEST(fc, Feptr, len);\n            switch(fc)\n              {\n              HSPACE_CASES:\n              VSPACE_CASES:\n              if (Lctype == OP_NOTPROP) goto ENDLOOP99;  /* Break the loop */\n              break;\n\n              default:\n              if ((UCD_CATEGORY(fc) == ucp_Z) == (Lctype == OP_NOTPROP))\n                goto ENDLOOP99;   /* Break the loop */\n              break;\n              }\n            Feptr+= len;\n            }\n          ENDLOOP99:\n          break;\n\n          case PT_WORD:\n          for (i = Lmin; i < Lmax; i++)\n            {\n            int category;\n            int len = 1;\n            if (Feptr >= mb->end_subject)\n              {\n              SCHECK_PARTIAL();\n              break;\n              }\n            GETCHARLENTEST(fc, Feptr, len);\n            category = UCD_CATEGORY(fc);\n            if ((category == ucp_L || category == ucp_N ||\n                 fc == CHAR_UNDERSCORE) == (Lctype == OP_NOTPROP))\n              break;\n            Feptr+= len;\n            }\n          break;\n\n          case PT_CLIST:\n          for (i = Lmin; i < Lmax; i++)\n            {\n            const uint32_t *cp;\n            int len = 1;\n            if (Feptr >= mb->end_subject)\n              {\n              SCHECK_PARTIAL();\n              break;\n              }\n            GETCHARLENTEST(fc, Feptr, len);\n            cp = PRIV(ucd_caseless_sets) + Lpropvalue;\n            for (;;)\n              {\n              if (fc < *cp)\n                { if (Lctype == OP_NOTPROP) break; else goto GOT_MAX; }\n              if (fc == *cp++)\n                { if (Lctype == OP_NOTPROP) goto GOT_MAX; else break; }\n              }\n            Feptr += len;\n            }\n          GOT_MAX:\n          break;\n\n          case PT_UCNC:\n          for (i = Lmin; i < Lmax; i++)\n            {\n            int len = 1;\n            if (Feptr >= mb->end_subject)\n              {\n              SCHECK_PARTIAL();\n              break;\n              }\n            GETCHARLENTEST(fc, Feptr, len);\n            if ((fc == CHAR_DOLLAR_SIGN || fc == CHAR_COMMERCIAL_AT ||\n                 fc == CHAR_GRAVE_ACCENT || (fc >= 0xa0 && fc <= 0xd7ff) ||\n                 fc >= 0xe000) == (Lctype == OP_NOTPROP))\n              break;\n            Feptr += len;\n            }\n          break;\n\n          default:\n          return PCRE2_ERROR_INTERNAL;\n          }\n\n        /* Feptr is now past the end of the maximum run */\n\n        if (reptype == REPTYPE_POS) continue;    /* No backtracking */\n\n        /* After \\C in UTF mode, Lstart_eptr might be in the middle of a\n        Unicode character. Use <= Lstart_eptr to ensure backtracking doesn't\n        go too far. */\n\n        for(;;)\n          {\n          if (Feptr <= Lstart_eptr) break;\n          RMATCH(Fecode, RM222);\n          if (rrc != MATCH_NOMATCH) RRETURN(rrc);\n          Feptr--;\n          if (utf) BACKCHAR(Feptr);\n          }\n        }\n\n      /* Match extended Unicode grapheme clusters. We will get here only if the\n      support is in the binary; otherwise a compile-time error occurs. */\n\n      else if (Lctype == OP_EXTUNI)\n        {\n        for (i = Lmin; i < Lmax; i++)\n          {\n          if (Feptr >= mb->end_subject)\n            {\n            SCHECK_PARTIAL();\n            break;\n            }\n          else\n            {\n            GETCHARINCTEST(fc, Feptr);\n            Feptr = PRIV(extuni)(fc, Feptr, mb->start_subject, mb->end_subject,\n              utf, NULL);\n            }\n          CHECK_PARTIAL();\n          }\n\n        /* Feptr is now past the end of the maximum run */\n\n        if (reptype == REPTYPE_POS) continue;    /* No backtracking */\n\n        /* We use <= Lstart_eptr rather than == Lstart_eptr to detect the start\n        of the run while backtracking because the use of \\C in UTF mode can\n        cause BACKCHAR to move back past Lstart_eptr. This is just palliative;\n        the use of \\C in UTF mode is fraught with danger. */\n\n        for(;;)\n          {\n          int lgb, rgb;\n          PCRE2_SPTR fptr;\n\n          if (Feptr <= Lstart_eptr) break;   /* At start of char run */\n          RMATCH(Fecode, RM220);\n          if (rrc != MATCH_NOMATCH) RRETURN(rrc);\n\n          /* Backtracking over an extended grapheme cluster involves inspecting\n          the previous two characters (if present) to see if a break is\n          permitted between them. */\n\n          Feptr--;\n          if (!utf) fc = *Feptr; else\n            {\n            BACKCHAR(Feptr);\n            GETCHAR(fc, Feptr);\n            }\n          rgb = UCD_GRAPHBREAK(fc);\n\n          for (;;)\n            {\n            if (Feptr <= Lstart_eptr) break;   /* At start of char run */\n            fptr = Feptr - 1;\n            if (!utf) fc = *fptr; else\n              {\n              BACKCHAR(fptr);\n              GETCHAR(fc, fptr);\n              }\n            lgb = UCD_GRAPHBREAK(fc);\n            if ((PRIV(ucp_gbtable)\u00ddlgb\u00a8 & (1u << rgb)) == 0) break;\n            Feptr = fptr;\n            rgb = lgb;\n            }\n          }\n        }\n\n      else\n#endif   /* SUPPORT_UNICODE */\n\n#ifdef SUPPORT_UNICODE\n      if (utf)\n        {\n        switch(Lctype)\n          {\n          case OP_ANY:\n          for (i = Lmin; i < Lmax; i++)\n            {\n            if (Feptr >= mb->end_subject)\n              {\n              SCHECK_PARTIAL();\n              break;\n              }\n            if (IS_NEWLINE(Feptr)) break;\n            if (mb->partial != 0 &&    /* Take care with CRLF partial */\n                Feptr + 1 >= mb->end_subject &&\n                NLBLOCK->nltype == NLTYPE_FIXED &&\n                NLBLOCK->nllen == 2 &&\n                UCHAR21(Feptr) == NLBLOCK->nl\u00dd0\u00a8)\n              {\n              mb->hitend = TRUE;\n              if (mb->partial > 1) return PCRE2_ERROR_PARTIAL;\n              }\n            Feptr++;\n            ACROSSCHAR(Feptr < mb->end_subject, Feptr, Feptr++);\n            }\n          break;\n\n          case OP_ALLANY:\n          if (Lmax < UINT32_MAX)\n            {\n            for (i = Lmin; i < Lmax; i++)\n              {\n              if (Feptr >= mb->end_subject)\n                {\n                SCHECK_PARTIAL();\n                break;\n                }\n              Feptr++;\n              ACROSSCHAR(Feptr < mb->end_subject, Feptr, Feptr++);\n              }\n            }\n          else\n            {\n            Feptr = mb->end_subject;   /* Unlimited UTF-8 repeat */\n            SCHECK_PARTIAL();\n            }\n          break;\n\n          /* The \"byte\" (i.e. \"code unit\") case is the same as non-UTF */\n\n          case OP_ANYBYTE:\n          fc = Lmax - Lmin;\n          if (fc > (uint32_t)(mb->end_subject - Feptr))\n            {\n            Feptr = mb->end_subject;\n            SCHECK_PARTIAL();\n            }\n          else Feptr += fc;\n          break;\n\n          case OP_ANYNL:\n          for (i = Lmin; i < Lmax; i++)\n            {\n            int len = 1;\n            if (Feptr >= mb->end_subject)\n              {\n              SCHECK_PARTIAL();\n              break;\n              }\n            GETCHARLEN(fc, Feptr, len);\n            if (fc == CHAR_CR)\n              {\n              if (++Feptr >= mb->end_subject) break;\n              if (UCHAR21(Feptr) == CHAR_LF) Feptr++;\n              }\n            else\n              {\n              if (fc != CHAR_LF &&\n                  (mb->bsr_convention == PCRE2_BSR_ANYCRLF ||\n                   (fc != CHAR_VT && fc != CHAR_FF && fc != CHAR_NEL\n#ifndef EBCDIC\n                    && fc != 0x2028 && fc != 0x2029\n#endif  /* Not EBCDIC */\n                    )))\n                break;\n              Feptr += len;\n              }\n            }\n          break;\n\n          case OP_NOT_HSPACE:\n          case OP_HSPACE:\n          for (i = Lmin; i < Lmax; i++)\n            {\n            BOOL gotspace;\n            int len = 1;\n            if (Feptr >= mb->end_subject)\n              {\n              SCHECK_PARTIAL();\n              break;\n              }\n            GETCHARLEN(fc, Feptr, len);\n            switch(fc)\n              {\n              HSPACE_CASES: gotspace = TRUE; break;\n              default: gotspace = FALSE; break;\n              }\n            if (gotspace == (Lctype == OP_NOT_HSPACE)) break;\n            Feptr += len;\n            }\n          break;\n\n          case OP_NOT_VSPACE:\n          case OP_VSPACE:\n          for (i = Lmin; i < Lmax; i++)\n            {\n            BOOL gotspace;\n            int len = 1;\n            if (Feptr >= mb->end_subject)\n              {\n              SCHECK_PARTIAL();\n              break;\n              }\n            GETCHARLEN(fc, Feptr, len);\n            switch(fc)\n              {\n              VSPACE_CASES: gotspace = TRUE; break;\n              default: gotspace = FALSE; break;\n              }\n            if (gotspace == (Lctype == OP_NOT_VSPACE)) break;\n            Feptr += len;\n            }\n          break;\n\n          case OP_NOT_DIGIT:\n          for (i = Lmin; i < Lmax; i++)\n            {\n            int len = 1;\n            if (Feptr >= mb->end_subject)\n              {\n              SCHECK_PARTIAL();\n              break;\n              }\n            GETCHARLEN(fc, Feptr, len);\n            if (fc < 256 && (mb->ctypes\u00ddfc\u00a8 & ctype_digit) != 0) break;\n            Feptr+= len;\n            }\n          break;\n\n          case OP_DIGIT:\n          for (i = Lmin; i < Lmax; i++)\n            {\n            int len = 1;\n            if (Feptr >= mb->end_subject)\n              {\n              SCHECK_PARTIAL();\n              break;\n              }\n            GETCHARLEN(fc, Feptr, len);\n            if (fc >= 256 ||(mb->ctypes\u00ddfc\u00a8 & ctype_digit) == 0) break;\n            Feptr+= len;\n            }\n          break;\n\n          case OP_NOT_WHITESPACE:\n          for (i = Lmin; i < Lmax; i++)\n            {\n            int len = 1;\n            if (Feptr >= mb->end_subject)\n              {\n              SCHECK_PARTIAL();\n              break;\n              }\n            GETCHARLEN(fc, Feptr, len);\n            if (fc < 256 && (mb->ctypes\u00ddfc\u00a8 & ctype_space) != 0) break;\n            Feptr+= len;\n            }\n          break;\n\n          case OP_WHITESPACE:\n          for (i = Lmin; i < Lmax; i++)\n            {\n            int len = 1;\n            if (Feptr >= mb->end_subject)\n              {\n              SCHECK_PARTIAL();\n              break;\n              }\n            GETCHARLEN(fc, Feptr, len);\n            if (fc >= 256 ||(mb->ctypes\u00ddfc\u00a8 & ctype_space) == 0) break;\n            Feptr+= len;\n            }\n          break;\n\n          case OP_NOT_WORDCHAR:\n          for (i = Lmin; i < Lmax; i++)\n            {\n            int len = 1;\n            if (Feptr >= mb->end_subject)\n              {\n              SCHECK_PARTIAL();\n              break;\n              }\n            GETCHARLEN(fc, Feptr, len);\n            if (fc < 256 && (mb->ctypes\u00ddfc\u00a8 & ctype_word) != 0) break;\n            Feptr+= len;\n            }\n          break;\n\n          case OP_WORDCHAR:\n          for (i = Lmin; i < Lmax; i++)\n            {\n            int len = 1;\n            if (Feptr >= mb->end_subject)\n              {\n              SCHECK_PARTIAL();\n              break;\n              }\n            GETCHARLEN(fc, Feptr, len);\n            if (fc >= 256 || (mb->ctypes\u00ddfc\u00a8 & ctype_word) == 0) break;\n            Feptr+= len;\n            }\n          break;\n\n          default:\n          return PCRE2_ERROR_INTERNAL;\n          }\n\n        if (reptype == REPTYPE_POS) continue;    /* No backtracking */\n\n        /* After \\C in UTF mode, Lstart_eptr might be in the middle of a\n        Unicode character. Use <= Lstart_eptr to ensure backtracking doesn't go\n        too far. */\n\n        for(;;)\n          {\n          if (Feptr <= Lstart_eptr) break;\n          RMATCH(Fecode, RM221);\n          if (rrc != MATCH_NOMATCH) RRETURN(rrc);\n          Feptr--;\n          BACKCHAR(Feptr);\n          if (Lctype == OP_ANYNL && Feptr > Lstart_eptr &&\n              UCHAR21(Feptr) == CHAR_NL && UCHAR21(Feptr - 1) == CHAR_CR)\n            Feptr--;\n          }\n        }\n      else\n#endif  /* SUPPORT_UNICODE */\n\n      /* Not UTF mode */\n        {\n        switch(Lctype)\n          {\n          case OP_ANY:\n          for (i = Lmin; i < Lmax; i++)\n            {\n            if (Feptr >= mb->end_subject)\n              {\n              SCHECK_PARTIAL();\n              break;\n              }\n            if (IS_NEWLINE(Feptr)) break;\n            if (mb->partial != 0 &&    /* Take care with CRLF partial */\n                Feptr + 1 >= mb->end_subject &&\n                NLBLOCK->nltype == NLTYPE_FIXED &&\n                NLBLOCK->nllen == 2 &&\n                *Feptr == NLBLOCK->nl\u00dd0\u00a8)\n              {\n              mb->hitend = TRUE;\n              if (mb->partial > 1) return PCRE2_ERROR_PARTIAL;\n              }\n            Feptr++;\n            }\n          break;\n\n          case OP_ALLANY:\n          case OP_ANYBYTE:\n          fc = Lmax - Lmin;\n          if (fc > (uint32_t)(mb->end_subject - Feptr))\n            {\n            Feptr = mb->end_subject;\n            SCHECK_PARTIAL();\n            }\n          else Feptr += fc;\n          break;\n\n          case OP_ANYNL:\n          for (i = Lmin; i < Lmax; i++)\n            {\n            if (Feptr >= mb->end_subject)\n              {\n              SCHECK_PARTIAL();\n              break;\n              }\n            fc = *Feptr;\n            if (fc == CHAR_CR)\n              {\n              if (++Feptr >= mb->end_subject) break;\n              if (*Feptr == CHAR_LF) Feptr++;\n              }\n            else\n              {\n              if (fc != CHAR_LF && (mb->bsr_convention == PCRE2_BSR_ANYCRLF ||\n                 (fc != CHAR_VT && fc != CHAR_FF && fc != CHAR_NEL\n#if PCRE2_CODE_UNIT_WIDTH != 8\n                 && fc != 0x2028 && fc != 0x2029\n#endif\n                 ))) break;\n              Feptr++;\n              }\n            }\n          break;\n\n          case OP_NOT_HSPACE:\n          for (i = Lmin; i < Lmax; i++)\n            {\n            if (Feptr >= mb->end_subject)\n              {\n              SCHECK_PARTIAL();\n              break;\n              }\n            switch(*Feptr)\n              {\n              default: Feptr++; break;\n              HSPACE_BYTE_CASES:\n#if PCRE2_CODE_UNIT_WIDTH != 8\n              HSPACE_MULTIBYTE_CASES:\n#endif\n              goto ENDLOOP00;\n              }\n            }\n          ENDLOOP00:\n          break;\n\n          case OP_HSPACE:\n          for (i = Lmin; i < Lmax; i++)\n            {\n            if (Feptr >= mb->end_subject)\n              {\n              SCHECK_PARTIAL();\n              break;\n              }\n            switch(*Feptr)\n              {\n              default: goto ENDLOOP01;\n              HSPACE_BYTE_CASES:\n#if PCRE2_CODE_UNIT_WIDTH != 8\n              HSPACE_MULTIBYTE_CASES:\n#endif\n              Feptr++; break;\n              }\n            }\n          ENDLOOP01:\n          break;\n\n          case OP_NOT_VSPACE:\n          for (i = Lmin; i < Lmax; i++)\n            {\n            if (Feptr >= mb->end_subject)\n              {\n              SCHECK_PARTIAL();\n              break;\n              }\n            switch(*Feptr)\n              {\n              default: Feptr++; break;\n              VSPACE_BYTE_CASES:\n#if PCRE2_CODE_UNIT_WIDTH != 8\n              VSPACE_MULTIBYTE_CASES:\n#endif\n              goto ENDLOOP02;\n              }\n            }\n          ENDLOOP02:\n          break;\n\n          case OP_VSPACE:\n          for (i = Lmin; i < Lmax; i++)\n            {\n            if (Feptr >= mb->end_subject)\n              {\n              SCHECK_PARTIAL();\n              break;\n              }\n            switch(*Feptr)\n              {\n              default: goto ENDLOOP03;\n              VSPACE_BYTE_CASES:\n#if PCRE2_CODE_UNIT_WIDTH != 8\n              VSPACE_MULTIBYTE_CASES:\n#endif\n              Feptr++; break;\n              }\n            }\n          ENDLOOP03:\n          break;\n\n          case OP_NOT_DIGIT:\n          for (i = Lmin; i < Lmax; i++)\n            {\n            if (Feptr >= mb->end_subject)\n              {\n              SCHECK_PARTIAL();\n              break;\n              }\n            if (MAX_255(*Feptr) && (mb->ctypes\u00dd*Feptr\u00a8 & ctype_digit) != 0)\n              break;\n            Feptr++;\n            }\n          break;\n\n          case OP_DIGIT:\n          for (i = Lmin; i < Lmax; i++)\n            {\n            if (Feptr >= mb->end_subject)\n              {\n              SCHECK_PARTIAL();\n              break;\n              }\n            if (!MAX_255(*Feptr) || (mb->ctypes\u00dd*Feptr\u00a8 & ctype_digit) == 0)\n              break;\n            Feptr++;\n            }\n          break;\n\n          case OP_NOT_WHITESPACE:\n          for (i = Lmin; i < Lmax; i++)\n            {\n            if (Feptr >= mb->end_subject)\n              {\n              SCHECK_PARTIAL();\n              break;\n              }\n            if (MAX_255(*Feptr) && (mb->ctypes\u00dd*Feptr\u00a8 & ctype_space) != 0)\n              break;\n            Feptr++;\n            }\n          break;\n\n          case OP_WHITESPACE:\n          for (i = Lmin; i < Lmax; i++)\n            {\n            if (Feptr >= mb->end_subject)\n              {\n              SCHECK_PARTIAL();\n              break;\n              }\n            if (!MAX_255(*Feptr) || (mb->ctypes\u00dd*Feptr\u00a8 & ctype_space) == 0)\n              break;\n            Feptr++;\n            }\n          break;\n\n          case OP_NOT_WORDCHAR:\n          for (i = Lmin; i < Lmax; i++)\n            {\n            if (Feptr >= mb->end_subject)\n              {\n              SCHECK_PARTIAL();\n              break;\n              }\n            if (MAX_255(*Feptr) && (mb->ctypes\u00dd*Feptr\u00a8 & ctype_word) != 0)\n              break;\n            Feptr++;\n            }\n          break;\n\n          case OP_WORDCHAR:\n          for (i = Lmin; i < Lmax; i++)\n            {\n            if (Feptr >= mb->end_subject)\n              {\n              SCHECK_PARTIAL();\n              break;\n              }\n            if (!MAX_255(*Feptr) || (mb->ctypes\u00dd*Feptr\u00a8 & ctype_word) == 0)\n              break;\n            Feptr++;\n            }\n          break;\n\n          default:\n          return PCRE2_ERROR_INTERNAL;\n          }\n\n        if (reptype == REPTYPE_POS) continue;    /* No backtracking */\n\n        for (;;)\n          {\n          if (Feptr == Lstart_eptr) break;\n          RMATCH(Fecode, RM34);\n          if (rrc != MATCH_NOMATCH) RRETURN(rrc);\n          Feptr--;\n          if (Lctype == OP_ANYNL && Feptr > Lstart_eptr && *Feptr == CHAR_LF &&\n              Feptr\u00dd-1\u00a8 == CHAR_CR) Feptr--;\n          }\n        }\n      }\n    break;  /* End of repeat character type processing */\n\n#undef Lstart_eptr\n#undef Lmin\n#undef Lmax\n#undef Lctype\n#undef Lpropvalue\n\n\n    /* ===================================================================== */\n    /* Match a back reference, possibly repeatedly. Look past the end of the\n    item to see if there is repeat information following. The OP_REF and\n    OP_REFI opcodes are used for a reference to a numbered group or to a\n    non-duplicated named group. For a duplicated named group, OP_DNREF and\n    OP_DNREFI are used. In this case we must scan the list of groups to which\n    the name refers, and use the first one that is set. */\n\n#define Lmin      F->temp_32\u00dd0\u00a8\n#define Lmax      F->temp_32\u00dd1\u00a8\n#define Lcaseless F->temp_32\u00dd2\u00a8\n#define Lstart    F->temp_sptr\u00dd0\u00a8\n#define Loffset   F->temp_size\n\n    case OP_DNREF:\n    case OP_DNREFI:\n    Lcaseless = (Fop == OP_DNREFI);\n      {\n      int count = GET2(Fecode, 1+IMM2_SIZE);\n      PCRE2_SPTR slot = mb->name_table + GET2(Fecode, 1) * mb->name_entry_size;\n      Fecode += 1 + 2*IMM2_SIZE;\n\n      while (count-- > 0)\n        {\n        Loffset = (GET2(slot, 0) << 1) - 2;\n        if (Loffset < Foffset_top && Fovector\u00ddLoffset\u00a8 != PCRE2_UNSET) break;\n        slot += mb->name_entry_size;\n        }\n      }\n    goto REF_REPEAT;\n\n    case OP_REF:\n    case OP_REFI:\n    Lcaseless = (Fop == OP_REFI);\n    Loffset = (GET2(Fecode, 1) << 1) - 2;\n    Fecode += 1 + IMM2_SIZE;\n\n    /* Set up for repetition, or handle the non-repeated case. The maximum and\n    minimum must be in the heap frame, but as they are short-term values, we\n    use temporary fields. */\n\n    REF_REPEAT:\n    switch (*Fecode)\n      {\n      case OP_CRSTAR:\n      case OP_CRMINSTAR:\n      case OP_CRPLUS:\n      case OP_CRMINPLUS:\n      case OP_CRQUERY:\n      case OP_CRMINQUERY:\n      fc = *Fecode++ - OP_CRSTAR;\n      Lmin = rep_min\u00ddfc\u00a8;\n      Lmax = rep_max\u00ddfc\u00a8;\n      reptype = rep_typ\u00ddfc\u00a8;\n      break;\n\n      case OP_CRRANGE:\n      case OP_CRMINRANGE:\n      Lmin = GET2(Fecode, 1);\n      Lmax = GET2(Fecode, 1 + IMM2_SIZE);\n      reptype = rep_typ\u00dd*Fecode - OP_CRSTAR\u00a8;\n      if (Lmax == 0) Lmax = UINT32_MAX;  /* Max 0 => infinity */\n      Fecode += 1 + 2 * IMM2_SIZE;\n      break;\n\n      default:                  /* No repeat follows */\n        {\n        rrc = match_ref(Loffset, Lcaseless, F, mb, &length);\n        if (rrc != 0)\n          {\n          if (rrc > 0) Feptr = mb->end_subject;   /* Partial match */\n          CHECK_PARTIAL();\n          RRETURN(MATCH_NOMATCH);\n          }\n        }\n      Feptr += length;\n      continue;              /* With the main loop */\n      }\n\n    /* Handle repeated back references. If a set group has length zero, just\n    continue with the main loop, because it matches however many times. For an\n    unset reference, if the minimum is zero, we can also just continue. We can\n    also continue if PCRE2_MATCH_UNSET_BACKREF is set, because this makes unset\n    group behave as a zero-length group. For any other unset cases, carrying\n    on will result in NOMATCH. */\n\n    if (Loffset < Foffset_top && Fovector\u00ddLoffset\u00a8 != PCRE2_UNSET)\n      {\n      if (Fovector\u00ddLoffset\u00a8 == Fovector\u00ddLoffset + 1\u00a8) continue;\n      }\n    else  /* Group is not set */\n      {\n      if (Lmin == 0 || (mb->poptions & PCRE2_MATCH_UNSET_BACKREF) != 0)\n        continue;\n      }\n\n    /* First, ensure the minimum number of matches are present. */\n\n    for (i = 1; i <= Lmin; i++)\n      {\n      PCRE2_SIZE slength;\n      rrc = match_ref(Loffset, Lcaseless, F, mb, &slength);\n      if (rrc != 0)\n        {\n        if (rrc > 0) Feptr = mb->end_subject;   /* Partial match */\n        CHECK_PARTIAL();\n        RRETURN(MATCH_NOMATCH);\n        }\n      Feptr += slength;\n      }\n\n    /* If min = max, we are done. They are not both allowed to be zero. */\n\n    if (Lmin == Lmax) continue;\n\n    /* If minimizing, keep trying and advancing the pointer. */\n\n    if (reptype == REPTYPE_MIN)\n      {\n      for (;;)\n        {\n        PCRE2_SIZE slength;\n        RMATCH(Fecode, RM20);\n        if (rrc != MATCH_NOMATCH) RRETURN(rrc);\n        if (Lmin++ >= Lmax) RRETURN(MATCH_NOMATCH);\n        rrc = match_ref(Loffset, Lcaseless, F, mb, &slength);\n        if (rrc != 0)\n          {\n          if (rrc > 0) Feptr = mb->end_subject;   /* Partial match */\n          CHECK_PARTIAL();\n          RRETURN(MATCH_NOMATCH);\n          }\n        Feptr += slength;\n        }\n      /* Control never gets here */\n      }\n\n    /* If maximizing, find the longest string and work backwards, as long as\n    the matched lengths for each iteration are the same. */\n\n    else\n      {\n      BOOL samelengths = TRUE;\n      Lstart = Feptr;     /* Starting position */\n      Flength = Fovector\u00ddLoffset+1\u00a8 - Fovector\u00ddLoffset\u00a8;\n\n      for (i = Lmin; i < Lmax; i++)\n        {\n        PCRE2_SIZE slength;\n        rrc = match_ref(Loffset, Lcaseless, F, mb, &slength);\n        if (rrc != 0)\n          {\n          /* Can't use CHECK_PARTIAL because we don't want to update Feptr in\n          the soft partial matching case. */\n\n          if (rrc > 0 && mb->partial != 0 &&\n              mb->end_subject > mb->start_used_ptr)\n            {\n            mb->hitend = TRUE;\n            if (mb->partial > 1) return PCRE2_ERROR_PARTIAL;\n            }\n          break;\n          }\n\n        if (slength != Flength) samelengths = FALSE;\n        Feptr += slength;\n        }\n\n      /* If the length matched for each repetition is the same as the length of\n      the captured group, we can easily work backwards. This is the normal\n      case. However, in caseless UTF-8 mode there are pairs of case-equivalent\n      characters whose lengths (in terms of code units) differ. However, this\n      is very rare, so we handle it by re-matching fewer and fewer times. */\n\n      if (samelengths)\n        {\n        while (Feptr >= Lstart)\n          {\n          RMATCH(Fecode, RM21);\n          if (rrc != MATCH_NOMATCH) RRETURN(rrc);\n          Feptr -= Flength;\n          }\n        }\n\n      /* The rare case of non-matching lengths. Re-scan the repetition for each\n      iteration. We know that match_ref() will succeed every time. */\n\n      else\n        {\n        Lmax = i;\n        for (;;)\n          {\n          RMATCH(Fecode, RM22);\n          if (rrc != MATCH_NOMATCH) RRETURN(rrc);\n          if (Feptr == Lstart) break; /* Failed after minimal repetition */\n          Feptr = Lstart;\n          Lmax--;\n          for (i = Lmin; i < Lmax; i++)\n            {\n            PCRE2_SIZE slength;\n            (void)match_ref(Loffset, Lcaseless, F, mb, &slength);\n            Feptr += slength;\n            }\n          }\n        }\n\n      RRETURN(MATCH_NOMATCH);\n      }\n    /* Control never gets here */\n\n#undef Lcaseless\n#undef Lmin\n#undef Lmax\n#undef Lstart\n#undef Loffset\n\n\n\n/* ========================================================================= */\n/*           Opcodes for the start of various parenthesized items            */\n/* ========================================================================= */\n\n    /* In all cases, if the result of RMATCH() is MATCH_THEN, check whether the\n    (*THEN) is within the current branch by comparing the address of OP_THEN\n    that is passed back with the end of the branch. If (*THEN) is within the\n    current branch, and the branch is one of two or more alternatives (it\n    either starts or ends with OP_ALT), we have reached the limit of THEN's\n    action, so convert the return code to NOMATCH, which will cause normal\n    backtracking to happen from now on. Otherwise, THEN is passed back to an\n    outer alternative. This implements Perl's treatment of parenthesized\n    groups, where a group not containing | does not affect the current\n    alternative, that is, (X) is NOT the same as (X|(*F)). */\n\n\n    /* ===================================================================== */\n    /* BRAZERO, BRAMINZERO and SKIPZERO occur just before a non-possessive\n    bracket group, indicating that it may occur zero times. It may repeat\n    infinitely, or not at all - i.e. it could be ()* or ()? or even (){0} in\n    the pattern. Brackets with fixed upper repeat limits are compiled as a\n    number of copies, with the optional ones preceded by BRAZERO or BRAMINZERO.\n    Possessive groups with possible zero repeats are preceded by BRAPOSZERO. */\n\n#define Lnext_ecode F->temp_sptr\u00dd0\u00a8\n\n    case OP_BRAZERO:\n    Lnext_ecode = Fecode + 1;\n    RMATCH(Lnext_ecode, RM9);\n    if (rrc != MATCH_NOMATCH) RRETURN(rrc);\n    do Lnext_ecode += GET(Lnext_ecode, 1); while (*Lnext_ecode == OP_ALT);\n    Fecode = Lnext_ecode + 1 + LINK_SIZE;\n    break;\n\n    case OP_BRAMINZERO:\n    Lnext_ecode = Fecode + 1;\n    do Lnext_ecode += GET(Lnext_ecode, 1); while (*Lnext_ecode == OP_ALT);\n    RMATCH(Lnext_ecode + 1 + LINK_SIZE, RM10);\n    if (rrc != MATCH_NOMATCH) RRETURN(rrc);\n    Fecode++;\n    break;\n\n#undef Lnext_ecode\n\n    case OP_SKIPZERO:\n    Fecode++;\n    do Fecode += GET(Fecode,1); while (*Fecode == OP_ALT);\n    Fecode += 1 + LINK_SIZE;\n    break;\n\n\n    /* ===================================================================== */\n    /* Handle possessive brackets with an unlimited repeat. The end of these\n    brackets will always be OP_KETRPOS, which returns MATCH_KETRPOS without\n    going further in the pattern. */\n\n#define Lframe_type    F->temp_32\u00dd0\u00a8\n#define Lmatched_once  F->temp_32\u00dd1\u00a8\n#define Lzero_allowed  F->temp_32\u00dd2\u00a8\n#define Lstart_eptr    F->temp_sptr\u00dd0\u00a8\n#define Lstart_group   F->temp_sptr\u00dd1\u00a8\n\n    case OP_BRAPOSZERO:\n    Lzero_allowed = TRUE;                /* Zero repeat is allowed */\n    Fecode += 1;\n    if (*Fecode == OP_CBRAPOS || *Fecode == OP_SCBRAPOS)\n      goto POSSESSIVE_CAPTURE;\n    goto POSSESSIVE_NON_CAPTURE;\n\n    case OP_BRAPOS:\n    case OP_SBRAPOS:\n    Lzero_allowed = FALSE;               /* Zero repeat not allowed */\n\n    POSSESSIVE_NON_CAPTURE:\n    Lframe_type = GF_NOCAPTURE;          /* Remembered frame type */\n    goto POSSESSIVE_GROUP;\n\n    case OP_CBRAPOS:\n    case OP_SCBRAPOS:\n    Lzero_allowed = FALSE;               /* Zero repeat not allowed */\n\n    POSSESSIVE_CAPTURE:\n    number = GET2(Fecode, 1+LINK_SIZE);\n    Lframe_type = GF_CAPTURE | number;   /* Remembered frame type */\n\n    POSSESSIVE_GROUP:\n    Lmatched_once = FALSE;               /* Never matched */\n    Lstart_group = Fecode;               /* Start of this group */\n\n    for (;;)\n      {\n      Lstart_eptr = Feptr;               /* Position at group start */\n      group_frame_type = Lframe_type;\n      RMATCH(Fecode + PRIV(OP_lengths)\u00dd*Fecode\u00a8, RM8);\n      if (rrc == MATCH_KETRPOS)\n        {\n        Lmatched_once = TRUE;            /* Matched at least once */\n        if (Feptr == Lstart_eptr)        /* Empty match; skip to end */\n          {\n          do Fecode += GET(Fecode, 1); while (*Fecode == OP_ALT);\n          break;\n          }\n\n        Fecode = Lstart_group;\n        continue;\n        }\n\n      /* See comment above about handling THEN. */\n\n      if (rrc == MATCH_THEN)\n        {\n        PCRE2_SPTR next_ecode = Fecode + GET(Fecode,1);\n        if (mb->verb_ecode_ptr < next_ecode &&\n            (*Fecode == OP_ALT || *next_ecode == OP_ALT))\n          rrc = MATCH_NOMATCH;\n        }\n\n      if (rrc != MATCH_NOMATCH) RRETURN(rrc);\n      Fecode += GET(Fecode, 1);\n      if (*Fecode != OP_ALT) break;\n      }\n\n    /* Success if matched something or zero repeat allowed */\n\n    if (Lmatched_once || Lzero_allowed)\n      {\n      Fecode += 1 + LINK_SIZE;\n      break;\n      }\n\n    RRETURN(MATCH_NOMATCH);\n\n#undef Lmatched_once\n#undef Lzero_allowed\n#undef Lframe_type\n#undef Lstart_eptr\n#undef Lstart_group\n\n\n    /* ===================================================================== */\n    /* Handle non-capturing brackets that cannot match an empty string. When we\n    get to the final alternative within the brackets, as long as there are no\n    THEN's in the pattern, we can optimize by not recording a new backtracking\n    point. (Ideally we should test for a THEN within this group, but we don't\n    have that information.) Don't do this if we are at the very top level,\n    however, because that would make handling assertions and once-only brackets\n    messier when there is nothing to go back to. */\n\n#define Lframe_type F->temp_32\u00dd0\u00a8     /* Set for all that use GROUPLOOP */\n#define Lnext_branch F->temp_sptr\u00dd0\u00a8  /* Used only in OP_BRA handling */\n\n    case OP_BRA:\n    if (mb->hasthen || Frdepth == 0)\n      {\n      Lframe_type = 0;\n      goto GROUPLOOP;\n      }\n\n    for (;;)\n      {\n      Lnext_branch = Fecode + GET(Fecode, 1);\n      if (*Lnext_branch != OP_ALT) break;\n\n      /* This is never the final branch. We do not need to test for MATCH_THEN\n      here because this code is not used when there is a THEN in the pattern. */\n\n      RMATCH(Fecode + PRIV(OP_lengths)\u00dd*Fecode\u00a8, RM1);\n      if (rrc != MATCH_NOMATCH) RRETURN(rrc);\n      Fecode = Lnext_branch;\n      }\n\n    /* Hit the start of the final branch. Continue at this level. */\n\n    Fecode += PRIV(OP_lengths)\u00dd*Fecode\u00a8;\n    break;\n\n#undef Lnext_branch\n\n\n    /* ===================================================================== */\n    /* Handle a capturing bracket, other than those that are possessive with an\n    unlimited repeat. */\n\n    case OP_CBRA:\n    case OP_SCBRA:\n    Lframe_type = GF_CAPTURE | GET2(Fecode, 1+LINK_SIZE);\n    goto GROUPLOOP;\n\n\n    /* ===================================================================== */\n    /* Atomic groups and non-capturing brackets that can match an empty string\n    must record a backtracking point and also set up a chained frame. */\n\n    case OP_ONCE:\n    case OP_SCRIPT_RUN:\n    case OP_SBRA:\n    Lframe_type = GF_NOCAPTURE | Fop;\n\n    GROUPLOOP:\n    for (;;)\n      {\n      group_frame_type = Lframe_type;\n      RMATCH(Fecode + PRIV(OP_lengths)\u00dd*Fecode\u00a8, RM2);\n      if (rrc == MATCH_THEN)\n        {\n        PCRE2_SPTR next_ecode = Fecode + GET(Fecode,1);\n        if (mb->verb_ecode_ptr < next_ecode &&\n            (*Fecode == OP_ALT || *next_ecode == OP_ALT))\n          rrc = MATCH_NOMATCH;\n        }\n      if (rrc != MATCH_NOMATCH) RRETURN(rrc);\n      Fecode += GET(Fecode, 1);\n      if (*Fecode != OP_ALT) RRETURN(MATCH_NOMATCH);\n      }\n    /* Control never reaches here. */\n\n#undef Lframe_type\n\n\n    /* ===================================================================== */\n    /* Recursion either matches the current regex, or some subexpression. The\n    offset data is the offset to the starting bracket from the start of the\n    whole pattern. (This is so that it works from duplicated subpatterns.) */\n\n#define Lframe_type F->temp_32\u00dd0\u00a8\n#define Lstart_branch F->temp_sptr\u00dd0\u00a8\n\n    case OP_RECURSE:\n    bracode = mb->start_code + GET(Fecode, 1);\n    number = (bracode == mb->start_code)? 0 : GET2(bracode, 1 + LINK_SIZE);\n\n    /* If we are already in a recursion, check for repeating the same one\n    without advancing the subject pointer. This should catch convoluted mutual\n    recursions. (Some simple cases are caught at compile time.) */\n\n    if (Fcurrent_recurse != RECURSE_UNSET)\n      {\n      offset = Flast_group_offset;\n      while (offset != PCRE2_UNSET)\n        {\n        N = (heapframe *)((char *)mb->match_frames + offset);\n        P = (heapframe *)((char *)N - frame_size);\n        if (N->group_frame_type == (GF_RECURSE | number))\n          {\n          if (Feptr == P->eptr) return PCRE2_ERROR_RECURSELOOP;\n          break;\n          }\n        offset = P->last_group_offset;\n        }\n      }\n\n    /* Now run the recursion, branch by branch. */\n\n    Lstart_branch = bracode;\n    Lframe_type = GF_RECURSE | number;\n\n    for (;;)\n      {\n      PCRE2_SPTR next_ecode;\n\n      group_frame_type = Lframe_type;\n      RMATCH(Lstart_branch + PRIV(OP_lengths)\u00dd*Lstart_branch\u00a8, RM11);\n      next_ecode = Lstart_branch + GET(Lstart_branch,1);\n\n      /* Handle backtracking verbs, which are defined in a range that can\n      easily be tested for. PCRE does not allow THEN, SKIP, PRUNE or COMMIT to\n      escape beyond a recursion; they cause a NOMATCH for the entire recursion.\n\n      When one of these verbs triggers, the current recursion group number is\n      recorded. If it matches the recursion we are processing, the verb\n      happened within the recursion and we must deal with it. Otherwise it must\n      have happened after the recursion completed, and so has to be passed\n      back. See comment above about handling THEN. */\n\n      if (rrc >= MATCH_BACKTRACK_MIN && rrc <= MATCH_BACKTRACK_MAX &&\n          mb->verb_current_recurse == (Lframe_type \u00ac GF_RECURSE))\n        {\n        if (rrc == MATCH_THEN && mb->verb_ecode_ptr < next_ecode &&\n            (*Lstart_branch == OP_ALT || *next_ecode == OP_ALT))\n          rrc = MATCH_NOMATCH;\n        else RRETURN(MATCH_NOMATCH);\n        }\n\n      /* Note that carrying on after (*ACCEPT) in a recursion is handled in the\n      OP_ACCEPT code. Nothing needs to be done here. */\n\n      if (rrc != MATCH_NOMATCH) RRETURN(rrc);\n      Lstart_branch = next_ecode;\n      if (*Lstart_branch != OP_ALT) RRETURN(MATCH_NOMATCH);\n      }\n    /* Control never reaches here. */\n\n#undef Lframe_type\n#undef Lstart_branch\n\n\n    /* ===================================================================== */\n    /* Positive assertions are like other groups except that PCRE doesn't allow\n    the effect of (*THEN) to escape beyond an assertion; it is therefore\n    treated as NOMATCH. (*ACCEPT) is treated as successful assertion, with its\n    captures and mark retained. Any other return is an error. */\n\n#define Lframe_type  F->temp_32\u00dd0\u00a8\n\n    case OP_ASSERT:\n    case OP_ASSERTBACK:\n    case OP_ASSERT_NA:\n    case OP_ASSERTBACK_NA:\n    Lframe_type = GF_NOCAPTURE | Fop;\n    for (;;)\n      {\n      group_frame_type = Lframe_type;\n      RMATCH(Fecode + PRIV(OP_lengths)\u00dd*Fecode\u00a8, RM3);\n      if (rrc == MATCH_ACCEPT)\n        {\n        memcpy(Fovector,\n              (char *)assert_accept_frame + offsetof(heapframe, ovector),\n              assert_accept_frame->offset_top * sizeof(PCRE2_SIZE));\n        Foffset_top = assert_accept_frame->offset_top;\n        Fmark = assert_accept_frame->mark;\n        break;\n        }\n      if (rrc != MATCH_NOMATCH && rrc != MATCH_THEN) RRETURN(rrc);\n      Fecode += GET(Fecode, 1);\n      if (*Fecode != OP_ALT) RRETURN(MATCH_NOMATCH);\n      }\n\n    do Fecode += GET(Fecode, 1); while (*Fecode == OP_ALT);\n    Fecode += 1 + LINK_SIZE;\n    break;\n\n#undef Lframe_type\n\n\n    /* ===================================================================== */\n    /* Handle negative assertions. Loop for each non-matching branch as for\n    positive assertions. */\n\n#define Lframe_type  F->temp_32\u00dd0\u00a8\n\n    case OP_ASSERT_NOT:\n    case OP_ASSERTBACK_NOT:\n    Lframe_type  = GF_NOCAPTURE | Fop;\n\n    for (;;)\n      {\n      group_frame_type = Lframe_type;\n      RMATCH(Fecode + PRIV(OP_lengths)\u00dd*Fecode\u00a8, RM4);\n      switch(rrc)\n        {\n        case MATCH_ACCEPT:   /* Assertion matched, therefore it fails. */\n        case MATCH_MATCH:\n        RRETURN (MATCH_NOMATCH);\n\n        case MATCH_NOMATCH:  /* Branch failed, try next if present. */\n        case MATCH_THEN:\n        Fecode += GET(Fecode, 1);\n        if (*Fecode != OP_ALT) goto ASSERT_NOT_FAILED;\n        break;\n\n        case MATCH_COMMIT:   /* Assertion forced to fail, therefore continue. */\n        case MATCH_SKIP:\n        case MATCH_PRUNE:\n        do Fecode += GET(Fecode, 1); while (*Fecode == OP_ALT);\n        goto ASSERT_NOT_FAILED;\n\n        default:             /* Pass back any other return */\n        RRETURN(rrc);\n        }\n      }\n\n    /* None of the branches have matched or there was a backtrack to (*COMMIT),\n    (*SKIP), (*PRUNE), or (*THEN) in the last branch. This is success for a\n    negative assertion, so carry on. */\n\n    ASSERT_NOT_FAILED:\n    Fecode += 1 + LINK_SIZE;\n    break;\n\n#undef Lframe_type\n\n\n    /* ===================================================================== */\n    /* The callout item calls an external function, if one is provided, passing\n    details of the match so far. This is mainly for debugging, though the\n    function is able to force a failure. */\n\n    case OP_CALLOUT:\n    case OP_CALLOUT_STR:\n    rrc = do_callout(F, mb, &length);\n    if (rrc > 0) RRETURN(MATCH_NOMATCH);\n    if (rrc < 0) RRETURN(rrc);\n    Fecode += length;\n    break;\n\n\n    /* ===================================================================== */\n    /* Conditional group: compilation checked that there are no more than two\n    branches. If the condition is false, skipping the first branch takes us\n    past the end of the item if there is only one branch, but that's exactly\n    what we want. */\n\n    case OP_COND:\n    case OP_SCOND:\n\n    /* The variable Flength will be added to Fecode when the condition is\n    false, to get to the second branch. Setting it to the offset to the ALT or\n    KET, then incrementing Fecode achieves this effect. However, if the second\n    branch is non-existent, we must point to the KET so that the end of the\n    group is correctly processed. We now have Fecode pointing to the condition\n    or callout. */\n\n    Flength = GET(Fecode, 1);    /* Offset to the second branch */\n    if (Fecode\u00ddFlength\u00a8 != OP_ALT) Flength -= 1 + LINK_SIZE;\n    Fecode += 1 + LINK_SIZE;     /* From this opcode */\n\n    /* Because of the way auto-callout works during compile, a callout item is\n    inserted between OP_COND and an assertion condition. Such a callout can\n    also be inserted manually. */\n\n    if (*Fecode == OP_CALLOUT || *Fecode == OP_CALLOUT_STR)\n      {\n      rrc = do_callout(F, mb, &length);\n      if (rrc > 0) RRETURN(MATCH_NOMATCH);\n      if (rrc < 0) RRETURN(rrc);\n\n      /* Advance Fecode past the callout, so it now points to the condition. We\n      must adjust Flength so that the value of Fecode+Flength is unchanged. */\n\n      Fecode += length;\n      Flength -= length;\n      }\n\n    /* Test the various possible conditions */\n\n    condition = FALSE;\n    switch(*Fecode)\n      {\n      case OP_RREF:                  /* Group recursion test */\n      if (Fcurrent_recurse != RECURSE_UNSET)\n        {\n        number = GET2(Fecode, 1);\n        condition = (number == RREF_ANY || number == Fcurrent_recurse);\n        }\n      break;\n\n      case OP_DNRREF:       /* Duplicate named group recursion test */\n      if (Fcurrent_recurse != RECURSE_UNSET)\n        {\n        int count = GET2(Fecode, 1 + IMM2_SIZE);\n        PCRE2_SPTR slot = mb->name_table + GET2(Fecode, 1) * mb->name_entry_size;\n        while (count-- > 0)\n          {\n          number = GET2(slot, 0);\n          condition = number == Fcurrent_recurse;\n          if (condition) break;\n          slot += mb->name_entry_size;\n          }\n        }\n      break;\n\n      case OP_CREF:                         /* Numbered group used test */\n      offset = (GET2(Fecode, 1) << 1) - 2;  /* Doubled ref number */\n      condition = offset < Foffset_top && Fovector\u00ddoffset\u00a8 != PCRE2_UNSET;\n      break;\n\n      case OP_DNCREF:      /* Duplicate named group used test */\n        {\n        int count = GET2(Fecode, 1 + IMM2_SIZE);\n        PCRE2_SPTR slot = mb->name_table + GET2(Fecode, 1) * mb->name_entry_size;\n        while (count-- > 0)\n          {\n          offset = (GET2(slot, 0) << 1) - 2;\n          condition = offset < Foffset_top && Fovector\u00ddoffset\u00a8 != PCRE2_UNSET;\n          if (condition) break;\n          slot += mb->name_entry_size;\n          }\n        }\n      break;\n\n      case OP_FALSE:\n      case OP_FAIL:   /* The assertion (?!) becomes OP_FAIL */\n      break;\n\n      case OP_TRUE:\n      condition = TRUE;\n      break;\n\n      /* The condition is an assertion. Run code similar to the assertion code\n      above. */\n\n#define Lpositive      F->temp_32\u00dd0\u00a8\n#define Lstart_branch  F->temp_sptr\u00dd0\u00a8\n\n      default:\n      Lpositive = (*Fecode == OP_ASSERT || *Fecode == OP_ASSERTBACK);\n      Lstart_branch = Fecode;\n\n      for (;;)\n        {\n        group_frame_type = GF_CONDASSERT | *Fecode;\n        RMATCH(Lstart_branch + PRIV(OP_lengths)\u00dd*Lstart_branch\u00a8, RM5);\n\n        switch(rrc)\n          {\n          case MATCH_ACCEPT:  /* Save captures */\n          memcpy(Fovector,\n                (char *)assert_accept_frame + offsetof(heapframe, ovector),\n                assert_accept_frame->offset_top * sizeof(PCRE2_SIZE));\n          Foffset_top = assert_accept_frame->offset_top;\n\n          /* Fall through */\n          /* In the case of a match, the captures have already been put into\n          the current frame. */\n\n          case MATCH_MATCH:\n          condition = Lpositive;   /* TRUE for positive assertion */\n          break;\n\n          /* PCRE doesn't allow the effect of (*THEN) to escape beyond an\n          assertion; it is therefore always treated as NOMATCH. */\n\n          case MATCH_NOMATCH:\n          case MATCH_THEN:\n          Lstart_branch += GET(Lstart_branch, 1);\n          if (*Lstart_branch == OP_ALT) continue;  /* Try next branch */\n          condition = !Lpositive;  /* TRUE for negative assertion */\n          break;\n\n          /* These force no match without checking other branches. */\n\n          case MATCH_COMMIT:\n          case MATCH_SKIP:\n          case MATCH_PRUNE:\n          condition = !Lpositive;\n          break;\n\n          default:\n          RRETURN(rrc);\n          }\n        break;  /* Out of the branch loop */\n        }\n\n      /* If the condition is true, find the end of the assertion so that\n      advancing past it gets us to the start of the first branch. */\n\n      if (condition)\n        {\n        do Fecode += GET(Fecode, 1); while (*Fecode == OP_ALT);\n        }\n      break;  /* End of assertion condition */\n      }\n\n#undef Lpositive\n#undef Lstart_branch\n\n    /* Choose branch according to the condition. */\n\n    Fecode += condition? PRIV(OP_lengths)\u00dd*Fecode\u00a8 : Flength;\n\n    /* If the opcode is OP_SCOND it means we are at a repeated conditional\n    group that might match an empty string. We must therefore descend a level\n    so that the start is remembered for checking. For OP_COND we can just\n    continue at this level. */\n\n    if (Fop == OP_SCOND)\n      {\n      group_frame_type  = GF_NOCAPTURE | Fop;\n      RMATCH(Fecode, RM35);\n      RRETURN(rrc);\n      }\n    break;\n\n\n\n/* ========================================================================= */\n/*                  End of start of parenthesis opcodes                      */\n/* ========================================================================= */\n\n\n    /* ===================================================================== */\n    /* Move the subject pointer back. This occurs only at the start of each\n    branch of a lookbehind assertion. If we are too close to the start to move\n    back, fail. When working with UTF-8 we move back a number of characters,\n    not bytes. */\n\n    case OP_REVERSE:\n    number = GET(Fecode, 1);\n#ifdef SUPPORT_UNICODE\n    if (utf)\n      {\n      while (number-- > 0)\n        {\n        if (Feptr <= mb->check_subject) RRETURN(MATCH_NOMATCH);\n        Feptr--;\n        BACKCHAR(Feptr);\n        }\n      }\n    else\n#endif\n\n    /* No UTF-8 support, or not in UTF-8 mode: count is code unit count */\n\n      {\n      if ((ptrdiff_t)number > Feptr - mb->start_subject) RRETURN(MATCH_NOMATCH);\n      Feptr -= number;\n      }\n\n    /* Save the earliest consulted character, then skip to next opcode */\n\n    if (Feptr < mb->start_used_ptr) mb->start_used_ptr = Feptr;\n    Fecode += 1 + LINK_SIZE;\n    break;\n\n\n    /* ===================================================================== */\n    /* An alternation is the end of a branch; scan along to find the end of the\n    bracketed group. */\n\n    case OP_ALT:\n    do Fecode += GET(Fecode,1); while (*Fecode == OP_ALT);\n    break;\n\n\n    /* ===================================================================== */\n    /* The end of a parenthesized group. For all but OP_BRA and OP_COND, the\n    starting frame was added to the chained frames in order to remember the\n    starting subject position for the group. */\n\n    case OP_KET:\n    case OP_KETRMIN:\n    case OP_KETRMAX:\n    case OP_KETRPOS:\n\n    bracode = Fecode - GET(Fecode, 1);\n\n    /* Point N to the frame at the start of the most recent group.\n    Remember the subject pointer at the start of the group. */\n\n    if (*bracode != OP_BRA && *bracode != OP_COND)\n      {\n      N = (heapframe *)((char *)mb->match_frames + Flast_group_offset);\n      P = (heapframe *)((char *)N - frame_size);\n      Flast_group_offset = P->last_group_offset;\n\n#ifdef DEBUG_SHOW_RMATCH\n      fprintf(stderr, \"++ KET for frame=%d type=%x prev char offset=%lu\\n\",\n        N->rdepth, N->group_frame_type,\n        (char *)P->eptr - (char *)mb->start_subject);\n#endif\n\n      /* If we are at the end of an assertion that is a condition, return a\n      match, discarding any intermediate backtracking points. Copy back the\n      mark setting and the captures into the frame before N so that they are\n      set on return. Doing this for all assertions, both positive and negative,\n      seems to match what Perl does. */\n\n      if (GF_IDMASK(N->group_frame_type) == GF_CONDASSERT)\n        {\n        memcpy((char *)P + offsetof(heapframe, ovector), Fovector,\n          Foffset_top * sizeof(PCRE2_SIZE));\n        P->offset_top = Foffset_top;\n        P->mark = Fmark;\n        Fback_frame = (char *)F - (char *)P;\n        RRETURN(MATCH_MATCH);\n        }\n      }\n    else P = NULL;   /* Indicates starting frame not recorded */\n\n    /* The group was not a conditional assertion. */\n\n    switch (*bracode)\n      {\n      case OP_BRA:    /* No need to do anything for these */\n      case OP_COND:\n      case OP_SCOND:\n      break;\n\n      /* Non-atomic positive assertions are like OP_BRA, except that the\n      subject pointer must be put back to where it was at the start of the\n      assertion. */\n\n      case OP_ASSERT_NA:\n      case OP_ASSERTBACK_NA:\n      if (Feptr > mb->last_used_ptr) mb->last_used_ptr = Feptr;\n      Feptr = P->eptr;\n      break;\n\n      /* Atomic positive assertions are like OP_ONCE, except that in addition\n      the subject pointer must be put back to where it was at the start of the\n      assertion. */\n\n      case OP_ASSERT:\n      case OP_ASSERTBACK:\n      if (Feptr > mb->last_used_ptr) mb->last_used_ptr = Feptr;\n      Feptr = P->eptr;\n      /* Fall through */\n\n      /* For an atomic group, discard internal backtracking points. We must\n      also ensure that any remaining branches within the top-level of the group\n      are not tried. Do this by adjusting the code pointer within the backtrack\n      frame so that it points to the final branch. */\n\n      case OP_ONCE:\n      Fback_frame = ((char *)F - (char *)P);\n      for (;;)\n        {\n        uint32_t y = GET(P->ecode,1);\n        if ((P->ecode)\u00ddy\u00a8 != OP_ALT) break;\n        P->ecode += y;\n        }\n      break;\n\n      /* A matching negative assertion returns MATCH, which is turned into\n      NOMATCH at the assertion level. */\n\n      case OP_ASSERT_NOT:\n      case OP_ASSERTBACK_NOT:\n      RRETURN(MATCH_MATCH);\n\n      /* At the end of a script run, apply the script-checking rules. This code\n      will never by exercised if Unicode support it not compiled, because in\n      that environment script runs cause an error at compile time. */\n\n      case OP_SCRIPT_RUN:\n      if (!PRIV(script_run)(P->eptr, Feptr, utf)) RRETURN(MATCH_NOMATCH);\n      break;\n\n      /* Whole-pattern recursion is coded as a recurse into group 0, so it\n      won't be picked up here. Instead, we catch it when the OP_END is reached.\n      Other recursion is handled here. */\n\n      case OP_CBRA:\n      case OP_CBRAPOS:\n      case OP_SCBRA:\n      case OP_SCBRAPOS:\n      number = GET2(bracode, 1+LINK_SIZE);\n\n      /* Handle a recursively called group. We reinstate the previous set of\n      captures and then carry on after the recursion call. */\n\n      if (Fcurrent_recurse == number)\n        {\n        P = (heapframe *)((char *)N - frame_size);\n        memcpy((char *)F + offsetof(heapframe, ovector), P->ovector,\n          P->offset_top * sizeof(PCRE2_SIZE));\n        Foffset_top = P->offset_top;\n        Fcapture_last = P->capture_last;\n        Fcurrent_recurse = P->current_recurse;\n        Fecode = P->ecode + 1 + LINK_SIZE;\n        continue;  /* With next opcode */\n        }\n\n      /* Deal with actual capturing. */\n\n      offset = (number << 1) - 2;\n      Fcapture_last = number;\n      Fovector\u00ddoffset\u00a8 = P->eptr - mb->start_subject;\n      Fovector\u00ddoffset+1\u00a8 = Feptr - mb->start_subject;\n      if (offset >= Foffset_top) Foffset_top = offset + 2;\n      break;\n      }  /* End actions relating to the starting opcode */\n\n    /* OP_KETRPOS is a possessive repeating ket. Remember the current position,\n    and return the MATCH_KETRPOS. This makes it possible to do the repeats one\n    at a time from the outer level. This must precede the empty string test -\n    in this case that test is done at the outer level. */\n\n    if (*Fecode == OP_KETRPOS)\n      {\n      memcpy((char *)P + offsetof(heapframe, eptr),\n             (char *)F + offsetof(heapframe, eptr),\n             frame_copy_size);\n      RRETURN(MATCH_KETRPOS);\n      }\n\n    /* Handle the different kinds of closing brackets. A non-repeating ket\n    needs no special action, just continuing at this level. This also happens\n    for the repeating kets if the group matched no characters, in order to\n    forcibly break infinite loops. Otherwise, the repeating kets try the rest\n    of the pattern or restart from the preceding bracket, in the appropriate\n    order. */\n\n    if (Fop != OP_KET && (P == NULL || Feptr != P->eptr))\n      {\n      if (Fop == OP_KETRMIN)\n        {\n        RMATCH(Fecode + 1 + LINK_SIZE, RM6);\n        if (rrc != MATCH_NOMATCH) RRETURN(rrc);\n        Fecode -= GET(Fecode, 1);\n        break;   /* End of ket processing */\n        }\n\n      /* Repeat the maximum number of times (KETRMAX) */\n\n      RMATCH(bracode, RM7);\n      if (rrc != MATCH_NOMATCH) RRETURN(rrc);\n      }\n\n    /* Carry on at this level for a non-repeating ket, or after matching an\n    empty string, or after repeating for a maximum number of times. */\n\n    Fecode += 1 + LINK_SIZE;\n    break;\n\n\n    /* ===================================================================== */\n    /* Start and end of line assertions, not multiline mode. */\n\n    case OP_CIRC:   /* Start of line, unless PCRE2_NOTBOL is set. */\n    if (Feptr != mb->start_subject || (mb->moptions & PCRE2_NOTBOL) != 0)\n      RRETURN(MATCH_NOMATCH);\n    Fecode++;\n    break;\n\n    case OP_SOD:    /* Unconditional start of subject */\n    if (Feptr != mb->start_subject) RRETURN(MATCH_NOMATCH);\n    Fecode++;\n    break;\n\n    /* When PCRE2_NOTEOL is unset, assert before the subject end, or a\n    terminating newline unless PCRE2_DOLLAR_ENDONLY is set. */\n\n    case OP_DOLL:\n    if ((mb->moptions & PCRE2_NOTEOL) != 0) RRETURN(MATCH_NOMATCH);\n    if ((mb->poptions & PCRE2_DOLLAR_ENDONLY) == 0) goto ASSERT_NL_OR_EOS;\n\n    /* Fall through */\n    /* Unconditional end of subject assertion (\\z) */\n\n    case OP_EOD:\n    if (Feptr < mb->end_subject) RRETURN(MATCH_NOMATCH);\n    if (mb->partial != 0)\n      {\n      mb->hitend = TRUE;\n      if (mb->partial > 1) return PCRE2_ERROR_PARTIAL;\n      }\n    Fecode++;\n    break;\n\n    /* End of subject or ending \\n assertion (\\Z) */\n\n    case OP_EODN:\n    ASSERT_NL_OR_EOS:\n    if (Feptr < mb->end_subject &&\n        (!IS_NEWLINE(Feptr) || Feptr != mb->end_subject - mb->nllen))\n      {\n      if (mb->partial != 0 &&\n          Feptr + 1 >= mb->end_subject &&\n          NLBLOCK->nltype == NLTYPE_FIXED &&\n          NLBLOCK->nllen == 2 &&\n          UCHAR21TEST(Feptr) == NLBLOCK->nl\u00dd0\u00a8)\n        {\n        mb->hitend = TRUE;\n        if (mb->partial > 1) return PCRE2_ERROR_PARTIAL;\n        }\n      RRETURN(MATCH_NOMATCH);\n      }\n\n    /* Either at end of string or \\n before end. */\n\n    if (mb->partial != 0)\n      {\n      mb->hitend = TRUE;\n      if (mb->partial > 1) return PCRE2_ERROR_PARTIAL;\n      }\n    Fecode++;\n    break;\n\n\n    /* ===================================================================== */\n    /* Start and end of line assertions, multiline mode. */\n\n    /* Start of subject unless notbol, or after any newline except for one at\n    the very end, unless PCRE2_ALT_CIRCUMFLEX is set. */\n\n    case OP_CIRCM:\n    if ((mb->moptions & PCRE2_NOTBOL) != 0 && Feptr == mb->start_subject)\n      RRETURN(MATCH_NOMATCH);\n    if (Feptr != mb->start_subject &&\n        ((Feptr == mb->end_subject &&\n           (mb->poptions & PCRE2_ALT_CIRCUMFLEX) == 0) ||\n         !WAS_NEWLINE(Feptr)))\n      RRETURN(MATCH_NOMATCH);\n    Fecode++;\n    break;\n\n    /* Assert before any newline, or before end of subject unless noteol is\n    set. */\n\n    case OP_DOLLM:\n    if (Feptr < mb->end_subject)\n      {\n      if (!IS_NEWLINE(Feptr))\n        {\n        if (mb->partial != 0 &&\n            Feptr + 1 >= mb->end_subject &&\n            NLBLOCK->nltype == NLTYPE_FIXED &&\n            NLBLOCK->nllen == 2 &&\n            UCHAR21TEST(Feptr) == NLBLOCK->nl\u00dd0\u00a8)\n          {\n          mb->hitend = TRUE;\n          if (mb->partial > 1) return PCRE2_ERROR_PARTIAL;\n          }\n        RRETURN(MATCH_NOMATCH);\n        }\n      }\n    else\n      {\n      if ((mb->moptions & PCRE2_NOTEOL) != 0) RRETURN(MATCH_NOMATCH);\n      SCHECK_PARTIAL();\n      }\n    Fecode++;\n    break;\n\n\n    /* ===================================================================== */\n    /* Start of match assertion */\n\n    case OP_SOM:\n    if (Feptr != mb->start_subject + mb->start_offset) RRETURN(MATCH_NOMATCH);\n    Fecode++;\n    break;\n\n\n    /* ===================================================================== */\n    /* Reset the start of match point */\n\n    case OP_SET_SOM:\n    Fstart_match = Feptr;\n    Fecode++;\n    break;\n\n\n    /* ===================================================================== */\n    /* Word boundary assertions. Find out if the previous and current\n    characters are \"word\" characters. It takes a bit more work in UTF mode.\n    Characters > 255 are assumed to be \"non-word\" characters when PCRE2_UCP is\n    not set. When it is set, use Unicode properties if available, even when not\n    in UTF mode. Remember the earliest and latest consulted characters. */\n\n    case OP_NOT_WORD_BOUNDARY:\n    case OP_WORD_BOUNDARY:\n    if (Feptr == mb->check_subject) prev_is_word = FALSE; else\n      {\n      PCRE2_SPTR lastptr = Feptr - 1;\n#ifdef SUPPORT_UNICODE\n      if (utf)\n        {\n        BACKCHAR(lastptr);\n        GETCHAR(fc, lastptr);\n        }\n      else\n#endif  /* SUPPORT_UNICODE */\n      fc = *lastptr;\n      if (lastptr < mb->start_used_ptr) mb->start_used_ptr = lastptr;\n#ifdef SUPPORT_UNICODE\n      if ((mb->poptions & PCRE2_UCP) != 0)\n        {\n        if (fc == '_') prev_is_word = TRUE; else\n          {\n          int cat = UCD_CATEGORY(fc);\n          prev_is_word = (cat == ucp_L || cat == ucp_N);\n          }\n        }\n      else\n#endif  /* SUPPORT_UNICODE */\n      prev_is_word = CHMAX_255(fc) && (mb->ctypes\u00ddfc\u00a8 & ctype_word) != 0;\n      }\n\n    /* Get status of next character */\n\n    if (Feptr >= mb->end_subject)\n      {\n      SCHECK_PARTIAL();\n      cur_is_word = FALSE;\n      }\n    else\n      {\n      PCRE2_SPTR nextptr = Feptr + 1;\n#ifdef SUPPORT_UNICODE\n      if (utf)\n        {\n        FORWARDCHARTEST(nextptr, mb->end_subject);\n        GETCHAR(fc, Feptr);\n        }\n      else\n#endif  /* SUPPORT_UNICODE */\n      fc = *Feptr;\n      if (nextptr > mb->last_used_ptr) mb->last_used_ptr = nextptr;\n#ifdef SUPPORT_UNICODE\n      if ((mb->poptions & PCRE2_UCP) != 0)\n        {\n        if (fc == '_') cur_is_word = TRUE; else\n          {\n          int cat = UCD_CATEGORY(fc);\n          cur_is_word = (cat == ucp_L || cat == ucp_N);\n          }\n        }\n      else\n#endif  /* SUPPORT_UNICODE */\n      cur_is_word = CHMAX_255(fc) && (mb->ctypes\u00ddfc\u00a8 & ctype_word) != 0;\n      }\n\n    /* Now see if the situation is what we want */\n\n    if ((*Fecode++ == OP_WORD_BOUNDARY)?\n         cur_is_word == prev_is_word : cur_is_word != prev_is_word)\n      RRETURN(MATCH_NOMATCH);\n    break;\n\n\n    /* ===================================================================== */\n    /* Backtracking (*VERB)s, with and without arguments. Note that if the\n    pattern is successfully matched, we do not come back from RMATCH. */\n\n    case OP_MARK:\n    Fmark = mb->nomatch_mark = Fecode + 2;\n    RMATCH(Fecode + PRIV(OP_lengths)\u00dd*Fecode\u00a8 + Fecode\u00dd1\u00a8, RM12);\n\n    /* A return of MATCH_SKIP_ARG means that matching failed at SKIP with an\n    argument, and we must check whether that argument matches this MARK's\n    argument. It is passed back in mb->verb_skip_ptr. If it does match, we\n    return MATCH_SKIP with mb->verb_skip_ptr now pointing to the subject\n    position that corresponds to this mark. Otherwise, pass back the return\n    code unaltered. */\n\n    if (rrc == MATCH_SKIP_ARG &&\n             PRIV(strcmp)(Fecode + 2, mb->verb_skip_ptr) == 0)\n      {\n      mb->verb_skip_ptr = Feptr;   /* Pass back current position */\n      RRETURN(MATCH_SKIP);\n      }\n    RRETURN(rrc);\n\n    case OP_FAIL:\n    RRETURN(MATCH_NOMATCH);\n\n    /* Record the current recursing group number in mb->verb_current_recurse\n    when a backtracking return such as MATCH_COMMIT is given. This enables the\n    recurse processing to catch verbs from within the recursion. */\n\n    case OP_COMMIT:\n    RMATCH(Fecode + PRIV(OP_lengths)\u00dd*Fecode\u00a8, RM13);\n    if (rrc != MATCH_NOMATCH) RRETURN(rrc);\n    mb->verb_current_recurse = Fcurrent_recurse;\n    RRETURN(MATCH_COMMIT);\n\n    case OP_COMMIT_ARG:\n    Fmark = mb->nomatch_mark = Fecode + 2;\n    RMATCH(Fecode + PRIV(OP_lengths)\u00dd*Fecode\u00a8 + Fecode\u00dd1\u00a8, RM36);\n    if (rrc != MATCH_NOMATCH) RRETURN(rrc);\n    mb->verb_current_recurse = Fcurrent_recurse;\n    RRETURN(MATCH_COMMIT);\n\n    case OP_PRUNE:\n    RMATCH(Fecode + PRIV(OP_lengths)\u00dd*Fecode\u00a8, RM14);\n    if (rrc != MATCH_NOMATCH) RRETURN(rrc);\n    mb->verb_current_recurse = Fcurrent_recurse;\n    RRETURN(MATCH_PRUNE);\n\n    case OP_PRUNE_ARG:\n    Fmark = mb->nomatch_mark = Fecode + 2;\n    RMATCH(Fecode + PRIV(OP_lengths)\u00dd*Fecode\u00a8 + Fecode\u00dd1\u00a8, RM15);\n    if (rrc != MATCH_NOMATCH) RRETURN(rrc);\n    mb->verb_current_recurse = Fcurrent_recurse;\n    RRETURN(MATCH_PRUNE);\n\n    case OP_SKIP:\n    RMATCH(Fecode + PRIV(OP_lengths)\u00dd*Fecode\u00a8, RM16);\n    if (rrc != MATCH_NOMATCH) RRETURN(rrc);\n    mb->verb_skip_ptr = Feptr;   /* Pass back current position */\n    mb->verb_current_recurse = Fcurrent_recurse;\n    RRETURN(MATCH_SKIP);\n\n    /* Note that, for Perl compatibility, SKIP with an argument does NOT set\n    nomatch_mark. When a pattern match ends with a SKIP_ARG for which there was\n    not a matching mark, we have to re-run the match, ignoring the SKIP_ARG\n    that failed and any that precede it (either they also failed, or were not\n    triggered). To do this, we maintain a count of executed SKIP_ARGs. If a\n    SKIP_ARG gets to top level, the match is re-run with mb->ignore_skip_arg\n    set to the count of the one that failed. */\n\n    case OP_SKIP_ARG:\n    mb->skip_arg_count++;\n    if (mb->skip_arg_count <= mb->ignore_skip_arg)\n      {\n      Fecode += PRIV(OP_lengths)\u00dd*Fecode\u00a8 + Fecode\u00dd1\u00a8;\n      break;\n      }\n    RMATCH(Fecode + PRIV(OP_lengths)\u00dd*Fecode\u00a8 + Fecode\u00dd1\u00a8, RM17);\n    if (rrc != MATCH_NOMATCH) RRETURN(rrc);\n\n    /* Pass back the current skip name and return the special MATCH_SKIP_ARG\n    return code. This will either be caught by a matching MARK, or get to the\n    top, where it causes a rematch with mb->ignore_skip_arg set to the value of\n    mb->skip_arg_count. */\n\n    mb->verb_skip_ptr = Fecode + 2;\n    mb->verb_current_recurse = Fcurrent_recurse;\n    RRETURN(MATCH_SKIP_ARG);\n\n    /* For THEN (and THEN_ARG) we pass back the address of the opcode, so that\n    the branch in which it occurs can be determined. */\n\n    case OP_THEN:\n    RMATCH(Fecode + PRIV(OP_lengths)\u00dd*Fecode\u00a8, RM18);\n    if (rrc != MATCH_NOMATCH) RRETURN(rrc);\n    mb->verb_ecode_ptr = Fecode;\n    mb->verb_current_recurse = Fcurrent_recurse;\n    RRETURN(MATCH_THEN);\n\n    case OP_THEN_ARG:\n    Fmark = mb->nomatch_mark = Fecode + 2;\n    RMATCH(Fecode + PRIV(OP_lengths)\u00dd*Fecode\u00a8 + Fecode\u00dd1\u00a8, RM19);\n    if (rrc != MATCH_NOMATCH) RRETURN(rrc);\n    mb->verb_ecode_ptr = Fecode;\n    mb->verb_current_recurse = Fcurrent_recurse;\n    RRETURN(MATCH_THEN);\n\n\n    /* ===================================================================== */\n    /* There's been some horrible disaster. Arrival here can only mean there is\n    something seriously wrong in the code above or the OP_xxx definitions. */\n\n    default:\n    return PCRE2_ERROR_INTERNAL;\n    }\n\n  /* Do not insert any code in here without much thought; it is assumed\n  that \"continue\" in the code above comes out to here to repeat the main\n  loop. */\n\n  }  /* End of main loop */\n/* Control never reaches here */\n\n\n/* ========================================================================= */\n/* The RRETURN() macro jumps here. The number that is saved in Freturn_id\nindicates which label we actually want to return to. The value in Frdepth is\nthe index number of the frame in the vector. The return value has been placed\nin rrc. */\n\n#define LBL(val) case val: goto L_RM##val;\n\nRETURN_SWITCH:\nif (Feptr > mb->last_used_ptr) mb->last_used_ptr = Feptr;\nif (Frdepth == 0) return rrc;                     /* Exit from the top level */\nF = (heapframe *)((char *)F - Fback_frame);       /* Backtrack */\nmb->cb->callout_flags |= PCRE2_CALLOUT_BACKTRACK; /* Note for callouts */\n\n#ifdef DEBUG_SHOW_RMATCH\nfprintf(stderr, \"++ RETURN %d to %d\\n\", rrc, Freturn_id);\n#endif\n\nswitch (Freturn_id)\n  {\n  LBL( 1) LBL( 2) LBL( 3) LBL( 4) LBL( 5) LBL( 6) LBL( 7) LBL( 8)\n  LBL( 9) LBL(10) LBL(11) LBL(12) LBL(13) LBL(14) LBL(15) LBL(16)\n  LBL(17) LBL(18) LBL(19) LBL(20) LBL(21) LBL(22) LBL(23) LBL(24)\n  LBL(25) LBL(26) LBL(27) LBL(28) LBL(29) LBL(30) LBL(31) LBL(32)\n  LBL(33) LBL(34) LBL(35) LBL(36)\n\n#ifdef SUPPORT_WIDE_CHARS\n  LBL(100) LBL(101)\n#endif\n\n#ifdef SUPPORT_UNICODE\n  LBL(200) LBL(201) LBL(202) LBL(203) LBL(204) LBL(205) LBL(206)\n  LBL(207) LBL(208) LBL(209) LBL(210) LBL(211) LBL(212) LBL(213)\n  LBL(214) LBL(215) LBL(216) LBL(217) LBL(218) LBL(219) LBL(220)\n  LBL(221) LBL(222)\n#endif\n\n  default:\n  return PCRE2_ERROR_INTERNAL;\n  }\n#undef LBL\n}\n\n\n/*************************************************\n*           Match a Regular Expression           *\n*************************************************/\n\n/* This function applies a compiled pattern to a subject string and picks out\nportions of the string if it matches. Two elements in the vector are set for\neach substring: the offsets to the start and end of the substring.\n\nArguments:\n  code            points to the compiled expression\n  subject         points to the subject string\n  length          length of subject string (may contain binary zeros)\n  start_offset    where to start in the subject string\n  options         option bits\n  match_data      points to a match_data block\n  mcontext        points a PCRE2 context\n\nReturns:          > 0 => success; value is the number of ovector pairs filled\n                  = 0 => success, but ovector is not big enough\n                  = -1 => failed to match (PCRE2_ERROR_NOMATCH)\n                  = -2 => partial match (PCRE2_ERROR_PARTIAL)\n                  < -2 => some kind of unexpected problem\n*/\n\nPCRE2_EXP_DEFN int PCRE2_CALL_CONVENTION\npcre2_match(const pcre2_code *code, PCRE2_SPTR subject, PCRE2_SIZE length,\n  PCRE2_SIZE start_offset, uint32_t options, pcre2_match_data *match_data,\n  pcre2_match_context *mcontext)\n{\nint rc;\nint was_zero_terminated = 0;\nconst uint8_t *start_bits = NULL;\nconst pcre2_real_code *re = (const pcre2_real_code *)code;\n\nBOOL anchored;\nBOOL firstline;\nBOOL has_first_cu = FALSE;\nBOOL has_req_cu = FALSE;\nBOOL startline;\n\n#if PCRE2_CODE_UNIT_WIDTH == 8\nBOOL memchr_not_found_first_cu = FALSE;\nBOOL memchr_not_found_first_cu2 = FALSE;\n#endif\n\nPCRE2_UCHAR first_cu = 0;\nPCRE2_UCHAR first_cu2 = 0;\nPCRE2_UCHAR req_cu = 0;\nPCRE2_UCHAR req_cu2 = 0;\n\nPCRE2_SPTR bumpalong_limit;\nPCRE2_SPTR end_subject;\nPCRE2_SPTR true_end_subject;\nPCRE2_SPTR start_match = subject + start_offset;\nPCRE2_SPTR req_cu_ptr = start_match - 1;\nPCRE2_SPTR start_partial;\nPCRE2_SPTR match_partial;\n\n#ifdef SUPPORT_JIT\nBOOL use_jit;\n#endif\n\n/* This flag is needed even when Unicode is not supported for convenience\n(it is used by the IS_NEWLINE macro). */\n\nBOOL utf = FALSE;\n\n#ifdef SUPPORT_UNICODE\nBOOL ucp = FALSE;\nBOOL allow_invalid;\nuint32_t fragment_options = 0;\n#ifdef SUPPORT_JIT\nBOOL jit_checked_utf = FALSE;\n#endif\n#endif  /* SUPPORT_UNICODE */\n\nPCRE2_SIZE frame_size;\n\n/* We need to have mb as a pointer to a match block, because the IS_NEWLINE\nmacro is used below, and it expects NLBLOCK to be defined as a pointer. */\n\npcre2_callout_block cb;\nmatch_block actual_match_block;\nmatch_block *mb = &actual_match_block;\n\n/* Allocate an initial vector of backtracking frames on the stack. If this\nproves to be too small, it is replaced by a larger one on the heap. To get a\nvector of the size required that is aligned for pointers, allocate it as a\nvector of pointers. */\n\nPCRE2_SPTR stack_frames_vector\u00ddSTART_FRAMES_SIZE/sizeof(PCRE2_SPTR)\u00a8\n    PCRE2_KEEP_UNINITIALIZED;\nmb->stack_frames = (heapframe *)stack_frames_vector;\n\n/* A length equal to PCRE2_ZERO_TERMINATED implies a zero-terminated\nsubject string. */\n\nif (length == PCRE2_ZERO_TERMINATED)\n  {\n  length = PRIV(strlen)(subject);\n  was_zero_terminated = 1;\n  }\ntrue_end_subject = end_subject = subject + length;\n\n/* Plausibility checks */\n\nif ((options & ~PUBLIC_MATCH_OPTIONS) != 0) return PCRE2_ERROR_BADOPTION;\nif (code == NULL || subject == NULL || match_data == NULL)\n  return PCRE2_ERROR_NULL;\nif (start_offset > length) return PCRE2_ERROR_BADOFFSET;\n\n/* Check that the first field in the block is the magic number. */\n\nif (re->magic_number != MAGIC_NUMBER) return PCRE2_ERROR_BADMAGIC;\n\n/* Check the code unit width. */\n\nif ((re->flags & PCRE2_MODE_MASK) != PCRE2_CODE_UNIT_WIDTH/8)\n  return PCRE2_ERROR_BADMODE;\n\n/* PCRE2_NOTEMPTY and PCRE2_NOTEMPTY_ATSTART are match-time flags in the\noptions variable for this function. Users of PCRE2 who are not calling the\nfunction directly would like to have a way of setting these flags, in the same\nway that they can set pcre2_compile() flags like PCRE2_NO_AUTOPOSSESS with\nconstructions like (*NO_AUTOPOSSESS). To enable this, (*NOTEMPTY) and\n(*NOTEMPTY_ATSTART) set bits in the pattern's \"flag\" function which we now\ntransfer to the options for this function. The bits are guaranteed to be\nadjacent, but do not have the same values. This bit of Boolean trickery assumes\nthat the match-time bits are not more significant than the flag bits. If by\naccident this is not the case, a compile-time division by zero error will\noccur. */\n\n#define FF (PCRE2_NOTEMPTY_SET|PCRE2_NE_ATST_SET)\n#define OO (PCRE2_NOTEMPTY|PCRE2_NOTEMPTY_ATSTART)\noptions |= (re->flags & FF) / ((FF & (~FF+1)) / (OO & (~OO+1)));\n#undef FF\n#undef OO\n\n/* If the pattern was successfully studied with JIT support, we will run the\nJIT executable instead of the rest of this function. Most options must be set\nat compile time for the JIT code to be usable. */\n\n#ifdef SUPPORT_JIT\nuse_jit = (re->executable_jit != NULL &&\n          (options & ~PUBLIC_JIT_MATCH_OPTIONS) == 0);\n#endif\n\n/* Initialize UTF/UCP parameters. */\n\n#ifdef SUPPORT_UNICODE\nutf = (re->overall_options & PCRE2_UTF) != 0;\nallow_invalid = (re->overall_options & PCRE2_MATCH_INVALID_UTF) != 0;\nucp = (re->overall_options & PCRE2_UCP) != 0;\n#endif  /* SUPPORT_UNICODE */\n\n/* Convert the partial matching flags into an integer. */\n\nmb->partial = ((options & PCRE2_PARTIAL_HARD) != 0)? 2 :\n              ((options & PCRE2_PARTIAL_SOFT) != 0)? 1 : 0;\n\n/* Partial matching and PCRE2_ENDANCHORED are currently not allowed at the same\ntime. */\n\nif (mb->partial != 0 &&\n   ((re->overall_options | options) & PCRE2_ENDANCHORED) != 0)\n  return PCRE2_ERROR_BADOPTION;\n\n/* It is an error to set an offset limit without setting the flag at compile\ntime. */\n\nif (mcontext != NULL && mcontext->offset_limit != PCRE2_UNSET &&\n     (re->overall_options & PCRE2_USE_OFFSET_LIMIT) == 0)\n  return PCRE2_ERROR_BADOFFSETLIMIT;\n\n/* If the match data block was previously used with PCRE2_COPY_MATCHED_SUBJECT,\nfree the memory that was obtained. Set the field to NULL for no match cases. */\n\nif ((match_data->flags & PCRE2_MD_COPIED_SUBJECT) != 0)\n  {\n  match_data->memctl.free((void *)match_data->subject,\n    match_data->memctl.memory_data);\n  match_data->flags &= ~PCRE2_MD_COPIED_SUBJECT;\n  }\nmatch_data->subject = NULL;\n\n/* Zero the error offset in case the first code unit is invalid UTF. */\n\nmatch_data->startchar = 0;\n\n\n/* ============================= JIT matching ============================== */\n\n/* Prepare for JIT matching. Check a UTF string for validity unless no check is\nrequested or invalid UTF can be handled. We check only the portion of the\nsubject that might be be inspected during matching - from the offset minus the\nmaximum lookbehind to the given length. This saves time when a small part of a\nlarge subject is being matched by the use of a starting offset. Note that the\nmaximum lookbehind is a number of characters, not code units. */\n\n#ifdef SUPPORT_JIT\nif (use_jit)\n  {\n#ifdef SUPPORT_UNICODE\n  if (utf && (options & PCRE2_NO_UTF_CHECK) == 0 && !allow_invalid)\n    {\n#if PCRE2_CODE_UNIT_WIDTH != 32\n    unsigned int i;\n#endif\n\n    /* For 8-bit and 16-bit UTF, check that the first code unit is a valid\n    character start. */\n\n#if PCRE2_CODE_UNIT_WIDTH != 32\n    if (start_match < end_subject && NOT_FIRSTCU(*start_match))\n      {\n      if (start_offset > 0) return PCRE2_ERROR_BADUTFOFFSET;\n#if PCRE2_CODE_UNIT_WIDTH == 8\n      return PCRE2_ERROR_UTF8_ERR20;  /* Isolated 0x80 byte */\n#else\n      return PCRE2_ERROR_UTF16_ERR3;  /* Isolated low surrogate */\n#endif\n      }\n#endif  /* WIDTH != 32 */\n\n    /* Move back by the maximum lookbehind, just in case it happens at the very\n    start of matching. */\n\n#if PCRE2_CODE_UNIT_WIDTH != 32\n    for (i = re->max_lookbehind; i > 0 && start_match > subject; i--)\n      {\n      start_match--;\n      while (start_match > subject &&\n#if PCRE2_CODE_UNIT_WIDTH == 8\n      (*start_match & 0xc0) == 0x80)\n#else  /* 16-bit */\n      (*start_match & 0xfc00) == 0xdc00)\n#endif\n        start_match--;\n      }\n#else  /* PCRE2_CODE_UNIT_WIDTH != 32 */\n\n    /* In the 32-bit library, one code unit equals one character. However,\n    we cannot just subtract the lookbehind and then compare pointers, because\n    a very large lookbehind could create an invalid pointer. */\n\n    if (start_offset >= re->max_lookbehind)\n      start_match -= re->max_lookbehind;\n    else\n      start_match = subject;\n#endif  /* PCRE2_CODE_UNIT_WIDTH != 32 */\n\n    /* Validate the relevant portion of the subject. Adjust the offset of an\n    invalid code point to be an absolute offset in the whole string. */\n\n    match_data->rc = PRIV(valid_utf)(start_match,\n      length - (start_match - subject), &(match_data->startchar));\n    if (match_data->rc != 0)\n      {\n      match_data->startchar += start_match - subject;\n      return match_data->rc;\n      }\n    jit_checked_utf = TRUE;\n    }\n#endif  /* SUPPORT_UNICODE */\n\n  /* If JIT returns BADOPTION, which means that the selected complete or\n  partial matching mode was not compiled, fall through to the interpreter. */\n\n  rc = pcre2_jit_match(code, subject, length, start_offset, options,\n    match_data, mcontext);\n  if (rc != PCRE2_ERROR_JIT_BADOPTION)\n    {\n    if (rc >= 0 && (options & PCRE2_COPY_MATCHED_SUBJECT) != 0)\n      {\n      length = CU2BYTES(length + was_zero_terminated);\n      match_data->subject = match_data->memctl.malloc(length,\n        match_data->memctl.memory_data);\n      if (match_data->subject == NULL) return PCRE2_ERROR_NOMEMORY;\n      memcpy((void *)match_data->subject, subject, length);\n      match_data->flags |= PCRE2_MD_COPIED_SUBJECT;\n      }\n    return rc;\n    }\n  }\n#endif  /* SUPPORT_JIT */\n\n/* ========================= End of JIT matching ========================== */\n\n\n/* Proceed with non-JIT matching. The default is to allow lookbehinds to the\nstart of the subject. A UTF check when there is a non-zero offset may change\nthis. */\n\nmb->check_subject = subject;\n\n/* If a UTF subject string was not checked for validity in the JIT code above,\ncheck it here, and handle support for invalid UTF strings. The check above\nhappens only when invalid UTF is not supported and PCRE2_NO_CHECK_UTF is unset.\nIf we get here in those circumstances, it means the subject string is valid,\nbut for some reason JIT matching was not successful. There is no need to check\nthe subject again.\n\nWe check only the portion of the subject that might be be inspected during\nmatching - from the offset minus the maximum lookbehind to the given length.\nThis saves time when a small part of a large subject is being matched by the\nuse of a starting offset. Note that the maximum lookbehind is a number of\ncharacters, not code units.\n\nNote also that support for invalid UTF forces a check, overriding the setting\nof PCRE2_NO_CHECK_UTF. */\n\n#ifdef SUPPORT_UNICODE\nif (utf &&\n#ifdef SUPPORT_JIT\n    !jit_checked_utf &&\n#endif\n    ((options & PCRE2_NO_UTF_CHECK) == 0 || allow_invalid))\n  {\n#if PCRE2_CODE_UNIT_WIDTH != 32\n  BOOL skipped_bad_start = FALSE;\n#endif\n\n  /* For 8-bit and 16-bit UTF, check that the first code unit is a valid\n  character start. If we are handling invalid UTF, just skip over such code\n  units. Otherwise, give an appropriate error. */\n\n#if PCRE2_CODE_UNIT_WIDTH != 32\n  if (allow_invalid)\n    {\n    while (start_match < end_subject && NOT_FIRSTCU(*start_match))\n      {\n      start_match++;\n      skipped_bad_start = TRUE;\n      }\n    }\n  else if (start_match < end_subject && NOT_FIRSTCU(*start_match))\n    {\n    if (start_offset > 0) return PCRE2_ERROR_BADUTFOFFSET;\n#if PCRE2_CODE_UNIT_WIDTH == 8\n    return PCRE2_ERROR_UTF8_ERR20;  /* Isolated 0x80 byte */\n#else\n    return PCRE2_ERROR_UTF16_ERR3;  /* Isolated low surrogate */\n#endif\n    }\n#endif  /* WIDTH != 32 */\n\n  /* The mb->check_subject field points to the start of UTF checking;\n  lookbehinds can go back no further than this. */\n\n  mb->check_subject = start_match;\n\n  /* Move back by the maximum lookbehind, just in case it happens at the very\n  start of matching, but don't do this if we skipped bad 8-bit or 16-bit code\n  units above. */\n\n#if PCRE2_CODE_UNIT_WIDTH != 32\n  if (!skipped_bad_start)\n    {\n    unsigned int i;\n    for (i = re->max_lookbehind; i > 0 && mb->check_subject > subject; i--)\n      {\n      mb->check_subject--;\n      while (mb->check_subject > subject &&\n#if PCRE2_CODE_UNIT_WIDTH == 8\n      (*mb->check_subject & 0xc0) == 0x80)\n#else  /* 16-bit */\n      (*mb->check_subject & 0xfc00) == 0xdc00)\n#endif\n        mb->check_subject--;\n      }\n    }\n#else  /* PCRE2_CODE_UNIT_WIDTH != 32 */\n\n  /* In the 32-bit library, one code unit equals one character. However,\n  we cannot just subtract the lookbehind and then compare pointers, because\n  a very large lookbehind could create an invalid pointer. */\n\n  if (start_offset >= re->max_lookbehind)\n    mb->check_subject -= re->max_lookbehind;\n  else\n    mb->check_subject = subject;\n#endif  /* PCRE2_CODE_UNIT_WIDTH != 32 */\n\n  /* Validate the relevant portion of the subject. There's a loop in case we\n  encounter bad UTF in the characters preceding start_match which we are\n  scanning because of a lookbehind. */\n\n  for (;;)\n    {\n    match_data->rc = PRIV(valid_utf)(mb->check_subject,\n      length - (mb->check_subject - subject), &(match_data->startchar));\n\n    if (match_data->rc == 0) break;   /* Valid UTF string */\n\n    /* Invalid UTF string. Adjust the offset to be an absolute offset in the\n    whole string. If we are handling invalid UTF strings, set end_subject to\n    stop before the bad code unit, and set the options to \"not end of line\".\n    Otherwise return the error. */\n\n    match_data->startchar += mb->check_subject - subject;\n    if (!allow_invalid || match_data->rc > 0) return match_data->rc;\n    end_subject = subject + match_data->startchar;\n\n    /* If the end precedes start_match, it means there is invalid UTF in the\n    extra code units we reversed over because of a lookbehind. Advance past the\n    first bad code unit, and then skip invalid character starting code units in\n    8-bit and 16-bit modes, and try again. */\n\n    if (end_subject < start_match)\n      {\n      mb->check_subject = end_subject + 1;\n#if PCRE2_CODE_UNIT_WIDTH != 32\n      while (mb->check_subject < start_match && NOT_FIRSTCU(*mb->check_subject))\n        mb->check_subject++;\n#endif\n      }\n\n    /* Otherwise, set the not end of line option, and do the match. */\n\n    else\n      {\n      fragment_options = PCRE2_NOTEOL;\n      break;\n      }\n    }\n  }\n#endif  /* SUPPORT_UNICODE */\n\n/* A NULL match context means \"use a default context\", but we take the memory\ncontrol functions from the pattern. */\n\nif (mcontext == NULL)\n  {\n  mcontext = (pcre2_match_context *)(&PRIV(default_match_context));\n  mb->memctl = re->memctl;\n  }\nelse mb->memctl = mcontext->memctl;\n\nanchored = ((re->overall_options | options) & PCRE2_ANCHORED) != 0;\nfirstline = (re->overall_options & PCRE2_FIRSTLINE) != 0;\nstartline = (re->flags & PCRE2_STARTLINE) != 0;\nbumpalong_limit = (mcontext->offset_limit == PCRE2_UNSET)?\n  true_end_subject : subject + mcontext->offset_limit;\n\n/* Initialize and set up the fixed fields in the callout block, with a pointer\nin the match block. */\n\nmb->cb = &cb;\ncb.version = 2;\ncb.subject = subject;\ncb.subject_length = (PCRE2_SIZE)(end_subject - subject);\ncb.callout_flags = 0;\n\n/* Fill in the remaining fields in the match block, except for moptions, which\ngets set later. */\n\nmb->callout = mcontext->callout;\nmb->callout_data = mcontext->callout_data;\n\nmb->start_subject = subject;\nmb->start_offset = start_offset;\nmb->end_subject = end_subject;\nmb->hasthen = (re->flags & PCRE2_HASTHEN) != 0;\nmb->allowemptypartial = (re->max_lookbehind > 0) ||\n    (re->flags & PCRE2_MATCH_EMPTY) != 0;\nmb->poptions = re->overall_options;          /* Pattern options */\nmb->ignore_skip_arg = 0;\nmb->mark = mb->nomatch_mark = NULL;          /* In case never set */\n\n/* The name table is needed for finding all the numbers associated with a\ngiven name, for condition testing. The code follows the name table. */\n\nmb->name_table = (PCRE2_UCHAR *)((uint8_t *)re + sizeof(pcre2_real_code));\nmb->name_count = re->name_count;\nmb->name_entry_size = re->name_entry_size;\nmb->start_code = mb->name_table + re->name_count * re->name_entry_size;\n\n/* Process the \\R and newline settings. */\n\nmb->bsr_convention = re->bsr_convention;\nmb->nltype = NLTYPE_FIXED;\nswitch(re->newline_convention)\n  {\n  case PCRE2_NEWLINE_CR:\n  mb->nllen = 1;\n  mb->nl\u00dd0\u00a8 = CHAR_CR;\n  break;\n\n  case PCRE2_NEWLINE_LF:\n  mb->nllen = 1;\n  mb->nl\u00dd0\u00a8 = CHAR_NL;\n  break;\n\n  case PCRE2_NEWLINE_NUL:\n  mb->nllen = 1;\n  mb->nl\u00dd0\u00a8 = CHAR_NUL;\n  break;\n\n  case PCRE2_NEWLINE_CRLF:\n  mb->nllen = 2;\n  mb->nl\u00dd0\u00a8 = CHAR_CR;\n  mb->nl\u00dd1\u00a8 = CHAR_NL;\n  break;\n\n  case PCRE2_NEWLINE_ANY:\n  mb->nltype = NLTYPE_ANY;\n  break;\n\n  case PCRE2_NEWLINE_ANYCRLF:\n  mb->nltype = NLTYPE_ANYCRLF;\n  break;\n\n  default: return PCRE2_ERROR_INTERNAL;\n  }\n\n/* The backtracking frames have fixed data at the front, and a PCRE2_SIZE\nvector at the end, whose size depends on the number of capturing parentheses in\nthe pattern. It is not used at all if there are no capturing parentheses.\n\n  frame_size             is the total size of each frame\n  mb->frame_vector_size  is the total usable size of the vector (rounded down\n                           to a whole number of frames)\n\nThe last of these is changed within the match() function if the frame vector\nhas to be expanded. We therefore put it into the match block so that it is\ncorrect when calling match() more than once for non-anchored patterns. */\n\nframe_size = offsetof(heapframe, ovector) +\n  re->top_bracket * 2 * sizeof(PCRE2_SIZE);\n\n/* Limits set in the pattern override the match context only if they are\nsmaller. */\n\nmb->heap_limit = (mcontext->heap_limit < re->limit_heap)?\n  mcontext->heap_limit : re->limit_heap;\n\nmb->match_limit = (mcontext->match_limit < re->limit_match)?\n  mcontext->match_limit : re->limit_match;\n\nmb->match_limit_depth = (mcontext->depth_limit < re->limit_depth)?\n  mcontext->depth_limit : re->limit_depth;\n\n/* If a pattern has very many capturing parentheses, the frame size may be very\nlarge. Ensure that there are at least 10 available frames by getting an initial\nvector on the heap if necessary, except when the heap limit prevents this. Get\nfewer if possible. (The heap limit is in kibibytes.) */\n\nif (frame_size <= START_FRAMES_SIZE/10)\n  {\n  mb->match_frames = mb->stack_frames;   /* Initial frame vector on the stack */\n  mb->frame_vector_size = ((START_FRAMES_SIZE/frame_size) * frame_size);\n  }\nelse\n  {\n  mb->frame_vector_size = frame_size * 10;\n  if ((mb->frame_vector_size / 1024) > mb->heap_limit)\n    {\n    if (frame_size > mb->heap_limit * 1024) return PCRE2_ERROR_HEAPLIMIT;\n    mb->frame_vector_size = ((mb->heap_limit * 1024)/frame_size) * frame_size;\n    }\n  mb->match_frames = mb->memctl.malloc(mb->frame_vector_size,\n    mb->memctl.memory_data);\n  if (mb->match_frames == NULL) return PCRE2_ERROR_NOMEMORY;\n  }\n\nmb->match_frames_top =\n  (heapframe *)((char *)mb->match_frames + mb->frame_vector_size);\n\n/* Write to the ovector within the first frame to mark every capture unset and\nto avoid uninitialized memory read errors when it is copied to a new frame. */\n\nmemset((char *)(mb->match_frames) + offsetof(heapframe, ovector), 0xff,\n  re->top_bracket * 2 * sizeof(PCRE2_SIZE));\n\n/* Pointers to the individual character tables */\n\nmb->lcc = re->tables + lcc_offset;\nmb->fcc = re->tables + fcc_offset;\nmb->ctypes = re->tables + ctypes_offset;\n\n/* Set up the first code unit to match, if available. If there's no first code\nunit there may be a bitmap of possible first characters. */\n\nif ((re->flags & PCRE2_FIRSTSET) != 0)\n  {\n  has_first_cu = TRUE;\n  first_cu = first_cu2 = (PCRE2_UCHAR)(re->first_codeunit);\n  if ((re->flags & PCRE2_FIRSTCASELESS) != 0)\n    {\n    first_cu2 = TABLE_GET(first_cu, mb->fcc, first_cu);\n#ifdef SUPPORT_UNICODE\n#if PCRE2_CODE_UNIT_WIDTH == 8\n    if (first_cu > 127 && ucp && !utf) first_cu2 = UCD_OTHERCASE(first_cu);\n#else\n    if (first_cu > 127 && (utf || ucp)) first_cu2 = UCD_OTHERCASE(first_cu);\n#endif\n#endif  /* SUPPORT_UNICODE */\n    }\n  }\nelse\n  if (!startline && (re->flags & PCRE2_FIRSTMAPSET) != 0)\n    start_bits = re->start_bitmap;\n\n/* There may also be a \"last known required character\" set. */\n\nif ((re->flags & PCRE2_LASTSET) != 0)\n  {\n  has_req_cu = TRUE;\n  req_cu = req_cu2 = (PCRE2_UCHAR)(re->last_codeunit);\n  if ((re->flags & PCRE2_LASTCASELESS) != 0)\n    {\n    req_cu2 = TABLE_GET(req_cu, mb->fcc, req_cu);\n#ifdef SUPPORT_UNICODE\n#if PCRE2_CODE_UNIT_WIDTH == 8\n    if (req_cu > 127 && ucp && !utf) req_cu2 = UCD_OTHERCASE(req_cu);\n#else\n    if (req_cu > 127 && (utf || ucp)) req_cu2 = UCD_OTHERCASE(req_cu);\n#endif\n#endif  /* SUPPORT_UNICODE */\n    }\n  }\n\n\n/* ==========================================================================*/\n\n/* Loop for handling unanchored repeated matching attempts; for anchored regexs\nthe loop runs just once. */\n\n#ifdef SUPPORT_UNICODE\nFRAGMENT_RESTART:\n#endif\n\nstart_partial = match_partial = NULL;\nmb->hitend = FALSE;\n\nfor(;;)\n  {\n  PCRE2_SPTR new_start_match;\n\n  /* ----------------- Start of match optimizations ---------------- */\n\n  /* There are some optimizations that avoid running the match if a known\n  starting point is not found, or if a known later code unit is not present.\n  However, there is an option (settable at compile time) that disables these,\n  for testing and for ensuring that all callouts do actually occur. */\n\n  if ((re->overall_options & PCRE2_NO_START_OPTIMIZE) == 0)\n    {\n    /* If firstline is TRUE, the start of the match is constrained to the first\n    line of a multiline string. That is, the match must be before or at the\n    first newline following the start of matching. Temporarily adjust\n    end_subject so that we stop the scans for a first code unit at a newline.\n    If the match fails at the newline, later code breaks the loop. */\n\n    if (firstline)\n      {\n      PCRE2_SPTR t = start_match;\n#ifdef SUPPORT_UNICODE\n      if (utf)\n        {\n        while (t < end_subject && !IS_NEWLINE(t))\n          {\n          t++;\n          ACROSSCHAR(t < end_subject, t, t++);\n          }\n        }\n      else\n#endif\n      while (t < end_subject && !IS_NEWLINE(t)) t++;\n      end_subject = t;\n      }\n\n    /* Anchored: check the first code unit if one is recorded. This may seem\n    pointless but it can help in detecting a no match case without scanning for\n    the required code unit. */\n\n    if (anchored)\n      {\n      if (has_first_cu || start_bits != NULL)\n        {\n        BOOL ok = start_match < end_subject;\n        if (ok)\n          {\n          PCRE2_UCHAR c = UCHAR21TEST(start_match);\n          ok = has_first_cu && (c == first_cu || c == first_cu2);\n          if (!ok && start_bits != NULL)\n            {\n#if PCRE2_CODE_UNIT_WIDTH != 8\n            if (c > 255) c = 255;\n#endif\n            ok = (start_bits\u00ddc/8\u00a8 & (1u << (c&7))) != 0;\n            }\n          }\n        if (!ok)\n          {\n          rc = MATCH_NOMATCH;\n          break;\n          }\n        }\n      }\n\n    /* Not anchored. Advance to a unique first code unit if there is one. In\n    8-bit mode, the use of memchr() gives a big speed up, even though we have\n    to call it twice in caseless mode, in order to find the earliest occurrence\n    of the character in either of its cases. If a call to memchr() that\n    searches the rest of the subject fails to find one case, remember that in\n    order not to keep on repeating the search. This can make a huge difference\n    when the strings are very long and only one case is present. */\n\n    else\n      {\n      if (has_first_cu)\n        {\n        if (first_cu != first_cu2)  /* Caseless */\n          {\n#if PCRE2_CODE_UNIT_WIDTH != 8\n          PCRE2_UCHAR smc;\n          while (start_match < end_subject &&\n                (smc = UCHAR21TEST(start_match)) != first_cu &&\n                  smc != first_cu2)\n            start_match++;\n\n#else  /* 8-bit code units */\n          PCRE2_SPTR pp1 = NULL;\n          PCRE2_SPTR pp2 = NULL;\n          PCRE2_SIZE cu2size = end_subject - start_match;\n\n          if (!memchr_not_found_first_cu)\n            {\n            pp1 = memchr(start_match, first_cu, end_subject - start_match);\n            if (pp1 == NULL) memchr_not_found_first_cu = TRUE;\n              else cu2size = pp1 - start_match;\n            }\n\n          /* If pp1 is not NULL, we have arranged to search only as far as pp1,\n          to see if the other case is earlier, so we can set \"not found\" only\n          when both searches have returned NULL. */\n\n          if (!memchr_not_found_first_cu2)\n            {\n            pp2 = memchr(start_match, first_cu2, cu2size);\n            memchr_not_found_first_cu2 = (pp2 == NULL && pp1 == NULL);\n            }\n\n          if (pp1 == NULL)\n            start_match = (pp2 == NULL)? end_subject : pp2;\n          else\n            start_match = (pp2 == NULL || pp1 < pp2)? pp1 : pp2;\n#endif\n          }\n\n        /* The caseful case */\n\n        else\n          {\n#if PCRE2_CODE_UNIT_WIDTH != 8\n          while (start_match < end_subject && UCHAR21TEST(start_match) !=\n                 first_cu)\n            start_match++;\n#else\n          start_match = memchr(start_match, first_cu, end_subject - start_match);\n          if (start_match == NULL) start_match = end_subject;\n#endif\n          }\n\n        /* If we can't find the required first code unit, having reached the\n        true end of the subject, break the bumpalong loop, to force a match\n        failure, except when doing partial matching, when we let the next cycle\n        run at the end of the subject. To see why, consider the pattern\n        /(?<=abc)def/, which partially matches \"abc\", even though the string\n        does not contain the starting character \"d\". If we have not reached the\n        true end of the subject (PCRE2_FIRSTLINE caused end_subject to be\n        temporarily modified) we also let the cycle run, because the matching\n        string is legitimately allowed to start with the first code unit of a\n        newline. */\n\n        if (mb->partial == 0 && start_match >= mb->end_subject)\n          {\n          rc = MATCH_NOMATCH;\n          break;\n          }\n        }\n\n      /* If there's no first code unit, advance to just after a linebreak for a\n      multiline match if required. */\n\n      else if (startline)\n        {\n        if (start_match > mb->start_subject + start_offset)\n          {\n#ifdef SUPPORT_UNICODE\n          if (utf)\n            {\n            while (start_match < end_subject && !WAS_NEWLINE(start_match))\n              {\n              start_match++;\n              ACROSSCHAR(start_match < end_subject, start_match, start_match++);\n              }\n            }\n          else\n#endif\n          while (start_match < end_subject && !WAS_NEWLINE(start_match))\n            start_match++;\n\n          /* If we have just passed a CR and the newline option is ANY or\n          ANYCRLF, and we are now at a LF, advance the match position by one\n          more code unit. */\n\n          if (start_match\u00dd-1\u00a8 == CHAR_CR &&\n               (mb->nltype == NLTYPE_ANY || mb->nltype == NLTYPE_ANYCRLF) &&\n               start_match < end_subject &&\n               UCHAR21TEST(start_match) == CHAR_NL)\n            start_match++;\n          }\n        }\n\n      /* If there's no first code unit or a requirement for a multiline line\n      start, advance to a non-unique first code unit if any have been\n      identified. The bitmap contains only 256 bits. When code units are 16 or\n      32 bits wide, all code units greater than 254 set the 255 bit. */\n\n      else if (start_bits != NULL)\n        {\n        while (start_match < end_subject)\n          {\n          uint32_t c = UCHAR21TEST(start_match);\n#if PCRE2_CODE_UNIT_WIDTH != 8\n          if (c > 255) c = 255;\n#endif\n          if ((start_bits\u00ddc/8\u00a8 & (1u << (c&7))) != 0) break;\n          start_match++;\n          }\n\n        /* See comment above in first_cu checking about the next few lines. */\n\n        if (mb->partial == 0 && start_match >= mb->end_subject)\n          {\n          rc = MATCH_NOMATCH;\n          break;\n          }\n        }\n      }   /* End first code unit handling */\n\n    /* Restore fudged end_subject */\n\n    end_subject = mb->end_subject;\n\n    /* The following two optimizations must be disabled for partial matching. */\n\n    if (mb->partial == 0)\n      {\n      PCRE2_SPTR p;\n\n      /* The minimum matching length is a lower bound; no string of that length\n      may actually match the pattern. Although the value is, strictly, in\n      characters, we treat it as code units to avoid spending too much time in\n      this optimization. */\n\n      if (end_subject - start_match < re->minlength)\n        {\n        rc = MATCH_NOMATCH;\n        break;\n        }\n\n      /* If req_cu is set, we know that that code unit must appear in the\n      subject for the (non-partial) match to succeed. If the first code unit is\n      set, req_cu must be later in the subject; otherwise the test starts at\n      the match point. This optimization can save a huge amount of backtracking\n      in patterns with nested unlimited repeats that aren't going to match.\n      Writing separate code for caseful/caseless versions makes it go faster,\n      as does using an autoincrement and backing off on a match. As in the case\n      of the first code unit, using memchr() in the 8-bit library gives a big\n      speed up. Unlike the first_cu check above, we do not need to call\n      memchr() twice in the caseless case because we only need to check for the\n      presence of the character in either case, not find the first occurrence.\n\n      The search can be skipped if the code unit was found later than the\n      current starting point in a previous iteration of the bumpalong loop.\n\n      HOWEVER: when the subject string is very, very long, searching to its end\n      can take a long time, and give bad performance on quite ordinary\n      anchored patterns. This showed up when somebody was matching something\n      like /\u00ac\\d+C/ on a 32-megabyte string... so we don't do this when the\n      string is sufficiently long, but it's worth searching a lot more for\n      unanchored patterns. */\n\n      p = start_match + (has_first_cu? 1:0);\n      if (has_req_cu && p > req_cu_ptr)\n        {\n        PCRE2_SIZE check_length = end_subject - start_match;\n\n        if (check_length < REQ_CU_MAX ||\n              (!anchored && check_length < REQ_CU_MAX * 1000))\n          {\n          if (req_cu != req_cu2)  /* Caseless */\n            {\n#if PCRE2_CODE_UNIT_WIDTH != 8\n            while (p < end_subject)\n              {\n              uint32_t pp = UCHAR21INCTEST(p);\n              if (pp == req_cu || pp == req_cu2) { p--; break; }\n              }\n#else  /* 8-bit code units */\n            PCRE2_SPTR pp = p;\n            p = memchr(pp, req_cu, end_subject - pp);\n            if (p == NULL)\n              {\n              p = memchr(pp, req_cu2, end_subject - pp);\n              if (p == NULL) p = end_subject;\n              }\n#endif /* PCRE2_CODE_UNIT_WIDTH != 8 */\n            }\n\n          /* The caseful case */\n\n          else\n            {\n#if PCRE2_CODE_UNIT_WIDTH != 8\n            while (p < end_subject)\n              {\n              if (UCHAR21INCTEST(p) == req_cu) { p--; break; }\n              }\n\n#else  /* 8-bit code units */\n            p = memchr(p, req_cu, end_subject - p);\n            if (p == NULL) p = end_subject;\n#endif\n            }\n\n          /* If we can't find the required code unit, break the bumpalong loop,\n          forcing a match failure. */\n\n          if (p >= end_subject)\n            {\n            rc = MATCH_NOMATCH;\n            break;\n            }\n\n          /* If we have found the required code unit, save the point where we\n          found it, so that we don't search again next time round the bumpalong\n          loop if the start hasn't yet passed this code unit. */\n\n          req_cu_ptr = p;\n          }\n        }\n      }\n    }\n\n  /* ------------ End of start of match optimizations ------------ */\n\n  /* Give no match if we have passed the bumpalong limit. */\n\n  if (start_match > bumpalong_limit)\n    {\n    rc = MATCH_NOMATCH;\n    break;\n    }\n\n  /* OK, we can now run the match. If \"hitend\" is set afterwards, remember the\n  first starting point for which a partial match was found. */\n\n  cb.start_match = (PCRE2_SIZE)(start_match - subject);\n  cb.callout_flags |= PCRE2_CALLOUT_STARTMATCH;\n\n  mb->start_used_ptr = start_match;\n  mb->last_used_ptr = start_match;\n#ifdef SUPPORT_UNICODE\n  mb->moptions = options | fragment_options;\n#else\n  mb->moptions = options;\n#endif\n  mb->match_call_count = 0;\n  mb->end_offset_top = 0;\n  mb->skip_arg_count = 0;\n\n  rc = match(start_match, mb->start_code, match_data->ovector,\n    match_data->oveccount, re->top_bracket, frame_size, mb);\n\n  if (mb->hitend && start_partial == NULL)\n    {\n    start_partial = mb->start_used_ptr;\n    match_partial = start_match;\n    }\n\n  switch(rc)\n    {\n    /* If MATCH_SKIP_ARG reaches this level it means that a MARK that matched\n    the SKIP's arg was not found. In this circumstance, Perl ignores the SKIP\n    entirely. The only way we can do that is to re-do the match at the same\n    point, with a flag to force SKIP with an argument to be ignored. Just\n    treating this case as NOMATCH does not work because it does not check other\n    alternatives in patterns such as A(*SKIP:A)B|AC when the subject is AC. */\n\n    case MATCH_SKIP_ARG:\n    new_start_match = start_match;\n    mb->ignore_skip_arg = mb->skip_arg_count;\n    break;\n\n    /* SKIP passes back the next starting point explicitly, but if it is no\n    greater than the match we have just done, treat it as NOMATCH. */\n\n    case MATCH_SKIP:\n    if (mb->verb_skip_ptr > start_match)\n      {\n      new_start_match = mb->verb_skip_ptr;\n      break;\n      }\n    /* Fall through */\n\n    /* NOMATCH and PRUNE advance by one character. THEN at this level acts\n    exactly like PRUNE. Unset ignore SKIP-with-argument. */\n\n    case MATCH_NOMATCH:\n    case MATCH_PRUNE:\n    case MATCH_THEN:\n    mb->ignore_skip_arg = 0;\n    new_start_match = start_match + 1;\n#ifdef SUPPORT_UNICODE\n    if (utf)\n      ACROSSCHAR(new_start_match < end_subject, new_start_match,\n        new_start_match++);\n#endif\n    break;\n\n    /* COMMIT disables the bumpalong, but otherwise behaves as NOMATCH. */\n\n    case MATCH_COMMIT:\n    rc = MATCH_NOMATCH;\n    goto ENDLOOP;\n\n    /* Any other return is either a match, or some kind of error. */\n\n    default:\n    goto ENDLOOP;\n    }\n\n  /* Control reaches here for the various types of \"no match at this point\"\n  result. Reset the code to MATCH_NOMATCH for subsequent checking. */\n\n  rc = MATCH_NOMATCH;\n\n  /* If PCRE2_FIRSTLINE is set, the match must happen before or at the first\n  newline in the subject (though it may continue over the newline). Therefore,\n  if we have just failed to match, starting at a newline, do not continue. */\n\n  if (firstline && IS_NEWLINE(start_match)) break;\n\n  /* Advance to new matching position */\n\n  start_match = new_start_match;\n\n  /* Break the loop if the pattern is anchored or if we have passed the end of\n  the subject. */\n\n  if (anchored || start_match > end_subject) break;\n\n  /* If we have just passed a CR and we are now at a LF, and the pattern does\n  not contain any explicit matches for \\r or \\n, and the newline option is CRLF\n  or ANY or ANYCRLF, advance the match position by one more code unit. In\n  normal matching start_match will aways be greater than the first position at\n  this stage, but a failed *SKIP can cause a return at the same point, which is\n  why the first test exists. */\n\n  if (start_match > subject + start_offset &&\n      start_match\u00dd-1\u00a8 == CHAR_CR &&\n      start_match < end_subject &&\n      *start_match == CHAR_NL &&\n      (re->flags & PCRE2_HASCRORLF) == 0 &&\n        (mb->nltype == NLTYPE_ANY ||\n         mb->nltype == NLTYPE_ANYCRLF ||\n         mb->nllen == 2))\n    start_match++;\n\n  mb->mark = NULL;   /* Reset for start of next match attempt */\n  }                  /* End of for(;;) \"bumpalong\" loop */\n\n/* ==========================================================================*/\n\n/* When we reach here, one of the following stopping conditions is true:\n\n(1) The match succeeded, either completely, or partially;\n\n(2) The pattern is anchored or the match was failed after (*COMMIT);\n\n(3) We are past the end of the subject or the bumpalong limit;\n\n(4) PCRE2_FIRSTLINE is set and we have failed to match at a newline, because\n    this option requests that a match occur at or before the first newline in\n    the subject.\n\n(5) Some kind of error occurred.\n\n*/\n\nENDLOOP:\n\n/* If end_subject != true_end_subject, it means we are handling invalid UTF,\nand have just processed a non-terminal fragment. If this resulted in no match\nor a partial match we must carry on to the next fragment (a partial match is\nreturned to the caller only at the very end of the subject). A loop is used to\navoid trying to match against empty fragments; if the pattern can match an\nempty string it would have done so already. */\n\n#ifdef SUPPORT_UNICODE\nif (utf && end_subject != true_end_subject &&\n    (rc == MATCH_NOMATCH || rc == PCRE2_ERROR_PARTIAL))\n  {\n  for (;;)\n    {\n    /* Advance past the first bad code unit, and then skip invalid character\n    starting code units in 8-bit and 16-bit modes. */\n\n    start_match = end_subject + 1;\n#if PCRE2_CODE_UNIT_WIDTH != 32\n    while (start_match < true_end_subject && NOT_FIRSTCU(*start_match))\n      start_match++;\n#endif\n\n    /* If we have hit the end of the subject, there isn't another non-empty\n    fragment, so give up. */\n\n    if (start_match >= true_end_subject)\n      {\n      rc = MATCH_NOMATCH;  /* In case it was partial */\n      break;\n      }\n\n    /* Check the rest of the subject */\n\n    mb->check_subject = start_match;\n    rc = PRIV(valid_utf)(start_match, length - (start_match - subject),\n      &(match_data->startchar));\n\n    /* The rest of the subject is valid UTF. */\n\n    if (rc == 0)\n      {\n      mb->end_subject = end_subject = true_end_subject;\n      fragment_options = PCRE2_NOTBOL;\n      goto FRAGMENT_RESTART;\n      }\n\n    /* A subsequent UTF error has been found; if the next fragment is\n    non-empty, set up to process it. Otherwise, let the loop advance. */\n\n    else if (rc < 0)\n      {\n      mb->end_subject = end_subject = start_match + match_data->startchar;\n      if (end_subject > start_match)\n        {\n        fragment_options = PCRE2_NOTBOL|PCRE2_NOTEOL;\n        goto FRAGMENT_RESTART;\n        }\n      }\n    }\n  }\n#endif  /* SUPPORT_UNICODE */\n\n/* Release an enlarged frame vector that is on the heap. */\n\nif (mb->match_frames != mb->stack_frames)\n  mb->memctl.free(mb->match_frames, mb->memctl.memory_data);\n\n/* Fill in fields that are always returned in the match data. */\n\nmatch_data->code = re;\nmatch_data->mark = mb->mark;\nmatch_data->matchedby = PCRE2_MATCHEDBY_INTERPRETER;\n\n/* Handle a fully successful match. Set the return code to the number of\ncaptured strings, or 0 if there were too many to fit into the ovector, and then\nset the remaining returned values before returning. Make a copy of the subject\nstring if requested. */\n\nif (rc == MATCH_MATCH)\n  {\n  match_data->rc = ((int)mb->end_offset_top >= 2 * match_data->oveccount)?\n    0 : (int)mb->end_offset_top/2 + 1;\n  match_data->startchar = start_match - subject;\n  match_data->leftchar = mb->start_used_ptr - subject;\n  match_data->rightchar = ((mb->last_used_ptr > mb->end_match_ptr)?\n    mb->last_used_ptr : mb->end_match_ptr) - subject;\n  if ((options & PCRE2_COPY_MATCHED_SUBJECT) != 0)\n    {\n    length = CU2BYTES(length + was_zero_terminated);\n    match_data->subject = match_data->memctl.malloc(length,\n      match_data->memctl.memory_data);\n    if (match_data->subject == NULL) return PCRE2_ERROR_NOMEMORY;\n    memcpy((void *)match_data->subject, subject, length);\n    match_data->flags |= PCRE2_MD_COPIED_SUBJECT;\n    }\n  else match_data->subject = subject;\n  return match_data->rc;\n  }\n\n/* Control gets here if there has been a partial match, an error, or if the\noverall match attempt has failed at all permitted starting positions. Any mark\ndata is in the nomatch_mark field. */\n\nmatch_data->mark = mb->nomatch_mark;\n\n/* For anything other than nomatch or partial match, just return the code. */\n\nif (rc != MATCH_NOMATCH && rc != PCRE2_ERROR_PARTIAL) match_data->rc = rc;\n\n/* Handle a partial match. If a \"soft\" partial match was requested, searching\nfor a complete match will have continued, and the value of rc at this point\nwill be MATCH_NOMATCH. For a \"hard\" partial match, it will already be\nPCRE2_ERROR_PARTIAL. */\n\nelse if (match_partial != NULL)\n  {\n  match_data->subject = subject;\n  match_data->ovector\u00dd0\u00a8 = match_partial - subject;\n  match_data->ovector\u00dd1\u00a8 = end_subject - subject;\n  match_data->startchar = match_partial - subject;\n  match_data->leftchar = start_partial - subject;\n  match_data->rightchar = end_subject - subject;\n  match_data->rc = PCRE2_ERROR_PARTIAL;\n  }\n\n/* Else this is the classic nomatch case. */\n\nelse match_data->rc = PCRE2_ERROR_NOMATCH;\n\nreturn match_data->rc;\n}\n\n/* End of pcre2_match.c */\n/*autoconv-0001 C:\\projects\\pcre2-10.35\\src\\pcre2_match.c converted to MATCH2*/\n/*autoconv-0011 MATCH2 line: 43 config.h replaced by CONFIG.h*/\n/*autoconv-0011 MATCH2 line: 63 pcre2_internal.h replaced by INTERNA2.h*/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "NEWLINE2": {"ttr": 6403, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "\n/*************************************************\n*      Perl-Compatible Regular Expressions       *\n*************************************************/\n\n/* PCRE is a library of functions to support regular expressions whose syntax\nand semantics are as close as possible to those of the Perl 5 language.\n\n                       Written by Philip Hazel\n     Original API code Copyright (c) 1997-2012 University of Cambridge\n         New API code Copyright (c) 2016 University of Cambridge\n\n-----------------------------------------------------------------------------\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n\n    * Redistributions of source code must retain the above copyright notice,\n      this list of conditions and the following disclaimer.\n\n    * Redistributions in binary form must reproduce the above copyright\n      notice, this list of conditions and the following disclaimer in the\n      documentation and/or other materials provided with the distribution.\n\n    * Neither the name of the University of Cambridge nor the names of its\n      contributors may be used to endorse or promote products derived from\n      this software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\nAND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\nIMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\nARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\nLIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\nCONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\nSUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\nINTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\nCONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\nARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\nPOSSIBILITY OF SUCH DAMAGE.\n-----------------------------------------------------------------------------\n*/\n\n\n/* This module contains internal functions for testing newlines when more than\none kind of newline is to be recognized. When a newline is found, its length is\nreturned. In principle, we could implement several newline \"types\", each\nreferring to a different set of newline characters. At present, PCRE2 supports\nonly NLTYPE_FIXED, which gets handled without these functions, NLTYPE_ANYCRLF,\nand NLTYPE_ANY. The full list of Unicode newline characters is taken from\nhttp://unicode.org/unicode/reports/tr18/. */\n\n\n#ifdef HAVE_CONFIG_H\n#include \"CONFIG.h\"\n#endif\n\n#include \"INTERNA2.h\"\n\n\n\n/*************************************************\n*      Check for newline at given position       *\n*************************************************/\n\n/* This function is called only via the IS_NEWLINE macro, which does so only\nwhen the newline type is NLTYPE_ANY or NLTYPE_ANYCRLF. The case of a fixed\nnewline (NLTYPE_FIXED) is handled inline. It is guaranteed that the code unit\npointed to by ptr is less than the end of the string.\n\nArguments:\n  ptr          pointer to possible newline\n  type         the newline type\n  endptr       pointer to the end of the string\n  lenptr       where to return the length\n  utf          TRUE if in utf mode\n\nReturns:       TRUE or FALSE\n*/\n\nBOOL\nPRIV(is_newline)(PCRE2_SPTR ptr, uint32_t type, PCRE2_SPTR endptr,\n  uint32_t *lenptr, BOOL utf)\n{\nuint32_t c;\n\n#ifdef SUPPORT_UNICODE\nif (utf) { GETCHAR(c, ptr); } else c = *ptr;\n#else\n(void)utf;\nc = *ptr;\n#endif  /* SUPPORT_UNICODE */\n\nif (type == NLTYPE_ANYCRLF) switch(c)\n  {\n  case CHAR_LF:\n  *lenptr = 1;\n  return TRUE;\n\n  case CHAR_CR:\n  *lenptr = (ptr < endptr - 1 && ptr\u00dd1\u00a8 == CHAR_LF)? 2 : 1;\n  return TRUE;\n\n  default:\n  return FALSE;\n  }\n\n/* NLTYPE_ANY */\n\nelse switch(c)\n  {\n#ifdef EBCDIC\n  case CHAR_NEL:\n#endif\n  case CHAR_LF:\n  case CHAR_VT:\n  case CHAR_FF:\n  *lenptr = 1;\n  return TRUE;\n\n  case CHAR_CR:\n  *lenptr = (ptr < endptr - 1 && ptr\u00dd1\u00a8 == CHAR_LF)? 2 : 1;\n  return TRUE;\n\n#ifndef EBCDIC\n#if PCRE2_CODE_UNIT_WIDTH == 8\n  case CHAR_NEL:\n  *lenptr = utf? 2 : 1;\n  return TRUE;\n\n  case 0x2028:   /* LS */\n  case 0x2029:   /* PS */\n  *lenptr = 3;\n  return TRUE;\n\n#else  /* 16-bit or 32-bit code units */\n  case CHAR_NEL:\n  case 0x2028:   /* LS */\n  case 0x2029:   /* PS */\n  *lenptr = 1;\n  return TRUE;\n#endif\n#endif /* Not EBCDIC */\n\n  default:\n  return FALSE;\n  }\n}\n\n\n\n/*************************************************\n*     Check for newline at previous position     *\n*************************************************/\n\n/* This function is called only via the WAS_NEWLINE macro, which does so only\nwhen the newline type is NLTYPE_ANY or NLTYPE_ANYCRLF. The case of a fixed\nnewline (NLTYPE_FIXED) is handled inline. It is guaranteed that the initial\nvalue of ptr is greater than the start of the string that is being processed.\n\nArguments:\n  ptr          pointer to possible newline\n  type         the newline type\n  startptr     pointer to the start of the string\n  lenptr       where to return the length\n  utf          TRUE if in utf mode\n\nReturns:       TRUE or FALSE\n*/\n\nBOOL\nPRIV(was_newline)(PCRE2_SPTR ptr, uint32_t type, PCRE2_SPTR startptr,\n  uint32_t *lenptr, BOOL utf)\n{\nuint32_t c;\nptr--;\n\n#ifdef SUPPORT_UNICODE\nif (utf)\n  {\n  BACKCHAR(ptr);\n  GETCHAR(c, ptr);\n  }\nelse c = *ptr;\n#else\n(void)utf;\nc = *ptr;\n#endif  /* SUPPORT_UNICODE */\n\nif (type == NLTYPE_ANYCRLF) switch(c)\n  {\n  case CHAR_LF:\n  *lenptr = (ptr > startptr && ptr\u00dd-1\u00a8 == CHAR_CR)? 2 : 1;\n  return TRUE;\n\n  case CHAR_CR:\n  *lenptr = 1;\n  return TRUE;\n\n  default:\n  return FALSE;\n  }\n\n/* NLTYPE_ANY */\n\nelse switch(c)\n  {\n  case CHAR_LF:\n  *lenptr = (ptr > startptr && ptr\u00dd-1\u00a8 == CHAR_CR)? 2 : 1;\n  return TRUE;\n\n#ifdef EBCDIC\n  case CHAR_NEL:\n#endif\n  case CHAR_VT:\n  case CHAR_FF:\n  case CHAR_CR:\n  *lenptr = 1;\n  return TRUE;\n\n#ifndef EBCDIC\n#if PCRE2_CODE_UNIT_WIDTH == 8\n  case CHAR_NEL:\n  *lenptr = utf? 2 : 1;\n  return TRUE;\n\n  case 0x2028:   /* LS */\n  case 0x2029:   /* PS */\n  *lenptr = 3;\n  return TRUE;\n\n#else /* 16-bit or 32-bit code units */\n  case CHAR_NEL:\n  case 0x2028:   /* LS */\n  case 0x2029:   /* PS */\n  *lenptr = 1;\n  return TRUE;\n#endif\n#endif /* Not EBCDIC */\n\n  default:\n  return FALSE;\n  }\n}\n\n/* End of pcre2_newline.c */\n/*autoconv-0001 C:\\projects\\pcre2-10.35\\src\\pcre2_newline.c converted to NEWLINE2*/\n/*autoconv-0011 NEWLINE2 line: 52 config.h replaced by CONFIG.h*/\n/*autoconv-0011 NEWLINE2 line: 55 pcre2_internal.h replaced by INTERNA2.h*/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ORD2UTF2": {"ttr": 3333, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "\n/*************************************************\n*      Perl-Compatible Regular Expressions       *\n*************************************************/\n\n/* PCRE is a library of functions to support regular expressions whose syntax\nand semantics are as close as possible to those of the Perl 5 language.\n\n                       Written by Philip Hazel\n     Original API code Copyright (c) 1997-2012 University of Cambridge\n         New API code Copyright (c) 2016 University of Cambridge\n\n-----------------------------------------------------------------------------\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n\n    * Redistributions of source code must retain the above copyright notice,\n      this list of conditions and the following disclaimer.\n\n    * Redistributions in binary form must reproduce the above copyright\n      notice, this list of conditions and the following disclaimer in the\n      documentation and/or other materials provided with the distribution.\n\n    * Neither the name of the University of Cambridge nor the names of its\n      contributors may be used to endorse or promote products derived from\n      this software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\nAND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\nIMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\nARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\nLIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\nCONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\nSUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\nINTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\nCONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\nARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\nPOSSIBILITY OF SUCH DAMAGE.\n-----------------------------------------------------------------------------\n*/\n\n\n/* This file contains a function that converts a Unicode character code point\ninto a UTF string. The behaviour is different for each code unit width. */\n\n\n#ifdef HAVE_CONFIG_H\n#include \"CONFIG.h\"\n#endif\n\n#include \"INTERNA2.h\"\n\n\n/* If SUPPORT_UNICODE is not defined, this function will never be called.\nSupply a dummy function because some compilers do not like empty source\nmodules. */\n\n#ifndef SUPPORT_UNICODE\nunsigned int\nPRIV(ord2utf)(uint32_t cvalue, PCRE2_UCHAR *buffer)\n{\n(void)(cvalue);\n(void)(buffer);\nreturn 0;\n}\n#else  /* SUPPORT_UNICODE */\n\n\n/*************************************************\n*          Convert code point to UTF             *\n*************************************************/\n\n/*\nArguments:\n  cvalue     the character value\n  buffer     pointer to buffer for result\n\nReturns:     number of code units placed in the buffer\n*/\n\nunsigned int\nPRIV(ord2utf)(uint32_t cvalue, PCRE2_UCHAR *buffer)\n{\n/* Convert to UTF-8 */\n\n#if PCRE2_CODE_UNIT_WIDTH == 8\nint i, j;\nfor (i = 0; i < PRIV(utf8_table1_size); i++)\n  if ((int)cvalue <= PRIV(utf8_table1)\u00ddi\u00a8) break;\nbuffer += i;\nfor (j = i; j > 0; j--)\n {\n *buffer-- = 0x80 | (cvalue & 0x3f);\n cvalue >>= 6;\n }\n*buffer = PRIV(utf8_table2)\u00ddi\u00a8 | cvalue;\nreturn i + 1;\n\n/* Convert to UTF-16 */\n\n#elif PCRE2_CODE_UNIT_WIDTH == 16\nif (cvalue <= 0xffff)\n  {\n  *buffer = (PCRE2_UCHAR)cvalue;\n  return 1;\n  }\ncvalue -= 0x10000;\n*buffer++ = 0xd800 | (cvalue >> 10);\n*buffer = 0xdc00 | (cvalue & 0x3ff);\nreturn 2;\n\n/* Convert to UTF-32 */\n\n#else\n*buffer = (PCRE2_UCHAR)cvalue;\nreturn 1;\n#endif\n}\n#endif  /* SUPPORT_UNICODE */\n\n/* End of pcre_ord2utf.c */\n/*autoconv-0001 C:\\projects\\pcre2-10.35\\src\\pcre2_ord2utf.c converted to ORD2UTF2*/\n/*autoconv-0011 ORD2UTF2 line: 47 config.h replaced by CONFIG.h*/\n/*autoconv-0011 ORD2UTF2 line: 50 pcre2_internal.h replaced by INTERNA2.h*/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PATTERN2": {"ttr": 515, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "\n/*************************************************\n*      Perl-Compatible Regular Expressions       *\n*************************************************/\n\n/* PCRE is a library of functions to support regular expressions whose syntax\nand semantics are as close as possible to those of the Perl 5 language.\n\n                       Written by Philip Hazel\n     Original API code Copyright (c) 1997-2012 University of Cambridge\n          New API code Copyright (c) 2016-2018 University of Cambridge\n\n-----------------------------------------------------------------------------\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n\n    * Redistributions of source code must retain the above copyright notice,\n      this list of conditions and the following disclaimer.\n\n    * Redistributions in binary form must reproduce the above copyright\n      notice, this list of conditions and the following disclaimer in the\n      documentation and/or other materials provided with the distribution.\n\n    * Neither the name of the University of Cambridge nor the names of its\n      contributors may be used to endorse or promote products derived from\n      this software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\nAND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\nIMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\nARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\nLIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\nCONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\nSUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\nINTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\nCONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\nARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\nPOSSIBILITY OF SUCH DAMAGE.\n-----------------------------------------------------------------------------\n*/\n\n\n#ifdef HAVE_CONFIG_H\n#include \"CONFIG.h\"\n#endif\n\n#include \"INTERNA2.h\"\n\n\n/*************************************************\n*        Return info about compiled pattern      *\n*************************************************/\n\n/*\nArguments:\n  code          points to compiled code\n  what          what information is required\n  where         where to put the information; if NULL, return length\n\nReturns:        0 when data returned\n                > 0 when length requested\n                < 0 on error or unset value\n*/\n\nPCRE2_EXP_DEFN int PCRE2_CALL_CONVENTION\npcre2_pattern_info(const pcre2_code *code, uint32_t what, void *where)\n{\nconst pcre2_real_code *re = (pcre2_real_code *)code;\n\nif (where == NULL)   /* Requests field length */\n  {\n  switch(what)\n    {\n    case PCRE2_INFO_ALLOPTIONS:\n    case PCRE2_INFO_ARGOPTIONS:\n    case PCRE2_INFO_BACKREFMAX:\n    case PCRE2_INFO_BSR:\n    case PCRE2_INFO_CAPTURECOUNT:\n    case PCRE2_INFO_DEPTHLIMIT:\n    case PCRE2_INFO_EXTRAOPTIONS:\n    case PCRE2_INFO_FIRSTCODETYPE:\n    case PCRE2_INFO_FIRSTCODEUNIT:\n    case PCRE2_INFO_HASBACKSLASHC:\n    case PCRE2_INFO_HASCRORLF:\n    case PCRE2_INFO_HEAPLIMIT:\n    case PCRE2_INFO_JCHANGED:\n    case PCRE2_INFO_LASTCODETYPE:\n    case PCRE2_INFO_LASTCODEUNIT:\n    case PCRE2_INFO_MATCHEMPTY:\n    case PCRE2_INFO_MATCHLIMIT:\n    case PCRE2_INFO_MAXLOOKBEHIND:\n    case PCRE2_INFO_MINLENGTH:\n    case PCRE2_INFO_NAMEENTRYSIZE:\n    case PCRE2_INFO_NAMECOUNT:\n    case PCRE2_INFO_NEWLINE:\n    return sizeof(uint32_t);\n\n    case PCRE2_INFO_FIRSTBITMAP:\n    return sizeof(const uint8_t *);\n\n    case PCRE2_INFO_JITSIZE:\n    case PCRE2_INFO_SIZE:\n    case PCRE2_INFO_FRAMESIZE:\n    return sizeof(size_t);\n\n    case PCRE2_INFO_NAMETABLE:\n    return sizeof(PCRE2_SPTR);\n    }\n  }\n\nif (re == NULL) return PCRE2_ERROR_NULL;\n\n/* Check that the first field in the block is the magic number. If it is not,\nreturn with PCRE2_ERROR_BADMAGIC. */\n\nif (re->magic_number != MAGIC_NUMBER) return PCRE2_ERROR_BADMAGIC;\n\n/* Check that this pattern was compiled in the correct bit mode */\n\nif ((re->flags & (PCRE2_CODE_UNIT_WIDTH/8)) == 0) return PCRE2_ERROR_BADMODE;\n\nswitch(what)\n  {\n  case PCRE2_INFO_ALLOPTIONS:\n  *((uint32_t *)where) = re->overall_options;\n  break;\n\n  case PCRE2_INFO_ARGOPTIONS:\n  *((uint32_t *)where) = re->compile_options;\n  break;\n\n  case PCRE2_INFO_BACKREFMAX:\n  *((uint32_t *)where) = re->top_backref;\n  break;\n\n  case PCRE2_INFO_BSR:\n  *((uint32_t *)where) = re->bsr_convention;\n  break;\n\n  case PCRE2_INFO_CAPTURECOUNT:\n  *((uint32_t *)where) = re->top_bracket;\n  break;\n\n  case PCRE2_INFO_DEPTHLIMIT:\n  *((uint32_t *)where) = re->limit_depth;\n  if (re->limit_depth == UINT32_MAX) return PCRE2_ERROR_UNSET;\n  break;\n\n  case PCRE2_INFO_EXTRAOPTIONS:\n  *((uint32_t *)where) = re->extra_options;\n  break;\n\n  case PCRE2_INFO_FIRSTCODETYPE:\n  *((uint32_t *)where) = ((re->flags & PCRE2_FIRSTSET) != 0)? 1 :\n                         ((re->flags & PCRE2_STARTLINE) != 0)? 2 : 0;\n  break;\n\n  case PCRE2_INFO_FIRSTCODEUNIT:\n  *((uint32_t *)where) = ((re->flags & PCRE2_FIRSTSET) != 0)?\n    re->first_codeunit : 0;\n  break;\n\n  case PCRE2_INFO_FIRSTBITMAP:\n  *((const uint8_t **)where) = ((re->flags & PCRE2_FIRSTMAPSET) != 0)?\n    &(re->start_bitmap\u00dd0\u00a8) : NULL;\n  break;\n\n  case PCRE2_INFO_FRAMESIZE:\n  *((size_t *)where) = offsetof(heapframe, ovector) +\n    re->top_bracket * 2 * sizeof(PCRE2_SIZE);\n  break;\n\n  case PCRE2_INFO_HASBACKSLASHC:\n  *((uint32_t *)where) = (re->flags & PCRE2_HASBKC) != 0;\n  break;\n\n  case PCRE2_INFO_HASCRORLF:\n  *((uint32_t *)where) = (re->flags & PCRE2_HASCRORLF) != 0;\n  break;\n\n  case PCRE2_INFO_HEAPLIMIT:\n  *((uint32_t *)where) = re->limit_heap;\n  if (re->limit_heap == UINT32_MAX) return PCRE2_ERROR_UNSET;\n  break;\n\n  case PCRE2_INFO_JCHANGED:\n  *((uint32_t *)where) = (re->flags & PCRE2_JCHANGED) != 0;\n  break;\n\n  case PCRE2_INFO_JITSIZE:\n#ifdef SUPPORT_JIT\n  *((size_t *)where) = (re->executable_jit != NULL)?\n    PRIV(jit_get_size)(re->executable_jit) : 0;\n#else\n  *((size_t *)where) = 0;\n#endif\n  break;\n\n  case PCRE2_INFO_LASTCODETYPE:\n  *((uint32_t *)where) = ((re->flags & PCRE2_LASTSET) != 0)? 1 : 0;\n  break;\n\n  case PCRE2_INFO_LASTCODEUNIT:\n  *((uint32_t *)where) = ((re->flags & PCRE2_LASTSET) != 0)?\n    re->last_codeunit : 0;\n  break;\n\n  case PCRE2_INFO_MATCHEMPTY:\n  *((uint32_t *)where) = (re->flags & PCRE2_MATCH_EMPTY) != 0;\n  break;\n\n  case PCRE2_INFO_MATCHLIMIT:\n  *((uint32_t *)where) = re->limit_match;\n  if (re->limit_match == UINT32_MAX) return PCRE2_ERROR_UNSET;\n  break;\n\n  case PCRE2_INFO_MAXLOOKBEHIND:\n  *((uint32_t *)where) = re->max_lookbehind;\n  break;\n\n  case PCRE2_INFO_MINLENGTH:\n  *((uint32_t *)where) = re->minlength;\n  break;\n\n  case PCRE2_INFO_NAMEENTRYSIZE:\n  *((uint32_t *)where) = re->name_entry_size;\n  break;\n\n  case PCRE2_INFO_NAMECOUNT:\n  *((uint32_t *)where) = re->name_count;\n  break;\n\n  case PCRE2_INFO_NAMETABLE:\n  *((PCRE2_SPTR *)where) = (PCRE2_SPTR)((char *)re + sizeof(pcre2_real_code));\n  break;\n\n  case PCRE2_INFO_NEWLINE:\n  *((uint32_t *)where) = re->newline_convention;\n  break;\n\n  case PCRE2_INFO_SIZE:\n  *((size_t *)where) = re->blocksize;\n  break;\n\n  default: return PCRE2_ERROR_BADOPTION;\n  }\n\nreturn 0;\n}\n\n\n\n/*************************************************\n*              Callout enumerator                *\n*************************************************/\n\n/*\nArguments:\n  code          points to compiled code\n  callback      function called for each callout block\n  callout_data  user data passed to the callback\n\nReturns:        0 when successfully completed\n                < 0 on local error\n               != 0 for callback error\n*/\n\nPCRE2_EXP_DEFN int PCRE2_CALL_CONVENTION\npcre2_callout_enumerate(const pcre2_code *code,\n  int (*callback)(pcre2_callout_enumerate_block *, void *), void *callout_data)\n{\npcre2_real_code *re = (pcre2_real_code *)code;\npcre2_callout_enumerate_block cb;\nPCRE2_SPTR cc;\n#ifdef SUPPORT_UNICODE\nBOOL utf;\n#endif\n\nif (re == NULL) return PCRE2_ERROR_NULL;\n\n#ifdef SUPPORT_UNICODE\nutf = (re->overall_options & PCRE2_UTF) != 0;\n#endif\n\n/* Check that the first field in the block is the magic number. If it is not,\nreturn with PCRE2_ERROR_BADMAGIC. */\n\nif (re->magic_number != MAGIC_NUMBER) return PCRE2_ERROR_BADMAGIC;\n\n/* Check that this pattern was compiled in the correct bit mode */\n\nif ((re->flags & (PCRE2_CODE_UNIT_WIDTH/8)) == 0) return PCRE2_ERROR_BADMODE;\n\ncb.version = 0;\ncc = (PCRE2_SPTR)((uint8_t *)re + sizeof(pcre2_real_code))\n     + re->name_count * re->name_entry_size;\n\nwhile (TRUE)\n  {\n  int rc;\n  switch (*cc)\n    {\n    case OP_END:\n    return 0;\n\n    case OP_CHAR:\n    case OP_CHARI:\n    case OP_NOT:\n    case OP_NOTI:\n    case OP_STAR:\n    case OP_MINSTAR:\n    case OP_PLUS:\n    case OP_MINPLUS:\n    case OP_QUERY:\n    case OP_MINQUERY:\n    case OP_UPTO:\n    case OP_MINUPTO:\n    case OP_EXACT:\n    case OP_POSSTAR:\n    case OP_POSPLUS:\n    case OP_POSQUERY:\n    case OP_POSUPTO:\n    case OP_STARI:\n    case OP_MINSTARI:\n    case OP_PLUSI:\n    case OP_MINPLUSI:\n    case OP_QUERYI:\n    case OP_MINQUERYI:\n    case OP_UPTOI:\n    case OP_MINUPTOI:\n    case OP_EXACTI:\n    case OP_POSSTARI:\n    case OP_POSPLUSI:\n    case OP_POSQUERYI:\n    case OP_POSUPTOI:\n    case OP_NOTSTAR:\n    case OP_NOTMINSTAR:\n    case OP_NOTPLUS:\n    case OP_NOTMINPLUS:\n    case OP_NOTQUERY:\n    case OP_NOTMINQUERY:\n    case OP_NOTUPTO:\n    case OP_NOTMINUPTO:\n    case OP_NOTEXACT:\n    case OP_NOTPOSSTAR:\n    case OP_NOTPOSPLUS:\n    case OP_NOTPOSQUERY:\n    case OP_NOTPOSUPTO:\n    case OP_NOTSTARI:\n    case OP_NOTMINSTARI:\n    case OP_NOTPLUSI:\n    case OP_NOTMINPLUSI:\n    case OP_NOTQUERYI:\n    case OP_NOTMINQUERYI:\n    case OP_NOTUPTOI:\n    case OP_NOTMINUPTOI:\n    case OP_NOTEXACTI:\n    case OP_NOTPOSSTARI:\n    case OP_NOTPOSPLUSI:\n    case OP_NOTPOSQUERYI:\n    case OP_NOTPOSUPTOI:\n    cc += PRIV(OP_lengths)\u00dd*cc\u00a8;\n#ifdef SUPPORT_UNICODE\n    if (utf && HAS_EXTRALEN(cc\u00dd-1\u00a8)) cc += GET_EXTRALEN(cc\u00dd-1\u00a8);\n#endif\n    break;\n\n    case OP_TYPESTAR:\n    case OP_TYPEMINSTAR:\n    case OP_TYPEPLUS:\n    case OP_TYPEMINPLUS:\n    case OP_TYPEQUERY:\n    case OP_TYPEMINQUERY:\n    case OP_TYPEUPTO:\n    case OP_TYPEMINUPTO:\n    case OP_TYPEEXACT:\n    case OP_TYPEPOSSTAR:\n    case OP_TYPEPOSPLUS:\n    case OP_TYPEPOSQUERY:\n    case OP_TYPEPOSUPTO:\n    cc += PRIV(OP_lengths)\u00dd*cc\u00a8;\n#ifdef SUPPORT_UNICODE\n    if (cc\u00dd-1\u00a8 == OP_PROP || cc\u00dd-1\u00a8 == OP_NOTPROP) cc += 2;\n#endif\n    break;\n\n#if defined SUPPORT_UNICODE || PCRE2_CODE_UNIT_WIDTH != 8\n    case OP_XCLASS:\n    cc += GET(cc, 1);\n    break;\n#endif\n\n    case OP_MARK:\n    case OP_COMMIT_ARG:\n    case OP_PRUNE_ARG:\n    case OP_SKIP_ARG:\n    case OP_THEN_ARG:\n    cc += PRIV(OP_lengths)\u00dd*cc\u00a8 + cc\u00dd1\u00a8;\n    break;\n\n    case OP_CALLOUT:\n    cb.pattern_position = GET(cc, 1);\n    cb.next_item_length = GET(cc, 1 + LINK_SIZE);\n    cb.callout_number = cc\u00dd1 + 2*LINK_SIZE\u00a8;\n    cb.callout_string_offset = 0;\n    cb.callout_string_length = 0;\n    cb.callout_string = NULL;\n    rc = callback(&cb, callout_data);\n    if (rc != 0) return rc;\n    cc += PRIV(OP_lengths)\u00dd*cc\u00a8;\n    break;\n\n    case OP_CALLOUT_STR:\n    cb.pattern_position = GET(cc, 1);\n    cb.next_item_length = GET(cc, 1 + LINK_SIZE);\n    cb.callout_number = 0;\n    cb.callout_string_offset = GET(cc, 1 + 3*LINK_SIZE);\n    cb.callout_string_length =\n      GET(cc, 1 + 2*LINK_SIZE) - (1 + 4*LINK_SIZE) - 2;\n    cb.callout_string = cc + (1 + 4*LINK_SIZE) + 1;\n    rc = callback(&cb, callout_data);\n    if (rc != 0) return rc;\n    cc += GET(cc, 1 + 2*LINK_SIZE);\n    break;\n\n    default:\n    cc += PRIV(OP_lengths)\u00dd*cc\u00a8;\n    break;\n    }\n  }\n}\n\n/* End of pcre2_pattern_info.c */\n/*autoconv-0001 C:\\projects\\pcre2-10.35\\src\\pcre2_pattern_info.c converted to PATTERN2*/\n/*autoconv-0011 PATTERN2 line: 43 config.h replaced by CONFIG.h*/\n/*autoconv-0011 PATTERN2 line: 46 pcre2_internal.h replaced by INTERNA2.h*/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PCOBAPI2": {"ttr": 3077, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "\n\n\n/*\nTHE z/OS specific functionality\n-------------------------------\n\nContributed by:   Ze'ev Atlas.\n\nCopyright (c) 2015-2017 Ze'ev Atlas.\nAll rights reserved.\n\n\nTHE \"BSD\" LICENCE\n-----------------\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n\n    * Redistributions of source code must retain the above copyright notice,\n      this list of conditions and the following disclaimer.\n\n    * Redistributions in binary form must reproduce the above copyright\n      notice, this list of conditions and the following disclaimer in the\n      documentation and/or other materials provided with the distribution.\n\n    * Neither the name of the University of Cambridge nor the name of Google\n      Inc. nor the names of their contributors may be used to endorse or\n      promote products derived from this software without specific prior\n      written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\nAND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\nIMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\nARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\nLIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\nCONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\nSUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\nINTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\nCONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\nARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\nPOSSIBILITY OF SUCH DAMAGE.                                          */\n/****************************************************************************\n* The PCOBAPI2 provides old style z/OS COBOL with the ability to call       *\n* traditional z/OS short (8 characters) names.  In this first version I     *\n* converted the API man page to simple C program and created short names    *\n* manually.  Subsequent conversion scripts might generate this program      *\n* automatically from my database.                            ZA 07/19/2015  *\n*                                                                           *\n* I also provide here some old COBOL oriented string manipulation and       *\n* memory allocation functions                                ZA 07/19/2015  *\n*                                                                           *\n* Basically, this is an adjusted version of the PCOBAPI as appeared in the  *\n* ported old PCRE (still available) - adjusted to PCRE2      ZA 07/19/2015  *\n****************************************************************************/\n/*PCRE2API(3)\nNAME\n       PCRE2 - Perl-compatible regular expressions (revised API)\n\n/*PCRE 16-BIT API, PCRE 32-BIT API as well as ASCII are specifically not\n         supported.  The z/OS port is meant to support native EBCDIC\n         environment only!    */\n\n#ifdef HAVE_CONFIG_H\n#include \"CONFIG.h\"\n#endif\n#include <stdlib.h>\n#include \"posixh.h\"\n#include \"pcre2.h\"\n#include \"pcrzconh.h\"\n\n     /*PCRE2  is  a  new API for PCRE. This program provides API between LE\n       languages and its functions. See the pcre2 document for an overview\n       of  all  the PCRE2 documentation.*/\n/*PCRE2_GENERAL_INFO_FUNCTIONS*/\nextern     int PCRE2_CALL_CONVENTION CONFIG2(uint32_t, void *);\n\n/* Functions for manipulating contexts. */\n\n/*PCRE2_GENERAL_CONTEXT_FUNCTIONS*/\nextern    pcre2_general_context PCRE2_CALL_CONVENTION\n  *GENCNTCP(pcre2_general_context *);\nextern     pcre2_general_context PCRE2_CALL_CONVENTION\n  *GENCNTCR(void *(*)(PCRE2_SIZE, void *),\n    void (*)(void *, void *), void *);\nextern     void PCRE2_CALL_CONVENTION\n  GENCNTFR(pcre2_general_context *);\n\n/*PCRE2_COMPILE_CONTEXT_FUNCTIONS*/\nextern     pcre2_compile_context PCRE2_CALL_CONVENTION\n  *CMPCNTCP(pcre2_compile_context *);\nextern     pcre2_compile_context PCRE2_CALL_CONVENTION\n  *CMPCNTCR(pcre2_general_context *);\nextern     void PCRE2_CALL_CONVENTION\n  CMPCNTFR(pcre2_compile_context *);\nextern     int PCRE2_CALL_CONVENTION\n  SETBSR(pcre2_compile_context *, uint32_t);\nextern     int PCRE2_CALL_CONVENTION\n  SETCHRTB(pcre2_compile_context *, const unsigned char *);\nextern     int PCRE2_CALL_CONVENTION\n  SETCEXOP(pcre2_compile_context *, uint32_t);\nextern     int PCRE2_CALL_CONVENTION\n  SETMXPLN(pcre2_compile_context *, PCRE2_SIZE);\nextern     int PCRE2_CALL_CONVENTION\n  SETNEWLN(pcre2_compile_context *, uint32_t);\nextern     int PCRE2_CALL_CONVENTION\n  SETPRNLM(pcre2_compile_context *, uint32_t);\nextern     int PCRE2_CALL_CONVENTION\n  SETCMRCG(pcre2_compile_context *,\n    int (*)(uint32_t, void *), void *);\n\n/*PCRE2_MATCH_CONTEXT_FUNCTIONS*/\nextern     pcre2_match_context PCRE2_CALL_CONVENTION\n  *MTCCNTCP(pcre2_match_context *);\nextern     pcre2_match_context PCRE2_CALL_CONVENTION\n  *MTCCNTCR(pcre2_general_context *);\nextern     void PCRE2_CALL_CONVENTION\n  MTCCNTFR(pcre2_match_context *);\nextern     int PCRE2_CALL_CONVENTION\n  SETCALOT(pcre2_match_context *,\n    int (*)(pcre2_callout_block *, void *), void *);\nextern     int PCRE2_CALL_CONVENTION\n  SETDEPLM(pcre2_match_context *, uint32_t);\nextern     int PCRE2_CALL_CONVENTION\n  SETHEPLM(pcre2_match_context *, uint32_t);\nextern     int PCRE2_CALL_CONVENTION\n  SETMTCLM(pcre2_match_context *, uint32_t);\nextern     int PCRE2_CALL_CONVENTION\n  SETOFFLM(pcre2_match_context *, PCRE2_SIZE);\nextern     int PCRE2_CALL_CONVENTION\n  SETRCNLM(pcre2_match_context *, uint32_t);\nextern     int PCRE2_CALL_CONVENTION\n  SETRCNMM(pcre2_match_context *,\n    void *(*)(PCRE2_SIZE, void *), void (*)(void *, void *), void *);\n\n/*PCRE2_CONVERT_CONTEXT_FUNCTIONS */\nextern     pcre2_convert_context PCRE2_CALL_CONVENTION\n  *CNVCTXCP(pcre2_convert_context *);\nextern     pcre2_convert_context PCRE2_CALL_CONVENTION\n  *CNVCTXCR(pcre2_general_context *);\nextern     void PCRE2_CALL_CONVENTION\n  CNVCTXFR(pcre2_convert_context *);\nextern     int PCRE2_CALL_CONVENTION\n  SETGLBES(pcre2_convert_context *, uint32_t);\nextern     int PCRE2_CALL_CONVENTION\n  SETGLBSP(pcre2_convert_context *, uint32_t);\n\n/* Functions concerned with compiling a pattern to PCRE internal code. */\n\n/*PCRE2_COMPILE_FUNCTIONS*/\nextern     pcre2_code PCRE2_CALL_CONVENTION\n  *COMPILE2(PCRE2_SPTR, PCRE2_SIZE, uint32_t, int *, PCRE2_SIZE *,\n    pcre2_compile_context *);\nextern     void PCRE2_CALL_CONVENTION\n  CODEFREE(pcre2_code *);\nextern     pcre2_code PCRE2_CALL_CONVENTION\n  *CODECOPY(const pcre2_code *);\nextern     pcre2_code PCRE2_CALL_CONVENTION\n  *CODECOPT(const pcre2_code *);\n\n/* Functions that give information about a compiled pattern. */\n\n/*PCRE2_PATTERN_INFO_FUNCTIONS*/\nextern     int PCRE2_CALL_CONVENTION\n  PATTERN2(const pcre2_code *, uint32_t, void *);\nextern     int PCRE2_CALL_CONVENTION\n  CALOTENM(const pcre2_code *,\n    int (*)(pcre2_callout_enumerate_block *, void *), void *);\n\n/* Functions for running a match and inspecting the result. */\n\n/*PCRE2_MATCH_FUNCTIONS*/\nextern     pcre2_match_data PCRE2_CALL_CONVENTION\n  *MATCHDCR(uint32_t, pcre2_general_context *);\nextern     pcre2_match_data PCRE2_CALL_CONVENTION\n  *MATCDCFP(const pcre2_code *,\n    pcre2_general_context *);\nextern     int PCRE2_CALL_CONVENTION\n  DFAMATC2(const pcre2_code *, PCRE2_SPTR, PCRE2_SIZE, PCRE2_SIZE,\n    uint32_t, pcre2_match_data *, pcre2_match_context *, int *, PCRE2_SIZE);\nextern     int PCRE2_CALL_CONVENTION\n  MATCH2(const pcre2_code *, PCRE2_SPTR, PCRE2_SIZE, PCRE2_SIZE,\n    uint32_t, pcre2_match_data *, pcre2_match_context *);\nextern     void PCRE2_CALL_CONVENTION\n  pcre2_match_data_free(pcre2_match_data *);\nextern     PCRE2_SPTR PCRE2_CALL_CONVENTION\n  GETMARK(pcre2_match_data *);\nextern     uint32_t PCRE2_CALL_CONVENTION\n  GETOVECN(pcre2_match_data *);\nextern     PCRE2_SIZE PCRE2_CALL_CONVENTION\n  *GETOVEPT(pcre2_match_data *);\nextern     PCRE2_SIZE PCRE2_CALL_CONVENTION\n  GETSTART(pcre2_match_data *);\n\n/* Convenience functions for handling matched substrings. */\n\n/*PCRE2_SUBSTRING_FUNCTIONS*/\nextern     int PCRE2_CALL_CONVENTION\n  SUBCPNAM(pcre2_match_data *, PCRE2_SPTR, PCRE2_UCHAR *,\n    PCRE2_SIZE *);\nextern     int PCRE2_CALL_CONVENTION\n  SUBCPNUM(pcre2_match_data *, uint32_t, PCRE2_UCHAR *,\n    PCRE2_SIZE *);\nextern     void PCRE2_CALL_CONVENTION\n  SUBSTFR(PCRE2_UCHAR *);\nextern     int PCRE2_CALL_CONVENTION\n  SUBGTNAM(pcre2_match_data *, PCRE2_SPTR, PCRE2_UCHAR **,\n    PCRE2_SIZE *);\nextern     int PCRE2_CALL_CONVENTION\n  SUBGTNUM(pcre2_match_data *, uint32_t, PCRE2_UCHAR **,\n    PCRE2_SIZE *);\nextern     int PCRE2_CALL_CONVENTION\n  SUBLNNAM(pcre2_match_data *, PCRE2_SPTR, PCRE2_SIZE *);\nextern     int PCRE2_CALL_CONVENTION\n  SUBLNNUM(pcre2_match_data *, uint32_t, PCRE2_SIZE *);\nextern     int PCRE2_CALL_CONVENTION\n  SUBNMSCN(const pcre2_code *, PCRE2_SPTR, PCRE2_SPTR *,\n    PCRE2_SPTR *);\nextern     int PCRE2_CALL_CONVENTION\n  SUBNMFNM(const pcre2_code *, PCRE2_SPTR);\nextern     void PCRE2_CALL_CONVENTION\n  SUBLSTFR(PCRE2_SPTR *);\nextern     int PCRE2_CALL_CONVENTION\n  SUBLSTGT(pcre2_match_data *, PCRE2_UCHAR ***, PCRE2_SIZE **);\n\n/* Functions for serializing / deserializing compiled patterns. */\n\n/*PCRE2_SERIALIZE_FUNCTIONS*/\nextern     int32_t PCRE2_CALL_CONVENTION\n  SERIAENC(const pcre2_code **, int32_t, uint8_t **,\n    PCRE2_SIZE *, pcre2_general_context *);\nextern     int32_t PCRE2_CALL_CONVENTION\n  SERIADCD(pcre2_code **, int32_t, const uint8_t *,\n    pcre2_general_context *);\nextern     int32_t PCRE2_CALL_CONVENTION\n  SERGTNMC(const uint8_t *);\nextern     void PCRE2_CALL_CONVENTION\n  SERIAFR(uint8_t *);\n\n/* Convenience function for match + substitute. */\n\n/*PCRE2_SUBSTITUTE_FUNCTION*/\nextern     int PCRE2_CALL_CONVENTION\n  SUBSTIT2(const pcre2_code *, PCRE2_SPTR, PCRE2_SIZE, PCRE2_SIZE,\n    uint32_t, pcre2_match_data *, pcre2_match_context *, PCRE2_SPTR,\n    PCRE2_SIZE, PCRE2_UCHAR *, PCRE2_SIZE *);\n\n\n/* Functions for converting pattern source strings. */\n\n/* PCRE2_CONVERT_FUNCTIONS */\nextern     int PCRE2_CALL_CONVENTION\n  PATTCONV(PCRE2_SPTR, PCRE2_SIZE, uint32_t, PCRE2_UCHAR **, \\\n    PCRE2_SIZE *, pcre2_convert_context *); \\\nextern     void PCRE2_CALL_CONVENTION\n  CNVPATFR(PCRE2_UCHAR *);\n\n\n/* Functions for JIT processing */\n\n/*PCRE2_JIT_FUNCTIONS*/\nextern     int PCRE2_CALL_CONVENTION\n  JITCOMP2(pcre2_code *, uint32_t);\nextern     int PCRE2_CALL_CONVENTION\n  JITMATC2(const pcre2_code *, PCRE2_SPTR, PCRE2_SIZE, PCRE2_SIZE,\n    uint32_t, pcre2_match_data *, pcre2_match_context *);\n/*\nextern     void PCRE2_CALL_CONVENTION\n  pcre2_jit_free_unused_memory(pcre2_general_context *);\nextern     pcre2_jit_stack PCRE2_CALL_CONVENTION\n  *pcre2_jit_stack_create(PCRE2_SIZE, PCRE2_SIZE, pcre2_general_context *);\nextern     void PCRE2_CALL_CONVENTION\n  pcre2_jit_stack_assign(pcre2_match_context *, pcre2_jit_callback, void *);\nextern     void PCRE2_CALL_CONVENTION\n  pcre2_jit_stack_free(pcre2_jit_stack *);\n*/\n\n\n/* Other miscellaneous functions. */\n\n/*PCRE2_OTHER_FUNCTIONS*/\nextern     int PCRE2_CALL_CONVENTION\n  GETERROR(int, PCRE2_UCHAR *, PCRE2_SIZE);\nextern     const uint8_t PCRE2_CALL_CONVENTION\n  *MAKETAB2(pcre2_general_context *);\n\nextern    void FREEMAIN (void* ptr);\n\nextern    void * GETMAIN (size_t size);\n\nextern    int ZWHTTRM (char * str, int maxlen);\n\nextern    int ZISSPTRM (char * str, int maxlen);\n\nextern    int ZISNLTRM (char * str, int maxlen);\n\nextern    int ZSPC2NUL (char * str, int maxlen);\n\nextern    int ZNUL2SPC (char * str, int maxlen);\n\n/*  pcrz_codeset_init <=> ZCSINIT             */\nextern int ZCSINIT (ZCSSTRCT ** handle_ptr,\n                      char * codeset_name,\n                      size_t codeset_size,\n                      size_t pattern_size,\n                      size_t subject_size);\n/*  pcrz_codeset_init_substitute <=> ZCSINIS             */\nextern int ZCSINIS (ZCSSTRCT * handle_ptr,\n                      size_t replacement_size,\n                      size_t substitute_size,\n                      char **substitute_ptr);\n/*  pcrz_codeset_convert_pattern <=> ZCSCONVP */\nextern int ZCSCONVP (ZCSSTRCT *zcsstrct_ptr,\n         char * input_pattern, size_t pattern_length,\n         char ** output_pattern, size_t ** out_pattern_length);\n/*  pcrz_codeset_convert_subject <=> ZCSCONVS */\nextern int ZCSCONVS (ZCSSTRCT *zcsstrct_ptr,\n         char * input_subject, size_t subject_length,\n         char ** output_subject, size_t ** out_subject_length);\n/*  pcrz_codeset_convert_replacement <=> ZCSCONVR */\nextern int ZCSCONVR (ZCSSTRCT *zcsstrct_ptr,\n         char * input_replacement, size_t replacement_length,\n         char ** output_replacement, size_t ** out_replacement_length);\n/*  pcrz_codeset_convert_substitute_back <=> ZCSCONVB */\nextern int ZCSCONVB (ZCSSTRCT *zcsstrct_ptr,\n         char * input_substitute, size_t substitute_length,\n         char ** output_substitute, size_t ** out_substitute_length);\n/*  pcrz_codeset_release <=> ZCSRLSE          */\nextern void ZCSRLSE (ZCSSTRCT *zcsstrct_ptr);\n\n/* special POSIX names are no longer needed (10.33)\n   but provided for backwards compatibility */\nextern int PREGCOMP(regex_t *, const char *, int);\n\nextern int PREGEXEC(const regex_t *, const char *, size_t,\n                     regmatch_t *, int);\n\nextern size_t PREGERR(int, const regex_t *, char *, size_t);\n\nextern void PREGFREE(regex_t *);\n\n\n/*PCRE2 NATIVE API BASIC FUNCTIONS*/\n\n/*        =>COMPILE2 */\npcre2_code * PCRE2_CALL_CONVENTION\nCOMPILE2(PCRE2_SPTR pattern, PCRE2_SIZE patlen, uint32_t options,\n   int *errorptr, PCRE2_SIZE *erroroffset, pcre2_compile_context *ccontext)\n{\n    return pcre2_compile(pattern, patlen,\n         options, errorptr, erroroffset,\n         ccontext);\n}\n\n/*       = part of COMPILE2 - supported as is via PGMNAME(LONGMIXED) */\nvoid PCRE2_CALL_CONVENTION\nCODEFREE(pcre2_code *code)\n{\n    return pcre2_code_free(code);\n}\n\n/*       = part of COMPILE2 - supported as is via PGMNAME(LONGMIXED) */\npcre2_code * PCRE2_CALL_CONVENTION\nCODECOPY(const pcre2_code *code)\n{\n    return pcre2_code_copy(code);\n}\n\n/*       = part of COMPILE2 - supported as is via PGMNAME(LONGMIXED) */\npcre2_code * PCRE2_CALL_CONVENTION\nCODECOPT(const pcre2_code *code)\n{\n    return pcre2_code_copy_with_tables(code);\n}\n\n/*       = part of MATCHDA2 - supported as is via PGMNAME(LONGMIXED) */\npcre2_match_data * PCRE2_CALL_CONVENTION\nMATCHDCR(uint32_t oveccount, pcre2_general_context *gcontext)\n{\n    return pcre2_match_data_create(oveccount,\n        gcontext);\n}\n\n/*       = part of MATCHDA2 - supported as is via PGMNAME(LONGMIXED) */\npcre2_match_data * PCRE2_CALL_CONVENTION\nMATCDCFP(const pcre2_code *code,\n  pcre2_general_context *gcontext)\n{\n    return pcre2_match_data_create_from_pattern(code,\n        gcontext);\n}\n\n/*        =>MATCH2  */\nint PCRE2_CALL_CONVENTION\nMATCH2(const pcre2_code *code, PCRE2_SPTR subject, PCRE2_SIZE length,\n  PCRE2_SIZE start_offset, uint32_t options, pcre2_match_data *match_data,\n  pcre2_match_context *mcontext)\n{\n    return pcre2_match(code, subject,\n         length, start_offset,\n         options, match_data,\n         mcontext);\n}\n\n/*        =>DFAMATC2  */\nint PCRE2_CALL_CONVENTION\nDFAMATC2(const pcre2_code *code, PCRE2_SPTR subject, PCRE2_SIZE length,\n  PCRE2_SIZE start_offset, uint32_t options, pcre2_match_data *match_data,\n  pcre2_match_context *mcontext, int *workspace, PCRE2_SIZE wscount)\n{\n    return pcre2_dfa_match(code, subject,\n         length, start_offset,\n         options, match_data,\n         mcontext,\n         workspace, wscount);\n}\n\n/*       = part of MATCHDA2 - supported as is via PGMNAME(LONGMIXED) */\nvoid PCRE2_CALL_CONVENTION\nMATCHDFR(pcre2_match_data *match_data)\n{\n    return pcre2_match_data_free(match_data);\n}\n\n/*PCRE2 NATIVE API AUXILIARY MATCH FUNCTIONS*/\n\n/*       = part of MATCHDA2 - supported as is via PGMNAME(LONGMIXED) */\nPCRE2_SPTR PCRE2_CALL_CONVENTION\nGETMARK(pcre2_match_data *match_data)\n{\n    return pcre2_get_mark(match_data);\n}\n\n/*       = part of MATCHDA2 - supported as is via PGMNAME(LONGMIXED) */\nPCRE2_SIZE PCRE2_CALL_CONVENTION\nGETMTCSZ(pcre2_match_data *match_data)\n{\n    return pcre2_get_match_data_size(match_data);\n}\n\n/*       = part of MATCHDA2 - supported as is via PGMNAME(LONGMIXED) */\nuint32_t PCRE2_CALL_CONVENTION\nGETOVECN(pcre2_match_data *match_data)\n{\n    return pcre2_get_ovector_count(match_data);\n}\n\n/*       = part of MATCHDA2 - supported as is via PGMNAME(LONGMIXED) */\nPCRE2_SIZE * PCRE2_CALL_CONVENTION\nGETOVEPT(pcre2_match_data *match_data)\n{\n    return pcre2_get_ovector_pointer(match_data);\n}\n\n/*       = part of MATCHDA2 - supported as is via PGMNAME(LONGMIXED) */\nPCRE2_SIZE PCRE2_CALL_CONVENTION\nGETSTART(pcre2_match_data *match_data)\n{\n    return pcre2_get_startchar(match_data);\n}\n\n/*PCRE2 NATIVE API GENERAL CONTEXT FUNCTIONS*/\n\n/*       = part of CONTEXT2 - supported as is via PGMNAME(LONGMIXED) */\npcre2_general_context * PCRE2_CALL_CONVENTION\nGENCNTCR(void *(*private_malloc)(size_t, void *),\nvoid (*private_free)(void *, void *), void *memory_data)\n{\n    return pcre2_general_context_create(\n         private_malloc,\n         private_free, memory_data);\n}\n\n/*       = part of CONTEXT2 - supported as is via PGMNAME(LONGMIXED) */\npcre2_general_context * PCRE2_CALL_CONVENTION\nGENCNTCP(pcre2_general_context *gcontext)\n{\n    return pcre2_general_context_copy(\n         gcontext);\n}\n\n/*       = part of CONTEXT2 - supported as is via PGMNAME(LONGMIXED) */\nvoid PCRE2_CALL_CONVENTION\nGENCNTFR(pcre2_general_context *gcontext)\n{\n    return pcre2_general_context_free(gcontext);\n}\n\n/*PCRE2 NATIVE API COMPILE CONTEXT FUNCTIONS*/\n\n/*       = part of CONTEXT2 - supported as is via PGMNAME(LONGMIXED) */\npcre2_compile_context * PCRE2_CALL_CONVENTION\nCMPCNTCR(\n         pcre2_general_context *gcontext)\n{\n    return pcre2_compile_context_create(\n         gcontext);\n}\n\n/*       = part of CONTEXT2 - supported as is via PGMNAME(LONGMIXED) */\npcre2_compile_context * PCRE2_CALL_CONVENTION\nCMPCNTCP(pcre2_compile_context *ccontext)\n{\n    return pcre2_compile_context_copy(\n         ccontext);\n}\n\n/*       = part of CONTEXT2 - supported as is via PGMNAME(LONGMIXED) */\nvoid PCRE2_CALL_CONVENTION\nCMPCNTFR(pcre2_compile_context *ccontext)\n{\n    return pcre2_compile_context_free(ccontext);\n}\n\n/*       = part of CONTEXT2 - supported as is via PGMNAME(LONGMIXED) */\nint PCRE2_CALL_CONVENTION\nSETBSR(pcre2_compile_context *ccontext, uint32_t value)\n{\n    return pcre2_set_bsr(ccontext,\n         value);\n}\n\n/*       = part of CONTEXT2 - supported as is via PGMNAME(LONGMIXED) */\nint PCRE2_CALL_CONVENTION\nSETMXPLN(pcre2_compile_context *ccontext, PCRE2_SIZE length)\n{\n    return pcre2_set_max_pattern_length(ccontext,\n  length);\n}\n\n/*       = part of CONTEXT2 - supported as is via PGMNAME(LONGMIXED) */\nint PCRE2_CALL_CONVENTION\nSETCHRTB(pcre2_compile_context *ccontext,\nconst unsigned char *tables)\n{\n    return pcre2_set_character_tables(ccontext,\n         tables);\n}\n\n/*       = part of CONTEXT2 - supported as is via PGMNAME(LONGMIXED) */\nint PCRE2_CALL_CONVENTION\nSETNEWLN(pcre2_compile_context *ccontext, uint32_t newline)\n{\n    return pcre2_set_newline(ccontext,\n         newline);\n}\n\n/*       = part of CONTEXT2 - supported as is via PGMNAME(LONGMIXED) */\nint PCRE2_CALL_CONVENTION\nSETPRNLM(pcre2_compile_context *ccontext, uint32_t limit)\n{\n    return pcre2_set_parens_nest_limit(ccontext,\n         limit);\n}\n\n/*       = part of CONTEXT2 - supported as is via PGMNAME(LONGMIXED) */\nint PCRE2_CALL_CONVENTION\nSETCEXOP(pcre2_compile_context *ccontext, uint32_t options)\n{\n    return pcre2_set_compile_extra_options(ccontext, options);\n}\n\n/*       = part of CONTEXT2 - supported as is via PGMNAME(LONGMIXED) */\nint PCRE2_CALL_CONVENTION\nSETCMRCG(pcre2_compile_context *ccontext,\nint (*guard)(uint32_t, void *), void *user_data)\n{\n    return pcre2_set_compile_recursion_guard(ccontext,\n         guard, user_data);\n}\n\n/*PCRE2 NATIVE API MATCH CONTEXT FUNCTIONS*/\n\n/*       = part of CONTEXT2 - supported as is via PGMNAME(LONGMIXED) */\npcre2_match_context * PCRE2_CALL_CONVENTION\nMTCCNTCR(pcre2_general_context *gcontext)\n{\n     return pcre2_match_context_create(\n         gcontext);\n}\n\n/*       = part of CONTEXT2 - supported as is via PGMNAME(LONGMIXED) */\npcre2_match_context * PCRE2_CALL_CONVENTION\nMTCCNTCP(pcre2_match_context *mcontext)\n{\n     return pcre2_match_context_copy(\n         mcontext);\n}\n\n/*       = part of CONTEXT2 - supported as is via PGMNAME(LONGMIXED) */\nvoid PCRE2_CALL_CONVENTION\nMTCCNTFR(pcre2_match_context *mcontext)\n{\n     return pcre2_match_context_free(mcontext);\n}\n\n/*       = part of CONTEXT2 - supported as is via PGMNAME(LONGMIXED) */\nint PCRE2_CALL_CONVENTION\nSETCALOT(pcre2_match_context *mcontext,\nint (*callout)(pcre2_callout_block *, void *), void *callout_data)\n{\n     return pcre2_set_callout(mcontext,\n         callout,\n         callout_data);\n}\n\n/*       = part of CONTEXT2 - supported as is via PGMNAME(LONGMIXED) */\nint PCRE2_CALL_CONVENTION\nSETOFFLM(pcre2_match_context *mcontext, PCRE2_SIZE limit)\n{\n     return pcre2_set_offset_limit(mcontext,\n         limit);\n}\n\n/*       = part of CONTEXT2 - supported as is via PGMNAME(LONGMIXED) */\nint PCRE2_CALL_CONVENTION\nSETMTCLM(pcre2_match_context *mcontext, uint32_t limit)\n{\n     return pcre2_set_match_limit(mcontext,\n         limit);\n}\n\n/*       = part of CONTEXT2 - supported as is via PGMNAME(LONGMIXED) */\nint PCRE2_CALL_CONVENTION\nSETHEPLM(pcre2_match_context *mcontext, uint32_t limit)\n{\n     return pcre2_set_heap_limit(mcontext, limit);\n}\n\n/*       = part of CONTEXT2 - supported as is via PGMNAME(LONGMIXED) */\nint PCRE2_CALL_CONVENTION\nSETDEPLM(pcre2_match_context *mcontext, uint32_t limit)\n{\n     return pcre2_set_depth_limit(mcontext, limit);\n}\n\n/*       = part of CONTEXT2 - supported as is via PGMNAME(LONGMIXED) */\nint PCRE2_CALL_CONVENTION\nSETRCNLM(pcre2_match_context *mcontext, uint32_t limit)\n{\n     return pcre2_set_recursion_limit(mcontext,\n         limit);\n}\n\n/*       = part of CONTEXT2 - supported as is via PGMNAME(LONGMIXED) */\nint PCRE2_CALL_CONVENTION\nSETRCNMM(pcre2_match_context *mcontext,\nvoid *(*mymalloc)(size_t, void *), void (*myfree)(void *, void *),\nvoid *mydata)\n{\n     return pcre2_set_recursion_memory_management(\n         mcontext,\n         mymalloc,\n         myfree, mydata);\n}\n\n/* PCRE2 NATIVE API CONVERT CONTEXT FUNCTIONS*/\n\n/*       = part of CONTEXT2 - supported as is via PGMNAME(LONGMIXED) */\npcre2_convert_context * PCRE2_CALL_CONVENTION\nCNVCTXCP(pcre2_convert_context *ccontext)\n{\n     return pcre2_convert_context_copy(ccontext);\n}\n\n/*       = part of CONTEXT2 - supported as is via PGMNAME(LONGMIXED) */\npcre2_convert_context * PCRE2_CALL_CONVENTION\nCNVCTXCR(pcre2_general_context *gcontext)\n{\n     return pcre2_convert_context_create(gcontext);\n}\n\n/*       = part of CONTEXT2 - supported as is via PGMNAME(LONGMIXED) */\nvoid PCRE2_CALL_CONVENTION\nCNVCTXFR(pcre2_convert_context *ccontext)\n{\n     return pcre2_convert_context_free(ccontext);\n}\n\n/*       = part of CONTEXT2 - supported as is via PGMNAME(LONGMIXED) */\nint PCRE2_CALL_CONVENTION\nSETGLBES(pcre2_convert_context *ccontext, uint32_t escape)\n{\n     return pcre2_set_glob_escape(ccontext, escape);\n}\n\n/*       = part of CONTEXT2 - supported as is via PGMNAME(LONGMIXED) */\nint PCRE2_CALL_CONVENTION\nSETGLBSP(pcre2_convert_context *ccontext, uint32_t separator)\n{\n     return pcre2_set_glob_separator(ccontext, separator);\n}\n\n/*PCRE2 NATIVE API STRING EXTRACTION FUNCTIONS*/\n\n/*       = part of SUBSTRI2 - supported as is via PGMNAME(LONGMIXED) */\nint PCRE2_CALL_CONVENTION\nSUBCPNAM(pcre2_match_data *match_data, PCRE2_SPTR stringname,\n  PCRE2_UCHAR *buffer, PCRE2_SIZE *sizeptr)\n{\n     return pcre2_substring_copy_byname(match_data,\n         stringname, buffer, sizeptr);\n}\n\n/*       = part of SUBSTRI2 - supported as is via PGMNAME(LONGMIXED) */\nint PCRE2_CALL_CONVENTION\nSUBCPNUM(pcre2_match_data *match_data,\n  uint32_t stringnumber, PCRE2_UCHAR *buffer, PCRE2_SIZE *sizeptr)\n{\n     return pcre2_substring_copy_bynumber(match_data,\n         stringnumber, buffer,\n         sizeptr);\n}\n\n/*       = part of SUBSTRI2 - supported as is via PGMNAME(LONGMIXED) */\nvoid PCRE2_CALL_CONVENTION\nSUBSTFR(PCRE2_UCHAR *string)\n{\n     return pcre2_substring_free(string);\n}\n\n/*       = part of SUBSTRI2 - supported as is via PGMNAME(LONGMIXED) */\nint PCRE2_CALL_CONVENTION\nSUBGTNAM(pcre2_match_data *match_data,\n  PCRE2_SPTR stringname, PCRE2_UCHAR **stringptr, PCRE2_SIZE *sizeptr)\n{\n     return pcre2_substring_get_byname(match_data,\n         stringname, stringptr, sizeptr);\n}\n\n/*       = part of SUBSTRI2 - supported as is via PGMNAME(LONGMIXED) */\nint PCRE2_CALL_CONVENTION\nSUBGTNUM(pcre2_match_data *match_data,\n  uint32_t stringnumber, PCRE2_UCHAR **stringptr, PCRE2_SIZE *sizeptr)\n{\n     return pcre2_substring_get_bynumber(match_data,\n         stringnumber, stringptr,\n         sizeptr);\n}\n\n/*       = part of SUBSTRI2 - supported as is via PGMNAME(LONGMIXED) */\nint PCRE2_CALL_CONVENTION\nSUBLNNAM(pcre2_match_data *match_data,\n  PCRE2_SPTR stringname, PCRE2_SIZE *sizeptr)\n{\n     return pcre2_substring_length_byname(match_data,\n         stringname, sizeptr);\n}\n\n/*       = part of SUBSTRI2 - supported as is via PGMNAME(LONGMIXED) */\nint PCRE2_CALL_CONVENTION\nSUBLNNUM(pcre2_match_data *match_data,\n  uint32_t stringnumber, PCRE2_SIZE *sizeptr)\n{\n     return pcre2_substring_length_bynumber(match_data,\n         stringnumber, sizeptr);\n}\n\n/*       = part of SUBSTRI2 - supported as is via PGMNAME(LONGMIXED) */\nint PCRE2_CALL_CONVENTION\nSUBNMSCN(const pcre2_code *code, PCRE2_SPTR stringname,\n  PCRE2_SPTR *firstptr, PCRE2_SPTR *lastptr)\n{\n     return pcre2_substring_nametable_scan(code,\n         stringname, firstptr, lastptr);\n}\n\n/*       = part of SUBSTRI2 - supported as is via PGMNAME(LONGMIXED) */\nint PCRE2_CALL_CONVENTION\nSUBNMFNM(const pcre2_code *code,\n  PCRE2_SPTR stringname)\n{\n     return pcre2_substring_number_from_name(code,\n         stringname);\n}\n\n/*       = part of SUBSTRI2 - supported as is via PGMNAME(LONGMIXED) */\n\nvoid PCRE2_CALL_CONVENTION\nSUBLSTFR(PCRE2_SPTR *list)\n{\n     return pcre2_substring_list_free(list);\n}\n\n/*       = part of SUBSTRI2 - supported as is via PGMNAME(LONGMIXED) */\nint PCRE2_CALL_CONVENTION\nSUBLSTGT(pcre2_match_data *match_data, PCRE2_UCHAR ***listptr,\n  PCRE2_SIZE **lengthsptr)\n{\n     return pcre2_substring_list_get(match_data,\n         listptr, lengthsptr);\n}\n\n/*PCRE2 NATIVE API STRING SUBSTITUTION FUNCTION*/\n/*        =>SUBSTIT2 */\nint PCRE2_CALL_CONVENTION\nSUBSTIT2(const pcre2_code *code, PCRE2_SPTR subject, PCRE2_SIZE length,\n  PCRE2_SIZE start_offset, uint32_t options, pcre2_match_data *match_data,\n  pcre2_match_context *mcontext, PCRE2_SPTR replacement, PCRE2_SIZE rlength,\n  PCRE2_UCHAR *buffer, PCRE2_SIZE *blength)\n{\n     return pcre2_substitute(code, subject,\n         length, start_offset,\n         options, match_data,\n         mcontext, replacement,\n         rlength, buffer,\n         blength);\n}\n\n/*PCRE2 NATIVE API CONVERT_FUNCTIONS */\n\n/*       = part of CONVERT2 - supported as is via PGMNAME(LONGMIXED) */\nint PCRE2_CALL_CONVENTION\nPATTCONV(PCRE2_SPTR pattern, PCRE2_SIZE plength, uint32_t options,\n  PCRE2_UCHAR **buffptr, PCRE2_SIZE *bufflenptr,\n  pcre2_convert_context *ccontext)\n{\n     return pcre2_pattern_convert(pattern, plength, options,\n  buffptr, bufflenptr,\n  ccontext);\n}\n\n/*       = part of CONVERT2 - supported as is via PGMNAME(LONGMIXED) */\nvoid PCRE2_CALL_CONVENTION\nCNVPATFR(PCRE2_UCHAR *converted)\n{\n pcre2_converted_pattern_free(converted);\n}\n\n\n/*PCRE2 NATIVE API JIT FUNCTIONS*/\n/*        =>JITCOMP2 - available but not supportet in z/OS */\nint PCRE2_CALL_CONVENTION\nJITCOMP2(pcre2_code *code, uint32_t options)\n{\n     return pcre2_jit_compile(code, options);\n}\n\n/*        =>JITMATC2 - available but not supportet in z/OS */\nint PCRE2_CALL_CONVENTION\nJITMATC2(const pcre2_code *code, PCRE2_SPTR subject, PCRE2_SIZE length,\n  PCRE2_SIZE start_offset, uint32_t options, pcre2_match_data *match_data,\n  pcre2_match_context *mcontext)\n{\n     return pcre2_jit_match(code, subject,\n         length, start_offset,\n         options, match_data,\n         mcontext);\n}\n\n/*       = part of JITMISC2 - not supportet in z/OS\n       void pcre2_jit_free_unused_memory(pcre2_general_context *gcontext);*/\n\n/*       = part of JITMISC2 - not supportet in z/OS\n       pcre2_jit_stack *pcre2_jit_stack_create(PCRE2_SIZE startsize,\n         PCRE2_SIZE maxsize, pcre2_general_context *gcontext);*/\n\n/*       = part of JITMISC2 - not supportet in z/OS\n       void pcre2_jit_stack_assign(pcre2_match_context *mcontext,\n         pcre2_jit_callback callback_function, void *callback_data);*/\n\n/*       = part of JITMISC2 - not supportet in z/OS\n       void pcre2_jit_stack_free(pcre2_jit_stack *jit_stack);*/\n\n/*PCRE2 NATIVE API SERIALIZATION FUNCTIONS*/\n\n/*       = part of SERIALI2 - supported as is via PGMNAME(LONGMIXED) */\nint32_t PCRE2_CALL_CONVENTION\nSERIADCD(pcre2_code **codes, int32_t number_of_codes,\n   const uint8_t *bytes, pcre2_general_context *gcontext)\n{\n     return pcre2_serialize_decode(codes,\n         number_of_codes, bytes,\n         gcontext);\n}\n\n/*       = part of SERIALI2 - supported as is via PGMNAME(LONGMIXED) */\nint32_t PCRE2_CALL_CONVENTION\nSERIAENC(const pcre2_code **codes, int32_t number_of_codes,\n   uint8_t **serialized_bytes, PCRE2_SIZE *serialized_size,\n   pcre2_general_context *gcontext)\n{\n     return pcre2_serialize_encode(codes,\n         number_of_codes, serialized_bytes,\n         serialized_size, gcontext);\n}\n\n/*       = part of SERIALI2 - supported as is via PGMNAME(LONGMIXED) */\nvoid PCRE2_CALL_CONVENTION\nSERIAFR(uint8_t *bytes)\n{\n     return pcre2_serialize_free(bytes);\n}\n\n/*       = part of SERIALI2 - supported as is via PGMNAME(LONGMIXED) */\nint32_t PCRE2_CALL_CONVENTION\nSERGTNMC(const uint8_t *bytes)\n{\n     return pcre2_serialize_get_number_of_codes(bytes);\n}\n\n/*PCRE2 NATIVE API AUXILIARY FUNCTIONS*/\n\n/*       = part of ERROR2 - supported as is via PGMNAME(LONGMIXED) */\nint PCRE2_CALL_CONVENTION\nGETERROR(int enumber, PCRE2_UCHAR *buffer, PCRE2_SIZE size)\n{\n     return pcre2_get_error_message(enumber, buffer,\n         size);\n}\n\n/*        =>MAKETAB2 */\nconst uint8_t * PCRE2_CALL_CONVENTION\nMAKETAB2(pcre2_general_context *gcontext)\n{\n     return pcre2_maketables(gcontext);\n}\n\n/*        => part of MAKETAB2 - supported as is via PGMNAME(LONGMIXED) */\nvoid PCRE2_CALL_CONVENTION\nMAKETABF(pcre2_general_context *gcontext, const uint8_t *character_tables)\n{\n     return pcre2_maketables_free(gcontext, character_tables);\n}\n\n/*        =>PATTERN2 */\nint PCRE2_CALL_CONVENTION\nPATTERN2(const pcre2_code *code, uint32_t what, void *where)\n\n{\n     return pcre2_pattern_info(code, what, where);\n}\n/*       = part of PATTERN2 - supported as is via PGMNAME(LONGMIXED) */\nint PCRE2_CALL_CONVENTION\nCALOTENM(const pcre2_code *code,\n  int (*callback)(pcre2_callout_enumerate_block *, void *), void *callout_data)\n{\n     return pcre2_callout_enumerate(code,\n         callback,\n         callout_data);\n}\n\n/*        =>CONFIG2 */\nint CONFIG2(uint32_t what, void *where)\n{\n     return pcre2_config(what, where);\n}\n\n/* experimental implementation of some of the above as COBOL front end to\n   native C\n   I chose the mainframe names GETMAIN and FREEMAIN since these are the names\n   that native z/OS users are familiar with, especially in the CICS\n   environment, but the implementation is simply via the malloc and free\n   functions.*/\n\nvoid FREEMAIN (void* ptr)\n{\n        free (ptr);\n}\n\nvoid * GETMAIN (size_t size)\n{\n    return malloc (size);\n}\n\n/*SYNOPSIS FOR PCRZ API*/\n\n/*     = part of pcrzfunc - supported as is via PGMNAME(LONGMIXED) */\n\nint ZWHTTRM (char * str, int maxlen)\n{\n       return pcrz_what_term_str (str, maxlen);\n}\n\nint ZISSPTRM (char * str, int maxlen)\n{\n       return pcrz_is_space_term_str (str, maxlen);\n}\n\nint ZISNLTRM (char * str, int maxlen)\n{\n       return pcrz_is_null_term_str (str, maxlen);\n}\n\nint ZSPC2NUL (char * str, int maxlen)\n{\n       return pcrz_space_to_null_term_str (str, maxlen);\n}\n\nint ZNUL2SPC (char * str, int maxlen)\n{\n       return pcrz_null_to_space_term_str (str, maxlen);\n}\n\n/*  pcrz_codeset_init <=> ZCSINIT             */\nint ZCSINIT (ZCSSTRCT ** handle_ptr,\n                      char * codeset_name,\n                      size_t codeset_size,\n                      size_t pattern_size,\n                      size_t subject_size)\n{\n       return pcrz_codeset_init (handle_ptr,\n                      codeset_name,\n                      codeset_size,\n                      pattern_size,\n                      subject_size);\n}\n\n/*  pcrz_codeset_init_substitute <=> ZCSINIS         */\nint ZCSINIS (ZCSSTRCT * handle_ptr,\n                      size_t replacement_size,\n                      size_t substitute_size,\n                      char **substitute_ptr)\n{\n       return pcrz_codeset_init_substitute (handle_ptr,\n                      replacement_size,\n                      substitute_size,\n                      substitute_ptr);\n}\n\n/*  pcrz_codeset_convert_pattern <=> ZCSCONVP */\nint ZCSCONVP (ZCSSTRCT *zcsstrct_ptr,\n         char * input_pattern, size_t pattern_length,\n         char ** output_pattern, size_t ** out_pattern_length)\n{\n       return pcrz_codeset_convert_pattern (zcsstrct_ptr,\n                input_pattern, pattern_length,\n                output_pattern, out_pattern_length);\n}\n\n/*  pcrz_codeset_convert_subject <=> ZCSCONVS */\nint ZCSCONVS (ZCSSTRCT *zcsstrct_ptr,\n         char * input_subject, size_t subject_length,\n         char ** output_subject, size_t ** out_subject_length)\n{\n       return pcrz_codeset_convert_subject (zcsstrct_ptr,\n                input_subject, subject_length,\n                output_subject, out_subject_length);\n}\n\n/*  pcrz_codeset_convert_replacement <=> ZCSCONVR */\nint ZCSCONVR (ZCSSTRCT *zcsstrct_ptr,\n         char * input_replacement, size_t replacement_length,\n         char ** output_replacement, size_t ** out_replacement_length)\n{\n       return pcrz_codeset_convert_replacement (zcsstrct_ptr,\n                input_replacement, replacement_length,\n                output_replacement, out_replacement_length);\n}\n\n/*  pcrz_codeset_convert_substitute_back <=> ZCSCONVB */\nint ZCSCONVB (ZCSSTRCT *zcsstrct_ptr,\n         char * input_substitute, size_t substitute_length,\n         char ** output_substitute, size_t ** out_substitute_length)\n{\n       return pcrz_codeset_convert_substitute_back (zcsstrct_ptr,\n                input_substitute, substitute_length,\n                output_substitute, out_substitute_length);\n}\n\n/*  pcrz_codeset_release <=> ZCSRLSE          */\nvoid ZCSRLSE (ZCSSTRCT *zcsstrct_ptr)\n{\n       pcrz_codeset_release (zcsstrct_ptr);\n}\n\n/*SYNOPSIS OF POSIX API*/\n\n/*note: native z/OS C has <regex.h> and these functions.  Do not issue\n#include <regex.h> in any program that intend to use PCRE POSIX*/\n/* Decided to transform names to eliminate the conflict above!\n#define NATIVE_ZOS_POSIX\nin the OPTFILE member will make the COBAPI2 to override the PCRE2 calls\nand direct them to the native z/OS, POSIX compliant functions */\n#ifdef NATIVE_ZOS_POSIX\n/* 10.22.\nI do no longer provide any override for POSIX through PCOBAPI.c.  Any\noverride, for any desired result should be achieved via using the\nPC2PSXAP.h header and manipulating the COMPILE_WITH_PCRE2 macro.\nint PREGCOMP(regex_t *preg, const char *pattern,\n            int cflags)\n{\n       return regcomp(preg, pattern,\n            cflags);\n}\n\nint PREGEXEC(regex_t *preg, const char *string,\n            size_t nmatch, regmatch_t pmatch\u00dd\u00a8, int eflags)\n{\n       return regexec(preg, string,\n            nmatch, pmatch  , eflags);\n}\n\nsize_t PREGERR(int errcode, const regex_t *preg,\n            char *errbuf, size_t errbuf_size)\n{\n       return regerror(errcode, preg,\n            errbuf, errbuf_size);\n}\n\nvoid PREGFREE(regex_t *preg)\n{\n       return regfree(preg);\n}*/\n#endif\n/* OTH the names are provided for backwards compatibility\n   with z/OS port of PCRE2 (10.33) */\nint PREGCOMP(regex_t *preg, const char *pattern,\n            int cflags)\n{\n       return pcre2_regcomp(preg, pattern,\n            cflags);\n}\n\nint PREGEXEC(regex_t *preg, const char *string,\n            size_t nmatch, regmatch_t pmatch\u00dd\u00a8, int eflags)\n{\n       return pcre2_regexec(preg, string,\n            nmatch, pmatch  , eflags);\n}\n\nsize_t PREGERR(int errcode, const regex_t *preg,\n            char *errbuf, size_t errbuf_size)\n{\n       return pcre2_regerror(errcode, preg,\n            errbuf, errbuf_size);\n}\n\nvoid PREGFREE(regex_t *preg)\n{\n       return pcre2_regfree(preg);\n}\n/**/\n/*autoconv-0001 C:\\projects\\pcre2port\\pcobapi2.c converted to PCOBAPI2*/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PCRE2": {"ttr": 14339, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "\n/*************************************************\n*       Perl-Compatible Regular Expressions      *\n*************************************************/\n\n/* This is the public header file for the PCRE library, second API, to be\n#included by applications that call PCRE2 functions.\n\n           Copyright (c) 2016-2020 University of Cambridge\n\n-----------------------------------------------------------------------------\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n\n    * Redistributions of source code must retain the above copyright notice,\n      this list of conditions and the following disclaimer.\n\n    * Redistributions in binary form must reproduce the above copyright\n      notice, this list of conditions and the following disclaimer in the\n      documentation and/or other materials provided with the distribution.\n\n    * Neither the name of the University of Cambridge nor the names of its\n      contributors may be used to endorse or promote products derived from\n      this software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\nAND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\nIMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\nARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\nLIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\nCONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\nSUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\nINTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\nCONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\nARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\nPOSSIBILITY OF SUCH DAMAGE.\n-----------------------------------------------------------------------------\n*/\n\n#ifndef PCRE2_H_IDEMPOTENT_GUARD\n#define PCRE2_H_IDEMPOTENT_GUARD\n\n/* The current PCRE version information. */\n\n#define PCRE2_MAJOR           10\n#define PCRE2_MINOR           35\n#define PCRE2_PRERELEASE\n#define PCRE2_DATE            2020-05-09\n\n/* When an application links to a PCRE DLL in Windows, the symbols that are\nimported have to be identified as such. When building PCRE2, the appropriate\nexport setting is defined in pcre2_internal.h, which includes this file. So we\ndon't change existing definitions of PCRE2_EXP_DECL. */\n\n#if defined(_WIN32) && !defined(PCRE2_STATIC)\n#  ifndef PCRE2_EXP_DECL\n#    define PCRE2_EXP_DECL  extern __declspec(dllimport)\n#  endif\n#endif\n\n/* By default, we use the standard \"extern\" declarations. */\n\n#ifndef PCRE2_EXP_DECL\n#  ifdef __cplusplus\n#    define PCRE2_EXP_DECL  extern \"C\"\n#  else\n#    define PCRE2_EXP_DECL  extern\n#  endif\n#endif\n\n/* When compiling with the MSVC compiler, it is sometimes necessary to include\na \"calling convention\" before exported function names. (This is secondhand\ninformation; I know nothing about MSVC myself). For example, something like\n\n  void __cdecl function(....)\n\nmight be needed. In order so make this easy, all the exported functions have\nPCRE2_CALL_CONVENTION just before their names. It is rarely needed; if not\nset, we ensure here that it has no effect. */\n\n#ifndef PCRE2_CALL_CONVENTION\n#define PCRE2_CALL_CONVENTION\n#endif\n\n/* Have to include limits.h, stdlib.h, and inttypes.h to ensure that size_t and\nuint8_t, UCHAR_MAX, etc are defined. Some systems that do have inttypes.h do\nnot have stdint.h, which is why we use inttypes.h, which according to the C\nstandard is a superset of stdint.h. If none of these headers are available,\nthe relevant values must be provided by some other means. */\n\n#include <limits.h>\n#include <stdlib.h>\n#include <inttypes.h>\n\n/* Allow for C++ users compiling this directly. */\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n/* The following option bits can be passed to pcre2_compile(), pcre2_match(),\nor pcre2_dfa_match(). PCRE2_NO_UTF_CHECK affects only the function to which it\nis passed. Put these bits at the most significant end of the options word so\nothers can be added next to them */\n\n#define PCRE2_ANCHORED            0x80000000u\n#define PCRE2_NO_UTF_CHECK        0x40000000u\n#define PCRE2_ENDANCHORED         0x20000000u\n\n/* The following option bits can be passed only to pcre2_compile(). However,\nthey may affect compilation, JIT compilation, and/or interpretive execution.\nThe following tags indicate which:\n\nC   alters what is compiled by pcre2_compile()\nJ   alters what is compiled by pcre2_jit_compile()\nM   is inspected during pcre2_match() execution\nD   is inspected during pcre2_dfa_match() execution\n*/\n\n#define PCRE2_ALLOW_EMPTY_CLASS   0x00000001u  /* C       */\n#define PCRE2_ALT_BSUX            0x00000002u  /* C       */\n#define PCRE2_AUTO_CALLOUT        0x00000004u  /* C       */\n#define PCRE2_CASELESS            0x00000008u  /* C       */\n#define PCRE2_DOLLAR_ENDONLY      0x00000010u  /*   J M D */\n#define PCRE2_DOTALL              0x00000020u  /* C       */\n#define PCRE2_DUPNAMES            0x00000040u  /* C       */\n#define PCRE2_EXTENDED            0x00000080u  /* C       */\n#define PCRE2_FIRSTLINE           0x00000100u  /*   J M D */\n#define PCRE2_MATCH_UNSET_BACKREF 0x00000200u  /* C J M   */\n#define PCRE2_MULTILINE           0x00000400u  /* C       */\n#define PCRE2_NEVER_UCP           0x00000800u  /* C       */\n#define PCRE2_NEVER_UTF           0x00001000u  /* C       */\n#define PCRE2_NO_AUTO_CAPTURE     0x00002000u  /* C       */\n#define PCRE2_NO_AUTO_POSSESS     0x00004000u  /* C       */\n#define PCRE2_NO_DOTSTAR_ANCHOR   0x00008000u  /* C       */\n#define PCRE2_NO_START_OPTIMIZE   0x00010000u  /*   J M D */\n#define PCRE2_UCP                 0x00020000u  /* C J M D */\n#define PCRE2_UNGREEDY            0x00040000u  /* C       */\n#define PCRE2_UTF                 0x00080000u  /* C J M D */\n#define PCRE2_NEVER_BACKSLASH_C   0x00100000u  /* C       */\n#define PCRE2_ALT_CIRCUMFLEX      0x00200000u  /*   J M D */\n#define PCRE2_ALT_VERBNAMES       0x00400000u  /* C       */\n#define PCRE2_USE_OFFSET_LIMIT    0x00800000u  /*   J M D */\n#define PCRE2_EXTENDED_MORE       0x01000000u  /* C       */\n#define PCRE2_LITERAL             0x02000000u  /* C       */\n#define PCRE2_MATCH_INVALID_UTF   0x04000000u  /*   J M D */\n\n/* An additional compile options word is available in the compile context. */\n\n#define PCRE2_EXTRA_ALLOW_SURROGATE_ESCAPES  0x00000001u  /* C */\n#define PCRE2_EXTRA_BAD_ESCAPE_IS_LITERAL    0x00000002u  /* C */\n#define PCRE2_EXTRA_MATCH_WORD               0x00000004u  /* C */\n#define PCRE2_EXTRA_MATCH_LINE               0x00000008u  /* C */\n#define PCRE2_EXTRA_ESCAPED_CR_IS_LF         0x00000010u  /* C */\n#define PCRE2_EXTRA_ALT_BSUX                 0x00000020u  /* C */\n\n/* These are for pcre2_jit_compile(). */\n\n#define PCRE2_JIT_COMPLETE        0x00000001u  /* For full matching */\n#define PCRE2_JIT_PARTIAL_SOFT    0x00000002u\n#define PCRE2_JIT_PARTIAL_HARD    0x00000004u\n#define PCRE2_JIT_INVALID_UTF     0x00000100u\n\n/* These are for pcre2_match(), pcre2_dfa_match(), pcre2_jit_match(), and\npcre2_substitute(). Some are allowed only for one of the functions, and in\nthese cases it is noted below. Note that PCRE2_ANCHORED, PCRE2_ENDANCHORED and\nPCRE2_NO_UTF_CHECK can also be passed to these functions (though\npcre2_jit_match() ignores the latter since it bypasses all sanity checks). */\n\n#define PCRE2_NOTBOL                      0x00000001u\n#define PCRE2_NOTEOL                      0x00000002u\n#define PCRE2_NOTEMPTY                    0x00000004u  /* ) These two must be kept */\n#define PCRE2_NOTEMPTY_ATSTART            0x00000008u  /* ) adjacent to each other. */\n#define PCRE2_PARTIAL_SOFT                0x00000010u\n#define PCRE2_PARTIAL_HARD                0x00000020u\n#define PCRE2_DFA_RESTART                 0x00000040u  /* pcre2_dfa_match() only */\n#define PCRE2_DFA_SHORTEST                0x00000080u  /* pcre2_dfa_match() only */\n#define PCRE2_SUBSTITUTE_GLOBAL           0x00000100u  /* pcre2_substitute() only */\n#define PCRE2_SUBSTITUTE_EXTENDED         0x00000200u  /* pcre2_substitute() only */\n#define PCRE2_SUBSTITUTE_UNSET_EMPTY      0x00000400u  /* pcre2_substitute() only */\n#define PCRE2_SUBSTITUTE_UNKNOWN_UNSET    0x00000800u  /* pcre2_substitute() only */\n#define PCRE2_SUBSTITUTE_OVERFLOW_LENGTH  0x00001000u  /* pcre2_substitute() only */\n#define PCRE2_NO_JIT                      0x00002000u  /* Not for pcre2_dfa_match() */\n#define PCRE2_COPY_MATCHED_SUBJECT        0x00004000u\n#define PCRE2_SUBSTITUTE_LITERAL          0x00008000u  /* pcre2_substitute() only */\n#define PCRE2_SUBSTITUTE_MATCHED          0x00010000u  /* pcre2_substitute() only */\n#define PCRE2_SUBSTITUTE_REPLACEMENT_ONLY 0x00020000u  /* pcre2_substitute() only */\n\n/* Options for pcre2_pattern_convert(). */\n\n#define PCRE2_CONVERT_UTF                    0x00000001u\n#define PCRE2_CONVERT_NO_UTF_CHECK           0x00000002u\n#define PCRE2_CONVERT_POSIX_BASIC            0x00000004u\n#define PCRE2_CONVERT_POSIX_EXTENDED         0x00000008u\n#define PCRE2_CONVERT_GLOB                   0x00000010u\n#define PCRE2_CONVERT_GLOB_NO_WILD_SEPARATOR 0x00000030u\n#define PCRE2_CONVERT_GLOB_NO_STARSTAR       0x00000050u\n\n/* Newline and \\R settings, for use in compile contexts. The newline values\nmust be kept in step with values set in config.h and both sets must all be\ngreater than zero. */\n\n#define PCRE2_NEWLINE_CR          1\n#define PCRE2_NEWLINE_LF          2\n#define PCRE2_NEWLINE_CRLF        3\n#define PCRE2_NEWLINE_ANY         4\n#define PCRE2_NEWLINE_ANYCRLF     5\n#define PCRE2_NEWLINE_NUL         6\n\n#define PCRE2_BSR_UNICODE         1\n#define PCRE2_BSR_ANYCRLF         2\n\n/* Error codes for pcre2_compile(). Some of these are also used by\npcre2_pattern_convert(). */\n\n#define PCRE2_ERROR_END_BACKSLASH                  101\n#define PCRE2_ERROR_END_BACKSLASH_C                102\n#define PCRE2_ERROR_UNKNOWN_ESCAPE                 103\n#define PCRE2_ERROR_QUANTIFIER_OUT_OF_ORDER        104\n#define PCRE2_ERROR_QUANTIFIER_TOO_BIG             105\n#define PCRE2_ERROR_MISSING_SQUARE_BRACKET         106\n#define PCRE2_ERROR_ESCAPE_INVALID_IN_CLASS        107\n#define PCRE2_ERROR_CLASS_RANGE_ORDER              108\n#define PCRE2_ERROR_QUANTIFIER_INVALID             109\n#define PCRE2_ERROR_INTERNAL_UNEXPECTED_REPEAT     110\n#define PCRE2_ERROR_INVALID_AFTER_PARENS_QUERY     111\n#define PCRE2_ERROR_POSIX_CLASS_NOT_IN_CLASS       112\n#define PCRE2_ERROR_POSIX_NO_SUPPORT_COLLATING     113\n#define PCRE2_ERROR_MISSING_CLOSING_PARENTHESIS    114\n#define PCRE2_ERROR_BAD_SUBPATTERN_REFERENCE       115\n#define PCRE2_ERROR_NULL_PATTERN                   116\n#define PCRE2_ERROR_BAD_OPTIONS                    117\n#define PCRE2_ERROR_MISSING_COMMENT_CLOSING        118\n#define PCRE2_ERROR_PARENTHESES_NEST_TOO_DEEP      119\n#define PCRE2_ERROR_PATTERN_TOO_LARGE              120\n#define PCRE2_ERROR_HEAP_FAILED                    121\n#define PCRE2_ERROR_UNMATCHED_CLOSING_PARENTHESIS  122\n#define PCRE2_ERROR_INTERNAL_CODE_OVERFLOW         123\n#define PCRE2_ERROR_MISSING_CONDITION_CLOSING      124\n#define PCRE2_ERROR_LOOKBEHIND_NOT_FIXED_LENGTH    125\n#define PCRE2_ERROR_ZERO_RELATIVE_REFERENCE        126\n#define PCRE2_ERROR_TOO_MANY_CONDITION_BRANCHES    127\n#define PCRE2_ERROR_CONDITION_ASSERTION_EXPECTED   128\n#define PCRE2_ERROR_BAD_RELATIVE_REFERENCE         129\n#define PCRE2_ERROR_UNKNOWN_POSIX_CLASS            130\n#define PCRE2_ERROR_INTERNAL_STUDY_ERROR           131\n#define PCRE2_ERROR_UNICODE_NOT_SUPPORTED          132\n#define PCRE2_ERROR_PARENTHESES_STACK_CHECK        133\n#define PCRE2_ERROR_CODE_POINT_TOO_BIG             134\n#define PCRE2_ERROR_LOOKBEHIND_TOO_COMPLICATED     135\n#define PCRE2_ERROR_LOOKBEHIND_INVALID_BACKSLASH_C 136\n#define PCRE2_ERROR_UNSUPPORTED_ESCAPE_SEQUENCE    137\n#define PCRE2_ERROR_CALLOUT_NUMBER_TOO_BIG         138\n#define PCRE2_ERROR_MISSING_CALLOUT_CLOSING        139\n#define PCRE2_ERROR_ESCAPE_INVALID_IN_VERB         140\n#define PCRE2_ERROR_UNRECOGNIZED_AFTER_QUERY_P     141\n#define PCRE2_ERROR_MISSING_NAME_TERMINATOR        142\n#define PCRE2_ERROR_DUPLICATE_SUBPATTERN_NAME      143\n#define PCRE2_ERROR_INVALID_SUBPATTERN_NAME        144\n#define PCRE2_ERROR_UNICODE_PROPERTIES_UNAVAILABLE 145\n#define PCRE2_ERROR_MALFORMED_UNICODE_PROPERTY     146\n#define PCRE2_ERROR_UNKNOWN_UNICODE_PROPERTY       147\n#define PCRE2_ERROR_SUBPATTERN_NAME_TOO_LONG       148\n#define PCRE2_ERROR_TOO_MANY_NAMED_SUBPATTERNS     149\n#define PCRE2_ERROR_CLASS_INVALID_RANGE            150\n#define PCRE2_ERROR_OCTAL_BYTE_TOO_BIG             151\n#define PCRE2_ERROR_INTERNAL_OVERRAN_WORKSPACE     152\n#define PCRE2_ERROR_INTERNAL_MISSING_SUBPATTERN    153\n#define PCRE2_ERROR_DEFINE_TOO_MANY_BRANCHES       154\n#define PCRE2_ERROR_BACKSLASH_O_MISSING_BRACE      155\n#define PCRE2_ERROR_INTERNAL_UNKNOWN_NEWLINE       156\n#define PCRE2_ERROR_BACKSLASH_G_SYNTAX             157\n#define PCRE2_ERROR_PARENS_QUERY_R_MISSING_CLOSING 158\n/* Error 159 is obsolete and should now never occur */\n#define PCRE2_ERROR_VERB_ARGUMENT_NOT_ALLOWED      159\n#define PCRE2_ERROR_VERB_UNKNOWN                   160\n#define PCRE2_ERROR_SUBPATTERN_NUMBER_TOO_BIG      161\n#define PCRE2_ERROR_SUBPATTERN_NAME_EXPECTED       162\n#define PCRE2_ERROR_INTERNAL_PARSED_OVERFLOW       163\n#define PCRE2_ERROR_INVALID_OCTAL                  164\n#define PCRE2_ERROR_SUBPATTERN_NAMES_MISMATCH      165\n#define PCRE2_ERROR_MARK_MISSING_ARGUMENT          166\n#define PCRE2_ERROR_INVALID_HEXADECIMAL            167\n#define PCRE2_ERROR_BACKSLASH_C_SYNTAX             168\n#define PCRE2_ERROR_BACKSLASH_K_SYNTAX             169\n#define PCRE2_ERROR_INTERNAL_BAD_CODE_LOOKBEHINDS  170\n#define PCRE2_ERROR_BACKSLASH_N_IN_CLASS           171\n#define PCRE2_ERROR_CALLOUT_STRING_TOO_LONG        172\n#define PCRE2_ERROR_UNICODE_DISALLOWED_CODE_POINT  173\n#define PCRE2_ERROR_UTF_IS_DISABLED                174\n#define PCRE2_ERROR_UCP_IS_DISABLED                175\n#define PCRE2_ERROR_VERB_NAME_TOO_LONG             176\n#define PCRE2_ERROR_BACKSLASH_U_CODE_POINT_TOO_BIG 177\n#define PCRE2_ERROR_MISSING_OCTAL_OR_HEX_DIGITS    178\n#define PCRE2_ERROR_VERSION_CONDITION_SYNTAX       179\n#define PCRE2_ERROR_INTERNAL_BAD_CODE_AUTO_POSSESS 180\n#define PCRE2_ERROR_CALLOUT_NO_STRING_DELIMITER    181\n#define PCRE2_ERROR_CALLOUT_BAD_STRING_DELIMITER   182\n#define PCRE2_ERROR_BACKSLASH_C_CALLER_DISABLED    183\n#define PCRE2_ERROR_QUERY_BARJX_NEST_TOO_DEEP      184\n#define PCRE2_ERROR_BACKSLASH_C_LIBRARY_DISABLED   185\n#define PCRE2_ERROR_PATTERN_TOO_COMPLICATED        186\n#define PCRE2_ERROR_LOOKBEHIND_TOO_LONG            187\n#define PCRE2_ERROR_PATTERN_STRING_TOO_LONG        188\n#define PCRE2_ERROR_INTERNAL_BAD_CODE              189\n#define PCRE2_ERROR_INTERNAL_BAD_CODE_IN_SKIP      190\n#define PCRE2_ERROR_NO_SURROGATES_IN_UTF16         191\n#define PCRE2_ERROR_BAD_LITERAL_OPTIONS            192\n#define PCRE2_ERROR_SUPPORTED_ONLY_IN_UNICODE      193\n#define PCRE2_ERROR_INVALID_HYPHEN_IN_OPTIONS      194\n#define PCRE2_ERROR_ALPHA_ASSERTION_UNKNOWN        195\n#define PCRE2_ERROR_SCRIPT_RUN_NOT_AVAILABLE       196\n#define PCRE2_ERROR_TOO_MANY_CAPTURES              197\n#define PCRE2_ERROR_CONDITION_ATOMIC_ASSERTION_EXPECTED  198\n\n\n/* \"Expected\" matching error codes: no match and partial match. */\n\n#define PCRE2_ERROR_NOMATCH          (-1)\n#define PCRE2_ERROR_PARTIAL          (-2)\n\n/* Error codes for UTF-8 validity checks */\n\n#define PCRE2_ERROR_UTF8_ERR1        (-3)\n#define PCRE2_ERROR_UTF8_ERR2        (-4)\n#define PCRE2_ERROR_UTF8_ERR3        (-5)\n#define PCRE2_ERROR_UTF8_ERR4        (-6)\n#define PCRE2_ERROR_UTF8_ERR5        (-7)\n#define PCRE2_ERROR_UTF8_ERR6        (-8)\n#define PCRE2_ERROR_UTF8_ERR7        (-9)\n#define PCRE2_ERROR_UTF8_ERR8       (-10)\n#define PCRE2_ERROR_UTF8_ERR9       (-11)\n#define PCRE2_ERROR_UTF8_ERR10      (-12)\n#define PCRE2_ERROR_UTF8_ERR11      (-13)\n#define PCRE2_ERROR_UTF8_ERR12      (-14)\n#define PCRE2_ERROR_UTF8_ERR13      (-15)\n#define PCRE2_ERROR_UTF8_ERR14      (-16)\n#define PCRE2_ERROR_UTF8_ERR15      (-17)\n#define PCRE2_ERROR_UTF8_ERR16      (-18)\n#define PCRE2_ERROR_UTF8_ERR17      (-19)\n#define PCRE2_ERROR_UTF8_ERR18      (-20)\n#define PCRE2_ERROR_UTF8_ERR19      (-21)\n#define PCRE2_ERROR_UTF8_ERR20      (-22)\n#define PCRE2_ERROR_UTF8_ERR21      (-23)\n\n/* Error codes for UTF-16 validity checks */\n\n#define PCRE2_ERROR_UTF16_ERR1      (-24)\n#define PCRE2_ERROR_UTF16_ERR2      (-25)\n#define PCRE2_ERROR_UTF16_ERR3      (-26)\n\n/* Error codes for UTF-32 validity checks */\n\n#define PCRE2_ERROR_UTF32_ERR1      (-27)\n#define PCRE2_ERROR_UTF32_ERR2      (-28)\n\n/* Miscellaneous error codes for pcre2\u00dd_dfa\u00a8_match(), substring extraction\nfunctions, context functions, and serializing functions. They are in numerical\norder. Originally they were in alphabetical order too, but now that PCRE2 is\nreleased, the numbers must not be changed. */\n\n#define PCRE2_ERROR_BADDATA           (-29)\n#define PCRE2_ERROR_MIXEDTABLES       (-30)  /* Name was changed */\n#define PCRE2_ERROR_BADMAGIC          (-31)\n#define PCRE2_ERROR_BADMODE           (-32)\n#define PCRE2_ERROR_BADOFFSET         (-33)\n#define PCRE2_ERROR_BADOPTION         (-34)\n#define PCRE2_ERROR_BADREPLACEMENT    (-35)\n#define PCRE2_ERROR_BADUTFOFFSET      (-36)\n#define PCRE2_ERROR_CALLOUT           (-37)  /* Never used by PCRE2 itself */\n#define PCRE2_ERROR_DFA_BADRESTART    (-38)\n#define PCRE2_ERROR_DFA_RECURSE       (-39)\n#define PCRE2_ERROR_DFA_UCOND         (-40)\n#define PCRE2_ERROR_DFA_UFUNC         (-41)\n#define PCRE2_ERROR_DFA_UITEM         (-42)\n#define PCRE2_ERROR_DFA_WSSIZE        (-43)\n#define PCRE2_ERROR_INTERNAL          (-44)\n#define PCRE2_ERROR_JIT_BADOPTION     (-45)\n#define PCRE2_ERROR_JIT_STACKLIMIT    (-46)\n#define PCRE2_ERROR_MATCHLIMIT        (-47)\n#define PCRE2_ERROR_NOMEMORY          (-48)\n#define PCRE2_ERROR_NOSUBSTRING       (-49)\n#define PCRE2_ERROR_NOUNIQUESUBSTRING (-50)\n#define PCRE2_ERROR_NULL              (-51)\n#define PCRE2_ERROR_RECURSELOOP       (-52)\n#define PCRE2_ERROR_DEPTHLIMIT        (-53)\n#define PCRE2_ERROR_RECURSIONLIMIT    (-53)  /* Obsolete synonym */\n#define PCRE2_ERROR_UNAVAILABLE       (-54)\n#define PCRE2_ERROR_UNSET             (-55)\n#define PCRE2_ERROR_BADOFFSETLIMIT    (-56)\n#define PCRE2_ERROR_BADREPESCAPE      (-57)\n#define PCRE2_ERROR_REPMISSINGBRACE   (-58)\n#define PCRE2_ERROR_BADSUBSTITUTION   (-59)\n#define PCRE2_ERROR_BADSUBSPATTERN    (-60)\n#define PCRE2_ERROR_TOOMANYREPLACE    (-61)\n#define PCRE2_ERROR_BADSERIALIZEDDATA (-62)\n#define PCRE2_ERROR_HEAPLIMIT         (-63)\n#define PCRE2_ERROR_CONVERT_SYNTAX    (-64)\n#define PCRE2_ERROR_INTERNAL_DUPMATCH (-65)\n#define PCRE2_ERROR_DFA_UINVALID_UTF  (-66)\n\n\n/* Request types for pcre2_pattern_info() */\n\n#define PCRE2_INFO_ALLOPTIONS            0\n#define PCRE2_INFO_ARGOPTIONS            1\n#define PCRE2_INFO_BACKREFMAX            2\n#define PCRE2_INFO_BSR                   3\n#define PCRE2_INFO_CAPTURECOUNT          4\n#define PCRE2_INFO_FIRSTCODEUNIT         5\n#define PCRE2_INFO_FIRSTCODETYPE         6\n#define PCRE2_INFO_FIRSTBITMAP           7\n#define PCRE2_INFO_HASCRORLF             8\n#define PCRE2_INFO_JCHANGED              9\n#define PCRE2_INFO_JITSIZE              10\n#define PCRE2_INFO_LASTCODEUNIT         11\n#define PCRE2_INFO_LASTCODETYPE         12\n#define PCRE2_INFO_MATCHEMPTY           13\n#define PCRE2_INFO_MATCHLIMIT           14\n#define PCRE2_INFO_MAXLOOKBEHIND        15\n#define PCRE2_INFO_MINLENGTH            16\n#define PCRE2_INFO_NAMECOUNT            17\n#define PCRE2_INFO_NAMEENTRYSIZE        18\n#define PCRE2_INFO_NAMETABLE            19\n#define PCRE2_INFO_NEWLINE              20\n#define PCRE2_INFO_DEPTHLIMIT           21\n#define PCRE2_INFO_RECURSIONLIMIT       21  /* Obsolete synonym */\n#define PCRE2_INFO_SIZE                 22\n#define PCRE2_INFO_HASBACKSLASHC        23\n#define PCRE2_INFO_FRAMESIZE            24\n#define PCRE2_INFO_HEAPLIMIT            25\n#define PCRE2_INFO_EXTRAOPTIONS         26\n\n/* Request types for pcre2_config(). */\n\n#define PCRE2_CONFIG_BSR                     0\n#define PCRE2_CONFIG_JIT                     1\n#define PCRE2_CONFIG_JITTARGET               2\n#define PCRE2_CONFIG_LINKSIZE                3\n#define PCRE2_CONFIG_MATCHLIMIT              4\n#define PCRE2_CONFIG_NEWLINE                 5\n#define PCRE2_CONFIG_PARENSLIMIT             6\n#define PCRE2_CONFIG_DEPTHLIMIT              7\n#define PCRE2_CONFIG_RECURSIONLIMIT          7  /* Obsolete synonym */\n#define PCRE2_CONFIG_STACKRECURSE            8  /* Obsolete */\n#define PCRE2_CONFIG_UNICODE                 9\n#define PCRE2_CONFIG_UNICODE_VERSION        10\n#define PCRE2_CONFIG_VERSION                11\n#define PCRE2_CONFIG_HEAPLIMIT              12\n#define PCRE2_CONFIG_NEVER_BACKSLASH_C      13\n#define PCRE2_CONFIG_COMPILED_WIDTHS        14\n#define PCRE2_CONFIG_TABLES_LENGTH          15\n\n\n/* Types for code units in patterns and subject strings. */\n\ntypedef uint8_t  PCRE2_UCHAR8;\ntypedef uint16_t PCRE2_UCHAR16;\ntypedef uint32_t PCRE2_UCHAR32;\n\ntypedef const PCRE2_UCHAR8  *PCRE2_SPTR8;\ntypedef const PCRE2_UCHAR16 *PCRE2_SPTR16;\ntypedef const PCRE2_UCHAR32 *PCRE2_SPTR32;\n\n/* The PCRE2_SIZE type is used for all string lengths and offsets in PCRE2,\nincluding pattern offsets for errors and subject offsets after a match. We\ndefine special values to indicate zero-terminated strings and unset offsets in\nthe offset vector (ovector). */\n\n#define PCRE2_SIZE            size_t\n#define PCRE2_SIZE_MAX        SIZE_MAX\n#define PCRE2_ZERO_TERMINATED (~(PCRE2_SIZE)0)\n#define PCRE2_UNSET           (~(PCRE2_SIZE)0)\n\n/* Generic types for opaque structures and JIT callback functions. These\ndeclarations are defined in a macro that is expanded for each width later. */\n\n#define PCRE2_TYPES_LIST \\\nstruct pcre2_real_general_context; \\\ntypedef struct pcre2_real_general_context pcre2_general_context; \\\n\\\nstruct pcre2_real_compile_context; \\\ntypedef struct pcre2_real_compile_context pcre2_compile_context; \\\n\\\nstruct pcre2_real_match_context; \\\ntypedef struct pcre2_real_match_context pcre2_match_context; \\\n\\\nstruct pcre2_real_convert_context; \\\ntypedef struct pcre2_real_convert_context pcre2_convert_context; \\\n\\\nstruct pcre2_real_code; \\\ntypedef struct pcre2_real_code pcre2_code; \\\n\\\nstruct pcre2_real_match_data; \\\ntypedef struct pcre2_real_match_data pcre2_match_data; \\\n\\\nstruct pcre2_real_jit_stack; \\\ntypedef struct pcre2_real_jit_stack pcre2_jit_stack; \\\n\\\ntypedef pcre2_jit_stack *(*pcre2_jit_callback)(void *);\n\n\n/* The structures for passing out data via callout functions. We use structures\nso that new fields can be added on the end in future versions, without changing\nthe API of the function, thereby allowing old clients to work without\nmodification. Define the generic versions in a macro; the width-specific\nversions are generated from this macro below. */\n\n/* Flags for the callout_flags field. These are cleared after a callout. */\n\n#define PCRE2_CALLOUT_STARTMATCH    0x00000001u  /* Set for each bumpalong */\n#define PCRE2_CALLOUT_BACKTRACK     0x00000002u  /* Set after a backtrack */\n\n#define PCRE2_STRUCTURE_LIST \\\ntypedef struct pcre2_callout_block { \\\n  uint32_t      version;           /* Identifies version of block */ \\\n  /* ------------------------ Version 0 ------------------------------- */ \\\n  uint32_t      callout_number;    /* Number compiled into pattern */ \\\n  uint32_t      capture_top;       /* Max current capture */ \\\n  uint32_t      capture_last;      /* Most recently closed capture */ \\\n  PCRE2_SIZE   *offset_vector;     /* The offset vector */ \\\n  PCRE2_SPTR    mark;              /* Pointer to current mark or NULL */ \\\n  PCRE2_SPTR    subject;           /* The subject being matched */ \\\n  PCRE2_SIZE    subject_length;    /* The length of the subject */ \\\n  PCRE2_SIZE    start_match;       /* Offset to start of this match attempt */ \\\n  PCRE2_SIZE    current_position;  /* Where we currently are in the subject */ \\\n  PCRE2_SIZE    pattern_position;  /* Offset to next item in the pattern */ \\\n  PCRE2_SIZE    next_item_length;  /* Length of next item in the pattern */ \\\n  /* ------------------- Added for Version 1 -------------------------- */ \\\n  PCRE2_SIZE    callout_string_offset; /* Offset to string within pattern */ \\\n  PCRE2_SIZE    callout_string_length; /* Length of string compiled into pattern */ \\\n  PCRE2_SPTR    callout_string;    /* String compiled into pattern */ \\\n  /* ------------------- Added for Version 2 -------------------------- */ \\\n  uint32_t      callout_flags;     /* See above for list */ \\\n  /* ------------------------------------------------------------------ */ \\\n} pcre2_callout_block; \\\n\\\ntypedef struct pcre2_callout_enumerate_block { \\\n  uint32_t      version;           /* Identifies version of block */ \\\n  /* ------------------------ Version 0 ------------------------------- */ \\\n  PCRE2_SIZE    pattern_position;  /* Offset to next item in the pattern */ \\\n  PCRE2_SIZE    next_item_length;  /* Length of next item in the pattern */ \\\n  uint32_t      callout_number;    /* Number compiled into pattern */ \\\n  PCRE2_SIZE    callout_string_offset; /* Offset to string within pattern */ \\\n  PCRE2_SIZE    callout_string_length; /* Length of string compiled into pattern */ \\\n  PCRE2_SPTR    callout_string;    /* String compiled into pattern */ \\\n  /* ------------------------------------------------------------------ */ \\\n} pcre2_callout_enumerate_block; \\\n\\\ntypedef struct pcre2_substitute_callout_block { \\\n  uint32_t      version;           /* Identifies version of block */ \\\n  /* ------------------------ Version 0 ------------------------------- */ \\\n  PCRE2_SPTR    input;             /* Pointer to input subject string */ \\\n  PCRE2_SPTR    output;            /* Pointer to output buffer */ \\\n  PCRE2_SIZE    output_offsets\u00dd2\u00a8; /* Changed portion of the output */ \\\n  PCRE2_SIZE   *ovector;           /* Pointer to current ovector */ \\\n  uint32_t      oveccount;         /* Count of pairs set in ovector */ \\\n  uint32_t      subscount;         /* Substitution number */ \\\n  /* ------------------------------------------------------------------ */ \\\n} pcre2_substitute_callout_block;\n\n\n/* List the generic forms of all other functions in macros, which will be\nexpanded for each width below. Start with functions that give general\ninformation. */\n\n#define PCRE2_GENERAL_INFO_FUNCTIONS \\\nPCRE2_EXP_DECL int PCRE2_CALL_CONVENTION pcre2_config(uint32_t, void *);\n\n\n/* Functions for manipulating contexts. */\n\n#define PCRE2_GENERAL_CONTEXT_FUNCTIONS \\\nPCRE2_EXP_DECL pcre2_general_context PCRE2_CALL_CONVENTION \\\n  *pcre2_general_context_copy(pcre2_general_context *); \\\nPCRE2_EXP_DECL pcre2_general_context PCRE2_CALL_CONVENTION \\\n  *pcre2_general_context_create(void *(*)(PCRE2_SIZE, void *), \\\n    void (*)(void *, void *), void *); \\\nPCRE2_EXP_DECL void PCRE2_CALL_CONVENTION \\\n  pcre2_general_context_free(pcre2_general_context *);\n\n#define PCRE2_COMPILE_CONTEXT_FUNCTIONS \\\nPCRE2_EXP_DECL pcre2_compile_context PCRE2_CALL_CONVENTION \\\n  *pcre2_compile_context_copy(pcre2_compile_context *); \\\nPCRE2_EXP_DECL pcre2_compile_context PCRE2_CALL_CONVENTION \\\n  *pcre2_compile_context_create(pcre2_general_context *);\\\nPCRE2_EXP_DECL void PCRE2_CALL_CONVENTION \\\n  pcre2_compile_context_free(pcre2_compile_context *); \\\nPCRE2_EXP_DECL int PCRE2_CALL_CONVENTION \\\n  pcre2_set_bsr(pcre2_compile_context *, uint32_t); \\\nPCRE2_EXP_DECL int PCRE2_CALL_CONVENTION \\\n  pcre2_set_character_tables(pcre2_compile_context *, const uint8_t *); \\\nPCRE2_EXP_DECL int PCRE2_CALL_CONVENTION \\\n  pcre2_set_compile_extra_options(pcre2_compile_context *, uint32_t); \\\nPCRE2_EXP_DECL int PCRE2_CALL_CONVENTION \\\n  pcre2_set_max_pattern_length(pcre2_compile_context *, PCRE2_SIZE); \\\nPCRE2_EXP_DECL int PCRE2_CALL_CONVENTION \\\n  pcre2_set_newline(pcre2_compile_context *, uint32_t); \\\nPCRE2_EXP_DECL int PCRE2_CALL_CONVENTION \\\n  pcre2_set_parens_nest_limit(pcre2_compile_context *, uint32_t); \\\nPCRE2_EXP_DECL int PCRE2_CALL_CONVENTION \\\n  pcre2_set_compile_recursion_guard(pcre2_compile_context *, \\\n    int (*)(uint32_t, void *), void *);\n\n#define PCRE2_MATCH_CONTEXT_FUNCTIONS \\\nPCRE2_EXP_DECL pcre2_match_context PCRE2_CALL_CONVENTION \\\n  *pcre2_match_context_copy(pcre2_match_context *); \\\nPCRE2_EXP_DECL pcre2_match_context PCRE2_CALL_CONVENTION \\\n  *pcre2_match_context_create(pcre2_general_context *); \\\nPCRE2_EXP_DECL void PCRE2_CALL_CONVENTION \\\n  pcre2_match_context_free(pcre2_match_context *); \\\nPCRE2_EXP_DECL int PCRE2_CALL_CONVENTION \\\n  pcre2_set_callout(pcre2_match_context *, \\\n    int (*)(pcre2_callout_block *, void *), void *); \\\nPCRE2_EXP_DECL int PCRE2_CALL_CONVENTION \\\n  pcre2_set_substitute_callout(pcre2_match_context *, \\\n    int (*)(pcre2_substitute_callout_block *, void *), void *); \\\nPCRE2_EXP_DECL int PCRE2_CALL_CONVENTION \\\n  pcre2_set_depth_limit(pcre2_match_context *, uint32_t); \\\nPCRE2_EXP_DECL int PCRE2_CALL_CONVENTION \\\n  pcre2_set_heap_limit(pcre2_match_context *, uint32_t); \\\nPCRE2_EXP_DECL int PCRE2_CALL_CONVENTION \\\n  pcre2_set_match_limit(pcre2_match_context *, uint32_t); \\\nPCRE2_EXP_DECL int PCRE2_CALL_CONVENTION \\\n  pcre2_set_offset_limit(pcre2_match_context *, PCRE2_SIZE); \\\nPCRE2_EXP_DECL int PCRE2_CALL_CONVENTION \\\n  pcre2_set_recursion_limit(pcre2_match_context *, uint32_t); \\\nPCRE2_EXP_DECL int PCRE2_CALL_CONVENTION \\\n  pcre2_set_recursion_memory_management(pcre2_match_context *, \\\n    void *(*)(PCRE2_SIZE, void *), void (*)(void *, void *), void *);\n\n#define PCRE2_CONVERT_CONTEXT_FUNCTIONS \\\nPCRE2_EXP_DECL pcre2_convert_context PCRE2_CALL_CONVENTION \\\n  *pcre2_convert_context_copy(pcre2_convert_context *); \\\nPCRE2_EXP_DECL pcre2_convert_context PCRE2_CALL_CONVENTION \\\n  *pcre2_convert_context_create(pcre2_general_context *); \\\nPCRE2_EXP_DECL void PCRE2_CALL_CONVENTION \\\n  pcre2_convert_context_free(pcre2_convert_context *); \\\nPCRE2_EXP_DECL int PCRE2_CALL_CONVENTION \\\n  pcre2_set_glob_escape(pcre2_convert_context *, uint32_t); \\\nPCRE2_EXP_DECL int PCRE2_CALL_CONVENTION \\\n  pcre2_set_glob_separator(pcre2_convert_context *, uint32_t);\n\n\n/* Functions concerned with compiling a pattern to PCRE internal code. */\n\n#define PCRE2_COMPILE_FUNCTIONS \\\nPCRE2_EXP_DECL pcre2_code PCRE2_CALL_CONVENTION \\\n  *pcre2_compile(PCRE2_SPTR, PCRE2_SIZE, uint32_t, int *, PCRE2_SIZE *, \\\n    pcre2_compile_context *); \\\nPCRE2_EXP_DECL void PCRE2_CALL_CONVENTION \\\n  pcre2_code_free(pcre2_code *); \\\nPCRE2_EXP_DECL pcre2_code PCRE2_CALL_CONVENTION \\\n  *pcre2_code_copy(const pcre2_code *); \\\nPCRE2_EXP_DECL pcre2_code PCRE2_CALL_CONVENTION \\\n  *pcre2_code_copy_with_tables(const pcre2_code *);\n\n\n/* Functions that give information about a compiled pattern. */\n\n#define PCRE2_PATTERN_INFO_FUNCTIONS \\\nPCRE2_EXP_DECL int PCRE2_CALL_CONVENTION \\\n  pcre2_pattern_info(const pcre2_code *, uint32_t, void *); \\\nPCRE2_EXP_DECL int PCRE2_CALL_CONVENTION \\\n  pcre2_callout_enumerate(const pcre2_code *, \\\n    int (*)(pcre2_callout_enumerate_block *, void *), void *);\n\n\n/* Functions for running a match and inspecting the result. */\n\n#define PCRE2_MATCH_FUNCTIONS \\\nPCRE2_EXP_DECL pcre2_match_data PCRE2_CALL_CONVENTION \\\n  *pcre2_match_data_create(uint32_t, pcre2_general_context *); \\\nPCRE2_EXP_DECL pcre2_match_data PCRE2_CALL_CONVENTION \\\n  *pcre2_match_data_create_from_pattern(const pcre2_code *, \\\n    pcre2_general_context *); \\\nPCRE2_EXP_DECL int PCRE2_CALL_CONVENTION \\\n  pcre2_dfa_match(const pcre2_code *, PCRE2_SPTR, PCRE2_SIZE, PCRE2_SIZE, \\\n    uint32_t, pcre2_match_data *, pcre2_match_context *, int *, PCRE2_SIZE); \\\nPCRE2_EXP_DECL int PCRE2_CALL_CONVENTION \\\n  pcre2_match(const pcre2_code *, PCRE2_SPTR, PCRE2_SIZE, PCRE2_SIZE, \\\n    uint32_t, pcre2_match_data *, pcre2_match_context *); \\\nPCRE2_EXP_DECL void PCRE2_CALL_CONVENTION \\\n  pcre2_match_data_free(pcre2_match_data *); \\\nPCRE2_EXP_DECL PCRE2_SPTR PCRE2_CALL_CONVENTION \\\n  pcre2_get_mark(pcre2_match_data *); \\\nPCRE2_EXP_DECL PCRE2_SIZE PCRE2_CALL_CONVENTION \\\n  pcre2_get_match_data_size(pcre2_match_data *); \\\nPCRE2_EXP_DECL uint32_t PCRE2_CALL_CONVENTION \\\n  pcre2_get_ovector_count(pcre2_match_data *); \\\nPCRE2_EXP_DECL PCRE2_SIZE PCRE2_CALL_CONVENTION \\\n  *pcre2_get_ovector_pointer(pcre2_match_data *); \\\nPCRE2_EXP_DECL PCRE2_SIZE PCRE2_CALL_CONVENTION \\\n  pcre2_get_startchar(pcre2_match_data *);\n\n\n/* Convenience functions for handling matched substrings. */\n\n#define PCRE2_SUBSTRING_FUNCTIONS \\\nPCRE2_EXP_DECL int PCRE2_CALL_CONVENTION \\\n  pcre2_substring_copy_byname(pcre2_match_data *, PCRE2_SPTR, PCRE2_UCHAR *, \\\n    PCRE2_SIZE *); \\\nPCRE2_EXP_DECL int PCRE2_CALL_CONVENTION \\\n  pcre2_substring_copy_bynumber(pcre2_match_data *, uint32_t, PCRE2_UCHAR *, \\\n    PCRE2_SIZE *); \\\nPCRE2_EXP_DECL void PCRE2_CALL_CONVENTION \\\n  pcre2_substring_free(PCRE2_UCHAR *); \\\nPCRE2_EXP_DECL int PCRE2_CALL_CONVENTION \\\n  pcre2_substring_get_byname(pcre2_match_data *, PCRE2_SPTR, PCRE2_UCHAR **, \\\n    PCRE2_SIZE *); \\\nPCRE2_EXP_DECL int PCRE2_CALL_CONVENTION \\\n  pcre2_substring_get_bynumber(pcre2_match_data *, uint32_t, PCRE2_UCHAR **, \\\n    PCRE2_SIZE *); \\\nPCRE2_EXP_DECL int PCRE2_CALL_CONVENTION \\\n  pcre2_substring_length_byname(pcre2_match_data *, PCRE2_SPTR, PCRE2_SIZE *); \\\nPCRE2_EXP_DECL int PCRE2_CALL_CONVENTION \\\n  pcre2_substring_length_bynumber(pcre2_match_data *, uint32_t, PCRE2_SIZE *); \\\nPCRE2_EXP_DECL int PCRE2_CALL_CONVENTION \\\n  pcre2_substring_nametable_scan(const pcre2_code *, PCRE2_SPTR, PCRE2_SPTR *, \\\n    PCRE2_SPTR *); \\\nPCRE2_EXP_DECL int PCRE2_CALL_CONVENTION \\\n  pcre2_substring_number_from_name(const pcre2_code *, PCRE2_SPTR); \\\nPCRE2_EXP_DECL void PCRE2_CALL_CONVENTION \\\n  pcre2_substring_list_free(PCRE2_SPTR *); \\\nPCRE2_EXP_DECL int PCRE2_CALL_CONVENTION \\\n  pcre2_substring_list_get(pcre2_match_data *, PCRE2_UCHAR ***, PCRE2_SIZE **);\n\n/* Functions for serializing / deserializing compiled patterns. */\n\n#define PCRE2_SERIALIZE_FUNCTIONS \\\nPCRE2_EXP_DECL int32_t PCRE2_CALL_CONVENTION \\\n  pcre2_serialize_encode(const pcre2_code **, int32_t, uint8_t **, \\\n    PCRE2_SIZE *, pcre2_general_context *); \\\nPCRE2_EXP_DECL int32_t PCRE2_CALL_CONVENTION \\\n  pcre2_serialize_decode(pcre2_code **, int32_t, const uint8_t *, \\\n    pcre2_general_context *); \\\nPCRE2_EXP_DECL int32_t PCRE2_CALL_CONVENTION \\\n  pcre2_serialize_get_number_of_codes(const uint8_t *); \\\nPCRE2_EXP_DECL void PCRE2_CALL_CONVENTION \\\n  pcre2_serialize_free(uint8_t *);\n\n\n/* Convenience function for match + substitute. */\n\n#define PCRE2_SUBSTITUTE_FUNCTION \\\nPCRE2_EXP_DECL int PCRE2_CALL_CONVENTION \\\n  pcre2_substitute(const pcre2_code *, PCRE2_SPTR, PCRE2_SIZE, PCRE2_SIZE, \\\n    uint32_t, pcre2_match_data *, pcre2_match_context *, PCRE2_SPTR, \\\n    PCRE2_SIZE, PCRE2_UCHAR *, PCRE2_SIZE *);\n\n\n/* Functions for converting pattern source strings. */\n\n#define PCRE2_CONVERT_FUNCTIONS \\\nPCRE2_EXP_DECL int PCRE2_CALL_CONVENTION \\\n  pcre2_pattern_convert(PCRE2_SPTR, PCRE2_SIZE, uint32_t, PCRE2_UCHAR **, \\\n    PCRE2_SIZE *, pcre2_convert_context *); \\\nPCRE2_EXP_DECL void PCRE2_CALL_CONVENTION \\\n  pcre2_converted_pattern_free(PCRE2_UCHAR *);\n\n\n/* Functions for JIT processing */\n\n#define PCRE2_JIT_FUNCTIONS \\\nPCRE2_EXP_DECL int PCRE2_CALL_CONVENTION \\\n  pcre2_jit_compile(pcre2_code *, uint32_t); \\\nPCRE2_EXP_DECL int PCRE2_CALL_CONVENTION \\\n  pcre2_jit_match(const pcre2_code *, PCRE2_SPTR, PCRE2_SIZE, PCRE2_SIZE, \\\n    uint32_t, pcre2_match_data *, pcre2_match_context *); \\\nPCRE2_EXP_DECL void PCRE2_CALL_CONVENTION \\\n  pcre2_jit_free_unused_memory(pcre2_general_context *); \\\nPCRE2_EXP_DECL pcre2_jit_stack PCRE2_CALL_CONVENTION \\\n  *pcre2_jit_stack_create(PCRE2_SIZE, PCRE2_SIZE, pcre2_general_context *); \\\nPCRE2_EXP_DECL void PCRE2_CALL_CONVENTION \\\n  pcre2_jit_stack_assign(pcre2_match_context *, pcre2_jit_callback, void *); \\\nPCRE2_EXP_DECL void PCRE2_CALL_CONVENTION \\\n  pcre2_jit_stack_free(pcre2_jit_stack *);\n\n\n/* Other miscellaneous functions. */\n\n#define PCRE2_OTHER_FUNCTIONS \\\nPCRE2_EXP_DECL int PCRE2_CALL_CONVENTION \\\n  pcre2_get_error_message(int, PCRE2_UCHAR *, PCRE2_SIZE); \\\nPCRE2_EXP_DECL const uint8_t PCRE2_CALL_CONVENTION \\\n  *pcre2_maketables(pcre2_general_context *); \\\nPCRE2_EXP_DECL void PCRE2_CALL_CONVENTION \\\n  pcre2_maketables_free(pcre2_general_context *, const uint8_t *);\n\n/* Define macros that generate width-specific names from generic versions. The\nthree-level macro scheme is necessary to get the macros expanded when we want\nthem to be. First we get the width from PCRE2_LOCAL_WIDTH, which is used for\ngenerating three versions of everything below. After that, PCRE2_SUFFIX will be\nre-defined to use PCRE2_CODE_UNIT_WIDTH, for use when macros such as\npcre2_compile are called by application code. */\n\n#define PCRE2_JOIN(a,b) a ## b\n#define PCRE2_GLUE(a,b) PCRE2_JOIN(a,b)\n#define PCRE2_SUFFIX(a) PCRE2_GLUE(a,PCRE2_LOCAL_WIDTH)\n\n\n/* Data types */\n\n#define PCRE2_UCHAR                 PCRE2_SUFFIX(PCRE2_UCHAR)\n#define PCRE2_SPTR                  PCRE2_SUFFIX(PCRE2_SPTR)\n\n#define pcre2_code                  PCRE2_SUFFIX(pcre2_code_)\n#define pcre2_jit_callback          PCRE2_SUFFIX(pcre2_jit_callback_)\n#define pcre2_jit_stack             PCRE2_SUFFIX(pcre2_jit_stack_)\n\n#define pcre2_real_code             PCRE2_SUFFIX(pcre2_real_code_)\n#define pcre2_real_general_context  PCRE2_SUFFIX(pcre2_real_general_context_)\n#define pcre2_real_compile_context  PCRE2_SUFFIX(pcre2_real_compile_context_)\n#define pcre2_real_convert_context  PCRE2_SUFFIX(pcre2_real_convert_context_)\n#define pcre2_real_match_context    PCRE2_SUFFIX(pcre2_real_match_context_)\n#define pcre2_real_jit_stack        PCRE2_SUFFIX(pcre2_real_jit_stack_)\n#define pcre2_real_match_data       PCRE2_SUFFIX(pcre2_real_match_data_)\n\n\n/* Data blocks */\n\n#define pcre2_callout_block            PCRE2_SUFFIX(pcre2_callout_block_)\n#define pcre2_callout_enumerate_block  PCRE2_SUFFIX(pcre2_callout_enumerate_block_)\n#define pcre2_substitute_callout_block PCRE2_SUFFIX(pcre2_substitute_callout_block_)\n#define pcre2_general_context          PCRE2_SUFFIX(pcre2_general_context_)\n#define pcre2_compile_context          PCRE2_SUFFIX(pcre2_compile_context_)\n#define pcre2_convert_context          PCRE2_SUFFIX(pcre2_convert_context_)\n#define pcre2_match_context            PCRE2_SUFFIX(pcre2_match_context_)\n#define pcre2_match_data               PCRE2_SUFFIX(pcre2_match_data_)\n\n\n/* Functions: the complete list in alphabetical order */\n\n#define pcre2_callout_enumerate               PCRE2_SUFFIX(pcre2_callout_enumerate_)\n#define pcre2_code_copy                       PCRE2_SUFFIX(pcre2_code_copy_)\n#define pcre2_code_copy_with_tables           PCRE2_SUFFIX(pcre2_code_copy_with_tables_)\n#define pcre2_code_free                       PCRE2_SUFFIX(pcre2_code_free_)\n#define pcre2_compile                         PCRE2_SUFFIX(pcre2_compile_)\n#define pcre2_compile_context_copy            PCRE2_SUFFIX(pcre2_compile_context_copy_)\n#define pcre2_compile_context_create          PCRE2_SUFFIX(pcre2_compile_context_create_)\n#define pcre2_compile_context_free            PCRE2_SUFFIX(pcre2_compile_context_free_)\n#define pcre2_config                          PCRE2_SUFFIX(pcre2_config_)\n#define pcre2_convert_context_copy            PCRE2_SUFFIX(pcre2_convert_context_copy_)\n#define pcre2_convert_context_create          PCRE2_SUFFIX(pcre2_convert_context_create_)\n#define pcre2_convert_context_free            PCRE2_SUFFIX(pcre2_convert_context_free_)\n#define pcre2_converted_pattern_free          PCRE2_SUFFIX(pcre2_converted_pattern_free_)\n#define pcre2_dfa_match                       PCRE2_SUFFIX(pcre2_dfa_match_)\n#define pcre2_general_context_copy            PCRE2_SUFFIX(pcre2_general_context_copy_)\n#define pcre2_general_context_create          PCRE2_SUFFIX(pcre2_general_context_create_)\n#define pcre2_general_context_free            PCRE2_SUFFIX(pcre2_general_context_free_)\n#define pcre2_get_error_message               PCRE2_SUFFIX(pcre2_get_error_message_)\n#define pcre2_get_mark                        PCRE2_SUFFIX(pcre2_get_mark_)\n#define pcre2_get_match_data_size             PCRE2_SUFFIX(pcre2_get_match_data_size_)\n#define pcre2_get_ovector_pointer             PCRE2_SUFFIX(pcre2_get_ovector_pointer_)\n#define pcre2_get_ovector_count               PCRE2_SUFFIX(pcre2_get_ovector_count_)\n#define pcre2_get_startchar                   PCRE2_SUFFIX(pcre2_get_startchar_)\n#define pcre2_jit_compile                     PCRE2_SUFFIX(pcre2_jit_compile_)\n#define pcre2_jit_match                       PCRE2_SUFFIX(pcre2_jit_match_)\n#define pcre2_jit_free_unused_memory          PCRE2_SUFFIX(pcre2_jit_free_unused_memory_)\n#define pcre2_jit_stack_assign                PCRE2_SUFFIX(pcre2_jit_stack_assign_)\n#define pcre2_jit_stack_create                PCRE2_SUFFIX(pcre2_jit_stack_create_)\n#define pcre2_jit_stack_free                  PCRE2_SUFFIX(pcre2_jit_stack_free_)\n#define pcre2_maketables                      PCRE2_SUFFIX(pcre2_maketables_)\n#define pcre2_maketables_free                 PCRE2_SUFFIX(pcre2_maketables_free_)\n#define pcre2_match                           PCRE2_SUFFIX(pcre2_match_)\n#define pcre2_match_context_copy              PCRE2_SUFFIX(pcre2_match_context_copy_)\n#define pcre2_match_context_create            PCRE2_SUFFIX(pcre2_match_context_create_)\n#define pcre2_match_context_free              PCRE2_SUFFIX(pcre2_match_context_free_)\n#define pcre2_match_data_create               PCRE2_SUFFIX(pcre2_match_data_create_)\n#define pcre2_match_data_create_from_pattern  PCRE2_SUFFIX(pcre2_match_data_create_from_pattern_)\n#define pcre2_match_data_free                 PCRE2_SUFFIX(pcre2_match_data_free_)\n#define pcre2_pattern_convert                 PCRE2_SUFFIX(pcre2_pattern_convert_)\n#define pcre2_pattern_info                    PCRE2_SUFFIX(pcre2_pattern_info_)\n#define pcre2_serialize_decode                PCRE2_SUFFIX(pcre2_serialize_decode_)\n#define pcre2_serialize_encode                PCRE2_SUFFIX(pcre2_serialize_encode_)\n#define pcre2_serialize_free                  PCRE2_SUFFIX(pcre2_serialize_free_)\n#define pcre2_serialize_get_number_of_codes   PCRE2_SUFFIX(pcre2_serialize_get_number_of_codes_)\n#define pcre2_set_bsr                         PCRE2_SUFFIX(pcre2_set_bsr_)\n#define pcre2_set_callout                     PCRE2_SUFFIX(pcre2_set_callout_)\n#define pcre2_set_character_tables            PCRE2_SUFFIX(pcre2_set_character_tables_)\n#define pcre2_set_compile_extra_options       PCRE2_SUFFIX(pcre2_set_compile_extra_options_)\n#define pcre2_set_compile_recursion_guard     PCRE2_SUFFIX(pcre2_set_compile_recursion_guard_)\n#define pcre2_set_depth_limit                 PCRE2_SUFFIX(pcre2_set_depth_limit_)\n#define pcre2_set_glob_escape                 PCRE2_SUFFIX(pcre2_set_glob_escape_)\n#define pcre2_set_glob_separator              PCRE2_SUFFIX(pcre2_set_glob_separator_)\n#define pcre2_set_heap_limit                  PCRE2_SUFFIX(pcre2_set_heap_limit_)\n#define pcre2_set_match_limit                 PCRE2_SUFFIX(pcre2_set_match_limit_)\n#define pcre2_set_max_pattern_length          PCRE2_SUFFIX(pcre2_set_max_pattern_length_)\n#define pcre2_set_newline                     PCRE2_SUFFIX(pcre2_set_newline_)\n#define pcre2_set_parens_nest_limit           PCRE2_SUFFIX(pcre2_set_parens_nest_limit_)\n#define pcre2_set_offset_limit                PCRE2_SUFFIX(pcre2_set_offset_limit_)\n#define pcre2_set_substitute_callout          PCRE2_SUFFIX(pcre2_set_substitute_callout_)\n#define pcre2_substitute                      PCRE2_SUFFIX(pcre2_substitute_)\n#define pcre2_substring_copy_byname           PCRE2_SUFFIX(pcre2_substring_copy_byname_)\n#define pcre2_substring_copy_bynumber         PCRE2_SUFFIX(pcre2_substring_copy_bynumber_)\n#define pcre2_substring_free                  PCRE2_SUFFIX(pcre2_substring_free_)\n#define pcre2_substring_get_byname            PCRE2_SUFFIX(pcre2_substring_get_byname_)\n#define pcre2_substring_get_bynumber          PCRE2_SUFFIX(pcre2_substring_get_bynumber_)\n#define pcre2_substring_length_byname         PCRE2_SUFFIX(pcre2_substring_length_byname_)\n#define pcre2_substring_length_bynumber       PCRE2_SUFFIX(pcre2_substring_length_bynumber_)\n#define pcre2_substring_list_get              PCRE2_SUFFIX(pcre2_substring_list_get_)\n#define pcre2_substring_list_free             PCRE2_SUFFIX(pcre2_substring_list_free_)\n#define pcre2_substring_nametable_scan        PCRE2_SUFFIX(pcre2_substring_nametable_scan_)\n#define pcre2_substring_number_from_name      PCRE2_SUFFIX(pcre2_substring_number_from_name_)\n\n/* Keep this old function name for backwards compatibility */\n#define pcre2_set_recursion_limit PCRE2_SUFFIX(pcre2_set_recursion_limit_)\n\n/* Keep this obsolete function for backwards compatibility: it is now a noop. */\n#define pcre2_set_recursion_memory_management PCRE2_SUFFIX(pcre2_set_recursion_memory_management_)\n\n/* Now generate all three sets of width-specific structures and function\nprototypes. */\n\n#define PCRE2_TYPES_STRUCTURES_AND_FUNCTIONS \\\nPCRE2_TYPES_LIST \\\nPCRE2_STRUCTURE_LIST \\\nPCRE2_GENERAL_INFO_FUNCTIONS \\\nPCRE2_GENERAL_CONTEXT_FUNCTIONS \\\nPCRE2_COMPILE_CONTEXT_FUNCTIONS \\\nPCRE2_CONVERT_CONTEXT_FUNCTIONS \\\nPCRE2_CONVERT_FUNCTIONS \\\nPCRE2_MATCH_CONTEXT_FUNCTIONS \\\nPCRE2_COMPILE_FUNCTIONS \\\nPCRE2_PATTERN_INFO_FUNCTIONS \\\nPCRE2_MATCH_FUNCTIONS \\\nPCRE2_SUBSTRING_FUNCTIONS \\\nPCRE2_SERIALIZE_FUNCTIONS \\\nPCRE2_SUBSTITUTE_FUNCTION \\\nPCRE2_JIT_FUNCTIONS \\\nPCRE2_OTHER_FUNCTIONS\n\n#define PCRE2_LOCAL_WIDTH 8\nPCRE2_TYPES_STRUCTURES_AND_FUNCTIONS\n#undef PCRE2_LOCAL_WIDTH\n\n#define PCRE2_LOCAL_WIDTH 16\nPCRE2_TYPES_STRUCTURES_AND_FUNCTIONS\n#undef PCRE2_LOCAL_WIDTH\n\n#define PCRE2_LOCAL_WIDTH 32\nPCRE2_TYPES_STRUCTURES_AND_FUNCTIONS\n#undef PCRE2_LOCAL_WIDTH\n\n/* Undefine the list macros; they are no longer needed. */\n\n#undef PCRE2_TYPES_LIST\n#undef PCRE2_STRUCTURE_LIST\n#undef PCRE2_GENERAL_INFO_FUNCTIONS\n#undef PCRE2_GENERAL_CONTEXT_FUNCTIONS\n#undef PCRE2_COMPILE_CONTEXT_FUNCTIONS\n#undef PCRE2_CONVERT_CONTEXT_FUNCTIONS\n#undef PCRE2_MATCH_CONTEXT_FUNCTIONS\n#undef PCRE2_COMPILE_FUNCTIONS\n#undef PCRE2_PATTERN_INFO_FUNCTIONS\n#undef PCRE2_MATCH_FUNCTIONS\n#undef PCRE2_SUBSTRING_FUNCTIONS\n#undef PCRE2_SERIALIZE_FUNCTIONS\n#undef PCRE2_SUBSTITUTE_FUNCTION\n#undef PCRE2_JIT_FUNCTIONS\n#undef PCRE2_OTHER_FUNCTIONS\n#undef PCRE2_TYPES_STRUCTURES_AND_FUNCTIONS\n\n/* PCRE2_CODE_UNIT_WIDTH must be defined. If it is 8, 16, or 32, redefine\nPCRE2_SUFFIX to use it. If it is 0, undefine the other macros and make\nPCRE2_SUFFIX a no-op. Otherwise, generate an error. */\n\n#undef PCRE2_SUFFIX\n#ifndef PCRE2_CODE_UNIT_WIDTH\n#error PCRE2_CODE_UNIT_WIDTH must be defined before including pcre2.h.\n#error Use 8, 16, or 32; or 0 for a multi-width application.\n#else  /* PCRE2_CODE_UNIT_WIDTH is defined */\n#if PCRE2_CODE_UNIT_WIDTH == 8 || \\\n    PCRE2_CODE_UNIT_WIDTH == 16 || \\\n    PCRE2_CODE_UNIT_WIDTH == 32\n#define PCRE2_SUFFIX(a) PCRE2_GLUE(a, PCRE2_CODE_UNIT_WIDTH)\n#elif PCRE2_CODE_UNIT_WIDTH == 0\n#undef PCRE2_JOIN\n#undef PCRE2_GLUE\n#define PCRE2_SUFFIX(a) a\n#else\n#error PCRE2_CODE_UNIT_WIDTH must be 0, 8, 16, or 32.\n#endif\n#endif  /* PCRE2_CODE_UNIT_WIDTH is defined */\n\n#ifdef __cplusplus\n}  /* extern \"C\" */\n#endif\n\n#endif  /* PCRE2_H_IDEMPOTENT_GUARD */\n\n/* End of pcre2.h */\n/*autoconv-0021 C:\\projects\\pcre2port\\pcre2.h copied to pcre2*/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PCRPRGMA": {"ttr": 5379, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "\n#pragma map (pcre2_serialize, \"SERIALI2\")\n#pragma map (pcre2demo, \"PCR2DEMO\")\n#pragma map (pcre2_match, \"MATCH2\")\n#pragma map (pcre2_script_run, \"SCRIPTR2\")\n#pragma map (pcre2_find_bracket, \"FINDBRA2\")\n#pragma map (pcre2_compile, \"COMPILE2\")\n#pragma map (pcre2_pattern_info, \"PATTERN2\")\n#pragma map (pcre2_xclass, \"XCLASS2\")\n#pragma map (pcre2_jit_misc, \"JITMISC2\")\n#pragma map (pcre2_valid_utf, \"VALIDUT2\")\n#pragma map (pcre2_config, \"CONFIG2\")\n#pragma map (pcre2test, \"PCR2TEST\")\n#pragma map (pcre2_convert, \"CONVERT2\")\n#pragma map (pcre2posix, \"PC2POSIX\")\n#pragma map (pcre2_printint, \"PRINTIN2\")\n#pragma map (pcre2_newline, \"NEWLINE2\")\n#pragma map (pcre2_tables, \"TABLES2\")\n#pragma map (pcre2_fuzzsupport, \"FUZZSUP2\")\n#pragma map (pcre2_ord2utf, \"ORD2UTF2\")\n#pragma map (pcre2_study, \"STUDY2\")\n#pragma map (pcre2_substitute, \"SUBSTIT2\")\n#pragma map (pcre2_maketables, \"MAKETAB2\")\n#pragma map (pcre2_chartables, \"CHARTAB2\")\n#pragma map (pcre2_error, \"ERROR2\")\n#pragma map (pcre2_string_utils, \"STRINGU2\")\n#pragma map (pcre2_auto_possess, \"AUTOPOS2\")\n#pragma map (pcre2_substring, \"SUBSTRI2\")\n#pragma map (pcre2_dftables, \"DFTABLES\")\n#pragma map (pcre2_jit_compile, \"JITCOMP2\")\n#pragma map (pcre2_jit_match, \"JITMATC2\")\n#pragma map (pcre2grep, \"PCR2GREP\")\n#pragma map (pcre2_dfa_match, \"DFAMATC2\")\n#pragma map (pcre2_context, \"CONTEXT2\")\n#pragma map (pcre2_ucd, \"UCD2\")\n#pragma map (pcre2_match_data, \"MATCHDA2\")\n/*autoconv-0001 C:\\projects\\pcre2port\\pcrprgma.h converted to PCRPRGMA*/\n", "mimetype": "text/x-c", "datatype": "ebcdic", "extension": ".x-c"}, "PCRZCONH": {"ttr": 3331, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "\n\n\n/*\nTHE z/OS specific functionality\n-------------------------------\n\nContributed by:   Ze'ev Atlas.\n\nCopyright (c) 2012, Ze'ev Atlas.\nAll rights reserved.\n\n\nTHE \"BSD\" LICENCE\n-----------------\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n\n    * Redistributions of source code must retain the above copyright notice,\n      this list of conditions and the following disclaimer.\n\n    * Redistributions in binary form must reproduce the above copyright\n      notice, this list of conditions and the following disclaimer in the\n      documentation and/or other materials provided with the distribution.\n\n    * Neither the name of the University of Cambridge nor the name of Google\n      Inc. nor the names of their contributors may be used to endorse or\n      promote products derived from this software without specific prior\n      written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\nAND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\nIMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\nARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\nLIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\nCONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\nSUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\nINTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\nCONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\nARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\nPOSSIBILITY OF SUCH DAMAGE.                                          */\n/****************************************************************************\n* This section  provides means to handle the EBCDIC horror within the       *\n* context of PCRE2 and its REXX interface.  Read more about the problem and *\n* solution in the PCRE2 Native z/OS Port documentation.                     *\n****************************************************************************/\n\n#include \"langinfo.h\"\n#include \"locale.h\"\n#include <iconv.h>\n#include \"interna2.h\"\n#include \"pcre2.h\"\n\n#ifndef CHAR_NULL\n#define CHAR_NULL 0x00\n#endif\n#define PCRZ_NULL_TERMINATED -1\n#define PCRZ_SPACE_TERMINATED -2\n#define PCRZ_LENGTH_TERMINATED -3\n\n#define PCRZ_MAX_PATTERN_SIZE 2048\n#define PCRZ_MAX_SUBJECT_SIZE 8192\n#define PCRZ_MAX_REPLACEMENT_SIZE 1024\n#define PCRZ_MAX_SUBSTITUTE_SIZE 16384\n#define PCRZ_MAX_CODESET_SIZE 16\n\n\ntypedef struct ZCSSTRCT\n{\n    unsigned char charset_locale \u00dd16\u00a8;\n    iconv_t cd; /* conversion descriptor */\n    iconv_t cd_reverse; /* conversion back descriptor */\n    size_t pattern_size; /* Max size converted pattern */\n    size_t subject_size; /* Max size converted subject */\n    size_t replacement_size; /* Max size converted replacement */\n    size_t substitute_size; /* Max size converted and unconverted substitute */\n    char* pattern_1047; /* pointer to allocated space for converted pattern */\n    char* subject_1047; /* pointer to allocated space for converted subject */\n    char* replacement_1047; /* pointer to allocated space for converted replacement */\n    char* substitute_1047; /* pointer to allocated space for converted buffer */\n    char* substitute; /* pointer to allocated space for unconverted buffer */\n}ZCSSTRCT;\n/*autoconv-0001 C:\\projects\\pcre2port\\pcrzconh.h converted to PCRZCONH*/\n/*autoconv-0001 C:\\projects\\pcre2port\\pcrzconh.h converted to PCRZCONH*/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PCRZFUNC": {"ttr": 2051, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "\n\n\n#ifndef HAVE_CONFIG_H\n#   define HAVE_CONFIG_H 1\n#endif\n#ifdef HAVE_CONFIG_H\n#   include \"config.h\"\n#endif\n\n#ifdef NATIVE_ZOS\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <errno.h>\n#include \"PCRZCONH.h\"\n\nstatic unsigned char CHARSET_IBM1047\u00dd\u00a8 = \"IBM-1047\";\n\n/*\nTHE z/OS specific functionality\n-------------------------------\n\nContributed by:   Ze'ev Atlas.\n\nCopyright (c) 2012, Ze'ev Atlas.\nAll rights reserved.\n\n\nTHE \"BSD\" LICENCE\n-----------------\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n\n    * Redistributions of source code must retain the above copyright notice,\n      this list of conditions and the following disclaimer.\n\n    * Redistributions in binary form must reproduce the above copyright\n      notice, this list of conditions and the following disclaimer in the\n      documentation and/or other materials provided with the distribution.\n\n    * Neither the name of the University of Cambridge nor the name of Google\n      Inc. nor the names of their contributors may be used to endorse or\n      promote products derived from this software without specific prior\n      written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\nAND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\nIMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\nARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\nLIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\nCONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\nSUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\nINTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\nCONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\nARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\nPOSSIBILITY OF SUCH DAMAGE.                                          */\n\n/* The functions herein do not use Reg Exp because Reg Exp is not yet\navailable.  They help to prepare COBOL fixed length character strings for Reg\nExp manipulation.  COBOL character strings are fundamentally different then C\n(and thus also C++, Java, C# and virtually any other language) character\nstrings in that they are fixed length or length terminated (i.e. the length of\nthe string is known either in compile time or in run time via some variable.)\nThat length is retrievable by means of querying the prefix variable or using\nthe LENGTH OF special register.  There is no terminator character (null or\notherwise.)  COBOL notion of fixed length or length terminated character\nstrings relate directly to the notion of fixed length records - record length\nis pre-defined and known in similar manner and there is no record terminator\ncharacter.\nMost other languages use the null terminated notation (i.e. the end-of-string\nis signaled by the null character.  Regular Expression as defined and implemented\nby Perl, Posix and PCRE depend on the string being null terminated.\nTo add to the complication, C on z/OS adds record terminator to the end of the\nrecord even on fixed length records, but on text records, at least from the\nstandard input, the last spaces are chopped.  I coined that type as space\nterminated records and strings.\nThe functions herein provide the means to query a character string and convert\nit to the desired format.\nCurrently, these functions compile only under NATIVE_ZOS as I suspect that nobody\nelse will want or need them, however, it is pretty simple to remove this\nlimitation                                                                     */\n\nextern int pcrz_what_term_str (char * str, int maxlen);\nextern int pcrz_is_space_term_str (char * str, int maxlen);\nextern int pcrz_is_null_term_str (char * str, int maxlen);\nextern int pcrz_space_to_null_term_str (char * str, int maxlen);\nextern int pcrz_null_to_space_term_str (char * str, int maxlen);\n\nextern int pcrz_codeset_init (ZCSSTRCT ** handle_ptr,\n                      char * codeset_name,\n                      size_t codeset_name_size,\n                      size_t pattern_size,\n                      size_t subject_size);\nextern int pcrz_codeset_init_substitute (ZCSSTRCT * handle_ptr,\n                      size_t replacement_size,\n                      size_t substitute_size,\n                      char **substitute_ptr);\nextern int pcrz_codeset_convert_pattern (ZCSSTRCT *zcsstrct_ptr,\n         char * input_pattern, size_t pattern_length,\n         char ** output_pattern, size_t ** out_pattern_length);\nextern int pcrz_codeset_convert_subject (ZCSSTRCT *zcsstrct_ptr,\n         char * input_subject, size_t subject_length,\n         char ** output_subject, size_t ** out_subject_length);\nextern int pcrz_codeset_convert_replacement (ZCSSTRCT *zcsstrct_ptr,\n         char * input_replacement, size_t replacement_length,\n         char ** output_replacement, size_t ** out_replacement_length);\nextern int pcrz_codeset_convert_substitute_back (ZCSSTRCT *zcsstrct_ptr,\n         char * input_substitute, size_t substitute_length,\n         char ** output_substitute, size_t ** out_substitute_length);\nextern void pcrz_codeset_release (ZCSSTRCT *zcsstrct_ptr);\nint pcrz_codeset_convert (ZCSSTRCT *zcsstrct_ptr, char func,\n         char * input_subject, size_t subject_length,\n         char ** output_subject, size_t ** out_subject_length);\n/* to make a length terminated into null terminated use COBOL (or PL/I\nequivalent) technique of concatenating the sting with null:\n           STRING YOUR-LENGTH-TERMINATED_STRING, LOW-VALUE\n                  DELIMITED BY SIZE INTO YOUR-TARGET-STRING\n*/\n\n/* This function examines the presumably COBOL character string as is.  If it\nis not null terminated, then if there is at least one space in the end it will\nreturn -2 for space terminated and if the last character is not space it will\nreturn -3 for length terminated.  The user may disregard the difference between\nlength and space terminated, depending on the application.  If the string is\nnull  terminated, then the function will return -1.\nNote: maxlen is one more then the null terminated string length to allow for\nthe null terminator.  For the others it is the fixed length of the string.  */\nint pcrz_what_term_str (char * str, int maxlen)\n{\n   int i;\n   /* is it null terminated? */\n   for (i=0; i<maxlen; i++)\n   {\n      if (str \u00ddi\u00a8 == CHAR_NULL)\n      {\n         return PCRZ_NULL_TERMINATED; /* null terminated */\n      }\n   }\n   /* no! then choose among length terminated variants*/\n   if (str \u00ddmaxlen-1\u00a8 ==  CHAR_SPACE)\n   {\n      return PCRZ_SPACE_TERMINATED; /*space terminated*/\n   }\n   else\n   {\n      return PCRZ_LENGTH_TERMINATED; /*length terminated */\n   }\n}\n\n/* This function examines the presumably COBOL character string as is.  If it\nis not null terminated, then it looks for the last non-space character and\nreturns the actual length of the string to that character.  If the last\ncharacter is not space it will return -3 for length terminated.  If the string\nis null terminated, then the function will return -1                        */\nint pcrz_is_space_term_str (char * str, int maxlen)\n{\n   int i;\n   for (i=0; i<maxlen; i++)\n   {\n      if (str \u00ddi\u00a8 == CHAR_NULL)\n      {\n         return PCRZ_NULL_TERMINATED; /* no, it is null terminated */\n      }\n   }\n   for (i=maxlen-1; i>=0; i--)\n   {\n      if (str \u00ddi\u00a8 !=  CHAR_SPACE)\n      {\n         return i+1; /* length of spaec terminated */\n      }\n   }\n   return PCRZ_LENGTH_TERMINATED; /*length terminated */\n}\n\n/* This function examines the presumably COBOL character string as is.  If it\nis null terminated then its length is returned.  Otherewise, if there is at\nleast one space in the end it will return -2 for space terminated and if the\nlast character is not space it will return -3 for length terminated.  The user\nmay disregard the difference between length and space terminated, depending on\nthe application.\nNote: maxlen is one more then the null terminated string length to allow for\nthe null terminator.  For the others it is the fixed length of the string.  */\nint pcrz_is_null_term_str (char * str, int maxlen)\n{\n   int i;\n   for (i=0; i<maxlen; i++)\n   {\n      if (str \u00ddi\u00a8 == CHAR_NULL)\n      {\n         return i; /* length of null terminated */\n      }\n   }\n   /* no! tehn choose among length terminated variants*/\n   if (str \u00ddmaxlen-1\u00a8 ==  CHAR_SPACE)\n   {\n      return PCRZ_SPACE_TERMINATED; /*space terminated*/\n   }\n   else\n   {\n      return PCRZ_LENGTH_TERMINATED; /*length terminated */\n   }\n}\n\n/* This function examines the presumably COBOL character string.  If it is\nalready null terminated, only the null terminated string part is examined\nfarther.  The function then looks for the last non-space character, marks the\nnext character as null and returns the actual length of the null terminated\nstring.  If the last non-space character is the last character (no room for\nnull character, then the function will return -3 for length terminated.\nNote: maxlen is one more then the null terminated string length to allow for\nthe null terminator.  For the others it is the fixed length of the string.  */\nint pcrz_space_to_null_term_str (char * str, int maxlen)\n{\n   int i;\n   int j;\n   j = maxlen;\n   for (i=0; i<maxlen; i++)\n   {\n      if (str \u00ddi\u00a8 == CHAR_NULL)\n      {\n         j= i;\n         break;\n      }\n   }\n   for (i=j-1; i>=0; i--)\n   {\n      if (i < 0)\n      {\n         str \u00ddi+1\u00a8 = CHAR_NULL;\n         return 0;\n      }\n      if (str \u00ddi\u00a8 !=  CHAR_SPACE)\n      {\n         if (i+1 == maxlen)\n         {\n            return PCRZ_LENGTH_TERMINATED; /*length terminated */\n         }\n         else\n         {\n            str \u00ddi+1\u00a8 = CHAR_NULL;\n            return i+1; /* length of spaec terminated */\n         }\n      }\n   }\n}\n\n/* This function examines the presumably COBOL character string.  If it is null\nterminated, the null character and all characters after it to maxlen are\nreplaced by space.  The function then looks for the last non-space character\nand returns the actual length of the space terminated string.  If the last\nnon-space character is the last character, then the function will return -3 for\nlength terminated.\nNote: maxlen is one more then the null terminated string length to allow for\nthe null terminator.  For the others it is the fixed length of the string.  */\nint pcrz_null_to_space_term_str (char * str, int maxlen)\n{\n   int i;\n   int j;\n   for (i=0; i<maxlen; i++)\n   {\n      if (str \u00ddi\u00a8 == CHAR_NULL)\n      {\n         for (j=i; j < maxlen; j++)\n         {\n            str \u00ddj\u00a8 =  CHAR_SPACE;\n         }\n         break;\n      }\n   }\n   if (str \u00ddmaxlen - 1\u00a8 !=  CHAR_SPACE)\n   {\n      return PCRZ_LENGTH_TERMINATED; /*length terminated */\n   }\n   for (i=maxlen-1; i>=0; i--)\n   {\n      if (str \u00ddi\u00a8 !=  CHAR_SPACE)\n      {\n          return i; /* length of space terminated */\n      }\n   }\n}\n\n\n/****************************************************************************\n* This section  provides means to handle the EBCDIC horror within the       *\n* context of PCRE2 and its REXX interface.  Read more about the problem and *\n* solution in the PCRE2 Native z/OS Port documentation.                     *\n****************************************************************************/\n/* provided functionalities:\n*  1. Determine the native (or supplied) input CODESET.\n*  2. Initializie conversion. (to, from)\n*  3. Allocate two blocks of memory for the IBM1047 intermediate\n*     strings, one for the pattern and one for the subject string.\n*  4. Front end conversion, converting pattern and subject strings\n*     from the local codeset to IBM1047\n*  5. Releasing the formerly initialized environment and deallocating\n*     allocated memory.\n*  6. Appropriate structure to point to all the above, via the\n*     PCRZCONH header file, that defines the ZCSSTRCT structure.\n*  7. Added dealing with replacement and substitute result string.\n*  Obviously the package should be smart enough to notice whether the\n*  local codeset is IBM1047 and do nothing.\n*  The LE language (COBOL) and REXX user does not need to know the\n*  intertnal structures or even the the structure of ZCSSTRCT.\n*  The current documentation would change to reflect what was learned\n*  about the EBCDIC horror, accurate explanation on the compiled\n*  version, and so on.  Appropriate changes would be introduced to\n*  the functions that try to determine the compiler and locale\n*  settings.\n*/\n\n/*\n*  pcrz_codeset_init <=> ZCSINIT\n*  1. Determines the native (or supplied) input CODESET.\n*  2. Initializie conversion. (to, from)\n*  3. Allocate two blocks of memory for the IBM1047 intermediate\n*     strings, one for the pattern and one for the subject string.\n*  codeset_name is optional and provides the input CODESET,\n*  defaults to local codeset. Note however, that if your emulator\n*  defaults to something different then the installation locale,\n*  you have to override the locale by supplying your codeset.\n*  Note that the internal CODESET is always IBM1047 which is the IBM\n*  C compiler default and the way the binaries are distributed.\n*  pattern_size and subject_size are the estimated max sizes for\n*  the largest pattern and largest subject string, default to 2048 and\n*  8192 corr.\n*  The returned handle should be preserved.\n*/\n\nint pcrz_codeset_init (ZCSSTRCT ** handle_ptr, char * codeset_name,\n                      size_t codeset_name_size,\n                      size_t pattern_size,\n                      size_t subject_size)\n{\n\n    char *codeset;\n    int rc;\n    ZCSSTRCT * zcsstrct_ptr;\n\n    /* Allocate the return block */\n    zcsstrct_ptr = (ZCSSTRCT *) malloc (sizeof (ZCSSTRCT));\n    if (zcsstrct_ptr == NULL)\n    {\n        fprintf(stderr,\n             \"ZCSINIT-001: failed to allocate ZCSSTRCT block: %s\\n\",\n                      strerror(errno));\n        return(-1);\n    }\n\n    /* Initialize the structure to empty */\n    *handle_ptr = zcsstrct_ptr;\n    memcpy(zcsstrct_ptr->charset_locale, \" \", 2);\n    zcsstrct_ptr->cd           = NULL;\n    zcsstrct_ptr->cd_reverse   = NULL;\n    zcsstrct_ptr->pattern_size = 0;\n    zcsstrct_ptr->subject_size = 0;\n    zcsstrct_ptr->replacement_size = 0;\n    zcsstrct_ptr->pattern_1047 = NULL;\n    zcsstrct_ptr->subject_1047 = NULL;\n    zcsstrct_ptr->replacement_1047 = NULL;\n\n    /* Determine the codeset name */\n    if (codeset_name != NULL)\n    {\n        codeset = codeset_name;\n        if (codeset_name_size == PCRE2_ZERO_TERMINATED)\n        {\n           if (strlen(codeset_name) > PCRZ_MAX_CODESET_SIZE - 1)\n           {\n              fprintf(stderr,\n              \"ZCSINIT-002: CODESET name length %d too large\\n\",\n                          strlen(codeset));\n              free (zcsstrct_ptr);\n              zcsstrct_ptr = NULL;\n              return(-1);\n           }\n           fprintf (stderr, \"ZCSINIT-020: CODSET is %s\\n\", codeset);\n        }\n        else\n        {\n           if (codeset_name_size == PCRZ_SPACE_TERMINATED)\n           {\n              rc = pcrz_space_to_null_term_str ((char *) codeset_name,\n                             PCRZ_MAX_CODESET_SIZE);\n              if (rc == PCRZ_LENGTH_TERMINATED)\n              {\n                 fprintf(stderr,\n                 \"ZCSINIT-003: CODESET name too long\\n\");\n                 free (zcsstrct_ptr);\n                 zcsstrct_ptr = NULL;\n                 return(-1);\n              }\n              fprintf (stderr, \"ZCSINIT-021: CODSET is %.16s\\n\",\n                       codeset);\n           }\n           else\n           {\n              if (codeset_name_size > PCRZ_MAX_CODESET_SIZE - 1)\n              {\n                 fprintf(stderr,\n                 \"ZCSINIT-004: CODESET name size %d too large\\n\",\n                             codeset_name_size);\n                 free (zcsstrct_ptr);\n                 zcsstrct_ptr = NULL;\n                 return(-1);\n              }\n              else\n              {\n                 codeset\u00ddcodeset_name_size\u00a8 = CHAR_NULL;\n                 fprintf (stderr, \"ZCSINIT-022: CODSET is %s\\n\",\n                       codeset);\n              }\n           }\n        }\n    }\n    else\n    {\n        setlocale(LC_ALL, \"\");\n        codeset = nl_langinfo(CODESET);\n        fprintf (stderr, \"ZCSINIT-023: CODSET is %s\\n\", codeset);\n    }\n\n    strcpy(zcsstrct_ptr->charset_locale, codeset);\n\n    /* Do we need conversion? */\n    if (strcmp(codeset, CHARSET_IBM1047) != 0)\n    /* Yes, open and allocate descriptor */\n    {\n        if ((zcsstrct_ptr->cd = iconv_open(CHARSET_IBM1047, codeset))\n           == (iconv_t)(-1))\n        {\n            fprintf(stderr,\n            \"ZCSINIT-005: Cannot open converter from %s to %s\\n\",\n                codeset, CHARSET_IBM1047);\n            free (zcsstrct_ptr);\n            zcsstrct_ptr = NULL;\n            return(-1);\n        }\n        if ((zcsstrct_ptr->cd_reverse = iconv_open(codeset, CHARSET_IBM1047))\n           == (iconv_t)(-1))\n        {\n            fprintf(stderr,\n            \"ZCSINIT-008: Cannot open converter from %s to %s\\n\",\n                CHARSET_IBM1047, codeset);\n            free (zcsstrct_ptr->cd);\n            free (zcsstrct_ptr);\n            zcsstrct_ptr = NULL;\n            return(-1);\n        }\n\n    }\n\n    if (pattern_size == 0)\n    {\n       zcsstrct_ptr->pattern_size = PCRZ_MAX_PATTERN_SIZE;\n    }\n    else\n    {\n       zcsstrct_ptr->pattern_size = pattern_size;\n    }\n\n    if (subject_size == 0)\n    {\n       zcsstrct_ptr->subject_size = PCRZ_MAX_SUBJECT_SIZE;\n    }\n    else\n    {\n       zcsstrct_ptr->subject_size = subject_size;\n    }\n\n    /* Allocate space for converted pattern */\n    zcsstrct_ptr->pattern_1047 = (char *)\n                  malloc (zcsstrct_ptr->pattern_size);\n    if (zcsstrct_ptr->pattern_1047 == NULL)\n    {\n        fprintf(stderr,\n        \"ZCSINIT-006: failed to allocate space for converted pattern: %s\\n\",\n                      strerror(errno));\n        iconv_close(zcsstrct_ptr->cd);\n        iconv_close(zcsstrct_ptr->cd_reverse);\n        free (zcsstrct_ptr);\n        zcsstrct_ptr = NULL;\n        return(-1);\n    }\n\n    /* Allocate space for converted subject */\n    zcsstrct_ptr->subject_1047 = (char *)\n                  malloc ( zcsstrct_ptr->subject_size);\n    if (zcsstrct_ptr->subject_1047 == NULL)\n    {\n        fprintf(stderr,\n        \"ZCSINIT-007: failed to allocate space for converted subject: %s\\n\",\n                      strerror(errno));\n        iconv_close(zcsstrct_ptr->cd);\n        iconv_close(zcsstrct_ptr->cd_reverse);\n        free (zcsstrct_ptr->pattern_1047);\n        free (zcsstrct_ptr);\n        zcsstrct_ptr = NULL;\n        return(-1);\n    }\n\n    return (0);\n}\n\n/*-------------------------------------------------------------------*/\n\n/*\n*  pcrz_codeset_init_substitute <=> ZCSINIS\n*  1. calls pcrz_codeset_init.\n*  2. deals with the replacement string and allocates memory for it\n*  3. Allocate two blocks of memory for the IBM1047 intermediate\n*     strings and for the ultimate output buffer of the substitute\n*     result.\n*  The returned handle originates from pcrz_codeset_init and should be\n*  preserved.  No need to call pcrz_codeset_init independently.\n*  However, if pcrz_codeset_init_substitute fails, it frees only\n*  it's own memory.  You still need to do release.\n*/\n\nint pcrz_codeset_init_substitute (ZCSSTRCT * handle_ptr,\n                      size_t replacement_size,\n                      size_t substitute_size,\n                      char **substitute_ptr)\n{\n    int rc;\n\n    if (replacement_size == 0)\n    {\n       handle_ptr->replacement_size = PCRZ_MAX_REPLACEMENT_SIZE;\n    }\n    else\n    {\n       handle_ptr->replacement_size = replacement_size;\n    }\n\n    if (substitute_size == 0)\n    {\n       handle_ptr->substitute_size = PCRZ_MAX_SUBSTITUTE_SIZE;\n    }\n    else\n    {\n       handle_ptr->substitute_size = substitute_size;\n    }\n\n    /* Allocate space for converted subject */\n    handle_ptr->replacement_1047 = (char *)\n                  malloc ( handle_ptr->replacement_size);\n    if (handle_ptr->replacement_1047 == NULL)\n    {\n        fprintf(stderr,\n        \"ZCSINIT-010: failed to allocate space for converted replacemen: %s\\n\",\n                      strerror(errno));\n      /*iconv_close(handle_ptr->cd);*/\n        iconv_close(handle_ptr->cd_reverse);\n      /*free (handle_ptr->pattern_1047);\n        free (handle_ptr->subject_1047);\n        free (handle_ptr);\n        handle_ptr = NULL;*/\n        return(-1);\n    }\n\n    /* Allocate space for converted buffer */\n    handle_ptr->substitute_1047 = (char *)\n                  malloc ( handle_ptr->substitute_size);\n    if (handle_ptr->substitute_1047 == NULL)\n    {\n        fprintf(stderr,\n        \"ZCSINIT-011: failed to allocate space for converted substitute: %s\\n\",\n                      strerror(errno));\n      /*iconv_close(handle_ptr->cd);*/\n        iconv_close(handle_ptr->cd_reverse);\n      /*free (handle_ptr->pattern_1047);\n        free (handle_ptr->subject_1047);*/\n        free (handle_ptr->replacement_1047);\n      /*free (handle_ptr);\n        handle_ptr = NULL;*/\n        return(-1);\n    }\n\n    /* Allocate space for result buffer */\n    handle_ptr->substitute = (char *)\n                  malloc ( handle_ptr->substitute_size);\n    if (handle_ptr->substitute == NULL)\n    {\n        fprintf(stderr,\n        \"ZCSINIT-012: failed to allocate space for converted substitute back: %s\\n\",\n                      strerror(errno));\n      /*iconv_close(handle_ptr->cd);*/\n        iconv_close(handle_ptr->cd_reverse);\n      /*free (handle_ptr->pattern_1047);\n        free (handle_ptr->subject_1047);*/\n        free (handle_ptr->replacement_1047);\n        free (handle_ptr->substitute_1047);\n      /*free (handle_ptr);\n        handle_ptr = NULL;*/\n        return(-1);\n    }\n\n    * substitute_ptr = handle_ptr->substitute_1047;\n\n    return (0);\n}\n\n/*-------------------------------------------------------------------*/\n\n/*\n*  pcrz_codeset_convert_pattern <=> ZCSCONVP\n*  pcrz_codeset_convert_subject <=> ZCSCONVS\n*  pcrz_codeset_convert_replacement <=> ZCSCONVR\n*  pcrz_codeset_convert_substitute_back <=> ZCSCONVB\n*  4. Front end conversion, converting pattern and subject strings\n*     from the local codeset to IBM1047\n*  This is done via two functions (to avoid user direct interuction\n*  with the gory details:\n*  int pcrz_codeset_convert_pattern (ZCSSTRCT zcsstrct_ptr,\n*        char * input_pattern, size_t pattern_length);\n*  int pcrz_codeset_convert_subject (ZCSSTRCT zcsstrct_ptr,\n*        char * input_subject, size_t subject_length);\n*  int pcrz_codeset_convert_replacement (ZCSSTRCR zcsstrct_ptr,\n*        char * input_replacement, size_t replacement_length);\n*  int pcrz_codeset_convert_substitute_back (ZCSSTRCB zcsstrct_ptr,\n*        char * input_substitute, size_t substitute_length);\n*  where zcsstrct_ptr is the structure returnde by ZCSINIT and\n*  input_pattern is the input pattern, or input_subject which is\n*  the input subject string.  The functions return pointer to\n*  converted string and its length.\n*  Note that pcrz_codeset_convert_substitute_back is different in\n*  that it convert back from IBM1047 to the original codeset\n*/\n\nint pcrz_codeset_convert_pattern (ZCSSTRCT *zcsstrct_ptr,\n         char * input_pattern, size_t pattern_length,\n         char ** output_pattern, size_t ** out_pattern_length)\n{\n   return\n    pcrz_codeset_convert (zcsstrct_ptr, 'p',\n         input_pattern, pattern_length,\n         output_pattern, out_pattern_length);\n}\n\n/*-------------------------------------------------------------------*/\n\nint pcrz_codeset_convert_subject (ZCSSTRCT *zcsstrct_ptr,\n         char * input_subject, size_t subject_length,\n         char ** output_subject, size_t ** out_subject_length)\n{\n   return\n    pcrz_codeset_convert (zcsstrct_ptr, 's',\n         input_subject, subject_length,\n         output_subject, out_subject_length);\n}\n\n/*-------------------------------------------------------------------*/\n\nint pcrz_codeset_convert_replacement (ZCSSTRCT *zcsstrct_ptr,\n         char * input_replacement, size_t replacement_length,\n         char ** output_replacement, size_t ** out_replacement_length)\n{\n   return\n    pcrz_codeset_convert (zcsstrct_ptr, 'r',\n         input_replacement, replacement_length,\n         output_replacement, out_replacement_length);\n}\n\n/*-------------------------------------------------------------------*/\n\n/*\nUse this subroutine to convert the substitute_1047 back to the original\ncodeset.  The input is the substitute_1047, the output is either\nsubstiute which is converted back or substitute_1047 if no conversion.\nSupplied parameters are substitute_1047, its length, substitute, same\nlength.\n*/\n\nint pcrz_codeset_convert_substitute_back (ZCSSTRCT *zcsstrct_ptr,\n         char * input_substitute, size_t substitute_length,\n         char ** output_substitute, size_t ** out_substitute_length)\n{\n   return\n    pcrz_codeset_convert (zcsstrct_ptr, 'b',\n         input_substitute, substitute_length,\n         output_substitute, out_substitute_length);\n}\n\n/*-------------------------------------------------------------------*/\n\nint pcrz_codeset_convert (ZCSSTRCT *zcsstrct_ptr, char func,\n         char * input_subject, size_t subject_length,\n         char ** output_subject, size_t ** out_subject_length)\n{\n   size_t subj_len;\n   size_t subj_len_save;\n   size_t target_len;\n   char * subj_ptr;\n   int rc;\n\n   switch(func)\n   {\n       case 's':\n          target_len = zcsstrct_ptr->subject_size;\n          subj_ptr = zcsstrct_ptr->subject_1047;\n          break;\n       case 'p':\n          target_len = zcsstrct_ptr->pattern_size;\n          subj_ptr = zcsstrct_ptr->pattern_1047;\n          break;\n       case 'r':\n          target_len = zcsstrct_ptr->replacement_size;\n          subj_ptr = zcsstrct_ptr->replacement_1047;\n          break;\n       case 'b':\n          target_len = zcsstrct_ptr->substitute_size;\n          subj_ptr = zcsstrct_ptr->substitute;\n          break;\n\n\n       default:\n          fprintf(stderr,\n          \"ZCSCONVx-003: Unknown supplied function %s\\n\", func);\n          return (-1);\n   }\n\n   if (subject_length == 0)\n   {\n      subj_len = strlen(input_subject);\n   }\n   else\n   {\n      subj_len = subject_length;\n   }\n   if (subj_len > target_len -1)\n   {\n      fprintf(stderr,\n      \"ZCSCONVx-001: target length gt allocated block\\n\");\n      return (-1);\n   }\n   subj_len_save = subj_len;\n\n   if (zcsstrct_ptr->cd == NULL)\n   {\n      * output_subject = input_subject;\n      * out_subject_length = subj_len_save;\n      return (1); /* no conversion is necessary. use input */\n   }\n\n   if (func != 'b')\n   {\n       rc = iconv(zcsstrct_ptr->cd, &input_subject, &subj_len,\n                  &subj_ptr, &target_len);\n   }\n   else\n   {\n       rc = iconv(zcsstrct_ptr->cd_reverse, &input_subject, &subj_len,\n                  &subj_ptr, &target_len);\n   }\n\n   if (rc == -1)\n   {\n      fprintf(stderr,\n      \"ZCSCONVx-002: Error in converting subject string\\n\");\n      return (-1);\n   }\n\n   switch(func)\n   {\n       case 's':\n          * output_subject = zcsstrct_ptr->subject_1047;\n          break;\n       case 'p':\n          * output_subject = zcsstrct_ptr->pattern_1047;\n          break;\n       case 'r':\n          * output_subject = zcsstrct_ptr->replacement_1047;\n          break;\n       case 'b':\n          * output_subject = zcsstrct_ptr->substitute;\n          break;\n   }\n\n   * out_subject_length = subj_len_save;\n   return (0); /* conversion successful, use zcsstrct_ptr->subject_1047 */\n}\n\n/*-------------------------------------------------------------------*/\n\n/*\n*  pcrz_codeset_release <=> ZCSRLSE\n*  5. Releasing the formerly initialized environment and deallocating\n*     allocated memory.\n*  This is done via the function:\n*  void pcrz_codeset_release (ZCSSTRCT zcsstrct_ptr);\n*  where struct is the structure returnde by ZCSINIT and input_pattern\n*  is the input pattern.\n*/\n\nvoid pcrz_codeset_release (ZCSSTRCT *zcsstrct_ptr)\n{\n   if (zcsstrct_ptr->subject_1047 != NULL)\n   {\n        free (zcsstrct_ptr->subject_1047);\n        free (zcsstrct_ptr->pattern_1047);\n   }\n   if (zcsstrct_ptr->replacement_1047 != NULL)\n   {\n        free (zcsstrct_ptr->replacement_1047);\n        free (zcsstrct_ptr->substitute_1047);\n        free (zcsstrct_ptr->substitute);\n   }\n\n   if (zcsstrct_ptr->cd != NULL)\n   {\n        iconv_close(zcsstrct_ptr->cd);\n   }\n   if (zcsstrct_ptr->cd_reverse != NULL)\n   {\n        iconv_close(zcsstrct_ptr->cd_reverse);\n   }\n\n   free (zcsstrct_ptr);\n}\n#endif\n/*autoconv-0001 C:\\projects\\pcre2port\\pcrzfunc.c converted to PCRZFUNC*/\n/*autoconv-0001 C:\\projects\\pcre2port\\pcrzfunc.c converted to PCRZFUNC*/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PCRZOSCS": {"ttr": 2826, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "\n\n/*\nTHE z/OS specific functionality\n-------------------------------\n\nContributed by:   Ze'ev Atlas.\n\nCopyright (c) 2013 Ze'ev Atlas.\nAll rights reserved.\n\n\nTHE \"BSD\" LICENCE\n-----------------\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n\n    * Redistributions of source code must retain the above copyright notice,\n      this list of conditions and the following disclaimer.\n\n    * Redistributions in binary form must reproduce the above copyright\n      notice, this list of conditions and the following disclaimer in the\n      documentation and/or other materials provided with the distribution.\n\n    * Neither the name of the University of Cambridge nor the name of Google\n      Inc. nor the names of their contributors may be used to endorse or\n      promote products derived from this software without specific prior\n      written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\nAND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\nIMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\nARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\nLIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\nCONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\nSUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\nINTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\nCONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\nARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\nPOSSIBILITY OF SUCH DAMAGE.                                          */\n\nstatic unsigned char CHARSET_IBM1047\u00dd\u00a8 = \"IBM1047\";\nstatic unsigned char CHARSET_IBM1140\u00dd\u00a8 = \"IBM1140\";\nstatic unsigned char CHARSET_IBM285\u00dd\u00a8 = \"IBM285\";\nstatic unsigned char CHARSET_posix_bc\u00dd\u00a8 = \"posix-bc\";\nstatic unsigned char CHARSET_IBMUNKN\u00dd\u00a8 = \"unknown\";\n\n/* This function resembles the Perl check for codepage and returns one\n   the four major EBCDIC versions (3 recognized by Perl and one more)\n/* my %ebcdic = ( 176 => 'cp37', 95 => 'cp1047', 106 => 'posix-bc' );*/\n\nconst char * pcrz_cpversion ()\n{\n  char CHAR_circumflex = '^';   /*<TAG>*/\n  if ((int) CHAR_circumflex == 176)     /* Common with CP424, etc. */\n  {\n    return CHARSET_IBM1140;\n  }\n  else if ((int) CHAR_circumflex == 95) /* Common with CP500, CP875,\n                                           IBM1026, etc. */\n  {\n    return CHARSET_IBM1047;\n  }\n  else if ((int) CHAR_circumflex == 106)\n  {\n    return CHARSET_posix_bc;\n  }\n  else if ((int) CHAR_circumflex == 186)\n  {\n    return CHARSET_IBM285;\n  }\n  else\n  {\n    return CHARSET_IBMUNKN;\n  }\n}\n/*autoconv-0001 C:\\projects\\pcre2port\\pcrzoscs.h converted to PCRZOSCS*/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PCRZOSFS": {"ttr": 513, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "\n\n\n\n/*\nTHE z/OS specific functionality\n-------------------------------\n\nContributed by:   Ze'ev Atlas.\n\nCopyright (c) 2013 Ze'ev Atlas.\nAll rights reserved.\n\n\nTHE \"BSD\" LICENCE\n-----------------\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n\n    * Redistributions of source code must retain the above copyright notice,\n      this list of conditions and the following disclaimer.\n\n    * Redistributions in binary form must reproduce the above copyright\n      notice, this list of conditions and the following disclaimer in the\n      documentation and/or other materials provided with the distribution.\n\n    * Neither the name of the University of Cambridge nor the name of Google\n      Inc. nor the names of their contributors may be used to endorse or\n      promote products derived from this software without specific prior\n      written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\nAND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\nIMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\nARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\nLIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\nCONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\nSUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\nINTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\nCONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\nARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\nPOSSIBILITY OF SUCH DAMAGE.                                          */\n/****************************************************************************\n* The pcrzosfs.h provides structures, types and variables needed to handle  *\n* some peculiarities of the classic z/OS file system.  Particularly there   *\n* are structures and types needed to handle PDS (or PDSE files).  Also, the *\n* PARM filed in the JCL behaves differently then the familiar Unix/Linux and*\n* Windows command line and there are some issues that need to be resolved.  *\n*                                                            ZA 7/08/2013   *\n****************************************************************************/\n\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n/* #define _XOPEN_SOURCE */\n#include <fnmatch.h>\n/* #define _POSIX_SOURCE */\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/modes.h>\n#include <dirent.h>\n\n/* There are three ways to supply a file name to C in z/OS\nfopen (\"file.dsn\", \"r\") - HLQ is added, much like in TSO\nfopen (\"\\'myhlq.file.dsn\\'\", \"r\") - HLQ is present in the filename\nfopen (\"dd:ddname\", \"r\") - needs a valid DD allocation\nfopen (\"dd:MYDD(B)\",\"r\");\n*/\n\n/* Each PDS directory record is of 256 bytes\n * +----------------+------+------+------+------+----------------+\n * + logical record |Member|Member|......|Member|  Unused        +\n * + length - short |elmnt1|elmnt2|      |elmntn|                +\n * +----------------+------+------+------+------+----------------+\n *  (logical record len includes itslef)\n *\n * each member element looks like the following\n * +--------+-------+----+-----------------------------------+\n * + Member |TTR    |info|                                   +\n * + Name   |       |byte|  User Data TTRN's (halfwords)     +\n * + 8 bytes|3 bytes|    |                                   +\n * +--------+-------+----+-----------------------------------+\n*/\n\n#define RECLEN  256\n#define TTRLEN  3      /* TTR's are 3 bytes long */\n/*\n * bit 0 of the info-byte is '1' if the member is an alias,\n * 0 otherwise. ALIAS_MASK is used to extract this information\n*/\n#define ALIAS_MASK ((unsigned int) 0x80)\n/*\n * The number of user data half-words is in bits 3-7 of the info byte.\n * TTRN_MASK is used to extract this number and doubled (for half words)\n*/\n#define TTRN_MASK ((unsigned int) 0x1F)\n#define MEMBLEN     8\n#define TRUE        1\n#define FALSE       0\n#define DIRECTORY_END \"\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\"\n\n/* define z/OS file types */\n#define __ZOS_NOFILE      0\n#define __ZOS_PDS         8\n#define __ZOS_PDSE        9\n#define __ZOS_PDS_MEMBER  10\n#define __ZOS_PS          16\n#define __ZOS_VSAM_KSDS   24\n#define __ZOS_VSAM_ESDS   25\n#define __ZOS_VSAM_RRDS   26\n#define __ZOS_HFS         32\n\n#define __ZOS_FUNCTION pcre2grep(handle, frtype, pds_n_member,\\\n            (filenames > FN_DEFAULT ||\\\n            (filenames == FN_DEFAULT &&\\\n            !only_one_at_top))? pds_n_member:NULL);\n\n/* member element within PDS directory record */\nstruct MEMBER_ELEMENT\n{\n    char member_name \u00ddMEMBLEN\u00a8;\n    char ttrmem \u00ddTTRLEN\u00a8;\n    unsigned char info_byte;\n};\n\n/* Distiled member information for our purpose */\ntypedef struct PDS_MEMBER\n{\n    char member\u00dd8+1\u00a8;   /* member name                    */\n    short int  alias;   /* TRUE if alias, FALSE otherwise */\n}PDS_MEMBER;\n\n/* Prototypes */\nint readpds(PDS_MEMBER * pds, FILE * fp);\nFILE * openpds (char * pds);\nint identifyzosfiletype (FILE * filename);\nint travelonpdsdir (char * pathname, BOOL only_one_at_top);\n\n/* any other functions are work in progress and are not exposed */\n\nstatic FILE *fp;\n\nint readpds\n(\n    PDS_MEMBER * pds,   /* pointer to current member information  */\n    FILE    * fp        /* PDS directory FILE pointer      */\n)\n{\n    static struct MEMBER_ELEMENT *member;\n    static char   directory_record\u00dd256\u00a8;\n    static short  ttrns;\n    static short  data_cnt = 2;     /* first useful; byte number  */\n    static int    blocks_read = 0;  /* Directory blocks read total */\n    static short  count = 0;\n    int rc;\n    int i;\n\n    if (   data_cnt >= count  )\n    {\n       i = fread(directory_record,256,1,fp);\n       if (i == 1)           /* Was 1 block of 256 bytes read?  */\n       {\n           blocks_read += 1;       /* increment block count           */\n           memcpy ( & count, directory_record, 2 );\n           data_cnt = 2;\n       }\n       else\n       {\n          int ferr = ferror(fp);\n          fprintf(stderr,\n             \"ZOSFS-001 - directory read error after block %d, read: %d ferror(): %d\\n\",\n             blocks_read, i, ferr);\n             rc = EXIT_FAILURE;\n       };\n    };\n\n    if (memcmp((directory_record+data_cnt),DIRECTORY_END,8) == 0 )\n    {\n        rc = EOF;    /* It is like logical EOF      */\n    }\n    else\n    {\n        member = (struct MEMBER_ELEMENT *) (directory_record + data_cnt);\n        memset(pds,'\\0',sizeof(PDS_MEMBER));\n        strncpy(pds->member, member->member_name, MEMBLEN);\n\n        if ( (member->info_byte & 0x80) == FALSE )\n        {\n            pds->alias = FALSE;\n        }\n        else\n        {\n            pds->alias = TRUE;\n        };\n\n        i = 2 * (member->info_byte & 0x1f); /* Number of ttrns */\n        data_cnt += sizeof(struct MEMBER_ELEMENT) + i; /* next element offset  */\n        rc = EXIT_SUCCESS;\n    };\n    return(rc);\n}\n\nFILE * openpds (char * pds)\n{\n   static FILE *fp;\n   static char pds_name \u00dd59\u00a8; /* ' + 44 bytes file name + '(' + +/- + 8 + ')' + ' + null */\n   memset(pds_name,'\\0',sizeof(pds_name));\n   sprintf(pds_name,\"%s\",pds);\n\n   /*\n   * Open the pds in binary read mode. The PDS directory will be read one\n   * record at a time until either the end of the directory or end-of-file\n   * is detected.\n   */\n\n   fp = fopen(pds_name,\"rb\");\n   if (fp == NULL)\n   {\n       fprintf(stderr, \"ZOSFS-002 - could not open %s\\n\", pds_name);\n       return(NULL);\n   };\n\n   return (fp);\n}\n\n/* fclose (fp); */\n\nint identifyzosfiletype (FILE * filename)\n{\n   fldata_t fileinfo;\n   int rc;\n   static char local_fname \u00ddFILENAME_MAX\u00a8;\n   rc = fldata(filename, local_fname, &fileinfo);\n   if (rc != 0)\n   {\n       fprintf(stderr, \"ZOSFS-003 - fldata failed\\n\");\n       return -1;\n   }\n   else\n   {\n   /* Note: if this is a file name (rather than DDNAME, it is\n      returned quoted\n   */\n      if ((fileinfo.__dsorgPO == 1 && fileinfo.__dsorgPDSE == 0) &&\n          fileinfo.__dsorgPDSdir == 1)\n      {\n          rc = __ZOS_PDS;\n      }\n      else if ((fileinfo.__dsorgPO == 1 && fileinfo.__dsorgPDSE == 1) &&\n          fileinfo.__dsorgPDSdir == 1)\n      {\n          rc = __ZOS_PDSE;\n      }\n      else if (fileinfo.__dsorgPS == 1)\n      {\n          rc = __ZOS_PS;\n      }\n      else if ((fileinfo.__dsorgPO == 1 || fileinfo.__dsorgPDSE == 1) &&\n          fileinfo.__dsorgPDSmem == 1)\n      {\n          rc = __ZOS_PDS_MEMBER;\n      }\n      else if(fileinfo.__vsamtype == __ESDS)\n      {\n          rc = __ZOS_VSAM_ESDS;\n      }\n      else if(fileinfo.__vsamtype == __KSDS)\n      {\n          rc = __ZOS_VSAM_KSDS;\n      }\n      else if(fileinfo.__vsamtype == __RRDS)\n      {\n          rc = __ZOS_VSAM_RRDS;\n      }\n      else if (fileinfo.__dsorgHFS == 1)\n      {\n          rc = __ZOS_HFS;\n      }\n      else\n      {\n          rc = __ZOS_NOFILE;\n      }\n   };\n   return rc;\n}\n\nint travelonpdsdir (char * pathname, BOOL only_one_at_top)\n{\n   int c;\n   int e;\n   int rc;\n   char * mem;\n   char pds_n_member \u00dd59\u00a8;\n   /* duplicating some enum's to allow for a general puurpos function */\n   enum { FN_NONE, FN_DEFAULT, FN_MATCH_ONLY, FN_NOMATCH_ONLY,\n          FN_FORCE };\n   enum { FR_PLAIN, FR_LIBZ, FR_LIBBZ2 };\n   void *handle;\n   int frtype;\n   FILE * mypds;\n   FILE * membfile;\n   PDS_MEMBER member_attributes;\n   mypds = openpds(pathname);\n   if (mypds == NULL)\n   {\n      fprintf(stderr, \"ZOSFS-004: error openning %s as a PDS/E\\n\", pathname);\n      fclose (mypds);\n      return -1;\n   }\n   else\n   {\n      c = readpds (&member_attributes, mypds);\n      while (c != EXIT_FAILURE && c != EOF)\n      {\n          strcpy (pds_n_member, pathname);\n          e = strlen(pds_n_member);\n          if (pds_n_member\u00dd0\u00a8 == '\\'')\n          {\n             e--;\n          }\n          mem = &pds_n_member\u00dde\u00a8;\n          strcpy (mem, \"(\"); mem ++;\n          pcrz_space_to_null_term_str(member_attributes.member, 9);\n          /*ZSPC2NUL (member_attributes.member, 9);*/\n          strcpy (mem, member_attributes.member);\n          e = strlen(pds_n_member);\n          mem = &pds_n_member\u00dde\u00a8;\n          strcpy (mem, \")\"); mem ++;\n          if (pds_n_member\u00dd0\u00a8=='\\'')\n          {\n             strcpy (mem, \"\\'\");\n          }\n          membfile = fopen(pds_n_member, \"r\");\n          handle = (void *)membfile;\n          frtype = FR_PLAIN;\n          if (handle == NULL)\n            {\n            if (!silent)\n              fprintf(stderr, \"ZOSFS-005: Failed to open member %s: %s\\n\", pds_n_member,\n                strerror(errno));\n            return 2;\n            }\n\n          /* Now grep the member file */\n          printf (\"ZOSFS-006: PDS member %s \\n\", pds_n_member);\n          rc = __ZOS_FUNCTION;\n\n          /* Close in an appropriate manner. */\n          fclose (membfile);\n\n          c = readpds (&member_attributes, mypds);\n      }\n   }\n   return rc;\n}\n/*autoconv-0001 C:\\projects\\pcre2port\\pcrzosfs.h converted to PCRZOSFS*/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PCR2DEMO": {"ttr": 2561, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "\n/*************************************************\n*           PCRE2 DEMONSTRATION PROGRAM          *\n*************************************************/\n\n/* This is a demonstration program to illustrate a straightforward way of\nusing the PCRE2 regular expression library from a C program. See the\npcre2sample documentation for a short discussion (\"man pcre2sample\" if you have\nthe PCRE2 man pages installed). PCRE2 is a revised API for the library, and is\nincompatible with the original PCRE API.\n\nThere are actually three libraries, each supporting a different code unit\nwidth. This demonstration program uses the 8-bit library. The default is to\nprocess each code unit as a separate character, but if the pattern begins with\n\"(*UTF)\", both it and the subject are treated as UTF-8 strings, where\ncharacters may occupy multiple code units.\n\nIn Unix-like environments, if PCRE2 is installed in your standard system\nlibraries, you should be able to compile this program using this command:\n\ncc -Wall pcre2demo.c -lpcre2-8 -o pcre2demo\n\nIf PCRE2 is not installed in a standard place, it is likely to be installed\nwith support for the pkg-config mechanism. If you have pkg-config, you can\ncompile this program using this command:\n\ncc -Wall pcre2demo.c `pkg-config --cflags --libs libpcre2-8` -o pcre2demo\n\nIf you do not have pkg-config, you may have to use something like this:\n\ncc -Wall pcre2demo.c -I/usr/local/include -L/usr/local/lib \\\n  -R/usr/local/lib -lpcre2-8 -o pcre2demo\n\nReplace \"/usr/local/include\" and \"/usr/local/lib\" with wherever the include and\nlibrary files for PCRE2 are installed on your system. Only some operating\nsystems (Solaris is one) use the -R option.\n\nBuilding under Windows:\n\nIf you want to statically link this program against a non-dll .a file, you must\ndefine PCRE2_STATIC before including pcre2.h, so in this environment, uncomment\nthe following line. */\n\n/* #define PCRE2_STATIC */\n\n/* The PCRE2_CODE_UNIT_WIDTH macro must be defined before including pcre2.h.\nFor a program that uses only one code unit width, setting it to 8, 16, or 32\nmakes it possible to use generic function names such as pcre2_compile(). Note\nthat just changing 8 to 16 (for example) is not sufficient to convert this\nprogram to process 16-bit characters. Even in a fully 16-bit environment, where\nstring-handling functions such as strcmp() and printf() work with 16-bit\ncharacters, the code for handling the table of named substrings will still need\nto be modified. */\n\n#define PCRE2_CODE_UNIT_WIDTH 8\n\n#include <stdio.h>\n#include <string.h>\n#include \"PCRE2.h\"\n\n\n/**************************************************************************\n* Here is the program. The API includes the concept of \"contexts\" for     *\n* setting up unusual interface requirements for compiling and matching,   *\n* such as custom memory managers and non-standard newline definitions.    *\n* This program does not do any of this, so it makes no use of contexts,   *\n* always passing NULL where a context could be given.                     *\n**************************************************************************/\n\nint main(int argc, char **argv)\n{\npcre2_code *re;\nPCRE2_SPTR pattern;     /* PCRE2_SPTR is a pointer to unsigned code units of */\nPCRE2_SPTR subject;     /* the appropriate width (in this case, 8 bits). */\nPCRE2_SPTR name_table;\n\nint crlf_is_newline;\nint errornumber;\nint find_all;\nint i;\nint rc;\nint utf8;\n\nuint32_t option_bits;\nuint32_t namecount;\nuint32_t name_entry_size;\nuint32_t newline;\n\nPCRE2_SIZE erroroffset;\nPCRE2_SIZE *ovector;\nPCRE2_SIZE subject_length;\n\npcre2_match_data *match_data;\n\n\n/**************************************************************************\n* First, sort out the command line. There is only one possible option at  *\n* the moment, \"-g\" to request repeated matching to find all occurrences,  *\n* like Perl's /g option. We set the variable find_all to a non-zero value *\n* if the -g option is present.                                            *\n**************************************************************************/\n\nfind_all = 0;\nfor (i = 1; i < argc; i++)\n  {\n  if (strcmp(argv\u00ddi\u00a8, \"-g\") == 0) find_all = 1;\n  else if (argv\u00ddi\u00a8\u00dd0\u00a8 == '-')\n    {\n    printf(\"Unrecognised option %s\\n\", argv\u00ddi\u00a8);\n    return 1;\n    }\n  else break;\n  }\n\n/* After the options, we require exactly two arguments, which are the pattern,\nand the subject string. */\n\nif (argc - i != 2)\n  {\n  printf(\"Exactly two arguments required: a regex and a subject string\\n\");\n  return 1;\n  }\n\n/* Pattern and subject are char arguments, so they can be straightforwardly\ncast to PCRE2_SPTR because we are working in 8-bit code units. The subject\nlength is cast to PCRE2_SIZE for completeness, though PCRE2_SIZE is in fact\ndefined to be size_t. */\n\npattern = (PCRE2_SPTR)argv\u00ddi\u00a8;\nsubject = (PCRE2_SPTR)argv\u00ddi+1\u00a8;\nsubject_length = (PCRE2_SIZE)strlen((char *)subject);\n\n\n/*************************************************************************\n* Now we are going to compile the regular expression pattern, and handle *\n* any errors that are detected.                                          *\n*************************************************************************/\n\nre = pcre2_compile(\n  pattern,               /* the pattern */\n  PCRE2_ZERO_TERMINATED, /* indicates pattern is zero-terminated */\n  0,                     /* default options */\n  &errornumber,          /* for error number */\n  &erroroffset,          /* for error offset */\n  NULL);                 /* use default compile context */\n\n/* Compilation failed: print the error message and exit. */\n\nif (re == NULL)\n  {\n  PCRE2_UCHAR buffer\u00dd256\u00a8;\n  pcre2_get_error_message(errornumber, buffer, sizeof(buffer));\n  printf(\"PCRE2 compilation failed at offset %d: %s\\n\", (int)erroroffset,\n    buffer);\n  return 1;\n  }\n\n\n/*************************************************************************\n* If the compilation succeeded, we call PCRE2 again, in order to do a    *\n* pattern match against the subject string. This does just ONE match. If *\n* further matching is needed, it will be done below. Before running the  *\n* match we must set up a match_data block for holding the result. Using  *\n* pcre2_match_data_create_from_pattern() ensures that the block is       *\n* exactly the right size for the number of capturing parentheses in the  *\n* pattern. If you need to know the actual size of a match_data block as  *\n* a number of bytes, you can find it like this:                          *\n*                                                                        *\n* PCRE2_SIZE match_data_size = pcre2_get_match_data_size(match_data);    *\n*************************************************************************/\n\nmatch_data = pcre2_match_data_create_from_pattern(re, NULL);\n\n/* Now run the match. */\n\nrc = pcre2_match(\n  re,                   /* the compiled pattern */\n  subject,              /* the subject string */\n  subject_length,       /* the length of the subject */\n  0,                    /* start at offset 0 in the subject */\n  0,                    /* default options */\n  match_data,           /* block for storing the result */\n  NULL);                /* use default match context */\n\n/* Matching failed: handle error cases */\n\nif (rc < 0)\n  {\n  switch(rc)\n    {\n    case PCRE2_ERROR_NOMATCH: printf(\"No match\\n\"); break;\n    /*\n    Handle other special cases if you like\n    */\n    default: printf(\"Matching error %d\\n\", rc); break;\n    }\n  pcre2_match_data_free(match_data);   /* Release memory used for the match */\n  pcre2_code_free(re);                 /*   data and the compiled pattern. */\n  return 1;\n  }\n\n/* Match succeded. Get a pointer to the output vector, where string offsets are\nstored. */\n\novector = pcre2_get_ovector_pointer(match_data);\nprintf(\"Match succeeded at offset %d\\n\", (int)ovector\u00dd0\u00a8);\n\n\n/*************************************************************************\n* We have found the first match within the subject string. If the output *\n* vector wasn't big enough, say so. Then output any substrings that were *\n* captured.                                                              *\n*************************************************************************/\n\n/* The output vector wasn't big enough. This should not happen, because we used\npcre2_match_data_create_from_pattern() above. */\n\nif (rc == 0)\n  printf(\"ovector was not big enough for all the captured substrings\\n\");\n\n/* We must guard against patterns such as /(?=.\\K)/ that use \\K in an assertion\nto set the start of a match later than its end. In this demonstration program,\nwe just detect this case and give up. */\n\nif (ovector\u00dd0\u00a8 > ovector\u00dd1\u00a8)\n  {\n  printf(\"\\\\K was used in an assertion to set the match start after its end.\\n\"\n    \"From end to start the match was: %.*s\\n\", (int)(ovector\u00dd0\u00a8 - ovector\u00dd1\u00a8),\n      (char *)(subject + ovector\u00dd1\u00a8));\n  printf(\"Run abandoned\\n\");\n  pcre2_match_data_free(match_data);\n  pcre2_code_free(re);\n  return 1;\n  }\n\n/* Show substrings stored in the output vector by number. Obviously, in a real\napplication you might want to do things other than print them. */\n\nfor (i = 0; i < rc; i++)\n  {\n  PCRE2_SPTR substring_start = subject + ovector\u00dd2*i\u00a8;\n  PCRE2_SIZE substring_length = ovector\u00dd2*i+1\u00a8 - ovector\u00dd2*i\u00a8;\n  printf(\"%2d: %.*s\\n\", i, (int)substring_length, (char *)substring_start);\n  }\n\n\n/**************************************************************************\n* That concludes the basic part of this demonstration program. We have    *\n* compiled a pattern, and performed a single match. The code that follows *\n* shows first how to access named substrings, and then how to code for    *\n* repeated matches on the same subject.                                   *\n**************************************************************************/\n\n/* See if there are any named substrings, and if so, show them by name. First\nwe have to extract the count of named parentheses from the pattern. */\n\n(void)pcre2_pattern_info(\n  re,                   /* the compiled pattern */\n  PCRE2_INFO_NAMECOUNT, /* get the number of named substrings */\n  &namecount);          /* where to put the answer */\n\nif (namecount == 0) printf(\"No named substrings\\n\"); else\n  {\n  PCRE2_SPTR tabptr;\n  printf(\"Named substrings\\n\");\n\n  /* Before we can access the substrings, we must extract the table for\n  translating names to numbers, and the size of each entry in the table. */\n\n  (void)pcre2_pattern_info(\n    re,                       /* the compiled pattern */\n    PCRE2_INFO_NAMETABLE,     /* address of the table */\n    &name_table);             /* where to put the answer */\n\n  (void)pcre2_pattern_info(\n    re,                       /* the compiled pattern */\n    PCRE2_INFO_NAMEENTRYSIZE, /* size of each entry in the table */\n    &name_entry_size);        /* where to put the answer */\n\n  /* Now we can scan the table and, for each entry, print the number, the name,\n  and the substring itself. In the 8-bit library the number is held in two\n  bytes, most significant first. */\n\n  tabptr = name_table;\n  for (i = 0; i < namecount; i++)\n    {\n    int n = (tabptr\u00dd0\u00a8 << 8) | tabptr\u00dd1\u00a8;\n    printf(\"(%d) %*s: %.*s\\n\", n, name_entry_size - 3, tabptr + 2,\n      (int)(ovector\u00dd2*n+1\u00a8 - ovector\u00dd2*n\u00a8), subject + ovector\u00dd2*n\u00a8);\n    tabptr += name_entry_size;\n    }\n  }\n\n\n/*************************************************************************\n* If the \"-g\" option was given on the command line, we want to continue  *\n* to search for additional matches in the subject string, in a similar   *\n* way to the /g option in Perl. This turns out to be trickier than you   *\n* might think because of the possibility of matching an empty string.    *\n* What happens is as follows:                                            *\n*                                                                        *\n* If the previous match was NOT for an empty string, we can just start   *\n* the next match at the end of the previous one.                         *\n*                                                                        *\n* If the previous match WAS for an empty string, we can't do that, as it *\n* would lead to an infinite loop. Instead, a call of pcre2_match() is    *\n* made with the PCRE2_NOTEMPTY_ATSTART and PCRE2_ANCHORED flags set. The *\n* first of these tells PCRE2 that an empty string at the start of the    *\n* subject is not a valid match; other possibilities must be tried. The   *\n* second flag restricts PCRE2 to one match attempt at the initial string *\n* position. If this match succeeds, an alternative to the empty string   *\n* match has been found, and we can print it and proceed round the loop,  *\n* advancing by the length of whatever was found. If this match does not  *\n* succeed, we still stay in the loop, advancing by just one character.   *\n* In UTF-8 mode, which can be set by (*UTF) in the pattern, this may be  *\n* more than one byte.                                                    *\n*                                                                        *\n* However, there is a complication concerned with newlines. When the     *\n* newline convention is such that CRLF is a valid newline, we must       *\n* advance by two characters rather than one. The newline convention can  *\n* be set in the regex by (*CR), etc.; if not, we must find the default.  *\n*************************************************************************/\n\nif (!find_all)     /* Check for -g */\n  {\n  pcre2_match_data_free(match_data);  /* Release the memory that was used */\n  pcre2_code_free(re);                /* for the match data and the pattern. */\n  return 0;                           /* Exit the program. */\n  }\n\n/* Before running the loop, check for UTF-8 and whether CRLF is a valid newline\nsequence. First, find the options with which the regex was compiled and extract\nthe UTF state. */\n\n(void)pcre2_pattern_info(re, PCRE2_INFO_ALLOPTIONS, &option_bits);\nutf8 = (option_bits & PCRE2_UTF) != 0;\n\n/* Now find the newline convention and see whether CRLF is a valid newline\nsequence. */\n\n(void)pcre2_pattern_info(re, PCRE2_INFO_NEWLINE, &newline);\ncrlf_is_newline = newline == PCRE2_NEWLINE_ANY ||\n                  newline == PCRE2_NEWLINE_CRLF ||\n                  newline == PCRE2_NEWLINE_ANYCRLF;\n\n/* Loop for second and subsequent matches */\n\nfor (;;)\n  {\n  uint32_t options = 0;                   /* Normally no options */\n  PCRE2_SIZE start_offset = ovector\u00dd1\u00a8;   /* Start at end of previous match */\n\n  /* If the previous match was for an empty string, we are finished if we are\n  at the end of the subject. Otherwise, arrange to run another match at the\n  same point to see if a non-empty match can be found. */\n\n  if (ovector\u00dd0\u00a8 == ovector\u00dd1\u00a8)\n    {\n    if (ovector\u00dd0\u00a8 == subject_length) break;\n    options = PCRE2_NOTEMPTY_ATSTART | PCRE2_ANCHORED;\n    }\n\n  /* If the previous match was not an empty string, there is one tricky case to\n  consider. If a pattern contains \\K within a lookbehind assertion at the\n  start, the end of the matched string can be at the offset where the match\n  started. Without special action, this leads to a loop that keeps on matching\n  the same substring. We must detect this case and arrange to move the start on\n  by one character. The pcre2_get_startchar() function returns the starting\n  offset that was passed to pcre2_match(). */\n\n  else\n    {\n    PCRE2_SIZE startchar = pcre2_get_startchar(match_data);\n    if (start_offset <= startchar)\n      {\n      if (startchar >= subject_length) break;   /* Reached end of subject.   */\n      start_offset = startchar + 1;             /* Advance by one character. */\n      if (utf8)                                 /* If UTF-8, it may be more  */\n        {                                       /*   than one code unit.     */\n        for (; start_offset < subject_length; start_offset++)\n          if ((subject\u00ddstart_offset\u00a8 & 0xc0) != 0x80) break;\n        }\n      }\n    }\n\n  /* Run the next matching operation */\n\n  rc = pcre2_match(\n    re,                   /* the compiled pattern */\n    subject,              /* the subject string */\n    subject_length,       /* the length of the subject */\n    start_offset,         /* starting offset in the subject */\n    options,              /* options */\n    match_data,           /* block for storing the result */\n    NULL);                /* use default match context */\n\n  /* This time, a result of NOMATCH isn't an error. If the value in \"options\"\n  is zero, it just means we have found all possible matches, so the loop ends.\n  Otherwise, it means we have failed to find a non-empty-string match at a\n  point where there was a previous empty-string match. In this case, we do what\n  Perl does: advance the matching position by one character, and continue. We\n  do this by setting the \"end of previous match\" offset, because that is picked\n  up at the top of the loop as the point at which to start again.\n\n  There are two complications: (a) When CRLF is a valid newline sequence, and\n  the current position is just before it, advance by an extra byte. (b)\n  Otherwise we must ensure that we skip an entire UTF character if we are in\n  UTF mode. */\n\n  if (rc == PCRE2_ERROR_NOMATCH)\n    {\n    if (options == 0) break;                    /* All matches found */\n    ovector\u00dd1\u00a8 = start_offset + 1;              /* Advance one code unit */\n    if (crlf_is_newline &&                      /* If CRLF is a newline & */\n        start_offset < subject_length - 1 &&    /* we are at CRLF, */\n        subject\u00ddstart_offset\u00a8 == '\\r' &&\n        subject\u00ddstart_offset + 1\u00a8 == '\\n')\n      ovector\u00dd1\u00a8 += 1;                          /* Advance by one more. */\n    else if (utf8)                              /* Otherwise, ensure we */\n      {                                         /* advance a whole UTF-8 */\n      while (ovector\u00dd1\u00a8 < subject_length)       /* character. */\n        {\n        if ((subject\u00ddovector\u00dd1\u00a8\u00a8 & 0xc0) != 0x80) break;\n        ovector\u00dd1\u00a8 += 1;\n        }\n      }\n    continue;    /* Go round the loop again */\n    }\n\n  /* Other matching errors are not recoverable. */\n\n  if (rc < 0)\n    {\n    printf(\"Matching error %d\\n\", rc);\n    pcre2_match_data_free(match_data);\n    pcre2_code_free(re);\n    return 1;\n    }\n\n  /* Match succeded */\n\n  printf(\"\\nMatch succeeded again at offset %d\\n\", (int)ovector\u00dd0\u00a8);\n\n  /* The match succeeded, but the output vector wasn't big enough. This\n  should not happen. */\n\n  if (rc == 0)\n    printf(\"ovector was not big enough for all the captured substrings\\n\");\n\n  /* We must guard against patterns such as /(?=.\\K)/ that use \\K in an\n  assertion to set the start of a match later than its end. In this\n  demonstration program, we just detect this case and give up. */\n\n  if (ovector\u00dd0\u00a8 > ovector\u00dd1\u00a8)\n    {\n    printf(\"\\\\K was used in an assertion to set the match start after its end.\\n\"\n      \"From end to start the match was: %.*s\\n\", (int)(ovector\u00dd0\u00a8 - ovector\u00dd1\u00a8),\n        (char *)(subject + ovector\u00dd1\u00a8));\n    printf(\"Run abandoned\\n\");\n    pcre2_match_data_free(match_data);\n    pcre2_code_free(re);\n    return 1;\n    }\n\n  /* As before, show substrings stored in the output vector by number, and then\n  also any named substrings. */\n\n  for (i = 0; i < rc; i++)\n    {\n    PCRE2_SPTR substring_start = subject + ovector\u00dd2*i\u00a8;\n    size_t substring_length = ovector\u00dd2*i+1\u00a8 - ovector\u00dd2*i\u00a8;\n    printf(\"%2d: %.*s\\n\", i, (int)substring_length, (char *)substring_start);\n    }\n\n  if (namecount == 0) printf(\"No named substrings\\n\"); else\n    {\n    PCRE2_SPTR tabptr = name_table;\n    printf(\"Named substrings\\n\");\n    for (i = 0; i < namecount; i++)\n      {\n      int n = (tabptr\u00dd0\u00a8 << 8) | tabptr\u00dd1\u00a8;\n      printf(\"(%d) %*s: %.*s\\n\", n, name_entry_size - 3, tabptr + 2,\n        (int)(ovector\u00dd2*n+1\u00a8 - ovector\u00dd2*n\u00a8), subject + ovector\u00dd2*n\u00a8);\n      tabptr += name_entry_size;\n      }\n    }\n  }      /* End of loop to find second and subsequent matches */\n\nprintf(\"\\n\");\npcre2_match_data_free(match_data);\npcre2_code_free(re);\nreturn 0;\n}\n\n/* End of pcre2demo.c */\n/*autoconv-0001 C:\\projects\\pcre2-10.35\\src\\pcre2demo.c converted to PCR2DEMO*/\n/*autoconv-0011 PCR2DEMO line: 58 pcre2.h replaced by PCRE2.h*/\n/*autoconv-0016 PCR2DEMO line: 58 <pcre2.h> replaced by \"pcre2.h\"*/\n", "mimetype": "text/x-c", "datatype": "ebcdic", "extension": ".x-c"}, "PCR2GREP": {"ttr": 4609, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "\n/*************************************************\n*               pcre2grep program                *\n*************************************************/\n\n/* This is a grep program that uses the 8-bit PCRE regular expression library\nvia the PCRE2 updated API to do its pattern matching. On Unix-like, Windows,\nand native z/OS systems it can recurse into directories, and in z/OS it can\nhandle PDS files.\n\nNote that for native z/OS, in addition to defining the NATIVE_ZOS macro, an\nadditional header is required. That header is not included in the main PCRE2\ndistribution because other apparatus is needed to compile pcre2grep for z/OS.\nThe header can be found in the special z/OS distribution, which is available\nfrom www.zaconsultants.net or from www.cbttape.org.\n\n           Copyright (c) 1997-2020 University of Cambridge\n\n-----------------------------------------------------------------------------\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n\n    * Redistributions of source code must retain the above copyright notice,\n      this list of conditions and the following disclaimer.\n\n    * Redistributions in binary form must reproduce the above copyright\n      notice, this list of conditions and the following disclaimer in the\n      documentation and/or other materials provided with the distribution.\n\n    * Neither the name of the University of Cambridge nor the names of its\n      contributors may be used to endorse or promote products derived from\n      this software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\nAND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\nIMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\nARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\nLIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\nCONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\nSUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\nINTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\nCONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\nARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\nPOSSIBILITY OF SUCH DAMAGE.\n-----------------------------------------------------------------------------\n*/\n\n#ifdef HAVE_CONFIG_H\n#include \"CONFIG.h\"\n#endif\n\n#include <ctype.h>\n#include <locale.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <errno.h>\n\n#include <sys/types.h>\n#include <sys/stat.h>\n\n#if (defined _WIN32 || (defined HAVE_WINDOWS_H && HAVE_WINDOWS_H)) \\\n  && !defined WIN32 && !defined(__CYGWIN__)\n#define WIN32\n#endif\n\n/* Some cmake's define it still */\n#if defined(__CYGWIN__) && defined(WIN32)\n#undef WIN32\n#endif\n\n#ifdef __VMS\n#include clidef\n#include descrip\n#include lib$routines\n#endif\n\n#ifdef WIN32\n#include <io.h>                /* For _setmode() */\n#include <fcntl.h>             /* For _O_BINARY */\n#endif\n\n#if defined(SUPPORT_PCRE2GREP_CALLOUT) && defined(SUPPORT_PCRE2GREP_CALLOUT_FORK)\n#ifdef WIN32\n#include <process.h>\n#else\n#include <sys/wait.h>\n#endif\n#endif\n\n#ifdef HAVE_UNISTD_H\n#include <unistd.h>\n#endif\n\n#ifdef SUPPORT_LIBZ\n#include <zlib.h>\n#endif\n\n#ifdef SUPPORT_LIBBZ2\n#include <bzlib.h>\n#endif\n\n#define PCRE2_CODE_UNIT_WIDTH 8\n#include \"PCRE2.h\"\n\n/* Older versions of MSVC lack snprintf(). This define allows for\nwarning/error-free compilation and testing with MSVC compilers back to at least\nMSVC 10/2010. Except for VC6 (which is missing some fundamentals and fails). */\n\n#if defined(_MSC_VER) && (_MSC_VER < 1900)\n#define snprintf _snprintf\n#endif\n\n/* VC and older compilers don't support %td or %zu, and even some that claim to\nbe C99 don't support it (hence DISABLE_PERCENT_ZT). */\n\n#if defined(_MSC_VER) || !defined(__STDC_VERSION__) || __STDC_VERSION__ < 199901L || defined(DISABLE_PERCENT_ZT)\n#define PTR_FORM \"lu\"\n#define SIZ_FORM \"lu\"\n#define SIZ_CAST (unsigned long int)\n#else\n#define PTR_FORM \"td\"\n#define SIZ_FORM \"zu\"\n#define SIZ_CAST\n#endif\n\n#define FALSE 0\n#define TRUE 1\n\ntypedef int BOOL;\n\n#define DEFAULT_CAPTURE_MAX 50\n\n#if BUFSIZ > 8192\n#define MAXPATLEN BUFSIZ\n#else\n#define MAXPATLEN 8192\n#endif\n\n#define FNBUFSIZ 2048\n#define ERRBUFSIZ 256\n\n/* Values for the \"filenames\" variable, which specifies options for file name\noutput. The order is important; it is assumed that a file name is wanted for\nall values greater than FN_DEFAULT. */\n\nenum { FN_NONE, FN_DEFAULT, FN_MATCH_ONLY, FN_NOMATCH_ONLY, FN_FORCE };\n\n/* File reading styles */\n\nenum { FR_PLAIN, FR_LIBZ, FR_LIBBZ2 };\n\n/* Actions for the -d and -D options */\n\nenum { dee_READ, dee_SKIP, dee_RECURSE };\nenum { DEE_READ, DEE_SKIP };\n\n/* Actions for special processing options (flag bits) */\n\n#define PO_WORD_MATCH     0x0001\n#define PO_LINE_MATCH     0x0002\n#define PO_FIXED_STRINGS  0x0004\n\n/* Binary file options */\n\nenum { BIN_BINARY, BIN_NOMATCH, BIN_TEXT };\n\n/* In newer versions of gcc, with FORTIFY_SOURCE set (the default in some\nenvironments), a warning is issued if the value of fwrite() is ignored.\nUnfortunately, casting to (void) does not suppress the warning. To get round\nthis, we use a macro that compiles a fudge. Oddly, this does not also seem to\napply to fprintf(). */\n\n#define FWRITE_IGNORE(a,b,c,d) if (fwrite(a,b,c,d)) {}\n\n/* Under Windows, we have to set stdout to be binary, so that it does not\nconvert \\r\\n at the ends of output lines to \\r\\r\\n. However, that means that\nany messages written to stdout must have \\r\\n as their line terminator. This is\nhandled by using STDOUT_NL as the newline string. We also use a normal double\nquote for the example, as single quotes aren't usually available. */\n\n#ifdef WIN32\n#define STDOUT_NL  \"\\r\\n\"\n#define QUOT       \"\\\"\"\n#else\n#define STDOUT_NL  \"\\n\"\n#define QUOT       \"'\"\n#endif\n\n\n\n/*************************************************\n*               Global variables                 *\n*************************************************/\n\n/* Jeffrey Friedl has some debugging requirements that are not part of the\nregular code. */\n\n#ifdef JFRIEDL_DEBUG\nstatic int S_arg = -1;\nstatic unsigned int jfriedl_XR = 0; /* repeat regex attempt this many times */\nstatic unsigned int jfriedl_XT = 0; /* replicate text this many times */\nstatic const char *jfriedl_prefix = \"\";\nstatic const char *jfriedl_postfix = \"\";\n#endif\n\nstatic const char *colour_string = \"1;31\";\nstatic const char *colour_option = NULL;\nstatic const char *dee_option = NULL;\nstatic const char *DEE_option = NULL;\nstatic const char *locale = NULL;\nstatic const char *newline_arg = NULL;\nstatic const char *om_separator = NULL;\nstatic const char *stdin_name = \"(standard input)\";\nstatic const char *output_text = NULL;\n\nstatic char *main_buffer = NULL;\n\nstatic int after_context = 0;\nstatic int before_context = 0;\nstatic int binary_files = BIN_BINARY;\nstatic int both_context = 0;\nstatic int bufthird = PCRE2GREP_BUFSIZE;\nstatic int max_bufthird = PCRE2GREP_MAX_BUFSIZE;\nstatic int bufsize = 3*PCRE2GREP_BUFSIZE;\nstatic int endlinetype;\n\nstatic unsigned long int total_count = 0;\nstatic unsigned long int counts_printed = 0;\n\n#ifdef WIN32\nstatic int dee_action = dee_SKIP;\n#else\nstatic int dee_action = dee_READ;\n#endif\n\nstatic int DEE_action = DEE_READ;\nstatic int error_count = 0;\nstatic int filenames = FN_DEFAULT;\n\n#ifdef SUPPORT_PCRE2GREP_JIT\nstatic BOOL use_jit = TRUE;\n#else\nstatic BOOL use_jit = FALSE;\n#endif\n\nstatic const uint8_t *character_tables = NULL;\n\nstatic uint32_t pcre2_options = 0;\nstatic uint32_t extra_options = 0;\nstatic PCRE2_SIZE heap_limit = PCRE2_UNSET;\nstatic uint32_t match_limit = 0;\nstatic uint32_t depth_limit = 0;\n\nstatic pcre2_compile_context *compile_context;\nstatic pcre2_match_context *match_context;\nstatic pcre2_match_data *match_data;\nstatic PCRE2_SIZE *offsets;\nstatic uint32_t offset_size;\nstatic uint32_t capture_max = DEFAULT_CAPTURE_MAX;\n\nstatic BOOL count_only = FALSE;\nstatic BOOL do_colour = FALSE;\n#ifdef WIN32\nstatic BOOL do_ansi = FALSE;\n#endif\nstatic BOOL file_offsets = FALSE;\nstatic BOOL hyphenpending = FALSE;\nstatic BOOL invert = FALSE;\nstatic BOOL line_buffered = FALSE;\nstatic BOOL line_offsets = FALSE;\nstatic BOOL multiline = FALSE;\nstatic BOOL number = FALSE;\nstatic BOOL omit_zero_count = FALSE;\nstatic BOOL resource_error = FALSE;\nstatic BOOL quiet = FALSE;\nstatic BOOL show_total_count = FALSE;\nstatic BOOL silent = FALSE;\nstatic BOOL utf = FALSE;\n\n/* Structure for list of --only-matching capturing numbers. */\n\ntypedef struct omstr {\n  struct omstr *next;\n  int groupnum;\n} omstr;\n\nstatic omstr *only_matching = NULL;\nstatic omstr *only_matching_last = NULL;\nstatic int only_matching_count;\n\n/* Structure for holding the two variables that describe a number chain. */\n\ntypedef struct omdatastr {\n  omstr **anchor;\n  omstr **lastptr;\n} omdatastr;\n\nstatic omdatastr only_matching_data = { &only_matching, &only_matching_last };\n\n/* Structure for list of file names (for -f and --{in,ex}clude-from) */\n\ntypedef struct fnstr {\n  struct fnstr *next;\n  char *name;\n} fnstr;\n\nstatic fnstr *exclude_from = NULL;\nstatic fnstr *exclude_from_last = NULL;\nstatic fnstr *include_from = NULL;\nstatic fnstr *include_from_last = NULL;\n\nstatic fnstr *file_lists = NULL;\nstatic fnstr *file_lists_last = NULL;\nstatic fnstr *pattern_files = NULL;\nstatic fnstr *pattern_files_last = NULL;\n\n/* Structure for holding the two variables that describe a file name chain. */\n\ntypedef struct fndatastr {\n  fnstr **anchor;\n  fnstr **lastptr;\n} fndatastr;\n\nstatic fndatastr exclude_from_data = { &exclude_from, &exclude_from_last };\nstatic fndatastr include_from_data = { &include_from, &include_from_last };\nstatic fndatastr file_lists_data = { &file_lists, &file_lists_last };\nstatic fndatastr pattern_files_data = { &pattern_files, &pattern_files_last };\n\n/* Structure for pattern and its compiled form; used for matching patterns and\nalso for include/exclude patterns. */\n\ntypedef struct patstr {\n  struct patstr *next;\n  char *string;\n  PCRE2_SIZE length;\n  pcre2_code *compiled;\n} patstr;\n\nstatic patstr *patterns = NULL;\nstatic patstr *patterns_last = NULL;\nstatic patstr *include_patterns = NULL;\nstatic patstr *include_patterns_last = NULL;\nstatic patstr *exclude_patterns = NULL;\nstatic patstr *exclude_patterns_last = NULL;\nstatic patstr *include_dir_patterns = NULL;\nstatic patstr *include_dir_patterns_last = NULL;\nstatic patstr *exclude_dir_patterns = NULL;\nstatic patstr *exclude_dir_patterns_last = NULL;\n\n/* Structure holding the two variables that describe a pattern chain. A pointer\nto such structures is used for each appropriate option. */\n\ntypedef struct patdatastr {\n  patstr **anchor;\n  patstr **lastptr;\n} patdatastr;\n\nstatic patdatastr match_patdata = { &patterns, &patterns_last };\nstatic patdatastr include_patdata = { &include_patterns, &include_patterns_last };\nstatic patdatastr exclude_patdata = { &exclude_patterns, &exclude_patterns_last };\nstatic patdatastr include_dir_patdata = { &include_dir_patterns, &include_dir_patterns_last };\nstatic patdatastr exclude_dir_patdata = { &exclude_dir_patterns, &exclude_dir_patterns_last };\n\nstatic patstr **incexlist\u00dd4\u00a8 = { &include_patterns, &exclude_patterns,\n                                 &include_dir_patterns, &exclude_dir_patterns };\n\nstatic const char *incexname\u00dd4\u00a8 = { \"--include\", \"--exclude\",\n                                    \"--include-dir\", \"--exclude-dir\" };\n\n/* Structure for options and list of them */\n\nenum { OP_NODATA, OP_STRING, OP_OP_STRING, OP_NUMBER, OP_U32NUMBER, OP_SIZE,\n       OP_OP_NUMBER, OP_OP_NUMBERS, OP_PATLIST, OP_FILELIST, OP_BINFILES };\n\ntypedef struct option_item {\n  int type;\n  int one_char;\n  void *dataptr;\n  const char *long_name;\n  const char *help_text;\n} option_item;\n\n/* Options without a single-letter equivalent get a negative value. This can be\nused to identify them. */\n\n#define N_COLOUR       (-1)\n#define N_EXCLUDE      (-2)\n#define N_EXCLUDE_DIR  (-3)\n#define N_HELP         (-4)\n#define N_INCLUDE      (-5)\n#define N_INCLUDE_DIR  (-6)\n#define N_LABEL        (-7)\n#define N_LOCALE       (-8)\n#define N_NULL         (-9)\n#define N_LOFFSETS     (-10)\n#define N_FOFFSETS     (-11)\n#define N_LBUFFER      (-12)\n#define N_H_LIMIT      (-13)\n#define N_M_LIMIT      (-14)\n#define N_M_LIMIT_DEP  (-15)\n#define N_BUFSIZE      (-16)\n#define N_NOJIT        (-17)\n#define N_FILE_LIST    (-18)\n#define N_BINARY_FILES (-19)\n#define N_EXCLUDE_FROM (-20)\n#define N_INCLUDE_FROM (-21)\n#define N_OM_SEPARATOR (-22)\n#define N_MAX_BUFSIZE  (-23)\n#define N_OM_CAPTURE   (-24)\n\nstatic option_item optionlist\u00dd\u00a8 = {\n  { OP_NODATA,     N_NULL,   NULL,              \"\",              \"terminate options\" },\n  { OP_NODATA,     N_HELP,   NULL,              \"help\",          \"display this help and exit\" },\n  { OP_NUMBER,     'A',      &after_context,    \"after-context=number\", \"set number of following context lines\" },\n  { OP_NODATA,     'a',      NULL,              \"text\",          \"treat binary files as text\" },\n  { OP_NUMBER,     'B',      &before_context,   \"before-context=number\", \"set number of prior context lines\" },\n  { OP_BINFILES,   N_BINARY_FILES, NULL,        \"binary-files=word\", \"set treatment of binary files\" },\n  { OP_NUMBER,     N_BUFSIZE,&bufthird,         \"buffer-size=number\", \"set processing buffer starting size\" },\n  { OP_NUMBER,     N_MAX_BUFSIZE,&max_bufthird, \"max-buffer-size=number\",  \"set processing buffer maximum size\" },\n  { OP_OP_STRING,  N_COLOUR, &colour_option,    \"color=option\",  \"matched text color option\" },\n  { OP_OP_STRING,  N_COLOUR, &colour_option,    \"colour=option\", \"matched text colour option\" },\n  { OP_NUMBER,     'C',      &both_context,     \"context=number\", \"set number of context lines, before & after\" },\n  { OP_NODATA,     'c',      NULL,              \"count\",         \"print only a count of matching lines per FILE\" },\n  { OP_STRING,     'D',      &DEE_option,       \"devices=action\",\"how to handle devices, FIFOs, and sockets\" },\n  { OP_STRING,     'd',      &dee_option,       \"directories=action\", \"how to handle directories\" },\n  { OP_PATLIST,    'e',      &match_patdata,    \"regex(p)=pattern\", \"specify pattern (may be used more than once)\" },\n  { OP_NODATA,     'F',      NULL,              \"fixed-strings\", \"patterns are sets of newline-separated strings\" },\n  { OP_FILELIST,   'f',      &pattern_files_data, \"file=path\",   \"read patterns from file\" },\n  { OP_FILELIST,   N_FILE_LIST, &file_lists_data, \"file-list=path\",\"read files to search from file\" },\n  { OP_NODATA,     N_FOFFSETS, NULL,            \"file-offsets\",  \"output file offsets, not text\" },\n  { OP_NODATA,     'H',      NULL,              \"with-filename\", \"force the prefixing filename on output\" },\n  { OP_NODATA,     'h',      NULL,              \"no-filename\",   \"suppress the prefixing filename on output\" },\n  { OP_NODATA,     'I',      NULL,              \"\",              \"treat binary files as not matching (ignore)\" },\n  { OP_NODATA,     'i',      NULL,              \"ignore-case\",   \"ignore case distinctions\" },\n  { OP_NODATA,     'l',      NULL,              \"files-with-matches\", \"print only FILE names containing matches\" },\n  { OP_NODATA,     'L',      NULL,              \"files-without-match\",\"print only FILE names not containing matches\" },\n  { OP_STRING,     N_LABEL,  &stdin_name,       \"label=name\",    \"set name for standard input\" },\n  { OP_NODATA,     N_LBUFFER, NULL,             \"line-buffered\", \"use line buffering\" },\n  { OP_NODATA,     N_LOFFSETS, NULL,            \"line-offsets\",  \"output line numbers and offsets, not text\" },\n  { OP_STRING,     N_LOCALE, &locale,           \"locale=locale\", \"use the named locale\" },\n  { OP_SIZE,       N_H_LIMIT, &heap_limit,      \"heap-limit=number\",  \"set PCRE2 heap limit option (kibibytes)\" },\n  { OP_U32NUMBER,  N_M_LIMIT, &match_limit,     \"match-limit=number\", \"set PCRE2 match limit option\" },\n  { OP_U32NUMBER,  N_M_LIMIT_DEP, &depth_limit, \"depth-limit=number\", \"set PCRE2 depth limit option\" },\n  { OP_U32NUMBER,  N_M_LIMIT_DEP, &depth_limit, \"recursion-limit=number\", \"obsolete synonym for depth-limit\" },\n  { OP_NODATA,     'M',      NULL,              \"multiline\",     \"run in multiline mode\" },\n  { OP_STRING,     'N',      &newline_arg,      \"newline=type\",  \"set newline type (CR, LF, CRLF, ANYCRLF, ANY, or NUL)\" },\n  { OP_NODATA,     'n',      NULL,              \"line-number\",   \"print line number with output lines\" },\n#ifdef SUPPORT_PCRE2GREP_JIT\n  { OP_NODATA,     N_NOJIT,  NULL,              \"no-jit\",        \"do not use just-in-time compiler optimization\" },\n#else\n  { OP_NODATA,     N_NOJIT,  NULL,              \"no-jit\",        \"ignored: this pcre2grep does not support JIT\" },\n#endif\n  { OP_STRING,     'O',      &output_text,       \"output=text\",   \"show only this text (possibly expanded)\" },\n  { OP_OP_NUMBERS, 'o',      &only_matching_data, \"only-matching=n\", \"show only the part of the line that matched\" },\n  { OP_STRING,     N_OM_SEPARATOR, &om_separator, \"om-separator=text\", \"set separator for multiple -o output\" },\n  { OP_U32NUMBER,  N_OM_CAPTURE, &capture_max,  \"om-capture=n\",  \"set capture count for --only-matching\" },\n  { OP_NODATA,     'q',      NULL,              \"quiet\",         \"suppress output, just set return code\" },\n  { OP_NODATA,     'r',      NULL,              \"recursive\",     \"recursively scan sub-directories\" },\n  { OP_PATLIST,    N_EXCLUDE,&exclude_patdata,  \"exclude=pattern\",\"exclude matching files when recursing\" },\n  { OP_PATLIST,    N_INCLUDE,&include_patdata,  \"include=pattern\",\"include matching files when recursing\" },\n  { OP_PATLIST,    N_EXCLUDE_DIR,&exclude_dir_patdata, \"exclude-dir=pattern\",\"exclude matching directories when recursing\" },\n  { OP_PATLIST,    N_INCLUDE_DIR,&include_dir_patdata, \"include-dir=pattern\",\"include matching directories when recursing\" },\n  { OP_FILELIST,   N_EXCLUDE_FROM,&exclude_from_data, \"exclude-from=path\", \"read exclude list from file\" },\n  { OP_FILELIST,   N_INCLUDE_FROM,&include_from_data, \"include-from=path\", \"read include list from file\" },\n#ifdef JFRIEDL_DEBUG\n  { OP_OP_NUMBER, 'S',      &S_arg,            \"jeffS\",         \"replace matched (sub)string with X\" },\n#endif\n  { OP_NODATA,    's',      NULL,              \"no-messages\",   \"suppress error messages\" },\n  { OP_NODATA,    't',      NULL,              \"total-count\",   \"print total count of matching lines\" },\n  { OP_NODATA,    'u',      NULL,              \"utf\",           \"use UTF mode\" },\n  { OP_NODATA,    'U',      NULL,              \"utf-allow-invalid\", \"use UTF mode, allow for invalid code units\" },\n  { OP_NODATA,    'V',      NULL,              \"version\",       \"print version information and exit\" },\n  { OP_NODATA,    'v',      NULL,              \"invert-match\",  \"select non-matching lines\" },\n  { OP_NODATA,    'w',      NULL,              \"word-regex(p)\", \"force patterns to match only as words\"  },\n  { OP_NODATA,    'x',      NULL,              \"line-regex(p)\", \"force patterns to match only whole lines\" },\n  { OP_NODATA,    0,        NULL,               NULL,            NULL }\n};\n\n/* Table of names for newline types. Must be kept in step with the definitions\nof PCRE2_NEWLINE_xx in pcre2.h. */\n\nstatic const char *newlines\u00dd\u00a8 = {\n  \"DEFAULT\", \"CR\", \"LF\", \"CRLF\", \"ANY\", \"ANYCRLF\", \"NUL\" };\n\n/* UTF-8 tables - used only when the newline setting is \"any\". */\n\nconst int utf8_table3\u00dd\u00a8 = { 0xff, 0x1f, 0x0f, 0x07, 0x03, 0x01};\n\nconst char utf8_table4\u00dd\u00a8 = {\n  1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n  1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n  2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,\n  3,3,3,3,3,3,3,3,4,4,4,4,5,5,5,5 };\n\n\n#if !defined(VPCOMPAT) && !defined(HAVE_MEMMOVE)\n/*************************************************\n*    Emulated memmove() for systems without it   *\n*************************************************/\n\n/* This function can make use of bcopy() if it is available. Otherwise do it by\nsteam, as there are some non-Unix environments that lack both memmove() and\nbcopy(). */\n\nstatic void *\nemulated_memmove(void *d, const void *s, size_t n)\n{\n#ifdef HAVE_BCOPY\nbcopy(s, d, n);\nreturn d;\n#else\nsize_t i;\nunsigned char *dest = (unsigned char *)d;\nconst unsigned char *src = (const unsigned char *)s;\nif (dest > src)\n  {\n  dest += n;\n  src += n;\n  for (i = 0; i < n; ++i) *(--dest) = *(--src);\n  return (void *)dest;\n  }\nelse\n  {\n  for (i = 0; i < n; ++i) *dest++ = *src++;\n  return (void *)(dest - n);\n  }\n#endif   /* not HAVE_BCOPY */\n}\n#undef memmove\n#define memmove(d,s,n) emulated_memmove(d,s,n)\n#endif   /* not VPCOMPAT && not HAVE_MEMMOVE */\n\n\n/*************************************************\n*         Case-independent string compare        *\n*************************************************/\n\nstatic int\nstrcmpic(const char *str1, const char *str2)\n{\nunsigned int c1, c2;\nwhile (*str1 != '\\0' || *str2 != '\\0')\n  {\n  c1 = tolower(*str1++);\n  c2 = tolower(*str2++);\n  if (c1 != c2) return ((c1 > c2) << 1) - 1;\n  }\nreturn 0;\n}\n\n\n/*************************************************\n*         Parse GREP_COLORS                      *\n*************************************************/\n\n/* Extract ms or mt from GREP_COLORS.\n\nArgument:  the string, possibly NULL\nReturns:   the value of ms or mt, or NULL if neither present\n*/\n\nstatic char *\nparse_grep_colors(const char *gc)\n{\nstatic char seq\u00dd16\u00a8;\nchar *col;\nuint32_t len;\nif (gc == NULL) return NULL;\ncol = strstr(gc, \"ms=\");\nif (col == NULL) col = strstr(gc, \"mt=\");\nif (col == NULL) return NULL;\nlen = 0;\ncol += 3;\nwhile (*col != ':' && *col != 0 && len < sizeof(seq)-1)\n  seq\u00ddlen++\u00a8 = *col++;\nseq\u00ddlen\u00a8 = 0;\nreturn seq;\n}\n\n\n/*************************************************\n*         Exit from the program                  *\n*************************************************/\n\n/* If there has been a resource error, give a suitable message.\n\nArgument:  the return code\nReturns:   does not return\n*/\n\nstatic void\npcre2grep_exit(int rc)\n{\n/* VMS does exit codes differently: both exit(1) and exit(0) return with a\nstatus of 1, which is not helpful. To help with this problem, define a symbol\n(akin to an environment variable) called \"PCRE2GREP_RC\" and put the exit code\ntherein. */\n\n#ifdef __VMS\n  char val_buf\u00dd4\u00a8;\n  $DESCRIPTOR(sym_nam, \"PCRE2GREP_RC\");\n  $DESCRIPTOR(sym_val, val_buf);\n  sprintf(val_buf, \"%d\", rc);\n  sym_val.dsc$w_length = strlen(val_buf);\n  lib$set_symbol(&sym_nam, &sym_val);\n#endif\n\nif (resource_error)\n  {\n  fprintf(stderr, \"pcre2grep: Error %d, %d, %d or %d means that a resource \"\n    \"limit was exceeded.\\n\", PCRE2_ERROR_JIT_STACKLIMIT, PCRE2_ERROR_MATCHLIMIT,\n    PCRE2_ERROR_DEPTHLIMIT, PCRE2_ERROR_HEAPLIMIT);\n  fprintf(stderr, \"pcre2grep: Check your regex for nested unlimited loops.\\n\");\n  }\nexit(rc);\n}\n\n\n/*************************************************\n*          Add item to chain of patterns         *\n*************************************************/\n\n/* Used to add an item onto a chain, or just return an unconnected item if the\n\"after\" argument is NULL.\n\nArguments:\n  s          pattern string to add\n  patlen     length of pattern\n  after      if not NULL points to item to insert after\n\nReturns:     new pattern block or NULL on error\n*/\n\nstatic patstr *\nadd_pattern(char *s, PCRE2_SIZE patlen, patstr *after)\n{\npatstr *p = (patstr *)malloc(sizeof(patstr));\nif (p == NULL)\n  {\n  fprintf(stderr, \"pcre2grep: malloc failed\\n\");\n  pcre2grep_exit(2);\n  }\nif (patlen > MAXPATLEN)\n  {\n  fprintf(stderr, \"pcre2grep: pattern is too long (limit is %d bytes)\\n\",\n    MAXPATLEN);\n  free(p);\n  return NULL;\n  }\np->next = NULL;\np->string = s;\np->length = patlen;\np->compiled = NULL;\n\nif (after != NULL)\n  {\n  p->next = after->next;\n  after->next = p;\n  }\nreturn p;\n}\n\n\n/*************************************************\n*           Free chain of patterns               *\n*************************************************/\n\n/* Used for several chains of patterns.\n\nArgument: pointer to start of chain\nReturns:  nothing\n*/\n\nstatic void\nfree_pattern_chain(patstr *pc)\n{\nwhile (pc != NULL)\n  {\n  patstr *p = pc;\n  pc = p->next;\n  if (p->compiled != NULL) pcre2_code_free(p->compiled);\n  free(p);\n  }\n}\n\n\n/*************************************************\n*           Free chain of file names             *\n*************************************************/\n\n/*\nArgument: pointer to start of chain\nReturns:  nothing\n*/\n\nstatic void\nfree_file_chain(fnstr *fn)\n{\nwhile (fn != NULL)\n  {\n  fnstr *f = fn;\n  fn = f->next;\n  free(f);\n  }\n}\n\n\n/*************************************************\n*            OS-specific functions               *\n*************************************************/\n\n/* These definitions are needed in all Windows environments, even those where\nUnix-style directory scanning can be used (see below). */\n\n#ifdef WIN32\n\n#ifndef STRICT\n# define STRICT\n#endif\n#ifndef WIN32_LEAN_AND_MEAN\n# define WIN32_LEAN_AND_MEAN\n#endif\n\n#include <windows.h>\n\n#define iswild(name) (strpbrk(name, \"*?\") != NULL)\n\n/* Convert ANSI BGR format to RGB used by Windows */\n#define BGR_RGB(x) ((x & 1 ? 4 : 0) | (x & 2) | (x & 4 ? 1 : 0))\n\nstatic HANDLE hstdout;\nstatic CONSOLE_SCREEN_BUFFER_INFO csbi;\nstatic WORD match_colour;\n\nstatic WORD\ndecode_ANSI_colour(const char *cs)\n{\nWORD result = csbi.wAttributes;\nwhile (*cs)\n  {\n  if (isdigit(*cs))\n    {\n    int code = atoi(cs);\n    if (code == 1) result |= 0x08;\n    else if (code == 4) result |= 0x8000;\n    else if (code == 5) result |= 0x80;\n    else if (code >= 30 && code <= 37) result = (result & 0xF8) | BGR_RGB(code - 30);\n    else if (code == 39) result = (result & 0xF0) | (csbi.wAttributes & 0x0F);\n    else if (code >= 40 && code <= 47) result = (result & 0x8F) | (BGR_RGB(code - 40) << 4);\n    else if (code == 49) result = (result & 0x0F) | (csbi.wAttributes & 0xF0);\n    /* aixterm high intensity colour codes */\n    else if (code >= 90 && code <= 97) result = (result & 0xF0) | BGR_RGB(code - 90) | 0x08;\n    else if (code >= 100 && code <= 107) result = (result & 0x0F) | (BGR_RGB(code - 100) << 4) | 0x80;\n\n    while (isdigit(*cs)) cs++;\n    }\n  if (*cs) cs++;\n  }\nreturn result;\n}\n\n\nstatic void\ninit_colour_output()\n{\nif (do_colour)\n  {\n  hstdout = GetStdHandle(STD_OUTPUT_HANDLE);\n  /* This fails when redirected to con; try again if so. */\n  if (!GetConsoleScreenBufferInfo(hstdout, &csbi) && !do_ansi)\n    {\n    HANDLE hcon = CreateFile(\"CONOUT$\", GENERIC_READ | GENERIC_WRITE,\n      FILE_SHARE_WRITE, NULL, OPEN_EXISTING, 0, NULL);\n    GetConsoleScreenBufferInfo(hcon, &csbi);\n    CloseHandle(hcon);\n    }\n  match_colour = decode_ANSI_colour(colour_string);\n  /* No valid colour found - turn off colouring */\n  if (!match_colour) do_colour = FALSE;\n  }\n}\n\n#endif  /* WIN32 */\n\n\n/* The following sets of functions are defined so that they can be made system\nspecific. At present there are versions for Unix-style environments, Windows,\nnative z/OS, and \"no support\". */\n\n\n/************* Directory scanning Unix-style and z/OS ***********/\n\n#if (defined HAVE_SYS_STAT_H && defined HAVE_DIRENT_H && defined HAVE_SYS_TYPES_H) || defined NATIVE_ZOS\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <dirent.h>\n\n#if defined NATIVE_ZOS\n/************* Directory and PDS/E scanning for z/OS ***********/\n/************* z/OS looks mostly like Unix with USS ************/\n/* However, z/OS needs the #include statements in this header */\n#include \"pcrzosfs.h\"\n/* That header is not included in the main PCRE distribution because\n   other apparatus is needed to compile pcre2grep for z/OS. The header\n   can be found in the special z/OS distribution, which is available\n   from www.zaconsultants.net or from www.cbttape.org. */\n#endif\n\ntypedef DIR directory_type;\n#define FILESEP '/'\n\nstatic int\nisdirectory(char *filename)\n{\nstruct stat statbuf;\nif (stat(filename, &statbuf) < 0)\n  return 0;        /* In the expectation that opening as a file will fail */\nreturn S_ISDIR(statbuf.st_mode);\n}\n\nstatic directory_type *\nopendirectory(char *filename)\n{\nreturn opendir(filename);\n}\n\nstatic char *\nreaddirectory(directory_type *dir)\n{\nfor (;;)\n  {\n  struct dirent *dent = readdir(dir);\n  if (dent == NULL) return NULL;\n  if (strcmp(dent->d_name, \".\") != 0 && strcmp(dent->d_name, \"..\") != 0)\n    return dent->d_name;\n  }\n/* Control never reaches here */\n}\n\nstatic void\nclosedirectory(directory_type *dir)\n{\nclosedir(dir);\n}\n\n\n/************* Test for regular file, Unix-style **********/\n\nstatic int\nisregfile(char *filename)\n{\nstruct stat statbuf;\nif (stat(filename, &statbuf) < 0)\n  return 1;        /* In the expectation that opening as a file will fail */\nreturn S_ISREG(statbuf.st_mode);\n}\n\n\n#if defined NATIVE_ZOS\n/************* Test for a terminal in z/OS **********/\n/* isatty() does not work in a TSO environment, so always give FALSE.*/\n\nstatic BOOL\nis_stdout_tty(void)\n{\nreturn FALSE;\n}\n\nstatic BOOL\nis_file_tty(FILE *f)\n{\nreturn FALSE;\n}\n\n\n/************* Test for a terminal, Unix-style **********/\n\n#else\nstatic BOOL\nis_stdout_tty(void)\n{\nreturn isatty(fileno(stdout));\n}\n\nstatic BOOL\nis_file_tty(FILE *f)\n{\nreturn isatty(fileno(f));\n}\n#endif\n\n\n/************* Print optionally coloured match Unix-style and z/OS **********/\n\nstatic void\nprint_match(const void *buf, int length)\n{\nif (length == 0) return;\nif (do_colour) fprintf(stdout, \"%c\u00dd%sm\", 0x1b, colour_string);\nFWRITE_IGNORE(buf, 1, length, stdout);\nif (do_colour) fprintf(stdout, \"%c\u00dd0m\", 0x1b);\n}\n\n/* End of Unix-style or native z/OS environment functions. */\n\n\n/************* Directory scanning in Windows ***********/\n\n/* I (Philip Hazel) have no means of testing this code. It was contributed by\nLionel Fourquaux. David Burgess added a patch to define INVALID_FILE_ATTRIBUTES\nwhen it did not exist. David Byron added a patch that moved the #include of\n<windows.h> to before the INVALID_FILE_ATTRIBUTES definition rather than after.\n*/\n\n#elif defined WIN32\n\n#ifndef INVALID_FILE_ATTRIBUTES\n#define INVALID_FILE_ATTRIBUTES 0xFFFFFFFF\n#endif\n\ntypedef struct directory_type\n{\nHANDLE handle;\nBOOL first;\nWIN32_FIND_DATA data;\n} directory_type;\n\n#define FILESEP '/'\n\nint\nisdirectory(char *filename)\n{\nDWORD attr = GetFileAttributes(filename);\nif (attr == INVALID_FILE_ATTRIBUTES)\n  return 0;\nreturn (attr & FILE_ATTRIBUTE_DIRECTORY) != 0;\n}\n\ndirectory_type *\nopendirectory(char *filename)\n{\nsize_t len;\nchar *pattern;\ndirectory_type *dir;\nDWORD err;\nlen = strlen(filename);\npattern = (char *)malloc(len + 3);\ndir = (directory_type *)malloc(sizeof(*dir));\nif ((pattern == NULL) || (dir == NULL))\n  {\n  fprintf(stderr, \"pcre2grep: malloc failed\\n\");\n  pcre2grep_exit(2);\n  }\nmemcpy(pattern, filename, len);\nif (iswild(filename))\n  pattern\u00ddlen\u00a8 = 0;\nelse\n  memcpy(&(pattern\u00ddlen\u00a8), \"\\\\*\", 3);\ndir->handle = FindFirstFile(pattern, &(dir->data));\nif (dir->handle != INVALID_HANDLE_VALUE)\n  {\n  free(pattern);\n  dir->first = TRUE;\n  return dir;\n  }\nerr = GetLastError();\nfree(pattern);\nfree(dir);\nerrno = (err == ERROR_ACCESS_DENIED) ? EACCES : ENOENT;\nreturn NULL;\n}\n\nchar *\nreaddirectory(directory_type *dir)\n{\nfor (;;)\n  {\n  if (!dir->first)\n    {\n    if (!FindNextFile(dir->handle, &(dir->data)))\n      return NULL;\n    }\n  else\n    {\n    dir->first = FALSE;\n    }\n  if (strcmp(dir->data.cFileName, \".\") != 0 && strcmp(dir->data.cFileName, \"..\") != 0)\n    return dir->data.cFileName;\n  }\n#ifndef _MSC_VER\nreturn NULL;   /* Keep compiler happy; never executed */\n#endif\n}\n\nvoid\nclosedirectory(directory_type *dir)\n{\nFindClose(dir->handle);\nfree(dir);\n}\n\n\n/************* Test for regular file in Windows **********/\n\n/* I don't know how to do this, or if it can be done; assume all paths are\nregular if they are not directories. */\n\nint isregfile(char *filename)\n{\nreturn !isdirectory(filename);\n}\n\n\n/************* Test for a terminal in Windows **********/\n\nstatic BOOL\nis_stdout_tty(void)\n{\nreturn _isatty(_fileno(stdout));\n}\n\nstatic BOOL\nis_file_tty(FILE *f)\n{\nreturn _isatty(_fileno(f));\n}\n\n\n/************* Print optionally coloured match in Windows **********/\n\nstatic void\nprint_match(const void *buf, int length)\n{\nif (length == 0) return;\nif (do_colour)\n  {\n  if (do_ansi) fprintf(stdout, \"%c\u00dd%sm\", 0x1b, colour_string);\n    else SetConsoleTextAttribute(hstdout, match_colour);\n  }\nFWRITE_IGNORE(buf, 1, length, stdout);\nif (do_colour)\n  {\n  if (do_ansi) fprintf(stdout, \"%c\u00dd0m\", 0x1b);\n    else SetConsoleTextAttribute(hstdout, csbi.wAttributes);\n  }\n}\n\n/* End of Windows functions */\n\n\n/************* Directory scanning when we can't do it ***********/\n\n/* The type is void, and apart from isdirectory(), the functions do nothing. */\n\n#else\n\n#define FILESEP 0\ntypedef void directory_type;\n\nint isdirectory(char *filename) { return 0; }\ndirectory_type * opendirectory(char *filename) { return (directory_type*)0;}\nchar *readdirectory(directory_type *dir) { return (char*)0;}\nvoid closedirectory(directory_type *dir) {}\n\n\n/************* Test for regular file when we can't do it **********/\n\n/* Assume all files are regular. */\n\nint isregfile(char *filename) { return 1; }\n\n\n/************* Test for a terminal when we can't do it **********/\n\nstatic BOOL\nis_stdout_tty(void)\n{\nreturn FALSE;\n}\n\nstatic BOOL\nis_file_tty(FILE *f)\n{\nreturn FALSE;\n}\n\n\n/************* Print optionally coloured match when we can't do it **********/\n\nstatic void\nprint_match(const void *buf, int length)\n{\nif (length == 0) return;\nFWRITE_IGNORE(buf, 1, length, stdout);\n}\n\n#endif  /* End of system-specific functions */\n\n\n\n#ifndef HAVE_STRERROR\n/*************************************************\n*     Provide strerror() for non-ANSI libraries  *\n*************************************************/\n\n/* Some old-fashioned systems still around (e.g. SunOS4) don't have strerror()\nin their libraries, but can provide the same facility by this simple\nalternative function. */\n\nextern int   sys_nerr;\nextern char *sys_errlist\u00dd\u00a8;\n\nchar *\nstrerror(int n)\n{\nif (n < 0 || n >= sys_nerr) return \"unknown error number\";\nreturn sys_errlist\u00ddn\u00a8;\n}\n#endif /* HAVE_STRERROR */\n\n\n\n/*************************************************\n*                Usage function                  *\n*************************************************/\n\nstatic int\nusage(int rc)\n{\noption_item *op;\nfprintf(stderr, \"Usage: pcre2grep \u00dd-\");\nfor (op = optionlist; op->one_char != 0; op++)\n  {\n  if (op->one_char > 0) fprintf(stderr, \"%c\", op->one_char);\n  }\nfprintf(stderr, \"\u00a8 \u00ddlong options\u00a8 \u00ddpattern\u00a8 \u00ddfiles\u00a8\\n\");\nfprintf(stderr, \"Type \\\"pcre2grep --help\\\" for more information and the long \"\n  \"options.\\n\");\nreturn rc;\n}\n\n\n\n/*************************************************\n*                Help function                   *\n*************************************************/\n\nstatic void\nhelp(void)\n{\noption_item *op;\n\nprintf(\"Usage: pcre2grep \u00ddOPTION\u00a8... \u00ddPATTERN\u00a8 \u00ddFILE1 FILE2 ...\u00a8\" STDOUT_NL);\nprintf(\"Search for PATTERN in each FILE or standard input.\" STDOUT_NL);\nprintf(\"PATTERN must be present if neither -e nor -f is used.\" STDOUT_NL);\n\n#ifdef SUPPORT_PCRE2GREP_CALLOUT\n#ifdef SUPPORT_PCRE2GREP_CALLOUT_FORK\nprintf(\"All callout scripts in patterns are supported.\" STDOUT_NL);\n#else\nprintf(\"Non-fork callout scripts in patterns are supported.\" STDOUT_NL);\n#endif\n#else\nprintf(\"Callout scripts are not supported in this pcre2grep.\" STDOUT_NL);\n#endif\n\nprintf(\"\\\"-\\\" can be used as a file name to mean STDIN.\" STDOUT_NL);\n\n#ifdef SUPPORT_LIBZ\nprintf(\"Files whose names end in .gz are read using zlib.\" STDOUT_NL);\n#endif\n\n#ifdef SUPPORT_LIBBZ2\nprintf(\"Files whose names end in .bz2 are read using bzlib2.\" STDOUT_NL);\n#endif\n\n#if defined SUPPORT_LIBZ || defined SUPPORT_LIBBZ2\nprintf(\"Other files and the standard input are read as plain files.\" STDOUT_NL STDOUT_NL);\n#else\nprintf(\"All files are read as plain files, without any interpretation.\" STDOUT_NL STDOUT_NL);\n#endif\n\nprintf(\"Example: pcre2grep -i \" QUOT \"hello.*world\" QUOT \" menu.h main.c\" STDOUT_NL STDOUT_NL);\nprintf(\"Options:\" STDOUT_NL);\n\nfor (op = optionlist; op->one_char != 0; op++)\n  {\n  int n;\n  char s\u00dd4\u00a8;\n\n  if (op->one_char > 0 && (op->long_name)\u00dd0\u00a8 == 0)\n    n = 31 - printf(\"  -%c\", op->one_char);\n  else\n    {\n    if (op->one_char > 0) sprintf(s, \"-%c,\", op->one_char);\n      else strcpy(s, \"   \");\n    n = 31 - printf(\"  %s --%s\", s, op->long_name);\n    }\n\n  if (n < 1) n = 1;\n  printf(\"%.*s%s\" STDOUT_NL, n, \"                           \", op->help_text);\n  }\n\nprintf(STDOUT_NL \"Numbers may be followed by K or M, e.g. --max-buffer-size=100K.\" STDOUT_NL);\nprintf(\"The default value for --buffer-size is %d.\" STDOUT_NL, PCRE2GREP_BUFSIZE);\nprintf(\"The default value for --max-buffer-size is %d.\" STDOUT_NL, PCRE2GREP_MAX_BUFSIZE);\nprintf(\"When reading patterns or file names from a file, trailing white\" STDOUT_NL);\nprintf(\"space is removed and blank lines are ignored.\" STDOUT_NL);\nprintf(\"The maximum size of any pattern is %d bytes.\" STDOUT_NL, MAXPATLEN);\n\nprintf(STDOUT_NL \"With no FILEs, read standard input. If fewer than two FILEs given, assume -h.\" STDOUT_NL);\nprintf(\"Exit status is 0 if any matches, 1 if no matches, and 2 if trouble.\" STDOUT_NL);\n}\n\n\n\n/*************************************************\n*            Test exclude/includes               *\n*************************************************/\n\n/* If any exclude pattern matches, the path is excluded. Otherwise, unless\nthere are no includes, the path must match an include pattern.\n\nArguments:\n  path      the path to be matched\n  ip        the chain of include patterns\n  ep        the chain of exclude patterns\n\nReturns:    TRUE if the path is not excluded\n*/\n\nstatic BOOL\ntest_incexc(char *path, patstr *ip, patstr *ep)\n{\nint plen = strlen((const char *)path);\n\nfor (; ep != NULL; ep = ep->next)\n  {\n  if (pcre2_match(ep->compiled, (PCRE2_SPTR)path, plen, 0, 0, match_data, NULL) >= 0)\n    return FALSE;\n  }\n\nif (ip == NULL) return TRUE;\n\nfor (; ip != NULL; ip = ip->next)\n  {\n  if (pcre2_match(ip->compiled, (PCRE2_SPTR)path, plen, 0, 0, match_data, NULL) >= 0)\n    return TRUE;\n  }\n\nreturn FALSE;\n}\n\n\n\n/*************************************************\n*         Decode integer argument value          *\n*************************************************/\n\n/* Integer arguments can be followed by K or M. Avoid the use of strtoul()\nbecause SunOS4 doesn't have it. This is used only for unpicking arguments, so\njust keep it simple.\n\nArguments:\n  option_data   the option data string\n  op            the option item (for error messages)\n  longop        TRUE if option given in long form\n\nReturns:        a long integer\n*/\n\nstatic long int\ndecode_number(char *option_data, option_item *op, BOOL longop)\n{\nunsigned long int n = 0;\nchar *endptr = option_data;\nwhile (*endptr != 0 && isspace((unsigned char)(*endptr))) endptr++;\nwhile (isdigit((unsigned char)(*endptr)))\n  n = n * 10 + (int)(*endptr++ - '0');\nif (toupper(*endptr) == 'K')\n  {\n  n *= 1024;\n  endptr++;\n  }\nelse if (toupper(*endptr) == 'M')\n  {\n  n *= 1024*1024;\n  endptr++;\n  }\n\nif (*endptr != 0)   /* Error */\n  {\n  if (longop)\n    {\n    char *equals = strchr(op->long_name, '=');\n    int nlen = (equals == NULL)? (int)strlen(op->long_name) :\n      (int)(equals - op->long_name);\n    fprintf(stderr, \"pcre2grep: Malformed number \\\"%s\\\" after --%.*s\\n\",\n      option_data, nlen, op->long_name);\n    }\n  else\n    fprintf(stderr, \"pcre2grep: Malformed number \\\"%s\\\" after -%c\\n\",\n      option_data, op->one_char);\n  pcre2grep_exit(usage(2));\n  }\n\nreturn n;\n}\n\n\n\n/*************************************************\n*       Add item to a chain of numbers           *\n*************************************************/\n\n/* Used to add an item onto a chain, or just return an unconnected item if the\n\"after\" argument is NULL.\n\nArguments:\n  n          the number to add\n  after      if not NULL points to item to insert after\n\nReturns:     new number block\n*/\n\nstatic omstr *\nadd_number(int n, omstr *after)\n{\nomstr *om = (omstr *)malloc(sizeof(omstr));\n\nif (om == NULL)\n  {\n  fprintf(stderr, \"pcre2grep: malloc failed\\n\");\n  pcre2grep_exit(2);\n  }\nom->next = NULL;\nom->groupnum = n;\n\nif (after != NULL)\n  {\n  om->next = after->next;\n  after->next = om;\n  }\nreturn om;\n}\n\n\n\n/*************************************************\n*            Read one line of input              *\n*************************************************/\n\n/* Normally, input that is to be scanned is read using fread() (or gzread, or\nBZ2_read) into a large buffer, so many lines may be read at once. However,\ndoing this for tty input means that no output appears until a lot of input has\nbeen typed. Instead, tty input is handled line by line. We cannot use fgets()\nfor this, because it does not stop at a binary zero, and therefore there is no\nway of telling how many characters it has read, because there may be binary\nzeros embedded in the data. This function is also used for reading patterns\nfrom files (the -f option).\n\nArguments:\n  buffer     the buffer to read into\n  length     the maximum number of characters to read\n  f          the file\n\nReturns:     the number of characters read, zero at end of file\n*/\n\nstatic PCRE2_SIZE\nread_one_line(char *buffer, int length, FILE *f)\n{\nint c;\nint yield = 0;\nwhile ((c = fgetc(f)) != EOF)\n  {\n  buffer\u00ddyield++\u00a8 = c;\n  if (c == '\\n' || yield >= length) break;\n  }\nreturn yield;\n}\n\n\n\n/*************************************************\n*             Find end of line                   *\n*************************************************/\n\n/* The length of the endline sequence that is found is set via lenptr. This may\nbe zero at the very end of the file if there is no line-ending sequence there.\n\nArguments:\n  p         current position in line\n  endptr    end of available data\n  lenptr    where to put the length of the eol sequence\n\nReturns:    pointer after the last byte of the line,\n            including the newline byte(s)\n*/\n\nstatic char *\nend_of_line(char *p, char *endptr, int *lenptr)\n{\nswitch(endlinetype)\n  {\n  default:      /* Just in case */\n  case PCRE2_NEWLINE_LF:\n  while (p < endptr && *p != '\\n') p++;\n  if (p < endptr)\n    {\n    *lenptr = 1;\n    return p + 1;\n    }\n  *lenptr = 0;\n  return endptr;\n\n  case PCRE2_NEWLINE_CR:\n  while (p < endptr && *p != '\\r') p++;\n  if (p < endptr)\n    {\n    *lenptr = 1;\n    return p + 1;\n    }\n  *lenptr = 0;\n  return endptr;\n\n  case PCRE2_NEWLINE_NUL:\n  while (p < endptr && *p != '\\0') p++;\n  if (p < endptr)\n    {\n    *lenptr = 1;\n    return p + 1;\n    }\n  *lenptr = 0;\n  return endptr;\n\n  case PCRE2_NEWLINE_CRLF:\n  for (;;)\n    {\n    while (p < endptr && *p != '\\r') p++;\n    if (++p >= endptr)\n      {\n      *lenptr = 0;\n      return endptr;\n      }\n    if (*p == '\\n')\n      {\n      *lenptr = 2;\n      return p + 1;\n      }\n    }\n  break;\n\n  case PCRE2_NEWLINE_ANYCRLF:\n  while (p < endptr)\n    {\n    int extra = 0;\n    int c = *((unsigned char *)p);\n\n    if (utf && c >= 0xc0)\n      {\n      int gcii, gcss;\n      extra = utf8_table4\u00ddc & 0x3f\u00a8;  /* Number of additional bytes */\n      gcss = 6*extra;\n      c = (c & utf8_table3\u00ddextra\u00a8) << gcss;\n      for (gcii = 1; gcii <= extra; gcii++)\n        {\n        gcss -= 6;\n        c |= (p\u00ddgcii\u00a8 & 0x3f) << gcss;\n        }\n      }\n\n    p += 1 + extra;\n\n    switch (c)\n      {\n      case '\\n':\n      *lenptr = 1;\n      return p;\n\n      case '\\r':\n      if (p < endptr && *p == '\\n')\n        {\n        *lenptr = 2;\n        p++;\n        }\n      else *lenptr = 1;\n      return p;\n\n      default:\n      break;\n      }\n    }   /* End of loop for ANYCRLF case */\n\n  *lenptr = 0;  /* Must have hit the end */\n  return endptr;\n\n  case PCRE2_NEWLINE_ANY:\n  while (p < endptr)\n    {\n    int extra = 0;\n    int c = *((unsigned char *)p);\n\n    if (utf && c >= 0xc0)\n      {\n      int gcii, gcss;\n      extra = utf8_table4\u00ddc & 0x3f\u00a8;  /* Number of additional bytes */\n      gcss = 6*extra;\n      c = (c & utf8_table3\u00ddextra\u00a8) << gcss;\n      for (gcii = 1; gcii <= extra; gcii++)\n        {\n        gcss -= 6;\n        c |= (p\u00ddgcii\u00a8 & 0x3f) << gcss;\n        }\n      }\n\n    p += 1 + extra;\n\n    switch (c)\n      {\n      case '\\n':    /* LF */\n      case '\\v':    /* VT */\n      case '\\f':    /* FF */\n      *lenptr = 1;\n      return p;\n\n      case '\\r':    /* CR */\n      if (p < endptr && *p == '\\n')\n        {\n        *lenptr = 2;\n        p++;\n        }\n      else *lenptr = 1;\n      return p;\n\n#ifndef EBCDIC\n      case 0x85:    /* Unicode NEL */\n      *lenptr = utf? 2 : 1;\n      return p;\n\n      case 0x2028:  /* Unicode LS */\n      case 0x2029:  /* Unicode PS */\n      *lenptr = 3;\n      return p;\n#endif  /* Not EBCDIC */\n\n      default:\n      break;\n      }\n    }   /* End of loop for ANY case */\n\n  *lenptr = 0;  /* Must have hit the end */\n  return endptr;\n  }     /* End of overall switch */\n}\n\n\n\n/*************************************************\n*         Find start of previous line            *\n*************************************************/\n\n/* This is called when looking back for before lines to print.\n\nArguments:\n  p         start of the subsequent line\n  startptr  start of available data\n\nReturns:    pointer to the start of the previous line\n*/\n\nstatic char *\nprevious_line(char *p, char *startptr)\n{\nswitch(endlinetype)\n  {\n  default:      /* Just in case */\n  case PCRE2_NEWLINE_LF:\n  p--;\n  while (p > startptr && p\u00dd-1\u00a8 != '\\n') p--;\n  return p;\n\n  case PCRE2_NEWLINE_CR:\n  p--;\n  while (p > startptr && p\u00dd-1\u00a8 != '\\n') p--;\n  return p;\n\n  case PCRE2_NEWLINE_NUL:\n  p--;\n  while (p > startptr && p\u00dd-1\u00a8 != '\\0') p--;\n  return p;\n\n  case PCRE2_NEWLINE_CRLF:\n  for (;;)\n    {\n    p -= 2;\n    while (p > startptr && p\u00dd-1\u00a8 != '\\n') p--;\n    if (p <= startptr + 1 || p\u00dd-2\u00a8 == '\\r') return p;\n    }\n  /* Control can never get here */\n\n  case PCRE2_NEWLINE_ANY:\n  case PCRE2_NEWLINE_ANYCRLF:\n  if (*(--p) == '\\n' && p > startptr && p\u00dd-1\u00a8 == '\\r') p--;\n  if (utf) while ((*p & 0xc0) == 0x80) p--;\n\n  while (p > startptr)\n    {\n    unsigned int c;\n    char *pp = p - 1;\n\n    if (utf)\n      {\n      int extra = 0;\n      while ((*pp & 0xc0) == 0x80) pp--;\n      c = *((unsigned char *)pp);\n      if (c >= 0xc0)\n        {\n        int gcii, gcss;\n        extra = utf8_table4\u00ddc & 0x3f\u00a8;  /* Number of additional bytes */\n        gcss = 6*extra;\n        c = (c & utf8_table3\u00ddextra\u00a8) << gcss;\n        for (gcii = 1; gcii <= extra; gcii++)\n          {\n          gcss -= 6;\n          c |= (pp\u00ddgcii\u00a8 & 0x3f) << gcss;\n          }\n        }\n      }\n    else c = *((unsigned char *)pp);\n\n    if (endlinetype == PCRE2_NEWLINE_ANYCRLF) switch (c)\n      {\n      case '\\n':    /* LF */\n      case '\\r':    /* CR */\n      return p;\n\n      default:\n      break;\n      }\n\n    else switch (c)\n      {\n      case '\\n':    /* LF */\n      case '\\v':    /* VT */\n      case '\\f':    /* FF */\n      case '\\r':    /* CR */\n#ifndef EBCDIC\n      case 0x85:    /* Unicode NEL */\n      case 0x2028:  /* Unicode LS */\n      case 0x2029:  /* Unicode PS */\n#endif  /* Not EBCDIC */\n      return p;\n\n      default:\n      break;\n      }\n\n    p = pp;  /* Back one character */\n    }        /* End of loop for ANY case */\n\n  return startptr;  /* Hit start of data */\n  }     /* End of overall switch */\n}\n\n\n\n/*************************************************\n*              Output newline at end             *\n*************************************************/\n\n/* This function is called if the final line of a file has been written to\nstdout, but it does not have a terminating newline.\n\nArguments:  none\nReturns:    nothing\n*/\n\nstatic void\nwrite_final_newline(void)\n{\nswitch(endlinetype)\n  {\n  default:      /* Just in case */\n  case PCRE2_NEWLINE_LF:\n  case PCRE2_NEWLINE_ANY:\n  case PCRE2_NEWLINE_ANYCRLF:\n  fprintf(stdout, \"\\n\");\n  break;\n\n  case PCRE2_NEWLINE_CR:\n  fprintf(stdout, \"\\r\");\n  break;\n\n  case PCRE2_NEWLINE_CRLF:\n  fprintf(stdout, \"\\r\\n\");\n  break;\n\n  case PCRE2_NEWLINE_NUL:\n  fprintf(stdout, \"%c\", 0);\n  break;\n  }\n}\n\n\n/*************************************************\n*       Print the previous \"after\" lines         *\n*************************************************/\n\n/* This is called if we are about to lose said lines because of buffer filling,\nand at the end of the file. The data in the line is written using fwrite() so\nthat a binary zero does not terminate it.\n\nArguments:\n  lastmatchnumber   the number of the last matching line, plus one\n  lastmatchrestart  where we restarted after the last match\n  endptr            end of available data\n  printname         filename for printing\n\nReturns:            nothing\n*/\n\nstatic void\ndo_after_lines(unsigned long int lastmatchnumber, char *lastmatchrestart,\n  char *endptr, const char *printname)\n{\nif (after_context > 0 && lastmatchnumber > 0)\n  {\n  int count = 0;\n  int ellength = 0;\n  while (lastmatchrestart < endptr && count < after_context)\n    {\n    char *pp = end_of_line(lastmatchrestart, endptr, &ellength);\n    if (ellength == 0 && pp == main_buffer + bufsize) break;\n    if (printname != NULL) fprintf(stdout, \"%s-\", printname);\n    if (number) fprintf(stdout, \"%lu-\", lastmatchnumber++);\n    FWRITE_IGNORE(lastmatchrestart, 1, pp - lastmatchrestart, stdout);\n    lastmatchrestart = pp;\n    count++;\n    }\n\n  /* If we have printed any lines, arrange for a hyphen separator if anything\n  else follows. Also, if the last line is the final line in the file and it had\n  no newline, add one. */\n\n  if (count > 0)\n    {\n    hyphenpending = TRUE;\n    if (ellength == 0 && lastmatchrestart >= endptr)\n      write_final_newline();\n    }\n  }\n}\n\n\n\n/*************************************************\n*   Apply patterns to subject till one matches   *\n*************************************************/\n\n/* This function is called to run through all patterns, looking for a match. It\nis used multiple times for the same subject when colouring is enabled, in order\nto find all possible matches.\n\nArguments:\n  matchptr     the start of the subject\n  length       the length of the subject to match\n  options      options for pcre_exec\n  startoffset  where to start matching\n  mrc          address of where to put the result of pcre2_match()\n\nReturns:      TRUE if there was a match\n              FALSE if there was no match\n              invert if there was a non-fatal error\n*/\n\nstatic BOOL\nmatch_patterns(char *matchptr, PCRE2_SIZE length, unsigned int options,\n  PCRE2_SIZE startoffset, int *mrc)\n{\nint i;\nPCRE2_SIZE slen = length;\npatstr *p = patterns;\nconst char *msg = \"this text:\\n\\n\";\n\nif (slen > 200)\n  {\n  slen = 200;\n  msg = \"text that starts:\\n\\n\";\n  }\nfor (i = 1; p != NULL; p = p->next, i++)\n  {\n  *mrc = pcre2_match(p->compiled, (PCRE2_SPTR)matchptr, (int)length,\n    startoffset, options, match_data, match_context);\n  if (*mrc >= 0) return TRUE;\n  if (*mrc == PCRE2_ERROR_NOMATCH) continue;\n  fprintf(stderr, \"pcre2grep: pcre2_match() gave error %d while matching \", *mrc);\n  if (patterns->next != NULL) fprintf(stderr, \"pattern number %d to \", i);\n  fprintf(stderr, \"%s\", msg);\n  FWRITE_IGNORE(matchptr, 1, slen, stderr);   /* In case binary zero included */\n  fprintf(stderr, \"\\n\\n\");\n  if (*mrc <= PCRE2_ERROR_UTF8_ERR1 &&\n      *mrc >= PCRE2_ERROR_UTF8_ERR21)\n    {\n    unsigned char mbuffer\u00dd256\u00a8;\n    PCRE2_SIZE startchar = pcre2_get_startchar(match_data);\n    (void)pcre2_get_error_message(*mrc, mbuffer, sizeof(mbuffer));\n    fprintf(stderr, \"%s at offset %\" SIZ_FORM \"\\n\\n\", mbuffer,\n      SIZ_CAST startchar);\n    }\n  if (*mrc == PCRE2_ERROR_MATCHLIMIT || *mrc == PCRE2_ERROR_DEPTHLIMIT ||\n      *mrc == PCRE2_ERROR_HEAPLIMIT || *mrc == PCRE2_ERROR_JIT_STACKLIMIT)\n    resource_error = TRUE;\n  if (error_count++ > 20)\n    {\n    fprintf(stderr, \"pcre2grep: Too many errors - abandoned.\\n\");\n    pcre2grep_exit(2);\n    }\n  return invert;    /* No more matching; don't show the line again */\n  }\n\nreturn FALSE;  /* No match, no errors */\n}\n\n\n/*************************************************\n*          Check output text for errors          *\n*************************************************/\n\nstatic BOOL\nsyntax_check_output_text(PCRE2_SPTR string, BOOL callout)\n{\nPCRE2_SPTR begin = string;\nfor (; *string != 0; string++)\n  {\n  if (*string == '$')\n    {\n    PCRE2_SIZE capture_id = 0;\n    BOOL brace = FALSE;\n\n    string++;\n\n    /* Syntax error: a character must be present after $. */\n    if (*string == 0)\n      {\n      if (!callout)\n        fprintf(stderr, \"pcre2grep: Error in output text at offset %d: %s\\n\",\n          (int)(string - begin), \"no character after $\");\n      return FALSE;\n      }\n\n    if (*string == '{')\n      {\n      /* Must be a decimal number in braces, e.g: {5} or {38} */\n      string++;\n\n      brace = TRUE;\n      }\n\n    if ((*string >= '1' && *string <= '9') || (!callout && *string == '0'))\n      {\n      do\n        {\n        /* Maximum capture id is 65535. */\n        if (capture_id <= 65535)\n          capture_id = capture_id * 10 + (*string - '0');\n\n        string++;\n        }\n      while (*string >= '0' && *string <= '9');\n\n      if (brace)\n        {\n        /* Syntax error: closing brace is missing. */\n        if (*string != '}')\n          {\n          if (!callout)\n            fprintf(stderr, \"pcre2grep: Error in output text at offset %d: %s\\n\",\n              (int)(string - begin), \"missing closing brace\");\n          return FALSE;\n          }\n        }\n      else\n        {\n        /* To negate the effect of the for. */\n        string--;\n        }\n      }\n    else if (brace)\n      {\n      /* Syntax error: a decimal number required. */\n      if (!callout)\n        fprintf(stderr, \"pcre2grep: Error in output text at offset %d: %s\\n\",\n          (int)(string - begin), \"decimal number expected\");\n      return FALSE;\n      }\n    else if (*string == 'o')\n      {\n      string++;\n\n      if (*string < '0' || *string > '7')\n        {\n        /* Syntax error: an octal number required. */\n        if (!callout)\n          fprintf(stderr, \"pcre2grep: Error in output text at offset %d: %s\\n\",\n            (int)(string - begin), \"octal number expected\");\n        return FALSE;\n        }\n      }\n    else if (*string == 'x')\n      {\n      string++;\n\n      if (!isxdigit((unsigned char)*string))\n        {\n        /* Syntax error: a hexdecimal number required. */\n        if (!callout)\n          fprintf(stderr, \"pcre2grep: Error in output text at offset %d: %s\\n\",\n            (int)(string - begin), \"hexadecimal number expected\");\n        return FALSE;\n        }\n      }\n    }\n  }\n\n  return TRUE;\n}\n\n\n/*************************************************\n*              Display output text               *\n*************************************************/\n\n/* Display the output text, which is assumed to have already been syntax\nchecked. Output may contain escape sequences started by the dollar sign. The\nescape sequences are substituted as follows:\n\n  $<digits> or ${<digits>} is replaced by the captured substring of the given\n  decimal number; zero will substitute the whole match. If the number is\n  greater than the number of capturing substrings, or if the capture is unset,\n  the replacement is empty.\n\n  $a is replaced by bell.\n  $b is replaced by backspace.\n  $e is replaced by escape.\n  $f is replaced by form feed.\n  $n is replaced by newline.\n  $r is replaced by carriage return.\n  $t is replaced by tab.\n  $v is replaced by vertical tab.\n\n  $o<digits> is replaced by the character represented by the given octal\n  number; up to three digits are processed.\n\n  $x<digits> is replaced by the character represented by the given hexadecimal\n  number; up to two digits are processed.\n\n  Any other character is substituted by itself. E.g: $$ is replaced by a single\n  dollar.\n\nArguments:\n  string:       the output text\n  callout:      TRUE for the builtin callout, FALSE for --output\n  subject       the start of the subject\n  ovector:      capture offsets\n  capture_top:  number of captures\n\nReturns:        TRUE if something was output, other than newline\n                FALSE if nothing was output, or newline was last output\n*/\n\nstatic BOOL\ndisplay_output_text(PCRE2_SPTR string, BOOL callout, PCRE2_SPTR subject,\n  PCRE2_SIZE *ovector, PCRE2_SIZE capture_top)\n{\nBOOL printed = FALSE;\n\nfor (; *string != 0; string++)\n  {\n  int ch = EOF;\n  if (*string == '$')\n    {\n    PCRE2_SIZE capture_id = 0;\n    BOOL brace = FALSE;\n\n    string++;\n\n    if (*string == '{')\n      {\n      /* Must be a decimal number in braces, e.g: {5} or {38} */\n      string++;\n\n      brace = TRUE;\n      }\n\n    if ((*string >= '1' && *string <= '9') || (!callout && *string == '0'))\n      {\n      do\n        {\n        /* Maximum capture id is 65535. */\n        if (capture_id <= 65535)\n          capture_id = capture_id * 10 + (*string - '0');\n\n        string++;\n        }\n      while (*string >= '0' && *string <= '9');\n\n      if (!brace)\n        {\n        /* To negate the effect of the for. */\n        string--;\n        }\n\n      if (capture_id < capture_top)\n        {\n        PCRE2_SIZE capturesize;\n        capture_id *= 2;\n\n        capturesize = ovector\u00ddcapture_id + 1\u00a8 - ovector\u00ddcapture_id\u00a8;\n        if (capturesize > 0)\n          {\n          print_match(subject + ovector\u00ddcapture_id\u00a8, capturesize);\n          printed = TRUE;\n          }\n        }\n      }\n    else if (*string == 'a') ch = '\\a';\n    else if (*string == 'b') ch = '\\b';\n#ifndef EBCDIC\n    else if (*string == 'e') ch = '\\033';\n#else\n    else if (*string == 'e') ch = '\\047';\n#endif\n    else if (*string == 'f') ch = '\\f';\n    else if (*string == 'r') ch = '\\r';\n    else if (*string == 't') ch = '\\t';\n    else if (*string == 'v') ch = '\\v';\n    else if (*string == 'n')\n      {\n      fprintf(stdout, STDOUT_NL);\n      printed = FALSE;\n      }\n    else if (*string == 'o')\n      {\n      string++;\n\n      ch = *string - '0';\n      if (string\u00dd1\u00a8 >= '0' && string\u00dd1\u00a8 <= '7')\n        {\n        string++;\n        ch = ch * 8 + (*string - '0');\n        }\n      if (string\u00dd1\u00a8 >= '0' && string\u00dd1\u00a8 <= '7')\n        {\n        string++;\n        ch = ch * 8 + (*string - '0');\n        }\n      }\n    else if (*string == 'x')\n      {\n      string++;\n\n      if (*string >= '0' && *string <= '9')\n        ch = *string - '0';\n      else\n        ch = (*string | 0x20) - 'a' + 10;\n      if (isxdigit((unsigned char)string\u00dd1\u00a8))\n        {\n        string++;\n        ch *= 16;\n        if (*string >= '0' && *string <= '9')\n          ch += *string - '0';\n        else\n          ch += (*string | 0x20) - 'a' + 10;\n        }\n      }\n    else\n      {\n      ch = *string;\n      }\n    }\n  else\n    {\n    ch = *string;\n    }\n  if (ch != EOF)\n    {\n    fprintf(stdout, \"%c\", ch);\n    printed = TRUE;\n    }\n  }\n\nreturn printed;\n}\n\n\n#ifdef SUPPORT_PCRE2GREP_CALLOUT\n\n/*************************************************\n*        Parse and execute callout scripts       *\n*************************************************/\n\n/* If SUPPORT_PCRE2GREP_CALLOUT_FORK is defined, this function parses a callout\nstring block and executes the program specified by the string. The string is a\nlist of substrings separated by pipe characters. The first substring represents\nthe executable name, and the following substrings specify the arguments:\n\n  program_name|param1|param2|...\n\nAny substring (including the program name) can contain escape sequences\nstarted by the dollar character. The escape sequences are substituted as\nfollows:\n\n  $<digits> or ${<digits>} is replaced by the captured substring of the given\n  decimal number, which must be greater than zero. If the number is greater\n  than the number of capturing substrings, or if the capture is unset, the\n  replacement is empty.\n\n  Any other character is substituted by itself. E.g: $$ is replaced by a single\n  dollar or $| replaced by a pipe character.\n\nAlternatively, if string starts with pipe, the remainder is taken as an output\nstring, same as --output. This is the only form that is supported if\nSUPPORT_PCRE2GREP_FORK is not defined. In this case, --om-separator is used to\nseparate each callout, defaulting to newline.\n\nExample:\n\n  echo -e \"abcde\\n12345\" | pcre2grep \\\n    '(.)(..(.))(?C\"/bin/echo|Arg1: \u00dd$1\u00a8 \u00dd$2\u00a8 \u00dd$3\u00a8|Arg2: $|${1}$| ($4)\")()' -\n\n  Output:\n\n    Arg1: \u00dda\u00a8 \u00ddbcd\u00a8 \u00ddd\u00a8 Arg2: |a| ()\n    abcde\n    Arg1: \u00dd1\u00a8 \u00dd234\u00a8 \u00dd4\u00a8 Arg2: |1| ()\n    12345\n\nArguments:\n  blockptr     the callout block\n\nReturns:       currently it always returns with 0\n*/\n\nstatic int\npcre2grep_callout(pcre2_callout_block *calloutptr, void *unused)\n{\nPCRE2_SIZE length = calloutptr->callout_string_length;\nPCRE2_SPTR string = calloutptr->callout_string;\nPCRE2_SPTR subject = calloutptr->subject;\nPCRE2_SIZE *ovector = calloutptr->offset_vector;\nPCRE2_SIZE capture_top = calloutptr->capture_top;\n\n#ifdef SUPPORT_PCRE2GREP_CALLOUT_FORK\nPCRE2_SIZE argsvectorlen = 2;\nPCRE2_SIZE argslen = 1;\nchar *args;\nchar *argsptr;\nchar **argsvector;\nchar **argsvectorptr;\n#ifndef WIN32\npid_t pid;\n#endif\nint result = 0;\n#endif  /* SUPPORT_PCRE2GREP_CALLOUT_FORK */\n\n(void)unused;   /* Avoid compiler warning */\n\n/* Only callout with strings are supported. */\n\nif (string == NULL || length == 0) return 0;\n\n/* If there's no command, output the remainder directly. */\n\nif (*string == '|')\n  {\n  string++;\n  if (!syntax_check_output_text(string, TRUE)) return 0;\n  (void)display_output_text(string, TRUE, subject, ovector, capture_top);\n  return 0;\n  }\n\n#ifndef SUPPORT_PCRE2GREP_CALLOUT_FORK\nreturn 0;\n#else\n\n/* Checking syntax and compute the number of string fragments. Callout strings\nare ignored in case of a syntax error. */\n\nwhile (length > 0)\n  {\n  if (*string == '|')\n    {\n    argsvectorlen++;\n\n    /* Maximum 10000 arguments allowed. */\n    if (argsvectorlen > 10000) return 0;\n    }\n  else if (*string == '$')\n    {\n    PCRE2_SIZE capture_id = 0;\n\n    string++;\n    length--;\n\n    /* Syntax error: a character must be present after $. */\n    if (length == 0) return 0;\n\n    if (*string >= '1' && *string <= '9')\n      {\n      do\n        {\n        /* Maximum capture id is 65535. */\n        if (capture_id <= 65535)\n          capture_id = capture_id * 10 + (*string - '0');\n\n        string++;\n        length--;\n        }\n      while (length > 0 && *string >= '0' && *string <= '9');\n\n      /* To negate the effect of string++ below. */\n      string--;\n      length++;\n      }\n    else if (*string == '{')\n      {\n      /* Must be a decimal number in braces, e.g: {5} or {38} */\n      string++;\n      length--;\n\n      /* Syntax error: a decimal number required. */\n      if (length == 0) return 0;\n      if (*string < '1' || *string > '9') return 0;\n\n      do\n        {\n        /* Maximum capture id is 65535. */\n        if (capture_id <= 65535)\n          capture_id = capture_id * 10 + (*string - '0');\n\n        string++;\n        length--;\n\n        /* Syntax error: no more characters */\n        if (length == 0) return 0;\n        }\n      while (*string >= '0' && *string <= '9');\n\n      /* Syntax error: closing brace is missing. */\n      if (*string != '}') return 0;\n      }\n\n    if (capture_id > 0)\n      {\n      if (capture_id < capture_top)\n        {\n        capture_id *= 2;\n        argslen += ovector\u00ddcapture_id + 1\u00a8 - ovector\u00ddcapture_id\u00a8;\n        }\n\n      /* To negate the effect of argslen++ below. */\n      argslen--;\n      }\n    }\n\n  string++;\n  length--;\n  argslen++;\n  }\n\nargs = (char*)malloc(argslen);\nif (args == NULL) return 0;\n\nargsvector = (char**)malloc(argsvectorlen * sizeof(char*));\nif (argsvector == NULL)\n  {\n  free(args);\n  return 0;\n  }\n\nargsptr = args;\nargsvectorptr = argsvector;\n\n*argsvectorptr++ = argsptr;\n\nlength = calloutptr->callout_string_length;\nstring = calloutptr->callout_string;\n\nwhile (length > 0)\n  {\n  if (*string == '|')\n    {\n    *argsptr++ = '\\0';\n    *argsvectorptr++ = argsptr;\n    }\n  else if (*string == '$')\n    {\n    string++;\n    length--;\n\n    if ((*string >= '1' && *string <= '9') || *string == '{')\n      {\n      PCRE2_SIZE capture_id = 0;\n\n      if (*string != '{')\n        {\n        do\n          {\n          /* Maximum capture id is 65535. */\n          if (capture_id <= 65535)\n            capture_id = capture_id * 10 + (*string - '0');\n\n          string++;\n          length--;\n          }\n        while (length > 0 && *string >= '0' && *string <= '9');\n\n        /* To negate the effect of string++ below. */\n        string--;\n        length++;\n        }\n      else\n        {\n        string++;\n        length--;\n\n        do\n          {\n          /* Maximum capture id is 65535. */\n          if (capture_id <= 65535)\n            capture_id = capture_id * 10 + (*string - '0');\n\n          string++;\n          length--;\n          }\n        while (*string != '}');\n        }\n\n        if (capture_id < capture_top)\n          {\n          PCRE2_SIZE capturesize;\n          capture_id *= 2;\n\n          capturesize = ovector\u00ddcapture_id + 1\u00a8 - ovector\u00ddcapture_id\u00a8;\n          memcpy(argsptr, subject + ovector\u00ddcapture_id\u00a8, capturesize);\n          argsptr += capturesize;\n          }\n      }\n    else\n      {\n      *argsptr++ = *string;\n      }\n    }\n  else\n    {\n    *argsptr++ = *string;\n    }\n\n  string++;\n  length--;\n  }\n\n*argsptr++ = '\\0';\n*argsvectorptr = NULL;\n\n/* Running an external command is system-dependent. Handle Windows and VMS as\nnecessary, otherwise assume fork(). */\n\n#ifdef WIN32\nresult = _spawnvp(_P_WAIT, argsvector\u00dd0\u00a8, (const char * const *)argsvector);\n\n#elif defined __VMS\n  {\n  char cmdbuf\u00dd500\u00a8;\n  short i = 0;\n  int flags = CLI$M_NOCLISYM|CLI$M_NOLOGNAM|CLI$M_NOKEYPAD, status, retstat;\n  $DESCRIPTOR(cmd, cmdbuf);\n\n  cmdbuf\u00dd0\u00a8 = 0;\n  while (argsvector\u00ddi\u00a8)\n  {\n    strcat(cmdbuf, argsvector\u00ddi\u00a8);\n    strcat(cmdbuf, \" \");\n    i++;\n  }\n  cmd.dsc$w_length = strlen(cmdbuf) - 1;\n  status = lib$spawn(&cmd, 0,0, &flags, 0,0, &retstat);\n  if (!(status & 1)) result = 0;\n  else result = retstat & 1 ? 0 : 1;\n  }\n\n#else  /* Neither Windows nor VMS */\npid = fork();\nif (pid == 0)\n  {\n  (void)execv(argsvector\u00dd0\u00a8, argsvector);\n  /* Control gets here if there is an error, e.g. a non-existent program */\n  exit(1);\n  }\nelse if (pid > 0)\n  (void)waitpid(pid, &result, 0);\n#endif  /* End Windows/VMS/other handling */\n\nfree(args);\nfree(argsvector);\n\n/* Currently negative return values are not supported, only zero (match\ncontinues) or non-zero (match fails). */\n\nreturn result != 0;\n#endif  /* SUPPORT_PCRE2GREP_CALLOUT_FORK */\n}\n#endif  /* SUPPORT_PCRE2GREP_CALLOUT */\n\n\n\n/*************************************************\n*     Read a portion of the file into buffer     *\n*************************************************/\n\nstatic int\nfill_buffer(void *handle, int frtype, char *buffer, int length,\n  BOOL input_line_buffered)\n{\n(void)frtype;  /* Avoid warning when not used */\n\n#ifdef SUPPORT_LIBZ\nif (frtype == FR_LIBZ)\n  return gzread((gzFile)handle, buffer, length);\nelse\n#endif\n\n#ifdef SUPPORT_LIBBZ2\nif (frtype == FR_LIBBZ2)\n  return BZ2_bzread((BZFILE *)handle, buffer, length);\nelse\n#endif\n\nreturn (input_line_buffered ?\n  read_one_line(buffer, length, (FILE *)handle) :\n  fread(buffer, 1, length, (FILE *)handle));\n}\n\n\n\n/*************************************************\n*            Grep an individual file             *\n*************************************************/\n\n/* This is called from grep_or_recurse() below. It uses a buffer that is three\ntimes the value of bufthird. The matching point is never allowed to stray into\nthe top third of the buffer, thus keeping more of the file available for\ncontext printing or for multiline scanning. For large files, the pointer will\nbe in the middle third most of the time, so the bottom third is available for\n\"before\" context printing.\n\nArguments:\n  handle       the fopened FILE stream for a normal file\n               the gzFile pointer when reading is via libz\n               the BZFILE pointer when reading is via libbz2\n  frtype       FR_PLAIN, FR_LIBZ, or FR_LIBBZ2\n  filename     the file name or NULL (for errors)\n  printname    the file name if it is to be printed for each match\n               or NULL if the file name is not to be printed\n               it cannot be NULL if filenames\u00dd_nomatch\u00a8_only is set\n\nReturns:       0 if there was at least one match\n               1 otherwise (no matches)\n               2 if an overlong line is encountered\n               3 if there is a read error on a .bz2 file\n*/\n\nstatic int\npcre2grep(void *handle, int frtype, const char *filename, const char *printname)\n{\nint rc = 1;\nint filepos = 0;\nunsigned long int linenumber = 1;\nunsigned long int lastmatchnumber = 0;\nunsigned long int count = 0;\nchar *lastmatchrestart = main_buffer;\nchar *ptr = main_buffer;\nchar *endptr;\nPCRE2_SIZE bufflength;\nBOOL binary = FALSE;\nBOOL endhyphenpending = FALSE;\nBOOL lines_printed = FALSE;\nBOOL input_line_buffered = line_buffered;\nFILE *in = NULL;                    /* Ensure initialized */\n\n/* Do the first read into the start of the buffer and set up the pointer to end\nof what we have. In the case of libz, a non-zipped .gz file will be read as a\nplain file. However, if a .bz2 file isn't actually bzipped, the first read will\nfail. */\n\nif (frtype != FR_LIBZ && frtype != FR_LIBBZ2)\n  {\n  in = (FILE *)handle;\n  if (is_file_tty(in)) input_line_buffered = TRUE;\n  }\nelse input_line_buffered = FALSE;\n\nbufflength = fill_buffer(handle, frtype, main_buffer, bufsize,\n  input_line_buffered);\n\n#ifdef SUPPORT_LIBBZ2\nif (frtype == FR_LIBBZ2 && (int)bufflength < 0) return 2;   /* Gotcha: bufflength is PCRE2_SIZE; */\n#endif\n\nendptr = main_buffer + bufflength;\n\n/* Unless binary-files=text, see if we have a binary file. This uses the same\nrule as GNU grep, namely, a search for a binary zero byte near the start of the\nfile. However, when the newline convention is binary zero, we can't do this. */\n\nif (binary_files != BIN_TEXT)\n  {\n  if (endlinetype != PCRE2_NEWLINE_NUL)\n    binary = memchr(main_buffer, 0, (bufflength > 1024)? 1024 : bufflength)\n      != NULL;\n  if (binary && binary_files == BIN_NOMATCH) return 1;\n  }\n\n/* Loop while the current pointer is not at the end of the file. For large\nfiles, endptr will be at the end of the buffer when we are in the middle of the\nfile, but ptr will never get there, because as soon as it gets over 2/3 of the\nway, the buffer is shifted left and re-filled. */\n\nwhile (ptr < endptr)\n  {\n  int endlinelength;\n  int mrc = 0;\n  unsigned int options = 0;\n  BOOL match;\n  char *t = ptr;\n  PCRE2_SIZE length, linelength;\n  PCRE2_SIZE startoffset = 0;\n\n  /* At this point, ptr is at the start of a line. We need to find the length\n  of the subject string to pass to pcre2_match(). In multiline mode, it is the\n  length remainder of the data in the buffer. Otherwise, it is the length of\n  the next line, excluding the terminating newline. After matching, we always\n  advance by the length of the next line. In multiline mode the PCRE2_FIRSTLINE\n  option is used for compiling, so that any match is constrained to be in the\n  first line. */\n\n  t = end_of_line(t, endptr, &endlinelength);\n  linelength = t - ptr - endlinelength;\n  length = multiline? (PCRE2_SIZE)(endptr - ptr) : linelength;\n\n  /* Check to see if the line we are looking at extends right to the very end\n  of the buffer without a line terminator. This means the line is too long to\n  handle at the current buffer size. Until the buffer reaches its maximum size,\n  try doubling it and reading more data. */\n\n  if (endlinelength == 0 && t == main_buffer + bufsize)\n    {\n    if (bufthird < max_bufthird)\n      {\n      char *new_buffer;\n      int new_bufthird = 2*bufthird;\n\n      if (new_bufthird > max_bufthird) new_bufthird = max_bufthird;\n      new_buffer = (char *)malloc(3*new_bufthird);\n\n      if (new_buffer == NULL)\n        {\n        fprintf(stderr,\n          \"pcre2grep: line %lu%s%s is too long for the internal buffer\\n\"\n          \"pcre2grep: not enough memory to increase the buffer size to %d\\n\",\n          linenumber,\n          (filename == NULL)? \"\" : \" of file \",\n          (filename == NULL)? \"\" : filename,\n          new_bufthird);\n        return 2;\n        }\n\n      /* Copy the data and adjust pointers to the new buffer location. */\n\n      memcpy(new_buffer, main_buffer, bufsize);\n      bufthird = new_bufthird;\n      bufsize = 3*bufthird;\n      ptr = new_buffer + (ptr - main_buffer);\n      lastmatchrestart = new_buffer + (lastmatchrestart - main_buffer);\n      free(main_buffer);\n      main_buffer = new_buffer;\n\n      /* Read more data into the buffer and then try to find the line ending\n      again. */\n\n      bufflength += fill_buffer(handle, frtype, main_buffer + bufflength,\n        bufsize - bufflength, input_line_buffered);\n      endptr = main_buffer + bufflength;\n      continue;\n      }\n    else\n      {\n      fprintf(stderr,\n        \"pcre2grep: line %lu%s%s is too long for the internal buffer\\n\"\n        \"pcre2grep: the maximum buffer size is %d\\n\"\n        \"pcre2grep: use the --max-buffer-size option to change it\\n\",\n        linenumber,\n        (filename == NULL)? \"\" : \" of file \",\n        (filename == NULL)? \"\" : filename,\n        bufthird);\n      return 2;\n      }\n    }\n\n  /* Extra processing for Jeffrey Friedl's debugging. */\n\n#ifdef JFRIEDL_DEBUG\n  if (jfriedl_XT || jfriedl_XR)\n  {\n#     include <sys/time.h>\n#     include <time.h>\n      struct timeval start_time, end_time;\n      struct timezone dummy;\n      int i;\n\n      if (jfriedl_XT)\n      {\n          unsigned long newlen = length * jfriedl_XT + strlen(jfriedl_prefix) + strlen(jfriedl_postfix);\n          const char *orig = ptr;\n          ptr = malloc(newlen + 1);\n          if (!ptr) {\n                  printf(\"out of memory\");\n                  pcre2grep_exit(2);\n          }\n          endptr = ptr;\n          strcpy(endptr, jfriedl_prefix); endptr += strlen(jfriedl_prefix);\n          for (i = 0; i < jfriedl_XT; i++) {\n                  strncpy(endptr, orig,  length);\n                  endptr += length;\n          }\n          strcpy(endptr, jfriedl_postfix); endptr += strlen(jfriedl_postfix);\n          length = newlen;\n      }\n\n      if (gettimeofday(&start_time, &dummy) != 0)\n              perror(\"bad gettimeofday\");\n\n\n      for (i = 0; i < jfriedl_XR; i++)\n          match = (pcre_exec(patterns->compiled, patterns->hint, ptr, length, 0,\n              PCRE2_NOTEMPTY, offsets, offset_size) >= 0);\n\n      if (gettimeofday(&end_time, &dummy) != 0)\n              perror(\"bad gettimeofday\");\n\n      double delta = ((end_time.tv_sec + (end_time.tv_usec / 1000000.0))\n                      -\n                      (start_time.tv_sec + (start_time.tv_usec / 1000000.0)));\n\n      printf(\"%s TIMER\u00dd%.4f\u00a8\\n\", match ? \"MATCH\" : \"FAIL\", delta);\n      return 0;\n  }\n#endif\n\n  /* We come back here after a match when only_matching_count is non-zero, in\n  order to find any further matches in the same line. This applies to\n  --only-matching, --file-offsets, and --line-offsets. */\n\n  ONLY_MATCHING_RESTART:\n\n  /* Run through all the patterns until one matches or there is an error other\n  than NOMATCH. This code is in a subroutine so that it can be re-used for\n  finding subsequent matches when colouring matched lines. After finding one\n  match, set PCRE2_NOTEMPTY to disable any further matches of null strings in\n  this line. */\n\n  match = match_patterns(ptr, length, options, startoffset, &mrc);\n  options = PCRE2_NOTEMPTY;\n\n  /* If it's a match or a not-match (as required), do what's wanted. NOTE: Use\n  only FWRITE_IGNORE() - which is just a packaged fwrite() that ignores its\n  return code - to output data lines, so that binary zeroes are treated as just\n  another data character. */\n\n  if (match != invert)\n    {\n    BOOL hyphenprinted = FALSE;\n\n    /* We've failed if we want a file that doesn't have any matches. */\n\n    if (filenames == FN_NOMATCH_ONLY) return 1;\n\n    /* If all we want is a yes/no answer, we can return immediately. */\n\n    if (quiet) return 0;\n\n    /* Just count if just counting is wanted. */\n\n    else if (count_only || show_total_count) count++;\n\n    /* When handling a binary file and binary-files==binary, the \"binary\"\n    variable will be set true (it's false in all other cases). In this\n    situation we just want to output the file name. No need to scan further. */\n\n    else if (binary)\n      {\n      fprintf(stdout, \"Binary file %s matches\" STDOUT_NL, filename);\n      return 0;\n      }\n\n    /* Likewise, if all we want is a file name, there is no need to scan any\n    more lines in the file. */\n\n    else if (filenames == FN_MATCH_ONLY)\n      {\n      fprintf(stdout, \"%s\" STDOUT_NL, printname);\n      return 0;\n      }\n\n    /* The --only-matching option prints just the substring that matched,\n    and/or one or more captured portions of it, as long as these strings are\n    not empty. The --file-offsets and --line-offsets options output offsets for\n    the matching substring (all three set only_matching_count non-zero). None\n    of these mutually exclusive options prints any context. Afterwards, adjust\n    the start and then jump back to look for further matches in the same line.\n    If we are in invert mode, however, nothing is printed and we do not restart\n    - this could still be useful because the return code is set. */\n\n    else if (only_matching_count != 0)\n      {\n      if (!invert)\n        {\n        PCRE2_SIZE oldstartoffset;\n\n        if (printname != NULL) fprintf(stdout, \"%s:\", printname);\n        if (number) fprintf(stdout, \"%lu:\", linenumber);\n\n        /* Handle --line-offsets */\n\n        if (line_offsets)\n          fprintf(stdout, \"%d,%d\" STDOUT_NL, (int)(ptr + offsets\u00dd0\u00a8 - ptr),\n            (int)(offsets\u00dd1\u00a8 - offsets\u00dd0\u00a8));\n\n        /* Handle --file-offsets */\n\n        else if (file_offsets)\n          fprintf(stdout, \"%d,%d\" STDOUT_NL,\n            (int)(filepos + ptr + offsets\u00dd0\u00a8 - ptr),\n            (int)(offsets\u00dd1\u00a8 - offsets\u00dd0\u00a8));\n\n        /* Handle --output (which has already been syntax checked) */\n\n        else if (output_text != NULL)\n          {\n          if (display_output_text((PCRE2_SPTR)output_text, FALSE,\n              (PCRE2_SPTR)ptr, offsets, mrc) || printname != NULL ||\n              number)\n            fprintf(stdout, STDOUT_NL);\n          }\n\n        /* Handle --only-matching, which may occur many times */\n\n        else\n          {\n          BOOL printed = FALSE;\n          omstr *om;\n\n          for (om = only_matching; om != NULL; om = om->next)\n            {\n            int n = om->groupnum;\n            if (n == 0 || n < mrc)\n              {\n              int plen = offsets\u00dd2*n + 1\u00a8 - offsets\u00dd2*n\u00a8;\n              if (plen > 0)\n                {\n                if (printed && om_separator != NULL)\n                  fprintf(stdout, \"%s\", om_separator);\n                print_match(ptr + offsets\u00ddn*2\u00a8, plen);\n                printed = TRUE;\n                }\n              }\n            }\n\n          if (printed || printname != NULL || number)\n            fprintf(stdout, STDOUT_NL);\n          }\n\n        /* Prepare to repeat to find the next match in the line. */\n\n        match = FALSE;\n        if (line_buffered) fflush(stdout);\n        rc = 0;                      /* Had some success */\n\n        /* If the pattern contained a lookbehind that included \\K, it is\n        possible that the end of the match might be at or before the actual\n        starting offset we have just used. In this case, start one character\n        further on. */\n\n        startoffset = offsets\u00dd1\u00a8;    /* Restart after the match */\n        oldstartoffset = pcre2_get_startchar(match_data);\n        if (startoffset <= oldstartoffset)\n          {\n          if (startoffset >= length) goto END_ONE_MATCH;  /* Were at end */\n          startoffset = oldstartoffset + 1;\n          if (utf) while ((ptr\u00ddstartoffset\u00a8 & 0xc0) == 0x80) startoffset++;\n          }\n\n        /* If the current match ended past the end of the line (only possible\n        in multiline mode), we must move on to the line in which it did end\n        before searching for more matches. */\n\n        while (startoffset > linelength)\n          {\n          ptr += linelength + endlinelength;\n          filepos += (int)(linelength + endlinelength);\n          linenumber++;\n          startoffset -= (int)(linelength + endlinelength);\n          t = end_of_line(ptr, endptr, &endlinelength);\n          linelength = t - ptr - endlinelength;\n          length = (PCRE2_SIZE)(endptr - ptr);\n          }\n\n        goto ONLY_MATCHING_RESTART;\n        }\n      }\n\n    /* This is the default case when none of the above options is set. We print\n    the matching lines(s), possibly preceded and/or followed by other lines of\n    context. */\n\n    else\n      {\n      lines_printed = TRUE;\n\n      /* See if there is a requirement to print some \"after\" lines from a\n      previous match. We never print any overlaps. */\n\n      if (after_context > 0 && lastmatchnumber > 0)\n        {\n        int ellength;\n        int linecount = 0;\n        char *p = lastmatchrestart;\n\n        while (p < ptr && linecount < after_context)\n          {\n          p = end_of_line(p, ptr, &ellength);\n          linecount++;\n          }\n\n        /* It is important to advance lastmatchrestart during this printing so\n        that it interacts correctly with any \"before\" printing below. Print\n        each line's data using fwrite() in case there are binary zeroes. */\n\n        while (lastmatchrestart < p)\n          {\n          char *pp = lastmatchrestart;\n          if (printname != NULL) fprintf(stdout, \"%s-\", printname);\n          if (number) fprintf(stdout, \"%lu-\", lastmatchnumber++);\n          pp = end_of_line(pp, endptr, &ellength);\n          FWRITE_IGNORE(lastmatchrestart, 1, pp - lastmatchrestart, stdout);\n          lastmatchrestart = pp;\n          }\n        if (lastmatchrestart != ptr) hyphenpending = TRUE;\n        }\n\n      /* If there were non-contiguous lines printed above, insert hyphens. */\n\n      if (hyphenpending)\n        {\n        fprintf(stdout, \"--\" STDOUT_NL);\n        hyphenpending = FALSE;\n        hyphenprinted = TRUE;\n        }\n\n      /* See if there is a requirement to print some \"before\" lines for this\n      match. Again, don't print overlaps. */\n\n      if (before_context > 0)\n        {\n        int linecount = 0;\n        char *p = ptr;\n\n        while (p > main_buffer &&\n               (lastmatchnumber == 0 || p > lastmatchrestart) &&\n               linecount < before_context)\n          {\n          linecount++;\n          p = previous_line(p, main_buffer);\n          }\n\n        if (lastmatchnumber > 0 && p > lastmatchrestart && !hyphenprinted)\n          fprintf(stdout, \"--\" STDOUT_NL);\n\n        while (p < ptr)\n          {\n          int ellength;\n          char *pp = p;\n          if (printname != NULL) fprintf(stdout, \"%s-\", printname);\n          if (number) fprintf(stdout, \"%lu-\", linenumber - linecount--);\n          pp = end_of_line(pp, endptr, &ellength);\n          FWRITE_IGNORE(p, 1, pp - p, stdout);\n          p = pp;\n          }\n        }\n\n      /* Now print the matching line(s); ensure we set hyphenpending at the end\n      of the file if any context lines are being output. */\n\n      if (after_context > 0 || before_context > 0)\n        endhyphenpending = TRUE;\n\n      if (printname != NULL) fprintf(stdout, \"%s:\", printname);\n      if (number) fprintf(stdout, \"%lu:\", linenumber);\n\n      /* This extra option, for Jeffrey Friedl's debugging requirements,\n      replaces the matched string, or a specific captured string if it exists,\n      with X. When this happens, colouring is ignored. */\n\n#ifdef JFRIEDL_DEBUG\n      if (S_arg >= 0 && S_arg < mrc)\n        {\n        int first = S_arg * 2;\n        int last  = first + 1;\n        FWRITE_IGNORE(ptr, 1, offsets\u00ddfirst\u00a8, stdout);\n        fprintf(stdout, \"X\");\n        FWRITE_IGNORE(ptr + offsets\u00ddlast\u00a8, 1, linelength - offsets\u00ddlast\u00a8, stdout);\n        }\n      else\n#endif\n\n      /* In multiline mode, or if colouring, we have to split the line(s) up\n      and search for further matches, but not of course if the line is a\n      non-match. In multiline mode this is necessary in case there is another\n      match that spans the end of the current line. When colouring we want to\n      colour all matches. */\n\n      if ((multiline || do_colour) && !invert)\n        {\n        int plength;\n        PCRE2_SIZE endprevious;\n\n        /* The use of \\K may make the end offset earlier than the start. In\n        this situation, swap them round. */\n\n        if (offsets\u00dd0\u00a8 > offsets\u00dd1\u00a8)\n          {\n          PCRE2_SIZE temp = offsets\u00dd0\u00a8;\n          offsets\u00dd0\u00a8 = offsets\u00dd1\u00a8;\n          offsets\u00dd1\u00a8 = temp;\n          }\n\n        FWRITE_IGNORE(ptr, 1, offsets\u00dd0\u00a8, stdout);\n        print_match(ptr + offsets\u00dd0\u00a8, offsets\u00dd1\u00a8 - offsets\u00dd0\u00a8);\n\n        for (;;)\n          {\n          PCRE2_SIZE oldstartoffset = pcre2_get_startchar(match_data);\n\n          endprevious = offsets\u00dd1\u00a8;\n          startoffset = endprevious;  /* Advance after previous match. */\n\n          /* If the pattern contained a lookbehind that included \\K, it is\n          possible that the end of the match might be at or before the actual\n          starting offset we have just used. In this case, start one character\n          further on. */\n\n          if (startoffset <= oldstartoffset)\n            {\n            startoffset = oldstartoffset + 1;\n            if (utf) while ((ptr\u00ddstartoffset\u00a8 & 0xc0) == 0x80) startoffset++;\n            }\n\n          /* If the current match ended past the end of the line (only possible\n          in multiline mode), we must move on to the line in which it did end\n          before searching for more matches. Because the PCRE2_FIRSTLINE option\n          is set, the start of the match will always be before the first\n          newline sequence. */\n\n          while (startoffset > linelength + endlinelength)\n            {\n            ptr += linelength + endlinelength;\n            filepos += (int)(linelength + endlinelength);\n            linenumber++;\n            startoffset -= (int)(linelength + endlinelength);\n            endprevious -= (int)(linelength + endlinelength);\n            t = end_of_line(ptr, endptr, &endlinelength);\n            linelength = t - ptr - endlinelength;\n            length = (PCRE2_SIZE)(endptr - ptr);\n            }\n\n          /* If startoffset is at the exact end of the line it means this\n          complete line was the final part of the match, so there is nothing\n          more to do. */\n\n          if (startoffset == linelength + endlinelength) break;\n\n          /* Otherwise, run a match from within the final line, and if found,\n          loop for any that may follow. */\n\n          if (!match_patterns(ptr, length, options, startoffset, &mrc)) break;\n\n          /* The use of \\K may make the end offset earlier than the start. In\n          this situation, swap them round. */\n\n          if (offsets\u00dd0\u00a8 > offsets\u00dd1\u00a8)\n            {\n            PCRE2_SIZE temp = offsets\u00dd0\u00a8;\n            offsets\u00dd0\u00a8 = offsets\u00dd1\u00a8;\n            offsets\u00dd1\u00a8 = temp;\n            }\n\n          FWRITE_IGNORE(ptr + endprevious, 1, offsets\u00dd0\u00a8 - endprevious, stdout);\n          print_match(ptr + offsets\u00dd0\u00a8, offsets\u00dd1\u00a8 - offsets\u00dd0\u00a8);\n          }\n\n        /* In multiline mode, we may have already printed the complete line\n        and its line-ending characters (if they matched the pattern), so there\n        may be no more to print. */\n\n        plength = (int)((linelength + endlinelength) - endprevious);\n        if (plength > 0) FWRITE_IGNORE(ptr + endprevious, 1, plength, stdout);\n        }\n\n      /* Not colouring or multiline; no need to search for further matches. */\n\n      else FWRITE_IGNORE(ptr, 1, linelength + endlinelength, stdout);\n      }\n\n    /* End of doing what has to be done for a match. If --line-buffered was\n    given, flush the output. */\n\n    if (line_buffered) fflush(stdout);\n    rc = 0;    /* Had some success */\n\n    /* Remember where the last match happened for after_context. We remember\n    where we are about to restart, and that line's number. */\n\n    lastmatchrestart = ptr + linelength + endlinelength;\n    lastmatchnumber = linenumber + 1;\n\n    /* If a line was printed and we are now at the end of the file and the last\n    line had no newline, output one. */\n\n    if (lines_printed && lastmatchrestart >= endptr && endlinelength == 0)\n      write_final_newline();\n    }\n\n  /* For a match in multiline inverted mode (which of course did not cause\n  anything to be printed), we have to move on to the end of the match before\n  proceeding. */\n\n  if (multiline && invert && match)\n    {\n    int ellength;\n    char *endmatch = ptr + offsets\u00dd1\u00a8;\n    t = ptr;\n    while (t < endmatch)\n      {\n      t = end_of_line(t, endptr, &ellength);\n      if (t <= endmatch) linenumber++; else break;\n      }\n    endmatch = end_of_line(endmatch, endptr, &ellength);\n    linelength = endmatch - ptr - ellength;\n    }\n\n  /* Advance to after the newline and increment the line number. The file\n  offset to the current line is maintained in filepos. */\n\n  END_ONE_MATCH:\n  ptr += linelength + endlinelength;\n  filepos += (int)(linelength + endlinelength);\n  linenumber++;\n\n  /* If input is line buffered, and the buffer is not yet full, read another\n  line and add it into the buffer. */\n\n  if (input_line_buffered && bufflength < (PCRE2_SIZE)bufsize)\n    {\n    int add = read_one_line(ptr, bufsize - (int)(ptr - main_buffer), in);\n    bufflength += add;\n    endptr += add;\n    }\n\n  /* If we haven't yet reached the end of the file (the buffer is full), and\n  the current point is in the top 1/3 of the buffer, slide the buffer down by\n  1/3 and refill it. Before we do this, if some unprinted \"after\" lines are\n  about to be lost, print them. */\n\n  if (bufflength >= (PCRE2_SIZE)bufsize && ptr > main_buffer + 2*bufthird)\n    {\n    if (after_context > 0 &&\n        lastmatchnumber > 0 &&\n        lastmatchrestart < main_buffer + bufthird)\n      {\n      do_after_lines(lastmatchnumber, lastmatchrestart, endptr, printname);\n      lastmatchnumber = 0;  /* Indicates no after lines pending */\n      }\n\n    /* Now do the shuffle */\n\n    (void)memmove(main_buffer, main_buffer + bufthird, 2*bufthird);\n    ptr -= bufthird;\n\n    bufflength = 2*bufthird + fill_buffer(handle, frtype,\n      main_buffer + 2*bufthird, bufthird, input_line_buffered);\n    endptr = main_buffer + bufflength;\n\n    /* Adjust any last match point */\n\n    if (lastmatchnumber > 0) lastmatchrestart -= bufthird;\n    }\n  }     /* Loop through the whole file */\n\n/* End of file; print final \"after\" lines if wanted; do_after_lines sets\nhyphenpending if it prints something. */\n\nif (only_matching_count == 0 && !(count_only|show_total_count))\n  {\n  do_after_lines(lastmatchnumber, lastmatchrestart, endptr, printname);\n  hyphenpending |= endhyphenpending;\n  }\n\n/* Print the file name if we are looking for those without matches and there\nwere none. If we found a match, we won't have got this far. */\n\nif (filenames == FN_NOMATCH_ONLY)\n  {\n  fprintf(stdout, \"%s\" STDOUT_NL, printname);\n  return 0;\n  }\n\n/* Print the match count if wanted */\n\nif (count_only && !quiet)\n  {\n  if (count > 0 || !omit_zero_count)\n    {\n    if (printname != NULL && filenames != FN_NONE)\n      fprintf(stdout, \"%s:\", printname);\n    fprintf(stdout, \"%lu\" STDOUT_NL, count);\n    counts_printed++;\n    }\n  }\n\ntotal_count += count;   /* Can be set without count_only */\nreturn rc;\n}\n\n\n\n/*************************************************\n*     Grep a file or recurse into a directory    *\n*************************************************/\n\n/* Given a path name, if it's a directory, scan all the files if we are\nrecursing; if it's a file, grep it.\n\nArguments:\n  pathname          the path to investigate\n  dir_recurse       TRUE if recursing is wanted (-r or -drecurse)\n  only_one_at_top   TRUE if the path is the only one at toplevel\n\nReturns:  -1 the file/directory was skipped\n           0 if there was at least one match\n           1 if there were no matches\n           2 there was some kind of error\n\nHowever, file opening failures are suppressed if \"silent\" is set.\n*/\n\nstatic int\ngrep_or_recurse(char *pathname, BOOL dir_recurse, BOOL only_one_at_top)\n{\nint rc = 1;\nint frtype;\nvoid *handle;\nchar *lastcomp;\nFILE *in = NULL;           /* Ensure initialized */\n\n#ifdef SUPPORT_LIBZ\ngzFile ingz = NULL;\n#endif\n\n#ifdef SUPPORT_LIBBZ2\nBZFILE *inbz2 = NULL;\n#endif\n\n#if defined SUPPORT_LIBZ || defined SUPPORT_LIBBZ2\nint pathlen;\n#endif\n\n#if defined NATIVE_ZOS\nint zos_type;\nFILE *zos_test_file;\n#endif\n\n/* If the file name is \"-\" we scan stdin */\n\nif (strcmp(pathname, \"-\") == 0)\n  {\n  return pcre2grep(stdin, FR_PLAIN, stdin_name,\n    (filenames > FN_DEFAULT || (filenames == FN_DEFAULT && !only_one_at_top))?\n      stdin_name : NULL);\n  }\n\n/* Inclusion and exclusion: --include-dir and --exclude-dir apply only to\ndirectories, whereas --include and --exclude apply to everything else. The test\nis against the final component of the path. */\n\nlastcomp = strrchr(pathname, FILESEP);\nlastcomp = (lastcomp == NULL)? pathname : lastcomp + 1;\n\n/* If the file is a directory, skip if not recursing or if explicitly excluded.\nOtherwise, scan the directory and recurse for each path within it. The scanning\ncode is localized so it can be made system-specific. */\n\n\n/* For z/OS, determine the file type. */\n\n#if defined NATIVE_ZOS\nzos_test_file =  fopen(pathname,\"r\");\n\nif (zos_test_file == NULL)\n   {\n   if (!silent) fprintf(stderr, \"pcre2grep: failed to test next file %s\\n\",\n     pathname, strerror(errno));\n   return -1;\n   }\nzos_type = identifyzosfiletype (zos_test_file);\nfclose (zos_test_file);\n\n/* Handle a PDS in separate code */\n\nif (zos_type == __ZOS_PDS || zos_type == __ZOS_PDSE)\n   {\n   return travelonpdsdir (pathname, only_one_at_top);\n   }\n\n/* Deal with regular files in the normal way below. These types are:\n   zos_type == __ZOS_PDS_MEMBER\n   zos_type == __ZOS_PS\n   zos_type == __ZOS_VSAM_KSDS\n   zos_type == __ZOS_VSAM_ESDS\n   zos_type == __ZOS_VSAM_RRDS\n*/\n\n/* Handle a z/OS directory using common code. */\n\nelse if (zos_type == __ZOS_HFS)\n {\n#endif  /* NATIVE_ZOS */\n\n\n/* Handle directories: common code for all OS */\n\nif (isdirectory(pathname))\n  {\n  if (dee_action == dee_SKIP ||\n      !test_incexc(lastcomp, include_dir_patterns, exclude_dir_patterns))\n    return -1;\n\n  if (dee_action == dee_RECURSE)\n    {\n    char buffer\u00ddFNBUFSIZ\u00a8;\n    char *nextfile;\n    directory_type *dir = opendirectory(pathname);\n\n    if (dir == NULL)\n      {\n      if (!silent)\n        fprintf(stderr, \"pcre2grep: Failed to open directory %s: %s\\n\", pathname,\n          strerror(errno));\n      return 2;\n      }\n\n    while ((nextfile = readdirectory(dir)) != NULL)\n      {\n      int frc;\n      int fnlength = strlen(pathname) + strlen(nextfile) + 2;\n      if (fnlength > FNBUFSIZ)\n        {\n        fprintf(stderr, \"pcre2grep: recursive filename is too long\\n\");\n        rc = 2;\n        break;\n        }\n      sprintf(buffer, \"%s%c%s\", pathname, FILESEP, nextfile);\n      frc = grep_or_recurse(buffer, dir_recurse, FALSE);\n      if (frc > 1) rc = frc;\n       else if (frc == 0 && rc == 1) rc = 0;\n      }\n\n    closedirectory(dir);\n    return rc;\n    }\n  }\n\n#ifdef WIN32\nif (iswild(pathname))\n  {\n  char buffer\u00dd1024\u00a8;\n  char *nextfile;\n  char *name;\n  directory_type *dir = opendirectory(pathname);\n\n  if (dir == NULL)\n    return 0;\n\n  for (nextfile = name = pathname; *nextfile != 0; nextfile++)\n    if (*nextfile == '/' || *nextfile == '\\\\')\n      name = nextfile + 1;\n  *name = 0;\n\n  while ((nextfile = readdirectory(dir)) != NULL)\n    {\n    int frc;\n    sprintf(buffer, \"%.512s%.128s\", pathname, nextfile);\n    frc = grep_or_recurse(buffer, dir_recurse, FALSE);\n    if (frc > 1) rc = frc;\n     else if (frc == 0 && rc == 1) rc = 0;\n    }\n\n  closedirectory(dir);\n  return rc;\n  }\n#endif\n\n#if defined NATIVE_ZOS\n }\n#endif\n\n/* If the file is not a directory, check for a regular file, and if it is not,\nskip it if that's been requested. Otherwise, check for an explicit inclusion or\nexclusion. */\n\nelse if (\n#if defined NATIVE_ZOS\n        (zos_type == __ZOS_NOFILE && DEE_action == DEE_SKIP) ||\n#else  /* all other OS */\n        (!isregfile(pathname) && DEE_action == DEE_SKIP) ||\n#endif\n        !test_incexc(lastcomp, include_patterns, exclude_patterns))\n  return -1;  /* File skipped */\n\n/* Control reaches here if we have a regular file, or if we have a directory\nand recursion or skipping was not requested, or if we have anything else and\nskipping was not requested. The scan proceeds. If this is the first and only\nargument at top level, we don't show the file name, unless we are only showing\nthe file name, or the filename was forced (-H). */\n\n#if defined SUPPORT_LIBZ || defined SUPPORT_LIBBZ2\npathlen = (int)(strlen(pathname));\n#endif\n\n/* Open using zlib if it is supported and the file name ends with .gz. */\n\n#ifdef SUPPORT_LIBZ\nif (pathlen > 3 && strcmp(pathname + pathlen - 3, \".gz\") == 0)\n  {\n  ingz = gzopen(pathname, \"rb\");\n  if (ingz == NULL)\n    {\n    if (!silent)\n      fprintf(stderr, \"pcre2grep: Failed to open %s: %s\\n\", pathname,\n        strerror(errno));\n    return 2;\n    }\n  handle = (void *)ingz;\n  frtype = FR_LIBZ;\n  }\nelse\n#endif\n\n/* Otherwise open with bz2lib if it is supported and the name ends with .bz2. */\n\n#ifdef SUPPORT_LIBBZ2\nif (pathlen > 4 && strcmp(pathname + pathlen - 4, \".bz2\") == 0)\n  {\n  inbz2 = BZ2_bzopen(pathname, \"rb\");\n  handle = (void *)inbz2;\n  frtype = FR_LIBBZ2;\n  }\nelse\n#endif\n\n/* Otherwise use plain fopen(). The label is so that we can come back here if\nan attempt to read a .bz2 file indicates that it really is a plain file. */\n\n#ifdef SUPPORT_LIBBZ2\nPLAIN_FILE:\n#endif\n  {\n  in = fopen(pathname, \"r\");\n  handle = (void *)in;\n  frtype = FR_PLAIN;\n  }\n\n/* All the opening methods return errno when they fail. */\n\nif (handle == NULL)\n  {\n  if (!silent)\n    fprintf(stderr, \"pcre2grep: Failed to open %s: %s\\n\", pathname,\n      strerror(errno));\n  return 2;\n  }\n\n/* Now grep the file */\n\nrc = pcre2grep(handle, frtype, pathname, (filenames > FN_DEFAULT ||\n  (filenames == FN_DEFAULT && !only_one_at_top))? pathname : NULL);\n\n/* Close in an appropriate manner. */\n\n#ifdef SUPPORT_LIBZ\nif (frtype == FR_LIBZ)\n  gzclose(ingz);\nelse\n#endif\n\n/* If it is a .bz2 file and the result is 3, it means that the first attempt to\nread failed. If the error indicates that the file isn't in fact bzipped, try\nagain as a normal file. */\n\n#ifdef SUPPORT_LIBBZ2\nif (frtype == FR_LIBBZ2)\n  {\n  if (rc == 3)\n    {\n    int errnum;\n    const char *err = BZ2_bzerror(inbz2, &errnum);\n    if (errnum == BZ_DATA_ERROR_MAGIC)\n      {\n      BZ2_bzclose(inbz2);\n      goto PLAIN_FILE;\n      }\n    else if (!silent)\n      fprintf(stderr, \"pcre2grep: Failed to read %s using bzlib: %s\\n\",\n        pathname, err);\n    rc = 2;    /* The normal \"something went wrong\" code */\n    }\n  BZ2_bzclose(inbz2);\n  }\nelse\n#endif\n\n/* Normal file close */\n\nfclose(in);\n\n/* Pass back the yield from pcre2grep(). */\n\nreturn rc;\n}\n\n\n\n/*************************************************\n*    Handle a single-letter, no data option      *\n*************************************************/\n\nstatic int\nhandle_option(int letter, int options)\n{\nswitch(letter)\n  {\n  case N_FOFFSETS: file_offsets = TRUE; break;\n  case N_HELP: help(); pcre2grep_exit(0); break; /* Stops compiler warning */\n  case N_LBUFFER: line_buffered = TRUE; break;\n  case N_LOFFSETS: line_offsets = number = TRUE; break;\n  case N_NOJIT: use_jit = FALSE; break;\n  case 'a': binary_files = BIN_TEXT; break;\n  case 'c': count_only = TRUE; break;\n  case 'F': options |= PCRE2_LITERAL; break;\n  case 'H': filenames = FN_FORCE; break;\n  case 'I': binary_files = BIN_NOMATCH; break;\n  case 'h': filenames = FN_NONE; break;\n  case 'i': options |= PCRE2_CASELESS; break;\n  case 'l': omit_zero_count = TRUE; filenames = FN_MATCH_ONLY; break;\n  case 'L': filenames = FN_NOMATCH_ONLY; break;\n  case 'M': multiline = TRUE; options |= PCRE2_MULTILINE|PCRE2_FIRSTLINE; break;\n  case 'n': number = TRUE; break;\n\n  case 'o':\n  only_matching_last = add_number(0, only_matching_last);\n  if (only_matching == NULL) only_matching = only_matching_last;\n  break;\n\n  case 'q': quiet = TRUE; break;\n  case 'r': dee_action = dee_RECURSE; break;\n  case 's': silent = TRUE; break;\n  case 't': show_total_count = TRUE; break;\n  case 'u': options |= PCRE2_UTF; utf = TRUE; break;\n  case 'U': options |= PCRE2_UTF|PCRE2_MATCH_INVALID_UTF; utf = TRUE; break;\n  case 'v': invert = TRUE; break;\n  case 'w': extra_options |= PCRE2_EXTRA_MATCH_WORD; break;\n  case 'x': extra_options |= PCRE2_EXTRA_MATCH_LINE; break;\n\n  case 'V':\n    {\n    unsigned char buffer\u00dd128\u00a8;\n    (void)pcre2_config(PCRE2_CONFIG_VERSION, buffer);\n    fprintf(stdout, \"pcre2grep version %s\" STDOUT_NL, buffer);\n    }\n  pcre2grep_exit(0);\n  break;\n\n  default:\n  fprintf(stderr, \"pcre2grep: Unknown option -%c\\n\", letter);\n  pcre2grep_exit(usage(2));\n  }\n\nreturn options;\n}\n\n\n\n/*************************************************\n*          Construct printed ordinal             *\n*************************************************/\n\n/* This turns a number into \"1st\", \"3rd\", etc. */\n\nstatic char *\nordin(int n)\n{\nstatic char buffer\u00dd14\u00a8;\nchar *p = buffer;\nsprintf(p, \"%d\", n);\nwhile (*p != 0) p++;\nn %= 100;\nif (n >= 11 && n <= 13) n = 0;\nswitch (n%10)\n  {\n  case 1: strcpy(p, \"st\"); break;\n  case 2: strcpy(p, \"nd\"); break;\n  case 3: strcpy(p, \"rd\"); break;\n  default: strcpy(p, \"th\"); break;\n  }\nreturn buffer;\n}\n\n\n\n/*************************************************\n*          Compile a single pattern              *\n*************************************************/\n\n/* Do nothing if the pattern has already been compiled. This is the case for\ninclude/exclude patterns read from a file.\n\nWhen the -F option has been used, each \"pattern\" may be a list of strings,\nseparated by line breaks. They will be matched literally. We split such a\nstring and compile the first substring, inserting an additional block into the\npattern chain.\n\nArguments:\n  p              points to the pattern block\n  options        the PCRE options\n  fromfile       TRUE if the pattern was read from a file\n  fromtext       file name or identifying text (e.g. \"include\")\n  count          0 if this is the only command line pattern, or\n                 number of the command line pattern, or\n                 linenumber for a pattern from a file\n\nReturns:         TRUE on success, FALSE after an error\n*/\n\nstatic BOOL\ncompile_pattern(patstr *p, int options, int fromfile, const char *fromtext,\n  int count)\n{\nchar *ps;\nint errcode;\nPCRE2_SIZE patlen, erroffset;\nPCRE2_UCHAR errmessbuffer\u00ddERRBUFSIZ\u00a8;\n\nif (p->compiled != NULL) return TRUE;\nps = p->string;\npatlen = p->length;\n\nif ((options & PCRE2_LITERAL) != 0)\n  {\n  int ellength;\n  char *eop = ps + patlen;\n  char *pe = end_of_line(ps, eop, &ellength);\n\n  if (ellength != 0)\n    {\n    patlen = pe - ps - ellength;\n    if (add_pattern(pe, p->length-patlen-ellength, p) == NULL) return FALSE;\n    }\n  }\n\np->compiled = pcre2_compile((PCRE2_SPTR)ps, patlen, options, &errcode,\n  &erroffset, compile_context);\n\n/* Handle successful compile. Try JIT-compiling if supported and enabled. We\nignore any JIT compiler errors, relying falling back to interpreting if\nanything goes wrong with JIT. */\n\nif (p->compiled != NULL)\n  {\n#ifdef SUPPORT_PCRE2GREP_JIT\n  if (use_jit) (void)pcre2_jit_compile(p->compiled, PCRE2_JIT_COMPLETE);\n#endif\n  return TRUE;\n  }\n\n/* Handle compile errors */\n\nif (erroffset > patlen) erroffset = patlen;\npcre2_get_error_message(errcode, errmessbuffer, sizeof(errmessbuffer));\n\nif (fromfile)\n  {\n  fprintf(stderr, \"pcre2grep: Error in regex in line %d of %s \"\n    \"at offset %d: %s\\n\", count, fromtext, (int)erroffset, errmessbuffer);\n  }\nelse\n  {\n  if (count == 0)\n    fprintf(stderr, \"pcre2grep: Error in %s regex at offset %d: %s\\n\",\n      fromtext, (int)erroffset, errmessbuffer);\n  else\n    fprintf(stderr, \"pcre2grep: Error in %s %s regex at offset %d: %s\\n\",\n      ordin(count), fromtext, (int)erroffset, errmessbuffer);\n  }\n\nreturn FALSE;\n}\n\n\n\n/*************************************************\n*     Read and compile a file of patterns        *\n*************************************************/\n\n/* This is used for --filelist, --include-from, and --exclude-from.\n\nArguments:\n  name         the name of the file; \"-\" is stdin\n  patptr       pointer to the pattern chain anchor\n  patlastptr   pointer to the last pattern pointer\n\nReturns:       TRUE if all went well\n*/\n\nstatic BOOL\nread_pattern_file(char *name, patstr **patptr, patstr **patlastptr)\n{\nint linenumber = 0;\nPCRE2_SIZE patlen;\nFILE *f;\nconst char *filename;\nchar buffer\u00ddMAXPATLEN+20\u00a8;\n\nif (strcmp(name, \"-\") == 0)\n  {\n  f = stdin;\n  filename = stdin_name;\n  }\nelse\n  {\n  f = fopen(name, \"r\");\n  if (f == NULL)\n    {\n    fprintf(stderr, \"pcre2grep: Failed to open %s: %s\\n\", name, strerror(errno));\n    return FALSE;\n    }\n  filename = name;\n  }\n\nwhile ((patlen = read_one_line(buffer, sizeof(buffer), f)) > 0)\n  {\n  while (patlen > 0 && isspace((unsigned char)(buffer\u00ddpatlen-1\u00a8))) patlen--;\n  linenumber++;\n  if (patlen == 0) continue;   /* Skip blank lines */\n\n  /* Note: this call to add_pattern() puts a pointer to the local variable\n  \"buffer\" into the pattern chain. However, that pointer is used only when\n  compiling the pattern, which happens immediately below, so we flatten it\n  afterwards, as a precaution against any later code trying to use it. */\n\n  *patlastptr = add_pattern(buffer, patlen, *patlastptr);\n  if (*patlastptr == NULL)\n    {\n    if (f != stdin) fclose(f);\n    return FALSE;\n    }\n  if (*patptr == NULL) *patptr = *patlastptr;\n\n  /* This loop is needed because compiling a \"pattern\" when -F is set may add\n  on additional literal patterns if the original contains a newline. In the\n  common case, it never will, because read_one_line() stops at a newline.\n  However, the -N option can be used to give pcre2grep a different newline\n  setting. */\n\n  for(;;)\n    {\n    if (!compile_pattern(*patlastptr, pcre2_options, TRUE, filename,\n        linenumber))\n      {\n      if (f != stdin) fclose(f);\n      return FALSE;\n      }\n    (*patlastptr)->string = NULL;            /* Insurance */\n    if ((*patlastptr)->next == NULL) break;\n    *patlastptr = (*patlastptr)->next;\n    }\n  }\n\nif (f != stdin) fclose(f);\nreturn TRUE;\n}\n\n\n\n/*************************************************\n*                Main program                    *\n*************************************************/\n\n/* Returns 0 if something matched, 1 if nothing matched, 2 after an error. */\n\nint\nmain(int argc, char **argv)\n{\nint i, j;\nint rc = 1;\nBOOL only_one_at_top;\npatstr *cp;\nfnstr *fn;\nomstr *om;\nconst char *locale_from = \"--locale\";\n\n#ifdef SUPPORT_PCRE2GREP_JIT\npcre2_jit_stack *jit_stack = NULL;\n#endif\n\n/* In Windows, stdout is set up as a text stream, which means that \\n is\nconverted to \\r\\n. This causes output lines that are copied from the input to\nchange from ....\\r\\n to ....\\r\\r\\n, which is not right. We therefore ensure\nthat stdout is a binary stream. Note that this means all other output to stdout\nmust use STDOUT_NL to terminate lines. */\n\n#ifdef WIN32\n_setmode(_fileno(stdout), _O_BINARY);\n#endif\n\n/* Process the options */\n\nfor (i = 1; i < argc; i++)\n  {\n  option_item *op = NULL;\n  char *option_data = (char *)\"\";    /* default to keep compiler happy */\n  BOOL longop;\n  BOOL longopwasequals = FALSE;\n\n  if (argv\u00ddi\u00a8\u00dd0\u00a8 != '-') break;\n\n  /* If we hit an argument that is just \"-\", it may be a reference to STDIN,\n  but only if we have previously had -e or -f to define the patterns. */\n\n  if (argv\u00ddi\u00a8\u00dd1\u00a8 == 0)\n    {\n    if (pattern_files != NULL || patterns != NULL) break;\n      else pcre2grep_exit(usage(2));\n    }\n\n  /* Handle a long name option, or -- to terminate the options */\n\n  if (argv\u00ddi\u00a8\u00dd1\u00a8 == '-')\n    {\n    char *arg = argv\u00ddi\u00a8 + 2;\n    char *argequals = strchr(arg, '=');\n\n    if (*arg == 0)    /* -- terminates options */\n      {\n      i++;\n      break;                /* out of the options-handling loop */\n      }\n\n    longop = TRUE;\n\n    /* Some long options have data that follows after =, for example file=name.\n    Some options have variations in the long name spelling: specifically, we\n    allow \"regexp\" because GNU grep allows it, though I personally go along\n    with Jeffrey Friedl and Larry Wall in preferring \"regex\" without the \"p\".\n    These options are entered in the table as \"regex(p)\". Options can be in\n    both these categories. */\n\n    for (op = optionlist; op->one_char != 0; op++)\n      {\n      char *opbra = strchr(op->long_name, '(');\n      char *equals = strchr(op->long_name, '=');\n\n      /* Handle options with only one spelling of the name */\n\n      if (opbra == NULL)     /* Does not contain '(' */\n        {\n        if (equals == NULL)  /* Not thing=data case */\n          {\n          if (strcmp(arg, op->long_name) == 0) break;\n          }\n        else                 /* Special case xxx=data */\n          {\n          int oplen = (int)(equals - op->long_name);\n          int arglen = (argequals == NULL)?\n            (int)strlen(arg) : (int)(argequals - arg);\n          if (oplen == arglen && strncmp(arg, op->long_name, oplen) == 0)\n            {\n            option_data = arg + arglen;\n            if (*option_data == '=')\n              {\n              option_data++;\n              longopwasequals = TRUE;\n              }\n            break;\n            }\n          }\n        }\n\n      /* Handle options with an alternate spelling of the name */\n\n      else\n        {\n        char buff1\u00dd24\u00a8;\n        char buff2\u00dd24\u00a8;\n        int ret;\n\n        int baselen = (int)(opbra - op->long_name);\n        int fulllen = (int)(strchr(op->long_name, ')') - op->long_name + 1);\n        int arglen = (argequals == NULL || equals == NULL)?\n          (int)strlen(arg) : (int)(argequals - arg);\n\n        if ((ret = snprintf(buff1, sizeof(buff1), \"%.*s\", baselen, op->long_name),\n             ret < 0 || ret > (int)sizeof(buff1)) ||\n            (ret = snprintf(buff2, sizeof(buff2), \"%s%.*s\", buff1,\n                     fulllen - baselen - 2, opbra + 1),\n             ret < 0 || ret > (int)sizeof(buff2)))\n          {\n          fprintf(stderr, \"pcre2grep: Buffer overflow when parsing %s option\\n\",\n            op->long_name);\n          pcre2grep_exit(2);\n          }\n\n        if (strncmp(arg, buff1, arglen) == 0 ||\n           strncmp(arg, buff2, arglen) == 0)\n          {\n          if (equals != NULL && argequals != NULL)\n            {\n            option_data = argequals;\n            if (*option_data == '=')\n              {\n              option_data++;\n              longopwasequals = TRUE;\n              }\n            }\n          break;\n          }\n        }\n      }\n\n    if (op->one_char == 0)\n      {\n      fprintf(stderr, \"pcre2grep: Unknown option %s\\n\", argv\u00ddi\u00a8);\n      pcre2grep_exit(usage(2));\n      }\n    }\n\n  /* Jeffrey Friedl's debugging harness uses these additional options which\n  are not in the right form for putting in the option table because they use\n  only one hyphen, yet are more than one character long. By putting them\n  separately here, they will not get displayed as part of the help() output,\n  but I don't think Jeffrey will care about that. */\n\n#ifdef JFRIEDL_DEBUG\n  else if (strcmp(argv\u00ddi\u00a8, \"-pre\") == 0) {\n          jfriedl_prefix = argv\u00dd++i\u00a8;\n          continue;\n  } else if (strcmp(argv\u00ddi\u00a8, \"-post\") == 0) {\n          jfriedl_postfix = argv\u00dd++i\u00a8;\n          continue;\n  } else if (strcmp(argv\u00ddi\u00a8, \"-XT\") == 0) {\n          sscanf(argv\u00dd++i\u00a8, \"%d\", &jfriedl_XT);\n          continue;\n  } else if (strcmp(argv\u00ddi\u00a8, \"-XR\") == 0) {\n          sscanf(argv\u00dd++i\u00a8, \"%d\", &jfriedl_XR);\n          continue;\n  }\n#endif\n\n\n  /* One-char options; many that have no data may be in a single argument; we\n  continue till we hit the last one or one that needs data. */\n\n  else\n    {\n    char *s = argv\u00ddi\u00a8 + 1;\n    longop = FALSE;\n\n    while (*s != 0)\n      {\n      for (op = optionlist; op->one_char != 0; op++)\n        {\n        if (*s == op->one_char) break;\n        }\n      if (op->one_char == 0)\n        {\n        fprintf(stderr, \"pcre2grep: Unknown option letter '%c' in \\\"%s\\\"\\n\",\n          *s, argv\u00ddi\u00a8);\n        pcre2grep_exit(usage(2));\n        }\n\n      option_data = s+1;\n\n      /* Break out if this is the last character in the string; it's handled\n      below like a single multi-char option. */\n\n      if (*option_data == 0) break;\n\n      /* Check for a single-character option that has data: OP_OP_NUMBER(S)\n      are used for ones that either have a numerical number or defaults, i.e.\n      the data is optional. If a digit follows, there is data; if not, carry on\n      with other single-character options in the same string. */\n\n      if (op->type == OP_OP_NUMBER || op->type == OP_OP_NUMBERS)\n        {\n        if (isdigit((unsigned char)s\u00dd1\u00a8)) break;\n        }\n      else   /* Check for an option with data */\n        {\n        if (op->type != OP_NODATA) break;\n        }\n\n      /* Handle a single-character option with no data, then loop for the\n      next character in the string. */\n\n      pcre2_options = handle_option(*s++, pcre2_options);\n      }\n    }\n\n  /* At this point we should have op pointing to a matched option. If the type\n  is NO_DATA, it means that there is no data, and the option might set\n  something in the PCRE options. */\n\n  if (op->type == OP_NODATA)\n    {\n    pcre2_options = handle_option(op->one_char, pcre2_options);\n    continue;\n    }\n\n  /* If the option type is OP_OP_STRING or OP_OP_NUMBER(S), it's an option that\n  either has a value or defaults to something. It cannot have data in a\n  separate item. At the moment, the only such options are \"colo(u)r\",\n  \"only-matching\", and Jeffrey Friedl's special -S debugging option. */\n\n  if (*option_data == 0 &&\n      (op->type == OP_OP_STRING || op->type == OP_OP_NUMBER ||\n       op->type == OP_OP_NUMBERS))\n    {\n    switch (op->one_char)\n      {\n      case N_COLOUR:\n      colour_option = \"auto\";\n      break;\n\n      case 'o':\n      only_matching_last = add_number(0, only_matching_last);\n      if (only_matching == NULL) only_matching = only_matching_last;\n      break;\n\n#ifdef JFRIEDL_DEBUG\n      case 'S':\n      S_arg = 0;\n      break;\n#endif\n      }\n    continue;\n    }\n\n  /* Otherwise, find the data string for the option. */\n\n  if (*option_data == 0)\n    {\n    if (i >= argc - 1 || longopwasequals)\n      {\n      fprintf(stderr, \"pcre2grep: Data missing after %s\\n\", argv\u00ddi\u00a8);\n      pcre2grep_exit(usage(2));\n      }\n    option_data = argv\u00dd++i\u00a8;\n    }\n\n  /* If the option type is OP_OP_NUMBERS, the value is a number that is to be\n  added to a chain of numbers. */\n\n  if (op->type == OP_OP_NUMBERS)\n    {\n    unsigned long int n = decode_number(option_data, op, longop);\n    omdatastr *omd = (omdatastr *)op->dataptr;\n    *(omd->lastptr) = add_number((int)n, *(omd->lastptr));\n    if (*(omd->anchor) == NULL) *(omd->anchor) = *(omd->lastptr);\n    }\n\n  /* If the option type is OP_PATLIST, it's the -e option, or one of the\n  include/exclude options, which can be called multiple times to create lists\n  of patterns. */\n\n  else if (op->type == OP_PATLIST)\n    {\n    patdatastr *pd = (patdatastr *)op->dataptr;\n    *(pd->lastptr) = add_pattern(option_data, (PCRE2_SIZE)strlen(option_data),\n      *(pd->lastptr));\n    if (*(pd->lastptr) == NULL) goto EXIT2;\n    if (*(pd->anchor) == NULL) *(pd->anchor) = *(pd->lastptr);\n    }\n\n  /* If the option type is OP_FILELIST, it's one of the options that names a\n  file. */\n\n  else if (op->type == OP_FILELIST)\n    {\n    fndatastr *fd = (fndatastr *)op->dataptr;\n    fn = (fnstr *)malloc(sizeof(fnstr));\n    if (fn == NULL)\n      {\n      fprintf(stderr, \"pcre2grep: malloc failed\\n\");\n      goto EXIT2;\n      }\n    fn->next = NULL;\n    fn->name = option_data;\n    if (*(fd->anchor) == NULL)\n      *(fd->anchor) = fn;\n    else\n      (*(fd->lastptr))->next = fn;\n    *(fd->lastptr) = fn;\n    }\n\n  /* Handle OP_BINARY_FILES */\n\n  else if (op->type == OP_BINFILES)\n    {\n    if (strcmp(option_data, \"binary\") == 0)\n      binary_files = BIN_BINARY;\n    else if (strcmp(option_data, \"without-match\") == 0)\n      binary_files = BIN_NOMATCH;\n    else if (strcmp(option_data, \"text\") == 0)\n      binary_files = BIN_TEXT;\n    else\n      {\n      fprintf(stderr, \"pcre2grep: unknown value \\\"%s\\\" for binary-files\\n\",\n        option_data);\n      pcre2grep_exit(usage(2));\n      }\n    }\n\n  /* Otherwise, deal with a single string or numeric data value. */\n\n  else if (op->type != OP_NUMBER && op->type != OP_U32NUMBER &&\n           op->type != OP_OP_NUMBER && op->type != OP_SIZE)\n    {\n    *((char **)op->dataptr) = option_data;\n    }\n  else\n    {\n    unsigned long int n = decode_number(option_data, op, longop);\n    if (op->type == OP_U32NUMBER) *((uint32_t *)op->dataptr) = n;\n      else if (op->type == OP_SIZE) *((PCRE2_SIZE *)op->dataptr) = n;\n      else *((int *)op->dataptr) = n;\n    }\n  }\n\n/* Options have been decoded. If -C was used, its value is used as a default\nfor -A and -B. */\n\nif (both_context > 0)\n  {\n  if (after_context == 0) after_context = both_context;\n  if (before_context == 0) before_context = both_context;\n  }\n\n/* Only one of --only-matching, --output, --file-offsets, or --line-offsets is\npermitted. They display, each in their own way, only the data that has matched.\n*/\n\nonly_matching_count = (only_matching != NULL) + (output_text != NULL) +\n  file_offsets + line_offsets;\n\nif (only_matching_count > 1)\n  {\n  fprintf(stderr, \"pcre2grep: Cannot mix --only-matching, --output, \"\n    \"--file-offsets and/or --line-offsets\\n\");\n  pcre2grep_exit(usage(2));\n  }\n\n/* Check that there is a big enough ovector for all -o settings. */\n\nfor (om = only_matching; om != NULL; om = om->next)\n  {\n  int n = om->groupnum;\n  if (n > (int)capture_max)\n    {\n    fprintf(stderr, \"pcre2grep: Requested group %d cannot be captured.\\n\", n);\n    fprintf(stderr, \"pcre2grep: Use --om-capture to increase the size of the capture vector.\\n\");\n    goto EXIT2;\n    }\n  }\n\n/* Check the text supplied to --output for errors. */\n\nif (output_text != NULL &&\n    !syntax_check_output_text((PCRE2_SPTR)output_text, FALSE))\n  goto EXIT2;\n\n/* Set up default compile and match contexts and a match data block. */\n\noffset_size = capture_max + 1;\ncompile_context = pcre2_compile_context_create(NULL);\nmatch_context = pcre2_match_context_create(NULL);\nmatch_data = pcre2_match_data_create(offset_size, NULL);\noffsets = pcre2_get_ovector_pointer(match_data);\n\n/* If string (script) callouts are supported, set up the callout processing\nfunction. */\n\n#ifdef SUPPORT_PCRE2GREP_CALLOUT\npcre2_set_callout(match_context, pcre2grep_callout, NULL);\n#endif\n\n/* Put limits into the match data block. */\n\nif (heap_limit != PCRE2_UNSET) pcre2_set_heap_limit(match_context, heap_limit);\nif (match_limit > 0) pcre2_set_match_limit(match_context, match_limit);\nif (depth_limit > 0) pcre2_set_depth_limit(match_context, depth_limit);\n\n/* If a locale has not been provided as an option, see if the LC_CTYPE or\nLC_ALL environment variable is set, and if so, use it. */\n\nif (locale == NULL)\n  {\n  locale = getenv(\"LC_ALL\");\n  locale_from = \"LC_ALL\";\n  }\n\nif (locale == NULL)\n  {\n  locale = getenv(\"LC_CTYPE\");\n  locale_from = \"LC_CTYPE\";\n  }\n\n/* If a locale is set, use it to generate the tables the PCRE needs. Passing\nNULL to pcre2_maketables() means that malloc() is used to get the memory. */\n\nif (locale != NULL)\n  {\n  if (setlocale(LC_CTYPE, locale) == NULL)\n    {\n    fprintf(stderr, \"pcre2grep: Failed to set locale %s (obtained from %s)\\n\",\n      locale, locale_from);\n    goto EXIT2;\n    }\n  character_tables = pcre2_maketables(NULL);\n  pcre2_set_character_tables(compile_context, character_tables);\n  }\n\n/* Sort out colouring */\n\nif (colour_option != NULL && strcmp(colour_option, \"never\") != 0)\n  {\n  if (strcmp(colour_option, \"always\") == 0)\n#ifdef WIN32\n    do_ansi = !is_stdout_tty(),\n#endif\n    do_colour = TRUE;\n  else if (strcmp(colour_option, \"auto\") == 0) do_colour = is_stdout_tty();\n  else\n    {\n    fprintf(stderr, \"pcre2grep: Unknown colour setting \\\"%s\\\"\\n\",\n      colour_option);\n    goto EXIT2;\n    }\n  if (do_colour)\n    {\n    char *cs = getenv(\"PCRE2GREP_COLOUR\");\n    if (cs == NULL) cs = getenv(\"PCRE2GREP_COLOR\");\n    if (cs == NULL) cs = getenv(\"PCREGREP_COLOUR\");\n    if (cs == NULL) cs = getenv(\"PCREGREP_COLOR\");\n    if (cs == NULL) cs = parse_grep_colors(getenv(\"GREP_COLORS\"));\n    if (cs == NULL) cs = getenv(\"GREP_COLOR\");\n    if (cs != NULL)\n      {\n      if (strspn(cs, \";0123456789\") == strlen(cs)) colour_string = cs;\n      }\n#ifdef WIN32\n    init_colour_output();\n#endif\n    }\n  }\n\n/* Sort out a newline setting. */\n\nif (newline_arg != NULL)\n  {\n  for (endlinetype = 1; endlinetype < (int)(sizeof(newlines)/sizeof(char *));\n       endlinetype++)\n    {\n    if (strcmpic(newline_arg, newlines\u00ddendlinetype\u00a8) == 0) break;\n    }\n  if (endlinetype < (int)(sizeof(newlines)/sizeof(char *)))\n    pcre2_set_newline(compile_context, endlinetype);\n  else\n    {\n    fprintf(stderr, \"pcre2grep: Invalid newline specifier \\\"%s\\\"\\n\",\n      newline_arg);\n    goto EXIT2;\n    }\n  }\n\n/* Find default newline convention */\n\nelse\n  {\n  (void)pcre2_config(PCRE2_CONFIG_NEWLINE, &endlinetype);\n  }\n\n/* Interpret the text values for -d and -D */\n\nif (dee_option != NULL)\n  {\n  if (strcmp(dee_option, \"read\") == 0) dee_action = dee_READ;\n  else if (strcmp(dee_option, \"recurse\") == 0) dee_action = dee_RECURSE;\n  else if (strcmp(dee_option, \"skip\") == 0) dee_action = dee_SKIP;\n  else\n    {\n    fprintf(stderr, \"pcre2grep: Invalid value \\\"%s\\\" for -d\\n\", dee_option);\n    goto EXIT2;\n    }\n  }\n\nif (DEE_option != NULL)\n  {\n  if (strcmp(DEE_option, \"read\") == 0) DEE_action = DEE_READ;\n  else if (strcmp(DEE_option, \"skip\") == 0) DEE_action = DEE_SKIP;\n  else\n    {\n    fprintf(stderr, \"pcre2grep: Invalid value \\\"%s\\\" for -D\\n\", DEE_option);\n    goto EXIT2;\n    }\n  }\n\n/* Set the extra options */\n\n(void)pcre2_set_compile_extra_options(compile_context, extra_options);\n\n/* Check the values for Jeffrey Friedl's debugging options. */\n\n#ifdef JFRIEDL_DEBUG\nif (S_arg > 9)\n  {\n  fprintf(stderr, \"pcre2grep: bad value for -S option\\n\");\n  return 2;\n  }\nif (jfriedl_XT != 0 || jfriedl_XR != 0)\n  {\n  if (jfriedl_XT == 0) jfriedl_XT = 1;\n  if (jfriedl_XR == 0) jfriedl_XR = 1;\n  }\n#endif\n\n/* If use_jit is set, check whether JIT is available. If not, do not try\nto use JIT. */\n\nif (use_jit)\n  {\n  uint32_t answer;\n  (void)pcre2_config(PCRE2_CONFIG_JIT, &answer);\n  if (!answer) use_jit = FALSE;\n  }\n\n/* Get memory for the main buffer. */\n\nif (bufthird <= 0)\n  {\n  fprintf(stderr, \"pcre2grep: --buffer-size must be greater than zero\\n\");\n  goto EXIT2;\n  }\n\nbufsize = 3*bufthird;\nmain_buffer = (char *)malloc(bufsize);\n\nif (main_buffer == NULL)\n  {\n  fprintf(stderr, \"pcre2grep: malloc failed\\n\");\n  goto EXIT2;\n  }\n\n/* If no patterns were provided by -e, and there are no files provided by -f,\nthe first argument is the one and only pattern, and it must exist. */\n\nif (patterns == NULL && pattern_files == NULL)\n  {\n  if (i >= argc) return usage(2);\n  patterns = patterns_last = add_pattern(argv\u00ddi\u00a8, (PCRE2_SIZE)strlen(argv\u00ddi\u00a8),\n    NULL);\n  i++;\n  if (patterns == NULL) goto EXIT2;\n  }\n\n/* Compile the patterns that were provided on the command line, either by\nmultiple uses of -e or as a single unkeyed pattern. We cannot do this until\nafter all the command-line options are read so that we know which PCRE options\nto use. When -F is used, compile_pattern() may add another block into the\nchain, so we must not access the next pointer till after the compile. */\n\nfor (j = 1, cp = patterns; cp != NULL; j++, cp = cp->next)\n  {\n  if (!compile_pattern(cp, pcre2_options, FALSE, \"command-line\",\n       (j == 1 && patterns->next == NULL)? 0 : j))\n    goto EXIT2;\n  }\n\n/* Read and compile the regular expressions that are provided in files. */\n\nfor (fn = pattern_files; fn != NULL; fn = fn->next)\n  {\n  if (!read_pattern_file(fn->name, &patterns, &patterns_last)) goto EXIT2;\n  }\n\n/* Unless JIT has been explicitly disabled, arrange a stack for it to use. */\n\n#ifdef SUPPORT_PCRE2GREP_JIT\nif (use_jit)\n  {\n  jit_stack = pcre2_jit_stack_create(32*1024, 1024*1024, NULL);\n  if (jit_stack != NULL                        )\n    pcre2_jit_stack_assign(match_context, NULL, jit_stack);\n  }\n#endif\n\n/* -F, -w, and -x do not apply to include or exclude patterns, so we must\nadjust the options. */\n\npcre2_options &= ~PCRE2_LITERAL;\n(void)pcre2_set_compile_extra_options(compile_context, 0);\n\n/* If there are include or exclude patterns read from the command line, compile\nthem. */\n\nfor (j = 0; j < 4; j++)\n  {\n  int k;\n  for (k = 1, cp = *(incexlist\u00ddj\u00a8); cp != NULL; k++, cp = cp->next)\n    {\n    if (!compile_pattern(cp, pcre2_options, FALSE, incexname\u00ddj\u00a8,\n         (k == 1 && cp->next == NULL)? 0 : k))\n      goto EXIT2;\n    }\n  }\n\n/* Read and compile include/exclude patterns from files. */\n\nfor (fn = include_from; fn != NULL; fn = fn->next)\n  {\n  if (!read_pattern_file(fn->name, &include_patterns, &include_patterns_last))\n    goto EXIT2;\n  }\n\nfor (fn = exclude_from; fn != NULL; fn = fn->next)\n  {\n  if (!read_pattern_file(fn->name, &exclude_patterns, &exclude_patterns_last))\n    goto EXIT2;\n  }\n\n/* If there are no files that contain lists of files to search, and there are\nno file arguments, search stdin, and then exit. */\n\nif (file_lists == NULL && i >= argc)\n  {\n  rc = pcre2grep(stdin, FR_PLAIN, stdin_name,\n    (filenames > FN_DEFAULT)? stdin_name : NULL);\n  goto EXIT;\n  }\n\n/* If any files that contains a list of files to search have been specified,\nread them line by line and search the given files. */\n\nfor (fn = file_lists; fn != NULL; fn = fn->next)\n  {\n  char buffer\u00ddFNBUFSIZ\u00a8;\n  FILE *fl;\n  if (strcmp(fn->name, \"-\") == 0) fl = stdin; else\n    {\n    fl = fopen(fn->name, \"r\");\n    if (fl == NULL)\n      {\n      fprintf(stderr, \"pcre2grep: Failed to open %s: %s\\n\", fn->name,\n        strerror(errno));\n      goto EXIT2;\n      }\n    }\n  while (fgets(buffer, sizeof(buffer), fl) != NULL)\n    {\n    int frc;\n    char *end = buffer + (int)strlen(buffer);\n    while (end > buffer && isspace(end\u00dd-1\u00a8)) end--;\n    *end = 0;\n    if (*buffer != 0)\n      {\n      frc = grep_or_recurse(buffer, dee_action == dee_RECURSE, FALSE);\n      if (frc > 1) rc = frc;\n        else if (frc == 0 && rc == 1) rc = 0;\n      }\n    }\n  if (fl != stdin) fclose(fl);\n  }\n\n/* After handling file-list, work through remaining arguments. Pass in the fact\nthat there is only one argument at top level - this suppresses the file name if\nthe argument is not a directory and filenames are not otherwise forced. */\n\nonly_one_at_top = i == argc - 1 && file_lists == NULL;\n\nfor (; i < argc; i++)\n  {\n  int frc = grep_or_recurse(argv\u00ddi\u00a8, dee_action == dee_RECURSE,\n    only_one_at_top);\n  if (frc > 1) rc = frc;\n    else if (frc == 0 && rc == 1) rc = 0;\n  }\n\n#ifdef SUPPORT_PCRE2GREP_CALLOUT\n/* If separating builtin echo callouts by implicit newline, add one more for\nthe final item. */\n\nif (om_separator != NULL && strcmp(om_separator, STDOUT_NL) == 0)\n  fprintf(stdout, STDOUT_NL);\n#endif\n\n/* Show the total number of matches if requested, but not if only one file's\ncount was printed. */\n\nif (show_total_count && counts_printed != 1 && filenames != FN_NOMATCH_ONLY)\n  {\n  if (counts_printed != 0 && filenames >= FN_DEFAULT)\n    fprintf(stdout, \"TOTAL:\");\n  fprintf(stdout, \"%lu\" STDOUT_NL, total_count);\n  }\n\nEXIT:\n#ifdef SUPPORT_PCRE2GREP_JIT\npcre2_jit_free_unused_memory(NULL);\nif (jit_stack != NULL) pcre2_jit_stack_free(jit_stack);\n#endif\n\nfree(main_buffer);\nif (character_tables != NULL) pcre2_maketables_free(NULL, character_tables);\n\npcre2_compile_context_free(compile_context);\npcre2_match_context_free(match_context);\npcre2_match_data_free(match_data);\n\nfree_pattern_chain(patterns);\nfree_pattern_chain(include_patterns);\nfree_pattern_chain(include_dir_patterns);\nfree_pattern_chain(exclude_patterns);\nfree_pattern_chain(exclude_dir_patterns);\n\nfree_file_chain(exclude_from);\nfree_file_chain(include_from);\nfree_file_chain(pattern_files);\nfree_file_chain(file_lists);\n\nwhile (only_matching != NULL)\n  {\n  omstr *this = only_matching;\n  only_matching = this->next;\n  free(this);\n  }\n\npcre2grep_exit(rc);\n\nEXIT2:\nrc = 2;\ngoto EXIT;\n}\n\n/* End of pcre2grep */\n/*autoconv-0001 C:\\projects\\pcre2-10.35\\src\\pcre2grep.c converted to PCR2GREP*/\n/*autoconv-0011 PCR2GREP line: 48 config.h replaced by CONFIG.h*/\n/*autoconv-0011 PCR2GREP line: 103 pcre2.h replaced by PCRE2.h*/\n/*autoconv-0015 PCR2GREP line: 3217 fopen \"rb\" replaced by \"r\"*/\n/*autoconv-0015 PCR2GREP line: 3388 fopen \"rb\" replaced by \"r\"*/\n/*autoconv-0015 PCR2GREP line: 4388 fopen \"rb\" replaced by \"r\"*/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PCR2TEST": {"ttr": 12801, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "\n/*************************************************\n*             PCRE2 testing program              *\n*************************************************/\n\n/* PCRE2 is a library of functions to support regular expressions whose syntax\nand semantics are as close as possible to those of the Perl 5 language. In 2014\nthe API was completely revised and '2' was added to the name, because the old\nAPI, which had lasted for 16 years, could not accommodate new requirements. At\nthe same time, this testing program was re-designed because its original\nhacked-up (non-) design had also run out of steam.\n\n                       Written by Philip Hazel\n     Original code Copyright (c) 1997-2012 University of Cambridge\n    Rewritten code Copyright (c) 2016-2020 University of Cambridge\n\n-----------------------------------------------------------------------------\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n\n    * Redistributions of source code must retain the above copyright notice,\n      this list of conditions and the following disclaimer.\n\n    * Redistributions in binary form must reproduce the above copyright\n      notice, this list of conditions and the following disclaimer in the\n      documentation and/or other materials provided with the distribution.\n\n    * Neither the name of the University of Cambridge nor the names of its\n      contributors may be used to endorse or promote products derived from\n      this software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\nAND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\nIMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\nARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\nLIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\nCONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\nSUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\nINTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\nCONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\nARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\nPOSSIBILITY OF SUCH DAMAGE.\n-----------------------------------------------------------------------------\n*/\n\n\n/* This program supports testing of the 8-bit, 16-bit, and 32-bit PCRE2\nlibraries in a single program, though its input and output are always 8-bit.\nIt is different from modules such as pcre2_compile.c in the library itself,\nwhich are compiled separately for each code unit width. If two widths are\nenabled, for example, pcre2_compile.c is compiled twice. In contrast,\npcre2test.c is compiled only once, and linked with all the enabled libraries.\nTherefore, it must not make use of any of the macros from pcre2.h or\npcre2_internal.h that depend on PCRE2_CODE_UNIT_WIDTH. It does, however, make\nuse of SUPPORT_PCRE2_8, SUPPORT_PCRE2_16, and SUPPORT_PCRE2_32, to ensure that\nit references only the enabled library functions. */\n\n#ifdef HAVE_CONFIG_H\n#include \"CONFIG.h\"\n#endif\n\n#include <ctype.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <time.h>\n#include <locale.h>\n#include <errno.h>\n\n#if defined NATIVE_ZOS\n#include \"pcrzoscs.h\"\n/* That header is not included in the main PCRE2 distribution because other\napparatus is needed to compile pcre2test for z/OS. The header can be found in\nthe special z/OS distribution, which is available from www.zaconsultants.net or\nfrom www.cbttape.org. */\n#endif\n\n#ifdef HAVE_UNISTD_H\n#include <unistd.h>\n#endif\n\n/* Debugging code enabler */\n\n/* #define DEBUG_SHOW_MALLOC_ADDRESSES */\n\n/* Both libreadline and libedit are optionally supported. The user-supplied\noriginal patch uses readline/readline.h for libedit, but in at least one system\nit is installed as editline/readline.h, so the configuration code now looks for\nthat first, falling back to readline/readline.h. */\n\n#if defined(SUPPORT_LIBREADLINE) || defined(SUPPORT_LIBEDIT)\n#if defined(SUPPORT_LIBREADLINE)\n#include <readline/readline.h>\n#include <readline/history.h>\n#else\n#if defined(HAVE_EDITLINE_READLINE_H)\n#include <editline/readline.h>\n#else\n#include <readline/readline.h>\n#endif\n#endif\n#endif\n\n/* Put the test for interactive input into a macro so that it can be changed if\nrequired for different environments. */\n\n#define INTERACTIVE(f) isatty(fileno(f))\n\n\n/* ---------------------- System-specific definitions ---------------------- */\n\n/* A number of things vary for Windows builds. Originally, pcretest opened its\ninput and output without \"b\"; then I was told that \"b\" was needed in some\nenvironments, so it was added for release 5.0 to both the input and output. (It\nmakes no difference on Unix-like systems.) Later I was told that it is wrong\nfor the input on Windows. I've now abstracted the modes into macros that are\nset here, to make it easier to fiddle with them, and removed \"b\" from the input\nmode under Windows. The BINARY versions are used when saving/restoring compiled\npatterns. */\n\n#if defined(_WIN32) || defined(WIN32)\n#include <io.h>                /* For _setmode() */\n#include <fcntl.h>             /* For _O_BINARY */\n#define INPUT_MODE          \"r\"\n#define OUTPUT_MODE         \"wb\"\n#define BINARY_INPUT_MODE   \"rb\"\n#define BINARY_OUTPUT_MODE  \"wb\"\n\n#ifndef isatty\n#define isatty _isatty         /* This is what Windows calls them, I'm told, */\n#endif                         /* though in some environments they seem to   */\n                               /* be already defined, hence the #ifndefs.    */\n#ifndef fileno\n#define fileno _fileno\n#endif\n\n/* A user sent this fix for Borland Builder 5 under Windows. */\n\n#ifdef __BORLANDC__\n#define _setmode(handle, mode) setmode(handle, mode)\n#endif\n\n/* Not Windows */\n\n#else\n#include <sys/time.h>          /* These two includes are needed */\n#include <sys/resource.h>      /* for setrlimit(). */\n#if defined NATIVE_ZOS         /* z/OS uses non-binary I/O */\n#define INPUT_MODE   \"r\"\n#define OUTPUT_MODE  \"w\"\n#define BINARY_INPUT_MODE   \"rb\"\n#define BINARY_OUTPUT_MODE  \"wb\"\n#else\n#define INPUT_MODE          \"rb\"\n#define OUTPUT_MODE         \"wb\"\n#define BINARY_INPUT_MODE   \"rb\"\n#define BINARY_OUTPUT_MODE  \"wb\"\n#endif\n#endif\n\n/* VMS-specific code was included as suggested by a VMS user \u00dd1\u00a8. Another VMS\nuser \u00dd2\u00a8 provided alternative code which worked better for him. I have\ncommented out the original, but kept it around just in case. */\n\n#ifdef __VMS\n#include <ssdef.h>\n/* These two includes came from \u00dd2\u00a8. */\n#include descrip\n#include lib$routines\n/* void vms_setsymbol( char *, char *, int ); Original code from \u00dd1\u00a8. */\n#endif\n\n/* VC and older compilers don't support %td or %zu, and even some that claim to\nbe C99 don't support it (hence DISABLE_PERCENT_ZT). There are some non-C99\nenvironments where %lu gives a warning with 32-bit pointers. As there doesn't\nseem to be an easy way round this, just live with it (the cases are rare). */\n\n#if defined(_MSC_VER) || !defined(__STDC_VERSION__) || __STDC_VERSION__ < 199901L || defined(DISABLE_PERCENT_ZT)\n#define PTR_FORM \"lu\"\n#define SIZ_FORM \"lu\"\n#define SIZ_CAST (unsigned long int)\n#else\n#define PTR_FORM \"td\"\n#define SIZ_FORM \"zu\"\n#define SIZ_CAST\n#endif\n\n/* ------------------End of system-specific definitions -------------------- */\n\n/* Glueing macros that are used in several places below. */\n\n#define glue(a,b) a##b\n#define G(a,b) glue(a,b)\n\n/* Miscellaneous parameters and manifests */\n\n#ifndef CLOCKS_PER_SEC\n#ifdef CLK_TCK\n#define CLOCKS_PER_SEC CLK_TCK\n#else\n#define CLOCKS_PER_SEC 100\n#endif\n#endif\n\n#define CFORE_UNSET UINT32_MAX    /* Unset value for startend/cfail/cerror fields */\n#define CONVERT_UNSET UINT32_MAX  /* Unset value for convert_type field */\n#define DFA_WS_DIMENSION 1000     /* Size of DFA workspace */\n#define DEFAULT_OVECCOUNT 15      /* Default ovector count */\n#define JUNK_OFFSET 0xdeadbeef    /* For initializing ovector */\n#define LOCALESIZE 32             /* Size of locale name */\n#define LOOPREPEAT 500000         /* Default loop count for timing */\n#define MALLOCLISTSIZE 20         /* For remembering mallocs */\n#define PARENS_NEST_DEFAULT 220   /* Default parentheses nest limit */\n#define PATSTACKSIZE 20           /* Pattern stack for save/restore testing */\n#define REPLACE_MODSIZE 100       /* Field for reading 8-bit replacement */\n#define VERSION_SIZE 64           /* Size of buffer for the version strings */\n\n/* Default JIT compile options */\n\n#define JIT_DEFAULT (PCRE2_JIT_COMPLETE|\\\n                     PCRE2_JIT_PARTIAL_SOFT|\\\n                     PCRE2_JIT_PARTIAL_HARD)\n\n/* Make sure the buffer into which replacement strings are copied is big enough\nto hold them as 32-bit code units. */\n\n#define REPLACE_BUFFSIZE 1024   /* This is a byte value */\n\n/* Execution modes */\n\n#define PCRE8_MODE   8\n#define PCRE16_MODE 16\n#define PCRE32_MODE 32\n\n/* Processing returns */\n\nenum { PR_OK, PR_SKIP, PR_ABEND };\n\n/* The macro PRINTABLE determines whether to print an output character as-is or\nas a hex value when showing compiled patterns. is We use it in cases when the\nlocale has not been explicitly changed, so as to get consistent output from\nsystems that differ in their output from isprint() even in the \"C\" locale. */\n\n#ifdef EBCDIC\n#define PRINTABLE(c) ((c) >= 64 && (c) < 255)\n#else\n#define PRINTABLE(c) ((c) >= 32 && (c) < 127)\n#endif\n\n#define PRINTOK(c) ((use_tables != NULL && c < 256)? isprint(c) : PRINTABLE(c))\n\n/* We have to include some of the library source files because we need\nto use some of the macros, internal structure definitions, and other internal\nvalues - pcre2test has \"inside information\" compared to an application program\nthat strictly follows the PCRE2 API.\n\nBefore including pcre2_internal.h we define PRIV so that it does not get\ndefined therein. This ensures that PRIV names in the included files do not\nclash with those in the libraries. Also, although pcre2_internal.h does itself\ninclude pcre2.h, we explicitly include it beforehand, along with pcre2posix.h,\nso that the PCRE2_EXP_xxx macros get set appropriately for an application, not\nfor building the library. */\n\n#define PRIV(name) name\n#define PCRE2_CODE_UNIT_WIDTH 0\n#include \"PCRE2.h\"\n#include \"POSIXH.h\"\n#include \"INTERNA2.h\"\n\n/* We need access to some of the data tables that PCRE2 uses. Defining\nPCRE2_PCRETEST makes some minor changes in the files. The previous definition\nof PRIV avoids name clashes. */\n\n#define PCRE2_PCRE2TEST\n#include \"TABLES2.c\"\n#include \"UCD2.c\"\n\n/* 32-bit integer values in the input are read by strtoul() or strtol(). The\ncheck needed for overflow depends on whether long ints are in fact longer than\nints. They are defined not to be shorter. */\n\n#if ULONG_MAX > UINT32_MAX\n#define U32OVERFLOW(x) (x > UINT32_MAX)\n#else\n#define U32OVERFLOW(x) (x == UINT32_MAX)\n#endif\n\n#if LONG_MAX > INT32_MAX\n#define S32OVERFLOW(x) (x > INT32_MAX || x < INT32_MIN)\n#else\n#define S32OVERFLOW(x) (x == INT32_MAX || x == INT32_MIN)\n#endif\n\n/* When PCRE2_CODE_UNIT_WIDTH is zero, pcre2_internal.h does not include\npcre2_intmodedep.h, which is where mode-dependent macros and structures are\ndefined. We can now include it for each supported code unit width. Because\nPCRE2_CODE_UNIT_WIDTH was defined as zero before including pcre2.h, it will\nhave left PCRE2_SUFFIX defined as a no-op. We must re-define it appropriately\nwhile including these files, and then restore it to a no-op. Because LINK_SIZE\nmay be changed in 16-bit mode and forced to 1 in 32-bit mode, the order of\nthese inclusions should not be changed. */\n\n#undef PCRE2_SUFFIX\n#undef PCRE2_CODE_UNIT_WIDTH\n\n#ifdef   SUPPORT_PCRE2_8\n#define  PCRE2_CODE_UNIT_WIDTH 8\n#define  PCRE2_SUFFIX(a) G(a,8)\n#include \"INTMODE2.h\"\n#include \"PRINTIN2.c\"\n#undef   PCRE2_CODE_UNIT_WIDTH\n#undef   PCRE2_SUFFIX\n#endif   /* SUPPORT_PCRE2_8 */\n\n#ifdef   SUPPORT_PCRE2_16\n#define  PCRE2_CODE_UNIT_WIDTH 16\n#define  PCRE2_SUFFIX(a) G(a,16)\n#include \"INTMODE2.h\"\n#include \"PRINTIN2.c\"\n#undef   PCRE2_CODE_UNIT_WIDTH\n#undef   PCRE2_SUFFIX\n#endif   /* SUPPORT_PCRE2_16 */\n\n#ifdef   SUPPORT_PCRE2_32\n#define  PCRE2_CODE_UNIT_WIDTH 32\n#define  PCRE2_SUFFIX(a) G(a,32)\n#include \"INTMODE2.h\"\n#include \"PRINTIN2.c\"\n#undef   PCRE2_CODE_UNIT_WIDTH\n#undef   PCRE2_SUFFIX\n#endif   /* SUPPORT_PCRE2_32 */\n\n#define PCRE2_SUFFIX(a) a\n\n/* We need to be able to check input text for UTF-8 validity, whatever code\nwidths are actually available, because the input to pcre2test is always in\n8-bit code units. So we include the UTF validity checking function for 8-bit\ncode units. */\n\nextern int valid_utf(PCRE2_SPTR8, PCRE2_SIZE, PCRE2_SIZE *);\n\n#define  PCRE2_CODE_UNIT_WIDTH 8\n#undef   PCRE2_SPTR\n#define  PCRE2_SPTR PCRE2_SPTR8\n#include \"VALIDUT2.c\"\n#undef   PCRE2_CODE_UNIT_WIDTH\n#undef   PCRE2_SPTR\n\n/* If we have 8-bit support, default to it; if there is also 16-or 32-bit\nsupport, it can be selected by a command-line option. If there is no 8-bit\nsupport, there must be 16-bit or 32-bit support, so default to one of them. The\nconfig function, JIT stack, contexts, and version string are the same in all\nmodes, so use the form of the first that is available. */\n\n#if defined SUPPORT_PCRE2_8\n#define DEFAULT_TEST_MODE PCRE8_MODE\n#define VERSION_TYPE PCRE2_UCHAR8\n#define PCRE2_CONFIG pcre2_config_8\n#define PCRE2_JIT_STACK pcre2_jit_stack_8\n#define PCRE2_REAL_GENERAL_CONTEXT pcre2_real_general_context_8\n#define PCRE2_REAL_COMPILE_CONTEXT pcre2_real_compile_context_8\n#define PCRE2_REAL_CONVERT_CONTEXT pcre2_real_convert_context_8\n#define PCRE2_REAL_MATCH_CONTEXT pcre2_real_match_context_8\n\n#elif defined SUPPORT_PCRE2_16\n#define DEFAULT_TEST_MODE PCRE16_MODE\n#define VERSION_TYPE PCRE2_UCHAR16\n#define PCRE2_CONFIG pcre2_config_16\n#define PCRE2_JIT_STACK pcre2_jit_stack_16\n#define PCRE2_REAL_GENERAL_CONTEXT pcre2_real_general_context_16\n#define PCRE2_REAL_COMPILE_CONTEXT pcre2_real_compile_context_16\n#define PCRE2_REAL_CONVERT_CONTEXT pcre2_real_convert_context_16\n#define PCRE2_REAL_MATCH_CONTEXT pcre2_real_match_context_16\n\n#elif defined SUPPORT_PCRE2_32\n#define DEFAULT_TEST_MODE PCRE32_MODE\n#define VERSION_TYPE PCRE2_UCHAR32\n#define PCRE2_CONFIG pcre2_config_32\n#define PCRE2_JIT_STACK pcre2_jit_stack_32\n#define PCRE2_REAL_GENERAL_CONTEXT pcre2_real_general_context_32\n#define PCRE2_REAL_COMPILE_CONTEXT pcre2_real_compile_context_32\n#define PCRE2_REAL_CONVERT_CONTEXT pcre2_real_convert_context_32\n#define PCRE2_REAL_MATCH_CONTEXT pcre2_real_match_context_32\n#endif\n\n/* ------------- Structure and table for handling #-commands ------------- */\n\ntypedef struct cmdstruct {\n  const char *name;\n  int  value;\n} cmdstruct;\n\nenum { CMD_FORBID_UTF, CMD_LOAD, CMD_LOADTABLES, CMD_NEWLINE_DEFAULT,\n  CMD_PATTERN, CMD_PERLTEST, CMD_POP, CMD_POPCOPY, CMD_SAVE, CMD_SUBJECT,\n  CMD_UNKNOWN };\n\nstatic cmdstruct cmdlist\u00dd\u00a8 = {\n  { \"forbid_utf\",      CMD_FORBID_UTF },\n  { \"load\",            CMD_LOAD },\n  { \"loadtables\",      CMD_LOADTABLES },\n  { \"newline_default\", CMD_NEWLINE_DEFAULT },\n  { \"pattern\",         CMD_PATTERN },\n  { \"perltest\",        CMD_PERLTEST },\n  { \"pop\",             CMD_POP },\n  { \"popcopy\",         CMD_POPCOPY },\n  { \"save\",            CMD_SAVE },\n  { \"subject\",         CMD_SUBJECT }};\n\n#define cmdlistcount (sizeof(cmdlist)/sizeof(cmdstruct))\n\n/* ------------- Structures and tables for handling modifiers -------------- */\n\n/* Table of names for newline types. Must be kept in step with the definitions\nof PCRE2_NEWLINE_xx in pcre2.h. */\n\nstatic const char *newlines\u00dd\u00a8 = {\n  \"DEFAULT\", \"CR\", \"LF\", \"CRLF\", \"ANY\", \"ANYCRLF\", \"NUL\" };\n\n/* Structure and table for handling pattern conversion types. */\n\ntypedef struct convertstruct {\n  const char *name;\n  uint32_t option;\n} convertstruct;\n\nstatic convertstruct convertlist\u00dd\u00a8 = {\n  { \"glob\",                   PCRE2_CONVERT_GLOB },\n  { \"glob_no_starstar\",       PCRE2_CONVERT_GLOB_NO_STARSTAR },\n  { \"glob_no_wild_separator\", PCRE2_CONVERT_GLOB_NO_WILD_SEPARATOR },\n  { \"posix_basic\",            PCRE2_CONVERT_POSIX_BASIC },\n  { \"posix_extended\",         PCRE2_CONVERT_POSIX_EXTENDED },\n  { \"unset\",                  CONVERT_UNSET }};\n\n#define convertlistcount (sizeof(convertlist)/sizeof(convertstruct))\n\n/* Modifier types and applicability */\n\nenum { MOD_CTC,    /* Applies to a compile context */\n       MOD_CTM,    /* Applies to a match context */\n       MOD_PAT,    /* Applies to a pattern */\n       MOD_PATP,   /* Ditto, OK for Perl test */\n       MOD_DAT,    /* Applies to a data line */\n       MOD_PD,     /* Applies to a pattern or a data line */\n       MOD_PDP,    /* As MOD_PD, OK for Perl test */\n       MOD_PND,    /* As MOD_PD, but not for a default pattern */\n       MOD_PNDP,   /* As MOD_PND, OK for Perl test */\n       MOD_CHR,    /* Is a single character */\n       MOD_CON,    /* Is a \"convert\" type/options list */\n       MOD_CTL,    /* Is a control bit */\n       MOD_BSR,    /* Is a BSR value */\n       MOD_IN2,    /* Is one or two unsigned integers */\n       MOD_INS,    /* Is a signed integer */\n       MOD_INT,    /* Is an unsigned integer */\n       MOD_IND,    /* Is an unsigned integer, but no value => default */\n       MOD_NL,     /* Is a newline value */\n       MOD_NN,     /* Is a number or a name; more than one may occur */\n       MOD_OPT,    /* Is an option bit */\n       MOD_SIZ,    /* Is a PCRE2_SIZE value */\n       MOD_STR };  /* Is a string */\n\n/* Control bits. Some apply to compiling, some to matching, but some can be set\neither on a pattern or a data line, so they must all be distinct. There are now\nso many of them that they are split into two fields. */\n\n#define CTL_AFTERTEXT                    0x00000001u\n#define CTL_ALLAFTERTEXT                 0x00000002u\n#define CTL_ALLCAPTURES                  0x00000004u\n#define CTL_ALLUSEDTEXT                  0x00000008u\n#define CTL_ALTGLOBAL                    0x00000010u\n#define CTL_BINCODE                      0x00000020u\n#define CTL_CALLOUT_CAPTURE              0x00000040u\n#define CTL_CALLOUT_INFO                 0x00000080u\n#define CTL_CALLOUT_NONE                 0x00000100u\n#define CTL_DFA                          0x00000200u\n#define CTL_EXPAND                       0x00000400u\n#define CTL_FINDLIMITS                   0x00000800u\n#define CTL_FRAMESIZE                    0x00001000u\n#define CTL_FULLBINCODE                  0x00002000u\n#define CTL_GETALL                       0x00004000u\n#define CTL_GLOBAL                       0x00008000u\n#define CTL_HEXPAT                       0x00010000u  /* Same word as USE_LENGTH */\n#define CTL_INFO                         0x00020000u\n#define CTL_JITFAST                      0x00040000u\n#define CTL_JITVERIFY                    0x00080000u\n#define CTL_MARK                         0x00100000u\n#define CTL_MEMORY                       0x00200000u\n#define CTL_NULLCONTEXT                  0x00400000u\n#define CTL_POSIX                        0x00800000u\n#define CTL_POSIX_NOSUB                  0x01000000u\n#define CTL_PUSH                         0x02000000u  /* These three must be */\n#define CTL_PUSHCOPY                     0x04000000u  /*   all in the same */\n#define CTL_PUSHTABLESCOPY               0x08000000u  /*     word. */\n#define CTL_STARTCHAR                    0x10000000u\n#define CTL_USE_LENGTH                   0x20000000u  /* Same word as HEXPAT */\n#define CTL_UTF8_INPUT                   0x40000000u\n#define CTL_ZERO_TERMINATE               0x80000000u\n\n/* Combinations */\n\n#define CTL_DEBUG            (CTL_FULLBINCODE|CTL_INFO)  /* For setting */\n#define CTL_ANYINFO          (CTL_DEBUG|CTL_BINCODE|CTL_CALLOUT_INFO)\n#define CTL_ANYGLOB          (CTL_ALTGLOBAL|CTL_GLOBAL)\n\n/* Second control word */\n\n#define CTL2_SUBSTITUTE_CALLOUT          0x00000001u\n#define CTL2_SUBSTITUTE_EXTENDED         0x00000002u\n#define CTL2_SUBSTITUTE_LITERAL          0x00000004u\n#define CTL2_SUBSTITUTE_MATCHED          0x00000008u\n#define CTL2_SUBSTITUTE_OVERFLOW_LENGTH  0x00000010u\n#define CTL2_SUBSTITUTE_REPLACEMENT_ONLY 0x00000020u\n#define CTL2_SUBSTITUTE_UNKNOWN_UNSET    0x00000040u\n#define CTL2_SUBSTITUTE_UNSET_EMPTY      0x00000080u\n#define CTL2_SUBJECT_LITERAL             0x00000100u\n#define CTL2_CALLOUT_NO_WHERE            0x00000200u\n#define CTL2_CALLOUT_EXTRA               0x00000400u\n#define CTL2_ALLVECTOR                   0x00000800u\n\n#define CTL2_NL_SET                      0x40000000u  /* Informational */\n#define CTL2_BSR_SET                     0x80000000u  /* Informational */\n\n/* These are the matching controls that may be set either on a pattern or on a\ndata line. They are copied from the pattern controls as initial settings for\ndata line controls. Note that CTL_MEMORY is not included here, because it does\ndifferent things in the two cases. */\n\n#define CTL_ALLPD  (CTL_AFTERTEXT|\\\n                    CTL_ALLAFTERTEXT|\\\n                    CTL_ALLCAPTURES|\\\n                    CTL_ALLUSEDTEXT|\\\n                    CTL_ALTGLOBAL|\\\n                    CTL_GLOBAL|\\\n                    CTL_MARK|\\\n                    CTL_STARTCHAR|\\\n                    CTL_UTF8_INPUT)\n\n#define CTL2_ALLPD (CTL2_SUBSTITUTE_CALLOUT|\\\n                    CTL2_SUBSTITUTE_EXTENDED|\\\n                    CTL2_SUBSTITUTE_LITERAL|\\\n                    CTL2_SUBSTITUTE_MATCHED|\\\n                    CTL2_SUBSTITUTE_OVERFLOW_LENGTH|\\\n                    CTL2_SUBSTITUTE_REPLACEMENT_ONLY|\\\n                    CTL2_SUBSTITUTE_UNKNOWN_UNSET|\\\n                    CTL2_SUBSTITUTE_UNSET_EMPTY|\\\n                    CTL2_ALLVECTOR)\n\n/* Structures for holding modifier information for patterns and subject strings\n(data). Fields containing modifiers that can be set either for a pattern or a\nsubject must be at the start and in the same order in both cases so that the\nsame offset in the big table below works for both. */\n\ntypedef struct patctl {       /* Structure for pattern modifiers. */\n  uint32_t  options;          /* Must be in same position as datctl */\n  uint32_t  control;          /* Must be in same position as datctl */\n  uint32_t  control2;         /* Must be in same position as datctl */\n  uint32_t  jitstack;         /* Must be in same position as datctl */\n   uint8_t  replacement\u00ddREPLACE_MODSIZE\u00a8;  /* So must this */\n  uint32_t  substitute_skip;  /* Must be in same position as patctl */\n  uint32_t  substitute_stop;  /* Must be in same position as patctl */\n  uint32_t  jit;\n  uint32_t  stackguard_test;\n  uint32_t  tables_id;\n  uint32_t  convert_type;\n  uint32_t  convert_length;\n  uint32_t  convert_glob_escape;\n  uint32_t  convert_glob_separator;\n  uint32_t  regerror_buffsize;\n   uint8_t  locale\u00ddLOCALESIZE\u00a8;\n} patctl;\n\n#define MAXCPYGET 10\n#define LENCPYGET 64\n\ntypedef struct datctl {       /* Structure for data line modifiers. */\n  uint32_t  options;          /* Must be in same position as patctl */\n  uint32_t  control;          /* Must be in same position as patctl */\n  uint32_t  control2;         /* Must be in same position as patctl */\n  uint32_t  jitstack;         /* Must be in same position as patctl */\n   uint8_t  replacement\u00ddREPLACE_MODSIZE\u00a8;  /* So must this */\n  uint32_t  substitute_skip;  /* Must be in same position as patctl */\n  uint32_t  substitute_stop;  /* Must be in same position as patctl */\n  uint32_t  startend\u00dd2\u00a8;\n  uint32_t  cerror\u00dd2\u00a8;\n  uint32_t  cfail\u00dd2\u00a8;\n   int32_t  callout_data;\n   int32_t  copy_numbers\u00ddMAXCPYGET\u00a8;\n   int32_t  get_numbers\u00ddMAXCPYGET\u00a8;\n  uint32_t  oveccount;\n  uint32_t  offset;\n  uint8_t   copy_names\u00ddLENCPYGET\u00a8;\n  uint8_t   get_names\u00ddLENCPYGET\u00a8;\n} datctl;\n\n/* Ids for which context to modify. */\n\nenum { CTX_PAT,            /* Active pattern context */\n       CTX_POPPAT,         /* Ditto, for a popped pattern */\n       CTX_DEFPAT,         /* Default pattern context */\n       CTX_DAT,            /* Active data (match) context */\n       CTX_DEFDAT };       /* Default data (match) context */\n\n/* Macros to simplify the big table below. */\n\n#define CO(name) offsetof(PCRE2_REAL_COMPILE_CONTEXT, name)\n#define MO(name) offsetof(PCRE2_REAL_MATCH_CONTEXT, name)\n#define PO(name) offsetof(patctl, name)\n#define PD(name) PO(name)\n#define DO(name) offsetof(datctl, name)\n\n/* Table of all long-form modifiers. Must be in collating sequence of modifier\nname because it is searched by binary chop. */\n\ntypedef struct modstruct {\n  const char   *name;\n  uint16_t      which;\n  uint16_t      type;\n  uint32_t      value;\n  PCRE2_SIZE    offset;\n} modstruct;\n\nstatic modstruct modlist\u00dd\u00a8 = {\n  { \"aftertext\",                   MOD_PNDP, MOD_CTL, CTL_AFTERTEXT,              PO(control) },\n  { \"allaftertext\",                MOD_PNDP, MOD_CTL, CTL_ALLAFTERTEXT,           PO(control) },\n  { \"allcaptures\",                 MOD_PND,  MOD_CTL, CTL_ALLCAPTURES,            PO(control) },\n  { \"allow_empty_class\",           MOD_PAT,  MOD_OPT, PCRE2_ALLOW_EMPTY_CLASS,    PO(options) },\n  { \"allow_surrogate_escapes\",     MOD_CTC,  MOD_OPT, PCRE2_EXTRA_ALLOW_SURROGATE_ESCAPES, CO(extra_options) },\n  { \"allusedtext\",                 MOD_PNDP, MOD_CTL, CTL_ALLUSEDTEXT,            PO(control) },\n  { \"allvector\",                   MOD_PND,  MOD_CTL, CTL2_ALLVECTOR,             PO(control2) },\n  { \"alt_bsux\",                    MOD_PAT,  MOD_OPT, PCRE2_ALT_BSUX,             PO(options) },\n  { \"alt_circumflex\",              MOD_PAT,  MOD_OPT, PCRE2_ALT_CIRCUMFLEX,       PO(options) },\n  { \"alt_verbnames\",               MOD_PAT,  MOD_OPT, PCRE2_ALT_VERBNAMES,        PO(options) },\n  { \"altglobal\",                   MOD_PND,  MOD_CTL, CTL_ALTGLOBAL,              PO(control) },\n  { \"anchored\",                    MOD_PD,   MOD_OPT, PCRE2_ANCHORED,             PD(options) },\n  { \"auto_callout\",                MOD_PAT,  MOD_OPT, PCRE2_AUTO_CALLOUT,         PO(options) },\n  { \"bad_escape_is_literal\",       MOD_CTC,  MOD_OPT, PCRE2_EXTRA_BAD_ESCAPE_IS_LITERAL, CO(extra_options) },\n  { \"bincode\",                     MOD_PAT,  MOD_CTL, CTL_BINCODE,                PO(control) },\n  { \"bsr\",                         MOD_CTC,  MOD_BSR, 0,                          CO(bsr_convention) },\n  { \"callout_capture\",             MOD_DAT,  MOD_CTL, CTL_CALLOUT_CAPTURE,        DO(control) },\n  { \"callout_data\",                MOD_DAT,  MOD_INS, 0,                          DO(callout_data) },\n  { \"callout_error\",               MOD_DAT,  MOD_IN2, 0,                          DO(cerror) },\n  { \"callout_extra\",               MOD_DAT,  MOD_CTL, CTL2_CALLOUT_EXTRA,         DO(control2) },\n  { \"callout_fail\",                MOD_DAT,  MOD_IN2, 0,                          DO(cfail) },\n  { \"callout_info\",                MOD_PAT,  MOD_CTL, CTL_CALLOUT_INFO,           PO(control) },\n  { \"callout_no_where\",            MOD_DAT,  MOD_CTL, CTL2_CALLOUT_NO_WHERE,      DO(control2) },\n  { \"callout_none\",                MOD_DAT,  MOD_CTL, CTL_CALLOUT_NONE,           DO(control) },\n  { \"caseless\",                    MOD_PATP, MOD_OPT, PCRE2_CASELESS,             PO(options) },\n  { \"convert\",                     MOD_PAT,  MOD_CON, 0,                          PO(convert_type) },\n  { \"convert_glob_escape\",         MOD_PAT,  MOD_CHR, 0,                          PO(convert_glob_escape) },\n  { \"convert_glob_separator\",      MOD_PAT,  MOD_CHR, 0,                          PO(convert_glob_separator) },\n  { \"convert_length\",              MOD_PAT,  MOD_INT, 0,                          PO(convert_length) },\n  { \"copy\",                        MOD_DAT,  MOD_NN,  DO(copy_numbers),           DO(copy_names) },\n  { \"copy_matched_subject\",        MOD_DAT,  MOD_OPT, PCRE2_COPY_MATCHED_SUBJECT, DO(options) },\n  { \"debug\",                       MOD_PAT,  MOD_CTL, CTL_DEBUG,                  PO(control) },\n  { \"depth_limit\",                 MOD_CTM,  MOD_INT, 0,                          MO(depth_limit) },\n  { \"dfa\",                         MOD_DAT,  MOD_CTL, CTL_DFA,                    DO(control) },\n  { \"dfa_restart\",                 MOD_DAT,  MOD_OPT, PCRE2_DFA_RESTART,          DO(options) },\n  { \"dfa_shortest\",                MOD_DAT,  MOD_OPT, PCRE2_DFA_SHORTEST,         DO(options) },\n  { \"dollar_endonly\",              MOD_PAT,  MOD_OPT, PCRE2_DOLLAR_ENDONLY,       PO(options) },\n  { \"dotall\",                      MOD_PATP, MOD_OPT, PCRE2_DOTALL,               PO(options) },\n  { \"dupnames\",                    MOD_PATP, MOD_OPT, PCRE2_DUPNAMES,             PO(options) },\n  { \"endanchored\",                 MOD_PD,   MOD_OPT, PCRE2_ENDANCHORED,          PD(options) },\n  { \"escaped_cr_is_lf\",            MOD_CTC,  MOD_OPT, PCRE2_EXTRA_ESCAPED_CR_IS_LF, CO(extra_options) },\n  { \"expand\",                      MOD_PAT,  MOD_CTL, CTL_EXPAND,                 PO(control) },\n  { \"extended\",                    MOD_PATP, MOD_OPT, PCRE2_EXTENDED,             PO(options) },\n  { \"extended_more\",               MOD_PATP, MOD_OPT, PCRE2_EXTENDED_MORE,        PO(options) },\n  { \"extra_alt_bsux\",              MOD_CTC,  MOD_OPT, PCRE2_EXTRA_ALT_BSUX,       CO(extra_options) },\n  { \"find_limits\",                 MOD_DAT,  MOD_CTL, CTL_FINDLIMITS,             DO(control) },\n  { \"firstline\",                   MOD_PAT,  MOD_OPT, PCRE2_FIRSTLINE,            PO(options) },\n  { \"framesize\",                   MOD_PAT,  MOD_CTL, CTL_FRAMESIZE,              PO(control) },\n  { \"fullbincode\",                 MOD_PAT,  MOD_CTL, CTL_FULLBINCODE,            PO(control) },\n  { \"get\",                         MOD_DAT,  MOD_NN,  DO(get_numbers),            DO(get_names) },\n  { \"getall\",                      MOD_DAT,  MOD_CTL, CTL_GETALL,                 DO(control) },\n  { \"global\",                      MOD_PNDP, MOD_CTL, CTL_GLOBAL,                 PO(control) },\n  { \"heap_limit\",                  MOD_CTM,  MOD_INT, 0,                          MO(heap_limit) },\n  { \"hex\",                         MOD_PAT,  MOD_CTL, CTL_HEXPAT,                 PO(control) },\n  { \"info\",                        MOD_PAT,  MOD_CTL, CTL_INFO,                   PO(control) },\n  { \"jit\",                         MOD_PAT,  MOD_IND, 7,                          PO(jit) },\n  { \"jitfast\",                     MOD_PAT,  MOD_CTL, CTL_JITFAST,                PO(control) },\n  { \"jitstack\",                    MOD_PNDP, MOD_INT, 0,                          PO(jitstack) },\n  { \"jitverify\",                   MOD_PAT,  MOD_CTL, CTL_JITVERIFY,              PO(control) },\n  { \"literal\",                     MOD_PAT,  MOD_OPT, PCRE2_LITERAL,              PO(options) },\n  { \"locale\",                      MOD_PAT,  MOD_STR, LOCALESIZE,                 PO(locale) },\n  { \"mark\",                        MOD_PNDP, MOD_CTL, CTL_MARK,                   PO(control) },\n  { \"match_invalid_utf\",           MOD_PAT,  MOD_OPT, PCRE2_MATCH_INVALID_UTF,    PO(options) },\n  { \"match_limit\",                 MOD_CTM,  MOD_INT, 0,                          MO(match_limit) },\n  { \"match_line\",                  MOD_CTC,  MOD_OPT, PCRE2_EXTRA_MATCH_LINE,     CO(extra_options) },\n  { \"match_unset_backref\",         MOD_PAT,  MOD_OPT, PCRE2_MATCH_UNSET_BACKREF,  PO(options) },\n  { \"match_word\",                  MOD_CTC,  MOD_OPT, PCRE2_EXTRA_MATCH_WORD,     CO(extra_options) },\n  { \"max_pattern_length\",          MOD_CTC,  MOD_SIZ, 0,                          CO(max_pattern_length) },\n  { \"memory\",                      MOD_PD,   MOD_CTL, CTL_MEMORY,                 PD(control) },\n  { \"multiline\",                   MOD_PATP, MOD_OPT, PCRE2_MULTILINE,            PO(options) },\n  { \"never_backslash_c\",           MOD_PAT,  MOD_OPT, PCRE2_NEVER_BACKSLASH_C,    PO(options) },\n  { \"never_ucp\",                   MOD_PAT,  MOD_OPT, PCRE2_NEVER_UCP,            PO(options) },\n  { \"never_utf\",                   MOD_PAT,  MOD_OPT, PCRE2_NEVER_UTF,            PO(options) },\n  { \"newline\",                     MOD_CTC,  MOD_NL,  0,                          CO(newline_convention) },\n  { \"no_auto_capture\",             MOD_PAT,  MOD_OPT, PCRE2_NO_AUTO_CAPTURE,      PO(options) },\n  { \"no_auto_possess\",             MOD_PATP, MOD_OPT, PCRE2_NO_AUTO_POSSESS,      PO(options) },\n  { \"no_dotstar_anchor\",           MOD_PAT,  MOD_OPT, PCRE2_NO_DOTSTAR_ANCHOR,    PO(options) },\n  { \"no_jit\",                      MOD_DAT,  MOD_OPT, PCRE2_NO_JIT,               DO(options) },\n  { \"no_start_optimize\",           MOD_PATP, MOD_OPT, PCRE2_NO_START_OPTIMIZE,    PO(options) },\n  { \"no_utf_check\",                MOD_PD,   MOD_OPT, PCRE2_NO_UTF_CHECK,         PD(options) },\n  { \"notbol\",                      MOD_DAT,  MOD_OPT, PCRE2_NOTBOL,               DO(options) },\n  { \"notempty\",                    MOD_DAT,  MOD_OPT, PCRE2_NOTEMPTY,             DO(options) },\n  { \"notempty_atstart\",            MOD_DAT,  MOD_OPT, PCRE2_NOTEMPTY_ATSTART,     DO(options) },\n  { \"noteol\",                      MOD_DAT,  MOD_OPT, PCRE2_NOTEOL,               DO(options) },\n  { \"null_context\",                MOD_PD,   MOD_CTL, CTL_NULLCONTEXT,            PO(control) },\n  { \"offset\",                      MOD_DAT,  MOD_INT, 0,                          DO(offset) },\n  { \"offset_limit\",                MOD_CTM,  MOD_SIZ, 0,                          MO(offset_limit)},\n  { \"ovector\",                     MOD_DAT,  MOD_INT, 0,                          DO(oveccount) },\n  { \"parens_nest_limit\",           MOD_CTC,  MOD_INT, 0,                          CO(parens_nest_limit) },\n  { \"partial_hard\",                MOD_DAT,  MOD_OPT, PCRE2_PARTIAL_HARD,         DO(options) },\n  { \"partial_soft\",                MOD_DAT,  MOD_OPT, PCRE2_PARTIAL_SOFT,         DO(options) },\n  { \"ph\",                          MOD_DAT,  MOD_OPT, PCRE2_PARTIAL_HARD,         DO(options) },\n  { \"posix\",                       MOD_PAT,  MOD_CTL, CTL_POSIX,                  PO(control) },\n  { \"posix_nosub\",                 MOD_PAT,  MOD_CTL, CTL_POSIX|CTL_POSIX_NOSUB,  PO(control) },\n  { \"posix_startend\",              MOD_DAT,  MOD_IN2, 0,                          DO(startend) },\n  { \"ps\",                          MOD_DAT,  MOD_OPT, PCRE2_PARTIAL_SOFT,         DO(options) },\n  { \"push\",                        MOD_PAT,  MOD_CTL, CTL_PUSH,                   PO(control) },\n  { \"pushcopy\",                    MOD_PAT,  MOD_CTL, CTL_PUSHCOPY,               PO(control) },\n  { \"pushtablescopy\",              MOD_PAT,  MOD_CTL, CTL_PUSHTABLESCOPY,         PO(control) },\n  { \"recursion_limit\",             MOD_CTM,  MOD_INT, 0,                          MO(depth_limit) },  /* Obsolete synonym */\n  { \"regerror_buffsize\",           MOD_PAT,  MOD_INT, 0,                          PO(regerror_buffsize) },\n  { \"replace\",                     MOD_PND,  MOD_STR, REPLACE_MODSIZE,            PO(replacement) },\n  { \"stackguard\",                  MOD_PAT,  MOD_INT, 0,                          PO(stackguard_test) },\n  { \"startchar\",                   MOD_PND,  MOD_CTL, CTL_STARTCHAR,              PO(control) },\n  { \"startoffset\",                 MOD_DAT,  MOD_INT, 0,                          DO(offset) },\n  { \"subject_literal\",             MOD_PATP, MOD_CTL, CTL2_SUBJECT_LITERAL,       PO(control2) },\n  { \"substitute_callout\",          MOD_PND,  MOD_CTL, CTL2_SUBSTITUTE_CALLOUT,    PO(control2) },\n  { \"substitute_extended\",         MOD_PND,  MOD_CTL, CTL2_SUBSTITUTE_EXTENDED,   PO(control2) },\n  { \"substitute_literal\",          MOD_PND,  MOD_CTL, CTL2_SUBSTITUTE_LITERAL,    PO(control2) },\n  { \"substitute_matched\",          MOD_PND,  MOD_CTL, CTL2_SUBSTITUTE_MATCHED,    PO(control2) },\n  { \"substitute_overflow_length\",  MOD_PND,  MOD_CTL, CTL2_SUBSTITUTE_OVERFLOW_LENGTH, PO(control2) },\n  { \"substitute_replacement_only\", MOD_PND,  MOD_CTL, CTL2_SUBSTITUTE_REPLACEMENT_ONLY, PO(control2) },\n  { \"substitute_skip\",             MOD_PND,  MOD_INT, 0,                          PO(substitute_skip) },\n  { \"substitute_stop\",             MOD_PND,  MOD_INT, 0,                          PO(substitute_stop) },\n  { \"substitute_unknown_unset\",    MOD_PND,  MOD_CTL, CTL2_SUBSTITUTE_UNKNOWN_UNSET, PO(control2) },\n  { \"substitute_unset_empty\",      MOD_PND,  MOD_CTL, CTL2_SUBSTITUTE_UNSET_EMPTY, PO(control2) },\n  { \"tables\",                      MOD_PAT,  MOD_INT, 0,                          PO(tables_id) },\n  { \"ucp\",                         MOD_PATP, MOD_OPT, PCRE2_UCP,                  PO(options) },\n  { \"ungreedy\",                    MOD_PAT,  MOD_OPT, PCRE2_UNGREEDY,             PO(options) },\n  { \"use_length\",                  MOD_PAT,  MOD_CTL, CTL_USE_LENGTH,             PO(control) },\n  { \"use_offset_limit\",            MOD_PAT,  MOD_OPT, PCRE2_USE_OFFSET_LIMIT,     PO(options) },\n  { \"utf\",                         MOD_PATP, MOD_OPT, PCRE2_UTF,                  PO(options) },\n  { \"utf8_input\",                  MOD_PAT,  MOD_CTL, CTL_UTF8_INPUT,             PO(control) },\n  { \"zero_terminate\",              MOD_DAT,  MOD_CTL, CTL_ZERO_TERMINATE,         DO(control) }\n};\n\n#define MODLISTCOUNT sizeof(modlist)/sizeof(modstruct)\n\n/* Controls and options that are supported for use with the POSIX interface. */\n\n#define POSIX_SUPPORTED_COMPILE_OPTIONS ( \\\n  PCRE2_CASELESS|PCRE2_DOTALL|PCRE2_LITERAL|PCRE2_MULTILINE|PCRE2_UCP| \\\n  PCRE2_UTF|PCRE2_UNGREEDY)\n\n#define POSIX_SUPPORTED_COMPILE_EXTRA_OPTIONS (0)\n\n#define POSIX_SUPPORTED_COMPILE_CONTROLS ( \\\n  CTL_AFTERTEXT|CTL_ALLAFTERTEXT|CTL_EXPAND|CTL_HEXPAT|CTL_POSIX| \\\n  CTL_POSIX_NOSUB|CTL_USE_LENGTH)\n\n#define POSIX_SUPPORTED_COMPILE_CONTROLS2 (0)\n\n#define POSIX_SUPPORTED_MATCH_OPTIONS ( \\\n  PCRE2_NOTBOL|PCRE2_NOTEMPTY|PCRE2_NOTEOL)\n\n#define POSIX_SUPPORTED_MATCH_CONTROLS  (CTL_AFTERTEXT|CTL_ALLAFTERTEXT)\n#define POSIX_SUPPORTED_MATCH_CONTROLS2 (0)\n\n/* Control bits that are not ignored with 'push'. */\n\n#define PUSH_SUPPORTED_COMPILE_CONTROLS ( \\\n  CTL_BINCODE|CTL_CALLOUT_INFO|CTL_FULLBINCODE|CTL_HEXPAT|CTL_INFO| \\\n  CTL_JITVERIFY|CTL_MEMORY|CTL_FRAMESIZE|CTL_PUSH|CTL_PUSHCOPY| \\\n  CTL_PUSHTABLESCOPY|CTL_USE_LENGTH)\n\n#define PUSH_SUPPORTED_COMPILE_CONTROLS2 (CTL2_BSR_SET|CTL2_NL_SET)\n\n/* Controls that apply only at compile time with 'push'. */\n\n#define PUSH_COMPILE_ONLY_CONTROLS   CTL_JITVERIFY\n#define PUSH_COMPILE_ONLY_CONTROLS2  (0)\n\n/* Controls that are forbidden with #pop or #popcopy. */\n\n#define NOTPOP_CONTROLS (CTL_HEXPAT|CTL_POSIX|CTL_POSIX_NOSUB|CTL_PUSH| \\\n  CTL_PUSHCOPY|CTL_PUSHTABLESCOPY|CTL_USE_LENGTH)\n\n/* Pattern controls that are mutually exclusive. At present these are all in\nthe first control word. Note that CTL_POSIX_NOSUB is always accompanied by\nCTL_POSIX, so it doesn't need its own entries. */\n\nstatic uint32_t exclusive_pat_controls\u00dd\u00a8 = {\n  CTL_POSIX    | CTL_PUSH,\n  CTL_POSIX    | CTL_PUSHCOPY,\n  CTL_POSIX    | CTL_PUSHTABLESCOPY,\n  CTL_PUSH     | CTL_PUSHCOPY,\n  CTL_PUSH     | CTL_PUSHTABLESCOPY,\n  CTL_PUSHCOPY | CTL_PUSHTABLESCOPY,\n  CTL_EXPAND   | CTL_HEXPAT };\n\n/* Data controls that are mutually exclusive. At present these are all in the\nfirst control word. */\n\nstatic uint32_t exclusive_dat_controls\u00dd\u00a8 = {\n  CTL_ALLUSEDTEXT | CTL_STARTCHAR,\n  CTL_FINDLIMITS  | CTL_NULLCONTEXT };\n\n/* Table of single-character abbreviated modifiers. The index field is\ninitialized to -1, but the first time the modifier is encountered, it is filled\nin with the index of the full entry in modlist, to save repeated searching when\nprocessing multiple test items. This short list is searched serially, so its\norder does not matter. */\n\ntypedef struct c1modstruct {\n  const char *fullname;\n  uint32_t    onechar;\n  int         index;\n} c1modstruct;\n\nstatic c1modstruct c1modlist\u00dd\u00a8 = {\n  { \"bincode\",         'B',           -1 },\n  { \"info\",            'I',           -1 },\n  { \"global\",          'g',           -1 },\n  { \"caseless\",        'i',           -1 },\n  { \"multiline\",       'm',           -1 },\n  { \"no_auto_capture\", 'n',           -1 },\n  { \"dotall\",          's',           -1 },\n  { \"extended\",        'x',           -1 }\n};\n\n#define C1MODLISTCOUNT sizeof(c1modlist)/sizeof(c1modstruct)\n\n/* Table of arguments for the -C command line option. Use macros to make the\ntable itself easier to read. */\n\n#if defined SUPPORT_PCRE2_8\n#define SUPPORT_8 1\n#endif\n#if defined SUPPORT_PCRE2_16\n#define SUPPORT_16 1\n#endif\n#if defined SUPPORT_PCRE2_32\n#define SUPPORT_32 1\n#endif\n\n#ifndef SUPPORT_8\n#define SUPPORT_8 0\n#endif\n#ifndef SUPPORT_16\n#define SUPPORT_16 0\n#endif\n#ifndef SUPPORT_32\n#define SUPPORT_32 0\n#endif\n\n#ifdef EBCDIC\n#define SUPPORT_EBCDIC 1\n#define EBCDIC_NL CHAR_LF\n#else\n#define SUPPORT_EBCDIC 0\n#define EBCDIC_NL 0\n#endif\n\n#ifdef NEVER_BACKSLASH_C\n#define BACKSLASH_C 0\n#else\n#define BACKSLASH_C 1\n#endif\n\ntypedef struct coptstruct {\n  const char *name;\n  uint32_t    type;\n  uint32_t    value;\n} coptstruct;\n\nenum { CONF_BSR,\n       CONF_FIX,\n       CONF_FIZ,\n       CONF_INT,\n       CONF_NL\n};\n\nstatic coptstruct coptlist\u00dd\u00a8 = {\n  { \"backslash-C\", CONF_FIX, BACKSLASH_C },\n  { \"bsr\",         CONF_BSR, PCRE2_CONFIG_BSR },\n  { \"ebcdic\",      CONF_FIX, SUPPORT_EBCDIC },\n  { \"ebcdic-nl\",   CONF_FIZ, EBCDIC_NL },\n  { \"jit\",         CONF_INT, PCRE2_CONFIG_JIT },\n  { \"linksize\",    CONF_INT, PCRE2_CONFIG_LINKSIZE },\n  { \"newline\",     CONF_NL,  PCRE2_CONFIG_NEWLINE },\n  { \"pcre2-16\",    CONF_FIX, SUPPORT_16 },\n  { \"pcre2-32\",    CONF_FIX, SUPPORT_32 },\n  { \"pcre2-8\",     CONF_FIX, SUPPORT_8 },\n  { \"unicode\",     CONF_INT, PCRE2_CONFIG_UNICODE }\n};\n\n#define COPTLISTCOUNT sizeof(coptlist)/sizeof(coptstruct)\n\n#undef SUPPORT_8\n#undef SUPPORT_16\n#undef SUPPORT_32\n#undef SUPPORT_EBCDIC\n\n\n/* ----------------------- Static variables ------------------------ */\n\nstatic FILE *infile;\nstatic FILE *outfile;\n\nstatic const void *last_callout_mark;\nstatic PCRE2_JIT_STACK *jit_stack = NULL;\nstatic size_t jit_stack_size = 0;\n\nstatic BOOL first_callout;\nstatic BOOL jit_was_used;\nstatic BOOL restrict_for_perl_test = FALSE;\nstatic BOOL show_memory = FALSE;\n\nstatic int code_unit_size;                    /* Bytes */\nstatic int jitrc;                             /* Return from JIT compile */\nstatic int test_mode = DEFAULT_TEST_MODE;\nstatic int timeit = 0;\nstatic int timeitm = 0;\n\nclock_t total_compile_time = 0;\nclock_t total_jit_compile_time = 0;\nclock_t total_match_time = 0;\n\nstatic uint32_t dfa_matched;\nstatic uint32_t forbid_utf = 0;\nstatic uint32_t maxlookbehind;\nstatic uint32_t max_oveccount;\nstatic uint32_t callout_count;\nstatic uint32_t maxcapcount;\n\nstatic uint16_t local_newline_default = 0;\n\nstatic VERSION_TYPE jittarget\u00ddVERSION_SIZE\u00a8;\nstatic VERSION_TYPE version\u00ddVERSION_SIZE\u00a8;\nstatic VERSION_TYPE uversion\u00ddVERSION_SIZE\u00a8;\n\nstatic patctl def_patctl;\nstatic patctl pat_patctl;\nstatic datctl def_datctl;\nstatic datctl dat_datctl;\n\nstatic void *patstack\u00ddPATSTACKSIZE\u00a8;\nstatic int patstacknext = 0;\n\nstatic void *malloclist\u00ddMALLOCLISTSIZE\u00a8;\nstatic PCRE2_SIZE malloclistlength\u00ddMALLOCLISTSIZE\u00a8;\nstatic uint32_t malloclistptr = 0;\n\n#ifdef SUPPORT_PCRE2_8\nstatic regex_t preg = { NULL, NULL, 0, 0, 0, 0 };\n#endif\n\nstatic int *dfa_workspace = NULL;\nstatic const uint8_t *locale_tables = NULL;\nstatic const uint8_t *use_tables = NULL;\nstatic uint8_t locale_name\u00dd32\u00a8;\nstatic uint8_t *tables3 = NULL;         /* For binary-loaded tables */\nstatic uint32_t loadtables_length = 0;\n\n/* We need buffers for building 16/32-bit strings; 8-bit strings don't need\nrebuilding, but set up the same naming scheme for use in macros. The \"buffer\"\nbuffer is where all input lines are read. Its size is the same as pbuffer8.\nPattern lines are always copied to pbuffer8 for use in callouts, even if they\nare actually compiled from pbuffer16 or pbuffer32. */\n\nstatic size_t    pbuffer8_size  = 50000;        /* Initial size, bytes */\nstatic uint8_t  *pbuffer8 = NULL;\nstatic uint8_t  *buffer = NULL;\n\n/* The dbuffer is where all processed data lines are put. In non-8-bit modes it\nis cast as needed. For long data lines it grows as necessary. */\n\nstatic size_t dbuffer_size = 1u << 14;    /* Initial size, bytes */\nstatic uint8_t *dbuffer = NULL;\n\n\n/* ---------------- Mode-dependent variables -------------------*/\n\n#ifdef SUPPORT_PCRE2_8\nstatic pcre2_code_8             *compiled_code8;\nstatic pcre2_general_context_8  *general_context8, *general_context_copy8;\nstatic pcre2_compile_context_8  *pat_context8, *default_pat_context8;\nstatic pcre2_convert_context_8  *con_context8, *default_con_context8;\nstatic pcre2_match_context_8    *dat_context8, *default_dat_context8;\nstatic pcre2_match_data_8       *match_data8;\n#endif\n\n#ifdef SUPPORT_PCRE2_16\nstatic pcre2_code_16            *compiled_code16;\nstatic pcre2_general_context_16 *general_context16, *general_context_copy16;\nstatic pcre2_compile_context_16 *pat_context16, *default_pat_context16;\nstatic pcre2_convert_context_16 *con_context16, *default_con_context16;\nstatic pcre2_match_context_16   *dat_context16, *default_dat_context16;\nstatic pcre2_match_data_16      *match_data16;\nstatic PCRE2_SIZE pbuffer16_size = 0;   /* Set only when needed */\nstatic uint16_t *pbuffer16 = NULL;\n#endif\n\n#ifdef SUPPORT_PCRE2_32\nstatic pcre2_code_32            *compiled_code32;\nstatic pcre2_general_context_32 *general_context32, *general_context_copy32;\nstatic pcre2_compile_context_32 *pat_context32, *default_pat_context32;\nstatic pcre2_convert_context_32 *con_context32, *default_con_context32;\nstatic pcre2_match_context_32   *dat_context32, *default_dat_context32;\nstatic pcre2_match_data_32      *match_data32;\nstatic PCRE2_SIZE pbuffer32_size = 0;   /* Set only when needed */\nstatic uint32_t *pbuffer32 = NULL;\n#endif\n\n\n/* ---------------- Macros that work in all modes ----------------- */\n\n#define CAST8VAR(x) CASTVAR(uint8_t *, x)\n#define SET(x,y) SETOP(x,y,=)\n#define SETPLUS(x,y) SETOP(x,y,+=)\n#define strlen8(x) strlen((char *)x)\n\n\n/* ---------------- Mode-dependent, runtime-testing macros ------------------*/\n\n/* Define macros for variables and functions that must be selected dynamically\ndepending on the mode setting (8, 16, 32). These are dependent on which modes\nare supported. */\n\n#if (defined (SUPPORT_PCRE2_8) + defined (SUPPORT_PCRE2_16) + \\\n     defined (SUPPORT_PCRE2_32)) >= 2\n\n/* ----- All three modes supported ----- */\n\n#if defined(SUPPORT_PCRE2_8) && defined(SUPPORT_PCRE2_16) && defined(SUPPORT_PCRE2_32)\n\n#define CASTFLD(t,a,b) ((test_mode == PCRE8_MODE)? (t)(G(a,8)->b) : \\\n  (test_mode == PCRE16_MODE)? (t)(G(a,16)->b) : (t)(G(a,32)->b))\n\n#define CASTVAR(t,x) ( \\\n  (test_mode == PCRE8_MODE)? (t)G(x,8) : \\\n  (test_mode == PCRE16_MODE)? (t)G(x,16) : (t)G(x,32))\n\n#define CODE_UNIT(a,b) ( \\\n  (test_mode == PCRE8_MODE)? (uint32_t)(((PCRE2_SPTR8)(a))\u00ddb\u00a8) : \\\n  (test_mode == PCRE16_MODE)? (uint32_t)(((PCRE2_SPTR16)(a))\u00ddb\u00a8) : \\\n  (uint32_t)(((PCRE2_SPTR32)(a))\u00ddb\u00a8))\n\n#define CONCTXCPY(a,b) \\\n  if (test_mode == PCRE8_MODE) \\\n    memcpy(G(a,8),G(b,8),sizeof(pcre2_convert_context_8)); \\\n  else if (test_mode == PCRE16_MODE) \\\n    memcpy(G(a,16),G(b,16),sizeof(pcre2_convert_context_16)); \\\n  else memcpy(G(a,32),G(b,32),sizeof(pcre2_convert_context_32))\n\n#define CONVERT_COPY(a,b,c) \\\n  if (test_mode == PCRE8_MODE) \\\n    memcpy(G(a,8),(char *)b,c); \\\n  else if (test_mode == PCRE16_MODE) \\\n    memcpy(G(a,16),(char *)b,(c)*2); \\\n  else if (test_mode == PCRE32_MODE) \\\n    memcpy(G(a,32),(char *)b,(c)*4)\n\n#define DATCTXCPY(a,b) \\\n  if (test_mode == PCRE8_MODE) \\\n    memcpy(G(a,8),G(b,8),sizeof(pcre2_match_context_8)); \\\n  else if (test_mode == PCRE16_MODE) \\\n    memcpy(G(a,16),G(b,16),sizeof(pcre2_match_context_16)); \\\n  else memcpy(G(a,32),G(b,32),sizeof(pcre2_match_context_32))\n\n#define FLD(a,b) ((test_mode == PCRE8_MODE)? G(a,8)->b : \\\n  (test_mode == PCRE16_MODE)? G(a,16)->b : G(a,32)->b)\n\n#define PATCTXCPY(a,b) \\\n  if (test_mode == PCRE8_MODE) \\\n    memcpy(G(a,8),G(b,8),sizeof(pcre2_compile_context_8)); \\\n  else if (test_mode == PCRE16_MODE) \\\n    memcpy(G(a,16),G(b,16),sizeof(pcre2_compile_context_16)); \\\n  else memcpy(G(a,32),G(b,32),sizeof(pcre2_compile_context_32))\n\n#define PCHARS(lv, p, offset, len, utf, f) \\\n  if (test_mode == PCRE32_MODE) \\\n    lv = pchars32((PCRE2_SPTR32)(p)+offset, len, utf, f); \\\n  else if (test_mode == PCRE16_MODE) \\\n    lv = pchars16((PCRE2_SPTR16)(p)+offset, len, utf, f); \\\n  else \\\n    lv = pchars8((PCRE2_SPTR8)(p)+offset, len, utf, f)\n\n#define PCHARSV(p, offset, len, utf, f) \\\n  if (test_mode == PCRE32_MODE) \\\n    (void)pchars32((PCRE2_SPTR32)(p)+offset, len, utf, f); \\\n  else if (test_mode == PCRE16_MODE) \\\n    (void)pchars16((PCRE2_SPTR16)(p)+offset, len, utf, f); \\\n  else \\\n    (void)pchars8((PCRE2_SPTR8)(p)+offset, len, utf, f)\n\n#define PCRE2_CALLOUT_ENUMERATE(a,b,c) \\\n  if (test_mode == PCRE8_MODE) \\\n     a = pcre2_callout_enumerate_8(compiled_code8, \\\n       (int (*)(struct pcre2_callout_enumerate_block_8 *, void *))b,c); \\\n  else if (test_mode == PCRE16_MODE) \\\n     a = pcre2_callout_enumerate_16(compiled_code16, \\\n       (int(*)(struct pcre2_callout_enumerate_block_16 *, void *))b,c); \\\n  else \\\n     a = pcre2_callout_enumerate_32(compiled_code32, \\\n       (int (*)(struct pcre2_callout_enumerate_block_32 *, void *))b,c)\n\n#define PCRE2_CODE_COPY_FROM_VOID(a,b) \\\n  if (test_mode == PCRE8_MODE) \\\n    G(a,8) = pcre2_code_copy_8(b); \\\n  else if (test_mode == PCRE16_MODE) \\\n    G(a,16) = pcre2_code_copy_16(b); \\\n  else \\\n    G(a,32) = pcre2_code_copy_32(b)\n\n#define PCRE2_CODE_COPY_TO_VOID(a,b) \\\n  if (test_mode == PCRE8_MODE) \\\n    a = (void *)pcre2_code_copy_8(G(b,8)); \\\n  else if (test_mode == PCRE16_MODE) \\\n    a = (void *)pcre2_code_copy_16(G(b,16)); \\\n  else \\\n    a = (void *)pcre2_code_copy_32(G(b,32))\n\n#define PCRE2_CODE_COPY_WITH_TABLES_TO_VOID(a,b) \\\n  if (test_mode == PCRE8_MODE) \\\n    a = (void *)pcre2_code_copy_with_tables_8(G(b,8)); \\\n  else if (test_mode == PCRE16_MODE) \\\n    a = (void *)pcre2_code_copy_with_tables_16(G(b,16)); \\\n  else \\\n    a = (void *)pcre2_code_copy_with_tables_32(G(b,32))\n\n#define PCRE2_COMPILE(a,b,c,d,e,f,g) \\\n  if (test_mode == PCRE8_MODE) \\\n    G(a,8) = pcre2_compile_8(G(b,8),c,d,e,f,g); \\\n  else if (test_mode == PCRE16_MODE) \\\n    G(a,16) = pcre2_compile_16(G(b,16),c,d,e,f,g); \\\n  else \\\n    G(a,32) = pcre2_compile_32(G(b,32),c,d,e,f,g)\n\n#define PCRE2_CONVERTED_PATTERN_FREE(a) \\\n  if (test_mode == PCRE8_MODE) pcre2_converted_pattern_free_8((PCRE2_UCHAR8 *)a); \\\n  else if (test_mode == PCRE16_MODE) pcre2_converted_pattern_free_16((PCRE2_UCHAR16 *)a); \\\n  else pcre2_converted_pattern_free_32((PCRE2_UCHAR32 *)a)\n\n#define PCRE2_DFA_MATCH(a,b,c,d,e,f,g,h,i,j) \\\n  if (test_mode == PCRE8_MODE) \\\n    a = pcre2_dfa_match_8(G(b,8),(PCRE2_SPTR8)c,d,e,f,G(g,8),h,i,j); \\\n  else if (test_mode == PCRE16_MODE) \\\n    a = pcre2_dfa_match_16(G(b,16),(PCRE2_SPTR16)c,d,e,f,G(g,16),h,i,j); \\\n  else \\\n    a = pcre2_dfa_match_32(G(b,32),(PCRE2_SPTR32)c,d,e,f,G(g,32),h,i,j)\n\n#define PCRE2_GET_ERROR_MESSAGE(r,a,b) \\\n  if (test_mode == PCRE8_MODE) \\\n    r = pcre2_get_error_message_8(a,G(b,8),G(G(b,8),_size)); \\\n  else if (test_mode == PCRE16_MODE) \\\n    r = pcre2_get_error_message_16(a,G(b,16),G(G(b,16),_size/2)); \\\n  else \\\n    r = pcre2_get_error_message_32(a,G(b,32),G(G(b,32),_size/4))\n\n#define PCRE2_GET_OVECTOR_COUNT(a,b) \\\n  if (test_mode == PCRE8_MODE) \\\n    a = pcre2_get_ovector_count_8(G(b,8)); \\\n  else if (test_mode == PCRE16_MODE) \\\n    a = pcre2_get_ovector_count_16(G(b,16)); \\\n  else \\\n    a = pcre2_get_ovector_count_32(G(b,32))\n\n#define PCRE2_GET_STARTCHAR(a,b) \\\n  if (test_mode == PCRE8_MODE) \\\n    a = pcre2_get_startchar_8(G(b,8)); \\\n  else if (test_mode == PCRE16_MODE) \\\n    a = pcre2_get_startchar_16(G(b,16)); \\\n  else \\\n    a = pcre2_get_startchar_32(G(b,32))\n\n#define PCRE2_JIT_COMPILE(r,a,b) \\\n  if (test_mode == PCRE8_MODE) r = pcre2_jit_compile_8(G(a,8),b); \\\n  else if (test_mode == PCRE16_MODE) r = pcre2_jit_compile_16(G(a,16),b); \\\n  else r = pcre2_jit_compile_32(G(a,32),b)\n\n#define PCRE2_JIT_FREE_UNUSED_MEMORY(a) \\\n  if (test_mode == PCRE8_MODE) pcre2_jit_free_unused_memory_8(G(a,8)); \\\n  else if (test_mode == PCRE16_MODE) pcre2_jit_free_unused_memory_16(G(a,16)); \\\n  else pcre2_jit_free_unused_memory_32(G(a,32))\n\n#define PCRE2_JIT_MATCH(a,b,c,d,e,f,g,h) \\\n  if (test_mode == PCRE8_MODE) \\\n    a = pcre2_jit_match_8(G(b,8),(PCRE2_SPTR8)c,d,e,f,G(g,8),h); \\\n  else if (test_mode == PCRE16_MODE) \\\n    a = pcre2_jit_match_16(G(b,16),(PCRE2_SPTR16)c,d,e,f,G(g,16),h); \\\n  else \\\n    a = pcre2_jit_match_32(G(b,32),(PCRE2_SPTR32)c,d,e,f,G(g,32),h)\n\n#define PCRE2_JIT_STACK_CREATE(a,b,c,d) \\\n  if (test_mode == PCRE8_MODE) \\\n    a = (PCRE2_JIT_STACK *)pcre2_jit_stack_create_8(b,c,d); \\\n  else if (test_mode == PCRE16_MODE) \\\n    a = (PCRE2_JIT_STACK *)pcre2_jit_stack_create_16(b,c,d); \\\n  else \\\n    a = (PCRE2_JIT_STACK *)pcre2_jit_stack_create_32(b,c,d);\n\n#define PCRE2_JIT_STACK_ASSIGN(a,b,c) \\\n  if (test_mode == PCRE8_MODE) \\\n    pcre2_jit_stack_assign_8(G(a,8),(pcre2_jit_callback_8)b,c); \\\n  else if (test_mode == PCRE16_MODE) \\\n    pcre2_jit_stack_assign_16(G(a,16),(pcre2_jit_callback_16)b,c); \\\n  else \\\n    pcre2_jit_stack_assign_32(G(a,32),(pcre2_jit_callback_32)b,c);\n\n#define PCRE2_JIT_STACK_FREE(a) \\\n  if (test_mode == PCRE8_MODE) \\\n    pcre2_jit_stack_free_8((pcre2_jit_stack_8 *)a); \\\n  else if (test_mode == PCRE16_MODE) \\\n    pcre2_jit_stack_free_16((pcre2_jit_stack_16 *)a); \\\n  else \\\n    pcre2_jit_stack_free_32((pcre2_jit_stack_32 *)a);\n\n#define PCRE2_MAKETABLES(a) \\\n  if (test_mode == PCRE8_MODE) a = pcre2_maketables_8(NULL); \\\n  else if (test_mode == PCRE16_MODE) a = pcre2_maketables_16(NULL); \\\n  else a = pcre2_maketables_32(NULL)\n\n#define PCRE2_MATCH(a,b,c,d,e,f,g,h) \\\n  if (test_mode == PCRE8_MODE) \\\n    a = pcre2_match_8(G(b,8),(PCRE2_SPTR8)c,d,e,f,G(g,8),h); \\\n  else if (test_mode == PCRE16_MODE) \\\n    a = pcre2_match_16(G(b,16),(PCRE2_SPTR16)c,d,e,f,G(g,16),h); \\\n  else \\\n    a = pcre2_match_32(G(b,32),(PCRE2_SPTR32)c,d,e,f,G(g,32),h)\n\n#define PCRE2_MATCH_DATA_CREATE(a,b,c) \\\n  if (test_mode == PCRE8_MODE) \\\n    G(a,8) = pcre2_match_data_create_8(b,c); \\\n  else if (test_mode == PCRE16_MODE) \\\n    G(a,16) = pcre2_match_data_create_16(b,c); \\\n  else \\\n    G(a,32) = pcre2_match_data_create_32(b,c)\n\n#define PCRE2_MATCH_DATA_CREATE_FROM_PATTERN(a,b,c) \\\n  if (test_mode == PCRE8_MODE) \\\n    G(a,8) = pcre2_match_data_create_from_pattern_8(G(b,8),c); \\\n  else if (test_mode == PCRE16_MODE) \\\n    G(a,16) = pcre2_match_data_create_from_pattern_16(G(b,16),c); \\\n  else \\\n    G(a,32) = pcre2_match_data_create_from_pattern_32(G(b,32),c)\n\n#define PCRE2_MATCH_DATA_FREE(a) \\\n  if (test_mode == PCRE8_MODE) \\\n    pcre2_match_data_free_8(G(a,8)); \\\n  else if (test_mode == PCRE16_MODE) \\\n    pcre2_match_data_free_16(G(a,16)); \\\n  else \\\n    pcre2_match_data_free_32(G(a,32))\n\n#define PCRE2_PATTERN_CONVERT(a,b,c,d,e,f,g) \\\n  if (test_mode == PCRE8_MODE) \\\n    a = pcre2_pattern_convert_8(G(b,8),c,d,(PCRE2_UCHAR8 **)e,f,G(g,8)); \\\n  else if (test_mode == PCRE16_MODE) \\\n    a = pcre2_pattern_convert_16(G(b,16),c,d,(PCRE2_UCHAR16 **)e,f,G(g,16)); \\\n  else \\\n    a = pcre2_pattern_convert_32(G(b,32),c,d,(PCRE2_UCHAR32 **)e,f,G(g,32))\n\n#define PCRE2_PATTERN_INFO(a,b,c,d) \\\n  if (test_mode == PCRE8_MODE) \\\n    a = pcre2_pattern_info_8(G(b,8),c,d); \\\n  else if (test_mode == PCRE16_MODE) \\\n    a = pcre2_pattern_info_16(G(b,16),c,d); \\\n  else \\\n    a = pcre2_pattern_info_32(G(b,32),c,d)\n\n#define PCRE2_PRINTINT(a) \\\n  if (test_mode == PCRE8_MODE) \\\n    pcre2_printint_8(compiled_code8,outfile,a); \\\n  else if (test_mode == PCRE16_MODE) \\\n    pcre2_printint_16(compiled_code16,outfile,a); \\\n  else \\\n    pcre2_printint_32(compiled_code32,outfile,a)\n\n#define PCRE2_SERIALIZE_DECODE(r,a,b,c,d) \\\n  if (test_mode == PCRE8_MODE) \\\n    r = pcre2_serialize_decode_8((pcre2_code_8 **)a,b,c,G(d,8)); \\\n  else if (test_mode == PCRE16_MODE) \\\n    r = pcre2_serialize_decode_16((pcre2_code_16 **)a,b,c,G(d,16)); \\\n  else \\\n    r = pcre2_serialize_decode_32((pcre2_code_32 **)a,b,c,G(d,32))\n\n#define PCRE2_SERIALIZE_ENCODE(r,a,b,c,d,e) \\\n  if (test_mode == PCRE8_MODE) \\\n    r = pcre2_serialize_encode_8((const pcre2_code_8 **)a,b,c,d,G(e,8)); \\\n  else if (test_mode == PCRE16_MODE) \\\n    r = pcre2_serialize_encode_16((const pcre2_code_16 **)a,b,c,d,G(e,16)); \\\n  else \\\n    r = pcre2_serialize_encode_32((const pcre2_code_32 **)a,b,c,d,G(e,32))\n\n#define PCRE2_SERIALIZE_FREE(a) \\\n  if (test_mode == PCRE8_MODE) \\\n    pcre2_serialize_free_8(a); \\\n  else if (test_mode == PCRE16_MODE) \\\n    pcre2_serialize_free_16(a); \\\n  else \\\n    pcre2_serialize_free_32(a)\n\n#define PCRE2_SERIALIZE_GET_NUMBER_OF_CODES(r,a) \\\n  if (test_mode == PCRE8_MODE) \\\n    r = pcre2_serialize_get_number_of_codes_8(a); \\\n  else if (test_mode == PCRE16_MODE) \\\n    r = pcre2_serialize_get_number_of_codes_16(a); \\\n  else \\\n    r = pcre2_serialize_get_number_of_codes_32(a); \\\n\n#define PCRE2_SET_CALLOUT(a,b,c) \\\n  if (test_mode == PCRE8_MODE) \\\n    pcre2_set_callout_8(G(a,8),(int (*)(pcre2_callout_block_8 *, void *))b,c); \\\n  else if (test_mode == PCRE16_MODE) \\\n    pcre2_set_callout_16(G(a,16),(int (*)(pcre2_callout_block_16 *, void *))b,c); \\\n  else \\\n    pcre2_set_callout_32(G(a,32),(int (*)(pcre2_callout_block_32 *, void *))b,c);\n\n#define PCRE2_SET_CHARACTER_TABLES(a,b) \\\n  if (test_mode == PCRE8_MODE) \\\n    pcre2_set_character_tables_8(G(a,8),b); \\\n  else if (test_mode == PCRE16_MODE) \\\n    pcre2_set_character_tables_16(G(a,16),b); \\\n  else \\\n    pcre2_set_character_tables_32(G(a,32),b)\n\n#define PCRE2_SET_COMPILE_RECURSION_GUARD(a,b,c) \\\n  if (test_mode == PCRE8_MODE) \\\n    pcre2_set_compile_recursion_guard_8(G(a,8),b,c); \\\n  else if (test_mode == PCRE16_MODE) \\\n    pcre2_set_compile_recursion_guard_16(G(a,16),b,c); \\\n  else \\\n    pcre2_set_compile_recursion_guard_32(G(a,32),b,c)\n\n#define PCRE2_SET_DEPTH_LIMIT(a,b) \\\n  if (test_mode == PCRE8_MODE) \\\n    pcre2_set_depth_limit_8(G(a,8),b); \\\n  else if (test_mode == PCRE16_MODE) \\\n    pcre2_set_depth_limit_16(G(a,16),b); \\\n  else \\\n    pcre2_set_depth_limit_32(G(a,32),b)\n\n#define PCRE2_SET_GLOB_SEPARATOR(r,a,b) \\\n  if (test_mode == PCRE8_MODE) \\\n    r = pcre2_set_glob_separator_8(G(a,8),b); \\\n  else if (test_mode == PCRE16_MODE) \\\n    r = pcre2_set_glob_separator_16(G(a,16),b); \\\n  else \\\n    r = pcre2_set_glob_separator_32(G(a,32),b)\n\n#define PCRE2_SET_GLOB_ESCAPE(r,a,b) \\\n  if (test_mode == PCRE8_MODE) \\\n    r = pcre2_set_glob_escape_8(G(a,8),b); \\\n  else if (test_mode == PCRE16_MODE) \\\n    r = pcre2_set_glob_escape_16(G(a,16),b); \\\n  else \\\n    r = pcre2_set_glob_escape_32(G(a,32),b)\n\n#define PCRE2_SET_HEAP_LIMIT(a,b) \\\n  if (test_mode == PCRE8_MODE) \\\n    pcre2_set_heap_limit_8(G(a,8),b); \\\n  else if (test_mode == PCRE16_MODE) \\\n    pcre2_set_heap_limit_16(G(a,16),b); \\\n  else \\\n    pcre2_set_heap_limit_32(G(a,32),b)\n\n#define PCRE2_SET_MATCH_LIMIT(a,b) \\\n  if (test_mode == PCRE8_MODE) \\\n    pcre2_set_match_limit_8(G(a,8),b); \\\n  else if (test_mode == PCRE16_MODE) \\\n    pcre2_set_match_limit_16(G(a,16),b); \\\n  else \\\n    pcre2_set_match_limit_32(G(a,32),b)\n\n#define PCRE2_SET_MAX_PATTERN_LENGTH(a,b) \\\n  if (test_mode == PCRE8_MODE) \\\n    pcre2_set_max_pattern_length_8(G(a,8),b); \\\n  else if (test_mode == PCRE16_MODE) \\\n    pcre2_set_max_pattern_length_16(G(a,16),b); \\\n  else \\\n    pcre2_set_max_pattern_length_32(G(a,32),b)\n\n#define PCRE2_SET_OFFSET_LIMIT(a,b) \\\n  if (test_mode == PCRE8_MODE) \\\n    pcre2_set_offset_limit_8(G(a,8),b); \\\n  else if (test_mode == PCRE16_MODE) \\\n    pcre2_set_offset_limit_16(G(a,16),b); \\\n  else \\\n    pcre2_set_offset_limit_32(G(a,32),b)\n\n#define PCRE2_SET_PARENS_NEST_LIMIT(a,b) \\\n  if (test_mode == PCRE8_MODE) \\\n    pcre2_set_parens_nest_limit_8(G(a,8),b); \\\n  else if (test_mode == PCRE16_MODE) \\\n    pcre2_set_parens_nest_limit_16(G(a,16),b); \\\n  else \\\n    pcre2_set_parens_nest_limit_32(G(a,32),b)\n\n#define PCRE2_SET_SUBSTITUTE_CALLOUT(a,b,c) \\\n  if (test_mode == PCRE8_MODE) \\\n    pcre2_set_substitute_callout_8(G(a,8), \\\n      (int (*)(pcre2_substitute_callout_block_8 *, void *))b,c); \\\n  else if (test_mode == PCRE16_MODE) \\\n    pcre2_set_substitute_callout_16(G(a,16), \\\n      (int (*)(pcre2_substitute_callout_block_16 *, void *))b,c); \\\n  else \\\n    pcre2_set_substitute_callout_32(G(a,32), \\\n      (int (*)(pcre2_substitute_callout_block_32 *, void *))b,c)\n\n#define PCRE2_SUBSTITUTE(a,b,c,d,e,f,g,h,i,j,k,l) \\\n  if (test_mode == PCRE8_MODE) \\\n    a = pcre2_substitute_8(G(b,8),(PCRE2_SPTR8)c,d,e,f,G(g,8),h, \\\n      (PCRE2_SPTR8)i,j,(PCRE2_UCHAR8 *)k,l); \\\n  else if (test_mode == PCRE16_MODE) \\\n    a = pcre2_substitute_16(G(b,16),(PCRE2_SPTR16)c,d,e,f,G(g,16),h, \\\n      (PCRE2_SPTR16)i,j,(PCRE2_UCHAR16 *)k,l); \\\n  else \\\n    a = pcre2_substitute_32(G(b,32),(PCRE2_SPTR32)c,d,e,f,G(g,32),h, \\\n      (PCRE2_SPTR32)i,j,(PCRE2_UCHAR32 *)k,l)\n\n#define PCRE2_SUBSTRING_COPY_BYNAME(a,b,c,d,e) \\\n  if (test_mode == PCRE8_MODE) \\\n    a = pcre2_substring_copy_byname_8(G(b,8),G(c,8),(PCRE2_UCHAR8 *)d,e); \\\n  else if (test_mode == PCRE16_MODE) \\\n    a = pcre2_substring_copy_byname_16(G(b,16),G(c,16),(PCRE2_UCHAR16 *)d,e); \\\n  else \\\n    a = pcre2_substring_copy_byname_32(G(b,32),G(c,32),(PCRE2_UCHAR32 *)d,e)\n\n#define PCRE2_SUBSTRING_COPY_BYNUMBER(a,b,c,d,e) \\\n  if (test_mode == PCRE8_MODE) \\\n    a = pcre2_substring_copy_bynumber_8(G(b,8),c,(PCRE2_UCHAR8 *)d,e); \\\n  else if (test_mode == PCRE16_MODE) \\\n    a = pcre2_substring_copy_bynumber_16(G(b,16),c,(PCRE2_UCHAR16 *)d,e); \\\n  else \\\n    a = pcre2_substring_copy_bynumber_32(G(b,32),c,(PCRE2_UCHAR32 *)d,e)\n\n#define PCRE2_SUBSTRING_FREE(a) \\\n  if (test_mode == PCRE8_MODE) pcre2_substring_free_8((PCRE2_UCHAR8 *)a); \\\n  else if (test_mode == PCRE16_MODE) \\\n    pcre2_substring_free_16((PCRE2_UCHAR16 *)a); \\\n  else pcre2_substring_free_32((PCRE2_UCHAR32 *)a)\n\n#define PCRE2_SUBSTRING_GET_BYNAME(a,b,c,d,e) \\\n  if (test_mode == PCRE8_MODE) \\\n    a = pcre2_substring_get_byname_8(G(b,8),G(c,8),(PCRE2_UCHAR8 **)d,e); \\\n  else if (test_mode == PCRE16_MODE) \\\n    a = pcre2_substring_get_byname_16(G(b,16),G(c,16),(PCRE2_UCHAR16 **)d,e); \\\n  else \\\n    a = pcre2_substring_get_byname_32(G(b,32),G(c,32),(PCRE2_UCHAR32 **)d,e)\n\n#define PCRE2_SUBSTRING_GET_BYNUMBER(a,b,c,d,e) \\\n  if (test_mode == PCRE8_MODE) \\\n    a = pcre2_substring_get_bynumber_8(G(b,8),c,(PCRE2_UCHAR8 **)d,e); \\\n  else if (test_mode == PCRE16_MODE) \\\n    a = pcre2_substring_get_bynumber_16(G(b,16),c,(PCRE2_UCHAR16 **)d,e); \\\n  else \\\n    a = pcre2_substring_get_bynumber_32(G(b,32),c,(PCRE2_UCHAR32 **)d,e)\n\n#define PCRE2_SUBSTRING_LENGTH_BYNAME(a,b,c,d) \\\n  if (test_mode == PCRE8_MODE) \\\n    a = pcre2_substring_length_byname_8(G(b,8),G(c,8),d); \\\n  else if (test_mode == PCRE16_MODE) \\\n    a = pcre2_substring_length_byname_16(G(b,16),G(c,16),d); \\\n  else \\\n    a = pcre2_substring_length_byname_32(G(b,32),G(c,32),d)\n\n#define PCRE2_SUBSTRING_LENGTH_BYNUMBER(a,b,c,d) \\\n  if (test_mode == PCRE8_MODE) \\\n    a = pcre2_substring_length_bynumber_8(G(b,8),c,d); \\\n  else if (test_mode == PCRE16_MODE) \\\n    a = pcre2_substring_length_bynumber_16(G(b,16),c,d); \\\n  else \\\n    a = pcre2_substring_length_bynumber_32(G(b,32),c,d)\n\n#define PCRE2_SUBSTRING_LIST_GET(a,b,c,d) \\\n  if (test_mode == PCRE8_MODE) \\\n    a = pcre2_substring_list_get_8(G(b,8),(PCRE2_UCHAR8 ***)c,d); \\\n  else if (test_mode == PCRE16_MODE) \\\n    a = pcre2_substring_list_get_16(G(b,16),(PCRE2_UCHAR16 ***)c,d); \\\n  else \\\n    a = pcre2_substring_list_get_32(G(b,32),(PCRE2_UCHAR32 ***)c,d)\n\n#define PCRE2_SUBSTRING_LIST_FREE(a) \\\n  if (test_mode == PCRE8_MODE) \\\n    pcre2_substring_list_free_8((PCRE2_SPTR8 *)a); \\\n  else if (test_mode == PCRE16_MODE) \\\n    pcre2_substring_list_free_16((PCRE2_SPTR16 *)a); \\\n  else \\\n    pcre2_substring_list_free_32((PCRE2_SPTR32 *)a)\n\n#define PCRE2_SUBSTRING_NUMBER_FROM_NAME(a,b,c) \\\n  if (test_mode == PCRE8_MODE) \\\n    a = pcre2_substring_number_from_name_8(G(b,8),G(c,8)); \\\n  else if (test_mode == PCRE16_MODE) \\\n    a = pcre2_substring_number_from_name_16(G(b,16),G(c,16)); \\\n  else \\\n    a = pcre2_substring_number_from_name_32(G(b,32),G(c,32))\n\n#define PTR(x) ( \\\n  (test_mode == PCRE8_MODE)? (void *)G(x,8) : \\\n  (test_mode == PCRE16_MODE)? (void *)G(x,16) : \\\n  (void *)G(x,32))\n\n#define SETFLD(x,y,z) \\\n  if (test_mode == PCRE8_MODE) G(x,8)->y = z; \\\n  else if (test_mode == PCRE16_MODE) G(x,16)->y = z; \\\n  else G(x,32)->y = z\n\n#define SETFLDVEC(x,y,v,z) \\\n  if (test_mode == PCRE8_MODE) G(x,8)->y\u00ddv\u00a8 = z; \\\n  else if (test_mode == PCRE16_MODE) G(x,16)->y\u00ddv\u00a8 = z; \\\n  else G(x,32)->y\u00ddv\u00a8 = z\n\n#define SETOP(x,y,z) \\\n  if (test_mode == PCRE8_MODE) G(x,8) z y; \\\n  else if (test_mode == PCRE16_MODE) G(x,16) z y; \\\n  else G(x,32) z y\n\n#define SETCASTPTR(x,y) \\\n  if (test_mode == PCRE8_MODE) \\\n    G(x,8) = (uint8_t *)(y); \\\n  else if (test_mode == PCRE16_MODE) \\\n    G(x,16) = (uint16_t *)(y); \\\n  else \\\n    G(x,32) = (uint32_t *)(y)\n\n#define STRLEN(p) ((test_mode == PCRE8_MODE)? ((int)strlen((char *)p)) : \\\n  (test_mode == PCRE16_MODE)? ((int)strlen16((PCRE2_SPTR16)p)) : \\\n  ((int)strlen32((PCRE2_SPTR32)p)))\n\n#define SUB1(a,b) \\\n  if (test_mode == PCRE8_MODE) G(a,8)(G(b,8)); \\\n  else if (test_mode == PCRE16_MODE) G(a,16)(G(b,16)); \\\n  else G(a,32)(G(b,32))\n\n#define SUB2(a,b,c) \\\n  if (test_mode == PCRE8_MODE) G(a,8)(G(b,8),G(c,8)); \\\n  else if (test_mode == PCRE16_MODE) G(a,16)(G(b,16),G(c,16)); \\\n  else G(a,32)(G(b,32),G(c,32))\n\n#define TEST(x,r,y) ( \\\n  (test_mode == PCRE8_MODE && G(x,8) r (y)) || \\\n  (test_mode == PCRE16_MODE && G(x,16) r (y)) || \\\n  (test_mode == PCRE32_MODE && G(x,32) r (y)))\n\n#define TESTFLD(x,f,r,y) ( \\\n  (test_mode == PCRE8_MODE && G(x,8)->f r (y)) || \\\n  (test_mode == PCRE16_MODE && G(x,16)->f r (y)) || \\\n  (test_mode == PCRE32_MODE && G(x,32)->f r (y)))\n\n\n/* ----- Two out of three modes are supported ----- */\n\n#else\n\n/* We can use some macro trickery to make a single set of definitions work in\nthe three different cases. */\n\n/* ----- 32-bit and 16-bit but not 8-bit supported ----- */\n\n#if defined(SUPPORT_PCRE2_32) && defined(SUPPORT_PCRE2_16)\n#define BITONE 32\n#define BITTWO 16\n\n/* ----- 32-bit and 8-bit but not 16-bit supported ----- */\n\n#elif defined(SUPPORT_PCRE2_32) && defined(SUPPORT_PCRE2_8)\n#define BITONE 32\n#define BITTWO 8\n\n/* ----- 16-bit and 8-bit but not 32-bit supported ----- */\n\n#else\n#define BITONE 16\n#define BITTWO 8\n#endif\n\n\n/* ----- Common macros for two-mode cases ----- */\n\n#define BYTEONE (BITONE/8)\n#define BYTETWO (BITTWO/8)\n\n#define CASTFLD(t,a,b) \\\n  ((test_mode == G(G(PCRE,BITONE),_MODE))? (t)(G(a,BITONE)->b) : \\\n    (t)(G(a,BITTWO)->b))\n\n#define CASTVAR(t,x) ( \\\n  (test_mode == G(G(PCRE,BITONE),_MODE))? \\\n    (t)G(x,BITONE) : (t)G(x,BITTWO))\n\n#define CODE_UNIT(a,b) ( \\\n  (test_mode == G(G(PCRE,BITONE),_MODE))? \\\n  (uint32_t)(((G(PCRE2_SPTR,BITONE))(a))\u00ddb\u00a8) : \\\n  (uint32_t)(((G(PCRE2_SPTR,BITTWO))(a))\u00ddb\u00a8))\n\n#define CONCTXCPY(a,b) \\\n  if (test_mode == G(G(PCRE,BITONE),_MODE)) \\\n    memcpy(G(a,BITONE),G(b,BITONE),sizeof(G(pcre2_convert_context_,BITONE))); \\\n  else \\\n    memcpy(G(a,BITTWO),G(b,BITTWO),sizeof(G(pcre2_convert_context_,BITTWO)))\n\n#define CONVERT_COPY(a,b,c) \\\n  (test_mode == G(G(PCRE,BITONE),_MODE))? \\\n  memcpy(G(a,BITONE),(char *)b,(c)*BYTEONE) : \\\n  memcpy(G(a,BITTWO),(char *)b,(c)*BYTETWO)\n\n#define DATCTXCPY(a,b) \\\n  if (test_mode == G(G(PCRE,BITONE),_MODE)) \\\n    memcpy(G(a,BITONE),G(b,BITONE),sizeof(G(pcre2_match_context_,BITONE))); \\\n  else \\\n    memcpy(G(a,BITTWO),G(b,BITTWO),sizeof(G(pcre2_match_context_,BITTWO)))\n\n#define FLD(a,b) \\\n  ((test_mode == G(G(PCRE,BITONE),_MODE))? G(a,BITONE)->b : G(a,BITTWO)->b)\n\n#define PATCTXCPY(a,b) \\\n  if (test_mode == G(G(PCRE,BITONE),_MODE)) \\\n    memcpy(G(a,BITONE),G(b,BITONE),sizeof(G(pcre2_compile_context_,BITONE))); \\\n  else \\\n    memcpy(G(a,BITTWO),G(b,BITTWO),sizeof(G(pcre2_compile_context_,BITTWO)))\n\n#define PCHARS(lv, p, offset, len, utf, f) \\\n  if (test_mode == G(G(PCRE,BITONE),_MODE)) \\\n    lv = G(pchars,BITONE)((G(PCRE2_SPTR,BITONE))(p)+offset, len, utf, f); \\\n  else \\\n    lv = G(pchars,BITTWO)((G(PCRE2_SPTR,BITTWO))(p)+offset, len, utf, f)\n\n#define PCHARSV(p, offset, len, utf, f) \\\n  if (test_mode == G(G(PCRE,BITONE),_MODE)) \\\n    (void)G(pchars,BITONE)((G(PCRE2_SPTR,BITONE))(p)+offset, len, utf, f); \\\n  else \\\n    (void)G(pchars,BITTWO)((G(PCRE2_SPTR,BITTWO))(p)+offset, len, utf, f)\n\n#define PCRE2_CALLOUT_ENUMERATE(a,b,c) \\\n  if (test_mode == G(G(PCRE,BITONE),_MODE)) \\\n     a = G(pcre2_callout_enumerate,BITONE)(G(compiled_code,BITONE), \\\n       (int (*)(struct G(pcre2_callout_enumerate_block_,BITONE) *, void *))b,c); \\\n  else \\\n     a = G(pcre2_callout_enumerate,BITTWO)(G(compiled_code,BITTWO), \\\n       (int (*)(struct G(pcre2_callout_enumerate_block_,BITTWO) *, void *))b,c)\n\n#define PCRE2_CODE_COPY_FROM_VOID(a,b) \\\n  if (test_mode == G(G(PCRE,BITONE),_MODE)) \\\n    G(a,BITONE) = G(pcre2_code_copy_,BITONE)(b); \\\n  else \\\n    G(a,BITTWO) = G(pcre2_code_copy_,BITTWO)(b)\n\n#define PCRE2_CODE_COPY_TO_VOID(a,b) \\\n  if (test_mode == G(G(PCRE,BITONE),_MODE)) \\\n    a = (void *)G(pcre2_code_copy_,BITONE)(G(b,BITONE)); \\\n  else \\\n    a = (void *)G(pcre2_code_copy_,BITTWO)(G(b,BITTWO))\n\n#define PCRE2_CODE_COPY_WITH_TABLES_TO_VOID(a,b) \\\n  if (test_mode == G(G(PCRE,BITONE),_MODE)) \\\n    a = (void *)G(pcre2_code_copy_with_tables_,BITONE)(G(b,BITONE)); \\\n  else \\\n    a = (void *)G(pcre2_code_copy_with_tables_,BITTWO)(G(b,BITTWO))\n\n#define PCRE2_COMPILE(a,b,c,d,e,f,g) \\\n  if (test_mode == G(G(PCRE,BITONE),_MODE)) \\\n    G(a,BITONE) = G(pcre2_compile_,BITONE)(G(b,BITONE),c,d,e,f,g); \\\n  else \\\n    G(a,BITTWO) = G(pcre2_compile_,BITTWO)(G(b,BITTWO),c,d,e,f,g)\n\n#define PCRE2_CONVERTED_PATTERN_FREE(a) \\\n  if (test_mode == G(G(PCRE,BITONE),_MODE)) \\\n    G(pcre2_converted_pattern_free_,BITONE)((G(PCRE2_UCHAR,BITONE) *)a); \\\n  else \\\n    G(pcre2_converted_pattern_free_,BITTWO)((G(PCRE2_UCHAR,BITTWO) *)a)\n\n#define PCRE2_DFA_MATCH(a,b,c,d,e,f,g,h,i,j) \\\n  if (test_mode == G(G(PCRE,BITONE),_MODE)) \\\n    a = G(pcre2_dfa_match_,BITONE)(G(b,BITONE),(G(PCRE2_SPTR,BITONE))c,d,e,f, \\\n      G(g,BITONE),h,i,j); \\\n  else \\\n    a = G(pcre2_dfa_match_,BITTWO)(G(b,BITTWO),(G(PCRE2_SPTR,BITTWO))c,d,e,f, \\\n      G(g,BITTWO),h,i,j)\n\n#define PCRE2_GET_ERROR_MESSAGE(r,a,b) \\\n  if (test_mode == G(G(PCRE,BITONE),_MODE)) \\\n    r = G(pcre2_get_error_message_,BITONE)(a,G(b,BITONE),G(G(b,BITONE),_size/BYTEONE)); \\\n  else \\\n    r = G(pcre2_get_error_message_,BITTWO)(a,G(b,BITTWO),G(G(b,BITTWO),_size/BYTETWO))\n\n#define PCRE2_GET_OVECTOR_COUNT(a,b) \\\n  if (test_mode == G(G(PCRE,BITONE),_MODE)) \\\n    a = G(pcre2_get_ovector_count_,BITONE)(G(b,BITONE)); \\\n  else \\\n    a = G(pcre2_get_ovector_count_,BITTWO)(G(b,BITTWO))\n\n#define PCRE2_GET_STARTCHAR(a,b) \\\n  if (test_mode == G(G(PCRE,BITONE),_MODE)) \\\n    a = G(pcre2_get_startchar_,BITONE)(G(b,BITONE)); \\\n  else \\\n    a = G(pcre2_get_startchar_,BITTWO)(G(b,BITTWO))\n\n#define PCRE2_JIT_COMPILE(r,a,b) \\\n  if (test_mode == G(G(PCRE,BITONE),_MODE)) \\\n    r = G(pcre2_jit_compile_,BITONE)(G(a,BITONE),b); \\\n  else \\\n    r = G(pcre2_jit_compile_,BITTWO)(G(a,BITTWO),b)\n\n#define PCRE2_JIT_FREE_UNUSED_MEMORY(a) \\\n  if (test_mode == G(G(PCRE,BITONE),_MODE)) \\\n    G(pcre2_jit_free_unused_memory_,BITONE)(G(a,BITONE)); \\\n  else \\\n    G(pcre2_jit_free_unused_memory_,BITTWO)(G(a,BITTWO))\n\n#define PCRE2_JIT_MATCH(a,b,c,d,e,f,g,h) \\\n  if (test_mode == G(G(PCRE,BITONE),_MODE)) \\\n    a = G(pcre2_jit_match_,BITONE)(G(b,BITONE),(G(PCRE2_SPTR,BITONE))c,d,e,f, \\\n      G(g,BITONE),h); \\\n  else \\\n    a = G(pcre2_jit_match_,BITTWO)(G(b,BITTWO),(G(PCRE2_SPTR,BITTWO))c,d,e,f, \\\n      G(g,BITTWO),h)\n\n#define PCRE2_JIT_STACK_CREATE(a,b,c,d) \\\n  if (test_mode == G(G(PCRE,BITONE),_MODE)) \\\n    a = (PCRE2_JIT_STACK *)G(pcre2_jit_stack_create_,BITONE)(b,c,d); \\\n  else \\\n    a = (PCRE2_JIT_STACK *)G(pcre2_jit_stack_create_,BITTWO)(b,c,d); \\\n\n#define PCRE2_JIT_STACK_ASSIGN(a,b,c) \\\n  if (test_mode == G(G(PCRE,BITONE),_MODE)) \\\n    G(pcre2_jit_stack_assign_,BITONE)(G(a,BITONE),(G(pcre2_jit_callback_,BITONE))b,c); \\\n  else \\\n    G(pcre2_jit_stack_assign_,BITTWO)(G(a,BITTWO),(G(pcre2_jit_callback_,BITTWO))b,c);\n\n#define PCRE2_JIT_STACK_FREE(a) \\\n  if (test_mode == G(G(PCRE,BITONE),_MODE)) \\\n    G(pcre2_jit_stack_free_,BITONE)((G(pcre2_jit_stack_,BITONE) *)a); \\\n  else \\\n    G(pcre2_jit_stack_free_,BITTWO)((G(pcre2_jit_stack_,BITTWO) *)a);\n\n#define PCRE2_MAKETABLES(a) \\\n  if (test_mode == G(G(PCRE,BITONE),_MODE)) \\\n    a = G(pcre2_maketables_,BITONE)(NULL); \\\n  else \\\n    a = G(pcre2_maketables_,BITTWO)(NULL)\n\n#define PCRE2_MATCH(a,b,c,d,e,f,g,h) \\\n  if (test_mode == G(G(PCRE,BITONE),_MODE)) \\\n    a = G(pcre2_match_,BITONE)(G(b,BITONE),(G(PCRE2_SPTR,BITONE))c,d,e,f, \\\n      G(g,BITONE),h); \\\n  else \\\n    a = G(pcre2_match_,BITTWO)(G(b,BITTWO),(G(PCRE2_SPTR,BITTWO))c,d,e,f, \\\n      G(g,BITTWO),h)\n\n#define PCRE2_MATCH_DATA_CREATE(a,b,c) \\\n  if (test_mode == G(G(PCRE,BITONE),_MODE)) \\\n    G(a,BITONE) = G(pcre2_match_data_create_,BITONE)(b,c); \\\n  else \\\n    G(a,BITTWO) = G(pcre2_match_data_create_,BITTWO)(b,c)\n\n#define PCRE2_MATCH_DATA_CREATE_FROM_PATTERN(a,b,c) \\\n  if (test_mode == G(G(PCRE,BITONE),_MODE)) \\\n    G(a,BITONE) = G(pcre2_match_data_create_from_pattern_,BITONE)(G(b,BITONE),c); \\\n  else \\\n    G(a,BITTWO) = G(pcre2_match_data_create_from_pattern_,BITTWO)(G(b,BITTWO),c)\n\n#define PCRE2_MATCH_DATA_FREE(a) \\\n  if (test_mode == G(G(PCRE,BITONE),_MODE)) \\\n    G(pcre2_match_data_free_,BITONE)(G(a,BITONE)); \\\n  else \\\n    G(pcre2_match_data_free_,BITTWO)(G(a,BITTWO))\n\n#define PCRE2_PATTERN_CONVERT(a,b,c,d,e,f,g) \\\n  if (test_mode == G(G(PCRE,BITONE),_MODE)) \\\n    a = G(pcre2_pattern_convert_,BITONE)(G(b,BITONE),c,d,(G(PCRE2_UCHAR,BITONE) **)e,f,G(g,BITONE)); \\\n  else \\\n    a = G(pcre2_pattern_convert_,BITTWO)(G(b,BITTWO),c,d,(G(PCRE2_UCHAR,BITTWO) **)e,f,G(g,BITTWO))\n\n#define PCRE2_PATTERN_INFO(a,b,c,d) \\\n  if (test_mode == G(G(PCRE,BITONE),_MODE)) \\\n    a = G(pcre2_pattern_info_,BITONE)(G(b,BITONE),c,d); \\\n  else \\\n    a = G(pcre2_pattern_info_,BITTWO)(G(b,BITTWO),c,d)\n\n#define PCRE2_PRINTINT(a) \\\n if (test_mode == G(G(PCRE,BITONE),_MODE)) \\\n    G(pcre2_printint_,BITONE)(G(compiled_code,BITONE),outfile,a); \\\n  else \\\n    G(pcre2_printint_,BITTWO)(G(compiled_code,BITTWO),outfile,a)\n\n#define PCRE2_SERIALIZE_DECODE(r,a,b,c,d) \\\n if (test_mode == G(G(PCRE,BITONE),_MODE)) \\\n    r = G(pcre2_serialize_decode_,BITONE)((G(pcre2_code_,BITONE) **)a,b,c,G(d,BITONE)); \\\n  else \\\n    r = G(pcre2_serialize_decode_,BITTWO)((G(pcre2_code_,BITTWO) **)a,b,c,G(d,BITTWO))\n\n#define PCRE2_SERIALIZE_ENCODE(r,a,b,c,d,e) \\\n if (test_mode == G(G(PCRE,BITONE),_MODE)) \\\n    r = G(pcre2_serialize_encode_,BITONE)((G(const pcre2_code_,BITONE) **)a,b,c,d,G(e,BITONE)); \\\n  else \\\n    r = G(pcre2_serialize_encode_,BITTWO)((G(const pcre2_code_,BITTWO) **)a,b,c,d,G(e,BITTWO))\n\n#define PCRE2_SERIALIZE_FREE(a) \\\n if (test_mode == G(G(PCRE,BITONE),_MODE)) \\\n    G(pcre2_serialize_free_,BITONE)(a); \\\n  else \\\n    G(pcre2_serialize_free_,BITTWO)(a)\n\n#define PCRE2_SERIALIZE_GET_NUMBER_OF_CODES(r,a) \\\n if (test_mode == G(G(PCRE,BITONE),_MODE)) \\\n    r = G(pcre2_serialize_get_number_of_codes_,BITONE)(a); \\\n  else \\\n    r = G(pcre2_serialize_get_number_of_codes_,BITTWO)(a)\n\n#define PCRE2_SET_CALLOUT(a,b,c) \\\n  if (test_mode == G(G(PCRE,BITONE),_MODE)) \\\n    G(pcre2_set_callout_,BITONE)(G(a,BITONE), \\\n      (int (*)(G(pcre2_callout_block_,BITONE) *, void *))b,c); \\\n  else \\\n    G(pcre2_set_callout_,BITTWO)(G(a,BITTWO), \\\n      (int (*)(G(pcre2_callout_block_,BITTWO) *, void *))b,c);\n\n#define PCRE2_SET_CHARACTER_TABLES(a,b) \\\n  if (test_mode == G(G(PCRE,BITONE),_MODE)) \\\n    G(pcre2_set_character_tables_,BITONE)(G(a,BITONE),b); \\\n  else \\\n    G(pcre2_set_character_tables_,BITTWO)(G(a,BITTWO),b)\n\n#define PCRE2_SET_COMPILE_RECURSION_GUARD(a,b,c) \\\n  if (test_mode == G(G(PCRE,BITONE),_MODE)) \\\n    G(pcre2_set_compile_recursion_guard_,BITONE)(G(a,BITONE),b,c); \\\n  else \\\n    G(pcre2_set_compile_recursion_guard_,BITTWO)(G(a,BITTWO),b,c)\n\n#define PCRE2_SET_DEPTH_LIMIT(a,b) \\\n  if (test_mode == G(G(PCRE,BITONE),_MODE)) \\\n    G(pcre2_set_depth_limit_,BITONE)(G(a,BITONE),b); \\\n  else \\\n    G(pcre2_set_depth_limit_,BITTWO)(G(a,BITTWO),b)\n\n#define PCRE2_SET_GLOB_ESCAPE(r,a,b) \\\n  if (test_mode == G(G(PCRE,BITONE),_MODE)) \\\n    r = G(pcre2_set_glob_escape_,BITONE)(G(a,BITONE),b); \\\n  else \\\n    r = G(pcre2_set_glob_escape_,BITTWO)(G(a,BITTWO),b)\n\n#define PCRE2_SET_GLOB_SEPARATOR(r,a,b) \\\n  if (test_mode == G(G(PCRE,BITONE),_MODE)) \\\n    r = G(pcre2_set_glob_separator_,BITONE)(G(a,BITONE),b); \\\n  else \\\n    r = G(pcre2_set_glob_separator_,BITTWO)(G(a,BITTWO),b)\n\n#define PCRE2_SET_HEAP_LIMIT(a,b) \\\n  if (test_mode == G(G(PCRE,BITONE),_MODE)) \\\n    G(pcre2_set_heap_limit_,BITONE)(G(a,BITONE),b); \\\n  else \\\n    G(pcre2_set_heap_limit_,BITTWO)(G(a,BITTWO),b)\n\n#define PCRE2_SET_MATCH_LIMIT(a,b) \\\n  if (test_mode == G(G(PCRE,BITONE),_MODE)) \\\n    G(pcre2_set_match_limit_,BITONE)(G(a,BITONE),b); \\\n  else \\\n    G(pcre2_set_match_limit_,BITTWO)(G(a,BITTWO),b)\n\n#define PCRE2_SET_MAX_PATTERN_LENGTH(a,b) \\\n  if (test_mode == G(G(PCRE,BITONE),_MODE)) \\\n    G(pcre2_set_max_pattern_length_,BITONE)(G(a,BITONE),b); \\\n  else \\\n    G(pcre2_set_max_pattern_length_,BITTWO)(G(a,BITTWO),b)\n\n#define PCRE2_SET_OFFSET_LIMIT(a,b) \\\n  if (test_mode == G(G(PCRE,BITONE),_MODE)) \\\n    G(pcre2_set_offset_limit_,BITONE)(G(a,BITONE),b); \\\n  else \\\n    G(pcre2_set_offset_limit_,BITTWO)(G(a,BITTWO),b)\n\n#define PCRE2_SET_PARENS_NEST_LIMIT(a,b) \\\n  if (test_mode == G(G(PCRE,BITONE),_MODE)) \\\n    G(pcre2_set_parens_nest_limit_,BITONE)(G(a,BITONE),b); \\\n  else \\\n    G(pcre2_set_parens_nest_limit_,BITTWO)(G(a,BITTWO),b)\n\n#define PCRE2_SET_SUBSTITUTE_CALLOUT(a,b,c) \\\n  if (test_mode == G(G(PCRE,BITONE),_MODE)) \\\n    G(pcre2_set_substitute_callout_,BITONE)(G(a,BITONE), \\\n      (int (*)(G(pcre2_substitute_callout_block_,BITONE) *, void *))b,c); \\\n  else \\\n    G(pcre2_set_substitute_callout_,BITTWO)(G(a,BITTWO), \\\n      (int (*)(G(pcre2_substitute_callout_block_,BITTWO) *, void *))b,c)\n\n#define PCRE2_SUBSTITUTE(a,b,c,d,e,f,g,h,i,j,k,l) \\\n  if (test_mode == G(G(PCRE,BITONE),_MODE)) \\\n    a = G(pcre2_substitute_,BITONE)(G(b,BITONE),(G(PCRE2_SPTR,BITONE))c,d,e,f, \\\n      G(g,BITONE),h,(G(PCRE2_SPTR,BITONE))i,j, \\\n      (G(PCRE2_UCHAR,BITONE) *)k,l); \\\n  else \\\n    a = G(pcre2_substitute_,BITTWO)(G(b,BITTWO),(G(PCRE2_SPTR,BITTWO))c,d,e,f, \\\n      G(g,BITTWO),h,(G(PCRE2_SPTR,BITTWO))i,j, \\\n      (G(PCRE2_UCHAR,BITTWO) *)k,l)\n\n#define PCRE2_SUBSTRING_COPY_BYNAME(a,b,c,d,e) \\\n  if (test_mode == G(G(PCRE,BITONE),_MODE)) \\\n    a = G(pcre2_substring_copy_byname_,BITONE)(G(b,BITONE),G(c,BITONE),\\\n      (G(PCRE2_UCHAR,BITONE) *)d,e); \\\n  else \\\n    a = G(pcre2_substring_copy_byname_,BITTWO)(G(b,BITTWO),G(c,BITTWO),\\\n      (G(PCRE2_UCHAR,BITTWO) *)d,e)\n\n#define PCRE2_SUBSTRING_COPY_BYNUMBER(a,b,c,d,e) \\\n  if (test_mode == G(G(PCRE,BITONE),_MODE)) \\\n    a = G(pcre2_substring_copy_bynumber_,BITONE)(G(b,BITONE),c,\\\n      (G(PCRE2_UCHAR,BITONE) *)d,e); \\\n  else \\\n    a = G(pcre2_substring_copy_bynumber_,BITTWO)(G(b,BITTWO),c,\\\n      (G(PCRE2_UCHAR,BITTWO) *)d,e)\n\n#define PCRE2_SUBSTRING_FREE(a) \\\n  if (test_mode == G(G(PCRE,BITONE),_MODE)) \\\n    G(pcre2_substring_free_,BITONE)((G(PCRE2_UCHAR,BITONE) *)a); \\\n  else G(pcre2_substring_free_,BITTWO)((G(PCRE2_UCHAR,BITTWO) *)a)\n\n#define PCRE2_SUBSTRING_GET_BYNAME(a,b,c,d,e) \\\n  if (test_mode == G(G(PCRE,BITONE),_MODE)) \\\n    a = G(pcre2_substring_get_byname_,BITONE)(G(b,BITONE),G(c,BITONE),\\\n      (G(PCRE2_UCHAR,BITONE) **)d,e); \\\n  else \\\n    a = G(pcre2_substring_get_byname_,BITTWO)(G(b,BITTWO),G(c,BITTWO),\\\n      (G(PCRE2_UCHAR,BITTWO) **)d,e)\n\n#define PCRE2_SUBSTRING_GET_BYNUMBER(a,b,c,d,e) \\\n  if (test_mode == G(G(PCRE,BITONE),_MODE)) \\\n    a = G(pcre2_substring_get_bynumber_,BITONE)(G(b,BITONE),c,\\\n      (G(PCRE2_UCHAR,BITONE) **)d,e); \\\n  else \\\n    a = G(pcre2_substring_get_bynumber_,BITTWO)(G(b,BITTWO),c,\\\n      (G(PCRE2_UCHAR,BITTWO) **)d,e)\n\n#define PCRE2_SUBSTRING_LENGTH_BYNAME(a,b,c,d) \\\n  if (test_mode == G(G(PCRE,BITONE),_MODE)) \\\n    a = G(pcre2_substring_length_byname_,BITONE)(G(b,BITONE),G(c,BITONE),d); \\\n  else \\\n    a = G(pcre2_substring_length_byname_,BITTWO)(G(b,BITTWO),G(c,BITTWO),d)\n\n#define PCRE2_SUBSTRING_LENGTH_BYNUMBER(a,b,c,d) \\\n  if (test_mode == G(G(PCRE,BITONE),_MODE)) \\\n    a = G(pcre2_substring_length_bynumber_,BITONE)(G(b,BITONE),c,d); \\\n  else \\\n    a = G(pcre2_substring_length_bynumber_,BITTWO)(G(b,BITTWO),c,d)\n\n#define PCRE2_SUBSTRING_LIST_GET(a,b,c,d) \\\n  if (test_mode == G(G(PCRE,BITONE),_MODE)) \\\n    a = G(pcre2_substring_list_get_,BITONE)(G(b,BITONE), \\\n      (G(PCRE2_UCHAR,BITONE) ***)c,d); \\\n  else \\\n    a = G(pcre2_substring_list_get_,BITTWO)(G(b,BITTWO), \\\n      (G(PCRE2_UCHAR,BITTWO) ***)c,d)\n\n#define PCRE2_SUBSTRING_LIST_FREE(a) \\\n  if (test_mode == G(G(PCRE,BITONE),_MODE)) \\\n    G(pcre2_substring_list_free_,BITONE)((G(PCRE2_SPTR,BITONE) *)a); \\\n  else \\\n    G(pcre2_substring_list_free_,BITTWO)((G(PCRE2_SPTR,BITTWO) *)a)\n\n#define PCRE2_SUBSTRING_NUMBER_FROM_NAME(a,b,c) \\\n  if (test_mode == G(G(PCRE,BITONE),_MODE)) \\\n    a = G(pcre2_substring_number_from_name_,BITONE)(G(b,BITONE),G(c,BITONE)); \\\n  else \\\n    a = G(pcre2_substring_number_from_name_,BITTWO)(G(b,BITTWO),G(c,BITTWO))\n\n#define PTR(x) ( \\\n  (test_mode == G(G(PCRE,BITONE),_MODE))? (void *)G(x,BITONE) : \\\n  (void *)G(x,BITTWO))\n\n#define SETFLD(x,y,z) \\\n  if (test_mode == G(G(PCRE,BITONE),_MODE)) G(x,BITONE)->y = z; \\\n  else G(x,BITTWO)->y = z\n\n#define SETFLDVEC(x,y,v,z) \\\n  if (test_mode == G(G(PCRE,BITONE),_MODE)) G(x,BITONE)->y\u00ddv\u00a8 = z; \\\n  else G(x,BITTWO)->y\u00ddv\u00a8 = z\n\n#define SETOP(x,y,z) \\\n  if (test_mode == G(G(PCRE,BITONE),_MODE)) G(x,BITONE) z y; \\\n  else G(x,BITTWO) z y\n\n#define SETCASTPTR(x,y) \\\n  if (test_mode == G(G(PCRE,BITONE),_MODE)) \\\n    G(x,BITONE) = (G(G(uint,BITONE),_t) *)(y); \\\n  else \\\n    G(x,BITTWO) = (G(G(uint,BITTWO),_t) *)(y)\n\n#define STRLEN(p) ((test_mode == G(G(PCRE,BITONE),_MODE))? \\\n  G(strlen,BITONE)((G(PCRE2_SPTR,BITONE))p) : \\\n  G(strlen,BITTWO)((G(PCRE2_SPTR,BITTWO))p))\n\n#define SUB1(a,b) \\\n  if (test_mode == G(G(PCRE,BITONE),_MODE)) \\\n    G(a,BITONE)(G(b,BITONE)); \\\n  else \\\n    G(a,BITTWO)(G(b,BITTWO))\n\n#define SUB2(a,b,c) \\\n  if (test_mode == G(G(PCRE,BITONE),_MODE)) \\\n    G(a,BITONE))(G(b,BITONE),G(c,BITONE)); \\\n  else \\\n    G(a,BITTWO))(G(b,BITTWO),G(c,BITTWO))\n\n#define TEST(x,r,y) ( \\\n  (test_mode == G(G(PCRE,BITONE),_MODE) && G(x,BITONE) r (y)) || \\\n  (test_mode == G(G(PCRE,BITTWO),_MODE) && G(x,BITTWO) r (y)))\n\n#define TESTFLD(x,f,r,y) ( \\\n  (test_mode == G(G(PCRE,BITONE),_MODE) && G(x,BITONE)->f r (y)) || \\\n  (test_mode == G(G(PCRE,BITTWO),_MODE) && G(x,BITTWO)->f r (y)))\n\n\n#endif  /* Two out of three modes */\n\n/* ----- End of cases where more than one mode is supported ----- */\n\n\n/* ----- Only 8-bit mode is supported ----- */\n\n#elif defined SUPPORT_PCRE2_8\n#define CASTFLD(t,a,b) (t)(G(a,8)->b)\n#define CASTVAR(t,x) (t)G(x,8)\n#define CODE_UNIT(a,b) (uint32_t)(((PCRE2_SPTR8)(a))\u00ddb\u00a8)\n#define CONCTXCPY(a,b) memcpy(G(a,8),G(b,8),sizeof(pcre2_convert_context_8))\n#define CONVERT_COPY(a,b,c) memcpy(G(a,8),(char *)b, c)\n#define DATCTXCPY(a,b) memcpy(G(a,8),G(b,8),sizeof(pcre2_match_context_8))\n#define FLD(a,b) G(a,8)->b\n#define PATCTXCPY(a,b) memcpy(G(a,8),G(b,8),sizeof(pcre2_compile_context_8))\n#define PCHARS(lv, p, offset, len, utf, f) \\\n  lv = pchars8((PCRE2_SPTR8)(p)+offset, len, utf, f)\n#define PCHARSV(p, offset, len, utf, f) \\\n  (void)pchars8((PCRE2_SPTR8)(p)+offset, len, utf, f)\n#define PCRE2_CALLOUT_ENUMERATE(a,b,c) \\\n   a = pcre2_callout_enumerate_8(compiled_code8, \\\n     (int (*)(struct pcre2_callout_enumerate_block_8 *, void *))b,c)\n#define PCRE2_CODE_COPY_FROM_VOID(a,b) G(a,8) = pcre2_code_copy_8(b)\n#define PCRE2_CODE_COPY_TO_VOID(a,b) a = (void *)pcre2_code_copy_8(G(b,8))\n#define PCRE2_CODE_COPY_WITH_TABLES_TO_VOID(a,b) a = (void *)pcre2_code_copy_with_tables_8(G(b,8))\n#define PCRE2_COMPILE(a,b,c,d,e,f,g) \\\n  G(a,8) = pcre2_compile_8(G(b,8),c,d,e,f,g)\n#define PCRE2_CONVERTED_PATTERN_FREE(a) \\\n  pcre2_converted_pattern_free_8((PCRE2_UCHAR8 *)a)\n#define PCRE2_DFA_MATCH(a,b,c,d,e,f,g,h,i,j) \\\n  a = pcre2_dfa_match_8(G(b,8),(PCRE2_SPTR8)c,d,e,f,G(g,8),h,i,j)\n#define PCRE2_GET_ERROR_MESSAGE(r,a,b) \\\n  r = pcre2_get_error_message_8(a,G(b,8),G(G(b,8),_size))\n#define PCRE2_GET_OVECTOR_COUNT(a,b) a = pcre2_get_ovector_count_8(G(b,8))\n#define PCRE2_GET_STARTCHAR(a,b) a = pcre2_get_startchar_8(G(b,8))\n#define PCRE2_JIT_COMPILE(r,a,b) r = pcre2_jit_compile_8(G(a,8),b)\n#define PCRE2_JIT_FREE_UNUSED_MEMORY(a) pcre2_jit_free_unused_memory_8(G(a,8))\n#define PCRE2_JIT_MATCH(a,b,c,d,e,f,g,h) \\\n  a = pcre2_jit_match_8(G(b,8),(PCRE2_SPTR8)c,d,e,f,G(g,8),h)\n#define PCRE2_JIT_STACK_CREATE(a,b,c,d) \\\n  a = (PCRE2_JIT_STACK *)pcre2_jit_stack_create_8(b,c,d);\n#define PCRE2_JIT_STACK_ASSIGN(a,b,c) \\\n  pcre2_jit_stack_assign_8(G(a,8),(pcre2_jit_callback_8)b,c);\n#define PCRE2_JIT_STACK_FREE(a) pcre2_jit_stack_free_8((pcre2_jit_stack_8 *)a);\n#define PCRE2_MAKETABLES(a) a = pcre2_maketables_8(NULL)\n#define PCRE2_MATCH(a,b,c,d,e,f,g,h) \\\n  a = pcre2_match_8(G(b,8),(PCRE2_SPTR8)c,d,e,f,G(g,8),h)\n#define PCRE2_MATCH_DATA_CREATE(a,b,c) G(a,8) = pcre2_match_data_create_8(b,c)\n#define PCRE2_MATCH_DATA_CREATE_FROM_PATTERN(a,b,c) \\\n  G(a,8) = pcre2_match_data_create_from_pattern_8(G(b,8),c)\n#define PCRE2_MATCH_DATA_FREE(a) pcre2_match_data_free_8(G(a,8))\n#define PCRE2_PATTERN_CONVERT(a,b,c,d,e,f,g) a = pcre2_pattern_convert_8(G(b,8),c,d,(PCRE2_UCHAR8 **)e,f,G(g,8))\n#define PCRE2_PATTERN_INFO(a,b,c,d) a = pcre2_pattern_info_8(G(b,8),c,d)\n#define PCRE2_PRINTINT(a) pcre2_printint_8(compiled_code8,outfile,a)\n#define PCRE2_SERIALIZE_DECODE(r,a,b,c,d) \\\n  r = pcre2_serialize_decode_8((pcre2_code_8 **)a,b,c,G(d,8))\n#define PCRE2_SERIALIZE_ENCODE(r,a,b,c,d,e) \\\n  r = pcre2_serialize_encode_8((const pcre2_code_8 **)a,b,c,d,G(e,8))\n#define PCRE2_SERIALIZE_FREE(a) pcre2_serialize_free_8(a)\n#define PCRE2_SERIALIZE_GET_NUMBER_OF_CODES(r,a) \\\n  r = pcre2_serialize_get_number_of_codes_8(a)\n#define PCRE2_SET_CALLOUT(a,b,c) \\\n  pcre2_set_callout_8(G(a,8),(int (*)(pcre2_callout_block_8 *, void *))b,c)\n#define PCRE2_SET_CHARACTER_TABLES(a,b) pcre2_set_character_tables_8(G(a,8),b)\n#define PCRE2_SET_COMPILE_RECURSION_GUARD(a,b,c) \\\n  pcre2_set_compile_recursion_guard_8(G(a,8),b,c)\n#define PCRE2_SET_DEPTH_LIMIT(a,b) pcre2_set_depth_limit_8(G(a,8),b)\n#define PCRE2_SET_GLOB_ESCAPE(r,a,b) r = pcre2_set_glob_escape_8(G(a,8),b)\n#define PCRE2_SET_GLOB_SEPARATOR(r,a,b) r = pcre2_set_glob_separator_8(G(a,8),b)\n#define PCRE2_SET_HEAP_LIMIT(a,b) pcre2_set_heap_limit_8(G(a,8),b)\n#define PCRE2_SET_MATCH_LIMIT(a,b) pcre2_set_match_limit_8(G(a,8),b)\n#define PCRE2_SET_MAX_PATTERN_LENGTH(a,b) pcre2_set_max_pattern_length_8(G(a,8),b)\n#define PCRE2_SET_OFFSET_LIMIT(a,b) pcre2_set_offset_limit_8(G(a,8),b)\n#define PCRE2_SET_PARENS_NEST_LIMIT(a,b) pcre2_set_parens_nest_limit_8(G(a,8),b)\n#define PCRE2_SET_SUBSTITUTE_CALLOUT(a,b,c) \\\n  pcre2_set_substitute_callout_8(G(a,8), \\\n    (int (*)(pcre2_substitute_callout_block_8 *, void *))b,c)\n#define PCRE2_SUBSTITUTE(a,b,c,d,e,f,g,h,i,j,k,l) \\\n  a = pcre2_substitute_8(G(b,8),(PCRE2_SPTR8)c,d,e,f,G(g,8),h, \\\n    (PCRE2_SPTR8)i,j,(PCRE2_UCHAR8 *)k,l)\n#define PCRE2_SUBSTRING_COPY_BYNAME(a,b,c,d,e) \\\n  a = pcre2_substring_copy_byname_8(G(b,8),G(c,8),(PCRE2_UCHAR8 *)d,e)\n#define PCRE2_SUBSTRING_COPY_BYNUMBER(a,b,c,d,e) \\\n  a = pcre2_substring_copy_bynumber_8(G(b,8),c,(PCRE2_UCHAR8 *)d,e)\n#define PCRE2_SUBSTRING_FREE(a) pcre2_substring_free_8((PCRE2_UCHAR8 *)a)\n#define PCRE2_SUBSTRING_GET_BYNAME(a,b,c,d,e) \\\n  a = pcre2_substring_get_byname_8(G(b,8),G(c,8),(PCRE2_UCHAR8 **)d,e)\n#define PCRE2_SUBSTRING_GET_BYNUMBER(a,b,c,d,e) \\\n  a = pcre2_substring_get_bynumber_8(G(b,8),c,(PCRE2_UCHAR8 **)d,e)\n#define PCRE2_SUBSTRING_LENGTH_BYNAME(a,b,c,d) \\\n    a = pcre2_substring_length_byname_8(G(b,8),G(c,8),d)\n#define PCRE2_SUBSTRING_LENGTH_BYNUMBER(a,b,c,d) \\\n    a = pcre2_substring_length_bynumber_8(G(b,8),c,d)\n#define PCRE2_SUBSTRING_LIST_GET(a,b,c,d) \\\n  a = pcre2_substring_list_get_8(G(b,8),(PCRE2_UCHAR8 ***)c,d)\n#define PCRE2_SUBSTRING_LIST_FREE(a) \\\n  pcre2_substring_list_free_8((PCRE2_SPTR8 *)a)\n#define PCRE2_SUBSTRING_NUMBER_FROM_NAME(a,b,c) \\\n  a = pcre2_substring_number_from_name_8(G(b,8),G(c,8));\n#define PTR(x) (void *)G(x,8)\n#define SETFLD(x,y,z) G(x,8)->y = z\n#define SETFLDVEC(x,y,v,z) G(x,8)->y\u00ddv\u00a8 = z\n#define SETOP(x,y,z) G(x,8) z y\n#define SETCASTPTR(x,y) G(x,8) = (uint8_t *)(y)\n#define STRLEN(p) (int)strlen((char *)p)\n#define SUB1(a,b) G(a,8)(G(b,8))\n#define SUB2(a,b,c) G(a,8)(G(b,8),G(c,8))\n#define TEST(x,r,y) (G(x,8) r (y))\n#define TESTFLD(x,f,r,y) (G(x,8)->f r (y))\n\n\n/* ----- Only 16-bit mode is supported ----- */\n\n#elif defined SUPPORT_PCRE2_16\n#define CASTFLD(t,a,b) (t)(G(a,16)->b)\n#define CASTVAR(t,x) (t)G(x,16)\n#define CODE_UNIT(a,b) (uint32_t)(((PCRE2_SPTR16)(a))\u00ddb\u00a8)\n#define CONCTXCPY(a,b) memcpy(G(a,16),G(b,16),sizeof(pcre2_convert_context_16))\n#define CONVERT_COPY(a,b,c) memcpy(G(a,16),(char *)b, (c)*2)\n#define DATCTXCPY(a,b) memcpy(G(a,16),G(b,16),sizeof(pcre2_match_context_16))\n#define FLD(a,b) G(a,16)->b\n#define PATCTXCPY(a,b) memcpy(G(a,16),G(b,16),sizeof(pcre2_compile_context_16))\n#define PCHARS(lv, p, offset, len, utf, f) \\\n  lv = pchars16((PCRE2_SPTR16)(p)+offset, len, utf, f)\n#define PCHARSV(p, offset, len, utf, f) \\\n  (void)pchars16((PCRE2_SPTR16)(p)+offset, len, utf, f)\n#define PCRE2_CALLOUT_ENUMERATE(a,b,c) \\\n   a = pcre2_callout_enumerate_16(compiled_code16, \\\n     (int (*)(struct pcre2_callout_enumerate_block_16 *, void *))b,c)\n#define PCRE2_CODE_COPY_FROM_VOID(a,b) G(a,16) = pcre2_code_copy_16(b)\n#define PCRE2_CODE_COPY_TO_VOID(a,b) a = (void *)pcre2_code_copy_16(G(b,16))\n#define PCRE2_CODE_COPY_WITH_TABLES_TO_VOID(a,b) a = (void *)pcre2_code_copy_with_tables_16(G(b,16))\n#define PCRE2_COMPILE(a,b,c,d,e,f,g) \\\n  G(a,16) = pcre2_compile_16(G(b,16),c,d,e,f,g)\n#define PCRE2_CONVERTED_PATTERN_FREE(a) \\\n  pcre2_converted_pattern_free_16((PCRE2_UCHAR16 *)a)\n#define PCRE2_DFA_MATCH(a,b,c,d,e,f,g,h,i,j) \\\n  a = pcre2_dfa_match_16(G(b,16),(PCRE2_SPTR16)c,d,e,f,G(g,16),h,i,j)\n#define PCRE2_GET_ERROR_MESSAGE(r,a,b) \\\n  r = pcre2_get_error_message_16(a,G(b,16),G(G(b,16),_size/2))\n#define PCRE2_GET_OVECTOR_COUNT(a,b) a = pcre2_get_ovector_count_16(G(b,16))\n#define PCRE2_GET_STARTCHAR(a,b) a = pcre2_get_startchar_16(G(b,16))\n#define PCRE2_JIT_COMPILE(r,a,b) r = pcre2_jit_compile_16(G(a,16),b)\n#define PCRE2_JIT_FREE_UNUSED_MEMORY(a) pcre2_jit_free_unused_memory_16(G(a,16))\n#define PCRE2_JIT_MATCH(a,b,c,d,e,f,g,h) \\\n  a = pcre2_jit_match_16(G(b,16),(PCRE2_SPTR16)c,d,e,f,G(g,16),h)\n#define PCRE2_JIT_STACK_CREATE(a,b,c,d) \\\n  a = (PCRE2_JIT_STACK *)pcre2_jit_stack_create_16(b,c,d);\n#define PCRE2_JIT_STACK_ASSIGN(a,b,c) \\\n  pcre2_jit_stack_assign_16(G(a,16),(pcre2_jit_callback_16)b,c);\n#define PCRE2_JIT_STACK_FREE(a) pcre2_jit_stack_free_16((pcre2_jit_stack_16 *)a);\n#define PCRE2_MAKETABLES(a) a = pcre2_maketables_16(NULL)\n#define PCRE2_MATCH(a,b,c,d,e,f,g,h) \\\n  a = pcre2_match_16(G(b,16),(PCRE2_SPTR16)c,d,e,f,G(g,16),h)\n#define PCRE2_MATCH_DATA_CREATE(a,b,c) G(a,16) = pcre2_match_data_create_16(b,c)\n#define PCRE2_MATCH_DATA_CREATE_FROM_PATTERN(a,b,c) \\\n  G(a,16) = pcre2_match_data_create_from_pattern_16(G(b,16),c)\n#define PCRE2_MATCH_DATA_FREE(a) pcre2_match_data_free_16(G(a,16))\n#define PCRE2_PATTERN_CONVERT(a,b,c,d,e,f,g) a = pcre2_pattern_convert_16(G(b,16),c,d,(PCRE2_UCHAR16 **)e,f,G(g,16))\n#define PCRE2_PATTERN_INFO(a,b,c,d) a = pcre2_pattern_info_16(G(b,16),c,d)\n#define PCRE2_PRINTINT(a) pcre2_printint_16(compiled_code16,outfile,a)\n#define PCRE2_SERIALIZE_DECODE(r,a,b,c,d) \\\n  r = pcre2_serialize_decode_16((pcre2_code_16 **)a,b,c,G(d,16))\n#define PCRE2_SERIALIZE_ENCODE(r,a,b,c,d,e) \\\n  r = pcre2_serialize_encode_16((const pcre2_code_16 **)a,b,c,d,G(e,16))\n#define PCRE2_SERIALIZE_FREE(a) pcre2_serialize_free_16(a)\n#define PCRE2_SERIALIZE_GET_NUMBER_OF_CODES(r,a) \\\n  r = pcre2_serialize_get_number_of_codes_16(a)\n#define PCRE2_SET_CALLOUT(a,b,c) \\\n  pcre2_set_callout_16(G(a,16),(int (*)(pcre2_callout_block_16 *, void *))b,c);\n#define PCRE2_SET_CHARACTER_TABLES(a,b) pcre2_set_character_tables_16(G(a,16),b)\n#define PCRE2_SET_COMPILE_RECURSION_GUARD(a,b,c) \\\n  pcre2_set_compile_recursion_guard_16(G(a,16),b,c)\n#define PCRE2_SET_DEPTH_LIMIT(a,b) pcre2_set_depth_limit_16(G(a,16),b)\n#define PCRE2_SET_GLOB_ESCAPE(r,a,b) r = pcre2_set_glob_escape_16(G(a,16),b)\n#define PCRE2_SET_GLOB_SEPARATOR(r,a,b) r = pcre2_set_glob_separator_16(G(a,16),b)\n#define PCRE2_SET_HEAP_LIMIT(a,b) pcre2_set_heap_limit_16(G(a,16),b)\n#define PCRE2_SET_MATCH_LIMIT(a,b) pcre2_set_match_limit_16(G(a,16),b)\n#define PCRE2_SET_MAX_PATTERN_LENGTH(a,b) pcre2_set_max_pattern_length_16(G(a,16),b)\n#define PCRE2_SET_OFFSET_LIMIT(a,b) pcre2_set_offset_limit_16(G(a,16),b)\n#define PCRE2_SET_PARENS_NEST_LIMIT(a,b) pcre2_set_parens_nest_limit_16(G(a,16),b)\n#define PCRE2_SET_SUBSTITUTE_CALLOUT(a,b,c) \\\n  pcre2_set_substitute_callout_16(G(a,16), \\\n    (int (*)(pcre2_substitute_callout_block_16 *, void *))b,c)\n#define PCRE2_SUBSTITUTE(a,b,c,d,e,f,g,h,i,j,k,l) \\\n  a = pcre2_substitute_16(G(b,16),(PCRE2_SPTR16)c,d,e,f,G(g,16),h, \\\n    (PCRE2_SPTR16)i,j,(PCRE2_UCHAR16 *)k,l)\n#define PCRE2_SUBSTRING_COPY_BYNAME(a,b,c,d,e) \\\n  a = pcre2_substring_copy_byname_16(G(b,16),G(c,16),(PCRE2_UCHAR16 *)d,e)\n#define PCRE2_SUBSTRING_COPY_BYNUMBER(a,b,c,d,e) \\\n  a = pcre2_substring_copy_bynumber_16(G(b,16),c,(PCRE2_UCHAR16 *)d,e)\n#define PCRE2_SUBSTRING_FREE(a) pcre2_substring_free_16((PCRE2_UCHAR16 *)a)\n#define PCRE2_SUBSTRING_GET_BYNAME(a,b,c,d,e) \\\n  a = pcre2_substring_get_byname_16(G(b,16),G(c,16),(PCRE2_UCHAR16 **)d,e)\n#define PCRE2_SUBSTRING_GET_BYNUMBER(a,b,c,d,e) \\\n  a = pcre2_substring_get_bynumber_16(G(b,16),c,(PCRE2_UCHAR16 **)d,e)\n#define PCRE2_SUBSTRING_LENGTH_BYNAME(a,b,c,d) \\\n    a = pcre2_substring_length_byname_16(G(b,16),G(c,16),d)\n#define PCRE2_SUBSTRING_LENGTH_BYNUMBER(a,b,c,d) \\\n    a = pcre2_substring_length_bynumber_16(G(b,16),c,d)\n#define PCRE2_SUBSTRING_LIST_GET(a,b,c,d) \\\n  a = pcre2_substring_list_get_16(G(b,16),(PCRE2_UCHAR16 ***)c,d)\n#define PCRE2_SUBSTRING_LIST_FREE(a) \\\n  pcre2_substring_list_free_16((PCRE2_SPTR16 *)a)\n#define PCRE2_SUBSTRING_NUMBER_FROM_NAME(a,b,c) \\\n  a = pcre2_substring_number_from_name_16(G(b,16),G(c,16));\n#define PTR(x) (void *)G(x,16)\n#define SETFLD(x,y,z) G(x,16)->y = z\n#define SETFLDVEC(x,y,v,z) G(x,16)->y\u00ddv\u00a8 = z\n#define SETOP(x,y,z) G(x,16) z y\n#define SETCASTPTR(x,y) G(x,16) = (uint16_t *)(y)\n#define STRLEN(p) (int)strlen16((PCRE2_SPTR16)p)\n#define SUB1(a,b) G(a,16)(G(b,16))\n#define SUB2(a,b,c) G(a,16)(G(b,16),G(c,16))\n#define TEST(x,r,y) (G(x,16) r (y))\n#define TESTFLD(x,f,r,y) (G(x,16)->f r (y))\n\n\n/* ----- Only 32-bit mode is supported ----- */\n\n#elif defined SUPPORT_PCRE2_32\n#define CASTFLD(t,a,b) (t)(G(a,32)->b)\n#define CASTVAR(t,x) (t)G(x,32)\n#define CODE_UNIT(a,b) (uint32_t)(((PCRE2_SPTR32)(a))\u00ddb\u00a8)\n#define CONCTXCPY(a,b) memcpy(G(a,32),G(b,32),sizeof(pcre2_convert_context_32))\n#define CONVERT_COPY(a,b,c) memcpy(G(a,32),(char *)b, (c)*4)\n#define DATCTXCPY(a,b) memcpy(G(a,32),G(b,32),sizeof(pcre2_match_context_32))\n#define FLD(a,b) G(a,32)->b\n#define PATCTXCPY(a,b) memcpy(G(a,32),G(b,32),sizeof(pcre2_compile_context_32))\n#define PCHARS(lv, p, offset, len, utf, f) \\\n  lv = pchars32((PCRE2_SPTR32)(p)+offset, len, utf, f)\n#define PCHARSV(p, offset, len, utf, f) \\\n  (void)pchars32((PCRE2_SPTR32)(p)+offset, len, utf, f)\n#define PCRE2_CALLOUT_ENUMERATE(a,b,c) \\\n   a = pcre2_callout_enumerate_32(compiled_code32, \\\n     (int (*)(struct pcre2_callout_enumerate_block_32 *, void *))b,c)\n#define PCRE2_CODE_COPY_FROM_VOID(a,b) G(a,32) = pcre2_code_copy_32(b)\n#define PCRE2_CODE_COPY_TO_VOID(a,b) a = (void *)pcre2_code_copy_32(G(b,32))\n#define PCRE2_CODE_COPY_WITH_TABLES_TO_VOID(a,b) a = (void *)pcre2_code_copy_with_tables_32(G(b,32))\n#define PCRE2_COMPILE(a,b,c,d,e,f,g) \\\n  G(a,32) = pcre2_compile_32(G(b,32),c,d,e,f,g)\n#define PCRE2_CONVERTED_PATTERN_FREE(a) \\\n  pcre2_converted_pattern_free_32((PCRE2_UCHAR32 *)a)\n#define PCRE2_DFA_MATCH(a,b,c,d,e,f,g,h,i,j) \\\n  a = pcre2_dfa_match_32(G(b,32),(PCRE2_SPTR32)c,d,e,f,G(g,32),h,i,j)\n#define PCRE2_GET_ERROR_MESSAGE(r,a,b) \\\n  r = pcre2_get_error_message_32(a,G(b,32),G(G(b,32),_size/4))\n#define PCRE2_GET_OVECTOR_COUNT(a,b) a = pcre2_get_ovector_count_32(G(b,32))\n#define PCRE2_GET_STARTCHAR(a,b) a = pcre2_get_startchar_32(G(b,32))\n#define PCRE2_JIT_COMPILE(r,a,b) r = pcre2_jit_compile_32(G(a,32),b)\n#define PCRE2_JIT_FREE_UNUSED_MEMORY(a) pcre2_jit_free_unused_memory_32(G(a,32))\n#define PCRE2_JIT_MATCH(a,b,c,d,e,f,g,h) \\\n  a = pcre2_jit_match_32(G(b,32),(PCRE2_SPTR32)c,d,e,f,G(g,32),h)\n#define PCRE2_JIT_STACK_CREATE(a,b,c,d) \\\n  a = (PCRE2_JIT_STACK *)pcre2_jit_stack_create_32(b,c,d);\n#define PCRE2_JIT_STACK_ASSIGN(a,b,c) \\\n  pcre2_jit_stack_assign_32(G(a,32),(pcre2_jit_callback_32)b,c);\n#define PCRE2_JIT_STACK_FREE(a) pcre2_jit_stack_free_32((pcre2_jit_stack_32 *)a);\n#define PCRE2_MAKETABLES(a) a = pcre2_maketables_32(NULL)\n#define PCRE2_MATCH(a,b,c,d,e,f,g,h) \\\n  a = pcre2_match_32(G(b,32),(PCRE2_SPTR32)c,d,e,f,G(g,32),h)\n#define PCRE2_MATCH_DATA_CREATE(a,b,c) G(a,32) = pcre2_match_data_create_32(b,c)\n#define PCRE2_MATCH_DATA_CREATE_FROM_PATTERN(a,b,c) \\\n  G(a,32) = pcre2_match_data_create_from_pattern_32(G(b,32),c)\n#define PCRE2_MATCH_DATA_FREE(a) pcre2_match_data_free_32(G(a,32))\n#define PCRE2_PATTERN_CONVERT(a,b,c,d,e,f,g) a = pcre2_pattern_convert_32(G(b,32),c,d,(PCRE2_UCHAR32 **)e,f,G(g,32))\n#define PCRE2_PATTERN_INFO(a,b,c,d) a = pcre2_pattern_info_32(G(b,32),c,d)\n#define PCRE2_PRINTINT(a) pcre2_printint_32(compiled_code32,outfile,a)\n#define PCRE2_SERIALIZE_DECODE(r,a,b,c,d) \\\n  r = pcre2_serialize_decode_32((pcre2_code_32 **)a,b,c,G(d,32))\n#define PCRE2_SERIALIZE_ENCODE(r,a,b,c,d,e) \\\n  r = pcre2_serialize_encode_32((const pcre2_code_32 **)a,b,c,d,G(e,32))\n#define PCRE2_SERIALIZE_FREE(a) pcre2_serialize_free_32(a)\n#define PCRE2_SERIALIZE_GET_NUMBER_OF_CODES(r,a) \\\n  r = pcre2_serialize_get_number_of_codes_32(a)\n#define PCRE2_SET_CALLOUT(a,b,c) \\\n  pcre2_set_callout_32(G(a,32),(int (*)(pcre2_callout_block_32 *, void *))b,c)\n#define PCRE2_SET_CHARACTER_TABLES(a,b) pcre2_set_character_tables_32(G(a,32),b)\n#define PCRE2_SET_COMPILE_RECURSION_GUARD(a,b,c) \\\n  pcre2_set_compile_recursion_guard_32(G(a,32),b,c)\n#define PCRE2_SET_DEPTH_LIMIT(a,b) pcre2_set_depth_limit_32(G(a,32),b)\n#define PCRE2_SET_GLOB_ESCAPE(r,a,b) r = pcre2_set_glob_escape_32(G(a,32),b)\n#define PCRE2_SET_GLOB_SEPARATOR(r,a,b) r = pcre2_set_glob_separator_32(G(a,32),b)\n#define PCRE2_SET_HEAP_LIMIT(a,b) pcre2_set_heap_limit_32(G(a,32),b)\n#define PCRE2_SET_MATCH_LIMIT(a,b) pcre2_set_match_limit_32(G(a,32),b)\n#define PCRE2_SET_MAX_PATTERN_LENGTH(a,b) pcre2_set_max_pattern_length_32(G(a,32),b)\n#define PCRE2_SET_OFFSET_LIMIT(a,b) pcre2_set_offset_limit_32(G(a,32),b)\n#define PCRE2_SET_PARENS_NEST_LIMIT(a,b) pcre2_set_parens_nest_limit_32(G(a,32),b)\n#define PCRE2_SET_SUBSTITUTE_CALLOUT(a,b,c) \\\n  pcre2_set_substitute_callout_32(G(a,32), \\\n    (int (*)(pcre2_substitute_callout_block_32 *, void *))b,c)\n#define PCRE2_SUBSTITUTE(a,b,c,d,e,f,g,h,i,j,k,l) \\\n  a = pcre2_substitute_32(G(b,32),(PCRE2_SPTR32)c,d,e,f,G(g,32),h, \\\n    (PCRE2_SPTR32)i,j,(PCRE2_UCHAR32 *)k,l)\n#define PCRE2_SUBSTRING_COPY_BYNAME(a,b,c,d,e) \\\n  a = pcre2_substring_copy_byname_32(G(b,32),G(c,32),(PCRE2_UCHAR32 *)d,e)\n#define PCRE2_SUBSTRING_COPY_BYNUMBER(a,b,c,d,e) \\\n  a = pcre2_substring_copy_bynumber_32(G(b,32),c,(PCRE2_UCHAR32 *)d,e);\n#define PCRE2_SUBSTRING_FREE(a) pcre2_substring_free_32((PCRE2_UCHAR32 *)a)\n#define PCRE2_SUBSTRING_GET_BYNAME(a,b,c,d,e) \\\n  a = pcre2_substring_get_byname_32(G(b,32),G(c,32),(PCRE2_UCHAR32 **)d,e)\n#define PCRE2_SUBSTRING_GET_BYNUMBER(a,b,c,d,e) \\\n  a = pcre2_substring_get_bynumber_32(G(b,32),c,(PCRE2_UCHAR32 **)d,e)\n#define PCRE2_SUBSTRING_LENGTH_BYNAME(a,b,c,d) \\\n    a = pcre2_substring_length_byname_32(G(b,32),G(c,32),d)\n#define PCRE2_SUBSTRING_LENGTH_BYNUMBER(a,b,c,d) \\\n    a = pcre2_substring_length_bynumber_32(G(b,32),c,d)\n#define PCRE2_SUBSTRING_LIST_GET(a,b,c,d) \\\n  a = pcre2_substring_list_get_32(G(b,32),(PCRE2_UCHAR32 ***)c,d)\n#define PCRE2_SUBSTRING_LIST_FREE(a) \\\n  pcre2_substring_list_free_32((PCRE2_SPTR32 *)a)\n#define PCRE2_SUBSTRING_NUMBER_FROM_NAME(a,b,c) \\\n  a = pcre2_substring_number_from_name_32(G(b,32),G(c,32));\n#define PTR(x) (void *)G(x,32)\n#define SETFLD(x,y,z) G(x,32)->y = z\n#define SETFLDVEC(x,y,v,z) G(x,32)->y\u00ddv\u00a8 = z\n#define SETOP(x,y,z) G(x,32) z y\n#define SETCASTPTR(x,y) G(x,32) = (uint32_t *)(y)\n#define STRLEN(p) (int)strlen32((PCRE2_SPTR32)p)\n#define SUB1(a,b) G(a,32)(G(b,32))\n#define SUB2(a,b,c) G(a,32)(G(b,32),G(c,32))\n#define TEST(x,r,y) (G(x,32) r (y))\n#define TESTFLD(x,f,r,y) (G(x,32)->f r (y))\n\n#endif\n\n/* ----- End of mode-specific function call macros ----- */\n\n\n\n\n/*************************************************\n*         Alternate character tables             *\n*************************************************/\n\n/* By default, the \"tables\" pointer in the compile context when calling\npcre2_compile() is not set (= NULL), thereby using the default tables of the\nlibrary. However, the tables modifier can be used to select alternate sets of\ntables, for different kinds of testing. Note that the locale modifier also\nadjusts the tables. */\n\n/* This is the set of tables distributed as default with PCRE2. It recognizes\nonly ASCII characters. */\n\nstatic const uint8_t tables1\u00dd\u00a8 = {\n\n/* This table is a lower casing table. */\n\n    0,  1,  2,  3,  4,  5,  6,  7,\n    8,  9, 10, 11, 12, 13, 14, 15,\n   16, 17, 18, 19, 20, 21, 22, 23,\n   24, 25, 26, 27, 28, 29, 30, 31,\n   32, 33, 34, 35, 36, 37, 38, 39,\n   40, 41, 42, 43, 44, 45, 46, 47,\n   48, 49, 50, 51, 52, 53, 54, 55,\n   56, 57, 58, 59, 60, 61, 62, 63,\n   64, 97, 98, 99,100,101,102,103,\n  104,105,106,107,108,109,110,111,\n  112,113,114,115,116,117,118,119,\n  120,121,122, 91, 92, 93, 94, 95,\n   96, 97, 98, 99,100,101,102,103,\n  104,105,106,107,108,109,110,111,\n  112,113,114,115,116,117,118,119,\n  120,121,122,123,124,125,126,127,\n  128,129,130,131,132,133,134,135,\n  136,137,138,139,140,141,142,143,\n  144,145,146,147,148,149,150,151,\n  152,153,154,155,156,157,158,159,\n  160,161,162,163,164,165,166,167,\n  168,169,170,171,172,173,174,175,\n  176,177,178,179,180,181,182,183,\n  184,185,186,187,188,189,190,191,\n  192,193,194,195,196,197,198,199,\n  200,201,202,203,204,205,206,207,\n  208,209,210,211,212,213,214,215,\n  216,217,218,219,220,221,222,223,\n  224,225,226,227,228,229,230,231,\n  232,233,234,235,236,237,238,239,\n  240,241,242,243,244,245,246,247,\n  248,249,250,251,252,253,254,255,\n\n/* This table is a case flipping table. */\n\n    0,  1,  2,  3,  4,  5,  6,  7,\n    8,  9, 10, 11, 12, 13, 14, 15,\n   16, 17, 18, 19, 20, 21, 22, 23,\n   24, 25, 26, 27, 28, 29, 30, 31,\n   32, 33, 34, 35, 36, 37, 38, 39,\n   40, 41, 42, 43, 44, 45, 46, 47,\n   48, 49, 50, 51, 52, 53, 54, 55,\n   56, 57, 58, 59, 60, 61, 62, 63,\n   64, 97, 98, 99,100,101,102,103,\n  104,105,106,107,108,109,110,111,\n  112,113,114,115,116,117,118,119,\n  120,121,122, 91, 92, 93, 94, 95,\n   96, 65, 66, 67, 68, 69, 70, 71,\n   72, 73, 74, 75, 76, 77, 78, 79,\n   80, 81, 82, 83, 84, 85, 86, 87,\n   88, 89, 90,123,124,125,126,127,\n  128,129,130,131,132,133,134,135,\n  136,137,138,139,140,141,142,143,\n  144,145,146,147,148,149,150,151,\n  152,153,154,155,156,157,158,159,\n  160,161,162,163,164,165,166,167,\n  168,169,170,171,172,173,174,175,\n  176,177,178,179,180,181,182,183,\n  184,185,186,187,188,189,190,191,\n  192,193,194,195,196,197,198,199,\n  200,201,202,203,204,205,206,207,\n  208,209,210,211,212,213,214,215,\n  216,217,218,219,220,221,222,223,\n  224,225,226,227,228,229,230,231,\n  232,233,234,235,236,237,238,239,\n  240,241,242,243,244,245,246,247,\n  248,249,250,251,252,253,254,255,\n\n/* This table contains bit maps for various character classes. Each map is 32\nbytes long and the bits run from the least significant end of each byte. The\nclasses that have their own maps are: space, xdigit, digit, upper, lower, word,\ngraph, print, punct, and cntrl. Other classes are built from combinations. */\n\n  0x00,0x3e,0x00,0x00,0x01,0x00,0x00,0x00,\n  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n\n  0x00,0x00,0x00,0x00,0x00,0x00,0xff,0x03,\n  0x7e,0x00,0x00,0x00,0x7e,0x00,0x00,0x00,\n  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n\n  0x00,0x00,0x00,0x00,0x00,0x00,0xff,0x03,\n  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n\n  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  0xfe,0xff,0xff,0x07,0x00,0x00,0x00,0x00,\n  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n\n  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  0x00,0x00,0x00,0x00,0xfe,0xff,0xff,0x07,\n  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n\n  0x00,0x00,0x00,0x00,0x00,0x00,0xff,0x03,\n  0xfe,0xff,0xff,0x87,0xfe,0xff,0xff,0x07,\n  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n\n  0x00,0x00,0x00,0x00,0xfe,0xff,0xff,0xff,\n  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x7f,\n  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n\n  0x00,0x00,0x00,0x00,0xff,0xff,0xff,0xff,\n  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x7f,\n  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n\n  0x00,0x00,0x00,0x00,0xfe,0xff,0x00,0xfc,\n  0x01,0x00,0x00,0xf8,0x01,0x00,0x00,0x78,\n  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n\n  0xff,0xff,0xff,0xff,0x00,0x00,0x00,0x00,\n  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,\n  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n\n/* This table identifies various classes of character by individual bits:\n  0x01   white space character\n  0x02   letter\n  0x04   decimal digit\n  0x08   hexadecimal digit\n  0x10   alphanumeric or '_'\n  0x80   regular expression metacharacter or binary zero\n*/\n\n  0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00, /*   0-  7 */\n  0x00,0x01,0x01,0x01,0x01,0x01,0x00,0x00, /*   8- 15 */\n  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, /*  16- 23 */\n  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, /*  24- 31 */\n  0x01,0x00,0x00,0x00,0x80,0x00,0x00,0x00, /*    - '  */\n  0x80,0x80,0x80,0x80,0x00,0x00,0x80,0x00, /*  ( - /  */\n  0x1c,0x1c,0x1c,0x1c,0x1c,0x1c,0x1c,0x1c, /*  0 - 7  */\n  0x1c,0x1c,0x00,0x00,0x00,0x00,0x00,0x80, /*  8 - ?  */\n  0x00,0x1a,0x1a,0x1a,0x1a,0x1a,0x1a,0x12, /*  @ - G  */\n  0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x12, /*  H - O  */\n  0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x12, /*  P - W  */\n  0x12,0x12,0x12,0x80,0x80,0x00,0x80,0x10, /*  X - _  */\n  0x00,0x1a,0x1a,0x1a,0x1a,0x1a,0x1a,0x12, /*  ` - g  */\n  0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x12, /*  h - o  */\n  0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x12, /*  p - w  */\n  0x12,0x12,0x12,0x80,0x80,0x00,0x00,0x00, /*  x -127 */\n  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, /* 128-135 */\n  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, /* 136-143 */\n  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, /* 144-151 */\n  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, /* 152-159 */\n  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, /* 160-167 */\n  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, /* 168-175 */\n  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, /* 176-183 */\n  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, /* 184-191 */\n  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, /* 192-199 */\n  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, /* 200-207 */\n  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, /* 208-215 */\n  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, /* 216-223 */\n  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, /* 224-231 */\n  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, /* 232-239 */\n  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, /* 240-247 */\n  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};/* 248-255 */\n\n/* This is a set of tables that came originally from a Windows user. It seems\nto be at least an approximation of ISO 8859. In particular, there are\ncharacters greater than 128 that are marked as spaces, letters, etc. */\n\nstatic const uint8_t tables2\u00dd\u00a8 = {\n0,1,2,3,4,5,6,7,\n8,9,10,11,12,13,14,15,\n16,17,18,19,20,21,22,23,\n24,25,26,27,28,29,30,31,\n32,33,34,35,36,37,38,39,\n40,41,42,43,44,45,46,47,\n48,49,50,51,52,53,54,55,\n56,57,58,59,60,61,62,63,\n64,97,98,99,100,101,102,103,\n104,105,106,107,108,109,110,111,\n112,113,114,115,116,117,118,119,\n120,121,122,91,92,93,94,95,\n96,97,98,99,100,101,102,103,\n104,105,106,107,108,109,110,111,\n112,113,114,115,116,117,118,119,\n120,121,122,123,124,125,126,127,\n128,129,130,131,132,133,134,135,\n136,137,138,139,140,141,142,143,\n144,145,146,147,148,149,150,151,\n152,153,154,155,156,157,158,159,\n160,161,162,163,164,165,166,167,\n168,169,170,171,172,173,174,175,\n176,177,178,179,180,181,182,183,\n184,185,186,187,188,189,190,191,\n224,225,226,227,228,229,230,231,\n232,233,234,235,236,237,238,239,\n240,241,242,243,244,245,246,215,\n248,249,250,251,252,253,254,223,\n224,225,226,227,228,229,230,231,\n232,233,234,235,236,237,238,239,\n240,241,242,243,244,245,246,247,\n248,249,250,251,252,253,254,255,\n0,1,2,3,4,5,6,7,\n8,9,10,11,12,13,14,15,\n16,17,18,19,20,21,22,23,\n24,25,26,27,28,29,30,31,\n32,33,34,35,36,37,38,39,\n40,41,42,43,44,45,46,47,\n48,49,50,51,52,53,54,55,\n56,57,58,59,60,61,62,63,\n64,97,98,99,100,101,102,103,\n104,105,106,107,108,109,110,111,\n112,113,114,115,116,117,118,119,\n120,121,122,91,92,93,94,95,\n96,65,66,67,68,69,70,71,\n72,73,74,75,76,77,78,79,\n80,81,82,83,84,85,86,87,\n88,89,90,123,124,125,126,127,\n128,129,130,131,132,133,134,135,\n136,137,138,139,140,141,142,143,\n144,145,146,147,148,149,150,151,\n152,153,154,155,156,157,158,159,\n160,161,162,163,164,165,166,167,\n168,169,170,171,172,173,174,175,\n176,177,178,179,180,181,182,183,\n184,185,186,187,188,189,190,191,\n224,225,226,227,228,229,230,231,\n232,233,234,235,236,237,238,239,\n240,241,242,243,244,245,246,215,\n248,249,250,251,252,253,254,223,\n192,193,194,195,196,197,198,199,\n200,201,202,203,204,205,206,207,\n208,209,210,211,212,213,214,247,\n216,217,218,219,220,221,222,255,\n0,62,0,0,1,0,0,0,\n0,0,0,0,0,0,0,0,\n32,0,0,0,1,0,0,0,\n0,0,0,0,0,0,0,0,\n0,0,0,0,0,0,255,3,\n126,0,0,0,126,0,0,0,\n0,0,0,0,0,0,0,0,\n0,0,0,0,0,0,0,0,\n0,0,0,0,0,0,255,3,\n0,0,0,0,0,0,0,0,\n0,0,0,0,0,0,12,2,\n0,0,0,0,0,0,0,0,\n0,0,0,0,0,0,0,0,\n254,255,255,7,0,0,0,0,\n0,0,0,0,0,0,0,0,\n255,255,127,127,0,0,0,0,\n0,0,0,0,0,0,0,0,\n0,0,0,0,254,255,255,7,\n0,0,0,0,0,4,32,4,\n0,0,0,128,255,255,127,255,\n0,0,0,0,0,0,255,3,\n254,255,255,135,254,255,255,7,\n0,0,0,0,0,4,44,6,\n255,255,127,255,255,255,127,255,\n0,0,0,0,254,255,255,255,\n255,255,255,255,255,255,255,127,\n0,0,0,0,254,255,255,255,\n255,255,255,255,255,255,255,255,\n0,2,0,0,255,255,255,255,\n255,255,255,255,255,255,255,127,\n0,0,0,0,255,255,255,255,\n255,255,255,255,255,255,255,255,\n0,0,0,0,254,255,0,252,\n1,0,0,248,1,0,0,120,\n0,0,0,0,254,255,255,255,\n0,0,128,0,0,0,128,0,\n255,255,255,255,0,0,0,0,\n0,0,0,0,0,0,0,128,\n255,255,255,255,0,0,0,0,\n0,0,0,0,0,0,0,0,\n128,0,0,0,0,0,0,0,\n0,1,1,0,1,1,0,0,\n0,0,0,0,0,0,0,0,\n0,0,0,0,0,0,0,0,\n1,0,0,0,128,0,0,0,\n128,128,128,128,0,0,128,0,\n28,28,28,28,28,28,28,28,\n28,28,0,0,0,0,0,128,\n0,26,26,26,26,26,26,18,\n18,18,18,18,18,18,18,18,\n18,18,18,18,18,18,18,18,\n18,18,18,128,128,0,128,16,\n0,26,26,26,26,26,26,18,\n18,18,18,18,18,18,18,18,\n18,18,18,18,18,18,18,18,\n18,18,18,128,128,0,0,0,\n0,0,0,0,0,1,0,0,\n0,0,0,0,0,0,0,0,\n0,0,0,0,0,0,0,0,\n0,0,0,0,0,0,0,0,\n1,0,0,0,0,0,0,0,\n0,0,18,0,0,0,0,0,\n0,0,20,20,0,18,0,0,\n0,20,18,0,0,0,0,0,\n18,18,18,18,18,18,18,18,\n18,18,18,18,18,18,18,18,\n18,18,18,18,18,18,18,0,\n18,18,18,18,18,18,18,18,\n18,18,18,18,18,18,18,18,\n18,18,18,18,18,18,18,18,\n18,18,18,18,18,18,18,0,\n18,18,18,18,18,18,18,18\n};\n\n\n\n#if !defined(VPCOMPAT) && !defined(HAVE_MEMMOVE)\n/*************************************************\n*    Emulated memmove() for systems without it   *\n*************************************************/\n\n/* This function can make use of bcopy() if it is available. Otherwise do it by\nsteam, as there are some non-Unix environments that lack both memmove() and\nbcopy(). */\n\nstatic void *\nemulated_memmove(void *d, const void *s, size_t n)\n{\n#ifdef HAVE_BCOPY\nbcopy(s, d, n);\nreturn d;\n#else\nsize_t i;\nunsigned char *dest = (unsigned char *)d;\nconst unsigned char *src = (const unsigned char *)s;\nif (dest > src)\n  {\n  dest += n;\n  src += n;\n  for (i = 0; i < n; ++i) *(--dest) = *(--src);\n  return (void *)dest;\n  }\nelse\n  {\n  for (i = 0; i < n; ++i) *dest++ = *src++;\n  return (void *)(dest - n);\n  }\n#endif   /* not HAVE_BCOPY */\n}\n#undef memmove\n#define memmove(d,s,n) emulated_memmove(d,s,n)\n#endif   /* not VPCOMPAT && not HAVE_MEMMOVE */\n\n\n\n#ifndef HAVE_STRERROR\n/*************************************************\n*     Provide strerror() for non-ANSI libraries  *\n*************************************************/\n\n/* Some old-fashioned systems (e.g. SunOS4) didn't have strerror() in their\nlibraries. They may no longer be around, but just in case, we can try to\nprovide the same facility by this simple alternative function. */\n\nextern int   sys_nerr;\nextern char *sys_errlist\u00dd\u00a8;\n\nchar *\nstrerror(int n)\n{\nif (n < 0 || n >= sys_nerr) return \"unknown error number\";\nreturn sys_errlist\u00ddn\u00a8;\n}\n#endif /* HAVE_STRERROR */\n\n\n\n/*************************************************\n*            Local memory functions              *\n*************************************************/\n\n/* Alternative memory functions, to test functionality. */\n\nstatic void *my_malloc(PCRE2_SIZE size, void *data)\n{\nvoid *block = malloc(size);\n(void)data;\nif (show_memory)\n  {\n  if (block == NULL)\n    {\n    fprintf(outfile, \"** malloc() failed for %\" SIZ_FORM \"\\n\", SIZ_CAST size);\n    }\n  else\n    {\n    fprintf(outfile, \"malloc  %5\" SIZ_FORM, SIZ_CAST size);\n#ifdef DEBUG_SHOW_MALLOC_ADDRESSES\n    fprintf(outfile, \" %p\", block);   /* Not portable */\n#endif\n    if (malloclistptr < MALLOCLISTSIZE)\n      {\n      malloclist\u00ddmalloclistptr\u00a8 = block;\n      malloclistlength\u00ddmalloclistptr++\u00a8 = size;\n      }\n    else\n      fprintf(outfile, \" (not remembered)\");\n    fprintf(outfile, \"\\n\");\n    }\n  }\nreturn block;\n}\n\nstatic void my_free(void *block, void *data)\n{\n(void)data;\nif (show_memory)\n  {\n  uint32_t i, j;\n  BOOL found = FALSE;\n\n  fprintf(outfile, \"free\");\n  for (i = 0; i < malloclistptr; i++)\n    {\n    if (block == malloclist\u00ddi\u00a8)\n      {\n      fprintf(outfile, \"    %5\" SIZ_FORM, SIZ_CAST malloclistlength\u00ddi\u00a8);\n      malloclistptr--;\n      for (j = i; j < malloclistptr; j++)\n        {\n        malloclist\u00ddj\u00a8 = malloclist\u00ddj+1\u00a8;\n        malloclistlength\u00ddj\u00a8 = malloclistlength\u00ddj+1\u00a8;\n        }\n      found = TRUE;\n      break;\n      }\n    }\n  if (!found) fprintf(outfile, \" unremembered block\");\n#ifdef DEBUG_SHOW_MALLOC_ADDRESSES\n  fprintf(outfile, \" %p\", block);  /* Not portable */\n#endif\n  fprintf(outfile, \"\\n\");\n  }\nfree(block);\n}\n\n\n\n/*************************************************\n*       Callback function for stack guard        *\n*************************************************/\n\n/* This is set up to be called from pcre2_compile() when the stackguard=n\nmodifier sets a value greater than zero. The test we do is whether the\nparenthesis nesting depth is greater than the value set by the modifier.\n\nArgument:  the current parenthesis nesting depth\nReturns:   non-zero to kill the compilation\n*/\n\nstatic int\nstack_guard(uint32_t depth, void *user_data)\n{\n(void)user_data;\nreturn depth > pat_patctl.stackguard_test;\n}\n\n\n/*************************************************\n*         JIT memory callback                    *\n*************************************************/\n\nstatic PCRE2_JIT_STACK*\njit_callback(void *arg)\n{\njit_was_used = TRUE;\nreturn (PCRE2_JIT_STACK *)arg;\n}\n\n\n/*************************************************\n*      Convert UTF-8 character to code point     *\n*************************************************/\n\n/* This function reads one or more bytes that represent a UTF-8 character,\nand returns the codepoint of that character. Note that the function supports\nthe original UTF-8 definition of RFC 2279, allowing for values in the range 0\nto 0x7fffffff, up to 6 bytes long. This makes it possible to generate\ncodepoints greater than 0x10ffff which are useful for testing PCRE2's error\nchecking, and also for generating 32-bit non-UTF data values above the UTF\nlimit.\n\nArgument:\n  utf8bytes   a pointer to the byte vector\n  vptr        a pointer to an int to receive the value\n\nReturns:      >  0 => the number of bytes consumed\n              -6 to 0 => malformed UTF-8 character at offset = (-return)\n*/\n\nstatic int\nutf82ord(PCRE2_SPTR8 utf8bytes, uint32_t *vptr)\n{\nuint32_t c = *utf8bytes++;\nuint32_t d = c;\nint i, j, s;\n\nfor (i = -1; i < 6; i++)               /* i is number of additional bytes */\n  {\n  if ((d & 0x80) == 0) break;\n  d <<= 1;\n  }\n\nif (i == -1) { *vptr = c; return 1; }  /* ascii character */\nif (i == 0 || i == 6) return 0;        /* invalid UTF-8 */\n\n/* i now has a value in the range 1-5 */\n\ns = 6*i;\nd = (c & utf8_table3\u00ddi\u00a8) << s;\n\nfor (j = 0; j < i; j++)\n  {\n  c = *utf8bytes++;\n  if ((c & 0xc0) != 0x80) return -(j+1);\n  s -= 6;\n  d |= (c & 0x3f) << s;\n  }\n\n/* Check that encoding was the correct unique one */\n\nfor (j = 0; j < utf8_table1_size; j++)\n  if (d <= (uint32_t)utf8_table1\u00ddj\u00a8) break;\nif (j != i) return -(i+1);\n\n/* Valid value */\n\n*vptr = d;\nreturn i+1;\n}\n\n\n\n/*************************************************\n*             Print one character                *\n*************************************************/\n\n/* Print a single character either literally, or as a hex escape, and count how\nmany printed characters are used.\n\nArguments:\n  c            the character\n  utf          TRUE in UTF mode\n  f            the FILE to print to, or NULL just to count characters\n\nReturns:       number of characters written\n*/\n\nstatic int\npchar(uint32_t c, BOOL utf, FILE *f)\n{\nint n = 0;\nchar tempbuffer\u00dd16\u00a8;\n\nif (PRINTOK(c))\n  {\n  if (f != NULL) fprintf(f, \"%c\", c);\n  return 1;\n  }\n\nif (c < 0x100)\n  {\n  if (utf)\n    {\n    if (f != NULL) fprintf(f, \"\\\\x{%02x}\", c);\n    return 6;\n    }\n  else\n    {\n    if (f != NULL) fprintf(f, \"\\\\x%02x\", c);\n    return 4;\n    }\n  }\n\nif (f != NULL) n = fprintf(f, \"\\\\x{%02x}\", c);\n  else n = sprintf(tempbuffer, \"\\\\x{%02x}\", c);\n\nreturn n >= 0 ? n : 0;\n}\n\n\n\n#ifdef SUPPORT_PCRE2_16\n/*************************************************\n*    Find length of 0-terminated 16-bit string   *\n*************************************************/\n\nstatic size_t strlen16(PCRE2_SPTR16 p)\n{\nPCRE2_SPTR16 pp = p;\nwhile (*pp != 0) pp++;\nreturn (int)(pp - p);\n}\n#endif  /* SUPPORT_PCRE2_16 */\n\n\n\n#ifdef SUPPORT_PCRE2_32\n/*************************************************\n*    Find length of 0-terminated 32-bit string   *\n*************************************************/\n\nstatic size_t strlen32(PCRE2_SPTR32 p)\n{\nPCRE2_SPTR32 pp = p;\nwhile (*pp != 0) pp++;\nreturn (int)(pp - p);\n}\n#endif  /* SUPPORT_PCRE2_32 */\n\n\n#ifdef SUPPORT_PCRE2_8\n/*************************************************\n*         Print 8-bit character string           *\n*************************************************/\n\n/* Must handle UTF-8 strings in utf8 mode. Yields number of characters printed.\nFor printing *MARK strings, a negative length is given, indicating that the\nlength is in the first code unit. If handed a NULL file, this function just\ncounts chars without printing (because pchar() does that). */\n\nstatic int pchars8(PCRE2_SPTR8 p, int length, BOOL utf, FILE *f)\n{\nuint32_t c = 0;\nint yield = 0;\nif (length < 0) length = *p++;\nwhile (length-- > 0)\n  {\n  if (utf)\n    {\n    int rc = utf82ord(p, &c);\n    if (rc > 0 && rc <= length + 1)   /* Mustn't run over the end */\n      {\n      length -= rc - 1;\n      p += rc;\n      yield += pchar(c, utf, f);\n      continue;\n      }\n    }\n  c = *p++;\n  yield += pchar(c, utf, f);\n  }\n\nreturn yield;\n}\n#endif\n\n\n#ifdef SUPPORT_PCRE2_16\n/*************************************************\n*           Print 16-bit character string        *\n*************************************************/\n\n/* Must handle UTF-16 strings in utf mode. Yields number of characters printed.\nFor printing *MARK strings, a negative length is given, indicating that the\nlength is in the first code unit. If handed a NULL file, just counts chars\nwithout printing. */\n\nstatic int pchars16(PCRE2_SPTR16 p, int length, BOOL utf, FILE *f)\n{\nint yield = 0;\nif (length < 0) length = *p++;\nwhile (length-- > 0)\n  {\n  uint32_t c = *p++ & 0xffff;\n  if (utf && c >= 0xD800 && c < 0xDC00 && length > 0)\n    {\n    int d = *p & 0xffff;\n    if (d >= 0xDC00 && d <= 0xDFFF)\n      {\n      c = ((c & 0x3ff) << 10) + (d & 0x3ff) + 0x10000;\n      length--;\n      p++;\n      }\n    }\n  yield += pchar(c, utf, f);\n  }\nreturn yield;\n}\n#endif  /* SUPPORT_PCRE2_16 */\n\n\n\n#ifdef SUPPORT_PCRE2_32\n/*************************************************\n*           Print 32-bit character string        *\n*************************************************/\n\n/* Must handle UTF-32 strings in utf mode. Yields number of characters printed.\nFor printing *MARK strings, a negative length is given, indicating that the\nlength is in the first code unit. If handed a NULL file, just counts chars\nwithout printing. */\n\nstatic int pchars32(PCRE2_SPTR32 p, int length, BOOL utf, FILE *f)\n{\nint yield = 0;\n(void)(utf);  /* Avoid compiler warning */\nif (length < 0) length = *p++;\nwhile (length-- > 0)\n  {\n  uint32_t c = *p++;\n  yield += pchar(c, utf, f);\n  }\nreturn yield;\n}\n#endif  /* SUPPORT_PCRE2_32 */\n\n\n\n\n/*************************************************\n*       Convert character value to UTF-8         *\n*************************************************/\n\n/* This function takes an integer value in the range 0 - 0x7fffffff\nand encodes it as a UTF-8 character in 0 to 6 bytes. It is needed even when the\n8-bit library is not supported, to generate UTF-8 output for non-ASCII\ncharacters.\n\nArguments:\n  cvalue     the character value\n  utf8bytes  pointer to buffer for result - at least 6 bytes long\n\nReturns:     number of characters placed in the buffer\n*/\n\nstatic int\nord2utf8(uint32_t cvalue, uint8_t *utf8bytes)\n{\nint i, j;\nif (cvalue > 0x7fffffffu)\n  return -1;\nfor (i = 0; i < utf8_table1_size; i++)\n  if (cvalue <= (uint32_t)utf8_table1\u00ddi\u00a8) break;\nutf8bytes += i;\nfor (j = i; j > 0; j--)\n {\n *utf8bytes-- = 0x80 | (cvalue & 0x3f);\n cvalue >>= 6;\n }\n*utf8bytes = utf8_table2\u00ddi\u00a8 | cvalue;\nreturn i + 1;\n}\n\n\n\n#ifdef SUPPORT_PCRE2_16\n/*************************************************\n*           Convert string to 16-bit             *\n*************************************************/\n\n/* In UTF mode the input is always interpreted as a string of UTF-8 bytes using\nthe original UTF-8 definition of RFC 2279, which allows for up to 6 bytes, and\ncode values from 0 to 0x7fffffff. However, values greater than the later UTF\nlimit of 0x10ffff cause an error. In non-UTF mode the input is interpreted as\nUTF-8 if the utf8_input modifier is set, but an error is generated for values\ngreater than 0xffff.\n\nIf all the input bytes are ASCII, the space needed for a 16-bit string is\nexactly double the 8-bit size. Otherwise, the size needed for a 16-bit string\nis no more than double, because up to 0xffff uses no more than 3 bytes in UTF-8\nbut possibly 4 in UTF-16. Higher values use 4 bytes in UTF-8 and up to 4 bytes\nin UTF-16. The result is always left in pbuffer16. Impose a minimum size to\nsave repeated re-sizing.\n\nNote that this function does not object to surrogate values. This is\ndeliberate; it makes it possible to construct UTF-16 strings that are invalid,\nfor the purpose of testing that they are correctly faulted.\n\nArguments:\n  p          points to a byte string\n  utf        true in UTF mode\n  lenptr     points to number of bytes in the string (excluding trailing zero)\n\nReturns:     0 on success, with the length updated to the number of 16-bit\n               data items used (excluding the trailing zero)\n             OR -1 if a UTF-8 string is malformed\n             OR -2 if a value > 0x10ffff is encountered in UTF mode\n             OR -3 if a value > 0xffff is encountered when not in UTF mode\n*/\n\nstatic PCRE2_SIZE\nto16(uint8_t *p, int utf, PCRE2_SIZE *lenptr)\n{\nuint16_t *pp;\nPCRE2_SIZE len = *lenptr;\n\nif (pbuffer16_size < 2*len + 2)\n  {\n  if (pbuffer16 != NULL) free(pbuffer16);\n  pbuffer16_size = 2*len + 2;\n  if (pbuffer16_size < 4096) pbuffer16_size = 4096;\n  pbuffer16 = (uint16_t *)malloc(pbuffer16_size);\n  if (pbuffer16 == NULL)\n    {\n    fprintf(stderr, \"pcre2test: malloc(%\" SIZ_FORM \") failed for pbuffer16\\n\",\n      SIZ_CAST pbuffer16_size);\n    exit(1);\n    }\n  }\n\npp = pbuffer16;\nif (!utf && (pat_patctl.control & CTL_UTF8_INPUT) == 0)\n  {\n  for (; len > 0; len--) *pp++ = *p++;\n  }\nelse while (len > 0)\n  {\n  uint32_t c;\n  int chlen = utf82ord(p, &c);\n  if (chlen <= 0) return -1;\n  if (!utf && c > 0xffff) return -3;\n  if (c > 0x10ffff) return -2;\n  p += chlen;\n  len -= chlen;\n  if (c < 0x10000) *pp++ = c; else\n    {\n    c -= 0x10000;\n    *pp++ = 0xD800 | (c >> 10);\n    *pp++ = 0xDC00 | (c & 0x3ff);\n    }\n  }\n\n*pp = 0;\n*lenptr = pp - pbuffer16;\nreturn 0;\n}\n#endif\n\n\n\n#ifdef SUPPORT_PCRE2_32\n/*************************************************\n*           Convert string to 32-bit             *\n*************************************************/\n\n/* In UTF mode the input is always interpreted as a string of UTF-8 bytes using\nthe original UTF-8 definition of RFC 2279, which allows for up to 6 bytes, and\ncode values from 0 to 0x7fffffff. However, values greater than the later UTF\nlimit of 0x10ffff cause an error.\n\nIn non-UTF mode the input is interpreted as UTF-8 if the utf8_input modifier\nis set, and no limit is imposed. There is special interpretation of the 0xff\nbyte (which is illegal in UTF-8) in this case: it causes the top bit of the\nnext character to be set. This provides a way of generating 32-bit characters\ngreater than 0x7fffffff.\n\nIf all the input bytes are ASCII, the space needed for a 32-bit string is\nexactly four times the 8-bit size. Otherwise, the size needed for a 32-bit\nstring is no more than four times, because the number of characters must be\nless than the number of bytes. The result is always left in pbuffer32. Impose a\nminimum size to save repeated re-sizing.\n\nNote that this function does not object to surrogate values. This is\ndeliberate; it makes it possible to construct UTF-32 strings that are invalid,\nfor the purpose of testing that they are correctly faulted.\n\nArguments:\n  p          points to a byte string\n  utf        true in UTF mode\n  lenptr     points to number of bytes in the string (excluding trailing zero)\n\nReturns:     0 on success, with the length updated to the number of 32-bit\n               data items used (excluding the trailing zero)\n             OR -1 if a UTF-8 string is malformed\n             OR -2 if a value > 0x10ffff is encountered in UTF mode\n*/\n\nstatic PCRE2_SIZE\nto32(uint8_t *p, int utf, PCRE2_SIZE *lenptr)\n{\nuint32_t *pp;\nPCRE2_SIZE len = *lenptr;\n\nif (pbuffer32_size < 4*len + 4)\n  {\n  if (pbuffer32 != NULL) free(pbuffer32);\n  pbuffer32_size = 4*len + 4;\n  if (pbuffer32_size < 8192) pbuffer32_size = 8192;\n  pbuffer32 = (uint32_t *)malloc(pbuffer32_size);\n  if (pbuffer32 == NULL)\n    {\n    fprintf(stderr, \"pcre2test: malloc(%\" SIZ_FORM \") failed for pbuffer32\\n\",\n      SIZ_CAST pbuffer32_size);\n    exit(1);\n    }\n  }\n\npp = pbuffer32;\n\nif (!utf && (pat_patctl.control & CTL_UTF8_INPUT) == 0)\n  {\n  for (; len > 0; len--) *pp++ = *p++;\n  }\n\nelse while (len > 0)\n  {\n  int chlen;\n  uint32_t c;\n  uint32_t topbit = 0;\n  if (!utf && *p == 0xff && len > 1)\n    {\n    topbit = 0x80000000u;\n    p++;\n    len--;\n    }\n  chlen = utf82ord(p, &c);\n  if (chlen <= 0) return -1;\n  if (utf && c > 0x10ffff) return -2;\n  p += chlen;\n  len -= chlen;\n  *pp++ = c | topbit;\n  }\n\n*pp = 0;\n*lenptr = pp - pbuffer32;\nreturn 0;\n}\n#endif /* SUPPORT_PCRE2_32 */\n\n\n\n/* This function is no longer used. Keep it around for a while, just in case it\nneeds to be re-instated. */\n\n#ifdef NEVERNEVERNEVER\n\n/*************************************************\n*         Move back by so many characters        *\n*************************************************/\n\n/* Given a code unit offset in a subject string, move backwards by a number of\ncharacters, and return the resulting offset.\n\nArguments:\n  subject   pointer to the string\n  offset    start offset\n  count     count to move back by\n  utf       TRUE if in UTF mode\n\nReturns:   a possibly changed offset\n*/\n\nstatic PCRE2_SIZE\nbackchars(uint8_t *subject, PCRE2_SIZE offset, uint32_t count, BOOL utf)\n{\nif (!utf || test_mode == PCRE32_MODE)\n  return (count >= offset)? 0 : (offset - count);\n\nelse if (test_mode == PCRE8_MODE)\n  {\n  PCRE2_SPTR8 pp = (PCRE2_SPTR8)subject + offset;\n  for (; count > 0 && pp > (PCRE2_SPTR8)subject; count--)\n    {\n    pp--;\n    while ((*pp & 0xc0) == 0x80) pp--;\n    }\n  return pp - (PCRE2_SPTR8)subject;\n  }\n\nelse  /* 16-bit mode */\n  {\n  PCRE2_SPTR16 pp = (PCRE2_SPTR16)subject + offset;\n  for (; count > 0 && pp > (PCRE2_SPTR16)subject; count--)\n    {\n    pp--;\n    if ((*pp & 0xfc00) == 0xdc00) pp--;\n    }\n  return pp - (PCRE2_SPTR16)subject;\n  }\n}\n#endif  /* NEVERNEVERNEVER */\n\n\n\n/*************************************************\n*           Expand input buffers                 *\n*************************************************/\n\n/* This function doubles the size of the input buffer and the buffer for\nkeeping an 8-bit copy of patterns (pbuffer8), and copies the current buffers to\nthe new ones.\n\nArguments: none\nReturns:   nothing (aborts if malloc() fails)\n*/\n\nstatic void\nexpand_input_buffers(void)\n{\nint new_pbuffer8_size = 2*pbuffer8_size;\nuint8_t *new_buffer = (uint8_t *)malloc(new_pbuffer8_size);\nuint8_t *new_pbuffer8 = (uint8_t *)malloc(new_pbuffer8_size);\n\nif (new_buffer == NULL || new_pbuffer8 == NULL)\n  {\n  fprintf(stderr, \"pcre2test: malloc(%d) failed\\n\", new_pbuffer8_size);\n  exit(1);\n  }\n\nmemcpy(new_buffer, buffer, pbuffer8_size);\nmemcpy(new_pbuffer8, pbuffer8, pbuffer8_size);\n\npbuffer8_size = new_pbuffer8_size;\n\nfree(buffer);\nfree(pbuffer8);\n\nbuffer = new_buffer;\npbuffer8 = new_pbuffer8;\n}\n\n\n\n/*************************************************\n*        Read or extend an input line            *\n*************************************************/\n\n/* Input lines are read into buffer, but both patterns and data lines can be\ncontinued over multiple input lines. In addition, if the buffer fills up, we\nwant to automatically expand it so as to be able to handle extremely large\nlines that are needed for certain stress tests, although this is less likely\nnow that there are repetition features for both patterns and data. When the\ninput buffer is expanded, the other two buffers must also be expanded likewise,\nand the contents of pbuffer, which are a copy of the input for callouts, must\nbe preserved (for when expansion happens for a data line). This is not the most\noptimal way of handling this, but hey, this is just a test program!\n\nArguments:\n  f            the file to read\n  start        where in buffer to start (this *must* be within buffer)\n  prompt       for stdin or readline()\n\nReturns:       pointer to the start of new data\n               could be a copy of start, or could be moved\n               NULL if no data read and EOF reached\n*/\n\nstatic uint8_t *\nextend_inputline(FILE *f, uint8_t *start, const char *prompt)\n{\nuint8_t *here = start;\n\nfor (;;)\n  {\n  size_t rlen = (size_t)(pbuffer8_size - (here - buffer));\n\n  if (rlen > 1000)\n    {\n    size_t dlen;\n\n    /* If libreadline or libedit support is required, use readline() to read a\n    line if the input is a terminal. Note that readline() removes the trailing\n    newline, so we must put it back again, to be compatible with fgets(). */\n\n#if defined(SUPPORT_LIBREADLINE) || defined(SUPPORT_LIBEDIT)\n    if (INTERACTIVE(f))\n      {\n      size_t len;\n      char *s = readline(prompt);\n      if (s == NULL) return (here == start)? NULL : start;\n      len = strlen(s);\n      if (len > 0) add_history(s);\n      if (len > rlen - 1) len = rlen - 1;\n      memcpy(here, s, len);\n      here\u00ddlen\u00a8 = '\\n';\n      here\u00ddlen+1\u00a8 = 0;\n      free(s);\n      }\n    else\n#endif\n\n    /* Read the next line by normal means, prompting if the file is a tty. */\n\n      {\n      if (INTERACTIVE(f)) printf(\"%s\", prompt);\n      if (fgets((char *)here, rlen,  f) == NULL)\n        return (here == start)? NULL : start;\n      }\n\n    dlen = strlen((char *)here);\n    here += dlen;\n\n    /* Check for end of line reached. Take care not to read data from before\n    start (dlen will be zero for a file starting with a binary zero). */\n\n    if (here > start && here\u00dd-1\u00a8 == '\\n') return start;\n\n    /* If we have not read a newline when reading a file, we have either filled\n    the buffer or reached the end of the file. We can detect the former by\n    checking that the string fills the buffer, and the latter by feof(). If\n    neither of these is true, it means we read a binary zero which has caused\n    strlen() to give a short length. This is a hard error because pcre2test\n    expects to work with C strings. */\n\n    if (!INTERACTIVE(f) && dlen < rlen - 1 && !feof(f))\n      {\n      fprintf(outfile, \"** Binary zero encountered in input\\n\");\n      fprintf(outfile, \"** pcre2test run abandoned\\n\");\n      exit(1);\n      }\n    }\n\n  else\n    {\n    size_t start_offset = start - buffer;\n    size_t here_offset = here - buffer;\n    expand_input_buffers();\n    start = buffer + start_offset;\n    here = buffer + here_offset;\n    }\n  }\n\n/* Control never gets here */\n}\n\n\n\n/*************************************************\n*         Case-independent strncmp() function    *\n*************************************************/\n\n/*\nArguments:\n  s         first string\n  t         second string\n  n         number of characters to compare\n\nReturns:    < 0, = 0, or > 0, according to the comparison\n*/\n\nstatic int\nstrncmpic(const uint8_t *s, const uint8_t *t, int n)\n{\nwhile (n--)\n  {\n  int c = tolower(*s++) - tolower(*t++);\n  if (c != 0) return c;\n  }\nreturn 0;\n}\n\n\n\n/*************************************************\n*          Scan the main modifier list           *\n*************************************************/\n\n/* This function searches the modifier list for a long modifier name.\n\nArgument:\n  p         start of the name\n  lenp      length of the name\n\nReturns:    an index in the modifier list, or -1 on failure\n*/\n\nstatic int\nscan_modifiers(const uint8_t *p, unsigned int len)\n{\nint bot = 0;\nint top = MODLISTCOUNT;\n\nwhile (top > bot)\n  {\n  int mid = (bot + top)/2;\n  unsigned int mlen = strlen(modlist\u00ddmid\u00a8.name);\n  int c = strncmp((char *)p, modlist\u00ddmid\u00a8.name, (len < mlen)? len : mlen);\n  if (c == 0)\n    {\n    if (len == mlen) return mid;\n    c = (int)len - (int)mlen;\n    }\n  if (c > 0) bot = mid + 1; else top = mid;\n  }\n\nreturn -1;\n\n}\n\n\n\n/*************************************************\n*        Check a modifer and find its field      *\n*************************************************/\n\n/* This function is called when a modifier has been identified. We check that\nit is allowed here and find the field that is to be changed.\n\nArguments:\n  m          the modifier list entry\n  ctx        CTX_PAT     => pattern context\n             CTX_POPPAT  => pattern context for popped pattern\n             CTX_DEFPAT  => default pattern context\n             CTX_DAT     => data context\n             CTX_DEFDAT  => default data context\n  pctl       point to pattern control block\n  dctl       point to data control block\n  c          a single character or 0\n\nReturns:     a field pointer or NULL\n*/\n\nstatic void *\ncheck_modifier(modstruct *m, int ctx, patctl *pctl, datctl *dctl, uint32_t c)\n{\nvoid *field = NULL;\nPCRE2_SIZE offset = m->offset;\n\nif (restrict_for_perl_test) switch(m->which)\n  {\n  case MOD_PNDP:\n  case MOD_PATP:\n  case MOD_PDP:\n  break;\n\n  default:\n  fprintf(outfile, \"** '%s' is not allowed in a Perl-compatible test\\n\",\n    m->name);\n  return NULL;\n  }\n\nswitch (m->which)\n  {\n  case MOD_CTC:  /* Compile context modifier */\n  if (ctx == CTX_DEFPAT) field = PTR(default_pat_context);\n    else if (ctx == CTX_PAT) field = PTR(pat_context);\n  break;\n\n  case MOD_CTM:  /* Match context modifier */\n  if (ctx == CTX_DEFDAT) field = PTR(default_dat_context);\n    else if (ctx == CTX_DAT) field = PTR(dat_context);\n  break;\n\n  case MOD_DAT:  /* Data line modifier */\n  if (dctl != NULL) field = dctl;\n  break;\n\n  case MOD_PAT:    /* Pattern modifier */\n  case MOD_PATP:   /* Allowed for Perl test */\n  if (pctl != NULL) field = pctl;\n  break;\n\n  case MOD_PD:   /* Pattern or data line modifier */\n  case MOD_PDP:  /* Ditto, allowed for Perl test */\n  case MOD_PND:  /* Ditto, but not default pattern */\n  case MOD_PNDP: /* Ditto, allowed for Perl test */\n  if (dctl != NULL) field = dctl;\n    else if (pctl != NULL && (m->which == MOD_PD || m->which == MOD_PDP ||\n             ctx != CTX_DEFPAT))\n      field = pctl;\n  break;\n  }\n\nif (field == NULL)\n  {\n  if (c == 0)\n    fprintf(outfile, \"** '%s' is not valid here\\n\", m->name);\n  else\n    fprintf(outfile, \"** /%c is not valid here\\n\", c);\n  return NULL;\n  }\n\nreturn (char *)field + offset;\n}\n\n\n\n/*************************************************\n*            Decode a modifier list              *\n*************************************************/\n\n/* A pointer to a control block is NULL when called in cases when that block is\nnot relevant. They are never all relevant in one call. At least one of patctl\nand datctl is NULL. The second argument specifies which context to use for\nmodifiers that apply to contexts.\n\nArguments:\n  p          point to modifier string\n  ctx        CTX_PAT     => pattern context\n             CTX_POPPAT  => pattern context for popped pattern\n             CTX_DEFPAT  => default pattern context\n             CTX_DAT     => data context\n             CTX_DEFDAT  => default data context\n  pctl       point to pattern control block\n  dctl       point to data control block\n\nReturns: TRUE if successful decode, FALSE otherwise\n*/\n\nstatic BOOL\ndecode_modifiers(uint8_t *p, int ctx, patctl *pctl, datctl *dctl)\n{\nuint8_t *ep, *pp;\nlong li;\nunsigned long uli;\nBOOL first = TRUE;\n\nfor (;;)\n  {\n  void *field;\n  modstruct *m;\n  BOOL off = FALSE;\n  unsigned int i, len;\n  int index;\n  char *endptr;\n\n  /* Skip white space and commas. */\n\n  while (isspace(*p) || *p == ',') p++;\n  if (*p == 0) break;\n\n  /* Find the end of the item; lose trailing whitespace at end of line. */\n\n  for (ep = p; *ep != 0 && *ep != ','; ep++);\n  if (*ep == 0)\n    {\n    while (ep > p && isspace(ep\u00dd-1\u00a8)) ep--;\n    *ep = 0;\n    }\n\n  /* Remember if the first character is '-'. */\n\n  if (*p == '-')\n    {\n    off = TRUE;\n    p++;\n    }\n\n  /* Find the length of a full-length modifier name, and scan for it. */\n\n  pp = p;\n  while (pp < ep && *pp != '=') pp++;\n  index = scan_modifiers(p, pp - p);\n\n  /* If the first modifier is unrecognized, try to interpret it as a sequence\n  of single-character abbreviated modifiers. None of these modifiers have any\n  associated data. They just set options or control bits. */\n\n  if (index < 0)\n    {\n    uint32_t cc;\n    uint8_t *mp = p;\n\n    if (!first)\n      {\n      fprintf(outfile, \"** Unrecognized modifier '%.*s'\\n\", (int)(ep-p), p);\n      if (ep - p == 1)\n        fprintf(outfile, \"** Single-character modifiers must come first\\n\");\n      return FALSE;\n      }\n\n    for (cc = *p; cc != ',' && cc != '\\n' && cc != 0; cc = *(++p))\n      {\n      for (i = 0; i < C1MODLISTCOUNT; i++)\n        if (cc == c1modlist\u00ddi\u00a8.onechar) break;\n\n      if (i >= C1MODLISTCOUNT)\n        {\n        fprintf(outfile, \"** Unrecognized modifier '%c' in '%.*s'\\n\",\n          *p, (int)(ep-mp), mp);\n        return FALSE;\n        }\n\n      if (c1modlist\u00ddi\u00a8.index >= 0)\n        {\n        index = c1modlist\u00ddi\u00a8.index;\n        }\n\n      else\n        {\n        index = scan_modifiers((uint8_t *)(c1modlist\u00ddi\u00a8.fullname),\n          strlen(c1modlist\u00ddi\u00a8.fullname));\n        if (index < 0)\n          {\n          fprintf(outfile, \"** Internal error: single-character equivalent \"\n            \"modifier '%s' not found\\n\", c1modlist\u00ddi\u00a8.fullname);\n          return FALSE;\n          }\n        c1modlist\u00ddi\u00a8.index = index;     /* Cache for next time */\n        }\n\n      field = check_modifier(modlist + index, ctx, pctl, dctl, *p);\n      if (field == NULL) return FALSE;\n\n      /* /x is a special case; a second appearance changes PCRE2_EXTENDED to\n      PCRE2_EXTENDED_MORE. */\n\n      if (cc == 'x' && (*((uint32_t *)field) & PCRE2_EXTENDED) != 0)\n        {\n        *((uint32_t *)field) &= ~PCRE2_EXTENDED;\n        *((uint32_t *)field) |= PCRE2_EXTENDED_MORE;\n        }\n      else\n        *((uint32_t *)field) |= modlist\u00ddindex\u00a8.value;\n      }\n\n    continue;    /* With tne next (fullname) modifier */\n    }\n\n  /* We have a match on a full-name modifier. Check for the existence of data\n  when needed. */\n\n  m = modlist + index;      /* Save typing */\n  if (m->type != MOD_CTL && m->type != MOD_OPT &&\n      (m->type != MOD_IND || *pp == '='))\n    {\n    if (*pp++ != '=')\n      {\n      fprintf(outfile, \"** '=' expected after '%s'\\n\", m->name);\n      return FALSE;\n      }\n    if (off)\n      {\n      fprintf(outfile, \"** '-' is not valid for '%s'\\n\", m->name);\n      return FALSE;\n      }\n    }\n\n  /* These on/off types have no data. */\n\n  else if (*pp != ',' && *pp != '\\n' && *pp != ' ' && *pp != 0)\n    {\n    fprintf(outfile, \"** Unrecognized modifier '%.*s'\\n\", (int)(ep-p), p);\n    return FALSE;\n    }\n\n  /* Set the data length for those types that have data. Then find the field\n  that is to be set. If check_modifier() returns NULL, it has already output an\n  error message. */\n\n  len = ep - pp;\n  field = check_modifier(m, ctx, pctl, dctl, 0);\n  if (field == NULL) return FALSE;\n\n  /* Process according to data type. */\n\n  switch (m->type)\n    {\n    case MOD_CTL:\n    case MOD_OPT:\n    if (off) *((uint32_t *)field) &= ~m->value;\n      else *((uint32_t *)field) |= m->value;\n    break;\n\n    case MOD_BSR:\n    if (len == 7 && strncmpic(pp, (const uint8_t *)\"default\", 7) == 0)\n      {\n#ifdef BSR_ANYCRLF\n      *((uint16_t *)field) = PCRE2_BSR_ANYCRLF;\n#else\n      *((uint16_t *)field) = PCRE2_BSR_UNICODE;\n#endif\n      if (ctx == CTX_PAT || ctx == CTX_DEFPAT) pctl->control2 &= ~CTL2_BSR_SET;\n        else dctl->control2 &= ~CTL2_BSR_SET;\n      }\n    else\n      {\n      if (len == 7 && strncmpic(pp, (const uint8_t *)\"anycrlf\", 7) == 0)\n        *((uint16_t *)field) = PCRE2_BSR_ANYCRLF;\n      else if (len == 7 && strncmpic(pp, (const uint8_t *)\"unicode\", 7) == 0)\n        *((uint16_t *)field) = PCRE2_BSR_UNICODE;\n      else goto INVALID_VALUE;\n      if (ctx == CTX_PAT || ctx == CTX_DEFPAT) pctl->control2 |= CTL2_BSR_SET;\n        else dctl->control2 |= CTL2_BSR_SET;\n      }\n    pp = ep;\n    break;\n\n    case MOD_CHR:  /* A single character */\n    *((uint32_t *)field) = *pp++;\n    break;\n\n    case MOD_CON:  /* A convert type/options list */\n    for (;; pp++)\n      {\n      uint8_t *colon = (uint8_t *)strchr((const char *)pp, ':');\n      len = ((colon != NULL && colon < ep)? colon:ep) - pp;\n      for (i = 0; i < convertlistcount; i++)\n        {\n        if (strncmpic(pp, (const uint8_t *)convertlist\u00ddi\u00a8.name, len) == 0)\n          {\n          if (*((uint32_t *)field) == CONVERT_UNSET)\n            *((uint32_t *)field) = convertlist\u00ddi\u00a8.option;\n          else\n            *((uint32_t *)field) |= convertlist\u00ddi\u00a8.option;\n          break;\n          }\n        }\n      if (i >= convertlistcount) goto INVALID_VALUE;\n      pp += len;\n      if (*pp != ':') break;\n      }\n    break;\n\n    case MOD_IN2:    /* One or two unsigned integers */\n    if (!isdigit(*pp)) goto INVALID_VALUE;\n    uli = strtoul((const char *)pp, &endptr, 10);\n    if (U32OVERFLOW(uli)) goto INVALID_VALUE;\n    ((uint32_t *)field)\u00dd0\u00a8 = (uint32_t)uli;\n    if (*endptr == ':')\n      {\n      uli = strtoul((const char *)endptr+1, &endptr, 10);\n      if (U32OVERFLOW(uli)) goto INVALID_VALUE;\n      ((uint32_t *)field)\u00dd1\u00a8 = (uint32_t)uli;\n      }\n    else ((uint32_t *)field)\u00dd1\u00a8 = 0;\n    pp = (uint8_t *)endptr;\n    break;\n\n    /* PCRE2_SIZE_MAX is usually SIZE_MAX, which may be greater, equal to, or\n    less than ULONG_MAX. So first test for overflowing the long int, and then\n    test for overflowing PCRE2_SIZE_MAX if it is smaller than ULONG_MAX. */\n\n    case MOD_SIZ:    /* PCRE2_SIZE value */\n    if (!isdigit(*pp)) goto INVALID_VALUE;\n    uli = strtoul((const char *)pp, &endptr, 10);\n    if (uli == ULONG_MAX) goto INVALID_VALUE;\n#if ULONG_MAX > PCRE2_SIZE_MAX\n    if (uli > PCRE2_SIZE_MAX) goto INVALID_VALUE;\n#endif\n    *((PCRE2_SIZE *)field) = (PCRE2_SIZE)uli;\n    pp = (uint8_t *)endptr;\n    break;\n\n    case MOD_IND:    /* Unsigned integer with default */\n    if (len == 0)\n      {\n      *((uint32_t *)field) = (uint32_t)(m->value);\n      break;\n      }\n    /* Fall through */\n\n    case MOD_INT:    /* Unsigned integer */\n    if (!isdigit(*pp)) goto INVALID_VALUE;\n    uli = strtoul((const char *)pp, &endptr, 10);\n    if (U32OVERFLOW(uli)) goto INVALID_VALUE;\n    *((uint32_t *)field) = (uint32_t)uli;\n    pp = (uint8_t *)endptr;\n    break;\n\n    case MOD_INS:   /* Signed integer */\n    if (!isdigit(*pp) && *pp != '-') goto INVALID_VALUE;\n    li = strtol((const char *)pp, &endptr, 10);\n    if (S32OVERFLOW(li)) goto INVALID_VALUE;\n    *((int32_t *)field) = (int32_t)li;\n    pp = (uint8_t *)endptr;\n    break;\n\n    case MOD_NL:\n    for (i = 0; i < sizeof(newlines)/sizeof(char *); i++)\n      if (len == strlen(newlines\u00ddi\u00a8) &&\n        strncmpic(pp, (const uint8_t *)newlines\u00ddi\u00a8, len) == 0) break;\n    if (i >= sizeof(newlines)/sizeof(char *)) goto INVALID_VALUE;\n    if (i == 0)\n      {\n      *((uint16_t *)field) = NEWLINE_DEFAULT;\n      if (ctx == CTX_PAT || ctx == CTX_DEFPAT) pctl->control2 &= ~CTL2_NL_SET;\n        else dctl->control2 &= ~CTL2_NL_SET;\n      }\n    else\n      {\n      *((uint16_t *)field) = i;\n      if (ctx == CTX_PAT || ctx == CTX_DEFPAT) pctl->control2 |= CTL2_NL_SET;\n        else dctl->control2 |= CTL2_NL_SET;\n      }\n    pp = ep;\n    break;\n\n    case MOD_NN:              /* Name or (signed) number; may be several */\n    if (isdigit(*pp) || *pp == '-')\n      {\n      int ct = MAXCPYGET - 1;\n      int32_t value;\n      li = strtol((const char *)pp, &endptr, 10);\n      if (S32OVERFLOW(li)) goto INVALID_VALUE;\n      value = (int32_t)li;\n      field = (char *)field - m->offset + m->value;      /* Adjust field ptr */\n      if (value >= 0)                                    /* Add new number */\n        {\n        while (*((int32_t *)field) >= 0 && ct-- > 0)   /* Skip previous */\n          field = (char *)field + sizeof(int32_t);\n        if (ct <= 0)\n          {\n          fprintf(outfile, \"** Too many numeric '%s' modifiers\\n\", m->name);\n          return FALSE;\n          }\n        }\n      *((int32_t *)field) = value;\n      if (ct > 0) ((int32_t *)field)\u00dd1\u00a8 = -1;\n      pp = (uint8_t *)endptr;\n      }\n\n    /* Multiple strings are put end to end. */\n\n    else\n      {\n      char *nn = (char *)field;\n      if (len > 0)                    /* Add new name */\n        {\n        if (len > MAX_NAME_SIZE)\n          {\n          fprintf(outfile, \"** Group name in '%s' is too long\\n\", m->name);\n          return FALSE;\n          }\n        while (*nn != 0) nn += strlen(nn) + 1;\n        if (nn + len + 2 - (char *)field > LENCPYGET)\n          {\n          fprintf(outfile, \"** Too many characters in named '%s' modifiers\\n\",\n            m->name);\n          return FALSE;\n          }\n        memcpy(nn, pp, len);\n        }\n      nn\u00ddlen\u00a8 = 0 ;\n      nn\u00ddlen+1\u00a8 = 0;\n      pp = ep;\n      }\n    break;\n\n    case MOD_STR:\n    if (len + 1 > m->value)\n      {\n      fprintf(outfile, \"** Overlong value for '%s' (max %d code units)\\n\",\n        m->name, m->value - 1);\n      return FALSE;\n      }\n    memcpy(field, pp, len);\n    ((uint8_t *)field)\u00ddlen\u00a8 = 0;\n    pp = ep;\n    break;\n    }\n\n  if (*pp != ',' && *pp != '\\n' && *pp != ' ' && *pp != 0)\n    {\n    fprintf(outfile, \"** Comma expected after modifier item '%s'\\n\", m->name);\n    return FALSE;\n    }\n\n  p = pp;\n  first = FALSE;\n\n  if (ctx == CTX_POPPAT &&\n     (pctl->options != 0 ||\n      pctl->tables_id != 0 ||\n      pctl->locale\u00dd0\u00a8 != 0 ||\n      (pctl->control & NOTPOP_CONTROLS) != 0))\n    {\n    fprintf(outfile, \"** '%s' is not valid here\\n\", m->name);\n    return FALSE;\n    }\n  }\n\nreturn TRUE;\n\nINVALID_VALUE:\nfprintf(outfile, \"** Invalid value in '%.*s'\\n\", (int)(ep-p), p);\nreturn FALSE;\n}\n\n\n/*************************************************\n*             Get info from a pattern            *\n*************************************************/\n\n/* A wrapped call to pcre2_pattern_info(), applied to the current compiled\npattern.\n\nArguments:\n  what        code for the required information\n  where       where to put the answer\n  unsetok     PCRE2_ERROR_UNSET is an \"expected\" result\n\nReturns:      the return from pcre2_pattern_info()\n*/\n\nstatic int\npattern_info(int what, void *where, BOOL unsetok)\n{\nint rc;\nPCRE2_PATTERN_INFO(rc, compiled_code, what, NULL);  /* Exercise the code */\nPCRE2_PATTERN_INFO(rc, compiled_code, what, where);\nif (rc >= 0) return 0;\nif (rc != PCRE2_ERROR_UNSET || !unsetok)\n  {\n  fprintf(outfile, \"Error %d from pcre2_pattern_info_%d(%d)\\n\", rc, test_mode,\n    what);\n  if (rc == PCRE2_ERROR_BADMODE)\n    fprintf(outfile, \"Running in %d-bit mode but pattern was compiled in \"\n      \"%d-bit mode\\n\", test_mode,\n      8 * (FLD(compiled_code, flags) & PCRE2_MODE_MASK));\n  }\nreturn rc;\n}\n\n\n\n#ifdef SUPPORT_PCRE2_8\n/*************************************************\n*             Show something in a list           *\n*************************************************/\n\n/* This function just helps to keep the code that uses it tidier. It's used for\nvarious lists of things where there needs to be introductory text before the\nfirst item. As these calls are all in the POSIX-support code, they happen only\nwhen 8-bit mode is supported. */\n\nstatic void\nprmsg(const char **msg, const char *s)\n{\nfprintf(outfile, \"%s %s\", *msg, s);\n*msg = \"\";\n}\n#endif  /* SUPPORT_PCRE2_8 */\n\n\n\n/*************************************************\n*                Show control bits               *\n*************************************************/\n\n/* Called for mutually exclusive controls and for unsupported POSIX controls.\nBecause the bits are unique, this can be used for both pattern and data control\nwords.\n\nArguments:\n  controls    control bits\n  controls2   more control bits\n  before      text to print before\n\nReturns:      nothing\n*/\n\nstatic void\nshow_controls(uint32_t controls, uint32_t controls2, const char *before)\n{\nfprintf(outfile, \"%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s\",\n  before,\n  ((controls & CTL_AFTERTEXT) != 0)? \" aftertext\" : \"\",\n  ((controls & CTL_ALLAFTERTEXT) != 0)? \" allaftertext\" : \"\",\n  ((controls & CTL_ALLCAPTURES) != 0)? \" allcaptures\" : \"\",\n  ((controls & CTL_ALLUSEDTEXT) != 0)? \" allusedtext\" : \"\",\n  ((controls2 & CTL2_ALLVECTOR) != 0)? \" allvector\" : \"\",\n  ((controls & CTL_ALTGLOBAL) != 0)? \" altglobal\" : \"\",\n  ((controls & CTL_BINCODE) != 0)? \" bincode\" : \"\",\n  ((controls2 & CTL2_BSR_SET) != 0)? \" bsr\" : \"\",\n  ((controls & CTL_CALLOUT_CAPTURE) != 0)? \" callout_capture\" : \"\",\n  ((controls2 & CTL2_CALLOUT_EXTRA) != 0)? \" callout_extra\" : \"\",\n  ((controls & CTL_CALLOUT_INFO) != 0)? \" callout_info\" : \"\",\n  ((controls & CTL_CALLOUT_NONE) != 0)? \" callout_none\" : \"\",\n  ((controls2 & CTL2_CALLOUT_NO_WHERE) != 0)? \" callout_no_where\" : \"\",\n  ((controls & CTL_DFA) != 0)? \" dfa\" : \"\",\n  ((controls & CTL_EXPAND) != 0)? \" expand\" : \"\",\n  ((controls & CTL_FINDLIMITS) != 0)? \" find_limits\" : \"\",\n  ((controls & CTL_FRAMESIZE) != 0)? \" framesize\" : \"\",\n  ((controls & CTL_FULLBINCODE) != 0)? \" fullbincode\" : \"\",\n  ((controls & CTL_GETALL) != 0)? \" getall\" : \"\",\n  ((controls & CTL_GLOBAL) != 0)? \" global\" : \"\",\n  ((controls & CTL_HEXPAT) != 0)? \" hex\" : \"\",\n  ((controls & CTL_INFO) != 0)? \" info\" : \"\",\n  ((controls & CTL_JITFAST) != 0)? \" jitfast\" : \"\",\n  ((controls & CTL_JITVERIFY) != 0)? \" jitverify\" : \"\",\n  ((controls & CTL_MARK) != 0)? \" mark\" : \"\",\n  ((controls & CTL_MEMORY) != 0)? \" memory\" : \"\",\n  ((controls2 & CTL2_NL_SET) != 0)? \" newline\" : \"\",\n  ((controls & CTL_NULLCONTEXT) != 0)? \" null_context\" : \"\",\n  ((controls & CTL_POSIX) != 0)? \" posix\" : \"\",\n  ((controls & CTL_POSIX_NOSUB) != 0)? \" posix_nosub\" : \"\",\n  ((controls & CTL_PUSH) != 0)? \" push\" : \"\",\n  ((controls & CTL_PUSHCOPY) != 0)? \" pushcopy\" : \"\",\n  ((controls & CTL_PUSHTABLESCOPY) != 0)? \" pushtablescopy\" : \"\",\n  ((controls & CTL_STARTCHAR) != 0)? \" startchar\" : \"\",\n  ((controls2 & CTL2_SUBSTITUTE_CALLOUT) != 0)? \" substitute_callout\" : \"\",\n  ((controls2 & CTL2_SUBSTITUTE_EXTENDED) != 0)? \" substitute_extended\" : \"\",\n  ((controls2 & CTL2_SUBSTITUTE_LITERAL) != 0)? \" substitute_literal\" : \"\",\n  ((controls2 & CTL2_SUBSTITUTE_MATCHED) != 0)? \" substitute_matched\" : \"\",\n  ((controls2 & CTL2_SUBSTITUTE_OVERFLOW_LENGTH) != 0)? \" substitute_overflow_length\" : \"\",\n  ((controls2 & CTL2_SUBSTITUTE_REPLACEMENT_ONLY) != 0)? \" substitute_replacement_only\" : \"\",\n  ((controls2 & CTL2_SUBSTITUTE_UNKNOWN_UNSET) != 0)? \" substitute_unknown_unset\" : \"\",\n  ((controls2 & CTL2_SUBSTITUTE_UNSET_EMPTY) != 0)? \" substitute_unset_empty\" : \"\",\n  ((controls & CTL_USE_LENGTH) != 0)? \" use_length\" : \"\",\n  ((controls & CTL_UTF8_INPUT) != 0)? \" utf8_input\" : \"\",\n  ((controls & CTL_ZERO_TERMINATE) != 0)? \" zero_terminate\" : \"\");\n}\n\n\n\n/*************************************************\n*                Show compile options            *\n*************************************************/\n\n/* Called from show_pattern_info() and for unsupported POSIX options.\n\nArguments:\n  options     an options word\n  before      text to print before\n  after       text to print after\n\nReturns:      nothing\n*/\n\nstatic void\nshow_compile_options(uint32_t options, const char *before, const char *after)\n{\nif (options == 0) fprintf(outfile, \"%s <none>%s\", before, after);\nelse fprintf(outfile, \"%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s\",\n  before,\n  ((options & PCRE2_ALT_BSUX) != 0)? \" alt_bsux\" : \"\",\n  ((options & PCRE2_ALT_CIRCUMFLEX) != 0)? \" alt_circumflex\" : \"\",\n  ((options & PCRE2_ALT_VERBNAMES) != 0)? \" alt_verbnames\" : \"\",\n  ((options & PCRE2_ALLOW_EMPTY_CLASS) != 0)? \" allow_empty_class\" : \"\",\n  ((options & PCRE2_ANCHORED) != 0)? \" anchored\" : \"\",\n  ((options & PCRE2_AUTO_CALLOUT) != 0)? \" auto_callout\" : \"\",\n  ((options & PCRE2_CASELESS) != 0)? \" caseless\" : \"\",\n  ((options & PCRE2_DOLLAR_ENDONLY) != 0)? \" dollar_endonly\" : \"\",\n  ((options & PCRE2_DOTALL) != 0)? \" dotall\" : \"\",\n  ((options & PCRE2_DUPNAMES) != 0)? \" dupnames\" : \"\",\n  ((options & PCRE2_ENDANCHORED) != 0)? \" endanchored\" : \"\",\n  ((options & PCRE2_EXTENDED) != 0)? \" extended\" : \"\",\n  ((options & PCRE2_EXTENDED_MORE) != 0)? \" extended_more\" : \"\",\n  ((options & PCRE2_FIRSTLINE) != 0)? \" firstline\" : \"\",\n  ((options & PCRE2_LITERAL) != 0)? \" literal\" : \"\",\n  ((options & PCRE2_MATCH_INVALID_UTF) != 0)? \" match_invalid_utf\" : \"\",\n  ((options & PCRE2_MATCH_UNSET_BACKREF) != 0)? \" match_unset_backref\" : \"\",\n  ((options & PCRE2_MULTILINE) != 0)? \" multiline\" : \"\",\n  ((options & PCRE2_NEVER_BACKSLASH_C) != 0)? \" never_backslash_c\" : \"\",\n  ((options & PCRE2_NEVER_UCP) != 0)? \" never_ucp\" : \"\",\n  ((options & PCRE2_NEVER_UTF) != 0)? \" never_utf\" : \"\",\n  ((options & PCRE2_NO_AUTO_CAPTURE) != 0)? \" no_auto_capture\" : \"\",\n  ((options & PCRE2_NO_AUTO_POSSESS) != 0)? \" no_auto_possess\" : \"\",\n  ((options & PCRE2_NO_DOTSTAR_ANCHOR) != 0)? \" no_dotstar_anchor\" : \"\",\n  ((options & PCRE2_NO_UTF_CHECK) != 0)? \" no_utf_check\" : \"\",\n  ((options & PCRE2_NO_START_OPTIMIZE) != 0)? \" no_start_optimize\" : \"\",\n  ((options & PCRE2_UCP) != 0)? \" ucp\" : \"\",\n  ((options & PCRE2_UNGREEDY) != 0)? \" ungreedy\" : \"\",\n  ((options & PCRE2_USE_OFFSET_LIMIT) != 0)? \" use_offset_limit\" : \"\",\n  ((options & PCRE2_UTF) != 0)? \" utf\" : \"\",\n  after);\n}\n\n\n/*************************************************\n*           Show compile extra options           *\n*************************************************/\n\n/* Called from show_pattern_info() and for unsupported POSIX options.\n\nArguments:\n  options     an options word\n  before      text to print before\n  after       text to print after\n\nReturns:      nothing\n*/\n\nstatic void\nshow_compile_extra_options(uint32_t options, const char *before,\n  const char *after)\n{\nif (options == 0) fprintf(outfile, \"%s <none>%s\", before, after);\nelse fprintf(outfile, \"%s%s%s%s%s%s%s%s\",\n  before,\n  ((options & PCRE2_EXTRA_ALLOW_SURROGATE_ESCAPES) != 0)? \" allow_surrogate_escapes\" : \"\",\n  ((options & PCRE2_EXTRA_BAD_ESCAPE_IS_LITERAL) != 0)? \" bad_escape_is_literal\" : \"\",\n  ((options & PCRE2_EXTRA_ALT_BSUX) != 0)? \" extra_alt_bsux\" : \"\",\n  ((options & PCRE2_EXTRA_MATCH_WORD) != 0)? \" match_word\" : \"\",\n  ((options & PCRE2_EXTRA_MATCH_LINE) != 0)? \" match_line\" : \"\",\n  ((options & PCRE2_EXTRA_ESCAPED_CR_IS_LF) != 0)? \" escaped_cr_is_lf\" : \"\",\n  after);\n}\n\n\n\n#ifdef SUPPORT_PCRE2_8\n/*************************************************\n*                Show match options              *\n*************************************************/\n\n/* Called for unsupported POSIX options. */\n\nstatic void\nshow_match_options(uint32_t options)\n{\nfprintf(outfile, \"%s%s%s%s%s%s%s%s%s%s%s%s%s\",\n  ((options & PCRE2_ANCHORED) != 0)? \" anchored\" : \"\",\n  ((options & PCRE2_COPY_MATCHED_SUBJECT) != 0)? \" copy_matched_subject\" : \"\",\n  ((options & PCRE2_DFA_RESTART) != 0)? \" dfa_restart\" : \"\",\n  ((options & PCRE2_DFA_SHORTEST) != 0)? \" dfa_shortest\" : \"\",\n  ((options & PCRE2_ENDANCHORED) != 0)? \" endanchored\" : \"\",\n  ((options & PCRE2_NO_JIT) != 0)? \" no_jit\" : \"\",\n  ((options & PCRE2_NO_UTF_CHECK) != 0)? \" no_utf_check\" : \"\",\n  ((options & PCRE2_NOTBOL) != 0)? \" notbol\" : \"\",\n  ((options & PCRE2_NOTEMPTY) != 0)? \" notempty\" : \"\",\n  ((options & PCRE2_NOTEMPTY_ATSTART) != 0)? \" notempty_atstart\" : \"\",\n  ((options & PCRE2_NOTEOL) != 0)? \" noteol\" : \"\",\n  ((options & PCRE2_PARTIAL_HARD) != 0)? \" partial_hard\" : \"\",\n  ((options & PCRE2_PARTIAL_SOFT) != 0)? \" partial_soft\" : \"\");\n}\n#endif  /* SUPPORT_PCRE2_8 */\n\n\n\n/*************************************************\n*      Show memory usage info for a pattern      *\n*************************************************/\n\nstatic void\nshow_memory_info(void)\n{\nuint32_t name_count, name_entry_size;\nsize_t size, cblock_size;\n\n/* One of the test_mode values will always be true, but to stop a compiler\nwarning we must initialize cblock_size. */\n\ncblock_size = 0;\n#ifdef SUPPORT_PCRE2_8\nif (test_mode == PCRE8_MODE) cblock_size = sizeof(pcre2_real_code_8);\n#endif\n#ifdef SUPPORT_PCRE2_16\nif (test_mode == PCRE16_MODE) cblock_size = sizeof(pcre2_real_code_16);\n#endif\n#ifdef SUPPORT_PCRE2_32\nif (test_mode == PCRE32_MODE) cblock_size = sizeof(pcre2_real_code_32);\n#endif\n\n(void)pattern_info(PCRE2_INFO_SIZE, &size, FALSE);\n(void)pattern_info(PCRE2_INFO_NAMECOUNT, &name_count, FALSE);\n(void)pattern_info(PCRE2_INFO_NAMEENTRYSIZE, &name_entry_size, FALSE);\nfprintf(outfile, \"Memory allocation (code space): %d\\n\",\n  (int)(size - name_count*name_entry_size*code_unit_size - cblock_size));\nif (pat_patctl.jit != 0)\n  {\n  (void)pattern_info(PCRE2_INFO_JITSIZE, &size, FALSE);\n  fprintf(outfile, \"Memory allocation (JIT code): %d\\n\", (int)size);\n  }\n}\n\n\n\n/*************************************************\n*       Show frame size info for a pattern       *\n*************************************************/\n\nstatic void\nshow_framesize(void)\n{\nsize_t frame_size;\n(void)pattern_info(PCRE2_INFO_FRAMESIZE, &frame_size, FALSE);\nfprintf(outfile, \"Frame size for pcre2_match(): %d\\n\", (int)frame_size);\n}\n\n\n\n/*************************************************\n*         Get and output an error message        *\n*************************************************/\n\nstatic BOOL\nprint_error_message(int errorcode, const char *before, const char *after)\n{\nint len;\nPCRE2_GET_ERROR_MESSAGE(len, errorcode, pbuffer);\nif (len < 0)\n  {\n  fprintf(outfile, \"\\n** pcre2test internal error: cannot interpret error \"\n    \"number\\n** Unexpected return (%d) from pcre2_get_error_message()\\n\", len);\n  }\nelse\n  {\n  fprintf(outfile, \"%s\", before);\n  PCHARSV(CASTVAR(void *, pbuffer), 0, len, FALSE, outfile);\n  fprintf(outfile, \"%s\", after);\n  }\nreturn len >= 0;\n}\n\n\n/*************************************************\n*     Callback function for callout enumeration  *\n*************************************************/\n\n/* The only differences in the callout emumeration block for different code\nunit widths are that the pointers to the subject, the most recent MARK, and a\ncallout argument string point to strings of the appropriate width. Casts can be\nused to deal with this.\n\nArgument:\n  cb            pointer to enumerate block\n  callout_data  user data\n\nReturns:    0\n*/\n\nstatic int callout_callback(pcre2_callout_enumerate_block_8 *cb,\n  void *callout_data)\n{\nuint32_t i;\nBOOL utf = (FLD(compiled_code, overall_options) & PCRE2_UTF) != 0;\n\n(void)callout_data;  /* Not currently displayed */\n\nfprintf(outfile, \"Callout \");\nif (cb->callout_string != NULL)\n  {\n  uint32_t delimiter = CODE_UNIT(cb->callout_string, -1);\n  fprintf(outfile, \"%c\", delimiter);\n  PCHARSV(cb->callout_string, 0,\n    cb->callout_string_length, utf, outfile);\n  for (i = 0; callout_start_delims\u00ddi\u00a8 != 0; i++)\n    if (delimiter == callout_start_delims\u00ddi\u00a8)\n      {\n      delimiter = callout_end_delims\u00ddi\u00a8;\n      break;\n      }\n  fprintf(outfile, \"%c  \", delimiter);\n  }\nelse fprintf(outfile, \"%d  \", cb->callout_number);\n\nfprintf(outfile, \"%.*s\\n\",\n  (int)((cb->next_item_length == 0)? 1 : cb->next_item_length),\n  pbuffer8 + cb->pattern_position);\n\nreturn 0;\n}\n\n\n\n/*************************************************\n*        Show information about a pattern        *\n*************************************************/\n\n/* This function is called after a pattern has been compiled if any of the\ninformation-requesting controls have been set.\n\nArguments:  none\n\nReturns:    PR_OK     continue processing next line\n            PR_SKIP   skip to a blank line\n            PR_ABEND  abort the pcre2test run\n*/\n\nstatic int\nshow_pattern_info(void)\n{\nuint32_t compile_options, overall_options, extra_options;\nBOOL utf = (FLD(compiled_code, overall_options) & PCRE2_UTF) != 0;\n\nif ((pat_patctl.control & (CTL_BINCODE|CTL_FULLBINCODE)) != 0)\n  {\n  fprintf(outfile, \"------------------------------------------------------------------\\n\");\n  PCRE2_PRINTINT((pat_patctl.control & CTL_FULLBINCODE) != 0);\n  }\n\nif ((pat_patctl.control & CTL_INFO) != 0)\n  {\n  int rc;\n  void *nametable;\n  uint8_t *start_bits;\n  BOOL heap_limit_set, match_limit_set, depth_limit_set;\n  uint32_t backrefmax, bsr_convention, capture_count, first_ctype, first_cunit,\n    hasbackslashc, hascrorlf, jchanged, last_ctype, last_cunit, match_empty,\n    depth_limit, heap_limit, match_limit, minlength, nameentrysize, namecount,\n    newline_convention;\n\n  /* Exercise the error route. */\n\n  PCRE2_PATTERN_INFO(rc, compiled_code, 999, NULL);\n  (void)rc;\n\n  /* These info requests may return PCRE2_ERROR_UNSET. */\n\n  switch(pattern_info(PCRE2_INFO_HEAPLIMIT, &heap_limit, TRUE))\n    {\n    case 0:\n    heap_limit_set = TRUE;\n    break;\n\n    case PCRE2_ERROR_UNSET:\n    heap_limit_set = FALSE;\n    break;\n\n    default:\n    return PR_ABEND;\n    }\n\n  switch(pattern_info(PCRE2_INFO_MATCHLIMIT, &match_limit, TRUE))\n    {\n    case 0:\n    match_limit_set = TRUE;\n    break;\n\n    case PCRE2_ERROR_UNSET:\n    match_limit_set = FALSE;\n    break;\n\n    default:\n    return PR_ABEND;\n    }\n\n  switch(pattern_info(PCRE2_INFO_DEPTHLIMIT, &depth_limit, TRUE))\n    {\n    case 0:\n    depth_limit_set = TRUE;\n    break;\n\n    case PCRE2_ERROR_UNSET:\n    depth_limit_set = FALSE;\n    break;\n\n    default:\n    return PR_ABEND;\n    }\n\n  /* These info requests should always succeed. */\n\n  if (pattern_info(PCRE2_INFO_BACKREFMAX, &backrefmax, FALSE) +\n      pattern_info(PCRE2_INFO_BSR, &bsr_convention, FALSE) +\n      pattern_info(PCRE2_INFO_CAPTURECOUNT, &capture_count, FALSE) +\n      pattern_info(PCRE2_INFO_FIRSTBITMAP, &start_bits, FALSE) +\n      pattern_info(PCRE2_INFO_FIRSTCODEUNIT, &first_cunit, FALSE) +\n      pattern_info(PCRE2_INFO_FIRSTCODETYPE, &first_ctype, FALSE) +\n      pattern_info(PCRE2_INFO_HASBACKSLASHC, &hasbackslashc, FALSE) +\n      pattern_info(PCRE2_INFO_HASCRORLF, &hascrorlf, FALSE) +\n      pattern_info(PCRE2_INFO_JCHANGED, &jchanged, FALSE) +\n      pattern_info(PCRE2_INFO_LASTCODEUNIT, &last_cunit, FALSE) +\n      pattern_info(PCRE2_INFO_LASTCODETYPE, &last_ctype, FALSE) +\n      pattern_info(PCRE2_INFO_MATCHEMPTY, &match_empty, FALSE) +\n      pattern_info(PCRE2_INFO_MINLENGTH, &minlength, FALSE) +\n      pattern_info(PCRE2_INFO_NAMECOUNT, &namecount, FALSE) +\n      pattern_info(PCRE2_INFO_NAMEENTRYSIZE, &nameentrysize, FALSE) +\n      pattern_info(PCRE2_INFO_NAMETABLE, &nametable, FALSE) +\n      pattern_info(PCRE2_INFO_NEWLINE, &newline_convention, FALSE)\n      != 0)\n    return PR_ABEND;\n\n  fprintf(outfile, \"Capture group count = %d\\n\", capture_count);\n\n  if (backrefmax > 0)\n    fprintf(outfile, \"Max back reference = %d\\n\", backrefmax);\n\n  if (maxlookbehind > 0)\n    fprintf(outfile, \"Max lookbehind = %d\\n\", maxlookbehind);\n\n  if (heap_limit_set)\n    fprintf(outfile, \"Heap limit = %u\\n\", heap_limit);\n\n  if (match_limit_set)\n    fprintf(outfile, \"Match limit = %u\\n\", match_limit);\n\n  if (depth_limit_set)\n    fprintf(outfile, \"Depth limit = %u\\n\", depth_limit);\n\n  if (namecount > 0)\n    {\n    fprintf(outfile, \"Named capture groups:\\n\");\n    for (; namecount > 0; namecount--)\n      {\n      int imm2_size = test_mode == PCRE8_MODE ? 2 : 1;\n      uint32_t length = (uint32_t)STRLEN(nametable + imm2_size);\n      fprintf(outfile, \"  \");\n\n      /* In UTF mode the name may be a UTF string containing non-ASCII\n      letters and digits. We must output it as a UTF-8 string. In non-UTF mode,\n      use the normal string printing functions, which use escapes for all\n      non-ASCII characters. */\n\n      if (utf)\n        {\n#ifdef SUPPORT_PCRE2_32\n        if (test_mode == PCRE32_MODE)\n          {\n          PCRE2_SPTR32 nameptr = (PCRE2_SPTR32)nametable + imm2_size;\n          while (*nameptr != 0)\n            {\n            uint8_t u8buff\u00dd6\u00a8;\n            int len = ord2utf8(*nameptr++, u8buff);\n            fprintf(outfile, \"%.*s\", len, u8buff);\n            }\n          }\n#endif\n#ifdef SUPPORT_PCRE2_16\n        if (test_mode == PCRE16_MODE)\n          {\n          PCRE2_SPTR16 nameptr = (PCRE2_SPTR16)nametable + imm2_size;\n          while (*nameptr != 0)\n            {\n            int len;\n            uint8_t u8buff\u00dd6\u00a8;\n            uint32_t c = *nameptr++ & 0xffff;\n            if (c >= 0xD800 && c < 0xDC00)\n              c = ((c & 0x3ff) << 10) + (*nameptr++ & 0x3ff) + 0x10000;\n            len = ord2utf8(c, u8buff);\n            fprintf(outfile, \"%.*s\", len, u8buff);\n            }\n          }\n#endif\n#ifdef SUPPORT_PCRE2_8\n        if (test_mode == PCRE8_MODE)\n          fprintf(outfile, \"%s\", (PCRE2_SPTR8)nametable + imm2_size);\n#endif\n        }\n      else  /* Not UTF mode */\n        {\n        PCHARSV(nametable, imm2_size, length, FALSE, outfile);\n        }\n\n      while (length++ < nameentrysize - imm2_size) putc(' ', outfile);\n\n#ifdef SUPPORT_PCRE2_32\n      if (test_mode == PCRE32_MODE)\n        fprintf(outfile, \"%3d\\n\", (int)(((PCRE2_SPTR32)nametable)\u00dd0\u00a8));\n#endif\n#ifdef SUPPORT_PCRE2_16\n      if (test_mode == PCRE16_MODE)\n        fprintf(outfile, \"%3d\\n\", (int)(((PCRE2_SPTR16)nametable)\u00dd0\u00a8));\n#endif\n#ifdef SUPPORT_PCRE2_8\n      if (test_mode == PCRE8_MODE)\n        fprintf(outfile, \"%3d\\n\", (int)(\n        ((((PCRE2_SPTR8)nametable)\u00dd0\u00a8) << 8) | ((PCRE2_SPTR8)nametable)\u00dd1\u00a8));\n#endif\n\n      nametable = (void*)((PCRE2_SPTR8)nametable + nameentrysize * code_unit_size);\n      }\n    }\n\n  if (hascrorlf)     fprintf(outfile, \"Contains explicit CR or LF match\\n\");\n  if (hasbackslashc) fprintf(outfile, \"Contains \\\\C\\n\");\n  if (match_empty)   fprintf(outfile, \"May match empty string\\n\");\n\n  pattern_info(PCRE2_INFO_ARGOPTIONS, &compile_options, FALSE);\n  pattern_info(PCRE2_INFO_ALLOPTIONS, &overall_options, FALSE);\n  pattern_info(PCRE2_INFO_EXTRAOPTIONS, &extra_options, FALSE);\n\n  /* Remove UTF/UCP if they were there only because of forbid_utf. This saves\n  cluttering up the verification output of non-UTF test files. */\n\n  if ((pat_patctl.options & PCRE2_NEVER_UTF) == 0)\n    {\n    compile_options &= ~PCRE2_NEVER_UTF;\n    overall_options &= ~PCRE2_NEVER_UTF;\n    }\n\n  if ((pat_patctl.options & PCRE2_NEVER_UCP) == 0)\n    {\n    compile_options &= ~PCRE2_NEVER_UCP;\n    overall_options &= ~PCRE2_NEVER_UCP;\n    }\n\n  if ((compile_options|overall_options) != 0)\n    {\n    if (compile_options == overall_options)\n      show_compile_options(compile_options, \"Options:\", \"\\n\");\n    else\n      {\n      show_compile_options(compile_options, \"Compile options:\", \"\\n\");\n      show_compile_options(overall_options, \"Overall options:\", \"\\n\");\n      }\n    }\n\n  if (extra_options != 0)\n    show_compile_extra_options(extra_options, \"Extra options:\", \"\\n\");\n\n  if (jchanged) fprintf(outfile, \"Duplicate name status changes\\n\");\n\n  if ((pat_patctl.control2 & CTL2_BSR_SET) != 0 ||\n      (FLD(compiled_code, flags) & PCRE2_BSR_SET) != 0)\n    fprintf(outfile, \"\\\\R matches %s\\n\", (bsr_convention == PCRE2_BSR_UNICODE)?\n      \"any Unicode newline\" : \"CR, LF, or CRLF\");\n\n  if ((FLD(compiled_code, flags) & PCRE2_NL_SET) != 0)\n    {\n    switch (newline_convention)\n      {\n      case PCRE2_NEWLINE_CR:\n      fprintf(outfile, \"Forced newline is CR\\n\");\n      break;\n\n      case PCRE2_NEWLINE_LF:\n      fprintf(outfile, \"Forced newline is LF\\n\");\n      break;\n\n      case PCRE2_NEWLINE_CRLF:\n      fprintf(outfile, \"Forced newline is CRLF\\n\");\n      break;\n\n      case PCRE2_NEWLINE_ANYCRLF:\n      fprintf(outfile, \"Forced newline is CR, LF, or CRLF\\n\");\n      break;\n\n      case PCRE2_NEWLINE_ANY:\n      fprintf(outfile, \"Forced newline is any Unicode newline\\n\");\n      break;\n\n      case PCRE2_NEWLINE_NUL:\n      fprintf(outfile, \"Forced newline is NUL\\n\");\n      break;\n\n      default:\n      break;\n      }\n    }\n\n  if (first_ctype == 2)\n    {\n    fprintf(outfile, \"First code unit at start or follows newline\\n\");\n    }\n  else if (first_ctype == 1)\n    {\n    const char *caseless =\n      ((FLD(compiled_code, flags) & PCRE2_FIRSTCASELESS) == 0)?\n      \"\" : \" (caseless)\";\n    if (PRINTOK(first_cunit))\n      fprintf(outfile, \"First code unit = \\'%c\\'%s\\n\", first_cunit, caseless);\n    else\n      {\n      fprintf(outfile, \"First code unit = \");\n      pchar(first_cunit, FALSE, outfile);\n      fprintf(outfile, \"%s\\n\", caseless);\n      }\n    }\n  else if (start_bits != NULL)\n    {\n    int i;\n    int c = 24;\n    fprintf(outfile, \"Starting code units: \");\n    for (i = 0; i < 256; i++)\n      {\n      if ((start_bits\u00ddi/8\u00a8 & (1u << (i&7))) != 0)\n        {\n        if (c > 75)\n          {\n          fprintf(outfile, \"\\n  \");\n          c = 2;\n          }\n        if (PRINTOK(i) && i != ' ')\n          {\n          fprintf(outfile, \"%c \", i);\n          c += 2;\n          }\n        else\n          {\n          fprintf(outfile, \"\\\\x%02x \", i);\n          c += 5;\n          }\n        }\n      }\n    fprintf(outfile, \"\\n\");\n    }\n\n  if (last_ctype != 0)\n    {\n    const char *caseless =\n      ((FLD(compiled_code, flags) & PCRE2_LASTCASELESS) == 0)?\n      \"\" : \" (caseless)\";\n    if (PRINTOK(last_cunit))\n      fprintf(outfile, \"Last code unit = \\'%c\\'%s\\n\", last_cunit, caseless);\n    else\n      {\n      fprintf(outfile, \"Last code unit = \");\n      pchar(last_cunit, FALSE, outfile);\n      fprintf(outfile, \"%s\\n\", caseless);\n      }\n    }\n\n  if ((FLD(compiled_code, overall_options) & PCRE2_NO_START_OPTIMIZE) == 0)\n    fprintf(outfile, \"Subject length lower bound = %d\\n\", minlength);\n\n  if (pat_patctl.jit != 0 && (pat_patctl.control & CTL_JITVERIFY) != 0)\n    {\n    if (FLD(compiled_code, executable_jit) != NULL)\n      fprintf(outfile, \"JIT compilation was successful\\n\");\n    else\n      {\n#ifdef SUPPORT_JIT\n      fprintf(outfile, \"JIT compilation was not successful\");\n      if (jitrc != 0 && !print_error_message(jitrc, \" (\", \")\"))\n        return PR_ABEND;\n      fprintf(outfile, \"\\n\");\n#else\n      fprintf(outfile, \"JIT support is not available in this version of PCRE2\\n\");\n#endif\n      }\n    }\n  }\n\nif ((pat_patctl.control & CTL_CALLOUT_INFO) != 0)\n  {\n  int errorcode;\n  PCRE2_CALLOUT_ENUMERATE(errorcode, callout_callback, 0);\n  if (errorcode != 0)\n    {\n    fprintf(outfile, \"Callout enumerate failed: error %d: \", errorcode);\n    if (errorcode < 0 && !print_error_message(errorcode, \"\", \"\\n\"))\n      return PR_ABEND;\n    return PR_SKIP;\n    }\n  }\n\nreturn PR_OK;\n}\n\n\n\n/*************************************************\n*              Handle serialization error        *\n*************************************************/\n\n/* Print an error message after a serialization failure.\n\nArguments:\n  rc         the error code\n  msg        an initial message for what failed\n\nReturns:     FALSE if print_error_message() fails\n*/\n\nstatic BOOL\nserial_error(int rc, const char *msg)\n{\nfprintf(outfile, \"%s failed: error %d: \", msg, rc);\nreturn print_error_message(rc, \"\", \"\\n\");\n}\n\n\n\n/*************************************************\n*        Open file for save/load commands        *\n*************************************************/\n\n/* This function decodes the file name and opens the file.\n\nArguments:\n  buffptr     point after the #command\n  mode        open mode\n  fptr        points to the FILE variable\n  name        name of # command\n\nReturns:      PR_OK or PR_ABEND\n*/\n\nstatic int\nopen_file(uint8_t *buffptr, const char *mode, FILE **fptr, const char *name)\n{\nchar *endf;\nchar *filename = (char *)buffptr;\nwhile (isspace(*filename)) filename++;\nendf = filename + strlen8(filename);\nwhile (endf > filename && isspace(endf\u00dd-1\u00a8)) endf--;\n\nif (endf == filename)\n  {\n  fprintf(outfile, \"** File name expected after %s\\n\", name);\n  return PR_ABEND;\n  }\n\n*endf = 0;\n*fptr = fopen((const char *)filename, mode);\nif (*fptr == NULL)\n  {\n  fprintf(outfile, \"** Failed to open '%s': %s\\n\", filename, strerror(errno));\n  return PR_ABEND;\n  }\n\nreturn PR_OK;\n}\n\n\n\n/*************************************************\n*               Process command line             *\n*************************************************/\n\n/* This function is called for lines beginning with # and a character that is\nnot ! or whitespace, when encountered between tests, which means that there is\nno compiled pattern (compiled_code is NULL). The line is in buffer.\n\nArguments:  none\n\nReturns:    PR_OK     continue processing next line\n            PR_SKIP   skip to a blank line\n            PR_ABEND  abort the pcre2test run\n*/\n\nstatic int\nprocess_command(void)\n{\nFILE *f;\nPCRE2_SIZE serial_size;\nsize_t i;\nint rc, cmd, cmdlen, yield;\nuint16_t first_listed_newline;\nconst char *cmdname;\nuint8_t *argptr, *serial;\n\nyield = PR_OK;\ncmd = CMD_UNKNOWN;\ncmdlen = 0;\n\nfor (i = 0; i < cmdlistcount; i++)\n  {\n  cmdname = cmdlist\u00ddi\u00a8.name;\n  cmdlen = strlen(cmdname);\n  if (strncmp((char *)(buffer+1), cmdname, cmdlen) == 0 &&\n      isspace(buffer\u00ddcmdlen+1\u00a8))\n    {\n    cmd = cmdlist\u00ddi\u00a8.value;\n    break;\n    }\n  }\n\nargptr = buffer + cmdlen + 1;\n\nif (restrict_for_perl_test && cmd != CMD_PATTERN && cmd != CMD_SUBJECT)\n  {\n  fprintf(outfile, \"** #%s is not allowed after #perltest\\n\", cmdname);\n  return PR_ABEND;\n  }\n\nswitch(cmd)\n  {\n  case CMD_UNKNOWN:\n  fprintf(outfile, \"** Unknown command: %s\", buffer);\n  break;\n\n  case CMD_FORBID_UTF:\n  forbid_utf = PCRE2_NEVER_UTF|PCRE2_NEVER_UCP;\n  break;\n\n  case CMD_PERLTEST:\n  restrict_for_perl_test = TRUE;\n  break;\n\n  /* Set default pattern modifiers */\n\n  case CMD_PATTERN:\n  (void)decode_modifiers(argptr, CTX_DEFPAT, &def_patctl, NULL);\n  if (def_patctl.jit == 0 && (def_patctl.control & CTL_JITVERIFY) != 0)\n    def_patctl.jit = JIT_DEFAULT;\n  break;\n\n  /* Set default subject modifiers */\n\n  case CMD_SUBJECT:\n  (void)decode_modifiers(argptr, CTX_DEFDAT, NULL, &def_datctl);\n  break;\n\n  /* Check the default newline, and if not one of those listed, set up the\n  first one to be forced. An empty list unsets. */\n\n  case CMD_NEWLINE_DEFAULT:\n  local_newline_default = 0;   /* Unset */\n  first_listed_newline = 0;\n  for (;;)\n    {\n    while (isspace(*argptr)) argptr++;\n    if (*argptr == 0) break;\n    for (i = 1; i < sizeof(newlines)/sizeof(char *); i++)\n      {\n      size_t nlen = strlen(newlines\u00ddi\u00a8);\n      if (strncmpic(argptr, (const uint8_t *)newlines\u00ddi\u00a8, nlen) == 0 &&\n          isspace(argptr\u00ddnlen\u00a8))\n        {\n        if (i == NEWLINE_DEFAULT) return PR_OK;  /* Default is valid */\n        if (first_listed_newline == 0) first_listed_newline = i;\n        }\n      }\n    while (*argptr != 0 && !isspace(*argptr)) argptr++;\n    }\n  local_newline_default = first_listed_newline;\n  break;\n\n  /* Pop or copy a compiled pattern off the stack. Modifiers that do not affect\n  the compiled pattern (e.g. to give information) are permitted. The default\n  pattern modifiers are ignored. */\n\n  case CMD_POP:\n  case CMD_POPCOPY:\n  if (patstacknext <= 0)\n    {\n    fprintf(outfile, \"** Can't pop off an empty stack\\n\");\n    return PR_SKIP;\n    }\n  memset(&pat_patctl, 0, sizeof(patctl));   /* Completely unset */\n  if (!decode_modifiers(argptr, CTX_POPPAT, &pat_patctl, NULL))\n    return PR_SKIP;\n\n  if (cmd == CMD_POP)\n    {\n    SET(compiled_code, patstack\u00dd--patstacknext\u00a8);\n    }\n  else\n    {\n    PCRE2_CODE_COPY_FROM_VOID(compiled_code, patstack\u00ddpatstacknext - 1\u00a8);\n    }\n\n  if (pat_patctl.jit != 0)\n    {\n    PCRE2_JIT_COMPILE(jitrc, compiled_code, pat_patctl.jit);\n    }\n  if ((pat_patctl.control & CTL_MEMORY) != 0) show_memory_info();\n  if ((pat_patctl.control & CTL_FRAMESIZE) != 0) show_framesize();\n  if ((pat_patctl.control & CTL_ANYINFO) != 0)\n    {\n    rc = show_pattern_info();\n    if (rc != PR_OK) return rc;\n    }\n  break;\n\n  /* Save the stack of compiled patterns to a file, then empty the stack. */\n\n  case CMD_SAVE:\n  if (patstacknext <= 0)\n    {\n    fprintf(outfile, \"** No stacked patterns to save\\n\");\n    return PR_OK;\n    }\n\n  rc = open_file(argptr+1, BINARY_OUTPUT_MODE, &f, \"#save\");\n  if (rc != PR_OK) return rc;\n\n  PCRE2_SERIALIZE_ENCODE(rc, patstack, patstacknext, &serial, &serial_size,\n    general_context);\n  if (rc < 0)\n    {\n    fclose(f);\n    if (!serial_error(rc, \"Serialization\")) return PR_ABEND;\n    break;\n    }\n\n  /* Write the length at the start of the file to make it straightforward to\n  get the right memory when re-loading. This saves having to read the file size\n  in different operating systems. To allow for different endianness (even\n  though reloading with the opposite endianness does not work), write the\n  length byte-by-byte. */\n\n  for (i = 0; i < 4; i++) fputc((serial_size >> (i*8)) & 255, f);\n  if (fwrite(serial, 1, serial_size, f) != serial_size)\n    {\n    fprintf(outfile, \"** Wrong return from fwrite()\\n\");\n    fclose(f);\n    return PR_ABEND;\n    }\n\n  fclose(f);\n  PCRE2_SERIALIZE_FREE(serial);\n  while(patstacknext > 0)\n    {\n    SET(compiled_code, patstack\u00dd--patstacknext\u00a8);\n    SUB1(pcre2_code_free, compiled_code);\n    }\n  SET(compiled_code, NULL);\n  break;\n\n  /* Load a set of compiled patterns from a file onto the stack */\n\n  case CMD_LOAD:\n  rc = open_file(argptr+1, BINARY_INPUT_MODE, &f, \"#load\");\n  if (rc != PR_OK) return rc;\n\n  serial_size = 0;\n  for (i = 0; i < 4; i++) serial_size |= fgetc(f) << (i*8);\n\n  serial = malloc(serial_size);\n  if (serial == NULL)\n    {\n    fprintf(outfile, \"** Failed to get memory (size %\" SIZ_FORM \") for #load\\n\",\n      SIZ_CAST serial_size);\n    fclose(f);\n    return PR_ABEND;\n    }\n\n  i = fread(serial, 1, serial_size, f);\n  fclose(f);\n\n  if (i != serial_size)\n    {\n    fprintf(outfile, \"** Wrong return from fread()\\n\");\n    yield = PR_ABEND;\n    }\n  else\n    {\n    PCRE2_SERIALIZE_GET_NUMBER_OF_CODES(rc, serial);\n    if (rc < 0)\n      {\n      if (!serial_error(rc, \"Get number of codes\")) yield = PR_ABEND;\n      }\n    else\n      {\n      if (rc + patstacknext > PATSTACKSIZE)\n        {\n        fprintf(outfile, \"** Not enough space on pattern stack for %d pattern%s\\n\",\n          rc, (rc == 1)? \"\" : \"s\");\n        rc = PATSTACKSIZE - patstacknext;\n        fprintf(outfile, \"** Decoding %d pattern%s\\n\", rc,\n          (rc == 1)? \"\" : \"s\");\n        }\n      PCRE2_SERIALIZE_DECODE(rc, patstack + patstacknext, rc, serial,\n        general_context);\n      if (rc < 0)\n        {\n        if (!serial_error(rc, \"Deserialization\")) yield = PR_ABEND;\n        }\n      else patstacknext += rc;\n      }\n    }\n\n  free(serial);\n  break;\n\n  /* Load a set of binary tables into tables3. */\n\n  case CMD_LOADTABLES:\n  rc = open_file(argptr+1, BINARY_INPUT_MODE, &f, \"#loadtables\");\n  if (rc != PR_OK) return rc;\n\n  if (tables3 == NULL)\n    {\n    (void)PCRE2_CONFIG(PCRE2_CONFIG_TABLES_LENGTH, &loadtables_length);\n    tables3 = malloc(loadtables_length);\n    }\n\n  if (tables3 == NULL)\n    {\n    fprintf(outfile, \"** Failed: malloc failed for #loadtables\\n\");\n    yield = PR_ABEND;\n    }\n  else if (fread(tables3, 1, loadtables_length, f) != loadtables_length)\n    {\n    fprintf(outfile, \"** Wrong return from fread()\\n\");\n    yield = PR_ABEND;\n    }\n\n  fclose(f);\n  break;\n  }\n\nreturn yield;\n}\n\n\n\n/*************************************************\n*               Process pattern line             *\n*************************************************/\n\n/* This function is called when the input buffer contains the start of a\npattern. The first character is known to be a valid delimiter. The pattern is\nread, modifiers are interpreted, and a suitable local context is set up for\nthis test. The pattern is then compiled.\n\nArguments:  none\n\nReturns:    PR_OK     continue processing next line\n            PR_SKIP   skip to a blank line\n            PR_ABEND  abort the pcre2test run\n*/\n\nstatic int\nprocess_pattern(void)\n{\nBOOL utf;\nuint32_t k;\nuint8_t *p = buffer;\nunsigned int delimiter = *p++;\nint errorcode;\nvoid *use_pat_context;\nuint32_t use_forbid_utf = forbid_utf;\nPCRE2_SIZE patlen;\nPCRE2_SIZE valgrind_access_length;\nPCRE2_SIZE erroroffset;\n\n/* Initialize the context and pattern/data controls for this test from the\ndefaults. */\n\nPATCTXCPY(pat_context, default_pat_context);\nmemcpy(&pat_patctl, &def_patctl, sizeof(patctl));\n\n/* Find the end of the pattern, reading more lines if necessary. */\n\nfor(;;)\n  {\n  while (*p != 0)\n    {\n    if (*p == '\\\\' && p\u00dd1\u00a8 != 0) p++;\n      else if (*p == delimiter) break;\n    p++;\n    }\n  if (*p != 0) break;\n  if ((p = extend_inputline(infile, p, \"    > \")) == NULL)\n    {\n    fprintf(outfile, \"** Unexpected EOF\\n\");\n    return PR_ABEND;\n    }\n  if (!INTERACTIVE(infile)) fprintf(outfile, \"%s\", (char *)p);\n  }\n\n/* If the first character after the delimiter is backslash, make the pattern\nend with backslash. This is purely to provide a way of testing for the error\nmessage when a pattern ends with backslash. */\n\nif (p\u00dd1\u00a8 == '\\\\') *p++ = '\\\\';\n\n/* Terminate the pattern at the delimiter, and compute the length. */\n\n*p++ = 0;\npatlen = p - buffer - 2;\n\n/* Look for modifiers and options after the final delimiter. */\n\nif (!decode_modifiers(p, CTX_PAT, &pat_patctl, NULL)) return PR_SKIP;\n\n/* Note that the match_invalid_utf option also sets utf when passed to\npcre2_compile(). */\n\nutf = (pat_patctl.options & (PCRE2_UTF|PCRE2_MATCH_INVALID_UTF)) != 0;\n\n/* The utf8_input modifier is not allowed in 8-bit mode, and is mutually\nexclusive with the utf modifier. */\n\nif ((pat_patctl.control & CTL_UTF8_INPUT) != 0)\n  {\n  if (test_mode == PCRE8_MODE)\n    {\n    fprintf(outfile, \"** The utf8_input modifier is not allowed in 8-bit mode\\n\");\n    return PR_SKIP;\n    }\n  if (utf)\n    {\n    fprintf(outfile, \"** The utf and utf8_input modifiers are mutually exclusive\\n\");\n    return PR_SKIP;\n    }\n  }\n\n/* The convert and posix modifiers are mutually exclusive. */\n\nif (pat_patctl.convert_type != CONVERT_UNSET &&\n    (pat_patctl.control & CTL_POSIX) != 0)\n  {\n  fprintf(outfile, \"** The convert and posix modifiers are mutually exclusive\\n\");\n  return PR_SKIP;\n  }\n\n/* Check for mutually exclusive control modifiers. At present, these are all in\nthe first control word. */\n\nfor (k = 0; k < sizeof(exclusive_pat_controls)/sizeof(uint32_t); k++)\n  {\n  uint32_t c = pat_patctl.control & exclusive_pat_controls\u00ddk\u00a8;\n  if (c != 0 && c != (c & (~c+1)))\n    {\n    show_controls(c, 0, \"** Not allowed together:\");\n    fprintf(outfile, \"\\n\");\n    return PR_SKIP;\n    }\n  }\n\n/* Assume full JIT compile for jitverify and/or jitfast if nothing else was\nspecified. */\n\nif (pat_patctl.jit == 0 &&\n    (pat_patctl.control & (CTL_JITVERIFY|CTL_JITFAST)) != 0)\n  pat_patctl.jit = JIT_DEFAULT;\n\n/* Now copy the pattern to pbuffer8 for use in 8-bit testing and for reflecting\nin callouts. Convert from hex if requested (literal strings in quotes may be\npresent within the hexadecimal pairs). The result must necessarily be fewer\ncharacters so will always fit in pbuffer8. */\n\nif ((pat_patctl.control & CTL_HEXPAT) != 0)\n  {\n  uint8_t *pp, *pt;\n  uint32_t c, d;\n\n  pt = pbuffer8;\n  for (pp = buffer + 1; *pp != 0; pp++)\n    {\n    if (isspace(*pp)) continue;\n    c = *pp++;\n\n    /* Handle a literal substring */\n\n    if (c == '\\'' || c == '\"')\n      {\n      uint8_t *pq = pp;\n      for (;; pp++)\n        {\n        d = *pp;\n        if (d == 0)\n          {\n          fprintf(outfile, \"** Missing closing quote in hex pattern: \"\n            \"opening quote is at offset %\" PTR_FORM \".\\n\", pq - buffer - 2);\n          return PR_SKIP;\n          }\n        if (d == c) break;\n        *pt++ = d;\n        }\n      }\n\n    /* Expect a hex pair */\n\n    else\n      {\n      if (!isxdigit(c))\n        {\n        fprintf(outfile, \"** Unexpected non-hex-digit '%c' at offset %\"\n          PTR_FORM \" in hex pattern: quote missing?\\n\", c, pp - buffer - 2);\n        return PR_SKIP;\n        }\n      if (*pp == 0)\n        {\n        fprintf(outfile, \"** Odd number of digits in hex pattern\\n\");\n        return PR_SKIP;\n        }\n      d = *pp;\n      if (!isxdigit(d))\n        {\n        fprintf(outfile, \"** Unexpected non-hex-digit '%c' at offset %\"\n          PTR_FORM \" in hex pattern: quote missing?\\n\", d, pp - buffer - 1);\n        return PR_SKIP;\n        }\n      c = toupper(c);\n      d = toupper(d);\n      *pt++ = ((isdigit(c)? (c - '0') : (c - 'A' + 10)) << 4) +\n               (isdigit(d)? (d - '0') : (d - 'A' + 10));\n      }\n    }\n  *pt = 0;\n  patlen = pt - pbuffer8;\n  }\n\n/* If not a hex string, process for repetition expansion if requested. */\n\nelse if ((pat_patctl.control & CTL_EXPAND) != 0)\n  {\n  uint8_t *pp, *pt;\n\n  pt = pbuffer8;\n  for (pp = buffer + 1; *pp != 0; pp++)\n    {\n    uint8_t *pc = pp;\n    uint32_t count = 1;\n    size_t length = 1;\n\n    /* Check for replication syntax; if not found, the defaults just set will\n    prevail and one character will be copied. */\n\n    if (pp\u00dd0\u00a8 == '\\\\' && pp\u00dd1\u00a8 == '\u00dd')\n      {\n      uint8_t *pe;\n      for (pe = pp + 2; *pe != 0; pe++)\n        {\n        if (pe\u00dd0\u00a8 == '\u00a8' && pe\u00dd1\u00a8 == '{')\n          {\n          uint32_t clen = pe - pc - 2;\n          uint32_t i = 0;\n          unsigned long uli;\n          char *endptr;\n\n          pe += 2;\n          uli = strtoul((const char *)pe, &endptr, 10);\n          if (U32OVERFLOW(uli))\n            {\n            fprintf(outfile, \"** Pattern repeat count too large\\n\");\n            return PR_SKIP;\n            }\n\n          i = (uint32_t)uli;\n          pe = (uint8_t *)endptr;\n          if (*pe == '}')\n            {\n            if (i == 0)\n              {\n              fprintf(outfile, \"** Zero repeat not allowed\\n\");\n              return PR_SKIP;\n              }\n            pc += 2;\n            count = i;\n            length = clen;\n            pp = pe;\n            break;\n            }\n          }\n        }\n      }\n\n    /* Add to output. If the buffer is too small expand it. The function for\n    expanding buffers always keeps buffer and pbuffer8 in step as far as their\n    size goes. */\n\n    while (pt + count * length > pbuffer8 + pbuffer8_size)\n      {\n      size_t pc_offset = pc - buffer;\n      size_t pp_offset = pp - buffer;\n      size_t pt_offset = pt - pbuffer8;\n      expand_input_buffers();\n      pc = buffer + pc_offset;\n      pp = buffer + pp_offset;\n      pt = pbuffer8 + pt_offset;\n      }\n\n    for (; count > 0; count--)\n      {\n      memcpy(pt, pc, length);\n      pt += length;\n      }\n    }\n\n  *pt = 0;\n  patlen = pt - pbuffer8;\n\n  if ((pat_patctl.control & CTL_INFO) != 0)\n    fprintf(outfile, \"Expanded: %s\\n\", pbuffer8);\n  }\n\n/* Neither hex nor expanded, just copy the input verbatim. */\n\nelse\n  {\n  strncpy((char *)pbuffer8, (char *)(buffer+1), patlen + 1);\n  }\n\n/* Sort out character tables */\n\nif (pat_patctl.locale\u00dd0\u00a8 != 0)\n  {\n  if (pat_patctl.tables_id != 0)\n    {\n    fprintf(outfile, \"** 'Locale' and 'tables' must not both be set\\n\");\n    return PR_SKIP;\n    }\n  if (setlocale(LC_CTYPE, (const char *)pat_patctl.locale) == NULL)\n    {\n    fprintf(outfile, \"** Failed to set locale '%s'\\n\", pat_patctl.locale);\n    return PR_SKIP;\n    }\n  if (strcmp((const char *)pat_patctl.locale, (const char *)locale_name) != 0)\n    {\n    strcpy((char *)locale_name, (char *)pat_patctl.locale);\n    if (locale_tables != NULL) free((void *)locale_tables);\n    PCRE2_MAKETABLES(locale_tables);\n    }\n  use_tables = locale_tables;\n  }\n\nelse switch (pat_patctl.tables_id)\n  {\n  case 0: use_tables = NULL; break;\n  case 1: use_tables = tables1; break;\n  case 2: use_tables = tables2; break;\n\n  case 3:\n  if (tables3 == NULL)\n    {\n    fprintf(outfile, \"** 'Tables = 3' is invalid: binary tables have not \"\n      \"been loaded\\n\");\n    return PR_SKIP;\n    }\n  use_tables = tables3;\n  break;\n\n  default:\n  fprintf(outfile, \"** 'Tables' must specify 0, 1, 2, or 3.\\n\");\n  return PR_SKIP;\n  }\n\nPCRE2_SET_CHARACTER_TABLES(pat_context, use_tables);\n\n/* Set up for the stackguard test. */\n\nif (pat_patctl.stackguard_test != 0)\n  {\n  PCRE2_SET_COMPILE_RECURSION_GUARD(pat_context, stack_guard, NULL);\n  }\n\n/* Handle compiling via the POSIX interface, which doesn't support the\ntiming, showing, or debugging options, nor the ability to pass over\nlocal character tables. Neither does it have 16-bit or 32-bit support. */\n\nif ((pat_patctl.control & CTL_POSIX) != 0)\n  {\n#ifdef SUPPORT_PCRE2_8\n  int rc;\n  int cflags = 0;\n  const char *msg = \"** Ignored with POSIX interface:\";\n#endif\n\n  if (test_mode != PCRE8_MODE)\n    {\n    fprintf(outfile, \"** The POSIX interface is available only in 8-bit mode\\n\");\n    return PR_SKIP;\n    }\n\n#ifdef SUPPORT_PCRE2_8\n  /* Check for features that the POSIX interface does not support. */\n\n  if (pat_patctl.locale\u00dd0\u00a8 != 0) prmsg(&msg, \"locale\");\n  if (pat_patctl.replacement\u00dd0\u00a8 != 0) prmsg(&msg, \"replace\");\n  if (pat_patctl.tables_id != 0) prmsg(&msg, \"tables\");\n  if (pat_patctl.stackguard_test != 0) prmsg(&msg, \"stackguard\");\n  if (timeit > 0) prmsg(&msg, \"timing\");\n  if (pat_patctl.jit != 0) prmsg(&msg, \"JIT\");\n\n  if ((pat_patctl.options & ~POSIX_SUPPORTED_COMPILE_OPTIONS) != 0)\n    {\n    show_compile_options(\n      pat_patctl.options & ~POSIX_SUPPORTED_COMPILE_OPTIONS, msg, \"\");\n    msg = \"\";\n    }\n\n  if ((FLD(pat_context, extra_options) &\n       ~POSIX_SUPPORTED_COMPILE_EXTRA_OPTIONS) != 0)\n    {\n    show_compile_extra_options(\n      FLD(pat_context, extra_options) & ~POSIX_SUPPORTED_COMPILE_EXTRA_OPTIONS,\n        msg, \"\");\n    msg = \"\";\n    }\n\n  if ((pat_patctl.control & ~POSIX_SUPPORTED_COMPILE_CONTROLS) != 0 ||\n      (pat_patctl.control2 & ~POSIX_SUPPORTED_COMPILE_CONTROLS2) != 0)\n    {\n    show_controls(pat_patctl.control & ~POSIX_SUPPORTED_COMPILE_CONTROLS,\n      pat_patctl.control2 & ~POSIX_SUPPORTED_COMPILE_CONTROLS2, msg);\n    msg = \"\";\n    }\n\n  if (local_newline_default != 0) prmsg(&msg, \"#newline_default\");\n  if (FLD(pat_context, max_pattern_length) != PCRE2_UNSET)\n    prmsg(&msg, \"max_pattern_length\");\n  if (FLD(pat_context, parens_nest_limit) != PARENS_NEST_DEFAULT)\n    prmsg(&msg, \"parens_nest_limit\");\n\n  if (msg\u00dd0\u00a8 == 0) fprintf(outfile, \"\\n\");\n\n  /* Translate PCRE2 options to POSIX options and then compile. */\n\n  if (utf) cflags |= REG_UTF;\n  if ((pat_patctl.control & CTL_POSIX_NOSUB) != 0) cflags |= REG_NOSUB;\n  if ((pat_patctl.options & PCRE2_UCP) != 0) cflags |= REG_UCP;\n  if ((pat_patctl.options & PCRE2_CASELESS) != 0) cflags |= REG_ICASE;\n  if ((pat_patctl.options & PCRE2_LITERAL) != 0) cflags |= REG_NOSPEC;\n  if ((pat_patctl.options & PCRE2_MULTILINE) != 0) cflags |= REG_NEWLINE;\n  if ((pat_patctl.options & PCRE2_DOTALL) != 0) cflags |= REG_DOTALL;\n  if ((pat_patctl.options & PCRE2_UNGREEDY) != 0) cflags |= REG_UNGREEDY;\n\n  if ((pat_patctl.control & (CTL_HEXPAT|CTL_USE_LENGTH)) != 0)\n    {\n    preg.re_endp = (char *)pbuffer8 + patlen;\n    cflags |= REG_PEND;\n    }\n\n  rc = regcomp(&preg, (char *)pbuffer8, cflags);\n\n  /* Compiling failed */\n\n  if (rc != 0)\n    {\n    size_t bsize, usize;\n    int psize;\n\n    preg.re_pcre2_code = NULL;     /* In case something was left in there */\n    preg.re_match_data = NULL;\n\n    bsize = (pat_patctl.regerror_buffsize != 0)?\n      pat_patctl.regerror_buffsize : pbuffer8_size;\n    if (bsize + 8 < pbuffer8_size)\n      memcpy(pbuffer8 + bsize, \"DEADBEEF\", 8);\n    usize = regerror(rc, &preg, (char *)pbuffer8, bsize);\n\n    /* Inside regerror(), snprintf() is used. If the buffer is too small, some\n    versions of snprintf() put a zero byte at the end, but others do not.\n    Therefore, we print a maximum of one less than the size of the buffer. */\n\n    psize = (int)bsize - 1;\n    fprintf(outfile, \"Failed: POSIX code %d: %.*s\\n\", rc, psize, pbuffer8);\n    if (usize > bsize)\n      {\n      fprintf(outfile, \"** regerror() message truncated\\n\");\n      if (memcmp(pbuffer8 + bsize, \"DEADBEEF\", 8) != 0)\n        fprintf(outfile, \"** regerror() buffer overflow\\n\");\n      }\n    return PR_SKIP;\n    }\n\n  /* Compiling succeeded. Check that the values in the preg block are sensible.\n  It can happen that pcre2test is accidentally linked with a different POSIX\n  library which succeeds, but of course puts different things into preg. In\n  this situation, calling regfree() may cause a segfault (or invalid free() in\n  valgrind), so ensure that preg.re_pcre2_code is NULL, which suppresses the\n  calling of regfree() on exit. */\n\n  if (preg.re_pcre2_code == NULL ||\n      ((pcre2_real_code_8 *)preg.re_pcre2_code)->magic_number != MAGIC_NUMBER ||\n      ((pcre2_real_code_8 *)preg.re_pcre2_code)->top_bracket != preg.re_nsub ||\n      preg.re_match_data == NULL ||\n      preg.re_cflags != cflags)\n    {\n    fprintf(outfile,\n      \"** The regcomp() function returned zero (success), but the values set\\n\"\n      \"** in the preg block are not valid for PCRE2. Check that pcre2test is\\n\"\n      \"** linked with PCRE2's pcre2posix module (-lpcre2-posix) and not with\\n\"\n      \"** some other POSIX regex library.\\n**\\n\");\n    preg.re_pcre2_code = NULL;\n    return PR_ABEND;\n    }\n\n  return PR_OK;\n#endif  /* SUPPORT_PCRE2_8 */\n  }\n\n/* Handle compiling via the native interface. Controls that act later are\nignored with \"push\". Replacements are locked out. */\n\nif ((pat_patctl.control & (CTL_PUSH|CTL_PUSHCOPY|CTL_PUSHTABLESCOPY)) != 0)\n  {\n  if (pat_patctl.replacement\u00dd0\u00a8 != 0)\n    {\n    fprintf(outfile, \"** Replacement text is not supported with 'push'.\\n\");\n    return PR_OK;\n    }\n  if ((pat_patctl.control & ~PUSH_SUPPORTED_COMPILE_CONTROLS) != 0 ||\n      (pat_patctl.control2 & ~PUSH_SUPPORTED_COMPILE_CONTROLS2) != 0)\n    {\n    show_controls(pat_patctl.control & ~PUSH_SUPPORTED_COMPILE_CONTROLS,\n                  pat_patctl.control2 & ~PUSH_SUPPORTED_COMPILE_CONTROLS2,\n      \"** Ignored when compiled pattern is stacked with 'push':\");\n    fprintf(outfile, \"\\n\");\n    }\n  if ((pat_patctl.control & PUSH_COMPILE_ONLY_CONTROLS) != 0 ||\n      (pat_patctl.control2 & PUSH_COMPILE_ONLY_CONTROLS2) != 0)\n    {\n    show_controls(pat_patctl.control & PUSH_COMPILE_ONLY_CONTROLS,\n                  pat_patctl.control2 & PUSH_COMPILE_ONLY_CONTROLS2,\n      \"** Applies only to compile when pattern is stacked with 'push':\");\n    fprintf(outfile, \"\\n\");\n    }\n  }\n\n/* Convert the input in non-8-bit modes. */\n\nerrorcode = 0;\n\n#ifdef SUPPORT_PCRE2_16\nif (test_mode == PCRE16_MODE) errorcode = to16(pbuffer8, utf, &patlen);\n#endif\n\n#ifdef SUPPORT_PCRE2_32\nif (test_mode == PCRE32_MODE) errorcode = to32(pbuffer8, utf, &patlen);\n#endif\n\nswitch(errorcode)\n  {\n  case -1:\n  fprintf(outfile, \"** Failed: invalid UTF-8 string cannot be \"\n    \"converted to %d-bit string\\n\", (test_mode == PCRE16_MODE)? 16:32);\n  return PR_SKIP;\n\n  case -2:\n  fprintf(outfile, \"** Failed: character value greater than 0x10ffff \"\n    \"cannot be converted to UTF\\n\");\n  return PR_SKIP;\n\n  case -3:\n  fprintf(outfile, \"** Failed: character value greater than 0xffff \"\n    \"cannot be converted to 16-bit in non-UTF mode\\n\");\n  return PR_SKIP;\n\n  default:\n  break;\n  }\n\n/* The pattern is now in pbuffer\u00dd8|16|32\u00a8, with the length in code units in\npatlen. If it is to be converted, copy the result back afterwards so that it\nends up back in the usual place. */\n\nif (pat_patctl.convert_type != CONVERT_UNSET)\n  {\n  int rc;\n  int convert_return = PR_OK;\n  uint32_t convert_options = pat_patctl.convert_type;\n  void *converted_pattern;\n  PCRE2_SIZE converted_length;\n\n  if (pat_patctl.convert_length != 0)\n    {\n    converted_length = pat_patctl.convert_length;\n    converted_pattern = malloc(converted_length * code_unit_size);\n    if (converted_pattern == NULL)\n      {\n      fprintf(outfile, \"** Failed: malloc failed for converted pattern\\n\");\n      return PR_SKIP;\n      }\n    }\n  else converted_pattern = NULL;  /* Let the library allocate */\n\n  if (utf) convert_options |= PCRE2_CONVERT_UTF;\n  if ((pat_patctl.options & PCRE2_NO_UTF_CHECK) != 0)\n    convert_options |= PCRE2_CONVERT_NO_UTF_CHECK;\n\n  CONCTXCPY(con_context, default_con_context);\n\n  if (pat_patctl.convert_glob_escape != 0)\n    {\n    uint32_t escape = (pat_patctl.convert_glob_escape == '0')? 0 :\n      pat_patctl.convert_glob_escape;\n    PCRE2_SET_GLOB_ESCAPE(rc, con_context, escape);\n    if (rc != 0)\n      {\n      fprintf(outfile, \"** Invalid glob escape '%c'\\n\",\n        pat_patctl.convert_glob_escape);\n      convert_return = PR_SKIP;\n      goto CONVERT_FINISH;\n      }\n    }\n\n  if (pat_patctl.convert_glob_separator != 0)\n    {\n    PCRE2_SET_GLOB_SEPARATOR(rc, con_context, pat_patctl.convert_glob_separator);\n    if (rc != 0)\n      {\n      fprintf(outfile, \"** Invalid glob separator '%c'\\n\",\n        pat_patctl.convert_glob_separator);\n      convert_return = PR_SKIP;\n      goto CONVERT_FINISH;\n      }\n    }\n\n  PCRE2_PATTERN_CONVERT(rc, pbuffer, patlen, convert_options,\n    &converted_pattern, &converted_length, con_context);\n\n  if (rc != 0)\n    {\n    fprintf(outfile, \"** Pattern conversion error at offset %\" SIZ_FORM \": \",\n      SIZ_CAST converted_length);\n    convert_return = print_error_message(rc, \"\", \"\\n\")? PR_SKIP:PR_ABEND;\n    }\n\n  /* Output the converted pattern, then copy it. */\n\n  else\n    {\n    PCHARSV(converted_pattern, 0, converted_length, utf, outfile);\n    fprintf(outfile, \"\\n\");\n    patlen = converted_length;\n    CONVERT_COPY(pbuffer, converted_pattern, converted_length + 1);\n    }\n\n  /* Free the converted pattern. */\n\n  CONVERT_FINISH:\n  if (pat_patctl.convert_length != 0)\n    free(converted_pattern);\n  else\n    PCRE2_CONVERTED_PATTERN_FREE(converted_pattern);\n\n  /* Return if conversion was unsuccessful. */\n\n  if (convert_return != PR_OK) return convert_return;\n  }\n\n/* By default we pass a zero-terminated pattern, but a length is passed if\n\"use_length\" was specified or this is a hex pattern (which might contain binary\nzeros). When valgrind is supported, arrange for the unused part of the buffer\nto be marked as no access. */\n\nvalgrind_access_length = patlen;\nif ((pat_patctl.control & (CTL_HEXPAT|CTL_USE_LENGTH)) == 0)\n  {\n  patlen = PCRE2_ZERO_TERMINATED;\n  valgrind_access_length += 1;  /* For the terminating zero */\n  }\n\n#ifdef SUPPORT_VALGRIND\n#ifdef SUPPORT_PCRE2_8\nif (test_mode == PCRE8_MODE && pbuffer8 != NULL)\n  {\n  VALGRIND_MAKE_MEM_NOACCESS(pbuffer8 + valgrind_access_length,\n    pbuffer8_size - valgrind_access_length);\n  }\n#endif\n#ifdef SUPPORT_PCRE2_16\nif (test_mode == PCRE16_MODE && pbuffer16 != NULL)\n  {\n  VALGRIND_MAKE_MEM_NOACCESS(pbuffer16 + valgrind_access_length,\n    pbuffer16_size - valgrind_access_length*sizeof(uint16_t));\n  }\n#endif\n#ifdef SUPPORT_PCRE2_32\nif (test_mode == PCRE32_MODE && pbuffer32 != NULL)\n  {\n  VALGRIND_MAKE_MEM_NOACCESS(pbuffer32 + valgrind_access_length,\n    pbuffer32_size - valgrind_access_length*sizeof(uint32_t));\n  }\n#endif\n#else  /* Valgrind not supported */\n(void)valgrind_access_length;  /* Avoid compiler warning */\n#endif\n\n/* If #newline_default has been used and the library was not compiled with an\nappropriate default newline setting, local_newline_default will be non-zero. We\nuse this if there is no explicit newline modifier. */\n\nif ((pat_patctl.control2 & CTL2_NL_SET) == 0 && local_newline_default != 0)\n  {\n  SETFLD(pat_context, newline_convention, local_newline_default);\n  }\n\n/* The null_context modifier is used to test calling pcre2_compile() with a\nNULL context. */\n\nuse_pat_context = ((pat_patctl.control & CTL_NULLCONTEXT) != 0)?\n  NULL : PTR(pat_context);\n\n/* If PCRE2_LITERAL is set, set use_forbid_utf zero because PCRE2_NEVER_UTF\nand PCRE2_NEVER_UCP are invalid with it. */\n\nif ((pat_patctl.options & PCRE2_LITERAL) != 0) use_forbid_utf = 0;\n\n/* Compile many times when timing. */\n\nif (timeit > 0)\n  {\n  int i;\n  clock_t time_taken = 0;\n  for (i = 0; i < timeit; i++)\n    {\n    clock_t start_time = clock();\n    PCRE2_COMPILE(compiled_code, pbuffer, patlen,\n      pat_patctl.options|use_forbid_utf, &errorcode, &erroroffset,\n        use_pat_context);\n    time_taken += clock() - start_time;\n    if (TEST(compiled_code, !=, NULL))\n      { SUB1(pcre2_code_free, compiled_code); }\n    }\n  total_compile_time += time_taken;\n  fprintf(outfile, \"Compile time %.4f milliseconds\\n\",\n    (((double)time_taken * 1000.0) / (double)timeit) /\n      (double)CLOCKS_PER_SEC);\n  }\n\n/* A final compile that is used \"for real\". */\n\nPCRE2_COMPILE(compiled_code, pbuffer, patlen, pat_patctl.options|use_forbid_utf,\n  &errorcode, &erroroffset, use_pat_context);\n\n/* Call the JIT compiler if requested. When timing, we must free and recompile\nthe pattern each time because that is the only way to free the JIT compiled\ncode. We know that compilation will always succeed. */\n\nif (TEST(compiled_code, !=, NULL) && pat_patctl.jit != 0)\n  {\n  if (timeit > 0)\n    {\n    int i;\n    clock_t time_taken = 0;\n\n    for (i = 0; i < timeit; i++)\n      {\n      clock_t start_time;\n      SUB1(pcre2_code_free, compiled_code);\n      PCRE2_COMPILE(compiled_code, pbuffer, patlen,\n        pat_patctl.options|use_forbid_utf, &errorcode, &erroroffset,\n        use_pat_context);\n      start_time = clock();\n      PCRE2_JIT_COMPILE(jitrc, compiled_code, pat_patctl.jit);\n      time_taken += clock() - start_time;\n      }\n    total_jit_compile_time += time_taken;\n    fprintf(outfile, \"JIT compile  %.4f milliseconds\\n\",\n      (((double)time_taken * 1000.0) / (double)timeit) /\n        (double)CLOCKS_PER_SEC);\n    }\n  else\n    {\n    PCRE2_JIT_COMPILE(jitrc, compiled_code, pat_patctl.jit);\n    }\n  }\n\n/* If valgrind is supported, mark the pbuffer as accessible again. The 16-bit\nand 32-bit buffers can be marked completely undefined, but we must leave the\npattern in the 8-bit buffer defined because it may be read from a callout\nduring matching. */\n\n#ifdef SUPPORT_VALGRIND\n#ifdef SUPPORT_PCRE2_8\nif (test_mode == PCRE8_MODE)\n  {\n  VALGRIND_MAKE_MEM_UNDEFINED(pbuffer8 + valgrind_access_length,\n    pbuffer8_size - valgrind_access_length);\n  }\n#endif\n#ifdef SUPPORT_PCRE2_16\nif (test_mode == PCRE16_MODE)\n  {\n  VALGRIND_MAKE_MEM_UNDEFINED(pbuffer16, pbuffer16_size);\n  }\n#endif\n#ifdef SUPPORT_PCRE2_32\nif (test_mode == PCRE32_MODE)\n  {\n  VALGRIND_MAKE_MEM_UNDEFINED(pbuffer32, pbuffer32_size);\n  }\n#endif\n#endif\n\n/* Compilation failed; go back for another re, skipping to blank line\nif non-interactive. */\n\nif (TEST(compiled_code, ==, NULL))\n  {\n  fprintf(outfile, \"Failed: error %d at offset %d: \", errorcode,\n    (int)erroroffset);\n  if (!print_error_message(errorcode, \"\", \"\\n\")) return PR_ABEND;\n  return PR_SKIP;\n  }\n\n/* If forbid_utf is non-zero, we are running a non-UTF test. UTF and UCP are\nlocked out at compile time, but we must also check for occurrences of \\P, \\p,\nand \\X, which are only supported when Unicode is supported. */\n\nif (forbid_utf != 0)\n  {\n  if ((FLD(compiled_code, flags) & PCRE2_HASBKPORX) != 0)\n    {\n    fprintf(outfile, \"** \\\\P, \\\\p, and \\\\X are not allowed after the \"\n      \"#forbid_utf command\\n\");\n    return PR_SKIP;\n    }\n  }\n\n/* Remember the maximum lookbehind, for partial matching. */\n\nif (pattern_info(PCRE2_INFO_MAXLOOKBEHIND, &maxlookbehind, FALSE) != 0)\n  return PR_ABEND;\n\n/* Remember the number of captures. */\n\nif (pattern_info(PCRE2_INFO_CAPTURECOUNT, &maxcapcount, FALSE) < 0)\n  return PR_ABEND;\n\n/* If an explicit newline modifier was given, set the information flag in the\npattern so that it is preserved over push/pop. */\n\nif ((pat_patctl.control2 & CTL2_NL_SET) != 0)\n  {\n  SETFLD(compiled_code, flags, FLD(compiled_code, flags) | PCRE2_NL_SET);\n  }\n\n/* Output code size and other information if requested. */\n\nif ((pat_patctl.control & CTL_MEMORY) != 0) show_memory_info();\nif ((pat_patctl.control & CTL_FRAMESIZE) != 0) show_framesize();\nif ((pat_patctl.control & CTL_ANYINFO) != 0)\n  {\n  int rc = show_pattern_info();\n  if (rc != PR_OK) return rc;\n  }\n\n/* The \"push\" control requests that the compiled pattern be remembered on a\nstack. This is mainly for testing the serialization functionality. */\n\nif ((pat_patctl.control & CTL_PUSH) != 0)\n  {\n  if (patstacknext >= PATSTACKSIZE)\n    {\n    fprintf(outfile, \"** Too many pushed patterns (max %d)\\n\", PATSTACKSIZE);\n    return PR_ABEND;\n    }\n  patstack\u00ddpatstacknext++\u00a8 = PTR(compiled_code);\n  SET(compiled_code, NULL);\n  }\n\n/* The \"pushcopy\" and \"pushtablescopy\" controls are similar, but push a\ncopy of the pattern, the latter with a copy of its character tables. This tests\nthe pcre2_code_copy() and pcre2_code_copy_with_tables() functions. */\n\nif ((pat_patctl.control & (CTL_PUSHCOPY|CTL_PUSHTABLESCOPY)) != 0)\n  {\n  if (patstacknext >= PATSTACKSIZE)\n    {\n    fprintf(outfile, \"** Too many pushed patterns (max %d)\\n\", PATSTACKSIZE);\n    return PR_ABEND;\n    }\n  if ((pat_patctl.control & CTL_PUSHCOPY) != 0)\n    {\n    PCRE2_CODE_COPY_TO_VOID(patstack\u00ddpatstacknext++\u00a8, compiled_code);\n    }\n  else\n    {\n    PCRE2_CODE_COPY_WITH_TABLES_TO_VOID(patstack\u00ddpatstacknext++\u00a8,\n      compiled_code); }\n  }\n\nreturn PR_OK;\n}\n\n\n\n/*************************************************\n*          Check heap, match or depth limit      *\n*************************************************/\n\n/* This is used for DFA, normal, and JIT fast matching. For DFA matching it\nshould only be called with the third argument set to PCRE2_ERROR_DEPTHLIMIT.\n\nArguments:\n  pp        the subject string\n  ulen      length of subject or PCRE2_ZERO_TERMINATED\n  errnumber defines which limit to test\n  msg       string to include in final message\n\nReturns:    the return from the final match function call\n*/\n\nstatic int\ncheck_match_limit(uint8_t *pp, PCRE2_SIZE ulen, int errnumber, const char *msg)\n{\nint capcount;\nuint32_t min = 0;\nuint32_t mid = 64;\nuint32_t max = UINT32_MAX;\n\nPCRE2_SET_MATCH_LIMIT(dat_context, max);\nPCRE2_SET_DEPTH_LIMIT(dat_context, max);\nPCRE2_SET_HEAP_LIMIT(dat_context, max);\n\nfor (;;)\n  {\n  uint32_t stack_start = 0;\n\n  if (errnumber == PCRE2_ERROR_HEAPLIMIT)\n    {\n    PCRE2_SET_HEAP_LIMIT(dat_context, mid);\n    }\n  else if (errnumber == PCRE2_ERROR_MATCHLIMIT)\n    {\n    PCRE2_SET_MATCH_LIMIT(dat_context, mid);\n    }\n  else\n    {\n    PCRE2_SET_DEPTH_LIMIT(dat_context, mid);\n    }\n\n  if ((dat_datctl.control & CTL_DFA) != 0)\n    {\n    stack_start = DFA_START_RWS_SIZE/1024;\n    if (dfa_workspace == NULL)\n      dfa_workspace = (int *)malloc(DFA_WS_DIMENSION*sizeof(int));\n    if (dfa_matched++ == 0)\n      dfa_workspace\u00dd0\u00a8 = -1;  /* To catch bad restart */\n    PCRE2_DFA_MATCH(capcount, compiled_code, pp, ulen, dat_datctl.offset,\n      dat_datctl.options, match_data,\n      PTR(dat_context), dfa_workspace, DFA_WS_DIMENSION);\n    }\n\n  else if ((pat_patctl.control & CTL_JITFAST) != 0)\n    PCRE2_JIT_MATCH(capcount, compiled_code, pp, ulen, dat_datctl.offset,\n      dat_datctl.options, match_data, PTR(dat_context));\n\n  else\n    {\n    stack_start = START_FRAMES_SIZE/1024;\n    PCRE2_MATCH(capcount, compiled_code, pp, ulen, dat_datctl.offset,\n      dat_datctl.options, match_data, PTR(dat_context));\n    }\n\n  if (capcount == errnumber)\n    {\n    if ((mid & 0x80000000u) != 0)\n      {\n      fprintf(outfile, \"Can't find minimum %s limit: check pattern for \"\n        \"restriction\\n\", msg);\n      break;\n      }\n\n    min = mid;\n    mid = (mid == max - 1)? max : (max != UINT32_MAX)? (min + max)/2 : mid*2;\n    }\n  else if (capcount >= 0 ||\n           capcount == PCRE2_ERROR_NOMATCH ||\n           capcount == PCRE2_ERROR_PARTIAL)\n    {\n    /* If we've not hit the error with a heap limit less than the size of the\n    initial stack frame vector (for pcre2_match()) or the initial stack\n    workspace vector (for pcre2_dfa_match()), the heap is not being used, so\n    the minimum limit is zero; there's no need to go on. The other limits are\n    always greater than zero. */\n\n    if (errnumber == PCRE2_ERROR_HEAPLIMIT && mid < stack_start)\n      {\n      fprintf(outfile, \"Minimum %s limit = 0\\n\", msg);\n      break;\n      }\n    if (mid == min + 1)\n      {\n      fprintf(outfile, \"Minimum %s limit = %d\\n\", msg, mid);\n      break;\n      }\n    max = mid;\n    mid = (min + max)/2;\n    }\n  else break;    /* Some other error */\n  }\n\nreturn capcount;\n}\n\n\n\n/*************************************************\n*        Substitute callout function             *\n*************************************************/\n\n/* Called from pcre2_substitute() when the substitute_callout modifier is set.\nPrint out the data that is passed back. The substitute callout block is\nidentical for all code unit widths, so we just pick one.\n\nArguments:\n  scb         pointer to substitute callout block\n  data_ptr    callout data\n\nReturns:      nothing\n*/\n\nstatic int\nsubstitute_callout_function(pcre2_substitute_callout_block_8 *scb,\n  void *data_ptr)\n{\nint yield = 0;\nBOOL utf = (FLD(compiled_code, overall_options) & PCRE2_UTF) != 0;\n(void)data_ptr;   /* Not used */\n\nfprintf(outfile, \"%2d(%d) Old %\" SIZ_FORM \" %\" SIZ_FORM \" \\\"\",\n  scb->subscount, scb->oveccount,\n  SIZ_CAST scb->ovector\u00dd0\u00a8, SIZ_CAST scb->ovector\u00dd1\u00a8);\n\nPCHARSV(scb->input, scb->ovector\u00dd0\u00a8, scb->ovector\u00dd1\u00a8 - scb->ovector\u00dd0\u00a8,\n  utf, outfile);\n\nfprintf(outfile, \"\\\" New %\" SIZ_FORM \" %\" SIZ_FORM \" \\\"\",\n  SIZ_CAST scb->output_offsets\u00dd0\u00a8, SIZ_CAST scb->output_offsets\u00dd1\u00a8);\n\nPCHARSV(scb->output, scb->output_offsets\u00dd0\u00a8,\n  scb->output_offsets\u00dd1\u00a8 - scb->output_offsets\u00dd0\u00a8, utf, outfile);\n\nif (scb->subscount == dat_datctl.substitute_stop)\n  {\n  yield = -1;\n  fprintf(outfile, \" STOPPED\");\n  }\nelse if (scb->subscount == dat_datctl.substitute_skip)\n  {\n  yield = +1;\n  fprintf(outfile, \" SKIPPED\");\n  }\n\nfprintf(outfile, \"\\\"\\n\");\nreturn yield;\n}\n\n\n/*************************************************\n*              Callout function                  *\n*************************************************/\n\n/* Called from a PCRE2 library as a result of the (?C) item. We print out where\nwe are in the match (unless suppressed). Yield zero unless more callouts than\nthe fail count, or the callout data is not zero. The only differences in the\ncallout block for different code unit widths are that the pointers to the\nsubject, the most recent MARK, and a callout argument string point to strings\nof the appropriate width. Casts can be used to deal with this.\n\nArguments:\n  cb                a pointer to a callout block\n  callout_data_ptr  the provided callout data\n\nReturns:            0 or 1 or an error, as determined by settings\n*/\n\nstatic int\ncallout_function(pcre2_callout_block_8 *cb, void *callout_data_ptr)\n{\nFILE *f, *fdefault;\nuint32_t i, pre_start, post_start, subject_length;\nPCRE2_SIZE current_position;\nBOOL utf = (FLD(compiled_code, overall_options) & PCRE2_UTF) != 0;\nBOOL callout_capture = (dat_datctl.control & CTL_CALLOUT_CAPTURE) != 0;\nBOOL callout_where = (dat_datctl.control2 & CTL2_CALLOUT_NO_WHERE) == 0;\n\n/* The FILE f is used for echoing the subject string if it is non-NULL. This\nhappens only once in simple cases, but we want to repeat after any additional\noutput caused by CALLOUT_EXTRA. */\n\nfdefault = (!first_callout && !callout_capture && cb->callout_string == NULL)?\n  NULL : outfile;\n\nif ((dat_datctl.control2 & CTL2_CALLOUT_EXTRA) != 0)\n  {\n  f = outfile;\n  switch (cb->callout_flags)\n    {\n    case PCRE2_CALLOUT_BACKTRACK:\n    fprintf(f, \"Backtrack\\n\");\n    break;\n\n    case PCRE2_CALLOUT_STARTMATCH|PCRE2_CALLOUT_BACKTRACK:\n    fprintf(f, \"Backtrack\\nNo other matching paths\\n\");\n    /* Fall through */\n\n    case PCRE2_CALLOUT_STARTMATCH:\n    fprintf(f, \"New match attempt\\n\");\n    break;\n\n    default:\n    f = fdefault;\n    break;\n    }\n  }\nelse f = fdefault;\n\n/* For a callout with a string argument, show the string first because there\nisn't a tidy way to fit it in the rest of the data. */\n\nif (cb->callout_string != NULL)\n  {\n  uint32_t delimiter = CODE_UNIT(cb->callout_string, -1);\n  fprintf(outfile, \"Callout (%\" SIZ_FORM \"): %c\",\n    SIZ_CAST cb->callout_string_offset, delimiter);\n  PCHARSV(cb->callout_string, 0,\n    cb->callout_string_length, utf, outfile);\n  for (i = 0; callout_start_delims\u00ddi\u00a8 != 0; i++)\n    if (delimiter == callout_start_delims\u00ddi\u00a8)\n      {\n      delimiter = callout_end_delims\u00ddi\u00a8;\n      break;\n      }\n  fprintf(outfile, \"%c\", delimiter);\n  if (!callout_capture) fprintf(outfile, \"\\n\");\n  }\n\n/* Show captured strings if required */\n\nif (callout_capture)\n  {\n  if (cb->callout_string == NULL)\n    fprintf(outfile, \"Callout %d:\", cb->callout_number);\n  fprintf(outfile, \" last capture = %d\\n\", cb->capture_last);\n  for (i = 2; i < cb->capture_top * 2; i += 2)\n    {\n    fprintf(outfile, \"%2d: \", i/2);\n    if (cb->offset_vector\u00ddi\u00a8 == PCRE2_UNSET)\n      fprintf(outfile, \"<unset>\");\n    else\n      {\n      PCHARSV(cb->subject, cb->offset_vector\u00ddi\u00a8,\n        cb->offset_vector\u00ddi+1\u00a8 - cb->offset_vector\u00ddi\u00a8, utf, f);\n      }\n    fprintf(outfile, \"\\n\");\n    }\n  }\n\n/* Unless suppressed, re-print the subject in canonical form (with escapes for\nnon-printing characters), the first time, or if giving full details. On\nsubsequent calls in the same match, we use PCHARS() just to find the printed\nlengths of the substrings. */\n\nif (callout_where)\n  {\n  if (f != NULL) fprintf(f, \"--->\");\n\n  /* The subject before the match start. */\n\n  PCHARS(pre_start, cb->subject, 0, cb->start_match, utf, f);\n\n  /* If a lookbehind is involved, the current position may be earlier than the\n  match start. If so, use the match start instead. */\n\n  current_position = (cb->current_position >= cb->start_match)?\n    cb->current_position : cb->start_match;\n\n  /* The subject between the match start and the current position. */\n\n  PCHARS(post_start, cb->subject, cb->start_match,\n    current_position - cb->start_match, utf, f);\n\n  /* Print from the current position to the end. */\n\n  PCHARSV(cb->subject, current_position, cb->subject_length - current_position,\n    utf, f);\n\n  /* Calculate the total subject printed length (no print). */\n\n  PCHARS(subject_length, cb->subject, 0, cb->subject_length, utf, NULL);\n\n  if (f != NULL) fprintf(f, \"\\n\");\n\n  /* For automatic callouts, show the pattern offset. Otherwise, for a\n  numerical callout whose number has not already been shown with captured\n  strings, show the number here. A callout with a string argument has been\n  displayed above. */\n\n  if (cb->callout_number == 255)\n    {\n    fprintf(outfile, \"%+3d \", (int)cb->pattern_position);\n    if (cb->pattern_position > 99) fprintf(outfile, \"\\n    \");\n    }\n  else\n    {\n    if (callout_capture || cb->callout_string != NULL) fprintf(outfile, \"    \");\n      else fprintf(outfile, \"%3d \", cb->callout_number);\n    }\n\n  /* Now show position indicators */\n\n  for (i = 0; i < pre_start; i++) fprintf(outfile, \" \");\n  fprintf(outfile, \"\u00ac\");\n\n  if (post_start > 0)\n    {\n    for (i = 0; i < post_start - 1; i++) fprintf(outfile, \" \");\n    fprintf(outfile, \"\u00ac\");\n    }\n\n  for (i = 0; i < subject_length - pre_start - post_start + 4; i++)\n    fprintf(outfile, \" \");\n\n  if (cb->next_item_length != 0)\n    fprintf(outfile, \"%.*s\", (int)(cb->next_item_length),\n      pbuffer8 + cb->pattern_position);\n  else\n    fprintf(outfile, \"End of pattern\");\n\n  fprintf(outfile, \"\\n\");\n  }\n\nfirst_callout = FALSE;\n\n/* Show any mark info */\n\nif (cb->mark != last_callout_mark)\n  {\n  if (cb->mark == NULL)\n    fprintf(outfile, \"Latest Mark: <unset>\\n\");\n  else\n    {\n    fprintf(outfile, \"Latest Mark: \");\n    PCHARSV(cb->mark, -1, -1, utf, outfile);\n    putc('\\n', outfile);\n    }\n  last_callout_mark = cb->mark;\n  }\n\n/* Show callout data */\n\nif (callout_data_ptr != NULL)\n  {\n  int callout_data = *((int32_t *)callout_data_ptr);\n  if (callout_data != 0)\n    {\n    fprintf(outfile, \"Callout data = %d\\n\", callout_data);\n    return callout_data;\n    }\n  }\n\n/* Keep count and give the appropriate return code */\n\ncallout_count++;\n\nif (cb->callout_number == dat_datctl.cerror\u00dd0\u00a8 &&\n    callout_count >= dat_datctl.cerror\u00dd1\u00a8)\n  return PCRE2_ERROR_CALLOUT;\n\nif (cb->callout_number == dat_datctl.cfail\u00dd0\u00a8 &&\n    callout_count >= dat_datctl.cfail\u00dd1\u00a8)\n  return 1;\n\nreturn 0;\n}\n\n\n\n/*************************************************\n*       Handle *MARK and copy/get tests          *\n*************************************************/\n\n/* This function is called after complete and partial matches. It runs the\ntests for substring extraction.\n\nArguments:\n  utf       TRUE for utf\n  capcount  return from pcre2_match()\n\nReturns:    FALSE if print_error_message() fails\n*/\n\nstatic BOOL\ncopy_and_get(BOOL utf, int capcount)\n{\nint i;\nuint8_t *nptr;\n\n/* Test copy strings by number */\n\nfor (i = 0; i < MAXCPYGET && dat_datctl.copy_numbers\u00ddi\u00a8 >= 0; i++)\n  {\n  int rc;\n  PCRE2_SIZE length, length2;\n  uint32_t copybuffer\u00dd256\u00a8;\n  uint32_t n = (uint32_t)(dat_datctl.copy_numbers\u00ddi\u00a8);\n  length = sizeof(copybuffer)/code_unit_size;\n  PCRE2_SUBSTRING_COPY_BYNUMBER(rc, match_data, n, copybuffer, &length);\n  if (rc < 0)\n    {\n    fprintf(outfile, \"Copy substring %d failed (%d): \", n, rc);\n    if (!print_error_message(rc, \"\", \"\\n\")) return FALSE;\n    }\n  else\n    {\n    PCRE2_SUBSTRING_LENGTH_BYNUMBER(rc, match_data, n, &length2);\n    if (rc < 0)\n      {\n      fprintf(outfile, \"Get substring %d length failed (%d): \", n, rc);\n      if (!print_error_message(rc, \"\", \"\\n\")) return FALSE;\n      }\n    else if (length2 != length)\n      {\n      fprintf(outfile, \"Mismatched substring lengths: %\"\n        SIZ_FORM \" %\" SIZ_FORM \"\\n\", SIZ_CAST length, SIZ_CAST length2);\n      }\n    fprintf(outfile, \"%2dC \", n);\n    PCHARSV(copybuffer, 0, length, utf, outfile);\n    fprintf(outfile, \" (%\" SIZ_FORM \")\\n\", SIZ_CAST length);\n    }\n  }\n\n/* Test copy strings by name */\n\nnptr = dat_datctl.copy_names;\nfor (;;)\n  {\n  int rc;\n  int groupnumber;\n  PCRE2_SIZE length, length2;\n  uint32_t copybuffer\u00dd256\u00a8;\n  int namelen = strlen((const char *)nptr);\n#if defined SUPPORT_PCRE2_16 || defined SUPPORT_PCRE2_32\n  PCRE2_SIZE cnl = namelen;\n#endif\n  if (namelen == 0) break;\n\n#ifdef SUPPORT_PCRE2_8\n  if (test_mode == PCRE8_MODE) strcpy((char *)pbuffer8, (char *)nptr);\n#endif\n#ifdef SUPPORT_PCRE2_16\n  if (test_mode == PCRE16_MODE)(void)to16(nptr, utf, &cnl);\n#endif\n#ifdef SUPPORT_PCRE2_32\n  if (test_mode == PCRE32_MODE)(void)to32(nptr, utf, &cnl);\n#endif\n\n  PCRE2_SUBSTRING_NUMBER_FROM_NAME(groupnumber, compiled_code, pbuffer);\n  if (groupnumber < 0 && groupnumber != PCRE2_ERROR_NOUNIQUESUBSTRING)\n    fprintf(outfile, \"Number not found for group '%s'\\n\", nptr);\n\n  length = sizeof(copybuffer)/code_unit_size;\n  PCRE2_SUBSTRING_COPY_BYNAME(rc, match_data, pbuffer, copybuffer, &length);\n  if (rc < 0)\n    {\n    fprintf(outfile, \"Copy substring '%s' failed (%d): \", nptr, rc);\n    if (!print_error_message(rc, \"\", \"\\n\")) return FALSE;\n    }\n  else\n    {\n    PCRE2_SUBSTRING_LENGTH_BYNAME(rc, match_data, pbuffer, &length2);\n    if (rc < 0)\n      {\n      fprintf(outfile, \"Get substring '%s' length failed (%d): \", nptr, rc);\n      if (!print_error_message(rc, \"\", \"\\n\")) return FALSE;\n      }\n    else if (length2 != length)\n      {\n      fprintf(outfile, \"Mismatched substring lengths: %\"\n        SIZ_FORM \" %\" SIZ_FORM \"\\n\", SIZ_CAST length, SIZ_CAST length2);\n      }\n    fprintf(outfile, \"  C \");\n    PCHARSV(copybuffer, 0, length, utf, outfile);\n    fprintf(outfile, \" (%\" SIZ_FORM \") %s\", SIZ_CAST length, nptr);\n    if (groupnumber >= 0) fprintf(outfile, \" (group %d)\\n\", groupnumber);\n      else fprintf(outfile, \" (non-unique)\\n\");\n    }\n  nptr += namelen + 1;\n  }\n\n/* Test get strings by number */\n\nfor (i = 0; i < MAXCPYGET && dat_datctl.get_numbers\u00ddi\u00a8 >= 0; i++)\n  {\n  int rc;\n  PCRE2_SIZE length;\n  void *gotbuffer;\n  uint32_t n = (uint32_t)(dat_datctl.get_numbers\u00ddi\u00a8);\n  PCRE2_SUBSTRING_GET_BYNUMBER(rc, match_data, n, &gotbuffer, &length);\n  if (rc < 0)\n    {\n    fprintf(outfile, \"Get substring %d failed (%d): \", n, rc);\n    if (!print_error_message(rc, \"\", \"\\n\")) return FALSE;\n    }\n  else\n    {\n    fprintf(outfile, \"%2dG \", n);\n    PCHARSV(gotbuffer, 0, length, utf, outfile);\n    fprintf(outfile, \" (%\" SIZ_FORM \")\\n\", SIZ_CAST length);\n    PCRE2_SUBSTRING_FREE(gotbuffer);\n    }\n  }\n\n/* Test get strings by name */\n\nnptr = dat_datctl.get_names;\nfor (;;)\n  {\n  PCRE2_SIZE length;\n  void *gotbuffer;\n  int rc;\n  int groupnumber;\n  int namelen = strlen((const char *)nptr);\n#if defined SUPPORT_PCRE2_16 || defined SUPPORT_PCRE2_32\n  PCRE2_SIZE cnl = namelen;\n#endif\n  if (namelen == 0) break;\n\n#ifdef SUPPORT_PCRE2_8\n  if (test_mode == PCRE8_MODE) strcpy((char *)pbuffer8, (char *)nptr);\n#endif\n#ifdef SUPPORT_PCRE2_16\n  if (test_mode == PCRE16_MODE)(void)to16(nptr, utf, &cnl);\n#endif\n#ifdef SUPPORT_PCRE2_32\n  if (test_mode == PCRE32_MODE)(void)to32(nptr, utf, &cnl);\n#endif\n\n  PCRE2_SUBSTRING_NUMBER_FROM_NAME(groupnumber, compiled_code, pbuffer);\n  if (groupnumber < 0 && groupnumber != PCRE2_ERROR_NOUNIQUESUBSTRING)\n    fprintf(outfile, \"Number not found for group '%s'\\n\", nptr);\n\n  PCRE2_SUBSTRING_GET_BYNAME(rc, match_data, pbuffer, &gotbuffer, &length);\n  if (rc < 0)\n    {\n    fprintf(outfile, \"Get substring '%s' failed (%d): \", nptr, rc);\n    if (!print_error_message(rc, \"\", \"\\n\")) return FALSE;\n    }\n  else\n    {\n    fprintf(outfile, \"  G \");\n    PCHARSV(gotbuffer, 0, length, utf, outfile);\n    fprintf(outfile, \" (%\" SIZ_FORM \") %s\", SIZ_CAST length, nptr);\n    if (groupnumber >= 0) fprintf(outfile, \" (group %d)\\n\", groupnumber);\n      else fprintf(outfile, \" (non-unique)\\n\");\n    PCRE2_SUBSTRING_FREE(gotbuffer);\n    }\n  nptr += namelen + 1;\n  }\n\n/* Test getting the complete list of captured strings. */\n\nif ((dat_datctl.control & CTL_GETALL) != 0)\n  {\n  int rc;\n  void **stringlist;\n  PCRE2_SIZE *lengths;\n  PCRE2_SUBSTRING_LIST_GET(rc, match_data, &stringlist, &lengths);\n  if (rc < 0)\n    {\n    fprintf(outfile, \"get substring list failed (%d): \", rc);\n    if (!print_error_message(rc, \"\", \"\\n\")) return FALSE;\n    }\n  else\n    {\n    for (i = 0; i < capcount; i++)\n      {\n      fprintf(outfile, \"%2dL \", i);\n      PCHARSV(stringlist\u00ddi\u00a8, 0, lengths\u00ddi\u00a8, utf, outfile);\n      putc('\\n', outfile);\n      }\n    if (stringlist\u00ddi\u00a8 != NULL)\n      fprintf(outfile, \"string list not terminated by NULL\\n\");\n    PCRE2_SUBSTRING_LIST_FREE(stringlist);\n    }\n  }\n\nreturn TRUE;\n}\n\n\n\n/*************************************************\n*            Show an entire ovector              *\n*************************************************/\n\n/* This function is called after partial matching or match failure, when the\n\"allvector\" modifier is set. It is a means of checking the contents of the\nentire ovector, to ensure no modification of fields that should be unchanged.\n\nArguments:\n  ovector      points to the ovector\n  oveccount    number of pairs\n\nReturns:       nothing\n*/\n\nstatic void\nshow_ovector(PCRE2_SIZE *ovector, uint32_t oveccount)\n{\nuint32_t i;\nfor (i = 0; i < 2*oveccount; i += 2)\n  {\n  PCRE2_SIZE start = ovector\u00ddi\u00a8;\n  PCRE2_SIZE end = ovector\u00ddi+1\u00a8;\n\n  fprintf(outfile, \"%2d: \", i/2);\n  if (start == PCRE2_UNSET && end == PCRE2_UNSET)\n    fprintf(outfile, \"<unset>\\n\");\n  else if (start == JUNK_OFFSET && end == JUNK_OFFSET)\n    fprintf(outfile, \"<unchanged>\\n\");\n  else\n    fprintf(outfile, \"%ld %ld\\n\", (unsigned long int)start,\n      (unsigned long int)end);\n  }\n}\n\n\n/*************************************************\n*               Process a data line              *\n*************************************************/\n\n/* The line is in buffer; it will not be empty.\n\nArguments:  none\n\nReturns:    PR_OK     continue processing next line\n            PR_SKIP   skip to a blank line\n            PR_ABEND  abort the pcre2test run\n*/\n\nstatic int\nprocess_data(void)\n{\nPCRE2_SIZE len, ulen, arg_ulen;\nuint32_t gmatched;\nuint32_t c, k;\nuint32_t g_notempty = 0;\nuint8_t *p, *pp, *start_rep;\nsize_t needlen;\nvoid *use_dat_context;\nBOOL utf;\nBOOL subject_literal;\n\nPCRE2_SIZE *ovector;\nPCRE2_SIZE ovecsave\u00dd3\u00a8;\nuint32_t oveccount;\n\n#ifdef SUPPORT_PCRE2_8\nuint8_t *q8 = NULL;\n#endif\n#ifdef SUPPORT_PCRE2_16\nuint16_t *q16 = NULL;\n#endif\n#ifdef SUPPORT_PCRE2_32\nuint32_t *q32 = NULL;\n#endif\n\nsubject_literal = (pat_patctl.control2 & CTL2_SUBJECT_LITERAL) != 0;\n\n/* Copy the default context and data control blocks to the active ones. Then\ncopy from the pattern the controls that can be set in either the pattern or the\ndata. This allows them to be overridden in the data line. We do not do this for\noptions because those that are common apply separately to compiling and\nmatching. */\n\nDATCTXCPY(dat_context, default_dat_context);\nmemcpy(&dat_datctl, &def_datctl, sizeof(datctl));\ndat_datctl.control |= (pat_patctl.control & CTL_ALLPD);\ndat_datctl.control2 |= (pat_patctl.control2 & CTL2_ALLPD);\nstrcpy((char *)dat_datctl.replacement, (char *)pat_patctl.replacement);\nif (dat_datctl.jitstack == 0) dat_datctl.jitstack = pat_patctl.jitstack;\n\nif (dat_datctl.substitute_skip == 0)\n    dat_datctl.substitute_skip = pat_patctl.substitute_skip;\nif (dat_datctl.substitute_stop == 0)\n    dat_datctl.substitute_stop = pat_patctl.substitute_stop;\n\n/* Initialize for scanning the data line. */\n\n#ifdef SUPPORT_PCRE2_8\nutf = ((((pat_patctl.control & CTL_POSIX) != 0)?\n  ((pcre2_real_code_8 *)preg.re_pcre2_code)->overall_options :\n  FLD(compiled_code, overall_options)) & PCRE2_UTF) != 0;\n#else\nutf = (FLD(compiled_code, overall_options) & PCRE2_UTF) != 0;\n#endif\n\nstart_rep = NULL;\nlen = strlen((const char *)buffer);\nwhile (len > 0 && isspace(buffer\u00ddlen-1\u00a8)) len--;\nbuffer\u00ddlen\u00a8 = 0;\np = buffer;\nwhile (isspace(*p)) p++;\n\n/* Check that the data is well-formed UTF-8 if we're in UTF mode. To create\ninvalid input to pcre2_match(), you must use \\x?? or \\x{} sequences. */\n\nif (utf)\n  {\n  uint8_t *q;\n  uint32_t cc;\n  int n = 1;\n  for (q = p; n > 0 && *q; q += n) n = utf82ord(q, &cc);\n  if (n <= 0)\n    {\n    fprintf(outfile, \"** Failed: invalid UTF-8 string cannot be used as input \"\n      \"in UTF mode\\n\");\n    return PR_OK;\n    }\n  }\n\n#ifdef SUPPORT_VALGRIND\n/* Mark the dbuffer as addressable but undefined again. */\nif (dbuffer != NULL)\n  {\n  VALGRIND_MAKE_MEM_UNDEFINED(dbuffer, dbuffer_size);\n  }\n#endif\n\n/* Allocate a buffer to hold the data line; len+1 is an upper bound on\nthe number of code units that will be needed (though the buffer may have to be\nextended if replication is involved). */\n\nneedlen = (size_t)((len+1) * code_unit_size);\nif (dbuffer == NULL || needlen >= dbuffer_size)\n  {\n  while (needlen >= dbuffer_size) dbuffer_size *= 2;\n  dbuffer = (uint8_t *)realloc(dbuffer, dbuffer_size);\n  if (dbuffer == NULL)\n    {\n    fprintf(stderr, \"pcre2test: realloc(%d) failed\\n\", (int)dbuffer_size);\n    exit(1);\n    }\n  }\nSETCASTPTR(q, dbuffer);  /* Sets q8, q16, or q32, as appropriate. */\n\n/* Scan the data line, interpreting data escapes, and put the result into a\nbuffer of the appropriate width. In UTF mode, input is always UTF-8; otherwise,\nin 16- and 32-bit modes, it can be forced to UTF-8 by the utf8_input modifier.\n*/\n\nwhile ((c = *p++) != 0)\n  {\n  int32_t i = 0;\n  size_t replen;\n\n  /* \u00a8 may mark the end of a replicated sequence */\n\n  if (c == '\u00a8' && start_rep != NULL)\n    {\n    long li;\n    char *endptr;\n    size_t qoffset = CAST8VAR(q) - dbuffer;\n    size_t rep_offset = start_rep - dbuffer;\n\n    if (*p++ != '{')\n      {\n      fprintf(outfile, \"** Expected '{' after \\\\\u00dd....\u00a8\\n\");\n      return PR_OK;\n      }\n\n    li = strtol((const char *)p, &endptr, 10);\n    if (S32OVERFLOW(li))\n      {\n      fprintf(outfile, \"** Repeat count too large\\n\");\n      return PR_OK;\n      }\n\n    p = (uint8_t *)endptr;\n    if (*p++ != '}')\n      {\n      fprintf(outfile, \"** Expected '}' after \\\\\u00dd...\u00a8{...\\n\");\n      return PR_OK;\n      }\n\n    i = (int32_t)li;\n    if (i-- == 0)\n      {\n      fprintf(outfile, \"** Zero repeat not allowed\\n\");\n      return PR_OK;\n      }\n\n    replen = CAST8VAR(q) - start_rep;\n    needlen += replen * i;\n\n    if (needlen >= dbuffer_size)\n      {\n      while (needlen >= dbuffer_size) dbuffer_size *= 2;\n      dbuffer = (uint8_t *)realloc(dbuffer, dbuffer_size);\n      if (dbuffer == NULL)\n        {\n        fprintf(stderr, \"pcre2test: realloc(%d) failed\\n\", (int)dbuffer_size);\n        exit(1);\n        }\n      SETCASTPTR(q, dbuffer + qoffset);\n      start_rep = dbuffer + rep_offset;\n      }\n\n    while (i-- > 0)\n      {\n      memcpy(CAST8VAR(q), start_rep, replen);\n      SETPLUS(q, replen/code_unit_size);\n      }\n\n    start_rep = NULL;\n    continue;\n    }\n\n  /* Handle a non-escaped character. In non-UTF 32-bit mode with utf8_input\n  set, do the fudge for setting the top bit. */\n\n  if (c != '\\\\' || subject_literal)\n    {\n    uint32_t topbit = 0;\n    if (test_mode == PCRE32_MODE && c == 0xff && *p != 0)\n      {\n      topbit = 0x80000000;\n      c = *p++;\n      }\n    if ((utf || (pat_patctl.control & CTL_UTF8_INPUT) != 0) &&\n      HASUTF8EXTRALEN(c)) { GETUTF8INC(c, p); }\n    c |= topbit;\n    }\n\n  /* Handle backslash escapes */\n\n  else switch ((c = *p++))\n    {\n    case '\\\\': break;\n    case 'a': c = CHAR_BEL; break;\n    case 'b': c = '\\b'; break;\n    case 'e': c = CHAR_ESC; break;\n    case 'f': c = '\\f'; break;\n    case 'n': c = '\\n'; break;\n    case 'r': c = '\\r'; break;\n    case 't': c = '\\t'; break;\n    case 'v': c = '\\v'; break;\n\n    case '0': case '1': case '2': case '3':\n    case '4': case '5': case '6': case '7':\n    c -= '0';\n    while (i++ < 2 && isdigit(*p) && *p != '8' && *p != '9')\n      c = c * 8 + *p++ - '0';\n    break;\n\n    case 'o':\n    if (*p == '{')\n      {\n      uint8_t *pt = p;\n      c = 0;\n      for (pt++; isdigit(*pt) && *pt != '8' && *pt != '9'; pt++)\n        {\n        if (++i == 12)\n          fprintf(outfile, \"** Too many octal digits in \\\\o{...} item; \"\n                           \"using only the first twelve.\\n\");\n        else c = c * 8 + *pt - '0';\n        }\n      if (*pt == '}') p = pt + 1;\n        else fprintf(outfile, \"** Missing } after \\\\o{ (assumed)\\n\");\n      }\n    break;\n\n    case 'x':\n    if (*p == '{')\n      {\n      uint8_t *pt = p;\n      c = 0;\n\n      /* We used to have \"while (isxdigit(*(++pt)))\" here, but it fails\n      when isxdigit() is a macro that refers to its argument more than\n      once. This is banned by the C Standard, but apparently happens in at\n      least one MacOS environment. */\n\n      for (pt++; isxdigit(*pt); pt++)\n        {\n        if (++i == 9)\n          fprintf(outfile, \"** Too many hex digits in \\\\x{...} item; \"\n                           \"using only the first eight.\\n\");\n        else c = c * 16 + tolower(*pt) - ((isdigit(*pt))? '0' : 'a' - 10);\n        }\n      if (*pt == '}')\n        {\n        p = pt + 1;\n        break;\n        }\n      /* Not correct form for \\x{...}; fall through */\n      }\n\n    /* \\x without {} always defines just one byte in 8-bit mode. This\n    allows UTF-8 characters to be constructed byte by byte, and also allows\n    invalid UTF-8 sequences to be made. Just copy the byte in UTF-8 mode.\n    Otherwise, pass it down as data. */\n\n    c = 0;\n    while (i++ < 2 && isxdigit(*p))\n      {\n      c = c * 16 + tolower(*p) - ((isdigit(*p))? '0' : 'a' - 10);\n      p++;\n      }\n#if defined SUPPORT_PCRE2_8\n    if (utf && (test_mode == PCRE8_MODE))\n      {\n      *q8++ = c;\n      continue;\n      }\n#endif\n    break;\n\n    case 0:     /* \\ followed by EOF allows for an empty line */\n    p--;\n    continue;\n\n    case '=':   /* \\= terminates the data, starts modifiers */\n    goto ENDSTRING;\n\n    case '\u00dd':   /* \\\u00dd introduces a replicated character sequence */\n    if (start_rep != NULL)\n      {\n      fprintf(outfile, \"** Nested replication is not supported\\n\");\n      return PR_OK;\n      }\n    start_rep = CAST8VAR(q);\n    continue;\n\n    default:\n    if (isalnum(c))\n      {\n      fprintf(outfile, \"** Unrecognized escape sequence \\\"\\\\%c\\\"\\n\", c);\n      return PR_OK;\n      }\n    }\n\n  /* We now have a character value in c that may be greater than 255.\n  In 8-bit mode we convert to UTF-8 if we are in UTF mode. Values greater\n  than 127 in UTF mode must have come from \\x{...} or octal constructs\n  because values from \\x.. get this far only in non-UTF mode. */\n\n#ifdef SUPPORT_PCRE2_8\n  if (test_mode == PCRE8_MODE)\n    {\n    if (utf)\n      {\n      if (c > 0x7fffffff)\n        {\n        fprintf(outfile, \"** Character \\\\x{%x} is greater than 0x7fffffff \"\n          \"and so cannot be converted to UTF-8\\n\", c);\n        return PR_OK;\n        }\n      q8 += ord2utf8(c, q8);\n      }\n    else\n      {\n      if (c > 0xffu)\n        {\n        fprintf(outfile, \"** Character \\\\x{%x} is greater than 255 \"\n          \"and UTF-8 mode is not enabled.\\n\", c);\n        fprintf(outfile, \"** Truncation will probably give the wrong \"\n          \"result.\\n\");\n        }\n      *q8++ = (uint8_t)c;\n      }\n    }\n#endif\n#ifdef SUPPORT_PCRE2_16\n  if (test_mode == PCRE16_MODE)\n    {\n    if (utf)\n      {\n      if (c > 0x10ffffu)\n        {\n        fprintf(outfile, \"** Failed: character \\\\x{%x} is greater than \"\n          \"0x10ffff and so cannot be converted to UTF-16\\n\", c);\n        return PR_OK;\n        }\n      else if (c >= 0x10000u)\n        {\n        c-= 0x10000u;\n        *q16++ = 0xD800 | (c >> 10);\n        *q16++ = 0xDC00 | (c & 0x3ff);\n        }\n      else\n        *q16++ = c;\n      }\n    else\n      {\n      if (c > 0xffffu)\n        {\n        fprintf(outfile, \"** Character \\\\x{%x} is greater than 0xffff \"\n          \"and UTF-16 mode is not enabled.\\n\", c);\n        fprintf(outfile, \"** Truncation will probably give the wrong \"\n          \"result.\\n\");\n        }\n\n      *q16++ = (uint16_t)c;\n      }\n    }\n#endif\n#ifdef SUPPORT_PCRE2_32\n  if (test_mode == PCRE32_MODE)\n    {\n    *q32++ = c;\n    }\n#endif\n  }\n\nENDSTRING:\nSET(*q, 0);\nlen = CASTVAR(uint8_t *, q) - dbuffer;    /* Length in bytes */\nulen = len/code_unit_size;                /* Length in code units */\narg_ulen = ulen;                          /* Value to use in match arg */\n\n/* If the string was terminated by \\= we must now interpret modifiers. */\n\nif (p\u00dd-1\u00a8 != 0 && !decode_modifiers(p, CTX_DAT, NULL, &dat_datctl))\n  return PR_OK;\n\n/* Setting substitute_{skip,fail} implies a substitute callout. */\n\nif (dat_datctl.substitute_skip != 0 || dat_datctl.substitute_stop != 0)\n  dat_datctl.control2 |= CTL2_SUBSTITUTE_CALLOUT;\n\n/* Check for mutually exclusive modifiers. At present, these are all in the\nfirst control word. */\n\nfor (k = 0; k < sizeof(exclusive_dat_controls)/sizeof(uint32_t); k++)\n  {\n  c = dat_datctl.control & exclusive_dat_controls\u00ddk\u00a8;\n  if (c != 0 && c != (c & (~c+1)))\n    {\n    show_controls(c, 0, \"** Not allowed together:\");\n    fprintf(outfile, \"\\n\");\n    return PR_OK;\n    }\n  }\n\nif (pat_patctl.replacement\u00dd0\u00a8 != 0)\n  {\n  if ((dat_datctl.control2 & CTL2_SUBSTITUTE_CALLOUT) != 0 &&\n      (dat_datctl.control & CTL_NULLCONTEXT) != 0)\n    {\n    fprintf(outfile, \"** Replacement callouts are not supported with null_context.\\n\");\n    return PR_OK;\n    }\n\n  if ((dat_datctl.control & CTL_ALLCAPTURES) != 0)\n    fprintf(outfile, \"** Ignored with replacement text: allcaptures\\n\");\n  }\n\n/* Warn for modifiers that are ignored for DFA. */\n\nif ((dat_datctl.control & CTL_DFA) != 0)\n  {\n  if ((dat_datctl.control & CTL_ALLCAPTURES) != 0)\n    fprintf(outfile, \"** Ignored after DFA matching: allcaptures\\n\");\n  }\n\n/* We now have the subject in dbuffer, with len containing the byte length, and\nulen containing the code unit length, with a copy in arg_ulen for use in match\nfunction arguments (this gets changed to PCRE2_ZERO_TERMINATED when the\nzero_terminate modifier is present).\n\nMove the data to the end of the buffer so that a read over the end can be\ncaught by valgrind or other means. If we have explicit valgrind support, mark\nthe unused start of the buffer unaddressable. If we are using the POSIX\ninterface, or testing zero-termination, we must include the terminating zero in\nthe usable data. */\n\nc = code_unit_size * (((pat_patctl.control & CTL_POSIX) +\n                       (dat_datctl.control & CTL_ZERO_TERMINATE) != 0)? 1:0);\npp = memmove(dbuffer + dbuffer_size - len - c, dbuffer, len + c);\n#ifdef SUPPORT_VALGRIND\n  VALGRIND_MAKE_MEM_NOACCESS(dbuffer, dbuffer_size - (len + c));\n#endif\n\n/* Now pp points to the subject string. POSIX matching is only possible in\n8-bit mode, and it does not support timing or other fancy features. Some were\nchecked at compile time, but we need to check the match-time settings here. */\n\n#ifdef SUPPORT_PCRE2_8\nif ((pat_patctl.control & CTL_POSIX) != 0)\n  {\n  int rc;\n  int eflags = 0;\n  regmatch_t *pmatch = NULL;\n  const char *msg = \"** Ignored with POSIX interface:\";\n\n  if (dat_datctl.cerror\u00dd0\u00a8 != CFORE_UNSET || dat_datctl.cerror\u00dd1\u00a8 != CFORE_UNSET)\n    prmsg(&msg, \"callout_error\");\n  if (dat_datctl.cfail\u00dd0\u00a8 != CFORE_UNSET || dat_datctl.cfail\u00dd1\u00a8 != CFORE_UNSET)\n    prmsg(&msg, \"callout_fail\");\n  if (dat_datctl.copy_numbers\u00dd0\u00a8 >= 0 || dat_datctl.copy_names\u00dd0\u00a8 != 0)\n    prmsg(&msg, \"copy\");\n  if (dat_datctl.get_numbers\u00dd0\u00a8 >= 0 || dat_datctl.get_names\u00dd0\u00a8 != 0)\n    prmsg(&msg, \"get\");\n  if (dat_datctl.jitstack != 0) prmsg(&msg, \"jitstack\");\n  if (dat_datctl.offset != 0) prmsg(&msg, \"offset\");\n\n  if ((dat_datctl.options & ~POSIX_SUPPORTED_MATCH_OPTIONS) != 0)\n    {\n    fprintf(outfile, \"%s\", msg);\n    show_match_options(dat_datctl.options & ~POSIX_SUPPORTED_MATCH_OPTIONS);\n    msg = \"\";\n    }\n  if ((dat_datctl.control & ~POSIX_SUPPORTED_MATCH_CONTROLS) != 0 ||\n      (dat_datctl.control2 & ~POSIX_SUPPORTED_MATCH_CONTROLS2) != 0)\n    {\n    show_controls(dat_datctl.control & ~POSIX_SUPPORTED_MATCH_CONTROLS,\n                  dat_datctl.control2 & ~POSIX_SUPPORTED_MATCH_CONTROLS2, msg);\n    msg = \"\";\n    }\n\n  if (msg\u00dd0\u00a8 == 0) fprintf(outfile, \"\\n\");\n\n  if (dat_datctl.oveccount > 0)\n    {\n    pmatch = (regmatch_t *)malloc(sizeof(regmatch_t) * dat_datctl.oveccount);\n    if (pmatch == NULL)\n      {\n      fprintf(outfile, \"** Failed to get memory for recording matching \"\n        \"information (size set = %du)\\n\", dat_datctl.oveccount);\n      return PR_OK;\n      }\n    }\n\n  if (dat_datctl.startend\u00dd0\u00a8 != CFORE_UNSET)\n    {\n    pmatch\u00dd0\u00a8.rm_so = dat_datctl.startend\u00dd0\u00a8;\n    pmatch\u00dd0\u00a8.rm_eo = (dat_datctl.startend\u00dd1\u00a8 != 0)?\n      dat_datctl.startend\u00dd1\u00a8 : len;\n    eflags |= REG_STARTEND;\n    }\n\n  if ((dat_datctl.options & PCRE2_NOTBOL) != 0) eflags |= REG_NOTBOL;\n  if ((dat_datctl.options & PCRE2_NOTEOL) != 0) eflags |= REG_NOTEOL;\n  if ((dat_datctl.options & PCRE2_NOTEMPTY) != 0) eflags |= REG_NOTEMPTY;\n\n  rc = regexec(&preg, (const char *)pp, dat_datctl.oveccount, pmatch, eflags);\n  if (rc != 0)\n    {\n    (void)regerror(rc, &preg, (char *)pbuffer8, pbuffer8_size);\n    fprintf(outfile, \"No match: POSIX code %d: %s\\n\", rc, pbuffer8);\n    }\n  else if ((pat_patctl.control & CTL_POSIX_NOSUB) != 0)\n    fprintf(outfile, \"Matched with REG_NOSUB\\n\");\n  else if (dat_datctl.oveccount == 0)\n    fprintf(outfile, \"Matched without capture\\n\");\n  else\n    {\n    size_t i, j;\n    size_t last_printed = (size_t)dat_datctl.oveccount;\n    for (i = 0; i < (size_t)dat_datctl.oveccount; i++)\n      {\n      if (pmatch\u00ddi\u00a8.rm_so >= 0)\n        {\n        PCRE2_SIZE start = pmatch\u00ddi\u00a8.rm_so;\n        PCRE2_SIZE end = pmatch\u00ddi\u00a8.rm_eo;\n        for (j = last_printed + 1; j < i; j++)\n          fprintf(outfile, \"%2d: <unset>\\n\", (int)j);\n        last_printed = i;\n        if (start > end)\n          {\n          start = pmatch\u00ddi\u00a8.rm_eo;\n          end = pmatch\u00ddi\u00a8.rm_so;\n          fprintf(outfile, \"Start of matched string is beyond its end - \"\n            \"displaying from end to start.\\n\");\n          }\n        fprintf(outfile, \"%2d: \", (int)i);\n        PCHARSV(pp, start, end - start, utf, outfile);\n        fprintf(outfile, \"\\n\");\n\n        if ((i == 0 && (dat_datctl.control & CTL_AFTERTEXT) != 0) ||\n            (dat_datctl.control & CTL_ALLAFTERTEXT) != 0)\n          {\n          fprintf(outfile, \"%2d+ \", (int)i);\n          /* Note: don't use the start/end variables here because we want to\n          show the text from what is reported as the end. */\n          PCHARSV(pp, pmatch\u00ddi\u00a8.rm_eo, len - pmatch\u00ddi\u00a8.rm_eo, utf, outfile);\n          fprintf(outfile, \"\\n\"); }\n        }\n      }\n    }\n  free(pmatch);\n  return PR_OK;\n  }\n#endif  /* SUPPORT_PCRE2_8 */\n\n /* Handle matching via the native interface. Check for consistency of\nmodifiers. */\n\nif (dat_datctl.startend\u00dd0\u00a8 != CFORE_UNSET)\n  fprintf(outfile, \"** \\\\=posix_startend ignored for non-POSIX matching\\n\");\n\n/* ALLUSEDTEXT is not supported with JIT, but JIT is not used with DFA\nmatching, even if the JIT compiler was used. */\n\nif ((dat_datctl.control & (CTL_ALLUSEDTEXT|CTL_DFA)) == CTL_ALLUSEDTEXT &&\n    FLD(compiled_code, executable_jit) != NULL)\n  {\n  fprintf(outfile, \"** Showing all consulted text is not supported by JIT: ignored\\n\");\n  dat_datctl.control &= ~CTL_ALLUSEDTEXT;\n  }\n\n/* Handle passing the subject as zero-terminated. */\n\nif ((dat_datctl.control & CTL_ZERO_TERMINATE) != 0)\n  arg_ulen = PCRE2_ZERO_TERMINATED;\n\n/* The nullcontext modifier is used to test calling pcre2_\u00ddjit_\u00a8match() with a\nNULL context. */\n\nuse_dat_context = ((dat_datctl.control & CTL_NULLCONTEXT) != 0)?\n  NULL : PTR(dat_context);\n\n/* Enable display of malloc/free if wanted. We can do this only if either the\npattern or the subject is processed with a context. */\n\nshow_memory = (dat_datctl.control & CTL_MEMORY) != 0;\n\nif (show_memory &&\n    (pat_patctl.control & dat_datctl.control & CTL_NULLCONTEXT) != 0)\n  fprintf(outfile, \"** \\\\=memory requires either a pattern or a subject \"\n    \"context: ignored\\n\");\n\n/* Create and assign a JIT stack if requested. */\n\nif (dat_datctl.jitstack != 0)\n  {\n  if (dat_datctl.jitstack != jit_stack_size)\n    {\n    PCRE2_JIT_STACK_FREE(jit_stack);\n    PCRE2_JIT_STACK_CREATE(jit_stack, 1, dat_datctl.jitstack * 1024, NULL);\n    jit_stack_size = dat_datctl.jitstack;\n    }\n  PCRE2_JIT_STACK_ASSIGN(dat_context, jit_callback, jit_stack);\n  }\n\n/* Or de-assign */\n\nelse if (jit_stack != NULL)\n  {\n  PCRE2_JIT_STACK_ASSIGN(dat_context, NULL, NULL);\n  PCRE2_JIT_STACK_FREE(jit_stack);\n  jit_stack = NULL;\n  jit_stack_size = 0;\n  }\n\n/* When no JIT stack is assigned, we must ensure that there is a JIT callback\nif we want to verify that JIT was actually used. */\n\nif ((pat_patctl.control & CTL_JITVERIFY) != 0 && jit_stack == NULL)\n   {\n   PCRE2_JIT_STACK_ASSIGN(dat_context, jit_callback, NULL);\n   }\n\n/* Adjust match_data according to size of offsets required. A size of zero\ncauses a new match data block to be obtained that exactly fits the pattern. */\n\nif (dat_datctl.oveccount == 0)\n  {\n  PCRE2_MATCH_DATA_FREE(match_data);\n  PCRE2_MATCH_DATA_CREATE_FROM_PATTERN(match_data, compiled_code, NULL);\n  PCRE2_GET_OVECTOR_COUNT(max_oveccount, match_data);\n  }\nelse if (dat_datctl.oveccount <= max_oveccount)\n  {\n  SETFLD(match_data, oveccount, dat_datctl.oveccount);\n  }\nelse\n  {\n  max_oveccount = dat_datctl.oveccount;\n  PCRE2_MATCH_DATA_FREE(match_data);\n  PCRE2_MATCH_DATA_CREATE(match_data, max_oveccount, NULL);\n  }\n\nif (CASTVAR(void *, match_data) == NULL)\n  {\n  fprintf(outfile, \"** Failed to get memory for recording matching \"\n    \"information (size requested: %d)\\n\", dat_datctl.oveccount);\n  max_oveccount = 0;\n  return PR_OK;\n  }\n\novector = FLD(match_data, ovector);\nPCRE2_GET_OVECTOR_COUNT(oveccount, match_data);\n\n/* Replacement processing is ignored for DFA matching. */\n\nif (dat_datctl.replacement\u00dd0\u00a8 != 0 && (dat_datctl.control & CTL_DFA) != 0)\n  {\n  fprintf(outfile, \"** Ignored for DFA matching: replace\\n\");\n  dat_datctl.replacement\u00dd0\u00a8 = 0;\n  }\n\n/* If a replacement string is provided, call pcre2_substitute() instead of one\nof the matching functions. First we have to convert the replacement string to\nthe appropriate width. */\n\nif (dat_datctl.replacement\u00dd0\u00a8 != 0)\n  {\n  int rc;\n  uint8_t *pr;\n  uint8_t rbuffer\u00ddREPLACE_BUFFSIZE\u00a8;\n  uint8_t nbuffer\u00ddREPLACE_BUFFSIZE\u00a8;\n  uint32_t xoptions;\n  uint32_t emoption;  /* External match option */\n  PCRE2_SIZE j, rlen, nsize, erroroffset;\n  BOOL badutf = FALSE;\n\n#ifdef SUPPORT_PCRE2_8\n  uint8_t *r8 = NULL;\n#endif\n#ifdef SUPPORT_PCRE2_16\n  uint16_t *r16 = NULL;\n#endif\n#ifdef SUPPORT_PCRE2_32\n  uint32_t *r32 = NULL;\n#endif\n\n  /* Fill the ovector with junk to detect elements that do not get set\n  when they should be (relevant only when \"allvector\" is specified). */\n\n  for (j = 0; j < 2*oveccount; j++) ovector\u00ddj\u00a8 = JUNK_OFFSET;\n\n  if (timeitm)\n    fprintf(outfile, \"** Timing is not supported with replace: ignored\\n\");\n\n  if ((dat_datctl.control & CTL_ALTGLOBAL) != 0)\n    fprintf(outfile, \"** Altglobal is not supported with replace: ignored\\n\");\n\n  /* Check for a test that does substitution after an initial external match.\n  If this is set, we run the external match, but leave the interpretation of\n  its output to pcre2_substitute(). */\n\n  emoption = ((dat_datctl.control2 & CTL2_SUBSTITUTE_MATCHED) == 0)? 0 :\n    PCRE2_SUBSTITUTE_MATCHED;\n\n  if (emoption != 0)\n    {\n    PCRE2_MATCH(rc, compiled_code, pp, arg_ulen, dat_datctl.offset,\n      dat_datctl.options, match_data, use_dat_context);\n    }\n\n  xoptions = emoption |\n             (((dat_datctl.control & CTL_GLOBAL) == 0)? 0 :\n                PCRE2_SUBSTITUTE_GLOBAL) |\n             (((dat_datctl.control2 & CTL2_SUBSTITUTE_EXTENDED) == 0)? 0 :\n                PCRE2_SUBSTITUTE_EXTENDED) |\n             (((dat_datctl.control2 & CTL2_SUBSTITUTE_LITERAL) == 0)? 0 :\n                PCRE2_SUBSTITUTE_LITERAL) |\n             (((dat_datctl.control2 & CTL2_SUBSTITUTE_OVERFLOW_LENGTH) == 0)? 0 :\n                PCRE2_SUBSTITUTE_OVERFLOW_LENGTH) |\n             (((dat_datctl.control2 & CTL2_SUBSTITUTE_REPLACEMENT_ONLY) == 0)? 0 :\n                PCRE2_SUBSTITUTE_REPLACEMENT_ONLY) |\n             (((dat_datctl.control2 & CTL2_SUBSTITUTE_UNKNOWN_UNSET) == 0)? 0 :\n                PCRE2_SUBSTITUTE_UNKNOWN_UNSET) |\n             (((dat_datctl.control2 & CTL2_SUBSTITUTE_UNSET_EMPTY) == 0)? 0 :\n                PCRE2_SUBSTITUTE_UNSET_EMPTY);\n\n  SETCASTPTR(r, rbuffer);  /* Sets r8, r16, or r32, as appropriate. */\n  pr = dat_datctl.replacement;\n\n  /* If the replacement starts with '\u00dd<number>\u00a8' we interpret that as length\n  value for the replacement buffer. */\n\n  nsize = REPLACE_BUFFSIZE/code_unit_size;\n  if (*pr == '\u00dd')\n    {\n    PCRE2_SIZE n = 0;\n    while ((c = *(++pr)) >= CHAR_0 && c <= CHAR_9) n = n * 10 + c - CHAR_0;\n    if (*pr++ != '\u00a8')\n      {\n      fprintf(outfile, \"Bad buffer size in replacement string\\n\");\n      return PR_OK;\n      }\n    if (n > nsize)\n      {\n      fprintf(outfile, \"Replacement buffer setting (%\" SIZ_FORM \") is too \"\n        \"large (max %\" SIZ_FORM \")\\n\", SIZ_CAST n, SIZ_CAST nsize);\n      return PR_OK;\n      }\n    nsize = n;\n    }\n\n  /* Now copy the replacement string to a buffer of the appropriate width. No\n  escape processing is done for replacements. In UTF mode, check for an invalid\n  UTF-8 input string, and if it is invalid, just copy its code units without\n  UTF interpretation. This provides a means of checking that an invalid string\n  is detected. Otherwise, UTF-8 can be used to include wide characters in a\n  replacement. */\n\n  if (utf) badutf = valid_utf(pr, strlen((const char *)pr), &erroroffset);\n\n  /* Not UTF or invalid UTF-8: just copy the code units. */\n\n  if (!utf || badutf)\n    {\n    while ((c = *pr++) != 0)\n      {\n#ifdef SUPPORT_PCRE2_8\n      if (test_mode == PCRE8_MODE) *r8++ = c;\n#endif\n#ifdef SUPPORT_PCRE2_16\n      if (test_mode == PCRE16_MODE) *r16++ = c;\n#endif\n#ifdef SUPPORT_PCRE2_32\n      if (test_mode == PCRE32_MODE) *r32++ = c;\n#endif\n      }\n    }\n\n  /* Valid UTF-8 replacement string */\n\n  else while ((c = *pr++) != 0)\n    {\n    if (HASUTF8EXTRALEN(c)) { GETUTF8INC(c, pr); }\n\n#ifdef SUPPORT_PCRE2_8\n    if (test_mode == PCRE8_MODE) r8 += ord2utf8(c, r8);\n#endif\n\n#ifdef SUPPORT_PCRE2_16\n    if (test_mode == PCRE16_MODE)\n      {\n      if (c >= 0x10000u)\n        {\n        c-= 0x10000u;\n        *r16++ = 0xD800 | (c >> 10);\n        *r16++ = 0xDC00 | (c & 0x3ff);\n        }\n      else *r16++ = c;\n      }\n#endif\n\n#ifdef SUPPORT_PCRE2_32\n    if (test_mode == PCRE32_MODE) *r32++ = c;\n#endif\n    }\n\n  SET(*r, 0);\n  if ((dat_datctl.control & CTL_ZERO_TERMINATE) != 0)\n    rlen = PCRE2_ZERO_TERMINATED;\n  else\n    rlen = (CASTVAR(uint8_t *, r) - rbuffer)/code_unit_size;\n\n  if ((dat_datctl.control2 & CTL2_SUBSTITUTE_CALLOUT) != 0)\n    {\n    PCRE2_SET_SUBSTITUTE_CALLOUT(dat_context, substitute_callout_function, NULL);\n    }\n  else\n    {\n    PCRE2_SET_SUBSTITUTE_CALLOUT(dat_context, NULL, NULL);  /* No callout */\n    }\n\n  PCRE2_SUBSTITUTE(rc, compiled_code, pp, arg_ulen, dat_datctl.offset,\n    dat_datctl.options|xoptions, match_data, use_dat_context,\n    rbuffer, rlen, nbuffer, &nsize);\n\n  if (rc < 0)\n    {\n    fprintf(outfile, \"Failed: error %d\", rc);\n    if (rc != PCRE2_ERROR_NOMEMORY && nsize != PCRE2_UNSET)\n      fprintf(outfile, \" at offset %ld in replacement\", (long int)nsize);\n    fprintf(outfile, \": \");\n    if (!print_error_message(rc, \"\", \"\")) return PR_ABEND;\n    if (rc == PCRE2_ERROR_NOMEMORY &&\n        (xoptions & PCRE2_SUBSTITUTE_OVERFLOW_LENGTH) != 0)\n      fprintf(outfile, \": %ld code units are needed\", (long int)nsize);\n    }\n  else\n    {\n    fprintf(outfile, \"%2d: \", rc);\n    PCHARSV(nbuffer, 0, nsize, utf, outfile);\n    }\n\n  fprintf(outfile, \"\\n\");\n  show_memory = FALSE;\n\n  /* Show final ovector contents if requested. */\n\n  if ((dat_datctl.control2 & CTL2_ALLVECTOR) != 0)\n    show_ovector(ovector, oveccount);\n\n  return PR_OK;\n  }   /* End of substitution handling */\n\n/* When a replacement string is not provided, run a loop for global matching\nwith one of the basic matching functions. For altglobal (or first time round\nthe loop), set an \"unset\" value for the previous match info. */\n\novecsave\u00dd0\u00a8 = ovecsave\u00dd1\u00a8 = ovecsave\u00dd2\u00a8 = PCRE2_UNSET;\n\nfor (gmatched = 0;; gmatched++)\n  {\n  PCRE2_SIZE j;\n  int capcount;\n\n  /* Fill the ovector with junk to detect elements that do not get set\n  when they should be. */\n\n  for (j = 0; j < 2*oveccount; j++) ovector\u00ddj\u00a8 = JUNK_OFFSET;\n\n  /* When matching is via pcre2_match(), we will detect the use of JIT via the\n  stack callback function. */\n\n  jit_was_used = (pat_patctl.control & CTL_JITFAST) != 0;\n\n  /* Do timing if required. */\n\n  if (timeitm > 0)\n    {\n    int i;\n    clock_t start_time, time_taken;\n\n    if ((dat_datctl.control & CTL_DFA) != 0)\n      {\n      if ((dat_datctl.options & PCRE2_DFA_RESTART) != 0)\n        {\n        fprintf(outfile, \"Timing DFA restarts is not supported\\n\");\n        return PR_OK;\n        }\n      if (dfa_workspace == NULL)\n        dfa_workspace = (int *)malloc(DFA_WS_DIMENSION*sizeof(int));\n      start_time = clock();\n      for (i = 0; i < timeitm; i++)\n        {\n        PCRE2_DFA_MATCH(capcount, compiled_code, pp, arg_ulen,\n          dat_datctl.offset, dat_datctl.options | g_notempty, match_data,\n          use_dat_context, dfa_workspace, DFA_WS_DIMENSION);\n        }\n      }\n\n    else if ((pat_patctl.control & CTL_JITFAST) != 0)\n      {\n      start_time = clock();\n      for (i = 0; i < timeitm; i++)\n        {\n        PCRE2_JIT_MATCH(capcount, compiled_code, pp, arg_ulen,\n          dat_datctl.offset, dat_datctl.options | g_notempty, match_data,\n          use_dat_context);\n        }\n      }\n\n    else\n      {\n      start_time = clock();\n      for (i = 0; i < timeitm; i++)\n        {\n        PCRE2_MATCH(capcount, compiled_code, pp, arg_ulen,\n          dat_datctl.offset, dat_datctl.options | g_notempty, match_data,\n          use_dat_context);\n        }\n      }\n    total_match_time += (time_taken = clock() - start_time);\n    fprintf(outfile, \"Match time %.4f milliseconds\\n\",\n      (((double)time_taken * 1000.0) / (double)timeitm) /\n        (double)CLOCKS_PER_SEC);\n    }\n\n  /* Find the heap, match and depth limits if requested. The depth and heap\n  limits are not relevant for JIT. The return from check_match_limit() is the\n  return from the final call to pcre2_match() or pcre2_dfa_match(). */\n\n  if ((dat_datctl.control & CTL_FINDLIMITS) != 0)\n    {\n    capcount = 0;  /* This stops compiler warnings */\n\n    if (FLD(compiled_code, executable_jit) == NULL ||\n          (dat_datctl.options & PCRE2_NO_JIT) != 0)\n      {\n      (void)check_match_limit(pp, arg_ulen, PCRE2_ERROR_HEAPLIMIT, \"heap\");\n      }\n\n    capcount = check_match_limit(pp, arg_ulen, PCRE2_ERROR_MATCHLIMIT,\n      \"match\");\n\n    if (FLD(compiled_code, executable_jit) == NULL ||\n        (dat_datctl.options & PCRE2_NO_JIT) != 0 ||\n        (dat_datctl.control & CTL_DFA) != 0)\n      {\n      capcount = check_match_limit(pp, arg_ulen, PCRE2_ERROR_DEPTHLIMIT,\n        \"depth\");\n      }\n\n    if (capcount == 0)\n      {\n      fprintf(outfile, \"Matched, but offsets vector is too small to show all matches\\n\");\n      capcount = dat_datctl.oveccount;\n      }\n    }\n\n  /* Otherwise just run a single match, setting up a callout if required (the\n  default). There is a copy of the pattern in pbuffer8 for use by callouts. */\n\n  else\n    {\n    if ((dat_datctl.control & CTL_CALLOUT_NONE) == 0)\n      {\n      PCRE2_SET_CALLOUT(dat_context, callout_function,\n        (void *)(&dat_datctl.callout_data));\n      first_callout = TRUE;\n      last_callout_mark = NULL;\n      callout_count = 0;\n      }\n    else\n      {\n      PCRE2_SET_CALLOUT(dat_context, NULL, NULL);  /* No callout */\n      }\n\n    /* Run a single DFA or NFA match. */\n\n    if ((dat_datctl.control & CTL_DFA) != 0)\n      {\n      if (dfa_workspace == NULL)\n        dfa_workspace = (int *)malloc(DFA_WS_DIMENSION*sizeof(int));\n      if (dfa_matched++ == 0)\n        dfa_workspace\u00dd0\u00a8 = -1;  /* To catch bad restart */\n      PCRE2_DFA_MATCH(capcount, compiled_code, pp, arg_ulen,\n        dat_datctl.offset, dat_datctl.options | g_notempty, match_data,\n        use_dat_context, dfa_workspace, DFA_WS_DIMENSION);\n      if (capcount == 0)\n        {\n        fprintf(outfile, \"Matched, but offsets vector is too small to show all matches\\n\");\n        capcount = dat_datctl.oveccount;\n        }\n      }\n    else\n      {\n      if ((pat_patctl.control & CTL_JITFAST) != 0)\n        PCRE2_JIT_MATCH(capcount, compiled_code, pp, arg_ulen, dat_datctl.offset,\n          dat_datctl.options | g_notempty, match_data, use_dat_context);\n      else\n        PCRE2_MATCH(capcount, compiled_code, pp, arg_ulen, dat_datctl.offset,\n          dat_datctl.options | g_notempty, match_data, use_dat_context);\n      if (capcount == 0)\n        {\n        fprintf(outfile, \"Matched, but too many substrings\\n\");\n        capcount = dat_datctl.oveccount;\n        }\n      }\n    }\n\n  /* The result of the match is now in capcount. First handle a successful\n  match. */\n\n  if (capcount >= 0)\n    {\n    int i;\n\n    if (capcount > (int)oveccount)   /* Check for lunatic return value */\n      {\n      fprintf(outfile,\n        \"** PCRE2 error: returned count %d is too big for ovector count %d\\n\",\n        capcount, oveccount);\n      capcount = oveccount;\n      if ((dat_datctl.control & CTL_ANYGLOB) != 0)\n        {\n        fprintf(outfile, \"** Global loop abandoned\\n\");\n        dat_datctl.control &= ~CTL_ANYGLOB;        /* Break g/G loop */\n        }\n      }\n\n    /* If PCRE2_COPY_MATCHED_SUBJECT was set, check that things are as they\n    should be, but not for fast JIT, where it isn't supported. */\n\n    if ((dat_datctl.options & PCRE2_COPY_MATCHED_SUBJECT) != 0 &&\n        (pat_patctl.control & CTL_JITFAST) == 0)\n      {\n      if ((FLD(match_data, flags) & PCRE2_MD_COPIED_SUBJECT) == 0)\n        fprintf(outfile,\n          \"** PCRE2 error: flag not set after copy_matched_subject\\n\");\n\n      if (CASTFLD(void *, match_data, subject) == pp)\n        fprintf(outfile,\n          \"** PCRE2 error: copy_matched_subject has not copied\\n\");\n\n      if (memcmp(CASTFLD(void *, match_data, subject), pp, ulen) != 0)\n        fprintf(outfile,\n          \"** PCRE2 error: copy_matched_subject mismatch\\n\");\n      }\n\n    /* If this is not the first time round a global loop, check that the\n    returned string has changed. If it has not, check for an empty string match\n    at different starting offset from the previous match. This is a failed test\n    retry for null-matching patterns that don't match at their starting offset,\n    for example /(?<=\\G.)/. A repeated match at the same point is not such a\n    pattern, and must be discarded, and we then proceed to seek a non-null\n    match at the current point. For any other repeated match, there is a bug\n    somewhere and we must break the loop because it will go on for ever. We\n    know that there are always at least two elements in the ovector. */\n\n    if (gmatched > 0 && ovecsave\u00dd0\u00a8 == ovector\u00dd0\u00a8 && ovecsave\u00dd1\u00a8 == ovector\u00dd1\u00a8)\n      {\n      if (ovector\u00dd0\u00a8 == ovector\u00dd1\u00a8 && ovecsave\u00dd2\u00a8 != dat_datctl.offset)\n        {\n        g_notempty = PCRE2_NOTEMPTY_ATSTART | PCRE2_ANCHORED;\n        ovecsave\u00dd2\u00a8 = dat_datctl.offset;\n        continue;    /* Back to the top of the loop */\n        }\n      fprintf(outfile,\n        \"** PCRE2 error: global repeat returned the same string as previous\\n\");\n      fprintf(outfile, \"** Global loop abandoned\\n\");\n      dat_datctl.control &= ~CTL_ANYGLOB;        /* Break g/G loop */\n      }\n\n    /* \"allcaptures\" requests showing of all captures in the pattern, to check\n    unset ones at the end. It may be set on the pattern or the data. Implement\n    by setting capcount to the maximum. This is not relevant for DFA matching,\n    so ignore it (warning given above). */\n\n    if ((dat_datctl.control & (CTL_ALLCAPTURES|CTL_DFA)) == CTL_ALLCAPTURES)\n      {\n      capcount = maxcapcount + 1;   /* Allow for full match */\n      if (capcount > (int)oveccount) capcount = oveccount;\n      }\n\n    /* \"allvector\" request showing the entire ovector. */\n\n    if ((dat_datctl.control2 & CTL2_ALLVECTOR) != 0) capcount = oveccount;\n\n    /* Output the captured substrings. Note that, for the matched string,\n    the use of \\K in an assertion can make the start later than the end. */\n\n    for (i = 0; i < 2*capcount; i += 2)\n      {\n      PCRE2_SIZE lleft, lmiddle, lright;\n      PCRE2_SIZE start = ovector\u00ddi\u00a8;\n      PCRE2_SIZE end = ovector\u00ddi+1\u00a8;\n\n      if (start > end)\n        {\n        start = ovector\u00ddi+1\u00a8;\n        end = ovector\u00ddi\u00a8;\n        fprintf(outfile, \"Start of matched string is beyond its end - \"\n          \"displaying from end to start.\\n\");\n        }\n\n      fprintf(outfile, \"%2d: \", i/2);\n\n      /* Check for an unset group */\n\n      if (start == PCRE2_UNSET && end == PCRE2_UNSET)\n        {\n        fprintf(outfile, \"<unset>\\n\");\n        continue;\n        }\n\n      /* Check for silly offsets, in particular, values that have not been\n      set when they should have been. However, if we are past the end of the\n      captures for this pattern (\"allvector\" causes this), or if we are DFA\n      matching, it isn't an error if the entry is unchanged. */\n\n      if (start > ulen || end > ulen)\n        {\n        if (((dat_datctl.control & CTL_DFA) != 0 ||\n              i >= (int)(2*maxcapcount + 2)) &&\n            start == JUNK_OFFSET && end == JUNK_OFFSET)\n          fprintf(outfile, \"<unchanged>\\n\");\n        else\n          fprintf(outfile, \"ERROR: bad value(s) for offset(s): 0x%lx 0x%lx\\n\",\n            (unsigned long int)start, (unsigned long int)end);\n        continue;\n        }\n\n      /* When JIT is not being used, ALLUSEDTEXT may be set. (It if is set with\n      JIT, it is disabled above, with a comment.) When the match is done by the\n      interpreter, leftchar and rightchar are available, and if ALLUSEDTEXT is\n      set, and if the leftmost consulted character is before the start of the\n      match or the rightmost consulted character is past the end of the match,\n      we want to show all consulted characters for the main matched string, and\n      indicate which were lookarounds. */\n\n      if (i == 0)\n        {\n        BOOL showallused;\n        PCRE2_SIZE leftchar, rightchar;\n\n        if ((dat_datctl.control & CTL_ALLUSEDTEXT) != 0)\n          {\n          leftchar = FLD(match_data, leftchar);\n          rightchar = FLD(match_data, rightchar);\n          showallused = i == 0 && (leftchar < start || rightchar > end);\n          }\n        else showallused = FALSE;\n\n        if (showallused)\n          {\n          PCHARS(lleft, pp, leftchar, start - leftchar, utf, outfile);\n          PCHARS(lmiddle, pp, start, end - start, utf, outfile);\n          PCHARS(lright, pp, end, rightchar - end, utf, outfile);\n          if ((pat_patctl.control & CTL_JITVERIFY) != 0 && jit_was_used)\n            fprintf(outfile, \" (JIT)\");\n          fprintf(outfile, \"\\n    \");\n          for (j = 0; j < lleft; j++) fprintf(outfile, \"<\");\n          for (j = 0; j < lmiddle; j++) fprintf(outfile, \" \");\n          for (j = 0; j < lright; j++) fprintf(outfile, \">\");\n          }\n\n        /* When a pattern contains \\K, the start of match position may be\n        different to the start of the matched string. When this is the case,\n        show it when requested. */\n\n        else if ((dat_datctl.control & CTL_STARTCHAR) != 0)\n          {\n          PCRE2_SIZE startchar;\n          PCRE2_GET_STARTCHAR(startchar, match_data);\n          PCHARS(lleft, pp, startchar, start - startchar, utf, outfile);\n          PCHARSV(pp, start, end - start, utf, outfile);\n          if ((pat_patctl.control & CTL_JITVERIFY) != 0 && jit_was_used)\n            fprintf(outfile, \" (JIT)\");\n          if (startchar != start)\n            {\n            fprintf(outfile, \"\\n    \");\n            for (j = 0; j < lleft; j++) fprintf(outfile, \"\u00ac\");\n            }\n          }\n\n        /* Otherwise, just show the matched string. */\n\n        else\n          {\n          PCHARSV(pp, start, end - start, utf, outfile);\n          if ((pat_patctl.control & CTL_JITVERIFY) != 0 && jit_was_used)\n            fprintf(outfile, \" (JIT)\");\n          }\n        }\n\n      /* Not the main matched string. Just show it unadorned. */\n\n      else\n        {\n        PCHARSV(pp, start, end - start, utf, outfile);\n        }\n\n      fprintf(outfile, \"\\n\");\n\n      /* Note: don't use the start/end variables here because we want to\n      show the text from what is reported as the end. */\n\n      if ((dat_datctl.control & CTL_ALLAFTERTEXT) != 0 ||\n          (i == 0 && (dat_datctl.control & CTL_AFTERTEXT) != 0))\n        {\n        fprintf(outfile, \"%2d+ \", i/2);\n        PCHARSV(pp, ovector\u00ddi+1\u00a8, ulen - ovector\u00ddi+1\u00a8, utf, outfile);\n        fprintf(outfile, \"\\n\");\n        }\n      }\n\n    /* Output (*MARK) data if requested */\n\n    if ((dat_datctl.control & CTL_MARK) != 0 &&\n         TESTFLD(match_data, mark, !=, NULL))\n      {\n      fprintf(outfile, \"MK: \");\n      PCHARSV(CASTFLD(void *, match_data, mark), -1, -1, utf, outfile);\n      fprintf(outfile, \"\\n\");\n      }\n\n    /* Process copy/get strings */\n\n    if (!copy_and_get(utf, capcount)) return PR_ABEND;\n\n    }    /* End of handling a successful match */\n\n  /* There was a partial match. The value of ovector\u00dd0\u00a8 is the bumpalong point,\n  that is, startchar, not any \\K point that might have been passed. When JIT is\n  not in use, \"allusedtext\" may be set, in which case we indicate the leftmost\n  consulted character. */\n\n  else if (capcount == PCRE2_ERROR_PARTIAL)\n    {\n    PCRE2_SIZE leftchar;\n    int backlength;\n    int rubriclength = 0;\n\n    if ((dat_datctl.control & CTL_ALLUSEDTEXT) != 0)\n      {\n      leftchar = FLD(match_data, leftchar);\n      }\n    else leftchar = ovector\u00dd0\u00a8;\n\n    fprintf(outfile, \"Partial match\");\n    if ((dat_datctl.control & CTL_MARK) != 0 &&\n         TESTFLD(match_data, mark, !=, NULL))\n      {\n      fprintf(outfile, \", mark=\");\n      PCHARS(rubriclength, CASTFLD(void *, match_data, mark), -1, -1, utf,\n        outfile);\n      rubriclength += 7;\n      }\n    fprintf(outfile, \": \");\n    rubriclength += 15;\n\n    PCHARS(backlength, pp, leftchar, ovector\u00dd0\u00a8 - leftchar, utf, outfile);\n    PCHARSV(pp, ovector\u00dd0\u00a8, ulen - ovector\u00dd0\u00a8, utf, outfile);\n\n    if ((pat_patctl.control & CTL_JITVERIFY) != 0 && jit_was_used)\n      fprintf(outfile, \" (JIT)\");\n    fprintf(outfile, \"\\n\");\n\n    if (backlength != 0)\n      {\n      int i;\n      for (i = 0; i < rubriclength; i++) fprintf(outfile, \" \");\n      for (i = 0; i < backlength; i++) fprintf(outfile, \"<\");\n      fprintf(outfile, \"\\n\");\n      }\n\n    if (ulen != ovector\u00dd1\u00a8)\n      fprintf(outfile, \"** ovector\u00dd1\u00a8 is not equal to the subject length: \"\n        \"%ld != %ld\\n\", (unsigned long int)ovector\u00dd1\u00a8, (unsigned long int)ulen);\n\n    /* Process copy/get strings */\n\n    if (!copy_and_get(utf, 1)) return PR_ABEND;\n\n    /* \"allvector\" outputs the entire vector */\n\n    if ((dat_datctl.control2 & CTL2_ALLVECTOR) != 0)\n      show_ovector(ovector, oveccount);\n\n    break;  /* Out of the /g loop */\n    }       /* End of handling partial match */\n\n  /* Failed to match. If this is a /g or /G loop, we might previously have\n  set g_notempty (to PCRE2_NOTEMPTY_ATSTART|PCRE2_ANCHORED) after a null match.\n  If that is the case, this is not necessarily the end. We want to advance the\n  start offset, and continue. We won't be at the end of the string - that was\n  checked before setting g_notempty. We achieve the effect by pretending that a\n  single character was matched.\n\n  Complication arises in the case when the newline convention is \"any\", \"crlf\",\n  or \"anycrlf\". If the previous match was at the end of a line terminated by\n  CRLF, an advance of one character just passes the CR, whereas we should\n  prefer the longer newline sequence, as does the code in pcre2_match().\n\n  Otherwise, in the case of UTF-8 or UTF-16 matching, the advance must be one\n  character, not one byte. */\n\n  else if (g_notempty != 0)   /* There was a previous null match */\n    {\n    uint16_t nl = FLD(compiled_code, newline_convention);\n    PCRE2_SIZE start_offset = dat_datctl.offset;    /* Where the match was */\n    PCRE2_SIZE end_offset = start_offset + 1;\n\n    if ((nl == PCRE2_NEWLINE_CRLF || nl == PCRE2_NEWLINE_ANY ||\n         nl == PCRE2_NEWLINE_ANYCRLF) &&\n        start_offset < ulen - 1 &&\n        CODE_UNIT(pp, start_offset) == '\\r' &&\n        CODE_UNIT(pp, end_offset) == '\\n')\n      end_offset++;\n\n    else if (utf && test_mode != PCRE32_MODE)\n      {\n      if (test_mode == PCRE8_MODE)\n        {\n        for (; end_offset < ulen; end_offset++)\n          if ((((PCRE2_SPTR8)pp)\u00ddend_offset\u00a8 & 0xc0) != 0x80) break;\n        }\n      else  /* 16-bit mode */\n        {\n        for (; end_offset < ulen; end_offset++)\n          if ((((PCRE2_SPTR16)pp)\u00ddend_offset\u00a8 & 0xfc00) != 0xdc00) break;\n        }\n      }\n\n    SETFLDVEC(match_data, ovector, 0, start_offset);\n    SETFLDVEC(match_data, ovector, 1, end_offset);\n    }  /* End of handling null match in a global loop */\n\n  /* A \"normal\" match failure. There will be a negative error number in\n  capcount. */\n\n  else\n    {\n    switch(capcount)\n      {\n      case PCRE2_ERROR_NOMATCH:\n      if (gmatched == 0)\n        {\n        fprintf(outfile, \"No match\");\n        if ((dat_datctl.control & CTL_MARK) != 0 &&\n             TESTFLD(match_data, mark, !=, NULL))\n          {\n          fprintf(outfile, \", mark = \");\n          PCHARSV(CASTFLD(void *, match_data, mark), -1, -1, utf, outfile);\n          }\n        if ((pat_patctl.control & CTL_JITVERIFY) != 0 && jit_was_used)\n          fprintf(outfile, \" (JIT)\");\n        fprintf(outfile, \"\\n\");\n\n        /* \"allvector\" outputs the entire vector */\n\n        if ((dat_datctl.control2 & CTL2_ALLVECTOR) != 0)\n          show_ovector(ovector, oveccount);\n        }\n      break;\n\n      case PCRE2_ERROR_BADUTFOFFSET:\n      fprintf(outfile, \"Error %d (bad UTF-%d offset)\\n\", capcount, test_mode);\n      break;\n\n      default:\n      fprintf(outfile, \"Failed: error %d: \", capcount);\n      if (!print_error_message(capcount, \"\", \"\")) return PR_ABEND;\n      if (capcount <= PCRE2_ERROR_UTF8_ERR1 &&\n          capcount >= PCRE2_ERROR_UTF32_ERR2)\n        {\n        PCRE2_SIZE startchar;\n        PCRE2_GET_STARTCHAR(startchar, match_data);\n        fprintf(outfile, \" at offset %\" SIZ_FORM, SIZ_CAST startchar);\n        }\n      fprintf(outfile, \"\\n\");\n      break;\n      }\n\n    break;  /* Out of the /g loop */\n    }       /* End of failed match handling */\n\n  /* Control reaches here in two circumstances: (a) after a match, and (b)\n  after a non-match that immediately followed a match on an empty string when\n  doing a global search. Such a match is done with PCRE2_NOTEMPTY_ATSTART and\n  PCRE2_ANCHORED set in g_notempty. The code above turns it into a fake match\n  of one character. So effectively we get here only after a match. If we\n  are not doing a global search, we are done. */\n\n  if ((dat_datctl.control & CTL_ANYGLOB) == 0) break; else\n    {\n    PCRE2_SIZE match_offset = FLD(match_data, ovector)\u00dd0\u00a8;\n    PCRE2_SIZE end_offset = FLD(match_data, ovector)\u00dd1\u00a8;\n\n    /* We must now set up for the next iteration of a global search. If we have\n    matched an empty string, first check to see if we are at the end of the\n    subject. If so, the loop is over. Otherwise, mimic what Perl's /g option\n    does. Set PCRE2_NOTEMPTY_ATSTART and PCRE2_ANCHORED and try the match again\n    at the same point. If this fails it will be picked up above, where a fake\n    match is set up so that at this point we advance to the next character.\n\n    However, in order to cope with patterns that never match at their starting\n    offset (e.g. /(?<=\\G.)/) we don't do this when the match offset is greater\n    than the starting offset. This means there will be a retry with the\n    starting offset at the match offset. If this returns the same match again,\n    it is picked up above and ignored, and the special action is then taken. */\n\n    if (match_offset == end_offset)\n      {\n      if (end_offset == ulen) break;           /* End of subject */\n      if (match_offset <= dat_datctl.offset)\n        g_notempty = PCRE2_NOTEMPTY_ATSTART | PCRE2_ANCHORED;\n      }\n\n    /* However, even after matching a non-empty string, there is still one\n    tricky case. If a pattern contains \\K within a lookbehind assertion at the\n    start, the end of the matched string can be at the offset where the match\n    started. In the case of a normal /g iteration without special action, this\n    leads to a loop that keeps on returning the same substring. The loop would\n    be caught above, but we really want to move on to the next match. */\n\n    else\n      {\n      g_notempty = 0;   /* Set for a \"normal\" repeat */\n      if ((dat_datctl.control & CTL_GLOBAL) != 0)\n        {\n        PCRE2_SIZE startchar;\n        PCRE2_GET_STARTCHAR(startchar, match_data);\n        if (end_offset <= startchar)\n          {\n          if (startchar >= ulen) break;       /* End of subject */\n          end_offset = startchar + 1;\n          if (utf && test_mode != PCRE32_MODE)\n            {\n            if (test_mode == PCRE8_MODE)\n              {\n              for (; end_offset < ulen; end_offset++)\n                if ((((PCRE2_SPTR8)pp)\u00ddend_offset\u00a8 & 0xc0) != 0x80) break;\n              }\n            else  /* 16-bit mode */\n              {\n              for (; end_offset < ulen; end_offset++)\n                if ((((PCRE2_SPTR16)pp)\u00ddend_offset\u00a8 & 0xfc00) != 0xdc00) break;\n              }\n            }\n          }\n        }\n      }\n\n    /* For a normal global (/g) iteration, save the current ovector\u00dd0,1\u00a8 and\n    the starting offset so that we can check that they do change each time.\n    Otherwise a matching bug that returns the same string causes an infinite\n    loop. It has happened! Then update the start offset, leaving other\n    parameters alone. */\n\n    if ((dat_datctl.control & CTL_GLOBAL) != 0)\n      {\n      ovecsave\u00dd0\u00a8 = ovector\u00dd0\u00a8;\n      ovecsave\u00dd1\u00a8 = ovector\u00dd1\u00a8;\n      ovecsave\u00dd2\u00a8 = dat_datctl.offset;\n      dat_datctl.offset = end_offset;\n      }\n\n    /* For altglobal, just update the pointer and length. */\n\n    else\n      {\n      pp += end_offset * code_unit_size;\n      len -= end_offset * code_unit_size;\n      ulen -= end_offset;\n      if (arg_ulen != PCRE2_ZERO_TERMINATED) arg_ulen -= end_offset;\n      }\n    }\n  }  /* End of global loop */\n\nshow_memory = FALSE;\nreturn PR_OK;\n}\n\n\n\n\n/*************************************************\n*               Print PCRE2 version              *\n*************************************************/\n\nstatic void\nprint_version(FILE *f)\n{\nVERSION_TYPE *vp;\nfprintf(f, \"PCRE2 version \");\nfor (vp = version; *vp != 0; vp++) fprintf(f, \"%c\", *vp);\nfprintf(f, \"\\n\");\n}\n\n\n\n/*************************************************\n*               Print Unicode version            *\n*************************************************/\n\nstatic void\nprint_unicode_version(FILE *f)\n{\nVERSION_TYPE *vp;\nfprintf(f, \"Unicode version \");\nfor (vp = uversion; *vp != 0; vp++) fprintf(f, \"%c\", *vp);\n}\n\n\n\n/*************************************************\n*               Print JIT target                 *\n*************************************************/\n\nstatic void\nprint_jit_target(FILE *f)\n{\nVERSION_TYPE *vp;\nfor (vp = jittarget; *vp != 0; vp++) fprintf(f, \"%c\", *vp);\n}\n\n\n\n/*************************************************\n*       Print newline configuration              *\n*************************************************/\n\n/* Output is always to stdout.\n\nArguments:\n  rc         the return code from PCRE2_CONFIG_NEWLINE\n  isc        TRUE if called from \"-C newline\"\nReturns:     nothing\n*/\n\nstatic void\nprint_newline_config(uint32_t optval, BOOL isc)\n{\nif (!isc) printf(\"  Default newline sequence is \");\nif (optval < sizeof(newlines)/sizeof(char *))\n  printf(\"%s\\n\", newlines\u00ddoptval\u00a8);\nelse\n  printf(\"a non-standard value: %d\\n\", optval);\n}\n\n\n\n/*************************************************\n*             Usage function                     *\n*************************************************/\n\nstatic void\nusage(void)\n{\nprintf(\"Usage:     pcre2test \u00ddoptions\u00a8 \u00dd<input file> \u00dd<output file>\u00a8\u00a8\\n\\n\");\nprintf(\"Input and output default to stdin and stdout.\\n\");\n#if defined(SUPPORT_LIBREADLINE) || defined(SUPPORT_LIBEDIT)\nprintf(\"If input is a terminal, readline() is used to read from it.\\n\");\n#else\nprintf(\"This version of pcre2test is not linked with readline().\\n\");\n#endif\nprintf(\"\\nOptions:\\n\");\n#ifdef SUPPORT_PCRE2_8\nprintf(\"  -8            use the 8-bit library\\n\");\n#endif\n#ifdef SUPPORT_PCRE2_16\nprintf(\"  -16           use the 16-bit library\\n\");\n#endif\n#ifdef SUPPORT_PCRE2_32\nprintf(\"  -32           use the 32-bit library\\n\");\n#endif\nprintf(\"  -ac           set default pattern modifier PCRE2_AUTO_CALLOUT\\n\");\nprintf(\"  -AC           as -ac, but also set subject 'callout_extra' modifier\\n\");\nprintf(\"  -b            set default pattern modifier 'fullbincode'\\n\");\nprintf(\"  -C            show PCRE2 compile-time options and exit\\n\");\nprintf(\"  -C arg        show a specific compile-time option and exit with its\\n\");\nprintf(\"                  value if numeric (else 0). The arg can be:\\n\");\nprintf(\"     backslash-C    use of \\\\C is enabled \u00dd0, 1\u00a8\\n\");\nprintf(\"     bsr            \\\\R type \u00ddANYCRLF, ANY\u00a8\\n\");\nprintf(\"     ebcdic         compiled for EBCDIC character code \u00dd0,1\u00a8\\n\");\nprintf(\"     ebcdic-nl      NL code if compiled for EBCDIC\\n\");\nprintf(\"     jit            just-in-time compiler supported \u00dd0, 1\u00a8\\n\");\nprintf(\"     linksize       internal link size \u00dd2, 3, 4\u00a8\\n\");\nprintf(\"     newline        newline type \u00ddCR, LF, CRLF, ANYCRLF, ANY, NUL\u00a8\\n\");\nprintf(\"     pcre2-8        8 bit library support enabled \u00dd0, 1\u00a8\\n\");\nprintf(\"     pcre2-16       16 bit library support enabled \u00dd0, 1\u00a8\\n\");\nprintf(\"     pcre2-32       32 bit library support enabled \u00dd0, 1\u00a8\\n\");\nprintf(\"     unicode        Unicode and UTF support enabled \u00dd0, 1\u00a8\\n\");\nprintf(\"  -d            set default pattern modifier 'debug'\\n\");\nprintf(\"  -dfa          set default subject modifier 'dfa'\\n\");\nprintf(\"  -error <n,m,..>  show messages for error numbers, then exit\\n\");\nprintf(\"  -help         show usage information\\n\");\nprintf(\"  -i            set default pattern modifier 'info'\\n\");\nprintf(\"  -jit          set default pattern modifier 'jit'\\n\");\nprintf(\"  -jitfast      set default pattern modifier 'jitfast'\\n\");\nprintf(\"  -jitverify    set default pattern modifier 'jitverify'\\n\");\nprintf(\"  -LM           list pattern and subject modifiers, then exit\\n\");\nprintf(\"  -q            quiet: do not output PCRE2 version number at start\\n\");\nprintf(\"  -pattern <s>  set default pattern modifier fields\\n\");\nprintf(\"  -subject <s>  set default subject modifier fields\\n\");\nprintf(\"  -S <n>        set stack size to <n> mebibytes\\n\");\nprintf(\"  -t \u00dd<n>\u00a8      time compilation and execution, repeating <n> times\\n\");\nprintf(\"  -tm \u00dd<n>\u00a8     time execution (matching) only, repeating <n> times\\n\");\nprintf(\"  -T            same as -t, but show total times at the end\\n\");\nprintf(\"  -TM           same as -tm, but show total time at the end\\n\");\nprintf(\"  -version      show PCRE2 version and exit\\n\");\n}\n\n\n\n/*************************************************\n*             Handle -C option                   *\n*************************************************/\n\n/* This option outputs configuration options and sets an appropriate return\ncode when asked for a single option. The code is abstracted into a separate\nfunction because of its size. Use whichever pcre2_config() function is\navailable.\n\nArgument:   an option name or NULL\nReturns:    the return code\n*/\n\nstatic int\nc_option(const char *arg)\n{\nuint32_t optval;\nunsigned int i = COPTLISTCOUNT;\nint yield = 0;\n\nif (arg != NULL && arg\u00dd0\u00a8 != CHAR_MINUS)\n  {\n  for (i = 0; i < COPTLISTCOUNT; i++)\n    if (strcmp(arg, coptlist\u00ddi\u00a8.name) == 0) break;\n\n  if (i >= COPTLISTCOUNT)\n    {\n    fprintf(stderr, \"** Unknown -C option '%s'\\n\", arg);\n    return 0;\n    }\n\n  switch (coptlist\u00ddi\u00a8.type)\n    {\n    case CONF_BSR:\n    (void)PCRE2_CONFIG(coptlist\u00ddi\u00a8.value, &optval);\n    printf(\"%s\\n\", (optval == PCRE2_BSR_ANYCRLF)? \"ANYCRLF\" : \"ANY\");\n    break;\n\n    case CONF_FIX:\n    yield = coptlist\u00ddi\u00a8.value;\n    printf(\"%d\\n\", yield);\n    break;\n\n    case CONF_FIZ:\n    optval = coptlist\u00ddi\u00a8.value;\n    printf(\"%d\\n\", optval);\n    break;\n\n    case CONF_INT:\n    (void)PCRE2_CONFIG(coptlist\u00ddi\u00a8.value, &yield);\n    printf(\"%d\\n\", yield);\n    break;\n\n    case CONF_NL:\n    (void)PCRE2_CONFIG(coptlist\u00ddi\u00a8.value, &optval);\n    print_newline_config(optval, TRUE);\n    break;\n    }\n\n/* For VMS, return the value by setting a symbol, for certain values only. This\nis contributed code which the PCRE2 developers have no means of testing. */\n\n#ifdef __VMS\n\n/* This is the original code provided by the first VMS contributor. */\n#ifdef NEVER\n  if (copytlist\u00ddi\u00a8.type == CONF_FIX || coptlist\u00ddi\u00a8.type == CONF_INT)\n    {\n    char ucname\u00dd16\u00a8;\n    strcpy(ucname, coptlist\u00ddi\u00a8.name);\n    for (i = 0; ucname\u00ddi\u00a8 != 0; i++) ucname\u00ddi\u00a8 = toupper\u00dducname\u00ddi\u00a8\u00a8;\n    vms_setsymbol(ucname, 0, optval);\n    }\n#endif\n\n/* This is the new code, provided by a second VMS contributor. */\n\n  if (coptlist\u00ddi\u00a8.type == CONF_FIX || coptlist\u00ddi\u00a8.type == CONF_INT)\n    {\n    char nam_buf\u00dd22\u00a8, val_buf\u00dd4\u00a8;\n    $DESCRIPTOR(nam, nam_buf);\n    $DESCRIPTOR(val, val_buf);\n\n    strcpy(nam_buf, coptlist\u00ddi\u00a8.name);\n    nam.dsc$w_length = strlen(nam_buf);\n    sprintf(val_buf, \"%d\", yield);\n    val.dsc$w_length = strlen(val_buf);\n    lib$set_symbol(&nam, &val);\n    }\n#endif  /* __VMS */\n\n  return yield;\n  }\n\n/* No argument for -C: output all configuration information. */\n\nprint_version(stdout);\nprintf(\"Compiled with\\n\");\n\n#ifdef EBCDIC\nprintf(\"  EBCDIC code support: LF is 0x%02x\\n\", CHAR_LF);\n#if defined NATIVE_ZOS\nprintf(\"  EBCDIC code page %s or similar\\n\", pcrz_cpversion());\n#endif\n#endif\n\n(void)PCRE2_CONFIG(PCRE2_CONFIG_COMPILED_WIDTHS, &optval);\nif (optval & 1) printf(\"  8-bit support\\n\");\nif (optval & 2) printf(\"  16-bit support\\n\");\nif (optval & 4) printf(\"  32-bit support\\n\");\n\n#ifdef SUPPORT_VALGRIND\nprintf(\"  Valgrind support\\n\");\n#endif\n\n(void)PCRE2_CONFIG(PCRE2_CONFIG_UNICODE, &optval);\nif (optval != 0)\n  {\n  printf(\"  UTF and UCP support (\");\n  print_unicode_version(stdout);\n  printf(\")\\n\");\n  }\nelse printf(\"  No Unicode support\\n\");\n\n(void)PCRE2_CONFIG(PCRE2_CONFIG_JIT, &optval);\nif (optval != 0)\n  {\n  printf(\"  Just-in-time compiler support: \");\n  print_jit_target(stdout);\n  printf(\"\\n\");\n  }\nelse\n  {\n  printf(\"  No just-in-time compiler support\\n\");\n  }\n\n(void)PCRE2_CONFIG(PCRE2_CONFIG_NEWLINE, &optval);\nprint_newline_config(optval, FALSE);\n(void)PCRE2_CONFIG(PCRE2_CONFIG_BSR, &optval);\nprintf(\"  \\\\R matches %s\\n\",\n  (optval == PCRE2_BSR_ANYCRLF)? \"CR, LF, or CRLF only\" :\n                                 \"all Unicode newlines\");\n(void)PCRE2_CONFIG(PCRE2_CONFIG_NEVER_BACKSLASH_C, &optval);\nprintf(\"  \\\\C is %ssupported\\n\", optval? \"not \":\"\");\n(void)PCRE2_CONFIG(PCRE2_CONFIG_LINKSIZE, &optval);\nprintf(\"  Internal link size = %d\\n\", optval);\n(void)PCRE2_CONFIG(PCRE2_CONFIG_PARENSLIMIT, &optval);\nprintf(\"  Parentheses nest limit = %d\\n\", optval);\n(void)PCRE2_CONFIG(PCRE2_CONFIG_HEAPLIMIT, &optval);\nprintf(\"  Default heap limit = %d kibibytes\\n\", optval);\n(void)PCRE2_CONFIG(PCRE2_CONFIG_MATCHLIMIT, &optval);\nprintf(\"  Default match limit = %d\\n\", optval);\n(void)PCRE2_CONFIG(PCRE2_CONFIG_DEPTHLIMIT, &optval);\nprintf(\"  Default depth limit = %d\\n\", optval);\n\n#if defined SUPPORT_LIBREADLINE\nprintf(\"  pcre2test has libreadline support\\n\");\n#elif defined SUPPORT_LIBEDIT\nprintf(\"  pcre2test has libedit support\\n\");\n#else\nprintf(\"  pcre2test has neither libreadline nor libedit support\\n\");\n#endif\n\nreturn 0;\n}\n\n\n\n/*************************************************\n*              Display one modifier              *\n*************************************************/\n\nstatic void\ndisplay_one_modifier(modstruct *m, BOOL for_pattern)\n{\nuint32_t c = (!for_pattern && (m->which == MOD_PND || m->which == MOD_PNDP))?\n  '*' : ' ';\nprintf(\"%c%s\", c, m->name);\n}\n\n\n\n/*************************************************\n*       Display pattern or subject modifiers     *\n*************************************************/\n\n/* In order to print in two columns, first scan without printing to get a list\nof the modifiers that are required.\n\nArguments:\n  for_pattern   TRUE for pattern modifiers, FALSE for subject modifiers\n  title         string to be used in title\n\nReturns:        nothing\n*/\n\nstatic void\ndisplay_selected_modifiers(BOOL for_pattern, const char *title)\n{\nuint32_t i, j;\nuint32_t n = 0;\nuint32_t list\u00ddMODLISTCOUNT\u00a8;\n\nfor (i = 0; i < MODLISTCOUNT; i++)\n  {\n  BOOL is_pattern = TRUE;\n  modstruct *m = modlist + i;\n\n  switch (m->which)\n    {\n    case MOD_CTC:       /* Compile context */\n    case MOD_PAT:       /* Pattern */\n    case MOD_PATP:      /* Pattern, OK for Perl-compatible test */\n    break;\n\n    /* The MOD_PND and MOD_PNDP modifiers are precisely those that affect\n    subjects, but can be given with a pattern. We list them as subject\n    modifiers, but marked with an asterisk.*/\n\n    case MOD_CTM:       /* Match context */\n    case MOD_DAT:       /* Subject line */\n    case MOD_PND:       /* As PD, but not default pattern */\n    case MOD_PNDP:      /* As PND, OK for Perl-compatible test */\n    is_pattern = FALSE;\n    break;\n\n    default: printf(\"** Unknown type for modifier '%s'\\n\", m->name);\n    /* Fall through */\n    case MOD_PD:        /* Pattern or subject */\n    case MOD_PDP:       /* As PD, OK for Perl-compatible test */\n    is_pattern = for_pattern;\n    break;\n    }\n\n  if (for_pattern == is_pattern) list\u00ddn++\u00a8 = i;\n  }\n\n/* Now print from the list in two columns. */\n\nprintf(\"-------------- %s MODIFIERS --------------\\n\", title);\n\nfor (i = 0, j = (n+1)/2; i < (n+1)/2; i++, j++)\n  {\n  modstruct *m = modlist + list\u00ddi\u00a8;\n  display_one_modifier(m, for_pattern);\n  if (j < n)\n    {\n    uint32_t k = 27 - strlen(m->name);\n    while (k-- > 0) printf(\" \");\n    display_one_modifier(modlist + list\u00ddj\u00a8, for_pattern);\n    }\n  printf(\"\\n\");\n  }\n}\n\n\n\n/*************************************************\n*          Display the list of modifiers         *\n*************************************************/\n\nstatic void\ndisplay_modifiers(void)\n{\nprintf(\n  \"An asterisk on a subject modifier means that it may be given on a pattern\\n\"\n  \"line, in order to apply to all subjects matched by that pattern. Modifiers\\n\"\n  \"that are listed for both patterns and subjects have different effects in\\n\"\n  \"each case.\\n\\n\");\ndisplay_selected_modifiers(TRUE, \"PATTERN\");\nprintf(\"\\n\");\ndisplay_selected_modifiers(FALSE, \"SUBJECT\");\n}\n\n\n\n/*************************************************\n*                Main Program                    *\n*************************************************/\n\nint\nmain(int argc, char **argv)\n{\nuint32_t temp;\nuint32_t yield = 0;\nuint32_t op = 1;\nBOOL notdone = TRUE;\nBOOL quiet = FALSE;\nBOOL showtotaltimes = FALSE;\nBOOL skipping = FALSE;\nchar *arg_subject = NULL;\nchar *arg_pattern = NULL;\nchar *arg_error = NULL;\n\n/* The offsets to the options and control bits fields of the pattern and data\ncontrol blocks must be the same so that common options and controls such as\n\"anchored\" or \"memory\" can work for either of them from a single table entry.\nWe cannot test this till runtime because \"offsetof\" does not work in the\npreprocessor. */\n\nif (PO(options) != DO(options) || PO(control) != DO(control) ||\n    PO(control2) != DO(control2))\n  {\n  fprintf(stderr, \"** Coding error: \"\n    \"options and control offsets for pattern and data must be the same.\\n\");\n  return 1;\n  }\n\n/* Get the PCRE2 and Unicode version number and JIT target information, at the\nsame time checking that a request for the length gives the same answer. Also\ncheck lengths for non-string items. */\n\nif (PCRE2_CONFIG(PCRE2_CONFIG_VERSION, NULL) !=\n    PCRE2_CONFIG(PCRE2_CONFIG_VERSION, version) ||\n\n    PCRE2_CONFIG(PCRE2_CONFIG_UNICODE_VERSION, NULL) !=\n    PCRE2_CONFIG(PCRE2_CONFIG_UNICODE_VERSION, uversion) ||\n\n    PCRE2_CONFIG(PCRE2_CONFIG_JITTARGET, NULL) !=\n    PCRE2_CONFIG(PCRE2_CONFIG_JITTARGET, jittarget) ||\n\n    PCRE2_CONFIG(PCRE2_CONFIG_UNICODE, NULL) != sizeof(uint32_t) ||\n    PCRE2_CONFIG(PCRE2_CONFIG_MATCHLIMIT, NULL) != sizeof(uint32_t))\n  {\n  fprintf(stderr, \"** Error in pcre2_config(): bad length\\n\");\n  return 1;\n  }\n\n/* Check that bad options are diagnosed. */\n\nif (PCRE2_CONFIG(999, NULL) != PCRE2_ERROR_BADOPTION ||\n    PCRE2_CONFIG(999, &temp) != PCRE2_ERROR_BADOPTION)\n  {\n  fprintf(stderr, \"** Error in pcre2_config(): bad option not diagnosed\\n\");\n  return 1;\n  }\n\n/* This configuration option is now obsolete, but running a quick check ensures\nthat its code is covered. */\n\n(void)PCRE2_CONFIG(PCRE2_CONFIG_STACKRECURSE, &temp);\n\n/* Get buffers from malloc() so that valgrind will check their misuse when\ndebugging. They grow automatically when very long lines are read. The 16-\nand 32-bit buffers (pbuffer16, pbuffer32) are obtained only if needed. */\n\nbuffer = (uint8_t *)malloc(pbuffer8_size);\npbuffer8 = (uint8_t *)malloc(pbuffer8_size);\n\n/* The following  _setmode() stuff is some Windows magic that tells its runtime\nlibrary to translate CRLF into a single LF character. At least, that's what\nI've been told: never having used Windows I take this all on trust. Originally\nit set 0x8000, but then I was advised that _O_BINARY was better. */\n\n#if defined(_WIN32) || defined(WIN32)\n_setmode( _fileno( stdout ), _O_BINARY );\n#endif\n\n/* Initialization that does not depend on the running mode. */\n\nlocale_name\u00dd0\u00a8 = 0;\n\nmemset(&def_patctl, 0, sizeof(patctl));\ndef_patctl.convert_type = CONVERT_UNSET;\n\nmemset(&def_datctl, 0, sizeof(datctl));\ndef_datctl.oveccount = DEFAULT_OVECCOUNT;\ndef_datctl.copy_numbers\u00dd0\u00a8 = -1;\ndef_datctl.get_numbers\u00dd0\u00a8 = -1;\ndef_datctl.startend\u00dd0\u00a8 = def_datctl.startend\u00dd1\u00a8 = CFORE_UNSET;\ndef_datctl.cerror\u00dd0\u00a8 = def_datctl.cerror\u00dd1\u00a8 = CFORE_UNSET;\ndef_datctl.cfail\u00dd0\u00a8 = def_datctl.cfail\u00dd1\u00a8 = CFORE_UNSET;\n\n/* Scan command line options. */\n\nwhile (argc > 1 && argv\u00ddop\u00a8\u00dd0\u00a8 == '-' && argv\u00ddop\u00a8\u00dd1\u00a8 != 0)\n  {\n  char *endptr;\n  char *arg = argv\u00ddop\u00a8;\n  unsigned long uli;\n\n  /* List modifiers and exit. */\n\n  if (strcmp(arg, \"-LM\") == 0)\n    {\n    display_modifiers();\n    goto EXIT;\n    }\n\n  /* Display and/or set return code for configuration options. */\n\n  if (strcmp(arg, \"-C\") == 0)\n    {\n    yield = c_option(argv\u00ddop + 1\u00a8);\n    goto EXIT;\n    }\n\n  /* Select operating mode. Ensure that pcre2_config() is called in 16-bit\n  and 32-bit modes because that won't happen naturally when 8-bit is also\n  configured. Also call some other functions that are not otherwise used. This\n  means that a coverage report won't claim there are uncalled functions. */\n\n  if (strcmp(arg, \"-8\") == 0)\n    {\n#ifdef SUPPORT_PCRE2_8\n    test_mode = PCRE8_MODE;\n    (void)pcre2_set_bsr_8(pat_context8, 999);\n    (void)pcre2_set_newline_8(pat_context8, 999);\n#else\n    fprintf(stderr,\n      \"** This version of PCRE2 was built without 8-bit support\\n\");\n    exit(1);\n#endif\n    }\n\n  else if (strcmp(arg, \"-16\") == 0)\n    {\n#ifdef SUPPORT_PCRE2_16\n    test_mode = PCRE16_MODE;\n    (void)pcre2_config_16(PCRE2_CONFIG_VERSION, NULL);\n    (void)pcre2_set_bsr_16(pat_context16, 999);\n    (void)pcre2_set_newline_16(pat_context16, 999);\n#else\n    fprintf(stderr,\n      \"** This version of PCRE2 was built without 16-bit support\\n\");\n    exit(1);\n#endif\n    }\n\n  else if (strcmp(arg, \"-32\") == 0)\n    {\n#ifdef SUPPORT_PCRE2_32\n    test_mode = PCRE32_MODE;\n    (void)pcre2_config_32(PCRE2_CONFIG_VERSION, NULL);\n    (void)pcre2_set_bsr_32(pat_context32, 999);\n    (void)pcre2_set_newline_32(pat_context32, 999);\n#else\n    fprintf(stderr,\n      \"** This version of PCRE2 was built without 32-bit support\\n\");\n    exit(1);\n#endif\n    }\n\n  /* Set quiet (no version verification) */\n\n  else if (strcmp(arg, \"-q\") == 0) quiet = TRUE;\n\n  /* Set system stack size */\n\n  else if (strcmp(arg, \"-S\") == 0 && argc > 2 &&\n      ((uli = strtoul(argv\u00ddop+1\u00a8, &endptr, 10)), *endptr == 0))\n    {\n#if defined(_WIN32) || defined(WIN32) || defined(__minix) || defined(NATIVE_ZOS) || defined(__VMS)\n    fprintf(stderr, \"pcre2test: -S is not supported on this OS\\n\");\n    exit(1);\n#else\n    int rc;\n    uint32_t stack_size;\n    struct rlimit rlim;\n    if (U32OVERFLOW(uli))\n      {\n      fprintf(stderr, \"** Argument for -S is too big\\n\");\n      exit(1);\n      }\n    stack_size = (uint32_t)uli;\n    getrlimit(RLIMIT_STACK, &rlim);\n    rlim.rlim_cur = stack_size * 1024 * 1024;\n    if (rlim.rlim_cur > rlim.rlim_max)\n      {\n      fprintf(stderr,\n        \"pcre2test: requested stack size %luMiB is greater than hard limit \"\n          \"%luMiB\\n\", (unsigned long int)stack_size,\n          (unsigned long int)(rlim.rlim_max));\n      exit(1);\n      }\n    rc = setrlimit(RLIMIT_STACK, &rlim);\n    if (rc != 0)\n      {\n      fprintf(stderr, \"pcre2test: setting stack size %luMiB failed: %s\\n\",\n        (unsigned long int)stack_size, strerror(errno));\n      exit(1);\n      }\n    op++;\n    argc--;\n#endif\n    }\n\n  /* Set some common pattern and subject controls */\n\n  else if (strcmp(arg, \"-AC\") == 0)\n    {\n    def_patctl.options |= PCRE2_AUTO_CALLOUT;\n    def_datctl.control2 |= CTL2_CALLOUT_EXTRA;\n    }\n  else if (strcmp(arg, \"-ac\") == 0)  def_patctl.options |= PCRE2_AUTO_CALLOUT;\n  else if (strcmp(arg, \"-b\") == 0)   def_patctl.control |= CTL_FULLBINCODE;\n  else if (strcmp(arg, \"-d\") == 0)   def_patctl.control |= CTL_DEBUG;\n  else if (strcmp(arg, \"-dfa\") == 0) def_datctl.control |= CTL_DFA;\n  else if (strcmp(arg, \"-i\") == 0)   def_patctl.control |= CTL_INFO;\n  else if (strcmp(arg, \"-jit\") == 0 || strcmp(arg, \"-jitverify\") == 0 ||\n           strcmp(arg, \"-jitfast\") == 0)\n    {\n    if (arg\u00dd4\u00a8 == 'v') def_patctl.control |= CTL_JITVERIFY;\n      else if (arg\u00dd4\u00a8 == 'f') def_patctl.control |= CTL_JITFAST;\n    def_patctl.jit = JIT_DEFAULT;  /* full & partial */\n#ifndef SUPPORT_JIT\n    fprintf(stderr, \"** Warning: JIT support is not available: \"\n                    \"-jit\u00ddfast|verify\u00a8 calls functions that do nothing.\\n\");\n#endif\n    }\n\n  /* Set timing parameters */\n\n  else if (strcmp(arg, \"-t\") == 0 || strcmp(arg, \"-tm\") == 0 ||\n           strcmp(arg, \"-T\") == 0 || strcmp(arg, \"-TM\") == 0)\n    {\n    int both = arg\u00dd2\u00a8 == 0;\n    showtotaltimes = arg\u00dd1\u00a8 == 'T';\n    if (argc > 2 && (uli = strtoul(argv\u00ddop+1\u00a8, &endptr, 10), *endptr == 0))\n      {\n      if (uli == 0)\n        {\n        fprintf(stderr, \"** Argument for %s must not be zero\\n\", arg);\n        exit(1);\n        }\n      if (U32OVERFLOW(uli))\n        {\n        fprintf(stderr, \"** Argument for %s is too big\\n\", arg);\n        exit(1);\n        }\n      timeitm = (int)uli;\n      op++;\n      argc--;\n      }\n    else timeitm = LOOPREPEAT;\n    if (both) timeit = timeitm;\n    }\n\n  /* Give help */\n\n  else if (strcmp(arg, \"-help\") == 0 ||\n           strcmp(arg, \"--help\") == 0)\n    {\n    usage();\n    goto EXIT;\n    }\n\n  /* Show version */\n\n  else if (strcmp(arg, \"-version\") == 0 ||\n           strcmp(arg, \"--version\") == 0)\n    {\n    print_version(stdout);\n    goto EXIT;\n    }\n\n  /* The following options save their data for processing once we know what\n  the running mode is. */\n\n  else if (strcmp(arg, \"-error\") == 0)\n    {\n    arg_error = argv\u00ddop+1\u00a8;\n    goto CHECK_VALUE_EXISTS;\n    }\n\n  else if (strcmp(arg, \"-subject\") == 0)\n    {\n    arg_subject = argv\u00ddop+1\u00a8;\n    goto CHECK_VALUE_EXISTS;\n    }\n\n  else if (strcmp(arg, \"-pattern\") == 0)\n    {\n    arg_pattern = argv\u00ddop+1\u00a8;\n    CHECK_VALUE_EXISTS:\n    if (argc <= 2)\n      {\n      fprintf(stderr, \"** Missing value for %s\\n\", arg);\n      yield = 1;\n      goto EXIT;\n      }\n    op++;\n    argc--;\n    }\n\n  /* Unrecognized option */\n\n  else\n    {\n    fprintf(stderr, \"** Unknown or malformed option '%s'\\n\", arg);\n    usage();\n    yield = 1;\n    goto EXIT;\n    }\n  op++;\n  argc--;\n  }\n\n/* If -error was present, get the error numbers, show the messages, and exit.\nWe wait to do this until we know which mode we are in. */\n\nif (arg_error != NULL)\n  {\n  int len;\n  int errcode;\n  char *endptr;\n\n/* Ensure the relevant non-8-bit buffer is available. Ensure that it is at\nleast 128 code units, because it is used for retrieving error messages. */\n\n#ifdef SUPPORT_PCRE2_16\n  if (test_mode == PCRE16_MODE)\n    {\n    pbuffer16_size = 256;\n    pbuffer16 = (uint16_t *)malloc(pbuffer16_size);\n    if (pbuffer16 == NULL)\n      {\n      fprintf(stderr, \"pcre2test: malloc(%\" SIZ_FORM \") failed for pbuffer16\\n\",\n        SIZ_CAST pbuffer16_size);\n      yield = 1;\n      goto EXIT;\n      }\n    }\n#endif\n\n#ifdef SUPPORT_PCRE2_32\n  if (test_mode == PCRE32_MODE)\n    {\n    pbuffer32_size = 512;\n    pbuffer32 = (uint32_t *)malloc(pbuffer32_size);\n    if (pbuffer32 == NULL)\n      {\n      fprintf(stderr, \"pcre2test: malloc(%\" SIZ_FORM \") failed for pbuffer32\\n\",\n        SIZ_CAST pbuffer32_size);\n      yield = 1;\n      goto EXIT;\n      }\n    }\n#endif\n\n  /* Loop along a list of error numbers. */\n\n  for (;;)\n    {\n    errcode = strtol(arg_error, &endptr, 10);\n    if (*endptr != 0 && *endptr != CHAR_COMMA)\n      {\n      fprintf(stderr, \"** '%s' is not a valid error number list\\n\", arg_error);\n      yield = 1;\n      goto EXIT;\n      }\n    printf(\"Error %d: \", errcode);\n    PCRE2_GET_ERROR_MESSAGE(len, errcode, pbuffer);\n    if (len < 0)\n      {\n      switch (len)\n        {\n        case PCRE2_ERROR_BADDATA:\n        printf(\"PCRE2_ERROR_BADDATA (unknown error number)\");\n        break;\n\n        case PCRE2_ERROR_NOMEMORY:\n        printf(\"PCRE2_ERROR_NOMEMORY (buffer too small)\");\n        break;\n\n        default:\n        printf(\"Unexpected return (%d) from pcre2_get_error_message()\", len);\n        break;\n        }\n      }\n    else\n      {\n      PCHARSV(CASTVAR(void *, pbuffer), 0, len, FALSE, stdout);\n      }\n    printf(\"\\n\");\n    if (*endptr == 0) goto EXIT;\n    arg_error = endptr + 1;\n    }\n  /* Control never reaches here */\n  }  /* End of -error handling */\n\n/* Initialize things that cannot be done until we know which test mode we are\nrunning in. Exercise the general context copying and match data size functions,\nwhich are not otherwise used. */\n\ncode_unit_size = test_mode/8;\nmax_oveccount = DEFAULT_OVECCOUNT;\n\n/* Use macros to save a lot of duplication. */\n\n#define CREATECONTEXTS \\\n  G(general_context,BITS) = G(pcre2_general_context_create_,BITS)(&my_malloc, &my_free, NULL); \\\n  G(general_context_copy,BITS) = G(pcre2_general_context_copy_,BITS)(G(general_context,BITS)); \\\n  G(default_pat_context,BITS) = G(pcre2_compile_context_create_,BITS)(G(general_context,BITS)); \\\n  G(pat_context,BITS) = G(pcre2_compile_context_copy_,BITS)(G(default_pat_context,BITS)); \\\n  G(default_dat_context,BITS) = G(pcre2_match_context_create_,BITS)(G(general_context,BITS)); \\\n  G(dat_context,BITS) = G(pcre2_match_context_copy_,BITS)(G(default_dat_context,BITS)); \\\n  G(default_con_context,BITS) = G(pcre2_convert_context_create_,BITS)(G(general_context,BITS)); \\\n  G(con_context,BITS) = G(pcre2_convert_context_copy_,BITS)(G(default_con_context,BITS)); \\\n  G(match_data,BITS) = G(pcre2_match_data_create_,BITS)(max_oveccount, G(general_context,BITS))\n\n#define CONTEXTTESTS \\\n  (void)G(pcre2_set_compile_extra_options_,BITS)(G(pat_context,BITS), 0); \\\n  (void)G(pcre2_set_max_pattern_length_,BITS)(G(pat_context,BITS), 0); \\\n  (void)G(pcre2_set_offset_limit_,BITS)(G(dat_context,BITS), 0); \\\n  (void)G(pcre2_set_recursion_memory_management_,BITS)(G(dat_context,BITS), my_malloc, my_free, NULL); \\\n  (void)G(pcre2_get_match_data_size_,BITS)(G(match_data,BITS))\n\n\n/* Call the appropriate functions for the current mode, and exercise some\nfunctions that are not otherwise called. */\n\n#ifdef SUPPORT_PCRE2_8\n#undef BITS\n#define BITS 8\nif (test_mode == PCRE8_MODE)\n  {\n  CREATECONTEXTS;\n  CONTEXTTESTS;\n  }\n#endif\n\n#ifdef SUPPORT_PCRE2_16\n#undef BITS\n#define BITS 16\nif (test_mode == PCRE16_MODE)\n  {\n  CREATECONTEXTS;\n  CONTEXTTESTS;\n  }\n#endif\n\n#ifdef SUPPORT_PCRE2_32\n#undef BITS\n#define BITS 32\nif (test_mode == PCRE32_MODE)\n  {\n  CREATECONTEXTS;\n  CONTEXTTESTS;\n  }\n#endif\n\n/* Set a default parentheses nest limit that is large enough to run the\nstandard tests (this also exercises the function). */\n\nPCRE2_SET_PARENS_NEST_LIMIT(default_pat_context, PARENS_NEST_DEFAULT);\n\n/* Handle command line modifier settings, sending any error messages to\nstderr. We need to know the mode before modifying the context, and it is tidier\nto do them all in the same way. */\n\noutfile = stderr;\nif ((arg_pattern != NULL &&\n    !decode_modifiers((uint8_t *)arg_pattern, CTX_DEFPAT, &def_patctl, NULL)) ||\n    (arg_subject != NULL &&\n    !decode_modifiers((uint8_t *)arg_subject, CTX_DEFDAT, NULL, &def_datctl)))\n  {\n  yield = 1;\n  goto EXIT;\n  }\n\n/* Sort out the input and output files, defaulting to stdin/stdout. */\n\ninfile = stdin;\noutfile = stdout;\n\nif (argc > 1 && strcmp(argv\u00ddop\u00a8, \"-\") != 0)\n  {\n  infile = fopen(argv\u00ddop\u00a8, INPUT_MODE);\n  if (infile == NULL)\n    {\n    printf(\"** Failed to open '%s': %s\\n\", argv\u00ddop\u00a8, strerror(errno));\n    yield = 1;\n    goto EXIT;\n    }\n  }\n\n#if defined(SUPPORT_LIBREADLINE) || defined(SUPPORT_LIBEDIT)\nif (INTERACTIVE(infile)) using_history();\n#endif\n\nif (argc > 2)\n  {\n  outfile = fopen(argv\u00ddop+1\u00a8, OUTPUT_MODE);\n  if (outfile == NULL)\n    {\n    printf(\"** Failed to open '%s': %s\\n\", argv\u00ddop+1\u00a8, strerror(errno));\n    yield = 1;\n    goto EXIT;\n    }\n  }\n\n/* Output a heading line unless quiet, then process input lines. */\n\nif (!quiet) print_version(outfile);\n\nSET(compiled_code, NULL);\n\n#ifdef SUPPORT_PCRE2_8\npreg.re_pcre2_code = NULL;\npreg.re_match_data = NULL;\n#endif\n\nwhile (notdone)\n  {\n  uint8_t *p;\n  int rc = PR_OK;\n  BOOL expectdata = TEST(compiled_code, !=, NULL);\n#ifdef SUPPORT_PCRE2_8\n  expectdata |= preg.re_pcre2_code != NULL;\n#endif\n\n  if (extend_inputline(infile, buffer, expectdata? \"data> \" : \"  re> \") == NULL)\n    break;\n  if (!INTERACTIVE(infile)) fprintf(outfile, \"%s\", (char *)buffer);\n  fflush(outfile);\n  p = buffer;\n\n  /* If we have a pattern set up for testing, or we are skipping after a\n  compile failure, a blank line terminates this test. */\n\n  if (expectdata || skipping)\n    {\n    while (isspace(*p)) p++;\n    if (*p == 0)\n      {\n#ifdef SUPPORT_PCRE2_8\n      if (preg.re_pcre2_code != NULL)\n        {\n        regfree(&preg);\n        preg.re_pcre2_code = NULL;\n        preg.re_match_data = NULL;\n        }\n#endif  /* SUPPORT_PCRE2_8 */\n      if (TEST(compiled_code, !=, NULL))\n        {\n        SUB1(pcre2_code_free, compiled_code);\n        SET(compiled_code, NULL);\n        }\n      skipping = FALSE;\n      setlocale(LC_CTYPE, \"C\");\n      }\n\n    /* Otherwise, if we are not skipping, and the line is not a data comment\n    line starting with \"\\=\", process a data line. */\n\n    else if (!skipping && !(p\u00dd0\u00a8 == '\\\\' && p\u00dd1\u00a8 == '=' && isspace(p\u00dd2\u00a8)))\n      {\n      rc = process_data();\n      }\n    }\n\n  /* We do not have a pattern set up for testing. Lines starting with # are\n  either comments or special commands. Blank lines are ignored. Otherwise, the\n  line must start with a valid delimiter. It is then processed as a pattern\n  line. A copy of the pattern is left in pbuffer8 for use by callouts. Under\n  valgrind, make the unused part of the buffer undefined, to catch overruns. */\n\n  else if (*p == '#')\n    {\n    if (isspace(p\u00dd1\u00a8) || p\u00dd1\u00a8 == '!' || p\u00dd1\u00a8 == 0) continue;\n    rc = process_command();\n    }\n\n  else if (strchr(\"/!\\\"'`%&-=_:;,@~\", *p) != NULL)\n    {\n    rc = process_pattern();\n    dfa_matched = 0;\n    }\n\n  else\n    {\n    while (isspace(*p)) p++;\n    if (*p != 0)\n      {\n      fprintf(outfile, \"** Invalid pattern delimiter '%c' (x%x).\\n\", *buffer,\n        *buffer);\n      rc = PR_SKIP;\n      }\n    }\n\n  if (rc == PR_SKIP && !INTERACTIVE(infile)) skipping = TRUE;\n  else if (rc == PR_ABEND)\n    {\n    fprintf(outfile, \"** pcre2test run abandoned\\n\");\n    yield = 1;\n    goto EXIT;\n    }\n  }\n\n/* Finish off a normal run. */\n\nif (INTERACTIVE(infile)) fprintf(outfile, \"\\n\");\n\nif (showtotaltimes)\n  {\n  const char *pad = \"\";\n  fprintf(outfile, \"--------------------------------------\\n\");\n  if (timeit > 0)\n    {\n    fprintf(outfile, \"Total compile time %.4f milliseconds\\n\",\n      (((double)total_compile_time * 1000.0) / (double)timeit) /\n        (double)CLOCKS_PER_SEC);\n    if (total_jit_compile_time > 0)\n      fprintf(outfile, \"Total JIT compile  %.4f milliseconds\\n\",\n        (((double)total_jit_compile_time * 1000.0) / (double)timeit) /\n          (double)CLOCKS_PER_SEC);\n    pad = \"  \";\n    }\n  fprintf(outfile, \"Total match time %s%.4f milliseconds\\n\", pad,\n    (((double)total_match_time * 1000.0) / (double)timeitm) /\n      (double)CLOCKS_PER_SEC);\n  }\n\n\nEXIT:\n\n#if defined(SUPPORT_LIBREADLINE) || defined(SUPPORT_LIBEDIT)\nif (infile != NULL && INTERACTIVE(infile)) clear_history();\n#endif\n\nif (infile != NULL && infile != stdin) fclose(infile);\nif (outfile != NULL && outfile != stdout) fclose(outfile);\n\nfree(buffer);\nfree(dbuffer);\nfree(pbuffer8);\nfree(dfa_workspace);\nfree((void *)locale_tables);\nfree(tables3);\nPCRE2_MATCH_DATA_FREE(match_data);\nSUB1(pcre2_code_free, compiled_code);\n\nwhile(patstacknext-- > 0)\n  {\n  SET(compiled_code, patstack\u00ddpatstacknext\u00a8);\n  SUB1(pcre2_code_free, compiled_code);\n  }\n\nPCRE2_JIT_FREE_UNUSED_MEMORY(general_context);\nif (jit_stack != NULL)\n  {\n  PCRE2_JIT_STACK_FREE(jit_stack);\n  }\n\n#define FREECONTEXTS \\\n  G(pcre2_general_context_free_,BITS)(G(general_context,BITS)); \\\n  G(pcre2_general_context_free_,BITS)(G(general_context_copy,BITS)); \\\n  G(pcre2_compile_context_free_,BITS)(G(pat_context,BITS)); \\\n  G(pcre2_compile_context_free_,BITS)(G(default_pat_context,BITS)); \\\n  G(pcre2_match_context_free_,BITS)(G(dat_context,BITS)); \\\n  G(pcre2_match_context_free_,BITS)(G(default_dat_context,BITS)); \\\n  G(pcre2_convert_context_free_,BITS)(G(default_con_context,BITS)); \\\n  G(pcre2_convert_context_free_,BITS)(G(con_context,BITS));\n\n#ifdef SUPPORT_PCRE2_8\n#undef BITS\n#define BITS 8\nif (preg.re_pcre2_code != NULL) regfree(&preg);\nFREECONTEXTS;\n#endif\n\n#ifdef SUPPORT_PCRE2_16\n#undef BITS\n#define BITS 16\nfree(pbuffer16);\nFREECONTEXTS;\n#endif\n\n#ifdef SUPPORT_PCRE2_32\n#undef BITS\n#define BITS 32\nfree(pbuffer32);\nFREECONTEXTS;\n#endif\n\n#if defined(__VMS)\n  yield = SS$_NORMAL;  /* Return values via DCL symbols */\n#endif\n\nreturn yield;\n}\n\n/* End of pcre2test.c */\n/*autoconv-0001 C:\\projects\\pcre2-10.35\\src\\pcre2test.c converted to PCR2TEST*/\n/*autoconv-0011 PCR2TEST line: 58 config.h replaced by CONFIG.h*/\n/*autoconv-0011 PCR2TEST line: 265 pcre2.h replaced by PCRE2.h*/\n/*autoconv-0011 PCR2TEST line: 266 pcre2posix.h replaced by POSIXH.h*/\n/*autoconv-0011 PCR2TEST line: 267 pcre2_internal.h replaced by INTERNA2.h*/\n/*autoconv-0011 PCR2TEST line: 274 pcre2_tables.c replaced by TABLES2.c*/\n/*autoconv-0011 PCR2TEST line: 275 pcre2_ucd.c replaced by UCD2.c*/\n/*autoconv-0011 PCR2TEST line: 308 pcre2_intmodedep.h replaced by INTMODE2.h*/\n/*autoconv-0011 PCR2TEST line: 309 pcre2_printint.c replaced by PRINTIN2.c*/\n/*autoconv-0011 PCR2TEST line: 317 pcre2_intmodedep.h replaced by INTMODE2.h*/\n/*autoconv-0011 PCR2TEST line: 318 pcre2_printint.c replaced by PRINTIN2.c*/\n/*autoconv-0011 PCR2TEST line: 326 pcre2_intmodedep.h replaced by INTMODE2.h*/\n/*autoconv-0011 PCR2TEST line: 327 pcre2_printint.c replaced by PRINTIN2.c*/\n/*autoconv-0011 PCR2TEST line: 344 pcre2_valid_utf.c replaced by VALIDUT2.c*/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PC2POSIX": {"ttr": 1795, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "\n/*************************************************\n*      Perl-Compatible Regular Expressions       *\n*************************************************/\n\n/* PCRE is a library of functions to support regular expressions whose syntax\nand semantics are as close as possible to those of the Perl 5 language.\n\n                       Written by Philip Hazel\n     Original API code Copyright (c) 1997-2012 University of Cambridge\n          New API code Copyright (c) 2016-2019 University of Cambridge\n\n-----------------------------------------------------------------------------\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n\n    * Redistributions of source code must retain the above copyright notice,\n      this list of conditions and the following disclaimer.\n\n    * Redistributions in binary form must reproduce the above copyright\n      notice, this list of conditions and the following disclaimer in the\n      documentation and/or other materials provided with the distribution.\n\n    * Neither the name of the University of Cambridge nor the names of its\n      contributors may be used to endorse or promote products derived from\n      this software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\nAND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\nIMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\nARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\nLIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\nCONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\nSUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\nINTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\nCONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\nARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\nPOSSIBILITY OF SUCH DAMAGE.\n-----------------------------------------------------------------------------\n*/\n\n\n/* This module is a wrapper that provides a POSIX API to the underlying PCRE2\nfunctions. The operative functions are called pcre2_regcomp(), etc., with\nwrappers that use the plain POSIX names. In addition, pcre2posix.h defines the\nPOSIX names as macros for the pcre2_xxx functions, so any program that includes\nit and uses the POSIX names will call the base functions directly. This makes\nit easier for an application to be sure it gets the PCRE2 versions in the\npresence of other POSIX regex libraries. */\n\n\n#ifdef HAVE_CONFIG_H\n#include \"CONFIG.h\"\n#endif\n\n\n/* Ensure that the PCRE2POSIX_EXP_xxx macros are set appropriately for\ncompiling these functions. This must come before including pcre2posix.h, where\nthey are set for an application (using these functions) if they have not\npreviously been set. */\n\n#if defined(_WIN32) && !defined(PCRE2_STATIC)\n#  define PCRE2POSIX_EXP_DECL extern __declspec(dllexport)\n#  define PCRE2POSIX_EXP_DEFN __declspec(dllexport)\n#endif\n\n/* Older versions of MSVC lack snprintf(). This define allows for\nwarning/error-free compilation and testing with MSVC compilers back to at least\nMSVC 10/2010. Except for VC6 (which is missing some fundamentals and fails). */\n\n#if defined(_MSC_VER) && (_MSC_VER < 1900)\n#define snprintf _snprintf\n#endif\n\n\n/* Compile-time error numbers start at this value. It should probably never be\nchanged. This #define is a copy of the one in pcre2_internal.h. */\n\n#define COMPILE_ERROR_BASE 100\n\n\n/* Standard C headers */\n\n#include <ctype.h>\n#include <limits.h>\n#include <stddef.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n/* PCRE2 headers */\n\n#include \"PCRE2.h\"\n#include \"POSIXH.h\"\n\n/* When compiling with the MSVC compiler, it is sometimes necessary to include\na \"calling convention\" before exported function names. (This is secondhand\ninformation; I know nothing about MSVC myself). For example, something like\n\n  void __cdecl function(....)\n\nmight be needed. In order to make this easy, all the exported functions have\nPCRE2_CALL_CONVENTION just before their names. It is rarely needed; if not\nset, we ensure here that it has no effect. */\n\n#ifndef PCRE2_CALL_CONVENTION\n#define PCRE2_CALL_CONVENTION\n#endif\n\n/* Table to translate PCRE2 compile time error codes into POSIX error codes.\nOnly a few PCRE2 errors with a value greater than 23 turn into special POSIX\ncodes: most go to REG_BADPAT. The second table lists, in pairs, those that\ndon't. */\n\nstatic const int eint1\u00dd\u00a8 = {\n  0,           /* No error */\n  REG_EESCAPE, /* \\ at end of pattern */\n  REG_EESCAPE, /* \\c at end of pattern */\n  REG_EESCAPE, /* unrecognized character follows \\ */\n  REG_BADBR,   /* numbers out of order in {} quantifier */\n  /* 5 */\n  REG_BADBR,   /* number too big in {} quantifier */\n  REG_EBRACK,  /* missing terminating \u00a8 for character class */\n  REG_ECTYPE,  /* invalid escape sequence in character class */\n  REG_ERANGE,  /* range out of order in character class */\n  REG_BADRPT,  /* nothing to repeat */\n  /* 10 */\n  REG_ASSERT,  /* internal error: unexpected repeat */\n  REG_BADPAT,  /* unrecognized character after (? or (?- */\n  REG_BADPAT,  /* POSIX named classes are supported only within a class */\n  REG_BADPAT,  /* POSIX collating elements are not supported */\n  REG_EPAREN,  /* missing ) */\n  /* 15 */\n  REG_ESUBREG, /* reference to non-existent subpattern */\n  REG_INVARG,  /* pattern passed as NULL */\n  REG_INVARG,  /* unknown compile-time option bit(s) */\n  REG_EPAREN,  /* missing ) after (?# comment */\n  REG_ESIZE,   /* parentheses nested too deeply */\n  /* 20 */\n  REG_ESIZE,   /* regular expression too large */\n  REG_ESPACE,  /* failed to get memory */\n  REG_EPAREN,  /* unmatched closing parenthesis */\n  REG_ASSERT   /* internal error: code overflow */\n  };\n\nstatic const int eint2\u00dd\u00a8 = {\n  30, REG_ECTYPE,  /* unknown POSIX class name */\n  32, REG_INVARG,  /* this version of PCRE2 does not have Unicode support */\n  37, REG_EESCAPE, /* PCRE2 does not support \\L, \\l, \\N{name}, \\U, or \\u */\n  56, REG_INVARG,  /* internal error: unknown newline setting */\n  92, REG_INVARG,  /* invalid option bits with PCRE2_LITERAL */\n};\n\n/* Table of texts corresponding to POSIX error codes */\n\nstatic const char *const pstring\u00dd\u00a8 = {\n  \"\",                                /* Dummy for value 0 */\n  \"internal error\",                  /* REG_ASSERT */\n  \"invalid repeat counts in {}\",     /* BADBR      */\n  \"pattern error\",                   /* BADPAT     */\n  \"? * + invalid\",                   /* BADRPT     */\n  \"unbalanced {}\",                   /* EBRACE     */\n  \"unbalanced \u00dd\u00a8\",                   /* EBRACK     */\n  \"collation error - not relevant\",  /* ECOLLATE   */\n  \"bad class\",                       /* ECTYPE     */\n  \"bad escape sequence\",             /* EESCAPE    */\n  \"empty expression\",                /* EMPTY      */\n  \"unbalanced ()\",                   /* EPAREN     */\n  \"bad range inside \u00dd\u00a8\",             /* ERANGE     */\n  \"expression too big\",              /* ESIZE      */\n  \"failed to get memory\",            /* ESPACE     */\n  \"bad back reference\",              /* ESUBREG    */\n  \"bad argument\",                    /* INVARG     */\n  \"match failed\"                     /* NOMATCH    */\n};\n\n\n\n/*************************************************\n*      Wrappers with traditional POSIX names     *\n*************************************************/\n\n/* Keep defining them to preseve the ABI for applications linked to the pcre2\nPOSIX library before these names were changed into macros in pcre2posix.h.\nThis also ensures that the POSIX names are callable from languages that do not\ninclude pcre2posix.h. It is vital to #undef the macro definitions from\npcre2posix.h! */\n\n#undef regerror\nPCRE2POSIX_EXP_DECL size_t regerror(int, const regex_t *, char *, size_t);\nPCRE2POSIX_EXP_DEFN size_t PCRE2_CALL_CONVENTION\nregerror(int errcode, const regex_t *preg, char *errbuf, size_t errbuf_size)\n{\nreturn pcre2_regerror(errcode, preg, errbuf, errbuf_size);\n}\n\n#undef regfree\nPCRE2POSIX_EXP_DECL void regfree(regex_t *);\nPCRE2POSIX_EXP_DEFN void PCRE2_CALL_CONVENTION\nregfree(regex_t *preg)\n{\npcre2_regfree(preg);\n}\n\n#undef regcomp\nPCRE2POSIX_EXP_DECL int regcomp(regex_t *, const char *, int);\nPCRE2POSIX_EXP_DEFN int PCRE2_CALL_CONVENTION\nregcomp(regex_t *preg, const char *pattern, int cflags)\n{\nreturn pcre2_regcomp(preg, pattern, cflags);\n}\n\n#undef regexec\nPCRE2POSIX_EXP_DECL int regexec(const regex_t *, const char *, size_t,\n  regmatch_t *, int);\nPCRE2POSIX_EXP_DEFN int PCRE2_CALL_CONVENTION\nregexec(const regex_t *preg, const char *string, size_t nmatch,\n  regmatch_t pmatch\u00dd\u00a8, int eflags)\n{\nreturn pcre2_regexec(preg, string, nmatch, pmatch, eflags);\n}\n\n\n\n/*************************************************\n*          Translate error code to string        *\n*************************************************/\n\nPCRE2POSIX_EXP_DEFN size_t PCRE2_CALL_CONVENTION\npcre2_regerror(int errcode, const regex_t *preg, char *errbuf,\n  size_t errbuf_size)\n{\nint used;\nconst char *message;\n\nmessage = (errcode <= 0 || errcode >= (int)(sizeof(pstring)/sizeof(char *)))?\n  \"unknown error code\" : pstring\u00dderrcode\u00a8;\n\nif (preg != NULL && (int)preg->re_erroffset != -1)\n  {\n  used = snprintf(errbuf, errbuf_size, \"%s at offset %-6d\", message,\n    (int)preg->re_erroffset);\n  }\nelse\n  {\n  used = snprintf(errbuf, errbuf_size, \"%s\", message);\n  }\n\nreturn used + 1;\n}\n\n\n\n/*************************************************\n*           Free store held by a regex           *\n*************************************************/\n\nPCRE2POSIX_EXP_DEFN void PCRE2_CALL_CONVENTION\npcre2_regfree(regex_t *preg)\n{\npcre2_match_data_free(preg->re_match_data);\npcre2_code_free(preg->re_pcre2_code);\n}\n\n\n\n/*************************************************\n*            Compile a regular expression        *\n*************************************************/\n\n/*\nArguments:\n  preg        points to a structure for recording the compiled expression\n  pattern     the pattern to compile\n  cflags      compilation flags\n\nReturns:      0 on success\n              various non-zero codes on failure\n*/\n\nPCRE2POSIX_EXP_DEFN int PCRE2_CALL_CONVENTION\npcre2_regcomp(regex_t *preg, const char *pattern, int cflags)\n{\nPCRE2_SIZE erroffset;\nPCRE2_SIZE patlen;\nint errorcode;\nint options = 0;\nint re_nsub = 0;\n\npatlen = ((cflags & REG_PEND) != 0)? (PCRE2_SIZE)(preg->re_endp - pattern) :\n  PCRE2_ZERO_TERMINATED;\n\nif ((cflags & REG_ICASE) != 0)    options |= PCRE2_CASELESS;\nif ((cflags & REG_NEWLINE) != 0)  options |= PCRE2_MULTILINE;\nif ((cflags & REG_DOTALL) != 0)   options |= PCRE2_DOTALL;\nif ((cflags & REG_NOSPEC) != 0)   options |= PCRE2_LITERAL;\nif ((cflags & REG_UTF) != 0)      options |= PCRE2_UTF;\nif ((cflags & REG_UCP) != 0)      options |= PCRE2_UCP;\nif ((cflags & REG_UNGREEDY) != 0) options |= PCRE2_UNGREEDY;\n\npreg->re_cflags = cflags;\npreg->re_pcre2_code = pcre2_compile((PCRE2_SPTR)pattern, patlen, options,\n  &errorcode, &erroffset, NULL);\npreg->re_erroffset = erroffset;\n\nif (preg->re_pcre2_code == NULL)\n  {\n  unsigned int i;\n\n  /* A negative value is a UTF error; otherwise all error codes are greater\n  than COMPILE_ERROR_BASE, but check, just in case. */\n\n  if (errorcode < COMPILE_ERROR_BASE) return REG_BADPAT;\n  errorcode -= COMPILE_ERROR_BASE;\n\n  if (errorcode < (int)(sizeof(eint1)/sizeof(const int)))\n    return eint1\u00dderrorcode\u00a8;\n  for (i = 0; i < sizeof(eint2)/sizeof(const int); i += 2)\n    if (errorcode == eint2\u00ddi\u00a8) return eint2\u00ddi+1\u00a8;\n  return REG_BADPAT;\n  }\n\n(void)pcre2_pattern_info((const pcre2_code *)preg->re_pcre2_code,\n  PCRE2_INFO_CAPTURECOUNT, &re_nsub);\npreg->re_nsub = (size_t)re_nsub;\npreg->re_match_data = pcre2_match_data_create(re_nsub + 1, NULL);\npreg->re_erroffset = (size_t)(-1);  /* No meaning after successful compile */\n\nif (preg->re_match_data == NULL)\n  {\n  pcre2_code_free(preg->re_pcre2_code);\n  return REG_ESPACE;\n  }\n\nreturn 0;\n}\n\n\n\n/*************************************************\n*              Match a regular expression        *\n*************************************************/\n\n/* A suitable match_data block, large enough to hold all possible captures, was\nobtained when the pattern was compiled, to save having to allocate and free it\nfor each match. If REG_NOSUB was specified at compile time, the nmatch and\npmatch arguments are ignored, and the only result is yes/no/error. */\n\nPCRE2POSIX_EXP_DEFN int PCRE2_CALL_CONVENTION\npcre2_regexec(const regex_t *preg, const char *string, size_t nmatch,\n  regmatch_t pmatch\u00dd\u00a8, int eflags)\n{\nint rc, so, eo;\nint options = 0;\npcre2_match_data *md = (pcre2_match_data *)preg->re_match_data;\n\nif ((eflags & REG_NOTBOL) != 0) options |= PCRE2_NOTBOL;\nif ((eflags & REG_NOTEOL) != 0) options |= PCRE2_NOTEOL;\nif ((eflags & REG_NOTEMPTY) != 0) options |= PCRE2_NOTEMPTY;\n\n/* When REG_NOSUB was specified, or if no vector has been passed in which to\nput captured strings, ensure that nmatch is zero. This will stop any attempt to\nwrite to pmatch. */\n\nif ((preg->re_cflags & REG_NOSUB) != 0 || pmatch == NULL) nmatch = 0;\n\n/* REG_STARTEND is a BSD extension, to allow for non-NUL-terminated strings.\nThe man page from OS X says \"REG_STARTEND affects only the location of the\nstring, not how it is matched\". That is why the \"so\" value is used to bump the\nstart location rather than being passed as a PCRE2 \"starting offset\". */\n\nif ((eflags & REG_STARTEND) != 0)\n  {\n  if (pmatch == NULL) return REG_INVARG;\n  so = pmatch\u00dd0\u00a8.rm_so;\n  eo = pmatch\u00dd0\u00a8.rm_eo;\n  }\nelse\n  {\n  so = 0;\n  eo = (int)strlen(string);\n  }\n\nrc = pcre2_match((const pcre2_code *)preg->re_pcre2_code,\n  (PCRE2_SPTR)string + so, (eo - so), 0, options, md, NULL);\n\n/* Successful match */\n\nif (rc >= 0)\n  {\n  size_t i;\n  PCRE2_SIZE *ovector = pcre2_get_ovector_pointer(md);\n  if ((size_t)rc > nmatch) rc = (int)nmatch;\n  for (i = 0; i < (size_t)rc; i++)\n    {\n    pmatch\u00ddi\u00a8.rm_so = (ovector\u00ddi*2\u00a8 == PCRE2_UNSET)? -1 :\n      (int)(ovector\u00ddi*2\u00a8 + so);\n    pmatch\u00ddi\u00a8.rm_eo = (ovector\u00ddi*2+1\u00a8 == PCRE2_UNSET)? -1 :\n      (int)(ovector\u00ddi*2+1\u00a8 + so);\n    }\n  for (; i < nmatch; i++) pmatch\u00ddi\u00a8.rm_so = pmatch\u00ddi\u00a8.rm_eo = -1;\n  return 0;\n  }\n\n/* Unsuccessful match */\n\nif (rc <= PCRE2_ERROR_UTF8_ERR1 && rc >= PCRE2_ERROR_UTF8_ERR21)\n  return REG_INVARG;\n\nswitch(rc)\n  {\n  default: return REG_ASSERT;\n  case PCRE2_ERROR_BADMODE: return REG_INVARG;\n  case PCRE2_ERROR_BADMAGIC: return REG_INVARG;\n  case PCRE2_ERROR_BADOPTION: return REG_INVARG;\n  case PCRE2_ERROR_BADUTFOFFSET: return REG_INVARG;\n  case PCRE2_ERROR_MATCHLIMIT: return REG_ESPACE;\n  case PCRE2_ERROR_NOMATCH: return REG_NOMATCH;\n  case PCRE2_ERROR_NOMEMORY: return REG_ESPACE;\n  case PCRE2_ERROR_NULL: return REG_INVARG;\n  }\n}\n\n/* End of pcre2posix.c */\n/*autoconv-0001 C:\\projects\\pcre2-10.35\\src\\pcre2posix.c converted to PC2POSIX*/\n/*autoconv-0011 PC2POSIX line: 52 config.h replaced by CONFIG.h*/\n/*autoconv-0011 PC2POSIX line: 92 pcre2.h replaced by PCRE2.h*/\n/*autoconv-0011 PC2POSIX line: 93 pcre2posix.h replaced by POSIXH.h*/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PC2PSXAP": {"ttr": 2309, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "\n\n/**************************************************\n *       Perl-Compatible Regular Expressions      *\n **************************************************\n---------------------------------------------------------------\nRedistribution and use in source and binary forms, with or\nwithout modification, are permitted provided that the following\nconditions are met:\n\n 1. Redistributions of source code must retain the above\n copyright notice, this list of conditions and the following\n disclaimer.\n\n 2. Redistributions in binary form must reproduce the above\n copyright notice, this list of conditions and the following\n disclaimer in the documentation and/or other materials\n provided with the distribution.\n\n 3. Neither the name of the University of Cambridge nor the\n names of its contributors may be used to endorse or promote\n products derived from this software without specific prior\n written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND\nCONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES,\nINCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\nMERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR\nCONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\nNOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\nLOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\nHOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\nCONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR\nOTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,\nEVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n---------------------------------------------------------------*/\n/* This header file is to be used by client C programs that want to use\n the traditional POSIX compliant CALL sequences, yet to get PCRE2\n functionality.  Non-C programs that want to achieve the same effect\n may either call the PCRE2 routine names directly or create an API\n module that wrap the PCRE2 names with the traditional namea. Be aware\n though that the latter solution may cause undue conflicts in 'bind'\n time.\n I've decided to change the POSIX API compliant PCRE2 functions to\n prevent such conflict, but by doing so I eliminated the simple\n traditional call sequnce.  This header restores the simple traditional\n call sequence for C programs, but the API for other languages is not\n yet available and is in low priority.\n I will try to provide such an API and full, less confusing\n documentation of the issue in a subsequent release of PCRE2 for z/OS\n This is the second version attempt.  It provides both the #pragma map\n directives and the decision whether to use them (and the accompanied\n headers, or the posix standard header, in one package.  It replaces\n the PC2PSXPG.h and makes it obsolete.\n */\n#ifdef COMPILE_WITH_PCRE2\n/* This header contains a few pragma statements to make the compiler\n use the PCRE2 equivalents of the traditional POSIX functions\n PC2PSXAP.h replaced the obsolete PC2PSXPG.h .  In addition, it\n invokes the necessary PCRE2 or POSIX headers.\n The #pragma statements are no longer needed (10.33) */\n#include \"pcre2.h\"\n#include \"posixh.h\"\n/*\n#pragma map (regfree, \"PREGFREE\")\n#pragma map (regerror, \"PREGERR\")\n#pragma map (regexec, \"PREGEXEC\")\n#pragma map (regcomp, \"PREGCOMP\")\n*/\nstatic unsigned char COMPILE_OPTION\u00dd\u00a8 = \"COMPILE WITH PCRE2\";\n#else\n#include <regex.h>\nstatic unsigned char COMPILE_OPTION\u00dd\u00a8 = \"COMPILE WITH POSIX\";\n#endif\n/*autoconv-0001 C:\\projects\\pcre2port\\PC2PSXAP.h converted to PC2PSXAP*/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "POSIXH": {"ttr": 273, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "\n/*************************************************\n*      Perl-Compatible Regular Expressions       *\n*************************************************/\n\n/* PCRE2 is a library of functions to support regular expressions whose syntax\nand semantics are as close as possible to those of the Perl 5 language. This is\nthe public header file to be #included by applications that call PCRE2 via the\nPOSIX wrapper interface.\n\n                       Written by Philip Hazel\n     Original API code Copyright (c) 1997-2012 University of Cambridge\n          New API code Copyright (c) 2016-2019 University of Cambridge\n\n-----------------------------------------------------------------------------\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n\n    * Redistributions of source code must retain the above copyright notice,\n      this list of conditions and the following disclaimer.\n\n    * Redistributions in binary form must reproduce the above copyright\n      notice, this list of conditions and the following disclaimer in the\n      documentation and/or other materials provided with the distribution.\n\n    * Neither the name of the University of Cambridge nor the names of its\n      contributors may be used to endorse or promote products derived from\n      this software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\nAND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\nIMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\nARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\nLIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\nCONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\nSUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\nINTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\nCONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\nARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\nPOSSIBILITY OF SUCH DAMAGE.\n-----------------------------------------------------------------------------\n*/\n\n\n/* Have to include stdlib.h in order to ensure that size_t is defined. */\n\n#include <stdlib.h>\n\n/* Allow for C++ users */\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n/* Options, mostly defined by POSIX, but with some extras. */\n\n#define REG_ICASE     0x0001  /* Maps to PCRE2_CASELESS */\n#define REG_NEWLINE   0x0002  /* Maps to PCRE2_MULTILINE */\n#define REG_NOTBOL    0x0004  /* Maps to PCRE2_NOTBOL */\n#define REG_NOTEOL    0x0008  /* Maps to PCRE2_NOTEOL */\n#define REG_DOTALL    0x0010  /* NOT defined by POSIX; maps to PCRE2_DOTALL */\n#define REG_NOSUB     0x0020  /* Do not report what was matched */\n#define REG_UTF       0x0040  /* NOT defined by POSIX; maps to PCRE2_UTF */\n#define REG_STARTEND  0x0080  /* BSD feature: pass subject string by so,eo */\n#define REG_NOTEMPTY  0x0100  /* NOT defined by POSIX; maps to PCRE2_NOTEMPTY */\n#define REG_UNGREEDY  0x0200  /* NOT defined by POSIX; maps to PCRE2_UNGREEDY */\n#define REG_UCP       0x0400  /* NOT defined by POSIX; maps to PCRE2_UCP */\n#define REG_PEND      0x0800  /* GNU feature: pass end pattern by re_endp */\n#define REG_NOSPEC    0x1000  /* Maps to PCRE2_LITERAL */\n\n/* This is not used by PCRE2, but by defining it we make it easier\nto slot PCRE2 into existing programs that make POSIX calls. */\n\n#define REG_EXTENDED  0\n\n/* Error values. Not all these are relevant or used by the wrapper. */\n\nenum {\n  REG_ASSERT = 1,  /* internal error ? */\n  REG_BADBR,       /* invalid repeat counts in {} */\n  REG_BADPAT,      /* pattern error */\n  REG_BADRPT,      /* ? * + invalid */\n  REG_EBRACE,      /* unbalanced {} */\n  REG_EBRACK,      /* unbalanced \u00dd\u00a8 */\n  REG_ECOLLATE,    /* collation error - not relevant */\n  REG_ECTYPE,      /* bad class */\n  REG_EESCAPE,     /* bad escape sequence */\n  REG_EMPTY,       /* empty expression */\n  REG_EPAREN,      /* unbalanced () */\n  REG_ERANGE,      /* bad range inside \u00dd\u00a8 */\n  REG_ESIZE,       /* expression too big */\n  REG_ESPACE,      /* failed to get memory */\n  REG_ESUBREG,     /* bad back reference */\n  REG_INVARG,      /* bad argument */\n  REG_NOMATCH      /* match failed */\n};\n\n\n/* The structure representing a compiled regular expression. It is also used\nfor passing the pattern end pointer when REG_PEND is set. */\n\ntypedef struct {\n  void *re_pcre2_code;\n  void *re_match_data;\n  const char *re_endp;\n  size_t re_nsub;\n  size_t re_erroffset;\n  int re_cflags;\n} regex_t;\n\n/* The structure in which a captured offset is returned. */\n\ntypedef int regoff_t;\n\ntypedef struct {\n  regoff_t rm_so;\n  regoff_t rm_eo;\n} regmatch_t;\n\n/* When an application links to a PCRE2 DLL in Windows, the symbols that are\nimported have to be identified as such. When building PCRE2, the appropriate\nexport settings are needed, and are set in pcre2posix.c before including this\nfile. */\n\n#if defined(_WIN32) && !defined(PCRE2_STATIC) && !defined(PCRE2POSIX_EXP_DECL)\n#  define PCRE2POSIX_EXP_DECL  extern __declspec(dllimport)\n#  define PCRE2POSIX_EXP_DEFN  __declspec(dllimport)\n#endif\n\n/* By default, we use the standard \"extern\" declarations. */\n\n#ifndef PCRE2POSIX_EXP_DECL\n#  ifdef __cplusplus\n#    define PCRE2POSIX_EXP_DECL  extern \"C\"\n#    define PCRE2POSIX_EXP_DEFN  extern \"C\"\n#  else\n#    define PCRE2POSIX_EXP_DECL  extern\n#    define PCRE2POSIX_EXP_DEFN  extern\n#  endif\n#endif\n\n/* The functions. The actual code is in functions with pcre2_xxx names for\nuniqueness. POSIX names are provided as macros for API compatibility with POSIX\nregex functions. It's done this way to ensure to they are always linked from\nthe PCRE2 library and not by accident from elsewhere (regex_t differs in size\nelsewhere). */\n\nPCRE2POSIX_EXP_DECL int pcre2_regcomp(regex_t *, const char *, int);\nPCRE2POSIX_EXP_DECL int pcre2_regexec(const regex_t *, const char *, size_t,\n                     regmatch_t *, int);\nPCRE2POSIX_EXP_DECL size_t pcre2_regerror(int, const regex_t *, char *, size_t);\nPCRE2POSIX_EXP_DECL void pcre2_regfree(regex_t *);\n\n#define regcomp  pcre2_regcomp\n#define regexec  pcre2_regexec\n#define regerror pcre2_regerror\n#define regfree  pcre2_regfree\n\n/* Debian had a patch that used different names. These are now here to save\nthem having to maintain their own patch, but are not documented by PCRE2. */\n\n#define PCRE2regcomp  pcre2_regcomp\n#define PCRE2regexec  pcre2_regexec\n#define PCRE2regerror pcre2_regerror\n#define PCRE2regfree  pcre2_regfree\n\n#ifdef __cplusplus\n}   /* extern \"C\" */\n#endif\n\n/* End of pcre2posix.h */\n/*autoconv-0001 C:\\projects\\pcre2-10.35\\src\\pcre2posix.h converted to POSIXH*/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PRINTIN2": {"ttr": 275, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "\n/*************************************************\n*      Perl-Compatible Regular Expressions       *\n*************************************************/\n\n/* PCRE is a library of functions to support regular expressions whose syntax\nand semantics are as close as possible to those of the Perl 5 language.\n\n                       Written by Philip Hazel\n     Original API code Copyright (c) 1997-2012 University of Cambridge\n          New API code Copyright (c) 2016-2019 University of Cambridge\n\n-----------------------------------------------------------------------------\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n\n    * Redistributions of source code must retain the above copyright notice,\n      this list of conditions and the following disclaimer.\n\n    * Redistributions in binary form must reproduce the above copyright\n      notice, this list of conditions and the following disclaimer in the\n      documentation and/or other materials provided with the distribution.\n\n    * Neither the name of the University of Cambridge nor the names of its\n      contributors may be used to endorse or promote products derived from\n      this software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\nAND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\nIMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\nARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\nLIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\nCONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\nSUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\nINTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\nCONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\nARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\nPOSSIBILITY OF SUCH DAMAGE.\n-----------------------------------------------------------------------------\n*/\n\n\n/* This module contains a PCRE private debugging function for printing out the\ninternal form of a compiled regular expression, along with some supporting\nlocal functions. This source file is #included in pcre2test.c at each supported\ncode unit width, with PCRE2_SUFFIX set appropriately, just like the functions\nthat comprise the library. It can also optionally be included in\npcre2_compile.c for detailed debugging in error situations. */\n\n\n/* Tables of operator names. The same 8-bit table is used for all code unit\nwidths, so it must be defined only once. The list itself is defined in\npcre2_internal.h, which is #included by pcre2test before this file. */\n\n#ifndef OP_LISTS_DEFINED\nstatic const char *OP_names\u00dd\u00a8 = { OP_NAME_LIST };\n#define OP_LISTS_DEFINED\n#endif\n\n/* The functions and tables herein must all have mode-dependent names. */\n\n#define OP_lengths            PCRE2_SUFFIX(OP_lengths_)\n#define get_ucpname           PCRE2_SUFFIX(get_ucpname_)\n#define pcre2_printint        PCRE2_SUFFIX(pcre2_printint_)\n#define print_char            PCRE2_SUFFIX(print_char_)\n#define print_custring        PCRE2_SUFFIX(print_custring_)\n#define print_custring_bylen  PCRE2_SUFFIX(print_custring_bylen_)\n#define print_prop            PCRE2_SUFFIX(print_prop_)\n\n/* Table of sizes for the fixed-length opcodes. It's defined in a macro so that\nthe definition is next to the definition of the opcodes in pcre2_internal.h.\nThe contents of the table are, however, mode-dependent. */\n\nstatic const uint8_t OP_lengths\u00dd\u00a8 = { OP_LENGTHS };\n\n\n\n/*************************************************\n*       Print one character from a string        *\n*************************************************/\n\n/* In UTF mode the character may occupy more than one code unit.\n\nArguments:\n  f           file to write to\n  ptr         pointer to first code unit of the character\n  utf         TRUE if string is UTF (will be FALSE if UTF is not supported)\n\nReturns:      number of additional code units used\n*/\n\nstatic unsigned int\nprint_char(FILE *f, PCRE2_SPTR ptr, BOOL utf)\n{\nuint32_t c = *ptr;\nBOOL one_code_unit = !utf;\n\n/* If UTF is supported and requested, check for a valid single code unit. */\n\n#ifdef SUPPORT_UNICODE\nif (utf)\n  {\n#if PCRE2_CODE_UNIT_WIDTH == 8\n  one_code_unit = c < 0x80;\n#elif PCRE2_CODE_UNIT_WIDTH == 16\n  one_code_unit = (c & 0xfc00) != 0xd800;\n#else\n  one_code_unit = (c & 0xfffff800u) != 0xd800u;\n#endif  /* CODE_UNIT_WIDTH */\n  }\n#endif  /* SUPPORT_UNICODE */\n\n/* Handle a valid one-code-unit character at any width. */\n\nif (one_code_unit)\n  {\n  if (PRINTABLE(c)) fprintf(f, \"%c\", (char)c);\n  else if (c < 0x80) fprintf(f, \"\\\\x%02x\", c);\n  else fprintf(f, \"\\\\x{%02x}\", c);\n  return 0;\n  }\n\n/* Code for invalid UTF code units and multi-unit UTF characters is different\nfor each width. If UTF is not supported, control should never get here, but we\nneed a return statement to keep the compiler happy. */\n\n#ifndef SUPPORT_UNICODE\nreturn 0;\n#else\n\n/* Malformed UTF-8 should occur only if the sanity check has been turned off.\nRather than swallow random bytes, just stop if we hit a bad one. Print it with\n\\X instead of \\x as an indication. */\n\n#if PCRE2_CODE_UNIT_WIDTH == 8\nif ((c & 0xc0) != 0xc0)\n  {\n  fprintf(f, \"\\\\X{%x}\", c);       /* Invalid starting byte */\n  return 0;\n  }\nelse\n  {\n  int i;\n  int a = PRIV(utf8_table4)\u00ddc & 0x3f\u00a8;  /* Number of additional bytes */\n  int s = 6*a;\n  c = (c & PRIV(utf8_table3)\u00dda\u00a8) << s;\n  for (i = 1; i <= a; i++)\n    {\n    if ((ptr\u00ddi\u00a8 & 0xc0) != 0x80)\n      {\n      fprintf(f, \"\\\\X{%x}\", c);   /* Invalid secondary byte */\n      return i - 1;\n      }\n    s -= 6;\n    c |= (ptr\u00ddi\u00a8 & 0x3f) << s;\n    }\n  fprintf(f, \"\\\\x{%x}\", c);\n  return a;\n}\n#endif  /* PCRE2_CODE_UNIT_WIDTH == 8 */\n\n/* UTF-16: rather than swallow a low surrogate, just stop if we hit a bad one.\nPrint it with \\X instead of \\x as an indication. */\n\n#if PCRE2_CODE_UNIT_WIDTH == 16\nif ((ptr\u00dd1\u00a8 & 0xfc00) != 0xdc00)\n  {\n  fprintf(f, \"\\\\X{%x}\", c);\n  return 0;\n  }\nc = (((c & 0x3ff) << 10) | (ptr\u00dd1\u00a8 & 0x3ff)) + 0x10000;\nfprintf(f, \"\\\\x{%x}\", c);\nreturn 1;\n#endif  /* PCRE2_CODE_UNIT_WIDTH == 16 */\n\n/* For UTF-32 we get here only for a malformed code unit, which should only\noccur if the sanity check has been turned off. Print it with \\X instead of \\x\nas an indication. */\n\n#if PCRE2_CODE_UNIT_WIDTH == 32\nfprintf(f, \"\\\\X{%x}\", c);\nreturn 0;\n#endif  /* PCRE2_CODE_UNIT_WIDTH == 32 */\n#endif  /* SUPPORT_UNICODE */\n}\n\n\n\n/*************************************************\n*     Print string as a list of code units       *\n*************************************************/\n\n/* These take no account of UTF as they always print each individual code unit.\nThe string is zero-terminated for print_custring(); the length is given for\nprint_custring_bylen().\n\nArguments:\n  f          file to write to\n  ptr        point to the string\n  len        length for print_custring_bylen()\n\nReturns:     nothing\n*/\n\nstatic void\nprint_custring(FILE *f, PCRE2_SPTR ptr)\n{\nwhile (*ptr != '\\0')\n  {\n  uint32_t c = *ptr++;\n  if (PRINTABLE(c)) fprintf(f, \"%c\", c); else fprintf(f, \"\\\\x{%x}\", c);\n  }\n}\n\nstatic void\nprint_custring_bylen(FILE *f, PCRE2_SPTR ptr, PCRE2_UCHAR len)\n{\nfor (; len > 0; len--)\n  {\n  uint32_t c = *ptr++;\n  if (PRINTABLE(c)) fprintf(f, \"%c\", c); else fprintf(f, \"\\\\x{%x}\", c);\n  }\n}\n\n\n\n/*************************************************\n*          Find Unicode property name            *\n*************************************************/\n\n/* When there is no UTF/UCP support, the table of names does not exist. This\nfunction should not be called in such configurations, because a pattern that\ntries to use Unicode properties won't compile. Rather than put lots of #ifdefs\ninto the main code, however, we just put one into this function. */\n\nstatic const char *\nget_ucpname(unsigned int ptype, unsigned int pvalue)\n{\n#ifdef SUPPORT_UNICODE\nint i;\nfor (i = PRIV(utt_size) - 1; i >= 0; i--)\n  {\n  if (ptype == PRIV(utt)\u00ddi\u00a8.type && pvalue == PRIV(utt)\u00ddi\u00a8.value) break;\n  }\nreturn (i >= 0)? PRIV(utt_names) + PRIV(utt)\u00ddi\u00a8.name_offset : \"??\";\n#else   /* No UTF support */\n(void)ptype;\n(void)pvalue;\nreturn \"??\";\n#endif  /* SUPPORT_UNICODE */\n}\n\n\n\n/*************************************************\n*       Print Unicode property value             *\n*************************************************/\n\n/* \"Normal\" properties can be printed from tables. The PT_CLIST property is a\npseudo-property that contains a pointer to a list of case-equivalent\ncharacters.\n\nArguments:\n  f            file to write to\n  code         pointer in the compiled code\n  before       text to print before\n  after        text to print after\n\nReturns:       nothing\n*/\n\nstatic void\nprint_prop(FILE *f, PCRE2_SPTR code, const char *before, const char *after)\n{\nif (code\u00dd1\u00a8 != PT_CLIST)\n  {\n  fprintf(f, \"%s%s %s%s\", before, OP_names\u00dd*code\u00a8, get_ucpname(code\u00dd1\u00a8,\n    code\u00dd2\u00a8), after);\n  }\nelse\n  {\n  const char *not = (*code == OP_PROP)? \"\" : \"not \";\n  const uint32_t *p = PRIV(ucd_caseless_sets) + code\u00dd2\u00a8;\n  fprintf (f, \"%s%sclist\", before, not);\n  while (*p < NOTACHAR) fprintf(f, \" %04x\", *p++);\n  fprintf(f, \"%s\", after);\n  }\n}\n\n\n\n/*************************************************\n*            Print compiled pattern              *\n*************************************************/\n\n/* The print_lengths flag controls whether offsets and lengths of items are\nprinted. Lenths can be turned off from pcre2test so that automatic tests on\nbytecode can be written that do not depend on the value of LINK_SIZE.\n\nArguments:\n  re              a compiled pattern\n  f               the file to write to\n  print_lengths   show various lengths\n\nReturns:          nothing\n*/\n\nstatic void\npcre2_printint(pcre2_code *re, FILE *f, BOOL print_lengths)\n{\nPCRE2_SPTR codestart, nametable, code;\nuint32_t nesize = re->name_entry_size;\nBOOL utf = (re->overall_options & PCRE2_UTF) != 0;\n\nnametable = (PCRE2_SPTR)((uint8_t *)re + sizeof(pcre2_real_code));\ncode = codestart = nametable + re->name_count * re->name_entry_size;\n\nfor(;;)\n  {\n  PCRE2_SPTR ccode;\n  uint32_t c;\n  int i;\n  const char *flag = \"  \";\n  unsigned int extra = 0;\n\n  if (print_lengths)\n    fprintf(f, \"%3d \", (int)(code - codestart));\n  else\n    fprintf(f, \"    \");\n\n  switch(*code)\n    {\n/* ========================================================================== */\n      /* These cases are never obeyed. This is a fudge that causes a compile-\n      time error if the vectors OP_names or OP_lengths, which are indexed\n      by opcode, are not the correct length. It seems to be the only way to do\n      such a check at compile time, as the sizeof() operator does not work in\n      the C preprocessor. */\n\n      case OP_TABLE_LENGTH:\n      case OP_TABLE_LENGTH +\n        ((sizeof(OP_names)/sizeof(const char *) == OP_TABLE_LENGTH) &&\n        (sizeof(OP_lengths) == OP_TABLE_LENGTH)):\n      return;\n/* ========================================================================== */\n\n    case OP_END:\n    fprintf(f, \"    %s\\n\", OP_names\u00dd*code\u00a8);\n    fprintf(f, \"------------------------------------------------------------------\\n\");\n    return;\n\n    case OP_CHAR:\n    fprintf(f, \"    \");\n    do\n      {\n      code++;\n      code += 1 + print_char(f, code, utf);\n      }\n    while (*code == OP_CHAR);\n    fprintf(f, \"\\n\");\n    continue;\n\n    case OP_CHARI:\n    fprintf(f, \" /i \");\n    do\n      {\n      code++;\n      code += 1 + print_char(f, code, utf);\n      }\n    while (*code == OP_CHARI);\n    fprintf(f, \"\\n\");\n    continue;\n\n    case OP_CBRA:\n    case OP_CBRAPOS:\n    case OP_SCBRA:\n    case OP_SCBRAPOS:\n    if (print_lengths) fprintf(f, \"%3d \", GET(code, 1));\n      else fprintf(f, \"    \");\n    fprintf(f, \"%s %d\", OP_names\u00dd*code\u00a8, GET2(code, 1+LINK_SIZE));\n    break;\n\n    case OP_BRA:\n    case OP_BRAPOS:\n    case OP_SBRA:\n    case OP_SBRAPOS:\n    case OP_KETRMAX:\n    case OP_KETRMIN:\n    case OP_KETRPOS:\n    case OP_ALT:\n    case OP_KET:\n    case OP_ASSERT:\n    case OP_ASSERT_NOT:\n    case OP_ASSERTBACK:\n    case OP_ASSERTBACK_NOT:\n    case OP_ASSERT_NA:\n    case OP_ASSERTBACK_NA:\n    case OP_ONCE:\n    case OP_SCRIPT_RUN:\n    case OP_COND:\n    case OP_SCOND:\n    case OP_REVERSE:\n    if (print_lengths) fprintf(f, \"%3d \", GET(code, 1));\n      else fprintf(f, \"    \");\n    fprintf(f, \"%s\", OP_names\u00dd*code\u00a8);\n    break;\n\n    case OP_CLOSE:\n    fprintf(f, \"    %s %d\", OP_names\u00dd*code\u00a8, GET2(code, 1));\n    break;\n\n    case OP_CREF:\n    fprintf(f, \"%3d %s\", GET2(code,1), OP_names\u00dd*code\u00a8);\n    break;\n\n    case OP_DNCREF:\n      {\n      PCRE2_SPTR entry = nametable + (GET2(code, 1) * nesize) + IMM2_SIZE;\n      fprintf(f, \" %s Cond ref <\", flag);\n      print_custring(f, entry);\n      fprintf(f, \">%d\", GET2(code, 1 + IMM2_SIZE));\n      }\n    break;\n\n    case OP_RREF:\n    c = GET2(code, 1);\n    if (c == RREF_ANY)\n      fprintf(f, \"    Cond recurse any\");\n    else\n      fprintf(f, \"    Cond recurse %d\", c);\n    break;\n\n    case OP_DNRREF:\n      {\n      PCRE2_SPTR entry = nametable + (GET2(code, 1) * nesize) + IMM2_SIZE;\n      fprintf(f, \" %s Cond recurse <\", flag);\n      print_custring(f, entry);\n      fprintf(f, \">%d\", GET2(code, 1 + IMM2_SIZE));\n      }\n    break;\n\n    case OP_FALSE:\n    fprintf(f, \"    Cond false\");\n    break;\n\n    case OP_TRUE:\n    fprintf(f, \"    Cond true\");\n    break;\n\n    case OP_STARI:\n    case OP_MINSTARI:\n    case OP_POSSTARI:\n    case OP_PLUSI:\n    case OP_MINPLUSI:\n    case OP_POSPLUSI:\n    case OP_QUERYI:\n    case OP_MINQUERYI:\n    case OP_POSQUERYI:\n    flag = \"/i\";\n    /* Fall through */\n    case OP_STAR:\n    case OP_MINSTAR:\n    case OP_POSSTAR:\n    case OP_PLUS:\n    case OP_MINPLUS:\n    case OP_POSPLUS:\n    case OP_QUERY:\n    case OP_MINQUERY:\n    case OP_POSQUERY:\n    case OP_TYPESTAR:\n    case OP_TYPEMINSTAR:\n    case OP_TYPEPOSSTAR:\n    case OP_TYPEPLUS:\n    case OP_TYPEMINPLUS:\n    case OP_TYPEPOSPLUS:\n    case OP_TYPEQUERY:\n    case OP_TYPEMINQUERY:\n    case OP_TYPEPOSQUERY:\n    fprintf(f, \" %s \", flag);\n\n    if (*code >= OP_TYPESTAR)\n      {\n      if (code\u00dd1\u00a8 == OP_PROP || code\u00dd1\u00a8 == OP_NOTPROP)\n        {\n        print_prop(f, code + 1, \"\", \" \");\n        extra = 2;\n        }\n      else fprintf(f, \"%s\", OP_names\u00ddcode\u00dd1\u00a8\u00a8);\n      }\n    else extra = print_char(f, code+1, utf);\n    fprintf(f, \"%s\", OP_names\u00dd*code\u00a8);\n    break;\n\n    case OP_EXACTI:\n    case OP_UPTOI:\n    case OP_MINUPTOI:\n    case OP_POSUPTOI:\n    flag = \"/i\";\n    /* Fall through */\n    case OP_EXACT:\n    case OP_UPTO:\n    case OP_MINUPTO:\n    case OP_POSUPTO:\n    fprintf(f, \" %s \", flag);\n    extra = print_char(f, code + 1 + IMM2_SIZE, utf);\n    fprintf(f, \"{\");\n    if (*code != OP_EXACT && *code != OP_EXACTI) fprintf(f, \"0,\");\n    fprintf(f, \"%d}\", GET2(code,1));\n    if (*code == OP_MINUPTO || *code == OP_MINUPTOI) fprintf(f, \"?\");\n      else if (*code == OP_POSUPTO || *code == OP_POSUPTOI) fprintf(f, \"+\");\n    break;\n\n    case OP_TYPEEXACT:\n    case OP_TYPEUPTO:\n    case OP_TYPEMINUPTO:\n    case OP_TYPEPOSUPTO:\n    if (code\u00dd1 + IMM2_SIZE\u00a8 == OP_PROP || code\u00dd1 + IMM2_SIZE\u00a8 == OP_NOTPROP)\n      {\n      print_prop(f, code + IMM2_SIZE + 1, \"    \", \" \");\n      extra = 2;\n      }\n    else fprintf(f, \"    %s\", OP_names\u00ddcode\u00dd1 + IMM2_SIZE\u00a8\u00a8);\n    fprintf(f, \"{\");\n    if (*code != OP_TYPEEXACT) fprintf(f, \"0,\");\n    fprintf(f, \"%d}\", GET2(code,1));\n    if (*code == OP_TYPEMINUPTO) fprintf(f, \"?\");\n      else if (*code == OP_TYPEPOSUPTO) fprintf(f, \"+\");\n    break;\n\n    case OP_NOTI:\n    flag = \"/i\";\n    /* Fall through */\n    case OP_NOT:\n    fprintf(f, \" %s \u00dd\u00ac\", flag);\n    extra = print_char(f, code + 1, utf);\n    fprintf(f, \"\u00a8\");\n    break;\n\n    case OP_NOTSTARI:\n    case OP_NOTMINSTARI:\n    case OP_NOTPOSSTARI:\n    case OP_NOTPLUSI:\n    case OP_NOTMINPLUSI:\n    case OP_NOTPOSPLUSI:\n    case OP_NOTQUERYI:\n    case OP_NOTMINQUERYI:\n    case OP_NOTPOSQUERYI:\n    flag = \"/i\";\n    /* Fall through */\n\n    case OP_NOTSTAR:\n    case OP_NOTMINSTAR:\n    case OP_NOTPOSSTAR:\n    case OP_NOTPLUS:\n    case OP_NOTMINPLUS:\n    case OP_NOTPOSPLUS:\n    case OP_NOTQUERY:\n    case OP_NOTMINQUERY:\n    case OP_NOTPOSQUERY:\n    fprintf(f, \" %s \u00dd\u00ac\", flag);\n    extra = print_char(f, code + 1, utf);\n    fprintf(f, \"\u00a8%s\", OP_names\u00dd*code\u00a8);\n    break;\n\n    case OP_NOTEXACTI:\n    case OP_NOTUPTOI:\n    case OP_NOTMINUPTOI:\n    case OP_NOTPOSUPTOI:\n    flag = \"/i\";\n    /* Fall through */\n\n    case OP_NOTEXACT:\n    case OP_NOTUPTO:\n    case OP_NOTMINUPTO:\n    case OP_NOTPOSUPTO:\n    fprintf(f, \" %s \u00dd\u00ac\", flag);\n    extra = print_char(f, code + 1 + IMM2_SIZE, utf);\n    fprintf(f, \"\u00a8{\");\n    if (*code != OP_NOTEXACT && *code != OP_NOTEXACTI) fprintf(f, \"0,\");\n    fprintf(f, \"%d}\", GET2(code,1));\n    if (*code == OP_NOTMINUPTO || *code == OP_NOTMINUPTOI) fprintf(f, \"?\");\n      else\n    if (*code == OP_NOTPOSUPTO || *code == OP_NOTPOSUPTOI) fprintf(f, \"+\");\n    break;\n\n    case OP_RECURSE:\n    if (print_lengths) fprintf(f, \"%3d \", GET(code, 1));\n      else fprintf(f, \"    \");\n    fprintf(f, \"%s\", OP_names\u00dd*code\u00a8);\n    break;\n\n    case OP_REFI:\n    flag = \"/i\";\n    /* Fall through */\n    case OP_REF:\n    fprintf(f, \" %s \\\\%d\", flag, GET2(code,1));\n    ccode = code + OP_lengths\u00dd*code\u00a8;\n    goto CLASS_REF_REPEAT;\n\n    case OP_DNREFI:\n    flag = \"/i\";\n    /* Fall through */\n    case OP_DNREF:\n      {\n      PCRE2_SPTR entry = nametable + (GET2(code, 1) * nesize) + IMM2_SIZE;\n      fprintf(f, \" %s \\\\k<\", flag);\n      print_custring(f, entry);\n      fprintf(f, \">%d\", GET2(code, 1 + IMM2_SIZE));\n      }\n    ccode = code + OP_lengths\u00dd*code\u00a8;\n    goto CLASS_REF_REPEAT;\n\n    case OP_CALLOUT:\n    fprintf(f, \"    %s %d %d %d\", OP_names\u00dd*code\u00a8, code\u00dd1 + 2*LINK_SIZE\u00a8,\n      GET(code, 1), GET(code, 1 + LINK_SIZE));\n    break;\n\n    case OP_CALLOUT_STR:\n    c = code\u00dd1 + 4*LINK_SIZE\u00a8;\n    fprintf(f, \"    %s %c\", OP_names\u00dd*code\u00a8, c);\n    extra = GET(code, 1 + 2*LINK_SIZE);\n    print_custring_bylen(f, code + 2 + 4*LINK_SIZE, extra - 3 - 4*LINK_SIZE);\n    for (i = 0; PRIV(callout_start_delims)\u00ddi\u00a8 != 0; i++)\n      if (c == PRIV(callout_start_delims)\u00ddi\u00a8)\n        {\n        c = PRIV(callout_end_delims)\u00ddi\u00a8;\n        break;\n        }\n    fprintf(f, \"%c %d %d %d\", c, GET(code, 1 + 3*LINK_SIZE), GET(code, 1),\n      GET(code, 1 + LINK_SIZE));\n    break;\n\n    case OP_PROP:\n    case OP_NOTPROP:\n    print_prop(f, code, \"    \", \"\");\n    break;\n\n    /* OP_XCLASS cannot occur in 8-bit, non-UTF mode. However, there's no harm\n    in having this code always here, and it makes it less messy without all\n    those #ifdefs. */\n\n    case OP_CLASS:\n    case OP_NCLASS:\n    case OP_XCLASS:\n      {\n      unsigned int min, max;\n      BOOL printmap;\n      BOOL invertmap = FALSE;\n      uint8_t *map;\n      uint8_t inverted_map\u00dd32\u00a8;\n\n      fprintf(f, \"    \u00dd\");\n\n      if (*code == OP_XCLASS)\n        {\n        extra = GET(code, 1);\n        ccode = code + LINK_SIZE + 1;\n        printmap = (*ccode & XCL_MAP) != 0;\n        if ((*ccode & XCL_NOT) != 0)\n          {\n          invertmap = (*ccode & XCL_HASPROP) == 0;\n          fprintf(f, \"\u00ac\");\n          }\n        ccode++;\n        }\n      else\n        {\n        printmap = TRUE;\n        ccode = code + 1;\n        }\n\n      /* Print a bit map */\n\n      if (printmap)\n        {\n        map = (uint8_t *)ccode;\n        if (invertmap)\n          {\n          /* Using 255 \u00ac instead of ~ avoids clang sanitize warning. */\n          for (i = 0; i < 32; i++) inverted_map\u00ddi\u00a8 = 255 \u00ac map\u00ddi\u00a8;\n          map = inverted_map;\n          }\n\n        for (i = 0; i < 256; i++)\n          {\n          if ((map\u00ddi/8\u00a8 & (1u << (i&7))) != 0)\n            {\n            int j;\n            for (j = i+1; j < 256; j++)\n              if ((map\u00ddj/8\u00a8 & (1u << (j&7))) == 0) break;\n            if (i == '-' || i == '\u00a8') fprintf(f, \"\\\\\");\n            if (PRINTABLE(i)) fprintf(f, \"%c\", i);\n              else fprintf(f, \"\\\\x%02x\", i);\n            if (--j > i)\n              {\n              if (j != i + 1) fprintf(f, \"-\");\n              if (j == '-' || j == '\u00a8') fprintf(f, \"\\\\\");\n              if (PRINTABLE(j)) fprintf(f, \"%c\", j);\n                else fprintf(f, \"\\\\x%02x\", j);\n              }\n            i = j;\n            }\n          }\n        ccode += 32 / sizeof(PCRE2_UCHAR);\n        }\n\n      /* For an XCLASS there is always some additional data */\n\n      if (*code == OP_XCLASS)\n        {\n        PCRE2_UCHAR ch;\n        while ((ch = *ccode++) != XCL_END)\n          {\n          BOOL not = FALSE;\n          const char *notch = \"\";\n\n          switch(ch)\n            {\n            case XCL_NOTPROP:\n            not = TRUE;\n            notch = \"\u00ac\";\n            /* Fall through */\n\n            case XCL_PROP:\n              {\n              unsigned int ptype = *ccode++;\n              unsigned int pvalue = *ccode++;\n\n              switch(ptype)\n                {\n                case PT_PXGRAPH:\n                fprintf(f, \"\u00dd:%sgraph:\u00a8\", notch);\n                break;\n\n                case PT_PXPRINT:\n                fprintf(f, \"\u00dd:%sprint:\u00a8\", notch);\n                break;\n\n                case PT_PXPUNCT:\n                fprintf(f, \"\u00dd:%spunct:\u00a8\", notch);\n                break;\n\n                default:\n                fprintf(f, \"\\\\%c{%s}\", (not? 'P':'p'),\n                  get_ucpname(ptype, pvalue));\n                break;\n                }\n              }\n            break;\n\n            default:\n            ccode += 1 + print_char(f, ccode, utf);\n            if (ch == XCL_RANGE)\n              {\n              fprintf(f, \"-\");\n              ccode += 1 + print_char(f, ccode, utf);\n              }\n            break;\n            }\n          }\n        }\n\n      /* Indicate a non-UTF class which was created by negation */\n\n      fprintf(f, \"\u00a8%s\", (*code == OP_NCLASS)? \" (neg)\" : \"\");\n\n      /* Handle repeats after a class or a back reference */\n\n      CLASS_REF_REPEAT:\n      switch(*ccode)\n        {\n        case OP_CRSTAR:\n        case OP_CRMINSTAR:\n        case OP_CRPLUS:\n        case OP_CRMINPLUS:\n        case OP_CRQUERY:\n        case OP_CRMINQUERY:\n        case OP_CRPOSSTAR:\n        case OP_CRPOSPLUS:\n        case OP_CRPOSQUERY:\n        fprintf(f, \"%s\", OP_names\u00dd*ccode\u00a8);\n        extra += OP_lengths\u00dd*ccode\u00a8;\n        break;\n\n        case OP_CRRANGE:\n        case OP_CRMINRANGE:\n        case OP_CRPOSRANGE:\n        min = GET2(ccode,1);\n        max = GET2(ccode,1 + IMM2_SIZE);\n        if (max == 0) fprintf(f, \"{%u,}\", min);\n        else fprintf(f, \"{%u,%u}\", min, max);\n        if (*ccode == OP_CRMINRANGE) fprintf(f, \"?\");\n        else if (*ccode == OP_CRPOSRANGE) fprintf(f, \"+\");\n        extra += OP_lengths\u00dd*ccode\u00a8;\n        break;\n\n        /* Do nothing if it's not a repeat; this code stops picky compilers\n        warning about the lack of a default code path. */\n\n        default:\n        break;\n        }\n      }\n    break;\n\n    case OP_MARK:\n    case OP_COMMIT_ARG:\n    case OP_PRUNE_ARG:\n    case OP_SKIP_ARG:\n    case OP_THEN_ARG:\n    fprintf(f, \"    %s \", OP_names\u00dd*code\u00a8);\n    print_custring_bylen(f, code + 2, code\u00dd1\u00a8);\n    extra += code\u00dd1\u00a8;\n    break;\n\n    case OP_THEN:\n    fprintf(f, \"    %s\", OP_names\u00dd*code\u00a8);\n    break;\n\n    case OP_CIRCM:\n    case OP_DOLLM:\n    flag = \"/m\";\n    /* Fall through */\n\n    /* Anything else is just an item with no data, but possibly a flag. */\n\n    default:\n    fprintf(f, \" %s %s\", flag, OP_names\u00dd*code\u00a8);\n    break;\n    }\n\n  code += OP_lengths\u00dd*code\u00a8 + extra;\n  fprintf(f, \"\\n\");\n  }\n}\n\n/* End of pcre2_printint.c */\n/*autoconv-0001 C:\\projects\\pcre2-10.35\\src\\pcre2_printint.c converted to PRINTIN2*/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SCRIPTR2": {"ttr": 6147, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "\n/*************************************************\n*      Perl-Compatible Regular Expressions       *\n*************************************************/\n\n/* PCRE is a library of functions to support regular expressions whose syntax\nand semantics are as close as possible to those of the Perl 5 language.\n\n                       Written by Philip Hazel\n     Original API code Copyright (c) 1997-2012 University of Cambridge\n          New API code Copyright (c) 2016-2018 University of Cambridge\n\n-----------------------------------------------------------------------------\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n\n    * Redistributions of source code must retain the above copyright notice,\n      this list of conditions and the following disclaimer.\n\n    * Redistributions in binary form must reproduce the above copyright\n      notice, this list of conditions and the following disclaimer in the\n      documentation and/or other materials provided with the distribution.\n\n    * Neither the name of the University of Cambridge nor the names of its\n      contributors may be used to endorse or promote products derived from\n      this software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\nAND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\nIMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\nARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\nLIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\nCONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\nSUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\nINTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\nCONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\nARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\nPOSSIBILITY OF SUCH DAMAGE.\n-----------------------------------------------------------------------------\n*/\n\n/* This module contains the function for checking a script run. */\n\n#ifdef HAVE_CONFIG_H\n#include \"CONFIG.h\"\n#endif\n\n#include \"INTERNA2.h\"\n\n\n/*************************************************\n*                Check script run                *\n*************************************************/\n\n/* A script run is conceptually a sequence of characters all in the same\nUnicode script. However, it isn't quite that simple. There are special rules\nfor scripts that are commonly used together, and also special rules for digits.\nThis function implements the appropriate checks, which is possible only when\nPCRE2 is compiled with Unicode support. The function returns TRUE if there is\nno Unicode support; however, it should never be called in that circumstance\nbecause an error is given by pcre2_compile() if a script run is called for in a\nversion of PCRE2 compiled without Unicode support.\n\nArguments:\n  pgr       point to the first character\n  endptr    point after the last character\n  utf       TRUE if in UTF mode\n\nReturns:    TRUE if this is a valid script run\n*/\n\n/* These dummy values must be less than the negation of the largest offset in\nthe PRIV(ucd_script_sets) vector, which is held in a 16-bit field in UCD\nrecords (and is only likely to be a few hundred). */\n\n#define SCRIPT_UNSET        (-99999)\n#define SCRIPT_HANPENDING   (-99998)\n#define SCRIPT_HANHIRAKATA  (-99997)\n#define SCRIPT_HANBOPOMOFO  (-99996)\n#define SCRIPT_HANHANGUL    (-99995)\n#define SCRIPT_LIST         (-99994)\n\n#define INTERSECTION_LIST_SIZE 50\n\nBOOL\nPRIV(script_run)(PCRE2_SPTR ptr, PCRE2_SPTR endptr, BOOL utf)\n{\n#ifdef SUPPORT_UNICODE\nint require_script = SCRIPT_UNSET;\nuint8_t intersection_list\u00ddINTERSECTION_LIST_SIZE\u00a8;\nconst uint8_t *require_list = NULL;\nuint32_t require_digitset = 0;\nuint32_t c;\n\n#if PCRE2_CODE_UNIT_WIDTH == 32\n(void)utf;    /* Avoid compiler warning */\n#endif\n\n/* Any string containing fewer than 2 characters is a valid script run. */\n\nif (ptr >= endptr) return TRUE;\nGETCHARINCTEST(c, ptr);\nif (ptr >= endptr) return TRUE;\n\n/* Scan strings of two or more characters, checking the Unicode characteristics\nof each code point. We make use of the Script Extensions property. There is\nspecial code for scripts that can be combined with characters from the Han\nChinese script. This may be used in conjunction with four other scripts in\nthese combinations:\n\n. Han with Hiragana and Katakana is allowed (for Japanese).\n. Han with Bopomofo is allowed (for Taiwanese Mandarin).\n. Han with Hangul is allowed (for Korean).\n\nIf the first significant character's script is one of the four, the required\nscript type is immediately known. However, if the first significant\ncharacter's script is Han, we have to keep checking for a non-Han character.\nHence the SCRIPT_HANPENDING state. */\n\nfor (;;)\n  {\n  const ucd_record *ucd = GET_UCD(c);\n  int32_t scriptx = ucd->scriptx;\n\n  /* If the script extension is Unknown, the string is not a valid script run.\n  Such characters can only form script runs of length one. */\n\n  if (scriptx == ucp_Unknown) return FALSE;\n\n  /* A character whose script extension is Inherited is always accepted with\n  any script, and plays no further part in this testing. A character whose\n  script is Common is always accepted, but must still be tested for a digit\n  below. The scriptx value at this point is non-zero, because zero is\n  ucp_Unknown, tested for above. */\n\n  if (scriptx != ucp_Inherited)\n    {\n    if (scriptx != ucp_Common)\n      {\n      /* If the script extension value is positive, the character is not a mark\n      that can be used with many scripts. In the simple case we either set or\n      compare with the required script. However, handling the scripts that can\n      combine with Han are more complicated, as is the case when the previous\n      characters have been man-script marks. */\n\n      if (scriptx > 0)\n        {\n        switch(require_script)\n          {\n          /* Either the first significant character (require_script unset) or\n          after only Han characters. */\n\n          case SCRIPT_UNSET:\n          case SCRIPT_HANPENDING:\n          switch(scriptx)\n            {\n            case ucp_Han:\n            require_script = SCRIPT_HANPENDING;\n            break;\n\n            case ucp_Hiragana:\n            case ucp_Katakana:\n            require_script = SCRIPT_HANHIRAKATA;\n            break;\n\n            case ucp_Bopomofo:\n            require_script = SCRIPT_HANBOPOMOFO;\n            break;\n\n            case ucp_Hangul:\n            require_script = SCRIPT_HANHANGUL;\n            break;\n\n            /* Not a Han-related script. If expecting one, fail. Otherise set\n            the requirement to this script. */\n\n            default:\n            if (require_script == SCRIPT_HANPENDING) return FALSE;\n            require_script = scriptx;\n            break;\n            }\n          break;\n\n          /* Previously encountered one of the \"with Han\" scripts. Check that\n          this character is appropriate. */\n\n          case SCRIPT_HANHIRAKATA:\n          if (scriptx != ucp_Han && scriptx != ucp_Hiragana &&\n              scriptx != ucp_Katakana)\n            return FALSE;\n          break;\n\n          case SCRIPT_HANBOPOMOFO:\n          if (scriptx != ucp_Han && scriptx != ucp_Bopomofo) return FALSE;\n          break;\n\n          case SCRIPT_HANHANGUL:\n          if (scriptx != ucp_Han && scriptx != ucp_Hangul) return FALSE;\n          break;\n\n          /* We have a list of scripts to check that is derived from one or\n          more previous characters. This is either one of the lists in\n          ucd_script_sets\u00dd\u00a8 (for one previous character) or the intersection of\n          several lists for multiple characters. */\n\n          case SCRIPT_LIST:\n            {\n            const uint8_t *list;\n            for (list = require_list; *list != 0; list++)\n              {\n              if (*list == scriptx) break;\n              }\n            if (*list == 0) return FALSE;\n            }\n\n          /* The rest of the string must be in this script, but we have to\n          allow for the Han complications. */\n\n          switch(scriptx)\n            {\n            case ucp_Han:\n            require_script = SCRIPT_HANPENDING;\n            break;\n\n            case ucp_Hiragana:\n            case ucp_Katakana:\n            require_script = SCRIPT_HANHIRAKATA;\n            break;\n\n            case ucp_Bopomofo:\n            require_script = SCRIPT_HANBOPOMOFO;\n            break;\n\n            case ucp_Hangul:\n            require_script = SCRIPT_HANHANGUL;\n            break;\n\n            default:\n            require_script = scriptx;\n            break;\n            }\n          break;\n\n          /* This is the easy case when a single script is required. */\n\n          default:\n          if (scriptx != require_script) return FALSE;\n          break;\n          }\n        }  /* End of handing positive scriptx */\n\n      /* If scriptx is negative, this character is a mark-type character that\n      has a list of permitted scripts. */\n\n      else\n        {\n        uint32_t chspecial;\n        const uint8_t *clist, *rlist;\n        const uint8_t *list = PRIV(ucd_script_sets) - scriptx;\n\n        switch(require_script)\n          {\n          case SCRIPT_UNSET:\n          require_list = PRIV(ucd_script_sets) - scriptx;\n          require_script = SCRIPT_LIST;\n          break;\n\n          /* An inspection of the Unicode 11.0.0 files shows that there are the\n          following types of Script Extension list that involve the Han,\n          Bopomofo, Hiragana, Katakana, and Hangul scripts:\n\n          . Bopomofo + Han\n          . Han + Hiragana + Katakana\n          . Hiragana + Katakana\n          . Bopopmofo + Hangul + Han + Hiragana + Katakana\n\n          The following code tries to make sense of this. */\n\n#define FOUND_BOPOMOFO 1\n#define FOUND_HIRAGANA 2\n#define FOUND_KATAKANA 4\n#define FOUND_HANGUL   8\n\n          case SCRIPT_HANPENDING:\n          chspecial = 0;\n          for (; *list != 0; list++)\n            {\n            switch (*list)\n              {\n              case ucp_Bopomofo: chspecial |= FOUND_BOPOMOFO; break;\n              case ucp_Hiragana: chspecial |= FOUND_HIRAGANA; break;\n              case ucp_Katakana: chspecial |= FOUND_KATAKANA; break;\n              case ucp_Hangul:   chspecial |= FOUND_HANGUL; break;\n              default: break;\n              }\n            }\n\n           if (chspecial == 0) return FALSE;\n\n           if (chspecial == FOUND_BOPOMOFO)\n             {\n             require_script = SCRIPT_HANBOPOMOFO;\n             }\n           else if (chspecial == (FOUND_HIRAGANA|FOUND_KATAKANA))\n             {\n             require_script = SCRIPT_HANHIRAKATA;\n             }\n\n          /* Otherwise it must be allowed with all of them, so remain in\n          the pending state. */\n\n          break;\n\n          case SCRIPT_HANHIRAKATA:\n          for (; *list != 0; list++)\n            {\n            if (*list == ucp_Hiragana || *list == ucp_Katakana) break;\n            }\n          if (*list == 0) return FALSE;\n          break;\n\n          case SCRIPT_HANBOPOMOFO:\n          for (; *list != 0; list++)\n            {\n            if (*list == ucp_Bopomofo) break;\n            }\n          if (*list == 0) return FALSE;\n          break;\n\n          case SCRIPT_HANHANGUL:\n          for (; *list != 0; list++)\n            {\n            if (*list == ucp_Hangul) break;\n            }\n          if (*list == 0) return FALSE;\n          break;\n\n          /* Previously encountered one or more characters that are allowed\n          with a list of scripts. Build the intersection of the required list\n          with this character's list in intersection_list\u00dd\u00a8. This code is\n          written so that it still works OK if the required list is already in\n          that vector. */\n\n          case SCRIPT_LIST:\n            {\n            int i = 0;\n            for (rlist = require_list; *rlist != 0; rlist++)\n              {\n              for (clist = list; *clist != 0; clist++)\n                {\n                if (*rlist == *clist)\n                  {\n                  intersection_list\u00ddi++\u00a8 = *rlist;\n                  break;\n                  }\n                }\n              }\n            if (i == 0) return FALSE;  /* No scripts in common */\n\n            /* If there's just one script in common, we can set it as the\n            unique required script. Otherwise, terminate the intersection list\n            and make it the required list. */\n\n            if (i == 1)\n              {\n              require_script = intersection_list\u00dd0\u00a8;\n              }\n            else\n              {\n              intersection_list\u00ddi\u00a8 = 0;\n              require_list = intersection_list;\n              }\n            }\n          break;\n\n          /* The previously set required script is a single script, not\n          Han-related. Check that it is in this character's list. */\n\n          default:\n          for (; *list != 0; list++)\n            {\n            if (*list == require_script) break;\n            }\n          if (*list == 0) return FALSE;\n          break;\n          }\n        }  /* End of handling negative scriptx */\n      }    /* End of checking non-Common character */\n\n    /* The character is in an acceptable script. We must now ensure that all\n    decimal digits in the string come from the same set. Some scripts (e.g.\n    Common, Arabic) have more than one set of decimal digits. This code does\n    not allow mixing sets, even within the same script. The vector called\n    PRIV(ucd_digit_sets)\u00dd\u00a8 contains, in its first element, the number of\n    following elements, and then, in ascending order, the code points of the\n    '9' characters in every set of 10 digits. Each set is identified by the\n    offset in the vector of its '9' character. An initial check of the first\n    value picks up ASCII digits quickly. Otherwise, a binary chop is used. */\n\n    if (ucd->chartype == ucp_Nd)\n      {\n      uint32_t digitset;\n\n      if (c <= PRIV(ucd_digit_sets)\u00dd1\u00a8) digitset = 1; else\n        {\n        int mid;\n        int bot = 1;\n        int top = PRIV(ucd_digit_sets)\u00dd0\u00a8;\n        for (;;)\n          {\n          if (top <= bot + 1)    /* <= rather than == is paranoia */\n            {\n            digitset = top;\n            break;\n            }\n          mid = (top + bot) / 2;\n          if (c <= PRIV(ucd_digit_sets)\u00ddmid\u00a8) top = mid; else bot = mid;\n          }\n        }\n\n      /* A required value of 0 means \"unset\". */\n\n      if (require_digitset == 0) require_digitset = digitset;\n        else if (digitset != require_digitset) return FALSE;\n      }   /* End digit handling */\n    }     /* End checking non-Inherited character */\n\n  /* If we haven't yet got to the end, pick up the next character. */\n\n  if (ptr >= endptr) return TRUE;\n  GETCHARINCTEST(c, ptr);\n  }  /* End checking loop */\n\n#else   /* NOT SUPPORT_UNICODE */\n(void)ptr;\n(void)endptr;\n(void)utf;\nreturn TRUE;\n#endif  /* SUPPORT_UNICODE */\n}\n\n/* End of pcre2_script_run.c */\n/*autoconv-0001 C:\\projects\\pcre2-10.35\\src\\pcre2_script_run.c converted to SCRIPTR2*/\n/*autoconv-0011 SCRIPTR2 line: 44 config.h replaced by CONFIG.h*/\n/*autoconv-0011 SCRIPTR2 line: 47 pcre2_internal.h replaced by INTERNA2.h*/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SERIALI2": {"ttr": 2049, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "\n/*************************************************\n*      Perl-Compatible Regular Expressions       *\n*************************************************/\n\n/* PCRE is a library of functions to support regular expressions whose syntax\nand semantics are as close as possible to those of the Perl 5 language.\n\n                       Written by Philip Hazel\n     Original API code Copyright (c) 1997-2012 University of Cambridge\n          New API code Copyright (c) 2016-2020 University of Cambridge\n\n-----------------------------------------------------------------------------\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n\n    * Redistributions of source code must retain the above copyright notice,\n      this list of conditions and the following disclaimer.\n\n    * Redistributions in binary form must reproduce the above copyright\n      notice, this list of conditions and the following disclaimer in the\n      documentation and/or other materials provided with the distribution.\n\n    * Neither the name of the University of Cambridge nor the names of its\n      contributors may be used to endorse or promote products derived from\n      this software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\nAND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\nIMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\nARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\nLIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\nCONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\nSUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\nINTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\nCONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\nARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\nPOSSIBILITY OF SUCH DAMAGE.\n-----------------------------------------------------------------------------\n*/\n\n/* This module contains functions for serializing and deserializing\na sequence of compiled codes. */\n\n\n#ifdef HAVE_CONFIG_H\n#include \"CONFIG.h\"\n#endif\n\n\n#include \"INTERNA2.h\"\n\n/* Magic number to provide a small check against being handed junk. */\n\n#define SERIALIZED_DATA_MAGIC 0x50523253u\n\n/* Deserialization is limited to the current PCRE version and\ncharacter width. */\n\n#define SERIALIZED_DATA_VERSION \\\n  ((PCRE2_MAJOR) | ((PCRE2_MINOR) << 16))\n\n#define SERIALIZED_DATA_CONFIG \\\n  (sizeof(PCRE2_UCHAR) | ((sizeof(void*)) << 8) | ((sizeof(PCRE2_SIZE)) << 16))\n\n\n\n/*************************************************\n*           Serialize compiled patterns          *\n*************************************************/\n\nPCRE2_EXP_DEFN int32_t PCRE2_CALL_CONVENTION\npcre2_serialize_encode(const pcre2_code **codes, int32_t number_of_codes,\n   uint8_t **serialized_bytes, PCRE2_SIZE *serialized_size,\n   pcre2_general_context *gcontext)\n{\nuint8_t *bytes;\nuint8_t *dst_bytes;\nint32_t i;\nPCRE2_SIZE total_size;\nconst pcre2_real_code *re;\nconst uint8_t *tables;\npcre2_serialized_data *data;\n\nconst pcre2_memctl *memctl = (gcontext != NULL) ?\n  &gcontext->memctl : &PRIV(default_compile_context).memctl;\n\nif (codes == NULL || serialized_bytes == NULL || serialized_size == NULL)\n  return PCRE2_ERROR_NULL;\n\nif (number_of_codes <= 0) return PCRE2_ERROR_BADDATA;\n\n/* Compute total size. */\ntotal_size = sizeof(pcre2_serialized_data) + TABLES_LENGTH;\ntables = NULL;\n\nfor (i = 0; i < number_of_codes; i++)\n  {\n  if (codes\u00ddi\u00a8 == NULL) return PCRE2_ERROR_NULL;\n  re = (const pcre2_real_code *)(codes\u00ddi\u00a8);\n  if (re->magic_number != MAGIC_NUMBER) return PCRE2_ERROR_BADMAGIC;\n  if (tables == NULL)\n    tables = re->tables;\n  else if (tables != re->tables)\n    return PCRE2_ERROR_MIXEDTABLES;\n  total_size += re->blocksize;\n  }\n\n/* Initialize the byte stream. */\nbytes = memctl->malloc(total_size + sizeof(pcre2_memctl), memctl->memory_data);\nif (bytes == NULL) return PCRE2_ERROR_NOMEMORY;\n\n/* The controller is stored as a hidden parameter. */\nmemcpy(bytes, memctl, sizeof(pcre2_memctl));\nbytes += sizeof(pcre2_memctl);\n\ndata = (pcre2_serialized_data *)bytes;\ndata->magic = SERIALIZED_DATA_MAGIC;\ndata->version = SERIALIZED_DATA_VERSION;\ndata->config = SERIALIZED_DATA_CONFIG;\ndata->number_of_codes = number_of_codes;\n\n/* Copy all compiled code data. */\ndst_bytes = bytes + sizeof(pcre2_serialized_data);\nmemcpy(dst_bytes, tables, TABLES_LENGTH);\ndst_bytes += TABLES_LENGTH;\n\nfor (i = 0; i < number_of_codes; i++)\n  {\n  re = (const pcre2_real_code *)(codes\u00ddi\u00a8);\n  (void)memcpy(dst_bytes, (char *)re, re->blocksize);\n\n  /* Certain fields in the compiled code block are re-set during\n  deserialization. In order to ensure that the serialized data stream is always\n  the same for the same pattern, set them to zero here. We can't assume the\n  copy of the pattern is correctly aligned for accessing the fields as part of\n  a structure. Note the use of sizeof(void *) in the second of these, to\n  specify the size of a pointer. If sizeof(uint8_t *) is used (tables is a\n  pointer to uint8_t), gcc gives a warning because the first argument is also a\n  pointer to uint8_t. Casting the first argument to (void *) can stop this, but\n  it didn't stop Coverity giving the same complaint. */\n\n  (void)memset(dst_bytes + offsetof(pcre2_real_code, memctl), 0,\n    sizeof(pcre2_memctl));\n  (void)memset(dst_bytes + offsetof(pcre2_real_code, tables), 0,\n    sizeof(void *));\n  (void)memset(dst_bytes + offsetof(pcre2_real_code, executable_jit), 0,\n    sizeof(void *));\n\n  dst_bytes += re->blocksize;\n  }\n\n*serialized_bytes = bytes;\n*serialized_size = total_size;\nreturn number_of_codes;\n}\n\n\n/*************************************************\n*          Deserialize compiled patterns         *\n*************************************************/\n\nPCRE2_EXP_DEFN int32_t PCRE2_CALL_CONVENTION\npcre2_serialize_decode(pcre2_code **codes, int32_t number_of_codes,\n   const uint8_t *bytes, pcre2_general_context *gcontext)\n{\nconst pcre2_serialized_data *data = (const pcre2_serialized_data *)bytes;\nconst pcre2_memctl *memctl = (gcontext != NULL) ?\n  &gcontext->memctl : &PRIV(default_compile_context).memctl;\n\nconst uint8_t *src_bytes;\npcre2_real_code *dst_re;\nuint8_t *tables;\nint32_t i, j;\n\n/* Sanity checks. */\n\nif (data == NULL || codes == NULL) return PCRE2_ERROR_NULL;\nif (number_of_codes <= 0) return PCRE2_ERROR_BADDATA;\nif (data->number_of_codes <= 0) return PCRE2_ERROR_BADSERIALIZEDDATA;\nif (data->magic != SERIALIZED_DATA_MAGIC) return PCRE2_ERROR_BADMAGIC;\nif (data->version != SERIALIZED_DATA_VERSION) return PCRE2_ERROR_BADMODE;\nif (data->config != SERIALIZED_DATA_CONFIG) return PCRE2_ERROR_BADMODE;\n\nif (number_of_codes > data->number_of_codes)\n  number_of_codes = data->number_of_codes;\n\nsrc_bytes = bytes + sizeof(pcre2_serialized_data);\n\n/* Decode tables. The reference count for the tables is stored immediately\nfollowing them. */\n\ntables = memctl->malloc(TABLES_LENGTH + sizeof(PCRE2_SIZE), memctl->memory_data);\nif (tables == NULL) return PCRE2_ERROR_NOMEMORY;\n\nmemcpy(tables, src_bytes, TABLES_LENGTH);\n*(PCRE2_SIZE *)(tables + TABLES_LENGTH) = number_of_codes;\nsrc_bytes += TABLES_LENGTH;\n\n/* Decode the byte stream. We must not try to read the size from the compiled\ncode block in the stream, because it might be unaligned, which causes errors on\nhardware such as Sparc-64 that doesn't like unaligned memory accesses. The type\nof the blocksize field is given its own name to ensure that it is the same here\nas in the block. */\n\nfor (i = 0; i < number_of_codes; i++)\n  {\n  CODE_BLOCKSIZE_TYPE blocksize;\n  memcpy(&blocksize, src_bytes + offsetof(pcre2_real_code, blocksize),\n    sizeof(CODE_BLOCKSIZE_TYPE));\n  if (blocksize <= sizeof(pcre2_real_code))\n    return PCRE2_ERROR_BADSERIALIZEDDATA;\n\n  /* The allocator provided by gcontext replaces the original one. */\n\n  dst_re = (pcre2_real_code *)PRIV(memctl_malloc)(blocksize,\n    (pcre2_memctl *)gcontext);\n  if (dst_re == NULL)\n    {\n    memctl->free(tables, memctl->memory_data);\n    for (j = 0; j < i; j++)\n      {\n      memctl->free(codes\u00ddj\u00a8, memctl->memory_data);\n      codes\u00ddj\u00a8 = NULL;\n      }\n    return PCRE2_ERROR_NOMEMORY;\n    }\n\n  /* The new allocator must be preserved. */\n\n  memcpy(((uint8_t *)dst_re) + sizeof(pcre2_memctl),\n    src_bytes + sizeof(pcre2_memctl), blocksize - sizeof(pcre2_memctl));\n  if (dst_re->magic_number != MAGIC_NUMBER ||\n      dst_re->name_entry_size > MAX_NAME_SIZE + IMM2_SIZE + 1 ||\n      dst_re->name_count > MAX_NAME_COUNT)\n    {\n    memctl->free(dst_re, memctl->memory_data);\n    return PCRE2_ERROR_BADSERIALIZEDDATA;\n    }\n\n  /* At the moment only one table is supported. */\n\n  dst_re->tables = tables;\n  dst_re->executable_jit = NULL;\n  dst_re->flags |= PCRE2_DEREF_TABLES;\n\n  codes\u00ddi\u00a8 = dst_re;\n  src_bytes += blocksize;\n  }\n\nreturn number_of_codes;\n}\n\n\n/*************************************************\n*    Get the number of serialized patterns       *\n*************************************************/\n\nPCRE2_EXP_DEFN int32_t PCRE2_CALL_CONVENTION\npcre2_serialize_get_number_of_codes(const uint8_t *bytes)\n{\nconst pcre2_serialized_data *data = (const pcre2_serialized_data *)bytes;\n\nif (data == NULL) return PCRE2_ERROR_NULL;\nif (data->magic != SERIALIZED_DATA_MAGIC) return PCRE2_ERROR_BADMAGIC;\nif (data->version != SERIALIZED_DATA_VERSION) return PCRE2_ERROR_BADMODE;\nif (data->config != SERIALIZED_DATA_CONFIG) return PCRE2_ERROR_BADMODE;\n\nreturn data->number_of_codes;\n}\n\n\n/*************************************************\n*            Free the allocated stream           *\n*************************************************/\n\nPCRE2_EXP_DEFN void PCRE2_CALL_CONVENTION\npcre2_serialize_free(uint8_t *bytes)\n{\nif (bytes != NULL)\n  {\n  pcre2_memctl *memctl = (pcre2_memctl *)(bytes - sizeof(pcre2_memctl));\n  memctl->free(memctl, memctl->memory_data);\n  }\n}\n\n/* End of pcre2_serialize.c */\n/*autoconv-0001 C:\\projects\\pcre2-10.35\\src\\pcre2_serialize.c converted to SERIALI2*/\n/*autoconv-0011 SERIALI2 line: 46 config.h replaced by CONFIG.h*/\n/*autoconv-0011 SERIALI2 line: 50 pcre2_internal.h replaced by INTERNA2.h*/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "STRINGU2": {"ttr": 3075, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "\n/*************************************************\n*      Perl-Compatible Regular Expressions       *\n*************************************************/\n\n/* PCRE is a library of functions to support regular expressions whose syntax\nand semantics are as close as possible to those of the Perl 5 language.\n\n                       Written by Philip Hazel\n     Original API code Copyright (c) 1997-2012 University of Cambridge\n          New API code Copyright (c) 2018 University of Cambridge\n\n-----------------------------------------------------------------------------\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n\n    * Redistributions of source code must retain the above copyright notice,\n      this list of conditions and the following disclaimer.\n\n    * Redistributions in binary form must reproduce the above copyright\n      notice, this list of conditions and the following disclaimer in the\n      documentation and/or other materials provided with the distribution.\n\n    * Neither the name of the University of Cambridge nor the names of its\n      contributors may be used to endorse or promote products derived from\n      this software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\nAND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\nIMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\nARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\nLIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\nCONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\nSUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\nINTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\nCONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\nARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\nPOSSIBILITY OF SUCH DAMAGE.\n-----------------------------------------------------------------------------\n*/\n\n/* This module contains internal functions for comparing and finding the length\nof strings. These are used instead of strcmp() etc because the standard\nfunctions work only on 8-bit data. */\n\n\n#ifdef HAVE_CONFIG_H\n#include \"CONFIG.h\"\n#endif\n\n#include \"INTERNA2.h\"\n\n\n/*************************************************\n*    Emulated memmove() for systems without it   *\n*************************************************/\n\n/* This function can make use of bcopy() if it is available. Otherwise do it by\nsteam, as there some non-Unix environments that lack both memmove() and\nbcopy(). */\n\n#if !defined(VPCOMPAT) && !defined(HAVE_MEMMOVE)\nvoid *\nPRIV(memmove)(void *d, const void *s, size_t n)\n{\n#ifdef HAVE_BCOPY\nbcopy(s, d, n);\nreturn d;\n#else\nsize_t i;\nunsigned char *dest = (unsigned char *)d;\nconst unsigned char *src = (const unsigned char *)s;\nif (dest > src)\n  {\n  dest += n;\n  src += n;\n  for (i = 0; i < n; ++i) *(--dest) = *(--src);\n  return (void *)dest;\n  }\nelse\n  {\n  for (i = 0; i < n; ++i) *dest++ = *src++;\n  return (void *)(dest - n);\n  }\n#endif   /* not HAVE_BCOPY */\n}\n#endif   /* not VPCOMPAT && not HAVE_MEMMOVE */\n\n\n/*************************************************\n*    Compare two zero-terminated PCRE2 strings   *\n*************************************************/\n\n/*\nArguments:\n  str1        first string\n  str2        second string\n\nReturns:      0, 1, or -1\n*/\n\nint\nPRIV(strcmp)(PCRE2_SPTR str1, PCRE2_SPTR str2)\n{\nPCRE2_UCHAR c1, c2;\nwhile (*str1 != '\\0' || *str2 != '\\0')\n  {\n  c1 = *str1++;\n  c2 = *str2++;\n  if (c1 != c2) return ((c1 > c2) << 1) - 1;\n  }\nreturn 0;\n}\n\n\n/*************************************************\n*  Compare zero-terminated PCRE2 & 8-bit strings *\n*************************************************/\n\n/* As the 8-bit string is almost always a literal, its type is specified as\nconst char *.\n\nArguments:\n  str1        first string\n  str2        second string\n\nReturns:      0, 1, or -1\n*/\n\nint\nPRIV(strcmp_c8)(PCRE2_SPTR str1, const char *str2)\n{\nPCRE2_UCHAR c1, c2;\nwhile (*str1 != '\\0' || *str2 != '\\0')\n  {\n  c1 = *str1++;\n  c2 = *str2++;\n  if (c1 != c2) return ((c1 > c2) << 1) - 1;\n  }\nreturn 0;\n}\n\n\n/*************************************************\n*    Compare two PCRE2 strings, given a length   *\n*************************************************/\n\n/*\nArguments:\n  str1        first string\n  str2        second string\n  len         the length\n\nReturns:      0, 1, or -1\n*/\n\nint\nPRIV(strncmp)(PCRE2_SPTR str1, PCRE2_SPTR str2, size_t len)\n{\nPCRE2_UCHAR c1, c2;\nfor (; len > 0; len--)\n  {\n  c1 = *str1++;\n  c2 = *str2++;\n  if (c1 != c2) return ((c1 > c2) << 1) - 1;\n  }\nreturn 0;\n}\n\n\n/*************************************************\n* Compare PCRE2 string to 8-bit string by length *\n*************************************************/\n\n/* As the 8-bit string is almost always a literal, its type is specified as\nconst char *.\n\nArguments:\n  str1        first string\n  str2        second string\n  len         the length\n\nReturns:      0, 1, or -1\n*/\n\nint\nPRIV(strncmp_c8)(PCRE2_SPTR str1, const char *str2, size_t len)\n{\nPCRE2_UCHAR c1, c2;\nfor (; len > 0; len--)\n  {\n  c1 = *str1++;\n  c2 = *str2++;\n  if (c1 != c2) return ((c1 > c2) << 1) - 1;\n  }\nreturn 0;\n}\n\n\n/*************************************************\n*        Find the length of a PCRE2 string       *\n*************************************************/\n\n/*\nArgument:    the string\nReturns:     the length\n*/\n\nPCRE2_SIZE\nPRIV(strlen)(PCRE2_SPTR str)\n{\nPCRE2_SIZE c = 0;\nwhile (*str++ != 0) c++;\nreturn c;\n}\n\n\n/*************************************************\n* Copy 8-bit 0-terminated string to PCRE2 string *\n*************************************************/\n\n/* Arguments:\n  str1     buffer to receive the string\n  str2     8-bit string to be copied\n\nReturns:   the number of code units used (excluding trailing zero)\n*/\n\nPCRE2_SIZE\nPRIV(strcpy_c8)(PCRE2_UCHAR *str1, const char *str2)\n{\nPCRE2_UCHAR *t = str1;\nwhile (*str2 != 0) *t++ = *str2++;\n*t = 0;\nreturn t - str1;\n}\n\n/* End of pcre2_string_utils.c */\n/*autoconv-0001 C:\\projects\\pcre2-10.35\\src\\pcre2_string_utils.c converted to STRINGU2*/\n/*autoconv-0011 STRINGU2 line: 47 config.h replaced by CONFIG.h*/\n/*autoconv-0011 STRINGU2 line: 50 pcre2_internal.h replaced by INTERNA2.h*/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "STUDY2": {"ttr": 2563, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "\n/*************************************************\n*      Perl-Compatible Regular Expressions       *\n*************************************************/\n\n/* PCRE is a library of functions to support regular expressions whose syntax\nand semantics are as close as possible to those of the Perl 5 language.\n\n                       Written by Philip Hazel\n     Original API code Copyright (c) 1997-2012 University of Cambridge\n          New API code Copyright (c) 2016-2020 University of Cambridge\n\n-----------------------------------------------------------------------------\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n\n    * Redistributions of source code must retain the above copyright notice,\n      this list of conditions and the following disclaimer.\n\n    * Redistributions in binary form must reproduce the above copyright\n      notice, this list of conditions and the following disclaimer in the\n      documentation and/or other materials provided with the distribution.\n\n    * Neither the name of the University of Cambridge nor the names of its\n      contributors may be used to endorse or promote products derived from\n      this software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\nAND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\nIMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\nARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\nLIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\nCONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\nSUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\nINTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\nCONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\nARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\nPOSSIBILITY OF SUCH DAMAGE.\n-----------------------------------------------------------------------------\n*/\n\n/* This module contains functions for scanning a compiled pattern and\ncollecting data (e.g. minimum matching length). */\n\n\n#ifdef HAVE_CONFIG_H\n#include \"CONFIG.h\"\n#endif\n\n#include \"INTERNA2.h\"\n\n/* The maximum remembered capturing brackets minimum. */\n\n#define MAX_CACHE_BACKREF 128\n\n/* Set a bit in the starting code unit bit map. */\n\n#define SET_BIT(c) re->start_bitmap\u00dd(c)/8\u00a8 |= (1u << ((c)&7))\n\n/* Returns from set_start_bits() */\n\nenum { SSB_FAIL, SSB_DONE, SSB_CONTINUE, SSB_UNKNOWN, SSB_TOODEEP };\n\n\n/*************************************************\n*   Find the minimum subject length for a group  *\n*************************************************/\n\n/* Scan a parenthesized group and compute the minimum length of subject that\nis needed to match it. This is a lower bound; it does not mean there is a\nstring of that length that matches. In UTF mode, the result is in characters\nrather than code units. The field in a compiled pattern for storing the minimum\nlength is 16-bits long (on the grounds that anything longer than that is\npathological), so we give up when we reach that amount. This also means that\ninteger overflow for really crazy patterns cannot happen.\n\nBackreference minimum lengths are cached to speed up multiple references. This\nfunction is called only when the highest back reference in the pattern is less\nthan or equal to MAX_CACHE_BACKREF, which is one less than the size of the\ncaching vector. The zeroth element contains the number of the highest set\nvalue.\n\nArguments:\n  re              compiled pattern block\n  code            pointer to start of group (the bracket)\n  startcode       pointer to start of the whole pattern's code\n  utf             UTF flag\n  recurses        chain of recurse_check to catch mutual recursion\n  countptr        pointer to call count (to catch over complexity)\n  backref_cache   vector for caching back references.\n\nThis function is no longer called when the pattern contains (*ACCEPT); however,\nthe old code for returning -1 is retained, just in case.\n\nReturns:   the minimum length\n           -1 \\C in UTF-8 mode\n              or (*ACCEPT)\n              or pattern too complicated\n           -2 internal error (missing capturing bracket)\n           -3 internal error (opcode not listed)\n*/\n\nstatic int\nfind_minlength(const pcre2_real_code *re, PCRE2_SPTR code,\n  PCRE2_SPTR startcode, BOOL utf, recurse_check *recurses, int *countptr,\n  int *backref_cache)\n{\nint length = -1;\nint branchlength = 0;\nint prev_cap_recno = -1;\nint prev_cap_d = 0;\nint prev_recurse_recno = -1;\nint prev_recurse_d = 0;\nuint32_t once_fudge = 0;\nBOOL had_recurse = FALSE;\nBOOL dupcapused = (re->flags & PCRE2_DUPCAPUSED) != 0;\nPCRE2_SPTR nextbranch = code + GET(code, 1);\nPCRE2_UCHAR *cc = (PCRE2_UCHAR *)code + 1 + LINK_SIZE;\nrecurse_check this_recurse;\n\n/* If this is a \"could be empty\" group, its minimum length is 0. */\n\nif (*code >= OP_SBRA && *code <= OP_SCOND) return 0;\n\n/* Skip over capturing bracket number */\n\nif (*code == OP_CBRA || *code == OP_CBRAPOS) cc += IMM2_SIZE;\n\n/* A large and/or complex regex can take too long to process. */\n\nif ((*countptr)++ > 1000) return -1;\n\n/* Scan along the opcodes for this branch. If we get to the end of the branch,\ncheck the length against that of the other branches. If the accumulated length\npasses 16-bits, reset to that value and skip the rest of the branch. */\n\nfor (;;)\n  {\n  int d, min, recno;\n  PCRE2_UCHAR op, *cs, *ce;\n\n  if (branchlength >= UINT16_MAX)\n    {\n    branchlength = UINT16_MAX;\n    cc = (PCRE2_UCHAR *)nextbranch;\n    }\n\n  op = *cc;\n  switch (op)\n    {\n    case OP_COND:\n    case OP_SCOND:\n\n    /* If there is only one branch in a condition, the implied branch has zero\n    length, so we don't add anything. This covers the DEFINE \"condition\"\n    automatically. If there are two branches we can treat it the same as any\n    other non-capturing subpattern. */\n\n    cs = cc + GET(cc, 1);\n    if (*cs != OP_ALT)\n      {\n      cc = cs + 1 + LINK_SIZE;\n      break;\n      }\n    goto PROCESS_NON_CAPTURE;\n\n    case OP_BRA:\n    /* There's a special case of OP_BRA, when it is wrapped round a repeated\n    OP_RECURSE. We'd like to process the latter at this level so that\n    remembering the value works for repeated cases. So we do nothing, but\n    set a fudge value to skip over the OP_KET after the recurse. */\n\n    if (cc\u00dd1+LINK_SIZE\u00a8 == OP_RECURSE && cc\u00dd2*(1+LINK_SIZE)\u00a8 == OP_KET)\n      {\n      once_fudge = 1 + LINK_SIZE;\n      cc += 1 + LINK_SIZE;\n      break;\n      }\n    /* Fall through */\n\n    case OP_ONCE:\n    case OP_SCRIPT_RUN:\n    case OP_SBRA:\n    case OP_BRAPOS:\n    case OP_SBRAPOS:\n    PROCESS_NON_CAPTURE:\n    d = find_minlength(re, cc, startcode, utf, recurses, countptr,\n      backref_cache);\n    if (d < 0) return d;\n    branchlength += d;\n    do cc += GET(cc, 1); while (*cc == OP_ALT);\n    cc += 1 + LINK_SIZE;\n    break;\n\n    /* To save time for repeated capturing subpatterns, we remember the\n    length of the previous one. Unfortunately we can't do the same for\n    the unnumbered ones above. Nor can we do this if (?| is present in the\n    pattern because captures with the same number are not then identical. */\n\n    case OP_CBRA:\n    case OP_SCBRA:\n    case OP_CBRAPOS:\n    case OP_SCBRAPOS:\n    recno = (int)GET2(cc, 1+LINK_SIZE);\n    if (dupcapused || recno != prev_cap_recno)\n      {\n      prev_cap_recno = recno;\n      prev_cap_d = find_minlength(re, cc, startcode, utf, recurses, countptr,\n        backref_cache);\n      if (prev_cap_d < 0) return prev_cap_d;\n      }\n    branchlength += prev_cap_d;\n    do cc += GET(cc, 1); while (*cc == OP_ALT);\n    cc += 1 + LINK_SIZE;\n    break;\n\n    /* ACCEPT makes things far too complicated; we have to give up. In fact,\n    from 10.34 onwards, if a pattern contains (*ACCEPT), this function is not\n    used. However, leave the code in place, just in case. */\n\n    case OP_ACCEPT:\n    case OP_ASSERT_ACCEPT:\n    return -1;\n\n    /* Reached end of a branch; if it's a ket it is the end of a nested\n    call. If it's ALT it is an alternation in a nested call. If it is END it's\n    the end of the outer call. All can be handled by the same code. If the\n    length of any branch is zero, there is no need to scan any subsequent\n    branches. */\n\n    case OP_ALT:\n    case OP_KET:\n    case OP_KETRMAX:\n    case OP_KETRMIN:\n    case OP_KETRPOS:\n    case OP_END:\n    if (length < 0 || (!had_recurse && branchlength < length))\n      length = branchlength;\n    if (op != OP_ALT || length == 0) return length;\n    nextbranch = cc + GET(cc, 1);\n    cc += 1 + LINK_SIZE;\n    branchlength = 0;\n    had_recurse = FALSE;\n    break;\n\n    /* Skip over assertive subpatterns */\n\n    case OP_ASSERT:\n    case OP_ASSERT_NOT:\n    case OP_ASSERTBACK:\n    case OP_ASSERTBACK_NOT:\n    case OP_ASSERT_NA:\n    case OP_ASSERTBACK_NA:\n    do cc += GET(cc, 1); while (*cc == OP_ALT);\n    /* Fall through */\n\n    /* Skip over things that don't match chars */\n\n    case OP_REVERSE:\n    case OP_CREF:\n    case OP_DNCREF:\n    case OP_RREF:\n    case OP_DNRREF:\n    case OP_FALSE:\n    case OP_TRUE:\n    case OP_CALLOUT:\n    case OP_SOD:\n    case OP_SOM:\n    case OP_EOD:\n    case OP_EODN:\n    case OP_CIRC:\n    case OP_CIRCM:\n    case OP_DOLL:\n    case OP_DOLLM:\n    case OP_NOT_WORD_BOUNDARY:\n    case OP_WORD_BOUNDARY:\n    cc += PRIV(OP_lengths)\u00dd*cc\u00a8;\n    break;\n\n    case OP_CALLOUT_STR:\n    cc += GET(cc, 1 + 2*LINK_SIZE);\n    break;\n\n    /* Skip over a subpattern that has a {0} or {0,x} quantifier */\n\n    case OP_BRAZERO:\n    case OP_BRAMINZERO:\n    case OP_BRAPOSZERO:\n    case OP_SKIPZERO:\n    cc += PRIV(OP_lengths)\u00dd*cc\u00a8;\n    do cc += GET(cc, 1); while (*cc == OP_ALT);\n    cc += 1 + LINK_SIZE;\n    break;\n\n    /* Handle literal characters and + repetitions */\n\n    case OP_CHAR:\n    case OP_CHARI:\n    case OP_NOT:\n    case OP_NOTI:\n    case OP_PLUS:\n    case OP_PLUSI:\n    case OP_MINPLUS:\n    case OP_MINPLUSI:\n    case OP_POSPLUS:\n    case OP_POSPLUSI:\n    case OP_NOTPLUS:\n    case OP_NOTPLUSI:\n    case OP_NOTMINPLUS:\n    case OP_NOTMINPLUSI:\n    case OP_NOTPOSPLUS:\n    case OP_NOTPOSPLUSI:\n    branchlength++;\n    cc += 2;\n#ifdef SUPPORT_UNICODE\n    if (utf && HAS_EXTRALEN(cc\u00dd-1\u00a8)) cc += GET_EXTRALEN(cc\u00dd-1\u00a8);\n#endif\n    break;\n\n    case OP_TYPEPLUS:\n    case OP_TYPEMINPLUS:\n    case OP_TYPEPOSPLUS:\n    branchlength++;\n    cc += (cc\u00dd1\u00a8 == OP_PROP || cc\u00dd1\u00a8 == OP_NOTPROP)? 4 : 2;\n    break;\n\n    /* Handle exact repetitions. The count is already in characters, but we\n    may need to skip over a multibyte character in UTF mode.  */\n\n    case OP_EXACT:\n    case OP_EXACTI:\n    case OP_NOTEXACT:\n    case OP_NOTEXACTI:\n    branchlength += GET2(cc,1);\n    cc += 2 + IMM2_SIZE;\n#ifdef SUPPORT_UNICODE\n    if (utf && HAS_EXTRALEN(cc\u00dd-1\u00a8)) cc += GET_EXTRALEN(cc\u00dd-1\u00a8);\n#endif\n    break;\n\n    case OP_TYPEEXACT:\n    branchlength += GET2(cc,1);\n    cc += 2 + IMM2_SIZE + ((cc\u00dd1 + IMM2_SIZE\u00a8 == OP_PROP\n      || cc\u00dd1 + IMM2_SIZE\u00a8 == OP_NOTPROP)? 2 : 0);\n    break;\n\n    /* Handle single-char non-literal matchers */\n\n    case OP_PROP:\n    case OP_NOTPROP:\n    cc += 2;\n    /* Fall through */\n\n    case OP_NOT_DIGIT:\n    case OP_DIGIT:\n    case OP_NOT_WHITESPACE:\n    case OP_WHITESPACE:\n    case OP_NOT_WORDCHAR:\n    case OP_WORDCHAR:\n    case OP_ANY:\n    case OP_ALLANY:\n    case OP_EXTUNI:\n    case OP_HSPACE:\n    case OP_NOT_HSPACE:\n    case OP_VSPACE:\n    case OP_NOT_VSPACE:\n    branchlength++;\n    cc++;\n    break;\n\n    /* \"Any newline\" might match two characters, but it also might match just\n    one. */\n\n    case OP_ANYNL:\n    branchlength += 1;\n    cc++;\n    break;\n\n    /* The single-byte matcher means we can't proceed in UTF mode. (In\n    non-UTF mode \\C will actually be turned into OP_ALLANY, so won't ever\n    appear, but leave the code, just in case.) */\n\n    case OP_ANYBYTE:\n#ifdef SUPPORT_UNICODE\n    if (utf) return -1;\n#endif\n    branchlength++;\n    cc++;\n    break;\n\n    /* For repeated character types, we have to test for \\p and \\P, which have\n    an extra two bytes of parameters. */\n\n    case OP_TYPESTAR:\n    case OP_TYPEMINSTAR:\n    case OP_TYPEQUERY:\n    case OP_TYPEMINQUERY:\n    case OP_TYPEPOSSTAR:\n    case OP_TYPEPOSQUERY:\n    if (cc\u00dd1\u00a8 == OP_PROP || cc\u00dd1\u00a8 == OP_NOTPROP) cc += 2;\n    cc += PRIV(OP_lengths)\u00ddop\u00a8;\n    break;\n\n    case OP_TYPEUPTO:\n    case OP_TYPEMINUPTO:\n    case OP_TYPEPOSUPTO:\n    if (cc\u00dd1 + IMM2_SIZE\u00a8 == OP_PROP\n      || cc\u00dd1 + IMM2_SIZE\u00a8 == OP_NOTPROP) cc += 2;\n    cc += PRIV(OP_lengths)\u00ddop\u00a8;\n    break;\n\n    /* Check a class for variable quantification */\n\n    case OP_CLASS:\n    case OP_NCLASS:\n#ifdef SUPPORT_WIDE_CHARS\n    case OP_XCLASS:\n    /* The original code caused an unsigned overflow in 64 bit systems,\n    so now we use a conditional statement. */\n    if (op == OP_XCLASS)\n      cc += GET(cc, 1);\n    else\n      cc += PRIV(OP_lengths)\u00ddOP_CLASS\u00a8;\n#else\n    cc += PRIV(OP_lengths)\u00ddOP_CLASS\u00a8;\n#endif\n\n    switch (*cc)\n      {\n      case OP_CRPLUS:\n      case OP_CRMINPLUS:\n      case OP_CRPOSPLUS:\n      branchlength++;\n      /* Fall through */\n\n      case OP_CRSTAR:\n      case OP_CRMINSTAR:\n      case OP_CRQUERY:\n      case OP_CRMINQUERY:\n      case OP_CRPOSSTAR:\n      case OP_CRPOSQUERY:\n      cc++;\n      break;\n\n      case OP_CRRANGE:\n      case OP_CRMINRANGE:\n      case OP_CRPOSRANGE:\n      branchlength += GET2(cc,1);\n      cc += 1 + 2 * IMM2_SIZE;\n      break;\n\n      default:\n      branchlength++;\n      break;\n      }\n    break;\n\n    /* Backreferences and subroutine calls (OP_RECURSE) are treated in the same\n    way: we find the minimum length for the subpattern. A recursion\n    (backreference or subroutine) causes an a flag to be set that causes the\n    length of this branch to be ignored. The logic is that a recursion can only\n    make sense if there is another alternative that stops the recursing. That\n    will provide the minimum length (when no recursion happens).\n\n    If PCRE2_MATCH_UNSET_BACKREF is set, a backreference to an unset bracket\n    matches an empty string (by default it causes a matching failure), so in\n    that case we must set the minimum length to zero.\n\n    For backreferenes, if duplicate numbers are present in the pattern we check\n    for a reference to a duplicate. If it is, we don't know which version will\n    be referenced, so we have to set the minimum length to zero. */\n\n    /* Duplicate named pattern back reference. */\n\n    case OP_DNREF:\n    case OP_DNREFI:\n    if (!dupcapused && (re->overall_options & PCRE2_MATCH_UNSET_BACKREF) == 0)\n      {\n      int count = GET2(cc, 1+IMM2_SIZE);\n      PCRE2_UCHAR *slot =\n        (PCRE2_UCHAR *)((uint8_t *)re + sizeof(pcre2_real_code)) +\n          GET2(cc, 1) * re->name_entry_size;\n\n      d = INT_MAX;\n\n      /* Scan all groups with the same name; find the shortest. */\n\n      while (count-- > 0)\n        {\n        int dd, i;\n        recno = GET2(slot, 0);\n\n        if (recno <= backref_cache\u00dd0\u00a8 && backref_cache\u00ddrecno\u00a8 >= 0)\n          dd = backref_cache\u00ddrecno\u00a8;\n        else\n          {\n          ce = cs = (PCRE2_UCHAR *)PRIV(find_bracket)(startcode, utf, recno);\n          if (cs == NULL) return -2;\n          do ce += GET(ce, 1); while (*ce == OP_ALT);\n\n          dd = 0;\n          if (!dupcapused ||\n              (PCRE2_UCHAR *)PRIV(find_bracket)(ce, utf, recno) == NULL)\n            {\n            if (cc > cs && cc < ce)    /* Simple recursion */\n              {\n              had_recurse = TRUE;\n              }\n            else\n              {\n              recurse_check *r = recurses;\n              for (r = recurses; r != NULL; r = r->prev)\n                if (r->group == cs) break;\n              if (r != NULL)           /* Mutual recursion */\n                {\n                had_recurse = TRUE;\n                }\n              else\n                {\n                this_recurse.prev = recurses;  /* No recursion */\n                this_recurse.group = cs;\n                dd = find_minlength(re, cs, startcode, utf, &this_recurse,\n                  countptr, backref_cache);\n                if (dd < 0) return dd;\n                }\n              }\n            }\n\n          backref_cache\u00ddrecno\u00a8 = dd;\n          for (i = backref_cache\u00dd0\u00a8 + 1; i < recno; i++) backref_cache\u00ddi\u00a8 = -1;\n          backref_cache\u00dd0\u00a8 = recno;\n          }\n\n        if (dd < d) d = dd;\n        if (d <= 0) break;    /* No point looking at any more */\n        slot += re->name_entry_size;\n        }\n      }\n    else d = 0;\n    cc += 1 + 2*IMM2_SIZE;\n    goto REPEAT_BACK_REFERENCE;\n\n    /* Single back reference by number. References by name are converted to by\n    number when there is no duplication. */\n\n    case OP_REF:\n    case OP_REFI:\n    recno = GET2(cc, 1);\n    if (recno <= backref_cache\u00dd0\u00a8 && backref_cache\u00ddrecno\u00a8 >= 0)\n      d = backref_cache\u00ddrecno\u00a8;\n    else\n      {\n      int i;\n      d = 0;\n\n      if ((re->overall_options & PCRE2_MATCH_UNSET_BACKREF) == 0)\n        {\n        ce = cs = (PCRE2_UCHAR *)PRIV(find_bracket)(startcode, utf, recno);\n        if (cs == NULL) return -2;\n        do ce += GET(ce, 1); while (*ce == OP_ALT);\n\n        if (!dupcapused ||\n            (PCRE2_UCHAR *)PRIV(find_bracket)(ce, utf, recno) == NULL)\n          {\n          if (cc > cs && cc < ce)    /* Simple recursion */\n            {\n            had_recurse = TRUE;\n            }\n          else\n            {\n            recurse_check *r = recurses;\n            for (r = recurses; r != NULL; r = r->prev) if (r->group == cs) break;\n            if (r != NULL)           /* Mutual recursion */\n              {\n              had_recurse = TRUE;\n              }\n            else                     /* No recursion */\n              {\n              this_recurse.prev = recurses;\n              this_recurse.group = cs;\n              d = find_minlength(re, cs, startcode, utf, &this_recurse, countptr,\n                backref_cache);\n              if (d < 0) return d;\n              }\n            }\n          }\n        }\n\n      backref_cache\u00ddrecno\u00a8 = d;\n      for (i = backref_cache\u00dd0\u00a8 + 1; i < recno; i++) backref_cache\u00ddi\u00a8 = -1;\n      backref_cache\u00dd0\u00a8 = recno;\n      }\n\n    cc += 1 + IMM2_SIZE;\n\n    /* Handle repeated back references */\n\n    REPEAT_BACK_REFERENCE:\n    switch (*cc)\n      {\n      case OP_CRSTAR:\n      case OP_CRMINSTAR:\n      case OP_CRQUERY:\n      case OP_CRMINQUERY:\n      case OP_CRPOSSTAR:\n      case OP_CRPOSQUERY:\n      min = 0;\n      cc++;\n      break;\n\n      case OP_CRPLUS:\n      case OP_CRMINPLUS:\n      case OP_CRPOSPLUS:\n      min = 1;\n      cc++;\n      break;\n\n      case OP_CRRANGE:\n      case OP_CRMINRANGE:\n      case OP_CRPOSRANGE:\n      min = GET2(cc, 1);\n      cc += 1 + 2 * IMM2_SIZE;\n      break;\n\n      default:\n      min = 1;\n      break;\n      }\n\n     /* Take care not to overflow: (1) min and d are ints, so check that their\n     product is not greater than INT_MAX. (2) branchlength is limited to\n     UINT16_MAX (checked at the top of the loop). */\n\n    if ((d > 0 && (INT_MAX/d) < min) || UINT16_MAX - branchlength < min*d)\n      branchlength = UINT16_MAX;\n    else branchlength += min * d;\n    break;\n\n    /* Recursion always refers to the first occurrence of a subpattern with a\n    given number. Therefore, we can always make use of caching, even when the\n    pattern contains multiple subpatterns with the same number. */\n\n    case OP_RECURSE:\n    cs = ce = (PCRE2_UCHAR *)startcode + GET(cc, 1);\n    recno = GET2(cs, 1+LINK_SIZE);\n    if (recno == prev_recurse_recno)\n      {\n      branchlength += prev_recurse_d;\n      }\n    else\n      {\n      do ce += GET(ce, 1); while (*ce == OP_ALT);\n      if (cc > cs && cc < ce)    /* Simple recursion */\n        had_recurse = TRUE;\n      else\n        {\n        recurse_check *r = recurses;\n        for (r = recurses; r != NULL; r = r->prev) if (r->group == cs) break;\n        if (r != NULL)          /* Mutual recursion */\n          had_recurse = TRUE;\n        else\n          {\n          this_recurse.prev = recurses;\n          this_recurse.group = cs;\n          prev_recurse_d = find_minlength(re, cs, startcode, utf, &this_recurse,\n            countptr, backref_cache);\n          if (prev_recurse_d < 0) return prev_recurse_d;\n          prev_recurse_recno = recno;\n          branchlength += prev_recurse_d;\n          }\n        }\n      }\n    cc += 1 + LINK_SIZE + once_fudge;\n    once_fudge = 0;\n    break;\n\n    /* Anything else does not or need not match a character. We can get the\n    item's length from the table, but for those that can match zero occurrences\n    of a character, we must take special action for UTF-8 characters. As it\n    happens, the \"NOT\" versions of these opcodes are used at present only for\n    ASCII characters, so they could be omitted from this list. However, in\n    future that may change, so we include them here so as not to leave a\n    gotcha for a future maintainer. */\n\n    case OP_UPTO:\n    case OP_UPTOI:\n    case OP_NOTUPTO:\n    case OP_NOTUPTOI:\n    case OP_MINUPTO:\n    case OP_MINUPTOI:\n    case OP_NOTMINUPTO:\n    case OP_NOTMINUPTOI:\n    case OP_POSUPTO:\n    case OP_POSUPTOI:\n    case OP_NOTPOSUPTO:\n    case OP_NOTPOSUPTOI:\n\n    case OP_STAR:\n    case OP_STARI:\n    case OP_NOTSTAR:\n    case OP_NOTSTARI:\n    case OP_MINSTAR:\n    case OP_MINSTARI:\n    case OP_NOTMINSTAR:\n    case OP_NOTMINSTARI:\n    case OP_POSSTAR:\n    case OP_POSSTARI:\n    case OP_NOTPOSSTAR:\n    case OP_NOTPOSSTARI:\n\n    case OP_QUERY:\n    case OP_QUERYI:\n    case OP_NOTQUERY:\n    case OP_NOTQUERYI:\n    case OP_MINQUERY:\n    case OP_MINQUERYI:\n    case OP_NOTMINQUERY:\n    case OP_NOTMINQUERYI:\n    case OP_POSQUERY:\n    case OP_POSQUERYI:\n    case OP_NOTPOSQUERY:\n    case OP_NOTPOSQUERYI:\n\n    cc += PRIV(OP_lengths)\u00ddop\u00a8;\n#ifdef SUPPORT_UNICODE\n    if (utf && HAS_EXTRALEN(cc\u00dd-1\u00a8)) cc += GET_EXTRALEN(cc\u00dd-1\u00a8);\n#endif\n    break;\n\n    /* Skip these, but we need to add in the name length. */\n\n    case OP_MARK:\n    case OP_COMMIT_ARG:\n    case OP_PRUNE_ARG:\n    case OP_SKIP_ARG:\n    case OP_THEN_ARG:\n    cc += PRIV(OP_lengths)\u00ddop\u00a8 + cc\u00dd1\u00a8;\n    break;\n\n    /* The remaining opcodes are just skipped over. */\n\n    case OP_CLOSE:\n    case OP_COMMIT:\n    case OP_FAIL:\n    case OP_PRUNE:\n    case OP_SET_SOM:\n    case OP_SKIP:\n    case OP_THEN:\n    cc += PRIV(OP_lengths)\u00ddop\u00a8;\n    break;\n\n    /* This should not occur: we list all opcodes explicitly so that when\n    new ones get added they are properly considered. */\n\n    default:\n    return -3;\n    }\n  }\n/* Control never gets here */\n}\n\n\n\n/*************************************************\n*      Set a bit and maybe its alternate case    *\n*************************************************/\n\n/* Given a character, set its first code unit's bit in the table, and also the\ncorresponding bit for the other version of a letter if we are caseless.\n\nArguments:\n  re            points to the regex block\n  p             points to the first code unit of the character\n  caseless      TRUE if caseless\n  utf           TRUE for UTF mode\n  ucp           TRUE for UCP mode\n\nReturns:        pointer after the character\n*/\n\nstatic PCRE2_SPTR\nset_table_bit(pcre2_real_code *re, PCRE2_SPTR p, BOOL caseless, BOOL utf,\n  BOOL ucp)\n{\nuint32_t c = *p++;   /* First code unit */\n\n(void)utf;           /* Stop compiler warnings when UTF not supported */\n(void)ucp;\n\n/* In 16-bit and 32-bit modes, code units greater than 0xff set the bit for\n0xff. */\n\n#if PCRE2_CODE_UNIT_WIDTH != 8\nif (c > 0xff) SET_BIT(0xff); else\n#endif\n\nSET_BIT(c);\n\n/* In UTF-8 or UTF-16 mode, pick up the remaining code units in order to find\nthe end of the character, even when caseless. */\n\n#ifdef SUPPORT_UNICODE\nif (utf)\n  {\n#if PCRE2_CODE_UNIT_WIDTH == 8\n  if (c >= 0xc0) GETUTF8INC(c, p);\n#elif PCRE2_CODE_UNIT_WIDTH == 16\n  if ((c & 0xfc00) == 0xd800) GETUTF16INC(c, p);\n#endif\n  }\n#endif  /* SUPPORT_UNICODE */\n\n/* If caseless, handle the other case of the character. */\n\nif (caseless)\n  {\n#ifdef SUPPORT_UNICODE\n  if (utf || ucp)\n    {\n    c = UCD_OTHERCASE(c);\n#if PCRE2_CODE_UNIT_WIDTH == 8\n    if (utf)\n      {\n      PCRE2_UCHAR buff\u00dd6\u00a8;\n      (void)PRIV(ord2utf)(c, buff);\n      SET_BIT(buff\u00dd0\u00a8);\n      }\n    else if (c < 256) SET_BIT(c);\n#else  /* 16-bit or 32-bit mode */\n    if (c > 0xff) SET_BIT(0xff); else SET_BIT(c);\n#endif\n    }\n\n  else\n#endif  /* SUPPORT_UNICODE */\n\n  /* Not UTF or UCP */\n\n  if (MAX_255(c)) SET_BIT(re->tables\u00ddfcc_offset + c\u00a8);\n  }\n\nreturn p;\n}\n\n\n\n/*************************************************\n*     Set bits for a positive character type     *\n*************************************************/\n\n/* This function sets starting bits for a character type. In UTF-8 mode, we can\nonly do a direct setting for bytes less than 128, as otherwise there can be\nconfusion with bytes in the middle of UTF-8 characters. In a \"traditional\"\nenvironment, the tables will only recognize ASCII characters anyway, but in at\nleast one Windows environment, some higher bytes bits were set in the tables.\nSo we deal with that case by considering the UTF-8 encoding.\n\nArguments:\n  re             the regex block\n  cbit type      the type of character wanted\n  table_limit    32 for non-UTF-8; 16 for UTF-8\n\nReturns:         nothing\n*/\n\nstatic void\nset_type_bits(pcre2_real_code *re, int cbit_type, unsigned int table_limit)\n{\nuint32_t c;\nfor (c = 0; c < table_limit; c++)\n  re->start_bitmap\u00ddc\u00a8 |= re->tables\u00ddc+cbits_offset+cbit_type\u00a8;\n#if defined SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH == 8\nif (table_limit == 32) return;\nfor (c = 128; c < 256; c++)\n  {\n  if ((re->tables\u00ddcbits_offset + c/8\u00a8 & (1u << (c&7))) != 0)\n    {\n    PCRE2_UCHAR buff\u00dd6\u00a8;\n    (void)PRIV(ord2utf)(c, buff);\n    SET_BIT(buff\u00dd0\u00a8);\n    }\n  }\n#endif  /* UTF-8 */\n}\n\n\n/*************************************************\n*     Set bits for a negative character type     *\n*************************************************/\n\n/* This function sets starting bits for a negative character type such as \\D.\nIn UTF-8 mode, we can only do a direct setting for bytes less than 128, as\notherwise there can be confusion with bytes in the middle of UTF-8 characters.\nUnlike in the positive case, where we can set appropriate starting bits for\nspecific high-valued UTF-8 characters, in this case we have to set the bits for\nall high-valued characters. The lowest is 0xc2, but we overkill by starting at\n0xc0 (192) for simplicity.\n\nArguments:\n  re             the regex block\n  cbit type      the type of character wanted\n  table_limit    32 for non-UTF-8; 16 for UTF-8\n\nReturns:         nothing\n*/\n\nstatic void\nset_nottype_bits(pcre2_real_code *re, int cbit_type, unsigned int table_limit)\n{\nuint32_t c;\nfor (c = 0; c < table_limit; c++)\n  re->start_bitmap\u00ddc\u00a8 |= ~(re->tables\u00ddc+cbits_offset+cbit_type\u00a8);\n#if defined SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH == 8\nif (table_limit != 32) for (c = 24; c < 32; c++) re->start_bitmap\u00ddc\u00a8 = 0xff;\n#endif\n}\n\n\n\n/*************************************************\n*      Create bitmap of starting code units      *\n*************************************************/\n\n/* This function scans a compiled unanchored expression recursively and\nattempts to build a bitmap of the set of possible starting code units whose\nvalues are less than 256. In 16-bit and 32-bit mode, values above 255 all cause\nthe 255 bit to be set. When calling set\u00dd_not\u00a8_type_bits() in UTF-8 (sic) mode\nwe pass a value of 16 rather than 32 as the final argument. (See comments in\nthose functions for the reason.)\n\nThe SSB_CONTINUE return is useful for parenthesized groups in patterns such as\n(a*)b where the group provides some optional starting code units but scanning\nmust continue at the outer level to find at least one mandatory code unit. At\nthe outermost level, this function fails unless the result is SSB_DONE.\n\nWe restrict recursion (for nested groups) to 1000 to avoid stack overflow\nissues.\n\nArguments:\n  re           points to the compiled regex block\n  code         points to an expression\n  utf          TRUE if in UTF mode\n  ucp          TRUE if in UCP mode\n  depthptr     pointer to recurse depth\n\nReturns:       SSB_FAIL     => Failed to find any starting code units\n               SSB_DONE     => Found mandatory starting code units\n               SSB_CONTINUE => Found optional starting code units\n               SSB_UNKNOWN  => Hit an unrecognized opcode\n               SSB_TOODEEP  => Recursion is too deep\n*/\n\nstatic int\nset_start_bits(pcre2_real_code *re, PCRE2_SPTR code, BOOL utf, BOOL ucp,\n  int *depthptr)\n{\nuint32_t c;\nint yield = SSB_DONE;\n\n#if defined SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH == 8\nint table_limit = utf? 16:32;\n#else\nint table_limit = 32;\n#endif\n\n*depthptr += 1;\nif (*depthptr > 1000) return SSB_TOODEEP;\n\ndo\n  {\n  BOOL try_next = TRUE;\n  PCRE2_SPTR tcode = code + 1 + LINK_SIZE;\n\n  if (*code == OP_CBRA || *code == OP_SCBRA ||\n      *code == OP_CBRAPOS || *code == OP_SCBRAPOS) tcode += IMM2_SIZE;\n\n  while (try_next)    /* Loop for items in this branch */\n    {\n    int rc;\n    uint8_t *classmap = NULL;\n#ifdef SUPPORT_WIDE_CHARS\n    PCRE2_UCHAR xclassflags;\n#endif\n\n    switch(*tcode)\n      {\n      /* If we reach something we don't understand, it means a new opcode has\n      been created that hasn't been added to this function. Hopefully this\n      problem will be discovered during testing. */\n\n      default:\n      return SSB_UNKNOWN;\n\n      /* Fail for a valid opcode that implies no starting bits. */\n\n      case OP_ACCEPT:\n      case OP_ASSERT_ACCEPT:\n      case OP_ALLANY:\n      case OP_ANY:\n      case OP_ANYBYTE:\n      case OP_CIRCM:\n      case OP_CLOSE:\n      case OP_COMMIT:\n      case OP_COMMIT_ARG:\n      case OP_COND:\n      case OP_CREF:\n      case OP_FALSE:\n      case OP_TRUE:\n      case OP_DNCREF:\n      case OP_DNREF:\n      case OP_DNREFI:\n      case OP_DNRREF:\n      case OP_DOLL:\n      case OP_DOLLM:\n      case OP_END:\n      case OP_EOD:\n      case OP_EODN:\n      case OP_EXTUNI:\n      case OP_FAIL:\n      case OP_MARK:\n      case OP_NOT:\n      case OP_NOTEXACT:\n      case OP_NOTEXACTI:\n      case OP_NOTI:\n      case OP_NOTMINPLUS:\n      case OP_NOTMINPLUSI:\n      case OP_NOTMINQUERY:\n      case OP_NOTMINQUERYI:\n      case OP_NOTMINSTAR:\n      case OP_NOTMINSTARI:\n      case OP_NOTMINUPTO:\n      case OP_NOTMINUPTOI:\n      case OP_NOTPLUS:\n      case OP_NOTPLUSI:\n      case OP_NOTPOSPLUS:\n      case OP_NOTPOSPLUSI:\n      case OP_NOTPOSQUERY:\n      case OP_NOTPOSQUERYI:\n      case OP_NOTPOSSTAR:\n      case OP_NOTPOSSTARI:\n      case OP_NOTPOSUPTO:\n      case OP_NOTPOSUPTOI:\n      case OP_NOTPROP:\n      case OP_NOTQUERY:\n      case OP_NOTQUERYI:\n      case OP_NOTSTAR:\n      case OP_NOTSTARI:\n      case OP_NOTUPTO:\n      case OP_NOTUPTOI:\n      case OP_NOT_HSPACE:\n      case OP_NOT_VSPACE:\n      case OP_PRUNE:\n      case OP_PRUNE_ARG:\n      case OP_RECURSE:\n      case OP_REF:\n      case OP_REFI:\n      case OP_REVERSE:\n      case OP_RREF:\n      case OP_SCOND:\n      case OP_SET_SOM:\n      case OP_SKIP:\n      case OP_SKIP_ARG:\n      case OP_SOD:\n      case OP_SOM:\n      case OP_THEN:\n      case OP_THEN_ARG:\n      return SSB_FAIL;\n\n      /* OP_CIRC happens only at the start of an anchored branch (multiline \u00ac\n      uses OP_CIRCM). Skip over it. */\n\n      case OP_CIRC:\n      tcode += PRIV(OP_lengths)\u00ddOP_CIRC\u00a8;\n      break;\n\n      /* A \"real\" property test implies no starting bits, but the fake property\n      PT_CLIST identifies a list of characters. These lists are short, as they\n      are used for characters with more than one \"other case\", so there is no\n      point in recognizing them for OP_NOTPROP. */\n\n      case OP_PROP:\n      if (tcode\u00dd1\u00a8 != PT_CLIST) return SSB_FAIL;\n        {\n        const uint32_t *p = PRIV(ucd_caseless_sets) + tcode\u00dd2\u00a8;\n        while ((c = *p++) < NOTACHAR)\n          {\n#if defined SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH == 8\n          if (utf)\n            {\n            PCRE2_UCHAR buff\u00dd6\u00a8;\n            (void)PRIV(ord2utf)(c, buff);\n            c = buff\u00dd0\u00a8;\n            }\n#endif\n          if (c > 0xff) SET_BIT(0xff); else SET_BIT(c);\n          }\n        }\n      try_next = FALSE;\n      break;\n\n      /* We can ignore word boundary tests. */\n\n      case OP_WORD_BOUNDARY:\n      case OP_NOT_WORD_BOUNDARY:\n      tcode++;\n      break;\n\n      /* If we hit a bracket or a positive lookahead assertion, recurse to set\n      bits from within the subpattern. If it can't find anything, we have to\n      give up. If it finds some mandatory character(s), we are done for this\n      branch. Otherwise, carry on scanning after the subpattern. */\n\n      case OP_BRA:\n      case OP_SBRA:\n      case OP_CBRA:\n      case OP_SCBRA:\n      case OP_BRAPOS:\n      case OP_SBRAPOS:\n      case OP_CBRAPOS:\n      case OP_SCBRAPOS:\n      case OP_ONCE:\n      case OP_SCRIPT_RUN:\n      case OP_ASSERT:\n      case OP_ASSERT_NA:\n      rc = set_start_bits(re, tcode, utf, ucp, depthptr);\n      if (rc == SSB_DONE)\n        {\n        try_next = FALSE;\n        }\n      else if (rc == SSB_CONTINUE)\n        {\n        do tcode += GET(tcode, 1); while (*tcode == OP_ALT);\n        tcode += 1 + LINK_SIZE;\n        }\n      else return rc;   /* FAIL, UNKNOWN, or TOODEEP */\n      break;\n\n      /* If we hit ALT or KET, it means we haven't found anything mandatory in\n      this branch, though we might have found something optional. For ALT, we\n      continue with the next alternative, but we have to arrange that the final\n      result from subpattern is SSB_CONTINUE rather than SSB_DONE. For KET,\n      return SSB_CONTINUE: if this is the top level, that indicates failure,\n      but after a nested subpattern, it causes scanning to continue. */\n\n      case OP_ALT:\n      yield = SSB_CONTINUE;\n      try_next = FALSE;\n      break;\n\n      case OP_KET:\n      case OP_KETRMAX:\n      case OP_KETRMIN:\n      case OP_KETRPOS:\n      return SSB_CONTINUE;\n\n      /* Skip over callout */\n\n      case OP_CALLOUT:\n      tcode += PRIV(OP_lengths)\u00ddOP_CALLOUT\u00a8;\n      break;\n\n      case OP_CALLOUT_STR:\n      tcode += GET(tcode, 1 + 2*LINK_SIZE);\n      break;\n\n      /* Skip over lookbehind and negative lookahead assertions */\n\n      case OP_ASSERT_NOT:\n      case OP_ASSERTBACK:\n      case OP_ASSERTBACK_NOT:\n      case OP_ASSERTBACK_NA:\n      do tcode += GET(tcode, 1); while (*tcode == OP_ALT);\n      tcode += 1 + LINK_SIZE;\n      break;\n\n      /* BRAZERO does the bracket, but carries on. */\n\n      case OP_BRAZERO:\n      case OP_BRAMINZERO:\n      case OP_BRAPOSZERO:\n      rc = set_start_bits(re, ++tcode, utf, ucp, depthptr);\n      if (rc == SSB_FAIL || rc == SSB_UNKNOWN || rc == SSB_TOODEEP) return rc;\n      do tcode += GET(tcode,1); while (*tcode == OP_ALT);\n      tcode += 1 + LINK_SIZE;\n      break;\n\n      /* SKIPZERO skips the bracket. */\n\n      case OP_SKIPZERO:\n      tcode++;\n      do tcode += GET(tcode,1); while (*tcode == OP_ALT);\n      tcode += 1 + LINK_SIZE;\n      break;\n\n      /* Single-char * or ? sets the bit and tries the next item */\n\n      case OP_STAR:\n      case OP_MINSTAR:\n      case OP_POSSTAR:\n      case OP_QUERY:\n      case OP_MINQUERY:\n      case OP_POSQUERY:\n      tcode = set_table_bit(re, tcode + 1, FALSE, utf, ucp);\n      break;\n\n      case OP_STARI:\n      case OP_MINSTARI:\n      case OP_POSSTARI:\n      case OP_QUERYI:\n      case OP_MINQUERYI:\n      case OP_POSQUERYI:\n      tcode = set_table_bit(re, tcode + 1, TRUE, utf, ucp);\n      break;\n\n      /* Single-char upto sets the bit and tries the next */\n\n      case OP_UPTO:\n      case OP_MINUPTO:\n      case OP_POSUPTO:\n      tcode = set_table_bit(re, tcode + 1 + IMM2_SIZE, FALSE, utf, ucp);\n      break;\n\n      case OP_UPTOI:\n      case OP_MINUPTOI:\n      case OP_POSUPTOI:\n      tcode = set_table_bit(re, tcode + 1 + IMM2_SIZE, TRUE, utf, ucp);\n      break;\n\n      /* At least one single char sets the bit and stops */\n\n      case OP_EXACT:\n      tcode += IMM2_SIZE;\n      /* Fall through */\n      case OP_CHAR:\n      case OP_PLUS:\n      case OP_MINPLUS:\n      case OP_POSPLUS:\n      (void)set_table_bit(re, tcode + 1, FALSE, utf, ucp);\n      try_next = FALSE;\n      break;\n\n      case OP_EXACTI:\n      tcode += IMM2_SIZE;\n      /* Fall through */\n      case OP_CHARI:\n      case OP_PLUSI:\n      case OP_MINPLUSI:\n      case OP_POSPLUSI:\n      (void)set_table_bit(re, tcode + 1, TRUE, utf, ucp);\n      try_next = FALSE;\n      break;\n\n      /* Special spacing and line-terminating items. These recognize specific\n      lists of characters. The difference between VSPACE and ANYNL is that the\n      latter can match the two-character CRLF sequence, but that is not\n      relevant for finding the first character, so their code here is\n      identical. */\n\n      case OP_HSPACE:\n      SET_BIT(CHAR_HT);\n      SET_BIT(CHAR_SPACE);\n\n      /* For the 16-bit and 32-bit libraries (which can never be EBCDIC), set\n      the bits for 0xA0 and for code units >= 255, independently of UTF. */\n\n#if PCRE2_CODE_UNIT_WIDTH != 8\n      SET_BIT(0xA0);\n      SET_BIT(0xFF);\n#else\n      /* For the 8-bit library in UTF-8 mode, set the bits for the first code\n      units of horizontal space characters. */\n\n#ifdef SUPPORT_UNICODE\n      if (utf)\n        {\n        SET_BIT(0xC2);  /* For U+00A0 */\n        SET_BIT(0xE1);  /* For U+1680, U+180E */\n        SET_BIT(0xE2);  /* For U+2000 - U+200A, U+202F, U+205F */\n        SET_BIT(0xE3);  /* For U+3000 */\n        }\n      else\n#endif\n      /* For the 8-bit library not in UTF-8 mode, set the bit for 0xA0, unless\n      the code is EBCDIC. */\n        {\n#ifndef EBCDIC\n        SET_BIT(0xA0);\n#endif  /* Not EBCDIC */\n        }\n#endif  /* 8-bit support */\n\n      try_next = FALSE;\n      break;\n\n      case OP_ANYNL:\n      case OP_VSPACE:\n      SET_BIT(CHAR_LF);\n      SET_BIT(CHAR_VT);\n      SET_BIT(CHAR_FF);\n      SET_BIT(CHAR_CR);\n\n      /* For the 16-bit and 32-bit libraries (which can never be EBCDIC), set\n      the bits for NEL and for code units >= 255, independently of UTF. */\n\n#if PCRE2_CODE_UNIT_WIDTH != 8\n      SET_BIT(CHAR_NEL);\n      SET_BIT(0xFF);\n#else\n      /* For the 8-bit library in UTF-8 mode, set the bits for the first code\n      units of vertical space characters. */\n\n#ifdef SUPPORT_UNICODE\n      if (utf)\n        {\n        SET_BIT(0xC2);  /* For U+0085 (NEL) */\n        SET_BIT(0xE2);  /* For U+2028, U+2029 */\n        }\n      else\n#endif\n      /* For the 8-bit library not in UTF-8 mode, set the bit for NEL. */\n        {\n        SET_BIT(CHAR_NEL);\n        }\n#endif  /* 8-bit support */\n\n      try_next = FALSE;\n      break;\n\n      /* Single character types set the bits and stop. Note that if PCRE2_UCP\n      is set, we do not see these opcodes because \\d etc are converted to\n      properties. Therefore, these apply in the case when only characters less\n      than 256 are recognized to match the types. */\n\n      case OP_NOT_DIGIT:\n      set_nottype_bits(re, cbit_digit, table_limit);\n      try_next = FALSE;\n      break;\n\n      case OP_DIGIT:\n      set_type_bits(re, cbit_digit, table_limit);\n      try_next = FALSE;\n      break;\n\n      case OP_NOT_WHITESPACE:\n      set_nottype_bits(re, cbit_space, table_limit);\n      try_next = FALSE;\n      break;\n\n      case OP_WHITESPACE:\n      set_type_bits(re, cbit_space, table_limit);\n      try_next = FALSE;\n      break;\n\n      case OP_NOT_WORDCHAR:\n      set_nottype_bits(re, cbit_word, table_limit);\n      try_next = FALSE;\n      break;\n\n      case OP_WORDCHAR:\n      set_type_bits(re, cbit_word, table_limit);\n      try_next = FALSE;\n      break;\n\n      /* One or more character type fudges the pointer and restarts, knowing\n      it will hit a single character type and stop there. */\n\n      case OP_TYPEPLUS:\n      case OP_TYPEMINPLUS:\n      case OP_TYPEPOSPLUS:\n      tcode++;\n      break;\n\n      case OP_TYPEEXACT:\n      tcode += 1 + IMM2_SIZE;\n      break;\n\n      /* Zero or more repeats of character types set the bits and then\n      try again. */\n\n      case OP_TYPEUPTO:\n      case OP_TYPEMINUPTO:\n      case OP_TYPEPOSUPTO:\n      tcode += IMM2_SIZE;  /* Fall through */\n\n      case OP_TYPESTAR:\n      case OP_TYPEMINSTAR:\n      case OP_TYPEPOSSTAR:\n      case OP_TYPEQUERY:\n      case OP_TYPEMINQUERY:\n      case OP_TYPEPOSQUERY:\n      switch(tcode\u00dd1\u00a8)\n        {\n        default:\n        case OP_ANY:\n        case OP_ALLANY:\n        return SSB_FAIL;\n\n        case OP_HSPACE:\n        SET_BIT(CHAR_HT);\n        SET_BIT(CHAR_SPACE);\n\n        /* For the 16-bit and 32-bit libraries (which can never be EBCDIC), set\n        the bits for 0xA0 and for code units >= 255, independently of UTF. */\n\n#if PCRE2_CODE_UNIT_WIDTH != 8\n        SET_BIT(0xA0);\n        SET_BIT(0xFF);\n#else\n        /* For the 8-bit library in UTF-8 mode, set the bits for the first code\n        units of horizontal space characters. */\n\n#ifdef SUPPORT_UNICODE\n        if (utf)\n          {\n          SET_BIT(0xC2);  /* For U+00A0 */\n          SET_BIT(0xE1);  /* For U+1680, U+180E */\n          SET_BIT(0xE2);  /* For U+2000 - U+200A, U+202F, U+205F */\n          SET_BIT(0xE3);  /* For U+3000 */\n          }\n        else\n#endif\n        /* For the 8-bit library not in UTF-8 mode, set the bit for 0xA0, unless\n        the code is EBCDIC. */\n          {\n#ifndef EBCDIC\n          SET_BIT(0xA0);\n#endif  /* Not EBCDIC */\n          }\n#endif  /* 8-bit support */\n        break;\n\n        case OP_ANYNL:\n        case OP_VSPACE:\n        SET_BIT(CHAR_LF);\n        SET_BIT(CHAR_VT);\n        SET_BIT(CHAR_FF);\n        SET_BIT(CHAR_CR);\n\n        /* For the 16-bit and 32-bit libraries (which can never be EBCDIC), set\n        the bits for NEL and for code units >= 255, independently of UTF. */\n\n#if PCRE2_CODE_UNIT_WIDTH != 8\n        SET_BIT(CHAR_NEL);\n        SET_BIT(0xFF);\n#else\n        /* For the 8-bit library in UTF-8 mode, set the bits for the first code\n        units of vertical space characters. */\n\n#ifdef SUPPORT_UNICODE\n        if (utf)\n          {\n          SET_BIT(0xC2);  /* For U+0085 (NEL) */\n          SET_BIT(0xE2);  /* For U+2028, U+2029 */\n          }\n        else\n#endif\n        /* For the 8-bit library not in UTF-8 mode, set the bit for NEL. */\n          {\n          SET_BIT(CHAR_NEL);\n          }\n#endif  /* 8-bit support */\n        break;\n\n        case OP_NOT_DIGIT:\n        set_nottype_bits(re, cbit_digit, table_limit);\n        break;\n\n        case OP_DIGIT:\n        set_type_bits(re, cbit_digit, table_limit);\n        break;\n\n        case OP_NOT_WHITESPACE:\n        set_nottype_bits(re, cbit_space, table_limit);\n        break;\n\n        case OP_WHITESPACE:\n        set_type_bits(re, cbit_space, table_limit);\n        break;\n\n        case OP_NOT_WORDCHAR:\n        set_nottype_bits(re, cbit_word, table_limit);\n        break;\n\n        case OP_WORDCHAR:\n        set_type_bits(re, cbit_word, table_limit);\n        break;\n        }\n\n      tcode += 2;\n      break;\n\n      /* Extended class: if there are any property checks, or if this is a\n      negative XCLASS without a map, give up. If there are no property checks,\n      there must be wide characters on the XCLASS list, because otherwise an\n      XCLASS would not have been created. This means that code points >= 255\n      are potential starters. In the UTF-8 case we can scan them and set bits\n      for the relevant leading bytes. */\n\n#ifdef SUPPORT_WIDE_CHARS\n      case OP_XCLASS:\n      xclassflags = tcode\u00dd1 + LINK_SIZE\u00a8;\n      if ((xclassflags & XCL_HASPROP) != 0 ||\n          (xclassflags & (XCL_MAP|XCL_NOT)) == XCL_NOT)\n        return SSB_FAIL;\n\n      /* We have a positive XCLASS or a negative one without a map. Set up the\n      map pointer if there is one, and fall through. */\n\n      classmap = ((xclassflags & XCL_MAP) == 0)? NULL :\n        (uint8_t *)(tcode + 1 + LINK_SIZE + 1);\n\n      /* In UTF-8 mode, scan the character list and set bits for leading bytes,\n      then jump to handle the map. */\n\n#if PCRE2_CODE_UNIT_WIDTH == 8\n      if (utf && (xclassflags & XCL_NOT) == 0)\n        {\n        PCRE2_UCHAR b, e;\n        PCRE2_SPTR p = tcode + 1 + LINK_SIZE + 1 + ((classmap == NULL)? 0:32);\n        tcode += GET(tcode, 1);\n\n        for (;;) switch (*p++)\n          {\n          case XCL_SINGLE:\n          b = *p++;\n          while ((*p & 0xc0) == 0x80) p++;\n          re->start_bitmap\u00ddb/8\u00a8 |= (1u << (b&7));\n          break;\n\n          case XCL_RANGE:\n          b = *p++;\n          while ((*p & 0xc0) == 0x80) p++;\n          e = *p++;\n          while ((*p & 0xc0) == 0x80) p++;\n          for (; b <= e; b++)\n            re->start_bitmap\u00ddb/8\u00a8 |= (1u << (b&7));\n          break;\n\n          case XCL_END:\n          goto HANDLE_CLASSMAP;\n\n          default:\n          return SSB_UNKNOWN;   /* Internal error, should not occur */\n          }\n        }\n#endif  /* SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH == 8 */\n#endif  /* SUPPORT_WIDE_CHARS */\n\n      /* It seems that the fall through comment must be outside the #ifdef if\n      it is to avoid the gcc compiler warning. */\n\n      /* Fall through */\n\n      /* Enter here for a negative non-XCLASS. In the 8-bit library, if we are\n      in UTF mode, any byte with a value >= 0xc4 is a potentially valid starter\n      because it starts a character with a value > 255. In 8-bit non-UTF mode,\n      there is no difference between CLASS and NCLASS. In all other wide\n      character modes, set the 0xFF bit to indicate code units >= 255. */\n\n      case OP_NCLASS:\n#if defined SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH == 8\n      if (utf)\n        {\n        re->start_bitmap\u00dd24\u00a8 |= 0xf0;            /* Bits for 0xc4 - 0xc8 */\n        memset(re->start_bitmap+25, 0xff, 7);    /* Bits for 0xc9 - 0xff */\n        }\n#elif PCRE2_CODE_UNIT_WIDTH != 8\n      SET_BIT(0xFF);                             /* For characters >= 255 */\n#endif\n      /* Fall through */\n\n      /* Enter here for a positive non-XCLASS. If we have fallen through from\n      an XCLASS, classmap will already be set; just advance the code pointer.\n      Otherwise, set up classmap for a a non-XCLASS and advance past it. */\n\n      case OP_CLASS:\n      if (*tcode == OP_XCLASS) tcode += GET(tcode, 1); else\n        {\n        classmap = (uint8_t *)(++tcode);\n        tcode += 32 / sizeof(PCRE2_UCHAR);\n        }\n\n      /* When wide characters are supported, classmap may be NULL. In UTF-8\n      (sic) mode, the bits in a class bit map correspond to character values,\n      not to byte values. However, the bit map we are constructing is for byte\n      values. So we have to do a conversion for characters whose code point is\n      greater than 127. In fact, there are only two possible starting bytes for\n      characters in the range 128 - 255. */\n\n#if defined SUPPORT_WIDE_CHARS && PCRE2_CODE_UNIT_WIDTH == 8\n      HANDLE_CLASSMAP:\n#endif\n      if (classmap != NULL)\n        {\n#if defined SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH == 8\n        if (utf)\n          {\n          for (c = 0; c < 16; c++) re->start_bitmap\u00ddc\u00a8 |= classmap\u00ddc\u00a8;\n          for (c = 128; c < 256; c++)\n            {\n            if ((classmap\u00ddc/8\u00a8 & (1u << (c&7))) != 0)\n              {\n              int d = (c >> 6) | 0xc0;                 /* Set bit for this starter */\n              re->start_bitmap\u00ddd/8\u00a8 |= (1u << (d&7));  /* and then skip on to the */\n              c = (c & 0xc0) + 0x40 - 1;               /* next relevant character. */\n              }\n            }\n          }\n        else\n#endif\n        /* In all modes except UTF-8, the two bit maps are compatible. */\n\n          {\n          for (c = 0; c < 32; c++) re->start_bitmap\u00ddc\u00a8 |= classmap\u00ddc\u00a8;\n          }\n        }\n\n      /* Act on what follows the class. For a zero minimum repeat, continue;\n      otherwise stop processing. */\n\n      switch (*tcode)\n        {\n        case OP_CRSTAR:\n        case OP_CRMINSTAR:\n        case OP_CRQUERY:\n        case OP_CRMINQUERY:\n        case OP_CRPOSSTAR:\n        case OP_CRPOSQUERY:\n        tcode++;\n        break;\n\n        case OP_CRRANGE:\n        case OP_CRMINRANGE:\n        case OP_CRPOSRANGE:\n        if (GET2(tcode, 1) == 0) tcode += 1 + 2 * IMM2_SIZE;\n          else try_next = FALSE;\n        break;\n\n        default:\n        try_next = FALSE;\n        break;\n        }\n      break; /* End of class handling case */\n      }      /* End of switch for opcodes */\n    }        /* End of try_next loop */\n\n  code += GET(code, 1);   /* Advance to next branch */\n  }\nwhile (*code == OP_ALT);\n\nreturn yield;\n}\n\n\n\n/*************************************************\n*          Study a compiled expression           *\n*************************************************/\n\n/* This function is handed a compiled expression that it must study to produce\ninformation that will speed up the matching.\n\nArgument:\n  re       points to the compiled expression\n\nReturns:   0 normally; non-zero should never normally occur\n           1 unknown opcode in set_start_bits\n           2 missing capturing bracket\n           3 unknown opcode in find_minlength\n*/\n\nint\nPRIV(study)(pcre2_real_code *re)\n{\nint count = 0;\nPCRE2_UCHAR *code;\nBOOL utf = (re->overall_options & PCRE2_UTF) != 0;\nBOOL ucp = (re->overall_options & PCRE2_UCP) != 0;\n\n/* Find start of compiled code */\n\ncode = (PCRE2_UCHAR *)((uint8_t *)re + sizeof(pcre2_real_code)) +\n  re->name_entry_size * re->name_count;\n\n/* For a pattern that has a first code unit, or a multiline pattern that\nmatches only at \"line start\", there is no point in seeking a list of starting\ncode units. */\n\nif ((re->flags & (PCRE2_FIRSTSET|PCRE2_STARTLINE)) == 0)\n  {\n  int depth = 0;\n  int rc = set_start_bits(re, code, utf, ucp, &depth);\n  if (rc == SSB_UNKNOWN) return 1;\n\n  /* If a list of starting code units was set up, scan the list to see if only\n  one or two were listed. Having only one listed is rare because usually a\n  single starting code unit will have been recognized and PCRE2_FIRSTSET set.\n  If two are listed, see if they are caseless versions of the same character;\n  if so we can replace the list with a caseless first code unit. This gives\n  better performance and is plausibly worth doing for patterns such as \u00ddWw\u00a8ord\n  or (word|WORD). */\n\n  if (rc == SSB_DONE)\n    {\n    int i;\n    int a = -1;\n    int b = -1;\n    uint8_t *p = re->start_bitmap;\n    uint32_t flags = PCRE2_FIRSTMAPSET;\n\n    for (i = 0; i < 256; p++, i += 8)\n      {\n      uint8_t x = *p;\n      if (x != 0)\n        {\n        int c;\n        uint8_t y = x & (~x + 1);   /* Least significant bit */\n        if (y != x) goto DONE;      /* More than one bit set */\n\n        /* In the 16-bit and 32-bit libraries, the bit for 0xff means \"0xff and\n        all wide characters\", so we cannot use it here. */\n\n#if PCRE2_CODE_UNIT_WIDTH != 8\n        if (i == 248 && x == 0x80) goto DONE;\n#endif\n\n        /* Compute the character value */\n\n        c = i;\n        switch (x)\n          {\n          case 1:   break;\n          case 2:   c += 1; break;  case 4:  c += 2; break;\n          case 8:   c += 3; break;  case 16: c += 4; break;\n          case 32:  c += 5; break;  case 64: c += 6; break;\n          case 128: c += 7; break;\n          }\n\n        /* c contains the code unit value, in the range 0-255. In 8-bit UTF\n        mode, only values < 128 can be used. In all the other cases, c is a\n        character value. */\n\n#if PCRE2_CODE_UNIT_WIDTH == 8\n        if (utf && c > 127) goto DONE;\n#endif\n        if (a < 0) a = c;   /* First one found, save in a */\n        else if (b < 0)     /* Second one found */\n          {\n          int d = TABLE_GET((unsigned int)c, re->tables + fcc_offset, c);\n\n#ifdef SUPPORT_UNICODE\n          if (utf || ucp)\n            {\n            if (UCD_CASESET(c) != 0) goto DONE;     /* Multiple case set */\n            if (c > 127) d = UCD_OTHERCASE(c);\n            }\n#endif  /* SUPPORT_UNICODE */\n\n          if (d != a) goto DONE;   /* Not the other case of a */\n          b = c;                   /* Save second in b */\n          }\n        else goto DONE;   /* More than two characters found */\n        }\n      }\n\n    /* Replace the start code unit bits with a first code unit, but only if it\n    is not the same as a required later code unit. This is because a search for\n    a required code unit starts after an explicit first code unit, but at a\n    code unit found from the bitmap. Patterns such as /a*a/ don't work\n    if both the start unit and required unit are the same. */\n\n    if (a >= 0 &&\n        (\n        (re->flags & PCRE2_LASTSET) == 0 ||\n          (\n          re->last_codeunit != (uint32_t)a &&\n          (b < 0 || re->last_codeunit != (uint32_t)b)\n          )\n        ))\n      {\n      re->first_codeunit = a;\n      flags = PCRE2_FIRSTSET;\n      if (b >= 0) flags |= PCRE2_FIRSTCASELESS;\n      }\n\n    DONE:\n    re->flags |= flags;\n    }\n  }\n\n/* Find the minimum length of subject string. If the pattern can match an empty\nstring, the minimum length is already known. If the pattern contains (*ACCEPT)\nall bets are off, and we don't even try to find a minimum length. If there are\nmore back references than the size of the vector we are going to cache them in,\ndo nothing. A pattern that complicated will probably take a long time to\nanalyze and may in any case turn out to be too complicated. Note that back\nreference minima are held as 16-bit numbers. */\n\nif ((re->flags & (PCRE2_MATCH_EMPTY|PCRE2_HASACCEPT)) == 0 &&\n     re->top_backref <= MAX_CACHE_BACKREF)\n  {\n  int min;\n  int backref_cache\u00ddMAX_CACHE_BACKREF+1\u00a8;\n  backref_cache\u00dd0\u00a8 = 0;    /* Highest one that is set */\n  min = find_minlength(re, code, code, utf, NULL, &count, backref_cache);\n  switch(min)\n    {\n    case -1:  /* \\C in UTF mode or over-complex regex */\n    break;    /* Leave minlength unchanged (will be zero) */\n\n    case -2:\n    return 2; /* missing capturing bracket */\n\n    case -3:\n    return 3; /* unrecognized opcode */\n\n    default:\n    re->minlength = (min > UINT16_MAX)? UINT16_MAX : min;\n    break;\n    }\n  }\n\nreturn 0;\n}\n\n/* End of pcre2_study.c */\n/*autoconv-0001 C:\\projects\\pcre2-10.35\\src\\pcre2_study.c converted to STUDY2*/\n/*autoconv-0011 STUDY2 line: 46 config.h replaced by CONFIG.h*/\n/*autoconv-0011 STUDY2 line: 49 pcre2_internal.h replaced by INTERNA2.h*/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SUBSTIT2": {"ttr": 9985, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "\n/*************************************************\n*      Perl-Compatible Regular Expressions       *\n*************************************************/\n\n/* PCRE is a library of functions to support regular expressions whose syntax\nand semantics are as close as possible to those of the Perl 5 language.\n\n                       Written by Philip Hazel\n     Original API code Copyright (c) 1997-2012 University of Cambridge\n          New API code Copyright (c) 2016-2020 University of Cambridge\n\n-----------------------------------------------------------------------------\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n\n    * Redistributions of source code must retain the above copyright notice,\n      this list of conditions and the following disclaimer.\n\n    * Redistributions in binary form must reproduce the above copyright\n      notice, this list of conditions and the following disclaimer in the\n      documentation and/or other materials provided with the distribution.\n\n    * Neither the name of the University of Cambridge nor the names of its\n      contributors may be used to endorse or promote products derived from\n      this software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\nAND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\nIMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\nARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\nLIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\nCONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\nSUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\nINTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\nCONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\nARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\nPOSSIBILITY OF SUCH DAMAGE.\n-----------------------------------------------------------------------------\n*/\n\n\n#ifdef HAVE_CONFIG_H\n#include \"CONFIG.h\"\n#endif\n\n#include \"INTERNA2.h\"\n\n#define PTR_STACK_SIZE 20\n\n#define SUBSTITUTE_OPTIONS \\\n  (PCRE2_SUBSTITUTE_EXTENDED|PCRE2_SUBSTITUTE_GLOBAL| \\\n   PCRE2_SUBSTITUTE_LITERAL|PCRE2_SUBSTITUTE_MATCHED| \\\n   PCRE2_SUBSTITUTE_OVERFLOW_LENGTH|PCRE2_SUBSTITUTE_REPLACEMENT_ONLY| \\\n   PCRE2_SUBSTITUTE_UNKNOWN_UNSET|PCRE2_SUBSTITUTE_UNSET_EMPTY)\n\n\n\n/*************************************************\n*           Find end of substitute text          *\n*************************************************/\n\n/* In extended mode, we recognize ${name:+set text:unset text} and similar\nconstructions. This requires the identification of unescaped : and }\ncharacters. This function scans for such. It must deal with nested ${\nconstructions. The pointer to the text is updated, either to the required end\ncharacter, or to where an error was detected.\n\nArguments:\n  code      points to the compiled expression (for options)\n  ptrptr    points to the pointer to the start of the text (updated)\n  ptrend    end of the whole string\n  last      TRUE if the last expected string (only } recognized)\n\nReturns:    0 on success\n            negative error code on failure\n*/\n\nstatic int\nfind_text_end(const pcre2_code *code, PCRE2_SPTR *ptrptr, PCRE2_SPTR ptrend,\n  BOOL last)\n{\nint rc = 0;\nuint32_t nestlevel = 0;\nBOOL literal = FALSE;\nPCRE2_SPTR ptr = *ptrptr;\n\nfor (; ptr < ptrend; ptr++)\n  {\n  if (literal)\n    {\n    if (ptr\u00dd0\u00a8 == CHAR_BACKSLASH && ptr < ptrend - 1 && ptr\u00dd1\u00a8 == CHAR_E)\n      {\n      literal = FALSE;\n      ptr += 1;\n      }\n    }\n\n  else if (*ptr == CHAR_RIGHT_CURLY_BRACKET)\n    {\n    if (nestlevel == 0) goto EXIT;\n    nestlevel--;\n    }\n\n  else if (*ptr == CHAR_COLON && !last && nestlevel == 0) goto EXIT;\n\n  else if (*ptr == CHAR_DOLLAR_SIGN)\n    {\n    if (ptr < ptrend - 1 && ptr\u00dd1\u00a8 == CHAR_LEFT_CURLY_BRACKET)\n      {\n      nestlevel++;\n      ptr += 1;\n      }\n    }\n\n  else if (*ptr == CHAR_BACKSLASH)\n    {\n    int erc;\n    int errorcode;\n    uint32_t ch;\n\n    if (ptr < ptrend - 1) switch (ptr\u00dd1\u00a8)\n      {\n      case CHAR_L:\n      case CHAR_l:\n      case CHAR_U:\n      case CHAR_u:\n      ptr += 1;\n      continue;\n      }\n\n    ptr += 1;  /* Must point after \\ */\n    erc = PRIV(check_escape)(&ptr, ptrend, &ch, &errorcode,\n      code->overall_options, code->extra_options, FALSE, NULL);\n    ptr -= 1;  /* Back to last code unit of escape */\n    if (errorcode != 0)\n      {\n      rc = errorcode;\n      goto EXIT;\n      }\n\n    switch(erc)\n      {\n      case 0:      /* Data character */\n      case ESC_E:  /* Isolated \\E is ignored */\n      break;\n\n      case ESC_Q:\n      literal = TRUE;\n      break;\n\n      default:\n      rc = PCRE2_ERROR_BADREPESCAPE;\n      goto EXIT;\n      }\n    }\n  }\n\nrc = PCRE2_ERROR_REPMISSINGBRACE;   /* Terminator not found */\n\nEXIT:\n*ptrptr = ptr;\nreturn rc;\n}\n\n\n\n/*************************************************\n*              Match and substitute              *\n*************************************************/\n\n/* This function applies a compiled re to a subject string and creates a new\nstring with substitutions. The first 7 arguments are the same as for\npcre2_match(). Either string length may be PCRE2_ZERO_TERMINATED.\n\nArguments:\n  code            points to the compiled expression\n  subject         points to the subject string\n  length          length of subject string (may contain binary zeros)\n  start_offset    where to start in the subject string\n  options         option bits\n  match_data      points to a match_data block, or is NULL\n  context         points a PCRE2 context\n  replacement     points to the replacement string\n  rlength         length of replacement string\n  buffer          where to put the substituted string\n  blength         points to length of buffer; updated to length of string\n\nReturns:          >= 0 number of substitutions made\n                  < 0 an error code\n                  PCRE2_ERROR_BADREPLACEMENT means invalid use of $\n*/\n\n/* This macro checks for space in the buffer before copying into it. On\noverflow, either give an error immediately, or keep on, accumulating the\nlength. */\n\n#define CHECKMEMCPY(from,length) \\\n  { \\\n  if (!overflowed && lengthleft < length) \\\n    { \\\n    if ((suboptions & PCRE2_SUBSTITUTE_OVERFLOW_LENGTH) == 0) goto NOROOM; \\\n    overflowed = TRUE; \\\n    extra_needed = length - lengthleft; \\\n    } \\\n  else if (overflowed) \\\n    { \\\n    extra_needed += length; \\\n    }  \\\n  else \\\n    {  \\\n    memcpy(buffer + buff_offset, from, CU2BYTES(length)); \\\n    buff_offset += length; \\\n    lengthleft -= length; \\\n    } \\\n  }\n\n/* Here's the function */\n\nPCRE2_EXP_DEFN int PCRE2_CALL_CONVENTION\npcre2_substitute(const pcre2_code *code, PCRE2_SPTR subject, PCRE2_SIZE length,\n  PCRE2_SIZE start_offset, uint32_t options, pcre2_match_data *match_data,\n  pcre2_match_context *mcontext, PCRE2_SPTR replacement, PCRE2_SIZE rlength,\n  PCRE2_UCHAR *buffer, PCRE2_SIZE *blength)\n{\nint rc;\nint subs;\nint forcecase = 0;\nint forcecasereset = 0;\nuint32_t ovector_count;\nuint32_t goptions = 0;\nuint32_t suboptions;\npcre2_match_data *internal_match_data = NULL;\nBOOL escaped_literal = FALSE;\nBOOL overflowed = FALSE;\nBOOL use_existing_match;\nBOOL replacement_only;\n#ifdef SUPPORT_UNICODE\nBOOL utf = (code->overall_options & PCRE2_UTF) != 0;\nBOOL ucp = (code->overall_options & PCRE2_UCP) != 0;\n#endif\nPCRE2_UCHAR temp\u00dd6\u00a8;\nPCRE2_SPTR ptr;\nPCRE2_SPTR repend;\nPCRE2_SIZE extra_needed = 0;\nPCRE2_SIZE buff_offset, buff_length, lengthleft, fraglength;\nPCRE2_SIZE *ovector;\nPCRE2_SIZE ovecsave\u00dd3\u00a8;\npcre2_substitute_callout_block scb;\n\n/* General initialization */\n\nbuff_offset = 0;\nlengthleft = buff_length = *blength;\n*blength = PCRE2_UNSET;\novecsave\u00dd0\u00a8 = ovecsave\u00dd1\u00a8 = ovecsave\u00dd2\u00a8 = PCRE2_UNSET;\n\n/* Partial matching is not valid. This must come after setting *blength to\nPCRE2_UNSET, so as not to imply an offset in the replacement. */\n\nif ((options & (PCRE2_PARTIAL_HARD|PCRE2_PARTIAL_SOFT)) != 0)\n  return PCRE2_ERROR_BADOPTION;\n\n/* Check for using a match that has already happened. Note that the subject\npointer in the match data may be NULL after a no-match. */\n\nuse_existing_match = ((options & PCRE2_SUBSTITUTE_MATCHED) != 0);\nreplacement_only = ((options & PCRE2_SUBSTITUTE_REPLACEMENT_ONLY) != 0);\n\n/* If starting from an existing match, there must be an externally provided\nmatch data block. We create an internal match_data block in two cases: (a) an\nexternal one is not supplied (and we are not starting from an existing match);\n(b) an existing match is to be used for the first substitution. In the latter\ncase, we copy the existing match into the internal block. This ensures that no\nchanges are made to the existing match data block. */\n\nif (match_data == NULL)\n  {\n  pcre2_general_context *gcontext;\n  if (use_existing_match) return PCRE2_ERROR_NULL;\n  gcontext = (mcontext == NULL)?\n    (pcre2_general_context *)code :\n    (pcre2_general_context *)mcontext;\n  match_data = internal_match_data =\n    pcre2_match_data_create_from_pattern(code, gcontext);\n  if (internal_match_data == NULL) return PCRE2_ERROR_NOMEMORY;\n  }\n\nelse if (use_existing_match)\n  {\n  pcre2_general_context *gcontext = (mcontext == NULL)?\n    (pcre2_general_context *)code :\n    (pcre2_general_context *)mcontext;\n  int pairs = (code->top_bracket + 1 < match_data->oveccount)?\n    code->top_bracket + 1 : match_data->oveccount;\n  internal_match_data = pcre2_match_data_create(match_data->oveccount,\n    gcontext);\n  if (internal_match_data == NULL) return PCRE2_ERROR_NOMEMORY;\n  memcpy(internal_match_data, match_data, offsetof(pcre2_match_data, ovector)\n    + 2*pairs*sizeof(PCRE2_SIZE));\n  match_data = internal_match_data;\n  }\n\n/* Remember ovector details */\n\novector = pcre2_get_ovector_pointer(match_data);\novector_count = pcre2_get_ovector_count(match_data);\n\n/* Fixed things in the callout block */\n\nscb.version = 0;\nscb.input = subject;\nscb.output = (PCRE2_SPTR)buffer;\nscb.ovector = ovector;\n\n/* Find lengths of zero-terminated strings and the end of the replacement. */\n\nif (length == PCRE2_ZERO_TERMINATED) length = PRIV(strlen)(subject);\nif (rlength == PCRE2_ZERO_TERMINATED) rlength = PRIV(strlen)(replacement);\nrepend = replacement + rlength;\n\n/* Check UTF replacement string if necessary. */\n\n#ifdef SUPPORT_UNICODE\nif (utf && (options & PCRE2_NO_UTF_CHECK) == 0)\n  {\n  rc = PRIV(valid_utf)(replacement, rlength, &(match_data->startchar));\n  if (rc != 0)\n    {\n    match_data->leftchar = 0;\n    goto EXIT;\n    }\n  }\n#endif  /* SUPPORT_UNICODE */\n\n/* Save the substitute options and remove them from the match options. */\n\nsuboptions = options & SUBSTITUTE_OPTIONS;\noptions &= ~SUBSTITUTE_OPTIONS;\n\n/* Error if the start match offset is greater than the length of the subject. */\n\nif (start_offset > length)\n  {\n  match_data->leftchar = 0;\n  rc = PCRE2_ERROR_BADOFFSET;\n  goto EXIT;\n  }\n\n/* Copy up to the start offset, unless only the replacement is required. */\n\nif (!replacement_only) CHECKMEMCPY(subject, start_offset);\n\n/* Loop for global substituting. If PCRE2_SUBSTITUTE_MATCHED is set, the first\nmatch is taken from the match_data that was passed in. */\n\nsubs = 0;\ndo\n  {\n  PCRE2_SPTR ptrstack\u00ddPTR_STACK_SIZE\u00a8;\n  uint32_t ptrstackptr = 0;\n\n  if (use_existing_match)\n    {\n    rc = match_data->rc;\n    use_existing_match = FALSE;\n    }\n  else rc = pcre2_match(code, subject, length, start_offset, options|goptions,\n    match_data, mcontext);\n\n#ifdef SUPPORT_UNICODE\n  if (utf) options |= PCRE2_NO_UTF_CHECK;  /* Only need to check once */\n#endif\n\n  /* Any error other than no match returns the error code. No match when not\n  doing the special after-empty-match global rematch, or when at the end of the\n  subject, breaks the global loop. Otherwise, advance the starting point by one\n  character, copying it to the output, and try again. */\n\n  if (rc < 0)\n    {\n    PCRE2_SIZE save_start;\n\n    if (rc != PCRE2_ERROR_NOMATCH) goto EXIT;\n    if (goptions == 0 || start_offset >= length) break;\n\n    /* Advance by one code point. Then, if CRLF is a valid newline sequence and\n    we have advanced into the middle of it, advance one more code point. In\n    other words, do not start in the middle of CRLF, even if CR and LF on their\n    own are valid newlines. */\n\n    save_start = start_offset++;\n    if (subject\u00ddstart_offset-1\u00a8 == CHAR_CR &&\n        code->newline_convention != PCRE2_NEWLINE_CR &&\n        code->newline_convention != PCRE2_NEWLINE_LF &&\n        start_offset < length &&\n        subject\u00ddstart_offset\u00a8 == CHAR_LF)\n      start_offset++;\n\n    /* Otherwise, in UTF mode, advance past any secondary code points. */\n\n    else if ((code->overall_options & PCRE2_UTF) != 0)\n      {\n#if PCRE2_CODE_UNIT_WIDTH == 8\n      while (start_offset < length && (subject\u00ddstart_offset\u00a8 & 0xc0) == 0x80)\n        start_offset++;\n#elif PCRE2_CODE_UNIT_WIDTH == 16\n      while (start_offset < length &&\n            (subject\u00ddstart_offset\u00a8 & 0xfc00) == 0xdc00)\n        start_offset++;\n#endif\n      }\n\n    /* Copy what we have advanced past (unless not required), reset the special\n    global options, and continue to the next match. */\n\n    fraglength = start_offset - save_start;\n    if (!replacement_only) CHECKMEMCPY(subject + save_start, fraglength);\n    goptions = 0;\n    continue;\n    }\n\n  /* Handle a successful match. Matches that use \\K to end before they start\n  or start before the current point in the subject are not supported. */\n\n  if (ovector\u00dd1\u00a8 < ovector\u00dd0\u00a8 || ovector\u00dd0\u00a8 < start_offset)\n    {\n    rc = PCRE2_ERROR_BADSUBSPATTERN;\n    goto EXIT;\n    }\n\n  /* Check for the same match as previous. This is legitimate after matching an\n  empty string that starts after the initial match offset. We have tried again\n  at the match point in case the pattern is one like /(?<=\\G.)/ which can never\n  match at its starting point, so running the match achieves the bumpalong. If\n  we do get the same (null) match at the original match point, it isn't such a\n  pattern, so we now do the empty string magic. In all other cases, a repeat\n  match should never occur. */\n\n  if (ovecsave\u00dd0\u00a8 == ovector\u00dd0\u00a8 && ovecsave\u00dd1\u00a8 == ovector\u00dd1\u00a8)\n    {\n    if (ovector\u00dd0\u00a8 == ovector\u00dd1\u00a8 && ovecsave\u00dd2\u00a8 != start_offset)\n      {\n      goptions = PCRE2_NOTEMPTY_ATSTART | PCRE2_ANCHORED;\n      ovecsave\u00dd2\u00a8 = start_offset;\n      continue;    /* Back to the top of the loop */\n      }\n    rc = PCRE2_ERROR_INTERNAL_DUPMATCH;\n    goto EXIT;\n    }\n\n  /* Count substitutions with a paranoid check for integer overflow; surely no\n  real call to this function would ever hit this! */\n\n  if (subs == INT_MAX)\n    {\n    rc = PCRE2_ERROR_TOOMANYREPLACE;\n    goto EXIT;\n    }\n  subs++;\n\n  /* Copy the text leading up to the match (unless not required), and remember\n  where the insert begins and how many ovector pairs are set. */\n\n  if (rc == 0) rc = ovector_count;\n  fraglength = ovector\u00dd0\u00a8 - start_offset;\n  if (!replacement_only) CHECKMEMCPY(subject + start_offset, fraglength);\n  scb.output_offsets\u00dd0\u00a8 = buff_offset;\n  scb.oveccount = rc;\n\n  /* Process the replacement string. If the entire replacement is literal, just\n  copy it with length check. */\n\n  ptr = replacement;\n  if ((suboptions & PCRE2_SUBSTITUTE_LITERAL) != 0)\n    {\n    CHECKMEMCPY(ptr, rlength);\n    }\n\n  /* Within a non-literal replacement, which must be scanned character by\n  character, local literal mode can be set by \\Q, but only in extended mode\n  when backslashes are being interpreted. In extended mode we must handle\n  nested substrings that are to be reprocessed. */\n\n  else for (;;)\n    {\n    uint32_t ch;\n    unsigned int chlen;\n\n    /* If at the end of a nested substring, pop the stack. */\n\n    if (ptr >= repend)\n      {\n      if (ptrstackptr == 0) break;       /* End of replacement string */\n      repend = ptrstack\u00dd--ptrstackptr\u00a8;\n      ptr = ptrstack\u00dd--ptrstackptr\u00a8;\n      continue;\n      }\n\n    /* Handle the next character */\n\n    if (escaped_literal)\n      {\n      if (ptr\u00dd0\u00a8 == CHAR_BACKSLASH && ptr < repend - 1 && ptr\u00dd1\u00a8 == CHAR_E)\n        {\n        escaped_literal = FALSE;\n        ptr += 2;\n        continue;\n        }\n      goto LOADLITERAL;\n      }\n\n    /* Not in literal mode. */\n\n    if (*ptr == CHAR_DOLLAR_SIGN)\n      {\n      int group, n;\n      uint32_t special = 0;\n      BOOL inparens;\n      BOOL star;\n      PCRE2_SIZE sublength;\n      PCRE2_SPTR text1_start = NULL;\n      PCRE2_SPTR text1_end = NULL;\n      PCRE2_SPTR text2_start = NULL;\n      PCRE2_SPTR text2_end = NULL;\n      PCRE2_UCHAR next;\n      PCRE2_UCHAR name\u00dd33\u00a8;\n\n      if (++ptr >= repend) goto BAD;\n      if ((next = *ptr) == CHAR_DOLLAR_SIGN) goto LOADLITERAL;\n\n      group = -1;\n      n = 0;\n      inparens = FALSE;\n      star = FALSE;\n\n      if (next == CHAR_LEFT_CURLY_BRACKET)\n        {\n        if (++ptr >= repend) goto BAD;\n        next = *ptr;\n        inparens = TRUE;\n        }\n\n      if (next == CHAR_ASTERISK)\n        {\n        if (++ptr >= repend) goto BAD;\n        next = *ptr;\n        star = TRUE;\n        }\n\n      if (!star && next >= CHAR_0 && next <= CHAR_9)\n        {\n        group = next - CHAR_0;\n        while (++ptr < repend)\n          {\n          next = *ptr;\n          if (next < CHAR_0 || next > CHAR_9) break;\n          group = group * 10 + next - CHAR_0;\n\n          /* A check for a number greater than the hightest captured group\n          is sufficient here; no need for a separate overflow check. If unknown\n          groups are to be treated as unset, just skip over any remaining\n          digits and carry on. */\n\n          if (group > code->top_bracket)\n            {\n            if ((suboptions & PCRE2_SUBSTITUTE_UNKNOWN_UNSET) != 0)\n              {\n              while (++ptr < repend && *ptr >= CHAR_0 && *ptr <= CHAR_9);\n              break;\n              }\n            else\n              {\n              rc = PCRE2_ERROR_NOSUBSTRING;\n              goto PTREXIT;\n              }\n            }\n          }\n        }\n      else\n        {\n        const uint8_t *ctypes = code->tables + ctypes_offset;\n        while (MAX_255(next) && (ctypes\u00ddnext\u00a8 & ctype_word) != 0)\n          {\n          name\u00ddn++\u00a8 = next;\n          if (n > 32) goto BAD;\n          if (++ptr >= repend) break;\n          next = *ptr;\n          }\n        if (n == 0) goto BAD;\n        name\u00ddn\u00a8 = 0;\n        }\n\n      /* In extended mode we recognize ${name:+set text:unset text} and\n      ${name:-default text}. */\n\n      if (inparens)\n        {\n        if ((suboptions & PCRE2_SUBSTITUTE_EXTENDED) != 0 &&\n             !star && ptr < repend - 2 && next == CHAR_COLON)\n          {\n          special = *(++ptr);\n          if (special != CHAR_PLUS && special != CHAR_MINUS)\n            {\n            rc = PCRE2_ERROR_BADSUBSTITUTION;\n            goto PTREXIT;\n            }\n\n          text1_start = ++ptr;\n          rc = find_text_end(code, &ptr, repend, special == CHAR_MINUS);\n          if (rc != 0) goto PTREXIT;\n          text1_end = ptr;\n\n          if (special == CHAR_PLUS && *ptr == CHAR_COLON)\n            {\n            text2_start = ++ptr;\n            rc = find_text_end(code, &ptr, repend, TRUE);\n            if (rc != 0) goto PTREXIT;\n            text2_end = ptr;\n            }\n          }\n\n        else\n          {\n          if (ptr >= repend || *ptr != CHAR_RIGHT_CURLY_BRACKET)\n            {\n            rc = PCRE2_ERROR_REPMISSINGBRACE;\n            goto PTREXIT;\n            }\n          }\n\n        ptr++;\n        }\n\n      /* Have found a syntactically correct group number or name, or *name.\n      Only *MARK is currently recognized. */\n\n      if (star)\n        {\n        if (PRIV(strcmp_c8)(name, STRING_MARK) == 0)\n          {\n          PCRE2_SPTR mark = pcre2_get_mark(match_data);\n          if (mark != NULL)\n            {\n            PCRE2_SPTR mark_start = mark;\n            while (*mark != 0) mark++;\n            fraglength = mark - mark_start;\n            CHECKMEMCPY(mark_start, fraglength);\n            }\n          }\n        else goto BAD;\n        }\n\n      /* Substitute the contents of a group. We don't use substring_copy\n      functions any more, in order to support case forcing. */\n\n      else\n        {\n        PCRE2_SPTR subptr, subptrend;\n\n        /* Find a number for a named group. In case there are duplicate names,\n        search for the first one that is set. If the name is not found when\n        PCRE2_SUBSTITUTE_UNKNOWN_EMPTY is set, set the group number to a\n        non-existent group. */\n\n        if (group < 0)\n          {\n          PCRE2_SPTR first, last, entry;\n          rc = pcre2_substring_nametable_scan(code, name, &first, &last);\n          if (rc == PCRE2_ERROR_NOSUBSTRING &&\n              (suboptions & PCRE2_SUBSTITUTE_UNKNOWN_UNSET) != 0)\n            {\n            group = code->top_bracket + 1;\n            }\n          else\n            {\n            if (rc < 0) goto PTREXIT;\n            for (entry = first; entry <= last; entry += rc)\n              {\n              uint32_t ng = GET2(entry, 0);\n              if (ng < ovector_count)\n                {\n                if (group < 0) group = ng;          /* First in ovector */\n                if (ovector\u00ddng*2\u00a8 != PCRE2_UNSET)\n                  {\n                  group = ng;                       /* First that is set */\n                  break;\n                  }\n                }\n              }\n\n            /* If group is still negative, it means we did not find a group\n            that is in the ovector. Just set the first group. */\n\n            if (group < 0) group = GET2(first, 0);\n            }\n          }\n\n        /* We now have a group that is identified by number. Find the length of\n        the captured string. If a group in a non-special substitution is unset\n        when PCRE2_SUBSTITUTE_UNSET_EMPTY is set, substitute nothing. */\n\n        rc = pcre2_substring_length_bynumber(match_data, group, &sublength);\n        if (rc < 0)\n          {\n          if (rc == PCRE2_ERROR_NOSUBSTRING &&\n              (suboptions & PCRE2_SUBSTITUTE_UNKNOWN_UNSET) != 0)\n            {\n            rc = PCRE2_ERROR_UNSET;\n            }\n          if (rc != PCRE2_ERROR_UNSET) goto PTREXIT;  /* Non-unset errors */\n          if (special == 0)                           /* Plain substitution */\n            {\n            if ((suboptions & PCRE2_SUBSTITUTE_UNSET_EMPTY) != 0) continue;\n            goto PTREXIT;                             /* Else error */\n            }\n          }\n\n        /* If special is '+' we have a 'set' and possibly an 'unset' text,\n        both of which are reprocessed when used. If special is '-' we have a\n        default text for when the group is unset; it must be reprocessed. */\n\n        if (special != 0)\n          {\n          if (special == CHAR_MINUS)\n            {\n            if (rc == 0) goto LITERAL_SUBSTITUTE;\n            text2_start = text1_start;\n            text2_end = text1_end;\n            }\n\n          if (ptrstackptr >= PTR_STACK_SIZE) goto BAD;\n          ptrstack\u00ddptrstackptr++\u00a8 = ptr;\n          ptrstack\u00ddptrstackptr++\u00a8 = repend;\n\n          if (rc == 0)\n            {\n            ptr = text1_start;\n            repend = text1_end;\n            }\n          else\n            {\n            ptr = text2_start;\n            repend = text2_end;\n            }\n          continue;\n          }\n\n        /* Otherwise we have a literal substitution of a group's contents. */\n\n        LITERAL_SUBSTITUTE:\n        subptr = subject + ovector\u00ddgroup*2\u00a8;\n        subptrend = subject + ovector\u00ddgroup*2 + 1\u00a8;\n\n        /* Substitute a literal string, possibly forcing alphabetic case. */\n\n        while (subptr < subptrend)\n          {\n          GETCHARINCTEST(ch, subptr);\n          if (forcecase != 0)\n            {\n#ifdef SUPPORT_UNICODE\n            if (utf || ucp)\n              {\n              uint32_t type = UCD_CHARTYPE(ch);\n              if (PRIV(ucp_gentype)\u00ddtype\u00a8 == ucp_L &&\n                  type != ((forcecase > 0)? ucp_Lu : ucp_Ll))\n                ch = UCD_OTHERCASE(ch);\n              }\n            else\n#endif\n              {\n              if (((code->tables + cbits_offset +\n                  ((forcecase > 0)? cbit_upper:cbit_lower)\n                  )\u00ddch/8\u00a8 & (1u << (ch%8))) == 0)\n                ch = (code->tables + fcc_offset)\u00ddch\u00a8;\n              }\n            forcecase = forcecasereset;\n            }\n\n#ifdef SUPPORT_UNICODE\n          if (utf) chlen = PRIV(ord2utf)(ch, temp); else\n#endif\n            {\n            temp\u00dd0\u00a8 = ch;\n            chlen = 1;\n            }\n          CHECKMEMCPY(temp, chlen);\n          }\n        }\n      }\n\n    /* Handle an escape sequence in extended mode. We can use check_escape()\n    to process \\Q, \\E, \\c, \\o, \\x and \\ followed by non-alphanumerics, but\n    the case-forcing escapes are not supported in pcre2_compile() so must be\n    recognized here. */\n\n    else if ((suboptions & PCRE2_SUBSTITUTE_EXTENDED) != 0 &&\n              *ptr == CHAR_BACKSLASH)\n      {\n      int errorcode;\n\n      if (ptr < repend - 1) switch (ptr\u00dd1\u00a8)\n        {\n        case CHAR_L:\n        forcecase = forcecasereset = -1;\n        ptr += 2;\n        continue;\n\n        case CHAR_l:\n        forcecase = -1;\n        forcecasereset = 0;\n        ptr += 2;\n        continue;\n\n        case CHAR_U:\n        forcecase = forcecasereset = 1;\n        ptr += 2;\n        continue;\n\n        case CHAR_u:\n        forcecase = 1;\n        forcecasereset = 0;\n        ptr += 2;\n        continue;\n\n        default:\n        break;\n        }\n\n      ptr++;  /* Point after \\ */\n      rc = PRIV(check_escape)(&ptr, repend, &ch, &errorcode,\n        code->overall_options, code->extra_options, FALSE, NULL);\n      if (errorcode != 0) goto BADESCAPE;\n\n      switch(rc)\n        {\n        case ESC_E:\n        forcecase = forcecasereset = 0;\n        continue;\n\n        case ESC_Q:\n        escaped_literal = TRUE;\n        continue;\n\n        case 0:      /* Data character */\n        goto LITERAL;\n\n        default:\n        goto BADESCAPE;\n        }\n      }\n\n    /* Handle a literal code unit */\n\n    else\n      {\n      LOADLITERAL:\n      GETCHARINCTEST(ch, ptr);    /* Get character value, increment pointer */\n\n      LITERAL:\n      if (forcecase != 0)\n        {\n#ifdef SUPPORT_UNICODE\n        if (utf || ucp)\n          {\n          uint32_t type = UCD_CHARTYPE(ch);\n          if (PRIV(ucp_gentype)\u00ddtype\u00a8 == ucp_L &&\n              type != ((forcecase > 0)? ucp_Lu : ucp_Ll))\n            ch = UCD_OTHERCASE(ch);\n          }\n        else\n#endif\n          {\n          if (((code->tables + cbits_offset +\n              ((forcecase > 0)? cbit_upper:cbit_lower)\n              )\u00ddch/8\u00a8 & (1u << (ch%8))) == 0)\n            ch = (code->tables + fcc_offset)\u00ddch\u00a8;\n          }\n        forcecase = forcecasereset;\n        }\n\n#ifdef SUPPORT_UNICODE\n      if (utf) chlen = PRIV(ord2utf)(ch, temp); else\n#endif\n        {\n        temp\u00dd0\u00a8 = ch;\n        chlen = 1;\n        }\n      CHECKMEMCPY(temp, chlen);\n      } /* End handling a literal code unit */\n    }   /* End of loop for scanning the replacement. */\n\n  /* The replacement has been copied to the output, or its size has been\n  remembered. Do the callout if there is one and we have done an actual\n  replacement. */\n\n  if (!overflowed && mcontext != NULL && mcontext->substitute_callout != NULL)\n    {\n    scb.subscount = subs;\n    scb.output_offsets\u00dd1\u00a8 = buff_offset;\n    rc = mcontext->substitute_callout(&scb, mcontext->substitute_callout_data);\n\n    /* A non-zero return means cancel this substitution. Instead, copy the\n    matched string fragment. */\n\n    if (rc != 0)\n      {\n      PCRE2_SIZE newlength = scb.output_offsets\u00dd1\u00a8 - scb.output_offsets\u00dd0\u00a8;\n      PCRE2_SIZE oldlength = ovector\u00dd1\u00a8 - ovector\u00dd0\u00a8;\n\n      buff_offset -= newlength;\n      lengthleft += newlength;\n      if (!replacement_only) CHECKMEMCPY(subject + ovector\u00dd0\u00a8, oldlength);\n\n      /* A negative return means do not do any more. */\n\n      if (rc < 0) suboptions &= (~PCRE2_SUBSTITUTE_GLOBAL);\n      }\n    }\n\n  /* Save the details of this match. See above for how this data is used. If we\n  matched an empty string, do the magic for global matches. Update the start\n  offset to point to the rest of the subject string. If we re-used an existing\n  match for the first match, switch to the internal match data block. */\n\n  ovecsave\u00dd0\u00a8 = ovector\u00dd0\u00a8;\n  ovecsave\u00dd1\u00a8 = ovector\u00dd1\u00a8;\n  ovecsave\u00dd2\u00a8 = start_offset;\n\n  goptions = (ovector\u00dd0\u00a8 != ovector\u00dd1\u00a8 || ovector\u00dd0\u00a8 > start_offset)? 0 :\n    PCRE2_ANCHORED|PCRE2_NOTEMPTY_ATSTART;\n  start_offset = ovector\u00dd1\u00a8;\n  } while ((suboptions & PCRE2_SUBSTITUTE_GLOBAL) != 0);  /* Repeat \"do\" loop */\n\n/* Copy the rest of the subject unless not required, and terminate the output\nwith a binary zero. */\n\nif (!replacement_only)\n  {\n  fraglength = length - start_offset;\n  CHECKMEMCPY(subject + start_offset, fraglength);\n  }\n\ntemp\u00dd0\u00a8 = 0;\nCHECKMEMCPY(temp, 1);\n\n/* If overflowed is set it means the PCRE2_SUBSTITUTE_OVERFLOW_LENGTH is set,\nand matching has carried on after a full buffer, in order to compute the length\nneeded. Otherwise, an overflow generates an immediate error return. */\n\nif (overflowed)\n  {\n  rc = PCRE2_ERROR_NOMEMORY;\n  *blength = buff_length + extra_needed;\n  }\n\n/* After a successful execution, return the number of substitutions and set the\nlength of buffer used, excluding the trailing zero. */\n\nelse\n  {\n  rc = subs;\n  *blength = buff_offset - 1;\n  }\n\nEXIT:\nif (internal_match_data != NULL) pcre2_match_data_free(internal_match_data);\n  else match_data->rc = rc;\nreturn rc;\n\nNOROOM:\nrc = PCRE2_ERROR_NOMEMORY;\ngoto EXIT;\n\nBAD:\nrc = PCRE2_ERROR_BADREPLACEMENT;\ngoto PTREXIT;\n\nBADESCAPE:\nrc = PCRE2_ERROR_BADREPESCAPE;\n\nPTREXIT:\n*blength = (PCRE2_SIZE)(ptr - replacement);\ngoto EXIT;\n}\n\n/* End of pcre2_substitute.c */\n/*autoconv-0001 C:\\projects\\pcre2-10.35\\src\\pcre2_substitute.c converted to SUBSTIT2*/\n/*autoconv-0011 SUBSTIT2 line: 43 config.h replaced by CONFIG.h*/\n/*autoconv-0011 SUBSTIT2 line: 46 pcre2_internal.h replaced by INTERNA2.h*/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SUBSTRI2": {"ttr": 2305, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "\n/*************************************************\n*      Perl-Compatible Regular Expressions       *\n*************************************************/\n\n/* PCRE is a library of functions to support regular expressions whose syntax\nand semantics are as close as possible to those of the Perl 5 language.\n\n                       Written by Philip Hazel\n     Original API code Copyright (c) 1997-2012 University of Cambridge\n          New API code Copyright (c) 2016-2018 University of Cambridge\n\n-----------------------------------------------------------------------------\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n\n    * Redistributions of source code must retain the above copyright notice,\n      this list of conditions and the following disclaimer.\n\n    * Redistributions in binary form must reproduce the above copyright\n      notice, this list of conditions and the following disclaimer in the\n      documentation and/or other materials provided with the distribution.\n\n    * Neither the name of the University of Cambridge nor the names of its\n      contributors may be used to endorse or promote products derived from\n      this software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\nAND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\nIMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\nARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\nLIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\nCONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\nSUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\nINTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\nCONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\nARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\nPOSSIBILITY OF SUCH DAMAGE.\n-----------------------------------------------------------------------------\n*/\n\n\n#ifdef HAVE_CONFIG_H\n#include \"CONFIG.h\"\n#endif\n\n#include \"INTERNA2.h\"\n\n\n\n/*************************************************\n*   Copy named captured string to given buffer   *\n*************************************************/\n\n/* This function copies a single captured substring into a given buffer,\nidentifying it by name. If the regex permits duplicate names, the first\nsubstring that is set is chosen.\n\nArguments:\n  match_data     points to the match data\n  stringname     the name of the required substring\n  buffer         where to put the substring\n  sizeptr        the size of the buffer, updated to the size of the substring\n\nReturns:         if successful: zero\n                 if not successful, a negative error code:\n                   (1) an error from nametable_scan()\n                   (2) an error from copy_bynumber()\n                   (3) PCRE2_ERROR_UNAVAILABLE: no group is in ovector\n                   (4) PCRE2_ERROR_UNSET: all named groups in ovector are unset\n*/\n\nPCRE2_EXP_DEFN int PCRE2_CALL_CONVENTION\npcre2_substring_copy_byname(pcre2_match_data *match_data, PCRE2_SPTR stringname,\n  PCRE2_UCHAR *buffer, PCRE2_SIZE *sizeptr)\n{\nPCRE2_SPTR first, last, entry;\nint failrc, entrysize;\nif (match_data->matchedby == PCRE2_MATCHEDBY_DFA_INTERPRETER)\n  return PCRE2_ERROR_DFA_UFUNC;\nentrysize = pcre2_substring_nametable_scan(match_data->code, stringname,\n  &first, &last);\nif (entrysize < 0) return entrysize;\nfailrc = PCRE2_ERROR_UNAVAILABLE;\nfor (entry = first; entry <= last; entry += entrysize)\n  {\n  uint32_t n = GET2(entry, 0);\n  if (n < match_data->oveccount)\n    {\n    if (match_data->ovector\u00ddn*2\u00a8 != PCRE2_UNSET)\n      return pcre2_substring_copy_bynumber(match_data, n, buffer, sizeptr);\n    failrc = PCRE2_ERROR_UNSET;\n    }\n  }\nreturn failrc;\n}\n\n\n\n/*************************************************\n*  Copy numbered captured string to given buffer *\n*************************************************/\n\n/* This function copies a single captured substring into a given buffer,\nidentifying it by number.\n\nArguments:\n  match_data     points to the match data\n  stringnumber   the number of the required substring\n  buffer         where to put the substring\n  sizeptr        the size of the buffer, updated to the size of the substring\n\nReturns:         if successful: 0\n                 if not successful, a negative error code:\n                   PCRE2_ERROR_NOMEMORY: buffer too small\n                   PCRE2_ERROR_NOSUBSTRING: no such substring\n                   PCRE2_ERROR_UNAVAILABLE: ovector too small\n                   PCRE2_ERROR_UNSET: substring is not set\n*/\n\nPCRE2_EXP_DEFN int PCRE2_CALL_CONVENTION\npcre2_substring_copy_bynumber(pcre2_match_data *match_data,\n  uint32_t stringnumber, PCRE2_UCHAR *buffer, PCRE2_SIZE *sizeptr)\n{\nint rc;\nPCRE2_SIZE size;\nrc = pcre2_substring_length_bynumber(match_data, stringnumber, &size);\nif (rc < 0) return rc;\nif (size + 1 > *sizeptr) return PCRE2_ERROR_NOMEMORY;\nmemcpy(buffer, match_data->subject + match_data->ovector\u00ddstringnumber*2\u00a8,\n  CU2BYTES(size));\nbuffer\u00ddsize\u00a8 = 0;\n*sizeptr = size;\nreturn 0;\n}\n\n\n\n/*************************************************\n*          Extract named captured string         *\n*************************************************/\n\n/* This function copies a single captured substring, identified by name, into\nnew memory. If the regex permits duplicate names, the first substring that is\nset is chosen.\n\nArguments:\n  match_data     pointer to match_data\n  stringname     the name of the required substring\n  stringptr      where to put the pointer to the new memory\n  sizeptr        where to put the length of the substring\n\nReturns:         if successful: zero\n                 if not successful, a negative value:\n                   (1) an error from nametable_scan()\n                   (2) an error from get_bynumber()\n                   (3) PCRE2_ERROR_UNAVAILABLE: no group is in ovector\n                   (4) PCRE2_ERROR_UNSET: all named groups in ovector are unset\n*/\n\nPCRE2_EXP_DEFN int PCRE2_CALL_CONVENTION\npcre2_substring_get_byname(pcre2_match_data *match_data,\n  PCRE2_SPTR stringname, PCRE2_UCHAR **stringptr, PCRE2_SIZE *sizeptr)\n{\nPCRE2_SPTR first, last, entry;\nint failrc, entrysize;\nif (match_data->matchedby == PCRE2_MATCHEDBY_DFA_INTERPRETER)\n  return PCRE2_ERROR_DFA_UFUNC;\nentrysize = pcre2_substring_nametable_scan(match_data->code, stringname,\n  &first, &last);\nif (entrysize < 0) return entrysize;\nfailrc = PCRE2_ERROR_UNAVAILABLE;\nfor (entry = first; entry <= last; entry += entrysize)\n  {\n  uint32_t n = GET2(entry, 0);\n  if (n < match_data->oveccount)\n    {\n    if (match_data->ovector\u00ddn*2\u00a8 != PCRE2_UNSET)\n      return pcre2_substring_get_bynumber(match_data, n, stringptr, sizeptr);\n    failrc = PCRE2_ERROR_UNSET;\n    }\n  }\nreturn failrc;\n}\n\n\n\n/*************************************************\n*      Extract captured string to new memory     *\n*************************************************/\n\n/* This function copies a single captured substring into a piece of new\nmemory.\n\nArguments:\n  match_data     points to match data\n  stringnumber   the number of the required substring\n  stringptr      where to put a pointer to the new memory\n  sizeptr        where to put the size of the substring\n\nReturns:         if successful: 0\n                 if not successful, a negative error code:\n                   PCRE2_ERROR_NOMEMORY: failed to get memory\n                   PCRE2_ERROR_NOSUBSTRING: no such substring\n                   PCRE2_ERROR_UNAVAILABLE: ovector too small\n                   PCRE2_ERROR_UNSET: substring is not set\n*/\n\nPCRE2_EXP_DEFN int PCRE2_CALL_CONVENTION\npcre2_substring_get_bynumber(pcre2_match_data *match_data,\n  uint32_t stringnumber, PCRE2_UCHAR **stringptr, PCRE2_SIZE *sizeptr)\n{\nint rc;\nPCRE2_SIZE size;\nPCRE2_UCHAR *yield;\nrc = pcre2_substring_length_bynumber(match_data, stringnumber, &size);\nif (rc < 0) return rc;\nyield = PRIV(memctl_malloc)(sizeof(pcre2_memctl) +\n  (size + 1)*PCRE2_CODE_UNIT_WIDTH, (pcre2_memctl *)match_data);\nif (yield == NULL) return PCRE2_ERROR_NOMEMORY;\nyield = (PCRE2_UCHAR *)(((char *)yield) + sizeof(pcre2_memctl));\nmemcpy(yield, match_data->subject + match_data->ovector\u00ddstringnumber*2\u00a8,\n  CU2BYTES(size));\nyield\u00ddsize\u00a8 = 0;\n*stringptr = yield;\n*sizeptr = size;\nreturn 0;\n}\n\n\n\n/*************************************************\n*       Free memory obtained by get_substring    *\n*************************************************/\n\n/*\nArgument:     the result of a previous pcre2_substring_get_byxxx()\nReturns:      nothing\n*/\n\nPCRE2_EXP_DEFN void PCRE2_CALL_CONVENTION\npcre2_substring_free(PCRE2_UCHAR *string)\n{\nif (string != NULL)\n  {\n  pcre2_memctl *memctl = (pcre2_memctl *)((char *)string - sizeof(pcre2_memctl));\n  memctl->free(memctl, memctl->memory_data);\n  }\n}\n\n\n\n/*************************************************\n*         Get length of a named substring        *\n*************************************************/\n\n/* This function returns the length of a named captured substring. If the regex\npermits duplicate names, the first substring that is set is chosen.\n\nArguments:\n  match_data      pointer to match data\n  stringname      the name of the required substring\n  sizeptr         where to put the length\n\nReturns:          0 if successful, else a negative error number\n*/\n\nPCRE2_EXP_DEFN int PCRE2_CALL_CONVENTION\npcre2_substring_length_byname(pcre2_match_data *match_data,\n  PCRE2_SPTR stringname, PCRE2_SIZE *sizeptr)\n{\nPCRE2_SPTR first, last, entry;\nint failrc, entrysize;\nif (match_data->matchedby == PCRE2_MATCHEDBY_DFA_INTERPRETER)\n  return PCRE2_ERROR_DFA_UFUNC;\nentrysize = pcre2_substring_nametable_scan(match_data->code, stringname,\n  &first, &last);\nif (entrysize < 0) return entrysize;\nfailrc = PCRE2_ERROR_UNAVAILABLE;\nfor (entry = first; entry <= last; entry += entrysize)\n  {\n  uint32_t n = GET2(entry, 0);\n  if (n < match_data->oveccount)\n    {\n    if (match_data->ovector\u00ddn*2\u00a8 != PCRE2_UNSET)\n      return pcre2_substring_length_bynumber(match_data, n, sizeptr);\n    failrc = PCRE2_ERROR_UNSET;\n    }\n  }\nreturn failrc;\n}\n\n\n\n/*************************************************\n*        Get length of a numbered substring      *\n*************************************************/\n\n/* This function returns the length of a captured substring. If the start is\nbeyond the end (which can happen when \\K is used in an assertion), it sets the\nlength to zero.\n\nArguments:\n  match_data      pointer to match data\n  stringnumber    the number of the required substring\n  sizeptr         where to put the length, if not NULL\n\nReturns:         if successful: 0\n                 if not successful, a negative error code:\n                   PCRE2_ERROR_NOSUBSTRING: no such substring\n                   PCRE2_ERROR_UNAVAILABLE: ovector is too small\n                   PCRE2_ERROR_UNSET: substring is not set\n*/\n\nPCRE2_EXP_DEFN int PCRE2_CALL_CONVENTION\npcre2_substring_length_bynumber(pcre2_match_data *match_data,\n  uint32_t stringnumber, PCRE2_SIZE *sizeptr)\n{\nPCRE2_SIZE left, right;\nint count = match_data->rc;\nif (count == PCRE2_ERROR_PARTIAL)\n  {\n  if (stringnumber > 0) return PCRE2_ERROR_PARTIAL;\n  count = 0;\n  }\nelse if (count < 0) return count;            /* Match failed */\n\nif (match_data->matchedby != PCRE2_MATCHEDBY_DFA_INTERPRETER)\n  {\n  if (stringnumber > match_data->code->top_bracket)\n    return PCRE2_ERROR_NOSUBSTRING;\n  if (stringnumber >= match_data->oveccount)\n    return PCRE2_ERROR_UNAVAILABLE;\n  if (match_data->ovector\u00ddstringnumber*2\u00a8 == PCRE2_UNSET)\n    return PCRE2_ERROR_UNSET;\n  }\nelse  /* Matched using pcre2_dfa_match() */\n  {\n  if (stringnumber >= match_data->oveccount) return PCRE2_ERROR_UNAVAILABLE;\n  if (count != 0 && stringnumber >= (uint32_t)count) return PCRE2_ERROR_UNSET;\n  }\n\nleft = match_data->ovector\u00ddstringnumber*2\u00a8;\nright = match_data->ovector\u00ddstringnumber*2+1\u00a8;\nif (sizeptr != NULL) *sizeptr = (left > right)? 0 : right - left;\nreturn 0;\n}\n\n\n\n/*************************************************\n*    Extract all captured strings to new memory  *\n*************************************************/\n\n/* This function gets one chunk of memory and builds a list of pointers and all\nthe captured substrings in it. A NULL pointer is put on the end of the list.\nThe substrings are zero-terminated, but also, if the final argument is\nnon-NULL, a list of lengths is also returned. This allows binary data to be\nhandled.\n\nArguments:\n  match_data     points to the match data\n  listptr        set to point to the list of pointers\n  lengthsptr     set to point to the list of lengths (may be NULL)\n\nReturns:         if successful: 0\n                 if not successful, a negative error code:\n                   PCRE2_ERROR_NOMEMORY: failed to get memory,\n                   or a match failure code\n*/\n\nPCRE2_EXP_DEFN int PCRE2_CALL_CONVENTION\npcre2_substring_list_get(pcre2_match_data *match_data, PCRE2_UCHAR ***listptr,\n  PCRE2_SIZE **lengthsptr)\n{\nint i, count, count2;\nPCRE2_SIZE size;\nPCRE2_SIZE *lensp;\npcre2_memctl *memp;\nPCRE2_UCHAR **listp;\nPCRE2_UCHAR *sp;\nPCRE2_SIZE *ovector;\n\nif ((count = match_data->rc) < 0) return count;   /* Match failed */\nif (count == 0) count = match_data->oveccount;    /* Ovector too small */\n\ncount2 = 2*count;\novector = match_data->ovector;\nsize = sizeof(pcre2_memctl) + sizeof(PCRE2_UCHAR *);      /* For final NULL */\nif (lengthsptr != NULL) size += sizeof(PCRE2_SIZE) * count;  /* For lengths */\n\nfor (i = 0; i < count2; i += 2)\n  {\n  size += sizeof(PCRE2_UCHAR *) + CU2BYTES(1);\n  if (ovector\u00ddi+1\u00a8 > ovector\u00ddi\u00a8) size += CU2BYTES(ovector\u00ddi+1\u00a8 - ovector\u00ddi\u00a8);\n  }\n\nmemp = PRIV(memctl_malloc)(size, (pcre2_memctl *)match_data);\nif (memp == NULL) return PCRE2_ERROR_NOMEMORY;\n\n*listptr = listp = (PCRE2_UCHAR **)((char *)memp + sizeof(pcre2_memctl));\nlensp = (PCRE2_SIZE *)((char *)listp + sizeof(PCRE2_UCHAR *) * (count + 1));\n\nif (lengthsptr == NULL)\n  {\n  sp = (PCRE2_UCHAR *)lensp;\n  lensp = NULL;\n  }\nelse\n  {\n  *lengthsptr = lensp;\n  sp = (PCRE2_UCHAR *)((char *)lensp + sizeof(PCRE2_SIZE) * count);\n  }\n\nfor (i = 0; i < count2; i += 2)\n  {\n  size = (ovector\u00ddi+1\u00a8 > ovector\u00ddi\u00a8)? (ovector\u00ddi+1\u00a8 - ovector\u00ddi\u00a8) : 0;\n\n  /* Size == 0 includes the case when the capture is unset. Avoid adding\n  PCRE2_UNSET to match_data->subject because it overflows, even though with\n  zero size calling memcpy() is harmless. */\n\n  if (size != 0) memcpy(sp, match_data->subject + ovector\u00ddi\u00a8, CU2BYTES(size));\n  *listp++ = sp;\n  if (lensp != NULL) *lensp++ = size;\n  sp += size;\n  *sp++ = 0;\n  }\n\n*listp = NULL;\nreturn 0;\n}\n\n\n\n/*************************************************\n*   Free memory obtained by substring_list_get   *\n*************************************************/\n\n/*\nArgument:     the result of a previous pcre2_substring_list_get()\nReturns:      nothing\n*/\n\nPCRE2_EXP_DEFN void PCRE2_CALL_CONVENTION\npcre2_substring_list_free(PCRE2_SPTR *list)\n{\nif (list != NULL)\n  {\n  pcre2_memctl *memctl = (pcre2_memctl *)((char *)list - sizeof(pcre2_memctl));\n  memctl->free(memctl, memctl->memory_data);\n  }\n}\n\n\n\n/*************************************************\n*     Find (multiple) entries for named string   *\n*************************************************/\n\n/* This function scans the nametable for a given name, using binary chop. It\nreturns either two pointers to the entries in the table, or, if no pointers are\ngiven, the number of a unique group with the given name. If duplicate names are\npermitted, and the name is not unique, an error is generated.\n\nArguments:\n  code        the compiled regex\n  stringname  the name whose entries required\n  firstptr    where to put the pointer to the first entry\n  lastptr     where to put the pointer to the last entry\n\nReturns:      PCRE2_ERROR_NOSUBSTRING if the name is not found\n              otherwise, if firstptr and lastptr are NULL:\n                a group number for a unique substring\n                else PCRE2_ERROR_NOUNIQUESUBSTRING\n              otherwise:\n                the length of each entry, having set firstptr and lastptr\n*/\n\nPCRE2_EXP_DEFN int PCRE2_CALL_CONVENTION\npcre2_substring_nametable_scan(const pcre2_code *code, PCRE2_SPTR stringname,\n  PCRE2_SPTR *firstptr, PCRE2_SPTR *lastptr)\n{\nuint16_t bot = 0;\nuint16_t top = code->name_count;\nuint16_t entrysize = code->name_entry_size;\nPCRE2_SPTR nametable = (PCRE2_SPTR)((char *)code + sizeof(pcre2_real_code));\n\nwhile (top > bot)\n  {\n  uint16_t mid = (top + bot) / 2;\n  PCRE2_SPTR entry = nametable + entrysize*mid;\n  int c = PRIV(strcmp)(stringname, entry + IMM2_SIZE);\n  if (c == 0)\n    {\n    PCRE2_SPTR first;\n    PCRE2_SPTR last;\n    PCRE2_SPTR lastentry;\n    lastentry = nametable + entrysize * (code->name_count - 1);\n    first = last = entry;\n    while (first > nametable)\n      {\n      if (PRIV(strcmp)(stringname, (first - entrysize + IMM2_SIZE)) != 0) break;\n      first -= entrysize;\n      }\n    while (last < lastentry)\n      {\n      if (PRIV(strcmp)(stringname, (last + entrysize + IMM2_SIZE)) != 0) break;\n      last += entrysize;\n      }\n    if (firstptr == NULL) return (first == last)?\n      (int)GET2(entry, 0) : PCRE2_ERROR_NOUNIQUESUBSTRING;\n    *firstptr = first;\n    *lastptr = last;\n    return entrysize;\n    }\n  if (c > 0) bot = mid + 1; else top = mid;\n  }\n\nreturn PCRE2_ERROR_NOSUBSTRING;\n}\n\n\n/*************************************************\n*           Find number for named string         *\n*************************************************/\n\n/* This function is a convenience wrapper for pcre2_substring_nametable_scan()\nwhen it is known that names are unique. If there are duplicate names, it is not\ndefined which number is returned.\n\nArguments:\n  code        the compiled regex\n  stringname  the name whose number is required\n\nReturns:      the number of the named parenthesis, or a negative number\n                PCRE2_ERROR_NOSUBSTRING if not found\n                PCRE2_ERROR_NOUNIQUESUBSTRING if not unique\n*/\n\nPCRE2_EXP_DEFN int PCRE2_CALL_CONVENTION\npcre2_substring_number_from_name(const pcre2_code *code,\n  PCRE2_SPTR stringname)\n{\nreturn pcre2_substring_nametable_scan(code, stringname, NULL, NULL);\n}\n\n/* End of pcre2_substring.c */\n/*autoconv-0001 C:\\projects\\pcre2-10.35\\src\\pcre2_substring.c converted to SUBSTRI2*/\n/*autoconv-0011 SUBSTRI2 line: 43 config.h replaced by CONFIG.h*/\n/*autoconv-0011 SUBSTRI2 line: 46 pcre2_internal.h replaced by INTERNA2.h*/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "TABLES2": {"ttr": 9731, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "\n/*************************************************\n*      Perl-Compatible Regular Expressions       *\n*************************************************/\n\n/* PCRE is a library of functions to support regular expressions whose syntax\nand semantics are as close as possible to those of the Perl 5 language.\n\n                       Written by Philip Hazel\n     Original API code Copyright (c) 1997-2012 University of Cambridge\n          New API code Copyright (c) 2016-2019 University of Cambridge\n\n-----------------------------------------------------------------------------\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n\n    * Redistributions of source code must retain the above copyright notice,\n      this list of conditions and the following disclaimer.\n\n    * Redistributions in binary form must reproduce the above copyright\n      notice, this list of conditions and the following disclaimer in the\n      documentation and/or other materials provided with the distribution.\n\n    * Neither the name of the University of Cambridge nor the names of its\n      contributors may be used to endorse or promote products derived from\n      this software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\nAND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\nIMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\nARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\nLIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\nCONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\nSUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\nINTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\nCONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\nARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\nPOSSIBILITY OF SUCH DAMAGE.\n-----------------------------------------------------------------------------\n*/\n\n/* This module contains some fixed tables that are used by more than one of the\nPCRE2 code modules. The tables are also #included by the pcre2test program,\nwhich uses macros to change their names from _pcre2_xxx to xxxx, thereby\navoiding name clashes with the library. In this case, PCRE2_PCRE2TEST is\ndefined. */\n\n#ifndef PCRE2_PCRE2TEST           /* We're compiling the library */\n#ifdef HAVE_CONFIG_H\n#include \"CONFIG.h\"\n#endif\n#include \"INTERNA2.h\"\n#endif /* PCRE2_PCRE2TEST */\n\n\n/* Table of sizes for the fixed-length opcodes. It's defined in a macro so that\nthe definition is next to the definition of the opcodes in pcre2_internal.h.\nThis is mode-dependent, so is skipped when this file is included by pcre2test. */\n\n#ifndef PCRE2_PCRE2TEST\nconst uint8_t PRIV(OP_lengths)\u00dd\u00a8 = { OP_LENGTHS };\n#endif\n\n/* Tables of horizontal and vertical whitespace characters, suitable for\nadding to classes. */\n\nconst uint32_t PRIV(hspace_list)\u00dd\u00a8 = { HSPACE_LIST };\nconst uint32_t PRIV(vspace_list)\u00dd\u00a8 = { VSPACE_LIST };\n\n/* These tables are the pairs of delimiters that are valid for callout string\narguments. For each starting delimiter there must be a matching ending\ndelimiter, which in fact is different only for bracket-like delimiters. */\n\nconst uint32_t PRIV(callout_start_delims)\u00dd\u00a8 = {\n  CHAR_GRAVE_ACCENT, CHAR_APOSTROPHE, CHAR_QUOTATION_MARK,\n  CHAR_CIRCUMFLEX_ACCENT, CHAR_PERCENT_SIGN, CHAR_NUMBER_SIGN,\n  CHAR_DOLLAR_SIGN, CHAR_LEFT_CURLY_BRACKET, 0 };\n\nconst uint32_t PRIV(callout_end_delims\u00dd\u00a8) = {\n  CHAR_GRAVE_ACCENT, CHAR_APOSTROPHE, CHAR_QUOTATION_MARK,\n  CHAR_CIRCUMFLEX_ACCENT, CHAR_PERCENT_SIGN, CHAR_NUMBER_SIGN,\n  CHAR_DOLLAR_SIGN, CHAR_RIGHT_CURLY_BRACKET, 0 };\n\n\n/*************************************************\n*           Tables for UTF-8 support             *\n*************************************************/\n\n/* These tables are required by pcre2test in 16- or 32-bit mode, as well\nas for the library in 8-bit mode, because pcre2test uses UTF-8 internally for\nhandling wide characters. */\n\n#if defined PCRE2_PCRE2TEST || \\\n   (defined SUPPORT_UNICODE && \\\n    defined PCRE2_CODE_UNIT_WIDTH && \\\n    PCRE2_CODE_UNIT_WIDTH == 8)\n\n/* These are the breakpoints for different numbers of bytes in a UTF-8\ncharacter. */\n\nconst int PRIV(utf8_table1)\u00dd\u00a8 =\n  { 0x7f, 0x7ff, 0xffff, 0x1fffff, 0x3ffffff, 0x7fffffff};\n\nconst int PRIV(utf8_table1_size) = sizeof(PRIV(utf8_table1)) / sizeof(int);\n\n/* These are the indicator bits and the mask for the data bits to set in the\nfirst byte of a character, indexed by the number of additional bytes. */\n\nconst int PRIV(utf8_table2)\u00dd\u00a8 = { 0,    0xc0, 0xe0, 0xf0, 0xf8, 0xfc};\nconst int PRIV(utf8_table3)\u00dd\u00a8 = { 0xff, 0x1f, 0x0f, 0x07, 0x03, 0x01};\n\n/* Table of the number of extra bytes, indexed by the first byte masked with\n0x3f. The highest number for a valid UTF-8 first byte is in fact 0x3d. */\n\nconst uint8_t PRIV(utf8_table4)\u00dd\u00a8 = {\n  1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n  1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n  2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,\n  3,3,3,3,3,3,3,3,4,4,4,4,5,5,5,5 };\n\n#endif /* UTF-8 support needed */\n\n\n#ifdef SUPPORT_UNICODE\n\n/* Table to translate from particular type value to the general value. */\n\nconst uint32_t PRIV(ucp_gentype)\u00dd\u00a8 = {\n  ucp_C, ucp_C, ucp_C, ucp_C, ucp_C,  /* Cc, Cf, Cn, Co, Cs */\n  ucp_L, ucp_L, ucp_L, ucp_L, ucp_L,  /* Ll, Lu, Lm, Lo, Lt */\n  ucp_M, ucp_M, ucp_M,                /* Mc, Me, Mn */\n  ucp_N, ucp_N, ucp_N,                /* Nd, Nl, No */\n  ucp_P, ucp_P, ucp_P, ucp_P, ucp_P,  /* Pc, Pd, Pe, Pf, Pi */\n  ucp_P, ucp_P,                       /* Ps, Po */\n  ucp_S, ucp_S, ucp_S, ucp_S,         /* Sc, Sk, Sm, So */\n  ucp_Z, ucp_Z, ucp_Z                 /* Zl, Zp, Zs */\n};\n\n/* This table encodes the rules for finding the end of an extended grapheme\ncluster. Every code point has a grapheme break property which is one of the\nucp_gbXX values defined in pcre2_ucp.h. These changed between Unicode versions\n10 and 11. The 2-dimensional table is indexed by the properties of two adjacent\ncode points. The left property selects a word from the table, and the right\nproperty selects a bit from that word like this:\n\n  PRIV(ucp_gbtable)\u00ddleft-property\u00a8 & (1u << right-property)\n\nThe value is non-zero if a grapheme break is NOT permitted between the relevant\ntwo code points. The breaking rules are as follows:\n\n1. Break at the start and end of text (pretty obviously).\n\n2. Do not break between a CR and LF; otherwise, break before and after\n   controls.\n\n3. Do not break Hangul syllable sequences, the rules for which are:\n\n    L may be followed by L, V, LV or LVT\n    LV or V may be followed by V or T\n    LVT or T may be followed by T\n\n4. Do not break before extending characters or zero-width-joiner (ZWJ).\n\nThe following rules are only for extended grapheme clusters (but that's what we\nare implementing).\n\n5. Do not break before SpacingMarks.\n\n6. Do not break after Prepend characters.\n\n7. Do not break within emoji modifier sequences or emoji zwj sequences. That\n   is, do not break between characters with the Extended_Pictographic property.\n   Extend and ZWJ characters are allowed between the characters; this cannot be\n   represented in this table, the code has to deal with it.\n\n8. Do not break within emoji flag sequences. That is, do not break between\n   regional indicator (RI) symbols if there are an odd number of RI characters\n   before the break point. This table encodes \"join RI characters\"; the code\n   has to deal with checking for previous adjoining RIs.\n\n9. Otherwise, break everywhere.\n*/\n\n#define ESZ (1<<ucp_gbExtend)|(1<<ucp_gbSpacingMark)|(1<<ucp_gbZWJ)\n\nconst uint32_t PRIV(ucp_gbtable)\u00dd\u00a8 = {\n   (1u<<ucp_gbLF),                                      /*  0 CR */\n   0,                                                   /*  1 LF */\n   0,                                                   /*  2 Control */\n   ESZ,                                                 /*  3 Extend */\n   ESZ|(1u<<ucp_gbPrepend)|                             /*  4 Prepend */\n       (1u<<ucp_gbL)|(1u<<ucp_gbV)|(1u<<ucp_gbT)|\n       (1u<<ucp_gbLV)|(1u<<ucp_gbLVT)|(1u<<ucp_gbOther)|\n       (1u<<ucp_gbRegionalIndicator),\n   ESZ,                                                 /*  5 SpacingMark */\n   ESZ|(1u<<ucp_gbL)|(1u<<ucp_gbV)|(1u<<ucp_gbLV)|      /*  6 L */\n       (1u<<ucp_gbLVT),\n   ESZ|(1u<<ucp_gbV)|(1u<<ucp_gbT),                     /*  7 V */\n   ESZ|(1u<<ucp_gbT),                                   /*  8 T */\n   ESZ|(1u<<ucp_gbV)|(1u<<ucp_gbT),                     /*  9 LV */\n   ESZ|(1u<<ucp_gbT),                                   /* 10 LVT */\n   (1u<<ucp_gbRegionalIndicator),                       /* 11 RegionalIndicator */\n   ESZ,                                                 /* 12 Other */\n   ESZ,                                                 /* 13 ZWJ */\n   ESZ|(1u<<ucp_gbExtended_Pictographic)                /* 14 Extended Pictographic */\n};\n\n#undef ESZ\n\n#ifdef SUPPORT_JIT\n/* This table reverses PRIV(ucp_gentype). We can save the cost\nof a memory load. */\n\nconst int PRIV(ucp_typerange)\u00dd\u00a8 = {\n  ucp_Cc, ucp_Cs,\n  ucp_Ll, ucp_Lu,\n  ucp_Mc, ucp_Mn,\n  ucp_Nd, ucp_No,\n  ucp_Pc, ucp_Ps,\n  ucp_Sc, ucp_So,\n  ucp_Zl, ucp_Zs,\n};\n#endif /* SUPPORT_JIT */\n\n/* The PRIV(utt)\u00dd\u00a8 table below translates Unicode property names into type and\ncode values. It is searched by binary chop, so must be in collating sequence of\nname. Originally, the table contained pointers to the name strings in the first\nfield of each entry. However, that leads to a large number of relocations when\na shared library is dynamically loaded. A significant reduction is made by\nputting all the names into a single, large string and then using offsets in the\ntable itself. Maintenance is more error-prone, but frequent changes to this\ndata are unlikely.\n\nJuly 2008: There is now a script called maint/GenerateUtt.py that can be used\nto generate this data automatically instead of maintaining it by hand.\n\nThe script was updated in March 2009 to generate a new EBCDIC-compliant\nversion. Like all other character and string literals that are compared against\nthe regular expression pattern, we must use STR_ macros instead of literal\nstrings to make sure that UTF-8 support works on EBCDIC platforms. */\n\n#define STRING_Adlam0 STR_A STR_d STR_l STR_a STR_m \"\\0\"\n#define STRING_Ahom0 STR_A STR_h STR_o STR_m \"\\0\"\n#define STRING_Anatolian_Hieroglyphs0 STR_A STR_n STR_a STR_t STR_o STR_l STR_i STR_a STR_n STR_UNDERSCORE STR_H STR_i STR_e STR_r STR_o STR_g STR_l STR_y STR_p STR_h STR_s \"\\0\"\n#define STRING_Any0 STR_A STR_n STR_y \"\\0\"\n#define STRING_Arabic0 STR_A STR_r STR_a STR_b STR_i STR_c \"\\0\"\n#define STRING_Armenian0 STR_A STR_r STR_m STR_e STR_n STR_i STR_a STR_n \"\\0\"\n#define STRING_Avestan0 STR_A STR_v STR_e STR_s STR_t STR_a STR_n \"\\0\"\n#define STRING_Balinese0 STR_B STR_a STR_l STR_i STR_n STR_e STR_s STR_e \"\\0\"\n#define STRING_Bamum0 STR_B STR_a STR_m STR_u STR_m \"\\0\"\n#define STRING_Bassa_Vah0 STR_B STR_a STR_s STR_s STR_a STR_UNDERSCORE STR_V STR_a STR_h \"\\0\"\n#define STRING_Batak0 STR_B STR_a STR_t STR_a STR_k \"\\0\"\n#define STRING_Bengali0 STR_B STR_e STR_n STR_g STR_a STR_l STR_i \"\\0\"\n#define STRING_Bhaiksuki0 STR_B STR_h STR_a STR_i STR_k STR_s STR_u STR_k STR_i \"\\0\"\n#define STRING_Bopomofo0 STR_B STR_o STR_p STR_o STR_m STR_o STR_f STR_o \"\\0\"\n#define STRING_Brahmi0 STR_B STR_r STR_a STR_h STR_m STR_i \"\\0\"\n#define STRING_Braille0 STR_B STR_r STR_a STR_i STR_l STR_l STR_e \"\\0\"\n#define STRING_Buginese0 STR_B STR_u STR_g STR_i STR_n STR_e STR_s STR_e \"\\0\"\n#define STRING_Buhid0 STR_B STR_u STR_h STR_i STR_d \"\\0\"\n#define STRING_C0 STR_C \"\\0\"\n#define STRING_Canadian_Aboriginal0 STR_C STR_a STR_n STR_a STR_d STR_i STR_a STR_n STR_UNDERSCORE STR_A STR_b STR_o STR_r STR_i STR_g STR_i STR_n STR_a STR_l \"\\0\"\n#define STRING_Carian0 STR_C STR_a STR_r STR_i STR_a STR_n \"\\0\"\n#define STRING_Caucasian_Albanian0 STR_C STR_a STR_u STR_c STR_a STR_s STR_i STR_a STR_n STR_UNDERSCORE STR_A STR_l STR_b STR_a STR_n STR_i STR_a STR_n \"\\0\"\n#define STRING_Cc0 STR_C STR_c \"\\0\"\n#define STRING_Cf0 STR_C STR_f \"\\0\"\n#define STRING_Chakma0 STR_C STR_h STR_a STR_k STR_m STR_a \"\\0\"\n#define STRING_Cham0 STR_C STR_h STR_a STR_m \"\\0\"\n#define STRING_Cherokee0 STR_C STR_h STR_e STR_r STR_o STR_k STR_e STR_e \"\\0\"\n#define STRING_Chorasmian0 STR_C STR_h STR_o STR_r STR_a STR_s STR_m STR_i STR_a STR_n \"\\0\"\n#define STRING_Cn0 STR_C STR_n \"\\0\"\n#define STRING_Co0 STR_C STR_o \"\\0\"\n#define STRING_Common0 STR_C STR_o STR_m STR_m STR_o STR_n \"\\0\"\n#define STRING_Coptic0 STR_C STR_o STR_p STR_t STR_i STR_c \"\\0\"\n#define STRING_Cs0 STR_C STR_s \"\\0\"\n#define STRING_Cuneiform0 STR_C STR_u STR_n STR_e STR_i STR_f STR_o STR_r STR_m \"\\0\"\n#define STRING_Cypriot0 STR_C STR_y STR_p STR_r STR_i STR_o STR_t \"\\0\"\n#define STRING_Cyrillic0 STR_C STR_y STR_r STR_i STR_l STR_l STR_i STR_c \"\\0\"\n#define STRING_Deseret0 STR_D STR_e STR_s STR_e STR_r STR_e STR_t \"\\0\"\n#define STRING_Devanagari0 STR_D STR_e STR_v STR_a STR_n STR_a STR_g STR_a STR_r STR_i \"\\0\"\n#define STRING_Dives_Akuru0 STR_D STR_i STR_v STR_e STR_s STR_UNDERSCORE STR_A STR_k STR_u STR_r STR_u \"\\0\"\n#define STRING_Dogra0 STR_D STR_o STR_g STR_r STR_a \"\\0\"\n#define STRING_Duployan0 STR_D STR_u STR_p STR_l STR_o STR_y STR_a STR_n \"\\0\"\n#define STRING_Egyptian_Hieroglyphs0 STR_E STR_g STR_y STR_p STR_t STR_i STR_a STR_n STR_UNDERSCORE STR_H STR_i STR_e STR_r STR_o STR_g STR_l STR_y STR_p STR_h STR_s \"\\0\"\n#define STRING_Elbasan0 STR_E STR_l STR_b STR_a STR_s STR_a STR_n \"\\0\"\n#define STRING_Elymaic0 STR_E STR_l STR_y STR_m STR_a STR_i STR_c \"\\0\"\n#define STRING_Ethiopic0 STR_E STR_t STR_h STR_i STR_o STR_p STR_i STR_c \"\\0\"\n#define STRING_Georgian0 STR_G STR_e STR_o STR_r STR_g STR_i STR_a STR_n \"\\0\"\n#define STRING_Glagolitic0 STR_G STR_l STR_a STR_g STR_o STR_l STR_i STR_t STR_i STR_c \"\\0\"\n#define STRING_Gothic0 STR_G STR_o STR_t STR_h STR_i STR_c \"\\0\"\n#define STRING_Grantha0 STR_G STR_r STR_a STR_n STR_t STR_h STR_a \"\\0\"\n#define STRING_Greek0 STR_G STR_r STR_e STR_e STR_k \"\\0\"\n#define STRING_Gujarati0 STR_G STR_u STR_j STR_a STR_r STR_a STR_t STR_i \"\\0\"\n#define STRING_Gunjala_Gondi0 STR_G STR_u STR_n STR_j STR_a STR_l STR_a STR_UNDERSCORE STR_G STR_o STR_n STR_d STR_i \"\\0\"\n#define STRING_Gurmukhi0 STR_G STR_u STR_r STR_m STR_u STR_k STR_h STR_i \"\\0\"\n#define STRING_Han0 STR_H STR_a STR_n \"\\0\"\n#define STRING_Hangul0 STR_H STR_a STR_n STR_g STR_u STR_l \"\\0\"\n#define STRING_Hanifi_Rohingya0 STR_H STR_a STR_n STR_i STR_f STR_i STR_UNDERSCORE STR_R STR_o STR_h STR_i STR_n STR_g STR_y STR_a \"\\0\"\n#define STRING_Hanunoo0 STR_H STR_a STR_n STR_u STR_n STR_o STR_o \"\\0\"\n#define STRING_Hatran0 STR_H STR_a STR_t STR_r STR_a STR_n \"\\0\"\n#define STRING_Hebrew0 STR_H STR_e STR_b STR_r STR_e STR_w \"\\0\"\n#define STRING_Hiragana0 STR_H STR_i STR_r STR_a STR_g STR_a STR_n STR_a \"\\0\"\n#define STRING_Imperial_Aramaic0 STR_I STR_m STR_p STR_e STR_r STR_i STR_a STR_l STR_UNDERSCORE STR_A STR_r STR_a STR_m STR_a STR_i STR_c \"\\0\"\n#define STRING_Inherited0 STR_I STR_n STR_h STR_e STR_r STR_i STR_t STR_e STR_d \"\\0\"\n#define STRING_Inscriptional_Pahlavi0 STR_I STR_n STR_s STR_c STR_r STR_i STR_p STR_t STR_i STR_o STR_n STR_a STR_l STR_UNDERSCORE STR_P STR_a STR_h STR_l STR_a STR_v STR_i \"\\0\"\n#define STRING_Inscriptional_Parthian0 STR_I STR_n STR_s STR_c STR_r STR_i STR_p STR_t STR_i STR_o STR_n STR_a STR_l STR_UNDERSCORE STR_P STR_a STR_r STR_t STR_h STR_i STR_a STR_n \"\\0\"\n#define STRING_Javanese0 STR_J STR_a STR_v STR_a STR_n STR_e STR_s STR_e \"\\0\"\n#define STRING_Kaithi0 STR_K STR_a STR_i STR_t STR_h STR_i \"\\0\"\n#define STRING_Kannada0 STR_K STR_a STR_n STR_n STR_a STR_d STR_a \"\\0\"\n#define STRING_Katakana0 STR_K STR_a STR_t STR_a STR_k STR_a STR_n STR_a \"\\0\"\n#define STRING_Kayah_Li0 STR_K STR_a STR_y STR_a STR_h STR_UNDERSCORE STR_L STR_i \"\\0\"\n#define STRING_Kharoshthi0 STR_K STR_h STR_a STR_r STR_o STR_s STR_h STR_t STR_h STR_i \"\\0\"\n#define STRING_Khitan_Small_Script0 STR_K STR_h STR_i STR_t STR_a STR_n STR_UNDERSCORE STR_S STR_m STR_a STR_l STR_l STR_UNDERSCORE STR_S STR_c STR_r STR_i STR_p STR_t \"\\0\"\n#define STRING_Khmer0 STR_K STR_h STR_m STR_e STR_r \"\\0\"\n#define STRING_Khojki0 STR_K STR_h STR_o STR_j STR_k STR_i \"\\0\"\n#define STRING_Khudawadi0 STR_K STR_h STR_u STR_d STR_a STR_w STR_a STR_d STR_i \"\\0\"\n#define STRING_L0 STR_L \"\\0\"\n#define STRING_L_AMPERSAND0 STR_L STR_AMPERSAND \"\\0\"\n#define STRING_Lao0 STR_L STR_a STR_o \"\\0\"\n#define STRING_Latin0 STR_L STR_a STR_t STR_i STR_n \"\\0\"\n#define STRING_Lepcha0 STR_L STR_e STR_p STR_c STR_h STR_a \"\\0\"\n#define STRING_Limbu0 STR_L STR_i STR_m STR_b STR_u \"\\0\"\n#define STRING_Linear_A0 STR_L STR_i STR_n STR_e STR_a STR_r STR_UNDERSCORE STR_A \"\\0\"\n#define STRING_Linear_B0 STR_L STR_i STR_n STR_e STR_a STR_r STR_UNDERSCORE STR_B \"\\0\"\n#define STRING_Lisu0 STR_L STR_i STR_s STR_u \"\\0\"\n#define STRING_Ll0 STR_L STR_l \"\\0\"\n#define STRING_Lm0 STR_L STR_m \"\\0\"\n#define STRING_Lo0 STR_L STR_o \"\\0\"\n#define STRING_Lt0 STR_L STR_t \"\\0\"\n#define STRING_Lu0 STR_L STR_u \"\\0\"\n#define STRING_Lycian0 STR_L STR_y STR_c STR_i STR_a STR_n \"\\0\"\n#define STRING_Lydian0 STR_L STR_y STR_d STR_i STR_a STR_n \"\\0\"\n#define STRING_M0 STR_M \"\\0\"\n#define STRING_Mahajani0 STR_M STR_a STR_h STR_a STR_j STR_a STR_n STR_i \"\\0\"\n#define STRING_Makasar0 STR_M STR_a STR_k STR_a STR_s STR_a STR_r \"\\0\"\n#define STRING_Malayalam0 STR_M STR_a STR_l STR_a STR_y STR_a STR_l STR_a STR_m \"\\0\"\n#define STRING_Mandaic0 STR_M STR_a STR_n STR_d STR_a STR_i STR_c \"\\0\"\n#define STRING_Manichaean0 STR_M STR_a STR_n STR_i STR_c STR_h STR_a STR_e STR_a STR_n \"\\0\"\n#define STRING_Marchen0 STR_M STR_a STR_r STR_c STR_h STR_e STR_n \"\\0\"\n#define STRING_Masaram_Gondi0 STR_M STR_a STR_s STR_a STR_r STR_a STR_m STR_UNDERSCORE STR_G STR_o STR_n STR_d STR_i \"\\0\"\n#define STRING_Mc0 STR_M STR_c \"\\0\"\n#define STRING_Me0 STR_M STR_e \"\\0\"\n#define STRING_Medefaidrin0 STR_M STR_e STR_d STR_e STR_f STR_a STR_i STR_d STR_r STR_i STR_n \"\\0\"\n#define STRING_Meetei_Mayek0 STR_M STR_e STR_e STR_t STR_e STR_i STR_UNDERSCORE STR_M STR_a STR_y STR_e STR_k \"\\0\"\n#define STRING_Mende_Kikakui0 STR_M STR_e STR_n STR_d STR_e STR_UNDERSCORE STR_K STR_i STR_k STR_a STR_k STR_u STR_i \"\\0\"\n#define STRING_Meroitic_Cursive0 STR_M STR_e STR_r STR_o STR_i STR_t STR_i STR_c STR_UNDERSCORE STR_C STR_u STR_r STR_s STR_i STR_v STR_e \"\\0\"\n#define STRING_Meroitic_Hieroglyphs0 STR_M STR_e STR_r STR_o STR_i STR_t STR_i STR_c STR_UNDERSCORE STR_H STR_i STR_e STR_r STR_o STR_g STR_l STR_y STR_p STR_h STR_s \"\\0\"\n#define STRING_Miao0 STR_M STR_i STR_a STR_o \"\\0\"\n#define STRING_Mn0 STR_M STR_n \"\\0\"\n#define STRING_Modi0 STR_M STR_o STR_d STR_i \"\\0\"\n#define STRING_Mongolian0 STR_M STR_o STR_n STR_g STR_o STR_l STR_i STR_a STR_n \"\\0\"\n#define STRING_Mro0 STR_M STR_r STR_o \"\\0\"\n#define STRING_Multani0 STR_M STR_u STR_l STR_t STR_a STR_n STR_i \"\\0\"\n#define STRING_Myanmar0 STR_M STR_y STR_a STR_n STR_m STR_a STR_r \"\\0\"\n#define STRING_N0 STR_N \"\\0\"\n#define STRING_Nabataean0 STR_N STR_a STR_b STR_a STR_t STR_a STR_e STR_a STR_n \"\\0\"\n#define STRING_Nandinagari0 STR_N STR_a STR_n STR_d STR_i STR_n STR_a STR_g STR_a STR_r STR_i \"\\0\"\n#define STRING_Nd0 STR_N STR_d \"\\0\"\n#define STRING_New_Tai_Lue0 STR_N STR_e STR_w STR_UNDERSCORE STR_T STR_a STR_i STR_UNDERSCORE STR_L STR_u STR_e \"\\0\"\n#define STRING_Newa0 STR_N STR_e STR_w STR_a \"\\0\"\n#define STRING_Nko0 STR_N STR_k STR_o \"\\0\"\n#define STRING_Nl0 STR_N STR_l \"\\0\"\n#define STRING_No0 STR_N STR_o \"\\0\"\n#define STRING_Nushu0 STR_N STR_u STR_s STR_h STR_u \"\\0\"\n#define STRING_Nyiakeng_Puachue_Hmong0 STR_N STR_y STR_i STR_a STR_k STR_e STR_n STR_g STR_UNDERSCORE STR_P STR_u STR_a STR_c STR_h STR_u STR_e STR_UNDERSCORE STR_H STR_m STR_o STR_n STR_g \"\\0\"\n#define STRING_Ogham0 STR_O STR_g STR_h STR_a STR_m \"\\0\"\n#define STRING_Ol_Chiki0 STR_O STR_l STR_UNDERSCORE STR_C STR_h STR_i STR_k STR_i \"\\0\"\n#define STRING_Old_Hungarian0 STR_O STR_l STR_d STR_UNDERSCORE STR_H STR_u STR_n STR_g STR_a STR_r STR_i STR_a STR_n \"\\0\"\n#define STRING_Old_Italic0 STR_O STR_l STR_d STR_UNDERSCORE STR_I STR_t STR_a STR_l STR_i STR_c \"\\0\"\n#define STRING_Old_North_Arabian0 STR_O STR_l STR_d STR_UNDERSCORE STR_N STR_o STR_r STR_t STR_h STR_UNDERSCORE STR_A STR_r STR_a STR_b STR_i STR_a STR_n \"\\0\"\n#define STRING_Old_Permic0 STR_O STR_l STR_d STR_UNDERSCORE STR_P STR_e STR_r STR_m STR_i STR_c \"\\0\"\n#define STRING_Old_Persian0 STR_O STR_l STR_d STR_UNDERSCORE STR_P STR_e STR_r STR_s STR_i STR_a STR_n \"\\0\"\n#define STRING_Old_Sogdian0 STR_O STR_l STR_d STR_UNDERSCORE STR_S STR_o STR_g STR_d STR_i STR_a STR_n \"\\0\"\n#define STRING_Old_South_Arabian0 STR_O STR_l STR_d STR_UNDERSCORE STR_S STR_o STR_u STR_t STR_h STR_UNDERSCORE STR_A STR_r STR_a STR_b STR_i STR_a STR_n \"\\0\"\n#define STRING_Old_Turkic0 STR_O STR_l STR_d STR_UNDERSCORE STR_T STR_u STR_r STR_k STR_i STR_c \"\\0\"\n#define STRING_Oriya0 STR_O STR_r STR_i STR_y STR_a \"\\0\"\n#define STRING_Osage0 STR_O STR_s STR_a STR_g STR_e \"\\0\"\n#define STRING_Osmanya0 STR_O STR_s STR_m STR_a STR_n STR_y STR_a \"\\0\"\n#define STRING_P0 STR_P \"\\0\"\n#define STRING_Pahawh_Hmong0 STR_P STR_a STR_h STR_a STR_w STR_h STR_UNDERSCORE STR_H STR_m STR_o STR_n STR_g \"\\0\"\n#define STRING_Palmyrene0 STR_P STR_a STR_l STR_m STR_y STR_r STR_e STR_n STR_e \"\\0\"\n#define STRING_Pau_Cin_Hau0 STR_P STR_a STR_u STR_UNDERSCORE STR_C STR_i STR_n STR_UNDERSCORE STR_H STR_a STR_u \"\\0\"\n#define STRING_Pc0 STR_P STR_c \"\\0\"\n#define STRING_Pd0 STR_P STR_d \"\\0\"\n#define STRING_Pe0 STR_P STR_e \"\\0\"\n#define STRING_Pf0 STR_P STR_f \"\\0\"\n#define STRING_Phags_Pa0 STR_P STR_h STR_a STR_g STR_s STR_UNDERSCORE STR_P STR_a \"\\0\"\n#define STRING_Phoenician0 STR_P STR_h STR_o STR_e STR_n STR_i STR_c STR_i STR_a STR_n \"\\0\"\n#define STRING_Pi0 STR_P STR_i \"\\0\"\n#define STRING_Po0 STR_P STR_o \"\\0\"\n#define STRING_Ps0 STR_P STR_s \"\\0\"\n#define STRING_Psalter_Pahlavi0 STR_P STR_s STR_a STR_l STR_t STR_e STR_r STR_UNDERSCORE STR_P STR_a STR_h STR_l STR_a STR_v STR_i \"\\0\"\n#define STRING_Rejang0 STR_R STR_e STR_j STR_a STR_n STR_g \"\\0\"\n#define STRING_Runic0 STR_R STR_u STR_n STR_i STR_c \"\\0\"\n#define STRING_S0 STR_S \"\\0\"\n#define STRING_Samaritan0 STR_S STR_a STR_m STR_a STR_r STR_i STR_t STR_a STR_n \"\\0\"\n#define STRING_Saurashtra0 STR_S STR_a STR_u STR_r STR_a STR_s STR_h STR_t STR_r STR_a \"\\0\"\n#define STRING_Sc0 STR_S STR_c \"\\0\"\n#define STRING_Sharada0 STR_S STR_h STR_a STR_r STR_a STR_d STR_a \"\\0\"\n#define STRING_Shavian0 STR_S STR_h STR_a STR_v STR_i STR_a STR_n \"\\0\"\n#define STRING_Siddham0 STR_S STR_i STR_d STR_d STR_h STR_a STR_m \"\\0\"\n#define STRING_SignWriting0 STR_S STR_i STR_g STR_n STR_W STR_r STR_i STR_t STR_i STR_n STR_g \"\\0\"\n#define STRING_Sinhala0 STR_S STR_i STR_n STR_h STR_a STR_l STR_a \"\\0\"\n#define STRING_Sk0 STR_S STR_k \"\\0\"\n#define STRING_Sm0 STR_S STR_m \"\\0\"\n#define STRING_So0 STR_S STR_o \"\\0\"\n#define STRING_Sogdian0 STR_S STR_o STR_g STR_d STR_i STR_a STR_n \"\\0\"\n#define STRING_Sora_Sompeng0 STR_S STR_o STR_r STR_a STR_UNDERSCORE STR_S STR_o STR_m STR_p STR_e STR_n STR_g \"\\0\"\n#define STRING_Soyombo0 STR_S STR_o STR_y STR_o STR_m STR_b STR_o \"\\0\"\n#define STRING_Sundanese0 STR_S STR_u STR_n STR_d STR_a STR_n STR_e STR_s STR_e \"\\0\"\n#define STRING_Syloti_Nagri0 STR_S STR_y STR_l STR_o STR_t STR_i STR_UNDERSCORE STR_N STR_a STR_g STR_r STR_i \"\\0\"\n#define STRING_Syriac0 STR_S STR_y STR_r STR_i STR_a STR_c \"\\0\"\n#define STRING_Tagalog0 STR_T STR_a STR_g STR_a STR_l STR_o STR_g \"\\0\"\n#define STRING_Tagbanwa0 STR_T STR_a STR_g STR_b STR_a STR_n STR_w STR_a \"\\0\"\n#define STRING_Tai_Le0 STR_T STR_a STR_i STR_UNDERSCORE STR_L STR_e \"\\0\"\n#define STRING_Tai_Tham0 STR_T STR_a STR_i STR_UNDERSCORE STR_T STR_h STR_a STR_m \"\\0\"\n#define STRING_Tai_Viet0 STR_T STR_a STR_i STR_UNDERSCORE STR_V STR_i STR_e STR_t \"\\0\"\n#define STRING_Takri0 STR_T STR_a STR_k STR_r STR_i \"\\0\"\n#define STRING_Tamil0 STR_T STR_a STR_m STR_i STR_l \"\\0\"\n#define STRING_Tangut0 STR_T STR_a STR_n STR_g STR_u STR_t \"\\0\"\n#define STRING_Telugu0 STR_T STR_e STR_l STR_u STR_g STR_u \"\\0\"\n#define STRING_Thaana0 STR_T STR_h STR_a STR_a STR_n STR_a \"\\0\"\n#define STRING_Thai0 STR_T STR_h STR_a STR_i \"\\0\"\n#define STRING_Tibetan0 STR_T STR_i STR_b STR_e STR_t STR_a STR_n \"\\0\"\n#define STRING_Tifinagh0 STR_T STR_i STR_f STR_i STR_n STR_a STR_g STR_h \"\\0\"\n#define STRING_Tirhuta0 STR_T STR_i STR_r STR_h STR_u STR_t STR_a \"\\0\"\n#define STRING_Ugaritic0 STR_U STR_g STR_a STR_r STR_i STR_t STR_i STR_c \"\\0\"\n#define STRING_Unknown0 STR_U STR_n STR_k STR_n STR_o STR_w STR_n \"\\0\"\n#define STRING_Vai0 STR_V STR_a STR_i \"\\0\"\n#define STRING_Wancho0 STR_W STR_a STR_n STR_c STR_h STR_o \"\\0\"\n#define STRING_Warang_Citi0 STR_W STR_a STR_r STR_a STR_n STR_g STR_UNDERSCORE STR_C STR_i STR_t STR_i \"\\0\"\n#define STRING_Xan0 STR_X STR_a STR_n \"\\0\"\n#define STRING_Xps0 STR_X STR_p STR_s \"\\0\"\n#define STRING_Xsp0 STR_X STR_s STR_p \"\\0\"\n#define STRING_Xuc0 STR_X STR_u STR_c \"\\0\"\n#define STRING_Xwd0 STR_X STR_w STR_d \"\\0\"\n#define STRING_Yezidi0 STR_Y STR_e STR_z STR_i STR_d STR_i \"\\0\"\n#define STRING_Yi0 STR_Y STR_i \"\\0\"\n#define STRING_Z0 STR_Z \"\\0\"\n#define STRING_Zanabazar_Square0 STR_Z STR_a STR_n STR_a STR_b STR_a STR_z STR_a STR_r STR_UNDERSCORE STR_S STR_q STR_u STR_a STR_r STR_e \"\\0\"\n#define STRING_Zl0 STR_Z STR_l \"\\0\"\n#define STRING_Zp0 STR_Z STR_p \"\\0\"\n#define STRING_Zs0 STR_Z STR_s \"\\0\"\n\nconst char PRIV(utt_names)\u00dd\u00a8 =\n  STRING_Adlam0\n  STRING_Ahom0\n  STRING_Anatolian_Hieroglyphs0\n  STRING_Any0\n  STRING_Arabic0\n  STRING_Armenian0\n  STRING_Avestan0\n  STRING_Balinese0\n  STRING_Bamum0\n  STRING_Bassa_Vah0\n  STRING_Batak0\n  STRING_Bengali0\n  STRING_Bhaiksuki0\n  STRING_Bopomofo0\n  STRING_Brahmi0\n  STRING_Braille0\n  STRING_Buginese0\n  STRING_Buhid0\n  STRING_C0\n  STRING_Canadian_Aboriginal0\n  STRING_Carian0\n  STRING_Caucasian_Albanian0\n  STRING_Cc0\n  STRING_Cf0\n  STRING_Chakma0\n  STRING_Cham0\n  STRING_Cherokee0\n  STRING_Chorasmian0\n  STRING_Cn0\n  STRING_Co0\n  STRING_Common0\n  STRING_Coptic0\n  STRING_Cs0\n  STRING_Cuneiform0\n  STRING_Cypriot0\n  STRING_Cyrillic0\n  STRING_Deseret0\n  STRING_Devanagari0\n  STRING_Dives_Akuru0\n  STRING_Dogra0\n  STRING_Duployan0\n  STRING_Egyptian_Hieroglyphs0\n  STRING_Elbasan0\n  STRING_Elymaic0\n  STRING_Ethiopic0\n  STRING_Georgian0\n  STRING_Glagolitic0\n  STRING_Gothic0\n  STRING_Grantha0\n  STRING_Greek0\n  STRING_Gujarati0\n  STRING_Gunjala_Gondi0\n  STRING_Gurmukhi0\n  STRING_Han0\n  STRING_Hangul0\n  STRING_Hanifi_Rohingya0\n  STRING_Hanunoo0\n  STRING_Hatran0\n  STRING_Hebrew0\n  STRING_Hiragana0\n  STRING_Imperial_Aramaic0\n  STRING_Inherited0\n  STRING_Inscriptional_Pahlavi0\n  STRING_Inscriptional_Parthian0\n  STRING_Javanese0\n  STRING_Kaithi0\n  STRING_Kannada0\n  STRING_Katakana0\n  STRING_Kayah_Li0\n  STRING_Kharoshthi0\n  STRING_Khitan_Small_Script0\n  STRING_Khmer0\n  STRING_Khojki0\n  STRING_Khudawadi0\n  STRING_L0\n  STRING_L_AMPERSAND0\n  STRING_Lao0\n  STRING_Latin0\n  STRING_Lepcha0\n  STRING_Limbu0\n  STRING_Linear_A0\n  STRING_Linear_B0\n  STRING_Lisu0\n  STRING_Ll0\n  STRING_Lm0\n  STRING_Lo0\n  STRING_Lt0\n  STRING_Lu0\n  STRING_Lycian0\n  STRING_Lydian0\n  STRING_M0\n  STRING_Mahajani0\n  STRING_Makasar0\n  STRING_Malayalam0\n  STRING_Mandaic0\n  STRING_Manichaean0\n  STRING_Marchen0\n  STRING_Masaram_Gondi0\n  STRING_Mc0\n  STRING_Me0\n  STRING_Medefaidrin0\n  STRING_Meetei_Mayek0\n  STRING_Mende_Kikakui0\n  STRING_Meroitic_Cursive0\n  STRING_Meroitic_Hieroglyphs0\n  STRING_Miao0\n  STRING_Mn0\n  STRING_Modi0\n  STRING_Mongolian0\n  STRING_Mro0\n  STRING_Multani0\n  STRING_Myanmar0\n  STRING_N0\n  STRING_Nabataean0\n  STRING_Nandinagari0\n  STRING_Nd0\n  STRING_New_Tai_Lue0\n  STRING_Newa0\n  STRING_Nko0\n  STRING_Nl0\n  STRING_No0\n  STRING_Nushu0\n  STRING_Nyiakeng_Puachue_Hmong0\n  STRING_Ogham0\n  STRING_Ol_Chiki0\n  STRING_Old_Hungarian0\n  STRING_Old_Italic0\n  STRING_Old_North_Arabian0\n  STRING_Old_Permic0\n  STRING_Old_Persian0\n  STRING_Old_Sogdian0\n  STRING_Old_South_Arabian0\n  STRING_Old_Turkic0\n  STRING_Oriya0\n  STRING_Osage0\n  STRING_Osmanya0\n  STRING_P0\n  STRING_Pahawh_Hmong0\n  STRING_Palmyrene0\n  STRING_Pau_Cin_Hau0\n  STRING_Pc0\n  STRING_Pd0\n  STRING_Pe0\n  STRING_Pf0\n  STRING_Phags_Pa0\n  STRING_Phoenician0\n  STRING_Pi0\n  STRING_Po0\n  STRING_Ps0\n  STRING_Psalter_Pahlavi0\n  STRING_Rejang0\n  STRING_Runic0\n  STRING_S0\n  STRING_Samaritan0\n  STRING_Saurashtra0\n  STRING_Sc0\n  STRING_Sharada0\n  STRING_Shavian0\n  STRING_Siddham0\n  STRING_SignWriting0\n  STRING_Sinhala0\n  STRING_Sk0\n  STRING_Sm0\n  STRING_So0\n  STRING_Sogdian0\n  STRING_Sora_Sompeng0\n  STRING_Soyombo0\n  STRING_Sundanese0\n  STRING_Syloti_Nagri0\n  STRING_Syriac0\n  STRING_Tagalog0\n  STRING_Tagbanwa0\n  STRING_Tai_Le0\n  STRING_Tai_Tham0\n  STRING_Tai_Viet0\n  STRING_Takri0\n  STRING_Tamil0\n  STRING_Tangut0\n  STRING_Telugu0\n  STRING_Thaana0\n  STRING_Thai0\n  STRING_Tibetan0\n  STRING_Tifinagh0\n  STRING_Tirhuta0\n  STRING_Ugaritic0\n  STRING_Unknown0\n  STRING_Vai0\n  STRING_Wancho0\n  STRING_Warang_Citi0\n  STRING_Xan0\n  STRING_Xps0\n  STRING_Xsp0\n  STRING_Xuc0\n  STRING_Xwd0\n  STRING_Yezidi0\n  STRING_Yi0\n  STRING_Z0\n  STRING_Zanabazar_Square0\n  STRING_Zl0\n  STRING_Zp0\n  STRING_Zs0;\n\nconst ucp_type_table PRIV(utt)\u00dd\u00a8 = {\n  {   0, PT_SC, ucp_Adlam },\n  {   6, PT_SC, ucp_Ahom },\n  {  11, PT_SC, ucp_Anatolian_Hieroglyphs },\n  {  33, PT_ANY, 0 },\n  {  37, PT_SC, ucp_Arabic },\n  {  44, PT_SC, ucp_Armenian },\n  {  53, PT_SC, ucp_Avestan },\n  {  61, PT_SC, ucp_Balinese },\n  {  70, PT_SC, ucp_Bamum },\n  {  76, PT_SC, ucp_Bassa_Vah },\n  {  86, PT_SC, ucp_Batak },\n  {  92, PT_SC, ucp_Bengali },\n  { 100, PT_SC, ucp_Bhaiksuki },\n  { 110, PT_SC, ucp_Bopomofo },\n  { 119, PT_SC, ucp_Brahmi },\n  { 126, PT_SC, ucp_Braille },\n  { 134, PT_SC, ucp_Buginese },\n  { 143, PT_SC, ucp_Buhid },\n  { 149, PT_GC, ucp_C },\n  { 151, PT_SC, ucp_Canadian_Aboriginal },\n  { 171, PT_SC, ucp_Carian },\n  { 178, PT_SC, ucp_Caucasian_Albanian },\n  { 197, PT_PC, ucp_Cc },\n  { 200, PT_PC, ucp_Cf },\n  { 203, PT_SC, ucp_Chakma },\n  { 210, PT_SC, ucp_Cham },\n  { 215, PT_SC, ucp_Cherokee },\n  { 224, PT_SC, ucp_Chorasmian },\n  { 235, PT_PC, ucp_Cn },\n  { 238, PT_PC, ucp_Co },\n  { 241, PT_SC, ucp_Common },\n  { 248, PT_SC, ucp_Coptic },\n  { 255, PT_PC, ucp_Cs },\n  { 258, PT_SC, ucp_Cuneiform },\n  { 268, PT_SC, ucp_Cypriot },\n  { 276, PT_SC, ucp_Cyrillic },\n  { 285, PT_SC, ucp_Deseret },\n  { 293, PT_SC, ucp_Devanagari },\n  { 304, PT_SC, ucp_Dives_Akuru },\n  { 316, PT_SC, ucp_Dogra },\n  { 322, PT_SC, ucp_Duployan },\n  { 331, PT_SC, ucp_Egyptian_Hieroglyphs },\n  { 352, PT_SC, ucp_Elbasan },\n  { 360, PT_SC, ucp_Elymaic },\n  { 368, PT_SC, ucp_Ethiopic },\n  { 377, PT_SC, ucp_Georgian },\n  { 386, PT_SC, ucp_Glagolitic },\n  { 397, PT_SC, ucp_Gothic },\n  { 404, PT_SC, ucp_Grantha },\n  { 412, PT_SC, ucp_Greek },\n  { 418, PT_SC, ucp_Gujarati },\n  { 427, PT_SC, ucp_Gunjala_Gondi },\n  { 441, PT_SC, ucp_Gurmukhi },\n  { 450, PT_SC, ucp_Han },\n  { 454, PT_SC, ucp_Hangul },\n  { 461, PT_SC, ucp_Hanifi_Rohingya },\n  { 477, PT_SC, ucp_Hanunoo },\n  { 485, PT_SC, ucp_Hatran },\n  { 492, PT_SC, ucp_Hebrew },\n  { 499, PT_SC, ucp_Hiragana },\n  { 508, PT_SC, ucp_Imperial_Aramaic },\n  { 525, PT_SC, ucp_Inherited },\n  { 535, PT_SC, ucp_Inscriptional_Pahlavi },\n  { 557, PT_SC, ucp_Inscriptional_Parthian },\n  { 580, PT_SC, ucp_Javanese },\n  { 589, PT_SC, ucp_Kaithi },\n  { 596, PT_SC, ucp_Kannada },\n  { 604, PT_SC, ucp_Katakana },\n  { 613, PT_SC, ucp_Kayah_Li },\n  { 622, PT_SC, ucp_Kharoshthi },\n  { 633, PT_SC, ucp_Khitan_Small_Script },\n  { 653, PT_SC, ucp_Khmer },\n  { 659, PT_SC, ucp_Khojki },\n  { 666, PT_SC, ucp_Khudawadi },\n  { 676, PT_GC, ucp_L },\n  { 678, PT_LAMP, 0 },\n  { 681, PT_SC, ucp_Lao },\n  { 685, PT_SC, ucp_Latin },\n  { 691, PT_SC, ucp_Lepcha },\n  { 698, PT_SC, ucp_Limbu },\n  { 704, PT_SC, ucp_Linear_A },\n  { 713, PT_SC, ucp_Linear_B },\n  { 722, PT_SC, ucp_Lisu },\n  { 727, PT_PC, ucp_Ll },\n  { 730, PT_PC, ucp_Lm },\n  { 733, PT_PC, ucp_Lo },\n  { 736, PT_PC, ucp_Lt },\n  { 739, PT_PC, ucp_Lu },\n  { 742, PT_SC, ucp_Lycian },\n  { 749, PT_SC, ucp_Lydian },\n  { 756, PT_GC, ucp_M },\n  { 758, PT_SC, ucp_Mahajani },\n  { 767, PT_SC, ucp_Makasar },\n  { 775, PT_SC, ucp_Malayalam },\n  { 785, PT_SC, ucp_Mandaic },\n  { 793, PT_SC, ucp_Manichaean },\n  { 804, PT_SC, ucp_Marchen },\n  { 812, PT_SC, ucp_Masaram_Gondi },\n  { 826, PT_PC, ucp_Mc },\n  { 829, PT_PC, ucp_Me },\n  { 832, PT_SC, ucp_Medefaidrin },\n  { 844, PT_SC, ucp_Meetei_Mayek },\n  { 857, PT_SC, ucp_Mende_Kikakui },\n  { 871, PT_SC, ucp_Meroitic_Cursive },\n  { 888, PT_SC, ucp_Meroitic_Hieroglyphs },\n  { 909, PT_SC, ucp_Miao },\n  { 914, PT_PC, ucp_Mn },\n  { 917, PT_SC, ucp_Modi },\n  { 922, PT_SC, ucp_Mongolian },\n  { 932, PT_SC, ucp_Mro },\n  { 936, PT_SC, ucp_Multani },\n  { 944, PT_SC, ucp_Myanmar },\n  { 952, PT_GC, ucp_N },\n  { 954, PT_SC, ucp_Nabataean },\n  { 964, PT_SC, ucp_Nandinagari },\n  { 976, PT_PC, ucp_Nd },\n  { 979, PT_SC, ucp_New_Tai_Lue },\n  { 991, PT_SC, ucp_Newa },\n  { 996, PT_SC, ucp_Nko },\n  { 1000, PT_PC, ucp_Nl },\n  { 1003, PT_PC, ucp_No },\n  { 1006, PT_SC, ucp_Nushu },\n  { 1012, PT_SC, ucp_Nyiakeng_Puachue_Hmong },\n  { 1035, PT_SC, ucp_Ogham },\n  { 1041, PT_SC, ucp_Ol_Chiki },\n  { 1050, PT_SC, ucp_Old_Hungarian },\n  { 1064, PT_SC, ucp_Old_Italic },\n  { 1075, PT_SC, ucp_Old_North_Arabian },\n  { 1093, PT_SC, ucp_Old_Permic },\n  { 1104, PT_SC, ucp_Old_Persian },\n  { 1116, PT_SC, ucp_Old_Sogdian },\n  { 1128, PT_SC, ucp_Old_South_Arabian },\n  { 1146, PT_SC, ucp_Old_Turkic },\n  { 1157, PT_SC, ucp_Oriya },\n  { 1163, PT_SC, ucp_Osage },\n  { 1169, PT_SC, ucp_Osmanya },\n  { 1177, PT_GC, ucp_P },\n  { 1179, PT_SC, ucp_Pahawh_Hmong },\n  { 1192, PT_SC, ucp_Palmyrene },\n  { 1202, PT_SC, ucp_Pau_Cin_Hau },\n  { 1214, PT_PC, ucp_Pc },\n  { 1217, PT_PC, ucp_Pd },\n  { 1220, PT_PC, ucp_Pe },\n  { 1223, PT_PC, ucp_Pf },\n  { 1226, PT_SC, ucp_Phags_Pa },\n  { 1235, PT_SC, ucp_Phoenician },\n  { 1246, PT_PC, ucp_Pi },\n  { 1249, PT_PC, ucp_Po },\n  { 1252, PT_PC, ucp_Ps },\n  { 1255, PT_SC, ucp_Psalter_Pahlavi },\n  { 1271, PT_SC, ucp_Rejang },\n  { 1278, PT_SC, ucp_Runic },\n  { 1284, PT_GC, ucp_S },\n  { 1286, PT_SC, ucp_Samaritan },\n  { 1296, PT_SC, ucp_Saurashtra },\n  { 1307, PT_PC, ucp_Sc },\n  { 1310, PT_SC, ucp_Sharada },\n  { 1318, PT_SC, ucp_Shavian },\n  { 1326, PT_SC, ucp_Siddham },\n  { 1334, PT_SC, ucp_SignWriting },\n  { 1346, PT_SC, ucp_Sinhala },\n  { 1354, PT_PC, ucp_Sk },\n  { 1357, PT_PC, ucp_Sm },\n  { 1360, PT_PC, ucp_So },\n  { 1363, PT_SC, ucp_Sogdian },\n  { 1371, PT_SC, ucp_Sora_Sompeng },\n  { 1384, PT_SC, ucp_Soyombo },\n  { 1392, PT_SC, ucp_Sundanese },\n  { 1402, PT_SC, ucp_Syloti_Nagri },\n  { 1415, PT_SC, ucp_Syriac },\n  { 1422, PT_SC, ucp_Tagalog },\n  { 1430, PT_SC, ucp_Tagbanwa },\n  { 1439, PT_SC, ucp_Tai_Le },\n  { 1446, PT_SC, ucp_Tai_Tham },\n  { 1455, PT_SC, ucp_Tai_Viet },\n  { 1464, PT_SC, ucp_Takri },\n  { 1470, PT_SC, ucp_Tamil },\n  { 1476, PT_SC, ucp_Tangut },\n  { 1483, PT_SC, ucp_Telugu },\n  { 1490, PT_SC, ucp_Thaana },\n  { 1497, PT_SC, ucp_Thai },\n  { 1502, PT_SC, ucp_Tibetan },\n  { 1510, PT_SC, ucp_Tifinagh },\n  { 1519, PT_SC, ucp_Tirhuta },\n  { 1527, PT_SC, ucp_Ugaritic },\n  { 1536, PT_SC, ucp_Unknown },\n  { 1544, PT_SC, ucp_Vai },\n  { 1548, PT_SC, ucp_Wancho },\n  { 1555, PT_SC, ucp_Warang_Citi },\n  { 1567, PT_ALNUM, 0 },\n  { 1571, PT_PXSPACE, 0 },\n  { 1575, PT_SPACE, 0 },\n  { 1579, PT_UCNC, 0 },\n  { 1583, PT_WORD, 0 },\n  { 1587, PT_SC, ucp_Yezidi },\n  { 1594, PT_SC, ucp_Yi },\n  { 1597, PT_GC, ucp_Z },\n  { 1599, PT_SC, ucp_Zanabazar_Square },\n  { 1616, PT_PC, ucp_Zl },\n  { 1619, PT_PC, ucp_Zp },\n  { 1622, PT_PC, ucp_Zs }\n};\n\nconst size_t PRIV(utt_size) = sizeof(PRIV(utt)) / sizeof(ucp_type_table);\n\n#endif /* SUPPORT_UNICODE */\n\n/* End of pcre2_tables.c */\n/*autoconv-0001 C:\\projects\\pcre2-10.35\\src\\pcre2_tables.c converted to TABLES2*/\n/*autoconv-0011 TABLES2 line: 49 config.h replaced by CONFIG.h*/\n/*autoconv-0011 TABLES2 line: 51 pcre2_internal.h replaced by INTERNA2.h*/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "UCD2": {"ttr": 8449, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "\n/* This module is generated by the maint/MultiStage2.py script.\nDo not modify it by hand. Instead modify the script and run it\nto regenerate this code.\n\nAs well as being part of the PCRE2 library, this module is #included\nby the pcre2test program, which redefines the PRIV macro to change\ntable names from _pcre2_xxx to xxxx, thereby avoiding name clashes\nwith the library. At present, just one of these tables is actually\nneeded. */\n\n#ifndef PCRE2_PCRE2TEST\n\n#ifdef HAVE_CONFIG_H\n#include \"CONFIG.h\"\n#endif\n\n#include \"INTERNA2.h\"\n\n#endif /* PCRE2_PCRE2TEST */\n\n/* Unicode character database. */\n/* This file was autogenerated by the MultiStage2.py script. */\n/* Total size: 101044 bytes, block size: 128. */\n\n/* The tables herein are needed only when UCP support is built,\nand in PCRE2 that happens automatically with UTF support.\nThis module should not be referenced otherwise, so\nit should not matter whether it is compiled or not. However\na comment was received about space saving - maybe the guy linked\nall the modules rather than using a library - so we include a\ncondition to cut out the tables when not needed. But don't leave\na totally empty module because some compilers barf at that.\nInstead, just supply some small dummy tables. */\n\n#ifndef SUPPORT_UNICODE\nconst ucd_record PRIV(ucd_records)\u00dd\u00a8 = {{0,0,0,0,0,0,0 }};\nconst uint16_t PRIV(ucd_stage1)\u00dd\u00a8 = {0};\nconst uint16_t PRIV(ucd_stage2)\u00dd\u00a8 = {0};\nconst uint32_t PRIV(ucd_caseless_sets)\u00dd\u00a8 = {0};\n#else\n\nconst char *PRIV(unicode_version) = \"13.0.0\";\n\n/* If the 32-bit library is run in non-32-bit mode, character values\ngreater than 0x10ffff may be encountered. For these we set up a\nspecial record. */\n\n#if PCRE2_CODE_UNIT_WIDTH == 32\nconst ucd_record PRIV(dummy_ucd_record)\u00dd\u00a8 = {{\n  ucp_Unknown,    /* script */\n  ucp_Cn,         /* type unassigned */\n  ucp_gbOther,    /* grapheme break property */\n  0,              /* case set */\n  0,              /* other case */\n  ucp_Unknown,    /* script extension */\n  0,              /* dummy filler */\n  }};\n#endif\n\n/* When recompiling tables with a new Unicode version, please check the\ntypes in this structure definition from pcre2_internal.h (the actual\nfield names will be different):\n\ntypedef struct {\nuint8_t property_0;\nuint8_t property_1;\nuint8_t property_2;\nuint8_t property_3;\npcre_int32 property_4;\npcre_int16 property_5;\nuint16_t property_6;\n} ucd_record;\n*/\n\n/* This table contains lists of characters that are caseless sets of\nmore than one character. Each list is terminated by NOTACHAR. */\n\nconst uint32_t PRIV(ucd_caseless_sets)\u00dd\u00a8 = {\n  NOTACHAR,\n  0x0053,   0x0073,   0x017f,   NOTACHAR,\n  0x01c4,   0x01c5,   0x01c6,   NOTACHAR,\n  0x01c7,   0x01c8,   0x01c9,   NOTACHAR,\n  0x01ca,   0x01cb,   0x01cc,   NOTACHAR,\n  0x01f1,   0x01f2,   0x01f3,   NOTACHAR,\n  0x0345,   0x0399,   0x03b9,   0x1fbe,   NOTACHAR,\n  0x00b5,   0x039c,   0x03bc,   NOTACHAR,\n  0x03a3,   0x03c2,   0x03c3,   NOTACHAR,\n  0x0392,   0x03b2,   0x03d0,   NOTACHAR,\n  0x0398,   0x03b8,   0x03d1,   0x03f4,   NOTACHAR,\n  0x03a6,   0x03c6,   0x03d5,   NOTACHAR,\n  0x03a0,   0x03c0,   0x03d6,   NOTACHAR,\n  0x039a,   0x03ba,   0x03f0,   NOTACHAR,\n  0x03a1,   0x03c1,   0x03f1,   NOTACHAR,\n  0x0395,   0x03b5,   0x03f5,   NOTACHAR,\n  0x0412,   0x0432,   0x1c80,   NOTACHAR,\n  0x0414,   0x0434,   0x1c81,   NOTACHAR,\n  0x041e,   0x043e,   0x1c82,   NOTACHAR,\n  0x0421,   0x0441,   0x1c83,   NOTACHAR,\n  0x0422,   0x0442,   0x1c84,   0x1c85,   NOTACHAR,\n  0x042a,   0x044a,   0x1c86,   NOTACHAR,\n  0x0462,   0x0463,   0x1c87,   NOTACHAR,\n  0x1e60,   0x1e61,   0x1e9b,   NOTACHAR,\n  0x03a9,   0x03c9,   0x2126,   NOTACHAR,\n  0x004b,   0x006b,   0x212a,   NOTACHAR,\n  0x00c5,   0x00e5,   0x212b,   NOTACHAR,\n  0x1c88,   0xa64a,   0xa64b,   NOTACHAR,\n};\n\n/* When #included in pcre2test, we don't need the table of digit\nsets, nor the the large main UCD tables. */\n\n#ifndef PCRE2_PCRE2TEST\n\n/* This table lists the code points for the '9' characters in each\nset of decimal digits. It is used to ensure that all the digits in\na script run come from the same set. */\n\nconst uint32_t PRIV(ucd_digit_sets)\u00dd\u00a8 = {\n  65,  /* Number of subsequent values */\n  0x00039, 0x00669, 0x006f9, 0x007c9, 0x0096f, 0x009ef, 0x00a6f, 0x00aef,\n  0x00b6f, 0x00bef, 0x00c6f, 0x00cef, 0x00d6f, 0x00def, 0x00e59, 0x00ed9,\n  0x00f29, 0x01049, 0x01099, 0x017e9, 0x01819, 0x0194f, 0x019d9, 0x01a89,\n  0x01a99, 0x01b59, 0x01bb9, 0x01c49, 0x01c59, 0x0a629, 0x0a8d9, 0x0a909,\n  0x0a9d9, 0x0a9f9, 0x0aa59, 0x0abf9, 0x0ff19, 0x104a9, 0x10d39, 0x1106f,\n  0x110f9, 0x1113f, 0x111d9, 0x112f9, 0x11459, 0x114d9, 0x11659, 0x116c9,\n  0x11739, 0x118e9, 0x11959, 0x11c59, 0x11d59, 0x11da9, 0x16a69, 0x16b59,\n  0x1d7d7, 0x1d7e1, 0x1d7eb, 0x1d7f5, 0x1d7ff, 0x1e149, 0x1e2f9, 0x1e959,\n  0x1fbf9,\n};\n\n/* This vector is a list of lists of scripts for the Script Extension\nproperty. Each sublist is zero-terminated. */\n\nconst uint8_t PRIV(ucd_script_sets)\u00dd\u00a8 = {\n  /*   0 */   0,\n  /*   1 */   1,  11,   0,\n  /*   4 */   1, 144,   0,\n  /*   7 */   1,  50,   0,\n  /*  10 */   1,  56,   0,\n  /*  13 */   3,  15,   0,\n  /*  16 */   4,  23,   0,\n  /*  19 */   6,  84,   0,\n  /*  22 */  12,  36,   0,\n  /*  25 */  13,  18,   0,\n  /*  28 */  13,  34,   0,\n  /*  31 */  13, 118,   0,\n  /*  34 */  13,  50,   0,\n  /*  37 */  15, 107,   0,\n  /*  40 */  15, 150,   0,\n  /*  43 */  15, 100,   0,\n  /*  46 */  15,  54,   0,\n  /*  49 */  17,  34,   0,\n  /*  52 */ 107,  54,   0,\n  /*  55 */  21, 108,   0,\n  /*  58 */  22, 129,   0,\n  /*  61 */  23,  34,   0,\n  /*  64 */  27,  30,   0,\n  /*  67 */  29, 150,   0,\n  /*  70 */  34,  38,   0,\n  /*  73 */  38,  65,   0,\n  /*  76 */   1,  50,  56,   0,\n  /*  80 */   1,  56, 156,   0,\n  /*  84 */   3,  96,  49,   0,\n  /*  88 */  96,  39,  53,   0,\n  /*  92 */  12, 110,  36,   0,\n  /*  96 */  15, 107,  29,   0,\n  /* 100 */  15, 107,  34,   0,\n  /* 104 */  23,  27,  30,   0,\n  /* 108 */  69,  34,  39,   0,\n  /* 112 */   3,  15, 107,  29,   0,\n  /* 117 */   7,  25,  52,  51,   0,\n  /* 122 */  15, 142,  85, 111,   0,\n  /* 127 */   1, 144,  50,  56, 156,   0,\n  /* 133 */   4,  24,  23,  27,  30,   0,\n  /* 139 */   4,  24,  23,  27,  30,  61,   0,\n  /* 146 */  15,  29,  37,  44,  54,  55,   0,\n  /* 153 */ 132,   1,  95, 112, 121, 144, 148,  50,   0,\n  /* 162 */   3,  15, 107,  29, 150,  44,  55, 124,   0,\n  /* 171 */  15, 142,  21,  22, 108,  85, 111, 114, 109, 102, 124,   0,\n  /* 183 */   3,  15, 107,  21,  22,  29,  34,  37,  44,  54,  55, 124,   0,\n  /* 196 */   3,  15, 107,  21,  22,  29,  34,  37,  44, 100,  54,  55, 124,   0,\n  /* 210 */  15, 142,  21,  22, 108,  29,  85, 111, 114, 150, 109, 102, 124,   0,\n  /* 224 */  15, 142,  21,  22, 108,  29,  85, 111,  37, 114, 150, 109, 102, 124,   0,\n  /* 239 */   3,  15, 142, 143, 138, 107,  21,  22,  29, 111,  37, 150,  44, 109,  48,  49, 102,  54,  55, 124,   0,\n  /* 260 */   3,  15, 142, 143, 138, 107,  21,  22,  29,  35, 111,  37, 150,  44, 109,  48,  49, 102,  54,  55, 124,   0,\n  /* 282 */\n};\n\n/* These are the main two-stage UCD tables. The fields in each record are:\nscript (8 bits), character type (8 bits), grapheme break property (8 bits),\noffset to multichar other cases or zero (8 bits), offset to other case\nor zero (32 bits, signed), script extension (16 bits, signed), and a dummy\n16-bit field to make the whole thing a multiple of 4 bytes. */\n\nconst ucd_record PRIV(ucd_records)\u00dd\u00a8 = { /* 11700 bytes, record size 12 */\n  {    10,      0,      2,      0,      0,     10,    256, }, /*   0 */\n  {    10,      0,      2,      0,      0,     10,      0, }, /*   1 */\n  {    10,      0,      1,      0,      0,     10,      0, }, /*   2 */\n  {    10,      0,      0,      0,      0,     10,      0, }, /*   3 */\n  {    10,     29,     12,      0,      0,     10,      0, }, /*   4 */\n  {    10,     21,     12,      0,      0,     10,      0, }, /*   5 */\n  {    10,     23,     12,      0,      0,     10,      0, }, /*   6 */\n  {    10,     22,     12,      0,      0,     10,      0, }, /*   7 */\n  {    10,     18,     12,      0,      0,     10,      0, }, /*   8 */\n  {    10,     25,     12,      0,      0,     10,      0, }, /*   9 */\n  {    10,     17,     12,      0,      0,     10,      0, }, /*  10 */\n  {    10,     13,     12,      0,      0,     10,      0, }, /*  11 */\n  {    34,      9,     12,      0,     32,     34,      0, }, /*  12 */\n  {    34,      9,     12,    100,     32,     34,      0, }, /*  13 */\n  {    34,      9,     12,      1,     32,     34,      0, }, /*  14 */\n  {    10,     24,     12,      0,      0,     10,      0, }, /*  15 */\n  {    10,     16,     12,      0,      0,     10,      0, }, /*  16 */\n  {    34,      5,     12,      0,    -32,     34,      0, }, /*  17 */\n  {    34,      5,     12,    100,    -32,     34,      0, }, /*  18 */\n  {    34,      5,     12,      1,    -32,     34,      0, }, /*  19 */\n  {    10,     26,     12,      0,      0,     10,      0, }, /*  20 */\n  {    10,     26,     14,      0,      0,     10,      0, }, /*  21 */\n  {    34,      7,     12,      0,      0,     34,      0, }, /*  22 */\n  {    10,     20,     12,      0,      0,     10,      0, }, /*  23 */\n  {    10,      1,      2,      0,      0,     10,      0, }, /*  24 */\n  {    10,     15,     12,      0,      0,     10,      0, }, /*  25 */\n  {    10,      5,     12,     26,    775,     10,      0, }, /*  26 */\n  {    10,     19,     12,      0,      0,     10,      0, }, /*  27 */\n  {    34,      9,     12,    104,     32,     34,      0, }, /*  28 */\n  {    34,      5,     12,      0,   7615,     34,      0, }, /*  29 */\n  {    34,      5,     12,    104,    -32,     34,      0, }, /*  30 */\n  {    34,      5,     12,      0,    121,     34,      0, }, /*  31 */\n  {    34,      9,     12,      0,      1,     34,      0, }, /*  32 */\n  {    34,      5,     12,      0,     -1,     34,      0, }, /*  33 */\n  {    34,      9,     12,      0,      0,     34,      0, }, /*  34 */\n  {    34,      5,     12,      0,      0,     34,      0, }, /*  35 */\n  {    34,      9,     12,      0,   -121,     34,      0, }, /*  36 */\n  {    34,      5,     12,      1,   -268,     34,      0, }, /*  37 */\n  {    34,      5,     12,      0,    195,     34,      0, }, /*  38 */\n  {    34,      9,     12,      0,    210,     34,      0, }, /*  39 */\n  {    34,      9,     12,      0,    206,     34,      0, }, /*  40 */\n  {    34,      9,     12,      0,    205,     34,      0, }, /*  41 */\n  {    34,      9,     12,      0,     79,     34,      0, }, /*  42 */\n  {    34,      9,     12,      0,    202,     34,      0, }, /*  43 */\n  {    34,      9,     12,      0,    203,     34,      0, }, /*  44 */\n  {    34,      9,     12,      0,    207,     34,      0, }, /*  45 */\n  {    34,      5,     12,      0,     97,     34,      0, }, /*  46 */\n  {    34,      9,     12,      0,    211,     34,      0, }, /*  47 */\n  {    34,      9,     12,      0,    209,     34,      0, }, /*  48 */\n  {    34,      5,     12,      0,    163,     34,      0, }, /*  49 */\n  {    34,      9,     12,      0,    213,     34,      0, }, /*  50 */\n  {    34,      5,     12,      0,    130,     34,      0, }, /*  51 */\n  {    34,      9,     12,      0,    214,     34,      0, }, /*  52 */\n  {    34,      9,     12,      0,    218,     34,      0, }, /*  53 */\n  {    34,      9,     12,      0,    217,     34,      0, }, /*  54 */\n  {    34,      9,     12,      0,    219,     34,      0, }, /*  55 */\n  {    34,      5,     12,      0,     56,     34,      0, }, /*  56 */\n  {    34,      9,     12,      5,      2,     34,      0, }, /*  57 */\n  {    34,      8,     12,      5,      1,     34,      0, }, /*  58 */\n  {    34,      5,     12,      5,     -2,     34,      0, }, /*  59 */\n  {    34,      9,     12,      9,      2,     34,      0, }, /*  60 */\n  {    34,      8,     12,      9,      1,     34,      0, }, /*  61 */\n  {    34,      5,     12,      9,     -2,     34,      0, }, /*  62 */\n  {    34,      9,     12,     13,      2,     34,      0, }, /*  63 */\n  {    34,      8,     12,     13,      1,     34,      0, }, /*  64 */\n  {    34,      5,     12,     13,     -2,     34,      0, }, /*  65 */\n  {    34,      5,     12,      0,    -79,     34,      0, }, /*  66 */\n  {    34,      9,     12,     17,      2,     34,      0, }, /*  67 */\n  {    34,      8,     12,     17,      1,     34,      0, }, /*  68 */\n  {    34,      5,     12,     17,     -2,     34,      0, }, /*  69 */\n  {    34,      9,     12,      0,    -97,     34,      0, }, /*  70 */\n  {    34,      9,     12,      0,    -56,     34,      0, }, /*  71 */\n  {    34,      9,     12,      0,   -130,     34,      0, }, /*  72 */\n  {    34,      9,     12,      0,  10795,     34,      0, }, /*  73 */\n  {    34,      9,     12,      0,   -163,     34,      0, }, /*  74 */\n  {    34,      9,     12,      0,  10792,     34,      0, }, /*  75 */\n  {    34,      5,     12,      0,  10815,     34,      0, }, /*  76 */\n  {    34,      9,     12,      0,   -195,     34,      0, }, /*  77 */\n  {    34,      9,     12,      0,     69,     34,      0, }, /*  78 */\n  {    34,      9,     12,      0,     71,     34,      0, }, /*  79 */\n  {    34,      5,     12,      0,  10783,     34,      0, }, /*  80 */\n  {    34,      5,     12,      0,  10780,     34,      0, }, /*  81 */\n  {    34,      5,     12,      0,  10782,     34,      0, }, /*  82 */\n  {    34,      5,     12,      0,   -210,     34,      0, }, /*  83 */\n  {    34,      5,     12,      0,   -206,     34,      0, }, /*  84 */\n  {    34,      5,     12,      0,   -205,     34,      0, }, /*  85 */\n  {    34,      5,     12,      0,   -202,     34,      0, }, /*  86 */\n  {    34,      5,     12,      0,   -203,     34,      0, }, /*  87 */\n  {    34,      5,     12,      0,  42319,     34,      0, }, /*  88 */\n  {    34,      5,     12,      0,  42315,     34,      0, }, /*  89 */\n  {    34,      5,     12,      0,   -207,     34,      0, }, /*  90 */\n  {    34,      5,     12,      0,  42280,     34,      0, }, /*  91 */\n  {    34,      5,     12,      0,  42308,     34,      0, }, /*  92 */\n  {    34,      5,     12,      0,   -209,     34,      0, }, /*  93 */\n  {    34,      5,     12,      0,   -211,     34,      0, }, /*  94 */\n  {    34,      5,     12,      0,  10743,     34,      0, }, /*  95 */\n  {    34,      5,     12,      0,  42305,     34,      0, }, /*  96 */\n  {    34,      5,     12,      0,  10749,     34,      0, }, /*  97 */\n  {    34,      5,     12,      0,   -213,     34,      0, }, /*  98 */\n  {    34,      5,     12,      0,   -214,     34,      0, }, /*  99 */\n  {    34,      5,     12,      0,  10727,     34,      0, }, /* 100 */\n  {    34,      5,     12,      0,   -218,     34,      0, }, /* 101 */\n  {    34,      5,     12,      0,  42307,     34,      0, }, /* 102 */\n  {    34,      5,     12,      0,  42282,     34,      0, }, /* 103 */\n  {    34,      5,     12,      0,    -69,     34,      0, }, /* 104 */\n  {    34,      5,     12,      0,   -217,     34,      0, }, /* 105 */\n  {    34,      5,     12,      0,    -71,     34,      0, }, /* 106 */\n  {    34,      5,     12,      0,   -219,     34,      0, }, /* 107 */\n  {    34,      5,     12,      0,  42261,     34,      0, }, /* 108 */\n  {    34,      5,     12,      0,  42258,     34,      0, }, /* 109 */\n  {    34,      6,     12,      0,      0,     34,      0, }, /* 110 */\n  {    10,      6,     12,      0,      0,     10,      0, }, /* 111 */\n  {     4,     24,     12,      0,      0,      4,      0, }, /* 112 */\n  {    28,     12,      3,      0,      0,     28,      0, }, /* 113 */\n  {    28,     12,      3,      0,      0,     20,      0, }, /* 114 */\n  {    28,     12,      3,     21,    116,     20,      0, }, /* 115 */\n  {    28,     12,      3,      0,      0,     34,      0, }, /* 116 */\n  {    20,      9,     12,      0,      1,     20,      0, }, /* 117 */\n  {    20,      5,     12,      0,     -1,     20,      0, }, /* 118 */\n  {    20,     24,     12,      0,      0,     20,      0, }, /* 119 */\n  {     0,      2,     12,      0,      0,      0,      0, }, /* 120 */\n  {    20,      6,     12,      0,      0,     20,      0, }, /* 121 */\n  {    20,      5,     12,      0,    130,     20,      0, }, /* 122 */\n  {    20,      9,     12,      0,    116,     20,      0, }, /* 123 */\n  {    20,      9,     12,      0,     38,     20,      0, }, /* 124 */\n  {    20,      9,     12,      0,     37,     20,      0, }, /* 125 */\n  {    20,      9,     12,      0,     64,     20,      0, }, /* 126 */\n  {    20,      9,     12,      0,     63,     20,      0, }, /* 127 */\n  {    20,      5,     12,      0,      0,     20,      0, }, /* 128 */\n  {    20,      9,     12,      0,     32,     20,      0, }, /* 129 */\n  {    20,      9,     12,     34,     32,     20,      0, }, /* 130 */\n  {    20,      9,     12,     59,     32,     20,      0, }, /* 131 */\n  {    20,      9,     12,     38,     32,     20,      0, }, /* 132 */\n  {    20,      9,     12,     21,     32,     20,      0, }, /* 133 */\n  {    20,      9,     12,     51,     32,     20,      0, }, /* 134 */\n  {    20,      9,     12,     26,     32,     20,      0, }, /* 135 */\n  {    20,      9,     12,     47,     32,     20,      0, }, /* 136 */\n  {    20,      9,     12,     55,     32,     20,      0, }, /* 137 */\n  {    20,      9,     12,     30,     32,     20,      0, }, /* 138 */\n  {    20,      9,     12,     43,     32,     20,      0, }, /* 139 */\n  {    20,      9,     12,     96,     32,     20,      0, }, /* 140 */\n  {    20,      5,     12,      0,    -38,     20,      0, }, /* 141 */\n  {    20,      5,     12,      0,    -37,     20,      0, }, /* 142 */\n  {    20,      5,     12,      0,    -32,     20,      0, }, /* 143 */\n  {    20,      5,     12,     34,    -32,     20,      0, }, /* 144 */\n  {    20,      5,     12,     59,    -32,     20,      0, }, /* 145 */\n  {    20,      5,     12,     38,    -32,     20,      0, }, /* 146 */\n  {    20,      5,     12,     21,   -116,     20,      0, }, /* 147 */\n  {    20,      5,     12,     51,    -32,     20,      0, }, /* 148 */\n  {    20,      5,     12,     26,   -775,     20,      0, }, /* 149 */\n  {    20,      5,     12,     47,    -32,     20,      0, }, /* 150 */\n  {    20,      5,     12,     55,    -32,     20,      0, }, /* 151 */\n  {    20,      5,     12,     30,      1,     20,      0, }, /* 152 */\n  {    20,      5,     12,     30,    -32,     20,      0, }, /* 153 */\n  {    20,      5,     12,     43,    -32,     20,      0, }, /* 154 */\n  {    20,      5,     12,     96,    -32,     20,      0, }, /* 155 */\n  {    20,      5,     12,      0,    -64,     20,      0, }, /* 156 */\n  {    20,      5,     12,      0,    -63,     20,      0, }, /* 157 */\n  {    20,      9,     12,      0,      8,     20,      0, }, /* 158 */\n  {    20,      5,     12,     34,    -30,     20,      0, }, /* 159 */\n  {    20,      5,     12,     38,    -25,     20,      0, }, /* 160 */\n  {    20,      9,     12,      0,      0,     20,      0, }, /* 161 */\n  {    20,      5,     12,     43,    -15,     20,      0, }, /* 162 */\n  {    20,      5,     12,     47,    -22,     20,      0, }, /* 163 */\n  {    20,      5,     12,      0,     -8,     20,      0, }, /* 164 */\n  {    11,      9,     12,      0,      1,     11,      0, }, /* 165 */\n  {    11,      5,     12,      0,     -1,     11,      0, }, /* 166 */\n  {    20,      5,     12,     51,    -54,     20,      0, }, /* 167 */\n  {    20,      5,     12,     55,    -48,     20,      0, }, /* 168 */\n  {    20,      5,     12,      0,      7,     20,      0, }, /* 169 */\n  {    20,      5,     12,      0,   -116,     20,      0, }, /* 170 */\n  {    20,      9,     12,     38,    -60,     20,      0, }, /* 171 */\n  {    20,      5,     12,     59,    -64,     20,      0, }, /* 172 */\n  {    20,     25,     12,      0,      0,     20,      0, }, /* 173 */\n  {    20,      9,     12,      0,     -7,     20,      0, }, /* 174 */\n  {    20,      9,     12,      0,   -130,     20,      0, }, /* 175 */\n  {    13,      9,     12,      0,     80,     13,      0, }, /* 176 */\n  {    13,      9,     12,      0,     32,     13,      0, }, /* 177 */\n  {    13,      9,     12,     63,     32,     13,      0, }, /* 178 */\n  {    13,      9,     12,     67,     32,     13,      0, }, /* 179 */\n  {    13,      9,     12,     71,     32,     13,      0, }, /* 180 */\n  {    13,      9,     12,     75,     32,     13,      0, }, /* 181 */\n  {    13,      9,     12,     79,     32,     13,      0, }, /* 182 */\n  {    13,      9,     12,     84,     32,     13,      0, }, /* 183 */\n  {    13,      5,     12,      0,    -32,     13,      0, }, /* 184 */\n  {    13,      5,     12,     63,    -32,     13,      0, }, /* 185 */\n  {    13,      5,     12,     67,    -32,     13,      0, }, /* 186 */\n  {    13,      5,     12,     71,    -32,     13,      0, }, /* 187 */\n  {    13,      5,     12,     75,    -32,     13,      0, }, /* 188 */\n  {    13,      5,     12,     79,    -32,     13,      0, }, /* 189 */\n  {    13,      5,     12,     84,    -32,     13,      0, }, /* 190 */\n  {    13,      5,     12,      0,    -80,     13,      0, }, /* 191 */\n  {    13,      9,     12,      0,      1,     13,      0, }, /* 192 */\n  {    13,      5,     12,      0,     -1,     13,      0, }, /* 193 */\n  {    13,      9,     12,     88,      1,     13,      0, }, /* 194 */\n  {    13,      5,     12,     88,     -1,     13,      0, }, /* 195 */\n  {    13,     26,     12,      0,      0,     13,      0, }, /* 196 */\n  {    13,     12,      3,      0,      0,    -31,      0, }, /* 197 */\n  {    13,     12,      3,      0,      0,    -25,      0, }, /* 198 */\n  {    28,     12,      3,      0,      0,    -28,      0, }, /* 199 */\n  {    13,     11,      3,      0,      0,     13,      0, }, /* 200 */\n  {    13,      9,     12,      0,     15,     13,      0, }, /* 201 */\n  {    13,      5,     12,      0,    -15,     13,      0, }, /* 202 */\n  {     2,      9,     12,      0,     48,      2,      0, }, /* 203 */\n  {     2,      6,     12,      0,      0,      2,      0, }, /* 204 */\n  {     2,     21,     12,      0,      0,      2,      0, }, /* 205 */\n  {     2,      5,     12,      0,      0,      2,      0, }, /* 206 */\n  {     2,      5,     12,      0,    -48,      2,      0, }, /* 207 */\n  {     2,     17,     12,      0,      0,      2,      0, }, /* 208 */\n  {     2,     26,     12,      0,      0,      2,      0, }, /* 209 */\n  {     2,     23,     12,      0,      0,      2,      0, }, /* 210 */\n  {    26,     12,      3,      0,      0,     26,      0, }, /* 211 */\n  {    26,     17,     12,      0,      0,     26,      0, }, /* 212 */\n  {    26,     21,     12,      0,      0,     26,      0, }, /* 213 */\n  {    26,      7,     12,      0,      0,     26,      0, }, /* 214 */\n  {     1,      1,      4,      0,      0,      1,      0, }, /* 215 */\n  {    10,      1,      4,      0,      0,     10,      0, }, /* 216 */\n  {     1,     25,     12,      0,      0,      1,      0, }, /* 217 */\n  {     1,     21,     12,      0,      0,      1,      0, }, /* 218 */\n  {     1,     23,     12,      0,      0,      1,      0, }, /* 219 */\n  {    10,     21,     12,      0,      0,   -127,      0, }, /* 220 */\n  {     1,     26,     12,      0,      0,      1,      0, }, /* 221 */\n  {     1,     12,      3,      0,      0,      1,      0, }, /* 222 */\n  {     1,      1,      2,      0,      0,    -76,      0, }, /* 223 */\n  {     1,      7,     12,      0,      0,      1,      0, }, /* 224 */\n  {    10,      6,     12,      0,      0,   -153,      0, }, /* 225 */\n  {    28,     12,      3,      0,      0,     -7,      0, }, /* 226 */\n  {     1,     13,     12,      0,      0,    -80,      0, }, /* 227 */\n  {     1,     21,     12,      0,      0,     -4,      0, }, /* 228 */\n  {     1,      6,     12,      0,      0,      1,      0, }, /* 229 */\n  {     1,     13,     12,      0,      0,      1,      0, }, /* 230 */\n  {    50,     21,     12,      0,      0,     50,      0, }, /* 231 */\n  {    50,      1,      4,      0,      0,     50,      0, }, /* 232 */\n  {    50,      7,     12,      0,      0,     50,      0, }, /* 233 */\n  {    50,     12,      3,      0,      0,     50,      0, }, /* 234 */\n  {    56,      7,     12,      0,      0,     56,      0, }, /* 235 */\n  {    56,     12,      3,      0,      0,     56,      0, }, /* 236 */\n  {    64,     13,     12,      0,      0,     64,      0, }, /* 237 */\n  {    64,      7,     12,      0,      0,     64,      0, }, /* 238 */\n  {    64,     12,      3,      0,      0,     64,      0, }, /* 239 */\n  {    64,      6,     12,      0,      0,     64,      0, }, /* 240 */\n  {    64,     26,     12,      0,      0,     64,      0, }, /* 241 */\n  {    64,     21,     12,      0,      0,     64,      0, }, /* 242 */\n  {    64,     23,     12,      0,      0,     64,      0, }, /* 243 */\n  {    90,      7,     12,      0,      0,     90,      0, }, /* 244 */\n  {    90,     12,      3,      0,      0,     90,      0, }, /* 245 */\n  {    90,      6,     12,      0,      0,     90,      0, }, /* 246 */\n  {    90,     21,     12,      0,      0,     90,      0, }, /* 247 */\n  {    95,      7,     12,      0,      0,     95,      0, }, /* 248 */\n  {    95,     12,      3,      0,      0,     95,      0, }, /* 249 */\n  {    95,     21,     12,      0,      0,     95,      0, }, /* 250 */\n  {    15,     12,      3,      0,      0,     15,      0, }, /* 251 */\n  {    15,     10,      5,      0,      0,     15,      0, }, /* 252 */\n  {    15,      7,     12,      0,      0,     15,      0, }, /* 253 */\n  {    28,     12,      3,      0,      0,   -196,      0, }, /* 254 */\n  {    28,     12,      3,      0,      0,   -183,      0, }, /* 255 */\n  {    10,     21,     12,      0,      0,   -239,      0, }, /* 256 */\n  {    10,     21,     12,      0,      0,   -260,      0, }, /* 257 */\n  {    15,     13,     12,      0,      0,   -122,      0, }, /* 258 */\n  {    15,     21,     12,      0,      0,     15,      0, }, /* 259 */\n  {    15,      6,     12,      0,      0,     15,      0, }, /* 260 */\n  {     3,      7,     12,      0,      0,      3,      0, }, /* 261 */\n  {     3,     12,      3,      0,      0,      3,      0, }, /* 262 */\n  {     3,     10,      5,      0,      0,      3,      0, }, /* 263 */\n  {     3,     10,      3,      0,      0,      3,      0, }, /* 264 */\n  {     3,     13,     12,      0,      0,    -84,      0, }, /* 265 */\n  {     3,     23,     12,      0,      0,      3,      0, }, /* 266 */\n  {     3,     15,     12,      0,      0,      3,      0, }, /* 267 */\n  {     3,     26,     12,      0,      0,      3,      0, }, /* 268 */\n  {     3,     21,     12,      0,      0,      3,      0, }, /* 269 */\n  {    22,     12,      3,      0,      0,     22,      0, }, /* 270 */\n  {    22,     10,      5,      0,      0,     22,      0, }, /* 271 */\n  {    22,      7,     12,      0,      0,     22,      0, }, /* 272 */\n  {    22,     13,     12,      0,      0,    -58,      0, }, /* 273 */\n  {    22,     21,     12,      0,      0,     22,      0, }, /* 274 */\n  {    21,     12,      3,      0,      0,     21,      0, }, /* 275 */\n  {    21,     10,      5,      0,      0,     21,      0, }, /* 276 */\n  {    21,      7,     12,      0,      0,     21,      0, }, /* 277 */\n  {    21,     13,     12,      0,      0,    -55,      0, }, /* 278 */\n  {    21,     21,     12,      0,      0,     21,      0, }, /* 279 */\n  {    21,     23,     12,      0,      0,     21,      0, }, /* 280 */\n  {    44,     12,      3,      0,      0,     44,      0, }, /* 281 */\n  {    44,     10,      5,      0,      0,     44,      0, }, /* 282 */\n  {    44,      7,     12,      0,      0,     44,      0, }, /* 283 */\n  {    44,     10,      3,      0,      0,     44,      0, }, /* 284 */\n  {    44,     13,     12,      0,      0,     44,      0, }, /* 285 */\n  {    44,     26,     12,      0,      0,     44,      0, }, /* 286 */\n  {    44,     15,     12,      0,      0,     44,      0, }, /* 287 */\n  {    54,     12,      3,      0,      0,     54,      0, }, /* 288 */\n  {    54,      7,     12,      0,      0,     54,      0, }, /* 289 */\n  {    54,     10,      3,      0,      0,     54,      0, }, /* 290 */\n  {    54,     10,      5,      0,      0,     54,      0, }, /* 291 */\n  {    54,     13,     12,      0,      0,    -52,      0, }, /* 292 */\n  {    54,     15,     12,      0,      0,    -52,      0, }, /* 293 */\n  {    54,     26,     12,      0,      0,    -52,      0, }, /* 294 */\n  {    54,     26,     12,      0,      0,     54,      0, }, /* 295 */\n  {    54,     23,     12,      0,      0,     54,      0, }, /* 296 */\n  {    55,     12,      3,      0,      0,     55,      0, }, /* 297 */\n  {    55,     10,      5,      0,      0,     55,      0, }, /* 298 */\n  {    55,      7,     12,      0,      0,     55,      0, }, /* 299 */\n  {    55,     13,     12,      0,      0,     55,      0, }, /* 300 */\n  {    55,     21,     12,      0,      0,     55,      0, }, /* 301 */\n  {    55,     15,     12,      0,      0,     55,      0, }, /* 302 */\n  {    55,     26,     12,      0,      0,     55,      0, }, /* 303 */\n  {    29,      7,     12,      0,      0,     29,      0, }, /* 304 */\n  {    29,     12,      3,      0,      0,     29,      0, }, /* 305 */\n  {    29,     10,      5,      0,      0,     29,      0, }, /* 306 */\n  {    29,     21,     12,      0,      0,     29,      0, }, /* 307 */\n  {    29,     10,      3,      0,      0,     29,      0, }, /* 308 */\n  {    29,     13,     12,      0,      0,    -67,      0, }, /* 309 */\n  {    37,     12,      3,      0,      0,     37,      0, }, /* 310 */\n  {    37,     10,      5,      0,      0,     37,      0, }, /* 311 */\n  {    37,      7,     12,      0,      0,     37,      0, }, /* 312 */\n  {    37,     10,      3,      0,      0,     37,      0, }, /* 313 */\n  {    37,      7,      4,      0,      0,     37,      0, }, /* 314 */\n  {    37,     26,     12,      0,      0,     37,      0, }, /* 315 */\n  {    37,     15,     12,      0,      0,     37,      0, }, /* 316 */\n  {    37,     13,     12,      0,      0,     37,      0, }, /* 317 */\n  {    48,     12,      3,      0,      0,     48,      0, }, /* 318 */\n  {    48,     10,      5,      0,      0,     48,      0, }, /* 319 */\n  {    48,      7,     12,      0,      0,     48,      0, }, /* 320 */\n  {    48,     10,      3,      0,      0,     48,      0, }, /* 321 */\n  {    48,     13,     12,      0,      0,     48,      0, }, /* 322 */\n  {    48,     21,     12,      0,      0,     48,      0, }, /* 323 */\n  {    57,      7,     12,      0,      0,     57,      0, }, /* 324 */\n  {    57,     12,      3,      0,      0,     57,      0, }, /* 325 */\n  {    57,      7,      5,      0,      0,     57,      0, }, /* 326 */\n  {    57,      6,     12,      0,      0,     57,      0, }, /* 327 */\n  {    57,     21,     12,      0,      0,     57,      0, }, /* 328 */\n  {    57,     13,     12,      0,      0,     57,      0, }, /* 329 */\n  {    33,      7,     12,      0,      0,     33,      0, }, /* 330 */\n  {    33,     12,      3,      0,      0,     33,      0, }, /* 331 */\n  {    33,      7,      5,      0,      0,     33,      0, }, /* 332 */\n  {    33,      6,     12,      0,      0,     33,      0, }, /* 333 */\n  {    33,     13,     12,      0,      0,     33,      0, }, /* 334 */\n  {    58,      7,     12,      0,      0,     58,      0, }, /* 335 */\n  {    58,     26,     12,      0,      0,     58,      0, }, /* 336 */\n  {    58,     21,     12,      0,      0,     58,      0, }, /* 337 */\n  {    58,     12,      3,      0,      0,     58,      0, }, /* 338 */\n  {    58,     13,     12,      0,      0,     58,      0, }, /* 339 */\n  {    58,     15,     12,      0,      0,     58,      0, }, /* 340 */\n  {    58,     22,     12,      0,      0,     58,      0, }, /* 341 */\n  {    58,     18,     12,      0,      0,     58,      0, }, /* 342 */\n  {    58,     10,      5,      0,      0,     58,      0, }, /* 343 */\n  {    39,      7,     12,      0,      0,     39,      0, }, /* 344 */\n  {    39,     10,     12,      0,      0,     39,      0, }, /* 345 */\n  {    39,     12,      3,      0,      0,     39,      0, }, /* 346 */\n  {    39,     10,      5,      0,      0,     39,      0, }, /* 347 */\n  {    39,     13,     12,      0,      0,    -88,      0, }, /* 348 */\n  {    39,     21,     12,      0,      0,     39,      0, }, /* 349 */\n  {    39,     13,     12,      0,      0,     39,      0, }, /* 350 */\n  {    39,     26,     12,      0,      0,     39,      0, }, /* 351 */\n  {    17,      9,     12,      0,   7264,     17,      0, }, /* 352 */\n  {    17,      5,     12,      0,   3008,     17,      0, }, /* 353 */\n  {    10,     21,     12,      0,      0,    -49,      0, }, /* 354 */\n  {    17,      6,     12,      0,      0,     17,      0, }, /* 355 */\n  {    24,      7,      6,      0,      0,     24,      0, }, /* 356 */\n  {    24,      7,      7,      0,      0,     24,      0, }, /* 357 */\n  {    24,      7,      8,      0,      0,     24,      0, }, /* 358 */\n  {    16,      7,     12,      0,      0,     16,      0, }, /* 359 */\n  {    16,     12,      3,      0,      0,     16,      0, }, /* 360 */\n  {    16,     21,     12,      0,      0,     16,      0, }, /* 361 */\n  {    16,     15,     12,      0,      0,     16,      0, }, /* 362 */\n  {    16,     26,     12,      0,      0,     16,      0, }, /* 363 */\n  {     9,      9,     12,      0,  38864,      9,      0, }, /* 364 */\n  {     9,      9,     12,      0,      8,      9,      0, }, /* 365 */\n  {     9,      5,     12,      0,     -8,      9,      0, }, /* 366 */\n  {     8,     17,     12,      0,      0,      8,      0, }, /* 367 */\n  {     8,      7,     12,      0,      0,      8,      0, }, /* 368 */\n  {     8,     26,     12,      0,      0,      8,      0, }, /* 369 */\n  {     8,     21,     12,      0,      0,      8,      0, }, /* 370 */\n  {    41,     29,     12,      0,      0,     41,      0, }, /* 371 */\n  {    41,      7,     12,      0,      0,     41,      0, }, /* 372 */\n  {    41,     22,     12,      0,      0,     41,      0, }, /* 373 */\n  {    41,     18,     12,      0,      0,     41,      0, }, /* 374 */\n  {    46,      7,     12,      0,      0,     46,      0, }, /* 375 */\n  {    46,     14,     12,      0,      0,     46,      0, }, /* 376 */\n  {    51,      7,     12,      0,      0,     51,      0, }, /* 377 */\n  {    51,     12,      3,      0,      0,     51,      0, }, /* 378 */\n  {    25,      7,     12,      0,      0,     25,      0, }, /* 379 */\n  {    25,     12,      3,      0,      0,     25,      0, }, /* 380 */\n  {    10,     21,     12,      0,      0,   -117,      0, }, /* 381 */\n  {     7,      7,     12,      0,      0,      7,      0, }, /* 382 */\n  {     7,     12,      3,      0,      0,      7,      0, }, /* 383 */\n  {    52,      7,     12,      0,      0,     52,      0, }, /* 384 */\n  {    52,     12,      3,      0,      0,     52,      0, }, /* 385 */\n  {    32,      7,     12,      0,      0,     32,      0, }, /* 386 */\n  {    32,     12,      3,      0,      0,     32,      0, }, /* 387 */\n  {    32,     10,      5,      0,      0,     32,      0, }, /* 388 */\n  {    32,     21,     12,      0,      0,     32,      0, }, /* 389 */\n  {    32,      6,     12,      0,      0,     32,      0, }, /* 390 */\n  {    32,     23,     12,      0,      0,     32,      0, }, /* 391 */\n  {    32,     13,     12,      0,      0,     32,      0, }, /* 392 */\n  {    32,     15,     12,      0,      0,     32,      0, }, /* 393 */\n  {    38,     21,     12,      0,      0,     38,      0, }, /* 394 */\n  {    10,     21,     12,      0,      0,    -73,      0, }, /* 395 */\n  {    38,     17,     12,      0,      0,     38,      0, }, /* 396 */\n  {    38,     12,      3,      0,      0,     38,      0, }, /* 397 */\n  {    38,      1,      2,      0,      0,     38,      0, }, /* 398 */\n  {    38,     13,     12,      0,      0,     38,      0, }, /* 399 */\n  {    38,      7,     12,      0,      0,     38,      0, }, /* 400 */\n  {    38,      6,     12,      0,      0,     38,      0, }, /* 401 */\n  {    35,      7,     12,      0,      0,     35,      0, }, /* 402 */\n  {    35,     12,      3,      0,      0,     35,      0, }, /* 403 */\n  {    35,     10,      5,      0,      0,     35,      0, }, /* 404 */\n  {    35,     26,     12,      0,      0,     35,      0, }, /* 405 */\n  {    35,     21,     12,      0,      0,     35,      0, }, /* 406 */\n  {    35,     13,     12,      0,      0,     35,      0, }, /* 407 */\n  {    53,      7,     12,      0,      0,     53,      0, }, /* 408 */\n  {    40,      7,     12,      0,      0,     40,      0, }, /* 409 */\n  {    40,     13,     12,      0,      0,     40,      0, }, /* 410 */\n  {    40,     15,     12,      0,      0,     40,      0, }, /* 411 */\n  {    40,     26,     12,      0,      0,     40,      0, }, /* 412 */\n  {    32,     26,     12,      0,      0,     32,      0, }, /* 413 */\n  {     6,      7,     12,      0,      0,      6,      0, }, /* 414 */\n  {     6,     12,      3,      0,      0,      6,      0, }, /* 415 */\n  {     6,     10,      5,      0,      0,      6,      0, }, /* 416 */\n  {     6,     21,     12,      0,      0,      6,      0, }, /* 417 */\n  {    91,      7,     12,      0,      0,     91,      0, }, /* 418 */\n  {    91,     10,      5,      0,      0,     91,      0, }, /* 419 */\n  {    91,     12,      3,      0,      0,     91,      0, }, /* 420 */\n  {    91,     10,     12,      0,      0,     91,      0, }, /* 421 */\n  {    91,     13,     12,      0,      0,     91,      0, }, /* 422 */\n  {    91,     21,     12,      0,      0,     91,      0, }, /* 423 */\n  {    91,      6,     12,      0,      0,     91,      0, }, /* 424 */\n  {    28,     11,      3,      0,      0,     28,      0, }, /* 425 */\n  {    62,     12,      3,      0,      0,     62,      0, }, /* 426 */\n  {    62,     10,      5,      0,      0,     62,      0, }, /* 427 */\n  {    62,      7,     12,      0,      0,     62,      0, }, /* 428 */\n  {    62,     10,      3,      0,      0,     62,      0, }, /* 429 */\n  {    62,     13,     12,      0,      0,     62,      0, }, /* 430 */\n  {    62,     21,     12,      0,      0,     62,      0, }, /* 431 */\n  {    62,     26,     12,      0,      0,     62,      0, }, /* 432 */\n  {    76,     12,      3,      0,      0,     76,      0, }, /* 433 */\n  {    76,     10,      5,      0,      0,     76,      0, }, /* 434 */\n  {    76,      7,     12,      0,      0,     76,      0, }, /* 435 */\n  {    76,     13,     12,      0,      0,     76,      0, }, /* 436 */\n  {    93,      7,     12,      0,      0,     93,      0, }, /* 437 */\n  {    93,     12,      3,      0,      0,     93,      0, }, /* 438 */\n  {    93,     10,      5,      0,      0,     93,      0, }, /* 439 */\n  {    93,     21,     12,      0,      0,     93,      0, }, /* 440 */\n  {    70,      7,     12,      0,      0,     70,      0, }, /* 441 */\n  {    70,     10,      5,      0,      0,     70,      0, }, /* 442 */\n  {    70,     12,      3,      0,      0,     70,      0, }, /* 443 */\n  {    70,     21,     12,      0,      0,     70,      0, }, /* 444 */\n  {    70,     13,     12,      0,      0,     70,      0, }, /* 445 */\n  {    73,     13,     12,      0,      0,     73,      0, }, /* 446 */\n  {    73,      7,     12,      0,      0,     73,      0, }, /* 447 */\n  {    73,      6,     12,      0,      0,     73,      0, }, /* 448 */\n  {    73,     21,     12,      0,      0,     73,      0, }, /* 449 */\n  {    13,      5,     12,     63,  -6222,     13,      0, }, /* 450 */\n  {    13,      5,     12,     67,  -6221,     13,      0, }, /* 451 */\n  {    13,      5,     12,     71,  -6212,     13,      0, }, /* 452 */\n  {    13,      5,     12,     75,  -6210,     13,      0, }, /* 453 */\n  {    13,      5,     12,     79,  -6210,     13,      0, }, /* 454 */\n  {    13,      5,     12,     79,  -6211,     13,      0, }, /* 455 */\n  {    13,      5,     12,     84,  -6204,     13,      0, }, /* 456 */\n  {    13,      5,     12,     88,  -6180,     13,      0, }, /* 457 */\n  {    13,      5,     12,    108,  35267,     13,      0, }, /* 458 */\n  {    17,      9,     12,      0,  -3008,     17,      0, }, /* 459 */\n  {    76,     21,     12,      0,      0,     76,      0, }, /* 460 */\n  {    28,     12,      3,      0,      0,   -112,      0, }, /* 461 */\n  {    28,     12,      3,      0,      0,     15,      0, }, /* 462 */\n  {    10,     21,     12,      0,      0,    -37,      0, }, /* 463 */\n  {    28,     12,      3,      0,      0,    -13,      0, }, /* 464 */\n  {    28,     12,      3,      0,      0,    -43,      0, }, /* 465 */\n  {    28,     12,      3,      0,      0,   -146,      0, }, /* 466 */\n  {    10,     10,      5,      0,      0,    -13,      0, }, /* 467 */\n  {    10,      7,     12,      0,      0,    -40,      0, }, /* 468 */\n  {    10,      7,     12,      0,      0,    -13,      0, }, /* 469 */\n  {    10,      7,     12,      0,      0,     15,      0, }, /* 470 */\n  {    10,      7,     12,      0,      0,   -162,      0, }, /* 471 */\n  {    10,      7,     12,      0,      0,    -37,      0, }, /* 472 */\n  {    28,     12,      3,      0,      0,    -96,      0, }, /* 473 */\n  {    10,     10,      5,      0,      0,      3,      0, }, /* 474 */\n  {    28,     12,      3,      0,      0,    -37,      0, }, /* 475 */\n  {    10,      7,     12,      0,      0,    150,      0, }, /* 476 */\n  {    13,      5,     12,      0,      0,     13,      0, }, /* 477 */\n  {    13,      6,     12,      0,      0,     13,      0, }, /* 478 */\n  {    34,      5,     12,      0,  35332,     34,      0, }, /* 479 */\n  {    34,      5,     12,      0,   3814,     34,      0, }, /* 480 */\n  {    34,      5,     12,      0,  35384,     34,      0, }, /* 481 */\n  {    28,     12,      3,      0,      0,    -34,      0, }, /* 482 */\n  {    34,      9,     12,     92,      1,     34,      0, }, /* 483 */\n  {    34,      5,     12,     92,     -1,     34,      0, }, /* 484 */\n  {    34,      5,     12,     92,    -58,     34,      0, }, /* 485 */\n  {    34,      9,     12,      0,  -7615,     34,      0, }, /* 486 */\n  {    20,      5,     12,      0,      8,     20,      0, }, /* 487 */\n  {    20,      9,     12,      0,     -8,     20,      0, }, /* 488 */\n  {    20,      5,     12,      0,     74,     20,      0, }, /* 489 */\n  {    20,      5,     12,      0,     86,     20,      0, }, /* 490 */\n  {    20,      5,     12,      0,    100,     20,      0, }, /* 491 */\n  {    20,      5,     12,      0,    128,     20,      0, }, /* 492 */\n  {    20,      5,     12,      0,    112,     20,      0, }, /* 493 */\n  {    20,      5,     12,      0,    126,     20,      0, }, /* 494 */\n  {    20,      8,     12,      0,     -8,     20,      0, }, /* 495 */\n  {    20,      5,     12,      0,      9,     20,      0, }, /* 496 */\n  {    20,      9,     12,      0,    -74,     20,      0, }, /* 497 */\n  {    20,      8,     12,      0,     -9,     20,      0, }, /* 498 */\n  {    20,      5,     12,     21,  -7173,     20,      0, }, /* 499 */\n  {    20,      9,     12,      0,    -86,     20,      0, }, /* 500 */\n  {    20,      9,     12,      0,   -100,     20,      0, }, /* 501 */\n  {    20,      9,     12,      0,   -112,     20,      0, }, /* 502 */\n  {    20,      9,     12,      0,   -128,     20,      0, }, /* 503 */\n  {    20,      9,     12,      0,   -126,     20,      0, }, /* 504 */\n  {    28,      1,      3,      0,      0,     28,      0, }, /* 505 */\n  {    28,      1,     13,      0,      0,     28,      0, }, /* 506 */\n  {    10,     27,      2,      0,      0,     10,      0, }, /* 507 */\n  {    10,     28,      2,      0,      0,     10,      0, }, /* 508 */\n  {    10,     29,     12,      0,      0,    -70,      0, }, /* 509 */\n  {    10,     21,     14,      0,      0,     10,      0, }, /* 510 */\n  {     0,      2,      2,      0,      0,      0,      0, }, /* 511 */\n  {    28,     12,      3,      0,      0,   -100,      0, }, /* 512 */\n  {    10,      9,     12,      0,      0,     10,      0, }, /* 513 */\n  {    10,      5,     12,      0,      0,     10,      0, }, /* 514 */\n  {    20,      9,     12,     96,  -7517,     20,      0, }, /* 515 */\n  {    34,      9,     12,    100,  -8383,     34,      0, }, /* 516 */\n  {    34,      9,     12,    104,  -8262,     34,      0, }, /* 517 */\n  {    34,      9,     12,      0,     28,     34,      0, }, /* 518 */\n  {    10,      7,     12,      0,      0,     10,      0, }, /* 519 */\n  {    10,      5,     14,      0,      0,     10,      0, }, /* 520 */\n  {    34,      5,     12,      0,    -28,     34,      0, }, /* 521 */\n  {    34,     14,     12,      0,     16,     34,      0, }, /* 522 */\n  {    34,     14,     12,      0,    -16,     34,      0, }, /* 523 */\n  {    34,     14,     12,      0,      0,     34,      0, }, /* 524 */\n  {    10,     25,     14,      0,      0,     10,      0, }, /* 525 */\n  {    10,     26,     12,      0,     26,     10,      0, }, /* 526 */\n  {    10,     26,     14,      0,     26,     10,      0, }, /* 527 */\n  {    10,     26,     12,      0,    -26,     10,      0, }, /* 528 */\n  {     5,     26,     12,      0,      0,      5,      0, }, /* 529 */\n  {    18,      9,     12,      0,     48,     18,      0, }, /* 530 */\n  {    18,      5,     12,      0,    -48,     18,      0, }, /* 531 */\n  {    34,      9,     12,      0, -10743,     34,      0, }, /* 532 */\n  {    34,      9,     12,      0,  -3814,     34,      0, }, /* 533 */\n  {    34,      9,     12,      0, -10727,     34,      0, }, /* 534 */\n  {    34,      5,     12,      0, -10795,     34,      0, }, /* 535 */\n  {    34,      5,     12,      0, -10792,     34,      0, }, /* 536 */\n  {    34,      9,     12,      0, -10780,     34,      0, }, /* 537 */\n  {    34,      9,     12,      0, -10749,     34,      0, }, /* 538 */\n  {    34,      9,     12,      0, -10783,     34,      0, }, /* 539 */\n  {    34,      9,     12,      0, -10782,     34,      0, }, /* 540 */\n  {    34,      9,     12,      0, -10815,     34,      0, }, /* 541 */\n  {    11,      5,     12,      0,      0,     11,      0, }, /* 542 */\n  {    11,     26,     12,      0,      0,     11,      0, }, /* 543 */\n  {    11,     12,      3,      0,      0,     11,      0, }, /* 544 */\n  {    11,     21,     12,      0,      0,     11,      0, }, /* 545 */\n  {    11,     15,     12,      0,      0,     11,      0, }, /* 546 */\n  {    17,      5,     12,      0,  -7264,     17,      0, }, /* 547 */\n  {    59,      7,     12,      0,      0,     59,      0, }, /* 548 */\n  {    59,      6,     12,      0,      0,     59,      0, }, /* 549 */\n  {    59,     21,     12,      0,      0,     59,      0, }, /* 550 */\n  {    59,     12,      3,      0,      0,     59,      0, }, /* 551 */\n  {    13,     12,      3,      0,      0,     13,      0, }, /* 552 */\n  {    10,     21,     12,      0,      0,    -25,      0, }, /* 553 */\n  {    23,     26,     12,      0,      0,     23,      0, }, /* 554 */\n  {    10,     21,     12,      0,      0,   -139,      0, }, /* 555 */\n  {    10,     21,     12,      0,      0,   -133,      0, }, /* 556 */\n  {    23,      6,     12,      0,      0,     23,      0, }, /* 557 */\n  {    10,      7,     12,      0,      0,     23,      0, }, /* 558 */\n  {    23,     14,     12,      0,      0,     23,      0, }, /* 559 */\n  {    10,     22,     12,      0,      0,   -139,      0, }, /* 560 */\n  {    10,     18,     12,      0,      0,   -139,      0, }, /* 561 */\n  {    10,     26,     12,      0,      0,   -133,      0, }, /* 562 */\n  {    10,     17,     12,      0,      0,   -133,      0, }, /* 563 */\n  {    10,     22,     12,      0,      0,   -133,      0, }, /* 564 */\n  {    10,     18,     12,      0,      0,   -133,      0, }, /* 565 */\n  {    28,     12,      3,      0,      0,    -16,      0, }, /* 566 */\n  {    24,     10,      3,      0,      0,     24,      0, }, /* 567 */\n  {    10,     17,     14,      0,      0,   -133,      0, }, /* 568 */\n  {    10,      6,     12,      0,      0,    -64,      0, }, /* 569 */\n  {    10,      7,     12,      0,      0,   -104,      0, }, /* 570 */\n  {    10,     21,     14,      0,      0,   -104,      0, }, /* 571 */\n  {    10,     26,     12,      0,      0,     23,      0, }, /* 572 */\n  {    27,      7,     12,      0,      0,     27,      0, }, /* 573 */\n  {    28,     12,      3,      0,      0,    -64,      0, }, /* 574 */\n  {    10,     24,     12,      0,      0,    -64,      0, }, /* 575 */\n  {    27,      6,     12,      0,      0,     27,      0, }, /* 576 */\n  {    10,     17,     12,      0,      0,    -64,      0, }, /* 577 */\n  {    30,      7,     12,      0,      0,     30,      0, }, /* 578 */\n  {    30,      6,     12,      0,      0,     30,      0, }, /* 579 */\n  {     4,      7,     12,      0,      0,      4,      0, }, /* 580 */\n  {    24,      7,     12,      0,      0,     24,      0, }, /* 581 */\n  {    10,     15,     12,      0,      0,     23,      0, }, /* 582 */\n  {    24,     26,     12,      0,      0,     24,      0, }, /* 583 */\n  {    10,     26,     14,      0,      0,     23,      0, }, /* 584 */\n  {    30,     26,     12,      0,      0,     30,      0, }, /* 585 */\n  {    23,      7,     12,      0,      0,     23,      0, }, /* 586 */\n  {    61,      7,     12,      0,      0,     61,      0, }, /* 587 */\n  {    61,      6,     12,      0,      0,     61,      0, }, /* 588 */\n  {    61,     26,     12,      0,      0,     61,      0, }, /* 589 */\n  {    86,      7,     12,      0,      0,     86,      0, }, /* 590 */\n  {    86,      6,     12,      0,      0,     86,      0, }, /* 591 */\n  {    86,     21,     12,      0,      0,     86,      0, }, /* 592 */\n  {    77,      7,     12,      0,      0,     77,      0, }, /* 593 */\n  {    77,      6,     12,      0,      0,     77,      0, }, /* 594 */\n  {    77,     21,     12,      0,      0,     77,      0, }, /* 595 */\n  {    77,     13,     12,      0,      0,     77,      0, }, /* 596 */\n  {    13,      9,     12,    108,      1,     13,      0, }, /* 597 */\n  {    13,      5,     12,    108, -35267,     13,      0, }, /* 598 */\n  {    13,      7,     12,      0,      0,     13,      0, }, /* 599 */\n  {    13,     21,     12,      0,      0,     13,      0, }, /* 600 */\n  {    79,      7,     12,      0,      0,     79,      0, }, /* 601 */\n  {    79,     14,     12,      0,      0,     79,      0, }, /* 602 */\n  {    79,     12,      3,      0,      0,     79,      0, }, /* 603 */\n  {    79,     21,     12,      0,      0,     79,      0, }, /* 604 */\n  {    10,     24,     12,      0,      0,    -61,      0, }, /* 605 */\n  {    34,      9,     12,      0, -35332,     34,      0, }, /* 606 */\n  {    34,      9,     12,      0, -42280,     34,      0, }, /* 607 */\n  {    34,      5,     12,      0,     48,     34,      0, }, /* 608 */\n  {    34,      9,     12,      0, -42308,     34,      0, }, /* 609 */\n  {    34,      9,     12,      0, -42319,     34,      0, }, /* 610 */\n  {    34,      9,     12,      0, -42315,     34,      0, }, /* 611 */\n  {    34,      9,     12,      0, -42305,     34,      0, }, /* 612 */\n  {    34,      9,     12,      0, -42258,     34,      0, }, /* 613 */\n  {    34,      9,     12,      0, -42282,     34,      0, }, /* 614 */\n  {    34,      9,     12,      0, -42261,     34,      0, }, /* 615 */\n  {    34,      9,     12,      0,    928,     34,      0, }, /* 616 */\n  {    34,      9,     12,      0,    -48,     34,      0, }, /* 617 */\n  {    34,      9,     12,      0, -42307,     34,      0, }, /* 618 */\n  {    34,      9,     12,      0, -35384,     34,      0, }, /* 619 */\n  {    49,      7,     12,      0,      0,     49,      0, }, /* 620 */\n  {    49,     12,      3,      0,      0,     49,      0, }, /* 621 */\n  {    49,     10,      5,      0,      0,     49,      0, }, /* 622 */\n  {    49,     26,     12,      0,      0,     49,      0, }, /* 623 */\n  {    10,     15,     12,      0,      0,   -224,      0, }, /* 624 */\n  {    10,     15,     12,      0,      0,   -210,      0, }, /* 625 */\n  {    10,     26,     12,      0,      0,   -171,      0, }, /* 626 */\n  {    10,     23,     12,      0,      0,   -171,      0, }, /* 627 */\n  {    65,      7,     12,      0,      0,     65,      0, }, /* 628 */\n  {    65,     21,     12,      0,      0,     65,      0, }, /* 629 */\n  {    75,     10,      5,      0,      0,     75,      0, }, /* 630 */\n  {    75,      7,     12,      0,      0,     75,      0, }, /* 631 */\n  {    75,     12,      3,      0,      0,     75,      0, }, /* 632 */\n  {    75,     21,     12,      0,      0,     75,      0, }, /* 633 */\n  {    75,     13,     12,      0,      0,     75,      0, }, /* 634 */\n  {    15,     12,      3,      0,      0,    -13,      0, }, /* 635 */\n  {    15,      7,     12,      0,      0,    -46,      0, }, /* 636 */\n  {    69,     13,     12,      0,      0,     69,      0, }, /* 637 */\n  {    69,      7,     12,      0,      0,     69,      0, }, /* 638 */\n  {    69,     12,      3,      0,      0,     69,      0, }, /* 639 */\n  {    10,     21,     12,      0,      0,   -108,      0, }, /* 640 */\n  {    69,     21,     12,      0,      0,     69,      0, }, /* 641 */\n  {    74,      7,     12,      0,      0,     74,      0, }, /* 642 */\n  {    74,     12,      3,      0,      0,     74,      0, }, /* 643 */\n  {    74,     10,      5,      0,      0,     74,      0, }, /* 644 */\n  {    74,     21,     12,      0,      0,     74,      0, }, /* 645 */\n  {    84,     12,      3,      0,      0,     84,      0, }, /* 646 */\n  {    84,     10,      5,      0,      0,     84,      0, }, /* 647 */\n  {    84,      7,     12,      0,      0,     84,      0, }, /* 648 */\n  {    84,     21,     12,      0,      0,     84,      0, }, /* 649 */\n  {    10,      6,     12,      0,      0,    -19,      0, }, /* 650 */\n  {    84,     13,     12,      0,      0,     84,      0, }, /* 651 */\n  {    39,      6,     12,      0,      0,     39,      0, }, /* 652 */\n  {    68,      7,     12,      0,      0,     68,      0, }, /* 653 */\n  {    68,     12,      3,      0,      0,     68,      0, }, /* 654 */\n  {    68,     10,      5,      0,      0,     68,      0, }, /* 655 */\n  {    68,     13,     12,      0,      0,     68,      0, }, /* 656 */\n  {    68,     21,     12,      0,      0,     68,      0, }, /* 657 */\n  {    92,      7,     12,      0,      0,     92,      0, }, /* 658 */\n  {    92,     12,      3,      0,      0,     92,      0, }, /* 659 */\n  {    92,      6,     12,      0,      0,     92,      0, }, /* 660 */\n  {    92,     21,     12,      0,      0,     92,      0, }, /* 661 */\n  {    87,      7,     12,      0,      0,     87,      0, }, /* 662 */\n  {    87,     10,      5,      0,      0,     87,      0, }, /* 663 */\n  {    87,     12,      3,      0,      0,     87,      0, }, /* 664 */\n  {    87,     21,     12,      0,      0,     87,      0, }, /* 665 */\n  {    87,      6,     12,      0,      0,     87,      0, }, /* 666 */\n  {    34,      5,     12,      0,   -928,     34,      0, }, /* 667 */\n  {     9,      5,     12,      0, -38864,      9,      0, }, /* 668 */\n  {    87,     13,     12,      0,      0,     87,      0, }, /* 669 */\n  {    24,      7,      9,      0,      0,     24,      0, }, /* 670 */\n  {    24,      7,     10,      0,      0,     24,      0, }, /* 671 */\n  {     0,      4,     12,      0,      0,      0,      0, }, /* 672 */\n  {     0,      3,     12,      0,      0,      0,      0, }, /* 673 */\n  {    26,     25,     12,      0,      0,     26,      0, }, /* 674 */\n  {     1,     24,     12,      0,      0,      1,      0, }, /* 675 */\n  {     1,      7,     12,      0,      0,    -10,      0, }, /* 676 */\n  {     1,     26,     12,      0,      0,    -10,      0, }, /* 677 */\n  {    10,      6,      3,      0,      0,    -64,      0, }, /* 678 */\n  {    36,      7,     12,      0,      0,     36,      0, }, /* 679 */\n  {    10,     21,     12,      0,      0,    -22,      0, }, /* 680 */\n  {    10,     15,     12,      0,      0,    -92,      0, }, /* 681 */\n  {    10,     26,     12,      0,      0,    -22,      0, }, /* 682 */\n  {    20,     14,     12,      0,      0,     20,      0, }, /* 683 */\n  {    20,     15,     12,      0,      0,     20,      0, }, /* 684 */\n  {    20,     26,     12,      0,      0,     20,      0, }, /* 685 */\n  {    71,      7,     12,      0,      0,     71,      0, }, /* 686 */\n  {    67,      7,     12,      0,      0,     67,      0, }, /* 687 */\n  {    28,     12,      3,      0,      0,     -1,      0, }, /* 688 */\n  {    10,     15,     12,      0,      0,     -1,      0, }, /* 689 */\n  {    42,      7,     12,      0,      0,     42,      0, }, /* 690 */\n  {    42,     15,     12,      0,      0,     42,      0, }, /* 691 */\n  {    19,      7,     12,      0,      0,     19,      0, }, /* 692 */\n  {    19,     14,     12,      0,      0,     19,      0, }, /* 693 */\n  {   118,      7,     12,      0,      0,    118,      0, }, /* 694 */\n  {   118,     12,      3,      0,      0,    118,      0, }, /* 695 */\n  {    60,      7,     12,      0,      0,     60,      0, }, /* 696 */\n  {    60,     21,     12,      0,      0,     60,      0, }, /* 697 */\n  {    43,      7,     12,      0,      0,     43,      0, }, /* 698 */\n  {    43,     21,     12,      0,      0,     43,      0, }, /* 699 */\n  {    43,     14,     12,      0,      0,     43,      0, }, /* 700 */\n  {    14,      9,     12,      0,     40,     14,      0, }, /* 701 */\n  {    14,      5,     12,      0,    -40,     14,      0, }, /* 702 */\n  {    47,      7,     12,      0,      0,     47,      0, }, /* 703 */\n  {    45,      7,     12,      0,      0,     45,      0, }, /* 704 */\n  {    45,     13,     12,      0,      0,     45,      0, }, /* 705 */\n  {   136,      9,     12,      0,     40,    136,      0, }, /* 706 */\n  {   136,      5,     12,      0,    -40,    136,      0, }, /* 707 */\n  {   106,      7,     12,      0,      0,    106,      0, }, /* 708 */\n  {   104,      7,     12,      0,      0,    104,      0, }, /* 709 */\n  {   104,     21,     12,      0,      0,    104,      0, }, /* 710 */\n  {   110,      7,     12,      0,      0,    110,      0, }, /* 711 */\n  {    12,      7,     12,      0,      0,     12,      0, }, /* 712 */\n  {    81,      7,     12,      0,      0,     81,      0, }, /* 713 */\n  {    81,     21,     12,      0,      0,     81,      0, }, /* 714 */\n  {    81,     15,     12,      0,      0,     81,      0, }, /* 715 */\n  {   120,      7,     12,      0,      0,    120,      0, }, /* 716 */\n  {   120,     26,     12,      0,      0,    120,      0, }, /* 717 */\n  {   120,     15,     12,      0,      0,    120,      0, }, /* 718 */\n  {   116,      7,     12,      0,      0,    116,      0, }, /* 719 */\n  {   116,     15,     12,      0,      0,    116,      0, }, /* 720 */\n  {   128,      7,     12,      0,      0,    128,      0, }, /* 721 */\n  {   128,     15,     12,      0,      0,    128,      0, }, /* 722 */\n  {    66,      7,     12,      0,      0,     66,      0, }, /* 723 */\n  {    66,     15,     12,      0,      0,     66,      0, }, /* 724 */\n  {    66,     21,     12,      0,      0,     66,      0, }, /* 725 */\n  {    72,      7,     12,      0,      0,     72,      0, }, /* 726 */\n  {    72,     21,     12,      0,      0,     72,      0, }, /* 727 */\n  {    98,      7,     12,      0,      0,     98,      0, }, /* 728 */\n  {    97,      7,     12,      0,      0,     97,      0, }, /* 729 */\n  {    97,     15,     12,      0,      0,     97,      0, }, /* 730 */\n  {    31,      7,     12,      0,      0,     31,      0, }, /* 731 */\n  {    31,     12,      3,      0,      0,     31,      0, }, /* 732 */\n  {    31,     15,     12,      0,      0,     31,      0, }, /* 733 */\n  {    31,     21,     12,      0,      0,     31,      0, }, /* 734 */\n  {    88,      7,     12,      0,      0,     88,      0, }, /* 735 */\n  {    88,     15,     12,      0,      0,     88,      0, }, /* 736 */\n  {    88,     21,     12,      0,      0,     88,      0, }, /* 737 */\n  {   117,      7,     12,      0,      0,    117,      0, }, /* 738 */\n  {   117,     15,     12,      0,      0,    117,      0, }, /* 739 */\n  {   112,      7,     12,      0,      0,    112,      0, }, /* 740 */\n  {   112,     26,     12,      0,      0,    112,      0, }, /* 741 */\n  {   112,     12,      3,      0,      0,    112,      0, }, /* 742 */\n  {   112,     15,     12,      0,      0,    112,      0, }, /* 743 */\n  {   112,     21,     12,      0,      0,    112,      0, }, /* 744 */\n  {    78,      7,     12,      0,      0,     78,      0, }, /* 745 */\n  {    78,     21,     12,      0,      0,     78,      0, }, /* 746 */\n  {    83,      7,     12,      0,      0,     83,      0, }, /* 747 */\n  {    83,     15,     12,      0,      0,     83,      0, }, /* 748 */\n  {    82,      7,     12,      0,      0,     82,      0, }, /* 749 */\n  {    82,     15,     12,      0,      0,     82,      0, }, /* 750 */\n  {   121,      7,     12,      0,      0,    121,      0, }, /* 751 */\n  {   121,     21,     12,      0,      0,    121,      0, }, /* 752 */\n  {   121,     15,     12,      0,      0,    121,      0, }, /* 753 */\n  {    89,      7,     12,      0,      0,     89,      0, }, /* 754 */\n  {   130,      9,     12,      0,     64,    130,      0, }, /* 755 */\n  {   130,      5,     12,      0,    -64,    130,      0, }, /* 756 */\n  {   130,     15,     12,      0,      0,    130,      0, }, /* 757 */\n  {   144,      7,     12,      0,      0,    144,      0, }, /* 758 */\n  {   144,     12,      3,      0,      0,    144,      0, }, /* 759 */\n  {   144,     13,     12,      0,      0,    144,      0, }, /* 760 */\n  {     1,     15,     12,      0,      0,      1,      0, }, /* 761 */\n  {   156,      7,     12,      0,      0,    156,      0, }, /* 762 */\n  {   156,     12,      3,      0,      0,    156,      0, }, /* 763 */\n  {   156,     17,     12,      0,      0,    156,      0, }, /* 764 */\n  {   147,      7,     12,      0,      0,    147,      0, }, /* 765 */\n  {   147,     15,     12,      0,      0,    147,      0, }, /* 766 */\n  {   148,      7,     12,      0,      0,    148,      0, }, /* 767 */\n  {   148,     12,      3,      0,      0,    148,      0, }, /* 768 */\n  {   148,     15,     12,      0,      0,    148,      0, }, /* 769 */\n  {   148,     21,     12,      0,      0,    148,      0, }, /* 770 */\n  {   153,      7,     12,      0,      0,    153,      0, }, /* 771 */\n  {   153,     15,     12,      0,      0,    153,      0, }, /* 772 */\n  {   149,      7,     12,      0,      0,    149,      0, }, /* 773 */\n  {    94,     10,      5,      0,      0,     94,      0, }, /* 774 */\n  {    94,     12,      3,      0,      0,     94,      0, }, /* 775 */\n  {    94,      7,     12,      0,      0,     94,      0, }, /* 776 */\n  {    94,     21,     12,      0,      0,     94,      0, }, /* 777 */\n  {    94,     15,     12,      0,      0,     94,      0, }, /* 778 */\n  {    94,     13,     12,      0,      0,     94,      0, }, /* 779 */\n  {    85,     12,      3,      0,      0,     85,      0, }, /* 780 */\n  {    85,     10,      5,      0,      0,     85,      0, }, /* 781 */\n  {    85,      7,     12,      0,      0,     85,      0, }, /* 782 */\n  {    85,     21,     12,      0,      0,     85,      0, }, /* 783 */\n  {    85,      1,      4,      0,      0,     85,      0, }, /* 784 */\n  {   101,      7,     12,      0,      0,    101,      0, }, /* 785 */\n  {   101,     13,     12,      0,      0,    101,      0, }, /* 786 */\n  {    96,     12,      3,      0,      0,     96,      0, }, /* 787 */\n  {    96,      7,     12,      0,      0,     96,      0, }, /* 788 */\n  {    96,     10,      5,      0,      0,     96,      0, }, /* 789 */\n  {    96,     13,     12,      0,      0,     96,      0, }, /* 790 */\n  {    96,     21,     12,      0,      0,     96,      0, }, /* 791 */\n  {   111,      7,     12,      0,      0,    111,      0, }, /* 792 */\n  {   111,     12,      3,      0,      0,    111,      0, }, /* 793 */\n  {   111,     21,     12,      0,      0,    111,      0, }, /* 794 */\n  {   100,     12,      3,      0,      0,    100,      0, }, /* 795 */\n  {   100,     10,      5,      0,      0,    100,      0, }, /* 796 */\n  {   100,      7,     12,      0,      0,    100,      0, }, /* 797 */\n  {   100,      7,      4,      0,      0,    100,      0, }, /* 798 */\n  {   100,     21,     12,      0,      0,    100,      0, }, /* 799 */\n  {   100,     13,     12,      0,      0,    100,      0, }, /* 800 */\n  {    48,     15,     12,      0,      0,     48,      0, }, /* 801 */\n  {   108,      7,     12,      0,      0,    108,      0, }, /* 802 */\n  {   108,     10,      5,      0,      0,    108,      0, }, /* 803 */\n  {   108,     12,      3,      0,      0,    108,      0, }, /* 804 */\n  {   108,     21,     12,      0,      0,    108,      0, }, /* 805 */\n  {   129,      7,     12,      0,      0,    129,      0, }, /* 806 */\n  {   129,     21,     12,      0,      0,    129,      0, }, /* 807 */\n  {   109,      7,     12,      0,      0,    109,      0, }, /* 808 */\n  {   109,     12,      3,      0,      0,    109,      0, }, /* 809 */\n  {   109,     10,      5,      0,      0,    109,      0, }, /* 810 */\n  {   109,     13,     12,      0,      0,    109,      0, }, /* 811 */\n  {   107,     12,      3,      0,      0,    107,      0, }, /* 812 */\n  {   107,     12,      3,      0,      0,    -52,      0, }, /* 813 */\n  {   107,     10,      5,      0,      0,    107,      0, }, /* 814 */\n  {   107,     10,      5,      0,      0,    -52,      0, }, /* 815 */\n  {   107,      7,     12,      0,      0,    107,      0, }, /* 816 */\n  {    28,     12,      3,      0,      0,    -52,      0, }, /* 817 */\n  {   107,     10,      3,      0,      0,    107,      0, }, /* 818 */\n  {   135,      7,     12,      0,      0,    135,      0, }, /* 819 */\n  {   135,     10,      5,      0,      0,    135,      0, }, /* 820 */\n  {   135,     12,      3,      0,      0,    135,      0, }, /* 821 */\n  {   135,     21,     12,      0,      0,    135,      0, }, /* 822 */\n  {   135,     13,     12,      0,      0,    135,      0, }, /* 823 */\n  {   124,      7,     12,      0,      0,    124,      0, }, /* 824 */\n  {   124,     10,      3,      0,      0,    124,      0, }, /* 825 */\n  {   124,     10,      5,      0,      0,    124,      0, }, /* 826 */\n  {   124,     12,      3,      0,      0,    124,      0, }, /* 827 */\n  {   124,     21,     12,      0,      0,    124,      0, }, /* 828 */\n  {   124,     13,     12,      0,      0,    124,      0, }, /* 829 */\n  {   123,      7,     12,      0,      0,    123,      0, }, /* 830 */\n  {   123,     10,      3,      0,      0,    123,      0, }, /* 831 */\n  {   123,     10,      5,      0,      0,    123,      0, }, /* 832 */\n  {   123,     12,      3,      0,      0,    123,      0, }, /* 833 */\n  {   123,     21,     12,      0,      0,    123,      0, }, /* 834 */\n  {   114,      7,     12,      0,      0,    114,      0, }, /* 835 */\n  {   114,     10,      5,      0,      0,    114,      0, }, /* 836 */\n  {   114,     12,      3,      0,      0,    114,      0, }, /* 837 */\n  {   114,     21,     12,      0,      0,    114,      0, }, /* 838 */\n  {   114,     13,     12,      0,      0,    114,      0, }, /* 839 */\n  {   102,      7,     12,      0,      0,    102,      0, }, /* 840 */\n  {   102,     12,      3,      0,      0,    102,      0, }, /* 841 */\n  {   102,     10,      5,      0,      0,    102,      0, }, /* 842 */\n  {   102,     13,     12,      0,      0,    102,      0, }, /* 843 */\n  {   126,      7,     12,      0,      0,    126,      0, }, /* 844 */\n  {   126,     12,      3,      0,      0,    126,      0, }, /* 845 */\n  {   126,     10,      5,      0,      0,    126,      0, }, /* 846 */\n  {   126,     13,     12,      0,      0,    126,      0, }, /* 847 */\n  {   126,     15,     12,      0,      0,    126,      0, }, /* 848 */\n  {   126,     21,     12,      0,      0,    126,      0, }, /* 849 */\n  {   126,     26,     12,      0,      0,    126,      0, }, /* 850 */\n  {   142,      7,     12,      0,      0,    142,      0, }, /* 851 */\n  {   142,     10,      5,      0,      0,    142,      0, }, /* 852 */\n  {   142,     12,      3,      0,      0,    142,      0, }, /* 853 */\n  {   142,     21,     12,      0,      0,    142,      0, }, /* 854 */\n  {   125,      9,     12,      0,     32,    125,      0, }, /* 855 */\n  {   125,      5,     12,      0,    -32,    125,      0, }, /* 856 */\n  {   125,     13,     12,      0,      0,    125,      0, }, /* 857 */\n  {   125,     15,     12,      0,      0,    125,      0, }, /* 858 */\n  {   125,      7,     12,      0,      0,    125,      0, }, /* 859 */\n  {   154,      7,     12,      0,      0,    154,      0, }, /* 860 */\n  {   154,     10,      3,      0,      0,    154,      0, }, /* 861 */\n  {   154,     10,      5,      0,      0,    154,      0, }, /* 862 */\n  {   154,     12,      3,      0,      0,    154,      0, }, /* 863 */\n  {   154,      7,      4,      0,      0,    154,      0, }, /* 864 */\n  {   154,     21,     12,      0,      0,    154,      0, }, /* 865 */\n  {   154,     13,     12,      0,      0,    154,      0, }, /* 866 */\n  {   150,      7,     12,      0,      0,    150,      0, }, /* 867 */\n  {   150,     10,      5,      0,      0,    150,      0, }, /* 868 */\n  {   150,     12,      3,      0,      0,    150,      0, }, /* 869 */\n  {   150,     21,     12,      0,      0,    150,      0, }, /* 870 */\n  {   141,      7,     12,      0,      0,    141,      0, }, /* 871 */\n  {   141,     12,      3,      0,      0,    141,      0, }, /* 872 */\n  {   141,     10,      5,      0,      0,    141,      0, }, /* 873 */\n  {   141,      7,      4,      0,      0,    141,      0, }, /* 874 */\n  {   141,     21,     12,      0,      0,    141,      0, }, /* 875 */\n  {   140,      7,     12,      0,      0,    140,      0, }, /* 876 */\n  {   140,     12,      3,      0,      0,    140,      0, }, /* 877 */\n  {   140,     10,      5,      0,      0,    140,      0, }, /* 878 */\n  {   140,      7,      4,      0,      0,    140,      0, }, /* 879 */\n  {   140,     21,     12,      0,      0,    140,      0, }, /* 880 */\n  {   122,      7,     12,      0,      0,    122,      0, }, /* 881 */\n  {   133,      7,     12,      0,      0,    133,      0, }, /* 882 */\n  {   133,     10,      5,      0,      0,    133,      0, }, /* 883 */\n  {   133,     12,      3,      0,      0,    133,      0, }, /* 884 */\n  {   133,     21,     12,      0,      0,    133,      0, }, /* 885 */\n  {   133,     13,     12,      0,      0,    133,      0, }, /* 886 */\n  {   133,     15,     12,      0,      0,    133,      0, }, /* 887 */\n  {   134,     21,     12,      0,      0,    134,      0, }, /* 888 */\n  {   134,      7,     12,      0,      0,    134,      0, }, /* 889 */\n  {   134,     12,      3,      0,      0,    134,      0, }, /* 890 */\n  {   134,     10,      5,      0,      0,    134,      0, }, /* 891 */\n  {   138,      7,     12,      0,      0,    138,      0, }, /* 892 */\n  {   138,     12,      3,      0,      0,    138,      0, }, /* 893 */\n  {   138,      7,      4,      0,      0,    138,      0, }, /* 894 */\n  {   138,     13,     12,      0,      0,    138,      0, }, /* 895 */\n  {   143,      7,     12,      0,      0,    143,      0, }, /* 896 */\n  {   143,     10,      5,      0,      0,    143,      0, }, /* 897 */\n  {   143,     12,      3,      0,      0,    143,      0, }, /* 898 */\n  {   143,     13,     12,      0,      0,    143,      0, }, /* 899 */\n  {   145,      7,     12,      0,      0,    145,      0, }, /* 900 */\n  {   145,     12,      3,      0,      0,    145,      0, }, /* 901 */\n  {   145,     10,      5,      0,      0,    145,      0, }, /* 902 */\n  {   145,     21,     12,      0,      0,    145,      0, }, /* 903 */\n  {    54,     15,     12,      0,      0,     54,      0, }, /* 904 */\n  {    54,     21,     12,      0,      0,     54,      0, }, /* 905 */\n  {    63,      7,     12,      0,      0,     63,      0, }, /* 906 */\n  {    63,     14,     12,      0,      0,     63,      0, }, /* 907 */\n  {    63,     21,     12,      0,      0,     63,      0, }, /* 908 */\n  {    80,      7,     12,      0,      0,     80,      0, }, /* 909 */\n  {    80,      1,      2,      0,      0,     80,      0, }, /* 910 */\n  {   127,      7,     12,      0,      0,    127,      0, }, /* 911 */\n  {   115,      7,     12,      0,      0,    115,      0, }, /* 912 */\n  {   115,     13,     12,      0,      0,    115,      0, }, /* 913 */\n  {   115,     21,     12,      0,      0,    115,      0, }, /* 914 */\n  {   103,      7,     12,      0,      0,    103,      0, }, /* 915 */\n  {   103,     12,      3,      0,      0,    103,      0, }, /* 916 */\n  {   103,     21,     12,      0,      0,    103,      0, }, /* 917 */\n  {   119,      7,     12,      0,      0,    119,      0, }, /* 918 */\n  {   119,     12,      3,      0,      0,    119,      0, }, /* 919 */\n  {   119,     21,     12,      0,      0,    119,      0, }, /* 920 */\n  {   119,     26,     12,      0,      0,    119,      0, }, /* 921 */\n  {   119,      6,     12,      0,      0,    119,      0, }, /* 922 */\n  {   119,     13,     12,      0,      0,    119,      0, }, /* 923 */\n  {   119,     15,     12,      0,      0,    119,      0, }, /* 924 */\n  {   146,      9,     12,      0,     32,    146,      0, }, /* 925 */\n  {   146,      5,     12,      0,    -32,    146,      0, }, /* 926 */\n  {   146,     15,     12,      0,      0,    146,      0, }, /* 927 */\n  {   146,     21,     12,      0,      0,    146,      0, }, /* 928 */\n  {    99,      7,     12,      0,      0,     99,      0, }, /* 929 */\n  {    99,     12,      3,      0,      0,     99,      0, }, /* 930 */\n  {    99,     10,      5,      0,      0,     99,      0, }, /* 931 */\n  {    99,      6,     12,      0,      0,     99,      0, }, /* 932 */\n  {   137,      6,     12,      0,      0,    137,      0, }, /* 933 */\n  {   139,      6,     12,      0,      0,    139,      0, }, /* 934 */\n  {   155,     12,      3,      0,      0,    155,      0, }, /* 935 */\n  {    23,     10,      5,      0,      0,     23,      0, }, /* 936 */\n  {   137,      7,     12,      0,      0,    137,      0, }, /* 937 */\n  {   155,      7,     12,      0,      0,    155,      0, }, /* 938 */\n  {   139,      7,     12,      0,      0,    139,      0, }, /* 939 */\n  {   105,      7,     12,      0,      0,    105,      0, }, /* 940 */\n  {   105,     26,     12,      0,      0,    105,      0, }, /* 941 */\n  {   105,     12,      3,      0,      0,    105,      0, }, /* 942 */\n  {   105,     21,     12,      0,      0,    105,      0, }, /* 943 */\n  {    10,      1,      2,      0,      0,    105,      0, }, /* 944 */\n  {    10,     10,      3,      0,      0,     10,      0, }, /* 945 */\n  {    10,     10,      5,      0,      0,     10,      0, }, /* 946 */\n  {    20,     12,      3,      0,      0,     20,      0, }, /* 947 */\n  {   131,     26,     12,      0,      0,    131,      0, }, /* 948 */\n  {   131,     12,      3,      0,      0,    131,      0, }, /* 949 */\n  {   131,     21,     12,      0,      0,    131,      0, }, /* 950 */\n  {    18,     12,      3,      0,      0,     18,      0, }, /* 951 */\n  {   151,      7,     12,      0,      0,    151,      0, }, /* 952 */\n  {   151,     12,      3,      0,      0,    151,      0, }, /* 953 */\n  {   151,      6,     12,      0,      0,    151,      0, }, /* 954 */\n  {   151,     13,     12,      0,      0,    151,      0, }, /* 955 */\n  {   151,     26,     12,      0,      0,    151,      0, }, /* 956 */\n  {   152,      7,     12,      0,      0,    152,      0, }, /* 957 */\n  {   152,     12,      3,      0,      0,    152,      0, }, /* 958 */\n  {   152,     13,     12,      0,      0,    152,      0, }, /* 959 */\n  {   152,     23,     12,      0,      0,    152,      0, }, /* 960 */\n  {   113,      7,     12,      0,      0,    113,      0, }, /* 961 */\n  {   113,     15,     12,      0,      0,    113,      0, }, /* 962 */\n  {   113,     12,      3,      0,      0,    113,      0, }, /* 963 */\n  {   132,      9,     12,      0,     34,    132,      0, }, /* 964 */\n  {   132,      5,     12,      0,    -34,    132,      0, }, /* 965 */\n  {   132,     12,      3,      0,      0,    132,      0, }, /* 966 */\n  {   132,      6,     12,      0,      0,    132,      0, }, /* 967 */\n  {   132,     13,     12,      0,      0,    132,      0, }, /* 968 */\n  {   132,     21,     12,      0,      0,    132,      0, }, /* 969 */\n  {     0,      2,     14,      0,      0,      0,      0, }, /* 970 */\n  {    10,     26,     11,      0,      0,     10,      0, }, /* 971 */\n  {    27,     26,     12,      0,      0,     27,      0, }, /* 972 */\n  {    10,     24,      3,      0,      0,     10,      0, }, /* 973 */\n  {    10,      1,      3,      0,      0,     10,      0, }, /* 974 */\n};\n\nconst uint16_t PRIV(ucd_stage1)\u00dd\u00a8 = { /* 17408 bytes */\n  0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, /* U+0000 */\n 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, /* U+0800 */\n 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 41, 41, 42, 43, 44, 45, /* U+1000 */\n 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, /* U+1800 */\n 62, 63, 64, 65, 66, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, /* U+2000 */\n 77, 77, 78, 79, 66, 66, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, /* U+2800 */\n 90, 91, 92, 93, 94, 95, 96, 97, 98, 98, 98, 98, 98, 98, 98, 98, /* U+3000 */\n 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, /* U+3800 */\n 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, /* U+4000 */\n 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 99, 98, 98, 98, 98, /* U+4800 */\n 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, /* U+5000 */\n 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, /* U+5800 */\n 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, /* U+6000 */\n 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, /* U+6800 */\n 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, /* U+7000 */\n 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, /* U+7800 */\n 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, /* U+8000 */\n 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, /* U+8800 */\n 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, /* U+9000 */\n 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98,100, /* U+9800 */\n101,102,102,102,102,102,102,102,102,103,104,104,105,106,107,108, /* U+A000 */\n109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,117, /* U+A800 */\n118,119,120,121,122,123,117,118,119,120,121,122,123,117,118,119, /* U+B000 */\n120,121,122,123,117,118,119,120,121,122,123,117,118,119,120,121, /* U+B800 */\n122,123,117,118,119,120,121,122,123,117,118,119,120,121,122,123, /* U+C000 */\n117,118,119,120,121,122,123,117,118,119,120,121,122,123,117,118, /* U+C800 */\n119,120,121,122,123,117,118,119,120,121,122,123,117,118,119,124, /* U+D000 */\n125,125,125,125,125,125,125,125,125,125,125,125,125,125,125,125, /* U+D800 */\n126,126,126,126,126,126,126,126,126,126,126,126,126,126,126,126, /* U+E000 */\n126,126,126,126,126,126,126,126,126,126,126,126,126,126,126,126, /* U+E800 */\n126,126,126,126,126,126,126,126,126,126,126,126,126,126,126,126, /* U+F000 */\n126,126, 98, 98,127,128,129,130,131,131,132,133,134,135,136,137, /* U+F800 */\n138,139,140,141,142,143,144,145,146,147,148,142,149,149,150,142, /* U+10000 */\n151,152,153,154,155,156,157,158,159,160,161,142,162,163,164,165, /* U+10800 */\n166,167,168,169,170,171,172,142,173,174,142,175,176,177,178,142, /* U+11000 */\n179,180,181,182,183,184,142,142,185,186,187,188,142,189,142,190, /* U+11800 */\n191,191,191,191,191,191,191,192,193,191,194,142,142,142,142,142, /* U+12000 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+12800 */\n195,195,195,195,195,195,195,195,196,142,142,142,142,142,142,142, /* U+13000 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+13800 */\n142,142,142,142,142,142,142,142,197,197,197,197,198,142,142,142, /* U+14000 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+14800 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+15000 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+15800 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+16000 */\n199,199,199,199,200,201,202,203,142,142,142,142,204,205,206,207, /* U+16800 */\n208,208,208,208,208,208,208,208,208,208,208,208,208,208,208,208, /* U+17000 */\n208,208,208,208,208,208,208,208,208,208,208,208,208,208,208,208, /* U+17800 */\n208,208,208,208,208,208,208,208,208,208,208,208,208,208,208,209, /* U+18000 */\n208,208,208,208,208,208,210,210,210,211,212,142,142,142,142,142, /* U+18800 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+19000 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+19800 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+1A000 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+1A800 */\n213,214,215,216,216,217,142,142,142,142,142,142,142,142,142,142, /* U+1B000 */\n142,142,142,142,142,142,142,142,218,219,142,142,142,142,142,142, /* U+1B800 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+1C000 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+1C800 */\n 71,220,221,222,223,224,225,142,226,227,228,229,230,231,232,233, /* U+1D000 */\n234,234,234,234,235,236,142,142,142,142,142,142,142,142,142,142, /* U+1D800 */\n237,142,238,142,142,239,142,142,142,142,142,142,142,142,142,142, /* U+1E000 */\n240,241,242,142,142,142,142,142,243,244,245,142,246,247,142,142, /* U+1E800 */\n248,249,250,251,252,253,254,255,254,254,256,254,257,258,259,260, /* U+1F000 */\n261,262,263,264,265,266, 71,267,253,253,253,253,253,253,253,268, /* U+1F800 */\n 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, /* U+20000 */\n 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, /* U+20800 */\n 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, /* U+21000 */\n 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, /* U+21800 */\n 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, /* U+22000 */\n 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, /* U+22800 */\n 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, /* U+23000 */\n 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, /* U+23800 */\n 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, /* U+24000 */\n 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, /* U+24800 */\n 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, /* U+25000 */\n 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, /* U+25800 */\n 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, /* U+26000 */\n 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, /* U+26800 */\n 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, /* U+27000 */\n 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, /* U+27800 */\n 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, /* U+28000 */\n 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, /* U+28800 */\n 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, /* U+29000 */\n 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, /* U+29800 */\n 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98,269, 98, 98, /* U+2A000 */\n 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, /* U+2A800 */\n 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98,270, 98, /* U+2B000 */\n271, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, /* U+2B800 */\n 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, /* U+2C000 */\n 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98,272, 98, 98, /* U+2C800 */\n 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, /* U+2D000 */\n 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, /* U+2D800 */\n 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, /* U+2E000 */\n 98, 98, 98, 98, 98, 98, 98,273,142,142,142,142,142,142,142,142, /* U+2E800 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+2F000 */\n 98, 98, 98, 98,274,142,142,142,142,142,142,142,142,142,142,142, /* U+2F800 */\n 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, /* U+30000 */\n 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, /* U+30800 */\n 98, 98, 98, 98, 98, 98,275,142,142,142,142,142,142,142,142,142, /* U+31000 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+31800 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+32000 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+32800 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+33000 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+33800 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+34000 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+34800 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+35000 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+35800 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+36000 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+36800 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+37000 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+37800 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+38000 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+38800 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+39000 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+39800 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+3A000 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+3A800 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+3B000 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+3B800 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+3C000 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+3C800 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+3D000 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+3D800 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+3E000 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+3E800 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+3F000 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+3F800 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+40000 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+40800 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+41000 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+41800 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+42000 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+42800 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+43000 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+43800 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+44000 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+44800 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+45000 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+45800 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+46000 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+46800 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+47000 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+47800 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+48000 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+48800 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+49000 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+49800 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+4A000 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+4A800 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+4B000 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+4B800 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+4C000 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+4C800 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+4D000 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+4D800 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+4E000 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+4E800 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+4F000 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+4F800 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+50000 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+50800 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+51000 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+51800 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+52000 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+52800 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+53000 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+53800 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+54000 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+54800 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+55000 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+55800 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+56000 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+56800 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+57000 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+57800 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+58000 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+58800 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+59000 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+59800 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+5A000 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+5A800 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+5B000 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+5B800 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+5C000 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+5C800 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+5D000 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+5D800 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+5E000 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+5E800 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+5F000 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+5F800 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+60000 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+60800 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+61000 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+61800 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+62000 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+62800 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+63000 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+63800 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+64000 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+64800 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+65000 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+65800 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+66000 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+66800 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+67000 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+67800 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+68000 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+68800 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+69000 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+69800 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+6A000 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+6A800 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+6B000 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+6B800 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+6C000 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+6C800 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+6D000 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+6D800 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+6E000 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+6E800 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+6F000 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+6F800 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+70000 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+70800 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+71000 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+71800 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+72000 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+72800 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+73000 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+73800 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+74000 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+74800 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+75000 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+75800 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+76000 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+76800 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+77000 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+77800 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+78000 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+78800 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+79000 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+79800 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+7A000 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+7A800 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+7B000 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+7B800 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+7C000 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+7C800 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+7D000 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+7D800 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+7E000 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+7E800 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+7F000 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+7F800 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+80000 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+80800 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+81000 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+81800 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+82000 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+82800 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+83000 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+83800 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+84000 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+84800 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+85000 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+85800 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+86000 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+86800 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+87000 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+87800 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+88000 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+88800 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+89000 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+89800 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+8A000 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+8A800 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+8B000 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+8B800 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+8C000 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+8C800 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+8D000 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+8D800 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+8E000 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+8E800 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+8F000 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+8F800 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+90000 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+90800 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+91000 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+91800 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+92000 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+92800 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+93000 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+93800 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+94000 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+94800 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+95000 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+95800 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+96000 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+96800 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+97000 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+97800 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+98000 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+98800 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+99000 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+99800 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+9A000 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+9A800 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+9B000 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+9B800 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+9C000 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+9C800 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+9D000 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+9D800 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+9E000 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+9E800 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+9F000 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+9F800 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+A0000 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+A0800 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+A1000 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+A1800 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+A2000 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+A2800 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+A3000 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+A3800 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+A4000 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+A4800 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+A5000 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+A5800 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+A6000 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+A6800 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+A7000 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+A7800 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+A8000 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+A8800 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+A9000 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+A9800 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+AA000 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+AA800 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+AB000 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+AB800 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+AC000 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+AC800 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+AD000 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+AD800 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+AE000 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+AE800 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+AF000 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+AF800 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+B0000 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+B0800 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+B1000 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+B1800 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+B2000 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+B2800 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+B3000 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+B3800 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+B4000 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+B4800 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+B5000 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+B5800 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+B6000 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+B6800 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+B7000 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+B7800 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+B8000 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+B8800 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+B9000 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+B9800 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+BA000 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+BA800 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+BB000 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+BB800 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+BC000 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+BC800 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+BD000 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+BD800 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+BE000 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+BE800 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+BF000 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+BF800 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+C0000 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+C0800 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+C1000 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+C1800 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+C2000 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+C2800 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+C3000 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+C3800 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+C4000 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+C4800 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+C5000 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+C5800 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+C6000 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+C6800 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+C7000 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+C7800 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+C8000 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+C8800 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+C9000 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+C9800 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+CA000 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+CA800 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+CB000 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+CB800 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+CC000 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+CC800 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+CD000 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+CD800 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+CE000 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+CE800 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+CF000 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+CF800 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+D0000 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+D0800 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+D1000 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+D1800 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+D2000 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+D2800 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+D3000 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+D3800 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+D4000 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+D4800 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+D5000 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+D5800 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+D6000 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+D6800 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+D7000 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+D7800 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+D8000 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+D8800 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+D9000 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+D9800 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+DA000 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+DA800 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+DB000 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+DB800 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+DC000 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+DC800 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+DD000 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+DD800 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+DE000 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+DE800 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+DF000 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+DF800 */\n276,277,278,279,277,277,277,277,277,277,277,277,277,277,277,277, /* U+E0000 */\n277,277,277,277,277,277,277,277,277,277,277,277,277,277,277,277, /* U+E0800 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+E1000 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+E1800 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+E2000 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+E2800 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+E3000 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+E3800 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+E4000 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+E4800 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+E5000 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+E5800 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+E6000 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+E6800 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+E7000 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+E7800 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+E8000 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+E8800 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+E9000 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+E9800 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+EA000 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+EA800 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+EB000 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+EB800 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+EC000 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+EC800 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+ED000 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+ED800 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+EE000 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+EE800 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+EF000 */\n142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142, /* U+EF800 */\n126,126,126,126,126,126,126,126,126,126,126,126,126,126,126,126, /* U+F0000 */\n126,126,126,126,126,126,126,126,126,126,126,126,126,126,126,126, /* U+F0800 */\n126,126,126,126,126,126,126,126,126,126,126,126,126,126,126,126, /* U+F1000 */\n126,126,126,126,126,126,126,126,126,126,126,126,126,126,126,126, /* U+F1800 */\n126,126,126,126,126,126,126,126,126,126,126,126,126,126,126,126, /* U+F2000 */\n126,126,126,126,126,126,126,126,126,126,126,126,126,126,126,126, /* U+F2800 */\n126,126,126,126,126,126,126,126,126,126,126,126,126,126,126,126, /* U+F3000 */\n126,126,126,126,126,126,126,126,126,126,126,126,126,126,126,126, /* U+F3800 */\n126,126,126,126,126,126,126,126,126,126,126,126,126,126,126,126, /* U+F4000 */\n126,126,126,126,126,126,126,126,126,126,126,126,126,126,126,126, /* U+F4800 */\n126,126,126,126,126,126,126,126,126,126,126,126,126,126,126,126, /* U+F5000 */\n126,126,126,126,126,126,126,126,126,126,126,126,126,126,126,126, /* U+F5800 */\n126,126,126,126,126,126,126,126,126,126,126,126,126,126,126,126, /* U+F6000 */\n126,126,126,126,126,126,126,126,126,126,126,126,126,126,126,126, /* U+F6800 */\n126,126,126,126,126,126,126,126,126,126,126,126,126,126,126,126, /* U+F7000 */\n126,126,126,126,126,126,126,126,126,126,126,126,126,126,126,126, /* U+F7800 */\n126,126,126,126,126,126,126,126,126,126,126,126,126,126,126,126, /* U+F8000 */\n126,126,126,126,126,126,126,126,126,126,126,126,126,126,126,126, /* U+F8800 */\n126,126,126,126,126,126,126,126,126,126,126,126,126,126,126,126, /* U+F9000 */\n126,126,126,126,126,126,126,126,126,126,126,126,126,126,126,126, /* U+F9800 */\n126,126,126,126,126,126,126,126,126,126,126,126,126,126,126,126, /* U+FA000 */\n126,126,126,126,126,126,126,126,126,126,126,126,126,126,126,126, /* U+FA800 */\n126,126,126,126,126,126,126,126,126,126,126,126,126,126,126,126, /* U+FB000 */\n126,126,126,126,126,126,126,126,126,126,126,126,126,126,126,126, /* U+FB800 */\n126,126,126,126,126,126,126,126,126,126,126,126,126,126,126,126, /* U+FC000 */\n126,126,126,126,126,126,126,126,126,126,126,126,126,126,126,126, /* U+FC800 */\n126,126,126,126,126,126,126,126,126,126,126,126,126,126,126,126, /* U+FD000 */\n126,126,126,126,126,126,126,126,126,126,126,126,126,126,126,126, /* U+FD800 */\n126,126,126,126,126,126,126,126,126,126,126,126,126,126,126,126, /* U+FE000 */\n126,126,126,126,126,126,126,126,126,126,126,126,126,126,126,126, /* U+FE800 */\n126,126,126,126,126,126,126,126,126,126,126,126,126,126,126,126, /* U+FF000 */\n126,126,126,126,126,126,126,126,126,126,126,126,126,126,126,280, /* U+FF800 */\n126,126,126,126,126,126,126,126,126,126,126,126,126,126,126,126, /* U+100000 */\n126,126,126,126,126,126,126,126,126,126,126,126,126,126,126,126, /* U+100800 */\n126,126,126,126,126,126,126,126,126,126,126,126,126,126,126,126, /* U+101000 */\n126,126,126,126,126,126,126,126,126,126,126,126,126,126,126,126, /* U+101800 */\n126,126,126,126,126,126,126,126,126,126,126,126,126,126,126,126, /* U+102000 */\n126,126,126,126,126,126,126,126,126,126,126,126,126,126,126,126, /* U+102800 */\n126,126,126,126,126,126,126,126,126,126,126,126,126,126,126,126, /* U+103000 */\n126,126,126,126,126,126,126,126,126,126,126,126,126,126,126,126, /* U+103800 */\n126,126,126,126,126,126,126,126,126,126,126,126,126,126,126,126, /* U+104000 */\n126,126,126,126,126,126,126,126,126,126,126,126,126,126,126,126, /* U+104800 */\n126,126,126,126,126,126,126,126,126,126,126,126,126,126,126,126, /* U+105000 */\n126,126,126,126,126,126,126,126,126,126,126,126,126,126,126,126, /* U+105800 */\n126,126,126,126,126,126,126,126,126,126,126,126,126,126,126,126, /* U+106000 */\n126,126,126,126,126,126,126,126,126,126,126,126,126,126,126,126, /* U+106800 */\n126,126,126,126,126,126,126,126,126,126,126,126,126,126,126,126, /* U+107000 */\n126,126,126,126,126,126,126,126,126,126,126,126,126,126,126,126, /* U+107800 */\n126,126,126,126,126,126,126,126,126,126,126,126,126,126,126,126, /* U+108000 */\n126,126,126,126,126,126,126,126,126,126,126,126,126,126,126,126, /* U+108800 */\n126,126,126,126,126,126,126,126,126,126,126,126,126,126,126,126, /* U+109000 */\n126,126,126,126,126,126,126,126,126,126,126,126,126,126,126,126, /* U+109800 */\n126,126,126,126,126,126,126,126,126,126,126,126,126,126,126,126, /* U+10A000 */\n126,126,126,126,126,126,126,126,126,126,126,126,126,126,126,126, /* U+10A800 */\n126,126,126,126,126,126,126,126,126,126,126,126,126,126,126,126, /* U+10B000 */\n126,126,126,126,126,126,126,126,126,126,126,126,126,126,126,126, /* U+10B800 */\n126,126,126,126,126,126,126,126,126,126,126,126,126,126,126,126, /* U+10C000 */\n126,126,126,126,126,126,126,126,126,126,126,126,126,126,126,126, /* U+10C800 */\n126,126,126,126,126,126,126,126,126,126,126,126,126,126,126,126, /* U+10D000 */\n126,126,126,126,126,126,126,126,126,126,126,126,126,126,126,126, /* U+10D800 */\n126,126,126,126,126,126,126,126,126,126,126,126,126,126,126,126, /* U+10E000 */\n126,126,126,126,126,126,126,126,126,126,126,126,126,126,126,126, /* U+10E800 */\n126,126,126,126,126,126,126,126,126,126,126,126,126,126,126,126, /* U+10F000 */\n126,126,126,126,126,126,126,126,126,126,126,126,126,126,126,280, /* U+10F800 */\n};\n\nconst uint16_t PRIV(ucd_stage2)\u00dd\u00a8 = { /* 71936 bytes, block = 128 */\n/* block 0 */\n  0,  1,  1,  1,  1,  1,  1,  1,  1,  1,  2,  1,  1,  3,  1,  1,\n  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,\n  4,  5,  5,  5,  6,  5,  5,  5,  7,  8,  5,  9,  5, 10,  5,  5,\n 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,  5,  5,  9,  9,  9,  5,\n  5, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 13, 12, 12, 12, 12,\n 12, 12, 12, 14, 12, 12, 12, 12, 12, 12, 12,  7,  5,  8, 15, 16,\n 15, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 18, 17, 17, 17, 17,\n 17, 17, 17, 19, 17, 17, 17, 17, 17, 17, 17,  7,  9,  8,  9,  1,\n\n/* block 1 */\n  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,\n  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,\n  4,  5,  6,  6,  6,  6, 20,  5, 15, 21, 22, 23,  9, 24, 21, 15,\n 20,  9, 25, 25, 15, 26,  5,  5, 15, 25, 22, 27, 25, 25, 25,  5,\n 12, 12, 12, 12, 12, 28, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,\n 12, 12, 12, 12, 12, 12, 12,  9, 12, 12, 12, 12, 12, 12, 12, 29,\n 17, 17, 17, 17, 17, 30, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,\n 17, 17, 17, 17, 17, 17, 17,  9, 17, 17, 17, 17, 17, 17, 17, 31,\n\n/* block 2 */\n 32, 33, 32, 33, 32, 33, 32, 33, 32, 33, 32, 33, 32, 33, 32, 33,\n 32, 33, 32, 33, 32, 33, 32, 33, 32, 33, 32, 33, 32, 33, 32, 33,\n 32, 33, 32, 33, 32, 33, 32, 33, 32, 33, 32, 33, 32, 33, 32, 33,\n 34, 35, 32, 33, 32, 33, 32, 33, 35, 32, 33, 32, 33, 32, 33, 32,\n 33, 32, 33, 32, 33, 32, 33, 32, 33, 35, 32, 33, 32, 33, 32, 33,\n 32, 33, 32, 33, 32, 33, 32, 33, 32, 33, 32, 33, 32, 33, 32, 33,\n 32, 33, 32, 33, 32, 33, 32, 33, 32, 33, 32, 33, 32, 33, 32, 33,\n 32, 33, 32, 33, 32, 33, 32, 33, 36, 32, 33, 32, 33, 32, 33, 37,\n\n/* block 3 */\n 38, 39, 32, 33, 32, 33, 40, 32, 33, 41, 41, 32, 33, 35, 42, 43,\n 44, 32, 33, 41, 45, 46, 47, 48, 32, 33, 49, 35, 47, 50, 51, 52,\n 32, 33, 32, 33, 32, 33, 53, 32, 33, 53, 35, 35, 32, 33, 53, 32,\n 33, 54, 54, 32, 33, 32, 33, 55, 32, 33, 35, 22, 32, 33, 35, 56,\n 22, 22, 22, 22, 57, 58, 59, 60, 61, 62, 63, 64, 65, 32, 33, 32,\n 33, 32, 33, 32, 33, 32, 33, 32, 33, 32, 33, 32, 33, 66, 32, 33,\n 32, 33, 32, 33, 32, 33, 32, 33, 32, 33, 32, 33, 32, 33, 32, 33,\n 35, 67, 68, 69, 32, 33, 70, 71, 32, 33, 32, 33, 32, 33, 32, 33,\n\n/* block 4 */\n 32, 33, 32, 33, 32, 33, 32, 33, 32, 33, 32, 33, 32, 33, 32, 33,\n 32, 33, 32, 33, 32, 33, 32, 33, 32, 33, 32, 33, 32, 33, 32, 33,\n 72, 35, 32, 33, 32, 33, 32, 33, 32, 33, 32, 33, 32, 33, 32, 33,\n 32, 33, 32, 33, 35, 35, 35, 35, 35, 35, 73, 32, 33, 74, 75, 76,\n 76, 32, 33, 77, 78, 79, 32, 33, 32, 33, 32, 33, 32, 33, 32, 33,\n 80, 81, 82, 83, 84, 35, 85, 85, 35, 86, 35, 87, 88, 35, 35, 35,\n 85, 89, 35, 90, 35, 91, 92, 35, 93, 94, 92, 95, 96, 35, 35, 94,\n 35, 97, 98, 35, 35, 99, 35, 35, 35, 35, 35, 35, 35,100, 35, 35,\n\n/* block 5 */\n101, 35,102,101, 35, 35, 35,103,101,104,105,105,106, 35, 35, 35,\n 35, 35,107, 35, 22, 35, 35, 35, 35, 35, 35, 35, 35,108,109, 35,\n 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,\n110,110,110,110,110,110,110,110,110,111,111,111,111,111,111,111,\n111,111, 15, 15, 15, 15,111,111,111,111,111,111,111,111,111,111,\n111,111, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n110,110,110,110,110, 15, 15, 15, 15, 15,112,112,111, 15,111, 15,\n 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n\n/* block 6 */\n113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,\n113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,\n113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,\n113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,\n113,113,114,113,113,115,113,113,113,113,113,113,113,113,113,113,\n113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,\n113,113,113,116,116,116,116,116,116,116,116,116,116,116,116,116,\n117,118,117,118,111,119,117,118,120,120,121,122,122,122,  5,123,\n\n/* block 7 */\n120,120,120,120,119, 15,124,  5,125,125,125,120,126,120,127,127,\n128,129,130,129,129,131,129,129,132,133,134,129,135,129,129,129,\n136,137,120,138,129,129,139,129,129,140,129,129,141,142,142,142,\n128,143,144,143,143,145,143,143,146,147,148,143,149,143,143,143,\n150,151,152,153,143,143,154,143,143,155,143,143,156,157,157,158,\n159,160,161,161,161,162,163,164,117,118,117,118,117,118,117,118,\n117,118,165,166,165,166,165,166,165,166,165,166,165,166,165,166,\n167,168,169,170,171,172,173,117,118,174,117,118,128,175,175,175,\n\n/* block 8 */\n176,176,176,176,176,176,176,176,176,176,176,176,176,176,176,176,\n177,177,178,177,179,177,177,177,177,177,177,177,177,177,180,177,\n177,181,182,177,177,177,177,177,177,177,183,177,177,177,177,177,\n184,184,185,184,186,184,184,184,184,184,184,184,184,184,187,184,\n184,188,189,184,184,184,184,184,184,184,190,184,184,184,184,184,\n191,191,191,191,191,191,191,191,191,191,191,191,191,191,191,191,\n192,193,194,195,192,193,192,193,192,193,192,193,192,193,192,193,\n192,193,192,193,192,193,192,193,192,193,192,193,192,193,192,193,\n\n/* block 9 */\n192,193,196,197,198,199,199,198,200,200,192,193,192,193,192,193,\n192,193,192,193,192,193,192,193,192,193,192,193,192,193,192,193,\n192,193,192,193,192,193,192,193,192,193,192,193,192,193,192,193,\n192,193,192,193,192,193,192,193,192,193,192,193,192,193,192,193,\n201,192,193,192,193,192,193,192,193,192,193,192,193,192,193,202,\n192,193,192,193,192,193,192,193,192,193,192,193,192,193,192,193,\n192,193,192,193,192,193,192,193,192,193,192,193,192,193,192,193,\n192,193,192,193,192,193,192,193,192,193,192,193,192,193,192,193,\n\n/* block 10 */\n192,193,192,193,192,193,192,193,192,193,192,193,192,193,192,193,\n192,193,192,193,192,193,192,193,192,193,192,193,192,193,192,193,\n192,193,192,193,192,193,192,193,192,193,192,193,192,193,192,193,\n120,203,203,203,203,203,203,203,203,203,203,203,203,203,203,203,\n203,203,203,203,203,203,203,203,203,203,203,203,203,203,203,203,\n203,203,203,203,203,203,203,120,120,204,205,205,205,205,205,205,\n206,207,207,207,207,207,207,207,207,207,207,207,207,207,207,207,\n207,207,207,207,207,207,207,207,207,207,207,207,207,207,207,207,\n\n/* block 11 */\n207,207,207,207,207,207,207,206,206,205,208,120,120,209,209,210,\n120,211,211,211,211,211,211,211,211,211,211,211,211,211,211,211,\n211,211,211,211,211,211,211,211,211,211,211,211,211,211,211,211,\n211,211,211,211,211,211,211,211,211,211,211,211,211,211,212,211,\n213,211,211,213,211,211,213,211,120,120,120,120,120,120,120,120,\n214,214,214,214,214,214,214,214,214,214,214,214,214,214,214,214,\n214,214,214,214,214,214,214,214,214,214,214,120,120,120,120,214,\n214,214,214,213,213,120,120,120,120,120,120,120,120,120,120,120,\n\n/* block 12 */\n215,215,215,215,215,216,217,217,217,218,218,219,220,218,221,221,\n222,222,222,222,222,222,222,222,222,222,222,220,223,120,218,220,\n224,224,224,224,224,224,224,224,224,224,224,224,224,224,224,224,\n224,224,224,224,224,224,224,224,224,224,224,224,224,224,224,224,\n225,224,224,224,224,224,224,224,224,224,224,226,226,226,226,226,\n226,226,226,226,226,226,222,222,222,222,222,222,222,222,222,222,\n227,227,227,227,227,227,227,227,227,227,218,218,218,218,224,224,\n226,224,224,224,224,224,224,224,224,224,224,224,224,224,224,224,\n\n/* block 13 */\n224,224,224,224,224,224,224,224,224,224,224,224,224,224,224,224,\n224,224,224,224,224,224,224,224,224,224,224,224,224,224,224,224,\n224,224,224,224,224,224,224,224,224,224,224,224,224,224,224,224,\n224,224,224,224,224,224,224,224,224,224,224,224,224,224,224,224,\n224,224,224,224,224,224,224,224,224,224,224,224,224,224,224,224,\n224,224,224,224,228,224,222,222,222,222,222,222,222,216,221,222,\n222,222,222,222,222,229,229,222,222,221,222,222,222,222,224,224,\n230,230,230,230,230,230,230,230,230,230,224,224,224,221,221,224,\n\n/* block 14 */\n231,231,231,231,231,231,231,231,231,231,231,231,231,231,120,232,\n233,234,233,233,233,233,233,233,233,233,233,233,233,233,233,233,\n233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,\n234,234,234,234,234,234,234,234,234,234,234,234,234,234,234,234,\n234,234,234,234,234,234,234,234,234,234,234,120,120,233,233,233,\n224,224,224,224,224,224,224,224,224,224,224,224,224,224,224,224,\n224,224,224,224,224,224,224,224,224,224,224,224,224,224,224,224,\n224,224,224,224,224,224,224,224,224,224,224,224,224,224,224,224,\n\n/* block 15 */\n235,235,235,235,235,235,235,235,235,235,235,235,235,235,235,235,\n235,235,235,235,235,235,235,235,235,235,235,235,235,235,235,235,\n235,235,235,235,235,235,236,236,236,236,236,236,236,236,236,236,\n236,235,120,120,120,120,120,120,120,120,120,120,120,120,120,120,\n237,237,237,237,237,237,237,237,237,237,238,238,238,238,238,238,\n238,238,238,238,238,238,238,238,238,238,238,238,238,238,238,238,\n238,238,238,238,238,238,238,238,238,238,238,239,239,239,239,239,\n239,239,239,239,240,240,241,242,242,242,240,120,120,239,243,243,\n\n/* block 16 */\n244,244,244,244,244,244,244,244,244,244,244,244,244,244,244,244,\n244,244,244,244,244,244,245,245,245,245,246,245,245,245,245,245,\n245,245,245,245,246,245,245,245,246,245,245,245,245,245,120,120,\n247,247,247,247,247,247,247,247,247,247,247,247,247,247,247,120,\n248,248,248,248,248,248,248,248,248,248,248,248,248,248,248,248,\n248,248,248,248,248,248,248,248,248,249,249,249,120,120,250,120,\n233,233,233,233,233,233,233,233,233,233,233,120,120,120,120,120,\n120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,\n\n/* block 17 */\n120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,\n120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,\n224,224,224,224,224,224,224,224,224,224,224,224,224,224,224,224,\n224,224,224,224,224,120,224,224,224,224,224,224,224,224,224,224,\n224,224,224,224,224,224,224,224,120,120,120,120,120,120,120,120,\n120,120,120,222,222,222,222,222,222,222,222,222,222,222,222,222,\n222,222,216,222,222,222,222,222,222,222,222,222,222,222,222,222,\n222,222,222,222,222,222,222,222,222,222,222,222,222,222,222,222,\n\n/* block 18 */\n251,251,251,252,253,253,253,253,253,253,253,253,253,253,253,253,\n253,253,253,253,253,253,253,253,253,253,253,253,253,253,253,253,\n253,253,253,253,253,253,253,253,253,253,253,253,253,253,253,253,\n253,253,253,253,253,253,253,253,253,253,251,252,251,253,252,252,\n252,251,251,251,251,251,251,251,251,252,252,252,252,251,252,252,\n253,254,255,113,113,251,251,251,253,253,253,253,253,253,253,253,\n253,253,251,251,256,257,258,258,258,258,258,258,258,258,258,258,\n259,260,253,253,253,253,253,253,253,253,253,253,253,253,253,253,\n\n/* block 19 */\n261,262,263,263,120,261,261,261,261,261,261,261,261,120,120,261,\n261,120,120,261,261,261,261,261,261,261,261,261,261,261,261,261,\n261,261,261,261,261,261,261,261,261,120,261,261,261,261,261,261,\n261,120,261,120,120,120,261,261,261,261,120,120,262,261,264,263,\n263,262,262,262,262,120,120,263,263,120,120,263,263,262,261,120,\n120,120,120,120,120,120,120,264,120,120,120,120,261,261,120,261,\n261,261,262,262,120,120,265,265,265,265,265,265,265,265,265,265,\n261,261,266,266,267,267,267,267,267,267,268,266,261,269,262,120,\n\n/* block 20 */\n120,270,270,271,120,272,272,272,272,272,272,120,120,120,120,272,\n272,120,120,272,272,272,272,272,272,272,272,272,272,272,272,272,\n272,272,272,272,272,272,272,272,272,120,272,272,272,272,272,272,\n272,120,272,272,120,272,272,120,272,272,120,120,270,120,271,271,\n271,270,270,120,120,120,120,270,270,120,120,270,270,270,120,120,\n120,270,120,120,120,120,120,120,120,272,272,272,272,120,272,120,\n120,120,120,120,120,120,273,273,273,273,273,273,273,273,273,273,\n270,270,272,272,272,270,274,120,120,120,120,120,120,120,120,120,\n\n/* block 21 */\n120,275,275,276,120,277,277,277,277,277,277,277,277,277,120,277,\n277,277,120,277,277,277,277,277,277,277,277,277,277,277,277,277,\n277,277,277,277,277,277,277,277,277,120,277,277,277,277,277,277,\n277,120,277,277,120,277,277,277,277,277,120,120,275,277,276,276,\n276,275,275,275,275,275,120,275,275,276,120,276,276,275,120,120,\n277,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,\n277,277,275,275,120,120,278,278,278,278,278,278,278,278,278,278,\n279,280,120,120,120,120,120,120,120,277,275,275,275,275,275,275,\n\n/* block 22 */\n120,281,282,282,120,283,283,283,283,283,283,283,283,120,120,283,\n283,120,120,283,283,283,283,283,283,283,283,283,283,283,283,283,\n283,283,283,283,283,283,283,283,283,120,283,283,283,283,283,283,\n283,120,283,283,120,283,283,283,283,283,120,120,281,283,284,281,\n282,281,281,281,281,120,120,282,282,120,120,282,282,281,120,120,\n120,120,120,120,120,281,281,284,120,120,120,120,283,283,120,283,\n283,283,281,281,120,120,285,285,285,285,285,285,285,285,285,285,\n286,283,287,287,287,287,287,287,120,120,120,120,120,120,120,120,\n\n/* block 23 */\n120,120,288,289,120,289,289,289,289,289,289,120,120,120,289,289,\n289,120,289,289,289,289,120,120,120,289,289,120,289,120,289,289,\n120,120,120,289,289,120,120,120,289,289,289,120,120,120,289,289,\n289,289,289,289,289,289,289,289,289,289,120,120,120,120,290,291,\n288,291,291,120,120,120,291,291,291,120,291,291,291,288,120,120,\n289,120,120,120,120,120,120,290,120,120,120,120,120,120,120,120,\n120,120,120,120,120,120,292,292,292,292,292,292,292,292,292,292,\n293,293,293,294,295,295,295,295,295,296,295,120,120,120,120,120,\n\n/* block 24 */\n297,298,298,298,297,299,299,299,299,299,299,299,299,120,299,299,\n299,120,299,299,299,299,299,299,299,299,299,299,299,299,299,299,\n299,299,299,299,299,299,299,299,299,120,299,299,299,299,299,299,\n299,299,299,299,299,299,299,299,299,299,120,120,120,299,297,297,\n297,298,298,298,298,120,297,297,297,120,297,297,297,297,120,120,\n120,120,120,120,120,297,297,120,299,299,299,120,120,120,120,120,\n299,299,297,297,120,120,300,300,300,300,300,300,300,300,300,300,\n120,120,120,120,120,120,120,301,302,302,302,302,302,302,302,303,\n\n/* block 25 */\n304,305,306,306,307,304,304,304,304,304,304,304,304,120,304,304,\n304,120,304,304,304,304,304,304,304,304,304,304,304,304,304,304,\n304,304,304,304,304,304,304,304,304,120,304,304,304,304,304,304,\n304,304,304,304,120,304,304,304,304,304,120,120,305,304,306,305,\n306,306,308,306,306,120,305,306,306,120,306,306,305,305,120,120,\n120,120,120,120,120,308,308,120,120,120,120,120,120,120,304,120,\n304,304,305,305,120,120,309,309,309,309,309,309,309,309,309,309,\n120,304,304,120,120,120,120,120,120,120,120,120,120,120,120,120,\n\n/* block 26 */\n310,310,311,311,312,312,312,312,312,312,312,312,312,120,312,312,\n312,120,312,312,312,312,312,312,312,312,312,312,312,312,312,312,\n312,312,312,312,312,312,312,312,312,312,312,312,312,312,312,312,\n312,312,312,312,312,312,312,312,312,312,312,310,310,312,313,311,\n311,310,310,310,310,120,311,311,311,120,311,311,311,310,314,315,\n120,120,120,120,312,312,312,313,316,316,316,316,316,316,316,312,\n312,312,310,310,120,120,317,317,317,317,317,317,317,317,317,317,\n316,316,316,316,316,316,316,316,316,315,312,312,312,312,312,312,\n\n/* block 27 */\n120,318,319,319,120,320,320,320,320,320,320,320,320,320,320,320,\n320,320,320,320,320,320,320,120,120,120,320,320,320,320,320,320,\n320,320,320,320,320,320,320,320,320,320,320,320,320,320,320,320,\n320,320,120,320,320,320,320,320,320,320,320,320,120,320,120,120,\n320,320,320,320,320,320,320,120,120,120,318,120,120,120,120,321,\n319,319,318,318,318,120,318,120,319,319,319,319,319,319,319,321,\n120,120,120,120,120,120,322,322,322,322,322,322,322,322,322,322,\n120,120,319,319,323,120,120,120,120,120,120,120,120,120,120,120,\n\n/* block 28 */\n120,324,324,324,324,324,324,324,324,324,324,324,324,324,324,324,\n324,324,324,324,324,324,324,324,324,324,324,324,324,324,324,324,\n324,324,324,324,324,324,324,324,324,324,324,324,324,324,324,324,\n324,325,324,326,325,325,325,325,325,325,325,120,120,120,120,  6,\n324,324,324,324,324,324,327,325,325,325,325,325,325,325,325,328,\n329,329,329,329,329,329,329,329,329,329,328,328,120,120,120,120,\n120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,\n120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,\n\n/* block 29 */\n120,330,330,120,330,120,330,330,330,330,330,120,330,330,330,330,\n330,330,330,330,330,330,330,330,330,330,330,330,330,330,330,330,\n330,330,330,330,120,330,120,330,330,330,330,330,330,330,330,330,\n330,331,330,332,331,331,331,331,331,331,331,331,331,330,120,120,\n330,330,330,330,330,120,333,120,331,331,331,331,331,331,120,120,\n334,334,334,334,334,334,334,334,334,334,120,120,330,330,330,330,\n120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,\n120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,\n\n/* block 30 */\n335,336,336,336,337,337,337,337,337,337,337,337,337,337,337,337,\n337,337,337,336,337,336,336,336,338,338,336,336,336,336,336,336,\n339,339,339,339,339,339,339,339,339,339,340,340,340,340,340,340,\n340,340,340,340,336,338,336,338,336,338,341,342,341,342,343,343,\n335,335,335,335,335,335,335,335,120,335,335,335,335,335,335,335,\n335,335,335,335,335,335,335,335,335,335,335,335,335,335,335,335,\n335,335,335,335,335,335,335,335,335,335,335,335,335,120,120,120,\n120,338,338,338,338,338,338,338,338,338,338,338,338,338,338,343,\n\n/* block 31 */\n338,338,338,338,338,337,338,338,335,335,335,335,335,338,338,338,\n338,338,338,338,338,338,338,338,120,338,338,338,338,338,338,338,\n338,338,338,338,338,338,338,338,338,338,338,338,338,338,338,338,\n338,338,338,338,338,338,338,338,338,338,338,338,338,120,336,336,\n336,336,336,336,336,336,338,336,336,336,336,336,336,120,336,336,\n337,337,337,337,337, 20, 20, 20, 20,337,337,120,120,120,120,120,\n120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,\n120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,\n\n/* block 32 */\n344,344,344,344,344,344,344,344,344,344,344,344,344,344,344,344,\n344,344,344,344,344,344,344,344,344,344,344,344,344,344,344,344,\n344,344,344,344,344,344,344,344,344,344,344,345,345,346,346,346,\n346,347,346,346,346,346,346,346,345,346,346,347,347,346,346,344,\n348,348,348,348,348,348,348,348,348,348,349,349,349,349,349,349,\n344,344,344,344,344,344,347,347,346,346,344,344,344,344,346,346,\n346,344,345,345,345,344,344,345,345,345,345,345,345,345,344,344,\n344,346,346,346,346,344,344,344,344,344,344,344,344,344,344,344,\n\n/* block 33 */\n344,344,346,345,347,346,346,345,345,345,345,345,345,346,344,345,\n350,350,350,350,350,350,350,350,350,350,345,345,345,346,351,351,\n352,352,352,352,352,352,352,352,352,352,352,352,352,352,352,352,\n352,352,352,352,352,352,352,352,352,352,352,352,352,352,352,352,\n352,352,352,352,352,352,120,352,120,120,120,120,120,352,120,120,\n353,353,353,353,353,353,353,353,353,353,353,353,353,353,353,353,\n353,353,353,353,353,353,353,353,353,353,353,353,353,353,353,353,\n353,353,353,353,353,353,353,353,353,353,353,354,355,353,353,353,\n\n/* block 34 */\n356,356,356,356,356,356,356,356,356,356,356,356,356,356,356,356,\n356,356,356,356,356,356,356,356,356,356,356,356,356,356,356,356,\n356,356,356,356,356,356,356,356,356,356,356,356,356,356,356,356,\n356,356,356,356,356,356,356,356,356,356,356,356,356,356,356,356,\n356,356,356,356,356,356,356,356,356,356,356,356,356,356,356,356,\n356,356,356,356,356,356,356,356,356,356,356,356,356,356,356,356,\n357,357,357,357,357,357,357,357,357,357,357,357,357,357,357,357,\n357,357,357,357,357,357,357,357,357,357,357,357,357,357,357,357,\n\n/* block 35 */\n357,357,357,357,357,357,357,357,357,357,357,357,357,357,357,357,\n357,357,357,357,357,357,357,357,357,357,357,357,357,357,357,357,\n357,357,357,357,357,357,357,357,358,358,358,358,358,358,358,358,\n358,358,358,358,358,358,358,358,358,358,358,358,358,358,358,358,\n358,358,358,358,358,358,358,358,358,358,358,358,358,358,358,358,\n358,358,358,358,358,358,358,358,358,358,358,358,358,358,358,358,\n358,358,358,358,358,358,358,358,358,358,358,358,358,358,358,358,\n358,358,358,358,358,358,358,358,358,358,358,358,358,358,358,358,\n\n/* block 36 */\n359,359,359,359,359,359,359,359,359,359,359,359,359,359,359,359,\n359,359,359,359,359,359,359,359,359,359,359,359,359,359,359,359,\n359,359,359,359,359,359,359,359,359,359,359,359,359,359,359,359,\n359,359,359,359,359,359,359,359,359,359,359,359,359,359,359,359,\n359,359,359,359,359,359,359,359,359,120,359,359,359,359,120,120,\n359,359,359,359,359,359,359,120,359,120,359,359,359,359,120,120,\n359,359,359,359,359,359,359,359,359,359,359,359,359,359,359,359,\n359,359,359,359,359,359,359,359,359,359,359,359,359,359,359,359,\n\n/* block 37 */\n359,359,359,359,359,359,359,359,359,120,359,359,359,359,120,120,\n359,359,359,359,359,359,359,359,359,359,359,359,359,359,359,359,\n359,359,359,359,359,359,359,359,359,359,359,359,359,359,359,359,\n359,120,359,359,359,359,120,120,359,359,359,359,359,359,359,120,\n359,120,359,359,359,359,120,120,359,359,359,359,359,359,359,359,\n359,359,359,359,359,359,359,120,359,359,359,359,359,359,359,359,\n359,359,359,359,359,359,359,359,359,359,359,359,359,359,359,359,\n359,359,359,359,359,359,359,359,359,359,359,359,359,359,359,359,\n\n/* block 38 */\n359,359,359,359,359,359,359,359,359,359,359,359,359,359,359,359,\n359,120,359,359,359,359,120,120,359,359,359,359,359,359,359,359,\n359,359,359,359,359,359,359,359,359,359,359,359,359,359,359,359,\n359,359,359,359,359,359,359,359,359,359,359,359,359,359,359,359,\n359,359,359,359,359,359,359,359,359,359,359,359,359,359,359,359,\n359,359,359,359,359,359,359,359,359,359,359,120,120,360,360,360,\n361,361,361,361,361,361,361,361,361,362,362,362,362,362,362,362,\n362,362,362,362,362,362,362,362,362,362,362,362,362,120,120,120,\n\n/* block 39 */\n359,359,359,359,359,359,359,359,359,359,359,359,359,359,359,359,\n363,363,363,363,363,363,363,363,363,363,120,120,120,120,120,120,\n364,364,364,364,364,364,364,364,364,364,364,364,364,364,364,364,\n364,364,364,364,364,364,364,364,364,364,364,364,364,364,364,364,\n364,364,364,364,364,364,364,364,364,364,364,364,364,364,364,364,\n364,364,364,364,364,364,364,364,364,364,364,364,364,364,364,364,\n364,364,364,364,364,364,364,364,364,364,364,364,364,364,364,364,\n365,365,365,365,365,365,120,120,366,366,366,366,366,366,120,120,\n\n/* block 40 */\n367,368,368,368,368,368,368,368,368,368,368,368,368,368,368,368,\n368,368,368,368,368,368,368,368,368,368,368,368,368,368,368,368,\n368,368,368,368,368,368,368,368,368,368,368,368,368,368,368,368,\n368,368,368,368,368,368,368,368,368,368,368,368,368,368,368,368,\n368,368,368,368,368,368,368,368,368,368,368,368,368,368,368,368,\n368,368,368,368,368,368,368,368,368,368,368,368,368,368,368,368,\n368,368,368,368,368,368,368,368,368,368,368,368,368,368,368,368,\n368,368,368,368,368,368,368,368,368,368,368,368,368,368,368,368,\n\n/* block 41 */\n368,368,368,368,368,368,368,368,368,368,368,368,368,368,368,368,\n368,368,368,368,368,368,368,368,368,368,368,368,368,368,368,368,\n368,368,368,368,368,368,368,368,368,368,368,368,368,368,368,368,\n368,368,368,368,368,368,368,368,368,368,368,368,368,368,368,368,\n368,368,368,368,368,368,368,368,368,368,368,368,368,368,368,368,\n368,368,368,368,368,368,368,368,368,368,368,368,368,368,368,368,\n368,368,368,368,368,368,368,368,368,368,368,368,368,368,368,368,\n368,368,368,368,368,368,368,368,368,368,368,368,368,368,368,368,\n\n/* block 42 */\n368,368,368,368,368,368,368,368,368,368,368,368,368,368,368,368,\n368,368,368,368,368,368,368,368,368,368,368,368,368,368,368,368,\n368,368,368,368,368,368,368,368,368,368,368,368,368,368,368,368,\n368,368,368,368,368,368,368,368,368,368,368,368,368,368,368,368,\n368,368,368,368,368,368,368,368,368,368,368,368,368,368,368,368,\n368,368,368,368,368,368,368,368,368,368,368,368,368,368,368,368,\n368,368,368,368,368,368,368,368,368,368,368,368,368,369,370,368,\n368,368,368,368,368,368,368,368,368,368,368,368,368,368,368,368,\n\n/* block 43 */\n371,372,372,372,372,372,372,372,372,372,372,372,372,372,372,372,\n372,372,372,372,372,372,372,372,372,372,372,373,374,120,120,120,\n375,375,375,375,375,375,375,375,375,375,375,375,375,375,375,375,\n375,375,375,375,375,375,375,375,375,375,375,375,375,375,375,375,\n375,375,375,375,375,375,375,375,375,375,375,375,375,375,375,375,\n375,375,375,375,375,375,375,375,375,375,375,375,375,375,375,375,\n375,375,375,375,375,375,375,375,375,375,375,  5,  5,  5,376,376,\n376,375,375,375,375,375,375,375,375,120,120,120,120,120,120,120,\n\n/* block 44 */\n377,377,377,377,377,377,377,377,377,377,377,377,377,120,377,377,\n377,377,378,378,378,120,120,120,120,120,120,120,120,120,120,120,\n379,379,379,379,379,379,379,379,379,379,379,379,379,379,379,379,\n379,379,380,380,380,381,381,120,120,120,120,120,120,120,120,120,\n382,382,382,382,382,382,382,382,382,382,382,382,382,382,382,382,\n382,382,383,383,120,120,120,120,120,120,120,120,120,120,120,120,\n384,384,384,384,384,384,384,384,384,384,384,384,384,120,384,384,\n384,120,385,385,120,120,120,120,120,120,120,120,120,120,120,120,\n\n/* block 45 */\n386,386,386,386,386,386,386,386,386,386,386,386,386,386,386,386,\n386,386,386,386,386,386,386,386,386,386,386,386,386,386,386,386,\n386,386,386,386,386,386,386,386,386,386,386,386,386,386,386,386,\n386,386,386,386,387,387,388,387,387,387,387,387,387,387,388,388,\n388,388,388,388,388,388,387,388,388,387,387,387,387,387,387,387,\n387,387,387,387,389,389,389,390,389,389,389,391,386,387,120,120,\n392,392,392,392,392,392,392,392,392,392,120,120,120,120,120,120,\n393,393,393,393,393,393,393,393,393,393,120,120,120,120,120,120,\n\n/* block 46 */\n394,394,395,395,394,395,396,394,394,394,394,397,397,397,398,120,\n399,399,399,399,399,399,399,399,399,399,120,120,120,120,120,120,\n400,400,400,400,400,400,400,400,400,400,400,400,400,400,400,400,\n400,400,400,400,400,400,400,400,400,400,400,400,400,400,400,400,\n400,400,400,401,400,400,400,400,400,400,400,400,400,400,400,400,\n400,400,400,400,400,400,400,400,400,400,400,400,400,400,400,400,\n400,400,400,400,400,400,400,400,400,400,400,400,400,400,400,400,\n400,400,400,400,400,400,400,400,400,120,120,120,120,120,120,120,\n\n/* block 47 */\n400,400,400,400,400,397,397,400,400,400,400,400,400,400,400,400,\n400,400,400,400,400,400,400,400,400,400,400,400,400,400,400,400,\n400,400,400,400,400,400,400,400,400,397,400,120,120,120,120,120,\n368,368,368,368,368,368,368,368,368,368,368,368,368,368,368,368,\n368,368,368,368,368,368,368,368,368,368,368,368,368,368,368,368,\n368,368,368,368,368,368,368,368,368,368,368,368,368,368,368,368,\n368,368,368,368,368,368,368,368,368,368,368,368,368,368,368,368,\n368,368,368,368,368,368,120,120,120,120,120,120,120,120,120,120,\n\n/* block 48 */\n402,402,402,402,402,402,402,402,402,402,402,402,402,402,402,402,\n402,402,402,402,402,402,402,402,402,402,402,402,402,402,402,120,\n403,403,403,404,404,404,404,403,403,404,404,404,120,120,120,120,\n404,404,403,404,404,404,404,404,404,403,403,403,120,120,120,120,\n405,120,120,120,406,406,407,407,407,407,407,407,407,407,407,407,\n408,408,408,408,408,408,408,408,408,408,408,408,408,408,408,408,\n408,408,408,408,408,408,408,408,408,408,408,408,408,408,120,120,\n408,408,408,408,408,120,120,120,120,120,120,120,120,120,120,120,\n\n/* block 49 */\n409,409,409,409,409,409,409,409,409,409,409,409,409,409,409,409,\n409,409,409,409,409,409,409,409,409,409,409,409,409,409,409,409,\n409,409,409,409,409,409,409,409,409,409,409,409,120,120,120,120,\n409,409,409,409,409,409,409,409,409,409,409,409,409,409,409,409,\n409,409,409,409,409,409,409,409,409,409,120,120,120,120,120,120,\n410,410,410,410,410,410,410,410,410,410,411,120,120,120,412,412,\n413,413,413,413,413,413,413,413,413,413,413,413,413,413,413,413,\n413,413,413,413,413,413,413,413,413,413,413,413,413,413,413,413,\n\n/* block 50 */\n414,414,414,414,414,414,414,414,414,414,414,414,414,414,414,414,\n414,414,414,414,414,414,414,415,415,416,416,415,120,120,417,417,\n418,418,418,418,418,418,418,418,418,418,418,418,418,418,418,418,\n418,418,418,418,418,418,418,418,418,418,418,418,418,418,418,418,\n418,418,418,418,418,418,418,418,418,418,418,418,418,418,418,418,\n418,418,418,418,418,419,420,419,420,420,420,420,420,420,420,120,\n420,421,420,421,421,420,420,420,420,420,420,420,420,419,419,419,\n419,419,419,420,420,420,420,420,420,420,420,420,420,120,120,420,\n\n/* block 51 */\n422,422,422,422,422,422,422,422,422,422,120,120,120,120,120,120,\n422,422,422,422,422,422,422,422,422,422,120,120,120,120,120,120,\n423,423,423,423,423,423,423,424,423,423,423,423,423,423,120,120,\n113,113,113,113,113,113,113,113,113,113,113,113,113,113,425,113,\n113,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,\n120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,\n120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,\n120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,\n\n/* block 52 */\n426,426,426,426,427,428,428,428,428,428,428,428,428,428,428,428,\n428,428,428,428,428,428,428,428,428,428,428,428,428,428,428,428,\n428,428,428,428,428,428,428,428,428,428,428,428,428,428,428,428,\n428,428,428,428,426,429,426,426,426,426,426,427,426,427,427,427,\n427,427,426,427,427,428,428,428,428,428,428,428,120,120,120,120,\n430,430,430,430,430,430,430,430,430,430,431,431,431,431,431,431,\n431,432,432,432,432,432,432,432,432,432,432,426,426,426,426,426,\n426,426,426,426,432,432,432,432,432,432,432,432,432,120,120,120,\n\n/* block 53 */\n433,433,434,435,435,435,435,435,435,435,435,435,435,435,435,435,\n435,435,435,435,435,435,435,435,435,435,435,435,435,435,435,435,\n435,434,433,433,433,433,434,434,433,433,434,433,433,433,435,435,\n436,436,436,436,436,436,436,436,436,436,435,435,435,435,435,435,\n437,437,437,437,437,437,437,437,437,437,437,437,437,437,437,437,\n437,437,437,437,437,437,437,437,437,437,437,437,437,437,437,437,\n437,437,437,437,437,437,438,439,438,438,439,439,439,438,439,438,\n438,438,439,439,120,120,120,120,120,120,120,120,440,440,440,440,\n\n/* block 54 */\n441,441,441,441,441,441,441,441,441,441,441,441,441,441,441,441,\n441,441,441,441,441,441,441,441,441,441,441,441,441,441,441,441,\n441,441,441,441,442,442,442,442,442,442,442,442,443,443,443,443,\n443,443,443,443,442,442,443,443,120,120,120,444,444,444,444,444,\n445,445,445,445,445,445,445,445,445,445,120,120,120,441,441,441,\n446,446,446,446,446,446,446,446,446,446,447,447,447,447,447,447,\n447,447,447,447,447,447,447,447,447,447,447,447,447,447,447,447,\n447,447,447,447,447,447,447,447,448,448,448,448,448,448,449,449,\n\n/* block 55 */\n450,451,452,453,454,455,456,457,458,120,120,120,120,120,120,120,\n459,459,459,459,459,459,459,459,459,459,459,459,459,459,459,459,\n459,459,459,459,459,459,459,459,459,459,459,459,459,459,459,459,\n459,459,459,459,459,459,459,459,459,459,459,120,120,459,459,459,\n460,460,460,460,460,460,460,460,120,120,120,120,120,120,120,120,\n461,462,461,463,462,464,464,465,464,465,466,462,465,465,462,462,\n465,467,462,462,462,462,462,462,462,468,469,470,470,464,470,470,\n470,470,471,472,473,469,469,474,475,475,476,120,120,120,120,120,\n\n/* block 56 */\n 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,\n 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,\n 35, 35, 35, 35, 35, 35,128,128,128,128,128,477,110,110,110,110,\n110,110,110,110,110,110,110,110,110,110,110,110,110,110,110,110,\n110,110,110,110,110,110,110,110,110,110,110,110,110,110,110,110,\n110,110,110,110,110,110,110,110,110,110,110,110,110,121,121,121,\n121,121,110,110,110,110,121,121,121,121,121, 35, 35, 35, 35, 35,\n 35, 35, 35, 35, 35, 35, 35, 35,478,479, 35, 35, 35,480, 35, 35,\n\n/* block 57 */\n 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,481, 35,\n 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,110,110,110,110,110,\n110,110,110,110,110,110,110,110,110,110,110,110,110,110,110,110,\n110,110,110,110,110,110,110,110,110,110,110,110,110,110,110,121,\n114,114,113,113,113,113,113,113,113,113,113,113,113,113,113,113,\n113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,\n113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,\n113,113,113,113,113,113,113,113,482,113,120,113,113,113,113,113,\n\n/* block 58 */\n 32, 33, 32, 33, 32, 33, 32, 33, 32, 33, 32, 33, 32, 33, 32, 33,\n 32, 33, 32, 33, 32, 33, 32, 33, 32, 33, 32, 33, 32, 33, 32, 33,\n 32, 33, 32, 33, 32, 33, 32, 33, 32, 33, 32, 33, 32, 33, 32, 33,\n 32, 33, 32, 33, 32, 33, 32, 33, 32, 33, 32, 33, 32, 33, 32, 33,\n 32, 33, 32, 33, 32, 33, 32, 33, 32, 33, 32, 33, 32, 33, 32, 33,\n 32, 33, 32, 33, 32, 33, 32, 33, 32, 33, 32, 33, 32, 33, 32, 33,\n483,484, 32, 33, 32, 33, 32, 33, 32, 33, 32, 33, 32, 33, 32, 33,\n 32, 33, 32, 33, 32, 33, 32, 33, 32, 33, 32, 33, 32, 33, 32, 33,\n\n/* block 59 */\n 32, 33, 32, 33, 32, 33, 32, 33, 32, 33, 32, 33, 32, 33, 32, 33,\n 32, 33, 32, 33, 32, 33, 35, 35, 35, 35, 35,485, 35, 35,486, 35,\n 32, 33, 32, 33, 32, 33, 32, 33, 32, 33, 32, 33, 32, 33, 32, 33,\n 32, 33, 32, 33, 32, 33, 32, 33, 32, 33, 32, 33, 32, 33, 32, 33,\n 32, 33, 32, 33, 32, 33, 32, 33, 32, 33, 32, 33, 32, 33, 32, 33,\n 32, 33, 32, 33, 32, 33, 32, 33, 32, 33, 32, 33, 32, 33, 32, 33,\n 32, 33, 32, 33, 32, 33, 32, 33, 32, 33, 32, 33, 32, 33, 32, 33,\n 32, 33, 32, 33, 32, 33, 32, 33, 32, 33, 32, 33, 32, 33, 32, 33,\n\n/* block 60 */\n487,487,487,487,487,487,487,487,488,488,488,488,488,488,488,488,\n487,487,487,487,487,487,120,120,488,488,488,488,488,488,120,120,\n487,487,487,487,487,487,487,487,488,488,488,488,488,488,488,488,\n487,487,487,487,487,487,487,487,488,488,488,488,488,488,488,488,\n487,487,487,487,487,487,120,120,488,488,488,488,488,488,120,120,\n128,487,128,487,128,487,128,487,120,488,120,488,120,488,120,488,\n487,487,487,487,487,487,487,487,488,488,488,488,488,488,488,488,\n489,489,490,490,490,490,491,491,492,492,493,493,494,494,120,120,\n\n/* block 61 */\n487,487,487,487,487,487,487,487,495,495,495,495,495,495,495,495,\n487,487,487,487,487,487,487,487,495,495,495,495,495,495,495,495,\n487,487,487,487,487,487,487,487,495,495,495,495,495,495,495,495,\n487,487,128,496,128,120,128,128,488,488,497,497,498,119,499,119,\n119,119,128,496,128,120,128,128,500,500,500,500,498,119,119,119,\n487,487,128,128,120,120,128,128,488,488,501,501,120,119,119,119,\n487,487,128,128,128,169,128,128,488,488,502,502,174,119,119,119,\n120,120,128,496,128,120,128,128,503,503,504,504,498,119,119,120,\n\n/* block 62 */\n  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4, 24,505,506, 24, 24,\n 10, 10, 10, 10, 10, 10,  5,  5, 23, 27,  7, 23, 23, 27,  7, 23,\n  5,  5,  5,  5,  5,  5,  5,  5,507,508, 24, 24, 24, 24, 24,509,\n  5,  5,  5,  5,  5,  5,  5,  5,  5, 23, 27,  5,510,  5,  5, 16,\n 16,  5,  5,  5,  9,  7,  8,  5,  5,510,  5,  5,  5,  5,  5,  5,\n  5,  5,  9,  5, 16,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  4,\n 24, 24, 24, 24, 24,511, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,\n 25,110,120,120, 25, 25, 25, 25, 25, 25,  9,  9,  9,  7,  8,110,\n\n/* block 63 */\n 25, 25, 25, 25, 25, 25, 25, 25, 25, 25,  9,  9,  9,  7,  8,120,\n110,110,110,110,110,110,110,110,110,110,110,110,110,120,120,120,\n  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,\n  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,\n120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,\n113,113,113,113,113,113,113,113,113,113,113,113,113,425,425,425,\n425,113,425,425,425,113,113,113,113,113,113,113,113,113,113,113,\n512,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,\n\n/* block 64 */\n 20, 20,513, 20, 20, 20, 20,513, 20, 20,514,513,513,513,514,514,\n513,513,513,514, 20,513, 20, 20,  9,513,513,513,513,513, 20, 20,\n 20, 20, 21, 20,513, 20,515, 20,513, 20,516,517,513,513, 20,514,\n513,513,518,513,514,519,519,519,519,520, 20, 20,514,514,513,513,\n  9,  9,  9,  9,  9,513,514,514,514,514, 20,  9, 20, 20,521, 20,\n 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25,\n522,522,522,522,522,522,522,522,522,522,522,522,522,522,522,522,\n523,523,523,523,523,523,523,523,523,523,523,523,523,523,523,523,\n\n/* block 65 */\n524,524,524, 32, 33,524,524,524,524, 25, 20, 20,120,120,120,120,\n  9,  9,  9,  9,525, 21, 21, 21, 21, 21,  9,  9, 20, 20, 20, 20,\n  9, 20, 20,  9, 20, 20,  9, 20, 20, 21, 21, 20, 20, 20,  9, 20,\n 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20,\n 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20,  9,  9,\n 20, 20,  9, 20,  9, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20,\n 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20,\n 20, 20, 20, 20,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,\n\n/* block 66 */\n  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,\n  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,\n  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,\n  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,\n  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,\n  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,\n  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,\n  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,\n\n/* block 67 */\n 20, 20, 20, 20, 20, 20, 20, 20,  7,  8,  7,  8, 20, 20, 20, 20,\n 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 21, 21, 20, 20, 20, 20,\n  9,  9, 20, 20, 20, 20, 20, 20, 21,  7,  8, 20, 20, 20, 20, 20,\n 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20,\n 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20,\n 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20,\n 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20,\n 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20,  9, 20, 20, 20,\n\n/* block 68 */\n 20, 20, 20, 20, 20, 20, 20, 20, 21, 20, 20, 20, 20, 20, 20, 20,\n 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20,  9,  9,  9,  9,  9,\n  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,\n  9,  9,  9,  9, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20,\n 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 21,\n 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20,  9,  9,  9,  9,\n  9,  9, 20, 20, 20, 20, 20, 20, 20, 21, 21, 21, 21, 21, 21, 21,\n 21, 21, 21, 21, 20, 20, 20, 20, 21, 21, 21, 20, 20, 20, 20, 20,\n\n/* block 69 */\n 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20,\n 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20,\n 20, 20, 20, 20, 20, 20, 20,120,120,120,120,120,120,120,120,120,\n120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,\n 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20,120,120,120,120,120,\n120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,\n 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25,\n 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25,\n\n/* block 70 */\n 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25,\n 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 20, 20, 20, 20,\n 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20,\n 20, 20, 20, 20, 20, 20,526,526,526,526,526,526,526,526,526,526,\n526,526,527,526,526,526,526,526,526,526,526,526,526,526,526,526,\n528,528,528,528,528,528,528,528,528,528,528,528,528,528,528,528,\n528,528,528,528,528,528,528,528,528,528, 25, 25, 25, 25, 25, 25,\n 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25,\n\n/* block 71 */\n 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20,\n 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20,\n 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20,\n 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20,\n 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20,\n 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20,\n 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20,\n 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20,\n\n/* block 72 */\n 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20,\n 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20,\n 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 21, 21, 20, 20, 20, 20,\n 20, 20, 20, 20, 20, 20, 21,  9, 20, 20, 20, 20, 20, 20, 20, 20,\n 21,  9, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20,\n 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20,\n 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20,\n 20, 20, 20, 20, 20, 20, 20, 20,  9,  9,  9,525,525,525,525,  9,\n\n/* block 73 */\n 21, 21, 21, 21, 21, 21, 20, 21, 21, 21, 21, 21, 21, 21, 21, 21,\n 21, 21, 21, 20, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21,\n 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21,\n 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21,\n 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21,\n 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21,\n 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21,525,\n 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21,\n\n/* block 74 */\n 21, 21, 21, 21, 21, 21, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20,\n 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21,\n 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21,\n 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21,\n 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21,\n 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21,\n 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21,\n 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21,\n\n/* block 75 */\n 21, 21, 21, 21, 21, 21, 20, 20, 21, 21, 21, 21, 21, 21, 21, 21,\n 21, 21, 21, 20, 21, 20, 21, 20, 20, 20, 20, 20, 20, 21, 20, 20,\n 20, 21, 20, 20, 20, 20, 20, 20, 21, 20, 20, 20, 20, 20, 20, 20,\n 20, 20, 20, 21, 21, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20,\n 20, 20, 20, 20, 21, 20, 20, 21, 20, 20, 20, 20, 21, 20, 21, 20,\n 20, 20, 20, 21, 21, 21, 20, 21, 20, 20, 20, 20, 20, 20, 20, 20,\n 20, 20, 20, 21, 21, 21, 21, 21,  7,  8,  7,  8,  7,  8,  7,  8,\n  7,  8,  7,  8,  7,  8, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25,\n\n/* block 76 */\n 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25,\n 25, 25, 25, 25, 20, 21, 21, 21, 20, 20, 20, 20, 20, 20, 20, 20,\n 20, 21, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20,\n 21, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 21,\n  9,  9,  9,  9,  9,  7,  8,  9,  9,  9,  9,  9,  9,  9,  9,  9,\n  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,\n  9,  9,  9,  9,  9,  9,  7,  8,  7,  8,  7,  8,  7,  8,  7,  8,\n  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,\n\n/* block 77 */\n529,529,529,529,529,529,529,529,529,529,529,529,529,529,529,529,\n529,529,529,529,529,529,529,529,529,529,529,529,529,529,529,529,\n529,529,529,529,529,529,529,529,529,529,529,529,529,529,529,529,\n529,529,529,529,529,529,529,529,529,529,529,529,529,529,529,529,\n529,529,529,529,529,529,529,529,529,529,529,529,529,529,529,529,\n529,529,529,529,529,529,529,529,529,529,529,529,529,529,529,529,\n529,529,529,529,529,529,529,529,529,529,529,529,529,529,529,529,\n529,529,529,529,529,529,529,529,529,529,529,529,529,529,529,529,\n\n/* block 78 */\n  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,\n  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,\n  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,\n  9,  9,  9,  9,525,525,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,\n  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,\n  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,\n  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,\n  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,\n\n/* block 79 */\n  9,  9,  9,  7,  8,  7,  8,  7,  8,  7,  8,  7,  8,  7,  8,  7,\n  8,  7,  8,  7,  8,  7,  8,  7,  8,  9,  9,  9,  9,  9,  9,  9,\n  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,\n  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,\n  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,\n  9,  9,  9,  9,  9,  9,  9,  9,  7,  8,  7,  8,  9,  9,  9,  9,\n  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,\n  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  7,  8,  9,  9,\n\n/* block 80 */\n 20, 20, 20, 20, 20, 21, 21, 21, 20, 20, 20, 20, 20, 20, 20, 20,\n 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 21, 21, 20, 20, 20,\n 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20,\n  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,\n  9,  9,  9,  9,  9, 20, 20,  9,  9,  9,  9,  9,  9, 20, 20, 20,\n 21, 20, 20, 20, 20, 21, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20,\n 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20,\n 20, 20, 20, 20,120,120, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20,\n\n/* block 81 */\n 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20,\n 20, 20, 20, 20, 20, 20,120, 20, 20, 20, 20, 20, 20, 20, 20, 20,\n 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20,\n 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20,\n 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20,\n 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20,\n 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20,\n 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20,\n\n/* block 82 */\n530,530,530,530,530,530,530,530,530,530,530,530,530,530,530,530,\n530,530,530,530,530,530,530,530,530,530,530,530,530,530,530,530,\n530,530,530,530,530,530,530,530,530,530,530,530,530,530,530,120,\n531,531,531,531,531,531,531,531,531,531,531,531,531,531,531,531,\n531,531,531,531,531,531,531,531,531,531,531,531,531,531,531,531,\n531,531,531,531,531,531,531,531,531,531,531,531,531,531,531,120,\n 32, 33,532,533,534,535,536, 32, 33, 32, 33, 32, 33,537,538,539,\n540, 35, 32, 33, 35, 32, 33, 35, 35, 35, 35, 35,110,110,541,541,\n\n/* block 83 */\n165,166,165,166,165,166,165,166,165,166,165,166,165,166,165,166,\n165,166,165,166,165,166,165,166,165,166,165,166,165,166,165,166,\n165,166,165,166,165,166,165,166,165,166,165,166,165,166,165,166,\n165,166,165,166,165,166,165,166,165,166,165,166,165,166,165,166,\n165,166,165,166,165,166,165,166,165,166,165,166,165,166,165,166,\n165,166,165,166,165,166,165,166,165,166,165,166,165,166,165,166,\n165,166,165,166,542,543,543,543,543,543,543,165,166,165,166,544,\n544,544,165,166,120,120,120,120,120,545,545,545,545,546,545,545,\n\n/* block 84 */\n547,547,547,547,547,547,547,547,547,547,547,547,547,547,547,547,\n547,547,547,547,547,547,547,547,547,547,547,547,547,547,547,547,\n547,547,547,547,547,547,120,547,120,120,120,120,120,547,120,120,\n548,548,548,548,548,548,548,548,548,548,548,548,548,548,548,548,\n548,548,548,548,548,548,548,548,548,548,548,548,548,548,548,548,\n548,548,548,548,548,548,548,548,548,548,548,548,548,548,548,548,\n548,548,548,548,548,548,548,548,120,120,120,120,120,120,120,549,\n550,120,120,120,120,120,120,120,120,120,120,120,120,120,120,551,\n\n/* block 85 */\n359,359,359,359,359,359,359,359,359,359,359,359,359,359,359,359,\n359,359,359,359,359,359,359,120,120,120,120,120,120,120,120,120,\n359,359,359,359,359,359,359,120,359,359,359,359,359,359,359,120,\n359,359,359,359,359,359,359,120,359,359,359,359,359,359,359,120,\n359,359,359,359,359,359,359,120,359,359,359,359,359,359,359,120,\n359,359,359,359,359,359,359,120,359,359,359,359,359,359,359,120,\n552,552,552,552,552,552,552,552,552,552,552,552,552,552,552,552,\n552,552,552,552,552,552,552,552,552,552,552,552,552,552,552,552,\n\n/* block 86 */\n  5,  5, 23, 27, 23, 27,  5,  5,  5, 23, 27,  5, 23, 27,  5,  5,\n  5,  5,  5,  5,  5,  5,  5, 10,  5,  5, 10,  5, 23, 27,  5,  5,\n 23, 27,  7,  8,  7,  8,  7,  8,  7,  8,  5,  5,  5,  5,  5,111,\n  5,  5,  5,  5,  5,  5,  5,  5,  5,  5, 10, 10,  5,  5,  5,  5,\n 10,  5,  7,553,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,\n 20, 20,  5,120,120,120,120,120,120,120,120,120,120,120,120,120,\n120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,\n120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,\n\n/* block 87 */\n554,554,554,554,554,554,554,554,554,554,554,554,554,554,554,554,\n554,554,554,554,554,554,554,554,554,554,120,554,554,554,554,554,\n554,554,554,554,554,554,554,554,554,554,554,554,554,554,554,554,\n554,554,554,554,554,554,554,554,554,554,554,554,554,554,554,554,\n554,554,554,554,554,554,554,554,554,554,554,554,554,554,554,554,\n554,554,554,554,554,554,554,554,554,554,554,554,554,554,554,554,\n554,554,554,554,554,554,554,554,554,554,554,554,554,554,554,554,\n554,554,554,554,120,120,120,120,120,120,120,120,120,120,120,120,\n\n/* block 88 */\n554,554,554,554,554,554,554,554,554,554,554,554,554,554,554,554,\n554,554,554,554,554,554,554,554,554,554,554,554,554,554,554,554,\n554,554,554,554,554,554,554,554,554,554,554,554,554,554,554,554,\n554,554,554,554,554,554,554,554,554,554,554,554,554,554,554,554,\n554,554,554,554,554,554,554,554,554,554,554,554,554,554,554,554,\n554,554,554,554,554,554,554,554,554,554,554,554,554,554,554,554,\n554,554,554,554,554,554,554,554,554,554,554,554,554,554,554,554,\n554,554,554,554,554,554,554,554,554,554,554,554,554,554,554,554,\n\n/* block 89 */\n554,554,554,554,554,554,554,554,554,554,554,554,554,554,554,554,\n554,554,554,554,554,554,554,554,554,554,554,554,554,554,554,554,\n554,554,554,554,554,554,554,554,554,554,554,554,554,554,554,554,\n554,554,554,554,554,554,554,554,554,554,554,554,554,554,554,554,\n554,554,554,554,554,554,554,554,554,554,554,554,554,554,554,554,\n554,554,554,554,554,554,120,120,120,120,120,120,120,120,120,120,\n120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,\n 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20,120,120,120,120,\n\n/* block 90 */\n  4,555,555,556, 20,557,558,559,560,561,560,561,560,561,560,561,\n560,561, 20,562,560,561,560,561,560,561,560,561,563,564,565,565,\n 20,559,559,559,559,559,559,559,559,559,566,566,566,566,567,567,\n568,569,569,569,569,569, 20,562,559,559,559,557,570,571,572,572,\n120,573,573,573,573,573,573,573,573,573,573,573,573,573,573,573,\n573,573,573,573,573,573,573,573,573,573,573,573,573,573,573,573,\n573,573,573,573,573,573,573,573,573,573,573,573,573,573,573,573,\n573,573,573,573,573,573,573,573,573,573,573,573,573,573,573,573,\n\n/* block 91 */\n573,573,573,573,573,573,573,573,573,573,573,573,573,573,573,573,\n573,573,573,573,573,573,573,120,120,574,574,575,575,576,576,573,\n577,578,578,578,578,578,578,578,578,578,578,578,578,578,578,578,\n578,578,578,578,578,578,578,578,578,578,578,578,578,578,578,578,\n578,578,578,578,578,578,578,578,578,578,578,578,578,578,578,578,\n578,578,578,578,578,578,578,578,578,578,578,578,578,578,578,578,\n578,578,578,578,578,578,578,578,578,578,578,578,578,578,578,578,\n578,578,578,578,578,578,578,578,578,578,578,555,569,579,579,578,\n\n/* block 92 */\n120,120,120,120,120,580,580,580,580,580,580,580,580,580,580,580,\n580,580,580,580,580,580,580,580,580,580,580,580,580,580,580,580,\n580,580,580,580,580,580,580,580,580,580,580,580,580,580,580,580,\n120,581,581,581,581,581,581,581,581,581,581,581,581,581,581,581,\n581,581,581,581,581,581,581,581,581,581,581,581,581,581,581,581,\n581,581,581,581,581,581,581,581,581,581,581,581,581,581,581,581,\n581,581,581,581,581,581,581,581,581,581,581,581,581,581,581,581,\n581,581,581,581,581,581,581,581,581,581,581,581,581,581,581,581,\n\n/* block 93 */\n581,581,581,581,581,581,581,581,581,581,581,581,581,581,581,120,\n572,572,582,582,582,582,572,572,572,572,572,572,572,572,572,572,\n580,580,580,580,580,580,580,580,580,580,580,580,580,580,580,580,\n580,580,580,580,580,580,580,580,580,580,580,580,580,580,580,580,\n572,572,572,572,572,572,572,572,572,572,572,572,572,572,572,572,\n572,572,572,572,572,572,572,572,572,572,572,572,572,572,572,572,\n572,572,572,572,120,120,120,120,120,120,120,120,120,120,120,120,\n578,578,578,578,578,578,578,578,578,578,578,578,578,578,578,578,\n\n/* block 94 */\n583,583,583,583,583,583,583,583,583,583,583,583,583,583,583,583,\n583,583,583,583,583,583,583,583,583,583,583,583,583,583,583,120,\n582,582,582,582,582,582,582,582,582,582,572,572,572,572,572,572,\n572,572,572,572,572,572,572,572,572,572,572,572,572,572,572,572,\n572,572,572,572,572,572,572,572, 25, 25, 25, 25, 25, 25, 25, 25,\n 20, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25,\n583,583,583,583,583,583,583,583,583,583,583,583,583,583,583,583,\n583,583,583,583,583,583,583,583,583,583,583,583,583,583,583, 20,\n\n/* block 95 */\n582,582,582,582,582,582,582,582,582,582,572,572,572,572,572,572,\n572,572,572,572,572,572,572,584,572,584,572,572,572,572,572,572,\n572,572,572,572,572,572,572,572,572,572,572,572,572,572,572,572,\n572, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25,\n572,572,572,572,572,572,572,572,572,572,572,572, 20, 20, 20, 20,\n585,585,585,585,585,585,585,585,585,585,585,585,585,585,585,585,\n585,585,585,585,585,585,585,585,585,585,585,585,585,585,585,585,\n585,585,585,585,585,585,585,585,585,585,585,585,585,585,585,572,\n\n/* block 96 */\n585,585,585,585,585,585,585,585,585,585,585,585,585,585,585,585,\n585,585,585,585,585,585,585,585,585,585,585,585,585,585,585,585,\n585,585,585,585,585,585,585,585,585,585,585,585,585,585,585,585,\n585,585,585,585,585,585,585,585,585,585,585,585,585,585,585,585,\n585,585,585,585,585,585,585,585,585,585,585,585,585,585,585,585,\n585,585,585,585,585,585,585,585,572,572,572,572,572,572,572,572,\n572,572,572,572,572,572,572,572,572,572,572,572,572,572,572,572,\n572, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20,572,572,572,572,572,\n\n/* block 97 */\n 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20,\n 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20,\n 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20,\n 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20,\n 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20,\n 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20,\n572,572,572,572,572,572,572,572,572,572,572,572,572,572,572,572,\n572,572,572,572,572,572,572,572,572,572,572,572,572,572,572, 20,\n\n/* block 98 */\n586,586,586,586,586,586,586,586,586,586,586,586,586,586,586,586,\n586,586,586,586,586,586,586,586,586,586,586,586,586,586,586,586,\n586,586,586,586,586,586,586,586,586,586,586,586,586,586,586,586,\n586,586,586,586,586,586,586,586,586,586,586,586,586,586,586,586,\n586,586,586,586,586,586,586,586,586,586,586,586,586,586,586,586,\n586,586,586,586,586,586,586,586,586,586,586,586,586,586,586,586,\n586,586,586,586,586,586,586,586,586,586,586,586,586,586,586,586,\n586,586,586,586,586,586,586,586,586,586,586,586,586,586,586,586,\n\n/* block 99 */\n586,586,586,586,586,586,586,586,586,586,586,586,586,586,586,586,\n586,586,586,586,586,586,586,586,586,586,586,586,586,586,586,586,\n586,586,586,586,586,586,586,586,586,586,586,586,586,586,586,586,\n586,586,586,586,586,586,586,586,586,586,586,586,586,586,586,586,\n 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20,\n 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20,\n 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20,\n 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20,\n\n/* block 100 */\n586,586,586,586,586,586,586,586,586,586,586,586,586,586,586,586,\n586,586,586,586,586,586,586,586,586,586,586,586,586,586,586,586,\n586,586,586,586,586,586,586,586,586,586,586,586,586,586,586,586,\n586,586,586,586,586,586,586,586,586,586,586,586,586,586,586,586,\n586,586,586,586,586,586,586,586,586,586,586,586,586,586,586,586,\n586,586,586,586,586,586,586,586,586,586,586,586,586,586,586,586,\n586,586,586,586,586,586,586,586,586,586,586,586,586,586,586,586,\n586,586,586,586,586,586,586,586,586,586,586,586,586,120,120,120,\n\n/* block 101 */\n587,587,587,587,587,587,587,587,587,587,587,587,587,587,587,587,\n587,587,587,587,587,588,587,587,587,587,587,587,587,587,587,587,\n587,587,587,587,587,587,587,587,587,587,587,587,587,587,587,587,\n587,587,587,587,587,587,587,587,587,587,587,587,587,587,587,587,\n587,587,587,587,587,587,587,587,587,587,587,587,587,587,587,587,\n587,587,587,587,587,587,587,587,587,587,587,587,587,587,587,587,\n587,587,587,587,587,587,587,587,587,587,587,587,587,587,587,587,\n587,587,587,587,587,587,587,587,587,587,587,587,587,587,587,587,\n\n/* block 102 */\n587,587,587,587,587,587,587,587,587,587,587,587,587,587,587,587,\n587,587,587,587,587,587,587,587,587,587,587,587,587,587,587,587,\n587,587,587,587,587,587,587,587,587,587,587,587,587,587,587,587,\n587,587,587,587,587,587,587,587,587,587,587,587,587,587,587,587,\n587,587,587,587,587,587,587,587,587,587,587,587,587,587,587,587,\n587,587,587,587,587,587,587,587,587,587,587,587,587,587,587,587,\n587,587,587,587,587,587,587,587,587,587,587,587,587,587,587,587,\n587,587,587,587,587,587,587,587,587,587,587,587,587,587,587,587,\n\n/* block 103 */\n587,587,587,587,587,587,587,587,587,587,587,587,587,120,120,120,\n589,589,589,589,589,589,589,589,589,589,589,589,589,589,589,589,\n589,589,589,589,589,589,589,589,589,589,589,589,589,589,589,589,\n589,589,589,589,589,589,589,589,589,589,589,589,589,589,589,589,\n589,589,589,589,589,589,589,120,120,120,120,120,120,120,120,120,\n590,590,590,590,590,590,590,590,590,590,590,590,590,590,590,590,\n590,590,590,590,590,590,590,590,590,590,590,590,590,590,590,590,\n590,590,590,590,590,590,590,590,591,591,591,591,591,591,592,592,\n\n/* block 104 */\n593,593,593,593,593,593,593,593,593,593,593,593,593,593,593,593,\n593,593,593,593,593,593,593,593,593,593,593,593,593,593,593,593,\n593,593,593,593,593,593,593,593,593,593,593,593,593,593,593,593,\n593,593,593,593,593,593,593,593,593,593,593,593,593,593,593,593,\n593,593,593,593,593,593,593,593,593,593,593,593,593,593,593,593,\n593,593,593,593,593,593,593,593,593,593,593,593,593,593,593,593,\n593,593,593,593,593,593,593,593,593,593,593,593,593,593,593,593,\n593,593,593,593,593,593,593,593,593,593,593,593,593,593,593,593,\n\n/* block 105 */\n593,593,593,593,593,593,593,593,593,593,593,593,594,595,595,595,\n593,593,593,593,593,593,593,593,593,593,593,593,593,593,593,593,\n596,596,596,596,596,596,596,596,596,596,593,593,120,120,120,120,\n120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,\n192,193,192,193,192,193,192,193,192,193,597,598,192,193,192,193,\n192,193,192,193,192,193,192,193,192,193,192,193,192,193,192,193,\n192,193,192,193,192,193,192,193,192,193,192,193,192,193,599,198,\n200,200,200,600,552,552,552,552,552,552,552,552,552,552,600,478,\n\n/* block 106 */\n192,193,192,193,192,193,192,193,192,193,192,193,192,193,192,193,\n192,193,192,193,192,193,192,193,192,193,192,193,478,478,552,552,\n601,601,601,601,601,601,601,601,601,601,601,601,601,601,601,601,\n601,601,601,601,601,601,601,601,601,601,601,601,601,601,601,601,\n601,601,601,601,601,601,601,601,601,601,601,601,601,601,601,601,\n601,601,601,601,601,601,601,601,601,601,601,601,601,601,601,601,\n601,601,601,601,601,601,602,602,602,602,602,602,602,602,602,602,\n603,603,604,604,604,604,604,604,120,120,120,120,120,120,120,120,\n\n/* block 107 */\n605,605,605,605,605,605,605,605, 15, 15, 15, 15, 15, 15, 15, 15,\n 15, 15, 15, 15, 15, 15, 15,111,111,111,111,111,111,111,111,111,\n 15, 15, 32, 33, 32, 33, 32, 33, 32, 33, 32, 33, 32, 33, 32, 33,\n 35, 35, 32, 33, 32, 33, 32, 33, 32, 33, 32, 33, 32, 33, 32, 33,\n 32, 33, 32, 33, 32, 33, 32, 33, 32, 33, 32, 33, 32, 33, 32, 33,\n 32, 33, 32, 33, 32, 33, 32, 33, 32, 33, 32, 33, 32, 33, 32, 33,\n 32, 33, 32, 33, 32, 33, 32, 33, 32, 33, 32, 33, 32, 33, 32, 33,\n110, 35, 35, 35, 35, 35, 35, 35, 35, 32, 33, 32, 33,606, 32, 33,\n\n/* block 108 */\n 32, 33, 32, 33, 32, 33, 32, 33,111, 15, 15, 32, 33,607, 35, 22,\n 32, 33, 32, 33,608, 35, 32, 33, 32, 33, 32, 33, 32, 33, 32, 33,\n 32, 33, 32, 33, 32, 33, 32, 33, 32, 33,609,610,611,612,609, 35,\n613,614,615,616, 32, 33, 32, 33, 32, 33, 32, 33, 32, 33, 32, 33,\n120,120, 32, 33,617,618,619, 32, 33, 32, 33,120,120,120,120,120,\n120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,\n120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,\n120,120,120,120,120, 32, 33, 22,110,110, 35, 22, 22, 22, 22, 22,\n\n/* block 109 */\n620,620,621,620,620,620,621,620,620,620,620,621,620,620,620,620,\n620,620,620,620,620,620,620,620,620,620,620,620,620,620,620,620,\n620,620,620,622,622,621,621,622,623,623,623,623,621,120,120,120,\n624,624,624,625,625,625,626,626,627,626,120,120,120,120,120,120,\n628,628,628,628,628,628,628,628,628,628,628,628,628,628,628,628,\n628,628,628,628,628,628,628,628,628,628,628,628,628,628,628,628,\n628,628,628,628,628,628,628,628,628,628,628,628,628,628,628,628,\n628,628,628,628,629,629,629,629,120,120,120,120,120,120,120,120,\n\n/* block 110 */\n630,630,631,631,631,631,631,631,631,631,631,631,631,631,631,631,\n631,631,631,631,631,631,631,631,631,631,631,631,631,631,631,631,\n631,631,631,631,631,631,631,631,631,631,631,631,631,631,631,631,\n631,631,631,631,630,630,630,630,630,630,630,630,630,630,630,630,\n630,630,630,630,632,632,120,120,120,120,120,120,120,120,633,633,\n634,634,634,634,634,634,634,634,634,634,120,120,120,120,120,120,\n251,251,251,251,251,251,251,251,251,251,251,251,251,251,251,251,\n251,635,253,636,253,253,253,253,259,259,259,253,259,253,253,251,\n\n/* block 111 */\n637,637,637,637,637,637,637,637,637,637,638,638,638,638,638,638,\n638,638,638,638,638,638,638,638,638,638,638,638,638,638,638,638,\n638,638,638,638,638,638,639,639,639,639,639,639,639,639,640,641,\n642,642,642,642,642,642,642,642,642,642,642,642,642,642,642,642,\n642,642,642,642,642,642,642,643,643,643,643,643,643,643,643,643,\n643,643,644,644,120,120,120,120,120,120,120,120,120,120,120,645,\n356,356,356,356,356,356,356,356,356,356,356,356,356,356,356,356,\n356,356,356,356,356,356,356,356,356,356,356,356,356,120,120,120,\n\n/* block 112 */\n646,646,646,647,648,648,648,648,648,648,648,648,648,648,648,648,\n648,648,648,648,648,648,648,648,648,648,648,648,648,648,648,648,\n648,648,648,648,648,648,648,648,648,648,648,648,648,648,648,648,\n648,648,648,646,647,647,646,646,646,646,647,647,646,646,647,647,\n647,649,649,649,649,649,649,649,649,649,649,649,649,649,120,650,\n651,651,651,651,651,651,651,651,651,651,120,120,120,120,649,649,\n344,344,344,344,344,346,652,344,344,344,344,344,344,344,344,344,\n350,350,350,350,350,350,350,350,350,350,344,344,344,344,344,120,\n\n/* block 113 */\n653,653,653,653,653,653,653,653,653,653,653,653,653,653,653,653,\n653,653,653,653,653,653,653,653,653,653,653,653,653,653,653,653,\n653,653,653,653,653,653,653,653,653,654,654,654,654,654,654,655,\n655,654,654,655,655,654,654,120,120,120,120,120,120,120,120,120,\n653,653,653,654,653,653,653,653,653,653,653,653,654,655,120,120,\n656,656,656,656,656,656,656,656,656,656,120,120,657,657,657,657,\n344,344,344,344,344,344,344,344,344,344,344,344,344,344,344,344,\n652,344,344,344,344,344,344,351,351,351,344,345,346,345,344,344,\n\n/* block 114 */\n658,658,658,658,658,658,658,658,658,658,658,658,658,658,658,658,\n658,658,658,658,658,658,658,658,658,658,658,658,658,658,658,658,\n658,658,658,658,658,658,658,658,658,658,658,658,658,658,658,658,\n659,658,659,659,659,658,658,659,659,658,658,658,658,658,659,659,\n658,659,658,120,120,120,120,120,120,120,120,120,120,120,120,120,\n120,120,120,120,120,120,120,120,120,120,120,658,658,660,661,661,\n662,662,662,662,662,662,662,662,662,662,662,663,664,664,663,663,\n665,665,662,666,666,663,664,120,120,120,120,120,120,120,120,120,\n\n/* block 115 */\n120,359,359,359,359,359,359,120,120,359,359,359,359,359,359,120,\n120,359,359,359,359,359,359,120,120,120,120,120,120,120,120,120,\n359,359,359,359,359,359,359,120,359,359,359,359,359,359,359,120,\n 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,\n 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,\n 35, 35, 35,667, 35, 35, 35, 35, 35, 35, 35, 15,110,110,110,110,\n 35, 35, 35, 35, 35,128, 35, 35, 35,110, 15, 15,120,120,120,120,\n668,668,668,668,668,668,668,668,668,668,668,668,668,668,668,668,\n\n/* block 116 */\n668,668,668,668,668,668,668,668,668,668,668,668,668,668,668,668,\n668,668,668,668,668,668,668,668,668,668,668,668,668,668,668,668,\n668,668,668,668,668,668,668,668,668,668,668,668,668,668,668,668,\n668,668,668,668,668,668,668,668,668,668,668,668,668,668,668,668,\n662,662,662,662,662,662,662,662,662,662,662,662,662,662,662,662,\n662,662,662,662,662,662,662,662,662,662,662,662,662,662,662,662,\n662,662,662,663,663,664,663,663,664,663,663,665,663,664,120,120,\n669,669,669,669,669,669,669,669,669,669,120,120,120,120,120,120,\n\n/* block 117 */\n670,671,671,671,671,671,671,671,671,671,671,671,671,671,671,671,\n671,671,671,671,671,671,671,671,671,671,671,671,670,671,671,671,\n671,671,671,671,671,671,671,671,671,671,671,671,671,671,671,671,\n671,671,671,671,671,671,671,671,670,671,671,671,671,671,671,671,\n671,671,671,671,671,671,671,671,671,671,671,671,671,671,671,671,\n671,671,671,671,670,671,671,671,671,671,671,671,671,671,671,671,\n671,671,671,671,671,671,671,671,671,671,671,671,671,671,671,671,\n670,671,671,671,671,671,671,671,671,671,671,671,671,671,671,671,\n\n/* block 118 */\n671,671,671,671,671,671,671,671,671,671,671,671,670,671,671,671,\n671,671,671,671,671,671,671,671,671,671,671,671,671,671,671,671,\n671,671,671,671,671,671,671,671,670,671,671,671,671,671,671,671,\n671,671,671,671,671,671,671,671,671,671,671,671,671,671,671,671,\n671,671,671,671,670,671,671,671,671,671,671,671,671,671,671,671,\n671,671,671,671,671,671,671,671,671,671,671,671,671,671,671,671,\n670,671,671,671,671,671,671,671,671,671,671,671,671,671,671,671,\n671,671,671,671,671,671,671,671,671,671,671,671,670,671,671,671,\n\n/* block 119 */\n671,671,671,671,671,671,671,671,671,671,671,671,671,671,671,671,\n671,671,671,671,671,671,671,671,670,671,671,671,671,671,671,671,\n671,671,671,671,671,671,671,671,671,671,671,671,671,671,671,671,\n671,671,671,671,670,671,671,671,671,671,671,671,671,671,671,671,\n671,671,671,671,671,671,671,671,671,671,671,671,671,671,671,671,\n670,671,671,671,671,671,671,671,671,671,671,671,671,671,671,671,\n671,671,671,671,671,671,671,671,671,671,671,671,670,671,671,671,\n671,671,671,671,671,671,671,671,671,671,671,671,671,671,671,671,\n\n/* block 120 */\n671,671,671,671,671,671,671,671,670,671,671,671,671,671,671,671,\n671,671,671,671,671,671,671,671,671,671,671,671,671,671,671,671,\n671,671,671,671,670,671,671,671,671,671,671,671,671,671,671,671,\n671,671,671,671,671,671,671,671,671,671,671,671,671,671,671,671,\n670,671,671,671,671,671,671,671,671,671,671,671,671,671,671,671,\n671,671,671,671,671,671,671,671,671,671,671,671,670,671,671,671,\n671,671,671,671,671,671,671,671,671,671,671,671,671,671,671,671,\n671,671,671,671,671,671,671,671,670,671,671,671,671,671,671,671,\n\n/* block 121 */\n671,671,671,671,671,671,671,671,671,671,671,671,671,671,671,671,\n671,671,671,671,670,671,671,671,671,671,671,671,671,671,671,671,\n671,671,671,671,671,671,671,671,671,671,671,671,671,671,671,671,\n670,671,671,671,671,671,671,671,671,671,671,671,671,671,671,671,\n671,671,671,671,671,671,671,671,671,671,671,671,670,671,671,671,\n671,671,671,671,671,671,671,671,671,671,671,671,671,671,671,671,\n671,671,671,671,671,671,671,671,670,671,671,671,671,671,671,671,\n671,671,671,671,671,671,671,671,671,671,671,671,671,671,671,671,\n\n/* block 122 */\n671,671,671,671,670,671,671,671,671,671,671,671,671,671,671,671,\n671,671,671,671,671,671,671,671,671,671,671,671,671,671,671,671,\n670,671,671,671,671,671,671,671,671,671,671,671,671,671,671,671,\n671,671,671,671,671,671,671,671,671,671,671,671,670,671,671,671,\n671,671,671,671,671,671,671,671,671,671,671,671,671,671,671,671,\n671,671,671,671,671,671,671,671,670,671,671,671,671,671,671,671,\n671,671,671,671,671,671,671,671,671,671,671,671,671,671,671,671,\n671,671,671,671,670,671,671,671,671,671,671,671,671,671,671,671,\n\n/* block 123 */\n671,671,671,671,671,671,671,671,671,671,671,671,671,671,671,671,\n670,671,671,671,671,671,671,671,671,671,671,671,671,671,671,671,\n671,671,671,671,671,671,671,671,671,671,671,671,670,671,671,671,\n671,671,671,671,671,671,671,671,671,671,671,671,671,671,671,671,\n671,671,671,671,671,671,671,671,670,671,671,671,671,671,671,671,\n671,671,671,671,671,671,671,671,671,671,671,671,671,671,671,671,\n671,671,671,671,670,671,671,671,671,671,671,671,671,671,671,671,\n671,671,671,671,671,671,671,671,671,671,671,671,671,671,671,671,\n\n/* block 124 */\n671,671,671,671,671,671,671,671,670,671,671,671,671,671,671,671,\n671,671,671,671,671,671,671,671,671,671,671,671,671,671,671,671,\n671,671,671,671,120,120,120,120,120,120,120,120,120,120,120,120,\n357,357,357,357,357,357,357,357,357,357,357,357,357,357,357,357,\n357,357,357,357,357,357,357,120,120,120,120,358,358,358,358,358,\n358,358,358,358,358,358,358,358,358,358,358,358,358,358,358,358,\n358,358,358,358,358,358,358,358,358,358,358,358,358,358,358,358,\n358,358,358,358,358,358,358,358,358,358,358,358,120,120,120,120,\n\n/* block 125 */\n672,672,672,672,672,672,672,672,672,672,672,672,672,672,672,672,\n672,672,672,672,672,672,672,672,672,672,672,672,672,672,672,672,\n672,672,672,672,672,672,672,672,672,672,672,672,672,672,672,672,\n672,672,672,672,672,672,672,672,672,672,672,672,672,672,672,672,\n672,672,672,672,672,672,672,672,672,672,672,672,672,672,672,672,\n672,672,672,672,672,672,672,672,672,672,672,672,672,672,672,672,\n672,672,672,672,672,672,672,672,672,672,672,672,672,672,672,672,\n672,672,672,672,672,672,672,672,672,672,672,672,672,672,672,672,\n\n/* block 126 */\n673,673,673,673,673,673,673,673,673,673,673,673,673,673,673,673,\n673,673,673,673,673,673,673,673,673,673,673,673,673,673,673,673,\n673,673,673,673,673,673,673,673,673,673,673,673,673,673,673,673,\n673,673,673,673,673,673,673,673,673,673,673,673,673,673,673,673,\n673,673,673,673,673,673,673,673,673,673,673,673,673,673,673,673,\n673,673,673,673,673,673,673,673,673,673,673,673,673,673,673,673,\n673,673,673,673,673,673,673,673,673,673,673,673,673,673,673,673,\n673,673,673,673,673,673,673,673,673,673,673,673,673,673,673,673,\n\n/* block 127 */\n586,586,586,586,586,586,586,586,586,586,586,586,586,586,586,586,\n586,586,586,586,586,586,586,586,586,586,586,586,586,586,586,586,\n586,586,586,586,586,586,586,586,586,586,586,586,586,586,586,586,\n586,586,586,586,586,586,586,586,586,586,586,586,586,586,586,586,\n586,586,586,586,586,586,586,586,586,586,586,586,586,586,586,586,\n586,586,586,586,586,586,586,586,586,586,586,586,586,586,586,586,\n586,586,586,586,586,586,586,586,586,586,586,586,586,586,120,120,\n586,586,586,586,586,586,586,586,586,586,586,586,586,586,586,586,\n\n/* block 128 */\n586,586,586,586,586,586,586,586,586,586,586,586,586,586,586,586,\n586,586,586,586,586,586,586,586,586,586,586,586,586,586,586,586,\n586,586,586,586,586,586,586,586,586,586,586,586,586,586,586,586,\n586,586,586,586,586,586,586,586,586,586,586,586,586,586,586,586,\n586,586,586,586,586,586,586,586,586,586,586,586,586,586,586,586,\n586,586,586,586,586,586,586,586,586,586,120,120,120,120,120,120,\n120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,\n120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,\n\n/* block 129 */\n 35, 35, 35, 35, 35, 35, 35,120,120,120,120,120,120,120,120,120,\n120,120,120,206,206,206,206,206,120,120,120,120,120,214,211,214,\n214,214,214,214,214,214,214,214,214,674,214,214,214,214,214,214,\n214,214,214,214,214,214,214,120,214,214,214,214,214,120,214,120,\n214,214,120,214,214,120,214,214,214,214,214,214,214,214,214,214,\n224,224,224,224,224,224,224,224,224,224,224,224,224,224,224,224,\n224,224,224,224,224,224,224,224,224,224,224,224,224,224,224,224,\n224,224,224,224,224,224,224,224,224,224,224,224,224,224,224,224,\n\n/* block 130 */\n224,224,224,224,224,224,224,224,224,224,224,224,224,224,224,224,\n224,224,224,224,224,224,224,224,224,224,224,224,224,224,224,224,\n224,224,224,224,224,224,224,224,224,224,224,224,224,224,224,224,\n224,224,675,675,675,675,675,675,675,675,675,675,675,675,675,675,\n675,675,120,120,120,120,120,120,120,120,120,120,120,120,120,120,\n120,120,120,224,224,224,224,224,224,224,224,224,224,224,224,224,\n224,224,224,224,224,224,224,224,224,224,224,224,224,224,224,224,\n224,224,224,224,224,224,224,224,224,224,224,224,224,224,224,224,\n\n/* block 131 */\n224,224,224,224,224,224,224,224,224,224,224,224,224,224,224,224,\n224,224,224,224,224,224,224,224,224,224,224,224,224,224,224,224,\n224,224,224,224,224,224,224,224,224,224,224,224,224,224,224,224,\n224,224,224,224,224,224,224,224,224,224,224,224,224,224,224,224,\n224,224,224,224,224,224,224,224,224,224,224,224,224,224,224,224,\n224,224,224,224,224,224,224,224,224,224,224,224,224,224,224,224,\n224,224,224,224,224,224,224,224,224,224,224,224,224,224,224,224,\n224,224,224,224,224,224,224,224,224,224,224,224,224,224,224,224,\n\n/* block 132 */\n224,224,224,224,224,224,224,224,224,224,224,224,224,224,224,224,\n224,224,224,224,224,224,224,224,224,224,224,224,224,224,224,224,\n224,224,224,224,224,224,224,224,224,224,224,224,224,224,224,224,\n224,224,224,224,224,224,224,224,224,224,224,224,224,224,  8,  7,\n120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,\n224,224,224,224,224,224,224,224,224,224,224,224,224,224,224,224,\n224,224,224,224,224,224,224,224,224,224,224,224,224,224,224,224,\n224,224,224,224,224,224,224,224,224,224,224,224,224,224,224,224,\n\n/* block 133 */\n224,224,224,224,224,224,224,224,224,224,224,224,224,224,224,224,\n120,120,224,224,224,224,224,224,224,224,224,224,224,224,224,224,\n224,224,224,224,224,224,224,224,224,224,224,224,224,224,224,224,\n224,224,224,224,224,224,224,224,224,224,224,224,224,224,224,224,\n224,224,224,224,224,224,224,224,120,120,120,120,120,120,120,120,\n120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,\n120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,\n224,224,676,224,224,224,224,224,224,224,224,224,219,677,120,120,\n\n/* block 134 */\n113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,\n  5,  5,  5,  5,  5,  5,  5,  7,  8,  5,120,120,120,120,120,120,\n113,113,113,113,113,113,113,113,113,113,113,113,113,113,552,552,\n  5, 10, 10, 16, 16,  7,  8,  7,  8,  7,  8,  7,  8,  7,  8,  7,\n  8,  7,  8,  7,  8,556,556,  7,  8,  5,  5,  5,  5, 16, 16, 16,\n  5,  5,  5,120,  5,  5,  5,  5, 10,  7,  8,  7,  8,  7,  8,  5,\n  5,  5,  9, 10,  9,  9,  9,120,  5,  6,  5,  5,120,120,120,120,\n224,224,224,224,224,120,224,224,224,224,224,224,224,224,224,224,\n\n/* block 135 */\n224,224,224,224,224,224,224,224,224,224,224,224,224,224,224,224,\n224,224,224,224,224,224,224,224,224,224,224,224,224,224,224,224,\n224,224,224,224,224,224,224,224,224,224,224,224,224,224,224,224,\n224,224,224,224,224,224,224,224,224,224,224,224,224,224,224,224,\n224,224,224,224,224,224,224,224,224,224,224,224,224,224,224,224,\n224,224,224,224,224,224,224,224,224,224,224,224,224,224,224,224,\n224,224,224,224,224,224,224,224,224,224,224,224,224,224,224,224,\n224,224,224,224,224,224,224,224,224,224,224,224,224,120,120, 24,\n\n/* block 136 */\n120,  5,  5,  5,  6,  5,  5,  5,  7,  8,  5,  9,  5, 10,  5,  5,\n 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,  5,  5,  9,  9,  9,  5,\n  5, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,\n 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,  7,  5,  8, 15, 16,\n 15, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,\n 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,  7,  9,  8,  9,  7,\n  8,555,560,561,555,555,578,578,578,578,578,578,578,578,578,578,\n569,578,578,578,578,578,578,578,578,578,578,578,578,578,578,578,\n\n/* block 137 */\n578,578,578,578,578,578,578,578,578,578,578,578,578,578,578,578,\n578,578,578,578,578,578,578,578,578,578,578,578,578,578,678,678,\n581,581,581,581,581,581,581,581,581,581,581,581,581,581,581,581,\n581,581,581,581,581,581,581,581,581,581,581,581,581,581,581,120,\n120,120,581,581,581,581,581,581,120,120,581,581,581,581,581,581,\n120,120,581,581,581,581,581,581,120,120,581,581,581,120,120,120,\n  6,  6,  9, 15, 20,  6,  6,120, 20,  9,  9,  9,  9, 20, 20,120,\n511,511,511,511,511,511,511,511,511, 24, 24, 24, 20, 20,120,120,\n\n/* block 138 */\n679,679,679,679,679,679,679,679,679,679,679,679,120,679,679,679,\n679,679,679,679,679,679,679,679,679,679,679,679,679,679,679,679,\n679,679,679,679,679,679,679,120,679,679,679,679,679,679,679,679,\n679,679,679,679,679,679,679,679,679,679,679,120,679,679,120,679,\n679,679,679,679,679,679,679,679,679,679,679,679,679,679,120,120,\n679,679,679,679,679,679,679,679,679,679,679,679,679,679,120,120,\n120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,\n120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,\n\n/* block 139 */\n679,679,679,679,679,679,679,679,679,679,679,679,679,679,679,679,\n679,679,679,679,679,679,679,679,679,679,679,679,679,679,679,679,\n679,679,679,679,679,679,679,679,679,679,679,679,679,679,679,679,\n679,679,679,679,679,679,679,679,679,679,679,679,679,679,679,679,\n679,679,679,679,679,679,679,679,679,679,679,679,679,679,679,679,\n679,679,679,679,679,679,679,679,679,679,679,679,679,679,679,679,\n679,679,679,679,679,679,679,679,679,679,679,679,679,679,679,679,\n679,679,679,679,679,679,679,679,679,679,679,120,120,120,120,120,\n\n/* block 140 */\n680,680,680,120,120,120,120,681,681,681,681,681,681,681,681,681,\n681,681,681,681,681,681,681,681,681,681,681,681,681,681,681,681,\n681,681,681,681,681,681,681,681,681,681,681,681,681,681,681,681,\n681,681,681,681,120,120,120,682,682,682,682,682,682,682,682,682,\n683,683,683,683,683,683,683,683,683,683,683,683,683,683,683,683,\n683,683,683,683,683,683,683,683,683,683,683,683,683,683,683,683,\n683,683,683,683,683,683,683,683,683,683,683,683,683,683,683,683,\n683,683,683,683,683,684,684,684,684,685,685,685,685,685,685,685,\n\n/* block 141 */\n685,685,685,685,685,685,685,685,685,685,684,684,685,685,685,120,\n 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20,120,120,120,\n685,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,\n120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,\n120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,\n 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20,\n 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20,\n 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20,113,120,120,\n\n/* block 142 */\n120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,\n120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,\n120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,\n120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,\n120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,\n120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,\n120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,\n120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,\n\n/* block 143 */\n686,686,686,686,686,686,686,686,686,686,686,686,686,686,686,686,\n686,686,686,686,686,686,686,686,686,686,686,686,686,120,120,120,\n687,687,687,687,687,687,687,687,687,687,687,687,687,687,687,687,\n687,687,687,687,687,687,687,687,687,687,687,687,687,687,687,687,\n687,687,687,687,687,687,687,687,687,687,687,687,687,687,687,687,\n687,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,\n688,689,689,689,689,689,689,689,689,689,689,689,689,689,689,689,\n689,689,689,689,689,689,689,689,689,689,689,689,120,120,120,120,\n\n/* block 144 */\n690,690,690,690,690,690,690,690,690,690,690,690,690,690,690,690,\n690,690,690,690,690,690,690,690,690,690,690,690,690,690,690,690,\n691,691,691,691,120,120,120,120,120,120,120,120,120,690,690,690,\n692,692,692,692,692,692,692,692,692,692,692,692,692,692,692,692,\n692,693,692,692,692,692,692,692,692,692,693,120,120,120,120,120,\n694,694,694,694,694,694,694,694,694,694,694,694,694,694,694,694,\n694,694,694,694,694,694,694,694,694,694,694,694,694,694,694,694,\n694,694,694,694,694,694,695,695,695,695,695,120,120,120,120,120,\n\n/* block 145 */\n696,696,696,696,696,696,696,696,696,696,696,696,696,696,696,696,\n696,696,696,696,696,696,696,696,696,696,696,696,696,696,120,697,\n698,698,698,698,698,698,698,698,698,698,698,698,698,698,698,698,\n698,698,698,698,698,698,698,698,698,698,698,698,698,698,698,698,\n698,698,698,698,120,120,120,120,698,698,698,698,698,698,698,698,\n699,700,700,700,700,700,120,120,120,120,120,120,120,120,120,120,\n120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,\n120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,\n\n/* block 146 */\n701,701,701,701,701,701,701,701,701,701,701,701,701,701,701,701,\n701,701,701,701,701,701,701,701,701,701,701,701,701,701,701,701,\n701,701,701,701,701,701,701,701,702,702,702,702,702,702,702,702,\n702,702,702,702,702,702,702,702,702,702,702,702,702,702,702,702,\n702,702,702,702,702,702,702,702,702,702,702,702,702,702,702,702,\n703,703,703,703,703,703,703,703,703,703,703,703,703,703,703,703,\n703,703,703,703,703,703,703,703,703,703,703,703,703,703,703,703,\n703,703,703,703,703,703,703,703,703,703,703,703,703,703,703,703,\n\n/* block 147 */\n704,704,704,704,704,704,704,704,704,704,704,704,704,704,704,704,\n704,704,704,704,704,704,704,704,704,704,704,704,704,704,120,120,\n705,705,705,705,705,705,705,705,705,705,120,120,120,120,120,120,\n706,706,706,706,706,706,706,706,706,706,706,706,706,706,706,706,\n706,706,706,706,706,706,706,706,706,706,706,706,706,706,706,706,\n706,706,706,706,120,120,120,120,707,707,707,707,707,707,707,707,\n707,707,707,707,707,707,707,707,707,707,707,707,707,707,707,707,\n707,707,707,707,707,707,707,707,707,707,707,707,120,120,120,120,\n\n/* block 148 */\n708,708,708,708,708,708,708,708,708,708,708,708,708,708,708,708,\n708,708,708,708,708,708,708,708,708,708,708,708,708,708,708,708,\n708,708,708,708,708,708,708,708,120,120,120,120,120,120,120,120,\n709,709,709,709,709,709,709,709,709,709,709,709,709,709,709,709,\n709,709,709,709,709,709,709,709,709,709,709,709,709,709,709,709,\n709,709,709,709,709,709,709,709,709,709,709,709,709,709,709,709,\n709,709,709,709,120,120,120,120,120,120,120,120,120,120,120,710,\n120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,\n\n/* block 149 */\n711,711,711,711,711,711,711,711,711,711,711,711,711,711,711,711,\n711,711,711,711,711,711,711,711,711,711,711,711,711,711,711,711,\n711,711,711,711,711,711,711,711,711,711,711,711,711,711,711,711,\n711,711,711,711,711,711,711,711,711,711,711,711,711,711,711,711,\n711,711,711,711,711,711,711,711,711,711,711,711,711,711,711,711,\n711,711,711,711,711,711,711,711,711,711,711,711,711,711,711,711,\n711,711,711,711,711,711,711,711,711,711,711,711,711,711,711,711,\n711,711,711,711,711,711,711,711,711,711,711,711,711,711,711,711,\n\n/* block 150 */\n711,711,711,711,711,711,711,711,711,711,711,711,711,711,711,711,\n711,711,711,711,711,711,711,711,711,711,711,711,711,711,711,711,\n711,711,711,711,711,711,711,711,711,711,711,711,711,711,711,711,\n711,711,711,711,711,711,711,120,120,120,120,120,120,120,120,120,\n711,711,711,711,711,711,711,711,711,711,711,711,711,711,711,711,\n711,711,711,711,711,711,120,120,120,120,120,120,120,120,120,120,\n711,711,711,711,711,711,711,711,120,120,120,120,120,120,120,120,\n120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,\n\n/* block 151 */\n712,712,712,712,712,712,120,120,712,120,712,712,712,712,712,712,\n712,712,712,712,712,712,712,712,712,712,712,712,712,712,712,712,\n712,712,712,712,712,712,712,712,712,712,712,712,712,712,712,712,\n712,712,712,712,712,712,120,712,712,120,120,120,712,120,120,712,\n713,713,713,713,713,713,713,713,713,713,713,713,713,713,713,713,\n713,713,713,713,713,713,120,714,715,715,715,715,715,715,715,715,\n716,716,716,716,716,716,716,716,716,716,716,716,716,716,716,716,\n716,716,716,716,716,716,716,717,717,718,718,718,718,718,718,718,\n\n/* block 152 */\n719,719,719,719,719,719,719,719,719,719,719,719,719,719,719,719,\n719,719,719,719,719,719,719,719,719,719,719,719,719,719,719,120,\n120,120,120,120,120,120,120,720,720,720,720,720,720,720,720,720,\n120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,\n120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,\n120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,\n721,721,721,721,721,721,721,721,721,721,721,721,721,721,721,721,\n721,721,721,120,721,721,120,120,120,120,120,722,722,722,722,722,\n\n/* block 153 */\n723,723,723,723,723,723,723,723,723,723,723,723,723,723,723,723,\n723,723,723,723,723,723,724,724,724,724,724,724,120,120,120,725,\n726,726,726,726,726,726,726,726,726,726,726,726,726,726,726,726,\n726,726,726,726,726,726,726,726,726,726,120,120,120,120,120,727,\n120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,\n120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,\n120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,\n120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,\n\n/* block 154 */\n728,728,728,728,728,728,728,728,728,728,728,728,728,728,728,728,\n728,728,728,728,728,728,728,728,728,728,728,728,728,728,728,728,\n729,729,729,729,729,729,729,729,729,729,729,729,729,729,729,729,\n729,729,729,729,729,729,729,729,120,120,120,120,730,730,729,729,\n730,730,730,730,730,730,730,730,730,730,730,730,730,730,730,730,\n120,120,730,730,730,730,730,730,730,730,730,730,730,730,730,730,\n730,730,730,730,730,730,730,730,730,730,730,730,730,730,730,730,\n730,730,730,730,730,730,730,730,730,730,730,730,730,730,730,730,\n\n/* block 155 */\n731,732,732,732,120,732,732,120,120,120,120,120,732,732,732,732,\n731,731,731,731,120,731,731,731,120,731,731,731,731,731,731,731,\n731,731,731,731,731,731,731,731,731,731,731,731,731,731,731,731,\n731,731,731,731,731,731,120,120,732,732,732,120,120,120,120,732,\n733,733,733,733,733,733,733,733,733,120,120,120,120,120,120,120,\n734,734,734,734,734,734,734,734,734,120,120,120,120,120,120,120,\n735,735,735,735,735,735,735,735,735,735,735,735,735,735,735,735,\n735,735,735,735,735,735,735,735,735,735,735,735,735,736,736,737,\n\n/* block 156 */\n738,738,738,738,738,738,738,738,738,738,738,738,738,738,738,738,\n738,738,738,738,738,738,738,738,738,738,738,738,738,739,739,739,\n120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,\n120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,\n740,740,740,740,740,740,740,740,741,740,740,740,740,740,740,740,\n740,740,740,740,740,740,740,740,740,740,740,740,740,740,740,740,\n740,740,740,740,740,742,742,120,120,120,120,743,743,743,743,743,\n744,744,744,744,744,744,744,120,120,120,120,120,120,120,120,120,\n\n/* block 157 */\n745,745,745,745,745,745,745,745,745,745,745,745,745,745,745,745,\n745,745,745,745,745,745,745,745,745,745,745,745,745,745,745,745,\n745,745,745,745,745,745,745,745,745,745,745,745,745,745,745,745,\n745,745,745,745,745,745,120,120,120,746,746,746,746,746,746,746,\n747,747,747,747,747,747,747,747,747,747,747,747,747,747,747,747,\n747,747,747,747,747,747,120,120,748,748,748,748,748,748,748,748,\n749,749,749,749,749,749,749,749,749,749,749,749,749,749,749,749,\n749,749,749,120,120,120,120,120,750,750,750,750,750,750,750,750,\n\n/* block 158 */\n751,751,751,751,751,751,751,751,751,751,751,751,751,751,751,751,\n751,751,120,120,120,120,120,120,120,752,752,752,752,120,120,120,\n120,120,120,120,120,120,120,120,120,753,753,753,753,753,753,753,\n120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,\n120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,\n120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,\n120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,\n120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,\n\n/* block 159 */\n754,754,754,754,754,754,754,754,754,754,754,754,754,754,754,754,\n754,754,754,754,754,754,754,754,754,754,754,754,754,754,754,754,\n754,754,754,754,754,754,754,754,754,754,754,754,754,754,754,754,\n754,754,754,754,754,754,754,754,754,754,754,754,754,754,754,754,\n754,754,754,754,754,754,754,754,754,120,120,120,120,120,120,120,\n120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,\n120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,\n120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,\n\n/* block 160 */\n755,755,755,755,755,755,755,755,755,755,755,755,755,755,755,755,\n755,755,755,755,755,755,755,755,755,755,755,755,755,755,755,755,\n755,755,755,755,755,755,755,755,755,755,755,755,755,755,755,755,\n755,755,755,120,120,120,120,120,120,120,120,120,120,120,120,120,\n756,756,756,756,756,756,756,756,756,756,756,756,756,756,756,756,\n756,756,756,756,756,756,756,756,756,756,756,756,756,756,756,756,\n756,756,756,756,756,756,756,756,756,756,756,756,756,756,756,756,\n756,756,756,120,120,120,120,120,120,120,757,757,757,757,757,757,\n\n/* block 161 */\n758,758,758,758,758,758,758,758,758,758,758,758,758,758,758,758,\n758,758,758,758,758,758,758,758,758,758,758,758,758,758,758,758,\n758,758,758,758,759,759,759,759,120,120,120,120,120,120,120,120,\n760,760,760,760,760,760,760,760,760,760,120,120,120,120,120,120,\n120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,\n120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,\n120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,\n120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,\n\n/* block 162 */\n120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,\n120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,\n120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,\n120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,\n120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,\n120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,\n761,761,761,761,761,761,761,761,761,761,761,761,761,761,761,761,\n761,761,761,761,761,761,761,761,761,761,761,761,761,761,761,120,\n\n/* block 163 */\n762,762,762,762,762,762,762,762,762,762,762,762,762,762,762,762,\n762,762,762,762,762,762,762,762,762,762,762,762,762,762,762,762,\n762,762,762,762,762,762,762,762,762,762,120,763,763,764,120,120,\n762,762,120,120,120,120,120,120,120,120,120,120,120,120,120,120,\n120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,\n120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,\n120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,\n120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,\n\n/* block 164 */\n765,765,765,765,765,765,765,765,765,765,765,765,765,765,765,765,\n765,765,765,765,765,765,765,765,765,765,765,765,765,766,766,766,\n766,766,766,766,766,766,766,765,120,120,120,120,120,120,120,120,\n767,767,767,767,767,767,767,767,767,767,767,767,767,767,767,767,\n767,767,767,767,767,767,768,768,768,768,768,768,768,768,768,768,\n768,769,769,769,769,770,770,770,770,770,120,120,120,120,120,120,\n120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,\n120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,\n\n/* block 165 */\n120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,\n120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,\n120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,\n771,771,771,771,771,771,771,771,771,771,771,771,771,771,771,771,\n771,771,771,771,771,772,772,772,772,772,772,772,120,120,120,120,\n120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,\n773,773,773,773,773,773,773,773,773,773,773,773,773,773,773,773,\n773,773,773,773,773,773,773,120,120,120,120,120,120,120,120,120,\n\n/* block 166 */\n774,775,774,776,776,776,776,776,776,776,776,776,776,776,776,776,\n776,776,776,776,776,776,776,776,776,776,776,776,776,776,776,776,\n776,776,776,776,776,776,776,776,776,776,776,776,776,776,776,776,\n776,776,776,776,776,776,776,776,775,775,775,775,775,775,775,775,\n775,775,775,775,775,775,775,777,777,777,777,777,777,777,120,120,\n120,120,778,778,778,778,778,778,778,778,778,778,778,778,778,778,\n778,778,778,778,778,778,779,779,779,779,779,779,779,779,779,779,\n120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,775,\n\n/* block 167 */\n780,780,781,782,782,782,782,782,782,782,782,782,782,782,782,782,\n782,782,782,782,782,782,782,782,782,782,782,782,782,782,782,782,\n782,782,782,782,782,782,782,782,782,782,782,782,782,782,782,782,\n781,781,781,780,780,780,780,781,781,780,780,783,783,784,783,783,\n783,783,120,120,120,120,120,120,120,120,120,120,120,784,120,120,\n785,785,785,785,785,785,785,785,785,785,785,785,785,785,785,785,\n785,785,785,785,785,785,785,785,785,120,120,120,120,120,120,120,\n786,786,786,786,786,786,786,786,786,786,120,120,120,120,120,120,\n\n/* block 168 */\n787,787,787,788,788,788,788,788,788,788,788,788,788,788,788,788,\n788,788,788,788,788,788,788,788,788,788,788,788,788,788,788,788,\n788,788,788,788,788,788,788,787,787,787,787,787,789,787,787,787,\n787,787,787,787,787,120,790,790,790,790,790,790,790,790,790,790,\n791,791,791,791,788,789,789,788,120,120,120,120,120,120,120,120,\n792,792,792,792,792,792,792,792,792,792,792,792,792,792,792,792,\n792,792,792,792,792,792,792,792,792,792,792,792,792,792,792,792,\n792,792,792,793,794,794,792,120,120,120,120,120,120,120,120,120,\n\n/* block 169 */\n795,795,796,797,797,797,797,797,797,797,797,797,797,797,797,797,\n797,797,797,797,797,797,797,797,797,797,797,797,797,797,797,797,\n797,797,797,797,797,797,797,797,797,797,797,797,797,797,797,797,\n797,797,797,796,796,796,795,795,795,795,795,795,795,795,795,796,\n796,797,798,798,797,799,799,799,799,795,795,795,795,799,796,795,\n800,800,800,800,800,800,800,800,800,800,797,799,797,799,799,799,\n120,801,801,801,801,801,801,801,801,801,801,801,801,801,801,801,\n801,801,801,801,801,120,120,120,120,120,120,120,120,120,120,120,\n\n/* block 170 */\n802,802,802,802,802,802,802,802,802,802,802,802,802,802,802,802,\n802,802,120,802,802,802,802,802,802,802,802,802,802,802,802,802,\n802,802,802,802,802,802,802,802,802,802,802,802,803,803,803,804,\n804,804,803,803,804,803,804,804,805,805,805,805,805,805,804,120,\n120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,\n120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,\n120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,\n120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,\n\n/* block 171 */\n806,806,806,806,806,806,806,120,806,120,806,806,806,806,120,806,\n806,806,806,806,806,806,806,806,806,806,806,806,806,806,120,806,\n806,806,806,806,806,806,806,806,806,807,120,120,120,120,120,120,\n808,808,808,808,808,808,808,808,808,808,808,808,808,808,808,808,\n808,808,808,808,808,808,808,808,808,808,808,808,808,808,808,808,\n808,808,808,808,808,808,808,808,808,808,808,808,808,808,808,809,\n810,810,810,809,809,809,809,809,809,809,809,120,120,120,120,120,\n811,811,811,811,811,811,811,811,811,811,120,120,120,120,120,120,\n\n/* block 172 */\n812,813,814,815,120,816,816,816,816,816,816,816,816,120,120,816,\n816,120,120,816,816,816,816,816,816,816,816,816,816,816,816,816,\n816,816,816,816,816,816,816,816,816,120,816,816,816,816,816,816,\n816,120,816,816,120,816,816,816,816,816,120,817,813,816,818,814,\n812,814,814,814,814,120,120,814,814,120,120,814,814,814,120,120,\n816,120,120,120,120,120,120,818,120,120,120,120,120,816,816,816,\n816,816,814,814,120,120,812,812,812,812,812,812,812,120,120,120,\n812,812,812,812,812,120,120,120,120,120,120,120,120,120,120,120,\n\n/* block 173 */\n819,819,819,819,819,819,819,819,819,819,819,819,819,819,819,819,\n819,819,819,819,819,819,819,819,819,819,819,819,819,819,819,819,\n819,819,819,819,819,819,819,819,819,819,819,819,819,819,819,819,\n819,819,819,819,819,820,820,820,821,821,821,821,821,821,821,821,\n820,820,821,821,821,820,821,819,819,819,819,822,822,822,822,822,\n823,823,823,823,823,823,823,823,823,823,822,822,120,822,821,819,\n819,819,120,120,120,120,120,120,120,120,120,120,120,120,120,120,\n120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,\n\n/* block 174 */\n824,824,824,824,824,824,824,824,824,824,824,824,824,824,824,824,\n824,824,824,824,824,824,824,824,824,824,824,824,824,824,824,824,\n824,824,824,824,824,824,824,824,824,824,824,824,824,824,824,824,\n825,826,826,827,827,827,827,827,827,826,827,826,826,825,826,827,\n827,826,827,827,824,824,828,824,120,120,120,120,120,120,120,120,\n829,829,829,829,829,829,829,829,829,829,120,120,120,120,120,120,\n120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,\n120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,\n\n/* block 175 */\n830,830,830,830,830,830,830,830,830,830,830,830,830,830,830,830,\n830,830,830,830,830,830,830,830,830,830,830,830,830,830,830,830,\n830,830,830,830,830,830,830,830,830,830,830,830,830,830,830,831,\n832,832,833,833,833,833,120,120,832,832,832,832,833,833,832,833,\n833,834,834,834,834,834,834,834,834,834,834,834,834,834,834,834,\n834,834,834,834,834,834,834,834,830,830,830,830,833,833,120,120,\n120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,\n120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,\n\n/* block 176 */\n835,835,835,835,835,835,835,835,835,835,835,835,835,835,835,835,\n835,835,835,835,835,835,835,835,835,835,835,835,835,835,835,835,\n835,835,835,835,835,835,835,835,835,835,835,835,835,835,835,835,\n836,836,836,837,837,837,837,837,837,837,837,836,836,837,836,837,\n837,838,838,838,835,120,120,120,120,120,120,120,120,120,120,120,\n839,839,839,839,839,839,839,839,839,839,120,120,120,120,120,120,\n394,394,394,394,394,394,394,394,394,394,394,394,394,120,120,120,\n120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,\n\n/* block 177 */\n840,840,840,840,840,840,840,840,840,840,840,840,840,840,840,840,\n840,840,840,840,840,840,840,840,840,840,840,840,840,840,840,840,\n840,840,840,840,840,840,840,840,840,840,840,841,842,841,842,842,\n841,841,841,841,841,841,842,841,840,120,120,120,120,120,120,120,\n843,843,843,843,843,843,843,843,843,843,120,120,120,120,120,120,\n120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,\n120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,\n120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,\n\n/* block 178 */\n844,844,844,844,844,844,844,844,844,844,844,844,844,844,844,844,\n844,844,844,844,844,844,844,844,844,844,844,120,120,845,845,845,\n846,846,845,845,845,845,846,845,845,845,845,845,120,120,120,120,\n847,847,847,847,847,847,847,847,847,847,848,848,849,849,849,850,\n120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,\n120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,\n120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,\n120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,\n\n/* block 179 */\n851,851,851,851,851,851,851,851,851,851,851,851,851,851,851,851,\n851,851,851,851,851,851,851,851,851,851,851,851,851,851,851,851,\n851,851,851,851,851,851,851,851,851,851,851,851,852,852,852,853,\n853,853,853,853,853,853,853,853,852,853,853,854,120,120,120,120,\n120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,\n120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,\n120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,\n120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,\n\n/* block 180 */\n120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,\n120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,\n855,855,855,855,855,855,855,855,855,855,855,855,855,855,855,855,\n855,855,855,855,855,855,855,855,855,855,855,855,855,855,855,855,\n856,856,856,856,856,856,856,856,856,856,856,856,856,856,856,856,\n856,856,856,856,856,856,856,856,856,856,856,856,856,856,856,856,\n857,857,857,857,857,857,857,857,857,857,858,858,858,858,858,858,\n858,858,858,120,120,120,120,120,120,120,120,120,120,120,120,859,\n\n/* block 181 */\n860,860,860,860,860,860,860,120,120,860,120,120,860,860,860,860,\n860,860,860,860,120,860,860,120,860,860,860,860,860,860,860,860,\n860,860,860,860,860,860,860,860,860,860,860,860,860,860,860,860,\n861,862,862,862,862,862,120,862,862,120,120,863,863,862,863,864,\n862,864,862,863,865,865,865,120,120,120,120,120,120,120,120,120,\n866,866,866,866,866,866,866,866,866,866,120,120,120,120,120,120,\n120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,\n120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,\n\n/* block 182 */\n120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,\n120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,\n867,867,867,867,867,867,867,867,120,120,867,867,867,867,867,867,\n867,867,867,867,867,867,867,867,867,867,867,867,867,867,867,867,\n867,867,867,867,867,867,867,867,867,867,867,867,867,867,867,867,\n867,868,868,868,869,869,869,869,120,120,869,869,868,868,868,868,\n869,867,870,867,868,120,120,120,120,120,120,120,120,120,120,120,\n120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,\n\n/* block 183 */\n871,872,872,872,872,872,872,872,872,872,872,871,871,871,871,871,\n871,871,871,871,871,871,871,871,871,871,871,871,871,871,871,871,\n871,871,871,871,871,871,871,871,871,871,871,871,871,871,871,871,\n871,871,871,872,872,872,872,872,872,873,874,872,872,872,872,875,\n875,875,875,875,875,875,875,872,120,120,120,120,120,120,120,120,\n876,877,877,877,877,877,877,878,878,877,877,877,876,876,876,876,\n876,876,876,876,876,876,876,876,876,876,876,876,876,876,876,876,\n876,876,876,876,876,876,876,876,876,876,876,876,876,876,876,876,\n\n/* block 184 */\n876,876,876,876,879,879,879,879,879,879,877,877,877,877,877,877,\n877,877,877,877,877,877,877,878,877,877,880,880,880,876,880,880,\n880,880,880,120,120,120,120,120,120,120,120,120,120,120,120,120,\n120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,\n881,881,881,881,881,881,881,881,881,881,881,881,881,881,881,881,\n881,881,881,881,881,881,881,881,881,881,881,881,881,881,881,881,\n881,881,881,881,881,881,881,881,881,881,881,881,881,881,881,881,\n881,881,881,881,881,881,881,881,881,120,120,120,120,120,120,120,\n\n/* block 185 */\n882,882,882,882,882,882,882,882,882,120,882,882,882,882,882,882,\n882,882,882,882,882,882,882,882,882,882,882,882,882,882,882,882,\n882,882,882,882,882,882,882,882,882,882,882,882,882,882,882,883,\n884,884,884,884,884,884,884,120,884,884,884,884,884,884,883,884,\n882,885,885,885,885,885,120,120,120,120,120,120,120,120,120,120,\n886,886,886,886,886,886,886,886,886,886,887,887,887,887,887,887,\n887,887,887,887,887,887,887,887,887,887,887,887,887,120,120,120,\n888,888,889,889,889,889,889,889,889,889,889,889,889,889,889,889,\n\n/* block 186 */\n889,889,889,889,889,889,889,889,889,889,889,889,889,889,889,889,\n120,120,890,890,890,890,890,890,890,890,890,890,890,890,890,890,\n890,890,890,890,890,890,890,890,120,891,890,890,890,890,890,890,\n890,891,890,890,891,890,890,120,120,120,120,120,120,120,120,120,\n120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,\n120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,\n120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,\n120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,\n\n/* block 187 */\n892,892,892,892,892,892,892,120,892,892,120,892,892,892,892,892,\n892,892,892,892,892,892,892,892,892,892,892,892,892,892,892,892,\n892,892,892,892,892,892,892,892,892,892,892,892,892,892,892,892,\n892,893,893,893,893,893,893,120,120,120,893,120,893,893,120,893,\n893,893,893,893,893,893,894,893,120,120,120,120,120,120,120,120,\n895,895,895,895,895,895,895,895,895,895,120,120,120,120,120,120,\n896,896,896,896,896,896,120,896,896,120,896,896,896,896,896,896,\n896,896,896,896,896,896,896,896,896,896,896,896,896,896,896,896,\n\n/* block 188 */\n896,896,896,896,896,896,896,896,896,896,897,897,897,897,897,120,\n898,898,120,897,897,898,897,898,896,120,120,120,120,120,120,120,\n899,899,899,899,899,899,899,899,899,899,120,120,120,120,120,120,\n120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,\n120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,\n120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,\n120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,\n120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,\n\n/* block 189 */\n120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,\n120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,\n120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,\n120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,\n120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,\n120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,\n900,900,900,900,900,900,900,900,900,900,900,900,900,900,900,900,\n900,900,900,901,901,902,902,903,903,120,120,120,120,120,120,120,\n\n/* block 190 */\n120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,\n120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,\n120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,\n590,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,\n904,904,904,904,904,904,904,904,904,904,904,904,904,904,904,904,\n293,293,904,293,904,295,295,295,295,295,295,295,295,296,296,296,\n296,295,295,295,295,295,295,295,295,295,295,295,295,295,295,295,\n295,295,120,120,120,120,120,120,120,120,120,120,120,120,120,905,\n\n/* block 191 */\n906,906,906,906,906,906,906,906,906,906,906,906,906,906,906,906,\n906,906,906,906,906,906,906,906,906,906,906,906,906,906,906,906,\n906,906,906,906,906,906,906,906,906,906,906,906,906,906,906,906,\n906,906,906,906,906,906,906,906,906,906,906,906,906,906,906,906,\n906,906,906,906,906,906,906,906,906,906,906,906,906,906,906,906,\n906,906,906,906,906,906,906,906,906,906,906,906,906,906,906,906,\n906,906,906,906,906,906,906,906,906,906,906,906,906,906,906,906,\n906,906,906,906,906,906,906,906,906,906,906,906,906,906,906,906,\n\n/* block 192 */\n906,906,906,906,906,906,906,906,906,906,906,906,906,906,906,906,\n906,906,906,906,906,906,906,906,906,906,120,120,120,120,120,120,\n120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,\n120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,\n120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,\n120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,\n120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,\n120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,\n\n/* block 193 */\n907,907,907,907,907,907,907,907,907,907,907,907,907,907,907,907,\n907,907,907,907,907,907,907,907,907,907,907,907,907,907,907,907,\n907,907,907,907,907,907,907,907,907,907,907,907,907,907,907,907,\n907,907,907,907,907,907,907,907,907,907,907,907,907,907,907,907,\n907,907,907,907,907,907,907,907,907,907,907,907,907,907,907,907,\n907,907,907,907,907,907,907,907,907,907,907,907,907,907,907,907,\n907,907,907,907,907,907,907,907,907,907,907,907,907,907,907,120,\n908,908,908,908,908,120,120,120,120,120,120,120,120,120,120,120,\n\n/* block 194 */\n906,906,906,906,906,906,906,906,906,906,906,906,906,906,906,906,\n906,906,906,906,906,906,906,906,906,906,906,906,906,906,906,906,\n906,906,906,906,906,906,906,906,906,906,906,906,906,906,906,906,\n906,906,906,906,906,906,906,906,906,906,906,906,906,906,906,906,\n906,906,906,906,120,120,120,120,120,120,120,120,120,120,120,120,\n120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,\n120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,\n120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,\n\n/* block 195 */\n909,909,909,909,909,909,909,909,909,909,909,909,909,909,909,909,\n909,909,909,909,909,909,909,909,909,909,909,909,909,909,909,909,\n909,909,909,909,909,909,909,909,909,909,909,909,909,909,909,909,\n909,909,909,909,909,909,909,909,909,909,909,909,909,909,909,909,\n909,909,909,909,909,909,909,909,909,909,909,909,909,909,909,909,\n909,909,909,909,909,909,909,909,909,909,909,909,909,909,909,909,\n909,909,909,909,909,909,909,909,909,909,909,909,909,909,909,909,\n909,909,909,909,909,909,909,909,909,909,909,909,909,909,909,909,\n\n/* block 196 */\n909,909,909,909,909,909,909,909,909,909,909,909,909,909,909,909,\n909,909,909,909,909,909,909,909,909,909,909,909,909,909,909,909,\n909,909,909,909,909,909,909,909,909,909,909,909,909,909,909,120,\n910,910,910,910,910,910,910,910,910,120,120,120,120,120,120,120,\n120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,\n120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,\n120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,\n120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,\n\n/* block 197 */\n911,911,911,911,911,911,911,911,911,911,911,911,911,911,911,911,\n911,911,911,911,911,911,911,911,911,911,911,911,911,911,911,911,\n911,911,911,911,911,911,911,911,911,911,911,911,911,911,911,911,\n911,911,911,911,911,911,911,911,911,911,911,911,911,911,911,911,\n911,911,911,911,911,911,911,911,911,911,911,911,911,911,911,911,\n911,911,911,911,911,911,911,911,911,911,911,911,911,911,911,911,\n911,911,911,911,911,911,911,911,911,911,911,911,911,911,911,911,\n911,911,911,911,911,911,911,911,911,911,911,911,911,911,911,911,\n\n/* block 198 */\n911,911,911,911,911,911,911,911,911,911,911,911,911,911,911,911,\n911,911,911,911,911,911,911,911,911,911,911,911,911,911,911,911,\n911,911,911,911,911,911,911,911,911,911,911,911,911,911,911,911,\n911,911,911,911,911,911,911,911,911,911,911,911,911,911,911,911,\n911,911,911,911,911,911,911,120,120,120,120,120,120,120,120,120,\n120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,\n120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,\n120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,\n\n/* block 199 */\n601,601,601,601,601,601,601,601,601,601,601,601,601,601,601,601,\n601,601,601,601,601,601,601,601,601,601,601,601,601,601,601,601,\n601,601,601,601,601,601,601,601,601,601,601,601,601,601,601,601,\n601,601,601,601,601,601,601,601,601,601,601,601,601,601,601,601,\n601,601,601,601,601,601,601,601,601,601,601,601,601,601,601,601,\n601,601,601,601,601,601,601,601,601,601,601,601,601,601,601,601,\n601,601,601,601,601,601,601,601,601,601,601,601,601,601,601,601,\n601,601,601,601,601,601,601,601,601,601,601,601,601,601,601,601,\n\n/* block 200 */\n601,601,601,601,601,601,601,601,601,601,601,601,601,601,601,601,\n601,601,601,601,601,601,601,601,601,601,601,601,601,601,601,601,\n601,601,601,601,601,601,601,601,601,601,601,601,601,601,601,601,\n601,601,601,601,601,601,601,601,601,120,120,120,120,120,120,120,\n912,912,912,912,912,912,912,912,912,912,912,912,912,912,912,912,\n912,912,912,912,912,912,912,912,912,912,912,912,912,912,912,120,\n913,913,913,913,913,913,913,913,913,913,120,120,120,120,914,914,\n120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,\n\n/* block 201 */\n120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,\n120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,\n120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,\n120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,\n120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,\n915,915,915,915,915,915,915,915,915,915,915,915,915,915,915,915,\n915,915,915,915,915,915,915,915,915,915,915,915,915,915,120,120,\n916,916,916,916,916,917,120,120,120,120,120,120,120,120,120,120,\n\n/* block 202 */\n918,918,918,918,918,918,918,918,918,918,918,918,918,918,918,918,\n918,918,918,918,918,918,918,918,918,918,918,918,918,918,918,918,\n918,918,918,918,918,918,918,918,918,918,918,918,918,918,918,918,\n919,919,919,919,919,919,919,920,920,920,920,920,921,921,921,921,\n922,922,922,922,920,921,120,120,120,120,120,120,120,120,120,120,\n923,923,923,923,923,923,923,923,923,923,120,924,924,924,924,924,\n924,924,120,918,918,918,918,918,918,918,918,918,918,918,918,918,\n918,918,918,918,918,918,918,918,120,120,120,120,120,918,918,918,\n\n/* block 203 */\n918,918,918,918,918,918,918,918,918,918,918,918,918,918,918,918,\n120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,\n120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,\n120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,\n120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,\n120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,\n120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,\n120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,\n\n/* block 204 */\n120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,\n120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,\n120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,\n120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,\n925,925,925,925,925,925,925,925,925,925,925,925,925,925,925,925,\n925,925,925,925,925,925,925,925,925,925,925,925,925,925,925,925,\n926,926,926,926,926,926,926,926,926,926,926,926,926,926,926,926,\n926,926,926,926,926,926,926,926,926,926,926,926,926,926,926,926,\n\n/* block 205 */\n927,927,927,927,927,927,927,927,927,927,927,927,927,927,927,927,\n927,927,927,927,927,927,927,928,928,928,928,120,120,120,120,120,\n120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,\n120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,\n120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,\n120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,\n120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,\n120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,\n\n/* block 206 */\n929,929,929,929,929,929,929,929,929,929,929,929,929,929,929,929,\n929,929,929,929,929,929,929,929,929,929,929,929,929,929,929,929,\n929,929,929,929,929,929,929,929,929,929,929,929,929,929,929,929,\n929,929,929,929,929,929,929,929,929,929,929,929,929,929,929,929,\n929,929,929,929,929,929,929,929,929,929,929,120,120,120,120,930,\n929,931,931,931,931,931,931,931,931,931,931,931,931,931,931,931,\n931,931,931,931,931,931,931,931,931,931,931,931,931,931,931,931,\n931,931,931,931,931,931,931,931,931,931,931,931,931,931,931,931,\n\n/* block 207 */\n931,931,931,931,931,931,931,931,120,120,120,120,120,120,120,930,\n930,930,930,932,932,932,932,932,932,932,932,932,932,932,932,932,\n120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,\n120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,\n120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,\n120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,\n933,934,  5,111,935,120,120,120,120,120,120,120,120,120,120,120,\n936,936,120,120,120,120,120,120,120,120,120,120,120,120,120,120,\n\n/* block 208 */\n937,937,937,937,937,937,937,937,937,937,937,937,937,937,937,937,\n937,937,937,937,937,937,937,937,937,937,937,937,937,937,937,937,\n937,937,937,937,937,937,937,937,937,937,937,937,937,937,937,937,\n937,937,937,937,937,937,937,937,937,937,937,937,937,937,937,937,\n937,937,937,937,937,937,937,937,937,937,937,937,937,937,937,937,\n937,937,937,937,937,937,937,937,937,937,937,937,937,937,937,937,\n937,937,937,937,937,937,937,937,937,937,937,937,937,937,937,937,\n937,937,937,937,937,937,937,937,937,937,937,937,937,937,937,937,\n\n/* block 209 */\n937,937,937,937,937,937,937,937,937,937,937,937,937,937,937,937,\n937,937,937,937,937,937,937,937,937,937,937,937,937,937,937,937,\n937,937,937,937,937,937,937,937,937,937,937,937,937,937,937,937,\n937,937,937,937,937,937,937,937,937,937,937,937,937,937,937,937,\n937,937,937,937,937,937,937,937,937,937,937,937,937,937,937,937,\n937,937,937,937,937,937,937,937,937,937,937,937,937,937,937,937,\n937,937,937,937,937,937,937,937,937,937,937,937,937,937,937,937,\n937,937,937,937,937,937,937,937,120,120,120,120,120,120,120,120,\n\n/* block 210 */\n938,938,938,938,938,938,938,938,938,938,938,938,938,938,938,938,\n938,938,938,938,938,938,938,938,938,938,938,938,938,938,938,938,\n938,938,938,938,938,938,938,938,938,938,938,938,938,938,938,938,\n938,938,938,938,938,938,938,938,938,938,938,938,938,938,938,938,\n938,938,938,938,938,938,938,938,938,938,938,938,938,938,938,938,\n938,938,938,938,938,938,938,938,938,938,938,938,938,938,938,938,\n938,938,938,938,938,938,938,938,938,938,938,938,938,938,938,938,\n938,938,938,938,938,938,938,938,938,938,938,938,938,938,938,938,\n\n/* block 211 */\n938,938,938,938,938,938,938,938,938,938,938,938,938,938,938,938,\n938,938,938,938,938,938,938,938,938,938,938,938,938,938,938,938,\n938,938,938,938,938,938,938,938,938,938,938,938,938,938,938,938,\n938,938,938,938,938,938,938,938,938,938,938,938,938,938,938,938,\n938,938,938,938,938,938,938,938,938,938,938,938,938,938,938,938,\n938,938,938,938,938,938,120,120,120,120,120,120,120,120,120,120,\n120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,\n120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,\n\n/* block 212 */\n937,937,937,937,937,937,937,937,937,120,120,120,120,120,120,120,\n120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,\n120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,\n120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,\n120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,\n120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,\n120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,\n120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,\n\n/* block 213 */\n578,573,573,573,573,573,573,573,573,573,573,573,573,573,573,573,\n573,573,573,573,573,573,573,573,573,573,573,573,573,573,573,573,\n573,573,573,573,573,573,573,573,573,573,573,573,573,573,573,573,\n573,573,573,573,573,573,573,573,573,573,573,573,573,573,573,573,\n573,573,573,573,573,573,573,573,573,573,573,573,573,573,573,573,\n573,573,573,573,573,573,573,573,573,573,573,573,573,573,573,573,\n573,573,573,573,573,573,573,573,573,573,573,573,573,573,573,573,\n573,573,573,573,573,573,573,573,573,573,573,573,573,573,573,573,\n\n/* block 214 */\n573,573,573,573,573,573,573,573,573,573,573,573,573,573,573,573,\n573,573,573,573,573,573,573,573,573,573,573,573,573,573,573,573,\n573,573,573,573,573,573,573,573,573,573,573,573,573,573,573,573,\n573,573,573,573,573,573,573,573,573,573,573,573,573,573,573,573,\n573,573,573,573,573,573,573,573,573,573,573,573,573,573,573,573,\n573,573,573,573,573,573,573,573,573,573,573,573,573,573,573,573,\n573,573,573,573,573,573,573,573,573,573,573,573,573,573,573,573,\n573,573,573,573,573,573,573,573,573,573,573,573,573,573,573,573,\n\n/* block 215 */\n573,573,573,573,573,573,573,573,573,573,573,573,573,573,573,573,\n573,573,573,573,573,573,573,573,573,573,573,573,573,573,573,120,\n120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,\n120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,\n120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,\n573,573,573,120,120,120,120,120,120,120,120,120,120,120,120,120,\n120,120,120,120,578,578,578,578,120,120,120,120,120,120,120,120,\n939,939,939,939,939,939,939,939,939,939,939,939,939,939,939,939,\n\n/* block 216 */\n939,939,939,939,939,939,939,939,939,939,939,939,939,939,939,939,\n939,939,939,939,939,939,939,939,939,939,939,939,939,939,939,939,\n939,939,939,939,939,939,939,939,939,939,939,939,939,939,939,939,\n939,939,939,939,939,939,939,939,939,939,939,939,939,939,939,939,\n939,939,939,939,939,939,939,939,939,939,939,939,939,939,939,939,\n939,939,939,939,939,939,939,939,939,939,939,939,939,939,939,939,\n939,939,939,939,939,939,939,939,939,939,939,939,939,939,939,939,\n939,939,939,939,939,939,939,939,939,939,939,939,939,939,939,939,\n\n/* block 217 */\n939,939,939,939,939,939,939,939,939,939,939,939,939,939,939,939,\n939,939,939,939,939,939,939,939,939,939,939,939,939,939,939,939,\n939,939,939,939,939,939,939,939,939,939,939,939,939,939,939,939,\n939,939,939,939,939,939,939,939,939,939,939,939,939,939,939,939,\n939,939,939,939,939,939,939,939,939,939,939,939,939,939,939,939,\n939,939,939,939,939,939,939,939,939,939,939,939,939,939,939,939,\n939,939,939,939,939,939,939,939,939,939,939,939,939,939,939,939,\n939,939,939,939,939,939,939,939,939,939,939,939,120,120,120,120,\n\n/* block 218 */\n940,940,940,940,940,940,940,940,940,940,940,940,940,940,940,940,\n940,940,940,940,940,940,940,940,940,940,940,940,940,940,940,940,\n940,940,940,940,940,940,940,940,940,940,940,940,940,940,940,940,\n940,940,940,940,940,940,940,940,940,940,940,940,940,940,940,940,\n940,940,940,940,940,940,940,940,940,940,940,940,940,940,940,940,\n940,940,940,940,940,940,940,940,940,940,940,940,940,940,940,940,\n940,940,940,940,940,940,940,940,940,940,940,120,120,120,120,120,\n940,940,940,940,940,940,940,940,940,940,940,940,940,120,120,120,\n\n/* block 219 */\n940,940,940,940,940,940,940,940,940,120,120,120,120,120,120,120,\n940,940,940,940,940,940,940,940,940,940,120,120,941,942,942,943,\n944,944,944,944,120,120,120,120,120,120,120,120,120,120,120,120,\n120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,\n120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,\n120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,\n120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,\n120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,\n\n/* block 220 */\n 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20,\n 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20,\n 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20,\n 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20,\n 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20,\n 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20,\n 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20,\n 20, 20, 20, 20, 20, 20,120,120,120,120,120,120,120,120,120,120,\n\n/* block 221 */\n 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20,\n 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20,\n 20, 20, 20, 20, 20, 20, 20,120,120, 20, 20, 20, 20, 20, 20, 20,\n 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20,\n 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20,\n 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20,\n 20, 20, 20, 20, 20,945,946,113,113,113, 20, 20, 20,946,945,945,\n945,945,945, 24, 24, 24, 24, 24, 24, 24, 24,113,113,113,113,113,\n\n/* block 222 */\n113,113,113, 20, 20,113,113,113,113,113,113,113, 20, 20, 20, 20,\n 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20,\n 20, 20, 20, 20, 20, 20, 20, 20, 20, 20,113,113,113,113, 20, 20,\n 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20,\n 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20,\n 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20,\n 20, 20, 20, 20, 20, 20, 20, 20, 20,120,120,120,120,120,120,120,\n120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,\n\n/* block 223 */\n685,685,685,685,685,685,685,685,685,685,685,685,685,685,685,685,\n685,685,685,685,685,685,685,685,685,685,685,685,685,685,685,685,\n685,685,685,685,685,685,685,685,685,685,685,685,685,685,685,685,\n685,685,685,685,685,685,685,685,685,685,685,685,685,685,685,685,\n685,685,947,947,947,685,120,120,120,120,120,120,120,120,120,120,\n120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,\n120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,\n120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,\n\n/* block 224 */\n120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,\n120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,\n120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,\n120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,\n120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,\n120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,\n 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25,\n 25, 25, 25, 25,120,120,120,120,120,120,120,120,120,120,120,120,\n\n/* block 225 */\n 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20,\n 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20,\n 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20,\n 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20,\n 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20,\n 20, 20, 20, 20, 20, 20, 20,120,120,120,120,120,120,120,120,120,\n582,582,582,582,582,582,582,582,582,582,582,582,582,582,582,582,\n582,582, 25, 25, 25, 25, 25, 25, 25,120,120,120,120,120,120,120,\n\n/* block 226 */\n513,513,513,513,513,513,513,513,513,513,513,513,513,513,513,513,\n513,513,513,513,513,513,513,513,513,513,514,514,514,514,514,514,\n514,514,514,514,514,514,514,514,514,514,514,514,514,514,514,514,\n514,514,514,514,513,513,513,513,513,513,513,513,513,513,513,513,\n513,513,513,513,513,513,513,513,513,513,513,513,513,513,514,514,\n514,514,514,514,514,120,514,514,514,514,514,514,514,514,514,514,\n514,514,514,514,514,514,514,514,513,513,513,513,513,513,513,513,\n513,513,513,513,513,513,513,513,513,513,513,513,513,513,513,513,\n\n/* block 227 */\n513,513,514,514,514,514,514,514,514,514,514,514,514,514,514,514,\n514,514,514,514,514,514,514,514,514,514,514,514,513,120,513,513,\n120,120,513,120,120,513,513,120,120,513,513,513,513,120,513,513,\n513,513,513,513,513,513,514,514,514,514,120,514,120,514,514,514,\n514,514,514,514,120,514,514,514,514,514,514,514,514,514,514,514,\n513,513,513,513,513,513,513,513,513,513,513,513,513,513,513,513,\n513,513,513,513,513,513,513,513,513,513,514,514,514,514,514,514,\n514,514,514,514,514,514,514,514,514,514,514,514,514,514,514,514,\n\n/* block 228 */\n514,514,514,514,513,513,120,513,513,513,513,120,120,513,513,513,\n513,513,513,513,513,120,513,513,513,513,513,513,513,120,514,514,\n514,514,514,514,514,514,514,514,514,514,514,514,514,514,514,514,\n514,514,514,514,514,514,514,514,513,513,120,513,513,513,513,120,\n513,513,513,513,513,120,513,120,120,120,513,513,513,513,513,513,\n513,120,514,514,514,514,514,514,514,514,514,514,514,514,514,514,\n514,514,514,514,514,514,514,514,514,514,514,514,513,513,513,513,\n513,513,513,513,513,513,513,513,513,513,513,513,513,513,513,513,\n\n/* block 229 */\n513,513,513,513,513,513,514,514,514,514,514,514,514,514,514,514,\n514,514,514,514,514,514,514,514,514,514,514,514,514,514,514,514,\n513,513,513,513,513,513,513,513,513,513,513,513,513,513,513,513,\n513,513,513,513,513,513,513,513,513,513,514,514,514,514,514,514,\n514,514,514,514,514,514,514,514,514,514,514,514,514,514,514,514,\n514,514,514,514,513,513,513,513,513,513,513,513,513,513,513,513,\n513,513,513,513,513,513,513,513,513,513,513,513,513,513,514,514,\n514,514,514,514,514,514,514,514,514,514,514,514,514,514,514,514,\n\n/* block 230 */\n514,514,514,514,514,514,514,514,513,513,513,513,513,513,513,513,\n513,513,513,513,513,513,513,513,513,513,513,513,513,513,513,513,\n513,513,514,514,514,514,514,514,514,514,514,514,514,514,514,514,\n514,514,514,514,514,514,514,514,514,514,514,514,513,513,513,513,\n513,513,513,513,513,513,513,513,513,513,513,513,513,513,513,513,\n513,513,513,513,513,513,514,514,514,514,514,514,514,514,514,514,\n514,514,514,514,514,514,514,514,514,514,514,514,514,514,514,514,\n513,513,513,513,513,513,513,513,513,513,513,513,513,513,513,513,\n\n/* block 231 */\n513,513,513,513,513,513,513,513,513,513,514,514,514,514,514,514,\n514,514,514,514,514,514,514,514,514,514,514,514,514,514,514,514,\n514,514,514,514,514,514,120,120,513,513,513,513,513,513,513,513,\n513,513,513,513,513,513,513,513,513,513,513,513,513,513,513,513,\n513,  9,514,514,514,514,514,514,514,514,514,514,514,514,514,514,\n514,514,514,514,514,514,514,514,514,514,514,  9,514,514,514,514,\n514,514,513,513,513,513,513,513,513,513,513,513,513,513,513,513,\n513,513,513,513,513,513,513,513,513,513,513,  9,514,514,514,514,\n\n/* block 232 */\n514,514,514,514,514,514,514,514,514,514,514,514,514,514,514,514,\n514,514,514,514,514,  9,514,514,514,514,514,514,513,513,513,513,\n513,513,513,513,513,513,513,513,513,513,513,513,513,513,513,513,\n513,513,513,513,513,  9,514,514,514,514,514,514,514,514,514,514,\n514,514,514,514,514,514,514,514,514,514,514,514,514,514,514,  9,\n514,514,514,514,514,514,513,513,513,513,513,513,513,513,513,513,\n513,513,513,513,513,513,513,513,513,513,513,513,513,513,513,  9,\n514,514,514,514,514,514,514,514,514,514,514,514,514,514,514,514,\n\n/* block 233 */\n514,514,514,514,514,514,514,514,514,  9,514,514,514,514,514,514,\n513,513,513,513,513,513,513,513,513,513,513,513,513,513,513,513,\n513,513,513,513,513,513,513,513,513,  9,514,514,514,514,514,514,\n514,514,514,514,514,514,514,514,514,514,514,514,514,514,514,514,\n514,514,514,  9,514,514,514,514,514,514,513,514,120,120, 11, 11,\n 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,\n 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,\n 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,\n\n/* block 234 */\n948,948,948,948,948,948,948,948,948,948,948,948,948,948,948,948,\n948,948,948,948,948,948,948,948,948,948,948,948,948,948,948,948,\n948,948,948,948,948,948,948,948,948,948,948,948,948,948,948,948,\n948,948,948,948,948,948,948,948,948,948,948,948,948,948,948,948,\n948,948,948,948,948,948,948,948,948,948,948,948,948,948,948,948,\n948,948,948,948,948,948,948,948,948,948,948,948,948,948,948,948,\n948,948,948,948,948,948,948,948,948,948,948,948,948,948,948,948,\n948,948,948,948,948,948,948,948,948,948,948,948,948,948,948,948,\n\n/* block 235 */\n949,949,949,949,949,949,949,949,949,949,949,949,949,949,949,949,\n949,949,949,949,949,949,949,949,949,949,949,949,949,949,949,949,\n949,949,949,949,949,949,949,949,949,949,949,949,949,949,949,949,\n949,949,949,949,949,949,949,948,948,948,948,949,949,949,949,949,\n949,949,949,949,949,949,949,949,949,949,949,949,949,949,949,949,\n949,949,949,949,949,949,949,949,949,949,949,949,949,949,949,949,\n949,949,949,949,949,949,949,949,949,949,949,949,949,948,948,948,\n948,948,948,948,948,949,948,948,948,948,948,948,948,948,948,948,\n\n/* block 236 */\n948,948,948,948,949,948,948,950,950,950,950,950,120,120,120,120,\n120,120,120,120,120,120,120,120,120,120,120,949,949,949,949,949,\n120,949,949,949,949,949,949,949,949,949,949,949,949,949,949,949,\n120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,\n120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,\n120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,\n120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,\n120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,\n\n/* block 237 */\n951,951,951,951,951,951,951,120,951,951,951,951,951,951,951,951,\n951,951,951,951,951,951,951,951,951,120,120,951,951,951,951,951,\n951,951,120,951,951,120,951,951,951,951,951,120,120,120,120,120,\n120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,\n120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,\n120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,\n120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,\n120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,\n\n/* block 238 */\n952,952,952,952,952,952,952,952,952,952,952,952,952,952,952,952,\n952,952,952,952,952,952,952,952,952,952,952,952,952,952,952,952,\n952,952,952,952,952,952,952,952,952,952,952,952,952,120,120,120,\n953,953,953,953,953,953,953,954,954,954,954,954,954,954,120,120,\n955,955,955,955,955,955,955,955,955,955,120,120,120,120,952,956,\n120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,\n120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,\n120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,\n\n/* block 239 */\n120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,\n120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,\n120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,\n120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,\n957,957,957,957,957,957,957,957,957,957,957,957,957,957,957,957,\n957,957,957,957,957,957,957,957,957,957,957,957,957,957,957,957,\n957,957,957,957,957,957,957,957,957,957,957,957,958,958,958,958,\n959,959,959,959,959,959,959,959,959,959,120,120,120,120,120,960,\n\n/* block 240 */\n961,961,961,961,961,961,961,961,961,961,961,961,961,961,961,961,\n961,961,961,961,961,961,961,961,961,961,961,961,961,961,961,961,\n961,961,961,961,961,961,961,961,961,961,961,961,961,961,961,961,\n961,961,961,961,961,961,961,961,961,961,961,961,961,961,961,961,\n961,961,961,961,961,961,961,961,961,961,961,961,961,961,961,961,\n961,961,961,961,961,961,961,961,961,961,961,961,961,961,961,961,\n961,961,961,961,961,961,961,961,961,961,961,961,961,961,961,961,\n961,961,961,961,961,961,961,961,961,961,961,961,961,961,961,961,\n\n/* block 241 */\n961,961,961,961,961,961,961,961,961,961,961,961,961,961,961,961,\n961,961,961,961,961,961,961,961,961,961,961,961,961,961,961,961,\n961,961,961,961,961,961,961,961,961,961,961,961,961,961,961,961,\n961,961,961,961,961,961,961,961,961,961,961,961,961,961,961,961,\n961,961,961,961,961,120,120,962,962,962,962,962,962,962,962,962,\n963,963,963,963,963,963,963,120,120,120,120,120,120,120,120,120,\n120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,\n120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,\n\n/* block 242 */\n964,964,964,964,964,964,964,964,964,964,964,964,964,964,964,964,\n964,964,964,964,964,964,964,964,964,964,964,964,964,964,964,964,\n964,964,965,965,965,965,965,965,965,965,965,965,965,965,965,965,\n965,965,965,965,965,965,965,965,965,965,965,965,965,965,965,965,\n965,965,965,965,966,966,966,966,966,966,966,967,120,120,120,120,\n968,968,968,968,968,968,968,968,968,968,120,120,120,120,969,969,\n120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,\n120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,\n\n/* block 243 */\n120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,\n120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,\n120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,\n120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,\n120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,\n120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,\n120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,\n120, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25,\n\n/* block 244 */\n 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25,\n 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25,\n 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 20, 25, 25, 25,\n  6, 25, 25, 25, 25,120,120,120,120,120,120,120,120,120,120,120,\n120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,\n120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,\n120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,\n120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,\n\n/* block 245 */\n120, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25,\n 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25,\n 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 20, 25,\n 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25,120,120,\n120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,\n120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,\n120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,\n120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,\n\n/* block 246 */\n224,224,224,224,120,224,224,224,224,224,224,224,224,224,224,224,\n224,224,224,224,224,224,224,224,224,224,224,224,224,224,224,224,\n120,224,224,120,224,120,120,224,120,224,224,224,224,224,224,224,\n224,224,224,120,224,224,224,224,120,224,120,224,120,120,120,120,\n120,120,224,120,120,120,120,224,120,224,120,224,120,224,224,224,\n120,224,224,120,224,120,120,224,120,224,120,224,120,224,120,224,\n120,224,224,120,224,120,120,224,224,224,224,120,224,224,224,224,\n224,224,224,120,224,224,224,224,120,224,224,224,224,120,224,120,\n\n/* block 247 */\n224,224,224,224,224,224,224,224,224,224,120,224,224,224,224,224,\n224,224,224,224,224,224,224,224,224,224,224,224,120,120,120,120,\n120,224,224,224,120,224,224,224,224,224,120,224,224,224,224,224,\n224,224,224,224,224,224,224,224,224,224,224,224,120,120,120,120,\n120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,\n120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,\n120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,\n217,217,120,120,120,120,120,120,120,120,120,120,120,120,120,120,\n\n/* block 248 */\n 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21,\n 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21,\n 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21,970,970,970,970,\n 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21,\n 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21,\n 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21,\n 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21,\n 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21,\n\n/* block 249 */\n 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21,\n 21, 21, 21, 21,970,970,970,970,970,970,970,970,970,970,970,970,\n 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21,970,\n970, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21,\n970, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21,\n970, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21,\n 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21,\n 21, 21, 21, 21, 21, 21,970,970,970,970,970,970,970,970,970,970,\n\n/* block 250 */\n 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 21, 21, 21,\n 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20,\n 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 21,\n 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20,\n 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20,\n 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20,\n 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 21, 21, 21, 21,\n 21, 21, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 21, 21,\n\n/* block 251 */\n 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 21, 20,\n 20, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 20, 20, 20, 20, 20,\n 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 21,970,970,\n970,970,970,970,970,970,970,970,970,970,970,970,970,970,970,970,\n970,970,970,970,970,970,970,970,970,970,970,970,970,970,970,970,\n970,970,970,970,970,970,970,970,970,970,970,970,970,970,970,970,\n970,970,970,970,970,970,971,971,971,971,971,971,971,971,971,971,\n971,971,971,971,971,971,971,971,971,971,971,971,971,971,971,971,\n\n/* block 252 */\n972, 21, 21,970,970,970,970,970,970,970,970,970,970,970,970,970,\n 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 21, 20, 20, 20, 20, 20,\n 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 21,\n 20, 20, 21, 21, 21, 21, 21, 21, 21, 21, 21, 20,970,970,970,970,\n 20, 20, 20, 20, 20, 20, 20, 20, 20,970,970,970,970,970,970,970,\n584,584,970,970,970,970,970,970,970,970,970,970,970,970,970,970,\n 21, 21, 21, 21, 21, 21,970,970,970,970,970,970,970,970,970,970,\n970,970,970,970,970,970,970,970,970,970,970,970,970,970,970,970,\n\n/* block 253 */\n970,970,970,970,970,970,970,970,970,970,970,970,970,970,970,970,\n970,970,970,970,970,970,970,970,970,970,970,970,970,970,970,970,\n970,970,970,970,970,970,970,970,970,970,970,970,970,970,970,970,\n970,970,970,970,970,970,970,970,970,970,970,970,970,970,970,970,\n970,970,970,970,970,970,970,970,970,970,970,970,970,970,970,970,\n970,970,970,970,970,970,970,970,970,970,970,970,970,970,970,970,\n970,970,970,970,970,970,970,970,970,970,970,970,970,970,970,970,\n970,970,970,970,970,970,970,970,970,970,970,970,970,970,970,970,\n\n/* block 254 */\n 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21,\n 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21,\n 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21,\n 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21,\n 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21,\n 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21,\n 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21,\n 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21,\n\n/* block 255 */\n 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21,\n 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21,\n 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21,\n 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21,\n 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21,\n 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21,\n 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21,\n 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21,973,973,973,973,973,\n\n/* block 256 */\n 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21,\n 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21,\n 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21,\n 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 20, 20,\n 20, 20, 20, 20, 20, 20, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21,\n 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21,\n 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21,\n 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21,\n\n/* block 257 */\n 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21,\n 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21,\n 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21,\n 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21,\n 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21,\n 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20,\n 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20,\n 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20,\n\n/* block 258 */\n 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21,\n 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21,\n 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21,\n 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21,\n 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21,\n 21, 21, 21, 21, 21, 21, 21, 21,970,970,970,970,970,970,970,970,\n 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21,970,970,970,\n 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21,970,970,970,\n\n/* block 259 */\n 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20,\n 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20,\n 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20,\n 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20,\n 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20,\n 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20,\n 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20,\n 20, 20, 20, 20,970,970,970,970,970,970,970,970,970,970,970,970,\n\n/* block 260 */\n 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20,\n 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20,\n 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20,\n 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20,\n 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20,\n 20, 20, 20, 20, 20, 21, 21, 21, 21,970,970,970,970,970,970,970,\n 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21,970,970,970,970,\n970,970,970,970,970,970,970,970,970,970,970,970,970,970,970,970,\n\n/* block 261 */\n 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20,970,970,970,970,\n 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20,\n 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20,\n 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20,\n 20, 20, 20, 20, 20, 20, 20, 20,970,970,970,970,970,970,970,970,\n 20, 20, 20, 20, 20, 20, 20, 20, 20, 20,970,970,970,970,970,970,\n 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20,\n 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20,\n\n/* block 262 */\n 20, 20, 20, 20, 20, 20, 20, 20,970,970,970,970,970,970,970,970,\n 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20,\n 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20,970,970,\n 21, 21,970,970,970,970,970,970,970,970,970,970,970,970,970,970,\n970,970,970,970,970,970,970,970,970,970,970,970,970,970,970,970,\n970,970,970,970,970,970,970,970,970,970,970,970,970,970,970,970,\n970,970,970,970,970,970,970,970,970,970,970,970,970,970,970,970,\n970,970,970,970,970,970,970,970,970,970,970,970,970,970,970,970,\n\n/* block 263 */\n 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 21, 21, 21, 21,\n 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21,\n 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21,\n 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 20, 21, 21, 21, 21,\n 21, 21, 21, 21, 21, 21, 20, 21, 21, 21, 21, 21, 21, 21, 21, 21,\n 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21,\n 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21,\n 21, 21, 21, 21, 21, 21, 21, 21, 21,970, 21, 21, 21, 21, 21, 21,\n\n/* block 264 */\n 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21,\n 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21,\n 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21,\n 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21,\n 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21,970, 21, 21, 21,\n 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21,\n 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21,\n 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21,\n\n/* block 265 */\n 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21,\n 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21,\n 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21,\n 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21,\n 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21,\n 21, 21, 21, 21,970,970,970,970,970,970,970,970,970,970,970,970,\n 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21,970,970,\n 21, 21, 21, 21, 21,970,970,970, 21, 21, 21,970,970,970,970,970,\n\n/* block 266 */\n 21, 21, 21, 21, 21, 21, 21,970,970,970,970,970,970,970,970,970,\n 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21,\n 21, 21, 21, 21, 21, 21, 21, 21, 21,970,970,970,970,970,970,970,\n 21, 21, 21, 21, 21, 21, 21,970,970,970,970,970,970,970,970,970,\n 21, 21, 21,970,970,970,970,970,970,970,970,970,970,970,970,970,\n 21, 21, 21, 21, 21, 21, 21,970,970,970,970,970,970,970,970,970,\n970,970,970,970,970,970,970,970,970,970,970,970,970,970,970,970,\n970,970,970,970,970,970,970,970,970,970,970,970,970,970,970,970,\n\n/* block 267 */\n 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20,\n 20, 20, 20,120, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20,\n 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20,\n 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20,\n 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20,120,120,120,120,120,\n120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,\n120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,\n 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,120,120,120,120,120,120,\n\n/* block 268 */\n970,970,970,970,970,970,970,970,970,970,970,970,970,970,970,970,\n970,970,970,970,970,970,970,970,970,970,970,970,970,970,970,970,\n970,970,970,970,970,970,970,970,970,970,970,970,970,970,970,970,\n970,970,970,970,970,970,970,970,970,970,970,970,970,970,970,970,\n970,970,970,970,970,970,970,970,970,970,970,970,970,970,970,970,\n970,970,970,970,970,970,970,970,970,970,970,970,970,970,970,970,\n970,970,970,970,970,970,970,970,970,970,970,970,970,970,970,970,\n970,970,970,970,970,970,970,970,970,970,970,970,970,970,120,120,\n\n/* block 269 */\n586,586,586,586,586,586,586,586,586,586,586,586,586,586,586,586,\n586,586,586,586,586,586,586,586,586,586,586,586,586,586,586,586,\n586,586,586,586,586,586,586,586,586,586,586,586,586,586,586,586,\n586,586,586,586,586,586,586,586,586,586,586,586,586,586,586,586,\n586,586,586,586,586,586,586,586,586,586,586,586,586,586,586,586,\n586,586,586,586,586,586,586,586,586,586,586,586,586,586,120,120,\n120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,\n120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,\n\n/* block 270 */\n586,586,586,586,586,586,586,586,586,586,586,586,586,586,586,586,\n586,586,586,586,586,586,586,586,586,586,586,586,586,586,586,586,\n586,586,586,586,586,586,586,586,586,586,586,586,586,586,586,586,\n586,586,586,586,586,120,120,120,120,120,120,120,120,120,120,120,\n586,586,586,586,586,586,586,586,586,586,586,586,586,586,586,586,\n586,586,586,586,586,586,586,586,586,586,586,586,586,586,586,586,\n586,586,586,586,586,586,586,586,586,586,586,586,586,586,586,586,\n586,586,586,586,586,586,586,586,586,586,586,586,586,586,586,586,\n\n/* block 271 */\n586,586,586,586,586,586,586,586,586,586,586,586,586,586,586,586,\n586,586,586,586,586,586,586,586,586,586,586,586,586,586,120,120,\n586,586,586,586,586,586,586,586,586,586,586,586,586,586,586,586,\n586,586,586,586,586,586,586,586,586,586,586,586,586,586,586,586,\n586,586,586,586,586,586,586,586,586,586,586,586,586,586,586,586,\n586,586,586,586,586,586,586,586,586,586,586,586,586,586,586,586,\n586,586,586,586,586,586,586,586,586,586,586,586,586,586,586,586,\n586,586,586,586,586,586,586,586,586,586,586,586,586,586,586,586,\n\n/* block 272 */\n586,586,586,586,586,586,586,586,586,586,586,586,586,586,586,586,\n586,586,586,586,586,586,586,586,586,586,586,586,586,586,586,586,\n586,586,120,120,120,120,120,120,120,120,120,120,120,120,120,120,\n586,586,586,586,586,586,586,586,586,586,586,586,586,586,586,586,\n586,586,586,586,586,586,586,586,586,586,586,586,586,586,586,586,\n586,586,586,586,586,586,586,586,586,586,586,586,586,586,586,586,\n586,586,586,586,586,586,586,586,586,586,586,586,586,586,586,586,\n586,586,586,586,586,586,586,586,586,586,586,586,586,586,586,586,\n\n/* block 273 */\n586,586,586,586,586,586,586,586,586,586,586,586,586,586,586,586,\n586,586,586,586,586,586,586,586,586,586,586,586,586,586,586,586,\n586,586,586,586,586,586,586,586,586,586,586,586,586,586,586,586,\n586,586,586,586,586,586,586,586,586,586,586,586,586,586,586,586,\n586,586,586,586,586,586,586,586,586,586,586,586,586,586,586,586,\n586,586,586,586,586,586,586,586,586,586,586,586,586,586,586,586,\n586,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,\n120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,\n\n/* block 274 */\n586,586,586,586,586,586,586,586,586,586,586,586,586,586,586,586,\n586,586,586,586,586,586,586,586,586,586,586,586,586,586,120,120,\n120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,\n120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,\n120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,\n120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,\n120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,\n120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,\n\n/* block 275 */\n586,586,586,586,586,586,586,586,586,586,586,586,586,586,586,586,\n586,586,586,586,586,586,586,586,586,586,586,586,586,586,586,586,\n586,586,586,586,586,586,586,586,586,586,586,586,586,586,586,586,\n586,586,586,586,586,586,586,586,586,586,586,586,586,586,586,586,\n586,586,586,586,586,586,586,586,586,586,586,120,120,120,120,120,\n120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,\n120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,\n120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,\n\n/* block 276 */\n511, 24,511,511,511,511,511,511,511,511,511,511,511,511,511,511,\n511,511,511,511,511,511,511,511,511,511,511,511,511,511,511,511,\n974,974,974,974,974,974,974,974,974,974,974,974,974,974,974,974,\n974,974,974,974,974,974,974,974,974,974,974,974,974,974,974,974,\n974,974,974,974,974,974,974,974,974,974,974,974,974,974,974,974,\n974,974,974,974,974,974,974,974,974,974,974,974,974,974,974,974,\n974,974,974,974,974,974,974,974,974,974,974,974,974,974,974,974,\n974,974,974,974,974,974,974,974,974,974,974,974,974,974,974,974,\n\n/* block 277 */\n511,511,511,511,511,511,511,511,511,511,511,511,511,511,511,511,\n511,511,511,511,511,511,511,511,511,511,511,511,511,511,511,511,\n511,511,511,511,511,511,511,511,511,511,511,511,511,511,511,511,\n511,511,511,511,511,511,511,511,511,511,511,511,511,511,511,511,\n511,511,511,511,511,511,511,511,511,511,511,511,511,511,511,511,\n511,511,511,511,511,511,511,511,511,511,511,511,511,511,511,511,\n511,511,511,511,511,511,511,511,511,511,511,511,511,511,511,511,\n511,511,511,511,511,511,511,511,511,511,511,511,511,511,511,511,\n\n/* block 278 */\n113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,\n113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,\n113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,\n113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,\n113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,\n113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,\n113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,\n113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,\n\n/* block 279 */\n113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,\n113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,\n113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,\n113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,\n113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,\n113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,\n113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,\n511,511,511,511,511,511,511,511,511,511,511,511,511,511,511,511,\n\n/* block 280 */\n673,673,673,673,673,673,673,673,673,673,673,673,673,673,673,673,\n673,673,673,673,673,673,673,673,673,673,673,673,673,673,673,673,\n673,673,673,673,673,673,673,673,673,673,673,673,673,673,673,673,\n673,673,673,673,673,673,673,673,673,673,673,673,673,673,673,673,\n673,673,673,673,673,673,673,673,673,673,673,673,673,673,673,673,\n673,673,673,673,673,673,673,673,673,673,673,673,673,673,673,673,\n673,673,673,673,673,673,673,673,673,673,673,673,673,673,673,673,\n673,673,673,673,673,673,673,673,673,673,673,673,673,673,120,120,\n\n};\n\n#if UCD_BLOCK_SIZE != 128\n#error Please correct UCD_BLOCK_SIZE in pcre2_internal.h\n#endif\n#endif  /* SUPPORT_UNICODE */\n\n#endif  /* PCRE2_PCRE2TEST */\n/*autoconv-0001 C:\\projects\\pcre2-10.35\\src\\pcre2_ucd.c converted to UCD2*/\n/*autoconv-0011 UCD2 line: 14 config.h replaced by CONFIG.h*/\n/*autoconv-0011 UCD2 line: 17 pcre2_internal.h replaced by INTERNA2.h*/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "UCP2": {"ttr": 5124, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "\n/*************************************************\n*      Perl-Compatible Regular Expressions       *\n*************************************************/\n\n/* PCRE is a library of functions to support regular expressions whose syntax\nand semantics are as close as possible to those of the Perl 5 language.\n\n                       Written by Philip Hazel\n     Original API code Copyright (c) 1997-2012 University of Cambridge\n          New API code Copyright (c) 2016-2018 University of Cambridge\n\n-----------------------------------------------------------------------------\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n\n    * Redistributions of source code must retain the above copyright notice,\n      this list of conditions and the following disclaimer.\n\n    * Redistributions in binary form must reproduce the above copyright\n      notice, this list of conditions and the following disclaimer in the\n      documentation and/or other materials provided with the distribution.\n\n    * Neither the name of the University of Cambridge nor the names of its\n      contributors may be used to endorse or promote products derived from\n      this software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\nAND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\nIMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\nARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\nLIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\nCONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\nSUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\nINTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\nCONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\nARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\nPOSSIBILITY OF SUCH DAMAGE.\n-----------------------------------------------------------------------------\n*/\n\n\n#ifndef PCRE2_UCP_H_IDEMPOTENT_GUARD\n#define PCRE2_UCP_H_IDEMPOTENT_GUARD\n\n/* This file contains definitions of the property values that are returned by\nthe UCD access macros. New values that are added for new releases of Unicode\nshould always be at the end of each enum, for backwards compatibility.\n\nIMPORTANT: Note also that the specific numeric values of the enums have to be\nthe same as the values that are generated by the maint/MultiStage2.py script,\nwhere the equivalent property descriptive names are listed in vectors.\n\nALSO: The specific values of the first two enums are assumed for the table\ncalled catposstab in pcre2_compile.c. */\n\n/* These are the general character categories. */\n\nenum {\n  ucp_C,     /* Other */\n  ucp_L,     /* Letter */\n  ucp_M,     /* Mark */\n  ucp_N,     /* Number */\n  ucp_P,     /* Punctuation */\n  ucp_S,     /* Symbol */\n  ucp_Z      /* Separator */\n};\n\n/* These are the particular character categories. */\n\nenum {\n  ucp_Cc,    /* Control */\n  ucp_Cf,    /* Format */\n  ucp_Cn,    /* Unassigned */\n  ucp_Co,    /* Private use */\n  ucp_Cs,    /* Surrogate */\n  ucp_Ll,    /* Lower case letter */\n  ucp_Lm,    /* Modifier letter */\n  ucp_Lo,    /* Other letter */\n  ucp_Lt,    /* Title case letter */\n  ucp_Lu,    /* Upper case letter */\n  ucp_Mc,    /* Spacing mark */\n  ucp_Me,    /* Enclosing mark */\n  ucp_Mn,    /* Non-spacing mark */\n  ucp_Nd,    /* Decimal number */\n  ucp_Nl,    /* Letter number */\n  ucp_No,    /* Other number */\n  ucp_Pc,    /* Connector punctuation */\n  ucp_Pd,    /* Dash punctuation */\n  ucp_Pe,    /* Close punctuation */\n  ucp_Pf,    /* Final punctuation */\n  ucp_Pi,    /* Initial punctuation */\n  ucp_Po,    /* Other punctuation */\n  ucp_Ps,    /* Open punctuation */\n  ucp_Sc,    /* Currency symbol */\n  ucp_Sk,    /* Modifier symbol */\n  ucp_Sm,    /* Mathematical symbol */\n  ucp_So,    /* Other symbol */\n  ucp_Zl,    /* Line separator */\n  ucp_Zp,    /* Paragraph separator */\n  ucp_Zs     /* Space separator */\n};\n\n/* These are grapheme break properties. The Extended Pictographic property\ncomes from the emoji-data.txt file. */\n\nenum {\n  ucp_gbCR,                    /*  0 */\n  ucp_gbLF,                    /*  1 */\n  ucp_gbControl,               /*  2 */\n  ucp_gbExtend,                /*  3 */\n  ucp_gbPrepend,               /*  4 */\n  ucp_gbSpacingMark,           /*  5 */\n  ucp_gbL,                     /*  6 Hangul syllable type L */\n  ucp_gbV,                     /*  7 Hangul syllable type V */\n  ucp_gbT,                     /*  8 Hangul syllable type T */\n  ucp_gbLV,                    /*  9 Hangul syllable type LV */\n  ucp_gbLVT,                   /* 10 Hangul syllable type LVT */\n  ucp_gbRegionalIndicator,     /* 11 */\n  ucp_gbOther,                 /* 12 */\n  ucp_gbZWJ,                   /* 13 */\n  ucp_gbExtended_Pictographic  /* 14 */\n};\n\n/* These are the script identifications. */\n\nenum {\n  ucp_Unknown,\n  ucp_Arabic,\n  ucp_Armenian,\n  ucp_Bengali,\n  ucp_Bopomofo,\n  ucp_Braille,\n  ucp_Buginese,\n  ucp_Buhid,\n  ucp_Canadian_Aboriginal,\n  ucp_Cherokee,\n  ucp_Common,\n  ucp_Coptic,\n  ucp_Cypriot,\n  ucp_Cyrillic,\n  ucp_Deseret,\n  ucp_Devanagari,\n  ucp_Ethiopic,\n  ucp_Georgian,\n  ucp_Glagolitic,\n  ucp_Gothic,\n  ucp_Greek,\n  ucp_Gujarati,\n  ucp_Gurmukhi,\n  ucp_Han,\n  ucp_Hangul,\n  ucp_Hanunoo,\n  ucp_Hebrew,\n  ucp_Hiragana,\n  ucp_Inherited,\n  ucp_Kannada,\n  ucp_Katakana,\n  ucp_Kharoshthi,\n  ucp_Khmer,\n  ucp_Lao,\n  ucp_Latin,\n  ucp_Limbu,\n  ucp_Linear_B,\n  ucp_Malayalam,\n  ucp_Mongolian,\n  ucp_Myanmar,\n  ucp_New_Tai_Lue,\n  ucp_Ogham,\n  ucp_Old_Italic,\n  ucp_Old_Persian,\n  ucp_Oriya,\n  ucp_Osmanya,\n  ucp_Runic,\n  ucp_Shavian,\n  ucp_Sinhala,\n  ucp_Syloti_Nagri,\n  ucp_Syriac,\n  ucp_Tagalog,\n  ucp_Tagbanwa,\n  ucp_Tai_Le,\n  ucp_Tamil,\n  ucp_Telugu,\n  ucp_Thaana,\n  ucp_Thai,\n  ucp_Tibetan,\n  ucp_Tifinagh,\n  ucp_Ugaritic,\n  ucp_Yi,\n  /* New for Unicode 5.0 */\n  ucp_Balinese,\n  ucp_Cuneiform,\n  ucp_Nko,\n  ucp_Phags_Pa,\n  ucp_Phoenician,\n  /* New for Unicode 5.1 */\n  ucp_Carian,\n  ucp_Cham,\n  ucp_Kayah_Li,\n  ucp_Lepcha,\n  ucp_Lycian,\n  ucp_Lydian,\n  ucp_Ol_Chiki,\n  ucp_Rejang,\n  ucp_Saurashtra,\n  ucp_Sundanese,\n  ucp_Vai,\n  /* New for Unicode 5.2 */\n  ucp_Avestan,\n  ucp_Bamum,\n  ucp_Egyptian_Hieroglyphs,\n  ucp_Imperial_Aramaic,\n  ucp_Inscriptional_Pahlavi,\n  ucp_Inscriptional_Parthian,\n  ucp_Javanese,\n  ucp_Kaithi,\n  ucp_Lisu,\n  ucp_Meetei_Mayek,\n  ucp_Old_South_Arabian,\n  ucp_Old_Turkic,\n  ucp_Samaritan,\n  ucp_Tai_Tham,\n  ucp_Tai_Viet,\n  /* New for Unicode 6.0.0 */\n  ucp_Batak,\n  ucp_Brahmi,\n  ucp_Mandaic,\n  /* New for Unicode 6.1.0 */\n  ucp_Chakma,\n  ucp_Meroitic_Cursive,\n  ucp_Meroitic_Hieroglyphs,\n  ucp_Miao,\n  ucp_Sharada,\n  ucp_Sora_Sompeng,\n  ucp_Takri,\n  /* New for Unicode 7.0.0 */\n  ucp_Bassa_Vah,\n  ucp_Caucasian_Albanian,\n  ucp_Duployan,\n  ucp_Elbasan,\n  ucp_Grantha,\n  ucp_Khojki,\n  ucp_Khudawadi,\n  ucp_Linear_A,\n  ucp_Mahajani,\n  ucp_Manichaean,\n  ucp_Mende_Kikakui,\n  ucp_Modi,\n  ucp_Mro,\n  ucp_Nabataean,\n  ucp_Old_North_Arabian,\n  ucp_Old_Permic,\n  ucp_Pahawh_Hmong,\n  ucp_Palmyrene,\n  ucp_Psalter_Pahlavi,\n  ucp_Pau_Cin_Hau,\n  ucp_Siddham,\n  ucp_Tirhuta,\n  ucp_Warang_Citi,\n  /* New for Unicode 8.0.0 */\n  ucp_Ahom,\n  ucp_Anatolian_Hieroglyphs,\n  ucp_Hatran,\n  ucp_Multani,\n  ucp_Old_Hungarian,\n  ucp_SignWriting,\n  /* New for Unicode 10.0.0 (no update since 8.0.0) */\n  ucp_Adlam,\n  ucp_Bhaiksuki,\n  ucp_Marchen,\n  ucp_Newa,\n  ucp_Osage,\n  ucp_Tangut,\n  ucp_Masaram_Gondi,\n  ucp_Nushu,\n  ucp_Soyombo,\n  ucp_Zanabazar_Square,\n  /* New for Unicode 11.0.0 */\n  ucp_Dogra,\n  ucp_Gunjala_Gondi,\n  ucp_Hanifi_Rohingya,\n  ucp_Makasar,\n  ucp_Medefaidrin,\n  ucp_Old_Sogdian,\n  ucp_Sogdian,\n  /* New for Unicode 12.0.0 */\n  ucp_Elymaic,\n  ucp_Nandinagari,\n  ucp_Nyiakeng_Puachue_Hmong,\n  ucp_Wancho,\n  /* New for Unicode 13.0.0 */\n  ucp_Chorasmian,\n  ucp_Dives_Akuru,\n  ucp_Khitan_Small_Script,\n  ucp_Yezidi\n};\n\n#endif  /* PCRE2_UCP_H_IDEMPOTENT_GUARD */\n\n/* End of pcre2_ucp.h */\n/*autoconv-0001 C:\\projects\\pcre2-10.35\\src\\pcre2_ucp.h converted to UCP2*/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "VALIDUT2": {"ttr": 6149, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "\n/*************************************************\n*      Perl-Compatible Regular Expressions       *\n*************************************************/\n\n/* PCRE is a library of functions to support regular expressions whose syntax\nand semantics are as close as possible to those of the Perl 5 language.\n\n                       Written by Philip Hazel\n     Original API code Copyright (c) 1997-2012 University of Cambridge\n          New API code Copyright (c) 2016-2020 University of Cambridge\n\n-----------------------------------------------------------------------------\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n\n    * Redistributions of source code must retain the above copyright notice,\n      this list of conditions and the following disclaimer.\n\n    * Redistributions in binary form must reproduce the above copyright\n      notice, this list of conditions and the following disclaimer in the\n      documentation and/or other materials provided with the distribution.\n\n    * Neither the name of the University of Cambridge nor the names of its\n      contributors may be used to endorse or promote products derived from\n      this software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\nAND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\nIMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\nARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\nLIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\nCONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\nSUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\nINTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\nCONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\nARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\nPOSSIBILITY OF SUCH DAMAGE.\n-----------------------------------------------------------------------------\n*/\n\n\n/* This module contains an internal function for validating UTF character\nstrings. This file is also #included by the pcre2test program, which uses\nmacros to change names from _pcre2_xxx to xxxx, thereby avoiding name clashes\nwith the library. In this case, PCRE2_PCRE2TEST is defined. */\n\n#ifndef PCRE2_PCRE2TEST           /* We're compiling the library */\n#ifdef HAVE_CONFIG_H\n#include \"CONFIG.h\"\n#endif\n#include \"INTERNA2.h\"\n#endif /* PCRE2_PCRE2TEST */\n\n\n#ifndef SUPPORT_UNICODE\n/*************************************************\n*  Dummy function when Unicode is not supported  *\n*************************************************/\n\n/* This function should never be called when Unicode is not supported. */\n\nint\nPRIV(valid_utf)(PCRE2_SPTR string, PCRE2_SIZE length, PCRE2_SIZE *erroroffset)\n{\n(void)string;\n(void)length;\n(void)erroroffset;\nreturn 0;\n}\n#else  /* UTF is supported */\n\n\n\n/*************************************************\n*           Validate a UTF string                *\n*************************************************/\n\n/* This function is called (optionally) at the start of compile or match, to\ncheck that a supposed UTF string is actually valid. The early check means\nthat subsequent code can assume it is dealing with a valid string. The check\ncan be turned off for maximum performance, but the consequences of supplying an\ninvalid string are then undefined.\n\nArguments:\n  string       points to the string\n  length       length of string\n  errp         pointer to an error position offset variable\n\nReturns:       == 0    if the string is a valid UTF string\n               != 0    otherwise, setting the offset of the bad character\n*/\n\nint\nPRIV(valid_utf)(PCRE2_SPTR string, PCRE2_SIZE length, PCRE2_SIZE *erroroffset)\n{\nPCRE2_SPTR p;\nuint32_t c;\n\n/* ----------------- Check a UTF-8 string ----------------- */\n\n#if PCRE2_CODE_UNIT_WIDTH == 8\n\n/* Originally, this function checked according to RFC 2279, allowing for values\nin the range 0 to 0x7fffffff, up to 6 bytes long, but ensuring that they were\nin the canonical format. Once somebody had pointed out RFC 3629 to me (it\nobsoletes 2279), additional restrictions were applied. The values are now\nlimited to be between 0 and 0x0010ffff, no more than 4 bytes long, and the\nsubrange 0xd000 to 0xdfff is excluded. However, the format of 5-byte and 6-byte\ncharacters is still checked. Error returns are as follows:\n\nPCRE2_ERROR_UTF8_ERR1   Missing 1 byte at the end of the string\nPCRE2_ERROR_UTF8_ERR2   Missing 2 bytes at the end of the string\nPCRE2_ERROR_UTF8_ERR3   Missing 3 bytes at the end of the string\nPCRE2_ERROR_UTF8_ERR4   Missing 4 bytes at the end of the string\nPCRE2_ERROR_UTF8_ERR5   Missing 5 bytes at the end of the string\nPCRE2_ERROR_UTF8_ERR6   2nd-byte's two top bits are not 0x80\nPCRE2_ERROR_UTF8_ERR7   3rd-byte's two top bits are not 0x80\nPCRE2_ERROR_UTF8_ERR8   4th-byte's two top bits are not 0x80\nPCRE2_ERROR_UTF8_ERR9   5th-byte's two top bits are not 0x80\nPCRE2_ERROR_UTF8_ERR10  6th-byte's two top bits are not 0x80\nPCRE2_ERROR_UTF8_ERR11  5-byte character is not permitted by RFC 3629\nPCRE2_ERROR_UTF8_ERR12  6-byte character is not permitted by RFC 3629\nPCRE2_ERROR_UTF8_ERR13  4-byte character with value > 0x10ffff is not permitted\nPCRE2_ERROR_UTF8_ERR14  3-byte character with value 0xd800-0xdfff is not permitted\nPCRE2_ERROR_UTF8_ERR15  Overlong 2-byte sequence\nPCRE2_ERROR_UTF8_ERR16  Overlong 3-byte sequence\nPCRE2_ERROR_UTF8_ERR17  Overlong 4-byte sequence\nPCRE2_ERROR_UTF8_ERR18  Overlong 5-byte sequence (won't ever occur)\nPCRE2_ERROR_UTF8_ERR19  Overlong 6-byte sequence (won't ever occur)\nPCRE2_ERROR_UTF8_ERR20  Isolated 0x80 byte (not within UTF-8 character)\nPCRE2_ERROR_UTF8_ERR21  Byte with the illegal value 0xfe or 0xff\n*/\n\nfor (p = string; length > 0; p++)\n  {\n  uint32_t ab, d;\n\n  c = *p;\n  length--;\n\n  if (c < 128) continue;                /* ASCII character */\n\n  if (c < 0xc0)                         /* Isolated 10xx xxxx byte */\n    {\n    *erroroffset = (PCRE2_SIZE)(p - string);\n    return PCRE2_ERROR_UTF8_ERR20;\n    }\n\n  if (c >= 0xfe)                        /* Invalid 0xfe or 0xff bytes */\n    {\n    *erroroffset = (PCRE2_SIZE)(p - string);\n    return PCRE2_ERROR_UTF8_ERR21;\n    }\n\n  ab = PRIV(utf8_table4)\u00ddc & 0x3f\u00a8;     /* Number of additional bytes (1-5) */\n  if (length < ab)                      /* Missing bytes */\n    {\n    *erroroffset = (PCRE2_SIZE)(p - string);\n    switch(ab - length)\n      {\n      case 1: return PCRE2_ERROR_UTF8_ERR1;\n      case 2: return PCRE2_ERROR_UTF8_ERR2;\n      case 3: return PCRE2_ERROR_UTF8_ERR3;\n      case 4: return PCRE2_ERROR_UTF8_ERR4;\n      case 5: return PCRE2_ERROR_UTF8_ERR5;\n      }\n    }\n  length -= ab;                         /* Length remaining */\n\n  /* Check top bits in the second byte */\n\n  if (((d = *(++p)) & 0xc0) != 0x80)\n    {\n    *erroroffset = (int)(p - string) - 1;\n    return PCRE2_ERROR_UTF8_ERR6;\n    }\n\n  /* For each length, check that the remaining bytes start with the 0x80 bit\n  set and not the 0x40 bit. Then check for an overlong sequence, and for the\n  excluded range 0xd800 to 0xdfff. */\n\n  switch (ab)\n    {\n    /* 2-byte character. No further bytes to check for 0x80. Check first byte\n    for for xx00 000x (overlong sequence). */\n\n    case 1: if ((c & 0x3e) == 0)\n      {\n      *erroroffset = (int)(p - string) - 1;\n      return PCRE2_ERROR_UTF8_ERR15;\n      }\n    break;\n\n    /* 3-byte character. Check third byte for 0x80. Then check first 2 bytes\n      for 1110 0000, xx0x xxxx (overlong sequence) or\n          1110 1101, 1010 xxxx (0xd800 - 0xdfff) */\n\n    case 2:\n    if ((*(++p) & 0xc0) != 0x80)     /* Third byte */\n      {\n      *erroroffset = (int)(p - string) - 2;\n      return PCRE2_ERROR_UTF8_ERR7;\n      }\n    if (c == 0xe0 && (d & 0x20) == 0)\n      {\n      *erroroffset = (int)(p - string) - 2;\n      return PCRE2_ERROR_UTF8_ERR16;\n      }\n    if (c == 0xed && d >= 0xa0)\n      {\n      *erroroffset = (int)(p - string) - 2;\n      return PCRE2_ERROR_UTF8_ERR14;\n      }\n    break;\n\n    /* 4-byte character. Check 3rd and 4th bytes for 0x80. Then check first 2\n       bytes for for 1111 0000, xx00 xxxx (overlong sequence), then check for a\n       character greater than 0x0010ffff (f4 8f bf bf) */\n\n    case 3:\n    if ((*(++p) & 0xc0) != 0x80)     /* Third byte */\n      {\n      *erroroffset = (int)(p - string) - 2;\n      return PCRE2_ERROR_UTF8_ERR7;\n      }\n    if ((*(++p) & 0xc0) != 0x80)     /* Fourth byte */\n      {\n      *erroroffset = (int)(p - string) - 3;\n      return PCRE2_ERROR_UTF8_ERR8;\n      }\n    if (c == 0xf0 && (d & 0x30) == 0)\n      {\n      *erroroffset = (int)(p - string) - 3;\n      return PCRE2_ERROR_UTF8_ERR17;\n      }\n    if (c > 0xf4 || (c == 0xf4 && d > 0x8f))\n      {\n      *erroroffset = (int)(p - string) - 3;\n      return PCRE2_ERROR_UTF8_ERR13;\n      }\n    break;\n\n    /* 5-byte and 6-byte characters are not allowed by RFC 3629, and will be\n    rejected by the length test below. However, we do the appropriate tests\n    here so that overlong sequences get diagnosed, and also in case there is\n    ever an option for handling these larger code points. */\n\n    /* 5-byte character. Check 3rd, 4th, and 5th bytes for 0x80. Then check for\n    1111 1000, xx00 0xxx */\n\n    case 4:\n    if ((*(++p) & 0xc0) != 0x80)     /* Third byte */\n      {\n      *erroroffset = (int)(p - string) - 2;\n      return PCRE2_ERROR_UTF8_ERR7;\n      }\n    if ((*(++p) & 0xc0) != 0x80)     /* Fourth byte */\n      {\n      *erroroffset = (int)(p - string) - 3;\n      return PCRE2_ERROR_UTF8_ERR8;\n      }\n    if ((*(++p) & 0xc0) != 0x80)     /* Fifth byte */\n      {\n      *erroroffset = (int)(p - string) - 4;\n      return PCRE2_ERROR_UTF8_ERR9;\n      }\n    if (c == 0xf8 && (d & 0x38) == 0)\n      {\n      *erroroffset = (int)(p - string) - 4;\n      return PCRE2_ERROR_UTF8_ERR18;\n      }\n    break;\n\n    /* 6-byte character. Check 3rd-6th bytes for 0x80. Then check for\n    1111 1100, xx00 00xx. */\n\n    case 5:\n    if ((*(++p) & 0xc0) != 0x80)     /* Third byte */\n      {\n      *erroroffset = (int)(p - string) - 2;\n      return PCRE2_ERROR_UTF8_ERR7;\n      }\n    if ((*(++p) & 0xc0) != 0x80)     /* Fourth byte */\n      {\n      *erroroffset = (int)(p - string) - 3;\n      return PCRE2_ERROR_UTF8_ERR8;\n      }\n    if ((*(++p) & 0xc0) != 0x80)     /* Fifth byte */\n      {\n      *erroroffset = (int)(p - string) - 4;\n      return PCRE2_ERROR_UTF8_ERR9;\n      }\n    if ((*(++p) & 0xc0) != 0x80)     /* Sixth byte */\n      {\n      *erroroffset = (int)(p - string) - 5;\n      return PCRE2_ERROR_UTF8_ERR10;\n      }\n    if (c == 0xfc && (d & 0x3c) == 0)\n      {\n      *erroroffset = (int)(p - string) - 5;\n      return PCRE2_ERROR_UTF8_ERR19;\n      }\n    break;\n    }\n\n  /* Character is valid under RFC 2279, but 4-byte and 5-byte characters are\n  excluded by RFC 3629. The pointer p is currently at the last byte of the\n  character. */\n\n  if (ab > 3)\n    {\n    *erroroffset = (int)(p - string) - ab;\n    return (ab == 4)? PCRE2_ERROR_UTF8_ERR11 : PCRE2_ERROR_UTF8_ERR12;\n    }\n  }\nreturn 0;\n\n\n/* ----------------- Check a UTF-16 string ----------------- */\n\n#elif PCRE2_CODE_UNIT_WIDTH == 16\n\n/* There's not so much work, nor so many errors, for UTF-16.\nPCRE2_ERROR_UTF16_ERR1  Missing low surrogate at the end of the string\nPCRE2_ERROR_UTF16_ERR2  Invalid low surrogate\nPCRE2_ERROR_UTF16_ERR3  Isolated low surrogate\n*/\n\nfor (p = string; length > 0; p++)\n  {\n  c = *p;\n  length--;\n\n  if ((c & 0xf800) != 0xd800)\n    {\n    /* Normal UTF-16 code point. Neither high nor low surrogate. */\n    }\n  else if ((c & 0x0400) == 0)\n    {\n    /* High surrogate. Must be a followed by a low surrogate. */\n    if (length == 0)\n      {\n      *erroroffset = p - string;\n      return PCRE2_ERROR_UTF16_ERR1;\n      }\n    p++;\n    length--;\n    if ((*p & 0xfc00) != 0xdc00)\n      {\n      *erroroffset = p - string - 1;\n      return PCRE2_ERROR_UTF16_ERR2;\n      }\n    }\n  else\n    {\n    /* Isolated low surrogate. Always an error. */\n    *erroroffset = p - string;\n    return PCRE2_ERROR_UTF16_ERR3;\n    }\n  }\nreturn 0;\n\n\n\n/* ----------------- Check a UTF-32 string ----------------- */\n\n#else\n\n/* There is very little to do for a UTF-32 string.\nPCRE2_ERROR_UTF32_ERR1  Surrogate character\nPCRE2_ERROR_UTF32_ERR2  Character > 0x10ffff\n*/\n\nfor (p = string; length > 0; length--, p++)\n  {\n  c = *p;\n  if ((c & 0xfffff800u) != 0xd800u)\n    {\n    /* Normal UTF-32 code point. Neither high nor low surrogate. */\n    if (c > 0x10ffffu)\n      {\n      *erroroffset = p - string;\n      return PCRE2_ERROR_UTF32_ERR2;\n      }\n    }\n  else\n    {\n    /* A surrogate */\n    *erroroffset = p - string;\n    return PCRE2_ERROR_UTF32_ERR1;\n    }\n  }\nreturn 0;\n#endif  /* CODE_UNIT_WIDTH */\n}\n#endif  /* SUPPORT_UNICODE */\n\n/* End of pcre2_valid_utf.c */\n/*autoconv-0001 C:\\projects\\pcre2-10.35\\src\\pcre2_valid_utf.c converted to VALIDUT2*/\n/*autoconv-0011 VALIDUT2 line: 49 config.h replaced by CONFIG.h*/\n/*autoconv-0011 VALIDUT2 line: 51 pcre2_internal.h replaced by INTERNA2.h*/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "XCLASS2": {"ttr": 2824, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "\n/*************************************************\n*      Perl-Compatible Regular Expressions       *\n*************************************************/\n\n/* PCRE is a library of functions to support regular expressions whose syntax\nand semantics are as close as possible to those of the Perl 5 language.\n\n                       Written by Philip Hazel\n     Original API code Copyright (c) 1997-2012 University of Cambridge\n          New API code Copyright (c) 2016-2019 University of Cambridge\n\n-----------------------------------------------------------------------------\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n\n    * Redistributions of source code must retain the above copyright notice,\n      this list of conditions and the following disclaimer.\n\n    * Redistributions in binary form must reproduce the above copyright\n      notice, this list of conditions and the following disclaimer in the\n      documentation and/or other materials provided with the distribution.\n\n    * Neither the name of the University of Cambridge nor the names of its\n      contributors may be used to endorse or promote products derived from\n      this software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\nAND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\nIMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\nARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\nLIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\nCONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\nSUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\nINTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\nCONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\nARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\nPOSSIBILITY OF SUCH DAMAGE.\n-----------------------------------------------------------------------------\n*/\n\n/* This module contains an internal function that is used to match an extended\nclass. It is used by pcre2_auto_possessify() and by both pcre2_match() and\npcre2_def_match(). */\n\n\n#ifdef HAVE_CONFIG_H\n#include \"CONFIG.h\"\n#endif\n\n\n#include \"INTERNA2.h\"\n\n/*************************************************\n*       Match character against an XCLASS        *\n*************************************************/\n\n/* This function is called to match a character against an extended class that\nmight contain codepoints above 255 and/or Unicode properties.\n\nArguments:\n  c           the character\n  data        points to the flag code unit of the XCLASS data\n  utf         TRUE if in UTF mode\n\nReturns:      TRUE if character matches, else FALSE\n*/\n\nBOOL\nPRIV(xclass)(uint32_t c, PCRE2_SPTR data, BOOL utf)\n{\nPCRE2_UCHAR t;\nBOOL negated = (*data & XCL_NOT) != 0;\n\n#if PCRE2_CODE_UNIT_WIDTH == 8\n/* In 8 bit mode, this must always be TRUE. Help the compiler to know that. */\nutf = TRUE;\n#endif\n\n/* Code points < 256 are matched against a bitmap, if one is present. If not,\nwe still carry on, because there may be ranges that start below 256 in the\nadditional data. */\n\nif (c < 256)\n  {\n  if ((*data & XCL_HASPROP) == 0)\n    {\n    if ((*data & XCL_MAP) == 0) return negated;\n    return (((uint8_t *)(data + 1))\u00ddc/8\u00a8 & (1u << (c&7))) != 0;\n    }\n  if ((*data & XCL_MAP) != 0 &&\n    (((uint8_t *)(data + 1))\u00ddc/8\u00a8 & (1u << (c&7))) != 0)\n    return !negated; /* char found */\n  }\n\n/* First skip the bit map if present. Then match against the list of Unicode\nproperties or large chars or ranges that end with a large char. We won't ever\nencounter XCL_PROP or XCL_NOTPROP when UTF support is not compiled. */\n\nif ((*data++ & XCL_MAP) != 0) data += 32 / sizeof(PCRE2_UCHAR);\n\nwhile ((t = *data++) != XCL_END)\n  {\n  uint32_t x, y;\n  if (t == XCL_SINGLE)\n    {\n#ifdef SUPPORT_UNICODE\n    if (utf)\n      {\n      GETCHARINC(x, data); /* macro generates multiple statements */\n      }\n    else\n#endif\n    x = *data++;\n    if (c == x) return !negated;\n    }\n  else if (t == XCL_RANGE)\n    {\n#ifdef SUPPORT_UNICODE\n    if (utf)\n      {\n      GETCHARINC(x, data); /* macro generates multiple statements */\n      GETCHARINC(y, data); /* macro generates multiple statements */\n      }\n    else\n#endif\n      {\n      x = *data++;\n      y = *data++;\n      }\n    if (c >= x && c <= y) return !negated;\n    }\n\n#ifdef SUPPORT_UNICODE\n  else  /* XCL_PROP & XCL_NOTPROP */\n    {\n    const ucd_record *prop = GET_UCD(c);\n    BOOL isprop = t == XCL_PROP;\n\n    switch(*data)\n      {\n      case PT_ANY:\n      if (isprop) return !negated;\n      break;\n\n      case PT_LAMP:\n      if ((prop->chartype == ucp_Lu || prop->chartype == ucp_Ll ||\n           prop->chartype == ucp_Lt) == isprop) return !negated;\n      break;\n\n      case PT_GC:\n      if ((data\u00dd1\u00a8 == PRIV(ucp_gentype)\u00ddprop->chartype\u00a8) == isprop)\n        return !negated;\n      break;\n\n      case PT_PC:\n      if ((data\u00dd1\u00a8 == prop->chartype) == isprop) return !negated;\n      break;\n\n      case PT_SC:\n      if ((data\u00dd1\u00a8 == prop->script) == isprop) return !negated;\n      break;\n\n      case PT_ALNUM:\n      if ((PRIV(ucp_gentype)\u00ddprop->chartype\u00a8 == ucp_L ||\n           PRIV(ucp_gentype)\u00ddprop->chartype\u00a8 == ucp_N) == isprop)\n        return !negated;\n      break;\n\n      /* Perl space used to exclude VT, but from Perl 5.18 it is included,\n      which means that Perl space and POSIX space are now identical. PCRE\n      was changed at release 8.34. */\n\n      case PT_SPACE:    /* Perl space */\n      case PT_PXSPACE:  /* POSIX space */\n      switch(c)\n        {\n        HSPACE_CASES:\n        VSPACE_CASES:\n        if (isprop) return !negated;\n        break;\n\n        default:\n        if ((PRIV(ucp_gentype)\u00ddprop->chartype\u00a8 == ucp_Z) == isprop)\n          return !negated;\n        break;\n        }\n      break;\n\n      case PT_WORD:\n      if ((PRIV(ucp_gentype)\u00ddprop->chartype\u00a8 == ucp_L ||\n           PRIV(ucp_gentype)\u00ddprop->chartype\u00a8 == ucp_N || c == CHAR_UNDERSCORE)\n             == isprop)\n        return !negated;\n      break;\n\n      case PT_UCNC:\n      if (c < 0xa0)\n        {\n        if ((c == CHAR_DOLLAR_SIGN || c == CHAR_COMMERCIAL_AT ||\n             c == CHAR_GRAVE_ACCENT) == isprop)\n          return !negated;\n        }\n      else\n        {\n        if ((c < 0xd800 || c > 0xdfff) == isprop)\n          return !negated;\n        }\n      break;\n\n      /* The following three properties can occur only in an XCLASS, as there\n      is no \\p or \\P coding for them. */\n\n      /* Graphic character. Implement this as not Z (space or separator) and\n      not C (other), except for Cf (format) with a few exceptions. This seems\n      to be what Perl does. The exceptional characters are:\n\n      U+061C           Arabic Letter Mark\n      U+180E           Mongolian Vowel Separator\n      U+2066 - U+2069  Various \"isolate\"s\n      */\n\n      case PT_PXGRAPH:\n      if ((PRIV(ucp_gentype)\u00ddprop->chartype\u00a8 != ucp_Z &&\n            (PRIV(ucp_gentype)\u00ddprop->chartype\u00a8 != ucp_C ||\n              (prop->chartype == ucp_Cf &&\n                c != 0x061c && c != 0x180e && (c < 0x2066 || c > 0x2069))\n         )) == isprop)\n        return !negated;\n      break;\n\n      /* Printable character: same as graphic, with the addition of Zs, i.e.\n      not Zl and not Zp, and U+180E. */\n\n      case PT_PXPRINT:\n      if ((prop->chartype != ucp_Zl &&\n           prop->chartype != ucp_Zp &&\n            (PRIV(ucp_gentype)\u00ddprop->chartype\u00a8 != ucp_C ||\n              (prop->chartype == ucp_Cf &&\n                c != 0x061c && (c < 0x2066 || c > 0x2069))\n         )) == isprop)\n        return !negated;\n      break;\n\n      /* Punctuation: all Unicode punctuation, plus ASCII characters that\n      Unicode treats as symbols rather than punctuation, for Perl\n      compatibility (these are $+<=>\u00ac`|~). */\n\n      case PT_PXPUNCT:\n      if ((PRIV(ucp_gentype)\u00ddprop->chartype\u00a8 == ucp_P ||\n            (c < 128 && PRIV(ucp_gentype)\u00ddprop->chartype\u00a8 == ucp_S)) == isprop)\n        return !negated;\n      break;\n\n      /* This should never occur, but compilers may mutter if there is no\n      default. */\n\n      default:\n      return FALSE;\n      }\n\n    data += 2;\n    }\n#else\n  (void)utf;  /* Avoid compiler warning */\n#endif  /* SUPPORT_UNICODE */\n  }\n\nreturn negated;   /* char did not match */\n}\n\n/* End of pcre2_xclass.c */\n/*autoconv-0001 C:\\projects\\pcre2-10.35\\src\\pcre2_xclass.c converted to XCLASS2*/\n/*autoconv-0011 XCLASS2 line: 47 config.h replaced by CONFIG.h*/\n/*autoconv-0011 XCLASS2 line: 51 pcre2_internal.h replaced by INTERNA2.h*/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT939/CBT.V500.FILE939.PDS/SRCE.xmi", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT939/CBT.V500.FILE939.PDS", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}