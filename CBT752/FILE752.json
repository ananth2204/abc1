{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "SBGOLOB", "INMTNODE": "A", "INMTUID": "A", "INMFTIME": "20201220012723000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 235144, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 5600, "INMRECFM": "FB", "INMDIR": 7, "INMDSNAM": "CBT.V500.FILE752.PDS", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 235144, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 235144, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"CBT.V500.FILE752.PDS": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 5600, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3340, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "200354", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\xbe'", "DS1LSTAR": "b'\\x00\\x05\\x04'", "DS1TRBAL": "b'\\xa7\\xbe'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xa0\\x00\\x04\\x9a\\xc0\\xd8'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xa0\\x00\\x04\\x9a\\xc0\\xd8'", "b'X\\xf4\\xfd\\xd0\\x00\\x00\\x05\\x1d\\x00\\x06\\x05\\x1d\\x00\\x0b\\x00\\x06'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$$$#DATE": {"ttr": 516, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04V\\x00\\x19\\x01\\x13\\x08/\\x01\\x13\\x08/#\\x07\\x00\\x0c\\x00\\x0c\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf8\\xf6@@@'", "ispf": {"version": "04.86", "flags": 0, "createdate": "2013-03-23T00:00:00", "modifydate": "2013-03-23T23:07:19", "lines": 12, "newlines": 12, "modlines": 0, "user": "CBT-486"}, "text": "REGULAR CBT TAPE - VERSION 486    FILE:  752\n\n    ORIGINAL DSNAME:  SBGOLOB.CBT486.FILE752\n    ---------------\n                    --RECFM-LRECL-BLKSIZE-DSORG\n                      FB    80    5600    PO\n\n   PDS117I 8 MEMBERS COUNTED; CUMULATIVE SIZE IS 1,922 RECORDS\n\n\nTIME THIS PDS WAS SHIPPED:   03/23/13    23:07:19    UTC-4:00\n\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$$NOTE01": {"ttr": 518, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00U\\x01\\x07\\x05\\x8f\\x01\\x07\\x05\\x8f\\tD\\x00\"\\x00\"\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2007-02-27T00:00:00", "modifydate": "2007-02-27T09:44:55", "lines": 34, "newlines": 34, "modlines": 0, "user": "SBGOLOB"}, "text": "Subject:     Re: Profile Search REXXes\nFrom:        \"Ryerse, Robin\" <robin.ryerse@EDS.COM>\nDate:        Mon, 26 Feb 2007 09:46:43 -0500\n\nMine will dump the ____PROF and all related tables for the applid\nwithin the ISPPROF DDname. The applid is either specified (can\ninclude \"wild cards\") or is the current applid.\n\nProblem is the routine requires SCCPDSD from my toolkit (file\n520). You still want it Sam?\n\n\nRobin Ryerse\n\n--------------------------------------------------------------------\n\nSubject:     RE: PROF dumper\nFrom:        \"Ryerse, Robin\" <robin.ryerse@eds.com>\nDate:        Tue, 27 Feb 2007 08:54:00 -0500\nTo:          \"Sam Golob\" <sbgolob@cbttape.org>\n\nApart from the required subroutine SCCPDSD, there is only the\nrexx exec.  I have attached it as clear text.\n\nRobin Ryerse\nMainframe Services  EDS Canada\nPhone:(905)528-2511.3174\n\n\n-----Original Message-----\nFrom:  ISPF discussion list \u00ddmailto:ISPF-L@listserv.nd.edu\u00a8\n       On Behalf Of Sam Golob\nSent:  February 26, 2007 9:13 AM\nTo:    ISPF-L@listserv.nd.edu Subject: Profile Search REXXes\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$$NOTE02": {"ttr": 520, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00#\\x01\\x13\\x08/\\x01\\x13\\x08/\"V\\x00^\\x00^\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2013-03-23T00:00:00", "modifydate": "2013-03-23T22:56:23", "lines": 94, "newlines": 94, "modlines": 0, "user": "SBGOLOB"}, "text": "Subject:  Update re: CBT files 752\nFrom:     \"Earle, William, H (Bill)\" <WEarle@azdes.gov>\nDate:     3/22/2013 1:18 PM\nTo:       Sam Golob <sbgolob@cbttape.org>\n\nSam,\n\nAs promised, here s an update for my problem with file 752.\n\nI created a replacement call for Robin's assembler routine, using\nan old rexx routine, #MEMLIST, written by Rollin Coville.\n\nThis way, all code is in rexx, so far easier to install.\n\nAttached are the APPLDUMP and #MEMLIST rexx routines. Be sure to\nmodify APPLDUMP to point to your PROFILE library in line\n\n\"pds = uid || '.ISPF.PROFILE'\".\n\nGive it a try if you'd like. Just go to ISPF 6, and enter\n\nEX 'your.rexx.lib.REXX(appldump)' 'dsnx'\nwhere dsnx (or dsn* for wildcard) is your applPROF member(s).\n\nBill\n\n------------------------------------------------------------\n\nOn 3/1/2013 9:53 AM, Earle, William, H (Bill) wrote:\n\n    Hi, Sam. I just tweaked the hex values on some of the panel\n    settings. Just an issue with the  Reflections  3270 emulator,\n    nothing about the file itself.  (about File 754)\n\n    On 752, I'm attempting to use some code I had previously to\n    replace the SCCPDSD code. We'll see how that goes. If I get\n    it working, I will send it to you.\n\n    Thanks for everything, and all the best to you and your\n    family also.\n\n    Bill\n\n------------------------------------------------------------\n\n\n From: Earle, William, H (Bill)\n Sent: Wednesday, February 27, 2013 3:28 PM\n To: sbgolob@cbttape.org\n Cc: Earle, William, H (Bill)\n Subject: CBT files 752 and 754\n\n Sam,\n Thanks for all that you do to keep the CBT tape going. I hope\n that the mainframe IT community appreciates it as much as I do.\n\n I have unloaded and used many of the files that are on the tape\n without issue, but I have had issues with the above mentioned\n files.\n\n Unfortunately, both files are from people that are long retired,\n and outside the U.S. (Canada and Sweden) so no assistance is\n available.\n\n On 752, there is no JCL for doing the compile for the various\n assembler/link edits and no mention of specific parms. Too bad\n the load library wasn't included as a separate file.\n\n On 754, for whatever reason, I'm having issues with the panels.\n It's probably related to the hex conversions during the\n upload/downloads. I've been able to overcome similar issues\n previously, but for whatever reason not this time. Displaying\n the panels returns a RC=20, severe error. Not very descriptive\n or specific.\n\n I was wondering if you have implemented either/both of these and\n if you had any issues with them. Any assistance would be\n appreciated.\n\n Thanks,\n\n Bill Earle\n DBA\n State of Arizona   DES\n 3443 N. Cenral Ave\n Phoenix, AZ 85212\n\n O (602) 274-5359 x1365\n C (602) 717-4819\n\nAttachments:\nAPPLDUMP.REX     7.6 KB\n#MEMLIST.REX     2.9 KB\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "#MEMLIST": {"ttr": 523, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\"\\x01\\x13\\x08/\\x01\\x13\\x08/\"\\'\\x00@\\x00@\\x00\\x00\\xe6`\\xc5\\xc1\\xd9\\xd3\\xc5@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2013-03-23T00:00:00", "modifydate": "2013-03-23T22:27:22", "lines": 64, "newlines": 64, "modlines": 0, "user": "W-EARLE"}, "text": "/**************************** REXX ************************************/\n/** EXEC NAME      : #MEMLIST  AN EXTERNAL REXX ROUTINE              **/\n/** AUTHOR         : ROLLIN E. COVILLE                               **/\n/** PHONE          : WORK: 545-1596                                  **/\n/** CREATE DATE    : 01/27/92                                        **/\n/**                                                                  **/\n/** Returns the number of members of a partitioned dataset           **/\n/**        and the names of the members on the stack. If the         **/\n/**        dataset is unavailable it returns a value of 0            **/\n/**                                                                  **/\n/**                                                                  **/\n/** INPUT PARMS   -  NAME OF PARTITIONED LIBRARY                     **/\n/**                     @dsname                                      **/\n/** Example call:    @return=#MEMLIST(c.c4386.prod.proclib)          **/\n/**                  IF @return > 0 THEN DO                          **/\n/**                     DO @i=1 to @return                           **/\n/**                        PULL @mem.@i                              **/\n/**                        END                                       **/\n/**                     END                                          **/\n/**                  ELSE NOP                                        **/\n/********************************************************************/\n ADDRESS TSO\n /*TRACE i*/\n PARSE UPPER ARG @dsname .\n/******************************************************************/\n/* Turn off prompts and messages                                  */\n/******************************************************************/\n@status = MSG('OFF')\n@prmt = PROMPT('OFF')\n\n/********************************************************/\n/* @retcode controls processing.  Initialize it now     */\n/********************************************************/\n@retcode = 0\n@a = 0\n\n ADDRESS TSO\n IF SYSDSN(\"'\"@dsname\"'\") \\= 'OK' THEN DO\n     /********************************************************/\n     /* See if library is available for processing           */\n     /********************************************************/\n     SAY ' '\n     SAY @dsname 'is unavailable for processing'\n     @retcode = 12\n     END\n ELSE NOP\n\n IF @retcode = 0 THEN DO\n     /********************************************************/\n     /* Trap output of TSO LISTDS command to get list of     */\n     /* members in PDS.  NOTE--List of member names begins   */\n     /* on seventh line of trapped output.                   */\n     /********************************************************/\n     @x = OUTTRAP('@line.')\n     \"LISTDS '\"@dsname\"' MEMBERS\"\n     @x = OUTTRAP('OFF')\n     DO @m = 7 to @line.0\n        @a = @a + 1\n        @mem = WORD(@line.@m,1)\n        QUEUE @mem\n        END\n     END\n ELSE NOP\n RETURN @a\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "@FILE752": {"ttr": 525, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04V\\x00\\x12\\x01\\x13\\x08/\\x01\\x13\\x08/#\\x07\\x00\\x1e\\x00\\x1e\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf8\\xf6@@@'", "ispf": {"version": "04.86", "flags": 0, "createdate": "2013-03-23T00:00:00", "modifydate": "2013-03-23T23:07:12", "lines": 30, "newlines": 30, "modlines": 0, "user": "CBT-486"}, "text": "//***FILE 752 is from Robin Ryerse and contains an ISPF Profile     *   FILE 752\n//*           dumping tool, written in REXX, requiring one          *   FILE 752\n//*           Assembler subroutine (included).                      *   FILE 752\n//*                                                                 *   FILE 752\n//*     Please note information about the fix from Bill Earle.      *   FILE 752\n//*                                                                 *   FILE 752\n//*     Dump the specified/current profile(s) and related           *   FILE 752\n//*     ISPPROF tables to a (series of) sequential file(s) named    *   FILE 752\n//*     userid.applid.APPLDUMP.  The specified applid can           *   FILE 752\n//*     contain wildcard values \"*\" and/or \"%\";  e.g. TSO           *   FILE 752\n//*     %APPLDUMP IS*                                               *   FILE 752\n//*                                                                 *   FILE 752\n//*     This exec must be named APPLDUMP for recursive execution.   *   FILE 752\n//*                                                                 *   FILE 752\n//*     Requires function/subroutine SCCPDSD                        *   FILE 752\n//*                                                                 *   FILE 752\n//*     - - - - - - - - - - - - - - - - - - - - - - - - - - - -     *   FILE 752\n//*                                                                 *   FILE 752\n//*     A fix was provided for this application by Bill Earle.      *   FILE 752\n//*     His version of APPLDUMP was named in this pds, APPLDUM1,    *   FILE 752\n//*     and it should be renamed back to APPLDUMP, if you use       *   FILE 752\n//*     his version.  In Bill's version, SCCPDSD was rewritten      *   FILE 752\n//*     in REXX.                                                    *   FILE 752\n//*                                                                 *   FILE 752\n//*     For details from Bill Earle, see member $$NOTE02.           *   FILE 752\n//*                                                                 *   FILE 752\n//*     email:  robin.ryerse@eds.com                                *   FILE 752\n//*                                                                 *   FILE 752\n//*     email:  \"Earle, William, H (Bill)\" <WEarle@azdes.gov>       *   FILE 752\n//*                                                                 *   FILE 752\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "APPLDUMP": {"ttr": 527, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x04\\x01\\x07\\x05\\x8f\\x01\\x07\\x05\\x8f\\t3\\x00\\x84\\x00\\x84\\x00\\x00\\xd7\\xe2\\xe3\\xf0\\xf7\\xf0\\xf5@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2007-02-27T00:00:00", "modifydate": "2007-02-27T09:33:04", "lines": 132, "newlines": 132, "modlines": 0, "user": "PST0705"}, "text": "/* REXX - Dump the specified/current profile(s) and related\n          ISPPROF tables to a (series of) sequential file(s) named\n          userid.applid.APPLDUMP.  The specified applid can\n          contain wildcard values \"*\" and/or \"%\";  e.g. TSO\n          %APPLDUMP IS*\n\n          This exec must be named APPLDUMP for recursive execution.\n\n          Requires function/subroutine SCCPDSD                        */\n\n'SUBCOM ISPEXEC'\nif rc \\= 0 then\n  do\n     say 'APPLDUMP:  Usage must be from within ISPF.'\n     exit 16\n  end\naddress 'ISPEXEC'\n'CONTROL ERRORS RETURN'\n'VGET ZAPPLID'\nParse arg appl options\nlibdef_d = options \\= ''\nparse upper value appl zapplid with appl .\ncall sccpdsd 'ISPPROF', appl'PROF', 'D.'\nif d.0 = 0 then\n  do\n     say 'APPLDUMP:  ',\n                   appl'PROF is not a saved ISPF profile/table.'\n     exit 12\n  end\nif wordpos(appl,zapplid 'ISPS') = 0 then\n  do\n     do d# = 1 to d.0\n          parse var d.d# appl 'PROF'\n          newappl = appl\n          if newappl = 'ISPS' then newappl = 'ISP'\n         'SELECT CMD(%APPLDUMP' appl') NEWAPPL('newappl') PASSLIB'\n     end\n     if rc > 0 then say zerrlm\n     exit rc\n  end\n\nmax_len = 251\nr# = 0\nif libdef_d then\n  do\n     d.0 = 1\n     d.1 = appl'PROF'\n     tablenam = d.1\n  end\nelse\n  do\n    'LIBDEF ISPTLIB LIBRARY ID(ISPPROF)'\n     call sccpdsd 'ISPPROF', appl'*', 'D.'\n  end\ndo d# = 1 to d.0\n     parse var d.d# tablenam 9\n     tbopened = 0\n'TBTOP ' tablenam\nif rc > 8 then\n  do\n    'TBOPEN' tablenam 'NOWRITE'\n     if rc > 8 then\n       do\n          r# = r# + 1\n          r.r# = 'APPLDUMP: TBOPEN' tablenam 'rc=' rc'.' zerrlm\n          iterate d#\n       end\n     tbopened = 1\n    'TBTOP ' tablenam\n  end\n'TBSTATS' tablenam 'CDATE(CDATE) UDATE(UDATE) UTIME(UTIME) ROWCURR(ROWS)',\n         'STATUS1(STAT) STATUS2(STAT2) STATUS3(STAT3) LIBRARY(ISPPROF)'\nvar_names = ''\nkey_lit = ''\nif tablenam = appl'PROF' then\n  do\n    'TBSKIP' tablenam 'SAVENAME(VVVV)'\n     var_names = substr(vvvv,2,length(vvvv)-2)\n  end\nelse\n  do\n    'TBQUERY' tablenam 'KEYS(KKKK) NAMES(VVVV)'\n     if length(vvvv) > 2 then var_names = substr(vvvv,2,length(vvvv)-2)\n     if length(kkkk) > 2 then key_lit = '   Keys:' substr(kkkk,2,length(kkkk)-2)\n    'TBSKIP' tablenam\n  end\nr# = r# + 1\nr.r# = left(tablenam':',9),\n      '  Variables:' right(words(var_names),3),\n      '  Created:' cdate,\n      '  Updated:' udate utime\nr# = r# + 1\nr.r# = '            Rows:' rows '  Stati:' stat stat2 stat3 key_lit\nmax_len = max(max_len,length(r.r#))\ndo rw# = 1 to rows\nsaves = var_names\nr# = r# + 1\nr.r# = left('--------' tablenam 'row:' right(rw#,5),72,'-')\ntlen = 0;\nDo While saves \\= ''\n     r# = r# + 1\n     Parse Var saves wwww saves\n     tlen = tlen + length(wwww)\n     Interpret 'val =' wwww\n     r.r# = left(wwww,9)right(length(val),5) val\n     max_len = max(max_len,length(r.r#))\nend\ndrop value(var_names)\nif appl'PROF' = tablenam then\n  do\n    'TBSKIP' tablenam 'SAVENAME(VVVV)'\n     var_names = substr(vvvv,2,length(vvvv)-2)\n  end\nelse 'TBSKIP' tablenam\nif rc > 0 then leave rw#\n\nend\nif tbopened then do; 'TBTOP' tablenam; 'TBCLOSE' tablenam; end\nend\nr.0 = r#\n\n'LIBDEF ISPTLIB'\naddress 'TSO'\nprefix = sysvar('SYSPREF')\nif prefix = '' then dsn = userid()'.'appl'.APPLDUMP'\nelse dsn = appl'.APPLDUMP'\n'ALLOC F(TBLDUMP) DA('dsn') MOD DEL UNIT(SYSDA) REU'\n'ALLOC F(TBLDUMP) DA('dsn') NEW CAT TR SPA(20,20) RELEASE REUSE',\n  'DSORG(PS) RECFM(V B) LRECL('max_len+4') BLKSIZE(0) UNIT(SYSDA)'\n'EXECIO' r.0 'DISKW TBLDUMP (FINIS STEM R.'\n'FREE FILE(TBLDUMP)'\nexit 0\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "APPLDUM1": {"ttr": 530, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x008\\x01\\x13\\x08/\\x01\\x13\\x08/\"6\\x01\\x14\\x01\\x14\\x00\\x00\\xe6`\\xc5\\xc1\\xd9\\xd3\\xc5@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2013-03-23T00:00:00", "modifydate": "2013-03-23T22:36:38", "lines": 276, "newlines": 276, "modlines": 0, "user": "W-EARLE"}, "text": "/* REXX - APPLDUMP\n   Dump the specified/current profile(s) and related\n   ISPPROF tables to a (series of) sequential file(s) named\n   userid.applid.APPLDUMP.  The specified applid can\n   contain wildcard values \"*\" and/or \"%\";  e.g. TSO\n   %APPLDUMP IS*\n\n   This exec must be named APPLDUMP for recursive execution.\n\n   Obtained from file 752 of the CBT Tape, from author\n   Robin Ryerse of EDS (robin.ryerse@eds.com)\n\n  Robin's sccpdsd assembler routine could not be assembled for\n  whatever reason, so I (Bill Earle) created my own version of\n  it and placed the code at sccpdsd:.\n\n*/\ndebug = 'N'\n'SUBCOM ISPEXEC'\nif rc \\= 0 then\n  do\n     say 'APPLDUMP:  Usage must be from within ISPF.'\n     exit 16\n  end\naddress 'ISPEXEC'\n'CONTROL ERRORS RETURN'\n'VGET ZAPPLID'\nif debug = 'Y' then\n   say 'Current APPL =' zapplid\nParse arg appl options\nif debug = 'Y' then\n   say 'arg=' arg 'appl=' appl 'options=' options\nlibdef_d = options \\= ''\nparse upper value appl zapplid with appl .\nif debug = 'Y' then\n  do\n     say 'appl=' appl 'zapplid=' zapplid 'appl=' appl\n     say appl'PROF'\n  end\n/* call sccpdsd appl'PROF' */\nif debug = 'Y' then\n   say 'Calling sccpdsd with appl=' appl\ncall sccpdsd appl\nif debug = 'Y' then\n   do\n     say 'Returning from sccpdsd with d.0 =' d.0 'entries'\n     say 'd.1 =' d.1\n   end\nif d.0 = 0 then\n  do\n     say 'APPLDUMP:  ',\n                   appl'PROF is not a saved ISPF profile/table.'\n     exit 12\n  end\nd# = 0\nif wordpos(appl,zapplid 'ISPS') = 0 then\n  do\n     do d# = 1 to d.0\n        parse var d.d# appl\n        newappl = appl\n        if newappl = 'ISPS' then newappl = 'ISP'\n       'SELECT CMD(%APPLDUMP' appl') NEWAPPL('newappl') PASSLIB'\n     end\n     if rc > 0 then say zerrlm\n     exit rc\n  end\n\nmax_len = 251\nr# = 0\n/*\nif libdef_d = '' then  /* desired profile library already allocated */\n  do\n     d.0 = 1\n     d.1 = appl||'PROF'\n     tablenam = d.1\n  end\nelse\n  do\n    'LIBDEF ISPTLIB LIBRARY ID(ISPPROF)'\n     call sccpdsd appl\n  end\n*/\ndo d# = 1 to d.0\n   parse var d.d# tablenam 9\n   tablenam = tablenam || 'PROF'\n   tbopened = 0\n   'TBTOP ' tablenam\n   if rc > 8 then\n   do\n    'TBOPEN' tablenam 'NOWRITE'\n     if rc > 8 then\n       do\n          r# = r# + 1\n          r.r# = 'APPLDUMP: TBOPEN' tablenam 'rc=' rc'.' zerrlm\n          iterate d#\n       end\n     tbopened = 1\n    'TBTOP ' tablenam\n   end\n   'TBSTATS' tablenam 'CDATE(CDATE) UDATE(UDATE) UTIME(UTIME) ROWCURR(ROWS)',\n         'STATUS1(STAT) STATUS2(STAT2) STATUS3(STAT3) LIBRARY(ISPPROF)'\n   parse var cdate  yr '/' monthday\n   cdate = monthday || '/' || yr\n   parse var udate  yr '/' monthday\n   udate = monthday || '/' || yr\n   if rows = '' then\n      rows = 0\n   var_names = ''\n   key_lit = ''\n   if tablenam = appl'PROF' then\n     do\n       'TBSKIP' tablenam 'SAVENAME(VVVV)'\n       var_names = substr(vvvv,2,length(vvvv)-2)\n     end\n   else\n     do\n       'TBQUERY' tablenam 'KEYS(KKKK) NAMES(VVVV)'\n       if length(vvvv) > 2 then var_names =   substr(vvvv,2,length(vvvv)-2)\n       if length(kkkk) > 2 then key_lit = '   Keys:' substr(kkkk,2,length(kkkk)-\n       'TBSKIP' tablenam\n     end\n   r# = r# + 1\n   r.r# = left(tablenam':',9),\n      '  Variables:' right(words(var_names),3),\n      '  Created:' cdate,\n      '  Updated:' udate utime\n/*\n   r# = r# + 1\n   r.r# = '            Rows:' rows '  Stati:' stat stat2 stat3 key_lit\n*/\n   max_len = max(max_len,length(r.r#))\n   do rw# = 1 to rows\n     saves = var_names\n     r# = r# + 1\n     r.r# = left('--------' tablenam 'row:' right(rw#,5),72,'-')\n     tlen = 0;\n     do While saves \\= ''\n        r# = r# + 1\n        Parse Var saves wwww saves\n        tlen = tlen + length(wwww)\n        Interpret 'val =' wwww\n        r.r# = left(wwww,9)right(length(val),5) val\n        max_len = max(max_len,length(r.r#))\n     end\n     drop value(var_names)\n     if appl'PROF' = tablenam then\n       do\n         'TBSKIP' tablenam 'SAVENAME(VVVV)'\n         var_names = substr(vvvv,2,length(vvvv)-2)\n       end\n     else 'TBSKIP' tablenam\n     if rc > 0 then leave rw#\nend\nif tbopened then do; 'TBTOP' tablenam; 'TBCLOSE' tablenam; end\nend\nr.0 = r#\n\n'LIBDEF ISPTLIB'\naddress 'TSO'\nUID    = USERID()                                  /* USER'S TSO ID */\nIF UID = 'xxxxxxxx' THEN\n   HLQ = 'DBA.ABCD'\nIF UID = 'yyyyyyyy' THEN\n   HLQ = 'DBA.EFG'\n\ndsn = hlq ||'.'appl'.APPLDUMP'\n\n'ALLOC F(TBLDUMP) DA('dsn') MOD DEL UNIT(SYSDA) REU'\n'ALLOC F(TBLDUMP) DA('dsn') NEW CAT TR SPA(20,20) RELEASE REUSE',\n  'DSORG(PS) RECFM(V B) LRECL('max_len+4') BLKSIZE(0) UNIT(SYSDA)'\n'EXECIO' r.0 'DISKW TBLDUMP (FINIS STEM R.'\n'FREE FILE(TBLDUMP)'\n/*\nsay\nsay 'Output file has been written to' dsn\nsay\n*/\nADDRESS ISPEXEC \"BROWSE DATASET('\"dsn\"')\"\nexit 0\n\nsccpdsd:\n/**********************************************************************\n\n   Written by Bill Earle to work with the APPLDUMP rexx originally\n   written by Robin Ryerse of EDS Canada. This rexx routine replaces\n   the assembler code required by Robin's code.\n\n   arg wc is for passing a wildcard for limiting the applPROF members\n   you want to process. A valid wildcard can be:\n\n     1. An actual specific appl name (i.e. ISR) minus the PROF.\n     2. A wildcard selection (ex. IS*) that will only process\n        xxxxPROF members that start with IS.\n\n     NOTE: Do NOT include the 'PROF' in the wildcard, only the prefix,\n           ex. ISRPROF would simply be ISR (or ISR*)\n\n**********************************************************************/\narg wc\nif wc = '' then                           /* no wildcard parm passed */\n   wclen = 0\nelse\n  do\n     if pos('*',wc) > 0 then           /* true wildcard, name prefix */\n        do\n           parse var wc wcappl '*' rest\n           wclen = length(wcappl)\n        end\n     else\n        do\n           wcappl = wc\n           wclen = length(wc)         /* length set to actual prefix */\n        end\n  end\nNUMERIC DIGITS 12\n@return = 0\nz = 0\nuid = userid()                                  /* get users TSO is */\npds = uid || '.ISPF.PROFILE'\nmemlist = '@return=#MEMLIST('||pds||')'\ninterpret memlist\n@i = 0\nd.0 = 0\nd.     = ''\nif @return > 0 THEN\n  do @i=1 to @return\n     PULL @mem.@i\n     mbrname = @mem.@i\n     mbr.@i = @mem.@i\n     if pos('PROF',mbrname) > 1 then\n        do\n           name = right(mbrname,4)  /* see if last 4 chars are PROF */\n           if name = 'PROF' then\n              do\n                if wclen = 0 then  /* no wildcard */\n                   do\n                      parse var mbrname applid 'PROF'\n                      z = z + 1\n                      d.0 = z\n                      d.z = applid\n                   end\n                else\n                   do\n                      parse var mbrname applid 'PROF'\n                      ckmbr = substr(applid,1,wclen) /* get wc len */\n                      if ckmbr = wcappl then     /* match on wc */\n                         do\n                            z = z + 1\n                            d.0 = z\n                            d.z = applid\n                         end\n                   end\n              end\n        end\n  end\nif d.0 > 0 then\n  do\n     if zapplid = appl then\n        do\n        /*\n           say 'turning trace on'\n           trace r\n        */\n           say 'Here''s the list of found APPL profile members in ' pds\n           say 'that meet the wildcard specification' wc\n           say\n           do z = 1 to d.0\n              say z d.z\n           end\n        /*\n           say 'turning trace off'\n           trace o\n        */\n        end\n  end\nreturn\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SCCPDSD": {"ttr": 772, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x01\\x15\\x7f\\x01\\x01\\x15\\x7f\\x14A\\x05\\x00\\x05\\x00\\x00\\x00\\xd7\\xe2\\xe3\\xf0\\xf7\\xf0\\xf5@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2001-06-06T00:00:00", "modifydate": "2001-06-06T14:41:00", "lines": 1280, "newlines": 1280, "modlines": 0, "user": "PST0705"}, "text": "./ ADD NAME=HELP     0100-01157-01157-1131-00054-00054-00000-PST0705\n Name:        SCCPDSD\n\n Purpose:     Obtain selected directory entries from the specified\n              DDname into a stemmed variable or into the data stack.\n\n Environment: REXX subroutine/function for all MVS/ESA environments.\n              SCCD2O resides in the IRXFLOC \"function package\".\n\n\n Arguments:\n           1. The DDname of the library. If the same DDname is to\n              be used by SCCPDSR, currently only three values\n              are allowed namely PDS1, PDS2, and PDS3. (Removal of\n              this limitation is the planned enhancement.)\n\n              The DDname must be pre-allocated to the library. That\n              allocation must not be done at the member level.\n\n           2. The selection criteria. The criteria is composed of\n              natural characters and/or the 'wildcard' values\n              '*' and '%'\n\n              Refer to the WILDCARD function for details of how this\n              criteria may be used.\n\n           3. The name of the REXX stem variable to receive the\n              directory entries.  The caller must ensure this\n              specification is enclosed within quotes.\n\n              If argument 3 is not specified (or specified as null),\n              the directory entries are placed in the data stack.\n\n\n Results: (when 'stem.' is specified at argument 3)\n              'stem.0' contains a count of the number of directory\n              entries.\n\n              'stem.1' through 'stem.stem.0' contains the individual\n              directory entries.\n\n          (when argument 3 is null):\n              The data stack contains directory entries read in FIFO\n              order.\n\n          (independent of argument 3)\n              As a REXX subroutine/function SCCPDSD must return a result\n              to the caller. SCCPDSD returns the number (relative to 0)\n              of datasets concatenated within the DDname.\n\n\n Notes:       Choice of a technique to manage the 'data stack' is a\n              subjective matter. SCCPDSD makes no choice. If the REXX\n              program requires stack isolation, the programmer must\n              use an appropriate technique.\n./ ADD NAME=ID       0102-98050-98050-1606-00049-00046-00000-PST0705\n         MACRO\n&LABEL   ID    &USING,&CSECT=YES,&AMODE=31,&RMODE=ANY\n         LCLC  &U,&LBL\n.*\n.* Stelco macro used to:\n.*    - generate the CSECT statement.\n.*    - generate the USING, AMODE and RMODE statements for the CSECT.\n.*    - generate an eye-catcher and date/time stamp (28 bytes total).\n.*      (The values for date and time are the time of the Assembly.)\n.*\n.* The default for the USING statement is (register) 15.\n.* Other defaults are as per the prototype above.\n.*\n.* If the CSECT requires multiple base registers, their specification\n.* must be enclosed in parenthesis.       e.g.  BIGRTN   ID     (12,11)\n.*\n.* This macro can also be used to generate only the eye-catcher and\n.* date/time stamp. For this type of usage specify   ID    ,CSECT=NO\n.*\n.* -----------------------Modification History-------------------------\n.* 98-02-19 change from &SYSDATE to &SYSDATC\n.*\n&U       SETC  '15'\n&LBL     SETC  ' '\n         AIF   (K'&LABEL EQ 0).LBLSET\n&LBL     SETC  '&LABEL'\n.LBLSET  ANOP\n         AIF   (T'&USING EQ 'O').USET\n         AIF   ('&USING'(1,1) NE '(').ONEUSE\n&U       SETC  '&USING'(2,K'&USING-2)\n         AGO   .USET\n.ONEUSE  ANOP\n&U       SETC  '&USING'\n.USET    ANOP\n         AIF   ('&CSECT' EQ 'YES').CSECT\n&LBL     DS    0H\n         B     *+32\n         AGO   .STAMP\n.CSECT   ANOP\n&LBL     CSECT\n&LBL     AMODE &AMODE\n&LBL     RMODE &RMODE\n         USING &LABEL,&U\n         BC    15,32(,15)\n.STAMP   ANOP\n         DS    CL4\n         DC    CL8'&LBL'\n         DC    CL16'&SYSDATC &SYSTIME'\n         MEND\n./ ADD NAME=SCCPDSD  0139-95181-01019-1445-00456-00355-00000-PST0705\nPDSD     TITLE            '<< REXX - Get PDS directory entry           X\n                                                      Documentation >>'\n* Name:        SCCPDSD\n*\n* Purpose:     Select the directory entries of a specified\n*              partitioned dataset via (Assembler) subroutine STSS383.\n*\n* Environment: REXX subroutine/function for Address TSO or MVS\n*\n* Features:    STSS383 supports 'wildcard' selection criteria for the\n*              directory entries via (Assembler) subroutine SCCWC001\n*\n*              The caller access the directory entries through either:\n*                 - a \"stemmed\" variable\n*                 - the \"data stack\"\n*\n* Parameters:  1. The DDNAME which refers to the partitioned dataset.\n*\n*              2. The member selection criteria. This parameter\n*                 supports the 'wildcard' values of '*' (asterisk)\n*                 and '%' (percent sign). Refer to subroutine\n*                 SCCWC001 for more information on these wild\n*                 cards.\n*\n*              3. (optional) The name of the stem variable which\n*                 will be assigned the values from the record. If the\n*                 caller does not delimit the stem with a period,\n*                 one is generated.\n*\n*                 The REXX programmer should ensure that the value\n*                 specified for the call is enclosed in quotes.\n*\n*                 stem.0 is assigned the value of the number of\n*                 records read.\n*\n*                 If parameter 3 is not specified or specified as null,\n*                 SCCPDSD places the records in the data stack.\n* Notes:\n*\n*    There are mutually exclusive techniques to handle the data stack.\n*    Since the choice of a technique is subjective, SCCPDSD makes no\n*    choice. If stack isolation is required, an appropriate technique\n*    is the responsibilty of the callin program.\n*\n         TITLE            '<< REXX - Get PDS directory entry           X\n                                                     System Linkage >>'\nSCCPDSD  ID    R12\n         SPACE 2\n         STM   R14,R12,12(R13)\n         LR    R12,R15\n         ST    R13,SAVEAREA+4\n         LA    R15,SAVEAREA\n         ST    R15,8(,R13)\n         LR    R13,R15\n         XC    RC,RC\n         B     MAINLINE\n         SPACE 3\nRC       DS    0F\n         DS    AL1\nRC1      DS    AL1\nRC2      DS    AL1\nRC3      DS    AL1\n         SPACE 1\nSAVEAREA DS    18F\n         SPACE 3\nRTNXT    DS    0H\n         L     R13,SAVEAREA+4\n         XC    8(4,R13),8(R13)\n         XC    16(4,R13),16(R13)   R15 (return code) always\n         LM    R14,R12,12(R13)        get set to zero.\n         BR    R14\n         TITLE            '<< REXX - Get PDS directory entry           X\n                                                Parse the Arguments >>'\nMAINLINE DS    0H\n         USING EFPL,R1\n         USING ENVBLOCK,R8\n         USING IRXEXTE,R9\n         USING EVALBLOCK,R11\n         USING SHVBLOCK,R14\n         LR    R8,R0               Address the environment block.\n         L     R9,ENVBLOCK_IRXEXTE Address the REXX vector table.\n         LM    R10,R11,EFPLARG     Address ARGTABLE & EVALBLOCK.\n         L     R11,0(,R11)\n         LM    R14,R0,SET_REGS-12\n         STM   R14,R0,SET_REGS\n         MVI   DDNAME,C' '\n         MVC   DDNAME+1(L'DDNAME+L'MEM_NAME-1),DDNAME\n         XC    SHVNAMA-SHVBLOCK+@SHV,SHVNAMA-SHVBLOCK+@SHV\n         MVI   TRTABLE-1,X'FF'     Pre-set table value.\n         NI    PLIST383,X'7F'      More than one parm for STSS383.\n*        WTO   'SCCPDSD started.'\n         BAL   R14,STRIP           Strip out arg(1).\n         B     MISSING_DD          Arg(1) not specified.\n         LA    R0,7                Maximum length.\n         CR    R15,R0              Length(arg(1)) > maximum ?\n         BNH   *+6                    -no -\n         LR    R15,R0                 -yes-   Use maximum\n         EX    R15,MVC_DD          Pick-up the DDname.\n         SPACE 1\n         BAL   R14,STRIP           Strip out arg(2).\n         B     MISSING_MEM         Arg(2) not specified\n         LA    R0,7                Maximum length.\n         CR    R15,R0              Length(arg(2)) > maximum ?\n         BNH   *+6                    -no -\n         LR    R15,R0                 -yes-   Use maximum\n         EX    R15,MVC_MEM         Pick-up the member name.\n         LA    R15,1(,R15)\n         ST    R15,SELECT_LEN\n         MVC   NON_WILD,MEM_NAME\n         TR    NON_WILD,NON_WILD_TR\n         BAL   R14,STRIP           Strip out arg(3).\n         B     MISSING_STEM        Arg(3) not specified\n         LA    R0,244              Maximum length of variable stem.\n         SR    R0,R15              Calculate\n         LA    R2,VAR_NAME            address where\n         AR    R2,R0                     stem will be stored.\n         CLI   0(R4),C'.'          Does stem end with period?\n         BE    *+10                   -yes-\n         BCTR  R2,0                   -no -   adjust address and\n         MVI   TAIL-1,C'.'                       provide the period.\n         EX    R15,MVC_STEM        Pick-up the stem name.\n         ST    R2,SHVNAMA-SHVBLOCK+@SHV   Variable name addr into SHVB.\n         LA    R0,TAIL+1           Include one digit of 'tail'\n         SR    R0,R2                  in the qualified\n         ST    R0,SHVNAML-SHVBLOCK+@SHV  variable name length.\n         SPACE 1\nMISSING_STEM   DS    0H\n         TITLE            '<< REXX - Get PDS directory entry           X\n                      Call STSS383 and determine method of disposal >>'\n         XC    ADRCTRY,ADRCTRY     Pre-set STSS383's result to zero.\n         LA    R1,PLIST383         Parameter list.\n         L     R15,VSTSS383        Entry point address.\n         BALR  R14,R15             Call.\n         L     R10,ADRCTRY         Address STSS383's result.\n         LTR   R10,R10             Did STSS383 set the address?\n         BZ    @383_FAILED            -no -\n         USING DRCTPREF,R10\n         LH    R0,DRCTCON          Number of concatenation levels\n         CVD   R0,DBLWD               into\n         OI    DBLWD+7,X'0F'             ebcdic\n         UNPK  EVALBLOCK_EVDATA(3),DBLWD+6(2)  format.\n         LA    R0,3                Let\n         ST    R0,EVALBLOCK_EVLEN     REXX know the length of data.\n         DROP  R11                 Done addressing EVALBLOCK.\n         LH    R11,DRCTCNT         Get the number of directory entries.\n         LTR   R11,R11             Empty PDS?\n         BZ    DO_STEM0               -yes-\n         LA    R10,DRCTNTRY        Address the first directory entry.\n         B     MATCH_ENTRY\n         DROP  R10\n         USING DRCTNTRY,R10\nNEXT_ENTRY DS  0H\n         BCT   R11,*+8\n         B     DO_STEM0\n         SR    R1,R1               Clear a register to\n         IC    R1,MEMLEN              pick-up number of member halfwd.\n         LA    R0,31               B'00011111' zero out bits 0,1,2\n         NR    R1,R0                  of byte 3 within register.\n         SLL   R1,1                Half words to bytes.\n         LA    R10,14(R1,R10)      Address the next entry.\nMATCH_ENTRY DS 0H\n         ST    R10,PLIST_WC001+8   Address of SCCWC001 'target'.\n         LA    R1,PLIST_WC001      Call\n         L     R15,VWC001             ...\n         BALR  R14,R15                   SCCWC001\n         BE    STEM_OR_STACK       Matched.\n         CLC   NON_WILD,MEMNAME    Beyond matching?\n         BNL   NEXT_ENTRY             -not yet-\nDO_STEM0 DS    0H\n*        WTO   'SCCPDSD after last CALL SCCWC001.'\n         LA    R1,PLIST383\n         OI    PLIST383,X'80'      One parm for STSS383.\n         L     R15,VSTSS383        Entry point address.\n         BALR  R14,R15             Call to free areas.\n*        WTO   'SCCPDSD after last CALL STSS383.'\n         L     R2,SHVNAMA-SHVBLOCK+@SHV  Address of variable name.\n         LTR   R2,R2               Did caller specify a stem variable?\n         BZ    RTNXT                  -no -   Go stack the entries.\n         MVI   TAIL,C'0'           Will be setting stem.0\n         LA    R0,TAIL+1           Calculate\n         SR    R0,R2                  length of variable name and\n         ST    R0,SHVNAML-SHVBLOCK+@SHV  tell EXCOM about it.\n         L     R0,SET_REGS         Get the record count\n         CVD   R0,DBLWD               into a\n         UNPK  NON_WILD(5),DBLWD+5(3)    ebcidic\n         OI    NON_WILD+4,X'F0'             format.\n         LA    R1,NON_WILD         Leftmost byte of variable value.\n         LA    R2,4                Maximum loop counter.\n         LA    R15,*+4             Top-of-loop address.\n         CLI   0(R1),C'0'          Insignificant zero?\n         BNE   *+10                   -no -\n         LA    R1,1(,R1)           Next byte.\n         BCTR  R2,R15              Count and loop.\n         SPACE 1\n         LA    R2,1(,R2)           Residual of loop-counter plus 1\n         ST    R2,SHVVALL-SHVBLOCK+@SHV equals the length of the value.\n         ST    R1,SHVVALA-SHVBLOCK+@SHV  EXCOM finds the value there.\n         L     R15,IRXEXCOM        Get routine's address from vector.\n         LA    R0,ENVBLOCK         Make sure REXX knows environment.\n         LA    R1,PLIST_EXCOM\n         BALR  R14,R15\n         B     RTNXT\nSTEM_OR_STACK  DS    0H\n         SR    R1,R1               Clear a register to\n         IC    R1,MEMLEN              pick-up number of member halfwd.\n         LA    R0,31               B'00011111' zero out bits 0,1,2\n         NR    R1,R0                  of byte 3 within register.\n         SLL   R1,1                Half words to bytes\n         LA    R1,14(,R1)             plus minimum length.\n         ST    R1,SHVVALL-SHVBLOCK+@SHV\n         ST    R10,SHVVALA-SHVBLOCK+@SHV\n         AR    R10,R1\n         L     R2,SHVNAMA-SHVBLOCK+@SHV  Address of variable name.\n         LTR   R2,R2               Did caller specify a stem variable?\n         BZ    STACK                  -no -   Go stack the entries.\n         TITLE            '<< REXX - Get PDS directory entry           X\n                             Place record into the stemmed variable >>'\n         LM    R2,R4,SET_REGS\n         LA    R2,1(,R2)           Count the entries and\n         ST    R2,SET_REGS            save the count.\n         CVD   R2,DBLWD            Covert the count\n         UNPK  TAIL,DBLWD+5(3)        to ebcdic\n         OI    TAIL+4,X'F0'              format.\n         BCTR  R3,R4               Branch unless count was 10, 100 etc.\n         L     R3,SHVNAML-SHVBLOCK+@SHV  Length of tail\n         LA    R3,1(,R3)                    just increased by one\n         ST    R3,SHVNAML-SHVBLOCK+@SHV        so save.\n         CLI   TAIL,C'1'           Just counted 10,000?\n         BE    SET@10000              -yes-\n         CLI   TAIL+1,C'1'         Just counted 1,000?\n         BE    SET@1000               -yes-\n         CLI   TAIL+2,C'1'         Just counted 100?\n         BE    SET@100                -yes-\n         LA    R3,90               At 10 now, re-set counter @ 90\n         LA    R4,*+8              Re-set address for left adjust move\n         ST    R4,SET_REGS+8          and save it.\n         MVC   TAIL(2),TAIL+3      Left adjust the tail to stem.\n         B     CALL_EXCOM          Ready for IRXEXCOM.\nSET@100  DS    0H                  At 100 now,\n         LA    R3,900                 re-set counter @ 900\n         LA    R4,*+8              Re-set address for left adjust move\n         ST    R4,SET_REGS+8          and save it.\n         MVC   TAIL(3),TAIL+2      Left adjust the tail to stem.\n         B     CALL_EXCOM          Ready for IRXEXCOM.\nSET@1000 DS    0H                  At 1,000 now,\n         L     R3,=A(9000)            re-set counter @ 9000\n         LA    R4,*+8              Re-set address for left adjust move\n         ST    R4,SET_REGS+8          and save it.\n         MVC   TAIL(4),TAIL+1      Left adjust the tail to stem.\n         B     CALL_EXCOM          Ready for IRXEXCOM.\nSET@10000 DS   0H                  At 10,000 now,\n         L     R3,=A(90000)           re-set counter @ 90000\n         LA    R4,CALL_EXCOM       Re-set address for no adjust move\n         ST    R4,SET_REGS+8          and save it.\n         B     CALL_EXCOM          Ready for IRXEXCOM.\nSET@1    DS    0H\n         MVC   TAIL(1),TAIL+4\n         TITLE            '<< REXX - Get PDS directory entry           X\n                Assign the value from the record to a REXX variable >>'\nCALL_EXCOM  DS  0H\n         ST    R3,SET_REGS+4       Save the loop counter.\n*\n* Refer to the IRXEXCOM routine; pages 312-319 of SC28-1883-06 -\n* TSO Extentions Version 2  REXX/MVS Reference\n*\nCALL_EXCOM@    DS  0H\n         L     R15,IRXEXCOM        Get routine's address from vector.\n         LA    R0,ENVBLOCK         Make sure REXX knows environment.\n         LA    R1,PLIST_EXCOM\n         BALR  R14,R15\n         BCT   R11,MATCH_ENTRY\n         B     DO_STEM0\n         SPACE 1\nPLIST_EXCOM DC A(EXCOM_LIT,0,0)\n         DC    A(@SHV+X'80000000')\n         SPACE 1\n@SHV     DS    0A\n         DC    2A(0)\n         DC    C'S'\n         DS    XL3'000000'\n         DC    5A(0)\n         SPACE 1\nEXCOM_LIT DC   CL8'IRXEXCOM'\n         TITLE            '<< REXX - Get PDS directory entry           X\n                                   Put the record on the data stack >>'\n*\n* Refer to the IRXSTK   routine; pages 485-490 of SC28-1883-06 -\n* TSO Extentions Version 2  REXX/MVS Reference\n*\nSTK_FUNC DC    CL8'QUEUE   '\nSTK_PLIST  DC  A(STK_FUNC)\n         DC    A(SHVVALA-SHVBLOCK+@SHV)\n         DC    A(SHVVALL-SHVBLOCK+@SHV)\n         DC    A(RC+X'80000000')\nSTACK    DS    0H\n         LA    R1,STK_PLIST\n         LA    R0,ENVBLOCK\n         L     R15,IRXSTK\n         BALR  R14,R15\n         BCT   R11,MATCH_ENTRY\n         B     DO_STEM0\n         TITLE            '<< REXX - Read a PDS member                 X\n                     Subroutine to Strip Leading && Trailing Blanks >>'\n         DROP  R10\n         USING ARGTABLE_ENTRY,R10\n* Registers upon entry\n*    R10 ==> argument table entry\n*    R14 ==> exit address when agrument is null\n*    R14+4=> normal exit\n*\n* Registers upon exit\n*    R10 ==> next argument table entry.\n*    R2    = 0 (zero)\n*    R3  ==> leftmost non-blank byte of argument\n*    R4  ==> rightmost non-blank byte of argument\n*    R15   = R4 - R3 (length of argument minus 1)\n         SPACE 2\nTRT3     TRT   0(0,R3),TRTABLE\nHEXFF    DC    X'FFFFFFFFFFFFFFFF'\n         DS    XL1\nTRTABLE  DS    XL256\n         SPACE 2\nSTRIP    DS    0H\n         CLC   HEXFF,ARGTABLE_ARGSTRING_PTR  Is there an argument?\n         BER   R14                              -no -\n         L     R15,ARGTABLE_ARGSTRING_LENGTH\n         L     R3,ARGTABLE_ARGSTRING_PTR  Get address of argument.\n         LA    R10,ARGTABLE_NEXT   Point to next argument table entry.\n         SPACE 1\n         LTR   R15,R15             Does the argument have any length?\n         BZR   R14                    -NO - take abnormal exit.\n         LA    R4,0(R15,R3)        Point just beyond ARG.\n         MVC   TRTABLE,TRTABLE-1   Set to\n         MVI   TRTABLE+C' ',X'00'     bypass blanks.\n         BCTR  R15,0               Set length for TRT instruction.\n         EX    R15,TRT3            Skip to non-blank.\n         BZR   R14                 When all blank.\n         LR    R3,R1               Re-set starting address.\nSTRIP@R  DS    0H\n         BCTR  R4,0                Backpedal 1 byte.\n         CLI   0(R4),X'40'         (still) at a blanK?\n         BNE   STRIPPED               -no -\n         CR    R4,R3                  -yes-  More to inspect?\n         BH    STRIP@R                          -yes-\nSTRIPPED DS    0H\n         LR    R15,R4              Calculate\n         SR    R15,R3                 length of ARG - 1.\n         SR    R2,R2               Pre-clear R2 for TRT\n         XC    TRTABLE,TRTABLE     Clear translate table.\n         BC    15,4(,R14)          Take normal exit.\n         TITLE            '<< REXX - Get PDS directory entry           X\n                                                   Error Conditions >>'\n*\n* Refer to the IRXSAY   routine; pages 336-339 of SC28-1883-06 -\n* TSO Extentions Version 2  REXX/MVS Reference\n*\nSAY_LIT        DC    CL8'WRITE   '\nSAY_BUFF       DS    A\nSAY_LEN        DS    F\nSAY_PLIST      DC    A(SAY_LIT,SAY_BUFF,SAY_LEN+X'80000000')\n@383_MSG DC    C'Directory read (STSS383) failure.'\nMISSING_DD_MSG DC    C'First argument (DDNAME) missing.'\nMISSING_MEM_MSG DC   C'Second argument (member selection criteria) missi\n               ing.'\n@383_FAILED    DS    0H\n         LA    R15,@383_MSG\n         LA    R0,L'@383_MSG\n         B     SAY_CALL\nMISSING_DD     DS    0H\n         LA    R15,MISSING_DD_MSG\n         LA    R0,L'MISSING_DD_MSG\n         B     SAY_CALL\nMISSING_MEM    DS    0H\n         LA    R15,MISSING_MEM_MSG\n         LA    R0,L'MISSING_MEM_MSG\n         B     SAY_CALL\nSAY_CALL DS    0H\n         ST    R15,SAY_BUFF\n         ST    R0,SAY_LEN\n         LA    R1,SAY_PLIST\n         LA    R0,ENVBLOCK\n         L     R15,IRXSAY\n         BALR  R14,R15\n         L     R13,SAVEAREA+4\n         XC    8(4,R13),8(R13)\n         LM    R14,R12,12(R13)\n         LA    R15,40\n         BR    R14\n         TITLE            '<< REXX - Get PDS directory entry           X\n                                              Global Data Constants >>'\n         SPACE 2\nDBLWD    DS    D\n         SPACE 2\n         DC    A(0,10,SET@1)\nSET_REGS DS    3A\n         SPACE 1\nVSTSS383 DC    V(STSS383)\nVWC001   DC    V(SCCWC001)\n         SPACE 1\nF8       DC    F'8'\nSELECT_LEN DS  F\n         SPACE 1\nPLIST383 DC    A(DDNAME,ADRCTRY+X'80000000')\nPLIST_WC001 DC    A(MEM_NAME,SELECT_LEN,0,F8+X'80000000')\nDDNAME   DC    CL8' '\nMEM_NAME DC    CL8' '\nNON_WILD DC    CL8' '\nADRCTRY  DS    F\nMVC_DD   MVC   DDNAME(0),0(R3)\nMVC_MEM  MVC   MEM_NAME(0),0(R3)\nMVC_STEM MVC   0(0,R2),0(R3)\n         SPACE 2\nNON_WILD_TR DC 256AL1(*-NON_WILD_TR)\n         ORG   NON_WILD_TR+C'*'\n         DC    X'FF'\n         ORG   NON_WILD_TR+C'%'\n         DC    X'FF'\n         ORG\n         SPACE 2\nVAR_NAME DS    0CL250\n         DS    CL245\nTAIL     DS    CL5\n         SPACE 2\n         LTORG\n         TITLE            '<< REXX - Get PDS directory entry           X\n                                                 DSECTs and EQUates >>'\n         YREGS\n         SPACE 2\n       IRXENVB\n         SPACE 2\n       IRXEXTE\n         SPACE 2\n       IRXSHVB\n         SPACE 2\n       IRXEFPL\n         SPACE 2\n      IRXARGTB\n         SPACE 2\n      IRXEVALB\n         SPACE 2\nDRCT00D  DSECT\nDRCTPREF DS   0D        Prefix area double word aligned.\nDRCTSIZ  DS   F         Size of table (in bytes).\nDRCTCNT  DS   H         Number of directory entries.\nDRCTCON  DS   H         Concatenation levels.\n*                End of prefix area\nDRCTNTRY DS   0CL14     (Note minimum size).\nMEMNAME  DS   CL8       Member name.\nMEMTTR   DS   XL3       Member \"ttr\" location.\nMEMCON   DS   XL1       Member concatenation level.\n         DS   XL1       Reserved.\nMEMLEN   DS   XL1       Number of user halfwords\nMEMALIAS EQU  X'80'     Mask for an ALIAS designation.\nMEMTTRNS EQU  X'60'     Mask for # of \"ttrn\" halfwords.\nMEMHALF  DS   0H        Member \"user data\".\n         END  SCCPDSD\n./ ADD NAME=SCCWC001 0108-95180-95229-1033-00139-00122-00000-PST0705\n* ** ** ** ** ** ** ** ** ** ** ** * ** ** ** ** ** ** ** ** ** ** ** *\n*\n* Program name :  SCCWC001\n*\n* Function:       Determine if the selection parameter (which may\n*                 contain 'wildcard' specifications of * and %) is\n*                 matched to the target parameter.\n*\n*                 A wildcard value of percent sign (or x'FF') means\n*                 the corresponding column in the target must exist.\n*                 A wildcard value of asterisk will match to any\n*                 string of any length (including 0) in the target.\n*\n*                 Multiple wildcard specifications are valid.\n*\n* Parameters:  1. The 'selection' field. A string of characters which\n*                 may contain 'wildcard' values as described above.\n*                 All non-wildcard values are compared for an exact\n*                 match against the target parameter.\n*\n*              2. Fullword field whose hexadecimal value is the\n*                 length of parameter 1.\n*\n*              3. The 'target' field. This (sub)field is what the\n*                 'selection' parameter is attempting to match.\n*\n*              4. Fullword field whose hexadecimal value is the\n*                 length of parameter 3.\n*\n* Output:      SCCWC001 produces no output parameter. It sets the\n*              condition code to zero if a match is made and sets the\n*              condition code to other than zero if no match is made.\n*              (No meaning other than 'not equal' should be derived\n*              from condition code settings of 1 or 2; condition code\n*              3 should never be set.)\n*\n* Updates:\n*     Jun. 1995    - R. Ryerse. Original composition.\n*\n* ** ** ** ** ** ** ** ** ** ** ** * ** ** ** ** ** ** ** ** ** ** ** *\nSCCWC001 ID    R12\n         STM   R14,R12,12(R13)\n         LR    R12,R15\n         B     START\nFORCE_EQUAL DS 0H\n         SR    R0,R0\n         B     RTNXT\nFORCE_LOW  DS  0H\n         CLI   SCCWC001,X'FF'\n         B     RTNXT\nFORCE_HIGH  DS 0H\n         CLI   SCCWC001,X'00'\nRTNXT    DS    0H\n         LA    R0,0                  Need a convenient zero to\n         ST    R0,16(,R13)              set R15 to zero.\n         LM    R14,R12,12(R13)       Re-set callers registers.\n         BR    R14                   Return to caller.\n         SPACE 3\nSTART    DS    0H\n         XC    A_STAR,A_STAR         We have no asterisk (yet).\n         LM    R3,R6,0(R1)           Pick-up parameter addresses.\n         L     SELECT_COUNT,0(,R4)   Get length(select).\n         L     TARGET_COUNT,0(,R6)   Get length(target).\n         LA    R1,0(TARGET_COUNT,TARGET)\n         LA    R7,*+4\n         BCTR  R1,0\n         CLI   0(R1),C' '\n         BNE   *+6\n         BCTR  TARGET_COUNT,R7\n         LA    R7,LOOP\nLOOP     DS    0H            The major loop.\n         CLI   0(SELECT),C'*'        Match everything?\n         BNE   NOT_ASTERISK             -no -\n         LA    R7,LOOP@                 -yes-   Switch to minor loop\n         B     COUNT_SELECT                        and continue.\nNOT_ASTERISK   DS    0H\n         CLI   0(SELECT),C'%'        Match any character?\n         BE    COUNT_TARGET             -yes-\n         CLC   0(1,SELECT),0(TARGET) Matched?\n         BNE   RE_LOOP                  -no - double check needed.\nCOUNT_TARGET   DS    0H\n         LA    TARGET,1(,TARGET)     Step along to next 'target' byte.\n         BCT   TARGET_COUNT,COUNT_SELECT  Count and continue.\n         B     END_OF_TARGET         'Target' is exhausted.\nCOUNT_SELECT   DS    0H\n         LA    SELECT,1(,SELECT)     Step along to next 'select' byte.\n         BCTR  SELECT_COUNT,R7       Count the select and loop.\n         SPACE 2\n* The 'select' field is exhausted but 'target' is not.\n         LA    R0,LOOP@              Was last 'select' byte\n         CR    R0,R7                    an asterisk?\n         BE    RTNXT                       -yes-   We have a match\nRE_LOOP  DS    0H\n         LM    SELECT,TARGET_COUNT,A_STAR\n         LTR   SELECT,SELECT         Was there a previous asterisk?\n         BZ    FORCE_LOW                -no -\n         LA    TARGET,1(,TARGET)     Post asterisk matched plus one\n         BCT   TARGET_COUNT,LOOP@@      and length minus one.\n         B     FORCE_LOW             Target went exhausted.\nEND_OF_TARGET  DS    0H\n         LA    SELECT,1(,SELECT)     Step along to next 'select' byte.\n         BCT   SELECT_COUNT,*+8      Count 'select'.\n         B     FORCE_EQUAL           'Select' equally exhausted.\n         CLI   0(SELECT),C'*'        Afterthought '*'\n         BE    END_OF_TARGET            -yes-   Keep checking.\n         B     FORCE_HIGH               -no -   No match.\n         EJECT\nLOOP@    DS    0H            After '*' in select.\n         CLI   0(SELECT),C'*'        Another asterisk?\n         BE    COUNT_SELECT@            -yes-   Really has no meaning.\n         CLI   0(SELECT),C'%'        Looking for any character?\n         BNE   LOOP@@                   -no -\n         LA    TARGET,1(,TARGET)     Step along to next 'target' byte.\n         BCT   TARGET_COUNT,COUNT_SELECT@ Decrement 'target' count.\n         B     END_OF_TARGET@        'Target' is exhausted.\nCOUNT_SELECT@  DS    0H\n         LA    SELECT,1(,SELECT)     Step along to next 'select' byte.\n         BCTR  SELECT_COUNT,R7       Count the select and loop.\n         B     FORCE_EQUAL           'Select' is exhausted.\nEND_OF_TARGET@ DS    0H\n         BCT   SELECT_COUNT,FORCE_LOW Count 'select'. No match if more.\n         B     FORCE_EQUAL           'Select' equally exhausted.\nLOOP@@   DS    0H\n         LA    R7,LOOP               Revert to major loop.\n         STM   SELECT,TARGET_COUNT,A_STAR\n         CLC   0(1,SELECT),0(TARGET) Matched?\n         BE    COUNT_TARGET             -yes-   Jump into major loop.\n         LA    TARGET,1(,TARGET)     Step along to next 'target' byte.\n         BCT   TARGET_COUNT,LOOP@@+4 Decrement 'target' count. Loop.\n         B     RTNXT                 LOOP@@+8 has set condition code.\n         SPACE 3\n         DS    0D\nA_STAR   DS    XL16\n         YREGS\nSELECT         EQU   R3\nSELECT_COUNT   EQU   R4\nTARGET         EQU   R5\nTARGET_COUNT   EQU   R6\n         END   SCCWC001\n./ ADD NAME=STSS383  0131-95310-98218-0839-00577-00710-00000-PST0705\nSS383    TITLE                     '<< Load/search a PDS directory     >\n                                                      Documentation >>'\n* ** ** ** ** ** ** ** ** ** ** ** * ** ** ** ** ** ** ** ** ** ** ** *\n*\n* Program name :  STSS383\n*\n* Function:       Build and/or search an in-core directory of a\n*                 specified partitioned data set.\n*\n* Parameters:     Be aware that the number of parameters passed to this\n*                 routine determines the funtion to be performed\n*\n*                 When there are no parameters, STSS383 releases all\n*                 the tables it has built.\n*\n*                 When there is one parameter, STSS383 releases the\n*                 the table for the specified DDNAME.\n*\n*                 When there are two parameters, STSS383 returns the\n*                 address of the table for the specified DDNAME.\n*\n*                 When there are three parameters, STSS383 matches\n*                 the specified member name and provides\n*                 addressability to the directory entry of the latest\n*                 version of that memeber.\n*\n*   1. In all cases (except when there are no parameters) the 1st\n*      parameter is an eight byte field containing the value of the\n*      DDNAME which STSS383 must act upon.\n*\n*   2. In the case where there are two parameters, the 2nd parameter is\n*      a fullword \"cell\" where STSS383 puts the address of the\n*      structure mapped as follows:\n*\n*         DRCT00D  DSECT\n*         DRCTPREF DS   0D        Prefix area double word aligned.\n*         DRCTSIZ  DS   F         Size of table (in bytes).\n*         DRCTCNT  DS   H         Number of directory entries.\n*         DRCTCON  DS   H         Concatenation levels.\n*         *                End of prefix area\n*         DRCTNTRY DS   0CL14     (Note minimum size).\n*         MEMNAME  DS   CL8       Member name.\n*         MEMTTR   DS   XL3       Member \"ttr\" location.\n*         MEMCON   DS   XL1       Member concatenation level.\n*                  DS   XL1       Reserved.\n*         MEMLEN   DS   XL1       Number of user halfwords\n*         MEMALIAS EQU  X'80'     Mask for an ALIAS designation.\n*         MEMTTRNS EQU  X'60'     Mask for # of \"ttrn\" halfwords.\n*         MEMHALF  DS   0H        Member \"user data\".\n*\n*      Note that the mapping above shows the table \"prefix\" area\n*      and one memeber.\n*\n*      In the case where there are three parameters, the 2nd parameter\n*      is an eight byte field containing the member name to be matched.\n         EJECT\n*   3. The 3rd parameter is a fullword where STSS383 places the\n*      address of the entry for the requested member.\n*      Zero signifies a \"not-found\".\n*\n* ** ** ** ** ** ** ** ** ** ** ** * ** ** ** ** ** ** ** ** ** ** ** *\n         TITLE                     '<< load/search a pds directory     >\n                                            initialization per call >>'\nSTSS383  ID    R12,AMODE=31,RMODE=24\n         SPACE 2\n         PRINT NOGEN\n         USING IHADCB,R11\n         STM   R14,R12,12(R13)     Save the callers registers\n         LR    R12,R15             Establish my base register.\n         LA    R15,SAVEAREA        Add\n         ST    R13,SAVEAREA+4         myself to the\n         ST    R15,8(,R13)               save area chain\n         LR    R13,R15             Finally linkup savearea chain.\n         ST    R1,APARMS           Save parameter list address.\n         LA    R11,DRCTDCB\n         MVI   COBOLSW,X'00'       Indicate non-COBOL caller.\n         XC    RC,RC               Pre-clear return code\n         XC    HCONCAT,HCONCAT        concatenation level\n         XC    ALLEN,ALLEN               and total length.\n         LTR   R1,R1               Any parameters?\n         BZ    FREEALL                -no -  Go free acquired areas.\n         TM    0(R1),X'80'         Only one parameter?\n         BO    FREEONE                -yes-  Go free acquired area.\n         TM    4(R1),X'80'         Did I get 2 parameters?\n         BO    *+12                   -yes-\n         TM    8(R1),X'80'         Did I get 3 parameters?\n         BZ    BADPARMS              -no - Something wrong here.\n         L     R3,0(,R1)           Addressablity to parameters.\n         MVC   DCBDDNAM,0(R3)\n         LA    R5,DDTBL-DDNTRY     Pre-set for table search.\nNXTDD    DS    0H\n         LA    R5,DDNTRY(0,R5)     Point to next table entry.\n         CLC   BLANK8,0(R5)        At end of active entries?\n         BE    SETDD                    -yes-\n         CLC   DCBDDNAM,0(R5)\n         BE    PARMOUT\n         C     R5,=A(DDLAST)       Any more entries?\n         BL    NXTDD                  -yes-  Go inspect them.\n         B     XTBL                   -no -  Abort.\nSETDD    DS    0H\n         MVC   0(8,R5),0(R3)       Save the DDNAME in the table entry.\n         ST    R5,ADDNTRY          Save address of this entry.\n         OPEN  ((R11)),MODE=31\n         LA    R0,ATBL0            The first entry\n         ST    R0,AATBL               is the current entry.\n         L     R0,GETMAIN_AVAIL    64K minus prefix (8) and 1 minimum\n         ST    R0,TBLEN               entry is the length available.\n         L     R0,GETMAIN_SIZE     Want 64K of virtual storage.\n       GETMAIN R,LV=(0)\n         MVC   0(4,R1),GETMAIN_SIZE\n         L     R5,ADDNTRY          Point to my table entry so I can\n         ST    R1,8(0,R5)             save the storage address\n         ST    R1,ATBL0                  also at index entry.\n         OI    ATBL0,X'80'         Say GETMAIN'd area.\n         LA    R1,8(0,R1)          Point to the 1st member area and\n         ST    R1,ATBLNTRY               1st member address.\n         SR    R8,R8               Initialize member counter.\n         TITLE                     '<< Load/search a pds directory     >\n                                          mainline (including read) >>'\nREADDRCT DS    0H\n         AMODE24\n         PRINT   GEN\n         GET   (R11)\n         AMODE31\n         MVC   DRCTBLK,0(R1)\n         BAL   R9,DEBLOCK          De-block a directory block.\n         CLC   =XL8'FFFFFFFFFFFFFFFF',0(R7)\n         BNE   READDRCT            More directory blocks to come.\n         FEOV  (R11)               Get next DD in the concatenation.\n         PRINT NOGEN\n         LH    R9,HCONCAT          Next concatenation exists so\n         LA    R9,1(,R9)              count 1 more and\n         STH   R9,HCONCAT                save the sum.\n         BAL   R9,NEXT_INDEX       I'll need another sector.\n         B     READDRCT            Go for more.\nEODRCT   DS    0H\n         CLOSE ((R11)),MODE=31\n         MVC   DRCTDCB(DCB_LEN),A_DCB\n         BAL   R9,TBLOUT           Format into one table.\nPARMOUT  DS    0H\n         L     R5,ADDNTRY          Pickup my entry for this DD and\n         L     R2,8(,R5)              get the table address for it.\n         L     R1,APARMS           Restore my parameter list address.\n         TM    4(R1),X'80'         Two parameters?\n         BZ    SEARCH0                -no -  Must be three parms.\n         L     R3,4(,R1)           Get the address of the 2nd parm.\n         ST    R2,0(,R3)           Give the caller the table address.\n         B     RTNXT               All done.\nSEARCH0  DS    0H\n         BAL   R9,SEARCH           Search for a member.\nRTNXT    DS    0H\n         L     R15,RC              Set the return code.\n         L     R13,SAVEAREA+4      Get the caller's savearea\n         L     R14,12(,R13)        Get the caller's return address.\n         LM    R0,R12,20(R13)      Restore the caller's registers\n         XC    8(4,R13),8(R13)     Take a link off the savearea chain.\n         BR    R14                 Return to the caller.\n         TITLE                     '<< Load/search a pds directory     >\n                                         de-block record into table >>'\nUSERIN   MVC   14(0,R4),12(R7)\nDEBLOCK9 DS    F\n         SPACE 1\nDEBLOCK  DS    0H\n         ST    R9,DEBLOCK9         Save the BAL return address.\n         LH    R2,DRCTBLK          Get the length\n         BCTR  R2,0                   of data\n         BCTR  R2,0                       within the block.\n         LA    R3,42(0,R2)         Do I have enough\n         C     R3,TBLEN               room in the table?\n         BL    *+8                       -yes-\n         BAL   R9,NEWSPAC                -no -  Get some more space.\n         SR    R3,R3               Pre-clear a work register.\n         LM    R4,R7,ATBLNTRY      Get various pointers.\nDEBLOCK1 DS    0H\n         CLC   =XL8'FFFFFFFFFFFFFFFF',0(R7)\n         BE    DEBLOCK8            Block is finished.\n         LA    R8,1(0,R8)          Increment the memeber counter.\n         IC    R3,11(R7)           Get number of user halfwords\n         N     R3,=F'31'              voiding the high order 3 bits.\n         SLL   R3,1                Halfword to bytes and\n         LA    R3,14(0,R3)            include the overhead.\n         SR    R6,R3               Decrement table length.\n         AR    R5,R3               Increment total length.\n         MVC   0(11,R4),0(R7)      Get the member name and TTR.\n         MVC   13(1,R4),11(R7)     Get the number of user halfwords.\n         MVC   11(1,R4),CONCAT     Get the concatenation level and\n         MVI   12(R4),X'00'           set a convenient halfword.\n         SH    R3,=H'15'           Decrement by overhead length + 1.\n         BNP   DEBLOCK2            There is nothing left.\n         EX    R3,USERIN           Get the user data.\nDEBLOCK2 DS    0H\n         LA    R3,13(,R3)          Restore the member length.\n         AR    R7,R3               Point to next source member\n         LA    R4,2(R3,R4)         Point to next target member.\n         SR    R2,R3               Decrement the block residual size.\n         BP    DEBLOCK1            There is still more to come.\nDEBLOCK8 DS    0H\n         STM   R4,R6,ATBLNTRY      Replace all that good stuff.\n         L     R9,DEBLOCK9         Get the return address.\n         BR    R9                  Exit this BAL procedure.\n         TITLE                     '<< Load/search a pds directory     >\n                   Switch to a new sector  /  Allocate more storage >>'\nGETMAIN_SIZE   DC  A(GETMAIN_VALUE)\nGETMAIN_AVAIL  DC  A(AVAIL_VALUE)\nTBLNTRYS EQU   64                  Maximum number of tables.\n         SPACE 1\nAATBL    DC    A(ATBL0)            Current entry of table below.\nATBL0    DS    (TBLNTRYS-1)F\nATBLF    DS    F\n         SPACE 1\nNEXT_INDEX  DS 0H\n         L     R3,AATBL            Already at\n         C     R3,=A(ATBLF)           last cell?\n         BNL   BADTBL                    -yes-   down the tubes.\n         LA    R3,4(0,R3)                -no - point to next cell and\n         ST    R3,AATBL                           save the cell address\n         L     R4,ATBLNTRY         Point no temp table slot.\n         MVI   0(R4),X'FF'         Fill slot\n         MVC   1(10,R4),0(R4)         with a\n         MVC   11(1,R4),CONCAT           high-value\n         XC    12(2,R4),12(R4)              entry.\n         LA    R4,14(0,R4)         Point beyond dummy slot in temp tbl.\n         ST    R4,ATBLNTRY         Save the address for later ntrys.\n         ST    R4,0(0,R3)          Fill cell for next temp table.\n         L     R6,TBLEN            Decrement\n         S     R6,=F'14'              available storage\n         ST    R6,TBLEN                  and save it.\n         BR    R9                  Exit via bal register.\n         SPACE 3\nNEWSPAC0 DS    10F\n         SPACE 1\nNEWSPAC  DS    0H\n         STM   R0,R9,NEWSPAC0      Save all those values.\n         BAL   R9,NEXT_INDEX       Allocate a new table entry.\n         MVC   TBLEN,GETMAIN_AVAIL Set the 'storage available'.\n         L     R0,GETMAIN_SIZE     64K.\n       GETMAIN R,LV=(0)\n         MVC   0(4,R1),GETMAIN_SIZE\n         L     R9,AATBL            Point to index entry.\n         ST    R1,0(0,R9)          The index knows where to save data.\n         OI    0(R9),X'80'         Set GETMAIN'd indicator.\n         LA    R1,8(,R1)           Point beyond the prefix area.\n         ST    R1,ATBLNTRY         Save the virtual storage address.\n         LM    R0,R9,NEWSPAC0      Restore all those registers.\n         BR    R9                  Exit via BAL register.\n         TITLE                     '<< Load/search a pds directory     >\n                                                 Load callers table >>'\nTBLOUT   DS    0H\n         L     R3,ADDNTRY          Get address for the DD table entry.\n         LA    R2,ATBL0            Is the first index\n         C     R2,AATBL               the current index?\n         BNE   TBLOUT1                   -no -\n         L     R2,ATBL0            Get the primary table address\n         LA    R2,0(,R2)           Clear the high order bit.\n         ST    R2,8(0,R3)          Put address into DDtable entry.\n         STH   R8,4(R2)            Put the memeber count, and\n         MVC   6(2,R2),HCONCAT        the concatenation level.\n         BR    R9                  That's all there is to it.\nTBLOUT1  DS    0H\n         L     R2,ATBLNTRY\n         MVI   0(R2),X'FF'         Set\n         MVC   1(10,R2),0(R2)         last\n         MVC   11(1,R2),CONCAT           table\n         XC    12(2,R2),12(R2)              entry.\n         L     R2,ALLEN            Get total length\n         LA    R2,16(,R2)             of storage required.\n         LR    R0,R2               Use R0 for GETMAIN\n       GETMAIN R,LV=(0)\n         ST    R1,8(0,R3)          Put address into DDtable entry.\n         ST    R2,0(,R1)           Length of GETMAIN now in table.\n         STH   R8,4(,R1)           Set number of directory entries,\n         MVC   6(2,R1),HCONCAT        and number of concatentaions.\n         LA    R8,8(0,R1)          Establish table base.\n         SR    R6,R6               Clear work register.\n         MVC   SAVEAREA+12(TBLNTRYS*4),ATBL0\n         LA    R2,ATBL0-4          Set index pointer.\n         LA    R15,*+4             Top of loop address\n         SPACE 1\n         LA    R2,4(,R2)           Point to next storage index.\n         C     R2,AATBL            Beyond allocated indexes?\n         BH    TBLOUT2                -yes-\n         TM    0(R2),X'80'         GETMAIN'd area\n         BZR   R15                    -no -   Loop back.\n         L     R14,0(,R2)          Adjust the address\n         LA    R14,8(,R14)            for the prefix area\n         ST    R14,0(,R2)                and put it back.\n         BR    R15                 Loop\nTBLOUT2  DS    0H\n         LA    R2,ATBL0            Get address of 1st storage index.\n         LR    R5,R2               Say this points to the least.\n         L     R3,ATBL0            Get address of 1st storage sector.\nTBLOUT3  DS    0H\n         LA    R2,4(0,R2)          Point to next storage index.\n         C     R2,AATBL            Out of indexes?\n         BH    TBLOUT4                -yes- Ready to move.\n         L     R4,0(0,R2)          Get address of comparator.\n         CLC   0(8,R4),0(R3)       This table entry less than current?\n         BNL   TBLOUT3                -no - keep looking\n         LR    R3,R4                  -yes- save sector address and\n         LR    R5,R2                        index address.\n         B     TBLOUT3             Keep looking.\nTBLOUT4  DS    0H\n         CLC   =XL8'FFFFFFFFFFFFFFFF',0(R3) Lowest at high-values?\n         BE    TBLOUT5                         -yes- table is complete.\n         IC    R6,13(R3)           Get number of\n         N     R6,=F'31'              'user' halfwords\n         SLL   R6,1                      into a length.\n         LA    R6,13(0,R6)         Incement by fixed length minus 1\n         EX    R6,MVC_DRCTRY          to pick-up the directry entry.\n         LA    R6,1(0,R6)          Get true entry length.\n         AR    R3,R6               Point to next temp entry and\n         ST    R3,0(0,R5)             reset the sector address.\n         AR    R8,R6               Point to next final slot.\n         B     TBLOUT2             Start again.\nMVC_DRCTRY     MVC   0(0,R8),0(R3) Move in the entry.\nTBLOUT5  DS    0H\n         MVC   ATBL0(TBLNTRYS*4),SAVEAREA+12\n         LA    R3,ATBL0            Will need more indexes.\nTBLOUT6  DS    0H\n         TM    0(R3),X'80'         GETMAIN'd area.\n         BZ    TBLOUT7                -no -\n         NI    0(R3),X'7F'         Turn off the bit.\n         L     R2,0(,R3)           Get storage address.\n         L     R0,0(,R2)           Get storage length.\n      FREEMAIN R,LV=(0),A=(R2)\nTBLOUT7  DS    0H\n         LA    R3,4(0,R3)          Point to next index.\n         C     R3,AATBL            All done?\n         BHR   R9                     -yes-  Exit via BAL register.\n         B     TBLOUT6                -no -  Go free it.\n         TITLE                     '<< Load/search a pds directory     >\n                                        Warnings, errors and abends >>'\nABEND    DS    0H\n         ABEND 383,DUMP,STEP\n         SPACE 3\nBADPARMS DS    0H\n         WTO   'STSS383  :  Incorrect number of parameters. Run abortedx\n               ',ROUTCDE=(11),DESC=(6)\n         B     ABEND\n         SPACE 3\nBADIO    DS    0H\n         WTO   'STSS383  :  Raised unrecognized sense bits from I/O',  x\n               ROUTCDE=(11),DESC=(6)\n         B     ABEND\n         SPACE 3\nBADTBL   DS    0H\n         WTO   'STSS383  :  Excessive table allocations. run aborted', x\n               ROUTCDE=(11),DESC=(6)\n         B     ABEND\n         SPACE 3\nXTBL     DS    0H\n         WTO   'STSS383  :  Excessive ddname requests. run aborted',   x\n               ROUTCDE=(11),DESC=(6)\n         B     ABEND\n         TITLE                     '<< Load/search a pds directory     >\n                                Release previously acquired storage >>'\nFREEALL  DS    0H\n         LA    R6,DDTBL-DDNTRY     Pre-set for indexes.\n         LA    R6,DDNTRY(,R6)      Point to next index.\n         CLC   BLANK8,0(R6)        Active index?\n         BE    RTNXT                  -no -  All done.\n         BAL   R9,FREEANY          Free this index and\n         MVC   0(8,R6),BLANK8         de-activate it.\n         B     FREEALL+4           Loop for next index.\n         SPACE 3\nFREEONE  DS    0H\n         L     R3,0(,R1)           Address the 1st parameter.\n         LA    R6,DDTBL-DDNTRY     Pre-set for indexes.\n         LA    R6,DDNTRY(,R6)      Point to next index.\n         CLC   BLANK8,0(R6)        Active index?\n         BE    RTNXT                  -no -  All done.\n         CLC   0(8,R6),0(R3)       Is the DDNAME matched?\n         BE    *+14                   -yes-\n         CLC   8(4,R6),0(R3)       How about table address?\n         BNE   FREEONE+8              -no -  Go bump to next index.\n         BAL   R9,FREEANY          Free this index.\n         LA    R7,DDLAST-1         Calculate residual\n         SR    R7,R6                  length of index entries\n         EX    R7,MINUS_DDNTRY           to eliminate this entry.\n         B     RTNXT               All done.\n         SPACE 1\nMINUS_DDNTRY   MVC   0(0,R6),DDNTRY(R6)  Overlay/lop off this entry.\n         SPACE 3\nFREEANY  DS    0H\n         L     R2,8(0,R6)          Get the directory table address.\n         L     R0,0(,R2)           Get the directory table length.\n         LTR   R0,R0               Table formatted for COBOL?\n         BNZ   *+12                   -no -\n         LH    R0,4(,R2)              -yes-   Calculate\n         MH    R0,=H'22'                         its length.\n      FREEMAIN R,LV=(0),A=(R2)\n         BR    R9                  Exit via BAL register.\n         TITLE                     '<< Load/search a pds directory     >\n                                                   Search routines >>'\nSRCHCLC  CLC   0(0,R3),0(R4)\nSRCHMAX  DS    F\n         SPACE 2\nSEARCH   DS    0H\n         L     R1,APARMS           Get parameter list address.\n         L     R3,4(,R1)           Address the 2nd and\n         L     R8,8(,R1)              3rd parameters.\n         LA    R1,8(,R3)           Pre-set end-of-search-name address\n         TRT   0(8,R3),TOBLNK      Find a blank.\n         BCTR  R1,0                Calculate machine instruction\n         SR    R1,R3                  length of the search name.\n         L     R5,ADDNTRY          Get the index.\n         L     R4,8(,R5)           Get the directory table address.\n         LH    R7,4(,R4)           Get the number of directory entries.\n         SR    R6,R6               Thereby calculate\n         M     R6,=F'22'              the address\n         LA    R6,8(R4,R7)               beyond the last entry and\n         ST    R6,SRCHMAX                   save the address.\n         L     R2,0(,R4)           Get the directory table length.\n         LTR   R2,R2               COBOL formatted table.\n         BZ    SEARCH40               -yes-\n         LA    R6,8(R4,R2)         Address beyond the last table entry\n         ST    R6,SRCHMAX             and save it.\nSEARCH10 DS    0H\n         LH    R2,4(,R4)           Get the member count.\n         LA    R4,8(,R4)           Point to the first table entry.\nSEARCH11 DS    0H\n         EX    R1,SRCHCLC          Matched?\n         BE    SEARCH60               -yes-\n         BL    SEARCH70               -never-\n         IC    R6,13(,R4)          Point\n         N     R6,=F'31'              to\n         SLL   R6,1                     next\n         LA    R4,14(R6,R4)                entry.\n         BCT   R2,SEARCH11         Decrement the count and loop back.\n         B     SEARCH70            No match.\n         EJECT\nSEARCH40 DS    0H\n         LA    R2,3                Set 2's exponent\n         LA    R7,15                  and maximum entries.\n         CH    R7,4(,R4)           Are there less than 15 entries.\n         BNL   SEARCH10               -yes-  Use a serial search.\n         LA    R14,*+4              Set top-of-loop address.\n         LA    R2,1(,R2)           Increment 2's exponent.\n         SLL   R7,1                Double\n         LA    R7,1(,R7)              the maximum entries.\n         CH    R7,4(,R4)           High enough yet?\n         BLR   R14                    -no -  Keep bumping.\n         LA    R7,1(,R7)           Double the maximum to a power of 2\n         SRL   R7,1                   for the initial incr/decr count.\n         SR    R6,R6               Calculate incr/decr width\n         M     R6,=F'22'              from the count.\n         LR    R6,R7               Save the value\n         S     R6,=F'22'              minus 1 entry width.\n         LA    R4,8(R4,R6)         Point to approximately mid-table.\nSEARCH42 DS    0H\n         SRL   R7,1                Cut the incr/decr value in half.\n         C     R4,SRCHMAX          Beyond the table?\n         BNL   *+16                   -yes-\n         EX    R1,SRCHCLC          Are we matched?\n         BE    SEARCH60               -yes-  Still need to dig further.\n         BH    *+14                   -no, but need to look higher\n         SR    R4,R7                  -no, but need to look lower.\n         BCT   R2,SEARCH42         Decrement the count and try again.\n         B     SEARCH45            Need to take one last peek.\n         SPACE 1\n         AR    R4,R7               Move the address higher.\n         BCT   R2,SEARCH42         Decrement the count and try again.\nSEARCH45 DS    0H\n         C     R4,SRCHMAX          Beyond the table?\n         BNL   SEARCH70               -yes-\n         EX    R1,SRCHCLC          One last attempt to match\n         BNE   SEARCH70               wasn't satisfied either.\n         EJECT\nSEARCH60 DS    0H\n         ST    R4,0(,R8)           We may have the right entry already.\n         LR    R7,R4               Keep the entry address.\n         IC    R6,13(,R4)          Point\n         N     R6,=F'31'              to\n         SLL   R6,1                      next\n         LA    R4,14(R6,R4)                 entry.\n         C     R4,SRCHMAX          Too far?\n         BNL   SEARCH80               -yes-\n         EX    R1,SRCHCLC          Still matched?\n         BNE   SEARCH80               -no -  I'm satisfied.\n         CLC   0(8,R4),0(R7)       Concatenation of equal member names?\n         BE    SEARCH60+6             -yes-  Don't want the concat.\n         B     SEARCH60               -no -  Re-set and keep trying.\nSEARCH70 DS    0H\n         XC    0(4,R8),0(R8)       Indicate a \"no-match\"\n         BR    R9                  Exit via BAL register.\n         SPACE 3\nSEARCH80 DS    0H\n         TM    COBOLSW,X'40'       COBOL caller?\n         BZR   R9                     -no -  Exit via BAL register.\n         L     R3,8(,R5)           Address of\n         LA    R3,8(,R3)              beginning of the table.\n         SR    R7,R3               Displacement to the match.\n         SR    R6,R6               Width\n         D     R6,=F'22'              divided by 22 = count\n         LA    R7,1(,R7)                 relative to 1.\n         ST    R7,0(,R8)           Give COBOL caller subscript value.\n         BR    R9                  Exit via BAL register.\n         SPACE 1\n         DS    0F\n         SPACE 1\n         TITLE                     '<< Load/search a pds directory     >\n                                                      Storage areas >>'\nRC       DC    F'0'                Return code.\n         SPACE 1\nATBLNTRY DS    F\nALLEN    DC    F'0'\nTBLEN    DC    A(4096*16-14-8)\n         DC    A(DRCTBLK+2)\n         SPACE 1\nAPARMS   DS    F\n         SPACE 1\nSAVEAREA DS    (3+TBLNTRYS)F\n         SPACE 1\nTOBLNK   DC    256X'00'\n         ORG   TOBLNK+C' '\n         DC    X'01'\n         ORG\n         SPACE 1\nHCONCAT  DS    0H\n         DC    X'0'\nCONCAT   DC    XL1'0'\n         EJECT\nADDNTRY  DS    F\n         SPACE 2\nDDTBL    DS    0F\n         DC    CL8'        ',A(0)\n         DC    CL8'        ',A(0)\n         DC    CL8'        ',A(0)\n         DC    CL8'        ',A(0)\n         DC    CL8'        ',A(0)\n         DC    CL8'        ',A(0)\n         DC    CL8'        ',A(0)\n         DC    CL8'        ',A(0)\n         DC    CL8'        ',A(0)\n         DC    CL8'        ',A(0)\n         DC    CL8'        ',A(0)\n         DC    CL8'        ',A(0)\n         DC    CL8'        ',A(0)\n         DC    CL8'        ',A(0)\n         DC    CL8'        ',A(0)\n         DC    CL8'        ',A(0)\nDDLAST   DC    CL8'        ',A(0)\nDDNTRY   EQU   *-DDLAST\nBLANK8   DC    CL8'        '      These two definitions must\nA0       DC    A(0)                  follow DDLAST.\n         SPACE 2\nCOBOLSW  DS    XL1\n         SPACE 3\n         EJECT\n         LTORG\n         TITLE                     '<< Load/search a pds directory     >\n                                                I/O control blocks >>'\n         DS    0D\nDRCTDCB  DCB   DSORG=PS,                                               x\n               EODAD=EODRCT,                                           x\n               MACRF=GL,                                               x\n               BLKSIZE=256,RECFM=F,LRECL=256,                          x\n               DDNAME=SYSUT1\n         DS    0D\nDCB_LEN  EQU   *-DRCTDCB\nA_DCB    DCB   DSORG=PS,                                               x\n               EODAD=EODRCT,                                           x\n               MACRF=GL,                                               x\n               BLKSIZE=256,RECFM=F,LRECL=256,                          x\n               DDNAME=SYSUT1\n         DS    0D\nDRCTKEY  DS    CL8\nDRCTBLK  DS    CL256\n         SPACE 1\n         TITLE                     '<< Load/search a pds directory     >\n                                                 DSECTs and EQUates >>'\nGETMAIN_VALUE  EQU   4096*16\nAVAIL_VALUE    EQU   GETMAIN_VALUE-8-14\n         YREGS\n         PRINT NOGEN\n         DCBD  DSORG=(QS),DEVD=(DA)\n         END   STSS383\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT752/FILE752.XMI", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT752", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}