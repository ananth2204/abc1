{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "SBGOLOB", "INMTNODE": "A", "INMTUID": "A", "INMFTIME": "20201220013728000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 16871582, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 5600, "INMRECFM": "FB", "INMDIR": 9, "INMDSNAM": "CBT.V500.FILE995.PDS", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 16871582, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 16871582, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"CBT.V500.FILE995.PDS": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 5600, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3340, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "200354", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\xbe'", "DS1LSTAR": "b'\\x01\\x01\\x02'", "DS1TRBAL": "b'\\xcf\\xfc'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xd0\\x00\\x04\\x9a\\xc0\\xd8'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xd0\\x00\\x04\\x9a\\xc0\\xd8'", "b'X\\xf4\\xfd\\xd0\\x00\\x00\\n\\x97\\x00\\x06\\n\\xa8\\x00\\x08\\x01\\x02'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$$$#DATE": {"ttr": 516, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04b\\x00\\x00\\x01\\x19#\\x1f\\x01\\x19#\\x1f\\x00\\x10\\x00\\x0c\\x00\\x0c\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf9\\xf8@@@'", "ispf": {"version": "04.98", "flags": 0, "createdate": "2019-08-19T00:00:00", "modifydate": "2019-08-19T00:10:00", "lines": 12, "newlines": 12, "modlines": 0, "user": "CBT-498"}, "text": "REGULAR CBT TAPE - VERSION 498    FILE:  995\n\n    ORIGINAL DSNAME:  SBGOLOB.CBT498.FILE995\n    ---------------\n                    --RECFM-LRECL-BLKSIZE-DSORG\n                      FB    80    5600    PO\n\n   PDS117I 23 MEMBERS COUNTED; CUMULATIVE SIZE IS 159,982 RECORDS\n\n\nTIME THIS PDS WAS SHIPPED:   08/19/19    00:10:00    UTC-4:00\n\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$LOADNL": {"ttr": 518, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\r\\x00\\x16\\x01\\x02\\x18/\\x01\\x19#\\x0f!5\\x00!\\x00\\x11\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.13", "flags": 0, "createdate": "2002-07-01T00:00:00", "modifydate": "2019-08-18T21:35:16", "lines": 33, "newlines": 17, "modlines": 0, "user": "SBGOLOB"}, "text": "//SBGOLOBA  JOB (ACCT#),S-GOLOB,\n// NOTIFY=&SYSUID,\n// CLASS=B,MSGCLASS=X\n//*\n//*    UNLOAD WYLBUR FILES FOR TSO FROM THE TAPE\n//*\n//LOADNL PROC IPRE='SBGOLOB',OPRE=SBGOLOB,DASN=XXX,LBL=01,XL=NL,\n//            IUNT=563,OUNT=SYSALLDA,IVL=WYLTSO,OVL=WORKE3,DSP2=CATLG,\n//            DSP1=NEW,DSP3='',P=30,S=60,D=224,QUAL=WYLTSO\n//DOLOAD  EXEC PGM=IEBCOPY,REGION=6M\n//SYSPRINT DD SYSOUT=*\n//SYSUT1 DD DISP=SHR,DSN=&IPRE..&DASN,UNIT=&IUNT,\n//       VOL=(,RETAIN,SER=&IVL),LABEL=(&LBL,&XL,EXPDT=98000),\n//       FREE=CLOSE\n//SYSUT2 DD UNIT=&OUNT,VOL=SER=&OVL,DSN=&OPRE..&QUAL..&DASN,\n//       DISP=(&DSP1,&DSP2&DSP3),SPACE=(TRK,(&P,&S,&D),RLSE)\n//SYSIN DD DUMMY\n//  PEND\n//*\n//S0001  EXEC LOADNL,LBL=01,DASN=LIB2.CNTL\n//S0002  EXEC LOADNL,LBL=02,DASN=LIB2.SOURCE\n//S0003  EXEC LOADNL,LBL=03,DASN=LIB2.FIXES\n//S0004  EXEC LOADNL,LBL=04,DASN=SYS2.HELP\n//S0005  EXEC LOADNL,LBL=05,DASN=ASM\n//S0006  EXEC LOADNL,LBL=06,DASN=CNTL\n//S0007  EXEC LOADNL,LBL=07,DASN=DOCLIB\n//S0008  EXEC LOADNL,LBL=08,DASN=HELP\n//S0009  EXEC LOADNL,LBL=09,DASN=MACLIB\n//S0010  EXEC LOADNL,LBL=10,DASN=MACLIBO\n//S0011  EXEC LOADNL,LBL=11,DASN=OBJ\n//S0012  EXEC LOADNL,LBL=12,DASN=MENUS\n//S0013  EXEC LOADNL,LBL=13,DASN=MSGS\n//S0014  EXEC LOADNL,LBL=14,DASN=PROCS\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$PDSLOAD": {"ttr": 520, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x15\\x00\\x14\\x01\\x026_\\x01\\x19#\\x0f!6\\x001\\x00\\x08\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.21", "flags": 0, "createdate": "2002-12-31T00:00:00", "modifydate": "2019-08-18T21:36:14", "lines": 49, "newlines": 8, "modlines": 0, "user": "SBGOLOB"}, "text": "//SBGOLOBL JOB (ACCT#),PDSLOAD,\n// NOTIFY=&SYSUID,\n// CLASS=B,MSGCLASS=X\n//*\n//*    PDSLOAD JOB TO CREATE SOME WYLTSO DATASETS\n//*          FROM THE MEMBERS OF THIS PDS\n//*\n//TSOBATCH EXEC PGM=IKJEFT01\n//SYSTSPRT DD SYSOUT=*\n//SYSTSIN DD *\n   RECEIVE INDS('SBGOLOB.CBT498.FILE995(PDSLOAD)')\n   DSN('SBGOLOB.WYLTSO.LOAD')   VOL(WORKA4)\n/*\n//*\n//PDSLOAD PROC IPDS='SBGOLOB.CBT498.FILE995',      <=== CHANGE\n//             OPRE=SBGOLOB,                       <=== PREFIX\n//             QUAL=WYLTSO,\n//             MEMB=XXX,\n//             OUNT=SYSALLDA,\n//             OVL=WORKA4,\n//             DSP1=NEW,\n//             DSP2=CATLG,\n//             DSP3='',\n//             P=30,S=60,D=44\n//*\n//LOAD   EXEC PGM=PDSLOAD\n//STEPLIB  DD DISP=SHR,DSN=SBGOLOB.WYLTSO.LOAD\n//SYSPRINT DD SYSOUT=*\n//SYSUT1   DD DISP=SHR,DSN=&IPDS(&MEMB)\n//SYSUT2   DD UNIT=&OUNT,VOL=SER=&OVL,\n//             DSN=&OPRE..&QUAL..&MEMB,\n//             DISP=(&DSP1,&DSP2&DSP3),\n//             SPACE=(TRK,(&P,&S,&D),RLSE)\n//  PEND\n//*\n//S001 EXEC PDSLOAD,MEMB=ASM\n//S002 EXEC PDSLOAD,MEMB=CNTL\n//S003 EXEC PDSLOAD,MEMB=DOCLIB\n//S004 EXEC PDSLOAD,MEMB=HELP\n//S005 EXEC PDSLOAD,MEMB=LIB2CNTL\n//S006 EXEC PDSLOAD,MEMB=LIB2FIX\n//S007 EXEC PDSLOAD,MEMB=LIB2SRCE\n//S008 EXEC PDSLOAD,MEMB=MACLIB\n//S009 EXEC PDSLOAD,MEMB=MACLIB0\n//S010 EXEC PDSLOAD,MEMB=MENUSF\n//S011 EXEC PDSLOAD,MEMB=MSGSF\n//S012 EXEC PDSLOAD,MEMB=OBJ\n//S013 EXEC PDSLOAD,MEMB=PROCS\n//S014 EXEC PDSLOAD,MEMB=SYS2HELP\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "@FILE995": {"ttr": 522, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04b\\x00E\\x01\\x19#\\x1f\\x01\\x19#\\x1f\\x00\\t\\x00X\\x00X\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf9\\xf8@@@'", "ispf": {"version": "04.98", "flags": 0, "createdate": "2019-08-19T00:00:00", "modifydate": "2019-08-19T00:09:45", "lines": 88, "newlines": 88, "modlines": 0, "user": "CBT-498"}, "text": "//***FILE 995 contains a Wylbur distribution that is probably       *   FILE 995\n//*           suitable to be installed on a pre-XA MVS system.      *   FILE 995\n//*           The code is written to run on MVS 3.8 and MVS/SP.     *   FILE 995\n//*                                                                 *   FILE 995\n//*           Thanks to Bill Smith for sending this in.             *   FILE 995\n//*                                                                 *   FILE 995\n//*           There are two distribution files containing           *   FILE 995\n//*           whole packages.  These are:                           *   FILE 995\n//*                                                                 *   FILE 995\n//*           WYLTSO  - GZIP AWS tape file with 14 individual       *   FILE 995\n//*                     files.  To install Wylbur on MVS, and       *   FILE 995\n//*                     accessory programs.                         *   FILE 995\n//*                                                                 *   FILE 995\n//*           WYLCMS  - GZIP AWS tape file to install Wylbur        *   FILE 995\n//*                     on CMS.                                     *   FILE 995\n//*                                                                 *   FILE 995\n//*       I have expanded the WYLTSO tape into its 14 files,        *   FILE 995\n//*       which are 14 pds'es, but I have not touched the WYLCMS    *   FILE 995\n//*       tape.  Using WYLCMS is up to you......                    *   FILE 995\n//*                                                                 *   FILE 995\n//*       If you need help with the packaging, my email address:    *   FILE 995\n//*                                                                 *   FILE 995\n//*           email:   sbgolob@cbttape.org                          *   FILE 995\n//*                                                                 *   FILE 995\n//*       TO INSTALL FROM THE GZIP-ED AWS FILES:                    *   FILE 995\n//*                                                                 *   FILE 995\n//*       You need to download the GZIP AWS format files to a PC    *   FILE 995\n//*       in BINARY and unzip them.  They are emulated tapes,       *   FILE 995\n//*       in AWS format.  If you have a real tape drive, the        *   FILE 995\n//*       VTT2TAPE program from CBT File 533 might help you to      *   FILE 995\n//*       cut a real tape from this file.                           *   FILE 995\n//*                                                                 *   FILE 995\n//*       TO INSTALL FROM THE SEPARATE FILES: (14 files from tape)  *   FILE 995\n//*                                                                 *   FILE 995\n//*       The following members are OFFLOAD-ed from the tape        *   FILE 995\n//*       files for WYLTSO:  Use the PDSLOAD program to get them    *   FILE 995\n//*       into PDS'es.                                              *   FILE 995\n//*                                                                 *   FILE 995\n//*       Customize the $PDSLOAD job to conform to your site's      *   FILE 995\n//*       naming conventions, and submit it.                        *   FILE 995\n//*                                                                 *   FILE 995\n//*       ASM                                                       *   FILE 995\n//*       CNTL                                                      *   FILE 995\n//*       DOCLIB                                                    *   FILE 995\n//*       HELP                                                      *   FILE 995\n//*       MACLIB                                                    *   FILE 995\n//*       MACLIBO                                                   *   FILE 995\n//*       OBJ                                                       *   FILE 995\n//*       PROCS                                                     *   FILE 995\n//*       SYS2HELP                                                  *   FILE 995\n//*       LIB2CNTL                                                  *   FILE 995\n//*       LIB2FIX                                                   *   FILE 995\n//*       LIB2SRCE                                                  *   FILE 995\n//*                                                                 *   FILE 995\n//*       These are in FB format, LRECL=80.                         *   FILE 995\n//*                                                                 *   FILE 995\n//*       Then deal with the other two files:                       *   FILE 995\n//*                                                                 *   FILE 995\n//*       Two other files are in a VB format, but I've supplied     *   FILE 995\n//*       FB-80 versions of them, just to make sure that you have   *   FILE 995\n//*       the right material available in this file.                *   FILE 995\n//*       The files are:                                            *   FILE 995\n//*                                                                 *   FILE 995\n//*       MENUS  -  Which should be VB LRECL=84    and              *   FILE 995\n//*       MSGS   -  Which should be VB LRECL=76                     *   FILE 995\n//*                                                                 *   FILE 995\n//*       To try to get it right for you, I've packaged these 2     *   FILE 995\n//*       files in TSO XMIT format, so the VB and LRECL quantities  *   FILE 995\n//*       are proper, when you TSO RECEIVE them.  They are members: *   FILE 995\n//*                                                                 *   FILE 995\n//*       WYLMENUS  -  XMIT of the MENUS dataset                    *   FILE 995\n//*       WYLMSGS   -  XMIT of the MSGS  dataset                    *   FILE 995\n//*                                                                 *   FILE 995\n//*       If you don't have access to TSO RECEIVE, I've FB-80-ized  *   FILE 995\n//*       them, and you can copy the material into VB datasets      *   FILE 995\n//*       that you allocate for yourselves.  These members are:     *   FILE 995\n//*                                                                 *   FILE 995\n//*       MENUSF -  FB-80 version of the MENUS library              *   FILE 995\n//*       MSGSF  -  FB-80 version of the MSGS  library              *   FILE 995\n//*                                                                 *   FILE 995\n//*       Using these datasets, you shouldn't lose any of the       *   FILE 995\n//*       material, because VB, LRECL=84 has 80 bytes of real       *   FILE 995\n//*       data.  The first 4 bytes are the RDW (Record Descriptor   *   FILE 995\n//*       Word).                                                    *   FILE 995\n//*                                                                 *   FILE 995\n//*       Then to install, follow the directions in the CNTL        *   FILE 995\n//*       file to assemble and linkedit.                            *   FILE 995\n//*                                                                 *   FILE 995\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "ASM": {"ttr": 525, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x18\\x01\\x19#\\x0f\\x01\\x19#\\x0f!Trqrq\\x00\\x00\\xe6\\xe8\\xd3\\xc2\\xe4\\xd9@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2019-08-18T00:00:00", "modifydate": "2019-08-18T21:54:18", "lines": 29297, "newlines": 29297, "modlines": 0, "user": "WYLBUR"}, "text": "./ ADD NAME=BEXE,SSI=00000169\nBEXE     TITLE 'EXEC ROUTINES MODULE'\n* PROPERTY OF C. U. C. C. A.\n         SPACE 3\nBEXE     CSECT\n         WIDENT 001\n         USING CPAREA,R12\n         SPACE\n         XTRNS\n         TITLE 'EXEC COMMAND PROCESSOR'\n* ENTRY FOR LOAD COMMAND\n         SPACE\nGOLOAD   DENTER DSSIZ\n         XCALL SCNEXFR             SEE IF RANGE FROM EXTERNAL\n         OI    CPLFLG1,CPFALL      SET DEFAULT ALL\n         XCALL DETRNG              GO GET RANGE IF SPECIFIED\n         LA    R7,EXECBASE         RESET BASE REGISTER\n         BR    R7                  GO JOIN EXEC COMMAND\n         SPACE 3\n* ENTRY FOR EXEC COMMAND\n         SPACE\nGOEXEC   DENTER DSSIZ\n         OI    CPLFLG5,CPFSELEX    SET DEFAULT EXEC LINE NO. SEL\n         XCALL SCNEXFR       SEE IF RANGE FROM EXTERNAL OR ACTIVE\n         TM    CPLFLG5,CPFSELOC  IS IT EXEC ACTIVE\n         BNZ   GOEXECA             BRANCH NO\n         CLC   CPAGCT(2),=D'0'     IS THERE AN ACTIVE FILE\n         BNZ   GOEXECA             YES, COMMAND IS OKAY\n         XCALL ITSNIL              NO, GO REPORT ERROR\n         SPACE\nGOEXECA  MVI   CPSTAD,CPFEXPRG         SET EXPLICIT RANGE\n         XC    CPFSLN(4),CPFSLN        SET FIRST LINE\n         MVC   CPLSLN(4),=F'99999999'  SET LAST LINE\n         GENTER ,\nEXECBASE TM    CPGFLG2,CPFEXEC+CPFNOLOG LIST EXEC COMMAND\n         BNO   GOEXEC1                 BRANCH NO\n         TM    CPGFLG2,CPFEXTER    TERSE MODE\n         BO    GOEXEC1             YES, DON'T LIST COMMAND NOW\n         MVC   CPLCNO,CPEXLINE     RESET LINE NUMBER FOR WRITE\n         BAL   R14,WRITECOM            WRITE OUT COMMAND\nGOEXEC1  LA    R6,SCANLNO          SET ADDR FOR LINE NUMBER\n         SCAN  EXECTBL1                SCAN EXEC PARMS\n         TM    CPLFLG2,CPFEXPA     WAS EXEC PAUSE SPECIFIED\n         BNO   GOEXNOPA            NO\n         TM    CPGFLG2,CPFEXEC     DID COMMAND COME FROM EXEC\n         BNO   GOEXNOPA            NO, NO NEED TO LIST COMMAND\n         MVC   CPLCNO,CPEXLINE     RESET LINE NUMBER FOR WRITE\n         BAL   R14,WRITECOM        WRITE OUT COMMAND\nGOEXNOPA TM    CPLFLG2,CPFEXFR         WAS EXEC FROM SPECIFIED\n         BO    GOEXECFR                YES\n         TM    CPLFLG2,CPFEXACT        WAS EXEC ACTIVE SPECIFIED\n         BO    GOEXECAC                YES\n         CLI   CPCMNM,C'L'         IS IS LOAD\n         BE    GOEXECAC            YES, GO EXEC ACTIVE\n         TM    CPLFLG2,CPFCLEAR        WAS CLEAR SPECIFIED\n         BO    GOEXECPA                YES, TREAT AS EXEC PAUSE\nGOEXECCM TM    CPGFLG2,CPFEXEC    IS EXEC IN EFFECT NOW\n         BO    GOEXECCA            YES, DON'T CLEAR IDLE ATTN\n         OI    CPGFLG2,CPFEXEC         SET EXEC FLAG\n         NI    JCBAFL,255-JCBAFIA      CLEAR IDLE ATTN\nGOEXECCA TM    CPLFLG2,CPFEXLNE        WAS EXEC LINENO SPECIFIED\n         BE    GOEXECC1                NO\n         L     R2,CPEXLNET             GET EXEC LINENO\n         BCTR  R2,0                    SET FOR ADDER\n         ST    R2,CPEXLINE             SET EXEC LINENO\nGOEXECC1 TM    CPLFLG2,CPFEXPA         PAUSE SPECIFIED\n         BE    CVGETCOM                NO, GO GET COMMAND\nGOEXECPA NI    CPGFLG2,255-CPFEXEC     TURN OFF EXEC FLAG TO PAUSE\n         TM    CPLFLG2,CPFCLEAR        WAS CLEAR SPECIFIED\n         BE    CVGETCOM                NO, GET NEXT COMMAND FROM\n         CLC   CPEXCNT(2),=D'0'        IS THERE AN EXEC FILE\n         BE    EXECNOFL                NO, GO ISSUE MESSAGE\n         BAL   R14,DOCLREX             GO CLEAR EXEC FILE\n         B     CVGETCOM                NOW GET NEXT COMMAND FROM\n         SPACE 3\n* EXEC ACTIVE WAS SPECIFIED\n         SPACE\nGOEXECAC BAL   R14,EXCLRCK             GO CLEAR OLD EXEC IF NEEDED\n         NI    CPLFLG2,255-CPFCLEAR    TURN OFF CLEAR FLAG\n         XC    CPEXLINE(4),CPEXLINE CLEAR EXEC LINE TO USE FIRST\n         OI    CPLFLG5,CPFNCUR     SET TO NOT CHANGE * POINTER\n         L     R15,GOLACAD         LOAD ADDRESS OF WORK\n         CVCALL DESPOT             GO LOAD EXEC FILE\nGOEXAC1  PFREE R9                  FREE ANY PAGE IN R9\n         PFREE R11                 FREE ANY PAGE IN R11\n         TM    CPLFLG2,CPFEXACT    WAS IT EXEC ACTIVE\n         BNO   GOEXECCM            NO, DON'T CLEAR ACTIVE\n         CVCALL DOCLEAR            YES, GO CLEAR ACTIVE\n         B     GOEXECCM            GO TRY TO EXECUTE COMMANDS\n         EJECT\nGOEXECFR BAL   R14,EXCLRCK         CLEAR EXEC FILE IF NECESSARY\n         NI    CPLFLG2,255-CPFCLEAR    TURN OFF CLEAR FLAG\n         CVCALL VOLCHEK                MAKE SURE VOL SPECIFIED\n         TM    CPLFLG3,CPFSET          WAS SET SPECIFIED\n         BZ    GOFRM1                  NO\n         CVCALL SETPFXNS               GO SET PREFIX\nGOFRM1   DOPEN 0,,USE                  OPEN DATA SET\n         BZ    GOFRM2                  OPEN OK\n         CLI   CPCMSAV,C';'            LOGON EXEC FILE?\n         BE    CVGETCOM                YES, NO ERROR\n         CVCALL NTGDOPN                GO DO OPEN ERROR MESSAGE\n         SPACE\nGOFRM2   OI    CPGFLG,CPFOPN           SET DATA SET OPEN\n         ST    R1,CPDRED               SAVE BUFFER ADDR\n         XC    CPEXLINE(4),CPEXLINE CLEAR EXEC LINE TO USE FIRST\n         OI    CPLFLG5,CPFNCUR     SET TO NOT CHANGE * POINTER\n         L     R15,GOFRXAD             ADDR FOR DESPOT USING LXCATE\n         CVCALL DESPOT                 GO DO WORK\n         DCLOSE ,                      CLOSE DATA SET\n         NI    CPGFLG,255-CPFOPN       SET DATA SET CLOSED\n         B     GOEXAC1             GO TO COMMON ENDING FOR ACTIVE\n         SPACE 3\n* EXEC WORK ROUTINE FOR DESPOT\n         SPACE\nFROMWORK DS    0H\n         XENTER 2,8,C32+SZR+12\n         L     R7,=A(EXECBASE)         RELOAD BASE REGISTER\n         USING EXECBASE,R7\n         SR    R2,R2\n         IC    R2,4(,R15)              GET PREST COUNT\n         LA    R3,C32(,R8)         POINT TO PREST SAVE AREA\n         LA    R6,4(,R2)           SET MVC COUNT\n         EX    R6,MOVIT2           SAVE PREST LINE\n         LH    R6,CPEXCNT              GET PAGE COUNT\n         LTR   R5,R6                   FIRST LINE OF ALL\n         BZ    FSTPAG                  YES\n         MH    R5,=H'6'\n         LA    R5,CPEXDIR-6(R5)        POINT TO LAST DIRECTORY ENTRY\n         LTR   R9,R9                 PAGE IN R9\n         BZ    TRY11                   NO, TRY R11\n         PNUM  R9                      WHAT PAGE\n         CH    R0,4(,R5)               WANTED ONE\n         BE    GOTIT                   YES\nTRY11    LTR   R11,R11                   PAGE IN R11\n         BZ    DOGET                   NO\n         PNUM  R11                       WHAT PAGE\n         CH    R0,4(,R5)               WANTED ONE\n         BNE   DOGET                   NO, GET ONE\n         PFLIP R9,R11                    YES, MOVE TO R9\n         B     GOTIT                   GO PROCESS\n         SPACE\nDOGET    LH    R0,4(,R5)               SET POINTER\n         PGET  R9,(0)                  GET PAGE\nGOTIT    EQU   *\n         LH    R4,0(,R9)              COUNT ON PAGE\n         LA    R14,5(R2,R4)        ROOM FOR THIS LINE ON PAGE?\n         CH    R14,=Y(CPSIZE)      (COMPARE TO FULL SIZE )\n*\n         BH    NEWPAG                  NO\nALLSET   LA    R15,0(R4,R9)           NEXT SPOT ON PAGE\n         LA    R4,5(R4,R2)             NEW COUNT\n         STH   R4,0(,R9)              PUT BACK IN PAGE\n         LA    R6,4(,R2)               SET MVC COUNT\n         EX    R6,MOVIT1               MOVE LINE TO PAGE\n         MVC   CPEXHIPS(4),0(R3)       SET HIGH LINE VALUE\n         LH    R6,CPEXLNCT             GET LINE COUNT\n         LA    R6,1(,R6)               ADD 1\n         STH   R6,CPEXLNCT             STORE IT\n         PMARK R9\n         XEXIT 2,8                     RETURN FOR NEXT LINE\n         SPACE 3\nFSTPAG   LA    R5,CPEXDIR-6            POINT BEFORE FIRST DIR ENTRY\nNEWPAG   CH    R6,=Y(CPEXECMX)         TOO MANY PAGES\n         BNL   FRMTOBIG                YES\n         PGET  R9                      GET NEW TEXT PAGE\n         BZ    FRMOUT                  NO MORE PAGES\n         LA    R6,1(,R6)               BUMP PAGE COUNT\n         STH   R6,CPEXCNT              SAVE COUNT\n         MVC   6(4,R5),0(R3)           PUT 1ST LINE NO IN DIRECTORY\n         STH   R0,10(,R5)              PUT PAGE NO IN DIREC\n         LA    R4,2                    SET NEW COUNT\n         B     ALLSET                  GO MOVE LINE\n         SPACE\nFRMOUT   TSEG  'NO MORE PAGES -- NO EXEC'\nFRMEND   NI    CPGFLG2,255-CPFEXEC TURN OFF EXEC MODE\n         TM    CPLFLG1,CPFEXFR     EXEC OR LOAD FROM\n         BNO   CVGETCOM            NO, NO DCLOSE\n         DCLOSE ,                      CLOSE DATA SET\n         NI    CPGFLG,255-CPFOPN       SET DATA SET CLOSES\n         B     CVGETCOM                GO GET COMMAND\n         SPACE\nFRMTOBIG TSEG  'FILE TOO BIG -- NO EXEC'\n         B     FRMEND\n         SPACE\nMOVIT2   MVC   0(0,R3),0(R15)\nMOVIT1   MVC   0(0,R15),0(R3)\nGOFRXAD  DC    0F'0',AL1(DESRTRN+LXCATRTN),AL3(FROMWORK)\nGOLACAD  DC    0F'0',AL1(DESRTRN+LOCATRTN+DESMATCH),AL3(FROMWORK)\n         TITLE 'EXEC SCAN TABLE AND SCAN ROUTINES'\nEXECTBL1 SCKW  PAUSE,SCANPA,A\n         SCKW  FROM,SCANFROM,A\n         SCKW  ,IGDSNPRT,PUSH\n         SCKW  ACTIVE,SCANACT,A\n         SCKW  ,STEXEPRT,PUSH\n         SCKW  START,SCANSTRT,A\n         SCKW  ,CLRPRT,PUSH\n         SCKW  RETRY,SCANRTRY,A\nSTRTBL   SCKW  ,LNENOPRT,PUSH\n         SCKW  ,INVALID\n         SPACE\nRESTBL1  SCKW  ,CLRPRT,PUSH\n         SCKW  ,INVALID\n         SPACE\n         ENTRY STEXEPRT\nSTEXEPRT SCKW  LOG,SCANLOG\n         SCKW  TERSE,SCANTER,A\n         SCKW  VERBOSE,SCANVER,A\n         SCKW  NOLOG,SCANNLOG,A\n         SCKW  ,,POP\n         SPACE\nSHOBTBL1 SCKW  RETRY,SCANRTRY,A\n         SCKW  ,LNENOPRT,PUSH\n         SCKW  LOG,SHLOG\n         SCKW  NOLOG,SHLOG,A\n         SCKW  TERSE,SHTERSE,A\n         SCKW  VERBOSE,SHTERSE,A\n         SCKW  ,INVALID\n         SPACE 3\nSCANPA   OI    CPLFLG2,CPFEXPA         SET EXEC PAUSE\n         BR    R14                     SCAN ON\n         SPACE\nSCANACT  OI    CPLFLG2,CPFEXACT        SET EXEC ACTIVE\n         CLI   CPCMNM,C'L'         IS IT LOAD COMMAND\n         BE    CVNVALID            YES, ACTIVE IS INVALID\n         TM    CPLFLG2,CPFEXFR         HAS EXCL OPER BEEN GIVEN\n         BZR   R14                     NO, SCAN ON\n         B     CVNVALID            CALL INVALID ROUTINE\n         SPACE\nSCANSTRT LA    R6,SCANLNOL         SET ADDR FOR LINE NO\n         SCAN  STRTBL              SCAN FOR START LINE NUMBER\n         B     CVNVALID\n         SPACE\nSCANLNO  CLI   CPCMNM,C'L'         IS IT LOAD COMMAND\n         BE    CVNVALID            YES, LINE NUMBER INVALID\nSCANLNOL ST    R0,CPEXLNET             SAVE SPECIFIED LINE NO.\nSCANLNO1 OI    CPLFLG2,CPFEXLNE        SET LINE NO. SPECIFIED\n         CLI   CPCMNM,C'S'         IS IT SHOW COMMAND\n         BNE   GOEXEC1             BRANCH NO\n         B     SHEXSCN             YES\n         SPACE\nSCANRTRY MVC   CPEXLNET(4),CPEXLINE  SET NORMAL RETRY LINE\n         CLC   CPEXLNET(4),CPEXHIPS  IS IT BEYOND FILE\n         BNH   SCANLNO1            NO, IT IS OKAY\n         MVC   CPEXLNET(4),CPEXHIPS  YES, SET IT TO HIGH LINE\n         B     SCANLNO1            GO FINISH\n         SPACE\nSHLOG    OI    0(R8),CPFNOLOG      SET TO SHOW OPTION\n         BR    R14                 SCAN ON\n         SPACE\nSHTERSE  OI    0(R8),CPFEXTER      SET TO SHOW TERSE\n         BR    R14\n         SPACE\nSCANFROM OI    CPLFLG2,CPFEXFR         SET FROM\n         TM    CPLFLG2,CPFEXACT        HAS EXCL OPER BEEN GIVEN\n         BO    CVNVALID            YES\n         CVCALL DODSNM                 GET THEN\n         B     GOEXEC1                 GO RESTART SCAN\n         SPACE\n         DROP  R7                  NO BASE FOR FOLLOWING\n         SPACE\nSCANTER  OI    CPGFLG2,CPFEXTER    SET EXEC TERSE FLAG\n         BR    R14                 RETURN\n         SPACE\nSCANVER  NI    CPGFLG2,255-CPFEXTER TURN OF TERSE FLAG\n         BR    R14                 RETURN\n         SPACE\nSCANLOG  NI    CPGFLG2,255-CPFNOLOG    RESET NOLOG FLAG (SET LOG)\n         BR    R14                     SCAN ON\n         SPACE\nSCANNLOG OI    CPGFLG2,CPFNOLOG        SET NOLOG\n         BR    R14                     SCAN ON\n         TITLE 'SHOW EXEC ROUTINE'\n* SHOW EXEC COMMAND\n         SPACE\nSHEXEC   GENTER SZR\n         L     R7,=A(EXECBASE)         USE BASE FOR EXEC COMMAND\n         USING EXECBASE,R7\n         MVI   0(R8),0             RESET SHOW TERSE & LOG\n         OI    CPLFLG5,CPFSELEX    SET TO USE EXEC LINE NUMBERS\nSHEXSCN  LA    R6,SCANLNOL         SET ADDR FOR LINE NUMBER\n         SCAN  SHOBTBL1                SCAN SHOW OPERANDS\n         TM    0(R8),CPFNOLOG+CPFEXTER SHOW TERSE &/| LOG\n         BZ    SHEXLNE             NO, GO SHOW EXEC LINE\n         TSEG  'EXEC',,B           SET FIRST PART OF MESSAGE\n         TM    0(R8),CPFNOLOG      TEST NOLOG\n         BZ    SHEXTER             NO, GO SHOW TERSE\n         SYSQS 1,0,'LOG'           ASSUME LOG IN EFFECT\n         TM    CPGFLG2,CPFNOLOG    LOG OR NOLOG\n         BZ    SHEXLOG             BRANCH IF LOG\n         SYSQS 1,0,'NOLOG'         SET FOR NOLOG\nSHEXLOG  TSEG  (1),(0),B           PUT IT IN MESSAGE\n         TM    0(R8),CPFEXTER      ALSO DO TERSE?\n         BZ    SHEXFIN             NO, GO FINISH MESSAGE\nSHEXTER  SYSQS 1,0,'TERSE'         ASSUME TERSE\n         TM    CPGFLG2,CPFEXTER    TERSE OR VERBOSE\n         BO    SHEXTER2            BRANCH IF TERSE\n         SYSQS 1,0,'VERBOSE'       SET FOR VERBOSE\nSHEXTER2 TSEG  (1),(0),B           PUT IT IN MESSAGE\nSHEXFIN  TSEG  'IS IN EFFECT',,W       FINISH & WRITE MESSAGE\n         TM    CPLFLG2,CPFEXLNE    EXEC LINE ALSO SPECIFIED\n         BZ    CVGETCOM            NO, GO GET NEXT COMMAND\nSHEXLNE  TM    CPLFLG2,CPFEXLNE        WAS SPECIFIC LINE NO SPECIFIED\n         BO    SHEXEC1                 YES\n         L     R0,CPEXLINE             GET CURRENT EXEC LINE NO\n         LA    R1,1\n         CVCALL ADDER                GET NEXT POSSIBLE LINE NO\n         BNP   NOSHOLNE                NO LINE IF BAD LINE NO\n         ST    R0,CPEXLNET             SAVE AS IF SPECIFIED\nSHEXEC1  LA    R1,CPEXLNET             LOCATE\n         XCALL LOCATEEX                      EXEC LINE\n         TM    CPDRPT,CPFNTYT+CPFHIGH  DOES LINE EXIST\n         BNZ   NOSHOLNE                NO\n         MVC   CPEXLNET,CPLCNO         SET ACTUAL LINE NO\n         TM    CPDRPT,CPFPGHI          AFTER LAST ON PAGE\n         BO    SHEXEC1                 YES, DO ANOTHER LOCATE\nSHEXEC2  LA    R1,4(,R8)               POINT TO UNPRESS AREA\n         CVCALL UNPRESS                UNPRESS LINE TO LIST IT\n         XCALL LISTLINE            FORMAT LINE FOR LIST\n         B     CVGETCOM                GO GET NEXT COMMAND\n         SPACE\nNOSHOLNE TSEG  'NO EXEC LINE'\n         B     CVQTYPE\n         TITLE 'GET NEXT COMMAND FROM EXEC FILE'\n* UPDATE EXEC LINE NO AND GET NEXT COMMAND\n         SPACE\nGETEXCMD GENTER ,\n         L     R7,=A(EXECBASE)         USE SAME BASE AS FOR EXEC\n         USING EXECBASE,R7\n         CLC   CPEXCNT(2),=D'0'    IS THERE AN EXEC FILE\n         BE    EXECNOFL            BRANCH NO\n         TM    JCBAFL,JCBAFIA          IDLE ATTN\n         BO    EXECABRT                YES\n         BAL   R14,EXLOOPCK        GO CHECK FOR EXECUTE LOOP\n         TM    CPEXLINE,FNEGBT     IS EXEC LINE POINTER SET\n         BO    EXECNOST            BRANCH NO\n         L     R0,CPEXLINE             GET LAST LINE NO USED\n         LA    R1,1\n         CVCALL ADDER                GET NEXT POSSIBLE LINE NO\n         BNP   EXECDONE                BRANCH IF DOESN'T EXIST\n         ST    R0,CPEXLINE             SAVE LINE NO\nGETEXLP  LA    R1,CPEXLINE             POINT TO LINE TO LOCATE\n         XCALL LOCATEEX                LOCATE EXEC LINE\n         TM    CPDRPT,CPFNTYT+CPFHIGH  DOES IT EXIST\n         BNZ   EXECDONE                NO\n         MVC   CPEXLINE,CPLCNO         SET EXEC LINE NO.\n         TM    CPDRPT,CPFPGHI          AFTER LAST ON PAGE\n         BO    GETEXLP                 YES, GO DO ANOTHER LOCATE\nGETEXCM1 LA    R1,CPCMSAV              POINT TO UNPRESS AREA\n         CVCALL UNPRESS                 UNPRESS THE COMMAND\n         LR    R2,R0               SAVE THE COUNT IN R2\n         ST    R2,CPCTSAV              SAVE THE COUNT\n         PFREE R11                     FREE EXEC PAGE IN R11\n         TM    CPGFLG2,CPFNOLOG        IS NOLOG IN EFFECT\n         BO    GETEXCM2                YES\n         BAL   R14,WRITECOM            WRITE OUT COMMAND\nGETEXCM2 LA    R8,CPWA             SET R8 AND\n         LR    R13,R8                  R13 FOR NEW COMMAND\n         LR    R0,R2               RESTORE THE COUNT\n         LA    R1,CPCMSAV          POINT TO THE COMMAND\n         XCALL EDTCOM                  GO EXECUTE COMMAND\n         SPACE 3\n* END OF RANGE FOR EXEC\n         SPACE\nEXECNOFL TSEG  'NO EXEC FILE'\n         B     EXECDNE1                GO FINISH\n         SPACE\nEXECDONE TSEG  'EXEC END'\nEXECDNE1 NI    CPGFLG2,255-CPFEXEC     TURN OFF EXEC MODE\n         B     CVGETCOM                GET NEXT COMMAND FROM USER\n         SPACE\nEXECNOST TSEG  'EXEC POINTER NOT SET'\n         B     EXECDNE1            GO FINISH\n         EJECT\n* WRITE OUT COMMAND TO BE EXECUTED\n         SPACE\nWRITECOM XENTER R0,R8,*\n         TM    CPCTSAV,FNEGBT      TEST IF LINE TO LIST\n         BO    WTCOMEX             NO, EXIT FROM ROUTINE\n         TSEG  '->',,B\n         TM    CPGFLG2,CPFEXTER    EXEC TERSE MODE\n         BO    WTCOM1              YES, DON'T LIST LINE NO.\n         L     R0,CPLCNO               LINE NO OF COMMAND\n         CVCALL CVEXNO              CONVERT TO EXTERNAL FORMAT\n         TSEG  (1),(0),B           ADD TO BUFFER\nWTCOM1   L     R0,CPCTSAV              LOAD COUNT OF COMMAND\n         LA    R1,CPCMSAV              POINT TO COMMAND\n         TSEG  (1),(0),W            ADD TO BUFFER\n         BP    EXECABRT                ABORT EXEC IF ATTN\n         MVI   CPCTSAV,FNEGBT      SET SO NO LIST AGAIN\nWTCOMEX  XEXIT R0,R8                   RETURN\n         TITLE 'CHECK FOR POSSIBLE EXEC OR READ LOOP'\n* IF 500 COMMANDS HAVE BEEN EXECUTED WITHOUT TYPING THEN\n* CAUSE AN EXEC BREAK SO USER CAN CHECK FOR POSSIBLE LOOP.\n*\n* IN ADDITION THIS ROUTINE FORCES A CALL OF THE DISPATCHER TO\n* LET OTHER READY USERS RUN EVERY TIME THE COMMAND COUNT IS\n* A MULTIPLE OF EIGHT.\n         SPACE\nEXLOOPCK SENTER R0,R7\n         LH    R0,CPEXCMCT\n         AH    R0,=H'1'\n         STH   R0,CPEXCMCT\n         CH    R0,=H'5000'          MORE THAN 5000\n         BNH   GETEXOK             NO, OK\n         TSEG  'NO TERMINAL OUTPUT AFTER 5000 COMMANDS EXECUTED-',,MARK\n         SYSQS 1,0,'PROCEED'\n         XCALL YESREQ\n         SPACE\nGETEXOK  SEXIT R0,R7\n         TITLE 'ABORT EXECUTE MODE'\n* ABORT EXEC AND GET NEXT COMMAND\n         SPACE\nEXECABRT GENTER ,\n         NI    CPGFLG2,255-CPFEXEC     TURN OFF EXEC MODE\n         TSEG  'EXEC BREAK',,W\n         BP    CVGETCOM\n         L     R0,CVEXTRAP\n         LTR   R0,R0\n         BZ    CVGETCOM                GET NEXT COMMAND FROM USER\nEXTRAP   XC    CVEXTRAP(4),CVEXTRAP    CLEAR TRAP\n         MVC   CPCMSAV(2),=C'X '\n         MVC   CVTRAPLN(4),CPEXLINE\n         CVCALL CVEXNO\n         AH    R0,=H'2'\n         MVC   CPCMSAV+2(10),0(R1)\n         ST    R0,CPCTSAV\n         LA    R1,CPCMSAV\n         LA    R8,CPWA\n         LR    R13,R8\n         XCALL EDTCOM\n         TITLE 'RESTORE COMMAND ROUTINE'\n* RESTORE EXEC FILE TO ACTIVE FILE\n         SPACE\nGORESTOR GENTER ,\n         L     R7,=A(EXECBASE)         USE SAME BASE AS FOR EXEC\n         USING EXECBASE,R7\n         LH    R2,CPEXCNT              GET EXEC FILE PAGE COUNT\n         LTR   R2,R2                   IS THERE AN EXEC FILE\n         BE    EXECNOFL                BRANCH NO\n         SCAN  RESTBL1\n         XCALL CLEARCK                 CLEAR ACTIVE FILE IF NECESSARY\n         SPACE 3\n* SINCE EXEC FILES ARE LOADED AND MARKED AS NOT ESSENTIAL TO\n* RCVY, ONE OR MORE OF THE EXEC PAGES MIGHT NOT HAVE BEEN\n* WRITTEN OUT.  NOW THAT A RESTORE IS BEING DONE WE MUST INSURE\n         SPACE\n* THAT ALL EXEC PAGES HAVE BEEN WRITTEN.\n         LR    R3,R2               PUT COUNT IN R3\n         LA    R4,CPEXDIR          POINT R4 TO DIRECTORY\nRESTLOOP LH    R0,4(,R4)           GET EXEC PAGE NUMBER\n         PGET  11,(0)              GET PAGE IN R11\n         PMARK R11\n         LA    R4,6(,R4)           STEP TO NEXT ENTRY\n         BCT   R3,RESTLOOP         LOOP UNTIL DONE\n         MH    R2,=H'6'                GET LENGTH\n         BCTR  R2,0                        FOR EXECUTE\n         EX    R2,MVEDIR2              MOVE EXEC DIRECTORY TO ACTIVE\n         MVC   CPHIPS(8),CPEXHIPS    SET HIGH LINENO, LINE & PAGE CNTS\n         MVC   CPEXHIPS(8),=D'0'       CLEAR EXEC FILE\n         OI    CPGFLG,CPFDIRCH         SET DIR CHNGED FOR RCVY\n         MVI   CPEXLINE,X'F0'      SET CURRENT EXEC LINE INVALID\n         XC    CPEXDIR(4),CPEXDIR  CLEAR FIRST EXEC LINE\n         NI    CPGFLG2,255-CPFEXEC     TURN OFF EXEC\n         B     CVGETCOM                GET NEXT COMMAND FROM USER\n         SPACE\nMVEDIR2  MVC   CPDREC(1),CPEXDIR     EX MVC TO MOVE EXEC DIR TO ACTIVE\n         TITLE 'COMMENT COMMAND ROUTINE'\n* COMMENT COMMAND  --  LIST COMMENT IF FNEGBT IS NOT ON FOR CPCTSAV\n         SPACE\nGOCOMMNT GENTER ,\n         TM    CPCTSAV,FNEGBT      DOES COMMENT NEED LISTING\n         BO    CVGETCOM                NO, GET NEXT COMMAND\n         SCTELL ,                      GET REST OF LINE\n         TSEG  (1),(0)              WRITE OUT COMMENT\n         CLI   CPCMNM,C'D'          WAS IT DISPLAY\n         BNE   *+8                  IF NOT LEAVE NOCR ALONE\n         OI    RTBMFL,RTBNOCR       ELSE TURN NOCR FLG ON\n         TWRITE ,                   GO WRITE IT\n         NI    RTBMFL,X'FF'-RTBNOCR TURN IT OF NOW\n         B     CVGETCOM                GET NEXT COMMAND\n         TITLE 'CLEAR CHECK ROUTINE FOR EXEC FILE'\n* CHECK FOR CLEAR OF EXEC FILE IF NECESSARY\n         SPACE\nEXCLRCK  XENTER R7,R8,*\n         CLC   CPEXCNT(2),=D'0'        IS THERE AN EXEC FILE\n         BE    EXITCLR                 NO, EXIT\n         TM    CPLFLG2,CPFCLEAR        WAS CLEAR SPECIFIED\n         BO    FIXCLRCK                YES, GO DO CLEAR\n         TSEG  'OK TO',,B          SET FIRST PART OF MESSAGE\n         SYSQS 1,0,'CLEAR EXEC'    SET POSITIVE RESPONSE\n         XCALL YESREQ              GO CHECK IF OKAY WITH USER\nFIXCLRCK BAL   R14,DOCLREX             DO THE CLEAR\nEXITCLR  XEXIT R7,R8                   RETURN\n         TITLE 'CLEAR EXEC FILE ROUTINE'\n* CLEAR EXEC FILE IF NECESSARY\n         SPACE\nDOCLREX  XENTER R2,R8,*\n         LH    R6,CPEXCNT              GET PAGE COUNT\n         LTR   R6,R6                   ANY PAGES\n         BE    DOCLREXX                NO, EXIT\n         LA    R5,CPEXDIR              POINT AT DIRECTORY\nDOCLREXL LH    R0,4(,R5)               GET PAGE NO.\n         PJUNK (0)                     JUNK IT\n         LA    R5,6(,R5)               STEP TO NEXT PAGE\n         BCT   R6,DOCLREXL             LOOP UNTIL DONE\n         MVI   CPEXLINE,X'F0'      SET CURRENT EXEC LINE INVALID\n         XC    CPEXDIR(4),CPEXDIR  CLEAR FIRST EXEC LINE\n         MVC   CPEXHIPS(8),=D'0'   CLEAR HIGH LINENO, LINE & PAGE CNTS\nDOCLREXX XEXIT R2,R8                   EXIT\n         TITLE 'COMMON ROUTINES, CONSTANTS AND DSECTS'\n         LTORG\n         EJECT\n         COPY  WYLCONST\n         EJECT\nPCB      DSECT\n         COPY  PCBTSO\n         EJECT\n         COMMON\n         SPACE\n         END\n./ ADD NAME=BLPR,SSI=00000171\nBLPR     TITLE 'WYLTSO --- POINT/LIST ROUTINES'\n         GBLC   &DCEC             SWITCH FOR DCEC MODS\n&DCEC    SETC  '1'  CHANGE TO ANY OTHER NUM. TO DELETE DCEC MOD\n* PROPERTY OF C. U. C. C. A.\n         SPACE 3\nBLPR     CSECT\n         SPACE\n         WIDENT 001\n         SPACE\n         XTRNS ,\n         SPACE\n         USING CPAREA,R12\n         EJECT\n         AIF   ('&DCEC' NE '1').LBL01\n* MOD\n*  IMPLEMENT DCEC VERSION OF THE RUN COMMAND.  ACKNOWLEDGMENT\n*  HEREBY MADE TO JIM MCKAY OF CCI FOR THE IDEA. CHANGES\n*  DENOTED BY OR  IN 66/71.\n*\n*\n*\n*  MOD\n*   MOVED COMMAREA TO CVTSO MACRO FOR REENTERABILITY.\n*\n*\n.LBL01   DS    0H\n* GOPOINT IS THE PRIMARY ENTRY POINT FOR THE POINT COMMAND.\n*        POINT IS THE SAME AS THE LIST COMMAND WITH THE\n*        ADDITION THAT THE CURRENT LINE POINTER IS UPDATED\n*        TO THE LAST LINE POINTED TO.\n         SPACE\nGOPOINT  GENTER ,\n         MVI   CPCMNM,C'L'         MAKE IT THE LIST COMMAND\n         B     COMMNPT\n         SPACE 3\n* GOLSPRN IS THE PRIMARY ENTRY FOR LIST,PUNCH, SUGGEST, AND RUN.\n         SPACE\nGOLSPRN  GENTER ,\n         OI    CPLFLG5,CPFNCUR     SET TO NOT UPDATE CURRENT\nCOMMNPT  EQU   *                   POINT COMES IN HERE\n         GENTER\n         XCALL SCNEXFR             SEE IF SELECT FROM EXEC\n         OI    CPLFLG1,CPFALL          SET DEFAULT ALL OKAY\n         CVCALL DETRNG             GET RANGE (IF NOT DEFAULT)\n         LA    R13,WASIZE(R8)      CREATE WORK SPACE\n         USING BLPRWA,R8\n         SR    R4,R4\n         ST    R4,CPWK1            CLEAR COLUMN FIELDS.\n         XC    BLPRWA(WASIZE),BLPRWA CLEAR ENTIRE WORK AREA\n         XC    CPSPAC(4),CPSPAC     CLEAR BLANK COUNT\n         ST    R8,CPWK2             SAVE BLPRWA POINTER\n         MVI   WYLRDR+25,X'0'     NO MACHINE OR ASA CHAR\n         MVI   CCHAR,C' '         END\nRESCAN   SCAN  LSTPRT                   SCAN FOR OPTIONS\n         AIF   ('&DCEC' NE '1').LBL02\n         CLI   CPCMNM,C'R'          RUN COMMAND ??\n         BE    GOTRUN               YES - SET FOR DESPOT\n         TM    WAFLAG1,WAFOFF      LIST OFF LINE\n         BO    GOTOFF               YES - SET FOR DESPOT\n.LBL02   DS    0H\nGOTLIST  L     R15,LSONLAD              ADDR WORK RTN\n         TM    CPLFLG5,CPFSELOC    SELECT FROM EXEC OR ACTIVE\n         BNM   *+8                 BRANCH IF ACTIVE\n         O     R15,=AL1(LEXATRTN,0,0,0) SET FOR EXEC LOCATE\n         CVCALL DESPOT             CALL DESPOT\n         B     CVGETCOM                 NEXT COMMAND\nGOTOFF   EQU   *\n         MVC   DAIRWTR,=CL8' '      BLANK OUT INTRDR\n         MVI   RPL+51,133          LRECL 133\n         XC    WAOFFCNT,WAOFFCNT          CLEAR FOR COUNT\n         B     PRTRUN               COMMON PRINT AND RUN\n         AIF   ('&DCEC' NE '1').LBL03\nGOTRUN   EQU   *\n         MVI   WYLRDR+25,0         MUST BE ZERO\n         MVI   CPCMNM,C'R'         FORCE RUN\n         MVC   DAIRWTR,=CL8'INTRDR'           INTRDR\n         MVI   RPL+51,80           LRECL 80\nPRTRUN   STAX  ATTN,OBUF=(RUNINT,L'RUNINT),USADDR=(R8),REPLACE=NO\n*             ALLOCATE  CODE FOR WYLRDR OR WYLPRINT\n         L     R15,CVIOWA          ADDRESS OF DAIR ROUTINE\n         LA    R1,WAUPT-WDWA(R15)  ADDR OF DAPL\n         LA    R2,DAIR30           PARAMETER LIST\n         ST    R2,WADAIR-WDWA(R15)\n         L     R15,CVDAIR          ADDRESS OF DAIR ROUTINE\n         BALR  R14,R15             CALL DAIR\n         LTR   15,15               INTRDR AVAILABLE??\n         BNZ   NORDR               NONE, GET OUT\n*              OPEN    INTRDR\n         OPEN (WYLRDR,OUTPUT)\n         L     15,RUONLAD          ADDRESS OF WORK ROUTINE\n         TM    CPLFLG5,CPFSELOC    SELECT FROM EXEC OR ACTIVE\n         BNM   *+8                 BRANCH IF ACTIVE\n         O     R15,=AL1(LEXATRTN,0,0,0) SET FOR EXEC LOCATE\n         ST    15,SWITCH           STORE WHERE TO GO ADDR\n        CVCALL DESPOT    CALL DESPOT - RETURN AT WORK RTN\nEOF      DS    0H\n         MVI   BUF,C' '        BLANK RTB\n         MVC   BUF+1(254),BUF\n*        PUT   RPL=RPL\n         CLI   CPCMNM,C'R'       IS IT RUN COMMAND\n         BNE   CLOSE             NO MUST BE PRINT\n         MVC   BUF(5),=C'/*EOF   '   INSURE END OF JOB\n         PUT   RPL=RPL\n         ENDREQ  RPL=RPL         JOB SUBMITTED, GET JOB NUMBER\n         MVC   JOBNUM,RPL+60        MOVE JOB ID\n         TSEG  JOBNUM,8,B       MOVE JOB-ID\n         TSEG  'SUBMITTED.'\n         TWRITE ,                  WRITE IT\nCLOSE    CLOSE (WYLRDR)\n*              CLOSE AND FREE INTRDR\n         L     R15,CVIOWA          ADDRESS OF DAIR ROUTINE\n         LA    R1,WAUPT-WDWA(R15)  ADDR OF DAPL\n         LA    R2,DAIR18           PARAMETER LIST\n         ST    R2,WADAIR-WDWA(R15)\n         L     R15,CVDAIR          ADDRESS OF DAIR ROUTINE\n         BALR  R14,R15             CALL DAIR\n         STAX\n         TM    WAFLAG1,WAFOFF      IS IT OFFLINE\n         BZ    CVGETCOM            NO GET NEXT COMMAND\n         SLR   R15,R15\n         ICM   R15,15,WAOFFCNT         GET LINE COUNT\n         LA    R1,CPDOUB           WHERE TO PUT IT\n         LA    R0,5                LENGTH OF 8\n         CVCALL BTD\n         TSEG  CPDOUB,5,B\n         TSEG  'LINES PRINTED',,W\n         B     CVGETCOM            DONE GET OUT\nNORDR    TSEG  'DYNAMIC ALLOCATION FAILLED CODE='\n         UNPK  REASON,DAIR30+4(3)   UNPK CODE\n         TR   REASON,HEX-X'F0'     TRANSLATE TO HEX\n         TSEG  REASON,4,B          DAIR FAILUE CODE\n         TWRITE ,\n         STAX\n         B     CVGETCOM            DONE GET OUT\n.LBL03   DS    0H\n         EJECT\nTRYMORE  CLI   0(R1),C'('          OFFSET COUNT?\n         BNE   CVNVALID            ILLEGAL\n         BCTR  R0,0                REDUCE LENGTH BY 1\n         BCTR  R0,0                -1 FOR ')'\n         LA    R1,1(,R1)           STEP PAST '('\n         LR    R2,R14              SAVE EXIT ADDR\n         XCALL DTB                 CONVERT\n         LTR   R0,R0               INTEGER?\n         BNZ   CVNVALID            NOPE.. NO GOOD\n         CH    R15,=H'70'          LIMIT OF 70 FOR OFFSET\n         BH    CVNVALID\n         LTR   R15,R15             POSITIVE?\n         BM    CVNVALID\n         ST    R15,CPSPAC\n         BPR   R2                  ITS > 0\n         B     CVNVALID            0 IS NOT ALLOWED\n         SPACE 3\n         AIF   ('&DCEC' NE '1').LBL04\nSQUASH   CLI   CPCMNM,C'R'         RUN COMMAND?\n         BE    CVNVALID            ILLEGAL FOR RUN\n         OI    WAFLAG1,WAFSQUSH    SET SQUASH OPTION GIVEN\n         AGO   .LBL05\n.LBL04   DS    0H\nSQUASH   OI    WAFLAG1,WAFSQUSH    SET SQUASH   OPTION GIVEN\n.LBL05   DS    0H\n         BR    R14\n         SPACE\nPRCC     OI    WYLRDR+25,X'04'     SET ASA CHAR CONTROL\n         BR    R14\n         SPACE\nPRMC     OI    WYLRDR+25,X'02'     SET MACHINE CONTROL\n         BR    R14\n         SPACE\nPROFF    OI    WAFLAG1,WAFOFF      LIST OFF LINE\n         BR    R14\n         SPACE\nTWLNSET  BCT   R0,CVNVALID               1 CHAR MAX\n         MVC   WA2LNCH(1),0(R1)         SAVE IT\n         OI    WAFLAG1,WAFTWLN          SET TWO-LINE MODE\n         BR    R14                      MORE?\n         SPACE\nSETMRKR  BNPR  14\n         AIF   ('&DCEC' NE '1').LBL06\n         CLI   CPCMNM,C'R'         RUN COMMAND?\n         BE    CVNVALID            ILLEGAL FOR RUN\n.LBL06   DS    0H\n         OI    WAFLAG1,WAFMRKN          SET MARKER MODE\n         MVC   WAMRKCH(1),1(R1)\n         CLI   0(R1),C''''             QUOTED?\n         BER   R14                      BR IF SO\n         CLI   0(R1),C'\"'\n         BER   R14\n         MVC   WAMRKCH(1),0(R1)         SET MARKER\n         BR    R14                      MORE?\n         EJECT\nCOLM     SCANSAVE ,\n         SCAN  COLT\nCOLTC    B     CVABSENT\n         SPACE\nCOLTA    OI    WAFLAG1,WALOWCOL\n         ST    R15,CPWK1\n         B     COLTD\n         SPACE\nCOLTF    OI    WAFLAG1,WAHICOL\n         TM    WAFLAG1,WALOWCOL\n         BZ    COLTH\n         CL    R15,CPWK1\n         BNL   COLTH\n         TSEG  'BAD COLUMN RANGE'\n         B     CVQTYPE\n         SPACE\nCOLTH    STH   R15,CPWK1\n         B     RESCAN\n         SPACE\nCOLTD    SCANSAVE ,\n         SCAN  COLTE\nCOLTG    SCANRSTR ,\n         B     RESCAN\n         SPACE\nCOLTS    SCANRSTR ,\n         B     COLTD\n         SPACE 3\nCOLT     SCKW  /,COLTS\n         SCKW  ,COLTA,PI,133\n         SCKW  ,INVALID\nCOLTE    SCKW  /,COLTF,(P,PI),133\n         SCKW  ,COLTG\n         SPACE 3\nNOCR     OI    RTBMFL,RTBNOCR           NOCR OPTION SELECTED\n         BR    R14                      RETURN FOR MORE SCANNING\n         SPACE\n         DS    0F\nLSONLAD  DC    AL1(DESNRTN+LOCATRTN+DESMATCH+UNPRST),AL3(LSTWORK)\n         SPACE 3\nLSTPRT   SCKW  NOCR,NOCR\n         SCKW  MARKER,SETMRKR,(P,A)\n         SCKW  TWOLINES,TWLNSET,(P,A)\n         SCKW  ,LTNPRT,PUSH\n         SCKW  COLUMNS,COLM,A\n         SCKW  SQUASHED,SQUASH,A\n         SCKW  ,LISTPRT,PUSH\n         SCKW  ,NUMPRT,PUSH\n         SCKW  EXECUTE,,A\n         SCKW  CC,PRCC             ASA CHAR CONTROL\n         SCKW  MC,PRMC             MACHINE CHAR CONTROL\n         SCKW  OFFLINE,PROFF,A           LIST OFFLINE\n         SCKW  ,TRYMORE\n         SPACE\n         DROP  R8\n         EJECT\nLSTWORK  XENTER 2,8,C32+SZR             SAVE REGS & SPACE\n         L     R3,CPWK2            GET WORK AREA ADDR\n         USING BLPRWA,R3\n         ST    R7,CVSPARES\n         TM    CPLFLG5,CPFNLST     NOLIST\n         BO    EXITNOW             YES, EXIT\n         AIF   ('&DCEC' NE '1').LBL09\n         CLI   CPCMNM,C'R'         RUN COMMAND?\n         BE    NEXTEST             YES -- NO MARKER\n         TM    WAFLAG1,WAFOFF      LIST OFF LINE\n         BO    NEXTEST             YES -- NO MARKER\n.LBL09   DS    0H\n         TM    WAFLAG1,WAFMRKN          IS MARKER IN AND ON\n         BZ    NEXTEST                  NO\n         CLC   0(1,R1),WAMRKCH          IS THIS MARKED LINE\n         BE    HAVEMRK                  YES\nNEXTEST  L     R5,CPSPAC                NO. BLANKS TO INSERT\n         MVI   C32(R8),C' '             BLANK 100 COLS\n         MVC   C32+1(99,R8),C32(R8)\n         LR    R2,R1                    SAVE POINTER TO UNPRESSED LINE\n         LR    R4,R0               SAVE UNPRESS COUNT\n         LA    R6,C32(R5,R8)            POINT PAST ANY INSERTED BLANKS\n         TM    CPLFLG5,CPFNONUM    TEST IF NONUMBER\n         BNO   LISTUNUM            NO, GO TEST FOR UNNUMBERED\n         LA    R5,11(,R5)          STEP UP LINE COUNT\n         LA    R6,11(,R6)          POINT PAST BLANKS\n         B     DOTEXT              GO PUT OUT TEXT\n         SPACE\nLISTUNUM TM    CPLFLG5,CPFUNUM     TEST UNUMBERED\n         BO    DOTEXT              BRANCH YES\n         L     R0,CPLCNO                LINE NO.\n         CVCALL CVEXNO                  CONVERT\n         MVC   0(9,R6),0(R1)           INTO LINE IMAGE\n         LA    R5,11(,R5)              KICK CHAR COUNT\n         LA    R6,11(,R6)              KICK POINTER\n         TM    CPLFLG5,CPFNTEX          TEXT?\n         BNZ   ALLTHER                  NO\nDOTEXT   LTR   R4,R4                    ANY NON-BLANKS?\n         BZ    ALLTHER                  NO\n         LA    R0,0(R4,R5)              TOTAL COUNT\n         CH    R0,=Y(MXPRTSZ+11)        UP TO 144 OK\n         BNH   COUNTOK\n         LH    R4,=Y(MXPRTSZ+11)        TRUNCATE\n         SR    R4,R5                    AT 144 CHARS\nCOUNTOK  SR    R0,R0\n         TM    WAFLAG1,WALOWCOL\n         BZ    HICOL             NO\n         LH    R0,CPWK1+2\n         BCTR  R0,R0\n         CR    R4,R0\n         BH    HICOL\n         LR    R0,R4\nHICOL    TM    WAFLAG1,WAHICOL   IS UPPER\n         BZ    NOCOL             NO\n         LH    R1,CPWK1\n         CR    R4,R1             IS UPPER GT LIM\n         BNH   NOCOL             YES\n         LR    R4,R1\nNOCOL    SR    R4,R0             SET LEN\n         AR    R2,R0             SET START PNT\n         ST    R5,CPWK5\n         ST    R3,CPWK3\n         BAL   R14,SQUASHIT             SQUASH\n         L     R3,CPWK3\n         L     R5,CPWK5\n         LA    R5,0(R4,R5)              TOTAL COUNT\n         EX    R4,MVCTEXT               MOVE TEXT CHARS\nALLTHER  LR    R0,R5                    COUNT\n         LA    R1,C32(,R8)              LOCATION\n         TM    CPLFLG5,CPFUNUM          NEED UNNUMB + TWLNS\n         BZ    OUTPNOW             DON'T HAVE UNUM\n         TM    WAFLAG1,WAFTWLN\n         BO    SPECHAN                  HAVE THEM\n         AIF   ('&DCEC' NE '1').LBL10\nOUTPNOW  EQU   *\n         CLI   CPCMNM,C'R'         RUN COMMAND??\n         BE    SUBONE              YES - GO SUBMIT IT\n         TM    WAFLAG1,WAFOFF      LIST OFF LINE\n         BO    SUBONE              YES - GO SUBMIT IT\n         TSEG  (1),(0),W           TO MESSAGE\n         AGO   .LBL11\n.LBL10   DS    0H\nOUTPNOW  TSEG  (1),(0),W                TO MESSAGE\n.LBL11   DS    0H\n         BNP   EXITNOW                  SCRAM\n         B     CVGETCOM                 CALL COMMAND PROCESSOR\n         AIF   ('&DCEC' NE '1').LBL12\nSUBONE   EQU   *                   SUBMIT TO HASP RTN\n         TM    CPLFLG5,CPFUNUM     UNNUMBERED SPEC??\n         BO    OKASIS              YES - DON'T NUMBER\n         TM    WAFLAG1,WAFOFF      LIST OFF LINE\n         BO    OKASIS             ALLOW RUN\n         CLC   83(8,1),=C' '       NUMBER IN 73-80\n         BNE   *+10                YES LEAVE ALONE\n         MVC   83(8,1),1(1)        MOVE WYL # TO 73-80\n         LA    1,11(1)             POINT TO TEXT\nOKASIS   EQU   *\n         L     R7,CVSPARES          RESTORE ADDRESSABILITY\n         MVI   BUF,C' '       CLEAR LINE\n         MVC   BUF+1(254),BUF\n         LR    R2,R0            FOR EXECUTE\n         BCTR  R2,R0\n         EX    R2,MVLINE0       MOVE DEFAULT TO RUN\n         TM    WAFLAG1,WAFOFF  IS IT LIST OFF\n         BZ    OKPUTIT         OK PUT IT AS IS\n         TM    WYLRDR+25,6     MC OR CC\n         BZ    OKPUTIT         NO LEAVE ALONE\n         EX    R2,MVLINE1      MOVE LINE WITHOUT CC\n         MVC   CCHAR,0(R1)        MOVE CONTROL CHAR\nOKPUTIT  PUT   RPL=RPL            PUT OUT RECORD\n         L     R15,WAOFFCNT         GET COUNT\n         LA    R15,1(,R15)       ADD 1\n         ST    R15,WAOFFCNT         SAVE IT\n         TM    WAFLAG1,WAFCAN   TEST FOR CANCEL\n         BO    CANCEL           YES CANCEL\n         L     15,SWITCH           RELOAD R15 FOR DESPOT\n         L     R15,0(R15)\n         B     EXITNOW             GO BACK TO DESPOT UNTIL DONE\nMVLINE0  MVC   BUF(0),0(R1)     MOVE FOR RUN\nMVLINE1  MVC   BUF(0),1(R1)     MOVE FOR LISTOFF\n.LBL12   DS    0H\n         SPACE 3\n* THE FOLLOWING SUBROUTINE SQUASHES MULTIPLE BLANKS IN THE\n* LINE PASSED TO IT IN R0-R1 IF THE SQUASH OPTION WAS GIVEN\n*        NOTE THAT THE ROUTINE DESTROYS R2,R4,R5, AND R6\n         SPACE\nSQUASHIT TM    WAFLAG1,WAFSQUSH    WAS SQUASH   OPTION GIVEN\n         BER   R14                 NO, RETURN\n         LTR   R5,R4               SET OLD LENGTH IN R5 AND TEST\n         BZR   R14                 NO SQUASH  NEEDED IF NULL LINE\n         LR    R1,R2               SET START POSITION\nFNDBLK   LA    R3,1(,R1)           SET POSSIBLE SQUSH MOVE POINT\nFNDNBLKL CLI   0(R1),C' '          LOOP FOR END OF BLANKS\n         BNE   FNDNBLK             BR IF NOT BLANK\n         LA    R1,1(,R1)           STEP TO NEXT POSITION\n         BCT   R5,FNDNBLKL         DECR COUNT AND LOOP\n         SR    R1,R3               BLANKS ENDED TEXT - LEAVE\n         BNPR  R14                    1 BLANK AT END AND\n         SR    R4,R1                  EXIT SQUASH\n         BR    R14\n         SPACE\nFNDNBLK  LR    R0,R1               GET NO OF BLANKS\n         SR    R0,R3                   TO SQUASH\n         BNP   FNDBLKL             NONE, SKIP MVC AND ADJUSTMENT\n         EX    R5,MVCTEXX          MOVE TEXT LEFT\n         SR    R4,R0               UPDATE SQUASHED   COUNT\n         LR    R1,R3               RESET R2 TO REST OF LINE\nFNDBLKL  CLI   0(R1),C' '          FIND START OF NEXT BLANK FIELD\n         BE    FNDBLK              GOT IT, GO TRY TO SQUASH\n         LA    R1,1(,R1)           STEP TO NEXT CHAR\n         BCT   R5,FNDBLKL          DECR COUNT AND LOOP\n         BR    R14                 DONE WITH SQUASH, RETURN\n         SPACE 3\nEXITNOW  XEXIT 2,8                      SCRAM\n         EJECT\nSPECHAN  TM    WAFLAG1,WAF2LNS          2ND OF TWO LINES INTO ON\n         BZ    CCKLN1                   NO, SEE IF FIRST\n         NI    WAFLAG1,255-WAF2LNS      RESET FLAG\n         B     OUTPNOW                  AND PUT OUT JOINED LINE\n         SPACE\nCCKLN1   CLC   0(1,R1),WA2LNCH          IS IT INDICATOR FOR TWOL\n         BNE   OUTPNOW                  NO, SINGLE LINE\n         LA    R1,1(,R1)                MOVE POINTER\n         BCTR  R0,0                     DECREMENT COUNTER\n         OI    WAFLAG1,WAF2LNS          SET SECOND PART OF LINE\n         TSEG  (1),(0)                  INTO OUTPUTTER\n         B     EXITNOW                  GO GET REST\n         SPACE\nHAVEMRK  TREDE                         WAIT FOR CARRIAGE RET (O\n         BP    CVGETCOM                 WANTS TO STOP\n         B     EXITNOW                  CONTINUE\n         SPACE 3\nMVCTEXT  MVC   0(0,R6),0(R2)            MOVE TEXT TO ASSEMBLY AREA\nMVCTEXX  MVC   0(0,R3),0(R1)            SQUISH TEXT MOVE\n         AIF   ('&DCEC' NE '1').LBL07\n         USING *,R15               TEMP ADDRESSABILITY\nATTN     LR    R7,R15\n         DROP  R15\n         USING ATTN,R7             PICK UP REAL ADDRESSABILITY\n         L     R3,8(R1)           POINT TO CP\n         OI    WAFLAG1,WAFCAN      TURN ON CANCEL FLAG\n         LA    R15,8\n         BR    R14\nCANCEL   DS    0H\n         BALR  R7,R0\n         USING *,R7\n         TM    WAFLAG1,WAFOFF      LIST OFF LINE\n         BO    CLOSEIT               YES - SET FOR DESPOT\n         MVI   BUF,C' '        BLANK RTB\n         MVC   BUF+1(254),BUF\n         MVC   BUF,=C'/*DEL'   INSURE DELETE\n         PUT   RPL=RPL          WRITE TRAILOR RECORD\nCLOSEIT  CLOSE (WYLRDR,FREE)         CLOSE AND FREE IT\n         STAX\n         B     CVGETCOM            DONE GET OUT\n         DS    0F\n*SWITCH   DC   A(RUONLAD)\nRUNINT   DC    C'RUN/LIST OFF INTERRUPTED'\n         DS    0F\nRUONLAD  DC  AL1(DESRTRN+LOCATRTN+DESMATCH+UNPRST),AL3(LSTWORK)\n         COPY  DAIRINT\nHEX      DC   C'0123456789ABCDEF'\n*COMMAREA DC   F'0'               INTRDR COMMUNICATIONS AREA\n*  ABOVE AREA MOVED TO CVTSO FOR REENTERABILITY\n.LBL07   DS    0H\n         SPACE\n         DROP  R3\n         SPACE 3\n         LTORG\n         EJECT\n         COPY  WYLCONST\n         EJECT\n         COMMON ,\n         EJECT\n         BLPRWA\n         EJECT\nWDWA     WDIOWA DSECT\n         SPACE\n         END\n./ ADD NAME=CR,SSI=00000002\nCR       TITLE 'WYLTSO CONVERSION ROUTINES'\n* PROPERTY OF C. U. C. C. A.\n         SPACE\nCR       CSECT\n         SPACE\n* REGISTER USAGE\n         SPACE\nWAR      EQU   8\nDR       EQU   6\nRR       EQU   4\nTR       EQU   3\nSR       EQU   2\n         SPACE\n         USING WA,WAR\n         USING DEC,DR\n         EJECT\n* DECIMAL TO BINARY CONVERSION\n* R1 POINTS TO A DECIMAL STRING, R0 CONTAINS THE LENGTH\n* R15 WILL CONTAIN THE RESULTING INTEGER\n         SPACE\nDTB      XENTER 2,8\n         SR    15,15                   CLEAR RESULT\nDTBL     LTR   0,0                     DONE?\n         BNP   DTBX\n         CLI   0(1),C'0'               DIGIT?\n         BL    DTBX                    BR IF TOO LOW\n         CLI   0(1),C'9'\n         BH    DTBX                    BR IF TOO HIGH\n         SR    SR,SR                   GET VALUE\n         IC    SR,0(,1)\n         SL    SR,=A(C'0')\n         MH    15,=H'10'               BUILD RESULT\n         ALR   15,SR\n         LA    1,1(,1)\n         BCTR  0,0\n         B     DTBL\n         SPACE\nDTBX     XEXIT 2,8\n         EJECT\n* HEXADECIMAL TO BINARY CONVERSION\n* R1 POINTS TO A HEX STRING, R0 CONTAINS THE LENGTH\n* R15 WILL CONTAIN THE RESULTING INTEGER\n         SPACE\nXTB      XENTER 2,8\n         SR    15,15\nXTBL     LTR   0,0                     DONE?\n         BNP   XTBX                    BR IF SO\n         SR    SR,SR\n         IC    SR,0(,1)                PICK UP DIGIT\n         CLI   0(1),C'A'\n         BL    XTBN\n         CLI   0(1),C'F'\n         BH    XTBN\n         SL    SR,=A(C'A'-10)\n         B     XTBB\n         SPACE\nXTBN     CLI   0(1),C'0'\n         BL    XTBX\n         CLI   0(1),C'9'\n         BH    XTBX\n         SL    SR,=A(C'0')\nXTBB     SLL   15,4                    ADD NEW DIGIT IN\n         OR    15,SR\n         LA    1,1(,1)                 NEXT DIGIT\n         BCTR  0,0\n         B     XTBL\n         SPACE\nXTBX     XEXIT 2,8\n         EJECT\n* BINARY TO DECIMAL CONVERSION\n* R15 CONTAINS AN INTEGER, R1 POINTS TO A AREA FOR THE RESULT\n* IF R0 IS 0 MINIMUM LENGTH NECESSARY IS USED\n* IF R0 IS POSITIVE THE RESULT IS RIGHT JUSTIFIED IN THE\n* AREA WITH THAT LENGTH\n         SPACE\nBTD      XENTER 2,8\n         LA    DR,DW                   GET A DOUBLE WORD\n         N     DR,=XL4'FFFFF8'\n         CVD   15,DEC                  CONVERT NUMBER TO PACKED\n         MVC   HEXS(16),ED15           EDIT MASK\n         LR    RR,1                    SAVE RESULT LOC.\n         LA    1,HEXS+15\n         EDMK  HEXS(16),DEC\n         LTR   15,15                   NEGATIVE?\n         BNM   *+10                    BR IF NOT\n         BCTR  1,0                     PUT IN A SIGN\n         MVI   0(1),C'-'\n         LA    TR,HEXS+16              COMPUTE ACTUAL LENGTH\n         SR    TR,1\n         LR    1,RR                    RESTORE RESULT POINTER\n         LTR   0,0                     FIELD SIZE GIVEN?\n         BP    *+8                     BR IF SO\n         LCR   0,0\n         AR    0,TR                    COMPUTE FIELD SIZE\n         LR    TR,0                    FIELD LENGTH\n         LA    SR,HEXS+16              COMPUTE STARTING ADDR\n         SR    SR,TR\n         BCTR  TR,0                    FOR MVC\n         EX    TR,BTDMV                MOVE TO RESULT LOC.\n         XEXIT 2,8\n         SPACE\nBTDMV    MVC   0(0,1),0(SR)\n         SPACE\nED15     DC    C' ',13X'20',X'2120'\n         EJECT\n* BINARY TO HEXADECIMAL CONVERSION\n* R15 CONTAINS AN INTEGER, R1 POINTS TO AN AREA FOR THE RESULT\n* R0 CONTAINS THE REQUESTED LENGTH OF THE RESULT\n         SPACE\nBTX      XENTER 2,8\n         ST    15,HEXW                 WORD TO BE CONVERTED\n         UNPK  HEXS(9),HEXW(5)         TO ZONED FORMAT\n         TR    HEXS(8),HEXTBL-C'0'     TO HEX FORMAT\n         LR    TR,0                    LENGTH\n         LA    SR,HEXS+8               COMPUTE ADDR TO MOVE FROM\n         SR    SR,TR\n         BCTR  TR,0\n         EX    TR,HEXMV                MOVE TO USERS AREA\n         XEXIT 2,8\n         SPACE\nHEXMV    MVC   0(0,1),0(SR)\n         EJECT\n* CONVERT DATE TO PRINTABLE FORMAT\n* R0 CONTAINS THE DATE IN 00YYDDDS FORM\n* THE RESULT IS PUT INTO AN AREA POINTED BY R1\n         SPACE\nDATE     XENTER 2,8\n         LA    DR,DW                   FIND DOUBLE WORD\n         N     DR,=XL4'FFFFF8'\n         ST    0,DEC+4                 PLANT DATE\n         UNPK  DEC(3),DEC+5(2)         CONVERT YEAR\n         MVC   6(2,1),DEC              PUT INTO AREA\n         PACK  DEC(8),6(2,1)           REPACK IT\n         CVB   TR,DEC                  CONVERT TO BINARY\n         ST    0,DEC+4                 STORE ORIG VALUE AGAIN\n         XC    DEC(6),DEC              CLEAR FOR CVB\n         NI    DEC+7,X'F0'             SET SIGN\n         OI    DEC+7,X'0C'\n         CVB   SR,DEC                  DAY OF YEAR\n         CL    SR,=A(31+28)            BEFORE FEB 28?\n         BNH   LEAP                    BR IF SO\n         N     TR,=F'3'                    FOR\n         BZ    LEAP                    BR IF SO\n         LA    SR,1(,SR)               ALLOW FOR FEB 29\nLEAP     LA    RR,10                   SET MONTH TO JAN\n         LA    TR,MONTHS\nML       CH    SR,0(,TR)               THIS MONTH?\n         BNH   MF                      BR IF SO\n         SH    SR,0(,TR)               TRY NEXT MONTH\n         LA    RR,10(,RR)\n         LA    TR,2(,TR)\n         B     ML\n         SPACE\nMF       CVD   RR,DEC                  CONVERT MONTH\n         UNPK  0(3,1),DEC+6(2)\n         MH    SR,=H'10'\n         CVD   SR,DEC                  CONVERT DAY\n         UNPK  3(3,1),DEC+6(2)\n         MVI   2(1),C'/'\n         MVI   5(1),C'/'\n         XEXIT 2,8\n         EJECT\n* CONVERT TIME TO PRINTABLE FORMAT\n* R0 CONTAINS THE TIME IN BINARY IN 100THS OF SECONDS\n* R1 POINTS TO AN AREA TO PUT THE RESULTING TIME IN CHARS\n         SPACE\nTIME     XENTER 2,8\n         LA    DR,DW                   FIND DOUBLE WORD\n         N     DR,=XL4'FFFFF8'\n         LR    TR,0\n         SR    SR,SR\n         D     SR,=F'100'              DISPOSE OF 100THS\n         SR    SR,SR\n         D     SR,=F'60'               GET SECONDS\n         MH    SR,=H'10'\n         CVD   SR,DEC\n         UNPK  DEC(3),DEC+6(2)\n         MVC   6(2,1),DEC\n         SR    SR,SR\n         D     SR,=F'60'               GET MINUTES\n         MH    SR,=H'10'\n         CVD   SR,DEC\n         UNPK  3(3,1),DEC+6(2)\n         MH    TR,=H'10'\n         CVD   TR,DEC                  HOURS\n         UNPK  0(3,1),DEC+6(2)\n         MVI   2(1),C':'\n         MVI   5(1),C':'\n         XEXIT 2,8\n         EJECT\n* CONSTANTS\n         SPACE\nMONTHS   DC    H'31,29,31,30,31,30,31,31,30,31,30,31,999'\n         SPACE\nHEXTBL   DC    C'0123456789ABCDEF'\n         SPACE 3\n         LTORG\n         EJECT\n* WORK AREA\n         SPACE\nWA       DSECT\n         XSA   2,8\n         DS    F                       INSURANCE\nDW       DS    2F                      DOUBLE WORD\nHEXW     DS    F\nHEXS     DS    CL16\n         SPACE 3\nDEC      DSECT\n         DS    D\n         SPACE\n         END\n./ ADD NAME=CVREAL,SSI=00000002\nCVRL     TITLE 'WYLTSO COMMUNICATION VECTOR TABLE'\n* PROPERTY OF C. U. C. C. A.\n         SPACE\nCVREAL   CSECT\n         SPACE\n*        USING CVSTART-X'C60',R12\n         USING CVSTART,R12\n         SPACE 3\n         COPY  CVTSO\n         EJECT\n         COPY  CVUSER\n         SPACE 3\nJCB      DS    0F\n         COPY  JCBTSO\n         SPACE 3\n         ROUTBLE ,\n         EJECT\n         COPY  WYLCONST\n         SPACE\n         END\n./ ADD NAME=FSCR\n         TITLE 'WYLBUR FULL SCREEN HANDLER'\n*        WYLBUR FULL SCREEN INTERFACE FOR WYLTSO\n*\n*        WRITTEN FOR GHI\n*\n*\nWYLFSCR  CSECT\n         LA    R2,SIZESCR\n         TPUT  SCREEN,(2),FULLSCR  ,     SEND 3270 SCREEN\n         LTR   R15,R15\n         BZ    SKIPRET\n         B     RETURN\nSKIPRET  EQU   *\n         L     R2,AREAADD\nBL       LA    R3,2048             2048\n         XR    R4,R4\n         L     R5,=XL4'40000000'\n         MVCL  R2,R4\n         LA    R3,2048             LOAD BACK LENGTH OF TGET\n         L     R7,AREAADD\n*\n*  THE TGET MACRO WILL READ ALL MODIFIED FIELDS FROM THE\n*    OUTPUTTED SCREEN. THE SEQUENCE OF INPUT FIELDS ARE :\n*    KEY PRESSED,CURSER ADDRESS,BUFFER ADDRESS,DATA,\n*    BUFFER ADDRESS,DATA.......\nREADSCR  EQU   *\n         TGET  (R7),(R3),ASIS\n         LR    R5,R15\n         LTR   R5,R5\n         BZ    SKIPZZZZ\n         B     RETURN\nSKIPZZZZ LR    R3,R7\n         MVC   KEY(1),0(R3)        SAVE PFKEY\n         CLI   KEY,X'6E'           RE-SHOW KEY\n         BE    SENDSCRN            YES JUST RE-SEND SCREEN\n         LR    R3,R7               SAVE ADDRESS OF GETMAINED DATA\n         LA    R4,8                BCT COUNT FOR TRANSLATE\nTRLOOP   TR    0(256,R3),HEXTABLE\n         LA    R3,256(R3)          TR THE NEXT 256 BYTES\n         BCT   R4,TRLOOP           DO IT FOR 2048 BYTES\n         B     LINECHAN            #### SCAN LINE CHANGES ####\nKEYS     L     R7,AREAADD          #### BEFORE COMMAND    ####\n         CLI   KEY,X'7D'           ENTER KEY PRESSED?\n         BE    TEST3270            YES, GO SCAN BUFFER\n         LR    R1,R7               NO, MUST BE PFKEY...\n         LA    R0,0                R0=0 IS PFKEY...R0=1 IS KEY COMMAND\n         CALL  FSSPFK              GO SEE WHAT IT IS\n*\nTEST3270 EQU   *\n         MVC   CURRADD(4),SAVECURR  COME HERE AFTER CHANGING LINES\n*   R7 HAS ADDRESS OF INPUT AREA\n*   R3 HAS LENGTH OF SCAN\n*\n         L     R7,AREAADD\n         LA    R3,2048\nINLOOP   CLC   0(3,R7),=XL3'11C1D5'  SCAN FOR COMMAND BUFFER\n         BNE   SKIPCO\n         B     HERECOMM\nSKIPCO   LA    R7,1(R7)\n         BCT   R3,INLOOP\n         CLI   LINEFLAG,X'00'\n         BE    DIRECRTN\n         MVI   LINEFLAG,X'00'\n         B     TPUTLOOP\n*  IF NO COMMAND ENTERED, SCAN FOR CHANGED LINES\n*\nLINECHAN EQU   *\n         MVC   FAKEIN(4),=C'0000'\n         MVC   SAVECURR(4),CURRADD\n         MVC   FAKELIN2(14),BLANKS\nCHANGE01 L     R7,AREAADD\n         MVI   LINEFLAG,X'00'\n         LA    R3,2048\nCHANGELO CLC   0(3,R7),=X'11C261'\n         BE    CHANGE02\n         CLC   0(3,R7),=X'11C5C1'\n         BE    CHANGE02\n         CLC   0(3,R7),=X'11C6D1'\n         BE    CHANGE02\n         CLC   0(3,R7),=X'11C761'\n         BE    CHANGE02\n         CLC   0(3,R7),=X'11C8F1'\n         BE    CHANGE02\n         CLC   0(3,R7),=X'114AC1'\n         BE    CHANGE02\n         CLC   0(3,R7),=X'114BD1'\n         BE    CHANGE02\n         CLC   0(3,R7),=X'114C61'\n         BE    CHANGE02\n         CLC   0(3,R7),=X'114DF1'\n         BE    CHANGE02\n         CLC   0(3,R7),=X'114FC1'\n         BE    CHANGE02\n         CLC   0(3,R7),=X'1150D1'\n         BE    CHANGE02\n         CLC   0(3,R7),=X'11D161'\n         BE    CHANGE02\n         CLC   0(3,R7),=X'11D2F1'\n         BE    CHANGE02\n         CLC   0(3,R7),=X'11D4C1'\n         BE    CHANGE02\n         CLC   0(3,R7),=X'11D5D1'\n         BE    CHANGE02\n         CLC   0(3,R7),=X'11D661'\n         BE    CHANGE02\n         CLC   0(3,R7),=X'11D7F1'\n         BE    CHANGE02\n         CLC   0(3,R7),=X'11D9C1'\n         BE    CHANGE02\n         CLC   0(3,R7),=X'115AD1'\n         BE    CHANGE02\n         CLC   0(3,R7),=X'115B61'\n         BE    CHANGE02\n         CLC   0(3,R7),=X'115CF1'\n         BE    CHANGE02\nCHANGE10 LA    R7,1(R7)\n         BCT   R3,CHANGELO\n         MVC   RESPONSE(50),BLANKS\n         CLI   FAKELIN2,C' '\n         BE    KEYS\n         CLI   FAKELIN2+7,C' '\n         BE    KEYS\nGOODRANG ST    R7,SAVE7\n         ST    R3,SAVE3\n         LA    R7,FAKEBLK\n         BAL   R14,SKIPLA14\n         L     R7,SAVE7\n         L     R3,SAVE3\n*\n         B     KEYS\nCHANGE02 MVI   MODFLAG,X'01'\n         L     R6,SAVES#\n         LA    R6,1(R6)\n         ST    R6,SAVES#\n*        MVC  0(3,R7),=C'XXX'\n         LA    R7,3(R7)\n         END\n./ ADD NAME=HELPLIST,SSI=00000159\n         TITLE '    H E L P L I S T   -   V E R S I O N   1 . 2   '\n************************************************************\n*                                                          *\n*              'HELPLIST' PROGRAM AT FPC                   *\n*                                                          *\n************************************************************\n         REGS\n         SPACE\n*        PROGRAM. HELPLIST.\n*        AUTHOR. UNKNOWN - FROM TOM GEE.\n*        MODIFIOR. BILL GODFREY,  PLANNING RESEARCH CORPORATION.\n*        INSTALLATION. FEDERAL POWER COMMISSION.\n*        DATE-UPDATED IN SOURCE LIBRARY. JANUARY 8 1974.\n*        REMARKS.\n*            DATE ADDED TO HEADING.\n*            SUBCOMMAND NAMES PREFIXED WITH 'SUBCOMMAND - '.\n*            INDENTATION CHANGED. CHECK FOR )X SYNTAX ADDED.\n*            USER MACROS - EASYCOME,GEHEN,REGISTER\n*\n*        MODIFIOR. JERRY PITTENGER, PLANNING RESEARCH CORPORATION.\n*        INSTALLATION. OFFICE OF MANAGEMENT AND BUDGET (OMB).\n*        DATE-UPDATED IN SOURCE LIBRARY. AUGUST 17 1977.\n*        REMARKS:\n*            DATE REMOVED FROM HEADING. MULTIPLE HEADING LINES.\n*            CHANGE FROM )O OR )X OR )F HIGHLIGHTED BETTER.\n*            ALLOW NO ALIAS TO PRINT BY USING BLDL AGAINST\n*            THE SYSUT1 LIBRARY/LIBRARIES DIRECTORY. INSERTED\n*            SUBCOMMANDS ON SEPARATE PAGES WITH THE SUBCOMMAND\n*            NAME IN THE HEADER BLOCK.\n         EJECT\n*            CURRENT REGISTER USAGE:\n*\n*            R0 = SYSTEM PARM REG\n*            R1 = SYSTEM PARM REG\n*            R2 = PROGRAM PARM REG + WORK REG\n*            R3 = WORK REG\n*            R4 = RECORD LENGTH\n*            R5 = BLOCKSIZE\n*            R6 = SPARE\n*            R7 = SPARE\n*            R8 = OFFSET INTO MEMBER DSECT\n*            R9 = WORK REG\n*           R10 = ADDRESS OF 'LINE'\n*           R11 = I/O AREA BASE\n*           R12 = PROGRAM BASE\n*           R13 = SAVE AREA POINTER\n*           R14 = SYSTEM RETURN ADDR\n*           R15 = PROGRAM RETURN ADDR\n*\n*        NON-STANDARD MACROS USED: KOMMEN AND GEHEN\n*\n         EJECT\nHELPLIST CSECT\n         STM   14,12,12(13)\n         LR    12,15\n         USING HELPLIST,12\n         LA    11,SAVEEM\n         ST    13,4(11)\n         ST    11,8(13)\n         LR    13,11\n         L     2,0(,1)             REG 2 --> PARM\n         MVI   LINE-1,C' '\n         MVC   LINE,LINE-1\n         LA    R10,LINE                POINT R10 TO 'LINE'\n         MVI   HEAD-1,C' '\n         OPEN  (IN,,HELP,,OUT,OUTPUT)\n         TM    IN+48,X'10'             OPEN OK?\n         BO    PARMCHK                 YES....SYSIN SPECIFIED\n         BZ    OPENERR                 NO....CAN'T OPEN\nPARMCHK  CLI   1(2),0              PARM?\n         BE    NOPARM\n         LH    3,0(,2)             R3  =  LENGTH OF PARM\n         CLI   1(2),9              PARM LENGTH GREATER THAN 9?\n         BNH   *+8                 NO - BRANCH\n         LA    3,9                 YES - REDUCE TO 9\n         BCTR  3,0                 LENGTH MINUS 1 FOR EX\nNOPARM   EQU   *\n         LH    R0,HELP+62               BLOCKSIZE\n         GETMAIN R,LV=(0)\n         LR    R11,R1                   SAVE POINTER TO I/O AREA\nCNTRL    EQU   *\n         GET   IN,REC                   READ A CONTROL CARD\n         MVC   MEM1(8),REC              MOVE TO BLDL AREA\n         MVC   MEMNAME,REC              SAVE DESIRED MEMBER NAME\n         LA    R1,HELP                  POINT TO DCB FOR BLDL\n         LA    R0,LSTSTRT               POINT TO BLDL LIST\n         BLDL  (R1),(R0)                GO GET IT\n         B     *+4(R15)                 TEST RETURN CODE\n         B     MOVE                     GOOD MEMBER\n         B     BADONE                   ALIAS OR INVALID MEMBER\n         B     BLDLERR                  GO ISSUE ABEND..PERM I/O ERROR\nBADONE   EQU   *\n         MVC   MEM1+8(6),=X'000000000000' ZERO OUT BLDL TTR FIELD\n         B     CNTRL                    GO GET THE NEXT MEMBER\nMOVE     TM    MEM1+13,X'80'            IS IT AN ALIAS???\n         BO    INDICATE                 ALIAS GO INDICATE SO\n         OR    R7,R7                    ZERO OUT R7\n         OR    R6,R6                    ZERO OUT R6\n         LA    R6,8                     LOAD A CONSTANT\n         LA    R14,REC                  LOAD ADDRESS TO CHECK\n         LA    R6,0(R6,R14)             COMBINE THE TWO\nCOMPR    CLI   0(R6),X'40'              CHECK FOR A BLANK\n         BNE   COMPDONE                 IF NOT...FINISHED\n         CR    R6,R14                   FINISHED YET???\n         BE    COMPDONE                 YES\n         BCT   R6,COMPR                 DOWN 1 AND CHECK AGAIN\nCOMPDONE EQU   *                        R6 ALREADY -1 FOR EXECUTE\n         SR    R6,R14                   LEAVE THE NUMBER OF CHARS\n         STC   R6,MEMLEN                SAVE MEMBER LENGTH FOR EXEC\n         LA    R7,8                     LOAD A CONSTANT\n         LA    R6,1(R6)                 PUT R6 BACK UP\n         SR    R7,R6                    GET NUMBER OF BLANKS\n         STC   R7,OFFSET                OFFSET FOR CENTERING ON HDR\n         SRL   R7,1                     DIVIDE BY 2\n         STC   R7,MEMOFFST              SAVE FOR OFFSETTING\n         NI    OP,255-STILLSC           TELL EM NOT SUBCOMMAND ANYMORE\n         NI    OP,255-SCSAVED           SUBCOMMAND NOT SAVED ANY MORE\n         FIND  HELP,MEMNAME,D           FIND MEMBER\n         B     *+4(R15)                 TEST RETURN CODE\n         B     *+12                     GOOD RETURN\n         B     BADNAME                  INVALID NAME\n         B     IOERROR                  I/O ERROR\nRDSETUP  NI    OP,255-OPINDENT-OPCMDS   TURN OFF INDENTION & CMDS\n         CLC   MEMNAME,=CL8'COMMANDS'   COMMANDS?\n         BNE   *+8                      NO, ....\n         OI    OP,OPCMDS                YES, INDICATE SUCH\n         TM    OP,ALIAS                 ALIAS ALREADY CAUSED TOF???\n         BO    READEM                   YES, NO HEADER\n         ZAP   CTRLIN,=P'0'        FORCE HEADING\nREADEM   EQU   *\n          NI    OP,255-ALIAS             TURN OFF ALIAS FLAG\n         READ  DECB,SF,HELP,(R11),'S'\n         CHECK DECB\n         LH    R5,HELP+62               BLOCK SIZE\n         L     R1,DECB+16               A(IOB)\n         SH    R5,14(R1)                MINUS RESIDUAL CCW COUNT\n         BCTR  R5,0                     DOWN ONE\n         LR    R3,R11                   REC START\n         LA    R4,80                    REC LENGTH\n         LA    R5,0(R3,R5)              REC END\nPROCESS  TM    OP,OPCMDS                CMDS?\n         BZ    PROCESSA                 NO, CONTINUE\n         MVC   LINEPL(72),0(R3)         YES, COPY IN RECORD\n         B     LISTER                   GO LIST IT\nPROCESSA CLC   0(2,R3),=C')F'           FUNCTION\n         BE    MAJOR\n         CLC   0(2,R3),=C')S'           SUBCOMMANDS\n         BE    MAJOR\n         CLC   0(2,R3),=C')X'           SYNTAX\n         BE    MAJOR\n         CLC   0(2,R3),=C')O'           OPERANDS\n         BE    INDENT\n         CLI   0(R3),C'='               SUB COMMAND\n         BNE   CHEKOP                   NO\n         OI    OP,SUBCOMD               TELL EM SUBCOMD\n         NI    OP,255-SCSAVED           TELL EM NEW SUBCOMMAND\n         NI    OP,255-STILLSC           NOT CONTINUED SUBCMD\n         B     SUBCMD                   GO SEPARATE\nCHEKOP   CLC   0(2,R3),=C'))'           YES - OPERAND?\n         BE    NOTDUMB                  YES - BRANCH\n         CLC   0(2,R3),=C'  '           NO, CHECK FOR LACK OF NEATNESS\n         BE    NOTDUMB                  VERY GOOD - BRANCH\n         MVC   LINEIND(72),0(R3)  SOME DUMMY DIDN'T LEAVE 1ST 2 BLANK\n         B     LISTER\nNOTDUMB  MVC   LINEIND(70),2(R3)        YES, SET LINE WITH INDENTION\n         B     LISTER\nNORMAL   TM    OP,MAJ                   MAJOR SEPARATION???\n         BNO   LISTER1                  NO....LIST IT\n         MVC   LINEMAJ(70),2(R3)        MOVE IN DATA\n         MVC   3(3,R10),=C'***'          INSERT HIGHLIGHTER\n         MVC   18(3,R10),=C'***'         INSERT HIGHLIGHTER\n         NI    OP,255-MAJ               TURN OFF SWITCH\n         B     LISTER\nLISTER1  MVC   LINEPL(70),2(R3)\nLISTER   CP    CTRLIN,CTRMAX\n         BNH   *+10\n         ZAP   CTRLIN,=P'0'\n         TM    OP,CMDSEP                NEED COMMAND NAME???\n         BO    HEADALI                  YES...GO DO IT\n         CP    CTRLIN,=P'0'\n         BE    HEADING1                 GO SEE IF STILL SUBCOMMAND\nREPORTD  AP    CTRLIN,=P'1'\n         CLI   LINE,C'0'           DOUBLE SPACING?\n         BNE   *+10                NO - BRANCH AROUND AP\n         AP    CTRLIN,=P'1'\n         TM    OP,SUBCOMD                IS IT SUBCOMMANDS???\n         BNO   PUTIT                     NO....LIST ASIS\n         NI    OP,255-SUBCOMD            TURN OFF SWITCH\n         MVC   3(3,R10),=C'***'          INSERT HIGHLIGHTER\nPUTIT    PUT   OUT,LINE\n         MVC   LINE,LINE-1         CLEAR LINE\nBXLE     BXLE  R3,R4,PROCESS       SCAN ENTIRE BLOCK\n         B     READEM                   READ ANOTHER BLOCK\nHEADING1 TM    OP,STILLSC               IS IT STILL SUBCOMMAND????\n         BO    SUBCMD                   YES.....GO DO IT THAT WAY\nHEADING  MVC   HEAD,HEAD-1              CLEAR IT\n         NI    OP,255-STILLSC           NOT SUBCOMMAND ANYMORE\n         MVI   HEAD,C'1'                SET TO EJECT\n         MVC   HEAD+2(60),ITELID         TOP OF PAGE ID\n         PUT   OUT,HEAD                 WRITE IT\nHEADALI  AP    CTRLIN,=P'5'             1 EA. FOR HDR + HIGHLIGHTERS\n         NI    OP,255-CMDSEP            TURN OFF COMMAND PRINT SW\n* THE OTHERS ARE ALREADY TAKEN INTO ACCOUNT\n         MVC   HEAD,HEAD-1              CLEAR LINE\n         MVI   HEAD,C'0'                DOUBLE SPACE\n         MVC   HEAD+35(10),=C'----------' COMMAND HIGHLIGHTER\n         PUT   OUT,HEAD                 PUT IT\n         MVI   HEAD,C' '                SET TO SINGLE SPACE\n         MVC   HEAD+35(10),=C'          ' BLANK OUT HEADER\n         OR    R6,R6                    ZERO OUT R6\n         IC    R6,MEMOFFST              GET THE OFFSET FOR MOVE\n         LA    R7,HEAD+36               PICK UP MOVE LOCATION\n         LA    R7,0(R7,R6)              LOAD R7 W/LOCATION + OFFSET\n         IC    R6,MEMLEN                PICK UP LENGTH TO MOVE\nMOVEMEM  MVC   0(0,R7),MEMNAME          EXECUTED BELOW\n         EX    R6,*-6                   MOVE IN THE MEMBER NAME\n         PUT   OUT,HEAD                 PUT OUT CENTERED NAME\n         MVC   HEAD+35(10),=C'----------' COMMAND HIGHLIGHTER\n         PUT   OUT,HEAD                 PUT IT\n         MVC   HEAD,HEAD-1              BLANK OUT HEAD\n         MVI   HEAD,C'-'                SET TO TRIPLE SPACE\n         PUT   OUT,HEAD                 WRITE BLANK HEADS\n         B     REPORTD\nMAJOR    NI    OP,255-OPINDENT          TURN OFF INDENTION\n         MVI   CC,C'0'                  DOUBLE SPACE\n         OI    OP,MAJ                   TURN ON SWITCH\n         B     NORMAL\nSUBCMD   TM    OP,STILLSC               IS IT STILL SUBCOMMAND???\n         BO    SUBCMD1                  YES, LONG MEMBER\n         CP    CTRLIN,=P'60'            ENOUGH ROOM FOR NEW ONE??\n         BL    ADD5                     YES, GO GETEM\nSUBCMD1  MVC   HEAD,HEAD-1              CLEAR IT\nNEWPG    ZAP   CTRLIN,=P'0'             REINITIALIZE LINE COUNT\n         MVI   HEAD,C'1'                SET TO EJECT\n         MVC   HEAD+2(59),ITELID         TOP OF PAGE ID\n         PUT   OUT,HEAD                 WRITE IT\nADD5     AP    CTRLIN,=P'5'             1 EA. FOR HDR + HIGHLIGHTERS\n* THE OTHERS ARE ALREADY TAKEN INTO ACCOUNT\n         MVC   HEAD,HEAD-1              CLEAR LINE\n         MVI   HEAD,C'0'                DOUBLE SPACE\n         MVC   HEAD+27(27),DASHES       COMMAND HIGHLIGHTER\n         PUT   OUT,HEAD                 PUT IT\n         MVC   HEAD,HEAD-1              CLEAR THE DASHES\n         MVI   HEAD,C' '                SET TO SINGLE SPACE\n         OR    R6,R6                    CLEAR IT\n         MVI   HEAD+41,C'-'             PUT IN THE SEPARATOR\n         LA    R7,HEAD+28               PICK UP LOCATION\n         IC    R6,OFFSET                PICK UP THE OFFSET\n         LA    R7,0(R6,R7)              POINT R7 TO LOCATION + OFFSET\n         IC    R6,MEMLEN                PICK UP LENGTH TO MOVE\nMEMMVC   MVC   0(0,R7),MEMNAME          EXECUTED BELOW\n         EX    R6,*-6                   MOVE IN MEMNAME\n* PRESUPPOSES THAT SUBCOMMAND HAS AN '=' SIGN IN FRONT OF IT\n         TM    OP,SCSAVED               HAS SUBCOMMAND BEEN SAVED???\n         BNO   R3MOVE                   IF NOT GET OFF OF R3\n         MVC   HEAD+44(8),SCSAVE        HAS BEEN SAVED....GET IT\n         B     DONEMOVE                 GO AROUND R3 MOVE\nR3MOVE   MVC   HEAD+44(8),1(R3)         MOVE IN SUBCOMMAND NAME\n         MVC   SCSAVE(8),1(R3)          SAVE THE SUBCOMMAND NAME\n         OI    OP,SCSAVED               AND TURN ON THE FLAG\nDONEMOVE LA    R14,HEAD+44              SET UP FOR '=' CHECK\n         LA    R15,8                    LENGTH TO CHECK\nSUBCX    CLI   0(R14),C'='              IS IT AN '=' SIGN\n         BE    SUBCX1                   YES....GO BLANK IT\n         LA    R14,1(R14)               BUMP TO NEXT CHAR\n         BCT   R15,SUBCX                GO CHECK FURTHER\nSUBCX1   MVC   0(9,R14),=C'         '   MOVE IN BLANKS\n         PUT   OUT,HEAD                 WRITE IT\n         MVC   HEAD+27(27),DASHES       HIGHLIGHT IT\n         PUT   OUT,HEAD                 WRITE EM\n         MVC   HEAD,HEAD-1              BLANK IT\n         MVI   LINE,C'-'                SET FOR TRIPLE SPACE\n         OI    OP,STILLSC               SET SUBCOMMAND HEADER SWITCH\n         TM    OP,SUBCOMD               LONG MEMBER OR NEW SUBCOMMAND?\n         BNO   REPORTD                  LONG MEMBER...LINE PRESENT\n         NI    OP,255-SUBCOMD           TURN OFF THE SWITCH\n         B     BXLE                     GO GET SOME MORE\nINDENT   OI    OP,OPINDENT              TURN ON INDENTION\n         MVI   CC,C'0'                  DOUBLE SPACE\n         OI    OP,MAJ                   TURN ON SWITCH\n         B     NORMAL\nFINI     DS    0H\n         CLOSE (OUT,,HELP,,IN)\n         L     13,4(13)\n         LM    14,12,12(13)\n         SR    R15,R15\n         BR    R14\n         SPACE 2\nBADNAME  DS    0H\n         MVC   LINE+10(L'ENAME),ENAME   INVALID MEMBER NAME\n         B     MSGOUT\nIOERROR  DS    0H\n         MVC   LINE+10(L'EIO),EIO       I/O ERROR\nMSGOUT   MVC   LINE+1(8),MEMNAME        PUT IN MEMBER NAME\n         MVI   CC,C'1'                  EJECT A PAGE\n         PUT   OUT,LINE                 PRINT ERROR MSG\n         MVC   LINE,LINE-1              CLEAR OUT LINE\n         B     CNTRL\nINDICATE EQU   *                        ALIAS PROCESSING\n         MVC   HEAD,HEAD-1              CLEAR LINE\n         TM    OP,ALIAS                 BEEN HERE BEFORE???\n         BNO   INDIC1                   NO, FORCE HEADING\n         MVI   HEAD,C'0'                DOUBLE SPACE\n         B     INDIC2                   NO HEADING\nINDIC1   MVI   HEAD,C'1'                FORCE HEADING\n         NI    OP,255-STILLSC           NOT SUBCMD ANYMORE\n         MVC   HEAD+2(59),ITELID        INSTALLATION CODE\n         PUT   OUT,HEAD\n         MVC   HEAD,HEAD-1\n         MVI   HEAD,C'0'                DOUBLE SPACE\n         ZAP   CTRLIN,=P'0'             RESET LINE COUNT\n         AP    CTRLIN,=P'1'\nINDIC2   MVC   HEAD+27(27),DASHES       HIGHLITE\n         PUT   OUT,HEAD\n         MVC   HEAD,HEAD-1              CLEAR LINE\n         MVI   HEAD,C' '                SINGLE SPACE\n         MVC   HEAD+30(8),MEMNAME       MOVE IN MEMBER NAME\n         MVC   HEAD+38(12),=C' IS AN ALIAS'\n         PUT   OUT,HEAD\n         MVC   HEAD,HEAD-1              CLEAR LINE\n         MVC   HEAD+27(27),DASHES       HIGHLITE\n         PUT   OUT,HEAD\n         MVC   HEAD,HEAD-1              CLEAR LINE\n         MVI   HEAD,C' '                SPACE\n         PUT   OUT,HEAD\n         AP    CTRLIN,=P'5'             MAKE LINECT CORRECT\n         OI    OP,ALIAS                 SAY WE HAVE BEEN HERE\n         OI    OP,CMDSEP                PRINT COMMAND NAME ALSO\n         B     CNTRL                    GO GET NEXT MEMBER\n         EJECT\n         DS    0D\nMEMNAME  DC    CL8'0'\nREC      DC    CL80'0'\n         DC    C'0'\nLINE     DS    0CL133\nCC       DC    CL1'0'\n         DC    CL132'0'\nLINEMAJ  EQU   LINE+6\nLINEPL   EQU   LINE+8\nLINEIND  EQU   LINEPL\n         DC    CL1'0'\nHEAD     DC    CL133'0'\nENAME    DC    C'- INVALID AS SPECIFIED'\nEIO      DC    C'- I/O ERROR OCCURRED WHILE LOCATING NAME'\nH9       DC    H'9'\nDASHES   DC    27C'-'       SUBCOMMAND HIGHLIGHTER\nMEMLEN   DC    B'0'\nOFFSET   DC    B'0'\nMEMOFFST DC    B'0'\nOP       DC    B'0'\nOPINDENT EQU   B'10000000'\nOPCMDS   EQU   B'01000000'\nSTILLSC  EQU   B'00100000'  SUBCOMMAND HEADER FLAG\nSCSAVED  EQU   B'00010000'  SUBCOMMAND HAS BEEN SAVED FLAG\nALIAS    EQU   B'00001000'  SPARE FLAG\nMAJ      EQU   B'00000100'  MAJOR SEPARATION\nSUBCOMD  EQU   B'00000010'  SUBCOMMAND SEPARATION\nCMDSEP   EQU   B'00000001'  PRINT COMMAND NAME FLAG\nSCSAVE   DC    D'0'         SUBCOMMAND SAVE AREA\nBLKADDR  DC    F'0'\nCTRMAX   DC    P'076'\nCTRLIN   DC    P'000'\n         SPACE\n         SPACE\n         PRINT NOGEN\n         LTORG\n         SPACE\n         DS    0D\nLSTSTRT  DC    X'0001000E'   TELL BLDL MAX NUMBER AND LENGTH\nMEM1     DC    2F'0'\nDUMMYFW  DC    F'0'\nDUMMYHW  DC    H'0'\nBLDLERR  ABEND 2222,DUMP     BLDL ERROR\nOPENERR  ABEND 1111,DUMP     CAN'T OPEN\nITELID  DC C'                    ITEL - TSO COMMAND LANGUAGE REFERENCE'\nSAVEEM   DC    18F'0'        SAVE AREA\nIN       DCB   DSORG=PS,MACRF=GM,EODAD=FINI,DDNAME=SYSIN\n         SPACE\nOUT      DCB DSORG=PS,MACRF=PM,RECFM=FA,BLKSIZE=133,DDNAME=SYSPRINT\n         SPACE\nHELP     DCB   DSORG=PO,MACRF=R,EODAD=CNTRL,DDNAME=SYSUT1\n         END\n./ ADD NAME=INIT     0103-80189-80234-0730-01014-00949-01014-$SYS13  00\nINIT     TITLE 'WYLTSO INITIALIZATION ROUTINE'\n*  WYLBUR MVS/TSO VERSION 1.1\n         SPACE\n         COPY  PMAC\n         SPACE\n         USING CPAREA,R12\n         SPACE 3\n         ENTRY INITWYL\nINITWYL  CSECT\n         DC    24XL256'00'         DUMMY MODULE\n         ORG   INITWYL\n         LR    R7,R15              GET ADDRESSABILITY\n         LR    R4,R1               ADDRESS OF REAL CV\n         LR    R8,R14              RETURN ADDRESS\n         SPACE\n*** WARNING *** R8 MUST NOT BE ALTERED *** WARNING ***\n         SPACE\n         USING INITWYL,R7\n         L     R0,=A(CVCPSIZE)     DETERMINE GETMAIN SIZE\n         A     R0,=F'1024'         FOR TRACE AREA\n         A     R0,=A(PIOBSIZE)     FOR RECOVERY IOB\n         GETMAIN R,LV=(0),PAGE       GO GET 'EM\n         SPACE\n* WE GOT IT IF WE SURVIVE TO GET HERE\n         LR    R12,R1              POINT TO THE AREA\n         LA    R13,CPWA\n         SPACE\n* CLEAR THE 'CP' PART OF THE AREA\n         SLR   R0,R0               CLEAR FOR MVCL\n         LR    R2,R1             AREA TO CLEAR\n         LA    R1,0              FILL CHAR INTO REG 1\n         LA    R3,CPSIZE          SIZE OF AREA TO CLEAR\n         MVCL  R2,R0             CLEAR THE AREA\n* COPY THE REAL CV INTO OUR AREA. R4 POINTS TO IT.\n         LA    R3,CVSIZE            SIZE TO MOVE\n         LR    R5,R3                ALSO IN REG 5\n         LA    R2,CVSTART           AREA TO MOVE TO\n         MVCL  R2,R4                MOVE IT\n         SPACE\n* CLEAR JCB FIELDS\n         XC    JCBSTART(JCBSIZE),JCBSTART\n         SPACE\n*\nCOPYWA   LOAD  EP=WYLWA\n         ST    R0,CVIOWA           SAVE ADDR OF WORK AREA\n         ST    R11,CVRETURN        SAVE OS RETURN ADDR\n         SPACE\n* INITIALIZE THE TRACE AREA\n         OFFSET R1,CVCPEND\n         ST    R1,CVTRSTRT         START OF TABLE\n         ST    R1,CVTRACE          CURRENT ENTRY\n         LA    R2,1024-16(,R1)\n         ST    R2,CVTREND          END OF TABLE POINTER\n         SPACE\n* NOW CLEAR THE AREA\n         LR    R2,R1               SET REG FOR MOVE AREA\n         LA    R3,1024             LENGTH TO MOVE\n         LA    R0,0                FOR CLEAR AREA\n         LA    R1,0                FILL LENGTH\n         SPACE\n* CLEAR RECOVERY IOB AND SAVE ITS ADDRESS IN CV\n         ST    R2,CVPIOB\n         XC    0(PIOBSIZE,R2),0(R2)\n         SPACE\n* INITIALIZE ALL THE CONTROL BLOCKS\nINIT2    LA    R1,&NUMPAGE         NUMBER OF PAGES IN SYS\n         OFFSET R2,CVPAGE1         POINT TO FIRST PAGE\n         USING PCB,R2\nPAGEINIT XC    PCBPT(PCBSIZE-PCBPSIZE),PCBPT\n         MVI   PCBFLG1,X'42'\n         LA    R3,PCBECB\n         ST    R3,PCBECBP-1        SAVE POINTER TO ECB\n         LA    R3,PCBCCWS          ADDR OF CHAN PROG\n         ST    R3,PCBCCWP-1        SAVE IN IOB\n         OFFSET R3,PFCB1+PFCBDCB-PFCB\n         ST    R3,PCBDCB-1         SAVE IN IOB\n         SPACE\n* NOW INITIALIZE THE CHANNEL PROG\n         LA    R3,PCBSEEK+3\n         ST    R3,PCBCCWS\n         MVI   PCBCCWS,X'31'       MOVE IN OP-CODE\n         MVI   PCBCCWS+4,X'40'     COMMAND CHAIN\n         MVI   PCBCCWS+7,X'05'     LENGTH OF 5\n         LA    R3,PCBCCWS\n         ST    R3,PCBCCWS+8        SAVE TIC ADDRESS\n         MVI   PCBCCWS+8,X'08'     TIC OP-CODE\n         LA    R3,PCBBUF           ADDRESS OF BUFFER\n         ST    R3,PCBRWCCW         SAVE INTO CCW\n         MVI   PCBRWCCW,X'06'      OP-CODE\n         MVC   PCBRWCCW+6(2),=AL2(PCBPSIZE)\n         SPACE\n* ALL DONE FOR THIS PAGE\n         LA    R2,PCBSIZE(,R2)     NEXT\n         BCT   R1,PAGEINIT         GET REMAINDER OF PAGES\n         DROP  R2\n         OFFSET R3,CVDDLIST\n         ST    R3,CVDDNAMS\n         OFFSET R3,PCBTABLE\n         ST    R3,CVPADDRS\n         LA    R0,&NUMPAGE\n         OFFSET R1,CVPAGE1         FIRST PAGE\nPCBLOOP  ST    R1,0(,R3)\n         LA    R3,4(,R3)\n         LA    R1,PCBSIZE(,R1)\n         BCT   R0,PCBLOOP\n         SPACE\n* GET TIOT POINTER\n         LA    R2,CPSTART          USE AREA AS BUFFER FOR EXTRACT\n         EXTRACT (R2),FIELDS=(TIOT,TSO,PSB),MF=(E,(R2))\n         L     R3,CPSTART+8        GET PSCB ADDR\n         L     R10,CVIOWA          WORK AREA\n         USING WDIOWA,R10\n         ST    R3,WAPSCB           SAVE PSCB ADDR IN WORK AREA\n         L     R4,CPSTART+4        TSO FIELD IN THE TCB\n         TM    0(R4),X'80'         ARE WE TSO BOUND?\n         BZ    NONTSO\n         OI    JCBAFL,JCBTSO       WE ARE UNDER TSO\n         TM    16(R3),X'80'        PRIV?\n         BZ    *+8\n         OI    JCBAFL,JCBSYSPR\n         LOAD  EP=IKJEFD00         NAME OF MODULE\n         ST    R0,CVDAIR\n         SPACE\n* INITIALIZE USER ID\n*\n*\n*\nNONTSO   EQU    *\n         L     R2,CPSTART        TIOT POINTER\n         MVC   CPUSER(8),0(R2)    MOVE IN USER ID\n         B     LETNOV                                  ITEL\n         TM    JCBAFL,JCBSYSPR    PRIV\n         BZ    *+18               NO\n         CLC   CPUSER(4),=CL4'TECH'  IS IT ALSO TECH\n         BE    *+8                YES, CONT\n         NI    JCBAFL,255-JCBSYSPR  TURN OFF PRIV\nLETNOV   OI    JCBAFL,JCBSYSPR     TURN ON PRIV         ITEL\n         LA    R2,24(,R2)          SKIP JOB,PROC,STEP NAMES\n         ST    R2,CVTIOT           SAVE\n         TM    JCBAFL,JCBTSO       ARE WE UNDER TSO?\n         L     R2,WAPSCB           PICK UP PSCB ADDRESS\n         LA    R2,7(R2)            POINT TO USER ID LEN\n         IC    R2,0(R2)            PICK UP LENGTH\n         STC   R2,CVUSRFLD         SAVE LENGTH FOR POSTERITY\n         SPACE\n* INITIALIZE PFCB & PAGE POINTERS\n         OFFSET R2,FRSTPAGE\n         ST    R2,CVFPAGE          SAVE IT\n         OFFSET R2,LASTPAGE\n         ST    R2,CVLPAGE\n         OFFSET R2,FRSTPFCB\n         ST    R2,CVFPFCB\n         USING FRSTPFCB,R2\n         LA    R2,LASTPFCB\n         DROP  R2\n         ST    R2,CVLPFCB\n         OFFSET R3,WAFORRTB\n         ST    R3,RTBWAPTR\n         XC    0(L'WAFORRTB,R3),0(R3) CLEAR IT TOO\n         MVI   RTBLSZ+1(R3),133\n         MVI   RTBPSZ+1(R3),25\n         L     R4,544              PICK UP ASCB  FROM PSAANEW\n         L     R4,60(R4)           PICK UP TSB ADDRESS          J\n         SLR   R1,R1               CLEAR FOR SVC\n*        SVC   254                       KEY 0\n         MODESET KEY=ZERO\n         TM    0(R4),X'20'         ASSUME DISP SCREEN IS 3277\n         BZ    NOT3277             NOT US...GO AROUND FLAG SET\nIS3277   OI    LFLG1,CPF3277       SET 3277 FLAG\nNOT3277  EQU    *                 CONTINUE\n         MVC   CPDOUB+5,=CL3' '\n         MVC   CPDOUB(5),CPUSER  USER ID\n         SLR   R2,R2\n         IC    R2,8(,R4)         GET TSBLNSZ\n         LH    R4,36(,R4)        GET TSBATNLC\n         LA    R1,4                CLEAR FOR SVC\n         MODESET KEY=NZERO\n*        SVC   254                       PROBLEM KEY\n         LR    R0,R4\n         LR    R1,R2\n         LTR   R0,R0\n         BNP   NOCRT\n         C     R0,=F'255'\n         BH    NOCRT\n         STH   R0,RTBPSZ(,R3)\n         OI    RTBMFL,RTBCRT\nNOCRT    LTR   R1,R1\n         BNP   NOLIN\n         C     R1,=F'133'\n         BH    NOLIN\n         LA    R1,133              TEMP UNIL TSB IS FOUND\n         STH   R1,RTBLSZ(,R3)\nNOLIN    L     R1,WAPSCB           GET PSCB\n         L     R1,52(,R1)          GET UPT FROM PSCB\n         ST    R1,WAUPT            SAVE UPT\n         SPACE\n         L     R1,16               CVT @\n         L     R1,0(,R1)           CURRENT TCB POINTER\n         L     R1,0(,R1)           CURRENT TCB @\n         L     R1,132(,R1)         MOTHER TCB @\n         L     R1,112(,R1)         MOTHER TCB'S S.A. PTR\n         L     R1,8(,R1)           CALLER'S S.A. PTR\n         L     R1,24(,R1)          CALLER'S R1 = IOPL FOR CALL\n         L     R1,4(,R1)           CALLER'S ECT\n         ST    R1,WAECT            WOW...\n         SPACE\n         OFFSET R3,WORKAREA\n         ST    R3,JCBWAPTR         SAVE POINTER TO IT\n         TM    JCBAFL,JCBTSO       ARE WE A TSO TASK?\n         BZ    NOTCP               NO.. SO DONT LOOK\n         L     R11,8(,R9)          GET A POSSIBLE PSCB ADDR\n         C     R11,WAPSCB          ARE WE A 'CP' ?\n         BNE   NOTCP               NO.. MUST BE VIA A CALL\n         L     R11,4(,R9)          UPT ENTRY\n         ST    R11,WAUPT\n         L     R11,12(,R9)         ENVIRON. CTL TAB\n         ST    R11,WAECT\n         L     R1,0(,R9)           POINTER TO COMMAND BUFFER\n         LH    R2,0(,R1)\n         SH    R2,=H'11'           4 + SIZE('WYLBUR ')\n         LA    R1,4+7(,R1)         TEXT IS FOLLOWING 'WYLBUR '\n         B     GOTPARM             GO PROCESS PARM\n         SPACE\nNOTCP    L     R1,0(,R9)           POINTER TO PARMS\n         LH    R2,0(,R1)           GET LENGTH\n         LA    R1,2(,R1)           POINT TO TEXT\nGOTPARM  LTR   R2,R2               ANYTHING?\n         BNP   NOPARMS\n         ST    R1,CVPARM           SAVE PARM POINTER\n         STC   R2,CVPARM           AND LENGTH\n         SPACE\n* INITIALIZE THE PFCB\nNOPARMS  OFFSET R2,PFCB1\n         USING PFCB,R2\n         MVC   PFCBDCB(PFCBDSZ1),DUMMYDCB\n         MVC   PFCBPDCB(PFCBDSZ2),PDCB\n         OFFSET R3,PT1\n         ST    R3,PFCBPTST         SAVE PAGE TABLE POINTER\n         LA    R3,&PAGE0\n         ST    R3,PFCBNP           SAVE IN PFCB\n         XC    PFCBCP(4),PFCBCP    0 PAGES CURRENTLY IN USE\nDODEVTYP DEVTYPE PFCBDCB+(DCBDDNAM-IHADCB),CPWA,DEVTAB\n         LTR   R15,R15             FILE SUPPLIED?\n         BZ    TESTDASD\n*\n* THE FOLLOWING CODE WAS ADDED BY BOB WENZEL OF ITEL\n* IT WILL TRY TO ALLOC DATASET WYLPAGE0 TO FILE PAGE0\n*\n         CALL  INITITEL\n         B     *+4(R15)\n         B     GOITEL1                 FOUND DSN WYLPAGE0\n         B     NOPAGE0   SOMEONE ELSE HAS USERID.WYLPAGE0\n         B     GOITEL2          DID NOT FIND DSN WYLPAGE0\nGOITEL1  MVC   DAIRPAGE(4),=CL4'DONE'   SHO AS ALLOCATED\n         B     DODEVTYP            DO DEVTYP AGAIN\nGOITEL2  EQU   *\n*\n* END OF CODE ADDED BY BOB WENZEL OF ITEL\n*\n         CLC   DAIRPAGE(4),=C'DONE'  DYNAMIC PERFORMED\n         BE    NOPAGE0      YES BYPASS ALLOC A 2ND TIME\n*             ALLOCATE  CODE FOR WYLRDR OR WYLPRINT\n         L     R15,CVIOWA          ADDRESS OF DAIR ROUTINE\n         LA    R1,WAUPT-WDIOWA(R15)  ADDR OF DAPL\n         LA    R14,DAIRPAGE           PARAMETER LIST\n         ST    R14,WADAIR-WDIOWA(R15)\n         L     R15,CVDAIR          ADDRESS OF DAIR ROUTINE\n         BALR  R14,R15             CALL DAIR\n         LTR   15,15               INTRDR AVAILABLE??\n         BNZ   NOPAGE0                   NO PAGE\n         MVC   DAIRPAGE(4),=CL4'DONE'   SHO AS ALLOCATED\n         B     DODEVTYP            DO DEVTYP AGAIN\nTESTDASD CLI   CPWA+2,X'20'        DIRECT ACCESS?\n         BNE   NODASD              NOPE\n         LA    R6,CPWA             SET BASE\n         USING DVTAREA,R6              FOR DEVTABLE\n         LA    R0,CPSIZE           SET R0 TO BLKSIZE ALSO\n         LR    R3,R0               SET R3 ALSO\n         MH    R3,DVTTOL           MULT BY TOLERANCE\n         SRA   R3,9                DIVIDE BY 512\n         SR    R1,R1               SET FOR IC\n         IC    R1,DVTKEYO          GET KEY OVERHEAD\n         SR    R0,R1               ADJUST BLKSIZES SINCE NO KEYS\n         SR    R3,R1\n         TM    DVTFLAG,DVTFOHD     IS IT HALF WORD OVERHEAD\n         BO    CALCTRK1            BR YES\n         IC    R1,DVTBLKO          GET NORMAL BLOCK OVERHEAD\n         AR    R3,R1               ADJUST NORMAL VALUE\n         IC    R1,DVTLBLKO         GET LAST BLOCK OVERHEAD\n         AR    R0,R1               ADJUST LAST BLOCK VALUE\n         B     CALCTRK2            NOW GO ON\n         SPACE\nCALCTRK1 LH    R1,DVTBLKO          GET BLOCK OVERHEAD\n         AR    R0,R1               ADJUST BOTH FOR\n         AR    R3,R1                   BLOCK OVERHEAD\nCALCTRK2 LH    R1,DVTTRKSZ         GET TRACK SIZE\n         SR    R1,R0               ADJUST FOR LAST BLOCK\n         AR    R1,R3               ADD TO INCR COUNT BY 1\n         SR    R0,R0               SET FOR DIVIDE\n         DR    R0,R3               CALCULATE VALUE IN R1\n         ST    R1,PFCBRPT          SAVE NUMBER OF RECORDS/TRK\n         DROP  R6\n         SPACE\n* OPEN THE FILE\n         LA    R3,PFCBDCB          GET DCB ADDR\n         LA    R4,PFCBPDCB         GET SECOND DCB\n         L     R1,CVPSYNAD         GET SYNAD ADDRESS\n         ST    R1,56(,R4)          SAVE SYNAD ADDRESS\n         L     R1,JCBWAPTR         POINT TO A WORK AREA FOR OPEN\n         OI    4(R1),X'80'     SET LAST DCB BIT\n         OPEN  ((3),(OUTPUT),(4),(OUTPUT)),MF=(E,(1))\n         TM    PFCBDCB+(DCBOFLGS-IHADCB),X'10'  OPEN OK?\n         BZ    BADOPEN\n         TM    PFCBPDCB+(DCBOFLGS-IHADCB),X'10'  OPEN OK?\n         BZ    BADOPEN\n         L     R4,PFCBDCB+(DCBDEBAD-IHADCB)  DEB ADDR\n         USING DEBBASIC,R4\n         SR    R5,R5               CLEAR WORK REG\n         IC    R5,DEBNMEXT         NUMBER OF EXTENTS\n         LA    R4,DEBDDEP          DEVICE DEPENDENT PORTION\n         USING DEBDDEP,R4\n         SR    R1,R1\nCOUNTRKS AH    R1,DEBNMTRK         NUMBER OF TRKS IN THIS EXTENT\n         LA    R4,DEBDSZDA(,R4)    SKIP EXTENT AREA\n         BCT   R5,COUNTRKS         ADD IN REMNDR\n         M     R0,PFCBRPT          TIMES RECORDS/TRK\n         CL    R1,PFCBNP           COMPARE AGAINST MAX DEFINED\n         BNH   *+8                 BR IF OK\n         L     R1,PFCBNP\n         ST    R1,PFCBNP           SAVE MAX\n         LR    R4,R1\n         AL    R1,PFCBPTST         END OF PAGE TABLE\n         BCTR  R1,R0               POINT TO LAST BYTE IN TABLE\n         ST    R1,PFCBPTND\n         L     R3,PFCBNP           LENGTH\n         L     R2,PFCBPTST         BEGINING OF TABLE\n         LA    R5,254              FILL CHAR\n         SLL   R5,24               MOVE TO HIGH ORDER BYTE\n         LR    R4,R2               SAME AREA\n         MVCL  R2,R4               OVERLAY WITH FF\nSETCP    DS    0H\n         L     R3,CVFPFCB          POINT TO PFCB\n         USING PFCB,R3\n         L     R2,CVFPAGE          POINT TO A PCB\n         USING PCB,R2\n         LA    R13,CPWA            SAVE AREA\n         SR    R1,R1               TO GET PAGE 0\n         ST    R3,PCBPFCB\n         MVI   PCBRWCCW,PIOREAD    TO READ IT\n         CVCALL PIO                GET 1ST PAGE\n         TM    JCBBFL,JCBBFPER     IO ERROR?\n         BO    NORMAL              YEP, NO REVCOVERY\n         LA    R4,PCBBUF           POINT TO READ MATERIAL\n         CLC   0(8,R4),=CL8'SUSPEND' IS IT A SUSPENDED SESSION\n         BE    CHKUSER             CHK IF SAME USER\n         CLC   0(8,R4),=CL8'RECOVER' IS IT CRASHED SESSION?\n         BNE   NORMAL\n         MVI   CPCMNM,C'Z'         REMEMBER IT IS RECOVERED.\nCHKUSER  ST    R6,CVSPARES        SAVE PAST COMPARE\n         SR    R6,R6\n         IC    R6,CVUSRFLD        PICK UP ID LENGTH\n         CLC   CPUSER(0),274(R4)  IS THIS THE ONE??             JJG001\n         EX    R6,*-6             EXEC ABOVE COMPARE\n         L     R6,CVSPARES\n         BNE   NORMAL              NOPE\n         MVI   0(R4),X'00'         MAKE IT NO SUSPEND\n         MVI   PCBRWCCW,PIOWRITE   TO WRITE IT BACK\n         CVCALL PIO                GO WRITE IT BACK\n         TM    JCBBFL,JCBBFPER     IO ERROR?\n         BO    NORMAL\n         MVC   PFCBCP(4),8(R4)     CURRENT PAGES\n         MVC   CPRSCNVL(4),12(R4)  RESCAN ESC & SKIP\n         MVC   CPEXLNET(4),16(R4)\n         MVC   CVEXTRAP(12),20(R4)\n         LA    R4,32(,R4)\n         L     R5,RTBWAPTR\n         MVC   RTBSTART(RTBSIZE-RTBNTEXT),0(R4)\n         ST    R5,RTBWAPTR\n         LA    R4,RTBSIZE-RTBNTEXT(,R4)\n         MVC   CPGLDL(CPRCVSZ1),0(R4)\n         LA    R4,CPRCVSZ1(,R4)\n         MVC   CPDRPT(CPRCVSZ2),0(R4)\n         LA    R4,CPRCVSZ2(,R4)\n         LR    R0,R2                         SAVE ACROSS MVCL\n         LR    R1,R3                         SAVE ACROSS MVCL\n         LA    R2,CPDREC                     SET FOR MVCL\n         LA    R3,CPRCVSZ3                   LENGTH\n         LR    R14,R4                        FROM\n         LR    R15,R3                        SAME LENGTH\n         MVCL  R2,R14                        MOVE IT\n*        MVC   CPDREC(CPRCVSZ3),0(R4)\n         LA    R4,CPRCVSZ3(,R4)\n         MVC   CPCHECK(4),=X'6913723F'\n         LA    R2,ROUTBLE                    SET FOR MVCL\n         LA    R3,ROUTBLEN                   LENGTH\n         LR    R14,R4                        FROM\n         LR    R15,R3                        SAME LENGTH\n         MVCL  R2,R14                        MOVE IT\n         LR    R2,R0                         RESTORE\n         LR    R3,R1                         RESTORE\n*        MVC   ROUTBLE(256),0(R4)\n*        MVC   ROUTBLE+256(ROUTBLEN-256),256(R4)\n         LA    R4,ROUTBLEN(,R4)\n         MVC   0(256,R5),0(R4)\n         LA    R4,256(,R4)\n         L     R3,CVFPFCB            POINT TO PFCB\n         L     R2,CVFPAGE            FIRST PCB\n         LA    R2,PCBSIZE(,R2)        2ND PCB\n         MVI   PCBRWCCW,PIOREAD       GO READ 2ND CP IN\n         LA    R1,1\n         ST    R3,PCBPFCB\n         CVCALL PIO\n         TM    JCBBFL,JCBBFPER        IO ERROR\n         BO    SIGHSIGH               TOO BAD\n         LR    R0,R2                  SAVE\n         LR    R1,R3                      ACROSS MVCL\n         LA    R14,PCBBUF             MOVE FROM\n         L     R2,PFCBPTST            BEGINNING OF PAGE TABLE\n         LA    R3,&PAGE0              MAX NUMBER OF PAGES\n         LR    R15,R3                 SAME LENGTH\n         MVCL  R2,R14                 MOVE IT\n         LR    R2,R0                         RESTORE\n         LR    R3,R1                         RESTORE\n         L     R5,PFCBPTST\n         CLI   CPCMNM,C'Z'            RECOVERY?\n         BNE   REWRITE\nPTLP     CLI   0(R5),INCORE\n         BNE   *+8\n         MVI   0(R5),0\n         CLI   0(R5),X'FE'\n         LA    R5,1(,R5)\n         BNE   PTLP\n         XC    RTBWC(6),RTBWC\n         SPACE\nREWRITE  LA    R5,CPAREA+CPSIZE       POINT TO AREA\n         ST    R5,PCBRWCCW\n         MVI   PCBRWCCW,PIOREAD       GO READ 2ND CP IN\n         LA    R1,2\n         CVCALL PIO\n         TM    JCBBFL,JCBBFPER        IO ERROR\n         BO    SIGHSIGH               TOO BAD\n         OFFSET R5,VCPAGE\n         ST    R5,CVCPADDR\n         ST    R5,PCBRWCCW\n         MVI   PCBRWCCW,PIOREAD       GO READ VCP IN\n         LA    R1,3\n         CVCALL PIO\n         TM    JCBBFL,JCBBFPER        IO ERROR?\n         BO    SIGHSIGH               TOO BAD\n         LA    R5,PCBBUF\n         ST    R5,PCBRWCCW\n         SPACE\n         L     R5,PFCBPTST            START OF PT\n         L     R4,PFCBRPT             # BLOCKS PER TRACK\n         SR    R1,R1                  0 TRACKS\nPTLOOP   AR    R5,R4                  START FROM TRK 1\n         LA    R1,1(,R1)              1 MORE TRACK\n         CLI   0(R5),X'FE'            A VIRGIN PAGE\n         BNE   PTLOOP\n         STH   R1,CPWK1\n         MVC   CPWK1+2,=X'0100'       1ST RECORD ON NEW TRK\n         LA    R0,CPWK1\n         LA    R1,PFCBPDCB            DCB ADDRESS\n         POINT (1),(0)\n         OI    CPGFLG,CPFDIRCH\n         CLI   CPCMNM,C'Z'         WAS IT RECOVERED?\n         BE    RECOVERD\n         SYSQS 1,0,'SUSPENDED SESSION RESTORED'\nTPUTRET  TPUT  (1),(0),EDIT,WAIT\n         B     LOADEXIT\n         SPACE\nRECOVERD TM    CPGFLG2,CPFEXEC\n         BZ    RECVNOEX\n         OI    JCBAFL,JCBAFIA      SET IDLE ATTENTION\n         XC    CVEXTRAP,CVEXTRAP   GET RID OF EXEC TRAP\nRECVNOEX SYSQS 1,0,'PREVIOUS SESSION RECOVERED SUCCESSFULLY'\n         B     TPUTRET\n         EJECT\nNORMAL   LA    R3,3                GET 3 PAGES\n         NI    JCBBFL,255-JCBBFPER TURN OF I/O ERROR FLAG\nPGETLP   SR    R1,R1               CLEAR FOR NEW PAGE\n         PGET  R1\n         TM    JCBBFL,JCBBFPER\n         BO    NOPAGES\n         LR    R5,R1               DON'T USE R1 FOR PFREE CALL\n         PFREE R5                  FREE THE PAGE WE JUST GOT\n         BCT   R3,PGETLP\n         SPACE\n* NOTE THAT THE PAGE IS JUST FREED.. NOT JUNKED\n* THAT MEANS PAGE WILL NOT BE IN CORE BUT REMAIN ALLOCATED.\n* THE PGET ROUTINE WILL WRITE OUT A TRACKFUL OF DUMMY PAGES\n* BECAUSE THE PAGE THAT WAS JUST GOTTEN WAS A BRAND NEW PAGE .\n         SPACE 3\n         MVC   CPUSERSV(8),CPUSER  FOR SAVE\n*        OI    CPGFLG,CPFVOLM      SET DEFAULT VOL FLAG    ITEL\n         OI    CPGFLG,CPFVOLM+CPFCMOFF TER & VOL FLAG      ITEL\n         OI    RTBMFL,RTBWRAP      SET WRAP AS DEFAULT\n         OI    RTBUFL,RTBUNCOL         NOCOLLECT FLAG      ITEL\n         MVC   CPVOLSV,=C'CATLG '  SET DEFAULT VOL = CATLG\n         MVC   CPCHECK(4),=X'6913723F'\n         MVC   CPGLDL(4),=F'1000'       DELTA=1.000\n         MVC   CPLNGTH(2),=H'72'        LEN=72\n         MVC   CPDREC(4),=D'0'          ZERO 1ST LINE NO.\n         MVI   CPLSTCOL,FNEGBT          SET NO COLLECT YET\n         MVI   CPCURRL,FNEGBT      SET CURRENT LINE POINTER INV\n         MVI   CPEXLINE,FNEGBT     SET EXEC LINE POINTER INV\n         MVI   CPMEMBSV,X'40'      CLEAR MEMBER\n         MVC   CPMEMBSV+1(L'CPMEMBSV-1),CPMEMBSV\n         OFFSET VCPR,VCPAGE\n         ST    VCPR,CVCPADDR\n         USING DVCP,VCPR\n         XC    VCPWVAR,VCPWVAR    ZERO LINE # VARIABLES\n         XC    VCPNVAR,VCPNVAR    ZERO INTEGER VARIABLES\n         MVC   VCPSVAR(L'SVARINIT),SVARINIT  INIT STRING VARS\n         LA    R2,24      LOOP\n         LA    R1,PVARINIT\n         LA    R6,VCPPVAR\nVCPVLOOP MVC   0(2,R6),0(R1)     MOVE PFK'S\n         MVC   2(23,R6),=CL23' ' SET DUMMY PFK'S\n         LA    R6,25(,R6)        NEXT AREA\n         LA    R1,2(,R1)         NEXT PFK DEF\n         BCT   R2,VCPVLOOP       LOOP THRU IT\n         DROP  VCPR\n         LA    0,5\n         STH   0,CPRSCNVL         INITIALIZE RESCAN LIMIT\n         OI    CPGFLG2,CPESNULL   SET ESCAPE CHARACTER NULL\n         OI    CPGFLG2,CPSKNULL   SET SKIP CHARACTER NULL\n         LA    R13,CPWA            SAVE AREA\n         MVC   CPCMSAV(L'LOGCMND),LOGCMND\n         LA    R0,L'LOGCMND-1\n         ST    R0,CPCTSAV\n         EJECT\n* LOAD IN THE PAGED ROUTINES\n         SPACE\n         LA    R10,ROUTBLE\n         USING ROUTBLE,R10\n         LA    R6,PAGTBLE-4        SET FOR START OF LOOP\n         SR    R5,R5               CLEAR REG FOR PFREE\n         USING PCB,R5\n         SPACE\n* LOOP THROUGH PAGTBLE AND LOAD EACH OVERLAY SEGMENT\n* AFTER LOADING THE SEGMENT, GET A PAGE FROM THE ACTIVE\n* FILE AND WRITE OUT THE OVERLAY SEGMENT.  THEN FILL IN\n* ROUTBLE FOR ANY ROUTINES FOUND.\n         SPACE\nLOADLOOP LA    R6,4(,R6)           STEP UP TO NEXT ENTRY\n         C     R6,=A(PAGTBLED)     END OF PAGETABLE?\n         BNL   LOADDONE            YES..GO FINISH\n         L     R1,0(,R6)           LOAD VCON\n         LTR   R1,R1               DOES IT EXIST?\n         BZ    LOADLOOP            NO..GO ON TO NEXT PAGE\n         LA    R0,1                SET R0 FOR SEGWT\n         SVC   37                  GO GET EM\n         PGET  R5                  GET A PAGE\n         BZ    NOPAGES\n         STH   R0,PCBPN            SAVE PAGE NUMBER IN PCB\n         LR    R4,R0               PRESERVE PAGE NUMBER\n         L     R11,=A(P001)\n         LH    R1,0(,R11)          GET ADDR OF INIT CODE\n         BAL   R14,0(R11,R1)       GO DO INIT CODE\n         STM   R2,R5,CVSPARES      TEMP SAVE\n         LR    R4,R11              SET R2 TO MOVE CODE\n         LR    R2,R5               SET R1 TO BUFFER ADDRESS\n         LA    R3,CPSIZE\n         LA    R5,CPSIZE           MOVE-A-CHUNK\n         MVCL  R2,R4\n         LM    R2,R5,CVSPARES      RESTORE REGS\n         PMARK R5                  MARK THE BUFFER\n         LA    R11,2(,R11)         SET R11 TO FIRST TABLE ENTRY\nLOADLP2  LH    R1,0(,R11)           GET NEXT ENTRY\n         LTR   R1,R1               IS THIS END OR DEFAULT\n         BM    LOADLP5             BR IF EITHER\n         C     R1,=A(ROUTBLEN)     CHECK THAT ITS IN RANGE\n         BL    LOADLP3             BR IF OK\n         WTO   '**WYLTSO** INCOMPATIBLE PAGED CODE..REASSEMBLE IT'\n         B     RETURN16\n*\nLOADLP3  STH   R4,ROUTBLE(R1)      PUT PAGE NO. IN ROUTBLE\n         LH    R0,2(,R11)           GET DISPLACEMENT TO START\n         STH   R0,ROUTBLE+2(R1)    PUT IT IN ROUTBLE\nLOADLP4  LA    R11,4(,R11)           STEP TO NEXT ENTRY\n         B     LOADLP2             GO CHECK THIS ENTRY\n*\nLOADLP5  CH    R1,=H'-1'   IS THIS DEFAULT ROUTINE FOR MISSING\n         BNE   LOADLOOP           NO, GO DO NEXT OVERLAY\n         STH   R4,LOADEFLT         YES, SAVE PAGE NUMBER\n         MVC   LOADEFLT+2(2),2(R11)   AND ALSO DISPLACEMENT\n         B     LOADLP4             GO DO NEXT ON THIS PAGE\n         DROP  R10\nLOADDONE PFREE R5                  FREE THE LAST GOTTEN PCB\n         CLC   LOADEFLT,=A(0)      IS THERE A DEFAULT MISSING ROUTINE\n         BE    LOADEXIT            NO, RETURN\n         L     R2,=A(ROUTBLEN)     LOAD LENGTH OF ROUTBLE\n         AR    R2,R10              NOW POINT TO END OF TABLE\nLOADEFLP CR    R10,R2              ARE WE DONE\n         BNL   LOADEXIT            BR YES\n         CLC   0(4,R10),=A(0)      WAS THIS ENTRY INITIALIZED\n         BNE   *+10                YES, DON'T PUT IN DEFAULT\n         MVC   0(4,R10),LOADEFLT   NO, SET ENTRY TO DEFAULT\n         LA    R10,4(,R10)         STEP TO NEXT ENTRY\n         B     LOADEFLP            GO DO IT\n         SPACE\nLOADEXIT DELETE EP=IEWSZOVR        DELETE REMDR\n         SPACE\n* INITIALIZE RECOVERY IOB AND CCW'S TO WRITE OUT SNAPSHOT\n         SPACE\n         L     R4,CVPIOB           GET RECOVERY IOB ADDRESS\n         USING PIOB,R4\n         MVI   PIOBFLG1,X'42'      COMMAND CHAINING\n         LA    R1,PECB             ECB ADDRESS\n         ST    R1,PIOBECB-1\n         LA    R1,PCCWS            START OF CCWS\n         ST    R1,PIOBCCW-1\n         L     R1,CVFPFCB          POINT TO THE PFCB\n         LA    R1,PFCBDCB-PFCBSTRT(,R1) DCB ADDRESS\n         ST    R1,PIOBDCB-1\n         L     R1,DCBDEBAD-IHADCB(,R1) POINT TO DEB\n         LR    R3,R1               REMEMBER DEB ADDRESS\n         LR    R6,R12              REMEMBER CP ADDRESS\n         L     R15,16              CVT ADDRESS\n         LA    R2,PSEEK1           RESULT ADDRESS OF CONV\n         L     R15,28(,R15)        TTR CONVERSION ROUTINE\n         L     R0,=X'00000100'     1ST RECORD, 1ST TRACK\n         LR    R5,R15              REMEMBER TTR CONV ROUTINE\n         BALR  R14,R15\n         LA    R2,PSEEK2           RESULT ADDRESS OF CONV\n         LR    R15,R5              TTR CONV ROUTINE\n         LR    R1,R3               DEB ADDRESS\n         L     R0,=X'00000200'     2ND RECORD\n         BALR  R14,R15\n         LA    R2,PSEEK3           RESULT ADDRESS OF CONV\n         LR    R15,R5              CONV ROUTINE ADDRESS\n         LR    R1,R3               DEB ADDRESS\n         L     R0,=X'00000300'     3RD RECORD\n         BALR  R14,R15\n        LA    R2,PSEEK4           RESULT ADDRESS OF CONV\n         LR    R15,R5              CONV ROUTINE ADDRESS\n         LR    R1,R3               DEB ADDRESS\n        L     R0,=X'00000400'     4TH RECORD\n         BALR  R14,R15\n         LR    R12,R6              RESTORE CP ADDRESS\n         LA    R13,CPWA            RESTORE SAVE AREA ADDRESS\n         LA    R2,PSEEK1+3\n         ST    R2,PCCWSID1\n         MVI   PCCWSID1,X'31'      SEARCH ID EQUAL\n         MVI   PCCWSID1+4,X'40'    COMMAND CHAINING\n         MVI   PCCWSID1+7,X'05'    LENGTH OF 5\n         LA    R2,PCCWSID1\n         ST    R2,PCCWTIC1\n         MVI   PCCWTIC1,X'08'\n         L     R2,JCBWAPTR\n         ST    R2,PCCWWRT1\n         MVI   PCCWWRT1,X'05'\n         LA    R5,PCBPSIZE\n         ST    R5,PCCWWRT1+4\n         MVI   PCCWWRT1+4,X'40'\n         LA    R2,PSEEK2+3\n         ST    R2,PCCWSID2\n         MVI   PCCWSID2,X'31'      SEARCH ID EQUAL\n         MVI   PCCWSID2+4,X'40'    COMMAND CHAINING\n         MVI   PCCWSID2+7,X'05'    LENGTH OF 5\n         LA    R2,PCCWSID2\n         ST    R2,PCCWTIC2\n         MVI   PCCWTIC2,X'08'\n         L     R2,JCBWAPTR\n         AH    R2,=AL2(CPSIZE)\n         ST    R2,PCCWWRT2\n         MVI   PCCWWRT2,X'05'\n         ST    R5,PCCWWRT2+4\n         MVI   PCCWWRT2+4,X'40'\n         LA    R2,PSEEK3+3\n         ST    R2,PCCWSID3\n         MVI   PCCWSID3,X'31'      SEARCH ID EQUAL\n         MVI   PCCWSID3+4,X'40'    COMMAND CHAINING\n         MVI   PCCWSID3+7,X'05'    LENGTH OF 5\n         LA    R2,PCCWSID3\n         ST    R2,PCCWTIC3\n         MVI   PCCWTIC3,X'08'\n         LA    R2,CPAREA+CPSIZE\n         ST    R2,PCCWWRT3\n         MVI   PCCWWRT3,X'05'\n         ST    R5,PCCWWRT3+4\n         LA    R2,PSEEK4+4\n         ST    R2,PCCWSID4\n          MVI   PCCWSID4,X'31'      SEARCH ID EQUAL\n         MVI   PCCWSID4+4,X'40'    COMMAND CHAINING\n         MVI   PCCWSID4+7,X'05'    LENGTH OF 5\n         LA    R2,PCCWSID4\n         ST    R2,PCCWTIC4\n         MVI   PCCWTIC4,X'08'\n         L     R2,CVCPADDR\n         ST    R2,PCCWWRT4\n         MVI   PCCWWRT4,X'05'\n         ST    R5,PCCWWRT4+4\n         MVC   CVPROMPT,CVPRMLIM\n         SPACE\n         L     R14,CVIOWA          WORK AREA ADDRESS\n         USING WDIOWA,R14\n         LA    R1,WASTAX           STAX PARAMETER AREA\n         XC    WASTAX(20),WASTAX   CLEAR IT\n         DROP  R14\n         L     R14,CVATNRTN        ATTENTION EXIT ADDRESS\n         STAX  (14),REPLACE=NO,DEFER=NO,USADDR=((12)),MF=(E,(1))\n         OI    JCBAFL,JCBSTAX\n         BR    R8                  RETURN TO WYLBUR\n         EJECT\n* ERROR MESSAGES:\n         SPACE\nNODASD   SYSQS 1,0,'PAGEFILE NOT ON DIRECT ACCESS DEVICE'\n         B     RETURN16                  EXIT\nSIGHSIGH SYSQS 1,0,'UNABLE TO RECOVER FROM SUSPENDED SESSION'\n         B     RETURN16\nNOPAGE0  SYSQS 1,0,'PAGEFILE NOT SUPPLIED'\n         B     RETURN16\nBADOPEN  SYSQS 1,0,'PAGEFILE CANNOT BE OPENED'\n         B     RETURN16\nNOPAGES  SYSQS 1,0,'INSUFFICIENT PAGES TO INITIALIZE'\n         SPACE\nRETURN16 TPUT  (1),(0),,WAIT,,BREAKIN\n         L     R13,CVRETURN\n         LM    R14,R12,12(R13)     RESTORE REGS\n         LA    R15,16\n         BR    R14                 RETURN TO CALLER\n         EJECT\n* VCON ENTRIES FOR EACH OVERLAY PAGE\n         SPACE\nPAGTBLE  DS    0F\n         DC    V(P001)\n         DC    V(P002)\n         DC    V(P003)\n         DC    V(P004)\n         DC    V(P005)\n         DC    V(P006)\n         DC    V(P007)\n         DC    V(P008)\n         DC    V(P009)\n         DC    V(P010)\n         DC    V(P011)\n         DC    V(P012)\n         DC    V(P013)\n         DC    V(P014)\n         DC    V(P015)\n         DC    V(P016)\n         DC    V(P017)\n         DC    V(P018)\n         DC    V(P019)\n         DC    V(P020)\n         DC    V(P021)\n         DC    V(P022)\n         DC    V(P023)\n         DC    V(P024)\n         DC    V(P025)\n         DC    V(P026)\n         DC    V(P027)\n         DC    V(P028)\n         DC    V(P029)\n         DC    V(P030)\n         DC    V(P031)\n         DC    V(P032)\n         DC    V(P033)\n         DC    V(P034)\n         DC    V(P035)\n         DC    V(P036)\n         DC    V(P037)\n         DC    V(P038)\n         DC    V(P039)\n         DC    V(P040)\n         DC    V(P041)\nPAGTBLED EQU   *                   END OF PAGTBLE\n         SPACE\nLOADEFLT DC    F'0'                DEFAULT ROUTINE FOR MISSING\n         SPACE\nLOGCMND  DC    C';X FRO #LOGON NOL '\n         SPACE 3\n         LTORG\n         SPACE\n         DROP  R5\n         DROP  R7\n         EJECT\n         DS    0H\nSVARINIT DS    0CL34\n         DC    H'32'\n         DC    C'0',X'00'\n         DC    C'1',X'00'\n         DC    C'2',X'00'\n         DC    C'3',X'00'\n         DC    C'4',X'00'\n         DC    C'5',X'00'\n         DC    C'6',X'00'\n         DC    C'7',X'00'\n         DC    C'8',X'00'\n         DC    C'9',X'00'\n         DC    C'A',X'00'\n         DC    C'B',X'00'\n         DC    C'C',X'00'\n         DC    C'D',X'00'\n         DC    C'E',X'00'\n         DC    C'F',X'00'\n         SPACE\nPVARINIT DS    0CL48\n         DC   X'F1',X'00'                   PFK01\n         DC   X'F2',X'00'                   PFK02\n         DC   X'F3',X'00'                   PFK04\n         DC   X'F4',X'00'                   PFK03\n         DC   X'F5',X'00'                   PFK05\n         DC   X'F6',X'00'                   PFK06\n         DC   X'F7',X'00'                   PFK07\n         DC   X'F8',X'00'                   PFK08\n         DC   X'F9',X'00'                   PFK09\n         DC   X'7A',X'00'                   PFK10\n         DC   X'7B',X'00'                   PFK11\n         DC   X'7C',X'00'                   PFK12\n         DC   X'C1',X'00'                   PFK13\n         DC   X'C2',X'00'                   PFK14\n         DC   X'C3',X'00'                   PFK15\n         DC   X'C4',X'00'                   PFK16\n         DC   X'C5',X'00'                   PFK00\n         DC   X'C6',X'00'                   PFK18\n         DC   X'C7',X'00'                   PFK00\n         DC   X'C8',X'00'                   PFK20\n         DC   X'C9',X'00'                   PFK21\n         DC   X'4A',X'00'                   PFK22\n         DC   X'4B',X'00'                   PFK23\n         DC   X'4C',X'00'                    PFK24\n          PRINT NOGEN\nDUMMYDCB DCB   DDNAME=PAGE0,MACRF=(E),DEVD=DA,DSORG=DA\n         SPACE\nPDCB     DCB   DDNAME=PAGE0,DSORG=PS,MACRF=WP,BLKSIZE=PCBPSIZE,        *\n               RECFM=F,OPTCD=C,SYNAD=0\n         PRINT GEN\n         TITLE  'DYNAMIC ALLOCATION PARMS FOR PAGE0'\nDAIRPAGE DS    0F\n         DC    X'0008'\n         DC    X'0000'\n         DC    X'00000000'\n         DC    AL4(PAGEDSN)\n         DC    CL8'PAGE0'\n         DC    CL8'VIO'\n         DC    CL8' '\n         DC    AL4(CPSIZE)              SIZE OF PAGE\n         DC    AL4(&PAGE0)             NUMBER OF PAGES\n         DC    F'0'\n         DC    F'0'\n         DC    CL8' '\n         DC    CL8' '\n         DC    XL3'040000'\n         DC    X'48'              BLOCK ALLOCATION/PERM ATTR\n         DC    F'0'\n         DC    CL8' '\nPAGEDSN  DC    XL2'002C',CL44' '\n         TITLE 'START OF PAGED CODE -- PAGE 1'\nP001     PAGECDE MISSING\n         WIDENT 001\n         USING CPAREA,R12\n         TITLE 'DEFAULT MISSING ROUTINE -- PAGE 1'\nPMISSING GENTER\n         TSEG  'CODE FOR ROUTINE NOT IN PAGEFILE'\n         B     CVQTYPE\n         TITLE 'END OF PAGE CODE -- PAGE 1'\n         PINIT                     DEFINE START OF INIT ROUTINE\n         PEND                      DEFINE END ON INIT CODE\n         TITLE 'CONSTANTS AND CONTROL BLOCKS'\n         COPY  WYLCONST\n         EJECT\n         COPY  VCPTSO\n         EJECT\nPCB      DSECT\n         COPY  PCBTSO\n         EJECT\nPFCB     DSECT\n         COPY  PFCBTSO\n         EJECT\nPIOB     DSECT\n         COPY  PIOB\n         EJECT\n         COMMON\n         EJECT\n         LTORG\n         ORG   ,\nFRSTPAGE DS    0D\n         PAGES &NUMPAGE\nLASTPAGE DS    0D\n         EJECT\nFRSTPFCB DS    0D\n         PAGEFILE &PAGE0           DEFINE ONE DRUM FILE\nLASTPFCB DS    0F\n         EJECT\n         PT\nVCPAGE   DS    0F\n         DS    XL(CPSIZE)         VARIABLE COMMAND PAGE\n         DS    0D\nWORKAREA DS    XL(CPSIZE*2)\nWAFORRTB DS    CL256\n         SPACE\nPCBTABLE DS    &NUMPAGE.A\n         SPACE\nCVDDLIST DS    &MAXDDS.CL8\n         SPACE\nCVCPEND  DS    0D                  ROUND OFF TO DBL-WRD\n         SPACE\nCVCPSIZE EQU   *-CPSTART\n         EJECT\nDEB      DSECT\n         COPY  DEB\n         SPACE 3\n         DCBD\n         EJECT\nWDIOWA   WDIOWA DSECT\n         SPACE\nINITITEL CSECT\n         SAVE  (14,12)\n         LR    R12,R15                    SET UP PROGRAM BASE\n         USING INITITEL,R12\nBEGIN    LR    R10,R9        SAVE R1\n         GETMAIN R,LV=LDYNAMIC          GET CORE\n         LR    R11,R1\n         USING WORKAREB,R11             SET UP ADDRESSABILITY\n         LA    R9,SAVEAREB              CHAIN\n         ST    R13,SAVEAREB+4             SAVE\n         ST    R9,8(R13)                    AREAS\n         LR    R13,R9\n         LR    R1,R10\n*\n         MVC   DAPLUPT,4(R1)\n         MVC   DAPLECT,12(R1)\n         MVC   DAPLPSCB,8(R1)\n         LA    R1,DAPL       ADDRESS OF DAIR PARAMETER LIST\nLINK     LINK  EP=IKJEFD00   LINK TO DAIR\nTEST     LTR   R15,R15      TEST FOR ERROR\n         BNZ   DAIRERR      JUMP TO TEST DAIR RETURN CODE\n*\nRETURN0  LR    R1,R13                   DYNAMIC AREA ADDRESS IN R1\n         LA    R0,LDYNAMIC              SIZE OF AREA\n         L     R13,4(R13)               PREVIOUS SAVE AREA\n         LA    R1,0(R1)                 CLEAR TOP BYTE\n         SVC   10                       FREEMAIN\n         LM    R14,R12,12(R13)\n         SR    R15,R15\n         BR    R14\n*\nRETURN4  LR    R1,R13                   DYNAMIC AREA ADDRESS IN R1\n         LA    R0,LDYNAMIC              SIZE OF AREA\n         L     R13,4(R13)               PREVIOUS SAVE AREA\n         LA    R1,0(R1)                 CLEAR TOP BYTE\n         SVC   10                       FREEMAIN\n         LM    R14,R12,12(R13)\n         LA    R15,4\n         BR    R14\n*\nRETURN8  LR    R1,R13                   DYNAMIC AREA ADDRESS IN R1\n         LA    R0,LDYNAMIC              SIZE OF AREA\n         L     R13,4(R13)               PREVIOUS SAVE AREA\n         LA    R1,0(R1)                 CLEAR TOP BYTE\n         SVC   10                       FREEMAIN\n         LM    R14,R12,12(R13)\n         LA    R15,8\n         BR    R14\n*\n*              DAIR ERROR DETERMINATION SECTION\n*\nDAIRERR  EQU   *       DAIR ERROR RETURN\n         CH    R15,=H'12'\n         BNE   RETURN8\nINUSEDSN L     R2,16(R1)              DAPL\n         LH    R3,4(R2)               DAPBDARC\n         CH    R3,=X'0210'            DSN IN USE ERROR\n         BNE   DARCERR                NO, SHOW DARC ERROR CODE\n*\n         TPUT  DSNINUSE,50            DSN IN USE MESSAGE\n         B     RETURN4\nDSNINUSE DC    CL50'PREFIXED WYLPAGE0 IS IN USE BY ANOTHER USER OR JOB'\n*\nDARCERR  ABEND 111,DUMP\n*        L     R2,16(R1)\n*        LH    R3,4(R2)\n*\n         DS    0D\nALLOCATE DS    0CL84\nALOCCD   DC    X'0008'\n         DC    H'0'\n         DC    H'0'\n         DC    H'0'\nALOCDSN  DC    A(PAGE0LNG)\nALOCDDN  DC    CL8'PAGE0'\n         DC    CL8' '\nALOCSER  DC    CL8' '\n         DC    F'0'\n         DC    F'0'\n         DC    F'0'\n         DC    F'0'\nALOCMNM  DC    CL8' '\n         DC    CL8' '\nALOCDPS1 DC    X'01'    OLD\nALOCDPS2 DC    X'08'    KEEP\nALOCDPS3 DC    X'08'    KEEP\nALOCCTL  DC    X'20'    ADD USER ID\n         DC    F'0'\n         DC    2F'0'\n*\nPAGE0LNG DC    H'8',CL8'WYLPAGE0'\nECB      DC    F'0'\n         DS    0D\nDAPL     DS    0CL20\nDAPLUPT  DS    F\nDAPLECT  DS    F\nDAPLECB  DC    A(ECB)\nDAPLPSCB DS    F\nDAPLDAPB DC    A(ALLOCATE)\n         LTORG\n*\nWORKAREB DSECT\nSAVEAREB DS    18F\nLDYNAMIC EQU   *-WORKAREB\n         END\n./ ADD NAME=INIT8,SSI=00000228\nINIT     TITLE 'WYLTSO INITIALIZATION ROUTINE'\n*  WYLBUR MVS/TSO VERSION 1.1\n         SPACE\n         COPY  PMAC\n         SPACE\n         USING CPAREA,R12\n         SPACE 3\n         ENTRY INITWYL\nINITWYL  CSECT\n         DC    24XL256'00'         DUMMY MODULE\n         ORG   INITWYL\n         LR    R7,R15              GET ADDRESSABILITY\n         LR    R4,R1               ADDRESS OF REAL CV\n         LR    R8,R14              RETURN ADDRESS\n         SPACE\n*** WARNING *** R8 MUST NOT BE ALTERED *** WARNING ***\n         SPACE\n         USING INITWYL,R7\n         L     R0,=A(CVCPSIZE)     DETERMINE GETMAIN SIZE\n         A     R0,=F'1024'         FOR TRACE AREA\n         A     R0,=A(PIOBSIZE)     FOR RECOVERY IOB\n         GETMAIN R,LV=(0),PAGE       GO GET 'EM\n         SPACE\n* WE GOT IT IF WE SURVIVE TO GET HERE\n         LR    R12,R1              POINT TO THE AREA\n         LA    R13,CPWA\n         SPACE\n* CLEAR THE 'CP' PART OF THE AREA\n         SLR   R0,R0               CLEAR FOR MVCL\n         LR    R2,R1             AREA TO CLEAR\n         LA    R1,0              FILL CHAR INTO REG 1\n         LA    R3,CPSIZE          SIZE OF AREA TO CLEAR\n         MVCL  R2,R0             CLEAR THE AREA\n* COPY THE REAL CV INTO OUR AREA. R4 POINTS TO IT.\n         LA    R3,CVSIZE            SIZE TO MOVE\n         LR    R5,R3                ALSO IN REG 5\n         LA    R2,CVSTART           AREA TO MOVE TO\n         MVCL  R2,R4                MOVE IT\n         SPACE\n* CLEAR JCB FIELDS\n         XC    JCBSTART(JCBSIZE),JCBSTART\n         SPACE\n*\nCOPYWA   LOAD  EP=WYLWA\n         ST    R0,CVIOWA           SAVE ADDR OF WORK AREA\n         ST    R11,CVRETURN        SAVE OS RETURN ADDR\n         SPACE\n* INITIALIZE THE TRACE AREA\n         OFFSET R1,CVCPEND\n         ST    R1,CVTRSTRT         START OF TABLE\n         ST    R1,CVTRACE          CURRENT ENTRY\n         LA    R2,1024-16(,R1)\n         ST    R2,CVTREND          END OF TABLE POINTER\n         SPACE\n* NOW CLEAR THE AREA\n         LR    R2,R1               SET REG FOR MOVE AREA\n         LA    R3,1024             LENGTH TO MOVE\n         LA    R0,0                FOR CLEAR AREA\n         LA    R1,0                FILL LENGTH\n         SPACE\n* CLEAR RECOVERY IOB AND SAVE ITS ADDRESS IN CV\n         ST    R2,CVPIOB\n         XC    0(PIOBSIZE,R2),0(R2)\n         SPACE\n* INITIALIZE ALL THE CONTROL BLOCKS\nINIT2    LA    R1,&NUMPAGE         NUMBER OF PAGES IN SYS\n         OFFSET R2,CVPAGE1         POINT TO FIRST PAGE\n         USING PCB,R2\nPAGEINIT XC    PCBPT(PCBSIZE-PCBPSIZE),PCBPT\n         MVI   PCBFLG1,X'42'\n         LA    R3,PCBECB\n         ST    R3,PCBECBP-1        SAVE POINTER TO ECB\n         LA    R3,PCBCCWS          ADDR OF CHAN PROG\n         ST    R3,PCBCCWP-1        SAVE IN IOB\n         OFFSET R3,PFCB1+PFCBDCB-PFCB\n         ST    R3,PCBDCB-1         SAVE IN IOB\n         SPACE\n* NOW INITIALIZE THE CHANNEL PROG\n         LA    R3,PCBSEEK+3\n         ST    R3,PCBCCWS\n         MVI   PCBCCWS,X'31'       MOVE IN OP-CODE\n         MVI   PCBCCWS+4,X'40'     COMMAND CHAIN\n         MVI   PCBCCWS+7,X'05'     LENGTH OF 5\n         LA    R3,PCBCCWS\n         ST    R3,PCBCCWS+8        SAVE TIC ADDRESS\n         MVI   PCBCCWS+8,X'08'     TIC OP-CODE\n         LA    R3,PCBBUF           ADDRESS OF BUFFER\n         ST    R3,PCBRWCCW         SAVE INTO CCW\n         MVI   PCBRWCCW,X'06'      OP-CODE\n         MVC   PCBRWCCW+6(2),=AL2(PCBPSIZE)\n         SPACE\n* ALL DONE FOR THIS PAGE\n         LA    R2,PCBSIZE(,R2)     NEXT\n         BCT   R1,PAGEINIT         GET REMAINDER OF PAGES\n         DROP  R2\n         OFFSET R3,CVDDLIST\n         ST    R3,CVDDNAMS\n         OFFSET R3,PCBTABLE\n         ST    R3,CVPADDRS\n         LA    R0,&NUMPAGE\n         OFFSET R1,CVPAGE1         FIRST PAGE\nPCBLOOP  ST    R1,0(,R3)\n         LA    R3,4(,R3)\n         LA    R1,PCBSIZE(,R1)\n         BCT   R0,PCBLOOP\n         SPACE\n* GET TIOT POINTER\n         LA    R2,CPSTART          USE AREA AS BUFFER FOR EXTRACT\n         EXTRACT (R2),FIELDS=(TIOT,TSO,PSB),MF=(E,(R2))\n         L     R3,CPSTART+8        GET PSCB ADDR\n         L     R10,CVIOWA          WORK AREA\n         USING WDIOWA,R10\n         ST    R3,WAPSCB           SAVE PSCB ADDR IN WORK AREA\n         L     R4,CPSTART+4        TSO FIELD IN THE TCB\n         TM    0(R4),X'80'         ARE WE TSO BOUND?\n         BZ    NONTSO\n         OI    JCBAFL,JCBTSO       WE ARE UNDER TSO\n         TM    16(R3),X'80'        PRIV?\n         BZ    *+8\n         OI    JCBAFL,JCBSYSPR\n         LOAD  EP=IKJEFD00         NAME OF MODULE\n         ST    R0,CVDAIR\n         SPACE\n* INITIALIZE USER ID\n*\n*\n*\nNONTSO   EQU    *\n         L     R2,CPSTART        TIOT POINTER\n         MVC   CPUSER(8),0(R2)    MOVE IN USER ID\n         TM    JCBAFL,JCBSYSPR    PRIV\n         BZ    *+18               NO\n         CLC   CPUSER(4),=CL4'TECH'  IS IT ALSO TECH\n         BE    *+8                YES, CONT\n         NI    JCBAFL,255-JCBSYSPR  TURN OFF PRIV\n         LA    R2,24(,R2)          SKIP JOB,PROC,STEP NAMES\n         ST    R2,CVTIOT           SAVE\n         TM    JCBAFL,JCBTSO       ARE WE UNDER TSO?\n         L     R2,WAPSCB           PICK UP PSCB ADDRESS\n         LA    R2,7(R2)            POINT TO USER ID LEN\n         IC    R2,0(R2)            PICK UP LENGTH\n         STC   R2,CVUSRFLD         SAVE LENGTH FOR POSTERITY\n         SPACE\n* INITIALIZE PFCB & PAGE POINTERS\n         OFFSET R2,FRSTPAGE\n         ST    R2,CVFPAGE          SAVE IT\n         OFFSET R2,LASTPAGE\n         ST    R2,CVLPAGE\n         OFFSET R2,FRSTPFCB\n         ST    R2,CVFPFCB\n         USING FRSTPFCB,R2\n         LA    R2,LASTPFCB\n         DROP  R2\n         ST    R2,CVLPFCB\n         OFFSET R3,WAFORRTB\n         ST    R3,RTBWAPTR\n         XC    0(L'WAFORRTB,R3),0(R3) CLEAR IT TOO\n         MVI   RTBLSZ+1(R3),133\n         MVI   RTBPSZ+1(R3),25\n         L     R4,544              PICK UP ASCB  FROM PSAANEW\n         L     R4,60(R4)           PICK UP TSB ADDRESS          J\n         SLR   R1,R1               CLEAR FOR SVC\n*        SVC   254                       KEY 0\n         MODESET KEY=ZERO\n         TM    0(R4),X'20'         ASSUME DISP SCREEN IS 3277\n         BZ    NOT3277             NOT US...GO AROUND FLAG SET\nIS3277   OI    LFLG1,CPF3277       SET 3277 FLAG\nNOT3277  EQU    *                 CONTINUE\n         MVC   CPDOUB+5,=CL3' '\n         MVC   CPDOUB(5),CPUSER  USER ID\n         SLR   R2,R2\n         IC    R2,8(,R4)         GET TSBLNSZ\n         LH    R4,36(,R4)        GET TSBATNLC\n         LA    R1,4                CLEAR FOR SVC\n         MODESET KEY=NZERO\n*        SVC   254                       PROBLEM KEY\n         LR    R0,R4\n         LR    R1,R2\n         LTR   R0,R0\n         BNP   NOCRT\n         C     R0,=F'255'\n         BH    NOCRT\n         STH   R0,RTBPSZ(,R3)\n         OI    RTBMFL,RTBCRT\nNOCRT    LTR   R1,R1\n         BNP   NOLIN\n         C     R1,=F'133'\n         BH    NOLIN\n         LA    R1,133              TEMP UNIL TSB IS FOUND\n         STH   R1,RTBLSZ(,R3)\nNOLIN    L     R1,WAPSCB           GET PSCB\n         L     R1,52(,R1)          GET UPT FROM PSCB\n         ST    R1,WAUPT            SAVE UPT\n         SPACE\n         L     R1,16               CVT @\n         L     R1,0(,R1)           CURRENT TCB POINTER\n         L     R1,0(,R1)           CURRENT TCB @\n         L     R1,132(,R1)         MOTHER TCB @\n         L     R1,112(,R1)         MOTHER TCB'S S.A. PTR\n         L     R1,8(,R1)           CALLER'S S.A. PTR\n         L     R1,24(,R1)          CALLER'S R1 = IOPL FOR CALL\n         L     R1,4(,R1)           CALLER'S ECT\n         ST    R1,WAECT            WOW...\n         SPACE\n         OFFSET R3,WORKAREA\n         ST    R3,JCBWAPTR         SAVE POINTER TO IT\n         TM    JCBAFL,JCBTSO       ARE WE A TSO TASK?\n         BZ    NOTCP               NO.. SO DONT LOOK\n         L     R11,8(,R9)          GET A POSSIBLE PSCB ADDR\n         C     R11,WAPSCB          ARE WE A 'CP' ?\n         BNE   NOTCP               NO.. MUST BE VIA A CALL\n         L     R11,4(,R9)          UPT ENTRY\n         ST    R11,WAUPT\n         L     R11,12(,R9)         ENVIRON. CTL TAB\n         ST    R11,WAECT\n         L     R1,0(,R9)           POINTER TO COMMAND BUFFER\n         LH    R2,0(,R1)\n         SH    R2,=H'11'           4 + SIZE('WYLBUR ')\n         LA    R1,4+7(,R1)         TEXT IS FOLLOWING 'WYLBUR '\n         B     GOTPARM             GO PROCESS PARM\n         SPACE\nNOTCP    L     R1,0(,R9)           POINTER TO PARMS\n         LH    R2,0(,R1)           GET LENGTH\n         LA    R1,2(,R1)           POINT TO TEXT\nGOTPARM  LTR   R2,R2               ANYTHING?\n         BNP   NOPARMS\n         ST    R1,CVPARM           SAVE PARM POINTER\n         STC   R2,CVPARM           AND LENGTH\n         SPACE\n* INITIALIZE THE PFCB\nNOPARMS  OFFSET R2,PFCB1\n         USING PFCB,R2\n         MVC   PFCBDCB(PFCBDSZ1),DUMMYDCB\n         MVC   PFCBPDCB(PFCBDSZ2),PDCB\n         OFFSET R3,PT1\n         ST    R3,PFCBPTST         SAVE PAGE TABLE POINTER\n         LA    R3,&PAGE0\n         ST    R3,PFCBNP           SAVE IN PFCB\n         XC    PFCBCP(4),PFCBCP    0 PAGES CURRENTLY IN USE\nDODEVTYP DEVTYPE PFCBDCB+(DCBDDNAM-IHADCB),CPWA,DEVTAB\n         LTR   R15,R15             FILE SUPPLIED?\n         BZ    TESTDASD\n         CLC   DAIRPAGE(4),=C'DONE'  DYNAMIC PERFORMED\n         BE    NOPAGE0      YES BYPASS ALLOC A 2ND TIME\n*             ALLOCATE  CODE FOR WYLRDR OR WYLPRINT\n         L     R15,CVIOWA          ADDRESS OF DAIR ROUTINE\n         LA    R1,WAUPT-WDIOWA(R15)  ADDR OF DAPL\n         LA    R14,DAIRPAGE           PARAMETER LIST\n         ST    R14,WADAIR-WDIOWA(R15)\n         L     R15,CVDAIR          ADDRESS OF DAIR ROUTINE\n         BALR  R14,R15             CALL DAIR\n         LTR   15,15               INTRDR AVAILABLE??\n         BNZ   NOPAGE0                   NO PAGE\n         MVC   DAIRPAGE(4),=CL4'DONE'   SHO AS ALLOCATED\n         B     DODEVTYP            DO DEVTYP AGAIN\nTESTDASD CLI   CPWA+2,X'20'        DIRECT ACCESS?\n         BNE   NODASD              NOPE\n         LA    R6,CPWA             SET BASE\n         USING DVTAREA,R6              FOR DEVTABLE\n         LA    R0,CPSIZE           SET R0 TO BLKSIZE ALSO\n         LR    R3,R0               SET R3 ALSO\n         MH    R3,DVTTOL           MULT BY TOLERANCE\n         SRA   R3,9                DIVIDE BY 512\n         SR    R1,R1               SET FOR IC\n         IC    R1,DVTKEYO          GET KEY OVERHEAD\n         SR    R0,R1               ADJUST BLKSIZES SINCE NO KEYS\n         SR    R3,R1\n         TM    DVTFLAG,DVTFOHD     IS IT HALF WORD OVERHEAD\n         BO    CALCTRK1            BR YES\n         IC    R1,DVTBLKO          GET NORMAL BLOCK OVERHEAD\n         AR    R3,R1               ADJUST NORMAL VALUE\n         IC    R1,DVTLBLKO         GET LAST BLOCK OVERHEAD\n         AR    R0,R1               ADJUST LAST BLOCK VALUE\n         B     CALCTRK2            NOW GO ON\n         SPACE\nCALCTRK1 LH    R1,DVTBLKO          GET BLOCK OVERHEAD\n         AR    R0,R1               ADJUST BOTH FOR\n         AR    R3,R1                   BLOCK OVERHEAD\nCALCTRK2 LH    R1,DVTTRKSZ         GET TRACK SIZE\n         SR    R1,R0               ADJUST FOR LAST BLOCK\n         AR    R1,R3               ADD TO INCR COUNT BY 1\n         SR    R0,R0               SET FOR DIVIDE\n         DR    R0,R3               CALCULATE VALUE IN R1\n         ST    R1,PFCBRPT          SAVE NUMBER OF RECORDS/TRK\n         DROP  R6\n         SPACE\n* OPEN THE FILE\n         LA    R3,PFCBDCB          GET DCB ADDR\n         LA    R4,PFCBPDCB         GET SECOND DCB\n         L     R1,CVPSYNAD         GET SYNAD ADDRESS\n         ST    R1,56(,R4)          SAVE SYNAD ADDRESS\n         L     R1,JCBWAPTR         POINT TO A WORK AREA FOR OPEN\n         OI    4(R1),X'80'     SET LAST DCB BIT\n         OPEN  ((3),(OUTPUT),(4),(OUTPUT)),MF=(E,(1))\n         TM    PFCBDCB+(DCBOFLGS-IHADCB),X'10'  OPEN OK?\n         BZ    BADOPEN\n         TM    PFCBPDCB+(DCBOFLGS-IHADCB),X'10'  OPEN OK?\n         BZ    BADOPEN\n         L     R4,PFCBDCB+(DCBDEBAD-IHADCB)  DEB ADDR\n         USING DEBBASIC,R4\n         SR    R5,R5               CLEAR WORK REG\n         IC    R5,DEBNMEXT         NUMBER OF EXTENTS\n         LA    R4,DEBDDEP          DEVICE DEPENDENT PORTION\n         USING DEBDDEP,R4\n         SR    R1,R1\nCOUNTRKS AH    R1,DEBNMTRK         NUMBER OF TRKS IN THIS EXTENT\n         LA    R4,DEBDSZDA(,R4)    SKIP EXTENT AREA\n         BCT   R5,COUNTRKS         ADD IN REMNDR\n         M     R0,PFCBRPT          TIMES RECORDS/TRK\n         CL    R1,PFCBNP           COMPARE AGAINST MAX DEFINED\n         BNH   *+8                 BR IF OK\n         L     R1,PFCBNP\n         ST    R1,PFCBNP           SAVE MAX\n         LR    R4,R1\n         AL    R1,PFCBPTST         END OF PAGE TABLE\n         BCTR  R1,R0               POINT TO LAST BYTE IN TABLE\n         ST    R1,PFCBPTND\n         L     R3,PFCBNP           LENGTH\n         L     R2,PFCBPTST         BEGINING OF TABLE\n         LA    R5,254              FILL CHAR\n         SLL   R5,24               MOVE TO HIGH ORDER BYTE\n         LR    R4,R2               SAME AREA\n         MVCL  R2,R4               OVERLAY WITH FF\nSETCP    DS    0H\n         L     R3,CVFPFCB          POINT TO PFCB\n         USING PFCB,R3\n         L     R2,CVFPAGE          POINT TO A PCB\n         USING PCB,R2\n         LA    R13,CPWA            SAVE AREA\n         SR    R1,R1               TO GET PAGE 0\n         ST    R3,PCBPFCB\n         MVI   PCBRWCCW,PIOREAD    TO READ IT\n         CVCALL PIO                GET 1ST PAGE\n         TM    JCBBFL,JCBBFPER     IO ERROR?\n         BO    NORMAL              YEP, NO REVCOVERY\n         LA    R4,PCBBUF           POINT TO READ MATERIAL\n         CLC   0(8,R4),=CL8'SUSPEND' IS IT A SUSPENDED SESSION\n         BE    CHKUSER             CHK IF SAME USER\n         CLC   0(8,R4),=CL8'RECOVER' IS IT CRASHED SESSION?\n         BNE   NORMAL\n         MVI   CPCMNM,C'Z'         REMEMBER IT IS RECOVERED.\nCHKUSER  ST    R6,CVSPARES        SAVE PAST COMPARE\n         SR    R6,R6\n         IC    R6,CVUSRFLD        PICK UP ID LENGTH\n         CLC   CPUSER(0),274(R4)  IS THIS THE ONE??             JJG001\n         EX    R6,*-6             EXEC ABOVE COMPARE\n         L     R6,CVSPARES\n         BNE   NORMAL              NOPE\n         MVI   0(R4),X'00'         MAKE IT NO SUSPEND\n         MVI   PCBRWCCW,PIOWRITE   TO WRITE IT BACK\n         CVCALL PIO                GO WRITE IT BACK\n         TM    JCBBFL,JCBBFPER     IO ERROR?\n         BO    NORMAL\n         MVC   PFCBCP(4),8(R4)     CURRENT PAGES\n         MVC   CPRSCNVL(4),12(R4)  RESCAN ESC & SKIP\n         MVC   CPEXLNET(4),16(R4)\n         MVC   CVEXTRAP(12),20(R4)\n         LA    R4,32(,R4)\n         L     R5,RTBWAPTR\n         MVC   RTBSTART(RTBSIZE-RTBNTEXT),0(R4)\n         ST    R5,RTBWAPTR\n         LA    R4,RTBSIZE-RTBNTEXT(,R4)\n         MVC   CPGLDL(CPRCVSZ1),0(R4)\n         LA    R4,CPRCVSZ1(,R4)\n         MVC   CPDRPT(CPRCVSZ2),0(R4)\n         LA    R4,CPRCVSZ2(,R4)\n         LR    R0,R2                         SAVE ACROSS MVCL\n         LR    R1,R3                         SAVE ACROSS MVCL\n         LA    R2,CPDREC                     SET FOR MVCL\n         LA    R3,CPRCVSZ3                   LENGTH\n         LR    R14,R4                        FROM\n         LR    R15,R3                        SAME LENGTH\n         MVCL  R2,R14                        MOVE IT\n*        MVC   CPDREC(CPRCVSZ3),0(R4)\n         LA    R4,CPRCVSZ3(,R4)\n         MVC   CPCHECK(4),=X'6913723F'\n         LA    R2,ROUTBLE                    SET FOR MVCL\n         LA    R3,ROUTBLEN                   LENGTH\n         LR    R14,R4                        FROM\n         LR    R15,R3                        SAME LENGTH\n         MVCL  R2,R14                        MOVE IT\n         LR    R2,R0                         RESTORE\n         LR    R3,R1                         RESTORE\n*        MVC   ROUTBLE(256),0(R4)\n*        MVC   ROUTBLE+256(ROUTBLEN-256),256(R4)\n         LA    R4,ROUTBLEN(,R4)\n         MVC   0(256,R5),0(R4)\n         LA    R4,256(,R4)\n         L     R3,CVFPFCB            POINT TO PFCB\n         L     R2,CVFPAGE            FIRST PCB\n         LA    R2,PCBSIZE(,R2)        2ND PCB\n         MVI   PCBRWCCW,PIOREAD       GO READ 2ND CP IN\n         LA    R1,1\n         ST    R3,PCBPFCB\n         CVCALL PIO\n         TM    JCBBFL,JCBBFPER        IO ERROR\n         BO    SIGHSIGH               TOO BAD\n         LR    R0,R2                  SAVE\n         LR    R1,R3                      ACROSS MVCL\n         LA    R14,PCBBUF             MOVE FROM\n         L     R2,PFCBPTST            BEGINNING OF PAGE TABLE\n         LA    R3,&PAGE0              MAX NUMBER OF PAGES\n         LR    R15,R3                 SAME LENGTH\n         MVCL  R2,R14                 MOVE IT\n         LR    R2,R0                         RESTORE\n         LR    R3,R1                         RESTORE\n         L     R5,PFCBPTST\n         CLI   CPCMNM,C'Z'            RECOVERY?\n         BNE   REWRITE\nPTLP     CLI   0(R5),INCORE\n         BNE   *+8\n         MVI   0(R5),0\n         CLI   0(R5),X'FE'\n         LA    R5,1(,R5)\n         BNE   PTLP\n         XC    RTBWC(6),RTBWC\n         SPACE\nREWRITE  LA    R5,CPAREA+CPSIZE       POINT TO AREA\n         ST    R5,PCBRWCCW\n         MVI   PCBRWCCW,PIOREAD       GO READ 2ND CP IN\n         LA    R1,2\n         CVCALL PIO\n         TM    JCBBFL,JCBBFPER        IO ERROR\n         BO    SIGHSIGH               TOO BAD\n         OFFSET R5,VCPAGE\n         ST    R5,CVCPADDR\n         ST    R5,PCBRWCCW\n         MVI   PCBRWCCW,PIOREAD       GO READ VCP IN\n         LA    R1,3\n         CVCALL PIO\n         TM    JCBBFL,JCBBFPER        IO ERROR?\n         BO    SIGHSIGH               TOO BAD\n         LA    R5,PCBBUF\n         ST    R5,PCBRWCCW\n         SPACE\n         L     R5,PFCBPTST            START OF PT\n         L     R4,PFCBRPT             # BLOCKS PER TRACK\n         SR    R1,R1                  0 TRACKS\nPTLOOP   AR    R5,R4                  START FROM TRK 1\n         LA    R1,1(,R1)              1 MORE TRACK\n         CLI   0(R5),X'FE'            A VIRGIN PAGE\n         BNE   PTLOOP\n         STH   R1,CPWK1\n         MVC   CPWK1+2,=X'0100'       1ST RECORD ON NEW TRK\n         LA    R0,CPWK1\n         LA    R1,PFCBPDCB            DCB ADDRESS\n         POINT (1),(0)\n         OI    CPGFLG,CPFDIRCH\n         CLI   CPCMNM,C'Z'         WAS IT RECOVERED?\n         BE    RECOVERD\n         SYSQS 1,0,'SUSPENDED SESSION RESTORED'\nTPUTRET  TPUT  (1),(0),EDIT,WAIT\n         B     LOADEXIT\n         SPACE\nRECOVERD TM    CPGFLG2,CPFEXEC\n         BZ    RECVNOEX\n         OI    JCBAFL,JCBAFIA      SET IDLE ATTENTION\n         XC    CVEXTRAP,CVEXTRAP   GET RID OF EXEC TRAP\nRECVNOEX SYSQS 1,0,'PREVIOUS SESSION RECOVERED SUCCESSFULLY'\n         B     TPUTRET\n         EJECT\nNORMAL   LA    R3,3                GET 3 PAGES\n         NI    JCBBFL,255-JCBBFPER TURN OF I/O ERROR FLAG\nPGETLP   SR    R1,R1               CLEAR FOR NEW PAGE\n         PGET  R1\n         TM    JCBBFL,JCBBFPER\n         BO    NOPAGES\n         LR    R5,R1               DON'T USE R1 FOR PFREE CALL\n         PFREE R5                  FREE THE PAGE WE JUST GOT\n         BCT   R3,PGETLP\n         SPACE\n* NOTE THAT THE PAGE IS JUST FREED.. NOT JUNKED\n* THAT MEANS PAGE WILL NOT BE IN CORE BUT REMAIN ALLOCATED.\n* THE PGET ROUTINE WILL WRITE OUT A TRACKFUL OF DUMMY PAGES\n* BECAUSE THE PAGE THAT WAS JUST GOTTEN WAS A BRAND NEW PAGE .\n         SPACE 3\n         MVC   CPUSERSV(8),CPUSER  FOR SAVE\n*        OI    CPGFLG,CPFVOLM      SET DEFAULT VOL FLAG    ITEL\n         OI    CPGFLG,CPFVOLM+CPFCMOFF TER & VOL FLAG      ITEL\n         OI    RTBMFL,RTBWRAP      SET WRAP AS DEFAULT\n         OI    RTBUFL,RTBUNCOL         NOCOLLECT FLAG      ITEL\n         MVC   CPVOLSV,=C'CATLG '  SET DEFAULT VOL = CATLG\n         MVC   CPCHECK(4),=X'6913723F'\n         MVC   CPGLDL(4),=F'1000'       DELTA=1.000\n         MVC   CPLNGTH(2),=H'72'        LEN=72\n         MVC   CPDREC(4),=D'0'          ZERO 1ST LINE NO.\n         MVI   CPLSTCOL,FNEGBT          SET NO COLLECT YET\n         MVI   CPCURRL,FNEGBT      SET CURRENT LINE POINTER INV\n         MVI   CPEXLINE,FNEGBT     SET EXEC LINE POINTER INV\n         MVI   CPMEMBSV,X'40'      CLEAR MEMBER\n         MVC   CPMEMBSV+1(L'CPMEMBSV-1),CPMEMBSV\n         OFFSET VCPR,VCPAGE\n         ST    VCPR,CVCPADDR\n         USING DVCP,VCPR\n         XC    VCPWVAR,VCPWVAR    ZERO LINE # VARIABLES\n         XC    VCPNVAR,VCPNVAR    ZERO INTEGER VARIABLES\n         MVC   VCPSVAR(L'SVARINIT),SVARINIT  INIT STRING VARS\n         LA    R2,24      LOOP\n         LA    R1,PVARINIT\n         LA    R6,VCPPVAR\nVCPVLOOP MVC   0(2,R6),0(R1)     MOVE PFK'S\n         MVC   2(23,R6),=CL23' ' SET DUMMY PFK'S\n         LA    R6,25(,R6)        NEXT AREA\n         LA    R1,2(,R1)         NEXT PFK DEF\n         BCT   R2,VCPVLOOP       LOOP THRU IT\n         DROP  VCPR\n         LA    0,5\n         STH   0,CPRSCNVL         INITIALIZE RESCAN LIMIT\n         OI    CPGFLG2,CPESNULL   SET ESCAPE CHARACTER NULL\n         OI    CPGFLG2,CPSKNULL   SET SKIP CHARACTER NULL\n         LA    R13,CPWA            SAVE AREA\n         MVC   CPCMSAV(L'LOGCMND),LOGCMND\n         LA    R0,L'LOGCMND-1\n         ST    R0,CPCTSAV\n         EJECT\n* LOAD IN THE PAGED ROUTINES\n         SPACE\n         LA    R10,ROUTBLE\n         USING ROUTBLE,R10\n         LA    R6,PAGTBLE-4        SET FOR START OF LOOP\n         SR    R5,R5               CLEAR REG FOR PFREE\n         USING PCB,R5\n         SPACE\n* LOOP THROUGH PAGTBLE AND LOAD EACH OVERLAY SEGMENT\n* AFTER LOADING THE SEGMENT, GET A PAGE FROM THE ACTIVE\n* FILE AND WRITE OUT THE OVERLAY SEGMENT.  THEN FILL IN\n* ROUTBLE FOR ANY ROUTINES FOUND.\n         SPACE\nLOADLOOP LA    R6,4(,R6)           STEP UP TO NEXT ENTRY\n         C     R6,=A(PAGTBLED)     END OF PAGETABLE?\n         BNL   LOADDONE            YES..GO FINISH\n         L     R1,0(,R6)           LOAD VCON\n         LTR   R1,R1               DOES IT EXIST?\n         BZ    LOADLOOP            NO..GO ON TO NEXT PAGE\n         LA    R0,1                SET R0 FOR SEGWT\n         SVC   37                  GO GET EM\n         PGET  R5                  GET A PAGE\n         BZ    NOPAGES\n         STH   R0,PCBPN            SAVE PAGE NUMBER IN PCB\n         LR    R4,R0               PRESERVE PAGE NUMBER\n         L     R11,=A(P001)\n         LH    R1,0(,R11)          GET ADDR OF INIT CODE\n         BAL   R14,0(R11,R1)       GO DO INIT CODE\n         STM   R2,R5,CVSPARES      TEMP SAVE\n         LR    R4,R11              SET R2 TO MOVE CODE\n         LR    R2,R5               SET R1 TO BUFFER ADDRESS\n         LA    R3,CPSIZE\n         LA    R5,CPSIZE           MOVE-A-CHUNK\n         MVCL  R2,R4\n         LM    R2,R5,CVSPARES      RESTORE REGS\n         PMARK R5                  MARK THE BUFFER\n         LA    R11,2(,R11)         SET R11 TO FIRST TABLE ENTRY\nLOADLP2  LH    R1,0(,R11)           GET NEXT ENTRY\n         LTR   R1,R1               IS THIS END OR DEFAULT\n         BM    LOADLP5             BR IF EITHER\n         C     R1,=A(ROUTBLEN)     CHECK THAT ITS IN RANGE\n         BL    LOADLP3             BR IF OK\n         WTO   '**WYLTSO** INCOMPATIBLE PAGED CODE..REASSEMBLE IT'\n         B     RETURN16\n*\nLOADLP3  STH   R4,ROUTBLE(R1)      PUT PAGE NO. IN ROUTBLE\n         LH    R0,2(,R11)           GET DISPLACEMENT TO START\n         STH   R0,ROUTBLE+2(R1)    PUT IT IN ROUTBLE\nLOADLP4  LA    R11,4(,R11)           STEP TO NEXT ENTRY\n         B     LOADLP2             GO CHECK THIS ENTRY\n*\nLOADLP5  CH    R1,=H'-1'   IS THIS DEFAULT ROUTINE FOR MISSING\n         BNE   LOADLOOP           NO, GO DO NEXT OVERLAY\n         STH   R4,LOADEFLT         YES, SAVE PAGE NUMBER\n         MVC   LOADEFLT+2(2),2(R11)   AND ALSO DISPLACEMENT\n         B     LOADLP4             GO DO NEXT ON THIS PAGE\n         DROP  R10\nLOADDONE PFREE R5                  FREE THE LAST GOTTEN PCB\n         CLC   LOADEFLT,=A(0)      IS THERE A DEFAULT MISSING ROUTINE\n         BE    LOADEXIT            NO, RETURN\n         L     R2,=A(ROUTBLEN)     LOAD LENGTH OF ROUTBLE\n         AR    R2,R10              NOW POINT TO END OF TABLE\nLOADEFLP CR    R10,R2              ARE WE DONE\n         BNL   LOADEXIT            BR YES\n         CLC   0(4,R10),=A(0)      WAS THIS ENTRY INITIALIZED\n         BNE   *+10                YES, DON'T PUT IN DEFAULT\n         MVC   0(4,R10),LOADEFLT   NO, SET ENTRY TO DEFAULT\n         LA    R10,4(,R10)         STEP TO NEXT ENTRY\n         B     LOADEFLP            GO DO IT\n         SPACE\nLOADEXIT DELETE EP=IEWSZOVR        DELETE REMDR\n         SPACE\n* INITIALIZE RECOVERY IOB AND CCW'S TO WRITE OUT SNAPSHOT\n         SPACE\n         L     R4,CVPIOB           GET RECOVERY IOB ADDRESS\n         USING PIOB,R4\n         MVI   PIOBFLG1,X'42'      COMMAND CHAINING\n         LA    R1,PECB             ECB ADDRESS\n         ST    R1,PIOBECB-1\n         LA    R1,PCCWS            START OF CCWS\n         ST    R1,PIOBCCW-1\n         L     R1,CVFPFCB          POINT TO THE PFCB\n         LA    R1,PFCBDCB-PFCBSTRT(,R1) DCB ADDRESS\n         ST    R1,PIOBDCB-1\n         L     R1,DCBDEBAD-IHADCB(,R1) POINT TO DEB\n         LR    R3,R1               REMEMBER DEB ADDRESS\n         LR    R6,R12              REMEMBER CP ADDRESS\n         L     R15,16              CVT ADDRESS\n         LA    R2,PSEEK1           RESULT ADDRESS OF CONV\n         L     R15,28(,R15)        TTR CONVERSION ROUTINE\n         L     R0,=X'00000100'     1ST RECORD, 1ST TRACK\n         LR    R5,R15              REMEMBER TTR CONV ROUTINE\n         BALR  R14,R15\n         LA    R2,PSEEK2           RESULT ADDRESS OF CONV\n         LR    R15,R5              TTR CONV ROUTINE\n         LR    R1,R3               DEB ADDRESS\n         L     R0,=X'00000200'     2ND RECORD\n         BALR  R14,R15\n         LA    R2,PSEEK3           RESULT ADDRESS OF CONV\n         LR    R15,R5              CONV ROUTINE ADDRESS\n         LR    R1,R3               DEB ADDRESS\n         L     R0,=X'00000300'     3RD RECORD\n         BALR  R14,R15\n        LA    R2,PSEEK4           RESULT ADDRESS OF CONV\n         LR    R15,R5              CONV ROUTINE ADDRESS\n         LR    R1,R3               DEB ADDRESS\n        L     R0,=X'00000400'     4TH RECORD\n         BALR  R14,R15\n         LR    R12,R6              RESTORE CP ADDRESS\n         LA    R13,CPWA            RESTORE SAVE AREA ADDRESS\n         LA    R2,PSEEK1+3\n         ST    R2,PCCWSID1\n         MVI   PCCWSID1,X'31'      SEARCH ID EQUAL\n         MVI   PCCWSID1+4,X'40'    COMMAND CHAINING\n         MVI   PCCWSID1+7,X'05'    LENGTH OF 5\n         LA    R2,PCCWSID1\n         ST    R2,PCCWTIC1\n         MVI   PCCWTIC1,X'08'\n         L     R2,JCBWAPTR\n         ST    R2,PCCWWRT1\n         MVI   PCCWWRT1,X'05'\n         LA    R5,PCBPSIZE\n         ST    R5,PCCWWRT1+4\n         MVI   PCCWWRT1+4,X'40'\n         LA    R2,PSEEK2+3\n         ST    R2,PCCWSID2\n         MVI   PCCWSID2,X'31'      SEARCH ID EQUAL\n         MVI   PCCWSID2+4,X'40'    COMMAND CHAINING\n         MVI   PCCWSID2+7,X'05'    LENGTH OF 5\n         LA    R2,PCCWSID2\n         ST    R2,PCCWTIC2\n         MVI   PCCWTIC2,X'08'\n         L     R2,JCBWAPTR\n         AH    R2,=AL2(CPSIZE)\n         ST    R2,PCCWWRT2\n         MVI   PCCWWRT2,X'05'\n         ST    R5,PCCWWRT2+4\n         MVI   PCCWWRT2+4,X'40'\n         LA    R2,PSEEK3+3\n         ST    R2,PCCWSID3\n         MVI   PCCWSID3,X'31'      SEARCH ID EQUAL\n         MVI   PCCWSID3+4,X'40'    COMMAND CHAINING\n         MVI   PCCWSID3+7,X'05'    LENGTH OF 5\n         LA    R2,PCCWSID3\n         ST    R2,PCCWTIC3\n         MVI   PCCWTIC3,X'08'\n         LA    R2,CPAREA+CPSIZE\n         ST    R2,PCCWWRT3\n         MVI   PCCWWRT3,X'05'\n         ST    R5,PCCWWRT3+4\n         LA    R2,PSEEK4+4\n         ST    R2,PCCWSID4\n          MVI   PCCWSID4,X'31'      SEARCH ID EQUAL\n         MVI   PCCWSID4+4,X'40'    COMMAND CHAINING\n         MVI   PCCWSID4+7,X'05'    LENGTH OF 5\n         LA    R2,PCCWSID4\n         ST    R2,PCCWTIC4\n         MVI   PCCWTIC4,X'08'\n         L     R2,CVCPADDR\n         ST    R2,PCCWWRT4\n         MVI   PCCWWRT4,X'05'\n         ST    R5,PCCWWRT4+4\n         MVC   CVPROMPT,CVPRMLIM\n         SPACE\n         L     R14,CVIOWA          WORK AREA ADDRESS\n         USING WDIOWA,R14\n         LA    R1,WASTAX           STAX PARAMETER AREA\n         XC    WASTAX(20),WASTAX   CLEAR IT\n         DROP  R14\n         L     R14,CVATNRTN        ATTENTION EXIT ADDRESS\n         STAX  (14),REPLACE=NO,DEFER=NO,USADDR=((12)),MF=(E,(1))\n         OI    JCBAFL,JCBSTAX\n         BR    R8                  RETURN TO WYLBUR\n         EJECT\n* ERROR MESSAGES:\n         SPACE\nNODASD   SYSQS 1,0,'PAGEFILE NOT ON DIRECT ACCESS DEVICE'\n         B     RETURN16                  EXIT\nSIGHSIGH SYSQS 1,0,'UNABLE TO RECOVER FROM SUSPENDED SESSION'\n         B     RETURN16\nNOPAGE0  SYSQS 1,0,'PAGEFILE NOT SUPPLIED'\n         B     RETURN16\nBADOPEN  SYSQS 1,0,'PAGEFILE CANNOT BE OPENED'\n         B     RETURN16\nNOPAGES  SYSQS 1,0,'INSUFFICIENT PAGES TO INITIALIZE'\n         SPACE\nRETURN16 TPUT  (1),(0),,WAIT,,BREAKIN\n         L     R13,CVRETURN\n         LM    R14,R12,12(R13)     RESTORE REGS\n         LA    R15,16\n         BR    R14                 RETURN TO CALLER\n         EJECT\n* VCON ENTRIES FOR EACH OVERLAY PAGE\n         SPACE\nPAGTBLE  DS    0F\n         DC    V(P001)\n         DC    V(P002)\n         DC    V(P003)\n         DC    V(P004)\n         DC    V(P005)\n         DC    V(P006)\n         DC    V(P007)\n         DC    V(P008)\n         DC    V(P009)\n         DC    V(P010)\n         DC    V(P011)\n         DC    V(P012)\n         DC    V(P013)\n         DC    V(P014)\n         DC    V(P015)\n         DC    V(P016)\n         DC    V(P017)\n         DC    V(P018)\n         DC    V(P019)\n         DC    V(P020)\n         DC    V(P021)\n         DC    V(P022)\n         DC    V(P023)\n         DC    V(P024)\n         DC    V(P025)\n         DC    V(P026)\n         DC    V(P027)\n         DC    V(P028)\n         DC    V(P029)\n         DC    V(P030)\n         DC    V(P031)\n         DC    V(P032)\n         DC    V(P033)\n         DC    V(P034)\n         DC    V(P035)\n         DC    V(P036)\n         DC    V(P037)\n         DC    V(P038)\n         DC    V(P039)\n         DC    V(P040)\n         DC    V(P041)\nPAGTBLED EQU   *                   END OF PAGTBLE\n         SPACE\nLOADEFLT DC    F'0'                DEFAULT ROUTINE FOR MISSING\n         SPACE\nLOGCMND  DC    C';X FRO #LOGON NOL '\n         SPACE 3\n         LTORG\n         SPACE\n         DROP  R5\n         DROP  R7\n         EJECT\n         DS    0H\nSVARINIT DS    0CL34\n         DC    H'32'\n         DC    C'0',X'00'\n         DC    C'1',X'00'\n         DC    C'2',X'00'\n         DC    C'3',X'00'\n         DC    C'4',X'00'\n         DC    C'5',X'00'\n         DC    C'6',X'00'\n         DC    C'7',X'00'\n         DC    C'8',X'00'\n         DC    C'9',X'00'\n         DC    C'A',X'00'\n         DC    C'B',X'00'\n         DC    C'C',X'00'\n         DC    C'D',X'00'\n         DC    C'E',X'00'\n         DC    C'F',X'00'\n         SPACE\nPVARINIT DS    0CL48\n         DC   X'F1',X'00'                   PFK01\n         DC   X'F2',X'00'                   PFK02\n         DC   X'F3',X'00'                   PFK04\n         DC   X'F4',X'00'                   PFK03\n         DC   X'F5',X'00'                   PFK05\n         DC   X'F6',X'00'                   PFK06\n         DC   X'F7',X'00'                   PFK07\n         DC   X'F8',X'00'                   PFK08\n         DC   X'F9',X'00'                   PFK09\n         DC   X'7A',X'00'                   PFK10\n         DC   X'7B',X'00'                   PFK11\n         DC   X'7C',X'00'                   PFK12\n         DC   X'C1',X'00'                   PFK13\n         DC   X'C2',X'00'                   PFK14\n         DC   X'C3',X'00'                   PFK15\n         DC   X'C4',X'00'                   PFK16\n         DC   X'C5',X'00'                   PFK00\n         DC   X'C6',X'00'                   PFK18\n         DC   X'C7',X'00'                   PFK00\n         DC   X'C8',X'00'                   PFK20\n         DC   X'C9',X'00'                   PFK21\n         DC   X'4A',X'00'                   PFK22\n         DC   X'4B',X'00'                   PFK23\n         DC   X'4C',X'00'                    PFK24\n          PRINT NOGEN\nDUMMYDCB DCB   DDNAME=PAGE0,MACRF=(E),DEVD=DA,DSORG=DA\n         SPACE\nPDCB     DCB   DDNAME=PAGE0,DSORG=PS,MACRF=WP,BLKSIZE=PCBPSIZE,        *\n               RECFM=F,OPTCD=C,SYNAD=0\n         PRINT GEN\n         TITLE  'DYNAMIC ALLOCATION PARMS FOR PAGE0'\nDAIRPAGE DS    0F\n         DC    X'0008'\n         DC    X'0000'\n         DC    X'00000000'\n         DC    AL4(PAGEDSN)\n         DC    CL8'PAGE0'\n         DC    CL8'VIO'\n         DC    CL8' '\n         DC    AL4(CPSIZE)              SIZE OF PAGE\n         DC    AL4(&PAGE0)             NUMBER OF PAGES\n         DC    F'0'\n         DC    F'0'\n         DC    CL8' '\n         DC    CL8' '\n         DC    XL3'040000'\n         DC    X'48'              BLOCK ALLOCATION/PERM ATTR\n         DC    F'0'\n         DC    CL8' '\nPAGEDSN  DC    XL2'002C',CL44' '\n         TITLE 'START OF PAGED CODE -- PAGE 1'\nP001     PAGECDE MISSING\n         WIDENT 001\n         USING CPAREA,R12\n         TITLE 'DEFAULT MISSING ROUTINE -- PAGE 1'\nPMISSING GENTER\n         TSEG  'CODE FOR ROUTINE NOT IN PAGEFILE'\n         B     CVQTYPE\n         TITLE 'END OF PAGE CODE -- PAGE 1'\n         PINIT                     DEFINE START OF INIT ROUTINE\n         PEND                      DEFINE END ON INIT CODE\n         TITLE 'CONSTANTS AND CONTROL BLOCKS'\n         COPY  WYLCONST\n         EJECT\n         COPY  VCPTSO\n         EJECT\nPCB      DSECT\n         COPY  PCBTSO\n         EJECT\nPFCB     DSECT\n         COPY  PFCBTSO\n         EJECT\nPIOB     DSECT\n         COPY  PIOB\n         EJECT\n         COMMON\n         EJECT\n         LTORG\n         ORG   ,\nFRSTPAGE DS    0D\n         PAGES &NUMPAGE\nLASTPAGE DS    0D\n         EJECT\nFRSTPFCB DS    0D\n         PAGEFILE &PAGE0           DEFINE ONE DRUM FILE\nLASTPFCB DS    0F\n         EJECT\n         PT\nVCPAGE   DS    0F\n         DS    XL(CPSIZE)         VARIABLE COMMAND PAGE\n         DS    0D\nWORKAREA DS    XL(CPSIZE*2)\nWAFORRTB DS    CL256\n         SPACE\nPCBTABLE DS    &NUMPAGE.A\n         SPACE\nCVDDLIST DS    &MAXDDS.CL8\n         SPACE\nCVCPEND  DS    0D                  ROUND OFF TO DBL-WRD\n         SPACE\nCVCPSIZE EQU   *-CPSTART\n         EJECT\nDEB      DSECT\n         COPY  DEB\n         SPACE 3\n         DCBD\n         EJECT\nWDIOWA   WDIOWA DSECT\n         SPACE\n         END\n./ ADD NAME=INIT9    0100-80228-80228-1339-00949-00949-00000-$SYS13  00\nINIT     TITLE 'WYLTSO INITIALIZATION ROUTINE'\n*  WYLBUR MVS/TSO VERSION 1.1\n         SPACE\n         COPY  PMAC\n         SPACE\n         USING CPAREA,R12\n         SPACE 3\n         ENTRY INITWYL\nINITWYL  CSECT\n         DC    24XL256'00'         DUMMY MODULE\n         ORG   INITWYL\n         LR    R7,R15              GET ADDRESSABILITY\n         LR    R4,R1               ADDRESS OF REAL CV\n         LR    R8,R14              RETURN ADDRESS\n         SPACE\n*** WARNING *** R8 MUST NOT BE ALTERED *** WARNING ***\n         SPACE\n         USING INITWYL,R7\n         L     R0,=A(CVCPSIZE)     DETERMINE GETMAIN SIZE\n         A     R0,=F'1024'         FOR TRACE AREA\n         A     R0,=A(PIOBSIZE)     FOR RECOVERY IOB\n         GETMAIN R,LV=(0),PAGE       GO GET 'EM\n         SPACE\n* WE GOT IT IF WE SURVIVE TO GET HERE\n         LR    R12,R1              POINT TO THE AREA\n         LA    R13,CPWA\n         SPACE\n* CLEAR THE 'CP' PART OF THE AREA\n         SLR   R0,R0               CLEAR FOR MVCL\n         LR    R2,R1             AREA TO CLEAR\n         LA    R1,0              FILL CHAR INTO REG 1\n         LA    R3,CPSIZE          SIZE OF AREA TO CLEAR\n         MVCL  R2,R0             CLEAR THE AREA\n* COPY THE REAL CV INTO OUR AREA. R4 POINTS TO IT.\n         LA    R3,CVSIZE            SIZE TO MOVE\n         LR    R5,R3                ALSO IN REG 5\n         LA    R2,CVSTART           AREA TO MOVE TO\n         MVCL  R2,R4                MOVE IT\n         SPACE\n* CLEAR JCB FIELDS\n         XC    JCBSTART(JCBSIZE),JCBSTART\n         SPACE\n*\nCOPYWA   LOAD  EP=WYLWA\n         ST    R0,CVIOWA           SAVE ADDR OF WORK AREA\n         ST    R11,CVRETURN        SAVE OS RETURN ADDR\n         SPACE\n* INITIALIZE THE TRACE AREA\n         OFFSET R1,CVCPEND\n         ST    R1,CVTRSTRT         START OF TABLE\n         ST    R1,CVTRACE          CURRENT ENTRY\n         LA    R2,1024-16(,R1)\n         ST    R2,CVTREND          END OF TABLE POINTER\n         SPACE\n* NOW CLEAR THE AREA\n         LR    R2,R1               SET REG FOR MOVE AREA\n         LA    R3,1024             LENGTH TO MOVE\n         LA    R0,0                FOR CLEAR AREA\n         LA    R1,0                FILL LENGTH\n         SPACE\n* CLEAR RECOVERY IOB AND SAVE ITS ADDRESS IN CV\n         ST    R2,CVPIOB\n         XC    0(PIOBSIZE,R2),0(R2)\n         SPACE\n* INITIALIZE ALL THE CONTROL BLOCKS\nINIT2    LA    R1,&NUMPAGE         NUMBER OF PAGES IN SYS\n         OFFSET R2,CVPAGE1         POINT TO FIRST PAGE\n         USING PCB,R2\nPAGEINIT XC    PCBPT(PCBSIZE-PCBPSIZE),PCBPT\n         MVI   PCBFLG1,X'42'\n         LA    R3,PCBECB\n         ST    R3,PCBECBP-1        SAVE POINTER TO ECB\n         LA    R3,PCBCCWS          ADDR OF CHAN PROG\n         ST    R3,PCBCCWP-1        SAVE IN IOB\n         OFFSET R3,PFCB1+PFCBDCB-PFCB\n         ST    R3,PCBDCB-1         SAVE IN IOB\n         SPACE\n* NOW INITIALIZE THE CHANNEL PROG\n         LA    R3,PCBSEEK+3\n         ST    R3,PCBCCWS\n         MVI   PCBCCWS,X'31'       MOVE IN OP-CODE\n         MVI   PCBCCWS+4,X'40'     COMMAND CHAIN\n         MVI   PCBCCWS+7,X'05'     LENGTH OF 5\n         LA    R3,PCBCCWS\n         ST    R3,PCBCCWS+8        SAVE TIC ADDRESS\n         MVI   PCBCCWS+8,X'08'     TIC OP-CODE\n         LA    R3,PCBBUF           ADDRESS OF BUFFER\n         ST    R3,PCBRWCCW         SAVE INTO CCW\n         MVI   PCBRWCCW,X'06'      OP-CODE\n         MVC   PCBRWCCW+6(2),=AL2(PCBPSIZE)\n         SPACE\n* ALL DONE FOR THIS PAGE\n         LA    R2,PCBSIZE(,R2)     NEXT\n         BCT   R1,PAGEINIT         GET REMAINDER OF PAGES\n         DROP  R2\n         OFFSET R3,CVDDLIST\n         ST    R3,CVDDNAMS\n         OFFSET R3,PCBTABLE\n         ST    R3,CVPADDRS\n         LA    R0,&NUMPAGE\n         OFFSET R1,CVPAGE1         FIRST PAGE\nPCBLOOP  ST    R1,0(,R3)\n         LA    R3,4(,R3)\n         LA    R1,PCBSIZE(,R1)\n         BCT   R0,PCBLOOP\n         SPACE\n* GET TIOT POINTER\n         LA    R2,CPSTART          USE AREA AS BUFFER FOR EXTRACT\n         EXTRACT (R2),FIELDS=(TIOT,TSO,PSB),MF=(E,(R2))\n         L     R3,CPSTART+8        GET PSCB ADDR\n         L     R10,CVIOWA          WORK AREA\n         USING WDIOWA,R10\n         ST    R3,WAPSCB           SAVE PSCB ADDR IN WORK AREA\n         L     R4,CPSTART+4        TSO FIELD IN THE TCB\n         TM    0(R4),X'80'         ARE WE TSO BOUND?\n         BZ    NONTSO\n         OI    JCBAFL,JCBTSO       WE ARE UNDER TSO\n         TM    16(R3),X'80'        PRIV?\n         BZ    *+8\n         OI    JCBAFL,JCBSYSPR\n         LOAD  EP=IKJEFD00         NAME OF MODULE\n         ST    R0,CVDAIR\n         SPACE\n* INITIALIZE USER ID\n*\n*\n*\nNONTSO   EQU    *\n         L     R2,CPSTART        TIOT POINTER\n         MVC   CPUSER(8),0(R2)    MOVE IN USER ID\n         TM    JCBAFL,JCBSYSPR    PRIV\n         BZ    *+18               NO\n         CLC   CPUSER(4),=CL4'$SYS'  IS IT ALSO TECH. SUPPORT\n         BE    *+8                YES, CONT\n         NI    JCBAFL,255-JCBSYSPR  TURN OFF PRIV\n         LA    R2,24(,R2)          SKIP JOB,PROC,STEP NAMES\n         ST    R2,CVTIOT           SAVE\n         TM    JCBAFL,JCBTSO       ARE WE UNDER TSO?\n         L     R2,WAPSCB           PICK UP PSCB ADDRESS\n         LA    R2,7(R2)            POINT TO USER ID LEN\n         IC    R2,0(R2)            PICK UP LENGTH\n         STC   R2,CVUSRFLD         SAVE LENGTH FOR POSTERITY\n         SPACE\n* INITIALIZE PFCB & PAGE POINTERS\n         OFFSET R2,FRSTPAGE\n         ST    R2,CVFPAGE          SAVE IT\n         OFFSET R2,LASTPAGE\n         ST    R2,CVLPAGE\n         OFFSET R2,FRSTPFCB\n         ST    R2,CVFPFCB\n         USING FRSTPFCB,R2\n         LA    R2,LASTPFCB\n         DROP  R2\n         ST    R2,CVLPFCB\n         OFFSET R3,WAFORRTB\n         ST    R3,RTBWAPTR\n         XC    0(L'WAFORRTB,R3),0(R3) CLEAR IT TOO\n         MVI   RTBLSZ+1(R3),133\n         MVI   RTBPSZ+1(R3),25\n         L     R4,544              PICK UP ASCB  FROM PSAANEW\n         L     R4,60(R4)           PICK UP TSB ADDRESS          J\n         SLR   R1,R1               CLEAR FOR SVC\n*        SVC   254                       KEY 0\n         MODESET KEY=ZERO\n         TM    0(R4),X'20'         ASSUME DISP SCREEN IS 3277\n         BZ    NOT3277             NOT US...GO AROUND FLAG SET\nIS3277   OI    LFLG1,CPF3277       SET 3277 FLAG\nNOT3277  EQU    *                 CONTINUE\n         MVC   CPDOUB+5,=CL3' '\n         MVC   CPDOUB(5),CPUSER  USER ID\n         SLR   R2,R2\n         IC    R2,8(,R4)         GET TSBLNSZ\n         LH    R4,36(,R4)        GET TSBATNLC\n         LA    R1,4                CLEAR FOR SVC\n         MODESET KEY=NZERO\n*        SVC   254                       PROBLEM KEY\n         LR    R0,R4\n         LR    R1,R2\n         LTR   R0,R0\n         BNP   NOCRT\n         C     R0,=F'255'\n         BH    NOCRT\n         STH   R0,RTBPSZ(,R3)\n         OI    RTBMFL,RTBCRT\nNOCRT    LTR   R1,R1\n         BNP   NOLIN\n         C     R1,=F'133'\n         BH    NOLIN\n         LA    R1,133              TEMP UNIL TSB IS FOUND\n         STH   R1,RTBLSZ(,R3)\nNOLIN    L     R1,WAPSCB           GET PSCB\n         L     R1,52(,R1)          GET UPT FROM PSCB\n         ST    R1,WAUPT            SAVE UPT\n         SPACE\n         L     R1,16               CVT @\n         L     R1,0(,R1)           CURRENT TCB POINTER\n         L     R1,0(,R1)           CURRENT TCB @\n         L     R1,132(,R1)         MOTHER TCB @\n         L     R1,112(,R1)         MOTHER TCB'S S.A. PTR\n         L     R1,8(,R1)           CALLER'S S.A. PTR\n         L     R1,24(,R1)          CALLER'S R1 = IOPL FOR CALL\n         L     R1,4(,R1)           CALLER'S ECT\n         ST    R1,WAECT            WOW...\n         SPACE\n         OFFSET R3,WORKAREA\n         ST    R3,JCBWAPTR         SAVE POINTER TO IT\n         TM    JCBAFL,JCBTSO       ARE WE A TSO TASK?\n         BZ    NOTCP               NO.. SO DONT LOOK\n         L     R11,8(,R9)          GET A POSSIBLE PSCB ADDR\n         C     R11,WAPSCB          ARE WE A 'CP' ?\n         BNE   NOTCP               NO.. MUST BE VIA A CALL\n         L     R11,4(,R9)          UPT ENTRY\n         ST    R11,WAUPT\n         L     R11,12(,R9)         ENVIRON. CTL TAB\n         ST    R11,WAECT\n         L     R1,0(,R9)           POINTER TO COMMAND BUFFER\n         LH    R2,0(,R1)\n         SH    R2,=H'11'           4 + SIZE('WYLBUR ')\n         LA    R1,4+7(,R1)         TEXT IS FOLLOWING 'WYLBUR '\n         B     GOTPARM             GO PROCESS PARM\n         SPACE\nNOTCP    L     R1,0(,R9)           POINTER TO PARMS\n         LH    R2,0(,R1)           GET LENGTH\n         LA    R1,2(,R1)           POINT TO TEXT\nGOTPARM  LTR   R2,R2               ANYTHING?\n         BNP   NOPARMS\n         ST    R1,CVPARM           SAVE PARM POINTER\n         STC   R2,CVPARM           AND LENGTH\n         SPACE\n* INITIALIZE THE PFCB\nNOPARMS  OFFSET R2,PFCB1\n         USING PFCB,R2\n         MVC   PFCBDCB(PFCBDSZ1),DUMMYDCB\n         MVC   PFCBPDCB(PFCBDSZ2),PDCB\n         OFFSET R3,PT1\n         ST    R3,PFCBPTST         SAVE PAGE TABLE POINTER\n         LA    R3,&PAGE0\n         ST    R3,PFCBNP           SAVE IN PFCB\n         XC    PFCBCP(4),PFCBCP    0 PAGES CURRENTLY IN USE\nDODEVTYP DEVTYPE PFCBDCB+(DCBDDNAM-IHADCB),CPWA,DEVTAB\n         LTR   R15,R15             FILE SUPPLIED?\n         BZ    TESTDASD\n*\n* THE FOLLOWING CODE WAS ADDED BY BOB WENZEL OF ITEL\n* IT WILL TRY TO ALLOC DATASET WYLPAGE0 TO FILE PAGE0\n*\n         L     R15,CVIOWA          ADDRESS OF DAIR ROUTINE\n         LA    R1,WAUPT-WDIOWA(R15)  ADDR OF DAPL\n         LA    R14,ALLOCATE           PARAMETER LIST\n         ST    R14,WADAIR-WDIOWA(R15)\n         L     R15,CVDAIR          ADDRESS OF DAIR ROUTINE\n         BALR  R14,R15             CALL DAIR\n         LTR   15,15               EVERYTHING OK?\n         BZ    DODEVTYP     EVERYTHING IS NOT OK\n*\n*              DAIR ERROR DETERMINATION SECTION\n*\nDAIRERR  EQU   *       DAIR ERROR RETURN\n         CH    R15,=H'12'\n         BNE   GOWYL\nINUSEDSN L     R2,16(R1)              DAPL\n         LH    R3,4(R2)               DAPBDARC\n         CH    R3,=X'0210'            DSN IN USE ERROR\n         BNE   DARCERR                NO, SHOW DARC ERROR CODE\n*\n         TPUT  DSNINUSE,50            DSN IN USE MESSAGE\n         B     NOPAGE0\nDSNINUSE DC    CL50'PREFIXED WYLPAGE0 IS IN USE BY ANOTHER USER OR JOB'\n*\nDARCERR  ABEND 111,DUMP\n*        L     R2,16(R1)\n*        LH    R3,4(R2)\n*\n         DS    0D\nALLOCATE DS    0CL84\nALOCCD   DC    X'0008'\n         DC    H'0'\n         DC    H'0'\n         DC    H'0'\nALOCDSN  DC    A(PAGE0LNG)\nALOCDDN  DC    CL8'PAGE0'\n         DC    CL8' '\nALOCSER  DC    CL8' '\n         DC    F'0'\n         DC    F'0'\n         DC    F'0'\n         DC    F'0'\nALOCMNM  DC    CL8' '\n         DC    CL8' '\nALOCDPS1 DC    X'01'    OLD\nALOCDPS2 DC    X'08'    KEEP\nALOCDPS3 DC    X'08'    KEEP\nALOCCTL  DC    X'20'    ADD USER ID\n         DC    F'0'\n         DC    2F'0'\n*\nPAGE0LNG DC    H'8',CL8'WYLPAGE0'\nGOWYL    DS    0H\n*\n* END OF CODE ADDED BY BOB WENZEL OF ITEL\n*\n*             ALLOCATE  CODE FOR WYLRDR OR WYLPRINT\n         L     R15,CVIOWA          ADDRESS OF DAIR ROUTINE\n         LA    R1,WAUPT-WDIOWA(R15)  ADDR OF DAPL\n         LA    R14,DAIRPAGE           PARAMETER LIST\n         ST    R14,WADAIR-WDIOWA(R15)\n         L     R15,CVDAIR          ADDRESS OF DAIR ROUTINE\n         BALR  R14,R15             CALL DAIR\n         LTR   15,15               INTRDR AVAILABLE??\n         BNZ   NOPAGE0                   NO PAGE\n         B     DODEVTYP            DO DEVTYP AGAIN\nTESTDASD CLI   CPWA+2,X'20'        DIRECT ACCESS?\n         BNE   NODASD              NOPE\n         LA    R6,CPWA             SET BASE\n         USING DVTAREA,R6              FOR DEVTABLE\n         LA    R0,CPSIZE           SET R0 TO BLKSIZE ALSO\n         LR    R3,R0               SET R3 ALSO\n         MH    R3,DVTTOL           MULT BY TOLERANCE\n         SRA   R3,9                DIVIDE BY 512\n         SR    R1,R1               SET FOR IC\n         IC    R1,DVTKEYO          GET KEY OVERHEAD\n         SR    R0,R1               ADJUST BLKSIZES SINCE NO KEYS\n         SR    R3,R1\n         TM    DVTFLAG,DVTFOHD     IS IT HALF WORD OVERHEAD\n         BO    CALCTRK1            BR YES\n         IC    R1,DVTBLKO          GET NORMAL BLOCK OVERHEAD\n         AR    R3,R1               ADJUST NORMAL VALUE\n         IC    R1,DVTLBLKO         GET LAST BLOCK OVERHEAD\n         AR    R0,R1               ADJUST LAST BLOCK VALUE\n         B     CALCTRK2            NOW GO ON\n         SPACE\nCALCTRK1 LH    R1,DVTBLKO          GET BLOCK OVERHEAD\n         AR    R0,R1               ADJUST BOTH FOR\n         AR    R3,R1                   BLOCK OVERHEAD\nCALCTRK2 LH    R1,DVTTRKSZ         GET TRACK SIZE\n         SR    R1,R0               ADJUST FOR LAST BLOCK\n         AR    R1,R3               ADD TO INCR COUNT BY 1\n         SR    R0,R0               SET FOR DIVIDE\n         DR    R0,R3               CALCULATE VALUE IN R1\n         ST    R1,PFCBRPT          SAVE NUMBER OF RECORDS/TRK\n         DROP  R6\n         SPACE\n* OPEN THE FILE\n         LA    R3,PFCBDCB          GET DCB ADDR\n         LA    R4,PFCBPDCB         GET SECOND DCB\n         L     R1,CVPSYNAD         GET SYNAD ADDRESS\n         ST    R1,56(,R4)          SAVE SYNAD ADDRESS\n         L     R1,JCBWAPTR         POINT TO A WORK AREA FOR OPEN\n         OI    4(R1),X'80'     SET LAST DCB BIT\n         OPEN  ((3),(OUTPUT),(4),(OUTPUT)),MF=(E,(1))\n         TM    PFCBDCB+(DCBOFLGS-IHADCB),X'10'  OPEN OK?\n         BZ    BADOPEN\n         TM    PFCBPDCB+(DCBOFLGS-IHADCB),X'10'  OPEN OK?\n         BZ    BADOPEN\n         L     R4,PFCBDCB+(DCBDEBAD-IHADCB)  DEB ADDR\n         USING DEBBASIC,R4\n         SR    R5,R5               CLEAR WORK REG\n         IC    R5,DEBNMEXT         NUMBER OF EXTENTS\n         LA    R4,DEBDDEP          DEVICE DEPENDENT PORTION\n         USING DEBDDEP,R4\n         SR    R1,R1\nCOUNTRKS AH    R1,DEBNMTRK         NUMBER OF TRKS IN THIS EXTENT\n         LA    R4,DEBDSZDA(,R4)    SKIP EXTENT AREA\n         BCT   R5,COUNTRKS         ADD IN REMNDR\n         M     R0,PFCBRPT          TIMES RECORDS/TRK\n         CL    R1,PFCBNP           COMPARE AGAINST MAX DEFINED\n         BNH   *+8                 BR IF OK\n         L     R1,PFCBNP\n         ST    R1,PFCBNP           SAVE MAX\n         LR    R4,R1\n         AL    R1,PFCBPTST         END OF PAGE TABLE\n         BCTR  R1,R0               POINT TO LAST BYTE IN TABLE\n         ST    R1,PFCBPTND\n         L     R3,PFCBNP           LENGTH\n         L     R2,PFCBPTST         BEGINING OF TABLE\n         LA    R5,254              FILL CHAR\n         SLL   R5,24               MOVE TO HIGH ORDER BYTE\n         LR    R4,R2               SAME AREA\n         MVCL  R2,R4               OVERLAY WITH FF\nSETCP    DS    0H\n         L     R3,CVFPFCB          POINT TO PFCB\n         USING PFCB,R3\n         L     R2,CVFPAGE          POINT TO A PCB\n         USING PCB,R2\n         LA    R13,CPWA            SAVE AREA\n         SR    R1,R1               TO GET PAGE 0\n         ST    R3,PCBPFCB\n         MVI   PCBRWCCW,PIOREAD    TO READ IT\n         CVCALL PIO                GET 1ST PAGE\n         TM    JCBBFL,JCBBFPER     IO ERROR?\n         BO    NORMAL              YEP, NO REVCOVERY\n         LA    R4,PCBBUF           POINT TO READ MATERIAL\n         CLC   0(8,R4),=CL8'SUSPEND' IS IT A SUSPENDED SESSION\n         BE    CHKUSER             CHK IF SAME USER\n         CLC   0(8,R4),=CL8'RECOVER' IS IT CRASHED SESSION?\n         BNE   NORMAL\n         MVI   CPCMNM,C'Z'         REMEMBER IT IS RECOVERED.\nCHKUSER  ST    R6,CVSPARES        SAVE PAST COMPARE\n         SR    R6,R6\n         IC    R6,CVUSRFLD        PICK UP ID LENGTH\n         CLC   CPUSER(0),274(R4)  IS THIS THE ONE??             JJG001\n         EX    R6,*-6             EXEC ABOVE COMPARE\n         L     R6,CVSPARES\n         BNE   NORMAL              NOPE\n         MVI   0(R4),X'00'         MAKE IT NO SUSPEND\n         MVI   PCBRWCCW,PIOWRITE   TO WRITE IT BACK\n         CVCALL PIO                GO WRITE IT BACK\n         TM    JCBBFL,JCBBFPER     IO ERROR?\n         BO    NORMAL\n         MVC   PFCBCP(4),8(R4)     CURRENT PAGES\n         MVC   CPRSCNVL(4),12(R4)  RESCAN ESC & SKIP\n         MVC   CPEXLNET(4),16(R4)\n         MVC   CVEXTRAP(12),20(R4)\n         LA    R4,32(,R4)\n         L     R5,RTBWAPTR\n         MVC   RTBSTART(RTBSIZE-RTBNTEXT),0(R4)\n         ST    R5,RTBWAPTR\n         LA    R4,RTBSIZE-RTBNTEXT(,R4)\n         MVC   CPGLDL(CPRCVSZ1),0(R4)\n         LA    R4,CPRCVSZ1(,R4)\n         MVC   CPDRPT(CPRCVSZ2),0(R4)\n         LA    R4,CPRCVSZ2(,R4)\n         LR    R0,R2                         SAVE ACROSS MVCL\n         LR    R1,R3                         SAVE ACROSS MVCL\n         LA    R2,CPDREC                     SET FOR MVCL\n         LA    R3,CPRCVSZ3                   LENGTH\n         LR    R14,R4                        FROM\n         LR    R15,R3                        SAME LENGTH\n         MVCL  R2,R14                        MOVE IT\n*        MVC   CPDREC(CPRCVSZ3),0(R4)\n         LA    R4,CPRCVSZ3(,R4)\n         MVC   CPCHECK(4),=X'6913723F'\n         LA    R2,ROUTBLE                    SET FOR MVCL\n         LA    R3,ROUTBLEN                   LENGTH\n         LR    R14,R4                        FROM\n         LR    R15,R3                        SAME LENGTH\n         MVCL  R2,R14                        MOVE IT\n         LR    R2,R0                         RESTORE\n         LR    R3,R1                         RESTORE\n*        MVC   ROUTBLE(256),0(R4)\n*        MVC   ROUTBLE+256(ROUTBLEN-256),256(R4)\n         LA    R4,ROUTBLEN(,R4)\n         MVC   0(256,R5),0(R4)\n         LA    R4,256(,R4)\n         L     R3,CVFPFCB            POINT TO PFCB\n         L     R2,CVFPAGE            FIRST PCB\n         LA    R2,PCBSIZE(,R2)        2ND PCB\n         MVI   PCBRWCCW,PIOREAD       GO READ 2ND CP IN\n         LA    R1,1\n         ST    R3,PCBPFCB\n         CVCALL PIO\n         TM    JCBBFL,JCBBFPER        IO ERROR\n         BO    SIGHSIGH               TOO BAD\n         LR    R0,R2                  SAVE\n         LR    R1,R3                      ACROSS MVCL\n         LA    R14,PCBBUF             MOVE FROM\n         L     R2,PFCBPTST            BEGINNING OF PAGE TABLE\n         LA    R3,&PAGE0              MAX NUMBER OF PAGES\n         LR    R15,R3                 SAME LENGTH\n         MVCL  R2,R14                 MOVE IT\n         LR    R2,R0                         RESTORE\n         LR    R3,R1                         RESTORE\n         L     R5,PFCBPTST\n         CLI   CPCMNM,C'Z'            RECOVERY?\n         BNE   REWRITE\nPTLP     CLI   0(R5),INCORE\n         BNE   *+8\n         MVI   0(R5),0\n         CLI   0(R5),X'FE'\n         LA    R5,1(,R5)\n         BNE   PTLP\n         XC    RTBWC(6),RTBWC\n         SPACE\nREWRITE  LA    R5,CPAREA+CPSIZE       POINT TO AREA\n         ST    R5,PCBRWCCW\n         MVI   PCBRWCCW,PIOREAD       GO READ 2ND CP IN\n         LA    R1,2\n         CVCALL PIO\n         TM    JCBBFL,JCBBFPER        IO ERROR\n         BO    SIGHSIGH               TOO BAD\n         OFFSET R5,VCPAGE\n         ST    R5,CVCPADDR\n         ST    R5,PCBRWCCW\n         MVI   PCBRWCCW,PIOREAD       GO READ VCP IN\n         LA    R1,3\n         CVCALL PIO\n         TM    JCBBFL,JCBBFPER        IO ERROR?\n         BO    SIGHSIGH               TOO BAD\n         LA    R5,PCBBUF\n         ST    R5,PCBRWCCW\n         SPACE\n         L     R5,PFCBPTST            START OF PT\n         L     R4,PFCBRPT             # BLOCKS PER TRACK\n         SR    R1,R1                  0 TRACKS\nPTLOOP   AR    R5,R4                  START FROM TRK 1\n         LA    R1,1(,R1)              1 MORE TRACK\n         CLI   0(R5),X'FE'            A VIRGIN PAGE\n         BNE   PTLOOP\n         STH   R1,CPWK1\n         MVC   CPWK1+2,=X'0100'       1ST RECORD ON NEW TRK\n         LA    R0,CPWK1\n         LA    R1,PFCBPDCB            DCB ADDRESS\n         POINT (1),(0)\n         OI    CPGFLG,CPFDIRCH\n         CLI   CPCMNM,C'Z'         WAS IT RECOVERED?\n         BE    RECOVERD\n         SYSQS 1,0,'SUSPENDED SESSION RESTORED'\nTPUTRET  TPUT  (1),(0),WAIT,EDIT\n         B     LOADEXIT\n         SPACE\nRECOVERD TM    CPGFLG2,CPFEXEC\n         BZ    RECVNOEX\n         OI    JCBAFL,JCBAFIA      SET IDLE ATTENTION\n         XC    CVEXTRAP,CVEXTRAP   GET RID OF EXEC TRAP\nRECVNOEX SYSQS 1,0,'PREVIOUS SESSION RECOVERED SUCCESSFULLY'\n         B     TPUTRET\n         EJECT\nNORMAL   LA    R3,3                GET 3 PAGES\n         NI    JCBBFL,255-JCBBFPER TURN OF I/O ERROR FLAG\nPGETLP   SR    R1,R1               CLEAR FOR NEW PAGE\n         PGET  R1\n         TM    JCBBFL,JCBBFPER\n         BO    NOPAGES\n         LR    R5,R1               DON'T USE R1 FOR PFREE CALL\n         PFREE R5                  FREE THE PAGE WE JUST GOT\n         BCT   R3,PGETLP\n         SPACE\n* NOTE THAT THE PAGE IS JUST FREED.. NOT JUNKED\n* THAT MEANS PAGE WILL NOT BE IN CORE BUT REMAIN ALLOCATED.\n* THE PGET ROUTINE WILL WRITE OUT A TRACKFUL OF DUMMY PAGES\n* BECAUSE THE PAGE THAT WAS JUST GOTTEN WAS A BRAND NEW PAGE .\n         SPACE 3\n         MVC   CPUSERSV(8),CPUSER  FOR SAVE\n*        OI    CPGFLG,CPFVOLM      SET DEFAULT VOL FLAG    ITEL\n         OI    CPGFLG,CPFVOLM+CPFCMOFF TER & VOL FLAG      ITEL\n         OI    RTBMFL,RTBWRAP      SET WRAP AS DEFAULT\n         OI    RTBUFL,RTBUNCOL         NOCOLLECT FLAG      ITEL\n         MVC   CPVOLSV,=C'CATLG '  SET DEFAULT VOL = CATLG\n         MVC   CPCHECK(4),=X'6913723F'\n         MVC   CPGLDL(4),=F'1000'       DELTA=1.000\n         MVC   CPLNGTH(2),=H'72'        LEN=72\n         MVC   CPDREC(4),=D'0'          ZERO 1ST LINE NO.\n         MVI   CPLSTCOL,FNEGBT          SET NO COLLECT YET\n         MVI   CPCURRL,FNEGBT      SET CURRENT LINE POINTER INV\n         MVI   CPEXLINE,FNEGBT     SET EXEC LINE POINTER INV\n         MVI   CPMEMBSV,X'40'      CLEAR MEMBER\n         MVC   CPMEMBSV+1(L'CPMEMBSV-1),CPMEMBSV\n         OFFSET VCPR,VCPAGE\n         ST    VCPR,CVCPADDR\n         USING DVCP,VCPR\n         XC    VCPWVAR,VCPWVAR    ZERO LINE # VARIABLES\n         XC    VCPNVAR,VCPNVAR    ZERO INTEGER VARIABLES\n         MVC   VCPSVAR(L'SVARINIT),SVARINIT  INIT STRING VARS\n         LA    R2,24      LOOP\n         LA    R1,PVARINIT\n         LA    R6,VCPPVAR\nVCPVLOOP MVC   0(2,R6),0(R1)     MOVE PFK'S\n         MVC   2(23,R6),=CL23' ' SET DUMMY PFK'S\n         LA    R6,25(,R6)        NEXT AREA\n         LA    R1,2(,R1)         NEXT PFK DEF\n         BCT   R2,VCPVLOOP       LOOP THRU IT\n         DROP  VCPR\n         LA    0,5\n         STH   0,CPRSCNVL         INITIALIZE RESCAN LIMIT\n         OI    CPGFLG2,CPESNULL   SET ESCAPE CHARACTER NULL\n         OI    CPGFLG2,CPSKNULL   SET SKIP CHARACTER NULL\n         LA    R13,CPWA            SAVE AREA\n         MVC   CPCMSAV(L'LOGCMND),LOGCMND\n         LA    R0,L'LOGCMND-1\n         ST    R0,CPCTSAV\n         EJECT\n* LOAD IN THE PAGED ROUTINES\n         SPACE\n         LA    R10,ROUTBLE\n         USING ROUTBLE,R10\n         LA    R6,PAGTBLE-4        SET FOR START OF LOOP\n         SR    R5,R5               CLEAR REG FOR PFREE\n         USING PCB,R5\n         SPACE\n* LOOP THROUGH PAGTBLE AND LOAD EACH OVERLAY SEGMENT\n* AFTER LOADING THE SEGMENT, GET A PAGE FROM THE ACTIVE\n* FILE AND WRITE OUT THE OVERLAY SEGMENT.  THEN FILL IN\n* ROUTBLE FOR ANY ROUTINES FOUND.\n         SPACE\nLOADLOOP LA    R6,4(,R6)           STEP UP TO NEXT ENTRY\n         C     R6,=A(PAGTBLED)     END OF PAGETABLE?\n         BNL   LOADDONE            YES..GO FINISH\n         L     R1,0(,R6)           LOAD VCON\n         LTR   R1,R1               DOES IT EXIST?\n         BZ    LOADLOOP            NO..GO ON TO NEXT PAGE\n         LA    R0,1                SET R0 FOR SEGWT\n         SVC   37                  GO GET EM\n         PGET  R5                  GET A PAGE\n         BZ    NOPAGES\n         STH   R0,PCBPN            SAVE PAGE NUMBER IN PCB\n         LR    R4,R0               PRESERVE PAGE NUMBER\n         L     R11,=A(P001)\n         LH    R1,0(,R11)          GET ADDR OF INIT CODE\n         BAL   R14,0(R11,R1)       GO DO INIT CODE\n         STM   R2,R5,CVSPARES      TEMP SAVE\n         LR    R4,R11              SET R2 TO MOVE CODE\n         LR    R2,R5               SET R1 TO BUFFER ADDRESS\n         LA    R3,CPSIZE\n         LA    R5,CPSIZE           MOVE-A-CHUNK\n         MVCL  R2,R4\n         LM    R2,R5,CVSPARES      RESTORE REGS\n         PMARK R5                  MARK THE BUFFER\n         LA    R11,2(,R11)         SET R11 TO FIRST TABLE ENTRY\nLOADLP2  LH    R1,0(,R11)           GET NEXT ENTRY\n         LTR   R1,R1               IS THIS END OR DEFAULT\n         BM    LOADLP5             BR IF EITHER\n         C     R1,=A(ROUTBLEN)     CHECK THAT ITS IN RANGE\n         BL    LOADLP3             BR IF OK\n         WTO   '**WYLTSO** INCOMPATIBLE PAGED CODE..REASSEMBLE IT'\n         B     RETURN16\n*\nLOADLP3  STH   R4,ROUTBLE(R1)      PUT PAGE NO. IN ROUTBLE\n         LH    R0,2(,R11)           GET DISPLACEMENT TO START\n         STH   R0,ROUTBLE+2(R1)    PUT IT IN ROUTBLE\nLOADLP4  LA    R11,4(,R11)           STEP TO NEXT ENTRY\n         B     LOADLP2             GO CHECK THIS ENTRY\n*\nLOADLP5  CH    R1,=H'-1'   IS THIS DEFAULT ROUTINE FOR MISSING\n         BNE   LOADLOOP           NO, GO DO NEXT OVERLAY\n         STH   R4,LOADEFLT         YES, SAVE PAGE NUMBER\n         MVC   LOADEFLT+2(2),2(R11)   AND ALSO DISPLACEMENT\n         B     LOADLP4             GO DO NEXT ON THIS PAGE\n         DROP  R10\nLOADDONE PFREE R5                  FREE THE LAST GOTTEN PCB\n         CLC   LOADEFLT,=A(0)      IS THERE A DEFAULT MISSING ROUTINE\n         BE    LOADEXIT            NO, RETURN\n         L     R2,=A(ROUTBLEN)     LOAD LENGTH OF ROUTBLE\n         AR    R2,R10              NOW POINT TO END OF TABLE\nLOADEFLP CR    R10,R2              ARE WE DONE\n         BNL   LOADEXIT            BR YES\n         CLC   0(4,R10),=A(0)      WAS THIS ENTRY INITIALIZED\n         BNE   *+10                YES, DON'T PUT IN DEFAULT\n         MVC   0(4,R10),LOADEFLT   NO, SET ENTRY TO DEFAULT\n         LA    R10,4(,R10)         STEP TO NEXT ENTRY\n         B     LOADEFLP            GO DO IT\n         SPACE\nLOADEXIT DELETE EP=IEWSZOVR        DELETE REMDR\n         SPACE\n* INITIALIZE RECOVERY IOB AND CCW'S TO WRITE OUT SNAPSHOT\n         SPACE\n         L     R4,CVPIOB           GET RECOVERY IOB ADDRESS\n         USING PIOB,R4\n         MVI   PIOBFLG1,X'42'      COMMAND CHAINING\n         LA    R1,PECB             ECB ADDRESS\n         ST    R1,PIOBECB-1\n         LA    R1,PCCWS            START OF CCWS\n         ST    R1,PIOBCCW-1\n         L     R1,CVFPFCB          POINT TO THE PFCB\n         LA    R1,PFCBDCB-PFCBSTRT(,R1) DCB ADDRESS\n         ST    R1,PIOBDCB-1\n         L     R1,DCBDEBAD-IHADCB(,R1) POINT TO DEB\n         LR    R3,R1               REMEMBER DEB ADDRESS\n         LR    R6,R12              REMEMBER CP ADDRESS\n         L     R15,16              CVT ADDRESS\n         LA    R2,PSEEK1           RESULT ADDRESS OF CONV\n         L     R15,28(,R15)        TTR CONVERSION ROUTINE\n         L     R0,=X'00000100'     1ST RECORD, 1ST TRACK\n         LR    R5,R15              REMEMBER TTR CONV ROUTINE\n         BALR  R14,R15\n         LA    R2,PSEEK2           RESULT ADDRESS OF CONV\n         LR    R15,R5              TTR CONV ROUTINE\n         LR    R1,R3               DEB ADDRESS\n         L     R0,=X'00000200'     2ND RECORD\n         BALR  R14,R15\n         LA    R2,PSEEK3           RESULT ADDRESS OF CONV\n         LR    R15,R5              CONV ROUTINE ADDRESS\n         LR    R1,R3               DEB ADDRESS\n         L     R0,=X'00000300'     3RD RECORD\n         BALR  R14,R15\n        LA    R2,PSEEK4           RESULT ADDRESS OF CONV\n         LR    R15,R5              CONV ROUTINE ADDRESS\n         LR    R1,R3               DEB ADDRESS\n        L     R0,=X'00000400'     4TH RECORD\n         BALR  R14,R15\n         LR    R12,R6              RESTORE CP ADDRESS\n         LA    R13,CPWA            RESTORE SAVE AREA ADDRESS\n         LA    R2,PSEEK1+3\n         ST    R2,PCCWSID1\n         MVI   PCCWSID1,X'31'      SEARCH ID EQUAL\n         MVI   PCCWSID1+4,X'40'    COMMAND CHAINING\n         MVI   PCCWSID1+7,X'05'    LENGTH OF 5\n         LA    R2,PCCWSID1\n         ST    R2,PCCWTIC1\n         MVI   PCCWTIC1,X'08'\n         L     R2,JCBWAPTR\n         ST    R2,PCCWWRT1\n         MVI   PCCWWRT1,X'05'\n         LA    R5,PCBPSIZE\n         ST    R5,PCCWWRT1+4\n         MVI   PCCWWRT1+4,X'40'\n         LA    R2,PSEEK2+3\n         ST    R2,PCCWSID2\n         MVI   PCCWSID2,X'31'      SEARCH ID EQUAL\n         MVI   PCCWSID2+4,X'40'    COMMAND CHAINING\n         MVI   PCCWSID2+7,X'05'    LENGTH OF 5\n         LA    R2,PCCWSID2\n         ST    R2,PCCWTIC2\n         MVI   PCCWTIC2,X'08'\n         L     R2,JCBWAPTR\n         AH    R2,=AL2(CPSIZE)\n         ST    R2,PCCWWRT2\n         MVI   PCCWWRT2,X'05'\n         ST    R5,PCCWWRT2+4\n         MVI   PCCWWRT2+4,X'40'\n         LA    R2,PSEEK3+3\n         ST    R2,PCCWSID3\n         MVI   PCCWSID3,X'31'      SEARCH ID EQUAL\n         MVI   PCCWSID3+4,X'40'    COMMAND CHAINING\n         MVI   PCCWSID3+7,X'05'    LENGTH OF 5\n         LA    R2,PCCWSID3\n         ST    R2,PCCWTIC3\n         MVI   PCCWTIC3,X'08'\n         LA    R2,CPAREA+CPSIZE\n         ST    R2,PCCWWRT3\n         MVI   PCCWWRT3,X'05'\n         ST    R5,PCCWWRT3+4\n         LA    R2,PSEEK4+4\n         ST    R2,PCCWSID4\n          MVI   PCCWSID4,X'31'      SEARCH ID EQUAL\n         MVI   PCCWSID4+4,X'40'    COMMAND CHAINING\n         MVI   PCCWSID4+7,X'05'    LENGTH OF 5\n         LA    R2,PCCWSID4\n         ST    R2,PCCWTIC4\n         MVI   PCCWTIC4,X'08'\n         L     R2,CVCPADDR\n         ST    R2,PCCWWRT4\n         MVI   PCCWWRT4,X'05'\n         ST    R5,PCCWWRT4+4\n         MVC   CVPROMPT,CVPRMLIM\n         SPACE\n         L     R14,CVIOWA          WORK AREA ADDRESS\n         USING WDIOWA,R14\n         LA    R1,WASTAX           STAX PARAMETER AREA\n         XC    WASTAX(20),WASTAX   CLEAR IT\n         DROP  R14\n         L     R14,CVATNRTN        ATTENTION EXIT ADDRESS\n         STAX  (14),REPLACE=NO,DEFER=NO,USADDR=((12)),MF=(E,(1))\n         OI    JCBAFL,JCBSTAX\n         BR    R8                  RETURN TO WYLBUR\n         EJECT\n* ERROR MESSAGES:\n         SPACE\nNODASD   SYSQS 1,0,'PAGEFILE NOT ON DIRECT ACCESS DEVICE'\n         B     RETURN16                  EXIT\nSIGHSIGH SYSQS 1,0,'UNABLE TO RECOVER FROM SUSPENDED SESSION'\n         B     RETURN16\nNOPAGE0  SYSQS 1,0,'PAGEFILE NOT SUPPLIED'\n         B     RETURN16\nBADOPEN  SYSQS 1,0,'PAGEFILE CANNOT BE OPENED'\n         B     RETURN16\nNOPAGES  SYSQS 1,0,'INSUFFICIENT PAGES TO INITIALIZE'\n         SPACE\nRETURN16 TPUT  (1),(0),WAIT,BREAKIN\n         L     R13,CVRETURN\n         LM    R14,R12,12(R13)     RESTORE REGS\n         LA    R15,16\n         BR    R14                 RETURN TO CALLER\n         EJECT\n* VCON ENTRIES FOR EACH OVERLAY PAGE\n         SPACE\nPAGTBLE  DS    0F\n         DC    V(P001)\n         DC    V(P002)\n         DC    V(P003)\n         DC    V(P004)\n         DC    V(P005)\n         DC    V(P006)\n         DC    V(P007)\n         DC    V(P008)\n         DC    V(P009)\n         DC    V(P010)\n         DC    V(P011)\n         DC    V(P012)\n         DC    V(P013)\n         DC    V(P014)\n         DC    V(P015)\n         DC    V(P016)\n         DC    V(P017)\n         DC    V(P018)\n         DC    V(P019)\n         DC    V(P020)\n         DC    V(P021)\n         DC    V(P022)\n         DC    V(P023)\n         DC    V(P024)\n         DC    V(P025)\n         DC    V(P026)\n         DC    V(P027)\n         DC    V(P028)\n         DC    V(P029)\n         DC    V(P030)\n         DC    V(P031)\n         DC    V(P032)\n         DC    V(P033)\n         DC    V(P034)\n         DC    V(P035)\n         DC    V(P036)\n         DC    V(P037)\n         DC    V(P038)\n         DC    V(P039)\n         DC    V(P040)\n         DC    V(P041)\nPAGTBLED EQU   *                   END OF PAGTBLE\n         SPACE\nLOADEFLT DC    F'0'                DEFAULT ROUTINE FOR MISSING\n         SPACE\nLOGCMND  DC    C';X FRO #LOGON NOL '\n         SPACE 3\n         LTORG\n         SPACE\n         DROP  R5\n         DROP  R7\n         EJECT\n         DS    0H\nSVARINIT DS    0CL34\n         DC    H'32'\n         DC    C'0',X'00'\n         DC    C'1',X'00'\n         DC    C'2',X'00'\n         DC    C'3',X'00'\n         DC    C'4',X'00'\n         DC    C'5',X'00'\n         DC    C'6',X'00'\n         DC    C'7',X'00'\n         DC    C'8',X'00'\n         DC    C'9',X'00'\n         DC    C'A',X'00'\n         DC    C'B',X'00'\n         DC    C'C',X'00'\n         DC    C'D',X'00'\n         DC    C'E',X'00'\n         DC    C'F',X'00'\n         SPACE\nPVARINIT DS    0CL48\n         DC   X'F1',X'00'                   PFK01\n         DC   X'F2',X'00'                   PFK02\n         DC   X'F3',X'00'                   PFK04\n         DC   X'F4',X'00'                   PFK03\n         DC   X'F5',X'00'                   PFK05\n         DC   X'F6',X'00'                   PFK06\n         DC   X'F7',X'00'                   PFK07\n         DC   X'F8',X'00'                   PFK08\n         DC   X'F9',X'00'                   PFK09\n         DC   X'7A',X'00'                   PFK10\n         DC   X'7B',X'00'                   PFK11\n         DC   X'7C',X'00'                   PFK12\n         DC   X'C1',X'00'                   PFK13\n         DC   X'C2',X'00'                   PFK14\n         DC   X'C3',X'00'                   PFK15\n         DC   X'C4',X'00'                   PFK16\n         DC   X'C5',X'00'                   PFK00\n         DC   X'C6',X'00'                   PFK18\n         DC   X'C7',X'00'                   PFK00\n         DC   X'C8',X'00'                   PFK20\n         DC   X'C9',X'00'                   PFK21\n         DC   X'4A',X'00'                   PFK22\n         DC   X'4B',X'00'                   PFK23\n         DC   X'4C',X'00'                    PFK24\n          PRINT NOGEN\nDUMMYDCB DCB   DDNAME=PAGE0,MACRF=(E),DEVD=DA,DSORG=DA\n         SPACE\nPDCB     DCB   DDNAME=PAGE0,DSORG=PS,MACRF=WP,BLKSIZE=PCBPSIZE,        *\n               RECFM=F,OPTCD=C,SYNAD=0\n         PRINT GEN\n         TITLE  'DYNAMIC ALLOCATION PARMS FOR PAGE0'\nDAIRPAGE DS    0F\n         DC    X'0008'\n         DC    X'0000'\n         DC    X'00000000'\n         DC    AL4(PAGEDSN)\n         DC    CL8'PAGE0'\n         DC    CL8'SYSTS'\n         DC    CL8' '\n         DC    AL4(CPSIZE)              SIZE OF PAGE\n         DC    AL4(&PAGE0)             NUMBER OF PAGES\n         DC    F'0'\n         DC    F'0'\n         DC    CL8' '\n         DC    CL8' '\n         DC    XL3'040000'\n         DC    X'48'              BLOCK ALLOCATION/PERM ATTR\n         DC    F'0'\n         DC    CL8' '\nPAGEDSN  DC    XL2'002C',CL44' '\n         TITLE 'START OF PAGED CODE -- PAGE 1'\nP001     PAGECDE MISSING\n         WIDENT 001\n         USING CPAREA,R12\n         TITLE 'DEFAULT MISSING ROUTINE -- PAGE 1'\nPMISSING GENTER\n         TSEG  'CODE FOR ROUTINE NOT IN PAGEFILE'\n         B     CVQTYPE\n         TITLE 'END OF PAGE CODE -- PAGE 1'\n         PINIT                     DEFINE START OF INIT ROUTINE\n         PEND                      DEFINE END ON INIT CODE\n         TITLE 'CONSTANTS AND CONTROL BLOCKS'\n         COPY  WYLCONST\n         EJECT\n         COPY  VCPTSO\n         EJECT\nPCB      DSECT\n         COPY  PCBTSO\n         EJECT\nPFCB     DSECT\n         COPY  PFCBTSO\n         EJECT\nPIOB     DSECT\n         COPY  PIOB\n         EJECT\n         COMMON\n         EJECT\n         LTORG\n         ORG   ,\nFRSTPAGE DS    0D\n         PAGES &NUMPAGE\nLASTPAGE DS    0D\n         EJECT\nFRSTPFCB DS    0D\n         PAGEFILE &PAGE0           DEFINE ONE DRUM FILE\nLASTPFCB DS    0F\n         EJECT\n         PT\nVCPAGE   DS    0F\n         DS    XL(CPSIZE)         VARIABLE COMMAND PAGE\n         DS    0D\nWORKAREA DS    XL(CPSIZE*2)\nWAFORRTB DS    CL256\n         SPACE\nPCBTABLE DS    &NUMPAGE.A\n         SPACE\nCVDDLIST DS    &MAXDDS.CL8\n         SPACE\nCVCPEND  DS    0D                  ROUND OFF TO DBL-WRD\n         SPACE\nCVCPSIZE EQU   *-CPSTART\n         EJECT\nDEB      DSECT\n         COPY  DEB\n         SPACE 3\n         DCBD\n         EJECT\nWDIOWA   WDIOWA DSECT\n         SPACE\n         END\n./ ADD NAME=PAGER,SSI=00000155\nPAGR     TITLE 'WYLTSO PAGE HANDLING ROUTINES'\n* PROPERTY OF C. U. C. C. A.\n         SPACE\n         COPY  PMAC\n         GBLC  &PTRACE\n&PTRACE  SETC  'NO'\n         SPACE 3\nPAGER    CSECT\n         WIDENT 001\n         EJECT\n* PAGING SCHEME.\n         SPACE\n* A PAGE IS OBTAINED BY ISSUING A 'PGET'\n*  THIS CAN BE A REQUEST FOR AN OLD PAGE OR A NEW ONE.\n*  FOR A NEW PAGE, R0 = 0 ON INPUT\n*  FOR AN OLD PAGE, R0 = PAGE NUMBER\n*\n*  ON RETURN, R1 WILL POINT TO A PCB TO HOUSE THAT PAGE\n*  IF THE REQUEST WAS FOR AN OLD PAGE, IT WILL HAVE\n*  BEEN READ IN.\n         SPACE\n* THE BITS IN PCBFL ARE SET AS FOLLOWS.\n*\n*   PCBFMARK ==> CONTENTS OF PAGE ALTERED.. PAGE\n*                MUST BE REWRITTEN OUT BEFORE REUSIMG IT\n*   PCBOWNED ==> PAGE IS CURRENTLY IN USE.. MAY NOT BE\n*                RE-ALLOCATED UNTIL IT IS FREED.\n*\n* THE PAGE ALLOCATION SCHEME IS VERY SIMPLE.\n* FIRST CHECK THE EMPTY LIST OF PCB'S.\n* THEN THE MARKED ONES.\n*\n*  WHILE SEARCHING THE PCB'S, ANY PCB WITH THE OWNED BIT SET IS\n*  IGNORED.  LIKEWISE FOR THE PCB POINTED TO BY 'CVPGRTN' WHICH\n*  IF NONE-ZERO CONTAINS A POINTER TO THE PAGE (PCB) HOUSING\n*  THE CURRENT PAGED ROUTINE.  IF THIS PCB IS TO BE RE-ALLOCATED\n*  THE CODE MAY GET OVERLAYED AND BOMB THE WYLTSO SYSTEM.\n         SPACE\n* THE PAGES MAY BE FREED IN ONE OF TWO WAYS.\n*  A) THE PCB IS RELEASED.  THAT MEANS THAT IF IT IS MARKED\n*     THEN ITS CONTENTS MUST BE WRITTEN OUT BEFORE REUSING\n*     THE PCB.\n*  B) THE PCB AND THE PAGE ARE FREED.  IN THIS CASE THE\n*     PCB IS FIRST MARKED EMPTY THEN THE PAGE ITSELF IS\n*     FREED, SO THAT A SUBSEQUENT PAGE REQUEST CAN\n*     REALLOCATE THAT PAGE.\n*\n*  IN CASE (A) ON INPUT R1 POINTS TO PCB\n*          (B) R1 CONTAINS THE COMPLEMENT OF THE PCB PTR\n         SPACE\n* A PAGE WHICH IS NOT IN CORE MAY BE FREED BY A 'PJUNK' MACRO.\n*  ON INPUT, R0 = PAGE NUMBER OF PAGE TO BE FREED.\n*  THE INDICATED PAGE IS MARKED AVAILABLE (IN THE PAGE TABLE)\n         SPACE 3\n         AIF   ('&PTRACE' NE 'YES').NOTRC1\n*\n* TRACE TABLE ENTRIES:\n*\n* CODE MEANING              SAVED INFORMATION\n* ---- -------------------- ---------------------------\n*   1  ENTRY TO PGET        R14: RETURN ADDRESS\n*                           R0 : PAGE NUMBER TO PGET\n*                           R1 : PCB POINTER TO FREE\n*\n*   2  WRITE A MARKED PAGE  R1 : PAGE NUMBER TO WRITE\n*                           R2 : PCB ADDRESS\n*\n*   3  READ AN OLD PAGE IN  R1 : PAGE NUMBER\n*                           R2 : PCB ADDRESS\n*\n*   4  RETURN FROM PGET     R0 : PAGE NUMBER\n*                           R1 : PCB POINTER\n*\n*   5  ENTRY TO PFREE       R14: RETURN ADDRESS\n*                           R1 : PCB ADDRESS\n*\n*   6  ENTRY TO PMARK       R14: RETURN ADDRESS\n*                           R1 : PCB ADDRESS\n*\n*   7  ENTRY TO PJUNK       R14: RETURN ADDRESS\n*                           R0 : PAGE NUMBER TO PJUNK\n*\n*   8  FORMAT OUT A TRACK   R0 : CURRENT PAGE # TO PGET\n.NOTRC1  ANOP\n         EJECT\nPGET     XENTER 2,8,*\n         USING CPAREA,R12\n         AIF   ('&PTRACE' NE 'YES').NOTRC2\n         L     R6,CVTRACE          PTR TO TRACE TABLE\n         STM   R0,R1,4(R6)         SAVE REQUEST REGS\n         ST    R14,0(,R6)          RETURN ADDR\n         MVI   0(R6),X'01'         PGET ENTRY\n         LA    R6,16(,R6)          SKIP THIS ENTRY\n         C     R6,CVTREND          END OF TABLE?\n         BL    *+8\n         L     R6,CVTRSTRT         POINT TO START OF TABLE\n         ST    R6,CVTRACE          SAVE POINTER TO NEXT ENTRY\n.NOTRC2  ANOP\n         NI    JCBBFL,X'FF'-JCBPGRD CLEAR PAGE READ FLAG\n         BAL   R14,PFREE           DO A PFREE IF NEEDED\n         SPACE\n* GET A PAGE\n         LTR   R1,R0               REQUEST FOR A NEW PAGE?\n         BZ    NEWPAGE             YES.\n         SPACE\n* HE WANTS AN OLD PAGE\n* FIRST LETS CHECK IF PAGE IS IN CORE\n* IF NOT IN CORE THEN DETERMINE IN WHICH\n* PAGE FILE ITS IN (IF MORE THAN ONE PAGE FILE EXISTS)\n* THEN PROCEED TO READ IT IN\n         SPACE\nGETOLD   L     R3,CVFPFCB          PFCB POINTER\n         USING PFCB,R3\n         L     R4,PFCBPTST         START OF PAGE TABLE\n         AR    R4,R1               DISPLACE INTO TABLE\n         CLI   0(R4),INCORE        IS IT IN CORE?\n         BE    ITSHERE             YES.. IT IS\n         SPACE\n* PAGE ISNT IN CORE.. SO IT MUST BE READ IN.\n* LOCATE A USEABLE PCB\n*  IN ALL CASES, R2 POINTS TO PCB\n* NOTE THAT R4 MUST NOT BE ALTERED, SINCE BY NOW IT\n* CONTAINS A POINTER TO THE PAGE'S ENTRY IN THE PT.\n         SPACE\n         OI    JCBBFL,JCBPGRD      PAGE HAS TO BE READ IN\n         USING PCB,R2\nGETAPCB  L     R5,CVPADDRS         ADDRESS OF PCB TABLE\n         L     R2,0(,R5)           GET TOP PCB\n         MVC   0(4*&NUMPAGE-4,R5),4(R5)   TAKE PCB OUT OF TABLE\n         TM    PCBFL,PCBOWNED\n         BZ    *+6\n         DC    H'0'                ERROR.. ALL PCBS IN USE\n         TM    PCBFL,PCBFMARK      IS IT MARKED?\n         BZ    REUSE               WE CAN REUSE WITH OUT REWRITE\n         SPACE\n* THE PCB IS MARKED, IE., IT HAS TO BE REWRITTEN\n* BACK TO THE PAGEFILE BEFORE IT CAN BE REUSED\n         MVI   PCBRWCCW,PIOWRITE   MOVE IN WRITE OPCODE\n         LR    R5,R1               PRESERVE # OF WANTED PAGE\n         LH    R1,PCBPN            PAGE # OF PAGE IN PCB\n         NI    PCBFL,X'FF'-PCBFMARK      TURN BIT OFF\n         AIF   ('&PTRACE' NE 'YES').NOTRC3\n         L     R14,CVTRACE         ENTRY FOR NEXT TRACE\n         STM   R1,R2,0(R14)        SAVE PARM REGS\n         MVI   0(R14),X'02'        WRITE ID\n         LA    R14,16(,R14)        NEXT SLOT\n         C     R14,CVTREND         END OF TABLE?\n         BL    *+8                 NO\n         L     R14,CVTRSTRT        WRAP AROUND\n         ST    R14,CVTRACE         NEXT AVAILABLE SLOT\n.NOTRC3  ANOP\n* RECALL THAT R2 POINTS TO PCB\n         BAL   R14,PAGEIO          WRITE OUT THE PAGE\n         LR    R1,R5               RESTORE WANTED PAGE#\nREUSE    L     R5,PCBPT            POINTER TO PAGE ENTRY\n         LTR   R5,R5               ANYTHING?\n         BZ    *+8                 NO.. WAS AN EMPTY PAGE\n         MVI   0(R5),X'00'         MARK AS NXO LONGER IN CORE\n         SPACE\n* AT THIS POINT:  R2 --> PCB (TO HOLD NEW PAGE)\n*                 R3 --> PFCB\n*                 R4 --> PAGETABLE ENTRY FOR NEW PAGE\n         SPACE\n         ST    R4,PCBPT            SAVE PTR TO PAGETABLE ENTRY\n         ST    R3,PCBPFCB          PTR TO PFCB\n         MVI   0(R4),INCORE        MARK PAGE AS IN CORE\n         STH   R1,PCBPN            SAVE PAGE ID\n         TM    JCBBFL,JCBPGRD      DO WE HAVE TO READ PAGE IN?\n         BZ    SETR1               NO.. WAS A REQUEST FOR A NEW PAGE\n* NOW SET UP TO ACTUALLY READ PAGE IN\n         MVI   PCBRWCCW,PIOREAD    SET READ OPCODE\n         AIF   ('&PTRACE' NE 'YES').NOTRC4\n         L     R14,CVTRACE         TRACE TABLE CURRENT ENTRY\n         STM   R1,R2,0(R14)        SAVE REGS\n         MVI   0(R14),X'03'        READ  PAGE CODE\n         LA    R14,16(,R14)\n         C     R14,CVTREND\n         BL    *+8\n         L     R14,CVTRSTRT\n         ST    R14,CVTRACE\n.NOTRC4  ANOP\n         BAL   R14,PAGEIO          READ IN THE PAGE\nSETR1    LR    R1,R2               PAGE ADDRESS IN CORE\n         OI    PCBFL,PCBOWNED      PAGE IN USE\n         LH    R0,PCBPN            SET PAGE #\n         L     R3,CVPADDRS         ADDRESS OF PCB TABLE\n         ST    R1,4*&NUMPAGE-4(,R3) SAVE AT END OF TABLE\n         SPACE\nPDONE    EQU   *\n         AIF   ('&PTRACE' NE 'YES').NOTRC5\n         L     R14,CVTRACE         TRACE TABLE CURRENT ENTRY\n         STM   R0,R1,0(R14)        SAVE REGS\n         MVI   0(R14),X'04'        PGET RETURN CODE\n         LA    R14,16(,R14)\n         C     R14,CVTREND\n         BL    *+8\n         L     R14,CVTRSTRT\n         ST    R14,CVTRACE\n.NOTRC5  ANOP\n         XEXIT 2,8                 RETURN TO CALLER\n         EJECT\n* USER WANTS A BRAND NEW PAGE\n         SPACE\nNEWPAGE  L     R3,CVFPFCB          PTR TO FIRST PFCB\n         USING PFCB,R3\nLOOP2    L     R4,PFCBCP           CURRENT # OF PGS IN USE\n         C     R4,PFCBNP           COMPARE AGAINS TOTAL AVAIL\n         BL    GOTCHA\n         LA    R3,PFCBSIZE(,R3)    NEXT PFCB\n         C     R3,CVLPFCB          LAST PFCB?\n         BL    LOOP2               KEEP LOOKING\n         SPACE\n* WE'RE OUT OF PAGES\nNOPAGES  SR    R1,R1               CLEAR PAGE PTR\n         SR    R0,R0               NO PAGE AVAIL\n         B     PDONE               EXIT\n         SPACE\n* WE HAVE AN AVAILABLE PAGE... SO LOOK\n* FOR A PCB TO PUT IT IN\nGOTCHA   NI    JCBBFL,X'FF'-JCBPGRD  NO PAGE READ NEEDED\n         LA    R4,1(,R4)           INCR # OF PAGES IN USE\n         ST    R4,PFCBCP\n         SPACE\n* STEP THROUGH THIS PAGETABLE TO FIND AN EMPTY SLOT\n         L     R4,PFCBPTST         START OF TABLE\n         L     R5,PFCBPTND         END OF TABLE\nLOOP4    TM    0(R4),X'FE'         AVAILABLE? (EMPTY OR VIRGIN)\n         BO    SETPAGE             YES\n         LA    R4,1(,R4)           INCR\n         CR    R4,R5               END YET?\n         BNH   LOOP4               NO.. KEEP LOOKING\n         SPACE\n* IF WE GET HERE WE LOSE\n         DIE   HERE COMES ANOTHER DUMP\n         SPACE\nSETPAGE  LR    R1,R4\n         S     R1,PFCBPTST         OFFSET FORM START OF TABLE\n         CLI   0(R4),X'FF'         IS IT AN OLD FREE PAGE\n         BE    GETAPCB             YES... REUSE\n         SPACE\n* THE PAGE WE WANT TO GIVE IS A BRAND NEW PAGE. FIRST WE HAVE\n* TO FORMAT THE VIRGIN TERRITORY.  TO DO THIS EXECUTE THE\n* FOLLOWING CODE WHICH WILL WRITE OUT A TRACKFULL OF PAGES...\n* A BAD TRICK BUT GETS AROUND THE PROBLEM OF WYLFMT.\n         SPACE\n         BAL   R14,WPAGES          GO WRITE A TRACK.\n         TM    JCBBFL,JCBBFPER     I/O ERROR?\n         BO    NOPAGES\n         B     GETAPCB             GO ON\n         DROP  R3\n         EJECT\n* THE PAGE IS IN CORE.. SO FIND ITS ADDRESS\nITSHERE  L     R2,CVFPAGE          POINTER TO FIRST PAGE\n         LA    R0,&NUMPAGE\n         USING PCB,R2\nLOOP3    CH    R1,PCBPN            IS THIS THE PAGE?\n         BE    REMOVE              YES... REMOVE FROM Q\n         LA    R2,PCBSIZE(,R2)     NEXT PCB\n         BCT   R0,LOOP3            KEEP LOOKING\n* ITS BAD NEWS IF WE GET HERE\n         DIE   ,\nREMOVE   BAL   R14,REMOVEQ\n         B     SETR1               GO ON\n         EJECT\n* WRITE A TRACKFULL OF PAGES.\n* AT INPUT R3 POINTS TO A PFCB AND R4 POINTS TO AN ENTRY\n* IN THE PAGE TABLE ASSOCIATED WITH THIS PFCB.\n         SPACE\n         USING PFCB,R3\nWPAGES   XENTER 0,15,*\n         LR    R9,R13          SAVE AREA FOR WRITE RETURN CODE\n         LA    R13,4(,R13)     UPDATE THIS\n         L     R5,PFCBRPT          GET RECORDS PER TRACK.\n         L     R2,CVFPAGE          POINT TO THE FIRST PAGE.\n         LA    R10,PFCBPDCB        POINT TO THE WRITE DCB\n         AIF   ('&PTRACE' NE 'YES').NOTRC8\n         L     R14,CVTRACE\n         ST    R1,0(,R14)\n         MVI   0(R14),X'08'\n         LA    R14,16(,R14)\n         C     R14,CVTREND\n         BL    *+8\n         L     R14,CVTRSTRT\n         ST    R14,CVTRACE\n.NOTRC8  ANOP\nWLOOP    LA    R6,5                RETRY ONLY 5 TIMES\nWRITE    WRITE PFCBDECB,SF,(10),(2),'S',MF=E\n         STC   15,0(,R9)           KEEP RETURN CODE.\n         CHECK PFCBDECB,ALL\n         TM    JCBBFL,JCBBFPER     FROM SYNAD ROUTINE?\n         BO    WEXIT               IF SO NO MORE WRITES.\n         CLI   0(R9),X'0C'         NEED TO BE REWRITTEN?\n         BNE   WRITEOK             IF YES ISSUE WRITE AGAIN.\n         BCT   R5,WRITE\n         OI    JCBBFL,JCBBFPER     INDICATE THAT'S IT.\n         MVC   PFCBNP(4),PFCBCP    NO MORE PAGES.\n         B     WEXIT\nWRITEOK  OI    0(R4),X'FF'         INDICATE PAGE IS NO VIRGIN\n         LA    R4,1(,R4)           INCREMENT PT ENTRY\n         BCT   R5,WLOOP            DO PFCBRPT TIMES.\nWEXIT    XEXIT 0,15\n         DROP  R3\n         EJECT\n* ROUTINE TO HANDLE PAGE I/O\n         SPACE\n         USING PFCB,R3\n         USING PCB,R2\nPAGEIO   XENTER 0,15,*\n         L     R3,PCBPFCB          POINTER TO PFCB\n         SR    R0,R0               COMPUTE TTRN\n         D     R0,PFCBRPT\n         AL    R0,=F'1'\n         LA    R5,PCBCCWS          ASSUME NO RPS                JJG\n         TM    PFCBFL,PFCBFRPS     DOES FILE HAVE RPS           JJG\n         BNO   PAGNORPS            BR NO                        JJG\n         LR    R5,0                PUT RECORD NO. IN R5         JJG\n         IC    R5,PFCBSECT-1(R5)   PICK UP SECTOR VALUE         JJG\n         STC   R5,PCBSECT          SAVE IN PCB FOR SET SECTOR   JJG\n         LA    R5,PCBCCWSC         START WITH SET SECTOR CCW    JJG\nPAGNORPS STCM  R5,7,PCBCCWP        SET STARTING CCW ADDRESS     JJG\n         SLL   R0,8\n         SLL   R1,16\n         OR    R0,R1\n         LA    R1,PFCBDCB          POINTER TO DCB\n         STCM  R1,7,PCBDCB         SAVE DCB ADDR IN IOB\n         LR    R5,R2               PRESERVE R2\n         L     R1,DCBDEBAD-IHADCB(,R1)  DEB ADDRESS\n         LA    R2,PCBSEEK\n         L     R15,16              CVT PTR\n         L     R15,28(,15)         CONVERSION RTN\n         BALR  R14,R15             GO CALL\n         LR    R2,R5               RESTORE PCB PTR\n         XC    PCBECB(4),PCBECB    CLEAR ECB\n         EXCP  PCBIOB              READ IN PAGE\n         WAIT  ECB=PCBECB          WAIT FOR I/O TO COMPLETE\n         CLI   PCBECB,X'7F'        I/O OK?\n         BNE   PIOERR              I/O ERR\nIOEXIT   XEXIT 0,15\n         SPACE\n* I/O ERROR FOR THIS PAGE .. TSK TSK TSK\nPIOERR   L     R12,4*12(R8)         RESTORE REG 12\n         OI    JCBBFL,JCBBFPER\n         B     IOEXIT\n         DROP  R2\n         EJECT\n         ENTRY PFREE\nPFREE    LTR   R1,R1               ANY PAGE TO FREE?\n         BZR   R14                 NO.. IMMED RETURN\n         XENTER 0,8,*\n         AIF   ('&PTRACE' NE 'YES').NOTRC9\n         L     R6,CVTRACE          TRACE TABLE CURRENT ENTRY\n         ST    R14,0(,R6)          SAVE REGS\n         ST    R1,4(,R6)\n         MVI   0(R6),X'05'         PFREE PAGE CODE\n         LA    R6,16(,R6)\n         C     R6,CVTREND\n         BL    *+8\n         L     R6,CVTRSTRT\n         ST    R6,CVTRACE\n.NOTRC9  ANOP\n         LTR   R1,R1\n         BP    FREEPCB             GO FREE THE PCB\n         LCR   R1,R1               PCB ADDR\n         SPACE\n         TESTPCB R1\n* ON INPUT R1 HAS PCB ADDR OF BUFFER TO BE FREED\n         USING PCB,R1\n         LH    R0,PCBPN            GET PAGE ID\n         L     R3,PCBPFCB          PFCB POINTER\n         L     R4,PCBPT            POINTER TO PAGET TABLE POINTER\nDOFREE   MVI   0(R4),X'FF'         MARK PAGE NOT IN USE\n         SPACE\n* JUNK THE PAGE\n         MVI   PCBFL,X'00'         FREE PCB AND ...\n         XC    PCBPT(11),PCBPT     ... JUNK THE PAGE\n         LR    R2,R1\n         BAL   R14,REMOVEQ\n         USING PFCB,R3\n         L     R4,PFCBCP           CURRENT NUMBER IN USE\n         BCTR  R4,R0               DECREMENT BY ONE\n         ST    R4,PFCBCP           SAVE UPDATED VALUE\n         L     R5,CVPADDRS         ADDRESS OF PCB TABLE\n         LA    R6,&NUMPAGE-1       # OF ENTRIES TO BE SHIFTED\n         BAL   R14,SHIFTPCB        SHIFT THE PCB ADDR BY 1\n         ST    R2,0(,R5)           SAVE ON TOP OF Q\nPFEXIT   XEXIT 0,8\n         SPACE\n         DROP  R1,R3\n         SPACE\n         USING PCB,R1\nFREEPCB  TESTPCB R1,EXIT=PFEXIT\n         NI    PCBFL,X'FF'-PCBOWNED   PCB NOT IN USE\n         LR    R2,R1\n         BAL   R14,REMOVEQ         REMOVE FROM Q\n         BAL   R14,PADDQ           ADD IT TO Q\n         B     PFEXIT              SCRAM\n         EJECT\n         USING  PCB,R1\nPMARK    XENTER 2,8,*\n         AIF   ('&PTRACE' NE 'YES').NOTRCA\n         L     R6,CVTRACE          TRACE TABLE CURRENT ENTRY\n         ST    R14,0(,R6)          SAVE REGS\n         ST    R1,4(,R6)\n         MVI   0(R6),X'06'         PMARK PAGE CODE\n         LA    R6,16(,R6)\n         C     R6,CVTREND\n         BL    *+8\n         L     R6,CVTRSTRT\n         ST    R6,CVTRACE\n.NOTRCA  ANOP\n         TESTPCB R1\n         TM    PCBFL,PCBOWNED      MARKING AN OWNED PAGE?\n         BO    MARKIT\n         DIE   ,\nMARKIT   OI     PCBFL,PCBFMARK     MARK IT\n         LR     R2,R1\n         BAL    R14,REMOVEQ\n         BAL    R14,PADDQ          ADD IT TO Q\n         XEXIT 2,8\n         SPACE 3\n         ENTRY PNUM\n         USING PCB,R1\nPNUM     LH    R0,PCBPN            GET PAGE NUMBER\n         BR    R14                 RETURN\n         SPACE 3\nPJUNK    XENTER 2,8,*\n         AIF   ('&PTRACE' NE 'YES').NOTRCB\n         L     R6,CVTRACE          TRACE TABLE CURRENT ENTRY\n         ST    R14,0(,R6)          SAVE REGS\n         ST    R0,4(,R6)\n         MVI   0(R6),X'07'         PJUNK PAGE CODE\n         LA    R6,16(,R6)\n         C     R6,CVTREND\n         BL    *+8\n         L     R6,CVTRSTRT\n         ST    R6,CVTRACE\n.NOTRCB  ANOP\n         L     R3,CVFPFCB          PFCB POINTER\n         USING PFCB,R3\n         L     R4,PFCBPTST         START OF PAGE TABLE\n         AR    R4,R0               ENTRY FOR THE PAGE\n         CLI   0(R4),INCORE        IS IT IN A PCB?\n         BNE   AVAILIT             NO\n* ITS IN CORE SOMEPLACE.. MAKE THE PCB AVAILABLE\n         L     R2,CVFPAGE          POINT TO FIRST PAGE\n         LA    R5,&NUMPAGE\n         USING PCB,R2\nJUNKLOOP CH    R0,PCBPN\n         BE    JUNKCLR\n         LA    R2,PCBSIZE(,R2)     NEXT\n         BCT   R5,JUNKLOOP\n         DIE   ,                   SHOULD NOT GET HERE\nJUNKCLR  BAL   R14,REMOVEQ         REMOVE FROM Q\n         L     R5,CVPADDRS\n         LA    R6,&NUMPAGE-1       # OF ENTRIES 2 B SHIFTED\n         BAL   R14,SHIFTPCB\n         ST    R2,0(,R5)           PUT AT TOP OF Q\n         XC    PCBPT(11),PCBPT     CLEAR PAGE POINTER\nAVAILIT  MVI   0(R4),X'FF'         MAKE PAGE AVAIL\n         L     R4,PFCBCP           CURRENT COUNT OF PAGES\n         BCTR  R4,R0               REDUCE BY ONE\n         ST    R4,PFCBCP           UPDATE VALUE\n         XEXIT 2,8\n         EJECT\n         USING PCB,R2\nREMOVEQ  DS    0H\n         XENTER 0,8,*\n* R2 HAS ADDRESS OF PCB TO BE DELETED FROM TABLE\n         L     R5,CVPADDRS         START OF TABLE\n         LA    R6,&NUMPAGE\nRMVLOOP  C     R2,0(,R5)           IS THIS THE PCB?\n         BE    REMOVEIT            YES\n         LA    R5,4(,R5)\n         BCT   R6,RMVLOOP\n         DIE   ,                   PCB NOT FOUND\nREMOVEIT BCT   R6,*+8\n         B     RMVDONE             IT WAS LAST IN Q\n         SPACE\n         SLL   R6,2                NUMBER OF BYTES TO SHIFT\n         BCTR  R6,R0               -1 FOR EXECUTE\n         EX    R6,SHIFT\nRMVDONE  XEXIT 0,8\nSHIFT    MVC   0(0,R5),4(R5)       SHIFT TABLE UP BY ONE ENTRY\n         EJECT\nPADDQ    DS    0H\n         XENTER 0,8,*\n*\n* ADD A PCB POINTED TO BY R2 TO THE TABLE\n*\n         USING PCB,R2\n         CLC   PCBPN(2),=H'0'      EMPTY PAGE?\n         BE    ADDTOP              YES.. ADD AT THE TOP\n         TM    PCBFL,PCBOWNED      IS IT OWNED\n         BO    ADDEND              YES.. AT AT THE END\n         TM    PCBFL,PCBFMARK      MARKED?\n         BO    ADDMARK\n*\n* MUST BE A USED (BUT NOT ALTERED) BUFFER\n* SO ADD IT AFTER THE EMPTIES (IF ANY).\n*\n         L     R5,CVPADDRS         ADDRESS OF PCB TABLE\n         LA    R6,&NUMPAGE-1       # OF ENTRIES\n         DROP  R2\n         USING PCB,R4\nADDLOOP1 L     R4,0(,R5)           GET ADDRESS OF PCB\n         CLC   PCBPN(2),=H'0'      IS THIS PAGE EMPTY?\n         BNE   ADDHERE\n         LA    R5,4(,R5)           GO TO NEXT ENTRY\n         BCT   R6,ADDLOOP1\n* ALL PCBS ARE EMPTY SO ADD AT END\n         ST    R2,0(,R5)           SAVE AT END\n         B     PADDONE             EXIT\n         DROP  R4\n         USING PCB,R2\n         SPACE\nADDTOP   L     R5,CVPADDRS\n         LA    R6,&NUMPAGE-1\n         BAL   R14,SHIFTPCB\n         ST    R2,0(,R5)           SAVE AT TOP OF Q\n         B     PADDONE\n         SPACE\nADDEND   L     R5,CVPADDRS\n         ST    R2,4*&NUMPAGE-4(,R5)      SAVE AT END\n         B     PADDONE\n         SPACE\nADDMARK  L     R5,CVPADDRS         ADDRESS OF PCB TABLE\n         LA    R6,&NUMPAGE-1       # OF ENTRIES\n         DROP  R2\n         USING PCB,R4\nADDLOOP2 L     R4,0(,R5)           GET ADDRESS OF PCB\n         TM    PCBFL,PCBOWNED      IS IT OWNED?\n         BO    ADDHERE\n         LA    R5,4(,R5)           GO TO NEXT ENTRY\n         BCT   R6,ADDLOOP2\n* ALL PCBS ARE EITHER EMPTY OR MARKED.. NONE OWNED SO FAR\n         ST    R2,0(,R5)           SAVE AT END\n         B     PADDONE             EXIT\n         DROP  R4\n         SPACE\nADDHERE  BAL   R14,SHIFTPCB        SHIFT OVER BY 1 ENTRY\n         ST    R2,0(,R5)           SAVE IN MIDDLE\n         SPACE\nPADDONE  XEXIT 0,8\n         SPACE\nSHIFTPCB DS    0H\n         XENTER 0,8,*\n         SPACE\n* ON INPUT R5 POINTS TO START OF SHIFT AREA\n*          R6 CONTAINS THE # OF ENTRIES TO SHIFT BY\n         SPACE\n         LR    R4,R6               NUMBER OF ENTRIES TO SHIFT\n         BCTR  R4,0\n         SLL   R4,2                MULT BY 4\n         AR    R5,R4               POINT TO LAST ENTRY TO BE SHIFTED\n         LA    R0,4\nSHIFTL   L     R4,0(,R5)\n         ST    R4,4(,R5)           SHIFT BY ONE\n         SR    R5,R0               DECREMENT BY 4\n         BCT   R6,SHIFTL\nSHIFTED  XEXIT 0,8\n         EJECT\n         COPY  WYLCONST\n         EJECT\n         COMMON\n         EJECT\nPCB      DSECT\n         COPY  PCBTSO\n         EJECT\nPFCB     DSECT\n         COPY  PFCBTSO\n         EJECT\n         DCBD  ,\n         SPACE\n         END\n./ ADD NAME=PDIO,SSI=00000178\nPDIO     TITLE 'WYLTSO''S DISK I/O ROUTINES'\n* PROPERTY OF C. U. C. C. A.\n         SPACE 3\n         GBLA  &NCP       DEFINE GLOBAL ASSEMBLY VAR\n         GBLC    &DCEC             SWITCH FOR DCEC MODS         JEP00X\n         GBLC  &INSTALL   DEFINE INSTALLATION\n         COPY  PMAC\n&NCP     SETA  10\n&DCEC    SETC   '1'  CHANGE TO ANY OTHER NUM. TO DELETE DCEC MODJEP00X\n         AIF   ('&DCEC' EQ '1').LBLX1                           JEP00X\n&INSTALL SETC  'CUCCA'             'CUCCA' FOR MIT PROTECT\n         AGO   .LBLX2                                           JEP00X\n.LBLX1   DS    0H                                               JEP00X\n&INSTALL SETC  'DCEC'                                           JEP00X\n.LBLX2   DS    0H                                               JEP00X\n         TRACER OFF\n         AIF   ('&DCEC' NE '1').LBL01                           JEP00X\n*************                                                   JEP001\n*                                                               JEP001\n*                                                               JEP001\n* MOD JEP001                                                    JEP001\n*  IMPLEMENTED DCEC NAMING CONVENTIONS. DENOTED JEP001 66/71    JEP001\n*  MODULES AFFECTED: PDIO, PEDS, PUTB,INIT   MACROS(DSNWA,CVTSO)JEP001\n*                                                               JEP002\n*                                                               JEP002\n* MOD JEP002                                                    JEP002\n*  FIXED BUG IN SPACE OPERAND. FORCES READ TO GET LENGTH FROM   JEP002\n*  DCB.  DENOTED JEP002 IN 66/71.  JERRY E PITTENGER            JEP002\n*  MODULES AFFECTED: PDIO                                       JEP002\n*                                                               JEP011\n*                                                               JEP011\n* MOD JEP011                                                    JEP011\n*  CHANGED DEFAULT DEVICE TYPE FROM 2314 TO 3330.               JEP011\n*  DENOTED JEP011 IN 66/71. MODULES AFFECTED: PDIO              JEP011\n*                                                               JEP011\n*                                                               JEP011\n.LBL01   DS    0H                                               JEP011\n         SPACE 3\nPDIO     CSECT\n         WIDENT 001\n         XTRNS\n         SPACE 3\n*  REGISTER USAGE\n*\n* RWA MUST BE GREATER THAN 2\n         SPACE\nRWA      EQU   6                   WORK AREA DSECT/CSECT REG\nTR       EQU   4\nSR       EQU   3\nRR       EQU   2\n         SPACE\n         USING CPAREA,R12\n         TITLE 'DISK OPEN (DOPEN) ROUTINE'\n***  LINKAGE TO DISK OPEN ROUTINE AS FOLLOWS:\n*\n**  FOR USE, SAVE, COPY, AND SCR:\n*\n*        R0    INDICATES TYPE OF FILE TO BE PROCESSED\n*                0 INDICATES EDIT FILE SPECIFIED\n*                + INDICATES FIXED BLOCKED.  THE VALUE IN R0 IS\n*                  LRECL FOR USE AND SAVE.\n*                - INDICATES NOT SPECIFIED.  INFO OBTAINED FROM\n*                  DSCB FOR ALL USES AND SAVES.\n*\n**  FOR SEQUENTIAL SAVES, THE DEFAULT TYPE OF SAVE IS FORCED\n*        TO BE EDIT IF NO OPTION IS GIVEN OR LRECL=80 IF A\n*        NUMBER OPTION WAS GIVEN EVEN IF A REPLACE OPTION WAS\n*        SPECIFIED.  SEQUENTIAL SAVES CAN BE MADE THE SAME AS\n*        PARTITIONED SAVES BY DELETING THOSE LINES WITH THE\n*        IDENTIFIER *SEQ*\n*\n** FOR SAVE:\n*\n*        R15   ADDRESS OF ROUTINE TO CALCULATE SIZE OF SAVE\n*              WHENEVER SEQUENTIAL SAVES ARE DONE.\n*\n*\n**  FOR SHOW COMMANDS:\n*\n*        R15   ADDRESS OF ROUTINE TO GET PAGE.\n*\n**     FOR CATLG/UNCATLG/RECATLG COMMANDS THE FUNCTION IS\n*        SPECIFIED IN THE FLAGS SET (SEE BELOW).\n*\n***  THE ACTUAL COMMAND FUNCTION IS SPECIFIED IN THE DSNAME\n*        WORK AREA - FLAG BYTE 2 (DSNWAF2) AS FOLLOWS:\n*\n*        USE   NO FLAGS\n*        SAVE  DSNFWRT\n*        SCR   DSNFWRT+DSNFSCR\n*        COPY  SAME AS USE\n*        CATLG DSNFCAT\n*        S/DSN DSNFSHOW\n*        S/DIR DSNFSHOW+DSNFPDS\n*        S/CAT DSNFSHOW+DSNFCAT\n*\n*     THE PDS FLAG (DSNFPDS) IS SET FOR USE/SAVE/SCR/COPY IF A\n*        MEMBER OF A PDS WAS PROCESSED.\n*\n*\n***  FOLLOWING FLAGS IN COMMAND PAGE DESERVE MENTION:\n*\n*    CPFUSCAT  INDICATES CATALOG TO BE USED TO FIND VOLUME NAME\n*    CPFSCRTC  INDICATES THAT DATA SET OR MEMBER EXISTING WITH\n*              THE SAME NAME MAY BE SCRATCHED.  IF THE DATA SET\n*              OR MEMBER IS NOT FOUND, THE FLAG IS CLEARED TO\n*              SO INDICATE.\n*    CPFDSCLG  DATA SET IS TO BE CATALOGED\n*    CPFUNCLG  DATA SET IS TO BE UNCATALOGED\n*    CPFRECLG  DATA SET IS TO BE RECATALOGED\n*\n         SPACE 4\n***  EXIT FROM OPEN PASSES FOLLOWING PARAMETERS BACK TO CALLER:\n*\n*        R1    POINTS TO BUFFER IF APPROPRIATE\n*\n*        R0    CONTAINS RECORD SIZE (LRECL) FOR CALLER:\n*                = BLOCKSIZE FOR EDIT FORMAT DATA SETS;\n*                = LRECL SPECIFIED OR FOUND IN DSCB FOR NON-EDIT\n*                  DATA SETS.  + INDICATES FIXED LENGTH RECORDS,\n*                  - INDICATES VARIABLE LENGTH RECORDS.\n*\n***     R15   CONTAINS ONE OF THE FOLLOWING RETURN CODES\n*              (DEFINED BY 'RTNCODES' COPY ENTRY):\n*\n*        0     NORMAL EXECUTION - DATA SET IS OPEN AND READY OR\n*                DATA SET/MEMBER HAS BEEN SCRATCHED.\n*        4     DATA SET NOT FOUND ON VOLUME OR IN CATALOG; OR\n*              MEMBER NOT FOUND IN PDS.\n*        8     DATA SET/MEMBER WITH SAME NAME ALREADY EXISTS.\n*        12    NO SPACE FOR DATA SET/MEMBER.\n*        16    DATA SET ENQ FAILED - DATA SET IN USE.\n*        20    INVALID BLOCK SIZE - TOO LARGE FOR BUFFER.\n*        24    ILLEGAL DSNAME.\n*        28    INVALID DSORG OR RECFM - ISAM,BDAM ETC. OR VBS.\n*        32    TALO.\n*        36    REQUEST ABORTED.\n*        40    INVALID VOLUME NAME - NOT IN TIOT OR NOT VALID\n*              FOR SPECIFIED COMMAND.\n*        44    MEMBER NOT SPECIFIED OR NOT FOUND.\n*        48    NO DIRECTORY SPACE REMAINING.\n*        52    PDS SAVE SPECIFIED OTHER THAN EDIT FORMAT.\n*        80    SHOW DSNAMES/DIRECTORY/CATALOG ERROR.\n*        100   \"CATASTROPHIC\" ERROR - ERROR LOGGED ELSEWHERE.\n*                LOG ENTRIES ARE IN FORMAT I00CC WHERE\n*                I IDENTIFIES ROUTINE ISSUING ERROR AND\n*                CC IS THE RETURN CODE FROM THE ROUTINE WHICH\n*                CAUSED THE CATER IN THE FIRST PLACE.\n*\n***     R0    SOMETIMES USED TO RETURN ADDITIONAL INFORMATION\n*              IF R15 .NE. 0 AS FOLLOWS:\n*\n*       R15   R0\n*        4     LEVEL NUMBER OF LAST GOOD INDEX SEARCHED IF ERROR\n*              WAS IN LOCATE.\n*        16    VALUE INDICATES WHETHER ENQ FAILED ON DSN (0)\n*              OR ACCOUNTING PROGRAM ENQ (NOT 0)\n*        20    VALUE OF BLOCKSIZE CONSIDERED INVALID\n*\n*    CATASTROPHIC ERROR ROUTINE ID CODES ARE AS FOLLOWS:\n*        1     ERROR IN ALLOCATE SVC.\n*        2     ERROR IN OBTAIN.\n*        3     ERROR IN LOCATE.\n*        4     ERROR IN OPEN.\n*        5     ERROR IN BLDL.\n*        6     ERROR IN SCRATCH.\n*        7     ERROR IN STOW.\n*\n*** FOR CATALOG OPERATIONS R15 CONTAINS THE CODE RETURNED FROM\n* THE CATALOG FUNCTION.  HOWEVER, WHEN THE RETURN CODE IS 8,\n* THE RETRUN CODE FROM LOCATE(WHICH WAS IN R1) IS SHIFTED\n* LEFT 8 BITS AND OR'D INTO R15.\n         EJECT\n* OPEN\n         SPACE\nDOPEN    XENTER R15,R8,44\n         XTRACE DOPEN\n         L     RWA,CVIOWA          ADDRESS OF WORK AREA\n         USING WDIOWA,RWA\n         MVI   DFL,0               CLEAR WORK FLAGS\n         OI    JCBAFL,JCBAFDO          SET DS OPEN\n         MVC   DCB(DCBSZ),MODELDCB  GET BRAND NEW COPY OF DCB\n         LA    SR,EXLST            ADDR OF EXLST\n         ST    SR,DCB+DCBEXLST-IHADCB  ENTER INTO DCB\n         MVI   RRECFM,UNDEFIND         SET UNDEFINED\n         MVI   DCB+(DCBRECFM-IHADCB),UNDEFIND  SET UNDEFINED\n         MVI   DCB+DCBDSORG-IHADCB,DSORGPS   INIT TO PS ORG\n         MVC   DSNAME(44),DSNWADSN     SAVE DS NAME\n         CLI   F2,DSNFSHOW         IS IT SHOW DSNAMES?\n         BE    DCEC1               BR IF YES\n         OC    DSNAME(44),BLANKS   ALLOW NO UPLOW AT DCEC       JEP001\n         B     DCEC1               GET AROUND DC                JEP001\nBLANKS   DC    44C' '              44 BLANKS FOR ORING          JEP001\nDCEC1    EQU   *                                                JEP001\n         MVC   DSVID(6),DSNWAVOL            VOLID\n         MVC   MEMBER,DSNWAMBR              MEMBER NAME\n         MVC   FLAGS,DSNWAF1                AND DSN FLAGS\n         XC    EXLST,EXLST         CLEAR DCB EXIT ADDR\n         TM    F2,X'02'             IS IT RENAME\n         BNO   HAVEWA1              NO\n         MVC   VTOCEND+4(44),SDSNQLB  SAVE SEC DSN IN WA\n         CLI   DSNWAMBR,C' '       IS IT MEMBER\n         BE    HAVEWA1              NO\n         MVC   VTOCEND+4(44),SDSNQUB  SAVE ALIAS\nHAVEWA1  CLI   F2,DSNFSHOW         IS IT SHOW DSNAMES?\n         BE    NOCATSCH            BR IF YES\n         TM    F1,DSNFQDSN         IS IT A QUOTED DSNAME?\n         BO    DSOK                IF SO BYPASS CHAR CHECK\n         CLI   DSNAME,C' '             MUST NOT BE BLANK\n         BE    ILLDS\n         LA    SR,DSNAME               CHECK FORMAT OF DS NAME\n         LA    TR,44\n         EJECT\nDSCK     DS    0H\n         CLI   0(SR),C' '\n         BE    DSOK\n         CLI   0(SR),C'.'\n         BE    OKCH\n         CLI   0(SR),C'_'\n         BE    OKCH\n         CLI   0(SR),C'*'\n         BE    OKCH\n         CLI   0(SR),C'$'                          ITEL\n         BE    OKCH                                ITEL\n         CLI   0(SR),C'A'\n         BL    ILLDS\n         CLI   0(SR),C'I'\n         BNH   OKCH\n         CLI   0(SR),C'J'\n         BL    ILLDS\n         CLI   0(SR),C'R'\n         BNH   OKCH\n         CLI   0(SR),C'S'\n         BL    ILLDS\n         CLI   0(SR),C'Z'\n         BNH   OKCH\n         CLI   0(SR),C'0'\n         BL    ILLDS\n         CLI   0(SR),C'9'\n         BH    ILLDS\nOKCH     LA    SR,1(,SR)               NEXT CHAR\n         BCT   TR,DSCK\nDSOK     LH    SR,DSNWANL          GET LENGTH OF DSNAME\n         MVC   DSNWADSN(44),DSNAME    SAVE DATASET AFTER CHANGES\n         EJECT\n* MAIN OPEN PROCESSING\n         SPACE\n         CLI   F2,DSNFCAT          TEST CATLG FUNCTIONS\n         BE    CALLCAT             BR IF YES\n         ST    0,RECSIZE               SAVE PARMS\n         ST    15,SPACE\n         MVC   ENQDSN+2(1),ENQESU  EXCL/SYSTEM/USE\nCHKCAT   TM    F2,DSNFWRT+DSNFSCR  TEST FUNCTION\n         BNZ   NOTSHR              BR IF SAVE OR SCR\n         MVC   ENQDSN+2(1),ENQSSU  SHR/SYSTEM/USE\nNOTSHR   TM    F2,DSNFSHOW+DSNFCAT  IS IT SHOW CATLG?\n         BO    DOLOCTE             BR IF YES\n         TM    CPLFLG1,CPFUSCAT    ARE WE TO GET VOL ID FM CAT\n         BZ    NOCATSCH            BR IF NO\n         CLI   DSVID+5,X'40'       WAS LOCATE ALREADY DONE?\n         BNE   NOCATSCH            BR IF YES\nDOLOCTE  LTR   SR,SR               TEST DSNAME LENGTH\n         BZ    CNOTDSN             DON'T DO LOCATE IF NULL\n         NI    USCATL,X'7F'        TURN OFF CVOL FLAG\n         LOCATE USCATL             GO GET CATALOG ENTRY\n         LR    RR,R0               SAVE INDEX LEVEL NUMBER\n         ST    R15,RETCOD          SAVE RETURN CODE FOR SHOW CAT\n         LTR   R15,R15             TEST IF FOUND\n*        BZ    HVCATVOL            BR IF YES\n         BZ    TSTCVOLP            SEE IF CVOL\n         ST    R15,ERROR           STORE ERROR\n         CLI   ERROR+3,4           CVOL NOT MOUNTED?\n         BE    CILLVOL             YES\n         CLI   ERROR+3,12          INDEX NOT DSNAME?\n         BE    CNOTDSN             YES\n         CLI   ERROR+3,20\n         BNH   ILLCAT\nXCATER   MVI   ERROR+1,C'3'        ERROR ID\n       XCALL   CATER\n         B     ERR\n         SPACE\nCILLVOL  MVC   DSVID,CATVOLID      GET MISSING CVOL NAME\n         SPACE\nILLVOLND LA    R15,RTNBDVOL        ILL VOLUME ERROR CODE\n         B     ERR\nTSTCVOLP DS    0H\n         CLC   DSNAME(44),DSNWADSN     SAME DSN AS INPUT\n         BE    HVCATVOL                YES CAN'T BE CVOL\n         CLC   DSNAME(9),=C'SYSCTLG.V'  ALIAS POINTER\n         BNE   HVCATVOL           NO CONTINUE\n         MVC   CATVOLID(6),DSNAME+9  MOVE VOL SER\n         MVC   DSNAME(44),DSNWADSN     RESTORE DSN\n         OI    USCATL,X'80'        TURN ON CVOL FLAG\n         LA    R0,CATVOLID        POINT TO CVOL\n         ST    R0,USCATL+8        STORE IT\n         LOCATE USCATL             LOCATE IT AGAIN\n         LR    RR,R0\n         ST    R15,RETCOD          SAVE RETURN CODE FOR SHOW CAT\n         LTR   R15,R15             SEE IF OK\n         BZ    HVCATVOL            OK CONTINUE\n         CH    R15,=H'12'          IS IT OK\n         BE    CNOTDSN\n         B     CILLVOL             SEE VOL ILLEGAL\n         SPACE\nCNOTDSN  TM    F2,DSNFSHOW+DSNFCAT  IS IT SHOW CATLG?\n         BNO   ILLCAT              NO - IT'S INVALID\n         EJECT\nHVCATVOL TM    F2,DSNFSHOW+DSNFCAT  IS IT SHOW CATLG?\n         BO    CALLVTOC            BR IF YES - GO PROCESS CATLG\n         MVC   DSVID(6),CATVOL     SAVE VOLUME ID\n         MVC   DSNWAVOL,DSVID      RESET WORK AREA VOL ID\n         TM    F2,DSNFWRT+DSNFSCR  TEST FUNCTION\n         BNZ   NOCATSCH            BR IF SAVE OR SCR - NO TSEG\n         TM    CPGFLG2,CPFEXEC+CPFEXTER EXEC AND EXEC TERSE?\n         BO    NOCATSCH            YES, NO TSEG\n         CLI   CPCMSAV,C';'        LOGON EXEC FILE?\n         BE    NOCATSCH            YES, NO TSEG\n         TSEG  'VOLUME IS',,B\n         TSEG  DSVID,6,M\n         SPACE 3\nNOCATSCH L     R1,=A(DOUCBSR)\n         BALR  SR,R1\n         BNZ   ERR                 BR IF BAD VOLUME\n         MVC   DCB+DCBDDNAM-IHADCB(8),DSDD  SET DCB DDNAME\n         TM    F2,DSNFWRT+DSNFSCR  TEST FUNCTION\n         BZ    SYSENQ              BR IF NOT SAVE OR SCR\n* SCRATCH OR SAVE - CHECK FOR VALID DSNAME/VOLUME\n*                                                               JEP001\n**** FOLLOWING CODE INSERTED FOR DCEC NAMING CONVENTIONS********JEP001\n*                                                               JEP001\n         LA    R2,DSNWADSN         DOES DATA SET BELONG TO USER JEP001\n         AGO   .LBL03                                           JEP00X\n         TM    F1,DSNFMYDS         DOES DATA SET BELONG TO USER?\n         BZ    ILLDS\n.LBL03   DS    0H                                               JEP00X\n         TM    F2,DSNFSCR          IS COMMAND SCRATCH?\n         BO    SYSENQ              BR IF YES\n* SAVE ONLY PERMITTED ON CERTAIN VOLUMES\n         CLC   CVSTYPE,DSDD        IS VOLUME VALID FOR SAVE\n         BE    SYSENQ              BRANCH YES\n         CLC   CVTTYPE,DSDD        IS IT TEMPORARY VOLUME TYPE\n         BE    SYSENQ              BR IF SO\n         TM    JCBAFL,JCBSYSPR     CAN WE ALLOW IT?\n         BZ    ILLVOLND            NO.. BAD VOLUME\n         SPACE 3\nSYSENQ   CLI   F2,DSNFSHOW         IS IT SHOW DSNAMES?\n         BNE   SYSENQ2             BR IF NOT\n         SPACE\n* CALL SHOW DSNAMES/DIRECTORY\nCALLVTOC L     R14,=A(DVTOC)       SHOW DSNAMES ROUTINE\n         LR    R13,R8              RESTORE REGS\n         LM    R15,R8,4(R13)\n         BR    R14                 GO TO SHOW DSNAMES ROUTINE\n         SPACE 3\nSYSENQ2  LH    SR,DSNWANL          GET LENGTH OF DSNAME\n         MODESET KEY=ZERO         KEY ZERO FOR ENQ              JJG\n         ENQ   (SYSDSN,,,(SR)),MF=(E,ENQDSN)\n         LTR   R15,R15\n         BNZ   LOCKOUT\n         MODESET KEY=NZERO        NOT ZERO                      JJG\nNQOK     RDJFCB (DCB),MF=(E,OPENLIST)\n         OBTAIN DSCB\n         STC   R15,SCRRET          SAVE RETURN CODE FOR LATER\n         AIF   ('&INSTALL' NE 'CUCCA').CANDO\n         SPACE 3\n* CHECK PROTECTION\n         SPACE\n         L     R1,16               GET CVT POINTER\n         L     R1,CVTUSER-CVT(R1)  GET CUCCCVT\n         TM    CVTVOLS-CUCCCVT(R1),X'F0' ANY BITS ON?\n         BZ    CANDO               NO.. ALLOW ACCESS\n         LTR   R15,R15             DATASET THERE?\n         BNZ   CANDO               NO.. SO ALLOW\n         SPACE\n* DATASET EXISTS TEST\n         LA    R1,DSNAME\n         ST    R1,DBUF\n         LA    R1,DSVID\n         ST    R1,DBUF+8\n         LA    R1,DS1FMTID\n         ST    R1,DBUF+12\n         SPACE\n* DECIDE ON ACCESS TYPE\n         LA    R1,=C'R'            ASSUME INPUT\n         TM    F2,DSNFWRT+DSNFSCR+X'02'    OUTPUT?\n         BZ    *+8\n         LA    R1,=C'W'            OUTPUT\n         ST    R1,DBUF+4\n         LA    R1,DBUF\n         LA    R0,4                INQUIRY CODE\n         SVC   226                 TEST PROTECTIO\n         LTR   R0,R0               TEST RETURN CODE\n         BNZ   ACCERROR\n         SPACE\n.CANDO   ANOP\n         SPACE\nCANDO    XCALL CLRJFCB             GO CLEAN UP THE JFCB\n         SPACE\n* NOW CALCULATE CURRENT DATE AND SET CCREDT IN CASE SAVE/SCR\n         BAL   R14,TMSET           SET CCREDT TO VTOC FORM DATE\n         TM    F2,X'02'            IS IT RENAME\n         BO    RENM                YES\n         TM    F2,DSNFWRT+DSNFSCR  TEST FUNCTION\n         BM    CREATE              BR IF SAVE\n         BAL   RR,MUSTXST          GO MAKE SURE DATA SET EXISTS\n         TM    F2,DSNFSCR          TEST SCRATCH OR USE\n         BO    DELT                BR IF SCRATCH\n         B     OLD\n         EJECT\n* CREATE DATA SET\n         SPACE\n* THE FIRST THING DONE AT CREATE IS TO CALCULATE A GOOD DEFAULT\n* BLKSIZE FOR THE DEVICE BEING USED.  THE SCHEME USED IS TO\n* CALCULATE THE MAXIMUM BLKSIZE >= 3000 AND <= MXRECSZ(3520)\n* THAT CAN BE USED FOR THE DEVICE AND STILL HAVE THE SAME\n* NUMBER OF RECORDS/TRACK AS BLKSIZE=3000 GIVES.  THE NORMAL\n* SPACE CALCULATIONS HAVE BEEN SOLVED TO FIND THAT BLKSIZE.\n* DIVISOR = (#REC-1)*TOL+512\n* DIVIDEND = 512*(TRKSZ-(LBLKO-KEYO)-(#REC-1)*(BLKO-KEY0))\n         SPACE\nCREATE   LA    R0,3000             SET BLKSIZE\n         LA    R1,DVTAREA          POINT TO DEVICE TABLE\n         XCALL CALCTRK             CALCULATE RECORDS/TRACK\n         BCTR  R1,0                SUBTRACT 1 FOR FORMULA\n         LR    R15,R1              SAVE VALUE\n         MH    R1,DVTTOL           MULTIPLY BY TOLERANCE\n         AH    R1,=H'512'          ADD IN 512 TO GET DIVISOR\n         LR    R4,R1               SAVE DIVISOR FOR LATER\n         TM    DVTFLAG,DVTFOHD     IS OVERHEAD A HALFWORD\n         BO    CREDEV1             BR YES\n         SR    R2,R2               GET OVERHEAD\n         IC    R2,DVTLBLKO             FOR LAST BLOCK\n         SR    R3,R3               GET OVERHEAD\n         IC    R3,DVTBLKO              FOR OTHER BLOCKS\n         B     CREDEV2             NOW CONTINUE\n         SPACE\nCREDEV1  LH    R3,DVTBLKO          GET OVERHEAD FOR OTHER BLOCKS\n         LR    R2,R3               LAST BLOCK OVERHEAD IS SAME\nCREDEV2  SR    R0,R0               GET OVERHEAD\n         IC    R0,DVTKEYO              FOR KEY REDUCTION\n         SR    R2,R0               ADJUST BOTH\n         SR    R3,R0                   OVERHEADS SINCE NO KEYS\n         LH    R1,DVTTRKSZ         GET TRACK SIZE\n         SR    R1,R2               ADJUST FOR LAST BLOCK\n         MR    R2,R15              CALC ADJUST FOR OTHER BLOCKS\n         SR    R1,R3               ADJUST FOR REMAINING BLOCKS\n         SLA   R1,9                MULTIPLY BY 512\n         SR    R0,R0               SET R0 FOR DIVIDE\n         DR    R0,R4               CALCULATE BLKSIZE\n         CH    R1,=AL2(MXRECSZ)    IS IT WITHIN BOUNDS\n         BNH   *+8                 BR YES, OK\n         LH    R1,=AL2(MXRECSZ)    NO, LOAD MAX SIZE ALLOWED\n         ST    R1,DEVBLOCK         SAVE DEFAULT BLKSIZE\n         CLI   SCRRET,8            WAS DSCB NOT FOUND?\n         BE    CREATE2             BR IF YES - NOT FOUND\n         CLI   SCRRET,0            WAS DSCB FOUND?\n         BNE   MUSTXST             BR IF ERROR\n         TM    DS1DSORG,DSORGPO    WAS OLD DATA SET A PDS?\n         BZ    CREXI1              BR IF NO\n         BAL   RR,DSISPDS          GO CHECK FOR MEMBER\n         OI    F2,DSNFPDS          SET THIS IS PDS OPERATION\nCREXI1   L     R0,RECSIZE          GET ORIG RECORD SIZE FLAG\n         LTR   R0,R0               WAS A FORMAT GIVEN\n         BM    CREXI2              NO, GO DECIDE FROM DSCB\n         BE    CREXED              YES, IT WAS EDIT\n         SPACE\n* LRECL WAS GIVEN\nCREXLR   MVI   RRECFM,FIXBLOCK     SET FIXED BLOCKED RECFM\n         L     R15,CPNREC          GET RECORDS/BLOCK COUNT\n         LTR   R15,R15             WAS IT GIVEN\n         BNZ   CREXLR4             YES, GO USE IT\n         CH    R0,DS1LRECL         IS LRECL SAME AS SPECIFIED\n         BNE   CREXLR2             NO, USE DEFAULT BLOCKSIZE\n         CLC   DS1RECFM,RRECFM     DO RECFMS AGREE\n         BNE   CREXLR2             NO, USE DEFAULT BLOCKSIZE\n*        TM    F2,DSNFPDS          IS IT A PDS OPERATION          *SEQ*\n*        BNO   CREXLR2             NO, FORCE DEFAULT BLKSIZE      *SEQ*\nCREXLR1  LH    R15,DS1BLKL         GET BLOCKSIZE FROM DSCB\n         LTR   R15,R15             IS IT POSITIVE\n         BNP   CREXLR2             NO, USE DEFAULT BLOCKSIZE\n         CH    R15,=AL2(MXRECSZ)   IS IT WITHIN ALLOWED SIZE\n         BNH   CREXLR3             YES, USE IT\nCREXLR2  L     R15,DEVBLOCK        GET DEFAULT BLOCKSIZE\nCREXLR3  SR    R14,R14             SET FOR DIVIDE\n         DR    R14,R0              GET RECORDS/BLOCK\n         ST    R15,CPNREC          SAVE VALUE\nCREXLR4  MR    R14,R0              RECALCULATE ACTUAL BLOCKSIZE\n         ST    R0,CPLRCL           MAKE SURE CPLRCL SET\n         BAL   R14,CHKSQFLD        CHECK SEQFLD BOUNDS\n         B     CREXTST             GO TEST RESULT\n         SPACE\nCREXED   L     R15,DEVBLOCK        USE DEFAULT BLKSIZE FOR EDIT\nCREXED1  LR    R0,R15              SET R0 TO SAME SIZE\n         XC    CPLRCL,CPLRCL       MAKE SURE EDIT IS SAVED\n         B     CREXTST             NOW GO TEST RESULT\n         SPACE\nCREXI2   DS    0H\n*        TM    F2,DSNFPDS          IS IT A PDS OPERATION          *SEQ*\n*        BNO   CREXI21             NO, FORCE DEFAULTS             *SEQ*\n         TM    DS1RECFM,UNDEFIND   IS DATA SET EDIT FORMAT\n         BNO   CREXI3              BR NO TO CHECK FOR FIXED\n         TM    CPLFLG5,CPFFOPT     WAS A NUMBERED OPTION GIVEN\n         BO    CREXI22             YES, MAKE DATA SET FIXED\n         LH    R15,DS1BLKL         GET EXISTING BLOCKSIZE\n         LTR   R15,R15             IS IT POSITIVE\n         BNP   CREXED              NO, USE DEFAULT\n         CH    R15,=AL2(MXRECSZ)   IS IT WITHIN ALLOWED SIZE\n         BNH   CREXED1             YES, USE THIS BLOCKSIZE\n         B     CREXED              NO, USE DEFAULT BLOCKSIZE\n         SPACE\nCREXI21  TM    CPLFLG5,CPFFOPT     WAS A NUMBER OPTION GIVEN\n         BNO   CREXED              NO, MAKE DATA SET EDIT\nCREXI22  LA    R0,80               USE LRECL OF 80\n         B     CREXLR              GO MAKE IT FIXED\n         SPACE\nCREXI3   TM    DS1RECFM,RECFMF     IS IT FIXED RECFM\n         BNO   CREXI21             NO, MAKE EDIT UNLESS NUM OPT\n         MVI   RRECFM,FIXBLOCK     SET FIXED BLOCKED RECFM\n         LH    R0,DS1LRECL         GET LRECL VALUE\n         LTR   R0,R0               IS IT POSITIVE\n         BNP   CREXI22             NO, USE 80\n         CH    R0,=H'133'          IS IT WITHIN BOUNDS\n         BNH   CREXLR1             YES, USE IT\n         B     CREXI22             NO, USE 80\n         SPACE\nCREXTST  ST    R15,RECSIZE         SAVE BLOCKSIZE\n         ST    R0,LRECSIZE         SAVE LRECL\n         TM    F3,DSNFCHT          IS IT OK TO CHANGE TYPE\n         BO    CREXTST1            YES, GO ON\n         CLC   DS1RECFM,RRECFM     DO RECFMS AGREE\n         BNE   TYPECHNG            NO, GO ASK USER\n         CH    R0,DS1LRECL         DOES LRECL AGREE\n         BNE   TYPECHNG            NO, GO ASK USER\n         CH    R15,DS1BLKL         DOES BLKSIZE AGREE\n         BE    CREXTST1            EQUAL OK\n         BH    TYPECHNG            IF HIGH CHECK CHANGE\n         LH    R15,DS1BLKL         LOW LEAVE ALONE\nCREXTST1 STH   R15,DCB+DCBBLKSI-IHADCB PUT BLKSIZE IN DCB\n         STH   R0,DCB+DCBLRECL-IHADCB PUT LRECL IN DCB\n         TM    F2,DSNFPDS          IS THIS PDS PROCESSING\n         BO    OLDSTUP             YES, GO OPEN DATA SET\n         TM    CPLFLG2,CPFSCRTC    CAN WE SCRATCH IT?\n         BZ    EXISTS              BR IF NO\n         L     R15,RECSIZE         SET R15 TO ACTUAL BLKSIZE\n         L     R14,SPACE           GET ADDRESS OF SPACE ROUTINE\n         BALR  R14,R14             GO CALC SIZE OF SAVE\n         BZ    ABORTMS             BRANCH IF VOID RANGE\n         XC    MEMBER+4(2),MEMBER+4  MAKE SPACE ADJ. ZERO\n         BAL   RR,DELTALL          GO SCRATCH IT\n         B     CREATE3\n         SPACE 3\n* DSCB NOT FOUND - ALLOCATE SPACE\nCREATE2  TM    F1,DSNFWLIB         IS IT A WYLBUR LIBRARY?\n         BO    NOSUCH              YES - PDS NOT FOUND ON VOL\n         L     R0,RECSIZE          GET RECSIZE\n         LTR   R0,R0               DID USER SPECIFY FORMAT\n         BM    CREDITST            NO, MAKE IT EDIT IF NO NUM\n         BZ    CREATE2E            MAKE EDIT IF EDIT SPEC        C068\nCRELREC  L     R15,CPNREC          CREATE FIXED -- GET NREC\n         LTR   R15,R15             WAS IT GIVEN\n         BP    CRELREC1            YES, USE IT\n         L     R15,DEVBLOCK        NO, GET DEFAULT\n         SR    R14,R14\n         DR    R14,R0              GET RECORDS/BLOCK\n         ST    R15,CPNREC          SET NREC\nCRELREC1 MR    R14,R0              CALCULATE ACTUAL BLKSIZE\n         MVI   RRECFM,FIXBLOCK     SET FIXED-BLOCKED RECFM\n         ST    R0,CPLRCL           MAKE SURE LRECL SET\n         BAL   R14,CHKSQFLD        CHECK SEQFLD BOUNDS\n         B     CREATE2A            GO ON\n         SPACE\nCREDITST TM    CPLFLG5,CPFFOPT     WAS A NUMBERED OPTION GIVEN\n         LA    R0,80               SET R0 FOR CARD\n         BO    CRELREC             YES, GO MAKE FIXED\n         SR    R0,R0               NO, SET FOR EDIT\n         ST    R0,CPLRCL           SET CPLRCL FOR EDIT\nCREATE2E L     R15,DEVBLOCK        GET BLOCKSIZE FOR EDIT        C068\n         LR    R0,R15              ALSO USE FOR LRECL\nCREATE2A ST    R0,LRECSIZE         SAVE LRECL\n         ST    R15,RECSIZE         SAVE BLOCKSIZE\nCREATTMP XC    MEMBER+4(2),MEMBER+4  MAKE SPACE ADJ. ZERO\n         NI    CPLFLG2,255-CPFSCRTC  INDICATE SCRATCH NOT DONE\n         L     R15,RECSIZE         SET R15 TO ACTUAL BLKSIZE\n         L     R14,SPACE           GET ADDRESS OF SPACE ROUTINE\n         BALR  R14,R14             GO CALC SIZE OF SAVE\n         BZ    ABORTMS             BRANCH IF VOID RANGE\nCREATE3  L     R0,CPLRCL           GET LRECL\n         LTR   R0,R0               IS IT EDIT OR FIXED\n         BZ    SZEDIT              EDIT IF ZERO\n         SPACE\n* CALCULATE SPACE FOR FIXED BLOCK USING LINE COUNT\n         LH    R15,DSAVCNT         GET LINE COUNT\n         SR    R14,R14             SET R14 FOR DIVIDE\n         D     R14,CPNREC          GET BLOCK COUNT\n         LTR   R14,R14             IS THERE A REMAINDER\n         BZ    SZSET               NO, DON'T ADD ONE\n         LA    R15,1(,R15)         UP BLOCK COUNT BY 1\n         B     SZSET               GO FINISH UP\n         SPACE\n* GET BLOCK COUNT FOR EDIT SAVE\nSZEDIT   LH    R15,DSAVBLK         COUNT WAS CALC BY SPACE ROUT\nSZSET    ST    R15,SPACE           SAVE BLOCK COUNT\n         BAL   R14,TMSET           GET CREATE DATE IN PROPER FORM\n         MVC   JFCBDSNM,DSNAME         MOVE IN DSNAME\n         MVC   JFCBPQTY,SPACE+1        MOVE IN SPACE\n         L     R1,SPACE            GET PRIMARY SPACE\n         LA    R1,7(,R1)           CALCULATE VALUE\n         SRA   R1,3                   FOR SECONDARY SPACE\n         ST    R1,SPACE            SAVE SECONDARY SPACE\n         MVC   JFCBSQTY,SPACE+1    SET SECONDARY SPACE VALUE\n         MVC   JFCBDRLH,RECSIZE+1      MOVE IN AVG BLOCK SIZE\n         MVI   JFCBCTRI,X'40'          FLAG\n         MVC   JFCBLKSI,RECSIZE+2      MOVE IN BLOCKSIZE\n         MVC   JFCLRECL,LRECSIZE+2     MOVE IN LRECL\n         MVC   JFCRECFM,RRECFM         MOVE IN RECFM\n         MVC   JFCBCRDT,CCREDT+1       MOVE IN CREATION DATE\n         MVC   JFCBXPDT,CCREDT+1       MOVE IN EXPIRATION DATE\n         MVI   JFCDSORG,DSORGPS    MOVE IN PS DSORG\n         SPACE\n* THE RELEASE OPTION CAN BE SKIPPED BECAUSE EXACT SIZES ARE\n* NOW CALCULATED FOR BOTH EDIT AND FIXED SAVES.\n         SPACE\n* ALLOCATE SVC LINKAGE\n         OI    F3,DSNFEXP   FIX A BUG              ITEL\n         LA    0,JFCB                  POINT TO JFCB\n         LA    1,UCB                   POINT TO UCB\n         SVC   32                      ALLOCATE DATA SET\n         LTR   15,15                   WERE THERE ERRORS\n         BZ    OLDOPEN             NO, FINISH PROCESSING LIKE OLD DS\n         ST    15,ERROR                SAVE FOR CATER\n         MVI   ERROR+1,C'1'            PUT IN CODE\n         CLI   ERROR+3,4               ANALYZE ERROR\n         BE    EXISTS                  SORRY\n         CLI   ERROR+3,8               IS THERE ROOM\n         BE    NOROOM                  NO\n         CLI   ERROR+3,X'14'           IS THERE ROOM\n         BE    NOROOM                  NO\n         XCALL CATER\n         B     DEQERR\n         SPACE 3\n* CALCULATE DATE IN FORM NEEDED BY DATA SET LABEL\n         SPACE\nTMSET    TIME\n         SR    0,0\n         ST    0,CCREDT                SETUP FOR CVB\n         SLDL  0,16                    YEAR TO R0\n         SRL   1,16                    DAY BACK\n         ST    1,CCREDT+4              STORE DAY\n         SLL   1,28                    SIGN TO HIGH END\n         SLDL  0,4                     SIGN ON THE YEAR TOO\n         CVB   1,CCREDT                DAY IN BUNARY\n         ST    0,CCREDT+4              STORE YEAR FOR CVB\n         CVB   0,CCREDT                YEAR TO BINARY\n         STH   1,CCREDT+2              STORE APPROPRIATELY\n         STH   0,CCREDT\n         BR    R14                 RETURN\n         SPACE 3\n         USING WDIOWA,R3\nRENM     L     R3,CVIOWA\n         CLI   DSNWAMBR,C' '        IS THIS A PDS OPER\n         BNE   RENM2                YES\n         MVI   MEMBER,X'FF'         SET TO STD NO PDS OPR\nRENM2    BAL   RR,MUSTXST          WAS DSCB FOUND\n         CLI   SCRRET,8            FOUND\n         BE    NOSUCH              NO\n         CLI   DSNWAMBR,C' '        IS THIS A PDS OPERATION\n         BE    RENM1                NO\n         TM    DS1DSORG,DSORGPO    IS DATA SET PDS\n         BZ    ILLORG              NO\n         MVC   RRECFM,DS1RECFM     SAVE RECFM\n         B     OLDSTUP             OPEN PDS\nRENM1    L     R15,DSREN        FUNCTION\n         ST    R15,CATLST       SAVE IN CAMLIST\n         LA    R15,VTOCEND+4    GET SEC DSN\n         ST    R15,CATLST+8     SAVE IN CAMLIST\n         SR    0,0\n         RENAME CATLST\n         LTR   15,15\n         BNZ   EXISTS            DATA SET EXISTS\nCHKUN    SR    R15,R15            CLEAR RETURN CODE FROM KWR\n         XCALL RENCTG\n         MVC   DSNAME(44),DSNWADSN  RESTORE RNAME\n         B     DEQERR\nDSREN    CAMLST RENAME,0,0,0\nPREN     XCALL PRENA                 GO TO RTN\nPREN3    LA    R1,DCB\n         CVCALL DCLOSE               DO CLOSE\n         B     RET                   RETURN\n         DROP  R3\n         EJECT\n* OLD DATA SET PROCESSING\n         SPACE\nOLD      TM    F2,DSNFSHOW         IS COMMAND SHOW?\n         BO    OLDEDIT             BR IF YES - NO BLKSIZE CHK\n         LH    R0,DS1BLKL          GET BLOCK SIZE\n         CL    R0,=A(DBUFSIZE)     IS IT UNDER MAXIMUM?      MVD\n         BH    ILLBLKSZ               BR IF TOO BIG          MVD\n         L     0,RECSIZE               GET RECSIZE\n         LTR   0,0                     WAS IT SPECIFIED\n         BNM   OLDSTUP                 YES (EDIT OR LRECL)\n         SPACE\n* OTHERWISE USE THE DSCB INFORMATION\n         TM    DS1RECFM,UNDEFIND   IS IT RECFM=U?\n         BO    OLDEDIT             ASSUME EDIT FOR RECFM=U\n         TM    DS1RECFM,RECFMF     IS IT RECFM=F(X)?\n         BO    USELRECL            USE LRECL IF SO\n         TM    DS1RECFM,RECFMV     IS IT RECFM=V(X)?\n         BZ    ILLORG              ERROR IF NOT\n         TM    DS1RECFM,SPANNED    SPANNED RECORDS?\n         BO    ILLORG              BR IF YES - CAN'T HACK THEM\nUSELRECL LH    R0,DS1LRECL         GET DSCB LRECL\n         LTR   R0,R0               IS IT ZERO\n         BNZ   HAVRECSZ            BR IF NOT\nUSEBS    LH    R0,DS1BLKL          GET BLOCKSIZE\n         LTR   R0,R0               IS IT ZERO?\n         BZ    ILLBLKSZ               BR IF YES - INVALID\nHAVRECSZ TM    DS1RECFM,RECFMV     IS IT VARIABLE?\n         BZ    *+6                 BR IF NO\n         LNR   R0,R0               INDICATE VARIABLE\n         ST    R0,RECSIZE          STORE RESULT\n         B     OLDSTUP             GO ON\n         SPACE\nOLDEDIT  XC    RECSIZE,RECSIZE     INDICATE EDIT FORMAT\n         SPACE\n* ENTER HERE FROM SAVE/SCR MEMBER ALSO\nOLDSTUP  MVC   JFCBDSNM,DSNAME         MOVE IN DSNAME\n         TM    F2,DSNFSHOW+DSNFPDS  IS COMMAND SHOW DIRECTORY?\n         BO    CALLVTOC            BR IF YES\n         CLI   MEMBER,X'FF'        TO BE TREATED AS PS?\n         BE    OLDOPEN             BR IF YES\n         TM    DS1DSORG,DSORGPO    IS IT PDS?\n         BZ    OLDOPEN             BR IF NO\n         MVI   DCB+DCBDSORG-IHADCB,DSORGPO   SET DCB FOR PO\n         OI    F2,DSNFPDS          INDICATE PDS PROCESSING\n         SPACE\n* ENTER HERE FROM CREATE ROUTINE ALSO\nOLDOPEN  MVC   DCB+DCBRECFM-IHADCB(1),RRECFM  MOVE IN REQ RECFM\n         TM    JCBAFL,JCBSYSPR     PRIV'D?\n         BZ    CLRKEY\n         CLC   CPDOUB(8),=CL8' '\n         BE    CLRKEY\n         MVC   CCREDT(8),CPDOUB\n         STM   R0,R5,0(R13)\n         L     R1,=A(TAB)\n         USING TAB,R1\n         TR    CCREDT(4),TAB\n         TR    CCREDT+4(4),TAB2\n         DROP  R1\n         LA    R5,31\n         SR    R2,R2\n         SR    R3,R3\n         LA    R4,1\nLANC     LR    R0,R3\n         SR    R1,R1\n         SRDL  R0,2\n         SRL   R1,27\n         AR    R0,R1\n         ST    R0,5*4(,R13)\n         L     R0,CCREDT\n         SR    R1,R1\n         SRDL  R0,1\n         ST    R0,CCREDT\n         LR    R0,R1\n         L     R1,5*4(,R13)\n         SRL   R0,0(R1)\n         OR    R2,R0\n         BXLE  R3,R4,LANC\n         ST    R2,CCREDT\n         SR    R2,R2\n         SR    R3,R3\nLANC1    LR    R0,R3\n         SR    R1,R1\n         SRDL  R0,2\n         SRL   R1,27\n         AR    R0,R1\n         ST    R0,4*5(,R13)\n         L     R0,CCREDT+4\n         SR    R1,R1\n         SRDL  R0,1\n         ST    R0,CCREDT+4\n         LR    R0,R1\n         L     R1,4*5(,R13)\n         SRL   R0,0(R1)\n         OR    R2,R0\n         BXLE  R3,R4,LANC1\n         ST    R2,CCREDT+4\n         LM    R0,R5,0(R13)\n         B     INOROUT\n         SPACE\nCLRKEY   MVC   CCREDT(8),=CL8' '\nINOROUT  TM    F2,DSNFWRT          INPUT OR OUTPUT?\n         BO    OPENOUT             BR IF OUTPUT\n         SPACE 3\n* OPEN DATA SET FOR INPUT\n         OI    JFCBTSDM,X'08'      INHIBIT JFCB REWRITE\n         OPEN  (,INPUT),TYPE=J,MF=(E,OPENLIST)\n         B     OPEN1\n         SPACE 3\n* OPEN DATA SET FOR OUTPUT\nOPENOUT  TM    F2,X'02'            RENAME\n         BO    OPENOUT1            YES\n         TM    F3,DSNFEXP          NEED CHECK FOR EXPDT\n         BO    OPENOUT1            NO, GO DO OPEN\n         LD    0,CCREDT            SAVE KEY\n         BAL   R14,TMSET           GET TODAY'S DATE IN PROPER FMT\n         CLC   DS1EXPDT,CCREDT+1   IS DATA SET DATE PROTECTED\n         BH    EXPDATE             YES, ABORT THE OPERATION\n         STD   0,CCREDT            RESTORE KEY\nOPENOUT1 OI    JFCBTSDM,X'08'      INHIBIT JFCB REWRITE\n         OPEN  (,OUTPUT),TYPE=J,MF=(E,OPENLIST)\n         MVI   DCB+(DCBRECFM-IHADCB),UNDEFIND\nOPEN1    DS    0H\n         TM    DCB+(DCBOFLGS-IHADCB),X'10' IS IT OPENED OK\n         BZ    OPNER               NO\nOKOPN    DS    0H\n         TM    DCB+DCBDSORG-IHADCB,DSORGPO   PDS?\n         BZ    NOBLDL              BR IF NO\n         TM    F2,X'02'            RENAME\n         BO    PREN                YES\n         BLDL  DCB,BLDL\n         ST    R15,ERROR           STORE RETURN CODE\n         CLI   ERROR+3,8           WAS IT I/O ERROR\n         BE    BLDLERR             BR IF YES\n         TM    F2,DSNFWRT+DSNFSCR  TEST FUNCTION\n         BO    SCRMBR              GO SCRATCH MEMBER\n         BZ    FINDMEMB            BR IF USE\n         CLI   ERROR+3,4           WAS MEMBER FOUND?\n         BE    SVNWMBR             BR IF NOT FOUND - NORMAL\n         TM    CPLFLG2,CPFSCRTC    CAN WE SCRATCH OLD MEMBER?\n         BO    OKREPL              BR IF YES\n         LA    R14,EXISTS          MEMBER ALREADY EXISTS\n         B     BLDLERR\n         SPACE\nOKREPL   OI    DFL,DFREPL          INDICATE REPL FOR STOW\nSVNWMBR  TM    DFL,DFREPL          IS IT TO BE A REPL FUNCT?\n         BO    NOBLDL              BR IF YES - NO SPACE CHECK\n         CLI   DCB+DCBDIRCT+1-IHADCB,254-STOWSZ  CHECK ROOM\n         BL    NOBLDL              BR IF DIRECTORY SPACE LEFT\n         LA    R14,NODIRSPC        LOAD ERROR RTN ADDR\n         BH    BLDLERR             BR IF NO -- NO ROOM LEFT\n         TSEG  'LAST MEMBER',,M     WARN USER\n         B     NOBLDL\n         SPACE\nFINDMEMB CLI   ERROR+3,4           WAS MEMBER FOUND FOR USE\n         LA    R14,ILLMEMB         PRIME RETURN ADDR\n         BE    BLDLERR             BR IF NOT\n         FIND  DCB,BLDLTTR,C       FIND MEMBER\nNOBLDL   SR    15,15                   INDICATE SUCCESS\n         LA    1,DBUF                  POINT TO BUFFER\n         BAL   RR,RESETWA          GO RESET DSNWA\nRET      LR    R13,R8              RESTORE ORIG R13\n         LM    R2,R8,16(R13)       RESTORE OTHER REGS\n         L     14,0(,13)\n         LTR   15,15\n         BR    14\n         SPACE\nOPNER    XC    ERROR,ERROR\n         MVI   ERROR+1,C'4'   SET OPEN ERROR CODE\n         XCALL CATER\n         B     DEQERR\n         SPACE\nBLDLERR  LR    SR,R14              SAVE ROUTINE ADDR\n         CLOSE (,REREAD),MF=(E,OPENLIST)\n         CLI   ERROR+3,8           WAS IT AN I/O ERROR\n         BNER  SR                  BR TO PRE-DESIG RTN IF NOT\n         LA    R15,RTNDIRIO        SET I/O ERROR RETURN CODE\n         B     DEQERR\n         SPACE 3\n* RESET DSNWA IN CASE CHANGED VALUES\nRESETWA  L     0,RECSIZE               RETURN SIZE\n         MVC   DSNWAVOL,DSVID      RETURN ACTUAL VOLUME NAME\n         MVC   DSNWAMBR,MEMBER        IN CASE MEMBER CHANGED\n         MVC   DSNWAF1(L'FLAGS),F1  RESTORE FLAGS ALSO\n         BR    RR                  RETURN\n         EJECT\n* CHAIN THRU THE DSE'S TO SEE IF WE ALREADY OWN THE DATASET\n         SPACE 3\n* DELETE PROCESSING\n         SPACE\nDELT     CLI   MEMBER,X'FF'       SCRATCH ENTIRE THING ANYWAY?\n         BE    DELTALL             BR IF YES\n         TM    DS1DSORG,DSORGPO    IS IT A PDS?\n         BZ    DELTALL             BR IF NO\n         MVC   RRECFM,DS1RECFM     SAVE ACTUAL RECFM\n         B     OLDSTUP             THEN GO OPEN PDS\n         SPACE\nDELTALL  MVI   SCRRET,0                SET BEFORE DROP-THRU\n         SR    0,0                     MUST BE ZERO ON ENTRY\n         NI    SCRLST+2,255-X'10'      TAKE OVRD OFF\n         TM    F3,DSNFEXP              EXPDT SPECIFIED?\n         BZ    *+8                     NOPE\n         OI    SCRLST+2,X'10'          SAY OVRD.\n         SCRATCH SCRLST                KILL THE DATA SET\n         SR    15,15                   FIX UP CODE\n         CLI   SCRRET,0                WAS THERE AN ERROR\n         BE    CHKUNCAT            NO.  ALL OK\n         CLI   SCRRET,1                WAS DS NOT THERE\n         BE    NOSUCH              DS NOT THERE\n         CLI   SCRRET,3                EXPDT???\n         BE    EXPDATE\n         IC    15,SCRRET               GET INTO REG\n         ST    15,ERROR                SAVE FOR CATER\n         MVI   ERROR+1,C'6'            PUT IN CODE\n         XCALL CATER\n         B     DEQERR\n         SPACE\nCHKUNCAT TM    F2,DSNFSCR          SCRATCH COMMAND?\n         BZR   RR                  BR IF NO\n         TM    CPLFLG3,CPFUNCLG    WAS UNCATLG SPECIFIED?\n         BO    UNCAT               BR IF YES\n         TM    CPLFLG1,CPFUSCAT    WAS CATLG USED TO LOC VOL?\n         BZ    DEQERR              BR IF NOT\n         OI    CPLFLG3,CPFUNCLG    INDICATE UNCATLG ATTEMPTED\nUNCAT    XCALL DCATLG              GO UNCATLG\n         BZ    DEQERR              BR IF NORMAL RETURN\nDELNOCAT LA    R15,C12             CATALOG STUFF NOT DONE RC\n         B     DEQERR\n         SPACE 4\n* RETURN HERE FROM OPEN TO SCRATCH MEMBER\n         SPACE\nSCRMBR   LA    R14,ILLMEMB         LOAD IN CASE OF ERROR\n         CLI   ERROR+3,4           WAS IT FOUND?\n         BE    BLDLERR             BR IF NO\n         BAL   RR,RESETWA          GO RESET DSNWA\n         LR    SR,R0               SAVE R0 RETURN VALUE\n         LA    R1,DCB\n         LA    R0,MEMBER\n         LCR   R0,R0               FLAG DELETE FOR STOW\n         CVCALL DCLOSE             GO STOW, CLOSE, AND DEQ\n         LR    R0,SR               RESTORE R0 RETURN VALUE\n         B     RET\n         EJECT\n* CALL CATALOG FUNCTION AFTER ERROR CHECKING\n         SPACE\nCALLCAT  TM    CPLFLG3,CPFDSCLG    IS IT RECATLG OR CATLG\n         BNO   CALLCAT1            BR NO,  NO VOL CHECK NEEDED\n         L     R1,=A(DOUCBSR)\n         BALR  SR,R1\n         BZ    CALLCAT1            YES, USE DEVTYPE FOUND\n         AIF   ('&DCEC' NE '1').LBL06                           JEP00X\n         MVC   DEVCODE(4),=X'3050200B' NO, USE 3330 FOR CATLG   JEP011\n         AGO   .LBL07                                           JEP00X\n.LBL06   DS    0H                                               JEP00X\n         MVC   DEVCODE(4),=X'30C02008' NO, USE 2314 FOR CATLG\n.LBL07   DS    0H                                               JEP00X\nCALLCAT1 XCALL DCATLG              GO DO IT\n         B     ERR\n         EJECT\n* UTILITY ROUTINES\n         SPACE\nDEQERR   LR    SR,R15              SAVE RETURN CODE\n         MODESET KEY=ZERO         KEY ZERO FOR ENQ              JJG\n         DEQ   RET=HAVE,MF=(E,ENQDSN)\n         MODESET KEY=NZERO        NOT ZERO                      JJG\nDEQERR2  LR    R15,SR              RESTORE RETURN CODE\n         B     ERR\n         SPACE\nILLDS    LA    R15,RTNILDSN\n         B     ERR\n         SPACE\nTYPECHNG TM    F2,DSNFPDS          IS IT A PDS OPERATION          *SEQ*\n         BNO   CREXTST1            NO, ALLOW THE CHANGE           *SEQ*\n         LNR   R15,R12             SET R15 NEGATIVE\n         B     DEQERR\n         SPACE\nEXPDATE  LA    R15,RTNEXPDT\n         B     DEQERR              ERROR DETECTED UNDER SUBTASK\n         SPACE\nACCERROR LA    R15,RTNPROT         PROTECTION VIOLATION\n         B     DEQERR\n         SPACE\nABORTMS  LA    R15,ABRTCODE        SET REQUEST ABORTED CODE\n         B     DEQERR\n         SPACE\nILLMEMB  LA    R15,RTNBDMBR\n         B     DEQERR\n         SPACE\nNODIRSPC LA    R15,RTNDIRFL\n         B     DEQERR\n         SPACE\nNOSUCH   LA    R15,RTNNODS\n         B     DEQERR\n         SPACE\nEXISTS   LA    R15,RTNDUPDS\n         B     DEQERR\n         SPACE\nNOROOM   LA    R15,RTNNOSPC\n         B     DEQERR\n         SPACE\nILLORG   LA    R15,RTNILORG\n         B     DEQERR\n         SPACE\nLOCKOUT  LA    SR,ENQDSN           ADDR OF ENQ LIST\n         CLI   3(R15),0            IS FIRST ONE THE PROBLEM\n         BNE   *+8                 BR IF YES\n         LA    R15,12(R15)         LOAD ADDR OF SECOND\n         SR    R15,SR              OFFSET OF RESOURCE NOT GOTTEN\n         ST    R15,RECSIZE         SAVE FOR RETURN LATER\n         LA    R15,RTNINUSE        INDICATE ENQ FAILED\n         B     DEQERR     GO DEQ IN CASE ONE IN THE LIST GOTTEN\n         SPACE\nILLBLKSZ ST    R0,RECSIZE          SAVE INVALID BLOCKSIZE\n         LA    R15,RTNINVBS\n         B     DEQERR\n         SPACE\nILLCAT   ST    RR,RECSIZE          SAVE LEVEL NUMBER OF ERR\n         LA    R15,RTNNODS\n         MVC   DSVID,=C'CATLG '    IN CASE CMND IS SHOW CATLG\n         SPACE\nERR      BAL   RR,RESETWA          GO RESET DSNWA\n         NI    JCBAFL,255-JCBAFDO      SET DS CLOSED\n         B     RET\n         EJECT\n* ROUTINE TO MAKE SURE DATA SET EXISTS AND MEMBER SPEC IF REQ\n         SPACE\nMUSTXST  SR    R15,R15\n         IC    R15,SCRRET          GET RETURN CODE FROM OBTAIN\n         LTR   R15,R15\n         BZ    DSEXISTS            BR IF DSCB FOUND\n         ST    R15,ERROR\n         MVI   ERROR+1,C'2'\n         CLI   ERROR+3,8           WAS IT JUST NOT FOUND?\n         BE    NOSUCH2             BR IF YES\n         CLI   ERROR+3,4           WAS IT VOL NOT AVAIL\n         LA    R15,RTNBDVOL        BAD VOLUME\n         BE    DEQERR\n         XCALL CATER\n         B     DEQERR\n         SPACE\nNOSUCH2  DS    0H                                                  VTOC\n         CLI   F2,0                USE?                            VTOC\n         BNE   NOSUCH                                              VTOC\n         CLC   DSNAME,DSN          IS IT THE VTOC?                 VTOC\n         BNE   NOSUCH                                              VTOC\n         MVI   DS1RECFM,RECFMF     RECFM=F                         VTOC\n         MVI   DS1DSORG,X'20'      DSORG=DA                        VTOC\n         MVI   DCB+DCBKEYLE-IHADCB,44   KEYLEN=44                  VTOC\n         MVI   DCB+DCBBLKSI-IHADCB+1,96 BLKSIZE=96                 VTOC\n         LA    R15,140             KEYLEN+BLKSIZE                  VTOC\n         STH   R15,DS1LRECL                                        VTOC\n         STH   R15,DS1BLKL                                         VTOC\n         SPACE ,                                                   VTOC\nDSEXISTS CLI   MEMBER,X'FF'        IS IT TO BE TREATED AS SEQ?\n         BER   RR                  BR IF YES\n         TM    DS1DSORG,DSORGPO    IS IT A PDS?\n         BO    DSISPDS             BR IF YES\n         TM    F2,DSNFSCR          SCRATCH COMMAND?\n         BO    CHKPSMBR            IF SO DON'T CHECK FOR PS\n         TM    DS1DSORG,DSORGPS    IS IT SEQ?\n         BZ    ILLORG              BR IF NO - INVALID DSORG\nCHKPSMBR TM    F2,DSNFSHOW+DSNFPDS  IS COMMAND SHOW DIRECTORY?\n         BO    ILLORG              BR IF YES - ILLEGAL\n         BR    RR                  RETURN\n         SPACE 3\n* PARTITIONED DATA SET\n         SPACE\nDSISPDS  TM    F2,DSNFSHOW+DSNFPDS  IS COMMAND SHOW DIRECTORY?\n         BOR   RR                  BR IF YES - RETURN\n         CLI   MEMBER,0            WAS MEMBER EXPLICITLY NULL?\n         BE    ILLMEMB             BR IF YES\n         CLI   MEMBER,X'40'        WAS MEMBER SPECIFIED?\n         BNER  RR                  RETURN IF YES\n         TM    CPMEMBSV,X'BF'      IS THERE A DEFAULT MEMBER?\n         BZ    ILLMEMB             BR IF NO\n         MVC   MEMBER,CPMEMBSV     USE DEFAULT\n         BR    RR\n         SPACE 3\n* CHECK THAT SEQFLD VALUES ARE WITHIN LRECL IF NUMBERED SAVE\n*    R0 = LRECL AT ENTRY\n         SPACE\nCHKSQFLD TM    CPLFLG5,CPFUNUM     UNNUMBERED SAVE\n         BOR   R14                 YES, RETURN\n         LH    RR,CPSEQLN          GET LENGTH OF SEQFLD\n         TM    CPSEQFLD,FNEGBT     SEQ FIELD AT END OF RECORD\n         BO    CHKSQFL1            YES\n         AH    RR,CPSEQFLD         ADD START COL FOR SEQFLD\n         BCTR  RR,0                SET FOR COMPARE TO LRECL\nCHKSQFL1 CR    RR,R0               IS IT WITHIN BOUNDS\n         BNHR  R14                 NO, RETURN\n         TSEG  'LRECL ILLEGAL',,M\n         LA    R15,ABRTCODE        SET ABORT CODE\n         B     DEQERR              FINISH UP\n         TITLE 'DOPEN CONSTANTS'\n         LTORG\n         SPACE 3\n* FOLLOWING CRAP USED BECAUSE OF WAY ENQ MACRO WAS WRITTEN\nEL1      ENQ   (,,E,,SYSTEM),RET=USE,MF=L\nENQESU   EQU   EL1+2     FUNCT BYTE FOR EXCL/SYSTEM/USE\n         ORG   EL1+4\nEL2      ENQ   (,,S,,SYSTEM),RET=USE,MF=L\nENQSSU   EQU   EL2+2     FUNCT BYTE FOR SHR/SYSTEM/USE\n         ORG   EL2+4\n         SPACE 3\nSYSDSN   DC    CL8'SYSWYL'             QNAME FOR DATA SETS\nWYLQNM   DC    CL8'WYLBUR'             CONSTANT FOR ENQ\nDSRNM    DC    C'DISKSPACE'        RNAME FOR ACCOUNTING ENQ\n         SPACE\nDSORGPS  EQU   X'40'               DSORG=PS\nDSORGPO  EQU   X'02'               DSORG=PO\nUNDEFIND EQU   X'C0'               RECFM=U\nFIXBLOCK EQU   X'90'               RECFM=FB\nRECFMF   EQU   X'80'               RECFM=F\nRECFMV   EQU   X'40'               RECFM=V\nSPANNED  EQU   X'08'               RECFM=XS\n         SPACE 3\n         PRINT NOGEN\nMODELDCB DCB   DSORG=PS,EODAD=EODAD,SYNAD=SYNAD,                       *\n               MACRF=(RP,WP)\nDCBSZ    EQU   *-MODELDCB\n         PRINT GEN\n         SPACE 3\n         LTORG\n         EJECT\n* DOUCBSR ROUTINE LOOKS UP THE VOLUME IN THE TIOT, DOES THE\n* SET UP OF THE WORK AREA FOR THE VOLUME BY DOING DEVTYPE.\n*\n* RETURN -- CC NON-ZERO MEANS UNKNOWN VOLUME OR DEVTYPE NOT\n* ALLOWED BY WYLBUR -- R15 HAS ERROR CODE.\n* R15 = 0 MEANS THE VOLUME WAS FOUND SUCCESFULLY.\n         SPACE\nDOUCBSR     XENTER 2,8,*\nRESEARCH L     RR,CVTIOT           GET TIOT ADDR\n         SR    1,1                     INIT REG\nDOUCB1   DS    0H\n         CLC   CVSTYPE,4(RR)       CHECK VALID DDNAME\n         BE    DOUCB2              BR IF OK\n         CLC   CVTTYPE,4(RR)       CHECK FOR TEMP TYPE\n         BE    DOUCB2              BR IF OK\n         CLC   CVUTYPE,4(RR)       OTHER POSSIBILITY\n         BNE   DOUCB3              BR IF NOT VALID DDNAME\nDOUCB2   L     15,16(,RR)          GET UCB ADDRESS\n         CLC   DSVID,28(15)        IS THIS THE RIGHT ENTRY?\n         BE    DOUCB4                  YES,GO PROCESS THIS ENTRY\nDOUCB3   IC    1,0(RR)                 GET ENTRY LENGTH\n         AR    RR,1                    MOVE TO NEXT ENTRY\n         CLI   0(RR),0                 IS IT LAST\n         BNE   DOUCB1              CHECK NEXT\n         TM    JCBAFL,JCBTSO       RUNNING UNDER TSO?\n         BZ    NOVOLUME\n         NC    WAPSCB(4),WAPSCB   A PSCB MAYBE?\n         BZ    NOVOLUME\n         L     R15,CVDAIR          ADDRESS OF DAIR ROUTINE\n         MVC   DA08SER(6),DSVID    GET VOLID\n         MVC   DSNVOL(6),DSVID     GET VOLID\n         XC    WADARECB(4),WADARECB\n         MVC   DA08DDN(2),CVSTYPE\n         MVC   DA08DDN+2(6),DSVID  GENERATE A DDNAME\n         LA    R1,WAUPT            ADDR OF DAPL\n         LA    R2,DA08CD\n         ST    R2,WADAIR\n         BALR  R14,R15             CALL DAIR\n         CH    R15,=H'20'\n         BH     NOVOLUME\n         B     *+4(R15)            BRANCH ACCORDINGLY\n         SPACE\n         B     ADDADD              ADD A DD\n         DC    2H'0'               BAD DAPL .. ANOTHER DUMP\n         DC    2H'0'               ERROR IN CAT\n         B     DAIRERR             ERROR\n         B     TIOTFULL\n         B     NOVOLUME\n         SPACE 3\nADDADD   L     R5,CVDDNAMS\n         L     R2,CVDDCNT          COUNT OF DD'S\n         CH    R2,=H'&MAXDDS'\n         BNL   RESEARCH            TABLE FULL\n         LR    R3,R2\n         LA    R2,1(,R2)\n         ST    R2,CVDDCNT\n         SLL   R3,3                MULT BY 8\n         AR    R5,R3\n         MVC   0(8,R5),DA08DDN     SAVE DDNAME\n         B     RESEARCH            GO THRU LOOP AGAIN\n         SPACE\n* TIOT IS FULL SO WE MUST DEALLOCATE SOMETHING\nTIOTFULL L     R5,CVDDNAMS\n         L     R4,CVDDCNT          COUNT OF DD'S\n         LTR   R4,R4\n         BZ    NOVOLUME            CANT FREE ANYTHING\n         BCTR  R4,R0               -1\n         ST    R4,CVDDCNT\n         SLL   R4,3                MULT BY 8\n         AR    R5,R4               POINT TO LAST DD ALLOCATED\n         MVC   DA18DDN(8),0(R5)\n         L     R15,CVDAIR\n         LA    R1,WAUPT            ADDR OF DAPL\n         LA    R2,DA18CD\n         ST    R2,WADAIR           SAVE PARM ADDR\n         BALR  R14,R15\n         LTR   R15,R15             OK?\n         BZ    RESEARCH\nDAIRERR  B     NOVOLUME\nNOVOLUME LA    R15,RTNBDVOL        ILL VOLUME ERROR CODE\n         LTR   R15,R15             SET CC FOR RETURN\n         B     XXX\n         SPACE\nDOUCB4   MVC   DSDD(8),4(RR)       MOVE FULL DDNAME\n         LA    15,0(15)                ZERO FIRST BYTE UCB ADDR\n         ST    15,UCB                  SAVE FOR ANYONE WHO WANTS\n         DEVTYPE DSDD,DVTAREA,DEVTAB\n         MVC   DEVCODE(4),DVTDEVCD     SAVE DEVCODE\n         MVC   DS4DEVSZ+2(2),DVTNUMT  SET IN CASE FMT4 NOT READ\n         SR    R15,R15             SET R15 FOR OK\n         CLI   DEVCODE+2,X'20'     IS IT DIRECT ACCESS?\n         BE    XXX\n         LA    R15,RTNBDVOL    RETURN CODE FOR ILL VOLUME\n         LTR   R15,R15             SET CC FOR RETURN\nXXX      LR    13,8\n         LM    2,8,4(13)\n         BR    SR                  RETURN TO CALLER\n         SPACE 6\n         EJECT\nRENCTG   XENTER 2,8,*\n         OI    CPLFLG3,CPFUNCLG  SET UNCAT\n         TM    F1,X'02'          IS UNCAT SET\n         BNO   REUN1             NO\nREUN     XCALL DCATLG            UNCAT\n         BZ    REUN1             NO ERROR\n         OI    F1,X'01'         SET UNCAT ERROR\n         SR    R15,R15              CLR\nREUN1    MVC   DSNAME(44),SDSNQLB   MOVE IN DSN\n         TM    SDSNQUB+16,X'02'     UNCAT,RECAT\n         BNO   REUN2                NO\n         XCALL DCATLG\n         BZ    REUN2                NO ERROR\n         OI    SDSNQUB+16,X'01'     UNCAT ERROR FLG\n         SR    R15,R15             CLR\nREUN2    TM    SDSNQUB+16,X'04'     CAT,RECAT\n         BNO   REUN3                NO\n         XI    CPLFLG3,X'60'        SET CAT\n         XCALL DCATLG\n         BZ    REUN3                NO ERROR\n         OI    SDSNQUB+16,X'08'     SET CAT ERROR FLG\n         SR    R15,R15             CLR\nREUN3    XEXIT 2,8,*\n         SPACE 3\nPRENA    XENTER 2,8,*              PDS PROCESSING FOR RENAME\n         USING WDIOWA,RWA\n         L     RWA,CVIOWA\n         MVC   VTOCEND+49(17),BLDL   CREATE SEC BLDL LIST\n         MVI   VTOCEND+52,X'4C'      SET LENGTH TO MAX\n         BLDL  DCB,VTOCEND+49\n         ST    R15,ERROR             SAVE ERROR CODE\n         CLI   ERROR+3,8             I/O ERROR?\n         BE    BLDR                  YES\n         CLI   ERROR+3,4           MEMBER FOUND AFTER BLDL\n         L     R14,=A(ILLMEMB)     SET RETURN\n         BE    BLDR             NO, ERROR\n         TM    F3,X'02'            ADD\n         BO    PREN1               YES\n         MVC   VTOCEND+61(8),VTOCEND+4    MOVE IN NEW NAME\n         STOW  DCB,VTOCEND+53,C      CHANGE NAME\n         LTR   15,15                 ERROR\n         BNZ   PREN2                 YES\nEXIP     XEXIT 2,8                   RETURN\n         SPACE 3\nPREN1    MVC   VTOCEND+53(8),VTOCEND+4    MOVE IN ALIAS NAME\n         MVC   VTOCEND+64(63),VTOCEND+66  REMOVE KZ FOR STOW ADD\n         OI    VTOCEND+64,X'80'      SET ALIAS FLAG\n         STOW  DCB,VTOCEND+53,A      ADD ALIAS\n         LTR   15,15                 ERROR\n         BZ    EXIP                  NO,CLOSE RTN\nPREN2    ST    R15,ERROR             SAVE ERROR\n         CLI   ERROR+3,4             ALREADY EXISTS\n         L     R14,=A(EXISTS)        SET RET\n         BE    BLDR               YES\n         CLI   ERROR+3,X'0C'         NO ROOM\n         L     R14,=A(NODIRSPC)      SET RET\n         BE    BLDR               YES\n         L     R14,=A(ABORTMS)       SET RET\nBLDR     L     R15,=A(BLDLERR)     OUT\n         LR    13,8\n         LM    2,8,4(13)\n         BR    R15                 RETURN TO ERROR ROUTINE\n         TITLE 'ROUTINE TO CLEAR AND RESET THE JFCB'\nCLRJFCB  DS    0H\n         SENTER R7\n         USING WDIOWA,RWA\n         MVC   JFCBSAVE(JFCBLGTH),JFCB  COPY JFCB\n         XC    JFCB(JFCBLGTH),JFCB  CLEAR THE WHOLE THING\n         MVC   JFCBELNM,JFCBSAVE+JFCBELNM-JFCB\n         MVC   JFCBLTYP,JFCBSAVE+JFCBLTYP-JFCB\n         MVC   JFCBVLSQ,JFCBSAVE+JFCBVLSQ-JFCB\n         MVC   JFCBIND2,JFCBSAVE+JFCBIND2-JFCB\n         MVC   JFCBNVOL,JFCBSAVE+JFCBNVOL-JFCB\n         MVC   JFCBVOLS,JFCBSAVE+JFCBVOLS-JFCB\n         MVC   JFCBVLCT,JFCBSAVE+JFCBVLCT-JFCB\n* JFCBDSNM IS FILLED IN ELSEWHERE\n         SEXIT R7\n         TITLE 'DISK READ (DREAD) ROUTINE'\n* READ\n         SPACE\nDREAD    XENTER 2,8,*\n         XTRACE DREAD\n         L     RWA,CVIOWA          LOAD WORK AREA ADDR\n         USING WDIOWA,RWA\n         TM    JCBAFL,JCBAFDO          DISK OPEN?\n         BNZ   NOTOPEN1                BR IF SO\n         XCALL NOTOPEN\nNOTOPEN1 SR    15,15\n         ST    15,RETCOD      SAVE RETURN CODE\n         IC    R15,DCB+DCBKEYLE-IHADCB GET KEY LENGTH\n         L     R2,=A(DBUFSIZE)     GET SIZE OF BUFFER\n         SR    R2,R15              SET BLKSIZE FOR READ\n         READ  DECB,SF,,,(2),MF=E\n         BAL   14,DWAIT\n         CLC   CCREDT(8),=CL8' '\n         BE    AD3\n         STM   R0,R5,0(R13)\n         LA    R3,DBUF\n         LA    R4,4\n         LA    R5,MXRECSZ(R3)\n         SR    R5,R4\nAD6      L     R1,CCREDT\n         SR    R0,R0\n         M     R0,=F'65533'\n         ST    R1,CCREDT\n         L     R1,CCREDT+4\n         SR    R0,R0\n         M     R0,=F'65547'\n         LR    R0,R1\n         X     R0,CCREDT\n         ST    R0,CCREDT+4\n         XC    0(4,R3),CCREDT+4\n         ST    R1,CCREDT+4\n         BXLE  R3,R4,AD6\n         LM    R0,R5,0(R13)\nAD3      EQU   *\n         XEXIT 2,8,LTR\n         TITLE 'DISK WRITE (DWRITE) ROUTINE'\n* WRITE\n         SPACE\nDWRITE   XENTER 2,8,*\n         XTRACE DWRITE\n         L     RWA,CVIOWA          LOAD WORK AREA ADDR\n         TM    JCBAFL,JCBAFDO          DISK OPEN?\n         BNZ   NOTOPEN2                BR IF SO\n         XCALL NOTOPEN\nNOTOPEN2 LTR   SR,0\n         BP    *+8\n         L     SR,RECSIZE\n         SR    15,15\n         ST    15,RETCOD      SAVE RETURN CODE\n         CLC   CCREDT(8),=CL8' '\n         BE    AD2\n         STM   R0,R5,0(R13)\n         LA    R3,DBUF\n         LA    R4,4\n         LA    R5,MXRECSZ(R3)\n         SR    R5,R4\nAD4      L     R1,CCREDT\n         SR    R0,R0\n         M     R0,=F'65533'\n         ST    R1,CCREDT\n         L     R1,CCREDT+4\n         SR    R0,R0\n         M     R0,=F'65547'\n         LR    R0,R1\n         X     R0,CCREDT\n         ST    R0,CCREDT+4\n         XC    0(4,R3),CCREDT+4\n         ST    R1,CCREDT+4\n         BXLE  R3,R4,AD4\n         LM    R0,R5,0(R13)\nAD2      WRITE DECB,SF,,,(SR),MF=E\n         BAL   R14,DWAIT\n         XEXIT R2,R8,TEST\n         EJECT\nTAB      DC    256X'5F'\n         ORG   TAB+C'0'\n         DC    X'01030507090B0D0F1113'\n         ORG   TAB+C'A'\n         DC    X'1517191B1D1F212325'\n         ORG   TAB+C'J'\n         DC    X'27292B2D2F31333537'\n         ORG   TAB+C'S'\n         DC    X'393B3D3F41434547'\n         ORG   TAB+C'$'\n         DC    X'494B'\n         ORG   TAB+C'\u00ac'\n         DC    X'4D4F51'\n         ORG   TAB+C'#'\n         DC    X'5355'\n         ORG\nTAB2     DC    256X'BF'\n         ORG   TAB2+C'0'\n         DC    X'61636567696B6D6F7173'\n         ORG   TAB2+C'A'\n         DC    X'7577797B7D7F818385'\n         ORG   TAB2+C'J'\n         DC    X'87898B8D8F91939597'\n         ORG   TAB2+C'S'\n         DC    X'999B9D9FA1A3A5A7'\n         ORG   TAB2+C'$'\n         DC    X'A9AB'\n         ORG   TAB2+C'\u00ac'\n         DC    X'ADAFB1'\n         ORG   TAB2+C'#'\n         DC    X'B3B5'\n         ORG\n         TITLE 'DISK CLOSE (DCLOSE) ROUTINE'\n* CLOSE\n         SPACE\nDCLOSE   XENTER 2,8,*\n         XTRACE DCLOSE\n         TM    JCBAFL,JCBAFDO          DISK OPEN?\n         BNZ   NOTOPEN3                BR IF SO\n         XCALL NOTOPEN\nNOTOPEN3 L     RWA,CVIOWA           LOAD WDIOWA ADDR\n         USING WDIOWA,RWA\n         LA    R3,DCB\n         USING IHADCB,R3\n         MVC   DCBRECFM(1),RRECFM  RESET FOR CLOSE\n         TM    F2,X'02'            RENAME\n         BO    CLOSE               YES, SKIP STOW\n         TM    F2,DSNFWRT+DSNFSCR+DSNFPDS    TEST FUNCTION\n         BO    STOW                BR IF SCRATCH MEMBER\n         SR    R15,R15             INIT RETURN CODE\n         TM    DCBDSORG,DSORGPO    TEST FOR PDS\n         BO    CLOSPDS             BR IF YES\n         TM    DFL,DFUPTSPC        IS SEQ SPACE ACCTG NEEDED\n         BZ    CLOSE               BR IF NOT\n         NOTE  (R3)\n         SR    R15,R15             INIT RETURN CODE\n         SRL   R1,16               GET TT FROM TTRZ IN NOTE\n         LTR   R1,R1               IS IT STILL ON FIRST TRACK\n         BNZ   CLOSE               BRANCH NO -- NOT SMALL FILE\n         L     R0,DEVBLOCK         GET BLKSIZE FOR DEVICE\n         SRA   R0,1                HALVE IT\n         CH    R0,DCBTRBAL         COMPARE TO BALANCE ON TRACK\n         BH    CLOSE               NOT SMALL IF HIGH\n         OI    CPLFLG2,CPFSMALL    SET SMALL DATA SET FLAG\n         B     CLOSE\n         SPACE\nCLOSPDS  TM    F2,DSNFWRT          TEST OUTPUT\n         BZ    CLOSE               BR IF NOT\n* WE MIGHT GET TO THIS POINT WITH A SAVE OF A VOID RANGE\n         TM    CPSTAD,CPFSOME      WAS IT A VOID RANGE\n         BE    CLOSVOID            YES, DON'T UPDATE DIRECTORY\n* SET UP FOR STOW OF NEW/REPL MEMBER\n         XC    BLDLTTR(STOWSZ-L'MEMBER),BLDLTTR  CLEAR TRASH\n         L     R1,DSAVSSI          GET SSI IF GIVEN\n         TM    F3,DSNFSSI          WAS SSI GIVEN\n         BO    CLOSPDS1            YES, GO USE IT\n         TIME  ,                   GET DATE\n         SRL   R1,4                GET RID OF SIGN\n         N     R1,=X'0000FFFF'     SAVE DIGIT FOR YEAR AND DATE\nCLOSPDS1 ST    R1,STOWLTTR         STOW IT IN DIRECTORY\n         MVI   BLDLKZC,X'02'   INDICATE 2H USER DATA\n         SPACE\n* THE STOW ROUTINE CALLS EOV TO ALLOCATE A NEW EXTENT IF\n* THE EOB WILL NOT FIT IN THE DATA SET.  WYLBUR DOES NOT\n* ALLOW EXTRA EXTENTS TO BE ALLOCATED AND MANY TIMES WYLBUR\n* WOULD ABEND X37 BECAUSE NO EXTENT WAS DEFINED OR NO EXTENT\n* WOULD VE AVAILABLE.  THEREFORE, THE FOLLOWING CODE IS NEEDED\n* TO DETERMINE IF THE EOB WILL FIT WITHOUT CALLING EOV.  IT IS\n* A DUPLICATE OF THE TEST MADE BY R21 MVT STOW MODULE IGG0210A.\n*\n* THE CODE FIRST CHECKS IF THE EOB WILL FIT ON THE TRACK BEING\n* USED.  IF IT WON'T THEN IT USES THE RESIDENT CONVERT ROUTINES\n* TO DETERMINE IF THERE IS ANOTHER TRACK IN THE CURRENT EXTENT/\n* THIS IS DONE BY CONVERTING THE CURRENT ABSOLUTE ADDRESS TO\n* TTRN FORM, ADD 1 TRACK TO THE TT, AND CONVERT BACK TO\n* ABSOLUTE FORM.  THE CONVERT BACK HAS A ZERO RETURN CODE IF\n* THE TRACK IS WITHIN THE DATASET, OR A FOUR RETURN CODE IF NOT\n*\n* THE RESIDENT ROUTINES USE R1 AS THE DEB PTR, R2 AS THE\n* ABSOLUTE ADDRESS AREA, R0 AS THE TTRN CONTENTS.  R1-R8 ARE\n* NOT CHANGED BY THE ROUTINES.  R9-R13 ARE CHANGED.  R14 IS THE\n* RETURN REGISTER, AND R15 IS THE ENTRY ADDRESS.\n         SPACE\nSTOWCRAP L     R2,DCBDVTBL         GET DEVTABLE ADDRESS\n         SR    R1,R1               PICK UP OVERHEAD VALUE\n         IC    R1,7(,R2)           FOR KEYED LAST RECORD\n         TM    9(R2),X'08'         IS OVERHEAD HALFWORD?\n         BZ    *+8                 NO, VALUE IS OK\n         LH    R1,6(,R2)           GET HALFWORD OVERHEAD\n         SR    R0,R0               PICK UP OVERHEAD\n         IC    R0,8(,R2)           FOR KEYED RECORDS\n         SR    R1,R0               GET OVERHEAD FOR NO KEYS\n         CH    R1,DCBTRBAL         WILL EOB FIT ON THIS TRACK?\n         BL    STOWCR1             YES EVERYTHING IS OK\n         SPACE\n* WON'T FIT IN THIS TRACK, CALCULATE NEXT TRACK AND SEE IF\n* STILL IN DATASET EXTENT.\n         L     R1,DCBDEBAD         GET DEB ADDRESS\n         LA    R2,CPDOUB           POINT TO 8-BYTE AREA\n         MVC   CPDOUB(8),DCBFDAD   SET CURRENT ABS ADDR\n         STM   R3,R13,0(R13)       SAVE REGISTERS\n         LR    R3,R13              AND R13\n         L     R4,CVTPTR           GET POINTER TO CVT\n         USING CVT,R4\n         L     R15,CVTPRLTV        CONVERT MBBCCHHR\n         BALR  R14,R15              TO TTRN\n         AL    R0,=XL4'10000'      POINT TO NEXT TRACK\n         L     R15,CVTPCNVT        CONVERT TTRN\n         BALR  R14,R15              TO MBBCCHHR\n         DROP  R4\n         LM    R3,R13,0(R3)        RESTORE REGISTERS\n         LTR   R15,R15             IS NEXT TRACK OK?\n         BNZ   CLOSVOID            NO, ABORT THE STOW\nSTOWCR1  LR    R1,R3               RESTORE STOW REGISTER\n         LA    R0,MEMBER\n         NI    CPLFLG2,255-CPFSCRTC  CLEAR IN CASE NOT REPL\n         TM    DFL,DFREPL          WAS IT REPL?\n         BZ    STOW\n         OI    CPLFLG2,CPFSCRTC    RESET IT\n         LCR   R1,R1               INDICATE REPL FUNCT\nSTOW     SVC   21                  STOW\n         B     CLOSE\n         SPACE 3\n* AN ATTEMPT WAS MADE TO SAVE A MEMBER OF A PDS BUT THE RANGE\n* WAS VOID.  RECOVER BY NOT UPDATING THE DIRECTORY OR DSCB\n* ALSO USED TO BYPASS STOW IF EOB WON'T FIT\n         SPACE\nCLOSVOID NI    DCB+DCBOFLGS-IHADCB,X'7F' TURN OFF FOR DSCB\n         LNR   R15,R6              SET NEGATIVE RETURN CODE\n         SPACE\nCLOSE    ST    R15,ERROR           SAVE RETURN CODE\n         CLOSE (,REREAD),MF=(E,OPENLIST)  CLOSE DATA SET\n         MODESET KEY=ZERO         KEY ZERO FOR ENQ              JJG\n         DEQ   RET=HAVE,MF=(E,ENQDSN)\n         SR    15,15\n         STH   R15,DCBLRECL        RESET LRECL\n         STH   R15,DCBBLKSI        RESET BLKSIZE\n         MODESET KEY=NZERO        NOT ZERO                      JJG\n         L     R15,ERROR           GET RETURN CODE\n         LTR   R15,R15             WAS IT NORMAL?\n         BZ    CHKCLCAT            BR IF YES\n         BM    DCX         VOID OR STOW EOF RECORD PROB IF NEG\n         MVI   ERROR+1,C'7'     EITHER I/O ERROR OR LOGIC PROB\n         XCALL CATER\n         L     R0,RECSIZE          RELOAD ERROR CODE\n         B     DCX\n         SPACE 3\n* TEST IF CATLG/RECATLG/UNCATLG SPECIFIED\n         SPACE\nCHKCLCAT TM    CPLFLG3,CPFRECLG    WAS ANY CATLG STUFF SPEC?\n         BZ    DCX                 BR IF NO\n         TM    CPLFLG3,CPFDSCLG    WAS IT CATLG OR RECATLG?\n         BZ    DOCLCAT             BR IF UNCAT\n         TM    CPLFLG1,CPFUSCAT    WAS CATLG USED TO LOC VOL?\n         BO    DCX        BR IF YES - SUPERFLUOUS TO REDO\nDOCLCAT  XCALL DCATLG              GO DO WHATEVER IT IS\n         B     DCX                 PASS ON RETURN CODE TO EXIT\n         SPACE 3\n* RELEASE\n         SPACE\nDCX      NI    JCBAFL,255-JCBAFDO      SET DS CLOSED\nDCXX     XEXIT 2,8                     RETURN\n         TITLE 'LITERAL POOL'\n         LTORG\n         TITLE 'MISCELLANEOUS STUFF'\n*  PROCESS REQUEST ON UNOPENED FILE\n         SPACE\nNOTOPEN  DS    0H\n         GENTER ,\n         ABEND  69,DUMP,STEP\n         TITLE 'DISK WAIT (DWAIT) ROUTINE'\n* ROUTINE TO WAIT FOR DISK I/O\n*\n* UNDER NORMAL CIRCUMSTANCES, THIS ROUTINE GOES DIRECTLY TO THE\n* WYLBUR DISPATCHER.  THUS, THE REGISTERS ARE SAVED IN THE CP.\n* THE EXCEPTION TO THIS IS WHEN AN I/O OPERATION IS COMPLETED\n* IMMEDIATELY BECAUSE THERE IS NO MORE ROOM IN A PDS.  INSTEAD\n* OF LETTING THE CHECK MODULE CALL EOV AND ABEND, THE APPROPRIATE\n* FLAGS ARE TURNED OFF TO PREVENT STOW AND DSCB UPDATING AND\n* DCLOSE IS USED TO CLOSE THE DATA SET.  FOR THIS FUNCTION, IT\n* IS NECESSARY TO SAVE THE REGISTERS IN THE STANDARD WAY SO THAT\n* WHEN DCLOSE CALLS THE DISPATCHER THE REGISTERS IN THE CP ARE\n* NOT OVERLAID CAUSING A LOOP.\n         SPACE\nDWAIT    STM   13,8,CPR13\n         SENTER R14,R8,C44          IN CASE DCLOSE CALLED\n         USING WDIOWA,RWA\n         XTRACE DWAIT\n         TM    DECB,X'40'              COMPLETE?\n         BO    DW                      BR IF NOT\n         WAIT  ECB=DECB\n         SPACE\n* IF OPERATION IS IMMEDIATELY COMPLETE CHECK FOR OPERATION\n* NOT INITIATED.  IF NOT, CHECK OUT OF SPACE AND BYPASS\n* FURTHER PROCESSING.\n         SPACE\nDW       TM    DECB+5,X'20'        WAS IT A WRITE?\n         BZ    DWNB                BR IF NO\n         TM    DCB+DCBCIND1-IHADCB,X'20'  WAS IT EOV?\n         BZ    DWNB                BR IF NO\n         SPACE\n* OUT OF SPACE (IN PDS). TURN OFF WRITE FLAG TO PREVENT DSCB\n* UPDATE DURING CLOSE.\n         SPACE\n         NI    DCB+DCBOFLGS-IHADCB,X'7F'\n         L     R15,DCB+DCBIOBA-IHADCB  GET IOB ADDR\n         NI    0(R15),X'BF'        INDICATE NO WRITE IN PROGRESS\n         NI    F2,255-DSNFWRT  TELL CLOSE IT'S INPUT TO BYPASS STOW\n         CVCALL DCLOSE\n         LA    R15,RTNNOSPC        RETURN CODE FOR NO SPACE\n         ST    R15,4(R8)           SAVE FOR SEXIT\n         SEXIT R14,R8,FOOP         RELOAD AND EXIT\n         SPACE 3\nDWNB     CHECK DECB\nDWCL     L     SR,DECB+16          POINT TO IOB\n         SR    R0,R0               CLEAR FOR IC\n         IC    R0,DCB+DCBKEYLE-IHADCB GET ANY KEY LENGTH\n         AH    R0,DECB+6           ADD IN BLKSIZE TO GET ORIG LEN\n         SH    0,14(,SR)           SUBTRACT RESID TO GET READ CNT\nDWCL1    L     15,RETCOD      LOAD RETURN CODE\nDWTXW    LM    2,8,CPR2       RETUTN\n         LM    13,14,CPR13\n         LTR   15,15\n         BR    14\n         SPACE\nEODAD    LA    15,4\n         B     DWTXW\n         SPACE\nSYNAD    L     SR,=F'-4'\n         ST    SR,RETCOD      SAVE RETURN CODE\n         BR    14\n         TITLE 'CATALOG MANIPULATION (DCATLG) ROUTINE'\n* ROUTINE TO DO CATLG/RECATLG/UNCATLG\n         SPACE\nDCATLG   DS    0H\n         XENTER R2,R8,32\n         SR    R15,R15\n         TM    CPLFLG3,CPFRECLG    TEST ANY BITS ON\n         BZ    DCATX               BR IF NO\n         L     R15,CAMUNC          GET UNCATLG FUNCT\n         TM    CPLFLG3,CPFUNCLG    UNCATLG OR RECATLG?\n         BO    DCATLGO             BR IF YES\nGETCATF  L     R15,CAMCAT          GET CATLG FUNCT\nDCATLGO  ST    R15,CATLST          AND STORE IN CAMLIST\n         MVI   SCRRET,0            CLEAR DATA SET SEQ NO FIELD\n         CATALOG CATLST            DO FUNCTION\n         CLC   CAMUNC,CATLST       WAS FUNCT UNCATLG?\n         BNE   DCATXX              BR IF NOT\n         TM    CPLFLG3,CPFDSCLG    ARE WE TO RECATLG?\n         BZ    DCATX               BR IF NO\n         SPACE\n* REACTLG SPECIFIED - IF UNCAT UNSUCC CHANGE TO CATLG\n         LTR   R15,R15\n         BZ    GETCATF\n         NI    CPLFLG3,255-CPFUNCLG\n         B     GETCATF\n         SPACE\nDCATXX   CH    R15,=H'8'           RC=8 MEANS REAL CODE IN R1\n         BNE   DCATX               BR IF NOT RETURN CODE 8\n         SLL   R1,8                SHIFT CODE LEFT\n         OR    R15,R1              PUT CODE INTO R15\nDCATX    XEXIT R2,R8,LTR\n         SPACE 3\n         DS    0F\nCAMUNC   CAMLST UCATDX,0\n         ORG   CAMUNC+4\nCAMCAT   CAMLST CATBX,0,,0\n         ORG   CAMCAT+4\n         TITLE 'SHOW DSNAMES/DIRECTORY/CATALOG (DVTOC) ROUTINE'\n* SHOW DSNAMES\n         SPACE\nDVTOC    L     R14,0(R13)          GET FINAL EXIT RETURN\nDVTOC2   DS    0H                  ENTRY FOR SPACE COMPUTATION\n         XENTER R2,R8,32           AND RESAVE REGS\n         XTRACE DVTOC\n         L     RWA,CVIOWA           RESTORE WDIOWA REG\n         TM    F2,DSNFSHOW         IS IT A SHOW COMMAND?\n         BZ    SDSNSPAC            NO - COMPUTE DSCB SPACE\n         ST    15,PAGEGET         SAVE SUBR ADDRESS\n         CLI   F2,DSNFSHOW         IS IT SHOW DSNAMES?\n         BE    NOTDRUM             SKIP CCW SETUP IF SO.\n         MVC   CCWSW+1(3),VTOCCCW   SET SHOW DSNAMES TIC ADDR\n         MVI   KEY,SCHKADEQ+MT     RESET CCW COMMAND CODE\n         MVI   ENDCCW1,SCHKADEQ+MT\n         LH    R0,DSNWANL          GET PATTERN LENGTH\n         LTR   R0,R0               IS THERE ONE?\n         BNZ   BLF                 BR IF NOT\n         LA    R0,1                SET DUMMY ONE FOR CCW\n         MVI   DSNAME,X'80'        SET LOW VALUE IN AREA\n         MVI   KEY,SCHKADHI+MT     USE SEARCH HI VICE EQ\n         MVI   ENDCCW1,SCHKADHI+MT\nBLF      STH   R0,KEY+6            LENGTH OF PATTERN\n         STH   R0,ENDCCW1+6\n         CLI   DEVCODE+3,2         IS DEVICE 2301?\n         BNE   NOTDRUM             BR IF NOT\n         SPACE\n* SCH KEY AND DATA COMMANDS NOT VALID ON 2301\n         XI    KEY,SWKADKY         SWAP TO SCH KEY\n         XI    ENDCCW1,SWKADKY     SAME\nNOTDRUM  L     R15,PAGEGET\n         BAL   R14,0(R15,R10)     GO TO PAGEGET SUBR\n         BZ    VTOCNPG                 NO PAGES\n         LA    0,1                INIT COUNT\n         STH   0,0(9)\n         MVI   2(9),0             INIT PAGE\n         PMARK 9                   MARK THE PAGE AS CHANGED\n         LA    SR,DCB\n         TM    F2,DSNFPDS          IS IT SHOW DIRECTORY?\n         BNZ   VTOCLP1             BR IF NOT\n         MVC   DCB(DCBSZ),TEST\n         USING IHADCB,SR\n         LA    R1,EXLST            EOD ADDRESS\n         IC    R0,DCBEXLST         PRESERVE RECFM BYTE\n         ST    R1,DCBEXLST\n         STC   R0,DCBEXLST         RESTORE IT\n         B     VTOCLP\n         SPACE 3\n* OTHERWISE, IT'S SHOW DIRECTORY\n         SPACE\nVTOCLP1  MVC   SEEK(4),DS1EXT1+2   SET DIRECTORY SEEK ADDR\n         MVI   SEEK+4,0              RO\n         MVC   CCWSW+1(3),PDSCCW   SET SHOW DIR TIC ADDR\n         LA    SR,FOURS\n         SPACE\nVTOCLP   LA    0,6                PUT OUT VOLID MSG\n         LA    1,DSVID\n         BAL   14,VTOCMSG\n         TM    F2,DSNFCAT          IS IT SHOW CATALOG?\n         BO    SHOWCAT             BR IF YES\n         MVC   DCBDDNAM(8),DSDD   INITIALIZE IT\n         TM    F2,DSNFPDS          IS IT SHOW DIRECTORY?\n         BO    OPENEXCP            BR IF YES\n         CLI   DSNAME,X'05'        IS IT SHO DSN\n         BNE   READJFCB            YES. DONT DO OBTAIN\n         OBTAIN VTOC\n         LTR   15,15              WAS IT OK\n         BZ    DVTOBTOK            BR IF OBTAIN OK\n         CH    R15,=H'8'           WAS IT VALID ERROR?\n         BE    DVTOBTOK            BR IF NO\n         CH    R15,=H'4'           WAS IT VOL NOT MOUNTED\n         BNE   VTOCERR             BR IF NO - I/O ERROR\n         LA    R15,RTNBDVOL        INDICATE BAD VOLUME\n         ST    R15,RETCOD\n         B     VTOCRET1            GO EXIT\n         SPACE 3\nDVTOBTOK LH    1,DVTNUMT\n         BCTR  1,0\n         STH   1,NUMTRK\n         MVC   ENDTEST(4),VTOCEND\n         MVC   ENDTEST+4(1),DS4DEVDT  SET UP FOR TEST\n         MVC   SEEK(4),VTOCBEG\n         MVI   SEEK+4,0\n         CLI   DSNAME,X'05'        IS IT SHOW SPACE?\n         BE    SHOWSPAC            BR IF YES\nREADJFCB RDJFCB (DCB),MF=(E,OPENLIST)\n         XCALL CLRJFCB             GO CLEAN UP THE JFCB\n         MVC   JFCBDSNM(44),DSN\nOPENEXCP DS    0H\n         MVI   JFCBLTYP,JFCBLP         NO LAST ACCESS DATE UPD\n         OI    JFCBTSDM,X'08'      INHIBIT JFCB REWRITE\n         OPEN  ((SR),INPUT),TYPE=J,MF=(E,OPENLIST)\n         TM    DCBOFLGS,X'10'     IS IT OPEN\n         BZ    VTOCERR            NO,ERROR\n         DROP  SR\n         MVI   SBUF,X'40'          CLEAR SHOW DSNAMES BUFFER\n         MVC   SBUF+1(SBSZ-1),SBUF\n         TM    F2,DSNFPDS           IS IT SHOW DIRECTORY?\n         BO    SRCHSTRT             YES. BRANCH.\n         SPACE\n         LA    R1,DECB1\n         LA    R2,DECB2\n         STM   R1,R2,DECBSTRT\n         MVC   DECBCUR(4),DECBEND  INIT DECBCUR FOR NEW VTOC\n         LA    R2,0\n         STH   R2,DSCBCNT\n         MVC   DSNLEN(2),DSNWANL\n         MVC   DPLFLG3,CPLFLG3\n         MVC   DDSNQLB(88),SDSNQLB\n         MVI   ALLBYTE,X'00'\n         CLC   DSNAME+4(2),FF1          GROUP=ALL?\n         BNE   CL2\n         OI    ALLBYTE,ALLGROUP\nCL2      CLC   DSNAME+7(3),FF1\n         BNE   CL3\n         OI    ALLBYTE,ALLUSER\n         SPACE\n* START A READ FOR EACH BUFFER NOW\nCL3      L     R3,DECBSTRT         GET STARTING ADDRESS OF DECB'S\n         LA    R2,DCB              SET ADDRESS OF VTOC READ DCB\nSTRTLOOP LA    R4,BUFFADDR(,R3)     GET BUFFER ADDR\n         XC    0(4,R3),0(R3)\n         READ  (R3),SF,(R2),(R4),MF=E ISSUE READ\n         LA    R3,DECBLEN(,R3)     STEP TO NEXT\n         C     R3,DECBEND          AT END YET\n         BL    STRTLOOP            NO, LOOP\nOBTAIN   L     R2,DECBCUR          GET CURRENT DECB POINTER\n         LA    R2,DECBLEN(,R2)     STEP TO NEXT DECB\n         C     R2,DECBEND          AT END OF DECB'S\n         BL    *+8                 NO, BRANCH\n         L     R2,DECBSTRT         YES, RESTART AT BEGINNING\n         ST    R2,DECBCUR          RESET CURRENT POINTER FOR NEXT\nCHECKRD  CHECK (R2)                CHECK THE RESULT\n         LH    R3,DSCBCNT\n         LA    R3,1(,R3)\n         STH   R3,DSCBCNT\n         MVC   DS1DSNAM(140),BUFFADDR(R2)  MOVE DSCB TO WORK\n         XC    0(4,R2),0(R2)\n         READ  (R2),SF,MF=E        RESTART READ FOR THIS DECB\n         CLI   DS1FMTID,C'1'      CHECK FOR FORMAT 1\n         BNE   OBTAIN              RETURN TO CALLER\n         SR    RR,RR\n         MVC   SBDSN,DS1DSNAM      DSNAME\n         LH    RR,DSNLEN           GET PATTERN LENGTH\n         LTR   RR,RR\n         BZ    ITSALL\n         LA    R15,DS1DSNAM        GET OFFSET IN DSN\n         TM    ALLBYTE,ALLUSER+ALLGROUP\n         BZ    EXCOMP\n         BO    ORFF1\n         TM    ALLBYTE,ALLGROUP\n         BZ    ORFF2\n         EX    0,ORFF1\n         B     EXCOMP\n         SPACE\nORFF1    OC    4(2,R15),FF1\n         SPACE\nORFF2    OC    7(3,R15),FF1\nEXCOMP   BCTR  RR,0\n         EX    RR,SDSCOMP\n         BNE   OBTAIN\n         LA    RR,1(RR)\nITSALL   LA    R15,DS1DSNAM(RR)    GET OFFSET IN DSN\n         LA    SR,44               LENGTH OF DSN\n         SR    SR,RR               LENGTH REMAINING FOR RANGE\n         BCTR  SR,0\n         EX    SR,DDSNCLC1         CHECK DSNAME IN BOUNDS\n         BL    DUTOFRNG            BR IF LOWER THAN LOW BOUND\n         EX    SR,DDSNCLC2         CHECK DSNAME IN BOUNDS\n         BH    DUTOFRNG            BR IF HIGHER THAN UPPER BOUND\n         TM    DPLFLG3,CPFEXCL     TEST FOR EXCLUDE RANGE\n         BO    OBTAIN              BR IF YES\n         B     SDSNWANT\nDUTOFRNG TM    DPLFLG3,CPFEXCL     TEXT FOR EXCLUDE RANGE\n         BZ    OBTAIN              BR IF NO\n         B     SDSNWANT            WE WANT THIS ONE\n         SPACE\nSDSCOMP  CLC   0(0,R15),DSNAME\nDDSNCLC1 CLC   0(0,R15),DDSNQLB\nDDSNCLC2 CLC   0(0,R15),DDSNQUB\n         SPACE\nFF1      DC    XL3'FFFFFF'\n         SPACE\nSYNAD1   ABEND 999,DUMP\n         EJECT\nSRCHSTRT LA    1,SRCHCCW\n         ST    1,IOBSTART\nEXCP     TM    JCBAFL,JCBAFIA          IDLE ATTN TO ABORT COMMND\n         BO    VTOCERR                 YES, ERROR EXIT\n         MVI   DECB,X'00'              CLEAR ECB\n         EXCP  IOB                     NO, START NEXT I/O\n         WAIT  ECB=DECB                WAIT FOR READ TO COMPLETE\n         TM    DECB,X'20'              OK COMPLETE\n         BO    ENDCHK\n         TM    IOBSNS+1,X'20'\n         BO    NEWCYL\nVTOCERR  LA    R15,RTNSHERR        SHOW ERROR RETURN CODE\n         B     VTOCRET            EXIT\n         SPACE\nVTOCNPG  TSEG  'WYLBUR OUT OF PAGES',,W\n         B     VTOCERR\n         SPACE\nNEWCYL   SR    1,1\n         STC   1,SEEK+4\n         IC    R1,SEEK+1\n         LA    1,1(,1)\n         STC   1,SEEK+1\n         B     EXCP\n         SPACE\nENDCHK   CLC   IOBCSW+1(3),LASTCCW\n         BE    DONE\n         TM    F2,DSNFPDS          IS IT SHOW DIRECTORY?\n         BO    PDSRDOK             BR IF YES\n         SPACE\n* GET PERTINENT STUFF FROM FORMAT 1 DSCB\nSDSNWANT MVC   SBCRDT,DS1CREDT     CREATION DATE\n         AIF   ('&DCEC' NE '1').LBLX6                           JEP00X\n         MVC   SBEXDT,DS1SYSCD+13      RES. FLD FOR LAST ACCESS JEP011\n         AGO   .LBLX7                                           JEP00X\n.LBLX6   DS    0H                                               JEP00X\n         MVC   SBEXDT,DS1REFD      (SU60) LAST UPDATE\n.LBLX7   DS    0H                                               JEP00X\n         MVC   SBNOEX,DS1NOEPV     NUMBER OF EXTENTS\n         MVC   SBDSORG,DS1DSORG    DSORG\n         MVC   SBRECFM,DS1RECFM    RECFM\n         MVC   SBLRECL,DS1LRECL    LRECL\n         MVC   SBBLKSZ,DS1BLKL     BLKSIZE\n         MVC   SBKEYL,DS1KEYL      KEY LENGTH\n         MVC   SBLB,DS1LSTAR       LAST RECORD WRITTEN\n         MVC   SBPROTF,DS1PROTF    PROTECTION BITS\n         MVC   SBACCTG,DS1SPACE    MOVE ACCOUNTING FLAG\n         NI    SBACCTG,SPACFLAG    GET RID OF OTHER CRAP\n         SPACE\n* THE FOLLOWING CODE IS ALSO USED AS A SUBROUTINE\n* COMPUTE AMOUNT OF SPACE ALLOCATED FROM EXTENT INFORMATION\nSDSNSPAC SR    SR,SR               TOTAL SPACE (IN TRKS)\n         LA    R0,3                NUMBER OF EXTENTS IN FMT 1\n         SR    RR,RR\n         IC    RR,DS1NOEPV         TOTAL NUMBER OF EXTENTS\n         LA    R15,DS1EXT1         ADDR OF FIRST EXTENT DESCRIP\nNXTXSECT CR    RR,R0          TOTAL REMAINING VS MAX THIS SECT\n         BH    MULTSECT            BR IF MORE SECTIONS FOLLOWING\n         LTR   R0,RR               TOTAL IS REMAINING\n         BZ    XTNTALL             UNLESS ZERO\nMULTSECT SR    RR,R0               REMAINING AFTER THIS SECTION\nXTNTLP   CLI   0(R15),0            IS THIS EXTENT ACTIVE?\n         BE    XTNTDONE            BR IF NO\n         MVC   CCREDT,2(R15)       MOVE LOWER/UPPER DESCRIP\n         LH    R1,CCREDT+6         LAST TRACK\n         LA    R1,1(R1)            +1 FOR SUBT\n         SH    R1,CCREDT+2         LESS FIRST TRACK\n         AR    SR,R1\n         LH    R1,CCREDT+4         UPPER CYL\n         SH    R1,CCREDT           LOWER CYL\n         MH    R1,DS4DEVSZ+2       * # TRKS/CYL\n         AR    SR,R1\nXTNTDONE LA    R15,DS1EXT2-DS1EXT1(R15)  TO NEXT DESCRIP\n         BCT   R0,XTNTLP           PROCESS NEXT ONE\n         LTR   RR,RR               ARE THERE MORE?\n         BZ    XTNTALL             BR IF NO\n         CLI   DS3FMTID,C'3'       HAS FMT 3 BEEN READ?\n         BE    FMT3SEC2            BR IF YES - SECTION 2\nREADFMT3 OBTAIN VTOC3\n         LTR   R15,R15             TEST NORMAL\n         BZ    XTNTFMT3            BR IF YES\nFMT3ERR  LNR   SR,SR               FLAG TOTAL AS INCOMPLETE\n         B     XTNTALL             SKIP IT\n         SPACE\nXTNTFMT3 CLI   DS3FMTID,C'2'       IS IT FORMAT 2?\n         BE    READFMT3            BR IF YES - GO GET FMT 3\n         CLI   DS3FMTID,C'5'       IS IT FORMAT 5?\n         BE    FMT5PROC            BR IF YES\n         CLI   DS3FMTID,C'3'       WAS DSCB FMT 3?\n         BNE   FMT3ERR             BR IF NO - ERROR\n         LA    R0,4                4 EXTENTS IN FIRST SECTION\n         LA    R15,DS3EXTNT        ADDR OF FIRST SECTION\n         B     NXTXSECT            GO PROCESS IT\n         SPACE\nFMT3SEC2 LA    R15,DS3ADEXT        ADDR OF SECTION 2 IN FMT 3\n         LA    R0,9                9 EXTENTS IN SECT 2\n         B     NXTXSECT\n         SPACE 3\nXTNTALL  STH   SR,SPTRK            SAVE TOTAL\n         SR    R15,R15             RESET RETURN CODE\n         TM    F2,DSNFSHOW         IS IT A SHOW COMMAND?\n         BZ    VTRX                NO - SUBROUTINE EXIT\n* END OF SUBROUTINE CODE\n         SPACE\n         LA    R1,SBUF             ADDR OF BUFFER\n         LA    R0,SBSZ             LENGTH OF ENTRY\n         CLI   DSNAME,X'05'        ARE WE IN SHOW SPACE?\n         BE    FMT5DONE            YES - GO FINISH UP\n         BAL   14,VTOCMSG         PUT IT OUT\nDONTWANT CLI   F2,DSNFSHOW\n         BE    OBTAIN\n         CLC   IOBCSW+1(3),LASTCCW1    WAS THIS THE FUNNY CASE\n         BNE   SRCHSTRT                NO CONTINUE SEARCH\n         SPACE\nDONE     SR    15,15              COMP CODE\n         B     VTOCRET\n         SPACE\nDONEA    SR    15,15              COMP CODE\n         B     VTOCRET\n         SPACE 3\nSDSNCLC1 CLC   0(0,R15),SDSNQLB\nSDSNCLC2 CLC   0(0,R15),SDSNQUB\n         EJECT\n* ROUTINE TO PROCESS FORMAT 5 DSCBS FOR SHOW SPACE\n         SPACE\nSHOWSPAC XC    SBUF(SBSZ),SBUF     CLEAR BUFFER\n         MVC   SBDSN,DSNAME        MOVE IN SPECIAL DSNAME\n         SR    SR,SR               ZERO SPACE TOTAL\n         SR    TR,TR               ZERO EXTENT TOTAL\n         ST    SR,HOLDEXT          INIT. LARGEST EXT\n         MVC   DS5PTRDS,VTOCBEG    MOVE FMT4 LOCATION (CCHH)\n         MVI   DS5PTRDS+4,2        REC 2 ON THAT TRACK\n         B     READFMT3            GO READ IT\n         SPACE\nFMT5PROC LA    R0,8                NUMBER OF FIELDS IN SECT 1\n         LA    R15,DS5AVEXT        ADDR OF FIRST ONE\nFMT5LOOP CLC   0(L'DS5AVEXT,R15),=D'0'  IS IT IN USE?\n         BE    FMT5NOTH            BR IF NOT\n         MVC   CCREDT,0(R15)       MOVE EXTENT INFO (+ GARBAGE)\n         LH    R1,CCREDT+2         NO OF CYL IN EXTENT\n         MH    R1,DS4DEVSZ+2       # NO TRKS/CYL\n         AR    SR,R1               ADD TO TOTAL\n         LR    R14,R1\n         SR    R1,R1\n         IC    R1,CCREDT+4         NO OF ODD TRACKS\n         AR    SR,R1               TO TOTAL\n         LA    TR,1(TR)            BUMP NO OF EXTENTS\n         AR    R14,R1              GET CURRENT EXTENT SIZE\n         C     R14,HOLDEXT         IS IT BIGGER?\n         BNH   FMT5NOTH            NO. BRANCH\n         ST    R14,HOLDEXT         STORE LARGEST EXTENT\nFMT5NOTH LA    R15,L'DS5AVEXT(R15)  BUMP FIELD POINTER\n         BCT   R0,FMT5LOOP\n         CLI   0(R15),C'5'         ARE WE AT END OF DSCB?\n         BNE   FMT5END             BR IF YES\n         LA    R15,1(R15)          BUMP PAST DSCB ID\n         LA    R0,18               NO OF FIELDS IN SECT 2\n         B     FMT5LOOP            GO GET THE REST\n         SPACE\nFMT5END  CLC   DS5PTRDS,=D'0'      IS IT LAST ONE?\n         BNE   READFMT3            BR IF NOT\n         B     XTNTALL             OTHERWISE WE'RE DONE\n         SPACE\nFMT5DONE STH   TR,SBDSN+8          SAVE TOTAL PIECES\n         MVC   SBDSN+4(4),HOLDEXT  MOVE LRGEST XTENT FOR\n*                                  WRITE SPA ROUTINE\n         BAL   R14,VTOCMSG         GO STORE IT\n         B     DONE                AND EXIT\n         EJECT\n* ROUTINE TO PROCESS DIRECTORY BLOCK FOR SHOW DIRECTORY\n         SPACE\nPDSRDOK  LA    RR,DBUF+8           ADDR OF DIRECTORY BLOCK\nPDSRDOK2 LH    R1,0(RR)            LENGTH OF DATA\n         CH    R1,=Y(256)          IS LENGTH OK?\n         BH    VTOCERR             BR IF TOO LONG - SOMETHING BA\n         LA    R1,0(R1,RR)         ADDR OF END OF BLOCK\n         BCTR  R1,0                ADDR OF LAST CHAR IN BLOCK\n         LA    R0,2                LENGTH OF BLOCK COUNT FIELD\nPDSUNBLK BXH   RR,R0,PDENDBLK      BR IF NO MORE ENTRIES IN BLK\n         LA    R0,12               LENGTH OF STD STUFF\n         IC    TR,11(RR)           GET \"C\"\n         N     TR,=X'0000001F'     CLEAR ALL EXCEPT LENGTH\n         SLL   TR,1                WHICH IS IN HALFWORDS\n         AR    R0,TR               TOTAL ENTRY LENGTH\n         TM    F2,DSNFCAT          IS IT SHOW CATLG?\n         BOR   R14                 RETURN IF YES\n         CLI   0(RR),X'FF'         IS IT LAST MEMBER\n         BE    DONE                BR IF YES\n         SPACE\nSCATPRNM CLC   0(8,RR),CPDSNWA+DSSIZ   MEMBER IN LOWER BOUND?\n         BL    PDSORNG             BR IF BELOW LOWER BOUND\n         CLC   0(8,RR),CPDSNWA+DSSIZ+8   UPPER BOUND?\n         BH    PDSORNG             BR IF ABOVE UPPER BOUND\n         SPACE\n* PDS MEMBER IN SPECIFIED RANGE\n         TM    CPLFLG3,CPFEXCL     EXCLUDE RANGE?\n         BO    PDSUNBLK            BR IF YES\n         B     HAVEMBR             NO - PROCESS IT\n         SPACE 3\n* PDS MEMBER OUTSIDE SPECIFIED RANGE\n         SPACE\nPDSORNG  TM    CPLFLG3,CPFEXCL     EXCLUDE RANGE?\n         BZ    PDSUNBLK            BR IF NOT\n*                 OUTSIDE EXCLUDED RANGE IS INSIDE DESIRED RANGE\nHAVEMBR  TM    F2,DSNFCAT          IS IT SHOW CATLG?\n         BO    HAVECAT             BR IF YES\n         LR    SR,R1               SAVE R1\n         LR    R1,RR               ADDR OF ENTRY\n         BAL   R14,VTOCMSG         GO ADD TO DISPLAY PAGE\n         LR    R1,SR               RESTORE R1 FOR BXH\n         B     PDSUNBLK\n         SPACE 3\n* END OF DIRECTORY BLOCK\n         SPACE\nPDENDBLK TM    F2,DSNFCAT          IS IT SHOW CATLG?\n         BO    VTOCERR             ERR IF SO\n         MVC   SEEK(5),SRCHC       ADDR OF LAST BLOCK READ\n         CLI   DBUF,X'FF'          CHECK KEY FOR LAST BLOCK\n         BE    DONE                BR IF SO\n         B     SRCHSTRT            GO GET NEXT BLOCK\n         EJECT\n* ROUTINE TO PROCESS CATALOG BLOCKS\n         SPACE\nSHOWCAT  LH    R0,DSNWANL          PATTERN LENGTH\n         LTR   R0,R0               IS PATTERN LENGTH ZERO?\n         BZ    FSTCTBLK            GO READ HIGHEST LEVEL IF SO\n         CLI   RETCOD+3,0          WAS DSN FOUND BY LOCATE?\n         BE    SCATDSN             BR IF YES\n         CLI   RETCOD+3,12         WAS INDEX LEVEL FOUND?\n         BE    SCATGO              BR IF YES\n         L     R0,RETCOD           SOMETHING WRONG\n         B     VTOCERR             SCRAM\n         SPACE 3\n* GO DEBLOCK INDEX BLOCK\n         SPACE\nSCATGO   LA    RR,CATBLOCK         FOR SHOW DIR ROUTINE\n         BAL   R14,PDSRDOK2        USE SHOW DIR RTN TO DEBLOCK\n         B     SCATGO2\n         SPACE\nSCATNEXT BAL   R14,PDSUNBLK        GET NEXT ENTRY\nSCATGO2  CLC   0(4,RR),=F'-1'      IS IT INDEX LINK ENTRY?\n         BNE   SCATDATA            BR IF NOT\n         SPACE\n* ENTRY SHOULD BE INDEX LINK\n         CLI   11(RR),0            VERIFY ENTRY TYPE\n         BNE   VTOCERR             BR IF NOT\n         CLC   8(3,RR),=XL3'0'     IS IT END OF LIST?\n         BE    DONE                BR IF YES\n         MVC   CATNTTR(3),8(RR)    NEXT TTR\n         OI    USCATL2,X'80'\nLOCATTR  LOCATE USCATL2       LOCATE NEXT BLOCK\n         LTR   R0,R15              LOCATE OK?\n         BNZ   VTOCERR             BR IF NOT\n         B     SCATGO              NOW GO AHEAD\n         SPACE 3\n* NULL PATTERN - READ FIRST CATALOG BLOCK FROM SYSRES\n         SPACE\nFSTCTBLK NI    USCATL2,X'7F'\n         MVC   CATNTTR(3),=AL3(1)  TTR=001\n         B     LOCATTR             GO DO LOCATE\n         SPACE 3\n* PROCESS OTHER ENTRY TYPES\n         SPACE\nSCATDATA LA    R14,SCATGO2         LOAD IN CASE OUT OF LIMITS\n         B     SCATPRNM            GO CHECK IN LIMITS SPECIFIED\n         SPACE\nHAVECAT  MVI   SCBUF,X'40'\n         MVC   SCBUF+1(SCBSZ-1),SCBUF   CLEAR BUFFER\n         MVC   SCBNM,0(RR)         MOVE INDEX NAME\n         CLI   11(RR),5            CHECK FOR DSN POINTER ENTRY\n         BH    SCATDSP             BR IF YES\n         SR    TR,TR\n         IC    TR,11(RR)           GET TYPE\n         SLL   TR,2                *4\n         B     *+4(TR)             BR TO PROPER ROUTINE\n         SPACE\n         B     SCATINDX            INDEX POINTER ENTRY\n         B     SCATVCB             VOLUME CONTROL BLOCK ENTRY\n         B     SCATGDG             GENERATION DATA GROUP ENTRY\n         B     SCATNEXT            INDEX CONTROL ENTRY - IGNORED\n         B     SCATALAS            ALIAS ENTRY\n         B     SCATCVOL            CVOL ENTRY\n         SPACE 3\n* ENTRY HERE FOR DSNAME SPECIFIED TO ORIG LOCATE\n         SPACE\nSCATDSN  MVI   SCBNM,X'FF'         INDICATE NAME IN DSNWA\n         MVI   SCBCODE,C'D'        ENTER DSNAME CODE\n         MVC   SCBNVOLS,CATNOENT   GET NUMBER OF VOLUMES\n         MVC   SCBVOL,CATVOL       GET VOLUME NAME\n         LA    R1,SCBUF\n         LA    R0,SCBSZ\n         BAL   R14,VTOCMSG\n         B     DONE                EXIT\n         SPACE\n* INDEX POINTER ENTRY\nSCATINDX MVI   SCBCODE,C'I'        ENTER INDEX CODE\n         B     SCATWRT             THAT'S ALL\n         SPACE\n* VOLUME CONTROL BLOCK ENTRY\nSCATVCB  MVI   SCBCODE,C'D'        FLAG AS DSNAME\n         MVI   SCBVOL,X'FF'        INDICATE VOL NAME NOT AVAIL\n         B     SCATGDSN            GO CHECK FOR GDG NAME\n         SPACE\n* GENERATION DATA GROUP INDEX POINTER\nSCATGDG  MVI   SCBCODE,C'G'        ENTER GDG CODE\n         MVC   SCBMAX(L'SCBMAX+L'SCBNVOLS),13(RR)  TWO COUNTERS\n         B     SCATWRT\n         SPACE\n* ALIAS ENTRY\nSCATALAS MVI   SCBCODE,C'A'        ENTER ALIAS CODE\n         MVC   SCBNM2,12(RR)       GET TRUE NAME\n         B     SCATWRT\n         SPACE\n* CVOL ENTRY\nSCATCVOL CLC   SCBNM,=FL8'1'       IS ENTRY CVOL OR VOL INDEX?\n         BE    SCATNEXT            BR IF VOL INDEX ENTRY\n         MVI   SCBCODE,C'C'        ENTER CVOL CODE\n         MVC   SCBVOL,16(RR)       GET CVOL NAME\n         B     SCATWRT\n         SPACE\n* DATA SET POINTER ENTRY\nSCATDSP  MVI   SCBCODE,C'D'        ENTER DSNAME CODE\n         MVC   SCBNVOLS,12(RR)     GET NUMBER OF VOLS\n         MVC   SCBVOL,18(RR)       GET VOL NAME\n         SPACE\n* CHECK FOR COMPLEMENTED GDG LOWEST LEVEL NAME\nSCATGDSN TM    SCBNM+1,X'F0'       TEST NO HI-ORDER BITS\n         BNZ   SCATWRT             CAN'T BE GDG NAME\n         CLI   SCBNM,C'G'          MAKE SURE GDG\n         BNE   SCATWRT             BR IF NOT\n         XC    SCBNM+1(4),=F'-1'   MAKE IT READABLE\n         SPACE\nSCATWRT  STM   R0,R1,CCREDT        SAVE REGS\n         LA    R1,SCBUF\n         LA    R0,SCBSZ\n         BAL   R14,VTOCMSG\n         LM    R0,R1,CCREDT        RESTORE REGS\n         B     SCATNEXT            CONTINUE TO NEXT ENTRY\n         EJECT\nVTOCRET  ST    R15,RETCOD\n         TM    F2,DSNFCAT          IS IT SHOW CATLG?\n         BO    VTOCRET4            BR IF YES\n         CLOSE (,REREAD),MF=(E,OPENLIST)\n         TM    F2,DSNFPDS          IS IT SHOW DIRECTORY?\n         BZ    VTOCRET1            BR IF NOT\n         MODESET KEY=ZERO         KEY ZERO FOR ENQ              JJG\n         DEQ   MF=(E,ENQDSN),RET=HAVE  DEQ ON PDS\n         MODESET KEY=NZERO        NOT ZERO                      JJG\nVTOCRET1 L     R15,RETCOD\nVTOCRET4 NI    JCBAFL,255-JCBAFDO      SET DS CLOSED\nVTRX     XEXIT R2,R8,LTR\n         EJECT\nVTOCMSG  STM   14,8,VTOCSV        SAVE REGS\n         TM    CPLFLG3,CPFPUT\n         BZ    DONTCONT\n         L     SR,CPWK6           USED FOR DELTA CALCULATION\n         LA    SR,1(SR)\n         ST    SR,CPWK6\nDONTCONT LH    SR,0(9)            GET COUNT\n         LR    TR,0               NEW COUNT\n         AR    SR,TR              NEW TOTAL\n         C     SR,=A(CPSIZE-3)    THATS HOW MUCH THERE IS\n         LH    SR,0(,9)           OLD COUNT\n         BNH   VMSGOK             IT'LL FIT\n         BCTR  SR,0               DECR. COUNT\n         STH   SR,0(,9)           STORE IT BACK\n         L     R14,CPMDLN         GET # OF PAGES\n         CH    R14,=Y(10)         OVER MAX?\n         BNL   OVERTEN            NO. BRANCH\n         L     15,PAGEGET         GET ADDR OF SUBR\n         BAL   R14,0(R15,R10)\n         BZ    OVERTEN\n         LA    SR,1               INIT NEW PAGE\nVMSGOK   LA    TR,1(9,SR)         POINTER WHERE TO PUT IT\n         AR    SR,0\n         LA    SR,1(SR)           FORM NEW COUNT\n         STH   SR,0(9)            STORE IT\n         LR    SR,0               MSG COUNT\n         BCTR  SR,0\n         EX    SR,DVTMV           MOVE IN MSG\n         LA    SR,1(SR)           COUNT OF MSG\n         STC   SR,0(TR)           STORE IT\n         LA    SR,1(SR,TR)        ONE PAST END OF MSG\n         MVI   0(SR),0            END FLAG\n         PMARK 9                   MARK THE PAGE AS CHANGED\n         LM    14,8,VTOCSV\n         BR    14\n         SPACE 3\nOVERTEN  LA    R15,RTNPAGES       SET CODE\n         B     VTOCRET\n         SPACE\nDVTMV    MVC   1(0,TR),0(1)\n         SPACE\n         PRINT NOGEN\nTEST     DCB   BLKSIZE=96,KEYLEN=44,RECFM=F,BUFNO=0,DSORG=PS,          *\n               EODAD=DONEA,LRECL=96,DEVD=DA,MACRF=(R),SYNAD=SYNAD1,    *\n               OPTCD=C,NCP=&NCP\n         PRINT GEN\n         TITLE 'CALCULATE RECORDS/TRACK ROUTINE'\n* CALCTRK CALCULATES THE NUMBER OF RECORDS/TRACK FOR A GIVEN\n*        BLKSIZE.\n*  INPUT  R1 POINTS TO DVTAREA AND THE DEVTYPE HAS BEEN DONE\n*         R0 HAS BLKSIZE\n* OUTPUT  R1 HAS RECORD COUNT\n         SPACE\nCALCTRK  SENTER R2,R8\n         LR    R6,R1               SET BASE\n         USING DVTAREA,R6              FOR DEVTABLE\n         LR    R2,R0               SET R2 TO BLKSIZE ALSO\n         MH    R2,DVTTOL           MULT BY TOLERANCE\n         SRA   R2,9                DIVIDE BY 512\n         SR    R1,R1               SET FOR IC\n         IC    R1,DVTKEYO          GET KEY OVERHEAD\n         SR    R0,R1               ADJUST BLKSIZES SINCE NO KEYS\n         SR    R2,R1\n         TM    DVTFLAG,DVTFOHD     IS IT HALF WORD OVERHEAD\n         BO    CALCTRK1            BR YES\n         IC    R1,DVTBLKO          GET NORMAL BLOCK OVERHEAD\n         AR    R2,R1               ADJUST NORMAL VALUE\n         IC    R1,DVTLBLKO         GET LAST BLOCK OVERHEAD\n         AR    R0,R1               ADJUST LAST BLOCK VALUE\n         B     CALCTRK2            NOW GO ON\n         SPACE\nCALCTRK1 LH    R1,DVTBLKO          GET BLOCK OVERHEAD\n         AR    R0,R1               ADJUST BOTH FOR\n         AR    R2,R1                   BLOCK OVERHEAD\nCALCTRK2 LH    R1,DVTTRKSZ         GET TRACK SIZE\n         SR    R1,R0               ADJUST FOR LAST BLOCK\n         AR    R1,R2               ADD TO INCR COUNT BY 1\n         SR    R0,R0               SET FOR DIVIDE\n         DR    R0,R2               CALCULATE VALUE IN R1\n         SEXIT R2,R8               RETURN\n         DROP  R6\n         TITLE 'CATASTROPHIC ERROR (CATER) ROUTINE'\nCATER    DS    0H\n         XENTER 0,8,*\n         USING WDIOWA,RWA\n         TSEG  '*** WYLBUR *** DATA FILE ERROR NO. '\n         L     R0,ERROR       ERROR CODE IN FORM XXFN00RR\n         LA    R15,4               NUMBER OF SHIFT ITERATIONS\nGAIN     SRDL  R0,4                PUT RETURN CODE INTO LO BITS\n         SRL   R1,4\n         BCT   R15,GAIN\n         ST    R1,ERROR            SAVE RETURN CODE PART\n         TR    ERROR(4),TRTB\n         STC   R0,ERROR+1          PUT EBCDIC ID BACK IN\n         MVC   RECSIZE,ERROR       SAVE IT FOR RETURN TO NTGDOPN\n         TSEG  ERROR+1,3\n         TSEG  '. VOLUME='\n         TSEG  DSVID,6\n         TSEG  '. DSNAME='\n         LH    R0,DSNWANL          GET DSNAME LENGTH\n         TSEG  DSNAME,(0)\n         OPWRITE\n         LA    R15,RTNCATER\n         XEXIT 0,8\n         SPACE\nTRTB     DC    C'0123456789ABCDEF'\n         DROP  RWA\n         TITLE 'MISCELLANEOUS STUFF'\n         COPY  WYLCONST\n         EJECT\n         COPY  RTNCODES\n         EJECT\n         LTORG\n         TITLE 'WDIO WORK AREA'\nWDIOWA   WDIOWA DSECT\nWASASZ   EQU 72\n         ORG WASA+WASASZ\nHOLDEXT  DC    F'0'\nALLBYTE  DC    X'00'\nALLUSER  EQU   X'01'\nALLGROUP EQU   X'02'\nDECBCUR  DC    A(DECB2)            CURRENT DECB POINTER\nDECBSTRT DC    A(DECB1)            START OF DECB'S\nDECBEND  DC    A(DECB2)            END OF DECB'S\nDSCBCNT  DC    H'0'                TOTAL DSCB COUNT\nDSNLEN   DC    H'0'\nDPLFLG3  DC    F'0'                CP FLAG 3\nDDSNQSZ  EQU   44\nDDSNQLB  DS    CL(DDSNQSZ)\nDDSNQUB  DS    CL(DDSNQSZ)\nBUFFADDR EQU   20\nPROTGRUP EQU   X'80'               ALLOW USE WITHIN GROUP\nPROTUSER EQU   X'40'               RESTRICT ACCESS TO USER ONLY\n         SPACE 3\n         DECBS ,\n         TITLE 'DSECTS'\n         EJECT\n         COMMON\n         EJECT\n         PRINT  NOGEN\n         DCBD  DSORG=PS\n         SPACE 3\n         COPY  SVCS\nUCM      DSECT\n         IEECUCM\n         SPACE\nCVT      DSECT\n         CVT     SYS=VMS\n         CUCCCVT ,\n         IKJTCB\n         IEECHAIN\n         IEZJSCB\n         IHADSAB\n         SPACE\n         END\n./ ADD NAME=PDOS,SSI=00000176\nPDOS     TITLE 'DO TYPE ROUTINES FOR WYLTSO'\n* PROPERTY OF C. U. C. C. A.\n         SPACE 3\n         GBLC    &DCEC             SWITCH FOR DCEC MODS         JEP00X\n&DCEC    SETC   '1'  CHANGE TO ANY OTHER NUM. TO DELETE DCEC MODJEP00X\n         AIF   ('&DCEC' NE '1').LBL01                           JEP00X\n*                                                               JEP003\n*                                                               JEP003\n* MOD  JEP003                                                   JEP003\n*  FIX BUG IN ALTERS COMMAND.  DENOTED  JEP003 IN 66/71.        JEP003\n*  MODULES AFFECTED: PDOS, PGOP                                 JEP003\n*  JERRY PITTENGER DEF COMM ENG CTR                             JEP003\n*                                                               JEP004\n*                                                               JEP004\n* MOD  JEP004                                                   JEP004\n*  ENABLE 3277 RECOGNITION SO ALTERS & EDIT COMMANDS LINE UP    JEP004\n*  DIRECTLY UNDER CHARACTER TO BE CHANGED ON NON-3277 TERMINALS.JEP004\n*  MODULES AFFECTED: PDOS, INIT, WTR, PGOP, MACRO(CPTSO)        JEP004\n*  DENOTED  JEP004 IN 66/71. JERRY PITTENGER DEF COMM ENG CTR.  JEP004\n*                                                               JEP005\n*                                                               JEP005\n*                                                               JEP005\n* MOD  JEP005                                                   JEP005\n*  CHANGED AT DCEC TO ADD UPPER & LOWER OPERANDS TO CHANGE CMD. JEP005\n*  FOR CHANGING CASE OF TEXT. DENOTED BY  JEP005 IN COL. 66/71. JEP005\n*      MODULES AFFECTED ARE:                                    JEP005\n*                           PDOS, PGOS, PUTB, AND MACRO CPTSO   JEP005\n*                                                               JEP008\n*                                                               JEP008\n* MOD  JEP007                                                   JEP007\n*  CHANGED AT DCEC TO ALLOW ATTENTION DURING THE CHANGE CMD.    JEP007\n*  DENOTED JEP007 IN COL. 66/71.  JERRY PITTENGER DCEC 5/19/78  JEP007\n*      MODULES AFFECTED ARE:                                    JEP007\n*                           PDOS                                JEP007\n*                                                               JEP008\n*                                                               JEP008\n* MOD JEP008                                                    JEP008\n*  IMPLEMENT TAB SUPPORT FOR SECRETARIAL STAFF. DENOTED IN 66/71JEP008\n*  MODULES AFFECTED: INIT, PDOS, MACRO(CVTSO)                   JEP008\n*                                                               JEP008\n*                                                               JEP008\n.LBL01   DS    0H                                               JEP00X\nPDOS     CSECT\n         SPACE\n         WIDENT 001\n         SPACE\n         XTRNS ,\n         SPACE\n         USING CPAREA,R12\n         TITLE 'DOCHNG ROUTINE'\n* DOCHNG EXECUTES ANY CHANGES ON A LINE.  DOCHNG IS CALLED BY DESPOT\n*      WITH THE UNPRESSED LINE.  CELLS USED SHOWN IN CP.\n         SPACE\nDOCHNG   XENTER R2,R8,C32+SZR+C8        REGS & SPACE\n         TM    CPLFLG3,CPFCHNM+CPFCHUS  CHANGE WITH NUMBERS\n         BZ    *+8                 BRANCH NO\n         OI    CPLFLG3,CPFCHNMI    SET TO INCREMENT\n         LR    R2,R0                    SAVE TOTAL UNPRESSED COUNT\n         LR    R14,R0                   COUNT OF UNPRESSED LINE\n         TM    CPFILLFG,CPFILL\n         BZ    FILLOWER\n         STM   R0,R1,CPFLEN(R8)    R0 = LEN, R1 = LEN\n         NI    CPFILLFG,255-CPDUN-CPFILLHI-CPLOST CLR FLAGS\n         L     R3,CPFCOL           GET FILL COL\n         LA    R3,0(R3)            CLEAR FLAG BYTE\n         CR    R3,R0               IS FILL COL > ORIG SIZE\n         BL    FILLOWER            NO. BRANCH\n         OI    CPFILLFG,CPFILLHI   TURN ON FILL HI FLAG\nFILLOWER LM    R3,R6,CPCHCST            PICK UP ASSOC CELLS\n         AIF   ('&DCEC' NE '1').LBL02                           JEP00X\n         TM    CPLFLG4,CPFCHUP          CHANGE TO UPPER?        JEP005\n         BO    CHUP                     GO RAISE                JEP005\n         TM    CPLFLG4,CPFCHLO          CHANGE TO LOWER?        JEP005\n         BO    CHLO                     GO LOWER                JEP005\n.LBL02   DS    0H                                               JEP00X\n         TM    CPLFLG2,CPFCHPOS         POSITIONAL CHANGE ONLY?\n         BNZ   POSCHANG                 YES\n         MVC   0(1,R8),CPCHMOD          MOD TO WORK MOD\n         STC   R5,CPSTCNT           SAVE LENGTH\n         MVC   CPSTCNT+1(1),0(R6)   SAVE CHAR\n         TM    CPLFLG2,CPFCHLIM         ASSOC IN ALL OR LIMITED CHARPOS\n         BO    GOTLIM                   DEFINED\n         CH    R14,=Y(MXPRTSZ)          133 CHARS?\n         BNL   CHKIT                    YES\n         LA    R14,1(R14)               END SCAN AT NO. CHARS PLUS ONE\nCHKIT    LA    R15,0(R14,R5)            AST START +(LEN-1) LE MXPRTSZ\n         CH    R15,=Y(MXPRTSZ)          COMPARE\n         BNH   MCLIB                    OK\n         LA    R14,MXPRTSZ              FIXUP\n         SR    R14,R5                   NO. CHARS TO CHECK FOR START\nMCLIB    LR    R0,R14                   NEED IT IN R0\n         SR    R3,R3                    START OUT COUNTER\n         LA    R4,C32+C8(R8)            START OUT POINTER\nMCLIA    LR    R15,R1                   KEEP START POINTER\nMCLI     CLC   0(1,R1),CPSTCNT+1         FIRST CHAR?\n         BE    MCLC                     YES\nMRCMP    LA    R1,1(R1)                 KICK\n         BCT   R0,MCLI                  MORE?\n         TM    CPLFLG2,CPFCHNGD         ANYTHING CHANGED?\n         BZ    SCREXIT                  NO\n         B     FINISUP                  MOVE THE REST\n         SPACE\nNOTNOW   STC   R14,0(R8)                RESET MOD\n         B     MRCMP                    GO ON\n         SPACE\nMCLCINST CLC   0(0,R1),0(R6)\nMCLC     ST    R14,0(,R13)         SAVE A REG\n         IC    R14,CPSTCNT          GET LENGTH-1\n         EX    R14,MCLCINST        EXECUTE INSTR\n         L     R14,0(,R13)         RESTORE..LEAVE CC UNCHANGED\n         BNE   MRCMP                    NOT THIS\n         TM    0(R8),FALLBT             MOD?\n         BZ    CHNGNOW                  NO, DO ALL OCCURANCES\n         IC    R14,0(R8)                MOD COUNTER\n         BCT   R14,NOTNOW               NOT THIS ONE\n         MVI   0(R8),FALLBT             MAKE SURE NO MORE\nCHNGNOW  OI    CPLFLG2,CPFCHNGD         SET CHANGES OCCURRED\n         LR    R14,R1                   CURRENT POINTER\n         SR    R14,R15                  COUNT BEFORE CHANGE\n         BNP   NOLDMOVE                 NOTHING BEFORE\n         AR    R3,R14                   INCREMENT OUT COUNTER\n         CH    R3,=Y(MXPRTSZ+15)        TOO MUCH IN NEW LINE?\n         BNH   OLDMOVE                  NO\n         SR    R3,R14                   BACK TO OLD COUNT\n         LA    R14,MXPRTSZ+15           MAX\n         SR    R14,R3                   COUNT THAT CAN STILL BE MOVED\n         BNP   NOMORMOV                 NIL\n         LA    R3,MXPRTSZ+15            OUT COUNT\nOLDMOVE  SR    R2,R14                   REDUCE COUNT TO MOVE YET\n         BCTR  R14,0                    FOR EX\n         EX    R14,MOVECHNG             MVC   0(0,R4),0(R15)\n         LA    R4,1(R4,R14)             UPDATE OUT POINTER\nNOLDMOVE LA    R1,1(R1,R5)              UPDATE IN POINTER\n         SR    R2,R5                    REDUCE COUNT TO MOVE YET\n         BCTR  R2,0                     ONE MORE\nPOSENTER TM    CPLFLG2,CPFCHDEL         STRING TO MOVE IN?\n         BO    ONLIDEL                  NOTHING TO MOVE IN\n         LM    R14,R15,CPCHLN2          REPLACING STRING\n         TM    CPLFLG3,CPFCHUS     CHANGE USING?\n         BO    CHUS                BR IF SO\n         SPACE\n* PROCESS CHANGE TO NUMBERS\n         TM    CPLFLG3,CPFCHNM+CPFCHNMI  CHANGE TO NUMBERS?\n         BZ    NCHN                BRANCH NO TO NORMAL CHANGE\n         BM    NCHNX               BRANCH IF ALREADY INCREMENTED\n         TM    CPLFLG3,CPFCHLN     \"LINE\" OPTION\n         BZ    *+8                 BRANCH IF NOT\n         NI    CPLFLG3,255-CPFCHNMI CLEAR INCREMENT FLAG\n         STM   R0,R2,0(R13)        SAVE A FEW\n         L     R0,0(,R15)          CURRENT NUMBER\n         CVD   R0,CPDOUB           CONVERT TO PACKED\n         A     R0,4(,R15)          ADD INCREMENT\n         BO    CHNOFL              BR IF OVERFLOW\n         C     R0,=F'999999999'    TOO HIGH?\n         BH    CHNOFL              BR IF SO\n         C     R0,=F'-999999999'   TOO LOW?\n         BNL   *+6                 BRANCH NO\nCHNOFL   SR    R0,R0               SET BACK TO ZERO\n         ST    R0,0(,R15)          SAVE NEW VALUE\n         LA    R2,10(,R14)         SET UP LENGTH\n         EX    R2,CHNMVC           MOVE PATTERN\n         L     R1,8(,R15)          SIGNAL START\n         ALR   R1,R13\n         EX    R2,CHNEDMK          EDIT\n         BNM   CHNM                BR IF NOT NEGATIVE\n         BCTR  R1,0\n         MVI   0(R1),C'-'          SIGN\n         CLI   8(R15),C'+'         PLUS SIGN?\n         BE    CHNS                BR IF SO\nCHNM     CLI   8(R15),0            SIGN?\n         BE    CHNS                BR IF NOT\n         BCTR  R1,0\n         MVC   0(1,R1),8(R15)      PLANT SIGN\nCHNS     LR    R15,R13             POINTER TO STRING\n         LA    R1,12+10-1(,R15)    SET UP LOOP\n         LA    R0,10\nBLTEST   CLI   0(R1),C' '          NUMBER EXPANDED?\n         BE    ISBL                BR IF NOT\n         BCTR  R15,0\n         BCTR  R1,0\n         LA    R14,1(,R14)\n         BCT   R0,BLTEST\nISBL     LM    R0,R2,0(R13)        RESTORE REGS\n         STM   R14,R15,0(R13)      SAVE POINTERS TO STRING\n         B     NCHN\n         SPACE 3\n* PROCESS CHANGE USING\n         SPACE\nCHUS     TM    CPLFLG3,CPFCHNMI    INCREMENT?\n         BZ    NCHNX               BR IF NOT\n         TM    CPLFLG3,CPFCHLN     \"LINE\" OPTION\n         BZ    *+8                 BR IF NOT\n         NI    CPLFLG3,255-CPFCHNMI CLEAR INCREMENT FLAG\n         STM   R0,R3,0(R13)        SAVE A FEW\n         PFLIP 9,11                SAVE CHANGED PAGE\n         LR    R3,R13              WORK SPACE\n         LA    R13,C28+SZR(,R13)\n         MVC   C16(12,R3),CPDRPT   SAVE LOCATE VALUES\n         LR    R2,R15              POINTER TO VALUES\n         CLC   0(4,R2),4(R2)       ALREADY TOO HIGH?\n         BH    CHUNM               BR IF SO\nCHUSLC   LR    R1,R2               POINT AT LINE NO.\n         CVCALL LOCATE              LOCATE LINE\n         TM    CPDRPT,CPFNTYT+CPFHIGH NO MORE TEXT?\n         BNZ   CHUNM               BR IF SO\n         CLC   CPLCNO(4),C4(R2)    LINE TOO HIGH?\n         BH    CHUNM               BR IF SO\n         MVC   0(4,R2),CPLCNO      SAVE LOCATE LINE NO.\n         TM    CPDRPT,CPFPGHI      HIGHER THAN ANY ON PAGE\n         BO    CHUSLC              YES, GO LOCATE AGAIN\n         L     R0,CPLCNO           COMPUTE NEXT LINE NO.\n         LA    R1,1\n         CVCALL ADDER              ADD INCREMENT\n         ST    R0,0(,R2)           SAVE NEW LINE NO.\n         LA    R1,C28(,R3)         POINT TO UNPRESS AREA\n         CVCALL UNPRESS            UNPRESS THE LINE\n         LM    R14,R15,C8(R2)      GET COLUMN POINTERS\n         LTR   R14,R14             WHOLE LINE?\n         BNZ   CHUNZL              BR IF NOT\n         SR    R0,R15              COMPUTE REAL LENGTH\n         LR    R14,R0              SET REAL LENGTH\nCHUNZL   AR    R15,R1              POINT AT RIGHT COL.\n         BCTR  R14,0               LENGTH - 1\n         MVC   CPDRPT(12),C16(R3)  RESTORE LOCATE VALUES\n         LR    R13,R3              RESTORE REG 13\n         LM    R0,R3,0(R13)        RESTORE REGS.\n         SH    R15,=Y(12+10)       ALLOW FOR HEADER\n         STM   R14,R15,0(R13)      SAVE VALUES FOR LATER\n         B     NCHNXX\n         SPACE\nCHUNM    CLC   0(4,R2),C16(R2)     IS LINE NUM SAME AS FRST NUM\n         BE    CHUNMB              YES, REPORT USING ERROR\n         MVC   0(8,R2),C16(R2)     RESET USING RANGE\n         TM    CPLFLG3,CPFCHREP    REPEAT THE RANGE\n         BO    CHUSLC              BRANCH YES\n         TSEG  'NOT ENOUGH LINES FOR USING',,M\n         SYSQS 1,0,'REPEAT'        ASK IF REPEAT IS OKAY\n         CVCALL YESREQ                   FROM USER\n         OI    CPLFLG3,CPFCHREP    OK, IF RETURN IS MADE\n         B     CHUSLC              GO REPEAT RANGE\n         SPACE\nCHUNMB   TSEG  'NO LINES IN USING RANGE'\n         B     CVQTYPE             GO ABORT COMMAND\n         SPACE 3\n* PLACE THE NEW STRING IN THE LINE\n         SPACE\nNCHNX    LM    R14,R15,0(R13)      PICK UP STRING POINTERS\nNCHNXX   LTR   R14,R14             NULL STRING?\n         BM    ONLIDEL             BR IF SO\nNCHN     LA    R15,12+10(,R15)     ALLOW FOR HEADER\n         LA    R3,1(R3,R14)             UPDATE OUT COUNT\n         CH    R3,=Y(MXPRTSZ+15)        TOO MUCH IN NEW LINE?\n         BNH   NEWMOVE                  NO\n         SR    R3,R14                   BACK TO OLD COUNT (PLUS 1)\n         LA    R14,MXPRTSZ+15           MAX (PLUS 1)\n         SR    R14,R3                   COUNT THAT CAN STILL BE MOVED\n         BM    NOMORMOV                 NIL\n         LA    R3,MXPRTSZ+15            OUT COUNT\nNEWMOVE  EX    R14,MOVECHNG             MVC   0(0,R4),0(R15)\n         LA    R4,1(R4,R14)             UPDATE OUT POINTER\nONLIDEL  SR    R0,R5                    REDUCE FOR STRING ELIMINATED\n         BNP   NOTCHECK                 ANOTHER STRING IMPOSSIBLE\n         TM    0(R8),FALLBT             MODS DONE?\n         BO    NOTCHECK                 YES, MOVE ANY MORE\n         BCT   R0,MCLIA                 LAST ONE?\nNOTCHECK LR    R15,R1                   CURRENT POINTER TO R15\nFINISUP  LTR   R14,R2                   MORE OF OLD LINE TO MOVE?\n         BNP   NOMORMOV                 NO\n         TM    CPFILLFG,CPFILL           FILL SPECIFIED?\n         BZ    LAS1\n         L     R2,CPFLEN(R8)       ORIG SIZE - # LEFT =\n         SR    R2,R14              NUMBER USED IN IN BUF\n         CR    R3,R2                    R3 = # IN OUT\n         BH    LAS2                     CHAR LOST. BR.\n         BL    LESINOUT                 LESS IN OUT. BLANK\n         OI    CPFILLFG,CPDUN\n         B     LAS1\n         SPACE 3\n* COME HERE IF REPLACED LINE IS SMALLER THAN ORIGINAL\n* IF FILL COL > THAN ORIG SIZE, SET DONE FLAG AND GO TO\n* PROCESS NORMALLY. IF FILL COL < ORIG SIZE PAD WITH BLANKS\n         SPACE\nLESINOUT TM    CPFILLFG,CPFILLHI   FILL COL > ?\n         BZ    FILLOW              NO. GO PAD\n         OI    CPFILLFG,CPDUN      GO THE NORMAL WAY\n         B     LAS1                NO NEED TO PAD\n         SPACE\nFILLOW   L     R14,CPFCOL          GET FILL COL\n         LA    R14,0(R14)          CLEAR HI ORDER BYTE\n         LR    R6,R14              SAVE IT\n         SR    R14,R2              # CHAR FROM CURR TO FILL\n*                                  SINCE # USED-FILL = # TO MOV\n         BNP   MOVEBLKS            UP TO FILL NOW. BR.\n         BCTR  R14,0               -1 FOR EXEC\n         EX    R14,MOVECHNG        MVC 0(0,R4),0(15)\n         LA    R3,1(R3,R14)\n         LA    R4,1(R4,R14)\nMOVEBLKS SR    R6,R3               R6 = # BLANKS\n         LR    R14,R6\n         MVI   0(R4),X'40'         MOVE BLANKS\n         S     R14,=F'2'           -1 FOR EX, -1 FOR ONE ABOVE\n         BM    NOMORMOV            NO MORE TO MOVE. BR.\n         EX    R14,MVBLKS          MVC 1(0,4),0(4)\n         B     NOMORMOV\n         SPACE 3\n*  IF OUT BIGGER THAN IN AND FILL SPECIFIED, ONLY MOVE UP\n*  TO FILL COL. THIS SAVES EXTRA MOVES, AND ALLOWS YOU TO\n*  CHECK ACCURATELY FOR LOST CHARACTERS.\n         SPACE\nLAS2     L     R14,CPFCOL\n         LA    R14,0(R14)\n         CR    R3,R14              OVER FILL ALREADY?\n         BNH   NOTOVER             NO. BRANCH\n         OI    CPFILLFG,CPLOST     SET LO T CHAR FLAG\n         B     NOMORMOV            NO NEED TO MOVE MORE\n         SPACE\nNOTOVER  SR    R14,R2              # LEFT FROM CUR/FIL\n         BNP   NOMORMOV\nLAS1     AR    R3,R14                   INCREMENT OUT COUNTER\n         CH    R3,=Y(MXPRTSZ+15)        TOO MUCH IN NEW LINE?\n         BNH   LASMOVE                  NO\n         SR    R3,R14                   BACK TO OLD COUNT\n         LA    R14,MXPRTSZ+15           MAX\n         SR    R14,R3                   COUNT THAT CAN STILL BE MOVED\n         BNP   NOMORMOV                 NIL\n         LA    R3,MXPRTSZ+15            OUT COUNT\nLASMOVE  BCTR  R14,0                    FOR EX\n         EX    R14,MOVECHNG             MVC   0(0,R4),0(R15)\n         B     NOMORMOV\n         SPACE\nMVBLKS   MVC   1(0,R4),0(R4)\nCOMPBLK  CLC  0(0,R4),1(R4)\nMOVESTR1 MVC   C32+C8(0,R8),0(R1)\n         EJECT\n* CPDUN WILL BE ON IF FILL COL > ORIG LEN AND REPLACED LINE\n* WAS SHORTER THAN ORIGINAL (NO SPILL), OR IF REPLACED LINE\n* WAS EQUAL IN SIZE TO ORIGINAL\n         SPACE\nNOMORMOV LR    R6,R3               SAVE LEN IN R6\n         TM    CPFILLFG,CPFILL+CPDUN\n         BNM   NOMORV2     IF NO FILL OR FILL DONE. BR.\n         L     R2,CPFCOL\n         LA    R2,0(R2)            CLEAR FLAG BYTE\n         LA    R4,C32+C8(R8)       ADDR OF OUT BUF\n         AR    R4,R2               FILL POS IN OUT FOR SEARCH\n         TM    CPFILLFG,CPLOST     KNOW THAT CHAR LOST?\n         BO    LOSTTHEM            YES. DONT BOTHER TO CHK\n         SR    R6,R2               LOST CHAR FOR FILL?\n         BNP   NOLOSS              NO. BR.\n         CLI   0(R4),X'40'         SEARCH FOR BLANKS IN FILL+\n         BNE   LOSTTHEM            NON-BLANK. LOST CHAR\n         S     R6,=F'2'            -1 FOR EX, -1 FOR ONE ABOVE\n         BM    NOLOSS              ONLY 1 TO LOOK AT. BR\n         EX    R6,COMPBLK          CLC 0(0,R4),1(R4)\n         BE    NOLOSS\nLOSTTHEM TSEG  'LINE NO.',,B\n         L     R0,CPLCNO           GET CURRENT LINE #\n         CVCALL CVEXNO             CONVERT IT\n         TSEG  (R1),(R0),B         PUT IT IN BUFFER\n         TSEG  'LOST CHARACTERS',,W\n         SPACE\n* IF FILL COL < THAN ORIGINAL SIZE, COPY CHARACTERS FROM\n* FILL TO END INTO OUT BUFFER.  IF FILL > THAN ORIG SIZE,\n* BRANCH OUT AND SET LENGTH TO LARGER OF 2 VALUES: FILL COL\n* OR SIZE IN OUT.\n         SPACE\nNOLOSS   TM    CPFILLFG,CPFILLHI   FILL COL > ORIG LEN?\n         BZ    HI2                 NO. BRANCH\n         CR    R3,R2               SIZE IN OUT < FILL?\n         BL    NOMORV2             YES. SET SIZE TO OUT SIZE\n         LR    R0,R2               SET LEN = FILL\n         B     NOMORE\n         SPACE\nHI2      LM    R14,R15,CPFLEN(R8)  14 = LEN, 15 = IN ADDR\n         SR    R14,R2              # CHAR FROM FILL TO END\n         AR    R15,R2              FILL POS IN IN\n         BCTR  R14,0               -1 FOR EX\n         EX    R14,MOVECHNG\n         L     R0,CPFLEN(R8)       LEN IN OUT = ORIG\n         B     NOMORE\n         SPACE\nNOMORV2  LR    R0,R3                    ADDR REASSEMBLED LINE\nNOMORE   LA    R1,C32+C8(R8)            TOTAL COUNT\n         L     R15,CPLCNO               LINE NO. TO R15\n         CVCALL LENCHK               CHECK LENGTH (AND UPDATE COUNT)\n         LR    R3,R0                    SAVE COUNT\n         TM    CPLFLG5,CPFNLST          LIST CHANGED LINE?\n         BNZ   DONLIST                 NO\n         CVCALL LISTLINE                 MAKE DESIRED LISTING\n         BNP   DONLIST                  CONTINUE (NO ATTN)\n         OI    CPLFLG2,CPFCHND          SET TO TERMINATE CHANGE\nDONLIST  L     R15,CPLCNO               LINE NO. TO R15\n         ST    R15,CPCURRL         SAVE CURRENT LINE POINTER\n         LA    R1,C32+C8(R8)            ADDR REASSEMBLED LINE\n         LR    R0,R3                    UNPRESSED COUNT TO R0\n         AIF   ('&DCEC' NE '1').LBL06                           JEP00X\nDONLIST1 CVCALL PRESS                   PRESS THE NEW LINE      JEP005\n         AGO   .LBL07                                           JEP00X\n.LBL06   DS    0H                                               JEP00X\n         CVCALL PRESS                    PRESS THE NEW LINE\n.LBL07   DS    0H                                               JEP00X\n         BAL   R14,STOWIT               REPLACE THE OLD WITH THE NEW\n         OI    CPLFLG2,CPFLNCHN        SET LINE CHANGED\nSCRAM    TM    CPLFLG2,CPFCHND          SEE IF TERMINATE SET\n         BNZ   CVQTYPE                  YES\n         NI    CPLFLG2,255-CPFCHNGD     TURN OFF LINE CHANGED BIT\nSCREXIT  XEXIT R2,R8                    RETURN\n         EJECT\n         AIF   ('&DCEC' NE '1').LBL03                           JEP00X\nCHUP     EQU   *                                                JEP005\n         TM    CPLFLG3,CPFCHALL         CHANGE WHOLE LINE???    JEP005\n         BNZ   CHALL                    YES                     JEP005\n* THIS SECTION IS FOR CHANGING EITHER SINGLE CHARS. OR          JEP005\n* STRINGS OF CHARS. TO UPPER CASE.                              JEP005\n* REGISTERS AT ENTRY ARE AS FOLLOWS                             JEP005\n*    R0 = UNPRESSED LENGTH                                      JEP005\n*    R1 = TEXT ADDRESS                                          JEP005\n*    R5 = LENGTH OF MATCH STRING - 1                            JEP005\n*    R6 = ADDRESS OF MATCHING STRING                            JEP005\n*                                                               JEP005\nUPSTART  EQU   *                                                JEP005\n         STM   R0,R1,CVSPARES      SAVE FOR LATER               JEP005\n         TM    CPLFLG2,CPFCHLIM    POSITIONALLY DEFINED?        JEP005\n         BNO   UPSTARTA            NOPE                         JEP005\n         AR    R1,R3               BUMP TO MATCH LOCATION       JEP005\nUPSTARTA LTR   R5,R5               IF EQ 0 -- ONLY 1 CHAR       JEP005\n         BNZ   UPPARTB             GO TO PART B                 JEP005\nUPPARTA  EQU   *                   SINGLE CHAR TO CHANGE SECT   JEP005\n         CLC   0(1,R1),0(R6)       IS THIS THE ONE??            JEP005\n         BNE   LOOPCTL             NO - LOOK FURTHER            JEP005\n         OC    0(1,R1),BLANKS      THIS WAS IT                  JEP005\n         OI    CVSPARES+11,X'01'   TELL EM WE MADE IT           JEP005\nLOOPCTL  EQU   *                                                JEP005\n         TM    CPLFLG2,CPFCHLIM    POSITIONALLY DEFINED?        JEP005\n         BO    CHGO1               ALLOW ONLY 1 SHOT IF SO      JEP005\n         LA    R1,1(R1)            UP THE TEXT PTR              JEP005\n         BCT   R0,UPPARTA          REDO UNTIL LINE DONE         JEP005\n         B     CHGO1               FINISHED                     JEP005\nUPPARTB  EQU   *                   STRING CHG SECT              JEP005\n         CLC   0(1,R1),0(R6)       BEGINNING CHAR??             JEP005\n         BNE   LOOPCTRL            NOT YET                      JEP005\n         EX    R5,COMP             FIRST  YES, REST = YES??     JEP005\n         BNE   LOOPCTRL            NOT YET                      JEP005\n         OI    CVSPARES+11,X'01'   TELL EM WE MADE IT           JEP005\n         EX    R5,ORCHAR           CHANGE IT TO UPPER           JEP005\n* WE DON'T NEED TO SET R5 TO REAL LENGTH                        JEP005\n* BECAUSE OF LA AT LOOPCTRL                                     JEP005\n         AR    R1,R5               BUMP PAST MATCH              JEP005\n* NOW WE NEED REAL LENGTH                                       JEP005\n         LA    R5,1(R5)            UP TO REAL LENGTH            JEP005\n         SR    R0,R5               DOWN BY LEN OF STRING        JEP005\n         BCTR  R5,0                BACK DOWN FOR LATER          JEP005\n         LTR   R0,R0               ANY LEFT TO CHECK??          JEP005\n         BC    2,LOOPCTRL          YES - GO GET EM              JEP005\n         B     CHGO1               FINISHED                     JEP005\nLOOPCTRL EQU   *                                                JEP005\n         TM    CPLFLG2,CPFCHLIM    POSITIONALLY DEFINED?        JEP005\n         BO    CHGO1               ALLOW ONLY 1 SHOT IF SO      JEP005\n         LA    R1,1(R1)            BUMP THE TEXT PTR            JEP005\n         BCT   R0,UPPARTB          GO DO UNTIL DONE             JEP005\n         B     CHGO1               ALL DONE                     JEP005\nCHALL    OC    0(EXCHUP,R1),BLANKS      CHANGE LINE TO UPPER CASJEP005\n         OI    CVSPARES+11,X'01'        TURN ON OUR CHG FLAG    JEP005\n         B     CHGO                                             JEP005\nCHGO1    LM    R0,R1,CVSPARES      RELOAD REGS                  JEP005\nCHGO     L     R15,CPLCNO               PICK UP LINE NUMBER     JEP005\n         ST    R15,CPCURRL              CURRENT LINE POINTER    JEP005\n         TM    CVSPARES+11,X'01'        DID WE REALLY CHG SOME??JEP005\n         BO    SETCHG                   YEP...LIST IT & GO      JEP005\n         B     DONLIST1                 NO....DON'T LIST        JEP005\nSETCHG   OI    CPLFLG2,CPFCHNGD         SET CHANGED SOMETHING   JEP005\n         NI    CVSPARES+11,X'FE'        RESET FOR NEXT LINE     JEP005\n        CVCALL LENCHK           INSURE CORRECT LEN & TABS DONE  JEP005\n         TM    CPLFLG5,CPFNLST          DO HE WANT LISTED????   JEP005\n         BO    DONLIST1                 NO...THATS ALL          JEP005\n        CVCALL LISTLINE                 MAKE THE LISTING        JEP005\n         L     R15,CPLCNO               RELOAD R15              JEP005\n         BNP   DONLIST1                 CONTINUE (NO ATTN)      JEP005\n         OI    CPLFLG2,CPFCHND          TURN ON TERMINATE FLAG  JEP005\n         B     DONLIST1                 GO BACK                 JEP005\nEXCHUP   EQU   133                      LENGTH OF LINE          JEP005\nBLANKS   DC    168C' '                                          JEP005\nORCHAR   OC    0(0,R1),BLANKS           RAISE TO UPPER CASE     JEP005\nCOMP     CLC   0(0,R1),0(R6)            ARE WE MATCHED YET????  JEP005\nCOMP1    CLC   0(0,R6),0(R4)                                    JEP005\nMOVEIT   MVC   0(0,R1),0(R4)                                    JEP005\n         EJECT                                                  JEP005\nCHLO     EQU   *                                                JEP005\n         LTR   R0,R0                         CHECK FOR BLANK LN JEP005\n         BZ    CHGO                          IF YES...GET OUT   JEP005\n         STM   R0,R1,CVSPARES           SAVE FOR LATER          JEP005\n         LR    R4,R1                    POINT R4 TO DATA        JEP005\n         TM    CPLFLG3,CPFCHALL         CHANGE WHOLE LINE???    JEP005\n         BO    CHLOALL                  YES                     JEP005\nEXCOMP1  EX    R5,COMP1                 IS THIS IT???           JEP005\n         BNE   REGCOMP                  NOPE, NOT YET           JEP005\n         CLI   0(R4),X'4B'              IT THIS A PERIOD???     JEP005\n         BE    PERIOD                   YES                     JEP005\n         CLI   0(R4),X'5A'              IT THIS A EXCLAMATION?? JEP005\n         BE    PERIOD                   YES                     JEP005\n         CLI   0(R4),X'6F'              IT THIS A QUESTION???   JEP005\n         BE    PERIOD                   YES                     JEP005\nSPACECHK CLI   0(R4),X'40'              IS THIS A BLANK????     JEP005\n         BE    PERCHK                   YES, SEE IF AFTER PERIODJEP005\nSPCCHK1  CLI   0(R4),X'D0'              IS CHAR A BRACE???      JEP005\n         BE    REGCOMP                  YES, DON'T CHG IT       JEP005\n         CLI   0(R4),X'C1'              MUST BE AT LEAST AN 'A' JEP005\n         BL    REGCOMP                  GO SEE IF DONE          JEP005\n         CLI   0(R4),X'E9'              CAN'T BE > Z (NUMERIC)  JEP005\n         BH    REGCOMP                  GO SEE IF DONE          JEP005\n         OI    CVSPARES+11,X'01'        TURN ON OUR CHG FLAG    JEP005\n        NI    0(R4),X'BF'              CHANGE CHAR TO LOWER CASEJEP005\n         NI    CVSPARES+12,X'FE'        TURN OFF PERIOD FLAG    JEP005\nREGCOMP  LA    R4,1(R4)                 BUMP TO NEXT CHAR       JEP005\n         BCT   R0,EXCOMP1               DOWN 1 AND GO IF > 0    JEP005\nBACK     EQU   *                                                JEP005\n         B     CHGO1                    GO RELOAD R0, LIST & GO JEP005\nPERIOD   TM    CPLFLG3,CPFCHALL         IS THIS CHG ALL???      JEP005\n         BO    ALLPERCK                 YES                     JEP005\n         CLI   1(R4),X'40'              IS NEXT CHAR A BLANK??? JEP005\n         BNE   SPCCHK1                  NOT END OF SENTENCE     JEP005\nPER1     LA    R4,2(R4)                 YES...ASSUME SPACE      JEP005\n         SH    R0,=H'2'                 SUBTRACT 2              JEP005\n         LTR   R0,R0                    FIND OUT IF END YET     JEP005\n         BNP   BACK                     END....GET OUT          JEP005\n         OI    CVSPARES+12,X'01'        TURN ON PERIOD FLAG     JEP005\nMORESPCS CLI   0(R4),X'40'        IS NEXT ONE BLANK ALSO?       JEP005\n         BNE   PER2               FINISHED                      JEP005\n         LA    R4,1(R4)           BUMP POINTER                  JEP005\n         BCTR  R0,0               DOWN 1 ON REMAINING           JEP005\n         LTR   R0,R0              DID WE GO NEGATIVE?           JEP005\n         BNP   BACK               YES...GET OUT                 JEP005\n         B     MORESPCS           GO CHECK FURTHER              JEP005\nPER2     LA    R4,1(R4)           BUMP POINTER PAST FIRST       JEP005\n         BCTR  R0,0               DOWN ONE ON REMAINING         JEP005\n         LTR   R0,R0              DID WE GO NEGATIVE            JEP005\n         BNP   BACK               YES...GET OUT                 JEP005\n         TM    CPLFLG3,CPFCHALL         IF CHG ALL GO THERE     JEP005\n         BO    SPCCHK3                                          JEP005\n         B     SPCCHK1                  CONTINUE                JEP005\nALLPERCK EQU   *                                                JEP005\n         CLI   1(R4),X'40'              NEXT CHAR A BLANK???    JEP005\n         BNE   SPCCHK3                  NO, LEAVE               JEP005\n         B     PER1                     YES, GO SKIP OVER       JEP005\nPERCHK   TM    CPLFLG3,CPFCHALL         ARE WE CHANGING ALL???  JEP005\n         BO    ALLCHK                   YES                     JEP005\n         TM    CVSPARES+12,X'01'        PERIOD FLAG ON????      JEP005\n        BNO   REGCOMP                  NO...GO BUMP REGS & CONT.JEP005\nUPRTBPTR LA    R4,2(R4)                 YES, MUST BE MULT SPACESJEP005\n         SH    R0,=H'2'                 ASSUME BLANK & CAP      JEP005\n         LTR   R0,R0                    FIND OUT IF END YET     JEP005\n         BNP   BACK                     END....GET OUT          JEP005\n         TM    CPLFLG3,CPFCHALL         IF CHG ALL GO THERE     JEP005\n         BO    SPACECH2                                         JEP005\n         B     SPACECHK                 NOT DONE....CONTINUE    JEP005\nALLCHK   EQU   *                                                JEP005\n         TM    CVSPARES+12,X'01'        PERIOD FLAG ON???       JEP005\n         BNO   SPCCHK3                  NOT US...CONTINUE       JEP005\n         B     UPRTBPTR                 CONTINUE WITH THE CHECK JEP005\nCHLOALL  EQU   *                        HERE FOR CHG WHOLE LINE JEP005\nCHLOALL1 CLI   0(R4),X'4B'              IT THIS A PERIOD???     JEP005\n         BE    PERIOD                   YES                     JEP005\n         CLI   0(R4),X'5A'              IT THIS AN EXCLAMATION? JEP005\n         BE    PERIOD                   YES                     JEP005\n         CLI   0(R4),X'6F'              IT THIS A QUESTION???   JEP005\n         BE    PERIOD                   YES                     JEP005\nSPACECH2 CLI   0(R4),X'40'              IS THIS A BLANK????     JEP005\n         BE    PERCHK                   YES, SEE IF AFTER PERIODJEP005\nSPCCHK3  EQU   *                                                JEP005\n         CLI   0(R4),X'D0'              IS CHAR A BRACE???      JEP005\n         BE    BUMP4                    YES, DON'T CHG IT       JEP005\n         CLI   0(R4),X'C1'              MUST BE AT LEAST AN 'A' JEP005\n         BL    BUMP4                    GO SEE IF DONE          JEP005\n         CLI   0(R4),X'E9'              CAN'T BE > Z (NUMERIC)  JEP005\n         BH    BUMP4                    GO SEE IF DONE          JEP005\n         OI    CVSPARES+11,X'01'        TURN ON OUR CHG FLAG    JEP005\n        NI    0(R4),X'BF'              CHANGE CHAR TO LOWER CASEJEP005\n         NI    CVSPARES+12,X'FE'        TURN OFF PERIOD FLAG    JEP005\nBUMP4    LA    R4,1(R4)                 BUMP TO NEXT CHAR       JEP005\n         BCT   R0,CHLOALL1              DOWN 1 AND DO IT AGAIN  JEP005\nCHLODONE EQU   *                                                JEP005\n         B     BACK                     GO RELOAD R0, LIST & GO JEP005\n.LBL03   DS    0H                                               JEP00X\nGOTLIM   EX    R3,MOVESTR1              MVC C32+C8(0,8),0(R1)\n         LA    R1,0(R1,R3)              SET LIMITED SCAN POINTER\n         SR    R2,R3                    LESS NO CHARS ALREADY MOVED\n         LTR   R0,R4                    NO. POSSIBLE START POINTS\n         BNZ   SKIP1                    OK\n         LA    R0,1                     1 START POINT\nSKIP1    LA    R4,C32+C8(R8,R3)         SET OUT POINTER\n         B     MCLIA                    GO LOOK\n         SPACE\nPOSCHANG EX    R3,MOVESTR1              MVC C32+C8(0,8),0(R1)\n         AR    R4,R3                    DISP TO NEXT SOURCE MOVE\n         SR    R2,R4                    NO CHARS LEFT TO MOVE\n         AR    R1,R4                    PTR TO CHARS LEFT TO MOVE\n         LA    R4,C32+C8(R8,R3)         SET OUT POINTER\n         SR    R0,R0                    SCAN COUNT ZERO\n         B     POSENTER                 TO COMMON CODE\n         TITLE 'DODELE ROUTINE'\n* DODELE CHARRIES OUT A LINE DELETE\n* DODELEL IS ENTRY FOR DELETE COMMAND -- DODELE IS ENTRY FOR OTHERS\n*\n* EXPECTS R15 TO BE POINTED AT THE R9 START OF THE PRESSED LINE\n* TO BE DELETED.\n         SPACE\nDODELEL  XENTER 0,8,C32+SZR+8      SET UP LIST WORK AREA\n         PFLIP 11,9                PUT PAGE IN R9\n         MVI   0(R8),X'80'         FLAG AS DELETE COMMAND\n         TM    CPLFLG5,CPFNLST     ANY LIST TO DO\n         BO    DODELE1             NO, GO DO DELETE\n         LR    R2,R15              SAVE POINTER TO LINE\n         LA    R1,C32+8(R8)        POINT TO UNPRESS AREA\n         CVCALL UNPRESS            GO UNPRESS LINE\n         CVCALL LISTLINE            FORMAT LINE FOR LIST\n         BP    CVQTYPE             ABORT IF HIT ATTN.\n         LR    R15,R2              RESTORE POINTER TO LINE\n         B     DODELE1             GO DELETE LINE\n         SPACE\nDODELE   XENTER 0,8,*                   SAVE REGS\n         MVI   0(R8),0             FLAG NOT DELETE AND NO LIST\nDODELE1  EQU   *\n         GENTER ,                  ESTABLISH COMMON BASE\nDELRTN   MVC    CPWORK1(4),CPLCNO\n         SR    R3,R3                    ZERO FOR IC INST\n         IC    R3,4(,R15)               PRESSED COUNT DELETE LINE\n         LA    R3,5(,R3)                DELETE COUNT\n         LH    R5,0(,R9)               TOTAL COUNT FOR PAGE\n         LA    R6,0(R9,R5)          POINTER TO AFTER LAST BYTE ON PAGE\n         LA    R2,0(R15,R3)             SOURCE FOR MVC (TARGET IN R15)\n         TM    CPDRPT,CPFPGLW           DELETE FIRST LINE ON PAGE?\n         BO    CHKPGDL                  YES\nFIXCNT   SR    R5,R3                    NEW PAGE COUNT\n         STH   R5,0(,R9)               RESET COUNT\n         PMARK R9                       MARK PAGE\n         TM    CPDRPT,CPFPGND+CPFNDDS   DELETE LAST LINE ON PAGE?\n         BO    FIXHIPS                  LAST LINE OF DATA SET\n         BM    FIXLCNT                  LAST LINE OF PAGE\n         SR    R6,R2                    NO. CHARS TO MOVE\n         BNP   FIXLCNT                     NO MOVE\n         BAL   R14,DELMVC               GO MOVE UP LINES\nFIXLCNT  SLR   R1,R1\n         ICM   R1,3,CPLNCT                LINE COUNT\n         BCTR  R1,0                     REDUCE BY ONE\n         STH   R1,CPLNCT                RESET\nDONET    XEXIT R0,R8                    SCRAM\n         EJECT\nCHKPGDL  OI    CPGFLG,CPFDIRCH         NO, SET DIR CHANGED\n         L     R4,CPDRPT               POINT TO DIR ENTRY\n         TM    CPDRPT,CPFPGND           ALSO LAST LINE ON PAGE?\n         BO    DELPAG                   YES, DELETE PAGE\n         MVC   0(4,R4),0(R2)            RESET 1ST LINE NO. ON PAGE\n         TM    0(R8),X'80'         IS IT DELETE COMMAND\n         BE    FIXCNT              BRANCH NO\n         MVC   CPNWLN,0(R2)        YES, SET CPNWLN FOR NEXT LOCAT\n         OI    CPLFLG4,CPFDESET    TELL DESPOT THAT CPNWLN SET\n         B     FIXCNT                   FINISH\n         SPACE\nDELPAG   OI    CPGFLG,CPFDIRCH     SET DIR CHANGED FOR PAGE DEL\n         LH    R1,CPAGCT                PAGE COUNT\n         BCT   R1,NTONLIPG              REDUCE (& SEE IF ONLY PAGE)\n         MVC   CPHIPS(8),=D'0'          ZERO HI-PS,LNCT,PGCT\n         MVC   CPDREC(4),=D'0'          ZERO IST LINE NO.\n         MVI   CPLSTCOL,FNEGBT          SET AS FIRST COLLECT\n         PFREE R9,EMPTY                 FREE ONLY PAGE\n         B     DONET                    SCRAM\n         SPACE\nNTONLIPG STH   R1,CPAGCT                RESET PAGE COUNT\n         TM    CPDRPT,CPFNDDS           LAST LINE?\n         BO    NOWFREE                  YES\n         MH    R1,=Y(6)                 NO. BYTES IN NEW DIREC\n         LA    R6,CPDREC(R1)            POINT PAST END NEW DIREC\n         LA    R15,0(R4)                SET TARGET ADDR & ZERO 1ST BYTE\n         SR    R6,R15                   COUNT TO MOVE\n         LA    R2,6(R15)                SOURCE FOR MOVE\n         BAL   R14,DELMVC               GO MOVE UP DIRECTORY\nNOWFREE  PFREE R9,EMPTY                 FREE EMPTY PAGE\nCHKHIPS  TM    CPDRPT,CPFNDDS           LAST LINE?\n         BZ    FIXLCNT                  NO\n         PFLIP R9,R11                   SAVE ANY PAGE IN R11\n         LA    R1,CPLCNO                NEED NEW HI-POS\n         CVCALL LOCATE                   LOCATE IT\n         PFLIP R11,R9                   RESTORE REGS\nFIXHIPS  MVC   CPHIPS(4),CPREVLN        SET NEW HIGH POSITION\n         B     FIXLCNT                  FINISH\n         EJECT\nDELMVC   LA    R5,256                   SET COMPARAND-INCREMENT\nCHKMVC   CR    R6,R5                    A 256 BYTE MVC?\n         BNH   FNNMVC                   NO\n         MVC   0(256,R15),0(R2)         MOVE 256 BYTES\n         AR    R2,R5                    NEW SOURCE ADDR\n         AR    R15,R5                   NEW TARGET ADDR\n         SR    R6,R5                    LEFT-OVER COUNT\n         B     CHKMVC                   ANOTHER FULL MVC?\n         SPACE\nFNNMVC   BCTR  R6,0                     REDUCE FOR EX OF MVC\n         EX    R6,LSSMVC                MVC   0(0,R15),0(R2)\n         BR    R14                      RETURN TO CALLER\n         TITLE 'REMOTE INSTRUCTIONS'\n* FOR CHANGE COMMAND\n         SPACE\nMOVECHNG MVC   0(0,R4),0(R15)\nCHNMVC   MVC   12(0,R13),12(R15)\nCHNEDMK  EDMK  12(0,R13),CPDOUB+3\n         SPACE 3\n* FOR DELETE\n         SPACE\nLSSMVC   MVC   0(0,R15),0(R2)\n         TITLE 'LITERALS'\n         LTORG\n         TITLE 'STOWIT ROUTINE'\n         SPACE\n* STOWIT REPLACES OR INSERTS A LINE INTO A WYLBUR DATA SET.  CALL WITH\n*        REG 0 - PRESSED COUNT OF LINE.\n*            1 - PTR TO PRESSED LINE (B/4 LINE NO)\n*\n* CPLFLG4 HAS SOME FLAG BIT DEFINITIONS THAT AFFECT THE OPERATION\n* OF STOWIT:\n*        CPFSTSPL - IF THE INSERT-ONLY FLAG IS ALSO ON, THIS\n*              FLAG SIGNALS THAT A PAGE SPLIT, IF NECESSARY,\n*              SHOULD BE DONE AT THE LINE NUMBER TO INSERT\n*              RATHER THAN SIMPLY DIVIDING THE PAGE IN HALF.\n*              COPY, MOVE, AND COLLECT USE THIS TO REDUCE THE\n*              WORK NEEDED TO DO LARGE NUMBERS OF LINES.\n*        CPFSTINS - THIS FLAG SIGNALS THAT ONLY INSERTS OF LINES\n*              SHOULD BE DONE BY STOWIT.  IF A REPLACE IS\n*              ATTEMPTED, IT IS NOT DONE AND AN ERROR RETURN\n*              CODE IS GIVEN INSTEAD.\n*\n* R15 RETURN CODES -- LTR IS DONE TO ALSO SET CC\n*        -4    REPLACE OF A LINE ATTEMPTED IN INSERT ONLY MODE\n*        0     STOWIT COMPLETED OKAY\n         SPACE\nSTOWIT   XENTER R2,R8,C32+8+4+8\n         MVC   C32+8(4,R8),CPHIPS       SET HI POS\n         LR    R2,R0                    SAVE PTRS\n         LR    R3,R1\n         SLR   R6,R6\n         ICM   R6,3,CPLNCT               LINE COUNT\n         C     R6,=X'0000FFFF'         TOO BIG?\n         BE    TOOPGS                  TOO BAD...\n         LH    R6,CPAGCT                PAGE COUNT\n         CLC   0(4,R3),CPHIPS           HIGHEST LINE NO YET?\n         BL    NTHI                     NO\n         BE    CKZR                     IF ZERO, YES\n         MVC   CPHIPS(4),0(R3)          RESET HI POSITION\n         LTR   R5,R6                    FIRST LINE OF ALL?\n         BZ    FSTPAG                   YES\n         MH    R5,=Y(6)\n         LA    R5,CPDREC-6(R5)          LAST ENTRY IN DIRECTORY\n         BAL   R4,STWPGET               GET LAST PAGE\n         LH    R4,0(R11)                COUNT ON PAGE\n         CH    R4,=Y(9*CPSIZE/10)       ROOM?\n         BH    NEWPAG                   NO\n         SPACE\n* PUT LINE INTO END OF PAGE\nALLSET   LA    R15,0(R4,R11)            NEXT AVAILABLE SPOT ON PAGE\n         LA    R4,5(R4,R2)              NEW COUNT\n         STH   R4,0(R11)\n         LA    R6,4(R2)                 FOR REMOTE MVC\n         EX    R6,MOVIT1\nCNTXIT   SLR   R6,R6\n         ICM   R6,3,CPLNCT                KICK LINE COUNT\n         LA    R6,1(R6)\n         STH   R6,CPLNCT\nMEXIT    PMARK R11\n         SR    R15,R15                  SET NO ERROR\n         MVC   CPWORK1(4),0(R3)\nFIXOT    XEXIT R2,R8,LTR                SCRAM\n         SPACE\nCKZR     LTR   R6,R6                    ANYTHING YET\n         BNZ   NTHI                     YES\nFSTPAG   LA    R5,CPDREC-6              SET BEFORE NEXT DIRECTORY ENTRY\nNEWPAG   BAL   R6,PGETT                 GET TXPG & PGCT TO R6\nJUMPIN   LA    R6,1(R6)                 BUMP PAGE COUNT\n         STH   R6,CPAGCT\n         STH   R0,10(R5)                PAGE NO &\n         MVC   6(4,R5),0(R3)            1ST LINE NO TO DIREC.\n         LA    R4,2\n         B     ALLSET\n         EJECT\n* NOT HIGHEST LINE NO. OF ALL\n         SPACE\nNTHI     LA    R5,CPDREC                1ST DIREC ENTRY\n         CH    R6,=Y(8)                IS PAGE COUNT > 8\n         BNH   LOOPSKIP                NO SKIP BINARY SEARCH\n         LA    R0,64                   SET PAGE COUNT STEP\n         LA    R1,384                  SET BYTE COUNT STEP\n         LA    R4,3                    SET LOOP COUNT\nLOOP1    SR    R6,R0                   SET NEW PAGE COUNT\n         BNH   LOOPEND1                BRANCH PAST END\n         AR    R5,R1                   POINT TO DIR VALUE\n         CLC   0(4,R3),0(R5)           COMPARE LINE NUMBERS\n         BH    LOOP1                   HIGH, CONTINUE SEARCH\n         SR    R5,R1                   RESET DIR POINTER\nLOOPEND1 AR    R6,R0                   RESET PAGE COUNT\n         SRDL  R0,2                    QUARTER STEPS FOR NEXT LP\n         BCT   R4,LOOP1                LOOP WITH NEW STEPS\nLOOPSKIP BCT   R6,NXCMPA                MORE THAN 1 PAGE EXISTS\n         B     HAVPAG                   ONLY 1, THAT'S IT\n         SPACE\nNXCMPA   CLC   6(4,R5),0(R3)            CHECK NEXT\n         BH    HAVPAG                   HAVE IT NOW\n         LA    R5,6(R5)                 TRY NEXT,\n         BCT   R6,NXCMPA                IF MORE\nHAVPAG   STM   R5,R6,C32+12(R8)         SAVE PTRS\n         BAL   R4,STWPGET               GET PAGE\n         SPACE\n* LOCATE THE LINE NO.(OR NEXT HIGHEST) ON PAGE\n         LH    R14,0(R11)               TOTAL COUNT\n         SR    R5,R5                    FOR IC\n         LA    R4,2                     START COUNT\n         LA    R15,2(R11)               PT TO 1ST LINE ON PAGE\nNXCMPB   IC    R5,4(R15)                LINE COUNT\n         CLC   0(4,R15),0(R3)           WANTED LINE\n         BNL   REPORIN                  YES\n         LA    R4,5(R4,R5)              KICK COUNT\n         LA    R15,5(R15,R5)            & PTR\n         CR    R4,R14                   MORE?\n         BL    NXCMPB                   YES\n         SPACE\n* INSERT AT END OF PAGE (NOT LAST)\n         CH    R4,=Y(9*CPSIZE/10)       ROOM?\n         BNH   ALLSET                   YES\n         SPACE\n* ONTO NEW PAGE\n         BAL   R6,PGETT                 GET A PAGE\n         LM    R5,R6,C32+12(R8)\n         MH    R6,=Y(6)                 MOVE-UP DIRECTORY BYTE COUNT\n         BAL   R4,MVDRCTRY              MOVE UP DIREC ENTRIES\n         LH    R6,CPAGCT                PAGE COUNT\n         B     JUMPIN                   FINISH\n         EJECT\n* INSERT BEFORE SOMETHING OR REPLACE\n         SPACE\nREPORIN  LR    R6,R2                    NEW LINE PRESSED COUNT\n         BH    INSERT                   GO TO INSERT\n         TM    CPLFLG4,CPFSTINS    INSERT ONLY MODE???\n         BO    STREPERR            YES, REPLACE IS AN ERROR\n         SR    R6,R5                    LINE LENGTH DIFFERENCE\n         BP    MOREREP                  NEW LONGER\n         EX    R2,MOVIT2                MOVE NEW LINE (WITHOUT NO)\n         BZ    MEXIT                    DONE IF SAME LEN\n         AR    R6,R14                   NEW PAGE COUNT\n         STH   R6,0(R11)\n         LA    R4,5(R4,R5)              COUNT TILL MOVE START\n         SR    R14,R4                   COUNT TO MOVE UP\n         BNP   MEXIT                    NONE TO MOVE\n         LA    R1,5(R15,R2)             TARGET\n         LA    R15,5(R15,R5)            SOURCE\n         LA    R4,MEXIT                 RETURN\n         B     MOVBLCK                  MOVE\n         SPACE\n* ERROR -- TRYING TO REPLACE WHEN ONLY INSERTS ARE ALLOWED\nSTREPERR LH    R15,=H'-4'          SET RETURN CODE\n         B     FIXOT               GO EXIT\n         EJECT\n* REPLACE WITH INCREASING PAGE SIZE\n         SPACE\nMOREREP  AR    R6,R14                   NEW TOTAL COUNT\n         CH    R6,=Y(CPSIZE)            WILL IT FIT\n         BH    SPLIT                    NO\n         LA    R4,5(R4,R5)              COUNT TO AFTER REPLACE LINE\n         SR    R14,R4                   MOVE-OUT COUNT\n         BZ    SNEEKY                   END-OF-PAGE REPLACE\n         SR    R15,R11                  RELATIVE DISPL\n         STM   R14,R15,C32(R8)          SAVE MOVE CT & PTR\n         STH   R6,0(R11)                NEW PAGE COUNT\n         LM    R14,R15,C32(R8)          RELOAD\n         AR    R15,R11                  ACTUAL DISPL\n         LA    R15,5(R15,R5)            SOURCE\n         L     R1,JCBWAPTR             AS TEMPORARY TARGET\n         BAL   R4,MOVBLCK               MOVE OUT\n         LM    R14,R15,C32(R8)          RELOAD\n         AR    R15,R11                  ACTUAL DISPL\n         EX    R2,MOVIT2                MOVE IN NEW LINE\n         LA    R1,5(R15,R2)             TARGET\n         L     R15,JCBWAPTR              BUFFER ADDRESS\n         BAL   R4,MOVBLCK               MOVE BACK\n         B     MEXIT                    BYE\n         SPACE\nSNEEKY   EX    R2,MOVIT2                MOVE (LAST LINE ON PAGE)\n         STH   R6,0(R11)                NEW PAGE COUNT\n         B     MEXIT\n         EJECT\n* INSERT A LINE\n         SPACE\nINSERT   LA    R6,5(R6,R14)             NEW PAGE COUNT\n         ST    R4,C32(,R8)         SAVE LINE POSITION FOR SPLIT\n         CH    R6,=Y(CPSIZE)            WILL IT FIT?\n         BH    SPLIT                    NO\n         SR    R14,R4                   MOVE-OUT COUNT\n         SR    R15,R11                  RELATIVE DISPL\n         STM   R14,R15,C32(R8)          SAVE\n         STH   R6,0(R11)                NEW PAGE COUNT\n         LM    R14,R15,C32(R8)          RELOAD\n         AR    R15,R11                  ACTUAL DISPL\n         L     R1,JCBWAPTR\n         BAL   R4,MOVBLCK               MOVE OUT\n         LM    R14,R15,C32(R8)          RELOAD\n         AR    R15,R11                  ACTUAL DISPL\n         LA    R6,4(R2)                 SET EX COUNT\n         EX    R6,MOVIT1                MOVE IN INSERT\n         LA    R1,5(R15,R2)             TARGET\n         L     R15,JCBWAPTR\n         BAL   R4,MOVBLCK               MOVE BACK\n         CLC   0(4,R3),2(R11)           NEW 1ST LINE ON PAGE?\n         BH    CNTXIT                   NO\n         L     R14,C32+12(R8)           SAVED POINTER TO DIREC ENTRY\n         MVC   0(4,R14),0(R3)           SET NEW FIRST LINE NO. ON PAGE\n         B     CNTXIT                   COUNT LINE & GO\n         EJECT\n* MOVBLCK MOVES A BLOCK, SOURCE IN R15, TARGET IN R1, LENGTH IN R14,\n*        RETURN ADDR IN R4.\n         SPACE\nMOVBLCK  CH    R14,=Y(256)              OVER 256 CHARS?\n         BNH   MOVLAS                   NO\n         MVC   0(256,R1),0(R15)         YES - MOVE 256\n         LA    R1,256(R1)               KICK TARGET POINTER\n         LA    R15,256(R15)             KICK SOURCE POINTER\n         SH    R14,=Y(256)              REDUCE REMAINING COUNT 256\n         B     MOVBLCK                  CHECK WHAT'S LEFT\nMOVLAS   BCTR  R14,0                    REDUCE FOR EX INST.\n         EX    R14,MOVEXM               MOVE BALANCE\n         BR    R4                       RETURN\n         SPACE\nMOVEXM   MVC   0(0,R1),0(R15)\n         SPACE\nMVDRCTRY LA    R1,6(R5,R6)              PAST LAST SOURCE BYTE\n         LA    R14,256                  CONSTANT\nMVLOOP   CR    R6,R14                   OVER 256 CHARS?\n         BNH   LASMOV                   NO, LAST MVC\n         SR    R1,R14                   SET SOURCE THIS MOVE\n         MVC   0(256,R11),0(R1)         MOVE TO SCRATCH AREA\n         MVC   6(256,R1),0(R11)         MOVE TO TARGET AREA\n         SR    R6,R14                   REDUCE REMAINING COUNT\n         B     MVLOOP                   MORE?\n         SPACE\nLASMOV   SR    R1,R6                    LAST MOVE SOURCE\n         BCTR  R6,0                     REDUCE FOR EX INST.\n         EX    R6,DRMVC1                LAST SCRATCH MOVE\n         EX    R6,DRMVC2                LAST TARGET MOVE\n         BR    R4                       FIN\n         EJECT\n* SPLITS PAGE IF NOT ENOUGH ROOM\n         SPACE\nSPLIT    PFLIP 11,9                     P(11) TO P(9)\n         BAL   R6,PGETT                 GET A PAGE\n         LA    R6,1(R6)                 KICK PAGE COUNT\n         STH   R6,CPAGCT\n         LM    R5,R6,C32+12(R8)         GET SAVED PTRS\n         MH    R6,=Y(6)                 MOVE-OUT COUNT\n         LTR   R6,R6                    LAST PAGE?\n         BNP   NTMOOV                   ADDING LAST DIRECTORY ENTRY\n         BAL   R4,MVDRCTRY              MOVE UP DIREC ENTRIES\nNTMOOV   STH   R0,10(R5)                SAVE NEW PAGE NO\n         LH    R14,0(R9)                OLD COUNT\n         LR    R0,R14                   TO RO\n         SRL   R0,1                     HALVE\n         TM    CPLFLG4,CPFSTSPL+CPFSTINS SPLIT AT LINE FOR INSERT\n         BNO   *+8                 BRANCH NO\n         L     R0,C32(,R8)         YES, SET COUNT TO INSERT COUNT\n         SR    R4,R4                    ZERO\n         LA    R6,2                     INIT\n         LA    R15,2(R9)                POINT AT 1ST LINE\nNXCMPC   IC    R4,4(R15)                COUNT\n         LA    R6,5(R6,R4)              KICK CTR\n         LA    R15,5(R15,R4)            & PTR\n         CR    R6,R0                    ENOUGH\n         BL    NXCMPC                   NO\n         SR    R14,R6                   MOVE COUNT\n         STH   R6,0(R9)                 NEW P9 COUNT\n         LA    R6,2(R14)                KICK\n         STH   R6,0(R11)                NEW P11 COUNT\n         MVC   6(4,R5),0(R15)           NEW 1ST LINE NO ON PAGE\n         LA    R1,2(R11)                TARGET\n         BAL   R4,MOVBLCK               MOVE\n         CLC   2(4,R11),0(R3)           WHICH ONE FOR 11\n         BNH   NOFLIP                   THIS ONE\n         PFLIP 11,9                     FLIP\nNOFLIP   PMARK 9                        MARK\n         PFREE 9\n         PMARK 11                  ALSO MARK R11\n         LH    R6,CPAGCT                PAGE COUNT\n         B     NTHI\n         EJECT\n* STWPGET PLACES THE PAGE POINTED AT BY 4(R5) INTO PAGE \"11\"\n*        RETURNS ON R4\n         SPACE\nSTWPGET  LTR   R11,R11                  ANYTHING IN 11?\n         BZ    TRY9                     NO\n         PNUM  11                       WHAT?\n         CH    R0,4(R5)                 WANTED ONE?\n         BER   R4                       YES\nTRY9     LTR   R9,R9                    ANYTHING IN 9?\n         BZ    DOGET                    NO\n         PNUM  9                        WHAT?\n         CH    R0,4(R5)                 WANTED ONE?\n         BNE   DOGET                    NO\n         PFLIP 11,9                     INTO 11\n         BR    R4                       DONE\n         SPACE\nDOGET    LH    R0,4(R5)                 SET POINTER\n         PGET  11,(0)                   GET PAGE\n         BR    R4                       DONE\n         EJECT\n* NEED ANOTHER TEXT PAGE\n         SPACE\nPGETT    CLC   CPAGCT(2),=Y(CPTNPG)     STILL DIRECTORY SPACE?\n         BNL   TOOPGS                   NO\nGTEXPG   PGET  11                       GET TEXT PAGE\n         BZ    NOTAPAG                  NOMORE\n         LR    R14,R6                   SETUP FOR RETURN\n         LH    R6,CPAGCT                SET WITH PAGE COUNT\n         OI    CPGFLG,CPFDIRCH         SET DIRECTORY CHANGED\n         BR    R14                      BYE - BYE\n         EJECT\n* NO PAGES ANYWHERE\n         SPACE\nNOTAPAG  MVC   CPHIPS(4),C32+8(R8)      RESET HI POSITION\n         LA    R15,16\n         TM    CPLFLG3,CPFPUT           DOING A PUT?\n         BO    FIXOT                     YES, RETURN TO MAMA\n         XCALL NOMORPG\n         SPACE 3\n* USER WANTS TOO MANY TEXT PAGES\n         SPACE\nTOOPGS   MVC   CPHIPS(4),C32+8(R8)      RESET HI POSITION\n         XC    RTBWC(4),RTBWC\n         TSEG  'WORKING FILE TOO BIG, COMMAND ABORTED'\n         CLC   CPCMNM(3),=CL3'COP'      FROM COPY?\n         BE    CHKMOR1                  YES\n         TM    CPLFLG3,CPFPUT           DOING A PUT?\n         BZ    HOWUSE                    NO. BRANCH\n         TWRITE ,\n         LA    R15,12\n         B     FIXOT\n         SPACE\nHOWUSE   CLC   CPCMNM(3),=CL3'USE'      FROM USE?\n         BNE   CVQTYPE                  NO\n         MVC   CPWORK2(4),CPDREC\n         MVC   CPWORK1(4),CPHIPS\n         B     FINIS1                   GET READY TO GO\n         SPACE\nCHKMOR1  TM    CPLFLG5,CPFSELOC         EXTERNAL COPY?\n         BNO   CVQTYPE                  NO\nFINIS1   DCLOSE ,                       CLOSE EXTERNAL DATA SET\n         NI    CPGFLG,255-CPFOPN        TURN OFF OPEN FLAG\n         B     CVQTYPE\n         TITLE 'UNPRESS ROUTINE'\n* UNPRESS SUBROUTINE - UNPRESSES A LINE IN EDIT FORMAT\n*        CALL WITH RETURN AREA POINTED TO BY R1 (AT LEAST 133 BYTES)\n*                  PRESSED LINE POINTED TO BY R15 (BEFORE LINE NO.)\n*        RETURNS R1 INTACT\n*                R0 WITH UNPRESSED CHAR COUNT\n*                R15 WITH INTERNAL LINE NO.\n         SPACE\nUNPRESS  SENTER R1,R7         SAVE REGS\n         MVC   CPDOUB(4),0(R15)    MAKE ALIGNED LINE-NO AVAILABLE\n         MVI   0(R1),C' '     BLANK RETURN AREA\n         MVC   1(MXPRTSZ-1,R1),0(R1)\n         SR    R6,R6          ZERO COUNTER\n         SR    R5,R5          ZERO FOR IC INSTRUCTION\n         IC    R5,4(R15)      PRESSED-LINE COUNT\n         LTR   R5,R5          TEST\n         BNP   FINUNP         BLANK LINE\n         LA    R1,0(R1)       CLEAR 1ST BYTE\n         SR    R4,R4          ZERO FOR IC INSTRUCTIONS\nMORECH   IC    R4,5(R15)      GET BLANK-CHAR COUNT BYTE\n         LA    R3,X'0F'       SET MASK\n         NR    R3,R4          NON-BLANK COUNT TO R3\n         SRL   R4,4           BLANK COUNT TO R4\n         AR    R1,R4          MOVE OUTPUT POINTER OVER BLANKS\n         AR    R6,R4          INCREASE OUTPUT COUNTER\n         LTR   R2,R3          ANY NON-BLANKS\n         BNP   ALLBLS         NO\n         SR    R5,R3          DECREASE INPUT COUNT BY NO. NON-BLANKS\n         BNP   BADEDIT                  CAN'T HAVE\n         AR    R6,R3          INCREASE OUTPUT COUNTER\n         CH    R6,=AL2(MXPRTSZ) TOO LONG?\n         BH    LIN2LONG            LINE WOULD BE TOO LONG\n         BCTR  R2,0           DECREMENT NON-BLANK COUNT FOR EX INST\n         EX    R2,UNPMVC      MOVE NON-BLANKS\n         AR    R1,R3          MOVE OUTPUT POINTER\nALLBLS   LA    R15,1(R15,R3)  MOVE INPUT POINTER OVER COUNT & NON-BLNKS\n         BCT   R5,MORECH      DO MORE\nFINUNP   L     R15,CPDOUB     LINE-NO TO R15\n         LTR   R0,R6          COUNT TO R0 WITH LTR\n         SEXIT R1,R7          RESTORE REGS\n         EJECT\nLIN2LONG TSEG  'LINE EXCEEDS 133 CHARACTERS'\n         B     CVQTYPE             ISSUE ERROR MSG\nBADEDIT  TSEG  'INVALID EDIT FORMAT'\n         B     CVQTYPE             ISSUE ERROR MSG\n         TITLE 'LENCHK ROUTINE'\n* LENCHK CHECKS TO SEE IF AN UNPRESSED LINE HAS A NON-BLANK CHARACTER\n*      AT A POSITION GREATER THAN THE CURRENT VALUE OF CPLBGTH.  IF ONE\n*      IS FOUND, A WARNING IS ISSUED.  IF TRUNCATION TO 133 CHARACTERS\n*      OCCURS, A TRUNCATION MESSAGE IS ISSUED.\n*\n* LENCHK EXPECTS:\n*      REG 1 - POINTER TO UNPRESSED TEXT\n*      REG 0 - COUNT OF UNPRESSED TEXT\n*      REG 15 - LINE NO. (INTERNAL FORM)\n*\n* LENCHK RETURNS:\n*      REGS 1 & 15 - INTACT\n*      REG 0 - COUNT UP TO LAST NON-BLANK IN THE LINE\n         SPACE\nLENCHK   SENTER R14,R8,44               SAVE REGS\n        AIF   ('&DCEC' NE '1').LBL08                            JEP00X\n*********                                                       JEP008\n*                                                               JEP008\n*  DCEC TAB SUPPORT WITH BACKSPACES RECOGNIZED.                 JEP008\n*                                                               JEP008\n*********                                                       JEP008\nTABSTART LR    R5,R0              SET R5 = R0 IF NO TABS        USPS01\n         LTR   R2,R0              TEST LENGTH                   USPS01\n         BZ    EXIT               IF ZERO SKIP                  USPS01\n         OI    CVSPARES+12,X'01'  TURN ON ALTERS IN CASE TRUE   JEP008\nTABALTER CH    R0,=Y(MXPRTSZ)     ALREADY AT MAX LENGTH         JEP008\n         BNL   EXIT               IF TRUE SKIP (CAME FROM ALTER)JEP008\n         SR    R4,R4              CLEAR R4                      USPS01\n         LA    R3,RTBTABS         GET TABS ADDR                 USPS01\n         IC    R4,0(R3)           FIRST TAB                     USPS01\n         LTR   R4,R4              IS IT ZERO                    USPS01\n         BNZ   YESTABS            IF ZERO SKIP, ELSE CONTINUE   USPS01\n         NI    CVSPARES+12,X'FE'  TURN OFF FLAG TO PREVENT LOOP USPS01\n         B     EXIT               SKIP THE REST                 USPS01\nYESTABS  L     R4,RTBWAPTR        PREPARE TO BLANK OUT          USPS01\n         LA    R4,RTBTRBUF(R4)    BUMP TO BEGINNING OF TR BUFF  JEP008\n         MVI   0(R4),C' '          BLANK FIRST POS              JEP008\n         MVC   1(RTBNTEXT-1,R4),0(R4)  BLANK IT                 USPS01\n         LA    R5,0               SET NEW LINE COUNT = 0        USPS01\nBS1      CLI   0(R1),X'08'         ASCII BACKSPACE???           JEP008\n         BE    BSSET               YES .. GO BACKSPACE          JEP008\n         CLI   0(R1),X'16'         EBCDIC BACKSPACE???          JEP008\n         BNE   ANYTABS             NO BACKSPACE                 JEP008\nBSSET    LTR    R5,R5               AT=START??                  JEP008\n         BZ    ADDTEMP             CAN'T BACK UP                JEP008\n         BCTR  R5,0                MOVE TABBED LINE BACK 1      JEP008\n         B     ADDTEMP             DONE... GET NEXT CHAR        JEP008\nANYTABS  EQU   *                  TAB CHECKED HERE              USPS01\n         CLI   0(R1),X'4A'        LOGICAL TAB?                  USPS01\n         BE    TAB                YES                           USPS01\n         CLI   0(R1),X'05'        TAB? (UPLOW SET)              USPS01\n         BE    TAB                YES                           USPS01\n         L     R4,RTBWAPTR        TAB LINE POINTER              USPS01\n         LA    R4,RTBTRBUF(R4)    BUMP TO BEGINNING OF TR BUFF  JEP008\n         AR    R4,R5              ADJ BY NEW LINE COUNT         USPS01\n         MVC   0(1,R4),0(R1)      MOVE A CHAR                   USPS01\n         LA    R5,1(R5)           INCR. TAB LINE COUNT          USPS01\nISTABOK  CH    R5,=H'148'         MAX LINE LENGTH               USPS01\n         BH    RESETLNE           YES                           USPS01\nADDTEMP  LA    R1,1(R1)           INCR. TEMP POINTER            USPS01\n         BCT   R2,BS1            GO CHECK NEXT CHAR             USPS01\nRESETLNE L     R1,12(R8)           ORIGINAL R1                  USPS01\n         L     R2,RTBWAPTR         NEW LINE POINTER             USPS01\n         LA    R2,RTBTRBUF(R2)    BUMP TO BEGINNING OF TR BUFF  JEP008\n         LR    R3,R5               NEW LINE LENGTH              USPS01\n         BCTR  R3,0                DOWN 1 FOR EX                USPS01\n         EX    R3,MOVELINE         MOVE BACK                    USPS01\n         NI    CVSPARES+12,X'FE'   TURN OFF ALTERS FLAG         JEP008\n         B     EXIT                                             USPS01\nMOVELINE MVC   0(0,R1),0(R2)  MOVE TABBED LINE                  USPS01\n*                                                               USPS01\n*  CHECK TAB TABLE                                              USPS01\n*                                                               USPS01\nTAB      LA    R6,8               MAX NO. OF TABS               USPS01\n         SR    R14,R14            CLEAR R14                     USPS01\nTABLOOP  IC    R14,0(R3)          PICK UP TAB                   USPS01\n         LTR   R14,R14            TAB = 0                       USPS01\n         BZ    TAB1               YES                           USPS01\n         SH    R14,=H'12'         MAKE TABS REAL                USPS01\n         CR    R5,R14             IS OLD LINE COUNT < TAB       USPS01\n         BL    TAB2               YES                           USPS01\n         LA    R3,1(R3)           INCR TAB TO NEXT TAB          USPS01\n         BCT   R6,TABLOOP                                       USPS01\nTAB1     LA    R5,149             BAD TAB OR NO TABS            USPS01\n         B     ISTABOK                                          USPS01\nTAB2     LR    R5,R14             OLD LINE COUNT = TABSET       USPS01\n         B     ADDTEMP                                          USPS01\nEXIT     LR    R0,R5              R0 HAS LENGTH OF INPUT        USPS01\n.LBL08   DS    0H                                               JEP00X\n         MVI   0(R8),0                  SET NOT TRUNCATED\n         CH    R0,=Y(148)               FORCE TRUNCATION BIT AT 148\n         BL    AFFEN                    OK\nAEEEN    MVI   0(R8),FALLBT             SET TRUNCATED\nAFFEN    AR    R1,R0                    POINT AT 1ST CHAR AFTER LAST\nAGGEN    BCTR  R1,0                     MOVE POINTER FOREWARD BY 1\n         CLI   0(R1),C' '               BLANK?\n         BNE   STRIT                    NO\n         BCT   R0,AGGEN                 TRY NEXT\nSTRIT    CH    R0,=Y(MXPRTSZ)           OVER 133 CHARS?\n         BH    FIXXUP                   YES\n         ST    R0,8(R8)                 COUNT TO LAST NON-BLANK\n         AIF   ('&DCEC' NE '1').LBLX8                           JEP00X\n         TM    CVSPARES+12,X'01'  IF COMING FROM ALTERS         JEP008\n         BNO   TABSDONE           LENGTH HAD TO BE SET FIRST    JEP008\n         L     R1,12(R8)          RELOAD ORIGINAL R1            JEP008\n         NI    CVSPARES+12,X'FE'  TURN OFF FLAG TO PREVENT LOOP JEP008\n         B     TABALTER           NOW WE CAN DO TABS            JEP008\nTABSDONE EQU   *                  NOW WE CAN CONTINUE           JEP008\n.LBLX8   DS    0H                                               JEP00X\n         TM    0(R8),FALLBT             TRUNCATED?\n         BO    LMESSA                   YES\n         TM    CPGFLG,CPFRETRY          IS RETRY GOING ON?\n         BO    STROUT                   RETURN IF SO\n         CH    R0,CPLNGTH               GREATER THAN LENGTH?\n         BNH   STROUT                   NO\nLMESSA   TM    CPGFLG,CPFRETRY          IS RETRY GOING ON\n         BO    LMESSR                   YEP, GIVE OTHER MSG\n         TSEG  'LINE NO.',,B\n         LR    R0,R15                   INTERNAL LINE-NO.\n         CVCALL CVEXNO                   CONVERT\n         TSEG  (1),(0),B                INTO MESSAGE\n         TM    0(R8),FALLBT             TRUNCATED?\n         BO    LMESSC                   YES\n         TSEG  'CONTAINS',,B\n         L     R15,8(,R8)              COUNT\n         BTD   CPDOUB,0,(15)           CONVERT TO DECIMAL\n         TSEG  (1),(0),B                INTO MESSAGE\nLMESSB   TSEG  'CHARACTERS',,W\n         BNP   STROUT                   ATTN NOT HIT\n         OI    CPLFLG2,CPFCHND          SET ATTN HIT\nSTROUT   SEXIT R14,R8,*                 EXIT\n         SPACE\nFIXXUP   L     R1,12(R8)                RESET POINTER\n         LA    R0,MXPRTSZ               SET DOWN TO MAX\n         B     AEEEN\n         SPACE\nLMESSR   TSEG  'COMMAND',,B\nLMESSC   TSEG  'TRUNCATED TO 133',,B\n         B     LMESSB\n         TITLE 'TERMINAL READ ROUTINE'\n* ALL TERMINAL READS GO THRU HERE\n*\n* IN ORDER TO GET AROUND PROBLEMS INVOLVED WITH SPECIAL\n* HANDLING OF ATTENTION HERE IN TRDRTN, THE ROUTINE HAS BEEN\n* CHANGED TO ALWAYS RETURN TO THE CALLER WHEN A READ ENDS WITH\n* ATTENTION OR NORMALLY.   ON RETURN THE CONDITION CODE IS\n* SET TO ZERO IF NO ATTENTION OCCURRED OR TO POSITIVE IF AN\n* ATTENTION DID OCCUR.  FOR NORMAL READS THAT DO NOT ALLOW\n* SPECIAL CHARACTERS(SUCH AS @, $, AND CENT SIGN) BEFORE\n* THE ATTENTION, THE LENGTH REGISTER R0 WILL HAVE A VALUE OF 0\n* WHEN ATTENTION IS RETURNED.\n*\n* BEFORE ISSUING THE READ REQUEST, THE PROMPT IS MOVED TO\n* THE CPWORK AREA OFF R13 IN CASE R1 POINTS TO AN ADDRESS IN\n* CODE THAT MAY BE PAGED.\n         SPACE\nTRDRTN   XENTER 6,8,C28                 SAVE REGS\n         LTR   R6,R0               PUT PROMPT CNT IN R6 & TEST\n         BNP   SAVPRMPT            BR IF NO PROMPT\n         BCTR  R6,0                SET FOR MVC\n         EX    R6,PRMPTMV          MOVE PROMPT TO R13 AREA\n         LR    R1,R13              POINT R1 TO NEW PROMPT AREA\n         LA    R13,4(R6,R13)       BUMP R13 BY LENGTH &\n         N     R13,=F'-4'              MAKE SURE WORD BOUNDARY\nSAVPRMPT STM   R15,R1,C16(R8)           SAVE PROMPT\nRESEG    TSEG  (1),(0)                  PROMPT\n         L     R15,C16(R8)              RESET CODE\n         TREAD                          OUT, THEN READ TERMINAL\n         BM    ITSIO                         BR I/O ERROR\n         XEXIT 6,8                      GOOD\n         SPACE\nITSIO    C     R15,=F'-4'               I/O OR TABS\n         BE    MERGE                    BR IF I/O ERROR\n         TSEG  'UNSET TABS -',,B\nMERGE    TSEG  'RETYPE',,M\n         LM    R0,R1,C20(R8)            RESET PROMPT\n         B     RESEG\n         SPACE\nPRMPTMV  MVC   0(0,R13),0(R1)\n         TITLE 'UTILITY ROUTINES'\n* LIST A LINE ROUTINE -- FORMATS THE OUTPUT LINE BASED ON\n*          SETTING OF LIST OPTIONS IN CPLFLG5\n* INPUT  R0 - LENGTH OF LINE TO LIST\n*        R1 - ADDRESS OF START OF LINE TO LIST\n*        CPLCNO - LINE NUMBER OF LINE TO LIST\n         SPACE\nLISTLINE XENTER 0,8,*\n         TM    CPLFLG5,CPFNONUM    NONUMBER OPTION\n         BO    LIST3               BRANCH YES\n         TM    CPLFLG5,CPFUNUM     UNNUMBERED\n         BO    LIST1               BRANCH YES\n         L     R0,CPLCNO           GET LINE NUMBER\n         CVCALL CVEXNO             CONVERT IT\n         TSEG  (1),(0),B           PUT IT IN BUFFER\n         AIF   ('&DCEC' NE '1').LBL04                           JEP00X\n         TM    LFLG1,CPF3277       IS THIS A 3277???            JEP004\n         BO    YES3277             YES...PUT OUT 2 BLANKS       JEP004\n         TSEG  ' '                 1 LESS BLANK FOR NON-3277    JEP004\n         B     NO3277              GO AROUND 3277 TSEG          JEP004\nYES3277  TSEG  '  '                PUT OUT TWO BLANKS           JEP004\nNO3277   TM    CPLFLG5,CPFNTEX     NOTEXT                       JEP004\n         BO    LIST2               YES                          JEP004\nLIST1    LM    R0,R1,4(R8)         POINT TO TEXT                JEP004\n         TSEG  (1),(0),MARK        PUT IT IN BUFF & MARK EOL    JEP003\n         AGO   .LBL05                                           JEP00X\n.LBL04   DS    0H                                               JEP00X\n         TSEG  ' '                 PUT OUT ANOTHER BLANK\n         TM    CPLFLG5,CPFNTEX     NOTEXT\n         BO    LIST2               YES\nLIST1    LM    R0,R1,4(R8)         POINT TO TEXT\n         TSEG  (1),(0)             PUT IT IN BUFFER\n.LBL05   DS    0H                                               JEP00X\nLIST2    TMARK ,                   MARK END OF LINE\n         AIF   ('&DCEC' NE '1').LBLX4                           JEP00X\n         TM    JCBAFL,JCBAFIA     DID USER HIT ATTENTION???     JEP007\n         BNO   LISTEXIT           BRANCH IF NO ATTN HIT         JEP007\n         OI    CPLFLG2,CPFCHND    SET TERMINATE                 JEP007\nLISTEXIT XEXIT 0,8                RETURN                        JEP007\nLIST3    TM    LFLG1,CPF3277      ARE WE A 3277 DEVICE???       JEP007\n         BNO   LIST3A             NO...DO NORMAL TSEG           JEP007\n         TSEG  ' '                EXTRA BLANK FOR 3277          JEP007\nLIST3A   TSEG  '           '      PUT OUTMBLANKS FOR NONUM      JEP007\n         AGO   .LBLX5                                           JEP00X\n.LBLX4   DS    0H                                               JEP00X\n         XEXIT 0,8                 RETURN\n         SPACE\nLIST3    TSEG  '           '       PUT OUT BLANKS FOR NONUMBER\n.LBLX5   DS    0H                                               JEP00X\n         B     LIST1               GO PUT OUT TEXT\n         TITLE 'SET PROMPT FOR LINE INPUT'\n* SETPRMPT SETS THE CORRECT PROMPT FOR TEXT INPUT BASED\n* ON THE LIST OPTIONS SET IN FLAG CPLFLG5\n*\n* INPUT -- R0 = INTERNAL LINE NUMBER THAT MAY BE USED IN PROMPT\n*\n* OUTPUT -- R0, R1, AND R15 ARE SET FOR THE CALL TO TRDRTN\n         SPACE\nSETPRMPT XENTER 7,8,*\n         TM    CPLFLG5,CPFNONUM    TEST IF NORMAL NUMBER PROMPT\n         BNZ   SETPR2              BRANCH NO\nSETPR1   CVCALL CVEXNO             CONVERT LINE NUMBER\n         SR    R15,R15             SET R15 FOR NORMAL PROMPT\nSETPREX  XEXIT 7,8                 EXIT\n         SPACE\nSETPR2   BNO   SETPR3              BRANCH IF NOT NONUMBER\n         SYSQS 1,0,'           '   SET NONUMBER PROMPT\n         LA    R15,4               SET FOR NO ? IN PROMPT\n         B     SETPREX             GO RETURN\n         SPACE\nSETPR3   TM    CPLFLG5,CPFUNUM     UNNUMBERED OR NOTEXT\n         BE    SETPR1              GO DO NORMAL PROMPT IF NOTEXT\n         SR    R0,R0               SET NO PROMPT FOR UNNUMBERED\n         SR    R1,R1\n         LA    R15,4\n         B     SETPREX             GO RETURN\n         TITLE 'DISK READ/WRITE ERROR MESSAGE ROUTINE'\nRDSKER   SENTER 14,8,44       SAVE REGS\n         TSEG  'DATA SET READ ERROR, PROCEEDING',,M\n         SEXIT 14,8,*\n         SPACE 3\nWDSKER   SENTER 14,8,44       SAVE REGS\n         TSEG  'DATA SET WRITE ERROR, PROCEEDING',,M\n         SEXIT 14,8,*\n         TITLE 'ADDER ROUTINE'\n* ADDER ADDS A LINE NO. IN R0 TO A DELTA IN R1 WITH LINE NO. ADDITION.\n* RETURN IS IN REG R0.\n* R0 NEGATIVE ON ILLEGAL (TOO-HIGH) RESULT\n         SPACE\nADDER    SENTER R3,R7         SAVE REGS\n         AR    R0,R1                   ADD NOS.\n         L     R6,CMPHGH               LOAD HIGH VALUE\n         CLR   R6,R0                   LESS THAN HIGH\n         BH    LNOK           GOOD WITH RETURN CONDITION CODE SET\n         LNR   R0,R6          SET NO GOOD\nLNOK     SEXIT R3,R7          SCRAM\n         TITLE 'LOWMULT ROUTINE'\n*  COMPUTE NEXT LOWER MULTIPLE OF A DELTA\n*\n*  (R0) = LINE NO.\n*  (R1) = DELTA\n*\n*  RETURNS R0 = NEXT LOWER MULTIPLE\n         SPACE\nLOWMULT  SENTER R1,R7\n         LR    R3,R0                   LINE NO.\n         SR    R2,R2\n         DR    R2,R1                   DIVIDE BY DELTA\n         MR    R2,R1                   MULTIPLY BY DELTA\n         LR    R0,R3                   PUT RESULT IN R0\n         SEXIT R1,R7\n         TITLE 'CVEXNO ROUTINE'\n* CVEXNO  CONVERTS INTERNAL LINE NOS. TO 9-DIGITS WITH/WITHOUT\n*              A DECIMAL POINT -- CVEXNO1 IS BRANCHED TO IF A\n*              DECIMAL POINT IN WANTED\n*      EXPECTS R0 - INTERNAL LINE NO.\n*      RETURNS R1 - ADDRESS OF EXTERNAL FORM LINE NO.\n*              R0 - LENGTH OF LINE NO. (9 CHARACTERS)\n         SPACE\nCVEXNO   SENTER 2,8,*\n         CVD   R0,CPDOUB               CONVERT TO DECIMAL\n         TM    CPLFLG5,CPFINT          IS DECIMAL POINT WANTED\n         BE    CVEXNO1                 NO\n         MVC   C32(8,R8),CPDOUB        MOVE CONVERTED NUMBER\n         UNPK  CPDOUB(9),C32+3(5,R8)   UNPK TO CPDOUB\n         OI    CPDOUB+8,X'F0'          SET ZONE\n         MVI   CPDOUB,C' '         SET FIRST CHAR TO BLANK\n         B     DONA                    EXIT FROM CVEXNO\n         SPACE\nCVEXNO1  MVC   C32(11,R8),EXEDTMSK     MOVE EDIT MASK\n         ED    C32(11,R8),CPDOUB+3     EDIT LINE NO.\n         MVC   CPDOUB(9),C32+2(R8)     MOVE RESULT TO CPDOUB\n         LA    R3,CPDOUB+8             TRAIL ZERO POINTER\nSTOP     CLI   0(3),C'0'     TRAILING ZERO?\n         BNE   DONA          NO\n         MVI   0(3),C' '     SET BLANK\n         BCT   3,STOP        REDUCE TRAILING PTR\nDONA     LA    1,CPDOUB       RETURN ADDRESS OF CONVERTED IN R1\n         LA    R0,9                    SET LENGTH\n         SEXIT 2,8,*         BYE\n         SPACE\nEXEDTMSK DC    C' ',X'202020202120',C'.',X'202020' EDIT MASK\n         DC    0H'0'\n         TITLE 'PRESS ROUTINE'\n* PRESS LINES FOR WYLBUR WDS\n*\n* R1 - PTR TO TEXT TO PRESS\n* R0 - COUNT OF TEXT TO PRESS\n* R15 - WYLBUR LINE NUMBER\n*\n* RETURNS PRESSED AT SAME PLACE R1 POINTED TO\n* PRESSED COUNT IN R0\n         SPACE\nPRESS    SENTER R1,R8         SAVE REGS\n         LA    R8,C32+4(R13)  SET PUT-TOGETHER AREA\n         ST    R15,C32(R13)   PUT LINE-NO INTO PRESSED\n         CH    R0,=Y(MXPRTSZ)           CANT HAVE TOO BIG\n         BNH   PRSGO          OK\n         LH    R0,=Y(MXPRTSZ)           FIXUP\nPRSGO    SR    R6,R6          START OUTPUT COUNT\n         LTR   R5,R0          SET (& TEST) INPUT COUNT\n         BNP   ALLBL          BLANK LINE\n         LA    R3,0(R1)       SET INPUT POINTER (ZERO 1ST BYTE)\n         SR    R1,R1          MAKE SURE HIGH ORDER BYTE IS ZERO\n         BCTR  R5,0           SET TO EX TRT INST\n         LA    R0,15          SET CONSTANT 15 INTO REG\n         LA    R2,1           SET CONSTANT 1 INTO REG (WILL REMAIN)\nOVER     EX    R5,BLTRT       FIND A NON-BLANK\n         BZ    ALLBL          NONE\n         SR    R1,R3          LENGTH BLANK STRING TO R1\n         LR    R4,R1          AND TO R4\n         AR    R3,R1          MOVE POINTER\n         SR    R5,R1          DECREASE COUNTER\n         EX    R5,NBTRT       FIND NEXT BLANK\n         BNZ   EVALA          NONE\n         LA    R1,1(R3,R5)    PRETEND ITS JUST AFTER INTERESTING STRING\nEVALA    CR    R4,R0          BLANK STRING OVER 15?\n         BH    EVALB          YES\n         SLL   R4,4           MOVE BLANK STRING LENGTH TO LEFT HALF-BYT\n         SR    R1,R3          LENGTH NON-BLANK STRING TO R1\n         LA    R6,1(R6,R1)    ADD NON-BL CT & CT-BYTE TO COUNTER\n         SR    R5,R1          DECREASE COUNTER\nEVALC    CR    R1,R0          OVER 15 NON-BLANKS?\n         BH    EVALD          YES\n         OR    R4,R1          COMBINE BLANK & NON-BLANK COUNTS\n         STC   R4,1(R8)       STORE COUNT-BYTE\n         BCTR  R1,0           SET R1 FOR EX OF MVC\n         EX    R1,NBLMVC      MOVE NON-BLANKS\n         LA    R8,2(R8,R1)    MOVE OUTPUT POINTER\n         LA    R3,1(R3,R1)    RESET POINTER (IN)\n         LTR   R5,R5          ANY MORE?\n         BP    OVER           YES\n         EJECT\nALLBL    STC   R6,C32+4(R13)  STORE TOTAL PRESSED COUNT\n         L     R1,0(R13)      RETURN ADDR FOR PRESSED LINE\n         LA    R5,4(R6)       MVC COUNT\n         EX    R5,FINMVC      MOVE PRESSED (WITHOUT LINE-NO)\n         LTR   R0,R6          SET PRESSED COUNT RETURN\n         LM    R2,R8,4(R13)   RESTORE REGS\n         BR    R14            SCRAM\n         SPACE\nEVALB    MVI   1(R8),X'F0'    SET A BLANK-ONLY COUNT BYTE\n         AR    R6,R2          KICK COUNTER\n         AR    R8,R2          KICK POINTER\n         SR    R4,R0          REDUCE BLANK COUNT BY 15\n         B     EVALA          ANOTHER ROUND\n         SPACE\nEVALD    OR    R4,R0          COMBINE BL & NON-BL COUNTS\n         STC   R4,1(R8)       INSERT NON-BL COUNT BYTE\n         SR    R1,R0          REDUCE REMAINING NON-BL COUNT BY 15\n         SR    R4,R4          ZERO REMAINING BL COUNT\n         MVC   2(15,R8),0(R3) MOVE A NON-BLANK STRING\n         AR    R3,R0          MOVE POINTER\n         AR    R6,R2          COUNT CONTROL CHAR\n         LA    R8,16(R8)      INCREASE COUNT BY 16\n         B     EVALC          MORE?\n         SPACE\nBLTRT    TRT   0(0,R3),BLTRTB SCAN FOR NON-BLANK\nNBTRT    TRT   0(0,R3),NBTRTB SCAN FOR BLANK\n         TITLE 'REMOTE INSTRUCTIONS'\n* FOR STOWIT\n         SPACE\nDRMVC1   MVC   0(0,R11),0(R1)\nDRMVC2   MVC   6(0,R1),0(R11)\nRTBTXMVC MVC   RTBTEXT(0),0(R1)\nMOVIT1   MVC   0(0,R15),0(R3)\nMOVIT2   MVC   4(0,R15),4(R3)\n         SPACE 3\n* FOR PRESS-UNPRESS\n         SPACE\nUNPMVC   MVC   0(0,R1),6(R15)\nNBLMVC   MVC   2(0,R8),0(R3)  MOVE NON-BLANK STRINGS\nFINMVC   MVC   0(0,R1),C32(R13)    MOVE PRESSED LINE\n         SPACE 3\n* FOR ADDER ROUTINE\n         SPACE\nCMPHGH   DC    F'100000000'            HIGH LINE VALUE\n         SPACE 3\n* FOR PRESS ROUTINE\n         SPACE\nBLTRTB   DC    256XL1'1'\nNBTRTB   DC    256XL1'0'\n         ORG   BLTRTB+C' '\n         DC    X'0'\n         ORG   NBTRTB+C' '\n         DC    X'1'\n         ORG\n         TITLE 'LITERALS'\n         LTORG\n         TITLE 'CONSTANTS, ETC.'\n         COPY  WYLCONST\n         EJECT ,\nPCB      DSECT ,\n         COPY  PCBTSO                  PAGE BUFFER DSECT\n         TITLE 'COPY MODS'\n         COMMON\n         SPACE\nCPFLEN   EQU   C32\nCPFLOC   EQU   C32+4\nCPFCOL   EQU   CPDRED\nCPFILLFG EQU   CPDRED\nCPFILL   EQU   X'80'\nCPDUN    EQU   X'40'\nCPFILLHI EQU   X'20'               FILL COL > ORIG LENGTH\nCPLOST   EQU   X'10'\n         SPACE\n         END\n./ ADD NAME=PEDP     0100-80193-80193-1611-02037-02037-00000-$SYS13  00\nPEDP     TITLE 'START OF PAGED CODE -- PAGE 2'\n* PROPERTY OF C. U. C. C. A.\n         SPACE 3\n         GBLC    &DCEC             SWITCH FOR DCEC MODS         JEP00X\n         GBLC    &USPS                                          USPS01\n         GBLC    &CHKSPCE                                       USPS01\n&USPS    SETC  '1'                                              USPS01\n&DCEC    SETC   '1'  CHANGE TO ANY OTHER NUM. TO DELETE DCEC MODJEP00X\n         AIF   ('&DCEC' NE '1').LBL01                           JEP00X\n*                                                               JEP006\n*                                                               JEP006\n* MOD JEP006                                                    JEP006\n*  INTERFACED WYLBUR TO TSO'S HELP COMMAND PROCESSOR.           JEP006\n*  MODULES AFFECTED: PEDP, PWYL ...DENOTED JEP006 IN 66/71.     JEP006\n*                                                               JEP006\n*                                                               JEP006\n*                                                               JEP001\n*                                                               JEP001\n*                                                               JEP001\n* MOD JEP001                                                    JEP001\n*  IMPLEMENTED DCEC NAMING CONVENTIONS. DENOTED JEP001 IN 66/71 JEP001\n*  MODULES AFFECTED: PDIO,PEDS,PUTB,INIT MACRO(DSNWA,CVTSO)     JEP001\n*                                                               JEP001\n*                                                               JEP001\n*\n* MOD\n*  MODULES AFFECTED ARE PWYL, PEDP AND MACRO(ROUTBLE)\n*  DENOTED BY  IN CC 66/71.     JERRY PITTENGER\n*\n*\n.LBL01   DS    0H                                               JEP00X\nP002     PAGECDE COMPARE,GODUMP,CLEAR\n         WIDENT 001\n         USING  CPAREA,R12\n         TITLE 'DUMP ROUTINE -- PAGE 2'\nPGODUMP  GENTER ,\n         SCAN  ARGPRT                   GET LOC TO DUMP\n         B     CVABSENT                 CAN'T DO\nTHISS    CH    R0,=Y(8)                 8 CHAR MAX\n         BH    CVNVALID                 CAN'T DO\n         XCALL HXCVT                    CONVERT ADDR\n         LA     R15,GONXCM\n         ST     R15,CVSPIEAD\n         L     R2,CPDOUB                ADDR TO R2\nTINHERE  LA    R13,300(R13)             WORK SPACE\nNXLINE   L     R6,CVTPTR                CVT POINTER\n         USING CVT,R6\n         L     R6,CVTMZ00               CURRENT MACHINE SIZE\n         DROP  R6\n         S     R6,=A(31)                DON'T PUSH TOO CLOSE TO EOCORE\n         CR    R2,R6                    CHECK IF LEGAL CORE VALUE\n         BH    GONXCM                   YES\n         ST    R2,CPWA+200              START ADDR DUMP\n         MVC   CPWA+204(32),0(R2)       CONTENT OF DUMP\n         LA    R6,CPWA+100              POINT TO UNPACK AREA\n         LA    R5,CPWA+201              SOURCE AREA\n         LA    R4,5                     35 SOURCE BYTES = 5 TIMES\nNXTUN    UNPK  0(15,R6),0(8,R5)         UNPACK 7 BYTES\n         LA    R6,14(R6)                UPDATE PTRS\n         LA    R5,7(R5)\n         BCT   R4,NXTUN                 MORE?\n         TR    CPWA+100(70),HEXTRTB     TRANSLATE\n         MVC   CPWA(6),CPWA+100         MOVE ADDR\n         LA    R4,CPWA+106              SET SOURCE ADDR START\n         LA    R6,2                     2 ROUNDS\n         MVC   CPWA+43(3),=C'  *'\n         MVC   CPWA+46(16),CPWA+204\n         MVI   CPWA+62,C'*'\nNXLIN    MVI   CPWA+6,C' '\n         LA    R5,CPWA+7                SET TARGET ADDR START\n         LA    R3,4                     4 TIMES/ROUND\nNXMUV    MVI   0(R5),C' '\n         MVC   1(8,R5),0(R4)            MOVE IN 8 CHARS\n         LA    R4,8(,R4)                KICK SOURCE PTR\n         LA    R5,9(,R5)                & TARGET PTR\n         BCT   R3,NXMUV                 MORE IN ROUND\n         TR    CPWA+46(16),PRTBL\n         TSEG  CPWA,63,W                OUTPUT\n         BP    GONXCM\n         MVC   CPWA+46(16),CPWA+204+16\n         MVC   CPWA(6),=6C' '\n         BCT   R6,NXLIN                 NEXT ROUND\n         L     R2,CPWA+200              LAST ADDR\n         LA    R2,32(R2)                NEXT ADDR\n         B     NXLINE                   DO MORE\nGONXCM   LR    R13,R8                   RESET R13 B/4 NEXT COMMAND\n         B     CVGETCOM                 NEXT COMMAND\n         SPACE 3\nTDIREC   LA    R2,CPDREC                POINT AT DIREC\n         B     TINHERE                  GO\n         SPACE\nTCPWYL   LA    R2,CPGLDL          POINT AT CPGLDL\n         B     TINHERE                  GO\n         SPACE\nTROUTBLE LA    R2,ROUTBLE          LOAD ADDRESS OF ROUTBLE\n         B     TINHERE             GO\n         SPACE 3\nHEXTRTB  EQU   *-C'0'\n         DC    CL16'0123456789ABCDEF'\n         SPACE 3\nPRTBL    DC    64C'.'\n         DC    X'40',10C'.'\n         DC    X'4B4C4D4E4F50',9C'.'\n         DC    X'5A5B5C5D5E5F6061',9C'.'\n         DC    X'6B6C6D6E6F',10C'.'\n         DC    X'7A7B7C7D7E7F80818283848586878889',C'.'\n         DC    X'8B',5C'.'\n         DC    X'919293949596979899',C'.'\n         DC    X'9B',6C'.'\n         DC    X'A2A3A4A5A6A7A8A9',3C'.'\n         DC    X'AD',15C'.'\n         DC    X'BD',3C'.'\n         DC    X'C1C2C3C4C5C6C7C8C9',7C'.'\n         DC    X'D1D2D3D4D5D6D7D8D9',8C'.'\n         DC    X'E2E3E4E5E6E7E8E9',6C'.'\n         DC    X'F0F1F2F3F4F5F6F7F8F9',6C'.'\n         SPACE 3\nHXCVT    LR    R2,R0                    SAVE PTRS\n         LR    R3,R1\nTHISNX   CLI   0(R1),C'A'               LESS A NG\n         BL    BADADDR                  CAN'T DO\n         CLI   0(R1),C'F'               A TO F OK\n         BH    THISNUM\n         TR    0(1,R1),ALPHTRTB         TRANS\n         B     THISOK\n         SPACE\nTHISNUM  CLI   0(R1),C'0'               LESS 0 NG\n         BL    BADADDR                  CAN'T DO\n         CLI   0(R1),C'9'               GTR 9 NG\n         BH    BADADDR                  CAN'T DO\nTHISOK   LA    R1,1(R1)                 KICK PTR\n         BCT   R0,THISNX                MORE?\n         EX    R2,PACKEM                PACK IT\n         MVI   CPDOUB,X'00'             IGNORE HI ORDER BITS\n         NI    CPDOUB+3,X'F8'           ALIGN D-W\n         L     R6,CVTPTR\n         USING CVT,R6\n         L     R6,CVTMZ00\n         DROP  R6\n         S     R6,=A(31)\n         C     R6,CPDOUB\n         BL    BADADDR\n         BR    R14                      RETURN TO CALLER\n         SPACE 3\nBADADDR  TSEG  'INVALID ADDRESS'\n         B     CVQTYPE\n         SPACE\nPACKEM   PACK  CPDOUB(5),0(0,R3)\n         SPACE\nALPHTRTB EQU   *-C'A'\n         DC    X'0A0B0C0D0E0F'\n         SPACE 3\nARGPRT   SCKW  DIR,TDIREC\n         SCKW  CP,TCPWYL\n         SCKW  ROUTBLE,TROUTBLE,A\n         SCKW  ,THISS\n         TITLE 'COMPARE ROUTINE -- PAGE 2'\nPCOMPARE GENTER C32+SZR+SZR\n         CLC   CPAGCT(2),=D'0'     IS THERE AN ACTIVE FILE\n         BNE   COMPAR1             BRANCH YES\n         CVCALL ITSNIL             NO, REPORT ERROR\n         SPACE\nCOMPAR1  LA    R6,LN1HV-P002       SET FOR FIRST LINE NUMBER\n         LCR   R6,R6               MAKE REL ADDR NEGATIVE AS FLG\n         SR    R2,R2               ZERO FOR IC\n         SCAN  LN1PRT              1ST LINE NO.\n         B     CVABSENT            VOID NG\n         SPACE\nLN1HV    ST    R0,0(R8)            SAVE LINE 1\n         ST    R0,16(,R8)          SAVE ALSO IN HIGH POSITION\n         LA    R6,LN2HV-P002       SET FOR 2ND LINE NUMBER\n         LCR   R6,R6               MAKE REL ADDR NEGATIVE AS FLG\n         SCAN  LN1PRT              2ND LINE\n         B     CVABSENT            VOID NG\n         SPACE\nLN2HV    LR    R2,R0               SAVE LINE 2\n         C     R2,16(,R8)          FIRST OR SECOND LINE NO HIGH\n         BL    LLLL                BRANCH IF SECOND HIGH\n         BE    TOOHI               IF EQUAL, THEN DONE\n         ST    R2,16(,R8)          SET SECOND LINE NO\n         B     MMMM                CONTINUE\n         SPACE\nLLLL     ST    R2,0(,R8)           SET FIRST LINE NO\nMMMM     SR    R1,R1\n         ST    R1,CPWK2\n         LA    R1,1\n         ST    R1,CPWK1\n         SCAN  COLUMN\n         B     COUT\n         SPACE\nMMMM1    SCAN  COLT\n         B     CVABSENT\n         SPACE\nCOLTA    C     R15,=F'133'\n         BH    CVNVALID\n         ST    R15,CPWK1\n         SCAN  COLTE\n         B     COUT\n         SPACE\nCOLTF    C     R15,CPWK1\n         BL    BADRA\n         ST    R15,CPWK2\nCOUT     PCALL GOCOMP\n         SPACE 3\nBADRA    TSEG  'BAD COLUMN RANGE'\n         B     CVQTYPE\n         SPACE\nBAD      B     CVNVALID\n         SPACE\nTOOHI    TSEG  'COMPARE',,W\n         B     CVGETCOM            YES, GO GET NEXT COMMAND\n         SPACE 3\nLN1PRT   SCKW  ,,PUSH       FILLED IN TO LNENOPRT\nLN2PRT   SCKW  ,,PUSH       FILLED IN TO LTNPRT\n         SCKW  ,BAD\n         SPACE\nCOLUMN   SCKW  COLUMNS,MMMM1,A\n         SCKW  ,BAD\n         SPACE\nCOLT     SCKW  ,COLTA,PI,133\nCOLTE    SCKW  /,COLTF,(P,PI),133\n         SCKW  ,BAD\n         TITLE 'CLEAR ROUTINE -- PAGE 2'\nPCLEAR   GENTER SZR+4  ENTRY FOR CLEAR COMMAND\n         LA    R2,TEXTPRT          POINT TO NORMAL SCAN TABLE\nGOCLEAR1 SLR   R2,R10              CONVERT PRT ADDR\n         LCR   R2,R2               TO RELATIVE ADDR FOR SCAN\n         SCTELL (1),(0)            GET OPERANDS\n         MVC   4(SZR,R8),0(R1)     MOVE TO WORK AREA\n         LA    R1,4(,R8)           POINT TO NEW SCAN AREA\n         SCINIT (1),(0)            SET SCANNER TO NEW AREA\n         MVC   0(1,R8),CPGFLG2     SAVE CURRENT VALUE OF CPGFLG2\n         SCAN  (R2),NO             SCAN FOR OPERANDS\n         B     CVABSENT            OP MISSING IF NOTHING\n         SPACE\nGOCLEAR2 SCAN  (R2),NO             CONTINUE SCAN FOR OTHER OPS\n         B     CVGETCOM            GO GET NEXT COMMAND\n         SPACE\nGGCLEAR  CLC   CPAGCT(2),=D'0'     IS THERE AN ACTIVE FILE\n         BNE   GGCLEAR1            BR YES\n         TM    0(R8),CPFEXEC+CPFEXTER    EXEC & EXEC TERSE\n         BO    GOCLEAR2            YES, DON'T WRITE MESSAGE\n         TSEG  'NO ACTIVE FILE',,W\n         B     GOCLEAR2            GO GET NEXT OPERAND\n         SPACE\nGGCLEAR1 CVCALL DOCLEAR            GO CLEAR FILE\n         B     GOCLEAR2            NEXT OPERAND\n         SPACE\nGGCLREX  CLC   CPEXCNT(2),=D'0'    IS THERE AN EXEC FILE\n         BNE   GGCLREX1            BR YES\n         TSEG  'NO EXEC FILE',,W\n         B     GOCLEAR2            GO GET NEXT OPERAND\n         SPACE\nGGCLREX1 CVCALL DOCLRX             GO CLEAR FILE\n         NI    CPGFLG2,255-CPFEXEC RESET EXEC MODE IF ON\n         B     GOCLEAR2            NEXT OPERAND\n         SPACE\nGGCLRTAB XC    RTBTABS(8),RTBTABS  CLEAR TAB SETTINGS\n         B     GOCLEAR2            NEXT OPERAND\n         SPACE\nGGCLRNAM XC    CPPFXL,CPPFXL       CLEAR PREFIX\n         MVI   CPMEMBSV,C' '       CLEAR SAVED MEMBER\n         AIF   ('&USPS' NE '1').XLBL03                          USPS01\n         ST    R6,CVSPARES   SAVE FOR MIN                       USPS01\n         SR    R6,R6         ZERO IT                            USPS01\n         IC    R6,CVUSRFLD  PICK UP ID LENGTH                   USPS01\n         MVC   CPUSERSV(0),CPUSER  RESET ID                     USPS01\n         EX    R6,*-6        EXECUTE ABOVE INST                 USPS01\n         L     R6,CVSPARES   RELOAD R6                          USPS01\n         AGO   .XLBL04                                          USPS01\n.XLBL03   DS   0H                                               USPS01\n         MVC   CPUSERSV(5),CPUSER  RESET SAVED USER AND GROUP\n.XLBL04   DS   0H                                               USPS01\n         B     GOCLEAR2            NEXT OPERAND\n         SPACE\nGGCLRIGN TSEG  (1),(0)             BAD OPERAND -- IGNORE IT\n         TSEG  ': IGNORED',,W      WRITE OUT MESSAGE\n         B     GOCLEAR2            GO GET NEXT OPERAND\n         SPACE 3\nTEXTPRT  SCKW  TEXT,GGCLEAR,A\n         SCKW  ACTIVE,GGCLEAR,A\n         SCKW  EXECUTE,GGCLREX,A\n         SCKW  TABS,GGCLRTAB,A\n         SCKW  NAME,GGCLRNAM,A\n         SCKW  ,GGCLRIGN\n         TITLE 'END OF PAGE CODE -- PAGE 2'\n         PINIT                     DEFINE START OF INIT ROUTINE\n         MVC   LN1PRT+1(3),CVLNENO+1\n         MVC   LN2PRT+1(3),CVLTNPR+1\n         PEND                      DEFINE END OF INIT CODE\n         TITLE 'TSO COMMANDS - INTERFACE ROUTINE - PAGE3'\nP003     PAGECDE TSOCMDS\n         WIDENT  001\n         USING   CPAREA,R12\nPTSOCMDS GENTER BLDLSIZ\n         USING BLDLWORK,R8    WORK AREA\n         CH    R0,=H'8'        COMMAND TOO LONG\n         ST    R0,CPWK1        SAVE FOR ILLEGAL COMMAND\n         BH    CMDILL          YES.\n         LR    R2,R0            CMD LEN FOR EXECUTE\n         MVC   BLDLNAM,=CL8' ' CLEAR\n         BCTR  R2,R0            DECR\n         EX    R2,MOVCMD        MOVE COMMAND FOR ATTACH\n         L     R4,CPCTSAV      PICK UP LENGTH OF CMD BUFF\n         LA    R4,4(,R4)       UP TO REAL LENGTH\n         LA    R5,CPCMSAV      MIN CMD LEN=1+BLANK\n         LA    R5,1(,R5)\nCMDLOOP  DS    0H\n         CLI   0(R5),C' '       CMD+SPACE = OPERAND OFFSET\n         BE    OPERAND         FOUND OPERAND OFFSET\n         LA    R5,1(,R5)       BUMP TO NEXT POS.\n         B     CMDLOOP         LOOP\nOPERAND  DS    0H\n         LA    R6,CPCMSAV      PICK UP START OF CMD\n         SR    R5,R6           GET LENGTH\n         LA    R5,1(,R5)       CORRECT FOR SPACE\n         STH   R5,CPCTSAV+2     SAVE OPERAND OFFSET\n         STH   R4,CPCTSAV       SAVE CMD LEN FOR TSO\n         LA    R0,BLDLWORK        FOR BLDL\n         MVC   BLDLCNT,=X'0001' FF\n         MVC   BLDLLEN,=AL2(BLDLSIZ)   LL\n         SLR   R1,R1               ALSO\n         SVC   18                  BLDL\n         L     R0,CPWK1         FOR ILLEGAL IF NEC\n         LA    R1,BLDLNAM       ALSO\n         LTR   R15,R15             FOUND\n         BNZ   CMDILL              NO EXIT\n*  ITEL  TM    BLDLLIB,2        IS IT STEPLIB,JOBLIB ETC\n*  ITEL  BO    APFLIB           MUST BE APF LIB\n         L     R6,CVIOWA        WORK AREA ADDRESS\n         USING WDIOWA,R6\n         L     R2,WAUPT         USER PROFILE TABLE\n         ST    R2,CPSTART+4\n         L     R2,WAPSCB           PSCB\n         ST    R2,CPSTART+8\n         L     R2,WAECT\n         ST    R2,CPSTART+12       ECT\n         LA    R2,CPCTSAV          CMD BUFFER\n         ST    R2,CPSTART\n         LA    R1,CPSTART          PHONEY CPPL\n         LA    R14,BLDLNAM\n         XC    ATTDECB(4),ATTDECB  CLEAR THE ECB\n         LA    R2,ATTDECB          PICK UP ECB ADDR\n        ATTACH DE=(14),ECB=(2)\n         LR    R3,R1               SAVE TCB ADDR\n         WAIT  ECB=(2)             WAIT FOR COMPLETION\n         OC    CPCMSAV(25),CPCMSAV READY CMD AREA FOR NEXT\n         ST    R3,CPSTART          SETUP FOR DETACH\nDETACH   DETACH CPSTART            DETACH CP\n         CLI    BLDLNAM,C'Q'       IS IT QUEUE COMMAND\n         BNE    NODEL              NO BYPASS DELETE\n         DELETE EP=QCMN            DELETE QUEUE COMMON\nNODEL    DS     0H\n*TURN STAX BACK ON\n         LA    R3,WASTAX           STAX WORK AREA\n         XC    WASTAX(4*5),WASTAX  CLEAR STAX PARM LIST\n         L     R14,CVATNRTN\n         STAX  (14),REPLACE=YES,DEFER=NO,USADDR=((R12)),MF=(E,(R3))\n         OC    CPCMSAV(25),CPCMSAV READY CMD AREA FOR NEXT\n         B     CVGETCOM                 NEXT COMMAND\nMOVCMD   MVC   BLDLNAM(0),0(R1) EXECUTE ONLY\n*\nCMDILL   TSEG  (R1),(R0),B\n         B      CVUNLEGL           GET NEXT COMMAND\n*\nAPFLIB   TSEG 'COMMAND MUST BE IN LINKLST LIBRARY'\n         B     CVQTYPE\n*\n         DROP  R6\n         PINIT\n         PEND\nBLDLWORK DSECT\nBLDLCNT  DS    XL2\nBLDLLEN  DS    XL2\nBLDLNAM  DS    CL8\nBLDLENT  DS    CL62\nBLDLLIB  EQU   BLDLENT+4          TYPE OF BLDL LIB\nBLDLSIZ  EQU   *-BLDLWORK\n         CSECT\n.LBLX1   DS     0H\n         TITLE 'START OF PAGED CODE -- PAGE 20'\nP020     PAGECDE GOCTLG,NTGDCAT,NTGDOPN,NOMORPG\n         WIDENT 001\n         TITLE 'GOCTLG ROUTINE -- PAGE 20'\nPGOCTLG  DENTER DSSIZ\n         CVCALL DODSNM\n         TM    CPLFLG3,CPFSET      WAS SET SPECIFIED?\n         BZ    GOCTLG2             BR IF NOT\n         CVCALL SETPFXNS\nGOCTLG2  TM    CPLFLG3,CPFDSCLG    CATLG OR RECATLG?\n         BZ    GOUNC               BR IF NEITHER\n         LNR   R1,R8               INDICATE MANDATORY VOL PRMT\n         CVCALL VOLCHKNL           CHECK FOR VOLUME\nGOUNC    TM    DSNWAF1,DSNFMYDS    BELONG TO USER?\n         BO    CALLCAT\n         CVCALL NOTMYDS            GO SEE IF OK\nCALLCAT  DCATLG ,                  GO DO FUNCTION\n         LR    R2,R15              SAVE RETURN CODE\n         CVCALL DSNAMED\n         LTR   R15,R2              TEST RETURN CODE\n         BNZ   PNTGDCAT            BR IF ERROR\n         CVCALL CTLGED\n         TM    CPLFLG3,CPFDSCLG    CATLG OR RECATLG?\n         BZ    CVGETCOM              EXIT IF NOT\n         TSEG  'ON',,B\n         TSEG  DSNWAVOL,6\n         B     CVGETCOM\n         TITLE 'NTGDCAT ROUTINE -- PAGE 20'\nPNTGDCAT GENTER ,\n         CH    R15,=Y(C8)          WAS RC=8?\n         BE    CATRC8P             GO DO PRELIM CHECKING\n         CH    R15,=Y(255)         WAS RC=8 AND FUNNY CONDITION\n         BNH   CATRCNT8            BR NO\n         SYSQS 1,0,'CANN''T CATLG'\n         B     NTGDCATX            GO FINISH\n         SPACE\nCATRCNT8 TSEG  'NOT',,B\n         CVCALL CTLGED             GO PRINT FUNCTION NOT DONE\n         TSEG  '-',,B\n         B     *(R15)              TAKE PROPER BRANCH\n         B     CATRC4\n         B     CATRC8\n         B     NTGDCATX\n         B     CATRC16\n         B     CATRC20\n         B     CATRC24\n         B     CATRC28\n         SPACE\nCATRC4   SYSQS 1,0,'CVOL NOT AVAILABLE'\n         B     NTGDCATX\n         SPACE\nCATRC8   SYSQS 1,0,'NOT IN CATALOG'\n         B     NTGDCATX\n         SPACE\nCATRC16  SYSQS 1,0,'INDEX DOES NOT EXIST'\n         B     NTGDCATX\n         SPACE\nCATRC20  SYSQS 1,0,'NO SPACE ON CVOL'\n         B     NTGDCATX\n         SPACE\nCATRC24  SYSQS 1,0,'IMPROPER GDG NAME'\n         B     NTGDCATX\n         SPACE\nCATRC28  SYSQS 1,0,'I/O ERROR'\n         B     NTGDCATX\n         SPACE 3\n* IF RETURN CODE IS 8 ENTRY FOUND/NOT FOUND\nCATRC8P  DS    0H\n         TM    CPLFLG3,CPFDSCLG    WAS IT CATLG OR RECATLG?\n         BZ    CATRCNT8            BR IF UNCATLG\n         SYSQS 1,0,'ALREADY CATLG''D'\n         SPACE\nNTGDCATX TSEG  (1),(0)             PUT MESSAGE IN BUFFER\n         B     CVQTYPE\n         TITLE 'OPEN ERROR MESSAGE ROUTINE -- PAGE 20'\nPNTGDOPN GENTER ,\n         LR    R6,R15              SAVE ERROR CONDITION\n         LR    R5,R0               SAVE ANY PARM PASSED BACK\n         CH    R15,=Y(RTNCATER)    IS IT POSSIBLE CATASTRPHE?\n         BNL   CATER\n         CH    R15,=Y(TALOCODE)    TALO ON DOPEN?\n         BNL   THISEN(R15)         DON'T PRINT DSNAME\n         CVCALL DSNAMED            DSNAME INTO MESSAGE\nTHISEN   B     THISEN(R6)     BRANCH TO PROPER CONTINUATION\n         SPACE\n         B     NOSUCH         4\n         B     CVGETCOM       8 - HANDLED ELSEWHERE\n         B     NOROOM         12\n         B     BATCH          16\n         B     ILLBLKSZ       20\n         B     DSILLEG        24\n         B     ILLORG         28\n         B     CVGETCOM       32    TALO\n         B     ABORTMS        36    ABORT\n         B     BDVOLM         40\n         B     ILLMEMB        44\n         B     NODIRSPC       48\n         B     EXPDTPRO       52\n         B     OUTOFSP        56\n         B     DIRIOERR       60\n         B     ABORTMS        64      SHOULDN'T HAPPEN\n         B     PROTERR        68\n         SPACE 3\nILLORG   DS    0H\n         SYSQS 1,0,': ILLEGAL DSORG OR RECFM'\n         B     NTGDOPNX\n         SPACE\nDSILLEG  SYSQS 1,0,': ILLEGAL DSNAME'\n         B     NTGDOPNX\n         SPACE\nBDVOLM   DS    0H\n         TSEG  DSNWAVOL,6\n         SYSQS 1,0,': INVALID VOLUME'\n         B     NTGDOPNX\n         SPACE\nNOSUCH   TSEG  'NOT',,B\nVOLTOMSG TSEG  'ON',,B\n         TSEG  DSNWAVOL,6,B\n         CLI   DSNWAF2,DSNFSHOW+DSNFCAT  IS CMND SHOW CATLG?\n         BNE   CVQTYPE             BR IF NOT\n         BTD   CPDOUB,0,(R5)       GET LAST GOOD INDEX LEVEL\n         TSEG  (1),(0),B\n         SYSQS 1,0,'LEVELS OK'\n         B     NTGDOPNX\n         SPACE\nNOROOM   TSEG  'CAN''T FIND SPACE',,B\n         B     VOLTOMSG\n         SPACE\nCATER    TSEG  'ERROR #'\n         ST    R5,CPDOUB           SAVE FORMATTED ERROR NUMBER\n         TSEG  CPDOUB+1,3          AND WRITE IT\n         SYSQS 1,0,'. I/O INCOMPLETE'\n         B     NTGDOPNX\nBATCH    SYSQS 1,0,'IS IN USE'\n         B     ABORMS\n         SPACE\nPROTERR  CVCALL DSNAMED\n         SYSQS 1,0,'IS PROTECTED'\n         B     ABORMS\n         SPACE\nOUTOFSP  SYSQS 1,0,'ALLOWED DISK SPACE EXCEEDED'\n         B     ABORMS\n         SPACE\nEXPDTPRO CVCALL DSNAMED            PUT OUT DSNAME\n         SYSQS 1,0,'IS DATE PROTECTED'\n         SPACE\nABORMS   TSEG  (1),(0),M\nABORTMS  SYSQS 1,0,'REQUEST ABORTED'\n         B     NTGDOPNX\n         SPACE\nILLMEMB  TSEG  'MEMBER',,B\n         TM    DSNWAMBR,X'BF'      WAS MEMBER SPECIFIED?\n         BZ    ILLMEMB2            NO - THAT'S WHAT'S WRONG\n         CVCALL MEMBERED           GO TSEG MEMBER NAME\n         SYSQS 1,0,'NOT FOUND'\n         B     NTGDOPNX\n         SPACE\nILLMEMB2 SYSQS 1,0,'NOT SPECIFIED'\n         B     NTGDOPNX\n         SPACE\nILLBLKSZ TSEG  ':',,B\n         BTD   CPDOUB,0,(R5)       GET INVALID BLOCKSIZE\n         TSEG  (1),(0),B\n         SYSQS 1,0,'INVALID BLOCK SIZE'\n         SPACE\nNTGDOPNX TSEG  (1),(0)             PUT MESSAGE INTO BUFFER\n         B     CVQTYPE             GO GET NEXT COMMAND\n         SPACE\nNODIRSPC DS    0H\n         TSEG  'NO DIRECTORY SPACE IN',,B\nDIRDSN   CVCALL DSNAMED            PUT IN DSNAME\n         B     CVQTYPE             GO GET NEXT COMMAND\n         SPACE\nDIRIOERR TSEG  'DIRECTORY I/O ERROR IN',,B\n         B     DIRDSN              GO PUT IN DSNAME\n         TITLE 'PAGE SHORTAGE MESSAGES -- PAGE 20'\nPNOMORPG GENTER ,\n         TM    CPGFLG,CPFOPN  IS ANY EXTERNAL DATA SET NOT CLOSED?\n         BZ    READYZ         NO\n         DCLOSE ,             CLOSE IT\n         NI    CPGFLG,255-CPFOPN SET CLOSED\nREADYZ   XC    RTBWC(4),RTBWC\n         TSEG  'WYLBUR OUT OF PAGES -- COMMAND ABORTED'\n         B     CVQTYPE                  GET NEW COMMAND\n         TITLE 'END OF PAGED CODE -- PAGE 20'\n         PINIT             DEFINE END OF CODE - START OF INIT\n         PEND                      END OF PAGE\n         TITLE 'START OF PAGED CODE -- PAGE 21'\nP021     PAGECDE GOSHO,GOPUT\n         WIDENT 001\n         TITLE 'GOSHOW ROUTINE -- PAGE 21'\n* GOSHOW IS THE PRIMARY ENTRY FOR SHOW.\n         SPACE\nPGOSHO   GENTER C8\n         SCANSAVE 0(R8)            SAVE SCAN POINTERS FOR LATER\n         MVI   CPLFLG3,X'00'\n         SCAN  STPRTA                   SCAN FOR OPTIONS\n         B     CVABSENT                 ILLEGAL COMMAND\n         SPACE 3\n* MIGHT BE SHOW LINENO -- SET UP FOR THAT\n         SPACE\nGOSHOW1  SCANRSTR 0(R8)            RESTORE SCAN POINTERS\n         CVCALL SCNEXFR            SEE IF SELECT EXECUTE\n         LA    R6,SHOLNENO-P021    SET R6 FOR LINE NO.\n         LCR   R6,R6                  WITH NEG RELATIVE ADDR\n         SCAN  STPRTB              SCAN FOR LINE NUMBER\n         B     CVABSENT            NOTHING -- SHOULDN'T HAPPEN\n         SPACE\nSHOLNENO SYSQS 6,5,'LINE NUMBER'   SET FOR NORMAL LINE NUMBER\n         CH    R15,=Y(24)          VALUE TOO LARGE FOR BR TABLE\n         BH    CONVTRR             YES, SHOW AS LINE NUMBER\n         LTR   R15,R15             POSITIVE VALUE RETURNED\n         BNH   CONVTRR             NO, SHOW AS LINE NUMBER\n         B     *(R15)              GO TO PROPER ROUTINE\n         SPACE\n         B     FIRST               FIRST SPECIFIED\n         B     CURRENT             CURRENT SPECIFIED\n         B     LAST                LAST SPECIFIED\n         B     END                 END SPECIFIED\n         B     NEXT                NEXT SPECIFIED\n         B     PREVIOUS            PREVIOUS SPECIFIED\n         SPACE 3\nCURRENT  SYSQS 6,5,'CURRENT'       POINT TO TEXT\n         B     CONVTRR             GO OUTPUT IT\n         SPACE\nLAST     SYSQS 6,5,'LAST'          SET OPTION\n         B     CONVTRR             FINISH\n         SPACE\nFIRST    SYSQS 6,5,'FIRST'         SET FOR FIRST MESSAGE\n         B     CONVTRR             GO OUTPUT NOW\n         SPACE\nEND      SYSQS 6,5,'END'           SET FOR END MESSAGE\n         B     CONVTRR             GO OUTPUT NOW\n         SPACE\nNEXT     SYSQS 6,5,'NEXT'          SET FOR NEXT MESSAGE\n         B     CONVTRR             GO OUTPUT NOW\n         SPACE\nPREVIOUS SYSQS 6,5,'PREVIOUS'      SET FOR PREVIOUS MESSAGE\n         B     CONVTRR             GO FINISH\n         SPACE\nDELTA    SYSQS 6,5,'DELTA'         SET OPTION\n         L     R0,CPGLDL           DELTA INTO R0\nCONVTRR  CVCALL CVEXNO             CONVERT\n         B     OUTPUTR             OUTPUT\n         SPACE\nSIZEA    SYSQS 6,5,'PAGES'         SET OPTION\n         LH    R15,CPAGCT          LOAD PAGE COUNT\n         B     LNGTHB              CONTINUE\n         SPACE\nLNGTHA   SYSQS 6,5,'LENGTH'        SET OPTION\n         LH    R15,CPLNGTH         LEN INTO R15\nLNGTHB   SR    R0,R0               ZERO\n         BTD   CPDOUB,(0),(15)     CONV TO INTEGER\nOUTPUTR  TSEG  (1),(0),B           INTO MSG\nSSSNPT   TSEG  '-',,B\nSSSOPT   TSEG  (6),(5)             OPTION INTO MESSAGE\n         B     CVGETCOM\n         SPACE 3\nSHLOG    TM    CPGFLG2,CPFNOLOG    TEST IF NOLOG ON\n         BNO   SHLOG2              NO\n         TSEG  'NO'\nSHLOG2   SYSQS 1,0,'LOG'           PUT LOG IN MESSAGE\nINEFFECT TSEG  (1),(0),B\n         TSEG  'IS IN EFFECT'      WRITE REST OF MESSAGE\n         B     CVGETCOM\n         SPACE 3\nSHCOLL   TM    RTBUFL,RTBUNCOL     NO COLLECT?\n         BNO   SHCOLL2\n         TSEG  'NO'\nSHCOLL2  SYSQS 1,0,'COLLECT'\n         B     INEFFECT\n         SPACE 3\nSHWRAP   TM    RTBMFL,RTBWRAP      IS IT WRAP\n         BO    SHWRAP2\n         TSEG  'NO'\nSHWRAP2  SYSQS 1,0,'WRAP'\n         B     INEFFECT\n         SPACE 3\nSHPAD    TM    RTBUFL,RTBUPAD\n         BO    SHPAD2\n         TSEG  'NO'\nSHPAD2   SYSQS 1,0,'PAD'\n         B     INEFFECT\n         SPACE 3\nSHCRT    TM    RTBMFL,RTBCRT\n         BO    SHCRT2\n         TSEG  'NO'\nSHCRT2   SYSQS 1,0,'CRT'\n         B     INEFFECT\n         SPACE 3\nSHOBACK  TM    RTBUFL,RTBUBACK\n         BO    SHOBACK2\n         TSEG  'NO'\nSHOBACK2 SYSQS 1,0,'BACK'\n         B     INEFFECT\n         SPACE 3\nSHPSZ    LA    R15,RTBPSZ\n         SYSQS 6,5,'PAGESIZE'\n         B     SHLPSZ\n         SPACE 3\nSHLSZ    LA    R15,RTBLSZ\n         SYSQS 6,5,'LINESIZE'\nSHLPSZ   L     R14,RTBWAPTR\n         LH    R15,0(R15,R14)\n         B     LNGTHB\n         SPACE 3\nSHATTN   SYSQS 6,5,'ATTN SEQUENCE'\n         TM    RTBUFL,RTBUATTN\n         BNO   VOLNONE\n         L     R14,RTBWAPTR\n         LA    R1,RTBATTN(,R14)\n         LH    R0,RTBATNSZ(,R14)\n         B     OUTPUTR\n         SPACE 3\nVOLSHOW  SYSQS 6,5,'VOLUME'\n         TM    CPGFLG,CPFVOLM      DEFAULT?\n         BZ    VOLNONE             NO\n         TSEG  CPVOLSV,6,B         SET DEFAULT VOL\n         B     SSSNPT              PUT OPTION INTO MSG\n         SPACE\nVOLNONE  TSEG  'NO',,B             NONE\n         B     SSSOPT              PUT OPTION INTO MSG\n         SPACE 3\nSHOESCAP SYSQS 6,5,'ESCAPE CHAR'   SET OPTION\n         LA    R1,CPESCAPE         GET ESCAPE CHAR\n         TM    CPGFLG2,CPESNULL    IS IT NULL\nSHESCSK  BO    VOLNONE             BRANCH YES\n         LA    R0,1                SET LENGTH\n         B     OUTPUTR             GO FINISH\n         SPACE\nSHOSKIP  SYSQS 6,5,'SKIP CHAR'     SET OPTION\n         LA    R1,CPSKIP           GET SKIP CHAR\n         TM    CPGFLG2,CPSKNULL    IS IT NULL\n         B     SHESCSK             BRANCH YES\n         SPACE\nSHORSCN  LH    R15,CPRSCNVL        GET RESCAN VALUE\n         SYSQS 6,5,'RESCAN COUNT'  SET OPTION\n         B     LNGTHB              GO FINISH\n         SPACE 3\nCCASE    TM    CPGFLG,CPFUPLW      TEST IF UPPER-LOWER BIT ON\n         BO    ISUPLOW             YES\n         TSEG  'UPPER CASE ONLY'\n         B     CVGETCOM            GET NEW COMMAND\n         SPACE\nTSKTSK   B     CVNVALID\n         SPACE\nISUPLOW  TSEG  'UPPER-LOWER CASE'\n         B     CVGETCOM            GET NEW COMMAND\n         EJECT\n* CALL VARIOUS SHOW COMMANDS IMPLEMENTED IN OTHER PAGES\n* NAME, PREFIX, MEMBER, DSNAME, USER, GROUP\n         SPACE\nSHNAM    PCALL SHONAM\n         SPACE\nTABSA    PCALL GOTAB               GO DO TABS\n         SPACE\nCOLUMNS  PCALL SHOCOL              CALL SHOW COLUMNS ROUTINE\n         SPACE\nSHDSNSPA PCALL SHODSN\n         SPACE\nSHSPACES PCALL SHOSPAC\n         SPACE\nSHDIRCAT PCALL SHOCAT\n         SPACE\nSHVOLS   PCALL SHOVOLS\n         SPACE\nFINDSIZE PCALL SHOSIZ\n         SPACE\nINFO     PCALL TIME\n         SPACE\nPROFIL   PCALL PROFIL\n         SPACE\nLISTUSR  PCALL LSTUSR\n         SPACE\n         EJECT\n* SCAN ROUTINES FOR SHOW\n         SPACE\nSTPRTA   SCKW  DELTA,DELTA,A\n         SCKW  LENGTH,LNGTHA,A\n         SCKW  CASE,CCASE,A\n         SCKW  VOLUME,VOLSHOW,A\n         SCKW  NAME,SHNAM,(A,S)\n         SCKW  GROUP,SHNAM,(A,S)\n         SCKW  USERS,LISTUSR\n         SCKW  USER,SHNAM,(A,S)\n         SCKW  MEMBER,SHNAM,(A,S)\n         SCKW  LOG,SHLOG\n         SCKW  SIZE,FINDSIZE,A\n         SCKW  PAGES,SIZEA,A\nSTPRTA1  SCKW  EXECUTE,,A      FILLED IN AT INIT TO SHEXEC\n         SCKW  VOLUMES,SHVOLS\n         SCKW  VOLS,SHVOLS\n         SCKW  TIME,INFO,(A,S)\n         SCKW  DATE,INFO,(A,S)\n         SCKW  PROFILE,PROFIL,A\n         SCKW  TABS,TABSA,A\n         SCKW  COLUMNS,COLUMNS,A\n         SCKW  COLS,COLUMNS\n         SCKW  PAGESIZE,SHPSZ,A\n         SCKW  PS,SHPSZ,A\n         SCKW  LINESIZE,SHLSZ,A\n         SCKW  LS,SHLSZ\n         SCKW  ATTN,SHATTN\n         SCKW  COLLECT,SHCOLL,A\n         SCKW  WRAP,SHWRAP\n         SCKW  PAD,SHPAD\n         SCKW  CRT,SHCRT\nSTPRTA2  SCKW  VALUE,,A        FILLED IN AT INIT TO SHOVAR\n         SCKW  ESCAPE,SHOESCAP,A\n         SCKW  SKIP,SHOSKIP,A\n         SCKW  RESCAN,SHORSCN,A\n         SCKW  BACK,SHOBACK,A\n         SCKW  ,GOSHOW1        END FIRST SHOW TABLE\n         SPACE\nSTPRTB   SCKW  ,,PUSH          FILLED IN AT INIT TO LNENOPRT\n         SCKW  PREFIX,SHNAM,(A,S)\nPUTSCKW  SCKW  DSNAMES,SHDSNSPA,(A,S)\n         SCKW  DIRECTORY,SHDIRCAT,(A,S)\n         SCKW  CATLG,SHDIRCAT,(A,S)\n         SCKW  CATALOG,SHDIRCAT,(A,S)\n         SCKW  SPACE,SHSPACES,(A,S)\n         SCKW  TRACKS,SHSPACES,(A,S)\n         SCKW  ,TSKTSK\n         TITLE 'GOPUT ROUTINE -- PAGE 21'\n* GOPUT IS THE PRIMARY ENTRY FOR PUT.\n         SPACE\nPGOPUT   GENTER C8\n         MVI   CPLFLG3,CPFPUT\n         SCAN  PUTSCKW\n         B     CVABSENT\n         TITLE 'END OF PAGED CODE -- PAGE 21'\n         PINIT             DEFINE END OF CODE - START OF INIT\n         MVC   STPRTA1+1(3),CVSHEXE+1  SET TO SHEXEC\n         MVC   STPRTA2+1(3),CVSHOVA+1  SET TO SHOVAR\n         MVC   STPRTB+1(3),CVLNENO+1   SET TO LNENOPRT\n         PEND                      END OF PAGE\n         TITLE 'START OF PAGED CODE -- PAGE 22'\nP022     PAGECDE SHOSIZ\n         WIDENT 001\n         TITLE 'SHOW ROUTINES -- PAGE 22'\n* SHO SIZE: LIST # OF CHARACTERS IN EACH LINE OF A RANGE\n         SPACE\nPSHOSIZ  GENTER ,\n         OI    CPLFLG1,CPFALL      DEFAULT RANGE IS 'ALL'\n*                                  DEFAULT OPTION IS 'COUNT'\n         CVCALL DETRNG             FIND RANGE IF SPECIFIED\n         XC    CPOVSIZE(8),CPOVSIZE  INITIALIZE\nNEXTOKEN SCAN  SHOSIZOP            SCAN FOR A SPECIFIED OPTION\n         TM    CPLFLG2,CPFOV+CPFUN WAS OVER AND UNDER GIVEN\n         BNO   AWAYWEGO            NO, NO CHECK NEEDED\n         L     R6,CPUNSIZE         GET UNDER SIZE\n         BCTR  R6,0                SUBTRACT 1\n         C     R6,CPOVSIZE         NOW MUST STILL BE > OVSIZE\n         BH    AWAYWEGO            BR IF VALUES OK\n         SYSQS 1,0,'CAN''T HAVE LINES OVER' SET FIRST PART\n         B     OV1                 GO FINISH MESSAGE\n         SPACE\nAWAYWEGO L     R15,VDOSHOSZ        COME HERE IF NO TOKEN FOUND\n         MVI   CPCURRL,X'F0'       SET CURRENT LINE INVALID\n         OI    CPLFLG5,CPFNCUR     QUASH CURRENT LINE PNTR UPDAT\n         CVCALL DESPOT             GIVE DESPOT FLAGS AND GO THERE\n         TM    CPSTAD,CPFSOME      VOID RANGE?\n         BZ    NCOMMAND            YES-AVOID FURTHER MESSAGE\n         TM    CPLFLG2,CPFFIRST    HAS DO RTN WRITTEN A LINE?\n         BO    NCOMMAND            YES AVOID FURTHER MESSAGE\n         TM    CPLFLG2,CPFEQ       WAS IT EQUAL?\n         BZ    NOEQ                BR NO\n         SYSQS 1,0,'NO LINES EQUAL' SET PART OF MESSAGE\n         B     NOUN1               GO FINISH MESSAGE\n         SPACE\nNOEQ     TM    CPLFLG2,CPFOV       WAS IT FOR OVER?\n         BZ    NOUN                GO TO PUT OUT FOR UNDER\n         SYSQS 1,0,'NO LINES OVER' SET PART OF MESSAGE\nOV1      TSEG  (1),(0),B           PUT OUT FIRST PART OF MESSAGE\n         L     R6,CPOVSIZE         GET OVER SIZE\n         BTD   CPDOUB,3,(6)        CONVERT IT TO BCD\n         TSEG  (1),(0)             FINISH UP \"NULL\" MESSAGE\n         TM    CPLFLG2,CPFUN       WAS IT ALSO UNDER?\n         BZ    WPM                 NO. GO WRITE.\n         SYSQS 1,0,' UNDER'        MSG NEEDS OVER AND UNDER\n         B     NOUN1               SKIP AROUND NEXR LINE\n         SPACE\nNOUN     SYSQS 1,0,'NO LINES UNDER' SET FOR UNDER\nNOUN1    TSEG  (1),(0),B           PUT OUT PART OF MESSAGE\n         L     R6,CPUNSIZE         GET UNDER SIZE\n         BTD   CPDOUB,3,(6)        CONVERT IT TO BCD\n         TSEG  (1),(0)             FINISH UP \"NULL\" MESSAGE\nWPM      TWRITE                    TELL THE USER ABOUT IT\nNCOMMAND B     CVGETCOM            GO GET THE NEXT COMMAND\n         SPACE\nGOINVAL1 B     CVNVALID                   GO SAY INVALID\n         SPACE 3\n         DS    0F                  ALIGNMENT\nVDOSHOSZ DC    AL1(UNPRST+DESMATCH+DESRTRN+DESRELA)\n         DC    AL3(DOSHOSZ-P022)  ADDR OF WORK ROUTINE\n         EJECT\n*        FOLLOWING CODE ENTERED FROM SCAN OF TABLE SHOSIZOP\n*\n*                                  **OPTION FOUND**  **ACTION**\nHAVNOCNT OI    CPLFLG2,CPFCOUNT    'NOCOUNT'         FLAG IT\n         BR    R14                 RETURN TO SAME SCAN LEVEL\n         SPACE\nHAVEOVER SCAN  SHOSIZOV            'OVER'            START SCAN\n         B     CVABSENT            IF NO PARAMETER--ERROR\n         SPACE\nHAVUNDER SCAN  SHOSIZUN\n         B     CVABSENT            IF NO PARM---ERROR\n         SPACE\nHAVEQUAL SCAN  SHOSIZEQ            SCAN FOR EQUAL VALUE\n         B     CVABSENT            ERROR IF NOTHING\n         SPACE 3\n*        FOLLOWING CODE ENTERED FROM SCAN OF TABLE SHOSIZOV\n*\n*                                  **OPTION FOUND**  **ACTION**\nGOTLENGT LH    R15,CPLNGTH         'OVER LENGTH'     GET CUR LNG\nGOTNUMBR ST    R15,CPOVSIZE        'OVER NUMBER'     SAVE IT\n         TM    CPLFLG2,CPFOV+CPFEQ DOES THIS OPTION CONFLICT\n         BNZ   CVNVALID            YES, MAKE IT INVALID\n         OI    CPLFLG2,CPFOV       SET OVER FLAG\n         B     NEXTOKEN            RETURN TO NEXT HIGHER SCAN\n         SPACE\nGOTLENUN LH    R15,CPLNGTH         'UNDER LENGTH'\nGOTNUMU  ST    R15,CPUNSIZE        'UNDER NUMBER'\n         TM    CPLFLG2,CPFUN+CPFEQ DOES THIS OPTION CONFLICT\n         BNZ   CVNVALID            YES, MAKE IT INVALID\n         OI    CPLFLG2,CPFUN       SET UNDER FLAG\n         B     NEXTOKEN\n         SPACE\nGOTLENEQ LH    R15,CPLNGTH         'EQUAL LENGTH'\nGOTNUMEQ ST    R15,CPUNSIZE        USE UNDER AREA FOR EQUAL VAL\n         TM    CPLFLG2,CPFUN+CPFOV+CPFEQ  DOES THIS OPTION CONFL\n         BNZ   CVNVALID            YES, MAKE IT INVALID\n         OI    CPLFLG2,CPFEQ       SET EQUAL FLAG\n         B     NEXTOKEN\n         EJECT\n* SHOW SIZE DO ROUTINE ENTRY CONDITIONS:\n* R1=POINTER TO TEXT  R0=TEXT COUNT CPLCN0=LINE # INTRNL FMT\n         SPACE\nDOSHOSZ  XENTER 6,8,*              SMOKEY THE BEAR SAYS-THE REGS\n         LR    R6,R0               YOU SAVE MAY BE YOUR OWN\n         TM    CPLFLG2,CPFOV+CPFUN+CPFEQ IS IT SHO SIZ ALL?\n         BZ    PUTOUT              YES. BRANCH TO PUT OUT\n         C     R0,CPOVSIZE         OVER ?\n         BNH   SEEUNDER            NO. BRANCH\n         OI    CPOVSIZE,CPFOV      MARK OVER\nSEEUNDER C     R0,CPUNSIZE         IS IT UNDER?\n         BNL   SEEEQUAL            NO. BRANCH.\n         OI    CPOVSIZE,CPFUN      MARK UNDER\n         B     WELLWELL            GO SEE IF CONDITIONS HOLD\n         SPACE\nSEEEQUAL BNE   WELLWELL            NOT EQUAL - BRANCH\n         OI    CPOVSIZE,CPFEQ      MARK EQUAL\nWELLWELL NC    CPOVSIZE(1),CPLFLG2 DO CONDITIONS HOLD?\n         XC    CPOVSIZE(1),CPLFLG2\n         TM    CPOVSIZE,CPFOV+CPFUN+CPFEQ\n         BNZ   NOTQUITE            NO. BRANCH OUT.\nPUTOUT   L     R0,CPLCNO           LINE # TO ARG REG FOR CVEXNO\n         ST    R0,CPCURRL          UPDATE CURRENT LINE POINTER\n         CVCALL CVEXNO             CONVERT IT TO EXTRNL FORMAT\n         TSEG  (1),(0),B           BUFFER IT\n         TM    CPLFLG2,CPFCOUNT    DO WE HAVE TO SHO THE COUNT??\n         BO    WRITE               IF NOT GO WRITE THE LINE\n         TSEG  '-',,B              MAKE FANCY LINE\n         BTD   CPDOUB,3,(6)        CNVRT BINARY TEXT COUNT TO BCD\n         TSEG  (1),(0),B           BUFFER IT\n         TM    CPLFLG2,CPFFIRST    MUST WE PUT OUT THE DOODADS??\n         BO    WRITE               IF NOT SKIP THE DODAD\n         TSEG  'CHARACTERS'        ELSE PUT IT IN..SIGH\nWRITE    OI    CPLFLG2,CPFFIRST    SET 'NOT FIRST CALL' FLAG ON\n         TWRITE ,\n         BP    CVQTYPE             BREAK PROCESSING IF ATTENTION\nNOTQUITE XC    CPOVSIZE(1),CPOVSIZE CLEAR HI BITS\n         XEXIT 6,8\n         EJECT\n* SCAN TABLE FOR SHOW SIZE\n         SPACE\nSHOSIZOP SCKW  OVER,HAVEOVER,A\n         SCKW  UNDER,HAVUNDER,A\n         SCKW  EQUAL,HAVEQUAL,A\n         SCKW  COUNT,NEXTOKEN,A\n         SCKW  NOCOUNT,HAVNOCNT,A\n         SCKW  ,GOINVAL1\n         SPACE 3\n* SCAN TABLE FOR SHOW SIZE OVER\n         SPACE\nSHOSIZOV SCKW  ,GOTNUMBR,I,133\n         SCKW  LENGTH,GOTLENGT,A\n         SCKW  ,GOINVAL1\n         SPACE 3\n* SCAN TABLE FOR SHOW SIZE EQUAL\n         SPACE\nSHOSIZUN SCKW  ,GOTNUMU,PI,133\n         SCKW  LENGTH,GOTLENUN,A\n         SCKW  ,GOINVAL1\n         SPACE 3\n* SCAN TABLE FOR SHOW SIZE EQUAL\n         SPACE\nSHOSIZEQ SCKW  ,GOTNUMEQ,I,133\n         SCKW  LENGTH,GOTLENEQ,A\n         SCKW  ,GOINVAL1\n         TITLE 'END OF PAGED CODE -- PAGE 22'\n         PINIT         DEFINE END OF CODE START OF INIT\n         PEND                      END OF PAGE\n         TITLE 'START OF PAGED CODE -- PAGE 25'\nP025     PAGECDE SHONAM,SHOVOLS,DECIDE\n         WIDENT 2067 12:12:03 03/07/72\n         TITLE 'SHOW VOLUMES ROUTINE -- PAGE 25'\n* SHOW VOLUMES ROUTINE\n*\n* LIST VOLUMES VALID IN CURRENT SESSION\n*        USE & SAVE VOLUMES ARE LISTED FIRST\n*        TEMPORARY VOLUMES ARE LISTED NEXT\n*        USE ONLY VOLUMES ARE LISTED LAST\n         SPACE\nPSHOVOLS GENTER ,\n         TSEG  'USE && SAVE --',,B\n         LA    R5,CVSTYPE       POINT TO USE&SAVE TIOT IDENT\n         LA    R4,10                   SET MAXIMUM FOR A LINE\n         BAL   R6,SHVROUT              GO PUT OUT VOLUMES\n         TSEG  'TEMPORARY  --',,B\n         LA    R5,CVTTYPE              POINT TO TEMP TIOT IDENT\n         LA    R4,10                   SET MAXIMUM FOR A LINE\n         BAL   R6,SHVROUT              GO PUT OUT VOLUMES\n         TSEG  'USE ONLY   --',,B\n         LA    R5,CVUTYPE              POINT TO USE TIOT IDENT\n         LA    R4,10                   SET MAXIMUM FOR A LINE\n         BAL   R6,SHVROUT              GO PUT OUT VOLUMES\n         B     CVGETCOM                GO GET NEXT COMMAND\n         SPACE 3\nSHVROUT  SLR   R6,R10              MAKE RETURN RELATIVE\n         SR    R2,R2                   ZERO REGISTER FOR IC\n         L     R3,CVTIOT               POINT TO TIOT VOL LIST\nSHVROUTL CLC   0(2,R5),4(R3)           DOES VOL IDENT MATCH\n         BNE   SHVROUT1               NO, GET NEXT ENTRY\n         TM    3(R3),X'10'            IS IT DYNAM?\n         BNO   SHVROUT2               NO IT'S OK.\nSHVROUT1 IC    R2,0(,R3)               GET COUNT\n         AR    R3,R2                   POINT TO NEXT ENTRY\n         CLI   0(R3),0                 DONE\n         BNE   SHVROUTL                NO, GO DO THIS ENTRY\n         TWRITE ,                      WRITE OUT BUFFER\n         B     0(R6,R10)               RETURN\n         SPACE\nSHVROUT2 BCT   R4,SHVROUT3             BRANCH BUFFER NOT FULL\n         LA    R4,9                    RESET BUFFER COUNT\n         TWRITE ,                      WRITE OUT BUFFER\n         BP    0(R6,R10)               RETURN IF ATTN\n         TSEG  '             ',,B      INITIALIZE NEW BUFFER\nSHVROUT3 L     R1,16(,R3)          GET UCB POINTER\n         TM    18(R1),X'20'        DIRECT ACCESS?\n         BNO   SHVROUT1            IF NOT DONT DISPLAY.\n         TSEG  28(,R1),6,B             PUT VOL IN BUFFER WITH BLK\n         B     SHVROUT1                GO GET NEXT ENTRY\n         TITLE 'SHO NAM/PREF/MEM/GRO/USE -- PAGE 25'\n* ENTER HERE FOR SHOW  NAME, PREFIX, MEMBER, GROUP, AND USER\n*     DETERMINE WHICH OPTION WAS SPECIFIED AND GO DO IT\nPSHONAM  GENTER ,\n         CLC   CPCMNM,=C'NAM'  IS IT NAME\n         BE    SHONAM              YES GO SHOW NAME\n         CLC   CPCMNM,=C'PRE'      IS IT PREFIX\n         BE    SHPFX               YES, GO SHOW PREFIX\n         CLC   CPCMNM,=C'MEM'      IS IT MEMBER\n         BE    SHMBR               YES, GO SHOW MEMBER\n         CLC   CPCMNM,=C'USE'      IS IT USER\n         BE    SHUSER              YES, GO SHOW USER\n         AIF   ('&USPS' EQ '1').XLBL05                          USPS01\n         CLC   CPCMNM(2),=C'GR'    IS IT GROUP\n         BE    SHGRP               YES, GO SHOW GROUP\n.XLBL05   DS   0H                                               USPS01\nGOINVAL  B     CVNVALID                   GO SAY INVALID\n         EJECT\n*  SHOW PREFIX\n         SPACE\nSHONAM   OI    CPLFLG3,CPFSET      INDICATE SHOW NAME\n         AIF   ('&USPS' EQ '1').XLBL06                          USPS01\n         BAL   R2,SHGRP2           GO SHOW GROUP CODE\n         TSEG  ':',,B\n         BAL   R2,SHUSER2          GO SHOW USER CODE\n         TSEG  ':',,B\n.XLBL06   DS   0H                                               USPS01\nSHPFX    LH    R0,CPPFXL               TEST FOR PREFIX\n         LTR   R0,R0\n         BNP   NULLPFX                 BR IF NONE\n         TM    CPGFLG,CPFCMOFF     TEST TERSE\n         BO    SHPFX1              BR IF YES\n         TSEG  'PREFIX -',,B\nSHPFX1   LH    R0,CPPFXL           PREFIX LENGTH\n         TSEG  CPPFX,(0),B\nSHPFX2   DS    0H\n         TM    CPLFLG3,CPFSET      SHOW PREFIX OR NAMES?\n         BZ    CVGETCOM            BR IF SHOW PREFIX\n         TSEG  ':',,B\n         BAL   R2,SHMBR2           GO SHOW MEMBER\nSHGETCOM B     CVGETCOM\n         SPACE\nNULLPFX  TSEG  'NO PREFIX',,B\n         B     SHPFX2\n         SPACE 3\n         AIF   ('&USPS' EQ '1').XLBL07                          USPS01\n* SHOW GROUP\n         SPACE\nSHGRP    LA    R2,SHGETCOM\nSHGRP2   SLR   R2,R10              MAKE RETURN RELATIVE\n         TM    CPGFLG,CPFCMOFF     TEST TERSE\n         BO    SHGRP3              BR IF YES\n         TSEG  'GROUP -',,B\n         B     SHGRP4\n         SPACE\nSHGRP3   TSEG  '@'\nSHGRP4   TSEG  CPGRPSV,L'CPGRPSV,B\n         B     0(R2,R10)\n         SPACE 3\n.XLBL07   DS   0H                                               USPS01\n* SHOW USER\n         SPACE\nSHUSER   LA    R2,SHGETCOM\nSHUSER2  SLR   R2,R10              MAKE RETURN RELATIVE\n         TM    CPGFLG,CPFCMOFF     TEST TERSE\n         BO    SHUSER3              BR IF YES\n         TSEG  'USER -',,B\n         B     SHUSER4\n         SPACE\nSHUSER3  TSEG  '&&'\n         AIF   ('&DCEC' NE '1').LBL04                           JEP00X\nSHUSER4  ST    R0,CVSPARES         SAVE R0 PAST TSEG            JEP001\n         SR    R0,R0               ZERO IT                      JEP001\n         IC    R0,CVUSRFLD         PICK UP USERID LENGTH        JEP001\n         TSEG  CPUSERSV,(0),BLANK                               JEP001\n         L     R0,CVSPARES         RESTORE R0                   JEP001\n         AGO   .LBL05                                           JEP00X\n.LBL04   DS    0H                                               JEP00X\nSHUSER4  TSEG  CPUSERSV,L'CPUSERSV,B\n.LBL05   DS    0H                                               JEP00X\n         B     0(R2,R10)\n         SPACE 3\n* SHOW MEMBER\n         SPACE\nSHMBR    LA    R2,SHGETCOM\nSHMBR2   SLR   R2,R10              MAKE RETURN RELATIVE\n         CLI   CPMEMBSV,X'40'      IS THERE A SAVED MEMBER?\n         BE    NULLMBR             BR IF NO\n         TM    CPGFLG,CPFCMOFF     TEST TERSE\n         BO    SHMBR3              BR IF YES\n         TSEG  'MEMBER -',,B\n         B     SHMBR4\n         SPACE\nSHMBR3   TSEG  '#'\nSHMBR4   TSEG  CPMEMBSV,L'CPMEMBSV\n         B     0(R2,R10)\n         SPACE\nNULLMBR  TSEG  'NO MEMBER'\n         B     0(R2,R10)\n         TITLE 'DECIDE ROUTINE -- PAGE 25'\nPDECIDE  GENTER ,\n         TIME  BIN                      GET TIME\n         LA    R1,7\n         NR    R1,R0                    LEAVE LAST 3 BITS\n         MH    R1,=H'12'                INDEX INTO FOLLOWING\n         B     *+4(R1)                  GO TO A MESSAGE\n         SYSQS 1,0,'MAYBE'\n         B     TSEGIT\n         SYSQS 1,0,'NO'\n         B     TSEGIT\n         SYSQS 1,0,'WHY NOT?'\n         B     TSEGIT\n         SYSQS 1,0,'YES'\n         B     TSEGIT\n         SYSQS 1,0,'OF COURSE'\n         B     TSEGIT\n         SYSQS 1,0,'NEVER'\n         B     TSEGIT\n         SYSQS 1,0,'OK'\n         B     TSEGIT\n         SYSQS 1,0,'BEATS ME'\nTSEGIT   TSEG  (1),(0)\n         B     CVGETCOM\n         TITLE 'END OF PAGED CODE -- PAGE 25'\n         PINIT         DEFINE END OF CODE START OF INIT\n         PEND                      END OF PAGE\n         TITLE 'START OF PAGED CODE -- PAGE 23'\nP023     PAGECDE SHODSN\n         WIDENT 001\n         TITLE 'SHOW DSNAMES AND SHOW SPACE -- PAGE 23'\nPSHODSN  GENTER  ,\n         XC    CPWK6(4),CPWK6\n         CLC   CPCMNM,=C'DSN'      IS IT SHOW DSN\n         BE    SHDSNMS             BR YES, ELSE SPACE\n         SPACE 3\n* SHOW SPACE ROUTINE\n         SPACE\nSHSPACE  SCANSAVE CPWK1\n         BAL   R14,DSNMDO      GO GET AND INIT DSNAME WORK AREA\n         MVC   CPCMNM(3),=C'DSN'   MAKE IT LOOK LIKE SHOW DSN\n         B     DSNRESCN            NOW GO DO SHOW DSNAMES\n         EJECT\n* SHOW DSNAMES ROUTINE\n*\n*\n* DSNAME WORK AREA DESCRIBED BY DSNWA ENTRY\n*\n* 12 BYTES OBTAINED AFTER DSNAME WORK AREA USED AS FOLLOWS:\n*   BYTES 1-4 CONTAINS ADDR OF RESCAN ROUTINE.\n*   BYTES 5-10 USED TO SAVE VOL WHEN MULT CALLS OF DODSNM\n*   BYTES 11-12 USED TO SAVE SHOW DSN SKIP COUNT\n         SPACE\nSHDSNMS  LA    R14,DSNMDFLT        LOAD INIT EXIT ADDR\n         SR    R4,R4               ZERO SKIP COUNTER\nDSNMDO   DS    0H\n         DENTER SDSNDSZ,C12,,NO\n         OI    CPLFLG2,CPFDSNMS    SET NULL DSNAMES OK FLAG\n         XC    SDSNQLB(SDSNQSZ),SDSNQLB    CLEAR LOWER BOUND\n         MVI   SDSNQUB,X'FF'       FILL UPPER BOUND WITH HIGH\n         MVC   SDSNQUB+1(SDSNQSZ-1),SDSNQUB     VALUES\n         XC    0(C12,R8),0(R8)     CLEAR WORK AREA\n         LA    R15,DSNRESCN        ADDRESS OF SCAN FOR SHOW DSN\n         SLR   R15,R10             MAKE ADDRESS RELATIVE\n         ST    R15,0(R8)           SAVE IT\n         BR    R14                 RETURN OR CONTINUE\n         SPACE 3\nDSNMDFLT SCTELL ,\n         SH    R1,=H'2'            GO BACK TWO CHARS\n         AH    R0,=H'2'            ADJUST LENGTH\n         ST    R1,0(R13)\n         MVC   4(2,R13),0(R1)      SAVE WHATEVER WAS\n         LA    R13,8(,R13)         STEAL 8 BYTES\n         MVC   0(2,R1),=C'# '      MOVE IN DUMMY OPERAND\n         SCINIT (1),(0)            REINIT SCANNER\n         CVCALL DODSNM         GO CONSTRUCT DEFAULT LIKE PATTERN\n         L     R15,0(R8)           GET SCAN ADDRESS\n         S     R13,=F'8'           SUBTRACT 8\n         L     R14,0(,R13)         GET BUFFER ADDRESS\n         MVC   0(2,R14),4(R13)     MOVE BACK THEM\n         B     0(R15,R10)          GO DO IT\n         EJECT\nDSNRESCN TM    CPLFLG3,CPFPUT\n         BO    DIDFIRST\n         SCAN  DSONPRT                  VOLUME OR OPTIONS\n         B     PUTRID\n         SPACE\nDIDFIRST NI    CPLFLG5,255-CPFNLST\n         L     R0,CPHIPS                HIGHEST LINE NO. YET\n         L     R1,CPGLDL                GLOBAL DELTA\n         CVCALL LOWMULT                 GET MULTIPLE\n         CVCALL ADDER                   ADD\n         STM   R0,R1,CPWKPS\n         OI    CPWKDL,FNEGBT       SET DELTA NOT SPEC. YET\nNOTFIRST CLC   DSNWADSN(4),=X'05050505' IS IT SHO SPA\n         BNE   DSNSCAN\n         SCAN  PUTOPT\n         B     PRYPRY\n         SPACE\nDSNSCAN  SCAN  PUTSTUFF                 VOLUME OR OPTIONS\nPRYPRY   TM    CPLFLG2,CPFCLEAR    WAS CLEAR SPECIFIED\n         BZ    PRYOUT              BRANCH NO\n         CVCALL DOCLEAR            GO CLEAR ACTIVE FILE\n         LM    R2,R3,CPWKPS        SAVE COLLECT VALUES\n         LTR   R6,R6               WAS A LINE NUMBER GIVEN\n         BZ    PRYCLR2             BRANCH YES\n         L     R2,CPGLDL           NO, SET START TO DELTA\nPRYCLR2  TM    CPWKDL,FNEGBT             WAS DELTA SPE?\n         BZ    PRYCLR1                   YES. BRANCH\n         L     R3,CPGLDL\nPRYCLR1  STM   R2,R3,CPWKPS        RESET COLLECT VALUES\nPRYOUT   MVC   CPNXPS(4),=F'100000000' SET COMPARAND TOO HIGH\n         OI    CPLFLG4,CPFSTSPL+CPFSTINS SET SO STOWIT WILL ONLY\n         NI    CPWKDL,255-FNEGBT\n         TM    CPWKPS,FNEGBT            ILLEGAL LINE NO.?\n         BO    BADLINES                 YES\n         LA    R1,CPWKPS                1ST LINE NO. FOR LOCATE\n         CVCALL LOCATE                  LOCATE\n         TM    CPDRPT,CPFMTCH           MATCHING LINE NO.?\n         BO    BADLINEM                  YES\n         TM    CPDRPT,CPFNTYT+CPFHIGH   OK TO COLLECT TILL 9999.9\n         BNZ   POTCHEK                  YES\n         MVC   CPNXPS(4),CPLCNO         SET COMPARAND TO NEXT LIN\nPOTCHEK  L     R0,CPWKPS                LINE NO. TO COLLECT\n         ST    R0,CPCURRL          SET CURRENT LINE\n         ST    R0,CPLCNO           SET CURRENT LINE\n         C     R0,CPNXPS                STILL SMALL ENOUGH?\n         BNL   PUTERC                   NO\n         TM    CPLFLG2,CPFSCRTC\n         BZ    PUTNOCHK\n         NI    CPLFLG5,255-CPFNTEX-CPFNLST\nPUTNOCHK TM    CPLFLG5,CPFNLST\n         BZ    PUTRID\n         TM    JCBAFL,JCBSYSPR     SYSTEM PRIVILEGES?\n         BO    PUTRID              YES..LET NOLIST STAY\n         NI    CPLFLG5,255-CPFNLST NO LIST\nPUTRID   TM    CPLFLG3,CPFSET      WAS SET SPECIFIED?\n         BZ    DSNCOLL             BR IF NOT\n         CVCALL SETPFXNS           GO DO IT\n         TWRITE ,\nDSNCOLL  NI    CPLFLG3,255-CPFPMSG\nPOLCHEK  CVCALL VOLCHEK\n         XC    CPMDLN(4),CPMDLN    INDICATE NO PAGES\n         DVTOC ,                   COLL SHOW DSNAMES ROUTINE\n         MVC   CPDSNWA+DSSIZ(2),10(R8)  SAVE SKIP COUNT\nDSMBRCOM LTR   R9,R9                    PAGE  9 IN?\n         BZ    SKIPMRK                  NO\n         PMARK R9\nSKIPMRK  LTR   R15,R15                  BAD VOL., TALO, ABORT OR ERROR?\n         BZ    NGTDSER                  NO\n         CH    R15,=Y(RTNPAGES)          NOT ENUF PAGES?\n         BNE   ATTNHIT\n         OI    CPLFLG3,CPFPMSG\n         TSEG  'INSUFFICIENT PAGES FOR COMPLETE OUTPUT'\n         B     GOWARN\nATTNHIT  CH    R15,=Y(RTNSHERR)    SHOW RTN ERROR?\n         BNE   CALLNGO             BR IF NOT\n         TSEG  'PROCESSING BREAK'\n         LTR   R9,R9                    ANYTHING?\n         BZ    CVGETCOM                 NO - GET NEW COMMAND\nGOWARN   TWRITE ,\nNGTDSER  L     R4,CPWK6\n         LTR   R4,R4\n         BZ    WRIDSSP1\n         L     R1,CPNXPS           GET FIRST ILLEGAL\n         S     R1,CPWKPS           SUBT FIRST LINENO TO GET SIZE\n         SR    R0,R0               ZERO FOR DIVIDE\n         DR    R0,R4               CALCULATE MAXIMUM DELTA\n         C     R1,CPWKDL           IS WORK DELTA LESS OR EQUAL\n         BNL   WRIDSSP1            YES, USE WORK DELTA\n         CVCALL SELDELTA           CONVERT IT TO ACTUAL DELTA\n         ST    R1,CPWKDL           SAVE DELTA TO USE\nWRIDSSP1 PCALL WRIDSSP                 TO 2741'S\n         SPACE\nCALLNGO  PCALL NTGDOPN\n         EJECT\nDSNMSPAC OI    CPLFLG3,CPFSPACE\n         BR    R14\n         SPACE\nDSNMTYPE OI    CPLFLG3,CPFTYPE\n         BR    R14\n         SPACE\nDSNMPROT OI    CPLFLG3,CPFPROTF\n         BR    R14\n         SPACE\nDSNDALL  OI    CPLFLG3,CPFPROTF+CPFTYPE+CPFDATED+CPFSPACE\n         BR    R14\n         SPACE\nDSNMSCRT OI    CPLFLG2,CPFSCRTC         SET \"SCRATCH\" MODE\n         BR    R14                       LOOK FOR MORE\n         SPACE\nDSNMDTED OI    CPLFLG3,CPFDATED         SET DATED OPTION\n         BR    R14                       LOOK FOR MORE\n         SPACE\nSKIP     STH   R15,10(R8)          SAVE SKIP COUNT\n         BR    R14\n         SPACE\nADLIKE   DS    0H                  LIKE PATTERN\n         MVC   4(6,R8),DSNWAVOL    SAVE VOLUME\n         CVCALL DODSNM\n         L     R15,0(R8)           ADDR OF RESCAN ROUTINE\n         ALR   R15,R10             MAKE ADDRESS ABSOLUTE\n         CLI   DSNWAVOL,C' '       WAS VOLUME FOUND IN SCAN?\n         BNER  R15                 BR IF YES\n         CLI   4(R8),C' '          WAS VOLUME THERE BEFORE?\n         BER   R15                 GO START SCAN AGAIN\n         MVC   DSNWAVOL(6),4(R8)   RESTORE OLD VOLUME\n         BR    R15                 GO START SCAN AGAIN\n         SPACE 3\nDSNMEXCL OI    CPLFLG3,CPFEXCL     MARK EXCLUDE\n         SPACE\nDSNMFROM LA    R15,SDSNQLB         ADDR OF LOWER BOUND STORAGE\n         B     DSNMFMTO            GO TO COMMON ROUTINE\n         SPACE\nDSNMTO   XC    SDSNQUB(SDSNQSZ),SDSNQUB   CLEAR UPPER BOUND\n         SPACE\nDSNMTHRU LA    R15,SDSNQUB         ADDR OF UPPER BOUND STORAGE\n         SPACE\nDSNMFMTO SR    R2,R2               LENGTH REG\n         CLI   0(R1),C'$'\n         BE    FMTOERR             $ SPEC INVALID\n         CLI   0(R1),C'*'          WAS PREFIX USE SPECIFIED?\n         BNE   NOFTPFX             BR IF NO\n         LH    R2,CPPFXL           GET PREFIX LENGTH\n         LTR   R2,R2               IS THERE ONE?\n         BZ    NOFTPFX             BR IF NO\n         CLI   CPPFX,C'$'          DOES PFX HAVE $?\n         BE    FMTOPERR            IT'S NFG IF SO\n         LA    R4,CPPFX            ADDR OF SOURCE\n         BCTR  R2,0                FOR EX\n         EX    R2,FMTOMVC          MOVE PREFIX\n         LA    R2,1(R2)            BUMP IT BACK AGAIN\n         AR    R15,R2              UPDATE POINTER\n         LA    R1,1(R1)            BUMP PAST \"*\"\n         BCTR  R0,0                ALSO ADJUST OPERAND LENGTH\n         SPACE\nNOFTPFX  LR    R4,R0               OPERAND LENGTH\n         AR    R4,R2               PLUS PFX LENGTH\n         CH    R4,=H'44'           IS TOTAL OK?\n         BH    FMTOLERR            BR IF TOO LONG\n         LTR   R2,R0               OPERAND LENGTH\n         BZR   R14                 BR IF NULL OPERAND\n         LR    R4,R1               ADDR OF OPERAND\n         BCTR  R2,0                FOR EX\n         EX    R2,FMTOMVC          MOVE OPERAND\n         BR    R14                 EXIT TO SCANNER\n         SPACE\nFMTOMVC  MVC   0(0,R15),0(R4)      MOVE FROM/THRU STRING\n         SPACE 3\nFMTOERR  TSEG  '$'\n         B     FMTOERRX\n         SPACE\nFMTOPERR TSEG  '$ IN PREFIX'\n         SPACE\nFMTOERRX B     CVUNLEGL\n         SPACE\nFMTOLERR TSEG  (1),(0),B\n         TSEG  'TOO LONG'\n         B     CVQTYPE\n         EJECT\nHAVTO    LA    R6,POTLNENO-P023    SET LINE NUMBER RETURN\n         LCR   R6,R6               SET NEGATIVE TO FLAG RELATIVE\n         SCAN  LINPRT              GO GET TO LINE\n         B     CVABSENT            MISSING IF NOTHING FOUND\n         SPACE\nPOTLNENO ST    R0,CPWKPS                SET NEW LINE NO. & DELTA\n         TM    CPWKDL,FNEGBT             WAS DELTA SPE?\n         BZ    POTDEL                    YES. BRANCH\n         ST    R1,CPWKDL\nPOTDEL   SR    R6,R6               FLAG HAVE LINE NUMBER\n         B     NOTFIRST\n         SPACE\nPOTDLL   LTR   R15,R15                  ZERO NG\n         BZ    CVNVALID                 NG\n         ST    R15,CPWKDL               STORE COLLECT DELTA\n         B     NOTFIRST\n         SPACE 3\nBADLINEM L     R0,CPLCNO           GET BAD LINE NUMBER\n         CVCALL CVEXNO             CONVERT TO EXTERNAL FORM\n         TSEG  (1),(0),B           PUT IT IN MESSAGE\nBADLINES TSEG  'LINE NO.'\n         B     CVUNLEGL\n         SPACE 3\nPUTERC   TSEG  'NO REPLACE OR INTERLEAVE'\n         B     CVQTYPE\n         SPACE 3\nBADBAD   B     CVNVALID\n         EJECT\n* SCAN TABLE FOR SHOW DSNAMES\n         SPACE\nPUTSTUFF SCKW  AT,HAVTO\n         SCKW  BY,POTDLL,(P,LN)\nDAPRC    SCKW  ,,PUSH        FILLED IN AT INIT TO CLRPRT\nLAPRC    SCKW  ,,PUSH        FILLED IN AT INIT TO LTNPRT\nDSONPRT  SCKW  DATED,DSNMDTED,A\n         SCKW  LIKE,ADLIKE,A\n         SCKW  FROM,DSNMFROM,(P,A)\n         SCKW  EXCLUDE,DSNMEXCL,(P,A)\n         SCKW  THROUGH,DSNMTHRU,(P,A)\n         SCKW  THRU,DSNMTHRU,P\n         SCKW  TO,DSNMTO,P\n         SCKW  SPACE,DSNMSPAC,A\n         SCKW  SIZE,DSNMSPAC,A\n         SCKW  TRACKS,DSNMSPAC,A\n         SCKW  TYPE,DSNMTYPE,A\n         SCKW  PERMIT,DSNMPROT,A\n         SCKW  ALL,DSNDALL   SPA TYP DAT\n         SCKW  SKIP,SKIP,(P,PI,A),999\n         SCKW  SCRATCH,DSNMSCRT,A\nDSONPRT1 SCKW  ,,PUSH        FILLED IN AT INIT TO IGDSNPRT\nCOMPRT   SCKW  SCRATCH,DSNMSCRT,A\nDSONPRT2 SCKW  ,BADBAD\n         SPACE\nLINPRT   SCKW  ,,PUSH        FILLED IN AT INIT TO LNENOPRT\n         SCKW  ,BADBAD\n         SPACE\nPUTOPT   SCKW  AT,HAVTO\n         SCKW  BY,POTDLL,(P,LN)\nDOPRC    SCKW  ,,PUSH        FILLED IN AT INIT TO CLRPRT\nLOPRC    SCKW  ,,PUSH        FILLED IN AT INIT TO LTNPRT\n         SCKW  ,DSONPRT2,PUSH\n         TITLE 'GETTPAG ROUTINE -- PAGE 23'\nGETTPAGR XENTER 15,8,44       SAVE SPACE (USED BY SHOW DSNAMES)\nGETTPAG  EQU   GETTPAGR-P023        MAKE RELATIVE ADDRESS\n         L     2,CPMDLN       NO PAGES ALREADY\n         LTR   2,2            ANY?\n         BNP   GETTNO1\n         PMARK R9\n         CH    R2,=Y(10)                10 MAX\n         BNL   SENSAME\nGETTNO1  PGET  R9\n         BZ    SENSAME\n         LA    2,1(2)         ONE MORE\n         ST    2,CPMDLN       STORE\n         SLL   2,2            POINT AT PLACE TO STORE PAGE NO\n         ST    0,CPMDAD-4(2)  STORE PAGE NO\nSENSAME  LTR   R9,R9\n         XEXIT 15,8\n         TITLE 'END OF PAGED CODE -- PAGE 23'\n         PINIT             DEFINE END OF CODE - START OF INIT\n         MVC   DSONPRT1+1(3),CVIGDSN+1  SET TO IGDSNPRT\n         MVC   LINPRT+1(3),CVLNENO+1  SET TO LNENOPRT\n         MVC   LAPRC+1(3),CVLTNPR+1   SET TO LTNPRT\n         MVC   DAPRC+1(3),CVCLRPR+1   SET TO CLRPRT\n         MVC   LOPRC+1(3),CVLTNPR+1   SET TO LTNPRT\n         MVC   DOPRC+1(3),CVCLRPR+1   SET TO CLRPRT\n         PEND                      END OF PAGE\n         TITLE 'START OF PAGED CODE -- PAGE 26'\nP026     PAGECDE SHOSPAC,DSNERR,GOCOMP\n         WIDENT 001\n         TITLE 'SHOW SPACE -- PAGE 26'\nPSHOSPAC GENTER  ,\n         SCAN  SHSPCPRT            SCAN FOR OPTIONS\n         B     CVABSENT\n         SPACE 3\nSHSPCON  DS    0H\n         DENTER SDSNDSZ,C12,,NO\n         XC    CPDSNWA(DSSIZ),CPDSNWA   CLEAR DSNAME WORK AREA\n         MVC   DSNWAVOL(6),0(R15)  SAVE VOLUME\n         MVC   DSNWADSN,=X'05050505'  DSN IS FORMAT 5 DSCB\n         MVI   DSNWANL+1,4         LENGTH OF DSNAME\n         PCALL SHODSN\n         TITLE 'ERROR MESSAGES -- PAGE 26'\nPDSNERR  GENTER ,\n         XC    RTBWC(4),RTBWC\n         B     *(R2)               JUMP AROUND\n         SPACE\n         B     PPOTERD             4\n         B     PPOTERC             8\n         B     CVGETCOM            12\n*                                  16\n         SPACE 3\nPWHAT    TM    CPLFLG3,CPFPMSG     ALREADY GIVEN 1 OF THESE?\n         BO    CVGETCOM            YES. DONT TALK SO MUCH\n         PCALL NOMORPG             ALRIGHT..BETTER SAY SOMETHING\n         SPACE\nPPOTERD  TSEG  '99999.999 EXCEEDED'\n         B     CVGETCOM\n         SPACE\nPPOTERC  TSEG  'ABORTED BY ATTEMPT TO REPLACE OR INTERLEAVE',,B\n         MVC   CPWORK1(4),CPCURRL\n         CVCALL LSLNMSG   GO DO LAST LINE MSG & DON'T COME BACK\n         TITLE 'COMPARE ROUTINE -- PAGE 26'\nPGOCOMP  GENTER ,\n         SR    R5,R5\n         LA    R1,16(,R8)          POINT TO\n         CVCALL LOCATE                 HIGH LINE NO\n         TM    CPDRPT,CPFNTYT+CPFHIGH  DONE IF TOO HIGH OR NONE\n         BNZ   TOOHIX\n         SYSQS 6,5,'DON''T '\nLOOPA    LR    R1,R8                    POINT AT 1ST LINE NO.\n         MVI   32(R8),X'40'\n         MVC   33(165,R8),32(R8)\n         CVCALL LOCATE                   LOCATE\n         TM    CPDRPT,CPFMTCH           MATCH?\n         BO    HAVLN1                   YES\n         MVC   0(4,R8),CPLCNO           SET FOR NEXT LOCATE\n         TM    CPDRPT,CPFPGHI          IS IT END OF PAGE\n         BE    HAVLN1                  NO, WE HAVE NEXT LINE\n         B     LOOPA                    GET IT\n         SPACE 3\nHAVLN1   LA    R1,C32(,R8)\n         CVCALL UNPRESS\n         LR    R2,R0\n         PFLIP 11,9                    SAVE PAGE POINTER\nLOOPB    LA    R1,16(R8)                POINT AT 2ND LINE NO.\n         CVCALL LOCATE                   LOCATE\n         TM    CPDRPT,CPFMTCH           MATCH?\n         BO    HAVLN2                   YES\n         MVC   16(4,R8),CPLCNO          SET FOR NEXT LOCATE\n         TM    CPDRPT,CPFPGHI          IS IT END OF PAGE\n         BE    HAVLN2                  NO, WE HAVE NEXT LINE\n         B     LOOPB                    GET IT\n         SPACE\nHAVLN2   LA    R1,C32+SZR(,R8)\n         CVCALL UNPRESS\n         LM    R3,R4,CPWK1\n         LTR   R4,R4\n         BNZ   GOCOMP\n         LR    R4,R2\n         CR    R2,R0\n         BNL   GOCOMP\n         LR    R4,R0\nGOCOMP   SR    R4,R3\n         BM    COMPOK\n         BCTR  R3,0\n         LA    R3,0(R8,R3)\n         EX    R4,CCCOMP2\n         BNE   OUTPUTT                  NOT SAME\nCOMPOK   LR    R3,R0\n         L     R0,16(R8)                LINE 2\n         C     R0,CPHIPS           FINISHED LAST LINE IN FILE\n         BNL   OUTPAT              YES, REPORT ALL COMPARE\n         LA    R1,1                     INCREMENT\n         CVCALL ADDER                    NEXT\n         ST    R0,16(R8)                SET\n         L     R0,0(R8)                 LINE 1\n         LA    R1,1                     INCREMENT\n         CVCALL ADDER                    NEXT\n         ST    R0,0(R8)                 SET\n         B     LOOPA                    MORE\n         SPACE 3\nOUTPAT   SR    R5,R5               ZERO COUNT SO 'DON''T ' OMITTED\nOUTPUTT  LR    R3,R0\n         L     R0,0(,R8)               LINE 1\n         CVCALL CVEXNO                   CONV\n         TSEG  (1),(0),B           INTO MSG\n         TSEG  '--',,B\n         L     R0,16(,R8)              LINE 2\n         CVCALL CVEXNO                   CONV\n         TSEG  (1),(0),B                INTO MSG\n         TSEG  (6),(5)\nTOOHIX   TSEG  'COMPARE',,W\n         TM    CPLFLG5,CPFNLST     NOLIST OPTION\n         BO    CVGETCOM            YES, GO GET NEXT COMMAND\n         LTR   R5,R5               DID LAST COMPARE OR NOT\n         BZ    CVGETCOM            COMPARE, DO NOT LIST THEM\n         LR    R1,R8               POINT TO 1ST LINE NO\nCOMPLST  LA    R1,C32(,R8)         POINT TO UNPRESS AREA\n         MVC   CPLCNO(4),0(R8)\n         LR    R0,R2\nCOMPLST1 CVCALL LISTLINE            FORMAT LINE FOR OUTPUT\n         LTR   R5,R5               SECOND TIME THROUGH\n         BZ    CVGETCOM            YES, GO GET NEXT COMMAND\n         SR    R5,R5               SET SWITCH FOR 2ND PASS\n         LA    R1,C32+SZR(,R8)\n         LR    R0,R3\n         MVC   CPLCNO(4),16(R8)\n         B     COMPLST1\n         SPACE\nCCCOMP2  CLC   C32(1,R3),C32+SZR(R3)\n         SPACE 3\n* SCAN TABLES FOR SHOW SPACE\n         SPACE\nINVAL    B     CVNVALID\n         SPACE\nSHSPCPRT SCKW  ON,SHSPCON,P\nSHSPC1   SCKW  ,INVAL\n         TITLE 'END OF PAGED CODE -- PAGE 26'\n         PINIT             DEFINE END OF CODE - START OF INIT\n         PEND                      END OF PAGE\n         TITLE 'START OF PAGED CODE -- PAGE 24'\nP024     PAGECDE WRIDSSP\n         WIDENT 001\n         TITLE 'WRITE OUTPUT FOR SHOW DSNAMES/SPACE -- PAGE 24'\n* WRIDSSP IS USED TO LIST INFORMATION PASSED FROM SHOW DSNAMES\n* AND SHOW SPACE\n*   CPMDLN CONTAINS THE NUMBER OF PAGES OF INFORMATION.\n*   CPMDAD CONTAIN UP TO TEN PAGE NUMBERS.\n*   THE FIRST HALF-WORD ON EACH PAGE IS THE PAGE BYTE-COUNT.\n*   EACH FIRST BYTE IN A LINE IS THE CHARACTER COUNT FOR THE LINE.\n*   A LINE CHARACTER COUNT OF ZERO INDICATES ALL DONE.\n*\n*   THE WORD AFTER 'DSSIZ' (DSSIZ+4 BELOW) IS USED TO STORE\n*   THE SKIP COUNT FOR SHOW DSNAMES AND THE ORIGINAL\n*   PATTERN LENGTH FOR SHOW CATLG.\n         SPACE\nPWRIDSSP DENTER DSSIZ+4,SDSNDSZ-DSSIZ+SBSZ\n         NI    CPLFLG3,255-CPFPUTER\n         L     R5,CPMDLN                NO. PAGES\n         LA    R6,CPMDAD-4              4 BYTES B/4 1ST PAGE NO\n         SR    R4,R4\n         LTR   R5,R5                    ANY?\n         BP    GTNXTPG             YES, START LOOP\n         PCALL NOMORPG             NO, ISSUE MESSAGE TO USER\n         SPACE\nGTNXTPG  LA    R6,4(R6)                 POINT AT NEXT PAGE NO\n         LTR   R9,R9                    PAGE IN?\n         BZ    GETNXPG                  NO\n         PNUM  R9                       WHICH PAGE IS IN?\n         C     R0,0(R6)                 RIGHT ONE?\n         BE    PROCPAG                  YES\nGETNXPG  L     R0,0(R6)                 PAGE NO NEEDED\n         PGET  R9,(0)                   GET IT\n         LTR   R4,R4\n         BNZR  R4\nPROCPAG  LA    R3,2                     NO. BYTES PROCESSED ON PAGE\nNEXTLINX CH    R3,0(R9)            MORE ON PAGE?\n         BNL   GONXPAG                  NO\n         TM    CPLFLG2,CPFSTOP          TEST IF MORE WANTED\n         BNZ   GONXPAG                  NO MORE\n         SR    R2,R2\n         IC    R2,0(R3,R9)              LINE CHAR COUNT\n         LTR   R0,R2                    ANY?\n         BZ    ALLDONN                  NO\nLOADAFC  LA    R1,1(R3,R9)         POINT AT 1ST CHAR IN LINE\n         SPACE 3\n* FORMAT AND WRITE INFORMATION FOR SHOW DSNAMES COMMAND.\n*\n* REGISTERS ARE USED AS FOLLOWS:\n*   R2    CHAR COUNT IN LINE OF DATA.\n*   R3    NUMBER OF BYTES PROCESSED IN CURRENT PAGE.\n*   R4    POINTS TO CURRENT INPUT LINE (SDSNBUF).\n*   R5    NUMBER OF PAGES TO BE PROCESSED.\n*   R6    PAGE INDEX POINTER.\n         SPACE\n         CH    R2,=Y(SBSZ)         IS IT DSNAME LINE?\n         BE    WDSN                BR IF YES\n         TSEG  (1),(0)             NO - WRITE COMPLETE LINE\n         TM    CPLFLG3,CPFPUT\n         BZ    LWRITE\n         B     DIDNTADD\n         SPACE 3\n* FORMAT DSNAME RECORD\n         SPACE\nWDSN     LR    R4,R13              END OF CURRENT WORK AREA\n         SH    R4,=Y(SBSZ)         GET AMOUNT ACTUALLY NEEDED\n         N     R4,=F'-8'           ALIGN DOUBLEWORD\n         MVC   0(SBSZ,R4),0(R1)    MOVE CURRENT RECORD\n         AIF   ('&DCEC' EQ '1').LBLX2\n         USING SDSNBUF,R4\n         AGO   .LBLX3\n.LBLX2   DS    0H\n         USING SBUF,R4\n.LBLX3   DS    0H\n         MVC   DSNWADSN,SBDSN      MOVE ACTUAL DSNAME\n         LA    R1,0(R8)            ADDR OF WORK AREA\n         CLI   SBDSN,X'05'         IS IT SHOW SPACE?\n         BE    WNOLTW              BR IF YES\n         LH    R0,CPDSNWA+DSSIZ    GET SKIP COUNT\n         LTR   R0,R0               TEST VALUE\n         BP    WDSNSKP             SKIP THIS ONE\n         SYSQS R1,R0,DSNWADSN+43,44\nWDSNL    CLI   0(R1),X'40'\n         BNE   HAVDSNL             BR IF LAST CHAR\n         BCTR  R1,0                CHECK NXT CHAR\n         BCT   R0,WDSNL            LOOP\nHAVDSNL  STH   R0,DSNWANL          SAVE DSNAME LENGTH\n         MVI   DSNWAF1,0           CLEAR ATTRIBUTE FLAGS\n         CVCALL DSNSTDDO          GO SET ATTRIBUTE FLAGS\n         CVCALL DSNUDSDO          SET MY FLAGS\n         CVCALL DSNAMED            GO TSEG DSNAME\n         TM    CPLFLG3,CPFDATED+CPFSPACE+CPFTYPE+CPFPROTF\n         BZ    NOWWHAT             BR IF NO OTHER OPTIONS\n         TM    CPLFLG3,CPFSPACE    WAS SPACE SPECIFIED?\n         BZ    WNOSPC              BR IF NO\n         SPACE\n* FORMAT SPACE INFORMATION\n         TSEG  '--',,B\n         LA    R1,0(R8)            START OF WORK AREA\n         LH    R15,SBLB            LAST TT\n         LA    R15,1(R15)          (REL TO 0)\n         CH    R15,SPTRK           SAME AS LAST ALLOC TRK?\n         BNL   WNOLTW              BR IF YES\n         BTD   (1),0,(15)          CONVERT\n         AR    R1,R0               BUMP PTR BY LENGTH\n         MVC   0(4,R1),=C' OF '\n         LA    R1,4(R1)\nWNOLTW   LH    R15,SPTRK           NUMBER OF TRKS ALLOCATED\n         LTR   R15,R15             TEST SPACE ALLOC COMPLETE?\n         BNM   WNOLTW2             BR IF YES\n         STM   R0,R1,CPDOUB        SAVE AROUND TSEG\n         TSEG  '>>'\n         LM    R0,R1,CPDOUB\n         LPR   R15,R15\nWNOLTW2  BTD   (1),0,(15)          CONVERT\n         AR    R1,R0               BUMP PTR BY LENGTH\n         MVC   0(5,R1),=C' TRKS'\n         LA    R1,5(R1)\n         CLI   SBNOEX,1            WAS THERE ONE EXTENT?\n         BE    WNOEXT              BR IF YES - DON'T BOTHER\n         MVC   0(2,R1),=C', '\n         LA    R1,2(R1)\n         SPACE\n* FORMAT NUMBER OF EXTENTS USED\n         SR    R15,R15\n         IC    R15,SBNOEX          NUMBER OF EXTENTS\n         CLI   SBDSN,X'05'         IS IT SHO SPA?\n         BNE   *+8                 IF NOT SKIP NEXT INSTR\n         LH    R15,SBDSN+8         GET REAL # OF EXTENTS\n         BTD   (1),0,(15)          CONVERT\n         AR    R1,R0               BUMP PTR BY LENGTH\n         MVC   0(5,R1),=C' EXTS'\n         LA    R1,5(R1)\n         CLI   SBDSN,X'05'\n         BNE   WNOEXT\n         MVC   0(2,R1),=C', '\n         LA    R1,2(R1)\n         L     R15,SBDSN+4\n         BTD   (1),0,(15)          CONVERT\n         AR    R1,R0               BUMP PTR BY LENGTH\n         MVC   0(9,R1),=C' TRKS MAX'\n         LA    R1,9(R1)\nWNOEXT   LR    R0,R1               CURRENT POINTER\n         LA    R1,0(R8)            START OF WORK AREA\n         SR    R0,R1               LENGTH OF LINE\n         TSEG  (1),(0)\n         CLI   SBDSN,X'05'         IS IT SHOW SPACE?\n         BE    NOWWHAT\n         TM    DSNWAF1,DSNFSTD     STANDARD WYLBUR DSN?\n         BZ    WNOSPC\n         CLI   SBACCTG,0           ACCOUNTED FOR?\n         BNE   WNOSPC\n         TM    JCBAFL,JCBSYSPR\n         BZ    WNOSPC\n         TSEG  ' N/A'              INDICATE NOT ACCOUNTED FOR\n         SPACE\n* FORMAT  FILE TYPE INFO AND DATE INFO ON SECOND LINE.\nWNOSPC   TM    CPLFLG3,CPFTYPE+CPFDATED+CPFPROTF\n         BZ    NOWWHAT\n         TSEG  '   '               ADD BLANKS\n         TM    CPLFLG3,CPFTYPE     WAS TYPE SPECIFIED?\n         BZ    WNOTYPE             BR IF NO\n         LA    R1,0(R8)            START OF WORK AREA\n         SPACE\n* FORMAT TYPE INFORMATION\n         SR    R15,R15\n         NI    SBDSORG,X'E2'       CLEAR GARBAGE BITS\n         IC    R15,SBDSORG         GET DSORG BYTE\n         SRL   R15,4               MOVE PS,IS,DA TO LOW BITS\n         TM    SBDSORG,X'02'       PO?\n         BZ    *+8                 BR IF NO\n         LA    R15,1(R15)          YES - ADD ITS BIT\n         STC   R15,SBDSORG         SAVE DSORG INDEX BYTE\n         SPACE\n* DSORG NOW HAS LOW ORDER FOUR BITS REPRESENTING PS/IS/DA/PO\n         TR    SBDSORG,DSORGTR     TRANSLATE INTO INDEX BYTE\n         IC    R15,SBDSORG         GET INDEX\n         LA    R15,DSORGTBL(R15)   GET ADDR OF DISPLAY\n         MVC   0(2,R1),0(R15)      MOVE TO DISPLAY BUFFER\n         MVC   2(2,R1),=C', '\n         LA    R1,4(R1)            BUMP PTR\n         SPACE\n* FORMAT RECFM\n         SR    R15,R15\n         IC    R15,SBRECFM\n         SRL   R15,6               ONLY PROCESS F/V/U\n         LA    R15,RECFMTBL(R15)   GET ADDR OF CHAR\n         MVC   0(1,R1),0(R15)      MOVE IT TO BFR\n         LA    R1,1(R1)\n         SPACE\n* FORMAT REST OF RECFM\n         TM    SBRECFM,X'10'       BLOCKED?\n         BZ    *+12                BR IF NO\n         MVI   0(R1),C'B'\n         LA    R1,1(R1)\n         TM    SBRECFM,X'20'       TRACK OVERFLOW?\n         BZ    *+12                BR IF NO\n         MVI   0(R1),C'T'\n         LA    R1,1(R1)\n         TM    SBRECFM,X'08'       STANDARD?\n         BZ    *+12                BR IF NO\n         MVI   0(R1),C'S'\n         LA    R1,1(R1)\n         TM    SBRECFM,X'04'       ASA CONTROL?\n         BZ    *+12                BR IF NO\n         MVI   0(R1),C'A'\n         LA    R1,1(R1)\n         TM    SBRECFM,X'02'       MACHING CONTROL?\n         BZ    *+12                BR IF NO\n         MVI   0(R1),C'M'\n         LA    R1,1(R1)\n         MVI   0(R1),C'/'\n         LA    R1,1(R1)\n         SPACE\n* FORMAT LRECL\n         LH    R15,SBLRECL\n         BTD   (1),0,(15)          CONVERT\n         AR    R1,R0               PTR PLUS LENGTH\n         MVI   0(R1),C'/'\n         LA    R1,1(R1)\n         SPACE\n* FORMAT BLOCKSIZE\n         LH    R15,SBBLKSZ\n         BTD   (1),0,(15)          CONVERT\n         AR    R1,R0               PTR+LENGTH\n         SPACE\n* CHECK IF A KEYLENGTH\n         CLI   SBKEYL,0            IS THERE ONE?\n         BE    WPRTYPE             BR IF NO\n         MVI   0(R1),C'/'\n         LA    R1,1(R1)\n         SR    R15,R15\n         IC    R15,SBKEYL\n         BTD   (1),0,(15)\n         AR    R1,R0\n         SPACE\n* PRINT IT\nWPRTYPE  LR    R0,R1               CURR PTR\n         LA    R1,0(R8)            START OF WORK AREA\n         SR    R0,R1               LENGTH\n         TSEG  (1),(0)\n         TM    CPLFLG3,CPFDATED+CPFPROTF\n         BZ    NOWWHAT\n         TSEG  ';',,B\nWNOTYPE  TM    CPLFLG3,CPFDATED+CPFPROTF\n         BZ    NOWWHAT             BR IF NO\nWOKTYPE  TM    CPLFLG3,CPFPROTF\n         BZ    WDATED\n         SPACE\n* FORMAT PROTECTION\n         CVCALL TPROTF\n         TM    CPLFLG3,CPFDATED\n         BZ    NOWWHAT\n         TSEG  ';',,B\n         SPACE\n* FORMAT DATES\nWDATED   LR    R1,R8\n         MVC   CPWK2+1,SBCRDT      CREATION DATE\n         MVC   CPWK3+1,SBEXDT      LAST ACCESS DATE\n         DROP  R4\n         LA    R15,CPWK2           ADDR OF CREATION DATE\n         BAL   R4,WCNVDT           GO CONVERT\n         MVI   8(R1),C' '          SEPERATOR\n         LA    R1,9(R1)           BUMP PTR BY DATE AND PREV\n         LA    R15,CPWK3           ADDR OF LAST ACCESS DATE\n         BAL   R4,WCNVDT           GO CONVERT\n         LA    R1,8(R1)            BUMP PTR BY SECOND DATE\n         LR    R0,R1               CURR PTR\n         LA    R1,0(R8)            START OF WORK AREA\n         SR    R0,R1               LENGTH\nNOWTSEG  TSEG  (1),(0)\n         B     NOWWHAT             ALL DONE\n         SPACE 3\n* SHOW DSNAMES SKIP COUNT NOT YET ZERO\n         SPACE\nWDSNSKP  BCTR  R0,0                DECREMENT BY ONE\n         STH   R0,CPDSNWA+DSSIZ    SAVE NEW VALUE\n         B     NEXTLIN             GO ON TO NEXT LINE\n         EJECT\nNEXTRY   LR    R15,R1                  GET ADDR OF LAST CHAR\n         AR    R15,R0\nNEXTRYX  BCTR  R15,0                   BACK UP ONE CHAR\n         CLI   0(R15),C' '              BLANK?\n         BNE   NOWTSEG             NO\n         BCT   R0,NEXTRYX\nNEXTLIN  LA    R3,1(R3,R2)             COUNT TO NEXT LINE\n         B     NEXTLINX\n         SPACE 3\nNOWWHAT  TM    CPLFLG3,CPFPUT            PUT?\n         BZ    DONTPUT                   NO. BRANCH.\nPONEXT   LM    R0,R1,CPWKPS             LINE NO.\n         CVCALL ADDER                   ADD\n         BM    POTERD                   TOO BIG\n         ST    R0,CPWKPS                SAVE NEXT LINE NO.\n         ST    R0,CPLCNO                FOR LISTLINE ROUTIN\nDIDNTADD MVC   0(133,R8),RTBTEXT        INTO WORK AREA\n         LH    R0,RTBWC\n         LR    R1,R8                    SET POINTER\n         L     R15,CPWKPS               LINE NO. INTO R15\n         CVCALL PRESS                   PRESS\n         CVCALL STOWIT                STOW IT AWAY\n         BM    POTERC                   REPL ERR\n         BNZ   BADFIT\n         MVC   CPCURRL(4),CPWKPS   SET CURRENT LINE\n         PNUM  R9                       CHECK ON R9?\n         C     R0,0(R6)\n         BE    NOWWRIT\n         BAL   R4,GETNXPG               GET IT BACK\n         EJECT\nNOWWRIT  LH    R0,RTBWC\n         XC    RTBWC(4),RTBWC\n         TM    CPLFLG5,CPFNLST          NOLIST?\n         BO    NEXTLIN                  YES   BRANCH.\n         MVC   0(133,R8),RTBTEXT        INTO WORK AREA\n         LR    R1,R8\n         CVCALL LISTLINE\n         BP    DSNMATTN                 ATTN HIT.\nDONTPUT  TM    CPLFLG2,CPFSCRTC         \"SCRATCH\" OPTION?\n         BO    PPROMPTT                 YES\nLWRITE   TM    CPLFLG3,CPFPUT            PUT COMMAND?\n         BO    NEXTLIN                  LINE ALREADY PRINTED\n         TWRITE ,\n         BP    DSNMATTN\n         B     NEXTLIN\n         EJECT\nBADFIT   LR     R2,R15                   MAKE A TRADE\n         B      CALLPERR\n         SPACE\nPOTERD   LA    R2,4\n         B     CALLPERR\n         SPACE\nPOTERC   LA    R2,8\nCALLPERR OI    CPLFLG3,CPFPUTER\n         SPACE\nDSNMATTN OI    CPLFLG2,CPFSTOP          SET TO PRINT NO MORE\nGONXPAG  PFREE R9,EMPTY                 SCRATCH PAGE\n         SR    R4,R4\n         BCT   R5,GTNXTPG               GET NEXT PAGE (IF ANY)\nALLDONN  PFREE R9,EMPTY                 SCRATCH LAST PAGE\n         TM    CPLFLG3,CPFPUTER\n         BZ    CVGETCOM\n         PCALL DSNERR\n         SPACE 3\nDSORGTR  DC    AL1(0,4,6,0,2),XL3'0',AL1(8),XL7'0'  INDEX VALUES\nDSORGTBL DC    C'**PSPODAIS'       DISPLAYS\nRECFMTBL DC    C'*VFU'             DISPLAYS\n         SPACE 3\n* ROUTINE TO CONVERT DSCB DATE INTO MM/DD/YY FORMAT.\n*   R1 POINTS TO AREA WHERE CONVERTED DATE TO BE PLACED,\n*   R15 POINTS TO FULLWORD WITH DSCB DATE IN LAST THREE BYTES\n         SPACE\nWCNVDT   SR    R0,R0\n         IC    R0,1(R15)           GET YEAR\n         MH    R0,=H'1000'         YEAR VALUE\n         AH    R0,2(R15)           ADD JULIAN DAY\n         CVD   R0,CPDOUB           CONVERT TO DEC\n         L     R0,CPDOUB+4         GET VALUE\n         CVCALL DATE                CONVERT\n         BR    R4                  RETURN\n         EJECT\n* PROMPT FOR SCRATCH IF DATA SET IS CANDIDATE FOR SCRATCHING\n* BY THIS USER.  OTHERWISE, FORGET THE PROMPT.\n         SPACE\nPPROMPTT TM    JCBAFL,JCBSYSPR     SYSTEM PRIVILEGES?\n         BO    PPETC2              YES..LET NOLIST STAY\n         TM    DSNWAF1,DSNFMYDS    BELONG TO USER?\n         BZ    LWRITE              BR IF NO\n         TM    DSNWAF1,DSNFWLIB    IS IT A WYLBUR LIB?\n         BO    LWRITE              YES - CON'T PROMPT\nPPETC2   SR    R1,R1\n         IC    R1,0(R3,R9)\n         CH    R1,=Y(SBSZ)\n         BNE   LWRITE\n         TM    CPLFLG5,CPFPUT\n         BO    NOPMARK\n         TMARK\nNOPMARK  SYSQS R1,R0,'SCRATCH'\nPPETC3   TREADR (1),(0)\n         BP    DSNMATTN            ABORT IF ATTENTION\n         SCINIT (1),(0)                 INIT SCAN\n         SCAN  YESSPRT                  LOOK FOR \"YES\"\n         B     NEXTLIN                  DO MORE\n         SPACE\nYESREPLY DSCRATCH ,                SCRATCH IT\n         BZ    NEXTLIN                  ON TO NEXT\n         L     R14,CVDSNMED        ADDR OF DSNAMED\n         BALR  R14,R14             GO DO PROPER ROUTINE\n         TSEG  'NOT SCRATCHED',,W\nYESRETN  BP    DSNMATTN\n         B     NEXTLIN\n         EJECT\nYESSPRT  SCKW  YES,YESREPLY\n         SCKW  OK,YESREPLY\n         SCKW  ,NEXTLIN\n         TITLE 'END OF PAGED CODE -- PAGE 24'\n         PINIT             DEFINE END OF CODE - START OF INIT\n         PEND                      END OF PAGE\n         TITLE 'CONSTANTS, ETC.'\n         COPY  WYLCONST\n         EJECT\n         COPY  RTNCODES\n         TITLE 'COPY MODS'\n         AIF   ('&DCEC' EQ '1').LBLX4\nSDSNBUF  DSECT\n         COPY  SDSNBUF\n         SPACE 3\n         COPY  SCATBUF\n         EJECT\n.LBLX4   DS    0F\nWDIOWA   WDIOWA DSECT\n         EJECT\n.LBL06   DS    0H                                               JEP00X\n         COMMON ,\n         SPACE 3\nCPUNSIZE EQU   CPWK2\nCPFOV    EQU   X'08'               FLAG FOR OVER SIZE\nCPFUN    EQU   X'04'               FLAG FOR UNDER SIZE\nCPFEQ    EQU   X'10'               FLAG FOR EQUAL SIZE\n         SPACE\n         PRINT NOGEN\nCVT      DSECT\n         CVT   SYS=VMS\n         SPACE\n         END\n./ ADD NAME=PEDP8    0100-80193-80193-1611-02037-02037-00000-$SYS13  00\nPEDP     TITLE 'START OF PAGED CODE -- PAGE 2'\n* PROPERTY OF C. U. C. C. A.\n         SPACE 3\n         GBLC    &DCEC             SWITCH FOR DCEC MODS         JEP00X\n         GBLC    &USPS                                          USPS01\n         GBLC    &CHKSPCE                                       USPS01\n&USPS    SETC  '1'                                              USPS01\n&DCEC    SETC   '1'  CHANGE TO ANY OTHER NUM. TO DELETE DCEC MODJEP00X\n         AIF   ('&DCEC' NE '1').LBL01                           JEP00X\n*                                                               JEP006\n*                                                               JEP006\n* MOD JEP006                                                    JEP006\n*  INTERFACED WYLBUR TO TSO'S HELP COMMAND PROCESSOR.           JEP006\n*  MODULES AFFECTED: PEDP, PWYL ...DENOTED JEP006 IN 66/71.     JEP006\n*                                                               JEP006\n*                                                               JEP006\n*                                                               JEP001\n*                                                               JEP001\n*                                                               JEP001\n* MOD JEP001                                                    JEP001\n*  IMPLEMENTED DCEC NAMING CONVENTIONS. DENOTED JEP001 IN 66/71 JEP001\n*  MODULES AFFECTED: PDIO,PEDS,PUTB,INIT MACRO(DSNWA,CVTSO)     JEP001\n*                                                               JEP001\n*                                                               JEP001\n*\n* MOD\n*  MODULES AFFECTED ARE PWYL, PEDP AND MACRO(ROUTBLE)\n*  DENOTED BY  IN CC 66/71.     JERRY PITTENGER\n*\n*\n.LBL01   DS    0H                                               JEP00X\nP002     PAGECDE COMPARE,GODUMP,CLEAR\n         WIDENT 001\n         USING  CPAREA,R12\n         TITLE 'DUMP ROUTINE -- PAGE 2'\nPGODUMP  GENTER ,\n         SCAN  ARGPRT                   GET LOC TO DUMP\n         B     CVABSENT                 CAN'T DO\nTHISS    CH    R0,=Y(8)                 8 CHAR MAX\n         BH    CVNVALID                 CAN'T DO\n         XCALL HXCVT                    CONVERT ADDR\n         LA     R15,GONXCM\n         ST     R15,CVSPIEAD\n         L     R2,CPDOUB                ADDR TO R2\nTINHERE  LA    R13,300(R13)             WORK SPACE\nNXLINE   L     R6,CVTPTR                CVT POINTER\n         USING CVT,R6\n         L     R6,CVTMZ00               CURRENT MACHINE SIZE\n         DROP  R6\n         S     R6,=A(31)                DON'T PUSH TOO CLOSE TO EOCORE\n         CR    R2,R6                    CHECK IF LEGAL CORE VALUE\n         BH    GONXCM                   YES\n         ST    R2,CPWA+200              START ADDR DUMP\n         MVC   CPWA+204(32),0(R2)       CONTENT OF DUMP\n         LA    R6,CPWA+100              POINT TO UNPACK AREA\n         LA    R5,CPWA+201              SOURCE AREA\n         LA    R4,5                     35 SOURCE BYTES = 5 TIMES\nNXTUN    UNPK  0(15,R6),0(8,R5)         UNPACK 7 BYTES\n         LA    R6,14(R6)                UPDATE PTRS\n         LA    R5,7(R5)\n         BCT   R4,NXTUN                 MORE?\n         TR    CPWA+100(70),HEXTRTB     TRANSLATE\n         MVC   CPWA(6),CPWA+100         MOVE ADDR\n         LA    R4,CPWA+106              SET SOURCE ADDR START\n         LA    R6,2                     2 ROUNDS\n         MVC   CPWA+43(3),=C'  *'\n         MVC   CPWA+46(16),CPWA+204\n         MVI   CPWA+62,C'*'\nNXLIN    MVI   CPWA+6,C' '\n         LA    R5,CPWA+7                SET TARGET ADDR START\n         LA    R3,4                     4 TIMES/ROUND\nNXMUV    MVI   0(R5),C' '\n         MVC   1(8,R5),0(R4)            MOVE IN 8 CHARS\n         LA    R4,8(,R4)                KICK SOURCE PTR\n         LA    R5,9(,R5)                & TARGET PTR\n         BCT   R3,NXMUV                 MORE IN ROUND\n         TR    CPWA+46(16),PRTBL\n         TSEG  CPWA,63,W                OUTPUT\n         BP    GONXCM\n         MVC   CPWA+46(16),CPWA+204+16\n         MVC   CPWA(6),=6C' '\n         BCT   R6,NXLIN                 NEXT ROUND\n         L     R2,CPWA+200              LAST ADDR\n         LA    R2,32(R2)                NEXT ADDR\n         B     NXLINE                   DO MORE\nGONXCM   LR    R13,R8                   RESET R13 B/4 NEXT COMMAND\n         B     CVGETCOM                 NEXT COMMAND\n         SPACE 3\nTDIREC   LA    R2,CPDREC                POINT AT DIREC\n         B     TINHERE                  GO\n         SPACE\nTCPWYL   LA    R2,CPGLDL          POINT AT CPGLDL\n         B     TINHERE                  GO\n         SPACE\nTROUTBLE LA    R2,ROUTBLE          LOAD ADDRESS OF ROUTBLE\n         B     TINHERE             GO\n         SPACE 3\nHEXTRTB  EQU   *-C'0'\n         DC    CL16'0123456789ABCDEF'\n         SPACE 3\nPRTBL    DC    64C'.'\n         DC    X'40',10C'.'\n         DC    X'4B4C4D4E4F50',9C'.'\n         DC    X'5A5B5C5D5E5F6061',9C'.'\n         DC    X'6B6C6D6E6F',10C'.'\n         DC    X'7A7B7C7D7E7F80818283848586878889',C'.'\n         DC    X'8B',5C'.'\n         DC    X'919293949596979899',C'.'\n         DC    X'9B',6C'.'\n         DC    X'A2A3A4A5A6A7A8A9',3C'.'\n         DC    X'AD',15C'.'\n         DC    X'BD',3C'.'\n         DC    X'C1C2C3C4C5C6C7C8C9',7C'.'\n         DC    X'D1D2D3D4D5D6D7D8D9',8C'.'\n         DC    X'E2E3E4E5E6E7E8E9',6C'.'\n         DC    X'F0F1F2F3F4F5F6F7F8F9',6C'.'\n         SPACE 3\nHXCVT    LR    R2,R0                    SAVE PTRS\n         LR    R3,R1\nTHISNX   CLI   0(R1),C'A'               LESS A NG\n         BL    BADADDR                  CAN'T DO\n         CLI   0(R1),C'F'               A TO F OK\n         BH    THISNUM\n         TR    0(1,R1),ALPHTRTB         TRANS\n         B     THISOK\n         SPACE\nTHISNUM  CLI   0(R1),C'0'               LESS 0 NG\n         BL    BADADDR                  CAN'T DO\n         CLI   0(R1),C'9'               GTR 9 NG\n         BH    BADADDR                  CAN'T DO\nTHISOK   LA    R1,1(R1)                 KICK PTR\n         BCT   R0,THISNX                MORE?\n         EX    R2,PACKEM                PACK IT\n         MVI   CPDOUB,X'00'             IGNORE HI ORDER BITS\n         NI    CPDOUB+3,X'F8'           ALIGN D-W\n         L     R6,CVTPTR\n         USING CVT,R6\n         L     R6,CVTMZ00\n         DROP  R6\n         S     R6,=A(31)\n         C     R6,CPDOUB\n         BL    BADADDR\n         BR    R14                      RETURN TO CALLER\n         SPACE 3\nBADADDR  TSEG  'INVALID ADDRESS'\n         B     CVQTYPE\n         SPACE\nPACKEM   PACK  CPDOUB(5),0(0,R3)\n         SPACE\nALPHTRTB EQU   *-C'A'\n         DC    X'0A0B0C0D0E0F'\n         SPACE 3\nARGPRT   SCKW  DIR,TDIREC\n         SCKW  CP,TCPWYL\n         SCKW  ROUTBLE,TROUTBLE,A\n         SCKW  ,THISS\n         TITLE 'COMPARE ROUTINE -- PAGE 2'\nPCOMPARE GENTER C32+SZR+SZR\n         CLC   CPAGCT(2),=D'0'     IS THERE AN ACTIVE FILE\n         BNE   COMPAR1             BRANCH YES\n         CVCALL ITSNIL             NO, REPORT ERROR\n         SPACE\nCOMPAR1  LA    R6,LN1HV-P002       SET FOR FIRST LINE NUMBER\n         LCR   R6,R6               MAKE REL ADDR NEGATIVE AS FLG\n         SR    R2,R2               ZERO FOR IC\n         SCAN  LN1PRT              1ST LINE NO.\n         B     CVABSENT            VOID NG\n         SPACE\nLN1HV    ST    R0,0(R8)            SAVE LINE 1\n         ST    R0,16(,R8)          SAVE ALSO IN HIGH POSITION\n         LA    R6,LN2HV-P002       SET FOR 2ND LINE NUMBER\n         LCR   R6,R6               MAKE REL ADDR NEGATIVE AS FLG\n         SCAN  LN1PRT              2ND LINE\n         B     CVABSENT            VOID NG\n         SPACE\nLN2HV    LR    R2,R0               SAVE LINE 2\n         C     R2,16(,R8)          FIRST OR SECOND LINE NO HIGH\n         BL    LLLL                BRANCH IF SECOND HIGH\n         BE    TOOHI               IF EQUAL, THEN DONE\n         ST    R2,16(,R8)          SET SECOND LINE NO\n         B     MMMM                CONTINUE\n         SPACE\nLLLL     ST    R2,0(,R8)           SET FIRST LINE NO\nMMMM     SR    R1,R1\n         ST    R1,CPWK2\n         LA    R1,1\n         ST    R1,CPWK1\n         SCAN  COLUMN\n         B     COUT\n         SPACE\nMMMM1    SCAN  COLT\n         B     CVABSENT\n         SPACE\nCOLTA    C     R15,=F'133'\n         BH    CVNVALID\n         ST    R15,CPWK1\n         SCAN  COLTE\n         B     COUT\n         SPACE\nCOLTF    C     R15,CPWK1\n         BL    BADRA\n         ST    R15,CPWK2\nCOUT     PCALL GOCOMP\n         SPACE 3\nBADRA    TSEG  'BAD COLUMN RANGE'\n         B     CVQTYPE\n         SPACE\nBAD      B     CVNVALID\n         SPACE\nTOOHI    TSEG  'COMPARE',,W\n         B     CVGETCOM            YES, GO GET NEXT COMMAND\n         SPACE 3\nLN1PRT   SCKW  ,,PUSH       FILLED IN TO LNENOPRT\nLN2PRT   SCKW  ,,PUSH       FILLED IN TO LTNPRT\n         SCKW  ,BAD\n         SPACE\nCOLUMN   SCKW  COLUMNS,MMMM1,A\n         SCKW  ,BAD\n         SPACE\nCOLT     SCKW  ,COLTA,PI,133\nCOLTE    SCKW  /,COLTF,(P,PI),133\n         SCKW  ,BAD\n         TITLE 'CLEAR ROUTINE -- PAGE 2'\nPCLEAR   GENTER SZR+4  ENTRY FOR CLEAR COMMAND\n         LA    R2,TEXTPRT          POINT TO NORMAL SCAN TABLE\nGOCLEAR1 SLR   R2,R10              CONVERT PRT ADDR\n         LCR   R2,R2               TO RELATIVE ADDR FOR SCAN\n         SCTELL (1),(0)            GET OPERANDS\n         MVC   4(SZR,R8),0(R1)     MOVE TO WORK AREA\n         LA    R1,4(,R8)           POINT TO NEW SCAN AREA\n         SCINIT (1),(0)            SET SCANNER TO NEW AREA\n         MVC   0(1,R8),CPGFLG2     SAVE CURRENT VALUE OF CPGFLG2\n         SCAN  (R2),NO             SCAN FOR OPERANDS\n         B     CVABSENT            OP MISSING IF NOTHING\n         SPACE\nGOCLEAR2 SCAN  (R2),NO             CONTINUE SCAN FOR OTHER OPS\n         B     CVGETCOM            GO GET NEXT COMMAND\n         SPACE\nGGCLEAR  CLC   CPAGCT(2),=D'0'     IS THERE AN ACTIVE FILE\n         BNE   GGCLEAR1            BR YES\n         TM    0(R8),CPFEXEC+CPFEXTER    EXEC & EXEC TERSE\n         BO    GOCLEAR2            YES, DON'T WRITE MESSAGE\n         TSEG  'NO ACTIVE FILE',,W\n         B     GOCLEAR2            GO GET NEXT OPERAND\n         SPACE\nGGCLEAR1 CVCALL DOCLEAR            GO CLEAR FILE\n         B     GOCLEAR2            NEXT OPERAND\n         SPACE\nGGCLREX  CLC   CPEXCNT(2),=D'0'    IS THERE AN EXEC FILE\n         BNE   GGCLREX1            BR YES\n         TSEG  'NO EXEC FILE',,W\n         B     GOCLEAR2            GO GET NEXT OPERAND\n         SPACE\nGGCLREX1 CVCALL DOCLRX             GO CLEAR FILE\n         NI    CPGFLG2,255-CPFEXEC RESET EXEC MODE IF ON\n         B     GOCLEAR2            NEXT OPERAND\n         SPACE\nGGCLRTAB XC    RTBTABS(8),RTBTABS  CLEAR TAB SETTINGS\n         B     GOCLEAR2            NEXT OPERAND\n         SPACE\nGGCLRNAM XC    CPPFXL,CPPFXL       CLEAR PREFIX\n         MVI   CPMEMBSV,C' '       CLEAR SAVED MEMBER\n         AIF   ('&USPS' NE '1').XLBL03                          USPS01\n         ST    R6,CVSPARES   SAVE FOR MIN                       USPS01\n         SR    R6,R6         ZERO IT                            USPS01\n         IC    R6,CVUSRFLD  PICK UP ID LENGTH                   USPS01\n         MVC   CPUSERSV(0),CPUSER  RESET ID                     USPS01\n         EX    R6,*-6        EXECUTE ABOVE INST                 USPS01\n         L     R6,CVSPARES   RELOAD R6                          USPS01\n         AGO   .XLBL04                                          USPS01\n.XLBL03   DS   0H                                               USPS01\n         MVC   CPUSERSV(5),CPUSER  RESET SAVED USER AND GROUP\n.XLBL04   DS   0H                                               USPS01\n         B     GOCLEAR2            NEXT OPERAND\n         SPACE\nGGCLRIGN TSEG  (1),(0)             BAD OPERAND -- IGNORE IT\n         TSEG  ': IGNORED',,W      WRITE OUT MESSAGE\n         B     GOCLEAR2            GO GET NEXT OPERAND\n         SPACE 3\nTEXTPRT  SCKW  TEXT,GGCLEAR,A\n         SCKW  ACTIVE,GGCLEAR,A\n         SCKW  EXECUTE,GGCLREX,A\n         SCKW  TABS,GGCLRTAB,A\n         SCKW  NAME,GGCLRNAM,A\n         SCKW  ,GGCLRIGN\n         TITLE 'END OF PAGE CODE -- PAGE 2'\n         PINIT                     DEFINE START OF INIT ROUTINE\n         MVC   LN1PRT+1(3),CVLNENO+1\n         MVC   LN2PRT+1(3),CVLTNPR+1\n         PEND                      DEFINE END OF INIT CODE\n         TITLE 'TSO COMMANDS - INTERFACE ROUTINE - PAGE3'\nP003     PAGECDE TSOCMDS\n         WIDENT  001\n         USING   CPAREA,R12\nPTSOCMDS GENTER BLDLSIZ\n         USING BLDLWORK,R8    WORK AREA\n         CH    R0,=H'8'        COMMAND TOO LONG\n         ST    R0,CPWK1        SAVE FOR ILLEGAL COMMAND\n         BH    CMDILL          YES.\n         LR    R2,R0            CMD LEN FOR EXECUTE\n         MVC   BLDLNAM,=CL8' ' CLEAR\n         BCTR  R2,R0            DECR\n         EX    R2,MOVCMD        MOVE COMMAND FOR ATTACH\n         L     R4,CPCTSAV      PICK UP LENGTH OF CMD BUFF\n         LA    R4,4(,R4)       UP TO REAL LENGTH\n         LA    R5,CPCMSAV      MIN CMD LEN=1+BLANK\n         LA    R5,1(,R5)\nCMDLOOP  DS    0H\n         CLI   0(R5),C' '       CMD+SPACE = OPERAND OFFSET\n         BE    OPERAND         FOUND OPERAND OFFSET\n         LA    R5,1(,R5)       BUMP TO NEXT POS.\n         B     CMDLOOP         LOOP\nOPERAND  DS    0H\n         LA    R6,CPCMSAV      PICK UP START OF CMD\n         SR    R5,R6           GET LENGTH\n         LA    R5,1(,R5)       CORRECT FOR SPACE\n         STH   R5,CPCTSAV+2     SAVE OPERAND OFFSET\n         STH   R4,CPCTSAV       SAVE CMD LEN FOR TSO\n         LA    R0,BLDLWORK        FOR BLDL\n         MVC   BLDLCNT,=X'0001' FF\n         MVC   BLDLLEN,=AL2(BLDLSIZ)   LL\n         SLR   R1,R1               ALSO\n         SVC   18                  BLDL\n         L     R0,CPWK1         FOR ILLEGAL IF NEC\n         LA    R1,BLDLNAM       ALSO\n         LTR   R15,R15             FOUND\n         BNZ   CMDILL              NO EXIT\n         TM    BLDLLIB,2        IS IT STEPLIB,JOBLIB ETC\n         BO    APFLIB           MUST BE APF LIB\n         L     R6,CVIOWA        WORK AREA ADDRESS\n         USING WDIOWA,R6\n         L     R2,WAUPT         USER PROFILE TABLE\n         ST    R2,CPSTART+4\n         L     R2,WAPSCB           PSCB\n         ST    R2,CPSTART+8\n         L     R2,WAECT\n         ST    R2,CPSTART+12       ECT\n         LA    R2,CPCTSAV          CMD BUFFER\n         ST    R2,CPSTART\n         LA    R1,CPSTART          PHONEY CPPL\n         LA    R14,BLDLNAM\n         XC    ATTDECB(4),ATTDECB  CLEAR THE ECB\n         LA    R2,ATTDECB          PICK UP ECB ADDR\n        ATTACH DE=(14),ECB=(2)\n         LR    R3,R1               SAVE TCB ADDR\n         WAIT  ECB=(2)             WAIT FOR COMPLETION\n         OC    CPCMSAV(25),CPCMSAV READY CMD AREA FOR NEXT\n         ST    R3,CPSTART          SETUP FOR DETACH\nDETACH   DETACH CPSTART            DETACH CP\n         CLI    BLDLNAM,C'Q'       IS IT QUEUE COMMAND\n         BNE    NODEL              NO BYPASS DELETE\n         DELETE EP=QCMN            DELETE QUEUE COMMON\nNODEL    DS     0H\n*TURN STAX BACK ON\n         LA    R3,WASTAX           STAX WORK AREA\n         XC    WASTAX(4*5),WASTAX  CLEAR STAX PARM LIST\n         L     R14,CVATNRTN\n         STAX  (14),REPLACE=YES,DEFER=NO,USADDR=((R12)),MF=(E,(R3))\n         OC    CPCMSAV(25),CPCMSAV READY CMD AREA FOR NEXT\n         B     CVGETCOM                 NEXT COMMAND\nMOVCMD   MVC   BLDLNAM(0),0(R1) EXECUTE ONLY\n*\nCMDILL   TSEG  (R1),(R0),B\n         B      CVUNLEGL           GET NEXT COMMAND\n*\nAPFLIB   TSEG 'COMMAND MUST BE IN LINKLST LIBRARY'\n         B     CVQTYPE\n*\n         DROP  R6\n         PINIT\n         PEND\nBLDLWORK DSECT\nBLDLCNT  DS    XL2\nBLDLLEN  DS    XL2\nBLDLNAM  DS    CL8\nBLDLENT  DS    CL62\nBLDLLIB  EQU   BLDLENT+4          TYPE OF BLDL LIB\nBLDLSIZ  EQU   *-BLDLWORK\n         CSECT\n.LBLX1   DS     0H\n         TITLE 'START OF PAGED CODE -- PAGE 20'\nP020     PAGECDE GOCTLG,NTGDCAT,NTGDOPN,NOMORPG\n         WIDENT 001\n         TITLE 'GOCTLG ROUTINE -- PAGE 20'\nPGOCTLG  DENTER DSSIZ\n         CVCALL DODSNM\n         TM    CPLFLG3,CPFSET      WAS SET SPECIFIED?\n         BZ    GOCTLG2             BR IF NOT\n         CVCALL SETPFXNS\nGOCTLG2  TM    CPLFLG3,CPFDSCLG    CATLG OR RECATLG?\n         BZ    GOUNC               BR IF NEITHER\n         LNR   R1,R8               INDICATE MANDATORY VOL PRMT\n         CVCALL VOLCHKNL           CHECK FOR VOLUME\nGOUNC    TM    DSNWAF1,DSNFMYDS    BELONG TO USER?\n         BO    CALLCAT\n         CVCALL NOTMYDS            GO SEE IF OK\nCALLCAT  DCATLG ,                  GO DO FUNCTION\n         LR    R2,R15              SAVE RETURN CODE\n         CVCALL DSNAMED\n         LTR   R15,R2              TEST RETURN CODE\n         BNZ   PNTGDCAT            BR IF ERROR\n         CVCALL CTLGED\n         TM    CPLFLG3,CPFDSCLG    CATLG OR RECATLG?\n         BZ    CVGETCOM              EXIT IF NOT\n         TSEG  'ON',,B\n         TSEG  DSNWAVOL,6\n         B     CVGETCOM\n         TITLE 'NTGDCAT ROUTINE -- PAGE 20'\nPNTGDCAT GENTER ,\n         CH    R15,=Y(C8)          WAS RC=8?\n         BE    CATRC8P             GO DO PRELIM CHECKING\n         CH    R15,=Y(255)         WAS RC=8 AND FUNNY CONDITION\n         BNH   CATRCNT8            BR NO\n         SYSQS 1,0,'CANN''T CATLG'\n         B     NTGDCATX            GO FINISH\n         SPACE\nCATRCNT8 TSEG  'NOT',,B\n         CVCALL CTLGED             GO PRINT FUNCTION NOT DONE\n         TSEG  '-',,B\n         B     *(R15)              TAKE PROPER BRANCH\n         B     CATRC4\n         B     CATRC8\n         B     NTGDCATX\n         B     CATRC16\n         B     CATRC20\n         B     CATRC24\n         B     CATRC28\n         SPACE\nCATRC4   SYSQS 1,0,'CVOL NOT AVAILABLE'\n         B     NTGDCATX\n         SPACE\nCATRC8   SYSQS 1,0,'NOT IN CATALOG'\n         B     NTGDCATX\n         SPACE\nCATRC16  SYSQS 1,0,'INDEX DOES NOT EXIST'\n         B     NTGDCATX\n         SPACE\nCATRC20  SYSQS 1,0,'NO SPACE ON CVOL'\n         B     NTGDCATX\n         SPACE\nCATRC24  SYSQS 1,0,'IMPROPER GDG NAME'\n         B     NTGDCATX\n         SPACE\nCATRC28  SYSQS 1,0,'I/O ERROR'\n         B     NTGDCATX\n         SPACE 3\n* IF RETURN CODE IS 8 ENTRY FOUND/NOT FOUND\nCATRC8P  DS    0H\n         TM    CPLFLG3,CPFDSCLG    WAS IT CATLG OR RECATLG?\n         BZ    CATRCNT8            BR IF UNCATLG\n         SYSQS 1,0,'ALREADY CATLG''D'\n         SPACE\nNTGDCATX TSEG  (1),(0)             PUT MESSAGE IN BUFFER\n         B     CVQTYPE\n         TITLE 'OPEN ERROR MESSAGE ROUTINE -- PAGE 20'\nPNTGDOPN GENTER ,\n         LR    R6,R15              SAVE ERROR CONDITION\n         LR    R5,R0               SAVE ANY PARM PASSED BACK\n         CH    R15,=Y(RTNCATER)    IS IT POSSIBLE CATASTRPHE?\n         BNL   CATER\n         CH    R15,=Y(TALOCODE)    TALO ON DOPEN?\n         BNL   THISEN(R15)         DON'T PRINT DSNAME\n         CVCALL DSNAMED            DSNAME INTO MESSAGE\nTHISEN   B     THISEN(R6)     BRANCH TO PROPER CONTINUATION\n         SPACE\n         B     NOSUCH         4\n         B     CVGETCOM       8 - HANDLED ELSEWHERE\n         B     NOROOM         12\n         B     BATCH          16\n         B     ILLBLKSZ       20\n         B     DSILLEG        24\n         B     ILLORG         28\n         B     CVGETCOM       32    TALO\n         B     ABORTMS        36    ABORT\n         B     BDVOLM         40\n         B     ILLMEMB        44\n         B     NODIRSPC       48\n         B     EXPDTPRO       52\n         B     OUTOFSP        56\n         B     DIRIOERR       60\n         B     ABORTMS        64      SHOULDN'T HAPPEN\n         B     PROTERR        68\n         SPACE 3\nILLORG   DS    0H\n         SYSQS 1,0,': ILLEGAL DSORG OR RECFM'\n         B     NTGDOPNX\n         SPACE\nDSILLEG  SYSQS 1,0,': ILLEGAL DSNAME'\n         B     NTGDOPNX\n         SPACE\nBDVOLM   DS    0H\n         TSEG  DSNWAVOL,6\n         SYSQS 1,0,': INVALID VOLUME'\n         B     NTGDOPNX\n         SPACE\nNOSUCH   TSEG  'NOT',,B\nVOLTOMSG TSEG  'ON',,B\n         TSEG  DSNWAVOL,6,B\n         CLI   DSNWAF2,DSNFSHOW+DSNFCAT  IS CMND SHOW CATLG?\n         BNE   CVQTYPE             BR IF NOT\n         BTD   CPDOUB,0,(R5)       GET LAST GOOD INDEX LEVEL\n         TSEG  (1),(0),B\n         SYSQS 1,0,'LEVELS OK'\n         B     NTGDOPNX\n         SPACE\nNOROOM   TSEG  'CAN''T FIND SPACE',,B\n         B     VOLTOMSG\n         SPACE\nCATER    TSEG  'ERROR #'\n         ST    R5,CPDOUB           SAVE FORMATTED ERROR NUMBER\n         TSEG  CPDOUB+1,3          AND WRITE IT\n         SYSQS 1,0,'. I/O INCOMPLETE'\n         B     NTGDOPNX\nBATCH    SYSQS 1,0,'IS IN USE'\n         B     ABORMS\n         SPACE\nPROTERR  CVCALL DSNAMED\n         SYSQS 1,0,'IS PROTECTED'\n         B     ABORMS\n         SPACE\nOUTOFSP  SYSQS 1,0,'ALLOWED DISK SPACE EXCEEDED'\n         B     ABORMS\n         SPACE\nEXPDTPRO CVCALL DSNAMED            PUT OUT DSNAME\n         SYSQS 1,0,'IS DATE PROTECTED'\n         SPACE\nABORMS   TSEG  (1),(0),M\nABORTMS  SYSQS 1,0,'REQUEST ABORTED'\n         B     NTGDOPNX\n         SPACE\nILLMEMB  TSEG  'MEMBER',,B\n         TM    DSNWAMBR,X'BF'      WAS MEMBER SPECIFIED?\n         BZ    ILLMEMB2            NO - THAT'S WHAT'S WRONG\n         CVCALL MEMBERED           GO TSEG MEMBER NAME\n         SYSQS 1,0,'NOT FOUND'\n         B     NTGDOPNX\n         SPACE\nILLMEMB2 SYSQS 1,0,'NOT SPECIFIED'\n         B     NTGDOPNX\n         SPACE\nILLBLKSZ TSEG  ':',,B\n         BTD   CPDOUB,0,(R5)       GET INVALID BLOCKSIZE\n         TSEG  (1),(0),B\n         SYSQS 1,0,'INVALID BLOCK SIZE'\n         SPACE\nNTGDOPNX TSEG  (1),(0)             PUT MESSAGE INTO BUFFER\n         B     CVQTYPE             GO GET NEXT COMMAND\n         SPACE\nNODIRSPC DS    0H\n         TSEG  'NO DIRECTORY SPACE IN',,B\nDIRDSN   CVCALL DSNAMED            PUT IN DSNAME\n         B     CVQTYPE             GO GET NEXT COMMAND\n         SPACE\nDIRIOERR TSEG  'DIRECTORY I/O ERROR IN',,B\n         B     DIRDSN              GO PUT IN DSNAME\n         TITLE 'PAGE SHORTAGE MESSAGES -- PAGE 20'\nPNOMORPG GENTER ,\n         TM    CPGFLG,CPFOPN  IS ANY EXTERNAL DATA SET NOT CLOSED?\n         BZ    READYZ         NO\n         DCLOSE ,             CLOSE IT\n         NI    CPGFLG,255-CPFOPN SET CLOSED\nREADYZ   XC    RTBWC(4),RTBWC\n         TSEG  'WYLBUR OUT OF PAGES -- COMMAND ABORTED'\n         B     CVQTYPE                  GET NEW COMMAND\n         TITLE 'END OF PAGED CODE -- PAGE 20'\n         PINIT             DEFINE END OF CODE - START OF INIT\n         PEND                      END OF PAGE\n         TITLE 'START OF PAGED CODE -- PAGE 21'\nP021     PAGECDE GOSHO,GOPUT\n         WIDENT 001\n         TITLE 'GOSHOW ROUTINE -- PAGE 21'\n* GOSHOW IS THE PRIMARY ENTRY FOR SHOW.\n         SPACE\nPGOSHO   GENTER C8\n         SCANSAVE 0(R8)            SAVE SCAN POINTERS FOR LATER\n         MVI   CPLFLG3,X'00'\n         SCAN  STPRTA                   SCAN FOR OPTIONS\n         B     CVABSENT                 ILLEGAL COMMAND\n         SPACE 3\n* MIGHT BE SHOW LINENO -- SET UP FOR THAT\n         SPACE\nGOSHOW1  SCANRSTR 0(R8)            RESTORE SCAN POINTERS\n         CVCALL SCNEXFR            SEE IF SELECT EXECUTE\n         LA    R6,SHOLNENO-P021    SET R6 FOR LINE NO.\n         LCR   R6,R6                  WITH NEG RELATIVE ADDR\n         SCAN  STPRTB              SCAN FOR LINE NUMBER\n         B     CVABSENT            NOTHING -- SHOULDN'T HAPPEN\n         SPACE\nSHOLNENO SYSQS 6,5,'LINE NUMBER'   SET FOR NORMAL LINE NUMBER\n         CH    R15,=Y(24)          VALUE TOO LARGE FOR BR TABLE\n         BH    CONVTRR             YES, SHOW AS LINE NUMBER\n         LTR   R15,R15             POSITIVE VALUE RETURNED\n         BNH   CONVTRR             NO, SHOW AS LINE NUMBER\n         B     *(R15)              GO TO PROPER ROUTINE\n         SPACE\n         B     FIRST               FIRST SPECIFIED\n         B     CURRENT             CURRENT SPECIFIED\n         B     LAST                LAST SPECIFIED\n         B     END                 END SPECIFIED\n         B     NEXT                NEXT SPECIFIED\n         B     PREVIOUS            PREVIOUS SPECIFIED\n         SPACE 3\nCURRENT  SYSQS 6,5,'CURRENT'       POINT TO TEXT\n         B     CONVTRR             GO OUTPUT IT\n         SPACE\nLAST     SYSQS 6,5,'LAST'          SET OPTION\n         B     CONVTRR             FINISH\n         SPACE\nFIRST    SYSQS 6,5,'FIRST'         SET FOR FIRST MESSAGE\n         B     CONVTRR             GO OUTPUT NOW\n         SPACE\nEND      SYSQS 6,5,'END'           SET FOR END MESSAGE\n         B     CONVTRR             GO OUTPUT NOW\n         SPACE\nNEXT     SYSQS 6,5,'NEXT'          SET FOR NEXT MESSAGE\n         B     CONVTRR             GO OUTPUT NOW\n         SPACE\nPREVIOUS SYSQS 6,5,'PREVIOUS'      SET FOR PREVIOUS MESSAGE\n         B     CONVTRR             GO FINISH\n         SPACE\nDELTA    SYSQS 6,5,'DELTA'         SET OPTION\n         L     R0,CPGLDL           DELTA INTO R0\nCONVTRR  CVCALL CVEXNO             CONVERT\n         B     OUTPUTR             OUTPUT\n         SPACE\nSIZEA    SYSQS 6,5,'PAGES'         SET OPTION\n         LH    R15,CPAGCT          LOAD PAGE COUNT\n         B     LNGTHB              CONTINUE\n         SPACE\nLNGTHA   SYSQS 6,5,'LENGTH'        SET OPTION\n         LH    R15,CPLNGTH         LEN INTO R15\nLNGTHB   SR    R0,R0               ZERO\n         BTD   CPDOUB,(0),(15)     CONV TO INTEGER\nOUTPUTR  TSEG  (1),(0),B           INTO MSG\nSSSNPT   TSEG  '-',,B\nSSSOPT   TSEG  (6),(5)             OPTION INTO MESSAGE\n         B     CVGETCOM\n         SPACE 3\nSHLOG    TM    CPGFLG2,CPFNOLOG    TEST IF NOLOG ON\n         BNO   SHLOG2              NO\n         TSEG  'NO'\nSHLOG2   SYSQS 1,0,'LOG'           PUT LOG IN MESSAGE\nINEFFECT TSEG  (1),(0),B\n         TSEG  'IS IN EFFECT'      WRITE REST OF MESSAGE\n         B     CVGETCOM\n         SPACE 3\nSHCOLL   TM    RTBUFL,RTBUNCOL     NO COLLECT?\n         BNO   SHCOLL2\n         TSEG  'NO'\nSHCOLL2  SYSQS 1,0,'COLLECT'\n         B     INEFFECT\n         SPACE 3\nSHWRAP   TM    RTBMFL,RTBWRAP      IS IT WRAP\n         BO    SHWRAP2\n         TSEG  'NO'\nSHWRAP2  SYSQS 1,0,'WRAP'\n         B     INEFFECT\n         SPACE 3\nSHPAD    TM    RTBUFL,RTBUPAD\n         BO    SHPAD2\n         TSEG  'NO'\nSHPAD2   SYSQS 1,0,'PAD'\n         B     INEFFECT\n         SPACE 3\nSHCRT    TM    RTBMFL,RTBCRT\n         BO    SHCRT2\n         TSEG  'NO'\nSHCRT2   SYSQS 1,0,'CRT'\n         B     INEFFECT\n         SPACE 3\nSHOBACK  TM    RTBUFL,RTBUBACK\n         BO    SHOBACK2\n         TSEG  'NO'\nSHOBACK2 SYSQS 1,0,'BACK'\n         B     INEFFECT\n         SPACE 3\nSHPSZ    LA    R15,RTBPSZ\n         SYSQS 6,5,'PAGESIZE'\n         B     SHLPSZ\n         SPACE 3\nSHLSZ    LA    R15,RTBLSZ\n         SYSQS 6,5,'LINESIZE'\nSHLPSZ   L     R14,RTBWAPTR\n         LH    R15,0(R15,R14)\n         B     LNGTHB\n         SPACE 3\nSHATTN   SYSQS 6,5,'ATTN SEQUENCE'\n         TM    RTBUFL,RTBUATTN\n         BNO   VOLNONE\n         L     R14,RTBWAPTR\n         LA    R1,RTBATTN(,R14)\n         LH    R0,RTBATNSZ(,R14)\n         B     OUTPUTR\n         SPACE 3\nVOLSHOW  SYSQS 6,5,'VOLUME'\n         TM    CPGFLG,CPFVOLM      DEFAULT?\n         BZ    VOLNONE             NO\n         TSEG  CPVOLSV,6,B         SET DEFAULT VOL\n         B     SSSNPT              PUT OPTION INTO MSG\n         SPACE\nVOLNONE  TSEG  'NO',,B             NONE\n         B     SSSOPT              PUT OPTION INTO MSG\n         SPACE 3\nSHOESCAP SYSQS 6,5,'ESCAPE CHAR'   SET OPTION\n         LA    R1,CPESCAPE         GET ESCAPE CHAR\n         TM    CPGFLG2,CPESNULL    IS IT NULL\nSHESCSK  BO    VOLNONE             BRANCH YES\n         LA    R0,1                SET LENGTH\n         B     OUTPUTR             GO FINISH\n         SPACE\nSHOSKIP  SYSQS 6,5,'SKIP CHAR'     SET OPTION\n         LA    R1,CPSKIP           GET SKIP CHAR\n         TM    CPGFLG2,CPSKNULL    IS IT NULL\n         B     SHESCSK             BRANCH YES\n         SPACE\nSHORSCN  LH    R15,CPRSCNVL        GET RESCAN VALUE\n         SYSQS 6,5,'RESCAN COUNT'  SET OPTION\n         B     LNGTHB              GO FINISH\n         SPACE 3\nCCASE    TM    CPGFLG,CPFUPLW      TEST IF UPPER-LOWER BIT ON\n         BO    ISUPLOW             YES\n         TSEG  'UPPER CASE ONLY'\n         B     CVGETCOM            GET NEW COMMAND\n         SPACE\nTSKTSK   B     CVNVALID\n         SPACE\nISUPLOW  TSEG  'UPPER-LOWER CASE'\n         B     CVGETCOM            GET NEW COMMAND\n         EJECT\n* CALL VARIOUS SHOW COMMANDS IMPLEMENTED IN OTHER PAGES\n* NAME, PREFIX, MEMBER, DSNAME, USER, GROUP\n         SPACE\nSHNAM    PCALL SHONAM\n         SPACE\nTABSA    PCALL GOTAB               GO DO TABS\n         SPACE\nCOLUMNS  PCALL SHOCOL              CALL SHOW COLUMNS ROUTINE\n         SPACE\nSHDSNSPA PCALL SHODSN\n         SPACE\nSHSPACES PCALL SHOSPAC\n         SPACE\nSHDIRCAT PCALL SHOCAT\n         SPACE\nSHVOLS   PCALL SHOVOLS\n         SPACE\nFINDSIZE PCALL SHOSIZ\n         SPACE\nINFO     PCALL TIME\n         SPACE\nPROFIL   PCALL PROFIL\n         SPACE\nLISTUSR  PCALL LSTUSR\n         SPACE\n         EJECT\n* SCAN ROUTINES FOR SHOW\n         SPACE\nSTPRTA   SCKW  DELTA,DELTA,A\n         SCKW  LENGTH,LNGTHA,A\n         SCKW  CASE,CCASE,A\n         SCKW  VOLUME,VOLSHOW,A\n         SCKW  NAME,SHNAM,(A,S)\n         SCKW  GROUP,SHNAM,(A,S)\n         SCKW  USERS,LISTUSR\n         SCKW  USER,SHNAM,(A,S)\n         SCKW  MEMBER,SHNAM,(A,S)\n         SCKW  LOG,SHLOG\n         SCKW  SIZE,FINDSIZE,A\n         SCKW  PAGES,SIZEA,A\nSTPRTA1  SCKW  EXECUTE,,A      FILLED IN AT INIT TO SHEXEC\n         SCKW  VOLUMES,SHVOLS\n         SCKW  VOLS,SHVOLS\n         SCKW  TIME,INFO,(A,S)\n         SCKW  DATE,INFO,(A,S)\n         SCKW  PROFILE,PROFIL,A\n         SCKW  TABS,TABSA,A\n         SCKW  COLUMNS,COLUMNS,A\n         SCKW  COLS,COLUMNS\n         SCKW  PAGESIZE,SHPSZ,A\n         SCKW  PS,SHPSZ,A\n         SCKW  LINESIZE,SHLSZ,A\n         SCKW  LS,SHLSZ\n         SCKW  ATTN,SHATTN\n         SCKW  COLLECT,SHCOLL,A\n         SCKW  WRAP,SHWRAP\n         SCKW  PAD,SHPAD\n         SCKW  CRT,SHCRT\nSTPRTA2  SCKW  VALUE,,A        FILLED IN AT INIT TO SHOVAR\n         SCKW  ESCAPE,SHOESCAP,A\n         SCKW  SKIP,SHOSKIP,A\n         SCKW  RESCAN,SHORSCN,A\n         SCKW  BACK,SHOBACK,A\n         SCKW  ,GOSHOW1        END FIRST SHOW TABLE\n         SPACE\nSTPRTB   SCKW  ,,PUSH          FILLED IN AT INIT TO LNENOPRT\n         SCKW  PREFIX,SHNAM,(A,S)\nPUTSCKW  SCKW  DSNAMES,SHDSNSPA,(A,S)\n         SCKW  DIRECTORY,SHDIRCAT,(A,S)\n         SCKW  CATLG,SHDIRCAT,(A,S)\n         SCKW  CATALOG,SHDIRCAT,(A,S)\n         SCKW  SPACE,SHSPACES,(A,S)\n         SCKW  TRACKS,SHSPACES,(A,S)\n         SCKW  ,TSKTSK\n         TITLE 'GOPUT ROUTINE -- PAGE 21'\n* GOPUT IS THE PRIMARY ENTRY FOR PUT.\n         SPACE\nPGOPUT   GENTER C8\n         MVI   CPLFLG3,CPFPUT\n         SCAN  PUTSCKW\n         B     CVABSENT\n         TITLE 'END OF PAGED CODE -- PAGE 21'\n         PINIT             DEFINE END OF CODE - START OF INIT\n         MVC   STPRTA1+1(3),CVSHEXE+1  SET TO SHEXEC\n         MVC   STPRTA2+1(3),CVSHOVA+1  SET TO SHOVAR\n         MVC   STPRTB+1(3),CVLNENO+1   SET TO LNENOPRT\n         PEND                      END OF PAGE\n         TITLE 'START OF PAGED CODE -- PAGE 22'\nP022     PAGECDE SHOSIZ\n         WIDENT 001\n         TITLE 'SHOW ROUTINES -- PAGE 22'\n* SHO SIZE: LIST # OF CHARACTERS IN EACH LINE OF A RANGE\n         SPACE\nPSHOSIZ  GENTER ,\n         OI    CPLFLG1,CPFALL      DEFAULT RANGE IS 'ALL'\n*                                  DEFAULT OPTION IS 'COUNT'\n         CVCALL DETRNG             FIND RANGE IF SPECIFIED\n         XC    CPOVSIZE(8),CPOVSIZE  INITIALIZE\nNEXTOKEN SCAN  SHOSIZOP            SCAN FOR A SPECIFIED OPTION\n         TM    CPLFLG2,CPFOV+CPFUN WAS OVER AND UNDER GIVEN\n         BNO   AWAYWEGO            NO, NO CHECK NEEDED\n         L     R6,CPUNSIZE         GET UNDER SIZE\n         BCTR  R6,0                SUBTRACT 1\n         C     R6,CPOVSIZE         NOW MUST STILL BE > OVSIZE\n         BH    AWAYWEGO            BR IF VALUES OK\n         SYSQS 1,0,'CAN''T HAVE LINES OVER' SET FIRST PART\n         B     OV1                 GO FINISH MESSAGE\n         SPACE\nAWAYWEGO L     R15,VDOSHOSZ        COME HERE IF NO TOKEN FOUND\n         MVI   CPCURRL,X'F0'       SET CURRENT LINE INVALID\n         OI    CPLFLG5,CPFNCUR     QUASH CURRENT LINE PNTR UPDAT\n         CVCALL DESPOT             GIVE DESPOT FLAGS AND GO THERE\n         TM    CPSTAD,CPFSOME      VOID RANGE?\n         BZ    NCOMMAND            YES-AVOID FURTHER MESSAGE\n         TM    CPLFLG2,CPFFIRST    HAS DO RTN WRITTEN A LINE?\n         BO    NCOMMAND            YES AVOID FURTHER MESSAGE\n         TM    CPLFLG2,CPFEQ       WAS IT EQUAL?\n         BZ    NOEQ                BR NO\n         SYSQS 1,0,'NO LINES EQUAL' SET PART OF MESSAGE\n         B     NOUN1               GO FINISH MESSAGE\n         SPACE\nNOEQ     TM    CPLFLG2,CPFOV       WAS IT FOR OVER?\n         BZ    NOUN                GO TO PUT OUT FOR UNDER\n         SYSQS 1,0,'NO LINES OVER' SET PART OF MESSAGE\nOV1      TSEG  (1),(0),B           PUT OUT FIRST PART OF MESSAGE\n         L     R6,CPOVSIZE         GET OVER SIZE\n         BTD   CPDOUB,3,(6)        CONVERT IT TO BCD\n         TSEG  (1),(0)             FINISH UP \"NULL\" MESSAGE\n         TM    CPLFLG2,CPFUN       WAS IT ALSO UNDER?\n         BZ    WPM                 NO. GO WRITE.\n         SYSQS 1,0,' UNDER'        MSG NEEDS OVER AND UNDER\n         B     NOUN1               SKIP AROUND NEXR LINE\n         SPACE\nNOUN     SYSQS 1,0,'NO LINES UNDER' SET FOR UNDER\nNOUN1    TSEG  (1),(0),B           PUT OUT PART OF MESSAGE\n         L     R6,CPUNSIZE         GET UNDER SIZE\n         BTD   CPDOUB,3,(6)        CONVERT IT TO BCD\n         TSEG  (1),(0)             FINISH UP \"NULL\" MESSAGE\nWPM      TWRITE                    TELL THE USER ABOUT IT\nNCOMMAND B     CVGETCOM            GO GET THE NEXT COMMAND\n         SPACE\nGOINVAL1 B     CVNVALID                   GO SAY INVALID\n         SPACE 3\n         DS    0F                  ALIGNMENT\nVDOSHOSZ DC    AL1(UNPRST+DESMATCH+DESRTRN+DESRELA)\n         DC    AL3(DOSHOSZ-P022)  ADDR OF WORK ROUTINE\n         EJECT\n*        FOLLOWING CODE ENTERED FROM SCAN OF TABLE SHOSIZOP\n*\n*                                  **OPTION FOUND**  **ACTION**\nHAVNOCNT OI    CPLFLG2,CPFCOUNT    'NOCOUNT'         FLAG IT\n         BR    R14                 RETURN TO SAME SCAN LEVEL\n         SPACE\nHAVEOVER SCAN  SHOSIZOV            'OVER'            START SCAN\n         B     CVABSENT            IF NO PARAMETER--ERROR\n         SPACE\nHAVUNDER SCAN  SHOSIZUN\n         B     CVABSENT            IF NO PARM---ERROR\n         SPACE\nHAVEQUAL SCAN  SHOSIZEQ            SCAN FOR EQUAL VALUE\n         B     CVABSENT            ERROR IF NOTHING\n         SPACE 3\n*        FOLLOWING CODE ENTERED FROM SCAN OF TABLE SHOSIZOV\n*\n*                                  **OPTION FOUND**  **ACTION**\nGOTLENGT LH    R15,CPLNGTH         'OVER LENGTH'     GET CUR LNG\nGOTNUMBR ST    R15,CPOVSIZE        'OVER NUMBER'     SAVE IT\n         TM    CPLFLG2,CPFOV+CPFEQ DOES THIS OPTION CONFLICT\n         BNZ   CVNVALID            YES, MAKE IT INVALID\n         OI    CPLFLG2,CPFOV       SET OVER FLAG\n         B     NEXTOKEN            RETURN TO NEXT HIGHER SCAN\n         SPACE\nGOTLENUN LH    R15,CPLNGTH         'UNDER LENGTH'\nGOTNUMU  ST    R15,CPUNSIZE        'UNDER NUMBER'\n         TM    CPLFLG2,CPFUN+CPFEQ DOES THIS OPTION CONFLICT\n         BNZ   CVNVALID            YES, MAKE IT INVALID\n         OI    CPLFLG2,CPFUN       SET UNDER FLAG\n         B     NEXTOKEN\n         SPACE\nGOTLENEQ LH    R15,CPLNGTH         'EQUAL LENGTH'\nGOTNUMEQ ST    R15,CPUNSIZE        USE UNDER AREA FOR EQUAL VAL\n         TM    CPLFLG2,CPFUN+CPFOV+CPFEQ  DOES THIS OPTION CONFL\n         BNZ   CVNVALID            YES, MAKE IT INVALID\n         OI    CPLFLG2,CPFEQ       SET EQUAL FLAG\n         B     NEXTOKEN\n         EJECT\n* SHOW SIZE DO ROUTINE ENTRY CONDITIONS:\n* R1=POINTER TO TEXT  R0=TEXT COUNT CPLCN0=LINE # INTRNL FMT\n         SPACE\nDOSHOSZ  XENTER 6,8,*              SMOKEY THE BEAR SAYS-THE REGS\n         LR    R6,R0               YOU SAVE MAY BE YOUR OWN\n         TM    CPLFLG2,CPFOV+CPFUN+CPFEQ IS IT SHO SIZ ALL?\n         BZ    PUTOUT              YES. BRANCH TO PUT OUT\n         C     R0,CPOVSIZE         OVER ?\n         BNH   SEEUNDER            NO. BRANCH\n         OI    CPOVSIZE,CPFOV      MARK OVER\nSEEUNDER C     R0,CPUNSIZE         IS IT UNDER?\n         BNL   SEEEQUAL            NO. BRANCH.\n         OI    CPOVSIZE,CPFUN      MARK UNDER\n         B     WELLWELL            GO SEE IF CONDITIONS HOLD\n         SPACE\nSEEEQUAL BNE   WELLWELL            NOT EQUAL - BRANCH\n         OI    CPOVSIZE,CPFEQ      MARK EQUAL\nWELLWELL NC    CPOVSIZE(1),CPLFLG2 DO CONDITIONS HOLD?\n         XC    CPOVSIZE(1),CPLFLG2\n         TM    CPOVSIZE,CPFOV+CPFUN+CPFEQ\n         BNZ   NOTQUITE            NO. BRANCH OUT.\nPUTOUT   L     R0,CPLCNO           LINE # TO ARG REG FOR CVEXNO\n         ST    R0,CPCURRL          UPDATE CURRENT LINE POINTER\n         CVCALL CVEXNO             CONVERT IT TO EXTRNL FORMAT\n         TSEG  (1),(0),B           BUFFER IT\n         TM    CPLFLG2,CPFCOUNT    DO WE HAVE TO SHO THE COUNT??\n         BO    WRITE               IF NOT GO WRITE THE LINE\n         TSEG  '-',,B              MAKE FANCY LINE\n         BTD   CPDOUB,3,(6)        CNVRT BINARY TEXT COUNT TO BCD\n         TSEG  (1),(0),B           BUFFER IT\n         TM    CPLFLG2,CPFFIRST    MUST WE PUT OUT THE DOODADS??\n         BO    WRITE               IF NOT SKIP THE DODAD\n         TSEG  'CHARACTERS'        ELSE PUT IT IN..SIGH\nWRITE    OI    CPLFLG2,CPFFIRST    SET 'NOT FIRST CALL' FLAG ON\n         TWRITE ,\n         BP    CVQTYPE             BREAK PROCESSING IF ATTENTION\nNOTQUITE XC    CPOVSIZE(1),CPOVSIZE CLEAR HI BITS\n         XEXIT 6,8\n         EJECT\n* SCAN TABLE FOR SHOW SIZE\n         SPACE\nSHOSIZOP SCKW  OVER,HAVEOVER,A\n         SCKW  UNDER,HAVUNDER,A\n         SCKW  EQUAL,HAVEQUAL,A\n         SCKW  COUNT,NEXTOKEN,A\n         SCKW  NOCOUNT,HAVNOCNT,A\n         SCKW  ,GOINVAL1\n         SPACE 3\n* SCAN TABLE FOR SHOW SIZE OVER\n         SPACE\nSHOSIZOV SCKW  ,GOTNUMBR,I,133\n         SCKW  LENGTH,GOTLENGT,A\n         SCKW  ,GOINVAL1\n         SPACE 3\n* SCAN TABLE FOR SHOW SIZE EQUAL\n         SPACE\nSHOSIZUN SCKW  ,GOTNUMU,PI,133\n         SCKW  LENGTH,GOTLENUN,A\n         SCKW  ,GOINVAL1\n         SPACE 3\n* SCAN TABLE FOR SHOW SIZE EQUAL\n         SPACE\nSHOSIZEQ SCKW  ,GOTNUMEQ,I,133\n         SCKW  LENGTH,GOTLENEQ,A\n         SCKW  ,GOINVAL1\n         TITLE 'END OF PAGED CODE -- PAGE 22'\n         PINIT         DEFINE END OF CODE START OF INIT\n         PEND                      END OF PAGE\n         TITLE 'START OF PAGED CODE -- PAGE 25'\nP025     PAGECDE SHONAM,SHOVOLS,DECIDE\n         WIDENT 2067 12:12:03 03/07/72\n         TITLE 'SHOW VOLUMES ROUTINE -- PAGE 25'\n* SHOW VOLUMES ROUTINE\n*\n* LIST VOLUMES VALID IN CURRENT SESSION\n*        USE & SAVE VOLUMES ARE LISTED FIRST\n*        TEMPORARY VOLUMES ARE LISTED NEXT\n*        USE ONLY VOLUMES ARE LISTED LAST\n         SPACE\nPSHOVOLS GENTER ,\n         TSEG  'USE && SAVE --',,B\n         LA    R5,CVSTYPE       POINT TO USE&SAVE TIOT IDENT\n         LA    R4,10                   SET MAXIMUM FOR A LINE\n         BAL   R6,SHVROUT              GO PUT OUT VOLUMES\n         TSEG  'TEMPORARY  --',,B\n         LA    R5,CVTTYPE              POINT TO TEMP TIOT IDENT\n         LA    R4,10                   SET MAXIMUM FOR A LINE\n         BAL   R6,SHVROUT              GO PUT OUT VOLUMES\n         TSEG  'USE ONLY   --',,B\n         LA    R5,CVUTYPE              POINT TO USE TIOT IDENT\n         LA    R4,10                   SET MAXIMUM FOR A LINE\n         BAL   R6,SHVROUT              GO PUT OUT VOLUMES\n         B     CVGETCOM                GO GET NEXT COMMAND\n         SPACE 3\nSHVROUT  SLR   R6,R10              MAKE RETURN RELATIVE\n         SR    R2,R2                   ZERO REGISTER FOR IC\n         L     R3,CVTIOT               POINT TO TIOT VOL LIST\nSHVROUTL CLC   0(2,R5),4(R3)           DOES VOL IDENT MATCH\n         BNE   SHVROUT1               NO, GET NEXT ENTRY\n         TM    3(R3),X'10'            IS IT DYNAM?\n         BNO   SHVROUT2               NO IT'S OK.\nSHVROUT1 IC    R2,0(,R3)               GET COUNT\n         AR    R3,R2                   POINT TO NEXT ENTRY\n         CLI   0(R3),0                 DONE\n         BNE   SHVROUTL                NO, GO DO THIS ENTRY\n         TWRITE ,                      WRITE OUT BUFFER\n         B     0(R6,R10)               RETURN\n         SPACE\nSHVROUT2 BCT   R4,SHVROUT3             BRANCH BUFFER NOT FULL\n         LA    R4,9                    RESET BUFFER COUNT\n         TWRITE ,                      WRITE OUT BUFFER\n         BP    0(R6,R10)               RETURN IF ATTN\n         TSEG  '             ',,B      INITIALIZE NEW BUFFER\nSHVROUT3 L     R1,16(,R3)          GET UCB POINTER\n         TM    18(R1),X'20'        DIRECT ACCESS?\n         BNO   SHVROUT1            IF NOT DONT DISPLAY.\n         TSEG  28(,R1),6,B             PUT VOL IN BUFFER WITH BLK\n         B     SHVROUT1                GO GET NEXT ENTRY\n         TITLE 'SHO NAM/PREF/MEM/GRO/USE -- PAGE 25'\n* ENTER HERE FOR SHOW  NAME, PREFIX, MEMBER, GROUP, AND USER\n*     DETERMINE WHICH OPTION WAS SPECIFIED AND GO DO IT\nPSHONAM  GENTER ,\n         CLC   CPCMNM,=C'NAM'  IS IT NAME\n         BE    SHONAM              YES GO SHOW NAME\n         CLC   CPCMNM,=C'PRE'      IS IT PREFIX\n         BE    SHPFX               YES, GO SHOW PREFIX\n         CLC   CPCMNM,=C'MEM'      IS IT MEMBER\n         BE    SHMBR               YES, GO SHOW MEMBER\n         CLC   CPCMNM,=C'USE'      IS IT USER\n         BE    SHUSER              YES, GO SHOW USER\n         AIF   ('&USPS' EQ '1').XLBL05                          USPS01\n         CLC   CPCMNM(2),=C'GR'    IS IT GROUP\n         BE    SHGRP               YES, GO SHOW GROUP\n.XLBL05   DS   0H                                               USPS01\nGOINVAL  B     CVNVALID                   GO SAY INVALID\n         EJECT\n*  SHOW PREFIX\n         SPACE\nSHONAM   OI    CPLFLG3,CPFSET      INDICATE SHOW NAME\n         AIF   ('&USPS' EQ '1').XLBL06                          USPS01\n         BAL   R2,SHGRP2           GO SHOW GROUP CODE\n         TSEG  ':',,B\n         BAL   R2,SHUSER2          GO SHOW USER CODE\n         TSEG  ':',,B\n.XLBL06   DS   0H                                               USPS01\nSHPFX    LH    R0,CPPFXL               TEST FOR PREFIX\n         LTR   R0,R0\n         BNP   NULLPFX                 BR IF NONE\n         TM    CPGFLG,CPFCMOFF     TEST TERSE\n         BO    SHPFX1              BR IF YES\n         TSEG  'PREFIX -',,B\nSHPFX1   LH    R0,CPPFXL           PREFIX LENGTH\n         TSEG  CPPFX,(0),B\nSHPFX2   DS    0H\n         TM    CPLFLG3,CPFSET      SHOW PREFIX OR NAMES?\n         BZ    CVGETCOM            BR IF SHOW PREFIX\n         TSEG  ':',,B\n         BAL   R2,SHMBR2           GO SHOW MEMBER\nSHGETCOM B     CVGETCOM\n         SPACE\nNULLPFX  TSEG  'NO PREFIX',,B\n         B     SHPFX2\n         SPACE 3\n         AIF   ('&USPS' EQ '1').XLBL07                          USPS01\n* SHOW GROUP\n         SPACE\nSHGRP    LA    R2,SHGETCOM\nSHGRP2   SLR   R2,R10              MAKE RETURN RELATIVE\n         TM    CPGFLG,CPFCMOFF     TEST TERSE\n         BO    SHGRP3              BR IF YES\n         TSEG  'GROUP -',,B\n         B     SHGRP4\n         SPACE\nSHGRP3   TSEG  '@'\nSHGRP4   TSEG  CPGRPSV,L'CPGRPSV,B\n         B     0(R2,R10)\n         SPACE 3\n.XLBL07   DS   0H                                               USPS01\n* SHOW USER\n         SPACE\nSHUSER   LA    R2,SHGETCOM\nSHUSER2  SLR   R2,R10              MAKE RETURN RELATIVE\n         TM    CPGFLG,CPFCMOFF     TEST TERSE\n         BO    SHUSER3              BR IF YES\n         TSEG  'USER -',,B\n         B     SHUSER4\n         SPACE\nSHUSER3  TSEG  '&&'\n         AIF   ('&DCEC' NE '1').LBL04                           JEP00X\nSHUSER4  ST    R0,CVSPARES         SAVE R0 PAST TSEG            JEP001\n         SR    R0,R0               ZERO IT                      JEP001\n         IC    R0,CVUSRFLD         PICK UP USERID LENGTH        JEP001\n         TSEG  CPUSERSV,(0),BLANK                               JEP001\n         L     R0,CVSPARES         RESTORE R0                   JEP001\n         AGO   .LBL05                                           JEP00X\n.LBL04   DS    0H                                               JEP00X\nSHUSER4  TSEG  CPUSERSV,L'CPUSERSV,B\n.LBL05   DS    0H                                               JEP00X\n         B     0(R2,R10)\n         SPACE 3\n* SHOW MEMBER\n         SPACE\nSHMBR    LA    R2,SHGETCOM\nSHMBR2   SLR   R2,R10              MAKE RETURN RELATIVE\n         CLI   CPMEMBSV,X'40'      IS THERE A SAVED MEMBER?\n         BE    NULLMBR             BR IF NO\n         TM    CPGFLG,CPFCMOFF     TEST TERSE\n         BO    SHMBR3              BR IF YES\n         TSEG  'MEMBER -',,B\n         B     SHMBR4\n         SPACE\nSHMBR3   TSEG  '#'\nSHMBR4   TSEG  CPMEMBSV,L'CPMEMBSV\n         B     0(R2,R10)\n         SPACE\nNULLMBR  TSEG  'NO MEMBER'\n         B     0(R2,R10)\n         TITLE 'DECIDE ROUTINE -- PAGE 25'\nPDECIDE  GENTER ,\n         TIME  BIN                      GET TIME\n         LA    R1,7\n         NR    R1,R0                    LEAVE LAST 3 BITS\n         MH    R1,=H'12'                INDEX INTO FOLLOWING\n         B     *+4(R1)                  GO TO A MESSAGE\n         SYSQS 1,0,'MAYBE'\n         B     TSEGIT\n         SYSQS 1,0,'NO'\n         B     TSEGIT\n         SYSQS 1,0,'WHY NOT?'\n         B     TSEGIT\n         SYSQS 1,0,'YES'\n         B     TSEGIT\n         SYSQS 1,0,'OF COURSE'\n         B     TSEGIT\n         SYSQS 1,0,'NEVER'\n         B     TSEGIT\n         SYSQS 1,0,'OK'\n         B     TSEGIT\n         SYSQS 1,0,'BEATS ME'\nTSEGIT   TSEG  (1),(0)\n         B     CVGETCOM\n         TITLE 'END OF PAGED CODE -- PAGE 25'\n         PINIT         DEFINE END OF CODE START OF INIT\n         PEND                      END OF PAGE\n         TITLE 'START OF PAGED CODE -- PAGE 23'\nP023     PAGECDE SHODSN\n         WIDENT 001\n         TITLE 'SHOW DSNAMES AND SHOW SPACE -- PAGE 23'\nPSHODSN  GENTER  ,\n         XC    CPWK6(4),CPWK6\n         CLC   CPCMNM,=C'DSN'      IS IT SHOW DSN\n         BE    SHDSNMS             BR YES, ELSE SPACE\n         SPACE 3\n* SHOW SPACE ROUTINE\n         SPACE\nSHSPACE  SCANSAVE CPWK1\n         BAL   R14,DSNMDO      GO GET AND INIT DSNAME WORK AREA\n         MVC   CPCMNM(3),=C'DSN'   MAKE IT LOOK LIKE SHOW DSN\n         B     DSNRESCN            NOW GO DO SHOW DSNAMES\n         EJECT\n* SHOW DSNAMES ROUTINE\n*\n*\n* DSNAME WORK AREA DESCRIBED BY DSNWA ENTRY\n*\n* 12 BYTES OBTAINED AFTER DSNAME WORK AREA USED AS FOLLOWS:\n*   BYTES 1-4 CONTAINS ADDR OF RESCAN ROUTINE.\n*   BYTES 5-10 USED TO SAVE VOL WHEN MULT CALLS OF DODSNM\n*   BYTES 11-12 USED TO SAVE SHOW DSN SKIP COUNT\n         SPACE\nSHDSNMS  LA    R14,DSNMDFLT        LOAD INIT EXIT ADDR\n         SR    R4,R4               ZERO SKIP COUNTER\nDSNMDO   DS    0H\n         DENTER SDSNDSZ,C12,,NO\n         OI    CPLFLG2,CPFDSNMS    SET NULL DSNAMES OK FLAG\n         XC    SDSNQLB(SDSNQSZ),SDSNQLB    CLEAR LOWER BOUND\n         MVI   SDSNQUB,X'FF'       FILL UPPER BOUND WITH HIGH\n         MVC   SDSNQUB+1(SDSNQSZ-1),SDSNQUB     VALUES\n         XC    0(C12,R8),0(R8)     CLEAR WORK AREA\n         LA    R15,DSNRESCN        ADDRESS OF SCAN FOR SHOW DSN\n         SLR   R15,R10             MAKE ADDRESS RELATIVE\n         ST    R15,0(R8)           SAVE IT\n         BR    R14                 RETURN OR CONTINUE\n         SPACE 3\nDSNMDFLT SCTELL ,\n         SH    R1,=H'2'            GO BACK TWO CHARS\n         AH    R0,=H'2'            ADJUST LENGTH\n         ST    R1,0(R13)\n         MVC   4(2,R13),0(R1)      SAVE WHATEVER WAS\n         LA    R13,8(,R13)         STEAL 8 BYTES\n         MVC   0(2,R1),=C'# '      MOVE IN DUMMY OPERAND\n         SCINIT (1),(0)            REINIT SCANNER\n         CVCALL DODSNM         GO CONSTRUCT DEFAULT LIKE PATTERN\n         L     R15,0(R8)           GET SCAN ADDRESS\n         S     R13,=F'8'           SUBTRACT 8\n         L     R14,0(,R13)         GET BUFFER ADDRESS\n         MVC   0(2,R14),4(R13)     MOVE BACK THEM\n         B     0(R15,R10)          GO DO IT\n         EJECT\nDSNRESCN TM    CPLFLG3,CPFPUT\n         BO    DIDFIRST\n         SCAN  DSONPRT                  VOLUME OR OPTIONS\n         B     PUTRID\n         SPACE\nDIDFIRST NI    CPLFLG5,255-CPFNLST\n         L     R0,CPHIPS                HIGHEST LINE NO. YET\n         L     R1,CPGLDL                GLOBAL DELTA\n         CVCALL LOWMULT                 GET MULTIPLE\n         CVCALL ADDER                   ADD\n         STM   R0,R1,CPWKPS\n         OI    CPWKDL,FNEGBT       SET DELTA NOT SPEC. YET\nNOTFIRST CLC   DSNWADSN(4),=X'05050505' IS IT SHO SPA\n         BNE   DSNSCAN\n         SCAN  PUTOPT\n         B     PRYPRY\n         SPACE\nDSNSCAN  SCAN  PUTSTUFF                 VOLUME OR OPTIONS\nPRYPRY   TM    CPLFLG2,CPFCLEAR    WAS CLEAR SPECIFIED\n         BZ    PRYOUT              BRANCH NO\n         CVCALL DOCLEAR            GO CLEAR ACTIVE FILE\n         LM    R2,R3,CPWKPS        SAVE COLLECT VALUES\n         LTR   R6,R6               WAS A LINE NUMBER GIVEN\n         BZ    PRYCLR2             BRANCH YES\n         L     R2,CPGLDL           NO, SET START TO DELTA\nPRYCLR2  TM    CPWKDL,FNEGBT             WAS DELTA SPE?\n         BZ    PRYCLR1                   YES. BRANCH\n         L     R3,CPGLDL\nPRYCLR1  STM   R2,R3,CPWKPS        RESET COLLECT VALUES\nPRYOUT   MVC   CPNXPS(4),=F'100000000' SET COMPARAND TOO HIGH\n         OI    CPLFLG4,CPFSTSPL+CPFSTINS SET SO STOWIT WILL ONLY\n         NI    CPWKDL,255-FNEGBT\n         TM    CPWKPS,FNEGBT            ILLEGAL LINE NO.?\n         BO    BADLINES                 YES\n         LA    R1,CPWKPS                1ST LINE NO. FOR LOCATE\n         CVCALL LOCATE                  LOCATE\n         TM    CPDRPT,CPFMTCH           MATCHING LINE NO.?\n         BO    BADLINEM                  YES\n         TM    CPDRPT,CPFNTYT+CPFHIGH   OK TO COLLECT TILL 9999.9\n         BNZ   POTCHEK                  YES\n         MVC   CPNXPS(4),CPLCNO         SET COMPARAND TO NEXT LIN\nPOTCHEK  L     R0,CPWKPS                LINE NO. TO COLLECT\n         ST    R0,CPCURRL          SET CURRENT LINE\n         ST    R0,CPLCNO           SET CURRENT LINE\n         C     R0,CPNXPS                STILL SMALL ENOUGH?\n         BNL   PUTERC                   NO\n         TM    CPLFLG2,CPFSCRTC\n         BZ    PUTNOCHK\n         NI    CPLFLG5,255-CPFNTEX-CPFNLST\nPUTNOCHK TM    CPLFLG5,CPFNLST\n         BZ    PUTRID\n         TM    JCBAFL,JCBSYSPR     SYSTEM PRIVILEGES?\n         BO    PUTRID              YES..LET NOLIST STAY\n         NI    CPLFLG5,255-CPFNLST NO LIST\nPUTRID   TM    CPLFLG3,CPFSET      WAS SET SPECIFIED?\n         BZ    DSNCOLL             BR IF NOT\n         CVCALL SETPFXNS           GO DO IT\n         TWRITE ,\nDSNCOLL  NI    CPLFLG3,255-CPFPMSG\nPOLCHEK  CVCALL VOLCHEK\n         XC    CPMDLN(4),CPMDLN    INDICATE NO PAGES\n         DVTOC ,                   COLL SHOW DSNAMES ROUTINE\n         MVC   CPDSNWA+DSSIZ(2),10(R8)  SAVE SKIP COUNT\nDSMBRCOM LTR   R9,R9                    PAGE  9 IN?\n         BZ    SKIPMRK                  NO\n         PMARK R9\nSKIPMRK  LTR   R15,R15                  BAD VOL., TALO, ABORT OR ERROR?\n         BZ    NGTDSER                  NO\n         CH    R15,=Y(RTNPAGES)          NOT ENUF PAGES?\n         BNE   ATTNHIT\n         OI    CPLFLG3,CPFPMSG\n         TSEG  'INSUFFICIENT PAGES FOR COMPLETE OUTPUT'\n         B     GOWARN\nATTNHIT  CH    R15,=Y(RTNSHERR)    SHOW RTN ERROR?\n         BNE   CALLNGO             BR IF NOT\n         TSEG  'PROCESSING BREAK'\n         LTR   R9,R9                    ANYTHING?\n         BZ    CVGETCOM                 NO - GET NEW COMMAND\nGOWARN   TWRITE ,\nNGTDSER  L     R4,CPWK6\n         LTR   R4,R4\n         BZ    WRIDSSP1\n         L     R1,CPNXPS           GET FIRST ILLEGAL\n         S     R1,CPWKPS           SUBT FIRST LINENO TO GET SIZE\n         SR    R0,R0               ZERO FOR DIVIDE\n         DR    R0,R4               CALCULATE MAXIMUM DELTA\n         C     R1,CPWKDL           IS WORK DELTA LESS OR EQUAL\n         BNL   WRIDSSP1            YES, USE WORK DELTA\n         CVCALL SELDELTA           CONVERT IT TO ACTUAL DELTA\n         ST    R1,CPWKDL           SAVE DELTA TO USE\nWRIDSSP1 PCALL WRIDSSP                 TO 2741'S\n         SPACE\nCALLNGO  PCALL NTGDOPN\n         EJECT\nDSNMSPAC OI    CPLFLG3,CPFSPACE\n         BR    R14\n         SPACE\nDSNMTYPE OI    CPLFLG3,CPFTYPE\n         BR    R14\n         SPACE\nDSNMPROT OI    CPLFLG3,CPFPROTF\n         BR    R14\n         SPACE\nDSNDALL  OI    CPLFLG3,CPFPROTF+CPFTYPE+CPFDATED+CPFSPACE\n         BR    R14\n         SPACE\nDSNMSCRT OI    CPLFLG2,CPFSCRTC         SET \"SCRATCH\" MODE\n         BR    R14                       LOOK FOR MORE\n         SPACE\nDSNMDTED OI    CPLFLG3,CPFDATED         SET DATED OPTION\n         BR    R14                       LOOK FOR MORE\n         SPACE\nSKIP     STH   R15,10(R8)          SAVE SKIP COUNT\n         BR    R14\n         SPACE\nADLIKE   DS    0H                  LIKE PATTERN\n         MVC   4(6,R8),DSNWAVOL    SAVE VOLUME\n         CVCALL DODSNM\n         L     R15,0(R8)           ADDR OF RESCAN ROUTINE\n         ALR   R15,R10             MAKE ADDRESS ABSOLUTE\n         CLI   DSNWAVOL,C' '       WAS VOLUME FOUND IN SCAN?\n         BNER  R15                 BR IF YES\n         CLI   4(R8),C' '          WAS VOLUME THERE BEFORE?\n         BER   R15                 GO START SCAN AGAIN\n         MVC   DSNWAVOL(6),4(R8)   RESTORE OLD VOLUME\n         BR    R15                 GO START SCAN AGAIN\n         SPACE 3\nDSNMEXCL OI    CPLFLG3,CPFEXCL     MARK EXCLUDE\n         SPACE\nDSNMFROM LA    R15,SDSNQLB         ADDR OF LOWER BOUND STORAGE\n         B     DSNMFMTO            GO TO COMMON ROUTINE\n         SPACE\nDSNMTO   XC    SDSNQUB(SDSNQSZ),SDSNQUB   CLEAR UPPER BOUND\n         SPACE\nDSNMTHRU LA    R15,SDSNQUB         ADDR OF UPPER BOUND STORAGE\n         SPACE\nDSNMFMTO SR    R2,R2               LENGTH REG\n         CLI   0(R1),C'$'\n         BE    FMTOERR             $ SPEC INVALID\n         CLI   0(R1),C'*'          WAS PREFIX USE SPECIFIED?\n         BNE   NOFTPFX             BR IF NO\n         LH    R2,CPPFXL           GET PREFIX LENGTH\n         LTR   R2,R2               IS THERE ONE?\n         BZ    NOFTPFX             BR IF NO\n         CLI   CPPFX,C'$'          DOES PFX HAVE $?\n         BE    FMTOPERR            IT'S NFG IF SO\n         LA    R4,CPPFX            ADDR OF SOURCE\n         BCTR  R2,0                FOR EX\n         EX    R2,FMTOMVC          MOVE PREFIX\n         LA    R2,1(R2)            BUMP IT BACK AGAIN\n         AR    R15,R2              UPDATE POINTER\n         LA    R1,1(R1)            BUMP PAST \"*\"\n         BCTR  R0,0                ALSO ADJUST OPERAND LENGTH\n         SPACE\nNOFTPFX  LR    R4,R0               OPERAND LENGTH\n         AR    R4,R2               PLUS PFX LENGTH\n         CH    R4,=H'44'           IS TOTAL OK?\n         BH    FMTOLERR            BR IF TOO LONG\n         LTR   R2,R0               OPERAND LENGTH\n         BZR   R14                 BR IF NULL OPERAND\n         LR    R4,R1               ADDR OF OPERAND\n         BCTR  R2,0                FOR EX\n         EX    R2,FMTOMVC          MOVE OPERAND\n         BR    R14                 EXIT TO SCANNER\n         SPACE\nFMTOMVC  MVC   0(0,R15),0(R4)      MOVE FROM/THRU STRING\n         SPACE 3\nFMTOERR  TSEG  '$'\n         B     FMTOERRX\n         SPACE\nFMTOPERR TSEG  '$ IN PREFIX'\n         SPACE\nFMTOERRX B     CVUNLEGL\n         SPACE\nFMTOLERR TSEG  (1),(0),B\n         TSEG  'TOO LONG'\n         B     CVQTYPE\n         EJECT\nHAVTO    LA    R6,POTLNENO-P023    SET LINE NUMBER RETURN\n         LCR   R6,R6               SET NEGATIVE TO FLAG RELATIVE\n         SCAN  LINPRT              GO GET TO LINE\n         B     CVABSENT            MISSING IF NOTHING FOUND\n         SPACE\nPOTLNENO ST    R0,CPWKPS                SET NEW LINE NO. & DELTA\n         TM    CPWKDL,FNEGBT             WAS DELTA SPE?\n         BZ    POTDEL                    YES. BRANCH\n         ST    R1,CPWKDL\nPOTDEL   SR    R6,R6               FLAG HAVE LINE NUMBER\n         B     NOTFIRST\n         SPACE\nPOTDLL   LTR   R15,R15                  ZERO NG\n         BZ    CVNVALID                 NG\n         ST    R15,CPWKDL               STORE COLLECT DELTA\n         B     NOTFIRST\n         SPACE 3\nBADLINEM L     R0,CPLCNO           GET BAD LINE NUMBER\n         CVCALL CVEXNO             CONVERT TO EXTERNAL FORM\n         TSEG  (1),(0),B           PUT IT IN MESSAGE\nBADLINES TSEG  'LINE NO.'\n         B     CVUNLEGL\n         SPACE 3\nPUTERC   TSEG  'NO REPLACE OR INTERLEAVE'\n         B     CVQTYPE\n         SPACE 3\nBADBAD   B     CVNVALID\n         EJECT\n* SCAN TABLE FOR SHOW DSNAMES\n         SPACE\nPUTSTUFF SCKW  AT,HAVTO\n         SCKW  BY,POTDLL,(P,LN)\nDAPRC    SCKW  ,,PUSH        FILLED IN AT INIT TO CLRPRT\nLAPRC    SCKW  ,,PUSH        FILLED IN AT INIT TO LTNPRT\nDSONPRT  SCKW  DATED,DSNMDTED,A\n         SCKW  LIKE,ADLIKE,A\n         SCKW  FROM,DSNMFROM,(P,A)\n         SCKW  EXCLUDE,DSNMEXCL,(P,A)\n         SCKW  THROUGH,DSNMTHRU,(P,A)\n         SCKW  THRU,DSNMTHRU,P\n         SCKW  TO,DSNMTO,P\n         SCKW  SPACE,DSNMSPAC,A\n         SCKW  SIZE,DSNMSPAC,A\n         SCKW  TRACKS,DSNMSPAC,A\n         SCKW  TYPE,DSNMTYPE,A\n         SCKW  PERMIT,DSNMPROT,A\n         SCKW  ALL,DSNDALL   SPA TYP DAT\n         SCKW  SKIP,SKIP,(P,PI,A),999\n         SCKW  SCRATCH,DSNMSCRT,A\nDSONPRT1 SCKW  ,,PUSH        FILLED IN AT INIT TO IGDSNPRT\nCOMPRT   SCKW  SCRATCH,DSNMSCRT,A\nDSONPRT2 SCKW  ,BADBAD\n         SPACE\nLINPRT   SCKW  ,,PUSH        FILLED IN AT INIT TO LNENOPRT\n         SCKW  ,BADBAD\n         SPACE\nPUTOPT   SCKW  AT,HAVTO\n         SCKW  BY,POTDLL,(P,LN)\nDOPRC    SCKW  ,,PUSH        FILLED IN AT INIT TO CLRPRT\nLOPRC    SCKW  ,,PUSH        FILLED IN AT INIT TO LTNPRT\n         SCKW  ,DSONPRT2,PUSH\n         TITLE 'GETTPAG ROUTINE -- PAGE 23'\nGETTPAGR XENTER 15,8,44       SAVE SPACE (USED BY SHOW DSNAMES)\nGETTPAG  EQU   GETTPAGR-P023        MAKE RELATIVE ADDRESS\n         L     2,CPMDLN       NO PAGES ALREADY\n         LTR   2,2            ANY?\n         BNP   GETTNO1\n         PMARK R9\n         CH    R2,=Y(10)                10 MAX\n         BNL   SENSAME\nGETTNO1  PGET  R9\n         BZ    SENSAME\n         LA    2,1(2)         ONE MORE\n         ST    2,CPMDLN       STORE\n         SLL   2,2            POINT AT PLACE TO STORE PAGE NO\n         ST    0,CPMDAD-4(2)  STORE PAGE NO\nSENSAME  LTR   R9,R9\n         XEXIT 15,8\n         TITLE 'END OF PAGED CODE -- PAGE 23'\n         PINIT             DEFINE END OF CODE - START OF INIT\n         MVC   DSONPRT1+1(3),CVIGDSN+1  SET TO IGDSNPRT\n         MVC   LINPRT+1(3),CVLNENO+1  SET TO LNENOPRT\n         MVC   LAPRC+1(3),CVLTNPR+1   SET TO LTNPRT\n         MVC   DAPRC+1(3),CVCLRPR+1   SET TO CLRPRT\n         MVC   LOPRC+1(3),CVLTNPR+1   SET TO LTNPRT\n         MVC   DOPRC+1(3),CVCLRPR+1   SET TO CLRPRT\n         PEND                      END OF PAGE\n         TITLE 'START OF PAGED CODE -- PAGE 26'\nP026     PAGECDE SHOSPAC,DSNERR,GOCOMP\n         WIDENT 001\n         TITLE 'SHOW SPACE -- PAGE 26'\nPSHOSPAC GENTER  ,\n         SCAN  SHSPCPRT            SCAN FOR OPTIONS\n         B     CVABSENT\n         SPACE 3\nSHSPCON  DS    0H\n         DENTER SDSNDSZ,C12,,NO\n         XC    CPDSNWA(DSSIZ),CPDSNWA   CLEAR DSNAME WORK AREA\n         MVC   DSNWAVOL(6),0(R15)  SAVE VOLUME\n         MVC   DSNWADSN,=X'05050505'  DSN IS FORMAT 5 DSCB\n         MVI   DSNWANL+1,4         LENGTH OF DSNAME\n         PCALL SHODSN\n         TITLE 'ERROR MESSAGES -- PAGE 26'\nPDSNERR  GENTER ,\n         XC    RTBWC(4),RTBWC\n         B     *(R2)               JUMP AROUND\n         SPACE\n         B     PPOTERD             4\n         B     PPOTERC             8\n         B     CVGETCOM            12\n*                                  16\n         SPACE 3\nPWHAT    TM    CPLFLG3,CPFPMSG     ALREADY GIVEN 1 OF THESE?\n         BO    CVGETCOM            YES. DONT TALK SO MUCH\n         PCALL NOMORPG             ALRIGHT..BETTER SAY SOMETHING\n         SPACE\nPPOTERD  TSEG  '99999.999 EXCEEDED'\n         B     CVGETCOM\n         SPACE\nPPOTERC  TSEG  'ABORTED BY ATTEMPT TO REPLACE OR INTERLEAVE',,B\n         MVC   CPWORK1(4),CPCURRL\n         CVCALL LSLNMSG   GO DO LAST LINE MSG & DON'T COME BACK\n         TITLE 'COMPARE ROUTINE -- PAGE 26'\nPGOCOMP  GENTER ,\n         SR    R5,R5\n         LA    R1,16(,R8)          POINT TO\n         CVCALL LOCATE                 HIGH LINE NO\n         TM    CPDRPT,CPFNTYT+CPFHIGH  DONE IF TOO HIGH OR NONE\n         BNZ   TOOHIX\n         SYSQS 6,5,'DON''T '\nLOOPA    LR    R1,R8                    POINT AT 1ST LINE NO.\n         MVI   32(R8),X'40'\n         MVC   33(165,R8),32(R8)\n         CVCALL LOCATE                   LOCATE\n         TM    CPDRPT,CPFMTCH           MATCH?\n         BO    HAVLN1                   YES\n         MVC   0(4,R8),CPLCNO           SET FOR NEXT LOCATE\n         TM    CPDRPT,CPFPGHI          IS IT END OF PAGE\n         BE    HAVLN1                  NO, WE HAVE NEXT LINE\n         B     LOOPA                    GET IT\n         SPACE 3\nHAVLN1   LA    R1,C32(,R8)\n         CVCALL UNPRESS\n         LR    R2,R0\n         PFLIP 11,9                    SAVE PAGE POINTER\nLOOPB    LA    R1,16(R8)                POINT AT 2ND LINE NO.\n         CVCALL LOCATE                   LOCATE\n         TM    CPDRPT,CPFMTCH           MATCH?\n         BO    HAVLN2                   YES\n         MVC   16(4,R8),CPLCNO          SET FOR NEXT LOCATE\n         TM    CPDRPT,CPFPGHI          IS IT END OF PAGE\n         BE    HAVLN2                  NO, WE HAVE NEXT LINE\n         B     LOOPB                    GET IT\n         SPACE\nHAVLN2   LA    R1,C32+SZR(,R8)\n         CVCALL UNPRESS\n         LM    R3,R4,CPWK1\n         LTR   R4,R4\n         BNZ   GOCOMP\n         LR    R4,R2\n         CR    R2,R0\n         BNL   GOCOMP\n         LR    R4,R0\nGOCOMP   SR    R4,R3\n         BM    COMPOK\n         BCTR  R3,0\n         LA    R3,0(R8,R3)\n         EX    R4,CCCOMP2\n         BNE   OUTPUTT                  NOT SAME\nCOMPOK   LR    R3,R0\n         L     R0,16(R8)                LINE 2\n         C     R0,CPHIPS           FINISHED LAST LINE IN FILE\n         BNL   OUTPAT              YES, REPORT ALL COMPARE\n         LA    R1,1                     INCREMENT\n         CVCALL ADDER                    NEXT\n         ST    R0,16(R8)                SET\n         L     R0,0(R8)                 LINE 1\n         LA    R1,1                     INCREMENT\n         CVCALL ADDER                    NEXT\n         ST    R0,0(R8)                 SET\n         B     LOOPA                    MORE\n         SPACE 3\nOUTPAT   SR    R5,R5               ZERO COUNT SO 'DON''T ' OMITTED\nOUTPUTT  LR    R3,R0\n         L     R0,0(,R8)               LINE 1\n         CVCALL CVEXNO                   CONV\n         TSEG  (1),(0),B           INTO MSG\n         TSEG  '--',,B\n         L     R0,16(,R8)              LINE 2\n         CVCALL CVEXNO                   CONV\n         TSEG  (1),(0),B                INTO MSG\n         TSEG  (6),(5)\nTOOHIX   TSEG  'COMPARE',,W\n         TM    CPLFLG5,CPFNLST     NOLIST OPTION\n         BO    CVGETCOM            YES, GO GET NEXT COMMAND\n         LTR   R5,R5               DID LAST COMPARE OR NOT\n         BZ    CVGETCOM            COMPARE, DO NOT LIST THEM\n         LR    R1,R8               POINT TO 1ST LINE NO\nCOMPLST  LA    R1,C32(,R8)         POINT TO UNPRESS AREA\n         MVC   CPLCNO(4),0(R8)\n         LR    R0,R2\nCOMPLST1 CVCALL LISTLINE            FORMAT LINE FOR OUTPUT\n         LTR   R5,R5               SECOND TIME THROUGH\n         BZ    CVGETCOM            YES, GO GET NEXT COMMAND\n         SR    R5,R5               SET SWITCH FOR 2ND PASS\n         LA    R1,C32+SZR(,R8)\n         LR    R0,R3\n         MVC   CPLCNO(4),16(R8)\n         B     COMPLST1\n         SPACE\nCCCOMP2  CLC   C32(1,R3),C32+SZR(R3)\n         SPACE 3\n* SCAN TABLES FOR SHOW SPACE\n         SPACE\nINVAL    B     CVNVALID\n         SPACE\nSHSPCPRT SCKW  ON,SHSPCON,P\nSHSPC1   SCKW  ,INVAL\n         TITLE 'END OF PAGED CODE -- PAGE 26'\n         PINIT             DEFINE END OF CODE - START OF INIT\n         PEND                      END OF PAGE\n         TITLE 'START OF PAGED CODE -- PAGE 24'\nP024     PAGECDE WRIDSSP\n         WIDENT 001\n         TITLE 'WRITE OUTPUT FOR SHOW DSNAMES/SPACE -- PAGE 24'\n* WRIDSSP IS USED TO LIST INFORMATION PASSED FROM SHOW DSNAMES\n* AND SHOW SPACE\n*   CPMDLN CONTAINS THE NUMBER OF PAGES OF INFORMATION.\n*   CPMDAD CONTAIN UP TO TEN PAGE NUMBERS.\n*   THE FIRST HALF-WORD ON EACH PAGE IS THE PAGE BYTE-COUNT.\n*   EACH FIRST BYTE IN A LINE IS THE CHARACTER COUNT FOR THE LINE.\n*   A LINE CHARACTER COUNT OF ZERO INDICATES ALL DONE.\n*\n*   THE WORD AFTER 'DSSIZ' (DSSIZ+4 BELOW) IS USED TO STORE\n*   THE SKIP COUNT FOR SHOW DSNAMES AND THE ORIGINAL\n*   PATTERN LENGTH FOR SHOW CATLG.\n         SPACE\nPWRIDSSP DENTER DSSIZ+4,SDSNDSZ-DSSIZ+SBSZ\n         NI    CPLFLG3,255-CPFPUTER\n         L     R5,CPMDLN                NO. PAGES\n         LA    R6,CPMDAD-4              4 BYTES B/4 1ST PAGE NO\n         SR    R4,R4\n         LTR   R5,R5                    ANY?\n         BP    GTNXTPG             YES, START LOOP\n         PCALL NOMORPG             NO, ISSUE MESSAGE TO USER\n         SPACE\nGTNXTPG  LA    R6,4(R6)                 POINT AT NEXT PAGE NO\n         LTR   R9,R9                    PAGE IN?\n         BZ    GETNXPG                  NO\n         PNUM  R9                       WHICH PAGE IS IN?\n         C     R0,0(R6)                 RIGHT ONE?\n         BE    PROCPAG                  YES\nGETNXPG  L     R0,0(R6)                 PAGE NO NEEDED\n         PGET  R9,(0)                   GET IT\n         LTR   R4,R4\n         BNZR  R4\nPROCPAG  LA    R3,2                     NO. BYTES PROCESSED ON PAGE\nNEXTLINX CH    R3,0(R9)            MORE ON PAGE?\n         BNL   GONXPAG                  NO\n         TM    CPLFLG2,CPFSTOP          TEST IF MORE WANTED\n         BNZ   GONXPAG                  NO MORE\n         SR    R2,R2\n         IC    R2,0(R3,R9)              LINE CHAR COUNT\n         LTR   R0,R2                    ANY?\n         BZ    ALLDONN                  NO\nLOADAFC  LA    R1,1(R3,R9)         POINT AT 1ST CHAR IN LINE\n         SPACE 3\n* FORMAT AND WRITE INFORMATION FOR SHOW DSNAMES COMMAND.\n*\n* REGISTERS ARE USED AS FOLLOWS:\n*   R2    CHAR COUNT IN LINE OF DATA.\n*   R3    NUMBER OF BYTES PROCESSED IN CURRENT PAGE.\n*   R4    POINTS TO CURRENT INPUT LINE (SDSNBUF).\n*   R5    NUMBER OF PAGES TO BE PROCESSED.\n*   R6    PAGE INDEX POINTER.\n         SPACE\n         CH    R2,=Y(SBSZ)         IS IT DSNAME LINE?\n         BE    WDSN                BR IF YES\n         TSEG  (1),(0)             NO - WRITE COMPLETE LINE\n         TM    CPLFLG3,CPFPUT\n         BZ    LWRITE\n         B     DIDNTADD\n         SPACE 3\n* FORMAT DSNAME RECORD\n         SPACE\nWDSN     LR    R4,R13              END OF CURRENT WORK AREA\n         SH    R4,=Y(SBSZ)         GET AMOUNT ACTUALLY NEEDED\n         N     R4,=F'-8'           ALIGN DOUBLEWORD\n         MVC   0(SBSZ,R4),0(R1)    MOVE CURRENT RECORD\n         AIF   ('&DCEC' EQ '1').LBLX2\n         USING SDSNBUF,R4\n         AGO   .LBLX3\n.LBLX2   DS    0H\n         USING SBUF,R4\n.LBLX3   DS    0H\n         MVC   DSNWADSN,SBDSN      MOVE ACTUAL DSNAME\n         LA    R1,0(R8)            ADDR OF WORK AREA\n         CLI   SBDSN,X'05'         IS IT SHOW SPACE?\n         BE    WNOLTW              BR IF YES\n         LH    R0,CPDSNWA+DSSIZ    GET SKIP COUNT\n         LTR   R0,R0               TEST VALUE\n         BP    WDSNSKP             SKIP THIS ONE\n         SYSQS R1,R0,DSNWADSN+43,44\nWDSNL    CLI   0(R1),X'40'\n         BNE   HAVDSNL             BR IF LAST CHAR\n         BCTR  R1,0                CHECK NXT CHAR\n         BCT   R0,WDSNL            LOOP\nHAVDSNL  STH   R0,DSNWANL          SAVE DSNAME LENGTH\n         MVI   DSNWAF1,0           CLEAR ATTRIBUTE FLAGS\n         CVCALL DSNSTDDO          GO SET ATTRIBUTE FLAGS\n         CVCALL DSNUDSDO          SET MY FLAGS\n         CVCALL DSNAMED            GO TSEG DSNAME\n         TM    CPLFLG3,CPFDATED+CPFSPACE+CPFTYPE+CPFPROTF\n         BZ    NOWWHAT             BR IF NO OTHER OPTIONS\n         TM    CPLFLG3,CPFSPACE    WAS SPACE SPECIFIED?\n         BZ    WNOSPC              BR IF NO\n         SPACE\n* FORMAT SPACE INFORMATION\n         TSEG  '--',,B\n         LA    R1,0(R8)            START OF WORK AREA\n         LH    R15,SBLB            LAST TT\n         LA    R15,1(R15)          (REL TO 0)\n         CH    R15,SPTRK           SAME AS LAST ALLOC TRK?\n         BNL   WNOLTW              BR IF YES\n         BTD   (1),0,(15)          CONVERT\n         AR    R1,R0               BUMP PTR BY LENGTH\n         MVC   0(4,R1),=C' OF '\n         LA    R1,4(R1)\nWNOLTW   LH    R15,SPTRK           NUMBER OF TRKS ALLOCATED\n         LTR   R15,R15             TEST SPACE ALLOC COMPLETE?\n         BNM   WNOLTW2             BR IF YES\n         STM   R0,R1,CPDOUB        SAVE AROUND TSEG\n         TSEG  '>>'\n         LM    R0,R1,CPDOUB\n         LPR   R15,R15\nWNOLTW2  BTD   (1),0,(15)          CONVERT\n         AR    R1,R0               BUMP PTR BY LENGTH\n         MVC   0(5,R1),=C' TRKS'\n         LA    R1,5(R1)\n         CLI   SBNOEX,1            WAS THERE ONE EXTENT?\n         BE    WNOEXT              BR IF YES - DON'T BOTHER\n         MVC   0(2,R1),=C', '\n         LA    R1,2(R1)\n         SPACE\n* FORMAT NUMBER OF EXTENTS USED\n         SR    R15,R15\n         IC    R15,SBNOEX          NUMBER OF EXTENTS\n         CLI   SBDSN,X'05'         IS IT SHO SPA?\n         BNE   *+8                 IF NOT SKIP NEXT INSTR\n         LH    R15,SBDSN+8         GET REAL # OF EXTENTS\n         BTD   (1),0,(15)          CONVERT\n         AR    R1,R0               BUMP PTR BY LENGTH\n         MVC   0(5,R1),=C' EXTS'\n         LA    R1,5(R1)\n         CLI   SBDSN,X'05'\n         BNE   WNOEXT\n         MVC   0(2,R1),=C', '\n         LA    R1,2(R1)\n         L     R15,SBDSN+4\n         BTD   (1),0,(15)          CONVERT\n         AR    R1,R0               BUMP PTR BY LENGTH\n         MVC   0(9,R1),=C' TRKS MAX'\n         LA    R1,9(R1)\nWNOEXT   LR    R0,R1               CURRENT POINTER\n         LA    R1,0(R8)            START OF WORK AREA\n         SR    R0,R1               LENGTH OF LINE\n         TSEG  (1),(0)\n         CLI   SBDSN,X'05'         IS IT SHOW SPACE?\n         BE    NOWWHAT\n         TM    DSNWAF1,DSNFSTD     STANDARD WYLBUR DSN?\n         BZ    WNOSPC\n         CLI   SBACCTG,0           ACCOUNTED FOR?\n         BNE   WNOSPC\n         TM    JCBAFL,JCBSYSPR\n         BZ    WNOSPC\n         TSEG  ' N/A'              INDICATE NOT ACCOUNTED FOR\n         SPACE\n* FORMAT  FILE TYPE INFO AND DATE INFO ON SECOND LINE.\nWNOSPC   TM    CPLFLG3,CPFTYPE+CPFDATED+CPFPROTF\n         BZ    NOWWHAT\n         TSEG  '   '               ADD BLANKS\n         TM    CPLFLG3,CPFTYPE     WAS TYPE SPECIFIED?\n         BZ    WNOTYPE             BR IF NO\n         LA    R1,0(R8)            START OF WORK AREA\n         SPACE\n* FORMAT TYPE INFORMATION\n         SR    R15,R15\n         NI    SBDSORG,X'E2'       CLEAR GARBAGE BITS\n         IC    R15,SBDSORG         GET DSORG BYTE\n         SRL   R15,4               MOVE PS,IS,DA TO LOW BITS\n         TM    SBDSORG,X'02'       PO?\n         BZ    *+8                 BR IF NO\n         LA    R15,1(R15)          YES - ADD ITS BIT\n         STC   R15,SBDSORG         SAVE DSORG INDEX BYTE\n         SPACE\n* DSORG NOW HAS LOW ORDER FOUR BITS REPRESENTING PS/IS/DA/PO\n         TR    SBDSORG,DSORGTR     TRANSLATE INTO INDEX BYTE\n         IC    R15,SBDSORG         GET INDEX\n         LA    R15,DSORGTBL(R15)   GET ADDR OF DISPLAY\n         MVC   0(2,R1),0(R15)      MOVE TO DISPLAY BUFFER\n         MVC   2(2,R1),=C', '\n         LA    R1,4(R1)            BUMP PTR\n         SPACE\n* FORMAT RECFM\n         SR    R15,R15\n         IC    R15,SBRECFM\n         SRL   R15,6               ONLY PROCESS F/V/U\n         LA    R15,RECFMTBL(R15)   GET ADDR OF CHAR\n         MVC   0(1,R1),0(R15)      MOVE IT TO BFR\n         LA    R1,1(R1)\n         SPACE\n* FORMAT REST OF RECFM\n         TM    SBRECFM,X'10'       BLOCKED?\n         BZ    *+12                BR IF NO\n         MVI   0(R1),C'B'\n         LA    R1,1(R1)\n         TM    SBRECFM,X'20'       TRACK OVERFLOW?\n         BZ    *+12                BR IF NO\n         MVI   0(R1),C'T'\n         LA    R1,1(R1)\n         TM    SBRECFM,X'08'       STANDARD?\n         BZ    *+12                BR IF NO\n         MVI   0(R1),C'S'\n         LA    R1,1(R1)\n         TM    SBRECFM,X'04'       ASA CONTROL?\n         BZ    *+12                BR IF NO\n         MVI   0(R1),C'A'\n         LA    R1,1(R1)\n         TM    SBRECFM,X'02'       MACHING CONTROL?\n         BZ    *+12                BR IF NO\n         MVI   0(R1),C'M'\n         LA    R1,1(R1)\n         MVI   0(R1),C'/'\n         LA    R1,1(R1)\n         SPACE\n* FORMAT LRECL\n         LH    R15,SBLRECL\n         BTD   (1),0,(15)          CONVERT\n         AR    R1,R0               PTR PLUS LENGTH\n         MVI   0(R1),C'/'\n         LA    R1,1(R1)\n         SPACE\n* FORMAT BLOCKSIZE\n         LH    R15,SBBLKSZ\n         BTD   (1),0,(15)          CONVERT\n         AR    R1,R0               PTR+LENGTH\n         SPACE\n* CHECK IF A KEYLENGTH\n         CLI   SBKEYL,0            IS THERE ONE?\n         BE    WPRTYPE             BR IF NO\n         MVI   0(R1),C'/'\n         LA    R1,1(R1)\n         SR    R15,R15\n         IC    R15,SBKEYL\n         BTD   (1),0,(15)\n         AR    R1,R0\n         SPACE\n* PRINT IT\nWPRTYPE  LR    R0,R1               CURR PTR\n         LA    R1,0(R8)            START OF WORK AREA\n         SR    R0,R1               LENGTH\n         TSEG  (1),(0)\n         TM    CPLFLG3,CPFDATED+CPFPROTF\n         BZ    NOWWHAT\n         TSEG  ';',,B\nWNOTYPE  TM    CPLFLG3,CPFDATED+CPFPROTF\n         BZ    NOWWHAT             BR IF NO\nWOKTYPE  TM    CPLFLG3,CPFPROTF\n         BZ    WDATED\n         SPACE\n* FORMAT PROTECTION\n         CVCALL TPROTF\n         TM    CPLFLG3,CPFDATED\n         BZ    NOWWHAT\n         TSEG  ';',,B\n         SPACE\n* FORMAT DATES\nWDATED   LR    R1,R8\n         MVC   CPWK2+1,SBCRDT      CREATION DATE\n         MVC   CPWK3+1,SBEXDT      LAST ACCESS DATE\n         DROP  R4\n         LA    R15,CPWK2           ADDR OF CREATION DATE\n         BAL   R4,WCNVDT           GO CONVERT\n         MVI   8(R1),C' '          SEPERATOR\n         LA    R1,9(R1)           BUMP PTR BY DATE AND PREV\n         LA    R15,CPWK3           ADDR OF LAST ACCESS DATE\n         BAL   R4,WCNVDT           GO CONVERT\n         LA    R1,8(R1)            BUMP PTR BY SECOND DATE\n         LR    R0,R1               CURR PTR\n         LA    R1,0(R8)            START OF WORK AREA\n         SR    R0,R1               LENGTH\nNOWTSEG  TSEG  (1),(0)\n         B     NOWWHAT             ALL DONE\n         SPACE 3\n* SHOW DSNAMES SKIP COUNT NOT YET ZERO\n         SPACE\nWDSNSKP  BCTR  R0,0                DECREMENT BY ONE\n         STH   R0,CPDSNWA+DSSIZ    SAVE NEW VALUE\n         B     NEXTLIN             GO ON TO NEXT LINE\n         EJECT\nNEXTRY   LR    R15,R1                  GET ADDR OF LAST CHAR\n         AR    R15,R0\nNEXTRYX  BCTR  R15,0                   BACK UP ONE CHAR\n         CLI   0(R15),C' '              BLANK?\n         BNE   NOWTSEG             NO\n         BCT   R0,NEXTRYX\nNEXTLIN  LA    R3,1(R3,R2)             COUNT TO NEXT LINE\n         B     NEXTLINX\n         SPACE 3\nNOWWHAT  TM    CPLFLG3,CPFPUT            PUT?\n         BZ    DONTPUT                   NO. BRANCH.\nPONEXT   LM    R0,R1,CPWKPS             LINE NO.\n         CVCALL ADDER                   ADD\n         BM    POTERD                   TOO BIG\n         ST    R0,CPWKPS                SAVE NEXT LINE NO.\n         ST    R0,CPLCNO                FOR LISTLINE ROUTIN\nDIDNTADD MVC   0(133,R8),RTBTEXT        INTO WORK AREA\n         LH    R0,RTBWC\n         LR    R1,R8                    SET POINTER\n         L     R15,CPWKPS               LINE NO. INTO R15\n         CVCALL PRESS                   PRESS\n         CVCALL STOWIT                STOW IT AWAY\n         BM    POTERC                   REPL ERR\n         BNZ   BADFIT\n         MVC   CPCURRL(4),CPWKPS   SET CURRENT LINE\n         PNUM  R9                       CHECK ON R9?\n         C     R0,0(R6)\n         BE    NOWWRIT\n         BAL   R4,GETNXPG               GET IT BACK\n         EJECT\nNOWWRIT  LH    R0,RTBWC\n         XC    RTBWC(4),RTBWC\n         TM    CPLFLG5,CPFNLST          NOLIST?\n         BO    NEXTLIN                  YES   BRANCH.\n         MVC   0(133,R8),RTBTEXT        INTO WORK AREA\n         LR    R1,R8\n         CVCALL LISTLINE\n         BP    DSNMATTN                 ATTN HIT.\nDONTPUT  TM    CPLFLG2,CPFSCRTC         \"SCRATCH\" OPTION?\n         BO    PPROMPTT                 YES\nLWRITE   TM    CPLFLG3,CPFPUT            PUT COMMAND?\n         BO    NEXTLIN                  LINE ALREADY PRINTED\n         TWRITE ,\n         BP    DSNMATTN\n         B     NEXTLIN\n         EJECT\nBADFIT   LR     R2,R15                   MAKE A TRADE\n         B      CALLPERR\n         SPACE\nPOTERD   LA    R2,4\n         B     CALLPERR\n         SPACE\nPOTERC   LA    R2,8\nCALLPERR OI    CPLFLG3,CPFPUTER\n         SPACE\nDSNMATTN OI    CPLFLG2,CPFSTOP          SET TO PRINT NO MORE\nGONXPAG  PFREE R9,EMPTY                 SCRATCH PAGE\n         SR    R4,R4\n         BCT   R5,GTNXTPG               GET NEXT PAGE (IF ANY)\nALLDONN  PFREE R9,EMPTY                 SCRATCH LAST PAGE\n         TM    CPLFLG3,CPFPUTER\n         BZ    CVGETCOM\n         PCALL DSNERR\n         SPACE 3\nDSORGTR  DC    AL1(0,4,6,0,2),XL3'0',AL1(8),XL7'0'  INDEX VALUES\nDSORGTBL DC    C'**PSPODAIS'       DISPLAYS\nRECFMTBL DC    C'*VFU'             DISPLAYS\n         SPACE 3\n* ROUTINE TO CONVERT DSCB DATE INTO MM/DD/YY FORMAT.\n*   R1 POINTS TO AREA WHERE CONVERTED DATE TO BE PLACED,\n*   R15 POINTS TO FULLWORD WITH DSCB DATE IN LAST THREE BYTES\n         SPACE\nWCNVDT   SR    R0,R0\n         IC    R0,1(R15)           GET YEAR\n         MH    R0,=H'1000'         YEAR VALUE\n         AH    R0,2(R15)           ADD JULIAN DAY\n         CVD   R0,CPDOUB           CONVERT TO DEC\n         L     R0,CPDOUB+4         GET VALUE\n         CVCALL DATE                CONVERT\n         BR    R4                  RETURN\n         EJECT\n* PROMPT FOR SCRATCH IF DATA SET IS CANDIDATE FOR SCRATCHING\n* BY THIS USER.  OTHERWISE, FORGET THE PROMPT.\n         SPACE\nPPROMPTT TM    JCBAFL,JCBSYSPR     SYSTEM PRIVILEGES?\n         BO    PPETC2              YES..LET NOLIST STAY\n         TM    DSNWAF1,DSNFMYDS    BELONG TO USER?\n         BZ    LWRITE              BR IF NO\n         TM    DSNWAF1,DSNFWLIB    IS IT A WYLBUR LIB?\n         BO    LWRITE              YES - CON'T PROMPT\nPPETC2   SR    R1,R1\n         IC    R1,0(R3,R9)\n         CH    R1,=Y(SBSZ)\n         BNE   LWRITE\n         TM    CPLFLG5,CPFPUT\n         BO    NOPMARK\n         TMARK\nNOPMARK  SYSQS R1,R0,'SCRATCH'\nPPETC3   TREADR (1),(0)\n         BP    DSNMATTN            ABORT IF ATTENTION\n         SCINIT (1),(0)                 INIT SCAN\n         SCAN  YESSPRT                  LOOK FOR \"YES\"\n         B     NEXTLIN                  DO MORE\n         SPACE\nYESREPLY DSCRATCH ,                SCRATCH IT\n         BZ    NEXTLIN                  ON TO NEXT\n         L     R14,CVDSNMED        ADDR OF DSNAMED\n         BALR  R14,R14             GO DO PROPER ROUTINE\n         TSEG  'NOT SCRATCHED',,W\nYESRETN  BP    DSNMATTN\n         B     NEXTLIN\n         EJECT\nYESSPRT  SCKW  YES,YESREPLY\n         SCKW  OK,YESREPLY\n         SCKW  ,NEXTLIN\n         TITLE 'END OF PAGED CODE -- PAGE 24'\n         PINIT             DEFINE END OF CODE - START OF INIT\n         PEND                      END OF PAGE\n         TITLE 'CONSTANTS, ETC.'\n         COPY  WYLCONST\n         EJECT\n         COPY  RTNCODES\n         TITLE 'COPY MODS'\n         AIF   ('&DCEC' EQ '1').LBLX4\nSDSNBUF  DSECT\n         COPY  SDSNBUF\n         SPACE 3\n         COPY  SCATBUF\n         EJECT\n.LBLX4   DS    0F\nWDIOWA   WDIOWA DSECT\n         EJECT\n.LBL06   DS    0H                                               JEP00X\n         COMMON ,\n         SPACE 3\nCPUNSIZE EQU   CPWK2\nCPFOV    EQU   X'08'               FLAG FOR OVER SIZE\nCPFUN    EQU   X'04'               FLAG FOR UNDER SIZE\nCPFEQ    EQU   X'10'               FLAG FOR EQUAL SIZE\n         SPACE\n         PRINT NOGEN\nCVT      DSECT\n         CVT   SYS=VMS\n         SPACE\n         END\n./ ADD NAME=PEDS,SSI=00000178\nPEDS     TITLE 'EXTERNAL DATA SET ROUTINES FOR WYLTSO'\n* PROPERTY OF C. U. C. C. A.\n         SPACE 3\n         GBLC    &DCEC             SWITCH FOR DCEC MODS         JEP00X\n         GBLC  &USPS                                            USPS01\n&USPS    SETC  '1'                                              USPS01\n&DCEC    SETC   '1'  CHANGE TO ANY OTHER NUM. TO DELETE DCEC MODJEP00X\n         AIF   ('&DCEC' NE '1').LBL01                           JEP00X\n         EJECT                                                  JEP00X\n*                                                               JEP001\n* MOD JEP001                                                    JEP001\n*  IMPLEMENTED DCEC NAMING CONVENTIONS IN SAVE.                 JEP001\n*  MODULES AFFECTED: PDIO, PEDS, PUTB,INIT MACROS(DSNWA,CVTSO)  JEP001\n*                                                               JEP001\n*                                                               JEP001\n.LBL01   DS    0H                                               JEP00X\nPEDS     CSECT\n         SPACE\n         WIDENT 001\n         SPACE\n         USING CPAREA,R12\n         SPACE\n         XTRNS ,\n         SPACE\n         ENTRY VOLCHEK\n         TITLE 'GOSAVE ROUTINE'\n* GOSAVE IS THE PRIMARY ENTRY FOR SAVE\n         SPACE\nGOSAVE   DENTER DSAVSIZ,12,GOSAVELA  LA 13 CMD USED ELSEWHERE\nSAVEBASE MVC   CPSEQFLD(4),=H'-1,8'    INITIALIZE SEQFLDS\n         MVC   CPCMNM(3),=C'SAV'       SET A POSS S TO SAV\n         SPACE\n* BACKUP TO THE PAGEFILE IS FORCED BEFORE ANY SAVE IS DONE TO\n* INSURE RECOVERY IN CASE OF SYSTEM CRASH.\n         SPACE\n         OI    CPGFLG,CPFDIRCH     YES, SET TO FORCE FILE UPDATE\nNOTNIL   CVCALL DODSNM         GO GET EITHER OR BOTH\nNOTVER   CVCALL SCNEXFR            SEE IF EXECUTE FILE RANGE\n         XCALL FMTCHK         SEE IF EDIT, CARD OR PRINT\n         STM   0,1,CPLRCL     SAVE LRECL & NRECS\n         TM    DSNWAF3,DSNFLIN     WAS A RANGE GIVEN\n         BO    SAVERNGE            BR YES\n         OI    CPLFLG1,CPFALL       SET 'ALL' OK FOR RANGE\n         CVCALL DETRNG             CALL DETRNG TO SET UP VALUES\nSAVERNGE CVCALL VOLCHEK                 MAKE SURE VOL SPECIFIED\n         TM    CPLFLG3,CPFSET      TEST \"SET\" SPECIFIED\n         BZ    ROPENN              BR IF NO\n         CVCALL SETPFXNS            GO SET PREFIX\nROPENN   TM    DSNWAF1,DSNFMYDS    DOES IT BELONG TO USER\n         BO    ROPENN1             BRANCH YES\n             AIF   ('&DCEC' NE '1').LBL02                           J\n******   DCEC NAMING CONVENTIONS IMPLEMENTED HERE.              JEP001\n*                                                               JEP001\n         LA    R2,DSNWADSN        SET POINTER TO USER ID        J\n         OC    DSNWADSN(44),BLANKS ALLOW NO UPLOW DSN'S AT DCEC JEP001\n         B     NAMECHK             GO AROUND THE BLANKS         JEP001\nBLANKS   DC    44C' '              UPPER THE CASE               JEP001\nNAMECHK  XR    R1,R1               ZERO WORK REG                JEP001\n         IC    R1,CVUSRFLD         GET LENGTH OF USERID         JEP001\n         BCTR  R1,0                DOWN 1 FOR EXECUTE           JEP001\n         CLC   CPUSERSV(0),0(R2)   IS IT THIS USER???           JEP001\n         EX    R1,*-6              EXECUTE ABOVE INSTRUCTION    JEP001\n         BE    ROPENN1            BRANCH YES                    JEP001\n.LBL02   DS    0H                                               JEP00X\n         BAL   R14,NOTMYDS         NO, GO TELL USER\nROPENN1  DOPEN CPLRCL,=A(GETSIZE),SAVE  OPEN DS\n         BNZ   PROBOPN        SOMETHING NG\n         LA    R2,2                ASSUME EDIT SAVE\n         L     R3,CPLRCL           GET LRECL\n         LTR   R3,R3               IS IT EDIT OR FIXED\n         BZ    ROPENN2             BR IF EDIT\n         BCTR  R3,0                SET LRECL FOR EX MOVES\n         ST    R3,CPNREC           PUT IN NREC\n         SR    R2,R2               SET DISPLACEMENT FOR FIXED\nROPENN2  OI    CPGFLG,CPFOPN  SET EXTERNAL DS OPENED\n         ST    1,CPDRED       SAVE EXTERNAL I/O BUFF ADDR\n         ST    0,CPRCSZ       SAVE OUTPUT RECORD SIZE\n         AR    1,2            POINT TO ADDR FOR FIRST TEXT BYTE\n         ST    1,CPNXAD       SAVE\n         ST    2,CPNWCT       INTO CURRENT COUNT\n         OI    CPLFLG5,CPFNCUR     SET NOT TO CHANGE CURRENT\n         L     15,WORKXD      SET ADDR FOR DESPOT\n         TM    CPLFLG5,CPFSELOC    IS IT ACTIVE OR EXEC RANGE\n         BZ    *+8                 BRANCH IF ACTIVE\n         O     R15,=AL1(LEXATRTN,0,0,0) SET FOR EXEC RANGE\n         CVCALL DESPOT         GO TO DESPOT\n         SPACE\n* VOID RANGES FOR SEQUENTIAL SAVES ARE CAUGHT AT DOPEN.\n* VOID RANGES FOR PDS SAVES AREN'T CAUGHT UNTIL NOW\n         SPACE\n         TM    CPSTAD,CPFSOME WAS RANGE VOID\n         BZ    DOCLOSVD            BRANCH YES FOR SPECIAL CLOSE\n         TM    CPLRCL+3,FALLBT   WAS IT EDIT FORMAT\n         BNZ   DOWRITT        NO - ONLY WRITE\n         L     2,CPNWCT       REMAINING COUNT\n         L     3,CPDRED       TO 1ST HALF-WORD\n         STH   2,0(3)         STORE IT\nDOWRITT  L     0,CPNWCT       COUNT THIS REC\n         DWRITE (0)           WRITE LAST\n         BZ    DOCLOS         B IF DISK I/O OK\n         BP    EOV                 BR IF NO MORE SPACE\n         XCALL WDSKER         GO DO MESSAGE ON DISK WRITE ERROR\nDOCLOS   DCLOSE ,             CLOSE\n         NI    CPGFLG,255-CPFOPN  SET EXTERNAL DATA SET CLOSED\n         LR    R2,R15              SAVE RETURN CODE\n         LR    R3,R0               ALSO SAVE SECOND RETURN CODE\n         LH    R0,RTBWC            CHECK IF ANYTHING TO WRITE\n         LTR   R0,R0\n         BZ    DOCLOS3             BRANCH NO\n         TWRITE ,                  WRITE OUT LINE\nDOCLOS3  TM    CPLFLG2,CPFSMALL    WAS SMALL DATA SET SAVED\n         BZ    DOCLOS4             BRANCH NO\n         TM    JCBAFL,JCBSYSPR     SYS PRIV?\n         BO    DOCLOS4             AVOID MSG\n         TSEG  'PUT SMALL DATASETS IN A LIBRARY TO AVOID WASTING LARGE *\n               AMOUNTS OF SPACE',,W\n* ROUTINE TO PROCESS RETURN FROM DCLOSE\nDOCLOS4  LR    R0,R3               RESTORE R0 RETURN CODE\n         LTR   R15,R2           RESTORE AND TEST RETURN CODE\n         BZ    GOODCLOS            BR IF EVERYTHING NORMAL\n         BM    NORMPDSA            BR IF PDS OUT OF SPACE\n         CH    R15,=Y(RTNCATER)    TEST FOR CATER\n         BE    NTGDOPN             IF YES IT'S ERROR ON STOW\n         SPACE\n* OTHERWISE IT'S A CATLG ERROR\nGOODCLOS XCALL CLRTST              GO CLEAR ACTIVE IF SO SPEC\n         XCALL CHKMBRIG            CHECK MEMBER IGNORED\n         BAL   R4,ALREDDY          GO TSEG FIRST PART OF MSG\n         TM    CPLFLG2,CPFSCRTC    TEST IF OLD ONE DELETED\n         BZ    GDCLSA              NO - NEW ONE ADDED\n         TSEG  'REPLACED',,B\n         B     GDCLS2\n         SPACE\nGDCLSA   TSEG  'SAVED',,B\nGDCLS2   TM    DSNWAF2,DSNFPDS     WAS IT A PDS SAVE?\n         BZ    GDCLSPS             BR IF NO\n         TSEG  'IN',,B\n         CVCALL DSNAMED\n         SPACE\n* SEQ DATA SET SAVE\nGDCLSPS  TM    CPLFLG3,CPFRECLG    TEST ANY CATLG BITS ON\n         BZ    GDCLSPS2            BR IF NOT\n         LTR   R2,R2               WAS THERE A CATLG ERROR?\n         BNZ   GDCLSPS2            BR IF YES\n         TSEG  'AND',,B\n         CVCALL CTLGED\nGDCLSPS2 TM    DSNWAF2,DSNFPDS     WAS IT A PDS SAVE?\n         BNZ   CHKCATD             BR IF YES\n         TSEG  'ON',,B\n         TSEG  DSNWAVOL,6\nCHKCATD  TWRITE ,\n         LTR   R15,R2              TEST RETURN CODE\n         BZ    GETCOM              NORMAL\n         TSEG  ' --',,B\n         PCALL NTGDCAT\n         EJECT\n* SCRATCH WITH SAVE CODE\n         SPACE\nSCRTGO   OI    CPLFLG2,CPFSCRTC    SET SCRATCH BIT\n         B     ROPENN         GO OPEN\n         SPACE\n* THE RANGE SPECIFIED FOR A PDS SAVE WAS VOID -- CLOSE DATA\n* SET AND GO ISSUE ABORTED MESSAGE -- NOTE THAT THE VOID RANGE\n* MESSAGE HAS ALREADY BEEN ISSUED BY DESPOT\nDOCLOSVD DCLOSE ,                  CLOSE THE DATA SET\n         NI    CPGFLG,255-CPFOPN   SET DATA SET CLOSED\n         LA    R15,ABRTCODE        SET CODE FOR ABORT\n         B     NTGDOPN             GO DO MESSAGE\n         EJECT\n* IF EOV (NO MORE SPACE) DURING SAVE GO HERE.  THE DCB IS\n* ALREADY CLOSED.\n         SPACE\nEOV      NI    CPGFLG,255-CPFOPN   TURN OFF XTRNAL DATA SET OPEN\n         B     PROBOPNA\n         SPACE\n* OPEN IRREGULARITY CODE\n         SPACE\nPROBOPN  BM    CHTYPE              TYPE BEING CHANGED IF MINUS\nPROBOPNA SR    R4,R4               INDICATE NOT A SUBROUTINE\n         CH    R15,=Y(RTNNOSPC)    WAS IT NO SPACE?\n         BH    NTGDOPN         OTHERS\n         BE    PROBNOSP\n         CH    R15,=Y(RTNDUPDS)        IS IT DUP DATA SET\n         BE    ALREDDY                 YES\n         B     NTGDOPN                 NO, MUST BE DS NOT ON CAT\n         SPACE\n* NO ROOM FOR DATA SET/MEMBER\nPROBNOSP TM    DSNWAF2,DSNFPDS     WAS IT A PDS SAVE?\n         BNZ   NORMPDS             BR IF YES\n         TM    CPLFLG2,CPFSCRTC    WAS OLD DATA SET DELETED?\n         BZ    NTGDOPN             BR IF NO\n         SPACE\n* TELL THE USER HIS OLD ONE IS GONE\n         TSEG  'AFTER SCRATCH ON',,B    SCRATCH WAS DONE\n         TSEG  DSNWAVOL,6          VOLUME NAME\n         TSEG  ',',,B\n         LA    R15,RTNNOSPC        RESET RETURN CODE\n         SPACE 3\n         ENTRY NTGDOPN             USE AS ENTRY FOR PCALL\nNTGDOPN  PCALL NTGDOPN\n         EJECT\n* NO SPACE FOR EOF AT END OF MEMBER -- MEMBER SCRATCHED\n* BEFORE COMING HERE\nNORMPDSA TM    CPLFLG2,CPFSCRTC    DID MEMBER EXIST BEFORE\n         BZ    NORMPDS             NO, NO NEED FOR SCRATCH MESS\n         BAL   R4,ALREDDY          GO PUT IN MEMBER PART\n         TSEG  'SCRATCHED,',,B     PUT IN SCRATCHED MESSAGE\n         SPACE\n* NO ROOM IN PDS\nNORMPDS  TSEG  'NO SAVE,',,B       TELL USER NO SAVE DONE\n         CVCALL DSNAMED\n         TSEG  'FULL',,W\n         B     CVQTYPE\n         SPACE 3\n* DATA SET ALREADY THERE\n* (USED AS A SUBROUTINE TO TSEG FIRST PART OF MSG)\n         SPACE\nALREDDY  TM    DSNWAF2,DSNFPDS     WAS IT A PDS SAVE?\n         BZ    ALRDSN              BR IF NO\n         TSEG  'MEMBER',,B\n         XCALL MEMBERED\n         B     ALREDDY2\n         SPACE\nALRDSN   CVCALL DSNAMED\nALREDDY2 LTR   R4,R4               CALLED AS A SUBROUTINE?\n         BNZR  R4                  BR IF YES - RETURN\n         TSEG  'ALREADY THERE',,W\n         SYSQS 1,0,'REPLACE'       SET POSITIVE PROMPT\n         XCALL YESREQ              GO CHECK IF OK\n         B     SCRTGO              YES, GO DO REPLACE\n         SPACE\nCHTYPE   LR    R3,R0               SAVE BLOCKSIZE RETURNED\n         MVC   CPDRED(8),CPDOUB    SAVE KEY\n         TSEG  'WARNING - DATASET TYPE WILL BE CHANGED TO',,B\n         SYSQS 1,0,'PO'            ASSUME PARTITIONED DATA SET\n         TM    DSNWAF2,DSNFPDS     IS IT A PDS\n         BO    CHTYPE1             BR YES\n         SYSQS 1,0,'PS'            NO, SET FOR SEQUENTIAL\nCHTYPE1  TSEG  (1),(0),B           PUT IN PS OR PO\n         TM    CPLRCL+3,FALLBT     IS IT EDIT OR FIXED SAVE\n         BNZ   CHTYPE2             BR IF FIXED\n         TSEG  'U/'                SET RECFM=U\n         LR    R15,R3              SET R15 TO LRECL\n         B     CHTYPE3             GO FINISH\n         SPACE\nCHTYPE2  TSEG  'FB/'               SET FIXED PART\n         L     R15,CPLRCL          GET LRECL\nCHTYPE3  BTD   CPDOUB,0,(15)       DO LRECL\n         TSEG  (1),(0)             PUT IN BUFFER\n         TSEG  '/'                 PUT IN /\n         BTD   CPDOUB,0,(R3)       DO BLKSIZE\n         TSEG  (1),(0),M           PUT IN BUFFER AND MARK\n         SYSQS 1,0,'OK'            SET PROMPT\n         CVCALL YESREQ             GO SEE IF OK TO CHANGE\n         OI    DSNWAF3,DSNFCHT     YES, SET CHANGE FLAG\n         MVC   CPDOUB(8),CPDRED     RESTORE KEY\n         B     ROPENN              DO OPEN AGAIN\n         SPACE 3\nSAVERB   TSEG  'BLOCKSIZE'\n         B     CVUNLEG\n         EJECT\nWORKX    XENTER 2,8,C32+SZR+C32         REG & WORK SPACE\n         LM    R2,R6,CPLRCL             SET ALL REGS\n         LTR   R2,R2                    EDIT?\n         BZ    DOEDIT                   YES\n         AR    R6,R2                    UPDATE CHAR COUNT\n         LA    R1,C32(R8)               WORK AREA ADDR\n         TM    CPSEQFLD,FNEGBT         IS SEQ # AT END\n         BO    GUNPRSS                 YES\n         AH    R1,CPSEQLN              NO, LEAVE ROOM FOR SEQ #\nGUNPRSS  CVCALL UNPRESS                  UNPRESS\n         TM    CPLFLG5,CPFUNUM          NUMBERED SAVE?\n         BNZ   GOONNOW                  NO\n         L     R0,CPLCNO                LINE NO. INTO R0\n         CVCALL CVEXNO                  CONVERT TO EXTERNAL\n         TM    CPSEQFLD,FNEGBT         IS SEQ # AT END\n         BO    GUNPR2                  YES\n         LH    R14,CPSEQFLD            GET SEQ FLD START\n         SH    R14,=H'2'               SUBTRACT FOR EX COUNT\n         BM    GUNPR1                  BEGINNING IF NEGATIVE\n         LA    R15,C32(,R8)            POINT TO\n         AH    R15,CPSEQLN                  TEXT TO MOVE\n         EX    R14,MVCPMVC             MVC C32(0,R8),9(R15)\nGUNPR1   LA    R15,C32+1(R14,R8)       POINT TO LINENO POSITION\n         B     GUNPR3\n         SPACE\nGUNPR2   LA    R15,C32(R2,R8)\n         SH    R15,CPSEQLN             POINT TO LINENO POSITION\nGUNPR3   LH    R14,CPSEQLN             GET SEQFLD LENGTH\n         SR    R0,R14                  ADJUST EXTERNAL\n         AR    R1,R0                          POINTER FOR LENGTH\n         BCTR  R14,R0                  SET LENGTH FOR EX\n         EX    R14,MOVSV3              MVC 0(0,R15),0(R1)\nGOONNOW  CR    R6,R4                    BUFFER FULL?\n         BNH   PUTMOR                   NO\n         DWRITE ,                       WRITE IT\n         BZ    WRITOK                   WRITE OK\n         BP    WORKXEOV            BR IF NO MORE SPACE\n         XCALL WDSKER                   DISK WRITE ERROR MESSAGE\nWRITOK   L     R5,CPDRED                RESET BUFFER ADDR TO START\n         LR    R6,R2                    RESET COUNT\nPUTMOR   EX    R3,MOVSV1                MVC   0(0,R5),C32(R8)\n         AR    R5,R2                    UPDATE BUFFER PTR\n         B     SCRAM\n         SPACE 3\n* DOING EDIT FORMAT SAVE\n         SPACE\nDOEDIT   IC    2,4(15)        PICK PREST COUNT\n         LA    6,5(2,6)       TOTAL COUNT FOR LINE PLUS PREVIOUS\n         CR    6,4            6 GTR 4 - TOO MUCH - FIRST OUTPUT BUFFER\n         BNH   STOW           ALL OK - STOW AWAY\n         L     5,CPDRED       EXTERNAL I/O BUF ADDR\n         L     6,CPNWCT       SET WITH COUNT FOR OUTPUT REC\n         STH   6,0(5)         STORE TOTAL BYTE COUNT\n         MVC   C32(SZR,8),0(15)   SAVE LOCATED LINE\n         DWRITE ,             OUT\n         BZ    NDSKERH        B IF DISK I/O OK\n         BP    WORKXEOV            BR IF NO MORE SPACE\n         XCALL WDSKER         GO DO MESSAGE ON DISK WRITE ERROR\nNDSKERH  LA    5,2(5)         POINT 2 BYTES INTO BUFFER\n         LA    6,7(2)         SET COUNT THRU FIRST LINE NEXT BUFFER\n         LA    15,C32(8)     POINT AT SAVED LINE IMAGE\nSTOW     LA    2,4(2)         PREST COUNT PLUS 4 FOR MOVE\n         EX    2,MOVSV2       MOVE IT\n         LA    5,1(2,5)       KICK POINTER\nSCRAM    STM   5,6,CPNXAD     STORE\n         XEXIT 2,8            RETURN\n         SPACE 3\n* EOV ENCOUNTERED DURING SAVE BECAUSE NO MORE SPACE IN THE\n*     DATA SET.  THIS IS NORMALLY ONLY DURING A PDS SAVE WHEN\n*     THE SPACE IS PRE-ALLOCATED.  DWRITE CLOSES THE DATA SET\n*     BEFORE RETURNING SO DCLOSE NEED NOT BE CALLED HERE.\n* SINCE THIS CONDITION IS ENCOUNTERED FROM A ROUTINE CALLED\n*     BY DESPOT, WE MUST RESTORE TWO LEVELS IN THE SAVE AREA\n*     STACK.  IN THIS CASE, SAVE IS AT THE FIRST LEVEL SO WE\n*     DON'T HAVE TO GO THROUGH TWO LEVELS OF XEXIT WITH RETUR\n*     ADDRESSES GLITCHED.\n         SPACE\nWORKXEOV LA    R8,CPDSNWA+DSAVSIZ  RESET SA STACK TO BEGINNING\n         LR    R13,R8\n         L     R2,=A(GOSAVELA)     GET ADDR OF ENTRY\n         EX    0,0(R2)        USE LA AT ENTRY TO RESTORE R13\n         L     R14,=A(EOV)         RETURN TO EOV ROUTINE IN SAVE\n         L     R7,=A(SAVEBASE)     RESTORE SAVE BASE REG\n         BR    R14       THE HELL WITH THE REST OF THE REGS\n         EJECT\n* THIS ROUTINE IS CALLED BY DOPEN IN PDIO IF THE SAVE IS\n* SEQUENTIAL.  THE SIZE OF THE SAVE IS CALCULATED BY RUNNING\n* THROUGH THE RANGE SPECIFIED.  HOWEVER, IF THE SAVE IS FIXED\n* BLOCKED AND NO PARTIAL RANGE WAS GIVEN, THEN THE LINE COUNT\n* IS KNOWN AND NO PASS THROUGH THE RANGE IS REQUIRED.\n*\n* ON ENTRY R15 HAS THE ACTUAL BLOCKSIZE OF THE SAVE\n         SPACE\nGETSIZE  DS    0H\n         XENTER 2,8,*\n         TM    DSNWAF3,DSNFLIN     WAS RANGE GIVEN\n         BO    GETSIZE1            YES, MUST RUN THROUGH RNAGE\n         TM    CPLRCL+3,FALLBT     IS IT FIXED SAVE\n         BZ    GETSIZE1            NO, MUST RUN THROUGH RANGE\n         LH    R15,CPLNCT          ASSUME ACTIVE FILE RANGE\n         TM    CPLFLG5,CPFSELOC    WAS IT ACTIVE OR EXEC\n         BZ    *+8                 BRANCH IF ACTIVE\n         LH    R15,CPEXLNCT        GET EXEC FILE LINE COUNT\n         STH   R15,DSAVCNT         SET LINE COUNT FOR SAVE\n         B     GETSIZEX            RETURN TO PDIO\n         SPACE\n* A RUN THROUGH THE RANGE IS MADE TO DETERMINE SIZE OF SAVE\nGETSIZE1 SR    R2,R2               INITIALIZE\n         STH   R2,DSAVCNT             SIZE OF SAVE TO\n         STH   R2,DSAVBLK             NOTHING\n         LA    R2,2                SET COUNT BYTES USED\n         ST    R2,DSAVSPA\n         ST    R15,CPNWCT          SAVE BLOCKSIZE OF SAVE\n         L     R15,WORKCTAD        GET ADDRESS OF COUNT ROUTINE\n         TM    CPLFLG5,CPFSELOC    IS IT ACTIVE OR EXEC RANGE\n         BZ    *+8                 BRANCH IF ACTIVE\n         O     R15,=AL1(LEXATRTN,0,0,0) SET FOR EXEC RANGE\n         OI    CPLFLG5,CPFNCUR     SET NOT TO CHANGE CURRENT\n         CVCALL DESPOT             RUN THRU RANGE TO GET SIZE\n         LH    R15,DSAVBLK\n         LA    R15,1(,R15)\n         STH   R15,DSAVBLK\n         LH    R15,DSAVCNT         GET FINAL LINE COUNT\nGETSIZEX XEXIT 2,8,LTR             RETURN\n         SPACE 3\n* DESPOT WORK ROUTINE TO COUNT LINES IN SAVE, BYTES IN EDIT\n* SAVE, AND MAXIMUM LENGTH EDIT LINE\nWORKCT   DS    0H\n         SENTER 6,8\n         LH    R6,DSAVCNT\n         LA    R6,1(,R6)\n         STH   R6,DSAVCNT\n         SR    R6,R6               ZERO FOR IC\n         IC    R6,4(,R15)          GET SIZE OF LINE\n         LA    R1,5(,R6)           SET R1 TO TRUE BYTE COUNT\n         A     R1,DSAVSPA          ADD IN COUNT SO FAR\n         C     R1,CPNWCT           STILL MORE ROOM IN BUFFER\n         BNH   WORKCTX             YES, GO ON\n         LA    R1,7(,R6)           NO, SET R1 TO NEW COUNT + HEAD\n         LH    R6,DSAVBLK\n         LA    R6,1(,R6)\n         STH   R6,DSAVBLK\nWORKCTX  ST    R1,DSAVSPA          SAVE NEW BYTE COUNT\n         SEXIT 6,8                 EXIT\n         TITLE 'GOREN ROUTINE'\nGOREN    DENTER SDSNDSZ\nRENAME   NI    SDSNQUB+18,X'00'   CLEAR TO ADD NOVER\n         CVCALL DODSNM             GET FIRST DSNAME\n         MVC   DSNWAF3(2),SDSNQUB+18  MOVE IN FLAGS\nRENT     TM    DSNWAF3,X'06'      ADD OR TO\n         BM    RENC               OK\n         BZ    CVABSENT           NO TO OR ADD\n         B     CVNVALID\n         SPACE\nRENC     TM    CPLFLG3,CPFSET      SET SPEC\n         BZ    RENDSN             NO\n         CVCALL SETPFXNS\nRENDSN   MVC   SDSNQLB(68),DSNWADSN     SAVE DSNAME  AND FLAGS\n         SCANRSTR  ,\n         CLI   DSNWAMBR,C' '      IS MEMBER SPEC\n         BNE   RENPSN             YES, PDS\n         NI    CPLFLG3,X'7F'      CLEAR SET\n         CVCALL DODSNM             GET REST OF DATA\n         MVC   DSNWAF3(2),SDSNQUB+18   UPDATE FLAGS\n         CLI   DSNWAMBR,C' '         IS MEMBER SPEC\n         BNE   RENR1                 YES, ERROR\nRENSET   TM    CPLFLG3,CPFSET     IS SET SPEC\n         BZ    RENV1              NO\n         CVCALL SETPFXNS\nRENV1    TM    DSNWAF3,X'01'         NOVER SPEC\n         BNO   RENV3                 NO,ASK USER\n         BAL   R14,NOVER             CHECK PRIV\nRENV3    TM    DSNWAF1,DSNFMYDS      BELONG TO USER\n         BO    REN55                 YES\n         BAL   R14,NOTMYDS           NO,CHECK\nREN55    CLI   DSNWAVOL,C' '         IS VOL SPEC\n         BE    REN5                  NO\n         MVC   SDSNQUB+8(6),DSNWAVOL MOVE VOL INTO 1ST\nREN5     XC    DSNWADSN(68),SDSNQLB  SWAP BOTH FIELDS\n         XC    SDSNQLB(68),DSNWADSN  DITTO\n         XC    DSNWADSN(68),SDSNQLB    \"\n         TM    DSNWAF3,X'01'         NOVER SPEC\n         BNO   RENV5                 NO,CHECK DSN & PRIV\n         BAL   R14,NOVER             CHECK PRIV\nRENV5    TM    DSNWAF1,DSNFMYDS      BELONG TO USER\n         BO    RENV66                YES\n         BAL   R14,NOTMYDS           NO,CHECK\nRENV66   CVCALL VOLCHEK               CHECK FOR VOLUME\nRENV6    CLI   DSNWAMBR,C' '         PDS PROCESS\n         BNE   REOPEN                YES\n         TM    DSNWAF3,X'02'         IS THIS ADD\n         BO    RENR2                 YES, ERROR\n         CLI   DSNWAVOL,C'C'         IS IT CAT\n         BNE   REOPEN                NO\n         OI    DSNWAF1,X'02'         SET UNCAT FLAG\nREOPEN   MVI   DSNWAF2,X'82'         SET FOR RENAME AND SAVE\n         L     14,CVDOPEN\n         BALR  14,14\n         LTR   15,15                 ERRORS\n         BZ    WTMSGR                WRITE RESULTS\n         CH    R15,=Y(RTNDUPDS)      CHECK FOR DSN OR MEMB\n         BNE   RNTG                  NO\n         TM    DSNWAF2,DSNFPDS       PDS USED\n         BNO   EXSQ                  PDS NOT USED\n         TSEG  'MEMBER',,B\n         MVC   DSNWAMBR(8),SDSNQUB   MOVE MEMBER\n         XCALL MEMBERED              TSEG MEMBER\nEXSQ2    TSEG  'ALREADY EXISTS',,B\n         B     CVQTYPE\nEXSQ     DS    0H\n         MVC   DSNWADSN(61),SDSNQLB   MOVE IN CAT DSN\n         XCALL DSNAMED\n         B     EXSQ2\nRNTG     PCALL NTGDOPN            GO TO ERROR ROUTINE\n         SPACE\nRENPSN   SCAN  RENMBR\n         B     CVABSENT           NO MEMBER\n         SPACE\nWTMSGR   CLI   DSNWAMBR,X'FF'      DIRECTORY\n         BNE   WTMSGP             YES\n         XCALL DSNAMED\n         TSEG  'ON',,B\n         LA    1,DSNWAVOL         VOLUME\n         LA    0,6\n         TSEG  (1),(0),B\n         TM    DSNWAF1,X'03'      UNCAT,NOT UNCAT\n         BO    WRM1               NOT UNCAT\n         BZ    WRM2               NOT CALLED\n         TSEG  'UNCATLG''D',,B\n         B     WRM2\nWRM1     TSEG  'NOT UNCATLG''D',,B\nWRM2     TSEG  'RENAMED',,B\n         MVC   DSNWADSN(61),SDSNQLB   MOVE IN DSN  AND LENGTH\n         XCALL DSNAMED\n         TM    SDSNQUB+16,X'06'       ANY CAT CMDS\n         BZ    GETCOM                 NO\n         NI    SDSNQUB+16,X'0F'       CLEAR UPPER NIBBLE\n         CLI   SDSNQUB+16,X'06'       RECAT\n         BNE   WRM3                   NO\n         TSEG  'RECATLG''D',,B\n         B     GETCOM\n         SPACE\nWRM3     TM    SDSNQUB+16,X'0C'       NOT CAT,CAT\n         BZ    WRM6                   NEITHER\n         BM    WRM5                   CAT\n         TSEG  'NOT CATLG''D',,B\n         B     CVQTYPE\n         SPACE\nWRM5     TSEG  'CATLG''D'\n         B     GETCOM\n         SPACE\nWRM6     TM    SDSNQUB+16,X'03'       NOT UNCAT,UNCAT\n         BM    WRM7                   UNCAT\n         TSEG  'NOT UNCATLG''D',,B\n         B     CVQTYPE\n         SPACE\nWRM7     TSEG  'UNCATLG''D',,B\n         B     GETCOM\n         SPACE\nWTMSGP   TM    DSNWAF3,X'02'          ALIAS\n         BO    WTMSGA                 YES\n         TSEG  'MEMBER',,B\n         XCALL MEMBERED\n         TSEG  'IN',,B\n         XCALL DSNAMED\n         TSEG  'RENAMED TO',,B\n         MVC   DSNWAMBR(8),SDSNQUB    MOVE IN MEMBER\n         XCALL MEMBERED\n         B     GETCOM\n         SPACE\nWTMSGA   TSEG  'ALIAS',,B\n         XC    DSNWAMBR(8),SDSNQUB     SWAP MEMBERS\n         XC    SDSNQUB(8),DSNWAMBR\n         XC    DSNWAMBR(8),SDSNQUB\n         XCALL MEMBERED\n         TSEG  'FOR MEMBER',,B\n         MVC   DSNWAMBR(8),SDSNQUB     MOVE BACK MEMBER\n         XCALL MEMBERED\n         TSEG  'ADDED TO',,B\n         XCALL DSNAMED\n         B     GETCOM\n         SPACE\nMBRF     LR    R5,R0              SAVE LENGTH\n         CLI   0(R1),C'#'         IS FIRST CHAR #\n         BNE   MBRF1              NO\n         LA    R4,1(R1)           MOVE POINTER\n         SH    R5,=H'1'           DEC LENGTH\n         TSEG  '#: IGNORED',,W\n         LR    R1,R4\nMBRF1    CH    R5,=H'8'           LENGTH >8\n         BH    CVNVALID           YES\n         MVI   DSNWAMBR,X'40'     CLR MEMBER\n         MVC   DSNWAMBR+1(7),DSNWAMBR\n         BCTR  R5,0               DEC FOR EX\n         EX    R5,MVEMBR          MOVE INTO DSNWA\n         SCAN  RENDS2\n         B     RENV1              RETURN TO MAIN STREAM\n         SPACE\nMVEMBR   MVC   DSNWAMBR(0),0(R1)\n         SPACE\nRENMBR   SCKW  ,MBRF\nRENDS2   SCKW  ON,RON,P\n         SCKW  NOVERIFY,NOVAR,A\n         SCKW  ,INVALID\n         SPACE\nRON      CH    R0,=Y(6)           LENGTH >6\n         BH    CVNVALID           YES\n         MVC   DSNWAVOL(6),0(15)  MOVE INTO DSNWA\n         BR    R14\n         SPACE\nNOVAR    OI    DSNWAF3,X'01'      SET NOV\n         BR    R14\n         SPACE\nRENR1    TSEG  'SECOND DSNAME INVALID',,B\n         B     CVQTYPE\n         SPACE\nRENR2    TSEG  'MEMBER NOT SPECIFIED',,B\n         B     CVQTYPE\n         TITLE 'GOSCRT ROUTINE'\nGOSCRT   DENTER DSSIZ\nSCRTBASE CVCALL DODSNM         GO GET THEM\n         SCAN  SCRSCAN             SCAN FOR OTHER STUFF\n         CVCALL VOLCHEK                  MAKE SURE VOL SPECIFIED\n         TM    CPLFLG3,CPFSET      TEST \"SET SPECIFIED\n         BZ    GOSCRT2             BR IF NO\n         CVCALL SETPFXNS            GO DO SET\nGOSCRT2  TM    DSNWAF1,DSNFMYDS        BELONG TO USER?\n         BO    SCRTOK              YES - PROCEED\n         BAL   R14,NOTMYDS         GO SEE IF OK TO SCRATCH\nSCRTOK   DSCRATCH ,                GO SCRATCH IT\n         LR    R2,R15              SAVE RETURN CODE\n         LR    R3,R0               SAVE SECOND RETURN CODE\n         LH    R0,RTBWC            SEE IF ANYTHING TO WRITE\n         LTR   R0,R0\n         BZ    SCRTOK2             BRANCH NO\n         TWRITE ,                  WRITE OUT LINE\nSCRTOK2  LR    R0,R3               RESTORE SECOND RETURN CODE\n         LTR   R15,R2              RESTORE AND TEST RETURN\n         BZ    SCRDONE             GOOD OPEN\n         CH    R15,=Y(C12)         TEST UNCATLG ERROR\n         BE    SCRDONE             BR IF YES\n         CH    R15,=Y(RTNBDMBR)    WAS IT MEMBER ERROR\n         BNE   SCRBAD              NO, GO GIVE ERROR MESSAGE\n         TM    DSNWAMBR,X'BF'      WAS MEMBER SPECIFIED\n         BNE   SCRBAD              YES, GO GIVE ERROR MESSAGE\n         TSEG  'MEMBER NOT SPECIFIED',,W\n         TSEG  'OK TO SCRATCH',,BLANK\n         CVCALL DSNAMED            PUT DSNAME IN MESSAGE\n         SYSQS 1,0,'PDS'           SET POSITIVE PROMPT PART\n         XCALL YESREQ              GO PROMPT USER\n         MVI   DSNWAMBR,X'FF'      SET FLAG FOR DSCRATCH\n         B     SCRTOK              GO DO SCRATCH\n         SPACE\nSCRBAD   PCALL NTGDOPN                 PROCESS ERROR\n         SPACE\nSCRDONE  TM    DSNWAF2,DSNFPDS     WAS IT A PDS MEMBER SCR?\n         BNZ   SCRMDONE            BR IF YES\n         XCALL CHKMBRIG            CHECK MEMBER IGNORED\n         CVCALL DSNAMED             GO TSEG DSNAME\n         TSEG  'SCRATCHED',,B\n         TM    CPLFLG3,CPFUNCLG    WAS UNCATLG ATTEMPTED?\n         BZ    GOSCVOL             BR IF NO\n         LTR   R2,R2               WAS IT SUCCESSFUL?\n         BNZ   GOSCNOUC            BR IF NO\n         TSEG  'AND',,B\n         B     GOSCUC\n         SPACE\nGOSCNOUC TSEG  'BUT NOT',,B\nGOSCUC   TSEG  'UNCATLG''D',,B\nGOSCVOL  TSEG  'ON',,B\n         TSEG  DSNWAVOL,6          TSEG VOL SER NO\n         B     GETCOM\n         SPACE 3\n* MEMBER SCRATCHED SUCCESSFULLY\n         SPACE\nSCRMDONE TSEG  'MEMBER',,B\n         XCALL MEMBERED            GO TSEG MEMBER NAME\n         TSEG  'SCRATCHED FROM',,B\n         CVCALL DSNAMED             GO TSEG DSNAME\nGETCOM   BALR   R14,0\n         USING *,R14\n         B     CVGETCOM            EXIT\n         DROP  R14\n         SPACE 3\nSCRPDS   TM    DSNWAMBR,X'BF'      TEST IF MEMBER SPECIFIED\n         BM    SCRPDSIG            BR YES TO IGNORE PDS OPERAND\n         MVI   DSNWAMBR,X'FF'      SO INDICATE\n         BR    R14\n         SPACE\nSCRPDSIG LR    R2,R14              SAVE RETURN ADDRESS\n         TSEG  'MEMBER SPECIFIED, PDS IGNORED',,W\n         BR    R2                  RETURN\n         SPACE\nSETUNC   OI    CPLFLG3,CPFUNCLG\n         BR    R14\n         SPACE 3\n* THE FOLLOWING CODE ALLOWS A USER WITH SYSTEM PRIVILEGES\n* TO SCRATCH, CATALOG, OR UNCATALOG A DATA SET WITHOUT THE\n* MSG--XXX NOT YOURS. OK?--- COMING OUT. HE DOES THIS BY\n* SAYING SCR CUCC.X NOVER\n         SPACE\nNOVER    TM    JCBAFL,JCBSYSPR     SYS PRIV?\n         BNOR  R14\n         OI    DSNWAF1,DSNFMYDS\n         BR    R14\n         SPACE\nVER      TM    JCBAFL,JCBSYSPR     SYS PRIV?\n         BNOR  R14\n         NI    DSNWAF1,255-DSNFMYDS\n         BR    R14\n         SPACE 3\nSETEXPDT OI    DSNWAF3,DSNFEXP     SET EXPIRATION DATE OVERRIDE\n         TM    JCBAFL,JCBSYSPR     SYS PRIV?\n         BNO   CVNVALID            NO, CANN'T USE OPTION\n         BR    R14                 SCAN ON\n         TITLE 'ROUTINE TO TEST FOR PRIV USER FOR SCR/UNCAT'\n* ALLOW TO SCRATCH SYSMSG, CB AND AC DATA SETS\n         SPACE\nNOTMYDS  SENTER R14,R8,C44\n         AIF   ('&DCEC' EQ '1').LBL04                           JEP00X\n         LA    R2,DSNWADSN+7       USER ID LOC IN SYSMSG DSN\n         CLC   =C'SYSMSG.',DSNWADSN     IS IT SYSMSG?\n         BE    CHKID               BR IF YES - GO CHECK ID\n         LA    R2,DSNWADSN+3       USER ID LOC IN CB DSN\n         CLC   =C'AC.',DSNWADSN    IS IT AC?\n         BE    CHKID\n         CLC   =C'CB.',DSNWADSN    IS IT CB?\n         BNE   NOTMYDS2            BR IF NO\nCHKID    CLC   CPUSER(5),0(R2)     IS IT FOR THIS USER?\n         AGO   .LBL05                                           JEP00X\n.LBL04   DS    0H                                               JEP00X\n         XR    R1,R1               ZERO OUT R1                  JEP001\n         IC    R1,CVUSRFLD         PICK UP LEN OF ID            JEP001\n         BCTR  R1,0                DOWN 1 FOR EXECUTE           JEP001\n         LA    R2,DSNWADSN         PICK UP USER ID              JEP001\nCHKID    CLC   CPUSERSV(0),0(R2)   IS IT THIS USER?             JEP001\n         EX    R1,*-6              EXECUTE ABOVE COMPARE        JEP001\n.LBL05   DS    0H                                               JEP00X\n         BE    SCRALL              BR IF YES - OK TO SCRATCH\nNOTMYDS2 CVCALL DSNAMED            PUT OUT DSNAME\n         TSEG  'NOT YOURS',,W\n         TM    JCBAFL,JCBSYSPR     SYS PRIV?\n         BZ    CVQTYPE             BR IF NO\n         SYSQS 1,0,'OK'            SET PROMPT PART\n         XCALL YESREQ              GO CHECK IF OK\nSCRALL   OI    DSNWAF1,DSNFMYDS    INDICATE SCR IS OK\n         SEXIT R14,R8,FOOP\n         TITLE 'SCKWS AND REMOTE MVCS'\n* FOR SCRATCH\n         SPACE\nSCRSCAN  SCKW  UNCATLG,SETUNC,A\n         SCKW  PDS,SCRPDS\n         SCKW  NOVERIFY,NOVER,A\n         SCKW  VERIFY,VER,A\n         SCKW  EXPDT,SETEXPDT,A\n         SCKW  ,IGDSNPRT,PUSH\n         SCKW  ,INVALID\n         SPACE 3\n* FOR SAVE\n         SPACE\nMOVSV1   MVC   0(0,5),C32(8)\nMOVSV2   MVC   0(0,5),0(15)\nMOVSV3   MVC   0(0,R15),0(R1)\nMVCPMVC  MVC   C32(0,R8),0(R15)\n         SPACE\n         DS    0F\nWORKXD   DC    AL1(DESRTRN+LOCATRTN+DESMATCH+PREST),AL3(WORKX)\nWORKCTAD DC    AL1(DESRTRN+LOCATRTN+DESMATCH+PREST),AL3(WORKCT)\n         TITLE 'LITERALS'\n         LTORG ,\n         TITLE 'GOUSE ROUTINE'\n* GOUSE IS ENTERED FROM PRIMARY SCAN ON USE -\n* USE IS PROCESSED HERE - ERRORS CALL EXTERNAL RTNS\n* PRIMARY SCAN ONLY REACHES HERE AT START OF JOB - OR AFTER CLEAR\n         SPACE\nGOUSE    DENTER DSSIZ,SZR\n         MVC   CPCMNM(3),=C'USE'   SET TO'USE'IN CASE IT IS'U'\n         OI    CPLFLG3,CPFSET      SET IS DEFAULT ON USE\n         MVC   CPSEQFLD(4),=H'-1,8'    INITIALIZE SEQFLDS\n         CVCALL DODSNM         GET DSNAME (AND MAYBE VOLUME)\n         XCALL FMTCHK R0=0,EDIT - RO=POS,LRECL - R0=NEG,NOT SPEC\n         LR    5,0            SAVE IN R5\n         LA    4,1(1)         SAVE SKIP COUNT\n         BAL   R14,CLEARCK              CLEAR, IF POSSIBLE\n         BAL   R14,VOLCHEK              MAKE SURE VOL SPECIFIED\n         TM    CPLFLG3,CPFSET      TEST \"SET SPECIFIED\n         BZ    USEOPEN             BR IF NOT\n         CVCALL SETPFXNS            DO SET PREFIX AS SUBROUTINE\n*        TM    DSNWAF1,DSNFMYDS    DOES IT BELONG TO USER\n*        BO    USEOPEN             BRANCH YES\n*        L     R14,=A(NOTMYDS)\n*        BALR  R14,R14\nUSEOPEN  OI    CPSYSFLG,CPFRNGCM+CPFNTYPD+CPFTUSXC\n         DOPEN (R5),,USE           OPEN DATA SET\n         BZ    OPNISGD        GOOD OPEN\n         PCALL NTGDOPN        GO DO OPEN ERROR MESSAGE\n         SPACE 3\n* GOOD OPEN -- SET CPGFLG FOR NO RECOVERY, IGNORE DIRECTORY\n*              CHANGES IN STOWIT AND EXTERNAL DATA SET OPEN\n         SPACE\nOPNISGD  OI    CPGFLG,CPFOPN\n         ST    1,CPDRED       SAVE START INPUT BUFFER\n         LTR   R5,R5               TEST FORMAT SPECIFIED\n         BNM   *+6                 BR IF YES\n         LR    R5,R0               LRECL PLUGGED IN BY DOPEN\n         XCALL CHKMBRIG            CHECK MEMBER IGNORED\n         TM    CPLFLG5,CPFUNUM     TEST UNNUMBERED\n         BO    NXREDE              BR IF YES\n         OI    CPSEQLN,FNEGBT   TURN ON FLAG TO DETERMINE POINT\n         LTR   R5,R5               TEST FORMAT\n         BNZ   NXREDE                  OKAY IF NOT EDIT\n         DCLOSE ,                      CLOSE FILE\n         NI    CPGFLG,255-CPFOPN  SET EXTERNAL DATA SET CLOSED\n         TSEG  'NUMBERED'\n         CVCALL UNLEGAL                                          *\n         EJECT\nNXREDE   TM    JCBAFL,JCBAFIA          TEST FOR IDLE ATTN\n         BZ    NXREDE2                 NO, READ NEXT RECORD\n         DCLOSE ,                      CLOSE DATA SET\n         NI    CPGFLG,255-CPFOPN       SET DATA SET CLOSED\n         TSEG  'ABORTED -- USE INCOMPLETE'\n         OI    CPGFLG,CPFDIRCH         SET DIRECTORY CHANGED\n         B     CVQTYPE\n         SPACE\nNXREDE2  DREAD (0)                     READ NEXT RECORD\n         BP    EOFNOW         FINI\n         BZ    NDSKERI        B IF DISK I/O OK\n         XCALL RDSKER         GO DO MESSAGE ON DISK READ ERROR\nNDSKERI  L     6,CPDRED       ADDR 1ST BYTE OF INPUT THIS READ\n         LTR   2,5            FORMAT CODE (0-ED, 80-CD, 132-PR)\n         BNZ   NOTEDT         NOT EDIT\n         LR    15,6           ADDR INPUT BUFFER\n         LH    3,0(15)        BYTE COUNT IN BUFFER\n         LTR   3,3            TEST FOR GOOD COUNT HALF-WORD\n         BNP   NOGGODY\n         CR    3,0            MAKE SURE COUNT MAKES SENSE\n         BH    NOGGODY\n         LA    15,2(15)       POINT AT 1ST LINE\n         AR    R3,R6                   SET ENDING ADDRESS\n         SR    R2,R2\nICAGEN   IC    2,4(15)        GET NEXT PREST-COUNT\n         CH    R2,=AL2(SZR)       PREST COUNT TOO LARGE?\n         BH    NOGGODY        YEP .... REJECT\n         CLC   0(4,R15),CPHIPS          HIGHEST?\n         BH    GOODY                    YES\n         CLC   CPAGCT(2),=D'0'          ANYTHING YET?\n         BNE   NOGGODY                  YES, NG\nGOODY    LA    15,5(,15)      SKIP LINE # AND LINE SIZE\n         LTR   R2,R2          NULL LINE?\n         BZ    NULLLINE\nPRESSCHK IC    R1,0(R15)      GET PRESSED BYTE INFO\n         LA    R14,15         MASK OF X'0F'\n         NR    R14,R1         NONBLANK CHAR COUNT\n         SRL   R1,4           BLANK COUNT IN R1\n         SR    R2,R14         DECREMENT LINE SIZE\n         BM    NOGGODY        TSK TSK .. BAD EDIT FORMAT\n         LA    R15,1(R14,R15)      SKIP TO NEXT PRESSED BYTE\n         BCT   R2,PRESSCHK         KEEP UNPRESSING\nNULLLINE CR    R15,R3                  SEE IF MORE IN RECORD\n         BL    ICAGEN\n         BH    NOGGODY\n         LA    6,2(6)         POINT OVER COUNT IN RECORD\nDONEXE   IC    2,4(6)         PREST COUNT TO R2\n         LR    1,6            CURRENT INPUT POINTER\n         LR    0,2            COUNT FOR STOW\n         BCT   R4,EUSESKP              SKIP IF CALLED FOR\n         LA    R4,1                    RESET FOR DROP THRU\n         CVCALL STOWIT         STOW IT AWAY\nEUSESKP  LA    6,5(6,2)       KICK POINTER\n         CR    R6,R3                   AT END OF THIS RECORD YET\n         BL    DONEXE         NO - DO NEXT\n         B     NXREDE         READ NEXT RECORD\n         EJECT\nNOTEDT   AR    0,6            ADDRESS 1ST BYTE PAST INPUT\n         ST    0,CPNWCT       STORE IT\n         LTR   R5,R5               TEST FIXED OR VARIABLE\n         BP    NOTIDT              BR IF FIXED\n         SR    R0,R6               RESTORE ORIG LENGTH\n         CH    R0,0(R6)            VALIDATE BLOCK LENGTH\n         BNE   INVARDS             INVALID BLOCK LENGTH\n         LA    R6,4(R6)            BUMP PAST BLOCK COUNT\nNOTIDT   LTR   R2,R5               TEST FIXED OR VARIABLE\n         BP    NOTIDT2             BR IF FIXED\n         L     R0,CPNWCT           ADDR OF END OF BLOCK\n         SR    R0,R6               REMAINING LENGTH\n         BZ    NXREDE              BR IF AT END OF BLOCK\n         BM    INVARDS             BR IF AN ERROR\n         MVC   CPHFWRD,0(R6)       MOVE RECORD LENGTH\n         LH    R2,CPHFWRD          LOAD IT\n         CR    R2,R0     IS REC LONGER THAN REMAINING IN BLOCK?\n         BH    INVARDS             BR IF YES\nNOTIDT2  LA    R3,0(R2,R6)         ADDR OF NEXT RECORD\n         C     R3,CPNWCT           CHECK FOR END OF BLOCK\n         BH    NXREDE              BR IF YES\n         LTR   R5,R5               TEST FIXED/VARIABLE\n         BP    NOTVAR              BR IF FIXED\n         LA    R6,4(R6)            PAST RECORD LENGTH FIELD\n         SH    R2,*-2              DECR LENGTH TO ACTUAL DATA\n         BM    INVARDS             INVALID VAR REC IF NEG\n         BZ    USESKP              NULL RECORD IF ZERO\nNOTVAR   CH    R2,=Y(MXPRTSZ)      CHECK OVER MAXIMUM\n         BNH   *+8                 OK\n         LH    R2,=Y(MXPRTSZ)      USE MAXIMUM\n         BCT   4,USESKP       SKIP IF CALLED FOR\n         LA    4,1            RESET FOR DROP THRU\n         TM    CPLFLG5,CPFUNUM NUMBERED USE?\n         BZ    DOUSNMB        YES\n         L     0,CPHIPS       GET LAST-TIME HIGHEST POSITION\n         L     1,CPGLDL       ADD TO IT DELTA\n         CVCALL ADDER          ADD THEM\n         BM    USERRB         NEED A SMALLER DELTA\n         LR    R15,R0                   LINE NO.\nCUTTIN2  LR    R1,R8                    PTR TO WORK AREA\n         EX    2,USEMVC       MOVE TO WORK AREA FOR PRESS\n         LR    0,2            MAX COUNT FOR PRESS\nUSEPRS   CVCALL PRESS          PRESS IT\n         CVCALL STOWIT         STOW IT AWAY\nUSESKP   LR    6,3            RESET POINTER FOR NEXT LINE\n         B     NOTIDT         GO GET NEXT CARD OR LINE\n         EJECT\nDOUSNMB  TM    CPSEQLN,FNEGBT   NEED TO DETERMINE POINT/NOPOINT\n         BE    DOUSNM3                 NO\n         NI    CPSEQLN,255-FNEGBT      TURN OFF FLAG\n         LH    R15,CPSEQLN             GET COUNT\n         NI    CPLFLG5,255-CPFINT      ASSUME DECIMAL POINT\n         TM    CPSEQFLD,FNEGBT         TEST SEQFLD AT END\n         BE    DOUSNM2                 NO\n         LA    R1,0(R2,R6)             POINT TO\n         SR    R1,R15                          SEQFLD\n         B     DOUSNM1                 GO LOOK FOR DECIMAL PNT\n         SPACE\nDOUSNM2  LH    R1,CPSEQFLD             POINT\n         BCTR  R1,0                         TO\n         AR    R1,R6                          SEQFLD\nDOUSNM1  CLI   0(R1),C'.'              DECIMAL POINT IN SEQFLD\n         BE    DOUSNM3                 YES, GO ON\n         LA    R1,1(,R1)               POINT TO NEXT POSITION\n         BCT   R15,DOUSNM1             LOOP TILL DONE\n         OI    CPLFLG5,CPFINT          SET NO DECIMAL POINT\nDOUSNM3  LH    R0,CPSEQLN              GET SEQFLD LENGTH\n         TM    CPSEQFLD,FNEGBT         SEQ FLD AT END\n         BO    DOUSNMB1                YES\n         LH    R1,CPSEQFLD             GET SEQFLD POSITION\n         BCTR  R1,0                    SET MACHINE POSITION\n         LR    R15,R0                  CHECK\n         AR    R15,R1                     SEQFLD\n         CR    R2,R15                        IN RECORD\n         BL    USERRC                  NO\n         AR    R1,R6                   POINT TO SEQFLD POSITION\n         B     CUTTIN1                 GO SCAN\n         SPACE\nDOUSNMB1 CH    R2,CPSEQLN              CHECK SEQFLD IN RECORD\n         BL    USERRC                  NO\n         LA    R1,0(R2,R6)             POINT TO\n         SR    R1,R0                         SEQFLD POSITION\nCUTTIN1  SCINIT (1),(0)                 SCAN INIT\n         LA    R1,USNMPRT              ASSUME DECIMAL LINENOS\n         TM    CPLFLG5,CPFINT          IS IT NOPOINT\n         BE    DOUSNMBA                NO, DECIMAL CORRECT\n         LA    R1,USNMPRT2             SET FOR NO DECIMAL POINT\nDOUSNMBA SCAN  (1)                     SCAN SEQ FLD\n         B     USERRC                  NOTHING FOUND\n         SPACE\nHVUSNMB1 CL    R15,=F'99999999'        TEST MAX VALUE\n         BH    USERRC                  ERROR IF HIGH\nHVUSNMB  C     R15,CPHIPS               LEGAL LINE NO?\n         BNH   USERRC                  NO\n         SH    R2,CPSEQLN              SET RECORD SIZE\n         TM    CPSEQFLD,FNEGBT         SEQFLD AT END\n         BO    CUTTIN2                 YES DONE\n         LH    R1,CPSEQFLD             GET SEQFLD POSITION\n         BCTR  R1,0                    SET FOR MACHINE POSITION\n         LA    R1,0(R6,R1)             SET R1 TO SEQFLD START\n         LR    R14,R1                  SET R14 TO TEXT\n         AH    R14,CPSEQLN                  AFTER SEQFLD\n         LR    R0,R2               SAVE R2\n         SH    R2,CPSEQFLD         LENGTH - POSIT OF SEQ FLD\n         BM    *+8                 BR IF REALLY IS AT END\n         EX    R2,USEMVC2              MVC 0(0,R1),0(R14)\n         LR    R2,R0               RELOAD R2\n         B     CUTTIN2\n         SPACE\nUSERRC   TSEG  'USE OPTION ERROR,',,BLANK\n         B     GOCLRNW\n         SPACE 3\nEOFNOW   DCLOSE ,             CLOSE FILE\n         NI    CPGFLG,255-CPFOPN  SET EXTERNAL DATA SET CLOSED\nOTHOUT   OI    CPGFLG,CPFDIRCH         SET DIR CHNGED FOR RCVY\n         B     CVGETCOM            EXIT\n         SPACE 3\nUSERRB   DCLOSE ,             CLOSE FILE\n         NI    CPGFLG,255-CPFOPN  SET EXTERNAL DATA SET CLOSED\n         TSEG  'DELTA TOO BIG, USE ABORTED',,B\n         B     OTHOUT                   GO SEE IF OTHER PARTITION WANTS\n         SPACE\nNOGGODY  TSEG  'INVALID EDIT FORMAT BLOCK,',,B\nGOCLRNW  DCLOSE  ,                 CLOSE FILE\n         NI    CPGFLG,255-CPFOPN   SET EXTERNAL DATA SET CLOSED\n         TSEG  'USE INCOMPLETE'\n         B      CVQTYPE\n         SPACE\nINVARDS  TSEG  'INVALID VARIABLE LENGTH BLOCK,',,B\n         B     GOCLRNW\n         TITLE 'CLEAR ROUTINE FOR FETCH - USE'\nCLEARCK  XENTER R7,R8,*\n         CLC   CPAGCT(2),=D'0'         ARE THERE ANY PAGES\n         BE    FIXCLR2                 NO\n         TM    CPLFLG2,CPFCLEAR    WAS \"CLEAR\" SPECIFIED?\n         BO    FIXCLR              BR IF YES\n         TSEG  'OK TO',,B          SET FIRST PART OF PROMPT\n         SYSQS 1,0,'CLEAR'         SET POSITIVE PART OF PROMPT\n         BAL   R14,YESREQ          GO PROMPT USER FOR PERMISSION\nFIXCLR   CVCALL DOCLEAR                  CLEAR\nFIXCLR2  MVI   CPLSTCOL,FNEGBT   SET FOR FIRST COLLECT\n         MVI   CPCURRL,X'F0'       SET CURRENT LINE POINTER INV\n         XEXIT R7,R8                    USE-FETCH NOW OK\n         TITLE 'PROMPT FOR YES PROCESSOR'\n* YESREQ PROCESSES VARIOUS PROMPT REQUESTS FOR THE USER\n* IF THE USER RESPONDS WITH 'YES', 'OK', OR THREE OR MORE\n* CHARACTERS OF THE PROMPT PASSED IN R0 AND R1, THEN IT\n* IS CONSIDERED TO BE A POSITIVE RESPONSE AND CONTROL IS\n* RETURNED TO THE CALLER.  ANY OTHER RESPONSE CAUSES A\n* REQUEST ABORTED MESSAGE BY CALLING THE NOT GOOD OPEN ROUTINE\n* WITH THE ABORT CODE.\n         SPACE\nYESREQ   XENTER 5,8,*              DEFINE ENTRY\n         LR    R6,R13              MAKE POINTER TO MOVED PROMPT\n         LTR   R5,R0               SAVE PROMPT LENGTH & TEST\n         BNP   YESREAD             GO READ IF NO MOVE NEEDED\n         EX    R5,YESMVC           MOVE PROMPT TO WORK AREA\n         LA    R13,4(R5,R13)       RESET R13\n         N     R13,=F'-4'          INSURE WORK BOUNDARY\nYESREAD  TREADR (1),(0)            GO PROMPT USER\n         SCINIT (1),(0)\n         SCAN  YESRQPRT            SCAN FOR YES, OK OR OTHER\nYESABORT LA    R15,ABRTCODE        SET ABORT CODE\n         PCALL NTGDOPN             GO ABORT REQUEST\n         SPACE\n* COMPARE RETURN TO PROMPTED TEXT TO SEE IF POSITIVE RESPONSE\nYESTEST  CR    R0,R5               TEST LENGTHS\n         BH    YESABORT            TO LONG -- ABORT IT\n         BE    YESCOMP             EQUAL -- GO COMPARE\n         LR    R5,R0               SMALLER -- USE SMALLER VALUE\n         CH    R5,=H'3'            IS IT AT LEAST THREE\n         BL    YESABORT            NO, ABORT REQUEST\nYESCOMP  BCTR  R5,0                SET LENGTH FOR CLC\n         EX    R5,YESCLC           DO COMPARE\n         BNE   YESABORT            NOT EQUAL -- ABORT REQUEST\nYESDO    XEXIT R5,R8               POSITIVE REPLY -- RETURN\n         SPACE\nYESCLC   CLC   0(0,R1),0(R6)       EXECUTED CLC INSTRUCTION\nYESMVC   MVC   0(0,R6),0(R1)       EXECUTED MVC INSTRUCTION\n         SPACE\nYESRQPRT SCKW  YES,YESDO\n         SCKW  OK,YESDO\n         SCKW  ,YESTEST\n         TITLE 'DSNAME MESSAGE ROUTINE (DSNAMED)'\n* ROUTINE TO TSEG DSNAME WITH TRAILING BLANK\n*     FORMAT OF TSEG DEPENDS ON SETTING OF TERSE FLAG\n         SPACE\nDSNAMED  XENTER 2,8,*\n         LA    R3,DSNWADSN         ADDR OF DSNAME\n         LH    R2,DSNWANL          LENGTH OF DSNAME\n         LTR   R2,R2               TEST LENGTH ZERO\n         BZ    DSNOTWYL            BR IF SO\n         TM    CPGFLG,CPFCMOFF     TEST TERSE\n         BZ    DSREDY              BR IF NOT\n* TERSE\n         TM    DSNWAF1,DSNFQDSN    IS IT QUOTED DSNAME?\n         BO    DSNOTWYL            BR IF YES\n         TM    DSNWAF1,DSNFSTD     IS IT A STD WYL DSN?\n         BZ    DSNOTWYL            BR IF NOT\n         AIF   ('&USPS' EQ '1').XLBL03                          USPS01\n         CLC   CPGRPSV,DSNXG+DSNWADSN   IS IT DEFAULT GROUP?\n         BE    DSSMGRP             BR IF YES\n         TSEG  '@'\n         SYSQS R1,R0,DSNXG+DSNWADSN,DSNXGL\n         CLC   CPGRP,0(R1)         IS IT SIGNED ON GROUP?\n         BNE   DSOGRP              BR IF NO\n         LA    R1,DSNXGL-1(R1)     BUMP TO \".\"\n         SH    R0,*-2              AND ADJUST LENGTH\nDSOGRP   TSEG  (1),(0)\n.XLBL03   DS   0H                                               USPS01\n         AIF   ('&USPS' NE '1').XLBL04                          USPS01\nDSSMGRP  EQU   *                                                JEP001\n         SR    R4,R4               CLEAR                        JEP001\n         IC    R4,CVUSRFLD         PICK UP ID LENGTH            JEP001\n         BCTR  R4,0                DOWN FOR COMPARES            JEP001\n         CLC   CPUSERSV(0),DSNWADSN   DEFAULT ID???             JEP001\n         EX    R4,*-6              EXEC ABOVE INST              JEP001\n         BE    DSSMUSER            SAME USER                    JEP001\n         TSEG  '&&'                PUT OUT DEFAULT USED         JEP001\n         LR    R1,R3               POINT TO DSN WORK AREA       JEP001\n         LR    R0,R4               PICK UP ID LEN               JEP001\n         LA    R0,1(R0)            MAKE REAL LENGTH             JEP001\n         CLC   CPUSER(0),0(R1)   FIND OUT IF LOGON ID           JEP001\n         EX    R4,*-6              SAME AS LOGON????            JEP001\n         BNE   DSOUSER             NOPE, SEND ID                JEP001\n         LA    R1,0(R4)            BUMP PAST ID                 JEP001\n         SR    R0,R4               ADJUST LENGTH                JEP001\nDSOUSER  TSEG  (1),(0)             SEND IT                      JEP001\nDSSMUSER LA    R4,1(R4)            BUMP PAST PERIOD             JEP001\n         LA    R4,1(R4)            ONE TAKEN FOR COMPARE        JEP001\n         AR    R3,R4               PAST ID OR DEFAULT           JEP001\n         SH    R2,R4               CORRECT LENGTH               JEP001\n         B     DSREDY              SET UP DONE .... PUT DSN     JEP001\n         AGO   .XLBL05                                          USPS01\n.XLBL04   DS   0H                                               USPS01\nDSSMGRP  CLC   CPUSERSV,DSNXU+DSNWADSN  DEFAULT ID?\n         BE    DSSMUSER            BR IF SAME USER ID\n         TSEG  '&&'\n         SYSQS R1,R0,DSNXU+DSNWADSN,DSNXUL\n         CLC   CPUSER,0(R1)        IS IT SIGNED ON USER?\n         BNE   DSOUSER             BR IF NO\n         LA    R1,DSNXUL-1(R1)\n         SH    R0,*-2              AND ADJUST LENGTH\nDSOUSER  TSEG  (1),(0)\nDSSMUSER LA    R3,DSNXN+DSNWADSN    PAST JUNK\n         SH    R2,=Y(DSNXN)        ADJUST LENGTH\n         B     DSREDY\n         SPACE\n.XLBL05   DS   0H                                               USPS01\nDSNOTWYL TSEG  '$'\n         B     DSREDY\n         SPACE 3\n* ROUTINE TO TSEG VARIABLE LENGTH MEMBER WITH TRAILING BLANK\n         SPACE\nMEMBERED XENTER R2,R8,*\n         LA    R3,DSNWAMBR         GET MEMBER ADDR\n         LR    R2,R3\n         LA    R15,8               MAX SIZE OF MEMBER\nMEMBEDLP CLI   0(R2),X'40'         IS CHAR BLANK?\n         BE    MEMBEDHL            BR IF YES - END OF NAME\n         LA    R2,1(R2)            ONWARDS\n         BCT   R15,MEMBEDLP        UNLESS OUT OF THE END\nMEMBEDHL SR    R2,R3               GET LENGTH\n         SPACE\n         DROP  R7\n         SPACE\n* EXIT FROM DSNAMED/MEMBERED - NO ADDRESSABILITY ON R7\nDSREDY   TSEG  (R3),(R2),B\n         LR    R1,R3\n         LR    R0,R2\n         XEXIT 2,8            RTRN\n         TITLE 'CATLG FUNCTION MESSAGE ROUTINE (CTLGED)'\n* ROUTINE TO TSEG THE CATLG FUNCTION WHICH WAS CALLED.\n         SPACE\nCTLGED   XENTER R2,R8,*\n         TM    CPLFLG3,CPFRECLG    TEST VALID BITS\n         BZ    CTLGEDC             BR IF NOT\n         BM    CTLGEDM             BR IF NOT RECATLG\n         TSEG  'RE'\n         B     CTLGEDC             GO TO COMMON STUFF\n         SPACE\nCTLGEDM  TM    CPLFLG3,CPFUNCLG    TEST UNCATLG\n         BZ    CTLGEDC\n         TSEG  'UN'\nCTLGEDC  TSEG  'CATLG''D',,B\nCTLGEDX  XEXIT R2,R8\n         TITLE 'MOVE IN DEFAULT VOL OR GET VOL RTN'\n* 1 - VOL ALREADY GIVEN?  RETURN\n* 2 - VOL NOT GIVEN, DEFAULT EXISTS?  SET DEFAULT\n* 3 - VOL NOT GIVEN, NO DEFAULT?  GET VOL FROM USER\n* 4 - IF VOL=\"CATLG\" SET FLAG\n         SPACE\nVOLCHEK  LA    R1,CPDSNWA\nVOLCHKNL SENTER 14,8,C44      ENTRY IN CASE R1 ALREADY LOADED\n         CLI   DSNWAVOL,C' '       SET?\n         BNE   VOLCKCAT            YES\n         LTR   R1,R1               MANDATORY PROMPT?\n         BNP   VOLPRMT             BR IF YES\n         TM    CPGFLG,CPFVOLM           DEFAULT?\n         BZ    VLNODFLT                 NO\n         MVC   DSNWAVOL(6),CPVOLSV  MOVE IN DEFAULT\nVOLCKCAT SCINIT DSNWAVOL,6         SCAN VOLUME NAME\n         SCAN  CATLGPRT            FOR 'CATLG' AND ABBREV\nCATLGMVC MVC   DSNWAVOL,=C'CATLG '    SET CATLG IN VOL NAME\n         OI    CPLFLG1,CPFUSCAT    SET FLAG TO USE CATALOG\nVOLEXIT  MVC   CPDOUB(8),CPDRED\n         SEXIT 14,8,*                   SCRAM\n         SPACE\nVLNODFLT TM    DSNWAF1,DSNFWLIB    IS IT A WYLBUR LIB?\n         BO    CATLGMVC            BR IF YES - USE CATLG\nVOLPRMT  TREADR 'VOLUME'\n         BP    CVQTYPE             ABORT IF ATTENTION\n         SCINIT (1),(0)\n         SCAN  VOLPRT\n         B     CVABSENT\n         SPACE\nVOLGOT   CH    R0,=Y(6)                 TOO LONG?\n         BH    CVNVALID                 YES\n         MVC   DSNWAVOL(6),0(R15)     SET IT\n         SCAN  VOLPRT2             SCAN FOR \"SET\"\n         B     VOLCKCAT\n         SPACE\nVOLSET   MVC   CPVOLSV,DSNWAVOL       SAVE VOLUME SPECIFIED\n         OI    CPGFLG,CPFVOLM      INDICATE DEFAULT VOLUME SET\n         B     VOLCKCAT\n         TITLE 'INFORM USER IF SPECIFIED MEMBER WAS NOT NEEDED'\nCHKMBRIG SENTER R14,R8,C44\n         TM    DSNWAF2,DSNFPDS     WAS PDS ACCESSED?\n         BO    CHKMIX              EXIT IF SO\n         TM    DSNWAMBR,X'BF'      WAS A MEMBER SPECIFIED?\n         BNM   CHKMIX              BR IF NOT OR IF X'FF'\n         XCALL MEMBERED            GO TSEG MEMBER NAME\n         TSEG  'IGNORED',,W\nCHKMIX   SEXIT R14,R8,*\n         TITLE 'SCKW''S'\n* FOR USE\n         SPACE\nUSNMPRT  SCKW  ,HVUSNMB,LN\n         SCKW  ,USERRC\n         SPACE\nUSNMPRT2 SCKW  ,HVUSNMB1,PI\n         SCKW  ,USERRC\n         SPACE 3\n* FOR VOLUME CHECK\n         SPACE\nVOLPRT   SCKW  ,VOLGOT\nVOLPRT2  SCKW  SET,VOLSET\n         SCKW  ,VOLCKCAT\nCATLGPRT SCKW  CATLG,CATLGMVC,A\n         SCKW  ,VOLEXIT\n         TITLE 'UTILITY ROUTINES - REMOTE MVC''S'\n* FOR USE\n         SPACE\nUSEMVC   MVC   0(0,1),0(6)\nUSEMVC2  MVC   0(0,R1),0(R14)\n         TITLE 'LITERALS'\n         LTORG ,\n         TITLE 'UTILITY ROUTINES'\nNOMORPG  GENTER ,NO                PCALL ENTRY FOR OUT OF PAGES\n         PCALL NOMORPG\n         SPACE 3\nADDBUF   BTD   CPDOUB,0,(15)           CONVERT TO DECIMAL\n         TSEG  (1),(0),B               ADD TO BUFFER\n         BR    R6                      RETURN\n         EJECT\n* TPROT ROUTINE IN CVCALLED TO DISPLAY PROTECTION BITS\n* WHILE DOING A SHO DSNAMES.\n         SPACE\nTPROTF   XENTER R5,R8,*\n         USING SDSNBUF,R4\n         TM    SBPROTF,X'01'           DOES THIS DSCB HAVE IT?\n         BO    *+8\n         MVI   SBPROTF,X'20'           OTHERWISE DEFAULT\n         TM    SBPROTF,X'03'           DPO?\n         BNO   TPNODPO\n         TSEG  'DPO/'\nTPNODPO  LA    R0,12\n         IC    R1,SBPROTF              GET THE BYTE\n         LR    R5,R1\n         SRL   R1,4\n         SRL   R5,2\n         NR    R5,R0\n         NR    R1,R0\n         TM    DSNWAF1,DSNFSTD         STANDARD WYL DSN?\n         BO    TPUSERDS\n         CLC   =C'AC.',SBDSN           ACDS STUFF\n         BE    TPUSERDS\n         CLC   =C'SYSMSG.',SBDSN       OS SYSMSG?\n         BE    TPUSERDS\n         LA    R1,16(,R1)\n         LA    R5,16(,R5)              ADD 16 MORE FOR SYS DSN\nTPUSERDS LA    R1,4(,R1)\n         LA    R5,4(,R5)\n         CR    R1,R5\n         BNE   *+6\n         LNR   R5,R5\n         BAL   R6,GETPROT\n         LTR   R5,R5\n         BM    TPROTEX\n         TSEG  '/'\n         LR    R1,R5\n         BAL   R6,GETPROT\nTPROTEX  XEXIT R5,R8,*\n         SPACE\nGETPROT  B     *(R1)\n         B     TPPUBLIC\n         B     TPGROUP\n         B     TPUSER\n         B     TPBLOCK\n         B     TPPUBLIC\n         B     TPCLASS3\n         B     TPCLASS2\n         SYSQS 1,0,'CLASS-1'\nTPTSEG   TSEG  (1),(0)\n         BR    R6\nTPPUBLIC SYSQS 1,0,'PUBLIC'\n         B     TPTSEG\nTPGROUP  SYSQS 1,0,'GROUP'\n         B     TPTSEG\nTPUSER   SYSQS 1,0,'USER'\n         B     TPTSEG\nTPBLOCK  SYSQS 1,0,'BLOCK'\n         B     TPTSEG\nTPCLASS2 TM    SBPROTF,X'01'         WAS IT SPECIFIED OR DEFLT\n         BZ    TPCLASS3              IF DEFLT ASSUME CLASS 3.\n         SYSQS 1,0,'CLASS-2'\n         B     TPTSEG\nTPCLASS3 SYSQS 1,0,'CLASS-3'\n         B     TPTSEG\n         AIF   ('&USPS' NE '1').XLBL06                          USPS01\n         LTORG                                                  USPS01\n.XLBL06   DS   0H                                               USPS01\n         TITLE 'CONSTANTS, ETC.'\n         COPY  WYLCONST\n         EJECT\n         COPY  RTNCODES\n         TITLE 'COPY MODS'\nSDSNBUF  DSECT\n         COPY  SDSNBUF\n         SPACE 3\n         COPY  SCATBUF\n         EJECT\n         COMMON\n         SPACE\n         END\n./ ADD NAME=PGOP,SSI=00000002\nPGOP     TITLE 'START OF PAGED CODE -- PAGE 7'\n* PROPERTY OF C. U. C. C. A.\n         SPACE  3\n         GBLC    &DCEC             SWITCH FOR DCEC MODS         JEP00X\n&DCEC    SETC   '1'  CHANGE TO ANY OTHER NUM. TO DELETE DCEC MODJEP00X\n         AIF   ('&DCEC' NE '1').LBL01                           JEP00X\n*  JERRY PITTENGER DEF COMM ENG CTR                             JEP003\n*                                                               JEP003\n*                                                               JEP003\n* MOD  JEP003                                                   JEP003\n*  FIX BUG IN ALTERS COMMAND.  DENOTED  JEP003 IN 66/71.        JEP003\n*  MODULES AFFECTED: PDOS, PGOP                                 JEP003\n*                                                               JEP004\n*                                                               JEP004\n* MOD JEP004                                                    JEP004\n*  MODIFIED CODE FOR VERIFYING PHYSICAL TABS TO PREVENT MESSED UJEP004\n*  3277 SCREEN DISPLAY.                                         JEP004\n*  MODULES AFFECTED: INIT, WTR, PGOP, PDOS, MACRO(CPTSO)        JEP004\n*                                                               JEP004\n*                                                               JEP004\n.LBL01   DS    0H                                               JEP00X\nP007     PAGECDE  MODGO\n         WIDENT 001\n         USING CPAREA,R12\n         TITLE 'MODIFY/EDIT COMMAND PROCESSOR -- PAGE 7'\n* REGISTER USAGE FOR MODIFY/EDIT\n         SPACE\nPR       EQU   5                       BUFFER POINTER REG\nRR       EQU   4\nTR       EQU   3\nSR       EQU   2\n         SPACE\n         USING WA,8\n         SPACE 3\nPMODGO   GENTER ,\n         TM    CPGFLG,CPFRETRY     IS RETRY GOING ON\n         BO    PROCESS             YES NO OTHER STUFF\n         OI    CPLFLG1,CPFALL          ALLOW DEFAULT ALL\n         CVCALL DETRNG                 SCAN THE RANGE\n         CLI   CPCMNM,C'E'         IS IT EDIT COMMAND\n         BE    SCANPRM             YES GO LOOK AT PARMS\n         OI    CPLFLG2,CPFMODCD    SET MODIFY COMMAND FLAG\nSCANPRM  SCAN  MODPRT              SCAN FOR PARAMETERS\n         TM    CPLFLG5,CPFUNUM     TEST IF UNNUMBERED\n         BZ    CHKNTEX             NO, CHECK OTHER OPTIONS\n         OI    CPLFLG5,CPFNONUM    MAKE IT NONUMBERED\n         B     MODSPOT             CONTINUE NORMALLY\nCHKNTEX  TM    CPLFLG5,CPFNONUM    CAN IT POSSIBLY BE NOTEXT\n         BNM   MODSPOT             NO, ALLOW WHATEVER OPTION\n         NI    CPLFLG5,255-CPFNONUM NO, MAKE NOTEXT BE NOLIST\n         OI    CPLFLG5,CPFNLST     AND SET NOLIST IF NOTEXT\nMODSPOT  L     15,ROUTINE          LOAD ROUTINE ADDRESS\n         CVCALL DESPOT             GO DO COMMAND\n         SPACE 3\nMODPRT   SCKW  SINGLE,SCNSIN,A\n         SCKW  S,SCNSIN\nMODPRT1  SCKW  ,,PUSH         FILLED IN AT INIT TO LTNPRT\n         SCKW  ,BADMOD\n         SPACE 3\nSCNSIN   OI    CPLFLG2,CPFSING     SET SINGLE PROMPT FLAG\n         BR    14                  SCAN ON\n         SPACE 3\n* ENTRY FROM DESPOT\n         SPACE\nPROCESS  DS    0H\n         XENTER 2,8,WASIZE\n         TM    CPGFLG,CPFRETRY         IS RETRY GOING ON?\n         BZ    NORMAL                  NO\n         LA    R1,CPCMSAV              POINT TO SAVED COMMAND\n         AIF   ('&DCEC' NE '1').LBLX1                           JEP003\n         LH    R0,CPCTSAV         COUNT OF COMMAND              JEP003\n         LTR   R0,R0              NORMAL COMMAND???             JEP003\n         BNZ   PROCESS1           NO....MESSED UP COUNT IS THEREJEP003\n         L     R0,CPCTSAV         COUNT OF COMMAND  ON NORMAL   JEP003\nPROCESS1 EQU   *                                                JEP003\n         AGO   .LBLX2                                           JEP003\n.LBLX1   DS    0H                                               JEP003\n         L     R0,CPCTSAV              COUNT OF COMMAND\n.LBLX2   DS    0H                                               JEP003\n         NI    CPLFLG2,255-CPFSING     SET NOT SINGLE\n         OI    CPLFLG2,CPFMODCD        SET MODIFY COMMAND\n         OI    CPLFLG5,CPFNONUM        SET NONUMBERED\n         NI    CPLFLG5,255-CPFNLST     CLEAR NOLIST FLAG\n         C     R0,=F'133'              IS IT LONG ENUF?\n         BH    ABNORMAL             NO, CANNOT MODIFY\n         LTR   TR,R0\n         BZ    FILLALL\n         BCTR  TR,0\n         EX    TR,TRGOOD            SEE IF GOOD CHARS???\n         BNZ   ABNORMAL             TOO BAD...\n         C     R0,=F'133'\n         BE    NORMAL\nFILLALL  LR    TR,R1                START\n         AR    TR,R0                   POINT TO END\n         MVI   0(TR),C' '              MOVE IN A BLNK\n         LA    SR,1(,TR)               1 PLACE RIGHT\n         L     R14,=F'133'             TOTAL LEN\n         SR    R14,R0                  LEN TO BLANK OUT\n         EX    R14,DEL                 GO PROPAGATE BLNK\nNORMAL   LR    PR,1                    SAVE BUFFER POINTER\n         ST    0,LEN                   SAVE LENGTH\n         CVCALL LISTLINE           LIST OUT THE LINE\n         MVC   AFL,CPLFLG2         SET FLAG FOR FIRST TIME\n         EJECT\n* ALTER OR EDIT LOOP\n         SPACE\nALTER    TM    AFL,CPFMODCD        EDIT OR MODIFY\n         BO    ALTER1              BRANCH IF MODIFY\n         SYSQS 1,0,'   EDITS'      SET PROMPT\n         BAL   RR,MODEDRD          GO READ IN LINE\n         LTR   R0,R0               ANYTHING TO DO\n         BNH   ENDALT              NO GO END THIS LINE\n         LR    SR,PR               SET SR TO START OF LINE\n         CLI   0(1),C' '           CONTROL CHAR FIRST\n         BE    EDITSTRT            NO, GO START EDIT\n         OI    0(1),C' '           SET TO UPPER\n         CLI   0(1),C'L'           IS TI LIST\n         BNE   EDCHKNL             NO, CHECK IF NOLIST\n         NI    AFL,255-CPFNLST     TURN OFF NOLIST\n         B     EDITSTRT            GO START EDIT\n         SPACE\nEDCHKNL  CLI   0(1),C'N'           IS IT NOLIST\n         BNE   ILLCH               NO, ILLEGAL CHARACTER\n         OI    AFL,CPFNLST         SET NOLIST\n         B     EDITSTRT            GO START EDIT\n         SPACE\nEDITL    CLI   0(1),C' '           IS IT A BLANK CHAR\n         BE    EDITLE              YES, GO ON TO NEXT CHAR\n         CLI   0(1),C'|'           IS IT VERTICAL BAR\n         BNE   EDITM               NO, GO MOVE CHAR\n         CLI   0(SR),C' '          IS THERE CHAR TO BLANK\n         BE    EDITM               NO, GO MOVE VERTICAL BAR\n         MVI   0(1),C' '           BLANK OUT VERTICAL BAR\nEDITM    MVC   0(1,SR),0(R1)       MOVE CHAR TO EDITED LINE\nEDITLE   LA    SR,1(,SR)           STEP FORWARD IN EDITED LINE\nEDITSTRT LA    R1,1(,R1)           STEP FORWARD IN MASK LINE\n         BCT   R0,EDITL            LOOP UNTIL DONE\n         B     NOI                 GO END LINE\n         SPACE\nALTER1   SYSQS 1,0,'   ALTERS'     SET UP TO PROMPT FOR MOD LINE\n         BAL   RR,MODEDRD          GO GET NEXT LINE\n         LTR   0,0\n         BNP   ENDALT                  BR IF END\n         LA    SR,1                    SET COL. PTR\nBLS      CLI   0(1),C' '               SKIP LEADING BLANKS\n         BNE   NBL\nBLN      LA    SR,1(,SR)               NEXT COL.\n         LA    1,1(,1)\n         BCT   0,BLS\n         B     DO\n         SPACE\nNBL      ST    SR,LPTR                 SAVE COL.\n         ST    SR,UPTR\n         OI    0(1),X'40'              MAKE UPPER CASE\n         CLI   0(1),C'N'               NOTEXT?\n         BE    N                       BR IF SO\n         CLI   0(1),C'L'           LIST\n         BE    L                   YES\n         CLI   0(1),C'D'               DELETE?\n         BE    D                       BR IF SO\n         CLI   0(1),C'I'               INSERT?\n         BE    I                       BR IF SO\n         CLI   0(1),C'R'               REPLACE?\n         BE    R                       BR IF SO\n         CLI   0(1),C'B'               BLANK?\n         BE    B                       BR IF SO\n         SPACE\nILLCH    TSEG  (1),1\n         TSEG  ': ILLEGAL, RETYPE LINE',,M\n         B     ALTER\n         SPACE\nN        OI    AFL,CPFNLST             SET NOTEXT\n         B     BLN\n         SPACE\nL        NI    AFL,255-CPFNLST     TURN OFF NOLIST\n         B     BLN\n         SPACE\nB        LA    SR,0(SR,PR)             POINT TO\n         BCTR  SR,0                         TEXT\n         MVI   0(SR),C' '              BLANK IT OUT\n         L     SR,LPTR                 RESTORE COL.\n         B     BLN                     GO ON\n         SPACE\nD        OI    AFL,AFD                 SET DELETE\nDL       OI    0(1),X'40'              MAKE UPPER CASE\n         CLI   0(1),C'D'               DETERMINE DELETE RANGE\n         BE    DLL\n         CLI   0(1),C' '\n         BNE   DEND\nDLL      LA    SR,1(,SR)               NEXT COL.\n         LA    1,1(,1)\n         BCT   0,DL\nDEND     ST    SR,UPTR                 SAVE UPPER LIMIT\n         LTR   0,0\n         BNP   DO                      BR IF END OF LINE\n         OI    0(1),X'40'              MAKE UPPER CASE\n         CLI   0(1),C'I'               INSERT?\n         BE    I                       BR IF SO\n         CLI   0(1),C'R'               REPLACE?\n         BNE   ILLCH                   BR IF NOT\n         SPACE\nR        LA    1,1(,1)                 SKIP OVER R\n         BCT   0,*+8\n         B     DO                      BR IF NOTHING TO REPLACE\n         AR    SR,0                    ALLOW FOR EXTRA DELETE\n         ST    SR,UPTR\n         OI    AFL,AFD+AFI             SET DELETE AND REPLACE\n         B     IR\n         SPACE\nI        LA    1,1(,1)                 SKIP OVER I\n         BCT   0,*+8\n         B     DO                      BR IF NOTHING TO INSERT\n         OI    AFL,AFI                 SET INSERT\nIR       STM   0,1,ILEN                SAVE LOC AND LENGTH\n         EJECT\n*  PERFORM THE REQUESTED ALTERATION\n         SPACE\nDO       L     SR,LEN                  PAD LINE WITH BLANKS\n         LA    TR,133-2\n         SR    TR,SR\n         AR    SR,PR\n         MVI   0(SR),C' '\n         LTR   TR,TR\n         BM    *+8\n         EX    TR,PAD\n         TM    AFL,AFD                 DELETE?\n         BZ    NOD                     BR IF NOT\n         L     TR,UPTR                 LIMITS OF DELETE\n         L     SR,LPTR\n         LA    RR,133\n         SR    RR,TR\n         AR    SR,PR\n         BCTR  SR,0\n         AR    TR,PR\n         BCTR  TR,0\n         LTR   RR,RR\n         BM    *+8\n         EX    RR,DEL                  DO THE DELETE\n         LA    SR,133(PR)\n         L     RR,UPTR\n         S     RR,LPTR\n         SR    SR,RR                   COMPUTE ADDR\n         MVI   0(SR),C' '\n         BCTR  RR,0\n         LTR   RR,RR\n         BM    *+8\n         EX    RR,PAD\nNOD      TM    AFL,AFI                 INSERT?\n         BZ    NOI                     BR IF NOT\n         LM    0,1,ILEN                PICK UP INSERT PTR\n         LA    SR,132(PR)\n         LR    TR,0\nCHOP     CLI   0(SR),C' '              LAST N CHAR SHOULD BE BLANK\n         BE    *+8\n         OI    AFL,AFCHOP              NOTE IF NOT\n         BCTR  SR,0\n         BCT   TR,CHOP\n         LA    TR,132(PR)              SHIFT BUF TO RIGHT\n         L     RR,LPTR\n         AR    RR,PR\n         BCTR  RR,0\n         B     MC\n         SPACE\nMOVE     MVC   0(1,TR),0(SR)\n         BCTR  SR,0\n         BCTR  TR,0\nMC       CR    SR,RR\n         BNL   MOVE\n         LR    SR,0\n         BCTR  SR,0\n         EX    SR,INS                  DO THE INSERT\nNOI      LR    1,PR                    STRIP TRAILING BLANKS\n         LA    0,133\n         L     15,CPLCNO\n         TM    AFL,AFCHOP              CHOPPED?\n         BZ    NCHOP                   BR IF NOT\n         LA    0,134                    FORCE TRUNCATION MESSAGE\n         MVI   133(1),C'*'              NON-BLANK\nNCHOP    CVCALL LENCHK\n         ST    0,LEN\n         TM    AFL,CPFNLST             NOTEXT?\n         BO    TESTEND                 BR IF SO\n         CVCALL LISTLINE            LIST THE LINE\n         TM    AFL,CPFSING+AFATTNC      TEST ATTN FLAGS\n         BZ    ALTER                    B IF NOT @ATTN\n         SPACE 3\n* END OF ALTER SEQUENCE\n         SPACE\nENDALT   LR    1,PR                    PREST THE LINE\n         L     0,LEN\n         TM    CPGFLG,CPFRETRY     IS RETRY GOING ON?\n         BZ    NOTRETRY            NO, NORMAL RETURN\n         ST    R0,CPCTSAV          SAVE NEW COMMAND LENGTH\n         B     CVGETCOM            RETURN TO EXECUTE COMMAND\n         SPACE\nNOTRETRY L     15,CPLCNO\n         CVCALL PRESS\n         CVCALL STOWIT                  REPLACE THE LINE\n         TM    AFL,AFATTNC              TEST $-ATTN FLAG\n         BO    CVGETCOM                 STOP IF $-ATTN\n         XEXIT 2,8                     RETURN TO DESPOT\n         SPACE 3\nTESTEND  TM    AFL,CPFSING+AFATTNC      TEST ATTN FLAGS\n         BZ    ALTER                    B IF NOT @ATTN\n         B     ENDALT                   BR IF END\n         EJECT ,\n* READ IN LINE FROM TERMINAL FOR EDIT OR MODIFY\n         SPACE\nMODEDRD  SLR   RR,R10              MAKE RETURN RELATIVE\n         NI    AFL,CPFMODCD        RESET FLAGS FOR NEXT PASS\n         TM    CPLFLG5,CPFNLST     NOLIST OPTION DEFAULT\n         BNO   *+8                 BRANCH NO\n         OI    AFL,CPFNLST         SET NOLIST FOR THIS PASS\n         TM    CPLFLG2,CPFSING     SINGLE PROMPT DEFAULT\n         BE    *+8                 BRANCH NO\n         OI    AFL,CPFSING         SET SINGLE PROMPT\n         L     R15,=X'005A5B7C'  ALLOW !, $ OR @ BEFORE ATTN\n         LCR   R15,R15             COMPLEMENT FOR ROUTINE\n         CVCALL TRDRTN             CALL READ ROUTINE\n         BZ    0(RR,R10)           RETURN IF NO ATTN\n         ALR   RR,R10              MAKE RETURN ABSOLUTE AGAIN\n         LTR   R0,R0               ANY CHARACTERS BEFORE ATTN\n         BZ    CVQTYPE             NO, ABORT THE COMMAND\n         BCT   R0,MODEDRD1         SUBTRACT 1 FOR ATTN CHAR\n         LA    RR,NOI              SET OTHER RETURN IF ONLY CHAR\nMODEDRD1 LR    SR,R0               POINT TO\n         LA    SR,0(SR,R1)              ATTN CHAR\n         CLI   0(SR),C'@'          IS IT @\n         BNE   TSTDOLL             NO\n         XI    AFL,CPFSING         YES, FLIP SINGLE PROMPT SW\n         BR    RR                  RETURN\n         SPACE\nTSTDOLL  CLI   0(SR),C'$'          IS IT $\n         BE    HAVDOLL             YES\n         XI    AFL,CPFMODCD        FLIP COMMAND TYPE SWITCH\n         NI    AFL,255-CPFSING     FORCE ANOTHER PROMPT LINE\n         BR    RR                  RETURN\n         SPACE\nHAVDOLL  OI    AFL,AFATTNC         SET $ ATTN FLAG\n         BR    RR                  RETURN\n         TITLE 'REMOTE INSTRUCTIONS -- PAGE 7'\n*\n* FOR MODIFY\n*\nPAD      MVC   1(0,SR),0(SR)\nINS      MVC   0(0,RR),0(1)\nDEL      MVC   0(0,SR),0(TR)\n         SPACE ,\nTRGOOD   TRT   0(0,R1),TRTAB\n         SPACE ,\nTRTAB    DC    X'FF',254X'00',X'FF'\n         SPACE ,\nABNORMAL TSEG  'COMMAND CANNOT BE RETRIED'\n         B     CVQTYPE\n         SPACE ,\nBADMOD   B     CVNVALID\nROUTINE  DS    0F\n         DC    AL1(DESNRTN+LOCATRTN+DESMATCH+UNPRST+DESRELA)\n         DC    AL3(PROCESS-P007)  RELATIVE ADDR FOR DESPOT\n         TITLE 'END OF PAGED CODE -- PAGE 7'\n         PINIT\n         MVC   MODPRT1+1(3),CVLTNPR+1  SET TO LTNPRT\n         PEND\n         TITLE 'START OF PAGED CODE -- PAGE 8'\nP008     PAGECDE GOCOLL,GOINS,GOREPL\n         WIDENT 001\n         TITLE 'GOCOLL ROUTINE -- PAGE 8'\nPGOCOLL  GENTER SZR\n         OI    CPLFLG4,CPFSTSPL+CPFSTINS   SET SO STOWIT WILL\n*              ONLY INSERT LINES AND WILL SPLIT PAGE AT LINENO\n         OI    CPLFLG5,CPFNLST     SET NOLIST DEFAULT\n         TM    CPLSTCOL,FNEGBT          USER'S FIRST COLLECT?\n         BZ    SCNAPRTC                 NO\nCOLLEND  L     R0,CPHIPS                HIGHEST LINE NO. YET\n         L     R1,CPGLDL                GLOBAL DELTA\n         CVCALL LOWMULT                 GET MULTIPLE\n         CVCALL ADDER                   ADD\n         STM   R0,R1,CPLSTCOL           SAVE NEXT LINE NO. & DELT\nSCNAPRTC LA    R6,GOTLNENO-P008    SET LINE NUMBER RETURN\n         LCR   R6,R6               SET NEGATIVE TO FLAG RELATIVE\n         SCAN  APRTC               SCAN FOR PARMS\n         TM    CPLFLG2,CPFCLEAR    WAS CLEAR SPECIFIED\n         BE    TRYOUT              BRANCH NO\n         L     R3,CPGLDL           SET DELTA TO USE\n         B     COLCLEAR            GO CLEAR\n         SPACE\nGOTLNENO STM   R0,R1,CPLSTCOL         SET NEW LINE NO. & DELTA\n         SR    R6,R6               FLAG HAVE LINE NUMBER\n         SCAN  BPRTC                    SCAN FOR DELTA\n         B     TRYCLR                   ALL SCANNED\n         SPACE\nGOTDLL   LTR   R15,R15                  ZERO NG\n         BZ    CVNVALID                 NG\n         ST    R15,CPDLTCOL             STORE COLLECT DELTA\n         SCAN  CPRTC               FINISH SCAN\nTRYCLR   TM    CPLFLG2,CPFCLEAR    WAS CLEAR SPECIFIED\n         BE    TRYOUT              BRANCH NO\n         LM    R2,R3,CPLSTCOL      SAVE COLLECT VALUES\nCOLCLEAR CVCALL DOCLEAR            GO CLEAR ACTIVE FILE\n         LTR   R6,R6               WAS A LINE NUMBER GIVEN\n         BZ    TRYCLR1             BRANCH YES\n         L     R2,CPGLDL           NO, SET START TO DELTA\nTRYCLR1  STM   R2,R3,CPLSTCOL      RESET COLLECT VALUES\nTRYOUT   MVC   CPNXPS(4),=F'100000000' SET COMPARAND TOO HIGH\n         TM    CPLSTCOL,FNEGBT          ILLEGAL LINE NO.?\n         BO    BADLINE                  YES\n         LA    R1,CPLSTCOL              1ST LINE NO. FOR LOCATE\n         CVCALL LOCATE                  LOCATE\n         TM    CPDRPT,CPFMTCH           MATCHING LINE NO.?\n         BO    GOTERCB                  YES\n         TM    CPDRPT,CPFNTYT+CPFHIGH   OK TO COLLECT TILL 9999.999\n         BNZ   DOLIST                   YES\n         MVC   CPNXPS(4),CPLCNO         SET COMPARAND TO NEXT LINE\nDOLIST   TM    CPLFLG5,CPFNLST     LIST LINE BEFORE COLLECT\n         BO    DONEXT              NO\n         LA    R1,CPLSTCOL         POINT TO LINE NO\n         CVCALL LOCLIST            GO LOCATE PRE AND FORMAT IT\n         BP    ENDCOLCT            IF ATTN END COLLECT.\nDONEXT   L     R0,CPLSTCOL              LINE NO. TO COLLECT\n         ST    R0,CPCURRL          SET CURRENT LINE\n         C     R0,CPNXPS                STILL SMALL ENOUGH?\n         BNL   GOTERC                   NO\n         CVCALL SETPRMPT           GO SET PROMPT\n         CVCALL TRDRTN             GO PROMPT AND READ\n         BP    ENDCOLCT            END COMMAND IF ATTENTION ONLY\n         MVC   0(133,R8),0(R1)          INTO WORK AREA\n         LR    R1,R8                    SET POINTER\n         L     R15,CPLSTCOL             LINE NO. INTO R15\n         CVCALL LENCHK                  CHECK LENGTH\n         CVCALL PRESS                   PRESS\n         CVCALL STOWIT                  STOW IT AWAY\n         L     R0,CPLSTCOL              LINE NO.\n         L     R1,CPDLTCOL              DELTA\n         CVCALL ADDER                   ADD\n         BM    GOTERD                   TOO BIG\n         ST    R0,CPLSTCOL              SAVE NEXT LINE NO.\n         B     DONEXT                   DO NEXT\n         SPACE\nENDCOLCT NI    JCBAFL,X'FF'-JCBAFIA CLEAR ATTN FLAG\n         B     CVGETCOM\n         EJECT\nGOTERC   BE    GOTERCA             NO REPLACE EVER\n         TM    CPLFLG2,CPFMERG     MERGE OPTION\n         BO    TRYOUT              YES, ALLOW INTERLEAVE\nGOTERCA  TSEG  'NO REPLACE',,B     SET FIRST PART OF MESSAGE\n         TM    CPLFLG2,CPFMERG     MERGE OPTION?\n         BO    CVQTYPE             YES, MESSAGE IS DONE\n         TSEG  'OR INTERLEAVE'     NO, SET REST OF MESSAGE\n         B     CVQTYPE\n         SPACE\nGOTERD   TSEG  '99999.999 EXCEEDED'\n         B     CVQTYPE\n         SPACE\nGOTERCB  TM    CPLFLG2,CPFMERG     MERG OPTION\n         BO    GOTERCA             YES, GIVE NO REPLACE MSG\n         B     BADLINEL            NO, GIVE BAD LINE MESSAGE\n         SPACE 3\n* FOR COLLECT\n         SPACE\nAPRTC    SCKW  ,,PUSH        FILLED IN AT INIT TO LNENOPRT\nBPRTC    SCKW  BY,GOTDLL,(P,LN)\nCPRTC    SCKW  MERGE,SCNMRGE,A\n         SCKW  NOMERGE,SCNNMRGE,A\nDPRTC    SCKW  ,,PUSH        FILLED IN AT INIT TO CLRPRT\nEPRTC    SCKW  ,,PUSH        FILLED IN AT INIT TO LTNPRT\n         SCKW  ,BADCOL\n         SPACE 3\nSCNMRGE  OI    CPLFLG2,CPFMERG     SET MERGE OPTION\n         BR    R14                 SCAN ON\n         SPACE\nSCNNMRGE NI    CPLFLG2,255-CPFMERG-CPFCOMB RESET MERGE OPTION\n         BR    R14\n         SPACE\nBADCOL   B     CVNVALID\n         TITLE 'GOINS ROUTINE -- PAGE 8'\nPGOINS   GENTER SZR+C80\n         OI    CPLFLG5,CPFNLST     SET NOLIST AS DEFAULT\n         SR    R4,R4                    ZERO COUNT\n         LA    R5,SZR(,R8)              SET PTR\n         LA    R6,GOTIT-P008       SET LINE NO RETURN ADDR\n         LCR   R6,R6               SET NEG TO FLAG RELATIVE ADDR\nINSCAN   SCAN  INSPRT                   SCAN FOR LINE NO.\n         LTR   R4,R4                    ANY LINES GIVEN?\n         BZ    CVABSENT                 NO\n         LA    R5,SZR(,R8)              SET PTR\nNXTPRMPT TM    CPLFLG5,CPFNLST     LIST OPTION\n         BO    NXTPRMP2            BRANCH NO\n         LR    R1,R5               POINT TO LINE NUMBER\n         CVCALL LOCLIST            GO LOCATE AND DO PREV LINE\nNXTPRMP2 L     R0,0(,R5)                LINE NO. INTO R0\n         ST    R0,CPCURRL          SET CURRENT LINE\n         CVCALL SETPRMPT           GO SET PROMPT\n         CVCALL TRDRTN             GO PROMPT AND READ\n         BP    CVQTYPE             ABORT IF ATTENTION\n         L     R15,0(,R5)               LINE NO. TO R15\n         MVC   0(133,R8),0(R1)          INTO WORK AREA\n         LR    R1,R8                    SET PTR R1\n         CVCALL LENCHK                  CHECK LENGTH\n         CVCALL PRESS                   PRESS LINE\n         STM   R0,R1,CPSAVE             SAVE\nNXTSTW   CVCALL STOWIT                  STORE THE LINE\n         BCT   R4,NUTHER1               ANOTHER?\n         B     CVGETCOM                 NO\n         SPACE\nNUTHER1  LA    R5,4(,R5)                KICK PTR\n         TM    CPLFLG2,CPFDITTO    DITTO OPTION\n         BE    NXTPRMPT            NO, GO PROMPT FOR NEXT INSERT\n         TM    CPLFLG5,CPFNLST     LIST OPTION\n         BO    NUTHER2             BRANCH NO\n         LR    R1,R5               POINT TO LINE NUMBER\n         CVCALL LOCLIST            GO LOCATE AND FORMAT PREV LINE\n         BNP   NUTHER2             BRANCH IF NO ATTENTION\n         LA    R4,1                SET COUNT TO STOP AFTER THIS\nNUTHER2  L     R0,0(,R5)           GET NEXT LINE NUMBER\n         ST    R0,0(,R8)           PUT IT IN THE LINE IMAGE\n         ST    R0,CPCURRL          UPDATE CURRENT LINE POINTER\n         LM    R0,R1,CPSAVE             RESET\n         B     NXTSTW                   STOW NEXT\n         SPACE 3\nGOTIT    CH    R4,=Y(20)                TOO MANY?\n         BH    CVNVALID                 YES\n         ST    R0,0(,R5)           SAVE LINE NUMBER\n         LR    R1,R5                    POINT TO LINE NO.\n         CVCALL LOCATE                  LOCATE IT\n         TM    CPDRPT,CPFMTCH           SAME NO. LOCATED?\n         BO    GOTBAD                   YES, ERROR (REPLACE)\n         LA    R5,4(,R5)                KICK PTR\n         LA    R4,1(,R4)                KICK COUNTER\n         B     INSCAN                   MORE?\n         SPACE\nGOTBAD   L     R0,0(,R5)           GET BAD LINE NUMBER\n         CVCALL CVEXNO             CONVERT IT\n         TSEG  (1),(0),B           PUT IN OUTPUT BUFFER\n         TSEG  'IN FILE, NO INSERT'\n         B     CVQTYPE\n         SPACE 3\n* SCAN TABLES FOR INSERT\n         SPACE\nINSPRT   SCKW  ,,PUSH        FILLED IN AT INIT TO LNENOPRT\n         SCKW  ,DITTPRT,PUSH\nINSPRT1  SCKW  ,,PUSH        FILLED IN AT INIT TO LTNPRT\n         SCKW  ,BADCOL\n         TITLE 'GOREPL ROUTINE -- PAGE 8'\nPGOREPL  GENTER SZR           ASSURE SPACE HERE FOR DOREPL\n         OI    CPLFLG1,CPFALL          ALLOW DEFAULT ALL\n         CVCALL DETRNG\n         OI    CPLFLG5,CPFNLST     SET NOLIST DEFAULT\n         SCAN  REPLPRT             SCAN FOR OTHER OPTIONS\n         L     15,VDOREPL     LOAD PROPERLY FLAGGED WORK ADDR FOR D\n         TM    CPLFLG5,CPFNLST     NOLIST OPTION?\n         BO    *+8                 YES, NO NEED TO UNPRESS\n         L     R15,VDOREPL1        SET UNPRST FOR FWORK ROUTINE\n         CVCALL DESPOT         GO TO IT\n         SPACE 3\n         DS    0F\nVDOREPL  DC    AL1(DESNRTN+LOCATRTN+DESMATCH+PREST+DESRELA)\n         DC    AL3(DOREPL-P008)    RELATIVE ADDR FOR DESPOT\nVDOREPL1 DC    AL1(DESNRTN+LOCATRTN+DESMATCH+UNPRST+DESRELA)\n         DC    AL3(DOREPL-P008)    RELATIVE ADDR FOR DESPOT\n         SPACE 3\nREPLPRT  SCKW  ,,PUSH        FILLED IN AT INIT TO LTNPRT\nDITTPRT  SCKW  DITTO,DITSET,A\n         SCKW  NODITTO,NDITSET,A\n         SCKW  ,,POP               NO-OP FOR REP CMD\n         SCKW  ,BADCOL\n         SPACE 3\nDITSET   OI    CPLFLG2,CPFDITTO    SET DITTO OPTION\n         BR    R14                 SCAN ON\n         SPACE\nNDITSET  NI    CPLFLG2,255-CPFDITTO    TURN OFF DITTO OPTION\n         BR    R14                 SCAN ON\n         TITLE 'DOREPL ROUTINE -- PAGE 8'\nDOREPL   XENTER 2,8,*         SAVE\n         TM    CPLFLG5,CPFNLST     ANYTHING TO LIST\n         BO    DOREPL1             NO\n         CVCALL LISTLINE           FORMAT LINE FOR LIST\n         BP    CVQTYPE             ABORT IF ATTN HIT.\nDOREPL1  TM    CPLFLG2,CPFREP1     HAVE A REPL LINE FOR DITTO\n         BZ    FIRST               NO\n         TM    CPLFLG2,CPFDITTO    DITTO OPTION\n         BO    SAMEREP             YES, GO DO REPLACE\nFIRST    L     0,CPLCNO      GET LOCATED NO\n         CVCALL SETPRMPT           GO SET PROMPT\n         CVCALL TRDRTN             GO PROMPT AND READ\n         BP    CVQTYPE             ABORT COMMAND IF ATTENTION\n         L     15,CPLCNO     LINE NO TO 15\n         LTR   0,0            TEST IF A REPLACE WANTED\n         BZ    REPEXIT        NO, LEAVE LINE ALONE\n         OI    CPLFLG2,CPFREP1     SET HAVE REPL LINE\n         MVC   CPWA(SZR),0(R1)          MOVE TEXT\n         LA    R1,CPWA                  WA RESERVED BY GOREPL\n         CVCALL LENCHK        COMPARE TO CURRENT LENGTH OPTION\n         CVCALL PRESS         PREST TEXT\n         CVCALL STOWIT        GO DO THE REPLACE\nREPEXIT  XEXIT 2,8           SCRAM\n         SPACE 3\nSAMEREP  LA    R1,CPWA                  POINT R1 TO REPLACING LIN\n         MVC   0(4,R1),CPLCNO      SET NEW LINE NO.\n         SR    R0,R0               ZERO FOR IC\n         IC    0,4(1)         PREST COUNT TO ZERO\n         CVCALL STOWIT             REPLACE THE LINE\n         B     REPEXIT             NORMAL EXIT\n         TITLE 'UTILITY ROUTINES -- PAGE 8'\nBADLINEL L     R0,CPLCNO           GET BAD LINE NUMBER\n         CVCALL CVEXNO             CONVERT TO EXTERNAL FORM\n         TSEG  (1),(0),B           PUT IT IN MESSAGE\n         SPACE\nBADLINE  TSEG  'LINE NO.'\n         B     CVUNLEGL\n         TITLE 'END OF PAGED CODE -- PAGE 8'\n         PINIT\n         MVC   APRTC+1(3),CVLNENO+1  SET TO LNENOPRT\n         MVC   DPRTC+1(3),CVCLRPR+1  SET TO CLRPRT\n         MVC   EPRTC+1(3),CVLTNPR+1  SET TO LTNPRT\n         MVC   INSPRT+1(3),CVLNENO+1 SET TO LNENOPRT\n         MVC   INSPRT1+1(3),CVLTNPR+1  SET TO LTNPRT\n         MVC   REPLPRT+1(3),CVLTNPR+1  SET TO LTNPRT\n         PEND\n         TITLE 'START OF PAGED CODE -- PAGE 9'\nP009     PAGECDE GONUMB,GOALINE\n         WIDENT 001\n         TITLE 'GONUMB ROUTINE -- PAGE 9'\nPGONUMB  GENTER NUMWORKL\n         USING NUMWORK,R8\n         PFREE R9                  FREE ANY PAGE IN R9 (FOR ALIGN)\n         XC    NUMWORK(NUMWORKL),NUMWORK CLEAR WORK AREA\nNUMISOK  MVI   CPLSTCOL,FNEGBT          RESET FIRST COLLECT\n         SR    R3,R3               SET NO E-O-RANGE GIVEN\n         LH    R5,CPAGCT           GET PAGE COUNT\n         LTR   R5,R5               ANY ACTIVE FILE?\n         BZ    NUMNIL              NO\n         L     R2,CPGLDL           SET DEFAULT 1ST POSITION\n         ST    R2,CPWKPS           SET DEFAULT START POSITION\n         ST    R2,CPWKDL           SET DEFAULT DELTA\n         MVC   NUMLPOS,=F'99999999' SET LAST FOR RANGE ALL\n         MVC   NUMHIGH,CPHIPS      SET WITH HIGHEST LINE NO\n         LA    R6,GOTPOS-P009      SET FOR LINE NUMBER RETURN\n         LCR   R6,R6               MAKE REL ADDR NEGATIVE AS FLAG\n         SCAN  APRTA                    SCAN FOR POSIT OR DELTA\n         B     FINITO                   GO PROCESS\n         SPACE\nGOTPOS   LR    R2,R0                    SET WORKING POSITION\n         ST    R2,CPWKPS           SET START POSITION\n         SCAN  CPRTA                    SCAN FOR DELTA\n         B     FINITO                   ALL SCANNED\n         SPACE\nGOTSLA   LA    R6,GOTPOSL-P009     SET FOR LAST LINENO\n         LCR   R6,R6               MAKE REL ADDR NEGATIVE AS FLAG\n         SCAN  DPRTA               SCAN FOR LAST LINE NO\n         B     CVABSENT            ERROR IF MISSING\n         SPACE\nGOTPOSL  LTR   R3,R0               SAVE LAST LINE NO\n         BNP   CVNVALID            ERROR IF NOT POSITIVE\n         CR    R3,R2               LAST MUST BE > FIRST\n         BL    CVNVALID            BRANCH NO\n         STM   R2,R3,NUMFPOS       SAVE FIRST & LAST\n         SCAN  BPRTA               SCAN FOR DELTA\n         B     FINITO\n         SPACE\nGOTTIMES LTR   R15,R15                 ZERO\n         BNP   CVNVALID                NOT ALLOWED\n         C     R15,=F'1000'            MULTIPLY BY 1\n         BE    CVGETCOM                DONE\n         ST    R15,CPWKDL              SAVE OPTION\n         XC    CPWKPS(4),CPWKPS        ZERO LINE NUMBER\n         M     R14,CPHIPS              WOULD\n         D     R14,=F'100000000'            LINE NUMBERS\n         CL    R15,=F'1000'                      OVERFLOW\n         BNL   TIMTOHGH                YES\n         OI    CPLFLG1,CPFTIMES        SET TIMES OPTION FLAG\n         B     FINITOC                 GO CHECK REST OF LINE\n         SPACE\nGOTDEL   LTR   R15,R15                  ZERO NG\n         BNP   CVNVALID                 DELTA ERROR\n         ST    R15,CPWKDL               RESET WORKING DELTA\nFINITOC  SCAN  ,                       CHECK REST OF LINE BLANK\n         BP    CVNVALID            INVALID IF ANYTHING FOUND\nFINITO   ST    R3,CPLCNO           SET FOR LOCATE ALL\n         LTR   R3,R3               WAS E-O-RANGE GIVEN\n         BZ    ALLNUMB             NO, RENUMBER ALL\n         ST    R2,CPLCNO           YES, RESET LOCATE LINE\nALLNUMB  LA    R1,CPLCNO           LOCATE FIRST\n         CVCALL LOCATE                   LINE\n         TM    CPDRPT,CPFNTYT+CPFHIGH AFTER LAST?\n         BNZ   NUMNIL              YES, RANGE IS NULL\n         TM    CPDRPT,CPFMTCH      LINE NO MATCH?\n         BZ    ALLNUMB             NO, DO LOCATE AGAIN\n         CLC   CPLCNO,NUMLPOS      ANY NUMBERS IN RANGE\n         BH    NUMNIL              NO, RANGE IS NULL\n         L     R4,CPDRPT           GET DIRECTORY POINTER\n         LR    R3,R15              GET DISPLACEMENT\n         SR    R3,R11                  TO FIRST LINE\n         STM   R3,R4,NUMDISP       SAVE DISP & DIR FOR FIXIT\n         SR    R6,R6               ZERO FOR IC\n         LR    R3,R15              POINT R3 TO FIRST LINE\n         B     BNUMBB              ENTER LOOP\n         SPACE\nNXPAG    LA    R4,6(,R4)           POINT TO NEXT DIR ENTRY\n         LH    0,4(4)         WANTED PAGE NO.\n         PGET  11,(0)         GET IT\n         LA    3,2(11)       ADDR 1ST LINE NO ON PAGE\nBNUMBB   PMARK 11                  MARK PAGE AS CHANGED\n         LH    2,0(11)        PAGE BYTE COUNT\n         LA    2,0(2,11)     ADDR FIRST FREE BYTE ON PAGE\n         TM    CPLFLG1,CPFTIMES        IS IT TIMES OPTION\n         BO    DOTIMES                 YES\nNXLIN    L     R1,CPWKPS           GET NEXT NUM TO USE\n         TM    NUMFLG,X'FF'        RECOVERING FROM FIXIT\n         BNZ   GOALONG             YES, DON'T CHECK RANGE\n         CLC   0(4,R3),NUMLPOS     END OF RANGE\n         BH    ALLDONE             BRANCH YES\n         CL    R1,NUMLPOS          NEW NUMBER STILL IN RANGE\n         BH    FIXIT               NO, GO FIX NUMBERS\nGOALONG  ST    R1,CPWORK1          SAVE LAST NO USED\n         CLC   0(4,R3),NUMHIGH     HIGHEST LINE RENUMBER\n         BL    NOTHIGH             NO\n         TM    NUMFLG,X'FF'        FIXIT RECOVERY\n         BZ    REALHIGH            NO, MUST BE END OF FILE\n         MVC   NUMHIGH,CPHIPS      YES, RESET TO END OF FILE\n         MVI   NUMFLG,X'00'        MARK FIXIT FINISHED\n         B     NOTHIGH             CONTINUE\n         SPACE\nREALHIGH MVC   CPHIPS,CPWORK1      RESET HIGH LINE NO\n         LA    R5,1                FORCE FINISH\nNOTHIGH  MVC   0(4,R3),CPWORK1     MOVE IN NEW LINE NO.\n         A     R1,CPWKDL           ADD DELTA\n         ST    R1,CPWKPS           SAVE NEXT LINE NO TO USE\n         IC    6,4(3)        GET PREST COUNT FOR THE LINE\n         LA    3,5(3,6)      SPACE TO LINE-NO POSITION NEXT LINE\n         CR    3,2           MORE LINES ON PAGE\n         BL    NXLIN         YES\nFIXLIN1  MVC   0(4,R4),2(R11)      FIX FIRST LINE NO IN DIRECTORY\n         BCT   5,NXPAG       MORE PAGES?\nALLDONE  EX    0,FIXLIN1           FIX 1ST LINE NO IN DIRECTORY\n         LA    R6,CVGETCOM         SET EXIT FOR LSLNMSG\n         MVC   CPCURRL,CPWORK1     SET CURRENT LINE NO\n         OI    CPGFLG,CPFDIRCH         SET DIR CHNGED FOR RCVY\n         TM    CPLFLG1,CPFNMOD         WAS THERE ANY ADJUSTMENT\n         BE    ALLDONE1                NO\n         TSEG  'LINE NUMBER(S) ADJUSTED',,M\nALLDONE1 CVCALL LSLNMSG,PFREE      GO DO LAST LINE MESSAGE\n         SPACE 3\nFIXIT    EX    0,FIXLIN1           FIX 1ST LINE NO IN DIRECTORY\n         L     R1,CPWKDL           GET CURRENT DELTA\n         SRA   R1,1                HALVE IT\n         CVCALL SELDELTA           GO SELECT PROPER DELTA\n         ST    R1,CPWKDL           SAVE NEW DELTA\n         LH    R5,CPAGCT           RESET PAGE COUNT\n         LM    R3,R4,NUMDISP       GET 1ST DISP & DIRECTORY POINTER\n         LH    R0,4(,R4)           GET PAGE NO.\n         PGET  R11,(0)             GET PAGE IN R11\n         MVC   CPWKPS,NUMFPOS      SET FIRST LINE NO TO USE\n         AR    R3,R11              POINT TO FIRST LINE\n         MVC   NUMHIGH,CPWORK1     SET FOR FIXIT RECOVERY\n         MVI   NUMFLG,X'FF'        SET FIXIT BEING DONE\n         TM    NUMMSG,X'FF'        FIRST FIXIT?\n         BO    BNUMBB              NO, MSG ALREADY DONE\n         MVI   NUMMSG,X'FF'        SET NOT FIRST FIXIT\n         TSEG  'LINE NO. TOO BIG, REDONE.',,M\n         B     BNUMBB              GO FIX LINE NUMBERS\n         SPACE\nNUMNIL   CVCALL ITSNIL              NULL RANGE\n         SPACE\nDOTIMES  MVC   CPDOUB(4),0(R3)         GET LINE\n         L     R1,CPDOUB                   NUMBER\n         M     R0,CPWKDL               MAKE NEW\n         D     R0,=F'1000'                 LINE NUMBER\n         CL    R1,CPWKPS               TEST HIGHER THAN LAST\n         BNH   DOTIM1                  NO, MUST INCREMENT\n         LTR   R0,R0                   IS THERE A REMAINDER\n         BE    DOTIMOK                 NO\n         B     DOTIM2\n         SPACE\nDOTIM1   LA    R0,1                    PUT INCR IN R0\n         L     R1,CPWKPS           SET TO LAST USED\n         CVCALL ADDER                  ADD TO LINE NO\n         LTR   R1,R0                   PUT RESULT IN R1\n         BP    DOTIM2                  POSITIVE OKAY\n         DIE   ,              SHOULD NOT HAPPEN\n         SPACE\nDOTIM2   OI    CPLFLG1,CPFNMOD         SET REMAINDER OR INCR\nDOTIMOK  ST    R1,CPWKPS               SAVE NEW HIGH LINE NO\n         ST    R1,CPWORK1          SET LAST LINE NO USED\n         MVC   0(4,R3),CPWKPS          PUT LINE NO IN RECORD\n         IC    R6,4(,R3)               GET PREST COUNT FOR LINE\n         LA    R3,5(R3,R6)             SPACE TO NEXT LINE\n         CR    R3,R2                   MORE LINES\n         BL    DOTIMES                 YES\n         MVC   CPHIPS,CPWKPS           SET NEW CPHIPS\n         B     FIXLIN1                 GO DO NEXT PAGE\n         SPACE\nTIMTOHGH TSEG  'TIMES OPTION TOO LARGE'\n         B     CVQTYPE\n         SPACE\nBADNUM   B     CVNVALID\n         SPACE 3\n* SCAN TABLES FOR NUMBER\n         SPACE\nAPRTA    SCKW  ,,PUSH          FILLED IN AT INIT TO LNENOPRT\n         SCKW  TIMES,GOTTIMES,(P,LN,A)\nBPRTA    SCKW  BY,GOTDEL,(P,LN)\n         SCKW  ,BADNUM\n         SPACE\nCPRTA    SCKW  /,GOTSLA\n         SCKW  ,BPRTA,PUSH\n         SPACE\nDPRTA    SCKW  ,,PUSH          FILLED IN AT INIT TO LNENOPRT\nDPRTA1   SCKW  ,BADNUM\n         TITLE 'ALIGN ROUTINE -- PAGE 9'\nPGOALINE GENTER ALWALEN      SPACE FOR OTBF=2*SZR-24\nALGNOK   MVI   CPLSTCOL,FNEGBT          RESET FIRST COLLECT\n         USING ALWA,R8             ESTABLISH ADDRESSABILITY\n         ST    R8,CPNAWAPT         SAVE WORK AREA POINTER\n         XC    ALWA(ALCLRLEN),ALWA CLEAR FIRST PART OF WORK AREA\n         MVI   ALWBL,C' '          INITIALIZE BLANK\n         MVC   ALWBC(4),BCINST     INITIALIZE BRANCH INSTR\n         MVI   ALMODSV,FNEGBT      SET TO FORCE NEW PARAGRAPH\n         OI    CPLFLG5,CPFNONUM    SET DEFAULT TO NOT RENUMBER ALL\n         CVCALL DETRNG         GET (EXPLICIT) RANGE\n         MVC   ALLNMAX(2),CPLNGTH  SET DEFAULT LENGTH\nALGNSCN  SCAN  ALIPRT                   SCAN FOR OPTIONS\nALNRDY   LH    R1,ALINDST          CHECK INDENT PARMS\n         CH    R1,ALLNMAX          LESS THAN LENGTH\n         BNL   BADINDNT            NO, ERROR\n         LA    R0,ALBUFF(R1)       JUSTIFY STARTING POINT\n         ST    R0,ALWJPT           SAVE IT\n         AH    R1,ALINDPA          ADD IN EXTRA PARAGRAPH INDENT\n         BM    BADINDNT            ERROR IF < 0\n         CH    R1,ALLNMAX          LESS THAN LENGTH\n         BNL   BADINDNT            NO, ERROR\n         STH   R1,ALINDPA          SET PARAGRAPH INDENT\n         STH   R1,ALINDNT          SET FIRST INDENT\n         TM    ALFLAGS,ALFEVEN     EVEN OPTION SPECIFIED\n         BE    *+8                 NO, SKIP NEXT\n         MVI   ALWBC+1,0           SET NOT TO BR EVER\n         MVI   CPWKPS,FNEGBT       SET TO AVOID NUMBERING FIRST\n         MVI   CPCURRL,X'F0'       SET CURRENT LINE INVALID\n         OI    CPLFLG5,CPFNCUR     SET SO DESPOT WON'T CHANGE CURRE\n         PCALL DOALINE             GO TO NEXT PAGE TO EXECUTE\n         SPACE\nBCINST   BNE   DIFLEAD-P011(,R10)  NOP OR BNE\n         SPACE 3\nHAVLENE  STH   R15,ALLNMAX              STORE\n         BR    R14                      MORE?\n         SPACE\nHAVMARK  BNPR  14\n         OI    ALFLAGS,ALFMRKN          SET MARKER MODE\n         MVC   ALLNMRK(1),1(R1)\n         CLI   0(R1),C''''             QUOTED?\n         BER   R14                      BR IF SO\n         CLI   0(R1),C'\"'\n         BER   R14\n         MVC   ALLNMRK(1),0(R1)         SET MARKER\n         BR    R14                      MORE?\n         SPACE\nHAVSPACE OI    ALFLAGS,ALFSPCE     SET SPACE OPTION\n         BR    R14                 SCAN ON\n         SPACE\nHAVEVEN  OI    ALFLAGS,ALFEVEN     SET EVEN OPTION\n         BR    R14                 SCAN ON\n         SPACE\nALINDENT STH   R15,ALINDST         SAVE INDENT VALUE\n         SCANSAVE ,                SAVE SCAN POINTERS\n         SCAN  INDPRT              SCAN FOR PARAGRAPH INDENT\n         B     ALNRDY              DONE IF NONE\n         SPACE\nALNPA1   LCR   R15,R15             COMPLEMENT THE VALUE\nALNPA2   STH   R15,ALINDPA         SAVE THE PARAGRAPH INDENT\n         B     ALGNSCN             SCAN ON\n         SPACE\nALCONT   SCANRSTR ,                RESTORE SCANNER\n         B     ALGNSCN             SCAN ON\n         SPACE\nBADINDNT TSEG  'ILLEGAL INDENTATION'\n         B     CVQTYPE\n         DROP  R8\n         SPACE 3\n* SCAN TABLES FOR ALIGN\n         SPACE\nALIPRT   SCKW  LENGTH,HAVLENE,(P,A,PI),133\n         SCKW  MARKER,HAVMARK,(P,A)\n         SCKW  SPACE,HAVSPACE,A\n         SCKW  EVEN,HAVEVEN,A\nALIPRT1  SCKW  ,,PUSH              FILLED IN AT INIT TO NUMPRT\n         SCKW  INDENT,ALINDENT,(P,I,A),50\n         SCKW  ,BADNUM\n         SPACE\nINDPRT   SCKW  +,ALNPA2,(P,I),50\n         SCKW  -,ALNPA1,(P,I),50\n         SCKW  ,ALNPA2,(I),50\n         SCKW  ,ALCONT\n         TITLE 'END OF PAGED CODE -- PAGE 9'\n         PINIT\n         MVC   APRTA+1(3),CVLNENO+1   SET TO LNENOPRT\n         MVC   DPRTA+1(3),CVLNENO+1   SET TO LNENOPRT\n         MVC   ALIPRT1+1(3),CVNUMPR+1 SET TO NUMPRT\n         PEND\n         TITLE 'START OF PAGED CODE -- PAGE 10'\nP010     PAGECDE GOTAB,GOCENTR,SHOCOL\n         AIF   ('&DCEC' NE '1').LBL21                           JEP004\n         ENTRY P010001                                          JEP001\nP010001 EQU   *                                                 JEP004\n         AGO   .LBL22                                           JEP004\n.LBL21   DS    0H                                               JEP004\n         WIDENT 001\n.LBL22   DS    0H                                               JEP004\n         TITLE 'TAB ROUTINES -- PAGE 10'\nPGOTAB   GENTER ,            ENTRY FOR SET/SHO TABS\n         CLI   CPCMNM+1,C'H' IS THIS SHOW TABS\n         BE    SHOTAB              BR YES\n         LA    2,8            MAY SET UP TO 8 TABS\n         MVC   0(8,R8),=D'0'            SET NO TABS\n         NI    RTBUFL,255-RTBURELT-RTBUTBUN NOT REL OR UNN\n         LR    R3,R8                    POINT AT TABS SAVE AREA\n         SR    6,6            WILL NEED LATER\n         NI    CPLFLG5,255-CPFUNUM ASSUME NUMBERED\n         SCAN  TBNPRT2        SEE IF EXPLICIT TAB SETTINGS GIVEN\n         AIF   ('&DCEC' NE '1').LBL23                           JEP004\n         TSEG  'TYPE A \"1\" AT EACH COLUMN THAT YOU WANT A TAB, LEAVE OTX\n               HERS BLANK:',,W                                  JEP004\n         AGO   .LBL24                                           JEP004\n.LBL23   DS    0H                                               JEP004\n         TSEG  'TYPE A \"1\" AT EACH COLUMN THAT YOU WANT A TAB, LEAVE OTH\n               HER SPACES BLANK:',,W\n.LBL24   DS    0H                                               JEP004\n         XCALL SHOWCOL         GO SHOW COLUMNS FOR TAB\n         TMARK ,              MARK IT\n         SR    R0,R0\n         LA    R1,=C'           '\n         TM    CPLFLG5,CPFUNUM\n         BO    *+8                 SKIP THE PROMPT IF UNNUM\n         LA    R0,11\n         L     R15,CVTRDRTN\n         BALR  R14,R15\n         BP    CVQTYPE             ABORT IF ATTENTION\n         LR    6,1            SAVE START\n         SCINIT (1),(0)       INIT SCAN\n         SCAN  ONEPRT                   SCAN FOR \"1'S\"\n         B     TABSOFF                  NONE SET MSG\n         SPACE\nHAVONE   LR    R5,R1                   SAVE ITEM ADDR\n         SR    R1,R6                   GET A TAB POSITION\n         TM    CPLFLG5,CPFUNUM         UNNUMBERED?\n         BO    *+8                     DON'T ADD 11\n         LA    R1,11(,R1)              ADJUST TAB POSITION\n         LA    R1,1(,R1)\n         LR    R4,R0                   LENGTH OF ITEM\nTABCMP   CLI   0(R5),C'1'              MUST BE ALL ONES\n         BNE   TABERR                  NG\n         LA    R5,1(R5)                KICK POINTER\n         BCT   R4,TABCMP               CHECK ALL\nSETATAB  STC   R1,0(R3)                STORE TAB POSITION\n         BCT   R2,TRYATAB              MORE SETTINGS POSSIBLE?\n         B     TABSET                   DO TAB SET\n         SPACE\nTRYATAB  LA    R3,1(R3)                POINT TO NEXT TAB TO SET\n         LA    R1,1(R1)                SET NEXT POSITION\n         BCT   R0,SETATAB              SET IT\n         SCAN  ONEPRT                   SCAN FOR \"1'S\"\n         MVC   RTBTABS(8),0(R8)        PLANT TABS\n         TM    CPLFLG1,CPFTNOV     VERIFY TABS?\n         BO    CVGETCOM            NO.\n         B     TABVWR2             GO VERIFY TAB SETTINGS\n         SPACE 3\nSTABVER  NI    CPLFLG1,255-CPFTNOV RESET NOVERIFY SWITCH\n         BR    R14                 SCAN ON\n         SPACE\nSTABNOV  OI    CPLFLG1,CPFTNOV     SET NO TAB VERIFY FLAG\n         BR    R14                 SCAN ON\n         SPACE\nSTABREL  OI    RTBUFL,RTBURELT     SET RELATIVE TABS\n         SPACE\nSTABUNUM OI    CPLFLG5,CPFUNUM     SET UNNUMBERED\n         OI    RTBUFL,RTBUTBUN     SET TABS UNNUMBERED\n         BR    R14\n         SPACE\nTABNOS   LTR   R2,R2               ANY MORE TABS ALLOWED\n         BCTR  R2,0           DECREMENT COUNT\n         BNPR  R14                 NO, IGNORE TAB AND SCAN ON\n         CR    R15,R6                   GTR 0 OR LAST\n         BNH   TABCHK                   ERROR\n         LR    R6,R15                   SAVE FOR NEXT COMPARE\n         LR    R0,R6\n         TM    CPLFLG5,CPFUNUM\n         BO    *+8\n         LA    0,11(,6)                GET INTERNAL COUNT\n         STC   0,0(3)         SAVE\n         LA    3,1(3)         MOVE TAB POINTER\nTABMOR   SCAN  TBNPRT         SEE IF ANOTHER TOKEN\n         LTR   R2,R2               SEE IF ANY TABS IGNORED\n         BNM   TABSET              BRANCH NO\n         TSEG  'ONLY FIRST 8 TABS USED',,W WRITE OUT MESSAGE\n         B     TABSET                   DO TAB SET\n         SPACE\nTABCHK   LTR   6,6            IS IT FIRST ONE & ZERO\n         BZ    TABSOFF        UNSET TABS\nTABERR   TSEG  'TABS ERROR, '\nTABSOFF  TSEG  'NO TABS SET'\n         XC    RTBTABS(8),RTBTABS      CLEAR TABS\n         B     CVGETCOM\n         SPACE\nTABSET   MVC   RTBTABS(8),0(R8)        SET TABS\n         TM    CPLFLG1,CPFTNOV     VERIFY TABS?\n         BO    CVGETCOM            NO.\nTABVER   LA    R2,RTBTABS\n         LA    R3,8\n         LA    R4,1\nTABLP    SR    R5,R5\n         IC    R5,0(,R2)               GET A TAB\n         LTR   R5,R5                   ANY LEFT?\n         BNP   TABVWR                  BR IF NOT\n         LR    R6,R5\n         SR    R5,R4                   COMPUTE NO. OF BLANKS\n         BNP   TAB1                    BR IF NONE\nTABBL    TSEG  ' '\n         BCT   R5,TABBL\nTAB1     TSEG  '1'\n         LA    R4,1(,R6)               SET NEW POSITION\n         LA    R2,1(,R2)               NEXT TAB\n         BCT   R3,TABLP\nTABVWR   OI    RTBMFL,RTBMFNTO         SET NO TABS\n         TWRITE ,\n         BNZ   CVGETCOM                BR IF ATTN\n         AIF   ('&DCEC' NE '1').LBL02                           JEP00X\nTABVWR2  TM    LFLG1,CPF3277       IS IT A TUBE???              JEP004\n         BO    TAB3277                                          JEP004\n         B     NOT3277             GO AROUND 3277 CODE          JEP004\nTAB3277  TSEG  'PHYS TABS NO-VER ON 3277',,WRITE                JEP004\n         B     TABVWR3             GO AROUND TTY TYPE CODE      JEP004\nNOT3277  EQU   *                                                JEP004\n         AGO   .LBL03                                           JEP00X\n.LBL02   DS    0H                                               JEP00X\nTABVWR2  LA    R2,RTBTABS\n         AGO   .LBL11                                           JEP00X\n.LBL03   DS    0H                                               JEP00X\n         LA    R2,RTBTABS                                       JEP004\n.LBL11   DS    0H                                               JEP00X\n         AIF   ('&DCEC' NE '1').LBL04                           JEP00X\nTABVWR3  EQU   *                                                JEP00X\n.LBL04   DS    0H                                               JEP00X\n         LA    R3,8\nTABVLP   CLI   0(R2),0                 LAST TAB?\n         BE    CVGETCOM                BR IF SO\n         TSEG  =X'05F1',2              TAB 1\n         LA    R2,1(,R2)\n         BCT   R3,TABVLP\n         B     CVGETCOM                 GET NEXT COMMAND\n         SPACE 3\nBADTAB   B     CVNVALID\n         EJECT\nSHOTAB   OI    CPLFLG1,CPFTNOV     SET NOVERIFY AS DEFAULT\n         SCAN  VERPRT              SCAN FOR VERIFY\n         CLC   RTBTABS(8),=D'0'         ANY TABS SET?\n         BNE   SOME                     YES\n         TSEG  'NO TABS'                NONE\n         B     CVGETCOM\n         SPACE\nSOME     LA    R4,8                     8 POSSIBLE TAB SETTINGS\n         LA    R3,RTBTABS               POINT AT FIRST\nOVRA     SR    R15,R15                  ZERO FOR IC INST\n         IC    R15,0(R3)                GET NEXT TAB BYTE\n         LA    R3,1(R3)                 MOVE POINTER\n         LTR   R15,R15                  IS IT ZERO?\n         BZ    SSSSQK                   YES, NONE SET FOR THIS BYTE\n         TM    RTBUFL,RTBURELT+RTBUTBUN UNNUM OR RELATIVE?\n         BNZ   *+8                      IF EITHER DON'T SUBTRACT 11\n         SH    R15,=Y(11)              EXTERNAL VALUE THIS TAB\n         SR    R0,R0                    SET TO RETURN CHAR COUNT\n         BTD   CPDOUB,(0),(15)          CONVERT TO EXTERNAL NO.\n         TSEG  (1),(0),B            INTO MESSAGE\n         TSEG  '-',,B               INSERT DASH INTO MESSAGE\nSSSSQK   BCT   R4,OVRA                  DO ANY MORE\n         TM    RTBUFL,RTBURELT      TABS RELATIVE?\n         BNO   CHKUNNTB\n         TSEG  'RELATIVE',,B\n         B     SSSOPT\nCHKUNNTB TM    RTBUFL,RTBUTBUN      UNNUMBERED TABS?\n         BNO   SSSOPT\n         TSEG  'UNNUMBERED',,B\nSSSOPT   TSEG  'TABS W/'           PUT IN TAB MESSAGE\n         LA    R0,4\n         LA    R1,=C'SLOW'\n         TM    RTBUFL,RTBUFAST      FAST LIST?\n         BZ    *+8\n         LA    R1,=C'FAST'\n         TSEG  (1),(0)\n         TSEG  'LIST',,W\n         TM    CPLFLG1,CPFTNOV     IS IT VERIFY OR NOVERIFY\n         BO    CVGETCOM            BR IF NOVERIFY\n         B     TABVER              GO VERIFY\n         TITLE 'SHOW COLUMNS -- PAGE 10'\nPSHOCOL  GENTER ,\n         OI    CPLFLG5,CPFUNUM     ASSUME UNNUMBERED\n         SCAN  SCU                 GO SCAN UNNUMBERED\nCLN      NI    CPLFLG5,255-CPFUNUM NOT UNNUMBERED\nCNU      XCALL SHOWCOL             USE SUBROUTINE TO SHO COL\n         B     CVGETCOM            GO GET NEXT COMMAND\n         SPACE 3\n* SHOW COLUMNS ROUTINE FOR SET TABS AND SHOW COLUMNS\n         SPACE\nSHOWCOL  XENTER R7,R8,*\n         TM    CPLFLG5,CPFUNUM     UNNUMBERED?\n         BO    CNUU                SKIP THE BLANKS\n         TSEG  '           '           11 BLAMKS\nCNUU     LA    4,13                13 TIMES\n         LA    5,COLPAT\nAGIN     TSEG  '123456789'    REPEAT THIS\n         LR    1,5            POINTER INTO REG 1\n         AIF   ('&DCEC' NE '1').LBLX5                           USPS01\n         LA    5,1(5)                                           USPS01\n         LA    0,1                                              USPS01\n         AGO   .LBLX6                                           USPS01\n.LBLX5   DS    0H                                               USPS01\n         LA    5,3(5)         KICK TO NEXT\n         LA    0,3            COUNT\n.LBLX6   DS    0H                                               USPS01\n         TSEG  (1),(0)\n         BCT   4,AGIN         ANOTHER?\n         AIF   ('&DCEC' NE '1').LBL31                           USPS01\n         LA    1,=C'123456789'                                  USPS01\n         LA    0,3                                              USPS01\n         TSEG  (1),(0)                                          USPS01\n         TWRITE ,                                               USPS01\n         AGO   .LBL32                                           USPS01\n.LBL31   DS    0H                                               USPS01\n         OI    RTBMFL,RTBNOCR SET NO CR/LF FLAG\n         TWRITE ,\n         NI    RTBMFL,255-RTBNOCR\n         LA    1,=C'123456789'\n         LA    0,3\n         TSEG  (1),(0)\n.LBL32   DS    0H                                               USPS01\n         OI    RTBMFL,RTBMFNTO     SET NOT TO USE TABS ON OUTPUT\n         XEXIT R7,R8\n         SPACE\n         AIF   ('&DCEC' NE '1').LBLX7                           USPS01\nCOLPAT   DC    C'ABCDEFGHIJKLM'                                 USPS01\n         AGO   .LBLX8                                           USPS01\n.LBLX7   DS    0H                                               USPS01\nCOLPAT   DC    C'1',X'16',C'_'\n         DC    C'2',X'16',C'_'\n         DC    C'3',X'16',C'_'\n         DC    C'4',X'16',C'_'\n         DC    C'5',X'16',C'_'\n         DC    C'6',X'16',C'_'\n         DC    C'7',X'16',C'_'\n         DC    C'8',X'16',C'_'\n         DC    C'9',X'16',C'_'\n         DC    C'A',X'16',C'_'\n         DC    C'B',X'16',C'_'\n         DC    C'C',X'16',C'_'\n         DC    C'D',X'16',C'_'\n.LBLX8   DS    0H                                               USPS01\n         TITLE 'SCKW''S FOR SHOW TABS/COLS -- PAGE 10'\n* FOR SET TABS\n         SPACE\nONEPRT   SCKW  ,HAVONE\nTBNPRT2  SCKW  NOVERIFY,STABNOV,A\n         SCKW  VERIFY,STABVER,A\n         SCKW  UNNUMBER,STABUNUM,A\n         SCKW  RELATIVE,STABREL,A\nTBNPRT   SCKW  ,TABNOS,PI,133\n         SCKW  ,TABERR\n         SPACE 3\n* FOR SHOW TABS VERIFY\n         SPACE\nVERPRT   SCKW  VERIFY,STABVER,A\n         SCKW  NOVERIFY,STABNOV,A\n         SCKW  ,BADTAB\n         SPACE 3\n* FOR SHOW COLUMNS\n         SPACE\nSCU      SCKW  UNNUMBER,CNU,A\n         SCKW  ,CLN\n         TITLE 'CENTER ROUTINE -- PAGE 10'\nPGOCENTR GENTER ALWALEN\n         CVCALL DETRNG             SCAN FOR RANGE\n         USING ALWA,R8\n         ST    R8,CPWK1\n         XC    ALWA(ALCLRLEN),ALWA CLEAR WORK AREA\n         MVC   ALLNMAX(2),CPLNGTH  SET DEFAULT LENGTH\n         SCAN  CENPRT              SCAN FOR OTHER VALUES\n         LH    R0,ALLNMAX          TEST INDENT AGAINST LENGTH\n         CH    R0,ALINDST          INDENT MUST BE LESS\n         BNH   CENSH               BR IF NOT\n         L     R15,CENWKAD         WORK ROUTINE ADDRESS\n         CVCALL DESPOT             GO DO COMMAND\n         SPACE\nCENLEN   STH   R15,ALLNMAX         SAVE LENGTH\n         BR    R14                 SCAN ON\n         SPACE\nCENIND   STH   R15,ALINDST         SAVE INDENT VALUE\n         BR    R14                 SCAN ON\n         SPACE\nCENSH    TSEG  'ILLEGAL INDENTATION'\n         B     CVQTYPE\n         DROP  R8\n         SPACE 3\nCENWORK  DS    0H\n         XENTER 2,8,*\n         L     R6,CPWK1            GET WORK AREA ADDR\n         USING ALWA,R6\n         LTR   R0,R0               BLANK LINE\n         BNP   CENEXIT             BRANCH YES\nCENBL    CLI   0(R1),C' '          LEADING BLANK?\n         BNE   CENNBL              BRANCH NO\n         LA    R1,1(,R1)           TO NEXT CHAR\n         BCT   R0,CENBL\nCENNBL   LH    R3,ALLNMAX          LENGTH\n         LH    R4,ALINDST          INDENT\n         SR    R3,R0               COMPUTE NO. OF BLANKS\n         SR    R3,R4               ALLOW FOR INDENT\n         BNM   CENPOS              BR IF OK\n         AR    R4,R3               REDUCE INDENTATION\n         BNM   *+6                 BUT NOT TOO MUCH\n         SR    R4,R4\n         SR    R3,R3               SET BLANK COUNT\nCENPOS   SRA   R3,1                COMPUTE BLANKS FOR LEFT SIDE\n         AR    R3,R4               ADD ADJUSTED INDENTATION\n         MVI   ALBUFF,C' '         BLANK OUT\n         EX    R3,CENMVBL              FIRST PART\n         LR    R2,R0               SAVE LENGTH\n         AR    R0,R3               COMPUTE FINAL LENGTH\n         LA    R3,ALBUFF(R3)       COMPUTE TEXT ADDRESS\n         EX    R2,CENMVTXT         MOVE TEXT TO BUFFER\n         LA    R1,ALBUFF           POINT AT NEW LINE\n         L     R15,CPLCNO          GET LINE NO.\n         CVCALL PRESS              PRESS THE LINE\n         CVCALL STOWIT             REPLACE THE LINE\nCENEXIT  XEXIT 2,8                 RETURN TO DESPOT\n         SPACE 3\nCENMVBL  MVC   ALBUFF+1(0),ALBUFF\nCENMVTXT MVC   0(0,R3),0(R1)\n         DROP  R6\n         SPACE 3\n* FOR CENTER\n         SPACE\nCENPRT   SCKW  LENGTH,CENLEN,(P,PI,A),133\n         SCKW  INDENT,CENIND,(P,I,A),132\n         SCKW  ,BADTAB\n         SPACE 3\n         DS    0F\nCENWKAD  DC    AL1(DESNRTN+LOCATRTN+DESMATCH+UNPRST+DESRELA)\n         DC    AL3(CENWORK-P010)    WORK ADDRESS\n         TITLE 'END OF PAGED CODE -- PAGE 10'\n         PINIT\n         PEND\n         TITLE 'START OF PAGED CODE -- PAGE 11'\nP011     PAGECDE DOALINE\n         WIDENT 001\n         TITLE 'DO ALIGN/JUSTIFY ROUTINE -- PAGE 11'\n         USING  ALWA,R8            SET UP FOR WORK AREA\nPDOALINE GENTER ,\n         L     15,ALNWKAD     SETUP ADDR AND CODES FOR DESPOT\n         CVCALL DESPOT                 GO DO ALIGN\n         OI    CPGFLG,CPFDIRCH         SET DIRECTORY CHANGED\n         LR    R6,R8               PUT WORK AREA ADDR IN R6\n         TM    ALFLAGS,ALFSOME     ANYTHING LEFT IN BUFFERS\n         BZ    ALISDON        NO\n         LA    R5,ALBUFF      POINT TO TEXT\n         LM    R3,R4,ALWSAVE  GET COUNT\n         SH    R4,ALWBUFL        INTO R4\n         LCR   R4,R4                  FOR OTALIN\n         XCALL OTALIN         OUTPUT LAST\nALISDON  TM    CPLFLG5,CPFNONUM    SKIP NUMBER COMMAND?\n         BNZ   DOLAST              YES, GO LOCAL RENUMBER LAST PART\n         LA    1,=C'  '       BLANKSOMMAND\n         LA    0,2            COUNT\n         SCINIT (1),(0)       INIT\n         XC    CPLFLG1(5),CPLFLG1      RESET FLAGS FOR NUMBER\n         PCALL GONUMB         RENUMBER\n         SPACE\nDOLAST   CLC   CPWKPS,CPHIPS       WAS LAST LINE IN FILE DONE\n         BNH   *+10                NO, USE RANGE DETERMINED\n         MVC   ALLNOSV,=F'99999999' YES, UP TO THIS CAN BE USED\n         XCALL RENUMB              GO FIX LINE NUMBERS\n         B     CVGETCOM\n         DROP  R8\n         SPACE 3\nWRKALIN  DS    0H                  NO ENTRY\n         XENTER 2,8,*              SAVE REGS\n         L     R6,CPNAWAPT         POINT TO WORK AREA\n         USING ALWA,R6\n         LM    R3,R5,ALWSAVE       RESTORE POINTERS\n         L     R2,CPLCNO           GET CURRENT LINE NO\n         STM   R0,R2,ALWSAVE       SAVE POINTERS TO LINE & LINENO\n         PFLIP R9,R11              FLIP PAGE TO R9 FOR DELETE\n         CVCALL DODELE             DELETE THE LINE\n         LNR   R0,R12              SET R0 NEG IN CASE END OF RNGE\n         CLC   ALMODSV,CPMDLN      IS IT FIRST LINE OF NEXT RANGE\n         BNE   BLINE               YES, GO FINISH OLD RANGE FIRST\nNEWRNGEC LM    R0,R2,ALWSAVE       RESTORE POINTERS TO LINE\n         ST    R2,ALLNOSV          SAVE HIGHEST LINE NO. YET\n         LTR   R0,R0               NULL LINE\n         BNP   BLINE               BR YES\n         TM    ALFLAGS,ALFMRKN     MARKER OPTION\n         BZ    DOLEAD              BR NO\n         CLC   ALLNMRK(1),0(R1)    MARKER LINE\n         BE    ALMAR               BR YES\nDOLEAD   LR    R2,R1               FIND BLANK COUNT\nBLCHOP   CLI   0(R2),C' '          IS THIS BLANK\n         BNE   ENDLEAD             NO, AT END OF BLANKS\n         LA    R2,1(,R2)           STEP PAST BLANK\n         BCT   R0,BLCHOP           LOOP TILL NON-BLANK\n         B     BLINE\n         SPACE\nENDLEAD  SR    R2,R1               COMPUTE BLANK COUNT\n         CH    R2,ALWPBC           TEST AGAINST PREVIOUS\n         MVC   ALWPBC,ALINDST      SET COUNT FOR NEXT COMPARE\n         EX    0,ALWBC             EXEC CONDITIONAL BR OR NOP\n         B     NEXTWORD            BR IF SO\n         SPACE\nDIFLEAD  CH    R2,ALINDPA          IS THIS NORMAL NEW PARAGRAPH\n         BE    BLINEI              YES, GO FLUSH BUFF AND RESTART\n         CH    R2,ALINDST          IS THIS NORMAL INDENT\n         BNE   ALMAR1              NO, TREAT AS IF MARKER LINE\n         SPACE\n* A NEW PARAGRAPH HAS STARTED WITH THE NORMAL INDENTATION INSTEAD\n* OF THE PARAGRAPH INDENTATION.  MAINTAIN THE INDENTATION AND\n* PROCESS THE LINE.\n         SPACE\n         MVC   ALINDNT,ALINDST     SET NORMAL INDENT VALUE\n         B     NEXTWORD            GO PROCESS LINE NORMALLY\n         SPACE\nGETWORD  LTR   R0,R0               MORE INPUT TEXT\n         BNP   NEXTLINE            BR NO\n         LR    R2,R1               START OF WORD\n         CLI   0(R2),C' '          BLANK\n         BNE   NONDO               BR IF NOT\n         B     BDO                 BR IF SO\n         SPACE\nBLOOP    CLI   0(R2),C' '          NEXT CHAR. BLANK\n         BNE   BEND                BR NO\nBDO      LA    R2,1(,R2)           NEXT\n         BCT   R0,BLOOP\n         B     NEXTLINE            BR IF NO MORE IN LINE\n         SPACE\nBEND     SR    R2,R1               COMPUTE LENGTH\n         TM    ALFLAGS,ALFSPCE      SPACE OPTION\n         BZ    DOWORD              BR NO\n         CL    R5,ALWJPT           PAST JUSTIFY POINT\n         BL    DOWORD              BR IF NOT\n         B     NEXTWORD            SKIP THE BLANKS\n         SPACE\nNONLOOP  CLI   0(R2),C' '          END OF WORD\n         BE    NONEND              BR IF SO\nNONDO    LA    R2,1(,R2)\n         BCT   R0,NONLOOP\nNONEND   SR    R2,R1               COMPUTE LENGTH\n         TM    ALFLAGS,ALFSOME     ANYTHING IN LINE\n         BZ    DOWORD              BR NO\n         LR    R15,R5              END OF OUT BUFFER\n         BCTR  R15,0\n         CLI   0(R15),C' '         LAST CHAR BLANK\n         BE    DOWORD              BR YES\n         MVC   0(2,R5),=C'  '      PUT 2 BLANKS AT END\n         LA    R14,2               SET COUNT\n         CLI   0(R15),C'.'         IS IT PERIOD\n         BE    ADDIN               YES, COUNT IS CORRECT\n         CLI   0(R15),C'?'         IS IT QUESTION MARK\n         BE    ADDIN               YES, COUNT IS CORRECT\n         CLI   0(R15),C':'         IS IT COLON\n         BE    ADDIN               YES, COUNT IS CORRECT\n         CLI   0(R15),CHEXCLAM     IS IT EXCLAMATION POINT\n         BE    ADDIN               YES, COUNT IS CORRECT\n         BCTR  R14,0               RESET COUNT TO 1\nADDIN    CR    R4,R14              ROOM FOR BLANKS\n         BNH   FULL                BR IF NOT\n         ST    R14,ALWLAST         SAVE WORD LENGTH\n         AR    R5,R14              UPDATE POINTER AND COUNT\n         SR    R4,R14\n         OI    ALFLAGS,ALFSOME     SET SOMETHING IN BUFFER\n         CL    R5,ALWJPT           PAST JUSTIFY POINT\n         BNH   *+8                 BR IF NOT\n         LA    R3,1(,R3)           BUMP WORD COUNT\nDOWORD   CR    R4,R2               ROOM IN LINE\n         BNL   ROOM                BR IF SO\nFULL     TM    ALFLAGS,ALFSOME     ANY WORDS IN LINE\n         BZ    NOWORDS             BR NO\n         CLI   CPCMNM,C'J'         JUSTIFY OR ALIGN\n         BNE   UNJUST              BR IF ALIGN\n         LR    R15,R5              OUTPUT POINTER\n         BCTR  R15,0\n         CLI   0(R15),C' '         LAST TOKEN BLANK\n         BNE   NBT                 BR IF NOT\n         S     R5,ALWLAST          BACK UP\n         A     R4,ALWLAST\n         BCTR  R3,0                DECREMENT WORD COUNT\nNBT      BCTR  R3,0                COMPUTE NO. OF GAPS\n         SRA   R3,1\n         BNP   UNJUST              BR IF NONE\n         STM   R0,R2,ALWSAVE       NEED A FEW REGS\n         LTR   R1,R4               NO OF SPACES TO INSERT\n         BNP   JEND                BR IF NONE\n         SR    R0,R0\n         DR    R0,R3               COMPUTE SPACES/GAPS\n         LTR   R0,R0\n         BNP   EBR                 BR IF EVEN UP\n         LA    R1,1(,R1)           START WITH EXTRA ON RIGHT\n         TM    ALFLAGS,ALFEBL     RIGHT OR LEFT\n         BZ    EBR                 BR IF RIGHT\n         BCTR  R1,0                TAKE IT BACK\n         SR    R0,R3        COMPUTE GAPS BEFORE EXTRA\n         LCR   R0,R0\nEBR      LA    R15,0(R4,R5)        LAST CHAR PLUS 1\nEBLOOP   BCTR  R15,0               LOOK AT LAST\n         BCTR  R5,0\nEBLOOPX  MVC   0(1,R15),0(R5)      MOVE ONE CHAR\n         CLI   0(R15),C' '         WAS IT BLANK\n         BNE   EBLOOP              BR IF NOT\nBSLOOP   BCTR  R15,0               MOVE REST OF BLANKS\n         BCTR  R5,0\n         MVC   0(1,R15),0(R5)\n         CLI   0(R15),C' '         END OF GAP\n         BE    BSLOOP              BR IF NOT\n         LTR   R2,R1               NO. OF BLANKS\n         BNP   NEB                 BR IF NONE\nEBPUT    MVI   0(R15),C' '         A BLANK\n         BCTR  R15,0\n         BCT   R2,EBPUT\nNEB      BCT   R0,JENDT            BR IF MORE GAPS TO DO\n         BCTR  R1,0                ASSUME EXTRA ON RIGHT\n         TM    ALFLAGS,ALFEBL     RIGHT OR LEFT\n         BZ    *+8                 BR IF RIGHT\n         LA    R1,2(,R1)           TAKE IT BACK\n         XI    ALFLAGS,ALFEBL     FLIP SWITCH\n         LTR   R1,R1               ANYTHING MORE TO DO\n         BNP   JEND                BR IF NOT\nJENDT    BCT   R3,EBLOOPX          BR IF MORE GAPS\nJEND     LM    R0,R2,ALWSAVE       RESTORE REGS\n         SR    R4,R4               SET BUFFER FULL\nUNJUST   LA    R3,1                SET SWITCH\n         LA    R5,ALBUFF\n         SH    R4,ALWBUFL          COMPUTE LENGTH\n         LCR   R4,R4\n         XCALL OTALIN              PUT OUT LINE\nNOWORDS  LA    R5,ALBUFF           RESET BUFFER POINTER\n         LH    R15,ALINDNT          INDENTATION\n         EX    R15,MVBL            BALNK START OF LINE\n         AR    R5,R15              POINT AT START OF TEXT\n         LH    R4,ALLNMAX           SET UP LENGTH\n         STH   R4,ALWBUFL          SAVE BUFFER SIZE\n         SR    R4,R15\n         LH    R14,ALINDST         RESET INDENTATION\n         STH   R14,ALINDNT\n         LR    R14,R3              SAVE WORD COUNT\n         SR    R3,R3               SET NO WORDS IN LINE\n         NI    ALFLAGS,255-ALFSOME\n         CLI   0(R1),C' '          WAS WORD BLANK\n         BNE   AGAIN               BR IF NOT\n         LTR   R14,R14             ANYTHING IN PREV LINE\n         BP    NEXTWORD            BR IF SO\nAGAIN    CR    R4,R2               ROOM IN LINE NOW\n         BNL   ROOM                BR IF SO\n         CLI   0(R1),C' '          BLANKS\n         BE    NEXTWORD            BR IF SO\n         LA    R14,MXPRTSZ         MAX. LINE LENGTH\n         SR    R14,R2              COMPUTE MAX INDENT\n         CR    R14,R15             PICK MIN\n         BNL   *+6\n         LR    R15,R14\n         LA    R5,ALBUFF           COMPUTE START OF LINE\n         AR    R5,R15\n         LR    R4,R2               SET REMAINING COUNT\n         AR    R15,R2              COMPUTE BUFFER LENGTH\n         STH   R15,ALWBUFL\nROOM     EX    R2,MVWORD           MOVE WORD INTO BUFFER\n         ST    R2,ALWLAST          SAVE LENGTH OF WORD\n         AR    R5,R2               UPDATE POINTER\n         SR    R4,R2\n         OI    ALFLAGS,ALFSOME     SET SOMETHING IN LINE\n         CL    R5,ALWJPT           PAST JUSTIFY POINT\n         BNH   *+8                 BR IF NOT\n         LA    R3,1(,R3)           BUMP WORD COUNT\nNEXTWORD AR    R1,R2               BUMP INPUT POINTER\n         B     GETWORD\n         SPACE\nALMAR1   AR    R0,R2               RESTORE COUNT\nALMAR    BAL   R2,BLINEX           SET SW AND OUTPUT MARKED LINE\nBLINEI   AR    R0,R2               RESTORE COUNT\nBLINE    SR    R2,R2               SET SWITCH\nBLINEX   TM    ALFLAGS,ALFSOME     ANYTHING IN BUFFER\n         BZ    NULLBUF             BR IF NOT\n         LA    R5,ALBUFF           BUFFER ADDR\n         SH    R4,ALWBUFL          COMPUTE LENGTH\n         LCR   R4,R4\n         XCALL OTALIN              EMPTY BUFFER\nNULLBUF  SR    R4,R4               CLEAR OUTPUT COUNT\n         SR    R3,R3               SET NO WORDS\n         NI    ALFLAGS,255-ALFSOME\n         LH    R15,ALINDPA         SET FOR PARAGRAPH\n         STH   R15,ALINDNT\n         STH   R15,ALWPBC          ALSO SET INDENT VALUE ALLOWED\n         NI    ALFLAGS,255-ALFEBL RESET EXTRA BLANKS SW\n         LTR   R2,R2               MARKER\n         BNZ   LNOUT               BR IF SO\n         LTR   R0,R0               TEST INPUT LINE\n         BP    DOLEAD              BR IF INDENTED LINE\n         BZ    LNOUT               BR IF BLANK LINE\n         SPACE\n* PROCESS END OF RANGE\n         XCALL RENUMB              RENUMBER THE OLD RANGE\n         MVC   ALMODSV,CPMDLN      SET MOD COUNT FOR THIS RNGE\n         MVC   CPNWLN(4),ALWSAVE+8 SET FOR DESPOT\n         L     R0,CPFSLN           GET FIRST LINE IN RANGE\n         ST    R0,ALFRSTSV         SAVE AS FIRST LINE NO USED\n         ST    R0,CPWKPS           SET NEW WORK LINE NO.\n         B     NEWRNGEC            GO PROCESS LINE FOR NEW RNGE\n         SPACE\nLNOUT    LR    R5,R1               POINT AT TEXT\n         LR    R4,R0\n         XCALL OTALIN              OUTPUT LINE\n         SR    R4,R4               SET BUFFER EMPTY\nNEXTLINE STM   R3,R5,ALWSAVE       SAVE OUTPUT POINTERS\n         XEXIT 2,8\n         SPACE 3\nMVBL     MVC   ALBUFF(0),ALWBL\nMVWORD   MVC   0(0,R5),0(R1)\n         EJECT\n* OUTPUT ALIGNED LINES ROUTINE\n*        POINTER - R5\n*        COUNT - R4\n*        RETURN - R14\n*        R0,R1,R15 - FREE\n         SPACE\nOTALIN   XENTER 0,8,*\n         MVC   CPLCNO,CPWKPS       SET CPLCNO IN CASE LAST\n         LA    1,CPWKPS       SAVED LINE NO\n         CVCALL LOCATE        SETUP FOR DORPIN & CHECK IF LINE N\n         TM    CPDRPT,CPFMTCH MUSN'T ALREADY EXIST\n         BO    BLASTA         NG\n         MVC   CPNWLN,CPLCNO       SET NEXT LINE FOR DESPOT\n         TM    CPDRPT,CPFNTYT+CPFHIGH SEE IF NEXT LINE EXISTS\n         BNZ   NOLINE      BRANCH NO AROUND FLAG SET\n         OI    CPLFLG4,CPFDESET    TELL DESPOT THAT LINE SET\nNOLINE   L     15,CPWKPS      LINE NO TO R15\n         ST    R15,CPCURRL         UPDATE CURRENT LINE POINTER\n         LR    R1,R5               POINTER TO R1\n         LR    R0,R4          COUNT TO R0\n         CVCALL PRESS         PRESS\n         CVCALL STOWIT        PUT AWAY\n         L     0,CPWKPS       LINE NO USED\n         LA    1,1            KICK MINIMUM\n         CVCALL ADDER\n         ST    0,CPWKPS       SAVE AS DEFAULT FOR NEXT\n         XEXIT 0,8            BYE-BYE\n         SPACE 3\nBLASTA   LR    R0,R4\n         LR    R1,R5\n         TSEG  (1),(0),W\n         TSEG  'ABOVE LOST BECAUSE NUMBER NEEDED',,M\n         B     CVQTYPE\n         EJECT\n* DO A LOCAL RENUMBER OF LAST SECTION DONE BY ALIGN\nRENUMB   TM    CPLFLG5,CPFNONUM    WILL NUMBER COMMAND BE CALLED\n         BZR   R14                 YES, RETURN WITHOUT ACTION\n         XENTER 5,8,*\n         L     R5,CPWKPS           GET NEXT NUMBER TO USE\n         LTR   R5,R5               IS IT STILL VALID\n         BM    RENUMBEX            BRANCH NO TO EXIT\n         BCTR  R5,0                REDUCE BY ONE\n         ST    R5,CPWKPS           SET TO LAST NUMBER USED\n         S     R5,ALFRSTSV         GET LINE COUNT - 1\n         BNP   RENUMBEX            EXIT IF NOT POSITIVE\n         L     R1,ALLNOSV          GET LAST LINENO THAT CAN BE USED\n         S     R1,ALFRSTSV         GET VALUE RANGE THAT CAN BE USED\n         SR    R0,R0               ZERO FOR DIVIDE\n         DR    R0,R5               CALCULATE POSSIBLE DELTA\n         CVCALL SELDELTA           CONVERT IT TO ACTUAL DELTA\n         ST    R1,CPWKDL           SAVE DELTA TO USE\n         L     R0,ALFRSTSV         SET FIRST LINE NO TO USE\n         CVCALL FIXNUMB            GO FIX UP NUMBERS IN FILE\n         ST    R0,CPCURRL          UPDATE CURRENT LINE POINTER\nRENUMBEX XEXIT 5,8                 RETURN\n         DROP  R6\n         SPACE 3\n         DS    0F\nALNWKAD  DC    AL1(DESRTRN+LOCATRTN+DESMATCH+UNPRST+DESRELA)\n         DC    AL3(WRKALIN-P011)    WORK ADDRESS\n         TITLE 'END OF PAGED CODE -- PAGE 11'\n         PINIT\n         PEND\n         TITLE 'START OF PAGED CODE -- PAGE 12'\nP012     PAGECDE SHOCAT\n         WIDENT 001\n         TITLE 'SHOW CATALOG AND SHOW DIRECTORY -- PAGE 12'\n* SHOW/PUT DIRECTORY/CATALOG ROUTINE\n*\n* WORK AREA FORMAT SIMILAR TO SHOW DSNAMES EXCEPT THE FIRST\n* 16 BYTES AFTER THE NORMAL DSNAME WORK AREA ARE USED FOR\n* THE LOWER AND UPPER BOUND MEMBER NAMES AND THE FOLLOWING\n* 20 BYTES USED AS WORK SPACE.\n*    WORD 1 OF WORK SPACE CONTAINS ADDR OF RESCAN ROUTINE.\n*    WORDS 2-5 USED TO SAVE REGS WHEN NECESSARY.\n         SPACE 3\nPSHOCAT  GENTER ,\n         XC    CPWK6(4),CPWK6\n         DENTER DSSIZ+SDSNQSZ,C20,,NO\n         XC    CPDSNWA+DSSIZ(8),CPDSNWA+DSSIZ     CLEAR FROM\n         MVI   CPDSNWA+DSSIZ+8,X'FF'           TO/THRU FIELD\n         MVC   CPDSNWA+DSSIZ+9(7),CPDSNWA+DSSIZ+8 THRU FIELD\n         CLI   CPCMNM,C'C'\n         BNE   DSNMDFLT\n         OI    CPLFLG3,CPFTYPE      DEFAULT 'TYPE' FOR SHO CAT\n         OI    CPLFLG2,CPFDSNMS     NULL/NO DEFAULT DSN OK\n         SPACE 3\nDSNMDFLT SCTELL ,\n         SH    R1,=H'2'            GO BACK TWO CHARS\n         AH    R0,=H'2'            ADJUST LENGTH\n         ST    R1,0(,R13)          SAVE BUFFER POINTER\n         MVC   4(2,R13),0(R1)      SAVE WHATEVER WAS THERE\n         LA    R13,8(,R13)         STEALING 8 BYTES\n         MVC   0(2,R1),=C'# '      MOVE IN DUMMY OPERAND\n         SCINIT (1),(0)            REINIT SCANNER\n         CVCALL DODSNM       GO CONSTRUCT DEFAULT LIKE PATTERN\n         S     R13,=F'8'\n         L     R14,0(,R13)\n         MVC   0(2,R14),4(R13)     MOVE BACK WHATEVER WAS THERE\n         SPACE 3\nMBRESCAN TM    CPLFLG3,CPFPUT\n         BO    FIRSTDID\n         SCAN  COMPRT\n         B     POLCHEK\n         SPACE\nFIRSTDID NI    CPLFLG5,255-CPFNLST\n         L     R0,CPHIPS                HIGHEST LINE NO. YET\n         L     R1,CPGLDL                GLOBAL DELTA\n         CVCALL LOWMULT                 GET MULTIPLE\n         CVCALL ADDER                   ADD\n         STM   R0,R1,CPWKPS\n         OI    CPWKDL,FNEGBT       SET DELTA NOT SPEC. YET\nNOTFIRST SCAN  PUTSTUFF\nPRYPRY   TM    CPLFLG2,CPFCLEAR    WAS CLEAR SPECIFIED\n         BZ    PRYOUT              BRANCH NO\n         CVCALL DOCLEAR            GO CLEAR ACTIVE FILE\n         LM    R2,R3,CPWKPS        SAVE COLLECT VALUES\n         LTR   R6,R6               WAS A LINE NUMBER GIVEN\n         BZ    PRYCLR2             BRANCH YES\n         L     R2,CPGLDL           NO, SET START TO DELTA\nPRYCLR2  TM    CPWKDL,FNEGBT             WAS DELTA SPE?\n         BZ    PRYCLR1                   YES. BRANCH\n         L     R3,CPGLDL\nPRYCLR1  STM   R2,R3,CPWKPS        RESET COLLECT VALUES\nPRYOUT   MVC   CPNXPS(4),=F'100000000' SET COMPARAND TOO HIGH\n         OI    CPLFLG4,CPFSTSPL+CPFSTINS SET SO STOWIT WILL ONLY\n         NI    CPWKDL,255-FNEGBT\n         TM    CPWKPS,FNEGBT            ILLEGAL LINE NO.?\n         BO    BADLINES                 YES\n         LA    R1,CPWKPS                1ST LINE NO. FOR LOCATE\n         CVCALL LOCATE                  LOCATE\n         TM    CPDRPT,CPFMTCH           MATCHING LINE NO.?\n         BO    BADLINEM                  YES\n         TM    CPDRPT,CPFNTYT+CPFHIGH   OK TO COLLECT TILL 9999.9\n         BNZ   POTCHEK                  YES\n         MVC   CPNXPS(4),CPLCNO         SET COMPARAND TO NEXT LIN\nPOTCHEK  L     R0,CPWKPS                LINE NO. TO COLLECT\n         ST    R0,CPCURRL          SET CURRENT LINE\n         C     R0,CPNXPS                STILL SMALL ENOUGH?\n         BNL   PUTERC                   NO\n         ST    R0,CPLCNO                STILL SMALL ENOUGH?\n         TM    CPLFLG2,CPFSCRTC\n         BZ    PUTNOCHK\n         NI    CPLFLG5,255-CPFNTEX-CPFNLST\nPUTNOCHK TM    CPLFLG5,CPFNLST\n         BZ    POLCHEK\n         TM    JCBAFL,JCBSYSPR     SYSTEM PRIVILEGES?\n         BO    POLCHEK             NO. CANT SET NOLIST\n         NI    CPLFLG5,255-CPFNLST NO LIST\nPOLCHEK  XC    CPMDLN(4),CPMDLN    INDICATE NO PAGES\n         TM    CPLFLG3,CPFSET      'SET'?\n         BZ    POLCHEK2            NO SET.\n         CVCALL SETPFXNS           GO SET PREFIX\nPOLCHEK2 CLI   CPCMNM,C'C'         CAT ?\n         BE    SCATRSCN\n         CVCALL VOLCHEK\nDODPDSD  NI    CPLFLG3,255-CPFPMSG\n         DPDSD ,                   CALL SHOW PDS\n         B     DSMBRCOM            GO TO COMMON CODE\n         SPACE 3\nMBREXCL  CLI   CPDSNWA+DSSIZ,X'00'\n         BNE   IGNEXOPT\n         OI    CPLFLG3,CPFEXCL     EXCLUDE FLAG\n         SPACE\nMBRFROM  LA    R15,CPDSNWA+DSSIZ   ADDR OF FROM FIELD\n         CLI   0(R15),X'00'\n         BNE   IGNFROPT\n         B     MBRFMTO\n         SPACE\nMBRTO    TM    CPDSNWA+DSSIZ+8,X'FF'\n         BM    IGNTOOPT\n         XC    CPDSNWA+DSSIZ+8(8),CPDSNWA+DSSIZ+8\n         SPACE\nMBRTHRU  LA    R15,CPDSNWA+DSSIZ+8    ADDR OF TO/THRU FIELD\n         TM    0(R15),X'FF'\n         BM    IGNTHOPT\n         SPACE 3\nMBRFMTO  CLI   0(R1),C'#'          POSSIBLE SAVED MEMBER USAGE?\n         BE    MBRFMTO2            BR IF YES\n         CLI   0(R1),C'*'          ALSO ACCEPT \"*\"\n         BNE   NOFTSVM             BR IF NO\nMBRFMTO2 BCT   R0,MBRNOISE         BR IF #/* IS NOISE\n         CLI   CPCMNM,C'C'         IS IT SHOW CATALOG?\n         BE    MBRNOISE            BR IF YES - */# NOT VALID\n         CLI   CPMEMBSV,X'40'      IS THERE ONE?\n         BER   R14                 BR IF NO - IGNORE\n         LA    R1,CPMEMBSV         ADDR OF SOURCE\n         LA    R4,7(R1)            ADDR OF LAST CHAR\n         LA    R0,8                LENGTH\nMBRFTLP  CLI   0(R4),X'40'         BLANK?\n         BNE   NOFTSVM             BR IF YES - HAVE LENGTH\n         BCTR  R4,0\n         BCT   R0,MBRFTLP\nNOFTSVM  LR    R4,R1\n         CH    R0,=H'8'            CHECK LENGTH\n         BH    CVNVALID            BR IF TOO LONG.\n         LTR   R2,R0\n         BZR   R14                 BR IF NULL\n         BCTR  R2,0                FOR EX\n         EX    R2,FMTOMVC          MOVE FIELD\n         BR    R14\n         SPACE 3\nMBRNOISE LR    R2,R7               MUST SAVE R7\n         STM   R14,R1,4(R8)        SAVE REGS\n         TSEG  (1),1,B             TELL USER HIS #/*\n         TSEG  'IGNORED',,M        WAS IGNORED.\n         LM    R14,R1,4(R8)        RESTORE REGS\n         LA    R1,1(R1)            BUMP PAST NOISE CHAR\n         LR    R7,R2               RESTORE R7\n         B     NOFTSVM\n         SPACE 3\nHAVTO    LA    R6,POTLNENO-P012    SET LINE NUMBER RETURN\n         LCR   R6,R6               SET NEGATIVE TO FLAG RELATIVE\n         SCAN  LINPRT              GO GET TO LINE\n         B     CVABSENT            MISSING IF NOTHING FOUND\n         SPACE\nPOTLNENO ST    R0,CPWKPS                SET NEW LINE NO. & DELTA\n         TM    CPWKDL,FNEGBT             WAS DELTA SPE?\n         BZ    POTDEL                    YES. BRANCH\n         ST    R1,CPWKDL\nPOTDEL   SR    R6,R6               FLAG HAVE LINE NUMBER\n         B     NOTFIRST\n         SPACE\nPOTDLL   LTR   R15,R15                  ZERO NG\n         BZ    CVNVALID                 NG\n         ST    R15,CPWKDL               STORE COLLECT DELTA\n         B     NOTFIRST\n         SPACE 3\n* BAD LINE NO. MESSAGE\n         SPACE\nBADLINEM L     R0,CPLCNO           GET BAD LINE NUMBER\n         CVCALL CVEXNO             CONVERT TO EXTERNAL FORM\n         TSEG  (1),(0),B           PUT IT IN MESSAGE\n         SPACE\nBADLINES TSEG  'LINE NO.'\n         B     CVUNLEGL\n         SPACE\nPUTERC   TSEG  'NO REPLACE OR INTERLEAVE'\n         B     CVQTYPE\n         SPACE\nFMTOMVC  MVC   0(0,R15),0(R4)      MOVE FROM/THRU STRING\n         EJECT\n* COME HERE IF COMMAND IS SHOW/PUT CATALOG\n         SPACE\nSCATRSCN LH    R15,DSNWANL         PATTERN LENGTH\n         LTR   R15,R15             IS IT NULL\n         BNP   SCATCALL            BR IF YES\n         LA    R1,DSNWADSN-1(R15)  ADDR OF LAST CHAR IN PATTERN\n         CLI   0(R1),C'.'          IS IT DELIMITER\n         BNE   SCATCALL            BR IF NOT\n         MVI   0(R1),X'40'         LOCATE BARFS ON TRAILING PER\n         BCTR  R15,0               DECR LENGTH\n         STH   R15,DSNWANL         STORE NEW LENGTH\nSCATCALL DSHCAT ,                  GO DO CATALOG SEARCH\nDSMBRCOM LTR   R9,R9              PAGE  9 IN?\n         BZ    SKIPMRK            NO\n         PMARK R9\nSKIPMRK  LTR   R15,R15            BAD VOL., TALO, ABORT OR ERROR?\n         BZ    WRIDSSP2           NO\n         CH    R15,=Y(RTNPAGES)    NOT ENUF PAGES?\n         BNE   ATTNHIT\n         OI    CPLFLG3,CPFPMSG\n         TSEG  'INSUFFICIENT PAGES FOR COMPLETE OUTPUT',,W\n         B     WRIDSSP2\n         SPACE\nATTNHIT  CH    R15,=Y(RTNSHERR)    SHOW RTN ERROR?\n         BNE   CALLNGO             BR IF NOT\n         TSEG  'PROCESSING BREAK',,W\n         LTR   R9,R9                    ANYTHING?\n         BZ    CVGETCOM                 NO - GET NEW COMMAND\nWRIDSSP2 L     R4,CPWK6            STORED BY PDIO\n         LTR   R4,R4\n         BZ    WRIDSSP1\n         L     R1,CPNXPS           GET FIRST ILLEGAL\n         S     R1,CPWKPS           SUBT FIRST LINENO TO GET SIZE\n         SR    R0,R0               ZERO FOR DIVIDE\n         DR    R0,R4               CALCULATE MAXIMUM DELTA\n         C     R1,CPWKDL           IS WORK DELTA LESS OR EQUAL\n         BNL   WRIDSSP1            YES, USE WORK DELTA\n         CVCALL SELDELTA           CONVERT IT TO ACTUAL DELTA\n         ST    R1,CPWKDL           SAVE DELTA TO USE\nWRIDSSP1 PCALL WRICTDR                 TO 2741'S\n         SPACE\nCALLNGO  PCALL NTGDOPN\n         EJECT\nDSNMTYPE CLI   CPCMNM,C'C'         CAT?\n         BE    CVNVALID\n         OI    CPLFLG3,CPFTYPE\n         BR    R14\n         SPACE\nDSNMNTYP CLI   CPCMNM,C'C'\n         BNE   CVNVALID\n         NI    CPLFLG3,255-CPFTYPE\n         BR    R14\n         SPACE\nDSNMSCRT DS    0H\n         CLI   CPCMNM,C'C'              CAT?\n         BE    CVNVALID\n         OI    CPLFLG2,CPFSCRTC         SET \"SCRATCH\" MODE\n         BR    R14                       LOOK FOR MORE\n         SPACE\nADLIKE   MVC   4(6,R8),DSNWAVOL    SAVE VOLUME\n         CVCALL DODSNM\n         CLI   DSNWAVOL,C' '       WAS VOLUME FOUND IN SCAN?\n         BNE   MBRESCAN            BR IF YES\n         CLI   4(R8),C' '          WAS VOLUME THERE BEFORE?\n         BE    MBRESCAN            GO START SCAN AGAIN\n         MVC   DSNWAVOL(6),4(R8)   RESTORE OLD VOLUME\n         B     MBRESCAN            GO START SCAN AGAIN\n         SPACE\nSETUNC   CLI   CPCMNM,C'C'         CAT?\n         BNE   CVNVALID\n         OI    CPLFLG3,CPFUNCLG    SET UNCATLG OPTION\n         BR    R14                 SCAN ON\n         SPACE\nIGNEXOPT STM   R14,R1,4(R8)\n         LR    R2,R7\n         TSEG  'EXCLUDE',,B\nIGNCOMM1 TSEG  'OPTION IGNORED',,W\n         LM    R14,R1,4(R8)\n         LR    R7,R2\n         BR    R14\n         SPACE\nIGNFROPT STM   R14,R1,4(R8)\n         LR    R2,R7\n         TSEG  'FROM',,B\n         B     IGNCOMM1\n         SPACE\nIGNTOOPT STM   R14,R1,4(R8)\n         LR    R2,R7\n         TSEG  'TO',,B\n         B     IGNCOMM1\n         SPACE\nIGNTHOPT STM   R14,R1,4(R8)\n         LR    R2,R7\n         TSEG  'THRU',,B\n         B     IGNCOMM1\n         SPACE 3\n* SCAN TABLES FOR SHOW DIRECTORY\n         SPACE\nPUTSTUFF SCKW  AT,HAVTO\n         SCKW  BY,POTDLL,(P,LN)\nDAPRC    SCKW  ,,PUSH        FILLED IN AT INIT TO CLRPRT\nLAPRC    SCKW  ,,PUSH        FILLED IN AT INIT TO LTNPRT\nCOMPRT   SCKW  ALL,DSNMTYPE\n         SCKW  SCRATCH,DSNMSCRT,A\n         SCKW  IN,ADLIKE\n         SCKW  FOR,ADLIKE\n         SCKW  UNCATLG,SETUNC,A\n         SCKW  NOTYPE,DSNMNTYP,A\n         SCKW  FROM,MBRFROM,(P,A)\n         SCKW  EXCLUDE,MBREXCL,(P,A)\n         SCKW  THROUGH,MBRTHRU,(P,A)\n         SCKW  THRU,MBRTHRU,P\n         SCKW  TO,MBRTO,P\nCOMPRT3  SCKW  ,,PUSH              FILLED IN AT INIT TO IGDSNPRT\n         SCKW  ,BADPUT\n         SPACE\nLINPRT   SCKW  ,,PUSH          FILLED IN AT INIT TO LNENOPRT\n         SCKW  ,BADPUT\n         SPACE 3\nBADPUT   B     CVNVALID\n         TITLE 'GETTPAG ROUTINE'\nGETTPAGY XENTER 15,8,44       SAVE SPACE (USED BY SHOW DSNAMES)\nGETTPAG  EQU   GETTPAGY-P012        MAKE RELATIVE ADDRESS\n         L     2,CPMDLN       NO PAGES ALREADY\n         LTR   2,2            ANY?\n         BNP   GETTNO1\n         PMARK R9\n         CH    R2,=Y(10)                10 MAX\n         BNL   SENSAME\nGETTNO1  PGET  R9\n         BZ    SENSAME\n         LA    2,1(2)         ONE MORE\n         ST    2,CPMDLN       STORE\n         SLL   2,2            POINT AT PLACE TO STORE PAGE NO\n         ST    0,CPMDAD-4(2)  STORE PAGE NO\nSENSAME  LTR   R9,R9\n         XEXIT 15,8\n         TITLE 'END OF PAGED CODE -- PAGE 12'\n         PINIT\n         MVC   COMPRT3+1(3),CVIGDSN+1 SET TO IGDSNPRT\n         MVC   LINPRT+1(3),CVLNENO+1  SET TO LNENOPRT\n         MVC   DAPRC+1(3),CVCLRPR+1   SET TO CLRPRT\n         MVC   LAPRC+1(3),CVLTNPR+1  SET TO LTNPRT\n         PEND\n         TITLE 'START OF PAGED CODE -- PAGE 13'\nP013     PAGECDE WRICTDR\n         WIDENT 001\n         TITLE 'WRITE OUTPUT FOR SHOW CAT/DIR -- PAGE 13'\n* WRICTDR IS USED TO LIST INFORMATION PASSED FROM SHOW CATALOG\n* AND SHOW DIRECTORY\n*   CPMDLN CONTAINS THE NUMBER OF PAGES OF INFORMATION.\n*   CPMDAD CONTAIN UP TO TEN PAGE NUMBERS.\n*   THE FIRST HALF-WORD ON EACH PAGE IS THE PAGE BYTE-COUNT.\n*   EACH FIRST BYTE IN A LINE IS THE CHARACTER COUNT FOR THE LINE.\n*   A LINE CHARACTER COUNT OF ZERO INDICATES ALL DONE.\n*\n* THE WORD AFTER 'DSSIZ' (DSSIZ+4 BELOW) IS USED TO STORE\n* THE SKIP COUNT FOR SHOW DSNAMES AND THE ORIGINAL\n* PATTERN LENGTH FOR SHOW CATLG.\n         SPACE\nPWRICTDR DENTER DSSIZ+4,SDSNDSZ-DSSIZ+SBSZ\n         NI     CPLFLG3,255-CPFPUTER\n         L     R5,CPMDLN                NO. PAGES\n         LA    R6,CPMDAD-4              4 BYTES B/4 1ST PAGE NO\n         SR    R4,R4\n         LTR   R5,R5                    ANY?\n         BP    GTNXTPG             BR YES TO START OUTPUT\n         PCALL NOMORPG             GO REPORT OUT OF PAGES\n         SPACE\nGTNXTPG  LA    R6,4(R6)                 POINT AT NEXT PAGE NO\n         LTR   R9,R9                    PAGE IN?\n         BZ    GETNXPG                  NO\n         PNUM  R9                       WHICH PAGE IS IN?\n         C     R0,0(R6)                 RIGHT ONE?\n         BE    PROCPAG                  YES\nGETNXPG  L     R0,0(R6)                 PAGE NO NEEDED\n         PGET  R9,(0)                   GET IT\n         LTR   R4,R4\n         BNZR  R4\nPROCPAG  LA    R3,2                     NO. BYTES PROCESSED ON PAGE\nNEXTLINX CH    R3,0(R9)            MORE ON PAGE?\n         BNL   GONXPAG                  NO\n         TM    CPLFLG2,CPFSTOP          TEST IF MORE WANTED\n         BNZ   GONXPAG                  NO MORE\n         SR    R2,R2\n         IC    R2,0(R3,R9)              LINE CHAR COUNT\n         LTR   R0,R2                    ANY?\n         BZ    ALLDONN                  NO\nLOADAFC  LA    R1,1(R3,R9)         POINT AT 1ST CHAR IN LINE\n         SPACE 3\n* FORMAT AND WRITE INFORMATION FOR SHOW DIRECTORY COMMAND.\n*\n* REGISTERS ARE USED AS FOLLOWS:\n*    R2    CHAR COUNT IN LINE OF DATA.\n*    R3    NUMBER OF BYTES PROCESSED IN CURRENT PAGE.\n*    R4    POINTS TO CURRENT INPUT LINE (SDSNBUF).\n*    R5    NUMBER OF PAGES TO BE PROCESSED.\n*    R6    PAGE INDEX POINTER.\n         SPACE\n         CH    R2,=H'6'            CHECK VOLUME ID MSG\n         BH    WRMBR               WHICH IS USED AS A FLAG\n         LH    R0,DSNWANL          TO WRITE THE DSNAME.\n         STH   R0,CPDSNWA+DSSIZ    SAVE ORIG PATTERN LENGTH\n         TSEG  DSNWADSN,(0)\n         TM    CPLFLG3,CPFPUT\n         BZ    LWRITE\n         B     DIDNTADD\n         SPACE\nWRMBR    CLC   =C'CAT',CPCMNM      IS IT SHOW CATALOG?\n         BE    WRCAT               BR IF YES\n         MVC   DSNWAMBR(8),0(R1)    MOVE MEMBER IN CASE SCR\n         TM    CPLFLG3,CPFTYPE     OTHER STUFF WANTED?\n         BZ    WRMBONLY            BR IF NO\n         TSEG  (1),8               FULL LENGTH FOR COL ALIGN\n         LA    R4,8(R1)            POSIT PTR AFTER MEMBER\nWRMBRLP  EX    0,LOADAFC           GET ADDR OF 1ST CHAR\n         LR    R15,R1\n         SR    R15,R4              -(LENGTH PROCESSED)\n         AR    R15,R2              LENGTH REMAINING\n         BNP   NOWWHAT             BR IF DONE\n         TSEG  '  '\n         CH    R15,=H'4'           IS IT GREATER THAN FULLWORD?\n         BNH   *+8                 BR IF NO\n         LA    R15,4               PROCESS FULLWORD ONLY\n         LR    R0,R15              SAVE FOR LATER\n         LA    R1,CPDOUB+4         END OF FULLWORD WORK AREA\n         SR    R1,R0               ADDR OF LOW ORDER CHARS\n         BCTR  R15,0               FOR EX\n         EX    R15,WRMBRMVC        MOVE THEM\n         SLL   R0,1                FOR BTX HEX LENGTH\n         BTX   0(R8),(0),CPDOUB    CONVERT TO HEX\n         TSEG  (1),(0)             TSEG THEM\n         SRL   R0,1                RESTORE ACTUAL LENGTH\n         AR    R4,R0               UPDATE POINTER\n         B     WRMBRLP\n         SPACE 3\n* LIST MEMBER NAME ONLY\nWRMBONLY CVCALL MEMBERED           GO TSEG MEMBER NAME\n         B     NOWWHAT\n         SPACE\nWRMBRMVC MVC   0(0,R1),0(R4)\n         SPACE 3\n* FORMAT AND WRITE INFORMATION FOR SHOW CATALOG COMMAND\n         SPACE\nWRCAT    MVC   0(SCBSZ,R8),0(R1)   MOVE FOR ALIGNMENT\n         USING SCBUF,R4\n         LR    R4,R8               ADDR OF ITEM\n         MVC   DSNWAMBR,SCBNM      GET LEVEL NAME\n         SR    R0,R0               IN CASE DUMMY NAME\n         CLI   SCBNM,X'FF'         IS IT DUMMY NAME?\n         BE    WCNMDONE            BR IF YES - NAME SPECIFIED\n         CVCALL MEMBERED\nWCNMDONE STH   R0,DSNWANL          SAVE LENGTH OF LEVEL NM\n         TM    CPLFLG3,CPFTYPE     WAS 'NOTYPE' SPECIFIED?\n         BZ    WCDCOM              BR IF YES\n         CLI   SCBCODE,C'D'        IS IT DSNAME ENTRY?\n         BE    WCDD\n         CLI   SCBCODE,C'I'        INDEX ENTRY?\n         BE    WCDI\n         CLI   SCBCODE,C'C'        CVOL ENTRY?\n         BE    WCDC\n         CLI   SCBCODE,C'G'        GDG ENTRY?\n         BE    WCDG\n         CLI   SCBCODE,C'A'        ALIAS ENTRY?\n         BE    WCDA\n         DIE   ,                   ERROR - ABEND\n         SPACE 3\nWCDD     TSEG  '- ON',,B\n         CLI   SCBVOL,X'FF'        IS IT DUMMY VOL ENTRY?\n         BE    WCDDGT5V            YES - MORE THAN 5 VOLS\n         TSEG  SCBVOL,6,B\n         LH    R15,SCBNVOLS        NUMBER OF VOLS\n         CH    R15,=H'1'           IS IT ONE VOL?\n         BNH   WCDCOM              YES - DON'T BOTHER\n         B     WCDDNV\n         SPACE\nWCDDGT5V TSEG  '>'\n         LA    R15,5\nWCDDNV   BTD   CPDOUB,0,(15)\n         TSEG  (1),(0),B\n         TSEG  'VOLS'\n         B     WCDCOM\n         SPACE\nWCDI     TSEG  '- INDEX'\n         B     WCDCOM\n         SPACE\nWCDC     TSEG  '- CVOL',,B\n         TSEG  SCBVOL,6\n         B     WCDCOM\n         SPACE\nWCDG     TSEG  '- GDG',,B\n         LH    R15,SCBNVOLS        NUMBER OF GDG ENTRIES\n         BTD   CPDOUB,0,(15)\n         TSEG  (1),(0),B\n         SR    R15,R15\n         IC    R15,SCBMAX          MAX NUMBER TO BE KEPT\n         CH    R15,SCBNVOLS        IS MAX = ACTUAL?\n         BE    WCDGMAX             BR IF YES\n         TSEG  'OF',,B\n         BTD   CPDOUB,0,(15)\n         TSEG  (1),(0),B\nWCDGMAX  TSEG  'GENS'\n         B     WCDCOM\n         SPACE\nWCDA     TSEG  '- ALIAS FOR',,B\n         MVC   DSNWAMBR,SCBNM2     ALIAS NAME\n         CVCALL MEMBERED\n         MVC   DSNWAMBR,SCBNM      RESTORE ORIG NAME\n         SPACE\n         DROP  R4\n         SPACE 3\n* COMMON ROUTINE FOR SHOW CATLG\n         SPACE\nWCDCOM   TM    CPLFLG3,CPFUNCLG    WAS UNCATLG SPECIFIED?\n         BZ    NOWWHAT\n         LA    R15,DSNWADSN\n         LH    R0,CPDSNWA+DSSIZ    GET PATTERN LENGTH\n         LA    R4,43               L'DSNAME-1\n         AR    R15,R0              FIRST CHAR FOLL PATTERN\n         SR    R4,R0               REMAINING AFTER DSN\n         BM    WCDCMGTL            BR IF L'DSN=44\n         MVI   0(R15),X'40'\n         BZ    WCDCMGTL            BR IF L'DSN=43\n         BCTR  R4,0\n         EX    R4,WCDCMCLR         CLEAR AFTER PATTERN\n         LH    R4,DSNWANL          LENGTH OF CURR INDEX NAME\n         LTR   R4,R4               TEST IT\n         BZ    WCDCMGTL            NO INDEX - PATTERN COMPLETE\n         LTR   R0,R0               TEST NULL PATTERN\n         BZ    WCDCOMNP            BR IF YES\n         MVI   0(R15),C'.'         INSERT INDEX DELIMITER\n         LA    R15,1(R15)          BUMP POINTER\n         AH    R0,*-2              AND LENGTH\nWCDCOMNP AR    R0,R4               TOTAL LENGTH\n         BCTR  R4,0\n         EX    R4,WCDCMMVC         MOVE CURR NAME\nWCDCMGTL STH   R0,DSNWANL          SAVE TOTAL LENGTH\n         CVCALL DSNSTDDO            GO SET DSN FLAGS\n         CVCALL DSNUDSDO\n         B     PPROMPTT            GO CHECK FOR PROMPT\n         SPACE 3\nWCDCMMVC MVC   0(0,R15),DSNWAMBR\nWCDCMCLR MVC   1(0,R15),0(R15)\n         EJECT\nNEXTRY   LR    R15,R1                  GET ADDR OF LAST CHAR\n         AR    R15,R0\nNEXTRYX  BCTR  R15,0                   BACK UP ONE CHAR\n         CLI   0(R15),C' '              BLANK?\n         BNE   NOWTSEG             NO\n         BCT   R0,NEXTRYX\nNEXTLIN  LA    R3,1(R3,R2)             COUNT TO NEXT LINE\n         B     NEXTLINX\n         SPACE\nNOWTSEG  TSEG  (1),(0)\nNOWWHAT  TM    CPLFLG3,CPFPUT            PUT?\n         BZ    DONTPUT                   NO. BRANCH.\nPONEXT   LM    R0,R1,CPWKPS             LINE NO.\n         CVCALL ADDER                   ADD\n         BM    POTERD                   TOO BIG\n         ST    R0,CPWKPS                SAVE NEXT LINE NO.\n         ST    R0,CPLCNO                FOR LISTLINE ROUTIN\nDIDNTADD MVC   0(133,R8),RTBTEXT        INTO WORK AREA\n         LH    R0,RTBWC\n         LR    R1,R8                    SET POINTER\n         L     R15,CPWKPS               LINE NO. INTO R15\n         CVCALL PRESS                   PRESS\n         CVCALL STOWIT                  STOW IT AWAY\n         BM    POTERC                   REPL ERR\n         BNZ   BADFIT\n         MVC   CPCURRL(4),CPWKPS\n         PNUM  R9                       CHECK ON R9?\n         C     R0,0(R6)\n         BE    NOWWRIT\n         BAL   R4,GETNXPG               GET IT BACK\n         SPACE 3\nNOWWRIT  LH    R0,RTBWC\n         MVC   RTBWC(4),=XL4'0'\n         TM    CPLFLG5,CPFNLST          NOLIST?\n         BO    NEXTLIN                  YES   BRANCH.\n         MVC   0(133,R8),RTBTEXT        INTO WORK AREA\n         LR    R1,R8\n         CVCALL LISTLINE\n         BP    DSNMATTN         ATTN HIT BRANCH\nDONTPUT  TM    CPLFLG2,CPFSCRTC         \"SCRATCH\" OPTION?\n         BO    PPROMPTT                 YES\nLWRITE   TM    CPLFLG3,CPFPUT           PUT?\n         BO    NEXTLIN                  IF SO LINE PRINTED.\n         TWRITE ,\n         BP    DSNMATTN\n         B     NEXTLIN\n         SPACE 3\n*\nBADFIT   LR    R2,R15              NOT A FAIR TRADE..\n         B     CALLPERR            HI HO...\n*\nPOTERD   LA    R2,4\n         B     CALLPERR\n         SPACE\nPOTERC   LA    R2,8\nCALLPERR OI    CPLFLG3,CPFPUTER\nDSNMATTN OI    CPLFLG2,CPFSTOP          SET TO PRINT NO MORE\nGONXPAG  PFREE R9,EMPTY                 SCRATCH PAGE\n         SR    R4,R4\n         BCT   R5,GTNXTPG               GET NEXT PAGE (IF ANY)\nALLDONN  PFREE R9,EMPTY                 SCRATCH LAST PAGE\n         TM    CPLFLG3,CPFPUTER\n         BZ    CVGETCOM                  AND AWAY WE GO...\nPUTTYERR PCALL DSNERR\n         EJECT\n* PROMPT FOR SCRATCH IF DATA SET IS CANDIDATE FOR SCRATCHING\n* BY THIS USER.  OTHERWISE, FORGET THE PROMPT.\n         SPACE\nPPROMPTT TM    JCBAFL,JCBSYSPR     SYSTEM PRIVILEGES?\n         BO    PPETC2              YES..LET NOLIST STAY\n         TM    DSNWAF1,DSNFMYDS    BELONG TO USER?\n         BZ    LWRITE              BR IF NO\nPPETC2   SR    R2,R2\n         IC    R2,0(R3,R9)              LINE CHAR COUNT\n         CH    R2,=H'6'            CHECK VOLUME ID MSG\n         BNH   LWRITE              WHICH IS USED AS A FLAG\n         TM    CPLFLG5,CPFPUT\n         BO    NOPMARK\n         TMARK\nNOPMARK  SYSQS R1,R0,'SCRATCH'\nPPCATCLC CLC   =C'CAT',CPCMNM\n         BNE   PPETC3\n         SYSQS R1,R0,'UNCATLG'\nPPETC3   TREADR (1),(0)\n         BP    DSNMATTN            ABORT IF ATTENTION\n         SCINIT (1),(0)                 INIT SCAN\n         SCAN  YESSPRT                  LOOK FOR \"YES\"\n         B     NEXTLIN                   DO MORE\n         SPACE\nYESREPLY EX    0,PPCATCLC\n         BE    SUNCAT\n         CLI   0(R1),C'U'          DID USER SAY UNCATLG\n         BE    NEXTLIN             YES,   DON'T SCATCH\n         DSCRATCH ,                SCRATCH IT\n         BZ    NEXTLIN                   ON TO NEXT\n         L     R14,CVMEMBER        ADDR OF MEMBERED\n         BALR  R14,R14             GO TO PROPER ROUTINE\n         TSEG  'NOT SCRATCHED',,W\nYESRETN  BP    DSNMATTN\n         B     NEXTLIN                   ON\n         SPACE\nSUNCAT   CLI   0(R1),C'S'          DID USER SAY SCRATCH\n         BE    NEXTLIN             YES, DON'T UNCATLG\n         DCATLG ,\n         BZ    NEXTLIN\n         CVCALL DSNAMED\n         TSEG  'NOT UNCATLG''D',,W\n         B     YESRETN\n         SPACE 3\nYESSPRT  SCKW  YES,YESREPLY\n         SCKW  OK,YESREPLY\n         SCKW  SCRATCH,YESREPLY,A\n         SCKW  UNCATLG,YESREPLY,A\n         SCKW  ,NEXTLIN\n         TITLE 'END OF PAGED CODE -- PAGE 13'\n         PINIT\n         PEND\n         TITLE 'DSECTS'\n*  WORK AREA\n         SPACE\nWA       DSECT\n         XSA   2,8\nLPTR     DS    A                       LOWER LIMIT\nUPTR     DS    A                       UPPER LIMIT\nILEN     DS    A                       LEN OF INSERT\nILOC     DS    A                       LOC\nLEN      DS    A\n         SPACE\nAFL      DS    X                       FLAGS\n         SPACE\nAFD      EQU   X'08'                   DELETE\nAFI      EQU   X'04'                   INSERT\nAFCHOP   EQU   X'02'                   CHOPPED OFF\nAFATTNC  EQU   X'01'                   $ATTN\n         SPACE\nWASIZE   EQU   *-WA\n         TITLE 'CONSTANTS, ETC.'\n         COPY  WYLCONST\nCHEXCLAM EQU   X'5A'   EXCLAMATION POINT\n         EJECT\n         COPY  RTNCODES\n         TITLE 'COPY MODS'\nSDSNBUF  DSECT\n         COPY  SDSNBUF\n         SPACE 3\n         COPY  SCATBUF\n         EJECT\nALWA     DSECT          ALIGN WORK AREA DEFINITION\nALFLAGS  DS    X                   ALIGN FLAG BYTE\nALFMRKN  EQU   X'80'               MARKER SPECIFIED FLAG\nALFSPCE  EQU   X'10'               SPACE OPTION SPECIFIED\nALFEVEN  EQU   X'08'               EVEN OPTION SPECIFIED\nALFEBL   EQU   X'04'               EXTRA BLANKS ON LEFT FLAG\nALFSOME  EQU   X'02'               SOMETHING IN BUFFER FLAG\nALLNMRK  DS    CL1                 MARKER CHARACTER\nALMODSV  DS    H                   MOD COUNT TO TELL DISJOINT RNGE\nALLNMAX  DS    H                   LENGTH SAVE SPOT\nALINDST  DS    H                   ALIGN INDENT VALUE\nALINDPA  DS    H                       INDENT FOR NEW PARAGRAPH\nALINDNT  DS    H                   NEXT INDENT VALUE\nALWBUFL  DS    H                   BUFFER LENGTH\nALWPBC   DS    H                   PREVIOUS BLANK COUNT\nALWBC    BNE   0                   NOP OR BNE DIFLEAD\nALWSAVE  DS    3F                  SAVE AREA FOR OUTPUT POINTERS\nALWLAST  DS    A                   LENGTH OF LAST WORD\nALWJPT   DS    A                   POINT TO BEGIN JUSTIFICATION\nALLNOSV  DS    F                   WORK CELL FOR LINE NUMBER\nALFRSTSV DS    F                   FIRST LINE OF RANGE SAVE\nALCLRLEN EQU   *-ALWA              LENGTH TO CLEAR AT START\nALWBL    DS    C                   A BLANK\nALBUFF   DS    CL(SZR)             BUFFER WORK AREA\nALWALEN  EQU   *-ALWA              LENGTH OF WORK AREA\n         EJECT ,\n* NUMBER WORK AREA\n         SPACE\nNUMWORK  DSECT\nNUMFLG   DS    C                   FLAG TO INDICATE FIXIT\nNUMMSG   DS    C                   FLAG TO INDICATE NOT 1ST FIXIT\nNUMFPOS  DS    A                   START RANGE & START LINE NO.\nNUMLPOS  DS    A                   END OF RANGE\nNUMDISP  DS    A                   1ST LINE DISPLACEMENT\nNUMDRPT  DS    A                   1ST LINE DIRECTORY POINTER\nNUMHIGH  DS    A                   FOR HIGH POSITION CHECKING\nNUMWORKL EQU   *-NUMWORK           LENGTH OF DSECT\n         EJECT\n         COMMON\n         SPACE\n         END\n./ ADD NAME=PGOS,SSI=00000002\nPGOS     TITLE 'GO ROUTINES FOR WYLTSO'\n* PROPERTY OF C. U. C. C. A.\n         SPACE 3\n         GBLC    &DCEC             SWITCH FOR DCEC MODS         JEP00X\n         GBLC  &USPS                                            USPS01\n&USPS    SETC  '1'                                              USPS01\n&DCEC    SETC   '1'  CHANGE TO ANY OTHER NUM. TO DELETE DCEC MODJEP00X\n         AIF   ('&DCEC' NE '1').LBL01                           JEP00X\n*                                                               JEP005\n* MOD JEP005                                                    JEP005\n*  ADDED CODE TO RECOGNIZE UPPER & LOWER OPERANDS ON            JEP005\n*  THE CHANGE COMMAND. DENOTED JEP005 IN COL. 66/71.            JEP005\n*             MODULES AFFECTED:                                 JEP005\n*                       PDOS, PGOS, PUTB, AND MACRO CPTSO       JEP005\n*                                                               JEP005\n*                                                               JEP001\n* MOD JEP001                                                    JEP001\n*  IMPLEMENTED DCEC NAMING CONVENTIONS. DENOTED JEP001 IN 66/71 JEP001\n*  MODULES AFFECTED: PDIO,PEDS,PUTB,INIT MACRO(DSNWA,CVTSO)     JEP001\n*                                                               JEP001\n*                                                               JEP001\n*                                                               JEP017\n* MOD JEP017                                                    JEP017\n*  DELETED THE DEFAULT RANGE OF 'ALL' IN CHANGE COMMAND.        JEP017\n*  MODULES AFFECTED: PGOS      DENOTED JEP017 IN 66/71.         JEP017\n*                                                               JEP017\n*                                                               JEP017\n.LBL01   DS    0H                                               JEP00X\nPGOS     CSECT\n         SPACE\n         WIDENT 001\n         SPACE\n         USING CPAREA,R12\n         SPACE\n         XTRNS ,\n         TITLE 'GOCHNG ROUTINE'\n* GOCHNG IS THE PRIMARY ENTRY POINT FOR THE CHANGE COMMAND.  THE SOURCE\n*      AND TARGET FIELDS ARE SET UP, RANGE IS DEFINED AND CONTROL GIVEN\n*      TO DESPOT WHICH CALLS DOCHNG WITH ALL LINES IN THE RANGE.\n         SPACE\nGOCHNG   GENTER ,\n         AIF   ('&DCEC' NE '1').LBL02                           JEP00X\n         NI    CPLFLG3,255-CPFCHALL  TURN OFF CHG ALL FLAG IF ONJEP005\n.LBL02   DS    0H                                               JEP00X\n         SR    R6,R6                    ZERO\n         ST    R6,CPCHLN1               SET REPLACED LEN DEFAULT\n         XC    CPFCOL(4),CPFCOL    CLEAR FILL AREA\n         OI    CPLFLG1,CPFALL          ALLOW DEFAULT ALL\n         SCAN  APRT                     SCAN 1ST STRING OR POSIT\n         B     CVABSENT                 NEED SOMETHING\n         SPACE\nASPOT    CLI   0(R1),C''''              SINGLE QUOTE?\n         BE    AASPOT                   YES\n         CLI   0(R1),C'\"'               DOUBLE QUOTE?\n         BNE   CVNVALID                 NG\nAASPOT   CVCALL DQSCAN                  DEQUOTE QUOTE STRING\n         LTR   R2,R0                    NEED SOME\n         BNP   CVNVALID                 REPLACE WHAT?\n         ST    R8,CPCHAD1               SAVE STRING ADDR\n         BCTR  R2,0                     STRING LENGTH MINUS ONE\n         ST    R2,CPCHLN1               SAVE STRING LEN (MINUS 1)\n         EX    R2,MOVSTRNG              MOVE IT\n         LA    R2,4(R2)                 MULTIPLE OF 4 GTR/EQU STRNG LEN\n         N     R2,=F'-4'                TO RESET R8 & R13\n         AR    R8,R2                    NEW R8\n         LR    R13,R8                   NEW R13 (SAME AS R8 HERE)\n         MVI   CPCHMOD,0                SET DEFAULT MOD\n         LA    R3,BPRT             POINT TO SCAN TABLE\n         BAL   R6,TELLSCAN         GO DO SCAN\n         B     CVABSENT                 NEED SOMETHING\n         EJECT\n*  COME HERE IF COMMAND IS CH 'STRING1' / WHERE '/'\n* / -- SHOULD BE FOLLOWED BY /Z\n         SPACE\nBSSZ     SCAN  BSLASH2Z            //Z -> BSSZ1\nBSSZ1    BAL   R5,SSZ              PROCESS Z OF //Z\n         B     BPOS1\n         SPACE\nBPOS     BAL   R5,DOPOSCH               HANDLE POSITIONAL ATTRIBUTE\nBPOS1    L     R14,CPCHCLN         GET CURRENT COMPARE COUNT\n         LTR   R14,R14             TEST VALUE\n         BNP   BSTLIM              NO IMPROVEMENT IF NOT POSITIV\n         S     R14,CPCHLN1         SUB LENGTH OF STRING\n         BNP   CVNVALID            STRING TOO LONG IF LESS\n         ST    R14,CPCHCLN         SAVE NEW COMPARE COUNT\nBSTLIM   OI    CPLFLG2,CPFCHLIM         SET REPLACE STRING LIMIT\n         LA    R3,BBPRT            POINT TO SCAN TABLE\n         BAL   R6,TELLSCAN         GO DO SCAN\n         B     CVABSENT                 NEED SOMETHING\n         SPACE\nBBSPOT   CLI   0(R1),C'('               IS LEAD PAREN THERE\n         BNE   RESCAN              NO, RESET SCAN & SCAN ON\n         BCTR  R0,0                     REDUCE COUNT FOR LEFT PAREN\n         BCTR  R0,0                     REDUCE COUNT FOR RIGHT PAREN\n         LA    R5,1(R1)                 POINT AT FIRST INTERIOR CHAR\n         LTR   R2,R0                    SOMETHING?\n         BNP   CVNVALID                 NO\n         SCANSAVE ,                SAVE SCAN POINTERS\n         SCINIT (5),(2)                 INIT MOD SCAN\n         SCAN  MODPRT                   SCAN\n         B     CVABSENT            ERRROR IF NOTHING\n         SPACE\nMODRTNR  STC   R15,CPCHMOD              STORE MODIFIER\n         SCAN  ,                   SEE IF ANYTHING ELSE TYPED\n         BP    CVNVALID            YES, IT IS INVALID\nRESCAN   SCANRSTR ,                RESTORE SCAN POINTERS\nSCNTO    SCAN  CCPRT                    SCAN FOR \"TO\"\n         B     READYGO             GO SEE IF O.K.\n         EJECT\n* PROCESS CHANGE USING\n         SPACE\nUSPOT    TM    CPLFLG3,CPFCHTO+CPFCHUS  WAS TO/USING GIVEN?\n         BNZ   CVNVALID            BRANCH YES TO ERROR\n         OI    CPLFLG3,CPFCHUS     SET CHANGE USING\n         LR    R2,R13              SAVE WORK SPACE ADDR\n         LA    R13,C24(,R13)       GET WORK SPACE\n         ST    R2,CPCHAD2          SAVE ADDR OF SPACE\n         SR    R14,R14             SET COLUMN POINTERS\n         SR    R15,R15\n         STM   R14,R15,C8(R2)\n         LA    R1,UPRTLN1          SET SCAN TABLE FOR LINE 1\n         BAL   R6,USLN             GO SCAN FOR LINE 1\n         LR    R15,R0\n         STM   R15,R0,0(R2)        SAVE START LINE NO.\n         STM   R15,R0,16(R2)       ALSO SAVE FOR RANGE RESTART\n         LA    R3,UPRTSL           SCAN FOR SLASH\n         BAL   R6,TELLSCAN\n         B     READYGO\n         SPACE\nUSALL    SR    R14,R14             FIRST\n         L     R15,CPHIPS          LAST\n         STM   R14,R15,0(R2)       SET ALL\n         STM   R14,R15,16(R2)      ALSO SET FOR RANGE RESTART\n         B     USCOL\n         SPACE\nUSSLASH  LA    R1,UPRTLN2          SCAN FOR LINE NO.\n         BAL   R6,USLN             GO SCAN FOR LINE NO.\n         C     R0,0(,R2)           TOO LOW\n         BL    CVNVALID            BRANCH YES\n         ST    R0,C4(,R2)          SAVE ENDING NO.\n         ST    R0,C20(,R2)         ALSO SAVE FOR RANGE RESTART\nUSCOL    LA    R3,UPRTCOL1         SET SCAN TABLE FOR COLUMN\n         BAL   R6,TELLSCAN         SCAN FOR IT\n         B     READYGO\n         SPACE\nUSCOL1   BCTR  R15,0               DECREASE COUNT\n         ST    R15,C12(,R2)        SAVE STARTING COL.\n         LA    R3,UPRTCOL2         SET SCAN TABLE FOR 2ND COL\n         BAL   R6,TELLSCAN         GO SCAN FOR IT\n         B     READYGO\n         SPACE\nUSCOL2   S     R15,C12(,R2)        COMPUTE LENGTH\n         BNP   CVNVALID\n         ST    R15,C8(,R2)\n         B     SCNTO               GO LOOK FOR OTHER PARMS\n         SPACE\nUSLN     LA    R6,0(,R6)           MAKE ROUTINE ADDR POSITIVE\n         SCAN  (1)                 SCAN FOR LINE NUMBER\n         B     CVABSENT            MISSING IF NOTHING FOUND\n         EJECT\nCSPOT    TM    CPLFLG3,CPFCHTO+CPFCHUS\n         BNZ   CVNVALID\n         OI    CPLFLG3,CPFCHTO     SET \"TO\" FLAG\n         SCAN  CCCPRT              SCAN FOR TO VALUE\n         B     CVABSENT            MISSING IF NOTHING\n         SPACE\nPNMSPOT  LA    R3,C'+'             SET SIGN\n         B     NNMSPOTX\n         SPACE\nNNMSPOT  LA    R3,C'-'             SET SIGN\nNNMSPOTX STC   R3,12+10(,R8)       SAVE SIGN\n         ST    R8,CPCHAD2          SAVE STRING ADDR\n         LR    R2,R0               LENGTH\n         EX    R2,MVCHSTR          MOVE STRING\n         B     NMSPOTXX\n         SPACE\nCSPOTX   CLI   0(R1),C''''         SINGLE QUOTE?\n         BE    CCSPOT              YES\n         CLI   0(R1),C'\"'          DOUBLE QUOTE?\n         BNE   CVNVALID            NO, IT IS AN ERROR\nCCSPOT   CVCALL DQSCAN             DEQUOTE QUOTE STRING\n         OI    CPLFLG3,CPFCHNMI    SET EXPLICIT INCR. REQUIRED\nNMSPOT   LTR   R2,R0               NEED SOME OR DEL\n         BNP   CHDELL              ONLY DELETE\n         ST    R8,CPCHAD2          SAVE STRING ADDR\n         BCTR  R2,0                STRING LENGTH - 1\n         ST    R2,CPCHLN2          SAVE LENGTH\n         EX    R2,MOVCHSTR         MOVE IT\nNMSPOTXX LA    R2,22+4(,R2)        MULTIPLE OF 4 >= STRING LEN\n         N     R2,=F'-4'             TO RESET R8&R13\n         AR    R13,R2              NEW R13\n         LA    R3,DDPRT            SCAN FOR INCREMENT\n         BAL   R6,TELLSCAN\nNOINCR   SCANRSTR ,                RESTORE SCAN\n         TM    CPLFLG3,CPFCHNMI    DEFAULT INCR O.K.\n         BO    SCNTO               BRANCH NO\n         SPACE\n*  HANDLE INCREMENTS\n         SR    R15,R15             SET DEFAULT INCR\n         BCTR  R15,0\nNEGDO    LCR   R15,R15             MAKE NUMBER NEGATIVE\nPLUSDO   ST    R15,4(,R8)          SAVE INCR.\n         MVC   12(10,R8),=X'40202020202020202020' SET UP PATTERN\n         L     R1,CPCHLN2\n         LA    R0,1(,R1)\n         LA    R1,12+10(,R8)       SET UP TO SCAN STRING\n         SR    R2,R2               DIGIT COUNT\n         SR    R4,R4               NUMBER\n         SR    R14,R14             SET PLUS\n         ST    R14,8(,R8)          CLEAR SIGN CHAR.\n         LA    R5,X'20'            PATTERN CHAR.\n         LA    R6,12+10-1(,R8)     PREV PATTERN CHAR.\n         LR    R3,R6\nNUMLOOP  CLI   0(R1),C' '          A BLANK?\n         BNE   NOTBLNK             NO, CHECK OTHERS\n         C     R5,=XL4'21'         SIGN. STARTED YET?\n         BNE   ISNUM               NO, LEAVE IT AS A PAD\n         B     NEXTNUM             YES, BLNK IS JUST A CHAR\nNOTBLNK  CLI   0(R1),C'0'          0 OR GREATER?\n         BL    NOTNUM              NOP\n         CLI   0(R1),C'9'          9 OR LESS?\n         BH    NOTNUM              NOPE\nSETSIGN  LA    R5,X'21'            START SIGNIFICANCE\nISNUM    IC    R15,0(,R1)          DIGIT\n         N     R15,=XL4'F'         ISOLATE VALUE\nISNUMX   C     R4,=F'100000000'    TOO MANY DIGITS?\n         BNL   ILLPAT              BR IF SO\n         MH    R4,=H'10'           PUT IN NEW DIGIT\n         AR    R4,R15\n         STC   R5,0(,R6)           PLANT PATTERN CHAR.\n         STC   R5,0(,R1)\n         LR    R3,R6\n         LR    R6,R1\n         LA    R2,1(,R2)\nNEXTNUM  LA    R1,1(,R1)           NEXT CHAR.\n         BCT   R0,NUMLOOP\n         LTR   R14,R14             NEGATIVE?\n         BZ    *+6                 BR IF NOT\n         LCR   R4,R4\n         ST    R4,0(,R8)           SAVE NUMBER\n         MVI   0(R6),X'21'         INSURE ONE DIGIT\n         MVI   0(R3),X'21'\n         LTR   R0,R2               ANY DIGITS?\n         BZ    SCNTO               BR IF NOT\n         LA    R1,12(,R8)          1ST PATTERN DIGIT\nPATSET   LA    R1,1(,R1)           POINT AT PATTERN CHAR.\n         CLI   0(R1),X'20'         PATTERN DIGIT?\n         BE    ISPAT               BR IF SO\n         CLI   0(R1),X'21'\n         BNE   PATSET\nISPAT    MVI   0(R1),C' '          PLANT IT OUT\n         BCT   R0,PATSET           DO NEXT\n         LA    R6,12+1(,R8)        SET SIG. START\nSIGTEST  LA    R1,1(,R1)\n         CLI   0(R1),X'21'\n         BNE   SIGTEST\n         CLI   0(R6),X'21'         WAS PREVIOUS CHAR SIG.\n         BE    ISSIG               BR IF SO\n         LR    R6,R1               SAVE THIS CHAR.\n         B     SIGTEST\n         SPACE\nISSIG    SLR   R1,R8               COMPUTE DISPLACEMENT\n         LA    R1,0(,R1)           BE SURE\n         O     R1,8(,R8)           ADD SIGN CHAR.\n         ST    R1,8(,R8)           SAVE SIG. START\n         OI    CPLFLG3,CPFCHNM     SET CHANGE BY NUMBER FLAG\n         B     SCNTO\n         SPACE\n         SPACE\nNOTNUM   CLI   0(R1),C'-'          MINUS?\n         BE    ISMINUS             BR IF SO\n         CLI   0(R1),C'+'          PLUS?\n         BE    ISPLUS              BR IF SO\n         CLI   0(R1),C'$'          DOLLAR SIGN?\n         BE    ISPLUS              BR YES\n         CLI   0(R1),C'#'          NUMBER SIGN?\n         BNE   NEXTNUM             BR IF NOT\nISPLUS   MVC   8(1,R8),0(R1)       SAVE SIGN CHAR.\n         SR    R15,R15\n         B     ISNUMX\n         SPACE\nISMINUS  SR    R15,R15             TREAT AS ZERO\n         BAL   R14,ISNUMX          SET SWITCH AND GO\nILLPAT   TSEG  'TOO MANY DIGITS IN PATTERN'\n         B     CVQTYPE\n         EJECT\n         AIF   ('&DCEC' NE '1').LBL03                           JEP00X\nUPSPOT   OI    CPLFLG4,CPFCHUP     SET TRANS TO UPPERCASE FLG   JEP005\n         B     SCNTO              GO CHK FURTHER OPERANDS       JEP005\nLOSPOT   OI    CPLFLG4,CPFCHLO     SET TRANS TO LOWERCASE FLG   JEP005\n         OI    CPGFLG,CPFUPLW      SET UPLOW FLAG ON            JEP005\n         B     SCNTO              GO CHK FURTHER OPERANDS       JEP005\nCHALLSPT OI    CPLFLG3,CPFCHALL    TURN ON CHG WHOLE LINE FLAG  JEP005\n         OI    CPGFLG,CPFUPLW      SET UPLOW FLAG ON            JEP005\n         LA    R3,BPRT             ON TO THE SECOND PART        JEP005\n         BAL   R6,TELLSCAN         GO SAVE SCAN POINTERS        JEP005\n         B     CVABSENT            NEEDS SOMETHING ELSE         JEP005\n.LBL03   DS    0H                                               JEP00X\nDSPOT    OI    CPLFLG3,CPFCHIN     SET \"IN\" FLAG\n         CVCALL DETRNG             GET RANGE DEFINED\n         B     SCNTO               CONTINUE\n         SPACE\nREADYGO  TM    CPLFLG3,CPFCHIN     RANGE GIVEN?\n         BNZ   READYGO1            BRANCH YES\n         CVCALL DETRNG             GO SET UP DEFAULT RANGE\nREADYGO1 TM    CPLFLG3,CPFCHTO+CPFCHUS TO OR USING GIVEN\n         BZ    CVABSENT            BR IF NOT\n         NI    CPLFLG3,255-CPFCHNMI  TURN OFF INCR FLAG\n         OI    CPLFLG5,CPFNCUR     SET NO CURRENT LINE UPDATE\n         MVI   CPCURRL,X'F0'       SET CURRENT LINE INVALID\n         L     R15,VDOCHNG             LOAD DESPOT ADDR\n         CVCALL DESPOT                 GO TO DESPOT\n         XC    CPFCOL(4),CPFCOL    CLEAR FILL AREA\n         TM    CPSTAD,CPFSOME      SOMETHING IN RANGE?\n         BZ    CVGETCOM            BR IF NOT\n         TM    CPLFLG2,CPFLNCHN        AT LEAST 1 LINE CHANGED\n         BO    CVGETCOM                YES GET NEXT COMMAND\n         TM    CPGFLG2,CPFEXEC+CPFEXTER IS IT EXEC MODE & TERSE\n         BO    CVGETCOM            BR YES, SKIP MESSAGE\n         TSEG  'VOID CHANGE'           TELL USER\n         B     CVGETCOM                GET NEXT COMMAND\n         SPACE\nCHDELL   OI    CPLFLG2,CPFCHDEL         SET VOID REPLACE STRING\n         B     SCNTO                    LOOK FOR EXPLICIT RANGE\n         SPACE\nLSPOT    OI    CPLFLG3,CPFCHLN     SET \"LINE\" OPTION\n         BR    R14\n         SPACE\nCHREPT   OI    CPLFLG3,CPFCHREP    SET \"REPEAT\" OPTION\n         BR    R14                 RETURN\n         EJECT\n* //Z -> 1/Z-1/Z\n         SPACE\nSLASH1   SCAN  SLASH1Z             SCAN FOR /Z\nSLASH2Z  BAL   R5,SSZ              CHECK OUT Z\n         B     ORPOSNAL\n         SPACE\nSSZ      SR    R1,R1               CHCST=0, SINCE X=1\n         ST    R1,CPCHCST\n         BCTR  R15,0\n         ST    R15,CPCHCLN         CLN = 1/Z-1\n         ST    R15,CPFCOL          SAVE FILL COL (-1)\n         OI    CPFILLFG,CPFILL\n         BR    R5\n         SPACE\nTRYPOST  BAL   R5,DOPOSCH               HANDLE POSITIONAL ATTRIBUTE\nORPOSNAL OI    CPLFLG2,CPFCHPOS         SET POSITIONAL CHANGE\n         B     SCNTO                    NEED \"TO\"\n         SPACE\nDOPOSCH  BCTR  R15,0                    REDUCE TO NO CHARS B/4 INSERT\n         CH    R15,=Y(MXPRTSZ)          STILL 133 CHARS?\n         BNL   CVNVALID                 YES\n         ST    R15,CPCHCST              STORE\n         SCANSAVE ,                SAVE SCAN POINTERS\n         SCAN  FPRT            LOOK FOR SLASH\nONESL    SCAN  FPRNUM\n         SPACE 3\n* X\n         SPACE\nFRESTOR  SCANRSTR ,                RESTORE SCAN POINTERS\n         SR    R1,R1                    LEN OF DELETE STRING\n         ST    R1,CPCHCLN               STORE\n         BR    R5                       TO CALLER\n         SPACE 3\n* X/Y\n         SPACE\nFSLASH   LR    R2,R15              SAVE Y FOR COMPARE TO Z\n         S     R15,CPCHCST         NO. DELETE CHARACTERS\n         BNP   CVNVALID                 CHANGE WHAT?\n         ST    R15,CPCHCLN              SAVE DELETE COUNT\n         SCANSAVE ,\n         SCAN  FPRTZ               X/Y -> FBACK, X/Y/Z -> XYZ\nFBACK    SCANRSTR ,\n         BR    R5                       TO CALLER\n         SPACE 3\n* X//Z -> CST=X-1,CLN=0,CPFCOL=Z-1\n         SPACE\nXSLASHZ  BCTR  R15,0\n         C     R15,CPCHCST         Z > X ?\n         BNH   CVNVALID            NO. ERROR. BR.\n         ST    R15,CPFCOL\n         SR    R1,R1\n         ST    R1,CPCHCLN\n         OI    CPFILLFG,CPFILL     SET FILL FLAG\n         BR    R5\n         SPACE 3\n* X/Y/Z\n         SPACE\nXYZ      CR    R15,R2              Z > Y ?\n         BNH   CVNVALID\n         BCTR  R15,0\n         ST    R15,CPFCOL\n         OI    CPFILLFG,CPFILL\n         BR    R5\n         SPACE\nTELLSCAN SCANSAVE ,                SAVE CURRENT SCAN POINTERS\n         SCAN  (R3)                SCAN FOR OPTIONS\n         BR    R6                  RETURN TO CALLER\n         EJECT\n* REMOTE MOVE INSTRUCTIONS FOR CHANGE\n         SPACE\nMOVSTRNG MVC   0(0,R8),0(R1)\nMOVCHSTR MVC   12+10(0,R8),0(R1)\nMVCHSTR  MVC   12+10+1(0,R8),0(R1)\n         SPACE\n         DS    0F\nVDOCHNG  DC    AL1(DESRTRN+LOCATRTN+DESMATCH+UNPRST),VL3(DOCHNG)\n         SPACE 3\nAPRT     SCKW  ,TRYPOST,PI,133\n         SCKW  /,SLASH1\n         AIF   ('&DCEC' NE '1').LBL04                           JEP00X\n         SCKW  ALL,CHALLSPT,A                                   JEP005\n.LBL04   DS    0C                                               JEP00X\n         SCKW  ,ASPOT\n         SPACE\nSLASH1Z  SCKW  /,SLASH2Z,(P,PI),133\n         SCKW  ,INVALID\n         SPACE\nBPRT     SCKW  ,BPOS,PI,133\n         SCKW  /,BSSZ\nBBPRT    SCKW  ,BBSPOT\n         SPACE\nBSLASH2Z SCKW  /,BSSZ1,(P,PI),133\n         SCKW  ,INVALID\n         SPACE\nCCPRT    SCKW  TO,CSPOT\n         SCKW  USING,USPOT,A\n         SCKW  LINE,LSPOT,A\n         SCKW  REPEAT,CHREPT,A\n         SCKW  IN,DSPOT\n         SCKW  ,LTNPRT,PUSH\n         SCKW  ,INVALID\n         SPACE\nUPRTLN1  SCKW  ALL,USALL\nUPRTLN2  SCKW  ,LNENOPRT,PUSH\n         SCKW  ,INVALID\n         SPACE\nUPRTSL   SCKW  /,USSLASH\nUPRTCOL1 SCKW  COLUMNS,USCOL1,(P,A,PI),133\n         SCKW  COLS,USCOL1,(P,PI),133\n         SCKW  ,RESCAN\n         SPACE\nUPRTCOL2 SCKW  /,USCOL2,(P,PI),133\n         SCKW  ,RESCAN\n         SPACE\nCCCPRT   SCKW  +,PNMSPOT,(P,I)\n         SCKW  -,NNMSPOT,(P,I)\n         AIF   ('&DCEC' NE '1').LBL05                           JEP00X\n         SCKW  UPPER,UPSPOT,A                                   JEP005\n         SCKW  LOWER,LOSPOT,A                                   JEP005\n.LBL05   DS    0C                                               JEP00X\n         SCKW  ,NMSPOT,I\n         SCKW  ,CSPOTX\n         SPACE\nDDPRT    SCKW  +,PLUSDO,(P,I)\n         SCKW  -,NEGDO,(P,I)\n         SCKW  ,PLUSDO,I\n         SCKW  ,NOINCR\n         SPACE\nFPRT     SCKW  /,ONESL\n         SCKW  ,FRESTOR\n         SPACE\nFPRNUM   SCKW  ,FSLASH,PI,133\n         SCKW  /,XSLASHZ,(P,PI),133\n         SCKW  ,INVALID\n         SPACE\nMODPRT   SCKW  ,MODRTNR,PI,133\n         SCKW  ,INVALID\n         SPACE\nFPRTZ    SCKW  /,XYZ,(P,PI),133\n         SCKW  ,FBACK\n         SPACE\n         LTORG\n         TITLE 'GODEL ROUTINE'\n* GODEL IS PRIMARY DELETE ENTRY - AFTER DEFINING RANGE,\n*      WORK ADDR AND CONTROL ARE PASSED TO DESPOT.\n         SPACE\nGODEL    GENTER ,\n         CVCALL DETRNG                  DEFINE RANGE\n         MVI   CPWORK2,X'FF'           SET FOR 1ST LINE\n         OI    CPLFLG5,CPFNLST     SET NOLIST AS DEFAULT\n         SCAN  DELPRT                  SCAN  REST OF LINE\n         TM    CPLFLG5,CPFFOPT     ANY FORMAT OPTION GIVEN\n         BE    BOOMDEL             BRANCH NO\n         NI    CPLFLG5,255-CPFNLST YES, MAKE SURE LIST IN EFFECT\n         EJECT\nBOOMDEL  XENTER 2,8,*\n         TM    CPLFLG5,CPFNLST     NOLIST OPTION\n         BE    NOTEXXP             BRANCH NO\n         TM    CPSTAD,CPFEXPRG          EXPLICIT RANGE?\n         BZ    NOTEXXP                  NO\n         TM    CPSTAD,CPFDSJNT          DISJOINT RANGE?\n         BO    ALLSOKK                  YES .. ACCEPT\n         MVC   CPWK1(4),=D'0'           ZERO COUNT CELL\n         L     R15,ADLKWNTR             ADDR COUNT RTN\n         CVCALL DESPOT                  TO DESPOT\n         L     R2,CPWK1                 COUNT\n         LTR   R2,R2                    ZERO?\n         BZ    CVGETCOM                 YES\n         CLC   CPWK2+1(3),CPWK4+1       ONE PAGE?\n         BNE   FASTDEL                  NO\nALLSOKK  L     R15,VDODELA              FLAGGED ADDR RTN FOR EXP RNG\nDESCALL  CVCALL DESPOT                  GO DELETE\n         TM    CPSYSFLG,CPFTUSXC        FROM ABORT?\n         BO    DELEXIT                  YES\nDFINISH  B     CVGETCOM                 NEW COMMAND\n         SPACE\nNOTEXXP  L     R15,VDODELE              FLAGGED ADDR RTN FOR ASSC RNG\n         B     DESCALL                  GO TO DESPOT\n         EJECT\nFASTDEL  LH    R3,CPLNCT                LINE COUNT\n         SR    R3,R2                    NEW LINE COUNT\n         STH   R3,CPLNCT                NEW LINE COUNT\n         SR    R2,R2                    ZERO\n         TM    CPWK4,CPFPGND            LAST LINE ON PAGE?\n         BZ    NTLLP                    NO\n         L     R2,CPWK4                 PAGE PTR\n         LA    R2,6(,R2)                PT AT NEXT\n         B     DFSTP                    SKIP\n         SPACE\nNTLLP    LA    R1,CPWK5                 PTR AT LAST LINE NO.\n         CVCALL LOCATE                  LOCATE IT\n         LH    R6,0(,R11)               COUNT\n         LH    R5,CPWK6                 COUNT TO LAST DELETE LINE\n         IC    R2,4(,R15)               COUNT LAST DELETE LINE\n         LA    R5,5(R2,R5)              COUNT PAST LAST DELETE LINE\n         SR    R6,R5                    COUNT TO MOVE\n         LA    R5,2(,R6)                NEW COUNT ON PAGE\n         STH   R5,0(,R11)               STORE\n         LA    R1,2(,R11)               TARGET\n         LA    R15,5(R2,R15)            SOURCE\n         BAL   R14,MOVITEM              MOVE IT UP\n         L     R2,CPWK4                 PTR FIRST DIREC ENTRY TO MOVE\n         MVC   0(4,R2),2(R11)           RESET 1ST LINE NO. IN DIREC\n         PMARK 11                       MARK PAGE\nDFSTP    L     R3,CPWK2                 POSSIBLE TARGET FOR DIREC MOVE\n         TM    CPWK2,CPFPGLW            1ST LINE ON PAGE?\n         BO    DIRFX                    DELETE WHOLE PAGE\n         LA    R1,CPWK3                 LOCATE 1ST DELETE LINE\n         CVCALL LOCATE                  LOCATE IT\n         MVC   0(2,R11),CPWK6+2         SET NEW COUNT FOR PAGE\n         PMARK 11                       MARK PAGE\n         LA    R3,6(,R3)                PROPER TARGET FOR DIREC MOVE\nDIRFX    LA    R5,0(,R3)                ZERO 1ST BYTE (INTO R5)\n         LA    R6,0(,R2)                ZERO 1ST BYTE (INTO R6)\n         CR    R6,R5                    DIREC SET?\n         BNH   DONEDEL                  YES\n         LH    R4,CPAGCT                PAGE COUNT\n         LR    R2,R4                    SAVE OLD PAGE COUNT\nJUNKER   LH    R0,4(,R5)                PAGE NO. TO JUNK\n         PJUNK (0)                      JUNK PAGE\n         LA    R5,6(,R5)                POINT AT NEXT\n         BCTR  R4,0                     REDUCE PAGE COUNT\n         CR    R6,R5                    MORE?\n         BH    JUNKER                   YES\n         STH   R4,CPAGCT                RESET PAGE COUNT\n         LTR   R4,R4                    CLEAR?\n         BP    NCLRDEL                  NO\n         ST    R4,CPDREC                SET 1ST LINE NO. ZERO\n         ST    R4,CPHIPS                SET HIGHEST LINE NO. ZERO\n         MVI   CPLSTCOL,FNEGBT         SET FOR FIRST COLLECT\n         B     DONEDEL\n         SPACE\nNCLRDEL  TM    CPWK4,CPFNDDS            LAST LINE OF WDS?\n         BZ    DMOVDIR                  NO\n         LA    R1,CPWK5                 PTR AT LAST LINE NO.\n         CVCALL LOCATE                  LOCATE IT\n         MVC   CPHIPS(4),CPREVLN        SET LAST LINE NO.\n         B     DONEDEL                  READY TO GO\n         SPACE\nDMOVDIR  LA    R1,0(,R3)                TARGET\n         LR    R15,R6                   SOURCE\n         MH    R2,=Y(6)                 TOTAL DIREC DISPLACEMENT\n         LA    R6,CPDREC(R2)            PTR PAST CPDREC\n         SR    R6,R15                   COUNT\n         BAL   R14,MOVITEM              MOVE DIREC ITEMS\nDONEDEL  OI    CPGFLG,CPFDIRCH     SET DIRECTORY CHANGED\n         TM    CPSYSFLG,CPFTUSXC        FROM ABORT?\n         BO    DELEXIT                  YES\n         MVC   CPWORK2(4),CPWK3        SET 1ST LINE NO.\n         MVC   CPWORK1(4),CPWK5        SET LAST LINE NO.\n         B     DFINISH                  SCRAM\n         SPACE\nDELEXIT  XEXIT 2,8                      RETURN TO ABORT\n         EJECT\nMOVITEM  LA    R5,256                   SET COMPARAND-INCREMENT\nCHKMVC   CR    R6,R5                    A 256 BYTE MVC?\n         BNH   FNNMVC                   NO\n         MVC   0(256,R1),0(R15)         MOVE 256 BYTES\n         AR    R1,R5                    NEW TARGET ADDR\n         AR    R15,R5                   NEW SOURCE ADDR\n         SR    R6,R5                    LEFT-OVER COUNT\n         B     CHKMVC                   ANOTHER FULL MVC?\n         SPACE\nFNNMVC   BCTR  R6,0                     REDUCE FOR EX OF MVC\n         EX    R6,LSSMVC                MVC   0(0,R1),0(R15)\n         BR    R14                      RETURN TO CALLER\n         SPACE\nLSSMVC   MVC   0(0,R1),0(R15)\n         TITLE 'GOMOVE AND GOCOPY ROUTINES'\n* GOMOVE IS THE PRIMARY ENTRY FOR MOVE\n* GOCOPY IS THE PRIMARY ENTRY FOR COPY\n         SPACE\nGOCOPY   DENTER DSSIZ,,,NO\n         OI    CPLFLG1,CPFCPY+CPFALL   SET COPY & DEFAULT ALL\nGOMOVE   GENTER ,\n         OI    CPLFLG5,CPFNLST     SET NOLIST AS DEFAULT\n         OI    CPLFLG4,CPFSTSPL+CPFSTINS SET SO STOWIT WILL ONLY\n*                     INSERT LINES AND WILL SPLIT PAGE AT LINENO\n         CVCALL SCNEXFR            SCAN TO SEE IF EXEC OR FROM\n         OI    CPSYSFLG,CPFNTYPD        SET NOT TYPED COMMAND\n         CVCALL DETRNG                   DEFINE RANGE\n         L     R0,CPHIPS                HIGHEST LINE NO. YET\n         L     R1,CPGLDL                GLOBAL DELTA\n         CVCALL LOWMULT             GET MULTIPLE\n         CVCALL ADDER                    ADD\n         STM   R0,R1,CPWKPS             SET FOR \"END\" & NO \"BY\"\n         SR    R5,R5               SET TO SHOW NO DELTA YET\n         SR    R6,R6               SET TO SHOW NO TO YES\nSCANTO   SCAN  TOPRT                    SCAN FOR \"TO\"\n         TM    CPLFLG5,CPFFOPT     ANY FORMAT OPTION GIVEN\n         BE    *+8                 BRANCH NO\n         NI    CPLFLG5,255-CPFNLST YES, MAKE SURE LIST IN EFFECT\n         TM    CPLFLG1,CPFCPY          DEFAULT \"TO END\" OKAY\n         BO    READY                   YES, IT'S COPY\n         LTR   R6,R6               WAS TO SPECIFIED\n         BNZ   READY               YES, IT'S OKAY\n         B     CVABSENT                 NEED SOMETHING\n         SPACE\nHAVTO    TM    CPLFLG2,CPFCOMB     COMBINE & TO INVALID\n         BO    COPCOMTO            BRANCH IF COMBINE GIVEN\n         LA    R6,HAVLNENO         SET ADDRESS FOR LINE NUMBER\n         IC    R4,CPLFLG5          SAVE CPLFLG5\n         NI    CPLFLG5,255-CPFSELOC CLEAR BITS SO ACTIVE USED\n         SCAN  LINPRT              GO GET TO LINE\n         B     CVABSENT            MISSING IF NOTHING FOUND\n         SPACE\nHAVLNENO STC   R4,CPLFLG5          RESTORE CPLFLG5\n         STM   R0,R1,CPWKPS             SET LINE NO. & DEFAULT DELTA\n         B     SCANTO\n         SPACE\nCOPYEXE  TM    CPLFLG1,CPFCPY      IS IT COPY COMMAND\n         BE    CVNVALID            NO, EXECUTE IS INVALID\n         TM    CPLFLG5,CPFSELOC    EXTERNAL OPTION GIVEN\n         BO    COPEXEFR            YES, EXECUTE CAN'T BE USED\n         BR    R14\n         SPACE\nHAVBY    LTR   R5,R15                   ZERO NG\n         BNP   CVNVALID                 DELTA ERROR\n         TM    CPLFLG2,CPFCOMB     COMBINE & BY INVALID\n         BO    COPCOMBY            BRANCH IF COMBINE GIVEN\n         BR    R14                 SCAN ON\n         SPACE\nHAVCOMB  TM    CPLFLG1,CPFCPY      IS IT COPY COMMAND\n         BZ    CVNVALID            NO, COMBINE OPTION IS INVALID\n         LTR   R6,R6               HAS TO BEEN GIVEN\n         BNZ   COPCOMTO            YES, COMBINE IS AN ERROR\n         LTR   R5,R5               HAS BY BEEN GIVEN\n         BNZ   COPCOMBY            YES, COMBINE IS AN ERROR\n         OI    CPLFLG2,CPFCOMB+CPFMERG COMBINE OPTION + MERGE\n         BR    R14                 GO SCAN ON\n         EJECT\nREADY    LTR   R5,R5               BY SPECIFIED\n         BZ    READY1              BRANCH NO\n         ST    R5,CPWKDL           RESET BY\nREADY1   TM    CPWKPS,FNEGBT            ILLEGAL VALUE?\n         BO    BADLINE                  YES\n         LA    R1,CPWKPS                POINT AT 1ST LINE NO.\n         CVCALL LOCATE                   LOCATE IT\n         MVC   CPNDLN(4),=F'100000000' SET COMPARAND TOO HIGH\n         TM    CPDRPT,CPFNTYT+CPFHIGH   NOTHING YET OR AFTER LAST?\n         BNZ   NXTOGT                   YES\n         TM    CPDRPT,CPFMTCH           EXACT MATCH?\n         BO    BADLINEL                 COPY-MOVE WON'T REPLACE\n         MVC   CPNDLN(4),CPLCNO         SET FIRST ILLEGAL LINE NO.\nNXTOGT   MVC   CPBGLN(4),CPWKPS         SAVE START LINE NO.\n         SR    R1,R1                    ZERO R1 FOR LATER\n         OI    CPLFLG5,CPFNCUR     SET NOT TO UPDATE *\n         MVI   CPCURRL,X'F0'       SET CURRENT LINE INVALID\n         TM    CPLFLG5,CPFSELOC         EXTERNAL?\n         BO    SETUP                    YES - BRANCH AROUND\n         L     R15,KWNTAD          SET ADDR FOR DESPOT ACTIVE\n         BZ    *+8                 BRANCH IF SELECT ACTIVE\n         L     R15,KWNTADX         LOAD ROUTINE FOR EXEC SELECT\n         ST    R1,CPWK4                 ZERO COUNT CELL FOR KOWNTER\n         CVCALL DESPOT                   GO TO DESPOT\n         L     R4,CPWK4            LINE COUNT IN MOVE/COPY\n         LTR   R4,R4               ARE THERE ANY LINES\n         BZ    CVGETCOM            NO, COMMAND IS DONE\n         TM    CPLFLG2,CPFMERG     MERGE OPTION\n         BO    GODSPT              DELTA O.K. IF MERGE\n         L     R1,CPNDLN           GET FIRST ILLEGAL\n         S     R1,CPWKPS           SUBT FIRST LINENO TO GET SIZE\n         SR    R0,R0               ZERO FOR DIVIDE\n         DR    R0,R4               CALCULATE MAXIMUM DELTA\n         C     R1,CPWKDL           IS WORK DELTA LESS OR EQUAL\n         BNL   GODSPT              YES, USE WORK DELTA\n         BAL   R14,SELDELTA        NO, GO SELECT DELTA\n         ST    R1,CPWKDL           SAVE DELTA TO USE\nGODSPT   L     R6,WORKAD                ADDR FOR DESPOT (LOCATE)\n         TM    CPLFLG5,CPFSELOC    SEE IF SELECT EXECUTE\n         BNM   *+8                 NO, USE ACTIVE ROUTINE\n         L     R6,WEXKAD           YES, LOAD EXEC SELECT\n         TM    CPLFLG5,CPFNLST     NOLIST IN EFFECT\n         BO    GODSPT1             YES, BRANCH\n         O     R6,=AL1(UNPRST,0,0,0) SET UNPRESS OPTION FOR LIST\n         TM    CPLFLG2,CPFCOMB     IS IT COMBINE OPTION\n         BO    GODSPT1             YES, CANN'T LIST LINE BEFORE\n         LA    R1,CPWKPS           POINT TO INSERT LINE NUMBER\n         BAL   R14,LOCLIST         GO LIST LINE BEFORE\n         BP    CVQTYPE             STOP IF ATTENTION\nGODSPT1  LR    R15,R6              SET R15 FOR DESPOT\nGOGO     MVC   CPWORK1(4),=F'-1'       SET NO LINE STORED\n         MVC   CPWORK2(4),CPWKPS       START POSITION\n         CVCALL DESPOT                   LET DESPOT RUN THE SHOW\n         TM    CPLFLG5,CPFSELOC         WAS IT EXTERNAL\n         BNO   LSLNMSGN                 NO\n         DCLOSE ,                       CLOSE EXTERNAL DATA SET\n         NI    CPGFLG,255-CPFOPN        SET EXTERNAL DATA SET CLOSED\n         CLC   CPWORK1(4),=F'-1'       NEG=NOTHING\n         BE    CVGETCOM                 NIX\n         B     LSLNMSGN\n         EJECT\nSETUP    TM    CPLFLG5,CPFNLST     IS NOLIST IN EFFECT\n         BO    SETUP1              YES, IT'S OK\n         TSEG  'LIST OPTION IGNORED',,M\n         OI    CPLFLG5,CPFNLST     SET NOLIST OPTION\nSETUP1   CVCALL VOLCHEK                  MAKE SURE VOL SPECIFIED\n         TM    CPLFLG3,CPFSET          TEST IF \"SET\" NECESSARY\n         BZ    CPYOPEN             BR IF NO\n         CVCALL SETPFXNS            GO SET PREFIX\nCPYOPEN  DOPEN 0,,USE                   OPEN DS\n         BZ    GDOPEN                   OPEN OK\n         CVCALL NTGDOPN                  GO DO OPEN ERROR MESSAGE\nGDOPEN   OI    CPGFLG,CPFOPN            SET EXTERNAL DATA SET OPENED\n         ST    R1,CPDRED                BUFFER ADDR(BYTE 1=ZERO)\n         XCALL CHKMBRIG            GO CHECK MBR IGNORED\n         L     R15,WXRKAD               ADDR FOR DESPOT (LXCATE)\n         B     GOGO                     GO TO IT\n         SPACE\nEXTRN    TM    CPLFLG1,CPFCPY           MUST BE COPY\n         BZ    CVNVALID                 IT'S MOVE\n         TM    CPLFLG5,CPFSELOC    EXECUTE OPTION GIVEN\n         BM    COPEXEFR            YES, FROM CAN'T BE USED TOO\n         OI    CPSYSFLG,CPFTUSXC        SET EXTERNAL COPY FLAG\n         CVCALL DODSNM                   GET THEM\n         B     SCANTO\n         EJECT\n* USER HAS USED COMBINE AND TO OPTIONS -- GIVE ERROR MSG\n         SPACE\nCOPCOMTO SYSQS 1,0,'COMBINE'       SET FIRST PART OF MSG\n         SYSQS 3,2,'TO'            SET LAST PART OF MSG\n         B     COPERRMS            GO DO MSG\n         SPACE 3\n* USER HAS USED COMBINE AND BY OPTIONS -- GIVE ERROR MSG\n         SPACE\nCOPCOMBY SYSQS 1,0,'COMBINE'       SET FIRST PART OF MSG\n         SYSQS 3,2,'BY'            SET LAST PART OF MSG\n         B     COPERRMS            GO DO MSG\n         SPACE 3\n* USER HAS USED FROM AND EXECUTE OPTIONS -- GIVE ERROR MSG\n         SPACE\nCOPEXEFR SYSQS 1,0,'FROM'          SET FIRST PART OF MSG\n         SYSQS 3,2,'EXECUTE'       SET LAST PART OF MSG\nCOPERRMS TSEG  (1),(0),B           PUT OUT FIRST PART\n         TSEG  'INVALID WITH',,B   PUT OUT COMMON MIDDLE\n         TSEG  (3),(2)             PUT OUT LAST PART OF MSG\n         B     CVQTYPE             GO ABORT COMMAND\n         EJECT\nWORK     XENTER 0,8,C40+SZR+12 REGSAVE, BUFFER & FIXUPP WORK\n         PFLIP 9,11                     FLIP PAGES\n         SR    R0,R0\n         IC    R0,4(R15)                GET PREST COUNT\n         LR    R3,R0\n         LA    R3,4(R3)                 TO MOVE LINE NO. ALSO\n         EX    R3,MVCPMVC               MOVE LINE\nTRYDEL   L     R2,CPWKPS                WORKING POSITION\n         TM    CPLFLG2,CPFMERG+CPFCOMB  MERGE OR COMBINE OPTION\n         BNZ   MRGECHK             BRANCH YES\n         CL    R2,CPNDLN                LEGAL?\n         BNL   FIXUPP                   TOO BIG - TRY TO FIX\nWRKMRGE  TM    CPLFLG1,CPFCPY           IS IT MOVE?\n         BO    GOTCPY                   NO\n         CVCALL DODELE                   DELETE THE LINE\n         L     R3,CPWK4                 LINE COUNT REMAINING\n         SPACE\n* THE FOLLOWING CODE AVOIDS PAGE THRASHING WHEN MOVE\n* IS PROCESSING A LARGE RANGE IN THE MIDDLE OF A DATA SET.\n* THE PAGE THRASHING WAS CAUSED BY LOCATE AFTER THE FIRST\n* LINE OF THE PAGE HAD BEEN DELETED BY DODELE\n         SPACE\n         TM    CPDRPT,CPFNDDS+CPFFSLN  END OR BEGINNING OF FILE\n         BNZ   GOTCPY              YES, THRASHING NO PROBLEM\n         TM    CPDRPT,CPFPGLW      JUST DELETED FIRST ON PAGE\n         BE    GOTCPY              NO, THRASHING NO PROBLEM\n         L     R4,CPDRPT           GET DIRECTORY ENTRY\n         MVC   CPDOUB(4),0(R4)     PUT NEW FIRST ON FULL WORD\n         L     R6,CPDOUB           PUT NEW FIRST IN R6\n         CR    R6,R2               MAKE SURE NO OVERLAY MOVE\n         BL    UPDMVE              CAN'T BE IF LESS\n         C     R2,CPLCNO           COMPARE TO LINE NUMBER DELETE\n         BH    GOTCPY     OVERLAY MOVE IF HIGH, CAN'T FIX\nUPDMVE   OI    CPLFLG4,CPFDESET    TELL DESPOT THAT CPNWLN SET\n         ST    R6,CPNWLN           SET DESPOT TO USE THE LINE NO\nGOTCPY   ST    R2,C40(R8)               SET NEW LINE NO.\n         ST    R2,CPCURRL          UPDATE CURRENT LINE POINTER\n         SPACE\n* R0 HAS ALREADY BEEN SET FOR STOWIT -- FIXUPP RESTORED R0 ALSO\n         LA    R1,C40(R8)               PREST LINE ADDR\n         CVCALL STOWIT                   LINE INTO PAGE\n         BM    BLASTER             ERROR IF TRY TO REPLACE\n         TM    CPLFLG5,CPFNLST     LIST OPTION IN EFFECT\n         BO    STORTST             BRANCH NO\n         LM    R0,R1,4(R8)         RESTORE POINT TO UNPRESS LINE\n         MVC   CPLCNO,C40(R8)      SET LINE NUMBER FOR LISTLINE\n         CVCALL LISTLINE            FORMAT LINE FOR LISTING\n         BP    LSLNMSGA            ABORT IF ATTENTION\nSTORTST  BCT   R3,STORT                 DECREMENT LINE COUNT LEFT\n         B     LSLNMSGN                 STOP IT NOW\n         SPACE\nSTORT    ST    R3,CPWK4                 RESET COUNT REMAINING (MOVE)\n         LR    R0,R2                    POSITION USED INTO R0\n         L     R1,CPWKDL                PLUS DELTA\n         CVCALL ADDER                    GIVE\n         ST    R0,CPWKPS                NEW POSITION\n         XEXIT 0,8                      SCRAM\n         EJECT\nMRGECHK  BNO   *+8        BRANCH IF MERGE BUT NOT COMBINE\n         L     R2,C40(,R8) USE OLD LINE NUMBER FOR COMBINE\n         CL    R2,=F'100000000'    LINE NUMBER O.K.\n         BL    WRKMRGE             BRANCH YES TO CONTINUE\nFIXUPP   TM    CPLFLG5,CPFSELOC    EXTERNAL FILE SELECTION?\n         BNO   BLASTER1            NO, ABORT THE MOVE/COPY\n         TM    CPLFLG2,CPFMERG     MERGE OPTION?\n         BO    TEARIT              YES, ABORT THE COPY\n         L     R1,CPWKDL           GET CURRENT DELTA\n         SRA   R1,1                HALVE IT\n         BZ    TEARIT              ABORT IF ZERO\n         BAL   R14,SELDELTA        CONVERT IT TO SUITABLE DELTA\n         ST    R1,CPWKDL           SAVE NEW DELTA\n         L     R0,CPBGLN           SET FIRST LINE NO. TO FIX\n         MVC   CPWKPS,CPWORK1     SET LAST LINE TO RENUMBER\n         XCALL FIXNUMB             GO FIX LINE NUMBERS\n         ST    R0,CPWORK1         SAVE LAST LINE NO.\n         A     R0,CPWKDL           CALCULATE NEXT LINE NO.\n         ST    R0,CPWKPS           SAVE IT FOR NEXT LINE\n         SR    R0,R0                    ZERO FOR IC\n         IC    R0,C40+4(R8)             RESET PREST COUNT\n         B     TRYDEL                   GO TO IT AGAIN\n         EJECT\nTEARIT   DCLOSE ,                       CLOSE IT\n         NI    CPGFLG,255-CPFOPN        SET CLOSED\n         TSEG  'COPY ABORTED BEFORE EXTERNAL LINE',,B\n         L     R0,C40(R8)               NEXT LINE NO.\n         CVCALL CVEXNO                   CONVERT IT\n         TSEG  (1),(0)                  INTO MSG\n         B     LSLNMSGA            GO DO LAST LINE MESSAGE\n         SPACE\nBLASTER  TM    CPLFLG5,CPFSELOC    SELECT FROM EXTERNAL?\n         BO    TEARIT              YES, GO ABORT IT\nBLASTER1 TSEG  'ABORTED BY ATTEMPT TO REPLACE',,B\n         TM    CPLFLG2,CPFMERG     MERGE OPTION?\n         BO    LSLNMSGA            YES\n         TSEG  'OR INTERLEAVE'\n         B     LSLNMSGA            GO DO LAST LINE MSG\n         TITLE 'LOCATE PREVIOUS LINE AND FORMAT FOR LIST'\n* LOCLIST LOCATES THE LINE IN THE FILE BEFORE THE LINE NUMBER\n* POINTED TO BY R1 ON INPUT.  THE LOCATED LINE IS FORMATTED FOR\n* LISTING ACCORDING TO THE SETTINGS OF THE FLAGS IN CPLFLG5 BY\n* THE LISTLINE ROUTINE.\n         SPACE\nLOCLIST  XENTER 7,8,SZR+12         DEFINE BASE & WORK AREA\n         CVCALL LOCATE             LOCATE THE CURRENT LINE\n         TM    CPDRPT,CPFMTCH+CPFNTYT+CPFFSLN  IS THERE A LINE\n         BNZ   LOCLISEX            BRANCH IF NO LINE\n         LA    R1,CPREVLN          POINT TO PREVIOUS LINE NO.\n         CVCALL LOCATE             LOCATE IT\n         LA    R1,12(,R8)          POINT TO UNPRESS AREA\n         CVCALL UNPRESS            UNPRESS LINE\n         CVCALL LISTLINE            FORMAT LINE FOR OUTPUT\nLOCLISEX XEXIT 7,8                 RETURN\n         TITLE 'UTILITY ROUTINES AND DESPOT ADDRESSES'\n* BAD LINE NO. MESSAGE\n         SPACE\nBADLINEL BALR  R7,0                SET BASE REGISTER\n         USING *,R7\n         L     R0,CPLCNO           GET BAD LINE NUMBER\n         CVCALL CVEXNO             CONVERT TO EXTERNAL FORM\n         TSEG  (1),(0),B           PUT IT IN MESSAGE\nBADLINE  BALR  7,0                      SET BASE REG\n         USING *,7\n         TSEG  'LINE NO.'\n         B     CVUNLEGL\n         SPACE 3\n* FOR DELETE\n         SPACE\n         DS    0F\nVDODELA  DC    AL1(DESRTRN+LOCATRTN+DESMATCH+PREST),VL3(DODELEL) DELETE\nVDODELE  DC    AL1(DESNRTN+LOCATRTN+DESMATCH+PREST),VL3(DODELEL) DELETE\nADLKWNTR DC    AL1(DESRTRN+LOCATRTN+DESMATCH+PREST),AL3(DELKWNT) COUNT\n         TITLE 'SCKW''S FOR DELETE'\nDELPRT   SCKW  ,LTNPRT,PUSH\n         SCKW  ,INVALID\n         SPACE 3\n         LTORG\n         TITLE 'UTILITY ROUTINES'\n* USED BY DELETE\n         SPACE\nDELKWNT  SR    R15,R11                  COUNT TO DELETE LINE\n         STH   R15,CPWK6                SAVE IT\n         L     R15,CPWK1                COUNT CELL\n         LA    R1,1(,R15)               KICK\n         ST    R1,CPWK1                 RESET COUNT\n         MVC   CPWK4(8),CPDRPT          LAST LINE SAVE\n         LTR   R15,R15                  FIRST?\n         BPR   R14                      NO\n         MVC   CPWK2(8),CPDRPT          FIRST LINE SAVE\n         MVC   CPWK6+2(2),CPWK6         COUNT TO 1ST DELETE LINE\n         BR    R14                      SCRAM\n         SPACE 3\n* USED BY MOVE-COPY\n         SPACE\nKOWNTR   L     1,CPWK4        GET PREV TOTAL\n         LA    1,1(1)         ADD ONE\n         ST    1,CPWK4        SAVE IT\n         BCR   15,14          RETURN\n         SPACE 3\n* FOR MOVE-COPY-SAVE\n         SPACE\nMVCPMVC  MVC   C40(0,R8),0(R15)\n         SPACE 3\n* FOR MOVE-COPY\n         SPACE\n         DS    0F\nKWNTAD   DC    AL1(DESRTRN+LOCATRTN+DESMATCH+PREST),AL3(KOWNTR) WORK\nKWNTADX  DC    AL1(DESRTRN+LEXATRTN+DESMATCH+PREST),AL3(KOWNTR) WORK\nWORKAD   DC    AL1(DESRTRN+LOCATRTN+DESMATCH+PREST),AL3(WORK) WORK\nWEXKAD   DC    AL1(DESRTRN+LEXATRTN+DESMATCH+PREST),AL3(WORK) WORK\nWXRKAD   DC    AL1(DESRTRN+LXCATRTN),AL3(WORK) WORK\n         TITLE 'SCKW''S FOR MOVE-COPY'\nLINPRT   SCKW  ,LNENOPRT,PUSH\n         SCKW  ,INVALID\n         SPACE\nTOPRT    SCKW  TO,HAVTO\nBYPRT    SCKW  BY,HAVBY,(P,LN)\n         SCKW  FROM,EXTRN,A\n         SCKW  EXECUTE,COPYEXE,A\n         SCKW  ,IGDSNPRT,PUSH\n         SCKW  ,MRGEPRT,PUSH\n         SCKW  ,LTNPRT,PUSH\n         SCKW  COMBINE,HAVCOMB,A\n         SCKW  ,INVALID\n         SPACE\nMRGEPRT  SCKW  MERGE,SCNMRGE,A\n         SCKW  NOMERGE,SCNNMRGE,A\n         SCKW  ,,POP\n         SPACE\nSCNMRGE  OI    CPLFLG2,CPFMERG     SET MERGE OPTION\n         BR    R14                 SCAN ON\n         SPACE\nSCNNMRGE NI    CPLFLG2,255-CPFMERG-CPFCOMB RESET MERGE OPTION\n         BR    R14\n         TITLE 'LAST LINE MESSAGE ROUTINE'\n* LAST LINE MESSAGE HERE - THEN ON TO COMMAND PROMPT\n         SPACE\nLSLNMSGA GENTER ,                  SET BASE\n         LA    R6,CVQTYPE          RETURN TO QTYPE\n         TM    CPLFLG5,CPFNLST+CPFUNUM DID COMMAND LIST LAST NUM\n         BER   R6                  BRANCH YES\n         B     LSLNMSGD            GO DO LAST LINE MSG\n         DROP  R7   NO BASE NEEDED UNTIL LSLNMSG\n         SPACE\nLSLNMSGN LA    R6,CVGETCOM         RETURN TO GETCOM\n         TM    CPLFLG5,CPFNLST+CPFUNUM DID COMMAND LIST LAST NUM\n         BER   R6                  BRANCH YES\n         CLC   CPWORK1(4),CPWORK2     ONLY ONE LINE?\n         BER   R6                       YES\nLSLNMSG  GENTER ,                  SET BASE\n         LA    R6,CVGETCOM         RETURN TO GETCOM\n         TM    CPGFLG2,CPFEXEC+CPFEXTER  IS IT TERSE AND EXEC\n         BOR   R6                  YES, SKIP MESSAGE\nLSLNMSGD L     R0,CPWORK1              LAST LINE NO.\n         LTR   R0,R0               ANYTHING MOVED\n         BMR   R6                  BRANCH NO\n         GENTER ,                  SET BASE\n         CVCALL CVEXNO                   CONVERT\n         TSEG  (1),(0),B                INTO MESSAGE\n         TSEG  '- LAST LINE'          FINISH MESSAGE\n         BR    R6\n         TITLE 'DELTA SELECT ROUTINE'\n* SELECT A SUITABLE DELTA BASED ON THE VALUE IN R1\n*        IF R1 IS 0 THEN .001 IS USED\n*        IF R1>=CPGLDL THEN CPGLDL IS USED\n*        OTHERWISE THE DELTA IS CHOSEN FROM A TABLE AS THE FIRST VALUE\n*        NOT GREATER THAN R1 FROM THE LIST 1.000, .500, .200, .100,\n*        .050, .020, .010, .005, .002, AND .001.\n* THE DELTA CHOSEN IS RETURNED IN R1\n         SPACE\nSELDELTA XENTER 6,8,*\n         LTR   R1,R1               IS VALUE POSITIVE\n         BNP   SEL001              NO, USE .001\n         C     R1,CPGLDL           IS R1>=CPGLDL\n         BNL   SELDEL              YES, USE CPGLDL\n         LA    R6,SELTBLE          POINT TO TABLE\nSELOOP   CH    R1,0(,R6)           USE THIS ENTRY?\n         BNL   SELGOT              YES\n         LA    R6,2(,R6)           POINT TO NEXT ENTRY\n         B     SELOOP              LOOP\n         SPACE\nSELGOT   LH    R1,0(,R6)           SET R1 TO SELECTED TABLE VALUE\nSELEXIT  XEXIT 6,8                 RETURN\n         SPACE\nSEL001   LA    R1,1                USE .001\n         B     SELEXIT             GO RETURN\n         SPACE\nSELDEL   L     R1,CPGLDL           USE CPGLDL\n         B     SELEXIT             GO RETURN\n         SPACE\nSELTBLE  DC    H'1000,500,200,100,50,20,10,5,2,1'  POSSIBLE DELTAS\n         TITLE 'FIX LINE NUMBERS FOR A GIVEN RANGE'\n* FIX NUMBERING FOR A RANGE\n*        R0 - LINENO OF FIRST LINE IN RANGE\n*        CPWKPS - LAST LINENO TO FIX\n*        CPWKDL - NEW DELTA TO USE\n* RETURNS LAST LINENO USED IN R0\n         SPACE\nFIXNUMB  XENTER 2,8,*\n         LR    R6,R0               SAVE FIRST LINE TO FIX\n         PFREE R9                  FREE ANY PAGE IN R9\n         ST    R6,CPLCNO           SET CPLCNO FOR LOCAT\nFIXLOCT  LA    R1,CPLCNO\n         CVCALL LOCATE             POINT TO FIRST LINENO\n         TM    CPDRPT,CPFNTYT+CPFHIGH    DOES LINE EXIST\n         BNZ   FIXABEND            NO, ABEND FOR INTERNAL ERROR\n         TM    CPDRPT,CPFMTCH      LINE NO. MATCH?\n         BZ    FIXLOCT             NO, GO LOCATE AGAIN\n         L     R4,CPDRPT           POINT TO DIRECTORY ENTRY\n         LR    R2,R15              POINT R2 TO LOCATED LINE\n         LR    R3,R11              POINT TO\n         AH    R3,0(,R11)              END OF TEXT\n         SR    R5,R5               ZERO FOR IC\n         B     FIXSTRT             ENTER LOOP\n         SPACE\nFIXNXPAG MVC   0(4,R4),2(R11)      RESET FIRST LINENO IN DIRECTORY\n         PMARK 11                  MARK PAGE CHANGED\n         CLC   CPHIPS,CPLCNO       AT HIGH LINE NO\n         BNH   FIXHIGH             YES, EXIT & RESET HIGH LINE\n         LA    R4,6(,R4)           STEP TO NEXT DIRECTORY ENTRY\n         LH    R0,4(,R4)           GET PAGE NUMBER\n         PGET  11,(0)              GET PAGE INTO R11\n         LR    R3,R11              POINT TO\n         AH    R3,0(,R11)              END OF TEXT\n         LA    R2,2(,R11)          POINT TO FIRST LINE\nFIXNXLIN A     R6,CPWKDL           CALCULATE NEW LINE NO.\nFIXSTRT  MVC   CPLCNO,0(R2)        SAVE OLD LINE NUM FOR TEST\n         CLC   CPWKPS,CPLCNO       CHECK IF DONE\n         BL    FIXDONE             BRANCH YES\n         ST    R6,CPDOUB           PUT NEW LINE NO\n         MVC   0(4,R2),CPDOUB            INTO LINE IMAGE\n         BE    FIXDONE             ALSO DONE IF EQUAL\n         IC    R5,4(,R2)           GET LENGTH OF LINE\n         LA    R2,5(R5,R2)         POINT TO NEXT LINE\n         CR    R2,R3               END OF PAGE?\n         BL    FIXNXLIN            BRANCH NO\n         B     FIXNXPAG            YES, GO GET NEXT PAGE\n         SPACE\nFIXDONE  MVC   0(4,R4),2(R11)      RESET FIRST LINENO IN DIRECTORY\n         PMARK 11                  MARK PAGE AS CHANGED\n         CLC   CPHIPS,CPLCNO       SHOULD HIGH LINE BE UPDATED?\n         BH    FIXEXIT             BRANCH NO\nFIXHIGH  ST    R6,CPHIPS           RESET HIGH LINENO\nFIXEXIT  OI    CPGFLG,CPFDIRCH     SET DIRECTORY CHANGED\n         LR    R0,R6               RETURN NEW HIGH NUM\n         XEXIT 2,8                 RETURN\n         SPACE\n* NO FIRST LINE -- A LOGIC ERROR HAS OCCURRED THAT SHOULDN'T HAVE\nFIXABEND ABEND 100,DUMP            GET A DUMP\n         TITLE 'GOSET ROUTINE'\n* GOSET IS THE PRIMARY ENTRY FOR ALL SET OPTIONS.\n         SPACE\nGOSET    GENTER C8\nSETBASE  SCAN  STPRT\n         B     CVABSENT\n         SPACE\nLNGTH    STH   R15,CPLNGTH              STORE LENGTH\n         B     CVGETCOM                 NEW COMMAND\n         SPACE\nUPDATE   LTR   R15,R15\n         BM    CVNVALID\n         STH   R15,CVPRMLIM\n         B     CVGETCOM\n         SPACE\nTRAPX    LTR   R15,R15\n         BM    CVNVALID\n         ST    R15,CVEXTRAP\n         B     CVGETCOM\n         SPACE\nDELTAX   LTR   R15,R15                  ZERO NG\n         BNP   CVNVALID                 NEED POSITIVE\n         ST    R15,CPGLDL               STORE DELTA\n         B     CVGETCOM                 NEW COMMAND\n         SPACE 3\n* SET DEFAULT VOLUME ROUTINE\n         SPACE\nVOLSETT  CH    R0,=Y(6)                 NOT OVER 6 CHARS\n         BH    CVNVALID                BR IF OVER\n         MVC   CPVOLSV(6),0(R15)        MOVE IN DEFAULT VOLUME\n         OI    CPGFLG,CPFVOLM           SET DEFAULT VOLUME SPECIFIED\n         B     CVGETCOM                 FINI\n         SPACE\nVOLGOTT  SCAN  VLMPRT                   CLEAR OR SET VOLUME?\nVLCLEAR  NI    CPGFLG,255-CPFVOLM       SET NO DEFAULT VOLUME\n         B     CVGETCOM                 FINI\n         EJECT\nTABS     PCALL GOTAB               TAB SET CODE IS PAGED\n         SPACE\nSETCURR  CVCALL SCNEXFR             SEE IF EXEC SPECIFIED\n         SR    R5,R5               USE 0 AS DEFAULT SET\n         LA    R6,GOTCURR          SET ADDRESS FOR LINE NO PRT\nSETCURR1 SCAN  CURRPRT1            SCAN OPTIONS\n         TM    CPLFLG5,CPFSELOC    SET * FOR ACTIVE OR EXEC\n         BNZ   SETCURR2            BRANCH IF SET FOR EXEC\n         ST    R5,CPCURRL          SET CURRENT FOR ACTIVE FILE\n         B     CVGETCOM\n         SPACE\nSETCURR2 ST    R5,CPEXLINE         SET CURRENT FOR EXEC FILE\n         B     CVGETCOM\n         SPACE\nCURRTO   SCAN  CURRPRT2            GET LINE NUMBER AFTER TO\n         B     CVABSENT            MISSING IF NOTHING FOUND\n         SPACE\nGOTCURR  LR    R5,R0               REMEMBER SPECIFIED LINE NO\n         B     SETCURR1            SCAN REST OF LINE\n         SPACE\nSETEXEC  SCAN  SETEXPRT\n         B     CVGETCOM\n         EJECT\nSETESCAP SCAN  ,                  LOOK FOR ESCAPE CHAR\n         BNP   SETESNUL\n         CLI   0(1),C''''         TEST FOR SINGLE QUOTE\n         BE    SETESLNG\n         CLI   0(1),C'\"'          TEST FOR DOUBLE QUOTE\n         BNE   SETESMOV\nSETESLNG SH    0,=H'2'            TEST LENGTH\n         BZ    SETESNUL           MUST BE '' OR \"\"\n         LA    1,1(,1)            TAKE 1ST CHAR INSIDE QUOTES\nSETESMOV MVC   CPESCAPE(1),0(1)   SET ESCAPE CHARACTER\n         NI    CPGFLG2,255-CPESNULL  TURN OFF NULL FLAG\n         B     SETIGNOR\n         SPACE\nSETESNUL OI    CPGFLG2,CPESNULL   SET NULL FLAG\n         B     SETIGNOR\n         SPACE\nSETSKIP  SCAN  ,                  LOOK FOR SKIP   CHAR\n         BNP   SETSKNUL\n         CLI   0(1),C''''         TEST FOR SINGLE QUOTE\n         BE    SETSKLNG\n         CLI   0(1),C'\"'          TEST FOR DOUBLE QUOTE\n         BNE   SETSKMOV\nSETSKLNG SH    0,=H'2'            TEST LENGTH\n         BZ    SETSKNUL           MUST BE '' OR \"\"\n         LA    1,1(,1)            TAKE 1ST CHAR INSIDE QUOTES\nSETSKMOV MVC   CPSKIP(1),0(1)     SET SKIP   CHARACTER\n         NI    CPGFLG2,255-CPSKNULL  TURN OFF NULL FLAG\n         B     SETIGNOR\n         SPACE\nSETSKNUL OI    CPGFLG2,CPSKNULL   SET NULL FLAG\n         B     SETIGNOR\n         SPACE\nSETRSCN  STH   R15,CPRSCNVL        SET RESCAN COUNT\n         B     SETIGNOR\n         EJECT                     ,\nCUPPER   NI    CPGFLG,255-CPFUPLW       SET UPPER CASE ONLY BIT\n         B     SETIGNOR                 GET NEW COMMAND\n         SPACE\nCUPLOW   OI    CPGFLG,CPFUPLW           SET UPPER-LOWER CASE BIT\n         B     SETIGNOR                 GET NEW COMMAND\n         SPACE\nNOCOMM   OI    CPGFLG,CPFCMOFF          DON'T PROMPT \"COMMAND\"\n         B     SETIGNOR\n         SPACE\nYSCOMM   NI    CPGFLG,255-CPFCMOFF      PROMPT \"COMMAND\"\n         B     SETIGNOR\n         SPACE\nCLOG     NI    CPGFLG2,255-CPFNOLOG    SET LOG FOR OBEY COMMANDS\n         B     SETIGNOR\n         SPACE\nCNOLOG   OI    CPGFLG2,CPFNOLOG        SET NOLOG FOR OBEY\nSETIGNOR SCAN  ,\n         BNP   CVGETCOM\nSETIGN1  TSEG  (1),(0),B\n         SCAN  ,                   SEE IF ANYTHING ELSE TO IGNOR\n         BP    SETIGN1             YES CONTINUE LOOP\n         TSEG  ': IGNORED'         NO, FINISH MESSAGE\n         B     CVGETCOM\n         EJECT\n* SET PREFIX COMMAND ENTERS AT \"SETPFX\"\n* SET NAME COMMAND ENTERS AT \"SETNAME\"\n* SET OPERAND OF OTHER COMMANDS ENTERS AT \"SETPFXNS\"\n         SPACE\nSETPFXNS SENTER R14,R8,C44         SET PREFIX WITH NO SCAN\n         L     R7,=A(SETBASE)      GET CURRENT BASE REG\n         USING SETBASE,R7          RESET ADDRESSABILITY\n         LH    R0,DSNWANL          GET DSNAME LENGTH\n         B     SETPFX2\n         SPACE 3\nSETNAME  OI    CPLFLG3,CPFSET      INDICATE SET NAME\nSETPFX   OI    CPLFLG2,CPFDSNMS    NULL/NO DEFAULT ON DSN OK\n         SCANSAVE 0(R8)            SAVE SCAN POINTERS\n         SCAN  ,\n         LTR   R0,R0                   PREFIX GIVEN?\n         BNP   NOPFX                   BR IF NOT\n         TM    CPLFLG3,CPFSET      SET PREFIX OR SET NAME?\n         BZ    CHKPFX              BR IF SET PREFIX\n         SCANRSTR 0(R8)            RESTORE SCAN POINTERS\n         DENTER DSSIZ,,,NO          GET WORK SPACE\n         CVCALL DODSNM              GET THE NAME\n         SPACE 3\n* PROCESS THE CONSTRUCTED DSNAME\n         SPACE\nSETPFX2  LA    R1,DSNWADSN         ADDRESS OF DSN WORK AREA\n         LA    R4,CPPFX            ADDR OF PREFIX FIELD\n         TM    DSNWAF1,DSNFQDSN    IS IT QUOTED OR $\n         BO    DOLPFX              BR IF YES\n         TM    DSNWAF1,DSNFSTD     IS DSN A STD WYLBUR DSN?\n         BZ    DOLPFX              BR IF NO\nCLCSET   CLC   =C'SET',CPCMNM      IS COMMAND SET NAME?\n         BNE   SETPFX2A                BR IF NO\n         AIF   ('&USPS' NE '1').XLBL01                          USPS01\n         MVC   CPUSERSV,DSNWADSN  SAVE USER                     USPS01\n         AGO   .XLBL02                                          USPS01\n.XLBL01   DS    0H                                              USPS01\n         MVC   CPGRPSV,DSNXG+DSNWADSN  SAVE GROUP\n         MVC   CPUSERSV,DSNXU+DSNWADSN  SAVE USER\n.XLBL02  DS    0H                                               USPS01\n         AIF   ('&USPS' NE '1').XLBL09                          USPS01\nSETPFX2A SR     R2,R2                                           JEP001\n         IC    R2,CVUSRFLD          PICK UP ID LENGTH           JEP001\n         LA    R2,1(R2)             BUMP FOR PERIOD             JEP001\n         AR    R1,R2                ADD IN FOR OFFSET           JEP001\n         SR    R0,R2               DECR LEN BY ID OFFSET        JEP001\n         AGO   .XLBL10                                          USPS01\n.XLBL09   DS    0H                                              USPS01\nSETPFX2A LA    R1,DSNXN(R1)\n         SH    R0,*-2              ADJUST LENGTH\n.XLBL10   DS    0H                                              USPS01\n         BP    SAVEPFX             BR IF MORE\n         XC    CPPFXL,CPPFXL       NO PREFIX - CLEAR IT\n         B     SETMPFX             GO CHECK MEMBER\n         SPACE 3\n* SET PREFIX TO QUOTED NAME - CLEAR QUOTES OFF FIRST\n         SPACE\nCHKPFXQ  CVCALL DQSCAN\n         SPACE 3\n* DSN IS NOT STD WYL NAME OR WAS SPECIFIED IN QUOTES OR $\n* SET WHOLE NAME AS $ SPEC IN PREFIX\n         SPACE\nDOLPFX   MVI   0(R4),C'$'          SET \"$\" IN PREFIX\n         LA    R4,1(R4)            BUMP PAST \"$\"\n         AH    R0,*-2              INCR LENGTH TO INCLUDE \"$\"\n         CH    R0,=Y(CPPFXSZ)      TOO BIG\n         BH    PFXTL               YES\n         STH   R0,CPPFXL           SAVE LENGTH\n         LR    R2,R0               LENGTH\n         BCT   R2,SAVEPFX1         DEC\n         B     SETMPFX             0 LENGTH\n         SPACE\nSAVEPFX  CH    R0,=Y(CPPFXSZ)          TOO BIG?\n         BH    PFXTL                   BR IF SO\n         STH   R0,CPPFXL               SAVE LENGTH\n         LR    R2,R0               LENGTH OF PREFIX\nSAVEPFX1 BCTR  R2,0                FOR EX\n         EX    R2,PFXMVC           MOVE IT\n         SPACE\n* NOW SET MEMBER IN CASE IT WAS SPECIFIED\nSETMPFX  TM    CPLFLG3,CPFSET      TEST SET NAME OR PREFIX\n         BZ    CHKEXTRA            BR IF PREFIX\n         CLI   DSNWAMBR,X'40'      WAS A MEMBER SPECIFIED?\n         BE    CHKEXTRA            BR IF NOT\n         MVC   CPMEMBSV,DSNWAMBR   MOVE MEMBER NAME\n         CLI   CPMEMBSV,0          WAS MEMBER EXPLICITLY NULL?\n         BNE   CHKEXTRA            BR IF NOT\n         MVI   CPMEMBSV,X'40'      RESET SAVED MEMBER\n         B     CHKEXTRA\n         SPACE\nSETPFXEX EX    0,CLCSET            WAS IT SET COMMAND?\n         BE    CVGETCOM            BR IF YES\n         CLI   CPCMNM,C'U'             IS IT USE COMMAND\n         BE    SETPFXXX            YES, NO TSEG SINCE DEFAULT\n         TSEG  'SET DONE',,M\nSETPFXXX SEXIT R14,R8,RELOAD\n         SPACE\nNOPFX    XC    CPPFXL(2),CPPFXL        CLEAR PREFIX\n         B     SETPFXEX\n         SPACE\nPFXTL    TSEG  'PREFIX TOO LONG',,M\n         B     SETPFXEX\n         SPACE\nCHKPFX   LA    R4,CPPFX            ADDR OF PREFIX FIELD\n         CLI   0(R1),X'C0'         IS FIRST CHAR ALPHA?\n         BH    SAVEPFX             BR IF YES\n         CLI   0(R1),C'$'\n         BE    SAVEPFX\n         CLI   0(R1),C''''         IS OPERAND QUOTED?\n         BE    CHKPFXQ             BR IF YES\n         CLI   0(R1),C'\"'          OTHER QUOTES?\n         BE    CHKPFXQ             BR IF YES\n         CLI   0(R1),C'*'          IS PREV PFX TO BE USED?\n         BNE   CVNVALID            BR IF NO - INVALID\n         LA    R1,1(R1)            BUMP PAST *\n         BCTR  R0,0                ADJUST LENGTH\n         LTR   R2,R0               SAVE LENGTH\n         BZ    CHKEXTRA            BR IF * ALONE\n         AH    R0,CPPFXL           GET TOTAL LENGTH\n         CH    R0,=Y(CPPFXSZ)      IS NEW LENGTH TOO BIG?\n         BH    PFXTL               BR IF YES\n         AH    R4,CPPFXL           BUMP DESTINATION ADDR\n         STH   R0,CPPFXL           STORE NEW LENGTH\n         BCTR  R2,0                FOR EX\n         EX    R2,PFXMVC           MOVE NEW PART OF PFX\nCHKEXTRA EX    0,CLCSET            WAS ENTRY FOR SET COMMAND?\n         BNE   SETPFXEX            BR IF NOT - NOEXTRA SCAN\n         SR    R2,R2               INIT FLAG\nEXTRALP  SCAN  EXTRAPRT            SCAN FOR OTHER STUFF\n         LTR   R2,R2               WAS ANYTHING FOUND?\n         BZ    SETPFXEX            BR IF NO\n         TSEG  ': IGNORED',,M\n         B     SETPFXEX\n         SPACE\nEXTRAGUM TM    CPLFLG3,CPFSET      IS IT SET NAME?\n         BOR   R14                 BR IF YES\nEXTRA    LR    R2,R0\n         TSEG  (1),(0),B\n         B     EXTRALP\n         SPACE\nPFXMVC   MVC   0(0,R4),0(R1)       MOVE PREFIX\n         EJECT\n         AIF   ('&USPS' EQ '1').XLBL03                          USPS01\n* SET GROUP\n         SPACE\nSETGRP   DS    0H\n         SCAN  GRPPRT\n         MVC   CPGRPSV,CPGRP       SET DEFAULT GROUP\n         B     CVGETCOM            EXIT\n         SPACE 3\n.XLBL03   DS    0H                                              USPS01\n* SET USER\n         SPACE\nSETUSER  SCAN  USERPRT\n         AIF   ('&DCEC' NE '1').LBL06                           JEP00X\n         SR    R2,R2               ZERO R2 FOR MOVE             JEP001\n         IC    R2,CVUSRFLD         PICK UP USERID LENGTH        JEP001\n         BCTR  R2,0                DOWN 1 FOR EX                JEP001\n         EX    R2,MVUSER           MOVE DEFAULT ID IN           JEP001\n         B     CVGETCOM            EXIT                         JEP001\nMVUSER   MVC   CPUSERSV(0),CPUSER                               JEP001\n         AGO   .LBL07                                           JEP00X\n.LBL06   DS    0H                                               JEP00X\n         MVC   CPUSERSV,CPUSER     SET DEFAULT USER\n         B     CVGETCOM            EXIT\n.LBL07   DS    0H                                               JEP00X\n         SPACE 3\n* SET MEMBER\n         SPACE\nSETMBR   SCAN  MBRPRT\n         MVC   CPMEMBSV,0(R15)     BLANK IS DEFAULT MEMBER\n         B     CVGETCOM\n         SPACE 3\n* HAVE MEMBER OPERAND\n         SPACE\nMBRSET   LA    R3,CPMEMBSV         ADDR OF DESTINATION\n         LA    R2,L'CPMEMBSV       LENGTH\n         LA    R4,4                SPECIAL PROCESSING\n         B     GUMSET\n         SPACE 3\n         AIF   ('&USPS' EQ '1').XLBL04                          USPS01\n* HAVE GROUP OPERAND\n         SPACE\nGRPSET   LA    R3,CPGRPSV          ADDR OF DESTINATION\n         LA    R2,L'CPGRPSV        LENGTH\n         B     GUSET\n.XLBL04   DS    0H                                              USPS01\n         SPACE 3\n* HAVE USER OPERAND\n         SPACE\n         AIF   ('&DCEC' NE '1').LBL08                           JEP00X\nUSERSET  LA    R3,CPUSERSV         ADDR OF DESTINATION          JEP001\n         SR    R2,R2               CLEAR R2                     JEP001\n         IC    R2,CVUSRFLD         PICK UP USERID LENGTH        JEP001\n         AGO   .LBL09                                           JEP00X\n.LBL08   DS    0H                                               JEP00X\nUSERSET  LA    R3,CPUSERSV         ADDR OF DESTINATION\n         LA    R2,L'CPUSERSV       LENGTH\n.LBL09   DS    0H                                               JEP00X\nGUSET    SR    R4,R4\nGUMSET   CLR   R0,R2               CHECK LENGTH OF OPERAND\n         EX    0,GUMBT(R4)         TAKE BRANCH IF INVALID\n         CLI   0(R1),X'C0'    IS THERE A SPEC CHAR ON FRONT?\n         BL    CVNVALID            BR IF YES\n         LR    R2,R0               CURRENT LENGTH\n         BCTR  R2,0                -1\n         LTR   R4,R4               WAS IT MEMBER?\n         BZ    GUMMOVE             BR IF NO\n         MVI   0(R3),X'40'         CLEAR MEMBER FIELD\n         MVC   1(7,R3),0(R3)\nGUMMOVE  EX    R2,GUMMVC           MOVE NEW VALUE\n         B     CHKEXTRA\n         SPACE\nGUMMVC   MVC   0(0,R3),0(R1)\nGUMBT    BNE   CVNVALID            GROUP/USER BRANCH\n         BH    CVNVALID            MEMBER BRANCH\n         SPACE\nSETATTN  SCAN  ATTNCHRS\n         NI    RTBUFL,255-RTBUATTN\n         B     CVGETCOM\n         SPACE\nSETATTN2 CH    R0,=H'8'\n         BH    CVNVALID\n         L     R14,RTBWAPTR\n         STH   R0,RTBATNSZ(,R14)\n         MVC   RTBATTN(8,R14),0(R1)\n         OI    RTBUFL,RTBUATTN\n         B     CVGETCOM\n         SPACE\nATTNCHRS SCKW  ,SETATTN2\n         SPACE 3\nSETCOLL  NI    RTBUFL,255-RTBUNCOL\n         B     CVGETCOM\n         SPACE 3\nSETNCOL  OI    RTBUFL,RTBUNCOL\n         B     CVGETCOM\n         SPACE 3\nSETCRT   OI    RTBMFL,RTBCRT\nSETCRTS  SR    R0,R0\n         L     R1,RTBWAPTR\n         STH   R0,RTBLINE(,R1)\n         CH    R0,RTBCURS(,R1)\n         BE    CVGETCOM\n         TSEG  (1),(0),W\n         B     CVGETCOM\n         SPACE 3\nSETNOCRT NI    RTBMFL,X'FF'-RTBCRT\n         B     SETCRTS\n         SPACE 3\nSETPAD   OI    RTBUFL,RTBUPAD\n         B     CVGETCOM\n         SPACE 3\nSETNOPAD NI    RTBUFL,X'FF'-RTBUPAD\n         B     CVGETCOM\n         SPACE 3\nSETBACK  OI    RTBUFL,RTBUBACK\n         B     CVGETCOM\n         SPACE 3\nSETNBACK NI    RTBUFL,255-RTBUBACK\n         B     CVGETCOM\n         SPACE 3\nSETFAST  OI    RTBUFL,RTBUFAST\n         B     CVGETCOM\n         SPACE 3\nSETSLOW  NI    RTBUFL,255-RTBUFAST\n         B     CVGETCOM\n         SPACE 3\nSETWRAP  OI    RTBMFL,RTBWRAP\n         B     SETCRTS\n         SPACE 3\nSETNWRAP NI    RTBMFL,X'FF'-RTBWRAP\n         B     SETCRTS\n         SPACE 3\nSETPSZ   LA    R2,RTBPSZ\n         B     SETLPSZ\n         SPACE 3\nSETLSZ   LA    R2,RTBLSZ\nSETLPSZ  LTR   R15,R15\n         BZ    CVNVALID\n         L     R14,RTBWAPTR\n         STH   R15,0(R2,R14)\n         B     SETCRTS\n         EJECT\n         LTORG\n         TITLE 'SCKW''S'\n* FOR SET\n         SPACE\nSTPRT    SCKW  LENGTH,LNGTH,(P,PI,A),133\n         SCKW  UPDATE,UPDATE,(P,I,A),32000\n         SCKW  DELTA,DELTAX,(P,LN,A)\n         SCKW  TRAP,TRAPX,(P,LN)\n         SCKW  TABS,TABS,A\n         SCKW  UPPER,CUPPER,A\n         SCKW  UPLOW,CUPLOW,A\n         SCKW  TERSE,NOCOMM,A\n         SCKW  VERBOSE,YSCOMM,A\n         SCKW  LOG,CLOG\n         SCKW  NOLOG,CNOLOG,A\n         SCKW  VOLUME,VOLGOTT,A\n         SCKW  PREFIX,SETPFX,A\n         SCKW  NAME,SETNAME,A\n         AIF   ('&USPS' EQ '1').XLBL05                          USPS01\n         SCKW  GROUP,SETGRP,A\n.XLBL05   DS    0C                                              USPS01\n         SCKW  USER,SETUSER,A\n         SCKW  MEMBER,SETMBR,A\n         SCKW  CURRENT,SETCURR,A\n         SCKW  *,SETCURR\n         SCKW  EXECUTE,SETEXEC,A\n         SCKW  ESCAPE,SETESCAP,A\n         SCKW  SKIP,SETSKIP,A\n         SCKW  VALUE,SETVAR,(A,P)\n         SCKW  RESCAN,SETRSCN,(A,P,I),100\n         SCKW  COLLECT,SETCOLL,A\n         SCKW  NOCOLLECT,SETNCOL,A\n         SCKW  ATTN,SETATTN\n         SCKW  WRAP,SETWRAP\n         SCKW  NOWRAP,SETNWRAP,A\n         SCKW  CRT,SETCRT\n         SCKW  NOCRT,SETNOCRT\n         SCKW  PAD,SETPAD\n         SCKW  NOPAD,SETNOPAD\n         SCKW  LINESIZE,SETLSZ,(P,PI,A),133\n         SCKW  LS,SETLSZ,(P,PI),133\n         SCKW  PAGESIZE,SETPSZ,(P,PI,A),255\n         SCKW  PS,SETPSZ,(P,PI),255\n         SCKW  BACK,SETBACK,A\n         SCKW  NOBACK,SETNBACK,A\n         SCKW  FASTLIST,SETFAST,A\n         SCKW  SLOWLIST,SETSLOW,A\n         SCKW  ,INVALID\n         SPACE 3\n* FOR SET CURRENT\n         SPACE\nCURRPRT1 SCKW  EXECUTE,,A\n         SCKW  TO,CURRTO\nCURRPRT2 SCKW  ,LNENOPRT,PUSH\n         SCKW  ,INVALID\n         SPACE 3\n* FOR SET EXEC\n         SPACE\nSETEXPRT SCKW  ,STEXEPRT,PUSH\n         SCKW  ,INVALID\n         SPACE 3\n* FOR SET VOLUME\n         SPACE\nVLMPRT   SCKW  ,VOLSETT\n         SPACE 3\n* FOR SET GROUP/USER/MEMBER\n         SPACE\n         AIF   ('&USPS' EQ '1').XLBL06                          USPS01\nGRPPRT   SCKW  ,GRPSET\n.XLBL06   DS    0C                                              USPS01\nUSERPRT  SCKW  ,USERSET\nMBRPRT   SCKW  ,MBRSET\n         SPACE 3\n* FOR SET GRP/USER/MBR/PFX/NAME POST-SCAN\n         SPACE\n         AIF   ('&USPS' NE '1').XLBL07                          USPS01\nEXTRAPRT DS    0C                                               USPS01\n         AGO   .XLBL08                                          USPS01\n.XLBL07   DS    0C                                              USPS01\nEXTRAPRT SCKW  GROUP,EXTRAGUM,(P,A)\n.XLBL08   DS    0C                                              USPS01\n         SCKW  USER,EXTRAGUM,(P,A)\n         SCKW  ,EXTRA\n         TITLE 'CONSTANTS, ETC.'\n         COPY  WYLCONST\n         SPACE\nCHEXCLAM EQU   X'5A'   EXCLAMATION POINT\n         EJECT\n         COPY  RTNCODES\n         EJECT\nSDSNBUF  DSECT\n         COPY  SDSNBUF\n         EJECT\n         COMMON\n         SPACE\nCPFCOL   EQU   CPDRED\nCPFILLFG EQU   CPDRED\nCPFILL   EQU   X'80'\n         SPACE\n         END\n./ ADD NAME=PPRT,SSI=00000002\nPPRT     TITLE 'COMMON SCAN TABLES FOUND IN MANY LISTS'\n* PROPERTY OF C. U. C. C. A.\n         SPACE  3\nPPRT     CSECT\n         WIDENT 001\n         USING CPAREA,R12\n         SPACE\n         XTRNS\n         TITLE 'LIST, TEXT, NUMBERED'\n         ENTRY LISTPRT\nLISTPRT  SCKW  LIST,SCNLIST,A\n         SCKW  NOLIST,SCNNLST,A\n         SCKW  N,SCNNLST\n         SCKW  ,,POP\n         SPACE\n         ENTRY TEXTPRT\nTEXTPRT  SCKW  TEXT,SCNTEXT,A\n         SCKW  NOTEXT,SCNNTEX,A\n         SCKW  ,,POP\n         SPACE\n         ENTRY LTNPRT\nLTNPRT   SCKW  ,LISTPRT,PUSH\n         SCKW  ,TEXTPRT,PUSH\n         SPACE\n         ENTRY NUMPRT\nNUMPRT   SCKW  NUMBERED,SCNNUM,A\n         SCKW  UNNUMBER,SCNUNUM,A\n         SCKW  NONUMBER,SCNONUM,A\n         SCKW  INTEGER,SCNINT,A\n         SCKW  DECIMAL,SCNDECI,A\n         SCKW  ,,POP\n         SPACE\nSCNLIST  NI    CPLFLG5,255-CPFNLST           RESET TO LIST\n         BR    R14                  SCAN ON\n         SPACE\nSCNNLST  OI    CPLFLG5,CPFNLST     SET NOLIST\n         BR    R14                 SCAN ON\n         SPACE\nSCNNTEX  NI    CPLFLG5,255-CPFNONUM-CPFNLST  RESET OPTIONS & LIST\n         OI    CPLFLG5,CPFNTEX+CPFFOPT     TURN ON NOTEXT FLAG\n         BR    R14                 SCAN ON\n         SPACE\nSCNTEXT  NI    CPLFLG5,255-CPFNLST RESET TO LIST\nSCNONUM  OI    CPLFLG5,CPFNONUM+CPFFOPT SET NONUMBER OPTION\n         BR    R14                 SCAN ON\n         SPACE\nSCNUNUM  NI    CPLFLG5,255-CPFNONUM         CLEAR ALL OPTIONS\n         OI    CPLFLG5,CPFUNUM+CPFFOPT SET UNNUMBERED\n         BR    R14                 SCAN ON\n         SPACE\nSCNDECI  NI    CPLFLG5,255-CPFINT  RESET INTEGER FLAG FOR DECIMAL\n         TM    CPLFLG5,CPFFOPT     HAS AN OPTION BEEN GIVEN\n         BOR   R14                 YES, SCAN ON\nSCNNUM   NI    CPLFLG5,255-CPFNONUM RESET TO NUMBERED\n         OI    CPLFLG5,CPFFOPT     SET NUMBER OPTION SPECIFIED\n         BR    R14                 SCAN ON\n         SPACE\nSCNINT   OI    CPLFLG5,CPFINT      SET INTEGER OPTION\n         TM    CPLFLG5,CPFFOPT     HAS AN OPTION BEEN GIVEN\n         BOR   R14                 YES, SCAN ON\n         NI    CPLFLG5,255-CPFNONUM  NO, TURN ON NUMBERED\n         OI    CPLFLG5,CPFFOPT     SET OPTION GIVEN\n         BR    R14                 SCAN ON\n         TITLE 'SCRATCH/CLEAR PRTS'\n         ENTRY SCRPRT\nSCRPRT   SCKW  SCRATCH,SCNSCR,A\n         SCKW  REPLACE,SCNSCR,A\n         SCKW  NOSCRATC,SCNNSCR,A\n         SCKW  NOREPLACE,SCNNSCR\n         SCKW  ,,POP\n         SPACE\n         ENTRY CLSCRPRT\nCLSCRPRT SCKW  ,SCRPRT,PUSH\n         SPACE\n         ENTRY CLRPRT\nCLRPRT   SCKW  CLEAR,SCNCLR,A\n         SCKW  CLR,SCNCLR,A\n         SCKW  NOCLEAR,SCNNCLR,A\n         SCKW  NOCLR,SCNNCLR\n         SCKW  ,,POP\n         SPACE\nSCNSCR   OI    CPLFLG2,CPFSCRTC    TURN ON SCRATCH\n         BR    R14                 SCAN ON\n         SPACE\nSCNNSCR  NI    CPLFLG2,255-CPFSCRTC  TURN OFF SCRATCH\n         BR    R14                 SCAN ON\n         SPACE\nSCNCLR   OI    CPLFLG2,CPFCLEAR    TURN ON CLEAR\n         BR    R14\n         SPACE\nSCNNCLR  NI    CPLFLG2,255-CPFCLEAR  TURN OFF CLEAR\n         BR    R14\n         TITLE 'DSNAME PARMS TO IGNORE IN COMMAND SCAN'\n         ENTRY IGDSNPRT\nIGDSNPRT SCKW  ON,,P\n         SCKW  USER,,(P,A)\n         SCKW  GROUP,,(P,A)\n         SCKW  KEYWORD,,(P,A)\n         SCKW  SET,\n         SCKW  NOSET,,A\n         SCKW  SHARE,\n         SCKW  SHR\n         SCKW  READ,,(P,A)\n         SCKW  WRITE,,(P,A)\n         SCKW  PROTECT,,(P,A)\n         SCKW  DPO,\n         SCKW  ,,POP\n         TITLE 'LINE NUMBER RECOGNITION ROUTINE'\n* TO USE THIS PRT, REGISTER R6 MUST BE SET TO THE DESIRED\n* RETURN ADDRESS IF A LINE NUMBER IS RECOGNIZED\n*  IF R6 IS NEGATIVE, IT IS THE COMPLEMENT OF A RELATIVE ADDRESS\n*  BASED OFF R10 WHICH POINTS TO THE CURRENT CODE-PAGE\n*\n* R0 CONTAINS THE SPECIFIED LINE NUMBER ON EXIT\n* R1 HAS A DELTA THAT CAN BE USED BY COLLECT, MOVE AND COPY\n* R15 HAS RETURN CODES TO SHOW WHICH WAY THE LINE NO WAS\n* SPECIFIED.\n* R15 -  0 REGULAR LINE NUMBER SPECIFIED\n*        4 FIRST SPECIFIED\n*        8 CURRENT SPECIFIED\n*       12 LAST SPECIFIED\n*       16 END SPECIFIED\n*       20 NEXT SPECIFIED\n*       24 PREVIOUS SPECIFIED\n*\n* IF ANYTHING OTHER THAN A REGULAR LINE NUMBER IS SPECIFIED THEN\n* AN INCREMENT IS SCANNED FOR AND ADDED IN IF FOUND\n         SPACE\n         ENTRY LNENOPRT\nLNENOPRT SCKW  F,SCNFRST\n         SCKW  L,SCNLAST\n         SPACE\n         ENTRY LNENOPRN\nLNENOPRN SCKW  ,SCNLNENO,LN\n         SCKW  FIRST,SCNFRST,A\n         SCKW  CURRENT,SCNCURR,A\n         SCKW  LAST,SCNLAST,A\n         SCKW  END,SCNEND\n         SCKW  NEXT,SCNNEXT,A\n         SCKW  PREVIOUS,SCNPREV,A\n         SCKW  *,SCNCURR\n         SCKW  ,,POP\n         SPACE\nSCNFRST  BALR  R14,0               ESTABLISH BASE\n         USING *,R14\n         L     R0,CPDREC           GET FIRST IN ACTIVE FILE\n         LA    R15,4               SET CODE THAT FIRST SPECIFIED\n         TM    CPLFLG5,CPFSELOC    TEST IF CORRECT SELECTION\n         BE    INCRSCN             BRANCH YES\n         MVC   CPDOUB,CPEXDIR      SET EXEC FIRST TO WORD BOUND\n         L     R0,CPDOUB           ASSUME SELECT FROM EXEC\n         BM    INCRSCN             BRANCH YES\n         SR    R0,R0               SET FIRST FOR EXTERNAL COPY\n         B     INCRSCN\n         SPACE\nSCNLAST  BALR  R14,0               ESTABLISH BASE\n         USING *,R14\n         LA    R15,12              SET CODE FOR LAST\n         L     R0,CPHIPS           GET LAST IN ACTIVE FILE\n         TM    CPLFLG5,CPFSELOC    TEST IF CORRECT SELECTION\n         BE    INCRSCN             BRANCH YES\n         L     R0,CPEXHIPS         ASSUME SELECT FROM EXEC\n         BM    INCRSCN             BRANCH YES\n         L     R0,=F'99999999'     SET HIGH FOR EXTERNAL\n         B     INCRSCN\n         SPACE\nSCNCURR  BALR  R14,0               ESTABLISH BASE\n         USING *,R14\n         LA    R15,8               SET CODE FOR CURRENT\n         L     R0,CPCURRL          GET CURRENT IN ACITVE FILE\n         TM    CPLFLG5,CPFSELOC    TEST IF CORRECT SELECTION\n         BE    CURRTST             BRANCH YES\n         BO    CVNVALID            INVALID IF FROM EXTERNAL FILE\n         L     R0,CPEXLINE         ASSUME SELECT FROM EXEC\nCURRTST  LTR   R0,R0               SEE IF VALID LINE NUMBER\n         BNM   INCRSCN             BRANCH IF OKAY\n         TM    CPLFLG4,CPFNOCUR    IS IT OK NOT TO HAVE CURRENT\n         BO    CURRMIN             BR YES TO RETURN -1\n         TSEG  'CURRENT LINE NOT SET'   SET ERROR MESSAGE\n         B     CVQTYPE\n         SPACE\nCURRMIN  LH    R0,=H'-1000'        SET R0 TO -1.000\n         L     R1,CPGLDL           SET R1 TO GLOBAL DELTA\n         B     INCRSCN         NOW GO LOOK FOR ANY INCREMENT\n         DROP  R14\n         SPACE\nSCNEND   DS    0H\n         SENTER 5,8,28             END WAS SPECIFIED\n         TM    CPLFLG5,CPFSELOC    ONLY SELECT FROM ACTIVE\n         BNZ   CVNVALID            BRANCH NOT FROM ACTIVE\n         L     R0,CPHIPS           GET CURRENT HIGH NO.\n         L     R1,CPGLDL           GET GLOBAL DELTA\n         XCALL LOWMULT\n         CVCALL ADDER              CALCULATE END\n         BM    CVNVALID            BAD IF NEGATIVE\n         LA    R15,16              SET CODE FOR END\n         B     INCRSCN1            GO GET INCR IF GIVEN\n         DROP  R7\n         SPACE\nSCNLNENO BALR  R14,0               ESTABLISH BASE\n         USING *,R14\n         LR    R0,R15              PUT NORMAL LINE NO IN R0\n         SR    R15,R15             SET CODE FOR NORMAL LINE NO\n         B     INCRSCN             GOTSCAN FOR INCREMENT\n         SPACE\nSCNPREV  BALR  R14,0               SET UP BASE\n         USING *,R14\n         LH    R1,=H'-1'           SET NEGATIVE INCREMENT\n         B     SCNNEXTC            GO JOIN NEXT CODE\n         DROP  R14\n         SPACE\nSCNNEXT  LA    R1,1                SET POSITIVE INCREMENT\nSCNNEXTC DS    0H\n         SENTER 5,8,28             ESTABLISH BASE & SAVE AREA\n         TM    CPLFLG5,CPFSELOC    WHERE IS LINE COMING FROM\n         BO    CVNVALID            INVALID IF EXTERNAL FILE\n         BM    SCNNEXT1            BRANCH IF FROM EXEC FILE\n         L     R0,CPCURRL          GET CURRENT IN ACTIVE FILE\n         L     R5,CVLOCATE         USE LOCATE ROUTINE\n         B     SCNNEXT2\n         SPACE\nSCNNEXT1 L     R0,CPEXLINE         USE CURRENT IN EXEC FILE\n         L     R5,=A(LOCATEEX)     USE LOCATEEX ROUTINE\nSCNNEXT2 CVCALL ADDER              ADD LINE NUMBER & INCREMENT\n         BM    NONEXTST            BRANCH IF INVALID LINE\n         ST    R0,CPLCNO           STORE LINE NO. TO LOCATE\n         LTR   R1,R1               SET CC FOR PREV OR NEXT\n         LA    R1,CPLCNO           POINT TO LOCATE LINE\n         BM    SCNPREV1            BRANCH IF PREVIOUS LINE\n         BALR  R14,R5              GO LOCATE NEXT LINE\n         PFREE 11                  FREE ANY LOCATED PAGE\n         TM    CPDRPT,CPFNTYT+CPFHIGH DOES IT EXIST\n         BNZ   NONEXT              BRANCH NO\n         L     R0,CPLCNO           LOAD LINE NO. OF NEXT\n         LA    R15,20              SET RETURN CODE\n         B     INCRSCN1            GO SCAN FOR INCREMENT\n         SPACE\nNONEXTST LTR   R1,R1               IS NEXT OR PREV BAD\n         BM    NOPREV              BRANCH IF PREVIOUS\nNONEXT   SYSQS 1,0,'NEXT'\nNONEXT1  TM    CPLFLG4,CPFNOCUR    IS IT OK TO NOT EXIST\n         BE    NONEXT2             BR NO TO DO ERROR\n         LH    R0,=H'-1000'        SET R0 TO -1.000\n         L     R1,CPGLDL           SET R1 TO GLOBAL DELTA\n         B     INCRXIT           EXIT TO LINE NUMBER ROUTINE\n         SPACE\nNONEXT2  TSEG  (1),(0),B           PUT OUT FIRST PART\n         TSEG  'LINE DOES NOT EXIST',,M\n         B     CVQTYPE\n         SPACE\nSCNPREV1 BALR  R14,R5              GO LOCATE PREV LINE\n         PFREE 11                  FREE ANY LOCATED PAGE\n         LA    R15,24              SET RETURN CODE\n         L     R0,CPLCNO           ASSUME MATCH\n         TM    CPDRPT,CPFMTCH      WAS IT A MATCH\n         BO    INCRSCN1            YES, HAVE PREV GO INCR.\n         L     R0,CPREVLN          NO, LOAD PREV LINE NUMBER\n         TM    CPDRPT,CPFNTYT+CPFFSLN PREV LINE EXIST?\n         BZ    INCRSCN1            BRANCH YES TO INCREMENT\nNOPREV   SYSQS 1,0,'PREVIOUS'\n         B     NONEXT1             GO FINISH MESSAGE\n         DROP  R7\n         TITLE 'SCAN FOR LINE NUMBER INCREMENT'\n* TRY TO FIND A LINE NUMBER INCREMENT\n* R0 - LINE NUMBER + INCREMENT (IF FOUND)\n* R15 - RESTORED TO VALUE ON ENTRY FROM LNENOPRT\n         SPACE\nINCRSCN  DS    0H\n         SENTER 5,8,28             DEFINE BASE & SAVE AREA\nINCRSCN1 EQU   *-2                 ENTRY FROM END LINE NUMBER\n         LR    R5,R0               SAVE FIRST LINE NUMBER\n         ST    R15,16(,R8)         SAVE R15 RETURN CODE\n         L     R1,CPSAVE+4         POINT TO\n         ST    R1,20(,R8)          SAVE POINTER\n         AL    R1,CPSAVE                END OF LAST TOKE\n         CLI   0(R1),C'+'          PLUS INCREMENT\n         BE    INCRSCND            YES GO SCAN FOR IT\n         CLI   0(R1),C'-'          MINUS INCREMENT\n         BE    INCRSCND            YES GO SCAN FOR IT\nDELTACAL LTR   R15,R15             REGULAR LINE NO GIVEN\n         BNZ   DELTAUSE            NO USE GLOBAL DELTA\n         LM    R5,R6,CPSAVE        YES CALC DELTA FROM IT\nDELTALP  CLI   0(R6),C'.'          FIND PERIOD\n         BE    DELTAPER            YES\n         LA    R6,1(,R6)           NO, STEP TO NEXT\n         BCT   R5,DELTALP          REDUCE COUNT & LOOP\nDELTAUSE L     R1,CPGLDL           SET R1 TO GLOBAL DELTA\nINCRXIT  LR    R13,R8              RESTORE R13 FOR EXIT\n         LM    R5,R8,0(R13)        RESTORE RETURN REGISTERS\n         L     R15,16(,R13)        RESTORE RETURN CODE\n         LTR   R6,R6               IS RETURN ADDR ABS OR RELATIV\n         BPR   R6                  RETURN IF ABSOLUTE ADDR\n         LCR   R14,R6              COMPLEMENT ADDRESS\n         B     0(R10,R14)          RETURN NOW\n         SPACE\nDELTAPER IC    R5,DELTATBL-1(R5)   GET DELTA FROM TABLE\n         LTR   R1,R5               SET R1 AND TEST VALUE\n         BNZ   INCRXIT             O.K. IT NOT ZERO\n         B     DELTAUSE            USE CPGLDL IF ZERO\n         SPACE\nDELTATBL DC    FL1'0,100,10,1'     TABLE OF DELTAS\n         SPACE\nINCRSCND TM    CPLFLG4,CPFNOINC    IS THE NO INCR FLAG SET\n         BO    DELTACAL            BR YES TO SKIP INCR\n         SCAN  INCRPRT             SCAN FOR INCREMENT\n         LR    R0,R5               NOTHING RESTORE R0\n         B     DELTAUSE            USE DELTA INCREMENT\n         SPACE\nMINUS    LA    R6,INCOMPL          SET COMPLEMENT RETURN\n         B     INCRSCN2            GO GET LINE NUMBER\n         SPACE\nPLUS     LA    R6,INCROK           SET INCR OK RETURN\nINCRSCN2 SCAN  INCRPRT2            SCAN FOR LINE NUMBER\n         B     CVABSENT            MISSING\n         SPACE\nINCOMPL  LCR   R0,R0               COMPLEMENT RESULT\nINCROK   LR    R1,R5               SET ENTRY VALUE FOR ADDER\n         CVCALL ADDER              ADD LINENO AND INCR\n         BNM   DELTACAL            RETURN IF VALUE OKAY\n         LM    R0,R1,CPSAVE        GET END OF LAST TOKEN\n         AR    R0,R1                    INTO R0\n         L     R1,20(,R8)          GET START OF THIS LINE NUMBER\n         SR    R0,R1               CALCULATE LENGTH OF NUMBER\n         TSEG  (1),(0)             PUT PART OF MESSAGE\n         TSEG  ': INVALID VALUE'   SET REST OF MESSAGE\n         B     CVQTYPE\n         SPACE\nLNENOINC LR    R0,R15              NORMAL LINE NUMBER FOUND\n         SR    R15,R15             ZERO R15 FOR DELTACAL\n         BR    R6                  GO FINISH UP\n         SPACE\nDELTAINC L     R0,CPGLDL           DELTA SPECIFIED\n         BR    R6                  GO FINISH UP\n         SPACE\nINCRPRT  SCKW  +,PLUS\n         SCKW  -,MINUS\n         SCKW  ,INVALID\n         SPACE\nINCRPRT2 SCKW  ,LNENOINC,LN\n         SCKW  DELTA,DELTAINC,A\n         SCKW  ,INVALID\n         TITLE 'SCAN LINE FOR EXECUTE AND/OR FROM'\n* SCAN LINE TO SEE IF SELECT FROM ACTIVE, EXECUTE OR EXTERNAL\n         SPACE\nSCNEXFR  XENTER 7,8,C8+12\n         LA    R1,EXFRPRT          SET FOR EITHER FROM OR EXECUTE\n         SCANSAVE C8+4(R8)         SAVE SCAN POINTERS FOR RESTORE\n         SCAN  (1)                 SCAN FOR FROM OR EXECUTE\nSCNEXFR1 SCANRSTR C8+4(R8)         RESTORE SCANNER\n         XEXIT 7,8                 EXIT\n         SPACE\nGOTFROM  OI    CPLFLG5,CPFSELOC    SET TO USE EXTERNAL\n         B     SCNEXFR1            GO EXIT\n         SPACE\nGOTACT   NI    CPLFLG5,255-CPFSELOC   SET TO USE ACTIVE\n         B     SCNEXFR1            GO EXIT\n         SPACE\nGOTEXEC  NI    CPLFLG5,255-CPFSELOC   CLEAR LOCATE FLAGS\n         OI    CPLFLG5,CPFSELEX    SET TO USE EXEC\n         B     SCNEXFR1            GO EXIT\n         SPACE\nEXFRPRT  SCKW  EXECUTE,GOTEXEC,A\n         SCKW  FROM,GOTFROM,A\n         SCKW  ACTIVE,GOTACT,A\n         SCKW  ,,\n         TITLE 'COMMON ROUTINES, CONSTANTS AND DSECTS'\n         LTORG\n         EJECT\n         COPY  WYLCONST\n         EJECT\n         COMMON\n         SPACE\n         END\n./ ADD NAME=PROC,SSI=00000169\nPROC     TITLE 'PROCGO - INITIALIZATION STUFF'\n* PROPERTY OF C. U. C. C. A.\n         SPACE 3\n         GBLC  &USPS                                            USPS01\n&USPS    SETC  '1'                                              USPS01\n         AIF   ('&USPS' EQ '1').LBLX1                           USPS01\n*                                                               JEP016\n*                                                               JEP016\n*  MOD JEP016                                                   JEP016\n*   CORRECT CODE TO MAKE WYLTSO REENTRANT.                      JEP016\n*                                                               JEP016\n*                                                               JEP016\n*                                                               JEP001\n*  MOD JEP001                                                   JEP001\n*   IMPLEMENTED DCEC NAMING CONVENTIONS. DENOTED JEP001 66/71   JEP001\n*   MODULES AFFECTED: PDIO, PEDS, PUTB, INIT MACROS(DSNWA,CVTSOJEP001\n*                                                               JEP001\n*                                                               JEP001\n.LBLX1   DS   0H                                                USPS01\nPROC     CSECT\n         SPACE\n         WIDENT 001\n         SPACE\n         USING CPAREA,R12\n         SPACE\n         XTRNS ,\n         TITLE 'ASSIGN - STRING VARIABLE ASSIGNMENT ROUTINE'\n* THIS ROUTINE TAKES THE STRING WHOSE LENGTH IS IN R0 AND ADDR\n* IN R1 AND ASSIGNS IT AS THE NEW VALUE TO THE STRING VARIABLE\n* WHOSE RELATIVE ADDR IS IN R2.\n         SPACE\n* REGISTER EQU'S\n         SPACE\nASNLR    EQU   3\nASNAR    EQU   4\nASNSR    EQU   5\nASNWR    EQU   6\n         SPACE\nASSIGN   DS    0H\n         XENTER 0,8,*\n         AR    R2,VCPR            CONVERT VARIABLE ADDR TO ABS\n         L     ASNWR,JCBWAPTR     POINTER TO A WORK BUFFER\n         USING DASSIGN,ASNWR      USE BUFFER AS WORK AREA\n         USING DVCP,VCPR\n         LA    ASNSR,255\n         CR    0,ASNSR            TEST SIZE OF STRING\n         BNH   ASNOK              ITS ALRIGHT MA\n         TSEG  'STRING ASSIGNMENT EXCEEDS 255 CHARS'\n         B     CVQTYPE\n         SPACE\nASNOK    SR    ASNLR,ASNLR\n         IC    ASNLR,0(,2)         GET CURRENT LENGTH OF VAR\n         LR    ASNAR,0\n         SR    ASNAR,ASNLR      DIFFERENCE BETWEEN NEW & CURRENT LNG\n         AH    ASNAR,VCPSVAR       COMPUTE NEW TOTAL LENGTH OF SVARS\n         CH    ASNAR,=Y(VCPLSVA2)  CHECK AGAINST MAX\n         BH    ASNOVFLW\n         STH   ASNAR,VCPSVAR       UPDATE TOTAL LENGTH\n         LR    ASNAR,2\n         BCTR  ASNAR,0           POINT TO ID BYTE\n         IC    ASNSR,0(,ASNAR)    GET ID BYTE\n         N     ASNSR,=F'15'        CONVERT TO BINARY\n         SH    ASNSR,=Y(VCP#SVAR)  CALC # OF VARS TO END OF STR AREA\n         LPR   ASNSR,ASNSR\n         IC    ASNLR,1(,ASNAR)      GET LENGTH OF  VAR\n         LA    ASNAR,2(ASNLR,ASNAR)  BUMP TO NEXT VAR\n         BCT   ASNSR,*-8          LOOP TILL END OF STRING AREA\n         IC    ASNLR,0(,2)\n         LA    ASNLR,1(ASNLR,2) POINT TO START OF AREA TO BE MOVED\n         SR    ASNAR,ASNLR          LENGTH OF AREA TO BE SAVED\n         ST    ASNAR,DASNLSV       SAVE FOR LATER USE\n         LA    ASNSR,DASNTEMP     POINT TO SAVE AREA\n         LR    ASNAR,ASNLR\n         L     ASNLR,DASNLSV\n         BAL   14,ASNMOVE         MOVE SVAR VALS TO SAVE AREA\n         LTR   ASNSR,0\n         BZ    ASNSKIP            NULL STRING\n         BCTR  ASNSR,0\n         EX    ASNSR,ASNSET        ASSIGN NEW VALUE\nASNSKIP  STC   0,0(,2)            SET LENGTH\n         L     ASNLR,DASNLSV       GET LENGTH OF SAVED SVARS\n         LA    ASNAR,DASNTEMP     POINT TO SAVE AREA\n         LA    ASNSR,1(,2)\n         AR    ASNSR,0            POINT TO END OF NEW VALUE\n         BAL   14,ASNMOVE         RESTORE SVARS\n         XEXIT 0,8\n         SPACE\nASNSET   MVC   1(0,2),0(1)\n         SPACE\nASNMOVE  SH    ASNLR,=H'256'\n         BNP   ASNMLAST           MOVE LAST PART OF SAVED SVARS\n         MVC   0(256,ASNSR),0(ASNAR)\n         LA    ASNSR,256(,ASNSR)    BUMP POINTERS\n         LA    ASNAR,256(,ASNAR)\n         B     ASNMOVE\n         SPACE\nASNMLAST AH    ASNLR,=H'256'       RESTORE LENGTH OF LAST MOVE\n         BCTR  ASNLR,0\n         EX    ASNLR,ASNSAVE       MOVE LAST BIT\n         BR    14                 RETURN\n         SPACE\nASNSAVE  MVC   0(0,ASNSR),0(ASNAR)\n         SPACE\nASNOVFLW STM   0,1,CPWK1\n         TSEG  'STRING OVERFLOW ASSIGNING '''\n         LM    0,1,CPWK1\n         TSEG  (1),(0)\n         TSEG  ''''\n         B     CVQTYPE\n         DROP  ASNWR,VCPR\n         SPACE 3\n         LTORG\n         TITLE 'CONVERT1 - LINE NUMBER TO STRING CONVERSION ROUTINE'\n* REGISTER EQU'S\n         SPACE\nCONSR    EQU   2                  SCRATCH REGISTER\nCONSV    EQU   4                  R8 SAVE REGISTER\n         SPACE\n* THIS ROUTINE TAKES THE LINE # OR INTEGER IN R0 (R15= TYPE) AND\n* CONVERTS IT TO AN EBCDIC STRING, WHOSE LENGTH IS RETURNED IN\n* R0 AND ADDRESS IN R1.\n         SPACE\nCONVERT1 DS    0H\n         XENTER 2,8,DCONLNG\n         USING DCONVERT,8\n         LR    CONSV,8\n         LA    CONSR,7\n         AR    8,CONSR\n         OR    8,CONSR\n         XR    8,CONSR            ALIGN TO DOUBLE-WORD\n         CVD   0,DCONCVT          CONVERT TO ZONED DECIMAL\n         B     *(15)              CHECK TYPE\n         B     CON1INT            INTEGER\n         MVC   DCONWORK(L'CON1MSK1),CON1MSK1  MOVE IN EDIT PATTERN\n         LA    1,DCONWORK+12\n         EDMK  DCONWORK(L'CON1MSK1),DCONCVT  CONVERT TO EBCDIC\n         LA    0,DCONWORK+17\n         SR    0,1                CALC LENGTH OF STRING\n         CLI   DCONWORK+17,C'-'   TEST FOR NEGATIVE RESULT\n         BNE   CON1RTN            NON-NEGATIVE\nCON1NEG  BCTR  1,0\n         AH    0,=H'1'\n         MVI   0(1),C'-'          ADD MINUS SIGN\n         B     CON1RTN\n         SPACE\nCON1INT  MVC   DCONWORK(L'CON1MSK2),CON1MSK2  MOVE IN EDIT PATTERN\n         LA    1,DCONWORK+15\n         EDMK  DCONWORK(L'CON1MSK2),DCONCVT  CONVERT TO EBCDIC\n         LA    0,DCONWORK+16\n         SR    0,1                CALC LENGTH OF STRING\n         CLI   DCONWORK+16,C'-'   TEST FOR NEGATIVE RESULT\n         BE    CON1NEG            IT'S NEGATIVE\nCON1RTN  LR    8,CONSV\n         XEXIT 2,8\n         SPACE\nCON1MSK1 DS    0CL18              LINE # EDIT MASK\n         DC    C' '               FILL CHARACTER\n         DC    X'202020202020202020202120'\n         DC    C'.'\n         DC    X'202020',C'-'\nCON1MSK2 DS    0CL17              INTEGER EDIT MASK\n         DC    C' '               FILL CHARACTER\n         DC    13X'20'\n         DC    X'2120',C'-'\n         SPACE 3\n         LTORG\n         DROP  8\n         TITLE 'CONVERT2 - STRING TO LINE NUMBER CONVERSION ROUTINE'\n* THIS ROUTINE TAKES THE STRING WHOSE LENGTH IS IN R0 AND WHOSE\n* ADDRESS IS IN R1 AND CONVERTS IT (IF POSSIBLE) TO A LINE #\n* OR INTEGER, WHICH IS RETURNED IN R0 (R15= TYPE).\n         SPACE\nCONVERT2 DS    0H\n         XENTER 1,8,*\n         SCANSAVE\n         SCINIT (1),(0)\n         SR    R3,R3               ZERO R3 AS FLAG\n         LA    6,CON2LNE\n         SCAN  CON2PRT            USE SCANNER TO DO CONVERSION\n         SR    15,15              SET VALUE 0 IF NULL\nCON2INT  LR    0,15\n         LA    15,DEXPFIN         SET TYPE= INTEGER\n         B     CON2RTN\n         SPACE\nCON2LNE  LA    15,DEXPFLN         SET TYPE= LINE #\nCON2RTN  LTR   R3,R3               SHOULD VALUE BE COMPLEMENTED\n         BNM   *+6                 BRANCH NO\n         LCR   R0,R0               MAKE VALUE NEGATIVE\n         LR    2,0                SAVE VALUE\n         LR    3,15               SAVE TYPE\n         SCAN  ,                   SEE IF ANYTHING ELSE\n         BNZ   CON2ERR             ERROR IF THERE IS\n         SCANRSTR\n         LR    0,2                RESTORE VALUE\n         LR    15,3               RESTORE TYPE\n         XEXIT 1,8\n         SPACE\nCON2MIN  BCTR  R3,0                SET FLAG FOR LEADING MINUS\nCON2PLS  SCAN  CON2PRT2            FINISH SCAN(NO MORE + OR -)\nCON2ERR  TSEG  'STRING DOESN''T CONVERT TO ARITHMETIC'\n         B     CVQTYPE\n         SPACE\nCON2PRT  SCKW  -,CON2MIN\n         SCKW  +,CON2PLS\nCON2PRT2 SCKW  ,CON2INT,I\n         SCKW  ,LNENOPRT,PUSH\n         SCKW  ,CON2ERR\n         SPACE 3\n         LTORG\n         TITLE 'EXPR - EXPRESSION EVALUATION ROUTINE'\n* THIS IS THE EXPRESSION ANALYZER.  IT DOES A TOP DOWN\n* PARSE/EVALUATION OF THE EXPRESSION POINTED TO BY R1 (R0\n* CONTAINS THE SCAN LENGTH).  THERE ARE 4 EXIT CONDITIONS-\n*       (1)  A NULL EXPRESSION RETURNS WITH THE CC=0\n*       (2)  A STRING VALUED EXPRESSION WITH R0=LENGTH,\n*            R1=RELATIVE ADDRESS AND R15=TYPE\n*       (3)  A LINE NUMBER EXPRESSION WITH R0=VALUE,R15=TYPE\n*       (4)  AN INTEGER EXPRESSION WITH R0=VALUE,R15=TYPE\n*       (5)  AN INVALID EXPRESSION ABORTS TO CVGETCOM\n         SPACE\n* REGISTER EQU'S\n         SPACE\nEXPLR    EQU   4                  LINK REG\nEXPPR    EQU   3                  STACK POINTER\nEXPSR    EQU   6                  SCRATCH REG\nEXPB1    EQU   7                  BASE REG 1\nEXPB2    EQU   5                  BASE REG 2\n         SPACE\n* OPERATOR CODES\n         SPACE\nDEXPCOP  EQU   4                  ||\nDEXPAOP  EQU   8                  +\nDEXPSOP  EQU   12                 -\nDEXPMOP  EQU   16                 *\nDEXPDOP  EQU   20                 /\nDEXPUMOP EQU   24                 UNARY MINUS\nDEXPUPOP EQU   28                  UNARY PLUS\n         SPACE\n* FLAGS\nDEXPFOP  EQU   X'80'              OPERATOR FLAG\n         SPACE\nDEXPFST  EQU   0                  STRING VAR FLAG\nDEXPFIN  EQU   4                  INTEGER TYPE\nDEXPFLN  EQU   8                  LINE NUMBER VAR FLAG\n         SPACE\nEXPR     DS    0H\n         XENTER 2,8,*\n         USING *+4096,EXPB2\n         LA    EXPB2,1(,7)\n         LA    EXPB2,4095(,EXPB2)\n         OI    CPLFLG4,CPFNOINC   TELL LINE NUMBER PRT TO IGNORE + -\n         OI    CPLFLG4,CPFNOCUR   CURRENT,NEXT,ETC ALLOWED NOT TO EXIST\n         L     VCPR,CVCPADDR      POINT TO VCP\n         USING DVCP,VCPR\nEXPINIT  XC    DEXPSP(10),DEXPSP  ZERO POINTERS(OFFSETS)\n         SR    EXPSR,EXPSR\n         SPM   EXPSR              MASK OFF ARITHMETIC INTERRUPTS\n         BAL   EXPLR,EXPPUSH      EVALUATE EXPRESSION\n         CLI   8(EXPPR),DEXPFST  TEST TYPE OF VALUE\n         BNE   EXPLVAL            LINE NUMBER OR INTEGER\n         L     1,4(,EXPPR)\n         SR    0,0\n         IC    0,DEXPSWA(1)       GET LENGTH\n         LA    1,DEXPSWA+1-DVCP(R1) AND RELATIVE ADDR OF STRING\n         LA    15,DEXPFST         SET TYPE FLAG\n         B     EXPEXIT\n         SPACE\nEXPLVAL  L     0,4(,EXPPR)       GET VALUE\n         SR    15,15              GET TYPE\n         IC    15,8(,EXPPR)\nEXPEXIT  NI    CPLFLG4,255-CPFNOINC-CPFNOCUR  RESET FLAGS\n         LA    EXPSR,1\n         LTR   EXPSR,EXPSR        SET CC NON-ZERO\n         XEXIT 2,8                RETURN TO CALLER\n         SPACE 3\n* PROCESS A PRIMARY\n         SPACE\nEXPSCAN  LA    6,EXPLCON\n         L     R1,=A(EXPRVARS)\n         SCAN  (1)                PICK OFF A PRIMARY\n         B     EXP0EXIT           SYNTAX ERROR OR NULL EXPR\n         SPACE\nEXPDATE  TIME  BIN                 GET DATE AND TIME\n         XCALL FMTTIME             FORMAT IT FOR STRING\n         B     EXPSCON             GO FINISH UP\n         SPACE\nEXPVOL   SR    0,0                ZERO IN CASE NO VOL SET\n         LA    1,CPVOLSV          POINT TO VOL SAVE AREA\n         TM    CPGFLG,CPFVOLM     TEST FOR NULL VOL\n         BZ    EXPSCON            ITS NULL\n         LA    0,6                SET LENGTH\n         B     EXPSCON\n         SPACE\nEXPTERM  LA    1,=C'TSO'\n         LA    0,3\n         B     EXPSCON\n         SPACE\nEXPPROJ  TM    JCBAFL,JCBSYSPR\n         LA    0,7\n         BZ    SEVENXS\n         LA    1,=C'USXXXXX'\n         B     EXPSCON\n         SPACE\nSEVENXS  LA    1,=C'XXXXXXX'\n         B     EXPSCON\n         SPACE\nEXPREFIX LH    0,CPPFXL           GET LENGTH\n         LA    1,CPPFX            AND ADDRESS OF PREFIX\n         B     EXPSCON\n         SPACE\n         AIF   ('&USPS' EQ '1').LBL01                           USPS01\nEXPGROUP LA    0,L'CPGRPSV\n         LA    1,CPGRPSV\n         B     EXPSCON\n         SPACE\n.LBL01   DS   0H                                                USPS01\n         AIF   ('&USPS' NE '1').LBL02                           JEP001\nEXPUSER  EQU   *                                                JEP001\n         SR    R0,R0                                            JEP001\n         IC    R0,CVUSRFLD         PICK UP ID LENGTH            JEP001\n         AGO   .LBL03                                           JEP001\n.LBL02   DS    0H                                               JEP001\nEXPUSER  LA    0,L'CPUSERSV\n.LBL03   DS    0H                                               JEP001\n         LA    1,CPUSERSV\n         B     EXPSCON\n         SPACE\nEXPMEMB  SR    0,0\n         LA    1,CPMEMBSV\n         CLI   0(1),X'40'         TEST FOR NULL MEMBER\n         BE    EXPSCON            ITS NULL\n         LA    1,CPMEMBSV+L'CPMEMBSV\n         BCTR  1,0\n         CLI   0(1),C' '\n         BE    *-6                CHOP OFF TRAILING BLANKS\n         LA    0,1(,1)\n         LA    1,CPMEMBSV         POINT TO MEMBER\n         SR    0,1                CALC LENGTH\n         B     EXPSCON\n         SPACE\nEXPDELTA L     0,CPGLDL           GET CURRENT DELTA\n         B     EXPLCON\n         SPACE\nEXPBREAK L     R0,CVTRAPLN\n         B     EXPLCON\n         SPACE\nEXPLNGTH LH    15,CPLNGTH         GET CURRENT LENGTH\n         B     EXPICON\n         SPACE\nEXPPGCNT LH    15,CPAGCT\n         B     EXPICON\n         SPACE\nEXPLNCNT SLR   15,15\n         ICM   15,3,CPLNCT\n         B     EXPICON\n         SPACE\nEXPRANDM TIME  BIN\n         N     0,=A(255)\n         LR    15,0\n         B     EXPICON\n         SPACE\nEXPCPADD TM    JCBAFL,JCBSYSPR\n         BNO   CVNVALID\n         LA    15,CPSTART\n         ST    15,DEXPWK\n         UNPK  DEXPWK(9),DEXPWK(5)\n         TR    DEXPWK(8),EXPDSP3-C'0'\n         LA    1,DEXPWK+2\n         LA    0,6\n         B     EXPSCON\n         SPACE\nEXPPARM  L     1,CVPARM\n         LA    1,0(,1)\n         SR    0,0\n         IC    0,CVPARM\n         B     EXPSCON\n         SPACE\nEXPESCP  SR    0,0\n         LA    1,CPESCAPE         POINT TO ESCAPE CHAR\n         TM    CPGFLG2,CPESNULL   TEST FOR NULL ESCAPE\n         BO    EXPSCON            NULL\n         LA    0,1                GIVE LENGTH\n         B     EXPSCON\n         SPACE\nEXPSKIP  SR    0,0\n         LA    1,CPSKIP           POINT TO SKIP CHAR\n         TM    CPGFLG2,CPSKNULL   TEST FOR NULL SKIP CHAR\n         BO    EXPSCON\n         LA    0,1\n         B     EXPSCON\n         SPACE\nEXPSIZE  LA    15,DEXPSIZE        GET FUNCTION ID\n         BAL   EXPLR,EXPFNGO      FUNCTION PROLOGUE\n         BAL   14,EXPSTACK        GET SPACE FOR ARG\n         DC    Y(4)\n         BAL   EXPLR,EXPRFAS      EVALUATE ARG\n         DC    Y(1,DEXPFST)       ARG LIST\n         BAL   14,EXPUNSTK        FREE ARG SPACE\n         DC    Y(4)\nEXPSIZE1 L     1,0(,EXPPR)        GET STRING OFFSET\n         SR    0,0\n         IC    0,DEXPSWA(1)       GET LENGTH OF STRING\n         BAL   EXPLR,EXPSTRDL     DELETE STRING\n         BAL   EXPLR,EXPFNEND     FUNCTION EPILOGUE\n         LR    15,0\n         B     EXPICON\n         SPACE\nEXPRINDX LA    15,DEXPRNDX         FUNCTION ID\n         BAL   EXPLR,EXPFNGO\n         BAL   14,EXPSTACK         GET SPACE FOR ARGS\n         DC    Y(8)                ONLY TWO ARGUMENT\n         BAL   EXPLR,EXPRFAS       EAVL ARGS\n         DC    Y(2,DEXPFST,DEXPFST) LOOK FOR TWO STRINGS\n         BAL   14,EXPUNSTK         FREE ARG SPACE\n         DC    Y(8)\n         LA    14,EXPRNDX1         POINT TO 'RINDEX' ROUTINE\n         LA    15,DEXPRNDX         FUNCTION ID\n         B     INDXARGS\n         SPACE\nEXPINDX1 CR    2,0                COMPARE STRING LENGTHS\n         BH    EXPINDX2           STR2 NOT IN STR1\n         BCTR  2,0\n         EX    2,EXPINDX5         LOOK FOR MATCH\n         BE    EXPINDX3           STR2 IN STR1\n         LA    2,1(,2)            RESTORE LENGTH OF STR2\n         LA    1,1(,1)            BUMP STR1 POINTER\n         BCT   0,EXPINDX1         KEEP LOOKING...\n         B     EXPINDX2           NOT FOUND\n         SPACE\nEXPRNDX1 SR    0,2\n         BZ    EXPRNDXX           THEY ARE OF EQUAL LENGTH\n         BM    EXPINDX2           |STR1| < |STR2|\n         AR    1,0\n         AH    0,=H'1'\n         BCTR  2,0                 -1 FOR EXECUTE\nEXPRNDXL EX    2,EXPINDX5          LOOK FOR MATCH\n         BE    EXPINDX3\n         BCTR  1,0                 BACK UP ONE\n         BCT   0,EXPRNDXL          KEEP LOOKING\n         B     EXPINDX2\n         SPACE\nEXPRNDXX BCTR  2,0                 -1 FOR EXECUTE\n         EX    2,EXPINDX5\n         BE    EXPINDX3\n         B     EXPINDX2            NOT FOUND\n         SPACE\nEXPINDEX LA    15,DEXPINDX        GET FUNCTION ID\n         BAL   EXPLR,EXPFNGO\n         BAL   14,EXPSTACK        GET SPACE FOR ARGS\n         DC    Y(8)\n         BAL   EXPLR,EXPRFAS      EVAL ARGS\n         DC    Y(2,DEXPFST,DEXPFST) ARG LIST\n         BAL   14,EXPUNSTK        FREE ARG SPACE\n         DC    Y(8)\n         LA    R14,EXPINDX1       'INDEX' FUNCTION\n         LA    R15,DEXPINDX\nINDXARGS CLI   8(EXPPR),2         TEST NUMBER OF ARGS\n         BE    EXPINDX0           THERE MUST BE 2\n         LA    15,DEXPINDX\n         BL    EXPERR3\n         B     EXPERR2\n         SPACE\nEXPINDX0 L     1,4(,EXPPR)        OFFSET OF STR1\n         SR    0,0\n         IC    0,DEXPSWA(1)       GET LENGTH AND\n         LA    1,DEXPSWA+1(1)     ADDR OF STR1\n         LTR   0,0                TEST FOR NULL STRING\n         BZ    EXPINDX2           NO INDEX IN NULL STRING\n         L     EXPSR,0(,EXPPR)    OFFSET OF STR2\n         SR    2,2\n         IC    2,DEXPSWA(EXPSR)   GET LENGTH AND\n         LA    EXPSR,DEXPSWA+1(EXPSR) ADDRESS OF STR2\n         LTR   2,2\n         BNP   EXPINDX2           NULL STR2\n         BR    R14                CALL 'INDEX' OR 'RINDEX'\n         SPACE\nEXPINDX2 SR    0,0                NOT FOUND\n         B     EXPINDX4\n         SPACE\nEXPINDX3 L     EXPSR,4(,EXPPR)    GET OFFSET OF STR1\n         LA    EXPSR,DEXPSWA(EXPSR)\n         SR    1,EXPSR            CALC INDEX\n         LR    0,1\nEXPINDX4 L     1,0(,EXPPR)        GET OFFSET OF STR2\n         BAL   EXPLR,EXPSTRDL     DELETE STR2\n         L     1,4(,EXPPR)        GET OFFSET OF STR1\n         BAL   EXPLR,EXPSTRDL     DELETE STR1\n         BAL   EXPLR,EXPFNEND     FUNCTION EPILOGUE\n         LR    15,0\n         B     EXPICON\n         SPACE\nEXPXPND  LA    R15,DEXPXPND\n         BAL   EXPLR,EXPFNGO\n         BAL   R14,EXPSTACK\n         DC    Y(4)\n         BAL   EXPLR,EXPRFAS\n         DC    Y(1,DEXPFST)\n         BAL   R14,EXPUNSTK\n         DC    Y(4)\n         L     R6,0(,EXPPR)\n         SR    R2,R2\n         IC    R2,DEXPSWA(R6)     LENGTH OF ARG\n         LTR   R2,R2\n         BNZ   EXPXPND1\n         SR    R0,R0\n         B     EXPXPND3           RETURN NULL AS RESULT\n         SPACE\nEXPXPND1 C     R2,=F'128'         CAN'T BE MORE\n         BH    EXPXPND4           ERROR\n         LA    R6,DEXPSWA+1(R6)   POINT TO STRING\n         L     R4,JCBWAPTR        GET A WA\n         LR    R0,R2\nEXPXPND2 MVC   0(1,R4),0(R6)      MOVE A CHAR\n         MVI   1(R4),C' '              AND A BLANK\n         LA    R6,1(R6)           ADVANCE 1 ON INPUT\n         LA    R4,2(,R4)          ADVANCE 2 ON OUTPUT\n         BCT   R2,EXPXPND2\n         SLL   R0,1               MULTIPLY LENGTH BY 2\n         BCTR  R0,0               AND REDUCE BY 1\nEXPXPND3 L     R1,0(,EXPPR)       ARG\n         BAL   EXPLR,EXPSTRDL     DELETE IT\n         L     R1,JCBWAPTR        RESULT ADDRESS\n         BAL   EXPLR,EXPFNEND\n         B     EXPSCON\n         SPACE\nEXPXPND4 SYSQS 1,0,'ARGUMENT OF EXPAND EXCEEDS 128 CHARS'\n         B     EXPQTYPE\n         SPACE\nEXPINDX5 CLC   0(0,1),0(EXPSR)\n         SPACE\nEXPCORE  TM    JCBAFL,JCBSYSPR\n         BNO   CVNVALID\n         LA    R15,EXPDUMER\n         ST    R15,CVSPIEAD\n         LA    R15,DEXPCORE\n         BAL   EXPLR,EXPFNGO\n         BAL   EXPLR,EXPSFAS\n         DC    Y(DEXPFIN+1)\n         L     R4,0(,EXPPR)        GET ARGUMENT\n         LA    R4,0(,R4)           CLEAR HI ORDER BYTE\n         L     R2,16               CVT ADDRESS\n         L     R2,164(,R2)         CVTMZ00 VALUE\n         S     R2,=F'3'            LESS THREE\n         CR    R4,R2               TO BIG AN ADDRESS?\n         BH    EXPDUMER            YEP, INVALID ADDRESS\n         MVC   DEXPWK(4),0(R4)     MOVE THE 4 BYTES\n         L     R15,DEXPWK          RETURN THE VALUE\n         BAL   R4,EXPFNEND         CLEAR FUNCTION\n         B     EXPICON             RETURN VALUE\n         SPACE\nEXPTDUMP TM    JCBAFL,JCBSYSPR     SYS PRIV?\n         BNO   CVNVALID            NO. DONT DO\n         LA    R15,EXPDUMER\n         ST    R15,CVSPIEAD\n         LA    15,DEXPTDU          FUNCTION ID\n         BAL   R4,EXPFNGO          PROLOUGE\n         BAL   14,EXPSTACK         GET  ARG  SPACE\n         DC    Y(8)\n         BAL   R4,EXPRFAS          EVAL  ARGS\n         DC    Y(2,DEXPFST,DEXPFIN)\n         BAL   14,EXPUNSTK         FREE  ARG  SPACE\n         DC    Y(8)\n         LA    15,DEXPTDU\n         L     R6,0(R3)            #  BYTES  WANTED\n         CLI   8(R3),2             #  ARGS\n         BH    EXPERR2             MUST  BE   1   OR  2\n         BE    EXPTDU1\n         CLI   8(R3),1\n         BL    EXPERR3\n         B     EXPTDU2\n         SPACE\nEXPTDU1  C     R6,=F'64'           64  BYTES  MAX\n         BH    EXPERR4\n         LTR   R6,R6\n         BNZ   EXPTDU3\nEXPTDU2  LA    R6,4\n         ST    R6,0(R3)            SET  DEFAULT  4\n         SPACE\n* GET CORE LOCATION\nEXPTDU3  SR    R6,R6\n         L     R4,4(R3)            OFFSET\n         IC    R6,DEXPSWA(R4)      LEN  OF  STRING\n         LA    R1,DEXPSWA+1(R4)    STRING  ADDRESS\n         SPACE\n* CHECK FOR VALID HEX CONSTANT\nEXLET    CLI   0(R1),C'A'\n         BL    EXPERR5\n         CLI   0(R1),C'F'\n         BNH   EXNUMNXT\n         CLI   0(R1),C'0'\n         BL    EXPERR5\n         CLI   0(R1),C'9'\n         BH    EXPERR5\nEXNUMNXT LA    R1,1(R1)\n         BCT   6,EXLET\n         LA    R1,DEXPSWA+1(R4)    RESTORE  STRING  ADDR\n         IC    R6,DEXPSWA(R4)      GET  STRING  LEN\n         LR    R4,R6               SAVE  LENGTH\n         BCTR  R6,0\n         EX    R6,EXPWHEX2         TR (C=C3) TO FC FOR PACK)\n         EX    R4,EXPWHEX3         PACK  (FC  TO  C)\n         L     R4,DEXPWK           GET  CORE  ADDR  IN  BIN\n         LA    R4,0(R4)            CLEAR HI ORDER BYTE\n         L     R2,16\n         L     R2,164(R2)          GET  CVTZM00\n         L     R6,0(R3)            #  BYTES\n         SR    R2,R6\n         CR    R4,R2               ADDRESS  IN  CORE?\n         BH    EXPDUMER            NO.  BRANCH\n         L     R1,JCBWAPTR\n         LR    R0,R6               SAVE  # BYES\n         BCTR  R6,0\n         EX    R6,MOVECORE         MOVE CORE CONTENTS TO BUF\n         LA    R2,80(R1)           UNPACK CORE  (128  BYTES MAX)\n         LR    R14,R2              SAVE UNPACK LOC\n         LR    R6,R0               SAVE LENGTH\n         B     EXPTDU13\n         SPACE\nEXPTDU12 UNPK  0(15,2),0(8,1)      UNPACK  7  BYTES\n         LA    2,14(,2)\n         LA    1,7(,1)            BUMP POINTERS\nEXPTDU13 SH    R6,=H'7'        DECR LENGHT\n         BP    EXPTDU12           UNPACK 7 MORE\n         AH    R6,=H'7'        RESTORE REMAINING LENGTH\n         BNP   EXPTDU14           NONE LEFT\n         ST    R6,DEXPWK       SAVE EFFECTIVE L2\n         LA    R6,1(,R6)    L2\n         AR    R6,R6\n         SH    R6,=H'2'        CALC EFFECTIVE L1\n         SLL   R6,4(0)         POSITION L1\n         O     R6,DEXPWK       'OR' IN L2\n         EX    R6,EXPDSP4      UNPACK REMAINDER\nEXPTDU14 AR    0,0                CALC LENGTH OF RESULT\n         LR    R2,R14              RESTORE  UNPACK  ADDRESS\n         LR    R6,0\n         BCTR  R6,0\n         EX    R6,EXPDSP5          CONVERT TO EBCIDIC\n         L     R1,4(R3)            GET  OFFSET\n         BAL   R4,EXPSTRDL         DELETE\n         LR    R1,R2               RESTORE  ADDRESS\n         BAL   R4,EXPFNEND\n         B     EXPSCON\n         SPACE\nMOVECORE MVC   0(0,R1),0(R4)       MOVE  CORE\n         SPACE\nEXPDUMER SYSQS 1,0,'INVALID ADDRESS'\n         B     EXPQTYPE\n         SPACE\nEXPRSBTR LA    15,DEXPRSUB         FUNCTION ID\n         BAL   EXPLR,EXPFNGO\n         BAL   14,EXPSTACK\n         DC    Y(12)               3 ARGS\n         BAL   EXPLR,EXPRFAS\n         DC    Y(3,DEXPFST,DEXPFIN,DEXPFIN)\n         BAL   14,EXPUNSTK         FREE ARG SPA\n         DC    Y(12)\n         CLI   12(EXPPR),3\n         BNH   EXPRSUB0\n         LA    15,DEXPRSUB\n         B     EXPERR2\n         SPACE\nEXPRSUB0 CLI   12(EXPPR),2\n         BNL   EXPRSUB1\n         LA    15,DEXPRSUB\n         B     EXPERR3\n         SPACE\nEXPRSUB1 L     EXPLR,8(,EXPPR)     OFFSET OF STR\n         SR    2,2\n         IC    2,DEXPSWA(EXPLR)    LENGTH\n         L     EXPSR,4(,EXPPR)     OFFSET INTO STR\n         SR    2,EXPSR\n         LA    2,1(,2)\n         ST    2,4(,EXPPR)         NEW VALUE\n         B     EXPSBST1\n         SPACE\nEXPSBSTR LA    15,DEXPSBST        FUNCTION ID\n         BAL   EXPLR,EXPFNGO      PROLOGUE\n         BAL   14,EXPSTACK        GET ARG SPACE\n         DC    Y(12)\n         BAL   EXPLR,EXPRFAS      EVAL ARGS\n         DC    Y(3,DEXPFST,DEXPFIN,DEXPFIN)  ARG LIST\n         BAL   14,EXPUNSTK        FREE ARG SPACE\n         DC    Y(12)\n         CLI   12(EXPPR),3        TEST NUMBER OF ARGS\n         BNH   EXPSBST0           MUST BE 2 OR 3\n         LA    15,DEXPSBST\n         B     EXPERR2\n         SPACE\nEXPSBST0 CLI   12(EXPPR),2\n         BNL   EXPSBST1\n         LA    15,DEXPSBST\n         B     EXPERR3\n         SPACE\nEXPSBST1 L     EXPSR,4(,EXPPR)    CHECK POSITION\n         L     EXPLR,8(,EXPPR)    OFFSET OF STR1\n         LTR   EXPSR,EXPSR         CHECK THAT VALUE IS POSITIVE\n         BNP   EXPSUBNV            BAD IF NOT\n         C     EXPSR,=F'256'       CHECK POSITIVE VALUE <= 256\n         BH    EXPSUBNV            NO GOOD IF NOT\n         CLI   12(EXPPR),3        CHECK NUMBER OF ARGS\n         BE    EXPSBST2           LENGTH GIVEN\n         SR    EXPSR,EXPSR\n         IC    EXPSR,DEXPSWA(EXPLR)   LENGTH OF ARG1\n         LA    EXPSR,1(,EXPSR)\n         S     EXPSR,4(,EXPPR)    CALC IMPLIED LENGTH\n         BNM   *+6                 LENGTH O.K. IF >= 0\n         SR    EXPSR,EXPSR         USE ZERO (NULL STRING) IF NEG\n         ST    EXPSR,0(,EXPPR)    SET IMPLIED LENGTH\nEXPSBST2 L     R1,JCBWAPTR\n         MVI   0(1),C' '           BLANK THE AREA\n         MVC   1(256,1),0(1)          FOR SUBSTR'S OUT OF RANGE\n         IC    EXPSR,DEXPSWA(EXPLR)   GET LENGTH OF STRING\n         LA    EXPLR,DEXPSWA(EXPLR)   POINT TO STRING\n         EX    EXPSR,EXPSBSTM      MOVE STRING TO BUFFER AREA\n         L     EXPSR,0(,EXPPR)    GET SPECIFIED LENGTH\n         LTR   EXPSR,EXPSR        TEST LENGTH\n         BM    EXPSUBNV           INVALID LENGTH\n         BZ    EXPSBST3           NULL STRING, IGNORE POSITION\n         A     EXPSR,4(,EXPPR)    ADD IN POSITION\n         C     EXPSR,=F'256'       CHECK START+LENGTH  <= 256\n         BNH   EXPSBST3            BR YES, IT'S OK\nEXPSUBNV SYSQS 1,0,'INVALID SUBSTRING'\n         B     EXPQTYPE\n         SPACE\nREVBAD   SYSQS 1,0,'STRING EXCEEDS 255 CHARS'\n         B     EXPQTYPE\n         SPACE\nEXPSBSTM MVC   0(0,1),0(EXPLR)         EX MOVE TO CP BUFF AREA\nREVTR    TR    0(0,1),1(EXPSR)\nPADZAP   MVC   2(0,1),1(1)         PROPAGATE PAD CHAR.\nPADMVC   MVC   0(0,2),1(EXPSR)     MOVE STRING OVER PADDED AREA\nTRIMMVC  MVC   6(0,1),1(EXPSR)\nTRIMCLI  CLI   0(EXPLR),0          LOOK FOR TRIM CHAR\n         SPACE\nEXPSBST3 A     1,4(,EXPPR)        BUMP TO SUBSTRING\n         ST    1,4(,EXPPR)        SAVE POINTER\n         L     1,8(,EXPPR)        GET ARG1 OFFSET\n         BAL   EXPLR,EXPSTRDL     DELETE ARG1\n         L     1,4(,EXPPR)        GET SUBSTRING POINTER\n         L     0,0(,EXPPR)        GET LENGTH\n         BAL   EXPLR,EXPFNEND     EPILOGUE\n         B     EXPSCON\n         SPACE\nEXPXLATE LA    R15,DEXPXLAT       FUNC ID\n         BAL   EXPLR,EXPFNGO      FUNC INIT\n         BAL   R14,EXPSTACK       STACK FOR 3 ARGS\n         DC    Y(12)\n         BAL   EXPLR,EXPRFAS      EVAL ARGS\n         DC    Y(3,DEXPFST,DEXPFST,DEXPFST)\n         BAL   R14,EXPUNSTK       FREE STACK\n         DC    Y(12)\n         LA    R15,DEXPXLAT       FUNC ID\n         CLI   12(EXPPR),2        # OF ARGS\n         BL    EXPERR3            TOO FEW\n         L     R2,8(,EXPPR)       1ST ARG\n         SR    R0,R0\n         IC    R0,DEXPSWA(R2)     R0 = LEN OF ARG 1\n         LTR   R0,R0\n         BZ    EXPXLAT4           RETURN NULL AS RESULT\n         LA    R1,DEXPSWA+1(R2)   R1 = ADDR OF ARG 1\n         L     R4,JCBWAPTR        WORK AREA\n         LR    R15,R0\n         EX    R15,XLATMVC1       MOVE 1ST ARG TO WA\n         L     R2,4(,EXPPR)       2ND ARG\n         SR    R4,R4\n         IC    R4,DEXPSWA(R2)     R4 = LEN OF ARG 2\n         LTR   R4,R4\n         BZ    EXPXLAT4           RETURN 1ST ARG AS RESULT\n         LA    R2,DEXPSWA(R2)     R2 = ADDR 2ND ARG - 1\n         CLI   12(EXPPR),2        IS THERE A 3RD ARG?\n         BE    EXPXLAT1           NO, JUST DELETE FUNC\n         L     R14,0(,EXPPR)      3RD ARG\n         SR    R15,R15\n         IC    R15,DEXPSWA(R14)   R15 = LEN OF 3RD ARG\n         LTR   R15,R15\n         BZ    EXPXLAT1           JUST DELETE FUNC\n         LA    R14,DEXPSWA(R14)   R14 = ADDR OF 3RD ARG - 1\n         LA    R1,255\n         STC   R1,0(R1,R13)       CREATE A\n         BCT   R1,*-4                      TR TABLE\n         MVI   0(R13),0           0TH BYTE OF TR TABLE\n         CR    R15,R4             IS 3RD ARG > 2ND ARG ?\n         BNH   *+6                NO, SKIP NEXT\n         LR    R15,R4             MAKE 3RD ARG SHORTER\n         SR    R4,R15             R4 = # OF DELETE CHARS\nEXPXLAT0 IC    R1,0(R15,R2)       GET A SELECT CHAR\n         IC    R6,0(R15,R14)      GET ITS XLATION\n         STC   R6,0(R1,R13)       PUT IT IN TR TABLE\n         BCT   R15,EXPXLAT0\n         L     R6,JCBWAPTR        1ST ARG\n         LR    R15,R0\n         EX    R15,XLATTR         XLATE 1ST ARG\n         LTR   R4,R4              ANY DELETE CHARS\n         BZ    EXPXLAT4           NO, RETURN RESULT\n         L     R6,4(,EXPPR)       2ND ARG\n         IC    R15,DEXPSWA(R6)    LEN OF ORIGINAL 2ND ARG\n         AR    R2,R15             ADDR OF LAST CHAR OF 2ND ARG\n         SR    R2,R4              ADDR OF DELETE CHARS - 1\nEXPXLAT1 MVI   0(R13),0           CREATE A\n         MVC   1(255,R13),0(R13)           TRT TABLE\n         SR    R1,R1\nEXPXLAT2 IC    R1,0(R4,R2)        GET A DELETE CHAR\n         STC   R4,0(R1,R13)       PUT A NON-0 BYTE IN TABLE\n         BCT   R4,EXPXLAT2\n         L     R6,JCBWAPTR        XLATED 1ST ARG\n         LR    R4,R0              LEN OF 1ST ARG\nEXPXLAT3 EX    R4,XLATTRT         FIND A CHAR TO DELETE\n         BC    8+2,EXPXLAT4\n         BCTR  R0,0               DECR LEN OF 1ST ARG\n         SR    R6,R1              - # OF CHARS SKIPPED OVER\n         AR    R4,R6              # OF CHARS REMAINING\n         BCTR  R4,0               LESS 1 TO BE DELETED\n         LR    R6,R1              CONTINUE WHERE STOPPED\n         EX    R4,XLATMVC2        MOVE REMAINING 1 PLACE\n         B     EXPXLAT3           AND MORE\n         SPACE\nEXPXLAT4 L     R1,0(,EXPPR)       3RD ARG\n         BAL   EXPLR,EXPSTRDL     DELETE IT\n         L     R1,4(,EXPPR)       2ND ARG\n         BAL   EXPLR,EXPSTRDL     DELETE IT\n         L     R1,8(,EXPPR)       1ST ARG\n         BAL   EXPLR,EXPSTRDL     DELETE IT\n         L     R1,JCBWAPTR        RESULT ADDRESS\n         BAL   EXPLR,EXPFNEND     FUNC END\n         B     EXPSCON            RETURN A STRING\n         SPACE\nXLATMVC1 MVC   0(0,R4),0(R1)      TO MOVE 1ST ARG TO WA\nXLATTR   TR    0(0,R6),0(R13)     TO XLATE\nXLATTRT  TRT   0(0,R6),0(R13)     TO FIND A DELETE CHAR\nXLATMVC2 MVC   0(0,R1),1(R1)      TO DELETE A CHAR\n         SPACE\nEXPREVRS LA    15,DEXPREV          FUNCTION ID\n         BAL   EXPLR,EXPFNGO\n         BAL   14,EXPSTACK\n         DC    Y(4)\n         BAL   EXPLR,EXPRFAS\n         DC    Y(1,DEXPFST)        1 STRING ARGUMENT\n         BAL   14,EXPUNSTK\n         DC    Y(4)\n         LA    15,DEXPREV\n         CLI   4(EXPPR),1      ONLY ONE ARG ALOWED\n         BH    EXPERR2\n         BL    EXPERR3\n         SR    2,2\n         L     EXPSR,0(,EXPPR)     PTR TO STR\n         IC    2,DEXPSWA(EXPSR)    LENGTH\n         LA    EXPSR,DEXPSWA(EXPSR)  POINT TO STRING\n         LTR   2,2\n         BZ    REVNULL             NULL STRING\n         C     2,=F'256'\n         BNL   REVBAD\n         LA    EXPLR,REVTAB+256\n         SR    EXPLR,2             BACK UP\n         BCTR  2,0                 -1 FOR EX\n         L     1,JCBWAPTR        WORK AREA\n         EX    2,EXPSBSTM          MOVE PART OF TABLE OVER\n         EX    2,REVTR             USE TR TO REVERSE\n         LA    2,1(,2)             RESTORE LENGTH\nREVNULL  L     1,0(,EXPPR)\n         BAL   EXPLR,EXPSTRDL\n         L     1,JCBWAPTR\n         LR    0,2                 GET LENGTH\n         BAL   EXPLR,EXPFNEND\n         B     EXPSCON\n         SPACE\nEXPDUPL  LA    15,DEXPDUPL         FUNCTION ID\n         BAL   EXPLR,EXPFNGO\n         BAL   14,EXPSTACK\n         DC    Y(8)                2 ARGS: DUPL(STR,#)\n         BAL   EXPLR,EXPRFAS\n         DC    Y(2,DEXPFST,DEXPFIN)  EVAL ARGS\n         BAL   14,EXPUNSTK\n         DC    Y(8)                FREE STACK ENTRY\n         LA    15,DEXPDUPL\n         CLI   8(EXPPR),2          BOTH ARGS SPECIFIED?\n         BH    EXPERR2             TOO MANY\n         BL    EXPERR3             TOO FEW\n         L     EXPLR,4(,EXPPR)     OFFSET OF STRING 2 B DUPL'D\n         LA    EXPLR,DEXPSWA(EXPLR)  POINT TO STRING\n         CLI   0(EXPLR),0          NULL STRING\n         BZ    DUPLNULL            RETURN NULL STR\n         L     1,JCBWAPTR          GET WORK AREA\n         SR    2,2\n         IC    2,0(,EXPLR)         GET LENGTH\n         BCTR  2,0                 -1 FOR EXECUTE\n         EX    2,DUPLMVC\n         L     EXPLR,0(,EXPPR)     GET THE DUPL FACTOR\n         LTR   EXPLR,EXPLR\n         BZ    DUPLNULL            RETURN NULL IF 0\n         BNP   BADDUPL\n         LA    15,1(,2)            LENGTH OF STR\n         MR    14,EXPLR            TOTAL WOULD BE LENGTH\n         C     15,=F'255'\n         BH    DUPLTRNK            MUST TRUNCATE\n         BCTR  15,0                -1 FOR EX\n         LA    2,3(2,1)            POINT PAST STRING\n         EX    15,DUPLDUPL\n         LR    2,1                 ADDRESS OF RESULT\n         LA    15,1(,15)           TRUE LENGTH OF RESULT\n         STH   15,0(,1)            SAVE\nDUPLFREE L     1,4(,EXPPR)         ADDR OF STR\n         BAL   EXPLR,EXPSTRDL      FREE\n         LH    0,0(,2)             LENGTH OF RESULT\n         LA    1,2(,2)             POINT TO RESULT\nDUPLRET  BAL   EXPLR,EXPFNEND\n         B     EXPSCON\n         SPACE\nDUPLTRNK SYSQS 1,0,'DUPL''D STRING EXCEEDS 255 CHARS'\n         B     EXPQTYPE\n         SPACE\nBADDUPL  SYSQS 1,0,'DUPLICATION FACTOR MUST BE POSITIVE'\n         B     EXPQTYPE\n         SPACE\nDUPLNULL L     R1,4(,EXPPR)\n         BAL   EXPLR,EXPSTRDL\n         SR    R0,R0\n         L     R1,JCBWAPTR\n         B     DUPLRET\n         SPACE\nDUPLMVC  MVC   2(0,1),1(EXPLR)     MOVE STR 2 BE DUPL\nDUPLDUPL MVC   0(0,2),2(1)         DUPLICATE\n         SPACE\nEXPLPAD  LA    15,DEXPLPAD        FUNCTION ID\n         BAL   EXPLR,EXPFNGO\n         BAL   14,EXPSTACK\n         DC    Y(12)              PAD(STR,SIZE,PADCHAR)\n         BAL   EXPLR,EXPRFAS\n         DC    Y(3,DEXPFST,DEXPFIN,DEXPFST)\n         BAL   14,EXPUNSTK\n         DC    Y(12)\n         LA    15,DEXPLPAD\n         LA    0,1                 INDICATE LEFT PADDING\n         B     PADARG\n         SPACE\nEXPRPAD  LA    15,DEXPRPAD        FUNCTION ID\n         BAL   EXPLR,EXPFNGO\n         BAL   14,EXPSTACK\n         DC    Y(12)              PAD(STR,SIZE,PADCHAR)\n         BAL   EXPLR,EXPRFAS\n         DC    Y(3,DEXPFST,DEXPFIN,DEXPFST)\n         BAL   14,EXPUNSTK\n         DC    Y(12)\n         LA    15,DEXPRPAD\n         SR    0,0                 INDICATE RIGHT PADDING\nPADARG   CLI   12(EXPPR),3         THREERARGS?\n         BH    EXPERR2\n         BE    GETPAD\n         CLI   12(EXPPR),2         DEFAULT OF BLANK?\n         BL    EXPERR3\n         LA    2,X'40'             LOAD A BLANK\n         B     DOPAD\n         SPACE\nGETPAD   L     EXPLR,0(,EXPPR)     GET OFFSET OF CHAR\n         LA    EXPLR,DEXPSWA(EXPLR)     POINT TO CHAR\n         CLI   0(EXPLR),1          ONLY 1 CHAR ALLOWED\n         BNE   BADPAD\n         IC    2,1(EXPLR)          GET ACTUAL PAD CHAR\n         B     DOPAD               GO PAD\n         SPACE\nBADPAD   SYSQS 1,0,'PAD STRING MUST BE 1 CHAR'\n         B     EXPQTYPE\n         SPACE\nDOPAD    L     1,JCBWAPTR\n         L     EXPLR,4(,EXPPR)     'SIZE' TO PAD TO\n         LTR   EXPLR,EXPLR\n         BNP   EXPERR4\n         C     EXPLR,=F'256'       TOO BIG?\n         BNL   REVBAD              YES.. TELL USER\n         L     EXPSR,8(,EXPPR)     POINT TO STRING TO BE PADDED\n         LA    EXPSR,DEXPSWA(EXPSR)\n         SR    14,14\n         IC    14,0(,EXPSR)        GET LENGTH\n         CR    14,EXPLR            STRING ALREADY TOO LONG?\n         BNL   NOPAD               YES.. NO PAD NEEDED\n         STC   2,2(,1)             SAVE PADDING CHARACTER\n         MVC   3(256,1),2(1)       PROPAGATE PAD CHAR\n         STH   EXPLR,0(,1)         SAVE LENGTH\n         LTR   14,14               LENGTH OF STR\n         BZ    PADRET              NULL STRING.. RETURN ALL PAD\n         SPACE\n* AT THIS POINT WE NEED TO EXTEND THE STRING.\n*   R0=0 ===> EXTEND (PAD) ON THE RIGHT END\n*   R0=1 ===> INSERT IN FRONT\n*\n* FIRST .. ASSUME PADDING TO BE ON THE RIGHT\n         SPACE\n         LA    2,2(,1)             POINT PAST THE LENGTH\n         STH   EXPLR,0(,1)         SAVE RESULTANT LENGTH\n         LTR   0,0                 IS IT RPAD?\n         BZ    ITSRPAD\n         AR    2,EXPLR\n         SR    2,14                MOVE UP POINTER\nITSRPAD  BCTR  14,0                -1 FOR EXECUTE\n         EX    14,PADMVC\n         B     PADRET\n         SPACE\nNOPAD    STH   14,0(,1)\n         BCTR  14,0                -1 FOR EXECUTE\n         LA    2,2(,1)\n         EX    14,PADMVC\nPADRET   ST    1,4(,EXPPR)         ADDRESS OF RESULT\n         L     1,0(,EXPPR)\n         BAL   EXPLR,EXPSTRDL      DELETE STR1\n         L     1,8(,EXPPR)\n         BAL   EXPLR,EXPSTRDL      DELETE STR2\n         L     1,4(,EXPPR)         POINTER TO STRING\n         LH    0,0(,1)             GET LENGTH\n         LA    1,2(,1)             POINT TO THE STRING PROPER\n         BAL   EXPLR,EXPFNEND\n         B     EXPSCON\n         SPACE\nEXPLTRIM LA    15,DEXPLTRM\n         BAL   EXPLR,EXPFNGO\n         BAL   14,EXPSTACK\n         DC    Y(8)\n         BAL   EXPLR,EXPRFAS\n         DC    Y(2,DEXPFST,DEXPFST)\n         BAL   14,EXPUNSTK\n         DC    Y(8)\n         LA    15,DEXPLTRM\n         LA    0,1                 INDICATE LTRIM\n         B     TRIMARG\n         SPACE\nEXPRTRIM LA    15,DEXPRTRM\n         BAL   EXPLR,EXPFNGO\n         BAL   14,EXPSTACK\n         DC    Y(8)\n         BAL   EXPLR,EXPRFAS\n         DC    Y(2,DEXPFST,DEXPFST)\n         BAL   14,EXPUNSTK\n         DC    Y(8)\n         LA    15,DEXPRTRM\n         SR    0,0                 INDICATE RTRIM\nTRIMARG  CLI   8(EXPPR),2          TWO ARGS?\n         BH    EXPERR2             MORE...TOO MANY\n         CLI   8(EXPPR),1          ONLY 1? ==> TRIM(...,' ')\n         BL    EXPERR3             NO.. NOT ENUF\n         BE    TRIMDFLT            USE BLANK AS DEFAULT CHAR\n         L     EXPLR,0(,EXPPR)     OFFSET OF TRIM CHAR\n         LA    EXPLR,DEXPSWA(EXPLR) POINT TO STRING\n         CLI   0(EXPLR),1          LENGTH OF 1 ?\n         BNE   BADTRIM\n         IC    2,1(,EXPLR)         GET TRIM CHAR\n         B     *+8                 BRANCH AROUND DFLT SETTING\n         SPACE\nTRIMDFLT LA    2,X'40'             SET DEFAULT TO A BLANK\n         L     EXPSR,4(,EXPPR)     OFFSET OF STRING TO BE TRIMMED\n         LA    EXPSR,DEXPSWA(EXPSR) POINT TO STRING\n         SR    14,14\n         IC    14,0(,EXPSR)        GET LENGTH\n         LTR   14,14               ANYTHING?\n         BZ    NULLTRIM            NO .. JUST RETURN THE NULL STR\n         L     1,JCBWAPTR          WORK AREA\n         STH   14,4(,1)            SAVE ITS LENGTH\n         LA    EXPLR,6(,1)         POINTER TO STRING\n         ST    EXPLR,0(,1)         SAVE POINTER\n         BCTR  14,0                PREPARE TO MOVE THE STRING\n         EX    14,TRIMMVC\n         LA    14,1(,14)           RESTORE TO ORIG LENGTH\n         LTR   0,0                 LTRIM OR RTRIM?\n         BZ    RTRIM\n         SPACE\n* ITS TRIM FROM THE LEFT\nLTRIM    EX    2,TRIMCLI           COMPARE AGAINST TRIM CHAR\n         BNE   TRIMEND\n         LA    EXPLR,1(,EXPLR)\n         BCT   14,LTRIM\n         B     TRIMEND\n         SPACE\nRTRIM    AR    EXPLR,14            POINT PAST END OF STRING\n         BCTR  EXPLR,0             BACK UP TO LAST CHAR\nRTRIML   EX    2,TRIMCLI\n         BNE   TRIMENDR\n         BCTR  EXPLR,0             BACK UP ANOTHER CHAR\n         BCT   14,RTRIML\nTRIMENDR LA    EXPLR,6(,1)         POINT TO START OF STRING\nTRIMEND  STH   14,4(,1)\n         ST    EXPLR,0(,1)\n         L     1,0(,EXPPR)         PTR TO TRIM CHAR IF ANY\n         BAL   EXPLR,EXPSTRDL      DELETE\n         L     1,4(,EXPPR)         PTR TO STRING TRIMMED\n         BAL   EXPLR,EXPSTRDL\n         L     1,JCBWAPTR\n         LH    0,4(,1)\n         L     1,0(,1)             ADDRESS OF RESULT\n         BAL   EXPLR,EXPFNEND\n         B     EXPSCON\n         SPACE\nBADTRIM  SYSQS 1,0,'TRIM STRING MUST BE 1 CHAR'\n         B     EXPQTYPE\n         SPACE\nNULLTRIM L     1,0(,EXPPR)\n         BAL   EXPLR,EXPSTRDL\n         L     1,4(,EXPPR)\n         BAL   EXPLR,EXPSTRDL\n         SR    0,0\n         L     1,JCBWAPTR\n         BAL   EXPLR,EXPFNEND\n         B     EXPSCON\n         SPACE\nEXPAND   LA    15,DEXPAND         FUNCTION ID\n         LA    R2,EXAND           FUNCTION INSTR\n         B     EXPLOGIC           ENTER MAIN STREAM\n         SPACE\nEXPOR    LA    15,DEXPOR          FUNCTION ID\n         LA    R2,EXOR            'OC' INSTR\n         B     EXPLOGIC\n         SPACE\nEXPXOR   LA    15,DEXPXOR         FUNCTION ID\n         LA    R2,EXXOR           'XC' INSTR\nEXPLOGIC BAL   EXPLR,EXPFNGO      PROLOGUE\n         BAL   14,EXPSTACK        GET SOME STACK SPACE\n         DC    Y(8)               TWO THINGIES\n         ST    R2,0(,EXPPR)       INSTR ADDR\n         ST    R15,4(,EXPPR)      FUNCTION ID\n         BAL   14,EXPSTACK        GET ARG SPACE\n         DC    Y(8)               2 ARGS\n         BAL   EXPLR,EXPRFAS      EVALUATE ARGS\n         DC    Y(2,DEXPFST,DEXPFST)  2 STRINGS\n         BAL   14,EXPUNSTK        RELEASE STACK SPACE\n         DC    Y(8)\n         CLI   8(EXPPR),2         BOTH ARGS SUPPLIED?\n         BE    EXPXOR1            YEP\n         BAL   14,EXPUNSTK        POP STACK\n         DC    Y(8)               TO OUR TWO THINGIES\n         L     R15,4(,EXPPR)      FUNCTION ID\n         CLI   16(EXPPR),2        TOO FEW/MANY?\n         BH    EXPERR2            TOO MANY ARGS\n         BL    EXPERR3            TOO FEW\n         SPACE\n* WE HAVE TWO STRING INPUTS..\n* FIRST INSURE THAT THEY ARE OF EQUAL LENGTH\n* ELSE USE LENGTH OF SHORTER STRING\n         SPACE\nEXPXOR1  L     1,0(,EXPPR)         OFFSET OF STR2\n         SR    15,15\n         IC    15,DEXPSWA(1)       LENGTH\n         LA    1,DEXPSWA+1(1)      ADDR OF STR2\n         L     14,4(,EXPPR)\n         SR    0,0\n         IC    0,DEXPSWA(14)       LENGTH\n         LA    14,DEXPSWA+1(14)    ADDR OF STR1\n         SPACE\n* NOW HAVE R14 R0 POINT TO THE SHORTER STRING\n         CR    0,15\n         BNL   XORSET              ALL SET\n         XR    R14,R1\n         XR    R1,R14\n         XR    R14,R1              FLIP R14,R1\n         XR    R15,R0\n         XR    R0,R15\n         XR    R15,R0              FLIP R15,R0\nXORSET   LTR   15,15               XOR('','') ?\n         BNP   XORDONE             YEA.. NO-OP.. RETURN ''\n         BCTR  15,0                -1 FOR EXECUTE\n         LR    R2,EXPPR           STACK TOP\n         S     R2,=F'8'            BACK UP\n         L     R2,0(,R2)           ADDR OF INSTR TO BE EX'D\n         EX    15,0(,2)\n         LR    R15,R0              LENGTH OF LONGER STRING\n         SPACE\n* ALL DONE... R14,R15 POINT TO RESULTANT STRING\nXORDONE  L     1,0(,EXPPR)         STR1 PTR\n         BAL   EXPLR,EXPSTRDL      DELETE\n         L     1,4(,EXPPR)         STR2 PTR\n         BAL   EXPLR,EXPSTRDL      DELETE IT\n         LR    0,15                LENGTH\n         LR    1,14                ADDR OF RESULT\n         BAL   14,EXPUNSTK         RESTORE OUR STACK\n         DC    Y(8)\n         BAL   EXPLR,EXPFNEND      EPILOGUE\n         B     EXPSCON             EXIT\n         SPACE\nEXXOR    XC    0(0,14),0(1)\nEXOR     OC    0(0,14),0(1)\nEXAND    NC    0(0,14),0(1)\n         SPACE\nEXPNEG   LA    15,DEXPNEG          FNCN ID\n         BAL   EXPLR,EXPFNGO\n         BAL   14,EXPSTACK\n         DC    Y(4)                ONE ARG\n         BAL   EXPLR,EXPRFAS       EVAL ARG\n         DC    Y(1,DEXPFST)         ALLOWED TYPES\n         BAL   14,EXPUNSTK          RELEASE THE SPACE\n         DC    Y(4)\n         CLI   4(EXPPR),1           ONE ARG?\n         LA    15,DEXPNEG\n         BL    EXPERR3\n         BH    EXPERR2\n         L     2,0(,EXPPR)         STR OFFSET\n         SR    15,15               CLEAR REG\n         IC    15,DEXPSWA(2)       GET LENGTH OF STRING\n         LA    14,DEXPSWA+1(2)     POINT TO STRING\n         L     1,JCBWAPTR          PTR TO OUR WORK AREA\n         STC   R15,0(,R1)          SAVE LENGTH OF RESULT\n         LTR   15,15               LENGTH\n         BZ    NEGNULL             NOOP .. RETURN NULL\n         MVI   1(1),X'FF'          SET UP FOR NEGATION\n         EX    15,NEGMVC           FILL UP WITH X'FF'\n         BCTR  15,0                -1 FOR EXECUTE\n         EX    15,NEGXOR           XOR WITH 'X'FF...FF'\nNEGNULL  L     1,0(,EXPPR)         STRING OFFSET\n         BAL   EXPLR,EXPSTRDL      DELETE IT\n         BAL   EXPLR,EXPFNEND      EPILOGUE\n         L     1,JCBWAPTR\n         SR    0,0\n         IC    0,0(,1)             GET LENGTH\n         LA    1,1(,1)             POINT TO STRING\n         B     EXPSCON             WE GOT'EM STRING\n         SPACE\nNEGMVC   MVC   2(0,1),1(1)\nNEGXOR   XC    1(0,1),0(R14)\n         SPACE\nEXPSCONV LA    15,DEXPSCON        GET FUNCTION ID\n         BAL   EXPLR,EXPFNGO      PROLOGUE\n         BAL   14,EXPSTACK        GET SPACE FOR ARGS\n         DC    Y(4)\n         BAL   EXPLR,EXPRFAS      EVAL ARG\n         DC    Y(1,DEXPFST)       ARG LIST\n         BAL   14,EXPUNSTK        UNSTACK ARG\n         DC    Y(4)\n         L     1,0(,EXPPR)        GET OFFSET\n         LA    15,DEXPFST         AND TYPE\n         BAL   EXPLR,EXPFNEND     EPILOGUE\n         B     EXPVRSTK           STACK RESULT\n         SPACE\nEXPWCONV LA    15,DEXPWCON        FUNCTION ID\n         BAL   EXPLR,EXPFNGO      PROLOGUE\n         BAL   14,EXPSTACK        GET ARG SPACE\n         DC    Y(4)\n         BAL   EXPLR,EXPRFAS      EVAL ARG\n         DC    Y(1,DEXPFLN)       ARG LIST\n         BAL   14,EXPUNSTK        FREE ARG SPACE\n         DC    Y(4)\n         L     0,0(,EXPPR)        GET VALUE\n         BAL   EXPLR,EXPFNEND     EPILOGUE\n         B     EXPLCON\n         SPACE\nEXPNCONV LA    15,DEXPNCON        FUNCTION ID\n         BAL   EXPLR,EXPFNGO      PROLOGUE\n         BAL   14,EXPSTACK        GET ARG SPACE\n         DC    Y(4)\n         BAL   EXPLR,EXPRFAS      EVAL ARG\n         DC    Y(1,DEXPFIN)       ARG LIST\n         BAL   14,EXPUNSTK        FREE ARG SPACE\n         DC    Y(4)\n         L     15,0(,EXPPR)       GET VALUE\n         BAL   EXPLR,EXPFNEND     EPILOGUE\n         B     EXPICON\n         SPACE\nEXPVRFY  LA    15,DEXPVRF         FUNCTION ID\n         BAL   EXPLR,EXPFNGO      PROLOGUE\n         BAL   14,EXPSTACK        GET ARG SPACE\n         DC    Y(8)\n         BAL   EXPLR,EXPRFAS      EVAL ARG\n         DC    Y(2,DEXPFST,DEXPFST) ARG LIST\n         BAL   14,EXPUNSTK        FREE ARG SPACE\n         DC    Y(8)\n         CLI   8(EXPPR),2         TEST NUMBER OF ARGS\n         BE    *+12               MUST BE 2\n         LA    15,DEXPVRF\n         B     EXPERR3            TOO MANY ARGS...\n         SPACE\n         L     EXPSR,JCBWAPTR     USE BUFFER AS TRT TABLE\n         MVI   0(EXPSR),1         INITIALIZE TRT TABLE\n         MVC   1(255,EXPSR),0(EXPSR)\n         L     1,0(,EXPPR)        OFFSET OF STR2\n         SR    0,0\n         IC    0,DEXPSWA(1)       LENGTH AND\n         LA    1,DEXPSWA+1(1)     ADDRESS OF STR2\n         LTR   0,0\n         BP    EXPVRF1            2ND ARG NOT NULL\n         L     1,4(,EXPPR)        GET OFFSET OF STR1\n         LA    1,DEXPSWA(1)\n         SR    15,15\n         CLI   0(1),0             TEST FOR STR1 NULL\n         BE    EXPVRF3            ITS NULL\n         LA    15,1               1ST CHAR NOT IN NULL STRING\n         B     EXPVRF3\n         SPACE\nEXPVRF1  SR    15,15              ZERO R15 AND R14\n         LR    14,15\nEXPVRF2  IC    14,0(,1)           GET CHAR OF STR2\n         STC   15,0(14,EXPSR)     ZERO TRT TABLE\n         LA    1,1(,1)            BUMP STR2 POINTER\n         BCT   0,EXPVRF2          LOOP FOR ALL CHARS\n         L     1,4(,EXPPR)        OFFSET OF STR1\n         IC    14,DEXPSWA(1)      LENGTH OF STR1\n         LA    1,DEXPSWA+1(1)     ANDDRESS OF STR1\n         LTR   14,14              TEST LENGTH OF STR1\n         BNP   EXPVRF4            ERROR- STR1 CAN'T BE NULL\n         BCTR  14,0\n         SR    2,2\n         LR    15,1               SAVE STR1 ADDR FOR INDEX CALC\n         EX    14,EXPVRF5         VERIFY\n         SR    15,2               DECR R15 BY 1 IF ILLEGAL CHAR\n         SR    1,15               CALC INDEX (0 IF OK)\n         LR    15,1\nEXPVRF3  L     1,0(,EXPPR)        GET STR2 OFFSET\n         BAL   EXPLR,EXPSTRDL     DELETE STR2\n         L     1,4(,EXPPR)        GET STR1 OFFSET\n         BAL   EXPLR,EXPSTRDL     DELETE STR1\n         BAL   EXPLR,EXPFNEND     EPILOGUE\n         B     EXPICON\n         SPACE\nEXPVRF4  SYSQS 1,0,'RESULT OF VERIFY UNDEFINED'\n         B     EXPQTYPE\n         SPACE\nEXPVRF5  TRT   0(0,1),0(EXPSR)\n         SPACE\nEXPDSPY  LA    15,DEXPDSP         FUNCTION ID\n         BAL   EXPLR,EXPFNGO      PROLOGUE\n         BAL   EXPLR,EXPSFAS      EVAL ARG\n         DC    Y(DEXPFLN+DEXPFIN+DEXPFST+1)  PERMISSABLE TYPES\n         CLI   4(EXPPR),DEXPFST   TEST TYPE\n         BE    EXPDSP1            STRING\n         MVC   DEXPWK,0(EXPPR)    MOVE VALUE TO WORK AREA\n         UNPK  DEXPWK(9),DEXPWK(5)  UNPACK\n         TR    DEXPWK(8),EXPDSP3-C'0'  CONVERT EBCDIC\n         LA    1,DEXPWK           ADDRESS AND\n         LA    0,8                LENGTH\n         B     EXPDSP2\n         SPACE\nEXPDSP1  L     1,0(,EXPPR)        GET STRING OFFSET\n         SR    0,0\n         IC    0,DEXPSWA(1)       GET LENGTH OF STRING\n         CH    0,=H'127'          TEST LENGTH\n         BNH   EXPDSP11           OK\n         SYSQS 1,0,'ARGUMENT OF DISPLAY EXCEEDS 127 CHARS'\n         B     EXPQTYPE\n         SPACE\nEXPDSP11 LA    1,DEXPSWA+1(1)     ADDRESS OF STRING\n         L     2,JCBWAPTR         GET BUFFER\n         LTR   EXPSR,0            TEST FOR NULL STRING\n         BNP   EXPDSP15           NULL\n         B     EXPDSP13\n         SPACE\nEXPDSP12 UNPK  0(15,2),0(8,1)     UNPACK 7 BYTES\n         LA    2,14(,2)\n         LA    1,7(,1)            BUMP POINTERS\nEXPDSP13 SH    EXPSR,=H'7'        DECR LENGHT\n         BP    EXPDSP12           UNPACK 7 MORE\n         AH    EXPSR,=H'7'        RESTORE REMAINING LENGTH\n         BNP   EXPDSP14           NONE LEFT\n         ST    EXPSR,DEXPWK       SAVE EFFECTIVE L2\n         LA    EXPSR,1(,EXPSR)    L2\n         AR    EXPSR,EXPSR\n         SH    EXPSR,=H'2'        CALC EFFECTIVE L1\n         SLL   EXPSR,4(0)         POSITION L1\n         O     EXPSR,DEXPWK       'OR' IN L2\n         EX    EXPSR,EXPDSP4      UNPACK REMAINDER\nEXPDSP14 AR    0,0                CALC LENGTH OF RESULT\n         L     R2,JCBWAPTR\n         LR    EXPSR,0\n         BCTR  EXPSR,0\n         EX    EXPSR,EXPDSP5      CONVERT TO EBCDIC\nEXPDSP15 L     1,0(,EXPPR)        OFFSET OF ARG\n         BAL   EXPLR,EXPSTRDL     DELETE\n         L     R1,JCBWAPTR\nEXPDSP2  BAL   EXPLR,EXPFNEND\n         B     EXPSCON\n         SPACE\nEXPDSP3  DC    C'0123456789ABCDEF'\n         SPACE\nEXPDSP4  UNPK  0(0,2),0(0,1)\nEXPDSP5  TR    0(0,2),EXPDSP3-C'0'\n         SPACE\nEXPWHEX  LA    15,DEXPWHX         FUNCTION ID\n         BAL   EXPLR,EXPFNGO      PROLOGUE\n         BAL   EXPLR,EXPSFAS      EVAL ARG\n         DC    Y(DEXPFST+1)       ONLY STRING ARG ALLOWED\n         BAL   EXPLR,EXPHEX       CHECK FOR VALID HEX CONSTANT\n         LTR   EXPSR,0            CHECK LENGTH\n         BNP   EXPWHEX1           NULL\n         CH    0,=H'8'            TEST FOR OVERFLOW\n         BH    EXPAOVF            OVERFLOW\n         BCTR  EXPSR,0\n         EX    EXPSR,EXPWHEX2     TRANSLATE FOR PACK\n         LR    EXPSR,0            RESTORE TRUE LENGTH\n         EX    EXPSR,EXPWHEX3     PACK\n         L     0,DEXPWK           GET VALUE\nEXPWHEX1 L     1,0(,EXPPR)        GET OFFSET\n         BAL   EXPLR,EXPSTRDL     DELETE\n         BAL   EXPLR,EXPFNEND     EPILOGUE\n         B     EXPLCON\n         SPACE\nEXPWHEX2 TR    0(0,1),EXPWHEX4-C'A'\nEXPWHEX3 PACK  DEXPWK(5),0(0,1)\n         SPACE\nEXPWHEX4 DC    X'FAFBFCFDFEFF'\n         DS    XL(C'0'-C'F'-1)\n         DC    C'0123456789'\n         SPACE\nEXPNHEX  LA    15,DEXPNHX         FUNCTION ID\n         BAL   EXPLR,EXPFNGO      PROLOGUE\n         BAL   EXPLR,EXPSFAS      EVAL ARG\n         DC    Y(DEXPFST+1)       ONLY STRING ARG ALLOWED\n         BAL   EXPLR,EXPHEX       CHECK FOR VALID HEX CONSTANT\n         LTR   EXPSR,0            CHECK LENGTH\n         BNP   EXPNHEX1           NULL\n         CH    0,=H'8'            TEST FOR OVERFLOW\n         BH    EXPAOVF            OVERFLOW\n         BCTR  EXPSR,0\n         EX    EXPSR,EXPWHEX2     TRANSLATE FOR PACK\n         LR    EXPSR,0            RESTORE TRUE LENGTH\n         EX    EXPSR,EXPWHEX3     PACK\n         L     15,DEXPWK          GET VALUE\nEXPNHEX1 L     1,0(,EXPPR)        GET OFFSET\n         BAL   EXPLR,EXPSTRDL     DELETE\n         BAL   EXPLR,EXPFNEND     EPILOGUE\n         B     EXPICON\n         SPACE\nEXPSHEX  LA    15,DEXPSHX         FUNCTION ID\n         BAL   EXPLR,EXPFNGO      PROLOGUE\n         BAL   EXPLR,EXPSFAS      EVAL ARG\n         DC    Y(DEXPFIN+DEXPFST+1) PERMISSIBLE TYPES\n         CLI   4(EXPPR),DEXPFIN   TEST TYPE\n         BE    EXPSHEX6           INTEGER\n         BAL   EXPLR,EXPHEX       CHECK FOR VALID HEX CONSTANT\n         LTR   EXPSR,0            CHECK LENGTH\n         BP    EXPSHEX1           NOT NULL\n         SR    0,0\n         B     EXPSHEX5\n         SPACE\nEXPSHEX1 BCTR  EXPSR,0\n         EX    EXPSR,EXPWHEX2     TRANSLATE FOR PACK\n         LR    EXPSR,0            RESTORE TRUE LENGTH\n         L     R2,JCBWAPTR        POINTER TO WORK AREA\n         B     EXPSHEX3\n         SPACE\nEXPSHEX2 PACK  0(8,2),0(15,1)     CONVERT 14 BYTES\n         LA    2,7(,2)\n         LA    1,14(,1)           BUMP POINTERS\nEXPSHEX3 SH    EXPSR,=H'14'       DECR STRING LENGTH\n         BP    EXPSHEX2           CONVERT 14 MORE\n         AH    EXPSR,=H'14'       RESTORE REMAINING LENGTH\n         BNP   EXPSHEX4           NONE LEFT\n         ST    EXPSR,DEXPWK       SAVE LENGTH\n         LA    EXPSR,1(,EXPSR)\n         SRL   EXPSR,1(0)         L1= (L2+1)/2\n         SLL   EXPSR,4(0)         POSITION L1\n         O     EXPSR,DEXPWK       'OR' IN L2\n         EX    EXPSR,EXPSHEX7     CONVERT REMAINDER\nEXPSHEX4 AH    0,=H'1'            LENGTH OF RESULT=\n         SRL   0,1(0)             (ARG LENGTH+1)/2\nEXPSHEX5 L     1,0(,EXPPR)        OFFSET OF STRING\n         BAL   EXPLR,EXPSTRDL     DELETE STRING\n         BAL   EXPLR,EXPFNEND     EPILOGUE\n         L     R1,JCBWAPTR        GET RESULT ADDRESS\n         B     EXPSCON\n         SPACE\nEXPSHEX6 LA    0,4\n         BCTR  EXPPR,0\n         LA    EXPPR,1(,EXPPR)    BUMP POINTER\n         CLI   0(EXPPR),0         STRIP LEADING ZEROS\n         BNE   *+12\n         BCT   0,*-12             MORE ZEROS\n         LA    0,1                RETURN 1 ZERO\n         LR    1,EXPPR            ADDRESS\n         BAL   EXPLR,EXPFNEND     EPILOGUE\n         B     EXPSCON\n         SPACE\nEXPSHEX7 PACK  0(0,2),0(0,1)\n         SPACE\n* UNARY MINUS AND UNARY PLUS ARE ALWAYS STACKED\nEXPREMIN LA    2,DEXPUMOP          SET UNARY MINUS\n         B     EXPREMP             GO TO COMMON CODE\n         SPACE\nEXPREPLS LA    2,DEXPUPOP          SET UNARY PLUS\nEXPREMP  BAL   14,EXPSTACK         RESERVE SPACE FOR DUMMY OPERND\n         DC    Y(5)\n         STC   2,DEXPWK            SAVE OPERATOR FOR STACKING\n         SRL   2,3                 GET OPERATOR PRECEDENCE\n         B     EXPOPSTK            GO STACK OPERATOR\n         SPACE\nEXPLOOK  XCALL LOOKUP\n         BZ    EXPEXPR            NOT A VARIABLE\n         B     *+4(15)            USE TYPE CODE AS INDEX\n         SPACE\n         B     EXPSVAR            STRING VARIABLE\n         B     EXPIVAR            INTEGER VARIABLE\n         B     EXPLVAR            LINE # VARIABLE\n         SPACE\nEXPEXPR  CLI   0(1),C'('          TEST FOR ( <EXPR> )\n         BNE   EXPQTST\n         BAL   14,EXPSTACK\n         DC    Y(8)\n         SCANSAVE 0(EXPPR)        SAVE SCAN INFO\n         LA    1,1(,1)\n         SH    0,=H'2'            DELETE PARENS\n         BNP   EXP0EXIT\n         BAL   EXPLR,EXPPUSH      EVAL EXPRESSION\n         L     1,4(,EXPPR)       GET POINTER/VALUE\n         SR    15,15\n         IC    15,8(,EXPPR)       GET TYPE CODE\n         BAL   14,EXPUNSTK\n         DC    Y(8)\n         SCANRSTR 0(EXPPR)        RESTORE SCAN POINTER\n         B     EXPVRSTK\n         SPACE\nEXPQTST  CLI   0(1),C''''         TEST FOR STRING\n         BE    EXPDQSCN           A STRING CONSTANT\n         CLI   0(1),C'\"'\n         BE    EXPDQSCN           DE-QUOTE STRING\n         CLI   0(1),C'#'          A HEX NUMBER COMING UP?\n         BE    EXPHEX#            YEP\nDOTMARK  TMARK     PUT IN CARR. RETURN IF BUFFER NOT EMPTY\n         B     CVNVALID\n         SPACE\nEXPHEX#  BCT   R0,EXPHEX#1\n         B     DOTMARK\n         SPACE\nEXPHEX#1 LA    R1,1(,R1)           SKIP OVER '#'\n         CH    R0,=H'8'           AT MOST 8 HEX CHARS ALLOWED\n         BH    HEX2LONG           TSK\n         SR    R15,R15            RESULT REGISTER\nEXPHEX#2 SR    R14,R14            CLEAR WORK REGISTER\n         CLI   0(R1),C'A'         VALID?\n         BL    BADHEX#\n         CLI   0(R1),C'F'\n         BH    TRYDIGIT\n         IC    R14,0(R1)          GET CHARACTER\n         N     R14,=X'0000000F'   CLEAR ZONE\n         LA    R14,9(,R14)        CONV TO HEX\nEXPMERGE SLL   R15,4\n         OR    R15,R14            BUILD UP THE NUMBER\n         LA    R1,1(,R1)          NEXT HEX CHAR\n         BCT   R0,EXPHEX#2        GET NEX DIGIT\n         B     EXPICON            MAKE IT LOOK LIKE INTEGER\n         SPACE\nTRYDIGIT CLI   0(R1),C'0'         VALID?\n         BL    BADHEX#\n         CLI   0(R1),C'9'\n         BH    BADHEX#\n         IC    R14,0(,R1)\n         N     R14,=X'0000000F'    CLEAR ZONE\n         B     EXPMERGE\n         SPACE\nBADHEX#  TSEG  'ILLEGAL HEX CONSTANT'\n         B     CVQTYPE            EXIT\n         SPACE\nHEX2LONG TSEG  'HEX CONSTANT EXCEEDS 8 DIGITS'\n         B    CVQTYPE\n         SPACE\nEXPDQSCN CVCALL DQSCAN            DE-QUOTE STRING\n         B     EXPSCON\n         SPACE\nEXPSVAR  SR    0,0\n         IC    0,0(VCPR,R1)       GET LENGTH OF STRING\n         LA    1,1(VCPR,R1)       AND ADDRESS\nEXPSCON  BAL   EXPLR,EXPSTRMV     MOVE STRING TO STRING AREA\n         LA    15,DEXPFST         GET TYPE CODE\n         B     EXPVRSTK\n         SPACE\nEXPIVAR  L     15,0(VCPR,1)       GET VALUE OF INTEGER\nEXPICON  LR    1,15\n         LA    15,DEXPFIN         SET TYPE\n         B     EXPVRSTK           STACK\n         SPACE\nEXPLVAR  L     0,0(VCPR,1)        GET VALUE OF LINE #\nEXPLCON  LA    15,DEXPFLN         GET TYPE CODE\n         LR    1,0\nEXPVRSTK BAL   14,EXPSTACK        GET STACK SPACE\n         DC    Y(5)\n         ST    1,0(,EXPPR)        STACK POINTER/VALUE\n         STC   15,4(,EXPPR)       SET TYPE CODE\n         SPACE\n* PROCESS AN OPERATOR\n         SPACE\n         SCANSAVE DEXPWK          SAVE SCAN INFO IN CASE OF RESCAN\n         SCAN  EXPROPS            SCAN FOR OPERATOR\nEXPOPCLR SR    2,2                EMPTY STACK\n         BCTR  2,0\n         B     EXPOPTST\n         SPACE\nEXPOPFND STC   2,DEXPWK           SAVE OPERATOR\n         SRL   2,3                GET OPERATOR PRECEDENCE\nEXPOPTST L     EXPPR,DEXPSP       GET STACK POINTER\n         SH    EXPPR,=H'8'        DEC TO POSSIBLE LAST OPERATOR\n         LA    EXPPR,DEXPSTK(EXPPR)  CALC STACK ADDRESS\n         CLI   0(EXPPR),DEXPFOP   MAKE SURE ITS AN OPERATOR\n         BNE   EXPOPSTK\n         SR    EXPSR,EXPSR\n         IC    EXPSR,1(,EXPPR)    GET PRECEDENCE OF TOP STACK OPERATOR\n         CR    2,EXPSR            CHECK FOR HIGHER PRECEDENCE OPERATOR\n         BNH   EXPEVAL            EVALUATE TERM\nEXPOPSTK LTR   2,2                TEST FOR END OF EXPR\n         BM    EXPPOP             POP BACK TO NEXT LEVEL\n         BAL   14,EXPSTACK\n         DC    Y(3)\n         STC   2,1(,EXPPR)        STACK OPERATOR PRECEDENCE\n         MVI   0(EXPPR),DEXPFOP   FLAG OPERATOR\n         MVC   2(1,EXPPR),DEXPWK  STACK OPERATOR\n         B     EXPSCAN            LOOK FOR NEXT PRIMARY\n         SPACE\n* EVALUATE A TERM\n         SPACE\nEXPEVAL  BAL   14,EXPUNSTK        UNSTACK TOP TWO OPERANDS AND OPERATOR\n         DC    Y(13)\n         CLI   7(EXPPR),DEXPCOP   TEST FOR CONCATENATION\n         BE    EXPCAT\n         LA    EXPPR,8(,EXPPR)    POINT TO OPERAND2\n         BAL   EXPLR,EXPCVTAR     CONVERT TO ARITH.\n         SH    EXPPR,=H'8'        RESET STACK POINTER\n         CLI   7(EXPPR),DEXPUMOP   IS IT UNARY MINUS OR PLUS\n         BL    EXPEVALA            NO, GO DO NORMAL BINARY OP\n         L     0,8(,EXPPR)         GET SECOND OPERAND\n         MVC   4(1,EXPPR),12(EXPPR) SET TYPE OF RESULT\n         BNE   EXPEVAL4            DONE IF NOT UNARY MINUS\n         LCR   0,0                 COMPLEMENT VALUE\n         BNO   EXPEVAL4            NOW GO STACK RESULT IF OK\n         B     EXPAOVF             ERROR FOR OVERFLOW\n         SPACE\nEXPEVALA BAL   EXPLR,EXPCVTAR     CONVERT OPERAND1\n         CLI   12(EXPPR),DEXPFLN  TEST FOR LINE #\n         BE    EXPEVAL1\n         CLI   4(EXPPR),DEXPFLN\n         BNE   EXPEVAL2           CONVERT TO INTEGER\nEXPEVAL1 BAL   EXPLR,EXPCVTLN     CONVERT 1ST OPERAND TO LINE #\n         LA    EXPPR,8(,EXPPR)    POINT TO 2ND OPERAND\n         BAL   EXPLR,EXPCVTLN     CONVERT TO LINE #\n         B     EXPEVAL3\n         SPACE\nEXPEVAL2 BAL   EXPLR,EXPCVTIN     CONVERT TO INTEGER\n         LA    EXPPR,8(,EXPPR)    POINT TO 2ND OPERAND\n         BAL   EXPLR,EXPCVTIN     CONVERT TO INTEGER\nEXPEVAL3 SH    EXPPR,=H'8'\n         L     0,0(,EXPPR)        GET VALUE OF 1ST OPERAND\n         SR    15,15\n         IC    15,7(,EXPPR)       GET OPERATOR CODE\n         BAL   EXPLR,EXPOP(15)    DO IT\nEXPEVAL4 BAL   14,EXPSTACK        GET SPACE TO STACK RESULT\n         DC    Y(5)\n         ST    0,0(,EXPPR)        STACK RESULT\n         B     EXPOPTST\n         SPACE\nEXPOP    DS    0H\n         ORG   EXPOP+DEXPAOP      +\n         B     EXPADD\n         ORG   EXPOP+DEXPSOP      -\n         B     EXPSUB\n         ORG   EXPOP+DEXPMOP      *\n         B     EXPMUL\n         ORG   EXPOP+DEXPDOP      /\n         B     EXPDIV\n         SPACE\nEXPADD   A     0,8(,EXPPR)\n         BO    EXPAOVF            OVERFLOW\n         BR    EXPLR\n         SPACE\nEXPAOVF  SYSQS 1,0,'ARITHMETIC OVERFLOW'\n         B     EXPQTYPE\n         SPACE\nEXPSUB   S     0,8(,EXPPR)\n         BO    EXPAOVF            OVERFLOW\n         BR    EXPLR\n         SPACE\nEXPMUL   LR    1,0\n         M     0,8(,EXPPR)        MULTIPLY\n         CLI   12(EXPPR),DEXPFLN  TEST TYPE\n         BE    EXPMUL0            LINE #\n         SLDA  0,32                PUT IN R0 AND TEST OVERFLOW\n         BNOR  EXPLR               OK IF NO OVERFLOW\n         B     EXPAOVF            OVERFLOW (SIGNS DIFFER)\n         SPACE\nEXPMUL0  LTR   0,0                TEST RESULT\n         BM    EXPMUL1            CHECK FOR UNDEFLOW\n         C     0,EXPMUL3          TEST FOR OVERFLOW\n         BL    EXPMUL2            OK\n         BH    EXPAOVF            OVERFLOW\n         CL    1,EXPMUL3+4        TEST FOR OVERLFOW\n         BH    EXPAOVF            OVERFLOW\n         B     EXPMUL2\n         SPACE\nEXPMUL1  C     0,EXPMUL4          TEST FOR UNDERFLOW\n         BH    EXPMUL2            OK\n         BL    EXPAOVF             OVERFLOW\n         CL    1,EXPMUL4+4        TEST FOR UNDERFLOW\n         BL    EXPAOVF             OVERFLOW\nEXPMUL2  D     0,=F'1000'         SCALE RESULT\n         LR    0,1\n         BR    EXPLR\n         SPACE\n         DS    0F\nEXPMUL3  DC    FL8'2147483647000'\nEXPMUL4  DC    FL8'-2147483648000'\n         SPACE\n* THE DIVIDE CODE MUST CHECK FOR OVERFLOW. THE STRANGE CASE\n* THAT CAUSES MOST OF THE PROBLEM IS THAT DIVIDING THE\n* SMALLEST NEGATIVE NUMBER (-2147483648) BY -1 CAUSES A\n* DIVIDE CHECK THAT CANNOT BE MASKED.\n         SPACE\nEXPDIV   SRDA  R0,32               SET UP DIVIDEND FOR DIVIDE\n         L     EXPSR,8(,EXPPR)     GET DIVISOR\n         LPR   R14,EXPSR     GET POSITIVE(ALMOST) DIVISOR IN R14\n         BZ    EXPAOVF             ZERO DIVISOR IS OVERFLOW\n         SPACE\n* THE POSSIBLE OVERFLOW FROM THE LPR IS IGNORED AND COMPARE\n*      LOGICAL (CL) COMMANDS ARE USED BELOW INSTEAD.\n         SPACE\n         CLI   12(EXPPR),DEXPFLN   TEST TYPE OF DIVIDE\n         BE    EXPDIV0             BRANCH IF LINE # DIVIDE\n         BCT   R14,EXPDIV11        DIVIDE OK IF NOT +1 OR -1\n         SPACE\n* DIVIDE BY +1 (+1.000) OR -1 (-1.000) REQUIRES SOME EXTRA\n*    EXTRA CHECKING.  +1 MEANS NO DIVIDE IS NECESSARY.\n*    -1 MEANS THE DIVIDEND MUST BE COMPLEMENTED AND THE\n*    RESULT IS OK IF NO OVERFLOW OCCURS.\n         SPACE\nEXPDIV2  LR    R0,R1               PUT DIVIDEND BACK IN R0\n         LTR   EXPSR,EXPSR         TEST SIGN OF DIVISOR\n         BPR   EXPLR               DONE IF POSITIVE\n         LCR   R0,R0               COMPLEMENT RESULT\n         BNOR  EXPLR               DONE IF NO OVERFLOW\n         B     EXPAOVF             GO REPORT OVERFLOW\n         SPACE\nEXPDIV0  CL    R14,=F'1000'        CHECK FOR POSSIBLE OVERFLOW\n         BH    EXPDIV1             NONE POSSIBLE IF HIGH\n         BE    EXPDIV2             CHECK IF -1.000 OR 1.000\n         SPACE\n* DIVIDE BY < 1.000 MIGHT OVERFLOW -- CHECK FIRST BY TEST DIVIDE\n         DR    R0,R14        DIVIDE USING R14 TO AVOID -1.000\n         LPR   R1,R1         MAKE TEST RESULT POSITIVE(ALMOST)\n         CL    R1,=F'2147483'      RESULT MUST BE <=\n         BH    EXPAOVF             OVERFLOW WOULD OCCUR IF HIGH\n         SPACE\n* NOW WE KNOW MULTIPLY BY 1000 FOLLOWED BY DIVIDE IS OK\n         L     R1,0(,EXPPR)        LOAD DIVIDEND FOR MULTIPLY\nEXPDIV1  M     R0,=F'1000'         MULTIPLY BY 1000 BEFORE DIVIDE\nEXPDIV11 DR    R0,EXPSR            DO FINAL DIVIDE\n         LR    R0,R1               PUT RESULT IN R0\n         BR    EXPLR               RETURN\n         SPACE\nEXPCAT   BAL   EXPLR,EXPCVTST     CONVERT TO STRING\n         LA    EXPPR,8(,EXPPR)    POINT TO 2ND OPERAND\n         BAL   EXPLR,EXPCVTST     CONVERT TO STRING\n         SH    EXPPR,=H'8'\n         CLC   0(4,EXPPR),8(EXPPR)  CHECK POSITION OF STRINGS\n         BNH   EXPCAT2            STR2 FOLLOWS STR1\n         L     EXPSR,JCBWAPTR     USE BUFFER AS WORK AREA\n         L     1,8(,EXPPR)        GET OFFSET OF STR2\n         LA    1,DEXPSWA(1)       GET ADDR\n         SR    14,14\n         IC    14,0(,1)           AND LENGTH OF STR1\n         EX    14,EXPCATS1        MOVE STR2 TO TEMP\n         L     EXPLR,0(,EXPPR)    GET OFFSET OF STR1\n         LA    EXPLR,DEXPSWA(EXPLR)  ADDR OF STR1\n         IC    14,0(,EXPLR)       AND LENGTH OF STR1\n         EX    14,EXPCATS2        MOVE STR1 TO FRONT\n         LA    EXPLR,1(14,1)      POINT TO END OF STR1\n         IC    14,0(,EXPSR)       GET LENGTH OF STR2\n         LR    0,14               SAVE LENGTH OF STR2\n         BCTR  14,0\n         EX    14,EXPCATS3        CONCATENATE STRINGS\n         MVC   0(4,EXPPR),8(EXPPR)  SET OFFSET OF CONCATENATED STR\n         B     EXPCAT3\n         SPACE\nEXPCAT2  L     1,8(,EXPPR)        GET OFFSET OF STR2\n         LA    1,DEXPSWA(1)       ADDRESS OF STRING2\n         SR    0,0\n         IC    0,0(,1)            GET LENGTH OF STRING2\n         LTR   EXPSR,0            TEST LENGTH\n         BNP   EXPCAT3\n         BCTR  EXPSR,0\n         EX    EXPSR,EXPCATMV     REMOVE LENGTH BYTE OF 2ND STRING\nEXPCAT3  L     1,DEXPSAP\n         BCTR  1,0\n         ST    1,DEXPSAP          UPDATE STRING AREA POINTER\n         L     1,0(,EXPPR)        GET OFFSET OF CONCATENATED STRING\n         SR    EXPSR,EXPSR\n         IC    EXPSR,DEXPSWA(1)\n         AR    EXPSR,0            CALCULATE LENGTH\n         CH    EXPSR,=H'255'      TEST AGAINST MAX\n         BNH   EXPCAT4            OK\n         SYSQS 1,0,'CONCATENATED STRING EXCEEDS 255 CHARS'\n         B     EXPQTYPE\n         SPACE\nEXPCAT4  STC   EXPSR,DEXPSWA(1)   UPDATE LENGTH\n         BAL   14,EXPSTACK\n         DC    Y(5)\n         ST    1,0(,EXPPR)        STACK STRING OFFSET\n         MVI   4(EXPPR),DEXPFST   SET TYPE\n         B     EXPOPTST\n         SPACE\nEXPCATMV MVC   0(0,1),1(1)\nEXPCATS1 MVC   0(0,EXPSR),0(1)\nEXPCATS2 MVC   0(0,1),0(EXPLR)\nEXPCATS3 MVC   0(0,EXPLR),1(EXPSR)\n         SPACE\n* STACK ROUTINES\n         SPACE\nEXPSTACK L     EXPPR,DEXPSP       GET STACK POINTER\n         AH    EXPPR,0(,14)       ADD IN REQUEST\n         LA    EXPSR,L'DEXPSTK\n         CR    EXPPR,EXPSR        TEST FOR OVERFLOW\n         BNH   EXPSTKOK           STILL ROOM\n         SYSQS 1,0,'EXPRESSION TOO COMPLEX'\n         B     EXPQTYPE\n         SPACE\nEXPSTKOK ST    EXPPR,DEXPSP       UPDATE STACK POINTER\n         SH    EXPPR,0(,14)       RETURN POINTER\n         LA    EXPPR,DEXPSTK(EXPPR)\n         B     2(,14)\n         SPACE\nEXPUNSTK L     EXPPR,DEXPSP\n         SH    EXPPR,0(,14)       SUBTRACT REQUEST\n         ST    EXPPR,DEXPSP       UPDATE STACK POINTER\n         LA    EXPPR,DEXPSTK(EXPPR)\n         B     2(,14)\n         SPACE\n* RECURSION ROUTINES\n         SPACE\nEXPPUSH  BAL   14,EXPSTACK\n         DC    Y(4)\n         LA    EXPLR,0(,EXPLR)    BE PARANOID, DROP HIGH ORDER BYTE\n         ST    EXPLR,0(,EXPPR)    STACK RETURN ADDRESS\n         SCINIT (1),(0)           INITIALIZE NEW SCAN\n         B     EXPSCAN\n         SPACE\nEXPPOP   BAL   14,EXPUNSTK        UNSTACK VALUE OF EXPR AND RETRN ADDR\n         DC    Y(9)\n         SCTELL ,                 RETURN SCAN INFO\n         L     EXPLR,0(,EXPPR)    RESTORE RETURN ADDRESS\n         BR    EXPLR\n         SPACE\n* STRING AREA ROUTINES\n         SPACE\nEXPSTRMV ST    EXPPR,DEXPPRSV     SAVE POINTER\n         L     EXPPR,DEXPSAP      GET STRING AREA POINTER\n         AR    EXPPR,0\n         LA    EXPPR,1(,EXPPR)    CALC AREA NEED FOR STRING\n         LA    EXPSR,L'DEXPSWA\n         CR    EXPPR,EXPSR        TEST FOR OVERFLOW\n         BNH   EXPSTRM1           STILL ROOM\n         SYSQS 1,0,'STRING AREA OVERFLOW'\n         B     EXPQTYPE\n         SPACE\nEXPSTRM1 L     EXPSR,DEXPSAP\n         ST    EXPPR,DEXPSAP      UPDATE POINTER\n         LA    EXPPR,DEXPSWA(EXPSR)\n         LTR   EXPSR,0            TEST LENGTH\n         BNP   *+10               NULL STRING\n         BCTR  EXPSR,0\n         EX    EXPSR,EXPSMV       MOVE STRING TO STRING AREA\n         STC   0,0(,EXPPR)        ADD LENGTH\n         LR    1,EXPPR\n         LA    EXPSR,DEXPSWA\n         SR    1,EXPSR            CALC OFFSET\n         L     EXPPR,DEXPPRSV     RESTORE POINTER\n         BR    EXPLR\n         SPACE\nEXPSMV   MVC   1(0,EXPPR),0(1)\n         SPACE\nEXPSTRDL LTR   1,1                TEST IF POINTER IS INSIDE ATRING AREA\n         BCR   4,EXPLR            LOW- NOT IN STRING AREA\n         C     1,DEXPSAP\n         BCR   11,EXPLR           HIGH- NOT IN WORK AREA\n         ST    EXPPR,DEXPPRSV     SAVE POINTER\n         SR    EXPSR,EXPSR\n         IC    EXPSR,DEXPSWA(1)   GET LENGTH OF STRING TO BE DELETED\n         LA    EXPSR,1(EXPSR,1)\n         C     EXPSR,DEXPSAP      IS STRING AT END OF SWA\n         BCR   7,EXPLR            NOT AT END DON'T DELETE\n         L     EXPPR,DEXPSAP\n         SR    EXPSR,EXPSR\n         IC    EXPSR,DEXPSWA(1)\n         SR    EXPPR,EXPSR        DECR STRING POINTER BY LEN OF STRING\n         BCTR  EXPPR,0            DON'T FORGET LENGTH BYTE\n         ST    EXPPR,DEXPSAP      UPDATE POINTER\n         L     EXPPR,DEXPPRSV     RESTORE POINTER\n         BR    EXPLR\n         SPACE\n* CONVERSION ROUTINES\n         SPACE\nEXPCVTST CLI   4(EXPPR),DEXPFST   TEST TYPE\n         BCR   8,EXPLR            ALREADY A STRING\n         SR    15,15\n         IC    15,4(,EXPPR)       GET TYPE CODE\n         L     0,0(,EXPPR)        GET VALUE\n         XCALL CONVERT1           CONVERT TO STRING\n         ST    EXPLR,0(,EXPPR)    SAVE RET. ADDR\n         BAL   EXPLR,EXPSTRMV     MOVE STRING TO STRING AREA\n         L     EXPLR,0(,EXPPR)    RESTORE RET. ADDR\n         ST    1,0(,EXPPR)        STACK OFFSET\n         MVI   4(EXPPR),DEXPFST   SET TYPE\n         BR    EXPLR\n         SPACE\nEXPCVTLN CLI   4(EXPPR),DEXPFLN   TEST TYPE\n         BCR   8,EXPLR            ALREADY A LINE #\n         L     0,0(,EXPPR)\n         CLI   4(EXPPR),DEXPFIN   TEST FOR INTEGER\n         BE    EXPCVTL1           INTEGER\n         LR    1,0                OFFSET TO R1\n         SR    0,0\n         IC    0,DEXPSWA(1)       GET LENGTH AND\n         LA    1,DEXPSWA+1(1)     ADDR OF STRING\n         XCALL CONVERT2           CONVERT TO ARITH.\n         L     1,0(,EXPPR)        GET STRING OFFSET\n         ST    EXPLR,0(,EXPPR)    SAVE RETURN ADDR\n         BAL   EXPLR,EXPSTRDL     DELETE STRING\n         L     EXPLR,0(,EXPPR)    RESTORE RET ADDR\n         ST    0,0(,EXPPR)        SAVE VALUE\n         STC   15,4(EXPPR)        AND TYPE\n         CLI   4(EXPPR),DEXPFLN   TEST FOR LINE #\n         BCR   8,EXPLR            RETURN\nEXPCVTL1 LPR   1,0                TEST FOR OVERFLOW\n         BO    EXPAOVF            OVERFLOW\n         C     1,=F'2147483'\n         BH    EXPAOVF            OVERFLOW\n         LR    1,0                RESTORE SIGN\n         M     0,=F'1000'         CONVERT TO LINE #\n         ST    1,0(,EXPPR)        SAVE VALUE\n         MVI   4(EXPPR),DEXPFLN   SET TYPE\n         BR    EXPLR\n         SPACE\nEXPCVTIN CLI   4(EXPPR),DEXPFIN   TEST TYPE\n         BCR   8,EXPLR            ALREADY AN INTEGER\n         L     0,0(,EXPPR)\n         CLI   4(EXPPR),DEXPFLN   TEST FOR LINE #\n         BE    EXPCVTI1           LINE #\n         LR    1,0\n         SR    0,0\n         IC    0,DEXPSWA(1)       GET LENGTH AND\n         LA    1,DEXPSWA+1(1)     ADDR OF STRING\n         XCALL CONVERT2           CONVERT\n         L     1,0(,EXPPR)        GET OFFSET\n         ST    EXPLR,0(,EXPPR)    SAVE RET ADDR\n         BAL   EXPLR,EXPSTRDL     DELETE STRING\n         L     EXPLR,0(,EXPPR)    RESTORE RET ADDR\n         ST    0,0(,EXPPR)\n         STC   15,4(,EXPPR)       SAVE TYPE\n         CLI   4(EXPPR),DEXPFIN   TEST TYPE\n         BCR   8,EXPLR            INTEGER\nEXPCVTI1 SRDA  0,32(0)\n         D     0,=F'1000'         CONVERT TO INTEGER\n         ST    1,0(,EXPPR)        SAVE VALUE\n         MVI   4(EXPPR),DEXPFIN   SET TYPE\n         BR    EXPLR\n         SPACE\nEXPCVTAR CLI   4(EXPPR),DEXPFST   TEST TYPE\n         BCR   7,EXPLR            NOT STRING\n         L     1,0(,EXPPR)        GET OFFSET\n         SR    0,0\n         IC    0,DEXPSWA(1)       GET LENGTH AND\n         LA    1,DEXPSWA+1(1)     ADDRESS OF STRING\n         XCALL CONVERT2           CONVERT TO ARITHMETIC\n         L     1,0(,EXPPR)        GET OFFSET\n         ST    EXPLR,0(,EXPPR)    SAVE RETURN ADDRESS\n         BAL   EXPLR,EXPSTRDL     DELETE STRING\n         L     EXPLR,0(,EXPPR)    RESTORE RETURN ADDR\n         ST    0,0(,EXPPR)        SAVE VALUE\n         STC   15,4(,EXPPR)       AND TYPE\n         BR    EXPLR\n         SPACE\nEXPHEX   L     EXPSR,JCBWAPTR     USE BUFFER FOR TRT TABLE\n         MVI   0(EXPSR),1\n         MVC   1(255,EXPSR),0(EXPSR)  INITIALIZE TRT TABLE\n         LA    0,16(,0)           NUMBER OF HEX DIGITS\n         SR    14,14              CLEAR R14 AND R15\n         LR    15,14\n         LA    1,EXPDSP3          POINT TO VALID HEX DIGITS\nEXPHEX1  IC    14,0(,1)           GET VALID DIGIT\n         STC   15,0(14,EXPSR)     ZERO OUT TRT TABLE\n         LA    1,1(,1)            BUMP POINTER\n         BCT   0,EXPHEX1          GET UM ALL\n         L     1,0(,EXPPR)        OFFSET OF STRING\n         IC    0,DEXPSWA(1)       LENGTH AND\n         LA    1,DEXPSWA+1(1)     ADDR OF STRING\n         LTR   0,0                TEST LENGTH\n         BCR   8,EXPLR            NULL- EXIT\n         LR    14,0\n         BCTR  14,0\n         EX    14,EXPHEX3         TEST FOR VALID HEX CONSTANT\n         BCR   8,EXPLR            OK\n         BAL   14,EXPUNSTK        UNSTACK FUNCTION ID\n         DC    Y(8)\n         LH    15,6(,EXPPR)       GET ID\n         B     EXPERR5            ISSUE MESSAGE\n         SPACE\nEXPHEX3  TRT   0(0,1),0(EXPSR)\n         SPACE\n* ARGUMENT ROUTINES\n         SPACE\nEXPRFAS  BAL   14,EXPSTACK\n         DC    Y(4)\n         LA    EXPLR,0(,EXPLR)    ZERO ARG COUNTER\n         ST    EXPLR,0(,EXPPR)    STACK COUNTER/RET ADDR\nEXPRFA1  SR    EXPSR,EXPSR\n         IC    EXPSR,0(,EXPPR)\n         LA    EXPSR,1(,EXPSR)\n         STC   EXPSR,0(,EXPPR)    INCR ARG COUNTER\n         L     EXPLR,0(,EXPPR)    GET ARG LIST POINTER\n         CH    EXPSR,0(,EXPLR)    CHECK # OF ARGS\n         BH    EXPRFA2            TOO MANY...\n         BAL   EXPLR,EXPPUSH      EVAL AN ARGUMENT\n         SH    EXPPR,=H'4'        POINT TO COUNTER/RET ADDR\n         IC    EXPSR,0(,EXPPR)\n         SLL   EXPSR,1(0)         CONVERT ARG# TO HALFWORD INDEX\n         L     EXPLR,0(,EXPPR)    GET ARG LIST POINTER\n         LH    EXPLR,0(EXPSR,EXPLR)  GET TYPE OF THIS ARG\n         L     EXPLR,EXPCVTBL(EXPLR)  GET ADDR OF CONVERSION ROUTINE\n         LA    EXPPR,8(,EXPPR)    POINT TO ARG\n         BALR  EXPLR,EXPLR        CONVERT TO PROPER TYPE\n         MVC   DEXPWK,0(EXPPR)    SAVE VALUE\n         SH    EXPPR,=H'8'        POINT TO COUNTER/RET ADDR\n         SR    EXPSR,EXPSR        RESTORE ARG COUNTER\n         IC    EXPSR,0(,EXPPR)\n         SLL   EXPSR,2(0)         CONVERT TO FULLWORD INDEX\n         SR    EXPPR,EXPSR        CALC ARG STACK ADDR\n         MVC   0(4,EXPPR),DEXPWK  STACK VALUE OF ARG\n         AR    EXPPR,EXPSR\n         SCTELL ,\n         LTR   0,0\n         BP    EXPRFA1            MORE ARGS TO EVAL\n         BAL   14,EXPUNSTK        UNSTACK RET ADD\n         DC    Y(4)\n         L     EXPLR,0(,EXPPR)\n         LH    EXPSR,0(,EXPLR)    GET ARG COUNT\n         LA    EXPSR,1(,EXPSR)    BUMP FOR ARG COUNT\n         SLL   EXPSR,1(0)         CALC LENGTH OF ARG LIST\n         B     0(EXPSR,EXPLR)     RETURN, SKIPPING ARG LIST\n         SPACE\nEXPRFA2  LH    EXPSR,0(,EXPLR)    GET # OF ARGS\n         LA    EXPSR,2(,EXPSR)    BUMP BY 2 FOR SCAN INFO\n         SLL   EXPSR,2(0)         CALC SPACE OF ARGS AND SCAN INFO\n         SR    EXPPR,EXPSR        DECR STACK POINTER\n         LH    15,6(,EXPPR)       GET FUNCTION ID\n         B     EXPERR2\n         SPACE\nEXPSFAS  BAL   14,EXPSTACK        GET SPACE FOR RET. ADDR AND ARG\n         DC    Y(8)\n         ST    EXPLR,4(,EXPPR)    STACK RETURN ADDR\n         BAL   EXPLR,EXPPUSH      EVAL ARG\n         BAL   14,EXPUNSTK        UNSTACK RET. ADDR AND ARG\n         DC    Y(8)\n         SCTELL ,\n         LTR   0,0                TEST FOR MORE THAN 1 ARG\n         BP    EXPSFA1            ERROR\n         L     EXPLR,4(,EXPPR)    RESTORE RETURN ADDRESS\n         SR    15,15\n         IC    15,16(,EXPPR)      GET TYPE\n         LTR   15,15              CHECK FOR 0\n         BNZ   *+8                NON ZERO\n         LA    15,1               BUMP FOR TYPE TEST\n         EX    15,EXPSFA3         CHECK PERMISSIBLE TYPES\n         BNO   EXPSFA2            ERROR\n         MVC   0(4,EXPPR),12(EXPPR) MOVE VAL TO TOP OF STACK\n         MVC   4(1,EXPPR),16(EXPPR) AND TYPE\n         B     2(,EXPLR)\n         SPACE\nEXPSFA1  LA    EXPLR,EXPERR2      TOO MANY ARGS\n         B     *+8\n         SPACE\nEXPSFA2  LA    EXPLR,EXPERR4      INVALID TYPE\n         BAL   14,EXPUNSTK        UNSTACK FUNCTION ID\n         DC    Y(8)\n         LH    15,6(,EXPPR)       GET ID\n         BR    EXPLR\n         SPACE\nEXPSFA3  TM    1(EXPLR),0\n         SPACE\nEXPFNGO  CLI   0(1),C'('          CHECK SYNTAX\n         BNE   CVNVALID\n         BAL   14,EXPSTACK\n         DC    Y(8)\n         SCANSAVE 0(EXPPR)        STACK SCAN INFO\n         STH   15,6(,EXPPR)       AND FUNCTION ID\n         LA    1,1(,1)\n         SH    0,=H'2'            DELETE PARENS\n         BCR   2,EXPLR\n         B     EXPERR1\n         SPACE\nEXPFNEND BAL   14,EXPUNSTK        UNSTACK SCAN INFO\n         DC    Y(8)\n         SCANRSTR 0(EXPPR)\n         BR    EXPLR\n         SPACE\n         DS    0F\nEXPCVTBL DC    A(EXPCVTST)        STRING CONVERSION ROUTINE\n         DC    A(EXPCVTIN)        INTEGER CONVERSION ROUTINE\n         DC    A(EXPCVTLN)        LINE # CONVERSION ROUTINE\n         SPACE\n* MISC. THINGS\n         SPACE\nEXP0EXIT LA    EXPSR,4\n         CL    EXPSR,DEXPSP       CHECK STACK\n         BL    EXPNOOP            THERE'S SOMETHING THERE\n         NI    CPLFLG4,255-CPFNOINC-CPFNOCUR\n         SR    15,15              SET CC=0 AS NULL EXPR FLAG\n         XEXIT 2,8\n         SPACE\n* ERROR MESSAGES\n         SPACE\nEXPNOOP  SYSQS 1,0,'MISSING OPERAND'\n         B     EXPQTYPE\n         SPACE\nEXPERR1  BAL   EXPLR,EXPFNAME(15) GET FUNCTION NAME\n         TSEG  (1),(0),B           PUT OUT FUNCTION NAME\n         SYSQS 1,0,'FUNCTION HAS NO ARGUMENTS'\n         B     EXPQTYPE\n         SPACE\nEXPERR2  BAL   EXPLR,EXPFNAME(15) GET FUNCTION NAME\n         TSEG  (1),(0),B           PUT OUT FUNCTION NAME\n         SYSQS 1,0,'FUNCTION HAS TOO MANY ARGUMENTS'\n         B     EXPQTYPE\n         SPACE\nEXPERR3  BAL   EXPLR,EXPFNAME(15) GET FUNCTION NAME\n         TSEG  (1),(0),B           PUT OUT FUNCTION NAME\n         SYSQS 1,0,'FUNCTION MISSING ARGUMENT'\n         B     EXPQTYPE\n         SPACE\nEXPERR4  BAL   EXPLR,EXPFNAME(15)\n         TSEG  (1),(0),B\n         SYSQS 1,0,'FUNCTION PASSED INVALID ARGUMENT'\n         B     EXPQTYPE\n         SPACE\nEXPERR5  BAL   EXPLR,EXPFNAME(15)\n         TSEG  (1),(0),B\n         SYSQS 1,0,'PASSED INVALID HEX CONSTANT'\n         B     EXPQTYPE\n         SPACE\nEXPABRT  SYSQS 1,0,'NO VARIABLE COMMAND PAGE, COMMAND ABORTED'\nEXPQTYPE TSEG  (1),(0)             ADD MESSAGE TO BUFFER\n         B     CVQTYPE\n         SPACE\nEXPFNAME DS    0H\n         SPACE\nDEXPSIZE EQU   *-EXPFNAME\n         SYSQS 1,0,'SIZE'\n         BR    EXPLR\n         SPACE\nDEXPINDX EQU   *-EXPFNAME\n         SYSQS 1,0,'INDEX'\n         BR    EXPLR\n         SPACE\nDEXPTDU  EQU   *-EXPFNAME\n         SYSQS 1,0,'TDUMP'\n         BR    EXPLR\n         SPACE\nDEXPSBST EQU   *-EXPFNAME\n         SYSQS 1,0,'SUBSTR'\n         BR    EXPLR\n         SPACE\nDEXPSCON EQU   *-EXPFNAME\n         SYSQS 1,0,'SCONVERT'\n         BR    EXPLR\n         SPACE\nDEXPWCON EQU   *-EXPFNAME\n         SYSQS 1,0,'WCONVERT'\n         BR    EXPLR\n         SPACE\nDEXPNCON EQU   *-EXPFNAME\n         SYSQS 1,0,'NCONVERT'\n         BR    EXPLR\n         SPACE\nDEXPVRF  EQU   *-EXPFNAME\n         SYSQS 1,0,'VERIFY'\n         BR    EXPLR\n         SPACE\nDEXPDSP  EQU   *-EXPFNAME\n         SYSQS 1,0,'DISPLAY'\n         BR    EXPLR\n         SPACE\nDEXPWHX  EQU   *-EXPFNAME\n         SYSQS 1,0,'WHEX'\n         BR    EXPLR\n         SPACE\nDEXPSHX  EQU   *-EXPFNAME\n         SYSQS 1,0,'SHEX'\n         BR    EXPLR\n         SPACE\nDEXPNHX  EQU   *-EXPFNAME\n         SYSQS 1,0,'NHEX'\n         BR    EXPLR\n         SPACE\nDEXPRNDX EQU   *-EXPFNAME          RINDEX\n         SYSQS 1,0,'RINDEX'\n         BR    EXPLR\n         SPACE\nDEXPRSUB EQU   *-EXPFNAME          RSUBSTR\n         SYSQS 1,0,'RSUBSTR'\n         BR    EXPLR\n         SPACE\nDEXPREV  EQU   *-EXPFNAME          REVERSE\n         SYSQS 1,0,'REVERSE'\n         BR    EXPLR\n         SPACE\nDEXPRVER EQU   *-EXPFNAME          RVERIFY\n         SYSQS 1,0,'RVERIFY'\n         BR    EXPLR\n         SPACE\nDEXPLPAD EQU   *-EXPFNAME\n         SYSQS 1,0,'LPAD'\n         BR    EXPLR\n         SPACE\nDEXPRPAD EQU   *-EXPFNAME\n         SYSQS 1,0,'RPAD'\n         BR    EXPLR\n         SPACE\nDEXPLTRM EQU   *-EXPFNAME\n         SYSQS 1,0,'LTRIM'\n         BR    EXPLR\n         SPACE\nDEXPRTRM EQU   *-EXPFNAME\n         SYSQS 1,0,'RTRIM'\n         BR    EXPLR\n         SPACE\nDEXPDUPL EQU   *-EXPFNAME\n         SYSQS 1,0,'DUPL'\n         BR    EXPLR\n         SPACE\nDEXPXOR  EQU   *-EXPFNAME\n         SYSQS 1,0,'XOR'\n         BR    EXPLR\n         SPACE\nDEXPOR   EQU   *-EXPFNAME\n         SYSQS 1,0,'OR'\n         BR    EXPLR\n         SPACE\nDEXPAND  EQU   *-EXPFNAME\n         SYSQS 1,0,'AND'\n         BR    EXPLR\n         SPACE\nDEXPNEG  EQU   *-EXPFNAME\n         SYSQS 1,0,'NEGATE'\n         BR    EXPLR\n         SPACE\nDEXPCORE EQU   *-EXPFNAME\n         SYSQS 1,0,'CORE'\n         BR    EXPLR\n         SPACE\nDEXPXLAT EQU   *-EXPFNAME\n         SYSQS 1,0,'XLATE'\n         BR    EXPLR\n         SPACE\nDEXPXPND EQU   *-EXPFNAME\n         SYSQS 1,0,'EXPAND'\n         BR    EXPLR\n         SPACE\n* PRTS\n         SPACE\nEXPROPS  SCKW  +,EXPPLUS\n         SCKW  -,EXPMINUS\n         SCKW  *,EXPSTAR\n         SCKW  /,EXPSLASH\n         SCKW  |,EXPBAR,P\n         SCKW  ,EXPRSCN\n         SPACE\nEXPPLUS  LA    2,DEXPAOP          GET INTERNAL OPERATOR CODE\n         B     EXPOPFND\n         SPACE\nEXPMINUS LA    2,DEXPSOP\n         B     EXPOPFND\n         SPACE\nEXPSTAR  LA    2,DEXPMOP\n         B     EXPOPFND\n         SPACE\nEXPSLASH LA    2,DEXPDOP\n         B     EXPOPFND\n         SPACE\nEXPBAR   BCT   0,EXPRSCN\n         CLI   0(1),C'|'          TEST FOR CONCATENATION\n         BNE   EXPRSCN            LET SOMEONE ELSE FIGURE IT OUT\n         LA    2,DEXPCOP          GET CONCATENATION CODE\n         B     EXPOPFND\n         SPACE\nEXPRSCN  SCANRSTR DEXPWK          BACKSPACE SCAN TO UNRECOGNIZED TOKEN\n         B     EXPOPCLR\n         EJECT\n         LTORG\n         SPACE 3\n         DS    0D\nREVTAB   DC    AL1(255,254,253,252,251,250)\n         DC    AL1(249,248,247,246,245,244,243,242,241,240)\n         DC    AL1(239,238,237,236,235,234,233,232,231,230)\n         DC    AL1(229,228,227,226,225,224,223,222,221,220)\n         DC    AL1(219,218,217,216,215,214,213,212,211,210)\n         DC    AL1(209,208,207,206,205,204,203,202,201,200)\n         DC    AL1(199,198,197,196,195,194,193,192,191,190)\n         DC    AL1(189,188,187,186,185,184,183,182,181,180)\n         DC    AL1(179,178,177,176,175,174,173,172,171,170)\n         DC    AL1(169,168,167,166,165,164,163,162,161,160)\n         DC    AL1(159,158,157,156,155,154,153,152,151,150)\n         DC    AL1(149,148,147,146,145,144,143,142,141,140)\n         DC    AL1(139,138,137,136,135,134,133,132,131,130)\n         DC    AL1(129,128,127,126,125,124,123,122,121,120)\n         DC    AL1(119,118,117,116,115,114,113,112,111,110)\n         DC    AL1(109,108,107,106,105,104,103,102,101,100)\n         DC    AL1(99,98,97,96,95,94,93,92,91,90)\n         DC    AL1(89,88,87,86,85,84,83,82,81,80)\n         DC    AL1(79,78,77,76,75,74,73,72,71,70)\n         DC    AL1(69,68,67,66,65,64,63,62,61,60)\n         DC    AL1(59,58,57,56,55,54,53,52,51,50)\n         DC    AL1(49,48,47,46,45,44,43,42,41,40)\n         DC    AL1(39,38,37,36,35,34,33,32,31,30)\n         DC    AL1(29,28,27,26,25,24,23,22,21,20)\n         DC    AL1(19,18,17,16,15,14,13,12,11,10)\n         DC    AL1(9,8,7,6,5,4,3,2,1,0)\n         EJECT\nEXPRVARS SCKW  ,EXPICON,I\n         SCKW  ,LNENOPRT,PUSH\n         SCKW  DATE,EXPDATE,A\n         SCKW  VOLUME,EXPVOL,A\n         SCKW  PREFIX,EXPREFIX,A\n         SCKW  USER,EXPUSER,A\n         SCKW  MEMBER,EXPMEMB,A\n         AIF   ('&USPS' EQ '1').LBL04                           USPS01\n         SCKW  GROUP,EXPGROUP,A\n.LBL04   DS   0C                                                USPS01\n         SCKW  LENGTH,EXPLNGTH,A\n         SCKW  PAGES,EXPPGCNT,A\n         SCKW  LINES,EXPLNCNT,A\n         SCKW  RANDOM,EXPRANDM,A\n         SCKW  CP,EXPCPADD\n         SCKW  PARM,EXPPARM\n         SCKW  TERMINAL,EXPTERM,A\n         SCKW  PROJECT,EXPPROJ,A\n         SCKW  DELTA,EXPDELTA,A\n         SCKW  BREAK,EXPBREAK,A\n         SCKW  ESCAPE,EXPESCP,A\n         SCKW  SKIP,EXPSKIP,A\n         SCKW  SIZE,EXPSIZE,(P,A)\n         SCKW  INDEX,EXPINDEX,(P,A)\n         SCKW  LINDEX,EXPINDEX,(P,A)\n         SCKW  TDUMP,EXPTDUMP,(P,A)\n         SCKW  CORE,EXPCORE,(P,A)\n         SCKW  XLATE,EXPXLATE,(P,A)\n         SCKW  EXPAND,EXPXPND,(P,A)\n         SCKW  SUBSTR,EXPSBSTR,(P,A)\n         SCKW  LSUBSTR,EXPSBSTR,(P,A)\n         SCKW  SCONVERT,EXPSCONV,(P,A)\n         SCKW  WCONVERT,EXPWCONV,(P,A)\n         SCKW  NCONVERT,EXPNCONV,(P,A)\n         SCKW  VERIFY,EXPVRFY,(P,A)\n         SCKW  LVERIFY,EXPVRFY,(P,A)\n         SCKW  SHEX,EXPSHEX,(P,A)\n         SCKW  NHEX,EXPNHEX,(P,A)\n         SCKW  WHEX,EXPWHEX,(P,A)\n         SCKW  S,EXPSHEX,(P,A)\n         SCKW  N,EXPNHEX,(P,A)\n         SCKW  W,EXPWHEX,(P,A)\n         SCKW  DISPLAY,EXPDSPY,(P,A)\n         SCKW  RINDEX,EXPRINDX,(P,A)\n         SCKW  RSUBSTR,EXPRSBTR,(P,A)\n         SCKW  REVERSE,EXPREVRS,(A,P)\n         SCKW  PAD,EXPRPAD,P\n         SCKW  RPAD,EXPRPAD,(P,A)\n         SCKW  LPAD,EXPLPAD,(P,A)\n         SCKW  TRIM,EXPRTRIM,(P,A)\n         SCKW  RTRIM,EXPRTRIM,(P,A)\n         SCKW  LTRIM,EXPLTRIM,(P,A)\n         SCKW  DUPL,EXPDUPL,(P,A)\n         SCKW  XOR,EXPXOR,P\n         SCKW  OR,EXPOR,P\n         SCKW  AND,EXPAND,P\n         SCKW  NEGATE,EXPNEG,(P,A)\n         SCKW  +,EXPREPLS\n         SCKW  -,EXPREMIN\n         SCKW  ,EXPLOOK\n         SPACE 3\n         DROP  VCPR,EXPB2\n         EJECT\n*  FMTTIME--SUBROUTINE TO FORMAT THE TIME AND DATE.\n*    INPUT:  TIME IN R0, DATE IN R1 (AS RETURNED BY TIME BIN)\n*    OUTPUT: R1 POINTS TO THE FORMATTED OUTPUT AREA, FMTTI,\n*            AND R0 CONTAINS THE LENGTH OF THAT AREA.  OUTPUT\n*            STRING IS OF THE FORMAT:\n*\n*                HH:MM:SS MM/DD/YY (YY.DDD)\n         SPACE\nFMTTIME  XENTER 2,8,*              SAVE REGS\n         AIF   ('&USPS' NE '1').LBL05                           USPS01\n         LA   R3,CPWK1             PICK UP WORK AREA ADDR       JEP016\n         MVC  0(FMTSIZE,R3),FMTTI   MOVE IN PATTERNS            JEP016\n         LR   R2,R1                 SAVE R1 FOR A MIN           JEP016\n         USING CPWK1,R3             USE WORK AREA               JEP016\n         LR   R1,R3                 POINT R1 TO W/A             JEP016\n         DROP R3                                                JEP016\n         XCALL TIME                CALL TIME ROUTINE            JEP016\n         LA    R3,CPWK1            REINITIALIZE R3              JEP016\n         LR   R0,R2                                             JEP016\n         USING CPWK1,R3                                         JEP016\n         LA   R1,9(R3)             POINT R1 TO TIME AREA        JEP016\n         DROP R3                                                JEP016\n         XCALL DATE               GET FIRST DATE                JEP016\n         LA    R3,CPWK1            REINITIALIZE R3              JEP016\n         USING CPWK1,R3                                         JEP016\n         MVC  18(7,R3),FMTDA2MS                                 JEP016\n         ST   R2,CPDOUB                                         JEP016\n         ED   18(7,R3),CPDOUB+1                                 JEP016\n         MVI  18(3),C'('                                        JEP016\n         LR   R1,R3                TELL EM LOCATION             JEP016\n         LA   R0,26                TELL EM HOW LONG             JEP016\n         AGO  .LBL06                                            JEP016\n.LBL05   DS   0C                                                USPS01\n         LA    R3,CPWK1\n         MVC   0(FMTSIZE,R3),FMTTI\n         LR    R2,1                SAVE DATE\n         USING FMTTI,R3\n         LA    1,FMTTI             POINT TO OUTPUT AREA\n         DROP  R3\n         XCALL TIME                FORMAT TIME\n         LR    0,R2                RECOVER DATE\n         USING FMTTI,R3\n         LA    1,FMTDA1            OUTPUT AREA FOR 1ST DATE\n         DROP  R3\n         XCALL DATE\n         USING FMTTI,R3\n         MVC   FMTDA2,FMTDA2MS     COPY EDIT MASK\n         ST    R2,CPDOUB\n         ED    FMTDA2,CPDOUB+1     EDIT JULIAN DATE\n         MVI   FMTDA2,C'('         REPLACE FILL CHAR\n         LA    1,FMTTI             POINT TO OUTPUT AREA\n         LA    0,FMTDA2E-FMTTI     LENGTH OF ENTIRE AREA\n.LBL06   DS   0C                                                USPS01\n         XEXIT 2,8                 RETURN\n         DROP  R3\n         SPACE\nFMTTI    DC    C'HH:MM:SS'         TIME IN FORMAT HH:MM:SS\nFMTTIE   EQU   *\n         DC    C' '\nFMTDA1   DC    C'MM/DD/YY'         1ST DATE IN FORMAT MM/DD/YY\nFMTDA1E  EQU   *\n         DC    C' '\nFMTDA2   DC    C'(YY.DDD',C')'     2ND DATE (JULIAN)\nFMTDA2E  EQU   *\n         SPACE\nFMTDA2MS DC    C' ',X'2120',C'.',X'202020'  DA2 EDIT MASK\nFMTSIZE  EQU   *-FMTTI\n         TITLE 'GOIF - IF COMMAND ROUTINE'\nGOIF     GENTER DIFLNG\n         USING DIF,8\n         MVI   DIFSTR1,C' '        BLANK OUT\n         MVC   DIFSTR1+1(255),DIFSTR1   STRING1 AREA\n         SCAN  ,\n         BZ    CVGETCOM\n         CLI   0(1),C'('          CHECK SYNTAX\n         BNE   CVNVALID           NO GOOD\n         SCANSAVE DIFSCNSV\n         LA    1,1(,1)\n         SH    0,=H'2'            DELETE PARENS\n         XCALL EXPR               EVAL 1ST EXPRESSION\n         BZ    CVABSENT            OPERAND MISSING IF NO EXPR\n         ST    R0,DIFVL1          SAVE EXPR1 VALUE OR LENGTH\n         STH   15,DIFTP1          AND TYPE\n         LTR   R15,R15             IS THIS A STRING\n         BNZ   GOIFREL             BR NO\n         AR    R1,VCPR             POINT TO ABS ADDR\n         LTR   R2,R0               LOAD R2 AND TEST IF NULL\n         BNP   GOIFREL             BR IF NULL STRING\n         BCTR  R2,0                SET COUNT FOR EX\n         EX    R2,GOIFMVC1         MOVE FIRST STRING\nGOIFREL  SCAN  GOIFPRT            SCAN RELATIONAL OPERATOR\n         B     CVABSENT            OPERAND MISSING IF NO RELATION\n         SPACE\nGOIFEQ   IC    2,=X'80'           BRANCH MASK\n         B     GOIFEXP2\n         SPACE\nGOIFNE   IC    2,=X'70'\n         B     GOIFEXP2\n         SPACE\nGOIFLT   IC    2,=X'40'\n         B     GOIFEXP2\n         SPACE\nGOIFLE   IC    2,=X'D0'\n         B     GOIFEXP2\n         SPACE\nGOIFGT   IC    2,=X'20'\n         B     GOIFEXP2\n         SPACE\nGOIFGE   IC    2,=X'B0'\nGOIFEXP2 SCTELL ,\n         XCALL EXPR               EVAL 2ND EXPRESSION\n         BZ    CVABSENT            OPERAND MISSING IF NO EXPR\n         ST    0,DIFVL2           SAVE VALUE OF EXPR2\n         STH   15,DIFTP2          SAVE TYPE OF EXP2\n         AH    15,DIFTP1\n         BZ    GOIFSTR            BOTH EXPS ARE STRINGS\n         SH    15,DIFTP1          TEST TYPE OF EXP2\n         BNZ   GOIFTP1T           NOT A STRING\n         AR    1,VCPR\n         XCALL CONVERT2           CONVERT EXP2 TO ARITHMETIC\n         ST    0,DIFVL2           SAVE VALUE\n         STH   15,DIFTP2          SAVE TYPE\n         B     GOIFATST\n         SPACE\nGOIFTP1T CLI   DIFTP1+1,DEXPFST   TEST TYPE OF EXP1\n         BNE   GOIFATST           NOT A STRING\n         LA    1,DIFSTR1          ADDRESS AND\n         L     0,DIFVL1           LENGTH OF STRING\n         XCALL CONVERT2           CONVERT\n         ST    0,DIFVL1           SAVE VALUE AND\n         STH   15,DIFTP1          TYPE\n         LH    15,DIFTP2\nGOIFATST AH    15,DIFTP1\n         SH    15,=H'8'\n         B     *+4(15)            USE TYPE CODES AS BRANCH\n         SPACE\n         B     GOIFACMP           BOTH ARE INTGERS\n         B     *+8                MIXED\n         B     GOIFACMP           BOTH ARE LINE NUMBER\n         L     0,DIFVL1           GET VALUE OF EXP1\n         CLI   DIFTP1+1,DEXPFIN   TEST EXP1 TYPE\n         BE    *+8                INTEGER\n         L     0,DIFVL2           EXP2 IS INTEGER\n         LPR   1,0                TEST FOR OVERFLOW\n         BO    GOIFAOVF           OVERFLOW\n         C     1,=F'2147483'\n         BH    GOIFAOVF           OVERFLOW\n         LR    1,0                RESTORE SIGN\n         M     0,=F'1000'         CONVERT TO LINE #\n         CLI   DIFTP1+1,DEXPFIN   TEST TYPE OF EXP1\n         BE    *+12               INTEGER\n         ST    1,DIFVL2\n         B     GOIFACMP\n         SPACE\n         ST    1,DIFVL1\nGOIFACMP L     0,DIFVL1           GET VALUE OF EXP1\n         C     0,DIFVL2           COMPARE\n         EX    2,GOIFBC           CHECK CONDITIONAL BRANCH\n         B     CVGETCOM           IF IS FALSE\n         SPACE\nGOIFAOVF TSEG  'ARITHMETIC OVERFLOW'\n         B     CVQTYPE\n         SPACE\nGOIFSTR  L     3,JCBWAPTR         USE BUFFER AS WORK AREA\n         MVI   0(3),C' '\n         MVC   1(255,3),0(3)      BLANK AREA FOR COMPARE\n         LTR   R4,R0               IS STRING2 NULL\n         BNP   GOIFSCMP            BR YES TO DO SCMPARE\n         AR    R1,VCPR             POINT TO 2ND EXPR\n         BCTR  4,0\n         EX    4,GOIFMVC2         MOVE 2ND EXPR TO COMPARE AREA\nGOIFSCMP CLC   DIFSTR1(256),0(R3) SCMPARE STRINGS\n         EX    2,GOIFBC           CHECK RELATION\n         B     CVGETCOM\n         SPACE\nGOIFMVC1 MVC   DIFSTR1(0),0(R1)\nGOIFMVC2 MVC   0(0,3),0(1)\n         SPACE\nGOIFBC   BC    0,GOIFCMD\nGOIFCMD  SCANRSTR DIFSCNSV\n         SCTELL ,                 POINT TO COMMAND\n         LA    R13,CPWA            RESET R13\n         LR    R8,R13                 AND R8 FOR NEW COMMAND\n         XCALL EDTCOMMV\n         SPACE\nGOIFPRT  SCKW  EQ,GOIFEQ\n         SCKW  NE,GOIFNE\n         SCKW  LT,GOIFLT\n         SCKW  LE,GOIFLE\n         SCKW  GT,GOIFGT\n         SCKW  GE,GOIFGE\n         SCKW  ,INVALID\n         SPACE\n         LTORG\n         DROP  8\n         TITLE 'LOOKUP - VARIABLE LOOKUP ROUTINE'\n* ON ENTRY TO LOOKUP, R1 POINTS TO THE PART OF A STRING WHICH\n* MAY BE A VARIABLE.  LOOKUP CHECKS TO SEE IF THE STRING REPRE-\n* SENTS A LEGAL VARIABLE, AND IF SO, RETURNS THE REL ADDR OF THE\n* VARIABLE IN R1 AND A TYPE CODE IN R15; OTHERWISE, THE\n* CONDITION CODE IS SET TO ZERO.\n         SPACE\n* REGISTER EQU'S\n         SPACE\nLKPAR    EQU   2                  STRING ADDRESS REGISTER\nLKPLR    EQU   3                  STRING LENGTH REGISTER\n         SPACE\nLOOKUP   XENTER 2,8,*\n         CH    0,=H'2'            LEGAL VARS MUST BE 2 CHARS\n         MVC   CPDOUB(1),1(R1)   MOVE FOR TRANSLATE\n         TR    CPDOUB(1),LKTABL        TRANSLATE IT\n         SLR   R2,R2              CLEAR FOR IC\n         IC    R2,CPDOUB          GET INTO REGISTER 2\n         CH    R2,=H'15'         HIGHEST GOOD VALUE\n         BH    LKPBAD            BAD IF HIGH\n         SLL   R2,2               MULTIPLY BY 4\n         OI    0(1),X'40'         CAPITILIZE\n         CLI   0(1),C'W'          TEST FOR WVAR\n         BE    LKPWVAR            LEGAL VARIABLE\n         CLI   0(1),C'N'          TEST FOR NVAR\n         BE    LKPNVAR            LEGAL VARIABLE\n         CLI   0(1),C'S'          TEST FOR NVAR\n         BNE   LKPBAD             TOO BAD\nLKPPGET  LR    LKPLR,0            SAVE R0\n         LR    LKPAR,1            SAVE R1\n         L     VCPR,CVCPADDR      POINT TO VCP\n         USING DVCP,VCPR\nLKPVTEST CLI   0(1),C'N'          TEST FOR NVAR\n         BE    LKPNVAR\n         CLI   0(1),C'W'\n         BE    LKPWVAR\nLKPSVAR  LA    LKPAR,VCPSVAR     INITIALIZE STRING ADDR REG AND\n         SR    LKPLR,LKPLR          STRING LENGTH REG\nLKPNEXT  LA    LKPAR,2(LKPLR,LKPAR)  BUMP TO NEXT STRING VAR\n         IC    LKPLR,1(,LKPAR)      GET STRING LENGTH\n         CLC   1(1,1),0(LKPAR)     TEST FOR MATCH\n         BNE   LKPNEXT            CONTINUE SEARCH\n         LA    1,1(,LKPAR)         ADDR OF VALUE TO R1\n         SR    R1,VCPR             CONVERT ADDRESS TO RELATIVE\n         LA    15,DEXPFST         SVAR\n         B     LKPEXIT\n         SPACE\nLKPWVAR  LA    1,VCPWVAR-DVCP(LKPAR)  R1= REL. ADDR OF VAR\n         LA    15,DEXPFLN         SET TYPE= LINE #\n         B     LKPEXIT\n         SPACE\nLKPNVAR  LA    1,VCPNVAR-DVCP(LKPAR) R1=RELATIVE ADDR OF VAR\n         LA    15,DEXPFIN         SET TYPE=INTEGER\nLKPEXIT  LTR   12,12              MAKE SURE CC IS NON-ZERO\n         XEXIT 2,8\nLKPBAD   SR    15,15              SET CC TO ZERO\n         B     LKPEXIT+2\n         SPACE\n*\nLKTABL   DC    240X'10'\n         ORG   LKTABL+C'A'\n         DC    X'0A0B0C0D0E0F'\n         ORG   ,\n         DC    X'00010203040506070809'\n         DC    6X'10'\n*\nLKPABRT  TSEG  'NO VARIABLE COMMAND PAGE, COMMAND ABORTED'\n         B     CVQTYPE\n         SPACE\n         LTORG\n         TITLE 'PREPROC - WYLBUR''S PRE-PROCESSOR'\n* NOTE: PRE-PROCESSOR DOES NOT SAVE R2-R6\n         SPACE\n*        THIS IS THE PRE-PROCESSOR.  IT SCANS ALL COMMANDS TYPED INTO\n*        WYLBUR, LOOKING  FOR THE ESCAPE OR SKIP CHARACTERS.  IF THE\n*        ESCAPE CHARACTER IS ENCOUNTERED AND THE TWO CHARACTERS FOLLOW-\n*        ING IT FORM A LEGAL VARIABLE, THE VALUE OF THAT VARIABLE (IN\n*        EBCDIC) IS INSERT IN THE COMMAND IN PLACE OF THE VARIABLE AND\n*        THE ESCAPE CHARACTER(S).  IF ONLY 1 ESCAPE CHARACTER PRECEDES\n*        THE VARIABLE, THE SCAN POINTER IS INCREMENTED SO THAT THE\n*        VALUE OF THE VARIABLE IS NOT SCANNED.  IF 2 ESCAPE CHARACTERS\n*        PRECEDE THE VARIABLE THE SCAN POINTER IS NOT INCREMENTED.\n*        IF THE SKIP CHARACTER IS ENCOUNTERED, IT IS ELIMINATED FROM\n*        THE COMMAND, AND THE NEXT CHARACTER IS PASSED OVER WITHOUT\n*        INSPECTION. ADDITION-AN EXPRESSION INCLOSED IN PARENTHESES MAY\n*        ALSO FOLLOW THE ESCAPE CHARACTER(S). IN THIS CASE, THE VALUE\n*        OF THE EXPRESSION IS SUBSTITUTED FOR IT IN THE COMMAND.\n         SPACE\n*        REGISTER EQU'S\n         SPACE\nPREWR    EQU   8                  WORK AREA BASE REG\nPREER    EQU   6                  SCAN END POINTER\nPRESR    EQU   3                  SCRATCH REG\nPRELR    EQU   4                  STRING LENGTH REG\nPREAR    EQU   5                  STRING ADDRESS REG\n         SPACE\nPREPROC  XENTER 7,8,DPRELNG\n         L     VCPR,CVCPADDR      POINT TO VCP                 TESTVCP\n         USING DPREPROC,PREWR\n         ST    1,DPRER1SV         SAVE COMMAND START ADDRESS\n         XC    DPRETRTT,DPRETRTT  CLEAR TRT TABLE\n         MVI   DPREFLAG,0         CLEAR FLAG BITS\n         MVC   DPRERSCT,CPRSCNVL  INITIALIZE RESCAN COUNT\n         STM   0,1,DPRESPSV\n         LA    2,8\n         SR    PRESR,PRESR        CLEAR SCRATCH REG\n         IC    PRESR,CPESCAPE      GET ESCAPE CHAR\n         STC   2,DPRETRTT(PRESR)  SET ESCAPE CHAR STOP\n         TM    CPGFLG2,CPSKNULL   TEST SKIP FLAG\n         BO    PRENSKIP           BRANCH IF NULL\n         LA    2,4\n         IC    PRESR,CPSKIP\n         STC   2,DPRETRTT(PRESR)   SET SKIP CHAR STOP\nPRENSKIP SR    2,2\n         LR    PREER,0\n         BCTR  PREER,0\n         AR    PREER,1             SET SCAN END POINTER\n         LM    0,1,DPRESPSV\nPRESCAN1 NI    DPREFLAG,255-DPRERSCN  RESET RESCAN FLAG\n         LR    PRESR,PREER\n         SR    PRESR,1             CALC SCAN LENGTH\n         BNP   PREEXIT\n         EX    PRESR,PRETRT        SCAN\n         BC    10,PREEXIT\n         B     *(2)               USE FUNCTION BYTE AS INDEX\n         SPACE\n         B     PRESKIP\n         SPACE\nPRESCAPE LA    1,1(,1)            BUMP SCAN POINTER\n         CLC   0(1,1),CPESCAPE    TEST FOR DOUBLE ESCAPE\n         BNE   PRELOOK            LOOKUP VARIABLE\n         OI    DPREFLAG,DPRERSCN  SET RESCAN FLAG\n         LA    1,1(,1)            BUMP SP\nPRELOOK  STM   0,1,DPRESPSV       SAVE SCAN POINTER AND COMMAND LENGTH\n         CLI   0(1),C'('          TEST FOR EXPRESSION\n         BNE   PRELOOK1\n         LA    0,1(,PREER)\n         SR    0,1                CALC SCAN LENGTH\n         SCINIT (1),(0)\n         SCAN  ,\n         BNP   PREEXIT\n         STH   0,DPRELDEL         SAVE LENGTH OF STRING TO BE DELETED\n         LA    1,1(,1)\n         SH    0,=H'2'            DELETE PARENS FROM EXPRESSION\n         XCALL EXPR               EVAL EXPR\n         BZ    PRESCAN1-4\n         STM   0,1,CPWK1          SAVE VALUE REGISTERS\n         SCTELL ,\n         LTR   0,0                TEST FOR BAD EXPRESSION\n         BP    PRESCAN1-4          IGNORE WHATEVER WAS THERE\n         LM    0,1,CPWK1          RESTORE R0 R1\n         B     *+4(15)            USE TYPE CODE\n         SPACE\n         B     PRECVT             STRING VALUED EXPRESSION\n         NOP   0\n         SPACE\n         XCALL CONVERT1            CONVERT LINE NUMBER TO STRING\n         B     PRECVT1             CONTINUE WITH STRING\n         SPACE\nPRELOOK1 LA    0,2\n         STH   0,DPRELDEL         SAVE LENGTH OF STRING TO BE DELETED\n         XCALL LOOKUP\n         BZ    PRESCAN1-4\n         B     *+4(15)            USE TYPE AS INDEX\n         SPACE\n         B     PRENCVT            NO CONVERSION\n         NOP   0\n         SPACE\n         L     0,0(VCPR,R1)       GET VALUE OF LINE NUMBER VAR\n         XCALL CONVERT1            CONVERT LINE NUMBER TO STRING\n         B     PRECVT1             CONTINUE WITH STRING\n         SPACE\nPRECVT   AR    R1,VCPR             CONVERT TO ABS ADDR\nPRECVT1  LR    PREAR,1\n         LR    PRELR,0\n         B     PRERSTSP\n         SPACE\nPRENCVT  LA    PREAR,1(VCPR,R1)\n         SR    PRELR,PRELR\n         IC    PRELR,0(VCPR,R1) GET LENGTH\nPRERSTSP LM    0,1,DPRESPSV        RESTORE SCAN POINTER & COMMAND LEN\n         BAL   14,PREINST         INSERT VALUE OF VAR\n         SR    1,PRELR             RESET SCAN POINTER FOR RESCAN\n         LH    PRESR,DPRERSCT      GET RESCAN COUNT\n         SH    PRESR,=H'1'         DEC RESCAN COUNT\n         BNP   PREABRT1           ABORT IF NOT POSITIVE\n         STH   PRESR,DPRERSCT      UPDATE RESCAN COUNT\n         B     PRESCAN1\n         SPACE\nPRESKIP  BCTR  PREER,0\n         BCTR  0,0                DECR COMMAND LENGTH\n         LR    PRESR,PREER\n         SR    PRESR,1             LENGTH OF SCAN\n         BM    PRESCAN1            NO MOVE IF END OF STRING\n         EX    PRESR,PRE1LMVC      MOVE SCAN STRING LEFT 1 BYTE\n         LA    1,1(,1)            SKIP CHARACTER\n         B     PRESCAN1\n         SPACE\nPRE1LMVC MVC   0(0,1),1(1)\nPRETRT   TRT   0(0,1),DPRETRTT\n         SPACE\nPREINST  L     2,JCBWAPTR         USE BUFFER AS SAVE AREA\n         AH    1,DPRELDEL         POINT TO END OF STRING TO BE REPLACED\n         LR    PRESR,PREER\n         SR    PRESR,1             CALC LENGTH OF REMAINING SCAN\n         BM    *+8\n         EX    PRESR,PREINSM1      MOVE SCAN STRING TO TEMP\n         SH    1,DPRELDEL\n         BCTR  1,0                BACK SPACE TO ESCAPE CHAR\n         BCTR  0,0                DECR COMMAND LENGTH\n         BCTR  PREER,0            AND SCAN END POINTER\n         TM    DPREFLAG,DPRERSCN  TEST FOR RESCAN\n         BNO   PRERTNCH           BRANCH IF NONE\n         BCTR  1,0\n         BCTR  0,0             ADJUST COMMAND LENGTH\n         BCTR  PREER,0             AND END OF SCAN POINTER\n         B     *+8                SKIP EXIT CHANGE\n         SPACE\nPRERTNCH LA    14,PRESCAN1         CHANGE EXIT IF NO RESCAN\n         AR    0,PRELR\n         SH    0,DPRELDEL         CALC NEW COMMAND LENGTH\n         CH    0,=AL2(SZR)     TEST AGAINST MAX\n         BH    PREABRT2           ABORT IF HIGH\n         SH    PRELR,=H'1'\n         BM    *+8\n         EX    PRELR,PREINSM2      INSERT VALUE\n         LA    PRELR,1(,PRELR)\n         AR    1,PRELR             ADVANCE SCAN POINTER\n         LTR   PRESR,PRESR\n         BM    *+8\n         EX    PRESR,PREINSM3      TACK ON SCAN STRING\n         AR    PREER,PRELR\n         SH    PREER,DPRELDEL      CALC NEW END OF SCAN POINTER\n         LA    2,1               CLEAR FOR TRT (MAKE NON-ZERO FOR EXIT)\n         BR    14\n         SPACE\nPREINSM1 MVC   0(0,2),0(1)\nPREINSM2 MVC   0(0,1),0(PREAR)\nPREINSM3 MVC   0(0,1),0(2)\n         SPACE\nPREABRT1 TSEG  'TOO MANY RESCANS',,B\n         B     PREABRT\n         SPACE\nPREABRT2 ST    1,DPRESPSV\n         TSEG  'COMMAND LENGTH OVERFLOW SUBSTITUTING FOR',,B\n         L     1,DPRESPSV\n         LA    1,1(,1)            BUMP PAST ESCAPE CHAR\n         TM    DPREFLAG,DPRERSCN  TEST FOR 2ND ESCAPE CHAR\n         BNO   *+8                NONE\n         LA    1,1(,1)            BUMP PAST 2ND ESCAPE CHAR\n         LH    0,DPRELDEL         GET LENGTH OF SUBSTITUTION STR\n         TSEG  (1),(0),B\nPREABRT  TSEG  ',PREPROCESSING ABORTED'\n         B     CVQTYPE\n         SPACE\nPREEXIT  L     VCPR,CVCPADDR\n         LR    R3,R0               SAVE COMMAND LENGTH\nPREEXIT1 L     1,DPRER1SV         RESTORE COMMAND START ADDR\n         LTR   2,2\n         BNP   PREEXIT2            DON'T COUNT IF NO CHANGE\n         LTR   R2,R2               RESET COND CODE\nPREEXIT2 XEXIT 7,8\n         SPACE\n         LTORG\n         SPACE\n         DROP  PREWR\n         TITLE 'READVAL - READ VALUE ROUTINE'\n* THIS SECTION EXECUTES THE 'READ VALUE' COMMAND\n         SPACE\nRDVPR    EQU   3                   STACK POINTER\nRDVCR    EQU   4                   STACK COUNTER\n         SPACE\nREADVAR  GENTER ,\n         USING  READWA,R5\n         SCINIT (1),(0)            SET SCAN TO INPUT LINE\n         LA    RDVPR,RDWAVAR       POINT TO VARIABLE AREA\n         LH    RDVCR,RDWAVARN      GET COUNT OF VARIABLES\nREADVLP  LR    R1,RDVPR            POINT TO NEXT VARIABLE\n         LA    R0,2                SET LENGTH FOR LOOKUP\n         XCALL LOOKUP              LOOKUP VARIABLE\n         BZ    CVNVALID            NOT A VARIABLE\n         STC   R15,0(,RDVPR)       SAVE VARIABLE TYPE\n         LR    R2,R1               SET VARIABLE ADDRESS IN R2\n         SCTELL ,\n         XCALL EXPR               GET VALUE OF VARIABLE\n         BZ    READNULL            NOTHING -- ASSIGN NULL OR 0\n         B     *+4(15)            BRANCH ON TYPE CODE\n         SPACE\n         B     READSVAL           STRING\n         B     READNVAL           INTEGER\n         B     READWVAL           LINE NUMBER\n         SPACE\nREADSVAL AR    R1,VCPR             MAKE ABS POINTER TO STRING\n         CLI   0(RDVPR),DEXPFST     TEST TYPE\n         BE    READSV1            A STRING VAR IS BEING READ\n         XCALL CONVERT2           CONVERT STRING TO LINE #\n         B     *(15)              USE TYPE AS BRANCH\n         SPACE\n         B     READNV1            INTEGER\n         B     READWV1\n         SPACE\nREADSV1  XCALL ASSIGN             MAKE ASSIGNMENT\n         LA    RDVPR,4(,RDVPR)      BUMP SP\n         BCT   RDVCR,READVLP       LOOP FOR MORE VALUES\n         XCALL SCANEND            IGNORE THE REST\n         B     CVGETCOM\n         SPACE\nREADWVAL CLI   0(RDVPR),DEXPFST     TEST TYPE\n         BNE   READWV1            LVAR BEING READ\nREADSCVT XCALL CONVERT1           CONVERT LINE # TO STRING\n         MVC   RDWAPRMT(16),0(1)  SAVE STRING IN THIS WORK AREA\n         LA    1,RDWAPRMT         POINT TO IT\n         B     READSV1\n         SPACE\nREADWV1  CLI   0(RDVPR),DEXPFIN    TEST TYPE\n         BNE   READWV2            LINE #\n         SRDA  0,32(0)\n         D     0,=F'1000'         CONVER TO INTEGER\n         LR    0,1\n         B     READNV2\n         SPACE\nREADWV2  ST    0,0(VCPR,R2)       MAKE ASSIGNMENT\n         LA    RDVPR,4(,RDVPR)      BUMP SP\n         BCT   RDVCR,READVLP\n         XCALL SCANEND            IGNORE THE REST\n         B     CVGETCOM\n         SPACE\nREADNVAL CLI   0(RDVPR),DEXPFST    TEST VAR TYPE\n         BE    READSCVT           STRING\nREADNV1  CLI   0(RDVPR),DEXPFLN    TEST VAR TYPE\n         BNE   READNV2            INTEGER\n         LR    R1,R0               SET FOR MULTIPLY\n         M     R0,=F'1000'         CONVERT TO LINE #\n         SLDA  R0,32               PUT IN R0 AND TEST OFLO\n         BNO   READWV2             OK IF NO OFLO\n         TSEG  'ARITHMETIC OVERFLOW'\n         B     CVQTYPE\n         SPACE\nREADNV2  ST    0,0(VCPR,2)        MAKE INTEGER ASSIGNMENT\n         LA    RDVPR,4(,RDVPR)\n         BCT   RDVCR,READVLP\n         XCALL SCANEND\n         B     CVGETCOM\n         SPACE\nREADNULL SR    R0,R0               SET NULL STRING OR 0 VALUE\n         CLI   0(RDVPR),DEXPFST    IS IT A STRING VARIABLE\n         BE    READSV1             YES, GO ASSIGN NULL\n         CLI   0(RDVPR),DEXPFIN\n         BE    READNV2            INTEGER\n         B     READWV2            LINE #\n         SPACE\n         DROP  R5\n         SPACE\n         LTORG\n         TITLE 'READSTR - READ STRING ROUTINE'\n* THIS SECTION EXECUTES THE 'READ STRING' COMMAND\n         SPACE\nREADSTR  GENTER ,\n         USING READWA,R5\n         L     R2,RDWAVAR          GET STRING VARIABLE ADDR\n         LA    R2,0(,R2)           CLEAR HIGH ORDER BYTE\n         XCALL ASSIGN              ASSIGN THE STRING VALUE\n         B     CVGETCOM            GO GET NEXT COMMAND\n         SPACE\n         DROP  R5\n         TITLE 'SCANEND - JUNK SCANNER'\nSCANEND  DS    0H\n         XENTER 0,8,*\n         SCAN  ,\n         BNP   SCNEND2            THERE'S NOTHING\nSCNEND1  TSEG  (1),(0)            ADD TO PRINT LINE\n         SCAN  ,                  PICK OFF JUNK\n         BP    SCNEND1\n         TSEG  ': IGNORED',,W\nSCNEND2  XEXIT 0,8\n         LTORG\n         TITLE 'SETVAL - SET VALUE ROUTINE'\n* THIS SECTION EXECUTES THE 'SET VALUE' COMMAND\n         SPACE\nSETVAR   GENTER 16\n         XCALL LOOKUP\n         BZ    CVNVALID           NO GOOD\n         LR    2,1                SAVE VAR ADDR\n         SCTELL ,                 POINT TO EXPRESSION\n         B     *+4(15)            BRANCH ON TYPE CODE\n         SPACE\n         B     SETSVAR            IT'S A STRING VAR\n         B     SETIVAR            INTEGER\n         SPACE\nSETLVAR  XCALL EXPR               ANALYZE EXPRESSION\n         BZ    CVABSENT            OPERAND MISSING IF NO EXPR\n         B     *+4(15)            BRANCH ON EXPR TYPE\n         SPACE\n         B     SETLVAR1           STRING\n         B     SETLVAR2           INTEGER\n         B     SETLVAR3           OK-IT'S A LINE NUMBER\n         SPACE\nSETLVAR1 AR    R1,VCPR             MAKE ADDRESS ABSOLUTE\n         XCALL CONVERT2           TRY STRING -> LINE NUMBER\n         B     *(15)              USE TYPE CODE AS BRANCH\n         SPACE\n         B     SETLVAR2           INTEGER\n         B     SETLVAR3           LINE #\n         SPACE\nSETLVAR2 LPR   1,0                CHECK FOR OVERFLOW\n         BO    SETAOVF            OVERFLOW\n         C     1,=F'2147483'\n         BH    SETAOVF\n         LR    1,0                RESTORE SIGN\n         M     0,=F'1000'         CONVERT TO LINE #\n         LR    0,1\nSETLVAR3 ST    0,0(VCPR,R2)       MAKE ASSIGNMENT\n         B     SETIGNOR\n         SPACE\nSETIVAR  XCALL EXPR               EVAL EXPRESSION\n         BZ    CVABSENT            OPERAND MISSING IF NO EXPR\n         B     *+4(15)            BRANCH ON TYPE\n         SPACE\n         B     SETIVAR1           STRING\n         B     SETIVAR3           INTEGER\n         B     SETIVAR2           LINE #\n         SPACE\nSETIVAR1 AR    1,VCPR             ABS ADDR OF STRING\n         XCALL CONVERT2           STRING TO ARITHMETIC\n         B     *(15)              USE TYPE CODE\n         SPACE\n         B     SETIVAR3           INTEGER\n         SPACE\nSETIVAR2 SRDA  0,32(0)\n         D     0,=F'1000'         CONVERT TO INTEGER\n         LR    0,1\nSETIVAR3 ST    0,0(VCPR,2)        MAKE ASSIGNMENT\n         B     SETIGNOR\n         SPACE\nSETAOVF  TSEG  'ARITHMETIC OVERFLOW'\n         B     CVQTYPE\n         SPACE\nSETSVAR  XCALL EXPR\n         BZ    CVABSENT            OPERAND MISSING IF NO EXPR\n         B     *+4(15)\n         SPACE\n         B     SETSVAR0           OK-IT'S A STRING\n         NOP   0\n         SPACE\n         XCALL CONVERT1           LINE # -> STRING\n         MVC   0(16,8),0(1)       SAVE STRING IN THIS WORK AREA\n         LR    1,8                POINT TO IT\n         B     SETSVAR1            GO MAKE ASSIGNMENT\n         SPACE\nSETSVAR0 AR    R1,VCPR             MAKE ADDRESS ABSOLUTE\nSETSVAR1 XCALL ASSIGN             MAKE ASSIGNMENT\nSETIGNOR XCALL SCANEND            IGNORE THE REST\n         B     CVGETCOM\n         SPACE\n         LTORG\n         TITLE 'SHOVAL - SHOW VALUE ROUTINE'\n* THIS SECTION EXECUTES THE 'SHOW VALUE' COMMAND\n         SPACE\nSHOLR    EQU   2                  LINE LENGTH REGISTER\nSHOSR    EQU   3                  SCRATCH REGISTER\n         SPACE\nSHOVAR   GENTER 8\n         SR    SHOLR,SHOLR        ZERO LENGTH REG\nSHOVAR1  SCTELL ,                 POINT TO NEXT EXPRESSION\n         XCALL  EXPR              ANALYZE\n         BZ    CVGETCOM            BR IF NO MORE TO DO\n         B     *+4(15)            USE TYPE AS INDEX\n         SPACE\n         B     SHOVAR3            EXPR VALUE IS STRING\n         NOP   0\n         SPACE\n         CH    SHOLR,=H'115'       IS THERE ROOM ON THIS LINE\n         BNH   SHOVAR21            BR YES\n         LR    SHOSR,R0            SAVE VALUE\n         ST    R15,0(8)          SAVE R15\n         TWRITE ,                  WRITE OUT PROVIOUS LINE\n         L     R15,0(8)          RESTORE R15.\n         BP    CVQTYPE             ABORT IF ATTENTION\n         LR    R0,SHOSR            RESTORE VALUE\n         SR    SHOLR,SHOLR         RESET LINE COUNT\nSHOVAR21 XCALL CONVERT1            CONVERT LINE NUM TO STRING\n         AR    SHOLR,R0            ADD IN COUNT\n         LA    SHOLR,1(,SHOLR)     PLUS 1 FOR BLANK\n         TSEG  (1),(0),BLANK       PUT VALUE IN BUFFER\n         B     SHOVAR1             GO DO NEXT VALUE\n         SPACE\nSHOVAR3  STM   0,1,0(8)           SAVE RO AND R1\n         TSEG  ''''\n         LA    SHOLR,1(,SHOLR)     ADD 1 FOR QUOTE\n         LM    0,1,0(8)           RESTORE R0 AND R1\n         AR    SHOLR,0            BUMP LINE LENGTH\nSHOVAR30 CH    SHOLR,=H'120'\n         BNH   SHOVAR31           OK\n         LA    SHOSR,120          GET MAX LINE LENGTH\n         SR    SHOLR,0\n         SR    SHOSR,SHOLR        CALC REMAINING LENGTH TO FILL LINE\n         TSEG  0(VCPR,R1),(SHOSR),W  FILL LINE AND PRINT\n         BP    CVQTYPE             ABORT IF ATTENTION\n         LM    0,1,0(8)           RESTORE R0 AND R1\n         SR    0,SHOSR            CALC REMAINING PRINT LENGTH\n         AR    1,SHOSR            INCR POINTER\n         LR    SHOLR,0            RESET LENGTH\n         STM   R0,R1,0(R8)         UPDATE SAVED VALUES\n         B     SHOVAR30            GO SEE IF IT FITS NOW\n         SPACE\nSHOVAR31 TSEG  0(VCPR,R1),(0)            VALUE OF STRING\n         TSEG  '''',,BLANK        CLOSING QUOTE\n         LA    SHOLR,2(,SHOLR)     ADD 2 FOR QUOTE  AND BLANK\n         B     SHOVAR1            LOOP FOR MORE\n         SPACE\n         LTORG\n         TITLE 'CONSTANTS'\n         COPY  WYLCONST\n         EJECT\n         COPY  READWA\n         TITLE 'DSECTS'\n         COPY  VCPTSO\n         SPACE\nVCPLSVA2 EQU   VCPLSVA-2\n* PUT WORK AREA FOR EXPRESSION SCANNER AFTER VCP AREA\n*    NOTE THAT THE MAX LENGTH MUST BE LESS THAT CPSIZE\nDEXPPRSV DS    F                  SAVE AREA FOR POINTER REG\nDEXPWK   DS    3F\nDEXPSP   DS    A                  STACK POINTER\nDEXPSAP  DS    A                  STRING POINTER\nDEXPRFCT DS    H                  PREFIX + - COUNTER\n         DS    0F                 ALIGN STACK ON FULLWORD\nDEXPSTK  DS    XL146              STACK\nDEXPSWA  DS    XL576              STRING WORK AREA\nDEXPRLEN EQU   *-DVCP              LENGTH OF VCP AREA\n         SPACE\nDASSIGN  DSECT\nDASNLSV  DS    F                  LENGTH SAVE AREA\nDASNTEMP DS    XL(VCPLSVA)        STRING SAVE AREA\nDASNLNG  EQU   *-DASSIGN          LENGTH\n         SPACE\nDCONVERT DSECT\n         DS    F                  R14 SAVE AREA\n         DS    8F                 R1-R8 SAVE AREA\nDCONCVT  DS    D                  CONVERSION AREA\nDCONWORK DS    XL(L'CON1MSK1)     WORK AREA\n         DS    F\nDCONLNG  EQU   *-DCONVERT\n         SPACE\nDPREPROC DSECT\n         DS    F                  R14 SAVE AREA\n         DS    2F                 R7-R8 SAVE AREA\nDPRER1SV DS    F                  R1 SAVE AREA\nDPRESPSV DS    2F\nDPRERSCT DS    H                  RESCAN COUNT\nDPRELDEL DS    H                  LENGTH OF STRING TO BE REPLACED\nDPRETRTT DS    XL256              TRT TABLE\nDPREFLAG DS    X                  FLAG BITS\nDPRERSCN EQU   X'80'              RESCAN FLAG\nDPRELNG  EQU   *-DPREPROC\n         SPACE\nDIF      DSECT\nDIFSCNSV DS    2F                 SCAN SAVE AREA\nDIFVL1   DS    F\nDIFVL2   DS    F\nDIFTP1   DS    H\nDIFTP2   DS    H\nDIFSTR1  DS    CL256\nDIFLNG   EQU   *-DIF\n         EJECT\n         COMMON\n         SPACE\n         END\n./ ADD NAME=PSCN,SSI=00000002\nPSCN     TITLE 'WYLTSO''S SCANNER'\n* PROPERTY OF C. U. C. C. A.\n         SPACE 3\nPSCN     CSECT\n         SPACE\n         WIDENT 001\n         SPACE\n         XTRNS ,\n         SPACE 3\n* REGISTER USAGE\n         SPACE\nPR       EQU   6\nNR       EQU   5\nRR       EQU   4\nTR       EQU   3\nSR       EQU   2\n         SPACE\n         USING SA,8\n         USING CPAREA,R12\n         EJECT\n* INITIALIZE\n         SPACE\n         ENTRY SCINIT\nSCINIT   LA    1,0(,1)\n         STH   0,LEN                   SAVE LENGTH\n         ST    1,LOC                   SAVE LOCATION\n         BR    14\n         SPACE 3\n* TELL LOCATION AND LENGTH\n         SPACE\n         ENTRY SCTELL\nSCTELL   LH    0,LEN                   LENGTH\n         L     1,LOC                   LOCATION\n         BR    14\n         SPACE 3\nSCAN     XENTER 2,12\nBASE     ST    14,RA                   RETURN ADDR\n         ST    1,PRT                   ROUTING TABLE\nGOSCAN   LH    NR,LEN                  GET LENGTH\n         L     PR,LOC                  GET LOCATION\n         SR    RR,RR\n         MVI   FL,0                    CLEAR FLAGS\nRESCAN   LTR   NR,NR                   ANY LEFT?\n         BNP   DONE                    BR IF NOT\n         SR    2,2                     CLEAR TRT REGS\n         LA    1,0(PR,NR)\n         BCTR  NR,0\n         EX    NR,TRT\n         B     *+4(2)                  BR ON DELIM CODE\n         SPACE\n         B     EOS                     0  END OF STRING\n         B     BLKCOM                  4  BLANK-COMMA\n         B     SQUOTE                  8  SINGLE QUOTE\n         B     DQUOTE                  12 DOUBLE QUOTE\n         B     LPAR                    16 LEFT PAREN\n         B     RPAR                    20 RIGHT PAREN\n         B     SLASH                    24 SLASH\n         B     SEMI                    28 SEMICOLON\n         SPACE 3\n* PROCESS END OF STRING\n         SPACE\nEOS      TM    FL,FSQS+FDQS+FPS        STRING?\n         BZ    PREND                   BR IF NOT\nILLSTR   LR    0,1                     COMPUTE STRING PTR\n         L     1,LOC\n         SR    0,1\n         B     RTNER                   RETURN\n         SPACE 3\n* PROCESS BLANKS\n         SPACE\nBLKCOM   TM    FL,FSQS+FDQS+FPS        STRING BEING COLLECTED?\n         BNZ   GOSTRING                BR IF SO\nPREND    SR    1,PR                    COMPUTE TOKEN SIZE\n         STH   1,LEN                   SAVE LENGTH & LOCATION\n         ST    PR,LOC\n         LA    PR,1(1,PR)              UPDATE STRING PTR\n         SR    NR,1\n         LTR   1,1                     TOKEN?\n         BP    TOKEN                   BR IF SO\n         B     RESCAN\n         SPACE 3\n* PROCESS SEMICOLON\n         SPACE\nSEMI     TM    FL,FSQS+FDQS+FPS        STRING BEING COLLECTED\n         BNZ   GOSTRING                BR IF SO\n         SR    NR,NR                   SET COUNT FOR END OF LINE\n         B     PREND                   FINISH UP TOKEN\n         SPACE 3\n* PROCESS SLASH\n         SPACE\nSLASH    TM    FL,FSQS+FDQS+FPS         STRING BEING COLLECTED?\n         BNZ   GOSTRING                 BR IF SO\n         ST    PR,LOC                   TOKEN START\n         SR    1,PR                     COMPUTE TOKEN SIZE\n         BP    STOKEN                   TOKEN WON'T BE \"/\"\n         LA    1,1                      LENGTH \"/\" TOKEN\n         B     STORZ                    FINISH SETUP\n         SPACE\nSTOKEN   SR    NR,1                     NEW STRING SIZE\n         LA    NR,1(NR)                 KEEP \"/\" IN STRING\nSTORZ    STH   1,LEN                   TOKEN LENGTH\n         LA    PR,0(1,PR)               POINT OVER TOKEN\n         B     TOKEN                    PROCESS\n         SPACE 3\n* PROCESS SINGLE QUOTE\n         SPACE\nSQUOTE   TM    FL,FDQS                 \"STRING\"?\n         BNZ   GOSTRING                BR IF SO\n         TM    FL,FSQS                 OLD STRING?\n         BO    CSQ                     BR IF SO\n         TM    FL,FPS              IS IT MIDDLE OF PAREN STRING\n         BO    SQUOTE1             YES, ONLY SET FLAG\n         CLR   1,PR                    COMPUTE TOKEN SIZE\n         BNE   PREVTOK                 BR IF PREVIOUS TOKEN\n         ST    PR,LOC\nSQUOTE1  OI    FL,FSQS                 SET STRING SCAN\n         B     GOSTRING\n         SPACE\nCSQ      AR    NR,PR                   BUMP PTR\n         LR    PR,1\n         SR    NR,1\n         BNP   CSQETST                 BR IF END\n         CLC   0(1,PR),1(PR)       SAME KIND OF QUOTE DOUBLED\n         BNE   CSQETST                 BR IF NOT\n         BCTR  NR,0                    ELIMINATE 2ND QUOTE\n         LA    PR,2(,PR)\n         B     RESCAN\n         SPACE\nCSQETST  TM    FL,FPS              IS THIS STRING WITHIN PARENS\n         BE    ESTR                NO, GO END NORMALLY\n         NI    FL,255-FSQS-FDQS    YES, TURN OFF STRING FLAGS\n         LA    PR,1(,PR)           POINT BEYOND STRING\n         B     RESCAN              GO FINISH PARENS\n         SPACE\nPREVTOK  SR    1,PR\n         STH   1,LEN                   SAVE LENGTH & LOCATION\n         ST    PR,LOC\n         AR    PR,1\n         SR    NR,1\n         LA    NR,1(,NR)\n         B     TOKEN\n         SPACE 3\n* PROCESS DOUBLE QUOTE\n         SPACE\nDQUOTE   TM    FL,FSQS                 'STRING'?\n         BNZ   GOSTRING                BR IF SO\n         TM    FL,FDQS                 OLD STRING?\n         BO    CSQ                     BR IF SO\n         TM    FL,FPS              IS IT MIDDLE OF PAREN STRING\n         BO    DQUOTE1             YES, ONLY SET FLAG\n         CLR   1,PR                    TOKEN SIZE\n         BNE   PREVTOK\n         ST    PR,LOC\nDQUOTE1  OI    FL,FDQS                 SET STRING SCAN\n         B     GOSTRING\n         SPACE\nESTR     LA    PR,1(,PR)\n         LR    0,PR                    COMPUTE TOKEN SIZE\n         S     0,LOC\n         STH   0,LEN                   SAVE LENGTH\n         B     TOKEN\n         SPACE 3\n* PROCESS LEFT PAREN\n         SPACE\nLPAR     TM    FL,FSQS+FDQS            QUOTED STRING?\n         BNZ   GOSTRING                BR IF SO\n         TM    FL,FPS                  PAREN STRING?\n         BO    INP                     BR IF SO\n         CLR   1,PR                    TOKEN SIZE\n         BNE   PREVTOK                 BR IF PREVIOUS TOKEN\n         OI    FL,FPS                  SET PAREN SCAN\n         LA    SR,1\n         STH   SR,PCNT\n         ST    PR,LOC\n         B     GOSTRING\n         SPACE\nINP      LH    SR,PCNT                 PAREN COUNT\n         LA    SR,1(,SR)\n         STH   SR,PCNT\n         B     GOSTRING\n         SPACE 3\n* PROCESS RIGHT PAREN\n         SPACE\nRPAR     TM    FL,FSQS+FDQS            QUOTED STRING?\n         BNZ   GOSTRING                BR IF SO\n         TM    FL,FPS                  PAREN STRING?\n         BZ    ILLST                   BR IF NOT\n         LH    SR,PCNT                 DECR COUNT\n         BCTR  SR,0\n         STH   SR,PCNT\n         LTR   SR,SR\n         BNZ   GOSTRING\n         SR    NR,1                    UPDATE STR PTR\n         AR    NR,PR\n         LR    PR,1\n         B     ESTR\n         SPACE\nGOSTRING SR    NR,1                    UPDATE STRING PTRS\n         AR    NR,PR\n         LA    PR,1(,1)\n         B     RESCAN\n         SPACE\nILLST    LR    0,1                     COMPUTE -LENGTH\n         SR    0,PR\n         LR    1,PR                    LOC OF TOKEN\n         B     RTNER\n         EJECT\n* PROCESS A TOKEN\n         SPACE\nTOKEN    LH    0,LEN                   GET LENGTH\n         L     1,LOC                   GET LOCATION\n         LR    15,0\n         MVI   KW,C' '                 CLEAR KW AREA\n         MVC   KW+1(7),KW\n         XC    PRTSTACK,PRTSTACK   ZERO PRT STACK VALUE\n         TM    FL,FSQS+FDQS+FPS        QUOTE OR PAREN STRING?\n         BNZ   PRKW                    BR IF QUOTE OR PAREN STRING\n         LR    SR,0                    COUNT\n         LR    TR,1                    PTR\nMRECH    OI    0(TR),X'40'             CAPITAL BIT\n         LA    TR,1(,TR)               MOVE PTR\n         BCT   SR,MRECH                MORE?\n         CL    15,=A(8)                MAX LEN IS 8\n         BL    *+8                     BR IF TOO LONG\n         LA    15,8                SET TO MOVE FIRST 8\n         BCTR  15,0\n         EX    15,MVT                  MOVE KW\nPRKW     LTR   RR,RR                   ROUTINE?\n         BNZ   SETSR                   BR IF SO\n         L     SR,PRT                  ROUTING TABLE\n         LTR   SR,SR\n         BP    KWSRCH                  BR IF NORMAL TABLE\n         BM    KWRELTAB                BR IF TABLE IN PAGED CODE\n         L     RR,RA\n         SLL   RR,8                PUT ADDR IN UPPER REG\n         B     GORTN\n         SPACE 3\n* THE TABLE IS IN PAGED CODE -- CONVERT TO ABSOLUTE ADDRESS\n         SPACE\nKWRELTAB LCR   SR,SR               GET POSITIVE DISPLACEMENT\n         ALR   SR,10               ADD IN PAGE BASE OFF R10\n         B     KWSRCH              NOW GO SEARCH\n         SPACE\nKWNEX    LA    SR,5(TR,SR)             TRY NEXT\nKWSRCH   TM    0(SR),FTBLE         IS IT PUSH, POP, OR END\n         BO    KWFND                   BR IF SO\n         IC    TR,0(,SR)               EXTRACT (LEN-1)\n         N     TR,=X'00000007'\n         TM    FL,FSQS+FDQS+FPS        QUOTE OR PAREN STRING?\n         BNZ   NXTRY                   BR IF QUOTE OR PAREN STRING\n         LTR   TR,TR                   TEST TOKEN LEN\n         BNZ   COMPOK                  USER KW EXISTS\n         CLI   4(SR),C' '              BLANK?\n         BE    KWFND                   YES\nCOMPOK   CR    TR,15                   LEN OK?\n         BL    NXTRY               NO, GO ON\n         BE    DOCOMP              EQUAL, GO COMPARE\n         TM    0(SR),FABBREV           TRY ABBREVIATION?\n         BZ    NXTRY                   NO\n         CH    0,=Y(3)                 3-CHARS?\n         BL    NXTRY                   NO\nDOCOMP   EX    15,CLC                  COMPARE KEYWORDS\n         BE    KWFND                   BR IF FOUND\nNXTRY    TM    0(SR),FLIMIT            LIMIT?\n         BZ    KWNEX                   NO\n         TM    0(SR),FINTEG+FINTEGP    INTEGER?\n         BNM   KWNEX                   NO\n         LA    SR,9(TR,SR)             TRY NEXT\n         B     KWSRCH\n         SPACE 3\nKWFND    NI    FL,255-FSQS-FDQS-FPS    RESET STRING SCAN\n         MVC   WORD(3),1(SR)       TO LEFT ADJUSTED WORD BOUND\n         L     RR,WORD                 ROUTINE\n         TM    0(SR),FTBLE         IS IT PUSH, POP, OR END\n         BO    TSTLAST             YES BR IF SO\n         TM    0(SR),FPARM             PARM?\n         BZ    GORTN                   BR IF NO PARM\n         IC    RR,*                MAKE SURE RR NOT ZERO\n         SPACE\n* SET RIGHT BYTE NON-ZERO SINCE IT IS IGNORED LATER\n         STM   SR,TR,WORD              SAVE SR/TR VALUES\n         B     RESCAN                  FIND PARM\n         SPACE\nTSTLAST  TM    0(SR),255-FTBLE     IS IT LAST\n         BO    GORTN               ALL ON, YES\n         BM    GOPOP               MIXED, GO POP UP ONE LEVEL\n         SPACE\n* PUSH DOWN CURRENT SCAN TABLE POINTER\n         LA    SR,4(,SR)           SET FOR NEXT AFTER POP\n         SRA   RR,8                FORM ADDRESS AND CHECK\n         BP    GOPUSH1             BR IF NORMAL ABSOLUTE ADDRESS\n         BZ    KWSRCH              BR IF NO TABLE TO PUSH TO\n         LCR   RR,RR               MAKE DISPLACEMENT POSITIVE\n         ALR   RR,10               ADD IN BASE TO GET ABSOLUTE\nGOPUSH1  LH    14,PRTSTACK         GET CURRENT STACK COUNT\n         SH    14,=H'4'            DECREMENT\n         STH   14,PRTSTACK         REPLACE STACK COUNT\n         ST    SR,CPCHECK(14)      SAVE CURRENT PRT POINTER\n         SPACE\n* NOTE THAT IT IS ALRIGHT TO SAVE THE ABSOLUTE POINTER TO\n*    ANY PRT IN PAGED-CODE BECAUSE PUSH/POP LOGIC IS ALWAYS\n*    DONE ENTIRELY IN THE SCANNER AND NO ONE ELSE CAN BE\n*    DISPATCHED UNTIL ALL POPS HAVE BEEN DONE.\n*    IF A POP IS NOT DONE BECAUSE A MATCH IS FOUND, THE\n*    ABSOLUTE ADDRESS WILL NOT BE USED.\n         SPACE\n         LR    SR,RR               SET NEW PRT ADDRESS\n         B     KWSRCH              GO SEARCH THIS TABLE\n         SPACE 3\n* POP UP A SAVE SCAN TABLE POINTER -- IGNORE IF AT TOP LEVEL\n         SPACE\nGOPOP    LH    14,PRTSTACK         GET CURRENT STACK POINTER\n         AH    14,=H'4'            INCREMENT\n         BP    NXTRY1              IGNORE IF TOP LEVEL\n         STH   14,PRTSTACK         PUT BACK STACK POINTER\n         L     SR,CPCHECK-4(14)    PICK UP OLD PRT POINTER\n         B     KWSRCH              BR TO CONTINUE SEARCH\n         SPACE\nNXTRY1   LA    SR,1(,SR)           STEP PAST IGNORED POP\n         B     KWSRCH              CONTINUE IN SAME TABLE\n         SPACE 3\nSETSR    LM    SR,TR,WORD              RESET SR/TR VALUES\nGORTN    SRA   RR,8                FORM ADDRESS AND CHECK\n         BZ    RESCAN                  BR IF NO ROUTINE\n         STH   NR,LEN                  SAVE LENGTH\n         ST    PR,LOC                  SAVE LOCATION\n         STM   0,1,CPSAVE              SAVE PTRS\n         ST    15,SV15                 SAVE 15\n         LTR   SR,SR                   PRT?\n         BZ    NTCMV                   BR IF NOT\n         CLI   0(SR),FLAST             END?\n         BE    NTCMV                   BR IF SO\n         TM    0(SR),FLINNO            INTEGER OR LINE NO CONV?\n         BO    LINNOCV                 LINE NO. CONV\n         BM    INTGRCV                 INTEGER CONV\n         TM    0(SR),FCMSET            SET COMMAND CHARS?\n         BZ    NTCMV                   DON'T MOVE 3 CMD CHARS\n         MVC   CPCMNM(3),KW            MOVE THEM\nNTCMV    LA    15,KW                   KW PTR\nNOTKWPS  LTR   14,RR                   SET EP AND TEST\n         BP    GORTN1              GO IF ABSOLUTE ADDRESS\n         LCR   14,14               COMPL VALUE FOR PAGED CODE\n         AR    14,10               ADD IN START OF PAGED CODE\nGORTN1   LM    2,12,4(13)\n         LTR   0,0                     SET CC\n         BALR  14,14                   GO TO PARM ROUTINE\n         SPACE 3\n         XENTER 2,12                   SAVE\n         L     7,=A(BASE)              RESTORE BASE\n         USING BASE,7\n         B     GOSCAN                  CONTINUE SCAN\n         EJECT\n* DECIMAL TO BINARY CONV RTN FOR SCAN\n         SPACE\nINTGRCV  BAL   14,DOINT                GO DO CV\n         TM    0(SR),FINTEGP           POS INT?\n         BZ    ANYI                    NO\n         LTR   0,0                     TEST INTEG\n         BNP   BOO                     NG\nANYI     TM    0(SR),FLIMIT            LIMIT?\n         BZ    NTRSET                  NO\n         ST    0,WORD                  FOR CLC\n         LA    PR,5(SR,TR)             PT AT LIMIT\n         CLC   WORD(4),0(PR)           CHECK LIMIT\n         BNH   NTRSET                  OK\n         B     BOO                     NG\n         SPACE 3\nLINNOCV  CL    0,=A(9)                 MAX LENGTH IN 9\n         BH    BOO                     TOO BIG\n         SR    15,15                   ZERO COUNTER\n         LR    PR,1                    PTR\nCHKMR    CLI   0(PR),C'.'              PERIOD?\n         BE    HVPRD                   YES\n         LA    15,1(,15)               KICK COUNTER\n         LA    PR,1(,PR)               KICK PTR\n         BCT   0,CHKMR                 MORE?\n         B     WHOL                    INTEGER LINE NO\n         SPACE\nHVPRD    BCT   0,CHKFR                 FRACTION?\nWHOL     LTR   0,15                    INTEG COUNT\n         BNP   BOO                     \".\" NOT LEGAL\n         SR    15,15                   ZERO FRACTION\nWHOLDO   CL    0,=A(5)                 MAX LENGTH IS 5\n         BH    BOO\n         BAL   14,DOINT                CONV\n         MH    0,=H'1000'              SET INTEGER VALUE\n         AR    0,15                    ADD IN FRACTION\nNTRSET   LR    15,0                    SET RETURN VALUE INTO R15\n         LM    0,1,CPSAVE              RESET PTRS\n         B     NOTKWPS                 READY TO RETURN\n         SPACE\nCHKFR    CL    0,=A(4)                 3 IS MAX\n         BNL   BOO                     NG\n         MVC   WORD+1(2),=C'00'        PUT ZEROS\n         LR    14,0                    COUNT\n         BCTR  14,0                    FOR EX\n         EX    14,MVFR                 MVC   WORD(0),1(PR)\n         LA    0,3                     CV COUNT\n         LA    1,WORD                   PTR\n         BAL   14,DOINT                CV\n         LTR   NR,15                   ANY INTEG COUNT?\n         BNP   NTRSET                  FIN\n         LR    15,0                    SAVE FRAC\n         LR    0,NR                    INTEG COUNT\n         L     1,CPSAVE+4              RESET START PTR\n         B     WHOLDO                  INTEGER LINE NO\n         SPACE\nMVFR     MVC   WORD(0),1(PR)\n         SPACE 3\nDOINT    CL    0,=A(9)                 MAX LEN IS 9\n         BH    BOO                     NG\n         LR    NR,0                    COUNT\n         LR    PR,1                    PTR\nCHNEXT   CLI   0(1),C'0'               TOO SMALL?\n         BL    BOO                     YES\n         CLI   0(1),C'9'               TOO BIG?\n         BH    BOO                     YES\n         LA    1,1(,1)                 NEXT\n         BCT   0,CHNEXT                MORE?\n         BCTR  NR,0                    REDUCE FOR EX OF PACK\n         EX    NR,CHPACK               PACK\n         CVB   0,CPDOUB                CONVERT\n         BR    14                      RETURN\n         SPACE 3\nBOO      SR    RR,RR                    UNSET ROUTINE\n         LH    NR,LEN                  GET LENGTH\n         L     PR,LOC                  GET LOCATION\n         LM    0,1,CPSAVE               PTRS\n         TM    0(SR),FPARM              PARM?\n         L     15,SV15                 SET 15\n         BZ    NXTRY                    NO\nRTNER    STM   0,1,CPSAVE          SET FOR INVALID\n         B     CVNVALID\n         EJECT\n* TERMINAL PROCESSING\n         SPACE\nDONE     LR    1,PR\n         TM    FL,FSQS+FDQS+FPS        COLLECTING STRING?\n         BNZ   ILLSTR                  ERROR IF SO\n         SR    0,0                     ZOT LOC AND LEN\n         SR    1,1\n         MVI   KW,C' '                 CLEAR KW\n         MVC   KW+1(9),KW\n         LTR   RR,RR                   PARM MISSING?\n         BNZ   CVABSENT                BR IF SO\nRTN      STH   NR,LEN                  SAVE LENGTH\n         ST    PR,LOC                  SAVE LOCATION\n         STM   0,1,CPSAVE               SAVE PTRS\n         L     14,RA                   RETURN ADDR\n         LA    15,KW\n         LM    2,12,4(13)\n         LTR   0,0\n         BR    14\n         EJECT\n* CONSTANTS\n         SPACE\nTRT      TRT   0(0,PR),CLTBL           SCAN\nMVT      MVC   KW(0),0(1)              MOVE TOKEN\nCLC      CLC   KW(0),4(SR)             COMPARE KEYWORDS\nCHPACK   PACK  CPDOUB(8),0(0,PR)       PACK INSTR FOR EX\n         EJECT\n* DOUBLE QUOTE SCAN\n         SPACE\nDQSCAN   XENTER 2,12\n         BCTR  0,0                     STRIP OFF OUTER QUOTES\n         BCTR  0,0\n         LR    RR,1                    REMEMBER KIND OF QUOTE\n         LA    1,1(,1)\n         LR    PR,1\n         LTR   NR,0\n         BNP   DQX                     BR IF NO STRING\nDQL      CLC   0(1,PR),0(RR)           QUOTE?\n         BE    QF                      BR IF SO\nDQLL     LA    PR,1(,PR)               NEXT CHAR\n         BCT   NR,DQL\n         LTR   0,0                     COURTESY\nDQX      XEXIT 2,12\n         SPACE\nQF       BCTR  NR,0\n         BCTR  NR,0\n         LTR   NR,NR\n         BM    DQX\n         BCTR  0,0\n         EX    NR,MVSTR                ELIMINATE 2ND QUOTE\n         LA    NR,1(,NR)\n         B     DQLL\n         SPACE 3\nMVSTR    MVC   0(0,PR),1(PR)\n         EJECT\n* TRANSLATE TABLE\n*\n* CLASS TABLE\n         SPACE\nCLTBL    DC    256AL1(4)\n         ORG   CLTBL+X'81'\n         DC    9X'00'\n         ORG   CLTBL+X'91'\n         DC    9X'00'\n         ORG   CLTBL+X'A2'\n         DC    8X'00'\n         ORG   CLTBL+C'A'\n         DC    9X'00'\n         ORG   CLTBL+C'J'\n         DC    9X'00'\n         ORG   CLTBL+C'S'\n         DC    8X'00'\n         ORG   CLTBL+C'0'\n         DC    10X'00'\n         ORG   CLTBL+C'.'\n         DC    X'00'\n         ORG   CLTBL+C'$'\n         DC    X'00'\n         ORG   CLTBL+C'@'\n         DC    X'00'\n         ORG   CLTBL+C'#'\n         DC    X'00'\n         ORG   CLTBL+C'&&'\n         DC    X'00'\n         ORG   CLTBL+C'_'\n         DC    X'00'\n         ORG   CLTBL+C'+'\n         DC    AL1(24)\n         ORG   CLTBL+C'-'\n         DC    AL1(24)\n         ORG   CLTBL+C'*'\n         DC    X'00'\n         ORG   CLTBL+C'\u00a2'              CENT SIGN\n         DC    X'00'\n         ORG   CLTBL+C'!'              EXP. POINT\n         DC    X'00'\n         ORG   CLTBL+C'<'\n         DC    X'00'\n         ORG   CLTBL+C'>'\n         DC    X'00'\n         ORG   CLTBL+C':'\n         DC    X'00'\n         ORG   CLTBL+C';'\n         DC    AL1(28)\n         ORG   CLTBL+C'%'\n         DC    X'00'\n         ORG   CLTBL+C'|'\n         DC    AL1(24)\n         ORG   CLTBL+C'?'\n         DC    X'00'\n         ORG   CLTBL+C''''\n         DC    AL1(8)\n         ORG   CLTBL+C'\"'\n         DC    AL1(12)\n         ORG   CLTBL+C'('\n         DC    AL1(16)\n         ORG   CLTBL+C')'\n         DC    AL1(20)\n         ORG   CLTBL+C'/'\n         DC    AL1(24)\n         ORG   CLTBL+C'\u00ac'              ADD \u00ac TO TRT TABLE\n         DC    AL1(24)\n         ORG\n         EJECT\n         LTORG\n         EJECT\n* SAVE AREA\n         SPACE\nSA       DSECT\n         DS    F\n         DS    (12-2+1)F\nWORD     DS    2F\nSV15     DS    F\nPCNT     DS    H\nFL       DS    X\n         SPACE\nFSQS     EQU   X'80'                   SINGLE QUOTED STRING\nFDQS     EQU   X'40'                   DOUBLE QUOTED STRING\nFPS      EQU   X'20'                   PARENED STRING\n         SPACE 3\nFTBLE    EQU   X'F8'               NEW TABLE POINTER\nFLAST    EQU   X'FF'                   END\nFPARM    EQU   X'80'                   PARM\nFLINNO   EQU   X'60'                   LINE NO. CONV\nFINTEG   EQU   X'40'                   INTEGER 0 OR GTR\nFINTEGP  EQU   X'20'                   INTEGER GTR 0\nFCMSET   EQU   X'10'                   SET 3 COMMAND CHARS\nFLIMIT   EQU   X'10'                   LIMIT\nFABBREV  EQU   X'08'                   ABBREVIATION\n         EJECT\n         COPY  WYLCONST\n         EJECT\n         COMMON\n         EJECT\n* WORK AREA\n         SPACE\n         ORG   CPSCAN\nLOC      DS    F\nLEN      DS    H\nKW       DS    CL8\nPRTSTACK DS    H         RELATIVE POINTER TO PRT STACK\nRA       DS    F\nPRT      DS    F\n         SPACE\n         END\n./ ADD NAME=PSGT,SSI=00000162\n         COPY PMAC\nPSGT     TITLE 'START OF PAGED CODE -- PAGE 36'\nP036     PAGECDE HLOGF,HPOINT,HPOP,HPUT,HRECAT,HRESTR\n      EJECT\n         WIDENT 001\n         USING CPAREA,R12\n         TITLE 'HELP ROUTINES -- PAGE 36'\nPHLOGF   GENTER ,\n         LA    R2,LOGOFBEG\n         LA    R3,LOGOFFIN\n         B     SEND36\nPHPOINT  GENTER ,\n         LA    R2,POINTBEG\n         LA    R3,POINTFIN\n         B     SEND36\nPHPOP    GENTER ,\n         LA    R2,POPBEG\n         LA    R3,POPFIN\n         B     SEND36\nPHPUT    GENTER ,\n         LA    R2,PUTBEG\n         LA    R3,PUTFIN\n         B     SEND36\nPHRECAT  GENTER ,\n         LA    R2,RECATBEG\n         LA    R3,RECATFIN\n         B     SEND36\nPHRESTR  GENTER ,\n         LA    R2,RESTRBEG\n         LA    R3,RESTRFIN\nSEND36   SENDH\n         PRINT NOGEN\nLOGOFBEG HT 'FUNCTION: TERMINATES THE SESSION'\n         HT 'SYNTAX:'\n         HT '          LOGOFF \u00ddCLEAR\u00a8'\n         HT '          SIGNOFF \u00ddCLEAR\u00a8'\n         HT '          LOGOUT \u00ddCLEAR\u00a8'\n         HT 'OPERAND:'\nLOGOFFIN HT 'CLEAR - DELETES THE ACTIVE FILE'\nPOINTBEG HT 'FUNCTION: SIMILAR TO THE LIST COMMAND EXCEPT IT UPDATES TH*\n               E CURRENT'\n         HT '          LINE POINTER'\n         HT 'SYNTAX:'\n         HT '          POINT \u00dd<RANGE>\u00a8 \u00ddEXEC\u00a8 \u00ddNOLIST\u00a8'\n         HT 'OPERANDS:'\n         HT 'EXEC - LISTS THE EXEC FILE AND SETS ITS CURRENT LINE POINT*\n               ER'\n         HT 'NOLIST - SETS THE EXEC FILE CURRENT LINE POINTER WITHOUT L*\n               ISTING ANY'\nPOINTFIN HT '         LINES'\nPOPBEG   HT 'FUNCTION: REMOVES A COMMAND FROM THE TOP OF THE TSO COMMAN*\n               D STACK'\n         HT 'SYNTAX:'\n         HT '         POP \u00ddALL\u00a8'\nPOPFIN   HT 'ALL - EMPTIES THE WHOLE STACK'\nPUTBEG   HT 'FUNCTION: ADDS OUTPUT FROM THE CORRESPONDING SHOW COMMAND *\n               TO THE'\n         HT '  ACTIVE FILE'\n         HT 'SYNTAX:'\n         HT '    PUT \u00bbSPACE|DIRECTORY|DSNAMES\u00ba \u00ddON <VOLUME>\u00a8 \u00ddCLEAR\u00a8 \u00ddA*\n               T <LINE1>\u00a8'\n         HT '        \u00ddBY <LINE2>\u00a8 \u00dd<LIST OPTIONS>\u00a8 \u00dd<SHOW OPTIONS>\u00a8'\n         HT 'OPERANDS:'\n         HT 'AT <LINE1> - TEXT IS ADDED TO ACTIVE FILE BEGINNING AT <LI*\n               NE1>'\n         HT 'BY <LINE2> - LINE NUMBERS OF ADDED TEXT DIFFER BY <LINE2>'\nPUTFIN   HT '<SHOW OPTIONS> - SPACE, DATE, TYPE, ALL.'\nRECATBEG HT 'FUNCTION: CATALOGS THE SPECIFIED DATA SET IN THE SYSTEM CA*\n               TALOG.'\nRECATFIN HT 'SYNTAX:  RECATLG <DSNAME> ON <VOLUME> \u00ddUSER <UUU>\u00a8 \u00ddGROUP *\n               <GG>\u00a8'\nRESTRBEG HT 'FUNCTION: MOVES THE CURRENT EXEC FILE TO THE ACTIVE FILE'\n         HT 'SYNTAX:'\n         HT '          RESTORE \u00ddCLEAR\u00a8'\nRESTRFIN HT 'OPERAND: CLEAR - DELETES THE ACTIVE FILE'\n         PRINT GEN\n         TITLE 'END OF PAGED CODE -- PAGE 36'\n         PINIT\n         PEND\n         TITLE 'START OF PAGED CODE -- PAGE 37'\nP037     PAGECDE HSAVE\n         WIDENT 001\n         USING CPAREA,R12\n         TITLE 'HELP ROUTINES -- PAGE 37'\nPHSAVE   GENTER ,\n         LA    R2,SAVEBEG\n         LA    R3,SAVEFIN\nSEND37   SENDH\n         PRINT NOGEN\nSAVEBEG  HT 'FUNCTION: SAVES THE ACTIVE FILE IN AN EXTERNAL DATA SET'\n         HT 'SYNTAX:'\n         HT '  SAVE <DSNAME> \u00ddUSER <UUU>\u00a8 \u00ddGROUP <GG>\u00a8 \u00ddON <VOLUME|CATL*\n               G\u00a8'\n         HT '     \u00ddNUMBERED|INTEGER\u00a8 \u00ddCATLG|RECATLG|UNCATLG\u00a8 \u00ddCLEAR\u00a8'\n         HT '     \u00ddEDIT|LRECL=<NNN>|CARD|PRINT\u00a8 \u00ddLINES <RANGE>\u00a8 \u00ddSET|NO*\n               SET\u00a8 \u00dd(<N>)\u00a8'\n         HT '     \u00ddSCRATCH|REPLACE\u00a8 \u00ddSEQFLD=(\u00bbEND|<POS>\u00ba\u00dd,<LEN>\u00a8)\u00a8 \u00ddNOP*\n               OINT\u00a8'\n         HT 'OPERANDS:'\n         HT 'CATLG|RECATLG|UNCATLG - CATLG SPECIFIES THAT THE SYSTEM CA*\n               TALOG THE'\n         HT '  DATA SET AFTER IT HAS BEEN SAVED. RECATLG APPLIES WHEN Y*\n               OU WANT'\n         HT '  TO SAVE A DATA SET ON A VOLUME OTHER THAN THE ONE ON WHI*\n               CH IT WAS'\n         HT '  CATALOGED. UNCATLG REMOVES THE ENTRY FOR THE DATA SET FR*\n               OM THE'\n         HT '  SYSTEM CATALOG'\n         HT 'EDIT|LRECL=<NNN>|CARD|PRINT - THE FORMAT OPERAND SPECIFIES*\n                THE FORM'\n         HT '  IN WHICH THE DATA IS TO BE SAVED. EDIT IS THE DEFAULT'\n         HT 'LINES <RANGE> - SAVES THE PORTION OF YOUR ACTIVE FILE SPEC*\n               IFIED BY'\n         HT '  <RANGE>'\n         HT '(<N>) - WHEN NON-EDIT DATA SETS ARE SAVED, IT SPECIFIES TH*\n               E'\n         HT '  BLOCKING FACTOR, THAT IS, THE DATA SET BLKSIZE WILL BE L*\n               RECL*<N>'\n         HT 'NOPOINT - LINE NUMBERS WILL BE PUT IN RECORDS WITHOUT A DE*\n               CIMAL POINT'\n         HT '  OR ZERO SUPPRESSION'\n         HT 'SCRATCH|REPLACE - SPECIFIES THAT THE OLD SEQUENTIAL DATA S*\n               ET IS TO BE'\n         HT '  SCRATCHED BEFORE THE NEW DATA IS SAVED. FOR A PDS MEMBER*\n               , THE NEW'\n         HT '  MEMBER IS ADDED TO THE PDS THEN THE DIRECTORY IS UPDATED*\n               '\nSAVEFIN  HT 'FOR INFO ON OTHER OPERANDS USE THE \"HELP USE\" COMMAND'\n         PRINT GEN\n         TITLE 'END OF PAGED CODE -- PAGE 37'\n         PINIT\n         PEND\n         TITLE 'START OF PAGED CODE -- PAGE 38'\nP038     PAGECDE HRENM,HREP,HSEND,HSCR\n         WIDENT 001\n         USING CPAREA,R12\n         TITLE 'HELP ROUTINES -- PAGE 38'\nPHRENM   GENTER ,\n         LA    R2,RENAMBEG\n         LA    R3,RENAMFIN\n         B     SEND38\nPHREP    GENTER ,\n         LA    R2,REPLBEG\n         LA    R3,REPLFIN\n         B     SEND38\nPHSEND   GENTER ,\n         LA    R2,TOBEG\n         LA    R3,TOFIN\n         B     SEND38\nPHSCR    GENTER ,\n         LA    R2,SCRATBEG\n         LA    R3,SCRATFIN\nSEND38   SENDH\n         PRINT NOGEN\nRENAMBEG HT 'FUNCTION: RENAMES A DATA SET OR PDS MEMBER'\n         HT 'SYNTAX:'\n         HT ' RENAME <DSNAME> \u00ddON <VOLUME>\u00a8 \u00ddUNCAT\u00a8 \u00ddUSER <UUU>\u00a8 \u00ddGROUP*\n                <GG>\u00a8 \u00ddSET\u00a8'\n         HT '         TO <NEW DSNAME> \u00ddON <VOLUME>\u00a8 \u00ddUSER <UUU>\u00a8 \u00ddGROUP*\n                <GG>\u00a8 \u00ddSET\u00a8'\n         HT '         \u00ddCATLG|RECATLG|UNCATLG\u00a8'\n         HT 'OR'\n         HT '  RENAME \u00dd<PDSNAME>\u00a8#<MEMBER> \u00ddON <VOLUME>\u00a8 \u00ddUSER <UUU>\u00a8 \u00dd*\n               GROUP <GG>\u00a8'\nRENAMFIN HT '         \u00bbTO|ALIAS\u00ba <NEW MEMBERNAME> \u00ddON <VOLUME>\u00a8'\nREPLBEG  HT 'FUNCTION: REPLACES THE CONTENTS OF ANY SPECIFIED <RANGE> O*\n               F THE ACTIVE'\n         HT '           FILE'\n         HT 'SYNTAX:  REPLACE <RANGE> \u00dd<LIST OPTIONS>\u00a8 \u00ddDITTO\u00a8'\n         HT 'OPERANDS:'\n         HT 'DITTO - ALL LINES IN <RANGE> REPLACED BY ANSWER TO FIRST P*\n               ROMT.'\nREPLFIN  HT 'LIST - LISTS EACH LINE IN THE <RANGE> BEFORE IT IS REPLACE*\n               D.'\nTOBEG    HT 'FUNCTION: SENDS A MESSAGE TO ANOTHER TERMINAL'\n         HT 'SYNTAX:'\n         HT '          SEND \u00bb<N>|<ID>|<UUU>|OPR\u00ba <MESSAGE>'\n         HT '      OR  TO   \u00bb<N>|<ID>|<UUU>|OPR\u00ba <MESSAGE>'\n         HT 'OPERANDS:'\n         HT '<N>,<ID> - USED AS IN THE SHOW LINE COMMAND.'\n         HT 'OPR - SEND THE <MESSAGE> TO THE OPERATOR''S CONSOLE.'\nTOFIN    HT '<UUU> - USER INITIALS.'\nSCRATBEG HT 'FUNCTION: DELETES ANY EXTERNAL FILE THAT BELONGS TO YOU OR*\n                YOUR GROUP.'\n         HT 'SYNTAX:'\n         HT 'SCRATCH <DSNAME> \u00ddON <VOLUME>|CATLG\u00a8 \u00ddUSER <UUU>\u00a8 \u00ddGROUP <*\n               GG>\u00a8'\n         HT '        \u00ddSET|NOSET\u00a8 \u00ddUNCATLG\u00a8 \u00ddPDS\u00a8'\n         HT 'OPERANDS:'\n         HT 'UNCATLG - UNCATALOGS THE SPECIFIED DATA SET.'\n         HT 'PDS - SCRATCHES THE ENTIRE PARTITIONED DATA SET'\nSCRATFIN HT 'FOR INFO ABOUT OTHER OPERANDS USE THE \"HELP USE\" COMMAND'\n         PRINT GEN\n         TITLE 'END OF PAGED CODE -- PAGE 38'\n         PINIT\n         PEND\n         TITLE 'START OF PAGED CODE -- PAGE 39'\nP039     PAGECDE HSUSP,HUSE\n         WIDENT 001\n         USING CPAREA,R12\n         TITLE 'HELP ROUTINES -- PAGE 39'\nPHSUSP   GENTER ,\n         LA    R2,SUSBEG\n         LA    R3,SUSFIN\n         B     SEND39\nPHUSE    GENTER ,\n         LA    R2,USEBEG\n         LA    R3,USEFIN\nSEND39   SENDH\n         PRINT NOGEN\nSUSBEG   HT 'FUNCTION: ENABLES A USER TO LOGOFF WITHOUT LOSING HIS ACTI*\n               VE WYLBUR'\n         HT '          ENVIRONMENT, (I.E. ACTIVE AND EXEC FILES, PREPRO*\n               CESSOR'\n         HT '          VARIABLE VALUES, ESCAPE CHARACTER, CURRENT LINE *\n               VALUES ETC.)'\n         HT 'SYNTAX:'\nSUSFIN   HT '          SUSPEND'\nUSEBEG   HT 'FUNCTION: READS A COPY OF A DIRECT ACCESS DATA SET INTO YO*\n               UR ACTIVE FILE'\n         HT 'SYNTAX:'\n         HT '  USE <DSNAME> \u00ddUSER <UUU>\u00a8 \u00ddGROUP <GG>\u00a8 \u00ddON <VOLUME>|CATL*\n               G\u00a8'\n         HT '      \u00ddCLEAR\u00a8 \u00ddEDIT|LRECL=<NNN>|CARD|PRINT\u00a8 \u00ddNOPOINT\u00a8 \u00ddNUM*\n               BERED\u00a8'\n         HT '      \u00ddSKIP <MMMM>\u00a8 \u00ddSEQFLD=(\u00bbEND|<POS>\u00ba\u00dd,<LEN>\u00a8)\u00a8 \u00ddSET|NO*\n               SET\u00a8'\n         HT 'OPERANDS:'\n         HT 'CLEAR - CLEARS THE ACTIVE FILE'\n         HT '<DSNAME> - SPECIFIES THE NAME OF THE DATA SET TO BE READ'\n         HT 'GROUP <GG> -- SPECIFIES THAT THE GROUP <GG> IS TO BE USED *\n               IN FORMING THE'\n         HT '  <DSNAME>'\n         HT 'NUMBERED - FOR NON-EDIT DATA SETS, THIS OPTION ASSUMES THA*\n               T EACH RECORD'\n         HT '  HAS A LINE NUMBER IN IT'\n         HT 'SEQFLD - NOTIFIES WYLBUR THAT LINE NUMBERS ARE AT SOME POS*\n               ITION OR'\n         HT '  LENGTH OTHER THAN THE DEFAULT SEQFLD=(END,8)'\n         HT 'SET/NOSET - SET SAVES THE PREFIX AND MEMBER NAMES USED IN *\n               THE COMMAND.'\n         HT '  IF YOU DO NOT WANT THIS TO BE DONE SPECIFY NOSET'\n         HT 'SKIP <MMMM> - THE FIRST <MMMM> RECORDS OF THE DATA SET ARE*\n                TO BE IGNORED'\n         HT '<VOLUME> - SPECIFIES THE NAME OF THE DIRECT ACCESS VOLUME *\n               ON WHICH THE'\n         HT '  DATA SET RESIDES. IF THE DATA SET IS CATALOGED IN THE SY*\n               STEM'\n         HT '  CATALOG YOU MAY SPECIFY <ON CATLG> INSTEAD OF THE <VOLUM*\n               E> NAME'\n         HT 'USER <UUU> -- SPECIFIES THAT THE USER <UUU> IS TO BE USED *\n               IN FORMING THE'\nUSEFIN   HT '  <DSNAME>'\n         PRINT GEN\n         TITLE 'END OF PAGED CODE -- PAGE 39'\n         PINIT\n         PEND\n         TITLE 'START OF PAGED CODE -- PAGE 40'\nP040     PAGECDE HLOAD,HSTACK\n         WIDENT 001\n         USING CPAREA,R12\n         TITLE 'HELP ROUTINES -- PAGE 40'\nPHLOAD   GENTER ,\n         LA    R2,LOADBEG\n         LA    R3,LOADFIN\n         B     SEND40\nPHSTACK  GENTER ,\n         LA    R2,STACKBEG\n         LA    R3,STACKFIN\nSEND40   SENDH\n         PRINT NOGEN\nLOADBEG  HT 'FUNCTION: LOADS THE ACTIVE FILE INTO THE EXEC FILE AND EXE*\n               CUTES IT.'\n         HT '          THE ACTIVE FILE IS NOT CLEARED.'\n         HT 'SYNTAX:'\n         HT ' LOAD \u00dd<RANGE>\u00a8 \u00ddFROM <DSNAME>\u00a8 \u00ddON <VOLUME>|CATLG\u00a8 \u00ddSET|N*\n               OSET\u00a8'\n         HT '      \u00ddSTART <LINENO>\u00a8 \u00ddLOG|NOLOG\u00a8 \u00ddTERSE|VERBOSE\u00a8 \u00ddPAUSE\u00a8*\n                \u00ddCLEAR\u00a8'\n         HT 'OPERANDS:'\nLOADFIN  HT 'FOR INFO ON OPERANDS USE THE \"HELP EXEC\" COMMAND.'\nSTACKBEG HT 'FUNCTION: PUSHES TSO COMMANDS ON A STACK. WHEN THE WYLBUR *\n               SESSION IS'\n         HT '          TERMINATED TSO THEN ACCEPTS COMMANDS FROM THE CO*\n               MMAND STACK.'\n         HT 'SYNTAX:'\nSTACKFIN HT '                            STACK <ANY TSO COMMAND>'\n         PRINT GEN\n         TITLE 'END OF PAGED CODE -- PAGE 40'\n         PINIT\n         PEND\n         TITLE 'START OF PAGED CODE -- PAGE 18'\nP018     PAGECDE STAX,GOTSO,TIME,LSTUSR,PROFIL\n         WIDENT 001\n         USING CPAREA,R12\n         TITLE 'STAX ROUTINE -- PAGE 18'\nPSTAX    GENTER ,\n         LA    R13,CPWA\n         LR    R8,R13              SETUP STACK MECHANISM\n         L     R2,CVIOWA\n         USING WDIOWA,R2\n         LA    R3,WASTAX           STAX WORK AREA\n         SCAN  STAXOPTS            CHECK OPTIONS\n         SPACE\n* WE GET HERE IF NONE SPECIFIED.. DEFUALT TO 'STAX ON'\n* MUST CHECK IF WE ARE IN DEFER MODE.\n         SPACE\nSTAXON   TM    JCBAFL,JCBSTAX      DO WE HAVE A STAX?\n         BO    STAXONX             YES.. ALREADY IN EFFECT\n         XC    WASTAX(4*5),WASTAX  CLEAR STAX PARM LIST\n         L     R14,CVATNRTN\n         STAX  (14),REPLACE=NO,DEFER=NO,USADDR=((R12)),MF=(E,(R3))\n         OI    JCBAFL,JCBSTAX\n         NI    JCBAFL,X'FF'-JCBSTAXD\n         B     CVGETCOM\n         SPACE\nSTAXONX  TSEG  'STAX ALREADY IN EFFECT'\n         B     CVGETCOM\n         SPACE\nSTAXOFF  TM    JCBAFL,JCBSYSPR     HE GOT'EM PRIVS?\n         BZ    CVGETCOM\n         TM    JCBAFL,JCBSTAX      DO WE HAVE A STAX?\n         BZ    TESTDEF             NO .. SEE IF DEFER=YES\n         XC    WASTAX(4*5),WASTAX  CLEAR STAX PARM LIST\n         STAX  ,MF=(E,(R3))\n         NI    JCBAFL,X'FF'-JCBSTAX   TURN FLAG OFF\nTESTDEF  TM    JCBAFL,JCBSTAXD        DEFER?\n         BZ    CVGETCOM\n         XC    WASTAX(4*5),WASTAX  CLEAR STAX PARM LIST\n         STAX  ,DEFER=NO,MF=(E,(R3))\n         NI    JCBAFL,X'FF'-JCBSTAXD\n         B     CVGETCOM\n         SPACE\nSTAXDEFR TM    JCBAFL,JCBSYSPR     PRIV'ED?\n         BZ    CVGETCOM\n         CH    R0,=H'3'            L'YES'\n         BNE   STAXNO\n         CLC   =C'YES',0(R1)\n         BNE   CVNVALID\n         XC    WASTAX(4*5),WASTAX  CLEAR STAX PARM LIST\n         STAX  ,DEFER=YES,MF=(E,(R3))\n         OI    JCBAFL,JCBSTAXD\n         B     CVGETCOM\n         SPACE\nSTAXNO   CH    R0,=H'2'\n         BNE   CVNVALID\n         CLC   =C'NO',0(R1)\n         BNE   CVNVALID\n         XC    WASTAX(4*5),WASTAX  CLEAR STAX PARM LIST\n         STAX  ,DEFER=NO,MF=(E,(R3))\n         NI    JCBAFL,X'FF'-JCBSTAX\n         B     CVGETCOM\n         SPACE\nSTAXINVL B     CVNVALID\n         SPACE\nSTAXOPTS SCKW  ON,STAXON\n         SCKW  OFF,STAXOFF\n         SCKW  DEFER,STAXDEFR,(A,P)\n         SCKW  ,STAXINVL\n         SPACE\n         DROP  R2\n         TITLE 'ATTACH TMP.. GO DOWN ONE LEVEL -- PAGE 18'\nPGOTSO   GENTER ,\n         TM    JCBAFL,JCBSYSPR     PRIVILEGED?\n         BZ    CVNVALID            NO .. EXE BREAK\n*        SLR   R1,R1               CLEAR FOR SVC\n*        SVC   254\n         MODESET KEY=ZERO          GET KEY ZERO\n         LA    R13,CPWA            SAVE AREA\n         SR    R1,R1\n         ST    R1,CPSTART+4\n         LA    R1,CPSTART+4\n         ST    R1,CPSTART\n         MVI   CPSTART,X'80'\n         L     R15,CVIOWA\n         USING WDIOWA,R15\n         LA    R4,WASTAX\n         XC    WASTAX(4*5),WASTAX  CLEAR STAX PARM LIST\n         STAX  ,DEFER=YES,MF=(E,(R4))\n         L     R15,CVIOWA\n         XC    ATTDECB(4),ATTDECB\n         LA    R3,ATTDECB\n         LA    R15,WATTACH\n         LA    R1,CPSTART\n         ATTACH MF=(E,(1)),SF=(E,(15))\n         LTR   R15,R15\n         BNZ   NOTODAY\n         LR    R2,R1\n         WAIT  ECB=(R3)\n         ST    R2,CPSTART\n         DETACH CPSTART\n*        LA    R1,4               CLEAR FOR SVC\n*        SVC   254\n         MODESET KEY=NZERO          GET KEY NZERO\n         L     R15,CVIOWA\n         LA    R4,WASTAX\n         XC    WASTAX(4*5),WASTAX  CLEAR STAX PARM LIST\n         STAX  ,DEFER=NO,MF=(E,(R4))\n         B     CVGETCOM\n         SPACE\nNOTODAY  TSEG  'CAN''T ATTACH THE TMP'\n*        LA    R1,4               CLEAR FOR SVC\n*        SVC   254\n         MODESET KEY=NZERO          GET KEY NZERO\n         L     R15,CVIOWA\n         LA    R4,WASTAX\n         XC    WASTAX(4*5),WASTAX  CLEAR STAX PARM LIST\n         STAX  ,DEFER=NO,MF=(E,(R4))\n         B     CVQTYPE\n         TITLE 'DISPLAY CPU AND SESSION TIME -- PAGE 18'\nPTIME    GENTER ,\n         TIME  BIN\n         CVCALL FMTIME\n         TSEG  (1),(0)\n         CLI   CPCMNM,C'D'\n         BE    CVGETCOM\n         LA    R13,CPWA            SAVE AREA\n         LOAD  EP=IKJEFT25\n         LR    R15,R0\n         L     R6,CVIOWA\n         DROP  R15\n         USING WDIOWA,R6\n         L     R2,WAUPT            USER PROFILE TABLE\n         LTR   R2,R2               ANYTHING?\n         BZ    NOTCP               NOT RUNNING AS A CP\n         ST    R2,CPSTART+4\n         L     R2,WAPSCB           POINT TO THE PSCB\n         ST    R2,CPSTART+8\n         L     R2,WAECT            ECT\n         LTR   R2,R2\n         BZ    NOTCP\n         ST    R2,CPSTART+12\n         LA    R2,CPSTART+16       POINT TO COMMAND BUFF\n         ST    R2,CPSTART\n         MVC   0(4,R2),=X'00040000' INDICATE NULL CMD\n         LA    R1,CPSTART\n         BALR  R14,R15             CALL IT\n         DELETE EP=IKJEFT25\n         B     CVGETCOM\n         SPACE\nNOTCP    TSEG  'WYLBUR IS NOT RUNNING AS A CP'\n         B     CVQTYPE\n         DROP  R6\n         TITLE 'SHO USERS -- PAGE 18'\n         SPACE\nPLSTUSR  GENTER ,\n         L     R6,16              CVT ADDRESS\n         L     R6,1012(R6)      TCAST ADDRES\n         USING TCAST,R6\n*        SLR   R1,R1            FOR SVC\n*        SVC   254\n         MODESET KEY=ZERO\n         LH    R2,TCASUSEC      NUMBER OF USERS\n         SR    R0,R0              FOR THE BTD MACRO\n         BTD   CPDOUB,(0),(2)     CONVERT TO CHARACTERS\n         TSEG  (1),(0),B          PRINT NUMBER OF USERS\n         TSEG  'CURRENT',,B\n         LH    R2,TCASUMAX      MAXIMUM NUMBER OF USERS\n         SR    R0,R0              FOR THE BTD MACRO\n         BTD   CPDOUB,(0),(2)     CONVERT TO CHARACTERS\n         TSEG  (1),(0),B          PRINT NUMBER OF USERS\n         TSEG  'MAX USERS',,W\n         L     R5,TCASTSB               POINTER TO TSB\n         USING TSB,R5\n         SLR   R0,R0              CLEAR FOR DIVIDE\n         SLR   R4,R4              CLEAR FOR DIVIDE\n         IC    R4,CVUSRFLD        LENGTH OF USERID\n         LA    R4,8(,R4)          LENGTH OF ONE ENTRY\n         LA    R1,79              LENGTH OF LINE\n         DR    R0,R4              DIVIDE FOR NUMBER OF USERS PER LINE\n         LR    R4,R1              SET FOR LOOP\n         LR    R6,R4              FOR LATER\nTESTUSER TM    TSBSTAT,TSBINUSE   TSB IN USE\n         BZ    NEXTU              NO GET NEXT\n         L     R3,TSBASCBA        GET ASCBAPOINTER\n         L     R3,176(R3)         POINTER TO USER ID\n         TSEG  (R3),7             PUT IT OUT\n         TSEG  '('\n         TSEG  TSBTRMID,4        TERMINAL ID\n         TSEG  ')',,B\n         BCT   R4,NEXTU           GET NEXT U\n         TWRITE ,                WRITE LINE\n         LR    R4,R6             NUMBER OF USERS PER LINE\nNEXTU    L     R5,TSBEXTNT        NEXT USER\n         ICM   R5,7,1(R5)        TSBXFWD\n         BZ    *+8               ZERO END\n         BCT   R2,TESTUSER       SEE IF SIGNONED\n         CH    R4,=H'4'           NO USERS\n         BE    LSTUEXIT            YES EXIT\n         TWRITE ,\nLSTUEXIT MODESET KEY=NZERO\n*        LA    R1,4            FOR SVC\n*        SVC   254\n         B     CVGETCOM\n         DROP  R5,R6\n         TITLE 'SHO PROFILE -- PAGE 18'\nPPROFIL  GENTER ,\n         L     R6,CVIOWA\n         USING WDIOWA,R6\n         L     R2,WAUPT\n         LTR   R2,R2\n         BZ    CVNVALID\n         DROP  R6\n         TM    12(R2),X'40'\n         BZ    PRMPT\n         TSEG  'NO'\nPRMPT    TSEG  'PROMPT',,B\n         TM    12(R2),X'20'\n         BO    MSGID\n         TSEG  'NO'\nMSGID    TSEG  'MSGID',,B\n         TM    12(R2),X'10'\n         BZ    INTCOM\n         TSEG  'NO'\nINTCOM   TSEG  'INTERCOM',,B\n         TM    12(R2),X'08'\n         BO    PAUSE\n         TSEG  'NO'\nPAUSE    TSEG  'PAUSE',,B\n         CLI   13(R2),X'FF'\n         BNE   CDEL1\n         TSEG  'NOCHAR',,B\n         B     LDEL\nCDEL1    TSEG  'CHAR('\n         CLI   13(R2),X'00'\n         BNE   CDEL2\nCDELBS   TSEG  'BS'\n         B     CDEL9\nCDEL2    CLI   13(R2),X'16'\n         BE    CDELBS\n         TSEG  13(R2),1\nCDEL9    TSEG  ')',,B\nLDEL     TM    12(R2),X'04'\n         BZ    LDEL0\n         TSEG  'LINE('\n         B     LDELATTN\nLDEL0    CLI   14(R2),X'FF'\n         BNE   LDEL1\n         TSEG  'NOLINE',,W\n         B     CVGETCOM\nLDEL1    TSEG  'LINE('\n         CLI   14(R2),X'00'\n         BNE   LDEL2\nLDELATTN TSEG  'ATTN'\n         B     LDEL9\nLDEL2    CLI   14(R2),X'16'\n         BE    LDELATTN\n         CLI   14(R2),X'18'\n         BNE   LDEL3\n         TSEG  'CTLX'\n         B     LDEL9\nLDEL3    TSEG  14(R2),1\nLDEL9    TSEG  ')',,W\n         B     CVGETCOM\n         TITLE 'END OF PAGED CODE -- PAGE 18'\n         PINIT\n         PEND\n         TITLE 'START OF PAGED CODE -- PAGE 17'\nP017     PAGECDE SEND,WHERE,STACK\n         WIDENT 001\n         USING CPAREA,R12\n         TITLE 'SEND A MESSAGE TO A USER -- PAGE 17'\nPSEND    GENTER ,\n         SCAN  USERID\n         B     CVABSENT\n         SPACE\nUSERID   SCKW  OPER,RESETRS\n         SCKW  OPR,RESETRS\n         SCKW  ,USERIDD\nUSERIDD  CH    R0,=H'8'\n         BH    BADID               INVALID .. TOO LONG\nFINDUSE  MVI   CPDOUB,C' '\n         MVC   CPDOUB+1(7),CPDOUB  BLANK OUT FIELD\n         LR    R4,R0\n         BCTR  R4,0                -1 FOR EX\n         EX    R4,MVCID            MOVE ID INTO CPDOUB\n         SPACE\n*        SEARCH THE CSCB CHAIN                                     JJG0\n         L     R3,16               CVT  POINTER                    JJG0\n         USING CVT,R3                                              JJG0\n         L     R3,CVTASVT          ASVT POINTER                    JJG0\n         USING ASVT,R3                                             JJG0\n         L     R6,ASVTMAXU         MAX USERS                       JJG0\nASCBLOOP DS    0H                                                  JJG0\n         TM    ASVTENTY,ASVTAVAL   IS IT AVAILABLE                 JJG0\n         BO    NEXTASCB            YES, GET NEXT ASCB              JJG0\n         ICM   R4,7,ASVTENTY+1     FIRST ASCB                      JJG0\n         BZ    NEXTASCB            YES, GET NEXT ASCB              JJG0\n         USING ASCB,R4                                             JJG0\n         L     R5,ASCBCSCB         CSCB POINTER                    JJG0\n         USING CHAIN,R5                                            JJG0\n         TM    CHACT,CHTERM        TSO USER                        JJG0\n         BZ    NEXTASCB            NO GET NEXT ASCB                JJG0\n         CLC   CHKEY,CPDOUB        USER WE WANT                    JJG0\n         BE    FOUNDHIM            YES FOUND HIM                   JJG0\nNEXTASCB DS    0H                                                  JJG0\n         LA    R3,4(,R3)           NEXT ASVT IF ANY                JJG0\n         BCT   R6,ASCBLOOP         CHECK NEXT                      JJG0\nNOUSER   TSEG  (1),(0)             ECHO THE USER ID\n         TSEG  ': NOT LOGGED ON'\n         B     CVQTYPE\n         SPACE\nMVCID    MVC   CPDOUB(0),0(R1)\nFOUNDHIM SCTELL ,                  GET MSG\n         LH    R3,CHTJID           GET TJID ASID                   JJG0\n         SLL   R3,16               MOVE INTO HIGH ORDER 2 BYTES\n         XR    R2,R2              ZERO THE REG\n         IC    R2,CVUSRFLD        PICK UP ID LEN\n         MVC   CPWA(5),=C'FROM '\n         MVC   CPWA+5(0),CPUSER   MOVE IN USERID\n         EX    R2,*-6             EXECUTE THE ABOVE MOVE\n         LA    R2,CPWA+6(R2)      CURRENT OFFSET\n         MVC   0(2,R2),=C': '     MAKE IT PRETTY\n         LA    R2,2(R2)           CURRENT OFFSET\n         LR    R15,R2             SAVE IN R15\n         LTR   R2,R0              LEN OF MSG TO R2\n         BNP   NULLMSG            SENDING BLANK LINE\n         BCTR  R2,0               DOWN 1 FOR IBM\n         EX    R2,MOVEMSG         MOVE IN THE MSG\n         IC    R2,CVUSRFLD        PICK UP THE ID LEN\n         LA    R2,8(R2)           PLUS GARBAGE+1 ON ID =\n         AR    R0,R2              TRUE LENGTH OF THE MSG\nPUT3277  LA    R1,CPWA            POINT TO MSG LOC\n         LR    R2,R3              RECEIVING USERID\n         LR    R4,R0              PRESERVE COUNT\n         OR    R0,R2              OR IN TJID FOR TPUT\n         O     R1,=XL4'00000000'  ENSURE EDIT, WAIT ON 3277'S\n         TPUT  (1),(0),R          REG FORM OF TPUT\n         B     RTNCHK\nMSGADDR  LA    R1,CPWA\n         LR    R2,R3\n         LR    R4,R0\n         OR    R2,R0\n         O     R1,=X'12000000'    INDICATED CONTROL\n         TPUT  (R1),(R0),R        TELL USER\nRTNCHK   LA    R8,CPWA+4(R4)                                    J\n         SRL   R8,2\n         SLL   R8,2\n         LR    R13,R8\n         LTR   R15,R15             ANYTHING UNUSUAL?\n         BZ    CVGETCOM\n         CH    R15,=H'4'           NO MORE BUFFS?\n         BE    EOBUFFS             YEP\n         CH    R15,=H'12'          MSGOFF?\n         BE    MSGOFF\n         SPACE\n* UNKNOWN RETURN CODE .. MSG UNSENT\n         LR    R5,R15\n         TSEG  NOTSENT,L'NOTSENT\n         MVC   CPWA(L'NOTSENT),NOTSENT\n         LR    R15,R5\n         SR    R0,R0               CLEAR LENGTH INDICATOR\n         LA    R1,CPWA+L'NOTSENT\n         LA    R8,CPWA+(L'NOTSENT+16)/4*4\n         CVCALL BTD\n         TSEG  (1),(0)\n         TSEG  ')'\n         B     CVQTYPE\nNOTSENT  DC    C'MESSAGE NOT SENT (RC='\nMSGOFF   TSEG  'USER DOES NOT WANT MESSAGES NOW'\n         B     CVQTYPE\n         SPACE\nEOBUFFS  TSEG  'NO BUFFERS AVAILABLE FOR MESSAGE',,W\n         SYSQS 1,0,'RETRY'\n         CVCALL YESREQ\n         B     MSGADDR\n         SPACE\nMOVEMSG  MVC   0(0,R15),0(R1)\nFROMID   DC    0C'CLCLFROM '\n         DC    X'0D250D25',C'FROM '\n         SPACE\nNULLMSG  LA    R0,L'FROMID+10\n         B     PUT3277            YES...GO DO 3277 TPUT\n         SPACE\nBADID    TSEG  'USER ID MUST BE 8 CHARACTERS OR LESS'\n         B     CVQTYPE\n         SPACE\nRESETRS  SCTELL ,\n         LTR   R2,R0               ANY MSG?\n         BNP   NULLOPR\n         BCTR  R2,0                -1 FOR EXECUTE\n         EX    R2,OPRMVC\n         LA    R3,CPWA+1+4(R2)\n         MVI   0(R3),C' '\n         MVC   1(5,R3),CPUSER\n         LA    R2,11(,R2)          INCLUDE USER ID\n         STH   R2,CPWA\n         SR    R0,R0\n         STH   R2,CPWA+2\n         LA    R1,CPWA\n         WTO   MF=(E,(1))\n         B     CVGETCOM\nNULLOPR  TSEG  'MESSAGE TO OPERATOR NOT SPECIFIED'\n         B     CVQTYPE\n         SPACE\nOPRMVC   MVC   CPWA+4(0),0(R1)\n         B     CVQTYPE\n             DROP  R3,R4,R5\n         TITLE 'WHERE ROUTINE -- PAGE 17'\nPWHERE   GENTER ,\n         TM    JCBAFL,JCBSYSPR     IS HE PRIVED>\n         BNO   CVNVALID\n         SCAN  WHERETAB\n         B     CVABSENT\n         SPACE\nWCP      LA    R3,CPSTART\n         B     DISPLAY\n         SPACE\nWCV      LA    R3,CVSTART\n         B     DISPLAY\n         SPACE\nWDIREC   LA    R3,CPDREC\n         B     DISPLAY\n         SPACE\nWCVT     L     R3,16               GET CVT POINTER\n         B     DISPLAY             DISPLAY IT\n         SPACE\nWROUTB   LA    R3,ROUTBLE\n         SPACE\nDISPLAY  TSEG  'ADRESS:',,B\n         BTX   CPDOUB,6,(R3)\n         TSEG  (1),(0),W\n         B     CVGETCOM\n         SPACE\nWHERETAB SCKW  CP,WCP\n         SCKW  CV,WCV\n         SCKW  DIRECTORY,WDIREC,A\n         SCKW  ROUTBLE,WROUTB,A\n         SCKW  ,POPINV\n         TITLE 'STACK AND POP COMMANDS -- PAGE 17'\nPSTACK   GENTER ,\n         L     R3,JCBWAPTR\n         L     R6,CVIOWA\n         USING WDIOWA,R6\n         L     R2,WAUPT\n         LTR   R2,R2\n         BZ    CVNVALID\n         ST    R2,16(,R3)        AT IOPL + 0 = UPT\n         L     R2,WAECT\n         DROP  R6\n         LTR   R2,R2\n         BZ    CVNVALID\n         ST    R2,20(,R3)        AT IOPL + 4 = ECT\n         LA    R2,8(,R3)\n         ST    R2,24(,R3)        AT IOPL + 8 = ECB\n         ST    R3,28(,R3)        AT IOPL +12 = STPB\n         CLI   CPCMNM,C'P'       CAN IT BE A POP COMMAND?\n         BE    GOPOP             YES, GO POP STACK\n         SCTELL ,                GO GET REST OF COMMAND\n         LTR   R4,R0             WAS THERE ANYTHING?\n         BNH   CVABSENT          NO MISSING OPERAND\n         LR    R2,R1             R2 CONTAINS OPERAND @\n         AH    R0,=H'16'         ADD 16 MORE FOR IOPL\n         O     R0,=XL4'4E000000' SUBPOOL 78 SAYS TSO\n         GETMAIN R,LV=(0)\n         LR    R5,R1             IOPL ADDRESS\n         STH   R4,6(,R5)         AT IOPL + 6 = TOTAL LENGTH\n         STH   R4,4(,R5)         AT IOPL + 4 = RECORD LENGTH\n         LA    R6,16(,R5)        IN-CORE LIST ADDRESS\n         ST    R6,0(,R5)         AT IOPL + 0 = IN-CORE LIST @\n         ST    R6,8(,R5)         AT IOPL + 8 = IN-CORE LIST @\n         BCTR  R4,0\n         EX    R4,STKCMND        FILL IN-CORE LIST\n         XC    12(4,5),12(5)     AT IOPL + 12 = RESERVED\n         ST    R5,4(,R3)            AT STPB + 4 = IOPL\n         MVC   0(4,R3),=X'80400000' AT STPB + 0 = FLAGS\nEXSTACK  LA    R1,16(,R3)          POINT TO IOPL\n         SR    R15,R15\n         ST    R15,4(,R13)\n         MVC   8(8,R13),=CL8'IKJSTCK'\n         LA    R15,8(,R13)\n         ST    R15,0(,R13)\n         LR    R15,R13\n         LA    R13,16(,R13)\n*        STACK MF=(E,(1))\n         SVC   6\n         B     CVGETCOM\n         SPACE\nSTKCMND  MVC   0(0,R6),0(R2)\n         SPACE 3\nGOPOP    XC    0(8,R3),0(R3)      CLEAR THE STPB\n         MVI   0(R3),X'10'        ASSUME DELETE ALL\n         SCAN  POPPRT\n         MVI   0(R3),X'40'        DELETE TOP ELEMENT\n         B     EXSTACK            GO ISSUE STACK MACRO\n         SPACE\nPOPINV   B     CVNVALID           INVALID PARAMETER\n         SPACE\nPOPPRT   SCKW  ALL,EXSTACK\n         SCKW  ,POPINV\n         TITLE 'END OF PAGED CODE -- PAGE 17'\n         PINIT\n         PEND\n         TITLE 'START OF PAGED CODE -- PAGE 16'\nP016     PAGECDE SUSPND,LGOFF\n         WIDENT 001\n         USING CPAREA,R12\n         TITLE 'SUSPEND COMMAND -- PAGE 16'\n* SUSPEND SESSION.. IE... WRITE OUT ALL MARKED PAGES\n* THEN DUMP THE CP AND CVP TO PAGE 0 & 1 RESPECTIVELY\n         SPACE\nPSUSPND  GENTER ,\n         L     R3,CVFPFCB\n         L     R2,CVFPAGE          POINT TO PCB\n         USING PFCB,R3\n         USING PCB,R2\nPCBLOOP  TM    PCBFL,PCBFMARK      PAGE ALTERED?\n         BZ    NEXTPCB\n         LH    R1,PCBPN            GET PAGE #\n         MVI   PCBRWCCW,PIOWRITE   INDICATE WRITE\n         CVCALL PIO                GO WRITE OUT THE PAGE\nNEXTPCB  L     R4,PCBPT            POINTER TO PT ENTRY\n         LTR   R4,R4               ANY?\n         BZ    *+8\n         MVI   0(R4),X'00'         PAGE NOT IN CORE\n         LA    R2,PCBSIZE(,R2)     NEXT PCB\n         C     R2,CVLPAGE\n         BL    PCBLOOP\n         SPACE\n* WE WILL FILL UP A PAGE BY GOOD STUFF THEN WRITE IT OUT\n         L     R2,CVFPAGE          POINT TO A PCB\n         L     R4,JCBWAPTR         A BUFFER ADDRESS\n         ST    R4,PCBRWCCW         PUT IT AS DATA ADDRESS\n         MVC   0(8,R4),=CL8'SUSPEND'\n         MVC   8(4,R4),PFCBCP      CURRENT PAGES USED\n         MVC   12(4,R4),CPRSCNVL   RESCAN ESC SKIP CHARS\n         MVC   16(4,R4),CPEXLNET   SAVE EXEC LINE POINTER\n         MVC   20(12,R4),CVEXTRAP  EXEC TRAP AND UPDATE CNT\n         LA    R4,32(,R4)          MORE TO WRITE\n         MVC   0(RTBSIZE-RTBNTEXT,R4),RTBSTART RTB INFO\n         LA    R4,RTBSIZE-RTBNTEXT(,R4)\n         MVC   0(CPRCVSZ1,R4),CPGLDL           CP INFO\n         LA    R4,CPRCVSZ1(,R4)\n         MVC   0(CPRCVSZ2,R4),CPDRPT           MORE CP INFO\n         LA    R4,CPRCVSZ2(,R4)\n         LR    R0,R2              SAVE ACROSS MVCL\n         LR    R1,R3              SAVE ACROSS MVCL\n         LR    R2,R4                           FOR MVCL\n         LA    R3,CPRCVSZ3                     LENGTH\n         LA    R14,CPDREC                      FROM\n         LR    R15,R3                          SAME LENGTH\n         MVCL  R2,R14                          MOVE IT\n*        MVC   0(CPRCVSZ3,R4),CPDREC           1ST PART OF DIREC\n         LA    R4,CPRCVSZ3(,R4)\n         LR    R2,R4                           FOR MVCL\n         LA    R3,ROUTBLEN                     LENGTH\n         LA    R14,ROUTBLE                     FROM\n         LR    R15,R3                          SAME LENGTH\n         MVCL  R2,R14                          MOVE IT\n         LR    R2,R0              RESTORE ACROSS MVCL\n         LR    R3,R1              RESTORE ACROSS MVCL\n*        MVC   0(256,R4),ROUTBLE\n*        MVC   256(ROUTBLEN-256,R4),256+ROUTBLE\n         LA    R4,ROUTBLEN(,R4)\n         L     R5,RTBWAPTR\n         MVC   0(256,R4),0(R5)                 TERMINAL INFO\n         LA    R4,256(,R4)\n         SLR   R1,R1               PAGE 0\n         ST    R3,PCBPFCB          PUT IN PFCB IT BELONGS TO\n         MVI   PCBRWCCW,PIOWRITE   INDICATE WRITE\n         CVCALL PIO\n*        L     R5,PFCBPTST\n*        MVC   0(256,R4),0(R5)                 PART 1 OF PT\n*        MVC   256(256,R4),256(R5)             PART 2 OF PT\n*        MVC   512(88,R4),512(R5)              LAST PART OF PT\n         LR    R0,R2                  SAVE\n         LR    R1,R3                   ACROSS MVCL\n         L     R14,JCBWAPTR           GET BUFFER\n         ST    R14,PCBRWCCW           SAVE IT\n         L     R2,PFCBPTST            BEGINNING OF PAGE TABLE\n         LA    R3,&PAGE0              MAX NUMBER OF PAGES\n         LR    R15,R3                 SAME LENGTH\n         MVCL  R14,R2                 MOVE IT\n         LR    R2,R0              RESTORE ACROSS MVCL\n         LR    R3,R1              RESTORE ACROSS MVCL\n         LA    R1,1                PAGE 1\n         ST    R3,PCBPFCB          PUT IN PFCB IT BELONGS TO\n         MVI   PCBRWCCW,PIOWRITE   INDICATE WRITE\n         CVCALL PIO\n         SPACE\n* WE CAN WRITE OUT THE CP2 AND VCP BY MAKING THE ADDR FIELD\n* OF THE WRITE CCW POINT TO THOSE TWO.\n         LA    R1,CPAREA+CPSIZE    SECOND CP\n         ST    R1,PCBRWCCW         SAVE ADDR IN CCW\n         MVI   PCBRWCCW,PIOWRITE   RESTORE OPCODE\n         LA    R1,2                PAGE 2\n         CVCALL PIO                GO WRITE IT OUT\n         L     R4,CVCPADDR         ADDRES OF VCP\n         ST    R4,PCBRWCCW\n         LA    R1,3                VCP GOES OUT ON PAGE # 3\n         MVI   PCBRWCCW,PIOWRITE   RESTORE OP CODE\n         CVCALL PIO\n         B     CHKSTX              RETURN ALMOST LIKE LOGOFF\n         TITLE 'LOGOFF PROCESSING -- PAGE 16'\nPLGOFF   GENTER ,\n         SCAN  CLRLIST\n         CVCALL CLEARCK            CLEAR ACTIVE\n         LA    R4,CPAREA+CPSIZE    WRITE OUT PAGE 0 SO THAT...\n         L     R3,CVFPFCB          NEXT TIME WYLBUR IS CALLED...\n         L     R2,CVFPAGE          IT DOES NOT TRY RECOVERY...\n         ST    R4,PCBRWCCW         SO... POINT TO ANY GOOD OLD...\n         SR    R1,R1               DATA AND WRITE IT OUT.\n         ST    R3,PCBPFCB\n         MVI   PCBRWCCW,PIOWRITE\n         CVCALL PIO\n         DROP  R2\nCHKSTX   TM    JCBAFL,JCBSTAX     DO WE HAVE A STAX GOING?\n         BZ    GOHOME\n         STAX  ,\nGOHOME   L     R13,CVRETURN\n         LM    R14,R12,12(R13)\n         SR    R15,R15\n         BR    R14                RETURN TO CALLER\n         SPACE\nLINVALID B     CVNVALID\n         SPACE\nCLRLIST  SCKW  CLEAR,CLRACT,A\n         SCKW  CLR,CLRACT\n         SCKW  ,LINVALID\n         SPACE\nCLRACT   OI    CPLFLG2,CPFCLEAR    INDICATE CLR ACTIVE\n         BR    R14                 RETURN\n         TITLE 'END OF PAGED CODE -- PAGE 16'\n         PINIT\n         PEND\n         PRINT OFF\n         TITLE 'CONSTANTS, ETC.'\n         COPY  WYLCONST\n         EJECT\n         COMMON ,\n         EJECT\nPFCB     DSECT\n         COPY  PFCBTSO\n         EJECT\nPCB      DSECT\n         COPY  PCBTSO\n         EJECT\nWDIOWA   WDIOWA DSECT\n         EJECT\nCVT      DSECT\n         CVT   SYS=VMS\n         EJECT\n         IHAASCB\n         EJECT\n         IHAASVT\n         EJECT\n         IEECHAIN\n         EJECT\n         IKTTCAST\n         PRINT ON\n         EJECT\n         IKJTSB    LIST=YES\n         END\n./ ADD NAME=PTSO,SSI=00000002\nPTSO     TITLE 'START OF PAGED CODE -- PAGE 19'\n* PROPERTY OF C. U. C. C. A.\n         SPACE 3\nP019     PAGECDE HELP,HCRT\n         WIDENT 001\n         USING CPAREA,R12\n         TITLE 'HELP ROUTINE -- PAGE 19'\nPHELP    GENTER ,\n         SCAN  HELPTBL            SCAN KEYWORDS\n         SPACE ,\n         LA    R2,HBEG            SET UP REGS FOR\n         LA    R3,HFIN            SENDH MACRO CALL\n         B     SEND19\n         SPACE 3\n*        REG 2 IS SET TO THE ADDRESS OF COMMAND TABLE\n*        REG 3 IS SET TO THE NUMBER OF COMMANDS\n*        REG 4 IS SET TO THE ADDRESS OF LAST COMMAND IN COMMAND TABLE\n         SPACE ,\nHCOMMAND TSEG  'FOLLOWING COMMANDS ARE AVAILABLE:',,W\n         BP    CVQTYPE\nNXTLINE  LA    R4,8               8 COMMANDS PER TERMINAL LINE\nPUTBUF   TSEG  (2),8,B            ADD TO TERMINAL BUFFER\n         LA    R2,16(,R2)         ADDRESS OF NEXT COMMAND\n         BCT   R3,*+8             IF R3>0 CONTINUE LISTING COMMANDS\n         B     CVGETCOM           END OF COMMANDS\n         BCT   R4,PUTBUF          BR TO CONTINUE FILLING TERMINAL L\n         TWRITE ,                 SEND LINE\n         BP    CVQTYPE            ATTN WAS HIT ABORT & GET NEXT COMD\n         B     NXTLINE\nHDSN     PCALL HDSN\nHINV     B     CVNVALID\nOPNDSRCH CH    R0,=H'8'        TOO LONG A COMMAND?\n         BH    CVNVALID        YES.\n         ST    R2,0(,13)\n         ST    R4,4(,13)       SAVE ADR OF LAST ENTRY OF COMAND TABLE\n         LR    R5,R0           GET LENGTH OF COMMAND\n         BCTR  R5,R0           GUESS WHY\n         LA    R6,1            TO PROPAGATE A 1 BIT\n         SLL   R6,0(R5)        TO FORM A LENGTH MASK\n         L     R2,=F'-1'\n         LA    R3,1(,R3)\nOPNLOOP  LA    R4,0(R2,R3)\n         SRL   R4,1            DIVIDE BY 2\n         SLL   R4,4            MULTIPLY BY 16\n         A     R4,0(,13)       POINT TO ENTRY\n         EX    R5,CLC          SEE WHETHER TO GO UP OR DOWN\n         BL    CMDLESS\n         BH    CMDHIGH\n         EX    R6,TMABREV      IS THIS ABBREV OK?\n         BO    FOUNDIT\n         LR    R14,R4          KEEP THE CURRENT POINTER\nGOBACK   S     R4,=F'16'       BACK UP AN ENTRY\n         C     R4,0(,13)\n         BL    FORWARDX\n         EX    R5,CLC          IS THIS A GOOD ONE?\n         BNE   FORWARDX\n         EX    R6,TMABREV      A GOOD ABBREV?\n         BO    FOUNDIT\n         B     GOBACK          KEEP BACKING UP\n         SPACE\nFORWARDX LR    R4,R14          RESTORE PONTER\nFORWARD  LA    R4,16(,R4)      STEP UP\n         C     R4,4(,13)\n         BH    CVNVALID\n         EX    R5,CLC          IS IT THIS ONE?\n         BNE   CVNVALID\n         EX    R6,TMABREV      GOOD ABREV?\n         BO    FOUNDIT\n         B     FORWARD\n         SPACE\nFOUNDIT  LA    R14,8(,R4)     FIND WHERE TO GO\n         B     CVROUTGT\n         SPACE\nCMDLESS  LA    R2,0(R2,R3)\n         SRL   R2,1\nISITOPD  LA    R15,1(,R2)\n         CR    R15,R3\n         BL    OPNLOOP\n         B     CVNVALID\n         SPACE\nCMDHIGH  LA    R3,0(R2,R3)\n         SRL   R3,1\n         B     ISITOPD\n         SPACE\nCLC      CLC   0(0,R4),0(R1)\n         SPACE\nTMABREV  TM    12(R4),X'00'\nPHCRT    GENTER ,\n         LA    R2,CRTBEG\n         LA    R3,CRTFIN\n         B     SEND19\nCMDRET   LA    R2,CMDBEG\n         LA    R3,CMDFIN\nSEND19   SENDH\n         PRINT NOGEN\nHBEG     HT 'Type HELP HELP for info about using the HELP COMMAND.'\nHFIN     HT 'For further help call Vace Kundakci at X-3618'\nCRTBEG   HT 'CRT|NOCRT- WHEN NOCRT IS IN EFFECT AND A LISTING OF RANGE *\n               LONGER THAN'\n         HT '  THE SCREEN SIZE IS BEING DONE, THE LISTING WILL FLOW OFF*\n                THE TOP OF'\n         HT '  THE SCREEN UNTIL THE LISTING IS OVER. HOWEVER, WHEN CRT *\n               IS IN EFFECT A'\n         HT '  LISTING WILL PAUSE WHEN THE SCREEN HAS BEEN FILLED AND W*\n               YLBUR WILL'\n         HT '  PROMPT WITH A COLON. YOU MAY RESPOND WITH ANY OF THE FOL*\n               LOWING:'\n         HT '  (CR)- THE SCREEN IS ERASED, LISTING CONTINUES UNTIL THE *\n               SCREEN'\n         HT '    IS FILLED AGAIN'\n         HT '  (ATTN) - THE COMMAND IS ABORTED'\n         HT '  (CTRL) \"E\" - SAME AS (CR) EXCEPT THE SCREEN IS NOT CLEAR*\n               ED FIRST'\n         HT '    3-DIGIT-NUMBER, FOLLOWED BY (CR) OR (CTRL) \"E\" - THIS *\n               WILL'\nCRTFIN   HT '    CONTINUE LISTING THAT NUMBER OF LINES BEFORE THE NEXT *\n               PROMPT'\nCMDBEG   HT 'Function: modifies and reissues the last command typed to *\n               WYLBUR'\n         HT 'Syntax: \"$\" followed by CARRIAGE RETURN'\nCMDFIN   HT '     or \"$\" followed by ATTENTION'\n         PRINT GEN\nHELPTBL  SCKW  ALL,HCOMMAND\n         SCKW  $,CMDRET\n         SCKW  DSN,HDSN\n         SCKW  ,OPNDSRCH,S\n         SCKW  ,HINV\n         TITLE 'END OF PAGED CODE -- PAGE 19'\n         PINIT\n         PEND\n         TITLE 'START OF PAGED CODE -- PAGE 14'\nP014     PAGECDE HDSN,HSHOW,NOHELP\n         WIDENT 001\n         USING CPAREA,R12\n         TITLE 'HELP ROUTINES -- PAGE 14'\nPHDSN    GENTER ,\n         LA    R2,BEGDSN                 SET UP REGS FOR\n         LA    R3,DSNFIN          SENDH MACRO CALL\nSENDIT   SENDH\nPHSHOW   GENTER ,\n         LA    R2,SHOWBEG\n         LA    R3,SHOWFIN\n         B     SENDIT\nPNOHELP  GENTER ,\n         LA    R2,NOHELBEG        SET UP REGS FOR\n         LR    R3,R2              SENH MACRO CALL\n         B     SENDIT\n         PRINT NOGEN\nNOHELBEG HT 'NO HELP AVAILABLE '\nBEGDSN   HT 'WYLBUR DATASET NAMING CONVENTIONS:'\n         HT '   A SEQUENTIAL DATASET NAME IS OF THE FORM'\n         HT '                            WYL.GG.UUU.FILE1'\n         HT '                     OR     @GG.&&UUU.FILE1'\n         HT '                     OR     FILE1 USER UUU GROUP GG'\n         HT 'WHERE GG IS THE GROUP NAME, UUU IS THE USER INITIALS AND \"*\n               FILE1\" IS THE'\n         HT 'USER GIVEN NAME (8 OR LESS CHARACTERS).'\n         HT '   A PARTITIONED DATASET (PDS) NAME IS OF THE FORM'\n         HT '                             WYL.GG.UUU.LIB#RECORD'\n         HT '                     OR      @GG.&&UUU.LIB#RECORD'\n         HT '                     OR      LIB#RECORD USER UUU GROUP GG'\n         HT 'WHERE GG AND UUU ARE AS ABOVE, \"LIB\" IS THE LIBRARY NAME A*\n               ND \"RECORD\" IS'\n         HT 'THE USER GIVEN MEMBER NAME (8 OR LESS CHARACTERS). THE MEM*\n               BER NAME CAN'\n         HT 'ALSO BE ENCLOSED IN PARENTHESES.  EVERY DATASET NAME MUST *\n               BE ACCOMPANIED'\n         HT 'BY THE VOLUME NUMBER ON WHICH THE DATASET RESIDES OTHERWIS*\n               E, YOU MUST'\nDSNFIN   HT 'SPECIFY \"ON CATLG\"'\nSHOWBEG  HT 'SHOW OPTIONS - CASE,CATLG,COLUMNS,DATE,DIRECTORY,DSNAMES,L*\n               INESIZE,'\nSHOWFIN  HT '  PAGES,SIZE,SPACE,TIME,TRACKS,USERS,VOLUMES'\n         PRINT GEN\n         TITLE 'END OF PAGED CODE -- PAGE 14'\n         PINIT\n         PEND\n         TITLE 'START OF PAGED CODE -- PAGE 03'\nP003     PAGECDE HHELP\n         WIDENT 001\n         USING CPAREA,R12\n         TITLE 'HELP ROUTINES -- PAGE 03'\nPHHELP   GENTER ,\n         LA    R2,HELPBEG         SET UP REGS FOR\n         LA    R3,HELPFIN         SENDH MACRO CALL\nSEND03   SENDH\n         PRINT NOGEN\nHELPBEG  HT 'FUNCTION: GIVES INFO ON USING HELP COMMAND'\n         HT 'SYNTAX:   HELP \u00ddCOMMANDS|ALL|DSN|$|<WYLBUR COMMAND>\u00a8'\n         HT 'OPERANDS:'\n         HT '$ - COMMAND RETRY'\n         HT 'DSN - GIVES INFO ON WYLBUR DATA SET NAMING CONVENTIONS'\n         HT 'COMMANDS,ALL - GIVES A LIST OF AVAILABLE WYLBUR COMMANDS. *\n               SOME COMMANDS'\n         HT '  ARE PRIVILEDGED'\n         HT '<WYLBUR COMMAND> - GIVES INFO ABOUT THE FUNCTION, SYNTAX A*\n               ND'\n         HT '  OPERANDS OF THE SPECIFIED WYLBUR COMMAND'\n         HT 'SYNTAX INTERPRETATION:'\n         HT '1) OPERANDS ENCLOSED IN POINTED BRACKETS <...> HAVE USER-S*\n               UPPLIED VALUES'\n         HT '2) OPTIONAL PHRASES ARE ENCLOSED IN SQUARE BRACKETS  \u00dd...\u00a8*\n               '\n         HT '3) ALTERNATE CHOICES ARE SEPARATED BY A | SYMBOL AND ARE E*\n               NCLOSED IN'\n         HT '   SQUARE BRACKETS IF THE ENTIRE PHRASE IS OPTIONAL OR IN'\n         HT '   BRACES \u00bb...\u00ba IF ONE OF THE OPTIONS MUST BE SELECTED'\n         HT 'COMMON OPERANDS:'\n         HT '<RANGE> -'\n         HT '  EXPLICIT - <LINE NUMBER>/<LINE NUMBER>'\n         HT '  ASSOCIATIVE - CHARACTER STRING ENCLOSED IN QUOTES OR APO*\n               STROPHES'\n         HT '    E.G. \"$\",<$> FINDS ALL LINES WHICH CONTAIN $'\n         HT '         \u00ac\"$\" FINDS ALL LINES WHICH DO NOT CONTAIN $'\n         HT '         \"$\"(5) FINDS THE 5TH OCCURRENCE OF $ IN A FILE'\n         HT '         \"$\"14/20 SEARCHES COLUMNS 14-20 INCLUSIVE FOR $'\n         HT '         \"$\"1 FINDS LINES WHICH HAVE A $ IN THE 1ST COLUMN*\n               '\n         HT '<LIST OPTIONS> -'\n         HT '  INTEGER - LIKE LIST OPTION BUT LINE NUMBERS REPLACED BY *\n               EIGHT DECIMAL'\n         HT '    INTEGERS'\n         HT '  LIST - LISTS LINES AND THEIR LINE NUMBERS'\n         HT '  NOLIST - SUPRESSES LISTING'\n         HT '  NONUMBERED,TEXT - LISTS LINES WITHOUT LINE NUMBERS'\n         HT '  NOTEXT - LISTS LINE NUMBERS WITHOUT TEXT'\nHELPFIN  HT '  UNNUMBERED - LIKE NONUMBERED OPTION BUT TEXT IS SHIFTED *\n               TO THE LEFT'\n         PRINT GEN\n         TITLE 'END OF PAGED CODE -- PAGE 03'\n         PINIT\n         PEND\n         TITLE 'START OF PAGED CODE -- PAGE 05'\nP005     PAGECDE HCOLCT,HIF,HTSO,HUNCAT\n         WIDENT 001\n         USING CPAREA,R12\n         TITLE 'HELP ROUTINES -- PAGE 05'\nPHCOLCT  GENTER ,\n         LA    R2,COLTBEG\n         LA    R3,COLTFIN\n         B     SEND05\nPHIF     GENTER ,\n         LA    R2,IFBEG\n         LA    R3,IFFIN\n         B     SEND05\nPHTSO    GENTER ,\n         LA    R2,TSOBEG\n         LA    R3,TSOFIN\n         B     SEND05\nPHUNCAT  GENTER ,\n         LA    R2,UNCATBEG\n         LA    R3,UNCATFIN\nSEND05   SENDH\n         PRINT NOGEN\nUNCATBEG HT 'FUNCTION: UNCATALOGS THE SPECIFIED DATA SET'\n         HT 'SYNTAX:'\n         HT '          UNCATLG <DSNAME> \u00ddUSER <UUU>\u00a8 \u00ddGROUP <GG>\u00a8'\nUNCATFIN HT 'FOR INFO ON OPERANDS USE THE \"HELP USE\" COMMAND'\nCOLTBEG  HT 'FUNCTION: ADDS LINES TO THE ACTIVE FILE'\n         HT 'SYNTAX:   COLLECT \u00dd<LINE1>|END\u00a8 \u00ddBY <LINE2>\u00a8 \u00ddMERGE\u00a8 \u00dd<LIS*\n               T OPTIONS>\u00a8'\n         HT '                  \u00ddCLEAR\u00a8'\n         HT 'OPERANDS:'\n         HT 'BY <LINE2> - DIFFERENCE BETWEEN SUCCESSIVE LINE NUMBERS IS*\n                <LINE2>. THE'\n         HT '  DEFAULT IS 1.000'\n         HT 'CLEAR - CLEARS THE ACTIVE FILE'\n         HT '<LINE1>|END - FIRST LINE COLLECTED AT <LINE1>. END IS THE *\n               DEFAULT'\n         HT '<LIST OPTIONS> - APPLY TO LINE PRECEEDING THE NEXT LINE TO*\n                BE COLLECTED'\n         HT '  NONUMBERED, UNNUMBERED OR INTEGER OPTION WILL PROMPT FOR*\n                THE NEW LINE'\n         HT '  FOR MORE INFO USE THE HELP COMMAND'\nCOLTFIN  HT 'MERGE - INTERLEAVES NEW LINES WITH OLD LINES'\nIFBEG    HT 'FUNCTION: THE RELATIONAL EXPRESSION IN PARENTHESES IS EVAL*\n               UATED. IF THE'\n         HT '  RESULT IS TRUE, THE <COMMAND> FOLLOWING THE PARENTHESES *\n               IS EXECUTED.'\n         HT '  OTHERWISE, THE <COMMAND> IS SKIPPED WITHOUT INSPECTION'\n         HT 'SYNTAX: IF(<EXP> <RELOP> <EXP>) <COMMAND>'\n         HT 'OPERANDS:'\n         HT '<COMMAND> - ANY WYLBUR COMMAND'\n         HT '<EXP> - AN ARITHMETIC EXPRESSION'\n         HT '<RELOP> - ALLOWED RELATIONAL OPERATORS ARE EQ, NE, LT, LE,*\n                GT, GE WHICH'\n         HT '  CORRESPOND TO TESTS FOR EQUAL, NOT EQUAL, LESS THAN, LES*\n               S THAN OR'\nIFFIN    HT '  EQUAL, GREATER THAN, GREATER THAN OR EQUAL, RESPECTIVELY*\n               '\nTSOBEG   HT 'FUNCTION: PUTS YOU DOWN A LEVEL TO A NEW TSO SESION'\nTSOFIN   HT 'SYNTAX:   TSO'\n         PRINT GEN\n         TITLE 'END OF PAGED CODE -- PAGE 05'\n         PINIT\n         PEND\n         TITLE 'START OF PAGED CODE -- PAGE 06'\nP006     PAGECDE HREAD,HDECD\n         WIDENT 001\n         USING CPAREA,R12\n         TITLE 'HELP ROUTINES -- PAGE 06'\nPHREAD   GENTER ,\n         LA    R2,READBEG\n         LA    R3,READFIN\n         B     SEND06\nPHDECD   GENTER ,\n         LA    R2,DECIDBEG\n         LA    R3,DECIDFIN\nSEND06   SENDH\n         PRINT NOGEN\nREADBEG  HT 'FUNCTION: PRODUCES A PROMPT FOR A COMMAND. WHEN THE NEW CO*\n               MMAND IS'\n         HT '  ENTERED, IT IS EXECUTED'\n         HT 'SYNTAX:'\n         HT '      READ \u00dd<LINE01>\u00a8 \u00ddEXEC|DELETE\u00a8 \u00ddPROMPT <STRING>\u00a8'\n         HT '  OR  READ STRING <S VARIABLE> \u00ddPROMPT <STRING>\u00a8'\n         HT '  OR  READ STRING <S VARIABLE> USING <LINENO> \u00ddCOMUMNS <C *\n               RANGE>\u00a8'\n         HT '  OR  READ VALUE <VARIABLE(S)> \u00ddPROMPT <STRING>\u00a8'\n         HT 'OPERANDS:'\n         HT 'COLUMNS <M>/<N> - LIMITS ASSIGNMENT TO COLUMNS <M> THROUGH*\n                <N> OF THE'\n         HT '  GIVEN LINE'\n         HT 'DELETE - COMMAND ERASED FROM ACTIVE FILE BEFORE EXECUTION'\n         HT 'EXEC - ONE COMMAND FROM EXEC FILE IS READ AND EXECUTED'\n         HT '<LINE01> - ALLOWS ONE COMMAND TO BE READ FROM THE ACTIVE F*\n               ILE AND'\n         HT '  EXECUTED'\n         HT 'PROMPT <STRING> - CAUSES THE <STRING> TO BE WRITTEN AT THE*\n                TERMINAL'\n         HT '  BEFORE THE COMMAND IS READ'\n         HT 'STRING <S VARIABLE> - VALUE ENTERED IS ASSIGNED TO <S VARI*\n               ABLE>. AN'\n         HT '  <S VARIABLE> IS THE LETTER S FOLLOWED BY ONE DIGIT (0-9)*\n               '\n         HT 'USING <LINENO> - ASSIGNS A VALUE TO <S VARIABLE> FROM THE *\n               LINE IN THE'\n         HT '  ACTIVE FILE SPECIFIED BY <LINENO>'\n         HT 'VALUE <VARIABLE(S)> - VALUE ENTERED ASSIGNED TO <VARIABLE(*\n               S)>. VALUES'\nREADFIN  HT '  ENTERED ARE SEPARATED BY AT LEAST ONE SPACE, COMMA OR EQ*\n               UAL SIGN'\nDECIDBEG HT 'FUNCTION: USES THE TEXT TO DETERMINE AN APPROPRIATE RESPON*\n               SE FROM EIGHT'\n         HT '          POSSIBLE RESPONSES: MAYBE, NO, WHY NOT, YES, OF *\n               COURSE,'\n         HT '          NEVER, OK, BEATS ME'\n         HT 'SYNTAX:'\nDECIDFIN HT '          DECIDE <ANY TEXT>'\n         PRINT GEN\n         TITLE 'END OF PAGED CODE -- PAGE 06'\n         PINIT\n         PEND\n         TITLE 'START OF PAGED CODE -- PAGE 15'\nP015     PAGECDE HCENTR,HNUM,HMOVE\n         WIDENT 001\n         USING CPAREA,R12\n         TITLE 'HELP ROUTINES -- PAGE 15'\nPHCENTR  GENTER ,\n         LA    R2,CENTBEG\n         LA    R3,CENTFIN\n         B     SEND15\nPHNUM    GENTER ,\n         LA    R2,NUMBEG\n         LA    R3,NUMFIN\n         B     SEND15\nPHMOVE   GENTER ,\n         LA    R2,MOVEBEG\n         LA    R3,MOVEFIN\nSEND15   SENDH\n         PRINT NOGEN\nCENTBEG  HT 'FUNCTION: CENTERS EACH LINE OF TEXT IN THE <RANGE> WITHIN *\n               THE LENGTH'\n         HT '          SPECIFIED OR THE GLOBAL LENGTH'\n         HT 'SYNTAX:'\n         HT '          CENTER <RANGE> \u00ddLENGTH=<N>\u00a8 \u00ddINDENT=<M>\u00a8'\n         HT 'OPERANDS:'\n         HT 'INDENT - SPECIFIES CENTERING BASED ON AN INDENTATION VALUE*\n               '\nCENTFIN  HT 'LENGTH=<N> - LINES CENTERED WITHIN A WIDTH OF <N> CHARACTE*\n               RS'\nNUMBEG   HT 'FUNCTION: RENUMBERS THE ACTIVE FILE'\n         HT 'SYNTAX:'\n         HT '          NUMBER \u00dd<RANGE>\u00a8 \u00dd\u00ddBY <LINE1>\u00a8|\u00ddTIMES <LINE2>\u00a8\u00a8'\n         HT 'OPERANDS:'\n         HT 'BY <LINE1> - <LINE1> IS THE INCREMENT USED IN DERIVING SUC*\n               CESSIVE'\n         HT '              LINE NUMBERS'\n         HT '<RANGE> - <RANGE> IS OF THE FORM M/N. THE LINE SPECIFIED B*\n               Y M BECOMES'\n         HT '          THE NEW NUMBER OF THE FIRST LINE IN THE FILE'\n         HT 'TIMES <LINE2> - <LINE2> IS A SCALE FACTOR THAT MULTIPLIES *\n               EACH OF THE'\nNUMFIN   HT '                EXISTING LINE NUMBERS TO FORM THE NEW LINE*\n                NUMBERS'\nMOVEBEG  HT 'FUNCTION: MOVES A SPECIFIED <RANGE> FROM ONE PART OF THE A*\n               CTIVE FILE'\n         HT '  TO ANOTHER'\n         HT 'SYNTAX:'\n         HT 'MOVE <RANGE> TO \u00bb<LINE1>|END\u00ba \u00ddBY <LINE2>\u00a8 \u00ddMERGE\u00a8 \u00dd<LIST *\n               OPTIONS>\u00a8'\n         HT 'OPERANDS:'\n         HT 'BY <LINE2> - <LINE2> IS THE LINE INCREMENT, ITS DEFAULT VA*\n               LUE IS 1 IN'\n         HT '  THE LOW-ORDER DIGIT POSITION OF <LINE1>'\n         HT 'TO <LINE1>|END - THE LINES IN <RANGE> ARE MOVED TO <LINE1>*\n               . IF <LINE1>'\n         HT '  IS NOT SPECIFIED THE LINES ARE MOVED TO THE END OF THE A*\n               CTIVE FILE'\n         HT '<LIST OPTIONS> - APPLY TO THE LINE BEFORE <LINE1> AND THE *\n               NEW LINES. USE'\n         HT '  \"HELP\" COMMAND'\nMOVEFIN  HT 'MERGE - ALLOWS INTERLEAVING IN THE FILE AND MUST APPEAR AF*\n               TER <LINE2>'\n         PRINT GEN\n         TITLE 'END OF PAGED CODE -- PAGE 15'\n         PINIT\n         PEND\n         TITLE 'START OF PAGED CODE -- PAGE 27'\nP027     PAGECDE HCHANG\n         WIDENT 001\n         USING CPAREA,R12\n         TITLE 'HELP ROUTINES -- PAGE 27'\nPHCHANG  GENTER ,\n         LA    R2,CHANGBEG\n         LA    R3,CHANGFIN\nSEND27   SENDH\n         PRINT NOGEN\nCHANGBEG HT 'FUNCTION: CHANGES A SPECIFIED CHARACTER STRING IN LINES WH*\n               ICH ARE'\n         HT '  IN A SPECIFIED <RANGE> OF THE ACTIVE FILE'\n         HT 'SYNTAX:'\n         HT '(1) CHANGE <STRING1> <I>/<J>/<K> \u00dd(<N>)\u00a8 TO <STRING2>'\n         HT '           \u00ddIN <RANGE>\u00a8 \u00dd<LIST OPTIONS>\u00a8 \u00ddLINE\u00a8'\n         HT '(2) CHANGE <I>/<J>/<K> TO <STRING2> \u00ddIN <RANGE>\u00a8 \u00ddLINE\u00a8'\n         HT '(3) CHANGE \u00dd<STRING1>\u00a8 <I>/J>/<K> \u00ddIN <RANGE>\u00a8 \u00dd(<N>)\u00a8'\n         HT '           USING <RANGE2> \u00ddCOLUMNS=\u00bb\u00dd<M1>\u00a8\u00dd/<M2>\u00ba\u00a8 \u00ddREPEAT*\n               \u00a8'\n         HT 'OPERANDS:'\n         HT '<STRING1> - THE SPECIFIED OCCURENCE OF <STRING1> IS CHANGE*\n               D TO <STRING2>'\n         HT '<I>/<J>/<K> - <I>/<J> RESTRICT THE SEARCH TO COLUMNS <I> T*\n               HROUGH <J>'\n         HT '  OF THE LINE. IF ONLY <I> IS SPECIFIED <STRING1> IS RESTR*\n               ICTED TO START'\n         HT '  IN COLUMN <I> OF THE LINE. IF <K> IS SPECIFIED NOTHING F*\n               ROM COLUMN <K>'\n         HT '  TO THE END OF THE LINE CAN BE MOVED OR CHANGED'\n         HT '(<N>) - ONLY THE <N>TH OCCURRENCE OF <STRING1> IN THE LINE*\n                IS CHANGED'\n         HT '  IF NOT SPECIFIED, ALL OCCURRENCES OF <STRING1> IN THE LI*\n               NE ARE CHANGED'\n         HT 'USING <RANGE2> - THE CONTENTS OF THE LINES IN THE REPLACEM*\n               ENT RANGE'\n         HT '  (<RANGE2>) ARE USED SUCCESSIVELY AS REPLACEMENTS'\n         HT 'COLUMNS=<M1>/<M2> - ONLY THE INDICATED COLUMNS FROM EACH L*\n               INE ARE USED'\n         HT '  IN THE REPLACEMENT RANGE. COLUMNS=<M1>, SPECIFIES THAT T*\n               HE CONTENTS OF'\n         HT '  THE LINES BEGINNING WITH COLUMN <M1> ARE TO BE USED.  CO*\n               LUMNS=/<M2>'\n         HT '  SPECIFIES THAT THE CONTENTS OF THE LINES FROM COLUMN 1 T*\n               HROUGH COLUMN'\n         HT '  <M2> ARE TO BE USED'\n         HT 'REPEAT - USED WHEN THERE ARE MORE CHANGES TO BE MADE THAN *\n               THERE ARE'\n         HT '  LINES IN THE REPLACEMENT RANGE. WYLBUR RECYCLES THRU THE*\n                REPLACEMENT'\nCHANGFIN HT '  RANGE'\n         PRINT GEN\n         TITLE 'END OF PAGED CODE -- PAGE 27'\n         PINIT\n         PEND\n         TITLE 'START OF PAGED CODE -- PAGE 28'\nP028     PAGECDE HEXCT\n         WIDENT 001\n         USING CPAREA,R12\n         TITLE 'HELP ROUTINES -- PAGE 28'\nPHEXCT   GENTER ,\n         LA    R2,EXECBEG\n         LA    R3,EXECFIN\nSEND28   SENDH\n         PRINT NOGEN\nEXECBEG  HT 'FUNCTION: EXECUTES A FILE OF WYLBUR COMMANDS'\n         HT 'SYNTAX:'\n         HT 'EXEC \u00ddACTIVE|FROM <DSNAME>\u00a8 \u00ddON <VOLUME>\u00a8 \u00ddUSER <UUU>\u00a8 \u00ddGR*\n               OUP <GG>\u00a8'\n         HT '     \u00ddCLEAR\u00a8 \u00dd<LINE1>|RETRY\u00a8 \u00ddPAUSE\u00a8 \u00ddLOG|NOLOG\u00a8 \u00ddTERSE|VE*\n               RBOSE\u00a8'\n         HT '     \u00ddSET|NOSET\u00a8 \u00ddSTART <LINE2>\u00a8'\n         HT 'OPERANDS:'\n         HT 'ACTIVE - THE EXEC FILE IS LOADED FROM THE CURRENT ACTIVE F*\n               ILE WHICH'\n         HT '         IS CLEARED'\n         HT 'FROM <DSNAME> - THE EXEC FILE IS LOADED FROM AN EDIT FORMA*\n               T EXTERNAL'\n         HT '                FILE'\n         HT 'ON <VOLUME> - THIS MUST BE SPECIFIED IF YOU ARE USING AN E*\n               XTERNAL FILE'\n         HT 'USER, GROUP - USED TO DESIGNATE AN EXTERNAL FILE WHICH BEL*\n               ONGS TO'\n         HT '              ANOTHER USER'\n         HT 'SET|NOSET - IF YOU SPECIFY SET, THE PREFIX AND MEMBER NAME*\n               S WILL BE SET'\n         HT '            NOSET IS THE DEFAULT'\n         HT 'CLEAR - CLEARS THE CURRENT EXEC FILE'\n         HT '<LINE1> - AFTER AN INTERRUPTION EXECUTION IS RESTARTED AT *\n               <LINE1>'\n         HT 'RETRY - EXECUTION STARTS AT THE INTERRUPTED COMMAND. IF BO*\n               TH <LINENO>'\n         HT '        AND RETRY ARE OMITTED EXECUTION STARTS AT THE NEXT*\n                COMMAND'\n         HT '        AFTER THE INTERRUPTED COMMAND'\n         HT 'PAUSE - DIRECTS WYLBUR TO RETURN CONTROL TO THE TERMINAL W*\n               ITHOUT'\n         HT '        EXECUTING ANY OTHER COMMANDS'\n         HT 'LOG|NOLOG - LOG SPECIFIES THAT ALL COMMANDS ARE TYPED BEFO*\n               RE EXECUTION'\n         HT '            LOG IS THE DEFAULT'\n         HT 'TERSE|VERBOSE - TERSE CAUSES WYLBUR NOT TO PRINT LINE NUMB*\n               ERS AND'\n         HT '  SHORTENS SOME RESPONSES. VERBOSE IS THE DEFAULT'\n         HT 'START <LINE2> - AFTER THE EXEC FILE HAS BEEN LOADED EXECUT*\n               ION BEGINS'\n         HT '  AT <LINE2>. IF THIS OPTION IS OMITTED EXECUTION BEGINS A*\n               T THE FIRST'\nEXECFIN  HT '  LINE OF THE EXEC FILE'\n         PRINT GEN\n         TITLE 'END OF PAGED CODE -- PAGE 28'\n         PINIT\n         PEND\n         TITLE 'START OF PAGED CODE -- PAGE 29'\nP029     PAGECDE HCOMNT,HJUST\n         WIDENT 001\n         USING CPAREA,R12\n         TITLE 'HELP ROUTINES -- PAGE 29'\nPHCOMNT  GENTER ,\n         LA    R2,COMMBEG\n         LA    R3,COMMFIN\n         B     SEND29\nPHJUST   GENTER ,\n         LA    R2,JUSTBEG\n         LA    R3,JUSTFIN\nSEND29   SENDH\n         PRINT NOGEN\nCOMMBEG  HT 'FUNCTION: CAUSES THE TEXT OF THE COMMAND TO BE PRINTED AT *\n               THE TERMINAL'\n         HT '  COMMENT - TEXT PRINTED ENDS WITH CR/LF'\n         HT '  DISPLAY - TEXT PRINTED DOES NOT END WITH CR/LF'\n         HT 'SYNTAX:'\nCOMMFIN  HT '          COMMENT <ANY TEXT>    OR    DISPLAY <ANY TEXT>'\nJUSTBEG  HT 'FUNCTION: REARRANGES THE CONTENTS OF THE LINES IN <RANGE> *\n               SO THAT EACH'\n         HT '          LINE CONTAINS AS MANY WORDS AS POSSIBLE BUT NOT *\n               MORE THAN'\n         HT '          LENGTH CHARACTERS. THE TEXT IS ALSO RIGHT JUSTIF*\n               IED'\n         HT 'SYNTAX:'\n         HT ' JUSTIFY <RANGE> \u00ddLENGTH=<N>\u00a8 \u00ddMARKER=<C>\u00a8 \u00ddNUMBER\u00a8 \u00ddINDEN*\n               T=<I> \u00dd<J>\u00a8\u00a8'\n         HT '         \u00ddEVEN\u00a8 \u00ddSPACE\u00a8'\n         HT 'OPERANDS:'\n         HT 'LENGTH=<N> - NOT MORE THAN <N> CHARACTERS IN A LINE'\n         HT 'MARKER=<C> - A LINE WITH <C> IN COLUMN 1 IS NOT ALIGNED AN*\n               D THE'\n         HT '             ALIGNMENT PROCESS IS RESTARTED AFTER THAT LIN*\n               E'\n         HT 'NUMBER - WYLBUR RENUMBERS THE ENTIRE FILE AFTER THE ALIGNM*\n               ENT PROCESS'\n         HT 'INDENT=<I> <J> - INDENTS EACH ALIGNED LINE BY <I> SPACES. *\n               INDENTED'\n         HT '                 PARAGRAPH BEGINNINGS ARE FURTHER INDENTED*\n                BY <J>'\n         HT '                 SPACES. THE DEFAULT IS INDENT 0 0'\n         HT 'EVEN - THE ALIGNMENT PROCESS IS RESTARTED ONLY AFTER A BLA*\n               NK LINE AND'\n         HT '       ALL LINES IN THE <RANGE> ARE ALIGNED ON THE LEFT MA*\n               RGIN TO THE'\n         HT '       COLUMNS SPECIFIED IN THE INDENT PARAMETER'\n         HT 'SPACE - WYLBUR RESPACES THE LINES SO THAT THERE IS ONLY ON*\n               E SPACE'\n         HT '        BETWEEN WORDS UNLESS THE WORD ENDS WITH A PERIOD, *\n               EXCLAMATION'\nJUSTFIN  HT '        POINT, OR QUESTION MARK, WHEN IT INSERTS TWO SPACE*\n               S'\n         PRINT GEN\n         TITLE 'END OF PAGED CODE -- PAGE 29'\n         PINIT\n         PEND\n         TITLE 'START OF PAGED CODE -- PAGE 30'\nP030     PAGECDE HLIST\n         WIDENT 001\n         USING CPAREA,R12\n         TITLE 'HELP ROUTINES -- PAGE 30'\nPHLIST   GENTER ,\n         LA    R2,LISTBEG\n         LA    R3,LISTFIN\nSEND30   SENDH\n         PRINT NOGEN\nLISTBEG  HT 'FUNCTION: LISTS ALL OR PART OF A FILE'\n         HT 'SYNTAX:'\n         HT '  LIST \u00dd<RANGE>\u00a8 \u00dd<LIST OPTIONS>\u00a8 \u00ddMARKER=C\u00a8 \u00ddEXEC\u00a8 \u00ddSQUAS*\n               HED\u00a8'\n         HT '       \u00ddCOLUMNS \u00bb\u00dd<M>\u00a8\u00dd/<N>\u00a8\u00ba\u00a8 \u00dd(<N>)\u00a8'\n         HT 'OPERANDS:'\n         HT 'COLUMNS <M>/<N> - LISTS ONLY TEXT BETWEEN COLUMNS <M> AND *\n               <N> IN THE'\n         HT '  <RANGE>. IF <M> IS UNSPECIFIED THE LINE IS LISTED THROUG*\n               H COLUMN <N>.'\n         HT '  IF <N> IS UNSPECIFIED THE LINE IS LISTED FROM COLUMN <M>*\n                THROUGH THE'\n         HT '  END OF THE LINE'\n         HT 'EXEC - THE EXEC FILE IS LISTED INSTEAD OF THE ACTIVE FILE'\n         HT '<LIST OPTIONS> - USE \"HELP\" COMMAND'\n         HT 'MARKER=<C> - SUSPENDS LISTING WHENEVER A LINE IS REACHED W*\n               HICH'\n         HT '  CONTAINS THE MARKER CHARACTER IN COLUMN ONE. LISTING IS *\n               RESTARTED'\n         HT '  WITH A (CR) RESPONSE OR ABORTED WITH AN ATTENTION RESPON*\n               SE'\n         HT '(<N>) - INSERTS <N> BLANKS AT THE LEFT OF THE OUTPUT'\n         HT '<RANGE> - USE THE HELP COMMAND'\n         HT 'SQUASHED - CONVERTS MULTIPLE BLANKS TO SINGLE BLANKS FOR T*\n               HE LISTING'\nLISTFIN  HT '  WITHOUT ALTERING THE ACTIVE AND EXEC FILES'\n         PRINT GEN\n         TITLE 'END OF PAGED CODE -- PAGE 30'\n         PINIT\n         PEND\n         TITLE 'START OF PAGED CODE -- PAGE 31'\nP031     PAGECDE HMODFY\n         WIDENT 001\n         USING CPAREA,R12\n         TITLE 'HELP ROUTINES -- PAGE 31'\nPHMODFY  GENTER ,\n         LA    R2,MODIFBEG\n         LA    R3,MODIFFIN\nSEND31   SENDH\n         PRINT NOGEN\nMODIFBEG HT 'FUNCTION: ENABLES INSERTIONS, DELETIONS AND REPLACEMENTS O*\n               F THE'\n         HT '          CONTENTS OF EACH LINE IN A SPECIFIED <RANGE>'\n         HT 'SYNTAX:   MODIFY \u00dd<RANGE>\u00a8 \u00dd<LIST OPTION>\u00a8 \u00ddSINGLE\u00a8'\n         HT 'OPERANDS:'\n         HT 'SINGLE - INSTRUCTS WYLBUR TO PROMPT FOR ALTERATIONS ONLY O*\n               NCE'\n         HT 'INSERTION: TYPE THE LETTER <I> IMMEDIATELY BELOW THE CHARA*\n               CTER IN THE'\n         HT '           LINE BEFORE WHICH CHARACTERS ARE TO BE INSERTED*\n               .  THIS'\n         HT '           INDICATOR IS FOLLOWED BY THE STRING OF CHARACTE*\n               RS TO BE'\n         HT '           INSERTED AND A CARRIAGE RETURN'\n         HT 'REPLACEMENT: THE INDICATOR \"R\" IS TYPED IMMEDIATELY BELOW *\n               THE FIRST'\n         HT '             CHARACTER TO BE REPLACED IN THE LINE FOLLOWED*\n                BY THE'\n         HT '             STRING OF REPLACEMENT CHARACTERS AND A CARRIA*\n               GE RETURN'\n         HT 'DELETION: TO REMOVE A STRING OF CHARACTERS FROM A LINE TYP*\n               E A \"D\"'\n         HT '          UNDER THE FIRST AND LAST CHARACTERS OF THE STRIN*\n               G TO BE'\n         HT '          DELETED.  THE DELETION RANGE MAY ALSO BE TERMINA*\n               TED BY'\n         HT '          TYPING EITHER AN \"I\" OR \"R\" INSTEAD OF A \"D\".  I*\n               F TERMINATED'\n         HT '          BY AN \"R\", THE CHARACTERS FOLLOWING THE DELETED *\n               STRING ARE'\n         HT '          REPLACED BY THE REPLACEMENT STRING THAT FOLLOWS *\n               THE \"R\".  IF'\n         HT '          THE DELETION RANGE IS TERMINATED BY AN \"I\", THE *\n               DELETED'\nMODIFFIN HT '          CHARACTERS ARE REPLACED BY THE STRING TO BE INSE*\n               RTED'\n         PRINT GEN\n         TITLE 'END OF PAGED CODE -- PAGE 31'\n         PINIT\n         PEND\n         TITLE 'START OF PAGED CODE -- PAGE 32'\nP032     PAGECDE HCLEAR,HEDIT,HINSRT\n         WIDENT 001\n         USING CPAREA,R12\n         TITLE 'HELP ROUTINES -- PAGE 32'\nPHCLEAR  GENTER ,\n         LA    R2,CLEARBEG\n         LA    R3,CLEARFIN\n         B     SEND32\nPHEDIT   GENTER ,\n         LA    R2,EDITBEG\n         LA    R3,EDITFIN\n         B     SEND32\nPHINSRT  GENTER ,\n         LA    R2,INSRTBEG\n         LA    R3,INSRTFIN\nSEND32   SENDH\n         PRINT NOGEN\nCLEARBEG HT 'SYNTAX:'\n         HT '          CLEAR \u00bb\u00ddACTIVE\u00a8 \u00ddEXEC\u00a8 \u00ddTEXT\u00a8 \u00ddNAME\u00a8 \u00ddTABS\u00a8\u00ba'\n         HT 'OPERANDS:'\n         HT 'ACTIVE, TEXT - THE ACTIVE FILE IS ERASED.'\n         HT 'EXEC - THE EXEC FILE IS ERASED.'\n         HT 'NAME - RESETS THE GROUP, USER, PREFIX, AND MEMBER FIELDS T*\n               O THE DEFAULT'\n         HT '       SIGNON VALUES.'\n         HT 'TABS - CLEARS THE TAB POSITIONS THAT HAVE BEEN SET BY A SE*\n               T TABS'\nCLEARFIN HT '       COMMAND'\nEDITBEG  HT 'FUNCTION: ALLOWS YOU TO CHANGE THE CONTENTS OF A RANGE OF *\n               LINES IN'\n         HT '  THE ACTIVE FILE. THERE WILL BE A PROMPT WITH THE DESIGNA*\n               TED'\n         HT '  LINE. TYPE THE REPLACEMENT CHARACTER(S) UNDER THE UNDESI*\n               RED'\n         HT '  CHARACTER(S). A VERTICAL BAR (|) REPLACES A CHARACTER WI*\n               TH'\n         HT '  A BLANK. A VERTICAL BAR TYPED UNDER A BLANK WILL CAUSE A*\n               '\n         HT '  VERTICAL BAR TO APPEAR IN THE TEXT'\n         HT 'SYNTAX:'\n         HT '          EDIT \u00dd<RANGE>\u00a8 \u00dd<LIST OPTIONS>\u00a8 \u00ddSINGLE\u00a8'\n         HT 'OPERANDS:'\n         HT 'NOLIST - WYLBUR DOES NOT LIST THE CHANGED LINES'\n         HT 'SINGLE - RESULTS IN ONE PROMPT PER LINE INSTEAD OF THE USU*\n               AL MULTIPLE'\nEDITFIN  HT '         PROMPTS'\nINSRTBEG HT 'FUNCTION: INSERTS A LINE OF TEXT INTO THE ACTIVE FILE'\n         HT 'SYNTAX:'\n         HT '          INSERT <LINENO> \u00ddNODITTO|DITTO\u00a8 \u00dd<LIST OPTIONS>\u00a8*\n               '\n         HT 'OPERANDS:'\n         HT '<LINENO> - WYLBUR PROMPTS FOR THE SPECIFIED LINE NUMBER (<*\n               LINENO>),'\n         HT '           AFTER WHICH YOU MAY TYPE IN THE CONTENTS OF THE*\n                NEW LINE'\n         HT 'NODITTO|DITTO - DITTO OPTION IS USED TO INSERT A LINE IN S*\n               EVERAL'\n         HT '                PLACES. THE DEFAULT IS NODITTO'\nINSRTFIN HT '<LIST OPTIONS> - SAME AS THE COLLECT COMMAND'\n         PRINT GEN\n         TITLE 'END OF PAGED CODE -- PAGE 32'\n         PINIT\n         PEND\n         TITLE 'START OF PAGED CODE -- PAGE 33'\nP033     PAGECDE HALIGN,HCOMP,HCATLG,HDEL\n         WIDENT 001\n         USING CPAREA,R12\n         TITLE 'HELP ROUTINES -- PAGE 33'\nPHALIGN  GENTER ,\n         LA    R2,ALIBEG\n         LA    R3,ALIFIN\n         B     SEND33\nPHCOMP   GENTER ,\n         LA    R2,COMPBEG\n         LA    R3,COMPFIN\n         B     SEND33\nPHCATLG  GENTER ,\n         LA    R2,CATBEG\n         LA    R3,CATFIN\n         B     SEND33\nPHDEL    GENTER ,\n         LA    R2,DELEBEG\n         LA    R3,DELEFIN\nSEND33   SENDH\n         PRINT NOGEN\nALIBEG   HT 'FUNCTION: SAME AS THE JUSTIFY COMMAND EXCEPT THE TEXT IS N*\n               OT RIGHT'\n         HT '          JUSTIFIED'\n         HT 'SYNTAX:'\n         HT 'ALIGN <RANGE> \u00ddLENGTH=<N>\u00a8 \u00ddMARKER=<C>\u00a8 \u00ddNUMBER\u00a8 \u00ddINDENT=<*\n               I> \u00dd<J>\u00a8\u00a8'\n         HT '      \u00ddEVEN\u00a8 \u00ddSPACE\u00a8'\nALIFIN    HT 'OPERANDS: SAME AS FOR THE JUSTIFY COMMAND'\nCOMPBEG  HT 'FUNCTION: COMPARES THE CONTENTS OF TWO SETS OF CONSECUTIVE*\n                LINES,'\n         HT '  BOTH OF WHICH MUST BE IN THE ACTIVE FILE. REQUIRED OPERA*\n               NDS'\n         HT '  ARE THE STARTING LINE NUMBERS OF THE RANGES TO BE COMPAR*\n               ED'\n         HT '  A LINE BY LINE COMPARISON IS MADE OF THE LINE CONTENTS U*\n               NTIL'\n         HT '  THE END OF THE ACTIVE FILE IS REACHED OR A COMPARISON FA*\n               ILS'\n         HT 'SYNTAX:'\n         HT '  COMPARE \u00dd<LIST OPTIONS>\u00a8 <LINE01> <LINE02> \u00ddCOLUMNS \u00bb\u00dd<N*\n               >\u00a8\u00dd/<M>\u00a8\u00ba\u00a8'\n         HT 'OPERANDS:'\n         HT 'COLUMNS <N>/<M> - ONLY COLUMNS <N> THROUGH <M> ARE COMPARE*\n               D. IF ONLY'\n         HT '  <N> IS SPECIFIED, <N>/133 IS ASSUMED. IF ONLY <M> 1/<M> *\n               IS ASSUMED'\n         HT '<LINE01>,<LINE02> - THE STARTING LINE NUMBERS OF THE RANGE*\n               S TO BE'\n         HT '  COMPARED'\nCOMPFIN  HT '<LIST OPTIONS> - USE \"HELP\" COMMAND'\nCATBEG   HT 'FUNCTION: CAUSES THE SPECIFIED DATA SET TO BE CATALOGED IN*\n                THE SYSTEM'\n         HT '  CATALOG. YOU MUST SPECIFY A DSNAME AND A VOLUME. YOU MAY*\n               '\n         HT '  CATALOG ONLY DATA SETS BELONGING TO YOU OR YOUR GROUP'\n         HT 'SYNTAX:'\n         HT 'CATLG <DSNAME> ON <VOLUME> \u00ddUSER <UUU>\u00a8 \u00ddGROUP <GG>\u00a8 \u00ddSET|*\n               NOSET\u00a8'\nCATFIN   HT 'OPERANDS: SAME AS FOR THE USE AND SAVE COMMANDS'\nDELEBEG  HT 'FUNCTION: ERASES A RANGE OF LINES IN THE ACTIVE FILE.'\n         HT 'SYNTAX:   DELETE <RANGE> \u00dd<LIST OPTIONS>\u00a8'\nDELEFIN  HT 'OPERANDS: USE \"HELP\" COMMAND'\n         PRINT GEN\n         TITLE 'END OF PAGED CODE -- PAGE 33'\n         PINIT\n         PEND\n         TITLE 'START OF PAGED CODE -- PAGE 34'\nP034     PAGECDE HCOPY\n         WIDENT 001\n         USING CPAREA,R12\n         TITLE 'HELP ROUTINES -- PAGE 34'\nPHCOPY   GENTER ,\n         LA    R2,COPYBEG\n         LA    R3,COPYFIN\nSEND34   SENDH\n         PRINT NOGEN\nCOPYBEG  HT 'FUNCTION: COPIES A RANGE OF LINES TO ANOTHER PLACE IN THE *\n               ACTIVE FILE'\n         HT 'SYNTAX:'\n         HT 'COPY \u00dd<RANGE>\u00a8 \u00ddTO \u00bb<LINE1>|END\u00ba\u00a8 \u00ddBY <LINE2>\u00a8 \u00ddFROM <DSNA*\n               ME>\u00a8'\n         HT '     \u00ddCOMBINE\u00a8 \u00ddUSER <UUU>\u00a8 \u00ddGROUP <GG>\u00a8 \u00ddSET|NOSET\u00a8 \u00ddMERG*\n               E\u00a8 \u00ddEXEC\u00a8'\n         HT '     \u00ddON <VOLUME>\u00a8 \u00dd<LIST OPTIONS>\u00a8'\n         HT 'OPERANDS:'\n         HT 'BY <LINE2> - SUCCESSIVE LINE NUMBERS OF THE COPY ARE DERIV*\n               ED BY USING'\n         HT '  <LINE2>'\n         HT 'COMBINE - ALLOWS INTERLEAVING OF THE FILE WHEN AN EXTERNAL*\n                FILE IS'\n         HT '  REFERENCED'\n         HT 'EXEC - COPIES ALL OR PART OF THE EXEC FILE TO THE ACTIVE F*\n               ILE'\n         HT 'FROM <DSNAME> - THE <RANGE> IS TAKEN FROM THE NAMED EXTERN*\n               AL FILE. IF'\n         HT '  THIS OPTION IS NOT USED THE <RANGE> IS TAKEN FROM THE AC*\n               TIVE FILE'\n         HT 'MERGE - ALLOWS INTERLEAVING OF THE FILE, IF THE LINE NUMBE*\n               RS INTERLEAVE'\n         HT 'ON <VOLUME> - SPECIFIES THE VOLUME NUMBER (<VOLUME>) ON WH*\n               ICH THE'\n         HT '  EXTERNAL FILE RESIDES'\n         HT '<RANGE> - MUST BE THE FIRST POSITIONAL PARAMETER IF SPECIF*\n               IED'\n         HT 'SET|NOSET - SET WILL ALTER THE PREFIX AND MEMBER FIELDS TO*\n                THOSE'\n         HT '  SPECIFIED IN IN THE COPY COMMAND'\n         HT 'TO <LINE1> - A COPY OF THE SPECIFIED <RANGE> IS PLACED IN *\n               THE ACTIVE'\n         HT '  FILE, BEGINNING AT A LINE NUMBERED <LINE1>'\nCOPYFIN  HT 'USER,GROUP - USED TO COPY FROM ANOTHER USER''S DATA SETS'\n         PRINT GEN\n         TITLE 'END OF PAGED CODE -- PAGE 34'\n         PINIT\n         PEND\n         TITLE 'START OF PAGED CODE -- PAGE 35'\nP035     PAGECDE HSET\n         WIDENT 001\n         USING CPAREA,R12\n         TITLE 'HELP SET ROUTINES -- PAGE 35'\nPHSET    GENTER ,\n         SCANSAVE ,            SAVE SCAN POINTERS IN CPSCAN\n         SCAN  SETBL1\n         LA    R2,SETOPTB         GET HERE IF NO OPTIONS FOUND\n         LA    R3,SETOPTF\n         B     SEND35\nNOTHERE  SCANRSTR ,               RESTORE SCAN POINTERS\n         PCALL HSET1\nBACK     LA    R2,BACKBEG\n         LA    R3,BACKFIN\n         B     SEND35\nDELTA    LA    R2,DELBEG\n         LA    R3,DELFIN\n         B     SEND35\nEXECUTE  LA    R2,EXEBEG\n         LA    R3,EXEFIN\n         B     SEND35\nCURRENT  LA    R2,CURBEG\n         LA    R3,CURFIN\n         B     SEND35\nPAGE     LA    R2,PAGEBEG\n         LA    R3,PAGEFIN\n         B     SEND35\nTERSE    LA    R2,TERSEBEG\n         LA    R3,TERSEFIN\nSEND35   SENDH\n         PRINT NOGEN\nSETOPTB  HT 'SET OPTIONS - BACK,NOBACK,CRT,NOCRT,CURRENT,*,DELTA,ESCAPE*\n               ,EXECUTE,'\n         HT '  GROUP,LENGTH,LOG,NOLOG,MEMBER,NAME,PREFIX,PAGESIZE,PS,RE*\n               SCAN,TABS,'\nSETOPTF  HT '  UPPER,UPLOW,TERSE,VERBOSE,VOLUME,USER,SKIP,VALUE,FASTLIS*\n               T,SLOWLIST'\nBACKBEG  HT 'BACK|NOBACK - WHEN NOBACK IS IN EFFECT A BACKSPACE ERASES *\n               THE PREVIOUS'\nBACKFIN  HT '  CHARACTER. WHEN BACK IS IN EFFECT A BACKSPACE IS ENTERED*\n                IN THE FILE'\nDELBEG   HT 'DELTA <LINENO> - SETS THE DEFAULT VALUE OF THE LINE NUMBER*\n                INCREMENT,'\n         HT '  DELTA. <LINENO> MAY BE ANY VALUE BETWEEN 0.000 AND 99999*\n               .999'\nDELFIN   HT '  INCLUSIVE. THE SIGNON VALUE OF DELTA IS 1.000'\nEXEBEG   HT 'EXECUTE \u00ddTERSE|VERBOSE\u00a8 \u00ddLOG|NOLOG\u00a8 - GOVERNS THE FORMAT O*\n               F TERMINAL'\n         HT '  MESSAGES WHICH APPEAR IN RESPONSE TO AN EXEC COMMAND. US*\n               E \"HELP'\nEXEFIN   HT '  SET TERSE\" AND \"HELP SET LOG\" COMMANDS'\nCURBEG   HT '\u00bbCURRENT|*\u00ba \u00dd<LINENO>\u00a8 \u00ddEXEC\u00a8 - SETS THE CURRENT LINE POIN*\n               TER TO THE'\n         HT '  <LINENO> SPECIFIED. THE EXEC OPTION APPLIES TO THE EXEC *\n               FILE INSTEAD'\nCURFIN   HT '  OF THE ACTIVE FILE'\nPAGEBEG  HT 'PAGESIZE|PS <N> - IF CRT IS IN EFFECT <N> LINES ARE LISTED*\n                BEFORE THE'\nPAGEFIN  HT '  COLON PROMPT'\nTERSEBEG HT 'TERSE|VERBOSE - TERSE SHORTENS THE WYLBUR COMMAND PROMPT C*\n               OMMAND? TO'\n         HT '  ?. ALL <DSNAMES> WILL BE LISTED IN AN ABBREVIATED FORM. *\n               ALL COMMANDS'\n         HT '  CONTAINING PRE-PROCESSOR ESCAPE OR SKIP CHARACTERS WILL *\n               NOT HAVE THE'\nTERSEFIN HT '  PROCESSED COMMAND LISTED. VERBOSE (DEFAULT) IS THE OPPOS*\n               ITE OF TERSE'\n         PRINT GEN\nSETBL1   SCKW  BACK,BACK,A\n         SCKW  NOBACK,BACK,A\n         SCKW  CURRENT,CURRENT,A\n         SCKW  *,CURRENT\n         SCKW  DELTA,DELTA,A\n         SCKW  PAGESIZE,PAGE ,A\n         SCKW  PS,PAGE,A\n         SCKW  EXECUTE,EXECUTE,A\n         SCKW  TERSE,TERSE,A\n         SCKW  VERBOSE,TERSE,A\n         SCKW  ,NOTHERE\n         TITLE 'END OF PAGED CODE -- PAGE 35'\n         PINIT\n         PEND\n         TITLE 'START OF PAGED CODE -- PAGE 04'\nP004     PAGECDE HSET1\n         WIDENT 001\n         USING CPAREA,R12\n         TITLE 'HELP ROUTINES -- PAGE 04'\nPHSET1   GENTER ,\n         SCANSAVE ,            SAVE SCAN POINTERS IN CPSCAN\n         SCAN SETBL2\nFAIL2    SCANRSTR ,\n         PCALL HSET2\nESCAPE   LA    R2,ESCBEG\n         LA    R3,ESCFIN\n         B     SEND04\nGROUP    LA    R2,GRPBEG\n         LA    R3,GRPFIN\n         B     SEND04\nLENGTH   LA    R2,LENBEG\n         LA    R3,LENFIN\n         B     SEND04\nLOG      LA    R2,LOGBEG\n         LA    R3,LOGFIN\n         B     SEND04\nMEMPDS   LA    R2,MEMBEG\n         LA    R3,MEMFIN\n         B     SEND04\nNAME     LA    R2,NAMEBEG\n         LA    R3,NAMEFIN\n         B     SEND04\nPREFIX   LA    R2,PREFBEG\n         LA    R3,PREFFIN\n         B     SEND04\nRESCAN   LA    R2,RESCBEG\n         LA    R3,RESCFIN\nSEND04   SENDH\n         PRINT NOGEN\nESCBEG   HT 'ESCAPE <C> - SETS THE PREPROCESSOR ESCAPE CHARACTER. IF <C*\n               > IS A'\n         HT '  SPECIAL CHARACTER ( ;,()\" OR BLANK) IT MUST BE ENCLOSED *\n               IN QUOTES.'\nESCFIN   HT '  SET ESC (CR) UNSETS THE ESCAPE CHARACTER'\nGRPBEG   HT 'GROUP <GG> - SPECIFIES THAT THE DEFAULT GROUP <GG> IS TO B*\n               E USED IN'\nGRPFIN   HT '  FORMING A <DSNAME>. SET GROUP (CR) RESETS GROUP TO THE S*\n               IGNON VALUE'\nLENBEG   HT 'LENGTH <N> - SPECIFIES THAT AT MOST <N> CHARACTERS MAY BE *\n               IN ANY'\n         HT '  LINE OF TEXT. <N> MAY BE ANY INTEGER BETWEEN 1 AND 133'\nLENFIN   HT '  INCLUSIVE. THE SIGNON VALUE OF LENGTH IS 72'\nLOGBEG   HT 'LOG|NOLOG - NOLOG SUPPRESSES PRINTING OF EACH LINE OF THE *\n               EXEC FILE'\nLOGFIN   HT '  AS IT IS EXECUTED. LOG (DEFAULT) IS THE OPPOSITE OF NOLO*\n               G'\nMEMBEG   HT 'MEMBER <MEMBER NAME> - SETS THE DEFAULT MEMBER NAME THAT W*\n               ILL BE USED TO'\nMEMFIN   HT '  FORM A <DSNAME>'\nNAMEBEG  HT 'NAME \u00dd<DSNAME>\u00a8 \u00ddUSER <UUU>\u00a8 \u00ddGROUP <GG>\u00a8 - SETS THE VALUE*\n               S OF GROUP,'\nNAMEFIN  HT '  USER, PREFIX, AND/OR MEMBER FIELDS IN ONE COMMAND'\nPREFBEG  HT 'PREFIX <STRING> - SETS THE PREFIX THAT CAN BE USED IN BUIL*\n               DING A'\n         HT '  <DSNAME>. <STRING> IS NOT ENCLOSED IN QUOTES. IF <STRING*\n               > IS OMITTED,'\nPREFFIN  HT '  PREFIX IS SET TO NULL, ITS SIGNON VALUE'\nRESCBEG  HT 'RESCAN <N> - SETS THE RESCAN COUNTER TO THE INTEGER <N>.'\n         HT '  A COMMAND WILL BE SCANNED AT MOST <N> TIMES BY THE PREPR*\n               OCESSOR'\nRESCFIN  HT '  FOR SKIP AND ESCAPE CHARACTERS BEFORE IT IS EXECUTED'\n         PRINT GEN\nSETBL2   SCKW  ESCAPE,ESCAPE,A\n         SCKW  GROUP,GROUP,A\n         SCKW  LENGTH,LENGTH,A\n         SCKW  LOG,LOG\n         SCKW  NOLOG,LOG,A\n         SCKW  MEMBER,MEMPDS,A\n         SCKW  NAME,NAME,A\n         SCKW  PREFIX,PREFIX,A\n         SCKW  RESCAN,RESCAN,A\n         SCKW  ,FAIL2\n         TITLE 'END OF PAGED CODE -- PAGE 04'\n         PINIT\n         PEND\n         TITLE 'START OF PAGED CODE -- PAGE 41'\nP041     PAGECDE HSET2\n         WIDENT 001\n         USING CPAREA,R12\n         TITLE 'MORE HELP SET ROUTINES -- PAGE 41'\nPHSET2  GENTER ,\n         SCAN  SETBL3\nTSKTSK   B     CVNVALID            PRINT INVALID OPTION & CVGETCOM\nCRT      PCALL HCRT\nSKIP     LA    R2,SKIPBEG\n         LA    R3,SKIPFIN\n         B     SEND41\nSLOWLIST LA    R2,SLOWBEG\n         LA    R3,SLOWFIN\n         B     SEND41\nTABS     LA    R2,TABSBEG\n         LA    R3,TABSFIN\n         B     SEND41\nUPPER    LA    R2,UPLOWBEG\n         LA    R3,UPLOWFIN\n         B     SEND41\nUSER     LA    R2,USERBEG\n         LA    R3,USERFIN\n         B     SEND41\nVALUE    LA    R2,VALUEBEG\n         LA    R3,VALUEFIN\n         B     SEND41\nVOLUME   LA    R2,VOLBEG\n         LA    R3,VOLFIN\nSEND41   SENDH\n         PRINT NOGEN\nSKIPBEG  HT 'SKIP <C> - SETS THE PREPROCESSOR SKIP CHARACTER. SET SKIP *\n               (CR) UNSETS'\nSKIPFIN  HT '  THE SKIP CHARACTER'\nSLOWBEG  HT 'SLOWLIST|FASTLIST - SLOWLIST KEEPS WYLBUR FROM USING TABS *\n               WHEN LISTING'\nSLOWFIN  HT '  A FILE. FASTLIST (DEFAULT) ALLOWS WYLBUR TO USE TABS'\nTABSBEG  HT 'TABS \u00ddT1,..,TN\u00a8 \u00ddNOVERIFY\u00a8 - SETS TABS AT COLUMNS T1,...,T*\n               N'\nTABSFIN  HT '  E.G. SET TABS 10 16 SETS TABS AT COLUMNS 10 AND 16'\nUPLOWBEG HT 'UPLOW|UPPER - UPPER SPECIFIES THAT ALL ALPHABETIC CHARACTE*\n               RS ARE'\n         HT '  RECOGNIZED AS UPPER CASE. UPLOW SPECIFIES THAT UPPER AND*\n                LOWER'\nUPLOWFIN HT '  CASE ALPHABETIC CHARACTERS ARE RECOGNIZED'\nUSERBEG  HT 'USER  <UUU> - SPECIFIES THAT THE DEFAULT USER <UUU> IS TO *\n               BE USED IN'\nUSERFIN  HT '  FORMING A <DSNAME>. SET USER (CR) RESETS USER TO THE SIG*\n               NON VALUE'\nVALUEBEG HT 'VALUE <PREVAR(S)> <CEXPR> - ASSIGNS VALUES TO PRE-PROCESSO*\n               R VARIABLE(S)'\n         HT '  (AN S,W, OR N FOLLOWED BY A DIGIT). <CEXPR> IS A CHARACT*\n               ER STRING OR'\nVALUEFIN HT '  AN ARITHMETIC EXPRESSION'\nVOLBEG   HT 'VOLUME <VOLUME> - SETS THE DEFAULT VOLUME IF NO OTHER IS S*\n               PECIFIED'\n         HT '  WITH THE FOLLOWING COMMANDS: USE,SAVE,SCRATCH,COPY FROM,*\n                SHOW DSNAMES'\nVOLFIN   HT '  AND SHOW DIRECTORY'\n         PRINT GEN\nSETBL3   SCKW  TABS,TABS,A\n         SCKW  UPPER,UPPER,A\n         SCKW  UPLOW,UPPER,A\n         SCKW  VOLUME,VOLUME,A\n         SCKW  USER,USER,A\n         SCKW  SKIP,SKIP,A\n         SCKW  VALUE,VALUE,A\n         SCKW  FASTLIST,SLOWLIST,A\n         SCKW  SLOWLIST,SLOWLIST,A\n         SCKW  CRT,CRT\n         SCKW  NOCRT,CRT,A\n         SCKW  ,TSKTSK\n         TITLE 'END OF PAGED CODE -- PAGE 41'\n         PINIT\n         PEND\n         TITLE 'CONSTANTS, ETC.'\n         COPY  WYLCONST\n         EJECT\n         COMMON ,\n         END\n./ ADD NAME=PUTB,SSI=00000002\nPUTB     TITLE 'UTILITY ROUTINE SET FOR WYLTSO'\n* PROPERTY OF C. U. C. C. A.\n         GBLC    &DCEC             SWITCH FOR DCEC MODS         JEP00X\n         GBLC  &USPS                                            USPS01\n&USPS    SETC  '1'                                              USPS01\n&DCEC    SETC   '1'  CHANGE TO ANY OTHER NUM. TO DELETE DCEC MODJEP00X\n         AIF   ('&DCEC' NE '1').LBL01                           JEP00X\n*                                                               JEP001\n*                                                               JEP001\n* MOD JEP001                                                    JEP001\n*  RESTRUCTURE NAMING CONVENTIONS TO DCEC COMPATABILITY.        JEP001\n*  MODULES AFFECTED: PDIO, PEDS, PUTB,INIT MACROS(DSNWA,CVTSO)  JEP001\n*  JERRY E PITTENGER                                            JEP001\n*                                                               JEP005\n*                                                               JEP005\n* MOD JEP005                                                    JEP005\n*  ADDED CODE TO TURN OFF FLAGS FOR UPPER & LOWER CASE          JEP005\n*  OPERANDS OF THE CHANGE COMMAND. DENOTED JEP005 62/68.        JEP005\n*  MODULES AFFECTED: PDOS, PGOS, PUTB, MACRO(CPTSO)             JEP005\n*                                                               JEP005\n*                                                               JEP005\n.LBL01   DS    0H                                               JEP00X\n         SPACE  3\nPUTB     CSECT\n         SPACE\n         WIDENT 001\n         SPACE\n         USING CPAREA,R12\n         SPACE\n         XTRNS ,\n         TITLE 'DESPOT ROUTINE'\n* DESPOT IS SENT AN ADDRESS IN R15 TO WHICH TO PASS CONTROL EACH TIME A\n*      LINE IN THE RANGE IS LOCATED.\n*\n* THE FIRST BYTE OF R15 ARRIVES WITH OTHER CODES AS FOLLOWS ---\n*  DESRTRN = X'80' - MEANS LEAVE DESPOT WITH RETURN\n*  DESNRTN = X'00' - MEANS LEAVE DESPOT WITH CALL TO CMDPRT\n*  LEXATRTN = X'40' MEANS USE LOCATEEX\n*  LXCATRTN = X'60' MEANS USE LXCATE\n*  LOCATRTN = X'00' MEANS USE LOCATE\n*  DESMATCH = X'10' - MEANS LOCATE AN ACTUAL LINE (I.E.: IF AT END\n*            OF A TEXT PAGE, POINT AHEAD TO FIRST LINE NEXT PAGE.)\n*            (POINT AT A REAL LINE, NOT A HOLE IN TEXT AREA.)\n*  DESNMTCH = X'00' - MEANS POINT AT END PREVIOUS PAGE IN THIS CASE.\n*\n*   PREST = X'00' - RETURN PRESSED LINE (R15 POINTS TO IT)\n*  UNPRST = X'01' - RETURN UNPRESSED LINE (R1=LOC, R0=LEN)\n*\n* DESRELA = '02' MEANS THAT THE ROUTINE ADDRESS IS A RELATIVE\n*              ADDRESS BASED OFF THE CODE-PAGE IN R10\n* DESRELA = '00' MEANS THAT THE ROUTINE ADDRESS IS ABSOLUTE\n*\n* BOTH EXPLICIT AND ASSOCIATIVE RANGES ARE HANDLED\n         SPACE\nDESPOT   XENTER R2,R8,C32+12+SZR+8      REGS & SPACE\n         ST    R15,RTNAD(R8)            ROUTINE ADDR (& FLAGS)\n         SR    R2,R2                    SET\n         ST    R2,OCCURS(R8)            VOID RANGE\n         LM    R3,R6,CPCMPST            PICK ASSOC CELLS\n         MVC   C32+12+SZR(8,R8),CPFSLN  SAVE FIRST RANGE ELEMENT\n         TM    CPLFLG4,CPFDESRT    RE-ENTRY TO DESPOT\n         BO    TSTKICK             BRANCH YES TO GET NEXT LINE\n         STH   R2,CPMDLN                SET NO DISJOINTS YET\n         TM    CPLFLG5,CPFNCUR     SUPPRESS CURRENT LINE UPDATE\n         BO    NEWROUND            BRANCH YES\n         TM    RTNAD(R8),LXCATRTN  DETERMINE RANGE SELECTION FILE\n         BO    NEWROUND            GO ON IF FROM EXTERNAL FILE\n         BM    DOEXEC              BRANCH IF FROM EXEC\n         MVI   CPCURRL,X'F0'       SET INVALID * FOR ACTIVE FILE\n         B     NEWROUND            GO INITIALIZE RANGE\n         SPACE\nDOEXEC   MVI   CPEXLINE,X'F0'      SET INVALID * FOR EXEC FILE\nNEWROUND MVC   CPNWLN(4),CPFSLN         SETUP FOR START\nDONEXT   LA    R1,CPNWLN                POINT AT LINE-NO TO LOCATE\n         TM    RTNAD(R8),LXCATRTN       WHICH LOCATE?\n         LA    R14,LOCATED         RETURN ADDR\n         BZ    LOCATE         USE LOCATE\n         BO    LXCATE         USE LXCATE\n         B     LOCATEEX            USE LOCATEEX\n         EJECT\nLOCATED  ST    R15,PRESTPT(R8)          POINTER AT PREST LINE\n         MVC   CPNWLN(4),CPLCNO         SAVE LOCATED LINE NO\n         TM    CPDRPT,CPFNTYT+CPFHIGH   TOO HIGH ALREADY?\n         BNZ   QUESFIN\n         CLC   CPNWLN(4),CPLSLN    TOO HIGH?  NOTE: FOR COUNT\n         BH    QUESFIN             RANGE CPLSLN WILL BE HIGH\n         TM    CPDRPT,CPFMTCH           LINE NO. REALLY EXISTS?\n         BZ    TSTNXLN                  NO\nLOCATDD  TM    CPSTAD,CPFSTRRG+CPFLIMRG+CPFONERG+CPFBLKRG ASSOC TYPE\n         BZ    TSTPRST                  NO\n         LA    R1,WRKAREA(R8)           GET UNPRESSED\n         CVCALL UNPRESS\n         LTR   R2,R0                    COUNT = 0, BLANKLINE\n         BNP   ITSBLK                   YEP\n         TM    CPSTAD,CPFBLKRG          BLANK LINES?\n         BO    KACKNEX                 YES - NOT IN RANGE\n         STC   R5,CPSTCNT          SAVE LENGTH-1\n         TM    CPSTAD,CPFONERG          STR START POS GIVEN?\n         BO    GOTONE                   YES\n         MVC   CPSTCNT+1(1),0(R6)       SAVE CHAR\n         TM    CPSTAD,CPFSTRRG          ASSOC IN ALL OR DEFINED CHARPOS\n         BZ    GOTLIM                   DEFINED\n         CH    R2,=Y(MXPRTSZ)           133 CHARS?\n         BNL   CHKIT                    YES\n         LA    R2,1(R2)                 END SCAN AT NO. CHARS PLUS ONE\nCHKIT    LA    R15,0(R2,R5)             LAST START +(LEN-1) LE MXPRTSZ\n         CH    R15,=Y(MXPRTSZ)          COMPARE\n         BNH   MCLI                     OK\n         LA    R2,MXPRTSZ               FIXUP\n         SR    R2,R5\nMCLI     CLC   0(1,R1),CPSTCNT+1        FIRST CHAR?\n         BE    MCLC                     YES\nMRCMP    LA    R1,1(R1)                 KICK\n         BCT   R2,MCLI                  MORE?\n         B     KACKNEX                 NOT IN LINE\n         SPACE\nCLCINSTR CLC   0(0,R1),0(R6)       CHECK\nMCLC     ST    R14,0(,R13)         SAVE A REG\n         IC    R14,CPSTCNT         GET LENGTH-1\n         EX    R14,CLCINSTR\n         L     R14,0(,R13)         RESTORE.. LEAVE CC UNCHANGED\n         BNE   MRCMP                    NOT THIS\nQUESLIN  LA    R1,WRKAREA(R8)           SET R1 TO UNPRESSED\n         TM    CPSTAD,CPFMODS           MODS\n         BZ    TRNSMAT                 NO\n         L     R2,OCCURS(R8)            INCREASE OCCURANCE COUNT\n         LA    R2,1(R2)\n         ST    R2,OCCURS(R8)\n         LA    R15,CPMDAD               ADDR OF MODS\n         L     R14,CPMDLN               COUNT\nTRYNXMD  CH    R2,0(R15)                LESS NOT IN\n         BL    KACKNEX\n         CH    R2,2(R15)                GTR NOT IN\n         BL    TRNSMAT                 GOT ONE\n         BE    TRNSMATE                GOT ONE\nTRYMRMD  LA    R15,4(R15)               KICK PTR\n         BCT   R14,TRYNXMD              MORE\n         TM    CPLFLG1,CPFNOTRG        \"NOT\" WANTED?\n         BZ    QUESFIN                 NO\n         SPACE\n* TEST FOR \"NOT\" LOGIC\nKACKNEX  TM    CPLFLG1,CPFNOTRG        \"NOT\" WANTED?\n         BZ    KICKNEX                 NO\n         LA    R1,WRKAREA(R8)          SET R1 TO UNPRESSED LINE\n         B     TRNSMIT                 SHIP\n         SPACE\nTRNSMATE BCT   R14,TRNSMAT             TEST FOR MORE MODS\n         TM    CPLFLG1,CPFNOTRG        \"NOT\" WANTED?\n         BO    KICKNEX                 YES, SKIP TO NEXT RECORD\n         MVC   CPLSLN(4),CPNWLN        FORCE AS LAST LINE\nTRNSMAT  TM    CPLFLG1,CPFNOTRG        \"NOT\" WANTED?\n         BZ    TRNSMIT                 NO, TRANSMIT THE RECORD\n         B     KICKNEX                 SKIP THE RECORD\n         EJECT\nITSBLK   TM    CPSTAD,CPFBLKRG          TEST BLANK LINE RANGE\n         BO    QUESLIN                  YES\n         B     KACKNEX                 NIX\n         SPACE\nGOTLIM   LA    R1,0(R1,R3)              SET LIMITED SCAN\n         LR    R2,R4\n         B     CHKIT                    SCAN\n         SPACE\nGOTONE   LA    R1,0(R1,R3)              SET SINGLE LOOK\n         ST    R14,0(,R13)\n         IC    R14,CPSTCNT\n         EX    R14,CLCINSTR\n         L     R14,0(,R13)\n         BE    QUESLIN                  GOT ONE\n         B     KACKNEX                 NIX\n         SPACE\nTSTNXLN  TM    CPSTAD,CPFEXPRG          TRY NEXT IN NOT EXPL RNG\n         BZ    KICKUP\n         TM    RTNAD(R8),DESMATCH       WHAT IS WANTED?\n         BZ    TSTPRST                  THIS\nKICKUP   OI    CPDRPT,CPFMTCH          SET LOCATED LINE THERE\n         TM    CPDRPT,CPFPGHI          LAST LINE ON PAGE LOCATED\n         BZ    LOCATDD                 BRANCH NO\n         B     DONEXT                   AND DO NEXT\n         SPACE\nTSTPRST  TM    RTNAD(R8),UNPRST         PREST WANTED\n         BZ    TRNSMIT                  YES\n         LA    R1,WRKAREA(R8)           UNPRESS\n         CVCALL UNPRESS\nTRNSMIT  TM    CPLFLG5,CPFNCUR     UPDATE CURRENT POINTER\n         BO    TRNSMIT2            NO\n         L     R14,CPLCNO          GET LINE NUMBER TO UPDATE\n         TM    RTNAD(R8),LXCATRTN  SELECT FROM EXEC OR ACTIVE\n         BNZ   TRNSMIT1            BRANCH IF EXEC OR EXTERNAL\n         ST    R14,CPCURRL         UPDATE CURRENT FOR ACTIVE FILE\n         B     TRNSMIT2            GO TRANSMIT LINE\n         SPACE\nTRNSMIT1 BO    TRNSMIT2            NO UPDATE IF EXTERNAL LINE\n         ST    R14,CPEXLINE        UPDATE CURRENT EXEC LINE\nTRNSMIT2 LM    R14,R15,RTNAD(R8)        RTN ADDR & PREST POINTER\n         OI    CPSTAD,CPFSOME           SET SOMETHING\n         TM    RTNAD(R8),DESRELA    IS ROUTINE ADDRESS REL OR ABS\n         BZ    *+6                 BR IF ABSOLUTE ADDR\n         ALR   R14,R10             ADD IN CODE-BASE IF RELATIVE\n         BALR  R14,R14                  GET IT TO WORK ROUTINE\nTSTKICK  TM    CPLFLG4,CPFDESET    HAS CPNWLN BEEN SET BY WORK\n         BE    KICKNEX             BRANCH NO\n         NI    CPLFLG4,255-CPFDESET YES, RESET FLAG\n         L     R0,CPNWLN           LOAD VALUE OF CPNWLN\n         B     TSTRNGTP            GO TEST IF AT END OF RANGE\n         EJECT\nKICKNEX  LA    R1,1                     INCREMENT LINE NO\n         L     R0,CPNWLN                PICKUP LAST LINE NO SENT\n         CVCALL ADDER\n         BM    QUESFIN                  TOO BIG.\n         ST    R0,CPNWLN                SET FOR NEXT LOCATE\nTSTRNGTP TM    CPLSLN,FRNGTYP      TEST COUNT OR EXPLICIT END\n         BZ    GOTNEX              BRANCH EXPLICIT END\n         LH    R1,CPLSLN+2         GET REMAINING COUNT\n         BCT   R1,GOTCNT           DECR AND BR IF NOT END\n         B     QUESFIN             GO TEST IF FINISHED\n         SPACE\nGOTCNT   STH   R1,CPLSLN+2         SAVE REMAINING COUNT\n         B     DONEXT              GO DO NEXT LINE\n         SPACE\nGOTNEX   C     R0,CPLSLN                UNLESS TOO BIG\n         BNH   DONEXT                   DO NEXT\nQUESFIN  TM    CPSTAD,CPFDSJNT          DISJOINT OR DONE\n         BZ    FINISH\n         LH    R1,CPMDLN                DISJOINT LENGTH\n         LA    R2,1(R1)                 PLUS 1 INTO R2\n         CH    R2,CPMDLN+2              DONE?\n         BH    FINISH                   YES\n         SLL   R1,2                     DISPLACEMENT INTO LIST\n         LA    R1,CPMDAD(R1)            ADDR ITEM\n         MVC   CPFSLN(8),0(R1)          MOVE LINE NOS\n         BE    DUNWUN                   FINISHED\n         TM    CPLSLN,FRNGTYP           ONE LINE RANGE?\n         BZ    DUNWUN                   YES\n         LA    R2,1(R2)                 KICK COUNTER\n         BNO   DUNTWO              BRANCH IF COUNT RANGE\n         NI    CPLSLN,255-FRNGTYP       PUT INTO LEGAL LINE NO\n         B     DUNTWO                   FINISH OFF\n         SPACE\nDUNWUN   MVC   CPLSLN(4),CPFSLN         SET E-O-RANGE\nDUNTWO   STH   R2,CPMDLN                RESTORE COUNTER\n         B     NEWROUND                 DO NEXT SUB-RANGE\n         EJECT\nFINISH   MVC   CPFSLN(8),C32+12+SZR(R8) RESET FIRST RANGE ELEMENT\n         TM    CPSTAD,CPFSOME           SET NOT VOID RANGE\n         BO    FINITO                   DONE\n         TM    CPGFLG2,CPFEXEC+CPFEXTER  IS IT EXEC AND TERSE\n         BO    FINITO              BRANCH IF SO\n         TSEG  'VOID RANGE',,M          MSG\n         AIF   ('&DCEC' NE '1').LBL02                           JEP00X\nFINITO   NI    CPLFLG4,255-CPFCHUP-CPFCHLO     TURN OFF FLAGS   JEP005\n         TM    RTNAD(R8),DESRTRN   LEAVE                        JEP005\n         AGO   .LBL03                                           JEP00X\n.LBL02   DS    0H                                               JEP00X\nFINITO   TM    RTNAD(R8),DESRTRN        LEAVE\n.LBL03   DS    0H                                               JEP00X\n         BZ    CVGETCOM\n         XEXIT R2,R8\n         TITLE 'DETRNG ROUTINE'\nDETRNG   XENTER R2,R8,C40               REG SAVES\n         TM    CPLFLG5,CPFSELOC    WHERE IS RANGE TO BE SELECTED\n         BO    SETEXT              BRANCH IF EXTERNAL\n         BM    SETEXEC             BRANCH IF EXECUTE\n*                                  OTHERWISE, IT IS ACTIVE FILE\n         CLC   CPAGCT(2),=Y(0)          ANYTHING AT ALL?\n         BE    ITSNIL              NO\n         MVC   CPFSLN,CPDREC       SET DEFAULT\n         MVC   CPFSLN+4,CPHIPS          ALL FOR ACTIVE FILE\n         B     NOTNIL\n         SPACE\nSETEXT   XC    CPFSLN,CPFSLN       SET DEFAULT\n         MVC   CPFSLN+4,=F'99999999'    ALL FOR EXTERNAL FILE\n         B     NOTNIL\n         SPACE\nSETEXEC  CLC   CPEXCNT(2),=Y(0)    ANYTHING AT ALL?\n         BE    ITSNIL              NO\n         MVC   CPFSLN(4),CPEXDIR   SET DEFAULT\n         MVC   CPFSLN+4,CPEXHIPS        ALL FOR EXEC FILE\nNOTNIL   OI    CPSYSFLG,CPFRNGCM        SET MULTI-LINE EFFECTS\n         MVI   CPSTAD,CPFEXPRG          SET EXPLICIT RANGE\n         LA    R6,HVFRSNO          SET FOR LINE NUMBER FOUND\n         LA    R2,EXRPRT0              FIRST PRT ADDR\nDETSCAN  SCANSAVE ,       SAVE TEMP DETRNG SCAN POINTERS\n         LR    R1,R2                    SET CURRENT PRT ADDR\nGOSCAN   SCAN  (1)                      SCAN\n         BM    CVNVALID                 NG\nCKIFLPRM TM    CPLFLG1,CPFALL          DEFAULT ALL OK\n         BZ    DETEXPRQ\n         NI    CPLFLG1,255-CPFALL      TURN OFF TO INDICATE DEF\nRESTORS  SCANRSTR ,       RESTORE TEMP SAVED DETRNG PTRS\nDETXIT   XEXIT 2,8\n         SPACE\nDETEXPRQ TSEG  'EXPLICIT RANGE MISSING' SET MESSAGE\n         B     CVQTYPE             GO WRITE OUT ERROR\n         EJECT\nSETNOTT  OI    CPLFLG1,CPFNOTRG        SET \"NOT\" RANGE LOGIC\n         LA    R2,EXRPRTA              SET NEXT SCAN\n         B     DETSCAN                 SCAN ON\n         SPACE\nHAVSOM1  LTR   R2,R2                    WAS \"IN\" LAST?\n         BZ    CVNVALID                 YES\n         CLI   0(R1),C''''              SINGLE QUOTE?\n         BE    HAVASSC                  YES\n         CLI   0(R1),C'\"'               DOUBLE QUOTE?\n         BNE   CKIFLPRM                 NO\nHAVASSC  CLC   CPCMNM(3),=C'ALI'        ALIGN ILLEGAL\n         BE    BADASSC\n         CLC   CPCMNM(3),=C'JUS'   IS IT JUSTIFY COMMAND\n         BE    BADASSC             BRANCH YES\n         CLC   CPCMNM(3),=C'SAV'   IS SAVE COMMAND\n         BE    BADASSC             BRANCH YES\n         CVCALL DQSCAN         REMOVE ENCLOSING + DOUBLE QUOTS\n         LTR   R2,R0                    BLANK LINE RANGE?\n         BZ    BLKSRNG                  YES\n         MVC   SZR(C40,R8),0(R8)        MOVE OUT SAVED REGS\n         ST    R8,CPSTAD                ADDR TO MOVE STRING TO\n         MVI   CPSTAD,CPFSTRRG          SET FOR SIMPLE ASSOC. RANGE\n         BCTR  R2,0                     STRING LENGTH MINUS ONE\n         ST    R2,CPSTLN                SAVE STRING LEN (MINUS 1)\n         EX    R2,MOVSTRNG              MOVE IT\n         LA    R2,4(R2)                 MULTIPLE OF 4 GTR/EQU STRNG LEN\n         N     R2,=F'-4'\n         LR    R3,R8                    SAVE OLD R8 VALUE\n         LA    R8,0(R2,R8)              NEW R8\n         LA    R13,0(R2,R13)            NEW R13\n         MVC   0(C40,R8),SZR(R3)        PUT BACK SAVED REGS\n         L     R3,C28(R8)               SAVED REG 8\n         LA    R3,0(R2,R3)              KICK VALUE\n         ST    R3,C28(R8)               RESET\nNXTSCN   LA    R2,RNGPRT2               NEXT PRT ADDR\n         B     DETSCAN                  SCAN MORE\n         SPACE\nBADASSC  TSEG  'ASSOCIATIVE RANGE NOT ALLOWED'\n         B     CVQTYPE\n         SPACE 3\nHAVSOM2  BCTR  R15,0                    REDUCE BY ONE\n         ST    R15,CPCMPST              SAVE START POSITION\n         L     R2,CPSTLN                STRING LEN\n         AR    R2,R15                   PLUS START\n         CH    R2,=Y(MXPRTSZ-2)         POSSIBLE?\n         BH    CVNVALID                 NO\n         MVI   CPSTAD,CPFONERG          SET STRING START POSITION GIVEN\n         LA    R2,RNGPRT3               SET NEXT PRT\n         B     DETSCAN                  GO SCAN\n         SPACE 3\nHAVSOM3  S     R15,CPCMPST              LENGTH PLUS ONE CONTAINING STR\n         BNP   CVNVALID                 NG\n         S     R15,CPSTLN               LENGTH POSSIBLE START CHARS\n         BNP   CVNVALID\n         ST    R15,CPCMPLN              STORE NO POSSIBLE 1ST CHAR POS\n         MVI   CPSTAD,CPFLIMRG          SET FOR LIMITED SCAN\n         LA    R2,RNGPRT5               SET NEXT PRT\n         B     DETSCAN                  GO SCAN\n         SPACE 3\nHAVSOM4  CLI   0(R1),C'('               NEED LEFT-PAREN\n         BNE   CKIFLPRM                 NO\nHAVMODS  SCANSAVE ,                TEMP DETRNG PTR SAVE\n         SH    R0,=Y(2)                 STRIP PARS\n         BNP   CVNVALID                 INVALID MSG\n         LA    R1,1(,R1)                KICK PTR\n         SCINIT (1),(0)                 INIT INSIDE PARENS\n         OI    CPSTAD,CPFMODS           SET MOD INDICATOR\n         SR    R5,R5                    ZERO MOD COUNT\n         ST    R5,CPMDLN               INIT\n         LA    R6,CPMDAD-4              AND SET ADDR\nNXMDSCN  SCAN  MODPRTA                  SCAN FOR A MOD\n         B     FINMOD                   DONE\n         EJECT\nGOTAMOD  LA    R5,1(R5)                 COUNT\n         CH    R5,=Y(10)                10 IS MAX\n         BH    CVNVALID                 NG\n         CH    R15,2(,R6)              ARE MODS ASCENDING\n         BNH   CVNVALID                BRANCH NO, ILLEGAL\n         LA    R6,4(R6)                 SET ADDR\n         STH   R15,0(R6)                STORE\n         STH   R15,2(R6)                ASSUME NO SLASH\n         SCAN  MODPRTB                  LOOK FOR SLASH OR NEXT MOD\nFINMOD   ST    R5,CPMDLN                STORE NUMBER OF MODS\n         SCANRSTR ,      RESTORE TEMP SAVED DETRNG PTRS\n         LA    R1,RNGPRT6               SET NEXT PRT ADDR\n         B     GOSCAN                   GO SCAN\n         SPACE\nGOTBMOD  CH    R15,2(R6)                IS IT LEGAL?\n         BL    CVNVALID                 NO\n         STH   R15,2(R6)                STORE\n         B     NXMDSCN                  GO FOR MORE\n         EJECT\nTRYEXPL  SCANRSTR ,      RESTORE TEMP SAVED DETRNG PTRS\n         LA    R2,1                     SET FOR NO \"IN\" ENCOUNTERED\n         LA    R6,HVFRSNO          SET FOR LINE NUMBER FOUND\n         LA    1,EXRPRT1                SET PRT ADDR\n         B     GOSCAN                   SET ESCAPE FOR LIST-PUNCH-RUN\n         SPACE\nBLKSRNG  MVI   CPSTAD,CPFBLKRG          SET BLANK LINE RANGE\n         B     NXTSCN\n         EJECT\nHAVEXPL  SR    R2,R2                    SET FOR \"IN\" & 1ST TIME\n         LA    R6,HVFRSNO          SET FOR LINE NUMBER FOUND\n         SCANSAVE ,                SAVE CURRENT SCAN POINTERS\n         SCAN  EXRPRT1                  LOOK FOR 1ST EXPLICIT RANGE ITM\n         B     DETEXPRQ                 NG\n         SPACE\nHVFRSNO  ST    R0,CPFSLN                SET 1ST LINE NO.\n         MVC   CPLSLN(4),CPFSLN         SET ONE LINE RANGE DEFAUL\nSCANGAN  MVC   C32(8,R8),CPTELL    SAVE POINTER BEFORE THIS RANGE\n         SCANSAVE ,      SAVE TEMP DETRNG SCAN POINTERS\n         LA    R6,NUMSET           SET ADDR FOR LINE NUMBER\n         SCAN  EXSLPRT                  LOOK FOR SLASH\n         B     DETXIT\n         SPACE\nHVLSTNO  ST    R0,CPLSLN                STORE\n         CLC   CPLSLN(4),CPFSLN         MAKE SURE EORANGE NOT LES\n         BNL   SCANGEN             OK, GOASCAN ON\nHVINVAL  LM    R1,R2,CPSAVE        GET LAST TOKEN POINTER\n         LA    R2,0(R1,R2)         SAVE POINTER PAST TOKEN\n         SCANRSTR C32(R8)          RESET BEFORE THIS RANGE\n         SCTELL (1),(0)            GET POINTER BEFORE RANGE\n         LR    R0,R2               CALCULATE LENGTH\n         SR    R0,R1                     OF PROMPT MESSAGE\n         TSEG  (1),(0)             PUT OUT BAD RANGE\n         TSEG  ': BAD RANGE'       FINISH MESSAGE\n         B     CVQTYPE             ABORT THE COMMAND\n         EJECT\nSCANGEN  SCANSAVE ,      RESTORE TEMP DETRNG POINTERS\nSCANGEN1 LA    R6,NUMSET           SET ADDR FOR LINE NUMBER\n         SCAN  EXRPRT3                  SCAN FOR DISJOINT ITEM\n         B     DETXIT                   FINISHED\n         SPACE\nNUMSET   TM    CPSTAD,CPFDSJNT          DISJOINT SET?\n         BO    NTFRST                   YES\n         TM    CPSTAD,CPFMODS           MODS USED?\n         BO    CVNVALID                 CAN'T HAVE DISJOINT\n         OI    CPSTAD,CPFDSJNT          SET DISJOINT\n         XC    CPMDLN(4),CPMDLN         START COUNT\nNTFRST   BAL   R3,SETMOD                COUNT\n         ST    R0,CPMDAD-4(R2)          STORE LINE-NO\n         B     SCANGAN                  MORE?\n         SPACE\nSETMOD   L     R2,CPMDLN           GET CURRENT NUMBER COUNT\n         LA    R2,1(,R2)           INCREMENT\n         CH    R2,=Y(10)           MORE THAN MAX ALLOWED\n         BH    CVNVALID            BRANCH YES\n         ST    R2,CPMDLN           SAVE NEW COUNT\n         SLL   R2,2                SHIFT FOR INDEX\n         BR    R3                  RETURN\n         EJECT\nGOTXSLS  LA    R1,EXRPRT2               SET PRT ADDR\n         LA    R6,HVLSTNO          SET ADDR FOR LINE NUMBER\n         TM    CPSTAD,CPFDSJNT          RIGHT ADDR?\n         BZ    RGHTWUN                  YES\n         LA    R6,NUMBSET               SET OTHER\nRGHTWUN  SCAN  (1)                 SCAN\n         B     CVABSENT                 NEED SOMETHING\n         SPACE\nNUMBSET  BAL   R3,SETMOD           COUNT\n         ST    R0,CPMDAD-4(R2)     SAVE LINE NUMBER\n         LA    R2,CPMDAD-8(R2)     POINT TO START OF RANGE\n         OI    4(R2),FRNGTYP       SET NORMAL TWO LINE RANGE\n         C     R0,0(R2)            TEST VALID RANGE\n         BNL   SCANGEN                  MORE?\n         B     HVINVAL             GO REPORT ERROR\n         SPACE\nMOVSTRNG MVC   0(0,R8),0(R1)\n         SPACE\nTSTCNT   CLI   0(R1),C'('          IS IT COUNT\n         BNE   RESTORS             NO\n         SCANSAVE ,                SAVE CURRENT POSITION\n         SH    R0,=Y(2)            REDUCE COUNT FOR ()\n         BNP   CVNVALID            INVALID IF NEGATIVE\n         LA    R1,1(,R1)           POINT PAST (\n         SCINIT  (1),(0)           INIT SCANNER\n         SCAN  CNTPRT              SCAN FOR COUNT\n         B     CVNVALID            INVALID IF NONE\n         SPACE\nCNTOK    LR    R4,R15              SAVE COUNT\n         SCAN  ,                   SEE IF ANYTHING ELSE\n         SCANRSTR ,                RESTORE SCANNER\n         BP    CVNVALID            YES, INVALID\n         TM    CPSTAD,CPFDSJNT     FIRST COUNT OR DISJOINT\n         BNZ   CNTOK1              BRANCH IF DISJOINT\n         ST    R4,CPLSLN           SAVE COUNT\n         OI    CPLSLN,FRNGTYP-FNEGBT INDICATE COUNT RANGE\n         B     SCANGEN1            GO SCAN ON\n         SPACE\nCNTOK1   BAL   R3,SETMOD           COUNT\n         ST    R4,CPMDAD-4(R2)     SAVE COUNT\n         LA    R2,CPMDAD-4(R2)     POINT TO SAVE ADDRESS\n         OI    0(R2),FRNGTYP-FNEGBT INDICATE COUNT RANGE\n         B     SCANGEN1            SCAN ON\n         EJECT\nITSNIL   GENTER ,                       SET BASE REG\n         TM    CPLFLG5,CPFSELOC    TEST IF NO EXEC OR NO ACTIVE\n         BNZ   ITSNIL1             BRANCH IF NO EXEC\n         TSEG  'NO ACTIVE FILE'\n         B     CVQTYPE\n         SPACE\nITSNIL1  TSEG  'NO EXEC FILE'\n         B     CVQTYPE\n         EJECT\nRNGPRT2  SCKW  IN,HAVEXPL\n         SCKW  ,HAVSOM2,PI,133\n         SCKW  ,HAVSOM4\nRNGPRT3  SCKW  /,HAVSOM3,(P,PI),133\nRNGPRT5  SCKW  IN,HAVEXPL\n         SCKW  ,HAVSOM4\n         SPACE\nRNGPRT6  SCKW  IN,HAVEXPL\n         SCKW  ,CKIFLPRM\n         SPACE\nMODPRTB  SCKW  /,GOTBMOD,(P,PI)\nMODPRTA  SCKW  ,GOTAMOD,PI\n         SCKW  ,INVALID\n         SPACE 3\nEXRPRT0  SCKW  \u00ac,SETNOTT\nEXRPRT1  SCKW  ALL,DETXIT\n         SCKW  ,LNENOPRT,PUSH\nEXRPRTA  SCKW  ,HAVSOM1\n         SPACE\nEXRPRT2  SCKW  ,LNENOPRT,PUSH\n         SCKW  ,INVALID\n         SPACE\nEXSLPRT  SCKW  /,GOTXSLS\nEXRPRT3  SCKW  ,LNENOPRT,PUSH\n         SCKW  ,TSTCNT\n         SPACE\nCNTPRT   SCKW  ,CNTOK,PI,30000\n         SCKW  ,INVALID\n         EJECT\n         LTORG ,\n         TITLE 'LOCATE ROUTINE'\n* LOCATE NEEDS REG 1 POINTING AT INTERNAL LINE-NO TO LOCATE.\n*    RETURNS:\n*           R15 - POINTS TO ADDR OF LINE IN TEXT PAGE (B/4 LINE NO.)\n*           CPDRPT - ADDRESS OF DIREC ENTRY FOR LOCATE PAGE\n*           CPLCNO - LINE NO. OF LOCATED LINE\n*           CPREVLN - LINE NO. OF LINE BEFORE LOCATED LINE\n* RETURN FLAGS (IN 1ST BYTE CPDRPT)\n*    CPFNTYT -  X'80' - NO PAGE AT ALL YET EXISTS - NO OTHER RETURN\n*    CPFHIGH -  X'40' - LOCATE LINE HIGHER THAN ANY PREEXISTING WITH-\n*           CPLCNO NOT SET\n*    CPFPGHI -  X'20' - LOCATE LINE IS HIGHER THAN ANY ON LOCATE PAGE,\n*           CPLCNO HAS FIRST LINE NO. NEXT PAGE\n*    CPFPGLW -  X'10' - LOCATE LINE IS FIRST ON PAGE\n*           CPREVLN IS NOT SET IN THIS CASE\n*    CPFMTCH -  X'08' - LOCATE LINE MATCHES AN EXISTING LINE NO.\n*    CPFFSLN -  X'04' - LOCATE LINE IS FIRST OR BEFORE\n*    CPFPGND -  X'02' - LOCATE LINE IS LAST ON A PAGE\n*    CPFNDDS -  X'01' - LOCATE LINE IS LAST OF ALL\n         SPACE\nLOCATE   XENTER R0,R8,*                 SAVE REGS\nLOCBASE  MVI   CPDRPT,CPFNTYT           SET NO PAGES YET EXIT CODE\n         LH    R2,CPAGCT                GET PAGE COUNT\n         LTR   R2,R2                    ANY PAGES?\n         BNP   EXITT                    NO\n         LA    R3,CPDREC                POINT AT 1ST DIRECTORY ENTRY\n         O     R3,=X'04000000'         SET 1ST LINE OR BEFORE INDICATOR\n         CH    R2,=Y(8)             TEST PAGE COUNT\n         BNH   TRYNEX               SKIP 1ST SEARCH FOR SMALL FILES\n         LA    R4,64                SET STEP SIZE\n         LA    R5,384               SET CHARACTER STEP SIZE\n         LA    R6,3                 SET OUTER LOOP COUNT\nLOOP1    SR    R2,R4                SET REMAINING PAGE COUNT\n         BNH   LOOPEND1             END IF NOT POSITIVE\n         AR    R3,R5                SET PAGE LOCATION\n         CLC   0(4,R1),0(R3)        COMPARE LINE NUMBERS\n         BH    LOOP1                LOOP IF STILL HIGH\n         SR    R3,R5                RESET PAGE LOCATION\nLOOPEND1 AR    R2,R4                RESET REMAINING COUNT\n         SRDL  R4,2               QUARTER STEPS FOR NEXT LOOP\n         BCT   R6,LOOP1             START NEW LOOP UNTIL DONE\n         CH    R2,CPAGCT           HAS PAGE COUNT CHANGED\n         BE    TRYNEX              NO, DON'T CLEAR FLAG\n         LA    R3,0(,R3)           CLEAR 1ST LINE FLAG\nTRYNEX   BCT   R2,DOCOMP                ONLY ONE PAGE YET?\n         B     HAVPAG                   YES - IT'S THE ONE\n         SPACE\nDOCOMP   CLC   0(4,R1),6(R3)            LINE NO. LE 1ST NEXT PAGE?\n         BL    HAVPAG                   YES - IT'S THE ONE\n         LA    R3,6(R3)                 POINT TO NEXT PAGE\n         B     TRYNEX                   TRY AGAIN\n         SPACE\nHAVPAG   ST    R3,CPDRPT                DIREC ADDR LOCATED PAGE\n         LTR   R11,R11                  PAGE IN FOR R11?\n         BZ    GETITA                   NO, CHECK R9\n         PNUM  11                       WHICH PAGE IN R11?\n         CH    R0,4(R3)                 WANTED PAGE?\n         BE    HAVIT                    YES\nGETITA   LTR   R9,R9                    PAGE IN FOR R9?\n         BZ    GETIT                    NO, GET PAGE\n         PNUM  9                        WHICH PAGE IN R9?\n         CH    R0,4(R3)                 WANTED PAGE?\n         BNE   GETIT                    NO, GET IT\n         PFLIP 11,9                     FLIP R11 & R9\n         B     HAVIT                    READY\n         SPACE\nGETIT    LH    R0,4(R3)                 WANTED PAGE NO.\n         PGET  11,(0)                   GET IT\nHAVIT    L     R1,C8(R8)                POINTER TO LINE NO. TO LOCATE\n         LA    R15,2(R11)               POINT TO 1ST ITEM ON PAGE\n         LH    R5,0(R11)                TOTAL DISPLACEMENT ON PAGE\n         LA    R5,0(R5,R11)        SET LOOP END ADDRESS\n         OI    CPDRPT,CPFPGLW           SET AS 1ST LINE ON PAGE\n         SR    R6,R6                    ZERO FOR IC\n         IC    R6,4(,R15)           PRESSED COUNT OF LINE\n         CLC   0(4,R1),0(R15)       LOCATE LINE?\n         BNH   FOUND1               YES\n         NI    CPDRPT,255-CPFPGLW-CPFFSLN TURN OFF 1ST LINE FLAG\n         B     TRYGEN1              ENTER LOOP\n         SPACE\nTRYGEN   IC    R6,4(R15)                PRESSED COUNT OF LINE\n         CLC   0(4,R1),0(R15)           LOCATE LINE?\n         BNH   FOUND                    YES\nTRYGEN1  LR    R4,R15               SAVE PREV LINE NO POINTER\n         LA    R15,5(R15,R6)        KICK POINTER\n         CR    R15,R5               MORE ON PAGE?\n         BL    TRYGEN                   YES\n         MVC   CPREVLN(4),0(R4)     SET PREVIOUS LINE NO\n         LTR   R2,R2                    LAST PAGE?\n         BNZ   LSONPG                   NO\n         OI    CPDRPT,CPFHIGH           SET LAST LAST-PAGE CODE\n         B     EXITT                    DONE\n         SPACE\nLSONPG   OI    CPDRPT,CPFPGHI           LAST NOT-LAST-PAGE CODE\n         MVC   CPLCNO(4),6(R3)          1ST LINE NEXT PAGE TO CPLCNO\n         B     EXITT                    READY\n         SPACE\nFOUND    MVC   CPREVLN(4),0(R4)     SET PREVIOUS LINE NO\nFOUND1   BNE   SATLCNO                 LOCATED LINE NOT THERE\n         OI    CPDRPT,CPFMTCH           SET LOCATED LINE ALREADY THERE\nSATLCNO  LA    R4,5(R15,R6)            KICK POINTER\n         CR    R4,R5                    MORE ON PAGE?\n         BL    SETLCNO                  YES\n         OI    CPDRPT,CPFPGND           SET LAST LINE ON PAGE LOCATED\n         LTR   R2,R2                    LAST PAGE?\n         BNZ   SETLCNO                  NO\n         OI    CPDRPT,CPFNDDS           SET LAST LINE OF ALL\nSETLCNO  MVC   CPLCNO(4),0(R15)         SET CPLCNO\nEXITT    XEXIT R0,R8                    SCRAM\n         TITLE 'LOCATE LINE IN EXEC FILE'\n* PARM AND RESULTS ARE THE SAME AS FOR LOCATE\n         SPACE\nLOCATEEX XENTER R0,R8,*\n         L     R7,=A(LOCBASE)          USE SAME BASE AS LOCATE\n         USING LOCBASE,R7\n         MVI   CPDRPT,CPFNTYT          SET NO PAGES YET CODE\n         LH    R2,CPEXCNT              LOAD EXEC FILE PAGE COUNT\n         LTR   R2,R2                   TEST IF ANY PAGES\n         BNP   EXITT                   EXIT IF NONE\n         LA    R3,CPEXDIR              POINT TO EXEC DIRECTORY\n         O     R3,=X'04000000'\n         B     TRYNEX                  GO JOIN NORMAL LOCATE\n         TITLE 'LXCATE ROUTINE'\n* LXCATE NEEDS REG 1 POINTING AT INTERNAL LINE-NO TO LOCATE.\n*\n* RETURN FLAGS (IN 1ST BYTE CPDRPT) AND RETURN ITEMS ARE....\n*    CPFNTYT -  X'80' - NOTHING AT ALL - OTHERS RETURNS ALL ZERO\n*    CPFMTCH -  X'08' - GOT A LINE IN EXTERNAL DATA SET\n*\n*      R15 - POINTS TO ADDR OF LINE\n*      CPLCNO - LINE-NO OF LOCATE LINE\n         SPACE\nLXCATE   XENTER 0,8,*                   SAVE REGS\n         SR    R5,R5                    SET FOR IC INST\n         TM    CPDRED,CPFSTART          SEE IF 1ST TIME IN\n         BO    LOADEM                   NO\nREADRE   DREAD (0)                      READ A RECORD\n         BP    NDFIL                    EOF\n         BZ    NDSKERJ                  B IF DISK I/O OK\n         XCALL RDSKER                   DISK READ ERROR MSG\nNDSKERJ  OI    CPDRED,CPFSTART          SET NOT 1ST TIME\n         L     R2,CPDRED                ADDR INPUT BUFFER\n         LH    R3,0(R2)                 BYTE COUNT\n         LTR   R3,R3                    NEED POSITIVE COUNT\n         BNP   NOGGODY                  NEG NG\n         CR    R3,R0                    COMPARE TO READ COUNT\n         BH    NOGGODY                  NONSENSE\n         LA    R2,2(R2)                 POINT AT 1ST LINE\n         LA    R4,2                     STARTING COUNT FOR BUFFER\n         STM   R2,R4,CPWK1           SAVE PTR, TOTAL COUNT, START COUNT\nICAGEN   IC    R5,4(R2)                 GET NEXT PREST-COUNT\n         LA    R4,5(R4,R5)              KICK COUNT\n         LA    R2,5(R2,R5)              KICK POINTER\n         CR    R4,R3                    MORE?\n         BL    ICAGEN                   YES\n         BH    NOGGODY                  TOO MUCH\n         L     R1,8(,R8)                REPOINT R1\nLOADEM   LM    R2,R4,CPWK1              LOAD 2-3-4\n         MVI   CPDRPT,0                 SET NO MATCHING LINE NO. FOUND\nTRYMOR   CR    R4,R3                    MORE TO PROCESS?\n         BNL   READRE                   NO, READ ANOTHER RECORD\n         IC    R5,4(R2)                 PRESSED COUNT NEXT LINE\n         LR    R15,R2                   POINT AT LINE BEGINNING\n         LA    R2,5(R2,R5)              POINT AT START NEXT LINE\n         LA    R4,5(R4,R5)              KICK TOTAL COUNT\n         CLC   0(4,R15),0(R1)           AT WANTED LINE?\n         BL    TRYMOR                   NO\n         BH    NOTEQ                    NO MATCH\n         MVI   CPDRPT,CPFMTCH           SET MATCHING LINE NO. FOUND\n         STM   R2,R4,CPWK1              SAVE 2-3-4\nNOTEQ    MVC   CPLCNO(4),0(R15)         SET LOCATED LINE NO.\nEXIT     XEXIT 0,8\n         SPACE\nNDFIL    MVI   CPDRPT,CPFNTYT           SET EOF FLAG\n         B     EXIT\n         SPACE\nNOGGODY  TSEG  'EXTERNAL DATA SET MUST BE EDIT FORMAT',,M\n         DCLOSE ,                       CLOSE IT\n         NI    CPGFLG,255-CPFOPN        SET EXTERNAL DATA SET CLOSED\n         B     CVQTYPE\n         TITLE 'DODSNM ROUTINE'\n* DODSNM TAKES 1ST TOKEN FOUND AS DSNAME AND HANDLES IT.\n*\n* ERRORS ARE RESOLVED INTERNALLY\n*\n* DSNAME AREA IS DEFINED BY DSNWA COPY ENTRY AFTER CP\n*\n* REGISTERS USED BY THIS ROUTINE (MUST BE 3-6)\n         SPACE\nREND     EQU   3              END OF DSN OPERAND\nRSCAN    EQU   4              CURR OPERAND POINTER\nRDSN     EQU   5              CURR DSNAME POINTER\nRDSNL    EQU   6              CURR DSNAME LENGTH\n         SPACE\nDODSNM   XENTER R2,R8,C32+C8\n         XC    CPDSNWA(DSSIZ),CPDSNWA   CLEAR DSNAME WORK AREA\n         MVI   DSNWADSN,X'40'\n         MVC   DSNWADSN+1(DSNWACLR-1),DSNWADSN\n         SR    RDSNL,RDSNL         ZERO LENGTH COUNTER\n         LA    RDSN,DSNWADSN       ADDR OF DSNAME WORK AREA\n         SCAN  DSPRTA         SCAN FOR DSN\n         B     CVABSENT       NO OPERAND\n         SPACE 3\n* HAVE DSNAME OPERAND\n         SPACE\nAGOOD    SCANSAVE C32(R8)          SAVE SCANNER POINTERS\n         CLI   0(R1),C''''         IS IT QUOTED STRING?\n         BE    HAVQUOT             BR IF YES\n         CLI   0(R1),C'\"'          OTHER TYPE OF QUOTE?\n         BNE   AGOOD2              BR IF NOT\nHAVQUOT  CVCALL DQSCAN              GO STRIP QUOTES\n         OI    DSNWAF1,DSNFQDSN    INDICATE QUOTED DSNAME\nAGOOD2   LR    RSCAN,R1            ADDRESS OF OPERAND\n         LR    REND,R1\n         AR    REND,R0             END OF OPERAND +1\n         TM    DSNWAF1,DSNFQDSN    WAS IT QUOTED?\n         BO    MAINDSN             BR IF YES\n         SPACE\n         AIF   ('&USPS' EQ '1').XLBL01                          USPS01\n* IF 'WYL.' SPECIFIED TREAT AS FULL DSNAME\n         CLC   KWYL,0(RSCAN)\n         BE    MAINDSN\n         SPACE\n.XLBL01   DS    0H                                              USPS01\n* IF '$' SPECIFIED ITS FULL DSNAME\n         CLI   0(RSCAN),C'$'\n         BE    HAVDOL\n         SPACE\n         AIF   ('&DCEC' NE '1').LBL04                           JEP00X\n*  FULL DSN NOT SPEC - CONSTRUCT FIRST PART OF DSN AS DEFAULT   JEP001\n         XR    R1,R1               ZERO OUT WORK REG            JEP001\n         IC    R1,CVUSRFLD         PICK UP LEN OF USERID        JEP001\n         LA    R1,1(R1)            PUT LENGTH PAST THE PERIOD   JEP001\n         STH   R1,WYLDSNL          TELL EM HOW LONG             JEP001\n         BCTR  R1,0                BACK DOWN FOR MOVING IN      JEP001\n         BCTR  R1,0                BACK DOWN FOR MOVING IN      JEP001\n         EX    R1,MOVEIN           MOVE IN USERID               JEP001\n         LA    R1,1(R1)            BACK UP FOR PERIOD           JEP001\n         LR    R0,RDSN             OFFSET FOR PERIOD            JEP001\n         AR    R1,R0               CORRECT POSITION FOR PERIOD  JEP001\n         MVI   0(R1),C'.'          PUT IT IN                    JEP001\nMOVEIN   MVC   0(0,RDSN),CPUSERSV                               JEP001\n         AGO   .LBL05                                           JEP00X\n.LBL04   DS    0H                                               JEP00X\n* FULL DSN NOT SPEC - CONSTRUCT FIRST PART OF DSN AS DEFAULT\n         MVC   0(L'KWYL,RDSN),KWYL\n         MVC   DSNXG(DSNXGL-1,RDSN),CPGRPSV\n         MVI   DSNXG+DSNXGL-1(RDSN),C'.'\n         MVC   DSNXU(DSNXUL-1,RDSN),CPUSERSV\n         MVI   DSNXU+DSNXUL-1(RDSN),C'.'\n         LA    RDSNL,DSNXN\nWYLDSNL  EQU   *-2       LENGTH OF WYL DSN STD STUFF (HCON)\n.LBL05   DS    0H                                               JEP00X\n         AIF   ('&DCEC' NE '1').LBL09                           JEP00X\n         LH    RDSNL,WYLDSNL       PICK UP ID LENGTH            JEP001\n         B     DODSNOR             GO AROUND DC                 JEP001\n*WYLDSNL  DC    H'0'               LEN OF WYL DSN STD STUFF     JEP001\n.LBL09   DS    0H                                               JEP00X\n         SPACE\n* CHECK OPERAND FOR OVERRIDES\n         SPACE\nDODSNOR  CLR   RSCAN,REND     CHECK IF OPERAND EXHAUSTED\n         BNL   MAINDSN        BR IF YES\n         AIF   ('&USPS' EQ '1').XLBL03                          USPS01\n         CLI   0(RSCAN),C'@'  IS THERE GROUP ID OVERRIDE?\n         BE    OVERGRP        BR IF YES.\n.XLBL03   DS    0H                                              USPS01\n         CLI   0(RSCAN),C'&&' IS THERE USER ID OVERRIDE?\n         BNE   MAINDSN        BR IF NO.\n         SPACE\n* OVERRIDE USER ID\nOVERUSER LA    R15,CPUSER          DEFAULT SOURCE\n         B     OVERRIDE\n         SPACE\n         AIF   ('&USPS' EQ '1').XLBL04                          USPS01\n* OVERRIDE GROUP ID\nOVERGRP  LA    R15,CPGRP           DEFAULT SOURCE\n.XLBL04   DS    0H                                              USPS01\n         SPACE 3\n* COMMON ROUTINE TO OVERRIDE SPECIFIED OPERAND\n* R15=ADDRESS OF DEFAULT FIELD\n         SPACE\nOVERRIDE LA    R1,1(RSCAN)    PAST '@' OR '&'\n         CLR   R1,REND        IS CHAR ONLY ONE LEFT?\n         BE    PLUGORIG       YES - USE LOGON VALUE\n         CLI   0(R1),C'.'     IS OVERRIDE NULL?\n         BE    PLUGORIG       YES - USE LOGON VALUE\n         SPACE\n* FIND END OF OVERRIDE\n         LR    R0,REND\n         SR    R0,R1          LENGTH REMAINING IN OPERAND\n         LR    R2,R1\nORSRCH   CLI   0(R2),C'.'     IS IT DELIMITER?\n         BE    ORDELIM        BR IF YES\n         CLI   0(R2),C'#'     IS IT MEMBER SPECIFICATION\n         BE    ORDELIM        BR IF YES\n         LA    R2,1(R2)\n         BCT   R0,ORSRCH\n         SPACE\n* FOUND A DELIM FOR OVERRIDE OR END OF OPERAND\nORDELIM  SR    R2,R1          LENGTH OF OVERRIDE\n         SPACE 3\n* PROCESS OVERRIDE VALUE\n*    R1=ADDR OF OVERRIDE OPERAND\n*    R2=LENGTH OF OVERRIDE\n         SPACE\nOREADY   LR    R0,R2\n         AIF   ('&USPS' EQ '1').XLBL05                          USPS01\n         LA    R15,HAVGRP          ADDR OF GROUP OVERRIDE RTN\n         CLI   0(RSCAN),C'@'       WAS IT A GROUP OVERRIDE?\n         BE    *+8                 BR IF YES\n.XLBL05   DS    0H                                              USPS01\n         LA    R15,HAVUSER         ADDR OF USER OVERRIDE RTN\n         LA    RSCAN,1(R2,RSCAN)\n         BALR  R14,R15             GO DO OVERRIDE\nORDONE   CLI   0(RSCAN),C'.'  NORMAL DELIM?\n         BNE   MAINDSN        BR IF NO - NO MORE OVERRIDES\n         LA    RSCAN,1(RSCAN)  PAST DELIM CHAR\n         B     DODSNOR        GO TEST FOR OTHERS\n         SPACE 3\n*  OVERRIDE VALUE IS NULL - USE LOGON VALUE\n         SPACE\nPLUGORIG LR    R1,R15              ADDRESS OF SOURCE\n         SR    R2,R2               INDICATE NULL OVERRIDE\n         B     OREADY\n         EJECT\n* FULL DSN SPECIFIED WITH '$'\n         SPACE\nHAVDOL   LA    RSCAN,1(RSCAN)  BUMP PAST $\n         MVI   DSNWANL,C'$'        FLAG $ DSNAME FOR LATER\n         SPACE\n* PROCESS DSN AFTER OVERRIDES OR ENTIRE DSNAME\nMAINDSN  AR    RDSN,RDSNL     UPDATE DSN POINTER\n         LR    R2,REND             END OF OPERAND\n         SR    R2,RSCAN            LENGTH REMAINING\n         BNP   ENDSNOP             BR IF NOTHING LEFT\n         TM    DSNWAF1,DSNFQDSN    WAS IT QUOTED DSNAME?\n         BO    HVDSTR2             BR IF YES\n         SPACE\n* IF $ HERE IT'S INVALID\n         AIF   ('&USPS' EQ '1').XLBL06                          USPS01\n         CLI   0(RSCAN),C'$'\n         BE    MBRLONG\n         SPACE\n.XLBL06   DS    0H                                              USPS01\n* CHECK WHETHER USE OF PREFIX WAS SPECIFIED\n         CLI   0(RSCAN),C'*'  PREFIX CHAR?\n         BNE   NOPFX\n         SPACE\n* PREFIX TO BE USED\n         LA    RSCAN,1(RSCAN)  PAST *\n         LH    R2,CPPFXL      PREFIX LENGTH\n         LTR   R2,R2          TEST LENGTH\n         BNP   NOPFX          BR IF NULL\n         SPACE\n* INSERT PREFIX\n         LA    R15,CPPFX\n         CLI   0(R15),C'$'    IS PREFIX ENTIRE DSN SPEC\n         BNE   INSPFX         BR IF NO\n         SR    RDSN,RDSNL     START OVER AGAIN\n         LTR   RDSNL,RDSNL    TEST IF NOTHING GENERATED YET\n         BZ    NORECLR        BYPASS RE-CLEAR\n         LA    R0,X'40'       SET UP BLANK\n         STC   R0,0(RDSNL,RDSN)   BLANK ORIG DSNAME\n         BCT   RDSNL,*-4      DOESN'T CLEAR FIRST CHAR - TOUGH\nNORECLR  OI    DSNWAF1,DSNFQDSN    INDICATE QUOTED DSNAME\n         LA    R15,1(R15)     PAST $\n         BCT   R2,INSPFX      DECR LENGTH\n         B     NOPFX          BR IF $ WAS ALONE IN PFX\n         SPACE\nINSPFX   AR    RDSNL,R2       COMPUTE TOTAL DSN LENGTH\n         CH    RDSNL,=H'44'   IS THERE ROOM FOR PFX\n         BH    DSNLONG        NO\n         BCTR  R2,0           YES\n         EX    R2,PFXMVC      ADD PREFIX TO DSN\n         LA    RDSN,1(R2,RDSN)  UPDATE DSN POINTER\nNOPFX    CLR   RSCAN,REND     IS SCAN AT END OF OPERAND\n         BNL   ENDSNOP        BR IF YES\n         CLI   0(RSCAN),C'('  TEST PAREN SPECIFIED ALONE\n         BE    ENDSNOP        BR IF YES\n         SPACE\n* SCAN FOR MEMBER SPEC (#) - SCANNER TAKES CARE OF PARENS\n         LR    R0,REND\n         SR    R0,RSCAN       LENGTH REMAINING\n         LR    R2,RSCAN       CURRENT POINTER\nMEMSRCH  CLI   0(R2),C'#'\n         BE    HVDSNSTR       FOUND END OF STRING\n         LA    R2,1(R2)\n         BCT   R0,MEMSRCH\n         SPACE\n* HAVE END OF DSNAME STRING\nHVDSNSTR SR    R2,RSCAN       LENGTH OF STRING\n         BZ    ENDSNOP        BR IF NULL STRING\nHVDSTR2  AR    RDSNL,R2       COMPUTE TOTAL LENGTH\n         CH    RDSNL,=H'44'   IS IT TOO LONG?\n         BH    DSNLONG        BR IF YES\n         BCTR  R2,0\n         LR    R15,RSCAN      FOR EX MVC\n         EX    R2,PFXMVC      MOVE STRING\n         LA    R2,1(R2)       RESTORE LENGTH\n         AR    RSCAN,R2       UPDATE SCAN POINTER\n         AR    RDSN,R2        UPDATE DSN POINTER\n         SPACE\n* END OF DSN OPERAND EXCEPT MEMBER SPEC\nENDSNOP  LR    R15,RDSN       CURRENT POINT\n         SR    RDSN,RDSNL     START OF NAME\n         SPACE\n* NOW PROCESS MEMBER NAME PRESENT\n         CLR   RSCAN,REND     IS OPERAND AT THE END?\n         BNL   PARENSCN       BR IF YES\n         CLI   0(RSCAN),C'#'  IS IT #?\n         BE    HAVEMEM\n         SPACE\n* ONLY OTHER POSSIBILITY IS '('\n         B     PARENMEM\n         SPACE 3\n* END OF SCANNED STUFF - CHECK MEMBER IN PARENS OR # AFTER ''\n         SPACE\nPARENSCN SCANRSTR C32(R8)          RESTORE SCAN POINTERS\n         SCTELL ,                  FIND OUT WHAT THEY WERE\n         LTR   R0,R0               WAS THERE ANYTHING LEFT?\n         BNP   DSNDONE             BR IF FINISHED\n         CLI   0(R1),C'#'          MEMBER AFTER QUOTED DSN?\n         BE    MBRSCN              BR IF YES\n         CLI   0(R1),C'('\n         BNE   DSNDONE             NO MEMBER SPECIFIED\nMBRSCN   SCAN  DSPRTB         GO SCAN FOR MEMBER NAME\n         B     DSNDONE             DONE IF NOTHING THERE\n         SPACE 3\n* HAVE MEMBER IN PARENS OR # FOLLOWING QUOTED DSNAME\n         SPACE\nBGOOD    LR    RSCAN,R1       LOC OF LPAREN\n         LR    REND,R1\n         AR    REND,R0        LOC OF RPAREN+1\n         CLI   0(RSCAN),C'#'\n         BE    HAVEMEM\nPARENMEM BCTR  REND,0         LOC OF RPAREN\n         SPACE\n* PROCESS MEMBER NAME IN PARENS OR BY #\nHAVEMEM  LA    RSCAN,1(RSCAN) PAST # OR (\n         LR    R2,REND\n         SR    R2,RSCAN       LENGTH OF MEMBER NAME\n         BZ    NULLMBR             BR IF NULL OVERRIDE\n         CH    R2,=H'8'       CHECK LENGTH\n         BNH   REPLMEM        BR IF OK\n         SPACE\n* MEMBER NAME IS TOO LONG\nMBRLONG  ST    R2,CPSAVE      SET UP FOR\n         ST    RSCAN,CPSAVE+4   'INVALID' RTN\n         B     CVNVALID\n         SPACE\n* DSNAME IS TOO LONG\nDSNLONG  ST    RDSNL,CPSAVE   AS ABOVE\n         SR    RDSNL,R2       BACK UP TO PREV LENGTH\n         SR    RDSN,RDSNL     FIND START OF DSNAME\n         ST    RDSN,CPSAVE+4  AS ABOVE\n         B     CVNVALID\n         SPACE 3\n* INSERT SPECIFIED MEMBER NAME\n         SPACE\nREPLMEM  BCTR  R2,0\n         EX    R2,MEMMVC      MOVE MEMBER NAME\n         OC    DSNWAMBR(8),=CL8' '  MAKE SURE UPPER CASE\n         B     DSNDONE\n         SPACE 3\nPFXMVC   MVC   0(0,RDSN),0(R15)\nMEMMVC   MVC   DSNWAMBR(0),0(RSCAN)\n         EJECT\n* DONE WITH DSNAME\n         SPACE\nNULLMBR  MVI   DSNWAMBR,0          FLAG EXPLICIT NULL MEMBER\nDSNDONE  CLI   DSNWANL,C'$'        WAS IT $ DSNAME?\n         BNE   *+8                 BR IF NOT\n         OI    DSNWAF1,DSNFQDSN    FLAG $ AS QUOTED DSNAME\n         TM    CPLFLG2,CPFDSNMS    TEST NULL OK\n         BO    DOLGO               BR IF SO\nDSNDONE2 LTR   RDSNL,RDSNL\n         BP    DOLGO\n         TSEG  'DSNAME IS NULL'\n         B     CVGETCOM\n         SPACE\nDOLGO    NI    DSNWAF2,X'FF'-DSNNOVER TURN FLAG OFF\n         MVI   CPDRED,X'40'\n         MVC   CPDRED+1(7),CPDRED\n         SCANSAVE C32(R8)          SAVE CURRENT SCAN POINTERS\nSCANPRTA SCAN  SPARTA                   SCAN FOR \"ON\" & OTHERS\nDOLGO9   CLI   CPCMNM,C'R'         IS IT RENAME\n         BE    DOLGO1              YES\n         SCANRSTR C32(R8)          RESTORE SCAN POINTERS\nDOLGO1   STH   RDSNL,DSNWANL       SAVE LENGTH FOR DSNSTDDO\n         BAL   R14,DSNSTDDO        GO SET DSNAME FLAGS\n         SPACE\n* IF STD WYL DSNAME CHECK NULL AFTER USERID\n         TM    DSNWAF1,DSNFQDSN   IS IT QUOTED?\n         BO    DOLGO2              BR IF YES\n         TM    DSNWAF1,DSNFSTD   IS IT STD WYL DSN?\n         BZ    DOLGO2              BR IF NO\n         CH    RDSNL,WYLDSNL  IS WYL NAME JUST STD LENGTH?\n         BNE   DOLGO2         BR IF NO\n         SPACE\n* DEFAULT DSNAME = 'LIB'\n         TM    CPLFLG2,CPFDSNMS    IS DEFAULT PERMITTED?\n         BO    DOLGO2              BR IF NO\n         AIF   ('&DCEC' NE '1').LBL21                           JEP001\n         ST    R1,CVSPARES         SAVE FOR A MINUTE            JEP001\n         SR    R1,R1                                            JEP001\n         IC    R1,CVUSRFLD         PICK UP ID LENGTH            JEP001\n         LA    R1,1(R1)            REAL LEN + '.'               JEP001\n         LA    R1,DSNWADSN(R1)     PLUS ADDR OF DSN W/A         JEP001\n         MVC   0(3,R1),=C'LIB'         MOVE IN DEFAULT          JEP001\n         L     R1,CVSPARES         RESTORE R1                   JEP001\n         AGO   .LBL22                                           JEP001\n.LBL21   DS    0H                                               JEP001\n         MVC   DSNWADSN+DSNXN(3),=C'LIB'\n.LBL22   DS    0H                                               JEP001\n         OI    DSNWAF1,DSNFWLIB  FLAG WYLBUR LIBRARY\n         LA    RDSNL,3(RDSNL)\nDOLGO2   TM    DSNWAF1,DSNFSTD     IS IT A STANDARD NAME?\n         BZ    ANYORINV            BR IF NOT - OVERRIDES INVALID\n         AIF   ('&USPS' EQ '1').XLBL07                          USPS01\n         CLI   DSNWAGOR,0          WAS GROUP OVERRIDE SPECIFIED?\n         BE    *+10                BR IF NO\n         MVC   DSNWADSN+DSNXG(DSNXGL-1),DSNWAGOR  MOVE GROUP O/R\n.XLBL07   DS    0H                                              USPS01\n         CLI   DSNWAUOR,0          WAS USER OVERRIDE SPECIFIED?\n         AIF   ('&DCEC' EQ '1').LBLX5                           JEP001\n         BE    *+10                BR IF NO\n.LBLX5   DS    0H                                               JEP001\n         AIF   ('&DCEC' NE '1').LBL23                           JEP001\n         BE    XITHERE             BR IF NO                     JEP001\n         ST    R1,CVSPARES         SAVE FOR A MINUTE            JEP001\n         SR    R1,R1                                            JEP001\n         IC    R1,CVUSRFLD         PICK UP ID LENGTH            JEP001\n         BCTR  R1,0                DOWN FOR EX                  JEP001\n         MVC   DSNWADSN(0),DSNWAUOR  MOVE IN USER O/R           JEP001\n         EX    R1,*-6              EXEC ABOVE MOVE              JEP001\n         L     R1,CVSPARES         RESTORE R1                   JEP001\n         AGO   .LBL24                                           JEP001\n.LBL23   DS    0H                                               JEP001\n         MVC   DSNWADSN+DSNXU(DSNXUL-1),DSNWAUOR  MOVE USER O/R\n.LBL24   DS    0H                                               JEP001\n         B     XITHERE             ALL DONE\n         SPACE\n         AIF   ('&USPS' EQ '1').XLBL08                          USPS01\nANYORINV CLI   DSNWAGOR,0          GROUP SPECIFIED?\n         BE    ANYOR2              BR IF NOT\n         TSEG  DSNWAGOR,2,B\n         AGO   .LBL18                                           JEP00X\n.XLBL08   DS    0H                                              USPS01\nANYORINV DS    0H        ANY OVERRIDE SPECIFIED IS INVALID      JEP001\n.LBL18   DS    0H                                               JEP00X\nANYOR2   CLI   DSNWAUOR,0          USER SPECIFIED?\n         BE    ANYOR3              BR IF NOT\n         TSEG  DSNWAUOR,3,B\n         AIF   ('&USPS' EQ '1').XLBL09                          USPS01\nANYOR3   OC    DSNWAGOR,DSNWAUOR   TEST NEITHER SPECIFIED\n         BZ    XITHERE             BR IF NEITHER SPECIFIED\n         TSEG  'IGNORED',,M\n         XC    DSNWAGOR(L'DSNWAGOR+L'DSNWAUOR),DSNWAGOR\n         AGO   .LBL19                                           JEP00X\n.XLBL09   DS    0H                                              USPS01\nANYOR3   DS    0H                                               JEP001\n.LBL19   DS    0H                                               JEP00X\nXITHERE  BAL   R14,DSNUDSDO        GO SET USER DATA SET FLAGS\n         LR    R0,RDSNL\n         STH   R0,DSNWANL          SAVE DSNAME LENGTH\n         XEXIT 2,8\n         EJECT\nHAVOLM   CH    R0,=Y(6)                 NOT OVER 6 CHARS\n         BH    CVNVALID                 TOO BIG\n         MVC   DSNWAVOL(6),0(R15)       MOVE VOLUME NAME\n         BR    R14                      MORE?\n         SPACE\nRESCAN   CLI   CPCMNM,C'R'               RENAME\n         BE    CVNVALID                  YES\n         BR    R14                       MORE?\n         SPACE\nTESTDSN  CLC   =C'DSN',CPCMNM            SHO DSN?\n         BE    DOLGO9\n         B     RESCAN\n         SPACE\nTESTDIR  CLC   =C'DIR',CPCMNM            SHO DIR?\n         BE    DOLGO9\n         CLC   =C'CAT',CPCMNM            SHO CAT?\n         BE    DOLGO9\n         B     RESCAN\n         SPACE\nTESTMEM  CLC   =C'DSN',CPCMNM            SHO DSN?\n         BE    TESTMEM2\n         CLC   =C'DIR',CPCMNM            SHO DIR?\n         BE    TESTMEM2\n         CLC   =C'CAT',CPCMNM            SHO CAT?\n         BNER  R14\n         SPACE\nTESTMEM2 SCAN  OPERAND\n         B     DOLGO9\n         SPACE\nOPERANDD B     SCANPRTA\n         SPACE\nSETSET   OI    CPLFLG3,CPFSET          TURN ON SET OPERAND\n         BR    R14                     RESCAN\n         SPACE\nSETNOSET NI    CPLFLG3,255-CPFSET      TURN OFF SET FLAG\n         BR    R14                     RESCAN\n         SPACE\n         AIF   ('&USPS' EQ '1').XLBL10                          USPS01\nHAVGRP   LA    R15,DSNWAGOR        DESTINATION\n         LA    R2,DSNXGL-1         CORRECT LENGTH\n         B     HAVGU               COMMON ROUTINE\n.XLBL10   DS    0H                                              USPS01\n         SPACE\nHAVKEY   LA    R15,CPDRED\n         LR    R2,R0\n         CH    R2,=Y(8)\n         BH    CVNVALID\n         B     HAVGUGO2\n         SPACE\nHAVUSER  LA    R15,DSNWAUOR        DESTINATION\n         LA    R2,DSNXUL-1         CORRECT LENGTH\nHAVGU    CLC   =C'DSN',CPCMNM      IS IT SHOW DSNAMES?\n         BNE   HAVGUGO             BR IF NOT\n         CH    R0,=H'3'            IS LENGTH 3?\n         BNE   HAVGUGO             BR IF NOT\n         CLC   =C'ALL',0(R1)       IS OVERRIDE 'ALL'?\n         BNE   HAVGUGO             BR IF NOT\n         LA    R1,=X'FFFFFF'       NEW OVERRIDE VALUE\n         B     HAVGUGO2            SKIP LENGTH CHECK FOR THIS\n         SPACE\nHAVGUGO  LTR   R0,R0               IS IT NULL OVERRIDE?\n         BZ    HAVGUGO2            BR IF YES - OK\n         CLR   R2,R0               OTHERWISE CHECK LENGTH\n         BNE   INVOR               INVALID OVERRIDE - WRONG LENGT\nHAVGUGO2 BCTR  R2,0                FOR EX\n         EX    R2,ORMVC            MOVE OVERRIDE\n         BR    R14                 RETURN\n         SPACE 3\nHAVTO    CLI   CPCMNM,C'R'         IS IT RENAME\n         BNE   TESTMEM             NO\n         TM    SDSNQUB+18,X'06'       WAS TO OR ADD SET\n         BNZ   CVNVALID            YES\n         OI    SDSNQUB+18,X'04'       SET TO\n         B     MOVETO\n         SPACE\nHAVADD   CLI   CPCMNM,C'R'         IS IT RENAME\n         BNER  R14                 NO\n         TM    SDSNQUB+18,X'06'       WAS TO OR ADD SET\n         BNZ   CVNVALID            YES\n         OI    SDSNQUB+18,X'02'       SET ADD\nMOVETO   SCANSAVE  ,\n         B     DOLGO9\n         SPACE\nNOVAR    CLI   CPCMNM,C'R'         RENAME CMD\n         BE    SETNOVAR            YES........\n         OI    DSNWAF2,DSNNOVER    NOVERIFY SPECIFIED\n         B     PRIVCHK             TEST PRIVS\n         SPACE\nSETNOVAR OI    SDSNQUB+18,X'01'       SET NOVARIFY\n         BR    R14                 MORE\n         SPACE\nRCATL    CLI   CPCMNM,C'R'         IS IT RENAME\n         BNER  R14                 NO\n         OI    DSNWAF1,X'04'       SET CATLG\n         BR    R14\n         SPACE\nUNCA     CLI   CPCMNM,C'R'         IS IT RENAME\n         BNER  R14\n         OI    DSNWAF1,X'02'       SET UNCAT\n         BR    R14\n         SPACE\nRECA     CLI   CPCMNM,C'R'         IS IT RENAME\n         BNER  R14                 NO\n         OI    DSNWAF1,X'06'       SET RECAT\n         BR    R14\n         SPACE\n* INVALID OVERRIDE BECAUSE OF LENGTH\nINVOR    STM   R0,R1,CPSAVE        SAVE FOR 'INVALID' ROUTINE\n         B     CVNVALID\n         SPACE 2\nORMVC    MVC   0(0,R15),0(R1)\n         EJECT\n* ROUTINE TO SET DSNAME ATTRIBUTE FLAGS\n         SPACE\nDSNSTDDO SENTER R0,R8\n         NI    DSNWAF1,255-DSNFSTD-DSNFWLIB  RESET FLAGS\n         AIF   ('&USPS' EQ '1').XLBL11                          USPS01\n         CLC   KWYL,DSNWADSN       FIRST LEVEL OK?\n         BNE   DODSNNS             BR IF NOT STD\n         CLI   DSNWADSN+DSNXG+DSNXGL-1,C'.'  GROUP DELIM?\n         BNE   DODSNNS             BR IF NOT\n.XLBL11   DS    0H                                              USPS01\n         AIF   ('&DCEC' NE '1').LBL31                           JEP001\n         SR    R2,R2                                            JEP001\n         IC    R2,CVUSRFLD         PICK UP ID LENGTH            JEP001\n*        LA    R2,1(R2)            GET TO PERIOD                JEP001\n         LA    R2,DSNWADSN(R2)     PLUS ADDR OF DSN W/A         JEP001\n         CLI   0(R2),C'.'          USER DELIM?                  JEP001\n         BNE   DODSNNS             BR IF NOT                    JEP001\n         SR    R2,R2                                            JEP001\n         IC    R2,CVUSRFLD         RELOAD R2                    JEP001\n         LH    R0,DSNWANL          GET DSN LENGTH               JEP001\n         LA    R2,1(R2)            GET PAST PERIOD              JEP001\n         CR    R0,R2               IS IT LONG ENOUGH??          JEP001\n         BL    DODSNNS             BR IF NOT                    JEP001\n         AGO   .LBL32                                           JEP001\n.LBL31   DS    0H                                               JEP001\n         CLI   DSNWADSN+DSNXU+DSNXUL-1,C'.'  USER DELIM?\n         BNE   DODSNNS             BR IF NOT\n         LH    R0,DSNWANL          GET DSNAME LENGTH\n         CH    R0,=Y(DSNXN)        IS IT LONG ENOUGH?\n         BL    DODSNNS             BR IF NOT\n.LBL32   DS    0H                                               JEP001\n         OI    DSNWAF1,DSNFSTD     SET STD WYL DSN FLAG\n         AGO   .XLBL13                                          USPS01\n         LA    R2,DSNXN+3          LENGTH OF STD PFX +3\n         CR    R0,R2               IS THAT THE LENGTH?\n         BNE   DODSNNS             BR IF NOT\n         CLC   =C'LIB',DSNWADSN+DSNXN  IS A WYLBUR LIB?\n         BNE   DODSNNS             BR IF NOT\n         OI    DSNWAF1,DSNFWLIB    SAY SO\n.XLBL13   DS    0H                                              USPS01\nDODSNNS  SEXIT R0,R8\n         EJECT\n* ROUTINE TO SET DSNAME POSSESSION FLAGS\n         SPACE\nDSNUDSDO SENTER R0,R8\n         TM   DSNWAF2,DSNNOVER     NOVERIFY SET?\n         BO   DODSNSMY             FAKE WYLBUR OUT\n         NI    DSNWAF1,255-DSNFMYDS     RESET\n         TM    DSNWAF1,DSNFSTD     IS IT STD DATA SET?\n         BZ    DODSNSX             BR IF NOT\n         AIF   ('&DCEC' NE '1').LBL06                           JEP00X\n         XR    R1,R1               ZERO OUT R1                  JEP001\n         IC    R1,CVUSRFLD         PICK UP LENGTH OF USER ID    JEP001\n         CLC   DSNWADSN(0),CPUSER  USERS DATA SET?              JEP001\n         EX    R1,*-6              EXECUTE ABOVE INST           JEP001\n         BE    DODSNSMY            GO TURN ON FLAG..            JEP001\n         B     DODSNSX             BR IF NOT                    USPS01\n         AGO   .LBL07                                           JEP00X\n.LBL06   DS    0H                                               JEP00X\n         CLC   DSNWADSN+DSNXG(DSNXGL-1),CPGRP  HIS GROUP?\n         BNE   DODSNSX             BR IF NOT\n         CLC   DSNWADSN+DSNXU(DSNXUL-1),CPUSER  HIS ID?\n         BE    DODSNSMY            BR IF YES\n         CLC   DSNWADSN+DSNXU(DSNXUL-1),=C'PUB'  PUB?\n         BNE   DODSNSX             BR IF NOT\n.LBL07   DS    0H                                               JEP00X\nDODSNSMY OI    DSNWAF1,DSNFMYDS    SET MY DATA SET FLAG\nDODSNSX  SEXIT R0,R8\n         SPACE 5\n         COPY  KWYL\n         TITLE 'FMTCHK ROUTINE'\n* FMTCHK IS CALLED BY EITHER USE OR SAVE TO GET THE FORMAT, BLOCKING\n*      FACTOR OR SKIP-COUNT.  FORMATS ARE: EDIT, CARD, PRINT OR LRECL.\n*      RETURNS FORMAT IN R0, WITH 0=EDIT, POS=LRECL.  (CARD=80, PR=133)\n         SPACE\nFMTCHK   XENTER  R2,R8,C32+C8+SZR    USE SZR FOR IGNORED OP LIST\n         OI    CPLFLG5,CPFUNUM     SET UNNUMBERED AS DEFAULT\n         LA    R2,C32+C8(R8)   START IGNORED OPERAND AREA\n         LCR   R6,R2                   SET NO DEFAULT FORMAT\n         SR    R5,R5                    NO BLK FACTOR/SKIP YET\n         SR    R3,R3                    SET NO \"NRECS\"\nSETUPSCN LA    R1,SVFMPRT               ASSUME \"SAVE\"\n         EX    R0,CHKFRMT               \"USE\" OR \"SAVE\"?\n         BNE   GOTOSCN                  \"SAVE\"\n         LA    R1,USFMPRT               SET USE PRT\nGOTOSCN  SCAN  (1)                 GO SCAN\n         LTR   R0,R3                    NRECS GIVEN?\n         BZ    CHKFRMT                  NO\n         SCINIT (4),(0)                 INIT SCAN\n         SCAN  NRECPRT                  GET \"NREC\"\n         B     CVABSENT            ERROR IF MISSING\nCHKFRMT  CLC   CPCMNM(3),=C'USE'        CHECK BLK FACTOR ON SAVE\n         BE    WRIGNORS            USE\n         LTR   R6,R6                   LRECL GIVEN\n         BM    WRIGNORS            NONE GIVEN, DO NO CHECKING NOW\n         BZ    CHKEDT                  YES EDIT FORMAT\nCHKLREC  TM    CPLFLG5,CPFUNUM         UNNUMBERED?\n         BO    CHKBLK                  YES\n         LH    R0,CPSEQLN              GET LENGTH OF SEQ FIELD\n         TM    CPSEQFLD,FNEGBT         SEQ FIELD AT END\n         BO    CHKLREC2                YES\n         AH    R0,CPSEQFLD             ADD START COL FOR SEQ\n         BCTR  R0,0                    SET FOR COMPARE TO LRECL\nCHKLREC2 CR    R0,R6                   SEQ FIELD IN LRECL BNDS\n         BH    GARBB                   NO, LRECL ERROR\nCHKBLK   LTR   R1,R5                    DEFAULT BLK FACTOR NEEDED?\n         BZ    WRIGNORS                 YES\n         MR    R0,R6                    MULT BLK FACTOR & LRECL\n         CH    R1,=Y(MXRECSZ)           TOO BIG?\n         BNH   WRIGNORS                NO\nGARBB    TSEG  'LRECL'\n         B     CVUNLEGL\n         SPACE\nCHKEDT   TM    CPLFLG5,CPFFOPT     ANY NUMBER OPTION GIVEN\n         BNE   GARBB               YES, EDIT IS BAD FORMAT\n         SPACE\n* TEST IF ANY OPERANDS IGNORED AND LET USER KNOW\nWRIGNORS MVI   0(R2),X'FF'    FLAG END OF LIST\n         LA    R2,C32+C8(R8)   START AT BEGINNING AGAIN\n         CLI   0(R2),X'FF'    TEST FOR NULL LIST\n         BE    NOSCRTH        BR IF YES\n         SR    R3,R3          ZERO LENGTH REG\nHVIGNORS IC    R3,0(R2)       LENGTH OF IGNORED KEYWORD\n         TSEG  1(R2),(R3)     WRITE IT\n         LA    R2,1(R3,R2)    BUMP TO NEXT ONE\n         CLI   0(R2),X'FF'    TEST FOR LAST ONE DONE\n         BE    ENDIGNRS       BR IF YES\n         TSEG  ',',,B         MORE TO FOLLOW\n         B     HVIGNORS\n         SPACE\nENDIGNRS TSEG  ': IGNORED',,M\nNOSCRTH  LR    R1,R5                    SET SKIP-NREC RETURN\n         LTR   R0,R6                    SET FMT RETURN\n         XEXIT 2,8\n         SPACE\nNRECDOO  LR    R5,R15                   SET NRECS\n         SCAN  NRECERT                  MAKE SURE OK\n         LTR   R6,R6               ANY LRECL GIVEN\n         BP    CHKFRMT             YES, GO DO NORMAL CHECK\n         BZ    GARBB               EDIT SPECIFIED, NRECS IS ERROR\n         LA    R6,80               SET FOR CARD\n         B     CHKFRMT             GO DO CHECK\n         EJECT\nLRECLA   LR    R6,R15                   SET FORMAT\n         BR    R14                      SCAN FOR MORE\n         SPACE\nSKIPA    LR    R5,R15                   SET SKIP COUNT\n         BR    R14                      MORE?\n         SPACE\nNRCTRY   CLI   0(R1),C'('               NEED LEFT PAREN FOR NRECS\n         BNE   CVNVALID                 NEED LEFT PAREN\n         EX    R0,CHKFRMT               ONLY SAVE OK\n         BE    IGNORE         NOT SAVE\n         LA    R4,1(R1)                 SAVE PTR\n         SH    R0,=Y(2)                 DECREMENT FOR PARENS\n         LTR   R3,R0                    SAVE COUNT\n         BNP   CVNVALID                 NIX\n         BR    R14                      MORE?\n         SPACE\nEDITA    SR    R6,R6                    SET \"EDIT\"\n         BR    R14                      SCAN FOR MORE\n         SPACE\nCARDA    LA    R6,80                    SET \"CARD\"\n         BR    R14                      SCAN FOR MORE\n         SPACE\nPRNTA    LA    R6,MXPRTSZ               SET \"PRINT\"\n         BR    R14                      SCAN FOR MORE\n         SPACE\nSETSEQ   NI    CPLFLG5,255-CPFNONUM    SET NUMBERED DEFAULT\n         OI    CPLFLG5,CPFFOPT     SET NUMBER OPTION GIVEN\n         SCANSAVE ,                SAVE SCAN POINTERS\n         LM    R0,R1,CPSAVE            GET SEQ FLD POINTERS\n         CLI   0(R1),C'('              NEED LEFT PAREN\n         BNE   SETSEQ1                 NO, ONLY POSITION GIVEN\n         SH    R0,=Y(2)                STRIP PAREN COUNT\n         BM    CVNVALID\n         LA    R1,1(,R1)               KICK POINTER PAST \"(\"\nSETSEQ1  SCINIT (1),(0)                INITIALIZE SCANNER\n         SCAN  SEQPRT1                 SCAN FOR SEQFLD\n         B     SETSEQ3                 NOTHING FOUND\n         SPACE\nSSEQEND  OI    CPSEQFLD,FNEGBT         SET SEQ FLD AT END\n         B     SETSEQ2                 GO TO GET LENGTH\n         SPACE\nSSEQFLD  LTR   R15,R15                 TEST LENGTH\n         BNP   CVNVALID                MUST BE POSITIVE\n         STH   R15,CPSEQFLD            SAVE SEQ FLD POSITION\nSETSEQ2  SCAN  SEQPRT2                 SCAN FOR LENGTH\n         B     SETSEQ3                 DONE, LEAVE LENGTH ALONE\n         SPACE\nSSEQLN   LTR   R15,R15\n         BNP   CVNVALID                LENGTH MUST BE POSITIVE\n         STH   R15,CPSEQLN             SAVE LENGTH\n         SCAN  UNRECPRT                CHECK REST OF PARM BLANK\nSETSEQ3  SCANRSTR ,       RESTORE SAVED SCAN POINTERS\n         B     SETUPSCN                GO CONTINUE NORMAL SCAN\n         SPACE\nEXPDT    OI    DSNWAF3,DSNFEXP     SET EXPDT OVERRIDE OK\n         B     PRIVCHK             GO CHECK IF PRIVILIGED\n         SPACE\nSSI      CH    R0,=H'8'            MAX OF 8 FOR SSI\n         BH    CVNVALID            BR IF NO GOOD\n         XCALL XTB                 CONVERT TO HEX\n         LTR   R0,R0               CHECK ALL DIGITS CONVERTED\n         BP    CVNVALID            NO, INVALID HEX SSI\n         ST    R15,DSAVSSI         SAVE SSI GIVEN\n         OI    DSNWAF3,DSNFSSI     SET SSI GIVEN FLAG\n         B     SETUPSCN            GO RESTART SCAN\n         SPACE\nLINES    CVCALL DETRNG             GO DO RANGE\n         OI    DSNWAF3,DSNFLIN     SET LINES SPECIFIED\n         B     SETUPSCN            CONTINUE SCAN\n         SPACE\nRECATLG  OI    CPLFLG3,CPFRECLG    SET \"RECATLG\"\n         BR    R14\n         SPACE\nCATLG    OI    CPLFLG3,CPFDSCLG    SET \"CATLG\"\n         BR    R14\n         SPACE\nUNCATLG  OI    CPLFLG3,CPFUNCLG    SET \"UNCATLG\" - INST EX'D\n         BR    R14\n         SPACE\nDSORG    CLC   =C'PS',0(R15)       DSORG=PS ONLY VALID OP\n         BNE   CVNVALID\n         MVI   DSNWAMBR,X'FF'      FLAG MEMBER FIELD\nPRIVCHK  TM    JCBAFL,JCBSYSPR     SYS PRIV?\n         BZ    CVNVALID            BR IF NO\n         BR    R14\n         SPACE\n* ROUTINE TO IGNORE AN OPERAND WHICH IS NOT APPLICABLE\n* ADD OPERAND TO A TABLE TO BE WRITTEN LATER\n         SPACE\nIGNORE   LTR   R15,R0              SAVE LENGTH OF OPERAND\n         BZR   R14                 EXIT IF NULL\n         STC   R0,0(R2)            SAVE LENGTH\n         EX    R15,IGNORMVC        (BCTR SUPERFLUOUS)\n         LA    R2,1(R15,R2)        BUMP TO NEXT AREA\nBR14     BR    R14                 EXIT\n         SPACE\nIGNORMVC MVC   1(0,R2),0(R1)       MOVE OPERAND TO LIST\n         TITLE 'CONSTANTS, ETC.'\n         COPY  WYLCONST\n         SPACE\nRTNAD    EQU   C32\nPRESTPT  EQU   C32+4\nOCCURS   EQU   C32+8\nWRKAREA  EQU   C32+12\n         TITLE 'LITERALS'\n         LTORG\n         TITLE 'SCKW''S'\n* FOR DODSNM ROUTINE\n         SPACE\nDSPRTA   SCKW  ,AGOOD         1ST TOKEN\nDSPRTB   SCKW  ,BGOOD\nSPARTA   SCKW  ON,HAVOLM,P\n         SCKW  SET,SETSET\n         SCKW  NOSET,SETNOSET,A\n         AIF   ('&USPS' EQ '1').XLBL17                          USPS01\n         SCKW  GROUP,HAVGRP,(P,A)\n         SCKW  GRP,HAVGRP,P\n.XLBL17   DS    0C                                              USPS01\n         SCKW  USER,HAVUSER,(P,A)\n         SCKW  KEYWORD,HAVKEY,(P,A)\n         SCKW  TO,HAVTO\n         SCKW  ALIAS,HAVADD\n         SCKW  NOVERIFY,NOVAR,A\n         SCKW  CATLG,RCATL,A\n         SCKW  RECATLG,RECA,A\n         SCKW  UNCATLG,UNCA,A\n         SCKW  READ,,(P,A)\n         SCKW  WRITE,,(P,A)\n         SCKW  PROTECT,,(P,A)\n         SCKW  DPO,\n         SCKW  SHARE,\n         SCKW  SHR,\n         SCKW  LIKE,TESTDSN,A\n         SCKW  FOR,TESTDIR\n         SCKW  IN,TESTDIR\n         SCKW  THROUGH,TESTMEM,A\n         SCKW  THRU,TESTMEM\n         SCKW  FROM,TESTMEM,A\n         SCKW  EXCLUDE,TESTMEM,A\n         SCKW  ,RESCAN\n         SPACE\nOPERAND  SCKW  ,OPERANDD\n         EJECT\n* FOR FMTCHK ROUTINE\n         SPACE\nUSFMPRT  SCKW  SCRATCH,IGNORE,A\n         SCKW  REPLACE,IGNORE,A\n         SCKW  CATLG,IGNORE,A\n         SCKW  LRECL,LRECLA,(P,PI,A),MXRECSZ\n         SCKW  RECATLG,IGNORE,A\n         SCKW  UNCATLG,IGNORE,A\n         SCKW  SKIP,SKIPA,(P,PI,A),99999\n         SCKW  DSORG,DSORG,(P,A)\n         SCKW  ,USSVPRT,PUSH       SKIP TO COMMON PART\nSVFMPRT  SCKW  NOVERIFY,BR14,A\n         SCKW  EXPDT,EXPDT,A\n         SCKW  SSI,SSI,P\n         SCKW  LINES,LINES,A\n         SCKW  EXECUTE,,A\n         SCKW  CATLG,CATLG,A\n         SCKW  RECATLG,RECATLG,A\n         SCKW  UNCATLG,UNCATLG,A\nUSSVPRT  SCKW  EDIT,EDITA,A\n         SCKW  CARD,CARDA,A\n         SCKW  PRINT,PRNTA,A\n         SCKW  LRECL,LRECLA,(P,PI,A),256\n         SCKW  ,CLSCRPRT,PUSH\n         SCKW  ,NUMPRT,PUSH\n         SCKW  SEQFLD,SETSEQ,(A,P)\n         SCKW  ,IGDSNPRT,PUSH\n         SCKW  ,NRCTRY        CHECK FOR NREC (BLOCKING FACTOR)\n         SPACE\nNRECPRT  SCKW  ,NRECDOO,PI,1000\nNRECERT  SCKW  ,INVALID\n         SPACE\nSEQPRT1  SCKW  END,SSEQEND\n         SCKW  E,SSEQEND\n         SCKW  ,SSEQFLD,PI,133\nUNRECPRT SCKW  ,INVALID\n         SPACE\nSEQPRT2  SCKW  ,SSEQLN,PI,9\n         SCKW  ,INVALID\n         TITLE 'COPY MODS'\n         COMMON\n         SPACE\nCPKWSAV  EQU   CPWA+608          FOR KW\n         SPACE\n         END\n./ ADD NAME=PWYL     0100-80189-80189-0746-00865-00865-00000-$SYS13  00\nPWYL     TITLE 'WYLTSO ENTRY AND COMMAND PROMPTER'\n* PROPERTY OF C. U. C. C. A.\n         GBLC    &CCI             SWITCH FOR CCI MODS           CCI001\n&CCI    SETC   '1'  CHANGE TO ANY OTHER NUM. TO DELETE CCI MOD  CCI001\n         AIF   ('&CCI' NE '1').LBL01                            CCI001\n*                                                               CCI001\n* MOD CCI001                                                    CCI001\n*  IMPLIMENT RUN COMMAND                                        CCI001\n*                                                               CCI001\n*                                                               JEP015\n* MOD JEP018                                                    JEP018\n*  ALLOW ALL NON-WYL CMDS AS VALID WYLBUR SUBCOMMANDS.          JEP018\n*  MODULES AFFECTED ARE PWYL AND PEDP. MOD DENOTED BY           JEP018\n*  JEP018 IN CC 66/71.     JERRY PITTENGER                      JEP018\n*                                                               JEP018\n*                                                               JEP018\n.LBL01   DS    0H                                               CCI001\n      EJECT                                                     JEP004\n         SPACE 3\nPWYL     CSECT\n         WIDENT 001\n         USING CPAREA,R12\n         SPACE\n         XTRNS\n         EJECT\n         ENTRY WYLTSO,CMDPRT,PSYNAD,ATTNRTN\n         SPACE\nWYLTSO   STM   R14,R12,12(R13)     SAVE ZE REGS\n         BALR  R7,R0               ESTABLISH A BASE REG\n         USING *,R7\n         L     R7,=A(WYLTSO)\n         LR    R9,R1               PARMS IF ANY\n         USING WYLTSO,R7\n         LR    R11,R13             RECALL RETURN SAVEAREA\n         LOAD  EP=WYLINIT\n         LR    R15,R0              ENTRY POINT ADDRESS\n         L     R1,=V(CVREAL)       ADDRESS OF REAL CV\n         BALR  R14,R15             GO TO IT\n         BALR  R7,R0               RESTORE BASE REG\n         USING *,R7\n         L     R7,=A(WYLTSO)\n         USING WYLTSO,R7\n         DELETE EP=WYLINIT         GET RID OF INIT MODULE\n         SR    R9,R9               CLEAR POSSIBLE PAGE PTR\n         SR    R10,R10             CLEAR POSSIBLE PAGE POINTER\n         SR    R11,R11             DITTO\n         SR    R0,R0\n         LR    R8,R13\n         ESTAE FIXUP,TERM=YES\n         IC    R0,CVPARM\n         LTR   R0,R0\n         BZ    XLOGON\n         L     R1,CVPARM\n         LA    R1,0(,R1)\n         B     EDTCOMMV\n         SPACE 3\nXLOGON   CLI   CPCMSAV,C';'              LOGON EXEC?\n         BNE   CMDPRT\n         L     R0,CPCTSAV\n         LA    R1,CPCMSAV+1\n         B     EDTCOM\n         EJECT\n* DO INVALID OPTIONS MSG HERE\n         SPACE\nINVALID  GENTER ,                       SET BASE REG\n         NI    RTBMFL,X'FF'-RTBNOCR-RTBNOTR RESET NOCR, NOTR\n         LM    R0,R1,CPSAVE             PICK UP PTRS\n         LTR   R0,R0                    POS COUNT?\n         BZ    CVABSENT                 MISSING\n         BNM   NOWSEG                   YES\n         LCR   R0,R0                    COMPLEMENT COUNT\nNOWSEG   CH    R0,=H'15'                USE ONLY 15 CHARS\n         BNH   *+8                      BRANCH O.K.\n         LA    R0,15                    SET TO MAX COUNT\n         TSEG  (1),(0)                  INVALID ITEM INTO MSG\n         TSEG  ': INVALID'\n         TM    CPGFLG2,CPFEXEC          IS EXEC IN EFFECT\n         BO    CVQTYPE                  YES\n         B     CMDPRT\n         TITLE 'ESTAE ROUTINE'\n         PUSH USING\n         SPACE 1\nFIXUP    STM   R14,R12,12(R13)          SAVE REGS\n         LR    R10,R1\n         USING SDWA,R10\n         BALR  R11,0\n         USING *,R11\n         L     R12,SDWAGR12          LOAD CP REGISTER\n         ICM   R15,15,CVSPIEAD        SEE IF ANY ADDRESS\n         BNZ   RETRY2\n         SPACE 1\n         CLC   SDWAABCC+1(2),=X'0470'   LOST AUTHORITY?\n         BNE   ABENDED                  NO, THEN WE ABENDED\n         SPACE 1\n         TPUT  APFMSG,L'APFMSG\n         B     RETRY\n         SPACE\nABENDED  UNPK  ABENDCDE(9),SDWAABCC(5)     CONVERT TO HEX\n         TR    ABENDCDE(8),TRTOHEX\n         MVI   ABENDCDE+8,C' '\n         SPACE 1\n         TPUT  ESTAEMSG,ESTAEMSZ\n         TPUT  REGMSG,32\n         LA    R2,SDWAGRSV     SAVE AREA\n         BAL   R14,TOHEX       TRANSLAGE\n         TPUT  HEX,36          PRINT IT\n         LA    R2,16(,R2)      NEXT REGISTERS\n         BAL   R14,TOHEX       TRANSLATE AGAIN\n         TPUT  HEX,36\n         LA    R2,16(,R2)      NEXT REGISTERS\n         BAL   R14,TOHEX       TRANSLATE AGAIN\n         TPUT  HEX,36\n         LA    R2,16(,R2)      NEXT REGISTERS\n         BAL   R14,TOHEX       TRANSLATE AGAIN\n         TPUT  HEX,36\n         SLR   R15,R15         FOR IC\n         IC    R15,SDWAILC2    LENGTH OF IC\n         L     R2,SDWAPMKP     NEXT INST\n         SR    R2,R15          POINT TO FAILING INST\n         ST    R2,CPDOUB       STORE IT\n         LA    R2,CPDOUB       POINT TO IT\n         BAL   R14,TOHEX       TRANSLAGE\n         MVC   ADR,HEX+2      MOV ABEND ADDRESS\n         TPUT  ADRMSG,ADRSIZ\nABNDMSG  TPUT  RETRYMSG,L'RETRYMSG\n         TGET  HEX,8         GET REPLY\n         OC    HEX(8),=CL8' '\n         CLC   HEX(5),=C'RETRY' IS IT RETRY\n         BE    RETRY\n         CLC   HEX(5),=C'ABEND' IS IT ABEND\n         BE    ATTNOUT\n         B     ABNDMSG        RE-ISSUE MESSAGE\n         SPACE\nRETRY    LA     R15,CMDPRT             SET AS RETRUN ADDRESS\nRETRY2   SETRP WKAREA=(10),REGS=(14,12),RC=4,RETADDR=(R15),            *\n               RETREGS=YES,FRESDWA=YES\n         SPACE\nATTNOUT  DS    0H\n         SETRP WKAREA=(10),REGS=(14,12),RC=0\n         SPACE\n         LTORG\n         SPACE\nTOHEX    UNPK  HEX(9),0(5,R2)\n         UNPK  HEX+9(9),4(5,R2)\n         UNPK  HEX+18(9),8(5,R2)\n         UNPK  HEX+27(9),12(5,R2)\n         TR    HEX(35),TRTOHEX\n         MVI   HEX+8,C' '\n         MVI   HEX+17,C' '\n         MVI   HEX+26,C' '\n         MVI   HEX+35,C' '\n         BR    R14                      RETURN\nADRMSG   DC    C'ADDRESS OF FAILING INSTRUCTION '\nADR      DC    CL6' '\nADRSIZ    EQU    *-ADRMSG\nREGMSG   DC    CL32'REGISTERS AT ENTRY TO ABEND'\nESTAEMSG DC    C'WYLBUR ESTAE TRAPPED ABEND='\nABENDCDE DC    C'XXXXXXXX '\nESTAEMSZ EQU   *-ESTAEMSG\nRETRYMSG DC    C'ENTER OPTION RETRY, OR ABEND'\nAPFMSG   DC    C'AUTHORIZATION LOST: SUSPEND CURRENT SESSION'\nHEX      DC    6D'0'\nTRTOHEX  EQU   *-C'0'\n         DC    C'0123456789ABCDEF'\n         POP   USING\n         TITLE 'CMDPRT ROUTINE'\n* CMDPRT PROMPTS FOR AND RECOGNIZES ALL WYLBUR COMMANDS.\n* CTL IS PASSED TO THE APPROPRIATE ROUTINE FOR ALL COMMANDS.\n* AFTER THE FIRST TIME THRU, CMDPRT IS ALWAYS CALLED, NEVER\n* RETURNED TO. R8 AND R13 ARE INITIALIZED TO POINT TO CPWA.\n         SPACE\nCMDPRT   LA    R13,CPWA                 START OF WORK AREA\n         LR    R8,R13                   ALSO HERE\n         XC    CVPGRTN(4),CVPGRTN       CLR PTR TO CURRENT PGED CDE\n         XC    CVSPIEAD,CVSPIEAD      CLEAR SPIE ADDRESS\n         XC    JCBPAGES(2),JCBPAGES\n         TM    JCBAFL,JCBAFIA           USER HIT ATTN?\n         BO    CVQTYPE                  YES... PROCESS\n         BALR  R7,0                     SET BASE REG\n         USING *,7\n         TM    CPGFLG,CPFOPN            ANY EXTERNAL DATA SET OPEN?\n         BZ    READY                    NO\n         DCLOSE ,                       CLOSE IT\n         NI    CPGFLG,255-CPFOPN        SET CLOSED\nREADY    C     R9,CVCPADDR         IS THIS THE VCP?\n         BNE   GOPFREE\n         SR    R9,R9\n         B     PFREE10\n         SPACE\nGOPFREE  PFREE 9                        FREE IF NECESSARY\nPFREE10  PFREE 10\n         PFREE 11                       FREE IF NECESSARY\n         LH    R0,RTBWC                 GET CURRENT WRITE COUNT\n         LTR   R0,R0                    ANYTHING OUTSTANDING?\n         BZ    NADA                     NOPE\n         TWRITE ,\nNADA     TM    JCBBFL,JCBBFPER          PAGING ERROR?\n         BZ    CMNDPRTG                 BR IF NOT\n         NI    JCBBFL,255-JCBBFPER      CLEAR ERROR FLAG\n         BAL   R2,QZWRITIT              TYPE BUFFER\n         TSEG  'I/O ERRORS MAY HAVE DAMAGED YOUR ACTIVE FILE',,M\n         SPACE\nCMNDPRTG TM    RTBMFL,RTBNOCR         NOCR?\n         BZ    NOMARK\n         NI    RTBMFL,X'FF'-RTBNOCR   RESET NOCR\n         SR    0,0\n         TSEG  (1),(0),W              PLANT CR/LF\nNOMARK   NI    RTBMFL,X'FF'-RTBNOTR   RESET NOTR\n         TM    CPGFLG2,CPFEXEC        IS EXEC IN EFFECT?\n         BE    CMNDPRTH                BRANCH NO\n         BAL   R2,QZWRITIT             TYPE BUFFER\n         XCALL GETEXCMD                GO GET COMMAND FROM EXEC\n         SPACE\nCMNDPRTH SR    R0,R0\n         TM    CPGFLG,CPFRETRY        IS RETRY GOING ON?\n         BZ    READYZ                 NO, GET COMMAND\n         MVI   CPCTSAV,0\n         L     R0,CPCTSAV             GET COUNT\n         LA    R1,CPCMSAV             GET ADDRESS\n         NI    CPGFLG,255-CPFRETRY    SET RETRY NOT IN EFFECT\n         B     EDTCOM                 GO DO COMMAND\n         SPACE\nREADYZ   TM    CPGFLG,CPFCMOFF        \"COMMAND\" IN PROMPT?\n         BO    GOREAD                 NO\n         SYSQS 1,0,'COMMAND'          SET UP \"COMMAND\" PROMPT\nGOREAD   L     R15,=X'005A5B7C'\n         LCR   R15,R15\n         CVCALL TRDRTN\n         BP    CMDATTN                BR IF ATTENTION\n         LTR   R0,R0                  ANYTHING TYPED?\n         BZ    READYZ                 NO - TRY AGAIN\n         BCT   R0,CMDCONT             SEE IF 1 CHAR\n         CLI   0(R1),C'$'             IS IT A RETRY REQUEST\n         BE    CMDRETRY\nCMDCONT  A     R0,=F'1'\n         MVI   CPCTSAV,0              SET COMMAND NOT LOGGED\n         B     EDTCOMMV               GO SCAN COMMAND\n         SPACE\nQZWRITIT CLC   RTBWC(2),=D'0'         ANYTHING TO WRITE?\n         BER   R2                     NO\n         TWRITE ,                     WRITE IT\n         BR    R2                     RETURN\n         SPACE\nCMDATTN  LTR   R0,R0                  ANY CHARACTERS BEFORE ATTN\n         BZ    CMDCOL                 NO, GO START COLLECT CMD\n         LR    R2,R0                 LENGTH OF INPUT\n         BCTR  R2,R0                 LESS 1\n         LA    R2,0(R2,R1)           LAST CHAR OF INPUT\n         CLI   0(R2),C'$'            RETRY WANTED\n         BNE   CVGETCOM\nCMDRETRY MVI   CPCTSAV,0             CLEAR HI ORDER BIT\n         OI    CPGFLG,CPFRETRY       SET RETRY GOING ON\n         B     MODGO                 GO TO MODIFY COMMAND\n         SPACE\nCMDCOL   TM    RTBUFL,RTBUNCOL       AUTO COLLECT WANTED?\n         BO    CVGETCOM              NOPE\n         LA    R1,=C'C'              PRETEND COLLECT WAS TYPED\n         SR    R0,R0                 WILL BE ADDED 1\n         B     CMDCONT                GO EXECUTE COMMAND\n         SPACE 3\nILLCMD   GENTER ,\n         CH    R0,=H'15'\n         BNH   *+8\n         LA    R0,15\n         TSEG  (1),(0)\n         TSEG  ': ILLEGAL COMMAND'\n         B     CVQTYPE\n         TITLE 'NEW COMMAND SETUP AND SCAN'\n* ALL COMMANDS MUST BE AT CPCMSAV AT START OF COMMAND SCAN.  THE\n* LENGTH OF THE COMMAND IS IN CPCTSAV.  IF THE NEGATIVE BIT IS\n* ON IN CPCTSAV, THEN THE COMMAND HAS BEEN LOGGED AT THE\n* TYPEWRITER.  THIS AFFECTS THE EXECUTION OF EXEC, LOAD, AND\n* COMMENT COMMANDS.  AT ENTRY TO EDTCOMMV OR EDTCOM R1 AND R0\n* MUST POINT TO THE COMMAND TO BE EXECUTED.  ENTER AT EDTCOMMV\n* IF THE COMMAND IS NOT ALREADY AT CPCMSAV, OTHERWISE, ENTER AT\n* EDTCOM.  IF NEGATIVE BIT IS ON IN CPCTSAV, THEN THE COUNT\n* IS ALWAYS IGNORED.\n         SPACE\nEDTCOMMV GENTER ,\n         LR    2,0\n         EX    2,CMDMOVE          MOVES COMMAND+1 TO CPCMSAV\n         TM    CPCTSAV,FNEGBT      HAS COMMAND BEEN LOGGED\n         BO    *+8                 YES, DON'T SET COUNT & CLEAR\n         ST    R0,CPCTSAV          SET COUNT SO LOG CAN BE DONE\n         LA    1,CPCMSAV          POINT TO COMMAND\nEDTCOM   GENTER ,                 BASE REG & ENTRY FOR MODE=EDIT\n         TM    CPGFLG2,CPESNULL    ESC CHAR\n         BNZ   EDTCOM1             NO, SKIP CALL OF PRE-PROC\n         MVC   CPCMNM(8),=D'0'     CLEAR FLAGS FOR PRE-PROCESSOR\n         MVI   CPSYSFLG,0               MAKE SURE ZERO\n         XCALL PREPROC            FINALLY,CALL THE PRE-PROCESSOR\n         BZ    EDTCOM1            NOTHING WAS CHANGED\n         ST    R0,CPCTSAV          SAVE NEW COUNT FOR LOG\n         TM    CPGFLG2,CPFEXEC     EXEC MODE\n         BZ    EDTRSE2             BR NO TO TEST TERSE MODE\n         TM    CPGFLG2,CPFEXTER    IS IT EXEC TERSE MODE\n         BO    EDTCOM1             YES, DON'T LIST CHANGED LINE\n         B     EDTRSE3             NO, GO LIST CHANGED LINE\n         SPACE\nEDTRSE2  TM    CPGFLG,CPFCMOFF     IS IT TERSE MODE\n         BO    EDTCOM1             BR YES TO SKIP WRITE\nEDTRSE3  LR    4,0\n         LR    5,1\n         TSEG  (1),(0),WRITE      PRINT CHANGED COMMAND\n         BP    CVQTYPE             ABORT IF ATTENTION\n         LR    0,4                RESTORE R0\n         LR    1,5                RESTORE R1\n         MVI   CPCTSAV,FNEGBT      SET COMMAND HAS BEEN LOGGED\nEDTCOM1  DS    0H\n         SR    R9,R9               CLEAR PAGE PTR\n         STM   R0,R1,CPTELL             SAVE POINTERS\n         SCINIT (1),(0)                 INITIALIZE SCAN\n         MVC   CPCMNM(8),=D'0'          SETUP FOR NEW COMMAND\n         MVI   CPSYSFLG,0               MAKE SURE ZERO\n         LA    R6,TRYEXN           SET FOR LINE NUMBER COMMAND\nOFCOURSE L     R1,=A(MNPRTOK)           SET ADDR PRT\nSCANEM   SCAN  (1)                      SCAN\n         B     CVGETCOM                NOTHING -- GO GET NEXT\n         SPACE\nCMDMOVE  MVC   CPCMSAV(0),0(1)\n         TITLE 'BINARY SEARCH FOR MAJOR COMMANDS'\n* COMMAND TABLE FORMAT:\n*   8 CHARS COMMAND ID\n*   4 BYTE COUNTER (NOT USED IN WYLTSO)\n*   1 BYTE FLAG (INDICATING ABBREVIATIONS)\n*   3 BYTE ADRESS FOR THE COMMAND ROUTINES\n*  --------\n*  16 BYTES TOTAL PER COMMAND\n         SPACE\nBINSRCH  CH    R0,=H'8'        TOO LONG A COMMAND?\n         BH    COMMIL          YES.\n         LR    R5,R0           GET LENGTH OF COMMAND\n         BCTR  R5,R0           GUESS WHY\n         LA    R6,1            TO PROPAGATE A 1 BIT\n         SLL   R6,0(R5)        TO FORM A LENGTH MASK\n         L     R2,=F'-1'\n         LA    R3,CMNDS#+1\nBINLOOP  LA    R4,0(R2,R3)\n         SRL   R4,1            DIVIDE BY 2\n         SLL   R4,4            MULTIPLY BY 16\n         LA    R4,CMDTAB(R4)   POINT TO ENTRY\n         EX    R5,CLC          SEE WHETHER TO GO UP OR DOWN\n         BL    ITSLESS\n         BH    ITSHIGH\n         EX    R6,TMINSTR      IS THIS ABBREV OK?\n         BO    WEGOTIT\n         LR    R14,R4          KEEP THE CURRENT POINTER\nBACKUP   S     R4,=F'16'       BACK UP AN ENTRY\n         C     R4,=A(CMDTAB)\n         BL    ADVANCEX\n         EX    R5,CLC          IS THIS A GOOD ONE?\n         BNE   ADVANCEX\n         EX    R6,TMINSTR      A GOOD ABBREV?\n         BO    WEGOTIT\n         B     BACKUP          KEEP BACKING UP\n         SPACE\nADVANCEX LR    R4,R14          RESTORE PONTER\nADVANCE  LA    R4,16(,R4)      STEP UP\n         C     R4,=A(EOTABL)\n         BH    COMMIL\n         EX    R5,CLC          IS IT THIS ONE?\n         BNE   COMMIL\n         EX    R6,TMINSTR      GOOD ABREV?\n         BO    WEGOTIT\n         B     ADVANCE\n         SPACE\nWEGOTIT  L     R14,12(,R4)     FIND WHERE TO GO\n         MVC   CPCMNM(3),0(R4) MOVE THE FULL COMMAND\n         BR    R14\n         SPACE\nITSLESS  LA    R2,0(R2,R3)\n         SRL   R2,1\nCOMPARE  LA    R15,1(,R2)\n         CR    R15,R3\n         BL    BINLOOP\n         B     COMMIL\n         SPACE\nITSHIGH  LA    R3,0(R2,R3)\n         SRL   R3,1\n         B     COMPARE\n         SPACE\nCLC      CLC   0(0,R4),0(R1)\n         SPACE\nTMINSTR  TM    12(R4),X'00'\n         SPACE 3\n         DS    0F\nCMDTAB   COMMAND ?,SHOVAR,HSHOW,1\n         COMMAND @,SETVAR,HSET,1\n         COMMAND ALIGN,GOALINE,HALIGN,1,2,3,4,5\n         COMMAND CATLG,CATLG,HCATLG,3,4,5\n         COMMAND CENTER,GOCENTER,HCENTR,2,3,4,5,6\n         COMMAND CHANGE,GOCHNG,HCHANG,2,3,4,5,6\n         COMMAND CLEAR,GOCLEAR,HCLEAR,2,3,4,5\n         COMMAND CLR,GOCLEAR,HCLEAR,2,3\n         COMMAND COLLECT,GOCOLL,HCOLCT,1,2,3,4,5,6,7\n         COMMAND COMMENT,GOCOMMNT,HCOMNT,4,5,6,7\n         COMMAND COMPARE,COMPAR,HCOMP,3,4,5,6,7\n         COMMAND COPY,GOCOPY,HCOPY,3,4\n         COMMAND DECIDE,DECIDE,HDECD,3,4,5,6\n         COMMAND DELETE,GODEL,HDEL,1,2,3,4,5,6\n         COMMAND DISPLAY,GOCOMMNT,HCOMNT,2,3,4,5,6,7\n         COMMAND EDIT,MODGO,HEDIT,1,2,3,4\n         COMMAND EXECUTE,GOEXEC,HEXCT,2,3,4,5,6,7\n         COMMAND HELP,HELP,HHELP,1,2,3,4\n         COMMAND IF,GOIF,HIF,2\n         COMMAND IMMEDIAT,GOIMMED,NOHELP,2,3,4,5,6,7,8\n         COMMAND INSERT,GOINS,HINSRT,1,2,3,4,5,6\n         COMMAND JUSTIFY,GOALINE,HJUST,2,3,4,5,6,7\n         AIF   ('&CCI' EQ '1').LBL11   DEL LI AS LIST ALIAS     JEP006\n         COMMAND LIST,GOLSPRN,HLIST,1,2,3,4\n         AGO   .LBL12                                           JEP006\n.LBL11   DS    0C                                               JEP006\n         COMMAND LIST,GOLSPRN,HLIST,1,3,4                       JEP006\n.LBL12   DS    0C                                               JEP006\n         COMMAND LOAD,GOLOAD,HLOAD,3,4\n         COMMAND LOGOFF,GOLOGOFF,HLOGF,5,6\n         COMMAND LOGOUT,GOLOGOFF,HLOGF,5,6\n         COMMAND MODIFY,MODGO,HMODFY,1,2,3,4,5,6\n         COMMAND MOVE,GOMOVE,HMOVE,3,4\n         COMMAND NUMBER,GONUMB,HNUM,1,2,3,4,5,6\n         COMMAND POINT,GOPOINT,HPOINT,1,2,3,4,5\n         COMMAND POP,GOSTACK,HPOP,3\n         COMMAND PRINT,GOLSPRN,NOHELP,2,3,4,5 PRINT COMMAND     CCI001\n         COMMAND PUT,GOPUT,HPUT,2,3\n         COMMAND READ,GORDCMD,HREAD,3,4\n         COMMAND RECATLG,RECATLG,HRECAT,3,4,5,6,7\n         COMMAND RENAME,GOREN,HRENM,3,4,5,6\n         COMMAND REPLACE,GOREPL,HREP,1,2,3,4,5,6,7\n         COMMAND RESTORE,GORESTOR,HRESTR,3,4,5,6,7\n         AIF   ('&CCI' NE '1').LBL15                            CCI001\n         COMMAND RUN,GOLSPRN,NOHELP,3     RUN COMMAND           CCI001\n.LBL15   DS    0C                                               CCI001\n         COMMAND SAVE,GOSAVE,HSAVE,1,2,3,4\n         COMMAND SCRATCH,GOSCRT,HSCR,2,3,4,5,6,7\n         COMMAND SEND,SENDMSG,HSEND,2,3,4\n         COMMAND SET,GOSET,HSET,3\n         COMMAND SHOW,GOSHOW,HSHOW,2,3,4\n         COMMAND SIGNOFF,GOLOGOFF,HLOGF,6,7\n         AIF   ('&CCI' NE '1').LBL16                            JEP015\n         COMMAND  SO,GOLOGOFF,HLOGF,2     SHORT SIGNOFF CMD     JEP015\n.LBL16   DS    0C                                               JEP015\n         COMMAND STACK,GOSTACK,HSTACK,3,4,5\n         COMMAND STAX,STAX,NOHELP,4\n         COMMAND SUSPEND,GOSUSPND,HSUSP,2,3,4,5,6,7\n         COMMAND TDUMP,GODUMP,NOHELP,1,2,3,4,5\n         COMMAND TO,SENDMSG,HSEND,2\n         COMMAND TSO,GOTSO,HTSO,2,3\n         COMMAND UNCATLG,UNCATLG,HUNCAT,3,4,5,6,7\n         COMMAND USE,GOUSE,HUSE,1,2,3\n         COMMAND WHERE,GOWHERE,NOHELP,1,2,3,4,5\nEOTABL   COMMAND X,GOEXEC,HEXCT,1\nCMNDS#   EQU   (*-CMDTAB)/16  NUMBER OF ENTRIES\n         AIF ('&CCI' NE '1').LBLX2                              JEP018\nCOMMIL   PCALL TSOCMDS                                          JEP018\n         AGO   .LBLX3                                           JEP018\n.LBLX2   DS      0H                                             JEP018\n         SPACE\nCOMMIL   XCALL ILLCMD\n         SPACE\n.LBLX3   DS      0H                                             JEP018\nMNPRTOK  SCKW  ,LNENOPRN,PUSH\n         SCKW  @,SETVAR,(S,P)\n         SCKW  ,BINSRCH\n         SPACE\nIMMEDLNO SCKW  ,LNENOPRN,PUSH\n         SCKW  ,INVALID\n         TITLE 'IMMEDIATE ROUTINES'\n         DS    0H\nGOIMMED  LA    R6,TRYEXN2\n         SCAN  IMMEDLNO\n         B     CVABSENT\n         SPACE\nTRYEXN   CH    R15,=H'16'               IS IT END SPECIFIED?\n         BE    TRYEXN2                  YES IT'S OK.\n         TM    CPGFLG2,CPFEXEC          IS EXEC IN EFFECT?\n         B     TRYEXN2                WAS BO   ALLOW IMMED\n         TSEG  'IN NON-EXEC MODE USE INSERT/DELETE/REPLACE COMMAND'\n         B     CVQTYPE\n         SPACE\nTRYEXN2  ST    R0,CPWK1                 LINE NO.\n         SCTELL (1),(0)                 SAVE POINTERS TO LINE TEXT\n         LTR   R3,R0                    0=DELETE, POS=INSERT OR REPLACE\n         BM    GODODL                   DELETE\n         LA    R13,SZR(R13)             RESERVE SPACE\n         EX    R3,MOVITOUT              MOVE OUT OF RTB\n         LR    R1,R8                    RESET POINTER\n         L     R15,CPWK1                LINE NO. TO R15\n         ST    R15,CPCURRL         UPDATE CURRENT LINE POINTER\n         CVCALL LENCHK                   LENGTH OK?\n         CVCALL PRESS                    PRESS\n         CVCALL STOWIT                   STOW\n         B     CVGETCOM                 TRY FOR NEXT COMMAND\n         SPACE\nMOVITOUT MVC   0(0,R8),0(R1)\n         SPACE\nGODODL   CLI   CPCMNM,C'I'              IS IT IMMEDIATE COMMAND\n         BE    CVABSENT                 NOT ALLOWED...\n         LM    R0,R1,CPTELL             POINTERS TO RESET\n         SCINIT (1),(0)                 REINIT SCAN\n         MVC   CPCMNM(3),=CL3'DEL'      TO SET CPCMNM\n         XCALL GODEL                    TO DELETE RTN\n         TITLE 'CATLG, UNCATLG, RECATLG FIRST LEVEL'\nCATLG    OI    CPLFLG3,CPFDSCLG    INDICATE CATALOG\n         PCALL GOCTLG\n         SPACE\nRECATLG  OI    CPLFLG3,CPFDSCLG    INDICATE RECATLG\nUNCATLG  OI    CPLFLG3,CPFUNCLG    INDICATE UNCATLG\n         PCALL GOCTLG\n         TITLE 'PCALLS TO VARIOUS PAGED ROUTINES'\nGOCLEAR  PCALL CLEAR               DO CLEAR COMMAND\n         SPACE\nGOTSO    PCALL GOTSO\n         SPACE\nSTAX     PCALL STAX\n         SPACE\nSENDMSG  PCALL SEND\n         SPACE\nGODUMP   DS    0H\n         GENTER ,\n         TM    JCBAFL,JCBSYSPR     SYS PRIV?\n         BO    CALLTDU\n         XCALL ILLCMD\nCALLTDU  PCALL GODUMP\n         SPACE\nDECIDE   PCALL DECIDE              DECIDE CODE IS NOW PAGED\n         SPACE\nCOMPAR   PCALL COMPARE             COMPARE CODE IS NOW PAGED\n         SPACE\nMODGO    PCALL MODGO        MODIFY/EDIT COMMANDS ARE PAGED\n         SPACE\nGOWHERE  PCALL WHERE\n         SPACE\nGOSTACK  PCALL STACK\n         SPACE\nGOSUSPND PCALL SUSPND\n         SPACE\nGOLOGOFF PCALL LGOFF\n         SPACE\nGOCOLL   PCALL GOCOLL       COLLECT COMMAND CODE IS PAGED\n         SPACE\nGOINS    PCALL GOINS        INSERT COMMAND CODE IS PAGED\n         SPACE\nGOREPL   PCALL GOREPL       REPLACE COMMAND CODE IS PAGED\n         SPACE\nGONUMB   PCALL GONUMB       NUMBER COMMAND CODE IS PAGED\n         SPACE\nGOSHOW   PCALL GOSHO        SHOW COMMAND CODE IS PAGED\n         SPACE\nGOPUT    PCALL GOPUT        PUT  COMMAND CODE IS PAGED\n         SPACE\nGOALINE  PCALL GOALINE      ALIGN/JUSTIFY CODE IS PAGED\n         SPACE\nGOCENTER PCALL GOCENTR      CENTER COMMAND CODE IS PAGED\n         SPACE\nHELP     GENTER ,\n         L     R2,=A(CMDTAB)      ADDRESS OF COMMAND TABLE\n         LA    R3,CMNDS#          NUMBER OF COMMANDS\n         LA    R4,=A(EOTABL)      ADDRESS OF LAST COMMAND\n         PCALL HELP\n         TITLE 'CLEAR TEST -- CLEAR ACTIVE IF FLAG ON'\n*  CLEAR ACTIVE FILE IF CPFCLEAR FLAG IS ON\n         SPACE\nCLRTST   XENTER 7,8,*              SAVE REGS\n         TM    CPLFLG2,CPFCLEAR    WAS CLEAR SPECIFIED\n         BZ    CLRTSTEX            NO, EXIT FROM ROUTINE\n         CLC   CPAGCT(2),=D'0'     IS THERE ANY ACTIVE FILE\n         BE    CLRTSTEX            NO, EXIT FROM ROUTINE\n         BAL   R14,DOCLEAR         GO CLEAR ACTIVE\nCLRTSTEX XEXIT 7,8                 RETURN\n         TITLE 'CLEAR ROUTINE'\nDOCLEAR  XENTER 2,8,*                   SAVE REGS\nCLRA     MVC   CPHIPS(6),=D'0'          ZERO CPHIPS & CPLNCT\n         LA    R5,CPDREC                FIRST DIRECTORY ENTRY\n         PFREE 9                        OUT WITH ANY PAGE IN R9\n         PFREE 11                       OUT WITH ANY PAGE IN R11\n         LH    R6,CPAGCT                NO. PAGES\n         LTR   R6,R6                    ANY?\n         BZ    FNBLAST                  NO JUNKING NECESSARY\n         OI    CPGFLG,CPFDIRCH         SET DIRECTORY CHANGED\nGOBLAST  LH    R0,4(R5)                 PAGE NO. INTO R0\n         PJUNK (0)                 FREE THIS PAGE\n         LA    R5,6(R5)                 POINT AT NEXT PAGE\n         BCT   R6,GOBLAST               JUNK NEXT PAGE (IF ANY)\nNORLSE   STH   R6,CPAGCT                ZERO PAGE COUNT\nFNBLAST  ST    R6,CPDREC                RESET FIRST DIRECTORY ENTRY\n         MVI   CPCURRL,X'F0'       SET CURRENT LINE INVALID\n         MVI   CPLSTCOL,FNEGBT          SET AS FIRST COLLECT\nCLR2     XEXIT R2,R8                    SCRAM\n         TITLE 'READ COMMAND'\n* READ, READ VALUE, AND READ STRING COMMAND\n* ALL OPTIONS ARE SCANNED FIRST, THEN THE INPUT LINE IS\n* OBTAINED FROM THE TYPEWRITER, ACTIVE FILE, OR EXEC FILE,\n* AND FINALLY THE VALUE, STRING, OR COMMAND IS PROCESSED.\n         SPACE\nGORDCMD  GENTER RDWASIZE           ESTABLISH AND WORK AREA\n         LR    R5,R8               POINT R5 TO WORK AREA\n         USING READWA,R5\n         XC    READWA(RDWASIZE),READWA CLEAR THE WORK AREA\n         MVC   RDWAPRMT(7),=C'ENTER? '   DEFAULT PROMPT\n         LA    R0,7                SET LENGTH\n         STH   R0,RDWAPRLN             FOR PROMPT\n         MVI   RDWACOL1,FNEGBT     SET NO COLUMNS GIVEN\n         CVCALL SCNEXFR            SCAN TO SEE IF READ FROM EXEC\nREADSCNL LA    R6,RDLNENO          SET R6 FOR LINE NUMBER RETURN\nREADSCN  SCAN  READPRT             SCAN READ OPERANDS\nREADSCND TM    RDWAFL,RDWAFLNO     WAS LINE NUMBER GIVEN\n         BO    READACT             BR YES\n         TM    RDWAFL,RDWAFDEL     WAS DELETE GIVEN WITH NO LINE\n         BO    READBAD1            BR YES TO ERROR\n         TM    RDWACOL1,FNEGBT     WERE COLS GIVEN WITH NO LINE\n         BNO   READBAD3            BR YES TO ERROR\n         LH    R0,RDWAPRLN         GET LENGTH FOR PROMPT\n         LA    R1,RDWAPRMT         POINT TO PROMPT\n         TREADR (1),(0),QM=NO      PROMPT USER FOR INPUT\n         BP    CVQTYPE             ABORT IF ATTENTION\n         MVI   CPCTSAV,FNEGBT      SET COMMAND LOGGED\n         B     READDO              NOW GO FINISH COMMAND\n         SPACE\nREADACT  LH    R0,CPAGCT           GET PAGE COUNT OF ACTIVE FILE\n         L     R14,CVLOCATE        POINT TO LOCATE FOR ACTIVE\n         TM    CPLFLG5,CPFSELOC    IS IT SELECT FROM ACTIVE\n         BZ    READNTST            YES, ASSUMPTION WAS CORRECT\n         LH    R0,CPEXCNT          GET EXEC FILE PAGE COUNT\n         L     R14,=A(LOCATEEX)    USE LOCATEEX FOR EXEC FILE\nREADNTST LTR   R0,R0               IS THE SELECTED FILE NULL\n         BNZ   READLOC             NO, GO DO LOCATE\n         CVCALL ITSNIL             REPORT NULL FILE\n         SPACE\nREADLOC  LA    R1,RDWALINO         POINT TO LINE TO LOCATE\n         BALR  R14,R14\n         TM    CPDRPT,CPFMTCH      DOES LINE EXIST\n         BNO   READBAD2            BRANCH TO ERROR IF NO\n         LR    R4,R15              SAVE PTR TO LINE FOR DELETE\n         LA    R1,CPCMSAV          POINT TO UNPRESS AREA\n         CVCALL UNPRESS            UNPRESS THE LINE\n         TM    RDWACOL1,FNEGBT     ANY COLUMN OPTIONS TO PROCESS\n         BO    READACT0            BR NO\n         AH    R1,RDWACOL1         POINT R1 TO NEW TEXT START\n         LH    R2,RDWACOL2         GET LENGTH FROM 2ND COL\n         LTR   R2,R2               WAS 2ND COL GIVEN\n         BZ    READACTA            BR NO TO COMPUTE NEW LENGTH\n         LR    R0,R2               SET LENGTH\n         B     READACT0            DONE WITH COLS, GO ON\n         SPACE\nREADACTA SH    R0,RDWACOL1         SET LENGTH TO REMAINING STRING\n         BNM   READACT0            OK IF NOT NEGATIVE\n         SR    R0,R0               MAKE LENGTH ZERO IF NEGATIVE\nREADACT0 ST    R0,CPCTSAV          SAVE COUNT FOR WRITECOM\n         LR    R2,R0               SAVE LINE COUNT\n         LR    R3,R1               SAVE LINE POINTER\n         PFLIP 9,11                SET PAGE INTO R9 (PROC TO R11)\n         TM    RDWAFL,RDWAFDEL     DELETE THE LINE\n         BE    READACT1            BRANCH NO\n         LR    R15,R4              POINT TO LINE TO DELETE\n         CVCALL  DODELE            GO DO DELETE\nREADACT1 PMOVE R9,R11    FREE R9 PAGE AND MOVE PROC PAGE TO R9\n         LR    R0,R2               RESET R0 COUNT\n         LR    R1,R3               RESET R1 POINTER\n* NOW DO STRING, VALUE, OR COMMAND\nREADDO   TM    RDWAFL,RDWAFPRO+RDWAFSTR   IS IT STRING OR VALUE\n         BZ    RDCMD               NO, GO DO COMMAND\n         BNO   RDVAL               BR IF READ VALUE\n         XCALL READSTR             GO DO READ STRING\n         SPACE\nRDVAL    XCALL READVAR             GO DO READ VALUE\n         SPACE\nRDCMD    XCALL EXLOOPCK            GO CHECK FOR LOOP IN EXEC\n         LR    R2,R0               GET COUNT FOR MVC (EXTRA OK)\n         EX    R2,READMVC          MOVE COMMAND TO CPCMSAV\n         LA    R1,CPCMSAV          POINT R1 TO CMOMMAND\n         MVC   CPLCNO,RDWALINO     SET LINE NUMBER FOR WRITECOM\n         TM    CPGFLG2,CPFNOLOG    EXEC NOLOG MODE\n         BO    RDCMD3              BRANCH YES\n         XCALL WRITECOM            GO WRITE OUT COMMAND\nRDCMD3   LR    R13,R8              RESET R13 FOR NEW COMMAND\n         XCALL EDTCOM              GO EXECUTE THIS COMMAND\n         SPACE\nREADMVC  MVC   CPCMSAV(0),0(R1)\n         SPACE\nNRDELETE NI    RDWAFL,255-RDWAFDEL RESET READ DELETE FLAG\n         BR    R14                 SCAN ON\n         SPACE\nRDELETE  OI    RDWAFL,RDWAFDEL     SET READ DELETE OPTION\n         TM    CPLFLG5,CPFSELOC    IS IT SELECT FROM EXEC\n         BNMR  R14                 NO,  DELETE IS OK\n         B     CVNVALID            YES, IT IS INVALID\n         SPACE\nRDLNENO  ST    R0,RDWALINO         SAVE READ LINE NUMBER\n         OI    RDWAFL,RDWAFLNO     SET LINE NUMBER OPTION FLAG\n         B     READSCNL            GO SCAN ON\n         SPACE\n* SCAN FOR READ STRING IS SAME AS VALUE FOR FIRST PART\nRDSCNSTR OI    RDWAFL,RDWAFSTR     SET STRING GIVEN AND ENTER VAL\n         SPACE\n* SCAN FOR READ VALUE AND REST OF READ STRING\nRDSCNVAL TM    RDWAFL,RDWAFPRO     IS THIS SECOND VALUE OR STRING\n         BO    CVNVALID            YES, IT IS INVALID\n         OI    RDWAFL,RDWAFPRO     SET VALUE OR STRING GIVEN\n         LA    R4,RDWAVAR          POINT TO VARIABLE SAVE AREA\n         LA    R3,1                SET COUNT TO 1\n         MVC   CPWK1(2),0(R1)      SAVE NAME IN CASE VARIABLE\n         L     R14,=A(LOOKUP)      CHECK THAT PRE-PROCESSOR\n         LTR   R14,R14                   IS INCLUDED\n         BZ    CVNVALID            BR NO TO ERROR\n         BALR  R14,R14             GO DO LOOKUP\n         BZ    CVNVALID            INVALID IF FIRST NOT A VAR\nRDSCNVL1 MVC   0(2,R4),CPWK1       PUT VARIABLE NAME IN LIST\n         STH   R3,RDWAVARN         SAVE VARIABLE COUNT\n         TM    RDWAFL,RDWAFSTR     IS IT STRING OPTION\n         BO    RDSCNST1            YES, GO FINISH UP STRING\n         SCANSAVE ,                SAVE SCAN PTRS FOR RESTORE\n         SCAN  ,                   GET NEXT TOKEN\n         SPACE\n         BNP   READSCND            END SCAN IF NO MORE\n         MVC   CPWK1(2),0(R1)      SAVE NAME IN CASE VARIABLE\n         XCALL LOOKUP              IS THIS A VARIABLE\n         BZ    RDSCNRES            NO, GO RESTORE SCAN\n         LA    R4,4(,R4)           STEP TO NEXT STORE AREA\n         LA    R3,1(,R3)           ADD 1 TO COUNT\n         CH    R3,=AL2(RDVARMAX)   IS THERE ROOM FOR THIS VAR\n         BNH   RDSCNVL1            YES, GO STORE AND LOOP\n         TSEG  'TOO MANY VARIABLES IN VALUE LIST'\n         B     CVQTYPE\n         SPACE\nRDSCNST1 ST    R1,0(,R4)           SAVE STRING VARIABLE ADDRESS\n         LTR   R15,R15             TYPE MUST BE ZERO FOR STRING\n         BZ    READSCN             YES, GO SCAN ON\n         TSEG  'READ STRING MUST HAVE STRING VARIABLE'\n         B     CVQTYPE\n         SPACE\nRDSCNRES SCANRSTR ,                RESTORE SCAN POINTERS\n         B     READSCN             CONTINUE SCANNING\n         SPACE\nRDSCNUSI SCAN  READPRT1            USING GIVEN -- GO GET LINENO\n         B     CVABSENT            NONE - REPORT MISSING\n         SPACE\nRDSCNCOL BCTR  R15,0               SET BETTER COLUMN NO.\n         STH   R15,RDWACOL1        SAVE COLUMN NO.\n         SCANSAVE ,                SAVE SCAN PTRS FOR RESTORE\n         SCAN  READPRT2            SCAN FOR 2ND COL NO.\n         B     READSCND            NONE, GO FINISH COMMAND\n         SPACE\nRDSCNCL2 SH    R15,RDWACOL1        GET LENGTH (COL2-(COL1+1))\n         BNP   CVNVALID            ERROR IF NOT POSITIVE\n         STH   R15,RDWACOL2        SAVE LENGTH\n         B     READSCN             CONTINUE SCANNING\n         SPACE\n* PROCESS PROMPT OPTION\nRDSCNPRM CLI   0(R1),C''''         IS PROMPT IN SINGLE QUOTES\n         BE    RDSCNPR1            BR YES\n         CLI   0(R1),C'\"'          IS PROMPT IN DOUBLE QUOTES\n         BNE   CVNVALID            NO, IT IS INVALID\nRDSCNPR1 CVCALL DQSCAN             STRIP QUOTES\n         CH    R0,=AL2(L'RDWAPRMT) IS PROMPT TOO LONG\n         BNH   *+8                 BR NO\n         LA    R0,L'RDWAPRMT       SET MAX LENGTH\n         STH   R0,RDWAPRLN         SAVE LENGTH OF PROMPT\n         LTR   R2,R0               PUT LENGTH IN R2 AND TEST\n         BZ    READSCN             NO MVC IF NULL\n         BCTR  R2,0                SET FOR EXECUTE\n         EX    R2,RDMVCPRM         MOVE PROMPT\n         B     READSCN             CONTINUE SCAN\n         SPACE\nRDMVCPRM MVC   RDWAPRMT(0),0(R1)   MVC FOR PROMPT MOVE\n         SPACE\nREADBAD1 SYSQS 1,0,'DELETE'        SET PART OF ERROR MESSAGE\n         B     READBAD4            GO PUT OUT MESSAGE\n         SPACE\nREADBAD2 L     R0,RDWALINO         GET LINE NUMBER\n         CVCALL CVEXNO             CONVERT TO EXTERNAL\n         TSEG  (1),(0),B           PUT OUT LINE NUMBER\n         TSEG  'NOT IN FILE'\n         B     CVQTYPE             GO ABORT\n         SPACE\nREADBAD3 SYSQS 1,0,'COLUMN'        SET PART OF ERROR MESSAGE\nREADBAD4 TSEG  (1),(0),B       PUT OUT FIRST PART OF MESSAGE\n         TSEG  'OPTION GIVEN WITHOUT A LINE NUMBER'\n         B     CVQTYPE\n         TITLE 'UTILITY ROUTINES'\n* ILLEGAL ITEM ROUTINE\n         SPACE\nUNLEGAL  GENTER ,                       ENTRY & BASE REG\n         TSEG  ' ILLEGAL'\n         B     QTYPED\n         SPACE 3\n* MISSING ITEM ROUTINES\n         SPACE\nABSCENT  GENTER ,                       ENTRY & BASE REG\n         TSEG  'OPERAND'\n         SPACE\nAMMISS   GENTER ,                       ENTRY & BASE REG\n         TSEG  ' MISSING'\n         SPACE\nQTYPED   GENTER ,\n         TM    CPGFLG,CPFRETRY         IS RETRY GOING ON?\n         BZ    QTYPED1                 NO\n         NI    CPGFLG,255-CPFRETRY\nQTYPED1  NI    JCBAFL,X'FF'-JCBAFIA     TURN ATTN FLAG OFF\n         TCLEARQ INPUT             FLUSH INPUT BUFFERS\n         NI    RTBMFL,X'FF'-RTBNOCR-RTBNOTR RESET NOCR, NOTR\n         TM    CPGFLG2,CPFEXEC         IS EXEC IN EFFECT\n         BE    CVGETCOM            NO, GET NEXT COMMAND\nQSYSRDY  CLC   RTBWC(2),=D'0'     ANYTHING TO WRITE?\n         BE    QSYSGO                  NO\n         TWRITE ,\n         SPACE\nQSYSGO   GENTER ,\n         TM    CPGFLG2,CPFEXEC         IS EXEC IN EFFECT\n         BZ    CVGETCOM            NO, GO GET NEXT CMD\n         XCALL EXECABRT                GO DO EXEC BREAK\n         EJECT\n*  FOR READ COMMAND\n         SPACE\nREADPRT  SCKW  NODELETE,NRDELETE,A\n         SCKW  DELETE,RDELETE,A\n         SCKW  STRING,RDSCNSTR,(A,P)\n         SCKW  PROMPT,RDSCNPRM,(A,P)\n         SCKW  USING,RDSCNUSI,A\n         SCKW  COLUMNS,RDSCNCOL,(A,P,PI),133\n         SCKW  COLS,RDSCNCOL,(P,PI),133\n         SCKW  VALUE,RDSCNVAL,(A,P)\nREADPRT1 SCKW  ,LNENOPRT,PUSH\n         SCKW  EXECUTE,,A\n         SCKW  ,INVALID\n         SPACE\nREADPRT2 SCKW  /,RDSCNCL2,(P,PI),133\n         SCKW  ,RDSCNRES\n         EJECT\nATTNRTN  DS    0H\n         USING ATTNRTN,R15\n         L     R1,8(,R1)\n         USING CPAREA,R1\n         DROP  R12\n         OI    JCBAFL,JCBAFIA      IDLE ATTN\n         LH    R2,JCBPAGES\n         LA    R2,1(,R2)\n         CH    R2,=H'10'\n         STH   R2,JCBPAGES\n         BNHR  R14\n         ABEND 100,DUMP\n         DROP  R1\n         USING CPAREA,R12\n         EJECT\n* SYNAD ROUTINE DOES ALMOST NOTHING\n         USING PFCB,R3\nPSYNAD   OI    JCBBFL,JCBBFPER     INDICATE PAGE ERROR\n         MVC   PFCBNP(4),PFCBCP    AND INDICATE END OF PAGES\n         BR    R14                 AND RETURN TO PGETS\n         DROP  R3\n         TITLE 'LITERALS'\n         LTORG\n         TITLE 'CONSTANTS, ETC.'\n         COPY  WYLCONST\nCHGFINCD EQU   32                       CHANGES FINISHED CODE\n         EJECT\n         COMMON\n         SPACE\n         EJECT\n         COPY  READWA\n         EJECT\nPFCB     DSECT\n         COPY   PFCBTSO\n         SPACE\n         IHASDWA ,                      FOR DIAG WORK AREA (ESTAE)\n         END\n./ ADD NAME=PWYL8,SSI=00000185\nPWYL     TITLE 'WYLTSO ENTRY AND COMMAND PROMPTER'\n* PROPERTY OF C. U. C. C. A.\n         GBLC    &CCI             SWITCH FOR CCI MODS           CCI001\n&CCI    SETC   '1'  CHANGE TO ANY OTHER NUM. TO DELETE CCI MOD  CCI001\n         AIF   ('&CCI' NE '1').LBL01                            CCI001\n*                                                               CCI001\n* MOD CCI001                                                    CCI001\n*  IMPLIMENT RUN COMMAND                                        CCI001\n*                                                               CCI001\n*                                                               JEP015\n* MOD JEP018                                                    JEP018\n*  ALLOW ALL NON-WYL CMDS AS VALID WYLBUR SUBCOMMANDS.          JEP018\n*  MODULES AFFECTED ARE PWYL AND PEDP. MOD DENOTED BY           JEP018\n*  JEP018 IN CC 66/71.     JERRY PITTENGER                      JEP018\n*                                                               JEP018\n*                                                               JEP018\n.LBL01   DS    0H                                               CCI001\n      EJECT                                                     JEP004\n         SPACE 3\nPWYL     CSECT\n         WIDENT 001\n         USING CPAREA,R12\n         SPACE\n         XTRNS\n         EJECT\n         ENTRY WYLTSO,CMDPRT,PSYNAD,ATTNRTN\n         SPACE\nWYLTSO   STM   R14,R12,12(R13)     SAVE ZE REGS\n         BALR  R7,R0               ESTABLISH A BASE REG\n         USING *,R7\n         L     R7,=A(WYLTSO)\n         LR    R9,R1               PARMS IF ANY\n         USING WYLTSO,R7\n         LR    R11,R13             RECALL RETURN SAVEAREA\n         LOAD  EP=WYLINIT\n         LR    R15,R0              ENTRY POINT ADDRESS\n         L     R1,=V(CVREAL)       ADDRESS OF REAL CV\n         BALR  R14,R15             GO TO IT\n         BALR  R7,R0               RESTORE BASE REG\n         USING *,R7\n         L     R7,=A(WYLTSO)\n         USING WYLTSO,R7\n         DELETE EP=WYLINIT         GET RID OF INIT MODULE\n         SR    R9,R9               CLEAR POSSIBLE PAGE PTR\n         SR    R10,R10             CLEAR POSSIBLE PAGE POINTER\n         SR    R11,R11             DITTO\n         SR    R0,R0\n         LR    R8,R13\n         ESTAE FIXUP,TERM=YES\n         IC    R0,CVPARM\n         LTR   R0,R0\n         BZ    XLOGON\n         L     R1,CVPARM\n         LA    R1,0(,R1)\n         B     EDTCOMMV\n         SPACE 3\nXLOGON   CLI   CPCMSAV,C';'              LOGON EXEC?\n         BNE   CMDPRT\n         L     R0,CPCTSAV\n         LA    R1,CPCMSAV+1\n         B     EDTCOM\n         EJECT\n* DO INVALID OPTIONS MSG HERE\n         SPACE\nINVALID  GENTER ,                       SET BASE REG\n         NI    RTBMFL,X'FF'-RTBNOCR-RTBNOTR RESET NOCR, NOTR\n         LM    R0,R1,CPSAVE             PICK UP PTRS\n         LTR   R0,R0                    POS COUNT?\n         BZ    CVABSENT                 MISSING\n         BNM   NOWSEG                   YES\n         LCR   R0,R0                    COMPLEMENT COUNT\nNOWSEG   CH    R0,=H'15'                USE ONLY 15 CHARS\n         BNH   *+8                      BRANCH O.K.\n         LA    R0,15                    SET TO MAX COUNT\n         TSEG  (1),(0)                  INVALID ITEM INTO MSG\n         TSEG  ': INVALID'\n         TM    CPGFLG2,CPFEXEC          IS EXEC IN EFFECT\n         BO    CVQTYPE                  YES\n         B     CMDPRT\n         TITLE 'ESTAE ROUTINE'\n         PUSH USING\n         SPACE 1\nFIXUP    STM   R14,R12,12(R13)          SAVE REGS\n         LR    R10,R1\n         USING SDWA,R10\n         BALR  R11,0\n         USING *,R11\n         L     R12,SDWAGR12          LOAD CP REGISTER\n         ICM   R15,15,CVSPIEAD        SEE IF ANY ADDRESS\n         BNZ   RETRY2\n         SPACE 1\n         CLC   SDWAABCC+1(2),=X'0470'   LOST AUTHORITY?\n         BNE   ABENDED                  NO, THEN WE ABENDED\n         SPACE 1\n         TPUT  APFMSG,L'APFMSG\n         B     RETRY\n         SPACE\nABENDED  UNPK  ABENDCDE(9),SDWAABCC(5)     CONVERT TO HEX\n         TR    ABENDCDE(8),TRTOHEX\n         MVI   ABENDCDE+8,C' '\n         SPACE 1\n         TPUT  ESTAEMSG,ESTAEMSZ\n         TPUT  REGMSG,32\n         LA    R2,SDWAGRSV     SAVE AREA\n         BAL   R14,TOHEX       TRANSLAGE\n         TPUT  HEX,36          PRINT IT\n         LA    R2,16(,R2)      NEXT REGISTERS\n         BAL   R14,TOHEX       TRANSLATE AGAIN\n         TPUT  HEX,36\n         LA    R2,16(,R2)      NEXT REGISTERS\n         BAL   R14,TOHEX       TRANSLATE AGAIN\n         TPUT  HEX,36\n         LA    R2,16(,R2)      NEXT REGISTERS\n         BAL   R14,TOHEX       TRANSLATE AGAIN\n         TPUT  HEX,36\n         SLR   R15,R15         FOR IC\n         IC    R15,SDWAILC2    LENGTH OF IC\n         L     R2,SDWAPMKP     NEXT INST\n         SR    R2,R15          POINT TO FAILING INST\n         ST    R2,CPDOUB       STORE IT\n         LA    R2,CPDOUB       POINT TO IT\n         BAL   R14,TOHEX       TRANSLAGE\n         MVC   ADR,HEX+2      MOV ABEND ADDRESS\n         TPUT  ADRMSG,ADRSIZ\nABNDMSG  TPUT  RETRYMSG,L'RETRYMSG\n         TGET  HEX,8         GET REPLY\n         OC    HEX(8),=CL8' '\n         CLC   HEX(5),=C'RETRY' IS IT RETRY\n         BE    RETRY\n         CLC   HEX(5),=C'ABEND' IS IT ABEND\n         BE    ATTNOUT\n         B     ABNDMSG        RE-ISSUE MESSAGE\n         SPACE\nRETRY    LA     R15,CMDPRT             SET AS RETRUN ADDRESS\nRETRY2   SETRP WKAREA=(10),REGS=(14,12),RC=4,RETADDR=(R15),            *\n               RETREGS=YES,FRESDWA=YES\n         SPACE\nATTNOUT  DS    0H\n         SETRP WKAREA=(10),REGS=(14,12),RC=0\n         SPACE\n         LTORG\n         SPACE\nTOHEX    UNPK  HEX(9),0(5,R2)\n         UNPK  HEX+9(9),4(5,R2)\n         UNPK  HEX+18(9),8(5,R2)\n         UNPK  HEX+27(9),12(5,R2)\n         TR    HEX(35),TRTOHEX\n         MVI   HEX+8,C' '\n         MVI   HEX+17,C' '\n         MVI   HEX+26,C' '\n         MVI   HEX+35,C' '\n         BR    R14                      RETURN\nADRMSG   DC    C'ADDRESS OF FAILING INSTRUCTION '\nADR      DC    CL6' '\nADRSIZ    EQU    *-ADRMSG\nREGMSG   DC    CL32'REGISTERS AT ENTRY TO ABEND'\nESTAEMSG DC    C'WYLBUR ESTAE TRAPPED ABEND='\nABENDCDE DC    C'XXXXXXXX '\nESTAEMSZ EQU   *-ESTAEMSG\nRETRYMSG DC    C'ENTER OPTION RETRY, OR ABEND'\nAPFMSG   DC    C'AUTHORIZATION LOST: SUSPEND CURRENT SESSION'\nHEX      DC    6D'0'\nTRTOHEX  EQU   *-C'0'\n         DC    C'0123456789ABCDEF'\n         POP   USING\n         TITLE 'CMDPRT ROUTINE'\n* CMDPRT PROMPTS FOR AND RECOGNIZES ALL WYLBUR COMMANDS.\n* CTL IS PASSED TO THE APPROPRIATE ROUTINE FOR ALL COMMANDS.\n* AFTER THE FIRST TIME THRU, CMDPRT IS ALWAYS CALLED, NEVER\n* RETURNED TO. R8 AND R13 ARE INITIALIZED TO POINT TO CPWA.\n         SPACE\nCMDPRT   LA    R13,CPWA                 START OF WORK AREA\n         LR    R8,R13                   ALSO HERE\n         XC    CVPGRTN(4),CVPGRTN       CLR PTR TO CURRENT PGED CDE\n         XC    CVSPIEAD,CVSPIEAD      CLEAR SPIE ADDRESS\n         XC    JCBPAGES(2),JCBPAGES\n         TM    JCBAFL,JCBAFIA           USER HIT ATTN?\n         BO    CVQTYPE                  YES... PROCESS\n         BALR  R7,0                     SET BASE REG\n         USING *,7\n         TM    CPGFLG,CPFOPN            ANY EXTERNAL DATA SET OPEN?\n         BZ    READY                    NO\n         DCLOSE ,                       CLOSE IT\n         NI    CPGFLG,255-CPFOPN        SET CLOSED\nREADY    C     R9,CVCPADDR         IS THIS THE VCP?\n         BNE   GOPFREE\n         SR    R9,R9\n         B     PFREE10\n         SPACE\nGOPFREE  PFREE 9                        FREE IF NECESSARY\nPFREE10  PFREE 10\n         PFREE 11                       FREE IF NECESSARY\n         LH    R0,RTBWC                 GET CURRENT WRITE COUNT\n         LTR   R0,R0                    ANYTHING OUTSTANDING?\n         BZ    NADA                     NOPE\n         TWRITE ,\nNADA     TM    JCBBFL,JCBBFPER          PAGING ERROR?\n         BZ    CMNDPRTG                 BR IF NOT\n         NI    JCBBFL,255-JCBBFPER      CLEAR ERROR FLAG\n         BAL   R2,QZWRITIT              TYPE BUFFER\n         TSEG  'I/O ERRORS MAY HAVE DAMAGED YOUR ACTIVE FILE',,M\n         SPACE\nCMNDPRTG TM    RTBMFL,RTBNOCR         NOCR?\n         BZ    NOMARK\n         NI    RTBMFL,X'FF'-RTBNOCR   RESET NOCR\n         SR    0,0\n         TSEG  (1),(0),W              PLANT CR/LF\nNOMARK   NI    RTBMFL,X'FF'-RTBNOTR   RESET NOTR\n         TM    CPGFLG2,CPFEXEC        IS EXEC IN EFFECT?\n         BE    CMNDPRTH                BRANCH NO\n         BAL   R2,QZWRITIT             TYPE BUFFER\n         XCALL GETEXCMD                GO GET COMMAND FROM EXEC\n         SPACE\nCMNDPRTH SR    R0,R0\n         TM    CPGFLG,CPFRETRY        IS RETRY GOING ON?\n         BZ    READYZ                 NO, GET COMMAND\n         MVI   CPCTSAV,0\n         L     R0,CPCTSAV             GET COUNT\n         LA    R1,CPCMSAV             GET ADDRESS\n         NI    CPGFLG,255-CPFRETRY    SET RETRY NOT IN EFFECT\n         B     EDTCOM                 GO DO COMMAND\n         SPACE\nREADYZ   TM    CPGFLG,CPFCMOFF        \"COMMAND\" IN PROMPT?\n         BO    GOREAD                 NO\n         SYSQS 1,0,'COMMAND'          SET UP \"COMMAND\" PROMPT\nGOREAD   L     R15,=X'005A5B7C'\n         LCR   R15,R15\n         CVCALL TRDRTN\n         BP    CMDATTN                BR IF ATTENTION\n         LTR   R0,R0                  ANYTHING TYPED?\n         BZ    READYZ                 NO - TRY AGAIN\n         BCT   R0,CMDCONT             SEE IF 1 CHAR\n         CLI   0(R1),C'$'             IS IT A RETRY REQUEST\n         BE    CMDRETRY\nCMDCONT  A     R0,=F'1'\n         MVI   CPCTSAV,0              SET COMMAND NOT LOGGED\n         B     EDTCOMMV               GO SCAN COMMAND\n         SPACE\nQZWRITIT CLC   RTBWC(2),=D'0'         ANYTHING TO WRITE?\n         BER   R2                     NO\n         TWRITE ,                     WRITE IT\n         BR    R2                     RETURN\n         SPACE\nCMDATTN  LTR   R0,R0                  ANY CHARACTERS BEFORE ATTN\n         BZ    CMDCOL                 NO, GO START COLLECT CMD\n         LR    R2,R0                 LENGTH OF INPUT\n         BCTR  R2,R0                 LESS 1\n         LA    R2,0(R2,R1)           LAST CHAR OF INPUT\n         CLI   0(R2),C'$'            RETRY WANTED\n         BNE   CVGETCOM\nCMDRETRY MVI   CPCTSAV,0             CLEAR HI ORDER BIT\n         OI    CPGFLG,CPFRETRY       SET RETRY GOING ON\n         B     MODGO                 GO TO MODIFY COMMAND\n         SPACE\nCMDCOL   TM    RTBUFL,RTBUNCOL       AUTO COLLECT WANTED?\n         BO    CVGETCOM              NOPE\n         LA    R1,=C'C'              PRETEND COLLECT WAS TYPED\n         SR    R0,R0                 WILL BE ADDED 1\n         B     CMDCONT                GO EXECUTE COMMAND\n         SPACE 3\nILLCMD   GENTER ,\n         CH    R0,=H'15'\n         BNH   *+8\n         LA    R0,15\n         TSEG  (1),(0)\n         TSEG  ': ILLEGAL COMMAND'\n         B     CVQTYPE\n         TITLE 'NEW COMMAND SETUP AND SCAN'\n* ALL COMMANDS MUST BE AT CPCMSAV AT START OF COMMAND SCAN.  THE\n* LENGTH OF THE COMMAND IS IN CPCTSAV.  IF THE NEGATIVE BIT IS\n* ON IN CPCTSAV, THEN THE COMMAND HAS BEEN LOGGED AT THE\n* TYPEWRITER.  THIS AFFECTS THE EXECUTION OF EXEC, LOAD, AND\n* COMMENT COMMANDS.  AT ENTRY TO EDTCOMMV OR EDTCOM R1 AND R0\n* MUST POINT TO THE COMMAND TO BE EXECUTED.  ENTER AT EDTCOMMV\n* IF THE COMMAND IS NOT ALREADY AT CPCMSAV, OTHERWISE, ENTER AT\n* EDTCOM.  IF NEGATIVE BIT IS ON IN CPCTSAV, THEN THE COUNT\n* IS ALWAYS IGNORED.\n         SPACE\nEDTCOMMV GENTER ,\n         LR    2,0\n         EX    2,CMDMOVE          MOVES COMMAND+1 TO CPCMSAV\n         TM    CPCTSAV,FNEGBT      HAS COMMAND BEEN LOGGED\n         BO    *+8                 YES, DON'T SET COUNT & CLEAR\n         ST    R0,CPCTSAV          SET COUNT SO LOG CAN BE DONE\n         LA    1,CPCMSAV          POINT TO COMMAND\nEDTCOM   GENTER ,                 BASE REG & ENTRY FOR MODE=EDIT\n         TM    CPGFLG2,CPESNULL    ESC CHAR\n         BNZ   EDTCOM1             NO, SKIP CALL OF PRE-PROC\n         MVC   CPCMNM(8),=D'0'     CLEAR FLAGS FOR PRE-PROCESSOR\n         MVI   CPSYSFLG,0               MAKE SURE ZERO\n         XCALL PREPROC            FINALLY,CALL THE PRE-PROCESSOR\n         BZ    EDTCOM1            NOTHING WAS CHANGED\n         ST    R0,CPCTSAV          SAVE NEW COUNT FOR LOG\n         TM    CPGFLG2,CPFEXEC     EXEC MODE\n         BZ    EDTRSE2             BR NO TO TEST TERSE MODE\n         TM    CPGFLG2,CPFEXTER    IS IT EXEC TERSE MODE\n         BO    EDTCOM1             YES, DON'T LIST CHANGED LINE\n         B     EDTRSE3             NO, GO LIST CHANGED LINE\n         SPACE\nEDTRSE2  TM    CPGFLG,CPFCMOFF     IS IT TERSE MODE\n         BO    EDTCOM1             BR YES TO SKIP WRITE\nEDTRSE3  LR    4,0\n         LR    5,1\n         TSEG  (1),(0),WRITE      PRINT CHANGED COMMAND\n         BP    CVQTYPE             ABORT IF ATTENTION\n         LR    0,4                RESTORE R0\n         LR    1,5                RESTORE R1\n         MVI   CPCTSAV,FNEGBT      SET COMMAND HAS BEEN LOGGED\nEDTCOM1  DS    0H\n         SR    R9,R9               CLEAR PAGE PTR\n         STM   R0,R1,CPTELL             SAVE POINTERS\n         SCINIT (1),(0)                 INITIALIZE SCAN\n         MVC   CPCMNM(8),=D'0'          SETUP FOR NEW COMMAND\n         MVI   CPSYSFLG,0               MAKE SURE ZERO\n         LA    R6,TRYEXN           SET FOR LINE NUMBER COMMAND\nOFCOURSE L     R1,=A(MNPRTOK)           SET ADDR PRT\nSCANEM   SCAN  (1)                      SCAN\n         B     CVGETCOM                NOTHING -- GO GET NEXT\n         SPACE\nCMDMOVE  MVC   CPCMSAV(0),0(1)\n         TITLE 'BINARY SEARCH FOR MAJOR COMMANDS'\n* COMMAND TABLE FORMAT:\n*   8 CHARS COMMAND ID\n*   4 BYTE COUNTER (NOT USED IN WYLTSO)\n*   1 BYTE FLAG (INDICATING ABBREVIATIONS)\n*   3 BYTE ADRESS FOR THE COMMAND ROUTINES\n*  --------\n*  16 BYTES TOTAL PER COMMAND\n         SPACE\nBINSRCH  CH    R0,=H'8'        TOO LONG A COMMAND?\n         BH    COMMIL          YES.\n         LR    R5,R0           GET LENGTH OF COMMAND\n         BCTR  R5,R0           GUESS WHY\n         LA    R6,1            TO PROPAGATE A 1 BIT\n         SLL   R6,0(R5)        TO FORM A LENGTH MASK\n         L     R2,=F'-1'\n         LA    R3,CMNDS#+1\nBINLOOP  LA    R4,0(R2,R3)\n         SRL   R4,1            DIVIDE BY 2\n         SLL   R4,4            MULTIPLY BY 16\n         LA    R4,CMDTAB(R4)   POINT TO ENTRY\n         EX    R5,CLC          SEE WHETHER TO GO UP OR DOWN\n         BL    ITSLESS\n         BH    ITSHIGH\n         EX    R6,TMINSTR      IS THIS ABBREV OK?\n         BO    WEGOTIT\n         LR    R14,R4          KEEP THE CURRENT POINTER\nBACKUP   S     R4,=F'16'       BACK UP AN ENTRY\n         C     R4,=A(CMDTAB)\n         BL    ADVANCEX\n         EX    R5,CLC          IS THIS A GOOD ONE?\n         BNE   ADVANCEX\n         EX    R6,TMINSTR      A GOOD ABBREV?\n         BO    WEGOTIT\n         B     BACKUP          KEEP BACKING UP\n         SPACE\nADVANCEX LR    R4,R14          RESTORE PONTER\nADVANCE  LA    R4,16(,R4)      STEP UP\n         C     R4,=A(EOTABL)\n         BH    COMMIL\n         EX    R5,CLC          IS IT THIS ONE?\n         BNE   COMMIL\n         EX    R6,TMINSTR      GOOD ABREV?\n         BO    WEGOTIT\n         B     ADVANCE\n         SPACE\nWEGOTIT  L     R14,12(,R4)     FIND WHERE TO GO\n         MVC   CPCMNM(3),0(R4) MOVE THE FULL COMMAND\n         BR    R14\n         SPACE\nITSLESS  LA    R2,0(R2,R3)\n         SRL   R2,1\nCOMPARE  LA    R15,1(,R2)\n         CR    R15,R3\n         BL    BINLOOP\n         B     COMMIL\n         SPACE\nITSHIGH  LA    R3,0(R2,R3)\n         SRL   R3,1\n         B     COMPARE\n         SPACE\nCLC      CLC   0(0,R4),0(R1)\n         SPACE\nTMINSTR  TM    12(R4),X'00'\n         SPACE 3\n         DS    0F\nCMDTAB   COMMAND ?,SHOVAR,HSHOW,1\n         COMMAND @,SETVAR,HSET,1\n         COMMAND ALIGN,GOALINE,HALIGN,1,2,3,4,5\n         COMMAND CATLG,CATLG,HCATLG,3,4,5\n         COMMAND CENTER,GOCENTER,HCENTR,2,3,4,5,6\n         COMMAND CHANGE,GOCHNG,HCHANG,2,3,4,5,6\n         COMMAND CLEAR,GOCLEAR,HCLEAR,2,3,4,5\n         COMMAND CLR,GOCLEAR,HCLEAR,2,3\n         COMMAND COLLECT,GOCOLL,HCOLCT,1,2,3,4,5,6,7\n         COMMAND COMMENT,GOCOMMNT,HCOMNT,4,5,6,7\n         COMMAND COMPARE,COMPAR,HCOMP,3,4,5,6,7\n         COMMAND COPY,GOCOPY,HCOPY,3,4\n         COMMAND DECIDE,DECIDE,HDECD,3,4,5,6\n         COMMAND DELETE,GODEL,HDEL,1,2,3,4,5,6\n         COMMAND DISPLAY,GOCOMMNT,HCOMNT,2,3,4,5,6,7\n         COMMAND EDIT,MODGO,HEDIT,1,2,3,4\n         COMMAND EXECUTE,GOEXEC,HEXCT,2,3,4,5,6,7\n         COMMAND HELP,HELP,HHELP,1,2,3,4\n         COMMAND IF,GOIF,HIF,2\n         COMMAND IMMEDIAT,GOIMMED,NOHELP,2,3,4,5,6,7,8\n         COMMAND INSERT,GOINS,HINSRT,1,2,3,4,5,6\n         COMMAND JUSTIFY,GOALINE,HJUST,2,3,4,5,6,7\n         AIF   ('&CCI' EQ '1').LBL11   DEL LI AS LIST ALIAS     JEP006\n         COMMAND LIST,GOLSPRN,HLIST,1,2,3,4\n         AGO   .LBL12                                           JEP006\n.LBL11   DS    0C                                               JEP006\n         COMMAND LIST,GOLSPRN,HLIST,1,3,4                       JEP006\n.LBL12   DS    0C                                               JEP006\n         COMMAND LOAD,GOLOAD,HLOAD,3,4\n         AIF   ('&CCI' EQ '1').LBLX1   LOGOFF INVALID AT DCEC   CCI001\n         COMMAND LOGOFF,GOLOGOFF,HLOGF,5,6\n.LBLX1   DS    0C                                               CCI001\n         COMMAND LOGOUT,GOLOGOFF,HLOGF,5,6\n         COMMAND MODIFY,MODGO,HMODFY,1,2,3,4,5,6\n         COMMAND MOVE,GOMOVE,HMOVE,3,4\n         COMMAND NUMBER,GONUMB,HNUM,1,2,3,4,5,6\n         COMMAND POINT,GOPOINT,HPOINT,1,2,3,4,5\n         COMMAND POP,GOSTACK,HPOP,3\n         COMMAND PRINT,GOLSPRN,NOHELP,2,3,4,5 PRINT COMMAND     CCI001\n         COMMAND PUT,GOPUT,HPUT,2,3\n         COMMAND READ,GORDCMD,HREAD,3,4\n         COMMAND RECATLG,RECATLG,HRECAT,3,4,5,6,7\n         COMMAND RENAME,GOREN,HRENM,3,4,5,6\n         COMMAND REPLACE,GOREPL,HREP,1,2,3,4,5,6,7\n         COMMAND RESTORE,GORESTOR,HRESTR,3,4,5,6,7\n         AIF   ('&CCI' NE '1').LBL15                            CCI001\n         COMMAND RUN,GOLSPRN,NOHELP,3     RUN COMMAND           CCI001\n.LBL15   DS    0C                                               CCI001\n         COMMAND SAVE,GOSAVE,HSAVE,1,2,3,4\n         COMMAND SCRATCH,GOSCRT,HSCR,2,3,4,5,6,7\n         COMMAND SEND,SENDMSG,HSEND,2,3,4\n         COMMAND SET,GOSET,HSET,3\n         COMMAND SHOW,GOSHOW,HSHOW,2,3,4\n         COMMAND SIGNOFF,GOLOGOFF,HLOGF,6,7\n         AIF   ('&CCI' NE '1').LBL16                            JEP015\n         COMMAND  SO,GOLOGOFF,HLOGF,2     SHORT SIGNOFF CMD     JEP015\n.LBL16   DS    0C                                               JEP015\n         COMMAND STACK,GOSTACK,HSTACK,3,4,5\n         COMMAND STAX,STAX,NOHELP,4\n         COMMAND SUSPEND,GOSUSPND,HSUSP,2,3,4,5,6,7\n         COMMAND TDUMP,GODUMP,NOHELP,1,2,3,4,5\n         COMMAND TO,SENDMSG,HSEND,2\n         COMMAND TSO,GOTSO,HTSO,2,3\n         COMMAND UNCATLG,UNCATLG,HUNCAT,3,4,5,6,7\n         COMMAND USE,GOUSE,HUSE,1,2,3\n         COMMAND WHERE,GOWHERE,NOHELP,1,2,3,4,5\nEOTABL   COMMAND X,GOEXEC,HEXCT,1\nCMNDS#   EQU   (*-CMDTAB)/16  NUMBER OF ENTRIES\n         AIF ('&CCI' NE '1').LBLX2                              JEP018\nCOMMIL   PCALL TSOCMDS                                          JEP018\n         AGO   .LBLX3                                           JEP018\n.LBLX2   DS      0H                                             JEP018\n         SPACE\nCOMMIL   XCALL ILLCMD\n         SPACE\n.LBLX3   DS      0H                                             JEP018\nMNPRTOK  SCKW  ,LNENOPRN,PUSH\n         SCKW  @,SETVAR,(S,P)\n         SCKW  ,BINSRCH\n         SPACE\nIMMEDLNO SCKW  ,LNENOPRN,PUSH\n         SCKW  ,INVALID\n         TITLE 'IMMEDIATE ROUTINES'\n         DS    0H\nGOIMMED  LA    R6,TRYEXN2\n         SCAN  IMMEDLNO\n         B     CVABSENT\n         SPACE\nTRYEXN   CH    R15,=H'16'               IS IT END SPECIFIED?\n         BE    TRYEXN2                  YES IT'S OK.\n         TM    CPGFLG2,CPFEXEC          IS EXEC IN EFFECT?\n         B     TRYEXN2                WAS BO   ALLOW IMMED\n         TSEG  'IN NON-EXEC MODE USE INSERT/DELETE/REPLACE COMMAND'\n         B     CVQTYPE\n         SPACE\nTRYEXN2  ST    R0,CPWK1                 LINE NO.\n         SCTELL (1),(0)                 SAVE POINTERS TO LINE TEXT\n         LTR   R3,R0                    0=DELETE, POS=INSERT OR REPLACE\n         BM    GODODL                   DELETE\n         LA    R13,SZR(R13)             RESERVE SPACE\n         EX    R3,MOVITOUT              MOVE OUT OF RTB\n         LR    R1,R8                    RESET POINTER\n         L     R15,CPWK1                LINE NO. TO R15\n         ST    R15,CPCURRL         UPDATE CURRENT LINE POINTER\n         CVCALL LENCHK                   LENGTH OK?\n         CVCALL PRESS                    PRESS\n         CVCALL STOWIT                   STOW\n         B     CVGETCOM                 TRY FOR NEXT COMMAND\n         SPACE\nMOVITOUT MVC   0(0,R8),0(R1)\n         SPACE\nGODODL   CLI   CPCMNM,C'I'              IS IT IMMEDIATE COMMAND\n         BE    CVABSENT                 NOT ALLOWED...\n         LM    R0,R1,CPTELL             POINTERS TO RESET\n         SCINIT (1),(0)                 REINIT SCAN\n         MVC   CPCMNM(3),=CL3'DEL'      TO SET CPCMNM\n         XCALL GODEL                    TO DELETE RTN\n         TITLE 'CATLG, UNCATLG, RECATLG FIRST LEVEL'\nCATLG    OI    CPLFLG3,CPFDSCLG    INDICATE CATALOG\n         PCALL GOCTLG\n         SPACE\nRECATLG  OI    CPLFLG3,CPFDSCLG    INDICATE RECATLG\nUNCATLG  OI    CPLFLG3,CPFUNCLG    INDICATE UNCATLG\n         PCALL GOCTLG\n         TITLE 'PCALLS TO VARIOUS PAGED ROUTINES'\nGOCLEAR  PCALL CLEAR               DO CLEAR COMMAND\n         SPACE\nGOTSO    PCALL GOTSO\n         SPACE\nSTAX     PCALL STAX\n         SPACE\nSENDMSG  PCALL SEND\n         SPACE\nGODUMP   DS    0H\n         GENTER ,\n         TM    JCBAFL,JCBSYSPR     SYS PRIV?\n         BO    CALLTDU\n         XCALL ILLCMD\nCALLTDU  PCALL GODUMP\n         SPACE\nDECIDE   PCALL DECIDE              DECIDE CODE IS NOW PAGED\n         SPACE\nCOMPAR   PCALL COMPARE             COMPARE CODE IS NOW PAGED\n         SPACE\nMODGO    PCALL MODGO        MODIFY/EDIT COMMANDS ARE PAGED\n         SPACE\nGOWHERE  PCALL WHERE\n         SPACE\nGOSTACK  PCALL STACK\n         SPACE\nGOSUSPND PCALL SUSPND\n         SPACE\nGOLOGOFF PCALL LGOFF\n         SPACE\nGOCOLL   PCALL GOCOLL       COLLECT COMMAND CODE IS PAGED\n         SPACE\nGOINS    PCALL GOINS        INSERT COMMAND CODE IS PAGED\n         SPACE\nGOREPL   PCALL GOREPL       REPLACE COMMAND CODE IS PAGED\n         SPACE\nGONUMB   PCALL GONUMB       NUMBER COMMAND CODE IS PAGED\n         SPACE\nGOSHOW   PCALL GOSHO        SHOW COMMAND CODE IS PAGED\n         SPACE\nGOPUT    PCALL GOPUT        PUT  COMMAND CODE IS PAGED\n         SPACE\nGOALINE  PCALL GOALINE      ALIGN/JUSTIFY CODE IS PAGED\n         SPACE\nGOCENTER PCALL GOCENTR      CENTER COMMAND CODE IS PAGED\n         SPACE\nHELP     GENTER ,\n         L     R2,=A(CMDTAB)      ADDRESS OF COMMAND TABLE\n         LA    R3,CMNDS#          NUMBER OF COMMANDS\n         LA    R4,=A(EOTABL)      ADDRESS OF LAST COMMAND\n         PCALL HELP\n         TITLE 'CLEAR TEST -- CLEAR ACTIVE IF FLAG ON'\n*  CLEAR ACTIVE FILE IF CPFCLEAR FLAG IS ON\n         SPACE\nCLRTST   XENTER 7,8,*              SAVE REGS\n         TM    CPLFLG2,CPFCLEAR    WAS CLEAR SPECIFIED\n         BZ    CLRTSTEX            NO, EXIT FROM ROUTINE\n         CLC   CPAGCT(2),=D'0'     IS THERE ANY ACTIVE FILE\n         BE    CLRTSTEX            NO, EXIT FROM ROUTINE\n         BAL   R14,DOCLEAR         GO CLEAR ACTIVE\nCLRTSTEX XEXIT 7,8                 RETURN\n         TITLE 'CLEAR ROUTINE'\nDOCLEAR  XENTER 2,8,*                   SAVE REGS\nCLRA     MVC   CPHIPS(6),=D'0'          ZERO CPHIPS & CPLNCT\n         LA    R5,CPDREC                FIRST DIRECTORY ENTRY\n         PFREE 9                        OUT WITH ANY PAGE IN R9\n         PFREE 11                       OUT WITH ANY PAGE IN R11\n         LH    R6,CPAGCT                NO. PAGES\n         LTR   R6,R6                    ANY?\n         BZ    FNBLAST                  NO JUNKING NECESSARY\n         OI    CPGFLG,CPFDIRCH         SET DIRECTORY CHANGED\nGOBLAST  LH    R0,4(R5)                 PAGE NO. INTO R0\n         PJUNK (0)                 FREE THIS PAGE\n         LA    R5,6(R5)                 POINT AT NEXT PAGE\n         BCT   R6,GOBLAST               JUNK NEXT PAGE (IF ANY)\nNORLSE   STH   R6,CPAGCT                ZERO PAGE COUNT\nFNBLAST  ST    R6,CPDREC                RESET FIRST DIRECTORY ENTRY\n         MVI   CPCURRL,X'F0'       SET CURRENT LINE INVALID\n         MVI   CPLSTCOL,FNEGBT          SET AS FIRST COLLECT\nCLR2     XEXIT R2,R8                    SCRAM\n         TITLE 'READ COMMAND'\n* READ, READ VALUE, AND READ STRING COMMAND\n* ALL OPTIONS ARE SCANNED FIRST, THEN THE INPUT LINE IS\n* OBTAINED FROM THE TYPEWRITER, ACTIVE FILE, OR EXEC FILE,\n* AND FINALLY THE VALUE, STRING, OR COMMAND IS PROCESSED.\n         SPACE\nGORDCMD  GENTER RDWASIZE           ESTABLISH AND WORK AREA\n         LR    R5,R8               POINT R5 TO WORK AREA\n         USING READWA,R5\n         XC    READWA(RDWASIZE),READWA CLEAR THE WORK AREA\n         MVC   RDWAPRMT(7),=C'ENTER? '   DEFAULT PROMPT\n         LA    R0,7                SET LENGTH\n         STH   R0,RDWAPRLN             FOR PROMPT\n         MVI   RDWACOL1,FNEGBT     SET NO COLUMNS GIVEN\n         CVCALL SCNEXFR            SCAN TO SEE IF READ FROM EXEC\nREADSCNL LA    R6,RDLNENO          SET R6 FOR LINE NUMBER RETURN\nREADSCN  SCAN  READPRT             SCAN READ OPERANDS\nREADSCND TM    RDWAFL,RDWAFLNO     WAS LINE NUMBER GIVEN\n         BO    READACT             BR YES\n         TM    RDWAFL,RDWAFDEL     WAS DELETE GIVEN WITH NO LINE\n         BO    READBAD1            BR YES TO ERROR\n         TM    RDWACOL1,FNEGBT     WERE COLS GIVEN WITH NO LINE\n         BNO   READBAD3            BR YES TO ERROR\n         LH    R0,RDWAPRLN         GET LENGTH FOR PROMPT\n         LA    R1,RDWAPRMT         POINT TO PROMPT\n         TREADR (1),(0),QM=NO      PROMPT USER FOR INPUT\n         BP    CVQTYPE             ABORT IF ATTENTION\n         MVI   CPCTSAV,FNEGBT      SET COMMAND LOGGED\n         B     READDO              NOW GO FINISH COMMAND\n         SPACE\nREADACT  LH    R0,CPAGCT           GET PAGE COUNT OF ACTIVE FILE\n         L     R14,CVLOCATE        POINT TO LOCATE FOR ACTIVE\n         TM    CPLFLG5,CPFSELOC    IS IT SELECT FROM ACTIVE\n         BZ    READNTST            YES, ASSUMPTION WAS CORRECT\n         LH    R0,CPEXCNT          GET EXEC FILE PAGE COUNT\n         L     R14,=A(LOCATEEX)    USE LOCATEEX FOR EXEC FILE\nREADNTST LTR   R0,R0               IS THE SELECTED FILE NULL\n         BNZ   READLOC             NO, GO DO LOCATE\n         CVCALL ITSNIL             REPORT NULL FILE\n         SPACE\nREADLOC  LA    R1,RDWALINO         POINT TO LINE TO LOCATE\n         BALR  R14,R14\n         TM    CPDRPT,CPFMTCH      DOES LINE EXIST\n         BNO   READBAD2            BRANCH TO ERROR IF NO\n         LR    R4,R15              SAVE PTR TO LINE FOR DELETE\n         LA    R1,CPCMSAV          POINT TO UNPRESS AREA\n         CVCALL UNPRESS            UNPRESS THE LINE\n         TM    RDWACOL1,FNEGBT     ANY COLUMN OPTIONS TO PROCESS\n         BO    READACT0            BR NO\n         AH    R1,RDWACOL1         POINT R1 TO NEW TEXT START\n         LH    R2,RDWACOL2         GET LENGTH FROM 2ND COL\n         LTR   R2,R2               WAS 2ND COL GIVEN\n         BZ    READACTA            BR NO TO COMPUTE NEW LENGTH\n         LR    R0,R2               SET LENGTH\n         B     READACT0            DONE WITH COLS, GO ON\n         SPACE\nREADACTA SH    R0,RDWACOL1         SET LENGTH TO REMAINING STRING\n         BNM   READACT0            OK IF NOT NEGATIVE\n         SR    R0,R0               MAKE LENGTH ZERO IF NEGATIVE\nREADACT0 ST    R0,CPCTSAV          SAVE COUNT FOR WRITECOM\n         LR    R2,R0               SAVE LINE COUNT\n         LR    R3,R1               SAVE LINE POINTER\n         PFLIP 9,11                SET PAGE INTO R9 (PROC TO R11)\n         TM    RDWAFL,RDWAFDEL     DELETE THE LINE\n         BE    READACT1            BRANCH NO\n         LR    R15,R4              POINT TO LINE TO DELETE\n         CVCALL  DODELE            GO DO DELETE\nREADACT1 PMOVE R9,R11    FREE R9 PAGE AND MOVE PROC PAGE TO R9\n         LR    R0,R2               RESET R0 COUNT\n         LR    R1,R3               RESET R1 POINTER\n* NOW DO STRING, VALUE, OR COMMAND\nREADDO   TM    RDWAFL,RDWAFPRO+RDWAFSTR   IS IT STRING OR VALUE\n         BZ    RDCMD               NO, GO DO COMMAND\n         BNO   RDVAL               BR IF READ VALUE\n         XCALL READSTR             GO DO READ STRING\n         SPACE\nRDVAL    XCALL READVAR             GO DO READ VALUE\n         SPACE\nRDCMD    XCALL EXLOOPCK            GO CHECK FOR LOOP IN EXEC\n         LR    R2,R0               GET COUNT FOR MVC (EXTRA OK)\n         EX    R2,READMVC          MOVE COMMAND TO CPCMSAV\n         LA    R1,CPCMSAV          POINT R1 TO CMOMMAND\n         MVC   CPLCNO,RDWALINO     SET LINE NUMBER FOR WRITECOM\n         TM    CPGFLG2,CPFNOLOG    EXEC NOLOG MODE\n         BO    RDCMD3              BRANCH YES\n         XCALL WRITECOM            GO WRITE OUT COMMAND\nRDCMD3   LR    R13,R8              RESET R13 FOR NEW COMMAND\n         XCALL EDTCOM              GO EXECUTE THIS COMMAND\n         SPACE\nREADMVC  MVC   CPCMSAV(0),0(R1)\n         SPACE\nNRDELETE NI    RDWAFL,255-RDWAFDEL RESET READ DELETE FLAG\n         BR    R14                 SCAN ON\n         SPACE\nRDELETE  OI    RDWAFL,RDWAFDEL     SET READ DELETE OPTION\n         TM    CPLFLG5,CPFSELOC    IS IT SELECT FROM EXEC\n         BNMR  R14                 NO,  DELETE IS OK\n         B     CVNVALID            YES, IT IS INVALID\n         SPACE\nRDLNENO  ST    R0,RDWALINO         SAVE READ LINE NUMBER\n         OI    RDWAFL,RDWAFLNO     SET LINE NUMBER OPTION FLAG\n         B     READSCNL            GO SCAN ON\n         SPACE\n* SCAN FOR READ STRING IS SAME AS VALUE FOR FIRST PART\nRDSCNSTR OI    RDWAFL,RDWAFSTR     SET STRING GIVEN AND ENTER VAL\n         SPACE\n* SCAN FOR READ VALUE AND REST OF READ STRING\nRDSCNVAL TM    RDWAFL,RDWAFPRO     IS THIS SECOND VALUE OR STRING\n         BO    CVNVALID            YES, IT IS INVALID\n         OI    RDWAFL,RDWAFPRO     SET VALUE OR STRING GIVEN\n         LA    R4,RDWAVAR          POINT TO VARIABLE SAVE AREA\n         LA    R3,1                SET COUNT TO 1\n         MVC   CPWK1(2),0(R1)      SAVE NAME IN CASE VARIABLE\n         L     R14,=A(LOOKUP)      CHECK THAT PRE-PROCESSOR\n         LTR   R14,R14                   IS INCLUDED\n         BZ    CVNVALID            BR NO TO ERROR\n         BALR  R14,R14             GO DO LOOKUP\n         BZ    CVNVALID            INVALID IF FIRST NOT A VAR\nRDSCNVL1 MVC   0(2,R4),CPWK1       PUT VARIABLE NAME IN LIST\n         STH   R3,RDWAVARN         SAVE VARIABLE COUNT\n         TM    RDWAFL,RDWAFSTR     IS IT STRING OPTION\n         BO    RDSCNST1            YES, GO FINISH UP STRING\n         SCANSAVE ,                SAVE SCAN PTRS FOR RESTORE\n         SCAN  ,                   GET NEXT TOKEN\n         SPACE\n         BNP   READSCND            END SCAN IF NO MORE\n         MVC   CPWK1(2),0(R1)      SAVE NAME IN CASE VARIABLE\n         XCALL LOOKUP              IS THIS A VARIABLE\n         BZ    RDSCNRES            NO, GO RESTORE SCAN\n         LA    R4,4(,R4)           STEP TO NEXT STORE AREA\n         LA    R3,1(,R3)           ADD 1 TO COUNT\n         CH    R3,=AL2(RDVARMAX)   IS THERE ROOM FOR THIS VAR\n         BNH   RDSCNVL1            YES, GO STORE AND LOOP\n         TSEG  'TOO MANY VARIABLES IN VALUE LIST'\n         B     CVQTYPE\n         SPACE\nRDSCNST1 ST    R1,0(,R4)           SAVE STRING VARIABLE ADDRESS\n         LTR   R15,R15             TYPE MUST BE ZERO FOR STRING\n         BZ    READSCN             YES, GO SCAN ON\n         TSEG  'READ STRING MUST HAVE STRING VARIABLE'\n         B     CVQTYPE\n         SPACE\nRDSCNRES SCANRSTR ,                RESTORE SCAN POINTERS\n         B     READSCN             CONTINUE SCANNING\n         SPACE\nRDSCNUSI SCAN  READPRT1            USING GIVEN -- GO GET LINENO\n         B     CVABSENT            NONE - REPORT MISSING\n         SPACE\nRDSCNCOL BCTR  R15,0               SET BETTER COLUMN NO.\n         STH   R15,RDWACOL1        SAVE COLUMN NO.\n         SCANSAVE ,                SAVE SCAN PTRS FOR RESTORE\n         SCAN  READPRT2            SCAN FOR 2ND COL NO.\n         B     READSCND            NONE, GO FINISH COMMAND\n         SPACE\nRDSCNCL2 SH    R15,RDWACOL1        GET LENGTH (COL2-(COL1+1))\n         BNP   CVNVALID            ERROR IF NOT POSITIVE\n         STH   R15,RDWACOL2        SAVE LENGTH\n         B     READSCN             CONTINUE SCANNING\n         SPACE\n* PROCESS PROMPT OPTION\nRDSCNPRM CLI   0(R1),C''''         IS PROMPT IN SINGLE QUOTES\n         BE    RDSCNPR1            BR YES\n         CLI   0(R1),C'\"'          IS PROMPT IN DOUBLE QUOTES\n         BNE   CVNVALID            NO, IT IS INVALID\nRDSCNPR1 CVCALL DQSCAN             STRIP QUOTES\n         CH    R0,=AL2(L'RDWAPRMT) IS PROMPT TOO LONG\n         BNH   *+8                 BR NO\n         LA    R0,L'RDWAPRMT       SET MAX LENGTH\n         STH   R0,RDWAPRLN         SAVE LENGTH OF PROMPT\n         LTR   R2,R0               PUT LENGTH IN R2 AND TEST\n         BZ    READSCN             NO MVC IF NULL\n         BCTR  R2,0                SET FOR EXECUTE\n         EX    R2,RDMVCPRM         MOVE PROMPT\n         B     READSCN             CONTINUE SCAN\n         SPACE\nRDMVCPRM MVC   RDWAPRMT(0),0(R1)   MVC FOR PROMPT MOVE\n         SPACE\nREADBAD1 SYSQS 1,0,'DELETE'        SET PART OF ERROR MESSAGE\n         B     READBAD4            GO PUT OUT MESSAGE\n         SPACE\nREADBAD2 L     R0,RDWALINO         GET LINE NUMBER\n         CVCALL CVEXNO             CONVERT TO EXTERNAL\n         TSEG  (1),(0),B           PUT OUT LINE NUMBER\n         TSEG  'NOT IN FILE'\n         B     CVQTYPE             GO ABORT\n         SPACE\nREADBAD3 SYSQS 1,0,'COLUMN'        SET PART OF ERROR MESSAGE\nREADBAD4 TSEG  (1),(0),B       PUT OUT FIRST PART OF MESSAGE\n         TSEG  'OPTION GIVEN WITHOUT A LINE NUMBER'\n         B     CVQTYPE\n         TITLE 'UTILITY ROUTINES'\n* ILLEGAL ITEM ROUTINE\n         SPACE\nUNLEGAL  GENTER ,                       ENTRY & BASE REG\n         TSEG  ' ILLEGAL'\n         B     QTYPED\n         SPACE 3\n* MISSING ITEM ROUTINES\n         SPACE\nABSCENT  GENTER ,                       ENTRY & BASE REG\n         TSEG  'OPERAND'\n         SPACE\nAMMISS   GENTER ,                       ENTRY & BASE REG\n         TSEG  ' MISSING'\n         SPACE\nQTYPED   GENTER ,\n         TM    CPGFLG,CPFRETRY         IS RETRY GOING ON?\n         BZ    QTYPED1                 NO\n         NI    CPGFLG,255-CPFRETRY\nQTYPED1  NI    JCBAFL,X'FF'-JCBAFIA     TURN ATTN FLAG OFF\n         TCLEARQ INPUT             FLUSH INPUT BUFFERS\n         NI    RTBMFL,X'FF'-RTBNOCR-RTBNOTR RESET NOCR, NOTR\n         TM    CPGFLG2,CPFEXEC         IS EXEC IN EFFECT\n         BE    CVGETCOM            NO, GET NEXT COMMAND\nQSYSRDY  CLC   RTBWC(2),=D'0'     ANYTHING TO WRITE?\n         BE    QSYSGO                  NO\n         TWRITE ,\n         SPACE\nQSYSGO   GENTER ,\n         TM    CPGFLG2,CPFEXEC         IS EXEC IN EFFECT\n         BZ    CVGETCOM            NO, GO GET NEXT CMD\n         XCALL EXECABRT                GO DO EXEC BREAK\n         EJECT\n*  FOR READ COMMAND\n         SPACE\nREADPRT  SCKW  NODELETE,NRDELETE,A\n         SCKW  DELETE,RDELETE,A\n         SCKW  STRING,RDSCNSTR,(A,P)\n         SCKW  PROMPT,RDSCNPRM,(A,P)\n         SCKW  USING,RDSCNUSI,A\n         SCKW  COLUMNS,RDSCNCOL,(A,P,PI),133\n         SCKW  COLS,RDSCNCOL,(P,PI),133\n         SCKW  VALUE,RDSCNVAL,(A,P)\nREADPRT1 SCKW  ,LNENOPRT,PUSH\n         SCKW  EXECUTE,,A\n         SCKW  ,INVALID\n         SPACE\nREADPRT2 SCKW  /,RDSCNCL2,(P,PI),133\n         SCKW  ,RDSCNRES\n         EJECT\nATTNRTN  DS    0H\n         USING ATTNRTN,R15\n         L     R1,8(,R1)\n         USING CPAREA,R1\n         DROP  R12\n         OI    JCBAFL,JCBAFIA      IDLE ATTN\n         LH    R2,JCBPAGES\n         LA    R2,1(,R2)\n         CH    R2,=H'10'\n         STH   R2,JCBPAGES\n         BNHR  R14\n         ABEND 100,DUMP\n         DROP  R1\n         USING CPAREA,R12\n         EJECT\n* SYNAD ROUTINE DOES ALMOST NOTHING\n         USING PFCB,R3\nPSYNAD   OI    JCBBFL,JCBBFPER     INDICATE PAGE ERROR\n         MVC   PFCBNP(4),PFCBCP    AND INDICATE END OF PAGES\n         BR    R14                 AND RETURN TO PGETS\n         DROP  R3\n         TITLE 'LITERALS'\n         LTORG\n         TITLE 'CONSTANTS, ETC.'\n         COPY  WYLCONST\nCHGFINCD EQU   32                       CHANGES FINISHED CODE\n         EJECT\n         COMMON\n         SPACE\n         EJECT\n         COPY  READWA\n         EJECT\nPFCB     DSECT\n         COPY   PFCBTSO\n         SPACE\n         IHASDWA ,                      FOR DIAG WORK AREA (ESTAE)\n         END\n./ ADD NAME=WTR      0100-80189-80189-0749-00789-00789-00000-$SYS13  00\n         COPY PMAC IS THIS CORRECT\nWTR      TITLE 'WYLTSO INTERFACE WITH TCAM'\n* PROPERTY OF C. U. C. C. A.\n         SPACE 3\n         GBLC  &USPS                                       USPS01\n&USPS    SETC  '1'                                         USPS01\n         TRACER OFF\nWTR      CSECT\n         WIDENT 001\n         SPACE\n         XTRNS ,\n         SPACE 3\n*  REGISTER USAGE\n         SPACE\nSR       EQU   2\nTR       EQU   3\nRR       EQU   4\nJCBR     EQU   5\n         SPACE 3\n         USING CPAREA,R12\n         EJECT\n         ENTRY TSEGXM,TSEGXW,TSEGXB,TSEGX\n         SPACE 3\n* ROUTINE TO DO TSEG AND TMARK\n         SPACE\nTSEGXM   ST    R14,0(13)\n         BALR  R14,0\n         USING *,R14\n         BAL   R14,TSEGCOM         GO DO TSEG\n         USING *,R14\n         B     TWRITEX2            GO DO TWRITE\n         SPACE 3\n* ROUTINE TO DO TSEG AND TWRITE\n         SPACE\nTSEGXW   ST    R14,0(13)\n         BALR  R14,0\n         USING *,R14\n         BAL   R14,TSEGCOM         GO DO TSEG\n         USING *,R14\n         B     TWRITEX2            GO DO TWRITE\n         SPACE 3\n* ROUTINE TO DO TSEG FOLLOWED BY A BLANK\n         SPACE\nTSEGXB   ST    R14,0(13)\n         BALR  R14,0\n         USING *,R14\n         BAL   R14,TSEGCOM         GO DO TSEG\n         USING *,R14\n         SYSQS 1,0,' '             SET UP FOR TSEG OF BLANK\n         BAL   R14,TSEGCOM2        GO DO TSEG OF BLANK\n         USING *,R14\n         B     TSEGEXIT\n         SPACE 3\n* ROUTINE TO DO NORMAL TSEG\n         SPACE\nTSEGX    ST    R14,0(13)\n         BALR  R14,0\n         USING *,R14\n         BAL   R14,TSEGCOM         GO DO TSEG\n         USING *,R14\nTSEGEXIT XEXIT 2,8\n         SPACE\n         DROP  R14\n         SPACE 3\n* TSEG - ADD SEGMENT TO BUFFER\n         SPACE\nTSEGCOM  DS    0H\n         XENTERI 2,8\nTSEGCOM2 DS    0H\n         XTRACE TSEG\n         LH    SR,RTBWC                PICK UP WRITE COUNT\n         LTR   TR,0                    DATA COUNT\n         BNPR  R14                     BR IF NULL SEG\n         AR    TR,SR                   COMPUTE NEW LENGTH\n         CH    TR,=Y(RTBNTEXT)                COMPARE WITH BUF SIZE\n         BNH   *+8\n         LH    TR,=Y(RTBNTEXT)                SET MAX SIZE\n         STH   TR,RTBWC                PLANT NEW WRITE COUNT\n         SR    TR,SR                   COMPUTE ACTUAL DATA COUNT\n         BNPR  R14                     BR IF NO DATA\n         BCTR  TR,0\n         LA    SR,RTBTEXT(SR)\n         EX    TR,MOVE                 MOVE THE DATA\n         BR    R14\n         EJECT\n* TWRITE OUTPUT A LINE\n         SPACE\nTMARKX   XENTER 2,8,*\n         LH     1,RTBWC\n         LTR    1,1\n         BP     DOWRITE\n         XEXIT  2,8\n         SPACE 3\nTWRITEX  XENTER 2,8,*\nDOWRITE  EQU   *-2               EQUATE TO BALR\nTWRITEX2 EQU   *-6               JUST BEFORE LA 13,...\n         XTRACE TWRITE\n         SR    R15,R15\n         L     R3,RTBWAPTR       RTB WORK AREA POINTER\n         LH    R2,RTBWC          WRITE COUNT\n         LTR   R2,R2             IS IT 0?\n         BZ    NOCHARS\n         LA    R1,RTBTEXT-1(R2)  POINT TO LAST CHAR\nBLNKLOOP CLI   0(R1),C' '\n         BNE   NOBLNKS           FOUND A NONBLANK\n         BCTR  R1,0              DECREMENT STRING POINTER\n         BCT   R2,BLNKLOOP       DECREMENT COUNT\nNOBLNKS  STH   R2,RTBWC          SAVE NEW COUNT\nNOCHARS  TM    RTBMFL,RTBNOCR    CHECK MODE FLAG FOR NOCR\n         BZ    NOTNOCR           NO ITS NOT NOCR\n         TM    RTBUFL,RTBUPAD    PAD WANTED?\n         BZ    NOPADS            NO SKIP PADDING\n         CH    R2,CPLNGTH        IS LINE >= 'LENGTH'\n         BNL   NOPADS            YES, SKIP PADDING\n         LH    R5,CPLNGTH\n         STH   R5,RTBWC          MAKE 'LENGTH' THE NEW SIZE\n         SR    R5,R2             NUMBER OF BLANKS TO MOVE\n         BCTR  R5,0\n         LA    R2,RTBTEXT(R2)    MOVE BLANKS TO HERE\n         LA    R1,BLANKS\n         EX    R5,MOVE           GO MOVE BLANKS\nNOPADS   SR    R0,R0             FOR DIVIDE INSTRUCTION\n         LH    R1,RTBCURS(,R3)   CURSOR POSITION\n         AH    R1,RTBWC          ADD NUMBER OF CHARS TO LIST\n         LH    R2,RTBLSZ(,R3)    LINE SIZE\n         DR    R0,R2             FIND REMAINDER\n         STH   R0,RTBCURS(,R3)   NEW CURSOR POSITION\n         LH    R0,RTBWC          LENGTH OF LINE TO PRINT\n         BAL   R6,WRITE          GO WRITE\n         SR    R0,R0\n         STH   R0,RTBLINE(,R3)   CLEAR LINE COUNT\n         B     TRX               AND RETURN\n         SPACE 3\nWRITE    LTR   R0,R0             ANYTHING TO PRINT?\n         BZR   R6                IF NOT RETURN\n         XC    CPEXCMCT,CPEXCMCT CLEAR EXEC COMMAND COUNT\n         LA    R1,RTBTEXT        POINT TO TEXT TO PRINT\n         AIF   ('&USPS' NE '1').LBL01                      USPS01\n         BCTR  R0,0                                        USPS01\n         CH    R0,=H'1'                                    ITEL\n         BNE   WRTPUT0                                     ITEL\n         MVI   0(R1),C' '                                  ITEL\n         B     WRTPUT1                                     ITEL\nWRTPUT0  EQU   *                                           ITEL\n         BCTR  R0,0                                        USPS01\nWRTPUT1  EQU   *                                           ITEL\n         TPUT  (1),(0),EDIT,WAIT                           USPS01\n         B     WRLTR                                       USPS01\nWRTPUT   O     R1,=XL4'02000000'                           USPS01\n         TPUT  (1),(0),R                                   USPS01\nWRLTR    LTR   R15,R15                                     USPS01\n         AGO   .LBL02                                      USPS01\n.LBL01   DS    0H                                          USPS01\n         O     R1,=XL4'02000000' TPUT OPTIONS\n         TPUT  (1),(0),R\n         LTR   R15,R15\n.LBL02   DS    0H                                          USPS01\n         BZR   R6                NORMAL RETURN\nWRATTN   OI    JCBAFL,JCBAFIA    IDLE ATTN ON WRITE\n         SR    R0,R0\n         STH   R0,RTBCURS(,R3)   CLEAR BALL POSITION\n         STH   R0,RTBLINE(,R3)   CLEAR LINE COUNT\n         B     TRX\n         SPACE 3\nPAUSE    LA    R1,=C'.'          PRINT A DOT\n         LA    R0,1              LENGTH OF A DOT\n         O     R1,=XL4'02000000' TPUT OPTIONS\n         TPUT  (1),(0),R         GO DO IT\n         LTR   R15,R15\n         BNZ   WRATTN\nPAUSERD  LA    R1,RTBPAUS(,R3)   POINT TO A WORK AREA\n         LA    R0,8              EIGHT IS ENUF\n         O     R1,=XL4'80000000' TGET OPTIONS\n         TGET  (1),(0),R         WAIT\n         B     *+4(R15)          AND RETURN APPROPRIATELY\n         BR    R6                GOOD RETURN\n         DC    3H'0'\n         B     WRATTN            ATTN HIT\n         B     PAUSERD           GO REREAD TO FLUSH\n         DC    2H'0'\n         SVC   3\n         SPACE 3\nNOTNOCR  TM    RTBMFL,RTBWRAP    IS CR/LF TO BE INSERTED?\n         BO    WRAP              YES GO DO IT...\nCHKCRT   TM    RTBMFL,RTBCRT     IS PAGING IN EFFECT?\n         BO    NWRAPCRT          YES GO TEST PAGING\nPUTCR    LH    R2,RTBWC          SIZE OF LINE TO PRINT\n         LA    R2,2(,R2)         2 MORE CHARS FOR CR/LF\n         CH    R2,=Y(RTBNTEXT)   MORE THAN BUFFER SIZE?\n         BNH   *+8               NO IT'S OK\n         LH    R2,=Y(RTBNTEXT)   DEFAULT TO MAXIMUM\n         LR    R0,R2             LENGTH OF TOTAL LINE\n         LA    R2,RTBTEXT-2(R2)  POINT TO PLANT CR/LF\n         MVC   0(2,R2),=X'0D25'  PUT IT IN\n         BAL   R6,WRITE          GO WRITE LINE\n         SR    R0,R0\n         STH   R0,RTBCURS(,R3)   ZERO CURSOR POSITION\n         B     TRX\n         SPACE 3\nNWRAPCRT LH    R1,RTBCURS(,R3)   GET CURSOR POSITION\n         AH    R1,RTBWC          ADD SIZE OF LINE\n         SR    R0,R0\n         LH    R2,RTBLSZ(,R3)    LINE SIZE\n         LTR   R1,R1\n         BZ    *+8               SKIP NEXT TWO INSTR\n         BCTR  R1,0\n         DR    R0,R2             FIND NEW LINE POSITION\n         LA    R1,1(,R1)         ADD ONE\n         AH    R1,RTBLINE(,R3)   ADD ALREADY PRINTED COUNT\n         STH   R1,RTBLINE(,R3)   SAVE IT\n         CH    R1,RTBPSZ(,R3)    NEED PAGING?\n         BNH   PUTCR             NO GO PRINT IT NORMALLY\n         BAL   R6,PAUSE          GO PAUSE\n         LH    R1,RTBWC          SIZE OF LINE\n         SR    R0,R0\n         LH    R2,RTBLSZ(,R3)    MAX LINE SIZE\n         BCTR  R1,0\n         DR    R0,R2             FIND NES LINE POSITION\n         LA    R1,1(,R1)\n         STH   R1,RTBLINE(,R3)   SAVE NEW LINE COUNT\n         B     PUTCR             AND GO LIST NORMALLY\n         SPACE 3\nWRAP     LH    R1,RTBCURS(,R3)   GET CURSOR POSITION\n         AH    R1,RTBWC          ADD SIZE OF LINE TO PRINT\n         CH    R1,RTBLSZ(,R3)    MORE THAN LINE SIZE?\n         BNH   CHKCRT            GO WRITE IGNORING WRAP\n         LH    R2,RTBCURS(,R3)   GET CURSOR POSITION\n         LTR   R2,R2             WHERE?\n         BZ    ZCURS             NO SPECIAL CASE NEEDED\n         SR    R0,R0\n         STH   R0,RTBCURS(,R3)   ZERO OUT CURSOR POSITION\n         LH    R0,RTBLSZ(,R3)    GET LINE SIZE\n         SR    R0,R2             NUMBER OF CHARS TO PRINT NOW\nADDCR    LR    R4,R0\n         LA    R4,RTBTEXT(R4)    POINT TO PLANT CR/LF\n         MVC   RTBSAVE(2,R3),0(R4) SAVE THE TWO CHARS IN TEXT\n         MVC   0(2,R4),=X'0D25'  PLANT THE CR/LF\n         LH    R1,RTBWC          GET LINE SIZE\n         SR    R1,R0             GET REMAINING LENGTH\n         STH   R1,RTBWC\n         AH    R0,=H'2'          ADD 2 FOR CR/LF\n         BAL   R6,WRITE\n         MVC   RTBTEXT(2),RTBSAVE(R3) MOVE BACK THE TEXT SAVED\n         MVC   RTBTEXT+2(RTBNTEXT-2),2(R4) AND THE REMAINING\nZCURS    LH    R1,RTBWC\n         LTR   R1,R1             ANY MORE LEFT?\n         BZ    TRX\n         CH    R1,RTBLSZ(,R3)    MORE THAN LINESIZE?\n         BNH   CHKCRT            GO PRINT REST AS IF NOWRAP\n         TM    RTBMFL,RTBCRT     PAGING IN EFFECT?\n         BZ    NOCR              NO IGNORE PAGING\n         LH    R4,RTBLINE(,R3)   GET LINE COUNT\n         LA    R4,1(,R4)         ADD ONE MORE LINE\n         STH   R4,RTBLINE(,R3)\n         CH    R4,RTBPSZ(,R3)    MORE THAN PAGESIZE?\n         BNH   NOCR\n         BAL   R6,PAUSE\n         SR    R0,R0\n         STH   R0,RTBLINE(,R3)   ZERO OUT LINE COUNT\nNOCR     LH    R0,RTBLSZ(,R3)    MAXIMUM TO PRINT\n         B     ADDCR\n         EJECT\n* OPWRITE - SEND MESSAGE TO OPERATOR\n         SPACE\nOPWRITE  XENTER 2,8,*\n         XTRACE OPWRITE\n         SR    SR,SR\n         STH   SR,RTBPC\n         STH   SR,RTBRC\n         BAL   R14,TREADX\n         XEXIT 2,8\n         EJECT\n* TREAD - PROMPT AND READ A LINE\n         SPACE\nTREADX   XENTER 2,8,*\n         SR    R3,R3               FLAG REGISTER\n         CH    R3,CVPRMLIM         RECOVERY WANTED?\n         BE    NORECVRY            IF 0 NO RECOVERY NEEDED\n         LA    R4,1                TO BE USED AS A FLAG\n         TM    CPGFLG,CPFDIRCH     IS DIRCTORY CHANGED?\n         BO    RECOVERY            IF SO FORCE RECOVERY\n         LH    R4,CVPROMPT         HOW MANY PROMPTS HAVE GONE BY?\n         CH    R4,CVPRMLIM         MORE THAN UPDATE LIMIT?\n         BL    NORECVRY            IF LESS, NO RECOVERY\n         SR    R4,R4               TO BE USED AS A FLAG\nRECOVERY L     R3,CVFPFCB          OUR PFCB ADDRESS\n         L     R2,CVFPAGE          FIRST PCB ADDRESS\n         USING PFCB,R3\n         USING PCB,R2\nPCBLOOP  TM    PCBFL,PCBFMARK      WAS PAGE MARKED?\n         BZ    NEXTPCB             IF NOT SKIP IT\n         LH    R1,PCBPN            GET PAGE NUMBER\n         LA    R4,1(,R4)           SAY A PAGE WAS WRITTEN\n         MVI   PCBRWCCW,PIOWRITE   INDICATE WE WILL WRITE\n         CVCALL PIO                GO DO I/O\n         NI    PCBFL,255-PCBFMARK  TURN OFF DIRTY MARK\nNEXTPCB  LA    R2,PCBSIZE(,R2)     POINT TO NEXT PCB\n         C     R2,CVLPAGE          PAST THE LAST ONE?\n         BL    PCBLOOP             IF NOT KEEP LOOPING\n         LTR   R4,R4               ANYTHING MORE TO BE DONE?\n         BZ    NORECVRX            NO, GET OUT\n         OI    JCBBFL,JCBPIOW      INDICATE EXCP WILL COME\n         LR    R5,R15\n         L     R4,JCBWAPTR\n         MVC   0(8,R4),=CL8'RECOVER'\n         MVC   8(4,R4),PFCBCP      CURRENT PAGES USED\n         MVC   12(4,R4),CPRSCNVL   RESCAN ESC SKIP CHARS\n         MVC   16(4,R4),CPEXLNET   SAVE EXEC LINE POINTER\n         MVC   20(12,R4),CVEXTRAP  EXEC TRAP AND UPDATE CNT\n         LA    R4,32(,R4)          MORE TO WRITE\n         MVC   0(RTBSIZE-RTBNTEXT,R4),RTBSTART RTB INFO\n         LA    R4,RTBSIZE-RTBNTEXT(,R4)\n         MVC   0(CPRCVSZ1,R4),CPGLDL           CP INFO\n         LA    R4,CPRCVSZ1(,R4)\n         MVC   0(CPRCVSZ2,R4),CPDRPT           MORE CP INFO\n         LA    R4,CPRCVSZ2(,R4)\n         LR    R2,R4                           FOR MVCL\n         LA    R3,CPRCVSZ3                     LENGTH\n         LA    R14,CPDREC                      FROM\n         LR    R15,R3                          SAME LENGTH\n         MVCL  R2,R14                          MOVE IT\n         LA    R4,CPRCVSZ3(,R4)\n         LR    R2,R4                           FOR MVCL\n         LA    R3,ROUTBLEN                     LENGTH\n         LA    R14,ROUTBLE                     FROM\n         LR    R15,R3                          SAME LENGTH\n         MVCL  R2,R14                          MOVE IT\n         LA    R4,ROUTBLEN(,R4)\n         L     R15,RTBWAPTR\n         MVC   0(256,R4),0(R15)                 TERMINAL INFO\n*        DO EXCP\n         L     R3,CVPIOB\n         USING PIOB,R3\n         L     R4,JCBWAPTR\n         STCM  R4,7,PCCWWRT1+1          SAVE IT\n         MVI   PSEEKREC,1        SET RECORD 1\n         MVI   PCCWWRT1+4,X'00'  UNCHAIN\n         XC    PECB,PECB\n         EXCP  PIOBSTRT\n        LA    R14,PECB\n        WAIT  ECB=(R14)           WAIT FOR I/O TO COMPLETE\n         L     R3,CVFPFCB          OUR PFCB ADDRESS\n         USING PFCB,R3\n         L     R14,JCBWAPTR           GET BUFFER\n         L     R2,PFCBPTST            BEGINNING OF PAGE TABLE\n         LA    R3,&PAGE0              MAX NUMBER OF PAGES\n         LR    R15,R3                 SAME LENGTH\n         MVCL  R14,R2                 MOVE IT\n*        DO EXCP\n         L     R3,CVPIOB\n         USING PIOB,R3\n         L     R4,JCBWAPTR\n         STCM  R4,7,PCCWWRT1+1          SAVE IT\n         MVI   PSEEKREC,2        SET RECORD 2\n         XC    PECB,PECB\n         EXCP  PIOBSTRT\n        LA    R14,PECB\n        WAIT  ECB=(R14)           WAIT FOR I/O TO COMPLETE\n         LA    R2,CPAREA+CPSIZE     2ND CP PAGE\n         STCM  R2,7,PCCWWRT1+1          SAVE IT\n         L     R3,CVPIOB\n         USING PIOB,R3\n         MVI   PSEEKREC,3        SET RECORD 3\n         XC    PECB,PECB\n         EXCP  PIOBSTRT\n        LA    R14,PECB\n        WAIT  ECB=(R14)           WAIT FOR I/O TO COMPLETE\n         L     R2,CVCPADDR          ADDR OF VCP\n         STCM  R2,7,PCCWWRT1+1          SAVE IT\n         L     R3,CVPIOB\n         USING PIOB,R3\n         MVI   PSEEKREC,4        SET RECORD 4\n         XC    PECB,PECB\n         EXCP  PIOBSTRT\n         LA    R14,PECB\n         WAIT  ECB=(R14)           WAIT FOR I/O TO COMPLETE\n         MVI   PSEEKREC,1        SET RECORD 1\n         MVI   PCCWWRT1+4,X'40'  SET CHAINED\n         XC    PCCWWRT1+1(3),PCCWWRT1+1\n         DROP  R3\n         DROP  R2\n         LR    R15,R5          RESTORE R15\nNORECVRX LM    R2,R6,4(R8)          RESTORE INPUT REGISTERSDEL\nNORECVRY SR    R3,R3\n         STH   R3,CPEXCMCT         ZERO EXEC COUNT\n         L     R4,RTBWAPTR         GET RTB WORK AREA POINTER\n         STH   R3,RTBLINE(,R4)     CLEAR LINES PRINTED\n         LTR   RR,15               TEST '? ' INSERT\n         BP    DNTADIT             NO '? '\n         LPR   R4,R15              SET IT TO POSITIVE\n         C     R4,=X'005A5B7C'     IS IT MOD OR EDIT?\n         BNE   *+6\n         LR    R3,R4               FLAG NO REPROMPT\n         TSEG  '? '                COMPLETE PROMPT\nDNTADIT  LH    R0,RTBWC            COMPUTE PROMPT SIZE\n         LTR   R0,R0               ANY PROMPT INVOLVED?\n         BZ    RD                  NO .. GO TO RD\n         L     R4,RTBWAPTR\n         LA    R1,RTBTEXT\n         CH    R0,=Y(RTBPMAX)    MORE THAN THAT?\n         BNH   *+10\n         SH    R0,=Y(RTBPMAX)\n         AR    R1,R0               POINT TO LAST RTBPMAX CHARS\n         MVC   RTBPRMPT(RTBPMAX,R4),0(R1) MOVE THE PROMPT\nTPUTIT   LH    R5,RTBWC            GET WRITE COUNT\n         TM    RTBMFL,RTBWRAP      WRAP FORCE WANTED?\n         BZ    RNOWRAP             NO, REGULAR\n         LH    R1,RTBCURS(,R4)     GET BALL POSITION\n         AR    R1,R5               ADD LENGTH TO BE WRITTEN\n         CH    R1,RTBLSZ(,R4)      MORE THAN LS?\n         BL    RNOWRAP             NO GO DO WITHOUT WRAP\n         LH    R2,RTBCURS(,R4)     GET BALL POSITION\n         LTR   R2,R2               WAS BALL MOVED?\n         BZ    RZCURS              NO, NO SPECIAL CASE THEN\n         SR    R0,R0\n         STH   R0,RTBCURS(,R4)     CLEAR BALL POSITION\n         LH    R0,RTBLSZ(,R4)      GET LS\n         SR    R0,R2               GET SPECIAL CASE LENGTH\nRADDCR   LR    R3,R0               LENGTH TO PRINT THIS TIME\n         LA    R3,RTBTEXT(R3)      POINT TO END OF IT\n         MVC   RTBSAVE(2,R4),0(R3) SAVE 2 CHARS\n         MVC   0(2,R3),=X'0D25'    PUT CR/LF\n         SR    R5,R0               GET REMAINING COUNT\n         AH    R0,=H'2'            ADD 2 MORE FOR CR/LF\n         BAL   R6,RWRITE           GO WRITE PORTION\n         MVC   RTBTEXT(2),RTBSAVE(R4) MOVE BACK THE 2 CHARS\n         MVC   RTBTEXT+2(RTBNTEXT-2),2(R3) AND SHIFT OTHERS\nRZCURS   LTR   R1,R5               ANYTHING MORE TO WRITE?\n         BZ    RD                  NO, GET OUT\n         CH    R1,RTBLSZ(,R4)      MORE THAN LS?\n         BL    RNOWRAP             NO, ACT JUST LIKE NOWRAP\n         LH    R0,RTBLSZ(,R4)      PROMPT SOME MORE\n         B     RADDCR\n         SPACE\nRNOWRAP  LH    R1,RTBCURS(,R4)     GET CURSOR POSITION\n         AR    R1,R5               ADD WRITE COUNT\n         SR    R0,R0\n         LH    R2,RTBLSZ(,R4)\n         DR    R0,R2               FIND NEW BALL POSIT = REM.\n         STH   R0,RTBCURS(,R4)\n         LR    R0,R5\n         BAL   R6,RWRITE\nRD       LA    R0,SZR              MAX LINE SIZE\n         LA    R1,RTBTEXT\n         CLI   LFLG1,CPF3277 IS THIS A 3277?                  ITEL\n         BE    RD1           YES                              ITEL\n         O     R1,=XL4'80000000'    JUST TGET FOR NON 3277    ITEL\n         TGET  (1),(0),R                                      ITEL\n         B     *+4(R15)                                       ITEL\n         B     SETREGS       TGET SUCCESSFUL                  ITEL\n         DC    2H'0'         CANNOT HAVE NOWAIT               ITEL\n         B     RDATTN        ATTN ON READ                     ITEL\n         B     FLUSH         TOO MANY CHARACTERS              ITEL\n         DC    2H'0'         CANNOT HAVE INVALID PARMS        ITEL\n         SVC   3             USER HANGED UP DE FONE           ITEL\n         SPACE                                                ITEL\nRD1      O     R1,=XL4'81000000'    TGET ASIS\n         TGET  (1),(0),R\n         B     *+4(R15)\n         B     TESTKEY       TGET SUCCESSFUL\n         DC    2H'0'         CANNOT HAVE NOWAIT\n         B     RDATTN        ATTN ON READ\n         B     FLUSH         TOO MANY CHARACTERS\n         DC    2H'0'         CANNOT HAVE INVALID PARMS\n         SVC   3             USER HANGED UP DE FONE\n         SPACE\nTESTKEY  DS    0H\n         LTR   R1,R1              ANYTHING RETURNED\n         BZ    REPROMP            NO TGET AGAIN\n         LR    R0,R1              SAVE ACROSS TRT\n         EX    R1,TRANTEST        TRT\n         BNZ   DELCUR             DELETE CURSOR CHAR\nTESTENT  LR    R1,R0              RESTORE COUNT\n         CLI   RTBTEXT,X'7D'      ENTER HIT\n         BNE   TESTPFK            NO TEST PFK\nSETENT   SH    R1,=H'6'           FOR ASIS INFO\n         LTR   R1,R1              SEE IF NEG\n         BNM   *+8\n         LA    R1,0               SET ZERO IF MINUS\n         EX    R1,MOVTEXT         MOV THE TEXT OVER\n         LA    R2,RTBTEXT+1(R1)  MOVE BLANKS\n         MVC   0(6,R2),BLANKS    FILL LINE WITH BLANKS\n         B     SETREGS            CONTINUE\n         SPACE\nDELCUR   DS    0H\n         LR    R3,R1           SET CUR POS\n         LA    R14,RTBTEXT     POINT TO BEGININNG\n         SR    R3,R14          DISPL INTO RTBTEXT\n         LR    R4,R0           TEMP REST\n         SR    R4,R3           DECR FOR MOVE\n         SH    R4,=H'4'        FOR EXEC\n         EX    R4,MOVTEXT2     MOV IT\n         SH    R0,=H'3'\n         B     TESTENT         CONTINUE\nMOVTEXT  MVC   RTBTEXT(0),RTBTEXT+6         MOVE OVER ASIS INFO\nMOVTEXT2 MVC   0(0,R1),3(R1)                MOVE OVER ASIS INFO\nTRANTEST TRT   RTBTEXT+6(0),CURTAB           DELETE CURSOR CHARS\n         SPACE\nTESTPFK  DS    0H\n         L     VCPR,CVCPADDR      POINT TO VCP PAGE\n         USING DVCP,VCPR\n         LA    R2,VCPPVAR         POINT TO PFK KEYS\n         DROP  VCPR\n         LA    R3,24              NUMBER OF PFK'S\n         SLR   R4,R4              USED FOR IC\nFINDPFK  CLC   RTBTEXT(1),0(R2)         MATCH\n         BE    SEEPFK             YES SEE IF SET\n         LA    R2,25(R2)          NEXT ENTRY\n         BCT   R3,FINDPFK         CHECK NEXT\n         B     SETENT                   UNKNOW SET AS ENTER\n         SPACE\nSEEPFK   CH    R1,=AL2(6)         ANY THING ELSE\n         BH    SETPFK             OVER 6 MEANS SET PFK\nSEEPFK2  SLR   R4,R4              FOR INSERT\n         ICM   R4,1,1(R2)         GET LENGTH\n         BZ    SETENT             ZERO LENGTH \u00a26 SET AS ENTER\n         LR    R1,R4              FOR LATER\n         BCTR  R4,R0              FOR MOVE\n         EX    R4,PFKMOVE         MOV TO RTBTEXT\n         B     SETREGS            CONTINUE PROCESSING\n         SPACE\nREPROMP  DS    0H\n         SLR   R0,R0              CLEAR REGISTER FOR ICM\n         ICM   R0,3,RTBPC         AND PROMPT COUNT\n         BZ    RD                 NO JUST READ\n         BAL   R6,RWRITE          REWRITE\n         B     RD                 GO RE-READ\n         SPACE\nSETPFK   DS   0H\n         L     VCPR,CVCPADDR      POINT TO VCP PAGE\n         USING DVCP,VCPR\n         LA    R2,VCPPVAR         POINT TO PFK KEYS\n         DROP  VCPR\n         SH    R1,=AL2(6)    SUBTRACT GARBAGE\n         CH    R1,=AL2(23)   MAX FOR ANY PFK\n         BH    PFKMAX        HIGH IGNORE\nPFKSLOOP CLC   RTBTEXT(1),0(R2)\n         BE    MOVPFK        YES\n         LA    R2,25(R2)     NEXT PFK\n         B     PFKSLOOP      LOOP\nMOVPFK   STC   R1,1(R2)        SAVE LENGTH\n         BCTR  R1,R0         DECR FOR EXECUTE\n         MVI   2(R2),C' '     CLEAR LAST ENTRY\n         MVC   3(22,R2),2(R2)       ENTIRELY\n         EX    R1,MOVEIT     MOVE IT\n         B     SEEPFK2          EXECUTE COMMAND\nMOVEIT   MVC   2(0,R2),RTBTEXT+6  CURRENT KEY\n         SPACE\n*\nPFKMAX   TSEG 'PFK ENTRY TOO LONG'\n         B    CVGETCOM\nPFKMOVE  MVC   RTBTEXT(0),2(R2)        COMMAND\n         SPACE\nRWRITE   LA    R1,RTBTEXT\n         AIF   ('&USPS' NE '1').LBL03                      USPS01\n         TPUT  (1),(0),ASIS,WAIT                           USPS01\n         B     RWLTR                                       USPS01\nRWTPUT   O     R1,=XL4'02000000'                           USPS01\n         TPUT  (1),(0),R                                   USPS01\nRWLTR    LTR   R15,R15                                     USPS01\n         AGO   .LBL04                                      USPS01\n.LBL03   DS    0H                                          USPS01\n         O     R1,=XL4'02000000'\n         TPUT  (1),(0),R\n         LTR   R15,R15\n.LBL04   DS    0H                                          USPS01\n         BZR   R6            SUCCESSFUL TPUT\nRDATTN   SR    R1,R1         ATTN INNTERRUPT\n         SR    R0,R0\n         B     TRXT\n         SPACE\nFLUSH    LA    R0,SZR\n         LA    R1,RTBTEXT\n         O     R1,=XL4'80000000'\n         TGET  (1),(0),R\n         B     *+4(R15)\n         B     SETREGM       FIRST NOTIFY TRUNCATION\n         DC    2H'0'         CANNOT BE NOWAIT\n         B     RDATTN        ATTN ON READ???\n         B     FLUSH         KEEP ON FLUSHING ZE INPUT\n         DC    2H'0'         ILLEGAL PARMS???\n         SVC   3             USER HUNG UP\n         SPACE 3\nSETREGM  LA    R1,LONGMSG\n         LA    R0,L'LONGMSG\nREPROMPT TPUT  (1),(0),R\nSETREGM2 LH    R0,RTBWC      GET PROMPT COUNT\n         L     R1,RTBWAPTR\n         XC    RTBCURS(2,R1),RTBCURS(R1) CLEAR BALL POSITION\n         LTR   R0,R0         IS THERE ANY?\n         BZ    RD            GO READ AGAIN\n         LR    R4,R1         POINT TO WA\n         MVC   RTBTEXT(RTBPMAX),RTBPRMPT(R1) MOVE PROMPT BACK\n         CH    R0,=Y(RTBPMAX) IS IT TOO LONG?\n         BNH   TPUTIT\n         LA    R0,RTBPMAX    MAX PROMPT SIZE\n         STH   R0,RTBWC      SAVE NEW WRITE COUNT\n         B     TPUTIT        GO PROMPT AGAIN\n         SPACE\nSETREGS  LR    R0,R1           LENGTH OF INPUT\n         LA    R1,RTBTEXT      ADDRESS OF INPUT\n         TM    RTBUFL,RTBUATTN IS ATTN SEQ ALLOWED\n         BZ    READTEST        IF NOT SKIP THE CHECK\n         L     SR,RTBWAPTR\n         LH    R5,RTBATNSZ(,SR) LENGTH OF ATTN SEQ\n         CR    R5,R0           CAN THERE BE AN ATTN SEQ?\n         BH    READTEST        IF NOT SKIP THE CHECK\n         LR    R6,R1           POINT TO INPUT\n         AR    R6,R0           POINT TO END OF INPUT\n         SR    R6,R5           POINT TO POSSIBLE ATTN SEQ\n         BCTR  R5,R0           GUESS WHY\n         EX    R5,CLCATTN      IS IT AN ATTN?\n         BNE   READTEST        IF NOT RETURN\n         LA    R5,1(,R5)       BACK TO CORRECT LENGTH\n         CR    R5,R0           WAS IT ONLY THE ATTN SEQ?\n         BE    TRXX            IF SO RETURN REAL ATTN\n         C     R3,=X'005A5B7C' IS IT EDIT OR MODIFY?\n         BNE   SETREGM2        IF NOT REPROMPT\n         BCTR  R6,R0           POINT TO CHAR BEFORE ATTN\n         CLI   0(R6),C'$'      IS IT A DOLLAR?\n         BE    TRXX\n         CLI   0(R6),C'!'      IS IT AN EXCLAMATION?\n         BE    TRXX\n         CLI   0(R6),C'@'      IS IT AN AT SIGN\n         BNE   SETREGM2        IF NON OF THE ABOVE, REPROMPT\nTRXX     SR    R0,R5           GET RID OF ATTN SEQ\n         LA    R15,4           RETURN NONZERO CC\nREADTEST LTR   SR,R0           UPLOW OR TABS POSSIBLE?\n         BZ    TRXT\n         BCTR  SR,0\n         TM    CPGFLG,CPFUPLW  UPLOW ALLOWED?\n         BO    NOEXTR          YES, SKIP TRANSLATE\n         EX    SR,TRUPLOW\n         AIF   ('&USPS' NE '1').LBL05                      USPS01\nNOEXTR   DS    0H                                          USPS01\n         AGO   .LBL06                                      USPS01\n.LBL05   DS    0H                                          USPS01\nNOEXTR   L     R3,RTBWAPTR\n         XC    RTBBSCNT(2,R3),RTBBSCNT(R3) CLEAR BS COUNT\n         LA    R3,RTBTRBUF(,R3) R3: @ BUFFER FOR COPY OF INPUT\n         LR    R4,SR           R4: REMAINING LENGTH - 1\n         LA    R5,RTBTEXT      R5: @ RESULT OF INPUT\n         SR    R0,R0           R0: PROCESSED LENGTH\n         SR    R2,R2\n         EX    R4,MVC2         GET A COPY OF INPUT\nTABBSLP  EX    R4,TABBS        FIND A TAB OR BS\n         BZ    ENDTABS         NONE, END UP\n         SR    R1,R3           R1: LENGTH OF STRING W/OUT TAB\n         BZ    NOMVC           IF NONE SKIP THE NEXT FEW\n         BCTR  R1,0            LESS 1 FOR EX\n         EX    R1,MVC1         MOVE THE STUFF OVER FROM COPY\n         LA    R1,1(,R1)       ADD 1 TO GET REAL LENGTH\n         AR    R5,R1           UPDATE REAL INPUT POINTER\n         AR    R3,R1           UPDATE COPY POINTER\n         AR    R0,R1           UPDATE PROCESSED LENGTH\n         SR    R4,R1           UPDATE REMAINING LENGTH\nNOMVC    LA    R3,1(,R3)       ADD 1 MORE FOR BS OR TAB CHR\n         B     *(R2)           R2 WAS SET FROM THE TRT\n         B     TAB             R2=4 MEANS A TAB, 8 MEANS A BS\n         SPACE\n         TM    RTBUFL,RTBUBACK BACK SET ?\n         BO    ADDBS           IF SO TREAT BS AS A CHARCTER\n         LTR   R0,R0           WAS THERE ANYTHING IN BUFFER?\n         BZ    TESTREM         NO, DON'T DECREMENT\n         BCTR  R0,0            REDUCE PROCESSED LENGTH\n         BCTR  R5,0            REDUCE BUFFER POINTER\nTESTREM  LTR   R4,R4           ANYTHING LEFT?\n         BZ    TRXXT           NO, EXIT\n         BCTR  R4,0            REDUCE 1 MORE FOR TAB OR BS\n         B     TABBSLP         GO FIND MORE\n         SPACE\nADDBS    MVI   0(R5),X'16'     MOVE IN A BS\n         LA    R5,1(,R5)       ADD 1 TO BUFFER POINTER\n         AH    R0,=H'1'        ADD 1 TO PROCESSED LENGTH\n         L     R14,RTBWAPTR\n         LH    R1,RTBBSCNT(,R14) GET BS COUNT\n         LA    R1,1(,R1)       ADD 1\n         STH   R1,RTBBSCNT(,R14) SAVE BS COUNT\n         B     TABBSLP\n         SPACE\nTAB      LR    R6,R0           GET PROCESSED COUNT\n         L     R14,RTBWAPTR\n         SH    R6,RTBBSCNT(,R14) REDUCE IT BY # BS'S\n         XC    RTBBSCNT(2,R14),RTBBSCNT(R14) CLEAR BS COUNT\n         TM    RTBUFL,RTBURELT ARE TABS RELATIVE?\n         BO    CURSET          IF SO SKIP THE NEXT 2\n         AH    R6,RTBCURS(,R14) ADD CURSOR POSITON\nCURSET   LA    R14,RTBTABS      POINT TO TABS\n         LA    R1,8             AT MOST EIGHT TABS\nTBLP     IC    R2,0(,R14)       GET A TAB\n         LTR   R2,R2            IS THERE ONE?\n         BZ    BADTABS          TOO BAD...\n         BCTR  R2,0             LESS 1\n         CR    R2,R6            DOES THIS ONE FIT?\n         BH    FNDTAB           OK IT DOES.\n         LA    R14,1(,R14)      POINT TO NEXT TAB\n         BCT   R1,TBLP          AND CHECK MORE\nBADTABS  LA    R1,TABMSG        UNSET TABS\n         LA    R0,L'TABMSG\n         B     REPROMPT\n         SPACE\nFNDTAB   LR    R1,R2            TAB POSITION\n         SR    R1,R6            TAB TO THIS MANY POSITIONS\n         AR    R0,R1            NEW PROCESSED COUNT\n         BCTR  R1,0\n         EX    R1,MVCB          MOVE SOME BLANKS OVER\n         LA    R5,1(R1,R5)      UPDATE BUFFER POINTER\n         B     TESTREM          AND GO FIND MORE\n         SPACE\nENDTABS  AR    R0,R4            TOTAL LENGTH OF INPUT\n         AH    R0,=H'1'         PLUS 1\n         CH    R0,=Y(RTBNTEXT)  LENGTH OK?\n         BH    BADTABS          NOPE\n         EX    R4,MVC1          MOVE REMAINING OVER\nTRXXT    LA    R1,RTBTEXT       POINT TO REAL INPUT\n.LBL06   DS    0H                                          USPS01\nTRXT     L     SR,RTBWAPTR\n         XC    RTBCURS(2,SR),RTBCURS(SR) CLEAR BALL POSITION\nTRX      SR    SR,SR\n         STH   SR,RTBWC\n         STH   SR,RTBPC\n         STH   SR,RTBRC\n         XEXIT 2,8,LTR\n         SPACE 3\nTRUPLOW  TR    RTBTEXT(0),UPLTAB\nCLCATTN  CLC   0(0,R6),RTBATTN(SR)\nMOVE     MVC   0(0,SR),0(1)\nMVC2     MVC   0(0,R3),0(R5)\n         AIF   ('&USPS' EQ '1').LBL07                      USPS01\nTABBS    TRT   0(0,R3),TABTAB\n.LBL07   DS    0H                                          USPS01\nMVC1     MVC   0(0,R5),0(R3)\nMVCB     MVC   0(0,R5),BLANKS\nBLANKS   DC    168C' '\nLONGMSG  DC    C'INPUT TOO LONG, REENTER'\n         AIF   ('&USPS' EQ '1').LBL08                      USPS01\nTABMSG   DC    C'UNSET TABS, REENTER'\nTABTAB   DC    256X'00'\n         ORG   TABTAB+X'05'\n         DC    X'04'\n         ORG   TABTAB+X'16'\n         DC    X'08'\n         ORG\n         SPACE\n.LBL08   DS    0H                                          USPS01\nUPLTAB   DC    X'000102030405060708090A0B0C0D0E0F'\n         DC    X'101112131415161718191A1B1C1D1E1F'\n         DC    X'202122232425262728292A2B2C2D2E2F'\n         DC    X'303132333435363738393A3B3C3D3E3F'\n         DC    X'404142434445464748494A4B4C4D4E4F'\n         DC    X'505152535455565758595A5B5C5D5E5F'\n         DC    X'606162636465666768696A6B6C6D6E6F'\n         DC    X'707172737475767778797A7B7C7D7E7F'\n         DC    X'80C1C2C3C4C5C6C7C8C98A8B8C8D8E8F'\n         DC    X'90D1D2D3D4D5D6D7D8D99A9B9C9D9E9F'\n         DC    X'A0A1E2E3E4E5E6E7E8E9AAABACADAEAF'\n         DC    X'B0B1B2B3B4B5B6B7B8B9BABBBCBDBEBF'\n         DC    X'C0C1C2C3C4C5C6C7C8C9CACBCCCDCECF'\n         DC    X'D0D1D2D3D4D5D6D7D8D9DADBDCDDDEDF'\n         DC    X'E0E1E2E3E4E5E6E7E8E9EAEBECEDEEEF'\n         DC    X'F0F1F2F3F4F5F6F7F8F9FAFBFCFDFEFF'\n         EJECT\nCURTAB    DC   256X'0'         FOR TRANSLATE AND TEST\n          ORG  CURTAB+X'11'\n          DC   X'04'\n          ORG  ,\n* SET TABS\n         SPACE\nTTABS    XENTER 2,8\n         MVC   RTBTABS(8),0(1)         PLACE TABS INTO RTB\n         XEXIT 2,8\n         EJECT\n         LTORG\n         EJECT\n         COPY  WYLCONST\n         EJECT\nPFCB     DSECT\n         COPY  PFCBTSO\n         EJECT\nPCB      DSECT\n         COPY  PCBTSO\n         EJECT\nPIOB     DSECT\n         COPY  PIOB\n         COPY VCPTSO\n         EJECT\n         COMMON\n         SPACE\n         END\n./ ADD NAME=WTR8,SSI=00000178\n         COPY PMAC IS THIS CORRECT\nWTR      TITLE 'WYLTSO INTERFACE WITH TCAM'\n* PROPERTY OF C. U. C. C. A.\n         SPACE 3\n         GBLC  &USPS                                       USPS01\n&USPS    SETC  '1'                                         USPS01\n         TRACER OFF\nWTR      CSECT\n         WIDENT 001\n         SPACE\n         XTRNS ,\n         SPACE 3\n*  REGISTER USAGE\n         SPACE\nSR       EQU   2\nTR       EQU   3\nRR       EQU   4\nJCBR     EQU   5\n         SPACE 3\n         USING CPAREA,R12\n         EJECT\n         ENTRY TSEGXM,TSEGXW,TSEGXB,TSEGX\n         SPACE 3\n* ROUTINE TO DO TSEG AND TMARK\n         SPACE\nTSEGXM   ST    R14,0(13)\n         BALR  R14,0\n         USING *,R14\n         BAL   R14,TSEGCOM         GO DO TSEG\n         USING *,R14\n         B     TWRITEX2            GO DO TWRITE\n         SPACE 3\n* ROUTINE TO DO TSEG AND TWRITE\n         SPACE\nTSEGXW   ST    R14,0(13)\n         BALR  R14,0\n         USING *,R14\n         BAL   R14,TSEGCOM         GO DO TSEG\n         USING *,R14\n         B     TWRITEX2            GO DO TWRITE\n         SPACE 3\n* ROUTINE TO DO TSEG FOLLOWED BY A BLANK\n         SPACE\nTSEGXB   ST    R14,0(13)\n         BALR  R14,0\n         USING *,R14\n         BAL   R14,TSEGCOM         GO DO TSEG\n         USING *,R14\n         SYSQS 1,0,' '             SET UP FOR TSEG OF BLANK\n         BAL   R14,TSEGCOM2        GO DO TSEG OF BLANK\n         USING *,R14\n         B     TSEGEXIT\n         SPACE 3\n* ROUTINE TO DO NORMAL TSEG\n         SPACE\nTSEGX    ST    R14,0(13)\n         BALR  R14,0\n         USING *,R14\n         BAL   R14,TSEGCOM         GO DO TSEG\n         USING *,R14\nTSEGEXIT XEXIT 2,8\n         SPACE\n         DROP  R14\n         SPACE 3\n* TSEG - ADD SEGMENT TO BUFFER\n         SPACE\nTSEGCOM  DS    0H\n         XENTERI 2,8\nTSEGCOM2 DS    0H\n         XTRACE TSEG\n         LH    SR,RTBWC                PICK UP WRITE COUNT\n         LTR   TR,0                    DATA COUNT\n         BNPR  R14                     BR IF NULL SEG\n         AR    TR,SR                   COMPUTE NEW LENGTH\n         CH    TR,=Y(RTBNTEXT)                COMPARE WITH BUF SIZE\n         BNH   *+8\n         LH    TR,=Y(RTBNTEXT)                SET MAX SIZE\n         STH   TR,RTBWC                PLANT NEW WRITE COUNT\n         SR    TR,SR                   COMPUTE ACTUAL DATA COUNT\n         BNPR  R14                     BR IF NO DATA\n         BCTR  TR,0\n         LA    SR,RTBTEXT(SR)\n         EX    TR,MOVE                 MOVE THE DATA\n         BR    R14\n         EJECT\n* TWRITE OUTPUT A LINE\n         SPACE\nTMARKX   XENTER 2,8,*\n         LH     1,RTBWC\n         LTR    1,1\n         BP     DOWRITE\n         XEXIT  2,8\n         SPACE 3\nTWRITEX  XENTER 2,8,*\nDOWRITE  EQU   *-2               EQUATE TO BALR\nTWRITEX2 EQU   *-6               JUST BEFORE LA 13,...\n         XTRACE TWRITE\n         SR    R15,R15\n         L     R3,RTBWAPTR       RTB WORK AREA POINTER\n         LH    R2,RTBWC          WRITE COUNT\n         LTR   R2,R2             IS IT 0?\n         BZ    NOCHARS\n         LA    R1,RTBTEXT-1(R2)  POINT TO LAST CHAR\nBLNKLOOP CLI   0(R1),C' '\n         BNE   NOBLNKS           FOUND A NONBLANK\n         BCTR  R1,0              DECREMENT STRING POINTER\n         BCT   R2,BLNKLOOP       DECREMENT COUNT\nNOBLNKS  STH   R2,RTBWC          SAVE NEW COUNT\nNOCHARS  TM    RTBMFL,RTBNOCR    CHECK MODE FLAG FOR NOCR\n         BZ    NOTNOCR           NO ITS NOT NOCR\n         TM    RTBUFL,RTBUPAD    PAD WANTED?\n         BZ    NOPADS            NO SKIP PADDING\n         CH    R2,CPLNGTH        IS LINE >= 'LENGTH'\n         BNL   NOPADS            YES, SKIP PADDING\n         LH    R5,CPLNGTH\n         STH   R5,RTBWC          MAKE 'LENGTH' THE NEW SIZE\n         SR    R5,R2             NUMBER OF BLANKS TO MOVE\n         BCTR  R5,0\n         LA    R2,RTBTEXT(R2)    MOVE BLANKS TO HERE\n         LA    R1,BLANKS\n         EX    R5,MOVE           GO MOVE BLANKS\nNOPADS   SR    R0,R0             FOR DIVIDE INSTRUCTION\n         LH    R1,RTBCURS(,R3)   CURSOR POSITION\n         AH    R1,RTBWC          ADD NUMBER OF CHARS TO LIST\n         LH    R2,RTBLSZ(,R3)    LINE SIZE\n         DR    R0,R2             FIND REMAINDER\n         STH   R0,RTBCURS(,R3)   NEW CURSOR POSITION\n         LH    R0,RTBWC          LENGTH OF LINE TO PRINT\n         BAL   R6,WRITE          GO WRITE\n         SR    R0,R0\n         STH   R0,RTBLINE(,R3)   CLEAR LINE COUNT\n         B     TRX               AND RETURN\n         SPACE 3\nWRITE    LTR   R0,R0             ANYTHING TO PRINT?\n         BZR   R6                IF NOT RETURN\n         XC    CPEXCMCT,CPEXCMCT CLEAR EXEC COMMAND COUNT\n         LA    R1,RTBTEXT        POINT TO TEXT TO PRINT\n         AIF   ('&USPS' NE '1').LBL01                      USPS01\n         BCTR  R0,0                                        USPS01\n         CH    R0,=H'1'                                    ITEL\n         BE    WRTPUT0                                     ITEL\n         BCTR  R0,0                                        USPS01\nWRTPUT0  EQU   *                                           ITEL\n         TPUT  (1),(0),EDIT,WAIT                           USPS01\n         B     WRLTR                                       USPS01\nWRTPUT   O     R1,=XL4'02000000'                           USPS01\n         TPUT  (1),(0),R                                   USPS01\nWRLTR    LTR   R15,R15                                     USPS01\n         AGO   .LBL02                                      USPS01\n.LBL01   DS    0H                                          USPS01\n         O     R1,=XL4'02000000' TPUT OPTIONS\n         TPUT  (1),(0),R\n         LTR   R15,R15\n.LBL02   DS    0H                                          USPS01\n         BZR   R6                NORMAL RETURN\nWRATTN   OI    JCBAFL,JCBAFIA    IDLE ATTN ON WRITE\n         SR    R0,R0\n         STH   R0,RTBCURS(,R3)   CLEAR BALL POSITION\n         STH   R0,RTBLINE(,R3)   CLEAR LINE COUNT\n         B     TRX\n         SPACE 3\nPAUSE    LA    R1,=C'.'          PRINT A DOT\n         LA    R0,1              LENGTH OF A DOT\n         O     R1,=XL4'02000000' TPUT OPTIONS\n         TPUT  (1),(0),R         GO DO IT\n         LTR   R15,R15\n         BNZ   WRATTN\nPAUSERD  LA    R1,RTBPAUS(,R3)   POINT TO A WORK AREA\n         LA    R0,8              EIGHT IS ENUF\n         O     R1,=XL4'80000000' TGET OPTIONS\n         TGET  (1),(0),R         WAIT\n         B     *+4(R15)          AND RETURN APPROPRIATELY\n         BR    R6                GOOD RETURN\n         DC    3H'0'\n         B     WRATTN            ATTN HIT\n         B     PAUSERD           GO REREAD TO FLUSH\n         DC    2H'0'\n         SVC   3\n         SPACE 3\nNOTNOCR  TM    RTBMFL,RTBWRAP    IS CR/LF TO BE INSERTED?\n         BO    WRAP              YES GO DO IT...\nCHKCRT   TM    RTBMFL,RTBCRT     IS PAGING IN EFFECT?\n         BO    NWRAPCRT          YES GO TEST PAGING\nPUTCR    LH    R2,RTBWC          SIZE OF LINE TO PRINT\n         LA    R2,2(,R2)         2 MORE CHARS FOR CR/LF\n         CH    R2,=Y(RTBNTEXT)   MORE THAN BUFFER SIZE?\n         BNH   *+8               NO IT'S OK\n         LH    R2,=Y(RTBNTEXT)   DEFAULT TO MAXIMUM\n         LR    R0,R2             LENGTH OF TOTAL LINE\n         LA    R2,RTBTEXT-2(R2)  POINT TO PLANT CR/LF\n         MVC   0(2,R2),=X'0D25'  PUT IT IN\n         BAL   R6,WRITE          GO WRITE LINE\n         SR    R0,R0\n         STH   R0,RTBCURS(,R3)   ZERO CURSOR POSITION\n         B     TRX\n         SPACE 3\nNWRAPCRT LH    R1,RTBCURS(,R3)   GET CURSOR POSITION\n         AH    R1,RTBWC          ADD SIZE OF LINE\n         SR    R0,R0\n         LH    R2,RTBLSZ(,R3)    LINE SIZE\n         LTR   R1,R1\n         BZ    *+8               SKIP NEXT TWO INSTR\n         BCTR  R1,0\n         DR    R0,R2             FIND NEW LINE POSITION\n         LA    R1,1(,R1)         ADD ONE\n         AH    R1,RTBLINE(,R3)   ADD ALREADY PRINTED COUNT\n         STH   R1,RTBLINE(,R3)   SAVE IT\n         CH    R1,RTBPSZ(,R3)    NEED PAGING?\n         BNH   PUTCR             NO GO PRINT IT NORMALLY\n         BAL   R6,PAUSE          GO PAUSE\n         LH    R1,RTBWC          SIZE OF LINE\n         SR    R0,R0\n         LH    R2,RTBLSZ(,R3)    MAX LINE SIZE\n         BCTR  R1,0\n         DR    R0,R2             FIND NES LINE POSITION\n         LA    R1,1(,R1)\n         STH   R1,RTBLINE(,R3)   SAVE NEW LINE COUNT\n         B     PUTCR             AND GO LIST NORMALLY\n         SPACE 3\nWRAP     LH    R1,RTBCURS(,R3)   GET CURSOR POSITION\n         AH    R1,RTBWC          ADD SIZE OF LINE TO PRINT\n         CH    R1,RTBLSZ(,R3)    MORE THAN LINE SIZE?\n         BNH   CHKCRT            GO WRITE IGNORING WRAP\n         LH    R2,RTBCURS(,R3)   GET CURSOR POSITION\n         LTR   R2,R2             WHERE?\n         BZ    ZCURS             NO SPECIAL CASE NEEDED\n         SR    R0,R0\n         STH   R0,RTBCURS(,R3)   ZERO OUT CURSOR POSITION\n         LH    R0,RTBLSZ(,R3)    GET LINE SIZE\n         SR    R0,R2             NUMBER OF CHARS TO PRINT NOW\nADDCR    LR    R4,R0\n         LA    R4,RTBTEXT(R4)    POINT TO PLANT CR/LF\n         MVC   RTBSAVE(2,R3),0(R4) SAVE THE TWO CHARS IN TEXT\n         MVC   0(2,R4),=X'0D25'  PLANT THE CR/LF\n         LH    R1,RTBWC          GET LINE SIZE\n         SR    R1,R0             GET REMAINING LENGTH\n         STH   R1,RTBWC\n         AH    R0,=H'2'          ADD 2 FOR CR/LF\n         BAL   R6,WRITE\n         MVC   RTBTEXT(2),RTBSAVE(R3) MOVE BACK THE TEXT SAVED\n         MVC   RTBTEXT+2(RTBNTEXT-2),2(R4) AND THE REMAINING\nZCURS    LH    R1,RTBWC\n         LTR   R1,R1             ANY MORE LEFT?\n         BZ    TRX\n         CH    R1,RTBLSZ(,R3)    MORE THAN LINESIZE?\n         BNH   CHKCRT            GO PRINT REST AS IF NOWRAP\n         TM    RTBMFL,RTBCRT     PAGING IN EFFECT?\n         BZ    NOCR              NO IGNORE PAGING\n         LH    R4,RTBLINE(,R3)   GET LINE COUNT\n         LA    R4,1(,R4)         ADD ONE MORE LINE\n         STH   R4,RTBLINE(,R3)\n         CH    R4,RTBPSZ(,R3)    MORE THAN PAGESIZE?\n         BNH   NOCR\n         BAL   R6,PAUSE\n         SR    R0,R0\n         STH   R0,RTBLINE(,R3)   ZERO OUT LINE COUNT\nNOCR     LH    R0,RTBLSZ(,R3)    MAXIMUM TO PRINT\n         B     ADDCR\n         EJECT\n* OPWRITE - SEND MESSAGE TO OPERATOR\n         SPACE\nOPWRITE  XENTER 2,8,*\n         XTRACE OPWRITE\n         SR    SR,SR\n         STH   SR,RTBPC\n         STH   SR,RTBRC\n         BAL   R14,TREADX\n         XEXIT 2,8\n         EJECT\n* TREAD - PROMPT AND READ A LINE\n         SPACE\nTREADX   XENTER 2,8,*\n         SR    R3,R3               FLAG REGISTER\n         CH    R3,CVPRMLIM         RECOVERY WANTED?\n         BE    NORECVRY            IF 0 NO RECOVERY NEEDED\n         LA    R4,1                TO BE USED AS A FLAG\n         TM    CPGFLG,CPFDIRCH     IS DIRCTORY CHANGED?\n         BO    RECOVERY            IF SO FORCE RECOVERY\n         LH    R4,CVPROMPT         HOW MANY PROMPTS HAVE GONE BY?\n         CH    R4,CVPRMLIM         MORE THAN UPDATE LIMIT?\n         BL    NORECVRY            IF LESS, NO RECOVERY\n         SR    R4,R4               TO BE USED AS A FLAG\nRECOVERY L     R3,CVFPFCB          OUR PFCB ADDRESS\n         L     R2,CVFPAGE          FIRST PCB ADDRESS\n         USING PFCB,R3\n         USING PCB,R2\nPCBLOOP  TM    PCBFL,PCBFMARK      WAS PAGE MARKED?\n         BZ    NEXTPCB             IF NOT SKIP IT\n         LH    R1,PCBPN            GET PAGE NUMBER\n         LA    R4,1(,R4)           SAY A PAGE WAS WRITTEN\n         MVI   PCBRWCCW,PIOWRITE   INDICATE WE WILL WRITE\n         CVCALL PIO                GO DO I/O\n         NI    PCBFL,255-PCBFMARK  TURN OFF DIRTY MARK\nNEXTPCB  LA    R2,PCBSIZE(,R2)     POINT TO NEXT PCB\n         C     R2,CVLPAGE          PAST THE LAST ONE?\n         BL    PCBLOOP             IF NOT KEEP LOOPING\n         LTR   R4,R4               ANYTHING MORE TO BE DONE?\n         BZ    NORECVRX            NO, GET OUT\n         OI    JCBBFL,JCBPIOW      INDICATE EXCP WILL COME\n         LR    R5,R15\n         L     R4,JCBWAPTR\n         MVC   0(8,R4),=CL8'RECOVER'\n         MVC   8(4,R4),PFCBCP      CURRENT PAGES USED\n         MVC   12(4,R4),CPRSCNVL   RESCAN ESC SKIP CHARS\n         MVC   16(4,R4),CPEXLNET   SAVE EXEC LINE POINTER\n         MVC   20(12,R4),CVEXTRAP  EXEC TRAP AND UPDATE CNT\n         LA    R4,32(,R4)          MORE TO WRITE\n         MVC   0(RTBSIZE-RTBNTEXT,R4),RTBSTART RTB INFO\n         LA    R4,RTBSIZE-RTBNTEXT(,R4)\n         MVC   0(CPRCVSZ1,R4),CPGLDL           CP INFO\n         LA    R4,CPRCVSZ1(,R4)\n         MVC   0(CPRCVSZ2,R4),CPDRPT           MORE CP INFO\n         LA    R4,CPRCVSZ2(,R4)\n         LR    R2,R4                           FOR MVCL\n         LA    R3,CPRCVSZ3                     LENGTH\n         LA    R14,CPDREC                      FROM\n         LR    R15,R3                          SAME LENGTH\n         MVCL  R2,R14                          MOVE IT\n         LA    R4,CPRCVSZ3(,R4)\n         LR    R2,R4                           FOR MVCL\n         LA    R3,ROUTBLEN                     LENGTH\n         LA    R14,ROUTBLE                     FROM\n         LR    R15,R3                          SAME LENGTH\n         MVCL  R2,R14                          MOVE IT\n         LA    R4,ROUTBLEN(,R4)\n         L     R15,RTBWAPTR\n         MVC   0(256,R4),0(R15)                 TERMINAL INFO\n*        DO EXCP\n         L     R3,CVPIOB\n         USING PIOB,R3\n         L     R4,JCBWAPTR\n         STCM  R4,7,PCCWWRT1+1          SAVE IT\n         MVI   PSEEKREC,1        SET RECORD 1\n         MVI   PCCWWRT1+4,X'00'  UNCHAIN\n         XC    PECB,PECB\n         EXCP  PIOBSTRT\n        LA    R14,PECB\n        WAIT  ECB=(R14)           WAIT FOR I/O TO COMPLETE\n         L     R3,CVFPFCB          OUR PFCB ADDRESS\n         USING PFCB,R3\n         L     R14,JCBWAPTR           GET BUFFER\n         L     R2,PFCBPTST            BEGINNING OF PAGE TABLE\n         LA    R3,&PAGE0              MAX NUMBER OF PAGES\n         LR    R15,R3                 SAME LENGTH\n         MVCL  R14,R2                 MOVE IT\n*        DO EXCP\n         L     R3,CVPIOB\n         USING PIOB,R3\n         L     R4,JCBWAPTR\n         STCM  R4,7,PCCWWRT1+1          SAVE IT\n         MVI   PSEEKREC,2        SET RECORD 2\n         XC    PECB,PECB\n         EXCP  PIOBSTRT\n        LA    R14,PECB\n        WAIT  ECB=(R14)           WAIT FOR I/O TO COMPLETE\n         LA    R2,CPAREA+CPSIZE     2ND CP PAGE\n         STCM  R2,7,PCCWWRT1+1          SAVE IT\n         L     R3,CVPIOB\n         USING PIOB,R3\n         MVI   PSEEKREC,3        SET RECORD 3\n         XC    PECB,PECB\n         EXCP  PIOBSTRT\n        LA    R14,PECB\n        WAIT  ECB=(R14)           WAIT FOR I/O TO COMPLETE\n         L     R2,CVCPADDR          ADDR OF VCP\n         STCM  R2,7,PCCWWRT1+1          SAVE IT\n         L     R3,CVPIOB\n         USING PIOB,R3\n         MVI   PSEEKREC,4        SET RECORD 4\n         XC    PECB,PECB\n         EXCP  PIOBSTRT\n         LA    R14,PECB\n         WAIT  ECB=(R14)           WAIT FOR I/O TO COMPLETE\n         MVI   PSEEKREC,1        SET RECORD 1\n         MVI   PCCWWRT1+4,X'40'  SET CHAINED\n         XC    PCCWWRT1+1(3),PCCWWRT1+1\n         DROP  R3\n         DROP  R2\n         LR    R15,R5          RESTORE R15\nNORECVRX LM    R2,R6,4(R8)          RESTORE INPUT REGISTERSDEL\nNORECVRY SR    R3,R3\n         STH   R3,CPEXCMCT         ZERO EXEC COUNT\n         L     R4,RTBWAPTR         GET RTB WORK AREA POINTER\n         STH   R3,RTBLINE(,R4)     CLEAR LINES PRINTED\n         LTR   RR,15               TEST '? ' INSERT\n         BP    DNTADIT             NO '? '\n         LPR   R4,R15              SET IT TO POSITIVE\n         C     R4,=X'005A5B7C'     IS IT MOD OR EDIT?\n         BNE   *+6\n         LR    R3,R4               FLAG NO REPROMPT\n         TSEG  '? '                COMPLETE PROMPT\nDNTADIT  LH    R0,RTBWC            COMPUTE PROMPT SIZE\n         LTR   R0,R0               ANY PROMPT INVOLVED?\n         BZ    RD                  NO .. GO TO RD\n         L     R4,RTBWAPTR\n         LA    R1,RTBTEXT\n         CH    R0,=Y(RTBPMAX)    MORE THAN THAT?\n         BNH   *+10\n         SH    R0,=Y(RTBPMAX)\n         AR    R1,R0               POINT TO LAST RTBPMAX CHARS\n         MVC   RTBPRMPT(RTBPMAX,R4),0(R1) MOVE THE PROMPT\nTPUTIT   LH    R5,RTBWC            GET WRITE COUNT\n         TM    RTBMFL,RTBWRAP      WRAP FORCE WANTED?\n         BZ    RNOWRAP             NO, REGULAR\n         LH    R1,RTBCURS(,R4)     GET BALL POSITION\n         AR    R1,R5               ADD LENGTH TO BE WRITTEN\n         CH    R1,RTBLSZ(,R4)      MORE THAN LS?\n         BL    RNOWRAP             NO GO DO WITHOUT WRAP\n         LH    R2,RTBCURS(,R4)     GET BALL POSITION\n         LTR   R2,R2               WAS BALL MOVED?\n         BZ    RZCURS              NO, NO SPECIAL CASE THEN\n         SR    R0,R0\n         STH   R0,RTBCURS(,R4)     CLEAR BALL POSITION\n         LH    R0,RTBLSZ(,R4)      GET LS\n         SR    R0,R2               GET SPECIAL CASE LENGTH\nRADDCR   LR    R3,R0               LENGTH TO PRINT THIS TIME\n         LA    R3,RTBTEXT(R3)      POINT TO END OF IT\n         MVC   RTBSAVE(2,R4),0(R3) SAVE 2 CHARS\n         MVC   0(2,R3),=X'0D25'    PUT CR/LF\n         SR    R5,R0               GET REMAINING COUNT\n         AH    R0,=H'2'            ADD 2 MORE FOR CR/LF\n         BAL   R6,RWRITE           GO WRITE PORTION\n         MVC   RTBTEXT(2),RTBSAVE(R4) MOVE BACK THE 2 CHARS\n         MVC   RTBTEXT+2(RTBNTEXT-2),2(R3) AND SHIFT OTHERS\nRZCURS   LTR   R1,R5               ANYTHING MORE TO WRITE?\n         BZ    RD                  NO, GET OUT\n         CH    R1,RTBLSZ(,R4)      MORE THAN LS?\n         BL    RNOWRAP             NO, ACT JUST LIKE NOWRAP\n         LH    R0,RTBLSZ(,R4)      PROMPT SOME MORE\n         B     RADDCR\n         SPACE\nRNOWRAP  LH    R1,RTBCURS(,R4)     GET CURSOR POSITION\n         AR    R1,R5               ADD WRITE COUNT\n         SR    R0,R0\n         LH    R2,RTBLSZ(,R4)\n         DR    R0,R2               FIND NEW BALL POSIT = REM.\n         STH   R0,RTBCURS(,R4)\n         LR    R0,R5\n         BAL   R6,RWRITE\nRD       LA    R0,SZR              MAX LINE SIZE\n         LA    R1,RTBTEXT\n         O     R1,=XL4'81000000'    TGET ASIS\n         TGET  (1),(0),R\n         B     *+4(R15)\n         B     TESTKEY       TGET SUCCESSFUL\n         DC    2H'0'         CANNOT HAVE NOWAIT\n         B     RDATTN        ATTN ON READ\n         B     FLUSH         TOO MANY CHARACTERS\n         DC    2H'0'         CANNOT HAVE INVALID PARMS\n         SVC   3             USER HANGED UP DE FONE\n         SPACE\nTESTKEY  DS    0H\n         LTR   R1,R1              ANYTHING RETURNED\n         BZ    REPROMP            NO TGET AGAIN\n         LR    R0,R1              SAVE ACROSS TRT\n         EX    R1,TRANTEST        TRT\n         BNZ   DELCUR             DELETE CURSOR CHAR\nTESTENT  LR    R1,R0              RESTORE COUNT\n         CLI   RTBTEXT,X'7D'      ENTER HIT\n         BNE   TESTPFK            NO TEST PFK\nSETENT   SH    R1,=H'6'           FOR ASIS INFO\n         LTR   R1,R1              SEE IF NEG\n         BNM   *+8\n         LA    R1,0               SET ZERO IF MINUS\n         EX    R1,MOVTEXT         MOV THE TEXT OVER\n         LA    R2,RTBTEXT+1(R1)  MOVE BLANKS\n         MVC   0(6,R2),BLANKS    FILL LINE WITH BLANKS\n         B     SETREGS            CONTINUE\n         SPACE\nDELCUR   DS    0H\n         LR    R3,R1           SET CUR POS\n         LA    R14,RTBTEXT     POINT TO BEGININNG\n         SR    R3,R14          DISPL INTO RTBTEXT\n         LR    R4,R0           TEMP REST\n         SR    R4,R3           DECR FOR MOVE\n         SH    R4,=H'4'        FOR EXEC\n         EX    R4,MOVTEXT2     MOV IT\n         SH    R0,=H'3'\n         B     TESTENT         CONTINUE\nMOVTEXT  MVC   RTBTEXT(0),RTBTEXT+6         MOVE OVER ASIS INFO\nMOVTEXT2 MVC   0(0,R1),3(R1)                MOVE OVER ASIS INFO\nTRANTEST TRT   RTBTEXT+6(0),CURTAB           DELETE CURSOR CHARS\n         SPACE\nTESTPFK  DS    0H\n         L     VCPR,CVCPADDR      POINT TO VCP PAGE\n         USING DVCP,VCPR\n         LA    R2,VCPPVAR         POINT TO PFK KEYS\n         DROP  VCPR\n         LA    R3,24              NUMBER OF PFK'S\n         SLR   R4,R4              USED FOR IC\nFINDPFK  CLC   RTBTEXT(1),0(R2)         MATCH\n         BE    SEEPFK             YES SEE IF SET\n         LA    R2,25(R2)          NEXT ENTRY\n         BCT   R3,FINDPFK         CHECK NEXT\n         B     SETENT                   UNKNOW SET AS ENTER\n         SPACE\nSEEPFK   CH    R1,=AL2(6)         ANY THING ELSE\n         BH    SETPFK             OVER 6 MEANS SET PFK\nSEEPFK2  SLR   R4,R4              FOR INSERT\n         ICM   R4,1,1(R2)         GET LENGTH\n         BZ    SETENT             ZERO LENGTH \u00a26 SET AS ENTER\n         LR    R1,R4              FOR LATER\n         BCTR  R4,R0              FOR MOVE\n         EX    R4,PFKMOVE         MOV TO RTBTEXT\n         B     SETREGS            CONTINUE PROCESSING\n         SPACE\nREPROMP  DS    0H\n         SLR   R0,R0              CLEAR REGISTER FOR ICM\n         ICM   R0,3,RTBPC         AND PROMPT COUNT\n         BZ    RD                 NO JUST READ\n         BAL   R6,RWRITE          REWRITE\n         B     RD                 GO RE-READ\n         SPACE\nSETPFK   DS   0H\n         L     VCPR,CVCPADDR      POINT TO VCP PAGE\n         USING DVCP,VCPR\n         LA    R2,VCPPVAR         POINT TO PFK KEYS\n         DROP  VCPR\n         SH    R1,=AL2(6)    SUBTRACT GARBAGE\n         CH    R1,=AL2(23)   MAX FOR ANY PFK\n         BH    PFKMAX        HIGH IGNORE\nPFKSLOOP CLC   RTBTEXT(1),0(R2)\n         BE    MOVPFK        YES\n         LA    R2,25(R2)     NEXT PFK\n         B     PFKSLOOP      LOOP\nMOVPFK   STC   R1,1(R2)        SAVE LENGTH\n         BCTR  R1,R0         DECR FOR EXECUTE\n         MVI   2(R2),C' '     CLEAR LAST ENTRY\n         MVC   3(22,R2),2(R2)       ENTIRELY\n         EX    R1,MOVEIT     MOVE IT\n         B     SEEPFK2          EXECUTE COMMAND\nMOVEIT   MVC   2(0,R2),RTBTEXT+6  CURRENT KEY\n         SPACE\n*\nPFKMAX   TSEG 'PFK ENTRY TOO LONG'\n         B    CVGETCOM\nPFKMOVE  MVC   RTBTEXT(0),2(R2)        COMMAND\n         SPACE\nRWRITE   LA    R1,RTBTEXT\n         AIF   ('&USPS' NE '1').LBL03                      USPS01\n         TPUT  (1),(0),ASIS,WAIT                           USPS01\n         B     RWLTR                                       USPS01\nRWTPUT   O     R1,=XL4'02000000'                           USPS01\n         TPUT  (1),(0),R                                   USPS01\nRWLTR    LTR   R15,R15                                     USPS01\n         AGO   .LBL04                                      USPS01\n.LBL03   DS    0H                                          USPS01\n         O     R1,=XL4'02000000'\n         TPUT  (1),(0),R\n         LTR   R15,R15\n.LBL04   DS    0H                                          USPS01\n         BZR   R6            SUCCESSFUL TPUT\nRDATTN   SR    R1,R1         ATTN INNTERRUPT\n         SR    R0,R0\n         B     TRXT\n         SPACE\nFLUSH    LA    R0,SZR\n         LA    R1,RTBTEXT\n         O     R1,=XL4'80000000'\n         TGET  (1),(0),R\n         B     *+4(R15)\n         B     SETREGM       FIRST NOTIFY TRUNCATION\n         DC    2H'0'         CANNOT BE NOWAIT\n         B     RDATTN        ATTN ON READ???\n         B     FLUSH         KEEP ON FLUSHING ZE INPUT\n         DC    2H'0'         ILLEGAL PARMS???\n         SVC   3             USER HUNG UP\n         SPACE 3\nSETREGM  LA    R1,LONGMSG\n         LA    R0,L'LONGMSG\nREPROMPT TPUT  (1),(0),R\nSETREGM2 LH    R0,RTBWC      GET PROMPT COUNT\n         L     R1,RTBWAPTR\n         XC    RTBCURS(2,R1),RTBCURS(R1) CLEAR BALL POSITION\n         LTR   R0,R0         IS THERE ANY?\n         BZ    RD            GO READ AGAIN\n         LR    R4,R1         POINT TO WA\n         MVC   RTBTEXT(RTBPMAX),RTBPRMPT(R1) MOVE PROMPT BACK\n         CH    R0,=Y(RTBPMAX) IS IT TOO LONG?\n         BNH   TPUTIT\n         LA    R0,RTBPMAX    MAX PROMPT SIZE\n         STH   R0,RTBWC      SAVE NEW WRITE COUNT\n         B     TPUTIT        GO PROMPT AGAIN\n         SPACE\nSETREGS  LR    R0,R1           LENGTH OF INPUT\n         LA    R1,RTBTEXT      ADDRESS OF INPUT\n         TM    RTBUFL,RTBUATTN IS ATTN SEQ ALLOWED\n         BZ    READTEST        IF NOT SKIP THE CHECK\n         L     SR,RTBWAPTR\n         LH    R5,RTBATNSZ(,SR) LENGTH OF ATTN SEQ\n         CR    R5,R0           CAN THERE BE AN ATTN SEQ?\n         BH    READTEST        IF NOT SKIP THE CHECK\n         LR    R6,R1           POINT TO INPUT\n         AR    R6,R0           POINT TO END OF INPUT\n         SR    R6,R5           POINT TO POSSIBLE ATTN SEQ\n         BCTR  R5,R0           GUESS WHY\n         EX    R5,CLCATTN      IS IT AN ATTN?\n         BNE   READTEST        IF NOT RETURN\n         LA    R5,1(,R5)       BACK TO CORRECT LENGTH\n         CR    R5,R0           WAS IT ONLY THE ATTN SEQ?\n         BE    TRXX            IF SO RETURN REAL ATTN\n         C     R3,=X'005A5B7C' IS IT EDIT OR MODIFY?\n         BNE   SETREGM2        IF NOT REPROMPT\n         BCTR  R6,R0           POINT TO CHAR BEFORE ATTN\n         CLI   0(R6),C'$'      IS IT A DOLLAR?\n         BE    TRXX\n         CLI   0(R6),C'!'      IS IT AN EXCLAMATION?\n         BE    TRXX\n         CLI   0(R6),C'@'      IS IT AN AT SIGN\n         BNE   SETREGM2        IF NON OF THE ABOVE, REPROMPT\nTRXX     SR    R0,R5           GET RID OF ATTN SEQ\n         LA    R15,4           RETURN NONZERO CC\nREADTEST LTR   SR,R0           UPLOW OR TABS POSSIBLE?\n         BZ    TRXT\n         BCTR  SR,0\n         TM    CPGFLG,CPFUPLW  UPLOW ALLOWED?\n         BO    NOEXTR          YES, SKIP TRANSLATE\n         EX    SR,TRUPLOW\n         AIF   ('&USPS' NE '1').LBL05                      USPS01\nNOEXTR   DS    0H                                          USPS01\n         AGO   .LBL06                                      USPS01\n.LBL05   DS    0H                                          USPS01\nNOEXTR   L     R3,RTBWAPTR\n         XC    RTBBSCNT(2,R3),RTBBSCNT(R3) CLEAR BS COUNT\n         LA    R3,RTBTRBUF(,R3) R3: @ BUFFER FOR COPY OF INPUT\n         LR    R4,SR           R4: REMAINING LENGTH - 1\n         LA    R5,RTBTEXT      R5: @ RESULT OF INPUT\n         SR    R0,R0           R0: PROCESSED LENGTH\n         SR    R2,R2\n         EX    R4,MVC2         GET A COPY OF INPUT\nTABBSLP  EX    R4,TABBS        FIND A TAB OR BS\n         BZ    ENDTABS         NONE, END UP\n         SR    R1,R3           R1: LENGTH OF STRING W/OUT TAB\n         BZ    NOMVC           IF NONE SKIP THE NEXT FEW\n         BCTR  R1,0            LESS 1 FOR EX\n         EX    R1,MVC1         MOVE THE STUFF OVER FROM COPY\n         LA    R1,1(,R1)       ADD 1 TO GET REAL LENGTH\n         AR    R5,R1           UPDATE REAL INPUT POINTER\n         AR    R3,R1           UPDATE COPY POINTER\n         AR    R0,R1           UPDATE PROCESSED LENGTH\n         SR    R4,R1           UPDATE REMAINING LENGTH\nNOMVC    LA    R3,1(,R3)       ADD 1 MORE FOR BS OR TAB CHR\n         B     *(R2)           R2 WAS SET FROM THE TRT\n         B     TAB             R2=4 MEANS A TAB, 8 MEANS A BS\n         SPACE\n         TM    RTBUFL,RTBUBACK BACK SET ?\n         BO    ADDBS           IF SO TREAT BS AS A CHARCTER\n         LTR   R0,R0           WAS THERE ANYTHING IN BUFFER?\n         BZ    TESTREM         NO, DON'T DECREMENT\n         BCTR  R0,0            REDUCE PROCESSED LENGTH\n         BCTR  R5,0            REDUCE BUFFER POINTER\nTESTREM  LTR   R4,R4           ANYTHING LEFT?\n         BZ    TRXXT           NO, EXIT\n         BCTR  R4,0            REDUCE 1 MORE FOR TAB OR BS\n         B     TABBSLP         GO FIND MORE\n         SPACE\nADDBS    MVI   0(R5),X'16'     MOVE IN A BS\n         LA    R5,1(,R5)       ADD 1 TO BUFFER POINTER\n         AH    R0,=H'1'        ADD 1 TO PROCESSED LENGTH\n         L     R14,RTBWAPTR\n         LH    R1,RTBBSCNT(,R14) GET BS COUNT\n         LA    R1,1(,R1)       ADD 1\n         STH   R1,RTBBSCNT(,R14) SAVE BS COUNT\n         B     TABBSLP\n         SPACE\nTAB      LR    R6,R0           GET PROCESSED COUNT\n         L     R14,RTBWAPTR\n         SH    R6,RTBBSCNT(,R14) REDUCE IT BY # BS'S\n         XC    RTBBSCNT(2,R14),RTBBSCNT(R14) CLEAR BS COUNT\n         TM    RTBUFL,RTBURELT ARE TABS RELATIVE?\n         BO    CURSET          IF SO SKIP THE NEXT 2\n         AH    R6,RTBCURS(,R14) ADD CURSOR POSITON\nCURSET   LA    R14,RTBTABS      POINT TO TABS\n         LA    R1,8             AT MOST EIGHT TABS\nTBLP     IC    R2,0(,R14)       GET A TAB\n         LTR   R2,R2            IS THERE ONE?\n         BZ    BADTABS          TOO BAD...\n         BCTR  R2,0             LESS 1\n         CR    R2,R6            DOES THIS ONE FIT?\n         BH    FNDTAB           OK IT DOES.\n         LA    R14,1(,R14)      POINT TO NEXT TAB\n         BCT   R1,TBLP          AND CHECK MORE\nBADTABS  LA    R1,TABMSG        UNSET TABS\n         LA    R0,L'TABMSG\n         B     REPROMPT\n         SPACE\nFNDTAB   LR    R1,R2            TAB POSITION\n         SR    R1,R6            TAB TO THIS MANY POSITIONS\n         AR    R0,R1            NEW PROCESSED COUNT\n         BCTR  R1,0\n         EX    R1,MVCB          MOVE SOME BLANKS OVER\n         LA    R5,1(R1,R5)      UPDATE BUFFER POINTER\n         B     TESTREM          AND GO FIND MORE\n         SPACE\nENDTABS  AR    R0,R4            TOTAL LENGTH OF INPUT\n         AH    R0,=H'1'         PLUS 1\n         CH    R0,=Y(RTBNTEXT)  LENGTH OK?\n         BH    BADTABS          NOPE\n         EX    R4,MVC1          MOVE REMAINING OVER\nTRXXT    LA    R1,RTBTEXT       POINT TO REAL INPUT\n.LBL06   DS    0H                                          USPS01\nTRXT     L     SR,RTBWAPTR\n         XC    RTBCURS(2,SR),RTBCURS(SR) CLEAR BALL POSITION\nTRX      SR    SR,SR\n         STH   SR,RTBWC\n         STH   SR,RTBPC\n         STH   SR,RTBRC\n         XEXIT 2,8,LTR\n         SPACE 3\nTRUPLOW  TR    RTBTEXT(0),UPLTAB\nCLCATTN  CLC   0(0,R6),RTBATTN(SR)\nMOVE     MVC   0(0,SR),0(1)\nMVC2     MVC   0(0,R3),0(R5)\n         AIF   ('&USPS' EQ '1').LBL07                      USPS01\nTABBS    TRT   0(0,R3),TABTAB\n.LBL07   DS    0H                                          USPS01\nMVC1     MVC   0(0,R5),0(R3)\nMVCB     MVC   0(0,R5),BLANKS\nBLANKS   DC    168C' '\nLONGMSG  DC    C'INPUT TOO LONG, REENTER'\n         AIF   ('&USPS' EQ '1').LBL08                      USPS01\nTABMSG   DC    C'UNSET TABS, REENTER'\nTABTAB   DC    256X'00'\n         ORG   TABTAB+X'05'\n         DC    X'04'\n         ORG   TABTAB+X'16'\n         DC    X'08'\n         ORG\n         SPACE\n.LBL08   DS    0H                                          USPS01\nUPLTAB   DC    X'000102030405060708090A0B0C0D0E0F'\n         DC    X'101112131415161718191A1B1C1D1E1F'\n         DC    X'202122232425262728292A2B2C2D2E2F'\n         DC    X'303132333435363738393A3B3C3D3E3F'\n         DC    X'404142434445464748494A4B4C4D4E4F'\n         DC    X'505152535455565758595A5B5C5D5E5F'\n         DC    X'606162636465666768696A6B6C6D6E6F'\n         DC    X'707172737475767778797A7B7C7D7E7F'\n         DC    X'80C1C2C3C4C5C6C7C8C98A8B8C8D8E8F'\n         DC    X'90D1D2D3D4D5D6D7D8D99A9B9C9D9E9F'\n         DC    X'A0A1E2E3E4E5E6E7E8E9AAABACADAEAF'\n         DC    X'B0B1B2B3B4B5B6B7B8B9BABBBCBDBEBF'\n         DC    X'C0C1C2C3C4C5C6C7C8C9CACBCCCDCECF'\n         DC    X'D0D1D2D3D4D5D6D7D8D9DADBDCDDDEDF'\n         DC    X'E0E1E2E3E4E5E6E7E8E9EAEBECEDEEEF'\n         DC    X'F0F1F2F3F4F5F6F7F8F9FAFBFCFDFEFF'\n         EJECT\nCURTAB    DC   256X'0'         FOR TRANSLATE AND TEST\n          ORG  CURTAB+X'11'\n          DC   X'04'\n          ORG  ,\n* SET TABS\n         SPACE\nTTABS    XENTER 2,8\n         MVC   RTBTABS(8),0(1)         PLACE TABS INTO RTB\n         XEXIT 2,8\n         EJECT\n         LTORG\n         EJECT\n         COPY  WYLCONST\n         EJECT\nPFCB     DSECT\n         COPY  PFCBTSO\n         EJECT\nPCB      DSECT\n         COPY  PCBTSO\n         EJECT\nPIOB     DSECT\n         COPY  PIOB\n         COPY VCPTSO\n         EJECT\n         COMMON\n         SPACE\n         END\n./ ADD NAME=WYLWA,SSI=00000002\n         TITLE 'WDIOWA --- PROTOTYPE'\n         ENTRY WDIOWA\nWDIOWA   WDIOWA CSECT\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CNTL": {"ttr": 12545, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00$\\x01\\x19#\\x0f\\x01\\x19#\\x0f\\x14A\\x01L\\x01L\\x00\\x00\\xe6\\xe8\\xd3\\xc2\\xe4\\xd9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2019-08-18T00:00:00", "modifydate": "2019-08-18T14:41:24", "lines": 332, "newlines": 332, "modlines": 0, "user": "WYLBUR"}, "text": "./ ADD NAME=ASMJCL   0102-80182-80193-1716-00022-00042-00001-$SYS13  00\n//ASMJCL  JOB (2000,S010),WENZEL,CLASS=Z\n/*JOBPARM Q=F,I\n//*\n//ASMWYL   PROC  PRE='SYS4.WYLTSO.JUN80',\n//         MEM=\n//ASM      EXEC  PGM=IFOX00,PARM='LOAD'\n//SYSLIB   DD    DSN=&PRE..MACLIB0,DISP=SHR,DCB=BLKSIZE=19040\n//         DD    DSN=&PRE..MACLIB,DISP=SHR,DCB=BLKSIZE=19040\n//         DD    DSN=SYS1.AMODGEN,DISP=SHR\n//         DD    DSN=SYS1.MACLIB,DISP=SHR\n//SYSUT1   DD    DSN=&&SYSUT1,UNIT=SYSDA,SPACE=(CYL,(10,10))\n//SYSUT2   DD    DSN=&&SYSUT2,UNIT=SYSDA,SPACE=(CYL,(10,10))\n//SYSUT3   DD    DSN=&&SYSUT3,UNIT=SYSDA,SPACE=(CYL,(10,10))\n//SYSPRINT DD    SYSOUT=*\n//SYSPUNCH DD    DUMMY\n//SYSGO    DD    DSN=&PRE..OBJ(&MEM),DISP=SHR,\n//         DCB=(LRECL=80,BLKSIZE=3120,RECFM=FB)\n//SYSIN    DD    DSN=&PRE..ASM(&MEM),DISP=SHR\n//        PEND\n//*\n//INIT    EXEC ASMWYL,REGION=2048K,MEM=INIT\n//PEDP    EXEC ASMWYL,REGION=2048K,MEM=PEDP\n./ ADD NAME=ASMJCL9  0101-80182-80228-1357-00041-00042-00000-$SYS13  00\n//ASMJCL  JOB (2000,S010),WENZEL,CLASS=Z\n/*JOBPARM Q=F,I\n//*\n//ASMWYL   PROC  PRE='SYS4.WYLTSO.JUN80',\n//         MEM=\n//ASM      EXEC  PGM=IFOX00,PARM='LOAD'\n//SYSLIB   DD    DSN=&PRE..MACLIB0,DISP=SHR,DCB=BLKSIZE=19040\n//         DD    DSN=&PRE..MACLIB,DISP=SHR,DCB=BLKSIZE=19040\n//         DD    DSN=SYS1.AMODGEN,DISP=SHR\n//         DD    DSN=SYS1.MACLIB,DISP=SHR\n//SYSUT1   DD    DSN=&&SYSUT1,UNIT=SYSDA,SPACE=(CYL,(10,10))\n//SYSUT2   DD    DSN=&&SYSUT2,UNIT=SYSDA,SPACE=(CYL,(10,10))\n//SYSUT3   DD    DSN=&&SYSUT3,UNIT=SYSDA,SPACE=(CYL,(10,10))\n//SYSPRINT DD    SYSOUT=*\n//SYSPUNCH DD    DUMMY\n//SYSGO    DD    DSN=&PRE..OBJ(&MEM),DISP=SHR,\n//         DCB=(LRECL=80,BLKSIZE=3120,RECFM=FB)\n//SYSIN    DD    DSN=&PRE..ASM(&MEM),DISP=SHR\n//        PEND\n//*\n//BEXE    EXEC ASMWYL,REGION=2048K,MEM=BEXE\n//BLPR    EXEC ASMWYL,REGION=2048K,MEM=BLPR\n//CR      EXEC ASMWYL,REGION=2048K,MEM=CR\n//CVREAL  EXEC ASMWYL,REGION=2048K,MEM=CVREAL\n//INIT    EXEC ASMWYL,REGION=2048K,MEM=INIT\n//PAGER   EXEC ASMWYL,REGION=2048K,MEM=PAGER\n//PDIO    EXEC ASMWYL,REGION=2048K,MEM=PDIO\n//PDOS    EXEC ASMWYL,REGION=2048K,MEM=PDOS\n//PEDP    EXEC ASMWYL,REGION=2048K,MEM=PEDP\n//PEDS    EXEC ASMWYL,REGION=2048K,MEM=PEDS\n//PGOP    EXEC ASMWYL,REGION=2048K,MEM=PGOP\n//PGOS    EXEC ASMWYL,REGION=2048K,MEM=PGOS\n//PPRT    EXEC ASMWYL,REGION=2048K,MEM=PPRT\n//PROC    EXEC ASMWYL,REGION=2048K,MEM=PROC\n//PSCN    EXEC ASMWYL,REGION=2048K,MEM=PSCN\n//PSGT    EXEC ASMWYL,REGION=2048K,MEM=PSGT\n//PTSO    EXEC ASMWYL,REGION=2048K,MEM=PTSO\n//PUTB    EXEC ASMWYL,REGION=2048K,MEM=PUTB\n//PWYL    EXEC ASMWYL,REGION=2048K,MEM=PWYL\n//WTR     EXEC ASMWYL,REGION=2048K,MEM=WTR\n//WYLWA   EXEC ASMWYL,REGION=2048K,MEM=WYLWA\n./ ADD NAME=HELPJCL  0109-80160-80234-1234-00009-00393-00009-$SYS11  00\n//HELPJCL  JOB (2000,S010),WENZEL,CLASS=Z,MSGCLASS=C\n//STEP1 EXEC PGM=HELPLIST\n//SYSUT1   DD DISP=SHR,DSN=SYS4.WYLTSO.JUN80.HELP\n//SYSINDEX DD SYSOUT=*\n//SYSPRINT DD SYSOUT=*\n//SYSIN    DD *\nGENWYL\nWYLBUR\n/*\n./ ADD NAME=IEBCOPYD 0101-80182-80182-1737-00023-00043-00000-$SYS13  00\n//IEBCOPY  JOB (2000,S010),WENZEL,CLASS=Z\n/*JOBPARM Q=F,I\n//STEP1    EXEC PGM=IEBCOPY,REGION=1024K\n//SYSPRINT DD SYSOUT=*\n//OUT1     DD DISP=SHR,DSN=SYS4.WYLTSO.JUN80.ASM\n//OUT2     DD DISP=SHR,DSN=SYS4.WYLTSO.JUN80.MACLIB0\n//OUT3     DD DISP=SHR,DSN=SYS4.WYLTSO.JUN80.MACLIB\n//IN1      DD DISP=(SHR,PASS),DSN=ASM,\n//         VOL=SER=WENZEL,\n//         UNIT=TAPE,LABEL=(1,NL,EXPDT=98000)\n//IN2      DD DISP=(SHR,PASS),DSN=CNTL,\n//         VOL=SER=WENZEL,\n//         UNIT=TAPE,LABEL=(2,NL,EXPDT=98000)\n//IN3      DD DISP=(SHR,PASS),DSN=DOCLIB,\n//         VOL=SER=WENZEL,\n//         UNIT=TAPE,LABEL=(3,NL,EXPDT=98000)\n//SYSUT3   DD UNIT=SYSDA,SPACE=(CYL,(5,1))\n//SYSUT4   DD UNIT=SYSDA,SPACE=(CYL,(5,1))\n//SYSIN    DD *\n COPY I=IN1,O=OUT1\n COPY I=IN2,O=OUT2\n COPY I=IN3,O=OUT3\n/*\n./ ADD NAME=IEBCOPYT 0103-80182-80193-1753-00048-00043-00047-$SYS13  00\n//IEBCOPYT JOB (2000,S010),WENZEL,CLASS=Z\n/*JOBPARM Q=F,I\n//STEP1    EXEC PGM=IEBCOPY,REGION=1024K\n//SYSPRINT DD SYSOUT=*\n//IN1      DD DISP=SHR,DSN=SYS4.WYLTSO.JUN80.ASM\n//IN2      DD DISP=SHR,DSN=SYS4.WYLTSO.JUN80.CNTL\n//IN3      DD DISP=SHR,DSN=SYS4.WYLTSO.JUN80.DOCLIB\n//IN4      DD DISP=SHR,DSN=SYS4.WYLTSO.JUN80.LOAD\n//IN5      DD DISP=SHR,DSN=SYS4.WYLTSO.JUN80.MACLIB0\n//IN6      DD DISP=SHR,DSN=SYS4.WYLTSO.JUN80.MACLIB\n//IN7      DD DISP=SHR,DSN=SYS4.WYLTSO.JUN80.OBJ\n//IN8      DD DISP=SHR,DSN=SYS4.WYLTSO.JUN80.HELP\n//OUT1     DD DISP=(SHR,PASS),DSN=ASM,\n//         VOL=SER=WENZEL,\n//         UNIT=TAPE,LABEL=(1,NL,EXPDT=98000)\n//OUT2     DD DISP=(SHR,PASS),DSN=CNTL,\n//         VOL=SER=WENZEL,\n//         UNIT=TAPE,LABEL=(2,NL,EXPDT=98000)\n//OUT3     DD DISP=(SHR,PASS),DSN=DOCLIB,\n//         VOL=SER=WENZEL,\n//         UNIT=TAPE,LABEL=(3,NL,EXPDT=98000)\n//OUT4     DD DISP=(SHR,PASS),DSN=LOAD,\n//         VOL=SER=WENZEL,\n//         UNIT=TAPE,LABEL=(4,NL,EXPDT=98000)\n//OUT5     DD DISP=(SHR,PASS),DSN=MACLIB0,\n//         VOL=SER=WENZEL,\n//         UNIT=TAPE,LABEL=(5,NL,EXPDT=98000)\n//OUT6     DD DISP=(SHR,PASS),DSN=MACLIB,\n//         VOL=SER=WENZEL,\n//         UNIT=TAPE,LABEL=(6,NL,EXPDT=98000)\n//OUT7     DD DISP=(SHR,PASS),DSN=OBJ,\n//         VOL=SER=WENZEL,\n//         UNIT=TAPE,LABEL=(7,NL,EXPDT=98000)\n//OUT8     DD DISP=(SHR,PASS),DSN=HELP,\n//         VOL=SER=WENZEL,\n//         UNIT=TAPE,LABEL=(8,NL,EXPDT=98000)\n//SYSUT3   DD UNIT=SYSDA,SPACE=(CYL,(5,1))\n//SYSUT4   DD UNIT=SYSDA,SPACE=(CYL,(5,1))\n//SYSIN    DD *\n COPY I=IN1,O=OUT1\n COPY I=IN2,O=OUT2\n COPY I=IN3,O=OUT3\n COPY I=IN4,O=OUT4\n COPY I=IN5,O=OUT5\n COPY I=IN6,O=OUT6\n COPY I=IN7,O=OUT7\n COPY I=IN8,O=OUT8\n/*\n./ ADD NAME=INFO     0100-80193-80193-1719-00043-00043-00000-$SYS13  00\nTO RUN WYLBUR UNDER TSO:\n\n1)  INSTALL INTO CMDLIB IN WHICH CASE WYLBUR BECOMES A COMMAND PROCESSOR\n2)  INSTALL IN SOME LOADLIB AND: CALL '..DSN..(WYLBUR)'\n\nFOR BEST PERFORMANCE, WYLBUR (JUST THE MAIN MODULE - WYLBUR) SHOULD\nBE IN THE TIMESHARE LINK PACK AREA.  THE SWAP LOAD IS THEN AROUND\n30K OR SO.\n\n3)  WHEN WYLBUR IS INVOKED, IT EXPECTS A PAGEFILE TO BE ALLOCATED\n    (AND FORMATTED).  THE PAGEFILE DDNAME IS \"PAGE0\".  MULTIPLE\n    PAGEFILES (OR MULTI-EXTENTS) ARE NOT SUPPORTED.\n\n    IF THE PAGEFILE IS NOT PROPERLY FORMATTED, WYLBUR WILL FORMAT IT.\n\n4)  DDNAME CONVENTIONS.  IN ORDER FOR WYLBUR TO ACCESS A PACK THE\n    PACK MUST BE ALLOCATED TO WYLBUR.\n\n    DDNAMES BEGINING WITH:\n      IO... -  INPUT/OUTPUT VOLUMES (SAVES AND USES ALLOWED)\n      IN... -  INPUT ONLY VOLUMES (ONLY USES PERMITTED)\n\n5)  IF A PACK IS NOT PREALLOCATED, WYLBUR WILL ATTEMPT TO USE A\n    DD DYNAM FOR THE PACK.  WYLBUR ATTEMPTS TO ALLOCATE A\n    DATASET WITH DSN=WYL.CU.CTR.VTOC,VOL=SER=......,DISP=SHR.\n\n    THUS ZERO TRACK DATASETS SHOULD BE PRE-ALLOCATED ON PUBLIC\n    VOLUMES.  TO CHANGE THE DEFAULT DSNAME LOOK AT MODULE: PDIO\n    AND WYLWA.\n\n6)  THERE ARE TWO TYPES OF WYLBUR USERS.  PRIVILIGED AND NORMAL.\n    PRIVILEGED USERS CAN MODIFY DATASETS NOT BELONGING TO THEM.\n\n7)  NEW COMMANDS:\n      TO <USERID> ...MSG.\n          IF <USERID> IS LOGGED ON HE WILL RECEIVE THE 'MSG'.\n      TSO\n          ATTACHES THE TMP (IKJEFT01).\n          YOU CAN TYPE IN ANY TSO COMMANDS.  WHEN DONE TYPE IN: LOGOFF\n          DO NOT HIT ATTENTION WHEN YOU ARE AT THIS LEVEL OF TSO.\n          YOU WILL THEN RETURN TO WYLBUR.\n      SHOW USERS\n          GIVES A LIST OF CURRENT TSO USERS.\n./ ADD NAME=LINIT    0102-80113-80113-1659-00091-00108-00000-$SYS13  00\n INCLUDE SYSLIB(INIT)\n INCLUDE SYSLIB(PEDP)\n INCLUDE SYSLIB(PGOP)\n INCLUDE SYSLIB(PSGT)\n INCLUDE SYSLIB(PTSO)\n OVERLAY ONE\n INSERT P001\n OVERLAY ONE\n INSERT P002\n OVERLAY ONE\n INSERT P003\n OVERLAY ONE\n INSERT P004\n OVERLAY ONE\n INSERT P005\n OVERLAY ONE\n INSERT P006\n OVERLAY ONE\n INSERT P007\n OVERLAY ONE\n INSERT P008\n OVERLAY ONE\n INSERT P009\n OVERLAY ONE\n INSERT P010\n OVERLAY ONE\n INSERT P011\n OVERLAY ONE\n INSERT P012\n OVERLAY ONE\n INSERT P013\n OVERLAY ONE\n INSERT P014\n OVERLAY ONE\n INSERT P015\n OVERLAY ONE\n INSERT P016\n OVERLAY ONE\n INSERT P017\n OVERLAY ONE\n INSERT P018\n OVERLAY ONE\n INSERT P019\n OVERLAY ONE\n INSERT P020\n OVERLAY ONE\n INSERT P021\n OVERLAY ONE\n INSERT P022\n OVERLAY ONE\n INSERT P023\n OVERLAY ONE\n INSERT P024\n OVERLAY ONE\n INSERT P025\n OVERLAY ONE\n INSERT P026\n OVERLAY ONE\n INSERT P027\n OVERLAY ONE\n INSERT P028\n OVERLAY ONE\n INSERT P029\n OVERLAY ONE\n INSERT P030\n OVERLAY ONE\n INSERT P031\n OVERLAY ONE\n INSERT P032\n OVERLAY ONE\n INSERT P033\n OVERLAY ONE\n INSERT P034\n OVERLAY ONE\n INSERT P035\n OVERLAY ONE\n INSERT P036\n OVERLAY ONE\n INSERT P037\n OVERLAY ONE\n INSERT P038\n OVERLAY ONE\n INSERT P039\n OVERLAY ONE\n INSERT P040\n OVERLAY ONE\n INSERT P041\n OVERLAY ONE\n ENTRY INITWYL\n SETCODE AC(1)\n NAME WYLINIT(R)\n./ ADD NAME=LWYLBUR  0100-80113-80113-1516-00019-00019-00000-$SYS13  00\n INCLUDE SYSLIB(PWYL)\n INCLUDE SYSLIB(PDIO)\n INCLUDE SYSLIB(PAGER)\n INCLUDE SYSLIB(WTR)\n INCLUDE SYSLIB(PROC)\n INCLUDE SYSLIB(PSCN)\n INCLUDE SYSLIB(PDOS)\n INCLUDE SYSLIB(CVREAL)\n INCLUDE SYSLIB(CR)\n INCLUDE SYSLIB(PEDS)\n INCLUDE SYSLIB(PGOS)\n INCLUDE SYSLIB(BEXE)\n INCLUDE SYSLIB(BLPR)\n INCLUDE SYSLIB(PUTB)\n INCLUDE SYSLIB(PPRT)\n ENTRY WYLTSO\n ALIAS W\n SETCODE AC(1)\n NAME WYLBUR(R)\n./ ADD NAME=LWYLWA   0100-80113-80113-1516-00004-00004-00000-$SYS13  00\n INCLUDE SYSLIB(WYLWA)\n ENTRY WDIOWA\n SETCODE AC(1)\n NAME WYLWA(R)\n./ ADD NAME=WASMPDS  0102-80113-80170-1257-00006-00006-00004-$SYS13  00\nPROC 1 NAME OPTION() PRE(SYS4.WYLTSO)\nASMX '&PRE..ASM(&NAME.)' &OPTION NOMAC -\n                       LIB('SYS1.MACLIB' -\n                           '&PRE..MACLIB') -\n                      LOAD('&PRE..OBJ(&NAME.)')\nEND\n./ ADD NAME=WYLASM   0101-80170-80193-1718-00008-00005-00000-$SYS13  00\nPROC 1 NAME OPTION() PRE(SYS4.WYLTSO.JUN80)\nASMX '&PRE..ASM(&NAME.)' &OPTION NOMAC -\n                      LIB('&PRE..MACLIB0' -\n                          '&PRE..MACLIB'  -\n                          'SYS1.MACLIB'   -\n                          'SYS1.AMODGEN') -\n                      LOAD('&PRE..OBJ(&NAME.)')\nEND\n./ ADD NAME=WYLLINK  0103-80113-80193-1718-00006-00006-00000-$SYS13  00\nPROC 2 MEMBER OUT PRE(SYS4.WYLTSO.JUN80)\nALLOC F(SYSUT1) SP(5,5) CYL REUSE\nALLOC DA(&OUT) SHR F(SYSLMOD) REUSE\nALLOC DA('&PRE..CNTL(L&MEMBER.)') SHR F(SYSLIN) REUSE\nALLOC DA('&PRE..OBJ') SHR F(SYSLIB) REUSE\n# IEWL 'NCAL,LIST,OVLY,TEST,LET,XREF,MAP,SIZE=(128K,32K)'\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DOCLIB": {"ttr": 12551, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00$\\x01\\x19#\\x0f\\x01\\x19#\\x0f\\x14A?\\xd5?\\xd5\\x00\\x00\\xe6\\xe8\\xd3\\xc2\\xe4\\xd9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2019-08-18T00:00:00", "modifydate": "2019-08-18T14:41:24", "lines": 16341, "newlines": 16341, "modlines": 0, "user": "WYLBUR"}, "text": "./ ADD NAME=GUIDE    0102-80177-80178-1121-02276-02387-02276-$SYS11  00\n1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n                     WYLBUR  LEARNER'S  GUIDE\n\n\n\n\n\n\n\n                            ITEL CORP\n\n\n                           JUNE, 1980\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n                   The  Itel  Data Processing Center\n                   San Francisco, California 94401\nm                                                Page  2\n\n\n\n       This Learner's Guide is designed for newcomers to Wylbur\n who have no knowledge of computers.  The Guide describes what a\n terminal is, how to log on to a terminal, and how to use the\n more frequently used Wylbur commands in their simplest forms.\n\n       A supplement to this Guide is the Wylbur Reference\n Manual, a manual designed for experienced Wylbur users.  The\n Wylbur Reference Manual is arranged alphabetically by topic,\n with each topic described first in a summary fashion and then\n in more detail.\n\n\n\n      Copies of the Wylbur Learner's Guide and the Wylbur Reference\n Manual may be obtained from the Data Processing Center #55\n Francisco St., San Francisco, Ca.\n\n\n\n       This manual violates a rule of grammar in regard to quote\n marks.  Grammar dictates that quote marks include the rightmost\n comma or a period.  For technical clarity the comma or period\n will be placed outside of the ending quote in this publication.\n1                                                Page  3\n\n                    TABLE OF CONTENTS\n\n\n\n Beginners' session #1 ..................................4\n     What a terminal is .................................4\n     How to log on to a terminal at Itel ................5\n     Wylbur's language ..................................6\n         Carriage return key ............................7\n         Backspace key ..................................7\n         Entering commands in upper and lower case ......7\n     Collect and command mode ...........................7\n     Typing your letter .................................9\n     Changing collect and command mode .................11\n         Using the interrupt button to switch modes ....11\n         Using the interrupt button to erase lines .....12\n     A review  .........................................13\n     Listing the rough draft of your letter ............14\n         The SET UPLOW command .........................15\n         The SET LENGTH command ........................18\n     Saving your letter ................................19\n     Logging off Wylbur ................................21\n\n Beginner's session #2 .................................22\n     Logging on ........................................22\n     Retrieving the letter .............................22\n         What a data set is ............................22\n         Your working data set .........................23\n     Listing your data set .............................24\n     The DELETE command ................................24\n     The REPLACE command ...............................25\n     The INSERT command ................................26\n     The CHANGE command ................................26\n     The range of a command ............................27\n     The MODIFY command ................................28\n     A review ..........................................31\n\n     The COPY command ..................................32\n     The MOVE command ..................................34\n     The COLLECT command ...............................35\n     The NUMBER command ................................35\n     The ALIGN command .................................36\n     The JUSTIFY command ...............................38\n\n     System failure. Wylbur crashes.....................38\n     Saving a backup data set ..........................39\n     Abbreviations .....................................40\n     Listing your data set offline on a\n                     high speed printer ................40\n     Saving your data set...............................41\n     Logging off Wylbur ................................42\n     How it all goes together ..........................43\n     Final review ......................................44\n1                                                Page  4\n\n\n\n BEGINNER'S SESSION #1\n+__________ _______ __\n\n\n       Wylbur is the name of the system that allows you to\n communicate with the computer.  Wylbur listens to what you say\n and directs the computer to do what you want.  Wylbur is fast\n and efficient and allows you to do a great deal of work in a\n small amount of time.\n\n       In the beginning you'll use Wylbur to type a letter or a\n memorandum, correct your typing mistakes, and print out a clean\n copy of what you've typed.  As you gain experience with Wylbur,\n you'll use it for more than letters and memorandums.  You'll\n discover you can store a large amount of information in Wylbur\n and come back months later and retrieve that information.  You\n can also execute a computer program through Wylbur and have the\n output printed at your terminal as well as on a high speed\n printer in the computer room.  In effect, you can use all of\n the facilities of the computer while you're sitting at a Wylbur\n terminal.\n\n       To talk to Wylbur you use a language resembling English.\n Some of Wylbur's commands, for example, are LIST, DELETE, SAVE,\n and REPLACE.  Other words in Wylbur's language will be new to\n you, such as LOGON, DDNAME, and LRECL.  You'll need to learn\n these new words, as well as Wylbur's grammar, which is rigid\n and which resembles English grammar only slightly.  You won't\n have to learn all of it at once though.  You can learn enough\n to do your work, and later when you're interested, you can\n learn more.  The purpose of this learning guide is to provide\n you with the basic concepts and commands used by Wylbur.  Once\n you learn the material in this learning guide, you'll be able\n to use Wylbur quite effectively.\n\n       You may have wondered if you can get into trouble using\n Wylbur.  Can you hurt the computer?  Can you bring Itel to a\n halt?  Not at all.  You'll discover Wylbur keeps you in check.\n You can do a lot of work, and you can destroy your work, but\n you can't destroy anyone else's work.  And you can't disrupt\n the computer in any way.\n\n\n WHAT A TERMINAL IS\n+____ _ ________ __\n\n\n      A terminal is a device like a typewriter that is connected\n by a wire to the computer.  Some terminals are merely modified\n typewriters; other terminals have TV screens and fancy\n keyboards with many strange abbreviatons on them.  Whatever the\n case, when you use a terminal, you use it in the same manner as\n you would a typewriter.  You type in a line as you would on a\n1                                                Page  5\n\n\n typewriter, and at the end of the line you press the carriage\n return key just as you would on a typewriter.  The one\n difference between a terminal and a typewriter is that a\n terminal will talk back to you.  That is, when you type in a\n command to Wylbur and press the carriage return key, Wylbur\n will type something back to you.  In effect, you carry on a\n conversation with Wylbur using a terminal.\n\n       Itel has two types of terminals.  The more common type\n has a TV screen.  This type of terminal is fast and silent, but\n it lacks the ability to print anything on paper.  The other\n type of terminal at Itel resembles a typewriter in that it has\n paper in it.  A typewriter terminal is slower than the others,\n but it has the advantage of being able to print on paper while\n you're sitting at the terminal.  More important to you as a\n beginner, a typewriter terminal prints on paper the commands\n you enter as well as Wylbur's responses.  If you make a mistake\n and get into trouble, you can take the printout to some one who\n is more experienced and find out what to do.  For that reason,\n we suggest you learn Wylbur using a terminal that has paper in\n it.  The instructions in this learning guide will assume you\n are using a terminal that prints on paper.\n\n\n HOW TO LOG ON TO A TERMINAL AT ITEL\n+___ __ ___ __ __ _ ________ __ ____\n\n\n       To use Wylbur, you must let Wylbur know you are there.\n The process of introducing yourself to Wylbur is called a\n 'logon'.  When you log on to Wylbur, you give Wylbur certain\n identifying information about yourself.  Once you give Wylbur\n this information, you are considered to be 'logged on' and then\n you can tell Wylbur what to do.\n\n1                                                Page  6\n\n\n\n\n       The printout which you'll see at your terminal (excluding\n the X's and M's printed behind your account number and keyword)\n is:\n\n\n\n       If you can't seem to log on to a terminal, don't be\n concerned.  Some one may have turned off the power or\n misadjusted one of the special buttons or switches on the\n terminal.  If you can't get the terminal to work, ask some one\n who is knowledgeable to look at it.  If neither of you can get\n it to work, give up.  Call ext. XXX and report the terminal as\n being broken.\n If you're still in\n trouble, ask one of the computer operators to look at the\n terminal.  If that doesn't work, go home and go to bed.\n\n\n WYLBUR'S LANGUAGE\n+________ ________\n\n\n      As we mentioned before, Wylbur has its own language and\n grammar.  To communicate with Wylbur you must learn a minimum\n of Wylbur's language and grammar.  Some of the punctuation of\n1                                                Page  7\n\n\n Wylbur's grammar is the special keys on the keyboard in front\n of you.  For example, when you logged on above, you typed your\n employe number and then you pressed the carriage return key.\n The carriage return key acts as a period at the end of a\n sentence.  It tells Wylbur that you have completed whatever you\n intend to type in for that line.  After you press the carriage\n return key, Wylbur looks at everything you have typed on\n that line and does as you command.\n\n       Another key you'll use frequently is the backspace key.\n The backspace key not only backspaces the carriage, but also\n erases, inside the computer's memory, whatever you backspaced\n over.  So if you type a word incorrectly, backspace over it and\n retype it.  The word will look messy on the terminal printout\n because of the overtyping, but it will enter Wylbur correctly.\n\n       The repeat key, as it name states, enables you to repeat\n a character or a blank.  For example, press the space bar, hold\n it down, and then press the repeat key to space automatically\n across the page.\n\n       One feature of Wylbur's grammar has to do with upper and\n lower case characters.  Wylbur responds to commands typed in\n both upper and lower case characters.  When you type a command\n for Wylbur, you can type it in lower case or in upper case and\n get the same results.  In these learning exercises the commands\n are printed in UPPER CASE in the text to make them stand out,\n and in lower case in the terminal printout examples because\n that's the way they would normally appear at your terminal.\n\n      The tab keys on the terminals are used as they are on a\n typewriter, but setting the tabs can be difficult, so the use\n of tabs will not be covered in these learning exercises.  When\n you feel ready to learn about setting tabs, look up the topic,\n TABS, in the Wylbur Reference Manual.\n\n      If you look carefully at the keyboard on your terminal,\n you'll see that there is both the letter 'o' and the number\n '0', the letter 'l' and the number '1'.  You should always type\n the letter 'o' when you want a letter, and the number '0' when\n you want a number, and similiarly with 'l' and '1'.   Wylbur is\n rather fussy about these distinctions.\n\n\n\n COLLECT AND COMMAND MODES\n+_______ ___ _______ _____\n\n\n       One important feature of Wylbur's grammar is the\n difference between the 'command mode' and the 'collect mode'.\n You use the command mode when you tell Wylbur to do something;\n you use the collect mode when you want Wylbur to save what you\n are typing.\n1                                                Page  8\n\n\n       The reason Wylbur needs a collect mode and a command mode\n is that Wylbur needs to know when you are commanding Wylbur\n to do something and when you are merely typing in things you\n want to save.  Suppose for example, you wanted to type a\n sentence in a letter that began with the word 'list'.  One of\n Wylbur's commands happens to be the 'LIST' command.  When\n Wylbur finds the word 'list', Wylbur tries to list something.\n That's not what you want in this instance.  You're trying to\n type a letter.  So how do you tell Wylbur to keep its hands off\n your letter?  You 'enter' the collect mode.  You do this by\n typing in the word 'COLLECT' in response to Wylbur's prompt of\n 'COMMAND ?'.  When you're in the collect mode, Wylbur doesn't\n examine what you're typing.  Wylbur merely stores it away for\n you.\n\n       As an example, suppose you wanted to type a letter on\n Wylbur.  The first thing you would do (after logon) is enter\n the collect mode.  If you remember from above, the printed\n output at your terminal after logon looked like this:\n\n\n      You can now enter the collect mode by typing the word\n 'COLLECT'.  Wylbur will respond by printing a '1.' on the next\n line.  Your terminal printout looks like this:\n\n                    COMMAND ? collect\n                       1.   ?\n\n\n       You are now in the collect mode and you can begin to type\n your letter.  The '1.' that Wylbur typed means that Wylbur is\n ready to 'collect' line number 1.  Wylbur will not scan the\n information you type, looking for commands.  Wylbur knows you\n are typing a letter or other text.\n1                                                Page  9\n\n\n TYPING YOUR LETTER\n+______ ____ ______\n\n\n       Suppose the letter you want to type looks like this:\n\n          Dear Fred,\n\n               As I informed you over the phone on\n          Tuesday, the last batch of skyhooks you\n          sent us were defective.  At last count 4\n          astronauts dropped into the Pacific.  Until\n          your quality control department gets on\n          the ball, we'll have to order our skyhooks\n          from Acme Inc.\n\n                              Still your friend,\n\n\n                              Josephine Blink\n\n\n      Let's start with the 'Dear Fred,'.  Type in 'Dear Fred,'\n after the number '1.'.  Type it  as you would on an ordinary\n typewriter.  Then press the carriage return key.  Your\n terminal printout looks like this:\n\n\n                    COMMAND ? collect\n                       1.   ? Dear Fred,\n                       2.   ?\n\n      Wylbur saved the first line you typed, and now Wylbur\n is ready to collect line number 2.   When you pressed carriage\n return, nothing printed, but for the sake of clarity, we'll use\n the expression '(cr)' to indicate a carriage return.  In the\n (cr) notation, the above printout would read:\n\n                    COMMAND ? collect(cr)\n                       1.   ? Dear Fred,(cr)\n                       2.   ?\n1                                                Page 10\n\n\n\n      You are now ready to type line 2.  Looking at the example,\n you can see that the next line of the letter you intend to type\n is blank.  Easy enough.  Just press carriage return.  That\n gives you one blank line.  Your terminal printout looks like\n this:\n\n                    COMMAND ? collect(cr)\n                       1.   ? Dear Fred,(cr)\n                       2.   ? (cr)\n                       3.   ?\n\n      In a similiar fashion, you proceed to type in the entire\n letter.  Assuming you are a poor typist (or maybe a good typist\n but somewhat rattled at being on Wylbur for the first time)\n your final effort might look like this:\n\n                COMMAND ? collect(cr)\n         1.   ? Dear Fred,(cr)\n         2.   ? (cr)\n         3.   ? As I informedd you on the phone over(cr)\n         4.   ? Tuesday the last batch for Skyhooks you(cr)\n         5.   ?  sent us wdere defective.  At last count(cr)\n         6.   ? 40 astronauts dropped into the Atlantic.(cr)\n         7.   ? Untily your quality control departments(cr)\n         8.   ? gets on the ball, we'll have to order our(cr)\n         9.   ? gets on the ball, we'll have to order our(cr)\n        10.   ? skyhooks from Acme INc.(cr)\n        11.   ?      Still your friend,(cr)\n        12.   ? (cr)\n        13.   ?      Josephine Blink(cr)\n        14.   ?\n\n      You've made a lot of mistakes, and you've typed in one\n line twice, but all in all you've managed to create a rough\n draft of your letter.\n\n      Everything you've typed is saved in a special area\n reserved for you (at logon) inside Wylbur.  You'll learn more\n about this special area later.\n1                                                Page 11\n\n\n CHANGING FROM COLLECT TO COMMAND MODE AND BACK AGAIN\n+________ ____ _______ __ _______ ____ ___ ____ _____\n\n\n       Notice in the above example that you're still in the\n collect mode.  The way you know you're in the collect mode is\n by the line number '14.  ?'.  That's Wylbur's prompt for the\n next line.  Whenever Wylbur prompts you with a line number\n you're in the collect mode, and Wylbur expects you to type in\n another line.  Wylbur would be happy collecting information\n from you forever.  It's up to you to tell Wylbur that you are\n through typing your letter.  You do that by entering the\n 'command mode'.\n\n       The way you enter the command mode is to press the key\n marked 'INT'.  This key is called the interrupt or attention\n key, and it occupies a central position in Wylbur's grammar.\n Whenever Wylbur prompts you with a line number, for example\n '10. ?', Wylbur is ready to change modes.  If you press the\n interrupt key in response to Wylbur's prompt, Wylbur will\n change back to the command mode.  In our example, you would\n press the interrupt button after '14.  ?' and Wylbur would\n print out 3 asterisks on that line, and then on the next line\n print 'COMMAND ?' The last part of your printout looks like\n this:\n\n            10.   ? skyhooks from Acme INc.(cr)\n            11.   ?      Still your friend,(cr)\n            12.   ? (cr)\n            13.   ?      Josephine Blink(cr)\n            14.   ? ***\n          COMMAND ?\n\n       When Wylbur prompts with 'COMMAND ?' you are in the\n command mode, and you can give Wylbur whatever command you\n like.  Suppose though, having successfully gotten into the\n command mode, you decide that you want to add a postscript to\n your letter.  This means you have to get back into the collect\n mode and collect more lines of your letter.  Well, you could\n enter the 'collect' command as you did above by typing in\n 'COLLECT'.  Your printout would look like this:\n\n            10.   ? skyhooks from Acme INc.(cr)\n            11.   ?      Still your friend,(cr)\n            12.   ? (cr)\n            13.   ?      Josephine Blink(cr)\n            14.   ? ***\n          COMMAND ? collect\n            14.   ?\n\n      You've probably noticed one thing: when Wylbur goes back\n to the collect mode, Wylbur remembers where you were before and\n then prompts you with the same line number.  That's rather\n handy, to say the least.\n1                                                Page 12\n\n\n      Another thing: the interrupt button you pressed to switch\n to the command mode, works equally well in both directions.\n That is, you can press the interrupt button to get into the\n collect mode at the point where Wylbur types 'COMMAND ?'.  The\n interrupt button  works exactly the same as if you had typed in\n the command, 'COLLECT'.   Above, for example, where you typed\n 'COLLECT', suppose you had pressed the interrupt button.  Your\n terminal printout would have looked like this:\n\n\n            10.   ? skyhooks from Acme INc.(cr)\n            11.   ?      Still your friend,(cr)\n            12.   ? (cr)\n            13.   ?      Josephine Blink(cr)\n            14.   ? ***\n          COMMAND ? ***\n            14.   ?\n\n      In either case, you are in the collect mode now and you\n can type in your postscript.   For example, (and we'll leave\n off the (cr) notation now that you're getting to be a pro):\n\n            10.   ? skyhooks from Acme INc.\n            11.   ?      Still your friend,\n            12.   ?\n            13.   ?      Josephine Blink\n            14.   ? ***\n          COMMAND ? ***\n            14.   ?\n            15.   ? P.S.  HOw could you do this to me!\n            16.   ?\n\n       Having typed in your postscript, you can press the\n interrupt key and switch from the collect mode to the command\n mode.  You want to do this because you've finished your letter,\n and you want to use Wylbur commands to correct some of the\n mistakes you made.\n\n       Before we discuss the command mode and some of the more\n common Wylbur commands, it would be best to let you know about\n another use of the interrrupt key.  Besides using the\n interrupt key to switch modes, you can use it as a kind of an\n eraser.  Suppose you had typed in part of a line and then\n noticed you typed in the wrong words.  Since you are midway\n through the line, you may press the interrupt key (but not the\n carriage return key also) and Wylbur will discard everything in\n that line and let you start that line over again.  This works\n in both the collect and command mode.  For example, suppose\n when you were typing the postcript above, your fingers got on\n1                                                Page 13\n\n\n the wrong keys and you typed in garbage.  Toward the end of the\n line you glanced up, saw your mistake, and pressed the\n interrupt key to erase what you had typed.  Wylbur prompted you\n with the line number again, and you typed in the line\n correctly.  Your terminal printout looks like this:\n\n\n            10.   ? skyhooks from Acme INc.\n            11.   ?      Still your friend,\n            12.   ?\n            13.   ?      Josephine Blink\n            14.   ? ***\n          COMMAND ? ***\n            14.   ?\n            15.   ? O.S. Giw ciykd tiy di tgus ti***\n            15.   ? P.S.  HOw could you do this to me!\n            16.   ? ***\n          COMMAND ?\n\n      One last thing: if you log on to Wylbur and then walk away\n from your terminal, Wylbur will wait a while, and then ask you\n 'ARE YOU STILL THERE?'.  Eventually Wylbur will log you off.\n Your output will be saved and restored ('RECOVERY COMPLETED')\n when you log on next.  It's best to avoid this situation by\n 'logging off' when you expect to be away from the terminal for\n a long time.  You'll learn about 'logging off' later in this\n session.\n\n\n\n\n A REVIEW OF WHAT YOU'VE DONE SO FAR\n+_ ______ __ ____ ______ ____ __ ___\n\n\n      In the beginning, you logged on using your employe number,\n account number, and keyword.  After you logged on, Wylbur\n placed you in the command mode, prompting you with 'COMMAND ?'.\n You wanted to type in a new letter, so you entered the collect\n mode by typing in the word, 'COLLECT'.   Wylbur responded by\n prompting you with the first line number, '1.   ?'.   You then\n typed in your letter, ending each line with a carriage return.\n When you were finished, you switched back to the command mode\n by pressing the interrupt key.  Besides using the interrupt key\n to switch modes you also used it to erase a line you typed\n poorly so you could type the line in again.   Finally you\n pressed the interrupt key again and ended up in the command\n mode.\n\n      The most important thing to remember so far is the\n difference between the command and the collect mode and the use\n of the interrupt key.  If you press the interrupt key\n1                                                Page 14\n\n\n immediately after a prompt (immediately after a line number\n such as '15.  ?' or immediately after 'COMMAND ?') you are\n asking Wylbur to switch modes.  If you type in something\n and then press the interrupt key, you are asking Wylbur\n to erase what you typed on that line and let you try again.\n\n      Now that you've learned the basics of the collect mode,\n let's find out about the command mode.\n\n\n LISTING YOUR LETTER\n+_______ ____ ______\n\n\n       Having typed in your letter, you probably want to see what\n it looks like under Wylbur.  You can do this with the LIST\n command.  Whenever Wylbur prompts with the word 'COMMAND ?',\n you can reply 'LIST' and Wylbur will list everything it's saved\n for you.  Continuing our example, if you typed 'LIST' and then\n a carriage return, Wylbur would respond by printing out your\n letter.  Your command and Wylbur's response looks like this:\n\n          COMMAND ? list\n             1.     DEAR FRED,\n             2.\n             3.     AS I INFORMEDD YOU ON THE PHONE OVER\n             4.     TUESDAY THE LAST BATCH FOR SKYHOOKS YOU\n             5.      SENT US WDERE DEFECTIVE,  AT LAST COUNT\n             6.     40 ASTRONAUTS DROPPED INTO THE ATLANTIC.\n             7.     UNTILY YOUR QUALITY CONTROL DEPARTMENTS\n             8.     GETS ON THE BALL, WE'LL HAVE TO ORDER OUR\n             9.     GETS ON THE BALL, WE'LL HAVE TO ORDER OUR\n            10.     SKYHOOKS FROM ACME INC.\n            11.          STILL YOUR FRIEND,\n            12.\n            13.          JOSEPHINE BLINK\n            14.\n            15.     P.S.  HOW COULD YOU DO THIS TO ME!\n          COMMAND ?\n\n\n      The first thing that strikes your eye is the upper case\n characters.  You typed the letter in both upper case and lower\n case characters.  So what happened?\n\n       What happened is that you ran afoul of one of Wylbur's\n default options.  When you logged on to Wylbur, you\n automatically got a number of default options.  These options\n are a set of values that Wylbur always assigns to you.  The\n option you crashed into here is the one concerned with upper\n and lower case characters.  Wylbur's default option for upper\n1                                                Page 15\n\n\n and lower case characters is to convert them all to upper case.\n The reason Wylbur does this is that most of the work done on\n the computer is done in upper case.  Job control cards and\n computer program cards are usually in upper case.  And since\n Wylbur was designed by computer programmers, the default option\n is upper case.  A clear example of programmer chauvinism.\n\n      The solution to your problem is simple: when you log on to\n Wylbur, and Wylbur types in 'COMMAND ?', you must tell Wylbur\n you want to use both upper and lower case characters.  You do\n this with the 'SET UPLOW' command.   Going back to the\n beginning when you logged on, your printout would have looked\n like this:\n\n                    COMMAND ? set uplow\n                    COMMAND ? collect\n                       1.   ? Dear Fred,\n                       2.   ?\n\n      You may wonder now why we didn't just tell you to SET\n UPLOW when you logged on.  You would have typed your letter\n correctly, and we wouldn't have had to go through this\n explanation.  The point is, if you forget to SET UPLOW,\n the consequences are serious: you may be in for a great deal of\n extra work.\n\n      In our example then, you will want to type your letter\n again.  First you must get rid of what you have already typed.\n You do this with the CLEAR TEXT command.  The CLEAR TEXT\n command wipes out everything you've typed.  After you issue the\n CLEAR TEXT command, you issue the COLLECT command and then type\n your letter.  The terminal printout looks like this:\n\n          COMMAND ? clear text\n          COMMAND ? set uplow\n          COMMAND ? collect\n             1.   ?\n\n       You proceed now to type the letter exactly as you did\n before.  This time when you execute the LIST command, your\n printout looks like this:\n1                                                Page 16\n\n\n          COMMAND ? list\n             1.     Dear Fred,\n             2.\n             3.     As I informedd you on the phone over\n             4.     Tuesday the last batch for Skyhooks you\n             5.      sent us wdere defective.  At last count\n             6.     40 astronauts dropped into the Atlantic.\n             7.     Untily your quality control departments\n             8.     gets on the ball, we'll have to order our\n             9.     gets on the ball, we'll have to order our\n            10.     skyhooks from Acme INc.\n            11.          Still your friend,\n            12.\n            13.          Josephine Blink\n            14.\n            15.     P.S.  HOw could you do this to me!\n          COMMAND ?\n\n\n       Wylbur has now saved your letter in both upper and lower\n case.  And when you asked Wylbur to list it, Wylbur listed it\n exactly as you typed it.\n\n      The LIST command has other variations.  One of these\n variations allows you to list a single line or several lines.\n The way you request which lines are to be listed is by\n specifying line numbers.  For example, if you wanted to list\n line 3 of your letter and then list lines 10-13, you would\n enter 'LIST 3' and 'LIST 10/13'.  Your printout looks like\n this:\n\n\n          COMMAND ? list 3\n             3.     As I informedd you on the phone over\n          COMMAND ? list 10/13\n            10.     skyhooks from Acme INc.\n            11.          Still your friend,\n            12.\n            13.          Josephine Blink\n          COMMAND ?\n\n\n       Notice the '/' between the line numbers 10 and 13 in the\n LIST command.  The slash tells Wylbur you want to list lines 10\n to 13 inclusive.  If you leave out the slash, Wylbur will list\n lines 10 and 13 only.  There's another rule: there must be\n at least 1 blank between the word, LIST, and the line numbers.\n\n        To aid you in specifying line numbers Wylbur has some\n special vocabulary.  You can refer to the first line of your\n letter by the word 'FIRST', and the last line  by the word\n 'LAST'.  You can list your entire letter by entering any of\n these 3 commands:\n1                                                Page 17\n\n\n              COMMAND ?  list\n              COMMAND ?  list 1/15\n              COMMAND ?  list first/last\n\n      In the first form of the command you didn't specify a\n range, so Wylbur gave you the default,  which is also\n FIRST/LAST. In the second and third forms, you specified a\n range that covered all line numbers, so you also got the\n complete letter listed.\n\n      You can intermix 'FIRST' and 'LAST' with numbers.\n For example:\n\n          COMMAND ?  list first/5\n          COMMAND ?  list 6/last\n\n      There is another variation of the LIST command that you\n should be aware of.  The LIST command will list 24 lines of\n your letter or memorandum and then pause.  If you want to\n continue listing the rest of your letter, you must press\n carriage return.  Wylbur will then  list another 24 lines of\n your letter.  In our example, your letter is less than 24\n lines, so you didn't see any pauses.\n\n      When Wylbur pauses after listing 24 lines, you can\n continue the listing or enter any command you like.  At the\n point where Wylbur pauses, Wylbur is in the command mode and\n will accept either a carriage return (which tells Wylbur to\n continue) or a new command.  This is the only time you can\n enter a command without first having Wylbur prompt you with\n 'COMMAND ?'.\n\n      If you have a long letter and you don't want Wylbur to\n pause in the middle of printing it, you can use the PAGE\n parameter of the LIST command.  For example:\n\n          COMMAND ?  list page 0\n\n      That '0' is a zero.  It tells Wylbur not to pause when\n listing.  You can give Wylbur other values too.  For example,\n LIST PAGE 5 tells Wylbur to pause after listing every 5 lines.\n If you use the LIST command without specifying PAGE, you get\n the default of 24 lines, which is the same as entering, LIST\n PAGE 24.   If you specify line numbers as well as the PAGE\n option, specify the line numbers first:\n\n          COMMAND ?  list first/70 page 0\n\n      For practice you might type a letter that is longer than\n 24 lines and then list it using various values for the PAGE\n parameter.\n1                                                Page 18\n\n\n SETTING THE LINE LENGTH\n+_______ ___ ____ ______\n\n\n\n      In our example, the lines in your letter are all about 40\n characters long.  For a letter, lines of 40 or 50 characters\n might be appropriate.  For other material though, lines as long\n as 100 or 120 characters would be appropriate.  (Wylbur will\n let you type in lines as long as 133 characters.)  If you do\n type in a long line however, Wylbur will print out a warning\n note to you.  For example, suppose you typed the first two\n lines of your letter as one line.  Although we can't reproduce\n it on this page, your printout (and Wylbur's note) would appear\n somthing like this:\n\n    2.   ?\n    3.   As I informedd you on the phone over Tuesday the last ...\n LINE NUMBER  3. CONTAINS 76 CHARACTERS\n    4.   ?\n\n      Sometimes you want to be warned when you type in a long\n line, but usually you don't want those messages to appear.  You\n can avoid getting the messages by using the 'SET LENGTH'\n command.  The SET LENGTH command tells Wylbur the size of the\n longest line you expect to type.  In your letter, for example,\n you didn't expect to type a line longer than 45 characters.\n You could have used the SET LENGTH command if you wanted.  For\n example:\n\n                    COMMAND ? set uplow\n                    COMMAND ? set length 45\n                    COMMAND ? collect\n                       1.   ?\n\n      Since you were careful in typing your letter, you didn't\n type a line longer than 45 characters and you didn't get any\n messages of the form,  'LINE  nn  CONTAINS  xx  CHARACTERS'.\n But if you had gotten distracted and typed in long line, Wylbur\n would have reminded you, and you could have corrected it at\n that time.\n\n      The default line length that you get when you log on is 72\n characters.  If you intend to type lines longer than 72\n characters, you should use the SET LENGTH command.\n1                                                Page 19\n\n\n A REVIEW OF THE COMMANDS YOU HAVE USED\n+_ ______ __ ___ ________ ___ ____ ____\n\n\n      So far you have used four Wylbur commands.  The most\n important command was the COLLECT command.  The COLLECT command\n allowed you to enter the collect mode after you logged on.\n\n      Another command you used was the LIST command.  You used\n the LIST command to list all of your letter, and then used it\n to list just a few lines of your letter.\n\n      The other two commands you used were SET commands.  You\n used SET UPLOW to tell Wylbur you wanted to type upper and\n lower case characters.  And you used the SET LENGTH command to\n tell Wylbur the length of the longest line you expected to\n type.\n\n      At this point we recommend you get in the habit of using\n the SET UPLOW and SET LENGTH commands every time you log on\n (assuming you want upper and lower case information).  When you\n log on, you can follow this pattern:\n\n              COMMAND ? set uplow\n              COMMAND ? set length 80\n\n\n\n SAVING THE LETTER YOU HAVE TYPED\n+______ ___ ______ ___ ____ _____\n\n\n      When you logged on to Wylbur, Wylbur reserved a space for\n you inside the computer.  As you typed your letter, Wylbur\n placed the typed lines in that reserved space.  That space is\n yours as long as you are logged on to Wylbur, but once you\n 'log off' (that is, once you end the Wylbur session) you lose your\n special space.  So if you want to save the letter you typed,\n you'll have to tell Wylbur to save it.  You tell Wylbur to save\n your letter by using, appropriately enough, the SAVE command.\n\n      When you issue the SAVE command, you must tell Wylbur the\n name of what you are saving.  In your case, you might name your\n letter, 'LETTER'.  Or you might name it anything else.  There\n is a problem though: what if some one else has a letter named\n 'LETTER'.  How does Wylbur keep the names straight?\n1                                                Page 20\n\n\n      Wylbur keeps the names straight by giving you a special\n codeword made out of your employe number and account number.\n For example, if your employe number is z1234 and your account\n is 9999, then Wylbur creates a codeword for you that is\n 'Z.Z1234.A9999.'.  This code word will be added to whatever\n name you give your letter, and the result will be a unique name\n you can use for yourself.  (You don't have to worry about\n the code word.  Wylbur handles that automatically.)\n\n        You may want to call your letter  'LETTER' or 'LETTER1'.\n You are free to use any name you like as long as the name\n begins with an alphabetic character and is 8 characters or\n less long, made up of alphabetic characters and numbers only.\n (You can make names longer than 8 characters if you\n follow some special rules; see the section on Data Set Naming\n Conventions in the Wylbur Reference Manual.)  It's a good idea\n to name the things you save with a name that reminds you of\n what it is you saved.  For example, you just typed up a letter\n to 'Fred', so you might want to name that letter FLETTER or\n FREDLTR.  In two weeks when you've forgotten what you called\n this letter, you can have Wylbur list the names of everything\n you've saved, and when you see 'FLETTER' you'll remember it's\n the letter you typed to Fred.\n\n      Besides supplying a name for your letter, you must also\n tell Wylbur where you want to save it.   Wylbur saves\n information on mechanical devices resembling multi-platter\n record players.  These devices are called disk packs.  Each\n disk pack has an individual name.  The names of some of the\n more commonly used packs at Itel are USECTL, USER01, USER02,\n etc.  Usually some one will supply you with the name of a disk\n pack to use.  If you haven't been supplied with a disk pack\n name, you can call User Services at Ext. 7764, and some one\n will tell you which pack has the most room on it.  (When you\n get more knowledgeable, you can find out for yourself by\n reading $PUBLIC.SPACE.  Read about $PUBLIC.SPACE in the\n Wylbur Reference Manual.)  Although you can use any of\n several different disk packs, it's a good idea to keep\n everything you save on the same pack.  That way you'll have no\n trouble remembering where your information is.\n\n      Getting back to our example, let's suppose you are told to\n save your letter on the disk pack USER50.  You would then enter\n 'SAVE FLETTER ON USER50'.  Wylbur would save your letter and\n print out a message that it had been saved.  Your terminal\n printout looks like this:\n\n                    COMMAND ? save fletter on user50\n                    \"FLETTER\" SAVED ON USER50\n                    COMMAND ?\n\n      In this example Wylbur verified your letter was saved on\n USER50.  Wylbur might have printed an error message at this\n point.  If Wylbur does print an error message, you should find\n some one who is knowledgeable and ask them what to do.   Do not\n reply blindly to a message whose meaning is unclear.  It's\n possible to destroy something you typed in previously.\n1                                                Page 21\n\n\n      When Wylbur saves your letter on a disk pack, Wylbur\n merely writes a copy of it onto that disk pack.  The original\n copy of the letter still exists in your reserved space inside\n the computer, and it is this copy that you will see when you\n issue the LIST command.  Remember, if you do additional work on\n the letter in your reserved space, you will want to save it\n again when you are done.\n\n      You'll learn  more about the SAVE command in Learning\n Session #2.   In particular, you'll learn about the REPLACE\n option of the SAVE command (i.e., SAVE FLETTER REPLACE), which\n is the form of the save command you'll use after the first\n time.  For now, use the SAVE command as shown above.\n\n\n LOGGING OFF WYLBUR\n+_______ ___ ______\n\n\n       When you type in a short letter as you did today, you\n would normally correct your mistakes at the same time and\n produce a final error-free copy for your own use.   Since\n you're working on Wylbur for the first time, you're probably\n tired and want to quit for a while.  Easy enough.\n\n       The first thing you do when you want to terminate a\n Wylbur session is issue the SAVE command so whatever you typed\n will be saved permanently.  After that, you issue the LOGOFF\n command to tell Wylbur you're done.   The process of ending a\n session is called logging off.\n\n       When you log off, you have one last option open to you.\n The place in the computer that Wylbur has reserved for you\n still contains what you've typed.  When you log off, Wylbur\n reminds you that you still have something in that space.  It's\n up to you to clear it out or at least let Wylbur know you want\n to discard it.  Since you've already saved a copy of it it on\n USER50, you can discard it now.  So when Wylbur asks you\n 'CLEAR OK?', you reply 'YES'.  Wylbur will then print out\n accounting information and log you off.  The printout at your\n terminal looks like this:\n\n                    COMMAND ? logoff\n                    CLEAR OK? yes\n                    EDITING TIME = 0.09 SECONDS.  I/O COUNT = 5\n                    ELAPSED TIME = 00.05.11\n                    END OF SESSION\n\n1                                                Page 22\n\n\n      You have now successfully completed a Wylbur session.  The\n letter you typed has been saved for posterity on USER50.  An\n hour from now, a day from now, or a month from now,  your\n letter will still be there.  (You do get charged for the space\n you use on a disk pack, so don't save things you don't need.)\n You're ready now for a coffee break and then Beginner's\n Session #2.\n\n\n\n BEGINNER'S SESSION #2\n+__________ _______ __\n\n\n       In session #2 you will retrieve the letter you typed in\n session #1, correct your spelling mistakes, add new sentences,\n and polish up a final copy.  You'll learn more of Wylbur's\n vocabulary as well as how to list your letter on a high speed\n printer in the computer room.  When you finish session #2,\n you'll know how to use Wylbur effectively and confidently.\n\n\n LOGGING ON FOR SESSION #2\n+_______ __ ___ _______ __\n\n\n      You log on to session #2 exactly as you did for session\n #1.  Your printout at the terminal looks like this:\n\n                    COMMAND ? set uplow\n                    COMMAND ? set length 45\n                    COMMAND ?\n\n\n RETRIEVING THE LETTER YOU SAVED IN THE EARLIER SESSION\n+__________ ___ ______ ___ _____ __ ___ _______ _______\n\n\n      Before we discuss how to retrieve your letter, we want to\n present more of Wylbur's vocabulary.  One term that you'll\n frequently see is 'data set'.  A data set is a collection of\n information.  Your letter, for example, is a data set.  You\n saved it with the name, FLETTER.  If you had typed in a long\n memorandum, it would have been a data set also.   The term\n 'data set' is a descriptive term for collection of data that\n are grouped together.\n1                                                Page 23\n\n\n      The data sets you'll usually hear about are the data sets\n stored on disk packs.  There is one special data set though,\n that Wylbur creates for you.  That data set is stored in\n the area of the computer reserved for you when you log\n on.  That data set is called your 'working data set'.  In\n session #1 when you typed in your letter, you typed it into\n your working data set.  And when you logged off and Wylbur\n responded  'CLEAR OK?', Wylbur was asking you if you were ready\n to discard your working data set.\n\n       The area of the computer that is reserved for you, your\n working data set, is of vital importance.  Everything Wylbur\n does, it does with the working data set.  Wylbur cannot list or\n modify a data set you have saved on a disk pack.  Wylbur can\n list or modify only that information which is in your working\n data set.\n\n      Consequently you must now retrieve your data set (your\n letter) from the disk pack and put it into your working data\n set.  You do this with the USE command.   When you enter the\n USE command, Wylbur goes out to the disk pack and reads that\n data set into your working data set in the computer.  For\n example, to retrieve the letter you typed in session #1, you\n type 'USE FLETTER'.   Wylbur will then read FLETTER into your\n working data set.  When Wylbur is done, Wylbur will print\n 'COMMAND ?' again.  Your terminal printout reads:\n\n                    COMMAND ? set uplow\n                    COMMAND ? set length 80\n                    COMMAND ? use fletter\n                    COMMAND ?\n\n      Sometimes when you ask for your data set, Wylbur is busy\n handling other users, so Wylbur will issue a 'QUEUED' message.\n For example:\n\n                    COMMAND ? use fletter\n                    QUEUED\n                    QUEUED\n                    COMMAND ?\n\n      The QUEUED message is not important to you; it's merely\n Wylbur's way of telling you it's still working on your\n request.\n\n      When Wylbur reads your letter from the disk pack and puts\n a copy of it into your working data set, Wylbur does not\n destroy the copy of your letter that is on the disk pack.\n Wylbur merely copies it into your working data set.  The data\n set on USER50 called FLETTER remains as it was when you issued\n the SAVE command at the end of lesson #1.\n1                                                Page 24\n\n\n LISTING YOUR DATA SET\n+_______ ____ ____ ___\n\n\n       Having brought your letter into your working data set,\n you can now proceed to correct the mistakes in it.  Normally\n the first thing you do after reading in a data set is to list\n part of it to make sure you have retrieved the right\n information.  In your case, since your letter is short, you\n can list all of it.  Your terminal printout will read:\n\n         COMMAND ? set uplow\n         COMMAND ? set length 80\n         COMMAND ? use fletter\n         COMMAND ? list\n            1.     Dear Fred,\n            2.\n            3.     As I informedd you on the phone over\n            4.     Tuesday the last batch for Skyhooks you\n            5.      sent us wdere defective.  At last count\n            6.     40 astronauts dropped into the Atlantic.\n            7.     Untily your quality control departments\n            8.     gets on the ball, we'll have to order our\n            9.     gets on the ball, we'll have to order our\n           10.     skyhooks from Acme INc.\n           11.          Still your friend,\n           12.\n           13.          Josephine Blink\n           14.\n           15.     P.S.  HOw could you do this to me!\n         COMMAND ?\n\n      Having assured yourself that your letter is in your\n working data set, you are free to use Wylbur editing commands\n to create a final product.\n\n\n DELETE COMMAND\n+______ _______\n\n\n      The function of the DELETE command is to delete 1 or more\n lines of Wylbur data.  In your letter, for example, you\n inadvertently typed in one line twice.  You now want to\n delete either line 8 or line 9 because you don't need both of\n them.  You can delete line 9 by entering 'DELETE 9'.  Your\n terminal printout looks like this:\n\n         COMMAND ? DELETE 9\n         COMMAND ?\n1                                                Page 25\n\n\n      If you listed your working data set, you would see the\n following printout:\n\n         COMMAND ? delete 9\n         COMMAND ? list 8/10\n            8.     gets on the ball, we'll have to order our\n           10.     skyhooks from Acme INc.\n         COMMAND ?\n\n      You can also use the DELETE command to delete several\n lines at the same time.  You could enter 'DELETE 3 9 13' and\n delete those three lines, or you could enter  'DELETE 3/13' and\n delete all the lines from 3 to 13.  You could also enter\n 'DELETE FIRST/LAST' and delete everything in your working data\n set.  Normally you would do this only by accident, and you\n would be very unhappy.\n\n      A rather tragic error that happens to all of us every so\n often is that we mistype the DELETE command.  For example,\n instead of entering 'DELETE 3/10', we enter 'DELETE 3/100'.\n Wylbur obediently and instantaneously deletes every line from 3\n to 100.  If we had spent an hour typing in lines 11 to 100, and\n if we hadn't yet issued the SAVE command to save that information\n on a disk pack, we would sit down and cry.  We would have to\n type all that information again.  The lesson is clear: be\n careful when you use the DELETE command.\n\n      You will discover that besides the DELETE command, there\n are innumerable ways of instantly negating hours or even days\n of work.  You will also discover (in fact you will read about\n it later in this lesson) that there are ways of safeguarding\n yourself against these kinds of disasters.  When you come to\n that part of this lesson, read it carefully.  Until then, use\n the DELETE command with caution.\n\n\n REPLACE COMMAND\n+_______ _______\n\n\n         The function of the REPLACE command is to replace\n Wylbur lines in their entirety.  In your letter, for example,\n line 5 contains several mistakes.  Rather than correcting each\n mistake individually (using a command which you'll learn about\n soon), it may be easier for you to use the REPLACE command and\n retype the entire line.  To replace line 5, you would enter\n 'REPLACE 5'.  Wylbur would then prompt you with '5.  ?'.   You\n then type in the new line as you want it.  Your terminal\n printout reads:\n\n         COMMAND ? replace 5\n            5.   ? sent us were defective.  At last count\n         COMMAND ?\n\n      If you listed line 5 you would see that it had been\n replaced with the line you just entered.\n1                                                Page 26\n\n\n      There are other options of the REPLACE command.  To learn\n about them see the Wylbur Reference Manual.\n\n\n INSERT COMMAND\n+______ _______\n\n\n       The INSERT command inserts new lines between old ones.\n In your letter, for example, you may want to add a sentence or\n two in the middle.  As a learning exercise, let's add a line\n between lines 6 and 7.  The most logical line number between 6\n and 7 is 6 1/2, but Wylbur doesn't work with fractions.  Wylbur\n will accept though, a decimal equivalent, like 6.5 or even 6.1\n or 6.2.   Wylbur will accept, in fact, 999 lines between 6 and\n 7 as long as those lines are in decimal format, i.e.  6.001 to\n 6.999.  To insert just one or two line numbers, you'll probably\n find it easier to use line numbers like 6.1, 6.2, 6.3, etc.  To\n insert line 6.1 into your letter, you would merely enter,\n 'INSERT 6.1' Wylbur would prompt you with ' 6.1  ?  '.  After\n you entered the new line of information, Wylbur would return to\n the command mode and prompt you with 'COMMAND ?'.  Your\n terminal printout looks like this:\n\n         COMMAND ? INSERT 6.1\n            6.1  ? (And one came down in New York City!)\n         COMMAND ?\n\n\n       If you listed lines 5 through 7 after you enter\n INSERT 6.1, your terminal printout would look like this:\n\n         COMMAND ? insert 6.1\n            6.1  ?  (And one came down in New York City!)\n         COMMAND ? list 5/7\n            6.     40 astronauts dropped into the Atlantic.\n            6.1  ? (And one came down in New York City!)\n            7.     Untily your quality control departments\n         COMMAND ?\n\n\n      There is another option of the INSERT command, which you\n may read about in the Wylbur Reference Manual.\n\n\n CHANGE COMMAND\n+______ _______\n\n\n      The CHANGE command is one of the most useful editing\n commands in Wylbur.  With the CHANGE command, you can change\n words, phrases, or sentences in one Wylbur line, or in every\n line in your working data set.  As an example, we'll use the\n change command to correct some errors in your letter.  (We\n could use the CHANGE command to correct all the errors, but we\n want to save some work for the MODIFY command which you'll find\n out about next.)\n1                                                Page 27\n\n\n      You may recall that you typed 'Atlantic' instead of\n 'Pacific' in line 6.  An easy way to correct that mistake is to\n use the CHANGE command.  You would enter, CHANGE 'Atlantic' TO\n 'Pacific' IN 6.  The characters or words between the first pair\n of quote marks would be changed to the characters or words\n between the second pair of quote marks.  The two sets of\n characters need not be (and seldom are) the same length.  Your\n terminal printout would look like this:\n\n         COMMAND ? change 'Atlantic' to 'Pacific' in 6\n            6.     40 astronauts dropped into the Pacific.\n         COMMAND ?\n\n\n      Note that Wylbur prints out the line after the line is\n changed, allowing you to see that the change was made correctly.\n\n      Also note that the information between the quote marks\n must be entered in upper and lower case characters exactly as\n you want it because Wylbur won't change it.\n\n       The quote marks appear in pairs, one at the beginning and\n one at the end of each term.  If you are changing something\n that has a quote mark in the middle, use a double quote mark\n key at either end of the term.  Wylbur will accept the double\n quote mark key as a delimiter as well as the single quote mark\n key.  The double and single quote mark keys may not be mixed as\n delimiters however.  For example, to change 'IS NOT' to 'ISN'T'\n enter the following command:\n\n       COMMAND ? change 'IS NOT' to \"ISN'T\" in 3/10\n\n\n\n THE RANGE OF A COMMAND\n+___ _____ __ _ _______\n\n\n      You may have noticed that most Wylbur commands require a\n line number or a list of line numbers.  These line numbers are\n called the 'range' of the Wylbur command. The range of a Wylbur\n command  can be just one line, or it can be all the lines in\n your working data set.   In many commands, as in the CHANGE\n command, if no range is specified, Wylbur uses the default\n range which is the entire working data set.  The fact that the\n range defaults to the entire working data set means you have to\n be careful when you use many of the commands, including the\n CHANGE command.\n\n      By expanding the range of a command, you can make the\n command a great deal more powerful than it may appear to be at\n first glance.  The CHANGE command is a good example.  Suppose\n you had typed a letter that was five times as long as the\n letter in our example.  And suppose you're mind was on a trip\n to Europe.  And suppose in a five places you typed in\n1                                                Page 28\n\n\n 'Atlantic' instead of 'Pacific'.  Then suddenly you woke up and\n realized that you had to change five lines in the letter.  You\n could change those lines by issuing a five CHANGE commands as\n you did above; or you could use one change command in several\n different ways.  If the line numbers to be changed were 6 14 57\n 89 113, you could enter, CHANGE 'Atlantic' TO 'Pacific' IN 6 14\n 57 89 113.  Or, if you knew that every time the word 'Atlantic'\n occurred in your letter, you wanted the word 'Pacific', you\n could let Wylbur do the work of finding the occurrences of\n 'Atlantic' and you could just enter CHANGE 'Atlantic' TO\n 'Pacific' IN FIRST/LAST.  Or, since Wylbur assumes you mean\n FIRST/LAST if you don't specify a range, you could just enter\n CHANGE 'Atlantic' TO 'Pacific' and Wylbur would proceed to\n search for every occurrence of the word Atlantic and change it.\n\n       There is a danger though.  Suppose you wanted to change\n only one occurence of the word 'Atlantic', at the same time\n leaving the word 'Atlantic' in twenty other places where it\n was correct and proper.  If you entered  CHANGE 'Atlantic' to\n 'Pacific' and left off a line number, Wylbur would proceed to\n change every occurrence of 'Atlantic' even those you wanted\n left alone.  The moral of the story is to use care when you\n enter commands.  Always specify the range you intend the\n command to work with.\n\n\n MODIFY COMMAND\n+______ _______\n\n\n      The MODIFY command is one of the most useful of all of\n Wylbur's text editing commands.  You'll probably use it more\n frequently than the other commands.\n\n      The MODIFY command is used to change words or sentences in\n parts of a line.  For example, line 3 in your letter contains\n the word 'over' when you intended to type 'on'.   You could use\n the CHANGE command to change 'over' to 'on', but in this case\n let's use the MODIFY command.  The MODIFY command works in two\n parts.  First you specify the range you want to modify; and\n then you perform the modifications.  In our example you would\n first enter, ' MODIFY 3 '.   Wylbur would print line 3 in its\n entirety, and on the next line, the the word 'ALTERS ?'.  Your\n terminal printout would look like this:\n\n         COMMAND ? modify 3\n            3.     As I informedd you on the phone over\n          ALTERS ?\n\n\n      You are now ready to make modifications to line 3 by\n typing in beneath the line the modifications you want to make.\n There are 3 types of modifications: insertions, deletions, and\n replacements.  In this example we want to do a replacement,\n replacing the word 'over' with the word 'on'.  You make a\n replacement  by typing in the letter 'R' exactly under the\n place where you want to start your replacement, and then you\n type in your replacement.  The new replacement must be the same\n length as the word or characters you replace.  In our case, the\n1                                                Page 29\n\n\n word 'on' is 2 characters shorter than the word 'over', so\n you'll have to add two blanks at the end.  After you type the\n letter 'R' followed by the word 'on' followed by 2 blanks and\n then a carriage return, Wylbur would respond by printing out\n the modified version of the line and then prompt you with the\n word 'ALTERS ?' again.  Your terminal output looks like\n this:\n\n         COMMAND ? modify 3\n            3.     As I informedd you on the phone over\n          ALTERS ?                                 ron\n            3.     As I informedd you on the phone on\n          ALTERS ?\n\n\n      At this point you can make additional modifications to the\n line by typing in an 'R' followed by the replacement characters\n or replacement words; or you can tell Wylbur you are done\n modifying the line by typing in a carriage return.  The\n carriage return is a signal to Wylbur that you have finished\n making alters to the line and you wish to terminate the MODIFY\n command.\n\n      After you make modifications, you must always type a\n carriage return by itself in response to 'ALTERS ?' in order to\n terminate the MODIFY command.\n\n      In our case, we still have one more error in this sentence\n in the word 'informedd'.  This typographical error allows us to\n use another of the MODIFY options, the delete option.  You use\n the delete option by typing in a 'D' under the characters or\n words you want to delete.  (It's just a coincidence in this\n example that the MODIFY delete character is a 'D', and the\n character we want to delete is a 'd'.)   If you typed in a 'D'\n under the superfluous 'd' in 'informedd' and then typed a\n carriage return, Wylbur would respond once more by prompting\n you with 'ALTERS ?', and your terminal printout looks like\n this:\n\n\n         COMMAND ? modify 3\n            3.     As I informedd you on the phone over\n          ALTERS ?                                 ron\n            3.     As I informedd you on the phone on\n          ALTERS ?              d\n            3.     As I informed you on the phone on\n          ALTERS ?\n\n\n       The sentence looks fine now, so you can signal Wylbur you\n are done with the MODIFY verb by typing in a carriage return\n only in response to 'ALTERS?'.  Your terminal printout looks\n like this:\n1                                                Page 30\n\n\n         COMMAND ? modify 3\n            3.     As I informedd you on the phone over\n          ALTERS ?                                 ron\n            3.     As I informedd you on the phone on\n          ALTERS ?              d\n            3.     As I informed you on the phone on\n          ALTERS ?\n         COMMAND ?\n\n       Thus far you have used the MODIFY command to replace\n characters and delete characters in a line.   There is a third\n function of the MODIFY command, the insert function.   The\n insert function is similiar to the replace and delete\n functions.  Using line number 4 as an example, suppose you\n wanted to add the word 'evening' after the word 'Tuesday'.  The\n most effective way of doing this would be to use the insert\n function of the MODIFY command.   In this case, you would enter\n 'MODIFY 4', and Wylbur would print out line 4 followed by the\n prompt 'ALTERS ?'.   You would then enter the letter 'I' in the\n place where you want to insert something, and then you would\n type the word you wanted to insert followed by a carriage\n return.  Wylbur would print out the line with the insertion and\n prompt you again with 'ALTERS ?'.  Satisfied with the result,\n you would press carriage return.  Your terminal printout looks\n like this:\n\n         COMMAND ? modify 4\n            4.     Tuesday the last batch for Skyhooks you\n          ALTERS ?        i evening\n            4.     Tuesday evening the last batch for Skyhooks you\n          ALTERS ?\n         COMMAND ?\n\n      Note that the insertion goes before the character the 'I'\n is placed under.\n\n      There is a combination of the delete and insert functions\n that is useful to know.  You can use the delete function along\n with the insert function to do replacements of unequal length.\n For example, suppose you have misgivings about the letter\n you're sending to Fred, and you want to elevate the style.  In\n line 8, for example, you want to change 'gets on the ball' to\n 'becomes more efficient'.  You could do this with several other\n Wylbur commands, but let's do it with the MODIFY command to\n show how the delete and insert functions can be combined\n together.  You first enter 'MODIFY 8' and then enter the letter\n 'D' under every character of the phrase 'gets on the ball' and\n then type in the letter 'I' followed by the new phrase.\n Satisfied with the result you type in carriage return.  The\n terminal prinout looks like this:\n\n         COMMAND ? modify 8\n            8.     gets on the ball, we'll have to order our\n          ALTERS ? ddddddddddddddddibecomes more efficient\n            8.     becomes more efficient, we'll have to order our\n          ALTERS ?\n         COMMAND ?\n1                                                Page 31\n\n\n      The end result is the replacement of a string of\n characters with another string of characters of a different\n length.  One last hint before we leave the MODIFY command: you\n don't have to type in D's under every character you want to\n delete.  Type in a 'D' under the first and last character to be\n deleted, and Wylbur will delete everything in between.\n\n      You should be aware that the insert function of the MODIFY\n command is considerably different from the INSERT command.  You\n might look at the INSERT command again and note the difference.\n\n\n A REVIEW OF SESSION #2\n+_ ______ __ _______ __\n\n\n      Session #2 began when you retrieved the letter you wrote\n in session #1.  You used the USE command to retrieve the letter\n from a disk pack into your working data set.  You listed the\n data set using the LIST command, and then you began to correct\n your mistakes using Wylbur's editing commands.\n\n      You used the DELETE command to delete one line from your\n letter.\n\n      You used the REPLACE command to replace a line with one\n you typed correctly.\n\n      You used the INSERT command to insert a new line between\n two existing lines.\n\n      You used the CHANGE command to change a word you had\n mistyped.\n\n      Finally you used the MODIFY command to replace a word,\n delete a character, insert a word, and replace an entire phrase\n with another phrase.\n\n      You may have noticed by this time that many of the Wylbur\n editing commands produce the same results.  For example, you\n can always use the REPLACE command and replace an entire line,\n and you would never need to use the CHANGE or MODIFY commands.\n Or you could always use the CHANGE command and never use the\n REPLACE or MODIFY commands.   Similiarly you could use the\n MODIFY command exclusively, and never worry about how the\n REPLACE or CHANGE commands work.\n\n       Each of the Wylbur editing commands has a strong point\n though.  The REPLACE command is handy if you've really botched\n up a line, but the MODIFY command requires less work if the\n line needs only minor changes.   The CHANGE command comes into\n its own when a change is necessary to the same word or phrase\n in twenty or thirty different places.  Each command has its own\n place.\n1                                                Page 32\n\n\n      At first you'll probably be happy enough to get your work\n done no matter which command you use.  But as you get to know\n Wylbur, you'll grow increasing lazy.  And when you get lazy,\n you'll benefit greatly by browsing through the Wylbur Reference\n Manual.  A large amount of information is contained there that\n could not be presented in this learning guide.\n\n      Another valuable thing to do when you become lazy, is to\n sit down with a more knowledgeable person at a Wylbur terminal\n and watch that person do her work.  An experienced Wylbur user\n frequently cannot tell you the shortcuts she has learned but she\n can usually demonstrate them in the course of her normal job.\n\n\n MORE WYLBUR COMMANDS\n+____ ______ ________\n\n\n       If you have some familiarity with the commands you've\n used thus far, you're in a good position to utilize Wylbur\n effectively.  There a few more Wylbur commands that are useful\n to know about though.  You may not need them every day, but\n when you do need them, they're indispensable.  We'll present\n them in their basic form and leave it to you to read more about\n them in the reference section when you have the time.\n\n\n COPY COMMAND\n+____ _______\n\n\n      The COPY command copies existing lines into another place\n in your working data set.  When you use the COPY command, you\n always end up with 2 copies of the line or lines.  As an\n example, suppose you decided to remove the P.S. in your letter\n and make it part of the body of the letter.  You could do this\n by entering 'COPY  15 to 10.1' and then 'DELETE 15'.  If you\n used the MODIFY command to remove the 'P.S.', and listed the\n results, your terminal printout would look like this:\n1                                                Page 33\n\n\n         COMMAND ? list 8/last\n            8.     gets on the ball, we'll have to order our\n           10.     skyhooks from Acme INc.\n           11.          Still your friend,\n           12.\n           13.          Josephine Blink\n           14.\n           15.     P.S.  HOw could you do this to me!\n         COMMAND ?  copy 15 to 10.1\n         COMMAND ?  list 8/last\n            8.     gets on the ball, we'll have to order our\n           10.     skyhooks from Acme INc.\n           10.1    P.S.  HOw could you do this to me!\n           11.          Still your friend,\n           12.\n           13.          Josephine Blink\n           14.\n           15.     P.S.  HOw could you do this to me!\n         COMMAND ?  modify 10.1\n           10.1    P.S.  HOw could you do this to me!\n          ALTERS ? r      Ho\n           15.           How could you do this to me!\n          ALTERS ?\n         COMMAND ? delete 15\n         COMMAND ? list 8/last\n            8.     gets on the ball, we'll have to order our\n           10.     skyhooks from Acme INc.\n           10.1          How could you do this to me!\n           11.          Still your friend,\n           12.\n           13.          Josephine Blink\n           14.\n\n\n      You may wonder about the modification where you entered\n 'r     Ho'.  In effect you replaced the first 6 characters with\n blanks and then replaced the 'H' with another 'H', and then\n replaced the upper case 'O' with a lower case 'o'.  As you can\n see, replacement characters are always one character to the\n right because you type the 'r' under the first character you\n want to replace.\n\n      This example shows one way of moving a line (or several\n lines) to some other location.  First you use the COPY command\n to copy the line or paragraph where you want it.  Then you list\n the line in the new location and verify it's where you want it.\n Once you're sure you've moved it where you want it, you use the\n DELETE command to remove the original line or lines.\n\n      The COPY command has another variation which is\n invaluable.  The COPY command can be used to copy lines and\n paragraphs from a data set on a disk pack into your working\n data set.  For example, suppose you wished to include in your\n letter to Fred, some data on the advertised strength of\n1                                                Page 34\n\n\n skyhooks versus the tested strength after ten days' use.  You\n typed this data perhaps a week ago and saved it on disk pack\n USER50 under the name SKYDATA.  To include this data in your\n letter you would enter the following command:\n\n        COMMAND ?  copy first/last to end from skydata\n        67. - LAST LINE\n        COMMAND ?\n\n      What has occurred is that Wylbur has read in lines\n FIRST/LAST of data set SKYDATA on disk pack USER50, and placed\n those lines at the end of your working data set.  There were 52\n lines of information in SKYDATA, and consequently your letter\n now has 67 lines to it.\n\n       You can guess from the above example that you can also\n copy part of the data set SKYDATA into the middle of your\n letter.  For example, you can enter, 'COPY  3/14 TO 13.001\n FROM SKYDATA'.   Wylbur would then copy lines 3,4,5...14\n into your letter as lines 13.001, 13.002, 13.003...  13.012.\n\n\n MOVE COMMAND\n+____ _______\n\n\n      The MOVE command functions a great deal like the COPY\n command in that it also copies a line or lines of Wylbur data\n from one place to another.  The MOVE command though, deletes\n the original line or lines.   For example, you could have used\n the MOVE command above instead of the COPY command, and you\n wouldn't have had to use the DELETE command because the\n original lines would have been deleted automatically.  The\n command you entered would be:\n\n                 COMMAND ? move 15 to 10.1\n                 COMMAND ?\n\n      In general, you use the MOVE command when you are sure you\n want a line moved and not copied.  If you are unsure of what\n you're doing, a COPY and a subsequent DELETE command may be\n better for you.\n\n      Note that the MOVE command cannot be used to get\n information from a data set on a disk pack.  Only the COPY\n command can do that.\n1                                                Page 35\n\n\n COLLECT COMMAND\n+_______ _______\n\n\n      You've used the COLLECT command several times already, so\n you know what it does.  Essentially, it allows you to go from\n the command mode to the collect mode.   There is an option to\n the COLLECT command that you haven't seen yet.  You can, if you\n wish, begin collecting lines of Wylbur text at some point other\n than line 1.  For example, if you decided to add another\n paragraph to your letter just past line 10.1, you could do it\n by entering the command  'COLLECT  10.2' or 'COLLECT 10.111'.\n Wylbur would then prompt you with the line number and proceed\n to increment the lines proportionally to the value you specified.\n Your terminal printout looks like this:\n\n\n         COMMAND ?  list 10/11\n           10.     skyhooks from Acme INc.\n           11.          Still your friend,\n         COMMAND ?  collect 10.111\n           10.111?  And I'd like to add at this point\n           10.112?\n\n\n      You could continue to enter lines of text now until you\n got to line 10.999, and then you would have to stop.  You could\n enter more lines then, but first you would have to use the\n NUMBER command (you'll learn about the NUMBER command next).\n\n      To summarize the COLLECT command, if you start a new\n working data set, you merely enter COLLECT and you then begin\n collecting with line number 1.  If you already have some lines\n in your working data set and you enter COLLECT without\n specifying line numbers, you'll start collecting at the end of\n your working data set.  If you specify a range with the COLLECT\n command, you'll start collecting at that line number, and the\n increments that Wylbur uses for line numbers will depend on the\n number you supply in the COLLECT command.  For example, if you\n enter COLLECT 10.1,  Wylbur will prompt you with line numbers\n 10.1, 10.2, 10.3, etc.  If you enter COLLECT 10.01, Wylbur will\n prompt you with 10.01, 10.02, 10.03, etc.\n\n\n\n NUMBER COMMAND\n+______ _______\n\n\n      The NUMBER command renumbers your working data set.\n Normally you'll use the NUMBER command to get rid of the funny\n numbers you've created by inserting, copying, and moving.  In\n your letter for example, you've delete line number 9 and\n1                                                Page 36\n\n\n created a line number 6.1 and 10.1.   There's no particular\n problem with these line numbers, except they just aren't neat\n and orderly.  You may want to renumber the lines in your\n working data set by using the NUMBER command.  If you listed\n part of your letter before and after you renumbered, your\n terminal printout would look like this:\n\n         COMMAND ? list 6/11\n            6.     40 astronauts dropped into the Atlantic.\n            6.1    (And one came down in New York City!)\n            7.     Untily your quality control departments\n            8.     gets on the ball, we'll have to order our\n           10.     skyhooks from Acme INc.\n           10.1          How could you do this to me!\n           11.          Still your friend,\n         COMMAND ?  number\n         15. - LAST LINE\n         COMMAND ?  list 6/12\n            6.     40 astronauts dropped into the Atlantic.\n            7.     (And one came down in New York City!)\n            8.     Untily your quality control departments\n            9.     gets on the ball, we'll have to order our\n           10.     skyhooks from Acme INc.\n           11.           How could you do this to me!\n           12.          Still your friend,\n         COMMAND ?\n\n       There are other options of the NUMBER command.  You\n can read about them in the Wylbur Reference Manual.\n\n\n ALIGN COMMAND\n+_____ _______\n\n\n      The ALIGN command is used to make the lines in your\n working data set the same size.  That is, the ALIGN command\n adds words to the end of short lines to make them as long as\n the long lines.   After the ALIGN comand has executed, every\n line in your letter or memorandum is about the same size.\n We'll use part of your letter as an example.\n\n      When you typed your letter, you typed in lines of about 40\n characters in length.  Suppose now you wanted to make the lines\n about 50 characters.  You would do this by entering\n ' ALIGN  9/15 LENGTH 50 '.  If you listed the body of your\n letter before and after you entered the ALIGN command, your\n printout would look like this:\n1                                                Page 37\n\n\n     COMMAND ? list 9/15\n        9.          As I informed you over the phone on\n       10.     Tuesday, the last batch of skyhooks you\n       11.     sent us were defective.  At last count 4\n       12.     astronauts dropped into the Pacific.  Until\n       13.     your quality control department gets on\n       14.     the ball, we'll have to order our skyhooks\n       15.     from Acme Inc.\n     COMMAND ? align 9/15 length 50\n     COMMAND ? list 9/15\n        9.          As I informed you over the phone on Tuesday,\n       10.     the last batch of skyhooks you sent us were\n       11.     defective.  At last count 4 astronauts dropped\n       12.     into the Pacific.  Until your quality control\n       13.     department gets on the ball, we'll have to order\n       14.     our skyhooks from Acme Inc.\n     COMMAND ?\n\n\n      The ALIGN command moves words from line to line until the\n maximum number of words have been fitted on each line, given\n the length you specified in the command.  When alignment is\n complete, the extra line numbers are deleted.  In this case,\n line number 15 was deleted because there were no words in it.\n\n       The ALIGN command has many rules governing what it will\n do, and the easiest way to discover what these rules are is to\n use the command on some test material.   (You can also read the\n Wylbur Reference Manual, but that's not half as much fun.) One\n of the rules of the ALIGN command which you do have to know, is\n that lines beginning with one or more blanks act as stop lines.\n That is, when the ALIGN command finds a line beginning with a\n blank, the ALIGN command assumes that the line is the start of\n a paragraph and consequently does not move any words from the\n beginning of that line to any of the preceding lines.\n\n      Another rule of the ALIGN command is that it will create\n new line numbers if it doesn't have enough lines to fit the\n words on.  For example, if you aligned the above test paragraph\n into lines with a maximum length of 15 characters, the ALIGN\n command would be forced to create some new line numbers to hold\n all of the little lines you have created.  The line numbers\n would probably go from 9 to 12 and then to 12.1, 12.2, etc.\n\n      One word of caution about the ALIGN command: since it\n changes your working data set dramatically, you're wise to save\n a copy of your working data set before you start aligning\n material and then align your text paragraph by paragraph.  If\n you make a mistake (for example, leave off the LENGTH option),\n you can go back to your original copy and start over again.\n1                                                Page 38\n\n\n JUSTIFY COMMAND\n+_______ _______\n\n\n       The JUSTIFY command performs the same function as the\n ALIGN command.  In addition, the JUSTIFY command spaces the\n words within lines such that the last word extends to the very\n end of the line.  The JUSTIFY command does this by adding\n blanks between the words in the sentences.  For example, to use\n the JUSTIFY command on your letter instead of the ALIGN command\n you would enter, 'JUSTIFY 9/14 LENGTH 50'; if you listed the\n results, your terminal printout would look like this:\n\n  COMMAND ? justify 9/14 length 50\n  COMMAND ? list 9/14\n     9.          As I informed you over the phone on  Tuesday,\n    10.     the  last  batch  of  skyhooks  you  sent  us were\n    11.     defective.  At last  count  4  astronauts  dropped\n    12.     into  the  Pacific.   Until  your  quality control\n    13.     department gets on the ball, we'll have  to  order\n    14.     our skyhooks from Acme Inc.\n  COMMAND ?\n\n       The JUSTIFY command makes your copy look cleaner.  Be\n careful in using the command though, as you can ruin your\n working data set if you use it incorrectly.  To be on the safe\n side, you should save a copy of the working data set before you\n begin justifying, and then justify one paragraph at a time\n until you are satisifed with the results.\n\n       If you have lines in your working data set that have one\n or more blanks in front of them, and these lines do not start\n paragraphs, you will have trouble with the JUSTIFY command.\n The JUSTIFY command will produce strange results in the area of\n these lines.  You can learn more about the JUSTIFY command in\n the Wylbur Reference Manual.\n\n\n SYSTEM FAILURE.  WYLBUR CRASHES.\n+______ ________  ______ ________\n\n\n      Every so often some part of the computer system doesn't\n function as it's suppose to, and all sorts of dire things\n happen.  What you'll usually notice as you sit at your\n terminal, is that the terminal is unresponsive.  No matter what\n you type, Wylbur doesn't answer.   The best thing to do at this\n point is to sit at your terminal and wait for the system to\n come back up.  Eventually, you'll see the 'MODEL ?' query, and\n you can log on again.\n\n      When you finish logging on, you'll see, if you're lucky,\n the message 'RECOVERY COMPLETED'.  This means that Wylbur saved\n your working data set before Wylbur crashed, and you can\n continue where you left off.\n1                                                Page 39\n\n\n       More frequently though, when the system crashes you lose\n everything you've typed in since the last time you issued a\n 'SAVE' command.   Consider how you would feel if you just spent\n 3 hours typing a 200 page memorandum and then the system\n crashed.  If you hadn't bothered to save the memorandum\n periodically on disk, you would be faced with the prospect of\n typing the 200 page memorandum over again.  An experienced\n Wylbur user can tell you that typing a memorandum the second\n time is an onerous chore.\n\n      The moral is: save your working data set after every\n significant increment of work.\n\n      What a signigicant increment of work is you'll have to\n decide for yourself.  Many people save their work every 20\n minutes, particularly if they are fast typists.\n\n      One important thing to remember after system crashes is to\n SET UPLOW and SET LENGTH.   You do not get these automatically.\n It's rather common to be so upset by a system crash, that you\n forget to SET UPLOW, and then you type for an hour and have to\n go back and type it in still a third time.  (That's the reason\n some of the offices have locks on them--on the outside.)\n\n\n SAVING A BACKUP DATASET\n+______ _ ______ _______\n\n\n      You've been warned often enough to save your working data\n set in a backup data set as you work along.  The way you do\n this is by issuing the SAVE command.  First, you select a name\n for your backup data set.  You can name it BACKUP or TEMPLETT\n or LULUBELL.  The name is unimportant as long as you remember\n that the data set is for backup purposes.\n\n      The first time you issue the SAVE command, you must give\n the disk pack name, e.g., SAVE LULUBELL ON USER50.  After this\n initial save, you do not need to specify the disk pack, but you\n must specify the REPLACE option, e.g., SAVE LULUBELL REPLACE.\n (You'll learn more about the SAVE command and the REPLACE\n option later.)\n\n      For example, to save a backup copy of FLETTER after you\n have typed 10 or so lines, you can enter:\n\n              COMMAND ? save lulubell on user50\n              \"LULUBELL\" SAVED ON USER50\n              COMMAND ?\n\n\n      Then to save a backup copy of FLETTER later, after you've\n typed line 15 or so, enter:\n\n              COMMAND ? save lulubell replace\n              \"LULUBELL\" REPLACED ON USER50\n              COMMAND ?\n1                                                Page 40\n\n\n\n      Once you save your working data set, you are somewhat\n protected against system failure and your own mistakes.  For\n example, if you inadvertently delete half of your working data\n set, you can read in the backup copy you saved twenty minutes\n ago and start over from that point.  You bring in a copy of\n your backup by entering the USE command with the CLEAR option,\n e.g., USE LULUBELL CLEAR.  The CLEAR option tells Wylbur to\n clear out your old working data set or what's left of it, and\n replace it with LULUBELL.  For example:\n\n              COMMAND ? use lulubell clear\n              COMMAND ?\n\n\n       Note that LULUBELL is a backup of your working data set\n and not a copy of FLETTER, except perhaps at the beginning of\n the day when you make your first backup.  As the day progresses\n the backup copy of your working data set in LULUBELL becomes\n increasingly different from the copy of your letter saved in\n FLETTER.  Considering this, you may find it wise to save a\n backup copy of FLETTER  (a third backup) under some other name.\n Then when you eventually replace FLETTER at the end of the day,\n you still have an old copy of it in case you inadvertently\n deleted part of your working data set just before you saved it\n as FLETTER.\n\n\n ABBREVIATIONS\n+_____________\n\n\n       Almost all Wylbur commands have abbreviations.  You can\n read about them under the topic, Abbreviations, in the Wylbur\n Reference Manual.  You use the abbreviations exactly as you\n would the full command.  For example, LIST FIRST/LAST can also\n be entered as L F/L.  Other handy abbreviations are MOD for\n MODIFY; CH for CHANGE; and DEL for DELETE.\n\n\n LISTING YOUR WORKING DATA SET ON A HIGH SPEED PRINTER\n+_______ ____ _______ ____ ___ __ _ ____ _____ _______\n\n\n      After you've typed a long time at the terminal, your\n working data set becomes very large.  To list your working data\n set at the terminal takes forever because the terminal prints\n slowly.  Fortunately there's another way.  In addition to\n the LIST command you're familiar with, there is also the LIST\n OFFLINE command.\n1                                                Page 41\n\n\n      When you issue the LIST OFFLINE command, Wylbur prints a\n copy of your working data set on a high speed printer in the\n computer room.  Sometimes the data set is printed before you\n can walk to the computer room to pick it up.  Sometimes you\n have to wait a few minutes.  Usually within ten minutes, your\n output is waiting for you on the counter in the Computer Room,\n room 1307.\n\n       Suppose for example, that the letter you just aligned and\n justifed was 1000 lines long.  It would be a perfect candidate\n for listing offline.  To list it offline, you would enter\n 'LIST OFFLINE PAL xxx  UPLOW'.   The 'xxx' stands for your\n 'pal box' number.  If you haven't been given one, you should\n enter the first initial of your last name.  This pal box letter\n will be printed on the front of your computer listing.  Your\n employe number will also be printed on your computer listing.\n When you enter the computer room, you will find the listings\n arranged on the long counter by pal box identifiers, with\n alphabetic identifiers first followed by the numeric\n identifiers.  If you can't find your output on the long\n counter, you should look in the pal boxes across the room.\n There is a pal box there with your number or alphabetic\n identifier on it.\n\n      If you had entered the LIST OFFLINE command above, your\n terminal printout would look like this:\n\n                 COMMAND ?  list offline uplow pal a\n                 nnn IS YOUR JOB NUMBER\n                 COMMAND ?\n\n      The 'nnn' is the number of your job as it goes through the\n computer.   If you go into the computer room and can't find\n your output, ask the computer operator about job 'nnn'.\n Possibly it's been held up somewhere by unusual conditions.\n\n       The  LIST OFFLINE command has numerous options.  You\n should read about them in the Wylbur Reference Manual.  Some of\n the options you won't understand at this point but many of them\n you'll find useful.  In the example above, you used the UPLOW\n option.  This tells Wylbur that you want to list your working\n data set in both upper and lower case letters when it's listed\n on the high speed printer.  If you had omitted UPLOW, you would\n have gotten your data set printed in upper case letters only.\n\n\n SAVING YOUR DATA SET\n+______ ____ ____ ___\n\n\n      At the end of lesson #2 as in lesson #1, you will want to\n save your working data set.   You save it by entering the SAVE\n command in the same way that you did in lesson #1.  There is\n one difference though: your data set called FLETTER now exists\n on disk pack USER50.  It's true that the version of FLETTER on\n1                                                Page 42\n\n\n USER50 is the old one with the mistakes, but Wylbur doesn't\n know that.  Wylbur will discover when it goes to save FLETTER,\n that there is another FLETTER on USER50.  Wylbur will warn you\n about it, and you will have to reply 'YES'  when Wylbur asks\n you 'REPLACE?'.  Your terminal printout will look like this:\n\n         COMMAND ?  save fletter\n         \"FLETTER\" ALREADY EXISTS ON USER50\n         TO REPLACE, REPLY \"YES\"\n         REPLACE? yes\n         \"FLETTER\" REPLACED ON USER50\n         COMMAND ?\n\n\n      Note that you didn't have to tell Wylbur which disk pack\n FLETTER was on (i.e. SAVE FLETTER ON USER50).  Wylbur keeps a\n catalog of all data sets, and whenever you reference a data\n set, Wylbur searches to see where it's at.  Wylbur does this to\n safeguard you against saving two data sets with the same name.\n In the example above, if you had replied 'NO' to the 'REPLACE?'\n prompt, Wylbur wouldn't have replaced FLETTER.  The copy of\n FLETTER on the disk pack would remain unchanged; and the copy\n of FLETTER in your working data set would remain unchanged.\n You would still have to save your working data set somewhere.\n You might call this version something else, like FLETR2, and\n once again issue a save command (e.g., SAVE FLETR2 ON USER50).\n\n      There is an option on the SAVE command that eliminates\n Wylbur's prompt for replacing.  If you add the word REPLACE to\n the SAVE command, you're telling Wylbur that you know there is\n a version of FLETTER out there on a disk pack, and you want to\n scratch that version and replace it with the version in your\n working data set.  In our example, you would enter 'SAVE\n FLETTER REPLACE'.  Your terminal printout would then read:\n\n        COMMAND ? save fletter replace\n        \"FLETTER\" REPLACED ON USER50\n        COMMAND ?\n\n\n LOGGING OFF WYLBUR\n+_______ ___ ______\n\n\n      You log off Wylbur in session #2 exactly as you did in\n session #1.  Or, if you're sure you have saved your working\n data set, you can enter 'LOGOFF CLEAR' and Wylbur will not ask\n you about clearing the working data set.\n1                                                Page 43\n\n\n HOW IT ALL GOES TOGETHER\n+___ __ ___ ____ ________\n\n\n      You're aware now of what Wylbur can do for you.  You can\n type a letter or memorandum, make corrections, save it on a\n disk pack, and list it offline on a high speed printer.  So\n where do you begin?\n\n       An experienced Wylbur user proceeds about as follows:\n typing in the first draft, the experienced user corrects only a\n few mistakes, usually those that she can correct by backspacing\n and retyping.  Spelling and grammatical errors are left in the\n copy.  Long lines of text and short lines of text are also left\n in the copy.  The experienced user saves the working data set\n every 15-20 minutes in a backup data set (for example with the\n name BACKUP), and then at the end of his session, she saves it\n one last time (for example with the name of MYDATA) before\n listing it offline on a high speed printer.\n\n      When she returns after lunch or in the morning, she reads\n the offline listing and makes sure it's what she thinks it\n should be.  Then using the offline listing, she marks in\n corrections in red pencil, circling the line numbers that need\n to be changed.  Then she logs on to Wylbur, saves a copy of the\n data set in a second backup (for example named BACKUP2), and\n then enters the corrections she has marked on the listing.\n\n      When she's done with her corrections, she issues the\n NUMBER command and then lists the last line.  If the number of\n lines seems about right, she saves the dataset back in the\n original (for example named MYDATA).  She's then ready to\n proceed to add additional text, if any, to her data set.\n Eventually, she'll list the data set offline on special paper,\n unnumbered, to get a listing that appears almost hand typed.\n (To find out how to get a listing of this sort, read about the\n LIST OFFLINE command in the Wylbur Reference Manual.)\n\n      The value of the two backup data sets is as follows: the\n data set named BACKUP will be used if the system crashes or if\n our experienced Wylbur user accidentally deletes a large\n portion of her working data set.   If either of these disasters\n happen, then our experienced user will lose at the most 20\n minutes of work because she can read in the copy of her working\n data set she saved as BACKUP 20 minutes ago.\n\n       The data set in BACKUP2 will be used only if a more\n serious disaster occurs.  For example, if our experienced user\n accidentally deleted almost all of her working data set and\n then, unaware of what she had done, she saved this fragmented\n working data set in both BACKUP and MYDATA at the end of the\n1                                                Page 44\n\n\n day, she would be in  real trouble.  When she read her offline\n listing the next morning, she would cry a while and then read\n in the data set she saved in BACKUP2 and repeat all of the\n previous day's work (except the bad deletion presumably).  She\n would have lost one day's work, but she wouldn't have lost two\n days' work or even a week's work--which has happened to some\n people.  So remember to save BACKUP2 at the beginning of a\n session after you've read your listing and are sure you know\n what it is you're backing up.\n\n\n A FINAL REVIEW\n+_ _____ ______\n\n\n      Session #2 began when you read in the data set FLETTER and\n began to update it.  You used a variety of Wylbur commands\n (DELETE, REPLACE, INSERT, CHANGE, MODIFY) to correct your\n spelling and typographical errors.  Then you used the  COPY\n command to copy a line from one place to another.  You learned\n that the MOVE command did much the same thing: it copies a\n line to a new place and then deletes the original line.  You\n found out that the COLLECT command had an option that allowed\n you to add paragraphs in the middle of existing lines, and you\n found you could make your line numbers orderly by using the\n NUMBER command.\n\n      Then you got fancy with the ALIGN and JUSTIFY commands,\n and at the same time learned that it's wise to save your\n working data set freqently in a back up data set in case you\n make a serious mistake or the computer crashes.   Along the way\n you discovered that you could list your working data set on a\n high speed printer in the computer room by using the LIST\n OFFLINE command.  And lastly you issued the SAVE command and\n discovered that Wylbur keeps a catalog of your data sets, and\n that you have to tell Wylbur to scratch the existing copy\n before it will save a new version.\n\n\n CONGRATULATIONS!\n+________________\n\n       If you've had the patience to stick with it until now,\n you'll soon be using Wylbur with efficiency and pleasure.\n Wylbur is not easy to learn (as you've found out), but the\n longer you practice at it, the better you'll get.  Some day\n some one will ask you a question about Wylbur and you'll answer\n it and discover you have become a Wylbur expert.  Good luck.\n./ ADD NAME=GUIDE9   0100-80177-80177-0802-02387-02387-00000-$SYS13  00\n1                                                                          1.\n                                                                           2.\n                                                                           3.\n                                                                           4.\n                                                                           5.\n                                                                           6.\n                                                                           7.\n                                                                           8.\n                                                                           9.\n                                                                          10.\n                                                                          11.\n                                                                          12.\n                                                                          13.\n                                                                          14.\n                                                                          15.\n                                                                          16.\n                                                                          17.\n                                                                          18.\n                                                                          19.\n                     WYLBUR  LEARNER'S  GUIDE                             20.\n                                                                          21.\n                                                                          22.\n                                                                          23.\n                                                                          24.\n                                                                          25.\n                                                                          26.\n                                                                          27.\n                            B. Grotz                                      28.\n                                                                          29.\n                                                                          30.\n                           April, 1974                                    31.\n                                                                          32.\n                                                                          33.\n                                                                          34.\n                                                                          35.\n                                                                          36.\n                                                                          37.\n                                                                          38.\n                                                                          39.\n                                                                          40.\n                                                                          41.\n                                                                          42.\n                                                                          43.\n                                                                          44.\n                                                                          45.\n                   The  Rand  Computation  Center                         46.\n                   Santa Monica, California 90406                         47.\n1                                                Page  2                  48.\n                                                                          49.\n                                                                          50.\n                                                                          51.\n       This Learner's Guide is designed for newcomers to Wylbur           52.\n who have no knowledge of computers.  The Guide describes what a          53.\n terminal is, how to log on to a terminal, and how to use the             54.\n more frequently used Wylbur commands in their simplest forms.            55.\n                                                                          56.\n       A supplement to this Guide is the Wylbur Reference                 57.\n Manual, a manual designed for experienced Wylbur users.  The             58.\n Wylbur Reference Manual is arranged alphabetically by topic,             59.\n with each topic described first in a summary fashion and then            60.\n in more detail.                                                          61.\n                                                                          62.\n       In addition to these two manuals, every user should have a copy    63.\n of the Wylbur Card.  The Wylbur Card contains a list of all Wylbur       64.\n commands along with helpful information on how to use them.              65.\n                                                                          66.\n                                                                          67.\n      Copies of the Wylbur Learner's Guide, the Wylbur Reference          68.\n Manual, and the Wylbur Card may be obtained from the Computer            69.\n Documentation Center, room 1765, ext. 436.                               70.\n                                                                          71.\n                                                                          72.\n                                                                          73.\n       This manual violates a rule of grammar in regard to quote          74.\n marks.  Grammar dictates that quote marks include the rightmost          75.\n comma or a period.  For technical clarity the comma or period            76.\n will be placed outside of the ending quote in this publication.          77.\n1                                                Page  3                  78.\n                                                                          79.\n                    TABLE OF CONTENTS                                     80.\n                                                                          81.\n                                                                          82.\n                                                                          83.\n Beginners' session #1 ..................................4                84.\n     What a terminal is .................................4                85.\n     How to log on to a terminal at Rand ................5                86.\n     Wylbur's language ..................................6                87.\n         Carriage return key ............................7                88.\n         Backspace key ..................................7                89.\n         Entering commands in upper and lower case ......7                90.\n     Collect and command mode ...........................7                91.\n     Typing your letter .................................9                92.\n     Changing collect and command mode .................11                93.\n         Using the interrupt button to switch modes ....11                94.\n         Using the interrupt button to erase lines .....12                95.\n     A review  .........................................13                96.\n     Listing the rough draft of your letter ............14                97.\n         The SET UPLOW command .........................15                98.\n         The SET LENGTH command ........................18                99.\n     Saving your letter ................................19               100.\n     Logging off Wylbur ................................21               101.\n                                                                         102.\n Beginner's session #2 .................................22               103.\n     Logging on ........................................22               104.\n     Retrieving the letter .............................22               105.\n         What a data set is ............................22               106.\n         Your working data set .........................23               107.\n     Listing your data set .............................24               108.\n     The DELETE command ................................24               109.\n     The REPLACE command ...............................25               110.\n     The INSERT command ................................26               111.\n     The CHANGE command ................................26               112.\n     The range of a command ............................27               113.\n     The MODIFY command ................................28               114.\n     A review ..........................................31               115.\n                                                                         116.\n     The COPY command ..................................32               117.\n     The MOVE command ..................................34               118.\n     The COLLECT command ...............................35               119.\n     The NUMBER command ................................35               120.\n     The ALIGN command .................................36               121.\n     The JUSTIFY command ...............................38               122.\n                                                                         123.\n     System failure. Wylbur crashes.....................38               124.\n     Saving a backup data set ..........................39               125.\n     Abbreviations .....................................40               126.\n     Listing your data set offline on a                                  127.\n                     high speed printer ................40               128.\n     Saving your data set...............................41               129.\n     Logging off Wylbur ................................42               130.\n     How it all goes together ..........................43               131.\n     Final review ......................................44               132.\n1                                                Page  4                 133.\n                                                                         134.\n                                                                         135.\n                                                                         136.\n BEGINNER'S SESSION #1                                                   137.\n+__________ _______ __                                                   138.\n                                                                         139.\n                                                                         140.\n       Wylbur is the name of the system that allows you to               141.\n communicate with the computer.  Wylbur listens to what you say          142.\n and directs the computer to do what you want.  Wylbur is fast           143.\n and efficient and allows you to do a great deal of work in a            144.\n small amount of time.                                                   145.\n                                                                         146.\n       In the beginning you'll use Wylbur to type a letter or a          147.\n memorandum, correct your typing mistakes, and print out a clean         148.\n copy of what you've typed.  As you gain experience with Wylbur,         149.\n you'll use it for more than letters and memorandums.  You'll            150.\n discover you can store a large amount of information in Wylbur          151.\n and come back months later and retrieve that information.  You          152.\n can also execute a computer program through Wylbur and have the         153.\n output printed at your terminal as well as on a high speed              154.\n printer in the computer room.  In effect, you can use all of            155.\n the facilities of the computer while you're sitting at a Wylbur         156.\n terminal.                                                               157.\n                                                                         158.\n       To talk to Wylbur you use a language resembling English.          159.\n Some of Wylbur's commands, for example, are LIST, DELETE, SAVE,         160.\n and REPLACE.  Other words in Wylbur's language will be new to           161.\n you, such as LOGON, DDNAME, and LRECL.  You'll need to learn            162.\n these new words, as well as Wylbur's grammar, which is rigid            163.\n and which resembles English grammar only slightly.  You won't           164.\n have to learn all of it at once though.  You can learn enough           165.\n to do your work, and later when you're interested, you can              166.\n learn more.  The purpose of this learning guide is to provide           167.\n you with the basic concepts and commands used by Wylbur.  Once          168.\n you learn the material in this learning guide, you'll be able           169.\n to use Wylbur quite effectively.                                        170.\n                                                                         171.\n       You may have wondered if you can get into trouble using           172.\n Wylbur.  Can you hurt the computer?  Can you bring Rand to a            173.\n halt?  Not at all.  You'll discover Wylbur keeps you in check.          174.\n You can do a lot of work, and you can destroy your work, but            175.\n you can't destroy anyone else's work.  And you can't disrupt            176.\n the computer in any way.                                                177.\n                                                                         178.\n                                                                         179.\n WHAT A TERMINAL IS                                                      180.\n+____ _ ________ __                                                      181.\n                                                                         182.\n                                                                         183.\n      A terminal is a device like a typewriter that is connected         184.\n by a wire to the computer.  Some terminals are merely modified          185.\n typewriters; other terminals have TV screens and fancy                  186.\n keyboards with many strange abbreviatons on them.  Whatever the         187.\n case, when you use a terminal, you use it in the same manner as         188.\n you would a typewriter.  You type in a line as you would on a           189.\n1                                                Page  5                 190.\n                                                                         191.\n                                                                         192.\n typewriter, and at the end of the line you press the carriage           193.\n return key just as you would on a typewriter.  The one                  194.\n difference between a terminal and a typewriter is that a                195.\n terminal will talk back to you.  That is, when you type in a            196.\n command to Wylbur and press the carriage return key, Wylbur             197.\n will type something back to you.  In effect, you carry on a             198.\n conversation with Wylbur using a terminal.                              199.\n                                                                         200.\n       Rand has two types of terminals.  The more common type            201.\n has a TV screen.  This type of terminal is fast and silent, but         202.\n it lacks the ability to print anything on paper.  The other             203.\n type of terminal at Rand resembles a typewriter in that it has          204.\n paper in it.  A typewriter terminal is slower than the others,          205.\n but it has the advantage of being able to print on paper while          206.\n you're sitting at the terminal.  More important to you as a             207.\n beginner, a typewriter terminal prints on paper the commands            208.\n you enter as well as Wylbur's responses.  If you make a mistake         209.\n and get into trouble, you can take the printout to some one who         210.\n is more experienced and find out what to do.  For that reason,          211.\n we suggest you learn Wylbur using a terminal that has paper in          212.\n it.  The instructions in this learning guide will assume you            213.\n are using a terminal that prints on paper.                              214.\n                                                                         215.\n                                                                         216.\n HOW TO LOG ON TO A TERMINAL AT RAND                                     217.\n+___ __ ___ __ __ _ ________ __ ____                                     218.\n                                                                         219.\n                                                                         220.\n       To use Wylbur, you must let Wylbur know you are there.            221.\n The process of introducing yourself to Wylbur is called a               222.\n 'logon'.  When you log on to Wylbur, you give Wylbur certain            223.\n identifying information about yourself.  Once you give Wylbur           224.\n this information, you are considered to be 'logged on' and then         225.\n you can tell Wylbur what to do.                                         226.\n                                                                         227.\n      The basic information that Wylbur needs to know when you           228.\n log on is the type of terminal you are using, the employe               229.\n number to which you are charging the session, the account               230.\n number to which you are charging the session, and the keyword           231.\n authorizing you to use the employe number and account.                  232.\n Normally you will be supplied with this information by whoever          233.\n is asking you to learn to use Wylbur.  If you do not have this          234.\n information, you should call the Rand Computation Center                235.\n Business Office, ext.7678, and have an account and keyword              236.\n assigned to you.                                                        237.\n                                                                         238.\n      When you sit down at a terminal, you will usually see the          239.\n word 'MODEL?' printed out.  Reply to this by typing in the              240.\n number '37' (which identifies the terminal as a tyepwriter like         241.\n device with printed output), and then press the key marked              242.\n 'RETURN', which is the carriage return key.    Wylbur will then         243.\n print the message, 'RAND COMPUTATION CENTER LINE xx  mm/dd/yy           244.\n hh.mm.ss P.M.', and on the next line, 'USER?'.  Reply to                245.\n 'USER'?' by typing in the employe number you have been told to          246.\n use (either your own or someone else's), and then press the             247.\n return key again.                                                       248.\n1                                                Page  6                 249.\n                                                                         250.\n                                                                         251.\n       Sometimes when you sit down at a terminal, the 'MODEL?'           252.\n line does not appear but the 'USER?' line does.  In this case           253.\n just proceed by replying to the 'USER?' line as you would               254.\n normally.                                                               255.\n                                                                         256.\n      Wylbur will prompt you next with 'ACCOUNT?', and then              257.\n print X's and M' in the next four spaces.  The purpose of the           258.\n X's and M's is to hide your account number after you type it.           259.\n You'll notice after you type in your account number, you won't          260.\n be able to read it because of the X's and M's typed in the              261.\n background.  This prevents some one else from stealing your             262.\n account number and charging computer time to it.                        263.\n                                                                         264.\n       After you reply to 'ACCOUNT?' by typing in your 4-digit           265.\n account number, press the carriage return key. Wylbur will              266.\n next prompt you with the line 'KEYWORD?', and then print X's            267.\n and M's.  Reply to 'KEYWORD?' with the 3-character keyword that         268.\n has been assigned to you.  Wylbur will pause for a moment after         269.\n you reply, and then it will print 'COMMAND?'.  You are now              270.\n loggged on.                                                             271.\n                                                                         272.\n       The printout which you'll see at your terminal (excluding         273.\n the X's and M's printed behind your account number and keyword)         274.\n is:                                                                     275.\n                                                                         276.\n              MODEL? 37                                                  277.\n              RAND COMPUTATION CENTER   LINExx mm/dd/yy...               278.\n              USER? x1234                                                279.\n              ACCOUNT? 9999                                              280.\n              KEYWORD? x12                                               281.\n              COMMAND?                                                   282.\n                                                                         283.\n                                                                         284.\n       If you can't seem to log on to a terminal, don't be               285.\n concerned.  Some one may have turned off the power or                   286.\n misadjusted one of the special buttons or switches on the               287.\n terminal.  If you can't get the terminal to work, ask some one          288.\n who is knowledgeable to look at it.  If neither of you can get          289.\n it to work, give up.  Call ext. 403 and report the terminal as          290.\n being broken.  Then go into the Computer Room (room 1307) and           291.\n log onto one of the terminals there.  If you're still in                292.\n trouble, ask one of the computer operators to look at the               293.\n terminal.  If that doesn't work, go home and go to bed.                 294.\n                                                                         295.\n                                                                         296.\n WYLBUR'S LANGUAGE                                                       297.\n+________ ________                                                       298.\n                                                                         299.\n                                                                         300.\n      As we mentioned before, Wylbur has its own language and            301.\n grammar.  To communicate with Wylbur you must learn a minimum           302.\n of Wylbur's language and grammar.  Some of the punctuation of           303.\n1                                                Page  7                 304.\n                                                                         305.\n                                                                         306.\n Wylbur's grammar is the special keys on the keyboard in front           307.\n of you.  For example, when you logged on above, you typed your          308.\n employe number and then you pressed the carriage return key.            309.\n The carriage return key acts as a period at the end of a                310.\n sentence.  It tells Wylbur that you have completed whatever you         311.\n intend to type in for that line.  After you press the carriage          312.\n return key, Wylbur looks at everything you have typed on                313.\n that line and does as you command.                                      314.\n                                                                         315.\n       Another key you'll use frequently is the backspace key.           316.\n The backspace key not only backspaces the carriage, but also            317.\n erases, inside the computer's memory, whatever you backspaced           318.\n over.  So if you type a word incorrectly, backspace over it and         319.\n retype it.  The word will look messy on the terminal printout           320.\n because of the overtyping, but it will enter Wylbur correctly.          321.\n                                                                         322.\n       The repeat key, as it name states, enables you to repeat          323.\n a character or a blank.  For example, press the space bar, hold         324.\n it down, and then press the repeat key to space automatically           325.\n across the page.                                                        326.\n                                                                         327.\n       One feature of Wylbur's grammar has to do with upper and          328.\n lower case characters.  Wylbur responds to commands typed in            329.\n both upper and lower case characters.  When you type a command          330.\n for Wylbur, you can type it in lower case or in upper case and          331.\n get the same results.  In these learning exercises the commands         332.\n are printed in UPPER CASE in the text to make them stand out,           333.\n and in lower case in the terminal printout examples because             334.\n that's the way they would normally appear at your terminal.             335.\n                                                                         336.\n      The tab keys on the terminals are used as they are on a            337.\n typewriter, but setting the tabs can be difficult, so the use           338.\n of tabs will not be covered in these learning exercises.  When          339.\n you feel ready to learn about setting tabs, look up the topic,          340.\n TABS, in the Wylbur Reference Manual.                                   341.\n                                                                         342.\n      If you look carefully at the keyboard on your terminal,            343.\n you'll see that there is both the letter 'o' and the number             344.\n '0', the letter 'l' and the number '1'.  You should always type         345.\n the letter 'o' when you want a letter, and the number '0' when          346.\n you want a number, and similiarly with 'l' and '1'.   Wylbur is         347.\n rather fussy about these distinctions.                                  348.\n                                                                         349.\n                                                                         350.\n                                                                         351.\n COLLECT AND COMMAND MODES                                               352.\n+_______ ___ _______ _____                                               353.\n                                                                         354.\n                                                                         355.\n       One important feature of Wylbur's grammar is the                  356.\n difference between the 'command mode' and the 'collect mode'.           357.\n You use the command mode when you tell Wylbur to do something;          358.\n you use the collect mode when you want Wylbur to save what you          359.\n are typing.                                                             360.\n1                                                Page  8                 361.\n                                                                         362.\n                                                                         363.\n       The reason Wylbur needs a collect mode and a command mode         364.\n is that Wylbur needs to know when you are commanding Wylbur             365.\n to do something and when you are merely typing in things you            366.\n want to save.  Suppose for example, you wanted to type a                367.\n sentence in a letter that began with the word 'list'.  One of           368.\n Wylbur's commands happens to be the 'LIST' command.  When               369.\n Wylbur finds the word 'list', Wylbur tries to list something.           370.\n That's not what you want in this instance.  You're trying to            371.\n type a letter.  So how do you tell Wylbur to keep its hands off         372.\n your letter?  You 'enter' the collect mode.  You do this by             373.\n typing in the word 'COLLECT' in response to Wylbur's prompt of          374.\n 'COMMAND ?'.  When you're in the collect mode, Wylbur doesn't           375.\n examine what you're typing.  Wylbur merely stores it away for           376.\n you.                                                                    377.\n                                                                         378.\n       As an example, suppose you wanted to type a letter on             379.\n Wylbur.  The first thing you would do (after logon) is enter            380.\n the collect mode.  If you remember from above, the printed              381.\n output at your terminal after logon looked like this:                   382.\n                                                                         383.\n                    MODEL? 37                                            384.\n                    RAND COMPUTATION CENTER   LINExx mm/dd/yy            385.\n                    USER? x1234                                          386.\n                    ACCOUNT? 9999                                        387.\n                    KEYWORD? x12                                         388.\n                    COMMAND ?                                            389.\n                                                                         390.\n      You can now enter the collect mode by typing the word              391.\n 'COLLECT'.  Wylbur will respond by printing a '1.' on the next          392.\n line.  Your terminal printout looks like this:                          393.\n                                                                         394.\n                    MODEL? 37                                            395.\n                    RAND COMPUTATION CENTER   LINExx mm/dd/yy            396.\n                    USER? x1234                                          397.\n                    ACCOUNT? 9999                                        398.\n                    KEYWORD? x12                                         399.\n                    COMMAND ? collect                                    400.\n                       1.   ?                                            401.\n                                                                         402.\n                                                                         403.\n       You are now in the collect mode and you can begin to type         404.\n your letter.  The '1.' that Wylbur typed means that Wylbur is           405.\n ready to 'collect' line number 1.  Wylbur will not scan the             406.\n information you type, looking for commands.  Wylbur knows you           407.\n are typing a letter or other text.                                      408.\n1                                                Page  9                 409.\n                                                                         410.\n                                                                         411.\n TYPING YOUR LETTER                                                      412.\n+______ ____ ______                                                      413.\n                                                                         414.\n                                                                         415.\n       Suppose the letter you want to type looks like this:              416.\n                                                                         417.\n          Dear Fred,                                                     418.\n                                                                         419.\n               As I informed you over the phone on                       420.\n          Tuesday, the last batch of skyhooks you                        421.\n          sent us were defective.  At last count 4                       422.\n          astronauts dropped into the Pacific.  Until                    423.\n          your quality control department gets on                        424.\n          the ball, we'll have to order our skyhooks                     425.\n          from Acme Inc.                                                 426.\n                                                                         427.\n                              Still your friend,                         428.\n                                                                         429.\n                                                                         430.\n                              Josephine Blink                            431.\n                                                                         432.\n                                                                         433.\n      Let's start with the 'Dear Fred,'.  Type in 'Dear Fred,'           434.\n after the number '1.'.  Type it  as you would on an ordinary            435.\n typewriter.  Then press the carriage return key.  Your                  436.\n terminal printout looks like this:                                      437.\n                                                                         438.\n                                                                         439.\n                    MODEL? 37                                            440.\n                    RAND COMPUTATION CENTER   LINExx mm/dd/yy            441.\n                    USER? x1234                                          442.\n                    ACCOUNT? 9999                                        443.\n                    KEYWORD? x12                                         444.\n                    COMMAND ? collect                                    445.\n                       1.   ? Dear Fred,                                 446.\n                       2.   ?                                            447.\n                                                                         448.\n      Wylbur saved the first line you typed, and now Wylbur              449.\n is ready to collect line number 2.   When you pressed carriage          450.\n return, nothing printed, but for the sake of clarity, we'll use         451.\n the expression '(cr)' to indicate a carriage return.  In the            452.\n (cr) notation, the above printout would read:                           453.\n                                                                         454.\n                    MODEL? 37(cr)                                        455.\n                    RAND COMPUTATION CENTER   LINExx mm/dd/yy            456.\n                    USER? x1234(cr)                                      457.\n                    ACCOUNT? 9999(cr)                                    458.\n                    KEYWORD? x12(cr)                                     459.\n                    COMMAND ? collect(cr)                                460.\n                       1.   ? Dear Fred,(cr)                             461.\n                       2.   ?                                            462.\n1                                                Page 10                 463.\n                                                                         464.\n                                                                         465.\n                                                                         466.\n      You are now ready to type line 2.  Looking at the example,         467.\n you can see that the next line of the letter you intend to type         468.\n is blank.  Easy enough.  Just press carriage return.  That              469.\n gives you one blank line.  Your terminal printout looks like            470.\n this:                                                                   471.\n                                                                         472.\n                    MODEL? 37(cr)                                        473.\n                    RAND COMPUTATION CENTER   LINExx mm/dd/yy            474.\n                    USER? x1234(cr)                                      475.\n                    ACCOUNT? 9999(cr)                                    476.\n                    KEYWORD? x12(cr)                                     477.\n                    COMMAND ? collect(cr)                                478.\n                       1.   ? Dear Fred,(cr)                             479.\n                       2.   ? (cr)                                       480.\n                       3.   ?                                            481.\n                                                                         482.\n      In a similiar fashion, you proceed to type in the entire           483.\n letter.  Assuming you are a poor typist (or maybe a good typist         484.\n but somewhat rattled at being on Wylbur for the first time)             485.\n your final effort might look like this:                                 486.\n                                                                         487.\n                MODEL? 37(cr)                                            488.\n                RAND COMPUTATION CENTER   LINE xx mm/dd/yy               489.\n                USER? x1234(cr)                                          490.\n                ACCOUNT? 9999(cr)                                        491.\n                KEYWORD? x12(cr)                                         492.\n                COMMAND ? collect(cr)                                    493.\n         1.   ? Dear Fred,(cr)                                           494.\n         2.   ? (cr)                                                     495.\n         3.   ? As I informedd you on the phone over(cr)                 496.\n         4.   ? Tuesday the last batch for Skyhooks you(cr)              497.\n         5.   ?  sent us wdere defective.  At last count(cr)             498.\n         6.   ? 40 astronauts dropped into the Atlantic.(cr)             499.\n         7.   ? Untily your quality control departments(cr)              500.\n         8.   ? gets on the ball, we'll have to order our(cr)            501.\n         9.   ? gets on the ball, we'll have to order our(cr)            502.\n        10.   ? skyhooks from Acme INc.(cr)                              503.\n        11.   ?      Still your friend,(cr)                              504.\n        12.   ? (cr)                                                     505.\n        13.   ?      Josephine Blink(cr)                                 506.\n        14.   ?                                                          507.\n                                                                         508.\n      You've made a lot of mistakes, and you've typed in one             509.\n line twice, but all in all you've managed to create a rough             510.\n draft of your letter.                                                   511.\n                                                                         512.\n      Everything you've typed is saved in a special area                 513.\n reserved for you (at logon) inside Wylbur.  You'll learn more           514.\n about this special area later.                                          515.\n1                                                Page 11                 516.\n                                                                         517.\n                                                                         518.\n CHANGING FROM COLLECT TO COMMAND MODE AND BACK AGAIN                    519.\n+________ ____ _______ __ _______ ____ ___ ____ _____                    520.\n                                                                         521.\n                                                                         522.\n       Notice in the above example that you're still in the              523.\n collect mode.  The way you know you're in the collect mode is           524.\n by the line number '14.  ?'.  That's Wylbur's prompt for the            525.\n next line.  Whenever Wylbur prompts you with a line number              526.\n you're in the collect mode, and Wylbur expects you to type in           527.\n another line.  Wylbur would be happy collecting information             528.\n from you forever.  It's up to you to tell Wylbur that you are           529.\n through typing your letter.  You do that by entering the                530.\n 'command mode'.                                                         531.\n                                                                         532.\n       The way you enter the command mode is to press the key            533.\n marked 'INT'.  This key is called the interrupt or attention            534.\n key, and it occupies a central position in Wylbur's grammar.            535.\n Whenever Wylbur prompts you with a line number, for example             536.\n '10. ?', Wylbur is ready to change modes.  If you press the             537.\n interrupt key in response to Wylbur's prompt, Wylbur will               538.\n change back to the command mode.  In our example, you would             539.\n press the interrupt button after '14.  ?' and Wylbur would              540.\n print out 3 asterisks on that line, and then on the next line           541.\n print 'COMMAND ?' The last part of your printout looks like             542.\n this:                                                                   543.\n                                                                         544.\n            10.   ? skyhooks from Acme INc.(cr)                          545.\n            11.   ?      Still your friend,(cr)                          546.\n            12.   ? (cr)                                                 547.\n            13.   ?      Josephine Blink(cr)                             548.\n            14.   ? ***                                                  549.\n          COMMAND ?                                                      550.\n                                                                         551.\n       When Wylbur prompts with 'COMMAND ?' you are in the               552.\n command mode, and you can give Wylbur whatever command you              553.\n like.  Suppose though, having successfully gotten into the              554.\n command mode, you decide that you want to add a postscript to           555.\n your letter.  This means you have to get back into the collect          556.\n mode and collect more lines of your letter.  Well, you could            557.\n enter the 'collect' command as you did above by typing in               558.\n 'COLLECT'.  Your printout would look like this:                         559.\n                                                                         560.\n            10.   ? skyhooks from Acme INc.(cr)                          561.\n            11.   ?      Still your friend,(cr)                          562.\n            12.   ? (cr)                                                 563.\n            13.   ?      Josephine Blink(cr)                             564.\n            14.   ? ***                                                  565.\n          COMMAND ? collect                                              566.\n            14.   ?                                                      567.\n                                                                         568.\n      You've probably noticed one thing: when Wylbur goes back           569.\n to the collect mode, Wylbur remembers where you were before and         570.\n then prompts you with the same line number.  That's rather              571.\n handy, to say the least.                                                572.\n1                                                Page 12                 573.\n                                                                         574.\n                                                                         575.\n      Another thing: the interrupt button you pressed to switch          576.\n to the command mode, works equally well in both directions.             577.\n That is, you can press the interrupt button to get into the             578.\n collect mode at the point where Wylbur types 'COMMAND ?'.  The          579.\n interrupt button  works exactly the same as if you had typed in         580.\n the command, 'COLLECT'.   Above, for example, where you typed           581.\n 'COLLECT', suppose you had pressed the interrupt button.  Your          582.\n terminal printout would have looked like this:                          583.\n                                                                         584.\n                                                                         585.\n            10.   ? skyhooks from Acme INc.(cr)                          586.\n            11.   ?      Still your friend,(cr)                          587.\n            12.   ? (cr)                                                 588.\n            13.   ?      Josephine Blink(cr)                             589.\n            14.   ? ***                                                  590.\n          COMMAND ? ***                                                  591.\n            14.   ?                                                      592.\n                                                                         593.\n      In either case, you are in the collect mode now and you            594.\n can type in your postscript.   For example, (and we'll leave            595.\n off the (cr) notation now that you're getting to be a pro):             596.\n                                                                         597.\n            10.   ? skyhooks from Acme INc.                              598.\n            11.   ?      Still your friend,                              599.\n            12.   ?                                                      600.\n            13.   ?      Josephine Blink                                 601.\n            14.   ? ***                                                  602.\n          COMMAND ? ***                                                  603.\n            14.   ?                                                      604.\n            15.   ? P.S.  HOw could you do this to me!                   605.\n            16.   ?                                                      606.\n                                                                         607.\n       Having typed in your postscript, you can press the                608.\n interrupt key and switch from the collect mode to the command           609.\n mode.  You want to do this because you've finished your letter,         610.\n and you want to use Wylbur commands to correct some of the              611.\n mistakes you made.                                                      612.\n                                                                         613.\n       Before we discuss the command mode and some of the more           614.\n common Wylbur commands, it would be best to let you know about          615.\n another use of the interrrupt key.  Besides using the                   616.\n interrupt key to switch modes, you can use it as a kind of an           617.\n eraser.  Suppose you had typed in part of a line and then               618.\n noticed you typed in the wrong words.  Since you are midway             619.\n through the line, you may press the interrupt key (but not the          620.\n carriage return key also) and Wylbur will discard everything in         621.\n that line and let you start that line over again.  This works           622.\n in both the collect and command mode.  For example, suppose             623.\n when you were typing the postcript above, your fingers got on           624.\n1                                                Page 13                 625.\n                                                                         626.\n                                                                         627.\n the wrong keys and you typed in garbage.  Toward the end of the         628.\n line you glanced up, saw your mistake, and pressed the                  629.\n interrupt key to erase what you had typed.  Wylbur prompted you         630.\n with the line number again, and you typed in the line                   631.\n correctly.  Your terminal printout looks like this:                     632.\n                                                                         633.\n                                                                         634.\n            10.   ? skyhooks from Acme INc.                              635.\n            11.   ?      Still your friend,                              636.\n            12.   ?                                                      637.\n            13.   ?      Josephine Blink                                 638.\n            14.   ? ***                                                  639.\n          COMMAND ? ***                                                  640.\n            14.   ?                                                      641.\n            15.   ? O.S. Giw ciykd tiy di tgus ti***                     642.\n            15.   ? P.S.  HOw could you do this to me!                   643.\n            16.   ? ***                                                  644.\n          COMMAND ?                                                      645.\n                                                                         646.\n      One last thing: if you log on to Wylbur and then walk away         647.\n from your terminal, Wylbur will wait a while, and then ask you          648.\n 'ARE YOU STILL THERE?'.  Eventually Wylbur will log you off.            649.\n Your output will be saved and restored ('RECOVERY COMPLETED')           650.\n when you log on next.  It's best to avoid this situation by             651.\n 'logging off' when you expect to be away from the terminal for          652.\n a long time.  You'll learn about 'logging off' later in this            653.\n session.                                                                654.\n                                                                         655.\n                                                                         656.\n                                                                         657.\n                                                                         658.\n A REVIEW OF WHAT YOU'VE DONE SO FAR                                     659.\n+_ ______ __ ____ ______ ____ __ ___                                     660.\n                                                                         661.\n                                                                         662.\n      In the beginning, you logged on using your employe number,         663.\n account number, and keyword.  After you logged on, Wylbur               664.\n placed you in the command mode, prompting you with 'COMMAND ?'.         665.\n You wanted to type in a new letter, so you entered the collect          666.\n mode by typing in the word, 'COLLECT'.   Wylbur responded by            667.\n prompting you with the first line number, '1.   ?'.   You then          668.\n typed in your letter, ending each line with a carriage return.          669.\n When you were finished, you switched back to the command mode           670.\n by pressing the interrupt key.  Besides using the interrupt key         671.\n to switch modes you also used it to erase a line you typed              672.\n poorly so you could type the line in again.   Finally you               673.\n pressed the interrupt key again and ended up in the command             674.\n mode.                                                                   675.\n                                                                         676.\n      The most important thing to remember so far is the                 677.\n difference between the command and the collect mode and the use         678.\n of the interrupt key.  If you press the interrupt key                   679.\n1                                                Page 14                 680.\n                                                                         681.\n                                                                         682.\n immediately after a prompt (immediately after a line number             683.\n such as '15.  ?' or immediately after 'COMMAND ?') you are              684.\n asking Wylbur to switch modes.  If you type in something                685.\n and then press the interrupt key, you are asking Wylbur                 686.\n to erase what you typed on that line and let you try again.             687.\n                                                                         688.\n      Now that you've learned the basics of the collect mode,            689.\n let's find out about the command mode.                                  690.\n                                                                         691.\n                                                                         692.\n LISTING YOUR LETTER                                                     693.\n+_______ ____ ______                                                     694.\n                                                                         695.\n                                                                         696.\n       Having typed in your letter, you probably want to see what        697.\n it looks like under Wylbur.  You can do this with the LIST              698.\n command.  Whenever Wylbur prompts with the word 'COMMAND ?',            699.\n you can reply 'LIST' and Wylbur will list everything it's saved         700.\n for you.  Continuing our example, if you typed 'LIST' and then          701.\n a carriage return, Wylbur would respond by printing out your            702.\n letter.  Your command and Wylbur's response looks like this:            703.\n                                                                         704.\n          COMMAND ? list                                                 705.\n             1.     DEAR FRED,                                           706.\n             2.                                                          707.\n             3.     AS I INFORMEDD YOU ON THE PHONE OVER                 708.\n             4.     TUESDAY THE LAST BATCH FOR SKYHOOKS YOU              709.\n             5.      SENT US WDERE DEFECTIVE,  AT LAST COUNT             710.\n             6.     40 ASTRONAUTS DROPPED INTO THE ATLANTIC.             711.\n             7.     UNTILY YOUR QUALITY CONTROL DEPARTMENTS              712.\n             8.     GETS ON THE BALL, WE'LL HAVE TO ORDER OUR            713.\n             9.     GETS ON THE BALL, WE'LL HAVE TO ORDER OUR            714.\n            10.     SKYHOOKS FROM ACME INC.                              715.\n            11.          STILL YOUR FRIEND,                              716.\n            12.                                                          717.\n            13.          JOSEPHINE BLINK                                 718.\n            14.                                                          719.\n            15.     P.S.  HOW COULD YOU DO THIS TO ME!                   720.\n          COMMAND ?                                                      721.\n                                                                         722.\n                                                                         723.\n      The first thing that strikes your eye is the upper case            724.\n characters.  You typed the letter in both upper case and lower          725.\n case characters.  So what happened?                                     726.\n                                                                         727.\n       What happened is that you ran afoul of one of Wylbur's            728.\n default options.  When you logged on to Wylbur, you                     729.\n automatically got a number of default options.  These options           730.\n are a set of values that Wylbur always assigns to you.  The             731.\n option you crashed into here is the one concerned with upper            732.\n and lower case characters.  Wylbur's default option for upper           733.\n1                                                Page 15                 734.\n                                                                         735.\n                                                                         736.\n and lower case characters is to convert them all to upper case.         737.\n The reason Wylbur does this is that most of the work done on            738.\n the computer is done in upper case.  Job control cards and              739.\n computer program cards are usually in upper case.  And since            740.\n Wylbur was designed by computer programmers, the default option         741.\n is upper case.  A clear example of programmer chauvinism.               742.\n                                                                         743.\n      The solution to your problem is simple: when you log on to         744.\n Wylbur, and Wylbur types in 'COMMAND ?', you must tell Wylbur           745.\n you want to use both upper and lower case characters.  You do           746.\n this with the 'SET UPLOW' command.   Going back to the                  747.\n beginning when you logged on, your printout would have looked           748.\n like this:                                                              749.\n                                                                         750.\n                    MODEL? 37                                            751.\n                    RAND COMPUTATION CENTER   LINE xx mm/dd/yy           752.\n                    USER? x1234                                          753.\n                    ACCOUNT? 9999                                        754.\n                    KEYWORD? x12                                         755.\n                    COMMAND ? set uplow                                  756.\n                    COMMAND ? collect                                    757.\n                       1.   ? Dear Fred,                                 758.\n                       2.   ?                                            759.\n                                                                         760.\n      You may wonder now why we didn't just tell you to SET              761.\n UPLOW when you logged on.  You would have typed your letter             762.\n correctly, and we wouldn't have had to go through this                  763.\n explanation.  The point is, if you forget to SET UPLOW,                 764.\n the consequences are serious: you may be in for a great deal of         765.\n extra work.                                                             766.\n                                                                         767.\n      In our example then, you will want to type your letter             768.\n again.  First you must get rid of what you have already typed.          769.\n You do this with the CLEAR TEXT command.  The CLEAR TEXT                770.\n command wipes out everything you've typed.  After you issue the         771.\n CLEAR TEXT command, you issue the COLLECT command and then type         772.\n your letter.  The terminal printout looks like this:                    773.\n                                                                         774.\n          COMMAND ? clear text                                           775.\n          COMMAND ? set uplow                                            776.\n          COMMAND ? collect                                              777.\n             1.   ?                                                      778.\n                                                                         779.\n       You proceed now to type the letter exactly as you did             780.\n before.  This time when you execute the LIST command, your              781.\n printout looks like this:                                               782.\n1                                                Page 16                 783.\n                                                                         784.\n                                                                         785.\n          COMMAND ? list                                                 786.\n             1.     Dear Fred,                                           787.\n             2.                                                          788.\n             3.     As I informedd you on the phone over                 789.\n             4.     Tuesday the last batch for Skyhooks you              790.\n             5.      sent us wdere defective.  At last count             791.\n             6.     40 astronauts dropped into the Atlantic.             792.\n             7.     Untily your quality control departments              793.\n             8.     gets on the ball, we'll have to order our            794.\n             9.     gets on the ball, we'll have to order our            795.\n            10.     skyhooks from Acme INc.                              796.\n            11.          Still your friend,                              797.\n            12.                                                          798.\n            13.          Josephine Blink                                 799.\n            14.                                                          800.\n            15.     P.S.  HOw could you do this to me!                   801.\n          COMMAND ?                                                      802.\n                                                                         803.\n                                                                         804.\n       Wylbur has now saved your letter in both upper and lower          805.\n case.  And when you asked Wylbur to list it, Wylbur listed it           806.\n exactly as you typed it.                                                807.\n                                                                         808.\n      The LIST command has other variations.  One of these               809.\n variations allows you to list a single line or several lines.           810.\n The way you request which lines are to be listed is by                  811.\n specifying line numbers.  For example, if you wanted to list            812.\n line 3 of your letter and then list lines 10-13, you would              813.\n enter 'LIST 3' and 'LIST 10/13'.  Your printout looks like              814.\n this:                                                                   815.\n                                                                         816.\n                                                                         817.\n          COMMAND ? list 3                                               818.\n             3.     As I informedd you on the phone over                 819.\n          COMMAND ? list 10/13                                           820.\n            10.     skyhooks from Acme INc.                              821.\n            11.          Still your friend,                              822.\n            12.                                                          823.\n            13.          Josephine Blink                                 824.\n          COMMAND ?                                                      825.\n                                                                         826.\n                                                                         827.\n       Notice the '/' between the line numbers 10 and 13 in the          828.\n LIST command.  The slash tells Wylbur you want to list lines 10         829.\n to 13 inclusive.  If you leave out the slash, Wylbur will list          830.\n lines 10 and 13 only.  There's another rule: there must be              831.\n at least 1 blank between the word, LIST, and the line numbers.          832.\n                                                                         833.\n        To aid you in specifying line numbers Wylbur has some            834.\n special vocabulary.  You can refer to the first line of your            835.\n letter by the word 'FIRST', and the last line  by the word              836.\n 'LAST'.  You can list your entire letter by entering any of             837.\n these 3 commands:                                                       838.\n1                                                Page 17                 839.\n                                                                         840.\n                                                                         841.\n              COMMAND ?  list                                            842.\n              COMMAND ?  list 1/15                                       843.\n              COMMAND ?  list first/last                                 844.\n                                                                         845.\n      In the first form of the command you didn't specify a              846.\n range, so Wylbur gave you the default,  which is also                   847.\n FIRST/LAST. In the second and third forms, you specified a              848.\n range that covered all line numbers, so you also got the                849.\n complete letter listed.                                                 850.\n                                                                         851.\n      You can intermix 'FIRST' and 'LAST' with numbers.                  852.\n For example:                                                            853.\n                                                                         854.\n          COMMAND ?  list first/5                                        855.\n          COMMAND ?  list 6/last                                         856.\n                                                                         857.\n      There is another variation of the LIST command that you            858.\n should be aware of.  The LIST command will list 24 lines of             859.\n your letter or memorandum and then pause.  If you want to               860.\n continue listing the rest of your letter, you must press                861.\n carriage return.  Wylbur will then  list another 24 lines of            862.\n your letter.  In our example, your letter is less than 24               863.\n lines, so you didn't see any pauses.                                    864.\n                                                                         865.\n      When Wylbur pauses after listing 24 lines, you can                 866.\n continue the listing or enter any command you like.  At the             867.\n point where Wylbur pauses, Wylbur is in the command mode and            868.\n will accept either a carriage return (which tells Wylbur to             869.\n continue) or a new command.  This is the only time you can              870.\n enter a command without first having Wylbur prompt you with             871.\n 'COMMAND ?'.                                                            872.\n                                                                         873.\n      If you have a long letter and you don't want Wylbur to             874.\n pause in the middle of printing it, you can use the PAGE                875.\n parameter of the LIST command.  For example:                            876.\n                                                                         877.\n          COMMAND ?  list page 0                                         878.\n                                                                         879.\n      That '0' is a zero.  It tells Wylbur not to pause when             880.\n listing.  You can give Wylbur other values too.  For example,           881.\n LIST PAGE 5 tells Wylbur to pause after listing every 5 lines.          882.\n If you use the LIST command without specifying PAGE, you get            883.\n the default of 24 lines, which is the same as entering, LIST            884.\n PAGE 24.   If you specify line numbers as well as the PAGE              885.\n option, specify the line numbers first:                                 886.\n                                                                         887.\n          COMMAND ?  list first/70 page 0                                888.\n                                                                         889.\n      For practice you might type a letter that is longer than           890.\n 24 lines and then list it using various values for the PAGE             891.\n parameter.                                                              892.\n1                                                Page 18                 893.\n                                                                         894.\n                                                                         895.\n SETTING THE LINE LENGTH                                                 896.\n+_______ ___ ____ ______                                                 897.\n                                                                         898.\n                                                                         899.\n                                                                         900.\n      In our example, the lines in your letter are all about 40          901.\n characters long.  For a letter, lines of 40 or 50 characters            902.\n might be appropriate.  For other material though, lines as long         903.\n as 100 or 120 characters would be appropriate.  (Wylbur will            904.\n let you type in lines as long as 133 characters.)  If you do            905.\n type in a long line however, Wylbur will print out a warning            906.\n note to you.  For example, suppose you typed the first two              907.\n lines of your letter as one line.  Although we can't reproduce          908.\n it on this page, your printout (and Wylbur's note) would appear         909.\n somthing like this:                                                     910.\n                                                                         911.\n    2.   ?                                                               912.\n    3.   As I informedd you on the phone over Tuesday the last ...       913.\n LINE NUMBER  3. CONTAINS 76 CHARACTERS                                  914.\n    4.   ?                                                               915.\n                                                                         916.\n      Sometimes you want to be warned when you type in a long            917.\n line, but usually you don't want those messages to appear.  You         918.\n can avoid getting the messages by using the 'SET LENGTH'                919.\n command.  The SET LENGTH command tells Wylbur the size of the           920.\n longest line you expect to type.  In your letter, for example,          921.\n you didn't expect to type a line longer than 45 characters.             922.\n You could have used the SET LENGTH command if you wanted.  For          923.\n example:                                                                924.\n                                                                         925.\n                    MODEL? 37                                            926.\n                    RAND COMPUTATION CENTER   LINE xx mm/dd/yy           927.\n                    USER? x1234                                          928.\n                    ACCOUNT? 9999                                        929.\n                    KEYWORD? x12                                         930.\n                    COMMAND ? set uplow                                  931.\n                    COMMAND ? set length 45                              932.\n                    COMMAND ? collect                                    933.\n                       1.   ?                                            934.\n                                                                         935.\n      Since you were careful in typing your letter, you didn't           936.\n type a line longer than 45 characters and you didn't get any            937.\n messages of the form,  'LINE  nn  CONTAINS  xx  CHARACTERS'.            938.\n But if you had gotten distracted and typed in long line, Wylbur         939.\n would have reminded you, and you could have corrected it at             940.\n that time.                                                              941.\n                                                                         942.\n      The default line length that you get when you log on is 72         943.\n characters.  If you intend to type lines longer than 72                 944.\n characters, you should use the SET LENGTH command.                      945.\n1                                                Page 19                 946.\n                                                                         947.\n                                                                         948.\n A REVIEW OF THE COMMANDS YOU HAVE USED                                  949.\n+_ ______ __ ___ ________ ___ ____ ____                                  950.\n                                                                         951.\n                                                                         952.\n      So far you have used four Wylbur commands.  The most               953.\n important command was the COLLECT command.  The COLLECT command         954.\n allowed you to enter the collect mode after you logged on.              955.\n                                                                         956.\n      Another command you used was the LIST command.  You used           957.\n the LIST command to list all of your letter, and then used it           958.\n to list just a few lines of your letter.                                959.\n                                                                         960.\n      The other two commands you used were SET commands.  You            961.\n used SET UPLOW to tell Wylbur you wanted to type upper and              962.\n lower case characters.  And you used the SET LENGTH command to          963.\n tell Wylbur the length of the longest line you expected to              964.\n type.                                                                   965.\n                                                                         966.\n      At this point we recommend you get in the habit of using           967.\n the SET UPLOW and SET LENGTH commands every time you log on             968.\n (assuming you want upper and lower case information).  When you         969.\n log on, you can follow this pattern:                                    970.\n                                                                         971.\n              MODEL? 37                                                  972.\n              RAND COMPUTATION CENTER   LINE xx mm/dd/yy...              973.\n              USER? x1234                                                974.\n              ACCOUNT? 9999                                              975.\n              KEYWORD? x12                                               976.\n              COMMAND ? set uplow                                        977.\n              COMMAND ? set length 80                                    978.\n                                                                         979.\n                                                                         980.\n                                                                         981.\n SAVING THE LETTER YOU HAVE TYPED                                        982.\n+______ ___ ______ ___ ____ _____                                        983.\n                                                                         984.\n                                                                         985.\n      When you logged on to Wylbur, Wylbur reserved a space for          986.\n you inside the computer.  As you typed your letter, Wylbur              987.\n placed the typed lines in that reserved space.  That space is           988.\n yours as long as you are logged on to Wylbur, but once you              989.\n 'log off' (that is, once you end the Wylbur session) you lose your      990.\n special space.  So if you want to save the letter you typed,            991.\n you'll have to tell Wylbur to save it.  You tell Wylbur to save         992.\n your letter by using, appropriately enough, the SAVE command.           993.\n                                                                         994.\n      When you issue the SAVE command, you must tell Wylbur the          995.\n name of what you are saving.  In your case, you might name your         996.\n letter, 'LETTER'.  Or you might name it anything else.  There           997.\n is a problem though: what if some one else has a letter named           998.\n 'LETTER'.  How does Wylbur keep the names straight?                     999.\n1                                                Page 20                1000.\n                                                                        1001.\n                                                                        1002.\n      Wylbur keeps the names straight by giving you a special           1003.\n codeword made out of your employe number and account number.           1004.\n For example, if your employe number is z1234 and your account          1005.\n is 9999, then Wylbur creates a codeword for you that is                1006.\n 'Z.Z1234.A9999.'.  This code word will be added to whatever            1007.\n name you give your letter, and the result will be a unique name        1008.\n you can use for yourself.  (You don't have to worry about              1009.\n the code word.  Wylbur handles that automatically.)                    1010.\n                                                                        1011.\n        You may want to call your letter  'LETTER' or 'LETTER1'.        1012.\n You are free to use any name you like as long as the name              1013.\n begins with an alphabetic character and is 8 characters or             1014.\n less long, made up of alphabetic characters and numbers only.          1015.\n (You can make names longer than 8 characters if you                    1016.\n follow some special rules; see the section on Data Set Naming          1017.\n Conventions in the Wylbur Reference Manual.)  It's a good idea         1018.\n to name the things you save with a name that reminds you of            1019.\n what it is you saved.  For example, you just typed up a letter         1020.\n to 'Fred', so you might want to name that letter FLETTER or            1021.\n FREDLTR.  In two weeks when you've forgotten what you called           1022.\n this letter, you can have Wylbur list the names of everything          1023.\n you've saved, and when you see 'FLETTER' you'll remember it's          1024.\n the letter you typed to Fred.                                          1025.\n                                                                        1026.\n      Besides supplying a name for your letter, you must also           1027.\n tell Wylbur where you want to save it.   Wylbur saves                  1028.\n information on mechanical devices resembling multi-platter             1029.\n record players.  These devices are called disk packs.  Each            1030.\n disk pack has an individual name.  The names of some of the            1031.\n more commonly used packs at Rand are USECTL, USER01, USER02,           1032.\n etc.  Usually some one will supply you with the name of a disk         1033.\n pack to use.  If you haven't been supplied with a disk pack            1034.\n name, you can call User Services at Ext. 7764, and some one            1035.\n will tell you which pack has the most room on it.  (When you           1036.\n get more knowledgeable, you can find out for yourself by               1037.\n reading $PUBLIC.SPACE.  Read about $PUBLIC.SPACE in the                1038.\n Wylbur Reference Manual.)  Although you can use any of                 1039.\n several different disk packs, it's a good idea to keep                 1040.\n everything you save on the same pack.  That way you'll have no         1041.\n trouble remembering where your information is.                         1042.\n                                                                        1043.\n      Getting back to our example, let's suppose you are told to        1044.\n save your letter on the disk pack USER50.  You would then enter        1045.\n 'SAVE FLETTER ON USER50'.  Wylbur would save your letter and           1046.\n print out a message that it had been saved.  Your terminal             1047.\n printout looks like this:                                              1048.\n                                                                        1049.\n                    COMMAND ? save fletter on user50                    1050.\n                    \"FLETTER\" SAVED ON USER50                           1051.\n                    COMMAND ?                                           1052.\n                                                                        1053.\n      In this example Wylbur verified your letter was saved on          1054.\n USER50.  Wylbur might have printed an error message at this            1055.\n point.  If Wylbur does print an error message, you should find         1056.\n some one who is knowledgeable and ask them what to do.   Do not        1057.\n reply blindly to a message whose meaning is unclear.  It's             1058.\n possible to destroy something you typed in previously.                 1059.\n1                                                Page 21                1060.\n                                                                        1061.\n                                                                        1062.\n      When Wylbur saves your letter on a disk pack, Wylbur              1063.\n merely writes a copy of it onto that disk pack.  The original          1064.\n copy of the letter still exists in your reserved space inside          1065.\n the computer, and it is this copy that you will see when you           1066.\n issue the LIST command.  Remember, if you do additional work on        1067.\n the letter in your reserved space, you will want to save it            1068.\n again when you are done.                                               1069.\n                                                                        1070.\n      You'll learn  more about the SAVE command in Learning             1071.\n Session #2.   In particular, you'll learn about the REPLACE            1072.\n option of the SAVE command (i.e., SAVE FLETTER REPLACE), which         1073.\n is the form of the save command you'll use after the first             1074.\n time.  For now, use the SAVE command as shown above.                   1075.\n                                                                        1076.\n                                                                        1077.\n LOGGING OFF WYLBUR                                                     1078.\n+_______ ___ ______                                                     1079.\n                                                                        1080.\n                                                                        1081.\n       When you type in a short letter as you did today, you            1082.\n would normally correct your mistakes at the same time and              1083.\n produce a final error-free copy for your own use.   Since              1084.\n you're working on Wylbur for the first time, you're probably           1085.\n tired and want to quit for a while.  Easy enough.                      1086.\n                                                                        1087.\n       The first thing you do when you want to terminate a              1088.\n Wylbur session is issue the SAVE command so whatever you typed         1089.\n will be saved permanently.  After that, you issue the LOGOFF           1090.\n command to tell Wylbur you're done.   The process of ending a          1091.\n session is called logging off.                                         1092.\n                                                                        1093.\n       When you log off, you have one last option open to you.          1094.\n The place in the computer that Wylbur has reserved for you             1095.\n still contains what you've typed.  When you log off, Wylbur            1096.\n reminds you that you still have something in that space.  It's         1097.\n up to you to clear it out or at least let Wylbur know you want         1098.\n to discard it.  Since you've already saved a copy of it it on          1099.\n USER50, you can discard it now.  So when Wylbur asks you               1100.\n 'CLEAR OK?', you reply 'YES'.  Wylbur will then print out              1101.\n accounting information and log you off.  The printout at your          1102.\n terminal looks like this:                                              1103.\n                                                                        1104.\n                    COMMAND ? logoff                                    1105.\n                    CLEAR OK? yes                                       1106.\n                    EDITING TIME = 0.09 SECONDS.  I/O COUNT = 5         1107.\n                    ELAPSED TIME = 00.05.11                             1108.\n                    END OF SESSION                                      1109.\n                                                                        1110.\n                    MODEL?                                              1111.\n1                                                Page 22                1112.\n                                                                        1113.\n                                                                        1114.\n      You have now successfully completed a Wylbur session.  The        1115.\n letter you typed has been saved for posterity on USER50.  An           1116.\n hour from now, a day from now, or a month from now,  your              1117.\n letter will still be there.  (You do get charged for the space         1118.\n you use on a disk pack, so don't save things you don't need.)          1119.\n You're ready now for a coffee break and then Beginner's                1120.\n Session #2.                                                            1121.\n                                                                        1122.\n                                                                        1123.\n                                                                        1124.\n BEGINNER'S SESSION #2                                                  1125.\n+__________ _______ __                                                  1126.\n                                                                        1127.\n                                                                        1128.\n       In session #2 you will retrieve the letter you typed in          1129.\n session #1, correct your spelling mistakes, add new sentences,         1130.\n and polish up a final copy.  You'll learn more of Wylbur's             1131.\n vocabulary as well as how to list your letter on a high speed          1132.\n printer in the computer room.  When you finish session #2,             1133.\n you'll know how to use Wylbur effectively and confidently.             1134.\n                                                                        1135.\n                                                                        1136.\n LOGGING ON FOR SESSION #2                                              1137.\n+_______ __ ___ _______ __                                              1138.\n                                                                        1139.\n                                                                        1140.\n      You log on to session #2 exactly as you did for session           1141.\n #1.  Your printout at the terminal looks like this:                    1142.\n                                                                        1143.\n                    MODEL? 37                                           1144.\n                    RAND COMPUTATION CENTER   LINE xx mm/dd/yy          1145.\n                    USER? x1234                                         1146.\n                    ACCOUNT? 9999                                       1147.\n                    KEYWORD? x12                                        1148.\n                    COMMAND ? set uplow                                 1149.\n                    COMMAND ? set length 45                             1150.\n                    COMMAND ?                                           1151.\n                                                                        1152.\n                                                                        1153.\n RETRIEVING THE LETTER YOU SAVED IN THE EARLIER SESSION                 1154.\n+__________ ___ ______ ___ _____ __ ___ _______ _______                 1155.\n                                                                        1156.\n                                                                        1157.\n      Before we discuss how to retrieve your letter, we want to         1158.\n present more of Wylbur's vocabulary.  One term that you'll             1159.\n frequently see is 'data set'.  A data set is a collection of           1160.\n information.  Your letter, for example, is a data set.  You            1161.\n saved it with the name, FLETTER.  If you had typed in a long           1162.\n memorandum, it would have been a data set also.   The term             1163.\n 'data set' is a descriptive term for collection of data that           1164.\n are grouped together.                                                  1165.\n1                                                Page 23                1166.\n                                                                        1167.\n                                                                        1168.\n      The data sets you'll usually hear about are the data sets         1169.\n stored on disk packs.  There is one special data set though,           1170.\n that Wylbur creates for you.  That data set is stored in               1171.\n the area of the computer reserved for you when you log                 1172.\n on.  That data set is called your 'working data set'.  In              1173.\n session #1 when you typed in your letter, you typed it into            1174.\n your working data set.  And when you logged off and Wylbur             1175.\n responded  'CLEAR OK?', Wylbur was asking you if you were ready        1176.\n to discard your working data set.                                      1177.\n                                                                        1178.\n       The area of the computer that is reserved for you, your          1179.\n working data set, is of vital importance.  Everything Wylbur           1180.\n does, it does with the working data set.  Wylbur cannot list or        1181.\n modify a data set you have saved on a disk pack.  Wylbur can           1182.\n list or modify only that information which is in your working          1183.\n data set.                                                              1184.\n                                                                        1185.\n      Consequently you must now retrieve your data set (your            1186.\n letter) from the disk pack and put it into your working data           1187.\n set.  You do this with the USE command.   When you enter the           1188.\n USE command, Wylbur goes out to the disk pack and reads that           1189.\n data set into your working data set in the computer.  For              1190.\n example, to retrieve the letter you typed in session #1, you           1191.\n type 'USE FLETTER'.   Wylbur will then read FLETTER into your          1192.\n working data set.  When Wylbur is done, Wylbur will print              1193.\n 'COMMAND ?' again.  Your terminal printout reads:                      1194.\n                                                                        1195.\n                    MODEL? 37                                           1196.\n                    RAND COMPUTATION CENTER   LINE xx mm/dd/yy          1197.\n                    USER? x1234                                         1198.\n                    ACCOUNT? 9999                                       1199.\n                    KEYWORD? x12                                        1200.\n                    COMMAND ? set uplow                                 1201.\n                    COMMAND ? set length 80                             1202.\n                    COMMAND ? use fletter                               1203.\n                    COMMAND ?                                           1204.\n                                                                        1205.\n      Sometimes when you ask for your data set, Wylbur is busy          1206.\n handling other users, so Wylbur will issue a 'QUEUED' message.         1207.\n For example:                                                           1208.\n                                                                        1209.\n                    COMMAND ? use fletter                               1210.\n                    QUEUED                                              1211.\n                    QUEUED                                              1212.\n                    COMMAND ?                                           1213.\n                                                                        1214.\n      The QUEUED message is not important to you; it's merely           1215.\n Wylbur's way of telling you it's still working on your                 1216.\n request.                                                               1217.\n                                                                        1218.\n      When Wylbur reads your letter from the disk pack and puts         1219.\n a copy of it into your working data set, Wylbur does not               1220.\n destroy the copy of your letter that is on the disk pack.              1221.\n Wylbur merely copies it into your working data set.  The data          1222.\n set on USER50 called FLETTER remains as it was when you issued         1223.\n the SAVE command at the end of lesson #1.                              1224.\n1                                                Page 24                1225.\n                                                                        1226.\n                                                                        1227.\n LISTING YOUR DATA SET                                                  1228.\n+_______ ____ ____ ___                                                  1229.\n                                                                        1230.\n                                                                        1231.\n       Having brought your letter into your working data set,           1232.\n you can now proceed to correct the mistakes in it.  Normally           1233.\n the first thing you do after reading in a data set is to list          1234.\n part of it to make sure you have retrieved the right                   1235.\n information.  In your case, since your letter is short, you            1236.\n can list all of it.  Your terminal printout will read:                 1237.\n                                                                        1238.\n         MODEL? 37                                                      1239.\n         RAND COMPUTATION CENTER   LINE xx mm/dd/yy                     1240.\n         USER? x1234                                                    1241.\n         ACCOUNT? 9999                                                  1242.\n         KEYWORD? x12                                                   1243.\n         COMMAND ? set uplow                                            1244.\n         COMMAND ? set length 80                                        1245.\n         COMMAND ? use fletter                                          1246.\n         COMMAND ? list                                                 1247.\n            1.     Dear Fred,                                           1248.\n            2.                                                          1249.\n            3.     As I informedd you on the phone over                 1250.\n            4.     Tuesday the last batch for Skyhooks you              1251.\n            5.      sent us wdere defective.  At last count             1252.\n            6.     40 astronauts dropped into the Atlantic.             1253.\n            7.     Untily your quality control departments              1254.\n            8.     gets on the ball, we'll have to order our            1255.\n            9.     gets on the ball, we'll have to order our            1256.\n           10.     skyhooks from Acme INc.                              1257.\n           11.          Still your friend,                              1258.\n           12.                                                          1259.\n           13.          Josephine Blink                                 1260.\n           14.                                                          1261.\n           15.     P.S.  HOw could you do this to me!                   1262.\n         COMMAND ?                                                      1263.\n                                                                        1264.\n      Having assured yourself that your letter is in your               1265.\n working data set, you are free to use Wylbur editing commands          1266.\n to create a final product.                                             1267.\n                                                                        1268.\n                                                                        1269.\n DELETE COMMAND                                                         1270.\n+______ _______                                                         1271.\n                                                                        1272.\n                                                                        1273.\n      The function of the DELETE command is to delete 1 or more         1274.\n lines of Wylbur data.  In your letter, for example, you                1275.\n inadvertently typed in one line twice.  You now want to                1276.\n delete either line 8 or line 9 because you don't need both of          1277.\n them.  You can delete line 9 by entering 'DELETE 9'.  Your             1278.\n terminal printout looks like this:                                     1279.\n                                                                        1280.\n         COMMAND ? DELETE 9                                             1281.\n         COMMAND ?                                                      1282.\n1                                                Page 25                1283.\n                                                                        1284.\n                                                                        1285.\n      If you listed your working data set, you would see the            1286.\n following printout:                                                    1287.\n                                                                        1288.\n         COMMAND ? delete 9                                             1289.\n         COMMAND ? list 8/10                                            1290.\n            8.     gets on the ball, we'll have to order our            1291.\n           10.     skyhooks from Acme INc.                              1292.\n         COMMAND ?                                                      1293.\n                                                                        1294.\n      You can also use the DELETE command to delete several             1295.\n lines at the same time.  You could enter 'DELETE 3 9 13' and           1296.\n delete those three lines, or you could enter  'DELETE 3/13' and        1297.\n delete all the lines from 3 to 13.  You could also enter               1298.\n 'DELETE FIRST/LAST' and delete everything in your working data         1299.\n set.  Normally you would do this only by accident, and you             1300.\n would be very unhappy.                                                 1301.\n                                                                        1302.\n      A rather tragic error that happens to all of us every so          1303.\n often is that we mistype the DELETE command.  For example,             1304.\n instead of entering 'DELETE 3/10', we enter 'DELETE 3/100'.            1305.\n Wylbur obediently and instantaneously deletes every line from 3        1306.\n to 100.  If we had spent an hour typing in lines 11 to 100, and        1307.\n if we hadn't yet issued the SAVE command to save that information      1308.\n on a disk pack, we would sit down and cry.  We would have to           1309.\n type all that information again.  The lesson is clear: be              1310.\n careful when you use the DELETE command.                               1311.\n                                                                        1312.\n      You will discover that besides the DELETE command, there          1313.\n are innumerable ways of instantly negating hours or even days          1314.\n of work.  You will also discover (in fact you will read about          1315.\n it later in this lesson) that there are ways of safeguarding           1316.\n yourself against these kinds of disasters.  When you come to           1317.\n that part of this lesson, read it carefully.  Until then, use          1318.\n the DELETE command with caution.                                       1319.\n                                                                        1320.\n                                                                        1321.\n REPLACE COMMAND                                                        1322.\n+_______ _______                                                        1323.\n                                                                        1324.\n                                                                        1325.\n         The function of the REPLACE command is to replace              1326.\n Wylbur lines in their entirety.  In your letter, for example,          1327.\n line 5 contains several mistakes.  Rather than correcting each         1328.\n mistake individually (using a command which you'll learn about         1329.\n soon), it may be easier for you to use the REPLACE command and         1330.\n retype the entire line.  To replace line 5, you would enter            1331.\n 'REPLACE 5'.  Wylbur would then prompt you with '5.  ?'.   You         1332.\n then type in the new line as you want it.  Your terminal               1333.\n printout reads:                                                        1334.\n                                                                        1335.\n         COMMAND ? replace 5                                            1336.\n            5.   ? sent us were defective.  At last count               1337.\n         COMMAND ?                                                      1338.\n                                                                        1339.\n      If you listed line 5 you would see that it had been               1340.\n replaced with the line you just entered.                               1341.\n1                                                Page 26                1342.\n                                                                        1343.\n                                                                        1344.\n      There are other options of the REPLACE command.  To learn         1345.\n about them see the Wylbur Reference Manual.                            1346.\n                                                                        1347.\n                                                                        1348.\n INSERT COMMAND                                                         1349.\n+______ _______                                                         1350.\n                                                                        1351.\n                                                                        1352.\n       The INSERT command inserts new lines between old ones.           1353.\n In your letter, for example, you may want to add a sentence or         1354.\n two in the middle.  As a learning exercise, let's add a line           1355.\n between lines 6 and 7.  The most logical line number between 6         1356.\n and 7 is 6 1/2, but Wylbur doesn't work with fractions.  Wylbur        1357.\n will accept though, a decimal equivalent, like 6.5 or even 6.1         1358.\n or 6.2.   Wylbur will accept, in fact, 999 lines between 6 and         1359.\n 7 as long as those lines are in decimal format, i.e.  6.001 to         1360.\n 6.999.  To insert just one or two line numbers, you'll probably        1361.\n find it easier to use line numbers like 6.1, 6.2, 6.3, etc.  To        1362.\n insert line 6.1 into your letter, you would merely enter,              1363.\n 'INSERT 6.1' Wylbur would prompt you with ' 6.1  ?  '.  After          1364.\n you entered the new line of information, Wylbur would return to        1365.\n the command mode and prompt you with 'COMMAND ?'.  Your                1366.\n terminal printout looks like this:                                     1367.\n                                                                        1368.\n         COMMAND ? INSERT 6.1                                           1369.\n            6.1  ? (And one came down in New York City!)                1370.\n         COMMAND ?                                                      1371.\n                                                                        1372.\n                                                                        1373.\n       If you listed lines 5 through 7 after you enter                  1374.\n INSERT 6.1, your terminal printout would look like this:               1375.\n                                                                        1376.\n         COMMAND ? insert 6.1                                           1377.\n            6.1  ?  (And one came down in New York City!)               1378.\n         COMMAND ? list 5/7                                             1379.\n            6.     40 astronauts dropped into the Atlantic.             1380.\n            6.1  ? (And one came down in New York City!)                1381.\n            7.     Untily your quality control departments              1382.\n         COMMAND ?                                                      1383.\n                                                                        1384.\n                                                                        1385.\n      There is another option of the INSERT command, which you          1386.\n may read about in the Wylbur Reference Manual.                         1387.\n                                                                        1388.\n                                                                        1389.\n CHANGE COMMAND                                                         1390.\n+______ _______                                                         1391.\n                                                                        1392.\n                                                                        1393.\n      The CHANGE command is one of the most useful editing              1394.\n commands in Wylbur.  With the CHANGE command, you can change           1395.\n words, phrases, or sentences in one Wylbur line, or in every           1396.\n line in your working data set.  As an example, we'll use the           1397.\n change command to correct some errors in your letter.  (We             1398.\n could use the CHANGE command to correct all the errors, but we         1399.\n want to save some work for the MODIFY command which you'll find        1400.\n out about next.)                                                       1401.\n1                                                Page 27                1402.\n                                                                        1403.\n                                                                        1404.\n      You may recall that you typed 'Atlantic' instead of               1405.\n 'Pacific' in line 6.  An easy way to correct that mistake is to        1406.\n use the CHANGE command.  You would enter, CHANGE 'Atlantic' TO         1407.\n 'Pacific' IN 6.  The characters or words between the first pair        1408.\n of quote marks would be changed to the characters or words             1409.\n between the second pair of quote marks.  The two sets of               1410.\n characters need not be (and seldom are) the same length.  Your         1411.\n terminal printout would look like this:                                1412.\n                                                                        1413.\n         COMMAND ? change 'Atlantic' to 'Pacific' in 6                  1414.\n            6.     40 astronauts dropped into the Pacific.              1415.\n         COMMAND ?                                                      1416.\n                                                                        1417.\n                                                                        1418.\n      Note that Wylbur prints out the line after the line is            1419.\n changed, allowing you to see that the change was made correctly.       1420.\n                                                                        1421.\n      Also note that the information between the quote marks            1422.\n must be entered in upper and lower case characters exactly as          1423.\n you want it because Wylbur won't change it.                            1424.\n                                                                        1425.\n       The quote marks appear in pairs, one at the beginning and        1426.\n one at the end of each term.  If you are changing something            1427.\n that has a quote mark in the middle, use a double quote mark           1428.\n key at either end of the term.  Wylbur will accept the double          1429.\n quote mark key as a delimiter as well as the single quote mark         1430.\n key.  The double and single quote mark keys may not be mixed as        1431.\n delimiters however.  For example, to change 'IS NOT' to 'ISN'T'        1432.\n enter the following command:                                           1433.\n                                                                        1434.\n       COMMAND ? change 'IS NOT' to \"ISN'T\" in 3/10                     1435.\n                                                                        1436.\n                                                                        1437.\n                                                                        1438.\n THE RANGE OF A COMMAND                                                 1439.\n+___ _____ __ _ _______                                                 1440.\n                                                                        1441.\n                                                                        1442.\n      You may have noticed that most Wylbur commands require a          1443.\n line number or a list of line numbers.  These line numbers are         1444.\n called the 'range' of the Wylbur command. The range of a Wylbur        1445.\n command  can be just one line, or it can be all the lines in           1446.\n your working data set.   In many commands, as in the CHANGE            1447.\n command, if no range is specified, Wylbur uses the default             1448.\n range which is the entire working data set.  The fact that the         1449.\n range defaults to the entire working data set means you have to        1450.\n be careful when you use many of the commands, including the            1451.\n CHANGE command.                                                        1452.\n                                                                        1453.\n      By expanding the range of a command, you can make the             1454.\n command a great deal more powerful than it may appear to be at         1455.\n first glance.  The CHANGE command is a good example.  Suppose          1456.\n you had typed a letter that was five times as long as the              1457.\n letter in our example.  And suppose you're mind was on a trip          1458.\n to Europe.  And suppose in a five places you typed in                  1459.\n1                                                Page 28                1460.\n                                                                        1461.\n                                                                        1462.\n 'Atlantic' instead of 'Pacific'.  Then suddenly you woke up and        1463.\n realized that you had to change five lines in the letter.  You         1464.\n could change those lines by issuing a five CHANGE commands as          1465.\n you did above; or you could use one change command in several          1466.\n different ways.  If the line numbers to be changed were 6 14 57        1467.\n 89 113, you could enter, CHANGE 'Atlantic' TO 'Pacific' IN 6 14        1468.\n 57 89 113.  Or, if you knew that every time the word 'Atlantic'        1469.\n occurred in your letter, you wanted the word 'Pacific', you            1470.\n could let Wylbur do the work of finding the occurrences of             1471.\n 'Atlantic' and you could just enter CHANGE 'Atlantic' TO               1472.\n 'Pacific' IN FIRST/LAST.  Or, since Wylbur assumes you mean            1473.\n FIRST/LAST if you don't specify a range, you could just enter          1474.\n CHANGE 'Atlantic' TO 'Pacific' and Wylbur would proceed to             1475.\n search for every occurrence of the word Atlantic and change it.        1476.\n                                                                        1477.\n       There is a danger though.  Suppose you wanted to change          1478.\n only one occurence of the word 'Atlantic', at the same time            1479.\n leaving the word 'Atlantic' in twenty other places where it            1480.\n was correct and proper.  If you entered  CHANGE 'Atlantic' to          1481.\n 'Pacific' and left off a line number, Wylbur would proceed to          1482.\n change every occurrence of 'Atlantic' even those you wanted            1483.\n left alone.  The moral of the story is to use care when you            1484.\n enter commands.  Always specify the range you intend the               1485.\n command to work with.                                                  1486.\n                                                                        1487.\n                                                                        1488.\n MODIFY COMMAND                                                         1489.\n+______ _______                                                         1490.\n                                                                        1491.\n                                                                        1492.\n      The MODIFY command is one of the most useful of all of            1493.\n Wylbur's text editing commands.  You'll probably use it more           1494.\n frequently than the other commands.                                    1495.\n                                                                        1496.\n      The MODIFY command is used to change words or sentences in        1497.\n parts of a line.  For example, line 3 in your letter contains          1498.\n the word 'over' when you intended to type 'on'.   You could use        1499.\n the CHANGE command to change 'over' to 'on', but in this case          1500.\n let's use the MODIFY command.  The MODIFY command works in two         1501.\n parts.  First you specify the range you want to modify; and            1502.\n then you perform the modifications.  In our example you would          1503.\n first enter, ' MODIFY 3 '.   Wylbur would print line 3 in its          1504.\n entirety, and on the next line, the the word 'ALTERS ?'.  Your         1505.\n terminal printout would look like this:                                1506.\n                                                                        1507.\n         COMMAND ? modify 3                                             1508.\n            3.     As I informedd you on the phone over                 1509.\n          ALTERS ?                                                      1510.\n                                                                        1511.\n                                                                        1512.\n      You are now ready to make modifications to line 3 by              1513.\n typing in beneath the line the modifications you want to make.         1514.\n There are 3 types of modifications: insertions, deletions, and         1515.\n replacements.  In this example we want to do a replacement,            1516.\n replacing the word 'over' with the word 'on'.  You make a              1517.\n replacement  by typing in the letter 'R' exactly under the             1518.\n place where you want to start your replacement, and then you           1519.\n type in your replacement.  The new replacement must be the same        1520.\n length as the word or characters you replace.  In our case, the        1521.\n1                                                Page 29                1522.\n                                                                        1523.\n                                                                        1524.\n word 'on' is 2 characters shorter than the word 'over', so             1525.\n you'll have to add two blanks at the end.  After you type the          1526.\n letter 'R' followed by the word 'on' followed by 2 blanks and          1527.\n then a carriage return, Wylbur would respond by printing out           1528.\n the modified version of the line and then prompt you with the          1529.\n word 'ALTERS ?' again.  Your terminal output looks like                1530.\n this:                                                                  1531.\n                                                                        1532.\n         COMMAND ? modify 3                                             1533.\n            3.     As I informedd you on the phone over                 1534.\n          ALTERS ?                                 ron                  1535.\n            3.     As I informedd you on the phone on                   1536.\n          ALTERS ?                                                      1537.\n                                                                        1538.\n                                                                        1539.\n      At this point you can make additional modifications to the        1540.\n line by typing in an 'R' followed by the replacement characters        1541.\n or replacement words; or you can tell Wylbur you are done              1542.\n modifying the line by typing in a carriage return.  The                1543.\n carriage return is a signal to Wylbur that you have finished           1544.\n making alters to the line and you wish to terminate the MODIFY         1545.\n command.                                                               1546.\n                                                                        1547.\n      After you make modifications, you must always type a              1548.\n carriage return by itself in response to 'ALTERS ?' in order to        1549.\n terminate the MODIFY command.                                          1550.\n                                                                        1551.\n      In our case, we still have one more error in this sentence        1552.\n in the word 'informedd'.  This typographical error allows us to        1553.\n use another of the MODIFY options, the delete option.  You use         1554.\n the delete option by typing in a 'D' under the characters or           1555.\n words you want to delete.  (It's just a coincidence in this            1556.\n example that the MODIFY delete character is a 'D', and the             1557.\n character we want to delete is a 'd'.)   If you typed in a 'D'         1558.\n under the superfluous 'd' in 'informedd' and then typed a              1559.\n carriage return, Wylbur would respond once more by prompting           1560.\n you with 'ALTERS ?', and your terminal printout looks like             1561.\n this:                                                                  1562.\n                                                                        1563.\n                                                                        1564.\n         COMMAND ? modify 3                                             1565.\n            3.     As I informedd you on the phone over                 1566.\n          ALTERS ?                                 ron                  1567.\n            3.     As I informedd you on the phone on                   1568.\n          ALTERS ?              d                                       1569.\n            3.     As I informed you on the phone on                    1570.\n          ALTERS ?                                                      1571.\n                                                                        1572.\n                                                                        1573.\n       The sentence looks fine now, so you can signal Wylbur you        1574.\n are done with the MODIFY verb by typing in a carriage return           1575.\n only in response to 'ALTERS?'.  Your terminal printout looks           1576.\n like this:                                                             1577.\n1                                                Page 30                1578.\n                                                                        1579.\n                                                                        1580.\n         COMMAND ? modify 3                                             1581.\n            3.     As I informedd you on the phone over                 1582.\n          ALTERS ?                                 ron                  1583.\n            3.     As I informedd you on the phone on                   1584.\n          ALTERS ?              d                                       1585.\n            3.     As I informed you on the phone on                    1586.\n          ALTERS ?                                                      1587.\n         COMMAND ?                                                      1588.\n                                                                        1589.\n       Thus far you have used the MODIFY command to replace             1590.\n characters and delete characters in a line.   There is a third         1591.\n function of the MODIFY command, the insert function.   The             1592.\n insert function is similiar to the replace and delete                  1593.\n functions.  Using line number 4 as an example, suppose you             1594.\n wanted to add the word 'evening' after the word 'Tuesday'.  The        1595.\n most effective way of doing this would be to use the insert            1596.\n function of the MODIFY command.   In this case, you would enter        1597.\n 'MODIFY 4', and Wylbur would print out line 4 followed by the          1598.\n prompt 'ALTERS ?'.   You would then enter the letter 'I' in the        1599.\n place where you want to insert something, and then you would           1600.\n type the word you wanted to insert followed by a carriage              1601.\n return.  Wylbur would print out the line with the insertion and        1602.\n prompt you again with 'ALTERS ?'.  Satisfied with the result,          1603.\n you would press carriage return.  Your terminal printout looks         1604.\n like this:                                                             1605.\n                                                                        1606.\n         COMMAND ? modify 4                                             1607.\n            4.     Tuesday the last batch for Skyhooks you              1608.\n          ALTERS ?        i evening                                     1609.\n            4.     Tuesday evening the last batch for Skyhooks you      1610.\n          ALTERS ?                                                      1611.\n         COMMAND ?                                                      1612.\n                                                                        1613.\n      Note that the insertion goes before the character the 'I'         1614.\n is placed under.                                                       1615.\n                                                                        1616.\n      There is a combination of the delete and insert functions         1617.\n that is useful to know.  You can use the delete function along         1618.\n with the insert function to do replacements of unequal length.         1619.\n For example, suppose you have misgivings about the letter              1620.\n you're sending to Fred, and you want to elevate the style.  In         1621.\n line 8, for example, you want to change 'gets on the ball' to          1622.\n 'becomes more efficient'.  You could do this with several other        1623.\n Wylbur commands, but let's do it with the MODIFY command to            1624.\n show how the delete and insert functions can be combined               1625.\n together.  You first enter 'MODIFY 8' and then enter the letter        1626.\n 'D' under every character of the phrase 'gets on the ball' and         1627.\n then type in the letter 'I' followed by the new phrase.                1628.\n Satisfied with the result you type in carriage return.  The            1629.\n terminal prinout looks like this:                                      1630.\n                                                                        1631.\n         COMMAND ? modify 8                                             1632.\n            8.     gets on the ball, we'll have to order our            1633.\n          ALTERS ? ddddddddddddddddibecomes more efficient              1634.\n            8.     becomes more efficient, we'll have to order our      1635.\n          ALTERS ?                                                      1636.\n         COMMAND ?                                                      1637.\n1                                                Page 31                1638.\n                                                                        1639.\n                                                                        1640.\n      The end result is the replacement of a string of                  1641.\n characters with another string of characters of a different            1642.\n length.  One last hint before we leave the MODIFY command: you         1643.\n don't have to type in D's under every character you want to            1644.\n delete.  Type in a 'D' under the first and last character to be        1645.\n deleted, and Wylbur will delete everything in between.                 1646.\n                                                                        1647.\n      You should be aware that the insert function of the MODIFY        1648.\n command is considerably different from the INSERT command.  You        1649.\n might look at the INSERT command again and note the difference.        1650.\n                                                                        1651.\n                                                                        1652.\n A REVIEW OF SESSION #2                                                 1653.\n+_ ______ __ _______ __                                                 1654.\n                                                                        1655.\n                                                                        1656.\n      Session #2 began when you retrieved the letter you wrote          1657.\n in session #1.  You used the USE command to retrieve the letter        1658.\n from a disk pack into your working data set.  You listed the           1659.\n data set using the LIST command, and then you began to correct         1660.\n your mistakes using Wylbur's editing commands.                         1661.\n                                                                        1662.\n      You used the DELETE command to delete one line from your          1663.\n letter.                                                                1664.\n                                                                        1665.\n      You used the REPLACE command to replace a line with one           1666.\n you typed correctly.                                                   1667.\n                                                                        1668.\n      You used the INSERT command to insert a new line between          1669.\n two existing lines.                                                    1670.\n                                                                        1671.\n      You used the CHANGE command to change a word you had              1672.\n mistyped.                                                              1673.\n                                                                        1674.\n      Finally you used the MODIFY command to replace a word,            1675.\n delete a character, insert a word, and replace an entire phrase        1676.\n with another phrase.                                                   1677.\n                                                                        1678.\n      You may have noticed by this time that many of the Wylbur         1679.\n editing commands produce the same results.  For example, you           1680.\n can always use the REPLACE command and replace an entire line,         1681.\n and you would never need to use the CHANGE or MODIFY commands.         1682.\n Or you could always use the CHANGE command and never use the           1683.\n REPLACE or MODIFY commands.   Similiarly you could use the             1684.\n MODIFY command exclusively, and never worry about how the              1685.\n REPLACE or CHANGE commands work.                                       1686.\n                                                                        1687.\n       Each of the Wylbur editing commands has a strong point           1688.\n though.  The REPLACE command is handy if you've really botched         1689.\n up a line, but the MODIFY command requires less work if the            1690.\n line needs only minor changes.   The CHANGE command comes into         1691.\n its own when a change is necessary to the same word or phrase          1692.\n in twenty or thirty different places.  Each command has its own        1693.\n place.                                                                 1694.\n1                                                Page 32                1695.\n                                                                        1696.\n                                                                        1697.\n      At first you'll probably be happy enough to get your work         1698.\n done no matter which command you use.  But as you get to know          1699.\n Wylbur, you'll grow increasing lazy.  And when you get lazy,           1700.\n you'll benefit greatly by browsing through the Wylbur Reference        1701.\n Manual.  A large amount of information is contained there that         1702.\n could not be presented in this learning guide.                         1703.\n                                                                        1704.\n      Another valuable thing to do when you become lazy, is to          1705.\n sit down with a more knowledgeable person at a Wylbur terminal         1706.\n and watch that person do her work.  An experienced Wylbur user         1707.\n frequently cannot tell you the shortcuts she has learned but she       1708.\n can usually demonstrate them in the course of her normal job.          1709.\n                                                                        1710.\n                                                                        1711.\n MORE WYLBUR COMMANDS                                                   1712.\n+____ ______ ________                                                   1713.\n                                                                        1714.\n                                                                        1715.\n       If you have some familiarity with the commands you've            1716.\n used thus far, you're in a good position to utilize Wylbur             1717.\n effectively.  There a few more Wylbur commands that are useful         1718.\n to know about though.  You may not need them every day, but            1719.\n when you do need them, they're indispensable.  We'll present           1720.\n them in their basic form and leave it to you to read more about        1721.\n them in the reference section when you have the time.                  1722.\n                                                                        1723.\n                                                                        1724.\n COPY COMMAND                                                           1725.\n+____ _______                                                           1726.\n                                                                        1727.\n                                                                        1728.\n      The COPY command copies existing lines into another place         1729.\n in your working data set.  When you use the COPY command, you          1730.\n always end up with 2 copies of the line or lines.  As an               1731.\n example, suppose you decided to remove the P.S. in your letter         1732.\n and make it part of the body of the letter.  You could do this         1733.\n by entering 'COPY  15 to 10.1' and then 'DELETE 15'.  If you           1734.\n used the MODIFY command to remove the 'P.S.', and listed the           1735.\n results, your terminal printout would look like this:                  1736.\n1                                                Page 33                1737.\n                                                                        1738.\n                                                                        1739.\n         COMMAND ? list 8/last                                          1740.\n            8.     gets on the ball, we'll have to order our            1741.\n           10.     skyhooks from Acme INc.                              1742.\n           11.          Still your friend,                              1743.\n           12.                                                          1744.\n           13.          Josephine Blink                                 1745.\n           14.                                                          1746.\n           15.     P.S.  HOw could you do this to me!                   1747.\n         COMMAND ?  copy 15 to 10.1                                     1748.\n         COMMAND ?  list 8/last                                         1749.\n            8.     gets on the ball, we'll have to order our            1750.\n           10.     skyhooks from Acme INc.                              1751.\n           10.1    P.S.  HOw could you do this to me!                   1752.\n           11.          Still your friend,                              1753.\n           12.                                                          1754.\n           13.          Josephine Blink                                 1755.\n           14.                                                          1756.\n           15.     P.S.  HOw could you do this to me!                   1757.\n         COMMAND ?  modify 10.1                                         1758.\n           10.1    P.S.  HOw could you do this to me!                   1759.\n          ALTERS ? r      Ho                                            1760.\n           15.           How could you do this to me!                   1761.\n          ALTERS ?                                                      1762.\n         COMMAND ? delete 15                                            1763.\n         COMMAND ? list 8/last                                          1764.\n            8.     gets on the ball, we'll have to order our            1765.\n           10.     skyhooks from Acme INc.                              1766.\n           10.1          How could you do this to me!                   1767.\n           11.          Still your friend,                              1768.\n           12.                                                          1769.\n           13.          Josephine Blink                                 1770.\n           14.                                                          1771.\n                                                                        1772.\n                                                                        1773.\n      You may wonder about the modification where you entered           1774.\n 'r     Ho'.  In effect you replaced the first 6 characters with        1775.\n blanks and then replaced the 'H' with another 'H', and then            1776.\n replaced the upper case 'O' with a lower case 'o'.  As you can         1777.\n see, replacement characters are always one character to the            1778.\n right because you type the 'r' under the first character you           1779.\n want to replace.                                                       1780.\n                                                                        1781.\n      This example shows one way of moving a line (or several           1782.\n lines) to some other location.  First you use the COPY command         1783.\n to copy the line or paragraph where you want it.  Then you list        1784.\n the line in the new location and verify it's where you want it.        1785.\n Once you're sure you've moved it where you want it, you use the        1786.\n DELETE command to remove the original line or lines.                   1787.\n                                                                        1788.\n      The COPY command has another variation which is                   1789.\n invaluable.  The COPY command can be used to copy lines and            1790.\n paragraphs from a data set on a disk pack into your working            1791.\n data set.  For example, suppose you wished to include in your          1792.\n letter to Fred, some data on the advertised strength of                1793.\n1                                                Page 34                1794.\n                                                                        1795.\n                                                                        1796.\n skyhooks versus the tested strength after ten days' use.  You          1797.\n typed this data perhaps a week ago and saved it on disk pack           1798.\n USER50 under the name SKYDATA.  To include this data in your           1799.\n letter you would enter the following command:                          1800.\n                                                                        1801.\n        COMMAND ?  copy first/last to end from skydata                  1802.\n        67. - LAST LINE                                                 1803.\n        COMMAND ?                                                       1804.\n                                                                        1805.\n      What has occurred is that Wylbur has read in lines                1806.\n FIRST/LAST of data set SKYDATA on disk pack USER50, and placed         1807.\n those lines at the end of your working data set.  There were 52        1808.\n lines of information in SKYDATA, and consequently your letter          1809.\n now has 67 lines to it.                                                1810.\n                                                                        1811.\n       You can guess from the above example that you can also           1812.\n copy part of the data set SKYDATA into the middle of your              1813.\n letter.  For example, you can enter, 'COPY  3/14 TO 13.001             1814.\n FROM SKYDATA'.   Wylbur would then copy lines 3,4,5...14               1815.\n into your letter as lines 13.001, 13.002, 13.003...  13.012.           1816.\n                                                                        1817.\n                                                                        1818.\n MOVE COMMAND                                                           1819.\n+____ _______                                                           1820.\n                                                                        1821.\n                                                                        1822.\n      The MOVE command functions a great deal like the COPY             1823.\n command in that it also copies a line or lines of Wylbur data          1824.\n from one place to another.  The MOVE command though, deletes           1825.\n the original line or lines.   For example, you could have used         1826.\n the MOVE command above instead of the COPY command, and you            1827.\n wouldn't have had to use the DELETE command because the                1828.\n original lines would have been deleted automatically.  The             1829.\n command you entered would be:                                          1830.\n                                                                        1831.\n                 COMMAND ? move 15 to 10.1                              1832.\n                 COMMAND ?                                              1833.\n                                                                        1834.\n      In general, you use the MOVE command when you are sure you        1835.\n want a line moved and not copied.  If you are unsure of what           1836.\n you're doing, a COPY and a subsequent DELETE command may be            1837.\n better for you.                                                        1838.\n                                                                        1839.\n      Note that the MOVE command cannot be used to get                  1840.\n information from a data set on a disk pack.  Only the COPY             1841.\n command can do that.                                                   1842.\n1                                                Page 35                1843.\n                                                                        1844.\n                                                                        1845.\n COLLECT COMMAND                                                        1846.\n+_______ _______                                                        1847.\n                                                                        1848.\n                                                                        1849.\n      You've used the COLLECT command several times already, so         1850.\n you know what it does.  Essentially, it allows you to go from          1851.\n the command mode to the collect mode.   There is an option to          1852.\n the COLLECT command that you haven't seen yet.  You can, if you        1853.\n wish, begin collecting lines of Wylbur text at some point other        1854.\n than line 1.  For example, if you decided to add another               1855.\n paragraph to your letter just past line 10.1, you could do it          1856.\n by entering the command  'COLLECT  10.2' or 'COLLECT 10.111'.          1857.\n Wylbur would then prompt you with the line number and proceed          1858.\n to increment the lines proportionally to the value you specified.      1859.\n Your terminal printout looks like this:                                1860.\n                                                                        1861.\n                                                                        1862.\n         COMMAND ?  list 10/11                                          1863.\n           10.     skyhooks from Acme INc.                              1864.\n           11.          Still your friend,                              1865.\n         COMMAND ?  collect 10.111                                      1866.\n           10.111?  And I'd like to add at this point                   1867.\n           10.112?                                                      1868.\n                                                                        1869.\n                                                                        1870.\n      You could continue to enter lines of text now until you           1871.\n got to line 10.999, and then you would have to stop.  You could        1872.\n enter more lines then, but first you would have to use the             1873.\n NUMBER command (you'll learn about the NUMBER command next).           1874.\n                                                                        1875.\n      To summarize the COLLECT command, if you start a new              1876.\n working data set, you merely enter COLLECT and you then begin          1877.\n collecting with line number 1.  If you already have some lines         1878.\n in your working data set and you enter COLLECT without                 1879.\n specifying line numbers, you'll start collecting at the end of         1880.\n your working data set.  If you specify a range with the COLLECT        1881.\n command, you'll start collecting at that line number, and the          1882.\n increments that Wylbur uses for line numbers will depend on the        1883.\n number you supply in the COLLECT command.  For example, if you         1884.\n enter COLLECT 10.1,  Wylbur will prompt you with line numbers          1885.\n 10.1, 10.2, 10.3, etc.  If you enter COLLECT 10.01, Wylbur will        1886.\n prompt you with 10.01, 10.02, 10.03, etc.                              1887.\n                                                                        1888.\n                                                                        1889.\n                                                                        1890.\n NUMBER COMMAND                                                         1891.\n+______ _______                                                         1892.\n                                                                        1893.\n                                                                        1894.\n      The NUMBER command renumbers your working data set.               1895.\n Normally you'll use the NUMBER command to get rid of the funny         1896.\n numbers you've created by inserting, copying, and moving.  In          1897.\n your letter for example, you've delete line number 9 and               1898.\n1                                                Page 36                1899.\n                                                                        1900.\n                                                                        1901.\n created a line number 6.1 and 10.1.   There's no particular            1902.\n problem with these line numbers, except they just aren't neat          1903.\n and orderly.  You may want to renumber the lines in your               1904.\n working data set by using the NUMBER command.  If you listed           1905.\n part of your letter before and after you renumbered, your              1906.\n terminal printout would look like this:                                1907.\n                                                                        1908.\n         COMMAND ? list 6/11                                            1909.\n            6.     40 astronauts dropped into the Atlantic.             1910.\n            6.1    (And one came down in New York City!)                1911.\n            7.     Untily your quality control departments              1912.\n            8.     gets on the ball, we'll have to order our            1913.\n           10.     skyhooks from Acme INc.                              1914.\n           10.1          How could you do this to me!                   1915.\n           11.          Still your friend,                              1916.\n         COMMAND ?  number                                              1917.\n         15. - LAST LINE                                                1918.\n         COMMAND ?  list 6/12                                           1919.\n            6.     40 astronauts dropped into the Atlantic.             1920.\n            7.     (And one came down in New York City!)                1921.\n            8.     Untily your quality control departments              1922.\n            9.     gets on the ball, we'll have to order our            1923.\n           10.     skyhooks from Acme INc.                              1924.\n           11.           How could you do this to me!                   1925.\n           12.          Still your friend,                              1926.\n         COMMAND ?                                                      1927.\n                                                                        1928.\n       There are other options of the NUMBER command.  You              1929.\n can read about them in the Wylbur Reference Manual.                    1930.\n                                                                        1931.\n                                                                        1932.\n ALIGN COMMAND                                                          1933.\n+_____ _______                                                          1934.\n                                                                        1935.\n                                                                        1936.\n      The ALIGN command is used to make the lines in your               1937.\n working data set the same size.  That is, the ALIGN command            1938.\n adds words to the end of short lines to make them as long as           1939.\n the long lines.   After the ALIGN comand has executed, every           1940.\n line in your letter or memorandum is about the same size.              1941.\n We'll use part of your letter as an example.                           1942.\n                                                                        1943.\n      When you typed your letter, you typed in lines of about 40        1944.\n characters in length.  Suppose now you wanted to make the lines        1945.\n about 50 characters.  You would do this by entering                    1946.\n ' ALIGN  9/15 LENGTH 50 '.  If you listed the body of your             1947.\n letter before and after you entered the ALIGN command, your            1948.\n printout would look like this:                                         1949.\n1                                                Page 37                1950.\n                                                                        1951.\n                                                                        1952.\n     COMMAND ? list 9/15                                                1953.\n        9.          As I informed you over the phone on                 1954.\n       10.     Tuesday, the last batch of skyhooks you                  1955.\n       11.     sent us were defective.  At last count 4                 1956.\n       12.     astronauts dropped into the Pacific.  Until              1957.\n       13.     your quality control department gets on                  1958.\n       14.     the ball, we'll have to order our skyhooks               1959.\n       15.     from Acme Inc.                                           1960.\n     COMMAND ? align 9/15 length 50                                     1961.\n     COMMAND ? list 9/15                                                1962.\n        9.          As I informed you over the phone on Tuesday,        1963.\n       10.     the last batch of skyhooks you sent us were              1964.\n       11.     defective.  At last count 4 astronauts dropped           1965.\n       12.     into the Pacific.  Until your quality control            1966.\n       13.     department gets on the ball, we'll have to order         1967.\n       14.     our skyhooks from Acme Inc.                              1968.\n     COMMAND ?                                                          1969.\n                                                                        1970.\n                                                                        1971.\n      The ALIGN command moves words from line to line until the         1972.\n maximum number of words have been fitted on each line, given           1973.\n the length you specified in the command.  When alignment is            1974.\n complete, the extra line numbers are deleted.  In this case,           1975.\n line number 15 was deleted because there were no words in it.          1976.\n                                                                        1977.\n       The ALIGN command has many rules governing what it will          1978.\n do, and the easiest way to discover what these rules are is to         1979.\n use the command on some test material.   (You can also read the        1980.\n Wylbur Reference Manual, but that's not half as much fun.) One         1981.\n of the rules of the ALIGN command which you do have to know, is        1982.\n that lines beginning with one or more blanks act as stop lines.        1983.\n That is, when the ALIGN command finds a line beginning with a          1984.\n blank, the ALIGN command assumes that the line is the start of         1985.\n a paragraph and consequently does not move any words from the          1986.\n beginning of that line to any of the preceding lines.                  1987.\n                                                                        1988.\n      Another rule of the ALIGN command is that it will create          1989.\n new line numbers if it doesn't have enough lines to fit the            1990.\n words on.  For example, if you aligned the above test paragraph        1991.\n into lines with a maximum length of 15 characters, the ALIGN           1992.\n command would be forced to create some new line numbers to hold        1993.\n all of the little lines you have created.  The line numbers            1994.\n would probably go from 9 to 12 and then to 12.1, 12.2, etc.            1995.\n                                                                        1996.\n      One word of caution about the ALIGN command: since it             1997.\n changes your working data set dramatically, you're wise to save        1998.\n a copy of your working data set before you start aligning              1999.\n material and then align your text paragraph by paragraph.  If          2000.\n you make a mistake (for example, leave off the LENGTH option),         2001.\n you can go back to your original copy and start over again.            2002.\n1                                                Page 38                2003.\n                                                                        2004.\n                                                                        2005.\n JUSTIFY COMMAND                                                        2006.\n+_______ _______                                                        2007.\n                                                                        2008.\n                                                                        2009.\n       The JUSTIFY command performs the same function as the            2010.\n ALIGN command.  In addition, the JUSTIFY command spaces the            2011.\n words within lines such that the last word extends to the very         2012.\n end of the line.  The JUSTIFY command does this by adding              2013.\n blanks between the words in the sentences.  For example, to use        2014.\n the JUSTIFY command on your letter instead of the ALIGN command        2015.\n you would enter, 'JUSTIFY 9/14 LENGTH 50'; if you listed the           2016.\n results, your terminal printout would look like this:                  2017.\n                                                                        2018.\n  COMMAND ? justify 9/14 length 50                                      2019.\n  COMMAND ? list 9/14                                                   2020.\n     9.          As I informed you over the phone on  Tuesday,          2021.\n    10.     the  last  batch  of  skyhooks  you  sent  us were          2022.\n    11.     defective.  At last  count  4  astronauts  dropped          2023.\n    12.     into  the  Pacific.   Until  your  quality control          2024.\n    13.     department gets on the ball, we'll have  to  order          2025.\n    14.     our skyhooks from Acme Inc.                                 2026.\n  COMMAND ?                                                             2027.\n                                                                        2028.\n       The JUSTIFY command makes your copy look cleaner.  Be            2029.\n careful in using the command though, as you can ruin your              2030.\n working data set if you use it incorrectly.  To be on the safe         2031.\n side, you should save a copy of the working data set before you        2032.\n begin justifying, and then justify one paragraph at a time             2033.\n until you are satisifed with the results.                              2034.\n                                                                        2035.\n       If you have lines in your working data set that have one         2036.\n or more blanks in front of them, and these lines do not start          2037.\n paragraphs, you will have trouble with the JUSTIFY command.            2038.\n The JUSTIFY command will produce strange results in the area of        2039.\n these lines.  You can learn more about the JUSTIFY command in          2040.\n the Wylbur Reference Manual.                                           2041.\n                                                                        2042.\n                                                                        2043.\n SYSTEM FAILURE.  WYLBUR CRASHES.                                       2044.\n+______ ________  ______ ________                                       2045.\n                                                                        2046.\n                                                                        2047.\n      Every so often some part of the computer system doesn't           2048.\n function as it's suppose to, and all sorts of dire things              2049.\n happen.  What you'll usually notice as you sit at your                 2050.\n terminal, is that the terminal is unresponsive.  No matter what        2051.\n you type, Wylbur doesn't answer.   The best thing to do at this        2052.\n point is to sit at your terminal and wait for the system to            2053.\n come back up.  Eventually, you'll see the 'MODEL ?' query, and         2054.\n you can log on again.                                                  2055.\n                                                                        2056.\n      When you finish logging on, you'll see, if you're lucky,          2057.\n the message 'RECOVERY COMPLETED'.  This means that Wylbur saved        2058.\n your working data set before Wylbur crashed, and you can               2059.\n continue where you left off.                                           2060.\n1                                                Page 39                2061.\n                                                                        2062.\n                                                                        2063.\n       More frequently though, when the system crashes you lose         2064.\n everything you've typed in since the last time you issued a            2065.\n 'SAVE' command.   Consider how you would feel if you just spent        2066.\n 3 hours typing a 200 page memorandum and then the system               2067.\n crashed.  If you hadn't bothered to save the memorandum                2068.\n periodically on disk, you would be faced with the prospect of          2069.\n typing the 200 page memorandum over again.  An experienced             2070.\n Wylbur user can tell you that typing a memorandum the second           2071.\n time is an onerous chore.                                              2072.\n                                                                        2073.\n      The moral is: save your working data set after every              2074.\n significant increment of work.                                         2075.\n                                                                        2076.\n      What a signigicant increment of work is you'll have to            2077.\n decide for yourself.  Many people save their work every 20             2078.\n minutes, particularly if they are fast typists.                        2079.\n                                                                        2080.\n      One important thing to remember after system crashes is to        2081.\n SET UPLOW and SET LENGTH.   You do not get these automatically.        2082.\n It's rather common to be so upset by a system crash, that you          2083.\n forget to SET UPLOW, and then you type for an hour and have to         2084.\n go back and type it in still a third time.  (That's the reason         2085.\n some of the offices have locks on them--on the outside.)               2086.\n                                                                        2087.\n                                                                        2088.\n SAVING A BACKUP DATASET                                                2089.\n+______ _ ______ _______                                                2090.\n                                                                        2091.\n                                                                        2092.\n      You've been warned often enough to save your working data         2093.\n set in a backup data set as you work along.  The way you do            2094.\n this is by issuing the SAVE command.  First, you select a name         2095.\n for your backup data set.  You can name it BACKUP or TEMPLETT          2096.\n or LULUBELL.  The name is unimportant as long as you remember          2097.\n that the data set is for backup purposes.                              2098.\n                                                                        2099.\n      The first time you issue the SAVE command, you must give          2100.\n the disk pack name, e.g., SAVE LULUBELL ON USER50.  After this         2101.\n initial save, you do not need to specify the disk pack, but you        2102.\n must specify the REPLACE option, e.g., SAVE LULUBELL REPLACE.          2103.\n (You'll learn more about the SAVE command and the REPLACE              2104.\n option later.)                                                         2105.\n                                                                        2106.\n      For example, to save a backup copy of FLETTER after you           2107.\n have typed 10 or so lines, you can enter:                              2108.\n                                                                        2109.\n              COMMAND ? save lulubell on user50                         2110.\n              \"LULUBELL\" SAVED ON USER50                                2111.\n              COMMAND ?                                                 2112.\n                                                                        2113.\n                                                                        2114.\n      Then to save a backup copy of FLETTER later, after you've         2115.\n typed line 15 or so, enter:                                            2116.\n                                                                        2117.\n              COMMAND ? save lulubell replace                           2118.\n              \"LULUBELL\" REPLACED ON USER50                             2119.\n              COMMAND ?                                                 2120.\n1                                                Page 40                2121.\n                                                                        2122.\n                                                                        2123.\n                                                                        2124.\n      Once you save your working data set, you are somewhat             2125.\n protected against system failure and your own mistakes.  For           2126.\n example, if you inadvertently delete half of your working data         2127.\n set, you can read in the backup copy you saved twenty minutes          2128.\n ago and start over from that point.  You bring in a copy of            2129.\n your backup by entering the USE command with the CLEAR option,         2130.\n e.g., USE LULUBELL CLEAR.  The CLEAR option tells Wylbur to            2131.\n clear out your old working data set or what's left of it, and          2132.\n replace it with LULUBELL.  For example:                                2133.\n                                                                        2134.\n              COMMAND ? use lulubell clear                              2135.\n              COMMAND ?                                                 2136.\n                                                                        2137.\n                                                                        2138.\n       Note that LULUBELL is a backup of your working data set          2139.\n and not a copy of FLETTER, except perhaps at the beginning of          2140.\n the day when you make your first backup.  As the day progresses        2141.\n the backup copy of your working data set in LULUBELL becomes           2142.\n increasingly different from the copy of your letter saved in           2143.\n FLETTER.  Considering this, you may find it wise to save a             2144.\n backup copy of FLETTER  (a third backup) under some other name.        2145.\n Then when you eventually replace FLETTER at the end of the day,        2146.\n you still have an old copy of it in case you inadvertently             2147.\n deleted part of your working data set just before you saved it         2148.\n as FLETTER.                                                            2149.\n                                                                        2150.\n                                                                        2151.\n ABBREVIATIONS                                                          2152.\n+_____________                                                          2153.\n                                                                        2154.\n                                                                        2155.\n       Almost all Wylbur commands have abbreviations.  You can          2156.\n read about them under the topic, Abbreviations, in the Wylbur          2157.\n Reference Manual.  You use the abbreviations exactly as you            2158.\n would the full command.  For example, LIST FIRST/LAST can also         2159.\n be entered as L F/L.  Other handy abbreviations are MOD for            2160.\n MODIFY; CH for CHANGE; and DEL for DELETE.                             2161.\n                                                                        2162.\n                                                                        2163.\n LISTING YOUR WORKING DATA SET ON A HIGH SPEED PRINTER                  2164.\n+_______ ____ _______ ____ ___ __ _ ____ _____ _______                  2165.\n                                                                        2166.\n                                                                        2167.\n      After you've typed a long time at the terminal, your              2168.\n working data set becomes very large.  To list your working data        2169.\n set at the terminal takes forever because the terminal prints          2170.\n slowly.  Fortunately there's another way.  In addition to              2171.\n the LIST command you're familiar with, there is also the LIST          2172.\n OFFLINE command.                                                       2173.\n1                                                Page 41                2174.\n                                                                        2175.\n                                                                        2176.\n      When you issue the LIST OFFLINE command, Wylbur prints a          2177.\n copy of your working data set on a high speed printer in the           2178.\n computer room.  Sometimes the data set is printed before you           2179.\n can walk to the computer room to pick it up.  Sometimes you            2180.\n have to wait a few minutes.  Usually within ten minutes, your          2181.\n output is waiting for you on the counter in the Computer Room,         2182.\n room 1307.                                                             2183.\n                                                                        2184.\n       Suppose for example, that the letter you just aligned and        2185.\n justifed was 1000 lines long.  It would be a perfect candidate         2186.\n for listing offline.  To list it offline, you would enter              2187.\n 'LIST OFFLINE PAL xxx  UPLOW'.   The 'xxx' stands for your             2188.\n 'pal box' number.  If you haven't been given one, you should           2189.\n enter the first initial of your last name.  This pal box letter        2190.\n will be printed on the front of your computer listing.  Your           2191.\n employe number will also be printed on your computer listing.          2192.\n When you enter the computer room, you will find the listings           2193.\n arranged on the long counter by pal box identifiers, with              2194.\n alphabetic identifiers first followed by the numeric                   2195.\n identifiers.  If you can't find your output on the long                2196.\n counter, you should look in the pal boxes across the room.             2197.\n There is a pal box there with your number or alphabetic                2198.\n identifier on it.                                                      2199.\n                                                                        2200.\n      If you had entered the LIST OFFLINE command above, your           2201.\n terminal printout would look like this:                                2202.\n                                                                        2203.\n                 COMMAND ?  list offline uplow pal a                    2204.\n                 nnn IS YOUR JOB NUMBER                                 2205.\n                 COMMAND ?                                              2206.\n                                                                        2207.\n      The 'nnn' is the number of your job as it goes through the        2208.\n computer.   If you go into the computer room and can't find            2209.\n your output, ask the computer operator about job 'nnn'.                2210.\n Possibly it's been held up somewhere by unusual conditions.            2211.\n                                                                        2212.\n       The  LIST OFFLINE command has numerous options.  You             2213.\n should read about them in the Wylbur Reference Manual.  Some of        2214.\n the options you won't understand at this point but many of them        2215.\n you'll find useful.  In the example above, you used the UPLOW          2216.\n option.  This tells Wylbur that you want to list your working          2217.\n data set in both upper and lower case letters when it's listed         2218.\n on the high speed printer.  If you had omitted UPLOW, you would        2219.\n have gotten your data set printed in upper case letters only.          2220.\n                                                                        2221.\n                                                                        2222.\n SAVING YOUR DATA SET                                                   2223.\n+______ ____ ____ ___                                                   2224.\n                                                                        2225.\n                                                                        2226.\n      At the end of lesson #2 as in lesson #1, you will want to         2227.\n save your working data set.   You save it by entering the SAVE         2228.\n command in the same way that you did in lesson #1.  There is           2229.\n one difference though: your data set called FLETTER now exists         2230.\n on disk pack USER50.  It's true that the version of FLETTER on         2231.\n1                                                Page 42                2232.\n                                                                        2233.\n                                                                        2234.\n USER50 is the old one with the mistakes, but Wylbur doesn't            2235.\n know that.  Wylbur will discover when it goes to save FLETTER,         2236.\n that there is another FLETTER on USER50.  Wylbur will warn you         2237.\n about it, and you will have to reply 'YES'  when Wylbur asks           2238.\n you 'REPLACE?'.  Your terminal printout will look like this:           2239.\n                                                                        2240.\n         COMMAND ?  save fletter                                        2241.\n         \"FLETTER\" ALREADY EXISTS ON USER50                             2242.\n         TO REPLACE, REPLY \"YES\"                                        2243.\n         REPLACE? yes                                                   2244.\n         \"FLETTER\" REPLACED ON USER50                                   2245.\n         COMMAND ?                                                      2246.\n                                                                        2247.\n                                                                        2248.\n      Note that you didn't have to tell Wylbur which disk pack          2249.\n FLETTER was on (i.e. SAVE FLETTER ON USER50).  Wylbur keeps a          2250.\n catalog of all data sets, and whenever you reference a data            2251.\n set, Wylbur searches to see where it's at.  Wylbur does this to        2252.\n safeguard you against saving two data sets with the same name.         2253.\n In the example above, if you had replied 'NO' to the 'REPLACE?'        2254.\n prompt, Wylbur wouldn't have replaced FLETTER.  The copy of            2255.\n FLETTER on the disk pack would remain unchanged; and the copy          2256.\n of FLETTER in your working data set would remain unchanged.            2257.\n You would still have to save your working data set somewhere.          2258.\n You might call this version something else, like FLETR2, and           2259.\n once again issue a save command (e.g., SAVE FLETR2 ON USER50).         2260.\n                                                                        2261.\n      There is an option on the SAVE command that eliminates            2262.\n Wylbur's prompt for replacing.  If you add the word REPLACE to         2263.\n the SAVE command, you're telling Wylbur that you know there is         2264.\n a version of FLETTER out there on a disk pack, and you want to         2265.\n scratch that version and replace it with the version in your           2266.\n working data set.  In our example, you would enter 'SAVE               2267.\n FLETTER REPLACE'.  Your terminal printout would then read:             2268.\n                                                                        2269.\n        COMMAND ? save fletter replace                                  2270.\n        \"FLETTER\" REPLACED ON USER50                                    2271.\n        COMMAND ?                                                       2272.\n                                                                        2273.\n                                                                        2274.\n LOGGING OFF WYLBUR                                                     2275.\n+_______ ___ ______                                                     2276.\n                                                                        2277.\n                                                                        2278.\n      You log off Wylbur in session #2 exactly as you did in            2279.\n session #1.  Or, if you're sure you have saved your working            2280.\n data set, you can enter 'LOGOFF CLEAR' and Wylbur will not ask         2281.\n you about clearing the working data set.                               2282.\n1                                                Page 43                2283.\n                                                                        2284.\n                                                                        2285.\n HOW IT ALL GOES TOGETHER                                               2286.\n+___ __ ___ ____ ________                                               2287.\n                                                                        2288.\n                                                                        2289.\n      You're aware now of what Wylbur can do for you.  You can          2290.\n type a letter or memorandum, make corrections, save it on a            2291.\n disk pack, and list it offline on a high speed printer.  So            2292.\n where do you begin?                                                    2293.\n                                                                        2294.\n       An experienced Wylbur user proceeds about as follows:            2295.\n typing in the first draft, the experienced user corrects only a        2296.\n few mistakes, usually those that she can correct by backspacing        2297.\n and retyping.  Spelling and grammatical errors are left in the         2298.\n copy.  Long lines of text and short lines of text are also left        2299.\n in the copy.  The experienced user saves the working data set          2300.\n every 15-20 minutes in a backup data set (for example with the         2301.\n name BACKUP), and then at the end of his session, she saves it         2302.\n one last time (for example with the name of MYDATA) before             2303.\n listing it offline on a high speed printer.                            2304.\n                                                                        2305.\n      When she returns after lunch or in the morning, she reads         2306.\n the offline listing and makes sure it's what she thinks it             2307.\n should be.  Then using the offline listing, she marks in               2308.\n corrections in red pencil, circling the line numbers that need         2309.\n to be changed.  Then she logs on to Wylbur, saves a copy of the        2310.\n data set in a second backup (for example named BACKUP2), and           2311.\n then enters the corrections she has marked on the listing.             2312.\n                                                                        2313.\n      When she's done with her corrections, she issues the              2314.\n NUMBER command and then lists the last line.  If the number of         2315.\n lines seems about right, she saves the dataset back in the             2316.\n original (for example named MYDATA).  She's then ready to              2317.\n proceed to add additional text, if any, to her data set.               2318.\n Eventually, she'll list the data set offline on special paper,         2319.\n unnumbered, to get a listing that appears almost hand typed.           2320.\n (To find out how to get a listing of this sort, read about the         2321.\n LIST OFFLINE command in the Wylbur Reference Manual.)                  2322.\n                                                                        2323.\n      The value of the two backup data sets is as follows: the          2324.\n data set named BACKUP will be used if the system crashes or if         2325.\n our experienced Wylbur user accidentally deletes a large               2326.\n portion of her working data set.   If either of these disasters        2327.\n happen, then our experienced user will lose at the most 20             2328.\n minutes of work because she can read in the copy of her working        2329.\n data set she saved as BACKUP 20 minutes ago.                           2330.\n                                                                        2331.\n       The data set in BACKUP2 will be used only if a more              2332.\n serious disaster occurs.  For example, if our experienced user         2333.\n accidentally deleted almost all of her working data set and            2334.\n then, unaware of what she had done, she saved this fragmented          2335.\n working data set in both BACKUP and MYDATA at the end of the           2336.\n1                                                Page 44                2337.\n                                                                        2338.\n                                                                        2339.\n day, she would be in  real trouble.  When she read her offline         2340.\n listing the next morning, she would cry a while and then read          2341.\n in the data set she saved in BACKUP2 and repeat all of the             2342.\n previous day's work (except the bad deletion presumably).  She         2343.\n would have lost one day's work, but she wouldn't have lost two         2344.\n days' work or even a week's work--which has happened to some           2345.\n people.  So remember to save BACKUP2 at the beginning of a             2346.\n session after you've read your listing and are sure you know           2347.\n what it is you're backing up.                                          2348.\n                                                                        2349.\n                                                                        2350.\n A FINAL REVIEW                                                         2351.\n+_ _____ ______                                                         2352.\n                                                                        2353.\n                                                                        2354.\n      Session #2 began when you read in the data set FLETTER and        2355.\n began to update it.  You used a variety of Wylbur commands             2356.\n (DELETE, REPLACE, INSERT, CHANGE, MODIFY) to correct your              2357.\n spelling and typographical errors.  Then you used the  COPY            2358.\n command to copy a line from one place to another.  You learned         2359.\n that the MOVE command did much the same thing: it copies a             2360.\n line to a new place and then deletes the original line.  You           2361.\n found out that the COLLECT command had an option that allowed          2362.\n you to add paragraphs in the middle of existing lines, and you         2363.\n found you could make your line numbers orderly by using the            2364.\n NUMBER command.                                                        2365.\n                                                                        2366.\n      Then you got fancy with the ALIGN and JUSTIFY commands,           2367.\n and at the same time learned that it's wise to save your               2368.\n working data set freqently in a back up data set in case you           2369.\n make a serious mistake or the computer crashes.   Along the way        2370.\n you discovered that you could list your working data set on a          2371.\n high speed printer in the computer room by using the LIST              2372.\n OFFLINE command.  And lastly you issued the SAVE command and           2373.\n discovered that Wylbur keeps a catalog of your data sets, and          2374.\n that you have to tell Wylbur to scratch the existing copy              2375.\n before it will save a new version.                                     2376.\n                                                                        2377.\n                                                                        2378.\n CONGRATULATIONS!                                                       2379.\n+________________                                                       2380.\n                                                                        2381.\n       If you've had the patience to stick with it until now,           2382.\n you'll soon be using Wylbur with efficiency and pleasure.              2383.\n Wylbur is not easy to learn (as you've found out), but the             2384.\n longer you practice at it, the better you'll get.  Some day            2385.\n some one will ask you a question about Wylbur and you'll answer        2386.\n it and discover you have become a Wylbur expert.  Good luck.           2387.\n./ ADD NAME=MANUAL   0100-80225-80225-1323-10776-10776-00000-$SYS11  00\n1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n         Title:          ITEL/WYLBUR Manual\n\n         Date:           June 1, 1980\n\n         Abstract:       This  manual  is   an   introduction   to\n                         ITEL/WYLBUR as well as a reference manual\n                         for that system.\n\n         Published by:   The ITEL Corporation, Data Processing Center\n                         55 Fransico St., San Francisco, California\n\n\n         Version:        Version  2\n\n\n1TABLE OF CONTENTS                                                  TOFC. - 1\n\n                         Table of Contents\n\n\n\n   I.  Introduction to WYLBUR..................................I-1\n       A.  Account Numbers...................................I.A-1\n       B.  The Selectric Terminal............................I.B-1\n       C.  WYLBUR Modes - COLLECT-COMMAND....................I.C-1\n           1.  COMMAND Mode..................................I.C-1\n               a.  Upper and Lower Case......................I.C-1\n               b.  Separators................................I.C-1\n               c.  Short Forms...............................I.C-2\n               d.  Changing Modes............................I.C-2\n           2.  COLLECT Mode..................................I.C-3\n               a.  Upper and Lower Case......................I.C-3\n               b.  Changing Modes............................I.C-3\n       D.  Use of Non-Typing Keys in WYLBUR..................I.D-1\n           1.  Carriage Return...............................I.D-1\n           2.  Backspace.....................................I.D-1\n           3.  Attention (ATTN)..............................I.D-2\n           4.  Shift-Key.....................................I.D-3\n       E.  WYLBUR Files - ACTIVE-EXTERNAL-EXEC...............I.E-1\n       F.  Sign-On Procedure.................................I.F-1\n       G.  Sign-Off Procedure................................I.G-1\n\n  II.  Creating a File......................................II.A-1\n       A.  Global Parameters................................II.A-1\n           1.  Case.........................................II.A-1\n           2.  TABS.........................................II.A-2\n               a.  Selectric Terminals......................II.A-2\n               b.  Setting Tabs - Long Form.................II.A-3\n               c.  Setting Tabs - Short Form................II.A-3\n               d.  CRT Terminals............................II.A-4\n               e.  Clearing Tabs............................II.A-4\n           3.  DELTA........................................II.A-5\n               a.  Setting Delta with the COLLECT Command...II.A-5\n               b.  Setting Delta with the SET Command.......II.A-5\n           4.  LENGTH.......................................II.A-6\n           5.  TERSE-VERBOSE................................II.A-6\n       B.  COLLECT..........................................II.B-1\n           1.  Specifying Line Numbers......................II.B-1\n           2.  MERGE........................................II.B-2\n           3.  Clear........................................II.B-2\n       C.  Line Numbers.....................................II.C-1\n           1.  Constants....................................II.C-1\n           2.  Arithmetic Expressions.......................II.C-1\n           3.  Symbolic Line Numbers........................II.C-1\n           4.  Referring to Line Numbers....................II.C-2\n       D.  The LIST Command (Short form: L).................II.D-1\n           1.  UNNUMBERED...................................II.D-1\n           2.  MARKER.......................................II.D-2\n           3.  CLEAN........................................II.D-3\n           4.  NOTEXT.......................................II.D-3\n           5.  Explicit Range...............................II.D-4\n           6.  Associative Range............................II.D-4\n           7.  Explicit and Associative Range...............II.D-4\n1TABLE OF CONTENTS                                                  TOFC. - 2\n\n\n       E.  The NUMBER Command...............................II.D-5\n           1.  Specifying a Starting Line...................II.D-5\n           2.  Specifying Delta.............................II.D-5\n           3.  Scaling......................................II.D-6\n           4.  Range........................................II.D-6\n III.  Editing an Active File..............................III.A-1\n       A.  Specifying Ranges...............................III.A-1\n           1.  Explicit Range..............................III.A-2\n           2.  Explicit Range-Count Field..................III.A-2\n           3.  Associative Range...........................III.A-3\n               a.  Use of Quotes...........................III.A-3\n               b.  Specifying Ordinal Occurrence...........III.A-4\n               c.  Specifying Column Position..............III.A-4\n               d.  Specifying Null Lines...................III.A-4\n           4.  Negative Associative Range..................III.A-4\n       B.  The DELETE, INSERT, and REPLACE Commands........III.B-1\n           1.  DELETE (Short Form: DEL or D)...............III.B-1\n               a.  Deleting a Single Line..................III.B-1\n               b.  Deleting an Explicit Range..............III.B-1\n               c.  Deleting an Associative Range...........III.B-1\n               d.  LIST....................................III.B-1\n           2.  INSERT (Short Form: INS or I)...............III.B-2\n               a.  Inserting One Line......................III.B-2\n               b.  Inserting Multiple Lines-Explicit Range.III.B-2\n               c.  Inserting Multiple Lines-DITTO..........III.B-2\n               d.  Inserting Multiple Lines-COLLECT........III.B-3\n           3.  REPLACE (Short Form: REP)...................III.B-3\n               a.  LIST....................................III.B-4\n               b.  Explicit Range..........................III.B-4\n               c.  Associative Range.......................III.B-4\n               d.  DITTO Option............................III.B-5\n               e.  Using The ATTN Key......................III.B-5\n           4.  Alternate Short Forms of DEL, INS, REP......III.B-5\n       C.  The CHANGE Command (Short Form: CH).............III.C-1\n           1.  Position in Line............................III.C-2\n               a.  String Replacement......................III.C-2\n               b.  Column Replacement......................III.C-4\n               c.  Column Insertion........................III.C-5\n           2.  Search Range................................III.C-5\n           3.  The Replacement.............................III.C-7\n               a.  Quoted String...........................III.C-7\n               b.  Incremented Integer.....................III.C-7\n               c.  Transferred Replacement.................III.C-9\n       D.  The COPY and MOVE Commands......................III.D-1\n           1.  COPY........................................III.D-1\n               a.  Copy an Explicit Range..................III.D-2\n               b.  Specifying Delta........................III.D-3\n               c.  MERGE...................................III.D-4\n               d.  Copy an Associative Range...............III.D-4\n               e.  Copy to the End of a File...............III.D-6\n               f.  Copy FROM an External File..............III.D-6\n                   1)  Copy All of an External File........III.D-6\n                   2)  Copy Part of an External File.......III.D-6\n               g.  Copy TO the Beginning of a File.........III.D-7\n               h.  Copy FROM an External File and COMBINE..III.D-7\n1TABLE OF CONTENTS                                                  TOFC. - 3\n\n\n           2.  MOVE........................................III.D-7\n               a.  Move an Explicit Range of Lines.........III.D-8\n               b.  Move an Associative Range of Lines......III.D-8\n               c.  MERGE...................................III.D-8\n       E.  The ALIGN Command...............................III.E-1\n           1.  Aligning an Explicit Range..................III.E-2\n           2.  Using a MARKER..............................III.E-2\n           3.  NUMBER......................................III.E-3\n           4.  Setting LENGTH in the Align Command.........III.E-3\n           5.  SPACE Option................................III.E-4\n           6.  Aligning Indented Material..................III.E-4\n           7.  Indenting using the EVEN Option.............III.E-4\n              a.  Indenting Paragraphs.....................III.E-5\n              b.  Hanging Indentations.....................III.E-5\n       G.  The EDIT and MODIFY Commands....................III.G-1\n           1.  EDIT (Short Form:  EDI or E)................III.G-1\n               a.  Range...................................III.G-2\n               b.  NOLIST..................................III.G-2\n               c.  SINGLE..................................III.G-2\n               d.  Terminating the EDIT Command............III.G-3\n                   1.  Terminating all Lines Remaining\n                       in the Range........................III.G-3\n                   2.  Terminating the Current Line Only...III.G-3\n                   3.  Terminating the EDITS...............III.G-3\n               e.  Changing from EDIT to MODIFY............III.G-4\n               f.  The ATTN Key in EDIT....................III.G-4\n                   1.  ATTN................................III.G-4\n                   2.  $ATTN...............................III.G-4\n                   3.  @ATTN...............................III.G-4\n                   4.  \u00a2ATTN...............................III.G-4\n           2. The MODIFY Command (Short Form:  MOD or M)...III.G-5\n               a.  To Delete Characters from a Line--D.....III.G-6\n               b.  To Blank Characters in a Line--B........III.G-7\n               c.  Insert Characters in a Line--I..........III.G-7\n               d.  Replace Characters in a Line--R.........III.G-7\n               e.  Multiple Modifications in a LINE........III.G-8\n               f.  To Complete the Alteration Process......III.G-9\n               g.  NOLIST - N..............................III.G-9\n               h.  SINGLE - S.............................III.G-10\n               i.  Terminating the MODIFY Command.........III.G-10\n\n  IV.  Saving, Retrieving and Deleting a File...............IV.A-1\n       A.  SAVE.............................................IV.A-1\n           1.  VOLUME.......................................IV.A-2\n           2.  REPLACE/SCRATCH..............................IV.A-3\n           3.  Format.......................................IV.A-3\n           4.  NUMBERED.....................................IV.A-4\n           5.  ON CATLG.....................................IV.A-4\n               a.  Sequential Data Sets.....................IV.A-4\n               b.  Partitioned Data Sets....................IV.A-5\n           6.  RECATLG/UNCATLG..............................IV.A-5\n               a.  RECATLG..................................IV.A-5\n               b.  UNCATLG..................................IV.A-5\n           7.  CONDENSE - (PDS Only)........................IV.A-5\n1TABLE OF CONTENTS                                                  TOFC. - 4\n\n\n       B.  SCRATCH..........................................IV.B-1\n           1.  Scratching a Sequential Data Set.............IV.B-1\n           2.  Scratching a PDS Member......................IV.B-1\n           3.  Scratching a Cataloged Data Set..............IV.B-2\n           4.  Scratching a non-WYLBUR Data Set.............IV.B-2\n       C.  USE..............................................IV.C-1\n           1.  On VOLUME/CATLG..............................IV.C-1\n           2.  Clearing the Active File.....................IV.C-1\n       D.  Data Set Naming Conventions......................IV.D-1\n           1.  Your Data Sets...............................IV.D-1\n               a.  Sequential Data Sets.....................IV.D-1\n               b.  Partitioned Data Sets....................IV.D-1\n           2.  Your Group's Data Sets.......................IV.D-2\n               a.  Sequential Data Sets.....................IV.D-2\n               b.  Partitioned Data Sets....................IV.D-2\n           3.  Other WYLBUR Data Sets.......................IV.D-2\n               a.  Sequential Data Sets.....................IV.D-3\n               b.  Partitioned Data Sets....................IV.D-3\n               c.  SET USER and SET GROUP...................IV.D-3\n           4.  Non-WYLBUR Data Sets.........................IV.D-4\n           5.  Locating a Data Set..........................IV.D-4\n               a.  Locating Your Own Data Sets..............IV.D-5\n               b.  Locating Your Group's Data Sets..........IV.D-5\n               c.  Locating Data Sets of Other WYLBUR Users.IV.D-6\n               d.  Locating Non-WYLBUR Data Sets............IV.D-7\n           6.  Managing Your Data Sets......................IV.D-7\n               a.  PDS vs. Sequential Space.................IV.D-8\n               b.  CONDENSE (PDS only)......................IV.D-8\n               c.  Scratching Obsolete Data Sets............IV.D-9\n\n1TABLE OF CONTENTS                                                  TOFC. - 5\n\n\n   VI. Using the Central Computer through WYLBUR............VI.A-1\n       A.  LIST OFFLINE.....................................VI.A-1\n           1.  BIN..........................................VI.A-1\n           2.  PROJECT......................................VI.A-2\n           3.  (n) Positioning..............................VI.A-2\n           4.  CC or MC (Carriage Control)..................VI.A-2\n           5.  'Title'......................................VI.A-3\n           6.  NOEJECT......................................VI.A-3\n           7.  COPIES.......................................VI.A-3\n           8.  UPLOW........................................VI.A-3\n           9.  DARKLIST.....................................VI.A-3\n          10.  SC (Service Class)...........................VI.A-3\n          11.  ID...........................................VI.A-4\n          12.  DEST.........................................VI.A-4\n          13.  FORMS........................................VI.A-4\n       B.  PUNCH............................................VI.B-1\n           1.  RANGE........................................VI.B-1\n           2.  LIST.........................................VI.B-1\n           3.  EXEC.........................................VI.B-1\n           4.  List Options.................................VI.B-1\n           5.  ID Option....................................VI.B-1\n       C.  RUN..............................................VI.C-1\n           1.  JOBNAME......................................VI.C-1\n           2.  LIST Options.................................VI.C-1\n           3.  EXEC Option..................................VI.C-1\n           4.  CANCEL and Reject............................VI.C-1\n       D.  LOCATE...........................................VI.D-1\n       E.  HOLD and RELEASE.................................VI.E-1\n       F.  Getting Output at the Terminal...................VI.F-1\n       G.  Converting Card Decks to WYLBUR Files............VI.G-1\n\n   VII.  Summary of Commands.................................VII-1\n\n   VIII. Definition of Terms................................VIII-1\n\n   Appendix A--Short Forms of WYLBUR Command Words.........APP.A-1\n   Appendix B--Editing Hints...............................APP.B-1\n   Appendix C--User/System News............................APP.C-1\n       A.  User Suggestions................................APP.C-1\n       B.  News from WYLBUR................................APP.C-1\n1I. INTRODUCTION TO WYLBUR                                            I - 1\n\n\n I.  Introduction to WYLBUR\n\n\n WYLBUR is a computer system used as a text editor and remote job\n entry  facility.   Ordinarily  it  is  used  with  a   Selectric\n typewriter  terminal  (2741-type),  a  teletype  device or a CRT\n (cathode-ray tube:  Hazeltine, 2260, etc.).  This  text  editing\n facility can be used to create, modify, store and retrieve  text\n such  as  a  computer program, a letter or a dissertation.  This\n manual was created using WYLBUR.\n\n\n A person using WYLBUR can create and edit a computer program and\n its Job Control Language just as he would any other WYLBUR text.\n The computer program may be written in  any  language.   He  can\n then  insert  the  program  into the computer's input stream for\n processing as a normal batch job.\n\n This manual is designed to serve both  as  a  tutorial  for  the\n WYLBUR  system  and  also  as  a  reference text.  The first six\n sections of this manual will describe  the  most  commonly  used\n functions of WYLBUR.  Within the discussion of each command, the\n simple  form  will  be  discussed  first,  and  the options will\n follow.  After each paragraph  describing  an  operation,  there\n will  be an illustration showing the way it will look when it is\n typed out.  In these illustrations,  the  use  of  the  carriage\n return will be indicated by (CR).  Sections VII and VIII of this\n manual  are  intended  as  a  reference for knowledgeable WYLBUR\n users.  Commands will be discussed much more  briefly  in  those\n sections,  and  some  commands  will  be discussed only in those\n sections.\n1INTRODUCTION TO WYLBUR                                             I.A - 1\n\n\n\n A.  Account Numbers\n\n To  become a  WYLBUR  user  you need a  valid  ITEL  TSO USER ID\n which  may  be  obtained  by filing the appropriate forms at the\n Data Processing Center. You will be assigned as user ID begining\n with a $ followed by a unique  3 character idenfification repre-\n senting your  organization,  followed by a  two digit identifier\n representing your  unique  user  identification.   You must also\n select a  password to use to initailly logon that you may change\n during your first logon session.\n1INTRODUCTION TO WYLBUR                                             I.B - 1\n\n\n B.  The Selectric Terminal\n\n The Selectric typewriter terminal is a device which looks and is\n operated much like an  ordinary  electric  typewriter  with  one\n additional  key, ATTN (attention).  It can be linked to the CUCC\n computer system through a standard telephone line.  The terminal\n may be disconnected from  the  computer  by  flipping  a  toggle\n switch  from  COM  (communicate)  to  LCL  (local) and used as a\n standard typewriter  for  normal  office  tasks.   However,  the\n terminal  typewriters are different from ordinary typewriters in\n three respects:  the typeface may be different,  the  characters\n of  standard  Selectric  balls do not correspond to the keyboard\n (except on correspondence terminals), and they cost about $2500.\n When it is connected  to  the  computer  (COM)  and  the  WYLBUR\n program,  several keys have functions different from those of an\n ordinary typewriter.  The use of  these  keys  is  discussed  in\n Section I.D.\n\n The Selectric terminal typewriters have  the  Typamatic  feature\n which  permits  the repeat of a hyphen, underline, backspace, or\n space by holding the proper key down  with  a  steady  pressure.\n WYLBUR  can  use all of the characters on the keyboard of an IBM\n Selectric typewriter terminal  except  the  margin  release  key\n which has no effect on WYLBUR text.\n\n1INTRODUCTION TO WYLBUR                                             I.C - 1\n\n\n\n C.  WYLBUR Modes - COLLECT-COMMAND\n\n WYLBUR has two modes  of  operation,  called  COLLECT  mode  and\n COMMAND mode.\n\n COLLECT mode is used for accumulating lines of text  for  a  new\n file, or adding lines of text to an existing file.\n\n COMMAND mode is used to perform any other tasks such as  editing\n an existing file, or submitting a job to the central computer.\n\n\n You are in COMMAND mode whenever you are responding to a command\n prompt  (COMMAND?),  and  in  COLLECT  mode  whenever  you   are\n responding to a line number prompt  (1.  ?).\n\n     1. COMMAND Mode\n\n        The bulk of this manual deals with the rules and purposes\n        of WYLBUR Commands.\n\n\n        a. Upper and Lower Case\n\n           Case is of no importance in WYLBUR commands.  You  may\n           use   all   upper   or  lower  case  characters  or  a\n           combination.  WYLBUR always responds and prompts  with\n           upper case.\n\n        b. Separators\n\n           \u00e6 Blank, Comma, Equal Sign ( ,=)\n\n             WYLBUR will recognize a blank, comma, and equal sign\n             as equivalent  separators  in  any  command.   These\n             three LIST commands are equivalent:\n\n             COMMAND? LIST 2,3,4,5\n             COMMAND? LIST 2 3 4 5\n             COMMAND? LIST 2=3=4=5\n\n1INTRODUCTION TO WYLBUR                                             I.C - 2\n\n\n           \u00e6 Slash (/)\n\n             The slash  is  used to designate range.  The command\n\n             COMMAND?  LIST 2/5\n\n             means to list all lines from 2 to 5  inclusive.   It\n             is  not equivalent to any of the three LIST commands\n             shown above as there may  be  more  than  two  lines\n             between lines 2 and 5.  For example, lines 2.5, 3.5,\n             and 4.5 may also be present.\n\n           \u00e6 Semi-Colon (;)\n\n             A semi-colon stops  the  scan  of  a  command  line;\n             comments  may  follow  it.  If a command line begins\n             with a semi-colon, the whole line is a comment.   As\n             you will see later, this will only be useful in exec\n             files.\n\n             COMMAND? LIST 2/5 ; EXAMPLE OF LIST COMMAND\n\n        c. Short Forms\n\n           The short form (abbreviation) of each command is noted\n           along with its description.  A list of short forms can\n           be found in Appendix A, Short Forms.\n\n        d. Changing Modes\n\n           To change  from  COMMAND  mode  to  COLLECT  mode,  or\n           vice-versa,  press the ATTN key as the first character\n           in a line.\n\n           There is another way to change from COMMAND to COLLECT\n           mode.  Type the command COLLECT:\n\n           COMMAND?  COLLECT\n             1.      ?\n\n\n1INTRODUCTION TO WYLBUR                                             I.C - 3\n\n\n     2. COLLECT Mode\n\n        a. Upper and Lower Case\n\n           Any combination of upper and lower case may be used in\n           COLLECT mode.  However, all letters will be  converted\n           to upper case unless you use this command:\n\n           COMMAND?  SET UPLOW\n\n           Some terminals, such as CRT's, have  only  upper  case\n           letters.  The SET UPLOW command has no effect on these\n           terminals but is accepted as a legal command.\n\n\n        b. Changing Modes\n\n           To change from COLLECT to COMMAND mode, press the ATTN\n           key.\n\n1INTRODUCTION TO WYLBUR                                             I.D - 1\n\n\n\n D.  Use of Non-Typing Keys in WYLBUR\n\n The non-typing keys have special functions in  WYLBUR  that  are\n quite different from those on an ordinary typewriter.\n\n     1. Carriage Return (or CR)\n\n        This key returns the printing head to the left margin  as\n        on  any  typewriter,  but in WYLBUR it also indicates the\n        end of a line.  In COMMAND mode WYLBUR responds to a (CR)\n        with the appropriate response to the command, followed by\n        a prompt for the next  command,  or  a  prompt  for  more\n        information for the current command.  In COLLECT mode, it\n        is  the  signal  for  WYLBUR to prompt with the next line\n        number followed by  a  question  mark  so  that  you  may\n        continue to enter text.\n\n     2. Backspace\n\n        This key moves the printing head one space to  the  left,\n        and  erases whatever was in the space from the computer's\n        memory (but not from the paper on hardcopy terminals;  on\n        display terminals, characters will  be  erased  from  the\n        screen  only  after you have typed in the replacement for\n        that character).  A whole line of type can be erased from\n        the computer's memory by backspacing  over  it,  but  you\n        cannot erase characters in this manner from lines already\n        terminated  with  a carriage return (CR).  On Hazeltines,\n        backspacing is performed by simultaneously depressing the\n        CTRL  and  H  keys.   In  addition,  be  careful  not  to\n        backspace into  the  line  number  that  WYLBUR  prompted\n        because any characters subsequently typed in those spaces\n        will be lost.\n\n        A command called SET BACK changes  the  function  of  the\n        backspace  key so that an upper case backspace (shift and\n        backspace on 2741-type terminals), will backspace without\n        erasing and will enter a backspace  in  the  text.   This\n        makes  it  possible,  for  example, to have a WYLBUR text\n        containing underlined material.\n\n1INTRODUCTION TO WYLBUR                                             I.D - 2\n\n\n\n        If BACK is set on a Hazeltine-type terminal, CTRL + H  is\n        the  equivalent of an upper case backspace on a 2741-type\n        terminal and there  is  no  equivalent  to  a  lower-case\n        backspace.   When  underscores  are  typed  in  they will\n        appear to have erased the characters in  the  text.   The\n        text  and  underlining  have  been accepted by WYLBUR, it\n        just will not show up on the screen.  Also note  that  if\n        BACK  is  set on a Hazeltine, backspace (CTRL + H) cannot\n        be used to erase a character;  the  whole  line  must  be\n        retyped.   The  underlining would appear in output listed\n        at a hardcopy terminal.\n\n        In anything listed at the  central  computer,  the  upper\n        case  backspaces  appear  as  blanks  and the underscores\n        appear as characters after the succession of blanks.   To\n        have  underlining  appear  in text printed at the central\n        computer, see Appendix B.  The SET BACK  command  can  be\n        given in response to any COMMAND?  prompt from WYLBUR.\n\n\n     3. Attention (or ATTN)\n\n        The attention key (or 'break' button on ASCII  terminals)\n        may  be  used to change from COLLECT mode to COMMAND mode\n        and vice versa.  When the attention key is pressed before\n        any spaces or characters are typed, WYLBUR first responds\n        by typing *** or ...  .\n\n        COMMAND?  ***(ATTN)\n           1.  ? PRESSING THE ATTN KEY PUT ME (CR)\n           2.  ? IN COLLECT MODE. (CR)\n           3.  ? NOW THAT I AM FINISHED, (CR)\n           4.  ? I WANT TO LEAVE COLLECT MODE. (CR)\n           5.  ? ***(ATTN)\n        COMMAND?\n\n        When this file is listed on the terminal, there will  not\n        be a line 5.\n\n        This key has an additional function.  You can  erase  the\n        entire  line you are working on by pressing the attention\n        key instead of using the backspace key.  WYLBUR will then\n        prompt with the same line number, if you are  in  COLLECT\n        mode,  or  'COMMAND?'  if  you are in COMMAND mode.  This\n        will not erase any text previously ended with a  carriage\n        return.\n\n          22.  ? THIS LINE IS A MESS ***(ATTN)\n          22.  ?\n\n        The ATTN key may be used with several special  characters\n        in  the  EDIT  and  MODIFY commands to do certain special\n        tasks.  See Section III.G, for more  information  on  the\n        use of the attention key in these commands.\n\n1INTRODUCTION TO WYLBUR                                             I.D - 3\n\n\n\n     4. Shift Key\n\n        There is a distinction between the effect  of  the  shift\n        key at the terminal and its effect on a WYLBUR text.  The\n        shift  key  operates  just as on any typewriter as far as\n        the terminal copy is concerned, but  its  effect  on  the\n        WYLBUR text depends on the WYLBUR mode and on the command\n        SET  UPLOW  and  SET  UPPER.   The use of this key has no\n        effect during COMMAND mode and all alphabetic  characters\n        are  converted  to  upper  case.   In COLLECT mode, it is\n        treated in two ways.  If you have used  the  command  SET\n        UPLOW,  WYLBUR  will accept upper and lower case letters.\n        If  you  have  not  used  this  command,  all  alphabetic\n        characters are converted to upper case.   UPPER  case  is\n        the  default  so it is necessary to do a SET UPLOW if you\n        wish to have lower case letters as  part  of  your  text.\n        (Reminder:  all JCL must be in upper case only.)\n\n        The  above  applies  to  \"uplow\"  terminals   only.    On\n        \"upper-case\"   only  terminals,  although  SET  UPLOW  is\n        accepted as a command, the use of the shift key is not at\n        all the same, except when used  for  upper  case  special\n        characters,  such as '#', '<', '>', etc.  Otherwise there\n        is no correspondence between the shifted letter you  type\n        and  the character displayed on the screen and understood\n        by WYLBUR.\n\n1INTRODUCTION TO WYLBUR                                             I.E - 1\n\n\n E.  WYLBUR Files - ACTIVE-EXTERNAL-EXEC\n\n The term file is used to describe any collection of text  (which\n might  be a letter, a list of data, a dissertation or report, or\n a computer program).\n\n A file is called an ACTIVE file while it is held in  the  active\n part  of the computer's memory and you are working on it.  While\n in COLLECT mode, you may accumulate  lines  of  text  into  this\n file;  this  is  the  only  file  to  which  you  may  make text\n modifications.\n\n A file is called an EXTERNAL file when it is stored on  a  disk.\n A detailed explanation of the use of external files may be found\n in Section IV.\n\n There is another type of active file called  an  EXEC  (execute)\n file,  which is stored in the same way as an active file, but in\n another  part  of  the  computer's  memory.   This  file  simply\n consists of a set of WYLBUR commands which,  when  the  file  is\n executed, will be executed  in the order in which they appear in\n the file.\n\n If a file is a complete program with JOB card and JCL, it can be\n submitted for execution with a WYLBUR command from the terminal,\n and you may use other WYLBUR commands to check on  the  progress\n of the job and retrieve your output. (See Section VI.)\n\n\n\n1INTRODUCTION TO WYLBUR                                             I.F - 1\n\n\n\n F.  Sign-On Procedure\n\n In order to use the WYLBUR system, you must succesfully  sign-on\n at  a terminal.  When the procedure is completed, you will be in\n COMMAND mode.  The procedure described below  is  for  hardwired\n (directly  connected  to  the  computer)  terminals  only.   For\n information on signing on to dial-up terminals, see  the  User's\n Manual Appendix, WYLBUR.\n\n     1. All lines to the computer at CUCC are controlled by TPMON\n        (a program  which  enables  users  to  connect  with  our\n        teleprocessing  systems).   When  you  begin your session\n        TPMON will ask for your CUCC project number and the  name\n        of  the  system you wish to use (unless the previous user\n        has signed off with the command  'LOGON').   This  number\n        must  be  valid  to ASP.  Type your project number in the\n        overprinted spaces provided by  TPMON  and  hit  carriage\n        return  (CR) after you type in the name of the system you\n        wish to use.\n\n           TPMON:  PROJECT NUMBER,SYSTEM?  WWWWWWW\n+                                          XXXXXXX\n+                                          GGGGGGG\n           user:                           UR00000,WYLBUR (CR)\n\n        At this  point  if  you  are  on  a  teletype   or   CRT\n        terminal  you  will  be connected with the WYLBUR system\n        and you may proceed from 2  below.   If  you  are  on  a\n        2741-type terminal,  the  keyboard will unlock and await\n        additional  information  on  the  type of connection you\n        wish   to   make.   Since   APL    and    correspondence\n        typeballs   are  extremely  different  from the standard\n        2741   typeball,   WYLBUR   will  make   the   necessary\n        translations if it knows which you are using.\n\n        If you are using an APL typeball you must now type:\n\n            A (CR)\n\n        If you are on  a  correspondence  terminal  (this  has  a\n        slightly  different  keyboard  from  a  standard 2741 and\n        looks more like a regular typewriter) type:\n\n            C (CR)\n\n        If you are  using  a  standard  typeball  on  a  standard\n        2741-type terminal you may simply type:\n\n            (CR)\n\n\n1INTRODUCTION TO WYLBUR                                             I.F - 2\n\n\n\n     2. After connecting to WYLBUR  through  TPMON,  WYLBUR  will\n        begin   its   own  signon  procedure.   As  part  of  the\n        procedure, WYLBUR asks you a series of questions so  that\n        the  validity  of your account number can be checked.  If\n        you do not receive a series of questions immediately that\n        means that your terminal is not equipped with the REVERSE\n        BREAK hardware feature.  You must flip the toggle  switch\n        from  COM  to  LCL  and then back again.  After this, you\n        must hit the RETURN key and WYLBUR will begin  its  LOGON\n        routine.   Do  not hit the ATTN key or you will be signed\n        off and have to establish connection to the system again.\n        For further  information,  see  the  CUCC  User's  Manual\n        Appendix, WYLBUR.\n\n        The system will then type:\n\n            CUCC LINE x hh:mm:ss mm/dd/yy\n\n        This signifies that the  terminal  is  ready  to  receive\n        information.  x is your line number for this session.  It\n        may be used in the TO and SHOW LINE commands described in\n        Section  VII.  The current time is given as hour (24-hour\n        clock), minute, and second - hh:mm:ss  and  the  date  is\n        given as month, day and year - mm/dd/yy.\n\n        The system may follow this with another line  giving  the\n        message  of  the  day (also called the broadcast message)\n        which includes  any  special  information  of  which  you\n        should be aware.\n\n        The  system  will  then  type  the  following  series  of\n        prompts, one at a time and await your  response  to  each\n        before  typing the next.  In this example, an appropriate\n        response follows the ?:\n\n            TERMINAL?   S23(CR)\n            INITIALS?   ABC(CR)\n            GROUP?      UR(CR)\n            KEYWORD?    XYZ(CR)\n+                       MMM\n\n\n1INTRODUCTION TO WYLBUR                                             I.F - 3\n\n\n\n        Let us look  at  each  prompt.   When  the  system  types\n        TERMINAL?,  answer  by  typing  the terminal ID.  (If the\n        command LOGON was typed by the previous user, WYLBUR will\n        not prompt for a new terminal ID).  The terminal ID is  a\n        three-character  field,  where  the  first character is a\n        letter and the next two are numbers.  The letters A and H\n        have special significance (as described below), otherwise\n        you may use any alphabetic character.\n\n        Ann - Terminal is hard copy teletype compatible.\n\n        Hnn - Terminal is display teletype (e.g., Hazeltine)  and\n        the  user  wants  screen paging.  (See SET CRT command in\n        Section VII).\n\n            TERMINAL?  S23 (CR)\n\n        Now you are asked for your initials, the user ID assigned\n        to you by the Computer Center.\n\n            INITIALS?  ABC(CR)\n\n        Next you will be asked to identify  yourself  further  by\n        giving  your group ID which was assigned at the same time\n        as the initials.\n\n            GROUP?  UR(CR)\n\n        If you have a keyword, you will be asked to supply it  to\n        determine  whether you have a right to use the group   ID\n        and initials you have just given.  If you do not  have  a\n        keyword  assigned,  WYLBUR will not prompt for one.  As a\n        protection feature, 2741-type (hardcopy)  terminals  will\n        overprint  the  keyword  with  a  series of miscellaneous\n        characters.\n\n              KEYWORD? XYZ(CR)\n+                      MMM\n              COMMAND?\n\n        This prompt from the system indicates  that  the  sign-on\n        procedure  is  complete, and the terminal is now ready to\n        accept WYLBUR commands.\n\n1INTRODUCTION TO WYLBUR                                             I.F - 4\n\n\n\n        If an invalid response is  given  to  any  of  the  above\n        prompts, you will be asked to try again.\n\n        To terminate the sign-on procedure, strike the  attention\n        key in response to any of the system's prompts.\n\n        You may bypass  the  INITIALS?   and  GROUP?   prompt  by\n        entering that information before it is requested.\n\n              TERMINAL ? S23,ABC,UR\n           or\n              TERMINAL ? S23\n              INITIALS ? ABC,UR\n\n        Blanks or equal signs may replace  the  commas,  and  the\n        initials  and  group may be typed as ABC$UR.  The keyword\n        prompt, if there is one, cannot be bypassed.\n\n        If you wish to use a terminal just  as  someone  else  is\n        preparing  to sign off, you may sign on without repeating\n        the whole sign-on procedure provided that the other  user\n        has not yet signed off.  Type:\n\n              COMMAND?  LOGON\n\n        WYLBUR will print all the statistics  from  the  previous\n        session  and  prompt  for  your  initials.   You may then\n        continue as for any sign-on.  Since you will not be going\n        through TPMON (TPMON designates the project number to  be\n        billed  for  each session) the time for this session will\n        be charged to the previous user.  The  TERMINAL?   prompt\n        will  not  be given.  LOGIN or SIGNON may be used instead\n        of LOGON.  There is no difference in the three  commands.\n        Be  sure  to  clear  the  active file for the user before\n        issuing the LOGON command.  Otherwise,  the  active  file\n        will  automatically  be  saved  by  WYLBUR  and the space\n        subtracted from that user's allocation.\n1INTRODUCTION TO WYLBUR                                             I.G - 1\n\n\n\n G.  Sign-Off Procedure\n\n To end a session, issue a LOGOFF, LOGOUT,  or  SIGNOFF  command.\n WYLBUR  will  reply  with  various  statistics on the session as\n shown and return control to TPMON.\n\n       COMMAND? LOGOFF (CR)\n       14.73 SECONDS EDITING TIME\n       2153 PAGE READS 1887 PAGE WRITES\n       127 DISK READS 240 DISK WRITES\n       ELAPSED TIME = 01:03:18\n       END OF SESSION\n\n The editing time is the actual computer  (CPU)  time  used  when\n processing  commands.   Page  reads and writes are counts of the\n I/O operations performed to execute the various commands dealing\n with the active or exec file during the session.  Disk reads and\n writes are counts of the I/O operations performed  to  read  and\n write external files.  Elapsed time, which is reported in hours,\n minutes  and  seconds,  is the time during which you were logged\n on through TPMON.\n\n In addition, WYLBUR keeps track of activity at a terminal and if\n nothing has been typed in at a logged-on terminal for  a  period\n of ten minutes, WYLBUR will ask for some action to show that you\n are still there.\n\n       COMMAND? ###\n       ARE YOU STILL THERE?\n       COMMAND?\n\n A carriage return is sufficient reply.  If  you  don't  respond,\n WYLBUR  will give you another five minutes and ask again.  If no\n reply is made, WYLBUR will wait another five minutes and  logoff\n the terminal without further queries.\n\n       COMMAND? ###\n       RESPOND OR BE LOGGED OFF.\n       COMMAND?\n\n To avoid being logged off in this manner, type the command:\n\n       COMMAND? SET NOTIME\n\n This will allow you to remain signed on until you sign  yourself\n off.   On  terminals without the reverse break feature or if you\n have  SET  NOBREAK  the  above  messages  will  not  be  issued.\n Therefore, you will be  logged  off  without  warning  after  20\n minutes of inactivity.\n1INTRODUCTION TO WYLBUR                                             I.G - 2\n\n\n You cannot logoff with an active file.  If you forget  to  clear\n the  active  file  before  attempting  to  sign off, WYLBUR will\n prompt for permission to clear it.  A YES or OK response  causes\n a  CLEAR  and  normal signoff.  Any other response continues the\n session.  If you are logged off by WYLBUR or if your session  is\n terminated  abnormally  by  communication  problems  or a system\n crash, the WYLBUR system will attempt to save  and  catalog  the\n current  active  file  as an external file named ACTIVE.  WYLBUR\n will save your active file exactly, although the last few  lines\n may  occasionally  be lost if the system crashes.  However, your\n active file will not be saved if you have  exceeded  your  space\n allocation.   You should make sure, therefore, to leave at least\n one sequential track open in the event of a  system  crash.   If\n WYLBUR  crashes  a second time, the new ACTIVE will be saved and\n cataloged (provided you have enough space) and  the  old  ACTIVE\n will  be  uncataloged but not scratched.  You may later retrieve\n your cataloged file ACTIVE by specifying the command USE  ACTIVE\n ON CATLG.  See Section IV for more about the USE command.   Also\n remember to scratch your files named ACTIVE after you have USE'd\n them.\n1II.    CREATING A FILE                                             II.A - 1\n\n\n II.  Creating a File\n\n In order to create a file you  must  enter  the  COLLECT   mode.\n You  may   enter   COLLECT  mode  by striking the ATTN key or by\n using the COLLECT command.  The terminal is  in   COLLECT   mode\n when   it   is  prepared  to  accumulate  lines of text typed at\n the terminal and store them in the active area of the computer's\n memory.   Before you enter COLLECT mode, you may want to  adjust\n certain  parameters  for   the   duration  of the WYLBUR session\n such as tab settings or line length.  You may do this  by  using\n the  SET  command  with appropriate  options.    These   options\n are discussed below.\n\n\n\n A.  Global Parameters\n\n Global parameters are features in WYLBUR which may  be  set   to\n an appropriate  value  and  will  remain  set  at that value for\n the duration of  the  session  or  until  reset.   Two  commands\n are  associated    with   global   parameters:   SET  and  SHOW.\n Global parameters are  changed  by  a  SET  command.   The  SHOW\n command may be used in most cases to see which global parameters\n are  in   effect.  Some parameters described in this section are\n associated with the SHOW  command  but  may  not be set  by  the\n user.  For  additional  information  on  global  parameters  see\n Section IV.\n\n\n\n    1. CASE\n\n       Case is determined by the shift key just as   it   is   on\n       an  ordinary   typewriter.   However,  unless you give the\n       command SET UPLOW  (set  upper  and  lower  case)   before\n       starting  in  COLLECT  mode,  in   file will be stored and\n       listed  only in upper case no matter which case characters\n       you type.\n\n       COMMAND? COLLECT  (CR)\n         1.   ? This is a sample passage to show what (CR)\n         2.   ? happens when you type in upper and lower (CR)\n         3.   ? case without setting UPLOW. (CR)\n         4.   ? ***(ATTN)\n       COMMAND? LIST (CR)\n         1.     THIS IS A SAMPLE PASSAGE TO SHOW WHAT\n         2.     HAPPENS WHEN YOU TYPE IN UPPER AND LOWER\n         3.     CASE WITHOUT SETTING UPLOW.\n       COMMAND?\n1CREATING A FILE                                                    II.A - 2\n\n\n       If UPLOW is  in  effect,  you   may   revert   to   having\n       all  alphabetic characters in upper case by giving the SET\n       UPPER command.   The  command  SHOW  CASE can be  used  to\n       find out whether UPPER or UPLOW is currently in effect.\n\n       COMMAND?  SHOW CASE (CR)\n       UPPER CASE ONLY\n\n       Note that the SET UPLOW  command  is  only  operable  with\n       \"up-low\"  terminals.  The Hazeltine terminals available at\n       CUCC use upper case only for  alphabetic  characters.   If\n       you  SET  UPLOW  and  use the shift key while typing on an\n       Hazeltine the cases will appear as below.\n\n                 ABCDEFGHIJKLMNOPQRSTUVWXYZ   <--user enters\n                 QRSTUVWXYZ\u00dd\u00ac\u00a2|_@ABCDEFGHIJ   <--WYLBUR transmits\n\n       This means that if you type an A while holding  the  shift\n       key, the Hazeltine will display and transmit a Q, etc.\n\n    2. TABS\n\n          Tabs may be used with WYLBUR to speed up terminal input\n          and output by skipping long strings  of  blanks.   This\n          requires  a SET TABS command  for internal WYLBUR tabs,\n          and the setting of the hardware tabs.\n\n       a. Selectric Terminals\n\n          There is a distinction  between  setting  tabs  in  the\n          WYLBUR  system  with  the  SET  command and setting the\n          hardware tabs on the terminal typewriter.  The hardware\n          tabs  are  set  and  cleared  as   for   any   electric\n          typewriter.   Their use during typing is also the same.\n          However,  you  cannot  use  the  tab  settings  on  the\n          typewriter unless you have already set the WYLBUR  tabs\n          with  a  SET TABS.  If you try to do so, you will get a\n          diagnostic message after every line in  which  you  use\n          UNSET  TABS  (tabs  that  have  not  been  set  through\n          WYLBUR).  WYLBUR  will  use  tabs  while  listing  text\n          unless   SLOWLIST   is   set.   The  WYLBUR  tabs  must\n          correspond to the hardware tabs.  Once tabs  have  been\n          set, they are used to speed up listing by skipping long\n          strings of blanks.\n\n          To SET TABS, first clear the hardware tabs  by  holding\n          down  the CLEAR switch while spacing over to the end of\n          a line.   Then  hit  carriage  return.   You  may  then\n          proceed from section b below.\n1CREATING A FILE                                                    II.A - 3\n\n\n       b. Setting Tabs - Long Form--Spacing Over\n\n          COMMAND? SET TABS (CR)\n          TYPE A \"1\" BENEATH EACH POSITION AT WHICH YOU SET A TAB.\n                    12345678911234567892123456789312...\n  +                          _         _         _\n            START ?\n\n          Starting at the left, space  over  to  each  successive\n          column  in  which  you  want  a  tab set, press the SET\n          toggle switch on the keyboard, and then type the number\n          1.  You may set a maximum of eight tabs.\n\n          COMMAND? SET TABS (CR)\n          TYPE A \"1\" BENEATH EACH POSITION AT WHICH YOU SET A TAB.\n                    12345678911234567892123456789312...\n+                            _         _         _\n             START ?         1         1         1 (CR)\n          VERIFY             1         1         1\n\n          The example above  shows  the  successful  setting  and\n          verifying  of  the  tabs  in  columns  10,  20, and 30.\n          Because the physical tab settings at the terminal  must\n          correspond  to  the  information  given when using this\n          form of the  SET  TABS  command,  WYLBUR  will  type  a\n          verification  line.   WYLBUR  will  tab  to each of the\n          positions and  again  type  1.   If  the  1's  are  not\n          directly under each other, reset the physical tabs.\n\n\n       c. Setting Tabs - Short Form--Appending Column Numbers\n\n          You may append to  the  SET  TABS  command  a  list  of\n          numbers  representing  the  column  numbers for the tab\n          settings.  If the  1's  are  not  directly  under  each\n          other, reset the physical tabs in the proper positions.\n1CREATING A FILE                                                    II.A - 4\n\n\n          COMMAND? SET TABS = 10,20,30 (CR)\n          VERIFY             1         1         1\n          VERIFY             1         1         1\n\n          Because the physical tab settings at the terminal  must\n          correspond  to  the  information  given when using this\n          form of the SET TABS  command,  WYLBUR  will  type  two\n          verification  lines.   WYLBUR  will  first space out to\n          each of the tab positions and type a 1.  Then  it  will\n          tab  to each of the positions and again type 1.  If the\n          1's are  not  directly  under  each  other,  reset  the\n          physical tabs.\n\n          If the tabs have not been set and the tab key is  used,\n          WYLBUR will pay no attention to the line and will issue\n          the message:\n\n                   UNSET TABS - RETYPE\n\n          This also occurs if the tab key is pressed  more  times\n          than  there are tabs set.  If you are not sure how many\n          tabs have been set, ask WYLBUR to SHOW TABS.\n\n          COMMAND? SHOW TABS (CR)\n          10 - 20 - 30  -  TABS\n\n          The SET SLOWLIST command will suppress the use of  tabs\n          in  listing  if  they have been set.  SET FASTLIST will\n          cause WYLBUR to resume using tabs in output.   To  find\n          out  which  option  is  in  effect, use either the SHOW\n          FASTLIST or SHOW SLOWLIST command.\n\n          You may suppress the verification of tabs  in  the  SET\n          TABS command by specifying NOVERIFY.\n\n          COMMAND? SET TABS NOVERIFY (CR)\n          TYPE A \"1\" BENEATH EACH POSITION AT WHICH YOU SET A TAB.\n                    12345678911234567892123456789312...\n+                            _         _         _\n             START ?         1         1         1 (CR)\n          COMMAND?\n\n          You may request that the tabs be verified in  the  SHOW\n          TABS command by using the VERIFY option.\n\n          COMMAND? SHOW TABS VERIFY (CR)\n          VERIFY             1         1         1\n          VERIFY             1         1         1\n\n\n       d. CRT Terminals\n\n          To set tabs use the short form described above.\n             You  may  physically  set  the  tabs by\n          simultaneously depressing the CTRL  and  I  keys  after\n          spacing the cursor to the desired column.  Set SLOWLIST\n          to see the tabs in the proper columns.\n\n1CREATING A FILE                                                    II.A - 5\n\n\n       e. Clearing Tabs\n\n          To clear the tab settings during  a  session,  use  the\n          CLEAR  TABS  command.   This  will  suppress the use of\n          tabs.  There is little reason to do so since  SET  TABS\n          automatically  clears  the old WYLBUR tabs as its first\n          action and SET SLOWLIST will also suppress the  use  of\n          tabs for listings.\n\n          COMMAND? CLEAR TABS (CR)\n          COMMAND? SHOW TABS (CR)\n          NO TABS\n\n\n\n    3. DELTA\n\n       DELTA is the increment which WYLBUR adds  to  the  present\n       line  number  to  get  the next one.  It is also used as a\n       starting line number for a file.  You may set a value  for\n       DELTA  at any number between .001 and 99999.999 inclusive.\n       If you do not set DELTA, 1.000 is  used  as  the  default.\n       The line number increment can be set to a value other than\n       1.000  in several ways.  You may set it temporarily at the\n       time you enter COLLECT mode, or you may reset the  default\n       DELTA with the SET DELTA command.\n\n       a. Setting Delta with the SET Command\n\n          Delta  may  be  set  at  any  time  in  response  to  a\n          \"COMMAND?\" prompt by the system.\n\n          COMMAND?  SET DELTA  5 (CR)\n\n          The current value for this parameter can be ascertained\n          as follows:\n\n          COMMAND? SHOW DELTA (CR)\n           5.  - DELTA\n\n       b. Setting DELTA with the COLLECT Command\n\n          COMMAND? COLLECT 90 BY 10 (CR)\n           90.   ?\n\n          This command will start collecting lines 90, 100,  110,\n          etc.   The  specified  increment  of  10 will remain in\n          effect as long as the command is in effect.   The  line\n          number  increment  can be set implicitly with a command\n          which specifies a line number with a  fractional  part.\n          This is useful, for example, to do a COLLECT which will\n          insert  lines  between  existing lines.  If this is the\n          text:\n\n           25.  to fully express our gratitude to\n           26.  Mr. Jones, Eileen Roberts and the rest of the\n1CREATING A FILE                       II.A - 6                     II.A - 6\n\n\n          Material  can  be  inserted  between  these  lines   by\n          entering:\n\n          COMMAND? COLLECT 25.1 (CR)\n           25.1  ?\n\n          WYLBUR will now COLLECT lines 25.1, 25.2, etc.,  adding\n          one  to  the  low-order  fractional  unit.  It will not\n          COLLECT 26.0 because that would write over  an  already\n          existing line.\n\n          COMMAND? COLLECT 25.1 (CR)\n            25.1   ?  THE NEXT LINE (25.2) IS ALREADY THERE (CR)\n          NO REPLACE OR INTERLEAVE\n          COMMAND?\n\n\n    4. LENGTH\n\n       LENGTH is another global parameter and may be set  to  any\n       value between 1 and 133 characters.  If you do not set the\n       LENGTH attribute, it defaults at SIGNON to a value of 72.\n\n       COMMAND? SET LENGTH  30 (CR)\n\n       WYLBUR will accept lines which are  longer  than  the  set\n       length,  but  a  message  will  be  typed  out  after each\n       over-length line  indicating  that  the  length  has  been\n       exceeded.\n\n       32.  ? THIS LINE IS LONGER THAN LENGTH, WHICH IS 30.  (CR)\n       LINE NO. 32. CONTAINS 45 CHARACTERS\n       33.  ?\n\n    5. TERSE-VERBOSE\n\n       The SET TERSE command  shortens  WYLBUR's  usual  COMMAND?\n       prompt to a ?  The TERSE mode also eliminates the response\n       to  certain commands and causes a short form of file names\n       to be typed to the user instead of  the  full  name.   See\n       Section IV.D on file naming conventions.\n\n       COMMAND? SET TERSE (CR)\n       ?\n       SET VERBOSE returns this parameter to its default.\n\n       ? SET VERBOSE (CR)\n       COMMAND?\n\n1CREATING A FILE                                                    II.B - 1\n\n\n B.  COLLECT (Short Form:  COL, C)\n\n To enter COLLECT mode, type COLLECT and  a  carriage  return  in\n answer to WYLBUR's prompt, \"COMMAND?\"\n\n       COMMAND? COLLECT (CR)\n\n WYLBUR will then type a line  number  and  allow  you  to  begin\n entering  text  into the system.  When you finish a line and use\n the carriage return, WYLBUR will  respond  with  the  next  line\n number so that you may continue to enter information.\n\n       COMMAND? COLLECT (CR)\n         1.    ? I am interested in creating (CR)\n         2.    ? a WYLBUR file. (CR)\n         3.    ?\n\n As a convenience, the COLLECT command can be given in one of two\n shortened forms:  COL and C.\n\n       COMMAND?  COL (CR)\n           1.    ?\n\n Remember to leave COLLECT  mode  before  giving  a  command,  or\n WYLBUR will interpret the command as part of the file.\n\n           3.    ? LIST (CR)\n           4.    ? ***\n         COMMAND?\n\n\n The *** shows that the ATTN key was  pressed  and  that  changed\n WYLBUR  back  to  COMMAND  mode.  The LIST command in line 3 was\n accepted as text and not recognized as a command by WYLBUR.\n\n    1. Specifying Line Numbers\n\n       It is possible to start collecting lines at a number other\n       than one by specifying the number in the COLLECT command.\n\n       COMMAND? COLLECT 10 (CR)\n          10.   ?\n\n\n       If no line number is given in the COLLECT command,  WYLBUR\n       will  resume  collecting at the place it left off when you\n       were last in COLLECT mode.  If this is impossible  because\n       it  would  overwrite an already existing line, WYLBUR will\n       abort the command and print  out  the  message:\n                  \"xxxx. LINE NO. ILLEGAL.\"\n\n       The command, COLLECT END, will cause  WYLBUR  to  add  the\n       value  of  DELTA  to the highest line number in the active\n       file and prompt with that line number.\n1CREATING A FILE                                                    II.B - 2\n\n\n\n    2. MERGE\n\n       If you use the MERGE option, the collected lines  will  be\n       interleaved  among  line numbers that already exist in the\n       active  file.   The  line  numbers  must  be   such   that\n       interleaving is possible.  For example, if the active file\n       consists only of odd numbered lines,  the command\n\n                 COLLECT 2 BY 2 MERGE (CR)\n\n       will result in prompts for even  numbered  lines  and  the\n       result would be a merged file.\n\n    3. CLEAR\n\n       You  may  specify  that  the  active   file   be   cleared\n       (completely erased) as you begin COLLECTing a new file.\n\n       COMMAND? COLLECT CLEAR (CR)\n         1.   ?\n1CREATING A FILE                                                    II.C - 1\n\n\n C.  Line Numbers\n\n Line numbers may be expressed  in  WYLBUR  commands  in  several\n ways.   The  simplest  way  is  by default as shown in the first\n example of the COLLECT command.  The default is 1 for both   the\n DELTA and the first line number.\n\n Line numbers may be a constant or arithmetic expression.   There\n are also 6 symbolic line numbers for the active and exec files.\n\n    1. Constants\n\n       The constant may be any line number of the form nnnnn.nnn.\n       Each of the following is  an  example  of  the  same  line\n       number.\n\n            00032.000       32.\n               32.000       32\n\n    2. Arithmetic Expressions\n\n       You may refer to a line number with  a  simple  arithmetic\n       expression  having  a  +  or -.  29+3 and 100-68 are valid\n       line numbers; they both refer to line 32.   However,  29+3\n       may refer to line 29.3 if lines 29.1 and 29.2 are present.\n       There  are  some restrictions on expressing a line in this\n       form.\n\n       \u00e6 There can be no blanks.  30 + 2  is  not  a  valid  line\n         number.\n\n       \u00e6 The resultant number must be a valid line number between\n         0 and 99999.999.  30+2 is a valid line number whether  a\n         file  has  a  line numbered 32 or not but 30-32 is not a\n         valid line number.\n\n       \u00e6 There can be only one + or -.   An  expression  such  as\n         30+4-2 is not allowed.\n\n       If you express a line number as an  arithmetic  expression\n       in  a  command,  WYLBUR replies with the line number which\n       corresponds to it.\n\n            COMMAND? COLLECT 30+2\n               32.   ?\n\n    3. Symbolic Line Numbers\n\n       There are six pointers to lines in  the  active  and  exec\n       files called symbolic line numbers.\n\n            FIRST        - first line in a file\n            LAST         - last line in a file\n            END          - last line + DELTA\n            CURRENT or * - last line edited\n            PREVIOUS     - line before CURRENT\n            NEXT         - line after CURRENT\n1CREATING A FILE                                                    II.C - 2\n\n\n       Consider a hypothetical file numbered consecutively from 1\n       to 10 with a DELTA of 1.  The first  three  symbolic  line\n       numbers are:\n\n            FIRST = 1\n            LAST  = 10\n            END   = 11\n\n       END does not point to an existing line; it points  to  the\n       line  number  of the next line to be added to the end of a\n       file.\n\n       The next three symbolic line numbers (CURRENT,  NEXT,  and\n       PREVIOUS)  may or may not be set, depending on the actions\n       you have taken.  If you are creating a file  and  entering\n       lines,  CURRENT  or * points to the last LINE NUMBER typed\n       by WYLBUR.  But if you have just fetched an external  file\n       the  CURRENT  line  is  not  set.   PREVIOUS  and NEXT are\n       entirely dependent on CURRENT.  For instance, if you  have\n       just  typed  line   10   into   the   hypothetical   file,\n       CURRENT=11=END, PREVIOUS=10, and NEXT=12.\n\n\n\n    4. Referring to Line Numbers\n\n       Very often it is handier to refer to a line number by  its\n       symbolic  pointer  rather  than  its  actual number.  This\n       feature can be extended by using symbolic line numbers  in\n       arithmetic  expressions to refer to one line or a range of\n       lines.\n\n             INSERT FIRST-.1\n             LIST   */LAST\n             DELETE *, *+4, *+6\n\n1CREATING A FILE                                                    II.D - 1\n\n\n D.  The LIST Command (Short form:  L)\n\n You may use the LIST command to see your  file  printed  at  the\n terminal.   The  example  which  follows  is a form letter which\n shows what happens in response to a LIST command.  Each line  of\n text  is  printed with its associated line number.  When all the\n lines in a file have been listed,  WYLBUR  prompts  for  another\n command.  To stop the listing at any time, press the ATTN key.\n\n       COMMAND? LIST (CR)\n         1.     We regret that because of the budget restrictions\n         2.     and travel ceiling under which we are now\n         3.     operating, we are unable to approve your\n         4.     request of $1000 for foreign travel.\n         4.5    $\n         5.     Please feel free to call on us at any time\n         6.     for information about your grant.\n         7.\n         8.                      Sincerely yours,\n         9.\n        10.\n        11.                      John Jones\n        12.\n        13.     $\n       COMMAND?\n\n For further information on the LIST command see Section VI.A.\n\n    1. UNNUMBERED/NONUMBERED\n\n       To list a file without line numbers, specify UNNUMBERED.\n\n       COMMAND? L UNNUMBERED (CR)\n       We regret that because of the budget restrictions\n       and travel ceiling under which we are now\n       operating, we are unable to approve your\n       request of $1000 for foreign travel.\n       $\n       Please feel free to call on us at any time\n       for information about your grant.\n\n                        Sincerely yours,\n\n\n                        John Jones\n\n       $\n\n       Note that the text is shifted to the left into the columns\n       normally occupied by the line numbers.\n\n1CREATING A FILE                                                    II.D - 2\n\n\n       To list a file without line numbers, but without  shifting\n       to  the left specify NONUMBERED, this puts blanks in place\n       of the numbers on the left.\n\n       COMMAND? LIST NONUMBERED (CR)\n                We regret that because of the budget restrictions\n                and travel ceiling under which we are now\n                operating, we are unable to approve your\n                request of $1000 for foreign travel.\n                $\n                Please feel free to call on us at any time\n                for information about your grant.\n\n                                 Sincerely yours,\n\n\n                                 John Jones\n\n                $\n       COMMAND?\n\n\n\n    2. MARKER\n\n       You may specify one character as a MARKER. If this  MARKER\n       occurs  in  the first column of any line in the range, the\n       listing  will  be  temporarily  suspended,  but  a  MARKER\n       elsewhere  in  a  line  will  be  treated  as  any   other\n       character.   After  suspension, the listing may be resumed\n       by striking the carriage return  key.  The  MARKER  itself\n       will  not  be listed.  Do not use the characters:\n\n                        (  )  \"  '  ,  =\n\n       blank or lower case letters as markers unless you  enclose\n       them in quotation marks such as:\n\n       LIST UNN MARKER = \"=\" (CR)\n\n       COMMAND? LIST MARKER = $ UNNUMBERED (CR)\n       We regret that because of the budget restrictions\n       and travel ceiling under which we are now\n       operating, we are unable to approve your\n       request of $1000 for foreign travel.\n       (CR) (hit carriage return to continue listing)\n       Please feel free to call on us at any time\n       for information about your grant.\n\n                        Sincerely yours,\n\n\n                        John Jones\n\n       (CR) (hit carriage return to continue listing)\n\n1CREATING A FILE                                                    II.D - 3\n\n\n       Notice that the lines containing the MARKER in column  one\n       (lines  4.5  and  13)  are not printed and that the MARKER\n       character is recognized only when it occurs in column one.\n       Also, if you insert a  new  sheet  of  paper  just  before\n       striking  the Carriage Return which begins the listing and\n       remove it just before typing the  final  Carriage  Return,\n       the  COMMAND?   prompt  will  not  mar  the listing of the\n       letter.\n\n\n    3. CLEAN\n\n       In order to  be  certain  that  no  message  from  another\n       terminal will interrupt your listing, add the CLEAN option\n       to  the  above  command.   Note  that  messages  from  the\n       operator can interrupt you.\n\n       COMMAND? LIST CLEAN MARKER=$ UNN (CR)\n\n\n    4. NOTEXT\n\n       Though there would be no point in doing this to  the  form\n       letter, you may have just the line numbers listed.\n\n       COMMAND? LIST NOTEXT (CR)\n          1.\n          2.\n          3.\n          4.\n          4.5\n          5.\n          6.\n          7.\n          8.\n          9.\n         10.\n         11.\n         12.\n         13.\n       COMMAND?\n\n       This NOTEXT option is more  useful  for  creating  a  file\n       which is a computer program rather than a simple text, and\n       then finding the line numbers of all lines which contain a\n       certain series of characters.  This character string might\n       typically  be  a mathematical formula or an instruction to\n       the  computer  and  is  illustrated  in  the  section   on\n       associative range which is on the next page.\n\n       In general, wherever LIST is a valid option on a  command,\n       the  NONUMBERED, UNNUMBERED, NOTEXT, and NOLIST parameters\n       are also valid.  This  applies  to  the  INSERT,  COLLECT,\n       REPLACE, DELETE, and CHANGE commands for example.\n1CREATING A FILE                                                    II.D - 4\n\n\n    5. EXPLICIT Range\n\n       You may restrict the LISTing to a specific range by giving\n       the line numbers of the  first  and  last  numbers  to  be\n       listed  separated by a slash.  Range is discussed fully in\n       Section III.\n\n       COMMAND? LIST 5/7 (CR)\n         5.     Please feel free to call on us at any time\n         6.     for information about your grant.\n         7.\n       COMMAND?\n\n       If you do not specify a range,  ALL  is  assumed  and  the\n       entire the entire file will be listed.\n\n\n    6. ASSOCIATIVE Range\n\n       The following example shows that WYLBUR  can  be  used  to\n       find  instances  of  some  character  string  which  is of\n       interest  to  the  user.   WYLBUR  will  find  all   lines\n       containing  the  word  \"your\"  and  print  their image for\n       inspection.\n\n       COMMAND?  LIST 'your' (CR)\n         3.      operating, we are unable to approve your\n         6.      for information about your grant.\n         8.                        Sincerely yours,\n       COMMAND?\n\n       Line 8 is listed because \"yours\" contains  the  characters\n       'your'.  Had you specified ' your ' in the command, line 8\n       would not have been listed.\n\n    7. EXPLICIT and ASSOCIATIVE Range\n\n       You may combine the explicit and associative ranges in the\n       LIST command.  To list all lines which contain ' your ' in\n       lines 1 through 5:\n\n       COMMAND? LIST ' your ' in 1/5 (CR)\n         3.     operating, we are unable to approve your\n       COMMAND?\n\n       Case is significant,  and  asking  for  'YOUR'  would  not\n       retrieve  these  lines.  Unless you have SET UPLOW in this\n       session, you cannot reference a string that contains lower\n       case characters.\n\n       You could also ask for only the line numbers of the  lines\n       containing the string.\n1CREATING A FILE                                                    II.D - 5\n\n\n       COMMAND? LIST 'your' IN ALL NOTEXT (CR)\n         3.\n         6.\n         8.\n       COMMAND?\n\n       Likewise, you could append the phrase  UNNUMBERED  instead\n       of NOTEXT and receive the line contents only.\n\n1CREATING A FILE                                                    II.E - 1\n\n\n E.  The NUMBER Command\n\n\n You may request WYLBUR to change the line numbers of  the  lines\n of text in an active file by typing the NUMBER command.\n\n       COMMAND? NUMBER (CR)\n\n This causes the renumbering of all the  lines  of  text  in  the\n file,  using  the  current  value  of  the  DELTA parameter as a\n starting line and as an increment.\n\n    1. Specifying a Starting Line\n\n       You may specify another number at which the  numbering  is\n       to begin by giving it in the command.\n\n       COMMAND? NUMBER 2.065 (CR)\n         673.065 - LAST LINE.\n       COMMAND?\n\n       WYLBUR will then start at a value of 2.065 for  the  first\n       new line number and print the number of the last line.\n\n    2. Specifying Delta\n\n       You may temporarily  override  the  setting  of  the  line\n       number  increment,  DELTA,  and  ask WYLBUR to use another\n       value.\n\n       COMMAND? NUMBER 2.065 BY .01 (CR)\n           8.795 - LAST LINE.\n       COMMAND?\n1CREATING A FILE                                                    II.E - 2\n\n\n    3. Scaling\n\n       You may also simply scale the existing line numbers in the\n       file by a given line number.\n\n       COMMAND?  NUMBER TIMES 10 (CR)\n        6740.     - LAST LINE.\n       COMMAND?\n\n       would cause all line numbers in the file to be  multiplied\n       by 10 while\n\n       COMMAND? NUMBER TIMES .1 (CR)\n          67.4   - LAST LINE.\n       COMMAND?\n\n       would cause all line numbers to be effectively divided  by\n       10.   Remember, this command causes the renumbering of the\n       entire file and not just a specific range.\n\n       WYLBUR line numbers must be between 0.000 and 99999.999.\n\n\n    4. Range\n\n       You may specify a single  range  of  starting  line/ending\n       line\n\n       COMMAND? NUMBER 600/1500 (CR)\n\n       would number lines 600 through 1500 by the current  delta.\n       The  first  line in the renumbered lines would be 600.  If\n       there were too many lines  to  be  accommodated  with  the\n       current delta, WYLBUR would calculate the largest possible\n       DELTA to make them fit.\n1III.  EDITING AN ACTIVE FILE                                     III.A - 1\n\n\n III.  Editing an Active File\n\n WYLBUR is a powerful text editor with a number of commands  which\n may be used to change part of an active file.  With these you may\n change  or delete single characters, groups of characters, entire\n lines or even groups  of  lines.   The  editing  commands  either\n affect  an  entire  line  or  part  of a line.  The commands that\n affect a whole line are:\n\n         DELETE                COPY                ALIGN\n         INSERT                MOVE                JUSTIFY\n         REPLACE               CENTER\n\n Commands that affect part of a line are:\n\n         CHANGE                EDIT                MODIFY\n\n All of these commands may be confined to one line or may treat an\n entire file. The MODIFY command is used to insert, blank, delete,\n or  replace  parts of a single line.  The EDIT Command is used to\n replace parts of a single line.  The CHANGE  command  can  effect\n changes  either  within  a  single  line or throughout a group of\n lines.  Before editing a file, you need to know how line  numbers\n may  be  specified  in  WYLBUR  and the various ways there are to\n refer to a range of lines.  These are necessary in order  to  use\n the editing commands efficiently.\n\n\n A.  Specifying Ranges\n\n Various commands use range  options.   These  commands  must  all\n refer  to an explicit range, but it may be implied by the default\n range ALL in the following commands.  However in  all  of  these,\n you may specify an explicit range to override the default.\n\n         CHANGE                LOAD                PUNCH\n         COPY                  MODIFY              REPLACE\n         EDIT                  NUMBER              RUN\n         LIST                  POINT               SUGGEST\n\n In the MOVE, DELETE, CENTER, JUSTIFY and ALIGN commands you  must\n specify an explicit range.  The commands LIST, REPLACE and DELETE\n will be used here to illustrate range.\n\n1EDITING AN ACTIVE FILE                                           III.A - 2\n\n\n    1. Explicit Range\n\n       An EXPLICIT RANGE is a line or group of lines identified by\n       its line numbers.  This type of range is denoted in  WYLBUR\n       by giving the numbers of the first and last lines separated\n       by a slash.\n\n       COMMAND?  LIST 1/10 (CR)\n\n       The range in the command  above  includes  all  lines  from\n       1.000  to  10.000.   A  single  line  is referred to by its\n       number alone.\n\n       COMMAND?  REPLACE 79.3 (CR)\n\n\n       Through the use of disjoint explicit ranges, the  user  can\n       specify  up  to  eleven different line numbers or ranges in\n       one command.  The LIST can contain single lines or  groups,\n       and ranges can overlap, but each group counts as two of the\n       numbers allowed.\n\n       COMMAND? LIST 1,7,4,3.6,6/10,5 (CR)\n\n       This command will list line 1 followed by line 7, then line\n       4, line 3.6, lines 6 through 10 inclusive, and then line 5.\n       In this example, six of the eleven ranges allowed are used.\n\n\n    2. Explicit Range - Count Field\n\n       Another way of denoting an explicit range of  lines  is  by\n       using  the  first  line number followed by a count field in\n       parentheses.  The count must be a positive integer.\n\n       COMMAND?  LIST 10(6) (CR)\n\n       would list the six lines starting at line 10.   It  is  not\n       necessarily the same range as 10/15 unless the next 6 lines\n       are  numbered  10,  11,  12, 13, 14 & 15.  LIST 10(6) might\n       produce a list of lines 10, 40, 41, 42, 68 and 72 if  those\n       were the next six lines in the file.\n\n\n       FIRST (F) and LAST (L) can also be used to define a range:\n\n       FIRST/LAST or F/L or ALL\n       1.05/LAST or 1.05/L\n       FIRST/10.0 or F/10.0\n\n       The word ALL has the same meaning as FIRST/LAST.\n\n       CURRENT, PREVIOUS and NEXT can be used to define a range if\n       the CURRENT line has been set.  (See  Section  II.C  for  a\n       discussion of symbolic line numbers.)\n1EDITING AN ACTIVE FILE                                           III.A - 3\n\n\n    3. Associative Range\n\n       An ASSOCIATIVE RANGE specifies a line  or  group  of  lines\n       each  of  which  contains  a  certain series of characters.\n       This type of range is specified by enclosing the  character\n       string within quote marks and indicating which lines should\n       be searched by giving an explicit range. If the command has\n       a default range of ALL, only the associative range need  be\n       specified unless you wish to override that default.\n\n       a. Use of Quotes\n\n          A terminal  keyboard has two types  of  quote  marks,  a\n          single  quote  (')  and  a  double quote (\").  Either of\n          these may be used to enclose the character  string,  but\n          consistency must be maintained.  Thus, the following are\n          valid associative ranges.\n\n          \"VARIABLE\" IN ALL\n          'X*(15 A * B**2)' IN 1/10\n\n          The following example, however, is not valid.\n\n          \"VARIABLE'\n\n          Also note that blanks are significant in an  associative\n          range specification, so that,\n\n          \" BLANKS ARE PART OF THE STRING \" IN 5/15\n\n          and\n\n          \"BLANKS ARE PART OF THE STRING\" IN 5/15\n\n          are not equivalent range specifications.\n\n          If a quote mark appears in  the  character  string,  you\n          must  follow  some  additional  rules.  It is easiest to\n          enclose the character  string  in  quotes  of  the  type\n          opposite of those appearing within the character string.\n          If  the  same type of quotes must be used to enclose the\n          string, type those  quote  marks  which  appear  in  the\n          character  string  as  two  consecutive instances of the\n          quote mark.  For example:\n\n          \"DON'T\" IN ALL\n             and\n          'DON''T' IN ALL\n\n          both designate the range  of  lines  which  contain  the\n          character string:  DON'T.\n\n1EDITING AN ACTIVE FILE                                           III.A - 4\n\n\n       b. Specifying the Ordinal Occurrence of a String\n\n          It is not necessary to  consider  all  the  lines  which\n          contain the specified string of characters.\n\n          COMMAND?  LIST 'INTEGER' (1,3,5/10) (CR)\n\n          is legal and will  list  the  first,  third,  and  fifth\n          through  tenth  lines  in  which  the  character  string\n          INTEGER  occurs.   The occurrence list must be ascending\n          with no overlap of range and should not be confused with\n          specific line numbers 1, 3, and 5 through 10.   Remember\n          that  WYLBUR  cannot tell when a line contains more than\n          one instance of the specified string.  WYLBUR  prohibits\n          the   use  of  the  occurrence  specifications  and  the\n          multiple group explicit range in the same command.\n\n          A maximum of ten numbers or ranges  may  appear  in  the\n          occurrence list.\n\n       c. Specifying Column Position\n\n          The user may restrict an associative range by  suffixing\n          the string with column positions within which the string\n          must be contained in any given line.\n\n          COMMAND?  DELETE 'INTEGER' 10/16 IN ALL (CR)\n\n          The  above  command  will  delete  all  lines  in  which\n          'INTEGER' occurs in columns 10 to  16.   Note  that  the\n          string  must  begin  and end within the specified column\n          positions.  If only one column  position  is  specified,\n          the string is required to start in that column position.\n\n       d. Specifying Null Lines\n\n          Blank lines are considered by WYLBUR to  be  lines  with\n          null  content.   Thus,  the  associative  range '' or \"\"\n          would retrieve all blank lines in the active file.   The\n          range  '  '  or  \" \" would retrieve all lines having one\n          blank and at least one  non-blank  character;  in  other\n          words, not blank lines.\n\n    4. Negative Associative Range\n\n       You may specify the lines which do not  contain  a  certain\n       character string by using the \u00ac symbol and quotes.\n\n       COMMAND? LIST \u00ac'not this string' (CR)\n\n       WYLBUR will list all the lines which do not contain:\n       'not this string'.\n1EDITING AN ACTIVE FILE                                           III.B - 1\n\n\n\n\n B.  The DELETE, INSERT, and REPLACE Commands\n\n These three commands may be used to completely erase a  line  and\n its  line  number,  insert a new line and line number, or replace\n the contents of an existing line.\n\n    1. DELETE (Short Form:  DEL or D)\n\n       You may delete (erase) lines in an active  file  by  giving\n       the  DELETE  command  and the number of the line to delete.\n       The deleted lines are erased, not replaced by blanks.   The\n       line numbers of the deleted lines are erased, too.\n\n       a. Deleting a Single Line\n\n       COMMAND? DELETE 5.03 (CR)\n\n       b. Deleting an Explicit Range of Lines\n\n       You may also delete a range by typing  the  number  of  the\n       first and last lines of the range.  Up to 5 disjoint ranges\n       are allowed.\n\n       COMMAND? DELETE 5.03/6.08 (CR)\n\n       c. Deleting an Associative Range\n\n       You can also have all lines containing a specific character\n       string eliminated.  These lines are  an  associative  range\n       and  the  string must be enclosed in quotation marks.  Note\n       that the associative range  is  in  addition  to,  and  not\n       instead of, the explicit range (see Section III.A).\n\n       COMMAND?  DELETE 'X = 3Y' IN ALL (CR)\n\n       This command  will  eliminate  all  lines  containing  this\n       equation   from   the  file.   However,  if  the  specified\n       character string is split between two  lines,  WYLBUR  will\n       not recognize it.\n\n       d.  LIST\n\n       The LIST option allows you to look at the lines after  each\n       is  deleted.   If  you are deleting a range and listing it,\n       you have time to stop the command by pressing the ATTN key.\n       The line being listed will already have been deleted.\n\n       COMMAND?  DELETE 1 35 LIST (CR)\n\n       You are cautioned not to abbreviate  LIST  with  an  L.   L\n       stands  for LAST when used as a parameter and thus the last\n       line of your file would be deleted and no lines listed.\n1EDITING AN ACTIVE FILE                                           III.B - 2\n\n\n\n    2. INSERT (Short Form:  INS or I)\n\n       Opposite to the DELETE command is the  INSERT  command.   A\n       line  to  be  inserted  must have a line number assigned by\n       you.  If you attempt to insert a line with the same  number\n       as  an  existing line, WYLBUR prompts with an error message\n       that that line is in the file and no insert may be made.\n\n         COMMAND? INSERT 1934  (CR)\n          1934.    IN FILE. NO INSERT.\n\n       a. Inserting One Line\n\n          COMMAND? INSERT 13.02 (CR)\n           13.02 ?\n\n          The above command is to insert a  line  numbered  13.02.\n          WYLBUR responds with that number and expects you to fill\n          in  the  contents of the line as if you were temporarily\n          in COLLECT mode.\n\n       b. Inserting Multiple Lines - Explicit Range\n\n          It is also possible to insert  more  than  one  line  at\n          multiple  points in the active file.  WYLBUR will prompt\n          with each line number to be inserted.\n\n          COMMAND? LIST 1/6 (CR)\n            2.     THIS IS AN OLD LINE\n            4.     THIS IS AN OLD LINE\n          COMMAND? INSERT 1,3 (CR)\n            1.   ? I AM A NEW LINE (CR)\n            3.   ? I AM A NEW LINE TOO (CR)\n\n          The explicit range may specify up to 21 lines,  but  you\n          may  not  specify a continuous range of lines by using a\n          slash(/), such as 1/3.\n\n       c. Inserting One Line at Multiple Points - DITTO\n\n          The DITTO option may be used to insert one line at up to\n          21 points within a file.  WYLBUR  will  prompt  for  the\n          first line only.\n\n          COMMAND? INSERT 1,3,5 DITTO (CR)\n            1.     I AM A NEW LINE (CR)\n          COMMAND? LIST 1/6 (CR)\n            1.     I AM A NEW LINE\n            2.     THIS IS AN OLD LINE\n            3.     I AM A NEW LINE\n            4.     THIS IS AN OLD LINE\n            5.     I AM A NEW LINE\n1EDITING AN ACTIVE FILE                                           III.B - 3\n\n\n       d. Inserting Multiple Lines - COLLECT\n\n       You may insert  several  consecutive  lines  by  specifying\n       COLLECT.  Though this is, strictly speaking, not the INSERT\n       command, the effect is to insert lines.\n\n          COMMAND?  COL 2.1 (CR)\n            2.1     My new line (CR)\n            2.2     My 2nd new line (CR)\n            2.3     My third new line (CR)\n            2.4 ?   ***(ATTN)\n          COMMAND?\n\n          The command stops when the last line inserted plus DELTA\n          equals an existing line.  Note that DELTA is temporarily\n          changed by the form with  which  you  specify  the  line\n          number to be collected.  For instance,\n\n          COMMAND?  COL 2.0 (CR)\n            2.  ?   This is the first line (CR)\n            2.1 ?   This is the second (CR)\n            2.2 ?   This is the third (CR)\n            2.3 ?   ***(ATTN)\n          COMMAND?\n\n          or\n\n          COMMAND?  COL 2.00  (CR)\n            2.   ?  This  is the first line   (CR)\n            2.01 ?  This is the second    (CR)\n            2.02 ?  This is the third    (CR)\n            2.03 ?  ***(ATTN)\n          COMMAND?\n\n\n    3. REPLACE (Short Form: REP or R)\n\n       To delete the contents of a line and  insert  another  line\n       into  the  file  with  the same number in one step, use the\n       REPLACE command.\n\n       COMMAND? REPLACE 13.06 (CR)\n          13.06  ?\n\n       WYLBUR  will  overwrite  the  old  contents  of  the   line\n       specified with the new contents which you type in.\n\n1EDITING AN ACTIVE FILE                                           III.B - 4\n\n\n       a. LIST\n\n          If you use the LIST option, WYLBUR will  list  the  line\n          first and then prompt with the line numbers.\n\n          COMMAND?  REPLACE 13.06 LIST (CR)\n            13.06  THIS IS THE OLD LINE\n            13.06?\n\n          Do not use L as an abbreviation for  LIST;  it  will  be\n          interpreted as LAST.\n\n       b. Explicit Range\n\n          You may specify that a range of  lines  be  replaced  in\n          which  case  WYLBUR  will prompt successive line numbers\n          from the specified range until the range  is  exhausted.\n          If  you  wish to replace lines 1.02, 1.03, 1.031, 1.032,\n          1.033, 1.04, and 1.05 of a file, do as follows:\n\n          COMMAND?  REPLACE 1.02/1.05 (CR)\n\n          WYLBUR will prompt for new contents  of  each  currently\n          existing line between 1.02 and 1.05.\n\n          If you reply to a  line  prompt  with  only  a  carriage\n          return, the line will not be replaced.\n\n          If you hit only the ATTN key as the new contents of  the\n          line,  the  REPLACE  command  is  aborted,  and  the old\n          contents of the line remain unchanged.\n\n       c. Associative Range\n\n          You may also REPLACE all the  lines  in  an  associative\n          range.\n\n          COMMAND?  REPLACE '3*X*X*Y/3.14159' (CR)\n\n          WYLBUR will then prompt with the  number  of  each  line\n          containing  the  character  string  which  is within the\n          quotation marks.  For further information on associative\n          ranges, see Section III.A, Specifying Ranges.\n\n          You cannot replace the contents of a line which does not\n          exist in the file--i.e.,  use  the  REPLACE  command  to\n          insert.   Should  you  attempt  to  do this, WYLBUR will\n          reply with the message VOID RANGE.  To do this, use  the\n          INSERT command.\n\n1EDITING AN ACTIVE FILE                                           III.B - 5\n\n\n       d. DITTO Option\n\n          You may replace more than one line at a  time  by  using\n          the DITTO option.\n\n          COMMAND? REPLACE 10/20 DITTO (CR)\n             10.   ?\n\n\n\n          Whatever you type for line 10 will be repeated for lines\n          (already there) between 10 and 20, inclusive.\n\n       e. Using the ATTN Key\n\n          If you hit the ATTN key while replacing a line, any text\n          already typed will be ignored  and  WYLBUR  will  prompt\n          again  for  the  line.   If  you  hit ATTN before typing\n          anything in the line, the command will  be  aborted  and\n          the line will not be replaced.\n\n          COMMAND? REPLACE 4 (CR)\n              4.   ? This is not the text that I want ***(ATTN)\n              4.   ? ***(ATTN)\n          COMMAND? LIST 4 (CR)\n              4.   THIS IS THE OLD TEXT.\n\n    4. Alternate Short Form of DEL, INS, REP\n\n       There is another short form for  the  DELETE,  INSERT,  and\n       REPLACE commands:\n\n       COMMAND?  13.06 (CR)\n\n       Line 13.06 will be deleted.\n\n       Type the full line of text for  the  inserted  or  replaced\n       line:\n\n       COMMAND?  13.06 The new contents of this line go here.\n\n       There must be a blank as the required separator between the\n       line number and the contents of the line.   Line  13.06  is\n       replaced if it already exists and inserted if it does not.\n1EDITING AN ACTIVE FILE                                           III.C - 1\n\n\n\n C.  The CHANGE Command (Short form: CH)\n\n\n The CHANGE command is the single most powerful command in WYLBUR.\n Every CHANGE command has three sections:  position,  replacement,\n and  range.  The position identifies the location within the line\n which is to be changed.  The range specifies which lines  are  to\n be considered for changing.  You may omit the range specification\n and  the  default  range  ALL  will  be assumed.  The replacement\n describes what change is to be made.  The  command  searches  the\n lines  specified in the range for instances of the position to be\n changed  and,  when  it  encounters  one,  makes  the   indicated\n replacement.   As  each  line  is  changed, the resulting line is\n listed.\n\n The command can be given in either of two orders:\n\n    CHANGE position TO replacement IN range\n\n    CHANGE position IN range TO replacement\n\n There is also an alternate form which will be discussed last:\n\n    CHANGE position IN range USING replacement\n\n The user can  suppress  the  listing  of  each  changed  line  by\n specifying  the  NOLIST option in the command.  Remember that any\n attempt to interrupt the  listing  of  the  changed  lines,  when\n NOLIST is not given, will also halt the change process.\n\n A sample data set  will  be  used  to  show  the  effect  of  the\n commands.  When each command is given, the active file will be:\n\n       1.     123456ABC\n       2.     123456ABC\n       3.     AAABBBCCC\n       4.     AAABBBCCC\n       5.     AAABBBCCC\n1EDITING AN ACTIVE FILE                                           III.C - 2\n\n\n\n    1. Position in Line\n\n       There are three  basic  types  of  locations  that  can  be\n       specified  in  the position section of the command:  string\n       replacement, column replacement, and column insertion.  The\n       order used to illustrate this section of the  command  will\n       be:\n\n       CHANGE position TO replacement IN range\n\n       a. String Replacement\n\n          The simplest version of the first form is:\n\n          CHANGE 'string1' TO 'string2'\n\n          In the examples below a  simple  version  of  the  later\n          parts  of  the command (the replacement) and the default\n          range ALL will be used.\n\n          COMMAND? CHANGE 'A' TO '*' (CR)\n             1.     123456*BC\n             2.     123456*BC\n             3.     ***BBBCCC\n             4.     ***BBBCCC\n             5.     ***BBBCCC\n          COMMAND?\n\n          Each 'A' in the active file has been found  and  changed\n          to an '*'.\n\n          The command can also  specify  that  the  string  to  be\n          changed  must  occur  completely  within  certain column\n          positions.  Notice that the string  being  replaced  and\n          its replacement can be of different lengths.\n\n          COMMAND? CH 'BC' 5/8 TO 'X' (CR)\n             3.     AAABBXCC\n             4.     AAABBXCC\n             5.     AAABBXCC\n          COMMAND?\n\n          The 'BC' strings in lines  1  and  2  were  not  changed\n          because  they  ended  in  column  9 and were, therefore,\n          outside the range specified.\n\n1EDITING AN ACTIVE FILE                                           III.C - 3\n\n\n          It is also possible to mention just the column  position\n          in  which the string must begin.  Thus, CHANGE 'BC' 6 TO\n          'X' IN ALL would have had the same effect as  the  above\n          example.\n\n          You may specify  a  third  column.   This  is  the  fill\n          column,  and  when  it is given, nothing to the right of\n          that column will be changed in the range.\n\n          COMMAND? CH 'BBB' 3/6/7 TO '&' (CR)\n             3.      AAA&  CCC\n             4.      AAA&  CCC\n             5.      AAA&  CCC\n          COMMAND?\n\n          Again you may mention  only  the  column  in  which  the\n          string  must  begin  along  with  the fill column.  Thus\n          CH 'BBB' 3//7 TO '&' would be equivalent in this case to\n          the above example.\n\n          You may also specify the fill column when specifying  no\n          other  column  positions.   This  will cause all columns\n          before  the  fill  column  to  be   searched   for   the\n          appropriate string.\n\n          COMMAND? CHANGE 'C' //8 TO ' ' (CR)\n             3.      AAABBB CC\n             4.      AAABBB CC\n             5.      AAABBB CC\n          COMMAND?\n\n          If the replacement cannot be  made  within  the  columns\n          before  the  fill column, the change will be made losing\n          some of the characters of the    new   line  and  WYLBUR\n          will  issue  a  message  indicating  the  lines in which\n          non-blank characters were lost.\n\n          COMMAND? CH 'A' //12 TO 'XX' (CR)\n             1.      123456XXBC\n             2.      123456XXBC\n          LINE NO.      3.    LOST CHARACTERS\n             3.      XXXXXXBBBCC\n          LINE NO.      4.    LOST CHARACTERS\n             4.      XXXXXXBBBCC\n          LINE NO.      5.    LOST CHARACTERS\n             5.      XXXXXXBBBCC\n          COMMAND?\n\n          You can also choose to change just a certain instance of\n          a string in each line.  For example:\n\n          COMMAND? CH 'C' (2) TO '??' (CR)\n             3.      AAABBBC??C\n             4.      AAABBBC??C\n             5.      AAABBBC??C\n          COMMAND?\n1EDITING AN ACTIVE FILE                                           III.C - 4\n\n\n          This command will change only the second instance of the\n          string 'C' within each line.\n\n          If column positions and an instance  are  combined,  the\n          columns must be given first.\n\n          A command using the most complex version of the position\n          section might read in outline:\n\n          CHANGE 'string1' col/col/col (instance) TO 'string2'\n\n          COMMAND?  CHANGE 'C' 8/50 (2) TO 'Y' (CR)\n             3.     AAABBBCCY\n             4.     AAABBBCCY\n             5.     AAABBBCCY\n          COMMAND?\n\n       b. Column Replacement\n\n          The second form of the position section specifies column\n          positions  to  be  changed  without  regard   to   their\n          contents.\n\n          CHANGE column/column/column TO 'string2'\n\n          COMMAND?  CHANGE 3/6 to '00' (CR)\n             1.     1200ABC\n             2.     1200ABC\n             3.     AA00CCC\n             4.     AA00CCC\n             5.     AA00CCC\n          COMMAND?\n\n          As the example shows, the replacement string can be of a\n          different length than the material it replaces.\n\n          COMMAND?  CHANGE 1/3 TO '' (CR)\n             1.     456ABC\n             2.     456ABC\n             3.     BBBCCC\n             4.     BBBCCC\n             5.     BBBCCC\n          COMMAND?\n\n          The above example illustrates the use of the null string\n          (\"\" or '') to eliminate columns completely.\n\n          Again, the fill column may be specified.\n\n          COMMAND? CH 3/6/8 TO '00' (CR)\n             1.     1200A  BC\n             2.     1200A  BC\n             3.     AA00C  CC\n             4.     AA00C  CC\n             5.     AA00C  CC\n1EDITING AN ACTIVE FILE                                           III.C - 5\n\n\n\n       c. Column Insertion\n\n          The third form of the position  section  designates  the\n          column position before which an insertion is to be made.\n\n          CHANGE column TO 'string2' IN range\n\n          COMMAND? CHANGE 3 IN ALL TO ' -' (CR)\n             1.     12 -3456ABC\n             2.     12 -3456ABC\n             3.     AA -ABBBCCC\n             4.     AA -ABBBCCC\n             5.     AA -ABBBCCC\n          COMMAND?\n\n          Since 3 was the specified column position, the insertion\n          was made in front of that position, and the rest of  the\n          line was moved to the right.\n\n          You may also specify a fill column for column insertion.\n\n          COMMAND? CH 3//6 TO ' -' (CR)\n          LINE NO.   1.    LOST CHARACTERS\n             1.     12 -36ABC\n          LINE NO.   2.    LOST CHARACTERS\n             2.     12 -36ABC\n          LINE NO.   3.    LOST CHARACTERS\n             3.     AA -ABCCC\n          LINE NO.   4.    LOST CHARACTERS\n             4.     AA -ABCCC\n          LINE NO.   5.    LOST CHARACTERS\n             5.     AA -ABCCC\n          COMMAND?\n\n          Notice that  it  is  always  the  column(s)  immediately\n          preceeding  the  fill  column  that  will be deleted, if\n          necessary.  If only blanks are deleted, the message LINE\n          NO.  x LOST CHARACTERS will not be given.\n\n    2. Search Range\n\n       The range section of the CHANGE command tells WYLBUR  which\n       lines  of  the  active  file  to search for the location to\n       change.  This section can  contain  any  valid  ASSOCIATIVE\n       RANGE or EXPLICIT RANGE.  IN ALL is the default range.\n\n       CHANGE position TO replacement IN range\n\n       This section may simply specify that the entire active file\n       should be searched.\n1EDITING AN ACTIVE FILE                                           III.C - 6\n\n\n       COMMAND? CHANGE 'A' TO '  ' (CR)\n          1.     123456  BC\n          2.     123456  BC\n          3.           BBBCCC\n          4.           BBBCCC\n          5.           BBBCCC\n       COMMAND?\n\n       As was mentioned above, the order of  the  replacement  and\n       the  range  can  be  reversed; so the general form can also\n       read:\n\n       CHANGE position IN range TO replacement\n\n       The specific command above could also have been stated as:\n\n       COMMAND?  CHANGE 'A' IN ALL TO ' ' (CR)\n\n       Note:  \"'A'  IN  ALL\"  in  the  above  example  is  not  an\n       ASSOCIATIVE RANGE.\n\n\n       The range can specify that only certain  lines  are  to  be\n       searched.\n\n       COMMAND?  CHANGE 'B' TO '' IN 1,3/5 (CR)\n          1.  123456AC\n          3.  AAACCC\n          4.  AAACCC\n          5.  AAACCC\n       COMMAND?\n\n       The range can be further restricted to lines containing (or\n       not containing) a given string which  can  be  required  to\n       fall within certain column positions.\n\n       COMMAND?  CHANGE 2/4 to '$$' IN \u00ac'A' 1/5 IN 2/LAST (CR)\n          2.  1$$56ABC\n       COMMAND?\n\n       You can further restrict changes to  certain  instances  of\n       lines  meeting  the  criteria.  Notice that in the example,\n       the third line containing \"A\" and \"BB\" is not changed.\n\n       COMMAND?  CHANGE 'A' TO 'Z' IN 'BB' (1,2) IN ALL (CR)\n          3.  ZZZBBBCCC\n          4.  ZZZBBBCCC\n       COMMAND?\n\n       The form of the command using the most complex  version  of\n       the  range section and showing the use of all three strings\n       might read:\n\n       CHANGE 'string1' TO 'string2' IN 'string3' column/column\n       (instances) IN linenumber,linenumber/linenumber\n1EDITING AN ACTIVE FILE                                           III.C - 7\n\n\n\n    3. The Replacement\n\n       The third section of the command specifies the  replacement\n       string  which  is to be put in the positions being changed.\n       The order used to illustrate this section will be:\n\n       CHANGE position IN range TO replacement\n\n       The replacement may  be  one  of  three  types:   a  quoted\n       string,   an   incremented   integer,   or   a  transferred\n       replacement range.\n\n       a. Quoted String\n\n          CHANGE 'string1' IN range TO 'string2'\n\n          The simplest use  of  this  section  involves  a  direct\n          replacement  of  the  designated  location with a single\n          quoted string.\n\n\n          COMMAND?  CHANGE 'ABC' IN ALL TO '%+%' (CR)\n             1.     123456%+%\n             2.     123456%+%\n          COMMAND?\n\n       b. Incremented Integer\n\n          The second form the replacement string can  take  is  an\n          integer which is incremented each time it is used.  This\n          can be used, for example, to generate  page  numbers  or\n          sequence numbers.\n\n          If a single integer is given, it is incremented  by  one\n          each time it is used.\n\n          COMMAND?  CHANGE 'C' IN ALL TO 1 (CR)\n             1.     123456AB1\n             2.     123456AB2\n             3.     AAABBB345\n             4.     AAABBB678\n             5.     AAABBB91011\n          COMMAND?\n\n          Notice that the field  is  expanded  if  necessary.   An\n          increment other than one may be specified.\n\n          COMMAND?  CHANGE 12 IN ALL TO 0+5 (CR)\n             1.     123456ABC  0\n             2.     123456ABC  5\n             3.     AAABBBCCC  10\n             4.     AAABBBCCC  15\n             5.     AAABBBCCC  20\n          COMMAND?\n1EDITING AN ACTIVE FILE                                           III.C - 8\n\n\n          The incrementing number may be negative.\n\n          COMMAND?  CH 12 IN ALL TO 30-10 (CR)\n             1.     123456ABC  30\n             2.     123456ABC  20\n             3.     AAABBBCCC  10\n             4.     AAABBBCCC  0\n             5.     AAABBBCCC  -10\n          COMMAND?\n\n          If leading zeros are specified in the  starting  number,\n          they  will  be preserved.  If the increment is positive,\n          the sign may be omitted.\n\n          COMMAND?  CHANGE 9/9 IN 3/5 TO 005 60 (CR)\n             3.     AAABBBCC005\n             4.     AAABBBCC065\n             5.     AAABBBCC125\n          COMMAND?\n\n          Leading  blanks  can  be  specified  by  enclosing   the\n          starting  number in quotes.  The incrementing number can\n          be negative.\n\n          COMMAND?  CHANGE 9/9 IN ALL TO ' 15'-5 (CR)\n             1.     123456AB 15\n             2.     123456AB 10\n             3.     AAABBBCC  5\n             4.     AAABBBCC  0\n             5.     AAABBBCC -5\n          COMMAND?\n\n          Non-numeric characters may also be used if the number is\n          enclosed in quotes.  In general, a non-numeric character\n          is changed to a blank if at least one blank  follows  it\n          in  the  result.   The  characters  +,  -,  $  and # are\n          exceptions to this rule.  Only one of these may occur in\n          the number, and  it  will  be  placed  adjacent  to  the\n          left-most significant digit.\n\n          COMMAND?  CHANGE 10 IN ALL TO '$ , 15' +270 (CR)\n             1.     123456ABC    $15\n             2.     123456ABC   $285\n             3.     AAABBBCCC   $555\n             4.     AAABBBCCC   $825\n             5.     AAABBBCCC $1,095\n          COMMAND?\n1EDITING AN ACTIVE FILE                                           III.C - 9\n\n\n          The incrementing number can be  negative;  the  starting\n          number  can  also  be  negative,  if  it  is enclosed in\n          quotes.  The field is  expanded  if  necessary  to  hold\n          minus signs.\n\n          COMMAND?  CHANGE 'C' IN 3/5 TO '-5'+1 (CR)\n             3.     AAABBB-5-4-3\n             4.     AAABBB-2-1-0\n             5.     AAABBB 1 2 3\n          COMMAND?\n\n          Normally the number is incremented for  each  occurrence\n          of  the string to be changed.  It is possible to have it\n          incremented only at the beginning of  each  line  to  be\n          changed.\n\n          COMMAND?  CHANGE 'C' IN ALL TO 15 LINE (CR)\n             1.     123456AB15\n             2.     123456AB16\n             3.     AAABBB171717\n             4.     AAABBB181818\n             5.     AAABBB191919\n\n       c. Transferred Replacement  (USING)\n\n          The third form,  transferred  replacement,  permits  the\n          contents  of  the  replacement strings to be copied from\n          another location in the active file.  This can be useful\n          for moving portions of the active file around.\n\n          CHANGE position IN range USING replacement\n\n          As for example in :\n\n          COMMAND?  CHANGE 15 IN 1/2 USING 4/5 (CR)\n             1.     123456ABC     AAABBBCCC\n             2.     123456ABC     AAABBBCCC\n          COMMAND?\n\n\n          Here, the entire contents of lines 4 and 5  have  served\n          as  replacement  strings.   Note that lines 4 and 5 have\n          not been deleted from the active file.  The  replacement\n          range is limited to one set of contiguous lines.\n1EDITING AN ACTIVE FILE                                           III.C - 10\n\n\n          If there are not enough lines in the  replacement  range\n          to  CHANGE  the  target range of lines, WYLBUR will give\n          you the option  of  reusing  the  replacement  range  by\n          repeating  the operation from the beginning.  The REPEAT\n          parameter  may  be  used  on  the  CHANGE   command   to\n          accomplish this function.\n\n          COMMAND?  CHANGE 15 IN ALL USING 2/3 REPEAT (CR)\n             1.     123456ABC     123456ABC\n             2.     123456ABC     AAABBBCCC\n             3.     AAABBBCCC     123456ABC\n             4.     AAABBBCCC     AAABBBCCC\n             5.     AAABBBCCC     123456ABC\n          COMMAND?\n\n          It is also  possible  to  restrict  the  material  being\n          transferred to certain columns of the copied lines.\n\n          COMMAND?  CHANGE 15 IN 1/2 USING 4/5 COLUMNS 1/3 (CR)\n             1.     123456ABC     AAA\n             2.     123456ABC     AAA\n          COMMAND?\n\n          Only the contents of columns 1 through 3 have been  used\n          as the replacements.\n\n          To transfer the contents of a single column from a group\n          of lines:\n\n          COMMAND?  CHANGE 15 IN 1/2 USING 4/5 COLUMNS 3/3 (CR)\n             1.     123456ABC     A\n             2.     123456ABC     A\n          COMMAND?\n\n          Specifying a single column position  only  once  in  the\n          replacement range causes that column position and all to\n          the right of it to be used.\n\n          COMMAND?  CHANGE 15 IN 1/2 USING 4/5 COLUMN 3 (CR)\n             1.     123456ABC     ABBBCCC\n             2.     123456ABC     ABBBCCC\n          COMMAND?\n\n          Normally a new line is obtained for each  occurrence  of\n          the  string  to  be  replaced.  However, you may specify\n          that the ranges are to be matched line-by-line.\n\n          COMMAND? CH 'C' IN ALL USING 2/3 COLUMNS 1/2 LINE (CR)\n             1.      123456AB12\n             2.      123456ABAA\n             3.      AAABBB121212\n             4.      AAABBBAAAAAA\n             5.      AAABBB121212\n          COMMAND?\n\n1EDITING AN ACTIVE FILE                                           III.D - 1\n\n\n\n D.  The COPY and MOVE Commands\n\n COPY and MOVE may be used to move lines to a different  place  in\n the  active  file.   COPY does not erase the lines from their old\n position whereas MOVE does erase.\n\n    1. COPY\n\n       WYLBUR will COPY one or more lines into a  section  of  the\n       active file.  The lines copied may be in the active file or\n       in  an external file.  The lines copied are not erased from\n       their old position.  The new lines are renumbered according\n       to the implicit DELTA  unless  you  specify  an  overriding\n       DELTA in the COPY command.  Also note that lines already in\n       the  file cannot be overwritten by use of the COPY command.\n       The following file will be  used  to  show  the  effect  of\n       various COPY commands.\n\n       1.     THIS IS A DUMMY FILE WHICH WILL BE USED\n       2.     TO SHOW THE EFFECT OF VARIOUS COPY COMMANDS.\n       3.     AAAA\n       4.     BBBBBB\n       5.     CCCCC\n       6.     DDDDDDD\n       7.     EEE\n\n       In the examples, assume that each  COPY  command  is  given\n       when the file is in the unmodified form given above.\n\n       COMMAND? COPY (CR)\n          14.  -  LAST LINE\n       COMMAND? LIST (CR)\n          1.     THIS IS A DUMMY FILE WHICH WILL BE USED\n          2.     TO SHOW THE EFFECT OF VARIOUS COPY COMMANDS.\n          3.     AAAA\n          4.     BBBBBB\n          5.     CCCCC\n          6.     DDDDDDD\n          7.     EEE\n          8.     THIS IS A DUMMY FILE WHICH WILL BE USED\n          9.     TO SHOW THE EFFECT OF VARIOUS COPY COMMANDS.\n         10.     AAAA\n         11.     BBBBBB\n         12.     CCCCC\n         13.     DDDDDDD\n         14.     EEE\n\n       This is the simplist form of the  COPY  command.   It  will\n       copy  all  of  the  active  file to the line number that is\n       referenced by the symbolic line number END.\n1EDITING AN ACTIVE FILE                                           III.D - 2\n\n\n       a. Copy an Explicit Range\n\n          If you copy a range of lines rather than a  whole  file,\n          range  must  be  the  first parameter.  If you specify a\n          line to COPY TO, it must be a non-existing line.  In the\n          following command, line 6.5 is used to COPY TO.\n\n          COMMAND? COPY 5 TO 6.5 (CR)\n          COMMAND? LIST (CR)\n            1.     THIS IS A DUMMY FILE WHICH WILL BE USED\n            2.     TO SHOW THE EFFECT OF VARIOUS COPY COMMANDS.\n            3.     AAAA\n            4.     BBBBBB\n            5.     CCCCC\n            6.     DDDDDDD\n            6.5    CCCCC\n            7.     EEE\n\n          If the range copied results in the addition of more than\n          one line to the file, the last line number  of  the  new\n          lines will be indicated.\n\n          COMMAND? COPY 3/5 TO 47 (CR)\n           49.    - LAST LINE.\n          COMMAND? LIST (CR)\n            1.     THIS IS A DUMMY FILE WHICH WILL BE USED\n            2.     TO SHOW THE EFFECT OF VARIOUS COPY COMMANDS.\n            3.     AAAA\n            4.     BBBBBB\n            5.     CCCCC\n            6.     DDDDDDD\n            7.     EEE\n           47.     AAAA\n           48.     BBBBBB\n           49.     CCCCC\n\n\n          COMMAND?  COPY 3/5 TO END (CR)\n\n          would have accomplished the  same  thing  but  the  line\n          numbers  would have been 8, 9, and 10 instead of 47, 48,\n          49.  If  the  TO  linenumber  is  omitted,  the  default\n          assumed is TO END.\n1EDITING AN ACTIVE FILE                                           III.D - 3\n\n\n       b. Specifying Delta\n\n          COMMAND?  COPY 2/3 TO 4.01\n            4.02  - LAST LINE.\n\n          In the example above, the two lines  from  line  2.0  to\n          line  3.0  inclusive  were  copied to follow 4.01 with a\n          default increment of .01.  In the  following  example  a\n          DELTA of .001 is specified.\n\n          COMMAND?  COPY 6/7 TO 2.03 BY .001 (CR)\n            2.031 - LAST LINE.\n          COMMAND?  LIST (CR)\n            1.     THIS IS A DUMMY FILE WHICH WILL BE USED\n            2.     TO SHOW THE EFFECT OF VARIOUS COPY COMMANDS.\n            2.03   DDDDDDD\n            2.031  EEE\n            3.     AAAA\n            4.     BBBBBB\n            5.     CCCCC\n            6.     DDDDDDD\n            7.     EEE\n\n\n          If the range to  be  copied  overlaps  the  range  being\n          copied into, bizarre results may be produced.\n\n          COMMAND? COPY 6/10  TO 8 BY .01 (CR)\n          10.02 - LAST LINE\n          COMMAND? LIST (CR)\n            1.     THIS IS A DUMMY FILE WHICH WILL BE USED\n            2.     TO SHOW THE EFFECT OF VARIOUS COPY COMMANDS.\n            3.     AAAA\n            4.     BBBBBB\n            5.     CCCCC\n            6.     DDDDDDD\n            7.     EEE\n            8.     DDDDDDD\n            8.01   EEE\n            8.02   DDDDDDD\n            8.03   EEE\n            8.04   DDDDDDD\n            8.05   EEE\n\n\n          And so it goes, until  it  copies  10  to  10.02.   This\n          happens  because  WYLBUR  copies one line at a time.  It\n          begins at 6 and copies that into 8.0; it next copies 7.0\n          into  8.01;  then  8.0  into  8.02,  and  it   continues\n          generating  and  copying  until  the limit, 10, has been\n          copied.  This feature  can  be  used  deliberately  when\n          multiple copies of a line or range of lines are wanted.\n1EDITING AN ACTIVE FILE                                           III.D - 4\n\n\n       c. MERGE\n\n          The MERGE option may be used  to  interleave  lines.   A\n          DELTA  must  be  specified  which  will allow the merged\n          lines to fit between the existing lines which are  being\n          copied  to.   Replaces  are not permitted.  The old line\n          numbers of the lines copied from are not retained by the\n          COPY MERGE command.\n\n          COMMAND?  COPY 1/3 TO 2.1 BY 2 MERGE (CR)\n            6.1  - LAST LINE\n          COMMAND?  LIST (CR)\n            1.     THIS IS A DUMMY FILE WHICH WILL BE USED\n            2.     TO SHOW THE EFFECT OF VARIOUS COPY COMMANDS.\n            2.1    THIS IS A DUMMY FILE WHICH WILL BE USED\n            3.     AAAA\n            4.     BBBBBB\n            4.1    TO SHOW THE EFFECT OF VARIOUS COPY COMMANDS.\n            5.     CCCCC\n            6.     DDDDDDD\n            6.1    AAAA\n            7.     EEE\n\n\n       d. Copy an Associative Range\n\n          The following example shows the successful  use  of  the\n          COPY command applied to an associative range.\n\n          COMMAND?  COPY 'FILE' IN 1/6 TO 33  (CR)\n          COMMAND?  LIST (CR)\n            1.     THIS IS A DUMMY FILE WHICH WILL BE USED\n            2.     TO SHOW THE EFFECT OF VARIOUS COPY COMMANDS.\n            3.     AAAA\n            4.     BBBBBB\n            5.     CCCCC\n            6.     DDDDDDD\n            7.     EEE\n           33.     THIS IS A DUMMY FILE WHICH WILL BE USED\n1EDITING AN ACTIVE FILE                                           III.D - 5\n\n\n          Bizarre situations can occur if you ask WYLBUR  to  copy\n          all   the   lines   containing  a  specified  string  of\n          characters because multiple copies  of  a  line  can  be\n          generated.\n\n          COMMAND? COPY 'A DUMMY' IN ALL TO 2.03 BY .01 (CR)\n          ABORTED BY ATTEMPT TO REPLACE OR INTERLEAVE. 2.99 - LAST LINE\n          COMMAND? LIST (CR)\n            1.     THIS IS A DUMMY FILE WHICH WILL BE USED\n            2.     TO SHOW THE EFFECT OF VARIOUS COPY COMMANDS.\n            2.03   THIS IS A DUMMY FILE WHICH WILL BE USED\n            2.04   THIS IS A DUMMY FILE WHICH WILL BE USED\n            2.05   THIS IS A DUMMY FILE WHICH WILL BE USED\n                 .\n                 .\n                 .\n            2.99   THIS IS A DUMMY FILE WHICH WILL BE USED\n            3.     AAAA\n            4.     BBBBBB\n            5.     CCCCC\n            6.     DDDDDDD\n            7.     EEE\n\n\n          These examples illustrate the importance of  considering\n          carefully the results of a COPY command before using it.\n\n          You may  specify  that  only  some  columns  are  to  be\n          searched  for  the  string.  The following example would\n          give the same results as the above example.\n\n          COMMAND? COPY 'A' COLUMNS 9/9 IN ALL TO 2.03 BY .01 (CR)\n          ABORTED BY ATTEMPT TO REPLACE OR INTERLEAVE. 2.99 - LAST LINE\n          COMMAND?\n\n          You may specify a LIST option.  This will result in  the\n          line  preceeding  the new lines as well as the new lines\n          being listed.\n\n          COMMAND?  COPY LIST (CR)\n             7.     EEE\n             8.     THIS IS A DUMMY FILE WHICH WILL BE USED\n             9.     TO SHOW THE EFFECT OF VARIOUS COPY COMMANDS.\n            10.     AAAA\n            11.     BBBBBB\n            12.     CCCCC\n            13.     DDDDDDD\n            14.     EEE\n1EDITING AN ACTIVE FILE                                           III.D - 6\n\n\n       e. COPY TO the End of a File\n\n          Frequently you may want to position the copied lines  at\n          the  end  of  the  file.   The special line number, END,\n          which is equal to LAST plus the current value for DELTA,\n          will allow this.  END is the  default  when  TO  is  not\n          specified.\n\n          COMMAND?  COPY 2.0 TO END (CR)\n          or\n          COMMAND?  COPY 2.0 (CR)\n\n       f. COPY FROM an External File\n\n          You may also copy lines from any external file by giving\n          a FROM phrase which specifies the external file.  If you\n          use dsname parameters  such  as  ON  volume,  they  must\n          follow the dsname.\n\n          a) COPY All of an External File\n\n             If the range is omitted, a default range  of  ALL  is\n             assumed.   If  the TO is omitted, a default TO END is\n             assumed.  Therefore, the command\n\n             COMMAND?  COPY FROM MYTEXT ON DCU209 (CR)\n               126.   - LAST LINE\n\n             would cause all of the external file named MYTEXT  to\n             be copied to the end of the active file.\n\n\n          b) COPY Part of an External File\n\n             COMMAND? COPY 1/57 TO 35 BY .1 FROM MYTEXT (CR)\n              97.    - LAST LINE.\n\n             This would cause all lines which are numbered between\n             1.000 and 57.000 in the external file named MYTEXT to\n             be copied into the active file starting  at  line  35\n             with  a  DELTA  (line  increment) of .1.  As with the\n             COLLECT or INSERT commands, there is  no  overwriting\n             or interleaving existing lines in the active file.\n\n             COMMAND?  COPY F(11) FROM MYFILE ON DCU207 (CR)\n                18.  -  LAST LINE\n\n             This command copies the first eleven lines  from  the\n             external file MYFILE to the END of the active file.\n\n             Another rule concerning the COPY command is that  any\n             external  file  which  is  specified  must be in edit\n             format.  Any file created  at  a  terminal  with  the\n             WYLBUR  system  is in edit format.  For a description\n             of the various formats, see FORMAT in Section VIII.\n1EDITING AN ACTIVE FILE                                           III.D - 7\n\n\n       g. COPY TO the Beginning of a File\n\n          To copy one file to the beginning of another, copy to  a\n          line  number  less than the first line.  For example, if\n          the first line of the active file which  is  to  receive\n          the copy is numbered 1,\n\n          COMMAND?  COPY TO .1 FROM FILE1 ON DCU208 (CR)\n\n          WYLBUR attempts to calculate a DELTA which will make all\n          the lines from the external file fit.  This command is a\n          convenient way to insert a file of JCL statements at the\n          beginning of a text file.\n\n       h. COPY part of an External File and COMBINE\n\n          The COMBINE parameter allows lines from an external file\n          to be merged  into  the  active  file.   The  difference\n          between COMBINE and MERGE is that MERGE requires a DELTA\n          whereas  COMBINE  will  use  the  line  numbers  in  the\n          external  file  to  determine the position in the active\n          file of the new lines.  Interleaving  is  permitted  but\n          replacing is not.\n\n          COMMAND? COPY 'abcd' FROM MYTEXT ON DCU208 COMBINE (CR)\n            6.5   - LAST LINE\n          COMMAND? LIST (CR)\n            1.     THIS IS A DUMMY FILE WHICH WILL BE USED\n            1.5    abcdgoldfish?\n            2.     TO SHOW THE EFFECT OF VARIOUS COPY COMMANDS.\n            3.     AAAA\n            4.     BBBBBB\n            5.     CCCCC\n            6.     DDDDDDD\n            6.5    abcdbbbbb?\n            7.     EEE\n          COMMAND?\n\n\n    2. MOVE\n\n       To copy a range of lines and delete the  old  copy  of  the\n       lines, use the command MOVE.  This functions exactly as the\n       COPY command with the following exceptions:\n\n          The old lines which were copied are deleted.\n\n          It is not possible to  apply  the  MOVE  command  to  an\n          external  file.\n1EDITING AN ACTIVE FILE                                           III.D - 8\n\n\n       Following are some examples of the MOVE command as  applied\n       to  the  sample  file  used  in the explanation of the COPY\n       command.\n\n       a. Move an Explicit Range of Lines\n\n          Range must be the first parameter.\n\n          COMMAND? MOVE 6/7 TO 2.03 BY .001 (CR)\n            2.031 - LAST LINE.\n          COMMAND? LIST (CR)\n            1.     THIS IS A DUMMY FILE WHICH WILL BE USED\n            2.     TO SHOW THE EFFECT OF VARIOUS COPY COMMANDS.\n            2.03   DDDDDDD\n            2.031  EEE\n            3.     AAAA\n            4.     BBBBBB\n            5.     CCCCC\n          COMMAND?\n\n       b. Move an Associative Range of Lines\n\n          COMMAND? MOVE 'FILE' IN 1/7 TO 33 (CR)\n          COMMAND? LIST (CR)\n            2.     TO SHOW THE EFFECT OF VARIOUS COPY COMMANDS.\n            3.     AAAA\n            4.     BBBBBB\n            5.     CCCCC\n            6.     DDDDDDD\n            7.     EEE\n           33.     THIS IS A DUMMY FILE WHICH WILL BE USED\n          COMMAND?\n\n          You may specify the special line  number  END  following\n          the  TO.   END  is  one  DELTA increment higher than the\n          current LAST of the active file.\n\n       c. MERGE\n\n          The MERGE option works just as for COPY except that  the\n          MOVED  lines  will be erased from their old position and\n          you may not MOVE from an external file.\n\n\n1EDITING AN ACTIVE FILE                                           III.E - 1\n\n\n E.  The ALIGN and JUSTIFY Commands\n\n These commands are used to adjust the LENGTH of lines in  a  file\n to   the  length  specified.   JUSTIFY  right-justifies  text  in\n addition; otherwise the commands are  identical.   They  will  be\n used  interchangably  in this section.  To ALIGN or JUSTIFY text,\n set LENGTH equal to the longest line you wish to  allow.   WYLBUR\n will  then arrange the lines so that they are as long as possible\n without exceeding the LENGTH specified.  Splits  in  a  line  are\n always  made  at  a blank; that is, a word is never split between\n two lines.\n\n WYLBUR assumes that each word or single character in a line to be\n aligned should be followed by one space unless it is  a  question\n mark,  period, or exclamation point, in which case it is followed\n by two spaces.\n\n       COMMAND? SET LENGTH = 80 (CR)\n       COMMAND? COLLECT 1 (CR)\n           1.   ?   $  THIS IS A SAMPLE FILE USED TO (CR)\n           2.   ?   SHOW THE EFFECTS OF (CR)\n           3.   ?   POSING THE ALIGN (CR)\n           4.   ?   COMMAND TO WYLBUR. (CR)\n           5.   ?   $ (CR)\n           6.   ?   THE $ MARKERS IN (CR)\n           7.   ?   COLUMN ONE CAUSE THE RESTARTING (CR)\n           8.   ?   OF THE (CR)\n           9.   ?   ALIGNMENT PROCESS. (CR)\n          10.   ?     (CR)\n          11.   ?   BUT TO USE MARKERS YOU MUST SPECIFY THE MARKER (CR)\n          12.   ?   OPTION IN THE ALIGN COMMAND. (CR)\n          13.   ?   ALSO NOTE THAT (CR)\n          14.   ?     INDENTED MATERIAL (CR)\n          15.   ?     WON'T BE ALIGNED (CR)\n          16.   ?     UNLESS SPECIFIED (CR)\n          17.   ?   (ATTN)***\n       COMMAND? JUSTIFY ALL LEN 28 (CR)\n       COMMAND? LIST (CR)\n           1.   $  THIS  IS  A  SAMPLE  FILE\n           2.   USED  TO SHOW THE EFFECTS OF\n           3.   POSING THE ALIGN COMMAND  TO\n           4.   WYLBUR.   $ THE $ MARKERS IN\n           5.   COLUMN   ONE    CAUSE    THE\n           6.   RESTARTING  OF THE ALIGNMENT\n           7.   PROCESS.\n           8.\n           9.   BUT TO USE MARKERS YOU  MUST\n          10.   SPECIFY THE MARKER OPTION IN\n          11.   THE   ALIGN  COMMAND.   ALSO\n          12.   NOTE THAT\n          13.     INDENTED MATERIAL\n          14.     WON'T BE ALIGNED\n          15.     UNLESS SPECIFIED\n\n1EDITING AN ACTIVE FILE                                           III.E - 2\n\n\n In order to JUSTIFY the text, WYLBUR inserts blanks between words\n alternating between starting from the right and starting from the\n left.  These blanks become part of the text.\n\n Note that the alignment process may cause a  renumbering  of  the\n aligned  portion  of  the  file using the largest DELTA possible.\n You may specify up to 5 disjoint explicit  ranges  in  one  ALIGN\n command.\n\n        COMMAND? ALIGN 1/2 4/5 7/8 10/11 13 (CR)\n\n A blank in column  one  (as  in  indented  material)  causes  the\n alignment  process  to  be restarted at the beginning of the next\n line, unless the INDENT option has been specified.\n\n    1. Aligning an Explicit Range\n\n       ALIGN and JUSTIFY  require  an  explicit  range.   You  may\n       specify  ALL  or  any single range of line numbers.  In the\n       example, only lines 8 to LAST are  to  be  aligned.   Also,\n       length  is  set to 28.  If this were not done, the previous\n       value of length would be used.\n\n       COMMAND? SET LENGTH = 28 (CR)\n       COMMAND? ALIGN 8/L (CR)\n       COMMAND? LIST 8/L (CR)\n         8.   OF THE ALIGNMENT PROCESS.\n         9.\n        10.   BUT TO USE MARKERS YOU MUST\n        11.   SPECIFY THE MARKER OPTION IN\n        12.   THE ALIGN COMMAND.  ALSO\n        13.   NOTE THAT\n        14.     INDENTED MATERIAL\n        15.     WON'T BE ALIGNED\n        16.     UNLESS SPECIFIED\n\n    2. Using a MARKER\n\n       Any line which has a special MARKER character in its  first\n       column  will cause the alignment process to be restarted at\n       the next line.  The MARKER line is not changed.  The MARKER\n       is designated in the ALIGN command if this option is to  be\n       used.   Do  not  use the characters ()\"' or = or lower case\n       letters (if UPLOW is  in  effect)  as  markers  unless  you\n       enclose   them   in   quotation   marks  (e.g.   ALIGN  ALL\n       MARKER=',').  If a marker appears anywhere except column 1,\n       it is treated as any other character.\n1EDITING AN ACTIVE FILE                                           III.E - 3\n\n\n       COMMAND? SET LENGTH = 28 (CR)\n       COMMAND? ALIGN ALL MARKER = $ (CR)\n       COMMAND? LIST (CR)\n           1.   $  THIS IS A SAMPLE FILE USED TO\n           2.   SHOW THE EFFECTS OF POSING\n           3.   THE ALIGN COMMAND TO WYLBUR.\n           4.   $\n           5.   THE $ MARKERS IN COLUMN ONE\n           6.   CAUSE THE RESTARTING OF THE\n           7.   ALIGNMENT PROCESS.\n           8.\n           9.   BUT TO USE MARKERS YOU MUST\n          10.   SPECIFY THE MARKER OPTION IN\n          11.   THE ALIGN COMMAND.  ALSO\n          12.   NOTE THAT\n          13.     INDENTED MATERIAL\n          14.     WON'T BE ALIGNED\n          15.     UNLESS SPECIFIED\n\n    3. NUMBER\n\n       The  NUMBER  option  will  cause  the  entire  file  to  be\n       renumbered rather  than  just  the  aligned  portion.   The\n       starting line number and increment will both be DELTA.\n\n\n    4. Setting LENGTH in the ALIGN Command\n\n       A temporary LENGTH, for use only during  execution of the\n       ALIGN command, may be specified in the command.\n\n       COMMAND?  ALIGN ALL LENGTH = 40 MARKER = $ (CR)\n\n       If WYLBUR attempts to ALIGN  a  line  which  has  a  string\n       longer  than  the  current LENGTH, the whole string will be\n       placed on a single line.  For example,\n\n       COMMAND? LIST (CR)\n          1.   ABCDEFGHIJKLMNOPQRSTUVWXYZ   or\n          2.   ZYXWVUTSRQPONMLKJIHGFEDCBA\n       COMMAND?   ALIGN ALL LEN 20 (CR)\n       COMMAND?   LIST  (CR)\n          1.   ABCDEFGHIJKLMNOPQRSTUVWXYZ\n          2.   or\n          3.   ZYXWVUTSRQPONMLKJIHGFEDCBA\n       COMMAND?\n1EDITING AN ACTIVE FILE                                           III.E - 4\n\n\n    5. SPACE option\n\n       The SPACE option may be  used  to  squeeze  out  spaces  on\n       material  to  be  aligned  or  justified.  It is especially\n       useful on successive JUSTIFYs of the same text.  As  WYLBUR\n       justifies text, it inserts blanks to even up the right hand\n       margin.   These  spaces  become  part  of  the  text and if\n       successive JUSTIFY commands are used, it may begin to  look\n       awkward.   The  SPACE  option  will first compress multiple\n       blanks.  It will then restart the justification process  on\n       the file, leaving two blanks after a period, question mark,\n       exclamation point, or colon.\n\n    6. Aligning Indented Material - INDENT Option\n\n       Indented material is ordinarily ignored  in  the  alignment\n       process.   In  order to align or justify indented material,\n       you must use the INDENT option and specify  the  column  in\n       which the material begins.\n\n       COMMAND?  ALIGN ALL INDENT 5 (CR)\n\n       This command will align only those lines indented 5  spaces\n       (lines  starting  in column 6).  Lines starting in column 1\n       have an indentation of 0 so they are ignored.\n\n    7. Indenting Material - EVEN Option\n\n       The ALIGN command may be used to  indent  material  if  you\n       specify  the  EVEN option with the INDENT option.  There is\n       no separate INDENT command in WYLBUR.\n\n       COMMAND? JUSTIFY 1/10 INDENT 5 EVEN LEN 30 (CR)\n\n       This command will align and  justify  lines  1  through  10\n       indenting  them  all 5 spaces regardless of where each line\n       started.  Any leading blanks are stripped off.  The  LENGTH\n       of  50 includes the 5 leading spaces, so only 45 spaces are\n       left for the text.\n\n       Since EVEN will indent all  material  no  matter  in  which\n       column  the  text  began,  it  can  change  all of a file's\n       format.  Take care with the EVEN option lest you find  your\n       indentations and columns destroyed.\n1EDITING AN ACTIVE FILE                                           III.E - 5\n\n\n       a. Indenting Paragraphs\n\n          The INDENT option may have  two  numbers  following  it.\n          The  second  number  may be used for indenting the first\n          line of paragraphs.\n\n          COMMAND?  JUSTIFY ALL INDENT 5 4 EVEN (CR)\n\n          This command will justify all lines of a file, indenting\n          them 5 spaces plus 4 more each  time  the  alignment  is\n          restarted  after a null or marker line.  Since no marker\n          was specified in this command,  alignment  is  restarted\n          only  after  each  null  line.  If you have a blank line\n          between paragraphs, the first line of each paragraph  is\n          indented 9 spaces.\n\n          COMMAND? ALIGN ALL LEN 30 INDENT 0 4 EVEN (CR)\n             1.        $  THIS IS A SAMPLE FILE\n             2.    USED TO SHOW THE EFFECTS OF\n             3.    POSING THE ALIGN COMMAND TO\n             4.    WYLBUR.  $ THE $ MARKERS IN\n             5.    COLUMN ONE CAUSE THE\n             6.    RESTARTING OF THE ALIGNMENT\n             7.    PROCESS.\n             8.\n             9.        BUT TO USE MARKERS YOU\n            10.    MUST SPECIFY THE MARKER OPTION\n            11.    IN THE ALIGN COMMAND.  ALSO\n            12.    NOTE THAT INDENTED MATERIAL\n            13.    WON'T BE ALIGNED UNLESS\n            14.    SPECIFIED\n\n       b. Hanging Indentations\n\n          The second number following the keyword  INDENT  may  be\n          negative, in which case a hanging indentation results.\n\n          COMMAND?  ALIGN 1/3 INDENT 10-4 EVEN LENGTH 30 (CR)\n\n          This command aligns lines 1 through 3 indenting them  10\n          spaces  regardless  of their previous indentation.  Each\n          time the alignment process is restarted, the first  line\n          is indented 6 spaces (10-4).\n\n          COMMAND? LIST 1/3 (CR)\n             1.         THIS IS A SAMPLE FILE\n             2.             USED TO SHOW A\n             3.             HANGING INDENT.\n\n1EDITING AN ACTIVE FILE                                           III.F - 1\n\n\n F.  The CENTER Command (Short Form: CEN)\n\n The CENTER command may be used to center text on a line within  a\n specified length.  It is useful in centering titles, headings, or\n lines of text to be emphasized.\n\n             COMMAND? SET LENGTH 50 (CR)\n             COMMAND? CENTER FIRST (CR)\n             COMMAND? LIST FIRST (CR)\n                1.                 THIS IS MY TITLE\n             COMMAND?\n\n The text is centered assuming leading and trailing blanks  to  be\n insignificant.   The  first and last non-blank characters will be\n symmetrically placed at the center  of  the  line  based  on  the\n LENGTH  that  has  been set.  Blanks imbedded within the line are\n not changed.\n\n         1.  Specifying LENGTH\n\n             You may  override  the  global  LENGTH  parameter  by\n             specifying a LENGTH option in the command.\n\n             COMMAND? CENTER 20 LENGTH=26 (CR)\n             COMMAND? LIST 19/21 (CR)\n               19.  ABCDEFGHIJKLMNOPQRSTUVWXYZ\n               20.       February 14, 1984\n               21.  12345678901234567890123456\n             COMMAND?\n\n         2.  Explicit Range\n\n             You may specify an explicit range in the command.\n\n             COMMAND? CENTER 1/3 LEN 30 (CR)\n             COMMAND? LIST 1/3 (CR)\n               1.     208 Computer Center\n               2.     Columbia University\n               3.   New York, New York 10027\n         COMMAND?\n\n         3.  Centering Indented Material\n\n             You may center indented material  by  specifying  the\n             INDENT option with the CENTER command.\n\n             COMMAND?  CENTER 3 IND 4 LEN 20  (CR)\n\n             This will center text between columns 4 and 20.\n1EDITING AN ACTIVE FILE                                           III.G - 1\n\n\n G.  The EDIT and MODIFY Commands\n\n EDIT and MODIFY are very powerful commands  for  making  multiple\n changes in a line or a range of lines.\n\n    1. EDIT (Short Form: EDI or E)\n\n       The EDIT command may be used to change a line or a range of\n       lines in the active file without retyping the entire  line.\n       WYLBUR's  response to EDIT is fairly complex.  First WYLBUR\n       lists the number and contents of the line to be edited  and\n       then prompts with the word EDITS.\n\n       COMMAND?  EDIT 2 (CR)\n           2.    THIS IS THE LINE TO BEEDITED.\n          EDITS ?\n\n       If you decide that the line does not need to be edited, hit\n       carriage return immediately after the EDITS?   prompt.   If\n       you  wish  to make changes, space over to the character you\n       wish to replace and type the replacement character.  WYLBUR\n       will list the line with the changes and again  prompt  with\n       the  word  EDITS ?  You may continue to make changes or end\n       the command with a carriage return.  You may  make  several\n       changes  per  line;  you  may  even change every character,\n       though it would  be  more  efficient  to  use  the  REPLACE\n       command  for  that.   To  replace a character with a blank,\n       type a vertical bar (| on a 2741).  If you type a | under a\n       blank, you will get a | on the output.  There is no way  to\n       insert  or  delete  a  character unless you replace all the\n       remaining characters in the line.\n\n       COMMAND?  EDIT 2 (CR)\n           2.     THIS IS THE LINE TO BEEEDITED\n         EDITS ?    at                  |      .(CR)\n           2.     THAT IS THE LINE TO BE EDITED.\n         EDITS ?          not the|line|to|edit.|(CR)\n           2.     THAT IS NOT THE LINE TO EDIT.\n         EDITS ? (CR)\n       COMMAND?\n\n       In the first example, the two characters IS  were  replaced\n       with  AT, E was blanked, and a period was inserted.  In the\n       last example, the word \"not\" was inserted and the word \"be\"\n       and letters \"ed\" were deleted.  Obviously, this is  awkward\n       and  it  might  be  simpler  to use the REPLACE command and\n       retype the entire line.\n1EDITING AN ACTIVE FILE                                           III.G - 2\n\n\n       a. Range\n\n          You may specify an explicit  or  associative  range  and\n          WYLBUR  will  prompt  with successive line numbers until\n          the range is exhausted.  In  the  preceding  example,  a\n          single  line  was  specified.  You may specify up to ten\n          line numbers in a list rather  than  type  ten  separate\n          commands.\n\n          COMMAND?  EDIT 2 3 4/5 (CR)\n\n          If you do not specify a range, ALL is assumed.\n\n\n       b. NOLIST (Short Form: N)\n\n          Normally, WYLBUR lists  the  corrected  line.   You  may\n          suppress this by specifying NOLIST.\n\n          COMMAND?  EDIT 2 NOLIST (CR)\n                2.   THIS IS THE LINE TO BEEEDITED\n            EDITS ?    at                  |      .\n            EDITS ? (CR)\n          COMMAND?\n\n          There is another way of specifying NOLIST once  you  are\n          in the EDIT command.  An N in column 0 will suppress the\n          listing  for  that  line  only.   An  L in column 0 will\n          override the NOLIST option and list the corrected  line.\n          Note  that  column  0 does not correspond to a column in\n          the line being edited; it must be blank, N, or L.\n\n          COMMAND? EDIT 2 (CR)\n             2.      THIS IS THE LINE TO BEEEDITED\n            EDITS ? N  at                  |      .(CR)\n            EDITS ? (CR)\n          COMMAND?\n\n\n       c. SINGLE (Short Form: S)\n\n          WYLBUR will prompt with EDITS ? for each line until only\n          a  carriage  return  is  given  in response.  The SINGLE\n          option can be used to change  this  to  one  prompt  per\n          line.\n\n          COMMAND? EDIT 3 SINGLE (CR)\n              3.     This is the line.\n            EDITS ?    at(CR)\n              3.     That is the line.\n          COMMAND?\n1EDITING AN ACTIVE FILE                                           III.G - 3\n\n\n          There is another way to indicate SINGLE if you  did  not\n          specify  it  in  the  EDIT command.  Simply type @(ATTN)\n          instead of a carriage return at the end of a line.  This\n          will give another prompt for the current line if  SINGLE\n          was  specified or terminate prompts for the current line\n          if the normal multiple mode was in effect.\n\n       d. Terminating the EDIT Command\n\n          To end the EDIT command  normally,  press  the  carriage\n          return  as  the  first  character  in  a  line after all\n          editing has been done.\n\n          COMMAND? EDIT 2 (CR)\n              2.     THAT IS NOT THE LINE TO EDIT.\n            EDITS ? (CR)\n          COMMAND?\n\n\n          1. Terminating All Lines Remaining in the Range - $(ATTN)\n\n             $(ATTN) will  terminate  the  command  including  any\n             remaining  lines if you have specified an explicit or\n             associative range.\n\n             COMMAND? EDIT 2 3 (CR)\n                 2.     THAT IS NOT THE LINE TO EDIT.\n               EDITS ?    is$(ATTN)\n                 2.     THIS IS NOT THE LINE TO EDIT.\n             COMMAND?\n\n          2. Terminating the Current Line Only - @(ATTN)\n\n             If you are in multiple prompt  mode,  typing  @(ATTN)\n             will stop further prompts for that line only.\n\n             COMMAND? EDIT 2 3 NOLIST (CR)\n                 2.     THAT IS NOT THE LINE TO EDIT.\n               EDITS ?    is @(ATTN)\n                 3.     NEXT LINE\n\n             The replacement characters \"IS\" are entered  in  this\n             case.\n\n          3. Terminating and Eliminating the EDITS - (ATTN)\n\n             Pressing the ATTN key aborts the command and  reneges\n             on  EDITS made to the current line.  The line will be\n             as it was before you used the EDIT command.\n1EDITING AN ACTIVE FILE                                           III.G - 4\n\n\n       e. Changing from EDIT to MODIFY\n\n          Use \u00a2(ATTN) to change to the MODIFY command.   Refer  to\n          the next section for a discussion of MODIFY.\n\n       f. Summary of the Use of the ATTN key in the EDIT Command\n\n          1. (ATTN)\n             Pressing (ATTN) in response to the EDITS prompt  will\n             abort  the command and leave the line unchanged.  All\n             lines already edited will remain in  their  new  form\n             and no subsequent lines in the range will be edited.\n          2. $(ATTN)\n             The  $(ATTN)  terminates  the  whole   EDIT   command\n             including  any unedited lines remaining in the range.\n             It does not affect lines already  terminated  with  a\n             (CR)  or  alterations  in  the  line  terminated with\n             $(ATTN).\n          3. @(ATTN)\n             @(ATTN) gives one more prompt  in  SINGLE  mode.   In\n             multiple  mode  it  changes to SINGLE mode, and lists\n             the line but gives no more  prompts.   If  there  are\n             other  lines  remaining in the range, they are listed\n             and EDITS are prompted for.\n          4. \u00a2(ATTN)\n             Pressing \u00a2(ATTN) in response to an EDITS prompt  will\n             switch  you  to  the MODIFY command.  The next prompt\n             will be ALTERS ?  instead of EDITS ?.\n\n\n1EDITING AN ACTIVE FILE                                           III.G - 5\n\n\n    2. The MODIFY Command (Short Form: MOD or M)\n\n       Like EDIT, MODIFY can be used to alter a line or a range of\n       lines without retyping all of each line, but  MODIFY  makes\n       it  easier  to insert or erase characters.  You may specify\n       an explicit or associative  range  of  lines.   The  MODIFY\n       command   allows   you  to  make  the  following  types  of\n       alterations to a line of text:\n\n             delete -    WYLBUR deletes the  characters  indicated\n                         by  you  and shifts the text to eliminate\n                         the resultant blanks.\n\n             blank -     WYLBUR changes the  characters  indicated\n                         to blanks and does not shift the text.\n\n             insert -    WYLBUR inserts the  character(s)  in  the\n                         position   indicated   and   shifts   the\n                         remainder  of  the  text  to the right as\n                         many places as necessary.\n\n             replace -   WYLBUR deletes the old  character(s)  and\n                         inserts the new one(s).\n\n       Although MODIFY has this broad range of  capabilities,  the\n       nature  of  the  responses  involved and the time they take\n       mean that this command may be  used  efficiently  only  for\n       certain kinds of modifications.\n\n       WYLBUR's response to MODIFY is similiar to its response  to\n       EDIT.   First  it  types  the  line to be modified and then\n       prompts for alterations with the word ALTERS.\n\n            COMMAND?  MODIFY 23.01 (CR)\n             23.01   THIS LINE IS TOOO BE MODIFIED.\n            ALTERS ?\n\n       At this point any of the four types of alterations  may  be\n       made to the line, or if it looks all right, you may end the\n       MODIFY  command  with  a  carriage  return  and no changes.\n       However, there is one significant  difference  between  the\n       responses  to  MODIFY  and  to EDIT.  Alterations to MODIFY\n       require a key to designate  which  of  the  four  types  of\n       alterations  you  are  doing;  d  (delete),  b  (blank),  i\n       (insert),   and   r  (replace).   To  enter  a  replacement\n       character without  first  typing  the  key  is  an  illegal\n       response.   Blanks  entered  as  replacement characters are\n       significant as will be illustrated in the example.\n\n1EDITING AN ACTIVE FILE                                           III.G - 6\n\n\n       After you have  made  alterations  and  used  the  carriage\n       return,  WYLBUR  will  type  the  line with the changes and\n       issue another ALTERS prompt.  You may then make  additional\n       changes or end the command with a carriage return.\n\n       Although there are  a  few  exceptions,  usually  only  one\n       modification may be entered on a line.  This restriction of\n       one  change per typed line at a time can make MODIFY a slow\n       command to use.  If a line is to be changed  in  more  than\n       one  place, it may be easier to use the REPLACE command and\n       retype the whole line or to use the EDIT command.\n\n       MODIFY may be used with the range  capability  which  saves\n       you from typing several commands.\n\n                 MODIFY  1/3 7 10 12 16 20/30 40/50 (CR)\n\n       Even in this case, other  commands  may  be  handier.   For\n       example,  if  you  wish  to make an identical change to the\n       same text in several lines (associative range) or  wish  to\n       make  a  change in the same column in each line, it is much\n       faster to use the CHANGE command.  If you want to change  a\n       few  characters in each line, use EDIT.  MODIFY is handiest\n       for inserting and deleting characters to a range  of  lines\n       because it shifts the text for you.\n\n       To return  to  the  example,  any  of  the  four  types  of\n       alterations described below may be made to a line.\n\n\n       a. To Delete Characters from a Line--D\n\n          To remove characters from  a  line  type  the  letter  D\n          beneath  the  first letter to be deleted and type either\n          spaces or D's beneath each character you wish to delete,\n          then hit carriage return.  The extra characters in  TOOO\n          are removed from the line in the following example.\n\n          COMMAND?  MODIFY 23.53 (CR)\n           23.53     THIS LINE IS TOOO BE MODIFIED\n            ALTERS ?                DD(CR)\n           23.53     THIS LINE IS TO BE MODIFIED\n            ALTERS ? (CR)\n          COMMAND?\n\n          Actually, it is necessary to type a  D  under  only  the\n          first  character  of any string which is to be deleted -\n          everything between the D and the carriage return will be\n          deleted.  Note that the carriage return  will  be  after\n          the  last  character  to be deleted has had a blank or D\n          typed under it.  The (CR) response to the second ALTERS?\n          prompt signals the end of the modification  process  for\n          that line.\n\n1EDITING AN ACTIVE FILE                                           III.G - 7\n\n\n       b. To Blank Characters in a Line--B\n\n          The blank option replaces with blanks all  positions  in\n          the  line  that  have  a B typed under them.  The option\n          does not change the character position of the  line  and\n          it erases only those positions that have a B typed under\n          them.   Any other modify character may follow the B (see\n          e. below).\n\n          COMMAND?  MODIFY 23.53 (CR)\n           23.53     THIS LINE ISSTO BE MODIFIED\n            ALTERS ?             B(CR)\n           23.53     THIS LINE IS TO BE MODIFIED\n\n       c. To Insert Characters in a Line--I\n\n          You may insert new  characters  into  a  line  by  first\n          typing  an  I  underneath the character before which the\n          insertion is to be made  and  following  this  with  the\n          character string to be inserted.\n\n          COMMAND?  MODIFY 23.53 (CR)\n           23.53     THIS LINE IS TO BE MODIFIED\n            ALTERS ?              IGOING (CR)\n           23.53     THIS LINE IS GOING TO BE MODIFIED\n            ALTERS ? (CR)\n          COMMAND?\n\n          Notice there is a space  between  GOING  and  the  (CR).\n          That is necessary to provide for the space between GOING\n          and TO.\n\n       d. To Replace Characters in a Line--R\n\n          Finally, you may replace a character string in the  line\n          contents  by typing an R under the first character to be\n          replaced and following this with a string of  characters\n          which  are  the  replacements.   As  many characters are\n          replaced, starting with the one over the R, as there are\n          characters in the string, including blanks.\n\n          COMMAND? MODIFY 23.53 (CR)\n           23.53     THIS LINE IS NOT TO BE MOD\n            ALTERS ?                  RBEING MODIFIED (CR)\n           23.53     THIS LINE IS NOT BEING MODIFIED\n            ALTERS ? (CR)\n          COMMAND?\n1EDITING AN ACTIVE FILE                                           III.G - 8\n\n\n          Using the R  indicator  restricts  you  to  replacing  a\n          number of characters with the same number of characters.\n          In  the  example above, the new text had more characters\n          but the excess characters were replacing blanks  at  the\n          end  of  the line.  To do a replacement with a different\n          number of characters, use a combination of the D  and  I\n          indicators as illustrated in the next paragraph.\n\n       e. Multiple Modifications in a Line DI-DR, BI-BR-BD\n\n          A few combinations of alterations are allowed per ALTERS\n          prompt.  They are:\n\n          Delete followed by Insert or Replace (DI or DR)\n          Blank followed by Insert, Replace or Delete (BI, BR, BD)\n\n          To replace a string by a longer string, it is convenient\n          to use delete followed by insert.\n\n          COMMAND?  MODIFY 23.53 (CR)\n           23.53     THIS LINE IS NOW BEING MODIFIED\n            ALTERS ?              D DIIN THE PROCESS OF(CR)\n           23.53     THIS LINE IS IN THE PROCESS OF BEING MODIFIED\n            ALTERS ? (CR)\n          COMMAND?\n\n          The D D caused the word NOW to  be  deleted  and  the  I\n          under the blank following the word NOW caused the string\n          following the I to be inserted before the blank.\n\n          It was not necessary to type the second  D  to  indicate\n          the  range  of  the  deletion since the I indicator will\n          automatically  terminate  the  deletion  range  at   the\n          character position just before the I.\n\n          To replace a long string by a shorter  string,  you  may\n          follow  the  D  range with a replacement indicator and a\n          string of replacement characters.\n\n          COMMAND?  MODIFY 23.53 (CR)\n           23.53     THIS LINE IS IN THE PROCESS OF BEING MODIFIED\n            ALTERS ?           D                 RHAS BEEN(CR)\n           23.53     THIS LINE HAS BEEN MODIFIED\n            ALTERS ? (CR)\n          COMMAND?\n\n          The string that  was  deleted  included  a  blank  after\n          PROCESS.  Had the blank not been included, the corrected\n          version  would  have  included 2 blanks between LINE and\n          HAS as shown below.  This is because the blank following\n          LINE becomes the blank between LINE and HAS.\n\n          THIS LINE  HAS BEEN MODIFIED\n1EDITING AN ACTIVE FILE                                           III.G - 9\n\n\n          COMMAND?  MODIFY 23.53 (CR)\n           23.53   THIS LINE ISSTOOOBE MODIFIED\n            ALTERS ?           B  BD(CR)\n           23.53   THIS LINE IS TO BE MODIFIED\n\n       f. To Complete the Alteration Process Normally\n\n          To signal that all alterations to  the  line  have  been\n          completed,  type  only a carriage return into the ALTERS\n          line.\n\n           23.53     THIS LINE HAS BEEN MODIFIED\n            ALTERS ? (CR)\n\n\n       g. NOLIST--N\n\n          In the  above  examples  WYLBUR  always  typed  out  the\n          modified   image   of   the  line  after  the  specified\n          alteration.  This may be suspended by specifying  NOLIST\n          (or  N)  as  illustrated  in  the discussion of the EDIT\n          command (see 1.b above) or by typing an N before  giving\n          any alteration indicators.\n\n          COMMAND?  MODIFY 23.53 (CR)\n           23.53     THIS LINE IS TOOOO BE MODIFIED\n            ALTERS ?               ND D(CR)\n            ALTERS ? (CR)\n          COMMAND?\n\n\n          The position of the N is of no concern to WYLBUR as long\n          as  it  appears  before  any  other  characters  on  the\n          alteration line.  On the other hand, you may get a  copy\n          of  the modified line, as it stands after correction, by\n          typing a few blanks into the ALTERS line before  hitting\n          Return.   Remember  that hitting Return alone causes the\n          modification process to be terminated.\n\n          COMMAND?  MODIFY 23.53 (CR)\n           23.53     THIS LINE IS TOOO BE MODIFIED\n            ALTERS ?              N DD(CR)\n            ALTERS ?    (CR)\n           23.53     THIS LINE IS TO BE MODIFIED\n            ALTERS ? (CR)\n          COMMAND?\n1EDITING AN ACTIVE FILE                                           III.G - 10\n\n\n       h. SINGLE--S\n\n          The SINGLE option has the same function for MODIFY as it\n          does for the EDIT command.  It produces a single  ALTERS\n          prompt  per  line  instead of the usual multiple prompt.\n          If you specify SINGLE or S in the MODIFY command, ending\n          an ALTERS line with @(ATTN) instead of a (CR) will  give\n          you one more prompt.\n\n          COMMAND?  MODIFY 23.53 SINGLE (CR)\n           23.53     THIS LINE IS TO BE MODIFIED\n            ALTERS ?   RAT(CR)\n           23.53     THAT LINE IS TO BE MODIFIED\n          COMMAND?\n\n          COMMAND?  MODIFY 23.53 SINGLE (CR)\n           23.53     THAT LINE IS TO BE MODIFIED\n            ALTERS ?   RIS @(ATTN)\n           23.53     THIS LINE IS TO BE MODIFIED\n            ALTERS ?   RAT(CR)\n           23.53     THAT LINE IS TO BE MODIFIED\n          COMMAND?\n\n\n\n       i. Terminating the MODIFY Command\n\n          The MODIFY command is terminated just the same as  EDIT.\n          There is a full discussion in Section III.F.1.  Briefly,\n          the ways of terminating the MODIFY command are:\n\n           (CR)        Normal Termination\n\n           $(ATTN)     Terminates the current line and  all  lines\n                       remaining in the range.\n\n           @(ATTN)     Changes from single prompt mode and  allows\n                       one more prompt.\n\n           (ATTN)      Terminates  the  command   and   eliminates\n                       modifications made in the current line.\n\n           \u00a2(ATTN)     Change from MODIFY to the EDIT command.\n1SAVING, RETRIEVING, DELETING                                       IV.A - 1\n\n\n IV.  Saving, Retrieving and Deleting a File\n\n Files not currently active are kept as external  files  on  disk.\n The  active  file  is  not on disk; while being modified it is in\n core storage.  WYLBUR has commands which enable you to SAVE  your\n active  file onto a disk and USE a copy of it (bring a copy of it\n to your active file) later in the session or in a later  session.\n Once saved, the file will remain on disk until you delete it with\n a  SCRATCH  command.  You may also retrieve a copy of a file that\n someone else has created, provided  you  know  his  initials  and\n group  ID.  USE is the command for retrieving a file.  It reads a\n copy of the file from disk into your active file.\n\n In order to use any of these commands, it is necessary to specify\n the name of the disk volume on which the external file resides or\n is to reside.  You must select a volume when  you  save  a  file.\n All  future  references  to  this external file must mention this\n volume either explicitly or implicitly.\n\n There are  certain  naming  conventions  that  must  be  observed\n whenever you SAVE, SCRATCH or USE a file.  These are explained in\n Section IV.D.\n\n Throughout this section assume that you are a WYLBUR  user  whose\n user ID is ABC and whose group ID is UR.\n\n A.  SAVE (Short Form:  S)\n\n To save a data set or a section of text or JCL that has just been\n created, leave COLLECT mode, type SAVE, give the data set a  name\n and  specify  the disk volume on which it is to be saved.  Saving\n the active file creates an external file by  writing  a  copy  of\n your  active  file onto the volume specified and giving that copy\n the name specified.  The active file remains  unchanged  and  you\n may  continue  working  with it.  It must be cleared with a CLEAR\n ACTIVE command before you can retrieve  another  file.   You  may\n save  a  data set only in your WYLBUR space; you may save it as a\n member of a partitioned data set (PDS) or as  a  sequential  data\n set  (For  a  discussion  of differences between the two kinds of\n data sets, see Section  IV.D  ).   A  PDS  member  name  must  be\n enclosed  in  parentheses  or,  alternatively, be preceded by a #\n sign.  If you do not use parentheses or the # sign, the data  set\n is saved as a sequential one.\n\n Suppose you want to save a file which you  will  name  MYTEXT  on\n DCU207.\n\n       COMMAND?  SAVE MYTEXT ON DCU207(CR)\n       WYL.UR.ABC.MYTEXT SAVED ON DCU207\n       COMMAND?\n\n1SAVING, RETRIEVING, DELETING                                       IV.A - 2\n\n\n The data set name (dsname or dsn) MYTEXT is assigned to your file\n and WYLBUR generates the WYL.UR.ABC heading from  your  user  and\n group  IDs.   The  WYL.   identifies it to the system as a WYLBUR\n file.   See  Section  IV.D.   for  more  about  data  set  naming\n conventions.  The SAVE command just shown is the simplest form of\n SAVE.  In addition there are a number  of  additional  parameters\n which may be used.\n\n    1. VOLUME\n\n       The file in the example  was  saved  on  the  disk  volume\n       called DCU207.  If you do not specify a volume in the SAVE\n       command, WYLBUR will prompt for it.\n\n       COMMAND? SAVE MYTEXT(CR)\n       VOLUME ? DCU207(CR)\n       WYL.UR.ABC.MYTEXT SAVED ON DCU207\n       COMMAND?\n\n       In order to specify the volume on which your  file  is  to\n       reside, you must know which are available for SAVE's.\n\n       COMMAND? SHOW VOLUMES (CR)\n       USE & SAVE -- DCU106 DCU111 DCU131 DCU132 DCU150 DCU207\n                DCU208 DCU209\n       TEMPORARY --  DCU115 DCU118\n       USE --   DCU110 DCU117 DCU126 DCU141 DCU142 DCU147\n\n       WYLBUR's reply of USE & SAVE  --  DCU106...   DCU209  means\n       that  the  volumes named DCU106...  DCU209 may be used with\n       the USE and SAVE commands.  The  second  line  of  WYLBUR's\n       reply  means  that  data  sets  on  these  volumes  will be\n       scratched periodically and should not be used for data sets\n       that are to  be  saved  permanently.   The  third  line  of\n       WYLBUR's  reply  means  that  the  volumes  named DCU110...\n       DCU147 are valid for the USE command only.  Thus  any  data\n       set  on one of those volumes may be fetched at the terminal\n       but  you  cannot  save  a  data  set  on   those   volumes.\n       Ordinarily,  you  should only SAVE your sequential files on\n       the same volume on which your LIBRARY is  allocated.   Only\n       users  with  a  GROUP  ID  of  BI  are permitted to SAVE on\n       DCU150; only users  with  a  GROUP  ID  of  CU  or  IS  are\n       permitted  to  SAVE  on  DCU131 and DCU132.  All other data\n       sets will be SCRATCH'ed from these volumes.\n\n       If  you  exceed  your  sequential  space  allocation  while\n       executing  a  SAVE,  WYLBUR  will  allow  the  command   to\n       complete.   However if your total space allocation has been\n       met or  exceeded  any  furthur  sequential  saves  will  be\n       blocked  (a  message  will  be  given  to that effect).  To\n       permit a dataset to be saved or to allow recovery, at least\n       one track of your sequential space must be unused.  If your\n       allocation has  been  used  completely  or  exceeded,  your\n       active  file  will not be saved by WYLBUR (recovery) in the\n       event of a system crash.   WYLBUR  will  also  give  you  a\n       warning   message  when  you  have  90%  or  more  of  your\n       allocation .\n1SAVING, RETRIEVING, DELETING                                       IV.A - 3\n\n\n       In  a  number  of  the  following  examples  no  volume  is\n       specified, this  is  because  a  default  volume  has  been\n       established.   This  is  done using the SET VOLUME command.\n       This command establishes a default VOLUME for  any  command\n       that   requires  a  VOLUME  to  be  specified,  it  may  be\n       overridden at any time by explicitly stating the volume  in\n       your command.\n\n       COMMAND? SET VOLUME DCU208(CR)\n       COMMAND? SAVE MYTEXT(CR)\n       WYL.UR.ABC.MYTEXT SAVED ON DCU208\n       COMMAND?\n\n       In addition to setting the volume to a specific  volume  it\n       may  also  be set to refer to the system catalog.  This way\n       WYLBUR will keep track of the location of all of your  data\n       sets  for  you.   The  first time that you place a data set\n       onto the disk, however, you will have to specify  a  volume\n       explicitly.\n\n       COMMAND? SET VOLUME CATLG(CR)\n       COMMAND? SAVE MYTEXT ON DCU208 CATLG(CR)\n       COMMAND? USE MYTEXT(CR)\n       VOLUME IS DCU208\n       COMMAND?\n\n\n    2. REPLACE/SCRATCH\n\n       If a file already exists and you want to replace it with a\n       new version, you may do it in one operation by  using  the\n       REPLACE  or  SCRATCH  parameter on the SAVE command.  Both\n       commands are synonymous.\n\n       COMMAND? SAVE MYTEXT ON DCU207 REPLACE(CR)\n       WYL.UR.ABC.MYTEXT  REPLACED ON DCU207\n\n       For sequential data sets WYLBUR checks to see that you have\n       not exceeded your space allocation, then scratches the  old\n       copy  and  saves  the new copy.  For library members WYLBUR\n       first saves the new copy and then  deletes  the  old  copy.\n       The dsname cannot be omitted.  SAVE REPLACE ON DCU207 would\n       save your file with the dsname REPLACE.\n\n    3. Format\n\n       Data sets are automatically saved in  the  form  in  which\n       they  were  created  (EDIT  format)  but it is possible to\n       choose CARD, PRINT, or LRECL formats.  However,  only  the\n       EDIT  format  is allowed for PDSs.  For details on format,\n       see Section VIII and the SAVE command in Section VII.\n\n1SAVING, RETRIEVING, DELETING                                       IV.A - 4\n\n\n    4. NUMBERED/INTEGER\n\n       The NUMBERED option specifies that the file would be  saved\n       with  line  numbers  in the last eight positions of 80 byte\n       records, saving it with LRECL=80, unless some  other  LRECL\n       is specified.  The data set is not saved in EDIT format and\n       may  take  much  more  disk  space  than  EDIT format would\n       require.\n\n       The INTEGER  option  performs  the  same  function  as  the\n       NUMBERED option, except that columns 73-80 contain 8 -digit\n       integers.\n\n    5. CATLG\n\n       a. Sequential Data Sets\n\n          You may specify CATLG to have the system make  an  entry\n          in  the  system  catalog for an external file.  When you\n          retrieve that  file  later  you  may  specify  ON  CATLG\n          instead  of  the  volume name.  You must assign a volume\n          the first time it is saved.\n\n          COMMAND? SAVE MYTEXT ON DCU207 CATLG (CR)\n          WYL.UR.ABC.MYTEXT  SAVED AND CATLG'D ON DCU207\n\n          You may now access the file MYTEXT without  remembering\n          which volume it is on:\n\n          COMMAND? USE MYTEXT ON CATLG(CR)\n\n          If you had omitted the CATLG in the SAVE  example,  the\n          file  called  MYTEXT  would  have  been  saved  but not\n          cataloged and a volume specification  would  have  been\n          necessary to retrieve it.\n\n          COMMAND? USE MYTEXT ON DCU207(CR)\n\n          If a data set is already cataloged, you may specify  ON\n          CATLG  to  save the data set on the volume named in the\n          catalog.  If you do not specify  REPLACE,  WYLBUR  will\n          prompt for it.\n\n          COMMAND? SAVE MYTEXT ON CATLG\n          WYL.UR.ABC.MYTEXT ALREADY THERE.\n          REPLACE? YES (CR)\n          WYL.UR.ABC.MYTEXT REPLACED ON DCU207\n\n          The ON CATLG phrase is not sufficient  information  for\n          saving a file the first time.\n\n          COMMAND? SAVE MYTEXT ON CATLG (CR)\n          WYL.UR.ABC.MYTEXT NOT ON CATLG\n\n\n1SAVING, RETRIEVING, DELETING                                       IV.A - 5\n\n\n       b. Partitioned Data Sets\n\n          When saving a file as a member of a PDS or library,  it\n          is  permissable  to  specify ON CATLG.  This is allowed\n          because  your  library,   WYL.UR.ABC.LIB   is   already\n          cataloged  and  the  system  uses that catalog entry to\n          find the volumes.   The  use  of  parentheses  or  a  #\n          signals to WYLBUR that it is a PDS member name.\n\n          COMMAND? SAVE (MYTEXT) ON CATLG (CR)\n          MEMBER MYTEXT SAVED IN WYL.UR.ABC.LIB\n\n    6. RECATLG/UNCATLG\n\n       a. RECATLG\n\n          Once a data set has been cataloged, you  may  recatalog\n          it.   There is no point, however, unless the volume has\n          changed.\n\n          COMMAND? USE MYTEXT ON CATLG (CR)\n          VOLUME IS DCU207\n          COMMAND? SAVE MYTEXT ON DCU208 RECATLG (CR)\n          WYL.UR.ABC.MYTEXT SAVED AND RECATLG'D ON DCU208\n\n          WYLBUR  will  recatalog  whether  the  data   set   was\n          cataloged previously or not.\n\n          COMMAND? SAVE MYTEXT ON DCU207 RECATLG (CR)\n          WYL.UR.ABC.MYTEXT ALREADY THERE\n          REPLACE? YES (CR)\n          WYL.UR.ABC.MYTEXT  REPLACED AND RECATLG'D ON DCU207\n\n       b. UNCATLG\n\n          To uncatalog means to remove the catalog entry.\n\n          COMMAND? SAVE MYTEXT ON DCU207 REPLACE UNCATLG (CR)\n          WYL.UR.ABC.MYTEXT REPLACED AND UNCATLG'D ON DCU207\n\n          If you specify UNCATLG when saving a member of  a  PDS,\n          the entire PDS will be uncataloged.\n\n    7. CONDENSE - (PDS only)\n\n       If you attempt to SAVE a member of a PDS and there  is  not\n       sufficient  space available in it, WYLBUR will prompt for a\n       CONDENSE.  Reply YES or OK and WYLBUR will submit a job  to\n       condense  your  library,  charging it to the project number\n       which you  signed  on.   After  that  job  has  succesfully\n       completed,  try  the SAVE again.  A reply other than YES or\n       OK to the CONDENSE prompt prevents the  submission  of  the\n       job.\n\n1SAVING, RETRIEVING, DELETING                                       IV.B - 1\n\n\n B.  SCRATCH (Short Form: SCR)\n\n You may use this command to delete any data set or member  of  a\n PDS  which  belongs  to you.   The data set need not be a WYLBUR\n data set.  Once scratched, the file cannot  be  retrieved.   You\n must  always  specify  a  dsname.   In addition, if you have not\n previously done a SET VOLUME command to the  proper  volume  for\n that  data  set,  you  must  specify  a  VOLUME parameter on the\n SCRATCH command.  If you do not, WYLBUR will prompt for one.\n\n       COMMAND? SCRATCH MYTEXT (CR)\n       VOLUME?\n\n If you do not know on which volume the data set  resides,  do  a\n SHOW  DSNAMES ON  volume  for each WYLBUR volume and WYLBUR will\n list your data set names.\n\n       COMMAND? SHOW DSNAMES ON DCU207 (CR)\n       DCU207\n       WYL.UR.ABC.CHARGING\n       WYL.UR.ABC.SURTEXT\n       WYL.UR.ABC.FILE1\n       WYL.UR.ABC.MYTEXT\n       WYL.UR.ABC.NEWS1\n       COMMAND? SHOW DSNAMES ON DCU208 (CR)\n       DCU208\n       COMMAND?\n\n       In the second SHOW DSNAMES example,  there  were  no  data\n       sets for user ABC, group UR, on DCU208.\n\n       If you catalog all of your  data  sets  however,  you  can\n       avoid  searching  all of the volumes for them. WYLBUR will\n       then keep track of the volume for you.  Now if you want to\n       see all of your data sets only one command will have to be\n       given.\n\n       COMMAND? SHOW CATLG (CR)\n       WYL.UR.ABC\n       LIB - ON DCU207\n       MYTEXT - ON DCU207\n\n    1. Scratching a Sequential Data Set\n\n       To scratch the sequential  data  set  named  MYTEXT  which\n       resides on DCU207:\n\n       COMMAND? SCRATCH MYTEXT ON DCU207 (CR)\n       WYL.UR.ABC.MYTEXT  SCRATCHED ON DCU207\n       COMMAND?\n\n    2. Scratching a PDS Member\n\n       Suppose you also have a PDS member  named  MYTEXT  on  the\n       same  volume,  which  is  permitted by WYLBUR, and wish to\n       scratch it.\n\n1SAVING, RETRIEVING, DELETING                                       IV.B - 2\n\n\n       COMMAND? SCRATCH (MYTEXT) ON CATLG (CR)\n       or\n       COMMAND? SCRATCH (MYTEXT) ON DCU207(CR)\n       MEMBER MYTEXT SCRATCHED FROM WYL.UR.ABC.LIB\n\n       LIB is the dsname of your PDS and MYTEXT was a  member  of\n       it.\n\n    3. Scratching a Cataloged Data Set\n\n       You may delete both the file and the catalog entry:\n\n       COMMAND? SCRATCH MYTEXT ON CATLG (CR)\n       WYL.UR.ABC.MYTEXT SCRATCHED AND UNCATLG'D ON DCU207\n\n       You may delete the file and leave the catalog entry:\n\n       COMMAND? SCRATCH MYTEXT ON DCU207 (CR)\n       WYL.UR.ABC.MYTEXT SCRATCHED ON DCU207\n\n       Since  this  leaves  a  catalog  entry   pointing   to   a\n       non-existant  data  set you should generally uncatalog the\n       data set when you scratch it.\n\n    4. Scratching a non-WYLBUR Data Set\n\n       You may SCRATCH non-WYLBUR data sets provided they  belong\n       to  you.  Data  sets  are identified as yours by WYLBUR if\n       they are of any of the following forms:\n\n             $SYSMSG.uuu...\n             $USER.uuu...\n             $CB.uuu...\n\n       where uuu are the initials with which you signed on.\n\n       COMMAND? SCRATCH $SYSMSG.ABCUR001 ON CAT (CR)\n       SYSMSG.ABCUR001 SCRATCHED AND UNCATLG'D ON DCU208\n\n       You may SCRATCH an entire PDS with one operation  provided\n       that  WYLBUR  recognizes the data set as belonging to you.\n       The parameter which permits this operation is PDS.  WYLBUR\n       will allow you to SCRATCH your WYLBUR library.\n\n       COMMAND? SCRATCH $USER.ABCURLIB ON CAT PDS (CR)\n       SYSMSG.ABCURLIB SCRATCHED AND UNCATLG'D ON DCU208\n\n       If PDS is not  specified,  WYLBUR  will  use  the  current\n       MEMBER  parameter  if one has been set. This can be set by\n       either a a SET  MEMBER  command  or  a  USE  command.  The\n       current  can  be  shown  by the SHOW MEMBER command. If no\n       member has been set,  WYLBUR  will  ask  if  you  want  to\n       scratch  the entire PDS. A reply other than YES or OK will\n       abort the SCRATCH command.\n\n1SAVING, RETRIEVING, DELETING                                       IV.B - 3\n\n\n       COMMAND? SCRATCH $USER.ABCURLIB ON CAT (CR)\n       MEMBER NOT SPECIFIED\n       OK TO SCRATCH USER.ABCURLIB PDS? OK (CR)\n       USER.ABCURLIB SCRATCHED AND UNCATLG'D ON DCU118\n\n1SAVING, RETRIEVING, DELETING                                       IV.C - 1\n\n\n\n C.  USE (Short Form: U)\n\n You may retrieve a copy of an external file with the USE command.\n The file may belong to you, or to another user  whether  in  your\n group or not.  The examples in this section will be for your file\n only.   See Section IV.D.  for illustrations of retrieving copies\n of files belonging to your group or other users.\n\n Only a copy of the external file is made available as  an  active\n file.   If  you make disasterous changes to it, you may clear the\n active file and retrieve another copy of the original version.\n\n The USE command may be used to fetch a sequential or partitioned\n data set.  The dsname or member name must always  be  specified.\n You  indicate  the difference by using a # symbol before the PDS\n member name or by using parentheses to enclose it.\n\n    1. ON volume/CATLG\n\n       You must specify the  volume  on  which  the  WYLBUR  file\n       resides.\n\n       COMMAND? USE MYTEXT ON DCU207 (CR)\n\n       If you cataloged the file when you saved it, you may use ON\n       CATLG and  WYLBUR  will  locate  the  volume  on  which  it\n       resides.\n\n       COMMAND? USE MYTEXT ON CATLG (CR)\n\n       If you specify neither, WYLBUR will prompt for a volume:\n\n       COMMAND? USE MYTEXT (CR)\n       VOLUME?\n\n       If you do not remember which volume the file is on,  do  a\n       SHOW DSNAMES or SHOW CATLG.\n\n    2. Clearing the Active File\n\n       You cannot fetch a copy of an external data set unless you\n       have an empty active file.\n\n       CLEAR can be appended to a USE command to clear an  active\n       file before USE is executed.\n\n       COMMAND? USE MYTEXT ON DCU207 CLEAR (CR)\n\n\n\n       The CLEAR in the second command cleared the active file of\n       the file MYFILE.  CLEAR may also be  used  as  a  separate\n       command, as in CLEAR TEXT or ACTIVE.  See Section VII  for\n       details.\n\n1SAVING, RETRIEVING, DELETING                                       IV.D - 1\n\n\n\n D.  Data Set Naming Conventions\n\n There  are  certain  rules  for  establishing  data  set   names\n (dsnames)  and they must be observed when using WYLBUR commands.\n Two attributes affect a dsname:   the  kind  of  data  set,  and\n ownership of the data set.\n\n There are two kinds of data sets -  sequential  and  partitioned\n data  sets  (PDSs).   A PDS is often called a library; the terms\n are synonymous.  Each WYLBUR user  has  one  PDS  plus  as  many\n sequential  data  sets  as  he  wants and as will fit within his\n space allocation.\n\n    1. Your Data Sets\n\n       Using your own data sets is the simplest case.   When  you\n       sign  on  with  your  initials  and  group  ID,     WYLBUR\n       retains the information and uses it when  necessary.   You\n       may USE, SCRATCH or SAVE your data sets by specifying only\n       a  dsname  for  sequential data sets and a member name for\n       PDSs.  WYLBUR adds the necessary header.  However,  should\n       you  sign  on  with  someone  else's  initials and account\n       number, you must treat your own data sets as  though  they\n       belonged to another user.\n\n       a. Sequential Data Sets\n\n          To USE a  sequential  data  set  named  FILE1,  specify\n          either of these:\n\n          COMMAND? USE FILE1 (CR)\n          COMMAND? USE WYL.UR.ABC.FILE1 (CR)\n\n          Both commands are equivalent; for  the  first  command,\n          WYLBUR  adds  the  WYL.UR.ABC header for you.  The same\n          rule holds true for  the  SAVE  and  SCRATCH  commands.\n          Note  that   both of these  examples   assume  that you\n          have previously indicated a volume with the SET  VOLUME\n          command.\n\n       b. Partitioned Data Sets\n\n          Your  PDS  actually  consists  of  a  data  set   named\n          WYL.UR.ABC.LIB  and  each  member name has this header.\n          The commands:\n\n          COMMAND? SAVE WYL.UR.ABC.LIB(FILE1) ON DCU208 (CR)\n          COMMAND? SAVE #FILE1 ON DCU208 (CR)\n\n          are equivalent.  The name  (FILE1)  is  in  parentheses\n          because  it  is a member of the PDS called LIB.  #FILE1\n          is another way of referring to the same library member.\n1SAVING, RETRIEVING, DELETING                                       IV.D - 2\n\n\n\n    2. Your Group's Data Sets\n\n       Most groups have a central pool of disk space allocated  to\n       them  from which  any user in that group may  USE , SAVE or\n       SCRATCH.  This group space is a  convenient  place  to  put\n       files  needed  by  more than one member of the group.  This\n       space is referenced as if it belonged to a  user  with  the\n       initials  of  PUB.   PUB is  a dummy user ID and can not be\n       signed on to.  You may also USE data sets which  belong  to\n       other  users  and  to  other  groups.   That  procedure  is\n       discussed in the section below on other WYLBUR data sets.\n\n       a. Sequential Data Sets\n\n          To SCRATCH a data set named FILE2 which belongs to  your\n          group (PUB):\n\n            COMMAND? SCRATCH WYL.UR.PUB.FILE2 ON DCU207 (CR)\n         or COMMAND? SCRATCH &PUB.FILE2 ON DCU207 (CR)\n         or COMMAND? SCRATCH FILE2 ON DCU207 USER PUB (CR)\n            WYL.UR.PUB.FILE2 SCRATCHED ON DCU207\n\n          All three of these commands accomplish the same results.\n          The USER uuu form may be used in the  USE,  SCRATCH  and\n          SAVE  commands  to  designate a user's initials.  If you\n          are going to use a series of files from the  same  user,\n          use the SET USER command.\n\n          COMMAND? SET USER DEF (CR)\n\n       b. Partitioned Data Sets\n\n          A group PDS has LIB for a dsname, and PUB for initials.\n\n          COMMAND? SCRATCH WYL.UR.PUB.LIB(FILE2) ON DCU207 (CR)\n\n          would scratch the member (FILE2) from the PDS  belonging\n          to the group whose group ID is UR.\n\n          COMMAND? SCRATCH (FILE2) USER PUB ON DCU207 (CR)\n\n          would accomplish the same.\n\n    3. Other WYLBUR Data Sets\n\n       You may access WYLBUR data sets belonging  to  other  users\n       with  a  USE  command  only.   You  may  not  SCRATCH files\n       belonging to another  user  or  SAVE  into  another  user's\n       allocated  space.   If  you sign on with another user's ID,\n       you may access his files as you would  your  own.   In  the\n       cases  discussed  here, assume that you have signed on with\n       your own initials and  group  ID.   When  you  USE  someone\n       else's  data  set,  you  must  always  specify  the  user's\n       initials.  In addition, you must specify his group , unless\n       he is a member of your own group.\n\n1SAVING, RETRIEVING, DELETING                                       IV.D - 3\n\n\n       a. Sequential Data Sets\n\n          COMMAND? USE WYL.EC.JMM.FILE1 ON DCU207 (CR)\n\n          This  command  would  fetch  a  data  set  named  FILE1\n          belonging to user JMM of group EC.  In  this  case  you\n          must  specify  the  heading,  because  if you typed USE\n          FILE1, WYLBUR would default to your  own  initials  and\n          group.\n\n          There are two other forms of the command:\n\n          COMMAND? USE FILE1 ON DCU207 USER JMM GROUP EC (CR)\n          COMMAND? USE @EC.&JMM.FILE2 (CR)\n\n          Both commands fetch the same file as the first form.\n\n       b. Partitioned Data Sets\n\n          There are also two ways to specify  a  PDS  of  another\n          user.\n\n          COMMAND? USE WYL.EC.JMM.LIB(FILE1) (CR)\n          VOLUME IS DCU207\n          COMMAND?\n\n          COMMAND? USE (FILE1) USER JMM GROUP EC (CR)\n          VOLUME IS DCU207\n          COMMAND?\n\n          Since a PDS is always cataloged, you  do  not  have  to\n          specify  the volume, but WYLBUR does type it out if you\n          do not specify it.\n\n       c. SET USER and SET GROUP\n\n          If you are going to use a series of files from the same\n          group or user, you may use the SET USER  or  SET  GROUP\n          commands.  In the first USE example, MAR is a member of\n          your  group.   In  the  second USE example, TTT are the\n          initials of someone in group ED.\n\n          COMMAND? SET USER MAR (CR)\n          COMMAND? USE DATASET ON DCU111 (CR)\n          COMMAND? SET GROUP ED (CR)\n          COMMAND? USE DATA1 ON DCU106 USER TTT (CR)\n          COMMAND?\n\n          You can reset the user to yourself and reset the  group\n          to your own by:\n\n          COMMAND? CLEAR NAME (CR)\n\n          You can simplify the specification of a user  or  group\n          ID  by  using  an & to indicate another set of initials\n          and an @ to indicate another group.\n1SAVING, RETRIEVING, DELETING                                       IV.D - 4\n\n\n          COMMAND? USE @ED.&TTT.DATA1 ON  DCU106(CR)\n          COMMAND? USE &MAR.DATASET ON DCU111 (CR)\n          COMMAND? USE @ED.&TTT#MEMBER (CR)\n\n    4. Non-WYLBUR Data Sets\n\n       You may access data sets that are  not  WYLBUR  data  sets,\n       provided  you know their name and provided that they are on\n       volumes that are valid for the USE command.  The name of  a\n       non-WYLBUR  data set must be preceded by a $ or enclosed in\n       quotes.\n\n       In   order to use   a non-WYLBUR   data set  it  must  have\n       a BLKSIZE of less than or  equal  to  3520,  and  a  record\n       format of F,FB,V,VB or U.  If the LRECL is greater than 133\n       only the first 133 characters will be displayed.  This  may\n       be  circumvented  by  specifying  an LRECL of less than 133\n       which divides evenly into the actual LRECL of the data set.\n       This way each line will have  as  many  characters  as  you\n       specify  in  your  USE command.  For example if TEMP has an\n       LRECL of 800 a BLKSIZE of 3200 and a RECFM of FB all of the\n       information in the file may be USEd by:\n\n       COMMAND?  USE $TEMP ON DCU118 LRECL 80 (CR)\n\n       You will not be able to save the file back with an LRECL of\n       800 however so you can not make changes  to  the  file  and\n       return  it  to  the  disk  as it was originally.  Also when\n       using VB records a use without an LRECL specified will  get\n       you up to the first 133 characters of each record.  However\n       if  you  do specify an LRECL in the USE command WYLBUR will\n       treat  the  file  as  if  the  block  and   record   length\n       information stored in the data set were part  of  the  data\n       set.   See the CUCC User's Manual for information on LRECL,\n       BLKSIZE, etc.\n\n       COMMAND? USE $CB.NAMEIT.SYSPRINT ON DCU126 (CR)\n\n       To fetch a non-WYLBUR PDS,\n\n       COMMAND? USE $SYS1.PROCLIB(PL1) ON CATLG (CR)\n       VOLUME IS DCU147\n       COMMAND?\n                               or\n       COMMAND? USE 'SYS1.PROCLIB'(PL1) ON CATLG (CR)\n\n       If the data set is a PDS, the quotes  enclose  the  dsname\n       only, not the member name.\n\n    5. Locating a Data Set\n\n       The examples so far in this section  have  been  concerned\n       with  using  data sets when you know the volume name.  But\n       you may want to use a data set when you do not know  where\n       it resides.\n1SAVING, RETRIEVING, DELETING                                       IV.D - 5\n\n\n       In the examples which follow, assume that  you  signed  on\n       with  your own initials and group number, and again assume\n       that your user ID is ABC and your group ID is UR.\n\n       For all the illustrated cases, you may have to do  a  SHOW\n       VOLUMES to get a list of the volumes available.\n\n       COMMAND? SHOW VOLUMES (CR)\n\n       USE & SAVE -- DCU106 DCU111 DCU131 DCU132 DCU150 DCU207\n                DCU208 DCU209\n       TEMPORARY -- DCU115 DCU118\n       USE -- DCU110 DCU117 DCU126 DCU141 DCU142 DCU147\n\n       Any searching from a WYLBUR terminal will  be  limited  to\n       those volumes listed.\n\n       a. Locating Your Own Data Sets\n\n          If you want one of your own data sets, do a\n\n                     SHOW DSNAMES ON volume\n\n          You must specify the volume.  If you are looking for  a\n          WYLBUR  data  set, search only the WYLBUR volumes which\n          are those whose names are in the USE & SAVE list.   You\n          will  get  a  list  of the fully qualified names of all\n          your sequential data sets on a given volume.  The  data\n          set  named  WYL.UR.ABC.LIB is your PDS.  To have WYLBUR\n          list the members of your PDS:\n\n          COMMAND? SHOW DIRECTORY (CR)\n\n       b. Locating Your Group's Data Sets\n\n          You may get a list of all the  data  sets  belonging  to\n          persons in your group, but you must specify a volume.\n\n          COMMAND? SHOW DSNAMES LIKE WYL.UR. ON DCU208 (CR)\n          DCU208\n          WYL.UR.ABC.FILE1\n          WYL.UR.DEF.LIB\n          WYL.UR.MUM.AFILE\n             .\n             .\n             .\n          COMMAND?\n\n1SAVING, RETRIEVING, DELETING                                       IV.D - 6\n\n\n          Another way of doing this is to specify user  ALL.   ALL\n          may also be used to get a listing   of the  data    sets\n          belonging to all groups:\n\n          COMMAND? SHOW DSN USER ALL GROUP ALL ON DCU208\n          DCU208\n          WYL.UR.ABC.FILE10\n          WYL.OR.GGG.ATLAST\n          WYL.GB.GBS.REGRESS\n          WYL.UR.MEL.RESULTS\n          .\n          .\n          .\n          COMMAND?\n\n          This command would list every WYLBUR data set on DCU208.\n\n          Any data set named LIB  is  a  PDS.   To  look  at  the\n          members  of  a  PDS belonging to someone in your group,\n          for example, to DEF:\n\n          COMMAND? SHOW DIR IN WYL.UR.DEF.LIB ON DCU208 (CR)\n          or\n          COMMAND? SHOW DIR USE DEF ON DCU208 (CR)\n          WYL.UR.DEF.LIB\n          BEEP\n          BIG\n          LITTLE\n              .\n              .\n              .\n          COMMAND?\n\n\n       c. Locating Data Sets of Other WYLBUR Users\n\n          To find a data set belonging to any WYLBUR user who  is\n          not a member of your group, you must know that person's\n          initials and group ID.\n\n          COMMAND? SHOW DSNAMES LIKE WYL.EG.AAB ON DCU208 (CR)\n          DCU208\n          WYL.EG.AAB.LIB\n          WYL.EG.AAB.TESTDATA\n          WYL.EG.AAB.FORTRAN\n          COMMAND?\n\n          Again, you must  specify  a  WYLBUR  volume.   In  this\n          example,  AAB  are  the  user's  initials and EG is his\n          group ID.\n\n          To look at the PDS members belonging to the same user:\n\n          COMMAND? SHOW DIR IN WYL.EG.AAB.LIB ON DCU208 (CR)\n\n1SAVING, RETRIEVING, DELETING                                       IV.D - 7\n\n\n       d. Locating Non-WYLBUR Data Sets\n\n          All names of non-WYLBUR data sets must be preceded by a\n          $ or enclosed in single quotes.  If the  data  set  you\n          want  is  cataloged you may USE it without specifying a\n          volume name.  For example, to use  (PL1),  which  is  a\n          member of the PDS named SYS1.PROCLIB, type\n\n          COMMAND? USE $SYS1.PROCLIB(PL1) ON CAT (CR)\n          or\n          COMMAND? USE 'SYS1.PROCLIB'(PL1) ON CATLG (CR)\n\n          In this case the data set was cataloged but  if  it  is\n          not,  you  must specify the volume.  If you do not know\n          the volume you must type\n\n          COMMAND? SHOW DSNAMES LIKE $SYS1.PROCLIB ON volume (CR)\n\n          for each volume valid with the USE  command  until  you\n          locate  the  file or determine that it is not on any of\n          the volumes.  Fortunately there is a shorter form.\n\n          COMMAND? SET PREFIX $SYS1.PROCLIB (CR)\n          COMMAND? SHOW DSNAMES LIKE * ON volume (CR)\n\n          Once you have set the name, you need type only  LIKE  *\n          instead  of  specifying  the  fully qualified dsname in\n          each command.  The prefix may be set by using  the  SET\n          option on the USE command.\n\n          To continue the example, assume you have  located  this\n          data  set  and it is on the volume named DCU147.  Since\n          the data set is a PDS, you may want to know  the  names\n          of  all  its members:\n\n          COMMAND? SHOW DIR IN $SYS1.PROCLIB ON DCU147 (CR)\n\n          or if the prefix has been set in a previous command:\n\n          COMMAND? SHOW DIR IN * ON DCU147 (CR)\n\n    6. Managing Your Data Sets\n\n       A few guidelines are presented below  which  may  make  it\n       easier for you to manage your space. Space is allocated in\n       1 track increments and you may not exceed your allocation.\n       Therefore,   careful   management   of  your  library  and\n       sequential space will allow you to save more information.\n\n1SAVING, RETRIEVING, DELETING                                       IV.D - 8\n\n\n       a. PDS vs. Sequential Space\n\n          Each user may save data sets as sequential data sets or\n          library members.   To  be  efficient,  they  should  be\n          managed  differently.   A PDS is designed to hold small\n          data sets.  A small data set in this case is less  than\n          100  card images.  To illustrate the difference between\n          a PDS and sequential data space suppose you had 7 or  8\n          very  small  data  sets,  such  as 10 card images each.\n          They would probably all fit  on  one  track  in  a  PDS\n          whereas  it  would  take  7 or 8 tracks to save them as\n          sequential data sets.   This  is  because  the  minimum\n          allocated  to  each  sequential  data set is one track.\n          Since one track can  actually  hold  100  to  200  card\n          images  (depending  on the number of imbedded blanks in\n          your data), it works best to use sequential space  only\n          for data sets over 100 or 200 cards.  A maximum of 4000\n          to  5000  card images is workable for a sequential data\n          set.  Although WYLBUR can handle larger  files,  it  is\n          time  consuming.   The  SHOW SPACE command is useful to\n          show how many tracks of sequential data space  you have\n          used.\n\n       b. CONDENSE (for PDS only)\n\n          When you save a PDS member, it is saved at the  end  of\n          your  library  space.   As you do a series of SAVEs and\n          SCRATCHes, empty space develops wherever a  PDS  member\n          was  scratched.   Eventually  you reach the end of your\n          space and cannot save another PDS  member  even  though\n          there  may  be  enough scattered space to hold the data\n          set.  When this happens, WYLBUR prompts you with an  OK\n          TO  CONDENSE?  message.  If you reply YES or OK, WYLBUR\n          submits a job to the CUCC ASP system to  condense  your\n          PDS  -  that  is  to  shuffle  the  members and leave a\n          contiguous empty space at the end.  Meanwhile  you  may\n          not  save  a PDS member but you may do other tasks like\n          edit a file.  In the interim, the active  file  may  be\n          saved  as a sequential file. You may avoid the CONDENSE\n          prompt by choosing a more convenient time  to  condense\n          your PDS.  Use the CONDENSE command,\n\n          COMMAND? CONDENSE LIB ON DCU207 ACCOUNT UR99999 (CR)\n\n          JOB 8101, ABCUR001 SUBMITTED\n\n          It is not nessasary to specify an  account  number  when\n          using  the condense command.  If you do not the condense\n          job will be charged  to  the  account  number  that  you\n          signed on with.\n\n          You should remember that CONDENSE'ing  costs  money  and\n          uses  up  computer  time,  so  it  should  not  be  done\n          excessively.\n\n1SAVING, RETRIEVING, DELETING                                       IV.D - 9\n\n\n          The time to condense is when you are getting  close  to\n          the  limit  of  your library space allocation.  To find\n          out how close you are:\n\n          COMMAND? SHOW DSNAMES SPACE LIKE LIB ON DCU207 (CR)\n          DCU207\n          WYL.UR.ABC.LIB -- 18 of 20 TRKS\n\n\n          Suppose you did a CONDENSE command at this point:\n\n          COMMAND? CONDENSE LIB ON DCU207  (CR)\n          JOB 8101, ABCUR001 SUBMITTED\n\n          When job ABCUR001 is finished executing, look  at  your\n          space again:\n\n          COMMAND? SHOW DSNAMES SPACE LIKE LIB ON DCU207\n          DCU207\n          WYL.UR.ABC.LIB -- 8 OF 20 TRKS\n\n\n       c. Scratching Obsolete Data Sets\n\n          ACTIVE and REPLACE\n\n          It is up to the discretion of each user to decide  when\n          a  data  set  is obsolete.  But it pays to look at your\n          dsnames once in a while.\n\n          COMMAND? SHOW DSNAMES ON DCU207 (CR)\n          DCU207\n          WYL.UR.ABC.LIB\n          WYL.UR.ABC.ACTIVE\n          WYL.UR.ABC.REPLACE\n          WYL.UR.ABC.FILE1\n\n          Occasionally you may find dsnames  like  those  listed.\n          LIB  is your PDS library.  Assume FILE1 is a valid name\n          for a data set, but that ACTIVE and  REPLACE  were  not\n          names  knowingly  assigned  by  you.   ACTIVE is a name\n          assigned to a data set by WYLBUR when the system fails.\n          If there is an active file at that time,  WYLBUR  saves\n          and  catalogs  it  with  the  dsname of ACTIVE.  On the\n          session following a system crash, as you signon, WYLBUR\n          will  tell  you  whether  your  ACTIVE  was  saved  and\n          catalogued at the last session.  If so, do a USE ACTIVE\n          ON CATLG and take a look at it. Be sure to  scratch  it\n          after  you  have saved it under its proper name so that\n          you release the space used by the file.\n\n          A data set named REPLACE usually got there because  you\n          left out the dsname on a SAVE REPLACE command.\n\n1SAVING, RETRIEVING, DELETING                                       IV.D - 10\n\n\n          COMMAND? SAVE FILE1 ON DCU208 REPLACE (CR)\n          COMMAND? SAVE REPLACE ON DCU208 (CR)\n\n          In the first  command  the  active  file  replaces  the\n          contents  of  FILE1;  in  the second command the active\n          file is saved with a dsname of REPLACE.\n\n          You may SHOW the creation date of any  data  set  on  a\n          pack  enabled  for  WYLBUR  USE's  and  the date that a\n          WYLBUR sequential file (WYL.UR.ABC.FILENAME)  was  last\n          accessed from WYLBUR.\n\n          COMMAND? SET VOL DCU207 (CR)\n          COMMAND? SHO DSNAMES DATED (CR)\n          DCU207\n          WYL.UR.ABC.ACTIVE\n               CR:  06/18/73   LA:  06/18/73\n          WYL.UR.ABC.OUTPUT\n               CR:  06/10/73   LA:  06/10/73\n          WYL.UR.ABC.WARBLE\n               CR:  05/04/73   LA:  06/05/73\n\n          also you may find out how much space each data set is\n          using and what type it is:\n\n          COMMAND? SHOW DSNAME SPACE TYPE ON DCU207 (CR)\n          DCU207\n          WYL.UR.ABC.ACTIVE -- 2 TRKS\n              PS, U3520/3520\n          WYL.UR.ABC.OUTPUT -- 7 TRKS\n              PS, FB/80/3440\n          WYL.UR.ABC.WARBLE -- 1 TRKS\n               PS, U/3520/3520\n          WYL.UR.ABC.LIB -- 8 OF 10 TRKS\n               PO, U/3520/3520\n\n          The second line of information in each case is  the  DCB\n          of  the  data  set.   First  is the DSORG then comes the\n          RECFM/LRECL/BLKSIZE. See the CUCC User's Manual for    a\n          description of DCB, DSORG, etc.\n1\n\n\n1 V. EXEC FILES                                                      V. - 1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n                                 SECTION V\n\n                  ***************************************\n                  * This Section  of  the  CUCC  WYLBUR *\n                  * Manual  will be released at a later *\n                  * date.                               *\n                  *                                     *\n                  * You must retain the  SECTION V card *\n                  * issued to you  when  you  purchased *\n                  * this  manual  in  order  to receive *\n                  * Section V when released.   It  must *\n                  * be    stamped      \"APPROVED\"  when *\n                  * purchased.                          *\n                  *                                     *\n                  * If this card  is  not  retained  an *\n                  * additional charge will be made.     *\n                  ***************************************\n\n1EXEC FILES                                                       V.A - 1\n\n\n V. Introduction to Exec Files\n\n Thus far, two kinds of WYLBUR files have been described:\n\n    1) \"external files\" are data sets stored on disk as members of\n       a partitioned data set (or \"library\") or as sequential data\n       sets;\n\n    2) the active file is a facility available to  a  WYLBUR  user\n       for text-editing, modification and/or submission as a batch\n       job (see Section VI).\n\n In addition to the active file, WYLBUR has a facility called  the\n exec  (execute) file.  The exec file differs from the active file\n in several ways.  Its function is to perform a series of commands\n sequentially (in a user-specified order).  Users  often  find  it\n necessary   to   perform  the  same  series  of  WYLBUR  commands\n repeatedly.  If such a series of commands is  collected  into  an\n active file  and  SAVed, it is thereafter necessary to type in an\n EXEC command (see Section V.B) any time you wish to  execute  all\n those commands.  Any WYLBUR file may become (\"be moved into\") the\n exec  file, as long as it does not exceed 3 WYLBUR pages (see the\n SHOW PAGES command in Section VII).  If  an  illegal  command  is\n given  within  an  exec  file,  the execution of the file will be\n interrupted.\n\n\n A.  Creating an Exec File\n\n To create an exec file, enter collect mode and enter one  command\n per  line.  The commands will eventually be executed in the order\n in which they are encountered, so the order  in  which  they  are\n collected may be significant.  Any valid WYLBUR command may occur\n in an exec file, and each line will be treated as a command.\n\n For example, if you usually enter the  same  series  of  commands\n each  time you sign on to WYLBUR (\"SET TERSE\", \"SET VOLUME,\" \"SET\n TABS,\" \"SET LENGTH,\" \"SHOW SPACE\"), it may be more convenient  to\n create  a  file  consisting of these commands and SAVE it in your\n library:\n\n         COMMAND? COLLECT (CR)\n              1.  ? SET TERSE (CR)\n              2.  ? SET VOLUME DCU308 (CR)\n              3.  ? SET TABS 10 20 30 50 NOVERIFY (CR)\n              4.  ? SET LENGTH 132 (CR)\n              5.  ? SHOW SPACE; CAN I ACCOUNT FOR SPACE USED? (CR)\n              6.  ? *** (ATTN)\n        COMMAND? SAVE #SIGNON\n        MEMBER SIGNON SAVED IN WYL.UR.ABC.LIB\n        COMMAND?\n\n1EXEC FILES                                                       V.A - 2\n\n\n Thus SAVEd, it may be accessed as needed, whenever  you  want  to\n execute those commands.\n\n Note that  in  line  5  of  the  previous  example,  there  is  a\n semi-colon followed by the words \"CAN I ACCOUNT FOR SPACE USED?\".\n As  discussed  in  Section  I.C, a semi-colon stops the scan of a\n command line; anything following it is a comment.\n\n With this basic example, you will be able  to  begin  using  exec\n files  as  well  as  attempt to understand the more sophisticated\n examples of exec files introduced later.\n1EXEC FILES                                                       V.B - 1\n\n\n B.  EXEC Command  (Short forms: EXE or X)\n\n\n The EXEC command is used to move an external or active file  into\n the exec file and execute the commands.\n\n\n    1. Executing the Active File\n\n       The ACTIVE option will place the active file into the  exec\n       file  and  execute  it.   When  you give this command,  the\n       active file is cleared.\n\n       Using the example described on the preceding page, you  may\n       proceed as follows just after SAVing #SIGNON:\n\n       COMMAND? EXEC ACTIVE (CR)\n       ->   1.  SET TERSE\n       ->   2.  SET VOLUME DCU308\n       ->   3.  SET TABS 10 20 30 50 NOVERIFY\n       ->   4.  SET LENGTH 132\n       ->   5.  SHOW SPACE ; CAN I ACCOUNT FOR SPACE USED?\n       ABC - 5 TRKS USED, 7 TRKS ALLOWED\n       EXEC END\n       ?\n\n       As each command in the file is executed, WYLBUR  lists  it,\n       preceded by an arrow indicating that it is the current line\n       in the exec file.\n\n\n    2. Executing an External File\n\n       You may execute a file that has been  SAVEd  by  specifying\n       the  FROM  option,  followed  by the name of the file to be\n       executed.  The external file must be in valid  WYLBUR  edit\n+                                   ____\n       format.  All of the options used in referencing an external\n       file   (USER  uuu,  GROUP  gg,  ON  volume,  etc.)  may  be\n       specified.  WYLBUR places  a  copy  of  the  external  file\n       directly  into  the  exec  file without altering the active\n       file.\n\n       For example, if  you have  created and saved #SIGNON,  that\n       file may be executed by typing,\n\n       COMMAND? EXEC FROM #SIGNON ON DCU308 (CR)\n       ->   1.  SET TERSE\n       ->   2.  SET VOLUME DCU308\n       ->   3.  SET TABS 10 20 30 50 NOVERIFY\n       ->   4.  SET LENGTH 132\n       ->   5.  SHOW SPACE ; CAN I ACCOUNT FOR SPACE USED?\n       ABC - 6 TRKS USED, 7 TRKS ALLOWED\n       EXEC END\n       ?\n\n\n1EXEC FILES                                                       V.B - 2\n\n\n    3. Specifying a Starting Line Number\n\n       You may specify that WYLBUR begin  execution  of  the  exec\n       file  at some line other than the first line in the file by\n       using the START option and giving the line  number  of  the\n       first line to be executed.\n\n       COMMAND? EXEC FROM #SIGNON ON DCU308 START 2 (CR)\n       ->   2.  SET VOLUME DCU308\n       ->   3.  SET TABS 10 20 30 50 NOVERIFY\n       ->   4.  SET LENGTH 132\n       ->   5.  SHOW SPACE ; CAN I ACCOUNT FOR SPACE USED?\n       ABC - 6 TRKS USED, 7 TRKS ALLOWED\n       EXEC END\n       COMMAND?\n\n\n    4. PAUSE Option  (Short form: PAU)\n\n       The PAUSE option may be used to suspend  execution  of  the\n       exec  file and return you to COMMAND mode.  This option can\n       be used in two different ways:  with  the  FROM  or  ACTIVE\n       option and within an exec file.\n\n       a. Using PAUSE with FROM or ACTIVE\n\n          When used with either the FROM or ACTIVE  option,  PAUSE\n          prevents the file from executing immediately after it is\n          placed  in  the  exec file.  Instead you are returned to\n          command mode and must use the exec command  to  commence\n          execution of the exec file.\n\n1EXEC FILES                                                       V.B - 3\n\n\n          COMMAND? COL (CR)\n             1.   ?  CH '&&' TO 'MR. JOHN DOE' NOLIST (CR)\n             2.   ?  CH '@@' TO '1234 MAIN STREET' NOLIST (CR)\n             3.   ?  CH '##' TO 'ANYTOWN, USA  12345' NOLIST (CR)\n             4.   ?  LIST CLEAN NONUMBER MARKER=$ (CR)\n             5.   ?  (ATTN)***\n          COMMAND? EXEC ACTIVE PAUSE (CR)\n          COMMAND? USE #FORMLTTR ON DCU308 (CR)\n          COMMAND? LIST (CR)\n                  1.     &&\n                  2.     @@\n                  3.     ##\n                  4.\n                  5.\n                  6.     DEAR &&, (ATTN) ***\n          COMMAND? EXEC (CR)\n          ->   1.  CH '&&' TO 'MR. JOHN DOE' NOLIST\n                     .\n                     .\n                     .\n          ->   4.  LIST CLEAN NONUMBER MARKER=$\n\n               MR. JOHN DOE\n               1234 MAIN STREET\n               ANYTOWN, USA 12345\n\n               DEAR MR. JOHN DOE,\n\n               ENCLOSED ARE THE ITEMS YOU REQUESTED.\n               WE HOPE YOU WILL FIND THEM SATISFACTORY.\n\n                                 SINCERELY,\n\n                                 SAM SMITH\n               (CR)\n          EXEC END\n          COMMAND?\n\n\n       b. Using PAUSE within an Exec File\n\n          By using the PAUSE option within an  exec  file,  it  is\n          possible  to  create an exec file which serves more than\n          one purpose.  For example, suppose that you may want  to\n          SET  UPLOW  for some sessions, but not for others.  With\n          the addition of the EXEC PAUSE statement to  the  SIGNON\n          file,  the first four commands of the file will execute,\n          after which the PAUSE command will return you to COMMAND\n          mode.  To execute the remainder of the file,  type  EXEC\n          and   execution  will  recommence  with  the  SET  UPLOW\n          statement.   Otherwise,  continue   with   any   command\n          normally permitted in command mode.\n\n1EXEC FILES                                                       V.B - 4\n\n\n          COMMAND? USE #SIGNON ON DCU308 (CR)\n          COMMAND? COL (CR)\n             6.   ?  EXEC PAUSE (CR)\n             7.   ?  SET UPLOW (CR)\n             8.   ?  *** (ATTN)\n          COMMAND? EXEC ACTIVE  (CR)\n          ->   1.    SET TERSE\n          ->   2.    SET VOLUME DCU308\n          ->   3.    SET TABS 10 20 30 50 NOVERIFY\n          ->   4.    SET LENGTH 132\n          ->   5.    SHOW SPACE ; CAN I ACCOUNT FOR SPACE USED?\n          ABC - 6 TRKS USED, 7 TRKS ALLOWED\n          ->   6.    EXEC PAUSE\n          ? EXEC (CR)\n          ->   7.    SET UPLOW\n          EXEC END\n          ?\n\n       c. Using the Exec File as Temporary Storage\n\n          It is sometimes useful to store the active file  in  the\n          exec  file  temporarily  while doing something else with\n          the active file.  The PAUSE option allows  any  type  of\n          file  (less  than  three WYLBUR pages) to be in the exec\n          file without being executed.\n\n          COMMAND? USE #PL1JOB ON DCU307 (CR)\n          COMMAND? EXEC ACTIVE PAUSE (CR)\n          COMMAND? USE #PL1DATA ON DCU307 (CR)\n          COMMAND? MODIFY 5 (CR)\n          5.         THIS IS SOME INCORRECT DATA\n          ALTERS?                 DD\n          5.         THIS IS SOME CORRECT DATA\n          ALTERS? (CR)\n          COMMAND? SAVE #PL1DATA ON DCU307 REPLACE\n          MEMBER PL1DATA REPLACED ON DCU307\n          COMMAND? RESTORE CLEAR\n          COMMAND?\n\n          The RESTORE command replaces the existing exec  file  in\n          the active file (See Section V.D).\n\n    5. CLEAR Option  (Short form: CLR,CLE)\n\n       If you already have an exec file, it must be cleared before\n       you can execute another file.  One way to  accomplish  this\n       is by using the CLEAR option in the EXEC command.\n\n       COMMAND?  EXEC FROM (SIGNON) CLEAR (CR)\n\n       The exec file may  also  be  cleared  by  using  the  CLEAR\n       command.\n\n       COMMAND? CLEAR EXEC (CR)\n1EXEC FILES                                                       V.B - 5\n\n\n\n    6. EXEC VERBOSE/TERSE and EXEC LOG/NOLOG\n\n\n       These global parameters may be used to govern the amount of\n       response that WYLBUR prints at the terminal.   All  of  the\n       above examples  have  used VERBOSE and LOG, the defaults at\n       signon.\n\n       These parameters may be specified  in  either  a  SET  EXEC\n       command  or  in  the  EXEC  command.  In either command the\n       parameter(s) specified will be set for the duration of  the\n       session or until reset.\n\n       If  TERSE  is  specified,  WYLBUR  shortens  some  of   the\n       responses  and causes WYLBUR not to print line numbers.  If\n       NOLOG is specified, command  lines  do  not  list  as  they\n       execute.\n\n       COMMAND? EXEC FROM #SIGNON ON DCU308 TERSE LOG (CR)\n       ->   SET TERSE\n       ->   SET VOLUME DCU308\n       ->   SET TABS 10 20 30 50 NOVERIFY\n       ->   SET LENGTH 132\n       ->   SHOW SPACE ; CAN I ACCOUNT FOR SPACE USED?\n       ABC - 6 TRKS USED, 7 TRKS ALLOWED\n       EXEC END\n       ? EXEC FIRST NOLOG VERBOSE (CR)\n       ABC - 6 TRKS USED, 7 TRKS ALLOWED\n       EXEC END\n       ?\n\n\n       These parameters may also be set using the SET command.\n\n       Note  that  EXEC  TERSE/VERBOSE  has  no  effect   on   the\n       TERSE/VERBOSE for COMMAND mode described in Section II.\n1EXEC FILES                                                       V.C - 1\n\n\n C. LOAD Command  (Short form: LOA)\n\n\n The LOAD command is similar to the  EXEC  command,  but  has  two\n major  differences:   you  may specify that a range of lines from\n the active file is to be loaded  into  the  exec  file,  and  the\n active file will not be altered by the LOAD command.\n\n You also may specify that a range of lines from an external  file\n be  LOADed  and executed.  If you specify a range, it must be the\n first option after the LOAD command.\n\n       COMMAND? LOAD 8/20 FROM #XFILE1 ON DCU308 (CR)\n\n After you type this command, lines 8/20 of #XFILE1 will be placed\n in the EXEC file and then executed.\n\n When  loading  the  entire  active  file  the  LOAD  command   is\n comparable  to  the  EXEC  ACTIVE command, except that the active\n file is not cleared.\n\n Note that the LOAD command may  not  be  used  to  execute  lines\n currently  in  the  exec file,i.e., it may not be used to replace\n the EXEC line number command.\n\n1EXEC FILES                                                       V.D - 1\n\n\n D. RESTORE Command  (Short form: RES)\n\n You may not make modifications directly to  the  exec  file.   To\n make  modifications,  you  must  first  move the exec file to the\n active file.  To do this, use the  RESTORE  command,  which  will\n place  the  exec  file into the active file if the active file is\n clear.  This will also clear the exec file.  If  an  active  file\n already  exists,  you may specify the CLEAR option of the RESTORE\n command to clear the active file before RESTORing the exec  file.\n If  you  do  not  specify  CLEAR, WYLBUR will prompt to clear the\n active file.\n\n COMMAND? RESTORE (CR)\n OK TO CLEAR? OK (CR)\n COMMAND?\n1EXEC FILES                                                       V.E - 1\n\n\n E. SET and SHOW EXEC\n\n The SET EXEC command is used to set those global parameters which\n affect the exec file.  Note however that this has  no  effect  on\n the general global parameters.\n\n    1. Specifying a Line Number\n\n       The SHOW EXEC command may be used to list a single line  of\n       the  exec  file.  You may specify a line number, a symbolic\n       line number, or RETRY.  SHOW EXEC RETRY will list the  line\n       that would be executed on an EXEC RETRY command(see below).\n\n    2. Specifying Global Exec Parameters\n\n       To set a global exec parameter(s), it is  necessary  merely\n       to  type  SET  EXEC  (parameters).  You may ascertain which\n       EXEC modes (VERBOSE or TERSE,LOG or NOLOG) are in effect by\n       specifying one or more of these global exec  parameters  in\n       the SHOW EXEC command.\n\n       COMMAND? SET EXEC TERSE NOLOG (CR)\n       COMMAND? SHO EXEC TERSE (CR)\n       EXEC TERSE IS IN EFFECT.\n       COMMAND? SHO EXEC LOG VERBOSE (CR)\n       EXEC NOLOG TERSE IS IN EFFECT.\n       COMMAND?\n\n\n1EXEC FILES                                                       V.F - 1\n\n\n F. Other Commands and Features Useful with Exec Files\n\n Any WYLBUR command may be used in an exec file.  The commands are\n executed as if you had entered them one by one  in  command  mode\n (except, perhaps, for some uses of the EXEC or LOAD command).\n\n There are some commands that, though they may be used in  COMMAND\n mode,  are  especially  useful  when  used in an exec file.  Many\n commands that have been discussed in  previous  sections  may  be\n used  with  an EXEC option which changes the file referenced from\n the active file to the exec file.\n\n    1. LIST Command\n\n       You may use the EXEC option of the LIST command to list all\n       or part of the exec file.  The EXEC option may be used with\n       any other valid options in the LIST command.\n\n       COMMAND? L 'TABS' EXEC NONUM (CR)\n                SET TABS 10 20 30 50 NOVERIFY\n       COMMAND?\n\n    2. Branching\n\n       A very important  feature  of  the  exec  facility  is  the\n       ability to branch within the file while executing.\n\n       a. Specifying a Line Number\n\n          If you specify a line number in the EXEC  command,  your\n          current  exec  file will be executed beginning with that\n          line number, or the next line  after  it  if  that  line\n          number does not exist in the exec file.\n\n          COMMAND? EXEC 3 (CR)\n\n       b. Symbolic Line Numbers\n\n          As noted in Section II, there are two distinct  sets  of\n          symbolic  line  numbers:   one  set refers to the active\n          file, the other refers to the exec file.   As  the  exec\n          file  is  executed, the exec current line pointer points\n          to the command currently  executing.\n\n       c. Exec Break\n\n          If you hit the (ATTN) key while executing an exec  file,\n          an  exec  break will occur:  WYLBUR interrupts execution\n          on  the  current  command,  types  out  EXEC  BREAK, and\n          returns you to  command  mode.   (This  also  occurs  if\n          WYLBUR  encounters  an illegal command or a command that\n          cannot be  executed.)  The  exec  current  line  pointer\n          points to the line that was interrupted or was in error.\n1EXEC FILES                                                       V.F - 2\n\n\n          When an exec break occurs,  you  may  want  to  continue\n          executing  the file.  To execute the interrupted command\n          use either of the following (in this command,  they  are\n          synonomous):\n\n          COMMAND? EXEC * (CR)\n          or\n          COMMAND? EXEC RETRY (CR)\n\n          To execute the next command use one of the following:\n\n          COMMAND? EXEC NEXT (CR)\n          or\n          COMMAND? EXEC (CR)\n\n    3. Looping\n\n       The following file is a simple example of the  use  of  the\n       line  number  option in an exec file.  More useful examples\n       will be given at the end of this section.\n\n             1.   ;THIS IS A \"SPIDER WEB\" INFINITE LOOP.\n             2.   ;HIT THE ATTN KEY TO TERMINATE IT.\n             3.   EXEC *+2\n             4.   EXEC LAST\n             5.   EXEC 4\n             6.   EXEC FIRST\n\n    4. POINT Command  (Short form: P)\n\n       WYLBUR keeps track of the commands being  executed  in  the\n       exec  file  by  use  of a line pointer.  As each command is\n       executed, the line  pointer  is  incremented  to  the  line\n       number of the next command.\n\n       The POINT command is identical to the LIST  command  except\n       that  the  current  line pointer is changed to point to the\n       line last listed (or referenced, if NOLIST  is  specified).\n       The   NOLIST  option,  though  it  completely  negates  the\n       usefulness of the LIST command, may be used  in  the  POINT\n       command to set the current line pointer without listing the\n       range.   The SET CURRENT command may not always be adequate\n       to set the current line  pointer;  for  instance,  you  may\n       POINT to an associative range.\n\n       When the EXEC option is used with the  POINT  command,  the\n       exec  current  line pointer is changed and the range in the\n       exec file is listed.\n\n       During execution of an exec  file,  WYLBUR  sets  the  exec\n       current  line pointer to the line currently being executed.\n       The next line to be executed is always the line  referenced\n       by  the  exec  symbolic line pointer NEXT, unless otherwise\n       specified.  Because of this, POINT (range) EXEC may be used\n       to branch within an exec file.\n\n1EXEC FILES                                                       V.F - 3\n\n\n       In the following file, the POINT command is  used  to  show\n       how labels may be used in an exec file.\n\n          1.  LIST 1\n          2.  POINT 1 ';SKIP' EXEC NOL\n          3.  LIST 2\n          4.  ;SKIP\n          5.  LIST 3\n\n       After statement one executes, statement two sets  the  EXEC\n       line  pointer  to  the  last line in the file which has the\n       character string \";SKIP\" starting in the first column.  (If\n       you had not specified \"1\"  in  the  POINT  command, WYLBURr\n       would  search  the  exec  file for the last line containing\n       \";SKIP\" in any postion within it.) In this case  line  four\n       is  the  only line which has the string \";SKIP\" starting in\n       its first column and the exec line pointer is set to  four.\n       As  stated previously, the next line which is to execute is\n       the line immediately following the line referenced  by  the\n       exec  line pointer, line five.  Thus the order of execution\n       of the statements in the file is one, two and finally five;\n       output from their execution consists of a listing of  lines\n       one and three of the active file  as  lines 1 and 5  of the\n       exec file are executed.\n\n    5. READ Command     (short form: REA)\n\n       The READ command may be used to read and execute one WYLBUR\n       command.  When the READ command is  executed,  WYLBUR  will\n       prompt  for a command to be entered, followed by a carriage\n       return (CR).  WYLBUR will execute that command  and  return\n       you  to COMMAND mode if WYLBUR was in COMMAND mode when the\n       READ command was executed; however, if WYLBUR  was  in  the\n       process of executing an exec file, it will proceed with the\n       execution of the file.\n\n       The following example shows the use of READ in COMMAND mode\n       and in an exec file.\n\n       COMMAND? READ (CR)\n       ENTER? EXE FROM #SIGNON ON DCU306 (CR)\n       ->   1.   SET TERSE\n       ->   2.   SET VOLUME DCU306\n       ->   3.   READ ; THIS MAY BE USED TO SKIP LINE 4\n       ENTER? EXE 5 (CR)\n       ->   5.   SHOW SPACE\n       ABC - 6 TRKS USED, 7 TRKS ALLOWED\n       EXEC END\n       ?\n\n1EXEC FILES                                                       V.F - 4\n\n\n       In this example the READ  command  is  used  for  the  same\n       purpose  as  the  EXEC  PAUSE  was  used  for in a previous\n       example:  to allow you to decide within the file whether or\n       not to set the LENGTH parameter.  Had the response  to  the\n       ENTER?  prompt been either a (CR) or EXEC, execution of the\n       file  would  have  continued  at  the next line of the exec\n       file.  If the response to the ENTER?  prompt had been  EXEC\n       6  (or any non-existent line in the exec file) WYLBUR would\n       respond EXEC END and terminate execution of the exec file.\n1EXEC FILES                                                       V.F - 5\n\n\n       a. PROMPT  Option    (short form: PRO)\n\n          Unless you specify otherwise, WYLBUR will respond to the\n          READ command with the prompt, \"ENTER?\" You may  override\n          this prompt and specify one of your own choice using the\n          PROMPT option followed by the prompt in quotes.\n\n          COMMAND? READ PROMPT 'WHAT NEXT? '\n          WHAT NEXT? EXE FRO #GETREADY TER NOLOG (CR)\n          VOLUME IS DCU306\n          ENTER X 5 TO SKIP SETTING LENGTH: X 5 (CR)\n          ABC - 6 TRKS USED, 7 TRKS ALLOWED\n          EXEC END\n          ?\n\n       b. Reading a Line\n\n          You may READ a command from your active file.\n\n          COMMAND? LIST 6 (CR)\n             6.   sho date\n          COMMAND? READ 6 (CR)\n          16:32:47 07/19/74 (74.200)\n\n          You may specify that  the  line  be  deleted  from  your\n          active  file  after  it  is  executed  using  the DELETE\n          option.\n\n          COMMAND? READ 6 DELETE (CR)\n          16:32:47 07/19/74 (74.200)\n          COMMAND? LIST 6\n          VOID RANGE\n          COMMAND?\n\n          If you have entered a command  in  COLLECT  mode  rather\n          than  in  COMMAND mode, the above command is an easy way\n          to correct the error.\n\n          You may execute a  single  line  of  the  exec  file  by\n          specifying  the EXEC option along with the READ command.\n          You may not specify both the DELETE and EXEC options.\n\n          COMMAND?  READ LAST EXEC (CR)\n          ABC - 6 TRKS USED, 7 TRKS ALLOWED\n          COMMAND?\n\n\n1EXEC FILES                                                       V.F - 6\n\n\n    6. COPY EXEC\n\n       The EXEC option may be specified in  the  COPY  command  to\n       copy  all or part of the exec file to the active file.  Any\n       of the other COPY options may  also  be  specified,  except\n       FROM  (and associated options such as ON volume); COPY FROM\n       EXEC would use an external file with the dsname EXEC.\n\n       COMMAND? COPY FIRST/3 EXEC TO .1 BY 1 MERGE (CR)\n          2.3  -  LAST LINE\n       COMMAND?\n\n    7. COMMENT Command  (Short form: COMM)\n\n       The COMMENT command may be used in an exec  file  to  print\n       messages  or  instructions on the use of the exec file.  It\n       differs from a comment line beginning with a semi-colon (;)\n       in two ways:\n\n       a. It cannot appear on the same line as another command.\n\n       b. In EXEC NOLOG  mode,  the  text  following  the  COMMENT\n          command will be printed, whereas comments beginning with\n          a semi-colon will not.\n\n          COMMAND? LIST (CR)\n             1. ; THIS LINE WILL NOT BE PRINTED\n             2. COMMENT BUT THIS LINE WILL.\n          COMMAND? EXE ACTIVE NOLOG (CR)\n          BUT THIS LINE WILL.\n          EXEC END\n          COMMAND?\n\n\n    8. CLEAR EXEC\n\n       The exec option used with the CLEAR command causes the exec\n       file to be cleared.\n\n       COMMAND? CLEAR EXE (CR)\n       COMMAND? LIST EXEC (CR)\n       NO EXEC FILE\n       COMMAND?\n\n1VI.  USING THE CENTRAL COMPUTER                                  VI.A - 1\n\n\n VI.  Using the Central Computer through WYLBUR\n\n WYLBUR has two  commands  which  make  it  possible  to  use  the\n center's computer without writing your own JCL statements.  These\n commands may be used only with an active file.  They are:\n\n      LIST OFFLINE (to list an active file on the system  printer)\n      PUNCH (to punch a card deck)\n\n You may also submit a job to ASP for execution with this command.\n\n      RUN            (to submit a job into the batch)\n\n In addition, you may monitor  the  progress  of  a  job,  whether\n submitted from WYLBUR or not, by using this command:\n\n      LOCATE\n\n WYLBUR's primary function, however, is as an efficent text editor\n and not merely as a convenient, but expensive keypunch.\n\n A.  LIST OFFLINE\n\n It is not convenient to list all of a  very  large  file  at  the\n typewriter   terminal   because  the  selectric  prints  only  15\n characters per second, and a CRT will not give a printed copy  of\n the  file.   (You  may  want  to  check previous corrections on a\n printed copy).  WYLBUR has a command which lists your ACTIVE file\n on a high speed printer.\n\n      COMMAND?  LIST OFFLINE (CR)\n\n or, you may use the shorter form:\n\n      COMMAND?  L OFF (CR)\n\n WYLBUR will generate the necessary JCL,  put  the  job  into  the\n computer's job queue and bill the TPMON project number.\n\n      JOB 8101, ABCUR001 SUBMITTED\n\n\n LIST OFFLINE is a form of the LIST command encountered in Section\n III.  Actually OFFLINE is  a  parameter  of  LIST.   All  of  the\n options  which  are available with LIST are also usable with LIST\n OFFLINE.  In addition, LIST OFFLINE has  special  features  which\n are described in this section.\n\n    1. BIN\n\n       The output will be delivered to your default bin unless you\n       specify another bin in the command.\n\n       COMMAND?   LIST OFFLINE BIN A1 (CR)\n\n1USING THE CENTRAL COMPUTER                                       VI.A - 2\n\n\n    2. ACCOUNT\n\n       A CUCC project number may be  specified  in  the  LIST  OFF\n       command.   It  need  not  be  the  same number that will be\n       billed for your connect time on WYLBUR,  that  is  for  the\n       project number with which you signed on.  The parameter  is\n       ACCOUNT or ACC.\n\n       COMMAND?   LIST OFFLINE ACCOUNT=aaaaaaa (CR)\n\n       If you do not specify an account number  in  the  LIST  OFF\n       command, the job will be charged to the project number used\n       to sign on to TPMON.  If you give an invalid project number\n       (mistyped  or  no funds remaining for the project) ASP will\n       reject the JOB and the following message will be issued:\n\n         JOB ABCUR001 REJECTED BY ASP. CHECK AND RESUBMIT.\n\n       ASP will pick up some other JCL errors and also  give  this\n       response.   These  errors  refer  to  the  JOB  card or ASP\n       control statements.\n\n    3. (n)  (Positioning)\n\n       When listing offline you may position output on the printed\n       paper by specifying a count of the number of blanks  to  be\n       inserted  at  the left.  In this way you may obtain margins\n       or even center text on a page.\n\n       COMMAND?   LIST OFF (5) (CR)\n\n       This example will produce  output  which  is  shifted  five\n       positions  to  the  right.   The number of blanks specified\n       must be between zero and 70.  There may be a maximum of 132\n       characters on a printed line.   (n)  must  be  positive  or\n       zero.   If  it  is  zero, (0), then the text is listed with\n       carriage control and UNNUMBERED.\n\n\n    4. CC or MC (Carriage Control)\n\n       WYLBUR allows you to list a file  which  contains  its  own\n       printer control characters in column 1.\n\n       COMMAND?   LIST OFFLINE  CC (CR)\n\n       See Appendix B, Editing Hints, for more about using carriage\n       control characters.\n\n       When the LIST OFFLINE command is given for a file that  has\n       been  created  by some of the IBM processors or assemblers,\n       such as Assembler F or the Linkage Editor, WYLBUR  requires\n       the MC (machine carriage control) option since the carriage\n       control  characters  output  by  the processors are not the\n       standard (ASA) characters used by WYLBUR.\n\n       COMMAND?   LIST OFF MC (CR)\n1USING THE CENTRAL COMPUTER                                       VI.A - 3\n\n\n\n    5. 'title'\n\n       You may have a title on the first page of each copy of  the\n       output.   It  may be up to 64 characters in length and must\n       be enclosed in quotes.\n\n       COMMAND?  LIST OFF 'THIS IS MY TITLE' (CR)\n\n       The title must always be specified after OFFLINE or it will\n       considered as part of the associative range.\n\n    6. NOEJECT\n\n       You may use NOEJECT to suppress the  feature  which  causes\n       the  printer  to  move to the top of the next page after 60\n       lines have been printed.  It will then print on every line,\n       even over page perforations.\n\n       COMMAND?   LIST OFF BIN A1  NOEJECT (CR)\n\n    7. COPIES\n\n       It is possible to request up to 99  copies  of  an  offline\n       list.\n\n       COMMAND?  LIST OFF COPIES=50 (CR)\n\n       If a call is made for more than  15,000  lines  of  output,\n       WYLBUR prints the line count and asks if it should proceed.\n       A  YES  or  OK  reply  will produce the listing.  Any other\n       reply stops the job.\n\n    8. UPLOW\n\n       An offline listing can be printed using the upper and lower\n       case print train if you specify  UPLOW.   Note  that  since\n       characters  such  as \u00a2 and !  are not on the standard print\n       train, they will be printed as blanks in an offline listing\n       unless the UPLOW option is specified.\n\n    9. DARKLIST\n\n       The DARKLIST option produces  output  that  is  overprinted\n       once.   This  is  handy if the listing is to be reproduced.\n       You can get up to four overprints by specifying  DARKLIST=n\n       (n must be four or less).\n\n   10. SC  (service class)\n\n       The  valid  service  classes  for  ASP  are  E,H,N,O,S   in\n       descending  order of CUCC scheduling priority.  The service\n       class default is N. (The default for UI jobs is S.)\n\n1USING THE CENTRAL COMPUTER                                       VI.A - 4\n\n\n   11. ID\n\n       Any jobs submitted through WYLBUR will be given  a  jobname\n       by  WYLBUR  of the form uuuggnnn, where uuu is the user ID,\n       gg is the  group  id,  and  nnn  is  a  three-digit  number\n       incremented each time a new job is submitted.  If ID=aaa is\n       specified,  where  aaa  is  any  set  of  3  letters and/or\n       numbers, the job will  be  given  a  jobname  of  the  form\n       uuuggaaa.  For example,\n\n       COMMAND?  LIST OFF ID=CAT (CR)\n       JOB 6003, ABCURCAT SUBMITTED\n\n       For user ABC of group UR, WYLBUR will submit the  job  with\n       the job name ABCURCAT.\n\n   12. DEST\n\n       You may use the DEST  option  when  you  want  your  output\n       routed  to  a location other than the bins in the reception\n       area.  For instance, if you wanted output directed  to  the\n       Self-Service  I/O  area, you would include the following in\n       the command:\n\n       COMMAND?  LIST OFF DEST=SSERV (CR)\n\n   13. FORMS\n\n       The FORMS option is used when output is to  be  printed  on\n       other than the standard lined paper.  The command\n\n       LIST OFF FORMS=HEAVY\n\n       would cause the output to be printed on heavy  plain  white\n       paper.\n\n\n       The complete form of the LIST  command  for  use  with  the\n       OFFLINE option is:\n\n       LIST \u00ddrange\u00a8 \u00ddLIST options\u00a8 \u00ddSQUASHED\u00a8 \u00ddEXEC\u00a8\n            \u00ddCOLUMNS  m/n\u00a8  \u00ddOFFLINE\u00a8  \u00ddCC\u00a8  \u00ddBIN=bb\u00a8\n            \u00ddACCOUNT=aaaaaaa\u00a8 \u00ddSC=c\u00a8 \u00dd'title'\u00a8 \u00ddCOPIES=nn\u00a8 \u00ddUPLOW\u00a8\n            \u00dd(n)\u00a8 \u00ddNOEJECT\u00a8 \u00ddMC\u00a8 \u00ddFORMS=forms\u00a8 \u00ddID=aaa\u00a8 \u00ddDEST=dest\u00a8\n            \u00ddDARKLIST\u00a8\n\n       The parameters which are listed following OFFLINE are valid\n       only when used with OFFLINE and must be typed in  following\n       the  word  'OFFLINE'.  See Section VII for more information\n       on all options.\n1USING THE CENTRAL COMPUTER                                       VI.B - 1\n\n\n B.  PUNCH\n\n You may obtain a punched card deck of the  active  or  exec  file\n with  the  PUNCH command.  The ACCOUNT parameter may be specified\n on this command as in the LIST OFF.  To punch the active file:\n\n      COMMAND?   PUNCH (CR)\n\n If the NUMBERED option is specified, the  line  numbers  will  be\n punched  into  columns  73-80,  overwriting whatever was in those\n columns.  The range is optional.  If a job punches more than 2000\n cards, WYLBUR will send a message to that effect and  ask  if  it\n should  proceed.  A YES reply is needed for the job to go on.  To\n submit the exec file as a job, use the EXEC option.\n\n    1. RANGE\n\n        You may specify an explicit or  associative range.\n\n    2. LIST\n\n       The LIST option gives you a listing of the deck punched  in\n       the same job.\n\n    3. EXEC\n\n       PUNCH EXEC will produce a punched deck  of  the  exec  file\n       instead of the active file.\n\n    4. List options\n\n       The default is  UNNUMBERED.   IF  NUMBERED  or  INTEGER  is\n       specified, line numbers will be punched in columns 73-80.\n\n    5. DEST, ID, SC, BIN, COPIES, and ACCOUNT\n\n        These  options are used in the same way  here  as  in  the\n        LIST OFFLINE command.\n\n\n The complete form of the PUNCH command is\n\n    PUNCH \u00ddrange\u00a8 \u00ddLIST options\u00a8 \u00ddBIN=bb\u00a8 \u00ddACCOUNT=aaaaaaa\u00a8 \u00ddLIST\u00a8\n         \u00ddEXEC\u00a8 \u00ddSC=c\u00a8 \u00ddID=aaa\u00a8 \u00ddDEST=dest\u00a8 \u00dd'title'\u00a8\n\n\n\n1USING THE CENTRAL COMPUTER                                       VI.C - 1\n\n\n C.  RUN\n\n The RUN command directs WYLBUR to put the active or exec file into\n the input stream.\n\n      COMMAND?   RUN (CR)\n\n The active file must contain the necessary JCL statements to form\n a complete job.  The job card may contain a job  name.   All  JCL\n must be in upper case.\n\n    //jobname  JOB  (acctinfo),i.name\n\n 1. JOBNAME\n\n You may also allow WYLBUR to create a job name for  your  job  by\n leaving  at  least one space between the // and the word 'JOB' on\n the job card.  The jobname must begin with the  (signon)  USERID.\n The  fields printed in the example in lower case must be replaced\n by the appropriate information.\n\n    //  JOB  (acctinfo),i.name\n\n The job name supplied will be of the form uuuggnnn, where uuu and\n gg  are  the user ID  and group ID  specified  in  the   signon\n procedure,  and nnn is a three-digit number incremented each time\n you submit a job from WYLBUR.  The value of nnn for the next  job\n you submit may be obtained by giving the following command:\n\n    COMMAND?  SHOW JOBNO (CR)\n    002 - NEXT JOBNO\n\n This response indicates that the next job you submit  would  have\n the default jobname of uuugg002.\n\n It is possible to override the JOBNO  by  using  the  ID  option.\n Whether  or  not  you  specify  the  ID option, the JOBNO will be\n incremented.\n\n    COMMAND?  RUN ID=AAA (CR)\n    JOB 6002, ABCURAAA SUBMITTED\n\n\n After WYLBUR places the job in the input stream, it  acknowledges\n the job's submission:\n\n      JOB 8101, ABCUR001 SUBMITTED\n\n In this example 8101 is the ASP JOB number and  ABCUR001  is  the\n job name.\n\n\n When the RUN command is given, WYLBUR  automatically  passes  the\n1USING THE CENTRAL COMPUTER                                       VI.C - 2\n\n\n file  to the system in CARD format so that it can be processed by\n the computer.  Take care not to run a file whose JCL was  created\n while the SET UPLOW command  was  in  effect,  since  lower  case\n characters  are  not  converted to upper case.  If you forget and\n submit a JOB with a JOB card in lower case you will  receive  the\n message:\n\n         BAD JOB CARD, LINE     1.\n\n\n 2. LIST options\n\n\n If NUMBERED is specified, line numbers will automatically be  put\n into character positions 73-80, overwriting whatever was in those\n positions.   Thus  the  output from the run will contain the line\n numbers to facilitate further editing.\n\n       COMMAND?   RUN NUMBERED (CR)\n\n\n\n 3. EXEC option\n\n      COMMAND? RUN EXEC (CR)\n\n The RUN EXEC cammand can be used to submit a JOB from  your  exec\n file.   The  JOB must be a valid JOB.  It must have the necessary\n control cards.  If there is no JOB card or it  is  not  typed  in\n properly, ASP will prompt with the message:\n\n          BAD JOB CARD, LINE   n\n\n where n is the line number of the JOB card.  If you want  to  run\n only a section of the exec file you can specify:\n\n         RUN range EXEC\n\n\n 5. CANCEL and reject\n\n To cancel a run, hit the ATTN  key  before  the  'JOB  SUBMITTED'\n reply appears.  This will cause the run command to be aborted and\n the  job  will  not be submitted.  When this is done, WYLBUR will\n respond:\n\n      JOB FLUSHED AT USER'S REQUEST.\n\n Occasionally it may happen that  a  job  will  be  submitted  and\n WYLBUR will reply:\n\n      ABCUR001 REJECTED BY ASP. CHECK AND RESUBMIT.\n\n If this  happens,  check  JOB  and  ASP  Control  statements  and\n resubmit the job.\n\n1USING THE CENTRAL COMPUTER                                       VI.D - 1\n\n\n D.  LOCATE\n\n After a job has been submitted to the central computer,  you  may\n keep track of it with LOCATE.  You must indicate either the job's\n name  or  number  to  do  this.   You  may use LOCATE for any job\n submitted to the center's computer, whether or not  it  was  done\n from  WYLBUR.   Occasionally  ASP will be down and NO RUN will be\n set in which case you will receive the message:\n\n      NO JOB SUBMISSION ALLOWED\n\n You may have  the  following  operands  as  part  of  the  LOCATE\n command:\n\n      aaa         the last three letters or digits of the job name\n                  WYLBUR prefixes them with the user and group ID\n                  specified at signon time\n      jobname     the name on the job statement\n      nnnn        the ASP job number\n      ?           the first job in user hold.\n      n or nn     becomes 000n or 00nn (ASP job number)\n      $nnn        becomes 0nnn (ASP job number)\n      $aaa        becomes aaa (job name)\n      *           the last job submitted with a default job name\n      *+n, *-n    jobno plus or minus n\n\n If you have set a user or group then WYLBUR will LOCATE with that\n user and/or group as the default unless you specify '*' in  which\n case  WYLBUR uses the signon users or group.  The WYLBUR commands\n which may be used to submit a job are LIST OFFLINE,  PUNCH,  RUN,\n CONDENSE, and SUGGEST.\n\n If you have a user or group set then WYLBUR will locate with that\n user and/or group as the default unless you use  an  *  in  which\n case  your  default (signon) users/group will apply only to those\n JOBS beginning with your user and group can be  held,  cancelled,\n or released.  If an attempt is made to do any of the above with a\n different user or group, the following message will be issued:\n\n                JOB NAME MUST START WITH USER INITIALS\n\n WYLBUR will respond to the LOCATE command with the current status\n of the job.\n\n      JOB 8101,ABCUR001 PRTY=00 MAIN(C),CRBEOUT(C),PUNCH,PRINT\n      or\n      JOB ABCUR002 IS NOT IN THE SYSTEM\n\n The possible job status letters may be received:\n\n         Q,V       Queued for processing\n         U,V       Setup jobs-waiting for devices\n         R,V       Setup jobs-in setup\n         A,V       Active\n         C         Completed\n\n1USING THE CENTRAL COMPUTER                                       VI.E - 1\n\n\n E.   HOLD, RELEASE and CANCEL\n\n Once your job has been submitted to ASP, you may control when  it\n runs on the computer by using the HOLD and RELEASE commands.  The\n HOLD  option  can  be used to save time and money by coding it as\n HOLD=YES.  This will hold your job  without  printing  until  you\n issue  the  RELEASE  command.   In this case you can CANCEL a JOB\n using the CANCEL command before it prints if the  output  is  not\n needed.   You  may  only  HOLD,  RELEASE,  and  CANCEL  jobs with\n jobnames beginning with your signon user ID.  If you try  to  use\n any  of the above commands with a user name or group to which you\n have not signed on, you will receive the error message:\n\n           JOBNAME MUST START WITH USER INITIALS\n\n The following operands are usable  with  the  HOLD,  RELEASE  and\n CANCEL commands:\n\n      jobname    the name on the job card.\n      aaa        the last three letters or digits of the job name.\n      *          the last job submitted with a default job name\n      *+n,*-n    jobno plus or minus n\n\n        COMMAND?  CANCEL 063 (CR)\n        JOB 063, ABCUR063 IS BEING CANCELLED\n\n        HOLD *\n        JOB 064, ABCUR064 RELEASED FROM HOLD STATUS\n\n If PRINT is specified after the jobname in  the  CANCEL  command,\n then  whatever was done up to the time the job was cancelled will\n be printed.\n\n        COMMAND? CANCEL ABCUR001 PRINT (CR)\n\n If you attempt to CANCEL a job before CRBEOUT takes over you will\n not get any printed output. (See F below.)\n\n1USING THE CENTRAL COMPUTER                                       VI.F - 1\n\n\n F.  Getting Output at the Terminal\n\n You may  route  your  output  to  the  terminal  after  you  have\n submitted  a job.  There are three possible forms of output which\n the system may produce in response to your request  for  terminal\n output.\n\n         An explicitly allocated data set\n         The ASP job facts file\n         ASP output data sets limited to  40 tracks on DCU126\n\n You may explicitly create a  data  set  with  LRECL  and  BLKSIZE\n specified.   This data set should be allocated on the same volume\n as your LIBRARY and should conform  to  WYLBUR  data  set  naming\n conventions:   WYL.gg.nnn.name  .   A  sample explicit allocation\n follows:\n\n       //SYSPRINT DD DSN=WYL.UR.ABC.OUTPUT,DISP=(,KEEP),UNIT=2314,\n       //            VOL=SER=DCU207,SPACE=(TRK,(10,10),RLSE),\n       //            DCB=(RECFM=FB,LRECL=121,BLKSIZE=3509)\n\n You may also request ASP to create  output  data  sets  for  you.\n When  your job has completed, ASP will construct a job facts file\n if you requested any output data sets on DCU126.   You  would  do\n this by inserting a /*FORMAT RT card after your JOB card.\n\n The  name  of  the  job  facts  data  set   is   $SYSMSG.jobname.\n Therefore,   you  could  inspect  it  by  issuing  the  following\n commands:\n\n         USE $SYSMSG.jobname ON CAT  (CR)\n         SCR * ON CAT (CR)\n         LIST (CR)\n\n The job facts data set will describe each output data  set  which\n you  requested  through the use of a /*FORMAT card.  A sample job\n which includes this ASP control card follows:\n\n         //       JOB (acctinfo),i.name\n         /*FORMAT   RT,DDNAME=SYSMSG\n         /*FORMAT   RT DDNAME=SYSPRINT\n         //  EXEC FORTGCG\n         //FORT.SYSIN DD *\n                READ (5,10) DATA\n          10    FORMAT (F5.0)\n                WRITE (6,20) DATA\n          20    FORMAT (F5.0)\n                STOP\n                END\n         //GO.SYSIN DD *\n          10.0\n         /*\n\n Inserting a blank between the RT and DDNAME on the /*FORMAT  card\n causes  the  output  data  set  to  be  created  but prevents its\n printing on the system printer.  A comma between them allows such\n printing and the creation of the output data set on DCU126.\n1USING THE CENTRAL COMPUTER                                       VI.F - 2\n\n\n The format of the output  data  set  will  be  $CB.jobname.ddname\n which  can  be  found  on  DCU126.  Therefore, you may USE it and\n SCRATCH from WYLBUR.  Since disk space is  scarce  at  CUCC,  you\n should  SCRATCH  your  output data sets as soon as you have USE'd\n them.  In any event, they will be scratched by the system  within\n 8  hours  of  their  creation.  The exec file #OUT can be used to\n retrieve a data set from DCU126 easily.  This exec  file  can  be\n invoked by specifying:\n\n         EXEC FROM #OUT USER CTR GROUP CU\n\n The directions from this exec file can be  listed  by  doing  the\n following:\n\n          COMMAND? USE @CU.&CTR#WYLMAN ON CAT (CR)\n\n and then listing the file either at the terminal or offline.\n\n You may automatically place your job in HOLD status after it  has\n finished  execution  but before printing.  This is useful because\n it allows you to look at your output over WYLBUR before  deciding\n whether  to  print  it  (and  be  charged  for the printing).  To\n accomplish this, construct a /*FORMAT  cards  with  a  comma  (,)\n between  the  RT  and the DDNAME parameters and add the parameter\n HOLD=YES.  The HOLD parameter on any /*FORMAT card will cause the\n entire job to be put in HOLD.  You may  subsequently  RELEASE  or\n CANCEL it.\n\n          /*FORMAT RT,DDNAME=SYSPRINT,HOLD=YES\n\n Since output retrieval is a common task, we  recommend  that  you\n use  the  the  exec files provided such as #OUT.  This can save a\n lot of time and effort  and  is  easily  invoked.\n\n1USING THE CENTRAL COMPUTER                                       VI.G - 1\n\n\n G.  Converting Card Decks to WYLBUR Files\n\n If you have a program or text on cards, you may  place  it  in  a\n WYLBUR  file  in  CARD  format  by punching the following JCL and\n submitting the job from the card  reader.   This  JCL  should  be\n employed for card decks containing more than 2000 cards.\n\n         //       JOB (acctinfo),i.name\n         // EXEC PUP,NAME=PRESS\n         //SYSUT2 DD DSN=dsname,UNIT=2314,\n         //       DISP=SHR,DCB=(RECFM=U,BLKSIZE=3520)\n         //SYSUT1 DD DATA\n            Your data with no /* or JOB cards\n         /*\n\n                        your data with no /* or JOB cards in it\n\n         /*\n\n Remember not to include in your deck any /* cards or  JOB  cards;\n other JCL is admissible.\n\n A more inexpensive method which may be used for decks under  2000\n cards in length employs ASP control cards as follows:\n\n         //   JOB (acctinfo),i.name\n         /*PROCESS CRBEOUT\n         /*FORMAT RT DDNAME=ddname,CONTROL=SINGLE\n         /*ENDPROCESS\n         /*DATASET DDNAME=ddname\n\n                        your data with no /* or JOB cards in it\n\n         /*ENDDATASET\n\n In this case, the cards will be saved on DCU126 under the name of\n $CB.jobname.ddname.  The data set will eventually be scratched by\n the system.  Therefore, you should promptly USE the data set  and\n save it in your WYLBUR space.\n\n COMMAND? USE $CB.ABCUR061.SYSPRINT ON DCU126\n COMMAND? SCR $CB.ABCUR062.FT06F001 ON DCU126\n $CB.ABCUR062.FT06F001 SCRATCHED ON DCU126\n COMMAND? SAVE #MYFILE\n MEMBER MYFILE SAVED IN LIB\n1VII.  SUMMARY OF COMMANDS                                          VII - 1\n\n\n VII.  Summary of Commands\n\n This section and the following one are meant  to  be  used  as  a\n reference once you know the basic WYLBUR Commands.\n\n This section gives a succinct review of all  WYLBUR  commands  as\n well as references to information in the previous section of this\n manual.   All  commands  appear  here with their complete list of\n parameters even if all the parameters were not  included  earlier\n in  this  manual.   In addition, these commands are introduced in\n this section:\n\n           CATLG      DECIDE      POINT      RENAME\n           COMMENT    GIVE        PUT        RESTORE\n           COMPARE    HELP        RECATLG    UNCATLG\n\n Three of these commands (CATLG, RECATLG, UNCATLG) were  discussed\n as  parameters  in  the  SAVE command in Section IV, but they are\n also valid as separate commands.  Several SET and  SHOW  commands\n are also introduced in this section.\n\n For each command, the format is given in outline form  under  the\n following rules:\n\n Required parameters are denoted by their general  terms  enclosed\n in  pointed  brackets  -- <...>.  Each is discussed under its own\n heading in Section VIII.  Section VIII also  defines  some  other\n terms used in the text.\n\n Optional phrases are denoted by enclosure in regular brackets  --\n \u00dd...\u00a8.\n\n Alternate choices are separated by a | symbol and are enclosed in\n regular brackets \u00dd...\u00a8 if the entire phrase  is  optional  or  in\n braces  \u00bb...\u00ba  if one of the options must be selected.  If one of\n the options is a default, it is underlined.\n\n Direct substitutions are denoted by lower  case  letters  in  the\n following ways:\n        a - any alphabetic or numeric character\n        bb - any valid bin number\n        c - any appropriate character\n        gg - a valid group id\n        i,j,k,l,m,n - a valid integer value\n        uuu - a valid user id\n\n1SUMMARY OF COMMANDS                                                VII - 2\n\n\n ALIGN Command (Short Form:  ALI)\n\n ALIGN <range> \u00ddLENGTH=n\u00a8 \u00ddMARKER=c\u00a8 \u00ddNUMBER\u00a8 \u00ddINDENT=i \u00ddj\u00a8\u00a8\n     \u00ddEVEN\u00a8 \u00ddSPACE\u00a8\n\n ALIGN rearranges the contents  of  the  lines  in  the  <explicit\n range>  of  the  active  file  so that each line contains as many\n words as possible but not more than LENGTH characters.  Splits in\n a line are made only at blanks.  After  the  lines  are  aligned,\n WYLBUR  renumbers that portion of the file that was aligned.  One\n blank is inserted after each word unless it ends with  a  period,\n exclamation  point,  or  question  mark, which forces two blanks.\n See Section III.E.  for a discussion and examples  of  the  ALIGN\n command.\n\n If LENGTH is not specified in the command, the current  value  of\n the   global  LENGTH  parameter  is  used.   The  maximum  LENGTH\n permitted is 133 characters.\n\n The MARKER option must be specified in the command  if  you  want\n this  feature.   When WYLBUR encounters the MARKER character or a\n blank in column one of any line being aligned, that line  is  not\n aligned and the alignment process is restarted after that line.\n\n If NUMBER is specified, WYLBUR renumbers the  entire  file  after\n the alignment process.\n\n INDENT=i will indent each aligned line by i spaces.   INDENT=i  j\n will also further indent paragraph beginnings that are indented j\n spaces.   If INDENT is not specified, INDENT 0 0 is assumed; if j\n is  not  specified,  INDENT=i  0  is  assumed.   Unless  EVEN  is\n specified, only those lines beginning in either column i+1 or j+1\n will be aligned.\n\n If EVEN is specified, the alignment  process  is  restarted  only\n after  a  blank  line and all lines in the <range> are aligned on\n the left margin to the columns specified in the INDENT parameter.\n\n If SPACE is specified, WYLBUR respaces the lines so that there is\n only one space between words unless the word ends with a  period,\n exclamation point, or question mark, when it inserts two spaces.\n1SUMMARY OF COMMANDS                                                VII - 3\n\n\n CANCEL Command (Short Form:  CAN)\n\n CANCEL \u00bb<jobname> | aaa | *\u00ba \u00ddPRINT\u00a8\n\n The CANCEL command allows a job to be deleted from the ASP queue.\n If the job is executing on MAIN, it will be stopped.   No  output\n for the job will be provided unless you specify the PRINT option.\n\n The job may  be  referenced  by  the  complete  <jobname>  (e.g.,\n ABCURXYZ)  or  by  the last three characters (aaa) (e.g., XYZ) of\n the jobname (WYLBUR will assume that  the  jobname  is  uuuggaaa,\n where  uuu  and  gg  are  the values of the global USER and GROUP\n parameters) or by an asterisk which denotes uuuggnnn,  where  nnn\n is  the current value of the preprocessor variable JOBNO which is\n part of the jobname if the ID option was not specified  when  the\n job  was  submitted (see the ID option of the RUN command).  This\n option may also be specified by *+m or *-m which  references  the\n preprocessor JOBNO + OR - the value of m.\n\n You may CANCEL only jobs which begin with your  signon  user  ID.\n For  example,  if  you  signed on with initials ABC, you may only\n CANCEL jobs with a jobname beginning with ABC.\n\n\n CATLG Command (Short Form:  CAT)\n\n CATLG <dsname> ON <volume> \u00ddUSER uuu\u00a8 \u00ddGROUP gg\u00a8 \u00ddSET|NOSET\u00a8\n+                                                      _____\n\n CATLG causes the specified data set to be cataloged in the system\n catalog.  You are informed if the data set is already  cataloged.\n You must specify a dsname and a volume.\n\n You may catalog only data sets which belong to  you  or  to  your\n group  (USER  PUB).   USER  uuu may be used to catalog a data set\n with your own initials if you have done a SET USER earlier in the\n session.  For example, if you did a SET USER XYZ and later wished\n to catalog a data set with your own initials, ABC,  specify  USER\n ABC.   This  will  work  only  if  you  have  signed on with your\n initials, ABC.  You can only catalog a data  set  to  either  the\n initials  with which you signed on or PUB.  GROUP gg has the same\n kind of restrictions as USER uuu.\n\n\n CENTER Command\n\n CENTER <range> \u00ddLENTH=n\u00a8 \u00ddINDENT=m\u00a8\n\n The CENTER command centers each line of text in the range  within\n the  LENGTH  specified  or  the global LENGTH.  The INDENT option\n allows you to specify centering based on an indentation value.\n1SUMMARY OF COMMANDS                                                VII - 4\n\n CHANGE Command (Short Form:  CHA or CH)\n\n This command allows you to change a specified character string in\n all lines which are in some specified <range> in the active file.\n\n CHANGE <string1> \u00dd\u00ddi\u00a8\u00dd/\u00ddj\u00a8\u00dd/k\u00a8\u00a8\u00a8 \u00dd(n)\u00a8 TO <string2> \u00ddIN <range>\u00a8\n     \u00dd<list options>\u00a8 \u00ddLINE\u00a8\n\n The entire active file or the <range>, if specified, is  searched\n for  lines containing an instance of <string1>.  In each of these\n lines, the  specified  occurrence  of  <string1>  is  changed  to\n <string2>.   See  Section  III.C.  for a discussion of the CHANGE\n command.\n\n The optional i and j modifiers restrict the search to  columns  i\n through  j  of  the  line.   If only i is specified, <string1> is\n restricted to start in column i of the line.  If specified, k  is\n the  fill  column, and nothing from that column to the end of the\n line should be moved or changed.  If j is specified,  i  must  be\n specified,  but  both  i  and  j  are  optional.  The fill column\n feature is useful for  preserving  sequence  numbers  in  columns\n 73-80,  for  instance,  or for preserving columnization in texts.\n Because of this feature, characters may be lost.  If this happens\n a warning message  will  be  issued  explaining  in  which  lines\n characters  were  lost.   See  Section III.C for more on the fill\n column.\n\n If the n modifier is not given, all occurrences of  <string1>  in\n the  line  are changed.  A (3) would specify the third occurrence\n in the line.\n\n Ordinarily the changed lines are listed together with their  line\n numbers.   If any of the <LIST options> are specified the changed\n lines will be listed accordingly.  These options as well  as  the\n IN range option may be used with any form of the CHANGE command.\n\n <string2> may take the form of an incremented  integer:   n  m  ,\n where  n  is  a  starting number and m is an increment to be used\n each time a change is made.  Either may  be  positive  (sign  not\n required) or negative (minus sign is required).  If m=1 it may be\n omitted.   The  LINE  option causes the integer to be incremented\n only at the beginning of each line changed.\n1SUMMARY OF COMMANDS                                                VII - 5\n\n\n CHANGE \u00dd\u00ddi\u00a8\u00dd/\u00ddj\u00a8\u00dd/k\u00a8\u00a8\u00a8 TO <string2> \u00ddIN <range>\u00a8 \u00ddLINE\u00a8\n\n In this alternate form, changes are made to columns i  through  j\n of  each line in the <range>.  If i and j are both specified, the\n characters in positions i through j are  replaced  by  <string2>.\n If  only  i  is specified, <string2> is inserted before character\n position i.  Thus CHANGE 1 to ' ' would insert a blank in  column\n 1.   CHANGE  1/1  to  ' ' would change the character presently in\n column 1 to a blank.  k is the fill column as specified above.\n\n <string2> may take the form of an  incremented  integer  with  or\n without the LINE option, as above.\n\n An alternate form of the command allows the replacement string to\n be taken from a range of lines in the data set.\n\n CHANGE \u00dd<string1>\u00a8  \u00dd\u00ddi\u00a8\u00dd/\u00ddj\u00a8\u00dd/k\u00a8\u00a8\u00a8  \u00ddIN  <range1>\u00a8  \u00dd(n)\u00a8\n     USING <range2> \u00ddCOLUMNS=\u00bb\u00ddm1\u00a8\u00dd/m2\u00a8\u00ba\u00a8 \u00ddREPEAT\u00a8\n\n The replacement may be any single set of contiguous lines.\n\n The contents of the lines  in  the  replacement  range  are  used\n successively  as  replacements.   If  more changes are to be made\n than there are lines in the replacement range, the REPEAT  option\n may  be  specified.   This  causes  WYLBUR to recycle through the\n replacement range.\n\n COLUMNS=m1/m2 can be added to specify  that  only  the  indicated\n range  of columns is to be used from each line in the replacement\n range.  COLUMNS=m1 specifies  that  the  contents  of  the  lines\n beginning  with  column m1 are to be used.  COLUMNS=/m2 specifies\n that the contents of the lines from column 1  through  column  m2\n are to be used.\n\n\n CLEAR Command (Short Form:  CLE or CLR)\n\n CLEAR \u00bb\u00ddACTIVE\u00a8 \u00ddEXEC\u00a8 \u00ddTEXT\u00a8 \u00ddNAME\u00a8 \u00ddTABS\u00a8\u00ba\n\n This command is used to erase either the current active  file  or\n the  current  exec  file.  The TEXT option is an alternate way to\n clear the active file.  The settings of global parameters  remain\n in  effect  even  after  the  active  file  is cleared.  Refer to\n Section IV.C.2 for clearing the active file.   See  Section  V.C.\n for clearing the exec file.\n\n The NAME option resets the GROUP, USER, PREFIX, and MEMBER fields\n to the default signon values.  Those fields are used  in  forming\n <dsnames>.\n\n The TABS option clears the tab positions that have been set by  a\n SET TABS command.\n1SUMMARY OF COMMANDS                                                VII - 6\n\n\n COLLECT Command (Short Form:  COL or C)\n\n COLLECT \u00dd<lineno1>|END\u00a8 \u00ddBY <lineno2>\u00a8 \u00ddMERGE\u00a8  \u00dd<list  options>\u00a8\n     \u00ddCLEAR\u00a8\n\n Lines are collected into the  active  file  beginning  with  line\n <lineno1>,  and deriving successive line numbers by using a DELTA\n of <lineno2>.  If <lineno2> isn't specified, a 1 in the low order\n digit of <lineno1> is used.  If <lineno1>  isn't  specified,  the\n starting  number  is  DELTA  higher  than  the last line that was\n collected.  If this line is presently in the text, a message will\n inform you that you cannot collect at that point.  The  only  way\n to  reset  this  pointer  for  the same active file is to specify\n <lineno1> in the COLLECT  command.   END  means  last  line  plus\n DELTA.   You  would specify END if you wanted to add lines to the\n end of a file.\n\n The COLLECT  command  will  not  normally  allow  overwriting  or\n interleaving  existing  lines  in  the  file  but  it  will allow\n interleaving if you use the MERGE option.\n\n The LIST or NOTEXT option will list the line or  line  number  in\n the  file  which  precedes  the  next  line to be collected.  The\n UNNUMBERED, NONUMBERED, OR INTEGER option will prompt for the new\n line.\n\n\n COMMENT Command (Short Form:  COMM)\n\n COMMENT any text\n\n This command is designed to be used in exec files to write at the\n terminal instructions to describe how to  use  the  current  exec\n file.   If LOG is in effect, the COMMENT command lines are listed\n just as all other commands are.   If  NOLOG  is  in  effect,  the\n COMMENT  text  is  listed even though the other commands are not.\n In this respect, comments in a COMMENT command are different from\n comments following a semi-colon on other command  lines  for  the\n latter  are  not  listed  under NOLOG.  A semi-colon in a COMMENT\n command is part of the comment to be displayed just as any  other\n character.\n\n      COMMAND? LIST (CR)\n        1. COMMENT THIS TEXT WILL BE LISTED.\n        2. ; THIS TEXT WILL NOT BE LISTED.\n      COMMAND? EXEC ACTIVE NOLOG (CR)\n      THIS TEXT WILL BE LISTED.\n      EXEC END\n      COMMAND?\n1SUMMARY OF COMMANDS                                                VII - 7\n\n\n COMPARE Command (Short Form:  COM)\n\n COMPARE \u00dd<list options>\u00a8 <lineno1> <lineno2> \u00ddCOLUMNS \u00bb\u00ddn\u00a8\u00dd/m\u00a8\u00ba\u00a8\n\n The COMPARE command may be used to compare the  contents  of  two\n sets  of  consecutive  lines, both of which must be in the active\n file.  The two required operands are the starting line numbers of\n the ranges to be compared.  A line by line comparison is made  of\n the  line contents until the end of the active file is reached or\n a comparison fails.\n\n      COMMAND? COMPARE 1 4\n          3.    --     6.    COMPARE\n      COMMAND? COMPARE NOLIST 1 1.3\n          1.1   --     2     DON'T COMPARE\n      COMMAND? COMPARE 2 2.4\n          2.3   --     3     DON'T COMPARE\n          2.3    THIS IS A LINE IN THE FILE\n          3.     THIS LINE DOES NOT MATCH\n\n In the first example the set of lines starting at 1  is  compared\n to the set of lines starting at 4 and did compare.  In the second\n example, the first lines of the two sets compared, but subsequent\n lines  did  not.  In the third example, NOLIST was not specified,\n so WYLBUR also listed the  first  pair  of  lines  that  did  not\n compare.\n\n If the COLUMNS option is specified, only columns n through m  are\n compared.   If only n is specified, n/133 is assummed.  If only m\n is specified, 1/m is assummed.\n\n\n CONDENSE Command (Short Form:  CON)\n\n CONDENSE <dsname> ON <volume> \u00ddUSER uuu\u00a8 \u00ddGROUP gg\u00a8\n     \u00ddBIN bb\u00a8 \u00ddACCOUNT aaaaaaa\u00a8 \u00ddSC=c\u00a8 \u00ddID=aaa\u00a8\n\n The condense command causes the submission of a job  to  condense\n the  specified  partitioned data set using the COMPRESS option of\n the IBM Utility IEBCOPY.  You  can  use  the  locate  command  to\n determine  when  the  job  has  finished  execution.  Whenever an\n attempted SAVE of a PDS member cannot  be  completed  because  of\n insufficient  space  in  the  data  set,  WYLBUR  prompts  with a\n CONDENSE?  To have your library condensed, reply YES or OK.   Any\n other  reply  aborts  the  SAVE  command  and  does  not submit a\n CONDENSE.  <dsname> and ON <volume>  must  be  specified  in  the\n command.  The USER and GROUP options may be used to specify a PDS\n belonging  to another user.  BIN and ACCOUNT may be used to route\n the output to another bin and charge your project number for  the\n accounting units.\n1SUMMARY OF COMMANDS                                                VII - 8\n\n\n NOTE:  The command SHOW DSNAMES LIKE LIB SPACE may be used to see\n how many tracks in your library have been used.  This information\n can be used to determine when a CONDENSE  should  be  done.   See\n Section IV.D. on the CONDENSE command.\n\n\n COPY Command (Short Form:  COP)\n\n This command allows you to copy a <range>  of  lines  to  another\n place  in the active file.  For a discussion of COPY, see Section\n III.D.\n\n COPY \u00dd<range>\u00a8 \u00ddTO \u00bb<lineno1>|END\u00ba\u00a8 \u00ddBY <lineno2>\u00a8 \u00ddFROM <dsname>\n+                              ___\n     \u00ddON <volume>\u00a8 \u00ddCOMBINE\u00a8 \u00ddUSER uuu\u00a8 \u00ddGROUP gg\u00a8  \u00ddSET|NOSET\u00a8\u00a8\n+                                                        _____\n     \u00ddMERGE\u00a8 \u00ddEXEC\u00a8 \u00dd<list options>\u00a8\n\n <range>  must  be  the  first  positional  parameter  if  it   is\n specified.   DSNAME  parameters  such  as USER uuu or ON <volume>\n must follow the <dsname> if it is used.\n\n A copy of the specified <range> is placed  in  the  active  file,\n beginning  at  a  line numbered <lineno1> and deriving successive\n line numbers by using <lineno2>.\n\n If <lineno2> is not specified, the default value is a  1  in  the\n last  specified  position  of  <lineno1>.   If the value of DELTA\n (specified or default) would cause the copied lines to interleave\n existing lines in the file, WYLBUR automatically calculates a new\n value of DELTA so that interleaving does not  take  place.   Note\n the MERGE and COMBINE options for exceptions.\n\n Existing lines in the file may not be replaced by using the  COPY\n command.\n\n The <range> is taken from the active file unless the FROM  option\n is  present,  in  which  case, the <range> will be taken from the\n named <external file>, which must be in EDIT format.  If you copy\n from an external file you may specify ON <volume>.  The USER  and\n GROUP options may be used to copy from another user's data sets.\n\n The SET option will set the PREFIX and  MEMBER  fields  to  those\n specified in the COPY command.  It will not set the USER or GROUP\n fields.\n\n The EXEC option copies all or part of the exec file to the active\n file.  Although COPY EXEC is really a copy from  the  exec  file,\n the  FROM  option  should not be used.  COPY FROM EXEC would copy\n the external file named EXEC instead of  copying  from  the  exec\n file.\n1SUMMARY OF COMMANDS                                                VII - 9\n\n\n The MERGE option allows interleaving of the  file,  if  the  line\n numbers  interleave.   COMBINE  also  allows interleaving, but is\n used when an external file is referenced.\n\n Any <LIST option> causes the new lines to be listed.\n\n\n DECIDE Command (Short Form:  DEC)\n\n DECIDE any text\n\n This command will  use  the  text  to  determine  an  appropriate\n response from these four possible responses:\n\n ** YES **, ** NO **, ** MAYBE **, ** WHY NOT?  **.\n\n\n DELETE Command (Short Form:  DEL or D)\n\n DELETE <range> \u00dd<list options>\u00a8\n\n This allows you to erase a <range> of lines in the  active  file.\n The  range  may be associative (i.e.  DEL 'abc' IN ALL).  In this\n case, an explicit range must be given.\n\n An alternate form may be used.  This consists of  giving  a  line\n number  followed immediately by a carriage return as the command.\n There is an example of the alternate form in Section III.C.4.\n\n Any of the <LIST options> list the deleted lines.  NOLIST is  the\n default.\n\n\n EDIT Command (Short Form:  EDI or E)\n\n EDIT \u00dd<range>\u00a8 \u00dd<list options>\u00a8 \u00ddSINGLE\u00a8\n\n The EDIT command allows you to change the contents of  a  <range>\n of  lines in the active file.  There is a full discussion of EDIT\n in Section III.F.  The SINGLE option results in  one  prompt  per\n line  instead  of  the  usual multiple prompts.  NOLIST specifies\n that WYLBUR is not to list the changed line.\n\n When executed, the EDIT command will prompt with  the  designated\n line.  A character or set of characters can be replaced by typing\n under  any  undesired  character the replacement character.  If a\n verticle bar  (|)  on  2741  type  terminals  is  typed  under  a\n character  then  the  character  is  replaced  by  a blank.  If a\n verticle bar is typed under a blank then the verticle bar appears\n in the text.\n1SUMMARY OF COMMANDS                                                VII - 10\n\n\n EXEC Command (Short Form:  EXE or X)\n\n EXEC \u00ddACTIVE|FROM <dsname> \u00ddON <volume>\u00a8 \u00ddUSER uuu\u00a8\n     \u00ddGROUP gg\u00a8 \u00ddSET|NOSET\u00a8\u00a8 \u00ddCLEAR\u00a8 \u00dd<lineno1>|RETRY\u00a8\n+                    _____\n     \u00ddPAUSE\u00a8 \u00ddLOG|NOLOG\u00a8 \u00ddTERSE|VERBOSE\u00a8 \u00ddSTART <lineno2>\u00a8\n\n The CUCC/WYLBUR system can execute a file of commands in an  exec\n file.    The   commands  are  selected  sequentially  unless  the\n <lineno1> option is used to specify a branch instruction  in  the\n exec  file.   Selection  of commands from the exec file continues\n until the end of the file is reached, a command has an  error  or\n is interrupted, or another EXEC command is executed from the file\n with  the  PAUSE  option.  See Section V for a discussion of exec\n files.\n\n Before commands can be executed from the exec file, the file must\n be loaded.  The ACTIVE option specifies that the file  should  be\n loaded  from  the  current  active file.  The active file will be\n cleared after the exec file is loaded.  The FROM option specifies\n that the exec file should be loaded from an EDIT format  external\n file.   The  active  file is not affected by this option.  If you\n are using an external file, you must specify ON <volume>.   After\n the  load  is  completed, execution begins from the start of exec\n file if START <lineno2> is not specified and the PAUSE option  is\n not  used.   If  neither  the  ACTIVE  nor  the  FROM  option  is\n specified, the EXEC command refers to the current exec file.\n\n If you specify SET, the PREFIX and MEMBER names will be set.\n\n USER and GROUP may be used to designate an  external  file  which\n belongs to another user.\n\n The CLEAR option specifies that the current exec file  should  be\n cleared   before   performing  the  rest  of  the  EXEC  command.\n Normally, this option is used with the ACTIVE or FROM  option  to\n avoid  a  prompt before clearing the current exec file.  Also see\n the CLEAR command.\n\n The EXEC feature maintains a current pointer to  a  line  in  the\n exec file whenever control is returned to the terminal.  Thus you\n may  continue  executing  at  the  point  of interruption without\n specifying  a  <lineno1>.   The  RETRY  option   specifies   that\n execution  should  start  with the interrupted command.  Omitting\n <lineno1> and RETRY specifies that execution should start at  the\n next  command  after  the  interrupted command.  See SHOW EXEC in\n this section.\n1SUMMARY OF COMMANDS                                                VII - 11\n\n\n The PAUSE option directs WYLBUR to return control to the terminal\n after all other options have been set without executing any other\n commands.  This option can be used to load an exec file and delay\n execution until later.\n\n The LOG option specifies that all commands should be typed before\n execution.  If the listing of a command is interrupted  by  using\n the  ATTN key , the command will not be executed and control will\n return to the terminal.  If neither LOG nor NOLOG  is  specified,\n the  LOG  option  is  unchanged.  At signon, the option is set to\n LOG.  See also SET LOG|NOLOG.\n\n\n GIVE Command (Short Form:  GIV)\n\n GIVE n TO uuu\n\n This command allows you to give n tracks of your space allocation\n to user uuu.  The number of tracks you specify cannot be  greater\n than  the  amount  of  unused space in your allocation.  User uuu\n must be in your group.\n\n\n HELP Command (Short Form:  HEL)\n\n HELP\n\n This command returns a message indicating whom to contact if  you\n are having problems with the WYLBUR system.\n\n\n HOLD Command (Short Form:  HOL)\n\n HOLD \u00bb<jobname> | aaa | *\u00ba\n\n This command places a job in user hold after  completion  of  the\n currently  scheduled  ASP  task  (e.g.,  MAIN, CRBEOUT).  See the\n RELEASE and CANCEL commands in this section and Section VI.E  and\n Section VI.F.\n\n The option specified may be in the same form as  the  options  of\n the CANCEL command.\n\n You may HOLD only jobs which begin  with  your  signon  INITIALS.\n For  example,  if  you  signed on with initials ABC, you may only\n HOLD jobs with a jobname beginning with ABC.\n1SUMMARY OF COMMANDS                                                VII - 12\n\n\n INSERT Command (Short Form:  INS or I)\n\n INSERT <lineno> \u00ddNODITTO|DITTO\u00a8 \u00dd<list options>\u00a8\n+                 _______\n\n This command allows you to insert a line of text into the  active\n file.  INSERT is discussed in SECTION III.B.\n\n This command causes WYLBUR to  prompt  with  the  specified  line\n number, after which you may type in the contents of the new line.\n The  specified  line  number must not already exist in the active\n file.\n\n The <LIST options> work as for the COLLECT command.\n\n Lines can be inserted at many places with a single command.\n\n      COMMAND? INSERT 3,5,7\n\n WYLBUR will prompt with the line number of  each  location.   The\n DITTO  option  may  be  used  if  you  wish to insert one line in\n several places.\n\n      COMMAND? INSERT 3,5,7 DITTO\n\n WYLBUR will prompt with line number 3 and  insert  the  line  you\n type at lines 3, 5, and 7.\n\n An alternate form of the INSERT command  consists  of  the  <line\n number>,  followed  by a single blank character, and the contents\n of the new line  of  text.   In  this  alternate  form,  the  old\n contents will be overwritten if the specified line already exists\n in  the  active  file.  Thus a replacement is done rather than an\n insertion.\n\n\n JUSTIFY Command (Short Form:  JUS)\n\n JUSTIFY <range> \u00ddLENGTH=n\u00a8 \u00ddMARKER=c\u00a8 \u00ddNUMBER\u00a8 \u00ddINDENT=i \u00ddj\u00a8\u00a8\n     \u00ddEVEN\u00a8 \u00ddSPACE\u00a8\n\n The JUSTIFY command is identical to the ALIGN command except that\n it also right justifies the text  to  the  value  of  the  LENGTH\n option  or the value of the global LENGTH parameter if the LENGTH\n option is not specified.\n\n The SPACE option will respace the  text,  omitting  extra  blanks\n before  it  justifies the <range>.  See the ALIGN command in this\n section and Section III.E.\n1SUMMARY OF COMMANDS                                                VII - 13\n\n\n LIST Command (Short Form:  LIS or L)\n\n This command lists part or all of a file.   It  is  discussed  in\n Section II.D and Section VI.A.\n\n LIST \u00dd<range>\u00a8 \u00dd<list options>\u00a8 \u00ddMARKER=c\u00a8\n     \u00ddCLEAN\u00a8 \u00ddEXEC\u00a8 \u00ddSQUASHED\u00a8 \u00ddCOLUMNS \u00bb\u00ddm1\u00a8\u00dd/m2\u00a8\u00ba\u00a8\n    \u00dd\u00ddOFFLINE\u00a8 \u00ddBIN bb\u00a8 \u00dd(n)\u00a8 \u00ddACCOUNT aaaaaaa\u00a8 \u00ddCOPIES=nn\u00a8\n     \u00dd'title'\u00a8 \u00ddUPLOW\u00a8 \u00ddNOEJECT\u00a8 \u00ddDARKLIST\u00a8 \u00ddCC|MC|DOUBLE|TRIPLE\u00a8\n     \u00ddDEST=destination\u00a8 \u00ddFORMS=formtype\u00a8 \u00ddID=aaa\u00a8 \u00ddSC=c\u00a8\u00a8\n\n\n If no options are specified, the entire active file is printed at\n the terminal.  The <range> option  limits  the  listing  to  some\n specified set of lines.\n\n Any of the <LIST options> lists the range  or  file  accordingly.\n The  effect  of  the  MARKER  option  is  to  suspend the listing\n whenever a line is reached which contains the MARKER character in\n column one.   The  suspended  listing  is  restarted  by  a  (CR)\n response.    An  (ATTN)  response  given  while  the  listing  is\n suspended will cause the rest of the listing to be aborted.   The\n MARKER option has no effect on an OFFLINE listing.\n\n The CLEAN option is used to be certain that messages  from  other\n terminals  will  not  interrupt  a  listing.   A message from the\n operator can interrupt even a CLEAN listing.\n\n The COLUMNS option lists only the text between columns m1 and  m2\n in  the  <range>.   If  m1  is  not  specified the line is listed\n through column m2; if m2 is not specified,  the  line  is  listed\n from column m1 through the end of the line.\n\n Specifying EXEC will result in listing the exec file  instead  of\n the active file.\n\n The SQUASHED option converts multiple blanks to single blanks for\n the listing.  The active or exec file is not altered.\n\n The OFFLINE option signals  that  you  want  a  printing  of  the\n specified  <range> or file on the high-speed printers rather than\n at the terminal.  You may specify a bin number  with  BIN  bb  to\n override the standard bin number for your initials.  In addition,\n you  may  have the charges incurred put onto ACCOUNT aaaaaaa.  If\n this is not specified, the charges will be put onto  the  account\n with which you signed onto TPMON.  The SC=c option may be used to\n specify  a  job priority other than the default determined by the\n project number of the job.  (SC may be E, H, N, O, or S.)\n1SUMMARY OF COMMANDS                                                VII - 14\n\n\n The ID=aaa option will cause the job to be submitted with the job\n name uuuggaaa, where uuu and gg are the signon  USER  and  GROUP.\n The JOBNO is still incremented by 1.\n\n The (n) option inserts n blanks at the  left  of  the  high-speed\n printer,  thus  allowing  you  to center output on the paper.  If\n n=0, the WYLBUR listing routine does not put any carriage control\n characters in print position one and it is assumed that the  file\n contains  the  carriage  control  characters.  ASA characters are\n expected unless you use the MC option.  If (0) is specified,  the\n file  will be listed unnumbered.  You may have a second (n) after\n the (0), which will cause the file to be listed unnumbered, using\n the first column as carriage control and indenting n spaces.   CC\n may be equivalent to (0), except that the file may be listed with\n line numbers.\n\n The COPIES=nn option allows you to have up to 99 copies  made  of\n your output.\n\n The offline listing may be given a title of up to  64  characters\n in  length  by  enclosing  the  desired  title in quotes.  If the\n string is longer than 64 characters, it will be truncated.\n\n\n The UPLOW option causes a special print train to  be  mounted  so\n alphabetic  characters  can  be  printed  in both upper and lower\n case.  If UPLOW is not specified, a \u00a2 or !  and  all  lower  case\n letters will print as blanks.\n\n NOEJECT suppresses the feature which causes the printer  to  move\n to the top of the next page after printing 60 lines.\n\n The DARKLIST option will cause each line of  the  listing  to  be\n restruck.   This  option  should  be  used if the output is to be\n reproduced.\n\n The MC option is valid only when an UNNUMBERED OFFLINE  (0)  list\n is  being  done on a file created by one of the IBM assemblers or\n compilers.  MC specifies  machine  carriage  control  characters,\n rather  than  ASA  characters.   DOUBLE or TRIPLE will double- or\n triple-space the listing.\n\n The FORMS option may be used to requset that the listing be  done\n on  non-standard  paper  or  forms.  See the CUCC User Manual for\n additional information.\n\n The DEST option may be used to route output  to  a  specific  RJE\n location.   For example, to route your output to the Self-Service\n I/O Area, specify:\n\n                            DEST=SSERV\n\n for a complete list of RJE locations, see the CUCC User's Manual.\n1SUMMARY OF COMMANDS                                                VII - 15\n\n\n LOAD Command (Short Form:  LOA)\n\n LOAD \u00dd<range>\u00a8 \u00ddFROM <dsname>\u00a8  \u00ddON  <volume>|CATLG\u00a8  \u00ddSET|NOSET\u00a8\n+                                                           _____\n      \u00ddSTART <lineno>\u00a8 \u00ddLOG|NOLOG\u00a8 \u00ddTERSE|VERBOSE\u00a8 \u00ddPAUSE\u00a8 \u00ddCLEAR\u00a8\n\n The LOAD command loads and executes the exec file.   It  is  like\n the EXEC command in all respects but two:\n\n      LOAD FROM is the same as EXEC FROM except that  LOAD  has  a\n      range  option  so  that  part  of  a  file may be loaded and\n      executed.  The <range> must be the first parameter.\n\n      LOAD is the same as EXEC  ACTIVE  except  that  EXEC  ACTIVE\n      clears the active file whereas LOAD does not.\n\n When you specify a <range> in the LOAD command, only that <range>\n is LOADed  into the EXEC file.  If a START <lineno> is specified,\n just that line number is  LOADed   into  the  EXEC  file.   If  a\n <range>  and a START <lineno> are both specified, then the entire\n <range> is LOADed  and execution starts with the START <lineno>.\n\n For more about the LOAD command, see Section V.\n\n\n\n LOCATE Command (Short Form:  LOC)\n\n This command allows you to inquire about the status of any job in\n the system, whether the job was created by WYLBUR or not.\n\n LOCATE \u00bbaaa|jobname|*|?|aaa>|nnnn\u00ba\n\n LOCATE is used to find the job's status in the ASP system.   aaa,\n jobname and * have the same form as in the CANCEL command.\n\n ?  is your first job in user hold.  aaa> is the first job in  the\n system  with  a job name beginning with aaa.  nnnn is the ASP job\n number.\n\n\n LOGOFF Command\n\n LOGOFF \u00ddCLEAR\u00a8\n\n This command terminates the session.  If CLEAR is  not  specified\n and the active file is not clear, a prompt is made to verify that\n it  is  okay to clear it and log off.  Any response to the prompt\n other than YES or OK causes the command to  be  aborted  and  the\n session  to continue.  Alternate forms of this command are LOGOUT\n and SIGNOFF.\n1SUMMARY OF COMMANDS                                                VII - 16\n\n\n      COMMAND? logoff\n      OK TO CLEAR? yes\n      3.46 SECONDS EDITING TIME\n      764 PAGE READS, 369 PAGE WRITES\n      20 DISK READS, 13 DISK WRITES\n      ELAPSED TIME = 01:36:22\n      END OF SESSION\n\n\n LOGON Command\n\n LOGON \u00ddCLEAR\u00a8\n\n This command allows a new user to sign on the  terminal  that  is\n already  in  use without changing the account number to which the\n session will be charged.   It  will  also  maintain  any  options\n (e.g.,CRT) defined by the terminal id.  If CLEAR is not specified\n and the old user has an active file, it is saved and cataloged as\n the  name  ACTIVE  before  the  new  log-on  sequence is started.\n Alternate forms on this command are LOGIN and SIGNON.\n\n\n MODIFY Command (Short Form:  MOD or M)\n\n MODIFY \u00dd<range>\u00a8 \u00dd<list options>\u00a8 \u00ddSINGLE\u00a8\n\n The MODIFY command allows insertions, replacements, and deletions\n to the contents of each line in a specified <range>.   Successive\n lines   are   prompted  for  alterations  until  the  <range>  is\n exhausted.  The MODIFY command is discussed at length in  Section\n III.F.    The  SINGLE  option  instructs  WYLBUR  to  prompt  for\n alterations only  once.   If  SINGLE  is  not  specified,  WYLBUR\n prompts  until  you  type only a carriage return in response to a\n prompt.  NOLIST means that WYLBUR will not type the changed  line\n at the terminal but it will still issue prompts.\n\n For each line in the specified <range> the following  process  is\n carried  out.   First,  the image of the line as it now stands is\n typed.  Then WYLBUR prompts for an alteration to be made  to  the\n line.  Alterations are one of the following:\n\n\n\n     INSERT (I)--Type the letter I immediately below the character\n     in the line before which characters are to be inserted.  This\n     indicator is followed by the string of characters  which  are\n     to  be  inserted.   For  example,  if you want to insert CUCC\n     before the W in WYLBUR, you type an I under the W, then  type\n     CUCC.   The string of characters to be inserted is terminated\n     by a carriage return.\n1SUMMARY OF COMMANDS                                                VII - 16.1\n\n\n     REPLACE (R)--This indicator is typed  immediately  below  the\n     first  character  to  be replaced in the line.  The string of\n     replacement characters is typed immediately following the  R.\n     As  many  characters  are replaced as there are characters in\n     the replacement string.\n\n     DELETE (D)--A string of characters to  be  deleted  from  the\n     line  is  designated  by  typing  a  D  under each successive\n     character to be removed.  A deleted character is not replaced\n     by a blank; WYLBUR shifts the other  text  to  eliminate  the\n     space.   You need type a D only underneath the first and last\n     characters  in  the  string  to  be  deleted--all  characters\n     between the two D's are also deleted.  The deletion range may\n     also be terminated by typing either an I or R instead of a D.\n     If terminated by an R, the characters following  the  deleted\n     string  are  replaced  by the replacement string that follows\n     the R.  If the deletion range is  terminated  by  an  I,  the\n     deleted  characters  are  replaced  with  the  string  to  be\n     inserted.\n\n     BLANK (B)--Individual characters may be blanked in  the  line\n     by  typing a B under each position to be blanked.  Only those\n     positions are blanked and  no  shifting  of  the  line  takes\n     place.  Any other alteration may follow the last B on a line.\n\n After the  alteration  is  specified,  type  a  carriage  return.\n WYLBUR  will  make the indicated alterations in the line and type\n the new image of the  line  for  inspection.   Then  WYLBUR  will\n prompt  for  more  alterations.   You signal that all alterations\n have been made by typing only a carriage return in answer to  the\n alteration  prompt.   WYLBUR  will  then put the new image of the\n line into the file and prompt for alterations to the next line in\n the <range>.\n\n The printing of the altered image of the line may be suspended by\n typing an N indicator into the alteration line before  any  other\n alteration indicators.\n\n You may have  WYLBUR  type  out  the  image  of  the  line  being\n modified,  as  it  currently  stands.  Type a few blanks into the\n alteration line and issue a carriage return.\n\n1SUMMARY OF COMMANDS                                                VII - 17\n\n\n You may eliminate all alterations made to a line by hitting  ATTN\n as  the  first  character in the alters line.  WYLBUR will forget\n about all alterations already made.\n\n\n MOVE Command (Short Form:  MOV)\n\n MOVE <range> TO \u00bb<lineno1>|END\u00ba  \u00ddBY  <lineno2>\u00a8  \u00ddMERGE\u00a8\n     \u00dd<list options>\u00a8\n\n This command moves a specified  <range>  from  one  part  of  the\n active  file  to  another.   It  is  essentially  a  COPY command\n followed by a DELETE command, where  the  old  instances  of  the\n copied lines are deleted.  See Section III.D.  for more about the\n MOVE command.\n\n If <lineno2> is not specified, the line increment is a 1  in  the\n low-order digit position of <lineno1>.\n\n The special line number END is defined as DELTA higher  than  the\n current LAST.\n\n Any of the <LIST options> will list the line before <lineno1> and\n the new lines.\n\n <range> must be the first parameter.\n\n MERGE allows interleaving in the file, and must appear after  the\n <lineno2>.\n\n\n NUMBER Command (Short Form:  NUM)\n\n NUMBER \u00dd<range>\u00a8 \u00dd\u00ddBY <lineno2>\u00a8 | \u00ddTIMES <lineno3>\u00a8\u00a8 \u00dd<range>\u00a8\n\n This allows you to have your entire file renumbered.  See Section\n III.\n\n <lineno1> is the new number for the first line in the  file.   If\n it is not specified, 1.000 is used.\n\n <lineno2> is the increment to be used in deriving successive line\n numbers.  If it is not specified, the current value of the global\n parameter DELTA is used.\n\n <lineno3> is a scale factor that multiplies each of the  existing\n line numbers to form the new line numbers.\n\n <range> may be used to limit the numbering to an  explicit  range\n of lines.\n1SUMMARY OF COMMANDS                                                VII - 18\n\n\n POINT Command (Short Form:  POI or P)\n\n POINT \u00dd<range>\u00a8 \u00ddEXEC\u00a8 \u00ddNOLIST\u00a8\n\n POINT functions exactly the same as LIST except that  it  updates\n the  current  line  pointer  (*)  as  it lists a line.  The POINT\n command has all the options of the LIST  command  plus  a  NOLIST\n option   which  sets  *  without  listing  any  lines.   This  is\n especially useful in EXEC files.\n\n\n POINT <range> EXEC sets a separate current line pointer  for  the\n exec  file.   This  is distinct from the active file current line\n pointer, and these pointers may have different values.\n\n      COMMAND? POINT 6/10 EXEC\n\n will list lines 6 through 10 of the exec file and the  exec  file\n current  line  pointer  will  be set to 10 if line 10 exists.  If\n there is no line 10, the pointer will be set to the highest  line\n number less than 10.\n\n      COMMAND? POINT 6/10 NOLIST\n\n sets the current line pointer just the same in the same way,  but\n does not list lines 6/10.\n\n\n PUNCH Command (Short Form:  PUN)\n\n PUNCH \u00dd<range>\u00a8 \u00ddNUMBERED|INTEGER\u00a8 \u00ddACCOUNT aaaaaaa\u00a8 \u00ddBIN bb\u00a8\n     \u00ddEXEC\u00a8 \u00ddLIST\u00a8 \u00ddSC=c\u00a8 \u00ddID=aaa\u00a8 \u00ddDEST=destination\u00a8 \u00dd'title'\u00a8\n\n This command allows you to produce a punched  card  output  of  a\n <range>  in  the active file.  See Section  VI.B.  If you specify\n EXEC, the exec file will be punched.\n\n The ACCOUNT, BIN, SC, ID, DEST and 'title' options are  the  same\n as in the LIST OFFLINE command.\n\n If the NUMBERED or INTEGER option is specified, line numbers will\n be punched into columns 73-80 of the cards.\n\n LIST will produce an offline listing of the file that is  punched\n in the same job.\n1SUMMARY OF COMMANDS                                                VII - 19\n\n\n PUT Command\n\n PUT   \u00bbSPACE|DIRECTORY|DSNAMES\u00ba   \u00ddON   <volume>\u00a8   \u00ddCLEAR\u00a8\n     \u00ddAT <lineno1>\u00a8 \u00ddBY <lineno2>\u00a8 \u00dd<list options>\u00a8 \u00dd<show options>\u00a8\n\n This command will add to your active file  the  output  from  the\n corresponding  SHOW  command as it lists at the terminal.  The AT\n option indicates where the text  is  to  be  added,  and  if  not\n specified  END  is used.  The BY option indicates an increment by\n which the text is to be added.  If  this  is  not  specified  the\n current value of the global parameter DELTA is used.\n\n The PUT DIRECTORY and  PUT  DSNAMES  commands  have  all  of  the\n options of their respective SHOW commands.  The PUT SPACE command\n can only be used as the SHOW SPACE ON <volume>.\n\n     PUT DSN LIK DATA ON DCU207 SPA CLE AT .001 INT\n     PUT SPA ON DCU111\n     PUT DIR ON DCU209 FRO A THRU D\n\n\n READ Command (Short Form:  REA)\n\n READ \u00dd<lineno>\u00a8 \u00ddEXEC|DELETE\u00a8 \u00ddPROMPT <string>\u00a8\n\n The READ command with no options produces a prompt for a command.\n When the new command is entered, it is executed.  It is  designed\n to  be  used in exec files to allow you to enter commands without\n having to PAUSE execution.  READ <lineno> allows one  command  to\n be  read  and  executed from the active file, or the exec file if\n EXEC is specified.   If  the  DELETE  option  is  specified,  the\n command  will  be  erased  from the active file before execution.\n DELETE and EXEC  are  mutually  exclusive.   The  DELETE  feature\n allows  you  to build single WYLBUR commands in the <active> file\n and then execute the commands without having to change the <exec>\n\n See the CUCC User's Manual for a  more  detailed  explanation  of\n JCL, JOB card, ASP, accounting information, etc.\n file.\n\n The PROMPT <string> option, when used, causes the <string> to  be\n written at the terminal before READ'ing the command.\n\n\n RECATLG Command (Short Form:  REC)\n\n RECATLG <dsname> ON <volume> \u00ddUSER uuu\u00a8 \u00ddGROUP gg\u00a8\n\n The RECATLG command catalogs the specified data set in the system\n catalog.  The catalog is done whether the data  set  was  already\n cataloged  or not.  You may recatalog only data sets which belong\n to you or your  group.   The  USER  and  GROUP  options  are  for\n resetting  your  own  initials and GROUP if they have been set to\n another user or group with a SET command.  RECATLG may also be  a\n parameter in the SAVE command.\n1SUMMARY OF COMMANDS                                                VII - 20\n\n\n RELEASE Command (Short Form:  REL)\n\n RELEASE \u00bb<jobname> | aaa | *\u00ba\n\n This command allows a job in user hold to complete the  remaining\n ASP  DSPs  (e.g.,  CRBEOUT,  PRINT).   See  the  HOLD  and CANCEL\n commands in this section and Section VI.\n\n The option specified may be in the same form as  the  options  of\n the CANCEL command.\n\n You may RELEASE only jobs which begin with your  signon  INITIALS\n and are currently in hold status.\n\n\n RENAME Command (Short Form:  REN)\n\n RENAME <dsname> \u00ddON <volume>\u00a8 \u00ddUNCAT\u00a8 \u00ddUSER uuu\u00a8 \u00ddGROUP gg\u00a8\n     \u00ddSET\u00a8 TO <new dsname> \u00ddON <volume>\u00a8 \u00ddUSER uuu\u00a8 \u00ddGROUP gg\u00a8\n     \u00ddSET\u00a8 \u00ddCATLG|RECATLG|UNCATLG\u00a8\n\n or\n\n RENAME \u00dd<PDSname>\u00a8#<member> \u00ddON <volume>\u00a8 \u00ddUSER uuu\u00a8 \u00ddGROUP gg\u00a8\n     \u00bbTO|ALIAS\u00ba TO  <new membername> \u00ddON <volume>\u00a8\n\n The RENAME command allows you to rename any of your data sets  or\n PDS  members.   In addition, you may add aliases to a PDS member,\n so that you may refer to a member by more than one name.\n\n The  ON  <volume>  option  is  necessary  if  the  global  VOLUME\n parameter has not been set.  The USER and GROUP  options  may  be\n used  to  specify  your  signon USER and GROUP if these have been\n changed with SET USER or SET GROUP commands.  The CAT, RECAT, and\n UNCAT options perform the  same  functions  as  their  respective\n commands.   If  CAT  is  global  or  specified, then the original\n dataset is uncatlg'd.  The ALIAS option will add the  new  member\n as an alternative way of referring to the PDS member named.\n\n\n REPLACE Command (Short Form:  REP or R)\n\n REPLACE <range> \u00dd<list options>\u00a8 \u00ddDITTO\u00a8\n\n This allows you to replace the contents of any specified  <range>\n in the active file.  See Section III.B.\n1SUMMARY OF COMMANDS                                                VII - 21\n\n\n WYLBUR will prompt with successive line numbers in the  specified\n <range>,  and you may type in the new contents after each prompt.\n A (CR) causes that line not to be replaced.   This  is  continued\n until  the  range  of lines is exhausted.  DITTO causes the first\n prompt to be used to REPLACE all lines in the range.\n\n Alternatively, you may replace the contents of a single  line  by\n giving  the line number, followed by a single blank, and then the\n new contents of the line.\n\n The LIST or NOTEXT  option  will  list  the  line  before  it  is\n replaced  which  gives  you time to abort the command by pressing\n the (CR).  Do not use L for LIST as this parameter; L stands  for\n LAST.\n\n\n RESTORE Command (Short Form:  RES)\n\n RESTORE \u00ddCLEAR\u00a8\n\n The RESTORE command is used to move the current exec file to  the\n active  file so that editing can be done on the file.  The active\n file is cleared before the restore; the exec file is clear  after\n the restore.\n\n\n RUN Command\n\n RUN \u00dd<range>\u00a8 \u00dd<list options>\u00a8 \u00ddEXEC\u00a8 \u00ddID=aaa\u00a8 \u00ddDEST=destination\u00a8\n\n This command allows you to put the active file into the job input\n stream.  See Section VI.C.\n\n All JCL required to run the job must be contained  in  the  file.\n The  first  line  in  the <range> must be a job card.  If the job\n name field on the job card is blank, WYLBUR will create a  unique\n job name consisting of the initials, group and a sequence number.\n If  the  range  contains  multiple  job  cards, multiple jobs are\n submitted.\n\n The option NUMBERED or INTEGER will cause the line numbers of the\n <range> to appear in the job output as sequence numbers.\n\n The ID and DEST options are the  same  as  in  the  LIST  OFFLINE\n command.\n1SUMMARY OF COMMANDS                                                VII - 22\n\n\n SAVE Command (Short Form:  SAV or S)\n\n The SAVE command is used to save user data from the  active  file\n in  an  external data set.  You may save data only in WYLBUR data\n sets which belong to you  or  to  your  group.   See  Section IV.\n for  more about the SAVE command.  The format of the SAVE command\n is:\n\n SAVE <dsname> \u00ddUSER uuu\u00a8 \u00ddGROUP gg\u00a8 \u00ddON <volume>|CATLG\u00a8\n     \u00ddSCRATCH|REPLACE\u00a8 \u00ddNUMBERED|INTEGER\u00a8 \u00ddCATLG|RECATLG|UNCATLG\u00a8\n     \u00ddCLEAR\u00a8 \u00ddEDIT|LRECL=nnn|CARD|PRINT\u00a8 \u00ddLINES <range>\u00a8\n+             ____\n     \u00ddSET|NOSET\u00a8 \u00dd(n)\u00a8 \u00ddSEQFLD=(\u00bbEND|pos\u00ba\u00dd,len\u00a8)\u00a8 \u00ddNOPOINT\u00a8\n+         _____\n\n The optional operands contain keywords  and  may  appear  in  any\n sequence.   The  dsname  operand  is required and is described in\n Section VIII.  See also the description of  the  USE  command  in\n this section.\n\n ON <volume> specifies the volume name on which the data set is to\n be saved.  It is optional if you have previously entered a volume\n name via the SET VOLUME command.   As  with  USE,  \"ON  <volume>\"\n specified in the SAVE command overrides any previously set volume\n name.   \"ON  CATLG\"  may  be used in the SAVE command only if the\n data set is a cataloged PDS or if the data set to be SAVEd is  to\n replace  a  cataloged sequential data set on the same volume.  ON\n CATLG is assumed if the <dsname> is a standard WYLBUR library and\n the volume information is not supplied from any source.  You  may\n SAVE  only a portion on the active file by specifying an explicit\n range with the LINES option.\n\n If you use the SET option, WYLBUR  will  retain  the  prefix  and\n member fields used in the command.  This SET is identical to that\n in  the  USE  command except that NOSET is the default option for\n SAVE.\n\n The format operand specifies the form in which the data is to  be\n saved.   EDIT  is  the  default  value for the SAVE command.  The\n other options are permitted when you specify  a  sequential  data\n set  but if a PDS member is specified, a warning message will ask\n if you want the format of the entire PDS changed.   Any  response\n other  than  YES  or OK will abort the SAVE.  This is because all\n members  in  the  pre-allocated  PDS  are  in  the  same  format.\n However, CARD format (LRECL=80) is assumed if NUMBERED,  INTEGER,\n SEQFLD, or NOPOINT is specified without any explicit format.\n1SUMMARY OF COMMANDS                                                VII - 23\n\n\n If any format other than EDIT is specified, the records are saved\n in a fixed blocked data set (RECFM=FB).  If the  records  in  the\n active  file  are  shorter  than  the  specified  LRECL, they are\n right-padded with blanks.  If the records  are  longer  than  the\n specified LRECL they are truncated at the right.  In either case,\n the  blocking factor may be specified as (n) in the SAVE command;\n in other words the data set BLKSIZE will  be  LRECL*n.   See  the\n User's Manual for a further explanation.\n\n\n When a fixed block data set is saved, WYLBUR  normally  does  not\n place  line numbers in the records.  When the file is used again,\n it is  renumbered.   The  NUMBERED  option  specifies  that  line\n numbers should be saved in the record.\n\n The NOPOINT option assumes the NUMBERED option and specifies that\n the line numbers should be put in the records without  a  decimal\n point or zero suppression.\n\n The SEQFLD option is used to change the normal position or length\n of the line numbers in the saved records.  The normal position is\n the last eight positions of each  record  (SEQFLD=(END,8)).   Any\n column  position  (pos)  and any length (len) less than 10 can be\n specified.  Line numbers are truncated on the left  to  the  size\n specified  without  checking for loss of digits.  The parentheses\n can be omitted if the length is not changed.\n\n WYLBUR will not permit you to SAVE a data set or a  member  of  a\n PDS  with a duplicate name on the same volume or in the same PDS.\n Should you attempt to do this, WYLBUR asks if you  want  the  old\n data  set or member to be replaced with the new data.  If you are\n aware of this condition when you enter the SAVE command, you  may\n pre-empt  this dialogue by specifying SCRATCH or REPLACE.  When a\n sequential data set is replaced, the old data  set  is  scratched\n before  the  new  data  is  saved.  However, when a PDS member is\n replaced, the new member is added to the PDS and the directory is\n updated after the new member has been written.\n\n You may specify that the system catalog the data set after it has\n been saved so that you do not have to remember the volume name on\n which it has been saved.  This is done with  the  CATLG  operand.\n If  the specified data set name already exists in the catalog you\n are informed.  If you want to save the data set on a volume other\n than the one on which it is catloged, you must  use  the  RECATLG\n command.   This  can  be  pre-empted  by  typing  RECATLG  in the\n command.  In that case the system will catalog the  data  set  on\n the  new  volume whether or not it is already cataloged.  RECATLG\n does not scratch the old data set.  CATLG and RECATLG are ignored\n when ON CATLG is specified for the volume.\n\n You may uncatalog the data set after SAVE by specifying UNCATLG.\n1SUMMARY OF COMMANDS                                                VII - 24\n\n\n SCRATCH Command (Short Form:  SCR)\n\n This command allows you  to  scratch  any  <external  file>  that\n belongs to you or your group.  See Section IV.B.\n\n SCRATCH <dsname> \u00ddON <volume>|CATLG\u00a8 \u00ddUSER uuu\u00a8 \u00ddGROUP gg\u00a8\n     \u00ddSET|NOSET\u00a8 \u00ddUNCATLG\u00a8 \u00ddPDS\u00a8\n+         _____\n\n\n\n A cataloged sequential data set will be scratched and uncataloged\n if UNCATLG is specified or if the data set  is  referenced  using\n CATLG.   Only  a  sequential  data  set  or  members of a PDS can\n normally be scratched.  If you want to scratch an entire PDS, you\n must specify the PDS operand.  If this is not specified  and  the\n <dsname>  is a PDS, a prompt will be given to ask if you want the\n entire PDS scratched.  Any response other than  YES  or  OK  will\n abort  the  command.   The  USER and GROUP options may be used to\n reset those fields to your own initials and account if necessary.\n\n There are also SCRATCH  options  on  the  SHOW  DIRECTORY|DSNAMES\n commands which cause a SCRATCH?  prompt after the listing of each\n title.\n\n ON CATLG is assumed if volume information is not  specified  from\n any  source  and  <dsname> is a standard WYLBUR library.  The SET\n option will set the prefix and member fields to those used in the\n command.\n\n\n SET and SHOW Commands\n\n These commands are used to establish and display the  values  for\n the global parameters and other factors that are in effect during\n a session.  Some global parameters are discussed in Section II.A.\n and some such as SET VOLUME are discussed throughout Sections III\n and IV.  Most are introduced here.\n\n\n SET BACK, SET NOBACK, SHOW BACK\n\n The SET BACK command alters the function of  the  backspace  key.\n An  upper  case  backspace  (a  shift and backspace) will enter a\n backspace in the file.  This is handy for getting an underline in\n the file.  A lower case backspace continues to erase the previous\n character,  just like  any  backspace  does  when  NOBACK  is  in\n effect.\n\n SET NOBACK returns the backspace key to its usual function.\n\n SHOW BACK tells which option is in effect.\n1SUMMARY OF COMMANDS                                                VII - 25\n\n\n SET BREAK, SET NOBREAK, SHOW BREAK, SHOW NOBREAK\n\n The SET NOBREAK command will allow no  messages  to  be  received\n until  you  hit  (CR)  or  (ATTN).  The sender's keyboard will be\n locked until the message is received.  The sender can  abort  the\n TO  command  by  hitting  (ATTN)  any  time  before  the keyboard\n unlocks.  If the message is sent to a terminal that does not have\n the BREAK hardware feature and NOBREAK is not set,  the  sender's\n terminal  will  unlock  whether  or  not the message is received.\n This will usually result in the message being lost.\n\n The SET  BREAK  command  allows  messages  to  interrupt  you  at\n anytime, except during a LIST CLEAN (See the LIST command above).\n\n SHOW BREAK will show which option is currently in effect.\n\n SHOW NOBREAK will display a list of lines which have this  option\n currently in effect.\n\n\n SET CRT, SET NOCRT, SHOW CRT, SHOW NOCRT\n\n The SET CRT and SET NOCRT commands are legal  only  for  CRT-type\n terminals (e.g., Hazeltines and teletypes), and will set or unset\n the  paging option described below.  CRT is automatically set for\n users who signon using  a  terminal  id  of  Hnn  at  a  CRT-type\n terminal.\n\n SHOW CRT or SHOW NOCRT will show which  option  is  currently  in\n effect.\n\n When NOCRT is in effect and a listing of a range longer than  the\n screen  size  (27 lines) is being done, the listing will flow off\n the top of the screen until the listing is over.  When CRT is  in\n effect,  however,  a  listing will pause when the screen has been\n filled and WYLBUR will prompt with a colon (:).   At  this  point\n you may respond with any of the following:\n\n (CR) -- The screen is erased and the listing is  continued  until\n the screen is filled again.\n\n (ATTN) -- The command is aborted.\n\n (CTRL) 'E' -- This does the same thing  as  (CR),  but  does  not\n clear the screen first.\n\n a 3-digit number, followed by (CR) or (CTRL)  'E'  --  This  will\n continue  listing that number of lines before the next :  prompt.\n If the number is greater than 256 the number of lines listed will\n be the remainder of dividing that number by 256.\n\n    :258(CR)\n    :514(CTRL)E\n1SUMMARY OF COMMANDS                                                VII - 26\n\n\n will both list the next two lines.  The first example will  clear\n the  screen; the last will add the two lines at the bottom of the\n screen.  The number must be  an  integer  less  than  1000.   The\n default value is CRT.\n\n\n SET CURRENT \u00dd<lineno>\u00a8 \u00ddEXEC\u00a8 , SHOW CURRENT \u00ddEXEC\u00a8\n\n SET CURRENT sets the  <current  line  pointer>  to  the  <lineno>\n specified.   SET  CURRENT 80 would set the <current line pointer>\n of the active file to 80.  SHOW CURRENT is actually just  one  of\n the  possibilities of the SHOW <symbolic line number> command.  *\n may be used in place of CURRENT.  The use of the EXEC  option  in\n either  command  will set or show the * for the exec file instead\n of the active file.\n\n\n SET DELTA, SHOW DELTA\n\n      COMMAND? SET DELTA = <lineno> (CR)\n\n This sets the default value of the line number increment, DELTA.\n\n <lineno> may be any value between 0.000 and 99999.999  inclusive.\n DELTA has a signon value of 1.000.\n\n\n SET ESCAPE, SHOW ESCAPE\n\n SET ESCAPE c\n\n This command sets the preprocessor escape character.  If c  is  a\n special character (e.g., =,()'\" or blank) it must be written as a\n <string> (e.g., enclosed in quotes).  Refer to Section V.\n\n\n SET ESCAPE (CR)\n\n This command unsets the escape character.\n\n SHOW ESCAPE  displays  the  current  escape  character.   For  an\n explanation of the use of the escape character, see Section V.\n\n\n SET EXEC, SHOW EXEC\n\n SET EXEC \u00ddTERSE|VERBOSE\u00a8 \u00ddLOG|NOLOG\u00a8\n\n The SET command can be used to govern the format of the  messages\n which appear on the terminal in response to an EXEC command.\n1SUMMARY OF COMMANDS                                                VII - 27\n\n\n SHOW EXEC \u00ddTERSE|VERBOSE\u00a8 \u00ddLOG|NOLOG\u00a8\n\n This command may be used to  show  which  of  these  options  are\n currently  in  effect.   The defaults are VERBOSE and LOG.  TERSE\n suppresses reprinting of exec lines with  preprocessor  SKIP  and\n ESC characters, and NOLOG suppresses printing of each line in the\n exec file as it is executed.\n\n The SHOW can be used to display single lines in the exec file.\n\n SHOW EXEC \u00dd<lineno>|RETRY\u00a8\n\n If <line number> is specified, the contents of that line will  be\n listed.  SHOW EXEC RETRY lists the line that would be executed on\n an EXEC RETRY command.  This was the line last executed.\n\n\n SET GROUP, SHOW GROUP\n\n       SET GROUP gg (CR)\n\n The SET GROUP command allows you  to  specify  that  the  default\n group  gg  is to be used in forming a <dsname>.  At signon, GROUP\n is set to the group id typed in response to the ACCOUNT?  prompt.\n\n       SET GROUP (CR)\n\n This form resets GROUP to the signon value.  The current value of\n GROUP can be displayed at any time with SHOW GROUP or SHOW NAME.\n\n\n SET KEYWORD\n\n The SET KEYWORD command safeguards against  the  unauthorized  or\n accidental misuse of an account number.  After you set a keyword,\n WYLBUR  will  check  for it in the initial sign-on dialogue every\n time you sign on with your initials and account number.\n\n      COMMAND? SET KEYWORD KKK (CR)\n      OLD KEYWORD? MMM (CR)\n+                  GGG\n\n If the new keyword is omitted, WYLBUR will ask  for  it.   WYLBUR\n will always prompt for the old keyword.  To end keyword checking,\n respond with a carriage return to the \"NEW KEYWORD?\" prompt.\n\n      COMMAND? SET KEYWORD (CR)\n      OLD KEYWORD? MMM\n+                  GGG\n      NEW KEYWORD? GGG (CR)\n+                  MMM\n\n The old  and  new  keywords  are  overstruck  as  in  the  signon\n procedure for protection.\n1SUMMARY OF COMMANDS                                                VII - 28\n\n\n SET LENGTH, SHOW LENGTH\n\n      COMMAND? SET LENGTH n (CR)\n\n The LENGTH is the number of characters which may be in  any  line\n of  text.   If  you type a line of text containing more than this\n number of characters, WYLBUR will accept the  line  but  issue  a\n warning message that you have exceeded the limit.\n\n n may be any integer between 1 and 133 inclusive.\n\n LENGTH has a signon default value of 72.\n\n\n SET MEMBER, SHOW MEMBER\n\n      COMMAND? SET MEMBER <member name> (CR)\n\n This command is used to set the default member name that will  be\n used  to  form  a  <dsname>.  The <member name> specified may not\n exceed 8 characters.  If the <member name> is omitted, it is  set\n to  null.   At  signon,  it is set to null.  The current value of\n MEMBER can be shown at any time with SHOW MEMBER or SHOW NAME.\n\n\n SET MSGOFF, SET MSGON, SHOW MSGOFF, SHOW MSGON\n\n The SET MSGOFF command will allow only operator  messages  to  be\n received at your terminal.  When someone else tries to send you a\n message,  they  will receive a message explaining that you do not\n want to receive messages at this time and their TO  command  will\n be aborted.\n\n SET MSGON will unset this feature.  This is the signon condition.\n\n SHOW MSGOFF will display a list of those lines which have  MSGOFF\n in effect.\n\n SHOW MSGON will show which option is currently in effect.\n\n\n SET NAME, SHOW NAME\n\n SET NAME \u00dd<dsname>\u00a8 \u00ddUSER uuu\u00a8 \u00ddGROUP gg\u00a8\n\n The SET NAME command allows you to set the values of  the  GROUP,\n USER,  PREFIX, and/or MEMBER fields in one command.  The <dsname>\n is formed in the usual way except that the default PREFIX is null\n rather than LIB (See <dsname> and  the  description  of  the  USE\n command).   SHOW  NAME  is  used to display the current values of\n GROUP, USER, PREFIX, and MEMBER.\n1SUMMARY OF COMMANDS                                                VII - 29\n\n\n SET NOTIME, SET TIMEOUT, SHOW NOTIME, SHOW TIMEOUT\n\n The SET NOTIME command will prevent WYLBUR from logging  you  off\n when  there  has  been 20 minutes of inactivity at your terminal.\n After 10 minutes of inactivity,  WYLBUR  gives  a  warning.   The\n warning  is  repeated  5  minutes  later.   If  there is still no\n response within 5 minutes after the second warning,  WYLBUR  will\n signoff   the  terminal.   An  active  file  will  be  saved  and\n catologued, provided there is space available  to  do  so.   This\n command  should  be  used with care since you will be charged for\n all the time that you are signed on.  See Section I.G.\n\n SET TIMEOUT will unset this feature.\n\n SHOW NOTIME and SHOW TIMEOUT will display a listing of the  lines\n which  have the specified parameter currently in effect.  TIMEOUT\n is the default signon value.\n\n\n SET PREFIX, SHOW PREFIX\n\n      COMMAND? SET PREFIX <string> (CR)\n\n This command is used to set  the  prefix  that  can  be  used  in\n building a <dsname>.  In this command <string> is not enclosed in\n quotes.   If  <string> is omitted, the prefix is set to null.  At\n signon, the prefix is set to null.\n\n      COMMAND? SET PREFIX *<string> (CR)\n\n This form sets the prefix to a concatenation of the old value and\n <string>.  SHOW PREFIX or SHOW NAME  can  be  used  to  show  the\n current value of PREFIX.\n\n\n SET RESCAN, SHOW RESCAN\n\n SET RESCAN n\n\n This command sets the rescan counter  to  the  number  specified.\n The  rescan  counter  indicates  the  maximum  number  of times a\n command will be scanned by the preprocessor for skip  and  escape\n characters  before  it  is  executed.  For further details on the\n rescan feature of the preprocessor, see Section V.\n\n SHOW RESCAN displays the current rescan count.  The signon  value\n is 5.\n1SUMMARY OF COMMANDS                                                VII - 30\n\n\n SET SKIP, SHOW SKIP\n\n SET SKIP c\n\n This command sets the preprocessor skip character.   If  c  is  a\n special character (e.g., =,()'\" or blank) it must be written as a\n <string>.\n\n SET SKIP (CR)\n\n This command unsets the skip character.\n\n SHOW  SKIP  displays  the  current  skip   character.    For   an\n explanation of the use of the skip character, see Section V.\n\n\n SET SLOWLIST, SET FASTLIST, SHOW SLOWLIST, SHOW FASTLIST\n\n SET SLOWLIST keeps WYLBUR from using  any  tabs  when  listing  a\n file.\n\n SET FASTLIST allows WYLBUR to use the tabs.  Either SHOW SLOWLIST\n or SHOW FASTLIST will display the  option  currently  in  effect.\n FASTLIST  is  the  default  value  at signon.  Users can use this\n feature if they wish to list a few lines that were  created  with\n tabs without having the terminal actually tab.  This is useful in\n checking the accuracy of the file.\n\n\n SET TABS, SHOW TABS\n\n SET TABS \u00ddt1,t2,...\u00a8 \u00ddNOVERIFY\u00a8\n\n This lets you set  tabs.   WYLBUR  will  prompt  with  directions\n telling  you  what  to  do.   If no tabs have been set, or if you\n press the tab key more times than there are tabs set, WYLBUR will\n not process the line  and  will  issue  an  error  message.   See\n Section II.A.  for more about the SET TABS command.\n\n Tabs are used when possible to speed up  listings  taken  at  the\n terminal.  See the SET SLOWLIST command.\n\n SHOW TABS \u00ddVERIFY\u00a8\n\n The current tab settings can be  shown  by  using  SHOW  TABS  or\n verified by using SHOW TABS VERIFY.\n1SUMMARY OF COMMANDS                                                VII - 31\n\n\n SET TERMINAL, SHOW TERMINAL\n\n SET TERMINAL lnn\n\n This command resets the terminal ID  initialized  in  the  signon\n procedure.   SHOW TERMINAL displays the current terminal ID.  Any\n characters automatically set when  the  user  signed  on  with  a\n terminal id of either Ann or Hnn will not be affected.\n\n\n SET TERSE, SET VERBOSE\n\n The SET TERSE command shorten the WYLBUR command prompt  COMMAND?\n to   ?.   In  addition,  all  <dsnames>  will  be  listed  in  an\n abbreviated form instead of  the  full  <dsname>.   All  commands\n containing  the  pre-processor escape or skip characters will not\n have the processed command listed.\n\n SET VERBOSE puts it back.  The signon default is VERBOSE.\n\n\n\n\n SET UPLOW, SET UPPER, SHOW CASE\n\n These  commands  govern  the  case  of   alphabetic   characters.\n Normally, all alphabetic characters are recognized as upper case.\n If  UPLOW  is specified, full upper and lower case facilities are\n available to you.  If UPLOW is in effect, you may revert  to  the\n normal  case  (all alphabetic characters in upper case) by giving\n the SET UPPER command.  The SET UPLOW command has no effect on  a\n Hazeltine  terminal.   A  file containing lower-case letters will\n list as upper case letters on a Hazeltine terminal.  If the  same\n file  is  listed  offline,  UPLOW  must  be specified in the LIST\n command or the lower case letters will print as blanks.\n\n\n SET USER, SHOW USER\n\n      COMMAND? SET USER uuu (CR)\n\n The SET USER command allows you to specify that the default  user\n uuu  is to be used in forming a <dsname>.  At signon, USER is set\n to the INITIALS used in the LOGON procedure.\n\n      COMMAND? SET USER (CR)\n\n This form resets USER to the signon value.  The current value  of\n1SUMMARY OF COMMANDS                                                VII - 32\n\n\n SET VALUE, SHOW VALUE\n\n These commands are used to SET or SHOW the current values of  the\n preprocessor variables or expressions.\n\n SET VALUE variable=expression\n\n Variable is any preprocessor variable (an S, W or N, followed  by\n a digit).  Expression is a preprocessor 'CEXPR' (see Section V.).\n\n SHOW VALUE expression(s)\n\n Expression(s) may be one or more preprocessor 'CEXPR's.\n\n      COMMAND? SET VALUE N1=628\n      COMMAND? SET VALUE S3='MMMM'\n      COMMAND? SET VALUE W6=JOBNO\n      COMMAND? SHOW VALUE  N1 W6 S3\n      628 123.000 'MMMM'\n\n\n SET VOLUME, SHOW VOLUME, SHOW VOLUMES\n\n The SET/SHOW VOLUME commands are used to set and show the default\n volume which will be used if  no  other  is  specified  with  the\n following commands:  USE, SAVE, SCRATCH, COPY FROM, SHOW DSNAMES,\n and  SHOW DIRECTORY.  Alternatively, ON <volume> can be specified\n with each command that requires it.\n\n SHOW VOLUMES gives a list of all volumes that may be accessed  by\n you,  all volumes on which saves can be performed and all volumes\n on which data sets may reside temporarily.\n\n\n SHOW CATLG\n\n The SHOW CATLG command is used  to  display  a  list  of  dsnames\n and/or  index  pointers below a given index node.  Only one level\n of index name may be listed in a single command.  The  format  of\n the command is:\n\n SHOW CATLG \u00ddFOR \u00bb*|index pattern\u00ba\u00a8 \u00ddUSER uuu\u00a8\n     \u00ddGROUP gg\u00a8 \u00ddUNCATLG\u00a8 \u00ddSET|NOSET\u00a8 \u00ddNOTYPE\u00a8\n+                              _____\n     \u00dd\u00bbFROM|EXCLUDE\u00ba <string1>\u00a8 \u00dd\u00bbTHRU|TO\u00ba <string2>\u00a8\n\n The \"index pattern\" in the FOR operand  specifies  the  level  or\n levels  of  index  used  to search the catalog.  Only those names\n found at the next level  of  index  below  the  pattern  will  be\n listed.   If  the FOR option is omitted, the SAVED USER and GROUP\n are used to form the index pattern.\n\n    SHOW CAT FOR @EB.&ABC FROM GHI TO STU\n\n1SUMMARY OF COMMANDS                                                VII - 33\n\n\n Normally each entry also  shows  the  type  of  entry  and  other\n pertinent  information  for that entry such as the volume name on\n data set entries.  This information may be  suppressed  with  the\n NOTYPE  option.   The  UNCATLG  option  performs the same general\n function for SHOW CATLG as SCRATCH does for SHOW DSNAMES; namely,\n WYLBUR lists every data set name that belongs to you and asks  if\n if  should be uncataloged.  All other operands are similar to the\n SHOW DSNAMES command.\n\n\n SHOW COLUMNS \u00ddUNNUMBERED\u00a8\n\n This command will produce a line containing column  numbers.   It\n is  usually  used to decide where to set the tabs or what columns\n to specify in another command.\n\n The UNNUMBERED option will display the columns as they  would  be\n positioned in a LIST UNNUMBERED command.\n\n      COMMAND? SHOW COLUMNS\n               12345678...\n      COMMAND? SHOW COLUMNS UNNUMBERED\n      12345678...\n\n SHOW COUNT\n\n This command displays the number of users currently signed on the\n system.\n\n\n SHOW DATE\n\n This command may be used to see the date in two forms -- MM/DD/YY\n and the julian date -- as well as the time of day.\n\n\n SHOW DIRECTORY\n\n The SHOW DIRECTORY command produces a list of member  names  from\n the specified PDS.  The format of the command is:\n\n SHOW DIRECTORY \u00ddIN <dsname>\u00a8 \u00ddUSER uuu\u00a8\u00ddGROUP gg\u00a8 \u00ddON <volume>\u00a8\n     \u00dd\u00bbFROM|EXCLUDE\u00ba \u00bb<string1>|#\u00ba\u00a8 \u00dd\u00bbTHRU|TO\u00ba \u00bb<string2>|#\u00ba\u00a8\n     \u00ddSCRATCH\u00a8 \u00ddALL\u00a8 \u00ddSET|NOSET\u00a8\n+                         _____\n1SUMMARY OF COMMANDS                                                VII - 34\n\n\n If the \"IN <dsname>\" operand is omitted, the default name LIB  is\n assumed   for   the   current   USER   and   GROUP  values.   The\n FROM/THRU/EXCLUDE/TO operands function identically to  their  use\n in  the  SHOW  DSNAMES  command except that for this command they\n refer to member names rather than data  set  names.   IF  \"#\"  is\n specified  for either string, the current value in MEMBER is used\n for that string.  The SCRATCH operand is also identical  to  that\n for  SHOW  DSNAMES  except  that it applies to members instead of\n data sets.  The SET option sets the PREFIX to <dsname> and unsets\n the MEMBER name.\n\n Usually, only the member names are shown in the  resulting  list.\n However,  if  you  want to see the other information contained in\n the PDS  directory,  specify  ALL.   This  causes  a  hexadecimal\n display of the other directory information.\n\n      COMMAND? SHOW DIRECTORY ALL\n      WYL.UR.ABC.LIB\n      FILE1     00020102  00003068\n      FILE2     00030102  00003072\n      FILE3     00020182  00003068\n\n The seventh digit of the first set of numbers, if it is equal  to\n eight, indicates an alias.  FILE3 is thus an alias of FILE1.  The\n fifth  digit  of  the second group indicate the year the file was\n created, in this case, 1973, and the next three  digits  indicate\n the  day  of  the year.  FILE1 and FILE2 were created on the 68th\n day of 1973; FILE3 was created on the 72nd day of 1973.\n\n\n SHOW DSNAMES\n\n The SHOW DSNAMES command produces a list of DSNAMEs  on  a  given\n volume  which satisfy the criteria specified in the command.  The\n format of this command is:\n\n SHOW DSNAMES \u00ddLIKE <dsname>\u00a8 \u00ddUSER \u00bbuuu|ALL\u00ba\u00a8 \u00ddGROUP \u00bbgg|ALL\u00ba\u00a8\n     \u00dd\u00bbFROM|EXCLUDE\u00ba \u00bb<string1>|*\u00ba\u00a8 \u00dd\u00bbTHRU|TO\u00ba \u00bb<string2>|*\u00ba\u00a8\n     \u00ddON <volume>\u00a8 \u00ddSET|NOSET\u00a8 \u00ddSKIP n\u00a8\n+                       _____\n     \u00ddSCRATCH\u00a8 \u00ddDATED\u00a8 \u00ddTYPE\u00a8 \u00ddSPACE|SIZE|TRACKS\u00a8\n\n\n If the command has no operands, WYLBUR will list all WYLBUR  data\n sets  which  belong  to the group and user specified in the SAVED\n GROUP and SAVED USER fields.  The volume will be taken  from  the\n ON  <volume> field or from the last SET VOLUME command (CATLG may\n not be used).  To display a list of data sets for other users  or\n groups  or  both, use the USER or GROUP options.  To look at data\n set names for all users or groups, or both, specify  ALL  instead\n of a user or group id.\n1SUMMARY OF COMMANDS                                                VII - 35\n\n\n The LIKE operand is used to construct a pattern against which all\n data set names on the specified volume are matched.   Only  those\n data set names beginning with the specified pattern are selected.\n The  operand  is  similar  to the standard dsname operand used in\n other commands except that there is no LIB default.\n\n You may limit the range of the displayed list by specifying  FROM\n and/or  THRU.   FROM  <string1>  specifies the lower limit of the\n displayed list and THRU  <string2>  specifies  the  upper  limit.\n Either  or  both  may  specify  *  to use the current PREFIX.  If\n PREFIX is null, and * alone is specified, the value of the string\n is also null; i.e., the operand is ignored.  Both  <string1>  and\n <string2>  refer  to that part of the WYLBUR DSNAME which appears\n after the pattern  constructed  from  the  LIKE  operand  or  the\n default  pattern.   Thus, if GROUP and USER are set to EG and ABC\n respectively, the command:\n\n\n                SHOW DSNAMES LIKE XYZ FROM F THRU G\n\n would cause a display of all data set names of the form:\n\n           WYL.EG.ABC.XYZFxxxxx  through  WYL.EG.ABC.XYZGxxxxx\n\n\n You may reverse this range by specifying EXCLUDE instead of FROM.\n In this case, all data sets except those  between  the  specified\n limits are displayed.\n\n To list the names of data  sets  other  than  WYLBUR  data  sets,\n specify  the  dsname  in  quotes  or  preceded  by  $ in the LIKE\n command.  The quotes or $ perform the same  function  as  in  the\n dsname operand of other commands.\n\n If the FROM operand is omitted, the range starts from the  lowest\n data  set  name  found.   If  THRU  is omitted, the range extends\n through the last data set name found.  If both are  omitted,  all\n data  sets  for the default pattern or specified LIKE pattern are\n listed.\n\n SET will  set  the  saved  PREFIX  and  MEMBER  fields  to  those\n specified in the command.\n\n You may also request that other information associated  with  the\n data  sets  be  displayed.  DATED gives you the date on which the\n data set was created and the date on which it was last  accessed.\n SPACE  means the amount of space occupied by the data set and the\n number of extents if not 1; TYPE information  consists  of  DSORG\n RECFM/LRECL/BLKSIZE  separated  by  slashes as indicated.  If the\n values are not valid, an asterisk appears instead.   EDIT  format\n data  sets are normally \"U/3520/3520\", PRINT format data sets are\n normally \"FB/133/3458\", and CARD format data  sets  are  normally\n \"FB/80/3520\".\n1SUMMARY OF COMMANDS                                                VII - 36\n\n\n If SCRATCH  is  specified,  WYLBUR  will  prompt  with  the  word\n \"SCRATCH?\"  and  require  a  response  after  every data set name\n listed which belongs to you.   A  yes  response  will  cause  the\n listed data set to be scratched.\n\n The command SHOW DSNAMES LIKE LIB SPACE will show how much  space\n has been used in the WYLBUR library.\n\n\n SHOW JOBNO\n\n This command produces the numeric portion of the  default  WYLBUR\n jobname to be assigned to the NEXT job submitted from your WYLBUR\n ID.\n\n      COMMAND? SHOW JOBNO (CR)\n      664 - NEXT JOBNO\n\n Note that this is different from the  preprocessor  command  SHOW\n VALUE  JOBNO.  The value of the preprocessor variable is a string\n whose value is the numeric portion (JOBNO)  of  the  default  job\n name  of the last job submitted from your WYLBUR ID, whereas SHOW\n JOBNO displays the default JOBNO for the next job submitted  from\n your  WYLBUR  ID.  The preprocessor value of JOBNO will always be\n one less than the other, they are incremented simultaneously when\n a command such as RUN, LIST OFFLINE, PUNCH, CONDENSE  or  SUGGEST\n is executed from your ID.\n\n\n SHOW LINES \u00ddALL\u00a8, SHOW LINE\n\n SHOW LINE gives you the line number and terminal number  for  the\n terminal you are using.  SHOW LINES produces a list of the status\n of  all active remote terminals or all remote terminals if ALL is\n specified.  SHOW USERS is a shortened form of this command.   The\n TO command can be used to send messages to any active line.\n\n\n SHOW LINE n, SHOW LINE uuu, SHOW LINE id\n\n These commands tell the status of a given line.  n  is  the  line\n number assigned to a terminal in the identification message typed\n at  the start of the sign-on process.  uuu is the set of initials\n you signed on with.  id is the terminal identification number.\n\n\n\n SHOW MESSAGE\n\n This command will show the current broadcast message.\n1SUMMARY OF COMMANDS                                                VII - 37\n\n\n SHOW FREE, SHOW MINFREE\n\n SHOW FREE gives a count of the free phone  lines  followed  by  a\n list of their WYLBUR line numbers.\n\n SHOW MINFREE also gives a count of the free phone lines and lists\n the current value of MINFREE.  MINFREE is a WYLBUR parameter  set\n by the operator.  It is the minimum number of free lines required\n before WYLBUR will honor the NOTIME option.\n\n      COMMAND? SHOW MINFREE\n      0 LINE(S) FREE, 5 MINFREE.  NOTIME NOT CURRENTLY HONORED.\n\n\n SHOW PAGES\n\n This command will print the number of <pages> in the active file.\n The size must be less than or equal to three if the  active  file\n is going to be used as an exec file.  The maximum number of pages\n is 294.\n\n\n SHOW RUN\n\n This command will show whether or not you are allowed  to  submit\n jobs at the present time.\n\n\n SHOW SIZE\n\n This command may be used to find the number of characters in each\n line of a specified range.  It can be helpful in finding lines to\n ALIGN.\n\n SHOW SIZE \u00dd<range>\u00a8 \u00ddOVER n|LENGTH\u00a8 \u00ddUNDER m|LENGTH\u00a8 \u00ddNOCOUNT\u00a8\n\n The default range is all.  The value of n may be any integer less\n than or equal to 133.  For example, SHOW SIZE OVER 72 would  list\n the  lines  with  over  72 characters in them, with the number of\n characters in each line.  m must be at least 2 greater than n  if\n both  are specified.  NOCOUNT is specified, only line numbers are\n printed.\n\n      COMMAND? SHOW SIZE\n          1.    -  45 CHARACTERS\n          2.    -  14\n          3.    -  45\n      COMMAND? SHOW SIZE 1/2 10/12 UNDER 60\n          1.    -  45 CHARACTERS\n          2.    -  14\n         10.    -  30\n         11.    -  53\n         12.    -  55\n      COMMAND? SHOW SIZE OVER LENGTH\n      NO LINES OVER 72\n1SUMMARY OF COMMANDS                                                VII - 38\n\n\n SHOW SPACE\n\n SHOW \u00bbSPACE|TRACKS\u00ba \u00ddGROUP|USER uuu\u00a8\n\n or\n\n SHOW  \u00bbSPACE|TRACKS\u00ba  ON    <volume>\n\n This command is used to show two distinct types  of  information.\n The  ON  <volume>  option  is  used to display the number of free\n tracks and <extents> available for all  users  on  the  specified\n volume.   Otherwise,  the  number  of tracks used by you, or your\n group if specified, will be displayed.  The  SHOW  SPACE  command\n does not show the size of any data sets.  The SHOW DSNAME command\n with the SPACE option must be used to show the size of individual\n data  sets  as well as the space used in a WYLBUR library.  SPACE\n and TRACKS are equivalent, and may be used interchangeably.\n\n\n SHOW <symbolic line numbers> \u00ddEXEC\u00a8\n\n This command displays the <symbolic line  number>  of  an  active\n file  or  an  exec  file  if  EXEC  is specified.  <Symbolic line\n number> may be:\n\n             FIRST      CURRENT or *\n             LAST       PREVIOUS\n             END        NEXT\n\n\n\n\n SHOW SYSTEMS\n\n This command shows the systems currently available under  MILTEN.\n Normally  WYLBUR, but only WYLBUR, will be available.  SHOW COUNT\n and SHOW LINES also show the systems as well as  how  many  users\n are on each.  See <SYSTEM?> and <recovery> in Section VIII.\n\n\n SHOW TIME\n\n This command will print out the date and time in  hours,  minutes\n and  seconds  and the current values for elapsed time and editing\n time.\n1SUMMARY OF COMMANDS                                                VII - 39\n\n\n SHOW USERS \u00dduuu\u00a8\n\n This  command  types  the  initials  of  all  signed  on   users.\n Specifying uuu will cause the list to begin with user uuu.\n\n      COMMAND? SHOW USERS\n      JCS CXL SXS JAG AXB PLR JZP RLS MUM - USERS\n      COMMAND? SHOW USERS AXB\n      AXB PLR JZP RLS MUM - USERS\n\n\n SUGGEST Command (Short Form:  SUG)\n\n SUGGEST \u00dd<range>\u00a8 \u00ddEXEC\u00a8 \u00ddACCOUNT aaaaaaa\u00a8\n\n With this command you may submit a file of  your  suggestions  to\n the CUCC staff members who maintain WYLBUR.  This command submits\n a  job  to  list offline the <range> of the active file or of the\n exec file if you use the EXEC option.  The SUGGEST will submit up\n to the first 50 lines of the file.  If the ACCOUNT option is  not\n specified,  the  job  will  be charged to the project number with\n which you signed on to TPMON.\n\n\n TO Command\n\n TO n message, TO id message, TO uuu message, TO OPR message\n\n These commands are used to send a message  to  another  terminal.\n The  n and id are used as in the SHOW LINE command.  uuu is a set\n of user initials.  The  TO  command  should  be  used  only  when\n absolutely   necessary  since  it  interrupts  the  work  of  the\n receiver.  See also the SET MSGOFF command, and the CLEAN  option\n on the LIST command.\n\n\n UNCATLG Command (Short Form:  UNC)\n\n UNCATLG <dsname> \u00ddUSER uuu\u00a8 \u00ddGROUP gg\u00a8\n\n The  UNCATLG  command  causes  the  specified  data  set  to   be\n uncataloged.   Only  data sets belonging to you or your group may\n be uncataloged.  The USER and GROUP options may be used to  reset\n those fields to your own initials and account if necessary.\n1SUMMARY OF COMMANDS                                                VII - 40\n\n\n USE Command (Short Form:  U)\n\n The USE command reads a copy of a direct  access  data  set  into\n your active file.  The general form for this command is:\n\n USE <dsname> \u00ddUSER uuu\u00a8 \u00ddGROUP gg\u00a8 \u00ddON <volume>\u00a8\n     \u00ddSET|NOSET\u00a8 \u00ddCLEAR\u00a8 \u00ddEDIT|LRECL=nnn|CARD|PRINT\u00a8 \u00ddNOPOINT\u00a8\n+     ___                 ____\n     \u00ddNUMBERED\u00a8 \u00ddSKIP mmmm\u00a8 \u00ddSEQFLD=(\u00bbEND|pos\u00ba \u00dd,len\u00a8)\u00a8\n\n The optional operands are all keyword operands and may appear  in\n any  sequence.   The <dsname> operand is positional and specifies\n the <dsname> of the data set to be read.  Names  of  WYLBUR  data\n sets  with  standard  WYLBUR  names  may  be  specified  in their\n entirety or in an abbreviated form using default  and/or  pre-set\n values.   The  full specification of this operand is discussed in\n Section VIII.\n\n The VOLUME operand tells WYLBUR the name  of  the  direct  access\n volume  on  which  the  data  set  resides.   If  the data set is\n cataloged in the system catalog, you may specify ON CATLG instead\n of the <volume> name.  When ON CATLG  is  specified,  the  system\n will tell you the <volume> name obtained from the catalog for the\n specified data set.  If the catalog is not used, \"ON <volume>\" is\n required  for  a  sequential  data set unless you have previously\n done a SET VOLUME command.  If \"ON <volume>\" is specified in  the\n command  it  overrides  any previously set <volume> name.  WYLBUR\n will prompt for the <volume> name if it is not  specified  for  a\n sequential data set.  For a WYLBUR <library>, ON CATLG is assumed\n if the <volume> is not specified.\n\n\n\n USE cannot be executed unless the active file is empty.  If there\n is an active file, the system will ask if it is ok to clear it in\n order to proceed with the USE.  You may pre-empt this dialogue by\n specifying CLEAR.  WYLBUR will then clear  the  active  file  and\n proceed.\n\n Normally, WYLBUR uses the  information  in  the  data  set  label\n (DSCB)  to determine how the data set was stored and how it is to\n be read.  However, if the DSCB has been altered, or if  you  wish\n to  read  the  data  set  in  a special way, you may override the\n information in the DSCB with the \"format\" operand.  If the record\n length (LRECL) of the data set is greater than 133 characters,the\n maximum record size for the working file, you must  override  the\n DSCB information with a number not greater than 133.  WYLBUR will\n read  fixed  length  records  (RECFM=F or FB) and variable length\n records (RECFM=V or VB) but not  \"spanned\"  records  (RECFM=VBS).\n Undefined  data  sets (RECFM=U) are assumed to be WYLBUR internal\n (EDIT) format data sets.  WYLBUR libraries and the WYLBUR  active\n file are always in EDIT format.\n1SUMMARY OF COMMANDS                                                VII - 41\n\n\n The  \"format\"  operand  may  take  one  of  four  values:   EDIT,\n LRECL=nnn, CARD, or PRINT.  EDIT specifies that the data has been\n saved in WYLBUR internal format.  LRECL=nnn  specifies  that  the\n data  set  is not in EDIT format and that the record length to be\n used in reading it is \"nnn\".  WYLBUR then treats the data set  as\n \"fixed blocked\" (RECFM=FB).  If the actual physical block size is\n not  an  integral multiple of nnn, any characters remaining after\n all possible lines of nnn characters have been extracted will  be\n ignored.   CARD  is  an abbreviation for LRECL=80 and PRINT is an\n abbreviation for  LRECL=133.   All  provisions  for  LRECL  apply\n equally  to  CARD  and PRINT.  The values LRECL=, CARD, and PRINT\n may be specified for any data set, but the user should  be  aware\n that  the  use  of  these  operands  may  produce some rather odd\n looking data if the data set being read does not actually contain\n fixed length records.\n\n You may specify that some number of records at the  beginning  of\n the  data  set  are  to  be  skipped.   The  operand  \"SKIP=mmmm\"\n specifies that the first mmmm records are to be ignored.\n\n\n\n When data sets are saved in EDIT format, the WYLBUR line  numbers\n are stored with the data.  However, this is normally not true for\n data  saved  in other formats.  Such data sets will be renumbered\n by WYLBUR (from 1.000 by current DELTA) when they are read.   For\n non-EDIT  data sets, the NUMBERED option assumes that each record\n has a line number in  it.   WYLBUR  uses  that  line  number  and\n deletes from the record those columns containing the line number.\n Although  the  line  numbers  can  be  either decimal or integer,\n integer line numbers will be assumed to  have  an  implied  three\n decimal  places.  The SEQFLD option is used to notify WYLBUR that\n the line numbers are at some position or length  other  than  the\n default  SEQFLD=(END,8).   Any starting column pos and any length\n len less than 10 can be specified.  If the length is not changed,\n the parentheses around the position field can be omitted.  SEQFLD\n assumes NUMBERED and both use the default LRECL in the DSCB.\n\n After the full DSNAME has been constructed and the entire command\n line has been scanned for  valid  syntax,  WYLBUR  will  normally\n retain  information  on  that  DSNAME  so  that  it  need  not be\n respecified in subsequent commands such as SAVE.  The SET operand\n saves the prefix and member name but it doesn't change  the  user\n or  group  values.   If  you  don't want this to be done, specify\n NOSET.\n\n\n1VIII.  DEFINITION OF TERMS                                       VIII - 1\n\n\n VIII.  Definition of Terms\n\n This section contains  the  definitions of  the  syntactic  types\n referred   to  in  Section  VII,  Summary  of  Commands,  plus  a\n definition of the special typewriter  keys.   All  terms  are  in\n alphabetical order.  Any terms enclosed in pointed brackets <...>\n are defined in this section.\n\n\n\n ACTIVE FILE\n\n An active file is a file which is being held in  core.   You  can\n make alterations and additions only to this file.  When it is not\n being  held  in  core  during  the actual execution of a command,\n parts of the active file are stored on a high-speed access drum.\n\n\n\n ASSOCIATIVE RANGE\n\n Associative range is a parameter in many of the commands.  It  is\n a  group  of  lines,  each  of which contains a certain series of\n characters (the <string>).  The range is specified  by  enclosing\n the  character string within quotation marks and indicating which\n lines (the <explicit range>) should be searched.  The form of  an\n associative range is:\n\n \u00dd\u00ac\u00a8<string> \u00ddm\u00dd/n\u00a8\u00a8 \u00dd(x,x,...,x/y)\u00a8 \u00ddIN <explicit range>\u00a8\n\n See Section III for a discussion on how to use associative range.\n\n The NOT character (\u00ac)  is  optional  and  defines  a  range  that\n consists of all lines in the <explicit range> that do not contain\n the  <string>.   The  m/n  parameter specifies the columns within\n which the string must be contained in any given  line.   If  only\n the  first  one  of  the  two  column positions is specified, the\n string must start in that column.  If m/n is omitted, the  entire\n line will be searched for the string.\n\n The  next  set  of  parameters,  which  must   be   enclosed   in\n parentheses, can be of two forms.\n\n                            X  or  X/Y\n\n These parameters restrict the  range  to  a  specific  subset  of\n lines,  namely,  those  whose ordinal positions in the set of all\n lines containing the string are given by x or x/y.  Thus (3)  and\n (3/7)  restrict  the  subset  to  the third and the third through\n seventh lines, respectively, of the <explicit range> in which the\n specified string occurs.\n\n1DEFINITION OF TERMS                                              VIII - 2\n\n\n If no modifiers are given, all lines containing the string  which\n are  in  the  specified  <explicit  range>  are  included  in the\n <associative range>.\n\n The IN phrase gives an <explicit range> in which  to  search  for\n the lines containing the string.\n\n The correct <associative range> to retrieve blank  lines  is  the\n null  string--''  or  \"\".   Associative ranges consisting of more\n than one blank, such as ' ' or \" \",  will  retrieve  lines  which\n have  the  specified  number of blanks and also have at least one\n non-blank character--blank lines will not be retrieved.\n\n\n\n ATTN Key\n\n When typed as other than the first  character  in  a  line,  this\n signals  that  WYLBUR  should  ignore the line.  However, see the\n MODIFY and EDIT commands in Section III for exceptions  to  this,\n as the ATTN key has extensive use in these commands.\n\n When typed as the first character in  a  response to  a  COMMAND?\n prompt, this key puts the user into COLLECT mode.\n\n Typed as the first character in an answer  to  any  prompt  other\n than  the  COMMAND?   prompt,  this  key  aborts  the command and\n returns to the command mode.\n\n If typed while WYLBUR is putting out  a  message  at  the  user's\n terminal, this suspends the printing of the rest of the message.\n\n The ATTN key causes an <exec break> if an <exec  file>  is  being\n used.\n\n\n\n Back-Space Key\n\n Back-spacing over any character typed by the user erases it  from\n the  computer's  memory.  This applies to command as well as text\n lines.\n\n An upper case backspace (a shift and a backspace)  will  enter  a\n backspace  into  the  file  and  will not erase material from the\n computer's memory if the SET BACK  command  is  in  effect.   For\n further  information,  see  Section I.D.\n1DEFINITION OF TERMS                                              VIII - 3\n\n\n Carriage Return\n\n This is the final entry of every line  that  does  not  end  with\n ATTN.   It  is the signal for WYLBUR to look at the line and take\n appropriate action.\n\n When given as the only response to a prompt  in  the  MODIFY  and\n EDIT  commands,  it signals that all modifications have been made\n to the line.\n\n\n\n COLLECT Mode\n\n This is the mode in which lines are entered into the active file.\n WYLBUR calculates and prompts successive line numbers.\n\n\n\n COMMAND Mode\n\n This is the mode in which WYLBUR accepts and executes commands.\n\n\n\n Comments on Command Lines\n\n The semicolon is used in WYLBUR to indicate the end of a command.\n Everything typed after  a  semicolon is ignored and may  be  used\n for  comments.   A  command  line that begins with a semicolon is\n accepted by WYLBUR as  a  comment  line.   <Exec  files>  can  be\n documented using the semicolon.  The COMMENT command is also used\n for  comments  and  should  not  be  confused  with this feature.\n COMMENT command lines in exec files appear in NOLOG mode  whereas\n comments following semicolons do not.  See the COMMENT command in\n Section VII.\n\n\n CURRENT LINE POINTER\n\n The <current line pointer> is a symbolic line number whose  value\n is  the  number of the last line edited (active file) or executed\n (exec file).  The <current line pointers> for the active file and\n exec file are distinct.\n\n The following commands will set the value of  the  <current  line\n pointer>:\n\n             CHANGE          JUSTIFY\n             COLLECT         MODIFY\n             COPY            MOVE\n             EDIT            POINT\n             SHOW SIZE\n\n1DEFINITION OF TERMS                                              VIII - 4\n\n\n Fetching a file with a USE command does not set the pointer.  Nor\n does an attempt to edit a void range.  The symbols *  or  CURRENT\n refer  to  the <current line pointer>.  Either symbol may be used\n in designating a <range> or a line.\n\n Sometimes the value of the <current line  pointer>  will  not  be\n set.  For example, if there is no active or exec file, there will\n be  no  current line pointer.  Two other <symbolic line numbers>,\n PREVIOUS and NEXT, are dependent  on  CURRENT  and  some  obvious\n restrictions  apply.   For instance, if the value of the <current\n line pointer> is the last line of a file, there is no NEXT.\n\n * may be used in place of CURRENT when used in a range, but  when\n used  in specifying a <dsname>, * means the currently set PREFIX,\n as in the command SAVE * REPLACE.\n\n The value of * is assumed to refer to the active file except when\n the EXEC option is specified in the command.  In that  case,  the\n exec file is assumed.\n\n The commands SET *, SHOW *, and POINT  are  associated  with  the\n <current  line  pointer> and may be used to display or change the\n value of it.\n\n\n\n DSNAME\n\n In general, all WYLBUR data set names have the form:\n\n                         WYL.gg.uuu.name\n\n where gg is a group identification, uuu  are  the  user  initials\n (WYLBUR  or  user  ID), and name is a name specified by the user.\n If the designated data set is a pre-allocated PDS  or  <library>,\n the assigned DSNAME is:\n\n                         WYL.gg.uuu.LIB\n\n Each member of this data set has the name WYL.gg.uuu.LIB(member).\n\n Data sets allocated from the group space pool  have  a  data  set\n name  with user ID of PUB.  Thus, data sets in this category have\n names of the form:\n\n                         WYL.gg.PUB.dsname\n\n and the group <library> is\n\n                         WYL.gg.PUB.LIB\n1DEFINITION OF TERMS                                              VIII - 5\n\n\n It is seldom necessary  to  specify  the  entire  DSNAME  in  the\n commands  since WYLBUR will construct all or part of the name for\n you from default or preset values.  However, the  dsname  operand\n may  never  be  omitted  and  it may not contain imbedded blanks.\n Normally you may specify SAVE * REPLACE to replace the  <external\n file> most recently accessed through a USE command.\n\n The system maintains four values to be used in constructing  data\n set  names.   These  are:  a group ID (not necessarily the user's\n group or the group to which he logged on), a user ID  (likewise),\n a  prefix  (a  dsname),  and a PDS member name.  Hereafter, these\n fields will be referred  to  as  the  SAVED  GROUP,  SAVED  USER,\n PREFIX, and SAVED MEMBER fields.\n\n The values in the four fields may be set individually by the user\n with the following commands:\n\n                         SET GROUP \u00ddgg\u00a8\n                         SET USER \u00dduuu\u00a8\n                         SET PREFIX \u00ddprefix\u00a8\n                         SET MEMBER \u00ddmember\u00a8\n\n and  the  current  value  may  be  displayed  with  similar  SHOW\n commands.  These commands are  described  in  Section  VII.   The\n GROUP  and USER values are set with the group and initials in the\n sign on procedure.  The prefix and member fields are set with the\n USE command.\n\n The USE, SAVE, SCRATCH,  and  utility  commands  always  use  the\n current  values  of  the  SAVED  GROUP  and  SAVED USER fields to\n construct a standard WYLBUR dsname unless you  override  them  in\n the  command.   You  may  take  advantage  of the PREFIX field by\n specifying * in the dsname operand.  Additionally, you may add on\n to the current PREFIX value by specifying *string as  the  dsname\n operand.   This  will  result in \"string\" being concatenated with\n the current PREFIX.  The PREFIX and MEMBER fields have  been  set\n up so that you normally need type only SAVE * to save the <active\n file> as the same name used with the USE command.\n\n The SAVED MEMBER field is used by WYLBUR  when  accessing  a  PDS\n unless  a  member  name  is  specified  in  the  command operand.\n Specifying (member) at the end of the  dsname  operand  overrides\n the  value in SAVED MEMBER.  Specifying a member name of () alone\n overrides SAVED MEMBER with a  null  value.   Thus,  to  use  the\n current  PREFIX,  but  ignore the current SAVED MEMBER, you would\n specify:\n\n                         command *()\n\n1DEFINITION OF TERMS                                              VIII - 6\n\n\n You may always override the SAVED GROUP or SAVED  USER  field  in\n the command without having to use the current PREFIX.  Do this by\n specifying the keyword operands:\n\n                      \u00ddGROUP gg\u00a8 \u00ddUSER uuu\u00a8\n\n somewhere in the command line after the dsname operand.\n\n To access a non-WYLBUR data set, specify  the  entire  DSNAME  by\n enclosing the name in quotes.\n\n                         'dsname'\n\n The  SAVED  GROUP  and  SAVED  USER  fields  are  not  used   for\n constructing  a  data  set  name  enclosed in quotes.  The quoted\n dsname is also valid in PREFIX.\n\n The dsname operand itself may contain certain special  characters\n as  abbreviations.   The special characters used for this purpose\n are:\n\n     $dsname  used instead of 'dsname' unless the dsname contains\n              delimiter characters (blank,comma,=,and parens);\n     #member  used instead of (member);\n     @gg.     used instead of \"GROUP gg\";\n     &uuu.    used instead of \"USER uuu\".\n\n When @ or & occur alone followed immediately by their  delimiting\n period, the default value is used.\n\n Thus, the general  short  form  of  the  dsname  operand  in  the\n commands is:\n\n     \u00dd$string|\u00dd@\u00ddgg\u00a8.\u00a8\u00dd&\u00dduuu\u00a8.\u00a8\u00dd*\u00a8\u00ddstring\u00a8\u00a8\u00dd#\u00ddmember\u00a8\u00a8\n\n     Examples:\n           $SYSMSG.ABCUR001\n           @UA.&.DATA1\n           &DEF#TEXT\n           $WYL.UR.ABC.MYTEXT\n\n The PREFIX and SAVED MEMBER may be set by specifying the optional\n command operand SET.  When SET is specified  in  a  command  that\n accesses  an external data set, the DSNAME is constructed and the\n entire command line is scanned for  syntactical  and  conflicting\n specification  errors.  Then the two fields are set to the values\n contained in the constructed DSNAME.  The PREFIX field takes  the\n value  of  the  part  of  the  DSNAME  following  the user ID but\n excluding any member name.  That is, for a constructed DSNAME of:\n\n                         WYL.SF.ESR.XYZ(A1)\n\n the PREFIX field is set to XYZ and the SAVED MEMBER  becomes  A1.\n If  the  member  name  is null (for a sequential data set), SAVED\n MEMBER is set to null.  The SAVED USER and SAVED GROUP fields are\n not changed by the SET option.  These fields can only be  changed\n by SET NAME/GROUP/USER commands.\n1DEFINITION OF TERMS                                              VIII - 7\n\n\n END\n\n END is a <symbolic line number> which points to  the  line  after\n the LAST line of a file.  Its line number value is LAST+DELTA, so\n if  the  last  line is 10 and DELTA is 1, the value of END is 11.\n That does not mean that line 11 exists, but rather that the  line\n number  of  the  next line to be added at the end of a file would\n default to 11.\n\n\n EXEC BREAK\n\n When a command that is being executed from  the  <exec  file>  is\n aborted,  an  <exec break> occurs and the user returns to COMMAND\n mode.  The command EXEC RETRY will re-attempt  execution  of  the\n aborted  command  while  EXEC  will  start  at  the command which\n follows the aborted command.\n\n\n\n EXEC FILE\n\n The <exec file> is a file that is separate and distinct from  the\n <active  file>.   It  may  contain a list of commands that can be\n executed at any time by using the EXEC command.  Any command  can\n be  in the file but the file can contain a maximum of three pages\n of commands (See SHOW PAGES in Section VII).   The  file  can  be\n loaded  from  either  the  <active  file> or from any EDIT format\n <external file>.\n\n\n\n EXPLICIT RANGE\n\n Explicit range refers to a group of lines  designated  by\n the  upper  and  lower limits of the line numbers such as X/Y.  X\n must be less than or equal to  Y.   If  X=Y,  the  range  may  be\n specified  by  giving only a single number.  See <line number> in\n this section for a description of line number limits.  Range  may\n be  expressed  as  a  line number and a count.  12(5) means the 5\n lines starting at line 12.\n\n The first and last lines of the <active file> may be referred  to\n simply  by  FIRST and LAST.  The explicit range ALL is equivalent\n to FIRST/LAST.\n\n An alternate form of an explicit range is a list  of  up  to  ten\n line  numbers.   The list can contain single lines or groups, and\n the ranges can overlap, but each  group  counts  as  two  of  the\n numbers  allowed.   For  example,  10,21,20,12/L,125.2 is a valid\n range.\n\n1DEFINITION OF TERMS                                              VIII - 8\n\n\n In any command  that  has  <range>  as  a  valid  option,  an  an\n <explicit  range>  must  either  be specified or implied.  It may\n only be implied by omission in those commands that use a  default\n range of ALL:\n\n              CHANGE         LOAD           PUNCH\n              COPY           MODIFY         RUN\n              EDIT           NUMBER         SUGGEST\n              LIST           POINT\n\n\n\n\n EXTERNAL FILE\n\n All files other than the current <active file>  and  <exec  file>\n are  external  files.  These external files are either sequential\n data sets or members of partitioned data sets.  See also <dsname>\n in this section.\n\n\n FIRST\n\n FIRST is a <symbolic line number> which has the value of the line\n number of the first line in the <active file>.\n\n\n FILE\n\n A file is a collection of lines of text which may include  WYLBUR\n commands as well as system control statements (JCL) or other text\n such  as  a  program, a set of data, a letter, or a dissertation.\n See <exec file>, <external file> and <active file>.\n\n\n FORMAT\n\n The format of a data set may be shown using the  TYPE  option  of\n the  SHOW  DSNAMES  command.   There are some restrictions on the\n format that a WYLBUR  data  set  may  have.   If  these  are  not\n followed,  the  following  message  will  be  displayed  when you\n attempt to use the data set:\n\n    <dsname> DSORG OR RECFM NOT VALID FOR WYLBUR.\n\n See  Section  VI.D  and  Section  VII  (SAVE  command)  for  more\n information on WYLBUR formats.\n\n\n LAST\n\n LAST is a <symbolic line number> which has the value of the  line\n number  of the last line in the <active file>.\n1DEFINITION OF TERMS                                              VIII - 9\n\n\n\n\n LIBRARY\n\n Each user has one PDS library that can be used to  contain  small\n <external  files> as members.  More than one member can reside on\n a single disk track whereas, only one sequential data set is on a\n track, regardless of the size of the data set.  There is also one\n group library for each group that can be used by  any  member  of\n the group.\n\n\n\n LINE NUMBER\n\n A line number must be between 0.  and 99999.999.   Any  <symbolic\n line  number>  is  allowed.   Leading  and terminal blanks may be\n dropped.  The decimal point may be dropped when the number is  an\n integer.\n\n        0065.000 = 65.000 = 65. = 65 = 63+2 =70-5\n\n\n\n LIST OPTIONS\n\n The UNNUMBERED option produces a listing containing only the text\n of the lines in the <range>.  The  NONUMBERED  and  TEXT  options\n function  similarly  to  UNNUMBERED  except  that the text is not\n moved to the left into the place usually  occupied  by  the  line\n numbers.   The  NOTEXT option suppresses printing of the text and\n produces a listing of only the line numbers of the lines  in  the\n specified  <range>.  The INTEGER option replaces the regular line\n numbers with eight digit integers.  The NOLIST option  suppresses\n listing when LIST is the default for the command.\n\n\n\n PROCESSING BREAK\n\n This  message  indicates  that  the  user  has  interrupted   the\n execution  of  a SHOW DSNAMES/DIRECTORY/CATALOG command before it\n was completed.  The results found before interruption are  listed\n but the list is not guaranteed to be complete.\n\n\n RANGE\n\n This is either an <explicit range> or an <associative range>.\n\n\n\n1DEFINITION OF TERMS                                              VIII - 10\n\n\n\n RECOVERY\n\n Recovery  is  attempted  whenever  WYLBUR  crashes,  the   system\n crashes,  the  telephone  connection  is  broken, or a session is\n ended with SIGNON without clearing the <active file>  (See  CLEAR\n command.).   The <active file> is saved and cataloged as the data\n set ACTIVE.  The next time you sign on WYLBUR, do a  \"USE  ACTIVE\n ON  CATLG\"  to  recover your file.  User's are warned not to save\n any data set with the name ACTIVE since the system might use this\n name at any time and replace the old  data  set.   (See  SYSTEM?,\n DSNAME, and the USE command.)\n\n There may be several files named  ACTIVE,  each  on  a  different\n volume,  but  only the most recently saved will be cataloged.  If\n some of your space allocation cannot be accounted for, do a\n\n                   SHOW  DSNAMES  LIKE  ACTIVE\n\n for different volumes until you find all of them.\n\n\n NEXT\n\n NEXT is a  <symbolic  line  number>  which  refers  to  the  line\n immediately   following  the  <current  line  pointer>.   If  the\n <current line pointer> has not been set or if the  <current  line\n pointer> points to the last line in a file, NEXT does not exist.\n\n\n\n PREVIOUS\n\n PREVIOUS is the <symbolic line number> of  the  line  immediately\n preceding the <current line pointer>.  PREVIOUS is not set if the\n <current  line  pointer>  is  not  set,  or  if the <current line\n pointer> points to the first line in a file.\n\n\n\n Sign-On Procedure\n\n This is the dialogue between the user and  the  system  which  is\n used to determine the project number to which the session will be\n charged,  as well as the user and group of the person signing on.\n (See Section I.E for a detailed example.)\n\n\n\n STRING\n\n A set of characters within  quotes  which  may  include  imbedded\n blanks.   The  quotes may be either single (') or double (\"), but\n must be consistant within a single string; for example, 'THIS' or\n \"THIS\" but not 'THIS\".\n\n1DEFINITION OF TERMS                                              VIII - 11\n\n\n\n SYMBOLIC LINE NUMBER\n\n There are 6 symbolic line numbers:\n\n                FIRST        PREVIOUS\n                LAST         CURRENT\n                END          NEXT\n\n Symbolic line numbers are changing pointers to lines in  a  file.\n FIRST  and LAST are the first and last lines in a file and always\n exist even if the file consists of one line.  END points  to  the\n line number which would be added after the last line.  CURRENT is\n the  last  line edited, executed, or POINTed to; NEXT is the line\n immediately after CURRENT, and PREVIOUS is the  line  immediately\n before it.  Unless editing, collecting or executing has been done\n on the file, these three entities do not exist.\n\n\n\n SYSTEM?\n\n This is a  prompt  by  the  MILTEN  portion  of  the  CUCC/MILTEN\n terminal  processor.   Users should receive this prompt only when\n WYLBUR is down.  SHOW SYSTEMS  can  be  used  to  determine  when\n WYLBUR  is  available  again  which  will  probably be only a few\n minutes.  Once WYLBUR is available, you must type WYLBUR to enter\n it.  See <recovery> for a description of how to  recover  from  a\n WYLBUR or system crash.\n\n No WYLBUR commands (i.e.  USE, LIST, LOCATE, etc.) are  valid  in\n MILTEN.    However,   such   commands  as  TO,  SHOW  TIME,  SHOW\n LINE|LINES, SHOW  COUNT,  LOGON,  and  LOGOFF  are  valid  MILTEN\n commands.\n\n This prompt may also be given by TPMON.  You may type any of  the\n following in response to this SYSTEM? prompt:\n\n    1. The name of a TPMON system\n       For WYLBUR you may type either WYLBUR or MILTEN.\n\n    2. ? (CR)\n       TPMON replies with the name of available systems.\n\n    3. # (CR)\n       This will terminate the session.\n\n\n\n\n VOLUME\n\n The term volume refers to the name of the storage devices used to\n hold both WYLBUR data sets and  other  system  data  sets.   SHOW\n VOLUMES  can  always  be  used  to obtain the valid names for the\n current session.  CATLG may be used to  reference  any  cataloged\n data set in most commands.\n1APPENDIX A  SHORT FORMS                                          APP.A - 1\n\n\n Appendix A    SHORT FORMS OF WYLBUR COMMAND WORDS\n\n\n Most words used in WYLBUR can be abbreviated by typing  three  or\n more characters of the word.  Thus, UNC, UNCA, UNCAT, UNCATL, and\n UNCATLG are all recognized by WYLBUR as the keyword UNCATLG.  All\n characters  typed  (up  to  the  first eight) are checked so that\n UNCATLL or UNCATLGG  would  not  be  recognized  as  the  keyword\n UNCATLG.   In  addition, some words in WYLBUR commands have short\n forms  or  alternate  forms  that  do  not   obey   the   general\n abbreviation rule.\n\n The following list gives all the words used  in  WYLBUR  commands\n along  with  any  alternate  forms allowed for them.  Those words\n marked with an asterisk (*) cannot be abbreviated using the first\n three letters.  Those words marked with a  number  sign  (#)  may\n only  be abbreviated by their alternative when used as a command,\n not as an option.  If there is no asterisk or  number  sign,  the\n general abbreviation rule applies.\n\n\n\n  WORD    ALTERNATE     WORD     ALTERNATE     WORD     ALTERNATE\n\n\n\n ACCOUNT               COPY                   HELP\n ACTIVE                COUNT      *           ID\n ADD                   CURRENT        *       IN\n ALIAS      *          CRT                    INDENT\n ALIGN                 DARKLIST               INSERT         I\n ALL                   DATE                   INTEGER\n AT                    DATED                  JOBNO\n BACK                  DECIDE                 JUSTIFY\n BIN            B      DELETE         D       KEYWORD\n BREAK                 DELTA                  LAST           L\n BY                    DIRECTORY              LENGTH\n CANCEL                DITTO                  LIKE\n CARD                  DOUBLE                 LINE\n CASE                  DSNAMES                LINES      #   LINS\n CATLG                 EDIT           E       LIST       #   L\n CC                    END                    LOAD\n CENTER                ESCAPE                 LOCATE\n CHANGE         CH     EVEN                   LOG\n CLEAN                 EXCLUDE                LOGOFF     *   SIGNOFF,LOGOUT\n CLEAR          CLR    EXEC       #   X       LOGON      *   SIGNON,LOGIN\n COLLECT        C      FASTLIST               LRECL\n COLUMNS               FIRST          F       MARKER\n COMBINE               FOR                    MC\n COMMENT    *   COMM   FORMS                  MEMBER\n COMPARE               FROM                   MERGE\n CONDENSE              GIVE                   MESSAGE        MSG\n COPIES                GROUP                  MODIFY         M\n1SHORT FORMS                                                      APP.A - 2\n\n\n\n  WORD    ALTERNATE     WORD     ALTERNATE     WORD     ALTERNATE\n\n\n\n MOVE                  PREFIX                 SUGGEST\n MSGOFF                PREVIOUS               SYSOUT\n MSGON                 PRINT                  SYSTEMS\n NAME                  PROMPT                 TABS\n NEXT                  PUNCH      *           TERMINAL       TERM\n NOBACK     *          PUT                    TERSE\n NOBREAK    *          READ                   TEXT\n NOCOUNT               RECATLG                THROUGH        THRU\n NODITTO               RELEASE                TIME\n NOEJECT               RENAME                 TIMEOUT    *\n NOLIST         N      REPLACE    #   R       TIMES\n NOLOG                 RESTORE                TO\n NONUMBER              RETRY                  TRACKS\n NOPOINT               RUN                    TRIPLE\n NOSET                 SAVE           S       TYPE\n NOTEXT                SC                     UNCATLG\n NOTIME                SCRATCH                UNDER\n NOTYPE                SEQFLD                 UNNUMBERED\n NOVERIFY              SET                    UPLOW\n NUMBER                SHOW                   UPPER\n NUMBERED              SINGLE         S       USE            U\n OFFLINE               SIZE                   USER\n ON                    SKIP                   USERS\n OVER                  SLOWLIST               USING\n PAGES                 SPACE                  VALUE\n PAUSE                 SQUASHED               VERBOSE\n PDS                   START                  VERIFY\n POINT          P      STRING                 VOLUME\n                                              VOLUMES    *   VOLS\n\n\n You may use any of the valid forms of a word in a command.  There\n no periods after abbreviations or short forms.\n1APPENDIX B  EDITING HINTS                                        APP.B - 1\n\n\n Appendix B   Editing Hints\n\n\n    1. Making a Skeleton for a Utility Job or Form Letter\n\n       The CHANGE command can be used to insert a name,  location,\n       etc.,  at  predetermined places in a file.  For example, if\n       $$ is put in each place in  the  text  where  the  changing\n       information is to go, the following commands can be used to\n       produce a form letter which contains personal references.\n\n       COMMAND? CHANGE '$$' TO 'MR. ROBERT SMITH' IN ALL NOLIST (CR)\n\n       In order to produce a clean copy of  the  letter,  place  a\n       marker  character  at  the  end  of  each page, call for an\n       UNNUMBERED listing, and change the  paper  before  striking\n       carriage  return.   In this example the character \u00a2 is used\n       for a marker.\n\n       COMMAND? LIST UNN MARKER=\u00a2 CLEAN(CR)\n\n    2. Duplicating Lines\n\n       The COPY command can be used to duplicate single  lines  or\n       groups of lines if the range being copied into is contained\n       within  the  range  being copied.  Starting with the sample\n       file\n\n          1.  THIS IS THE LINE TO BE COPIED.\n\n       The command\n\n       COMMAND? COPY 1 (3) TO 2\n\n\n       will produce the following:\n\n          1.  THIS IS THE LINE TO BE COPIED.\n          2.  THIS IS THE LINE TO BE COPIED.\n          3.  THIS IS THE LINE TO BE COPIED.\n          4.  THIS IS THE LINE TO BE COPIED.\n\n1EDITING HINTS                                                    APP.B - 2\n\n\n    3. Using Printer Control Characters.\n\n       Certain symbols are recognized by  the  system  as  printer\n       control  characters  if  they  occur  in  column one.  They\n       control line-spacing  and  page  ejects.   Normally  WYLBUR\n       inserts these characters for you when you do a LIST OFFLINE\n       but  you  may  do this yourself.  Use the CC parameter with\n       the LIST OFFLINE command to tell WYLBUR you  have  inserted\n       these  control  characters.   Anything  in column 1 will be\n       assumed to be a carriage control character,  and  column  1\n       will  not  be  printed in the listing.  The listing will be\n       numbered  unless  you  specify  UNNUMBERED  or  UNN.    The\n       following  command  will give you a listing when you supply\n       the printer control characters.\n\n       COMMAND? LIST OFFLINE CC (CR)\n\n       Some of the common printer  control  characters  and  their\n       functions are:\n\n          blank          single space - skip to next line\n            1            page eject - skip to top of next page\n            0            double space - skip to next line + 1\n            -            triple space - skip to next line + 2\n            +            no skip - used for underlining\n\n\n       Page Boundaries\n\n       WYLBUR will give you 60 lines per page.  If you want  fewer\n       lines  on  a  page  or if you want a new page to start at a\n       certain place, such as at the beginning of a paragraph, you\n       must have a 1 in column 1 of the first line of  each  page.\n       Every  other  line  must  also  have  a  control character,\n       perhaps a blank for single spacing, in  column  1.   Rather\n       than  space over to column 2 when typing each line, you can\n       insert the blanks this way.\n\n       COMMAND? CH 1 TO ' ' IN \u00ac'1' 1 NOLIST (CR)\n\n       This command inserts a blank in column 1 of every line that\n       does not have a  1  (\u00ac'1')  in  column  1.   The  blank  is\n       actually  inserted  and  the  text is moved over one column\n       rather than replacing column 1 with a  blank.   The  blanks\n       will  produce  single spaced lines in the printed copy.  To\n       list this active file:\n\n       COMMAND? LIST OFFLINE CC (CR)\n\n       Double and Triple Spacing\n\n       If you want your file to  have  double  or  triple  spacing\n       throughout, use the DOUBLE or TRIPLE option.\n\n       COMMAND? LIST OFF TRIPLE (CR)\n\n1EDITING HINTS                                                    APP.B - 3\n\n\n       You might want a combination  of  spacing  such  as  single\n       spaced  text  and triple spaces between paragraphs.  To get\n       this, insert a 1 in column 1 wherever you want a new  page;\n       insert  a - in column 1 wherever you start a new paragraph.\n       Then follow this procedure.\n\n          COMMAND? CH 1 TO ' ' NOLIST (CR)\n          COMMAND? CH ' 1' 1 TO '1' NOLIST (CR)\n          COMMAND? CH ' -' 1 TO '-' NOLIST (CR)\n          COMMAND? LIST OFFLINE CC (CR)\n\n       The first command inserts a blank  in  column  1  of  every\n       line.   Thus all lines which had a 1 in column 1 now have a\n       blank and a 1 in columns  1  and  2.   The  second  command\n       changes  each  line with a blank and a 1 in columns 1 and 2\n       to a 1 column 1 (deleting the new column  2).   The  second\n       command  does a similar switch for lines with a blank and a\n       - in columns 1 and 2.\n\n       Underlining\n\n       To do underlining with printer control characters takes two\n       lines for each line that has underlined text in it.\n\n           This is an example of underlining\n          +           _______\n\n       The + in column 1 of the second line means not  to  skip  a\n       line so it overprints and produces a line in which the word\n       example is underlined.  To get a listing with underlining,\n\n          COMMAND? CH 1 TO ' ' NOLIST (CR)\n          COMMAND? CH ' +' 1 TO '+' NOLIST (CR)\n          COMMAND? LIST OFFLINE CC (CR)\n\n    4. How to Insert Page Numbers.\n\n       You may insert lines containing a 1 in column 1 and a  page\n       number  near the right margin throughout the text.  Or, you\n       may insert lines containing only a 1 in column  1  wherever\n       you want a new page.  Then you may insert page numbers this\n       way.\n\n          COMMAND? CH 68 TO 'PAGE' IN '1' 1 NOL (CR)\n          COMMAND? CH 73 TO 1+1 IN '1' 1 NOL (CR)\n1EDITING HINTS                                                    APP.B - 4\n\n\n       The first command will insert the character  string  'PAGE'\n       into  columns  68/71  of every line which contains a '1' in\n       column 1.  The second command will insert a '1'  in  column\n       73 of the first line which contains a '1' in column 1.  The\n       replacement value is incremented by one so that WYLBUR will\n       insert  a  '2'  in  the second line which contains a '1' in\n       column 1 and so on.   Notice  that  page  number  10  would\n       occuppy columns 73 and 74.  Page number 100 would be placed\n       in   columns  73, 74,  and  75.   Therefore,  if  you  were\n       renumbering the pages of  an  already  existing  file,  you\n       would use the following command:\n\n              COMMAND? CH 73/75 TO 1+1 IN '1' 1 NOL (CR)\n\n    5. Creating Columns of Information\n\n       The USING parameter on the CHANGE command  is  very  useful\n       for  creating  tables  or  columns  of information.  Let us\n       assume that the following lines exist in a file:\n\n          1.  ABC\n          2.  DEF\n          3.  $1100\n          4.  $ 620\n\n       COMMAND? CH 30 IN 1/2 USING 3/4  NOL (CR)\n       COMMAND? DEL 3/4 (CR)\n       COMMAND? LIST\n          1.  ABC                      $1100\n          2.  DEF                      $ 620\n\n       You  may  subsequently  make  modifications  to  the  first\n       columns without destroying the later columns by  using  the\n       fill column of the CHANGE command.\n\n       COMMAND? CH 'ABC' //30 TO 'JONES' (CR)\n       COMMAND? CH 'DEF' //30 TO 'SMYTHE' NOL (CR)\n       COMMAND? LIST (CR)\n          1.  JONES                    $1100\n          2.  SMYTHE                   $ 620\n1APPENDIX C - USER/SYSTEM NEWS                                    APP.C - 1\n\n\n APPENDIX C - User/System News\n\n 1.  User Suggestions\n\n You may register a suggestion or complaint by creating an  active\n file with your suggestion and then giving the command SUGGEST.  A\n range  of up to 50 lines may be specified in the command.  If the\n active file contains more than  50  lines  and  a  range  is  not\n specified  in the command, the first 50 lines of the file will be\n submitted as the suggestion.\n\n\n       COMMAND? CLEAR TEXT (CR)\n       COMMAND? COL (CR)\n         1.   ? WYLBUR Editing time should be more expensive. (CR)\n         2.   ?  John Doe Comp Group (CR)\n         3.   ? (ATTN)***\n       COMMAND? SUGGEST (CR)\n\n       JOB 8193,ABCEB500 SUBMITTED\n\n The last line is printed because an off-line listing will be done.\n\n\n 2.  News from WYLBUR\n\n The file WYL.CU.CTR.LIB(NEWS) is  a  PDS  member  which  contains\n information  on  changes  and  additions  that  have been made to\n WYLBUR subsequent to the printing of this manual, as well as news\n of general interest concerning the Computer Center.\n\n To look at it, use the following command:\n\n       COMMAND? EXE FRO WYL.CU.CTR.LIB(NEWS) CLR (CR)\n\n You should consult the NEWS file often in order  to  keep  up  to\n date on modifications to the system.\n\n1INDEX                                                             INDEX - 1\n-BOLDFACE type indicates a primary reference for the command.\n+BOLDFACE\n+BOLDFACE\n\n0\u00b5                   \u00b5                     \u00b5                     \u00b5\n1INDEX                                                             INDEX - 2\n0\u00b5                   \u00b5                     \u00b5                     \u00b5\n1INDEX                                                             INDEX - 3\n0\u00b5                   \u00b5                     \u00b5                     \u00b5\n1INDEX                                                             INDEX - 4\n0\u00b5                   \u00b5                     \u00b5                     \u00b5\n1INDEX                                                             INDEX - 5\n0\u00b5                   \u00b5                     \u00b5                     \u00b5\n1INDEX                                                             INDEX - 6\n0\u00b5                   \u00b5                     \u00b5                     \u00b5\n1INDEX                                                             INDEX - 7\n0\u00b5                   \u00b5                     \u00b5                     \u00b5\n1\n-\n0ACCOUNT-> IV.D-8,\n+ACCOUNT\n+ACCOUNT\n     VI.A-2, 4, B-1,\n     VII.-7, 13, 18,\n     27, 39, APP.A-1\n0ACTIVE-> I.E-1, G-2,\n+ACTIVE\n+ACTIVE\n     IV.A-1, C-1,\n     D-9, 10, VI.A-1,\n     VII.-5, 6, 10,\n     15, 16, VIII.-1,\n     10, APP.A-1\n0ALIAS-> VII.-20,\n+ALIAS\n+ALIAS\n     APP.A-1\n0ALIGN-> III.A-1,\n+ALIGN\n+ALIGN\n     E-1, 2, 3, 4,\n+            3\n+            3\n     5, VII.-2, 12,\n+       VII.-2\n+       VII.-2\n     37, APP.A-1\n0ALL-> II.D-4, 5,\n+ALL\n+ALL\n     III.A-1, 2, 3,\n     4, B-1, C-1, 2,\n     3, 5, 6, 7, 8,\n     9, 10, D-5, 6,\n     E-1, 2, 3, 4, 5,\n     G-2, IV.D-6,\n     VII.-9, 33, 34,\n     36, VIII.-7, 8 ,\n     APP.A-1, B-1\n0ASSOCIATIVE->\n+ASSOCIATIVE\n+ASSOCIATIVE\n     III.A-3, 4, B-1,\n     4, D-4, 8,\n     VIII.-1, 2\n0AT-> II.A-3, 4,\n+AT\n+AT\n     III.G-1, VI.C-2,\n     VII.-19, APP.A-1\n0\n-\n0BACK-> I.D-1, 2,\n+BACK\n+BACK\n     VII.-24,\n     VIII.-2, APP.A-1\n0BIN-> VI.A-1, 3, 4,\n+BIN\n+BIN\n     B-1, VII.-7, 13,\n     18, APP.A-1\n0BREAK-> I.F-2,\n+BREAK\n+BREAK\n     VII.-25,\n     VIII.-7, 9,\n     APP.A-1\n0BY-> II.A-5, B-2,\n+BY\n+BY\n     E-1, III.D-3, 4,\n     5, 6, 8, VI.A-2,\n     C-2, VII.-6, 8,\n     17, 19, APP.A-1\n0\n-\n0CANCEL-> VI.C-2,\n+CANCEL\n+CANCEL\n     E-1, F-2,\n     VII.-3, 11, 15,\n+    VII.-3\n+    VII.-3\n     20, APP.A-1\n0CARD-> IV.A-3,\n+CARD\n+CARD\n     VI.C-2, G-1,\n     VII.-22, 35, 40,\n     41, APP.A-1\n0CASE-> II.A-1, 2,\n+CASE\n+CASE\n     VII.-31, APP.A-1\n0CATALOG-> VIII.-9\n+CATALOG\n+CATALOG\n0CATLG-> I.G-2,\n+CATLG\n+CATLG\n     IV.A-3, 4, 5,\n     B-1, 2, C-1,\n     D-4, 7, 9,\n     VII.-1, 3, 15,\n+            3\n+            3\n     20, 22, 23, 24,\n     32, 33, 34, 40,\n     VIII.-10, 11,\n     APP.A-1\n0CENTER-> III.A-1,\n+CENTER\n+CENTER\n     F-1, VII.-3,\n+    F-1  VII.-3\n+    F-1  VII.-3\n     APP.A-1\n0CC-> III.C-3, 4,\n+CC\n+CC\n     VI.A-2, 4,\n     VII.-13, 14,\n     APP.A-1, B-2, 3\n0CHANGE-> II.D-3,\n+CHANGE\n+CHANGE\n     III.A-1, C-1,\n+             C-1\n+             C-1\n     2, 3, 4, 5, 6,\n     7, 8, 9, 10,\n     G-6, VII.-4, 5,\n+         VII.-4\n+         VII.-4\n     VIII.-3, 8,\n     APP.A-1, B-1, 4\n0CLEAN-> II.D-3,\n+CLEAN\n+CLEAN\n     VII.-13, 25, 39,\n     APP.A-1, B-1\n0CLEAR-> I.G-2,\n+CLEAR\n+CLEAR\n     II.A-2, 5, B-2,\n     IV.A-1, C-1,\n     D-3, VII.-5, 6,\n+         VII.-5\n+         VII.-5\n     10, 15, 16, 19,\n     21, 22, 40,\n     VIII.-10,\n     APP.A-1, C-1\n0COLLECT-> I.C-1, 2,\n+COLLECT\n+COLLECT\n     3, D-1, 2, 3,\n     E-1, II.A-1, 5,\n+                 5\n+                 5\n     6, B-1, 2, C-1,\n     D-3, III.B-2, 3,\n     D-6, E-1,\n     IV.A-1, VII.-6,\n+            VII.-6\n+            VII.-6\n     12, VIII.-2, 3,\n     APP.  A-1\n0COLUMNS-> III.C-10,\n+COLUMNS\n+COLUMNS\n     D-5, VI.A-4,\n     VII.-5, 7, 13,\n     33, APP.A-1\n0COMBINE-> III.D-7,\n+COMBINE\n+COMBINE\n     VII.-8, 9,\n     APP.A-1\n0COMMENT-> VII.-1,\n+COMMENT\n+COMMENT\n     6, VIII.-3,\n+    6\n+    6\n     APP.A-1\n0COMPARE-> VII.-1,\n+COMPARE\n+COMPARE\n     7, APP.A-1\n+    7\n+    7\n0CONDENSE-> IV.A-5,\n+CONDENSE\n+CONDENSE\n     D-8, 9, VI.D-1,\n     VII.-7, 8, 36,\n+    VII.-7\n+    VII.-7\n     APP.A-1\n0COPIES-> VI.A-3, 4,\n+COPIES\n+COPIES\n     B-1, VII.-13,\n     14, APP.A-1\n0COPY-> III.A-1, D-1,\n+COPY\n+COPY\n     2, 3, 4, 5, 6,\n     7, 8, VII.-8,\n+          VII.-8\n+          VII.-8\n     17, 32, VIII.-3,\n     8, APP.A-1, B-1\n0COUNT-> VII.-33, 38,\n+COUNT\n+COUNT\n     VIII.-11,\n     APP.A-1\n0CRT-> I.-1, C-3,\n+CRT\n+CRT\n     F-1, 3, II.A-4,\n     VI.A-1, VII.-16,\n     25, 26, APP.A-1\n0CURRENT-> II.C-1, 2,\n+CURRENT\n+CURRENT\n     III.A-2,\n     VII.-26, 38,\n     VIII.-3, 4, 11,\n     APP.A-1\n0\n-\n0DARKLIST-> VI.A-3,\n+DARKLIST\n+DARKLIST\n     4, VII.-13, 14,\n     APP.A-1\n0DATE-> VII.-33,\n+DATE\n+DATE\n     APP.A-1\n0DATED-> IV.D-10,\n+DATED\n+DATED\n     VII.-34, 35,\n     APP.A-1\n0DECIDE-> VII.-1, 9,\n+DECIDE\n+DECIDE\n     APP.A-1\n0DELETE-> II.C-2,\n+DELETE\n+DELETE\n     D-3, III.A-1, 4,\n     B-1, 2, 5,\n     VII.-9, 16, 17,\n+    VII.-9\n+    VII.-9\n     19, APP.A-1\n0DELTA-> II.A-5, B-1,\n+DELTA\n+DELTA\n     C-1, 2, E-1, 2,\n     III.B-3, D-1, 3,\n     4, 6, 7, 8, E-2,\n     3, VII.-6, 8,\n     17, 19, 26, 41,\n     VIII.-7, APP.A-1\n0DEST-> VI.A-4, B-1,\n+DEST\n+DEST\n     VII.-13, 14, 18,\n     21\n0DIRECTORY-> IV.D-5,\n+DIRECTORY\n+DIRECTORY\n     VII.-19, 24, 32,\n     33, 34, VIII.-9,\n     APP.A-1\n0DITTO-> III.B-2, 5,\n+DITTO\n+DITTO\n     VII.-12, 20, 21,\n     APP.A-1\n0DOUBLE-> VII.-13,\n+DOUBLE\n+DOUBLE\n     14, APP.A-1, B-2\n0DSNAMES-> IV.B-1,\n+DSNAMES\n+DSNAMES\n     C-1, D-5, 6, 7,\n     9, 10, VII.-8,\n     19, 24, 32, 33,\n     34, 35, 36,\n     VIII.-8, 9, 10,\n     APP.A-1\n0DSORG-> IV.D-10,\n+DSORG\n+DSORG\n     VII.-35, VIII.-8\n0\n-\n0EDIT-> I.D-2,\n+EDIT\n+EDIT\n     III.A-1, G-1,\n+    III.A-1\n+    III.A-1\n     2, 3, 4, 5, 6,\n+       3  4\n+       3  4\n     9, 10, IV.A-3,\n     4, VII.-8, 9,\n+               9\n+               9\n     10, 22, 23, 35,\n     40, 41, VIII.-2,\n     3, 7, 8, APP.A-1\n0END-> I.G-1, II.B-1,\n+END\n+END\n     C-1, 2, III.D-1,\n     2, 6, 8, VI.F-1,\n     VII.-6, 8, 16,\n     17, 19, 22, 23,\n     38, 40, 41,\n     VIII.-7, 11,\n     APP.A-1\n0ESCAPE-> VII.-26,\n+ESCAPE\n+ESCAPE\n     APP.A-1\n0EVEN-> III.E-4, 5,\n+EVEN\n+EVEN\n     VII.-2, 12,\n     APP.A-1\n0EXCLUDE-> VII.-32,\n+EXCLUDE\n+EXCLUDE\n     33, 34, 35,\n     APP.A-1\n0EXEC-> I.E-1,\n+EXEC\n+EXEC\n     VI.A-4, B-1,\n     C-2, F-1, 2,\n     G-1, VII.-5, 6,\n     8, 10, 13, 15,\n+       10\n+       10\n     18, 19, 21, 26,\n     27, 38, 39,\n     VIII.-4, 7,\n     APP.A-1\n0EXPLICIT-> III.A-2,\n+EXPLICIT\n+EXPLICIT\n     B-1, 2, 4, D-2,\n     8, E-2, F-1,\n     VIII.-7\n0EXTERNAL-> III.D-6,\n+EXTERNAL\n+EXTERNAL\n     7\n0\n-\n0FASTLIST-> II.A-4,\n+FASTLIST\n+FASTLIST\n     VII.-30, APP.A-1\n0FILE-> II.A-1,\n+FILE\n+FILE\n     III.B-2, D-1, 2,\n     3, 4, 5, 7, 8,\n     E-1, 3, 5,\n     IV.B-1, D-1, 2,\n     3, 5, 6, 9, 10,\n     VII.-7, 34,\n     VIII.-1, 7, 8\n0FIRST-> II.C-1, 2,\n+FIRST\n+FIRST\n     III.A-2, F-1,\n     VII.-38,\n     VIII.-7, 8, 11,\n     APP.A-1\n0FOR-> VII.-32,\n+FOR\n+FOR\n     VIII.-8, APP.A-1\n0FORMS-> VI.A-4,\n+FORMS\n+FORMS\n     VII.-13, 14,\n     APP.A-1\n0FROM-> III.D-6, 7,\n+FROM\n+FROM\n     IV.B-2, VI.E-1,\n     F-2, VII.-8, 10,\n     15, 32, 33, 34,\n     35, APP.A-1\n0\n-\n0GIVE-> VII.-1, 11,\n+GIVE\n+GIVE\n     APP.A-1\n0GROUP-> I.F-2, 3, 4,\n+GROUP\n+GROUP\n     IV.A-2, D-3, 6,\n     VI.F-2, VII.-3,\n     5, 7, 8, 10, 14,\n     19, 20, 22, 24,\n     27, 28, 32, 33,\n     34, 35, 38, 39,\n     40, VIII.-5, 6,\n     AP P.A-1\n0\n-\n0HELP-> VII.-1, 11,\n+HELP\n+HELP\n     APP.A-1\n0\n-\n0ID-> I.A-1, F-3,\n+ID\n+ID\n     IV.A-1, 2, D-1,\n     2, 3, 5, 6,\n     VI.A-4, B-1,\n     C-1, D-1, E-1,\n     VII.-3, 7, 13,\n     14, 18, 21, 31,\n     36, VIII.-4, 5,\n     6, APP.A-1\n0IN-> I.D-2, II.A-1,\n+IN\n+IN\n     D-5, III.A-3, 4,\n     B-1, 2, C-1, 2,\n     3, 5, 6, 7, 8,\n     9, 10, D-4, 5,\n     8, E-1, 2, 3, 5,\n     G-8, IV.A-5,\n     D-6, 7, VI.D-1,\n     G-1, VII .-4, 5,\n     7, 9, 33, 34,\n     VIII.-1, 2,\n     APP.A-1, B-1, 2,\n     3, 4\n0INDENT-> III.E-2, 4,\n+INDENT\n+INDENT\n     5, F-1, VII.-2,\n     3, 12, APP.A-1\n0INSERT-> II.C-2,\n+INSERT\n+INSERT\n     D-3, III.A-1,\n     B-1, 2, 3, 4, 5,\n     D-6, VII.-12,\n+         VII.-12\n+         VII.-12\n     16, APP.A-1\n0INTEGER-> III.A-4,\n+INTEGER\n+INTEGER\n     IV.A-4, VI.B-1,\n     VII.-6, 18, 21,\n     22, VIII.-9,\n     APP.A-1\n0\n-\n0JOBNO-> VI.C-1,\n+JOBNO\n+JOBNO\n     VII.-3, 14, 32,\n     36, APP.A-1\n0JUSTIFY-> III.A-1,\n+JUSTIFY\n+JUSTIFY\n     E-1, 2, 4, 5,\n     VII.-12,\n+    VII.-12\n+    VII.-12\n     VIII.-3, APP.A-1\n0\n-\n0KEYWORD-> I.F-2, 3,\n+KEYWORD\n+KEYWORD\n     VII.-27, APP.A-1\n0\n-\n0LAST-> II.C-1, 2,\n+LAST\n+LAST\n     E-1, 2, III.A-2,\n     B-1, 4, C-6,\n     D-1, 2, 3, 4, 5,\n     6, 7, 8, E-2,\n     VII.-17, 21, 38,\n     VIII.-7, 8, 11,\n     APP.A-1\n0LENGTH-> II.A-6,\n+LENGTH\n+LENGTH\n     III.E-1, 2, 3,\n     4, 5, F-1,\n     VII.-2, 3, 12,\n     28, 37, APP.A-1\n0LIKE-> IV.D-5, 6, 7,\n+LIKE\n+LIKE\n     9, VII.-8, 34,\n     35, 36,\n     VIII.-10,\n     APP.A-1\n0LINE-> I.D-2, F-2,\n+LINE\n+LINE\n     II.A-6, B-1,\n     C-2, E-1, 2,\n     III.B-2, 4, C-3,\n     5, 9, 10, D-1,\n     2, 3, 4, 5, 6,\n     7, 8, G-1, 2, 3,\n     5, 6, 7, 8, 9,\n     10, VI.C-2, VII\n     .-4, 5, 7, 36,\n     37, 39, VIII.-3,\n     9, 11, APP.A-1,\n     B-1\n0LINES-> VII.-22, 36,\n+LINES\n+LINES\n     37, 38,\n     VIII.-11,\n     APP.A-1\n0LIST-> I.C-1, 2,\n+LIST\n+LIST\n     II.A-1, B-1,\n     C-2, D-1, 2, 3,\n+         D-1\n+         D-1\n     4, 5, III.A-1,\n     2, 4, B-1, 2, 4,\n     5, D-1, 2, 3, 4,\n     5, 7, 8, E-1, 2,\n     3, 5, F-1,\n     VI.A-1, 2, 3, 4,\n     B-1, C-2, D-1,\n     F-1, VII.-4, 6,\n     9, 12, 13, 17,\n+           13\n+           13\n     18, 21, 25, 31,\n     33, 36, 39,\n     VIII.-8, 9, 11,\n     APP.A-1, B-1, 2,\n     3, 4\n0LOAD-> III.A-1,\n+LOAD\n+LOAD\n     VII.-15,\n+    VII.-15\n+    VII.-15\n     VIII.-8, APP.A-1\n0LOCATE-> VI.A-1,\n+LOCATE\n+LOCATE\n     D-1, VII.-15,\n+         VII.-15\n+         VII.-15\n     VIII.-11,\n     APP.A-1\n0LOG-> VII.-6, 10,\n+LOG\n+LOG\n     11, 15, 26, 27,\n     APP.A-1\n0LOGOFF-> I.G-1,\n+LOGOFF\n+LOGOFF\n     VII.-15,\n+    VII.-15\n+    VII.-15\n     VIII.-11,\n     APP.A-1\n0LOGON-> I.F-1, 2, 3,\n+LOGON\n+LOGON\n     4, VII.-16, 31,\n+       VII.-16\n+       VII.-16\n     VIII.-11,\n     APP.A-1\n0LRECL-> IV.A-3, 4,\n+LRECL\n+LRECL\n     D-4, 10, VI.F-1,\n     VII.-22, 23, 35,\n     40, 41, APP.A-1\n0\n-\n0MARKER-> II.D-2, 3,\n+MARKER\n+MARKER\n     III.E-1, 2, 3,\n     5, VII.-2, 12,\n     13, APP.A-1, B-1\n0MC-> VI.A-2, 4,\n+MC\n+MC\n     VII.-13, 14,\n     APP.A-1\n0MEMBER-> IV.A-5,\n+MEMBER\n+MEMBER\n     B-2, 3, D-4,\n     VI.G-1, VII.-5,\n     8, 10, 28, 34,\n     35, VIII.-5, 6,\n     APP.A-1\n0MERGE-> II.B-2,\n+MERGE\n+MERGE\n     III.D-4, 7, 8,\n     VII.-6, 8, 9,\n     17, APP.A-1\n0MESSAGE-> VII.-36,\n+MESSAGE\n+MESSAGE\n     APP.A-1\n0MILTEN-> VII.-38,\n+MILTEN\n+MILTEN\n     VIII.-11\n0MODIFY-> I.D-2,\n+MODIFY\n+MODIFY\n     III.A-1, G-1, 4,\n     5, 6, 7, 8, 9,\n+    5\n+    5\n     10, VII.-16,\n+    10  VII.-16\n+    10  VII.-16\n     VIII.-2, 3, 8,\n     APP.A-1\n0MOVE-> III.A-1, D-1,\n+MOVE\n+MOVE\n     7, 8, VII.-17,\n+          VII.-17\n+          VII.-17\n     VIII.-3, APP.A-2\n0MSGOFF-> VII.-28,\n+MSGOFF\n+MSGOFF\n     39, APP.A-2\n0MSGON-> VII.-28,\n+MSGON\n+MSGON\n     APP.A-2\n0\n-\n0NAME-> IV.D-3,\n+NAME\n+NAME\n     VI.D-1, G-1,\n     VII.-5, 27, 28,\n     29, VIII.-6,\n     APP.A-2\n0NEXT-> II.A-6, C-1,\n+NEXT\n+NEXT\n     2, III.A-2, G-3,\n     VI.C-1, VII.-36,\n     38, VIII.-4, 10,\n     11, APP.A-2\n0NOBACK-> VII.-24,\n+NOBACK\n+NOBACK\n     APP.A-2\n0NOBREAK-> I.G-1,\n+NOBREAK\n+NOBREAK\n     VII.-25, APP.A-2\n0NOCOUNT-> VII.-37,\n+NOCOUNT\n+NOCOUNT\n     APP.A-2\n0NODITTO-> VII.-12,\n+NODITTO\n+NODITTO\n     APP.A-2\n0NOEJECT-> VI.A-3, 4,\n+NOEJECT\n+NOEJECT\n     VII.-13, 14,\n     APP.A-2\n0NOLIST-> II.D-3,\n+NOLIST\n+NOLIST\n     III.C-1, G-2, 3,\n     9, VII.-7, 9,\n     16, 18, VIII.-9,\n     APP.A-2, B-1, 2,\n     3\n0NOLOG-> VII.-6, 10,\n+NOLOG\n+NOLOG\n     11, 15, 26, 27,\n     VIII.-3, APP.A-2\n0NONUMBER-> APP.A-2\n+NONUMBER\n+NONUMBER\n0NOPOINT-> VII.-22,\n+NOPOINT\n+NOPOINT\n     23, 40, APP.A-2\n0NOSET-> VII.-3, 8,\n+NOSET\n+NOSET\n     10, 15, 22, 24,\n     32, 33, 34, 40,\n     41, APP.A-2\n0NOTEXT-> II.D-3, 5,\n+NOTEXT\n+NOTEXT\n     VII.-6, 21,\n     VIII.-9, APP.A-2\n0NOTIME-> I.G-1,\n+NOTIME\n+NOTIME\n     VII.-29, 37,\n     APP.A-2\n0NOTYPE-> VII.-32,\n+NOTYPE\n+NOTYPE\n     33, APP.A-2\n0NOVERIFY-> II.A-4,\n+NOVERIFY\n+NOVERIFY\n     VII.-30, APP.A-2\n0NUMBER-> I.F-1,\n+NUMBER\n+NUMBER\n     II.C-2, E-1, 2,\n+            E-1\n+            E-1\n     III.A-1, E-3,\n     VII.-2, 12, 17,\n+                17\n+                17\n     VIII.-8, 9, 11,\n     APP.A-2\n0NUMBERED-> IV.A-4,\n+NUMBERED\n+NUMBERED\n     VI.B-1, C-2,\n     VII.-18, 21, 22,\n     23, 40, 41,\n     APP.A-2\n0\n-\n0OFFLINE-> VI.A-1, 2,\n+OFFLINE\n+OFFLINE\n     3, 4, B-1, D-1,\n     VII.-13, 14, 18,\n     21, 36, APP.A-2,\n     B-2, 3\n0ON-> I.G-2, III.D-6,\n+ON\n+ON\n     7, IV.A-1, 2, 3,\n     4, 5, B-1, 2, 3,\n     C-1, D-1, 2, 3,\n     4, 5, 6, 7, 8,\n     9, 10, VI.F-1,\n     2, G-1, VII.-3,\n     7, 8, 10, 15,\n     19, 20, 2 2, 23,\n     24, 32, 33, 34,\n     38, 40,\n     VIII.-10,\n     APP.A-2\n0OVER-> VII.-37,\n+OVER\n+OVER\n     APP.A-2\n0\n-\n0PAGES-> VII.-37,\n+PAGES\n+PAGES\n     VIII.-7, APP.A-2\n0PAUSE-> VII.-10, 11,\n+PAUSE\n+PAUSE\n     15, 19, APP.A-2\n0PDS-> IV.A-1, 5,\n+PDS\n+PDS\n     B-1, 2, 3, C-1,\n     D-1, 2, 3, 4, 5,\n     6, 7, 8, 9,\n     VII.-7, 20, 22,\n     23, 24, 33, 34,\n     VIII.-4, 5, 9,\n     APP.A-2, C-1\n0POINT-> III.A-1,\n+POINT\n+POINT\n     VII.-1, 18,\n+            18\n+            18\n     VIII.-3, 4, 8,\n     APP.A-2\n0PREFIX-> IV.D-7,\n+PREFIX\n+PREFIX\n     VII.-5, 8, 10,\n     28, 29, 34, 35,\n     VIII.-4, 5, 6,\n     APP.A-2\n0PREVIOUS-> II.C-1,\n+PREVIOUS\n+PREVIOUS\n     2, III.A-2,\n     VII.-38,\n     VIII.-4, 10, 11,\n     APP.A-2\n0PRINT-> IV.A-3,\n+PRINT\n+PRINT\n     VI.D-1, E-1,\n     VII.-3, 20, 22,\n     35, 40, 41,\n     APP.A-2\n0PROMPT-> VII.-19,\n+PROMPT\n+PROMPT\n     APP.A-2\n0PUNCH-> III.A-1,\n+PUNCH\n+PUNCH\n     VI.A-1, B-1,\n     D-1, VII.-18,\n+         VII.-18\n+         VII.-18\n     36, VIII.-8,\n     APP.A-2\n0PUT-> I.D-2, VII.-1,\n+PUT\n+PUT\n     19, APP.A-2\n+    19\n+    19\n0\n-\n0READ-> VI.F-1,\n+READ\n+READ\n     VII.-19,\n+    VII.-19\n+    VII.-19\n     APP.A-2\n0RECATLG-> IV.A-5,\n+RECATLG\n+RECATLG\n     VII.-1, 19, 20,\n+            19\n+            19\n     22, 23, APP.A-2\n0RECOVERY-> VIII.-10\n+RECOVERY\n+RECOVERY\n0RECFM-> IV.D-4, 10,\n+RECFM\n+RECFM\n     VI.F-1, G-1,\n     VII.-23, 35, 40,\n     41, VIII.-8\n0RELEASE-> VI.E-1,\n+RELEASE\n+RELEASE\n     F-2, VII.-11,\n     20, APP.A-2\n+    20\n+    20\n0RENAME-> VII.-1,\n+RENAME\n+RENAME\n     20, APP.A-2\n+    20\n+    20\n0REPLACE-> II.A-6,\n+REPLACE\n+REPLACE\n     D-3, III.A-1, 2,\n     B-1, 3, 4, 5,\n     D-5, G-1, 6,\n     IV.A-3, 4, 5,\n     D-9, 10,\n     VII.-16, 20,\n+             20\n+             20\n     21, 22, 23,\n     VIII.-4, 5,\n     APP.A-2\n0RESTORE-> VII.-1,\n+RESTORE\n+RESTORE\n     21, APP.A-2\n+    21\n+    21\n0RETRY-> VII.-10, 27,\n+RETRY\n+RETRY\n     VIII.-7, APP.A-2\n0RUN-> III.A-1,\n+RUN\n+RUN\n     VI.A-1, C-1, 2,\n     D-1, VII.-3,\n     21, 36, 37,\n+    21\n+    21\n     VIII.-8, APP.A-2\n0\n-\n0SAVE-> IV.A-1, 2, 3,\n+SAVE\n+SAVE\n     4, 5, D-1, 2, 5,\n     9, 10, VI.G-1,\n     VII.-1, 7, 19,\n     22, 23, 32, 41,\n+    22\n+    22\n     VIII.-4, 5, 8,\n     APP.A-2\n0SC-> VI.A-3, 4, B-1,\n+SC\n+SC\n     VII.-7, 13, 18,\n     APP.A-2\n0SCRATCH-> IV.A-1, 2,\n+SCRATCH\n+SCRATCH\n     3, B-1, 2, 3,\n     D-1, 2, VI.F-2,\n     VII.-22, 23,\n     24, 32, 33, 34,\n+    24\n+    24\n     36, VIII.-5,\n     APP.A-2\n0SEQFLD-> VII.-22,\n+SEQFLD\n+SEQFLD\n     23, 40, 41,\n     APP.A-2\n0SET-> I.C-3, D-1, 2,\n+SET\n+SET\n     3, F-3, G-1,\n     II.A-1, 2, 3, 4,\n     5, 6, D-4,\n+    5\n+    5\n     III.E-1, 2, 3,\n     F-1, IV.A-3,\n     B-1, 2, D-1, 2,\n     3, 7, 10,\n     VI.C-2, VII.-1,\n     3, 5, 8, 10, 11,\n     15, 19, 20, 22,\n     24, 25, 26, 27,\n     28, 29, 30, 31,\n     32, 33, 34, 35,\n     39, 40, 41,\n     VIII.-2, 4, 5,\n     6, APP.A-2\n0SHOW-> I.F-2,\n+SHOW\n+SHOW\n     II.A-1, 2, 4, 5,\n     III.D-1, 2, 3,\n     4, 5, 7, 8, E-1,\n     3, 5, IV.A-2,\n     B-1, 2, C-1,\n     D-5, 6, 7, 8, 9,\n     10, VI.C-1,\n     VII.-1, 8, 10,\n     19, 24, 25, 26,\n     27, 28, 29, 30,\n     31, 32, 33, 34,\n     35, 36, 37, 38,\n     39, VIII.-3, 4,\n     5, 7, 8, 9, 10,\n     11, APP.A-2\n0SINGLE-> III.G-2, 3,\n+SINGLE\n+SINGLE\n     4, 10, VI.G-1,\n     VII.-9, 16,\n     APP.A-2\n0SIZE-> VII.-34, 37,\n+SIZE\n+SIZE\n     VIII.-3, APP.A-2\n0SKIP-> VII.-27, 30,\n+SKIP\n+SKIP\n     34, 40, 41,\n     APP.A-2\n0SLOWLIST-> II.A-2,\n+SLOWLIST\n+SLOWLIST\n     4, 5, VII.-30,\n     APP.A-2\n0SPACE-> III.E-4,\n+SPACE\n+SPACE\n     IV.D-8, 9, 10,\n     VI.F-1, VII.-2,\n     8, 12, 19, 34,\n     35, 36, 38,\n     APP.A-2\n0SQUASHED-> VI.A-4,\n+SQUASHED\n+SQUASHED\n     VII.-13, APP.A-2\n0START-> II.A-3, 4,\n+START\n+START\n     VI.D-1, E-1,\n     VII.-10, 15,\n     APP.A-2\n0STRING-> III.A-3,\n+STRING\n+STRING\n     VIII.-10,\n     APP.A-2\n0SUGGEST-> III.A-1,\n+SUGGEST\n+SUGGEST\n     VI.D-1, VII.-36,\n     39, VIII.-8,\n+    39\n+    39\n     APP.A-2, C-1\n0SYSOUT-> APP.A-2\n+SYSOUT\n+SYSOUT\n0SYSTEMS-> VII.-38,\n+SYSTEMS\n+SYSTEMS\n     VIII.-11,\n     APP.A-2\n0\n-\n0TABS-> II.A-2, 3, 4,\n+TABS\n+TABS\n     5, VII.-5, 30,\n     APP.A-2\n0TERMINAL-> I.F-2, 3,\n+TERMINAL\n+TERMINAL\n     4, VII.-31,\n     APP.A-2\n0TERSE-> II.A-6,\n+TERSE\n+TERSE\n     VII.-10, 15, 26,\n     27, 31, APP.A-2\n0TEXT-> III.B-5,\n+TEXT\n+TEXT\n     IV.C-1, VII.-5,\n     6, VIII.-6, 9,\n     APP.A-2, C-1\n0THROUGH-> APP.A-2\n+THROUGH\n+THROUGH\n0TIME-> I.G-1,\n+TIME\n+TIME\n     VII.-16, 38,\n     VIII.-11,\n     APP.A-2\n0TIMEOUT-> VII.-29,\n+TIMEOUT\n+TIMEOUT\n     APP.A-2\n0TIMES-> II.E-2,\n+TIMES\n+TIMES\n     VII.-17, APP.A-2\n0TO-> I.D-2, F-2,\n+TO\n+TO\n     II.A-1, III.C-1,\n     2, 3, 4, 5, 6,\n     7, 8, 9, D-1, 2,\n     3, 4, 5, 6, 7,\n     8, E-1, 2, 3, 5,\n     G-1, 2, 3, 6, 7,\n     9, 10, IV.B-3,\n     D-8, VII.-4 , 5,\n     8, 11, 16, 17,\n     20, 25, 28, 32,\n     33, 34, 36, 39,\n+                39\n+                39\n     VIII.-11,\n     APP.A-2, B-1, 2,\n     3, 4\n0TPMON-> I.F-1, 2, 4,\n+TPMON\n+TPMON\n     G-1, VI.A-1, 2,\n     VII.-13, 39,\n     VIII.-11\n0TRACKS-> VII.-34,\n+TRACKS\n+TRACKS\n     38, APP.A-2\n0TRIPLE-> VII.-13,\n+TRIPLE\n+TRIPLE\n     14, APP.A-2, B-2\n0TYPE-> II.A-1, 3, 4,\n+TYPE\n+TYPE\n     IV.D-10,\n     VII.-34, 35,\n     VIII.-8, APP.A-2\n0\n-\n0UNCATLG-> IV.A-5,\n+UNCATLG\n+UNCATLG\n     B-2, 3, VII.-1,\n     20, 22, 23, 24,\n     32, 33, 39,\n+            39\n+            39\n     APP.A-1, 2\n0UNDER-> VII.-37,\n+UNDER\n+UNDER\n     APP.A-2\n0UNNUMBERED-> II.D-1,\n+UNNUMBERED\n+UNNUMBERED\n     2, 3, 5, VI.A-2,\n     B-1, VII.-6, 14,\n     33, VIII.-9,\n     APP.A-2, B-1, 2\n0UPLOW-> I.C-3, D-3,\n+UPLOW\n+UPLOW\n     II.A-1, 2, D-4,\n     III.E-2, VI.A-3,\n     4, C-2, VII.-13,\n     14, 31, APP.A-2\n0UPPER-> I.D-3,\n+UPPER\n+UPPER\n     II.A-1, 2,\n     VII.-31, APP.A-2\n0USE-> I.G-2,\n+USE\n+USE\n     III.E-1, 2, 3,\n     5, IV.A-1, 2, 3,\n     4, 5, B-2, C-1,\n     D-1, 2, 3, 4, 5,\n     6, 7, 9, 10,\n     VI.F-1, 2, G-1,\n     VII.-22, 28, 32,\n     40, VIII.-4 ,\n+    40\n+    40\n     5, 9, 10, 11,\n     APP.A-2\n0USER-> IV.B-2, 3,\n+USER\n+USER\n     D-2, 3, 6,\n     VI.C-2, D-1,\n     E-1, F-2,\n     VII.-3, 5, 7, 8,\n     10, 14, 19, 20,\n     22, 24, 28, 31,\n     32, 33, 34, 35,\n     38, 39, 40,\n     VIII.-5 , 6,\n     APP.A-2\n0USERS-> VII.-36, 39,\n+USERS\n+USERS\n     APP.A-2\n0USING-> III.C-1, 9,\n+USING\n+USING\n     10, VII.-5,\n     APP.A-2, B-4\n0\n-\n0VALUE-> VII.-32, 36,\n+VALUE\n+VALUE\n     APP.A-2\n0VERBOSE-> II.A-6,\n+VERBOSE\n+VERBOSE\n     VII.-10, 15, 26,\n     27, 31, APP.A-2\n0VERIFY-> II.A-3, 4,\n+VERIFY\n+VERIFY\n     VII.-30, APP.A-2\n0VOLUME-> IV.A-2, 3,\n+VOLUME\n+VOLUME\n     5, B-1, C-1,\n     D-1, 3, 4,\n     VII.-20, 22, 24,\n     32, 34, 40,\n     VIII.-11,\n     APP.A-2\n0VOLUMES-> IV.A-2,\n+VOLUMES\n+VOLUMES\n     D-5, VII.-32,\n     VIII.-11,\n     APP.A-2\n1\n\n\n\n\n\n\n\n\n\n\n\n            YOUR COMMENTS PLEASE.....\n\n\n            CUCC/WYLBUR Manual\n\n            Your comments and  constructive  criticism  regarding\n            this  manual  will  help us to improve it so that you\n            may be better served.  Each comment will be  reviewed\n            carefully.\n\n\n\n\n\n            Thank you for your cooperation.\n\n            Comments:\n1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n./ ADD NAME=NEWS001\n1\n WYLBUR Changes:\n\n The MODIFY command when requested with the\n UNNUMBER option will  no  longer  set  the\n NOLIST option.\n\n The  CHANGE  command  with  the  increment\n option is now fixed for starting  patterns\n that  contain alpahbetic characters before\n digits when  the  digit  characters  don't\n start  with  a  zero;  Blanks  embedded in\n digit patterns are no longer assumed to be\n zero  but  they are taken as the character\n ' '  --  only heading blanks before digits\n are taken as zero when necessary.\n\n The 'HELP ALL' command will give a listing\n of all available  WYLBUR  commands.   Note\n that  some  commands  that  are listed are\n only available to systems programmers.\n\n The 'DISPLAY' command is  a  variation  on\n the  'COMMENT'  command but unlike COMMENT\n the line displayed will not be  terminated\n with  a  CR/LF  sequence, i.e.  the cursor\n (or the print ball) will remain at the end\n of the printed line.\n\n COMMAND RETRY feature  is  now  available.\n The  last command that was typed to WYLBUR\n can be modified and reissued by  typing  a\n '$'  followed  by  a  CARRIAGE  RETURN, or\n ending a command line with a '$'  followed\n by an ATTENTION.  Since the new COMTEN was\n installed    WYLBUR   features   involving\n ATTENTION have not worked properly.  (e.g.\n Switching between EDIT and  MODIFY  modes,\n exiting from EDIT or MODIFY modes.) Please\n use  the CONTROL-Q sequence if you need to\n use ATTENTION for such uses,  as  well  as\n the   COMMAND  RETRY  feature.   When  you\n request COMMAND RETRY you will be prompted\n for changes on the command  you  had  last\n typed.    After   the   command  has  been\n modified when a CARRIAGE RETURN is hit the\n command will be reissued.  If an ATTENTION\n is hit the COMMAND RETRY request  will  be\n aborted.\n\n./ ADD NAME=PREPROC\n1           Specification of WYLBUR Pre-Processor Features\n\n\n The pre-processor features described below have been added to WYLBUR\n to enhance EXEC file processing  and  general  WYLBUR  capabilities.\n *** NOTE :  THESE FEATURES MAY BE REMOVED AT ANY TIME WITHOUT NOTICE\n IF IT IS FOUND THAT SYSTEM PERFORMANCE IS DEGRADED.\n\n\n I.  Extensions\n\n     A.  SET and SHOW VALUE commands\n\n         1.  SET VALUE <variable>=<EXP>\n\n             a.  Expression syntax\n                 <INTEGER>::= <1 to 9 digits>\n                 <LINENO>::= <0 to 5 digits>.<1 to 3 digits> |\n                             <1 to 5 digits>.\n                 <STRING>::= '<0 to 255 characters>' |\n                             \"<0 to 255 characters>\"\n                 <CONSTANT>::= <STRING> | <LINENO> | <INTEGER>\n                 <nVARIABLE>::= N<one digit>\n                 <wVARIABLE>::= W<one digit>\n                 <sVARIABLE>::= S<one digit>\n                 <VARIABLE>::= <nVARIABLE> | <wVARIABLE> | <sVARIABLE>\n                 <KEYWORD VAR>::= DELTA | FIRST | LAST | END | NEXT |\n                                  PREVIOUS | CURRENT | * | LENGTH |\n                                  PREFIX | USER | GROUP | MEMBER |\n                                  VOLUME | DATE | ESCAPE | SKIP |\n                                  PAGES | LINES | RANDOM | TERMINAL |\n                                  CP | PROJECT\n                 <PRIMARY>::= <VARIABLE> | <CONSTANT> | (<EXP>) |\n                              <KEYWORD VAR> | -<PRIMARY> | +<PRIMARY>\n                              <1 var function>(<EXP>) |\n                              <2 var function>(<EXP>,<EXP>) |\n                              <3 var function>(<EXP>,<EXP>,<EXP>)\n                 <1 var function>::= SIZE | TDUMP | CORE | EXPAND |\n                                     SCONVERT | NCONVERT | WCONVERT |\n                                     SHEX | NHEX | WHEX | DISPLAY |\n                                     REVERSE | TRIM | LTRIM | RTRIM |\n                                     NEGATE\n                 <2 var function>::= INDEX | RINDEX | LINDEX | TDUMP |\n                                     XLATE | SUBSTR | LSUBSTR |\n                                     RSUBSTR | VERIFY | LVERIFY |\n                                     RVERIFY | PAD | RPAD | LPAD |\n                                     TRIM | LTRIM | RTRIM | DUPL |\n                                     XOR | AND | OR\n                 <3 var function>::= XLATE | SUBSTR | RSUBSTR |\n                                     LSUBSTR | PAD | RPAD | LPAD\n                 <TERM>::= <PRIMARY> | <TERM> * <PRIMARY> |\n                           <TERM>/<PRIMARY>\n                 <AEXPR>::= <TERM> | <AEXPR>+<TERM> | <AEXPR>-<TERM>\n                 <EXP>::= <AEXPR> | <EXP>||<AEXPR>\n1                                            (2)\n\n             b.  The expression syntax is given in a fairly  standard\n                 BNF  grammar  format.   Expressions  have five basic\n                 operators   and   three    levels    of    priority.\n                 Multiplication (*) and division (/) have the highest\n                 priority  and are performed first.  Addition (+) and\n                 subtraction (-) have the next priority,  and  string\n                 catenation  (||) is performed last.  Parentheses can\n                 be  used  to  cause  any  other  desired  order   of\n                 evaluation.\n\n             c.  There are  only  30  variables  and  they  all  have\n                 pre-declared  names  (N0-N9,  W0-W9  and S0-S9).  An\n                 <nVARIABLE> can be set to any  <INTEGER>  value.   A\n                 <wVARIABLE>  can  be  set to any <LINENO> value.  An\n                 <sVARIABLE> can be set to any <STRING>  value.   The\n                 syntax for <LINENO>, <INTEGER> and <STRING> is given\n                 just  to show the range of values allowed.  <LINENO>\n                 and <INTEGER> expressions can have results that  are\n                 any  value representable by a full word.  The length\n                 of a <STRING> must  be  less  than  256  characters.\n                 Initially,  N0-N9  and W0-W9 are set to 0; S0-S9 are\n                 set to NULL.\n\n             d.  One or more blanks, commas, and/or equal  signs  can\n                 be  used  between  arguments,  around operators, and\n                 before and after parentheses.  They are normally not\n                 required if the separation is  clear  without  them.\n                 However,  a  restriction  on the use of multiply (*)\n                 now requires one or more blanks,  commas,  or  equal\n                 signs  on both sides of the * to be properly scanned\n                 if the two arguments are constants or variables.\n\n             e.  If CURRENT, NEXT, and/or PREVIOUS are  used  in  any\n                 <EXP>  and  they are not set, they will be given the\n                 value -1.000 instead of causing an EXEC break.\n\n             f.  Mixed  types  are  always  converted   automatically\n                 before the operation is done.  For mixed integer and\n                 line  number operations, the integer is converted to\n                 a  line  number.   For  arithmetic   operations   on\n                 strings,  the string(s) are converted to integers or\n                 line numbers first, and then normal integer to  line\n                 number  conversion is done if needed.  The functions\n                 SCONVERT, WCONVERT, and NCONVERT  are  available  to\n                 force different conversion.  Each of these functions\n                 takes  any  type  of  <EXP> as its argument and does\n                 any  conversion  necessary  to   output   a   string\n                 (SCONVERT),   line  number  (WCONVERT),  or  integer\n                 (NCONVERT) value.\n1                                            (3)\n\n             g.  Whenever a line number  is  converted  to  a  string\n                 (including  pre-processor substitutions), the string\n                 is made to always contain a 3-digit fractional  part\n                 even if the fractional part is '.000'.\n\n             h.  SUBSTR performs a substring operation on the  string\n                 specified   as   the  first  argument.   The  second\n                 argument specifies  the  starting  position  of  the\n                 substring,  and  the  third  argument  specifies the\n                 length.  If the third argument is omitted, the  rest\n                 of  the  string after the starting position is used.\n                 The starting position and length need not be  within\n                 the  string  operand  boundaries, but they cannot be\n                 negative nor sum to more than 256.  The result  will\n                 be a null string if the length operand is zero or if\n                 the  length  is omitted and the starting position is\n                 beyond the string operand.  The result will be blank\n                 filled on the right to give a result that  is  equal\n                 in  length  to the specified length operand whenever\n                 the  string  operand  is  not  long enough.  LSUBSTR\n                 function  is  identical to SUBSTR.  RSUBSTR function\n                 does the same function as SUBSTR with the difference\n                 that  the start position is specified from the right\n                 hand side of the first argument.\n\n             i.  VERIFY examines the two operand  strings  to  verify\n                 that   each   character   in  the  first  string  is\n                 represented in the second string.  If  this  is  the\n                 case,  a  value  of  0 is the result; otherwise, the\n                 value returned is the index of the  first  character\n                 in  the  first string that is not represented in the\n                 second  string.   LVERIFY  is  synonymous to VERIFY.\n                 RVERIFY  performs  the  same  function as VERIFY but\n                 the verification starts from the right hand side.\n\n             j.  SIZE simply has a value equal to the length  of  the\n                 argument string.\n\n             k.  INDEX finds the  starting  position  of  the  string\n                 specified  as  the second argument within the string\n                 specified as the  first  argument.   If  the  second\n                 string  is  not  in the first string, the value 0 is\n                 returned.  LINDEX  is  synonymous  to INDEX.  RINDEX\n                 returns the starting position of the first occurence\n                 of the string specified as the second argument  from\n                 scanning from the right hand side of the string.\n1                                            (4)\n\n             l.  DISPLAY converts the  argument  to  its  hexadecimal\n                 representation.   If  the  argument is a string, the\n                 result is a string of twice the length,  since  each\n                 character  of the argument string is now represented\n                 as   two   characters   which   are    its    EBCDIC\n                 representation  in hex (e.g.  DISPLAY('A1')='C1F1').\n                 If the argument is a line  number  or  integer,  the\n                 result  is  an  eight character string consisting of\n                 the hex digits for the  internal  representation  of\n                 the     line     number     or     integer     (e.g.\n                 DISPLAY(1.)=DISPLAY(1000)='000003E8').\n\n             m.  SHEX  is  the  inverse  of  DISPLAY  with  a  string\n                 argument.  The hex digits of the string argument are\n                 packed to form the characters.  The resultant string\n                 is half the length  of  the  argument  string  (e.g.\n                 SHEX('C1F1')='A1').   This  function  can be used to\n                 directly create any of the  256  possible  character\n                 codes.   Most  of  these  codes  will  type  on  the\n                 terminal  as  a  '%'  to  show  that  they  are  not\n                 printable.   As an extension, the SHEX function also\n                 allows integer arguments.  The result  is  a  string\n                 that   strips  off  leading  X'00'  bytes  from  the\n                 internal  representation  of   the   integer   (e.g.\n                 SHEX(241)=SHEX('F1')='1').\n\n             n.  NHEX is the  inverse  of  DISPLAY  with  an  integer\n                 argument.   The  string of up to 8 hex characters is\n                 packed to  form  an  internal  integer  value  (e.g.\n                 NHEX('3E8')=1000).\n\n             o.  WHEX is the inverse of DISPLAY with  a  line  number\n                 argument.   The  string of up to 8 hex characters is\n                 packed to form an internal line number  value  (e.g.\n                 WHEX('3E8')=1.000).\n\n             p.  The  PAD  function returns its first argument padded\n                 to a length  specified  by the second argument.  The\n                 fill character is specified with the third argument.\n                 If there is no third argument the fill character  is\n                 a space.  RPAD is synonymous to PAD.  LPAD pads  its\n                 argument on the left hand side.\n\n             q.  The  TRIM  and  RTRIM  functions  strip  their first\n                 argument off of the trim character specified as  the\n                 second argument on the left hand side. If the second\n                 argument is omitted the trim character  is a  blank.\n                 The LTRIM function does the same on the left side.\n\n             r.  REVERSE function returns the reverse of its argument\n1                                            (5)\n\n             s.  DUPL function returns a string constructed by dupli-\n                 cating its first argument as many times as specified\n                 by its second argument.\n\n             t.  XOR, AND, OR functions take two arguments and return\n                 a string formed by the logical operation implied  by\n                 the function name.  Shorter of the arguments is  ex-\n                 panded on the right side by adding blanks.\n\n             u.  NEGATE function returns a string formed by exclusive\n                 or-ing its argument by X'FFFFFF...'.\n\n             v.  TDUMP  function  returns the contents of main memory\n                 in hex.   The  first  argument  specifies in hex the\n                 the starting position of core dump.  The second  ar-\n                 gument specifies the length of core dump. If  it  is\n                 omitted 4 bytes of main memory is returned. The CORE\n                 function takes only one integer argument which tells\n                 the  start  address  of main memory, and returns the\n                 contents of 4 bytes starting at that location as  an\n                 integer.\n\n             w.  XLATE function translates its first  argument  in  a\n                 fashion specified by the second and third arguments.\n                 The  characters  specified  in  the  second argument\n                 are translated to the respective characters  in  the\n                 third argument.  If  the  third  argument is shorter\n                 than the second, the characters  specified  in   the\n                 second one with no corresponding   translations  are\n                 deleted.\n\n             x.  The EXPAND function returns its argument expanded by\n                 inserting blanks between each character.\n\n             y.  Examples:  SET VALUE W0 FIRST+5 *(DELTA+W5)\n                            SET VALUE S0 GROUP||'.'||USER||'.LIB'\n                            SET VAL S0 EXPAND('HELLO')\n                            SET VAL S5 XLATE('ABCDE','ABCD','XY')\n                            SET VAL S0 TDUMP('000010',4)\n\n         2.  SHOW VALUE <EXP>(s)\n\n             a.  Print value(s) for EXP(s)\n\n             b.  Multiple  expressions  are  always  separated  by  a\n                 blank.    String   expressions   are   enclosed   in\n                 apostrophes.\n\n             c.  Examples:  SHOW VALUE W0+3,W4,S0||'ABC',N5-12\n                            SHOW VALUE DISPLAY('ABCD')\n1                                            (6)\n\n     B.  READ command\n\n         1.  READ VALUE <variable>(s)\n             READ VALUE <variable>(s) PROMPT <string>\n\n             a.  Prompt    for    value(s)     of     <sVARIABLE>(s),\n                 <nVARIABLE>(s)   or   <wVARIABLE>(s).   Up  to  five\n                 variables may be read by one READ VALUE command, and\n                 the values are entered as <EXP>(s).\n\n             b.  Strings must be entered with quotes.  The quotes are\n                 stripped and any pairs of quotes within  the  string\n                 will  become  a single quote.  Any needed conversion\n                 of  the  <EXP>  to  the  type  of  the  variable  is\n                 performed automatically.\n\n             c.  If the input does not contain as many expressions as\n                 variables  given  in  the  command,  the   remaining\n                 <sVARIABLE>(s)  are  set  to  NULL and the remaining\n                 <nVARIABLES>(s) or <wVARIABLE>(s) are set to 0.\n\n             d.  If  the  PROMPT  option is used the string following\n                 the keyword PROMPT is prompted, otherwise 'ENTER? '.\n\n             e.  Examples:  READ VALUE W0,W2,S0\n                            READ VALUE N8\n\n         2.  READ STRING <sVARIABLE>\n             READ STRING <sVARIABLE> PROMPT <string>\n\n             a.  Prompt for value of sVARIABLE\n\n             b.  The entire line entered is assigned to  the  string.\n                 Quotes   become  simply  another  character  in  the\n                 string.\n\n             c.  If  the  PROMPT  option is used the string following\n                 the keyword PROMPT is prompted, otherwise 'ENTER? '.\n\n             d.  Example:  READ STRING S1\n\n         3.  READ STRING <sVARIABLE> USING <lineno> COLUMNS <column(s)>\n\n             a.  Set string variable to specified part of active file\n                 line.\n\n             b.  The USING and COLUMNS options are processed  in  the\n                 same  way as these options are in the CHANGE command\n                 except that only one line may be specified.\n\n             c.  Examples:  READ STRING S1 USING LAST\n                            READ STRING S3 USING 4 COLUMN 6\n                            READ STRING S0 USING * COLUMNS 1/15\n1                                            (7)\n\n     C.  SET and SHOW ESCAPE commands\n\n         1.  The pre-processor described in Section II below  uses  a\n             character called the ESCAPE character in order to signal\n             that  text substitution should be made in a command line\n             before WYLBUR executes it.  If no ESCAPE  character  has\n             been  set,  the  pre-processor  does not process command\n             lines  before  execution.   The  ESCAPE   character   is\n             initially  NULL so the pre-processor is never used until\n             you set an ESCAPE character.\n\n         2.  SET ESCAPE='<character>'\n\n             a.  The pre-processor will use <character> as the ESCAPE\n                 character.   Setting  the  ESCAPE  character  to  ''\n                 (NULL) turns off the  pre-processor.   Normally  the\n                 quotes  can  be  omitted.   However, some characters\n                 such as (),;'\"= blank and  the  lower  case  letters\n                 must  be  typed  in quotes if they are to be used as\n                 the ESCAPE character.\n\n             b.  Examples: SET ESCAPE '%'\n                           SET ESCAPE %\n                           SET ESCAPE ''\n                           SET ESCAPE\n\n         3.  The  current  value  of  the  ESCAPE  character  can  be\n             displayed at any time by using the command SHOW ESCAPE.\n\n     D.  SET and SHOW SKIP commands\n\n         1.  The pre-processor also uses a  second  character  called\n             the  SKIP  character  in  order  to  allow  you to enter\n             command lines that will have an ESCAPE or SKIP character\n             in it after the  pre-processor  has  finished  any  text\n             substitution.    The   character   following   the  SKIP\n             character in a  command  line  is  always  left  in  the\n             command line by the pre-processor.  The initial value of\n             the SKIP character is NULL.\n\n         2.  SET SKIP='<character>'\n\n             a.  The pre-processor will use <character> as  the  SKIP\n                 character.   If  the  ESCAPE  character is NULL, the\n                 SKIP character is ignored.  Quotes  can  be  omitted\n                 for  the  SKIP  character  just  as  for  the ESCAPE\n                 character.\n\n             b.  Examples:  SET SKIP $\n                            SET SKIP\n\n         3.  The current value of the SKIP character can be displayed\n             at any time by using the command SHOW SKIP.\n1                                            (8)\n\n     E.  SET and SHOW RESCAN COMMANDS\n\n         1.  The pre-processor can be directed  to  rescan  any  text\n             that it substitutes.  This could lead to infinite rescan\n             if an error is made.  Therefore, a RESCAN limit has been\n             defined  to force a stop so that infinite rescans cannot\n             occur.  The RESCAN count is initially set to 5.\n\n         2.  Rescans occur only when  a  pair  of  ESCAPE  characters\n             prevents   the   scan   pointer  from  moving  over  the\n             substituted value.  The rescan is begun at the start  of\n             the  substituted text, not at the start of the line (See\n             II.A.1 below).\n\n         3.  SET RESCAN=<integer>\n\n             a.  This sets the number of rescan substitutions allowed\n                 before the pre-processor terminates the scan.\n\n             b.  Example:  SET RESCAN 10\n\n         4.  The current RESCAN limit can be displayed at any time by\n             using the command SHOW RESCAN.\n\n II. Additions\n\n     A.  Pre-processor\n\n         1.  The pre-processor scans all WYLBUR commands, looking for\n             either (or  both)  of  two  significant  user-controlled\n             characters, the ESCAPE character and the SKIP character.\n             If  neither  of  these  two characters is present in the\n             text given to the  pre-processor,  no  change  is  made;\n             otherwise, there are five cases (described in the format\n             <text  into  the  pre-processor>  ->  <text  out  of the\n             pre-processor>, where '%' is assumed to  be  the  ESCAPE\n             character,  '$'  is assumed to be the SKIP character and\n             '|' denotes the scan pointer):\n\n             a.  |%<variable><text> -> <value>|<text>\n\n             b.  |%(<EXP>)<text> -> <value>|<text>\n\n             c.  |%%<variable><text> -> |<value><text>\n\n             d.  |%%(<EXP>)<text> -> |<value><text>\n\n             e.  |$<character><text> -> <character>|<text>\n\n         2.  Any substitutions or changes to a command are made  each\n             time  the command is executed.  If the command came from\n             a file, the file is not changed;  only  a  copy  of  the\n             command is changed and then executed.\n1                                            (9)\n\n         3.  All substitutions are completed before  the  command  is\n             executed.    No  substitutions  are  made  or  evaluated\n             dynamically as the command is executed.\n\n         4.  The  TERSE/VERBOSE  modes  of  typed  input   and   EXEC\n             processing  control whether the changed command is typed\n             before execution.  If the mode is TERSE for  the  source\n             of the command, the changed command is not typed.  If it\n             is VERBOSE, the changed command is typed.\n\n         5.  There is no overhead before  command  execution  if  the\n             ESCAPE  character  is  null.   If  there  is  an  ESCAPE\n             character,  a  translate and test is done on the command\n             line to locate and process  any  ESCAPE  characters  and\n             skip  characters.  If the text after an ESCAPE character\n             is not a  preprocessor  variable  or  an  expression  in\n             parentheses,  there will be no substitution and the text\n             (including the ESCAPE character) will not be changed.\n\n     B.  IF command\n\n         1.  Syntax:  IF ( <EXP> <RELOP> <EXP> ) <command>\n\n         2.  The relational operators (<RELOP>) allowed are  EQ,  NE,\n             LT,  LE, GT, and GE which correspond to tests for equal,\n             not equal, less than, less than or equal, greater  than,\n             and greater than or equal.\n\n         3.  The IF command evaluates the  relational  expression  in\n             parentheses.   If  the  result  is  true,  the <command>\n             following the parentheses is executed.  If the result is\n             false, the <command> is skipped without inspection.\n\n         4.  If CURRENT, NEXT, and/or PREVIOUS are  used  in  the  IF\n             expressions,  no  EXEC  break will occur if they are not\n             set or do not exist.  Instead, they will  be  given  the\n             value  -1.000 to allow you to test whether they exist or\n             not.\n\n         5.  If  the  <EXP>s are both line numbers or both  integers,\n             the values are compared algebraically.  If one is a line\n             number  and  one is an integer, the integer is converted\n             to  a  line  number  and   the   values   are   compared\n             algebraically.    Otherwise,   a   logical   compare  is\n             performed  after  converting both <EXP>s to  strings  of\n             the  same  length  and/or by adding blanks to the end of\n             the shorter string.\n\n         6.  Examples:  IF (W0 LT 0) COPY 'X' IN 1/20 TO 3000\n                        IF (W1 EQ LAST-5) EXEC 35\n1                                            (10)\n\n III.Sample Session Showing Use of ESCAPE Character and Arithmetic\n\n     ? show escape\n     NO ESCAPE CHAR\n     ? set value s0 'wyl001'\n     ? show value s0\n     'WYL001'\n     ? show space on &s0\n     &S0   : INVALID VOLUME.\n     ? set escape &\n     ? show space on &s0\n     WYL001\n     1193 TRKS, 143 EXTENTS\n     ? show escape\n     & - ESCAPE CHAR\n     ? set verbose\n     COMMAND? show space on &s0\n     SHOW SPACE ON WYL001\n     WYL001\n     1193 TRKS, 143 EXTENTS\n     COMMAND? set escape\n     COMMAND? show space on &s0\n     &S0   : INVALID VOLUME\n     COMMAND? show escape\n     NO ESCAPE CHAR\n     COMMAND? show value 10/3 10./3 nconvert(10./3)\n     3 3.333 3\n     COMMAND? show value 1 * 1, .01 * .01, 1/2, 1./2\n     1 0.000 0 0.500\n1                                            (11)\n\n IV. Exec File Examples\n\n     A.  WYL.CU.CTR.LIB(CHNGESTR)\n\n         1  ; SEE WYL.CU.CTR.LIB(PREPROC) FOR INFO AND CAUTIONS ABOUT\n         2  ; USING SOME OF THE FEATURES IN THIS EXEC FILE.\n         3  COMMENT CHANGE STRING S1 TO S2 IN LINE W0\n         4  SET EXEC VERBOSE LOG; THIS LETS YOU SEE WHAT'S HAPPENING\n         5  SET ESCAPE ''; TURN OFF ESCAPE CHARACTER\n         6  READ VALUE S1,S2,W0\n         7  IF (W0 EQ 0) EXEC 6 PAUSE\n         8  SET ESCAPE %; TURN ESCAPE CHARACTER ON TO SUBSTITUTE\n         9  CH '%S1' TO '%S2' IN %W0\n        10  EXEC 5\n\n     B.  WYL.CU.CTR.LIB(FINDCOL)\n\n         1  SET EXEC NOLOG TERSE\n         2  ; SEE WYL.CU.CTR.LIB(PREPROC) FOR INFO AND CAUTIONS ABOUT\n         3  ; USING SOME OF THE FEATURES IN THIS EXEC FILE.\n         4  COMMENT FIND COLUMNS OF A STRING IN A SPECIFIED LINE\n         5  COMMENT WHERE S0 IS THE STRING, W0 THE LINE\n         6  SET ESCAPE; TURN OFF ESCAPE CHAR.\n         7  READ VALUE S0,W0\n         8  IF (S0 EQ '') EXEC CLEAR; STOP IF NOTHING ENTERED\n         9  SET ESCAPE %; SET THE ESCAPE CHAR TO DO SUBSTITUTIONS\n        10  POINT %W0 NOLIST; SEE IF LINE W0 EXISTS\n        11  IF (* LT 0) EXEC 19; NO LINE IF * WAS NOT SET\n        12  READ STRING S1 USING *\n        13  SET VALUE W1 INDEX(S1,S0)\n        14  IF (W1 EQ 0) EXEC *+3\n        15  SHO VALUE W1 W1+SIZE(S0)-1\n        16  EXEC 6\n        17  COMMENT '%S0' NOT IN LINE %W0\n        18  EXEC 6\n        19  COMMENT LINE %W0 NOT IN FILE\n        20  EXEC 6\n1                                            (12)\n\n     C.  WYL.CU.CTR.LIB(ASMEXEC)\n\n         1  SET EXEC NOLOG TERSE\n         2  ; THIS EXEC FILE WILL REPLACE LABELS IN AN EXEC FILE\n         3  ; WITH THE APPROPRIATE LINE NUMBER. LABELS MUST BE\n         4  ; OF THE FORM LABELNN WHERE NN IS A 2-CHARACTER FIELD\n         5  ;\n         6  ; SEE WYL.CU.CTR.LIB(PREPROC) FOR INFO AND CAUTIONS ABOUT\n         7  ; USING SOME OF THE FEATURES IN THIS EXEC FILE.\n         8  IF(LAST NE 0)EXEC 12; BRANCH IF FILE TO ASSEMBLE\n         9  COMMENT ** ENTER USE FOR ACTIVE FILE **\n        10  READ\n        11  EXEC 8; GO MAKE SURE FILE WAS ENTERED\n        12  SET VALUE W0 0\n        13  COMMENT ** BEGIN ASSEMBLY **\n        14  COMMENT\n        15  SET ESCAPE &\n        16  SET LENGTH 132\n        17  POINT 'LABEL' 1/5 (1) IN &W0/LAST NOL; FIND NEXT LABEL\n        18  IF(* LT 0)EXEC 33; CHECK FOR END OF LABELS\n        19  READ STRING S0 USING *;PUT THE LINE IN A STRING VARIABLE\n        20  SET VALUE W0 *;SAVE CURRENT LINE NUMBER\n        21  IF(SIZE(S0) LT 7)EXEC 31;CHECK FOR FUNNY LINE\n        22  SET VALUE S1 SUBSTR(S0,1,7);PICK OFF LABEL FIELD\n        23  CH 1/7 TO '' IN &W0 NOLIST; DELETE LABEL FIELD ON LINE\n        24  CH ' '1 TO '' IN &W0 NOL; ALSO DELETE BLANK AFTER LABEL\n        25  POINT '&S1' 1/7 (1) IN &W0/LAST NOL; SEE IF DUP LABEL\n        26  IF(* GT 0)COMMENT &S1 IS DUPLICATELY DEFINED\n        27  CH '&S1' TO '&W0' IN ALL NOL; REPLACE LABEL WITH LINENO\n        28  IF(* LT 0)COMMENT &S1 IN LINE &W0 IS UNREFERENCED\n        29  IF(* GE 0)COMMENT REPLACE &S1 WITH LINE NO. &W0\n        30  EXEC 17;GO FIND NEXT LABEL\n        31  SET VALUE W0 NEXT;SKIP PAST GARBAGE LINE\n        32  IF(W0 GE 0)EXEC 17\n        33  P 'LABEL' NOL; FIND UNDEFINED LABELS\n        34  IF( * LT 0)EXEC 38\n        35  COMMENT\n        36  COMMENT LINES BELOW REFER TO UNDEFINED LABELS\n        37  L 'LABEL';LIST MISSING LABELS\n        38  COMMENT\n        39  COMMENT ** END ASSEMBLY **\n        40  SET ESCAPE\n        41  EXEC CLEAR\n./ ADD NAME=TSO001\n1\n                                                    August 4, 1977\n WYLTSO changes:\n\n\n 1) New pre-processor variables added:\n\n    a) 'PROJECT' returns the string 'USXXXXX' for users with\n       TSO operator privilige, and 'XXXXXXX' for non-priviliged\n       users.\n    b) 'TERMINAL' returns the string 'TSO'.\n    c) 'PAGES' returns the number of pages currently in use by\n       your active file.\n    d) 'LINES' returns the number of lines in your active file\n       regardless of your DELTA or line numbering.\n    e) 'CP' returns the address of WYLTSO's CP (Control Page)\n       address in hex for those who know what to do with it.\n       This is an invalid variable for non-priviliged users.\n\n\n 2) Additional attention handling:\n\n    If the input is terminated by the ATTN SEQUENCE during an\n    input to any prompt (such as in COMMAND or COLLECT modes,\n    or in response to a READ command with the PROMPT option),\n    a real attention is simulated.  If you want the input to\n    contain the ATTENTION SEQUENCE, just terminate the input\n    with an additional blank (a space).\n\n    'SET ATTN <string-up-to-8-characters>' command sets the\n    ATTENTION SEQUENCE to the operand supplied.  'SET ATTN'\n    command (with no operands) clears the ATTN SEQUENCE.\n    'SHOW ATTN' command displays the attn sequence.  Default\n    is no ATTENTION SEQUENCE.\n\n\n 3) Disabling automatic COMMAND to COLLECT mode switch:\n\n    'SET NOCOLLECT' command disables the facility to switch to\n    COLLECT mode when an attention is encountered.  'SET COLLECT'\n    command enables the facility back -- This is the default mode.\n    'SHOW COLLECT' command displays the current mode.\n\n\n 4) Screen paging:\n\n    a) 'SET CRT' command enables screen paging -- The pause\n       chatracter is a single dot.  'SET NOCRT' command disables\n       screen paging -- NOCRT is the default mode.  'SHOW CRT'\n       command displays the current CRT mode.\n1\n    b) 'SET PAGESIZE/PS <integer-between-1-and-255>' command sets\n       the number of lines that can be printed without a pause on\n       a screen.  'SHOW PAGESIZE/PS' command displays the current\n       value of page-size -- Default is 25.\n\n    c) 'SET LINESIZE/LS <integer-between-1-and-133>' command sets\n       the screen width (i.e. characters per line) also to be used\n       for paging to compensate for long text to be contiinued on\n       a different line on the screen.  'SHOW LINESIZE/LS' command\n       displays the curren size of the screen width -- Default is\n       133.\n\n    d) For terminals which don't have the automatic wrap-around\n       feature, in WRAP mode a CR/LF (carriage-return line-feed\n       sequence) will be inserted in the text to be displayed,\n       if the text is longer than the screen width.  This mode\n       can be set by the 'SET WRAP' command.  To dispable the\n       insertion of CR/LF's you can use the 'SET NOWRAP' command.\n       NOWRAP is the default mode.  'SHOW WRAP' displays the current\n       mode.\n\n    e) NonE of the screen paging features are in effect when a\n       LIST/POINT is being done with the NOCR option.\n\n    f) SET CRT/NOCRT/WRAP/NOWRAP/LS/PS commands as well as any\n       input from the terminal initialize the number of lines\n       printed on the screen to zero.\n\n\n 5) More control over the NOCR option:\n\n    'SET PAD' command sets the PAD mode, effective only for the\n    LIST/POINT command with the NOCR option.  In PAD mode all\n    lines listed will be padded on the right-hand-side with blanks\n    to a length specified by the LENGTH variable.  If a line is\n    longer than LENGTH no truncation is done.  'SET NOPAD' command\n    disables padding -- NOPAD is the default mode.  'SHOW PAD'\n    command displays the current mode.\n\n\n 6) With the 'DISPLAY <any-string>' command (a variation of the\n    'COMMENT' command) a line printed on the screen is not terminated\n    with a CR/LF (i.e. the cursor will remain at the end of the\n    line just displayed.)\n\n\n 7) It is now possible to read datasets with block size up to\n    13030 bytes.  Previously the limit was 3520.  You still cannot\n    save datasets with BLKSIZE larger than 3520.\n1\n 8) The response to 'SHOW USERS' command is slightly modified.\n\n\n 9) the response to 'SHOW DSNAMES' command when used with the\n    DATE and/or TYPE options is also slightly modified.\n\n\n Until this version is insatlled as the floor system, you can use it\n by typing 'CALL WYL.CU.VVV.WYLTSO(WYLBUR)' under TSO insteAd of\n 'WYLBUR' -- You will notice that no pagefile initialization is\n done.  Pages are initialized as they are needed in this version.\n\n\n Comments, suggestions are welcome!...  Problems are not, but will\n be taken care of...\n./ ADD NAME=TSO002\n1\n                                                 September 9, 1977\n WYLTSO changes:\n\n\n 1) Changes in Pre-Processor functions:\n\n    a) EXPAND function added.  This function returns its argument\n       with blanks inserted between each character.\n       e.g. EXPAND('hello') will return 'h e l l o'.\n\n    b) XLATE function added.  This function is a general trans-\n       lator.  It takes three arguments.  The first one is the\n       source string which is the xlatee.  The second argument\n       is a string which lists the characters to be xlated or\n       deleted.  The third string lists the characters to replace\n       the respective characters in the second arg.  If the third\n       argument is shorter than the second one the caharcters that\n       don't have xlations in the second argument are deleted\n       from the source.\n       e.g. XLATE('abcd','abc','ef') will return 'efd'.\n\n    c) CORE funtion added.  This is a variation on the TDUMP func-\n       tion.  CORE function takes only one integer argument and\n       returns the contents of that address (4 bytes) in integer.\n       This is useful in chaining thru control blocks.\n\n    d) DUPL function now accepts null argument or a zero duplica-\n       tion factor.  In both cases it returns the null string.\n\n    e) The SHEX function now returns a null string if the argument\n       is a null string rather than returning the char X'00'.\n\n 2) Changes in Editing features:\n\n    a) The MODIFY command  when  requested  with  the  UNNUMBER\n       option will no longer set the NOLIST option.\n\n    b) The CHANGE command with  the  increment  option  is  now\n       fixed  for  starting  patterns  that  contain alpahbetic\n       characters before digits when the digit characters don't\n       start with a zero; Blanks embedded in digit patterns are\n       no longer assumed to be zero but they are taken  as  the\n       character  ' '  -- only heading blanks before digits are\n       taken as zero when necessary.\n\n\n 3) New features:\n\n    a) The 'HELP ALL'  command  will  give  a  listing  of  all\n       available WYLBUR commands.  Note that some commands that\n       are listed are only available to systems programmers.\n\n1\n    b) COMMAND  RETRY  feature  is  now  available.   The  last\n       command that was typed to WYLBUR  can  be  modified  and\n       reissued  by typing a '$' followed by a Carriage Return,\n       or ending a command line  with  a  '$'  followed  by  an\n       ATTENTION.   Since  the  way TCAM handles attentions is\n       really poor features involving attention have not worked\n       properly. (e.g.   Switching between edit and modify modes,\n       exiting from edit or modify modes.)  Please use the ATTN\n       SEQUENCE  if you need to use attention for such uses, as\n       well as the COMMAND RETRY  feature.   When  you  request\n       COMMAND  RETRY  you  will be prompted for changes on the\n       command you had last typed.  After the command has  been\n       modified  when a Carriage Return is hit the command will\n       be reissued.  If an Attention is hit the  COMMAND  RETRY\n       request will be aborted.\n\n    c) 'PROFILE' command will display the current values set in\n       the User Profile Table.  Refer to Tso Terminal Guide for\n       individual fields.\n\n    d) During WYLBUR initialization Page Size and Line Size will\n       be initialized to the values that have been set by the\n       TERMINAL command of TSO.  If LINES option is used then\n       CRT will be set for WYLBUR also.   Changing Page Size and\n       Line Size in WYLTSO will not effect TSO TERMINAL values.\n\n    e) SUSPEND command will enable a user to \"LOGOFF\" without\n       loosing his active WYLBUR environment, (i.e. ACTIVE and\n       EXEC files, preprocessor variable values, ESCAPE charcter,\n       CURRENT line values, etc.)  Thus when the user calls WYLBUR\n       again the previous environment will be reconstructed.  It\n       is possible to loose the active environment if you logoff\n       from TSO, because the PAGE FILE that is used for ACTIVE\n       files is defined by a temporary dataset.\n\n    f) STACK command will allow a user to issue TSO commands\n       which will be pushed on a stack until the WYLBUR session\n       is terminated either with a LOGOFF or a SUSPEND command.\n       Once Wylbur is ended TSO will accept commands from the\n       command stack.  Note that the stack is LIFO.\n       e.g. STACK ALLOC FI(DD1) DA('SYS2.MACLIB') SHR\n\n    g) POP command will let you remove a command from the top of\n       the stack.  'POP ALL' command will flush the whole stack.\n\n\n Until this version is insatlled as the floor system, you can use it\n by typing 'CALL WYL.CU.VVV.WYLTSO(WYLBUR)' under TSO instead of\n 'WYLBUR' -- you will notice that no PAGEFILE initialization is\n done.  Pages are initialized as they are needed in this version.\n\n./ ADD NAME=WYLABEND\n1\n ABND(HEX)   MODULE          SAVEAREA  EXPLANATION\n ---------   -------------   --------  ----------------------------------\n ------------------------------------------------------------------------\n  210(0D2)   WYLBUR(BORV)    CVNRJE    NO ORVYL INTERFACE\n ------------------------------------------------------------------------\n  310(136)   WYLBUR(PCBS)    CVNRJE    INSUFFICIENT PAGES TO INITIALIZE\n  320(140)   WYLBUR(PCBS)    CVNRJE    NO DIRECT ACCESS VOLUMES\n ------------------------------------------------------------------------\n  410(19A)   WYLBUR(PCP)     CVNRJE    SPIE ROUTINE ENTERED, NO RESUME ADDRESS\n  420(1A4)   WYLBUR(PCP)     CVNRJE    MCAN WYLBUR COMMAND ISSUED\n  430(1AE)   WYLBUR(PCP)     CVNRJE    WORK AREA OVERFLOW\n  450(1C2)   WYLBUR(PCP)     CVNRJE    ILLEGAL PAGE JUNK\n  460(1CC)   WYLBUR(PCP)     CVNRJE    TIME'S UP, WYLBUR LOOPING...\n ------------------------------------------------------------------------\n  510(1FE)   WYLBUR(PDIO)    CVNRJE    INVALID  FORMAT 1 DSCB DURING OPEN\n  520(208)   WYLBUR(PDIO)    CVNRJE    READ REQUEST AND DCB NOT OPEN\n  530(212)   WYLBUR(PDIO)    CVNRJE    WRITE REQUEST AND DCB NOT OPEN\n  540(21C)   WYLBUR(PDIO)    CVNRJE    CLOSE REQUEST AND DCB NOT OPEN\n  550(226)   WYLBUR(PDIO)    CVNRJE    I/O ERROR DURING SHO DSN/DIR\n  560(230)   WYLBUR(PDIO)    CVNRJE    I/O SUBTASK ABENDED\n ------------------------------------------------------------------------\n  610(262)   WYLBUR(PDOS)    CVNRJE    ORVYL NOT SUPPORTED\n  620(26C)   WYLBUR(PDOS)    CVNRJE    ORVYL NOT SUPPORTED\n ------------------------------------------------------------------------\n  710(2C6)   WYLBUR(PGOS)    CVNRJE    NO FIRST LINE -- LOGIC ERROR\n ------------------------------------------------------------------------\n  810(32A)   WYLBURP(PGOP)   CVNRJE    INVALID CATALOG ENTRY FOR SHO COMMANDS\n  820(334)   WYLBURP(PGOP)   CVNRJE    CVADDER RETURNED NONPOSITIVE VALUE\n ------------------------------------------------------------------------\n  910(38E)   WYLBURP(PLOD)   CVNRJE    INSUFFICIENT PAGES TO LOAD PAGED CODE\n  920(398)   WYLBURP(PLOD)   CVNRJE    ROUTABLE MUST BE UPDATED AND REASSEMBLED\n  930(3A0)   WYLBURP(PLOD)   CVNRJE    PAGE FILE I/O ERROR DURING INITIALIZATION\n  940(3AA)   WYLBURP(PLOD)   CVNRJE    PAGE FILE I/O ERROR (LAST PAGED CODE)\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "HELP": {"ttr": 19207, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00Y\\x01\\x19#\\x0f\\x01\\x19#\\x0f\\x18\\x18\\x16R\\x16R\\x00\\x00\\xe6\\xe8\\xd3\\xc2\\xe4\\xd9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2019-08-18T00:00:00", "modifydate": "2019-08-18T18:18:59", "lines": 5714, "newlines": 5714, "modlines": 0, "user": "WYLBUR"}, "text": "./ ADD NAME=GENWYL\n=FILES\n)F FUNCTION -\n   WYLBUR FILES --- ACTIVE-EXTERNAL-EXEC\n\n          THE TERM \"FILE\" IS USED TO DESCRIBE ANY COLLECTION OF\n          TEXT (WHICH MIGHT BE A LETTER,  A  LIST  OF  DATA,  A\n          REPORT, OR A COMPUTER PROGRAM).\n\n   ACTIVE\n          A FILE IS CALLED AN \"ACTIVE FILE\" WHILE IT IS HELD  IN\n          THE  ACTIVE  PART OF THE COMPUTER'S MEMORY AND YOU ARE\n          WORKING ON IT.  WHILE IN COLLECT MODE, YOU MAY  ACCUM-\n          ULATE  LINES OF TEXT INTO THIS FILE.  THIS IS THE ONLY\n          FILE TO WHICH YOU MAY MAKE  TEXT  MODIFICATIONS.   THE\n          MAXIMUM NUMBER OF LINES IN THE ACTIVE FILE IS SOMWHERE\n          BETWEEN  5,000  AND 10,000 (DEPENDING ON THE NUMBER OF\n          EMBEDDED BLANKS).\n\n   EXTERNAL\n          A FILE IS CALLED AN EXTERNAL FILE WHEN IT  IS  STORED\n          ON  A  DISK.  WYLBUR HAS COMMANDS WHICH ENABLE YOU TO\n          \"SAVE\" YOUR ACTIVE FILE ONTO A DISK AND \"USE\" A  COPY\n          OF  IT (BRING A COPY OF IT TO YOUR ACTIVE FILE) LATER\n          IN THE SESSION OR IN A LATER  SESSION.   ONCE  SAVED,\n          THE FILE WILL REMAIN ON DISK UNTIL YOU DELETE IT WITH\n          A  \"SCRATCH\"  COMMAND  IF  YOU  ENTERED  THE  \"CATLG\"\n          OPERAND  ON  THE  \"SAVE\" COMMAND.  IF THE DATA SET IS\n          NOT CATALOGUED IT WILL DISAPPEAR DURING THE FOLLOWING\n          MORNINGS BRINGING UP OF THE COMPUTER.  YOU  MAY  ALSO\n          RETRIEVE A COPY OF AN EXTERNAL FILE THAT SOMEONE ELSE\n          HAS  CREATED,  PROVIDING  YOU  KNOW  HIS/HER  USERID.\n          NORMALLY  IT  IS  NOT  REQUIRED TO KNOW THE DISK PACK\n          NAME THAT CONTAINS THE EXTERNAL FILE BECAUSE  ONE  OF\n          THE  DEFAULTS  AT  SIGNON  TIME IS TO SET \"VOL=CATLG\"\n          WHICH TELLS WYLBUR TO LOOK THROUGH  THE  CATALOG  FOR\n          THE  VOLUME ID.  THIS DEFAULT DOES YOU NO GOOD IF THE\n          DATA SET IS NOT CATALOGUED AND YOU MUST  TELL  WYLBUR\n          THE VOLUME ID IN THIS CASE.\n\n   EXEC (EXECUTE)\n          THERE IS ANOTHER TYPE OF ACTIVE FILE CALLED  AN  EXEC\n          (EXECUTE) FILE, WHICH IS STORED IN THE SAME WAY AS AN\n          ACTIVE  FILE,  BUT  IN ANOTHER PART OF THE COMPUTER'S\n          MEMORY.   THIS  FILE  CAN  CONTAIN  DATA  OR   WYLBUR\n          COMMANDS.   WHEN IT CONTAINS COMMANDS AND THE FILE IS\n          EXECUTED, THE COMMANDS EXECUTE IN THE ORDER IN  WHICH\n          THEY  APPEAR IN THE FILE.  WHEN THE EXEC FILE IS USED\n          TO HOLD DATA, THE DATA IS NORMALLY JUST  COPIED  FROM\n          THE  EXEC  FILE  INTO  THE  ACTIVE  FILE.  THIS IS AN\n          EXTREMELY FAST WAY TO DO A  MERGE  OF  TWO  DATASETS.\n          THE  MAXIMUM NUMBER OF LINES THAT CAN BE CONTAINED IN\n          THE EXEC FILE IS AROUND 150 (DEPENDING ON THE  NUMBER\n          OF EMBEDDED BLANKS).\n=DSNAMES\n)F FUNCTION -\n          WYLBUR  DATA  SETS  HAVE,  IN   GENERAL,   THE   FORM:\n                   UUUUU.NAME\n          WHERE UUUUU IS YOUR USER ID AND NAME IS  ANY  TRAILING\n          QUALIFIER.    IT  IS  SELDOM  NECESSARY TO SPECIFY THE\n          ENTIRE DSNAME IN COMMANDS SINCE WYLBUR WILL  CONSTRUCT\n          ALL  OR PART OF THE NAME FOR YOU.  HOWEVER, THE DSNAME\n          OPERAND MAY NEVER BE OMITTED AND IT  MAY  NOT  CONTAIN\n          IMBEDDED  BLANKS.   NORMALLY  YOU  MAY SPECIFY \"SAVE *\n          REPLACE\" TO REPLACE THE <EXTERNAL FILE> MOST  RECENTLY\n          ACCESSED THROUGH A \"USE\" COMMAND.\n\n          WYLBUR  MAINTAINS  THREE  VALUES   TO   BE   USED   IN\n          CONSTRUCTING  DATA  SET NAMES.  THESE ARE: USERID (NOT\n          NECESSARILY THE ID TO WHICH THE USER IS LOGGED ON),  A\n          PREFIX  (A DSNAME), AND A PDS MEMBER NAME.  HEREAFTER,\n          THESE FIELDS WILL BE REFERRED TO AS THE SAVED  USERID,\n          PREFIX, AND SAVED MEMBER FIELDS.\n\n          THE VALUES IN THE THREE FIELDS MAY BE SET INDIVIDUALLY\n          BY THE USER WITH THE FOLLOWING COMMANDS:\n                   SET USER UUUUU\n                   SET PREFIX <PREFIX>\n                   SET MEMBER <MEMBER>\n          AND THE CURRENT VALUE OF THESE FIELDS MAY BE DISPLAYED\n          WITH SIMILAR \"SHOW\" COMMANDS.  THE SYNTAX OF \"SET\" AND\n          \"SHOW\" ARE DOCUMENTED  ELSEWHERE.   THE  SAVED  USERID\n          FIELD  IS  SET DURING THE LOGON PROCEDURE.  THE PREFIX\n          AND MEMBER FIELDS ARE SET WITH THE USE COMMAND.\n\n          THE \"USE\", \"SAVE\",  \"SCRATCH\",  AND  UTILITY  COMMANDS\n          ALWAYS  USE  THE  CURRENT  VALUES  OF THE SAVED USERID\n          FIELD TO CONSTRUCT A STANDARD WYLBUR DSNAME UNLESS YOU\n          OVERRIDE THEM IN THE COMMAND.  YOU MAY TAKE  ADVANTAGE\n          OF  THE  PREFIX  FIELD BY SPECIFYING \"*\" IN THE DSNAME\n          OPERAND.  ADDITIONALLY, YOU MAY ADD ON TO THE  CURRENT\n          PREFIX  VALUE  BY  SPECIFYING \"*.STRING\" AS THE DSNAME\n          OPERAND.   THIS  WILL  RESULT   IN   \".STRING\"   BEING\n          CONCATENATED  WITH THE CURRENT PREFIX.  THE PREFIX AND\n          MEMBER FIELDS HAVE BEEN SET UP SO  THAT  YOU  NORMALLY\n          NEED  TYPE  ONLY \"SAVE *\" TO SAVE THE <ACTIVE FILE> AS\n          THE SAME NAME USED WITH THE USE COMMAND.\n\n          THE  SAVED  MEMBER  FIELD  IS  USED  BY  WYLBUR   WHEN\n          ACCESSING  A  PDS UNLESS A MEMBER NAME IS SPECIFIED IN\n          THE COMMAND OPERAND.  SPECIFYING (MEMBER) AT  THE  END\n          OF  THE  DSNAME  OPERAND  OVERRIDES THE VALUE IN SAVED\n          MEMBER.   SPECIFYING  A  MEMBER  NAME  OF   ()   ALONE\n          OVERRIDES  SAVED  MEMBER  WITH A NULL VALUE.  THUS, TO\n          USE THE CURRENT PREFIX, BUT IGNORE THE  CURRENT  SAVED\n          MEMBER, YOU WOULD SPECIFY:\n\n                   COMMAND * ()\n\n          YOU MAY ALWAYS OVERRIDE THE SAVED USERID FIELD IN  THE\n          COMMAND  WITHOUT HAVING TO USE THE CURRENT PREFIX.  DO\n          THIS BY SPECIFYING THE KEYWORD OPERAND:\n\n                   USER UUUUU\n\n         SOMEWHERE IN THE COMMAND LINE AFTER THE DSNAME OPERAND.\n\n          TO ACCESS A NON-WYLBUR DATA SET,  SPECIFY  THE  ENTIRE\n          DSNAME BY ENCLOSING THE NAME IN QUOTES.\n                   EXAMPLE:\n                                  'DSNAME'\n\n          THE SAVED USERID IS NOT USED FOR CONSTRUCTING  A  DATA\n          SET  NAME  ENCLOSED  IN  QUOTES.  THE QUOTED DSNAME IS\n          ALSO VALID IN PREFIX.\n\n          THE DSNAME OPERAND ITSELF MAY CONTAIN CERTAIN  SPECIAL\n          CHARACTERS  AS  ABBREVIATIONS.  THE SPECIAL CHARACTERS\n          USED FOR THIS PURPOSE ARE:\n\n             $DSNAME  USED INSTEAD OF 'DSNAME' UNLESS THE DSNAME\n                      CONTAINS DELIMITER CHARACTERS (BLANK, COMMA,\n                      =) ;\n             #MEMBER  USED INSTEAD OF (MEMBER) ;\n\n          THUS, THE  GENERAL  FORMS  OF  SPECIFYING  THE  DSNAME\n          OPERAND IN COMMAND LINES ARE:\n\n                   'UUUUU.XXXX'\n                   $UUUUU.XXXX\n                   #TEXT\n                   $UUUUU.XXXX(MEMBER)\n\n          THE PREFIX AND SAVED MEMBER MAY BE SET  BY  SPECIFYING\n          THE   OPTIONAL  COMMAND  OPERAND  SET.   WHEN  SET  IS\n          SPECIFIED IN A COMMAND THAT ACCESSES AN EXTERNAL  DATA\n          SET,  THE DSNAME IS CONSTRUCTED AND THE ENTIRE COMMAND\n          LINE  IS  SCANNED  FOR  SYNTACTICAL  AND   CONFLICTING\n          SPECIFICATION  ERRORS.  THEN THE TWO FIELDS ARE SET TO\n          THE VALUES CONTAINED IN THE CONSTRUCTED  DSNAME.   THE\n          PREFIX FIELD TAKES THE VALUE OF THE PART OF THE DSNAME\n          FOLLOWING  THE  USERID  BUT EXCLUDING ANY MEMBER NAME.\n          THAT IS, FOR A CONSTRUCTED DSNAME OF:\n\n                   UUUUU.XYZ(A1)\n\n          THE PREFIX FIELD IS SET TO \"XYZ\" AND THE SAVED  MEMBER\n          FIELD BECOMES \"A1\".  IF THE MEMBER NAME IS NULL (FOR A\n          SEQUENTIAL  DATA  SET),  SAVED  MEMBER IS SET TO NULL.\n          THE SAVED USERID IS NOT CHANGED  BY  THE  SET  OPTION.\n          THIS  FIELD  MAY  ONLY  BE  CHANGED  BY THE \"SET USER\"\n          COMMAND.\n=LINE#\n)F FUNCTION -\n\n         LINE NUMBERS\n\n          LINE NUMBERS MAY BE EXPRESSED IN  WYLBUR  COMMANDS  IN\n          SEVERAL WAYS.  THE SIMPLEST WAY IS BY DEFAULT AS SHOWN\n          IN  THE  EXAMPLE BELOW.  THE DEFAULT IS 1 FOR BOTH THE\n          DELTA AND THE FIRST LINE NUMBER.\n\n                   COMMAND?  LIST F (CR)\n\n          LINE  NUMBERS  MAY  BE   A   CONSTANT   OR   ARITHMETIC\n          EXPRESSION.  THERE ARE ALSO 6 SYMBOLIC LINE NUMBERS FOR\n          THE ACTIVE AND EXEC FILES.\n\n         CONSTANT\n\n          THE CONSTANT  MAY  BE  ANY  LINE  NUMBER  OF  THE  FORM\n          NNNNN.NNN.  EACH  OF THE FOLLOWING IS AN EXAMPLE OF THE\n          SAME LINE NUMBER.\n\n                   00032.000      32.\n                      32.000      32\n\n         ARITHMETIC EXPRESSIONS\n\n          YOU  MAY  REFER  TO  A  LINE  NUMBER  WITH  A   SIMPLE\n          ARITHMETIC  EXPRESSION  HAVING  A  +  OR  -.  29+3 AND\n          100-68 ARE VALID LINE NUMBERS; THEY BOTH REFER TO LINE\n          32.  THERE ARE SOME RESTRICTIONS ON EXPRESSING A  LINE\n          IN THIS FORM.\n\n         1.  THERE CAN BE NO BLANKS.  30 + 2 IS NOT A VALID\n             LINE NUMBER.\n\n         2.  THE RESULTANT NUMBER MUST BE A VALID LINE NUMBER\n             BETWEEN 0 AND 99999.999.  30+2 IS A VALID   LINE\n             NUMBER WHETHER A FILE HAS A LINE NUMBERED 32  OR\n             NOT, BUT 30-32 IS NOT A VALID LINE NUMBER.\n\n         3.  THERE CAN ONLY BE ONE  + OR -. AN EXPRESSION SUCH\n             AS 30+4-2 IS NOT ALLOWED.\n\n          IF  YOU  EXPRESS  A  LINE  NUMBER  AS  AN   ARITHMETIC\n          EXPRESSION  IN A COMMAND, WYLBUR REPLIES WITH THE LINE\n          NUMBER WHICH CORRESPONDS TO IT.\n\n                   COMMAND?  COLLECT 30+2\n                      32.    ?\n\n         SYMBOLIC LINE NUMBERS\n\n         THERE ARE SIX POINTERS TO LINES IN THE ACTIVE AND EXEC\n         FILES CALLED SYMBOLIC LINE NUMBERS.\n\n                   FIRST          - FIRST LINE IN A FILE\n                   LAST           - LAST LINE IN A FILE\n                   END            - LAST LINE + DELTA\n                   CURRENT OR *   - LAST LINE EDITED\n                   PREVIOUS       - LINE BEFORE CURRENT\n                   NEXT           - LINE AFTER CURRENT\n\n          CONSIDER A HYPOTHETICAL  FILE  NUMBERED  CONSECUTIVELY\n          FROM  1  TO  10  WITH  A  DELTA OF 1.  THE FIRST THREE\n          SYMBOLIC LINE NUMBERS ARE:\n\n                   FIRST = 1\n                   LAST  = 10\n                   END   = 11\n\n          END DOES NOT POINT TO AN EXISTING LINE; IT  POINTS  TO\n          THE  LINE  NUMBER  OF THE NEXT LINE TO BE ADDED TO THE\n          END OF A FILE.\n\n          THE NEXT THREE SYMBOLIC LINE NUMBERS  (CURRENT,  NEXT,\n          AND  PREVIOUS) MAY OR MAY NOT BE SET, DEPENDING ON THE\n          ACTIONS YOU HAVE TAKEN.\n\n          THE <CURRENT LINE POINTER> IS A SYMBOLIC  LINE  NUMBER\n          WHOSE  VALUE  IS  THE  NUMBER  OF THE LAST LINE EDITED\n          (ACTIVE FILE) OR EXECUTED (EXEC FILE).   THE  <CURRENT\n          LINE  POINTERS>  FOR THE ACTIVE FILE AND EXEC FILE ARE\n          SEPARATE AND DISTINCT.\n\n          THE FOLLOWING COMMANDS  WILL  SET  THE  VALUE  OF  THE\n          <CURRENT LINE POINTER>:\n                   CHANGE         JUSTIFY\n                   COLLECT        MODIFY\n                   COPY           MOVE\n                   EDIT           POINT\n                   SET            SHOW SIZE\n\n\n          FETCHING A FILE WITH A \"USE\" COMMAND DOES NOT SET  THE\n          POINTER.   NOR  DOES  AN ATTEMPT TO EDIT A VOID RANGE.\n          THE SYMBOL (*) OR THE WORD CURRENT BOTH REFER  TO  THE\n          <CURRENT  LINE POINTER>.  EITHER SYMBOL MAY BE USED IN\n          DESIGNATING A <RANGE> OR A LINE.\n\n\n          SOMETIMES THE VALUE OF THE <CURRENT LINE POINTER> WILL\n          NOT BE SET.  FOR EXAMPLE, IF THERE  IS  NO  ACTIVE  OR\n          EXEC  FILE,   THERE  WILL  BE NO CURRENT LINE POINTER.\n          TWO OTHER  <SYMBOLIC  LINE  NUMBERS>,  \"PREVIOUS\"  AND\n          \"NEXT\",  ARE  DEPENDENT  ON \"CURRENT\" AND SOME OBVIOUS\n          RESTRICTIONS APPLY.  FOR INSTANCE, IF THE VALUE OF THE\n          <CURRENT LINE POINTER> IS THE LAST  LINE  OF  A  FILE,\n          THERE IS NO \"NEXT\".\n\n          \"*\" MAY BE USED IN PLACE OF \"CURRENT\" WHEN USED  IN  A\n          RANGE,  BUT  WHEN  USED  IN SPECIFYING A <DSNAME>, \"*\"\n          MEANS THE CURRENTLY SET  PREFIX,  AS  IN  THE  COMMAND\n          \"SAVE * REPLACE\".\n\n          THE VALUE OF \"*\" IS ASSUMED TO  REFER  TO  THE  ACTIVE\n          FILE  EXCEPT  WHEN THE EXEC OPTION IS SPECIFIED IN THE\n          COMMAND.  IN THAT CASE, THE EXEC FILE IS ASSUMED.\n\n          THE COMMANDS  \"SET  *\",  \"SHOW  *\",  AND  \"POINT\"  ARE\n          ASSOCIATED  WITH THE <CURRENT LINE POINTER> AND MAY BE\n          USED TO DISPLAY OR CHANGE THE VALUE OF IT.\n\n          ONCE AGAIN, IF YOU ARE CREATING A  FILE  AND  ENTERING\n          LINES, \"CURRENT\" OR \"*\" POINTS TO THE LAST LINE NUMBER\n          TYPED  BY  WYLBUR.   BUT  IF  YOU HAVE JUST FETCHED AN\n          EXTERNAL FILE, THE CURRENT LINE IS NOT SET.   PREVIOUS\n          AND  NEXT  ARE  ENTIRELY  DEPENDENT  ON  CURRENT.  FOR\n          INSTANCE, IF YOU HAVE JUST  TYPED  LINE  10  INTO  THE\n          HYPOTHETICAL  FILE,  CURRENT=11=END,  PREVIOUS=10, AND\n          NEXT=12.\n\n         REFERRING TO LINE NUMBERS\n\n          VERY OFTEN IT IS HANDIER TO REFER TO A LINE NUMBER  BY\n          ITS  SYMBOLIC  POINTER  RATHER THAN ITS ACTUAL NUMBER.\n          THIS FEATURE CAN BE EXTENDED BY  USING  SYMBOLIC  LINE\n          NUMBERS IN ARITHMETIC EXPRESSIONS TO REFER TO ONE LINE\n          OR A RANGE OF LINES.\n\n                   INSERT FIRST-.1\n                   LIST */LAST\n                   DELETE *, *+4, *+6\n=STRINGS\n)F FUNCTION -\n          WITHIN  WYLBUR,   STRINGS   OF   CHARACTERS   MAY   BE\n          REPRESENTED  BY  ENCLOSING THE STRINGS IN QUOTE MARKS.\n          THE QUOTES MAY BE EITHER SINGLE (') OR DOUBLE(\"),  BUT\n          NOT A MIXED COMBINATION OF THE TWO FORMS.\n\n                   EXAMPLE:\n                           'THIS' OR \"THIS\" BUT NOT 'THIS\"\n=KEYS\n)F FUNCTION -\n         SHIFT KEY\n\n          THERE IS A DISTINCTION  BETWEEN  THE  EFFECT  OF  THE\n          SHIFT  KEY AT THE TERMINAL AND ITS EFFECT ON A WYLBUR\n          TEXT.  THE  SHIFT  KEY  OPERATES  JUST  AS   ON   ANY\n          TYPEWRITER  AS FAR AS THE TERMINAL COPY IS CONCERNED,\n          BUT ITS EFFECT ON THE  WYLBUR  TEXT  DEPENDS  ON  THE\n          WYLBUR  MODE  AND ON THE COMMAND \"SET UPLOW\" AND \"SET\n          UPPER\".  THE USE OF THIS KEY  HAS  NO  EFFECT  DURING\n          COMMAND  MODE  AND ALL ALPHA CHARACTERS ARE CONVERTED\n          TO UPPER CASE.  IN COLLECT MODE, IT IS TREATED IN TWO\n          WAYS.\n\n         1. \"UPLOW\" TERMINALS\n          IF YOU HAVE USED THE COMMAND \"SET UPLOW\", WYLBUR WILL\n          ACCEPT UPPER AND LOWER CASE LETTERS.  IF YOU HAVE NOT\n          USED THIS COMMAND, ALL ALPHABETIC CHARACTERS ARE CON-\n          VERTED TO UPPER CASE.  UPPER CASE IS THE  DEFAULT  SO\n          IT  IS  NECESSARY  TO DO A \"SET UPLOW\" IF YOU WISH TO\n          HAVE  LOWER  CASE  LETTERS  AS  PART  OF  YOUR  TEXT.\n          (REMINDER:  ALL JCL MUST BE IN UPPER CASE ONLY.)\n\n         2. \"UPPER-CASE\" TERMINALS\n          ON \"UPPER-CASE\" ONLY TERMINALS, ALTHOUGH \"SET  UPLOW\"\n          IS ACCEPTED AS A COMMAND, THE USE OF THE SHIFT KEY IS\n          NOT AT ALL THE SAME, EXCEPT WHEN USED FOR UPPER- CASE\n          SPECIAL  CHARACTERS,  SUCH  AS  '#',  '<',  '>', ETC.\n          OTHERWISE THERE  IS  NO  CORRESPONDENCE  BETWEEN  THE\n          SHIFTED  LETTER  YOU TYPE AND THE CHARACTER DISPLAYED\n          ON THE SCREEN AND UNDERSTOOD BY WYLBUR.\n=RANGES\n)F FUNCTION -\n\n         SPECIFYING RANGES\n\n          VARIOUS COMMANDS USE RANGE  OPTIONS.   THESE  COMMANDS\n          MUST  ALL  REFER  TO  AN EXPLICIT RANGE, BUT IT MAY BE\n          IMPLIED BY THE DEFAULT  RANGE  ALL  IN  THE  FOLLOWING\n          COMMANDS.  HOWEVER IN ALL OF THESE, YOU MAY SPECIFY AN\n          EXPLICIT RANGE TO OVERRIDE THE DEFAULT.\n\n                   CHANGE         LOAD           COPY\n                   MODIFY         REPLACE        EDIT\n                   NUMBER         RUN            LIST\n                   POINT\n\n          IN THE  \"MOVE\",  \"DELETE\",  \"CENTER\",  \"JUSTIFY\",  AND\n          \"ALIGN\" COMMANDS YOU MUST SPECIFY AN EXPLICIT RANGE.\n\n         EXPLICIT RANGE\n\n          AN  EXPLICIT  RANGE  IS  A  LINE  OR  GROUP  OF  LINES\n          IDENTIFIED BY ITS LINE NUMBERS.  THIS TYPE OF RANGE IS\n          DENOTED IN WYLBUR BY GIVING THE NUMBERS OF  THE  FIRST\n          AND LAST LINES SEPARATED BY A SLASH.\n\n         COMMAND?  LIST 1/10 (CR)\n\n          THE RANGE IN THE COMMAND ABOVE INCLUDES ALL LINES FROM\n          1.000 TO 10.000.  A SINGLE LINE IS REFERRED TO BY  ITS\n          NUMBER ALONE.\n\n         COMMAND?  REPLACE 79.3 (CR)\n\n          THROUGH THE USE OF DISJOINT EXPLICIT RANGES, THE  USER\n          CAN  SPECIFY  UP  TO  ELEVEN DIFFERENT LINE NUMBERS OR\n          RANGES IN ONE COMMAND.  THE LIST  CAN  CONTAIN  SINGLE\n          LINES  OR  GROUPS,  AND  RANGES  CAN OVERLAP, BUT EACH\n          GROUP COUNTS AS TWO OF THE NUMBERS ALLOWED.\n\n         COMMAND?  LIST 1,7,4,3.6,6/10,5 (CR)\n\n          THIS COMMAND WILL LIST LINE 1 FOLLOWED BY LINE 7, THEN\n          LINE 4, LINE 3.6, LINES 6 THROUGH  10  INCLUSIVE,  AND\n          THEN  LINE  5.   IN  THIS EXAMPLE, SEVEN OF THE ELEVEN\n          RANGES ALLOWED ARE USED.\n\n\n         EXPLICIT RANGE -- COUNT FIELD\n\n          ANOTHER WAY OF DENOTING AN EXPLICIT RANGE OF LINES  IS\n          BY  USING  THE  FIRST  LINE NUMBER FOLLOWED BY A COUNT\n          FIELD IN PARENTHESES.  THE COUNT MUST  BE  A  POSITIVE\n          INTEGER.\n\n         COMMAND?  L 22(6) (CR)\n\n          THIS COMMAND WOULD LIST SIX LINES STARTING AT LINE 22.\n          IT IS NOT NECESSARILY THE SAME RANGE AS  22/27  UNLESS\n          THE NEXT 6 LINES ARE NUMBERED 22, 23, 24, 25, 26 & 27.\n          LIST  22(6)  MIGHT PRODUCE A LIST OF LINES 22, 39, 43,\n          62, 89 & 101 IF THOSE WERE THE NEXT SIX LINES  IN  THE\n          FILE.\n\n          FIRST (F) AND LAST (L) CAN ALSO BE USED  TO  DEFINE  A\n          RANGE:\n\n         FIRST/LAST OR F/L OR ALL\n         1.05/LAST OR 1.05/L\n         FIRST/10.0 OR F/10.0\n\n          AS IS SEEN IN THIS EXAMPLE, THE WORD ALL HAS THE  SAME\n          MEANING AS FIRST/LAST.\n\n\n         EXPLICIT RANGE -- SYMBOLIC LINE NUMBERS\n\n          SYMBOLIC LINE NUMBERS, SUCH AS \"CURRENT\",  \"PREVIOUS\",\n          AND  \"NEXT\",  CAN  BE  USED  TO  DEFINE A RANGE IF THE\n          CURRENT LINE HAS BEEN SET.   FOR  AN  EXPLANATION  AND\n          LIST  OF  ALL  VALID  SYMBOLIC LINE NUMBERS, SEE   THE\n          ENTRY FOR \"LINE#\".\n\n\n\n         ASSOCIATIVE RANGE\n\n          AN ASSOCIATIVE RANGE SPECIFIES  A  LINE  OR  GROUP  OF\n          LINES  EACH  OF  WHICH  CONTAINS  A  CERTAIN SERIES OF\n          CHARACTERS.   THIS  TYPE  OF  RANGE  IS  SPECIFIED  BY\n          ENCLOSING THE CHARACTER STRING WITHIN QUOTE MARKS  AND\n          INDICATING WHICH LINES SHOULD BE SEARCHED BY GIVING AN\n          EXPLICIT RANGE.  IF THE COMMAND HAS A DEFAULT RANGE OF\n          ALL,  ONLY  THE  ASSOCIATIVE  RANGE  NEED BE SPECIFIED\n          UNLESS YOU WISH TO OVERRIDE THAT DEFAULT.\n\n         USE OF QUOTES\n\n          A TERMINAL KEYBOARD HAS TWO TYPES OF  QUOTE  MARKS,  A\n          SINGLE  QUOTE  (')  AND A DOUBLE QUOTE (\").  EITHER OF\n          THESE MAY BE USED TO ENCLOSE THE CHARACTER STRING, BUT\n          CONSISTENCY MUST BE MAINTAINED.  THUS,  THE  FOLLOWING\n          ARE VALID ASSOCIATIVE RANGES.\n\n         \"VARIABLE\" IN ALL\n         'X*(15 A * B**2)' IN 1/10\n\n         THE FOLLOWING EXAMPLE, HOWEVER, IS NOT VALID.\n\n         \"VARIABLE'\n\n         ALSO NOTE THAT BLANKS ARE SIGNIFICANT IN AN ASSOCIATIVE\n         RANGE SPECIFICATION, SO THAT,\n\n         \" BLANKS ARE PART OF THE STRING \" IN 5/15\n\n                   AND\n\n         \"BLANKS ARE PART OF THE STRING\" IN 5/15\n\n         ARE NOT EQUIVALENT RANGE SPECIFICATIONS.\n\n          IF A QUOTE MARK APPEARS IN THE CHARACTER  STRING,  YOU\n          MUST  FOLLOW  SOME ADDITIONAL RULES.  IT IS EASIEST TO\n          ENCLOSE THE CHARACTER STRING IN  QUOTES  OF  THE  TYPE\n          OPPOSITE  OF  THOSE  APPEARING  WITHIN  THE  CHARACTER\n          STRING.   IF  THE  SAME TYPE OF QUOTES MUST BE USED TO\n          ENCLOSE THE  STRING,  TYPE  THOSE  QUOTE  MARKS  WHICH\n          APPEAR  IN  THE  CHARACTER  STRING  AS TWO CONSECUTIVE\n          INSTANCES OF THE QUOTE MARK.  FOR EXAMPLE:\n\n          \"DON'T\" IN ALL AND 'DON''T' IN ALL\n\n          ARE BOTH VALID WAYS TO DESIGNATE THE  RANGE  OF  LINES\n          WHICH CONTAIN THE CHARACTER STRING:   DON'T.\n\n          ANOTHER  QUALIFIER  THAT  MAY  BE  ADDED  IS  THE  NOT\n          CHARACTER (\u00ac).  THIS IS OPTIONAL AND, IF USED, DEFINES\n          A RANGE THAT CONSISTS OF ALL LINES  IN  THE  <EXPLICIT\n          RANGE> THAT DO NOT CONTAIN THE <STRING>.  EXAMPLE:\n                   L \u00ac'HERE' M/N IN 1/10\n          THE M/N PARAMETER CAN BE USED TO RESTRICT THE RANGE TO\n          A SPECIFIC SUBSET OF LINES, NAMELY, THOSE LINES (AS IN\n          THE ABOVE EXAMPLE) IN THE SET OF ALL  LINES  SPECIFIED\n          THAT  DO  NOT  CONTAIN  'HERE'  IN  A  GIVEN COLUMN OR\n          COLUMNS  (M/N CAN ALSO BE \"M\" ONLY, WHERE \"M\"  IS  THE\n          STARTING POSITION).  ANOTHER LEVEL OF SPECIFICATION OF\n          SEARCH CAN BE GIVEN, WHEREBY YOU RESTRICT NOT ONLY THE\n          COLUMN POSITIONS BUT ALSO THE ORDINAL POSITIONS IN THE\n          SET OF ALL LINES SPECIFIED.  FOR EXAMPLE:\n                   L \u00ac'HERE' 5 (3/7) IN 1/10\n          WOULD MEAN \"LIST THE THIRD THRU THE SEVENTH OCCURANCES\n          THAT DO NOT CONTAIN THE WORD 'HERE' STARTING IN COLUMN\n          5 IN THE RANGE OF LINES FROM 1  THRU  10.\"  THE  (3/7)\n          PARAMETER  MAY  ALSO  BE  EXPRESSED AS A SINGLE NUMBER\n          SUCH AS (3).\n=DELTA\n)F FUNCTION -\n\n          DELTA IS  THE  INCREMENT  WHICH  WYLBUR  ADDS  TO  THE\n          PRESENT  LINE  NUMBER TO GET THE NEXT ONE.  IT IS ALSO\n          USED AS A STARTING LINE NUMBER FOR A  FILE.   YOU  MAY\n          SET  A  VALUE FOR DELTA AT ANY NUMBER BETWEEN .001 AND\n          99999.999 INCLUSIVE.  IF YOU DO NOT SET  DELTA,  1.000\n          IS USED AS THE DEFAULT.  THE LINE NUMBER INCREMENT CAN\n          BE  SET  TO  A VALUE OTHER THAN 1.000 IN SEVERAL WAYS.\n          YOU MAY SET IT  TEMPORARILY  AT  THE  TIME  YOU  ENTER\n          COLLECT  MODE, OR YOU MAY RESET THE DEFAULT DELTA WITH\n          THE \"SET DELTA\" COMMAND.\n\n=EDITING\n)F FUNCTION -\n\n         CREATING A FILE\n\n          IN ORDER TO CREATE A FILE YOU MUST ENTER  THE  COLLECT\n          MODE.  YOU MAY ENTER COLLECT MODE BY STRIKING THE ATTN\n          KEY  OR  BY USING THE \"COLLECT\" COMMAND.  THE TERMINAL\n          IS IN COLLECT MODE WHEN IT IS PREPARED  TO  ACCUMULATE\n          LINES  OF TEXT TYPED AT THE TERMINAL AND STORE THEM IN\n          THE ACTIVE AREA OF THE COMPUTER'S MEMORY.  BEFORE  YOU\n          ENTER  COLLECT  MODE,  YOU  MAY WANT TO ADJUST CERTAIN\n          PARAMETERS FOR THE DURATION OF THE WYLBUR SESSION SUCH\n          AS TAB SETTINGS OR LINE LENGTH.  YOU MAY  DO  THIS  BY\n          USING THE \"SET\" COMMAND WITH APPROPRIATE OPTIONS.  THE\n          AVAILABLE OPTIONS ARE LISTED UNDER THE \"SET\" COMMAND.\n\n         GLOBAL PARAMETERS\n\n          GLOBAL PARAMETERS ARE FEATURES IN WYLBUR WHICH MAY  BE\n          SET  TO  AN  APPROPRIATE  VALUE AND WILL REMAIN SET AT\n          THAT VALUE FOR THE DURATION OF THE  SESSION  OR  UNTIL\n          RESET.    TWO  COMMANDS  ARE  ASSOCIATED  WITH  GLOBAL\n          PARAMETERS: \"SET\" AND \"SHOW\".  GLOBAL  PARAMETERS  ARE\n          CHANGED  BY  A \"SET\" COMMAND.  THE SHOW COMMAND MAY BE\n          USED (IN MOST CASES) TO SEE  WHICH  GLOBAL  PARAMETERS\n          ARE  IN  EFFECT.   SOME  PARAMETERS  DESCRIBED IN THIS\n          SECTION ARE ASSOCIATED WITH THE \"SHOW\" COMMAND BUT MAY\n          NOT BE SET BY THE USER.   FOR  ALL  AVAILABLE  OPTIONS\n          ENTER \"H SET\" OR \"H SHOW\".\n\n         CASE\n\n          CASE IS DETERMINED BY THE SHIFT KEY JUST AS IT  IS  ON\n          ANY ORDINARY TYPEWRITER.  HOWEVER, UNLESS YOU GIVE THE\n          COMMAND  \"SET UPLOW\" (SET UPPER AND LOWER CASE) BEFORE\n          STARTING IN COLLECT MODE, THE FILE WILL BE STORED  AND\n          LISTED  ONLY  IN  UPPER  CASE  NO  MATTER  WHICH  CASE\n          CHARACTERS  YOU  TYPE.  IF UPLOW IS IN EFFECT, YOU MAY\n          REVERT TO HAVING ALL ALPHABETIC  CHARACTERS  IN  UPPER\n          CASE  BY  GIVING THE \"SET UPPER\" COMMAND.  THE COMMAND\n          \"SHOW CASE\" CAN BE USED TO FIND OUT WHETHER  UPPER  OR\n          UPLOW IS CURRENTLY IN EFFECT.\n\n         EDITING AN ACTIVE FILE\n\n          WYLBUR IS A POWERFUL TEXT  EDITOR  WITH  A  NUMBER  OF\n          COMMANDS WHICH MAY BE USED TO CHANGE PART OF AN ACTIVE\n          FILE.   WITH  THESE  YOU  MAY  CHANGE OR DELETE SINGLE\n          CHARACTERS, GROUPS OF CHARACTERS, ENTIRE LINES OR EVEN\n          GROUPS OF LINES.  THE EDITING COMMANDS  EITHER  AFFECT\n          AN  ENTIRE  LINE OR PART OF A LINE.  THE COMMANDS THAT\n          AFFECT A WHOLE LINE ARE:\n\n                   DELETE         COPY           ALIGN\n                   INSERT         MOVE           JUSTIFY\n                   REPLACE        CENTER\n\n         COMMAND THAT AFFECT PART OF A LINE ARE:\n\n                   CHANGE         EDIT           MODIFY\n\n          ALL OF THESE COMMANDS MAY BE CONFINED TO ONE  LINE  OR\n          MAY  TREAT  AN  ENTIRE  FILE.  THE \"MODIFY\" COMMAND IS\n          USED TO INSERT, BLANK, DELETE, OR REPLACE PARTS  OF  A\n          SINGLE  LINE.   THE  \"EDIT\" COMMAND IS USED TO REPLACE\n          PARTS OF A SINGLE  LINE.   THE  \"CHANGE\"  COMMAND  CAN\n          EFFECT   CHANGES   EITHER  WITHIN  A  SINGLE  LINE  OR\n          THROUGHOUT A GROUP OF LINES.  BEFORE EDITING  A  FILE,\n          YOU  NEED TO KNOW HOW LINE NUMBERS MAY BE SPECIFIED IN\n          WYLBUR AND THE VARIOUS WAYS THERE ARE TO  REFER  TO  A\n          RANGE  OF  LINES.  THESE ARE NECESSARY IN ORDER TO USE\n          THE EDITING  COMMANDS  EFFICIENTLY.   TO  LEARN  ABOUT\n          SPECIFYING  RANGES  OF  LINES SEE THE SECTION ON\n          \"RANGES\".\n\n\n          *** FOR HINTS ON SHORT  CUT  METHODS  FOR  USE  DURING\n          ENTRY OF DATA.......SEE THE ENTRY \"EDHINTS\" *****\n=EDHINTS\n)F FUNCTION -\n\n         MAKING A SKELETON FOR A UTILITY JOB OR FORM LETTER.\n\n          THE \"CHANGE\" COMMAND CAN BE USED  TO  INSERT  A  NAME,\n          LOCATION,  ETC.,  AT  PREDETERMINED  PLACES IN A FILE.\n          FOR EXAMPLE, IF \"==\" IS PUT IN EACH PLACE IN THE  DATA\n          WHERE THE CHANGING INFORMATION IS TO GO, THE FOLLOWING\n          COMMAND  CAN  BE USED TO PRODUCE A JOB STREAM READY TO\n          RUN WITH FAR LESS CHANCE FOR ERRORS.\n\n                   COMMAND?  CH \"==\" TO \"UUUUU.MY.DS\" IN ALL NOL(CR)\n\n          IF, INSTEAD OF A JOB STREAM, THIS WERE  A  LETTER  THE\n          COMMAND TO PERSONALIZE THE FORM LETTER WOULD BE:\n\n                   COMMAND?  CH \"==\" TO \"MR. BOB JONES\" IN ALL NOL(CR)\n\n          IF YOU ARE ON A HARD COPY TERMINAL AND WANT A  LISTING\n          OF  THE  FORM  LETTER,  USE  THE FOLLOWING METHOD.  IN\n          ORDER TO PRODUCE A CLEAN COPY OF THE LETTER,  PLACE  A\n          MARKER CHARACTER AT THE END OF EACH PAGE,  CALL FOR AN\n          \"UNNUMBERED\"  LISTING,  AND  CHANGE  THE  PAPER BEFORE\n          STRIKING  CARRIAGE  RETURN.   IN  THIS   EXAMPLE   THE\n          CHARACTER '<' IS USED FOR A MARKER.\n\n                   COMMAND?  L UNN MARKER=< CLEAN(CR)\n\n          THE MARKER WILL NOT BE LISTED AND WYLBUR WILL STOP AND\n          WAIT FOR A (CR) EVERY TIME HE ENCOUNTERS THE SPECIFIED\n          CHARACTER APPEARING IN COLUMN 1.   THIS  GIVES  YOU  A\n          CHANCE TO CHANGE TO A NEW SHEET OF PAPER.\n\n         DUPLICATING LINES\n\n          THE \"COPY\" COMMAND CAN BE  USED  TO  DUPLICATE  SINGLE\n          LINES  OR  GROUPS  OF  LINES IF THE RANGE BEING COPIED\n          INTO IS  CONTAINED  WITHIN  THE  RANGE  BEING  COPIED.\n          STARTING WITH THE SAMPLE FILE:\n\n         1.   THIS IS THE LINE TO BE COPIED.\n\n         ISSUING THE COMMAND:\n\n         COMMAND? COPY 1 (3) TO 2\n\n         WILL PRODUCE THE FOLLOWING RESULT:\n\n         1.   THIS IS THE LINE TO BE COPIED.\n         2.   THIS IS THE LINE TO BE COPIED.\n         3.   THIS IS THE LINE TO BE COPIED.\n         4.   THIS IS THE LINE TO BE COPIED.\n\n\n         USING PRINTER CONTROL CHARACTERS\n\n          CERTAIN  SYMBOLS  ARE  RECOGNIZED  BY  THE  SYSTEM  AS\n          PRINTER CONTROL CHARACTERS IF  THEY  OCCUR  IN  COLUMN\n          ONE.   THEY  CONTROL  LINE-SPACING  AND  PAGE  EJECTS.\n          NORMALLY,  IF  THE  CORRECT  PRINT  COMMAND  IS  USED,\n          ANYTHING  IN COLUMN 1 WILL BE ASSUMED TO BE A CARRIAGE\n          CONTROL CHARACTER, AND COLUMN 1 WILL NOT BE PRINTED IN\n          THE LISTING.   SOME  OF  THE  COMMON  PRINTER  CONTROL\n          CHARACTERS AND THEIR FUNCTIONS ARE:\n\n              BLANK  SINGLE SPACE - SKIP TO NEXT LINE\n                1    PAGE EJECT - SKIP TO TOP OF NEXT PAGE\n                0    DOUBLE SPACE - SKIP TO NEXT LINE + 1\n                -    TRIPLE SPACE - SKIP TO NEXT LINE + 2\n                +    NO SKIP - USED FOR UNDERLING\n\n\n         PAGE BOUNDARIES\n\n          WYLBUR WILL GIVE YOU THE ASSEMBLED DEFAULT  NUMBER  OF\n          LINES PER PAGE (NORMALLY 60) DEPENDING ON WHICH \"PRINT\"\n          COMMAND YOU USE.  IF YOU WANT FEWER LINES\n          ON  A  PAGE  OR  IF  YOU WANT A NEW PAGE TO START AT A\n          CERTAIN  PLACE,  SUCH  AS  AT  THE  BEGINNING   OF   A\n          PARAGRAPH,  YOU MUST HAVE A 1 IN COLUMN 1 OF THE FIRST\n          LINE OF EACH PAGE.  EVERY OTHER LINE MUST ALSO HAVE  A\n          CONTROL   CHARACTER,    PERHAPS  A  BLANK  FOR  SINGLE\n          SPACING, IN COLUMN  1.   RATHER  THAN  SPACE  OVER  TO\n          COLUMN  2  WHEN  TYPING  EACH LINE, YOU CAN INSERT THE\n          NEEDED BLANKS THIS WAY:\n\n\n                   COMMAND?  CH 1 TO ' ' IN \u00ac'1' 1 NOL(CR)\n\n          THIS COMMAND INSERTS A BLANK IN COLUMN 1 OF EVERY LINE\n          THAT DOES NOT HAVE A 1 (\u00ac'1') IN COLUMN 1.  THE  BLANK\n          IS  ACTUALLY  INSERTED  AND THE TEXT IS MOVED OVER ONE\n          COLUMN RATHER THAN REPLACING COLUMN 1  WITH  A  BLANK.\n          THE  BLANKS  WILL  PRODUCE  SINGLE SPACED LINES IN THE\n          PRINTED COPY.\n\n          YOU MIGHT WANT A COMBINATION OF SPACING SUCH AS SINGLE\n          SPACED TEXT AND TRIPLE SPACES BETWEEN PARAGRAPHS.   TO\n          GET  THIS,  INSERT A 1 IN COLUMN 1 WHEREVER YOU WANT A\n          NEW PAGE; INSERT A - IN COLUMN 1 WHEREVER YOU START  A\n          NEW PARAGRAPH.  THEN ISSUE THE FOLLOWING COMMANDS:\n\n                   COMMAND?  CH 1 TO ' ' IN ALL NOL(CR)\n                   COMMAND?  CH ' 1' TO '1' IN ALL NOL(CR)\n                   COMMAND?  CH ' -' TO '-' IN ALL NOL(CR)\n\n          THE FIRST COMMAND INSERTS A BLANK IN COLUMN 1 OF EVERY\n          LINE.  THUS ALL LINES WHICH HAD A 1 IN  COLUMN  1  NOW\n          HAVE  A  BLANK AND A 1 IN COLUMNS 1 AND 2.  THE SECOND\n          COMMAND CHANGES EACH LINE WITH A  BLANK  AND  A  1  IN\n          COLUMNS  1 AND 2 TO A 1 IN COLUMN1 (DELETING THE SPACE\n          IN COLUMN 1).  THE THIRD COMMAND DOES A SIMILAR SWITCH\n          FOR LINES WITH A BLANK AND A - IN COLUMNS 1 AND 2.\n\n\n         UNDERLINING\n\n         TO DO UNDERLINING WITH PRINTER CONTROL CHARACTERS TAKES\n         TWO LINES FOR EACH LINE THAT HAS UNDERLINED TEXT IN IT.\n\n                   THIS IS AN EXAMPLE OF UNDERLINING\n                  +           _______\n\n          THE \"+\" IN COLUMN 1 OF THE SECOND LINE  MEANS  NOT  TO\n          SKIP  A  LINE  SO IT OVERPRINTS AND PRODUCES A LINE IN\n          WHICH THE WORD EXAMPLE IS UNDERLINED.   YOU  CAN  ALSO\n          USE  THIS  TECHNIQUE  TO  GET  \"BOLD-FACED\"  PRINT  BY\n          RETYPING  THE  WORD  TO  BE  \"BOLD-FACED\"  INSTEAD  OF\n          THE \"UNDERLINING\" MARKS.\n\n         HOW TO INSERT PAGE NUMBERS\n\n          YOU MAY INSERT LINES CONTAINING A 1 IN COLUMN 1 AND  A\n          PAGE NUMBER NEAR THE RIGHT MARGIN THROUGHOUT THE TEXT.\n          OR, YOU MAY INSERT LINES CONTAINING ONLY A 1 IN COLUMN\n          1  WHEREVER  YOU WANT A NEW PAGE.  THEN YOU MAY INSERT\n          PAGE NUMBERS THIS WAY:\n\n            COMMAND?  CH 68 TO 'PAGE' IN '1' 1 NOL(CR)\n            COMMAND?  CH 73 TO 1+1 IN '1' 1 NOL(CR)\n\n          THE FIRST COMMAND WILL  INSERT  THE  CHARACTER  STRING\n          'PAGE' INTO COLUMNS 68/71 OF EVERY LINE WHICH CONTAINS\n          A  '1'  IN COLUMN 1.  THE SECOND COMMAND WILL INSERT A\n          '1' IN COLUMN 73 OF THE FIRST LINE  WHICH  CONTAINS  A\n          '1' IN COLUMN 1.  THE REPLACEMENT VALUE IS INCREMENTED\n          BY  ONE SO THAT WYLBUR WILL INSERT A '2' IN THE SECOND\n          LINE WHICH CONTAINS A '1'  IN  COLUMN  1  AND  SO  ON.\n          NOTICE  THAT  PAGE  NUMBER 10 WOULD OCCUPPY COLUMNS 73\n          AND 74.  PAGE NUMBER 100 WOULD BE  PLACED  IN  COLUMNS\n          73,  74,  AND  75.  THEREFORE, IF YOU WERE RENUMBERING\n          THE PAGES OF AN ALREADY EXISTING FILE, YOU  WOULD  USE\n          THE FOLLOWING COMMAND:\n\n             COMMAND?  CH 73/75 TO 1+1 IN '1' 1 NOL(CR)\n\n          AN ALTERNATE WAY OF EXPRESSING  (1+1)  IS  (1 1)   AND\n          ACCOMPLISHES THE SAME THING.\n\n         CREATING COLUMNS OF INFORMATION\n\n          THE \"USING\" PARAMETER ON THE \"CHANGE\" COMMAND IS  VERY\n          USEFUL  FOR CREATING TABLES OR COLUMNS OF INFORMATION.\n          LET US ASSUME THAT THE  FOLLOWING  LINES  EXIST  IN  A\n          FILE:\n\n            1.   ABC\n            2.   DEF\n            3.   $1160\n            4.   $ 620\n\n            COMMAND?  CH 30 IN 1/2 USING 3/4 NOL(CR)\n            COMMAND?  DEL 3/4(CR)\n            COMMAND?  LIST(CR)\n\n            1.   ABC                           $1160\n            2.   DEF                           $ 620\n\n          YOU MAY SUBSEQUENTLY MAKE MODIFICATIONS TO  THE  FIRST\n          29  COLUMNS  WITHOUT  MOVING OR DESTROYING THE COLUMNS\n          FROM 30 ON BY USING THE FILL COLUMN PARAMETER  OF  THE\n          \"CHANGE\" COMMAND:\n\n            COMMAND?  CH 'ABC' //30 TO 'JONES' IN ALL NOL(CR)\n            COMMAND?  CH 'DEF' //30 TO 'SAMPSON' IN ALL NOL(CR)\n            COMMAND?  LIST(CR)\n            1.   JONES                         $1160\n            2.   SAMPSON                       $ 620\n\n         MERGING LINES OF DATA\n\n          IT MAY BECOME NECESSARY AT SOME TIME TO MERGE LINES OF\n          DATA OR CREATE TWO LINES THAT CONTAIN THE  SAME  DATA.\n          IN  THE  FOLLOWING  EXAMPLE, WE ARE CREATING TWO LINES\n          (ONE RIGHT AFTER THE OTHER).  THE SAME METHOD  MAY  BE\n          USED FOR MERGING.\n\n            COMMAND?  LIST(CR)\n            1.   AAAAA\n            2.   BBBBB\n            3.   CCCCC\n            COMMAND?  COPY F/L TO END(CR)\n            6. LAST LINE\n            COMMAND?  CH 1 TO '$$' IN 4/L NOL(CR)\n            COMMAND?  COPY 4/L TO .5 BY 1 MERGE(CR)\n            COMMAND?  LIST(CR)\n             .5  $$AAAAA\n            1.   AAAAA\n            1.5  $$BBBBB\n            2.   BBBBB\n            2.5  $$CCCCC\n            3.   CCCCC\n\n          NORMALLY, YOU WOULD WANT TO DO SOMETHING DIFFERENT  TO\n          THE  SECOND  OCCURRENCE  OF  THE  DATA  AND THAT IS THE\n          REASON FOR PUTTING THE UNIQUE IDENTIFIER \"$$\"  IN  THE\n          COPIED  LINES.   WHILE  THIS  APPEARS  TO  BE A LOT OF\n          TROUBLE WITH THE SMALL AMOUNT OF DATA SHOWN, THE  TIME\n          SAVINGS  CAN  BE  CONSIDERABLE IF YOU ARE USING A FILE\n          WITH LINES CONTAINING 60 COLUMNS OF DATA AND THE  FILE\n          IS 400 LINES IN LENGTH.\n=MOVESAMP\n    THE MOVE COMMAND\n\n          TO COPY A RANGE OF LINES AND DELETE THE  OLD  COPY  OF\n          THE  LINES,  USE  THE  COMMAND  MOVE.   THIS FUNCTIONS\n          EXACTLY  AS  THE  COPY  COMMAND  WITH  THE   FOLLOWING\n          EXCEPTIONS:\n\n          THE OLD LINES WHICH WERE COPIED ARE DELETED.\n\n          IT IS NOT POSSIBLE TO  APPLY  THE  MOVE  COMMAND  TO  AN\n          EXTERNAL  FILE.\n\n\n          FOLLOWING ARE SOME EXAMPLES OF  THE  MOVE  COMMAND  AS\n          APPLIED  TO THE SAMPLE FILE USED IN THE EXPLANATION OF\n          THE COPY COMMAND.\n\n       A. MOVE AN EXPLICIT RANGE OF LINES\n\n          RANGE MUST BE THE FIRST PARAMETER.\n\n          COMMAND? MOVE 6/7 TO 2.03 BY .001 (CR)\n            2.031 - LAST LINE.\n          COMMAND? LIST (CR)\n            1.     THIS IS A DUMMY FILE WHICH WILL BE USED\n            2.     TO SHOW THE EFFECT OF VARIOUS COPY COMMANDS.\n            2.03   DDDDDDD\n            2.031  EEE\n            3.     AAAA\n            4.     BBBBBB\n            5.     CCCCC\n          COMMAND?\n\n       B. MOVE AN ASSOCIATIVE RANGE OF LINES\n\n          COMMAND? MOVE 'FILE' IN 1/7 TO 33 (CR)\n          COMMAND? LIST (CR)\n            2.     TO SHOW THE EFFECT OF VARIOUS COPY COMMANDS.\n            3.     AAAA\n            4.     BBBBBB\n            5.     CCCCC\n            6.     DDDDDDD\n            7.     EEE\n           33.     THIS IS A DUMMY FILE WHICH WILL BE USED\n          COMMAND?\n\n          YOU MAY SPECIFY THE SPECIAL LINE  NUMBER  END  FOLLOWING\n          THE  TO.   END  IS  ONE  DELTA INCREMENT HIGHER THAN THE\n          CURRENT LAST OF THE ACTIVE FILE.\n\n       C. MERGE\n\n          THE MERGE OPTION WORKS JUST AS FOR COPY EXCEPT THAT  THE\n          MOVED  LINES  WILL BE ERASED FROM THEIR OLD POSITION AND\n          YOU MAY NOT MOVE FROM AN EXTERNAL FILE.\n\n\n=COPYSAMP\n\n\n    1. COPY\n\n          WYLBUR WILL COPY ONE OR MORE LINES INTO A  SECTION  OF\n          THE  ACTIVE  FILE.   THE  LINES  COPIED  MAY BE IN THE\n          ACTIVE FILE OR IN AN EXTERNAL FILE.  THE LINES  COPIED\n          ARE NOT ERASED FROM THEIR OLD POSITION.  THE NEW LINES\n          ARE  RENUMBERED ACCORDING TO THE IMPLICIT DELTA UNLESS\n          YOU SPECIFY AN OVERRIDING DELTA IN THE  COPY  COMMAND.\n          ALSO  NOTE  THAT  LINES  ALREADY IN THE FILE CANNOT BE\n          OVERWRITTEN BY USE OF THE COPY COMMAND.  THE FOLLOWING\n          FILE WILL BE USED TO SHOW THE EFFECT OF  VARIOUS  COPY\n          COMMANDS.\n\n       1.     THIS IS A DUMMY FILE WHICH WILL BE USED\n       2.     TO SHOW THE EFFECT OF VARIOUS COPY COMMANDS.\n       3.     AAAA\n       4.     BBBBBB\n       5.     CCCCC\n       6.     DDDDDDD\n       7.     EEE\n\n          IN THE EXAMPLES, ASSUME  THAT  EACH  COPY  COMMAND  IS\n          GIVEN  WHEN  THE  FILE IS IN THE UNMODIFIED FORM GIVEN\n          ABOVE.\n\n       COMMAND? COPY (CR)\n          14.  -  LAST LINE\n       COMMAND? LIST (CR)\n          1.     THIS IS A DUMMY FILE WHICH WILL BE USED\n          2.     TO SHOW THE EFFECT OF VARIOUS COPY COMMANDS.\n          3.     AAAA\n          4.     BBBBBB\n          5.     CCCCC\n          6.     DDDDDDD\n          7.     EEE\n          8.     THIS IS A DUMMY FILE WHICH WILL BE USED\n          9.     TO SHOW THE EFFECT OF VARIOUS COPY COMMANDS.\n         10.     AAAA\n         11.     BBBBBB\n         12.     CCCCC\n         13.     DDDDDDD\n         14.     EEE\n\n          THIS IS THE SIMPLIST FORM OF  THE  COPY  COMMAND.   IT\n          WILL  COPY  ALL  OF THE ACTIVE FILE TO THE LINE NUMBER\n          THAT IS REFERENCED BY THE SYMBOLIC LINE NUMBER END.\n\n\n       A. COPY AN EXPLICIT RANGE\n\n          IF YOU COPY A RANGE OF LINES RATHER THAN A  WHOLE  FILE,\n          RANGE  MUST  BE  THE  FIRST PARAMETER.  IF YOU SPECIFY A\n          LINE TO COPY TO, IT MUST BE A NON-EXISTING LINE.  IN THE\n          FOLLOWING COMMAND, LINE 6.5 IS USED TO COPY TO.\n\n          COMMAND? COPY 5 TO 6.5 (CR)\n          COMMAND? LIST (CR)\n            1.     THIS IS A DUMMY FILE WHICH WILL BE USED\n            2.     TO SHOW THE EFFECT OF VARIOUS COPY COMMANDS.\n            3.     AAAA\n            4.     BBBBBB\n            5.     CCCCC\n            6.     DDDDDDD\n            6.5    CCCCC\n            7.     EEE\n\n          IF THE RANGE COPIED RESULTS IN THE  ADDITION  OF  MORE\n          THAN ONE LINE TO THE FILE, THE LAST LINE NUMBER OF THE\n          NEW LINES WILL BE INDICATED.\n\n          COMMAND? COPY 3/5 TO 47 (CR)\n           49.    - LAST LINE.\n          COMMAND? LIST (CR)\n            1.     THIS IS A DUMMY FILE WHICH WILL BE USED\n            2.     TO SHOW THE EFFECT OF VARIOUS COPY COMMANDS.\n            3.     AAAA\n            4.     BBBBBB\n            5.     CCCCC\n            6.     DDDDDDD\n            7.     EEE\n           47.     AAAA\n           48.     BBBBBB\n           49.     CCCCC\n\n\n          COMMAND?  COPY 3/5 TO END (CR)\n\n          WOULD HAVE ACCOMPLISHED THE  SAME  THING  BUT  THE  LINE\n          NUMBERS  WOULD HAVE BEEN 8, 9, AND 10 INSTEAD OF 47, 48,\n          49.  IF  THE  TO  LINENUMBER  IS  OMITTED,  THE  DEFAULT\n          ASSUMED IS TO END.\n\n\n       B. SPECIFYING DELTA\n\n          COMMAND?  COPY 2/3 TO 4.01\n            4.02  - LAST LINE.\n\n          IN THE EXAMPLE ABOVE, THE TWO LINES  FROM  LINE  2.0  TO\n          LINE  3.0  INCLUSIVE  WERE  COPIED TO FOLLOW 4.01 WITH A\n          DEFAULT INCREMENT OF .01.  IN THE  FOLLOWING  EXAMPLE  A\n          DELTA OF .001 IS SPECIFIED.\n\n          COMMAND?  COPY 6/7 TO 2.03 BY .001 (CR)\n            2.031 - LAST LINE.\n          COMMAND?  LIST (CR)\n            1.     THIS IS A DUMMY FILE WHICH WILL BE USED\n            2.     TO SHOW THE EFFECT OF VARIOUS COPY COMMANDS.\n            2.03   DDDDDDD\n            2.031  EEE\n            3.     AAAA\n            4.     BBBBBB\n            5.     CCCCC\n            6.     DDDDDDD\n            7.     EEE\n\n\n          IF THE RANGE TO  BE  COPIED  OVERLAPS  THE  RANGE  BEING\n          COPIED INTO, BIZARRE RESULTS MAY BE PRODUCED.\n\n          COMMAND? COPY 6/10  TO 8 BY .01 (CR)\n          10.02 - LAST LINE\n          COMMAND? LIST (CR)\n            1.     THIS IS A DUMMY FILE WHICH WILL BE USED\n            2.     TO SHOW THE EFFECT OF VARIOUS COPY COMMANDS.\n            3.     AAAA\n            4.     BBBBBB\n            5.     CCCCC\n            6.     DDDDDDD\n            7.     EEE\n            8.     DDDDDDD\n            8.01   EEE\n            8.02   DDDDDDD\n            8.03   EEE\n            8.04   DDDDDDD\n            8.05   EEE\n\n\n          AND SO IT GOES, UNTIL  IT  COPIES  10  TO  10.02.   THIS\n          HAPPENS  BECAUSE  WYLBUR  COPIES ONE LINE AT A TIME.  IT\n          BEGINS AT 6 AND COPIES THAT INTO 8.0; IT NEXT COPIES 7.0\n          INTO  8.01;  THEN  8.0  INTO  8.02,  AND  IT   CONTINUES\n          GENERATING  AND  COPYING  UNTIL  THE LIMIT, 10, HAS BEEN\n          COPIED.  THIS FEATURE  CAN  BE  USED  DELIBERATELY  WHEN\n          MULTIPLE COPIES OF A LINE OR RANGE OF LINES ARE WANTED.\n\n\n       C. MERGE\n\n          THE MERGE OPTION MAY BE USED  TO  INTERLEAVE  LINES.   A\n          DELTA  MUST  BE  SPECIFIED  WHICH  WILL ALLOW THE MERGED\n          LINES TO FIT BETWEEN THE EXISTING LINES WHICH ARE  BEING\n          COPIED  TO.   REPLACES  ARE NOT PERMITTED.  THE OLD LINE\n          NUMBERS OF THE LINES COPIED FROM ARE NOT RETAINED BY THE\n          COPY MERGE COMMAND.\n\n          COMMAND?  COPY 1/3 TO 2.1 BY 2 MERGE (CR)\n            6.1  - LAST LINE\n          COMMAND?  LIST (CR)\n            1.     THIS IS A DUMMY FILE WHICH WILL BE USED\n            2.     TO SHOW THE EFFECT OF VARIOUS COPY COMMANDS.\n            2.1    THIS IS A DUMMY FILE WHICH WILL BE USED\n            3.     AAAA\n            4.     BBBBBB\n            4.1    TO SHOW THE EFFECT OF VARIOUS COPY COMMANDS.\n            5.     CCCCC\n            6.     DDDDDDD\n            6.1    AAAA\n            7.     EEE\n\n\n       D. COPY AN ASSOCIATIVE RANGE\n\n          THE FOLLOWING EXAMPLE SHOWS THE SUCCESSFUL  USE  OF  THE\n          COPY COMMAND APPLIED TO AN ASSOCIATIVE RANGE.\n\n          COMMAND?  COPY 'FILE' IN 1/6 TO 33  (CR)\n          COMMAND?  LIST (CR)\n            1.     THIS IS A DUMMY FILE WHICH WILL BE USED\n            2.     TO SHOW THE EFFECT OF VARIOUS COPY COMMANDS.\n            3.     AAAA\n            4.     BBBBBB\n            5.     CCCCC\n            6.     DDDDDDD\n            7.     EEE\n           33.     THIS IS A DUMMY FILE WHICH WILL BE USED\n\n\n          BIZARRE SITUATIONS CAN OCCUR IF YOU ASK WYLBUR  TO  COPY\n          ALL   THE   LINES   CONTAINING  A  SPECIFIED  STRING  OF\n          CHARACTERS BECAUSE MULTIPLE COPIES  OF  A  LINE  CAN  BE\n          GENERATED.\n\n          COMMAND? COPY 'A DUMMY' IN ALL TO 2.03 BY .01 (CR)\n          ABORTED BY ATTEMPT TO REPLACE OR INTERLEAVE. 2.99 - LAST LINE\n          COMMAND? LIST (CR)\n            1.     THIS IS A DUMMY FILE WHICH WILL BE USED\n            2.     TO SHOW THE EFFECT OF VARIOUS COPY COMMANDS.\n            2.03   THIS IS A DUMMY FILE WHICH WILL BE USED\n            2.04   THIS IS A DUMMY FILE WHICH WILL BE USED\n            2.05   THIS IS A DUMMY FILE WHICH WILL BE USED\n                 .\n                 .\n                 .\n            2.99   THIS IS A DUMMY FILE WHICH WILL BE USED\n            3.     AAAA\n            4.     BBBBBB\n            5.     CCCCC\n            6.     DDDDDDD\n            7.     EEE\n\n\n          THESE EXAMPLES ILLUSTRATE THE IMPORTANCE OF  CONSIDERING\n          CAREFULLY THE RESULTS OF A COPY COMMAND BEFORE USING IT.\n\n          YOU MAY  SPECIFY  THAT  ONLY  SOME  COLUMNS  ARE  TO  BE\n          SEARCHED  FOR  THE  STRING.  THE FOLLOWING EXAMPLE WOULD\n          GIVE THE SAME RESULTS AS THE ABOVE EXAMPLE.\n\n          COMMAND? COPY 'A' COLUMNS 9/9 IN ALL TO 2.03 BY .01 (CR)\n          ABORTED BY ATTEMPT TO REPLACE OR INTERLEAVE. 2.99 - LAST LINE\n          COMMAND?\n\n          YOU MAY SPECIFY A LIST OPTION.  THIS WILL RESULT IN  THE\n          LINE  PRECEEDING  THE NEW LINES AS WELL AS THE NEW LINES\n          BEING LISTED.\n\n          COMMAND?  COPY LIST (CR)\n             7.     EEE\n             8.     THIS IS A DUMMY FILE WHICH WILL BE USED\n             9.     TO SHOW THE EFFECT OF VARIOUS COPY COMMANDS.\n            10.     AAAA\n            11.     BBBBBB\n            12.     CCCCC\n            13.     DDDDDDD\n            14.     EEE\n\n\n       E. COPY TO THE END OF A FILE\n\n          FREQUENTLY YOU MAY WANT TO POSITION THE COPIED LINES  AT\n          THE  END  OF  THE  FILE.   THE SPECIAL LINE NUMBER, END,\n          WHICH IS EQUAL TO LAST PLUS THE CURRENT VALUE FOR DELTA,\n          WILL ALLOW THIS.  END IS THE  DEFAULT  WHEN \"TO\" IS  NOT\n          SPECIFIED.\n\n          COMMAND?  COPY 2.0 TO END (CR)\n          OR\n          COMMAND?  COPY 2.0 (CR)\n\n       F. COPY FROM AN EXTERNAL FILE\n\n          YOU MAY ALSO COPY LINES FROM ANY EXTERNAL FILE BY GIVING\n          A FROM PHRASE WHICH SPECIFIES THE EXTERNAL FILE.  IF YOU\n          USE DSNAME PARAMETERS  SUCH  AS  ON  VOLUME,  THEY  MUST\n          FOLLOW THE DSNAME.\n\n          A) COPY ALL OF AN EXTERNAL FILE\n\n             IF THE RANGE IS OMITTED, A DEFAULT RANGE  OF  ALL  IS\n             ASSUMED.   IF  THE \"TO\" IS OMITTED, A DEFAULT OF\n             \"TO=END\" IS ASSUMED.  THEREFORE, THE COMMAND:\n\n             COMMAND?  COPY FROM MYTEXT ON TSOWK1 (CR)\n               126.   - LAST LINE\n\n             WOULD CAUSE ALL OF THE EXTERNAL FILE NAMED MYTEXT  TO\n             BE COPIED TO THE END OF THE ACTIVE FILE.\n\n\n          B) COPY PART OF AN EXTERNAL FILE\n\n             COMMAND? COPY 1/57 TO 35 BY .1 FROM MYTEXT (CR)\n              97.    - LAST LINE.\n\n             THIS WOULD CAUSE ALL LINES WHICH ARE NUMBERED BETWEEN\n             1.000 AND 57.000 IN THE EXTERNAL FILE NAMED MYTEXT TO\n             BE COPIED INTO THE ACTIVE FILE STARTING  AT  LINE  35\n             WITH  A  DELTA  (LINE  INCREMENT) OF .1.  AS WITH THE\n             COLLECT OR INSERT COMMANDS, THERE IS  NO  OVERWRITING\n             OR INTERLEAVING EXISTING LINES IN THE ACTIVE FILE.\n\n             COMMAND?  COPY F(11) FROM MYFILE ON TSOWK1 (CR)\n                18.  -  LAST LINE\n\n             THIS COMMAND COPIES THE FIRST ELEVEN LINES  FROM  THE\n             EXTERNAL FILE MYFILE TO THE END OF THE ACTIVE FILE.\n\n             ANOTHER RULE CONCERNING THE COPY COMMAND IS THAT  ANY\n             EXTERNAL  FILE  WHICH  IS  SPECIFIED  MUST BE IN EDIT\n             FORMAT.  ANY FILE CREATED  AT  A  TERMINAL  WITH  THE\n             WYLBUR  SYSTEM  IS IN EDIT FORMAT.  FOR A DESCRIPTION\n             OF THE VARIOUS FORMATS, SEE FORMAT IN SECTION VIII.\n\n\n       G. COPY TO THE BEGINNING OF A FILE\n\n          TO COPY ONE FILE TO THE BEGINNING OF ANOTHER, COPY TO  A\n          LINE  NUMBER  LESS THAN THE FIRST LINE.  FOR EXAMPLE, IF\n          THE FIRST LINE OF THE ACTIVE FILE WHICH  IS  TO  RECEIVE\n          THE COPY IS NUMBERED 1,\n\n          COMMAND?  COPY TO .1 FROM FILE1 ON TSOWK2 (CR)\n\n          WYLBUR ATTEMPTS TO CALCULATE A DELTA WHICH WILL MAKE ALL\n          THE LINES FROM THE EXTERNAL FILE FIT.  THIS COMMAND IS A\n          CONVENIENT WAY TO INSERT A FILE OF JCL STATEMENTS AT THE\n          BEGINNING OF A TEXT FILE.\n\n       H. COPY PART OF AN EXTERNAL FILE AND COMBINE\n\n          THE COMBINE PARAMETER ALLOWS LINES FROM AN EXTERNAL FILE\n          TO BE MERGED  INTO  THE  ACTIVE  FILE.   THE  DIFFERENCE\n          BETWEEN COMBINE AND MERGE IS THAT MERGE REQUIRES A DELTA\n          WHEREAS  COMBINE  WILL  USE  THE  LINE  NUMBERS  IN  THE\n          EXTERNAL  FILE  TO  DETERMINE THE POSITION IN THE ACTIVE\n          FILE OF THE NEW LINES.  INTERLEAVING  IS  PERMITTED  BUT\n          REPLACING IS NOT.\n\n          COMMAND? COPY 'ABCD' FROM MYTEXT ON TSOWK2 COMBINE (CR)\n            6.5   - LAST LINE\n          COMMAND? LIST (CR)\n            1.     THIS IS A DUMMY FILE WHICH WILL BE USED\n            1.5    ABCDGOLDFISH?\n            2.     TO SHOW THE EFFECT OF VARIOUS COPY COMMANDS.\n            3.     AAAA\n            4.     BBBBBB\n            5.     CCCCC\n            6.     DDDDDDD\n            6.5    ABCDBBBBB?\n            7.     EEE\n          COMMAND?\n\n\n\n    I. COPY EXEC\n\n       THE EXEC OPTION MAY BE SPECIFIED IN  THE  COPY  COMMAND  TO\n       COPY  ALL OR PART OF THE EXEC FILE TO THE ACTIVE FILE.  ANY\n       OF THE OTHER COPY OPTIONS MAY  ALSO  BE  SPECIFIED,  EXCEPT\n       FROM  (AND ASSOCIATED OPTIONS SUCH AS ON VOLUME); COPY FROM\n       EXEC WOULD USE AN EXTERNAL FILE WITH THE DSNAME EXEC.\n\n       COMMAND? COPY FIRST/3 EXEC TO .1 BY 1 MERGE (CR)\n          2.3  -  LAST LINE\n       COMMAND?\n\n=CHGLEARN\n)F FUNCTION -\n\n THE CHANGE COMMAND\n\n\n          THE CHANGE COMMAND IS THE SINGLE MOST POWERFUL COMMAND\n          IN WYLBUR.  EVERY CHANGE COMMAND HAS  THREE  SECTIONS:\n          POSITION,   REPLACEMENT,   AND  RANGE.   THE  POSITION\n          IDENTIFIES THE LOCATION WITHIN THE LINE WHICH IS TO BE\n          CHANGED.  THE RANGE SPECIFIES WHICH LINES  ARE  TO  BE\n          CONSIDERED  FOR  CHANGING.   THE REPLACEMENT DESCRIBES\n          WHAT CHANGE IS TO BE MADE.  THE COMMAND  SEARCHES  THE\n          LINES  SPECIFIED  IN  THE  RANGE  FOR INSTANCES OF THE\n          POSITION TO BE CHANGED AND, WHEN  IT  ENCOUNTERS  ONE,\n          MAKES  THE  INDICATED  REPLACEMENT.   AS  EACH LINE IS\n          CHANGED, THE RESULTING LINE IS LISTED.\n\n THE COMMAND CAN BE GIVEN IN EITHER OF TWO ORDERS:\n\n    CHANGE POSITION TO REPLACEMENT IN RANGE\n\n    CHANGE POSITION IN RANGE TO REPLACEMENT\n\n THERE IS ALSO AN ALTERNATE FORM WHICH WILL BE DISCUSSED LAST:\n\n    CHANGE POSITION IN RANGE USING REPLACEMENT\n\n          THE USER CAN SUPPRESS THE LISTING OF EACH CHANGED LINE\n          BY  SPECIFYING  THE  NOLIST  OPTION  IN  THE  COMMAND.\n          REMEMBER THAT ANY ATTEMPT TO INTERRUPT THE LISTING  OF\n          THE CHANGED LINES, WHEN NOLIST IS NOT GIVEN, WILL ALSO\n          HALT THE CHANGE PROCESS.\n\n          A SAMPLE DATA SET WILL BE USED TO SHOW THE  EFFECT  OF\n          THE  COMMANDS.  WHEN EACH COMMAND IS GIVEN, THE ACTIVE\n          FILE WILL BE:\n\n       1.     123456ABC\n       2.     123456ABC\n       3.     AAABBBCCC\n       4.     AAABBBCCC\n       5.     AAABBBCCC\n\n\n\n    1. POSITION IN LINE\n\n          THERE ARE THREE BASIC TYPES OF LOCATIONS THAT  CAN  BE\n          SPECIFIED  IN  THE  POSITION  SECTION  OF THE COMMAND:\n          STRING REPLACEMENT,  COLUMN  REPLACEMENT,  AND  COLUMN\n          INSERTION.   THE ORDER USED TO ILLUSTRATE THIS SECTION\n          OF THE COMMAND WILL BE:\n\n       CHANGE POSITION TO REPLACEMENT IN RANGE\n\n       A. STRING REPLACEMENT\n\n          THE SIMPLEST VERSION OF THE FIRST FORM IS:\n\n          CHANGE 'STRING1' TO 'STRING2' IN ALL\n\n          IN THE EXAMPLES BELOW A SIMPLE VERSION  OF  THE  LATER\n          PARTS OF THE COMMAND (THE REPLACEMENT) AND THE DEFAULT\n          RANGE ALL WILL BE USED.\n\n          COMMAND? CHANGE 'A' TO '*' IN ALL (CR)\n             1.     123456*BC\n             2.     123456*BC\n             3.     ***BBBCCC\n             4.     ***BBBCCC\n             5.     ***BBBCCC\n          COMMAND?\n\n          EACH 'A' IN THE ACTIVE FILE HAS BEEN FOUND AND CHANGED\n          TO AN '*'.\n\n          THE COMMAND CAN ALSO SPECIFY THAT  THE  STRING  TO  BE\n          CHANGED  MUST  OCCUR  COMPLETELY WITHIN CERTAIN COLUMN\n          POSITIONS.  NOTICE THAT THE STRING BEING REPLACED  AND\n          ITS REPLACEMENT CAN BE OF DIFFERENT LENGTHS.\n\n          COMMAND? CH 'BC' 5/8 TO 'X' IN ALL (CR)\n             3.     AAABBXCC\n             4.     AAABBXCC\n             5.     AAABBXCC\n          COMMAND?\n\n          THE 'BC' STRINGS IN LINES 1 AND  2  WERE  NOT  CHANGED\n          BECAUSE  THEY  ENDED  IN COLUMN 9 AND WERE, THEREFORE,\n          OUTSIDE THE RANGE SPECIFIED.\n\n\n\n          IT  IS  ALSO  POSSIBLE  TO  MENTION  JUST  THE  COLUMN\n          POSITION IN WHICH THE STRING MUST BEGIN.  THUS, CHANGE\n          'BC' 6 TO 'X' IN ALL WOULD HAVE HAD THE SAME EFFECT AS\n          THE ABOVE EXAMPLE.\n\n          YOU MAY SPECIFY A THIRD  COLUMN.   THIS  IS  THE  FILL\n          COLUMN,  AND WHEN IT IS GIVEN, NOTHING TO THE RIGHT OF\n          THAT COLUMN WILL BE CHANGED IN THE RANGE.\n\n          COMMAND? CH 'BBB' 3/6/7 TO '&' IN ALL (CR)\n             3.      AAA&  CCC\n             4.      AAA&  CCC\n             5.      AAA&  CCC\n          COMMAND?\n\n          AGAIN YOU MAY MENTION ONLY THE  COLUMN  IN  WHICH  THE\n          STRING MUST BEGIN ALONG WITH THE FILL COLUMN.  THUS CH\n          'BBB'  3//7 TO '&' WOULD BE EQUIVALENT IN THIS CASE TO\n          THE ABOVE EXAMPLE.\n\n          YOU MAY ALSO SPECIFY THE FILL COLUMN  WHEN  SPECIFYING\n          NO  OTHER  COLUMN  POSITIONS.   THIS  WILL  CAUSE  ALL\n          COLUMNS  BEFORE THE FILL COLUMN TO BE SEARCHED FOR THE\n          APPROPRIATE STRING.\n\n          COMMAND? CHANGE 'C' //8 TO ' ' IN ALL (CR)\n             3.      AAABBB CC\n             4.      AAABBB CC\n             5.      AAABBB CC\n          COMMAND?\n\n          IF THE REPLACEMENT CANNOT BE MADE WITHIN  THE  COLUMNS\n          BEFORE THE FILL COLUMN, THE CHANGE WILL BE MADE LOSING\n          SOME OF THE CHARACTERS OF THE NEW LINE AND WYLBUR WILL\n          ISSUE   A   MESSAGE  INDICATING  THE  LINES  IN  WHICH\n          NON-BLANK CHARACTERS WERE LOST.\n\n          COMMAND? CH 'A' //12 TO 'XX' IN ALL (CR)\n             1.      123456XXBC\n             2.      123456XXBC\n          LINE NO.      3.    LOST CHARACTERS\n             3.      XXXXXXBBBCC\n          LINE NO.      4.    LOST CHARACTERS\n             4.      XXXXXXBBBCC\n          LINE NO.      5.    LOST CHARACTERS\n             5.      XXXXXXBBBCC\n          COMMAND?\n\n          YOU CAN ALSO CHOOSE TO CHANGE JUST A CERTAIN INSTANCE OF\n          A STRING IN EACH LINE.  FOR EXAMPLE:\n\n          COMMAND? CH 'C' (2) TO '??' IN ALL (CR)\n             3.      AAABBBC??C\n             4.      AAABBBC??C\n             5.      AAABBBC??C\n          COMMAND?\n\n\n          THIS COMMAND WILL CHANGE ONLY THE SECOND  INSTANCE  OF\n          THE STRING 'C' WITHIN EACH LINE.\n\n          IF COLUMN POSITIONS AND AN INSTANCE ARE COMBINED,  THE\n          COLUMNS MUST BE GIVEN FIRST.\n\n          A COMMAND  USING  THE  MOST  COMPLEX  VERSION  OF  THE\n          POSITION SECTION MIGHT READ IN OUTLINE:\n\n          CHANGE 'STRING1' COL/COL/COL (INSTANCE) TO 'STRING2' IN F/L\n\n          COMMAND?  CHANGE 'C' 8/50 (2) TO 'Y' IN F/L (CR)\n             3.     AAABBBCCY\n             4.     AAABBBCCY\n             5.     AAABBBCCY\n          COMMAND?\n\n       B. COLUMN REPLACEMENT\n\n          THE SECOND FORM  OF  THE  POSITION  SECTION  SPECIFIES\n          COLUMN POSITIONS TO BE CHANGED WITHOUT REGARD TO THEIR\n          CONTENTS.\n\n          CHANGE COLUMN/COLUMN/COLUMN TO 'STRING2' IN F/L\n\n          COMMAND?  CHANGE 3/6 TO '00' IN F/L (CR)\n             1.     1200ABC\n             2.     1200ABC\n             3.     AA00CCC\n             4.     AA00CCC\n             5.     AA00CCC\n          COMMAND?\n\n          AS THE EXAMPLE SHOWS, THE REPLACEMENT STRING CAN BE OF\n          A DIFFERENT LENGTH THAN THE MATERIAL IT REPLACES.\n\n          COMMAND?  CHANGE 1/3 TO '' IN F/L (CR)\n             1.     456ABC\n             2.     456ABC\n             3.     BBBCCC\n             4.     BBBCCC\n             5.     BBBCCC\n          COMMAND?\n\n          THE ABOVE EXAMPLE ILLUSTRATES  THE  USE  OF  THE  NULL\n          STRING (\"\" OR '') TO ELIMINATE COLUMNS COMPLETELY.\n\n          AGAIN, THE FILL COLUMN MAY BE SPECIFIED.\n\n          COMMAND? CH 3/6/8 TO '00' IN F/L (CR)\n             1.     1200A  BC\n             2.     1200A  BC\n             3.     AA00C  CC\n             4.     AA00C  CC\n             5.     AA00C  CC\n\n\n\n       C. COLUMN INSERTION\n\n          THE THIRD FORM OF THE POSITION SECTION DESIGNATES  THE\n          COLUMN  POSITION  BEFORE  WHICH  AN INSERTION IS TO BE\n          MADE.\n\n          CHANGE COLUMN TO 'STRING2' IN RANGE\n\n          COMMAND? CHANGE 3 IN ALL TO ' -' (CR)\n             1.     12 -3456ABC\n             2.     12 -3456ABC\n             3.     AA -ABBBCCC\n             4.     AA -ABBBCCC\n             5.     AA -ABBBCCC\n          COMMAND?\n\n          SINCE  3  WAS  THE  SPECIFIED  COLUMN  POSITION,   THE\n          INSERTION  WAS MADE IN FRONT OF THAT POSITION, AND THE\n          REST OF THE LINE WAS MOVED TO THE RIGHT.\n\n          YOU MAY ALSO SPECIFY A FILL COLUMN FOR COLUMN INSERTION.\n\n          COMMAND? CH 3//6 TO ' -' IN F/L (CR)\n          LINE NO.   1.    LOST CHARACTERS\n             1.     12 -36ABC\n          LINE NO.   2.    LOST CHARACTERS\n             2.     12 -36ABC\n          LINE NO.   3.    LOST CHARACTERS\n             3.     AA -ABCCC\n          LINE NO.   4.    LOST CHARACTERS\n             4.     AA -ABCCC\n          LINE NO.   5.    LOST CHARACTERS\n             5.     AA -ABCCC\n          COMMAND?\n\n          NOTICE THAT IT IS  ALWAYS  THE  COLUMN(S)  IMMEDIATELY\n          PRECEEDING  THE  FILL  COLUMN THAT WILL BE DELETED, IF\n          NECESSARY.  IF ONLY BLANKS ARE  DELETED,  THE  MESSAGE\n          LINE NO.  X LOST CHARACTERS WILL NOT BE GIVEN.\n\n    2. SEARCH RANGE\n\n          THE RANGE SECTION OF THE CHANGE COMMAND  TELLS  WYLBUR\n          WHICH  LINES  OF  THE  ACTIVE  FILE  TO SEARCH FOR THE\n          LOCATION TO CHANGE.   THIS  SECTION  CAN  CONTAIN  ANY\n          VALID  ASSOCIATIVE  RANGE OR EXPLICIT RANGE.\n\n       CHANGE POSITION TO REPLACEMENT IN RANGE\n\n          THIS SECTION MAY SIMPLY SPECIFY THAT THE ENTIRE ACTIVE\n          FILE SHOULD BE SEARCHED.\n\n\n       COMMAND? CHANGE 'A' TO '  ' IN F/L (CR)\n          1.     123456  BC\n          2.     123456  BC\n          3.           BBBCCC\n          4.           BBBCCC\n          5.           BBBCCC\n       COMMAND?\n\n          AS WAS MENTIONED ABOVE, THE ORDER OF  THE  REPLACEMENT\n          AND THE RANGE CAN BE REVERSED; SO THE GENERAL FORM CAN\n          ALSO READ:\n\n       CHANGE POSITION IN RANGE TO REPLACEMENT\n\n       THE SPECIFIC COMMAND ABOVE COULD ALSO HAVE BEEN STATED AS:\n\n       COMMAND?  CHANGE 'A' IN ALL TO ' ' (CR)\n\n       NOTE:  \"'A'  IN  ALL\"  IN  THE  ABOVE  EXAMPLE  IS  NOT  AN\n       ASSOCIATIVE RANGE.\n\n\n          THE RANGE CAN SPECIFY THAT ONLY CERTAIN LINES  ARE  TO\n          BE SEARCHED.\n\n       COMMAND?  CHANGE 'B' TO '' IN 1,3/5 (CR)\n          1.  123456AC\n          3.  AAACCC\n          4.  AAACCC\n          5.  AAACCC\n       COMMAND?\n\n          THE  RANGE  CAN  BE  FURTHER   RESTRICTED   TO   LINES\n          CONTAINING  (OR  NOT  CONTAINING) A GIVEN STRING WHICH\n          CAN  BE  REQUIRED  TO  FALL  WITHIN   CERTAIN   COLUMN\n          POSITIONS.\n\n       COMMAND?  CHANGE 2/4 TO '$$' IN \u00ac'A' 1/5 IN 2/LAST (CR)\n          2.  1$$56ABC\n       COMMAND?\n\n          YOU CAN FURTHER RESTRICT CHANGES TO CERTAIN  INSTANCES\n          OF  LINES  MEETING  THE  CRITERIA.  NOTICE THAT IN THE\n          EXAMPLE, THE THIRD LINE CONTAINING \"A\" AND \"BB\" IS NOT\n          CHANGED.\n\n       COMMAND?  CHANGE 'A' TO 'Z' IN 'BB' (1,2) IN ALL (CR)\n          3.  ZZZBBBCCC\n          4.  ZZZBBBCCC\n       COMMAND?\n\n          THE FORM OF THE COMMAND USING THE MOST COMPLEX VERSION\n          OF THE RANGE SECTION AND SHOWING THE USE OF ALL  THREE\n          STRINGS MIGHT READ:\n\n       CHANGE 'STRING1' TO 'STRING2' IN 'STRING3' COLUMN/COLUMN\n       (INSTANCES) IN LINENUMBER,LINENUMBER/LINENUMBER\n\n\n\n    3. THE REPLACEMENT\n\n          THE  THIRD  SECTION  OF  THE  COMMAND  SPECIFIES   THE\n          REPLACEMENT STRING WHICH IS TO BE PUT IN THE POSITIONS\n          BEING  CHANGED.   THE  ORDER  USED  TO ILLUSTRATE THIS\n          SECTION WILL BE:\n\n       CHANGE POSITION IN RANGE TO REPLACEMENT\n\n          THE REPLACEMENT MAY BE ONE OF THREE TYPES:   A  QUOTED\n          STRING,  AN  INCREMENTED  INTEGER,  OR  A  TRANSFERRED\n          REPLACEMENT RANGE.\n\n       A. QUOTED STRING\n\n          CHANGE 'STRING1' IN RANGE TO 'STRING2'\n\n          THE SIMPLEST USE OF THIS  SECTION  INVOLVES  A  DIRECT\n          REPLACEMENT  OF  THE DESIGNATED LOCATION WITH A SINGLE\n          QUOTED STRING.\n\n\n          COMMAND?  CHANGE 'ABC' IN ALL TO '%+%' (CR)\n             1.     123456%+%\n             2.     123456%+%\n          COMMAND?\n\n       B. INCREMENTED INTEGER\n\n          THE SECOND FORM THE REPLACEMENT STRING CAN TAKE IS  AN\n          INTEGER  WHICH  IS  INCREMENTED  EACH TIME IT IS USED.\n          THIS CAN  BE  USED,  FOR  EXAMPLE,  TO  GENERATE  PAGE\n          NUMBERS OR SEQUENCE NUMBERS.\n\n          IF A SINGLE INTEGER IS GIVEN, IT IS INCREMENTED BY ONE\n          EACH TIME IT IS USED.\n\n          COMMAND?  CHANGE 'C' IN ALL TO 1 (CR)\n             1.     123456AB1\n             2.     123456AB2\n             3.     AAABBB345\n             4.     AAABBB678\n             5.     AAABBB91011\n          COMMAND?\n\n          NOTICE THAT THE FIELD IS EXPANDED  IF  NECESSARY.   AN\n          INCREMENT OTHER THAN ONE MAY BE SPECIFIED.\n\n          COMMAND?  CHANGE 12 IN ALL TO 0+5 (CR)\n             1.     123456ABC  0\n             2.     123456ABC  5\n             3.     AAABBBCCC  10\n             4.     AAABBBCCC  15\n             5.     AAABBBCCC  20\n          COMMAND?\n\n\n          THE INCREMENTING NUMBER MAY BE NEGATIVE.\n\n          COMMAND?  CH 12 IN ALL TO 30-10 (CR)\n             1.     123456ABC  30\n             2.     123456ABC  20\n             3.     AAABBBCCC  10\n             4.     AAABBBCCC  0\n             5.     AAABBBCCC  -10\n          COMMAND?\n\n          IF LEADING ZEROS ARE SPECIFIED IN THE STARTING NUMBER,\n          THEY WILL BE PRESERVED.  IF THE INCREMENT IS POSITIVE,\n          THE SIGN MAY BE OMITTED.\n\n          COMMAND?  CHANGE 9/9 IN 3/5 TO 005 60 (CR)\n             3.     AAABBBCC005\n             4.     AAABBBCC065\n             5.     AAABBBCC125\n          COMMAND?\n\n          LEADING BLANKS  CAN  BE  SPECIFIED  BY  ENCLOSING  THE\n          STARTING  NUMBER  IN  QUOTES.  THE INCREMENTING NUMBER\n          CAN BE NEGATIVE.\n\n          COMMAND?  CHANGE 9/9 IN ALL TO ' 15'-5 (CR)\n             1.     123456AB 15\n             2.     123456AB 10\n             3.     AAABBBCC  5\n             4.     AAABBBCC  0\n             5.     AAABBBCC -5\n          COMMAND?\n\n          NON-NUMERIC CHARACTERS MAY ALSO BE USED IF THE  NUMBER\n          IS  ENCLOSED  IN  QUOTES.   IN  GENERAL, A NON-NUMERIC\n          CHARACTER IS CHANGED TO A BLANK IF AT LEAST ONE  BLANK\n          FOLLOWS  IT IN THE RESULT.  THE CHARACTERS +, -, $ AND\n          # ARE EXCEPTIONS TO THIS RULE.  ONLY ONE OF THESE  MAY\n          OCCUR IN THE NUMBER, AND IT WILL BE PLACED ADJACENT TO\n          THE LEFT-MOST SIGNIFICANT DIGIT.\n\n          COMMAND?  CHANGE 10 IN ALL TO '$ , 15' +270 (CR)\n             1.     123456ABC    $15\n             2.     123456ABC   $285\n             3.     AAABBBCCC   $555\n             4.     AAABBBCCC   $825\n             5.     AAABBBCCC $1,095\n          COMMAND?\n\n\n          THE INCREMENTING NUMBER CAN BE NEGATIVE; THE  STARTING\n          NUMBER  CAN  ALSO  BE  NEGATIVE,  IF IT IS ENCLOSED IN\n          QUOTES.  THE FIELD IS EXPANDED IF  NECESSARY  TO  HOLD\n          MINUS SIGNS.\n\n          COMMAND?  CHANGE 'C' IN 3/5 TO '-5'+1 (CR)\n             3.     AAABBB-5-4-3\n             4.     AAABBB-2-1-0\n             5.     AAABBB 1 2 3\n          COMMAND?\n\n          NORMALLY THE NUMBER IS INCREMENTED FOR EACH OCCURRENCE\n          OF THE STRING TO BE CHANGED.  IT IS POSSIBLE  TO  HAVE\n          IT  INCREMENTED  ONLY AT THE BEGINNING OF EACH LINE TO\n          BE CHANGED.\n\n          COMMAND?  CHANGE 'C' IN ALL TO 15 LINE (CR)\n             1.     123456AB15\n             2.     123456AB16\n             3.     AAABBB171717\n             4.     AAABBB181818\n             5.     AAABBB191919\n\n       C. TRANSFERRED REPLACEMENT  (USING)\n\n          THE THIRD FORM, TRANSFERRED REPLACEMENT,  PERMITS  THE\n          CONTENTS  OF THE REPLACEMENT STRINGS TO BE COPIED FROM\n          ANOTHER LOCATION IN THE  ACTIVE  FILE.   THIS  CAN  BE\n          USEFUL FOR MOVING PORTIONS OF THE ACTIVE FILE AROUND.\n\n          CHANGE POSITION IN RANGE USING REPLACEMENT\n\n          AS FOR EXAMPLE IN :\n\n          COMMAND?  CHANGE 15 IN 1/2 USING 4/5 (CR)\n             1.     123456ABC     AAABBBCCC\n             2.     123456ABC     AAABBBCCC\n          COMMAND?\n\n\n          HERE, THE ENTIRE CONTENTS OF LINES 4 AND 5 HAVE SERVED\n          AS REPLACEMENT STRINGS.  NOTE THAT LINES 4 AND 5  HAVE\n          NOT   BEEN   DELETED   FROM   THE  ACTIVE  FILE.   THE\n          REPLACEMENT RANGE IS LIMITED TO ONE SET OF  CONTIGUOUS\n          LINES.\n\n\n          IF THERE ARE NOT ENOUGH LINES IN THE REPLACEMENT RANGE\n          TO CHANGE THE TARGET RANGE OF LINES, WYLBUR WILL  GIVE\n          YOU  THE  OPTION  OF  REUSING THE REPLACEMENT RANGE BY\n          REPEATING  THE  OPERATION  FROM  THE  BEGINNING.   THE\n          REPEAT PARAMETER MAY BE USED ON THE CHANGE COMMAND  TO\n          ACCOMPLISH THIS FUNCTION.\n\n          COMMAND?  CHANGE 15 IN ALL USING 2/3 REPEAT (CR)\n             1.     123456ABC     123456ABC\n             2.     123456ABC     AAABBBCCC\n             3.     AAABBBCCC     123456ABC\n             4.     AAABBBCCC     AAABBBCCC\n             5.     AAABBBCCC     123456ABC\n          COMMAND?\n\n          IT IS ALSO POSSIBLE TO  RESTRICT  THE  MATERIAL  BEING\n          TRANSFERRED TO CERTAIN COLUMNS OF THE COPIED LINES.\n\n          COMMAND?  CHANGE 15 IN 1/2 USING 4/5 COLUMNS 1/3 (CR)\n             1.     123456ABC     AAA\n             2.     123456ABC     AAA\n          COMMAND?\n\n          ONLY THE CONTENTS OF COLUMNS 1  THROUGH  3  HAVE  BEEN\n          USED AS THE REPLACEMENTS.\n\n          TO TRANSFER THE CONTENTS OF A  SINGLE  COLUMN  FROM  A\n          GROUP OF LINES:\n\n          COMMAND?  CHANGE 15 IN 1/2 USING 4/5 COLUMNS 3/3 (CR)\n             1.     123456ABC     A\n             2.     123456ABC     A\n          COMMAND?\n\n          SPECIFYING A SINGLE COLUMN POSITION ONLY ONCE  IN  THE\n          REPLACEMENT  RANGE CAUSES THAT COLUMN POSITION AND ALL\n          TO THE RIGHT OF IT TO BE USED.\n\n          COMMAND?  CHANGE 15 IN 1/2 USING 4/5 COLUMN 3 (CR)\n             1.     123456ABC     ABBBCCC\n             2.     123456ABC     ABBBCCC\n          COMMAND?\n\n          NORMALLY A NEW LINE IS OBTAINED FOR EACH OCCURRENCE OF\n          THE STRING TO BE REPLACED.  HOWEVER, YOU  MAY  SPECIFY\n          THAT THE RANGES ARE TO BE MATCHED LINE-BY-LINE.\n\n          COMMAND? CH 'C' IN ALL USING 2/3 COLUMNS 1/2 LINE (CR)\n             1.      123456AB12\n             2.      123456ABAA\n             3.      AAABBB121212\n             4.      AAABBBAAAAAA\n             5.      AAABBB121212\n          COMMAND?\n\n\n          IF AN ERROR HAS OCCURED IN THE  CASE  SETTING  (UPPER,\n          UPLOW)  WHILE  ENTERING TEXT, USE ONE OF THE FOLLOWING\n          COMMANDS TO CORRECT THE ERROR:\n\n          COMMAND?  CH ALL TO UPPER IN 1/2\n                           OR\n                    CH ALL TO LOWER IN 1/2\n                           OR\n                    CH 'AAA' TO LOWER IN ALL\n                           OR\n                    CH 'AAA' TO UPPER IN 1/10\n                           OR\n                    CH 22 TO LOWER IN 1/2\n                           OR\n                    CH 22 TO UPPER IN 1/2\n\nTHE ONLY INVALID FORM OF CHANGE TO UPPER/LOWER IS:\n\n          CH 'A' TO LOWER IN ALL\n                OR\n          CH 'A' TO UPPER IN ALL\n\n          NOTE:  WHEN USING THE CHANGE TO  LOWER  OR  CHANGE  TO\n          UPPER, UPLOW IS AUTOMATICALLY SET.\n\n\n=PREPROC1\n\n         WYLBUR PRE-PROCESSOR: DEFINITION OF TERMS\n\n          THE  FOLLOWING  DEFINITIONS  PERTAIN   ONLY   TO   THE\n          PRE-PROCESSOR  (EXCEPT AS NOTED).  ALL ITEMS IN ANGLED\n          BRACKETS (<>) REFER TO ITEMS DEFINED IN THIS SECTION.\n\n         INTEGER\n\n          AN <INTEGER> IS  A  WHOLE  NUMBER  WRITTEN  WITHOUT  A\n          DECIMAL  POINT.  IT MAY BE POSITIVE, NEGATIVE OR ZERO,\n          BUT IT IS ASSUMED TO BE POSITIVE IN THE ABSENCE  OF  A\n          SIGN.   ITS  VALUE MAY NOT BE LESS THAN -999999999 NOR\n          GREATER THAN 999999999.\n\n         LINENO\n\n          A <LINENO>  (LINE  NUMBER)  IS  A  REAL  NUMBER  WHICH\n          CONTAINS  A  DECIMAL POINT.  ITS VALUE MAY NOT BE LESS\n          THAN -99999.999.  NOR GREATER THAN 99999.999.\n\n         STRING\n\n          A <STRING> IS A SERIES OF CHARACTERS.  ITS LENGTH  MAY\n          VARY FROM 1 TO 255.\n\n         CONSTANT\n\n          A <CONSTANT> IS DEFINED  AS  EITHER  AN  <INTEGER>,  A\n          <LINENO>, OR A <STRING>.\n\n         N-VARIABLE\n\n          AN <N-VARIABLE> IS THE LETTER N FOLLOWED BY ONE  DIGIT\n          (0-9).\n\n         W-VARIABLE\n\n          A <W-VARIABLE> IS THE LETTER W FOLLOWED BY  ONE  DIGIT\n          (0-9).\n\n         S-VARIABLE\n\n          AN <S-VARIABLE> IS THE LETTER S FOLLOWED BY ONE  DIGIT\n          (0-9).\n\n         VARIABLE\n\n          THE GENERIC TERM 'VARIABLE' IS USED TO REFER TO EITHER\n          AN <N-VARIABLE>, A <W-VARIABLE>, OR AN <S-VARIABLE>.\n\n          NOTE....NORMALLY    <N-VARIABLES>     ARE     ASSIGNED\n          <INTEGERS>,  <W-VARIABLES> ARE ASSIGNED <LINENOS>, AND\n          <S-VARIABLES> ARE ASSIGNED <STRINGS>.\n\n         KEYWORD (GLOBAL) VARIABLES\n\n          A NUMBER OF WYLBUR  KEYWORDS  (GLOBALS)  HAVE  SPECIAL\n          MEANING    WHEN   USED   IN   CONJUNCTION   WITH   THE\n          PRE-PROCESSOR.  THESE SIGNIFICANT  KEYWORDS  (GLOBALS)\n          ARE: DELTA, FIRST, LAST, END, NEXT, PREVIOUS, CURRENT,\n          *,  LENGTH,  PREFIX,  USER,  MEMBER,  AND  VOLUME.  IN\n          ADDITION  TO  THESE  KEYWORDS  (GLOBALS),  WHICH  HAVE\n          MEANING OUTSIDE THE  PRE-PROCESSOR,  THERE  ARE  OTHER\n          KEYWORDS  (GLOBALS)  WHOSE  MEANING  IS LIMITED TO USE\n          WITH THE PRE-PROCESSOR.  THESE KEYWORDS (GLOBALS) ARE:\n          ESCAPE (ESC) AND SKIP.  THE  VALUES  OF  <ESCAPE>  AND\n          <SKIP>  ARE  DETERMINED BY THE CURRENT SETTINGS OF THE\n          <ESCAPE>  AND  <SKIP>  CHARACTERS,  RESPECTIVELY.    A\n          DESCRIPTION  OF  SETTING AND SHOWING THE VALUES OF THE\n          <ESCAPE> AND <SKIP> CHARACTERS  IS  COVERED  LATER  IN\n          THIS ENTRY.\n\n         FUNCTION\n\n          AMONG THE FACILITIES OF THE PRE-PROCESSOR ARE  SEVERAL\n          <FUNCTIONS>.   THESE ARE SCONVERT, NCONVERT, WCONVERT,\n          SUBSTR, SIZE, INDEX, VERIFY, DISPLAY, SHEX, NHEX,  AND\n          WHEX.   FOR DESCRIPTIONS OF THESE <FUNCTIONS>, SEE THE\n          ENTRY \"PREPROC2\".\n\n         PRIMARY\n\n          FOR EASE IN REFERENCE, WE SHALL REFER TO A  NUMBER  OF\n          THINGS AS A 'PRIMARY.'  THIS GROUPING WILL INCLUDE THE\n          FOLLOWING  ITEMS:   <VARIABLE>,  <CONSTANT>,  <KEYWORD\n          (GLOBAL)  VARIABLE>,  ANY OF THE <FUNCTIONS>, AND WILL\n          ALSO BE  USED  TO  REFER  TO  A  <CEXPR>  ENCLOSED  IN\n          PARENTHESES.   A  <PRIMARY> MAY BE SIGNED OR UNSIGNED.\n          IF NO SIGN IS PRESENT \"+\" IS ASSUMED.\n\n         TERM\n\n          A  <TERM>  IS  DEFINED  AS  A  <PRIMARY>,   A   <TERM>\n          MULTIPLIED  BY  A  <PRIMARY>, OR A <TERM> DIVIDED BY A\n          <PRIMARY>.\n\n         AEXPR\n\n          AN <AEXPR> IS DEFINED AS A <TERM>, AN <AEXPR>  PLUS  A\n          <TERM>, OR AN <AEXPR> MINUS A <TERM>.\n\n         CEXPR\n\n          A <CEXPR> IS DEFINED AS EITHER AN <AEXPR> OR A <CEXPR>\n          CATENATED WITH AN <AEXPR>.\n\n         DESCRIPTION OF THE WYLBUR PRE-PROCESSOR\n\n          THE PRE-PROCESSOR SCANS ALL  WYLBUR  COMMANDS  LOOKING\n          FOR   EITHER   (OR   BOTH)   OF  THE  TWO  SIGNIFICANT\n          USER-CONTROLLED CHARACTERS, THE <EXCAPE> CHARACTER AND\n          THE  <SKIP>  CHARACTER.   IF  NEITHER  OF  THESE   TWO\n          CHARACTERS  IS  PRESENT  IN  THE  TEXT  GIVEN  TO  THE\n          PRE-PROCESSOR, NO CHANGE IS MADE; OTHERWISE, THERE ARE\n          FIVE CASES DESCRIBED IN THE FORMAT:\n\n         <INPUT TEXT> --- <OUTPUT TEXT>\n\n          WHERE '%' IS ASSUMED TO BE THE <ESCAPE> CHARACTER, '$'\n          IS ASSUMED TO BE THE <SKIP> CHARACTER AND '|'  DENOTES\n          THE  SCAN  POINTER.   SUBSTITUTIONS  WILL  BE  MADE AS\n          FOLLOWS:\n\n         %<VARIABLE><TEXT> --- <VALUE> <TEXT>\n         |                            |\n\n         %(<CEXPR>)<TEXT> --- <VALUE> <TEXT>\n         |                           |\n\n         %%<VARIABLE><TEXT> --- <VALUE><TEXT>\n         |                     |\n\n         %%(<CEXPR>)<TEXT> ---  <VALUE><TEXT>\n         |                     |\n\n         $<CHARACTER><TEXT> --- <CHARACTER> <TEXT>\n         |                                 |\n\n          ANY SUBSTITUTIONS OR CHANGES TO  A  COMMAND  ARE  MADE\n          EACH  TIME  THE  COMMAND  IS EXECUTED.  IF THE COMMAND\n          CAME FROM A FILE, THE FILE IS NOT CHANGED; ONLY A COPY\n          OF  THE  COMMAND  IS  CHANGED  AND   IS   SUBSEQUENTLY\n          EXECUTED.   ALL SUBSTITUTIONS ARE COMPLETED BEFORE THE\n          COMMAND IS EXECUTED.  THE TERSE/VERBOSE MODES  CONTROL\n          THE  LISTING OF THE CHANGED COMMAND.  IF TERSE IS SET,\n          THE CHANGED COMMAND IS NOT  LISTED  BEFORE  EXECUTION.\n          IF,  HOWEVER,  VERBOSE  IS SET, THE CHANGED COMMAND IS\n          LISTED BEFORE IT IS EXECUTED.\n\n         COMMAND LANGUAGE\n\n          SEE THE INDIVIDUAL  HELP  ENTRIES  FOR  THE  FOLLOWING\n          COMMANDS:\n\n         IF COMMAND\n         SET AND SHOW VALUE (SEE THE \"SET\" COMMAND)\n         READ COMMAND\n         SET AND SHOW ESCAPE (SEE THE \"SET\" COMMAND)\n         SET AND SHOW SKIP (SEE THE \"SET\" COMMAND)\n         SET AND SHOW RESCAN (SEE THE \"SET\" COMMAND)\n\n\n         EXAMPLES OF PRE-PROCESSOR USAGE\n\n          IN  THE  FOLLOWING  SECTION  YOU  WILL  FIND  EXAMPLES\n          DESCRIBING  THE  USE  OF  THE  PRE-PROCESSOR.    THESE\n          EXAMPLES  ARE  MEANT  TO DEMONSTRATE THE FACILITIES OF\n          THE  PRE-PROCESSOR.   A  POINT  HAS   BEEN   MADE   TO\n          DEMONSTRATE  THE USE OF THE ESCAPE AND SKIP CHARACTERS\n          AS WELL AS THE RESCAN FEATURE.\n\n          THE PRE-PROCESSOR CANNOT BE INVOKED  UNTIL  AN  ESCAPE\n          CHARACTER  HAS  BEEN  SET.   SINCE,  IN  THE FOLLOWING\n          EXAMPLES, BOTH THE ESCAPE AND SKIP CHARACTERS WILL  BE\n          USED, LET US FIRST SET THESE.\n\n                   COMMAND?  SET ESCAPE &\n                   COMMAND?  SET SKIP /\n\n          IN THE ABOVE COMMANDS, IT IS NOT NECESSARY TO  ENCLOSE\n          THE  ESCAPE  AND SKIP CHARACTERS IN QUOTATIONS BECAUSE\n          NEITHER  OF  THEM  IS  CONSIDERED  TO  BE  A   SPECIAL\n          CHARACTER.   THE  ESCAPE  AND SKIP CHARACTERS HAVE NOW\n          BEEN SET FOR OUR SESSION AND WILL REMAIN SET TO  THESE\n          VALUES  UNTIL CHANGED VIA ANOTHER \"SET ESCAPE\" OR \"SET\n          SKIP\" COMMAND.\n\n         LET US PROCEED WITH AN EXAMPLE:\n\n\n         COMMAND?  SET VALUE S0 'SHOW DSNAMES SPACE LIKE ACT ON ' (CR)\n         COMMAND?  &S0 TSOWK1 (CR)\n         SHOW DSNAMES SPACE LIKE ACT ON TSOWK1\n         TSOWK1\n         UUUUU.ACTIVE -- 13 TRKS\n         UUUUU.ACTIVITY -- 2 TRKS\n         COMMAND?  &S0 TSOWK2 (CR)\n         SHOW DSNAMES SPACE LIKE ACT ON TSOWK2\n         TSOWK2\n         COMMAND?\n\n          IN  THE  ABOVE  EXAMPLE  A  VALUE  IS  SET  INTO   THE\n          PRE-PROCESSOR  STRING  VARIABLE  S0.   IT HAPPENS THAT\n          THIS VALUE IS A  WYLBUR  COMMAND.   WHEN,  IN  COMMAND\n          MODE, AN ESCAPE CHARACTER (& IN THIS CASE) IS FOLLOWED\n          BY  S0, THE PRE-PROCESSOR IS INVOKED TO SUBSTITUTE THE\n          VALUE OF THE VARIABLE S0 AND TO RESUME SCANNING AT THE\n          END OF  THE  TEXT  WHICH  WAS  SUBSTITUTED.   IN  THIS\n          EXAMPLE,  THERE ARE NO ADDITIONAL ESCAPE CHARACTERS IN\n          THE COMMAND, HENCE NO FURTHER  SUBSTITUTIONS  NEED  BE\n          MADE.   AS  WAS  MENTIONED  IN  THE DESCRIPTION OF THE\n          PRE-PROCESSOR, SINCE  WE  ARE  IN  VERBOSE  MODE,  THE\n          COMMAND IS RETYPED BY WYLBUR AFTER ALL THE APPROPRIATE\n          SUBSTITUTIONS  HAVE BEEN MADE.  THE COMMAND, AS IT WAS\n          RETYPED, IS THEN EXECUTED.\n\n\n          IN THE NEXT EXAMPLE, ASSUME THAT THE VALUE  OF  S0  IS\n          UNCHANGED, BUT THAT WE INTRODUCE TWO NEW VARIABLES, S1\n          AND S2 AS FOLLOWS:\n\n         COMMAND?  SET VALUE S1 'TSOWK1' (CR)\n         COMMAND?  SET VALUE S2 'TSOWK2' (CR)\n\n          THIS EXAMPLE WILL THEN DEMONSTRATE THE USE OF MULTIPLE\n          VARIABLES IN A SINGLE COMMAND:\n\n         COMMAND?  &S0 &S1 (CR)\n         SHOW DSNAMES SPACE LIKE ACT ON TSOWK1\n         TSOWK1\n         UUUUU.ACTIVE -- 13 TRKS\n         UUUUU.ACTIVITY -- 2 TRKS\n         COMMAND?  &S0 &S2 (CR)\n         SHOW DSNAMES SPACE LIKE ACT ON TSOWK2\n         TSOWK2\n         COMMAND?\n\n          IN THE ABOVE EXAMPLE TWO SUBSTITUTIONS ARE  MADE:  ONE\n          (IN  EACH  CASE) FOR THE VALUE OF S0,  AND ANOTHER FOR\n          THE VALUE OF S1 (OR, IN THE SECOND CASE, S2).   AGAIN,\n          THE  COMMANDS  ARE  TYPED  BY  WYLBUR  BEFORE THEY ARE\n          EXECUTED.\n\n          THIS CAN BE FURTHER GENERALIZED BY CHANGING THE  VALUE\n          OF S0 AS IN THE FOLLOWING EXAMPLE:\n\n         COMMAND?  SET VAL S0 'SHOW DSNAMES SPACE LIKE /&S9 ON '\n         SET VALUE S0 'SHOW DSNAMES SPACE LIKE &S9 ON '\n         COMMAND?  SHOW VALUE S0\n         'SHOW DSNAMES SPACE LIKE &S9 ON '\n         COMMAND?\n\n          NOTE, IN THE ABOVE \"SET VALUE\" COMMAND, THE USE OF THE\n          SKIP CHARACTER (/) TO FORCE THE PRE-PROCESSOR TO  SKIP\n          THE  SUBSEQUENT CHARACTER, WHICH IS, IN THIS CASE, THE\n          ESCAPE CHARACTER (&).  THE  EFFECT  OF  THIS  IS  THAT\n          SINCE  THE  PRE-PROCESSOR  DOESN'T  \"SEE\"  THE  ESCAPE\n          CHARACTER,  TEXT SUBSTITUTION IS NOT PERFORMED FOR THE\n          VALUE OF S9.  NOW, LET US SET THE VALUE OF S9  TO  THE\n          DSNAMES WE WANT TO LOOK FOR:\n\n         COMMAND? SET VALUE S9 'ACT' (CR)\n\n          SINCE WE WANT THE PRE-PROCESSOR TO  RESCAN  THE  VALUE\n          WHICH  WILL  BE SUBSTITUTED FOR S0 (SO THAT THE PROPER\n          VALUE OF S9 WILL BE PUT IN), WE MUST PRECEDE S0  BY  A\n          PAIR OF ESCAPE CHARACTERS WHEN WE ENTER THE COMMAND:\n\n         COMMAND?  &&S0 &S1 (CR)\n         SHOW DSNAMES SPACE LIKE ACT ON TSOWK1\n         TSOWK1\n         UUUUU.ACTIVE -- 13 TRKS\n         UUUUU.ACTIVITY -- 2 TRKS\n         COMMAND?  SET VALUE S9 'TEST' (CR)\n         COMMAND?  &&S0 &S1 (CR)\n         SHOW DSNAMES SPACE LIKE TEST ON TSOWK1\n         TSOWK1\n         UUUUU.TESTRUN -- 10 TRKS\n         COMMAND?  SET VALUE S9 'PGM' (CR)\n         COMMAND?  &&S0 &S2 (CR)\n         SHOW DSNAMES SPACE LIKE PGM ON TSOWK2\n         TSOWK2\n         UUUUU.PGM1 -- 1 TRKS\n         UUUUU.PGM2 -- 1 TRKS\n         UUUUU.PGM3 -- 1 TRKS\n         COMMAND?\n\n          YOU CAN SEE THAT IN THIS CASE, SIMPLY BY CHANGING  THE\n          VALUE  OF  S9, THE DATA SET FOR WHICH WE SEARCH CAN BE\n          CHANGED.   IN  EITHER  OF  THE  FIRST  TWO   EXAMPLES,\n          HOWEVER,  WE  WOULD HAVE HAD TO RESET THE ENTIRE VALUE\n          OF S0.  IN THIS  WAY  WE  HAVE  SAVED  OURSELVES  SOME\n          TYPING!\n\n          ON ENCOUNTERING THE  ABOVE  INPUT,  THE  PRE-PROCESSOR\n          MUST  MAKE SEVERAL SUBSTITUTIONS.  THESE SUBSTITUTIONS\n          ARE INDICATED IN THE FOLLOWING LINES.  IN EACH OF  THE\n          LINES  BELOW,  THE  VERTICAL  BAR  (|)  INDICATES  THE\n          POSITION  OF  THE  SCAN POINTER AFTER EACH SCAN OF THE\n          COMMAND:\n\n         COMMAND?  &&S0 &S2 (CR)\n         1 -> SHOW DSNAMES SPACE LIKE &S9 ON &S2\n              |\n\n         2 -> SHOW DSNAMES SPACE LIKE PGM ON &S2\n                                         |\n\n         3 -> SHOW DSNAMES SPACE LIKE PGM ON TSOWK2\n                                                   |\n\n          IT IS THIS LAST VERION OF THE COMMAND WHICH  IS  TYPED\n          OUT  BY WYLBUR BEFORE EXECUTION.  NOTE THAT IN LINE 1,\n          THE VALUE OF S0 IS SUBSTITUTED AND THE SCAN POINTER IS\n          POSITIONED AT THE BEGINNING OF  THE  SUBSTITUTED  TEXT\n          FOR  RESCANNING  OF THAT TEXT (THIS IS DUE TO THE PAIR\n          OF ESCAPE CHARACTERS PRECEDING S0).  UPON ENCOUNTERING\n          AN ESCAPE CHARACTER IN THE SUBSTITUTED TEXT (I.E. WHEN\n          IT FINDS &S9 AFTER IT HAS  SUBSTITUTED  THE  VALUE  OF\n          S0), ANOTHER SUBSTITUTION IS MADE FOR THE VALUE OF S9.\n          AT  THIS  TIME,  BECAUSE  S9  IS  PRECEDED BY A SINGLE\n          ESCAPE CHARACTER, THE SCAN POINTER IS POSITIONED AFTER\n          THE SUBSTITUTED VALUE OF S9 AND SCANNING CONTINUES.\n\n          ONE FINAL EXAMPLE WILL ILLUSTRATE THE USE OF  MULTIPLE\n          RESCANS.   SUPPOSE  YOU  WISH TO DETERMINE HOW MANY OF\n          YOUR GROUP MEMBERS HAVE FILES NAMED ACTIVE ON  TSOWK1,\n          TSOWK2,   AND  TSOWK3.   THE  FOLLOWING  EXAMPLE  WILL\n          DEMONSTRATE ONE METHOD  OF  ANSWERING  THIS  QUESTION.\n          SUPPOSE  THAT  THE ESCAPE AND SKIP CHARACTERS HAVE NOT\n          BEEN CHANGED FROM THE PREVIOUS EXAMPLES.\n\n         COMMAND? SHOW ESCAPE (CR)\n         & - ESCAPE CHAR\n         COMMAND? SHOW SKIP (CR)\n         / - SKIP CHAR\n         COMMAND?  SET VAL S0 'SHOW DSNAMES LIKE /&/&S9 ON ' (CR)\n         SET VALUE S0 'SHOW DSNAMES LIKE &&S9 ON '\n         COMMAND?  SET VAL S1 'TSOWK1' (CR)\n         COMMAND?  SET VAL S2 'TSOWK2' (CR)\n         COMMAND?  SET VAL S3 'TSOWK3' (CR)\n         COMMAND?  SET VALUE S9 'U4IA0./&S8.ACTIVE' (CR)\n         SET VALUE S9 'U4IA0.&S8.ACTIVE'\n         COMMAND?  SET VAL S8 'ABC' (CR)\n         COMMAND?  &&S0 &S1 (CR)\n         SHOW DSNAMES LIKE R4IA0.ABC.ACTIVE ON TSOWK1\n         TSOWK1\n         R4IA0.ABC.ACTIVE\n         COMMAND?  &&S0 &S2 (CR)\n         SHOW DSNAMES LIKE R4IA0.ABC.ACTIVE ON TSOWK2\n         TSOWK2\n         COMMAND?  SET VALUE S8 'DEF' (CR)\n         COMMAND &&S0 &S1 (CR)\n         SHOW DSNAMES LIKE R4IA0.DEF.ACTIVE ON TSOWK1\n         TSOWK1\n         R4IA0.DEF.ACTIVE\n         COMMAND?  &&S0 &S2 (CR)\n         SHOW DSNAMES LIKE R4IA0.DEF.ACTIVE ON TSOWK2\n         TSOWK2\n         COMMAND?\n\n          YOU COULD CONTINUE CHANGING THE VALUE OF S8 UNTIL  YOU\n          HAD  LOOKED  FOR  ALL  THE  MEMBERS OF YOUR GROUP.  IN\n          THESE COMMANDS, TEXT SUBSTITUTION IS PERFORMED IN  THE\n          FOLLOWING   WAY   (IN  EACH  LINE,  THE  VERTICAL  BAR\n          INDICATES THE POSITION OF THE SCAN POINTER):\n\n         COMMAND?  &&S0 &S2 (CR)\n         1 -> SHOW DSNAMES LIKE &&S9 ON &S2\n              |\n\n         2 -> SHOW DSNAMES LIKE R4IA0.&S8.ACTIVE ON &S2\n                                |\n\n         3 -> SHOW DSNAMES LIKE R4IA0.DEF.ACTIVE ON &S2\n                                         |\n\n         4 -> SHOW DSNAMES LIKE R4IA0.DEF.ACTIVE ON TSOWK2\n\n          IN THE ABOVE EXAMPLE, RESCAN MUST BE SET TO  AT  LEAST\n          THREE.   IF  RESCAN  HAS BEEN SET TO A VALUE LESS THAN\n          THREE, THE FOLLOWING MESSAGE WILL  BE  TYPED  AND  THE\n          COMMAND WILL BE ABORTED:\n\n             TOO MANY RESCANS, PREPROCESSING ABORTED\n\n          THIS IS TRUE IN GENERAL WHEN THE RESCAN COUNT  IS  TOO\n          SMALL  TO  ALLOW  FULL  PRE-PROCESSING OF THE COMMAND.\n          THIS CAN BE RECTIFIED  BY  USE  OF  THE  \"SET  RESCAN\"\n          COMMAND  DESCRIBED  IN  THE  HELP  ENTRY FOR THE \"SET\"\n          COMMAND.  RESCAN MUST  BE  ONE  MORE  THAN  THE  TOTAL\n          NUMBER  OF  PAIRS  OF  ESCAPE  CHARACTERS  WHICH  WILL\n          EVENTUALLY  BE  ENCOUNTERED  BY THE PRE-PROCESSOR.  IN\n          THE ABOVE  EXAMPLE  THERE  ARE  TWO  PAIRS  OF  ESCAPE\n          CHARACTERS  (PRECEDING S0 IN THE COMMAND AND PRECEDING\n          S9 WITHIN S0) HENCE RESCAN MUST BE  SET  TO  AT  LEAST\n          2+1=3.  NOTE.....IN THE ABOVE EXAMPLES THAT AN ABSENCE\n          OF  THE  DESIRED  DATA  SET  ON  A VOLUME STILL CAUSES\n          WYLBUR TO TYPE OUT THE VOLUME NAME BEFORE COMING  BACK\n          TO THE COMMAND MODE.\n\n=PREPROC2\n)F FUNCTION -\n\n          THIS SECTION IS NOT MEANT FOR BEGINNING  WYLBUR  USERS\n          DUE TO THE COMPLEXITY OF THE MATERIAL BEING PRESENTED.\n          ALL OF THE INFORMATION HERE IS AVAILABLE UNDER VARIOUS\n          OTHER  HELP  ENTRIES, BUT IS GATHERED HERE TO ENABLE A\n          MORE EASILY UNDERSTOOD EXPLANATION  OF  THE  FUNCTIONS\n          AND  CAPABILITIES  OF THE PRE-PROCESSOR AND WHAT \"EXEC\n          FILES\" ARE REALLY CAPABLE OF DOING FOR YOU.\n\n          IN ALL  OF  THE  ENTRIES  LISTED  BELOW,  THE  VARIOUS\n          KEYWORDS ARE PRESENTED ON THE LEFT OF THE \"=\" SIGN AND\n          THE  VALUES  THE  KEYWORDS  MAY  TAKE ARE ON THE RIGHT\n          SEPARATED BY THE VERTICAL BAR (|) CHARACTER.\n\n            SPECIFICATION OF WYLBUR PRE-PROCESSOR FEATURES\n\n\n          THE PRE-PROCESSOR FEATURES DESCRIBED BELOW  HAVE  BEEN\n          ADDED  TO  WYLBUR  TO ENHANCE EXEC FILE PROCESSING AND\n          GENERAL WYLBUR CAPABILITIES.\n\n\n I.  EXTENSIONS\n\n     A.  SET AND SHOW VALUE COMMANDS\n\n         1.  SET VALUE <VARIABLE>=<EXP>\n\n             A.  EXPRESSION SYNTAX\n                 <INTEGER>  = <1 TO 9 DIGITS>\n                 <LINENO>  = <0 TO 5 DIGITS>.<1 TO 3 DIGITS> |\n                             <1 TO 5 DIGITS>.\n                 <STRING>  = '<0 TO 255 CHARACTERS>' |\n                             \"<0 TO 255 CHARACTERS>\"\n                 <CONSTANT>  = <STRING> | <LINENO> | <INTEGER>\n                 <NVARIABLE>  = N<ONE DIGIT>\n                 <WVARIABLE>  = W<ONE DIGIT>\n                 <SVARIABLE>  = S<ONE DIGIT>\n                 <VARIABLE>  = <NVARIABLE> | <WVARIABLE> | <SVARIABLE>\n                 <KEYWORD VAR>  = DELTA | FIRST | LAST | END | NEXT |\n                                  PREVIOUS | CURRENT | * | LENGTH |\n                                  PREFIX | MEMBER |\n                                  VOLUME | DATE | ESCAPE | SKIP |\n                                  PAGES | LINES | RANDOM |\n                                  CP | PROJECT\n                 <PRIMARY>  = <VARIABLE> | <CONSTANT> | (<EXP>) |\n                              <KEYWORD VAR> | -<PRIMARY> | +<PRIMARY>\n                              <1 VAR FUNCTION>(<EXP>) |\n                              <2 VAR FUNCTION>(<EXP>,<EXP>) |\n                              <3 VAR FUNCTION>(<EXP>,<EXP>,<EXP>)\n                 <1 VAR FUNCTION>  = SIZE | TDUMP | CORE | EXPAND |\n                                     SCONVERT | NCONVERT | WCONVERT |\n                                     SHEX | NHEX | WHEX | DISPLAY |\n                                     REVERSE | TRIM | LTRIM | RTRIM |\n                                     NEGATE\n                 <2 VAR FUNCTION>  = INDEX | RINDEX | LINDEX | TDUMP |\n                                     XLATE | SUBSTR | LSUBSTR |\n                                     RSUBSTR | VERIFY | LVERIFY |\n                                     RVERIFY | PAD | RPAD | LPAD |\n                                     TRIM | LTRIM | RTRIM | DUPL |\n                                     XOR | AND | OR\n                 <3 VAR FUNCTION>  = XLATE | SUBSTR | RSUBSTR |\n                                     LSUBSTR | PAD | RPAD | LPAD\n                 <TERM>  = <PRIMARY> | <TERM> * <PRIMARY> |\n                           <TERM>/<PRIMARY>\n                 <AEXPR>  = <TERM> | <AEXPR>+<TERM> | <AEXPR>-<TERM>\n                 <EXP>  = <AEXPR> | <EXP>||<AEXPR>\n\n\n             B.  THE EXPRESSION SYNTAX IS GIVEN IN A FAIRLY  STANDARD\n                 BNF  GRAMMAR  FORMAT.   EXPRESSIONS  HAVE FIVE BASIC\n                 OPERATORS   AND   THREE    LEVELS    OF    PRIORITY.\n                 MULTIPLICATION (*) AND DIVISION (/) HAVE THE HIGHEST\n                 PRIORITY  AND ARE PERFORMED FIRST.  ADDITION (+) AND\n                 SUBTRACTION (-) HAVE THE NEXT PRIORITY,  AND  STRING\n                 CATENATION  (||) IS PERFORMED LAST.  PARENTHESES CAN\n                 BE  USED  TO  CAUSE  ANY  OTHER  DESIRED  ORDER   OF\n                 EVALUATION.\n\n             C.  THERE ARE  ONLY  30  VARIABLES  AND  THEY  ALL  HAVE\n                 PRE-DECLARED  NAMES  (N0-N9,  W0-W9  AND S0-S9).  AN\n                 <NVARIABLE> CAN BE SET TO ANY  <INTEGER>  VALUE.   A\n                 <WVARIABLE>  CAN  BE  SET TO ANY <LINENO> VALUE.  AN\n                 <SVARIABLE> CAN BE SET TO ANY <STRING>  VALUE.   THE\n                 SYNTAX FOR <LINENO>, <INTEGER> AND <STRING> IS GIVEN\n                 JUST  TO SHOW THE RANGE OF VALUES ALLOWED.  <LINENO>\n                 AND <INTEGER> EXPRESSIONS CAN HAVE RESULTS THAT  ARE\n                 ANY  VALUE REPRESENTABLE BY A FULL WORD.  THE LENGTH\n                 OF A <STRING> MUST  BE  LESS  THAN  256  CHARACTERS.\n                 INITIALLY,  N0-N9  AND W0-W9 ARE SET TO 0; S0-S9 ARE\n                 SET TO NULL.\n\n             D.  ONE OR MORE BLANKS, COMMAS, AND/OR EQUAL  SIGNS  CAN\n                 BE  USED  BETWEEN  ARGUMENTS,  AROUND OPERATORS, AND\n                 BEFORE AND AFTER PARENTHESES.  THEY ARE NORMALLY NOT\n                 REQUIRED IF THE SEPARATION IS  CLEAR  WITHOUT  THEM.\n                 HOWEVER,  A  RESTRICTION  ON THE USE OF MULTIPLY (*)\n                 NOW REQUIRES ONE OR MORE BLANKS,  COMMAS,  OR  EQUAL\n                 SIGNS  ON BOTH SIDES OF THE * TO BE PROPERLY SCANNED\n                 IF THE TWO ARGUMENTS ARE CONSTANTS OR VARIABLES.\n\n             E.  IF CURRENT, NEXT, AND/OR PREVIOUS ARE  USED  IN  ANY\n                 <EXP>  AND  THEY ARE NOT SET, THEY WILL BE GIVEN THE\n                 VALUE -1.000 INSTEAD OF CAUSING AN EXEC BREAK.\n\n             F.  MIXED  TYPES  ARE  ALWAYS  CONVERTED   AUTOMATICALLY\n                 BEFORE THE OPERATION IS DONE.  FOR MIXED INTEGER AND\n                 LINE  NUMBER OPERATIONS, THE INTEGER IS CONVERTED TO\n                 A  LINE  NUMBER.   FOR  ARITHMETIC   OPERATIONS   ON\n                 STRINGS,  THE STRING(S) ARE CONVERTED TO INTEGERS OR\n                 LINE NUMBERS FIRST, AND THEN NORMAL INTEGER TO  LINE\n                 NUMBER  CONVERSION IS DONE IF NEEDED.  THE FUNCTIONS\n                 SCONVERT, WCONVERT, AND NCONVERT  ARE  AVAILABLE  TO\n                 FORCE DIFFERENT CONVERSION.  EACH OF THESE FUNCTIONS\n                 TAKES  ANY  TYPE  OF  <EXP> AS ITS ARGUMENT AND DOES\n                 ANY  CONVERSION  NECESSARY  TO   OUTPUT   A   STRING\n                 (SCONVERT),   LINE  NUMBER  (WCONVERT),  OR  INTEGER\n                 (NCONVERT) VALUE.\n\n\n             G.  WHENEVER A LINE NUMBER  IS  CONVERTED  TO  A  STRING\n                 (INCLUDING  PRE-PROCESSOR SUBSTITUTIONS), THE STRING\n                 IS MADE TO ALWAYS CONTAIN A 3-DIGIT FRACTIONAL  PART\n                 EVEN IF THE FRACTIONAL PART IS '.000'.\n\n             H.  SUBSTR PERFORMS A SUBSTRING OPERATION ON THE  STRING\n                 SPECIFIED   AS   THE  FIRST  ARGUMENT.   THE  SECOND\n                 ARGUMENT SPECIFIES  THE  STARTING  POSITION  OF  THE\n                 SUBSTRING,  AND  THE  THIRD  ARGUMENT  SPECIFIES THE\n                 LENGTH.  IF THE THIRD ARGUMENT IS OMITTED, THE  REST\n                 OF  THE  STRING AFTER THE STARTING POSITION IS USED.\n                 THE STARTING POSITION AND LENGTH NEED NOT BE  WITHIN\n                 THE  STRING  OPERAND  BOUNDARIES, BUT THEY CANNOT BE\n                 NEGATIVE NOR SUM TO MORE THAN 256.  THE RESULT  WILL\n                 BE A NULL STRING IF THE LENGTH OPERAND IS ZERO OR IF\n                 THE  LENGTH  IS OMITTED AND THE STARTING POSITION IS\n                 BEYOND THE STRING OPERAND.  THE RESULT WILL BE BLANK\n                 FILLED ON THE RIGHT TO GIVE A RESULT THAT  IS  EQUAL\n                 IN  LENGTH  TO THE SPECIFIED LENGTH OPERAND WHENEVER\n                 THE  STRING  OPERAND  IS  NOT  LONG ENOUGH.  LSUBSTR\n                 FUNCTION  IS  IDENTICAL TO SUBSTR.  RSUBSTR FUNCTION\n                 DOES THE SAME FUNCTION AS SUBSTR WITH THE DIFFERENCE\n                 THAT  THE START POSITION IS SPECIFIED FROM THE RIGHT\n                 HAND SIDE OF THE FIRST ARGUMENT.\n\n             I.  VERIFY EXAMINES THE TWO OPERAND  STRINGS  TO  VERIFY\n                 THAT   EACH   CHARACTER   IN  THE  FIRST  STRING  IS\n                 REPRESENTED IN THE SECOND STRING.  IF  THIS  IS  THE\n                 CASE,  A  VALUE  OF  0 IS THE RESULT; OTHERWISE, THE\n                 VALUE RETURNED IS THE INDEX OF THE  FIRST  CHARACTER\n                 IN  THE  FIRST STRING THAT IS NOT REPRESENTED IN THE\n                 SECOND  STRING.   LVERIFY  IS  SYNONYMOUS TO VERIFY.\n                 RVERIFY  PERFORMS  THE  SAME  FUNCTION AS VERIFY BUT\n                 THE VERIFICATION STARTS FROM THE RIGHT HAND SIDE.\n\n             J.  SIZE SIMPLY HAS A VALUE EQUAL TO THE LENGTH  OF  THE\n                 ARGUMENT STRING.\n\n             K.  INDEX FINDS THE  STARTING  POSITION  OF  THE  STRING\n                 SPECIFIED  AS  THE SECOND ARGUMENT WITHIN THE STRING\n                 SPECIFIED AS THE  FIRST  ARGUMENT.   IF  THE  SECOND\n                 STRING  IS  NOT  IN THE FIRST STRING, THE VALUE 0 IS\n                 RETURNED.  LINDEX  IS  SYNONYMOUS  TO INDEX.  RINDEX\n                 RETURNS THE STARTING POSITION OF THE FIRST OCCURENCE\n                 OF THE STRING SPECIFIED AS THE SECOND ARGUMENT  FROM\n                 SCANNING FROM THE RIGHT HAND SIDE OF THE STRING.\n\n\n             L.  DISPLAY CONVERTS THE  ARGUMENT  TO  ITS  HEXADECIMAL\n                 REPRESENTATION.   IF  THE  ARGUMENT IS A STRING, THE\n                 RESULT IS A STRING OF TWICE THE LENGTH,  SINCE  EACH\n                 CHARACTER  OF THE ARGUMENT STRING IS NOW REPRESENTED\n                 AS   TWO   CHARACTERS   WHICH   ARE    ITS    EBCDIC\n                 REPRESENTATION  IN HEX (E.G.  DISPLAY('A1')='C1F1').\n                 IF THE ARGUMENT IS A LINE  NUMBER  OR  INTEGER,  THE\n                 RESULT  IS  AN  EIGHT CHARACTER STRING CONSISTING OF\n                 THE HEX DIGITS FOR THE  INTERNAL  REPRESENTATION  OF\n                 THE     LINE     NUMBER     OR     INTEGER     (E.G.\n                 DISPLAY(1.)=DISPLAY(1000)='000003E8').\n\n             M.  SHEX  IS  THE  INVERSE  OF  DISPLAY  WITH  A  STRING\n                 ARGUMENT.  THE HEX DIGITS OF THE STRING ARGUMENT ARE\n                 PACKED TO FORM THE CHARACTERS.  THE RESULTANT STRING\n                 IS HALF THE LENGTH  OF  THE  ARGUMENT  STRING  (E.G.\n                 SHEX('C1F1')='A1').   THIS  FUNCTION  CAN BE USED TO\n                 DIRECTLY CREATE ANY OF THE  256  POSSIBLE  CHARACTER\n                 CODES.   MOST  OF  THESE  CODES  WILL  TYPE  ON  THE\n                 TERMINAL  AS  A  ':'  TO  SHOW  THAT  THEY  ARE  NOT\n                 PRINTABLE.   AS AN EXTENSION, THE SHEX FUNCTION ALSO\n                 ALLOWS INTEGER ARGUMENTS.  THE RESULT  IS  A  STRING\n                 THAT   STRIPS  OFF  LEADING  X'00'  BYTES  FROM  THE\n                 INTERNAL  REPRESENTATION  OF   THE   INTEGER   (E.G.\n                 SHEX(241)=SHEX('F1')='1').\n\n             N.  NHEX IS THE  INVERSE  OF  DISPLAY  WITH  AN  INTEGER\n                 ARGUMENT.   THE  STRING OF UP TO 8 HEX CHARACTERS IS\n                 PACKED TO  FORM  AN  INTERNAL  INTEGER  VALUE  (E.G.\n                 NHEX('3E8')=1000).\n\n             O.  WHEX IS THE INVERSE OF DISPLAY WITH  A  LINE  NUMBER\n                 ARGUMENT.   THE  STRING OF UP TO 8 HEX CHARACTERS IS\n                 PACKED TO FORM AN INTERNAL LINE NUMBER  VALUE  (E.G.\n                 WHEX('3E8')=1.000).\n\n             P.  THE  PAD  FUNCTION RETURNS ITS FIRST ARGUMENT PADDED\n                 TO A LENGTH  SPECIFIED  BY THE SECOND ARGUMENT.  THE\n                 FILL CHARACTER IS SPECIFIED WITH THE THIRD ARGUMENT.\n                 IF THERE IS NO THIRD ARGUMENT THE FILL CHARACTER  IS\n                 A SPACE.  RPAD IS SYNONYMOUS TO PAD.  LPAD PADS  ITS\n                 ARGUMENT ON THE LEFT HAND SIDE.\n\n             Q.  THE  TRIM  AND  RTRIM  FUNCTIONS  STRIP  THEIR FIRST\n                 ARGUMENT OFF OF THE TRIM CHARACTER SPECIFIED AS  THE\n                 SECOND ARGUMENT ON THE LEFT HAND SIDE. IF THE SECOND\n                 ARGUMENT IS OMITTED THE TRIM CHARACTER  IS A  BLANK.\n                 THE LTRIM FUNCTION DOES THE SAME ON THE LEFT SIDE.\n\n             R.  REVERSE FUNCTION RETURNS THE REVERSE OF ITS ARGUMENT\n\n             S.  DUPL FUNCTION RETURNS A STRING CONSTRUCTED BY DUPLI-\n                 CATING ITS FIRST ARGUMENT AS MANY TIMES AS SPECIFIED\n                 BY ITS SECOND ARGUMENT.\n\n             T.  XOR, AND, OR FUNCTIONS TAKE TWO ARGUMENTS AND RETURN\n                 A STRING FORMED BY THE LOGICAL OPERATION IMPLIED  BY\n                 THE FUNCTION NAME.  SHORTER OF THE ARGUMENTS IS  EX-\n                 PANDED ON THE RIGHT SIDE BY ADDING BLANKS.\n\n             U.  NEGATE FUNCTION RETURNS A STRING FORMED BY EXCLUSIVE\n                 OR-ING ITS ARGUMENT BY X'FFFFFF...'.\n\n             V.  TDUMP  FUNCTION  RETURNS THE CONTENTS OF MAIN MEMORY\n                 IN HEX.   THE  FIRST  ARGUMENT  SPECIFIES IN HEX THE\n                 THE STARTING POSITION OF CORE DUMP.  THE SECOND  AR-\n                 GUMENT SPECIFIES THE LENGTH OF CORE DUMP. IF  IT  IS\n                 OMITTED 4 BYTES OF MAIN MEMORY IS RETURNED. THE CORE\n                 FUNCTION TAKES ONLY ONE INTEGER ARGUMENT WHICH TELLS\n                 THE  START  ADDRESS  OF MAIN MEMORY, AND RETURNS THE\n                 CONTENTS OF 4 BYTES STARTING AT THAT LOCATION AS  AN\n                 INTEGER.\n\n             W.  XLATE FUNCTION TRANSLATES ITS FIRST  ARGUMENT  IN  A\n                 FASHION SPECIFIED BY THE SECOND AND THIRD ARGUMENTS.\n                 THE  CHARACTERS  SPECIFIED  IN  THE  SECOND ARGUMENT\n                 ARE TRANSLATED TO THE RESPECTIVE CHARACTERS  IN  THE\n                 THIRD ARGUMENT.  IF  THE  THIRD  ARGUMENT IS SHORTER\n                 THAN THE SECOND, THE CHARACTERS  SPECIFIED  IN   THE\n                 SECOND ONE WITH NO CORRESPONDING   TRANSLATIONS  ARE\n                 DELETED.\n\n             X.  THE EXPAND FUNCTION RETURNS ITS ARGUMENT EXPANDED BY\n                 INSERTING BLANKS BETWEEN EACH CHARACTER.\n\n             Y.  EXAMPLES:  SET VALUE W0 FIRST+5 *(DELTA+W5)\n                            SET VALUE S0 GROUP||'.'||USER||'.LIB'\n                            SET VAL S0 EXPAND('HELLO')\n                            SET VAL S5 XLATE('ABCDE','ABCD','XY')\n                            SET VAL S0 TDUMP('000010',4)\n\n         2.  SHOW VALUE <EXP>(S)\n\n             A.  PRINT VALUE(S) FOR EXP(S)\n\n             B.  MULTIPLE  EXPRESSIONS  ARE  ALWAYS  SEPARATED  BY  A\n                 BLANK.    STRING   EXPRESSIONS   ARE   ENCLOSED   IN\n                 APOSTROPHES.\n\n             C.  EXAMPLES:  SHOW VALUE W0+3,W4,S0||'ABC',N5-12\n                            SHOW VALUE DISPLAY('ABCD')\n\n     B.  READ COMMAND\n\n         1.  READ VALUE <VARIABLE>(S)\n             READ VALUE <VARIABLE>(S) PROMPT <STRING>\n\n             A.  PROMPT    FOR    VALUE(S)     OF     <SVARIABLE>(S),\n                 <NVARIABLE>(S)   OR   <WVARIABLE>(S).   UP  TO  FIVE\n                 VARIABLES MAY BE READ BY ONE READ VALUE COMMAND, AND\n                 THE VALUES ARE ENTERED AS <EXP>(S).\n\n             B.  STRINGS MUST BE ENTERED WITH QUOTES.  THE QUOTES ARE\n                 STRIPPED AND ANY PAIRS OF QUOTES WITHIN  THE  STRING\n                 WILL  BECOME  A SINGLE QUOTE.  ANY NEEDED CONVERSION\n                 OF  THE  <EXP>  TO  THE  TYPE  OF  THE  VARIABLE  IS\n                 PERFORMED AUTOMATICALLY.\n\n             C.  IF THE INPUT DOES NOT CONTAIN AS MANY EXPRESSIONS AS\n                 VARIABLES  GIVEN  IN  THE  COMMAND,  THE   REMAINING\n                 <SVARIABLE>(S)  ARE  SET  TO  NULL AND THE REMAINING\n                 <NVARIABLES>(S) OR <WVARIABLE>(S) ARE SET TO 0.\n\n             D.  IF  THE  PROMPT  OPTION IS USED THE STRING FOLLOWING\n                 THE KEYWORD PROMPT IS PROMPTED, OTHERWISE 'ENTER? '.\n\n             E.  EXAMPLES:  READ VALUE W0,W2,S0\n                            READ VALUE N8\n\n         2.  READ STRING <SVARIABLE>\n             READ STRING <SVARIABLE> PROMPT <STRING>\n\n             A.  PROMPT FOR VALUE OF SVARIABLE\n\n             B.  THE ENTIRE LINE ENTERED IS ASSIGNED TO  THE  STRING.\n                 QUOTES   BECOME  SIMPLY  ANOTHER  CHARACTER  IN  THE\n                 STRING.\n\n             C.  IF  THE  PROMPT  OPTION IS USED THE STRING FOLLOWING\n                 THE KEYWORD PROMPT IS PROMPTED, OTHERWISE 'ENTER? '.\n\n             D.  EXAMPLE:  READ STRING S1\n\n         3.  READ STRING <SVARIABLE> USING <LINENO> COLUMNS <COLUMN(S)>\n\n             A.  SET STRING VARIABLE TO SPECIFIED PART OF ACTIVE FILE\n                 LINE.\n\n             B.  THE USING AND COLUMNS OPTIONS ARE PROCESSED  IN  THE\n                 SAME  WAY AS THESE OPTIONS ARE IN THE CHANGE COMMAND\n                 EXCEPT THAT ONLY ONE LINE MAY BE SPECIFIED.\n\n             C.  EXAMPLES:  READ STRING S1 USING LAST\n                            READ STRING S3 USING 4 COLUMN 6\n                            READ STRING S0 USING * COLUMNS 1/15\n\n     C.  SET AND SHOW ESCAPE COMMANDS\n\n         1.  THE PRE-PROCESSOR DESCRIBED IN SECTION II BELOW  USES  A\n             CHARACTER CALLED THE ESCAPE CHARACTER IN ORDER TO SIGNAL\n             THAT  TEXT SUBSTITUTION SHOULD BE MADE IN A COMMAND LINE\n             BEFORE WYLBUR EXECUTES IT.  IF NO ESCAPE  CHARACTER  HAS\n             BEEN  SET,  THE  PRE-PROCESSOR  DOES NOT PROCESS COMMAND\n             LINES  BEFORE  EXECUTION.   THE  ESCAPE   CHARACTER   IS\n             INITIALLY  NULL SO THE PRE-PROCESSOR IS NEVER USED UNTIL\n             YOU SET AN ESCAPE CHARACTER.\n\n         2.  SET ESCAPE='<CHARACTER>'\n\n             A.  THE PRE-PROCESSOR WILL USE <CHARACTER> AS THE ESCAPE\n                 CHARACTER.   SETTING  THE  ESCAPE  CHARACTER  TO  ''\n                 (NULL) TURNS OFF THE  PRE-PROCESSOR.   NORMALLY  THE\n                 QUOTES  CAN  BE  OMITTED.   HOWEVER, SOME CHARACTERS\n                 SUCH AS (),;'\"= BLANK AND  THE  LOWER  CASE  LETTERS\n                 MUST  BE  TYPED  IN QUOTES IF THEY ARE TO BE USED AS\n                 THE ESCAPE CHARACTER.\n\n             B.  EXAMPLES: SET ESCAPE '%'\n                           SET ESCAPE %\n                           SET ESCAPE ''\n                           SET ESCAPE\n\n         3.  THE  CURRENT  VALUE  OF  THE  ESCAPE  CHARACTER  CAN  BE\n             DISPLAYED AT ANY TIME BY USING THE COMMAND SHOW ESCAPE.\n\n     D.  SET AND SHOW SKIP COMMANDS\n\n         1.  THE PRE-PROCESSOR ALSO USES A  SECOND  CHARACTER  CALLED\n             THE  SKIP  CHARACTER  IN  ORDER  TO  ALLOW  YOU TO ENTER\n             COMMAND LINES THAT WILL HAVE AN ESCAPE OR SKIP CHARACTER\n             IN IT AFTER THE  PRE-PROCESSOR  HAS  FINISHED  ANY  TEXT\n             SUBSTITUTION.    THE   CHARACTER   FOLLOWING   THE  SKIP\n             CHARACTER IN A  COMMAND  LINE  IS  ALWAYS  LEFT  IN  THE\n             COMMAND LINE BY THE PRE-PROCESSOR.  THE INITIAL VALUE OF\n             THE SKIP CHARACTER IS NULL.\n\n         2.  SET SKIP='<CHARACTER>'\n\n             A.  THE PRE-PROCESSOR WILL USE <CHARACTER> AS  THE  SKIP\n                 CHARACTER.   IF  THE  ESCAPE  CHARACTER IS NULL, THE\n                 SKIP CHARACTER IS IGNORED.  QUOTES  CAN  BE  OMITTED\n                 FOR  THE  SKIP  CHARACTER  JUST  AS  FOR  THE ESCAPE\n                 CHARACTER.\n\n             B.  EXAMPLES:  SET SKIP $\n                            SET SKIP\n\n         3.  THE CURRENT VALUE OF THE SKIP CHARACTER CAN BE DISPLAYED\n             AT ANY TIME BY USING THE COMMAND SHOW SKIP.\n\n     E.  SET AND SHOW RESCAN COMMANDS\n\n         1.  THE PRE-PROCESSOR CAN BE DIRECTED  TO  RESCAN  ANY  TEXT\n             THAT IT SUBSTITUTES.  THIS COULD LEAD TO INFINITE RESCAN\n             IF AN ERROR IS MADE.  THEREFORE, A RESCAN LIMIT HAS BEEN\n             DEFINED  TO FORCE A STOP SO THAT INFINITE RESCANS CANNOT\n             OCCUR.  THE RESCAN COUNT IS INITIALLY SET TO 5.\n\n         2.  RESCANS OCCUR ONLY WHEN  A  PAIR  OF  ESCAPE  CHARACTERS\n             PREVENTS   THE   SCAN   POINTER  FROM  MOVING  OVER  THE\n             SUBSTITUTED VALUE.  THE RESCAN IS BEGUN AT THE START  OF\n             THE  SUBSTITUTED TEXT, NOT AT THE START OF THE LINE (SEE\n             II.A.1 BELOW).\n\n         3.  SET RESCAN=<INTEGER>\n\n             A.  THIS SETS THE NUMBER OF RESCAN SUBSTITUTIONS ALLOWED\n                 BEFORE THE PRE-PROCESSOR TERMINATES THE SCAN.\n\n             B.  EXAMPLE:  SET RESCAN 10\n\n         4.  THE CURRENT RESCAN LIMIT CAN BE DISPLAYED AT ANY TIME BY\n             USING THE COMMAND SHOW RESCAN.\n\n II. ADDITIONS\n\n     A.  PRE-PROCESSOR\n\n         1.  THE PRE-PROCESSOR SCANS ALL WYLBUR COMMANDS, LOOKING FOR\n             EITHER (OR  BOTH)  OF  TWO  SIGNIFICANT  USER-CONTROLLED\n             CHARACTERS, THE ESCAPE CHARACTER AND THE SKIP CHARACTER.\n             IF  NEITHER  OF  THESE  TWO CHARACTERS IS PRESENT IN THE\n             TEXT GIVEN TO THE  PRE-PROCESSOR,  NO  CHANGE  IS  MADE;\n             OTHERWISE, THERE ARE FIVE CASES (DESCRIBED IN THE FORMAT\n             <TEXT  INTO  THE  PRE-PROCESSOR>  ->  <TEXT  OUT  OF THE\n             PRE-PROCESSOR>, WHERE '%' IS ASSUMED TO  BE  THE  ESCAPE\n             CHARACTER,  '$'  IS ASSUMED TO BE THE SKIP CHARACTER AND\n             '|' DENOTES THE SCAN POINTER):\n\n             A.  |%<VARIABLE><TEXT> -> <VALUE>|<TEXT>\n\n             B.  |%(<EXP>)<TEXT> -> <VALUE>|<TEXT>\n\n             C.  |%%<VARIABLE><TEXT> -> |<VALUE><TEXT>\n\n             D.  |%%(<EXP>)<TEXT> -> |<VALUE><TEXT>\n\n             E.  |$<CHARACTER><TEXT> -> <CHARACTER>|<TEXT>\n\n         2.  ANY SUBSTITUTIONS OR CHANGES TO A COMMAND ARE MADE  EACH\n             TIME  THE COMMAND IS EXECUTED.  IF THE COMMAND CAME FROM\n             A FILE, THE FILE IS NOT CHANGED;  ONLY  A  COPY  OF  THE\n             COMMAND IS CHANGED AND THEN EXECUTED.\n\n         3.  ALL SUBSTITUTIONS ARE COMPLETED BEFORE  THE  COMMAND  IS\n             EXECUTED.    NO  SUBSTITUTIONS  ARE  MADE  OR  EVALUATED\n             DYNAMICALLY AS THE COMMAND IS EXECUTED.\n\n         4.  THE  TERSE/VERBOSE  MODES  OF  TYPED  INPUT   AND   EXEC\n             PROCESSING  CONTROL WHETHER THE CHANGED COMMAND IS TYPED\n             BEFORE EXECUTION.  IF THE MODE IS TERSE FOR  THE  SOURCE\n             OF THE COMMAND, THE CHANGED COMMAND IS NOT TYPED.  IF IT\n             IS VERBOSE, THE CHANGED COMMAND IS TYPED.\n\n         5.  THERE IS NO OVERHEAD BEFORE  COMMAND  EXECUTION  IF  THE\n             ESCAPE  CHARACTER  IS  NULL.   IF  THERE  IS  AN  ESCAPE\n             CHARACTER,  A  TRANSLATE AND TEST IS DONE ON THE COMMAND\n             LINE TO LOCATE AND PROCESS  ANY  ESCAPE  CHARACTERS  AND\n             SKIP  CHARACTERS.  IF THE TEXT AFTER AN ESCAPE CHARACTER\n             IS NOT A  PREPROCESSOR  VARIABLE  OR  AN  EXPRESSION  IN\n             PARENTHESES,  THERE WILL BE NO SUBSTITUTION AND THE TEXT\n             (INCLUDING THE ESCAPE CHARACTER) WILL NOT BE CHANGED.\n\n     B.  IF COMMAND\n\n         1.  SYNTAX:  IF ( <EXP> <RELOP> <EXP> ) <COMMAND>\n\n         2.  THE RELATIONAL OPERATORS (<RELOP>) ALLOWED ARE  EQ,  NE,\n             LT,  LE, GT, AND GE WHICH CORRESPOND TO TESTS FOR EQUAL,\n             NOT EQUAL, LESS THAN, LESS THAN OR EQUAL, GREATER  THAN,\n             AND GREATER THAN OR EQUAL.\n\n         3.  THE IF COMMAND EVALUATES THE  RELATIONAL  EXPRESSION  IN\n             PARENTHESES.   IF  THE  RESULT  IS  TRUE,  THE <COMMAND>\n             FOLLOWING THE PARENTHESES IS EXECUTED.  IF THE RESULT IS\n             FALSE, THE <COMMAND> IS SKIPPED WITHOUT INSPECTION.\n\n         4.  IF CURRENT, NEXT, AND/OR PREVIOUS ARE  USED  IN  THE  IF\n             EXPRESSIONS,  NO  EXEC  BREAK WILL OCCUR IF THEY ARE NOT\n             SET OR DO NOT EXIST.  INSTEAD, THEY WILL  BE  GIVEN  THE\n             VALUE  -1.000 TO ALLOW YOU TO TEST WHETHER THEY EXIST OR\n             NOT.\n\n         5.  IF  THE  <EXP>S ARE BOTH LINE NUMBERS OR BOTH  INTEGERS,\n             THE VALUES ARE COMPARED ALGEBRAICALLY.  IF ONE IS A LINE\n             NUMBER  AND  ONE IS AN INTEGER, THE INTEGER IS CONVERTED\n             TO  A  LINE  NUMBER  AND   THE   VALUES   ARE   COMPARED\n             ALGEBRAICALLY.    OTHERWISE,   A   LOGICAL   COMPARE  IS\n             PERFORMED  AFTER  CONVERTING BOTH <EXP>S TO  STRINGS  OF\n             THE  SAME  LENGTH  AND/OR BY ADDING BLANKS TO THE END OF\n             THE SHORTER STRING.\n\n         6.  EXAMPLES:  IF (W0 LT 0) COPY 'X' IN 1/20 TO 3000\n                        IF (W1 EQ LAST-5) EXEC 35\n\n III.SAMPLE SESSION SHOWING USE OF ESCAPE CHARACTER AND ARITHMETIC\n\n     ? SHOW ESCAPE\n     NO ESCAPE CHAR\n     ? SET VALUE S0 'TSOWK1'\n     ? SHOW VALUE S0\n     'TSOWK1'\n     ? SHOW SPACE ON &S0\n     &S0   : INVALID VOLUME.\n     ? SET ESCAPE &\n     ? SHOW SPACE ON &S0\n     TSOWK1\n     1193 TRKS, 143 EXTENTS\n     ? SHOW ESCAPE\n     & - ESCAPE CHAR\n     ? SET VERBOSE\n     COMMAND? SHOW SPACE ON &S0\n     SHOW SPACE ON TSOWK1\n     TSOWK1\n     1193 TRKS, 143 EXTENTS\n     COMMAND? SET ESCAPE\n     COMMAND? SHOW SPACE ON &S0\n     &S0   : INVALID VOLUME\n     COMMAND? SHOW ESCAPE\n     NO ESCAPE CHAR\n     COMMAND? SHOW VALUE 10/3 10./3 NCONVERT(10./3)\n     3 3.333 3\n     COMMAND? SHOW VALUE 1 * 1, .01 * .01, 1/2, 1./2\n     1 0.000 0 0.500\n\n IV. EXEC FILE EXAMPLES\n\n     A.  EXEC FILE FOR CHANGING STRINGS OF CHARACTERS\n\n         3  COMMENT CHANGE STRING S1 TO S2 IN LINE W0\n         4  SET EXEC VERBOSE LOG; THIS LETS YOU SEE WHAT'S HAPPENING\n         5  SET ESCAPE ''; TURN OFF ESCAPE CHARACTER\n         6  READ VALUE S1,S2,W0\n         7  IF (W0 EQ 0) EXEC 6 PAUSE\n         8  SET ESCAPE %; TURN ESCAPE CHARACTER ON TO SUBSTITUTE\n         9  CH '%S1' TO '%S2' IN %W0\n        10  EXEC 5\n\n     B.  EXEC FILE FOR FINDING A COLUMN\n\n         1  SET EXEC NOLOG TERSE\n         4  COMMENT FIND COLUMNS OF A STRING IN A SPECIFIED LINE\n         5  COMMENT WHERE S0 IS THE STRING, W0 THE LINE\n         6  SET ESCAPE; TURN OFF ESCAPE CHAR.\n         7  READ VALUE S0,W0\n         8  IF (S0 EQ '') EXEC CLEAR; STOP IF NOTHING ENTERED\n         9  SET ESCAPE %; SET THE ESCAPE CHAR TO DO SUBSTITUTIONS\n        10  POINT %W0 NOLIST; SEE IF LINE W0 EXISTS\n        11  IF (* LT 0) EXEC 19; NO LINE IF * WAS NOT SET\n        12  READ STRING S1 USING *\n        13  SET VALUE W1 INDEX(S1,S0)\n        14  IF (W1 EQ 0) EXEC *+3\n        15  SHO VALUE W1 W1+SIZE(S0)-1\n        16  EXEC 6\n        17  COMMENT '%S0' NOT IN LINE %W0\n        18  EXEC 6\n        19  COMMENT LINE %W0 NOT IN FILE\n        20  EXEC 6\n\n     C.  EXEC FILE FOR PREPARING TO ASSEMBLE A FILE\n\n         1  SET EXEC NOLOG TERSE\n         2  ; THIS EXEC FILE WILL REPLACE LABELS IN AN EXEC FILE\n         3  ; WITH THE APPROPRIATE LINE NUMBER. LABELS MUST BE\n         4  ; OF THE FORM LABELNN WHERE NN IS A 2-CHARACTER FIELD\n         5  ;\n         8  IF(LAST NE 0)EXEC 12; BRANCH IF FILE TO ASSEMBLE\n         9  COMMENT ** ENTER USE FOR ACTIVE FILE **\n        10  READ\n        11  EXEC 8; GO MAKE SURE FILE WAS ENTERED\n        12  SET VALUE W0 0\n        13  COMMENT ** BEGIN ASSEMBLY **\n        14  COMMENT\n        15  SET ESCAPE &\n        16  SET LENGTH 132\n        17  POINT 'LABEL' 1/5 (1) IN &W0/LAST NOL; FIND NEXT LABEL\n        18  IF(* LT 0)EXEC 33; CHECK FOR END OF LABELS\n        19  READ STRING S0 USING *;PUT THE LINE IN A STRING VARIABLE\n        20  SET VALUE W0 *;SAVE CURRENT LINE NUMBER\n        21  IF(SIZE(S0) LT 7)EXEC 31;CHECK FOR FUNNY LINE\n        22  SET VALUE S1 SUBSTR(S0,1,7);PICK OFF LABEL FIELD\n        23  CH 1/7 TO '' IN &W0 NOLIST; DELETE LABEL FIELD ON LINE\n        24  CH ' '1 TO '' IN &W0 NOL; ALSO DELETE BLANK AFTER LABEL\n        25  POINT '&S1' 1/7 (1) IN &W0/LAST NOL; SEE IF DUP LABEL\n        26  IF(* GT 0)COMMENT &S1 IS DUPLICATELY DEFINED\n        27  CH '&S1' TO '&W0' IN ALL NOL; REPLACE LABEL WITH LINENO\n        28  IF(* LT 0)COMMENT &S1 IN LINE &W0 IS UNREFERENCED\n        29  IF(* GE 0)COMMENT REPLACE &S1 WITH LINE NO. &W0\n        30  EXEC 17;GO FIND NEXT LABEL\n        31  SET VALUE W0 NEXT;SKIP PAST GARBAGE LINE\n        32  IF(W0 GE 0)EXEC 17\n        33  P 'LABEL' NOL; FIND UNDEFINED LABELS\n        34  IF( * LT 0)EXEC 38\n        35  COMMENT\n        36  COMMENT LINES BELOW REFER TO UNDEFINED LABELS\n        37  L 'LABEL';LIST MISSING LABELS\n        38  COMMENT\n        39  COMMENT ** END ASSEMBLY **\n        40  SET ESCAPE\n        41  EXEC CLEAR\n=EXINTRO\n)F\n INTRODUCTION TO EXEC FILES\n\n          IN ADDITION TO THE ACTIVE FILE, WYLBUR HAS A  FACILITY\n          CALLED THE EXEC (EXECUTE) FILE.  THE EXEC FILE DIFFERS\n          FROM THE ACTIVE FILE IN SEVERAL WAYS.  ITS FUNCTION IS\n          TO  PERFORM  A  SERIES  OF COMMANDS SEQUENTIALLY (IN A\n          USER-SPECIFIED ORDER).  USERS OFTEN FIND IT  NECESSARY\n          TO   PERFORM   THE  SAME  SERIES  OF  WYLBUR  COMMANDS\n          REPEATEDLY.  IF SUCH A SERIES OF COMMANDS IS COLLECTED\n          INTO AN  ACTIVE  FILE  AND  SAVED,  IT  IS  THEREAFTER\n          NECESSARY TO TYPE IN AN EXEC COMMAND ANY TIME YOU WISH\n          TO  EXECUTE  ALL  THOSE COMMANDS.  ANY WYLBUR FILE MAY\n          BECOME (\"BE MOVED INTO\") THE EXEC FILE, AS LONG AS  IT\n          DOES  NOT  EXCEED  3  WYLBUR PAGES (SEE THE SHOW PAGES\n          COMMAND).  IF AN ILLEGAL COMMAND IS  GIVEN  WITHIN  AN\n          EXEC   FILE,   THE  EXECUTION  OF  THE  FILE  WILL  BE\n          INTERRUPTED.\n\n CREATING AN EXEC FILE\n\n          TO CREATE AN EXEC FILE, ENTER COLLECT MODE  AND  ENTER\n          ONE COMMAND PER LINE.  THE COMMANDS WILL EVENTUALLY BE\n          EXECUTED  IN  THE ORDER IN WHICH THEY ARE ENCOUNTERED,\n          SO THE ORDER  IN  WHICH  THEY  ARE  COLLECTED  MAY  BE\n          SIGNIFICANT.  ANY VALID WYLBUR COMMAND MAY OCCUR IN AN\n          EXEC FILE, AND EACH LINE WILL BE TREATED AS A COMMAND.\n\n          FOR EXAMPLE, IF YOU USUALLY ENTER THE SAME  SERIES  OF\n          COMMANDS EACH TIME YOU SIGN ON TO WYLBUR (\"SET TERSE\",\n          \"SET  VOLUME,\"  \"SET  TABS,\" \"SET LENGTH\" ), IT MAY BE\n          MORE CONVENIENT TO CREATE A FILE CONSISTING  OF  THESE\n          COMMANDS AND SAVE IT IN YOUR LIBRARY:\n\n         COMMAND? COLLECT (CR)\n              1.  ? SET TERSE (CR)\n              2.  ? SET VOLUME TSOWK2 (CR)\n              3.  ? SET TABS 10 20 30 50 NOVERIFY (CR)\n              4.  ? SET LENGTH 132; IS THIS TOO LONG? (CR)\n              5.  ? *** (ATTN)\n        COMMAND? SAVE #SIGNON\n        MEMBER SIGNON SAVED IN @@@@@.LIB\n        COMMAND?\n\n\n\n          THUS SAVED, IT MAY BE ACCESSED AS NEEDED, WHENEVER YOU\n          WANT TO EXECUTE THOSE COMMANDS.\n\n          NOTE THAT IN LINE 4 OF THE PREVIOUS EXAMPLE, THERE  IS\n          A  SEMI-COLON  FOLLOWED  BY  THE  WORDS  \"IS  THIS TOO\n          LONG?\".  A SEMI-COLON STOPS  THE  SCAN  OF  A  COMMAND\n          LINE; ANYTHING FOLLOWING IT IS A COMMENT.\n\n          WITH THIS BASIC EXAMPLE, YOU WILL  BE  ABLE  TO  BEGIN\n          USING  EXEC FILES AS WELL AS ATTEMPT TO UNDERSTAND THE\n          MORE SOPHISTICATED EXAMPLES OF EXEC  FILES  INTRODUCED\n          LATER.\n\n=EXADVANC\n          THIS IS A SAMPLE OF A MORE ADVANCED EXEC FILE THAN THE\n          SAMPLE SHOWN IN THE ENTRY \"EXINTRO\".  BEFORE TRYING OR\n          DURING THE PROCESS OF UNDERSTANDING THIS EXAMPLE,  YOU\n          SHOULD  BE  FAMILIAR  WITH THE CONTENTS OF THE ENTRIES\n          \"PREPROC1 AND PREPROC2\".\n\n          THIS SAMPLE IS A WORKABLE EXEC FILE  USED  TO  JUSTIFY\n          PARAGRAPHS  OF  DATA.  TO USE THIS EXEC FILE YOU WOULD\n          GO LIST YOUR DATA AND MAKE NOTE OF  THE  STARTING  AND\n          ENDING  LINE  NUMBERS OF EACH PARAGRAPH.  WYLBUR WOULD\n          THEN PROMPT WITH \"ENTER FIRST # \", \"ENTER  LAST  #  \",\n          AND  \"ENTER  INDENT \" AND THEN LOOP BACK TO THE PROMPT\n          \"ENTER FIRST # \".  NOTE......THE ONLY WAY  (AS  CODED)\n          TO GET OUT OF THE LOOP IS TO HIT BREAK OR ATTN.\n\n          THE SAMPLE EXEC FILE  IS  LISTED,  THEN  EACH  OF  THE\n          COMMANDS ARE EXPLAINED ONE BY ONE.\n\n        1.  SET EXEC NOLOG\n        2.  SET EXEC TERSE\n        3.  READ STRING S9 PROMPT 'ENTER FIRST # '\n        4.  IF (0 NE VERIFY (S9,'0123456789.')) EXEC 3\n        5.  SET VAL W1=S9 ; COULD ALSO BE @ INSTEAD OF SET VAL\n        6.  READ STRING S9 PROMPT 'ENTER LAST # '\n        7.  IF (0 NE VERIFY (S9,'0123456789.')) EXEC 6\n        8.  SET VAL W2=S9 ; COULD ALSO BE @ INSTEAD OF SET VAL\n        9.  READ STRING S9 PROMPT 'ENTER INDENT '\n        10. IF (0 NE VERIFY (S9,'0123456789')) EXEC 9\n        11. SET VAL N1=S9 ; COULD ALSO BE @ INSTEAD OF SET VAL\n        12. SET ESC %\n        13. JUS %W1/%W2 INDENT %N1 EVEN LEN 64\n        14. EXEC 3\n\n          LINE 1 TELLS  WYLBUR  THAT  HE  IS  NOT  TO  LIST  THE\n          COMMANDS  AS  THEY  ARE EXECUTED.  LINE 2 TELLS WYLBUR\n          THAT LINES  THAT  GET  EXPANDED  BY  THE  PREPROCESSOR\n          (ENTRY \"PREPROC1\") NEED NOT BE LISTED AT THE TERMINAL.\n          LINE  3  TELLS WYLBUR TO PROMPT FOR A VALUE THAT IS TO\n          BE ASSIGNED TO GLOBAL VARIABLE S9.  LINE 4 IS A SAMPLE\n          OF THE \"IF\"  COMMAND  THAT  VERIFIES  THAT  THE  VALUE\n          ASSIGNED  TO  S9  IS  VALID NUMERIC LINE NUMBER AND IF\n          THIS IS NOT TRUE, EXECUTION IS TO TAKE PLACE  STARTING\n          WITH  LINE  3 AGAIN.  IF TRUE, EXECUTION WILL CONTINUE\n          WITH LINE 5.  SINCE THE VALUE SPECIFIED  IN  REPLY  TO\n          THE  PROMPT  \"ENTER  FIRST # \" AND ASSIGNED TO S9 IS A\n          VALID WYLBUR LINE NUMBER, WE CAN ASSIGN THAT VALUE  TO\n          THE  GLOBAL  WYLBUR LINE NUMBER VARIABLE W1 AND RE-USE\n          S9.  THIS IS THE PURPOSE OF LINE 5.  NOTE THE  COMMENT\n          (FOLLOWING  THE \";\") ON LINES 5, 8, 11.  \"SET VAL\" MAY\n          BE SHORTENED TO \"@\".  LINES 6-8 ARE A REPEAT OF  LINES\n          3-5  FOR  THE  ENDING LINE NUMBER WITH THE VALUE BEING\n          ASSIGNED TO W2.  LINE 9 AGAIN  PROMPTS  FOR  A  NUMBER\n          EXCEPT  THIS  TIME THE NUMBER IS AN N VALUE ASSUMED TO\n          BE AN INTEGER.  LINE 10 VERIFIES THAT THE NUMBER IS  A\n          VALID  INTEGER.  NOTE THE DIFFERENCE BETWEEN THIS \"IF\"\n          COMMAND AND THE \"IF\" COMMANDS IN LINES 3 AND  6.   THE\n          DIFFERENCE   IS   THE  PERIOD  IN  THE  QUOTED  STRING\n          FOLLOWING  THE  WORD  \"VERIFY   (S9,\".    THIS   TAKES\n          ADVANTAGE  OF  THE PREPROCESSOR RULE THAT \"MIXED TYPES\n          OF OPERANDS (LINE NUMBERS AND INTEGERS) ARE  CONVERTED\n          BEFORE   THE  COMPARISON  TAKES  PLACE.   THE  INTEGER\n          OPERAND IS CONVERTED TO A  LINE  NUMBER\".   THIS  RULE\n          APPLIES  IN THE FIRST TWO \"IF\" COMMANDS BUT NOT IN THE\n          LAST \"IF\" BECAUSE BOTH OF  THE  OPERANDS  ARE  OF  THE\n          INTEGER FORMAT ALREADY.  THE VALUE ENTERED, IF A VALID\n          INTEGER, IS ASSIGNED TO THE GLOBAL INTEGER VARIABLE N1\n          IN  LINE 11.  LINE 12 SETS THE ESCAPE CHARACTER TO \"%\"\n          TO INFORM WYLBUR THAT PREPROCESSING IS  NEEDED.   LINE\n          13  ISSUES  THE  COMMAND \"JUSTIFY\" .  WHEN WYLBUR SEES\n          THE  ESCAPE  CHARACTERS  PRESENT  IN  THE   LINE,   HE\n          AUTOMATICALLY   CONVERTS   THE  \"%W1,  %W2,  AND  %N1\"\n          VARIABLES TO THE VALUES ASSIGNED BEFORE EXECUTING  THE\n          COMMAND.   AFTER  CONVERSION  THE  COMMAND  (IF  W1=1,\n          W2=10,  N1=5)  WOULD  READ \"JUS 1/10 INDENT 5 EVEN LEN\n          64\".  LINE 14 IS A  SAMPLE  OF  AN  EXEC  FILE  BRANCH\n          INSTRUCTION  AND WILL CAUSE EXECUTION TO CONTINUE WITH\n          LINE 3.\n\n          NOTE.......A MORE EFFICIENT WAY TO DO THIS  EXEC  FILE\n          WOULD  HAVE  BEEN  TO HAVE LINE 12 CODED AFTER LINE 2.\n          THIS WOULD PREVENT WYLBUR FROM HAVING TO EXECUTE  THAT\n          COMMAND  EVERY  TIME  HE LOOPED THROUGH THE EXEC FILE.\n          THIS WAS DONE TO SHOW AGAIN THE FACT THAT THE COMMANDS\n          ARE EXECUTED EXACTLY AS YOU ENTER THEM.   IT  PAYS  TO\n          PLAN BEFORE WRITING EXEC FILES AS THEY ARE, IN EFFECT,\n          MINI-PROGRAMS.\n\n./ ADD NAME=WYLBUR\n)S SUBCOMMANDS -\n          ?  (SHOW VAR.), @ (SET VAR.),  ALIGN,  CATLG,  CENTER,\n          CHANGE,   CLEAR,   COLLECT,  COMMENT,  COMPARE,  COPY,\n          DELETE, DISPLAY,  EDIT,  EXEC,  IF,  INSERT,  JUSTIFY,\n          LIST,  LOAD, LOGOUT, MODIFY, MOVE, NUMBER, POINT, POP,\n          PROFILE, PUT, READ, RECATLG, RENAME, REPLACE, RESTORE,\n          RUN, SAVE, SCRATCH, SEND, SET, SHOW,  SIGNOFF,  STACK,\n          STAX, SUSPEND, TIME, TO, UNCATLG, USE\n\n          IN ADDITION, SOME TSO COMMANDS ARE AVAILABLE  FOR  USE\n          UNDER WYLBUR.  THOSE THAT ARE PRESENTLY NOT VALID WILL\n          NOT  WORK  PROPERLY, PLEASE INFORM SYSTEMS PROGRAMMING\n          AT EXT.  383 OR 384 IF THERE ARE ANY PROBLEMS.\n\n          AT VARIOUS POINTS IN THE HELP ENTRIES  THERE  WILL  BE\n          REFERENCES  TO  GENERAL TYPE ENTRIES.....SUCH AS HINTS\n          ON EDITING AN ACTIVE FILE....ENTER \"HELP EDITING.\"\n)F FUNCTION -\n          WYLBUR IS A COMPUTER SYSTEM USED AS A TEXT EDITOR  AND\n          REMOTE  JOB  ENTRY FACILITY.  IT IS VERY FAST AND VERY\n          POWERFUL.  WYLBUR MAY BE USED ON ANY TYPE OF TERMINAL.\n\n)X SYNTAX -\n          WYLBUR HAS TWO MODES OF OPERATION, CALLED COLLECT MODE\n          AND COMMAND MODE.\n\n         COLLECT MODE - USED FOR ACCUMULATING LINES OF TEXT FOR\n                    A NEW FILE OR ADDING LINES OF  TEXT  TO  AN\n                    EXISTING FILE.\n\n         COMMAND MODE - USED TO PERFORM ANY OTHER TASKS SUCH AS\n                    EDITING AN EXISTING FILE, OR  SUBMITTING  A\n                    JOB TO THE COMPUTER.\n\n          YOU ARE IN COMMAND MODE WHENEVER YOU ARE RESPONDING TO\n          A COMMAND PROMPT (COMMAND  ?),  AND  IN  COLLECT  MODE\n          WHENEVER  YOU  ARE  RESPONDING TO A LINE NUMBER PROMPT\n          (1.  ?).\n\n         UPPER AND LOWER CASE\n          YOU MAY USE ALL UPPER OR LOWER CASE  CHARACTERS  OR  A\n          COMBINATION.   WYLBUR ALWAYS RESPONDS AND PROMPTS WITH\n          UPPER CASE.  CASE IS OF EXTREME  IMPORTANCE  WHILE  IN\n          COLLECT   MODE.    IF   AN  ERROR  IS  MADE  WHILE  IN\n          COLLECT....THE CASE OF TEXT MAY  BE  CHANGED  VIA  THE\n          UPPER/LOWER OPERANDS OF THE CHANGE COMMAND.\n\n         SEPARATORS\n         BLANK, COMMA, EQUAL SIGN ( ,=)\n          WYLBUR WILL RECOGNIZE A BLANK, COMMA, AND  EQUAL  SIGN\n          AS  EQUIVALENT SEPARATORS IN ANY COMMAND.  THESE THREE\n          LIST COMMANDS ARE EQUIVALENT:\n\n                   COMMAND?  LIST 2,3,4,5\n                   COMMAND?  LIST 2 3 4 5\n                   COMMAND?  LIST 2=3=4=5\n\n         SEMI-COLON (;)\n          A SEMI-COLON STOPS THE SCAN OF A  COMMAND  LINE.   ALL\n          FOLLOWING  TEXT IS CONSIDERED A COMMENT.  IF A COMMAND\n          LINE BEGINS WITH A SEMI-COLON, THE  WHOLE  LINE  IS  A\n          COMMENT.\n\n                   COMMAND?  LIST 2/5 ; EXAMPLE OF LIST COMMAND\n\n         CHANGING MODES\n          TO CHANGE  FROM  COMMAND  MODE  TO  COLLECT  MODE,  OR\n          VICE-VERSA,  PRESS THE ATTN KEY AS THE FIRST CHARACTER\n          IN A LINE.\n\n          THERE IS ANOTHER WAY TO CHANGE FROM COMMAND TO COLLECT\n          MODE.  TYPE THE COMMAND COLLECT:\n\n                   COMMAND?  COLLECT (CR)\n                     1.    ?\n\n          TO CHANGE FROM COLLECT TO COMMAND MODE, PRESS THE ATTN\n          KEY.\n\n         ATTENTION (OR ATTN)\n           THIS KEY HAS TWO MAIN FUNCTIONS:\n             1. TO CHANGE FROM COLLECT TO COMMAND MODE.\n             2. TO ERASE UNWANTED COMMAND LINE.\n             3. TO ERASE AN UNWANTED LINE OF INPUT\n                WHILE IN COLLECT MODE.  EXAMPLE:\n\n                   COMMAND?  ***(ATTN)\n                      1.  ? COLLECT MODE(CR)\n                      2.  ?  GARBAGE LINE....***(ATTN)\n\n           WHEN LISTED, THERE WILL BE NO LINE 2.\n\n          WYLBUR HELP ENTRIES DEPART FROM THE IBM  STANDARDS  IN\n          THE FOLLOWING RESPECTS:\n\n         1. MANDANTORY OPERANDS ARE ENCLOSED IN \"LESS THAN\" AND\n            \"GREATER THAN\" SIGNS:\n                                    <RANGE>\n\n          2.  OPTIONAL OPERANDS ARE ENCLOSED IN PARENTHESIS  AND\n          HAVE ALTERNATE FORMS OF A GIVEN OPERAND LISTED SIDE BY\n          SIDE, SEPERATED BY A SLASH (/):\n                             (INDENT=/IND=)\n=ALIGN=ALIG=ALI=AL=A\n)F FUNCTION -\n\n          THE WYLBUR ALIGN COMMAND REARRANGES  THE  CONTENTS  OF\n          THE LINES IN THE RANGE SPECIFIED IN THE ACTIVE FILE SO\n          THAT  EACH LINE CONTAINS AS MANY WORDS AS POSSIBLE BUT\n          NOT MORE THAT \"LENGTH\" CHARACTERS.  SPLITS IN  A  LINE\n          ARE MADE ONLY AT BLANKS.  AFTER THE LINES ARE ALIGNED,\n          WYLBUR RENUMBERS THEM ONE BLANK IS INSERTED AFTER EACH\n          WORD  UNLESS IT ENDS WITH A PERIOD, EXCLAMATION POINT,\n          OR QUESTION MARK, WHICH FORCES TWO BLANKS.\n\n)X SYNTAX -\n\n         ALIGN <RANGE> (LENGTH=N) (MARKER=C) (NUMBER)\n               (INDENT=I(+ OR - J)) (EVEN) (SPACE)\n\n         REQUIRED - RANGE\n         DEFAULTS - LENGTH = GLOBAL LENGTH PARAMETER, INDENT=0\n         ALIAS    - ALIG, ALI, AL, A\n\n)O OPERANDS -\n\n))RANGE -\n         MUST BE SPECIFIED AS AN \"EXPLICIT RANGE\".\n\n))LENGTH=N -\n          IF LENGTH IS NOT SPECIFIED IN THE COMMAND, THE CURRENT\n          VALUE OF THE GLOBAL LENGTH  PARAMETER  IS  USED.   THE\n          MAXIMUM LENGTH PERMITTED IS 133 CHARACTERS.\n\n))MARKER=C -\n          THE MARKER OPTION MUST BE SPECIFIED IN THE COMMAND  IF\n          YOU  WANT  THIS  FEATURE.   WHEN WYLBUR ENCOUNTERS THE\n          MARKER CHARACTER OR A BLANK IN COLUMN ONE OF ANY  LINE\n          BEING  ALIGNED,  THAT  LINE  IS  NOT  ALIGNED  AND THE\n          ALIGNMENT PROCESS IS RESTARTED AFTER THAT LINE.\n\n))NUMBER -\n          IF NUMBER IS SPECIFIED, WYLBUR  RENUMBERS  THE  ENTIRE\n          FILE AFTER THE ALIGNMENT PROCESS.\n\n))INDENT=I (+ OR - J) -\n          INDENT=I WILL INDENT EACH ALIGNED LINE BY \"I\"  SPACES.\n          INDENT=\"I\"  (+ OR -) \"J\" WILL FURTHER INDENT PARAGRAPH\n          BEGINNINGS \"J\" SPACES.  IF INDENT  IS  NOT  SPECIFIED,\n          INDENT  0+0  IS  ASSUMED;  IF  \"J\"  IS  NOT SPECIFIED,\n          INDENT=\"I\"+0 IS ASSUMED.  UNLESS \"EVEN\" IS  SPECIFIED,\n          ONLY  THOSE  LINES  BEGINNING  IN COLUMN I+J+1 WILL BE\n          ALIGNED.\n\n         HANGING INDENTATIONS\n\n          THE SECOND NUMBER FOLLOWING THE KEYWORD INDENT MAY  BE\n          NEGATIVE, IN WHICH CASE A HANGING INDENTATION RESULTS.\n\n         COMMAND?  ALIGN 1/3 INDENT 10-4 EVEN LENGTH 30 (CR)\n\n          THIS COMMAND ALIGNS LINES 1 THROUGH  3  INDENTING  THE\n          FIRST  LINE  OF EACH PARAGRAPH (10-4=6) SPACES AND ALL\n          OTHERS  10  SPACES,  REGARDLESS  OF   THEIR   PREVIOUS\n          INDENTATION.\n\n))EVEN -\n          A NEW PARAGRAPH IS ASSUMED TO START ONLY AFTER A BLANK\n          LINE, AND ALL LINES IN THE <RANGE> ARE ALIGNED ON  THE\n          LEFT  MARGIN  TO  THE  COLUMNS SPECIFIED IN THE INDENT\n          PARAMETER REGARDLESS OF THEIR PREVIOUS INDENTATION.\n\n))SPACE -\n          IF SPACE IS SPECIFIED, THE ALIGNMENT PROCESS  IS  DONE\n          AFTER  WYLBUR RESPACES THE LINES SO THAT THERE IS ONLY\n          ONE SPACE BETWEEN WORDS AND TWO SPACES AFTER A PERIOD,\n          EXCLAMATION POINT, OR QUESTION MARK.  THIS IS THE  WAY\n          OF  TELLING  WYLBUR  THAT HE HAS PREVIOUSLY ALIGNED OR\n          JUSTIFIED THE DATA.  IF WORKING WITH THIS TYPE OF DATA\n          AND THIS OPERAND IS NOT SPECIFIED, BIZARRE RESULTS MAY\n          OCCUR.\n\n=CATLG=CATL=CAT\n)F FUNCTION -\n\n          THE  WYLBUR  CATLG  COMMAND   IS   USED   TO   CATALOG\n          \"UNCATALOGED\"  DATA  SETS  ON ANY VOLUME THAT IS VALID\n          FOR YOUR USE.\n\n)X SYNTAX -\n\n         CATLG <DSNAME> <ON VOLUME/CATLG>\n\n         REQUIRED - DSNAME AND ON VOLUME\n         DEFAULTS - VOLUME=CATLG (AND THERE IS NO SUCH DEVICE)\n         ALIAS    - CATL, CAT\n\n)O OPERANDS -\n))DSNAME -\n         ANY VALID DATA SET NAME.  SEE THE ENTRY \"DSNAMES\".\n\n))ON VOLUME/CATLG -\n          THIS IS NOT (IN  THE  STRICT  SENSE  OF  THE  WORD)  A\n          REQUIRED  OPERAND.  HOWEVER, IF A VALID VOLUME NAME IS\n          NOT GIVEN, THE DEFAULT  VOLUME  OF  \"CATLG\"  IS  USED.\n          THERE  IS  NO  SUCH  VALID  VOLUME  NAME AND THIS WILL\n          RESULT IN A CATALOG ERROR.\n\n=CENTER=CENTE=CENT=CEN=CE\n)F FUNCTION -\n          THE WYLBUR CENTER COMMAND MAY BE USED TO  CENTER  TEXT\n          ON  A  LINE.   THE FIRST AND LAST NON-BLANK CHARACTERS\n          WILL BE SYMMETRICALLY PLACED  AT  THE  CENTER  OF  THE\n          LINE.    BLANKS  IMBEDDED  WITHIN  THE  LINE  ARE  NOT\n          CHANGED.\n\n)X SYNTAX -\n\n         CENTER <RANGE> (INDENT=I, LENGTH=J)\n                        (INDENT I, LENGTH J)\n                           (IND=I, LEN=J)\n                            (IND I, LEN J)\n\n   REQUIRED - RANGE\n   DEFAULTS - INDENT=0, LENGTH=GLOBAL LENGTH PARAMETER\n   ALIAS    - CENTE, CENT, CEN, CE\n\n)O OPERANDS -\n\n))RANGE -\n          THE LINE/LINES TO BE CENTERED.  CAN BE SINGLE LINE  #,\n          START  #/ END #, OR THE LINE POINTED TO BY THE CURRENT\n          LINE POINTER  (TYPED  AS  '*'  AND  SET  AT  ENTRY  TO\n          WYLBUR).  REQUIRED OPERAND.\n\n         EXAMPLE:  COMMAND?  CEN * (CR)\n                   COMMAND?  CEN 3 (CR)\n                   COMMAND?  CEN F/L (CR)\n                   COMMAND?  CEN 3/10 (CR)\n\n))INDENT=I OR IND I -\n          USED TO CENTER INDENTED MATERIAL.  THE  MATERIAL  WILL\n          BE CENTERED BETWEEN THE SPECIFIED INDENTATION (DEFAULT\n          IND=0),AND THE LENGTH SPECIFIED.\n\n         EXAMPLE:  COMMAND?  CEN 3 IND 4 LEN 20 (CR)\n            OR     COMMAND?  CEN 3 IND=4 LEN 20 (CR)\n\n           THIS WOULD CENTER LINE 3 DATA BETWEEN COLUMNS 4 AND 20.\n\n          WHEN USING THE '=' SIGN FORM OF THIS KEYWORD, THE  '='\n          SIGN TAKES THE PLACE OF THE BLANK.\n\n\n))LENGTH OR LEN -\n          USED TO OVERRIDE THE GLOBAL LENGTH PARAMETER  THAT  IS\n          SET  WHEN  FIRST  SIGNING  ON  TO  WYLBUR.   THE VALUE\n          SPECIFIED THEN BECOMES THE LIMITING VALUE.\n\n         EXAMPLE:  COMMAND?  SHOW LEN (CR)\n                   72 - LENGTH\n                   COMMAND?  CEN 3 LEN 60 (CR)\n            OR     COMMAND?  CEN 3 LEN=60 (CR)\n\n          THIS WOULD CENTER ALL DATA ON LINE 3 BETWEEN COLUMNS 1\n          AND 60 RATHER THAN THE DEFAULT OF 1 AND 72.\n\n          WHEN USING THE '=' SIGN FORM OF THIS KEYWORD  THE  '='\n          SIGN TAKES THE PLACE OT THE BLANK.\n\n=CHANGE=CHANG=CHAN=CHA=CH\n)F FUNCTION -\n\n          NOTE......THIS WYLBUR HELP ENTRY SHOULD BE  USED  ONLY\n          IF  YOU  ARE FAMILIAR WITH THE CHANGE COMMAND.  IF YOU\n          ARE LEARNING, SEE THE  ENTRY  \"CHGLEARN\".   THIS  WILL\n          SHOW  YOU SAMPLES OF ALL OF THE VARIOUS FORMS AND IS A\n          BETTER  LEARNING  ENTRY  BECAUSE  IT  IS   EASIER   TO\n          UNDERSTAND.\n\n          THE WYLBUR CHANGE COMMAND IS THE SINGLE MOST  POWERFUL\n          COMMAND  IN  WYLBUR.   EVERY  CHANGE COMMAND HAS THREE\n          SECTIONS:   POSITION,  REPLACEMENT,  AND  RANGE.   THE\n          POSITION IDENTIFIES THE LOCATION WITHIN THE LINE WHICH\n          IS TO BE CHANGED.  THE RANGE SPECIFIES WHICH LINES ARE\n          TO BE CONSIDERED FOR CHANGING.  YOU MAY OMIT THE RANGE\n          SPECIFICATION AND THE DEFAULT RANGE  OF  ALL  WILL  BE\n          ASSUMED.   THE REPLACEMENT DESCRIBES WHAT CHANGE IS TO\n          BE MADE.  THE COMMAND SEARCHES THE LINES SPECIFIED  IN\n          THE  RANGE FOR INSTANCES OF THE POSITION TO BE CHANGED\n          AND, WHEN  IT  ENCOUNTERS  ONE,  MAKES  THE  INDICATED\n          REPLACEMENT.   AS  EACH LINE IS CHANGED, THE RESULTING\n          LINE IS LISTED UNLESS THIS FEATURE IS OVERRIDDEN.\n\n          THERE ARE THREE BASIC FORMS OF THE CHANGE COMMAND  AND\n          THEY ARE LISTED BELOW.\n\n         CHANGE (POSITION) TO (REPLACEMENT) IN (RANGE)\n         CHANGE (POSITION) IN (RANGE) TO (REPLACEMENT)\n         CHANGE (POSITION) IN (RANGE) USING (REPLACEMENT)\n\n)X SYNTAX -\n\n\n         CHANGE <STRING1> (I/J/K) (N) TO <STRING2> (IN <RANGE>)\n                (LIST OPTIONS) (LINE)\n\n         CHANGE (I/J/K) TO <STRING2> (IN <RANGE>) (LINE)\n                (LIST OPTIONS)\n\n         CHANGE (<STRING1>) (I/J/K) (IN <RANGE1>) (N) USING\n                <RANGE2> (COLUMNS=(M1/M2)) (REPEAT)\n                (LIST OPTIONS)\n\n         REQUIRED - VARIABLE (DEPENDS ON THE FORM USED)\n         DEFAULTS - LIST, NUMBERED\n         ALIAS    - CHANG, CHAN, CHA, CH\n\n)O OPERANDS -\n\n))STRING1 -\n          THIS IS THE SEARCH ARGUMENT FOR THE CHANGE COMMAND AND\n          SHOULD BE SPECIFIED WITHIN EITHER FORM OF QUOTES.\n\n\n))I/J/K -\n          THIS DEFINES THE COLUMNS IN WHICH TO  SEARCH  FOR  THE\n          STRING TO CHANGE.  \"I\" IS THE STARTING COLUMN.  \"J\" IS\n          THE ENDING COLUMN.  \"K\" IS THE FILL COLUMN WHICH TELLS\n          WYLBUR  NOT TO DISTURB ANY DATA IN COLUMNS PAST COLUMN\n          K.   DATA  WILL  NOT  BE  DISTURBED  EVEN  THOUGH  THE\n          REPLACEMENT STRING IS LONGER THAN THE SEARCH ARGUMENT.\n\n))N -\n          \"N\" IS USED TO SPECIFY WHAT OCCURENCE  OF  THE  SEARCH\n          ARGUMENT  WITHIN  A  LINE IS TO BE CHANGED.  (3) WOULD\n          TELL WYLBUR TO CHANGE THE THIRD OCCURENCE.\n\n))STRING2 -\n          THIS IS THE REPLACEMENT STRING AND TELLS  WYLBUR  WHAT\n          THE  OUTPUT IS TO CONTAIN AFTER THE SEARCH ARGUMENT IS\n          SATISFIED.  THIS OPERAND MAY TAKE THE FORM OF  \"N  M\".\n          THIS TELLS WYLBUR TO CHANGE THE SPECIFIED STRING TO AN\n          INTEGER  (N)  THAT  IS  INCREMENTED BY (M).  IF (M) IS\n          EQUAL TO 1 THIS PORTION OF THE OPERAND MAY BE OMITTED.\n          THIS OPERAND MAY ALSO CONTAIN THE WORD \"UPPER\" OR  THE\n          WORD  \"LOWER\"  AND TELLS WYLBUR THAT YOU WANT THE CASE\n          OF THE LETTERS CHANGED TO THE SPECIFIED FORM.   WYLBUR\n          WILL  NOT  CHANGE  THE FIRST CHARACTER OF A PARAGRAPH,\n          THE FIRST CHARACTER  OF  THE  NEXT  WORD  FOLLOWING  A\n          PERIOD,  EXCLAMATION  POINT, OR QUESTION MARK TO LOWER\n          CASE.\n\n))IN RANGE -\n          RESTRICTS THE SEARCH  TO  SPECIFIC  LINES  WITHIN  THE\n          ACTIVE  FILE.  MAY BE SPECIFIED AS \"IN \u00ac'A' 2 IN ALL\".\n          THIS WOULD TELL WYLBUR TO MAKE THE  SPECIFIED  CHANGES\n          IN  ALL  LINES  THAT  DID NOT CONTAIN \"A\" IN COLUMN 2.\n          NOTE.....THE WORD \"ALL\" MAY BE SUBSTITUTED AS 1/15, OR\n          SOME OTHER FORM OF LINE  RANGE,  BUT  MAY  NOT  BE  AN\n          ASSOCIATIVE RANGE.\n\n))LIST OPTIONS -\n          ANY OF THE VALID LIST  OPTIONS  (DESCRIBED  UNDER  THE\n          HELP  ENTRY FOR LIST) ARE VALID OPERANDS.  LIST NUM IS\n          THE DEFAULT.\n\n))LINE -\n          USED  IN  CONJUNCTION  WITH  THE   \"N   M\"   FORM   OF\n          SPECIFICATION   OF  \"STRING2\".   THIS  OPERAND  CAUSES\n          WYLBUR TO CHANGE  THE  \"STRING2\"  VALUE  ONLY  BETWEEN\n          LINES.  EXAMPLE:\n\n         1.   AAA\n         2.   AAA\n\n         COMMAND?  CH 'A' TO 1 1 IN ALL (CR)\n         1.   123\n         2.   456\n\n          YOU WILL NOTICE THAT THIS COMMAND DID NOT RESTRICT THE\n          INCREMENTING AND WYLBUR INCREMENTED BY ONE EVERY  TIME\n          HE FOUND A MATCH.  IF THE LINE OPERAND IS USED HE WILL\n          INCREMENT  ONLY  ON  THE FIRST OCCURENCE OF THE STRING\n          WITHIN THE LINE.  EXAMPLE:\n\n         1.   AAA\n         2.   AAA\n\n         COMMAND?  CH 'A' TO 1 1 IN ALL LINE (CR)\n         1.   111\n         2.   222\n\n))USING -\n          INDICATES TO WYLBUR THAT  YOU  ARE  DOING  THE  COLUMN\n          REPLACEMENT \"USING\" FORM OF THE CHANGE COMMAND.\n\n))RANGE2 -\n          INDICATES TO WYLBUR WHAT RANGE OF LINES HE IS  TO  USE\n          TO  GET  THE REPLACEMENT COLUMNS FROM DURING A \"USING\"\n          FORM  OF  THE  CHANGE  COMMAND.   NOTE.....THE   RANGE\n          SPECIFIED (REPLACEMENT RANGE) MAY BE ANY SINGLE SET OF\n          CONTIGUOUS LINES.  MULTIPLE SETS ARE NOT ALLOWED.\n\n))COLUMNS=M1/M2 -\n          RESTRICTS THE \"REPLACEMENT COLUMNS\" TO  THE  RANGE  OF\n          COLUMNS   SPECIFIED.    MAY   BE  USED  AS  M1/M2,  OR\n          \"COLUMNS=M1\" (WHICH TELLS WYLBUR TO  USE  ALL  COLUMNS\n          FROM THE VALUE OF M1 ON TO THE END OF ALL COLUMNS), OR\n          \"COLUMNS=/M2\"  (WHICH  TELLS  WYLBUR  TO USE COLUMNS 1\n          THRU THE VALUE SPECIFIED IN M2).\n\n))REPEAT -\n          THE CONTENTS OF THE LINES  IN  THE  REPLACEMENT  RANGE\n          (RANGE2)  ARE  USED  SUCCESSIVELY AS REPLACEMENTS.  IF\n          MORE CHANGES ARE TO BE MADE THAN THERE  ARE  LINES  IN\n          THE  REPLACEMENT  RANGE,  THE  REPEAT  OPTION  MAY  BE\n          SPECIFIED.   THIS CAUSES WYLBUR TO RECYCLE THROUGH THE\n          REPLACEMENT RANGE.\n\n=CLEAR=CLEA=CLE=CL=CLR\n)F FUNCTION -\n\n          THE WYLBUR CLEAR COMMAND IS USED TO ERASE THE  CURRENT\n          ACTIVE FILE OR THE CURRENT EXEC FILE.\n\n)X SYNTAX -\n\n         CLEAR (ACT/ACTIVE) (EXEC) (TEXT) (NAME) (TABS)\n\n         REQUIRED - NONE\n         DEFAULTS - NONE\n         ALIAS    - CLEA, CLE, CL, CLR\n\n)O OPERANDS -\n\n))ACT/ACTIVE -\n         CLEARS THE ACTIVE FILE.\n\n))EXEC -\n         CLEARS THE EXEC FILE.\n\n))TEXT -\n         CLEARS THE ACTIVE FILE.\n\n))NAME -\n          THE NAME OPTION RESETS THE GLOBAL  USER,  PREFIX,  AND\n          MEMBER  FIELDS  TO  THE  DEFAULT SIGNON VALUES.  THESE\n          FIELDS ARE USED IN FORMING <DSNAMES>.\n\n))TABS -\n          SPECIFYING THIS KEYWORD CLEARS ALL WYLBUR TABS.   THIS\n          DOES  NOT CLEAR ANY HARDWARE (TERMINAL) TABS THAT HAVE\n          BEEN SET.\n\n=COLLECT=COLLEC=COLLE=COLL=COL=C\n\n)F FUNCTION -\n\n          THE WYLBUR COLLECT COMMAND IS ONE OF THE  METHODS  FOR\n          ENTERING  DATA  INTO THE ACTIVE FILE AND IS ONE OF THE\n          TWO MODES OF OPERATIONS THAT WYLBUR HAS.\n\n)X SYNTAX -\n\n         COLLECT (STARTING NUMBER) (BY 'NNN') (MERGE) (CLEAR)\n                 (NUM/INT/UNN)\n\n         REQUIRED - NONE\n         DEFAULTS - STARTING LINE NO.= END, DELTA = 1, NOMERGE,\n                    NOCLEAR, NUM\n         ALIAS    - COLLEC, COLLE, COLL, COL, C\n\n         NOTE:  THERE IS ALTERNATE FORM OF GETTING INTO\n                COLLECT MODE.  WHILE IN COMMAND MODE,\n                HIT THE (ATTN) KEY.  THIS SWITCHES FROM\n                COMMAND MODE TO COLLECT MODE AND THE\n                REVERSE.\n\n)O OPERANDS -\n\n))STARTING NUMBER -\n          THE  LINE  NUMBER  THAT  YOU  WISH  WYLBUR  TO   START\n          COLLECTING  LINES.   NOTE....THE  FORM  OF  THE NUMBER\n          SPECIFIED IMPLIES TO WYLBUR THE 'DELTA'  VALUE  TO  BE\n          USED FOR INCREMENTING SUCH AS.....67.001 (TELLS WYLBUR\n          TO  INCREMENT  BY  .001)  .....67.01  (TELLS WYLBUR TO\n          INCREMENT BY .01) .....67.1 (TELLS WYLBUR TO INCREMENT\n          BY .1)...  .....THIS IMPLIED VALUE MAY  BE  OVERRIDDEN\n          BY  USE  OF  THE OTHER OPERANDS.  THE VALUE OF 'DELTA'\n          (NORMALLY 1.000) IS USED WHEN THE NUMBER SPECIFIED  IS\n          A WHOLE INTEGER.  EXAMPLE...COMMAND?  COL 64 (CR).  IF\n          YOU  SPECIFY  AS  A  NUMBER,  A  NUMBER THAT CURRENTLY\n          EXISTS, WYLBUR WILL INFORM YOU THAT THE LINE  NO.   IS\n          ILLEGAL.   IF  NO  LINE NUMBER IS GIVEN IN THE COLLECT\n          COMMAND, WYLBUR WILL RESUME COLLECTING AT THE PLACE IT\n          LEFT OFF WHEN YOU WERE LAST IN COLLECT MODE.\n\n))BY 'NNN' -\n          OVERRIDES DEFAULT DELTA VALUE.   IMPLIED  INCREMENTING\n          NUMBER  USED  BY  WYLBUR  TO  FIGURE OUT THE NEXT LINE\n          NUMBER WITH WHICH TO PROMPT YOU.\n\n))MERGE -\n          PERMITS INTERLEAVING THE COLLECTED LINES WITH EXISTING\n          LINES.\n\n))CLEAR -\n          YOU MAY  SPECIFY  THAT  THE  ACTIVE  FILE  BE  CLEARED\n          (COMPLETELY  ERASED)  AS  YOU  BEGIN  COLLECTING A NEW\n          FILE.\n\n))NUM/INT/UNN -\n          NUM IS THE DEFAULT AND CAUSES WYLBUR  TO  PROMPT  WITH\n          LINE  NUMBERS  WHEN READY TO RECEIVE TEXT.  INT CAUSES\n          THE PROMPT TO BE IN INTEGER FORM  AND  UNN  CAUSES  NO\n          PROMPTING TO OCCUR.\n\n=COMMENT=COMM=COMME=COMMEN=DISPLAY\n)F FUNCTION -\n          THE WYLBUR COMMENT COMMAND IS DESIGNED TO BE  USED  IN\n          EXEC  FILES TO DISPLAY TEXT AT THE TERMINAL.  IF NOLOG\n          IS IN EFFECT, THE COMMENT TEXT IS LISTED  EVEN  THOUGH\n          THE OTHER COMMANDS ARE NOT.  EXAMPLE:\n\n                   COMMAND?  LIST EXEC (CR)\n                     1.  COMMENT THIS TEXT WILL BE LISTED.\n                   COMMAND?  EXEC NOLOG (CR)\n                   THIS TEXT WILL BE LISTED.\n                   EXEC END\n                   COMMAND?\n\n)X SYNTAX -\n\n                   COMMENT <ANY TEXT>\n\n         REQUIRED - NONE\n         DEFAULTS - NONE\n         ALIAS    - COMM, COMME, COMMEN, DISPLAY\n\n)O\n=COMPARE=COMPAR=COMPA=COMP=COM\n)F FUNCTION -\n\n          THE WYLBUR COMPARE COMMAND MAY BE USED TO COMPARE  THE\n          CONTENTS  OF  TWO  SETS  OF CONSECUTIVE LINES, BOTH OF\n          WHICH MUST BE IN THE ACTIVE  FILE.   A  LINE  BY  LINE\n          COMPARE  IS MADE OF THE LINE CONTENTS UNTIL THE END OF\n          THE ACTIVE FILE IS REACHED OR A COMPARISON FAILS.   IF\n          A  COMPARISON  FAILS, YOU ARE NOTIFIED OF THE LINES IN\n          WHICH THE FAILURE OCCURS.  IF VERBOSE IS SET, YOU WILL\n          RECEIVE A MESSAGE TELLING WHICH LINES DO NOT  COMPARE.\n          YOU ALSO BE SHOWN THE TWO LINES.  IF TERSE IS SET, THE\n          LINES THAT DO NOT COMPARE WILL NOT BE LISTED.\n\n)X SYNTAX -\n\n         COMPARE <LINENO1> <LINENO2> (COLUMNS (N1/M1)) (LIST OPTIONS)\n\n         REQUIRED - LINENO1 AND LINENO2\n         DEFAULTS - NONE\n         ALIAS    - COMPAR, COMPA, COMP, COM\n\n)O OPERANDS -\n\n))LIST OPTIONS -\n          ANY OF THE LIST  OPTIONS  (DESCRIBED  UNDER  THE  HELP\n          ENTRY FOR THE LIST COMMAND) ARE VALID OPERANDS.\n\n))LINENO1 -\n          THIS IS THE STARTING LINE NUMBER OF THE FIRST  OF  THE\n          RANGES TO BE COMPARED.\n\n))LINENO2 -\n          THIS IS THE STARTING LINE NUMBER OF THE SECOND OF  THE\n          RANGES TO BE COMPARED.\n\n))COLUMNS N1/M1 -\n          IF THE COLUMNS OPERAND IS SPECIFIED,  ONLY  COLUMNS  N\n          THROUGH  M  ARE  COMPARED.   IF ONLY \"N\" IS SPECIFIED,\n          N/133 IS ASSUMED.  IF ONLY \"M\" IS  SPECIFIED,  1/M  IS\n          ASSUMED.\n\n=COPY=COP\n)F FUNCTION -\n\n          THE WYLBUR COPY COMMAND ALLOWS YOU TO COPY  A  <RANGE>\n          OF  LINES  TO  A  PLACE IN THE ACTIVE FILE.  LINES MAY\n          COME FROM THE ACTIVE FILE OR  FROM  AN  EXTERNAL  FILE\n          THAT  IS IN EDIT FORMAT (THIS INCLUDES THE EXEC FILE).\n          EXISTING LINES IN THE ACTIVE FILE MAY NOT BE  REPLACED\n          USING THE COPY COMMAND.\n\n          NOTE.....FOR SAMPLES OF VARIOUS FORMS OF COPYING,  SEE\n          THE ENTRY \"COPYSAMP\".\n\n)X SYNTAX -\n\n         COPY (<RANGE>) (EXEC) (N) (TO (LINENO1/END)) (FROM DSNAME)\n              (ON (VOLUME/CATLG)) (COMBINE) (USER UUUUU) (SET/NOSET)\n              (MERGE) (BY LINENO2) (LIST OPTIONS)\n\n         REQUIRED - VARIOUS DEPENDING ON FORM USED\n         DEFAULTS - RANGE=ALL, END, NOSET\n         ALIAS    - COP\n\n)O OPERANDS -\n\n))RANGE -\n          SPECIFIES THE RANGE OF LINES YOU WISH  TO  BE  COPIED.\n          THE  DEFAULT  LOCATION  FOR  RANGE IS THE ACTIVE FILE,\n          UNLESS OVERRIDDEN BY OTHER OPERANDS.\n\n))EXEC -\n          THIS OPERAND TELLS WYLBUR THAT THE RANGE SPECIFIED  IS\n          TO  BE TAKEN FROM THE EXEC FILE.  THE \"EXEC\" AND \"FROM\n          DSNAME\" OPERANDS ARE MUTUALLY EXCLUSIVE.\n\n))N -\n          THIS OPERAND TELLS WYLBUR HOW MANY COPIES OF A  SINGLE\n          LINE  YOU WANT.  THE COMMAND \"COPY 1 (3) TO END\" WOULD\n          RESULT IN THREE COPIES OF LINE 1 BEING PLACED  AS  THE\n          LAST THREE LINES IN THE ACTIVE FILE.\n\n))TO LINENO1/END -\n          THIS OPERAND TELLS WYLBUR WHERE YOU WANT THE  DATA  TO\n          BE COPIED TO.  DEFAULT LOCATION IS LAST + DELTA (END).\n\n))BY LINENO2 -\n          THIS OPTIONAL OPERAND, SPECIFIES WHAT INCREMENT TO ADD\n          TO THE STARTING LINE IN THE \"TO\"  LOCATION.   IF  THIS\n          OPERAND  IS NOT SPECIFIED, THE DEFAULT VALUE IS A 1 IN\n          THE LAST SPECIFIED POSITION OF <LINENO1>.  IF THE LAST\n          POSITION WAS FOR EXAMPLE 5.07, THEN .01 WOULD  BE  THE\n          INCREMENTING VALUE.  IF THE VALUE OF DELTA (DEFAULT OR\n          SPECIFIED)  WOULD CAUSE THE COPIED LINES TO INTERLEAVE\n          EXISTING  LINES  IN  THE  FILE,  WYLBUR  AUTOMATICALLY\n          CALCULATES A NEW VALUE OF DELTA SO  THAT  INTERLEAVING\n          DOES  NOT  TAKE  PLACE.  THE MERGE OR COMBINE OPERANDS\n          MAY  BE  SPECIFIED  TO  ALLOW  INTERLEAVING.   IF  NOT\n          SPECIFIED, WYLBUR SELECTS A DELTA THAT ALLOWS  FITTING\n          THE COPIED LINES BETWEEN EXISTING LINES.\n\n))FROM DSNAME -\n          THIS OPERAND TELLS WYLBUR THAT  THE  LOCATION  OF  THE\n          LINES  TO BE COPIED IS AN EXTERNAL FILE.  THE EXTERNAL\n          FILE MUST BE IN EDIT FORMAT.\n\n))ON VOLUME/CATLG -\n          THIS  OPERAND  TELLS  WYLBUR  WHAT  VOLUME  THE  \"FROM\n          DSNAME\" IS ON.  IF THIS OPERAND IS NOT SPECIFIED  THEN\n          WYLBUR  WILL SEARCH THE VOLUME SPECIFIED BY THE VOLUME\n          GLOBAL.\n\n))COMBINE -\n          THIS OPERAND ALLOWS WYLBUR TO  INTERLEAVE  LINES  INTO\n          THE  ACTIVE  FILE  AND  WHEN  THE \"FROM DSNAME\" \"EXEC\"\n          OPERAND IS USED.  TO ALLOW INTERLEAVING  WHEN  COPYING\n          FROM  ANOTHER PART OF THE ACTIVE FILE, USE THE \"MERGE\"\n          OPERAND.  NOTE...LINE NUMBERS FROM THE  \"FROM  DSNAME\"\n          ARE  USED  IN  A  COMBINE  OPERATION  AND  MUST NOT BE\n          PRESENT IN THE ACTIVE FILE.  IF PRESENT, THE OPERATION\n          TERMINATES WHEN SUCH A LINE NUMBER IS REACHED.\n\n))USER -\n          THIS OPERAND  SPECIFIES  THE  FIRST  QUALIFIER  OF  AN\n          EXTERNAL  FILE.   SEE  THE  HELP  ENTRY  FOR \"USE\" FOR\n          ALTERNATE METHODS OF SPECIFYING DSNAMES.\n\n))SET/NOSET -\n          THE SET OPTION WILL SET THE GLOBAL PREFIX  AND  MEMBER\n          FIELDS  TO  THOSE  SPECIFIED  IN THE COPY COMMAND.  IT\n          WILL NOT SET THE \"USER\" GLOBAL.  THE DEFAULT IS NOSET.\n\n))MERGE -\n          THIS OPERAND IS USED WHEN  COPYING  ONE  PART  OF  THE\n          ACTIVE  FILE  TO  ANOTHER  PART  AND  INTERLEAVING  IS\n          DESIRED.\n\n))LIST OPTIONS -\n          ANY OF THE LIST  OPTIONS  (DESCRIBED  UNDER  THE  HELP\n          ENTRY FOR LIST) ARE VALID OPERANDS.\n\n=DELETE=DELET=DELE=DEL=D\n)F FUNCTION -\n\n          THE WYLBUR DELETE COMMAND ALLOWS YOU TO DELETE (ERASE)\n          A RANGE OF LINES.  THE DELETED LINES ARE  ERASED,  NOT\n          REPLACED  BY  BLANKS.  THE LINE NUMBERS OF THE DELETED\n          LINES ARE ERASED, TOO.\n\n)X SYNTAX -\n\n         DELETE <RANGE> (LIST)\n\n         REQUIRED - RANGE\n         DEFAULTS - NOLIST\n         ALIAS    - DELET, DELE, DEL, D\n\n)O OPERANDS -\n\n))RANGE -\n          YOU MAY DELETE A SINGLE LINE  BY  GIVING  THE  COMMAND\n          \"DELETE  3.05\"  OR  BY SPECIFYING ONLY THE LINE NUMBER\n          SUCH AS \"3.05\".  YOU MAY  DELETE  EXPLICIT  RANGES  OF\n          LINES,  SUCH  AS  \"DELETE  3.05/6.8\".  IF THIS FORM OF\n          DELETION IS USED, UP TO 5 DISJOINT RANGES ARE ALLOWED.\n          YOU   MAY   ALSO   USE   THE   ASSOCIATIVE   FORM   OF\n          SPECIFICATION, SUCH AS \"DELETE 'MY DOG' IN  ALL\".   IF\n          THIS  FORM OF DELETION IS USED AND THE STRING IS SPLIT\n          BETWEEN TWO LINES, WYLBUR CAN NOT RECOGNIZE IT.\n\n))LIST -\n          THE LIST OPTION ALLOWS YOU TO LOOK AT THE LINES  AFTER\n          EACH  IS  DELETED.   IF  YOU  ARE DELETING A RANGE AND\n          LISTING IT, YOU HAVE  TIME  TO  STOP  THE  COMMAND  BY\n          PRESSING  THE  ATTN  KEY.   THE LINE BEING LISTED WILL\n          ALREADY HAVE BEEN DELETED.  YOU ARE CAUTIONED  NOT  TO\n          ABBREVIATE  \"LIST\"  WITH  \"L\".   \"L\" STANDS FOR \"LAST\"\n          WHEN USED AS A PARAMTER AND THUS THE LAST LINE OF YOUR\n          FILE WOULD BE DELETED AND NO LINES LISTED.\n\n=EDIT=EDI=ED=E\n)F FUNCTION -\n\n          THE WYLBUR EDIT  COMMAND  ALLOWS  YOU  TO  CHANGE  THE\n          CONTENTS  OF  A  <RANGE>  OF LINES IN THE ACTIVE FILE.\n          THERE IS A FULL DISCUSSION OF EDITING UNDER  THE  HELP\n          ENTRY  \"EDITING\"  AND  SOME  HINTS  ON  MORE EFFICIENT\n          EDITING UNDER THE HELP ENTRY \"EDHINTS\".\n\n          WHEN EXECUTED, THE EDIT COMMAND WILL PROMPT  WITH  THE\n          DESIGNATED  LINE.   ANY CHARACTER OR SET OF CHARACTERS\n          CAN BE REPLACED BY TYPING UNDER AN UNDESIRED CHARACTER\n          THE DESIRED REPLACEMENT CHARACTER.  IF A VERTICAL  BAR\n          (|)  IS TYPED UNDER A CHARACTER, THEN THE CHARACTER IS\n          REPLACED BY A BLANK.  IF A VERTICAL BAR IS TYPED UNDER\n          A BLANK, THEN THE VERTICAL BAR APPEARS IN THE TEXT.\n\n)X SYNTAX -\n\n         EDIT (RANGE) (LIST OPTIONS) (SINGLE)\n\n         REQUIRED - NONE\n         DEFAULTS - LIST, MULTIPLE PROMPTS, RANGE=ALL, NUM\n         ALIAS    - EDI, ED, E\n\n\n         NOTE:  IF YOU DECIDE THAT THE LINE DOES NOT NEED TO BE\n                EDITED, HIT CARRIAGE RETURN IMMEDIATELY AFTER THE\n                \"EDITS? \" PROMPT.  THERE ARE SEVERAL WAYS TO END\n                THE EDIT PROCESS.  THESE WAYS ARE LISTED AND\n                EXPLAINED UNDER THE OPERAND \"TERMINATION\".\n\n)O OPERANDS -\n\n))RANGE -\n          YOU MAY SPECIFY AN EXPLICIT OR ASSOCIATIVE  RANGE,  OR\n          UP TO TEN LINE NUMBERS IN A LIST (RATHER THAN TYPE TEN\n          SEPARATE  COMMANDS).   IF  YOU DO NOT SPECIFY A RANGE,\n          ALL IS ASSUMED.\n\n))LIST OPTIONS -\n          ALL OF THE LIST OPTIONS (DESCRIBED IN THE  HELP  ENTRY\n          FOR  LIST)  ARE  VALID  IN THE EDIT COMMAND LINE.  THE\n          \"NOLIST\"  (SHORT  FORM  =  N)  SUPPRESSES  THE  NORMAL\n          LISTING  OF  THE  CORRECTED  LINE.   ANOTHER  WAY   OF\n          SPECIFYING  THE \"NOLIST\" OPTION IS TO PLACE THE LETTER\n          \"N\" IN COLUMN 0 OF THE \"EDITS?  \" PROMPT  LINE.   THIS\n          WILL SUPPRESS LISTING FOR THAT LINE ONLY.  IF \"NOLIST\"\n          WAS  SPECIFIED  IN THE ORIGINAL EDIT COMMAND, THIS MAY\n          BE OVERRIDDEN BY PLACING THE LETTER \"L\"  IN  COLUMN  0\n          AND  THIS WILL CAUSE LISTING OF THE CORRECTED LINE FOR\n          THIS LINE ONLY.  NOTE:  COLUMN 0 DOES  NOT  CORRESPOND\n          TO  A COLUMN IN THE LINE BEING EDITED; IT MUST CONTAIN\n          ONLY THE VALUES --- BLANK, N, OR L.\n\n))SINGLE -\n          WYLBUR WILL PROMPT WITH \"EDITS?  \" FOR  A  LINE  UNTIL\n          ONLY  A  CARRIAGE  RETURN  IS GIVEN IN RESPONSE TO THE\n          PROMPT.  THE \"SINGLE\" OPTION CAN  BE  USED  TO  CHANGE\n          THIS  TO ONE PROMPT PER LINE.  THERE IS ANOTHER WAY TO\n          INDICATE \"SINGLE\" TO WYLBUR IF YOU DID NOT SPECIFY  IT\n          IN THE EDIT COMMAND.  SIMPLY TYPE @(ATTN) INSTEAD OF A\n          CARRIAGE  RETURN AT THE END OF A LINE.  THIS WILL GIVE\n          ANOTHER PROMPT FOR THE CURRENT LINE  IF  \"SINGLE\"  WAS\n          SPECIFIED OR TERMINATE PROMPTS FOR THE CURRENT LINE IF\n          THE NORMAL MULTIPLE MODE WAS IN EFFECT.\n\n))TERMINATION -\n          TO END THE EDIT COMMAND NORMALLY, PRESS  THE  CARRIAGE\n          RETURN  AS  THE  FIRST  CHARACTER  IN A LINE AFTER ALL\n          EDITING HAS BEEN  DONE.   TO  END  PROMPTING  FOR  THE\n          CURRENT  LINE  ONLY,  TYPING  A  \"@(ATTN)\"  INSTEAD OF\n          CARRIAGE RETURN WILL CAUSE THE CHANGES TO BE MADE  AND\n          THEN  PROMPTING  FOR  THE  NEXT  LINE  IN  THE <RANGE>\n          SPECIFIED.  TYPING A \"$(ATTN)\" INSTEAD OF  A  CARRIAGE\n          RETURN WILL CAUSE THE CHANGES SPECIFIED TO BE MADE AND\n          ALL  FURTHER  LINES  IN THE <RANGE> TO REMAIN THE SAME\n          AND A RETURN TO COMMAND MODE.  PRESSING THE (ATTN) KEY\n          ABORTS ANY CHANGES SPECIFIED IN THE CURRENT  LINE  AND\n          RETURNS YOU TO COMMAND MODE.\n\n=EXEC=EXE=X\n)F FUNCTION -\n\n          NOTE......THIS ENTRY IS FOR  THOSE  WHO  ARE  FAMILIAR\n          WITH  EXEC  FILES....FOR BEGINNERS..ENTER \"HELP FILES\"\n          FOR BASIC  INFORMATION  OF  AN  EXEC  FILE  AND  \"HELP\n          EXINTRO\" FOR AN INTRODUCTION TO USING EXEC FILES.\n\n          WYLBUR CAN EXECUTE A FILE OF COMMANDS FROM  A  SPECIAL\n          FILE  CALLED  AN  \"EXEC FILE\".  BEFORE COMMANDS CAN BE\n          EXECUTED FROM THE EXEC FILE, THE FILE MUST BE  LOADED.\n          THE EXEC COMMAND IS USED TO MOVE AN EXTERNAL OR ACTIVE\n          FILE  INTO  THE  EXEC FILE AND EXECUTE THE COMMANDS OR\n          EXECUTE COMMANDS THAT HAVE BEEN PREVIOUSLY  PLACED  IN\n          THE  EXEC  FILE.   IF  AN EXTERNAL FILE IS TO BE MOVED\n          INTO THE EXEC FILE, THE EXTERNAL FILE MUST BE IN  EDIT\n          FORMAT.    ANOTHER   USE   OF  THE  EXEC  FILE  IS  TO\n          TEMPORARILY HOLD A SMALL AMOUNT OF DATA THAT IS TO  BE\n          MERGED  INTO  ANOTHER FILE.  THE APPROXIMATE AMOUNT OF\n          EITHER COMMANDS OR DATA THAT CAN BE HELD IN  THE  EXEC\n          FILE  IS  ABOUT  150 LINES (DEPENDING ON THE NUMBER OF\n          EMBEDDED BLANKS).\n\n          WHEN A COMMAND IS BEING EXECUTED FROM THE EXEC FILE IS\n          INTERRUPTED BY THE USER HITTING (BREAK) OR (ATTN),  AN\n          \"EXEC  BREAK\"  OCCURS  AND THE USER RETURNS TO COMMAND\n          MODE.   THE  COMMAND  \"EXEC  RETRY\"  WILL   RE-ATTEMPT\n          EXECUTION  OF THE ABORTED COMMAND.  THE COMMAND \"EXEC\"\n          WILL START EXECUTION AT THE COMMAND WHICH FOLLOWS  THE\n          ABORTED  COMMAND.   NOTE...   THE  \"EXEC  CURRENT LINE\n          POINTER\" CONTROLS WHERE EXECUTION IS TO RESUME.\n\n)X SYNTAX -\n\n         EXEC ((ACTIVE/ACT)/FROM <DSNAME>) ((ON VOLUME)/CATLG)\n              (USER UUUUU) (SET/NOSET) (CLEAR/CLR) (LINENO1/RETRY)\n              (PAUSE/PAU) (LOG/NOLOG) (TERSE/VERBOSE)\n              (START <LINENO2>)\n\n         REQUIRED - NONE\n         DEFAULTS - LINE FOLLOWING EXEC CURRENT LINE POINTER OR\n                    FIRST LINE IF NO OPERANDS SPECIFIED, NOSET,\n                    LOG, VERBOSE\n         ALIAS    - EXE, X\n\n)O OPERANDS -\n\n))(ACTIVE/ACT)/FROM <DSNAME> -\n          THIS OPERAND TELLS WYLBUR WHERE HE IS TO LOOK FOR  THE\n          INFORMATION TO LOAD THE EXEC FILE WITH.\n\n))ON VOLUME/CATLG -\n          THIS OPERAND TELLS WYLBUR THE LOCATION OF  THE  \"FROM\"\n          FILE.   IF NOT SPECIFIED AND THE \"FROM DSNAME\" OPERAND\n          IS USED, WYLBUR WILL SEARCH THE GLOBAL VOLUME.\n\n))USER UUUUU -\n          THIS OPERAND IS USED IF THE  FIRST  QUALIFIER  OF  THE\n          DATA  SET NAME DOES NOT MATCH YOUR USERID.  THE GLOBAL\n          \"USER\" IS USED IF NOT SPECIFIED.  THIS GLOBAL  MAY  BE\n          SET  USING  THE \"SET USER\" COMMAND OR THE DEFAULT THAT\n          IS SET AT SIGNON TIME IS USED.\n\n))SET/NOSET -\n          THE DEFAULT IS NOSET.  IF SET IS SPECIFIED, THE GLOBAL\n          PREFIX AND MEMBER NAMES WILL BE SET.\n\n))CLEAR/CLR -\n          THIS OPERAND TELLS WYLBUR TO CLEAR  THE  CURRENT  EXEC\n          FILE  BEFORE  PERFORMING THE REST OF THE EXEC COMMAND.\n          IF YOU DO  NOT  SPECIFY  THIS  OPERAND  AND  THERE  IS\n          INFORMATION  IN  THE EXEC FILE, WYLBUR WILL PROMPT YOU\n          WITH \"OK TO CLEAR EXEC?   \".   ANY  REPLY  OTHER  THAN\n          \"YES\"  OR  \"OK\" WILL ABORT THE EXEC COMMAND AND RETURN\n          YOU TO COMMAND MODE.\n\n))LINENO1/RETRY -\n          THIS OPERAND, IF SPECIFIED, TELLS WYLBUR WHERE IN  THE\n          EXEC  FILE  TO  BEGIN OR RESUME EXECUTION OF COMMANDS.\n          THE GLOBAL EXEC CURRENT LINE  POINTER  CONTROLS  WHERE\n          EXECUTION  RESUMES OR STARTS.  IF THE GLOBAL IS SET AT\n          OTHER THAN THE FIRST COMMAND IN  THE  FILE,  EXECUTION\n          WILL RESUME AT THE COMMAND FOLLOWING UNLESS \"RETRY\" IS\n          SPECIFIED  WHICH  TELLS  WYLBUR  TO  RETRY THE CURRENT\n          COMMAND.\n\n))PAUSE/PAU -\n          SPECIFYING THIS OPERAND TELLS WYLBUR TO LOAD THE  EXEC\n          FILE  AND  RETURN  YOU  TO  THE  COMMAND  MODE WITHOUT\n          EXECUTING ANY OF THE LOADED COMMANDS.\n\n))LOG/NOLOG -\n          \"LOG\" IS THE DEFAULT AND WILL DISPLAY THE COMMANDS  AT\n          THE  TERMINAL  (PREFACED  WITH  \"->\")  BEFORE THEY ARE\n          EXECUTED.  THE RESULTS OF THE  EXECUTED  COMMANDS,  IF\n          DISPLAYED,  WILL  NOT  HAVE  THE  \"->\"  AS  A PREFACE.\n          \"NOLOG\" TELLS WYLBUR NOT TO DISPLAY THE COMMANDS.\n\n))TERSE/VERBOSE -\n          IF TERSE IS SPECIFIED, WYLBUR  SHORTENS  SOME  OF  THE\n          RESPONSES   AND  CAUSES  SUPPRESSION  OF  LINE  NUMBER\n          PRINTING.  VERBOSE IS  THE  DEFAULT  THAT  IS  SET  AT\n          SIGNON  TIME.  THE DEFAULT MAY BE OVERRIDDEN EITHER IN\n          THE EXEC COMMAND OR BY  USING  THE  \"SET  EXEC  TERSE\"\n          COMMAND.\n\n))START <LINENO2> -\n          AFTER  THE  LOAD  OF  THE  EXEC  FILE  IS   COMPLETED,\n          EXECUTION  BEGINS FROM THE START OF THE FILE IF \"START\n          <LINENO2>\" IS NOT SPECIFIED AND THE \"PAUSE\" OPTION  IS\n          NOT USED.\n\n=IF\n)F FUNCTION -\n          THE WYLBUR IF  COMMAND  IS  USED  IN  EXEC  FILES  FOR\n          CONDITIONAL   EXECUTION.   ONLY  THE  SYNTAX  FOR  THE\n          COMMAND IS GIVEN HERE.  SEE THE ENTRY  \"PREPROC2\"  FOR\n          FULL DETAILS ON USE.\n\n)X SYNTAX -\n\n         IF ( <EXP> <RELOP> <EXP> ) <COMMAND>\n)O\n=INSERT=INSER=INSE=INS=IN=I\n)F FUNCTION -\n\n          OPPOSITE TO THE WYLBUR DELETE COMMAND  IS  THE  INSERT\n          COMMAND.\n\n)X SYNTAX -\n\n         INSERT <LINE NUMBER> (NODITTO/DITTO) (LIST OPTIONS)\n\n         REQUIRED - LINE NUMBER\n         DEFAULTS - NODITTO\n         ALIAS    - INSER, INSE, INS, IN, I\n\n)O OPERANDS -\n\n))LINE NUMBER -\n          A LINE TO BE INSERTED MUST HAVE A LINE NUMBER ASSIGNED\n          BY YOU.  IF YOU ATTEMPT TO INSERT A LINE WITH THE SAME\n          NUMBER AS AN EXISTING LINE,  WYLBUR  PROMPTS  WITH  AN\n          ERROR  MESSAGE  THAT LINE IS IN THE FILE AND NO INSERT\n          MAY BE MADE.  YOU MAY SPECIFY 21 SEPARATE  LINES,  BUT\n          YOU  MAY  NOT  SPECIFY  A CONTINUOUS RANGE OF LINES BY\n          USING A (/) SLASH,  SUCH  AS  1/8.   ANOTHER  FORM  OF\n          INSERTING  DATA  IS  TO EXPLICITLY GIVE A LINE NUMBER,\n          FOLLOWED BY A BLANK, FOLLOWED BY THE DATA.  THIS  WILL\n          INSERT  THE  GIVEN LINE IF THE LINE DID NOT EXIST, AND\n          REPLACE THE LINE IF IT DID EXIST.  CARE SHOULD BE USED\n          WHEN DOING THIS FORM OF INSERTION.\n\n))NODITTO/DITTO -\n          THE DITTO OPTION MAY BE USED TO INSERT ONE LINE AT  UP\n          TO  21  POINTS  WITHIN A FILE.  WYLBUR WILL PROMPT FOR\n          THE FIRST LINE ONLY.\n\n))LIST OPTIONS -\n          ANY OF THE LIST  OPTIONS  (DESCRIBED  UNDER  THE  HELP\n          ENTRY FOR THE LIST COMMAND) ARE VALID OPERANDS.\n\n=JUSTIFY=JUSTIF=JUSTI=JUST=JUS=JU=J\n)F FUNCTION -\n\n          THE WYLBUR JUSTIFY COMMAND IS IDENTICAL TO  THE  ALIGN\n          COMMAND  EXCEPT  THAT IT ALSO RIGHT JUSTIFIES THE TEXT\n          TO THE VALUE OF THE LINE LENGTH SPECIFIED.\n\n)X SYNTAX -\n\n         JUSTIFY <RANGE> (LENGTH=N) (MARKER=C) (NUMBER)\n                 (INDENT=I(+ OR - J)) (EVEN) (SPACE)\n\n         REQUIRED - RANGE\n         DEFAULTS - LENGTH= GLOBAL LENGTH PARAMETER, INDENT= 0\n         ALIAS    - JUSTIF, JUSTI, JUST, JUS, JU, J\n\n          NOTE - NONE OF THE OPERANDS ARE DISCUSSED  HERE.   FOR\n          HELP  ON  THE  VARIOUS  OPERANDS,  SEE  THE ALIGN HELP\n          ENTRY.  THIS IS DUE TO THE  FACT  THAT  BOTH  COMMANDS\n          OPERATE THE SAME WAY AND HAVE THE SAME OPERANDS.\n)O\n=LIST=LIS=L\n)F FUNCTION -\n\n          THE WYLBUR LIST COMMAND WILL ALLOW  YOU  TO  SEE  YOUR\n          ACTIVE  FILE  OR  EXEC  FILE  PRINTED/LISTED  AT  YOUR\n          TERMINAL.   YOU  CAN  LIST  ALL OR PART/PARTS OF THESE\n          FILES.\n\n)X SYNTAX -\n\n         LIST <RANGE> (MARKER=C) (EXEC) (SQUASHED)\n              (COLUMNS M1/M2) (RANGE2) (LIST OPTIONS)\n\n          NOTE:  <RANGE> IS POSITIONAL IF SPECIFIED,  ALL  OTHER\n          OPERANDS  ARE  KEYWORD  AND  MAY  BE  SPECIFIED IN ANY\n          ORDER.\n\n         REQUIRED - NONE\n         DEFAULTS - RANGE=ALL, ACTIVE, UNSQUASHED, COLUMNS=ALL, TEXT\n         ALIAS    - LIS, L\n\n)O OPERANDS -\n\n))RANGE -\n          THE RANGE OPERAND LIMITS THE LISTING TO SOME SPECIFIED\n          SET OF LINES.  IF RANGE OMITTED THE DEFAULT OF ALL  IS\n          USED.\n\n))MARKER=\n          THE EFFECT OF THE MARKER  OPTION  IS  TO  SUSPEND  THE\n          LISTING  WHENEVER A LINE IS REACHED WHICH CONTAINS THE\n          MARKER CHARACTER IN COLUMN 1.  THE  SUSPENDED  LISTING\n          IS RESTARTED BY A (CR) RESPONSE.  AN (ATTN) OR (BREAK)\n          RESPONSE  GIVEN  WHILE  THE  LISTING IS SUSPENDED WILL\n          CAUSE THE REST OF THE  LISTING  TO  BE  ABORTED.   THE\n          MARKER  CHARACTER  IS  IGNORED AND LISTED AS ANY OTHER\n          DATA IF IN ANY COLUMN OTHER THAN COLUMN 1.  THERE  ARE\n          SOME  CHARACTERS  THAT YOU CAN NOT USE UNLESS THEY ARE\n          ENCLOSED WITHIN  QUOTATION  MARKS.   THESE  CHARACTERS\n          ARE:\n\n                   ( ) \" ' , =\n\n          AND THE BLANK OR LOWER CASE LETTERS.  A SAMPLE OF  THE\n          METHOD FOR USING THESE CHARACTERS IS:\n\n                   COMMAND?  LI UNN MARKER=\")\" (CR)\n\n))EXEC -\n          LISTS EXEC FILE RATHER  THAN  THE  ACTIVE  FILE.   THE\n          ACTIVE FILE IS THE DEFAULT.\n\n))SQUASHED -\n          THIS  OPERAND  IS  USED  TO  LIST  YOUR  DATA  WITHOUT\n          MULTIPLE BLANKS.\n\n))COLUMNS M1/M2 -\n          RESTRICTS THE LISTING  TO  THE  SPECIFIED  COLUMNS  M1\n          THROUGH M2.  PRESENT.\n\n))RANGE2 -\n          IF YOU HAVE SPECIFIED THE  FIRST  RANGE  FIELD  AS  AN\n          ASSOCIATIVE   RANGE   ('YOUR'),  YOU  MAY  SPECIFY  AN\n          EXPLICIT RANGE  ALSO  AND  THIS  IS  THE  PURPOSE  FOR\n          RANGE2.\n\n          EXAMPLE:\n                   COMMAND?  LIST ' YOUR ' IN 1/10 (CR)\n\n          YOU  MAY  ALSO  USE  RANGE2   TO   SPECIFY   \"ORDINAL\"\n          OCCURRENCES  OF  A  SPECIFIED  STRING  OF  CHARACTERS.\n          EXAMPLE:\n\n          COMMAND?  LIST 'NUMBER' (1,3,6/15) (CR)\n\n          THIS IS LEGAL AND WILL  LIST  THE  FIRST,  THIRD,  AND\n          SIXTH   THROUGH  THE  FIFTEENTH  LINES  IN  WHICH  THE\n          CHARACTER STRING \"NUMBER\" OCCURS.  THE OCCURRENCE LIST\n          MUST BE IN ASCENDING ORDER WITH NO  OVERLAP  OF  RANGE\n          AND SHOULD NOT BE CONFUSED WITH LINE NUMBERS 1, 3, AND\n          6 THROUGH 15.  REMEMBER THAT WYLBUR CANNOT TELL WHEN A\n          LINE  CONTAINS MORE THAN ONE INSTANCE OF THE SPECIFIED\n          STRING.  WYLBUR PROHIBITS THE USE  OF  THE  OCCURRENCE\n          SPECIFICATIONS  AND  THE MULTIPLE GROUP EXPLICIT RANGE\n          IN THE SAME COMMAND.\n\n          A MAXIMUM OF TEN NUMBERS OR RANGES MAY APPEAR  IN  THE\n          OCCURRENCE LIST.\n\n))LIST OPTIONS -\n          AT VARIOUS POINTS  IN  THE  HELP  ENTRIES,  THERE  ARE\n          REFERENCES  TO  \"LIST OPTIONS\".  THESE \"OPTIONS\" ARE A\n          SUBSET OF ALL OF THE OPTIONS AVAILABLE UNDER LIST.\n\n          THE \"UNNUMBERED\" OPTION PRODUCES A LISTING  CONTAINING\n          ONLY  THE  TEXT OF THE LINES IN THE <RANGE> SPECIFIED.\n          THE \"NONUMBERED\" AND \"TEXT\" OPTIONS FUNCTION SIMILARLY\n          TO THE \"UNNUMBERED\" OPTION EXCEPT THAT THE TEXT IS NOT\n          MOVED TO THE LEFT INTO THE PLACE USUALLY  OCCUPIED  BY\n          THE  LINE  NUMBERS.   THE  \"NOTEXT\"  OPTION SUPPRESSES\n          PRINTING OF THE TEXT AND PRODUCES A  LISTING  OF  ONLY\n          THE  LINE  NUMBERS  OF  THE  LINES  IN  THE  SPECIFIED\n          <RANGE>.   THE  \"INTEGER\"  OPTION REPLACES THE REGULAR\n          LINE NUMBERS WITH EIGHT DIGIT INTEGERS.  THE  \"NOLIST\"\n          OPTION  SUPPRESSES  LISTING WHEN \"LIST\" IS THE DEFAULT\n          FOR THE COMMAND.\n\n=LOAD=LOA\n)F FUNCTION -\n\n          THE WYLBUR LOAD COMMAND IS SIMILAR TO THE EXEC COMMAND\n          WITH ONLY TWO MAJOR DIFFERENCES:  YOU MAY SPECIFY THAT\n          A RANGE OF LINES FROM THE ACTIVE FILE OR  AN  EXTERNAL\n          FILE  BE  \"LOAD'ED\"  AND EXECUTED, AND THE ACTIVE FILE\n          WILL NOT BE ALTERED BY THE LOAD COMMAND.   NOTE....THE\n          LOAD   COMMAND  MAY  NOT  BE  USED  TO  EXECUTE  LINES\n          CURRENTLY IN THE EXEC FILE, I.E., IT MAY NOT  BE  USED\n          TO REPLACE THE \"EXEC <LINE NUMBER>\" COMMAND.\n\n)X SYNTAX -\n\n         LOAD (<RANGE>) ((FROM <DSNAME>) (ON <VOLUME/CATLG>))\n              (SET/NOSET) (START <LINENO>) (LOG/NOLOG) (TERSE/VERBOSE)\n              (PAUSE) (CLEAR)\n\n         REQUIRED - NONE\n         DEFAULTS - ACTIVE, VOL=CATLG, NOSET, LOG, VERBOSE, NOPAUSE,\n                    RANGE=ALL\n         ALIAS    - LOA\n\n)O OPERANDS -\n\n))RANGE -\n          WHEN YOU SPECIFY A RANGE IN  THE  LOAD  COMMAND,  ONLY\n          THAT  RANGE  IS LOADED INTO THE EXEC FILE.  THE ACTIVE\n          FILE IS NOT CLEARED.\n\n))FROM DSNAME -\n          SPECIFIES THAT WYLBUR IS TO LOAD THE EXEC FILE FROM AN\n          EXTERNAL FILE THAT IS IN WYLBUR  \"EDIT\"  FORMAT.   THE\n          DSNAME SPECIFIED MUST CONFORM TO NAMING CONVENTIONS AS\n          OUTLINED IN THE HELP ENTRY \"DSNAMES\".\n\n))ON VOLUME/CATLG -\n          SPECIFIES THE  VOLUME  ON  WHICH  THE  DATA  SET  THAT\n          CONTAINS  THE  DATA  TO  BE  LOADED  RESIDES.   IF NOT\n          SPECIFIED, THE DEFAULT VOLUME IS SEARCHED.\n\n))SET/NOSET -\n          THE DEFAULT IS NOSET AND DOES NOT UPDATE THE  \"CURRENT\n          EXEC  LINE\"  GLOBAL.   IF SET SPECIFIED, THE GLOBAL IS\n          SET.\n\n))START LINENO -\n          IF A START LINENO IS  SPECIFIED  WITHOUT  RANGE  BEING\n          SPECIFIED,  ONLY  THAT  LINENO IS LOADED INTO THE EXEC\n          FILE.   IF  A  RANGE  AND  A  START  LINENO  ARE  BOTH\n          SPECIFIED, THEN THE ENTIRE RANGE OF  LINES  IS  LOADED\n          AND EXECUTION STARTS WITH THE \"START LINENO\".\n\n))LOG/NOLOG -\n          LOG LISTS THE  COMMANDS  AT  THE  TERMINAL  AS  WYLBUR\n          EXECUTES THEM.  NOLOG WILL PREVENT THIS LISTING.\n\n))TERSE/VERBOSE -\n          THESE SETTINGS APPLY ONLY TO THE EXEC FILE PROCESSING,\n          NOT TO THE OVERALL SESSION.  VERBOSE IS THE DEFAULT.\n\n))PAUSE -\n          SPEICIFICATION OF THIS KEYWORD TELLS  WYLBUR  TO  LOAD\n          THE EXEC FILE, BUT DO NOT EXECUTE ANY OF THE COMMANDS.\n\n))CLEAR -\n          WYLBUR  CLEARS  THE  EXEC  FILE  BEFORE  LOADING.   IF\n          OMITTED AND THE EXEC FILE  CONTAINS  COMMANDS,  WYLBUR\n          WILL  PROMPT  WITH  \"OK  TO  CLEAR  EXEC?\".  THE VALID\n          REPLIES ARE \"YES\" OR \"OK\", ANY OTHER REPLY  TERMINATES\n          THE COMMAND AND RETURNS YOU TO COMMAND MODE.\n\n=MODIFY=MODIF=MODI=MOD=M\n)F FUNCTION -\n\n          THE   WYLBUR   MODIFY   COMMAND   ALLOWS   INSERTIONS,\n          REPLACEMENTS, AND DELETIONS TO THE  CONTENTS  OF  EACH\n          LINE  IN  A  SPECIFIED  <RANGE>.  SUCCESSIVE LINES ARE\n          PROMPTED  FOR  ALTERATIONS  UNTIL   THE   <RANGE>   IS\n          EXHAUSTED.   ALTHOUGH  THERE  ARE  A  FEW  EXCEPTIONS,\n          USUALLY  ONLY  ONE  MODIFICATION  MAY  BE ENTERED ON A\n          LINE.  THIS  RESTRICTION  CAN  MAKE  \"MODIFY\"  A  SLOW\n          COMMAND  TO  USE.   IF A LINE IS TO BE CHANGED IN MORE\n          THAN ONE PLACE, IT MAY BE EASIER TO  USE  THE  REPLACE\n          COMMAND  AND  RETYPE THE WHOLE LINE OR TO USE THE EDIT\n          COMMAND.\n\n)X SYNTAX -\n\n         MODIFY (<RANGE>) (LIST OPTIONS) (SINGLE)\n\n         REQUIRED -  NONE\n         DEFAULTS - RANGE = F/L, LIST\n         ALIAS    - MODIF, MODI, MOD, M\n\n         NOTE:  THERE IS AN ADDITIONAL ENTRY UNDER OPERANDS\n                WHICH EXPLAINS THE USE OF THE MODIFY CHARACTERS\n                AND IS NAMED ALTERATIONS.\n\n)O OPERANDS -\n\n))RANGE -\n          THE DEFAULT RANGE IS FIRST/LAST.   IF  SPECIFIED,  THE\n          RANGE WILL LIMIT WYLBUR TO THE LINES SPECIFIED.\n\n))LIST OPTIONS -\n          ANY OF THE VALID LIST OPTIONS (DESCRIBED IN  THE  HELP\n          ENTRY FOR LIST) ARE VALID OPERANDS.\n\n))SINGLE -\n          WYLBUR WILL ISSUE A SINGLE ALTERS PROMPT FOR EACH LINE\n          IN RANGE.\n\n))ALTERATIONS -\n          FOR EACH LINE IN THE SPECIFIED <RANGE>  THE  FOLLOWING\n          PROCESS  IS CARRIED OUT.  FIRST, THE IMAGE OF THE LINE\n          IN  IT'S  PRESENT  FORM  IS  DISPLAYED.   THEN  WYLBUR\n          PROMPTS FOR AN ALTERATION TO BE MADE TO THE LINE  WITH\n          THE  MESSAGE \"ALTERS?\" AND THE CURSOR POSITIONED UNDER\n          THE FIRST CHARACTER OF THE DATA.  ALTERATIONS ARE  ONE\n          OF THE FOLLOWING:\n\n          INSERT (I)---TYPE THE LETTER I IMMEDIATELY  BELOW  THE\n          CHARACTER  IN  THE LINE BEFORE WHICH CHARACTERS ARE TO\n          BE INSERTED.  THIS INDICATOR IS FOLLOWED BY THE STRING\n          OF CHARACTERS  (INCLUDING  BLANKS)  WHICH  ARE  TO  BE\n          INSERTED.\n\n          REPLACE  (R)---THIS  INDICATOR  IS  TYPED  IMMEDIATELY\n          BELOW THE FIRST CHARACTER TO BE REPLACED IN THE  LINE.\n          THE   STRING   OF   REPLACEMENT  CHARACTERS  IS  TYPED\n          IMMEDIATELY FOLLOWING THE R.  AS MANY  CHARACTERS  ARE\n          REPLACED  AS  THERE  ARE CHARACTERS IN THE REPLACEMENT\n          STRING.\n\n          DELETE (D)---A STRING OF CHARACTERS TO BE DELETED FROM\n          THE LINE IS  DESIGNATED  BY  TYPING  A  D  UNDER  EACH\n          SUCCESSIVE   CHARACTER   TO  BE  REMOVED.   A  DELETED\n          CHARACTER IS NOT REPLACED BY A  BLANK;  WYLBUR  SHIFTS\n          THE  OTHER TEXT TO ELIMINATE THE SPACE.  YOU NEED TYPE\n          A D ONLY UNDERNEATH THE FIRST AND LAST  CHARACTERS  IN\n          THE  STRING  TO  BE DELETED --- ALL CHARACTERS BETWEEN\n          THE TWO D'S ARE DELETED.  THE DELETION RANGE MAY  ALSO\n          BE TERMINATED BY EITHER AN I OR R INSTEAD OF A D.\n\n          BLANK (B)---INDIVIDUAL CHARACTERS MAY  BE  BLANKED  IN\n          THE  LINE  BY  TYPING  A  B  UNDER EACH POSITION TO BE\n          BLANKED.  ONLY THOSE  POSITIONS  ARE  BLANKED  AND  NO\n          SHIFTING   OF   THE   LINE  TAKES  PLACE.   ANY  OTHER\n          ALTERATION MAY FOLLOW THE LAST B ON A LINE (D, R, I).\n\n          MULTIPLE MODIFICATIONS --- (DI) (DR) (BI) (BR) (BD)  A\n          FEW COMBINATIONS OF ALTERATIONS ARE ALLOWED PER ALTERS\n          PROMPT.   THEY  ARE:   DELETE  FOLLOWED  BY  INSERT OR\n          REPLACE, AND BLANK  FOLLOWED  BY  INSERT,  REPLACE  OR\n          DELETE.  TO REPLACE A STRING BY A LONGER STRING, IT IS\n          CONVENIENT TO USE DELETE FOLLOWED BY INSERT.  EXAMPLE:\n\n         COMMAND?  MOD 25 (CR)\n          25.    WE ARE GOING TO MOD THIS LINE.\n          ALTERS?       D          DIIN THE PROCESS OF MODIFYING\n          25.    WE ARE IN THE PROCESS OF MODIFYING THIS LINE.\n\n          THE D D CAUSED THE DELETION OF THE  STRING  'GOING  TO\n          MOD'  AND  THE  I  UNDER  THE BLANK FOLLOWING THE WORD\n          'MOD' CAUSED THE STRING FOLLOWING IT TO  BE  INSERTED.\n          NOTE:   IT  WAS NOT NECESSARY TO ENTER THE ENDING D TO\n          INDICATE  THE  RANGE  OF  THE  DELETION  SINCE  THE  I\n          INDICATOR WILL AUTOMATICALLY  TERMINATE  THE  DELETION\n          RANGE  AT  THE  CHARACTER  POSITION JUST BEFORE THE I.\n          THE OTHER FORMS OF MULTIPLE MODIFICATIONS WORK IN  THE\n          SAME MANNER.\n\n          AFTER THE ALTERATION IS  SPECIFIED,  TYPE  A  CARRIAGE\n          RETURN.  WYLBUR WILL MAKE THE INDICATED ALTERATIONS IN\n          THE  LINE  AND  TYPE  THE  NEW  IMAGE  OF THE LINE FOR\n          INSPECTION.   THEN  WYLBUR  WILL   PROMPT   FOR   MORE\n          ALTERATIONS,  UNLESS  YOU  HAVE SPECIFIED THE \"SINGLE\"\n          OPERAND.  YOUR SIGNAL TO WYLBUR THAT  ALL  ALTERATIONS\n          HAVE  BEEN  MADE  IS  MADE  BY  TYPING ONLY A CARRIAGE\n          RETURN IN ANSWER TO  THE  ALTERATION  PROMPT.   WYLBUR\n          WILL  THEN  PUT  THE  NEW  IMAGE  OF THE LINE INTO THE\n          ACTIVE FILE AND PROMPT FOR  ALTERATIONS  TO  THE  NEXT\n          LINE IN THE <RANGE>.\n\n          THE DISPLAYING OF THE ALTERED IMAGE OF THE LINE MAY BE\n          SUSPENDED BY TYPING AN N INDICATOR INTO THE ALTERATION\n          LINE BEFORE ANY OTHER ALTERATION INDICATORS.\n\n          YOU MAY HAVE WYLBUR TYPE OUT THE  IMAGE  OF  THE  LINE\n          BEING  MODIFIED,  AS  IT CURRENTLY STANDS.  TYPE A FEW\n          BLANKS INTO THE ALTERATION LINE AND ISSUE  A  CARRIAGE\n          RETURN.\n\n          YOU MAY ELIMINATE ALL ALTERATIONS MADE TO  A  LINE  BY\n          HITTING  ATTENTION  (DUP/PA1),  OR  BREAK AS THE FIRST\n          CHARACTER IN THE  ALTERS  LINE.   WYLBUR  WILL  FORGET\n          ABOUT  ALL  ALTERATIONS  ALREADY MADE.  TERMINATION OF\n          THE MODIFY COMMAND IS THE SAME AS  THAT  OF  THE  EDIT\n          COMMAND.   FOR  MORE  INFORMATION ON TERMINATION ENTER\n          \"HELP EDIT\".\n\n=MOVE=MOV\n)F FUNCTION -\n\n          THIS WYLBUR COMMAND MOVES LINES FROM ONE PART  OF  THE\n          ACTIVE  FILE  TO  ANOTHER.  IT IS ESSENTIALLY A \"COPY\"\n          COMMAND FOLLOWED BY A \"DELETE\" COMMAND, WHERE THE  OLD\n          INSTANCES OF THE COPIED LINES ARE DELETED.\n\n          NOTE......IF YOU NEED SAMPLES OF  THE  MOVE  COMMANDS,\n          SEE  THE  ENTRIES FOR \"MOVESAMP\" AND \"COPYSAMP\".  BOTH\n          THE MOVE AND COPY COMMANDS ARE SIMILAR IN FUNCTION.\n\n)X SYNTAX -\n\n         MOVE <RANGE> TO (<LINENO1>/END) (BY <LINENO2>)\n              (MERGE) (LIST OPTIONS)\n\n         REQUIRED - RANGE\n         DEFAULTS - TO=END, BY=1, NOMERGE\n         ALIAS    - MOV\n\n)O OPERANDS -\n\n))RANGE -\n          SPECIFIES THE RANGE OF LINES TO BE MOVED.\n\n))TO <LINENO1>/END -\n          SPECIFIES THE STARTING LINE NUMBER OF  WHERE  TO  MOVE\n          THE  RANGE  SPECIFIED.   \"END\"  IS  THE DEFAULT, WHERE\n          \"END\" IS EQUAL TO  \"DELTA\"  HIGHER  THAN  THE  CURRENT\n          \"LAST\".\n\n))BY <LINENO2> -\n          SPECIFIES THE LINE INCREMENT TO BE USED IF OTHER  THAN\n          \"1\".  NOTE.......DELTA IS NOT USED TO INCREMENT.\n\n))MERGE -\n          USED  TO  SPECIFY  INTERLEAVING  OF  LINES.   IF   NOT\n          SPECIFIED  AS  A PARAMETER, NO INTERLEAVING WILL OCCUR\n          AND WYLBUR WILL ABORT THE OPERATION AND SEND A MESSAGE\n          TO THE TERMINAL.  \"MERGE\" MUST APPEAR AFTER <LINENO2>.\n\n))LIST OPTIONS -\n          ANY OF THE VALID LIST OPTIONS ARE VALID OPERANDS.\n\n=NUMBER=N=NU=NUM=NUMB=NUMBE\n)F FUNCTION -\n          THE WYLBUR NUMBER COMMAND IS USED TO RENUMBER SOME  OR\n          ALL OF THE LINES OF TEXT IN AN ACTIVE FILE\n)X SYNTAX -\n         NUMBER      (START (/STOP)) (BY NN) (TIMES NN) (RANGE)\n                   (START/STOP)    (TIMES)\n\n   REQUIRED - NONE\n   DEFAULTS - START=DELTA, BY=DELTA, RANGE=ALL\n   ALIAS    - N, NU, NUM, NUMB, NUMBE\n\n)O OPERANDS -\n\n))START (/STOP) -\n          YOU MAY SPECIFY A NUMBER AT WHICH THE NUMBERING IS  TO\n          BEGIN BY GIVING IT IN THE COMMAND.  THIS WILL OVERRIDE\n          THE DELTA DEFAULT.\n             EXAMPLE:\n                      COMMAND ?  NUMBER 2.111(CR)\n                        72.111 - LAST LINE\n                      COMMAND ?\n\n          WYLBUR STARTS NUMBERING AT 2.111 AND NUMBERS THE WHOLE\n          ACTIVE FILE AND THEN PRINTS OUT THE NUMBER OF THE LAST\n          LINE.  THE DELTA VALUE (NORMALLY  1.000)  IS  USED  TO\n          INCREMENT DURING NUMBERING OPERATION.\n\n          IF \"/STOP\" IS SPECIFIED, THE DELTA VALUE IS OVERRIDDEN\n          AND WYLBUR WILL CALCULATE A DELTA THAT WILL ENABLE ALL\n          LINES IN THE RANGE TO BE RENUMBERED UNLESS  THE  DELTA\n          DEFAULT OF 1.000 IS ACCEPTABLE.\n\n))BY NN -\n          SETS THE DELTA VALUE USED TO  INCREMENT  NUMBERING  TO\n          \"NN\".\n\n             EXAMPLE:\n                   COMMAND ?  NUMBER 2.065 BY .01(CR)\n                      8.795 - LAST LINE\n                   COMMAND ?\n\n          THIS CAUSES RENUMBERING TO START WITH LINE # 2.065 AND\n          INCREMENT BY .01 (2.065, 2.075, 2.085.....8.795).\n\n))TIMES NN -\n          THIS OPERAND IS USED IN  CONJUNCTION  WITH  THE  DELTA\n          OVERRIDE TO ACCOMPLISH SCALING.\n             EXAMPLE:\n                   COMMAND ?  N TIMES 10(CR)\n                     6720 - LAST LINE\n                   COMMAND ?\n\n          THIS  CAUSES  ALL  LINE  NUMBERS  IN  A  FILE  TO   BE\n          MULTIPLIED BY \"NN\" WHILE :\n\n                   COMMAND ?  N TIMES .1(CR)\n                      67.1 - LAST LINE\n                   COMMAND ?\n\n          CAUSES ALL LINE NUMBERS TO BE EFFECTIVELY  DIVIDED  BY\n          10.\n\n               >>>> REMEMBER, THIS FORM OF THE  NUMBER  COMMAND\n               CAUSES  RENUMBERING  OF  THE ENTIRE FILE AND NOT\n               JUST A SPECIFIC RANGE.  WYLBUR LINE NUMBERS MUST\n               BE BETWEEN 0.001 AND 99999.999. <<<<\n\n))RANGE2 -\n          YOU MAY ALSO LIMIT THE RANGE OF LINES TO BE RENUMBERED\n          BY GIVING A STARTING AND STOPPING POINT TO WYLBUR.\n             EXAMPLE:\n                   COMMAND ?  NUMBER 300/800(CR)\n\n          THIS WOULD NUMBER LINES 300 THROUGH 800 BY THE CURRENT\n          DELTA.  THE FIRST LINE IN THE RENUMBERED  LINES  WOULD\n          BE   300.    IF   THERE  ARE  TOO  MANY  LINES  TO  BE\n          ACCOMMODATED WITH THE CURRENT DELTA, WYLBUR CALCULATES\n          THE LARGEST POSSIBLE DELTA TO MAKE ALL LINES FIT.\n\n=POINT=POIN=POI=PO=P\n)F FUNCTION -\n\n          THE WYLBUR POINT COMMAND FUNCTIONS EXACTLY THE SAME AS\n          THE LIST COMMAND EXCEPT THAT  IT  UPDATES  TO  CURRENT\n          LINE  POINTER  (*)  AS  IT  LISTS  A  LINE.  THE POINT\n          COMMAND HAS ALL OF THE OPERANDS OF  THE  LIST  COMMAND\n          PLUS  A \"NOLIST\" OPTION WHICH SETS (*) WITHOUT LISTING\n          ANY LINES.  THIS IS ESPECIALLY USEFUL IN EXEC FILES.\n\n          \"POINT <RANGE> EXEC\"  SETS  A  SEPARATE  CURRENT  LINE\n          POINTER  FOR THE EXEC FILE.  THIS IS DISTINCT FROM THE\n          ACTIVE FILE CURRENT LINE POINTER, AND  THESE  POINTERS\n          MAY HAVE DIFFERENT VALUES.\n\n          \"POINT 6/10 EXEC\" WILL LIST LINES 6 THROUGH 10 OF  THE\n          EXEC  FILE AND THE EXEC FILE CURRENT LINE POINTER WILL\n          BE SET TO LINE 10 IF LINE 10 EXISTS.  IF THERE  IS  NO\n          LINE  10,  THE POINTER WILL BE SET TO THE HIGHEST LINE\n          NUMBER LESS THAN 10.\n\n          \"POINT 6/10 NOLIST\" SETS THE CURRENT LINE POINTER  FOR\n          THE  ACTIVE  FILE  IN  THE SAME WAY, BUT DOES NOT LIST\n          LINES 6/10.\n\n          DURING EXECUTION OF AN EXEC FILE, WYLBUR SETS THE EXEC\n          FILE CURRENT LINE POINTER TO THE LINE CURRENTLY  BEING\n          EXECUTED.   THE NEXT LINE TO BE EXECUTED IS ALWAYS THE\n          LINE REFERENCED BY  THE  EXEC  SYMBOLIC  LINE  POINTER\n          \"NEXT\",  UNLESS  OTHERWISE SPECIFIED.  BECAUSE OF THIS\n          FACT, \"POINT <RANGE> EXEC\" MAY BE  USED  AS  A  BRANCH\n          INSTRUCTION WITHIN AN EXEC FILE.\n\n          IN THE FOLLOWING EXAMPLE, THE \"POINT\" COMMAND IS  USED\n          TO SHOW HOW LABELS MAY BE USED IN AN EXEC FILE:\n\n                   1.   LIST 1\n                   2.   POINT 1 ';SKIP' EXEC NOL\n                   3.   LIST 2\n                   4.   ;SKIP\n                   5.   LIST 3\n\n          AFTER STATEMENT ONE EXECUTES, STATEMENT TWO  SETS  THE\n          EXEC FILE CURRENT LINE POINTER TO THE LAST LINE IN THE\n          EXEC  FILE  WHICH  HAS  THE  CHARACTER  STRING ';SKIP'\n          STARTING IN COLUMN 1.  (IF YOU HAD NOT  SPECIFIED  \"1\"\n          IN  THE  POINT  COMMAND,  WYLBUR WOULD SEARCH THE EXEC\n          FILE FOR THE  LAST  LINE  CONTAINING  ';SKIP'  IN  ANY\n          POSITION  WITHIN  IT.)  IN THIS CASE, LINE FOUR IS THE\n          ONLY LINE WHICH HAS THE STRING ';SKIP' STARTING IN ITS\n          FIRST COLUMN AND THE EXEC FILE CURRENT LINE POINTER IS\n          SET TO FOUR.  AS  STATED  PREVIOUSLY,  THE  NEXT  LINE\n          WHICH  IS TO EXECUTE IS THE LINE IMMEDIATELY FOLLOWING\n          THE LINE REFERENCED BY  THE  EXEC  FILE  CURRENT  LINE\n          POINTER,  LINE  FIVE.  THUS, THE ORDER OF EXECUTION OF\n          THE STATEMENTS IN THE FILE IS ONE,  TWO,  AND  FINALLY\n          FIVE.   OUTPUT  FROM  THIS  EXECUTION  CONSISTS  OF  A\n          LISTING OF LINES ONE AND THREE OF THE ACTIVE FILE WHEN\n          LINES 1 AND 5 OF THE EXEC FILE ARE EXECUTED.\n\n)X\n)O\n=POP\n)F FUNCTION -\n\n          THE WYLBUR POP COMMAND IS USED TO REMOVE COMMANDS THAT\n          HAVE BEEN PLACED ON THE TSO COMMAND STACK.\n\n)X SYNTAX -\n\n         POP (ALL)\n\n         REQUIRED - NONE\n         DEFAULT  - SINGLE COMMAND TO BE REMOVED\n         ALIAS    - NONE\n\n)O OPERANDS -\n))ALL -\n          THE POP COMMAND WILL REMOVE  THE  LAST  ADDED  COMMAND\n          UNLESS  THE  \"ALL\" KEYWORD IS SPECIFIED, IN WHICH CASE\n          ALL \"STACKED\" COMMANDS ARE REMOVED.\n\n=PROFILE=PROFIL=PROFI=PROF=PRO\n)F FUNCTION -\n         THE WYLBUR PROFILE COMMAND GIVES INFORMATION ON SESSION\n         CONTROL DEFAULTS THAT ARE SET IN TSO.\n\n)X SYNTAX -\n\n         PROFILE\n\n         REQUIRED - NONE\n         DEFAULTS - NONE\n         ALIAS    - PROFIL, PROFI, PROF, PRO\n\n)O OPERANDS -\n               THERE ARE NO OPERANDS.\n=PUT=PU\n)F FUNCTION -\n\n          THE WYLBUR PUT COMMAND WORKS THE SIMILAR TO THE \"SHOW\"\n          COMMAND EXCEPT THAT THE DATA IS ADDED  TO  THE  ACTIVE\n          FILE AS IT LISTS AT THE TERMINAL.\n\n)X SYNTAX -\n\n         PUT (DIRECTORY/DSNAMES) (ON <VOLUME>) (CLEAR) (AT <LINENO1>)\n             (BY <LINENO2>) (LIST OPTIONS) (SHOW OPTIONS)\n\n         REQUIRED - DIRECTORY OR DSNAMES\n         DEFAULTS - AT \"END\"\n         ALIAS    - PU\n\n)O OPERANDS -\n\n))DIRECTORY/DSNAMES -\n          THE \"PUT DIRECTORY\" OR \"PUT DSNAMES\" COMMANDS HAVE ALL\n          OF THE OPTIONS OF THEIR  RESPECTIVE  \"SHOW\"  COMMANDS.\n          IF  \"PUT  DIRECTORY\"  IS USED ....  THE DEFAULT DSNAME\n          FOR THE DIRECTORY LIST IS UUUUU.LIB,  WHERE  UUUUU  IS\n          YOUR USERID.\n\n))ON VOLUME -\n          TELLS WYLBUR THE VOLUME ON WHICH YOU WISH  THE  SEARCH\n          TO  BE  MADE.  IF SPECIFIED, THIS OVERRIDES THE VOLUME\n          GLOBAL.\n\n))CLEAR -\n          TELLS  WYLBUR  TO  CLEAR  THE  ACTIVE  FILE  PRIOR  TO\n          STARTING THE PUT OPERATION.\n\n))AT LINENO1 -\n          TELLS WYLBUR THE LINE NUMBER AT WHICH TO START PLACING\n          THE \"PUT\" DATA.  IF NOT SPECIFIED, \"END\" IS ASSUMED.\n\n))BY LINENO2 -\n          TELLS WYLBUR WHAT  INCREMENT  TO  USE  WHEN  \"PUTTING\"\n          LINES.   IF  NOT  SPEICIFIED, THE GLOBAL DELTA IS USED\n          (NORMALLY 1.000).\n\n))LIST OPTIONS -\n          ALL OF THE OPTIONS AVAILABLE UNDER  THE  LIST  COMMAND\n          ARE VALID OPERANDS.\n\n))SHOW OPTIONS -\n          ALL OF THE OPTIONS AVAILABLE UNDER  THE  SHOW  DSNAMES\n          COMMAND ARE VALID OPERANDS.\n\n=READ=REA\n)F FUNCTION -\n\n          THE WYLBUR READ COMMAND IS USED TO EXECUTE ONE COMMAND\n          FROM EITHER THE ACTIVE  OR  EXEC  FILES,  OR  INPUT  A\n          COMMAND, OR SET DATA VARIABLES FROM THE TERMINAL.  THE\n          READ  COMMAND WITH NO OPERANDS PRODUCES A PROMPT FOR A\n          COMMAND.  WHEN THE  NEW  COMMAND  IS  ENTERED,  IT  IS\n          EXECUTED.   THIS  COMMAND  IS DESIGNED FOR USE IN EXEC\n          FILES TO ALLOW YOU TO ENTER COMMANDS WITHOUT HAVING TO\n          \"PAUSE\" EXECUTION.  IF YOU HAVE ENTERED A  COMMAND  IN\n          COLLECT MODE RATHER THAN IN COMMAND MODE, THIS COMMAND\n          PROVIDES AN EASY WAY TO CORRECT THE ERROR BY USING THE\n          \"DELETE\" OPERAND.\n\n)X SYNTAX -\n\n         READ (<LINENO>) (EXEC/DELETE) (PROMPT <STRING>)\n\n         2.  READ VALUE <VARIABLE>(S)\n             READ VALUE <VARIABLE>(S) PROMPT <STRING>\n\n         3.  READ STRING <SVARIABLE>\n             READ STRING <SVARIABLE> PROMPT <STRING>\n\n         NOTE:.....THE \"2\" AND \"3\" TYPES OF THE READ COMMAND\n                   ARE NOT COVERED HERE.  SEE THE ENTRY \"PREPROC2\".\n\n\n         REQUIRED - NONE\n         DEFAULTS - NONE\n         ALIAS    - REA\n\n)O OPERANDS -\n\n))LINENO -\n          READ <LINENO>  ALLOWS  ONE  COMMAND  TO  BE  READ  AND\n          EXECUTED  FROM  THE  ACTIVE  FILE, OR THE EXEC FILE IF\n          \"EXEC\" IS SPECIFIED.\n\n))EXEC/DELETE -\n          IF THE \"DELETE\" OPTION IS SPECIFIED, THE COMMAND  WILL\n          BE  ERASED FROM THE ACTIVE FILE BEFORE EXECUTION.  THE\n          \"DELETE\" FEATURE ALLOWS YOU  TO  BUILD  SINGLE  WYLBUR\n          COMMANDS  IN  THE  ACTIVE  FILE  AND  THEN EXECUTE THE\n          COMMANDS WITHOUT  HAVING  TO  CHANGE  THE  EXEC  FILE.\n          \"DELETE\"    AND   \"EXEC\"   ARE   MUTUALLY   EXCLUSIVE.\n          SPECIFICATION OF \"EXEC\" TELL WYLBUR THAT  THE  COMMAND\n          TO BE EXECUTED IS TO COME FROM THE EXEC FILE.\n\n))PROMPT <STRING> -\n          THE PROMPT <STRING>  OPTION,  WHEN  USED,  CAUSES  THE\n          <STRING>   TO   BE  WRITTEN  AT  THE  TERMINAL  BEFORE\n          \"READ'ING\" THE COMMAND.  IF THIS OPERAND  IS  OMITTED,\n          WYLBUR WILL PROMPT WITH \"ENTER?  \" AND WAIT FOR YOU TO\n          ENTER  A  STRING OF DATA.  IF YOU REPLY WITH A (CR) OR\n          THE WORD \"EXEC\"  (WHEN  REPLYING  TO  THE  \"ENTER?   \"\n          PROMPT  FROM  WITHIN  AN  EXEC FILE), EXECUTION OF THE\n          FILE WILL CONTINUE AT THE NEXT LINE OF THE EXEC  FILE.\n          IF THE RESPONSE TO THE \"ENTER?  \" PROMPT HAD BEEN \"EXE\n          6\"  (OR  A NUMBER HIGHER THAN ANY EXISTING IN THE EXEC\n          FILE),  WYLBUR  WILL  RESPOND  WITH  \"EXEC  END\"   AND\n          TERMINATE  EXECUTION OF THE EXEC FILE.  IF LINE 6 IS A\n          VALID LINE NUMBER IN  THE  EXEC  FILE,  OR  THERE  ARE\n          EXISTING  LINES  WITH A HIGHER LINE NUMBER IN START AT\n          LINE 6, OR THE NEXT HIGHER LINE.  AS YOU CAN SEE, THIS\n          WILL ALLOW DYNAMIC BRANCHING WITHIN THE EXEC FILE.\n\n=RECATLG=RECATL=RECAT=RECA=REC\n)F FUNCTION -\n          IF, AFTER SAVING A DATA SET WITHOUT CATALOGING IT,  AN\n          ERROR  IS  MADE  DURING  THE  CATALOG PROCESS, YOU MAY\n          CORRECT YOUR ERROR BY USING THIS COMMAND.\n\n)X SYNTAX -\n\n         RECATLG <DSNAME> <ON 'VOLUME'>\n\n         REQUIRED - ALL OPERANDS\n         DEFAULT  - VOLUME=CATLG\n         ALIAS    - RECATL, RECAT, RECA, REC\n\n)O OPERANDS -\n\n))DSNAME -\n          SOME FORM OF DSNAME MUST BE GIVEN.  FOR  FURTHER  INFO\n          ON DATA SET FORMAT, SEE THE ENTRY \"DSNAMES\".\n\n))ON 'VOLUME' -\n          ANY ONE OF THE VALID SAVE VOLUMES  MAY  BE  SPECIFIED.\n          TO SEE WHAT VOLUMES ARE AVAILABLE FOR SAVING ENTER THE\n          COMMAND  \"SHOW  VOLUMES\".  IF THIS OPERAND IS OMITTED,\n          THE DATA SET WILL BE CATALOGED ON  THE  VALUE  OF  THE\n          VOLUME  DEFAULT  (NORMALLY \"CATLG\").  THIS WILL RESULT\n          IN THE DATA SET BEING CATALOGED ON THE WRONG VOLUME OR\n          ON A VOLUME WITH THE NAME 'CATLG' MOST  OF  THE  TIME.\n          IT  IS  THEREFORE RECOMMENDED THAT YOU MAKE A HABIT OF\n          ALWAYS SPECIFYING THIS OPERAND.\n\n=RENAME=RENAM=RENA=REN\n)F FUNCTION -\n\n          THE WYLBUR RENAME COMMAND ALLOWS YOU TO RENAME ANY  OF\n          YOUR  DATA  SETS OR PDS MEMBERS.  IN ADDITION, YOU MAY\n          ADD ALIASES TO A PDS MEMBER, SO THAT YOU MAY REFER  TO\n          A MEMBER BY MORE THAN ONE NAME.\n\n)X SYNTAX -\n\n         THERE ARE TWO FORMS OF THE COMMAND:\n\n         RENAME <DSNAME> (ON <VOLUME>) (UNCAT) (SET) TO <NEW DSNAME>\n                (ON <VOLUME>) (SET) (CATLG/RECATLG/UNCATLG)\n\n                                      OR\n\n         RENAME <PDSNAME> #<MEMBER> (ON <VOLUME>)\n                (ALIAS) TO <NEW MEMBERNAME> (ON <VOLUME>)\n\n         REQUIRED - DSNAME/PDSNAME, TO DSNAME/NEW MEMBERNAME\n         DEFAULTS - NONE\n         ALIAS    - RENAM, RENA, REN\n\n         NOTE:  ALL OPERANDS WILL NOT BE COVERED DUE TO THE\n                REPETITIVE NATURE OF DOING SO.  THE MEMBER\n                MAY BE ENCLOSED IN PARENTHESES, BUT THE PARENS\n                ARE NOT REQUIRED.\n\n)O OPERANDS -\n\n))DSNAME/PDSNAME -\n          MUST BE A DATA SET NAME OF THE TYPE DETAILED UNDER THE\n          HELP ENTRY \"DSNAMES\".\n\n))ON VOLUME -\n          REQUIRED ONLY IF THE GLOBAL VOLUME  PARAMETER  IS  NOT\n          SET.  IF VOLUME=CATLG (LOGON DEFAULT) IS SET, THEN THE\n          ORIGINAL DATASET IS UNCATLG'D.\n\n))SET -\n         USED TO SET THE SAVED PREFIX AND/OR MEMBER GLOBALS.\n\n))CATLG/RECATLG/UNCATLG -\n          THE CATLG/CAT, RECAT, AND UNCAT OPERANDS WORK THE SAME\n          WAY AS THEIR RESPECTIVE COMMANDS.\n\n))ALIAS -\n          THE ALIAS OPERAND WILL TELL WYLBUR THAT THE NEW MEMBER\n          NAME SPECIFIED IS TO BE ADDED AS AN ALTERNATIVE WAY OF\n          REFERRING TO THE PDS MEMBER NAMED.\n\n=REPLACE=REPLAC=REPLA=REPL=REP=R\n)F FUNCTION -\n\n          THE WYLBUR REPLACE COMMAND ALLOWS YOU TO  REPLACE  THE\n          CONTENTS OF ANY SPECIFIED RANGE OF LINES IN THE ACTIVE\n          FILE.\n\n)X SYNTAX -\n\n         REPLACE <RANGE> (LIST OPTIONS) (DITTO)\n\n         REQUIRED - RANGE\n         DEFAULTS - NONE\n         ALIAS    - REPLAC, REPLA, REPL, REP, R\n\n          NOTES:  AS  ALTERNATE  METHOD,  YOU  MAY  REPLACE  THE\n          CONTENTS  OF  A SINGLE LINE BY GIVING THE LINE NUMBER,\n          FOLLOWED BY A SINGLE BLANK, AND THEN THE NEW  CONTENTS\n          OF THE LINE.  THE \"LIST\" OR \"NOTEXT\" OPTIONS WILL LIST\n          THE LINE BEFORE IT IS REPLACED WHICH GIVES YOU TIME TO\n          ABORT  THE  COMMAND  BY PRESSING THE (CR).  DO NOT USE\n          \"L\" FOR \"LIST\"  AS  THIS  PARAMETER;  \"L\"  STANDS  FOR\n          \"LAST\".\n\n)O OPERANDS -\n\n))RANGE -\n          SPECIFIES THE RANGE OF LINES  FOR  WHICH  WYLBUR  WILL\n          PROMPT  WITH  SUCCESSIVE LINE NUMBERS IN THE SPECIFIED\n          <RANGE>, AND YOU MAY TYPE IN THE  NEW  CONTENTS  AFTER\n          EACH  PROMPT.   A  (CR)  CAUSES  THAT  LINE  NOT TO BE\n          REPLACED.  THIS IS CONTINUED UNTIL THE RANGE OF  LINES\n          IS EXHAUSTED.\n\n))LIST OPTIONS -\n          ANY OF THE OPTIONS VALID UNDER THE  LIST  COMMAND  ARE\n          VALID OPTIONS.\n\n))DITTO -\n          DITTO CAUSES REPLY GIVEN TO THE  FIRST  PROMPT  TO  BE\n          USED TO REPLACE ALL LINES IN THE RANGE.\n\n=RESTORE=RESTOR=RESTO=REST=RES\n)F FUNCTION -\n\n          THE WYLBUR RESTORE COMMAND IS USED TO MOVE THE CURRENT\n          EXEC FILE TO  THE  ACTIVE  FILE.   YOU  MAY  NOT  MAKE\n          MODIFICATIONS  DIRECTLY  TO  THE  EXEC  FILE.  TO MAKE\n          MODIFICATIONS, YOU MUST FIRST MOVE THE  EXEC  FILE  TO\n          THE ACTIVE FILE.\n\n)X SYNTAX -\n\n         RESTORE (CLEAR)\n\n         REQUIRED - NONE\n         DEFAULTS - NONE\n         ALIAS    - RESTOR, RESTO, REST, RES\n\n)O OPERAND -\n          SPEICIFICATION OF THE CLEAR OPERAND CLEARS THE  ACTIVE\n          FILE  PRIOR TO MOVING THE EXEC FILE IN.  IF YOU DO NOT\n          SPECIFY THIS OPERAND AND THE ACTIVE FILE CONTAINS DATA\n          WYLBUR WILL PROMPT WITH \"OK TO CLEAR?  \".   THE  VALID\n          REPLIES  TO  THE  PROMPT  ARE \"YES\" OR \"OK\", ANY OTHER\n          REPLY WILL TERMINATE THE COMMAND  AND  RETURN  YOU  TO\n          COMMAND MODE.\n\n=RUN\n)F FUNCTION -\n          THE WYLBUR RUN COMMAND ALLOWS YOU TO  PUT  THE  ACTIVE\n          FILE INTO THE JOB INPUT STREAM OF THE COMPUTER.\n\n)X SYNTAX -\n\n         RUN (RANGE) (LIST OPTIONS)\n\n         REQUIRED - NONE\n         DEFAULTS - RANGE=ALL, ACTIVE\n         ALIAS    - NONE\n\n)O OPERANDS -\n\n))RANGE -\n          IF SPECIFIED, TELLS WYLBUR TO SUBMIT  ONLY  THE  LINES\n          SPECIFIED.   DEFAULT  IS  ALL  LINES.  ALL JCL THAT IS\n          REQUIRED TO RUN THE JOB MUST BE CONTAINED IN THE FILE.\n          THE FIRST LINE IN THE RANGE MUST BE A  JOB  CARD.   IF\n          THE  RANGE  CONTAINS MULTIPLE JOB CARDS, MULTIPLE JOBS\n          ARE SUBMITTED.\n\n))LIST OPTIONS -\n          ANY OF THE OPTIONS AVAILABLE UNDER  THE  LIST  COMMAND\n          ARE  VALID FOR THE \"RUN\" COMMAND EXCEPT THE \"SQUASHED\"\n          OPTION.  THE OPTION NUMBERED OR INTEGER WILL CAUSE THE\n          LINE NUMBERS OF THE RANGE TO APPEAR IN THE JOB  OUTPUT\n          AS SEQUENCE NUMBERS.  USING \"UNN\" WILL CAUSE WYLBUR TO\n          SUBMIT ONLY THE DATA AND IS RECOMMENDED BECAUSE OF THE\n          FASTER LISTING WHEN DOING THE \"OUT\" COMMAND.\n=SAVE=S=SA=SAV\n)F FUNCTION -\n          THE WYLBUR SAVE COMMAND IS USED TO SAVE USER DATA FROM\n          THE ACTIVE FILE IN AN EXTERNAL FILE (DATA SET).\n\n)X SYNTAX -\n\n         SAVE (*/<DSNAME>) (ON <VOLUME>/CATLG) (SCRATCH/REPLACE)\n              (UNN/NUMBERED/INTEGER) (CATLG/RECATLG/UNCATLG)\n              (CLEAR/CLR) (EDIT/LRECL='NNN'/CARD/PRINT)\n              (LINES <RANGE>) (SET/NOSET) (N)\n              (SEQFLD=(END/POS ',LEN')) (INTEGER/INT)\n\n         REQUIRED - DSNAME\n         DEFAULTS - ON CATLG, EDIT, NOSET, UNN\n         ALIAS    - SAV, SA, S\n\n         NOTE ----- THE OPTIONAL OPERANDS ARE KEYWORD TYPE AND\n                    MAY APPEAR IN ANY SEQUENCE. DSNAME IS THE\n                    ONLY REQUIRED OPERAND.\n\n)O OPERANDS -\n\n))DSNAME -\n          REQUIRED OPERAND THAT SPECIFIES THE NAME  UNDER  WHICH\n          YOU  WANT THE DATA STORED.  SHOULD CONFORM TO THE DATA\n          SET  NAMING  CONVENTIONS  OUTLINED  UNDER  HELP  ENTRY\n          \"DSNAMES\".\n\n\n))ON <VOLUME>/CATLG -\n\n          ON <VOLUME> SPECIFIES THE VOLUME  NAME  ON  WHICH  THE\n          DATA  SET  IS TO BE SAVED.  IT IS OPTIONAL IF YOU HAVE\n          PREVIOUSLY ENTERED A VOLUME NAME VIA THE \"SET  VOLUME\"\n          COMMAND.   AS  WITH  \"USE\", \"ON <VOLUME>\" SPECIFIED IN\n          THE \"SAVE\" COMMAND OVERRIDES ANY PREVIOUSLY SET VOLUME\n          NAME (INCLUDING THE DEFAULT  OF  VOLUME=CATLG  SET  AT\n          LOGON  TIME).   \"ON  CATLG\"  MAY BE USED IN THE \"SAVE\"\n          COMMAND ONLY IF THE DATA SET IS A CATALOGED PDS OR  IF\n          THE  DATA  SET  TO  BE SAVED IS TO REPLACE A CATALOGED\n          SEQUENTIAL DATA SET ON THE SAME VOLUME.  \"ON CATLG\" IS\n          ASSUMED IT THE <DSNAME> IS A STANDARD  WYLBUR  LIBRARY\n          AND  THE  VOLUME  INFORMATION IS NOT SUPPLIED FROM ANY\n          SOURCE.\n\n\n))SCRATCH/REPLACE -\n          WYLBUR WILL NOT PERMIT YOU TO \"SAVE\" A DATA SET  OR  A\n          MEMBER  OF  A  PDS  WITH  A DUPLICATE NAME ON THE SAME\n          VOLUME OR IN THE SAME PDS.  SHOULD YOU ATTEMPT  TO  DO\n          THIS,  WYLBUR  ASKS  IF  YOU  WANT THE OLD DATA SET OR\n          MEMBER TO BE REPLACED WITH THE NEW DATA.  IF  YOU  ARE\n          AWARE  OF  THIS  CONDITION  WHEN  YOU ENTER THE \"SAVE\"\n          COMMAND, YOU MAY PRE-EMPT THIS DIALOGUE BY  SPECIFYING\n          \"SCRATCH\" OR \"REPLACE\".  WHEN A SEQUENTIAL DATA SET IS\n          REPLACED, THE OLD DATA SET IS SCRATCHED BEFORE THE NEW\n          DATA  IS  SAVED,  IF  YOU SPECIFY \"SCRATCH\".  HOWEVER,\n          WHEN A PDS MEMBER IS REPLACED, THE NEW MEMBER IS ADDED\n          TO THE PDS AND THE DIRECTORY IS UPDATED AFTER THE  NEW\n          MEMBER HAS BEEN WRITTEN.\n\n          NOTE.....THE  WORDS  \"SCRATCH  AND  REPLACE\"  MAY   BE\n          SHORTENED TO \"SCR\" AND \"REP\".\n\n))NUMBERED/NUM/INTEGER -\n          WHEN A FIXED BLOCK DATA SET IS SAVED, WYLBUR  NORMALLY\n          DOES  NOT PLACE LINE NUMBERS IN THE RECORDS.  WHEN THE\n          FILE IS USED AGAIN, LINE NUMBERS ARE  GENERATED.   THE\n          \"NUMBERED/NUM\"  OPTION SPECIFIES THAT WYLBUR TYPE LINE\n          NUMBERS  SHOULD  BE  SAVED  IN  THE   SEQUENCE   FIELD\n          (DEFAULTS  TO  COLUMNS 73/80 UNLESS THE SEQFLD OPERAND\n          IS USED).  THE \"INTEGER/INT\" OPTION TELLS WYLBUR  THAT\n          THE LINE NUMBERS SHOULD BE INTEGER TYPE NUMBERS.\n\n))CATLG/RECATLG/UNCATLG -\n          YOU MAY SPECIFY THAT THE SYSTEM CATALOG THE  DATA  SET\n          AFTER  IT  HAS  BEEN  SAVED SO THAT YOU DO NOT HAVE TO\n          REMEMBER THE VOLUME NAME ON WHICH IT HAS  BEEN  SAVED.\n          THIS  IS  DONE  WITH  THE  \"CATLG\"  OPERAND.   IF  THE\n          SPECIFIED DATA SET NAME ALREADY EXISTS IN THE CATALOG,\n          YOU  ARE  INFORMED BY WYLBUR.  IF YOU WANT TO SAVE THE\n          DATA SET ON A VOLUME OTHER THAN THE ONE ON WHICH IT IS\n          CATALOGED, YOU MUST USE  THE  \"RECATLG\"  OPERAND.   IF\n          THIS IS THE CASE, THE SYSTEM WILL CATALOG THE DATA SET\n          ON  THE  NEW  VOLUME  WHETHER  OR  NOT  IT  IS ALREADY\n          CATALOGED.  \"RECATLG\" WILL NOT SCRATCH  THE  OLD  DATA\n          SET,  IT  IS  ONLY UNCATALOGED.  \"CATLG\" AND \"RECATLG\"\n          ARE IGNORED WHEN  \"ON  CATLG\"  IS  SPECIFIED  FOR  THE\n          VOLUME.   YOU MAY UNCATALOG THE DATA SET AFTER SAVE BY\n          SPECIFYING \"UNCATLG\".  THIS IS NOT RECOMMENDED BECAUSE\n          UNCATALOGED DATA SETS ARE SCRATCHED AFTER THREE DAYS.\n\n))CLEAR -\n          IF THIS OPERAND  IS  SPECIFIED,  THE  ACTIVE  FILE  IS\n          CLEARED AFTER THE SAVE OPERATION IS COMPLETE.\n\n))EDIT/LRECL='NNN'/CARD/PRINT -\n          THIS OPERAND IS KNOWN  AS  THE  \"FORMAT  OPERAND\"  AND\n          SPECIFIES  THE  FORM IN WHICH THE DATA IS TO BE SAVED.\n          \"EDIT\" IS THE DEFAULT VALUE FOR THE SAVE COMMAND.  THE\n          OTHER  OPTIONS  ARE  PERMITTED  WHEN  YOU  SPECIFY   A\n          SEQUENTIAL  DATA SET BUT IF A PDS MEMBER IS SPECIFIED,\n          A WARNING MESSAGE WILL ASK IF YOU WANT THE  FORMAT  OF\n          THE  ENTIRE  PDS  CHANGED  IF NOT SPECIFIED CORRECTLY.\n          ANY RESPONSE OTHER THAN \"YES\" OR \"OK\" WILL  ABORT  THE\n          SAVE.    THIS   IS   BECAUSE   ALL   MEMBERS   IN  THE\n          PRE-ALLOCATED PDS ARE IN THE SAME FORMAT.  CARD IS  AN\n          ABBREVIATED  WAY  OF  SAYING  LRECL=80,  PRINT  IS  AN\n          ABBREVIATED  WAY  OF  SAYING LRECL=133.  \"CARD\" FORMAT\n          (LRECL=80) IS ASSUMED IF NUMBERED, INTEGER, SEQFLD, OR\n          NOPOINT IS SPECIFIED WITHOUT ANY EXPLICIT FORMAT.\n\n))LINES <RANGE> -\n          YOU MAY \"SAVE\" ONLY A PORTION OF THE  ACTIVE  FILE  BY\n          SPECIFYING AN EXPLICIT RANGE WITH THE LINES OPERAND.\n\n))SET/NOSET -\n          \"NOSET\" IS THE DEFAULT AND TELLS WYLBUR NOT  TO  RESET\n          THE  PREFIX  AND  MEMBER FIELDS.  IF YOU USE THE \"SET\"\n          OPTION WYLBUR WILL RETAIN THE PREFIX AND MEMBER FIELDS\n          USED IN THE COMMAND.\n\n))N -\n          IF ANY FORMAT OTHER  THAN  \"EDIT\"  IS  SPECIFIED,  THE\n          RECORDS   ARE  SAVED  IN  A  FIXED  BLOCKED  DATA  SET\n          (RECFM=FB).  IF THE RECORDS IN  THE  ACTIVE  FILE  ARE\n          SHORTER   THAN   THE   SPECIFIED   LRECL,   THEY   ARE\n          RIGHT-PADDED  WITH  BLANKS.  IF THE RECORDS ARE LONGER\n          THAT THE SPECIFIED LRECL, THEY ARE  TRUNCATED  ON  THE\n          RIGHT.   IN  EITHER  CASE,  THE BLOCKING FACTOR MAY BE\n          SPECIFIED AS (N) IN THE SAVE COMMAND; IN  OTHER  WORDS\n          THE  DATA SET BLKSIZE WILL BE \"LRECL\" TIMES (N), WHERE\n          \"LRECL\"  IS  THE  'NNN'   VALUE   SPECIFIED   IN   THE\n          \"LRECL=NNN\" OPERAND.\n\n))SEQFLD=(END/POS',LEN') -\n          THE SEQFLD  OPERAND  IS  USED  TO  CHANGE  THE  NORMAL\n          POSITION  OR  LENGTH  OF THE LINE NUMBERS IN THE SAVED\n          RECORDS.   THE  NORMAL  POSITION  IS  THE  LAST  EIGHT\n          POSITIONS OF EACH RECORD (SEQFLD=(END,8)).  ANY COLUMN\n          POSITION (POS) AND ANY LENGTH (LEN) LESS THAN  10  CAN\n          BE  SPECIFIED.  LINE NUMBERS ARE TRUNCATED ON THE LEFT\n          TO THE SIZE SPECIFIED WITHOUT  CHECKING  FOR  LOSS  OF\n          DIGITS.   THE PARENTHESES CAN BE OMITTED IF THE LENGTH\n          IS NOT CHANGED.\n\n))INTEGER/INT -\n          THE \"NOPOINT\"  OPERAND  ASSUMES  THAT  THE  \"NUMBERED\"\n          OPERAND  HAS  BEEN SPECIFIED AND TELLS WYLBUR THAT THE\n          LINE NUMBERS SHOULD BE PUT IN THE  RECORDS  WITHOUT  A\n          DECIMAL POINT OR ZERO SUPPRESSION.\n\n=SCRATCH=SC=SCR=SCRA=SCRAT=SCRATC\n)F FUNCTION -\n\n          THE WYLBUR SCRATCH COMMAND ALLOWS YOU TO  SCRATCH  ANY\n          <EXTERNAL FILE> THAT BELONGS TO YOU.\n\n)X SYNTAX -\n\n         SCRATCH <DSNAME> (ON <VOLUME>/CATLG) (SET/NOSET)\n                 (UNCATLG) (PDS)\n\n         REQUIRED - DSNAME\n         DEFAULTS - ON CATLG, NOSET\n         ALIAS    - SCRATC, SCRAT, SCRA, SCR, SC\n\n)O OPERANDS -\n\n))DSNAME -\n         THE DATA SET NAME TO BE SCRATCHED.\n))ON VOLUME/CATLG -\n          IF SPECIFIED, TELLS WYLBUR WHERE TO LOOK FOR THE  DATA\n          SET.\n))SET/NOSET -\n          IF \"SET\" IS SPECIFIED, PREFIX AND MEMBER ARE RESET  TO\n          THE <DSNAME>.  NOSET IS DEFAULT.\n))UNCATLG -\n          THIS OPERAND TELLS WYLBUR TO UNCATALOG  THE  DATA  SET\n          AND  MUST  BE  SPECIFIED  IF \"ON VOLUME\" GLOBAL IS NOT\n          EQUAL TO CATLG.\n))PDS -\n          ONLY A SEQUENTIAL DATA SET OR MEMBERS  OF  A  PDS  CAN\n          NORMALLY  BE  SCRATCHED.   IF  YOU  WANT TO SCRATCH AN\n          ENTIRE PDS, YOU MUST SPECIFY THE PDS OPERAND.  IF THIS\n          IS NOT SPECIFIED AND THE <DSNAME> IS A PDS,  A  PROMPT\n          WILL  BE  GIVEN  TO ASK YOU IF YOU WANT THE ENTIRE PDS\n          SCRATCHED.  ANY RESPONSE OTHER THAN \"YES\" OR \"OK\" WILL\n          ABORT THE COMMAND AND RETURN YOU TO THE COMMAND MODE.\n\n=SET\n)F FUNCTION -\n\n          THE WYLBUR SET COMMAND IS  USED  TO  SET  THE  VARIOUS\n          GLOBALS  HAVING  TO DO WITH OVERALL, GENERAL OPERATION\n          AND THOSE THAT SPECIFICALLY  DEAL  WITH  EXECUTION  OF\n          EXEC FILES.  BOTH SETS OF GLOBALS THAT MAY BE SET WITH\n          THIS COMMAND ARE COVERED IN THIS ENTRY.  THOSE DEALING\n          WITH  THE  EXEC  FILES  ARE  SET  WITH  THE \"SET EXEC\"\n          COMMAND.  THE ONLY WAY WYLBUR DISTINGUISHES IS BY  THE\n          \"EXEC\" KEYWORD.  ANY GLOBAL THAT IS SET WITH THE \"SET\"\n          COMMAND  MAY  BE  DISPLAYED BY USING THE CORRESPONDING\n          \"SHOW\" COMMAND.  BOTH THE \"SET\" AND  \"SHOW\"  HAVE  THE\n          SAME SYNTAX.\n\n)X SYNTAX -\n\n         SET         (USER=UUUUU) (VOLUME=XXXXXX) (LENGTH=III)\n                     (TERSE/VERBOSE) (DELTA=NNN) (BREAK/NOBREAK)\n                     (CRT/NOCRT) (ESC 'K') (MEMBER=CCCCCCCC)\n                     (NAME=BBBBBBBB) (PREFIX <STRING>) (SKIP C)\n                     (TABS) (UPLOW/UPPER) (CURRENT <LINENO>)\n                     (RESCAN=N)\n\n         SET EXEC    (CURRENT <LINENO>) (TERSE/VERBOSE) (LOG/NOLOG)\n\n         REQUIRED - NONE\n         DEFAULTS - NONE\n         ALIAS    - NONE\n\n)O OPERANDS -\n\n))USER=UUUUU -\n          USED TO CHANGE THE FIRST QUALIFIER  (USERID)  THAT  IS\n          USED  AS  A DEFAULT WHEN \"USING\" A DATA SET.  TO RESET\n          THIS GLOBAL VALUE TO THE ORIGINAL \"SIGNON\" VALUE,  MAY\n          BE  DONE  WITH \"SET USER=<SIGNON VALUE>\" OR \"SET USER\"\n          WITH NO USERID SPECIFIED.\n\n))VOLUME=XXXXXX -\n          THE DEFAULT VALUE ASSIGNED THIS GLOBAL AT SIGNON  TIME\n          IS  \"VOLUME=CATLG\".  THIS GLOBAL TELLS WYLBUR WHERE TO\n          LOOK FOR  DATASETS  DURING  A  \"USE\"  COMMAND  (UNLESS\n          SPECIFICALLY  OVERRIDDEN)  OR  WHERE TO PLACE DATASETS\n          DURING    A    \"SAVE\"    OPERATION.      NOTE.........\n          \"VOLUME=CATLG\" IS AN INVALID VOLUME AND CARE SHOULD BE\n          TAKEN  TO  EXPLICITLY  SPECIFY  A  VALID VOLUME DURING\n          SAVING OPERATIONS.\n\n))LENGTH=III -\n          THE LENGTH IS THE NUMBER OF CHARACTERS WHICH MAY BE IN\n          ANY LINE  OF  TEXT.   IF  YOU  TYPE  A  LINE  OF  TEXT\n          CONTAINING MORE THAN THIS NUMBER OF CHARACTERS, WYLBUR\n          WILL  ACCEPT THE LINE BUT ISSUE A WARNING MESSAGE THAT\n          YOU HAVE EXCEEDED THE \"LENGTH\" LIMIT.   \"III\"  MAY  BE\n          ANY INTEGER BETWEEN 1 AND 133 INCLUSIVE.  LENGTH HAS A\n          SIGNON DEFAULT OF 72.\n\n))TERSE/VERBOSE -\n         SET TERSE/VERBOSE\n\n          THE \"SET TERSE\" COMMAND SHORTENS  THE  WYLBUR  COMMAND\n          PROMPT  \"COMMAND?\" TO \"?\".  IN ADDITION, ALL <DSNAMES>\n          WILL BE LISTED IN AN ABBREVIATED FORM INSTEAD  OF  THE\n          FULL  <DSNAME> DURING A \"SHOW DSNAMES\" OPERATION.  ALL\n          COMMANDS CONTAINING THE PRE-PROCESSOR ESCAPE  OR  SKIP\n          CHARACTERS WILL NOT HAVE THE PROCESSED COMMAND LISTED.\n          THE \"SET VERBOSE\" COMMAND WILL RESUME THE VERBOSE MODE\n          WHICH  IS  THE  REVERSE OF \"TERSE\" MODE.  \"VERBOSE\" IS\n          THE DEFAULT AT SIGNON TIME.\n\n         SET EXEC TERSE/VERBOSE\n\n          THE \"SET EXEC TERSE\" CAN BE USED TO GOVERN THE  FORMAT\n          OF  THE  MESSAGES  WHICH  APPEAR  ON  THE  TERMINAL IN\n          RESPONSE TO AN  \"EXEC\"  COMMAND.   \"TERSE\"  SUPPRESSES\n          REPRINTING OF EXEC LINES WITH PRE-PROCESSOR \"SKIP\" AND\n          \"ESC\" CHARACTERS.  \"VERBOSE\" IS THE SIGNON VARIABLE.\n\n))DELTA=NNN -\n          SPECIFYING \"DELTA=NNN\" SETS THE DEFAULT VALUE  OF  THE\n          LINE  NUMBER  INCREMENT GLOBAL, \"DELTA\".  \"NNN\" MAY BE\n          ANY  VALUE  BETWEEN  0.001  AND  99999.999  INCLUSIVE.\n          \"DELTA\" HAS A SIGNON VALUE OF 1.000.\n\n))CRT/NOCRT -\n          THE \"SET CRT\" AND \"SET NOCRT\" COMMANDS ARE LEGAL  ONLY\n          FOR  CRT-TYPE TERMINALS (3277 AND OMRON), AND WILL SET\n          OR UNSET THE PAGING OPTION DESCRIBED BELOW.\n\n          WHEN \"NOCRT\" IS IN EFFECT AND A  LISTING  OF  A  RANGE\n          LONGER  THAN THE SCREEN SIZE (25 LINES) IS BEING DONE,\n          THE LISTING WILL FLOW OFF THE TOP OF THE SCREEN  UNTIL\n          THE  LISTING  IS  OVER.   WHEN  \"CRT\"  IS  IN  EFFECT,\n          HOWEVER, A LISTING WILL PAUSE WHEN THE SCREEN HAS BEEN\n          FILLED  AND  WYLBUR  WILL PROMPT WITH A COLON (:).  AT\n          THIS POINT YOU MAY RESPOND WITH THE FOLLOWING:\n\n                   (CR) -- LISTING IS CONTINUED UNTIL THE SCREEN IS\n                           FILLED AGAIN.\n                   (ATTN) -- THE COMMAND IS ABORTED.\n                   A 3-DIGIT NUMBER, FOLLOWED BY (CR) -- THIS WILL\n                   CONTINUE LISTING THAT NUMBER OF LINES BEFORE THE\n                   NEXT (:) PROMPT.  IF THE NUMBER IS GREATER THAN 256\n                   THE NUMBER OF LINES LISTED WILL BE THE REMAINDER OF\n                   DIVIDING THAT NUMBER BY 256.  THE NUMBER MUST BE AN\n                   INTEGER LESS THAN 1000.\n\n\n))ESC 'K' -\n          \"SET  ESCAPE  'K'\"  SETS  THE   PRE-PROCESSOR   ESCAPE\n          CHARACTER   WHICH   IS  THE  TRIGGER  THAT  TELLS  THE\n          PRE-PROCESSOR  THAT  IT  HAS  WORK  TO  DO.   THE  'K'\n          CHARACTER DOES NOT  HAVE  TO  BE  ENCLOSED  IN  QUOTES\n          UNLESS  IT  IS  A  SPECIAL  CHARACTER (E.G.  =,()'\" OR\n          BLANK).  \"SET  ESCAPE  (CR)\"  WITH  NO  'K'  CHARACTER\n          OPERAND  UNSETS  THE  ESCAPE  CHARACTER  AND TURNS OFF\n          PRE-PROCESSOR SCANNING.\n\n))MEMBER=CCCCCCCC -\n          \"SET MEMBER=CCCCCCCC\"  IS  USED  TO  SET  THE  DEFAULT\n          MEMBER NAME THAT WILL BE USED TO FORM A <DSNAME>.  THE\n          <MEMBER  NAME>  SPECIFIED MAY NOT EXCEED 8 CHARACTERS.\n          IF THE <MEMBER NAME> IS OMITTED, IT IS  SET  TO  NULL.\n          AT  SIGNON,  IT  IS SET TO NULL.  THE CURRENT VALUE OF\n          \"MEMBER\" CAN BE SHOWN AT ANY TIME WITH  \"SHOW  MEMBER\"\n          OR \"SHOW NAME\".\n\n))NAME=BBBBBBBB -\n          THE \"SET NAME\" COMMAND ALLOWS YOU TO SET THE VALUES OF\n          THE USER, PREFIX, AND/OR MEMBER  FIELDS  (GLOBALS)  IN\n          ONE  COMMAND.  THE <DSNAME> IS FORMED IN THE USUAL WAY\n          EXCEPT THAT THE DEFAULT \"PREFIX\" IS NULL  RATHER  THAN\n          \"LIB\"  (SEE \"DSNAMES\" AND THE DESCRIPTION OF THE \"USE\"\n          COMMAND).  \"SHOW NAME\" IS USED TO DISPLAY THE  CURRENT\n          VALUES OF USER, PREFIX, AND MEMBER.\n\n))PREFIX <STRING> -\n          \"SET PREFIX <STRING>\"  COMMAND  IS  USED  TO  SET  THE\n          PREFIX  THAT  CAN  BE USED IN BUILDING A <DSNAME>.  IN\n          THIS COMMAND <STRING> IS NOT ENCLOSED IN  QUOTES.   IF\n          <STRING>  IS  OMITTED,  THE PREFIX IS SET TO NULL.  AT\n          SIGNON, THE PREFIX IS SET TO NULL.\n\n          \"SET  PREFIX  *<STRING>\"  SETS   THE   PREFIX   TO   A\n          CONCATENATION  OF  THE  OLD VALUE AND <STRING>.  \"SHOW\n          PREFIX\" OR \"SHOW NAME\" MAY BE USED TO SHOW THE CURRENT\n          VALUE OF \"PREFIX\".\n\n))SKIP C -\n          THE  \"SET  SKIP  C\"  COMMAND  IS  USED  TO   SET   THE\n          PRE-PROCESSOR   SKIP   CHARACTER.   THE  \"C\"  MUST  BE\n          ENCLOSED IN QUOTES IF THE CHARACTER USED IS A  SPECIAL\n          CHARACTER (E.G., =,()'\" OR BLANK).\n\n))TABS -\n          TABS MAY BE SET BY SPECIFYING THE COLUMN NUMBERS  THAT\n          TABS  ARE TO BE SET, SUCH AS \"SET TABS 10 30 55\".  YOU\n          MAY ALSO  ALLOW  WYLBUR  TO  PROMPT  YOU  WITH  COLUMN\n          NUMBERS  IN  WHICH  YOU SPACE OVER AND ENTER A 1.  SEE\n          THE HELP  ENTRY  FOR  TABS  FOR  COMPLETE  DETAILS  ON\n          SETTING TABS.\n\n))UPLOW/UPPER -\n          THE \"SET UPLOW\" COMMAND CONTROLS HOW WYLBUR  PERCEIVES\n          THE  DATA THAT IS COMING IN.  THE DEFAULT AT SIGNON IS\n          THE DEFAULT CASE AT SIGNON IS \"UPPER\" AND USE OF  THIS\n          COMMAND  IS  THE ONLY WAY TO CHANGE THAT .....WITH ONE\n          EXCEPTION....IF YOU  USE  THE  \"CHANGE  TO  UPPER\"  OR\n          \"CHANGE  TO LOWER\" OPERANDS OF THE CHANGE COMMAND, THE\n          CASE SETTING IS AUTOMATICALLY SET TO \"UPLOW\".\n\n))CURRENT <LINENO> OR * -\n          \"SET CURRENT\" SETS THE <CURRENT LINE POINTER>  TO  THE\n          <LINENO>  SPECIFIED.   \"SET  CURRENT 80\" WOULD SET THE\n          <CURRENT LINE POINTER> OF THE ACTIVE FILE TO 80.   USE\n          OF  THE  KEYWORD  \"EXEC\"  SETS  THE  EXEC FILE POINTER\n          INSTEAD OF THE ACTIVE FILE.\n\n))RESCAN -\n          \"SET  RESCAN\"   SETS   THE   NUMBER   OF   TIMES   THE\n          PRE-PROCESSOR  WILL  RESCAN  A  LINE  CONTAINING  SKIP\n          CHARACTERS.    SEE  THE  HELP  ENTRIES  (PREPROC1  AND\n          PREPROC2) FOR A COMPLETE EXPLANATION OF OPERATIONS.\n\n))LOG/NOLOG -\n          \"SET NOLOG\" SUPPRESSES PRINTING OF EACH  LINE  IN  THE\n          EXEC  FILE  AS  IT  IS EXECUTED.  DEFAULT AT SIGNON IS\n          \"LOG\".\n\n=SHOW=SHO=SH\n)F FUNCTION -\n\n          THE WYLBUR SHOW COMMAND IS USED TO SHOW THE VALUES  OF\n          THE  DEFAULTS THAT ARE SET WITH THE \"SET\" COMMAND.  IN\n          ADDITION TO THE VALUES OF THE DEFAULTS, YOU  MAY  ALSO\n          USE ANY OF THE BELOW LISTED \"SHOW COMMANDS\" TO LOOK AT\n          VARIOUS  OTHER THINGS THAT ARE COMMONLY OF INTEREST TO\n          A USER DURING A SESSION.  BECAUSE  OF  THE  REPETITIVE\n          NATURE  OF  LISTING ALL OF THE OPTIONS AVAILABLE, THIS\n          ENTRY WILL NOT LIST THE OPTIONS AGAIN.  SEE  THE  HELP\n          ENTRY  FOR  THE SET COMMAND FOR ALL OPTIONS.  THE SHOW\n          COMMAND WILL SHOW THE VALUES OF ALL OF THE OPTIONS  OF\n          THE SET COMMAND.\n\n         SHOW CATLG\n\n          IN A DEPARTURE FROM THE NORMAL HELP FORMAT, THE SYNTAX\n          OF THIS COMMAND IS:\n\n         SHOW CATLG (FOR */INDEX PATTERN) (USER) (UNCATLG)\n                    (SET/NOSET) (NOTYPE) (FROM/EXCLUED <STRING1>)\n                    (THRU/TO <STRING2>)\n\n          THE SHOW CATLG COMMAND IS USED TO DISPLAY  A  LIST  OF\n          DSNAMES  AND/OR  INDEX  POINTERS  BELOW  A GIVEN INDEX\n          NODE.  ONLY ONE LEVEL OF INDEX NAME MAY BE LISTED IN A\n          SINGLE COMMAND.  THE  \"INDEX  PATTERN\"  IN  THE  \"FOR\"\n          OPERAND  SPECIFIES  THE  VALID  LEVEL OF INDEX USED TO\n          SEARCH THE CATALOG.  ONLY THOSE  NAMES  FOUND  AT  THE\n          NEXT  LEVEL OF INDEX BELOW THE PATTERN WILL BE LISTED.\n          IF THE \"FOR\" OPERAND IS OMITTED, THE \"SAVED  USER\"  IS\n          USED TO FORM THE INDEX PATTERN.  EXAMPLE:\n\n                   COMMAND?  SHOW CAT FOR $SYS1 FROM GHI TO STU (CR)\n\n          YOU WILL NOTICE THAT IN THE ABOVE  EXAMPLE,  THE  WORD\n          \"CATLG\"  MAY  BE  ABBREVIATED  TO \"CAT\".  THIS COMMAND\n          WILL LIST ALL  DATASETS  WITH  A  FIRST  QUALIFIER  OF\n          \"SYS1\"  THAT  HAVE A SECOND QUALIFIER WITHIN THE RANGE\n          OF \"GHI\" TO, BUT NOT INCLUDING THOSE WITH \"STU\".\n\n          NORMALLY EACH ENTRY ALSO SHOWS THE TYPE OF  ENTRY  AND\n          OTHER PERTINENT INFORMATION FOR THAT ENTRY SUCH AS THE\n          VOLUME NAME ON DATA SET ENTRIES.  THIS INFORMATION MAY\n          BE   SUPPRESSED   WITH   THE  \"NOTYPE\"  OPERAND.   THE\n          \"UNCATLG\"  OPTION  LISTS  EVERY  DATA  SET  NAME  THAT\n          BELONGS TO YOU AND ASKS IF IT SHOULD BE  UNCATALOGUED.\n          ALL  OTHER  OPERANDS ARE SIMILAR TO THE \"SHOW DSNAMES\"\n          COMMAND (LISTED BELOW).\n\n         SHOW COLUMNS\n\n          THIS COMMAND WILL PRODUCE  A  LINE  CONTAINING  COLUMN\n          NUMBERS.   IT  IS  USUALLY USED TO DECIDE WHERE TO SET\n          THE  TABS  OR  WHAT  COLUMNS  TO  SPECIFY  IN  ANOTHER\n          COMMAND.  THERE IS ONLY ONE OPERAND, \"UNNUMBERED/UNN\".\n          USING THIS OPERAND WILL DISPLAY THE  COLUMNS  AS  THEY\n          WOULD  BE  POSITIONED  IN  A  \"LIST UNN\" COMMAND.  THE\n          NUMBERS GO FROM 1 TO 9, THEN AN  ALPHABETIC  CHARACTER\n          WHERE A=10,B=20,C=30...M=130.\n\n         SHOW DATE\n\n          THIS  COMMAND  DISPLAYS  THE  DATE  IN  TWO  FORMS  --\n          MM/DD/YY AND THE JULIAN DATA -- AS WELL AS THE TIME OF\n          DAY.\n\n         SHOW DIRECTORY/DIR\n\n          THE SHOW DIRECTORY COMMAND PRODUCES A LIST  OF  MEMBER\n          NAMES  FROM  THE  SPECIFIED  PDS.   THE  FORMAT OF THE\n          COMMAND IS:\n\n                   SHOW DIR (IN/FOR <DSNAME>) (USER UUUUU)\n                            (ON <VOLUME>) (FROM/EXCLUDE (<STRING1>/#))\n                            (THRU/TO (<STRING2>/#)) (SCRATCH/SCR) (ALL)\n                            (SET/NOSET)\n\n          IF THE \"IN <DSNAME>\" OPERAND IS OMITTED,  THE  DEFAULT\n          NAME  \".LIB\"  IS  ASSUMED  FOR  THE CURRENT USER.  THE\n          FROM/THRU/EXCLUED/TO OPERANDS FUNCTION IDENTICALLY  TO\n          THEIR USE IN THE \"SHOW DSNAMES\" (LISTED BELOW) COMMAND\n          EXCEPT THAT IN THIS COMMAND THEY REFER TO MEMBER NAMES\n          RATHER  THAN  DATA SET NAMES.  IF \"#\" IS SPECIFIED FOR\n          EITHER OF THE STRINGS, THE CURRENT VALUE  IN  \"MEMBER\"\n          IS  USED  FOR  THAT  STRING.  THE \"SCRATCH\" OPERAND IS\n          ALSO IDENTICAL TO THE \"SHOW DSNAMES\"  EXCEPT  THAT  IT\n          APPLIES  TO  MEMBERS  INSTEAD OF DATA SETS.  THE \"SET\"\n          OPTION SETS THE \"PREFIX\" TO <DSNAME>  AND  UNSETS  THE\n          \"MEMBER\" NAME.\n\n          USUALLY  ONLY  THE  MEMBER  NAMES  ARE  SHOWN  IN  THE\n          RESULTING LIST.  HOWEVER, IF YOU WANT TO SEE THE OTHER\n          INFORMATION CONTAINED IN THE  PDS  DIRECTORY,  SPECIFY\n          \"ALL\".  THIS CAUSES A HEXADECIMAL DISPLAY OF THE OTHER\n          DIRECTORY INFORMATION:\n\n                   COMMAND?  SHOW DIR ALL\n                   UUUUU.LIB\n                   FILE1 00020102 00003068\n                   FILE2 00030102 00003072\n                   FILE3 00020182 00003068\n\n          THE SEVENTH DIGIT OF THE  FIRST  SET  OF  NUMBERS,  IF\n          EQUAL  TO AN EIGHT, INDICATES AN ALIAS.  FILE3 IS THUS\n          AN ALIAS OF FILE1.  THE  FIFTH  DIGIT  OF  THE  SECOND\n          GROUP  OF  NUMBERS  INDICATES  THE  YEAR  THE FILE WAS\n          CREATED (1973), AND THE NEXT THREE DIGITS INDICATE THE\n          DAY.  FILE1 AND FILE3 WERE CREATED ON THE 68TH DAY  OF\n          1973, FILE2 WAS CREATED ON THE 72ND DAY OF 1973.\n\n         SHOW DSNAMES\n\n          THE \"SHOW DSNAMES\" COMMAND PRODUCES A LIST OF  DSNAMES\n          ON  A  GIVEN VOLUME WHICH SATISFY THE LIMITS SPECIFIED\n          IN THE COMMAND.  THE FORMAT OF THE COMMAND IS:\n\n         SHOW DSNAMES/DSN (LIKE <DSNAME>)\n                          (FROM/EXCLUDE (<STRING1>/*))\n                          (THRU/TO (<STRING2>/*)) (ON <VOLUME>)\n                          (SET/NOSET) (SKIP N) (SCRATCH) (DATED)\n                          (TYPE) (SPACE/SIZE/TRACKS/ALL)\n\n          IF THE COMMAND IS ISSUED WITH NO OPERANDS, WYLBUR WILL\n          LIST ALL DATA SETS WHICH BELONG TO THE USER  SPECIFIED\n          IN  THE  \"SAVED USER\" FIELD.  THE VOLUME WILL BE TAKEN\n          FROM THE \"ON <VOLUME>\" FIELD OR  FROM  THE  LAST  \"SET\n          VOLUME\"  COMMAND  (CATLG IS THE SIGNON DEFAULT AND MAY\n          NOT BE USED).  TO DISPLAY A  LIST  OF  DATA  SETS  FOR\n          OTHER  USERS,  USE THE \"LIKE\" OPTION.  TO LOOK AT DATA\n          SET NAMES FOR ALL USERS ON A VOLUME,  USE  \"LIKE  $  \"\n          WITH NOTHING AFTER THE \"$\".\n\n          THE \"LIKE\" OPERAND IS  USED  TO  CONSTRUCT  A  PATTERN\n          AGAINST  WHICH  ALL  DATA  SET  NAMES ON THE SPECIFIED\n          VOLUME  ARE  MATCHED.   ONLY  THOSE  DATA  SET   NAMES\n          BEGINNING  WITH  THE  SPECIFIED  PATTERN ARE SELECTED.\n          THIS OPERAND IS SIMILAR TO \"DSNAME\" OPERANDS  USED  IN\n          OTHER COMMANDS EXCEPT THAT THERE IS NO \"LIB\" DEFAULT.\n\n          YOU MAY LIMIT THE  RANGE  OF  THE  DISPLAYED  LIST  BY\n          SPECIFYING  \"FROM\"  AND/OR  \"THRU\".   \"FROM <STRING1>\"\n          SPECIFIES THE LOWER LIMIT OF THE  DISPLAYED  LIST  AND\n          \"THRU <STRING2>\" SPECIFIES THE UPPER LIMIT.  EITHER OR\n          BOTH  MAY  SPECIFY  \"*\"  TO  USE  THE  CURRENT  \"SAVED\n          PREFIX\".   IF  \"PREFIX\"  IS  NULL,  AND  \"*\"  ALONE IS\n          SPECIFIED, THE VALUE OF THE STRING IS ALSO NULL; I.E.,\n          THE OPERAND IS IGNORED.  BOTH <STRING1> AND  <STRING2>\n          REFER  TO  THAT PART OF THE DSNAME WHICH APPEARS AFTER\n          THE PATTERN CONSTRUCTED FROM THE \"LIKE\" OPERAND OR THE\n          DEFAULT PATTERN.  THUS, IF \"USER\" IS SET  TO  \"ABCDE\",\n          THE COMMAND:\n\n         SHOW DSNAMES LIKE XYZ FROM F THRU G\n\n         WOULD CAUSE A DISPLAY OF ALL DATA SET NAMES OF THE FORM:\n\n         ABCDE.XYZF....  THROUGH  ABCDE.XYZG....\n\n          YOU MAY REVERSE THIS RANGE BY SPECIFYING THE \"EXCLUDE\"\n          KEYWORD INSTEAD OF \"FROM\".  IN  THAT  CASE,  ALL  DATA\n          SETS  EXCEPT  THOSE  BETWEEN  THE SPECIFIED LIMITS ARE\n          DISPLAYED.\n\n          TO LIST THE NAMES OF DATA SETS OTHER THAN WYLBUR  DATA\n          SETS (THOSE WITH A USERID AS FIRST QUALIFIER), SPECIFY\n          THE  DSNAME  IN  QUOTES  OR  PRECEDED  BY A \"$\" IN THE\n          \"LIKE\" OPERAND.  THE QUOTES  OR  $  PERFORM  THE  SAME\n          FUNCTION AS IN THE DSNAME OPERAND OF OTHER COMMANDS.\n\n          IF THE \"FROM\" OPERAND IS  OMITTED,  THE  RANGE  STARTS\n          FROM  THE  LOWEST  DATA  SET NAME FOUND.  IF \"THRU\" IS\n          OMITTED, THE RANGE EXTENDS THROUGH THE LAST  DATA  SET\n          NAME  FOUND.   IF  BOTH ARE OMITTED, ALL DATA SETS FOR\n          THE DEFAULT PATTERN OR SPECIFIED  \"LIKE\"  PATTERN  ARE\n          LISTED.\n\n          \"SET\" WILL SET THE \"SAVED PREFIX AND MEMBER\" FIELDS TO\n          THOSE SPECIFIED IN THE COMMAND.\n\n          YOU MAY ALSO REQUEST THAT OTHER INFORMATION ASSOCIATED\n          WITH THE DATA SETS BE DISPLAYED.   \"DATED\"  GIVES  YOU\n          THE  DATE  ON  WHICH  THE DATA SET WAS CREATED AND THE\n          DATE ON WHICH IT WAS LAST ACCESSED.  \"SPACE\" MEANS THE\n          AMOUNT OF SPACE OCCUPIED  BY  THE  DATA  SET  AND  THE\n          NUMBER  OF  EXTENTS  IF  NOT  1.   \"TYPE\"  INFORMATION\n          CONSISTS  OF  DSORG  RECFM/LRECL/BLKSIZE  SEPARATED BY\n          SLASHES AS INDICATED.  IF THE VALUES ARE NOT VALID, AN\n          ASTERISK APPEARS INSTEAD.\n\n          IF \"SCRATCH/SCR\" IS SPECIFIED, WYLBUR WILL PROMPT WITH\n          THE WORD \"SCRATCH?\" AND REQUIRE A RESPONSE AFTER EVERY\n          DATA SET NAME LISTED WHICH BELONGS TO  YOU.   A  \"YES\"\n          RESPONSE   WILL  CAUSE  THE  LISTED  DATA  SET  TO  BE\n          SCRATCHED.\n)X\n)O\n=LOGOFF=SIGNOFF=SO=LOGOUT\n)F FUNCTION -\n\n          THE \"LOGOFF\" COMMAND IS NOT VALID UNDER WYLBUR.   THIS\n          WAS  DONE  TO  PREVENT  CONFUSION  ON BEGINNING USERS.\n          THIS HELP  ENTRY  IS  FOR  SIGNOFF  AND  THIS  COMMAND\n          REPLACES LOGOFF.\n\n          THE LOGOUT COMMAND IS ALSO A VALID WAY TO DEPART FROM\n          WYLBUR AND HAS THE SAME SYNTAX AND OPERANDS.\n\n)X SYNTAX -\n\n         SIGNOFF (CLEAR/CLR)\n\n   REQUIRED - NONE\n   DEFAULTS - NONE\n   ALIAS    - SO\n\n)O OPERANDS -\n\n))CLEAR/CLR\n          THIS OPERAND  IS  A  FORM  OF  PROTECTION  TO  PREVENT\n          INADVERTENT LOSS OF DATA.  IF SPECIFIED, WYLBUR THINKS\n          YOU  KNOW  WHAT  YOU ARE DOING AND WILL NOT PROMPT YOU\n          WITH \"OK TO CLEAR?\".  SPECIFICATION OF THIS  PARAMETER\n          WILL RESULT IN CLEARING OF ANY DATA IN THE ACTIVE FILE\n          AND  TERMINATION  OF WYLBUR WITHOUT ANY PROMPTING.  IF\n          THIS OPERAND IS NOT SPECIFIED, WYLBUR WILL PROMPT WITH\n          \"OK TO CLEAR?\" AND ANY RESPONSE OTHER  THAN  \"YES\"  OR\n          \"OK\"  WILL STOP THE TERMINATION PROCESS AND RETURN YOU\n          TO COMMAND MODE.\n=STACK=STAC=STA\n)F FUNCTION -\n          THE WYLBUR STACK  COMMAND  ALLOWS  YOU  TO  PLACE  TSO\n          COMMANDS  ON THE TSO COMMAND STACK FROM WITHIN WYLBUR.\n          SUCH COMMANDS WILL BE EXECUTED WHEN  YOU  DEPART  FROM\n          WYLBUR.\n\n\n)X SYNTAX -\n\n         STACK <COMMAND>\n\n         REQUIRED - A VALID TSO COMMAND\n         DEFAULT  - NONE\n         ALIAS    - STAC, STA\n\n)O OPERANDS -\n))COMMAND -\n         ANY TSO COMMAND.\n\n=SUSPEND=SUSPEN=SUSPE=SUSP=SUS\n)F FUNCTION -\n          THE WYLBUR SUSPEND COMMAND ALLOWS YOU  TO  TEMPORARILY\n          GET  OUT  OF  WYLBUR WITHOUT LOSING ANY DATA OR GLOBAL\n          VALUES SET DURING A SESSION.  WHEN RETURNING TO WYLBUR\n          YOU  WILL  RECEIVE  A   MESSAGE...\"SUSPENDED   SESSION\n          RESTORED\".\n\n)X SYNTAX -\n\n         SUSPEND (CLEAR/CLR)\n\n         REQUIRED - NONE\n         DEFAULT  - NOCLR\n         ALIAS    - SUS, SUSP, SUSPE, SUSPEN\n\n)O OPERAND -\n))CLEAR/CLR -\n         CLEARS THE ACTIVE FILE BEFORE SUSPENSION.\n\n=TABS\n)F FUNCTION -\n\n          TABS MAY BE USED WITH  WYLBUR  TO  SPEED  UP  TERMINAL\n          INPUT  AND  OUTPUT BY SKIPPING LONG STRINGS OF BLANKS.\n          THIS REQUIRES A \"SET TABS\" COMMAND FOR INTERNAL WYLBUR\n          TABS, AND THE SETTING OF  THE  HARDWARE  TABS  IF  YOUR\n          TERMINAL TYPE HAS HARDWARE TABS.\n\n          THE SETTING OF HARDWARE TABS  WILL  NOT  BE  DISCUSSED\n          HERE,  ONLY  THE  INTERNAL WYLBUR TABS.  THERE ARE TWO\n          WAYS TO SET TABS.\n\n         LONG FORM --- SPACING OVER\n\n          YOU MAY SET A MAXIMUM OF EIGHT TABS.  YOU WILL  NOTICE\n          THAT  THERE  ARE  ALPHA CHARACTERS EMBEDDED WITHIN THE\n          NUMERICS  IN  THE  LONG  FORM.    THESE   ARE   \"10'S\"\n          INDICATORS WHERE A=10, B=20, C=30....M=130.\n\n         COMMAND?  SET TABS (CR)\n         TYPE A \"1\" BENEATH EACH POSITION AT WHICH YOU SET A TAB.\n                   123456789A123456789B123456789C12345.....\n                           -          -         -\n                   _\n\n          THE CURSOR WILL BE PLACED BY WYLBUR  UNDER  COLUMN  1.\n          STARTING  AT  THE  LEFT, SPACE OVER TO EACH SUCCESSIVE\n          COLUMN IN WHICH YOU WANT A TAB TO BE  SET,  PRESS  THE\n          HARDWARE  TAB  IF  YOU HAVE THAT TYPE OF TERMINAL, AND\n          THEN TYPE THE NUMBER 1.  PHYSICAL TAB SETTINGS ARE NOT\n          VERIFIED ON 3277 TYPE TERMINALS.\n\n         COMMAND?  SET TABS (CR)\n         TYPE A \"1\" BENEATH EACH POSITION AT WHICH YOU SET A TAB.\n                   123456789A123456789B123456789C12345.....\n                           -          -         -\n                           1          1         1 (CR)\n                           1          1         1\n                           1          1         1\n\n          THE EXAMPLE ABOVE SHOWS  THE  SUCCESSFUL  SETTING  AND\n          VERIFICATION  OF  THE  TABS  IN COLUMNS 9, 20, AND 30.\n          BECAUSE PHYSICAL TABS WERE SET  WYLBUR  HAS  SENT  TWO\n          LINES OF DATA BACK TO VERIFY CORRECT TAB SETTINGS.  IF\n          YOU  DID  NOT  SET THE HARDWARE TABS, WYLBUR WILL SEND\n          BACK (THE SECOND LINE IS  HARDWARE  TABS)  A  LINE  OF\n          BLANKS.   IF  YOU  DID  SET  THE HARDWARE TABS AND THE\n          VERIFICATION ONES ARE NOT DIRECTLY IN LINE  WITH  EACH\n          OTHER,   RESET   THE   PHYSICAL  TABS.   REMEMBER,  NO\n          VERIFICATION OF HARDWARE  TABS  OCCURS  ON  3277  TYPE\n          TERMINALS AND YOU WILL BE INFORMED OF THIS BY WYLBUR.\n\n         SHORT FORM --- APPENDING COLUMN NUMBERS\n\n          YOU MAY APPEND TO THE \"SET TABS\"  COMMAND  A  LIST  OF\n          NUMBERS  REPRESENTING  THE  COLUMN NUMBERS FOR THE TAB\n          SETTINGS.  IF THE 1'S  ARE  NOT  DIRECTLY  UNDER  EACH\n          OTHER,   RESET   THE   PHYSICAL  TABS  TO  THE  PROPER\n          POSITIONS.\n\n         COMMAND?  SET TABS 9 20 30 (CR)\n                            1          1          1\n                            1          1          1\n\n          TO RECEIVE THE FULL BENEFIT OF THE  TABS,  YOU  SHOULD\n          SET  THE  PHYSICAL  TABS AS WELL AS THE INTERNAL TABS.\n          WYLBUR WILL VERIFY EACH KIND OF SETTING  BY  TYPING  A\n          VERIFICATION  LINE  FOR  EACH.  THE FIRST VERIFICATION\n          LINE IS THE INTERNAL TABS AND THE SECOND LINE  IS  THE\n          HARDWARE  TABS.   IF THE TWO VERIFICATION LINES DO NOT\n          MATCH,  RESET THE PHYSICAL TABS.\n\n          IF YOU PRESS THE TAB KEY MORE  TIMES  THAN  THERE  ARE\n          TABS  SET,  WYLBUR  WILL  SEND  THE  MESSAGE \"LINE XXX\n          TRUNCATED TO 133 CHARACTERS\" IF THE LINE IS TOO  LONG,\n          OR  IGNORE  THE  ERRONEOUS  TAB  IF  THE LINE DOES NOT\n          EXCEED 133 CHARS.  IF YOU ARE NOT SURE HOW  MANY  TABS\n          HAVE BEEN SET, ISSUE THE \"SHOW TABS\" COMMAND.\n\n          WHEN THE \"SHOW TABS\" COMMAND IS  ISSUED,  WYLBUR  WILL\n          ALSO  TELL  YOU  WHETHER  SLOWLIST  OR  FASTLIST IS IN\n          EFFECT.  SLOWLIST AND FASTLIST HAVE NO MEANING ON  THE\n          DCEC WYLBUR SYSTEM AT THIS TIME.\n\n          YOU MAY SUPPRESS THE VERIFICATION OF TABS IN THE  \"SET\n          TABS\"    COMMAND    BY    SPECIFYING    THE    OPERAND\n          \"NOVERIFY/NOVER\".\n=TIME=TIM=TI\n)F FUNCTION -\n          THE WYLBUR TIME COMMAND IS  USED  TO  DISPLAY  SESSION\n          USAGE  STATISTICS.   THE  DISPLAY CONSISTS OF CPU TIME\n          USED, EXECUTION TIME USED, AND SESSION LENGTH.\n\n)X SYNTAX -\n\n         TIME\n\n         REQUIRED - NONE\n         DEFAULTS - NONE\n         ALIAS    - TIM, TI\n\n)O OPERANDS -\n               THERE ARE NO OPERANDS.\n=TO=SEND\n)F FUNCTION -\n\n          THE WYLBUR \"TO\" COMMAND ALLOWS YOU TO SEND MESSAGES TO\n          THE OPERATOR OR ANOTHER USER.  IT IS VERY  SIMILAR  TO\n          THE  TSO  \"SEND\"  COMMAND, BUT EASIER TO USE.  YOU MAY\n          USE  THE  WORD  \"SEND\"  INSTEAD  OF  \"TO\".   THEY  ARE\n          SYNONYMOUS.\n\n)X SYNTAX -\n\nTO <OPR/UUUUU> <MESSAGE>\n\nREQUIRED - ALL\nDEFAULTS - NONE\nALIAS    - NONE\n\n)O OPERANDS -\n\n))OPR/UUUUU -\n          \"UUUUU\" STANDS FOR THE USER ID OF THE PERSON TO  WHICH\n          YOU WISH TO SEND THE MESSAGE.  \"OPR\" MEANS THAT WYLBUR\n          SHOULD SEND THE MESSAGE TO THE OPERATOR.\n\n))MESSAGE -\n          THE MESSAGE TEXT THAT YOU WISH SENT.  THE MESSAGE NEED\n          NOT BE ENCLOSED IN QUOTES.\n\n=UNCATLG=UNC=UNCA=UNCAT=UNCATL\n)F FUNCTION -\n\n          THE WYLBUR UNCATLG COMMAND CAUSES THE  SPECIFIED  DATA\n          SET TO BE UNCATALOGED.  THIS DOES NOT SCRATCH THE DATA\n          SET.\n\n)X SYNTAX -\n\n         UNCATLG <DSNAME>\n\n         REQUIED - DSNAME\n         DEFAULT - NONE\n         ALIAS   - UNCATL, UNCAT, UNCA, UNC\n\n)O OPERANDS -\n\n))DSNAME -\n         USED TO SPECIFY THE DATA SET TO BE UNCATALOGED.\n\n=USE=US=U\n)F FUNCTION -\n\n          THE WYLBUR USE COMMAND READS A COPY OF A DIRECT ACCESS\n          DATA SET (EXTERNAL FILE) INTO YOUR ACTIVE FILE.\n\n)X SYNTAX -\n\n          DUE TO THE NUMBER OF OPERANDS, THE  OPERANDS  WILL  BE\n          SHOWN TWO TO A LINE EVEN THOUGH THEY WOULD APPEAR ON A\n          SINGLE COMMAND LINE DURING A SESSION.\n\n                   USE <DSNAME> (ON 'VOLUME')\n                       (SET/NOSET) (CLEAR)\n                       (EDIT/LRECL='NNN'/CARD/PRINT) (INT)\n                       (NUMBERED/NUM) (SKIP MMMMM)\n                       (SEQFLD='END/(POS,LEN)')\n\n         REQUIRED - DSNAME\n         DEFAULTS - VOLUME=CATLG, SET, NOCLEAR, EDIT,\n                    SKIP=0, SEQFLD=(73,7)\n         ALIAS    - US, U\n\n)O OPERANDS -\n\n          ALL OPERANDS ARE KEYWORDS AND MAY BE SPECIFIED IN  ANY\n          SEQUENCE   EXCEPT   THE   <DSNAME>  OPERAND  WHICH  IS\n          POSITIONAL.\n\n))DSNAME -\n          THE <DSNAME> OPERAND IS POSITIONAL AND  SPECIFIES  THE\n          <DSNAME>  OF THE DATA SET TO BE READ.  NAMES OF WYLBUR\n          DATA SETS WITH STANDARD WYLBUR NAMES MAY BE  SPECIFIED\n          IN  THEIR  ENTIRETY  OR  IN  AN ABBREVIATED FORM USING\n          DEFAULT AND/OR PRE-SET VALUES.  THE FULL SPECIFICATION\n          OF  THIS  OPERAND  IS  DISCUSSED  IN  THE  HELP  ENTRY\n          \"DSNAMES\".\n\n))ON 'VOLUME' -\n          THE \"ON 'VOLUME'\" OPERAND TELLS WYLBUR THE NAME OF THE\n          DIRECT ACCESS VOLUME ON WHICH THE  DATA  SET  RESIDES.\n          IF  THE  DATA  SET IS CATALOGED IN THE SYSTEM CATALOG,\n          THIS OPERAND IS NOT NEEDED PROVIDING NO \"SET  VOLUME=\"\n          COMMAND  HAS BEEN ISSUED THAT HAS OVERRIDDEN THE LOGON\n          DEFAULT VALUE OF VOLUME=CATLG.  THIS  OPERAND  MAY  BE\n          SPECIFIED  AS  \"ON  CATLG\".  IF THE OPERAND IS USED IN\n          THE FORM \"ON CATLG\" OR DEFAULT, THEN WYLBUR WILL  TELL\n          YOU  THE  <VOLUME>  NAME OBTAINED FROM THE CATALOG FOR\n          THE SPECIFIED DATA SET.  IF THE CATALOG IS  NOT  USED,\n          \"ON  'VOLUME'\"  IS  REQUIRED FOR A SEQUENTIAL DATA SET\n          UNLESS  YOU  HAVE  PREVIOUSLY  DONE  A  \"SET   VOLUME\"\n          COMMAND.  IF \"ON 'VOLUME\" IS SPECIFIED IN THE COMMAND,\n          IT OVERRIDES ANY PREVIOUSLY SET <VOLUME> NAME.  WYLBUR\n          WILL  PROMPT  FOR  THE  <VOLUME>  NAME  IF  IT  IS NOT\n          SPECIFIED FOR A SEQUENTIAL DATA  SET.   FOR  A  WYLBUR\n          <LIBRARY> (YOUR USERID.  'LIB'), \"ON CATLG\" IS ASSUMED\n          IF THE <VOLUME> IS NOT SPECIFIED.\n\n))SET/NOSET -\n          THE DEFAULT VALUE FOR THIS OPERAND IS SET  AND  REFERS\n          TO  THE  SETTING OF THE SAVED PREFIX (AND POSSIBLY THE\n          SAVED MEMBER) NAME/NAMES.\n\n))CLEAR -\n          USE CANNOT BE  EXECUTED  UNLESS  THE  ACTIVE  FILE  IS\n          EMPTY.   IF  THERE  IS AN ACTIVE FILE, WYLBUR WILL ASK\n          YOU IF IT IS \"OK TO CLEAR?\" IN ORDER TO  PROCEED  WITH\n          THE USE.  YOU MAY PRE-EMPT THIS DIALOGUE BY SPECIFYING\n          \"CLEAR\".   WYLBUR  WILL THEN CLEAR THE ACTIVE FILE AND\n          PROCEED.  IF ANY REPLY OTHER THAN \"YES OR OK\" IS GIVEN\n          TO THE \"OK TO CLEAR?\" PROMPT, THEN  THE  OPERATION  IS\n          TERMINATED AND YOU ARE RETURNED TO THE COMMAND MODE.\n\n))EDIT/LRECL='NNN'/CARD/PRINT -\n          THIS OPERAND TELLS WYLBUR THE TYPE OF FILE HE IS GOING\n          TO USE.  THE DEFAULT IS  \"EDIT\"  (WYLBUR'S  COMPRESSED\n          FORM OF DATA STORAGE).  IF \"LRECL='NNN'\" (WHERE NNN IS\n          REPLACED  WITH  A NUMBER EQUAL TO OR LESS THAN 133) IS\n          USED, THEN WYLBUR ASSIGNS THAT VALUE TO THE DATA BEING\n          READ IN AND ACTS ACCORDINGLY.  IF \"CARD\" IS USED  THEN\n          THE  LRECL  OF 80 IS USED.  ALL 80 COLUMNS ARE ASSUMED\n          TO HAVE VALID DATA IN THEM AND WYLBUR LINE NUMBERS ARE\n          ASSIGNED  OUTSIDE  OF  THE  80  COLUMNS.   PRINT,   IF\n          SPECIFIED, TELLS WYLBUR THAT THE LINE LENGTH IS 133.\n\n          NORMALLY, WYLBUR USES THE INFORMATION IN THE DATA  SET\n          LABEL  (DSCB) TO DETERMINE HOW THE DATA SET WAS STORED\n          AND HOW IT IS TO BE READ.  HOWEVER, IF  THE  DSCB  HAS\n          BEEN ALTERED, OR IF YOU WISH TO READ THE DATA SET IN A\n          SPECIAL  WAY,  YOU MAY OVERRIDE THE INFORMATION IN THE\n          DSCB WITH THIS OPERAND.  IF THE RECORD LENGTH  (LRECL)\n          OF  THE  DATA SET IS GREATER THAN 133 CHARACTERS, (THE\n          MAXIMUM RECORD SIZE FOR  THE  ACTIVE  FILE)  YOU  MUST\n          OVERRIDE  THE  DSCB  INFORMATION  WITH  A  NUMBER  NOT\n          GREATER  THAN  133.   WYLBUR  WILL  READ  FIXED LENGTH\n          RECORDS (RECFM=F OR FB) AND  VARIABLE  LENGTH  RECORDS\n          (RECFM=V OR VB) BUT NOT \"SPANNED\" RECORDS (RECFM=VBS).\n          UNDEFINED DATA SETS (RECFM=U) ARE ASSUMED TO BE WYLBUR\n          INTERNAL  (EDIT)  FORMAT  DATA SETS.  WYLBUR LIBRARIES\n          AND THE  WYLBUR  ACTIVE  FILE  ARE  ALWAYS  IN  \"EDIT\"\n          FORMAT.\n\n          \"EDIT\" SPECIFIES THAT THE DATA HAS BEEN SAVE IN WYLBUR\n          INTERNAL FORMAT (A COMPRESSION SCHEME).   \"LRECL='NNN'\n          SPECIFIES  THAT  THE  DATA SET IS NOT IN \"EDIT\" FORMAT\n          AND THAT THE RECORD LENGTH TO BE USED IN READING IT IS\n          'NNN'.  WYLBUR THEN TREATS  THE  DATA  SET  AS  \"FIXED\n          BLOCK\" (RECFM= FB).  IF THE ACTUAL PHYSICAL BLOCK SIZE\n          IS  NOT  AN  INTEGRAL  MULTIPLE OF NNN, ANY CHARACTERS\n          REMAINING AFTER ALL POSSIBLE LINES OF  NNN  CHARACTERS\n          HAVE  BEEN  EXTRACTED  WILL  BE IGNORED.  \"CARD\" IS AN\n          ABBREVIATION OF LRECL=80 AND PRINT IS AN  ABBREVIATION\n          FOR LRECL=133.  ALL PROVISIONS FOR LRECL APPLY EQUALLY\n          TO  \"CARD\"  AND \"PRINT\".  THE VALUES \"LRECL=\", \"CARD\",\n          AND \"PRINT\" MAY BE SPECIFIED FOR ANY DATA SET, BUT THE\n          USER SHOULD BE AWARE THAT THE USE  OF  THESE  OPERANDS\n          MAY  PRODUCE  SOME RATHER ODD LOOKING DATA IF THE DATA\n          SET BEING READ DOES NOT ACTUALLY CONTAIN FIXED  LENGTH\n          RECORDS.\n\n))INT -\n          THIS KEYWORD IS SPECIFIED IF YOU WANT  WYLBUR  TO  USE\n          THE  LINE  NUMBERS  AS  INTEGERS,  WITHOUT INSERTING A\n          DECIMAL POINT BETWEEN THE  FIFTH  AND  SIXTH  NUMBERS.\n          THIS  PRESUPPOSES THAT THE \"NUMBERED\" OPERAND HAS BEEN\n          SUPPLIED IN THE COMMAND.\n\n\n          ))SKIP MMMM - YOU MAY  SPECIFY  THAT  SOME  NUMBER  OF\n          RECORDS  AT  THE  BEGINNING  OF THE DATA SET ARE TO BE\n          SKIPPED.  THE OPERAND \"SKIP=MMMM\" SPECIFIES  THAT  THE\n          FIRST MMMM RECORDS ARE TO BE IGNORED.\n\n))NUMBERED/NUM -\n          SPECIFICATION OF ANY OF THE THREE  KEYWORDS  (ALL  ARE\n          SYNONYMOUS)  TELLS  WYLBUR THAT LINE NUMBERS ARE TO BE\n          FOUND WITHIN THE DATA.  IF THIS KEYWORD IS  SPECIFIED,\n          AND  THE  DATA  IS  STORED IN EDIT FORMAT, WYLBUR WILL\n          TERMINATE THE COMMAND, ISSUE \"NUMBERED  ILLEGAL\",  AND\n          PROMPT  FOR  ANOTHER  COMMAND.   IF THE DATA IS STORED\n          WITHOUT LINE NUMBERS AND THIS  KEYWORD  IS  SPECIFIED,\n          WYLBUR  WILL  TERMINATE THE COMMAND, ISSUE \"USE OPTION\n          ERROR,  USE  INCOMPLETE\",  AND  PROMPT   FOR   ANOTHER\n          COMMAND.\n\n))SEQFLD='END/(POS,LEN)' -\n          WHEN DATA SETS ARE SAVED IN \"EDIT\" FORMAT, THE  WYLBUR\n          LINE  NUMBERS  ARE  STORED  SEPARATE  FROM  THE  DATA.\n          HOWEVER,  THIS  IS NORMALLY NOT TRUE FOR DATA SAVED IN\n          OTHER FORMATS.  SUCH DATA SETS WILL BE  RENUMBERED  BY\n          WYLBUR  (FROM  1.000  BY  CURRENT DELTA) WHEN THEY ARE\n          READ.  FOR NON-EDIT DATA SETS, THE  \"NUMBERED\"  OPTION\n          ASSUMES  THAT  EACH  RECORD  HAS  A LINE NUMBER IN IT.\n          WYLBUR USES THAT LINE  NUMBER  AND  DELETES  FROM  THE\n          RECORD  THOSE  COLUMNS  CONTAINING  THE  LINE  NUMBER.\n          ALTHOUGH  THE  LINE  NUMBERS  CAN BE EITHER DECIMAL OR\n          INTEGER, INTEGER LINE NUMBERS WILL BE ASSUMED TO  HAVE\n          AN  IMPLIED THREE DECIMAL PLACES.  THE \"SEQFLD\" OPTION\n          IS USED TO NOTIFY WYLBUR THAT THE LINE NUMBERS ARE  AT\n          SOME   POSITION  OR  LENGTH  OTHER  THAN  THE  DEFAULT\n          \"SEQFLD=(END,8)\".  ANY STARTING COLUMN POSITION  (POS)\n          AND  ANY  LENGTH (,LEN) LESS THAT 10 CAN BE SPECIFIED.\n          IF THE LENGTH IS NOT CHANGED, THE  PARENTHESES  AROUND\n          THE  POSITION  FIELD CAN BE OMITTED.  \"SEQFLD\" ASSUMES\n          NUMBERED AND BOTH USE THE DEFAULT LRECL IN THE DSCB.\n\n./ ALIAS NAME=W\n./ ALIAS NAME=WYLTSO\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LIB2CNTL": {"ttr": 21512, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00$\\x01\\x19#\\x0f\\x01\\x19#\\x0f\\x14A\\x02{\\x02{\\x00\\x00\\xe3\\xd6\\xd6\\xd3\\xe2@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2019-08-18T00:00:00", "modifydate": "2019-08-18T14:41:24", "lines": 635, "newlines": 635, "modlines": 0, "user": "TOOLS"}, "text": "./ ADD NAME=$RAB\n//$RAB    JOB (2000,C010),'DOBBINS, DENNIS G.',CLASS=Z,NOTIFY=$SYS11\n/*JOBPARM Q=F\n//STEP01   EXEC ASMFCL,MAC1='SYS1.AMODGEN'\n//ASM.SYSIN  DD  DISP=SHR,DSN=SYS0.CMDLIB2.SOURCE($RAB)\n//LKED.SYSLMOD  DD  DISP=SHR,DSN=SYS2.CMDLIB\n//LKED.SYSIN    DD  *\n NAME  $RAB(R)\n/*\n./ ADD NAME=$RELOAD,SSI=00009025\n//$RELOAD JOB (8220,0952),WENZEL,CLASS=Z,NOTIFY=$SYS13,MSGCLASS=X\n/*JOBPARM Q=F\n//STEP01   EXEC ASMFCL,MAC1='SYS2.MACLIB'\n//ASM.SYSIN  DD  DISP=SHR,DSN=SYS.CMDLIB2.SOURCE($RELOAD)\n//LKED.SYSLMOD  DD  DISP=SHR,DSN=SYS2.CMDLIB\n//LKED.SYSIN    DD  *\n NAME  $RELOAD(R)\n/*\n./ ADD NAME=#        0100-80017-80017-0728-00008-00008-00000-$SYS13  00\n//#       JOB (2000,S010),WENZEL\n/*JOBPARM Q=F,I\n//STEP01   EXEC ASMFCL,MAC1='SYS2.MACLIB'\n//ASM.SYSIN  DD  DISP=SHR,DSN=SYS0.CMDLIB2.SOURCE(#)\n//LKED.SYSLMOD  DD  DISP=SHR,DSN=SYS2.CMDLIB\n//LKED.SYSIN    DD  *\n NAME  #(R)\n/*\n./ ADD NAME=ASID,SSI=00000038\n//ASID  JOB (2000,S010),WENZEL,CLASS=Z\n/*JOBPARM Q=F,I\n//STEP01   EXEC ASMFCL,MAC1='SYS1.AMODGEN'\n//ASM.SYSIN  DD  DISP=SHR,DSN=SYS0.CMDLIB2.SOURCE(ASID)\n//LKED.SYSLMOD  DD  DISP=SHR,DSN=SYS2.CMDLIB\n//LKED.SYSIN    DD  *\n ALIAS AS\n NAME  ASID(R)\n/*\n./ ADD NAME=BURN     0100-80017-80017-0728-00011-00011-00000-$SYS13  00\n//BURN  JOB (2000,S010),WENZEL\n/*JOBPARM Q=F,I\n//STEP01   EXEC ASMFCL\n//ASM.SYSLIB DD DISP=SHR,DSN=SYS1.MACLIB\n//           DD DISP=SHR,DSN=SYS2.MACLIB\n//           DD DISP=SHR,DSN=SYS1.AMODGEN\n//ASM.SYSIN  DD  DISP=SHR,DSN=SYS0.CMDLIB2.SOURCE(BURN)\n//LKED.SYSLMOD  DD  DISP=SHR,DSN=SYS2.CMDLIB\n//LKED.SYSIN    DD  *\n NAME  BURN(R)\n/*\n./ ADD NAME=CATCLEAN 0102-80184-80184-0811-00008-00009-00004-$SYS13  00\n//CATCLEAN  JOB (2000,S010),WENZEL,CLASS=Z\n/*JOBPARM Q=F,I\n//STEP01   EXEC ASMFCL\n//ASM.SYSIN  DD  DISP=SHR,DSN=SYS0.LINKLIB2.SOURCE(CATCLEAN)\n//LKED.SYSLMOD  DD  DISP=SHR,DSN=SYS2.LINKLIB\n//LKED.SYSIN    DD  *\n NAME  CATCLEAN(R)\n/*\n./ ADD NAME=CBT973   0101-80056-80056-1312-00009-00010-00003-$SYS13  00\n//CBT973 JOB (2000,S010),WENZEL,CLASS=Z\n/*JOBPARM Q=F,I\n//*\n//STEP1   EXEC ASMFCL,MAC1='SYS1.AMODGEN'\n//ASM.SYSIN    DD DISP=SHR,DSN=SYS0.LINKLIB2.SOURCE(CBT973)\n//LKED.SYSLMOD DD DISP=SHR,DSN=SYS2.LINKLIB\n//LKED.SYSIN   DD  *\n NAME  CBT973(R)\n/*\n./ ADD NAME=CLEANSYS\n//CLEANSYS  JOB (2000,S010),WENZEL,CLASS=A,NOTIFY=$SYS13,MSGCLASS=A\n/*JOBPARM Q=F\n//STEP01   EXEC ASMFCL\n//ASM.SYSIN  DD  DISP=SHR,DSN=SYS0.LINKLIB2.SOURCE(CLEANSYS)\n//LKED.SYSLMOD  DD  DISP=SHR,DSN=SYS2.LINKLIB\n//LKED.SYSIN    DD  *\n SETCODE AC(1)\n NAME  CLEANSYS(R)\n/*\n./ ADD NAME=CREATE   0100-80017-80017-0729-00009-00009-00000-$SYS13  00\n//CREATE  JOB (2000,S010),WENZEL\n/*JOBPARM Q=F,I\n//STEP01   EXEC ASMFCL\n//ASM.SYSIN  DD  DISP=SHR,DSN=SYS0.CMDLIB2.SOURCE(CREATE)\n//LKED.SYSLMOD  DD  DISP=SHR,DSN=SYS2.CMDLIB\n//LKED.SYSIN    DD  *\n ALIAS CR\n NAME  CREATE(R)\n/*\n./ ADD NAME=DEBUG    0101-80017-80081-1221-00012-00012-00001-$SYS13  00\n//DEBUG  JOB (2000,S010),WENZEL,CLASS=Z\n/*JOBPARM Q=F,I\n//STEP01   EXEC ASMFCL\n//ASM.SYSLIB DD DISP=SHR,DSN=SYS2.MACLIB\n//        DD DISP=SHR,DSN=SYS1.MACLIB\n//        DD DISP=SHR,DSN=SYS1.AMODGEN\n//ASM.SYSIN  DD  DISP=SHR,DSN=SYS0.CMDLIB2.SOURCE(DEBUG)\n//LKED.SYSLMOD  DD  DISP=SHR,DSN=SYS2.CMDLIB\n//LKED.SYSIN    DD  *\n SETCODE AC(1)\n NAME  DEBUG(R)\n/*\n./ ADD NAME=DISK,SSI=00000185\n//DISK  JOB (2000,S010),WENZEL,CLASS=Z\n/*JOBPARM Q=F,I\n//STEP01   EXEC ASMFCL,MAC1='SYS2.MACLIB'\n//ASM.SYSIN  DD  DISP=SHR,DSN=SYS0.CMDLIB2.SOURCE(DISK)\n//LKED.SYSLMOD  DD  DISP=SHR,DSN=SYS2.CMDLIB\n//LKED.SYSIN    DD  *,DCB=BLKSIZE=80\n ALIAS DI\n NAME  DISK(R)\n/*\n./ ADD NAME=DMN      0101-80017-80161-1320-00010-00010-00001-$SYS13  00\n//DMN JOB (2000,S010),WENZEL\n/*JOBPARM Q=F,I\n//STEP01   EXEC PLIXCL\n//PLI.SYSIN  DD  DISP=SHR,DSN=SYS0.CMDLIB2.SOURCE(DMN)\n//LKED.SYSLMOD  DD  DISP=SHR,DSN=SYS2.CMDLIB\n//LKED.SYSIN    DD  *\n ENTRY PLICALLA\n PAGE PLISTART\n NAME  DMN(R)\n/*\n./ ADD NAME=DMOD     0101-80017-80128-1116-00014-00014-00001-$SYS13  00\n//DMOD  JOB (2000,S010),WENZEL,CLASS=Z\n/*JOBPARM Q=F,I\n//STEP01   EXEC ASMFC,MAC1='SYS1.AMODGEN'\n//ASM.SYSIN  DD  DISP=SHR,DSN=SYS0.CMDLIB2.SOURCE(DMOD)\n//STEP02   EXEC ASMFC,MAC1='SYS1.AMODGEN'\n//ASM.SYSIN  DD  DISP=SHR,DSN=SYS0.CMDLIB2.SOURCE(DMODFNDV)\n//STEP03   EXEC ASMFCL,MAC1='SYS1.AMODGEN'\n//ASM.SYSIN  DD  DISP=SHR,DSN=SYS0.CMDLIB2.SOURCE(DMODRDVT)\n//LKED.SYSLMOD  DD  DISP=SHR,DSN=SYS2.CMDLIB\n//LKED.SYSIN    DD  *\n SETCODE AC(1)\n ENTRY DMOD\n NAME  DMOD(R)\n/*\n./ ADD NAME=DPCPROB  0101-80035-80035-1147-00012-00008-00006-$SYS13  00\n//DPCPROB JOB (2000,S010),WENZEL,CLASS=Z\n/*JOBPARM Q=F,I\n//STEP01   EXEC ASMFCL,MAC1='SYS2.MACLIB'\n//ASM.SYSLIB DD  DISP=SHR,DSN=SYS1.MACLIB,DCB=BLKSIZE=18960\n//           DD  DISP=SHR,DSN=SYS2.MACLIB\n//           DD  DISP=SHR,DSN=SYS1.AMODGEN\n//ASM.SYSIN  DD  DISP=SHR,DSN=SYS0.CMDLIB2.SOURCE(DPCPROB)\n//LKED.SYSLMOD  DD  DISP=SHR,DSN=SYS2.CMDLIB\n//LKED.SYSIN    DD  *\n SETCODE AC(1)\n NAME  DPCPROB(R)\n/*\n./ ADD NAME=DSUTIL   0101-80058-80058-1805-00016-00011-00013-$SYS13  00\n//DSUTIL JOB (2000,S010),WENZEL,CLASS=Z\n/*JOBPARM Q=F,I\n//*\n//DSUTIL1 EXEC ASMFC,MAC1='SYS2.MACLIB'\n//ASM.SYSIN DD DISP=SHR,DSN=SYS0.LINKLIB2.SOURCE(DSUTIL1)\n//*\n//DSUTIL2 EXEC ASMFC,MAC1='SYS2.MACLIB'\n//ASM.SYSIN DD DISP=SHR,DSN=SYS0.LINKLIB2.SOURCE(DSUTIL2)\n//*\n//DSUTIL3 EXEC ASMFCL,MAC1='SYS2.MACLIB'\n//ASM.SYSIN DD DISP=SHR,DSN=SYS0.LINKLIB2.SOURCE(DSUTIL3)\n//*\n//LKED.SYSLMOD DD DISP=SHR,DSN=SYS2.LINKLIB\n//LKED.SYSIN   DD  *\n ENTRY DSUTIL\n NAME  DSUTIL(R)\n./ ADD NAME=EYEBALL  0104-80051-80058-1805-00014-00010-00013-$SYS13  00\n//EYEBALL JOB (2000,S010),WENZEL,CLASS=Z\n/*JOBPARM Q=F,I\n//*\n//EYEBALL EXEC ASMFC,MAC1='SYS1.AMODGEN'\n//ASM.SYSIN DD DISP=SHR,DSN=SYS0.LINKLIB2.SOURCE(EYEBALL)\n//*\n//EYE001  EXEC ASMFCL,MAC1='SYS1.AMODGEN'\n//ASM.SYSIN DD DISP=SHR,DSN=SYS0.LINKLIB2.SOURCE(EYE001)\n//*\n//LKED.SYSLMOD DD DISP=SHR,DSN=SYS2.LINKLIB\n//LKED.SYSIN   DD  *\n ENTRY EYEBALL\n SETCODE AC(1)\n NAME  EYEBALL(R)\n./ ADD NAME=HELPLIST 0102-80160-80160-1445-00006-00006-00004-$SYS13  00\n//HELPLIST JOB (2000,S010),WENZEL,CLASS=Z\n/*JOBPARM Q=F,I\n//*\n//STEP1   EXEC ASMFCL,MAC1='SYS2.MACLIB'\n//ASM.SYSIN    DD DISP=SHR,DSN=SYS0.LINKLIB2.SOURCE(HELPLIST)\n//LKED.SYSLMOD DD DISP=SHR,DSN=SYS2.LINKLIB(HELPLIST)\n./ ADD NAME=INTTAB   0100-80104-80104-2140-00006-00006-00000-$SYS13  00\n//INTTAB JOB (2000,S010),WENZEL,CLASS=Z\n/*JOBPARM Q=F,I\n//*\n//STEP1   EXEC ASMFCL\n//ASM.SYSIN    DD DISP=SHR,DSN=SYS0.LINKLIB2.SOURCE(INTTAB)\n//LKED.SYSLMOD DD DISP=SHR,DSN=SYS1.VTAMLIB(INTTAB)\n./ ADD NAME=ITELACCT 0101-80080-80080-1940-00006-00010-00004-$SYS13  00\n//ITELACCT JOB (2000,S010),WENZEL,CLASS=Z\n/*JOBPARM Q=F,I\n//*\n//STEP1   EXEC ASMFCL\n//ASM.SYSIN    DD DISP=SHR,DSN=SYS0.LINKLIB2.SOURCE(ITELACCT)\n//LKED.SYSLMOD DD DISP=SHR,DSN=SYS2.LINKLIB(ITELACCT)\n./ ADD NAME=LPDS     0101-80017-80029-1645-00009-00009-00001-$SYS13  00\n//LPDS  JOB (2000,S010),WENZEL,CLASS=Z\n/*JOBPARM Q=F,I\n//STEP01   EXEC ASMFCL,MAC1='SYS1.AMODGEN'\n//ASM.SYSIN  DD  DISP=SHR,DSN=SYS0.CMDLIB2.SOURCE(LPDS)\n//LKED.SYSLMOD  DD  DISP=SHR,DSN=SYS2.CMDLIB\n//LKED.SYSIN    DD  *\n ALIAS LP\n NAME  LPDS(R)\n/*\n./ ADD NAME=MCPGEN   0107-79351-80170-1323-00007-00009-00007-$SYS13  00\n//MCPGEN JOB (2000,S010),WENZEL,CLASS=Z\n/*JOBPARM Q=F,I\n//MCPGEN  EXEC MCPGEN,\n//             DSNIN1='SYS0.LINKLIB2.SOURCE(MCPGEN)',\n//             VOLIN1=SYS500,UIN1=DISK,\n//             DSNOUT2='SYS2.LINKLIB(IEDQTCAM)',\n//             VOLOUT2=SYS200,UOUT2=DISK\n./ ADD NAME=MCPGEN9  0100-80170-80170-1322-00010-00010-00000-$SYS13  00\n//MCPGEN JOB (2000,S010),WENZEL,CLASS=Z\n/*JOBPARM Q=F,I\n//TABLES  EXEC ASMFC\n//ASM.SYSGO DD DSN=&&OBJSET2,UNIT=VIO\n//ASM.SYSIN DD DISP=SHR,DSN=SYS0.LINKLIB2.SOURCE(TCAMTBLS)\n//MCPGEN  EXEC MCPGEN,\n//             DSNIN1='SYS0.LINKLIB2.SOURCE(MCPGEN)',\n//             VOLIN1=SYS500,UIN1=DISK,\n//             DSNOUT2='SYS2.LINKLIB(IEDQTCAN)',\n//             VOLOUT2=SYS200,UOUT2=DISK\n./ ADD NAME=MCS      0101-80119-80119-1131-00008-00009-00004-$SYS13  00\n//MCS   JOB (2000,S010),WENZEL,CLASS=Z\n/*JOBPARM Q=F,I\n//STEP01   EXEC ASMFCL,MAC1='SYS1.AMODGEN'\n//ASM.SYSIN  DD  DISP=SHR,DSN=SYS0.CMDLIB2.SOURCE(MCS)\n//LKED.SYSLMOD  DD  DISP=SHR,DSN=SYS2.CMDLIB\n//LKED.SYSIN    DD  *\n NAME  MCS(R)\n/*\n./ ADD NAME=MODREP   0100-80037-80037-2303-00010-00010-00000-$SYS13  00\n//MODREP JOB (2000,S010),WENZEL,CLASS=Z\n/*JOBPARM Q=F,I\n//*\n//STEP1   EXEC ASMFCL,MAC1='SYS1.AMODGEN'\n//ASM.SYSIN    DD DISP=SHR,DSN=SYS0.LINKLIB2.SOURCE(MODREP)\n//LKED.SYSLMOD DD DISP=SHR,DSN=SYS2.LINKLIB\n//LKED.SYSIN   DD  *\n SETCODE AC(1)\n NAME  MODREP(R)\n/*\n./ ADD NAME=PAGES    0102-80017-80205-1532-00010-00010-00002-$SYS13  00\n//PAGES JOB (2000,S010),WENZEL,CLASS=Z\n/*JOBPARM Q=F,I\n//STEP01   EXEC PLIXCL\n//PLI.SYSIN  DD  DISP=SHR,DSN=SYS0.CMDLIB2.SOURCE(PAGES)\n//LKED.SYSLMOD  DD  DISP=SHR,DSN=$SYS13.STEPLIB.LOAD\n//LKED.SYSIN    DD  *\n ENTRY PLICALLA\n PAGE PLISTART\n NAME  PAGES(R)\n/*\n./ ADD NAME=PERFORM  0100-80017-80017-0724-00011-00011-00000-$SYS13  00\n//PERFORM  JOB (2000,S010),WENZEL\n/*JOBPARM Q=F,I\n//STEP01   EXEC ASMFCL\n//ASM.SYSLIB DD DISP=SHR,DSN=SYS1.AMODGEN\n//         DD DISP=SHR,DSN=SYS1.MACLIB\n//         DD DISP=SHR,DSN=SYS2.MACLIB\n//ASM.SYSIN  DD  DISP=SHR,DSN=SYS0.CMDLIB2.SOURCE(PERFORM)\n//LKED.SYSLMOD  DD  DISP=SHR,DSN=SYS2.CMDLIB\n//LKED.SYSIN    DD  *\n ALIAS PERF\n NAME PERFORM(R)\n./ ADD NAME=PREOSTIQ\n//PREOSTIQ  JOB (2000,S010),WENZEL,CLASS=Z\n/*JOBPARM Q=F,I\n//STEP01   EXEC ASMFCL,MAC1='SYS2.MACLIB'\n//ASM.SYSIN  DD  DISP=SHR,DSN=SYS0.LINKLIB2.SOURCE(PREOSTIQ)\n//LKED.SYSLMOD  DD  DISP=SHR,DSN=SYS2.LINKLIB\n//LKED.SYSIN    DD  *\n NAME  PREOSTIQ(R)\n/*\n./ ADD NAME=QUE1     0101-80017-80018-1915-00018-00011-00010-$SYS13  00\n//QUE1 JOB (2000,S010),WENZEL\n/*JOBPARM Q=F,I\n//*\n//DELETE  EXEC  PGM=IEFBR14\n//DD1      DD DSN=SYS0.QUE.MACLIB,DISP=(MOD,DELETE),\n//            UNIT=DISK,SPACE=(CYL,0)\n//DD2      DD DSN=SYS0.QUE.OBJ,DISP=(MOD,DELETE),\n//            UNIT=DISK,SPACE=(CYL,0)\n//*\n//UPDT    EXEC  PGM=IEBUPDTE,PARM=NEW\n//SYSPRINT DD DUMMY\n//SYSUT2   DD DSN=SYS0.QUE.MACLIB,DISP=(,CATLG),\n//            UNIT=DISK,SPACE=(CYL,(2,1,27)),VOL=SER=PAG001,\n//            DCB=(RECFM=FB,LRECL=80,BLKSIZE=3120)\n//SYSIN    DD DISP=SHR,DSN=SYS0.CMDLIB2.SOURCE(QUEUPDTE)\n//DD       DD DSN=SYS0.QUE.OBJ,DISP=(,CATLG),\n//            UNIT=DISK,SPACE=(CYL,(1,1,27)),VOL=SER=PAG001,\n//            DCB=(RECFM=FB,LRECL=80,BLKSIZE=3120)\n./ ADD NAME=QUE2     0101-80059-80137-1604-00035-00035-00000-$SYS13  00\n//QUE2  JOB (2000,S010),WENZEL,CLASS=Z\n/*JOBPARM Q=F,I\n//UPDT    EXEC  PGM=IEBUPDTE,PARM=MOD\n//SYSPRINT DD SYSOUT=*\n//SYSUT1   DD DSN=SYS0.QUE.MACLIB,DISP=SHR\n//SYSUT2   DD DSN=SYS0.QUE.MACLIB,DISP=SHR\n//SYSIN    DD *\n>< CHANGE NAME=QCOMMON,SEQFLD=738\n               &UNIT=3350,     DEFAULT UNIT NAME FOR SYS1.HASPCKPT     X\n               &VOLSER=SYS400, DEFAULT VOLUME SERIAL FOR SYS1.HASPCKPT X\n               &SID1='A000',   SYSTEM ID FOR SYSTEM # 1 (UP TO 8 CHARS)X\n               &SID2='     ',  SYSTEM ID FOR SYSTEM # 2                X\n               &SID3='      ', SYSTEM ID FOR SYSTEM # 3                X\n>< CHANGE NAME=Q7,SEQFLD=738\n*        DELETED                                                MRX\n*        DELETED                                                MRX\n         MVC   CONVERT-4(8),=X'4020202020202120' EDIT MASK      MRX\n         ED    CONVERT-4(8),CONVERT+4   CONVERT TO EBCDIC       MRX\n         MVC   FLINES(5),CONVERT-1      MOVE IT TO MSG          MRX\n         C     R0,=F'99999'             COUNT FIT IN 5 DIGITS?  MRX\n         BNH   LISTJOE1                 B IF SO                 MRX\n         MVC   FLINES(5),CONVERT-4      CONVERT TO K'S          MRX\n         MVI   FLINES+5,C'K'            SET INDICATOR           MRX\nLISTJOE1 EQU   *                                                MRX\n*        DELETED                                                MRX\n*        DELETED                                                MRX\n         MVC   CONVERT-4(8),=X'4020202020202120' EDIT MASK      MRX\n         ED    CONVERT-4(8),CONVERT+4   CONVERT TO EBCDIC       MRX\n         MVC   FLINES(5),CONVERT-1      MOVE IT TO MSG          MRX\n         MVI   FLINES+5,C' '            SET BLANK TO BE SAFE    MRX\n         C     R0,=F'99999'             COUNT FIT IN 5 DIGITS?  MRX\n         BNH   LISTJOE2                 B IF SO                 MRX\n         MVC   FLINES(5),CONVERT-4      CONVERT TO K'S          MRX\n         MVI   FLINES+5,C'K'            SET INDICATOR           MRX\nLISTJOE2 EQU   *                                                MRX\n./ ADD NAME=QUE3     0108-79319-80205-1315-00093-00090-00026-$SYS13  00\n//QUE3  JOB (2000,S010),WENZEL,CLASS=Z\n/*JOBPARM Q=F,I\n//QASM     PROC MBR=\n//ASM      EXEC PGM=IFOX00,PARM='LOAD,NODECK',REGION=4000K\n//SYSLIB   DD DISP=SHR,DSN=SYS0.QUE.MACLIB\n//         DD DISP=SHR,DSN=SYS1.SMPMTS\n//         DD DISP=SHR,DSN=SYS1.MACLIB\n//         DD DISP=SHR,DSN=SYS4.ACF2.V221.ACFMAC\n//         DD DISP=SHR,DSN=SYS1.HASPSRC\n//         DD DISP=SHR,DSN=SYS4.JTIP.V12.MAC\n//SYSUT1    DD  SPACE=(CYL,(5,5)),UNIT=VIO\n//SYSUT2    DD  SPACE=(CYL,(5,5)),UNIT=VIO\n//SYSUT3    DD  SPACE=(CYL,(5,5)),UNIT=VIO\n//SYSPRINT  DD  SYSOUT=*\n//SYSGO     DD  DISP=OLD,DSN=SYS0.QUE.OBJ(&MBR)\n//SYSIN     DD  DISP=SHR,DSN=SYS0.QUE.MACLIB(&MBR)\n//         PEND\n//*\n//*\n//**** ASSEMBLE ALL THE REENTRANT MODULES\n//*\n//*\n//QUEUE    EXEC QASM,MBR=Q1          QUEUE\n//ALLOCATE EXEC QASM,MBR=Q2          ALLOCATE\n//CKPT     EXEC QASM,MBR=Q3          CKPT\n//DDNAME   EXEC QASM,MBR=Q4          DDNAME\n//DISPLAY  EXEC QASM,MBR=Q5          DISPLAY\n//FINDJOB  EXEC QASM,MBR=Q6          FINDJOB\n//FORMAT   EXEC QASM,MBR=Q7          FORMAT\n//HELP     EXEC QASM,MBR=Q8          HELP\n//HEXBLK   EXEC QASM,MBR=Q9          HEXBLK\n//INIT     EXEC QASM,MBR=Q10         INIT\n//JCL      EXEC QASM,MBR=Q11         JCL\n//JLOG     EXEC QASM,MBR=Q12         JLOG\n//JMSG     EXEC QASM,MBR=Q13         JMSG\n//LIST     EXEC QASM,MBR=Q14         LIST\n//LISTDS   EXEC QASM,MBR=Q15         LISTDS\n//PARSE    EXEC QASM,MBR=Q16         PARSE\n//READSPC  EXEC QASM,MBR=Q17         READSPC\n//REPOS    EXEC QASM,MBR=Q18         REPOS\n//SAVE     EXEC QASM,MBR=Q19         SAVE\n//SEARCH   EXEC QASM,MBR=Q20         SEARCH\n//SYSLOG   EXEC QASM,MBR=Q21         SYSLOG\n//XDS      EXEC QASM,MBR=Q22         XDS\n//*\n//*\n//**** LINK THE REENTRANT MODULES TO FORM THE QUEUE COMMAND\n//*\n//*\n//LINKEDIT EXEC PGM=IEWL,PARM='XREF,LIST,LET,NCAL,REFR,RENT,REUS',\n//         COND=(7,LT)\n//SYSLMOD   DD  DISP=SHR,DSN=SYS2.CMDLIB\n//SYSUT1    DD  UNIT=SYSDA,SPACE=(CYL,(2,1))\n//SYSPRINT  DD  SYSOUT=*\n//SYSLIB    DD  DISP=SHR,DSN=SYS0.QUE.OBJ\n//SYSLIN    DD  *\n INCLUDE SYSLIB(Q1,Q2,Q3,Q4,Q5,Q6,Q7,Q8,Q9,Q10)\n INCLUDE SYSLIB(Q11,Q12,Q13,Q14,Q15,Q16,Q17,Q18,Q19,Q20)\n INCLUDE SYSLIB(Q21,Q22)\n ENTRY QUEUE\n ALIAS Q\n NAME QUEUE(R)\n/*\n//*\n//*\n//**** ASSEMBLE AND LINK THE NON REENTRANT COMMON MODULE\n//*\n//*\n//ASM2     EXEC PGM=IFOX00,PARM='LOAD,NODECK',REGION=4000K\n//SYSLIB   DD DISP=SHR,DSN=SYS0.QUE.MACLIB\n//         DD DISP=SHR,DSN=SYS1.SMPMTS\n//         DD DISP=SHR,DSN=SYS1.MACLIB\n//         DD DISP=SHR,DSN=SYS4.ACF2.V221.ACFMAC\n//         DD DISP=SHR,DSN=SYS1.HASPSRC\n//         DD DISP=SHR,DSN=SYS4.JTIP.V12.MAC\n//SYSUT1    DD  SPACE=(CYL,(5,5)),UNIT=SYSDA\n//SYSUT2    DD  SPACE=(CYL,(5,5)),UNIT=SYSDA\n//SYSUT3    DD  SPACE=(CYL,(5,5)),UNIT=SYSDA\n//SYSPRINT  DD  SYSOUT=*\n//SYSGO     DD  DISP=OLD,DSN=SYS0.QUE.OBJ(Q0)\n//SYSIN     DD  DISP=SHR,DSN=SYS0.QUE.MACLIB(Q0)\n/*\n//LINKEDT2 EXEC PGM=IEWL,PARM='XREF,LIST,LET,NCAL',\n//         COND=(7,LT,ASM2)\n//SYSLMOD   DD  DISP=SHR,DSN=SYS2.CMDLIB\n//SYSUT1    DD  UNIT=SYSDA,SPACE=(CYL,(2,1))\n//SYSPRINT  DD  SYSOUT=*\n//SYSLIB    DD  DISP=SHR,DSN=SYS0.QUE.OBJ\n//SYSLIN    DD  *\n INCLUDE SYSLIB(Q0)\n NAME QUEUECMN(R)\n/*\n//\n./ ADD NAME=RCT      0100-80017-80017-0726-00010-00010-00000-$SYS13  00\n//RCT JOB (2000,S010),WENZEL\n/*JOBPARM Q=F,I\n//STEP01   EXEC PLIXCL\n//PLI.SYSIN  DD  DISP=SHR,DSN=SYS0.CMDLIB2.SOURCE(RCT)\n//LKED.SYSLMOD  DD  DISP=SHR,DSN=SYS2.CMDLIB\n//LKED.SYSIN    DD  *\n ENTRY PLICALLA\n PAGE PLISTART\n NAME  RCT(R)\n/*\n./ ADD NAME=RECAP    0100-79347-79347-1240-00004-00004-00000-$SYS13  00\n//SMFDUMP0 JOB (2000,S010),SMFDUMP0,CLASS=A,MSGCLASS=A\n//S1 EXEC ASMSCL,LIB1='MRX.LINKLIB2.SOURCE',LIB2='SYS2.LINKLIB',\n// MEMBER=RECAP,MAC1='SYS3.NSC.MACLIB',MAC2='SYS1.MACLIB'\n/*\n./ ADD NAME=RMFRPT   0101-80044-80044-1606-00009-00021-00003-$SYS13  00\n//RMFRPT   JOB (2000,S010),WENZEL,CLASS=Z\n/*JOBPARM Q=F,I\n//*\n//STEP01   EXEC PLIXCL\n//PLI.SYSIN  DD  DISP=SHR,DSN=SYS0.LINKLIB2.SOURCE(RMFRPT)\n//LKED.SYSLMOD  DD  DISP=SHR,DSN=SYS2.LINKLIB\n//LKED.SYSIN    DD  *\n NAME  RMFRPT(R)\n//*\n./ ADD NAME=SMFBLOCK,SSI=00000088\n//SMFBLOCK JOB (2000,S010),WENZEL,CLASS=Z\n/*JOBPARM Q=F,I\n//STEP01   EXEC ASMFCL\n//ASM.SYSIN     DD  DISP=SHR,DSN=SYS0.LINKLIB2.SOURCE(SMFBLOCK)\n//LKED.SYSLMOD  DD  DISP=SHR,DSN=SYS2.LINKLIB\n//LKED.SYSIN    DD  *\n NAME  SMFBLOCK(R)\n/*\n./ ADD NAME=SMFCPUID 0101-80198-80198-1010-00008-00008-00003-$SYS13  00\n//SMFCPUID JOB (2000,S010),SMFCPUID,CLASS=Z\n/*JOBPARM Q=F,I\n//STEP01   EXEC ASMFCL\n//ASM.SYSIN     DD  DISP=SHR,DSN=SYS0.LINKLIB2.SOURCE(SMFCPUID)\n//LKED.SYSLMOD  DD  DISP=SHR,DSN=SYS2.LINKLIB\n//LKED.SYSIN    DD  *\n NAME  SMFCPUID(R)\n/*\n./ ADD NAME=SMFDUMP1 0101-80121-80121-1504-00009-00009-00003-$SYS13  00\n//SMFDUMP1 JOB (2000,S010),WENZEL,CLASS=Z\n/*JOBPARM Q=F,I\n//STEP01   EXEC ASMFCL\n//ASM.SYSIN     DD  DISP=SHR,DSN=SYS0.LINKLIB2.SOURCE(SMFDUMP1)\n//LKED.SYSLMOD  DD  DISP=SHR,DSN=SYS2.LINKLIB\n//LKED.SYSIN    DD  *\n SETCODE AC(1)\n NAME  SMFDUMP1(R)\n/*\n./ ADD NAME=SMFDUMP2 0101-80121-80121-1505-00009-00009-00004-$SYS13  00\n//SMFDUMP2 JOB (2000,S010),WENZEL,CLASS=Z\n/*JOBPARM Q=F,I\n//STEP01   EXEC ASMFCL,MAC1='SYS1.AMODGEN'\n//ASM.SYSIN     DD  DISP=SHR,DSN=SYS0.LINKLIB2.SOURCE(SMFDUMP2)\n//LKED.SYSLMOD  DD  DISP=SHR,DSN=SYS2.LINKLIB\n//LKED.SYSIN    DD  *\n SETCODE AC(1)\n NAME  SMFDUMP2(R)\n/*\n./ ADD NAME=SMFDUP   0101-80092-80092-1230-00008-00009-00003-$SYS13  00\n//SMFDUP JOB (2000,S010),SMFDUP,CLASS=Z\n/*JOBPARM Q=F,I\n//STEP01   EXEC ASMFCL\n//ASM.SYSIN     DD  DISP=SHR,DSN=SYS0.LINKLIB2.SOURCE(SMFDUP)\n//LKED.SYSLMOD  DD  DISP=SHR,DSN=SYS2.LINKLIB\n//LKED.SYSIN    DD  *\n NAME  SMFDUP(R)\n/*\n./ ADD NAME=SMFFIX   0101-80141-80141-1547-00008-00008-00003-$SYS13  00\n//SMFFIX JOB (2000,S010),WENZEL,CLASS=Z\n/*JOBPARM Q=F,I\n//STEP01   EXEC ASMFCL\n//ASM.SYSIN     DD  DISP=SHR,DSN=SYS0.LINKLIB2.SOURCE(SMFFIX)\n//LKED.SYSLMOD  DD  DISP=SHR,DSN=SYS2.LINKLIB\n//LKED.SYSIN    DD  *\n NAME  SMFFIX(R)\n/*\n./ ADD NAME=SMF234   0102-79166-80017-0727-00012-00012-00003-$SYS13  00\n//SMF234  JOB (2000,S010),WENZEL\n/*JOBPARM Q=F,I\n//STEP01   EXEC ASMFCL\n//ASM.SYSLIB  DD DISP=SHR,DSN=SYS1.MACLIB\n//        DD DISP=SHR,DSN=SYS2.MACLIB\n//        DD DISP=SHR,DSN=SYS1.AMODGEN\n//ASM.SYSIN  DD  DISP=SHR,DSN=SYS0.CMDLIB2.SOURCE(SMF234)\n//LKED.SYSLMOD  DD  DISP=SHR,DSN=SYS2.CMDLIB\n//LKED.SYSIN    DD  *\n SETCODE AC(1)\n NAME  SMF234(R)\n/*\n./ ADD NAME=STATE    0101-80017-80137-1804-00008-00008-00000-$SYS13  00\n//STATE  JOB (2000,S010),WENZEL\n/*JOBPARM Q=F,I\n//STEP01   EXEC ASMFCL,MAC1='SYS2.MACLIB'\n//ASM.SYSIN  DD  DISP=SHR,DSN=SYS0.CMDLIB2.SOURCE(STATE)\n//LKED.SYSLMOD  DD  DISP=SHR,DSN=SYS2.CMDLIB\n//LKED.SYSIN    DD  *\n NAME  STATE(R)\n/*\n./ ADD NAME=TAPEINQ  0100-80023-80023-1428-00008-00008-00000-$SYS13  00\n//TAPEINQ JOB (2000,S010),WENZEL,CLASS=Z\n/*JOBPARM Q=F,I\n//STEP01   EXEC ASMFCL,MAC1='SYS2.MACLIB'\n//ASM.SYSIN  DD  DISP=SHR,DSN=SYS0.CMDLIB2.SOURCE(TAPEINQ)\n//LKED.SYSLMOD  DD  DISP=SHR,DSN=SYS2.CMDLIB\n//LKED.SYSIN    DD  *\n NAME  TAPEINQ(R)\n/*\n./ ADD NAME=TKSPBR0D 0100-80109-80109-1414-00011-00011-00000-$SYS13  00\n//TKSPBR0D JOB (2000,S010),WENZEL,CLASS=Z\n/*JOBPARM Q=F,I\n//*\n//*         STEP 1 ASSEMBLE AND LINKEDIT TKSPBR0D\n//*\n//STEP1    EXEC ASMFCL,MAC='SYS4.JTIP.CSG.MACLIB'\n//ASM.SYSLIB DD\n//          DD UNIT=DISK,VOL=SER=ITEL01\n//ASM.SYSIN DD DSN=SYS0.CMDLIB2.SOURCE(TKSPBR0D),DISP=SHR\n//LKED.SYSLMOD DD DISP=OLD,DSN=SYS2.CMDLIB(TKSPBR0D)\n//*\n./ ADD NAME=TMSACTRT 0101-80099-80099-1532-00010-00010-00005-$SYS13  00\n//TMSACTRT JOB (2000,S010),WENZEL,CLASS=Z\n/*JOBPARM Q=F,I\n//*\n//STEP1   EXEC ASMFCL,MAC1='SYS3.TMS.TMSGEN',\n//        PARM.LKED='XREF,LET,LIST,NCAL,RENT'\n//ASM.SYSIN    DD DISP=SHR,DSN=SYS0.LINKLIB2.SOURCE(TMSACTRT)\n//LKED.SYSLMOD DD DISP=SHR,DSN=SYS2.LINKLIB\n//LKED.SYSIN   DD  *\n NAME  TMSACTRT(R)\n/*\n./ ADD NAME=TSOHOLD,SSI=00000030\n//TSOHOLD JOB (2000,S010),WENZEL,CLASS=Z\n/*JOBPARM Q=F,I\n//STEP1   EXEC ASMFCL\n//ASM.SYSIN    DD DISP=SHR,DSN=SYS0.LINKLIB2.SOURCE(TSOHOLD)\n//LKED.SYSLMOD DD DISP=SHR,DSN=SYS2.LINKLIB\n//LKED.SYSIN   DD  *\n NAME  TSOHOLD(R)\n/*\n./ ADD NAME=UICPACK  0101-80035-80036-1441-00018-00017-00000-$SYS13  00\n//UICPACK  JOB (2000,S010),WENZEL,CLASS=Z\n/*JOBPARM Q=F,I\n//DIRECT   EXEC PGM=DIRECT\n//DIRECT   DD DSN=SYS0.PSWSAMP.DIRECT,DISP=SHR\n//ANALYSIS EXEC PGM=ANALYSIS\n//SYSPRINT DD SYSOUT=*\n//PAKLIST  DD DSN=SYS0.PSWSAMP.IEAPAK00,DISP=SHR,\n//            DCB=(LRECL=80,BLKSIZE=3120,RECFM=FB)\n//DIRECT   DD DSN=SYS0.PSWSAMP.DIRECT,DISP=SHR\n//TAPE     DD DSN=SYS0.PSWSAMP.DATA,DISP=SHR\nEQUATE IEFW21SD,DEVMASKT,DEVNAMET\nEQUATE IGG0199F,IGG0199G,IGG0199W,IGG0198L\nEQUATE IGC0008C,IEFU83\nEQUATE IEEPRTN,IEEPRWI2,IEESB605\nEQUATE IEFIRECM,IEFJDSNA,IEFJJTRM,IEFJRASP,IEFJRECM,IEFJSDTN,IEFJSREQ\nEQUATE IGG0196S,IGG019T3,IGG019T4,IGG019T5,IGG019T6,IGG019T7,IGG019T8\nEQUATE IGG019T5,IGG019TX,IGG019TY,IGG019TZ\n/*\n./ ADD NAME=UICPSWAS 0101-80035-80035-1731-00021-00021-00001-$SYS13  00\n//UICPSWAS JOB (2000,S010),WENZEL,CLASS=Z\n/*JOBPARM Q=F,I\n//*\n//STEP01   EXEC PLIXCL\n//PLI.SYSIN  DD  DISP=SHR,DSN=SYS0.LINKLIB2.SOURCE(ANALYSIS)\n//LKED.SYSLMOD  DD  DISP=SHR,DSN=SYS2.LINKLIB\n//LKED.SYSIN    DD  *\n NAME  ANALYSIS(R)\n//*\n//STEP02   EXEC ASMFCL,MAC1='SYS1.AMODGEN'\n//ASM.SYSIN  DD  DISP=SHR,DSN=SYS0.LINKLIB2.SOURCE(DIRECT)\n//LKED.SYSLMOD  DD  DISP=SHR,DSN=SYS2.LINKLIB\n//LKED.SYSIN    DD  *\n NAME  DIRECT(R)\n//*\n//STEP03   EXEC ASMFCL,MAC1='SYS1.AMODGEN'\n//ASM.SYSIN  DD  DISP=SHR,DSN=SYS0.LINKLIB2.SOURCE(PSWSAMP)\n//LKED.SYSLMOD  DD  DISP=SHR,DSN=SYS2.LINKLIB\n//LKED.SYSIN    DD  *\n NAME  PSWSAMP(R)\n/*\n./ ADD NAME=USSTAB   0101-80104-80104-1613-00006-00006-00003-$SYS13  00\n//USSTAB JOB (2000,S010),WENZEL,CLASS=Z\n/*JOBPARM Q=F,I\n//*\n//STEP1   EXEC ASMFCL\n//ASM.SYSIN    DD DISP=SHR,DSN=SYS0.LINKLIB2.SOURCE(USSTAB)\n//LKED.SYSLMOD DD DISP=SHR,DSN=SYS1.VTAMLIB(USSTAB)\n./ ADD NAME=VTOCSCAN 0100-80203-80203-1139-00008-00008-00000-$SYS13  00\n//VTOCSCAN JOB (2000,S010),WENZEL,CLASS=Z\n/*JOBPARM Q=F,I\n//STEP01   EXEC ASMFCL,MAC1='SYS2.MACLIB'\n//ASM.SYSIN  DD  DISP=SHR,DSN=SYS0.LINKLIB2.SOURCE(VTOCSCAN)\n//LKED.SYSLMOD  DD  DISP=SHR,DSN=SYS2.LINKLIB\n//LKED.SYSIN    DD  *\n NAME  VTOCSCAN(R)\n/*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "LIB2FIX": {"ttr": 21769, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00$\\x01\\x19#\\x0f\\x01\\x19#\\x0f\\x14A\\x11]\\x11]\\x00\\x00\\xe3\\xd6\\xd6\\xd3\\xe2@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2019-08-18T00:00:00", "modifydate": "2019-08-18T14:41:24", "lines": 4445, "newlines": 4445, "modlines": 0, "user": "TOOLS"}, "text": "./ ADD NAME=$INDEX   0179-80013-80211-0755-00142-00104-00125-$SYS13  00\nTHIS IS THE DIRECTORY FOR THE  I T E L  SYSTEM MODIFICATIONS.\n\nSYSTEM LEVEL: MVS 3.8 FROM 7908 DLIBS, WITH PTFS 7909 THRU 7911,\nAND WITH SE V2.0 AND SAME V1.0, INSTALLED 4/13/80.\n\nBOB WENZEL     415/955-0473\n\nSYS0.SMP.SE.CNTL:      THIS DATASET CONTAINS MODIFICATIONS IN SMP4\n                       FORMAT TO SYSTEM CODE.  EACH MODIFICATION IS\n                       NAMED VS..... AND CONTAINS JCL, SMP CONTROL\n                       CARDS, AND THE MODIFICATION ITSELF.\n\nMODIFICATION NUMBERS SHOULD BE SIGNED OUT WHEN THEY ARE NEEDED\nBY MAKING A ONE LINE ENTRY IN THIS MEMBER.  THIS LINE SHOULD\nBE IN THE FOLLOWING FORMAT:\n\">MM/DD/YY VSNNNNN-ID-TITLE OF INTENDED LOCAL MODIFICATION\"\n  WHERE - '>' IS USED AS A MARKER TO LIST CHANGE HEADERS\n        - MM/DD/YY IS THE DATE APPLIED\n        - NNNNN IS A NUMBER ASSIGNED SEQUENTIALLY WITHIN VS\n\n   NOTE: THE SYSTEM SHOULD BE CONSIDERED AT THE 7911 DLIB LEVEL.\n\n************************************************************************\n\nFOLLOWING IS THE INDEX OF THE MEMBERS ACTUALLY IN THIS DATASET AND\nINSTALLED IN THE SYSTEM.\n\n************************************************************************\n>06/17/80 VS00001-$SYS13-REBUILDS SVCTABLE WITHOUT A SYSGEN.\n>04/10/80 VS00002-$SYS13-IKJEFF53: IPO-6.0 SAMPLE TSO OUTPUT/STATUS/\n                         CANCEL EXIT ROUTINE.\n>04/10/80 VS00003-$SYS13-IKJEFLD: LOGON PREPROMPT EXIT FOR TSOHOLD.\n>04/10/80 VS00004-$SYS13-SGIEC0PT: ADD LOCAL PROGRAM NAMES TO PROGRAM\n                         PROPERTIES TABLE (PPT).\n>04/10/80 VS00005-$SYS03-UCC_ONE(TMS): PUT HOOKS INTO IFG0194A,\n                         IGC0001I, IGC00020, & IGC0005E.\n>04/10/80 VS00006-$SYS13-IKJEFTE2/IKJEFTE8: ADD LOCAL AUTHORIZED\n                         COMMAND PROCESSORS/PROGRAMS TO THE LIST OF\n                         THOSE INVOKED BY THE TSO TMP/CALL COMMAND\n                         AND COMMAND PROCESSORS FOR ASM2.\n>04/10/80 VS00007-$SYS03-ABEND-AID/TOMARK: FRONT-END IGC0005A.\n>07/08/80 VS00008-$SYS13-SPFIJTIP FETCH/VERFYQEL: INSTALL JTIP\n                         INTERFACE. ALLOW $SYS AND $RJE USERS TO FETCH,\n                         SHOW, PURGE AND ROUTE BY JOB, REGARDLESS OF\n                         JOBNAME.\n>04/10/80 VS00009-$SYS13-IKJEBELE: MAKE 3270 LOGICAL TAB SIGN (\"CENT\")\n                         GOOD FOR ALL TERMINALS.\n>04/11/80 VS00010-$SYS13-IEFUJI IEFUSI IEFUTL: INSTALLATION OF IEFUJI,\n                         IEFUSI AND IEFUTL.\n>04/  /80 VS00011-HOLD  -IEANUC01: FRONT END IGC018 FOR DYNAMIC BLDL.\n>05/17/80 VS00012-$SYS13-IKJEFLE: 1) RESET PROFILE PREFIX TO BE THAT OF\n                         USERID, & 2) SAVE ACCOUNT NUMBER IN UPTUSER.\n>04/10/80 VS00013-$SYS13-IKJEBECI,IKJEGCIV: ELIMINATE BLDL FOR TSO EDIT\n                         AND TEST SUB-COMMANDS.\n>  /  /80 VS00014-$SYS13-IEFU83:\n>04/10/80 VS00015-$SYS13-IKJEBESA: HAVE TSO EDIT \"RLSE\" ON NEW DATASETS.\n>04/10/80 VS00016-$SYS13-WYLBUR: ADD SVC 249 (IGC0024I) TO LPALIB.\n>04/10/80 VS00017-$SYS03-JES2(HASPPRPU): PUT THE JOB NAME ON THE PUNCH\n                         SEPARATOR CARD.\n>04/10/80 VS00018-$SYS03-JES2(HASPRDR): SET THE DEFAULT MSGCLASS TO \"A\"\n                         FOR A TSO-SUBMITTED JOB. NOT NEEDED IF TSO\n                         COMMAND PACKAGE IS INSTALLED FMID(JBB1112).\n>04/11/80 VS00019-$SYS13 IDMS: SVC 219.\n>04/10/80 VS00020-$SYS13-UCLIN: ADD LINKLIB MODULES TO LPALIB (IEBCOPY/\n                         UCLIN).\n>04/11/80 VS00021-$SYS13-SYNCSORT: ADD MODULES IGX00017 AND WCSREENT\n                         TO LPALIB.\n>04/10/80 VS00022-$SYS03-UCC_ONE(TMS): ADD MODULES IGC..24G, IGC..24H\n                         TO LPALIB.\n>04/10/80 VS00023-$SYS13-IEFACTRT: INSTALLATION OF IEFACTRT, HAS COREQ\n                         OF VS00024.\n>04/10/80 VS00024-$SYS13-IEECVXIT: INSTALLATION OF IEECVXIT, HAS COREQ\n                         OF VS00023.\n>04/11/80 VS00025-$SYS03-JTIP: MODIFIES ALMOST ALL OF JES2.\n>04/16/80 VS00026-$SYS03-JTIP: IKJEBEMA AND IGC0023I AND JTIP COMMANDS\n>  /  /   VS00027-HOLD  -IEFAB4A2: DON'T ABEND ON \"NOT CATLG 2\".\n>04/28/80 VS00028-$SYS13-LINKLIB: ADD OZLIB MODULES TO LINKLIB (IEBCOPY/\n                         UCLIN) FOR INFORMATION SYSTEMS.\n>04/10/80 VS00029-$SYS13-IECVHIDT: CHANGED HOT I/O DEFAULT VALUES.\n>04/11/80 VS00030-$SYS13-CICS: INSTALL TYPE 4 SVC 214 FOR PAGE FIX, AND\n                         TYPE 6 SVC 215 FOR HIGH PERFORMANCE.\n>04/10/80 VS00031-$SYS13-AZ25758: CIR. 106-C'S BY COPYING SOME SU33\n                         MODULES FROM LINKLIB TO LPALIB.\n>04/10/80 VS00032-$SYS13-IEECVETC: INVOKE DIDOCS TO SET-UP CONSOLES IN\n                         ROLL DELETABLE MODE.\n>04/10/80 VS00033-$SYS03-JES2(HASPPRPU): MULTICOPY PAGE SEPARATOR.\n>04/11/80 VS00034-$SYS13-VSCOBOL: MOVE REENTRANT MODULES TO LPALIB,\n                         DID NOT USE SMP... TOO MANY MODULES AND\n                         ALIASES.\n>  /  /   VS00035-HOLD  -AGENLIB: MODIFY GENERATE, JOBCARD, SGASMPAK,\n                         SGIFB600,SGLEDPK1,TSASMPAK TO PRODUCE \"BETTER\"\n>04/17/80 VS00036-$SYS13-SPFCOPY: INSTALL SPFCOPY WHICH ENABLES SPF TO\n                         DO A COMPRESS.\n>04/17/80 VS00037-$SYS13-SPFIPAN: INSTALL PANVALET SPF INTERFACE.\n>04/10/80 VS00038-$SYS13-IKJEFD30: CHANGE DEFAULT ALLOCATE DISPOSITION\n                         FROM \"OLD\" TO \"SHR\".\n>04/10/80 VS00039-$SYS03-JTIP: 27MAR79 FIXES.\n>06/19/80 VS00040-$SYS13-JARSCICS: INSTALL SVC TYPE 3 (237) FOR WRITING\n                         SMF RECORDS, AND SVC TYPE 6 (208) FOR SAMPLING\n                         CPU REAL TIME FOR TESTCICS.\n>04/10/80 VS00041-$SYS13-UCLIN: ADD CMDLIB MODULES TO LPALIB (IEBCOPY/\n                         UCLIN).\n>06/06/80 VS00042-$SYS13-SGIEE0MS: CHANGE  MSTRJCL TO NOT START JES2\n>04/17/80 VS00043-$SYS03-ASM2: ZAP IFG0196W, ADD IGC0023H.\n                         ASSOCIATED MEMBERS ARE VS00043I AND VS00043O.\n                         VS00043I IS THE INPUT TO VS00043.\n                         VS00043O IS THE ZAPS GENERATED BY VS00043I AND\n                         INPUT FOR SMPPTFIN.\n>06/09/10 VS00044-$SYS13-HMASMUC1:  CICS STAGE2 GEN PRODUCES UCLIN CARDS\n                         TO UPDATE CDS MACRO ENTRIES AND HAS PROBLEMS\n                         PROBLEM IR10797 FOR MORE DETAILS.\n>06/17/80 VS00045-$SYS13-CICS: INSTALL TYPE 4 SVC 245 FOR PAGE FIX,\n                         TYPE 2 SVC 229 FOR INTER REGION COMMUNICATIONS\n                         AND TYPE 6 SVC 209 FOR HIGH PERFORMANCE OPTION.\n>06/18/80 VS00046-$SYS13-IEDAYW IEDQ21: ALLOW CERTAIN CONTROL CHARACTERS\n                         FOR TTY COMPATIBLE TERMINALS AND REPLACE TTY\n                         TRANSLATE TABEL IEDQ21.\n>07/09/80 VS00047-$SYS13-JES2(HASPPRPU): MAKE PRINT TRAIN TN WORK\n                         CORRECTLY WITH &PRTRANS=YES SPECIFIED.\n>07/01/80 VS00048-$SYS13-JARSCICS: INSTALL SVC TYPE 3 (236) FOR WRITING\n                         SMF RECORDS, AND SVC TYPE 6 (207) FOR SAMPLING\n                         CPU REAL TIME FOR PRODCICS.\n>04/10/80 VS00053-$SYS03-JTIP: 6MAR80 FIXES DUE TO UZ26743/7909,PER UIC\n>07/20/80 VS00054-$CSG05-ASM2: REL 2.5 MOD TO IFG0196W\n>07/20/80 VS00055-$CSG05-ASM2: REL 2.5 MOD TO IFG0194C\n>07/20/80 VS00056-$CSG05-ASM2: REL 2.5 MOD TO IDA0192C\n\n\n\n************************************************************************\n\nFOLLOWING ARE ONLY COMMENTS, TAKEN FROM THE OLD MEMOREX SYS0.SMP.CNTL.\n\n************************************************************************\n\n>  /  /   FDR1   -$SYS  -FIX TO SLOWDOWN BACKUPS.\n>  /  /   PCF1   -$SYS  -FIX TO IMPROVE CLIST PROCESSING.\n>  /  /   VS00030-$SYS  -CCWTRACE:\n>  /  /   VS00048-$SYS  -IEANUC01: FRONT-END IGC018 FOR DYNAMIC BLDL.\n>  /  /   VS00049-$SYS  -SPFSUBS: LOG/LIST DATA SETS TO TSOSPF PACK\n>  /  /   VS00050-$SYS  -NETWORK SOLICITOR DCNS MESSAGE\n                         ADD SUBROUTINE FOR COMPILERS\n./ ADD NAME=SMPLIST  0101-80130-80130-1531-00006-00024-00003-$SYS13  00\n//SMPLIST JOB (2000,S010),WENZEL,CLASS=Z\n/*JOBPARM Q=F,I\n//STEP1  EXEC IPOSMP4\n//SYSIN    DD *\n LIST CDS SYSMOD USERMOD APAR PTF.\n/*\n./ ADD NAME=SMPLIST1 0101-80204-80204-1134-00006-00006-00001-$SYS13  00\n//SMPLIST1 JOB (2000,S010),WENZEL,CLASS=Z\n/*JOBPARM Q=F,I\n//STEP1  EXEC IPOSMP4\n//SYSIN    DD *\n LIST CDS SYSMOD USERMOD APAR PTF.\n/*\n./ ADD NAME=SMPLIST2 0101-80204-80204-1136-00006-00006-00002-$SYS13  00\n//SMPLIST2 JOB (2000,S010),WENZEL,CLASS=Z\n/*JOBPARM Q=F,I\n//STEP1  EXEC IPOSMP4\n//SYSIN    DD *\n LIST CDS SYSMOD NOACCEPT.\n/*\n./ ADD NAME=VS00001  3814-80010-80169-1814-00087-00132-00046-$SYS13  00\n//VS00001  JOB (2000,S010),WENZEL,CLASS=Z\n/*JOBPARM Q=F,I\n//*\n//*  IPO-6.0\n//*\n//* REFER IPO60.JCLLIB(SVCTBL)\n//* COMPID SYSTEMS\n//* DOC    THIS JOB IS EXAMPLE OF HOW THE SVCTABLE CAN BE REBUILT\n//*        WITHOUT A SYSGEN\n//*\n//* STEPNAME   DESCRIPTION\n//* ________   ______________________________________________________\n//* SVCGEN     ASSEMBLE MINI GEN FOR SVCTABLE JOB STEP\n//* TSOEDIT    SELECT ONLY ASSEMBLER INPUT FOR SVCTABLE\n//* ASMSVC     ASSEMBLE NEW SVC TABLE\n//* SMPSVC     USE SMP TO INCLUDE NEW SVC TABLE INTO SYSTEM\n//*\n//* NOTES:\n//*      1) THIS JOB REASSEMBLES THE SVCTABLE SYSGEN MACRO,\n//*         THUS THE COMPLETE SVCTABLE IS REPLACED IN THE NUCLEUS.\n//*         TO THIS END THE SVCTABLE MACRO MUST BE SPECIFIED IN\n//*         ITS ENTIRETY, AS IT WOULD BE SPECIFIED IN A SYSGEN.\n//*\n//*      2) REFER TO THE SPL: SYSGEN FOR CODING OF THE SVCTABLE\n//*         MACRO.\n//*\n//SVCGEN  EXEC PGM=IFOX00,PARM='DECK,NOLOAD',TIME=5,REGION=5000K\n//SYSPRINT DD SYSOUT=*\n//SYSLIB   DD DISP=SHR,DSN=SYS2.AGENLIB,DCB=BLKSIZE=19040\n//         DD DISP=SHR,DSN=SYS1.AGENLIB,UNIT=DISK,VOL=SER=ITEL02\n//         DD DISP=SHR,DSN=SYS1.AMODGEN,UNIT=DISK,VOL=SER=ITEL02\n//         DD DISP=SHR,DSN=SYS1.AMACLIB,UNIT=DISK,VOL=SER=ITEL02\n//SYSUT1   DD UNIT=VIO,SPACE=(6233,(152,38),,,ROUND)\n//SYSUT2   DD UNIT=VIO,SPACE=(6233,(152,38),,,ROUND)\n//SYSUT3   DD UNIT=VIO,SPACE=(6233,(152,38),,,ROUND)\n//SYSPUNCH DD DSN=SYS0.SMP.SE.CNTL(VS00001O),\n//         DCB=(LRECL=80,RECFM=FB,BLKSIZE=3120),\n//         DISP=OLD\n//SYSIN    DD DISP=SHR,DSN=SYS0.GENLIB.SE.CNTL(STAGE1A)\n//         DD DISP=SHR,DSN=SYS0.GENLIB.SE.CNTL(SVCTABLE)\n//         DD DISP=SHR,DSN=SYS0.GENLIB.SE.CNTL(DUMMY1B)\n//********************************************************************\n//*\n//* EDIT SVCTABLE ASSEMBLER STATEMENTS FROM JOB STEP PRODUCED IN THE\n//*      PREVIOUS STEP\n//*\n//********************************************************************\n//TSOEDIT EXEC PGM=IKJEFT01,DYNAMNBR=5,COND=(0,NE)\n//SYSTSPRT DD SYSOUT=*\n//SYSTSIN  DD *\nE 'SYS0.SMP.SE.CNTL(VS00001O)' DATA\nDEL * 1230\nDOWN 5\nF X/X 1\nDEL * 99999\nS\nEND\n/*\n//********************************************************************\n//*\n//* ASSEMBLE  NEW SVC TABLE: OBJECT OUTPUT TO SYS1.OBJPDS03(IEASVC00)\n//*\n//********************************************************************\n//ASMSVC EXEC ASMS,OBJ=OBJPDS03,MOD=IEASVC00,\n//           CLASS='A',COND=(0,NE)\n//SYSIN      DD  DISP=OLD,DSN=SYS0.SMP.SE.CNTL(VS00001O)\n//********************************************************************\n//*\n//* USE SMP TO UPDATE NUCLEUS WITH THE NEW SVCTABLE\n//*\n//********************************************************************\n//VS00001  EXEC IPOSMP4,COND=(0,NE),RES=ITEL01\n//SMPJCLIN   DD DSN=*.SVCGEN.SYSPUNCH,DISP=OLD,\n//           VOL=REF=*.SVCGEN.SYSPUNCH\n//OBJECT     DD DSN=*.ASMSVC.A.SYSPUNCH,DISP=OLD,\n//           VOL=REF=*.ASMSVC.A.SYSPUNCH\n//SYSIN    DD *\n REJECT  S(VS00001).\n RECEIVE S(VS00001).\n APPLY   S(VS00001).\n LIST CDS SYSMOD(VS00001) .\n//SMPPTFIN   DD *\n++ USERMOD (VS00001) .\n++ VER (Z038) FMID(JBB1222) .\n++JCLIN TXLIB(SMPJCLIN) .\n++ MOD (IEASVC00) TXLIB(OBJECT).\n//********************************************************************\n./ ADD NAME=VS00001O\n      PRINT ON,NODATA\nSVCTABLE   CSECT\n DS    0D\n DC V(IGC000),X'00008000'\n DC V(IGC001),B'00000000000000001000000000000000'\n DC V(IGC002),B'00000000000000001000000000000000'\n DC V(IGC003),B'00000000000000001000000000000000'\n DC V(IGC004),B'00000000000000001000000000000000'\n DC V(IGC005),B'00000000000000001000000000000000'\n DC V(IGC006),B'10000000000000001000000000000000'\n DC V(IGC007),B'10000000000000001000000000000000'\n DC V(IGC008),B'10000000000000001000000000000000'\n DC V(IGC009),B'10000000000000001000000000000000'\n DC V(IGC010),B'00000000000000001000000000000000'\n DC A(0),B'11000000000000000000000000000000'\n DC V(IGC012),B'10000000000000001000000000000000'\n DC A(0),B'11000000000000000000000000000000'\n DC A(0),B'11000000000000001000000000000000'\n DC V(IGC015),B'00000000000000001000000000000000'\n DC A(0),B'11000000000000000000000000000000'\n DC A(0),B'11000000000000000000000000000000'\n DC V(IGC018),B'10000000000000000000000000000000'\n DC A(0),B'11000000000000000000000000000000'\n DC A(0),B'11000000000000000000000000000000'\n DC A(0),B'11000000000000000000000000000000'\n DC A(0),B'11000000000000000000000000000000'\n DC A(0),B'11000000000000000000000000000000'\n DC A(0),B'11000000000000000000000000000000'\n DC A(0),B'11000000000000000000000000000000'\n DC A(0),B'11000000000000000000000000000000'\n DC A(0),B'11000000000000000000000000000000'\n DC V(IGCERROR),B'10000000000000000000000000000000'\n DC A(0),B'11000000000000000000000000000000'\n DC A(0),B'11000000000000000000000000000000'\n DC A(0),B'11000000000000000000000000000000'\n DC A(0),B'11001000000000000000000000000000'\n DC A(0),B'11000000000000000000000000000000'\n DC A(0),B'11000000000000000000000000000000'\n DC A(0),B'11000000000000000000000000000000'\n DC A(0),B'11000000000000000000000000000000'\n DC V(IGC037),B'10000000000000000000000000000000'\n DC V(IGCERROR),B'10000000000000000000000000000000'\n DC A(0),B'11001000000000000000000000000000'\n DC A(0),B'11000000000000001000000000000000'\n DC A(0),B'11000000000000001000000000000000'\n DC A(0),B'11000000000000000000000000000000'\n DC V(IGC043),B'00000000000000001000000000000000'\n DC V(IGC044),B'10000000000000001000000000000000'\n DC V(IGC045),B'10000000000000000000000000000000'\n DC A(0),B'11000000000000000000000000000000'\n DC A(0),B'11000000000000000000000000000000'\n DC V(IGC048),B'10000000000000000000000000000000'\n DC V(IGCERROR),B'10000000000000000000000000000000'\n DC A(IGCRETRN),B'00000000000000000000000000000000'\n DC A(0),B'11000000000000001000000000000000'\n DC A(0),B'11001000000000000000000000000000'\n DC A(0),B'11000000000000000000000000000000'\n DC A(0),B'11000000000000001000000000000000'\n DC A(0),B'11000000000000000000000000000000'\n DC V(IGC056),B'10000000000000000000000000000000'\n DC A(0),B'11000000000000000000000000000000'\n DC V(IGC058),B'00000000000000001000000000000000'\n DC A(0),B'11000000000000000000000000000000'\n DC A(0),B'11000000000000000000000000000000'\n DC A(0),B'11000000000000001000000000000000'\n DC V(IGC062),B'10000000000000001000000000000000'\n DC A(0),B'11000000000000000000000000000000'\n DC A(0),B'11000000000000000000000000000000'\n DC V(IGCERROR),B'10000000000000000000000000000000'\n DC A(0),B'11000000000000000000000000000000'\n DC V(IGCERROR),B'10000000000000000000000000000000'\n DC A(0),B'11000000000000000000000000000000'\n DC A(0),B'11000000000000000000000000000000'\n DC V(IGC070),B'10000000000000001000000000000000'\n DC V(IGCERROR),B'10000000000000000000000000000000'\n DC A(0),B'11000000000000000000000000000000'\n DC V(IGCERROR),B'10000000000000000000000000000000'\n DC V(IGCERROR),B'10000000000000000000000000000000'\n DC V(IGCERROR),B'10000000000000000000000000000000'\n DC A(0),B'11001000000000000000000000000000'\n DC V(IGCERROR),B'10000000000000000000000000000000'\n DC A(0),B'11000000000000000000000000000000'\n DC V(IGC079),B'10000000000000001000000000000000'\n DC V(IGCERROR),B'10000000000000000000000000000000'\n DC A(0),B'11000000000000000000000000000000'\n DC A(0),B'11001000000000000000000000000000'\n DC A(0),B'11001000000000000000000000000000'\n DC V(IGC084),B'00000000000000001000000000000000'\n DC A(0),B'11001000000000000000000000000000'\n DC A(0),B'11001000000000000000000000000000'\n DC A(0),B'11000000000000000000000000000000'\n DC A(0),B'11000000000000000000000000000000'\n DC V(IGCERROR),B'10000000000000000000000000000000'\n DC V(IGCERROR),B'10000000000000000000000000000000'\n DC A(0),B'11000000000000000000000000000000'\n DC V(IGC092),B'00000000000000001000000000000000'\n DC A(0),B'11000000000000001000000000000000'\n DC A(0),B'11000000000000000000000000000000'\n DC V(IGC095),B'00000000000000001000000000000000'\n DC A(0),B'11000000000000001000000000000000'\n DC A(0),B'11000000000000001000000000000000'\n DC A(0),B'11000000000000000000000000000000'\n DC A(0),B'11000000000000000000000000000000'\n DC A(0),B'11000000000000000000000000000000'\n DC A(IGCRETRN),B'00000000000000001100000000000000'\n DC A(0),B'11000000000000001000000000000000'\n DC A(0),B'11000000000000000000000000000000'\n DC A(0),B'11001000000000000000000000000000'\n DC A(0),B'11000000000000000000000000000000'\n DC V(IGCERROR),B'10000000000000000000000000000000'\n DC V(IGC107),B'00101000000000000000000000000000'\n DC V(IGCERROR),B'10000000000000000000000000000000'\n DC V(IGC109),B'10000000000000000000000000000000'\n DC A(0),B'11000000000000000000000000000000'\n DC V(IGC111),B'10000000000000000000000000000000'\n DC V(IGC112),B'00000000000000001000000000000000'\n DC V(IGC113),B'00000000000000001000000000000000'\n DC V(IGC114),B'00000000000000001000000000000000'\n DC V(IGCERROR),B'10000000000000000000000000000000'\n DC V(IGC116),B'00000000000000001000000000000000'\n DC V(IGC117),B'10000000000000001000000000000000'\n DC V(IGCERROR),B'10000000000000000000000000000000'\n DC V(IGC119),B'00000000000000001000000000000000'\n DC V(IGC120),B'00000000000000001000000000000000'\n DC V(IGC121),B'00000000000000001000000000000000'\n DC V(IGC122),B'10000000000000000000000000000000'\n DC V(IGC123),B'10001000000000000000000000000000'\n DC V(IGC124),B'00000000000000001000000000000000'\n DC V(IGC125),B'00000000000000001000000000000000'\n DC V(IGCERROR),B'10000000000000000000000000000000'\n DC V(IGCERROR),B'10000000000000000000000000000000'\n DC V(IGCERROR),B'10000000000000000000000000000000'\n DC V(IGCERROR),B'10000000000000000000000000000000'\n DC A(0),B'11000000000000000000000000000000'\n DC A(0),B'11001000000000000000000000000000'\n DC A(0),B'11001000000000000000000000000000'\n DC A(0),B'11001000000000000000000000000000'\n DC V(IGCERROR),B'10000000000000000000000000000000'\n DC V(IGCERROR),B'10000000000000000000000000000000'\n DC V(IGCERROR),B'10000000000000000000000000000000'\n DC V(IGC137),B'00100000000000000000000000000000'\n DC V(IGCERROR),B'10000000000000000000000000000000'\n DC V(IGCERROR),B'10000000000000000000000000000000'\n DC V(IGCERROR),B'10000000000000000000000000000000'\n DC V(IGCERROR),B'10000000000000000000000000000000'\n DC V(IGCERROR),B'10000000000000000000000000000000'\n DC V(IGCERROR),B'10000000000000000000000000000000'\n DC V(IGCERROR),B'10000000000000000000000000000000'\n DC V(IGCERROR),B'10000000000000000000000000000000'\n DC V(IGCERROR),B'10000000000000000000000000000000'\n DC V(IGCERROR),B'10000000000000000000000000000000'\n DC V(IGCERROR),B'10000000000000000000000000000000'\n DC V(IGCERROR),B'10000000000000000000000000000000'\n DC V(IGCERROR),B'10000000000000000000000000000000'\n DC V(IGCERROR),B'10000000000000000000000000000000'\n DC V(IGCERROR),B'10000000000000000000000000000000'\n DC V(IGCERROR),B'10000000000000000000000000000000'\n DC V(IGCERROR),B'10000000000000000000000000000000'\n DC V(IGCERROR),B'10000000000000000000000000000000'\n DC V(IGCERROR),B'10000000000000000000000000000000'\n DC V(IGCERROR),B'10000000000000000000000000000000'\n DC V(IGCERROR),B'10000000000000000000000000000000'\n DC V(IGCERROR),B'10000000000000000000000000000000'\n DC V(IGCERROR),B'10000000000000000000000000000000'\n DC V(IGCERROR),B'10000000000000000000000000000000'\n DC V(IGCERROR),B'10000000000000000000000000000000'\n DC V(IGCERROR),B'10000000000000000000000000000000'\n DC V(IGCERROR),B'10000000000000000000000000000000'\n DC V(IGCERROR),B'10000000000000000000000000000000'\n DC V(IGCERROR),B'10000000000000000000000000000000'\n DC V(IGCERROR),B'10000000000000000000000000000000'\n DC V(IGCERROR),B'10000000000000000000000000000000'\n DC V(IGCERROR),B'10000000000000000000000000000000'\n DC V(IGCERROR),B'10000000000000000000000000000000'\n DC V(IGCERROR),B'10000000000000000000000000000000'\n DC V(IGCERROR),B'10000000000000000000000000000000'\n DC V(IGCERROR),B'10000000000000000000000000000000'\n DC V(IGCERROR),B'10000000000000000000000000000000'\n DC V(IGCERROR),B'10000000000000000000000000000000'\n DC V(IGCERROR),B'10000000000000000000000000000000'\n DC V(IGCERROR),B'10000000000000000000000000000000'\n DC V(IGCERROR),B'10000000000000000000000000000000'\n DC V(IGCERROR),B'10000000000000000000000000000000'\n DC V(IGCERROR),B'10000000000000000000000000000000'\n DC V(IGCERROR),B'10000000000000000000000000000000'\n DC V(IGCERROR),B'10000000000000000000000000000000'\n DC V(IGCERROR),B'10000000000000000000000000000000'\n DC V(IGCERROR),B'10000000000000000000000000000000'\n DC V(IGCERROR),B'10000000000000000000000000000000'\n DC V(IGCERROR),B'10000000000000000000000000000000'\n DC V(IGCERROR),B'10000000000000000000000000000000'\n DC V(IGCERROR),B'10000000000000000000000000000000'\n DC V(IGCERROR),B'10000000000000000000000000000000'\n DC V(IGCERROR),B'10000000000000000000000000000000'\n DC V(IGCERROR),B'10000000000000000000000000000000'\n DC V(IGCERROR),B'10000000000000000000000000000000'\n DC V(IGCERROR),B'10000000000000000000000000000000'\n DC V(IGCERROR),B'10000000000000000000000000000000'\n DC V(IGCERROR),B'10000000000000000000000000000000'\n DC V(IGCERROR),B'10000000000000000000000000000000'\n DC V(IGCERROR),B'10000000000000000000000000000000'\n DC V(IGCERROR),B'10000000000000000000000000000000'\n DC V(IGCERROR),B'10000000000000000000000000000000'\n DC A(IGCRETRN),B'00000000000000000000000000000000'\n DC A(IGCRETRN),B'00000000000000000000000000000000'\n DC A(IGCRETRN),B'00000000000000000000000000000000'\n DC A(IGCRETRN),B'00000000000000000000000000000000'\n DC A(IGCRETRN),B'00000000000000000000000000000000'\n DC A(IGCRETRN),B'00000000000000000000000000000000'\n DC A(IGCRETRN),B'00000000000000000000000000000000'\n DC V(IGC207),B'00100000000000000000000000000000'\n DC V(IGC208),B'00100000000000000000000000000000'\n DC V(IGC209),B'00100000000000000000000000000000'\n DC A(IGCRETRN),B'00000000000000000000000000000000'\n DC A(IGCRETRN),B'00000000000000000000000000000000'\n DC A(IGCRETRN),B'00000000000000000000000000000000'\n DC A(IGCRETRN),B'00000000000000000000000000000000'\n DC A(0),B'11000000000000000000000000000000'\n DC V(IGC215),B'00100000000000000000000000000000'\n DC A(IGCRETRN),B'00000000000000000000000000000000'\n DC A(IGCRETRN),B'00000000000000000000000000000000'\n DC A(IGCRETRN),B'00000000000000000000000000000000'\n DC V(IGC219),B'00000000000000001000000000000000'\n DC A(IGCRETRN),B'00000000000000000000000000000000'\n DC A(IGCRETRN),B'00000000000000000000000000000000'\n DC A(IGCRETRN),B'00000000000000000000000000000000'\n DC A(IGCRETRN),B'00000000000000000000000000000000'\n DC A(IGCRETRN),B'00000000000000000000000000000000'\n DC A(IGCRETRN),B'00000000000000000000000000000000'\n DC A(IGCRETRN),B'00000000000000000000000000000000'\n DC A(IGCRETRN),B'00000000000000000000000000000000'\n DC A(IGCRETRN),B'00000000000000000000000000000000'\n DC V(IGC229),B'10000000000000000000000000000000'\n DC A(IGCRETRN),B'00000000000000000000000000000000'\n DC A(IGCRETRN),B'00000000000000000000000000000000'\n DC A(IGCRETRN),B'00000000000000000000000000000000'\n DC A(IGCRETRN),B'00000000000000000000000000000000'\n DC A(0),B'11000000000000000000000000000000'\n DC A(0),B'11000000000000000000000000000000'\n DC A(0),B'11000000000000000000000000000000'\n DC A(0),B'11000000000000000000000000000000'\n DC A(0),B'11000000000000000000000000000000'\n DC A(0),B'11000000000000000000000000000000'\n DC A(IGCRETRN),B'00000000000000000000000000000000'\n DC A(IGCRETRN),B'00000000000000000000000000000000'\n DC A(IGCRETRN),B'00000000000000000000000000000000'\n DC A(IGCRETRN),B'00000000000000000000000000000000'\n DC A(IGCRETRN),B'00000000000000000000000000000000'\n DC A(0),B'11000000000000000000000000000000'\n DC A(0),B'11000000000000000000000000000000'\n DC A(0),B'11000000000000000000000000000000'\n DC A(0),B'11000000000000000000000000000000'\n DC A(0),B'11000000000000000000000000000000'\n DC A(IGCRETRN),B'00000000000000000000000000000000'\n DC A(IGCRETRN),B'00000000000000000000000000000000'\n DC A(IGCRETRN),B'00000000000000000000000000000000'\n DC A(IGCRETRN),B'00000000000000000000000000000000'\n DC A(IGCRETRN),B'00000000000000000000000000000000'\n DC A(IGCRETRN),B'00000000000000000000000000000000'\nIGCRETRN SR    15,15\n         BR    14\n         END\n./ ADD NAME=VS000019 0100-80169-80169-1730-00132-00132-00000-$SYS13  00\n//VS00001  JOB (2000,S010),WENZEL,CLASS=Z\n/*JOBPARM Q=F,I\n//*\n//*  IPO-6.0\n//*\n//* REFER IPO60.JCLLIB(SVCTBL)\n//* COMPID SYSTEMS\n//* DOC    THIS JOB IS EXAMPLE OF HOW THE SVCTABLE CAN BE REBUILT\n//*        WITHOUT A SYSGEN\n//*\n//* STEPNAME   DESCRIPTION\n//* ________   ______________________________________________________\n//* SVCGEN     ASSEMBLE MINI GEN FOR SVCTABLE JOB STEP\n//* SELECT     SELECT ONLY ASSEMBLER INPUT FROM JOB STEP\n//* ASMSVC     ASSEMBLE NEW SVC TABLE\n//* SMPSVC     USE SMP TO INCLUDE NEW SVC TABLE INTO SYSTEM\n//*\n//* NOTES:\n//*      1) THIS JOB REASSEMBLES THE SVCTABLE SYSGEN MACRO,\n//*         THUS THE COMPLETE SVCTABLE IS REPLACED IN THE NUCLEUS.\n//*         TO THIS END THE SVCTABLE MACRO MUST BE SPECIFIED IN\n//*         ITS ENTIRETY, AS IT WOULD BE SPECIFIED IN A SYSGEN.\n//*\n//*      2) SINCE THIS ASSEMBLY IS TAKEN OUT OF THE SCOPE OF A\n//*         COMPLETE SET OF SYSGEN MACROS CERTAIN SYSGEN ASSEMBLER\n//*         VARIABLES MUST BE PRESET AS NOTED IN THE ASSEMBLY BELOW.\n//*\n//*      3) REFER TO THE SPL: SYSGEN FOR CODING OF THE SVCTABLE\n//*         MACRO.\n//SVCGEN EXEC PGM=IFOX00,PARM='DECK,NOLOAD'\n//SYSLIB DD DSN=SYS1.AGENLIB,UNIT=DISK,VOL=SER=ITEL02,DISP=SHR\n//       DD DSN=SYS1.MACLIB,UNIT=DISK,DISP=SHR\n//SYSUT1 DD UNIT=VIO,SPACE=(CYL,(5,5))\n//SYSUT2 DD UNIT=VIO,SPACE=(CYL,(5,5))\n//SYSUT3 DD UNIT=VIO,SPACE=(CYL,(5,5))\n//SYSPRINT DD  SYSOUT=*\n//SYSPUNCH DD  DSN=SYS0.LINKLIB2.OBJ(VS00001),DISP=OLD\n//SYSIN    DD    *,DCB=BLKSIZE=19040\n**********************************************************************\n*                                                                    *\n*        PRE-SET SELECTED GLOBAL SYSGEN VARIABLES                    *\n*                                                                    *\n**********************************************************************\n         PRINT OFF\n         COPY  SGGBLPAK  BRING IN SYSGEN GLOBAL VARIABLES\n         PRINT ON\n&SGMENTB(16) SETB 1      AND OVERRIDE DIAGNOSTIC SWITCH .\n&SGCTRLC(41) SETC '*'        CLASS= PARM ON ASMS PROC\n&SGCTRLC(05) SETC 'OBJPDS03' OBJ=   PARM ON ASMS PROC\n**********************************************************************\n*        CHANGE THE FOLLOWING TO CONFORM TO FULLGEN OPTIONS          *\n*               THEY ARE INITIALIZED TO THE FULLGEN OPTIONS          *\n*               AS DISTRIBUTED ON THE MVS SYSTEM IPO SYSTEM AND      *\n*               AND SHOULD NOT HAVE TO BE CHANGED                    *\n**********************************************************************\n&SGMENTB(12) SETB 0          0=> NO GAM,  1=> GAM    FULLGEN OPTION\n&SGDMGTB(06) SETB 1          0=> NO VTAM  1=> VTAM   FULLGEN OPTION\n**********************************************************************\n*__________________ READ THIS ________________________________       *\n*                                                                    *\n*        CHANGE THE FOLLOWING TO CONFORM TO YOUR IOGEN OPTIONS       *\n*          THE VARIABLES CAN TAKE ON A VALUE OF 0 OR 1               *\n*          0 MEANING THE OPTION WAS NOT SPECIFIED                    *\n*          1 MEANING THE OPTION WAS SPECIFIED                        *\n**********************************************************************\n&SGDCLSB(09) SETB 0          0=> NO 2250  1=> 2250   IOGEN OPTION\n&SGDCLSB(28) SETB 0          0=> NO 3851  1=> 3851   IOGEN OPTION\n             SPACE\n**********************************************************************\n*                                                                    *\n*        ENTER YOUR SVCTABLE MACRO WITH YOUR SVCS                    *\n*           -- WATCH YOUR CONTINUATIONS --                           *\n**********************************************************************\n//         DD  DSN=SYS0.GENLIB.SE.CNTL(SVCTABLE),DISP=SHR\n//         DD  *\n**********************************************************************\n*                                                                    *\n*        ISSUE SYSGEN MACROS TO PUNCH SVCTABLE ASSEMBLY STEP         *\n*                                                                    *\n**********************************************************************\n         SGIEI1SV                  MACRO TO INCLUDE SYSTEM SVCS\n         SGIEA201                  MACRO TO PUNCH ASSEMBLY STEP\n         END\n//********************************************************************\n//*\n//* SELECT ASSEMBLER STATEMENTS FROM JOB STEP PRODUCED IN THE\n//*        PREVIOUS STEP\n//*\n//********************************************************************\n//SELECT EXEC PGM=IEBGENER,COND=(0,NE)\n//SYSPRINT DD SYSOUT=*\n//SYSUT1   DD DSN=*.SVCGEN.SYSPUNCH,DISP=OLD,\n//         VOL=REF=*.SVCGEN.SYSPUNCH\n//SYSUT2   DD DSN=&&PASS,DISP=(,PASS),\n//         UNIT=DISK,SPACE=(CYL,(5,1,1)),\n//         DCB=(RECFM=FB,LRECL=80,BLKSIZE=800)\n//SYSIN    DD *\n  GENERATE MAXNAME=3,MAXGPS=32\n  MEMBER   NAME=DUMMY1\n  RECORD   IDENT=(8,'//SYSIN ',1)\n  MEMBER   NAME=IEASVC00\n  RECORD   IDENT=(5,' END ',9)\n//********************************************************************\n//*\n//* ASSEMBLE  NEW SVC TABLE: OBJECT OUTPUT TO SYS1.OBJPDS03(IEASVC00)\n//*\n//********************************************************************\n//ASMSVC EXEC ASMS,OBJ=OBJPDS03,MOD=IEASVC00,\n//           CLASS='*',COND=(0,NE)\n//A.SYSPUNCH DD  VOL=SER=ITEL01,UNIT=DISK\n//SYSIN      DD  DSN=&&PASS(IEASVC00),DISP=(OLD,DELETE)\n//********************************************************************\n//*\n//* USE SMP TO UPDATE NUCLEUS WITH THE NEW SVCTABLE\n//*\n//********************************************************************\n//VS00001  EXEC IPOSMP4,COND=(0,NE),RES=ITEL01\n//SMPJCLIN   DD DSN=*.SVCGEN.SYSPUNCH,DISP=OLD,\n//           VOL=REF=*.SVCGEN.SYSPUNCH\n//OBJECT     DD DSN=*.ASMSVC.A.SYSPUNCH,DISP=OLD,\n//           VOL=REF=*.ASMSVC.A.SYSPUNCH\n//SYSIN    DD *\n REJECT  S(VS00001).\n RECEIVE S(VS00001).\n APPLY   S(VS00001).\n LIST CDS SYSMOD(VS00001) .\n//SMPPTFIN   DD *\n++ USERMOD (VS00001) .\n++ VER (Z038) FMID(JBB1222) .\n++JCLIN TXLIB(SMPJCLIN) .\n++ MOD (IEASVC00) TXLIB(OBJECT).\n//********************************************************************\n./ ADD NAME=VS00002  0108-79327-80102-0850-00024-00031-00016-$SYS13  00\n//VS00002 JOB (2000,S010),WENZEL,CLASS=Z\n/*JOBPARM Q=F,I\n//*\n//*         STEP 1 ASSEMBLE IKJEFF53\n//*         STEP 2 SMP TO INSTALL AS SYSMOD NUMBER VS00002\n//*\n//STEP1    EXEC ASMFC,MAC1='SYS1.AMODGEN',\n//          PARM.ASM='NOTERM,LIST,NODECK,OBJECT'\n//ASM.SYSLIB DD UNIT=DISK,VOL=SER=ITEL01\n//          DD UNIT=DISK,VOL=SER=ITEL02\n//ASM.SYSGO DD DISP=OLD,DSN=SYS0.LINKLIB2.OBJ(IKJEFF53)\n//SYSIN     DD DISP=SHR,DSN=SYS0.LINKLIB2.SOURCE(IKJEFF53)\n//*\n//STEP2  EXEC IPOSMP4,COND=(8,LT)\n//SMPPTFIN DD *\n++ USERMOD (VS00002) .\n++ VER (Z038) FMID(JBB1112) /*\n MODULE IKJEFF53    TSO OUTPUT/STATUS/CANCEL EXIT ROUTINE */.\n++ MOD (IKJEFF53) DISTLIB (AOST4) TXLIB (OBJECT).\n//SYSIN    DD *\n RECEIVE  S(VS00002)   /* IKJEFF53 */    .\n APPLY    S(VS00002)  DIS(NO).\n/*\n//OBJECT  DD DISP=SHR,DSN=SYS0.LINKLIB2.OBJ\n./ ADD NAME=VS00003  0107-79327-80143-1909-00025-00028-00019-$SYS13  00\n//VS00003 JOB (2000,S010),WENZEL,CLASS=Z\n/*JOBPARM Q=F,I\n//*\n//*         STEP 1 ASSEMBLE IKJEFLD\n//*         STEP 2 SMP TO INSTALL AS SYSMOD NUMBER VS00003\n//*\n//STEP1    EXEC ASMFC,MAC1='SYS1.AMODGEN',\n//          PARM.ASM='NOTERM,LIST,NODECK,OBJECT'\n//ASM.SYSLIB DD UNIT=DISK,VOL=SER=SYS100\n//          DD UNIT=DISK,VOL=SER=ITEL02\n//ASM.SYSGO DD DSN=SYS0.LINKLIB2.OBJ(IKJEFLA),DISP=OLD\n//SYSIN     DD DSN=SYS0.LINKLIB2.SOURCE(IKJEFLD),DISP=SHR\n//*\n//STEP2  EXEC IPOSMP4,COND=(8,LT)\n//SMPCNTL  DD  *\n RECEIVE S (VS00003).\n APPLY   S (VS00003) DIS(NO).\n LOG (LOGON PREPROMPT EXIT USED WITH TSOHOLD - RPW/04/10/80).\n LIST  CDS SYSMOD(VS00003) DIS(NO).\n//SMPPTFIN  DD  *\n++ USERMOD (VS00003) .\n++ VER (Z038) FMID(EBB1102) .\n++ MOD (IKJEFLA) TXLIB(OBJECT).\n//OBJECT    DD  DISP=SHR,DSN=SYS0.LINKLIB2.OBJ\n//********************************************************************\n./ ADD NAME=VS00004  0122-79327-80213-1648-00262-00252-00000-$SYS13  00\n//VS00004 JOB (2000,S010),VS00004,NOTIFY=$SYS00\n/*JOBPARM Q=F,I\n//*\n//* REFER  IPO60.JCLLIB(PPTUPDT)\n//* COMPID  SYSTEMS\n//* DOC  THIS MEMBER CONTAINS THE JCL TO UPDATE THE PROGRAM\n//*      PROPERTIES TABLE USING SMP.\n//*\n//*********************************************************************\n//*                                                                   *\n//* IMPORTANT IMPORTANT IMPORTANT IMPORTANT IMPORTANT                 *\n//*                                                                   *\n//* IEBUPDTE INPUT MUST BE UNNUMBERED                                 *\n//*                                                                   *\n//* EXAMPLE JCL TO SHOW PPT USED BY MVS SYSTEM IPO DEVELOPMENT GROUP  *\n//*                                                                   *\n//* NOTE: ENTRIES ARE NOW 16 BYTES LONG, THEY USED TO BE 12.          *\n//*                                                                   *\n//* * THIS IS A MAPPING FOR A SINGLE ENRTY IN IEFSDPPT, THE PROGRAM\n//* * PROPERTIES TABLE.\n//* PPTNAME  DS   CL8 - PROGRAM NAME\n//* PPTBYTE1 DS   C -   FIRST BYTE OF PROPERTIES\n//* PPTNCNCL EQU  X'80' THIS PROGRAM IS NON-CANCELABLE\n//* PPTSKEY  EQU  X'40' THIS PROGRAM REQUIRES THE SPECIAL PROTECT\n//* *                   KEY IN PPTKEY\n//* PPTNSWP  EQU  X'20' THIS PROGRAM IS TO BE AUTHORIZED TO BE\n//* *                   NON-SWAPPABLE\n//* PPTPRIV  EQU  X'10' THIS PROGRAM IS TO BE 'PRIVILEGED' (WITH\n//* *                   RESPECT TO THE SYSTEM RESOURCES MANAGER)\n//* PPTSYSTK EQU  X'08' THIS PROGRAM IS A SYSTEM TASK\n//* PPTNDSI  EQU  X'04' THIS PROGRAM IS NOT TO BE GIVEN DATA SET\n//* *                   INTEGRITY\n//* PPTNOPAS EQU  X'02' BYPASS PASSWORD PROTECTION\n//* * THE REMAINING BIT IS RESERVED\n//* PPTKEY   DS   C -   THIS KEY IS TO BE GIVEN TO THE PROGRAM\n//* *                   BEING ATTACHED IF PPTSKEY IS ON\n//* * EQUATES FOR PROTECT KEYS FOLLOW:\n//* PPTKEY0 EQU   X'00'\n//* PPTKEY1 EQU   X'10'\n//* PPTKEY2 EQU   X'20'\n//* PPTKEY3 EQU   X'30'\n//* PPTKEY4 EQU   X'40'\n//* PPTKEY5 EQU   X'50'\n//* PPTKEY6 EQU   X'60'\n//* PPTKEY7 EQU   X'70'\n//* PPTKEY8 EQU   X'80'\n//* PPTCPUA DS    BL2   BIT MASK OF CPU'S ON WHICH THIS PROGRAM CAN\n//* *                   RUN (SHOULD BE X'FFFF' IF AFFINITY IS NOT\n//* *                   REQUIRED)\n//* ***** NEW FIELDS FOLLOW ******\n//* PPTFLGS DS    0F    FLAG BYTES\n//* PPTPUBYT DS   CL1   PREFERRED USAGE FLAGS\n//* PPT2LPU EQU   X'80' 2ND LEVEL PREFERRED USAGE\n//* PPT1LPU EQU   X'40' 1ST LEVEL PREFERRED USAGE\n//* PPTN2LP EQU   X'20' NOT 2ND LEVEL PREFERRED USAGE\n//* * THE REMAINING BITS ARE RESERVED\n//*      DS    CL3   RESERVED\n//*\n//*  FUNCTION\n//*  THIS MODULE (THE PROGRAM PROPERTIES TABLE) CONTAINS A LIST OF\n//*  PROGRAMS AND THE SPECIAL PROPERTIES TO BE ASSIGNED TO THESE\n//*  PROGRAMS. THE FORMAT OF EACH ENTRY IS DESCRIBED BY MACRO\n//*  IEFZB610. (THE NAME OF THE DSECT GENERATED IS PPT.)\n//*  THE BYTE FOLLOWING THE LAST ENTRY CONTAINS X'FF' AND\n//*  THE REMAINING BYTES IN THAT ENTRY CONTAIN BINARY ZEROES.\n//*  1. THE TABLE IS USED BY IEFSD161 AND IEFSD101.\n//*  2. NONE OF THE PROPERTIES WILL BE ASSIGNED IF THE STEP HAS\n//*     REQUESTED A JOBLIB OR STEPLIB WHICH IS NOT DEFINED AS\n//*     BEING AUTHORIZED. THIS CHECK IS PERFORMED BY IEFSD162.\n//*  3. THE PROPERTY 'SYSTEM TASK' WILL NOT BE ASSIGNED UNLESS\n//*     THE JOB IS '1-STEP' AND 'STARTED.' THIS CHECK IS\n//*     PERFORMED BY IEFSD101.\n//*  4. THE PROPERTY 'NO DATA SET INTEGRITY' WILL NOT BE\n//*     ASSIGNED UNLESS THE JOB IS '1-STEP.' THIS CHECK IS\n//*     PERFORMED BY IEFSD101.\n//*  5. EVEN IF THE 'NO DATA SET INTEGRITY' PROPERTY IS\n//*     REQUESTED, DATA SET INTEGRITY PROCESSING WILL ALWAYS\n//*     BE PERFORMED BY IEFSD102. THE PROPERTY (NDSI) WILL\n//*     ACTUALLY BE PROVIDED BY IEFSD162 IF THE AUTHORIZATION\n//*     CHECK OF JOBLIB/STEPLIB IS SUCCESSFUL. (THIS METHOD\n//*     IS NECESSARY EVEN IF NO JOBLIB OR STEPLIB IS PRESENT,\n//*     BECAUSE THE PRESENCE OR ABSENCE OF A STEPLIB IS NOT\n//*     KNOWN UNTIL ALLOCATION IS COMPLETE.)\n//*  6. THIS MODULE WAS CREATED BY SGIEF0PT.\n//*\n//SMPPPT  EXEC IPOSMP4\n//SMPCNTL  DD  *\n  REJECT   S (VS00004) .\n  RECEIVE  S (VS00004) .\n  APPLY    S (VS00004) DIS(NO).\n  LIST   CDS SYSMOD(VS00004) DIS(NO) .\n//SMPPTFIN DD  *\n++ USERMOD(VS00004) .\n++ VER (Z038) FMID(EBB1102)\n              PRE(UZ23961) /*\n   THESE UPDATES ARE AT PTF LEVEL UZ23961\n   IEBUPDTE INPUT MUST BE SEQUENCED PROPERLY SINCE\n   SMP4 WILL NOT ACCEPT ANY IEBUPDTE CONTROL CARDS\n   OTHER THAN CHANGE AND ENDUP                       10/16/79 SCF\n   */ .\n++ MACUPD (SGIEF0PT) ASSEM(IEFSDPPT) DISTLIB(AMODGEN) BASE(UPDATE) .\n><  CHANGE NAME=SGIEF0PT\n***THESE ENTRIES PRECEEDS THE IBM ENTRIES, VALID LINE NUMBERS ARE\n***       BETWEEN 03350003 AND 03400001 INCLUSIVELY\n********* UPDATE FOR ISTINM01 ACF VTAM\n          DC    CL8'ISTINM01'             PROGRAM NAME       1\n          DC    AL1(PPTSKEY+PPTNSWP+PPTSYSTK+PPTNOPAS+PPTNDSI)\n          DC    AL1(PPTKEY6)              KEY                3\n          DC    XL2'FFFF'                 AFFINITIES         4\n          DC    AL1(PPTN2LP)        FLAG BYTE\n          DC    XL3'00'             RESERVED FLAG BYTES\n********* UPDATE FOR RMF\n          DC    CL8'ERBMFMFC'             PROGRAM NAME       1\n          DC    AL1(PPTPRIV+PPTSYSTK+PPTNDSI+PPTNOPAS) PROPERTIES   FJP\n          DC    AL1(PPTKEY0)              KEY                3\n          DC    XL2'FFFF'                 AFFINITIES         4\n          DC    AL1(0)              FLAG BYTE\n          DC    XL3'00'             RESERVED FLAG BYTES\n********* UPDATE FOR ASM2 (SUBTASK OF $MIGRATE)\n          DC    CL8'$MCLMVR '             PROGRAM NAME       1\n          DC    AL1(PPTNDSI+PPTNOPAS)         PROPERTIES     2\n          DC    AL1(PPTKEY8)              KEY                3\n          DC    XL2'FFFF'                 AFFINITIES         4\n          DC    AL1(PPTN2LP)        FLAG BYTE\n          DC    XL3'00'             RESERVED FLAG BYTES\n********* UPDATE FOR ASM2\n          DC    CL8'$MIGRATE'             PROGRAM NAME       1\n          DC    AL1(PPTNDSI+PPTNOPAS)     PROPERTIES         2\n          DC    AL1(PPTKEY8)              KEY                3\n          DC    XL2'FFFF'                 AFFINITIES         4\n          DC    AL1(0)              FLAG BYTE\n          DC    XL3'00'             RESERVED FLAG BYTES\n********* UPDATE FOR SMP\n          DC    CL8'HMASMP  '             PROGRAM NAME       1\n          DC    AL1(PPTNOPAS)             PROPERTIES         2\n          DC    AL1(PPTKEY8)              KEY                3      FJP\n          DC    XL2'FFFF'                 AFFINITIES         4\n          DC    AL1(0)              FLAG BYTE\n          DC    XL3'00'             RESERVED FLAG BYTES\n********* UPDATE FOR DPRO\n          DC    CL8'DPROANAL'             PROGRAM NAME       1\n          DC    AL1(PPTNOPAS)             PROPERTIES         2\n          DC    AL1(PPTKEY8)              KEY                3\n          DC    XL2'FFFF'                 AFFINITIES         4\n          DC    AL1(PPTN2LP)        FLAG BYTE\n          DC    XL3'00'             RESERVED FLAG BYTES\n********* UPDATE FOR ALTERNATE TCAM NAME\n          DC    CL8'IEDQTCAN'             PROGRAM NAME       1      FJP\n          DC    AL1(PPTNSWP+PPTSKEY+PPTNOPAS) PROPERTIES     2\n          DC    AL1(PPTKEY6)              KEY                3\n          DC    XL2'FFFF'                 AFFINITIES         4\n          DC    AL1(PPTN2LP)        FLAG BYTE\n          DC    XL3'00'             RESERVED FLAG BYTES\n********* UPDATE FOR IDMS PRODUCTION VERSION\n          DC    CL8'IDMSCV0'              PROGRAM NAME       1\n          DC    AL1(PPTNSWP)              PROPERTIES         2\n          DC    AL1(PPTKEY8)              KEY                3\n          DC    XL2'FFFF'                 AFFINITIES         4\n          DC    AL1(PPTN2LP)        FLAG BYTE\n          DC    XL3'00'             RESERVED FLAG BYTES\n********* UPDATE FOR TSO\n          DC    CL8'IKTCAS00'             PROGRAM NAME       1\n          DC    AL1(PPTSKEY+PPTSYSTK+PPTNDSI+PPTNOPAS+PPTPRIV) 2\n          DC    AL1(PPTKEY6)              KEY                3\n          DC    XL2'FFFF'                 AFFINITIES         4\n          DC    AL1(0)              FLAG BYTE\n          DC    XL3'00'             RESERVED FLAG BYTES\n********* USED BY CSG FOR TESTING PURPOSES\n          DC    CL8'XXX11XXX'             PROGRAM NAME       1\n          DC    AL1(PPTNDSI+PPTNOPAS)     PROPERTIES         2\n          DC    AL1(PPTKEY8)              KEY                3\n          DC    XL2'FFFF'                 AFFINITIES         4\n          DC    AL1(0)              FLAG BYTE\n          DC    XL3'00'             RESERVED FLAG BYTES\n********* UPDATE FOR HASJES2A A DIFFERENT JES2\n          DC    CL8'HASJES2A'             PROGRAM NAME       1\n          DC    AL1(PPTSKEY+PPTSYSTK)     PROPERTIES         2\n          DC    AL1(PPTKEY1)              KEY                3\n          DC    XL2'FFFF'                 AFFINITIES         4\n          DC    AL1(0)              FLAG BYTE\n          DC    XL3'00'             RESERVED FLAG BYTES\n***\n***  THE ABOVE REPRESENTS (SLIGHTLY) MODIFIED IPO-4.0 MATERIAL,\n***  WHAT FOLLOWS REPRESENTS ITEL ADDITIONS TO THE PPT\n***\n********* UPDATE FOR COPYPACK\n          DC    CL8'COPYPACK'             PROGRAM NAME          1\n          DC    AL1(PPTNOPAS+PPTNDSI)     PROPERTIES            2\n          DC    AL1(PPTKEY8)              KEY                   3\n          DC    XL2'FFFF'                 AFFINITIES            4\n          DC    AL1(PPTN2LP)              FLAG BYTE             5\n          DC    XL3'00'                   RESERVED FLAG BYTES   6\n********* UPDATE FOR ASM2\n          DC    CL8'$ARCHIVE'             PROGRAM NAME          1\n          DC    AL1(PPTNOPAS)             PROPERTIES            2\n          DC    AL1(PPTKEY8)              KEY                   3\n          DC    XL2'FFFF'                 AFFINITIES            4\n          DC    AL1(PPTN2LP)              FLAG BYTE             5\n          DC    XL3'00'                   RESERVED FLAG BYTES   6\n********* UPDATE FOR ASM2\n          DC    CL8'$ASMBMON'             PROGRAM NAME          1\n          DC    AL1(PPTNOPAS)             PROPERTIES            2\n          DC    AL1(PPTKEY8)              KEY                   3\n          DC    XL2'FFFF'                 AFFINITIES            4\n          DC    AL1(PPTN2LP)              FLAG BYTE             5\n          DC    XL3'00'                   RESERVED FLAG BYTES   6\n********* UPDATE FOR SOF\n          DC    CL8'CREDISP0'             PROGRAM NAME          1\n          DC    AL1(PPTNDSI)              PROPERTIES            2\n          DC    AL1(PPTKEY8)              KEY                   3\n          DC    XL2'FFFF'                 AFFINITIES            4\n          DC    AL1(PPTN2LP)              FLAG BYTE             5\n          DC    XL3'00'                   RESERVED FLAG BYTES   6\n********* UPDATE FOR CICS TEST AND PROD. VERSIONS\n          DC    CL8'DFHSIP'               PROGRAM NAME          1\n          DC    AL1(PPTNDSI+PPTNSWP)      PROPERTIES            2\n          DC    AL1(PPTKEY8)              KEY                   3\n          DC    XL2'FFFF'                 AFFINITIES            4\n          DC    AL1(PPTN2LP)              FLAG BYTE             5\n          DC    XL3'00'                   RESERVED FLAG BYTES   6\n********* UPDATE FOR ACF2 MAIN TASK\n          DC    CL8'ACFMAIN '             PROGRAM NAME          1\n          DC    AL1(PPTNCNCL+PPTSKEY+PPTSYSTK+PPTNOPAS)         2\n          DC    AL1(PPTKEY1)              KEY                   3\n          DC    XL2'FFFF'                 AFFINITIES            4\n          DC    AL1(PPTN2LP)              FLAG BYTE             5\n          DC    XL3'00'                   RESERVED FLAG BYTES   6\n********* UPDATE FOR IDMS TEST VERSION\n          DC    CL8'IDMSCV1'              PROGRAM NAME          1\n          DC    AL1(PPTNSWP)              PROPERTIES            2\n          DC    AL1(PPTKEY8)              KEY                   3\n          DC    XL2'FFFF'                 AFFINITIES            4\n          DC    AL1(PPTN2LP)              FLAG BYTE             5\n          DC    XL3'00'                   RESERVED FLAG BYTES   6\n********* UPDATE FOR COMPRESS\n          DC    CL8'COMPRESS'             PROGRAM NAME          1   FJP\n          DC    AL1(PPTNOPAS)             PROPERTIES            2\n          DC    AL1(PPTKEY8)              KEY                   3\n          DC    XL2'FFFF'                 AFFINITIES            4\n          DC    AL1(0)                    FLAG BYTE             5\n          DC    XL3'00'                   RESERVED FLAG BYTES   6\n********* UPDATE FOR GTFCCW\n          DC    CL8'GTFCCW'               PROGRAM NAME          1   FJP\n          DC    XL1'FE'                   PROPERTIES            2\n          DC    AL1(PPTKEY0)              KEY                   3\n          DC    XL2'FFFF'                 AFFINITIES            4\n          DC    AL1(0)                    FLAG BYTE             5\n          DC    XL3'00'                   RESERVED FLAG BYTES   6\n********* UPDATE FOR GTF\n          DC    CL8'AHLGTF  '             PROGRAM NAME       1\n          DC    XL1'FE'                   PROPERTIES         2\n          DC    AL1(PPTKEY0)              KEY                3\n          DC    XL2'FFFF'                 AFFINITIES         4\n          DC    AL1(0)              FLAG BYTE\n          DC    XL3'00'             RESERVED FLAG BYTES\n********* UPDATE FOR NETWORK\n          DC    CL8'NETWORK '             PROGRAM NAME       1\n          DC    AL1(PPTSKEY+PPTNOPAS)     PROPERTIES         2\n          DC    AL1(PPTKEY6)              KEY                3\n          DC    XL2'FFFF'                 AFFINITIES         4\n          DC    AL1(0)              FLAG BYTE\n          DC    XL3'00'             RESERVED FLAG BYTES\n./ ADD NAME=VS00005  0110-80084-80101-1100-00118-00111-00028-$SYS03  00\n//VS00005  JOB (2000,9030),S.CAIRES,CLASS=Z,MSGCLASS=A\n/*JOBPARM Q=F,I\n//*\n//* DELTA 239 FOR PTF UZ26761, MODIFIED FOR AZ43620, WAS USED\n//* SINCE THERE IS NO DELTA FOR UZ90018, A PTF IN ERROR NEEDED\n//* FOR INSTALL OF SE V2.0.  WENZEL 4/10/80.\n//*\n//* USE SMP4 TO PUT IN THE TMS DATA MANAGEMENT HOOKS (ZAPS) INTO\n//* SYS1.LPALIB ON SYS101.\n//*\n//* THIS SYSMOD VS00005 WAS MODIFIED FROM THE VS00005 ON ITEL'S\n//* SYS3.TMS.CNTL BY T. RAIMER TO REPLACE THE DELTA 202 FOR PTF UZ22467\n//* WITH THE DELTA 253 FOR PTF UZ27340, WHICH SUPERSEDES UZ22467.\n//*\n//* COMMENTS WERE ADDED BY S. CAIRES, TO IDENTIFY BASE DELTAS AND PTFS.\n//*\n//* TO BUILD VS00005 FROM SCRATCH OR TO CHECK THIS VS00005, FIRST FUN\n//* JOB TMSPDC11, TO EXEC TMSDELTA WITH OPTIONS:  ADD99, LIST99,\n//* VERIFY(ZAP), AND SMPZAP(VS00005).  THE ZAPS IN SMP FORMAT AND THE\n//* VERIFY CARDS CORRESPOND TO THE TMS BASE FOR SAY MVS 3.8.  THEY MAY\n//* HAVE BEEN SUPERSEDED BY LATER SMP PTFS.  TO IDENTIFY WHICH MODULES\n//* HAVE BEEN HIT BY PTFS, RUN THE VERIFY CARDS AGAINST SYS1.LPALIB, OR\n//* DO AN APPLY CHECK OF THE (TMS BASE) VS00005.  THEN USE LIST99 TO\n//* IDENTIFY THE DELTAS WHICH CORRESPOND TO THE PTF NUMBERS FOUND.  TO\n//* DOUBLE CHECK, USE SMP4 TO LIST THE MODS HIT BY THE ZAPS IN THE TMS\n//* BASE FOR MVS 3.8 TO FIND THE RMID FOR EACH MOD:  'LIST CDS\n//* MOD(IFGXXXXX,IFGYYYYY).'\n//*\n//*\n//VS00005  EXEC IPOSMP4         DLIB=PAG002,RES=SYS101,PTS=PAG002\n//SYSIN    DD  *      (//SMPCNTL DD *)\n /* RESTORE S (VS00005) . */\n LIST PTS SYSMOD(VS00005) .\n REJECT  S (VS00005) .\n RECEIVE S (VS00005) .\n LIST PTS SYSMOD(VS00005) .\n LIST CDS SYSMOD(VS00005) .\n APPLY S (VS00005)  /* CHECK   /* BACKUP CDS AND ACDS\n                                  BEFORE DIS(WRITE) */ .\n LIST CDS SYSMOD(VS00005) .\n LOG (TMSHOOKS INTO IFG0194A, IGC0001I, IGC00020 AND IGC0005E).\n/*\n//SMPPTFIN DD  *\n++  USERMOD (VS00005)  /* UCC-ONE (TMS) HOOKS FOR O/S REL VS203.8 */ .\n++ VER (Z038) FMID(EDM1102)\n   PRE (UZ26761,AZ43620,UZ90018,\n        UZ22527,UZ25274,UZ22277,UZ26833,UZ27757).\n++ ZAP (IFG0194F)\n /* DELTA 239 FOR PTF UZ26761, MODIFIED FOR AZ43620, WAS USED\n    SINCE THERE IS NO DELTA FOR UZ90018, A PTF IN ERROR NEEDED\n    FOR INSTALL OF SE V2.0 */ .\n* TMS HOOKS FOR O/S RELEASE VS203.8\n NAME IFG0194A IFG0194F                                   40239\n VER  0488 910140B1,471034CE                              40239\n VER  0A2C D501A01A3E7F,47203A80                          40239\n VER  0DFC D20441CA3F29,920441CF                          40239\n*VER  0F70 0000,00000000,00000000,00000000,00000000       40239\n VER  0FB0 0000,00000000,00000000,00000000,00000000     AZ43620\n REP  0488 910140B1,470034CE                              40239\n*REP  0A2C 1BFF,47F03F6E,47000000                         40239\n REP  0A2C 1BFF,47F03FAE,47000000                       AZ43620\n*REP  0F70 0AF8,47FF3F70,47F03A80,47F03A34,47F03DFA       40239\n REP  0FB0 0AF8,47FF3FB0,47F03A80,47F03A34,47F03DFA     AZ43620\n IDRDATA VS00005\n++ ZAP (IFG0196Q) .  /* TMS BASE DELTA FOR PTF - - - - (EDM1102) */\n NAME IGC0001I IFG0196Q\n VER 0020 F23441E04030,58B00010,D503B03841E0,47B03094\n VER 008E 4100000D\n REP 0020 41F00004,0AF8,47FF3024,47F03094,47F0308C,0700\n IDRDATA VS00005\n++ ZAP (IFG0195H) .  /* DELTA 254 FOR PTF UZ27757 */\n*        SUPPORT FOR PTF UZ27757 FOR VS2 3.8\n NAME IGC0001I IFG0195H                                  40254 003124\n VER  024A 91037000,47E03304,95F04030,47403304,95F04032  40254 003125\n VER  025E 47403304,95804034,47403304,F224417D4030       40254 003126\n REP  024A 41F00008,0AF8,47FF324E,47F03304,95F04030,4740 40254 003127\n REP  025E 3304,95F04032,47403304,95804034,47403304      40254 003128\n IDRDATA VS00005\n++ ZAP (IFG0552B) .  /* TMS BASE DELTA     FOR PTF UZ22527 */\n NAME IGC0005E IFG0552B\n VER 026E F23441E04030,58100010,D503103841E0,47B032D8\n VER 01A4 47F032D8\n VER 02D2 4100006C\n REP 026E 41F00010,0AF8,47FF3272,47F032D8,47F032D0,0700\n REP 01A4 47F0326C\n IDRDATA VS00005\n++ ZAP (IFG0196N) .  /* TMS BASE DELTA FOR PTF - - - - (EDM1102) */\n NAME IGC0001I IFG0196N\n VER 009E D50132FEA018,474030B4\n VER 02C0 1700,43004190\n VER 0352 00000000,0000,00000000,00000000,00000000,00000000\n REP 009E 47F03350\n REP 0352 41F00014,0AF8,47FF3356,47F030A6,47F032BE,47F030B4\n IDRDATA VS00005\n++ ZAP (IFG0553F) .  /* DELTA 230 FOR PTF UZ25274 */\n NAME IGC0005E IFG0553F                                   40230\n VER  04C8 9180202A,47E034D6,910C202B,478034E8            40230\n REP  04C8 41F0001C,0AF8,47FF34CC,47F034E8,0700           40230\n IDRDATA VS00005\n++ ZAP (IFG0552V) .  /* TMS BASE DELTA    FOR PTF - - - - (EDM1102) */\n NAME IGC0005E IFG0552V\n VER 0012 9180202A,47803020,910C202B,47803026\n REP 0012 41F0003C,0700,0AF8,47FF3018,47F03026\n IDRDATA VS00005\n++ ZAP (IFG0551T) .  /* TMS BASE DELTA     FOR PTF UZ22277 */\n NAME IGC0005E IFG0551T\n VER 00CA 9180202A,478030D8,910C202B,478030DE,D703200C200C\n REP 00CA 41F00040,0AF8,47FF30CE,47F030DE,0700\n IDRDATA VS00005\n++ ZAP (IFG0200Y) .  /* DELTA 236 FOR PTF UZ26833 */\n NAME IGC00020 IFG0200Y                                   40236\n VER 01EC 9180A012,4710321C,41F03511                      40236\n VER 021E 9140A006,47E03234                               40236\n VER 0560 00000000,0000,00000000                          40236\n REP 01EC 9180A012,4710355E                               40236\n REP 0560 41F00044,0AF8,47F0321C                          40236\n IDRDATA VS00005\n/*\n./ ADD NAME=VS00006  0102-80101-80102-0851-00031-00028-00003-$SYS13  00\n//VS00006 JOB (2000,S010),WENZEL,CLASS=Z\n/*JOBPARM Q=F,I\n//*\n//*         STEP 1 ASSEMBLE IKJEFTE2\n//*         STEP 2 ASSEMBLE IKJEFTE8\n//*         STEP 3 SMP TO INSTALL AS SYSMOD NUMBER VS00006\n//*\n//STEP1    EXEC ASMFC,MAC1='SYS1.AMODGEN',\n//          PARM.ASM='NOTERM,LIST,NODECK,OBJECT'\n//ASM.SYSLIB DD UNIT=DISK,VOL=SER=ITEL01\n//          DD UNIT=DISK,VOL=SER=ITEL02\n//ASM.SYSGO DD DISP=OLD,DSN=SYS0.LINKLIB2.OBJ(IKJEFTE2)\n//SYSIN     DD DISP=SHR,DSN=SYS0.LINKLIB2.SOURCE(IKJEFTE2)\n//*\n//STEP2    EXEC ASMFC,PARM.ASM='NOTERM,LIST,NODECK,OBJECT'\n//ASM.SYSLIB DD UNIT=DISK,VOL=SER=ITEL01\n//ASM.SYSGO DD DISP=OLD,DSN=SYS0.LINKLIB2.OBJ(IKJEFTE8)\n//SYSIN     DD DISP=SHR,DSN=SYS0.LINKLIB2.SOURCE(IKJEFTE8)\n//*\n//STEP3    EXEC IPOSMP4,COND=(8,LT)\n//SYSIN   DD  *\n RECEIVE S(VS00006) .\n APPLY   S(VS00006) DIS(NO) .\n LIST  CDS SYSMOD(VS00006).\n LIST  CDS MOD(IKJEFTE2,IKJEFTE8).\n//SMPPTFIN     DD  *\n++ USERMOD (VS00006) .\n++ VER (Z038) FMID(EBB1102)  SUP(IPOTE80).\n++ MOD (IKJEFTE2) DISTLIB(AOST4) TXLIB(OBJECT) .\n++ MOD (IKJEFTE8) DISTLIB(AOST4) TXLIB(OBJECT) .\n//OBJECT  DD DISP=SHR,DSN=SYS0.LINKLIB2.OBJ\n./ ADD NAME=VS00007  0104-80106-80106-1644-00090-00129-00079-$SYS03  00\n//VS00007  JOB (2000,S010),CAIRES,CLASS=Z,MSGCLASS=A\n/*JOBPARM Q=F,I\n//*\n//* INSTALL ABEND-AID REL 3.0 AFTER PUT TAPES 7909 THRU 7911,\n//* AND AFTER INSTALL OF SAME V1.0 AND SE V2.0 AT ITEL. CAIRES 4/15/80.\n//*\n//* JCL TAKEN FROM SYS4.ABENDAID.V30.SORCMAC(JCLS45A2).\n//* THIS JOB USES $SYSUT.ABENDAID.V30.CNTL(ABENDAID) INSTEAD OF\n//* SYS4.ABENDAID.V30.OBJECT(ABENDAID), WHICH LIBRARY IS TO BE\n//* DELETED AFTER INITIAL INSTALLATION.\n//*\n//*\n//IPOSMP4  EXEC IPOSMP4           DLIB=PAG002,RES=SYS101,PTS=PAG002\n//********************************************************************\n//*   JCLS45A2 - SMP 4 JCL FOR THE ABEND-AID OPERATING SYSTEM CHANGE *\n//*              FOR MVS REL 3.8 WITH SU 64 (3033 MP PER SUPPORT)    *\n//*                                                                  *\n//*    PLEASE NOTE THAT THE PROCEDURE NAME (SMP4PROC) MUST BE CHANGED*\n//*    ALSO NOTE THAT THE ORDER OF THE SMP DD STATEMENTS MAY NOT     *\n//*         MATCH THE ORDER OF THE SAME SMP DD CARD IN YOUR SMPPROC  *\n//*         PLEASE REARRANGE THEM BEFORE RUNNING TO INSURE PROPER    *\n//*         JCL OVERRIDE                                             *\n//*                                                                  *\n//********************************************************************\n//SYSIN    DD  *    ( //SMPCNTL DD DDNAME=SYSIN )\nUCLIN CDS.\nREP MOD(ABENDAID) LMOD(IGC0005A) DISTLIB(ABENDAID) FMID(EBB1102) .\nENDUCL.\nUCLIN ACDS.\nADD MOD(ABENDAID) LMOD(IGC0005A) DISTLIB(ABENDAID) FMID(EBB1102) .\nENDUCL.\n LIST PTS SYSMOD(VS00007) .\n REJECT  S(VS00007) .\n RECEIVE S(VS00007)\n         /* UPDATE CDS WITH ABENDAID FRONT END TO IGC0005A */ .\n LIST PTS SYSMOD(VS00007) .\n LIST CDS SYSMOD(VS00007) .\n APPLY   S (VS00007)  DIS(WRITE) .\n LOG (UPDATE SMP CDS WITH ABENDAID MODULE DESTINED FOR LPALIB).\n LIST CDS SYSMOD(VS00007) .\n/*\n//*\n//*\n//*\n//DUMMYJCL DD *   UNUSED CARDS.\n APPLY   S (VS00007)  CHECK .\n/*\n//*\n//*\n//*\n//* JCLIN FOR LMOD IGC0005A, INCLUDING ABENDAID MOD.\n//*\n//SMPPTFIN DD DATA,DLM=$$\n++ USERMOD(VS00007) .\n++ VER(Z038) FMID(EBB1102).\n++ JCLIN  /* UPDATE SMPCDS WITH ABENDAID FRONT END TO IGC0005A */ .\n//LINK     EXEC PGM=IEWL,PARM='LIST,XREF,NCAL,RENT,REFR'\n//SYSLMOD  DD  DSN=SYS1.LPALIB,DISP=SHR\n//ABENDAID DD DISP=SHR,DSN=SYS4.ABENDAID.V30.LINKLIB\n//SYSLIN   DD  *\n     INCLUDE ABENDAID(ABENDAID)\n     ORDER   ABENDAID\n     ORDER   IEAVAD00(P),IEAVAD03(P)\n     ORDER   IEAVAD01(P),IEAVAD0B\n     ORDER   IEAVAD02(P),IEAVAD05,IEAVAD09,IEAVADFM\n     ORDER   IEAVAD06(P),IEAVAD07,IEAVAD08\n     ORDER   IEAVAD11(P),IEAVAD31,IEAVAD51,IEAVAD71,IEAVAD0A\n     ORDER   IEAVAD0E(P),IEAVAD0F,IEAVAD10\n     ORDER   IEAVAD0C(P),IEAVAD0D\n     ORDER   IEAVTSDG(P),IEAVTSDC,IEAVTSSE\n     ORDER   IEAVTSDL(P),IEAVTSDF\n     ORDER   IEAVTSDT(P),IEAVTSDH,IEAVTSDU\n     ORDER   IEAVTSDO,IEAVTSDW\n     ALIAS   IEAVTSDT\n     ALIAS   IEAVTSDA\n     ENTRY   ABENDAID\n     NAME    IGC0005A(R)\n/*\n++ MOD(ABENDAID) TXLIB(TMOBJECT) DISTLIB(ABENDAID) LEPARM(RENT,REFR) .\n$$\n//ABENDAID DD DSN=SYS4.ABENDAID.V30.LINKLIB,DISP=SHR,\n//            VOL=SER=SYS200,UNIT=DISK\n//*TMOBJECT DD DSN=SYS4.ABENDAID.V30.OBJECT,DISP=SHR\n//*\n//* THE FOLLOWING LIBRARY, $SYSUT.ABENDAID.V30.CNTL, CONTAINS A COPY OF\n//* THE ABENDAID CSECT FROM SYS4.ABENDAID.V30.OBJECT, CREATED BY JOB\n//* ABENAID1.  SYS4.ABENDAID.V30.OBJECT IS NOT NEEDED AFTER ABENDAID\n//* INSTALLATION.\n//*\n//TMOBJECT DD DSN=$SYSUT.ABENDAID.V30.CNTL,DISP=SHR\n./ ADD NAME=VS00008  0120-80107-80191-1154-00091-00023-00000-$SYS13  00\n//VS00008 JOB (2000,S010),WENZEL,CLASS=Z\n/*JOBPARM Q=F,I\n//*\n//*         STEP 1 ASSEMBLE AND LINKEDIT SPFIJTIP\n//*         STEP 2 SMP TO INSTALL SPF/JTIP AS SYSMOD NUMBER VS00008\n//*\n//STEP1    EXEC ASMFCL,MAC='SYS2.MACLIB'\n//ASM.SYSLIB DD\n//          DD UNIT=DISK,VOL=SER=SYS100\n//ASM.SYSIN DD DSN=SYS0.CMDLIB2.SOURCE(SPFIJTIP),DISP=SHR\n//LKED.SYSLMOD DD DISP=OLD,DSN=SYS2.CMDLIB(SPFIJTIP)\n//*\n//STEP2   EXEC  IPOSMP4\n//SMPPTFIN DD *\n++ USERMOD (VS00008) .\n++ VER (Z038) FMID(JTP0001) PRE(VS00026)\n /*\n JES2TSO:  UPDATE TO JES2TSO - ADD  DUMMY STATEMENT\n           TO FORCE ASSEMBLY.\n FETCH:    UPDATE TO FETCH - SPF/JTIP INTERFACE\n           PERMITS FETCH TO RETRIEVE BY DDNAME TO THE\n           SPFLIST1/2 VIO DATASETS.\n VERFYQEL: UPDATE TO VERFYQEL SO THAT $SYS USER CAN\n           FETCH, ROUTE, PURGE AND SHOW ANY JOB\n           REGARDLESS OF THE JOBNAME.\n */ .\n++ SRCUPD (JES2TSO) DISTLIB(JTIPMAC) .\n>< CHANGE NAME=JES2TSO\n*        DUMMY STATEMENT TO FORCE ASSEMBLY                     ITEL RPW\n++ SRCUPD (FETCH) DISTLIB(JTIPMAC) .\n>< CHANGE NAME=FETCH\n         PUNCH ' ALIAS FET'                                    ITEL RPW\n         EJECT 1                                                CSG RWB\n         BZ    CSGONT1             OKAY - BYPASS THIS JAZZ      CSG RWB\nCSGRC04  L     R3,CPPLUPT          ELSE -                       CSG RWB\n         L     R4,CPPLECT          FLUSH THE COMMAND STACK -    CSG RWB\n         LA    R5,ECBS             AND -                        CSG RWB\n         XC    ECBS,ECBS           SET -                        CSG RWB\n         L     R13,4(,R13)         RETURN -                     CSG RWB\n         RETURN (14,12),RC=4       CODE TO 04 - JOB NOT FOUND   CSG RWB\n         SPACE 2                                                CSG RWB\nCSGONT1  DS    0H                                               CSG RWB\n         EJECT 1                                                CSG RWB\n         TM    DSNAM+6,X'40'       QUOTES AROUND DSN ?          CSG RWB\n         BNO   CSGALLOC            ..NO, CAN'T BE THE ONE I WANTCSG RWB\n         L     R2,DSNAM            POINT AT DSNAME              CSG RWB\n         LA    R1,7                LOOK AT 7 POSITIONS          CSG RWB\nCSGCKSPC DS   0H                   CHECK FOR SPECIAL DSN        CSG RWB\n         CLC   =C'.SPFTEMP',1(R2)   SPF TEMP LIST DS ?          CSG RWB\n         BE    CSGCHK10            ..MAYBE , MAKE SURE          CSG RWB\n         LA    R2,1(,R2)           ..NO, TRY AGAIN              CSG RWB\n         BCT   R1,CSGCKSPC                                      CSG RWB\n         B     CSGALLOC                                         CSG RWB\nCSGCHK10 DS   0H                   CHECK FOR SPECIAL DSN        CSG RWB\n         CLC   =C'.LIST',10(R2)    COMPLETE CHECK               CSG RWB\n         BNE   CSGALLOC            NOT ONE I WANT               CSG RWB\n         MVC   CSGDDNAM(7),=C'SPFLIST'  SET UP 'SPECIAL' DDNAME CSG RWB\n         MVC   CSGDDNAM+7(1),9(R2)      LIST NO. FROM DSN       CSG RWB\n         EXTRACT CSGTIOT,FIELDS=(TIOT) GET ADDR OF TIOT         CSG RWB\n         L     R2,CSGTIOT                                       CSG RWB\n         LA    R2,24(,R2)          POINT AT FIRST DD            CSG RWB\nCSGCHKDD CLC   0(4,R2),=F'0'       END OF TIOT ?                CSG RWB\n         BE    CSGALLOC            ..YES, GO ALLOC D.S.         CSG RWB\n         CLC   CSGDDNAM,4(R2)      ..NO, IS 'SPECIAL' DD HERE ? CSG RWB\n         BE    CSGDDFND            ..YES, GO PROCCESS           CSG RWB\n         SR    R1,R1               ..NO, GET INCR               CSG RWB\n         IC    R1,0(R2)                                         CSG RWB\n         AR    R2,R1               ADD TO CURRENT ENTRY         CSG RWB\n         B     CSGCHKDD            GO CHECK NEXT ENTRY          CSG RWB\nCSGDDFND DS   0H                   'SPECIAL' DD FOUND           CSG RWB\n         MVC   DA08DDNM,CSGDDNAM   SET UP DDNAME                CSG RWB\n         B     DAIROK              GO TO IT                     CSG RWB\nCSGALLOC DS   0H                   'SPECIAL' DD NOT FOUND       CSG RWB\nERROR90  PUTIT 'INVALID JOB NUMBER',JUMP=CSGRC04                CSG RWB\n         DC    C'N',AL1(133),AL2(3059),X'94',X'03'             ITEL RPW\nCSGDDNAM DS    CL8                 'SPECIAL' DDNAME FOR SPF     CSG RWB\nCSGTIOT  DS    F                    ADDR OF TIOT                CSG RWB\n++ SRCUPD (VERFYQEL) DISTLIB(JTIPMAC) .\n>< CHANGE NAME=VERFYQEL\n         CLC   0(4,R1),=C'$SYS' SEE IF SYSTEM USER             ITEL RPW\n         BE    VEREXIT          OK, BYPASS EVERTHING           ITEL RPW\n         CLC   0(4,R1),=C'$RJE' SEE IF PRODCTION USER          ITEL RPW\n         BNE   NOVERXIT         NOPE                           ITEL RPW\n         CLI   JQEJNAME,C'I'    PRODUCTION JOB                 ITEL RPW\n         BE    VEREXIT          OK, LET THEM DO IT             ITEL RPW\n>< ENDUP\n//SYSIN DD *\n REJECT  S (VS00008) .\n RECEIVE S (VS00008) .\n APPLY   S (VS00008) .\n/*\n./ ADD NAME=VS00009  3803-80010-80101-1327-00020-00019-00007-$SYS13  00\n//VS00009 JOB (2000,S010),WENZEL,CLASS=Z\n/*JOBPARM Q=F,I\n//VS00009 EXEC IPOSMP4\n//SYSIN DD *\n RECEIVE S (VS00009) .\n APPLY   S (VS00009) .\n LOG (3270  LOGICAL TAB (CENT SIGN), GOOD ON ALL TERMINALS) .\n//SMPPTFIN DD  *\n++ USERMOD (VS00009) /*LOGOCAL TABS(\u00a2) GOOD ON ALL TERMINALS */ .\n++ VER (Z038) FMID(EBB1102) .\n++ ZAP (IKJEBELE) .\n NAME IKJEBELE\n VER  0228 92406003     MVI  3(6),X'40'\n VER  0828 4A4B4C4D                       CENT SIGN, TABLE CONT.\n REP  0228 924A6003     MVI  3(6),C'   '    TAB OFF SUBCOMMAND\n REP  0828 05                              LOGICAL TAB FOR 3270\n*                                          REPLACE LOGICAL TAB WITH\n*                                          CENT SIGN\n IDRDATA VS00009\n/*\n./ ADD NAME=VS00010  0109-80081-80117-1357-00033-00022-00022-$SYS13  00\n//VS00010  JOB (2000,S010),WENZEL,CLASS=Z\n/*JOBPARM Q=F,I\n//*\n//*         STEP 1 ASSEMBLE IEFUJI\n//*         STEP 2 ASSEMBLE IEFUSI\n//*         STEP 3 ASSEMBLE IEFUTL\n//*         STEP 4 SMP TO INSTALL AS SYSMOD NUMBER VS00010\n//*\n//STEP1    EXEC ASMFC,PARM.ASM='NOTERM,LIST,NODECK,OBJECT'\n//ASM.SYSGO DD DSN=SYS0.LINKLIB2.OBJ(IEFUJI),DISP=OLD\n//SYSIN     DD DSN=SYS0.LINKLIB2.SOURCE(IEFUJI),DISP=SHR\n//*\n//STEP2    EXEC ASMFC,PARM.ASM='NOTERM,LIST,NODECK,OBJECT'\n//ASM.SYSGO DD DSN=SYS0.LINKLIB2.OBJ(IEFUSI),DISP=OLD\n//SYSIN     DD DSN=SYS0.LINKLIB2.SOURCE(IEFUSI),DISP=SHR\n//*\n//STEP3    EXEC ASMFC,PARM.ASM='NOTERM,LIST,NODECK,OBJECT'\n//ASM.SYSGO DD DSN=SYS0.LINKLIB2.OBJ(IEFUTL),DISP=OLD\n//SYSIN     DD DSN=SYS0.LINKLIB2.SOURCE(IEFUTL),DISP=SHR\n//*\n//STEP4    EXEC IPOSMP4,COND=(0,NE)\n//SMPPTFIN     DD  *\n++ USERMOD (VS00010) .\n++ VER (Z038) FMID(JBB1222) .\n++ MOD (IEFUJI) DISTLIB(AOSB3) TXLIB(OBJECT) .\n++ MOD (IEFUSI) DISTLIB(AOSB3) TXLIB(OBJECT) .\n++ MOD (IEFUTL) DISTLIB(AOSB3) TXLIB(OBJECT) .\n//SYSIN   DD  *\n REJECT  S(VS00010) .\n RECEIVE S(VS00010) .\n APPLY   S(VS00010) DIS(NO) .\n LIST  CDS SYSMOD(VS00010) DIS(NO) .\n//OBJECT  DD DSN=SYS0.LINKLIB2.OBJ,DISP=SHR\n./ ADD NAME=VS00011  0104-80128-80128-1237-00173-00176-00000-$SYS13  00\n//VS00011 JOB (2000,S010),WENZEL,CLASS=Z\n/*JOBPARM Q=F,I\n//*\n//STEP1    EXEC ASMFCL\n//ASM.SYSLIB DD UNIT=DISK,VOL=SER=SYS100\n//ASM.SYSIN  DD  DISP=SHR,DSN=SYS0.LINKLIB2.SOURCE(BLDLSWIT)\n//LKED.SYSLMOD  DD  DISP=SHR,DSN=SYS2.LINKLIB\n//LKED.SYSIN    DD  *\n SETCODE AC(1)\n NAME  BLDLSWIT(R)\n//*\n//STEP2    EXEC ASMFCL,MAC1='SYS1.AMODGEN'\n//ASM.SYSLIB DD UNIT=DISK,VOL=SER=SYS100\n//           DD UNIT=DISK,VOL=SER=ITEL02\n//ASM.SYSIN  DD  DISP=SHR,DSN=SYS0.LINKLIB2.SOURCE(BLDLSTAT)\n//LKED.SYSLMOD  DD  DISP=SHR,DSN=SYS2.LINKLIB\n//LKED.SYSIN    DD  *\n NAME  BLDLSTAT(R)\n/*\n//STEP3    EXEC ASMFC,\n//          PARM.ASM='NOTERM,LIST,NODECK,OBJECT'\n//ASM.SYSLIB DD UNIT=DISK,VOL=SER=SYS100\n//ASM.SYSGO DD DISP=OLD,DSN=SYS0.LINKLIB2.OBJ(DYNBLDL)\n//SYSIN     DD DISP=SHR,DSN=SYS0.LINKLIB2.SOURCE(DYNBLDL)\n//*\n//STEP4    EXEC IPOSMP4\n//SYSIN DD *\n RECEIVE S(VS00011) .\n APPLY   S(VS00011) .\n LIST CDS SYSMOD(VS00011) .\n LIST CDS MOD(IGC018) .\n//NUCLEUSA DD DSN=SYS0.LINKLIB2.OBJ,DISP=SHR\n//SMPPTFIN DD DATA\n++ USERMOD (VS00011) .\n++ VER   (Z038)   FMID (EDM1102)  PRE (UZ90059)\n                 /*\n\n         DYNAMIC BLDL\n\n         THIS MODIFICATION SUPPLIES A DYNAMIC BLDL TABLE.\n         IT FRONT ENDS IGC018.  THIS MOD INCLUDES BOTH\n         THE FRONT END MODULE FOR IGC018 AND THE SYSGEN\n         MACRO UPDATE FOR THE INCLUSION OF THE NEW MODULE\n         AND THE EXTERNAL REFERENCE SYMBOL CHANGE.\n         IF PLACED ONTO AN EXISTING SYSTEM, JCLIN\n         WILL BE NECESSARY.\n\n         NOTE THAT IN ORDER FOR THE \"CHANGE\" STATEMENT\n         TO PROPERLY UPDATE THE BLDL MODULE (IGC018),\n         IT IS NECESSARY TO PERFORM A JCLIN AND APPLY\n         A PTF (OR OTHERWISE CAUSE SMP TO REPLACE IGC018).\n         IF YOU FAIL TO DO SO WHEN APPLYING THIS PTF\n         TO AN ALREADY GENERATED SYSTEM, BLDL WILL BE\n         IN RATHER POOR SHAPE.\n\n         DURING THE APPLY OF ANY PTF AGAINST THE ORIGINAL\n         IGC018 MODULE, AN ERROR MESSAGE WILL BE ISSUED\n         BY THE LINKAGE EDITOR, AS THE CSECT NAME OF IGC018\n         IS CHANGED TO IGC018A AND THE \"IDENTIFY\" STILL\n         REFERENCES THE ORIGINAL CSECT NAME. (NOTE THAT\n         CHANGING THE \"IDENTIFY\" WILL ONLY RESULT IN THE\n         ERROR MESSAGE BEING ISSUED AT ACCEPT TIME\n         INSTEAD OF APPLY TIME.\n\n         THE DYNAMIC BLDL CSECT (DYNBLDL) AS DISTRIBUTED\n         CONTAINS A 200 ENTRY TABLE.  THIS CAN BE CHANGED\n         BY UPDATING THE EQUATES FOR \"ENT1\" AND \"ENT1X\"\n         IN THE SOURCE FOR DYNBLDL AND REASSEMBLING.\n         EACH ENTRY TAKES 64 BYTES AND IS FIXED IN THE\n         NUCLEUS.  200 ENTRIES PROVIDED A \"HIT RATIO\" IN\n         EXCESS OF 95 PERCENT UNTIL THE 13 MOST POPULAR\n         PL/I EXECUTION TIME SUBROUTINES WERE PLACED IN\n         THE LINK PACK AREA.  THE \"HIT RATIO\" DROPPED\n         TO ABOUT 90 PERCENT.\n\n         SEPARATE PROGRAMS ARE AVAILABLE TO ENABLE/DISABLE\n         DYNAMIC BLDL AND TO RETRIEVE USE STATISTICS.\n         THESE AND \"BLDLSWIT\" AND \"BLDLSTAT\".\n         BLDLSWIT IS AN AUTHORIZED PROGRAM THAT WILL TURN\n         A SWITCH IN THE DYNAMIC BLDL MODULE ON AND OFF.\n         (WHEN DISABLING DYNAMIC BLDL, IT ALSO ZEROS THE\n         BLDL TABLE.)  NOTE, HOWEVER, WHEN DYNAMIC BLDL IS\n         DISABLED, THE SYSTEM WILL USE ONLY THE BLDL LIST\n         SUPPLIED THROUGH PARMLIB AT IPL TIME (IF ANY).\n         THIS CAN LEAD TO SERIOUS PERFORMANCE PROBLEMS.\n         BLDLSTAT IS AN UNAUTHORIZED PROGRAM WHICH WILL\n         DISPLAY THE CONTENTS OF THE BLDL TABLE AND WILL\n         GIVE USAGE STATISTICS AND PERCENTAGES.\n         IT CAN BE RUN FROM EITHER BATCH OR TSO.\n\n         SYSGEN MACRO:      SGIEC3FB\n         NEW MODULE:        DYNBLDL\n         MODULE DEPENDANCY: IGC018 (UZ90059 - 7909)\n\n                                                               */ .\n++ UPDTE (SGIEC3FB)  DISTLIB (AGENLIB) .\n><       CHANGE NAME=SGIEC3FB,LIST=ALL\n         PUNCH '         CHANGE IGC018(IGC018A)    DYNAM BLDL ' #Z00132\n         PUNCH '         INCLUDE NUCLEUSA(DYNBLDL) DYNAM BLDL ' #Z00132\n><       ENDUP\n++ MOD   (DYNBLDL)  DISTLIB (NUCLEUSA) TXLIB(NUCLEUSA).\n++ JCLIN .\n//NUC24 EXEC LINKS,COND=(4,LT),REGION=350K,\n// PARM='LIST,XREF,NCAL,SCTR,LET,SIZE=(300K,64K)',\n// UNIT='3330',SER=CCMVST,N=SYS1,NAME=NUCLEUS,P1='(',\n// MOD=IEANUC01,P2=')',OBJ=OBJPDS03,CLASS=M\n//SYSLIN DD *\n   INSERT  IEAVNIP0\n   INSERT  IEAVFX00\n INCLUDE AOS20(IGC058)\n INCLUDE AOS20(IECTATEN)\n INCLUDE SYSPUNCH(IEAASU00,IEASVC00,IEAVBK00,IEECVUCM)\n INCLUDE AOSC5(IECVURDT,IECVURSV,IECVRRSV)\n INCLUDE AOSC5(IECVESIO,IECVDURP)\n INCLUDE AOSC5(IEEVLDWT)\n    INCLUDE AOSC5(IECTCATN)\n INCLUDE SYSPUNCH(IFBCTA00)\n INCLUDE SYSPUNCH(IEFAQTOP)\n INCLUDE  SYSPUNCH(IECZDTAB)\n         CHANGE IGC018(IGC018A)    DYNAM BLDL\n INCLUDE  AOSD0(IGC018)\n         INCLUDE NUCLEUSA(DYNBLDL) DYNAM BLDL\n INCLUDE  SYSPUNCH(IFGDEBCK)\n INCLUDE AOSCE(IGFCCHCR)\n INCLUDE AOSCE(IGFCHDA)\n INCLUDE AOSCE(IGFTMC00)\n INSERT IGFPMCIH,IGFRWAC\n INSERT IGFPMPFX,IGFPMSCA,IGFPMHCA\n INSERT IGFPMRTM,IGFPMTHA,IGFPMFRS\n INSERT IGFPMMSG,IGFPMKTA,IGFPKREF\n INSERT IGFPTERM,IGFPTSIG\n INSERT IGFCCHED\n INSERT IGFPNRFH\n INSERT IGFPBUCR,IGFPEXIT\n INSERT IGFPSAD0\n INSERT IGFPTCON,IGFPTREC\n INCLUDE AOSCE(IGFPMCIH)\n INCLUDE AOSCE(IGFRWAC)\n INCLUDE AOSCE(IGFPMPFX)\n INCLUDE AOSCE(IGFPMSCA)\n INCLUDE AOSCE(IGFPMHCA)\n INCLUDE AOSCE(IGFPMRTM)\n INCLUDE AOSCE(IGFPMTHA)\n INCLUDE AOSCE(IGFPMFRS)\n INCLUDE AOSCE(IGFPMMSG)\n INCLUDE AOSCE(IGFPMKTA)\n INCLUDE AOSCE(IGFPKREF)\n INCLUDE AOSCE(IGFPTERM)\n INCLUDE AOSCE(IGFPTSIG)\n INCLUDE AOSCE(IGFCCHED)\n INCLUDE AOSCE(IGFPNRFH)\n INCLUDE AOSCE(IGFPBUCR)\n INCLUDE AOSCE(IGFPEXIT)\n INCLUDE AOSCE(IGFPSAD0)\n INCLUDE AOSCE(IGFPTCON)\n INCLUDE AOSCE(IGFPTREC)\n INCLUDE AOSCE(ICFBDX00)\n INCLUDE AOSCD(IFBDCB01)\n INCLUDE SYSPUNCH(IEECVD1)\n INCLUDE SYSPUNCH(IEECVH9)\n INCLUDE SYSPUNCH(IEECVH8)\n INCLUDE SYSPUNCH(IEECVH7)\n INCLUDE SYSPUNCH(IEECVH6)\n INCLUDE SYSPUNCH(IEECVH5)\n INCLUDE SYSPUNCH(IEECVH4)\n INCLUDE SYSPUNCH(IEECVH3)\n INCLUDE SYSPUNCH(IEECVH2)\n INCLUDE SYSPUNCH(IEECVH1)\n INCLUDE SYSPUNCH(IEECVSUB)\n INCLUDE SYSPUNCH(IEEPFKEY)\n INCLUDE SYSLMOD(IEANUC01)\n NAME IEANUC01(R)\n/*\n./ ADD NAME=VS000119 0100-80128-80128-1224-00176-00176-00000-$SYS13  00\n//VS00011 JOB (2000,S010),WENZEL,CLASS=Z\n/*JOBPARM Q=F,I\n//*\n//STEP1    EXEC ASMFCL,MAC1='SYS1.AMODGEN'\n//ASM.SYSLIB DD UNIT=DISK,VOL=SER=SYS100\n//          DD UNIT=DISK,VOL=SER=ITEL02\n//ASM.SYSIN  DD  DISP=SHR,DSN=SYS0.LINKLIB2.SOURCE(BLDLSWIT)\n//LKED.SYSLMOD  DD  DISP=SHR,DSN=SYS2.LINKLIB\n//LKED.SYSIN    DD  *\n SETCODE AC(1)\n NAME  BLDLSWIT(R)\n//*\n//STEP2    EXEC ASMFCL,MAC1='SYS1.AMODGEN'\n//ASM.SYSLIB DD UNIT=DISK,VOL=SER=SYS100\n//          DD UNIT=DISK,VOL=SER=ITEL02\n//ASM.SYSIN  DD  DISP=SHR,DSN=SYS0.LINKLIB2.SOURCE(BLDLSTAT)\n//LKED.SYSLMOD  DD  DISP=SHR,DSN=SYS2.LINKLIB\n//LKED.SYSIN    DD  *\n NAME  BLDLSTAT(R)\n/*\n//*STEP3    EXEC ASMFC,MAC1='SYS1.AMODGEN',\n//STEP3    EXEC ASMFC,\n//          PARM.ASM='NOTERM,LIST,NODECK,OBJECT'\n//ASM.SYSLIB DD UNIT=DISK,VOL=SER=SYS100\n//          DD UNIT=DISK,VOL=SER=ITEL02\n//ASM.SYSGO DD DISP=OLD,DSN=SYS0.LINKLIB2.OBJ(DYNBLDL)\n//SYSIN     DD DISP=SHR,DSN=SYS0.LINKLIB2.SOURCE(DYNBLDL)\n//*\n//STEP4    EXEC IPOSMP4\n//SYSIN DD *\n RECEIVE S(VS00011) .\n APPLY   S(VS00011) .\n LIST CDS SYSMOD(VS00011) .\n LIST CDS MOD(IGC018) .\n//NUCLEUSA DD DSN=SYS0.LINKLIB2.OBJ,DISP=SHR\n//SMPPTFIN DD DATA\n++ USERMOD (VS00011) .\n++ VER   (Z038)   FMID (EDM1102)  PRE (UZ90059)\n                 /*\n\n         DYNAMIC BLDL\n\n         THIS MODIFICATION SUPPLIES A DYNAMIC BLDL TABLE.\n         IT FRONT ENDS IGC018.  THIS MOD INCLUDES BOTH\n         THE FRONT END MODULE FOR IGC018 AND THE SYSGEN\n         MACRO UPDATE FOR THE INCLUSION OF THE NEW MODULE\n         AND THE EXTERNAL REFERENCE SYMBOL CHANGE.\n         IF PLACED ONTO AN EXISTING SYSTEM, JCLIN\n         WILL BE NECESSARY.\n\n         NOTE THAT IN ORDER FOR THE \"CHANGE\" STATEMENT\n         TO PROPERLY UPDATE THE BLDL MODULE (IGC018),\n         IT IS NECESSARY TO PERFORM A JCLIN AND APPLY\n         A PTF (OR OTHERWISE CAUSE SMP TO REPLACE IGC018).\n         IF YOU FAIL TO DO SO WHEN APPLYING THIS PTF\n         TO AN ALREADY GENERATED SYSTEM, BLDL WILL BE\n         IN RATHER POOR SHAPE.\n\n         DURING THE APPLY OF ANY PTF AGAINST THE ORIGINAL\n         IGC018 MODULE, AN ERROR MESSAGE WILL BE ISSUED\n         BY THE LINKAGE EDITOR, AS THE CSECT NAME OF IGC018\n         IS CHANGED TO IGC018A AND THE \"IDENTIFY\" STILL\n         REFERENCES THE ORIGINAL CSECT NAME. (NOTE THAT\n         CHANGING THE \"IDENTIFY\" WILL ONLY RESULT IN THE\n         ERROR MESSAGE BEING ISSUED AT ACCEPT TIME\n         INSTEAD OF APPLY TIME.\n\n         THE DYNAMIC BLDL CSECT (DYNBLDL) AS DISTRIBUTED\n         CONTAINS A 200 ENTRY TABLE.  THIS CAN BE CHANGED\n         BY UPDATING THE EQUATES FOR \"ENT1\" AND \"ENT1X\"\n         IN THE SOURCE FOR DYNBLDL AND REASSEMBLING.\n         EACH ENTRY TAKES 64 BYTES AND IS FIXED IN THE\n         NUCLEUS.  200 ENTRIES PROVIDED A \"HIT RATIO\" IN\n         EXCESS OF 95 PERCENT UNTIL THE 13 MOST POPULAR\n         PL/I EXECUTION TIME SUBROUTINES WERE PLACED IN\n         THE LINK PACK AREA.  THE \"HIT RATIO\" DROPPED\n         TO ABOUT 90 PERCENT.\n\n         SEPARATE PROGRAMS ARE AVAILABLE TO ENABLE/DISABLE\n         DYNAMIC BLDL AND TO RETRIEVE USE STATISTICS.\n         THESE AND \"BLDLSWIT\" AND \"BLDLSTAT\".\n         BLDLSWIT IS AN AUTHORIZED PROGRAM THAT WILL TURN\n         A SWITCH IN THE DYNAMIC BLDL MODULE ON AND OFF.\n         (WHEN DISABLING DYNAMIC BLDL, IT ALSO ZEROS THE\n         BLDL TABLE.)  NOTE, HOWEVER, WHEN DYNAMIC BLDL IS\n         DISABLED, THE SYSTEM WILL USE ONLY THE BLDL LIST\n         SUPPLIED THROUGH PARMLIB AT IPL TIME (IF ANY).\n         THIS CAN LEAD TO SERIOUS PERFORMANCE PROBLEMS.\n         BLDLSTAT IS AN UNAUTHORIZED PROGRAM WHICH WILL\n         DISPLAY THE CONTENTS OF THE BLDL TABLE AND WILL\n         GIVE USAGE STATISTICS AND PERCENTAGES.\n         IT CAN BE RUN FROM EITHER BATCH OR TSO.\n\n         SYSGEN MACRO:      SGIEC3FB\n         NEW MODULE:        DYNBLDL\n         MODULE DEPENDANCY: IGC018 (UZ90059 - 7909)\n\n                                                               */ .\n++ UPDTE (SGIEC3FB)  DISTLIB (AGENLIB) .\n><       CHANGE NAME=SGIEC3FB,LIST=ALL\n         PUNCH '         CHANGE IGC018(IGC018A)    DYNAM BLDL ' #Z00132\n         PUNCH '         INCLUDE NUCLEUSA(DYNBLDL) DYNAM BLDL ' #Z00132\n><       ENDUP\n++ MOD   (DYNBLDL)  DISTLIB (NUCLEUSA) TXLIB(NUCLEUSA).\n++ JCLIN .\n//NUC24 EXEC LINKS,COND=(4,LT),REGION=350K,\n// PARM='LIST,XREF,NCAL,SCTR,LET,SIZE=(300K,64K)',\n// UNIT='3330',SER=CCMVST,N=SYS1,NAME=NUCLEUS,P1='(',\n// MOD=IEANUC01,P2=')',OBJ=OBJPDS03,CLASS=M\n//SYSLIN DD *\n   INSERT  IEAVNIP0\n   INSERT  IEAVFX00\n INCLUDE AOS20(IGC058)\n INCLUDE AOS20(IECTATEN)\n INCLUDE SYSPUNCH(IEAASU00,IEASVC00,IEAVBK00,IEECVUCM)\n INCLUDE AOSC5(IECVURDT,IECVURSV,IECVRRSV)\n INCLUDE AOSC5(IECVESIO,IECVDURP)\n INCLUDE AOSC5(IEEVLDWT)\n    INCLUDE AOSC5(IECTCATN)\n INCLUDE SYSPUNCH(IFBCTA00)\n INCLUDE SYSPUNCH(IEFAQTOP)\n INCLUDE  SYSPUNCH(IECZDTAB)\n         CHANGE IGC018(IGC018A)    DYNAM BLDL\n INCLUDE  AOSD0(IGC018)\n         INCLUDE NUCLEUSA(DYNBLDL) DYNAM BLDL\n INCLUDE  SYSPUNCH(IFGDEBCK)\n INCLUDE AOSCE(IGFCCHCR)\n INCLUDE AOSCE(IGFCHDA)\n INCLUDE AOSCE(IGFTMC00)\n INSERT IGFPMCIH,IGFRWAC\n INSERT IGFPMPFX,IGFPMSCA,IGFPMHCA\n INSERT IGFPMRTM,IGFPMTHA,IGFPMFRS\n INSERT IGFPMMSG,IGFPMKTA,IGFPKREF\n INSERT IGFPTERM,IGFPTSIG\n INSERT IGFCCHED\n INSERT IGFPNRFH\n INSERT IGFPBUCR,IGFPEXIT\n INSERT IGFPSAD0\n INSERT IGFPTCON,IGFPTREC\n INCLUDE AOSCE(IGFPMCIH)\n INCLUDE AOSCE(IGFRWAC)\n INCLUDE AOSCE(IGFPMPFX)\n INCLUDE AOSCE(IGFPMSCA)\n INCLUDE AOSCE(IGFPMHCA)\n INCLUDE AOSCE(IGFPMRTM)\n INCLUDE AOSCE(IGFPMTHA)\n INCLUDE AOSCE(IGFPMFRS)\n INCLUDE AOSCE(IGFPMMSG)\n INCLUDE AOSCE(IGFPMKTA)\n INCLUDE AOSCE(IGFPKREF)\n INCLUDE AOSCE(IGFPTERM)\n INCLUDE AOSCE(IGFPTSIG)\n INCLUDE AOSCE(IGFCCHED)\n INCLUDE AOSCE(IGFPNRFH)\n INCLUDE AOSCE(IGFPBUCR)\n INCLUDE AOSCE(IGFPEXIT)\n INCLUDE AOSCE(IGFPSAD0)\n INCLUDE AOSCE(IGFPTCON)\n INCLUDE AOSCE(IGFPTREC)\n INCLUDE AOSCE(ICFBDX00)\n INCLUDE AOSCD(IFBDCB01)\n INCLUDE SYSPUNCH(IEECVD1)\n INCLUDE SYSPUNCH(IEECVH9)\n INCLUDE SYSPUNCH(IEECVH8)\n INCLUDE SYSPUNCH(IEECVH7)\n INCLUDE SYSPUNCH(IEECVH6)\n INCLUDE SYSPUNCH(IEECVH5)\n INCLUDE SYSPUNCH(IEECVH4)\n INCLUDE SYSPUNCH(IEECVH3)\n INCLUDE SYSPUNCH(IEECVH2)\n INCLUDE SYSPUNCH(IEECVH1)\n INCLUDE SYSPUNCH(IEECVSUB)\n INCLUDE SYSPUNCH(IEEPFKEY)\n INCLUDE SYSLMOD(IEANUC01)\n NAME IEANUC01(R)\n/*\n./ ADD NAME=VS00012  3808-80010-80137-1846-00035-00047-00026-$SYS13  00\n//VS00012 JOB   (2000,S010),WENZEL,CLASS=Z\n/*JOBPARM Q=F,I\n//SMP EXEC IPOSMP4\n//SMPCNTL DD *\n REJECT  S (VS00012).\n RESTORE S (VS00012).\n RECEIVE S (VS00012).\n APPLY S (VS00012)  .\n LIST CDS SYSMOD(VS00012).\n/*\n//SMPPTFIN DD *\n++ USERMOD(VS00012)      /* RESET PROFILE PREFIX TO BE USERID */.\n++ VER (Z038) FMID(JBB1112) PRE(UZ28125).\n++ ZAP (IKJEFLE).\n NAME IKJEFLE\n**********************************************************************\n VER  0ACE 47F0CB26               B     FNDPROC            NOT CHANGED\n VER  0B4A 5880B4C0      FNDPROC  L     @08,UADSNDAT\n VER  25FA 00000000      PATCHLOC DC    X'00000000'\n VER  25FE 00000000               DC    X'00000000'\n VER  2602 00000000               DC    X'00000000'\n VER  2606 00000000,0000          DC    X'000000000000'\n VER  260C 00000000               DC    X'00000000'\n VER  2610 00000000               DC    X'00000000'\n**********************************************************************\n REP  0B4A 47F095D8               B     PATCHLOC\n**********     BEGINING OF PATCH AREA     **********\n REP  25FA 5810B400      PATCHLOC L     R1,LWAPTR\n REP  25FE 58E01018               L     R14,LWAPSCB(,R1) PSCB PTR\n REP  2602 5810E034               L     R1,PSCBUPT(,14)  UPT PTR\n REP  2606 D2071010,E000          MVC   16(8,R1),0(R14)  MOVE ID\n REP  260C 5880B4C0               L     @08,UADSNDAT     FROM BEFORE\n REP  2610 47F0CB2A               B     FNDPROC+4        CONTINUE\n**********************************************************************\n IDRDATA VS00012\n./ ADD NAME=VS00013  3803-80010-80101-1347-00025-00027-00008-$SYS13  00\n//VS00013  JOB  (2000,S010),WENZEL,CLASS=Z\n/*JOBPARM Q=F,I\n//SMP EXEC IPOSMP4\n//SMPCNTL DD *\n RECEIVE S (VS00013).\n APPLY S (VS00013) .\n LOG (ELIMINATE BLDL FOR TSO EDIT AND TEST SUBCOMMANDS).\n LIST CDS SYSMOD(VS00013).\n LIST CDS   MOD(IKJEBECI,IKJEGCIV) .\n/*\n//SMPPTFIN DD *\n++ USERMOD(VS00013)   .       /* ELIMINATE BLDL FOR TSO EDIT AND */\n++ VER (Z038) FMID(EBB1102) . /* TEST SUBCOMMANDS               */\n++ ZAP (IKJEBECI)  .\n NAME IKJEBECI\n VER 021C 0A12\n VER 037C 9280F000\n REP 021C 1BFF\n REP 037C 9200\n IDRDATA VS00013\n++ ZAP (IKJEGCIV)  .\n NAME IKJEGCIV\n VER 00F4 0A12\n REP 00F4 1BFF\n IDRDATA VS00013\n./ ADD NAME=VS00014  0116-80089-80211-1255-00027-00048-00027-$SYS13  00\n//VS00014 JOB (2000,S010),WENZEL,CLASS=Z\n/*JOBPARM Q=F,I\n//*\n//*         STEP 1 ASSEMBLE IEFU84\n//*         STEP 2 SMP TO INSTALL AS SYSMOD NUMBER VS00014\n//*\n//STEP1    EXEC ASMFC,MAC1='SYS1.AMODGEN',\n//          PARM.ASM='NOTERM,LIST,NODECK,OBJECT'\n//ASM.SYSLIB DD UNIT=DISK,VOL=SER=SYS100\n//          DD UNIT=DISK,VOL=SER=ITEL02\n//ASM.SYSGO DD DSN=SYS0.LINKLIB2.OBJ(IEFU84),DISP=OLD\n//SYSIN     DD DSN=SYS0.LINKLIB2.SOURCE(IEFU84),DISP=SHR\n//*\n//STEP2  EXEC IPOSMP4,COND=(8,LT)\n//SMPCNTL  DD  *\n REJECT  S (VS00014).\n RESTORE S (VS00014).\n RECEIVE S (VS00014).\n APPLY   S (VS00014) DIS(WRITE).\n LOG (SMF EXIT- RPW/07/28/80).\n LIST  CDS SYSMOD(VS00014) DIS(NO).\n//SMPPTFIN  DD  *\n++ USERMOD (VS00014) .\n++ VER (Z038) FMID(JBB1222) .\n++ MOD (IEFU84) TXLIB(OBJECT).\n//OBJECT    DD  DISP=SHR,DSN=SYS0.LINKLIB2.OBJ\n//********************************************************************\n./ ADD NAME=VS00015  3804-80010-80101-1348-00017-00018-00017-$SYS13  00\n//VS00015  JOB  (2000,S010),WENZEL,CLASS=Z\n/*JOBPARM Q=F,I\n//SMP EXEC IPOSMP4\n//SMPCNTL DD *\n RECEIVE S (VS00015) .\n APPLY   S (VS00015) .\n LIST CDS  MOD(IKJEBESA) .\n LIST CDS  SYSMOD(VS00015) .\n//SMPPTFIN DD *     SU11 TSO CMD PACKAGE\n++ USERMOD (VS00015)      /* CHANGE TSO EDIT TO RELEASE SPACE\n                         FOR NEW DATASETS                 */.\n++ VER(Z038) PRE(UZ29594) FMID(JBB1112) .\n++ ZAP (IKJEBESA) .   /* PTF UZ29594 */\n NAME IKJEBESA\n VER 139C 04020840      SADA8N   DC   DISP=(NEW,CATLG)\n REP 139C 04020850                    DISP=(NEW,CATLG),RLSE\n IDRDATA VS00015\n./ ADD NAME=VS00016  3808-80010-80102-1945-00036-00023-00035-$SYS13  00\n//VS00016 JOB (2000,S010),WENZEL,CLASS=Z\n/*JOBPARM Q=F,I\n//*\n//*         STEP 1 ASSEMBLE IGC0024I\n//*         STEP 2 SMP TO INSTALL AS SYSMOD NUMBER VS00016\n//*\n//STEP1    EXEC ASMFC,MAC1='SYS1.AMODGEN',\n//          PARM.ASM='NOTERM,LIST,NODECK,OBJECT'\n//ASM.SYSLIB DD UNIT=DISK,VOL=SER=ITEL01\n//          DD UNIT=DISK,VOL=SER=ITEL02\n//ASM.SYSGO DD DISP=OLD,DSN=SYS0.LINKLIB2.OBJ(IGC0024I)\n//SYSIN     DD DISP=SHR,DSN=SYS0.LINKLIB2.SOURCE(IGC0024I)\n//*\n//STEP2    EXEC IPOSMP4,COND=(8,LT)\n//SYSIN DD *\n RECEIVE S (VS00016) .\n APPLY   S (VS00016) .\n LOG (UPDATE SMP CDS WITH SVC FOR WYLBUR).\n LIST  CDS SYSMOD (VS00016) .\n//WYLBUR   DD  DISP=SHR,DSN=SYS0.LINKLIB2.OBJ(IGC0024I)\n//SMPPTFIN DD  DATA\n++ USERMOD (VS00016) .\n++ VER (Z038) FMID(EBB1102) .\n++ MOD (IGC0024I) DISTLIB(WYLBUR) TXLIB(WYLBUR) .\n++ JCLIN .\n//LKED     EXEC PGM=IEWL,PARM='XREF,LIST,LET,NCAL'\n//* REFER SYS1.PROCLIB(LKED)\n//SYSPRINT DD  SYSOUT=*\n//WYLBUR   DD  DISP=SHR,DSN=SYS0.LINKLIB2.OBJ(IGC0024I)\n//SYSLMOD  DD  DISP=OLD,DSN=SYS1.LPALIB(IGC0024I)\n//SYSUT1   DD  UNIT=VIO,\n//         SPACE=(1024,(200,20))\n//SYSLIN   DD  *\n INCLUDE   WYLBUR(IGC0024I)\n NAME      IGC0024I(R)\n/*\n./ ADD NAME=VS00017  0110-79358-80101-1656-00019-00016-00000-$SYS03  00\n//VS00017  JOB (2000,S010),S.CAIRES,CLASS=A,MSGCLASS=A\n/*JOBPARM Q=F,I\n//* VS00017 FROM FOWLER MEMOREX.\n//VS00017  EXEC IPOSMP4           DLIB=PAG002,RES=SYS101,PTS=PAG002\n//SYSIN DD *\n REJECT  S (VS00017) .\n RECEIVE S (VS00017) .\n LIST  PTS SYSMOD(VS00017) .\n APPLY   S (VS00017) CHECK BYPASS(REQ) /* DIS(READ) */ .\n//SMPPTFIN DD  *\n++ USERMOD (VS00017) /* PUT JOB NAME ON THE PUNCH SEPARATOR CARD */ .\n++ VER (Z038)  FMID(EJE1102)\n       PRE (AZ40644, UZ24622)\n       REQ (VS00018, VS00025, VS00033) .\n++ SRCUPD (HASPPRPU) DISTLIB(HASPSRC) .\n>< CHANGE NAME=HASPPRPU\n         MVC   BUFSTART(8),JCTJNAME     MOVE JOB NAME TO PUNCH  VS00017 Q1687010\n><  ENDUP                                                               Q9999999\n/*\n./ ADD NAME=VS00018  0109-79358-80101-1659-00020-00018-00000-$SYS03  00\n//VS00018  JOB (2000,S010),S.CAIRES,CLASS=Z,MSGCLASS=A\n/*JOBPARM Q=F,I\n//* VS00018 FROM FOWLER MEMOREX.\n//VS00018  EXEC IPOSMP4          DLIB=PAG002,RES=SYS101,PTS=PAG002\n//SYSIN  DD  *\n RECEIVE S (VS00018).\n LIST PTS SYSMOD(VS00018) .\n APPLY   S (VS00018) CHECK BYPASS(REQ) /* DIS(READ) */ .\n//SMPPTFIN DD  *\n++ USERMOD (VS00018) /* SET THE DEFAULT MSGCLASS TO \"A\" FOR A\n                        TSO-SUBMITTED JOB */ .\n++ VER (Z038) FMID(EJE1102)\n       PRE (#Z90235, UZ24623, UZ24947)\n       REQ (VS00017, VS00025, VS00033) .\n++ SRCUPD (HASPRDR) DISTLIB (HASPSRC) .\n>< CHANGE NAME=HASPRDR\n         MVI   JCTMCLAS,C'A'            SET DEFAULT MSGCLASS=A  VS00018 R2567500\n         CLI   JCTJOBID,C'J'            IS THIS A JOB           VS00018 R2567600\n         BE    *+10                     BIF SO - USE MSGCLASS=A VS00018 R2567700\n><  ENDUP                                                               R9999999\n./ ADD NAME=VS00019  3803-80010-80102-1149-00020-00022-00018-$SYS13  00\n//VS00019 JOB (2000,S010),WENZEL,CLASS=Z\n/*JOBPARM Q=F,I\n//*\n//*   INSTALL THE IDMS SVC  219\n//*\n//VS00019  EXEC IPOSMP4\n//SYSIN DD *\n UCLIN CDS .\n ADD MOD(IGC219) LMOD(IEANUC01) DISTLIB(IDMS) FMID(EBB1102) .\n ENDUCL .\n RECEIVE S(VS00019) .\n APPLY   S(VS00019) .\n LOG (ADD SVC  219 FOR IDMS) .\n LIST CDS SYSMOD(VS00019) .\n//SMPPTFIN DD *\n++ USERMOD (VS00019) .\n++ VER (Z038) FMID(EBB1102) .\n++ MOD (IGC219)   DISTLIB(IDMS) LKLIB(IDMS) .\n/*\n//IDMS   DD DISP=SHR,DSN=SYS3.IDMS.LOAD\n./ ADD NAME=VS00020  0101-80101-80101-1135-00320-00320-00001-$SYS13  00\n//VS00020 JOB (2000,S010),WENZEL,CLASS=Z\n/*JOBPARM Q=F,I\n//*\n//LPALNK EXEC PGM=IEBCOPY\n//SYSPRINT   DD SYSOUT=*\n//SYSUT3     DD UNIT=SYSDA,SPACE=(CYL,(10,10))\n//SYSUT4     DD UNIT=SYSDA,SPACE=(CYL,(10,10))\n//LPALIB     DD DSN=SYS1.LPALIB,DISP=OLD,UNIT=DISK,VOL=SER=ITEL01\n//SLINKDD    DD DSN=SYS1.LINKLIB,DISP=SHR,UNIT=DISK,VOL=SER=ITEL01\n//SYSIN      DD *\n COPY OUTDD=LPALIB,INDD=SLINKDD\n S M=IDCAL01\n S M=IDCAMS\n S M=IDCBI01\n S M=IDCCC01\n S M=IDCCDAL\n S M=IDCCDBI\n S M=IDCCDCC\n S M=IDCCDCK\n S M=IDCCDDE\n S M=IDCCDDL\n S M=IDCCDLC\n S M=IDCCDLR\n S M=IDCCDMP\n S M=IDCCDPM\n S M=IDCCDPR\n S M=IDCCDRC\n S M=IDCCDRM\n S M=IDCCDRP\n S M=IDCCDRS\n S M=IDCCDVY\n S M=IDCCDXP\n S M=IDCCK01\n S M=IDCDB01\n S M=IDCDB02\n S M=IDCDE01\n S M=IDCDL01\n S M=IDCIO04\n S M=IDCLC01\n S M=IDCLR01\n S M=IDCMP01\n S M=IDCPM01\n S M=IDCPR01\n S M=IDCRC01\n S M=IDCRIKT\n S M=IDCRILT\n S M=IDCRI01\n S M=IDCRI04\n S M=IDCRM01\n S M=IDCRP01\n S M=IDCRS01\n S M=IDCSATO\n S M=IDCTSAL0\n S M=IDCTSBI0\n S M=IDCTSCC0\n S M=IDCTSCK0\n S M=IDCTSDE0\n S M=IDCTSDL0\n S M=IDCTSEX0\n S M=IDCTSIO0\n S M=IDCTSLC0\n S M=IDCTSLC1\n S M=IDCTSLR0\n S M=IDCTSLR1\n S M=IDCTSMP0\n S M=IDCTSPR0\n S M=IDCTSRC0\n S M=IDCTSRI0\n S M=IDCTSRI1\n S M=IDCTSRS0\n S M=IDCTSSA0\n S M=IDCTSTP0\n S M=IDCTSTP1\n S M=IDCTSTP6\n S M=IDCTSUV0\n S M=IDCTSXP0\n S M=IDCVY01\n S M=IDCXP01\n S M=IKJCT467\n S M=IKJCT469\n S M=IKJEES40\n S M=IKJEES73\n S M=IKJEFA10\n S M=IKJEFA20\n S M=IKJEFA30\n S M=IKJEFA40\n S M=IKJEFF03\n S M=IKJEFF04\n S M=IKJEFF15\n S M=IKJEFF18\n S M=IKJEFF19\n S M=IKJEFF50\n S M=IKJEFF51\n S M=IKJEFF55\n S M=IKJEFF57\n S M=IKJEFT25\n S M=IKJRBBCR\n S M=IKJEFF10\n S M=IKJEFF53\n S M=ACCOUNT\n S M=AMBLIST\n S M=HEWLDRGO\n S M=HEWLOAD\n S M=HEWLOADR\n S M=HMBLIST\n S M=IAPAP100\n S M=IAPTIMER\n S M=IEAVMASV\n S M=IEAVMQR0\n S M=IEAVMWTL\n S M=IEAVTMSI\n S M=IEAVTPUT\n S M=IEAVVINT\n S M=IEBCRANL\n S M=IEBCREAT\n S M=IEBDG\n S M=IEBDGCUP\n S M=IEBDGMSG\n S M=IEBFDANL\n S M=IEBFDTBL\n S M=IEBISAM\n S M=IEBISC\n S M=IEBISF\n S M=IEBISL\n S M=IEBISPL\n S M=IEBISU\n S M=IEDQEC\n S M=IEDQES\n S M=IEDQEW\n S M=IEDQGQ\n S M=IEDQNF\n S M=IEDQNG\n S M=IEDQNH\n S M=IEDQNJ\n S M=IEDQNK\n S M=IEDQNM\n S M=IEDQNO\n S M=IEDQNP\n S M=IEDQNQ\n S M=IEDQNR\n S M=IEDQNS\n S M=IEDQNX\n S M=IEDQWO\n S M=IEECVGCI\n S M=IEEPGEXP\n S M=IEESB601\n S M=IEEVSEND\n S M=IEHATLAS\n S M=IEWLDRGO\n S M=IEWLOAD\n S M=IEWLOADR\n S M=IFASMFDP\n S M=IGFCIC\n S M=IGFC60\n S M=IGFC70\n S M=IGFC80\n S M=IGG0CLA0\n S M=ILROPS00\n S M=ILRPGEXP\n S M=ILRPREAD\n S M=IMBLIST\n S M=LOADER\n/*\n//*\n//LINKUCL EXEC IPOSMP4        UCLIN: LINKLIB ---> LPALIB\n//SYSIN   DD  *\n  UCLIN CDS DIS(WRITE).\n  ADD LMOD(IDCAL01)    SYSLIB(LPALIB).\n  ADD LMOD(IDCAMS)     SYSLIB(LPALIB).\n  ADD LMOD(IDCBI01)    SYSLIB(LPALIB).\n  ADD LMOD(IDCCC01)    SYSLIB(LPALIB).\n  ADD LMOD(IDCCDAL)    SYSLIB(LPALIB).\n  ADD LMOD(IDCCDBI)    SYSLIB(LPALIB).\n  ADD LMOD(IDCCDCC)    SYSLIB(LPALIB).\n  ADD LMOD(IDCCDCK)    SYSLIB(LPALIB).\n  ADD LMOD(IDCCDDE)    SYSLIB(LPALIB).\n  ADD LMOD(IDCCDDL)    SYSLIB(LPALIB).\n  ADD LMOD(IDCCDLC)    SYSLIB(LPALIB).\n  ADD LMOD(IDCCDLR)    SYSLIB(LPALIB).\n  ADD LMOD(IDCCDMP)    SYSLIB(LPALIB).\n  ADD LMOD(IDCCDPM)    SYSLIB(LPALIB).\n  ADD LMOD(IDCCDPR)    SYSLIB(LPALIB).\n  ADD LMOD(IDCCDRC)    SYSLIB(LPALIB).\n  ADD LMOD(IDCCDRM)    SYSLIB(LPALIB).\n  ADD LMOD(IDCCDRP)    SYSLIB(LPALIB).\n  ADD LMOD(IDCCDRS)    SYSLIB(LPALIB).\n  ADD LMOD(IDCCDVY)    SYSLIB(LPALIB).\n  ADD LMOD(IDCCDXP)    SYSLIB(LPALIB).\n  ADD LMOD(IDCCK01)    SYSLIB(LPALIB).\n  ADD LMOD(IDCDB01)    SYSLIB(LPALIB).\n  ADD LMOD(IDCDB02)    SYSLIB(LPALIB).\n  ADD LMOD(IDCDE01)    SYSLIB(LPALIB).\n  ADD LMOD(IDCDL01)    SYSLIB(LPALIB).\n  ADD LMOD(IDCIO04)    SYSLIB(LPALIB).\n  ADD LMOD(IDCLC01)    SYSLIB(LPALIB).\n  ADD LMOD(IDCLR01)    SYSLIB(LPALIB).\n  ADD LMOD(IDCMP01)    SYSLIB(LPALIB).\n  ADD LMOD(IDCPM01)    SYSLIB(LPALIB).\n  ADD LMOD(IDCPR01)    SYSLIB(LPALIB).\n  ADD LMOD(IDCRC01)    SYSLIB(LPALIB).\n  ADD LMOD(IDCRIKT)    SYSLIB(LPALIB).\n  ADD LMOD(IDCRILT)    SYSLIB(LPALIB).\n  ADD LMOD(IDCRI01)    SYSLIB(LPALIB).\n  ADD LMOD(IDCRI04)    SYSLIB(LPALIB).\n  ADD LMOD(IDCRM01)    SYSLIB(LPALIB).\n  ADD LMOD(IDCRP01)    SYSLIB(LPALIB).\n  ADD LMOD(IDCRS01)    SYSLIB(LPALIB).\n  ADD LMOD(IDCSATO)    SYSLIB(LPALIB).\n  ADD LMOD(IDCTSAL0)   SYSLIB(LPALIB).\n  ADD LMOD(IDCTSBI0)   SYSLIB(LPALIB).\n  ADD LMOD(IDCTSCC0)   SYSLIB(LPALIB).\n  ADD LMOD(IDCTSCK0)   SYSLIB(LPALIB).\n  ADD LMOD(IDCTSDE0)   SYSLIB(LPALIB).\n  ADD LMOD(IDCTSDL0)   SYSLIB(LPALIB).\n  ADD LMOD(IDCTSEX0)   SYSLIB(LPALIB).\n  ADD LMOD(IDCTSIO0)   SYSLIB(LPALIB).\n  ADD LMOD(IDCTSLC0)   SYSLIB(LPALIB).\n  ADD LMOD(IDCTSLC1)   SYSLIB(LPALIB).\n  ADD LMOD(IDCTSLR0)   SYSLIB(LPALIB).\n  ADD LMOD(IDCTSLR1)   SYSLIB(LPALIB).\n  ADD LMOD(IDCTSMP0)   SYSLIB(LPALIB).\n  ADD LMOD(IDCTSPR0)   SYSLIB(LPALIB).\n  ADD LMOD(IDCTSRC0)   SYSLIB(LPALIB).\n  ADD LMOD(IDCTSRI0)   SYSLIB(LPALIB).\n  ADD LMOD(IDCTSRI1)   SYSLIB(LPALIB).\n  ADD LMOD(IDCTSRS0)   SYSLIB(LPALIB).\n  ADD LMOD(IDCTSSA0)   SYSLIB(LPALIB).\n  ADD LMOD(IDCTSTP0)   SYSLIB(LPALIB).\n  ADD LMOD(IDCTSTP1)   SYSLIB(LPALIB).\n  ADD LMOD(IDCTSTP6)   SYSLIB(LPALIB).\n  ADD LMOD(IDCTSUV0)   SYSLIB(LPALIB).\n  ADD LMOD(IDCTSXP0)   SYSLIB(LPALIB).\n  ADD LMOD(IDCVY01)    SYSLIB(LPALIB).\n  ADD LMOD(IDCXP01)    SYSLIB(LPALIB).\n  ADD LMOD(IKJCT467)   SYSLIB(LPALIB).\n  ADD LMOD(IKJCT469)   SYSLIB(LPALIB).\n  ADD LMOD(IKJEES40)   SYSLIB(LPALIB).\n  ADD LMOD(IKJEES73)   SYSLIB(LPALIB).\n  ADD LMOD(IKJEFA10)   SYSLIB(LPALIB).\n  ADD LMOD(IKJEFA20)   SYSLIB(LPALIB).\n  ADD LMOD(IKJEFA30)   SYSLIB(LPALIB).\n  ADD LMOD(IKJEFA40)   SYSLIB(LPALIB).\n  ADD LMOD(IKJEFF03)   SYSLIB(LPALIB).\n  ADD LMOD(IKJEFF04)   SYSLIB(LPALIB).\n  ADD LMOD(IKJEFF15)   SYSLIB(LPALIB).\n  ADD LMOD(IKJEFF18)   SYSLIB(LPALIB).\n  ADD LMOD(IKJEFF19)   SYSLIB(LPALIB).\n  ADD LMOD(IKJEFF50)   SYSLIB(LPALIB).\n  ADD LMOD(IKJEFF51)   SYSLIB(LPALIB).\n  ADD LMOD(IKJEFF55)   SYSLIB(LPALIB).\n  ADD LMOD(IKJEFF57)   SYSLIB(LPALIB).\n  ADD LMOD(IKJEFT25)   SYSLIB(LPALIB).\n  ADD LMOD(IKJRBBCR)   SYSLIB(LPALIB).\n  ADD LMOD(IKJEFF10)   SYSLIB(LPALIB).\n  ADD LMOD(IKJEFF53)   SYSLIB(LPALIB).\n  ADD LMOD(ACCOUNT)    SYSLIB(LPALIB).\n  ADD LMOD(AMBLIST)    SYSLIB(LPALIB).\n  ADD LMOD(HEWLDRGO)   SYSLIB(LPALIB).\n  ADD LMOD(HEWLOAD)    SYSLIB(LPALIB).\n  ADD LMOD(HEWLOADR)   SYSLIB(LPALIB).\n  ADD LMOD(HMBLIST)    SYSLIB(LPALIB).\n  ADD LMOD(IAPAP100)   SYSLIB(LPALIB).\n  ADD LMOD(IAPTIMER)   SYSLIB(LPALIB).\n  ADD LMOD(IEAVMASV)   SYSLIB(LPALIB).\n  ADD LMOD(IEAVMQR0)   SYSLIB(LPALIB).\n  ADD LMOD(IEAVMWTL)   SYSLIB(LPALIB).\n  ADD LMOD(IEAVTMSI)   SYSLIB(LPALIB).\n  ADD LMOD(IEAVTPUT)   SYSLIB(LPALIB).\n  ADD LMOD(IEAVVINT)   SYSLIB(LPALIB).\n  ADD LMOD(IEBCRANL)   SYSLIB(LPALIB).\n  ADD LMOD(IEBCREAT)   SYSLIB(LPALIB).\n  ADD LMOD(IEBDG)      SYSLIB(LPALIB).\n  ADD LMOD(IEBDGCUP)   SYSLIB(LPALIB).\n  ADD LMOD(IEBDGMSG)   SYSLIB(LPALIB).\n  ADD LMOD(IEBFDANL)   SYSLIB(LPALIB).\n  ADD LMOD(IEBFDTBL)   SYSLIB(LPALIB).\n  ADD LMOD(IEBISAM)    SYSLIB(LPALIB).\n  ADD LMOD(IEBISC)     SYSLIB(LPALIB).\n  ADD LMOD(IEBISF)     SYSLIB(LPALIB).\n  ADD LMOD(IEBISL)     SYSLIB(LPALIB).\n  ADD LMOD(IEBISPL)    SYSLIB(LPALIB).\n  ADD LMOD(IEBISU)     SYSLIB(LPALIB).\n  ADD LMOD(IEDQEC)     SYSLIB(LPALIB).\n  ADD LMOD(IEDQES)     SYSLIB(LPALIB).\n  ADD LMOD(IEDQEW)     SYSLIB(LPALIB).\n  ADD LMOD(IEDQGQ)     SYSLIB(LPALIB).\n  ADD LMOD(IEDQNF)     SYSLIB(LPALIB).\n  ADD LMOD(IEDQNG)     SYSLIB(LPALIB).\n  ADD LMOD(IEDQNH)     SYSLIB(LPALIB).\n  ADD LMOD(IEDQNJ)     SYSLIB(LPALIB).\n  ADD LMOD(IEDQNK)     SYSLIB(LPALIB).\n  ADD LMOD(IEDQNM)     SYSLIB(LPALIB).\n  ADD LMOD(IEDQNO)     SYSLIB(LPALIB).\n  ADD LMOD(IEDQNP)     SYSLIB(LPALIB).\n  ADD LMOD(IEDQNQ)     SYSLIB(LPALIB).\n  ADD LMOD(IEDQNR)     SYSLIB(LPALIB).\n  ADD LMOD(IEDQNS)     SYSLIB(LPALIB).\n  ADD LMOD(IEDQNX)     SYSLIB(LPALIB).\n  ADD LMOD(IEDQWO)     SYSLIB(LPALIB).\n  ADD LMOD(IEECVGCI)   SYSLIB(LPALIB).\n  ADD LMOD(IEEPGEXP)   SYSLIB(LPALIB).\n  ADD LMOD(IEESB601)   SYSLIB(LPALIB).\n  ADD LMOD(IEEVSEND)   SYSLIB(LPALIB).\n  ADD LMOD(IEHATLAS)   SYSLIB(LPALIB).\n  ADD LMOD(IEWLDRGO)   SYSLIB(LPALIB).\n  ADD LMOD(IEWLOAD)    SYSLIB(LPALIB).\n  ADD LMOD(IEWLOADR)   SYSLIB(LPALIB).\n  ADD LMOD(IFASMFDP)   SYSLIB(LPALIB).\n  ADD LMOD(IGFCIC)     SYSLIB(LPALIB).\n  ADD LMOD(IGFC60)     SYSLIB(LPALIB).\n  ADD LMOD(IGFC70)     SYSLIB(LPALIB).\n  ADD LMOD(IGFC80)     SYSLIB(LPALIB).\n  ADD LMOD(IGG0CLA0)   SYSLIB(LPALIB).\n  ADD LMOD(ILROPS00)   SYSLIB(LPALIB).\n  ADD LMOD(ILRPGEXP)   SYSLIB(LPALIB).\n  ADD LMOD(ILRPREAD)   SYSLIB(LPALIB).\n  ADD LMOD(IMBLIST)    SYSLIB(LPALIB).\n  ADD LMOD(LOADER)     SYSLIB(LPALIB).\n  ENDUCL.\n/*\n./ ADD NAME=VS00021  0105-80102-80191-1717-00029-00026-00029-$SYS13  00\n//VS00021  JOB (2000,S010),WENZEL,CLASS=Z\n/*JOBPARM Q=F,I\n//*\n//*            MOVE SYNCSORT REENTRANT MODULES TO LPALIB\n//*\n//IPOSMP4 EXEC IPOSMP4\n//SMP.SMPCNTL   DD  *\n REJECT  S (VS00021) .\n RECEIVE S (VS00021) .\n APPLY  S (VS00021) .\n LIST  CDS SYSMOD(VS00021) .\n LOG (UPDATE SMP CDS WITH SYNCSORT MODULES DESTINED FOR LPALIB).\n//SYNCSORT DD DISP=SHR,DSN=SYS4.SYNCSORT.V23G.LPALIB\n//SMPPTFIN  DD  DATA\n++ USERMOD (VS00021)  /* SYNCSORT MODULES IN LPALIB */ .\n++ VER (Z038) FMID(EDM1102) .\n++ MOD (IGX00017) DISTLIB(SYNCSORT) LKLIB(SYNCSORT) .\n++ MOD (WCSREENT) DISTLIB(SYNCSORT) LKLIB(SYNCSORT) .\n++ JCLIN.\n//STEP1  EXEC PGM=IEBCOPY\n//SYNCSORT DD DISP=SHR,DSN=SYS4.SYNCSORT.V23G.LPALIB\n//LPALIB   DD DISP=SHR,DSN=SYS1.LPALIB,\n//            VOL=SER=SYS100,UNIT=DISK\n//SYSPRINT DD SYSOUT=*\n//SYSIN    DD *\n C I=((SYNCSORT,R)),O=LPALIB\n S M=IGX00017\n S M=WCSREENT\n/*\n./ ADD NAME=VS00022  0107-79026-80101-1013-00096-00067-00049-$SYS03  00\n//VS00022  JOB (2000,S010),S.CAIRES,CLASS=A,MSGCLASS=A\n/*JOBPARM Q=F,I\n//*\n//* VS00022 TAKEN FROM WENZEL'S SYS.IPO40.SMP.CNTL(VS00022).\n//* NEEDS CHANGES FOR SMP4.\n//*\n//IPOSMP4 EXEC IPOSMP4           DLIB=PAG002,RES=SYS101,PTS=PAG002\n//SMP.SMPCNTL   DD  *\n LIST  PTS SYSMOD(VS00022) .\n APPLY  S (VS00022) DIS(WRITE) /* BACKUP CDS AND ACDS BEFORE WRITE */ .\n LIST  CDS SYSMOD(VS00022) .\n LOG (UPDATE SMP CDS WITH TMS MODULES DESTINED FOR LPALIB).\n/*\n//*\n//*\n//*\n//DUMMYJCL DD *   UNUSED CARDS\n JCLIN /* UPDATE SMP CDS WITH TMS MODULES DESTINED FOR LPALIB */\n  DIS(WRITE) /* JCLIN DEFAULT -- BACKUP CDS AND ACDS BEFORE WRITE */ .\n REJECT  S (VS00022) .\n RECEIVE S (VS00022) .\n APPLY  S (VS00022) CHECK DIS(READ) /* APPLY DEFAULT */ .\n/*\n//*\n//*\n//*\n//TMS      DD DISP=SHR,DSN=SYS3.TMS.LPALIB,\n//            VOL=SER=SYS101,UNIT=DISK\n//*\n//SMPJCLIN  DD DATA\n//TMS  JOB (8220,0952),WENZEL,MSGCLASS=X,NOTIFY=$SYS13,CLASS=Z\n//STEP1  EXEC PGM=IEBCOPY\n//TMS      DD DISP=SHR,DSN=SYS3.TMS.LPALIB,\n//            VOL=SER=SYS101,UNIT=DISK\n//LPALIB   DD DISP=SHR,DSN=SYS1.LPALIB,\n//            VOL=SER=SYS101,UNIT=DISK\n//SYSPRINT DD SYSOUT=*\n//*\n//* THESE MEMBER NAMES MAY CHANGE WITH NEW RELEASES OF TMS.\n//*\n//SYSIN    DD *\n C I=((TMS,R)),O=LPALIB\n S M=IGC0A24H\n S M=IGC0B24H\n S M=IGC0C24H\n S M=IGC0D24H\n S M=IGC0E24H\n S M=IGC0F24H\n S M=IGC0024H\n S M=IGC0124H\n S M=IGC0224H\n S M=IGC0324H\n S M=IGC0424H\n S M=IGC0524H\n S M=IGC0624H\n S M=IGC0724H\n S M=IGC0824H\n S M=IGC0924H\n S M=IGC0024G\n S M=IGC0124G\n S M=IGC0224G\n S M=IGC0324G\n S M=IGC0424G\n S M=IGC0524G\n S M=IGC0624G\n S M=IGG24700\n/*\n//*\n//SMPPTFIN  DD  *\n++ USERMOD (VS00022)  /* UCC-1 TMS MODULES IN LPALIB */ .\n++ VER (Z038) FMID(EDM1102) .\n++ MOD (IGC0A24H) DISTLIB(TMS) LKLIB(TMS) .\n++ MOD (IGC0B24H) DISTLIB(TMS) LKLIB(TMS) .\n++ MOD (IGC0C24H) DISTLIB(TMS) LKLIB(TMS) .\n++ MOD (IGC0D24H) DISTLIB(TMS) LKLIB(TMS) .\n++ MOD (IGC0E24H) DISTLIB(TMS) LKLIB(TMS) .\n++ MOD (IGC0F24H) DISTLIB(TMS) LKLIB(TMS) .\n++ MOD (IGC0024H) DISTLIB(TMS) LKLIB(TMS) .\n++ MOD (IGC0124H) DISTLIB(TMS) LKLIB(TMS) .\n++ MOD (IGC0224H) DISTLIB(TMS) LKLIB(TMS) .\n++ MOD (IGC0324H) DISTLIB(TMS) LKLIB(TMS) .\n++ MOD (IGC0424H) DISTLIB(TMS) LKLIB(TMS) .\n++ MOD (IGC0524H) DISTLIB(TMS) LKLIB(TMS) .\n++ MOD (IGC0624H) DISTLIB(TMS) LKLIB(TMS) .\n++ MOD (IGC0724H) DISTLIB(TMS) LKLIB(TMS) .\n++ MOD (IGC0824H) DISTLIB(TMS) LKLIB(TMS) .\n++ MOD (IGC0924H) DISTLIB(TMS) LKLIB(TMS) .\n++ MOD (IGC0024G) DISTLIB(TMS) LKLIB(TMS) .\n++ MOD (IGC0124G) DISTLIB(TMS) LKLIB(TMS) .\n++ MOD (IGC0224G) DISTLIB(TMS) LKLIB(TMS) .\n++ MOD (IGC0324G) DISTLIB(TMS) LKLIB(TMS) .\n++ MOD (IGC0424G) DISTLIB(TMS) LKLIB(TMS) .\n++ MOD (IGC0524G) DISTLIB(TMS) LKLIB(TMS) .\n++ MOD (IGC0624G) DISTLIB(TMS) LKLIB(TMS) .\n++ MOD (IGG24700) DISTLIB(TMS) LKLIB(TMS) .\n/*\n./ ADD NAME=VS00023  0108-79329-80102-0855-00022-00031-00018-$SYS13  00\n//VS00023 JOB (2000,S010),WENZEL,CLASS=Z\n/*JOBPARM Q=F,I\n//*\n//*         STEP 1 ASSEMBLE IEFACTRT\n//*         STEP 2 SMP TO RECEIVE SYSMOD NUMBER VS00023.\n//*                HAS A COREQ OF VS00024.\n//*\n//STEP1    EXEC ASMFC,MAC1='SYS1.AMODGEN',\n//          PARM.ASM='NOTERM,LIST,NODECK,OBJECT'\n//ASM.SYSLIB DD UNIT=DISK,VOL=SER=ITEL01\n//          DD UNIT=DISK,VOL=SER=ITEL02\n//ASM.SYSGO DD DSN=SYS0.LINKLIB2.OBJ(IEFACTRT),DISP=OLD\n//SYSIN     DD DSN=SYS0.LINKLIB2.SOURCE(IEFACTRT),DISP=SHR\n//*\n//STEP2    EXEC IPOSMP4,COND=(8,LT)\n//SMPPTFIN     DD  *\n++ USERMOD (VS00023) .\n++ VER (Z038) FMID(JBB1222) REQ(VS00024).\n++ MOD (IEFACTRT) DISTLIB(AOSB3) TXLIB(OBJECT) .\n//SYSIN   DD  *\n RECEIVE S(VS00023) .\n//OBJECT  DD DISP=SHR,DSN=SYS0.LINKLIB2.OBJ\n./ ADD NAME=VS00024  0101-80101-80101-1725-00022-00027-00012-$SYS13  00\n//VS00024 JOB (2000,S010),WENZEL,CLASS=Z\n/*JOBPARM Q=F,I\n//*\n//*         STEP 1 ASSEMBLE IEECVXIT\n//*         STEP 2 SMP TO RECEIVE SYSMOD NUMBER VS00024\n//*                AND TO APPLY BOTH VS00023 AND VS00024\n//*\n//STEP1    EXEC ASMFC,PARM.ASM='NOTERM,LIST,NODECK,OBJECT'\n//ASM.SYSLIB DD UNIT=DISK,VOL=SER=ITEL01\n//ASM.SYSGO DD DSN=SYS0.LINKLIB2.OBJ(IEECVXIT),DISP=OLD\n//SYSIN     DD DSN=SYS0.LINKLIB2.SOURCE(IEECVXIT),DISP=SHR\n//*\n//STEP2    EXEC IPOSMP4,COND=(8,LT)\n//SMPPTFIN     DD  *\n++ USERMOD (VS00024) .\n++ VER (Z038) FMID(EBB1102) REQ(VS00023).\n++ MOD (IEECVXIT) DISTLIB(AOSC5) TXLIB(OBJECT) .\n//SYSIN   DD  *\n RECEIVE S(VS00024) .\n APPLY   S(VS00023,VS00024) .\n LIST  CDS SYSMOD(VS00023,VS00024).\n//OBJECT  DD DISP=SHR,DSN=SYS0.LINKLIB2.OBJ\n./ ADD NAME=VS00025  0101-80102-80102-1134-00355-00359-00000-$SYS03  00\n//VS00025  JOB (2000,S010),S.CAIRES,CLASS=Z,MSGCLASS=A\n/*JOBPARM Q=F,I\n//*\n//* RECEIVE JTIP001 AS VS00025, WHICH REASSEMBLES NEARLY ALL JES2\n//* WHEN APPLIED OR ACCEPTED.\n//*\n//VS00025  EXEC IPOSMP4      DLIB=PAG002,RES=SYS101,PTS=PAG002\n//SYSIN    DD  *    ( //SMPCNTL DD DDNAME=SYSIN IN IPOSMP4 PROC )\n LIST PTS SYSMOD(VS00025) .\n REJECT S (VS00025) .\n RECEIVE  /* VS00025 (OR JTIP001) CONTAINS JES2 SOURCE CHANGES THAT\n             FORCE RE-ASSEMBLY OF NEARLY ALL OF JES2 */ .\n LIST PTS SYSMOD(VS00025) .\n APPLY  S (VS00025)         BYPASS(ID) DIS(READ) CHECK .\n ACCEPT S (VS00025) NOAPPLY BYPASS(ID) DIS(READ) CHECK .\n/*\n//*SMPPTFIN DD DSN=SYS3.JTIP.V12.SMP4(VS00025),DISP=SHR,VOL=SER=ITEL02,\n//*            UNIT=3350\n//SMPPTFIN DD *    FROM SYS3.JTIP.V12.SMP4(VS00025), COPIED 4/11/80.\n++PTF(VS00025) /* NAME CHANGED TO VS00025 FROM JTIP001 <---PDC */\n               /* VS00025 COPIED FROM SYS3.JTIP.V12.SMP4. */ .\n++VER(Z038) FMID(EJE1102)\n  PRE(#Z90235,\n  UZ24612,UZ24614,UZ24616,UZ24619,UZ24620,UZ24622,UZ24623,\n  UZ24625,UZ24627,UZ24947,\n  AZ27300,AZ37386,AZ38575,AZ40644) .\n++MACUPD($CMB) DISTLIB(HASPSRC)\n   ASSEM(HASPCOMM,HASPCON,HASPINIT,HASPMISC,HASPPRPU,HASPRDR,\n         HASPSSM,HASPXEQ,HASPNUC,HASPACCT,HASPRTAM,HASPDOC)\n   ASMLIB(HASPSRC) .\n>< CHANGE NAME=$CMB,SEQFLD=756                                77/08/15  BV000000\nCMB#MAPS EQU   CMBDOMID,4          X-MEM MSG PARMLIST POINTER   UIC 002 BV140010\n*                                  WHEN CMBFLAGC SET.           UIC 002 BV140020\n++MACUPD($COMWORK) DISTLIB(HASPSRC) .\n>< CHANGE NAME=$COMWORK,SEQFLD=747                            77/08/15  B0000000\nCOMPNTER DS    24F                 AREA FOR OPERAND POINTERS    UIC 002 B1154000\n         COPY  #VERQEL             GET QEL OWNERSHIP VERIFY AREAUIC 002 B1160650\n++MACUPD($DCT) DISTLIB(HASPSRC) .\n>< CHANGE NAME=$DCT,SEQFLD=756                                77/08/15  CD000000\n         COPY  #INTRDCT            GET X-MEM MSG AREA DEFS      UIC 002 CD269610\nRIDBUFSZ EQU   4096-256            LENGTH OF INTERNAL READER BF UIC 002 CD271000\n++MACUPD($HASPGEN) DISTLIB(HASPSRC) .\n>< CHANGE NAME=$HASPGEN,SEQFLD=756                            77/08/15  DR000000\n         COPY  UICC                UICC DEPENDENCIES            UIC 002 DR028610\n$TUBE    EQU   64*&UICC  ($SPARE1 - RTE 13) CARD READER DISPLAY UIC 002 DR272610\n$INT     EQU   $SPARE2             TS->JES CONSOLE ID (RTE 14)  UIC 002 DR274610\n++MACUPD($HCT) DISTLIB(HASPSRC) .\n>< CHANGE NAME=$HCT,SEQFLD=756                                77/08/15  DT000000\n$JCMDQUE DC    A(*-*)              ADDR OF CMBS RSVD FOR TS/JES UIC 002 DT271610\n$JCMDPCE DC    V(HASPCOMM)         TS->JES CMD PROCESSOR        UIC 002 DT446610\n$JFETPCE DC    V(HASPJFET)         SYSOUT FETCH PROCESSOR       UIC 002 DT447610\n++MACUPD($JCT) DISTLIB(HASPSRC) .\n>< CHANGE NAME=$JCT,SEQFLD=756                                77/08/15  EB000000\n         GBLB  &UICC                                            UIC 002 EB007000\n         DS    0D                  ENSURE START ON DBLWD        UIC 002 EB296610\n         COPY  #JCTUWK1            GET UICC JCT DEFINITIONS     UIC 002 EB296620\n++MACUPD($JQE) DISTLIB(HASPSRC) .\n>< CHANGE NAME=$JQE,SEQFLD=756                                77/08/15  EM000000\n         GBLB  &UICC                                            UIC 002 EM007000\n         COPY  #JQEDEFS            GET UICC JQE DEFINITIONS     UIC 002 EM062610\n$FETCH   EQU   $DUMMY              SYSOUT FETCH QUEUE           UIC 002 EM124610\n++MACUPD($MODMAP) DISTLIB(HASPSRC) .\n>< CHANGE NAME=$MODMAP,SEQFLD=756                             77/08/15  EW000000\nMAPJFET  DC    CL8'HASPJFET'       FETCH PROCESSOR              UIC 002 EW130610\nMAPJFETA DC    V(HASPJFET),A(0)                                 UIC 002 EW130620\n++MACUPD($OCR) DISTLIB(HASPSRC) .\n>< CHANGE NAME=$OCR,SEQFLD=756                                77/08/15  FF000000\nOCRLINCT DS    X                   LINECT VALUE FOR DS          UIC 002 FF057610\nOCRUFLG  DS    X                   FLAGS TO BE MERGED W/PDDB    UIC 002 FF057620\nOCRUJ    EQU   X'40'               OPTCD=J REQUEST W/SPIN       UIC 002 FF057630\nOCRUHO   EQU   X'10'               HOLD=YES @ DEST REQUEST      UIC 002 FF057640\n         DS    H                   SPARE                        UIC 002 FF057650\nOCRUNAME DS    CL8                 DATASET SEP. PAGE 'JOBNAME'  UIC 002 FF057660\n++MACUPD($PCE) DISTLIB(HASPSRC) .\n>< CHANGE NAME=$PCE,SEQFLD=756                                77/08/15  FP000000\nPCECMMSG DS    0D                  CROSS MEMORY MSG CNTL        UIC 002 FP082610\nPCECMMFL DS    X                   CONTROL FLAGS                UIC 002 FP082620\nPCECMMAD DS    AL3                 MESSAGE BUFFER POINTER       UIC 002 FP082630\nPCECMMSV DS    F                   SAVE AREA                    UIC 002 FP082640\nPCEJCMID EQU   32                  TS->JES CMD PCE ID           UIC 002 FP181610\nPCEFETID EQU   64                  FETCH JOB SYSOUT PCE ID      UIC 002 FP181620\n         SPACE 2                                                UIC 002 FP181630\n*    PCECMMFL BIT DEFINTIONS                                    UIC 002 FP181640\n*                                                               UIC 002 FP181650\n*              X'0F'               USED FOR X-MEM MSG CNTL      UIC 002 FP181660\nPCE#CMBQ EQU   X'04'               CMB CONTAINED MULT CMDS      UIC 002 FP181760\nPCE#BEND EQU   X'02'               BUFF FULL, MSG SENT          UIC 002 FP181770\nPCE#$WTO EQU   X'01'               SPECIAL $WTO PROCESSING      UIC 002 FP181780\n         SPACE 2                                                UIC 002 FP206610\n*                                                               UIC 002 FP206620\n         COPY   #CMDSECT             GET PARM LIST DSECT        UIC 002 FP206630\n++MACUPD($PDDB) DISTLIB(HASPSRC) .\n>< CHANGE NAME=$PDDB,SEQFLD=756                               77/08/15  FR000000\nPDB#LNCT DS    X                   DATASET LINECT VALUE         UIC 002 FR080610\n         DS    X                   SPARE                        UIC 002 FR080620\nPDB#NAME DS    CL8                 DATASET SEP. PAGE 'JOBNAME'  UIC 002 FR080630\nPDB#PROC DS    CL8                 PROC-STEP NAME               UIC 002 FR080640\nPDB#STEP DS    CL8                 STEP NAME                    UIC 002 FR080650\nPDB#DDN  DS    CL8                 DD NAME                      UIC 002 FR080660\n++MACUPD($RDRWORK) DISTLIB(HASPSRC) .\n>< CHANGE NAME=$RDRWORK,SEQFLD=756                            77/08/15  GT000000\nRUFLAG   DS    X                   JCT1FLG2/JQEUFLAG FIELD SAVE UIC 002 GT093610\n         DS    3X                  RESERVED                     UIC 002 GT093620\n++MACUPD($SDB) DISTLIB(HASPSRC) .\n>< CHANGE NAME=$SDB,SEQFLD=747                                77/08/15  G0000000\nSDBFLG3  DS    X                   FLAG BYTE - RESERVED         UIC 002 G5104000\nSDB#FI   EQU   X'10'               SDB FOR FETCH INPUT DS       UIC 002 G5104610\nSDB#ASA  EQU   X'40'               TO MATCH LRC1TASA, LRC1TMCH  UIC 002 G5104620\nSDB#MCH  EQU   X'20'                 SET FROM PDBRECFM...       UIC 002 G5104630\n++MACUPD($SJB) DISTLIB(HASPSRC) .\n>< CHANGE NAME=$SJB,SEQFLD=747                                77/08/15  G0000000\n         COPY  #SJBWORK            UICC WORKSPACE               UIC 002 G9238610\n++MACUPD($SSOB) DISTLIB(HASPSRC) .\n>< CHANGE NAME=$SSOB,SEQFLD=756                               77/08/15  HJ000000\n         COPY  #SSOB               GET ADDITIONAL SSOB DEFS     UIC 002 HJ009610\n++MACUPD($SVT) DISTLIB(HASPSRC) .\n>< CHANGE NAME=$SVT,SEQFLD=756                                77/08/15  HN000000\n         GBLB  &UICC               UICC CONTROL BIT             UIC 002 HN004210\n         DC    Y(($SVUNFUN-$SVNULL)/4)  NUMBER OF FUNCTIONS     UIC 002 HN032000\n$SVUJCMD DC    A(*-*)              TS -> JES COMMANDS           UIC 002 HN086620\n$SVUFOUT DC    A(*-*)              FETCH JOB SYSOUT             UIC 002 HN086630\n         DC    A(*-*)              NOT DEFINED                  UIC 002 HN086640\n         DC    A(*-*)              NOT DEFINED                  UIC 002 HN086650\n$SVUNFUN EQU   *-4                 FOR MAX FUNCTION CALC        UIC 002 HN086990\n         COPY  #SSVTVTC            SERVICE ROUTINE VECTOR TABLE UIC 002 HN114610\n$SVUCMDQ DC    A(*-*)              TS -> JES CMD-PCE CMB QUEUE  UIC 002 HN212610\n         DC    A(*-*)              RESERVED                     UIC 002 HN212620\n$SVUCMDP DC    A(*-*)              $$POST ELEMENT FOR TS CMD PCEUIC 002 HN222610\n$SVUFOUP DC    A(*-*)              $$POST ELEMENT FOR FETCH PCE UIC 002 HN224610\n$SVUFOQ  DC    D'0'                SJBS FOR FETCH SYSOUT        UIC 002 HN338610\n++MACUPD($SVTC) DISTLIB(HASPSRC) .\n>< CHANGE NAME=$SVTC,SEQFLD=756                               77/08/15  HP000000\n         DC    38AL1(0)                  22 - 59 RSVD FOR JES   UIC 002 HP047600\n         DC    AL1(($SVUJCMD-$SVNULL)/4) 60 TS -> JES CMD       UIC 002 HP047610\n         DC    AL1(($SVUFOUT-$SVNULL)/4) 61 FETCH JOB SYSOUT    UIC 002 HP047620\n         DC    AL1(0)                    62 NOT DEFINED         UIC 002 HP047630\n         DC    AL1(0)                    63 NOT DEFINED         UIC 002 HP047640\n++SRCUPD(HASPCOMM) DISTLIB(HASPSRC) .\n>< CHANGE NAME=HASPCOMM,SEQFLD=747                            77/08/15  K0000000\n         $ASCB  DOC=&DOC           ASCB DEFINITIONS             UIC 002 K0073620\n         $ASVT  DOC=&DOC           ASVT DEFINITIONS             UIC 002 K0073630\n         #OUCB LIST=&LIST          OS OUCB BLOCK                UIC 002 K0073640\n         $LRC  DOC=&DOC            LOGICAL RECORD DSECT         UIC 002 K0074110\n         GBLB  &UICC               GLOBAL UICC BIT              UIC 002 K0730100\nCOFTR    EQU   COFFLAGS+5,15         LINE COUNTS                UIC 002 K0776110\n         COPY  #COMFET             GET FETCH QUEUE CODE         UIC 002 K0787310\n         COPY  #COFJMXQ            GET ACTIVE XEQ INFO          UIC 002 K0807610\n         COPY  #COFQDPX            AWAIT XEQ Q DEPTH            UIC 002 K0827310\n         COPY  #COMJMDV            GET ACTIVE ON DEVICE DISPLAY UIC 002 K0878610\n         COPY  #COMCNTO            GET CLASS DEPTH DISPLAY      UIC 002 K0919310\nCOFJMFFX DS    0H                  FETCH Q MSG EXIT..           UIC 002 K0924110\n         LCLC  &R                                               UIC 002 K1101110\n&R       SETC  '&SYSNDX'                                        UIC 002 K1101120\n         COPY  #CO#CVQE            GET TS -> JES VERIFY CODE    UIC 002 K1119610\n         CLI   PCEID+1,PCEJCMID    TS->JES CMD PCE?             UIC 002 K1161610\n         BE    CO#JCMDA            YES, ENTER QUEUE SCANNER     UIC 002 K1161620\n         COPY  #CO#JCMD            GET TS->JES CMD CODE         UIC 002 K1187310\n         COPY  #CO#JCSS            MULTI/CMD PER CMB CODE       UIC 002 K1501510\n         NI    PCECMMFL,255-PCE#CMBQ  CLEAR REQUEUED FLAG       UIC 002 K1511210\n         COPY  #CO#PCHK            CMD PERMISSION CHECKER       UIC 002 K1625610\nCOMTBLJ  DS   0F                  INDEX FOR J                   UIC 002 K1701110\nCOMTBLK  DS   0F                  INDEX FOR K                   UIC 002 K1701310\n         $COMTAB LA,#HASPLA        SHOW ALL COMMAND             UIC 002 K1701610\nCOMTBLM  DS   0F                  INDEX FOR M                   UIC 002 K1703110\nCOMTBLQ  DS   0F                  INDEX FOR Q                   UIC 002 K1710110\n         $COMTAB Q7D,#HASPQJ1  REQUEUE A JOB BY NAME            UIC 002 K1710150\n         $COMTAB QA,#HASP$QA  REQUEUE ALL JOBS                  UIC 002 K1710160\n         $COMTAB QJ,#HASPQJ1  REQUEUE A JOB BY NUMBER           UIC 002 K1710170\nCOMTBLU  DS   0F                  INDEX FOR U                   UIC 002 K1720610\nCOMTBLW  DS   0F                  INDEX FOR W                   UIC 002 K1721110\nCOMTBLX  DS   0F                  INDEX FOR X                   UIC 002 K1721210\nCOMTBLY  DS   0F                  INDEX FOR Y                   UIC 002 K1721310\n         $COMTAB Y7D,#HASPYJ1      JOBNAME SYSOUT INFO LISTER   UIC 002 K1721350\n         $COMTAB YJ,#HASPYJ1       JOB SYSOUT INFO LISTER       UIC 002 K1721360\n         $COMTAB Y,#HASPYJ1        1ST JOB IN FETCH Q           UIC 002 K1721370\n         DC   C'J',AL3(COMTBLJ)    ENTRY FOR 'J' VERBS          UIC 002 K1729610\n         DC   C'K',AL3(COMTBLK)    ENTRY FOR 'K' VERBS          UIC 002 K1729620\n         DC   C'M',AL3(COMTBLM)    ENTRY FOR 'M' VERBS          UIC 002 K1730110\n         DC   C'Q',AL3(COMTBLQ)    ENTRY FOR 'Q' VERBS          UIC 002 K1731610\n         DC   C'U',AL3(COMTBLU)    ENTRY FOR 'U' VERBS          UIC 002 K1733110\n         DC   C'W',AL3(COMTBLW)    ENTRY FOR 'W' VERBS          UIC 002 K1733610\n         DC   C'X',AL3(COMTBLX)    ENTRY FOR 'X' VERBS          UIC 002 K1733620\n         DC   C'Y',AL3(COMTBLY)    ENTRY FOR 'Y' VERBS          UIC 002 K1733630\n         BNE   CDQUICOP            TEST UIC ADDED QUEUES        UIC 002 K1967000\n         COPY  #COMOPS             GET UIC QUEUE CODE           UIC 002 K1980610\n         CH    WF,CDQFETD          IS IT FETCH REQ              UIC 002 K1996810\n         BE    SKIP110             YES, GO SET ROUTE INFO       UIC 002 K1996820\nCDQFETEX DS    0H                  FETCH QUEUE EXIT..           UIC 002 K2114110\nCDQFETD  DC    AL2(CDQFET-CDQB),AL3(CDQTYPEF,CDQTYPEF)          UIC 002 K2190610\nCDQTYPEF DC    AL1($FETCH)                                      UIC 002 K2194210\nCDQXEQAD EQU   CDQXEQD+6-CDQS+CDQSEE LOC OF ELEMENT AFTER XEQ   UIC 002 K2200500\nCDQFETDD EQU   CDQFETD-CDQS+CDQSEE LOC OF FETCH ELM.            UIC 002 K2200510\n* ADD OTHER Q ITEMS HERE                                        UIC 002 K2200520\n         COPY  #HASP$YJ            COPY $YJ COMMAND CODE        UIC 002 K2880110\n         COPY  #HASP$LA            GET SHOW ALL CODE            UIC 002 K2880120\n         COPY  #HASP$QJ    GET QUEUE JOB COMMAND                UIC 002 K2880150\n         COPY  #HASP$QA    GET QUEUE ALL COMMAND                UIC 002 K2880160\n++SRCUPD(HASPCON) DISTLIB(HASPSRC) .\n>< CHANGE NAME=HASPCON,SEQFLD=747                             77/08/15  L0000000\n         B     WQUERET             EXIT OF NO CONSOLES   +0     UIC 002 L0456610\n         LA    R15,WSCREEN         ADDR OF ROUTE SCREEN ROUTINE UIC 002 L0956000\n         BALR  R14,R15             IND CMB TYPE CALL            UIC 002 L0956310\n         B     WQUERET             EXIT IF NO CONSOLES          UIC 002 L0956610\n         BNZ   4(,LINK)            RETURN IF COMPLETE           UIC 002 L1084000\n         BNZ   4(,LINK)            RETURN                       UIC 002 L1116000\n         BL    4(,LINK)            LEAVE AS OS 'INFO' WTO       UIC 002 L1122400\n         B     4(,LINK)            RETURN                       UIC 002 L1124000\n         COPY  #CN#$WTO            GET TS->JES CONSOLE CODE     UIC 002 L1138000\nW$INTC   DS    0H                  MCS ROUTE FOR $INT CNSLE     UIC 002 L2199700\n++SRCUPD(HASPINIT) DISTLIB(HASPSRC) .\n>< CHANGE NAME=HASPINIT,SEQFLD=747                            77/08/15  M0000000\n         DC    AL2($JCMDPCE-HCTDSECT,PCEJCMID)                  UIC 002 M2635610\n         DC    AL2((PCEWORK-PCEDSECT+COMPCEWS+7)/8*8)           UIC 002 M2635620\n         DC    AL2($JFETPCE-HCTDSECT,PCEFETID)                  UIC 002 M2635630\n         DC    AL2(PCEWORK+160-PCEDSECT)                        UIC 002 M2635635\nISVTFNUM DC    Y(($SVUNFUN-$SVNULL)/4)  NUMBER OF FUNCTIONS     UIC 002 M3881000\n         MVC   0(#DCTEND-DCTDSECT,R2),NINRDCT   BUILD BASIC DCT UIC 002 M4622500\n#DCBL    EQU   #DC#MBUF-DCTDSECT,L'#DC#MBUF     SETUP FOR MOVE  UIC 002 M4622610\n         MVC   #DCBL(256,R2),NINRDCT+#DCBL      MOVE MIDDLE     UIC 002 M4622620\n         MVC   #DCBL+256(L'#DCBL-256,R2),NINRDCT+#DCBL+256 DUL  UIC 002 M4622630\n         LA    R5,#DC#MBUF         GET X-MEM MSG BUFF ADDR      UIC 002 M4657110\n         ST    R5,#DC#PARM         INIT PARM LIST               UIC 002 M4657130\n         MVI   0(R5),X'FF'         SET BUFFER EMPTY             UIC 002 M4657140\n         LA    R5,L'#DC#MBUF-1     GET BUFFER LENGTH            UIC 002 M4657150\n         STH   R5,#DC#BEND         PLANT BUFF END DISPL         UIC 002 M4657170\n++SRCUPD(HASPMISC) DISTLIB(HASPSRC) .\n>< CHANGE NAME=HASPMISC,SEQFLD=747                            77/08/15  N0000000\nGPRNOFET DS    0H                  SKIP FETCH QUEUE CKS         UIC 002 N3208610\n         L     WD,=V($QINDEX)      ADDR OF Q INDEX TABLE        UIC 002 N3222610\n         CLM   WB,1,$FETCH(WD)     IGNORE FETCH QUEUE           UIC 002 N3222620\n         BE    GPRNOFET            SINCE ITS STATIC.            UIC 002 N3222630\n         L     R15,=V($QINDEX)     ADDR OF Q INDEX TABLE        UIC 002 N3272610\n         SR    WD,WD               ZIP FOR QUETYPES INSERT      UIC 002 N3272620\n         IC    WD,$FETCH(R15)      GET QUETYPE VALUE            UIC 002 N3272630\n         CR    WD,WB               DO NOT AGE STATIC            UIC 002 N3276010\n         BE    GPREND1             $FETCH QUEUE...              UIC 002 N3276020\n         COPY  #FETWARM            GET FETCH Q WARM START       UIC 002 N4368000\n         LA    WA,HQTHQR           PREPARE TO SCAN HQT          UIC 002 N4826000\n         B     *+8                  SKIP                        UIC 002 N4830010\nNQ420    LA    WA,HQTHQR           PREPARE                      UIC 002 N5200000\n         B     *+8                 SKIP                         UIC 002 N5216010\n         COPY  #WARMGS             FETCH WARM START MSGS        UIC 002 N6438810\n++SRCUPD(HASPPRPU) DISTLIB(HASPSRC) .\n>< CHANGE NAME=HASPPRPU,SEQFLD=747                            77/08/15  Q0000000\n         TM    JCT1FLG4,JCT14NOT   WAS HE ALREADY NOTED         UIC 002 Q0453610\n         BO    OPNOTX              YES, SKIP NOTIFY             UIC 002 Q0453620\n         OI    JCT1FLG4,JCT14NOT   SET NOTIFIED FLAG            UIC 002 Q0584610\n         ST    R0,PCECMMSV         SAVE TTR OF REG IOT          UIC 002 Q0685610\n         L     R2,PCEJQE           GET JQE ADDRESS              UIC 002 Q0727110\n         TM    QUEUFLAG(R2),QUERTE$F  ROUTED TO FETCH Q         UIC 002 Q0727120\n         BO    OPQPUT              YES, GO DO SO NOW            UIC 002 Q0727130\n         COPY  #HOPFETC            GET FETCH Q CODE             UIC 002 Q0902610\n         MVC   PCCWORK,JCTOUTNM    MOVE OUTNAME TEXT            UIC 002 Q4841610\n++SRCUPD(HASPRDR) DISTLIB(HASPSRC) .\n>< CHANGE NAME=HASPRDR,SEQFLD=747                             77/08/15  R0000000\n         $SJB  DOC=&DOC            GEN SJB DSECT                UIC 002 R0296610\n         COPY  #DCRINIT            GET X-MEM MSG AREA INIT      UIC 002 R0606610\n               ROUTE=$INT+$LOG+$UR+$TUBE,CLASS=$NORMAL,PRI=$ST  UIC 002 R1202000\n         ST    JCT,PCECMMFL        ZERO FLAG AND PARM ADDR      UIC 002 R1234610\n         DC    AL1(5),AL3(RREPCARD),CL8'REPRO'  UICC /*REPRO    UIC 002 R1336720\n         DC    AL1(3),AL3(RREPCARD),CL8'DUP'    UICC /*DUP      UIC 002 R1336730\n         DC    AL1(4),AL3(RSCNCARD),CL8'SCAN'  UICC /*SCAN      UIC 002 R1336740\n         COPY  #RDRREPC            GET UICC REPRO CARD          UIC 002 R1338720\n               ROUTE=$INT+$LOG+$UR,CLASS=$TRIVIA,PRI=$ST MSG    UIC 002 R1550000\n         XC    JCTWORK+40(10),JCTWORK+40  Q SAVE AREA           UIC 002 R1717610\n         COPY  #JBPARM             GET JOB PARM ADJUSTER        UIC 002 R1726140\n               ROUTE=$INT+$LOG+$UR+$TUBE,CLASS=$TRIVIA,PRI=$ST  UIC 002 R1748000\n         COPY  #JBTABL             GET ADDED JOBPARM ENTRIES    UIC 002 R1821610\n               ROUTE=$INT+$LOG+$UR,CLASS=$TRIVIA,PRI=$ST        UIC 002 R2066000\n*  ALSO USED FOR TIMED DELETES FROM FETCH QUEUE                 UIC 002 R2364610\n         STM   R0,R1,JCTXEQOF      SET IN CASE NEVER XEQ        UIC 002 R2364620\n         STM   R0,R1,JCTXEQON      SET SO XEQ TIME=0            UIC 002 R2364630\n         MVC   JCTOUTNM,JCTJNAME   DEFAULT OUTNAME TO JNAME     UIC 002 R2382610\n         MVC   1*PDBLENG(1*PDBLENG,R1),0(R1)                    UIC 002 R2658100\n         MVC   2*PDBLENG(1*PDBLENG,R1),0(R1)                    UIC 002 R2658110\n         MVC   3*PDBLENG(1*PDBLENG,R1),0(R1)                    UIC 002 R2658200\n         MVC   4*PDBLENG(1*PDBLENG,R1),0(R1)                    UIC 002 R2658210\n         MVC   PDB#DDN-PDBDSECT+IOTPDBOJ(8,R1),=CL8'JCL '       UIC 002 R2670610\n         MVC   PDB#DDN-PDBDSECT+IOTPDBOL(8,R1),=C'JOBLOG  '     UIC 002 R2678610\n         MVC   PDB#DDN-PDBDSECT+IOTPDBOI(8,R1),=CL8'JCL '       UIC 002 R2684610\n         MVC   PDB#DDN-PDBDSECT+IOTPDBOM(8,R1),=C'SYSMSGS '     UIC 002 R2690610\n               ROUTE=$INT+$LOG+$UR+$TUBE,CLASS=$ACTION,PRI=$ST  UIC 002 R2894000\n               ROUTE=$INT+$LOG+$UR+$TUBE,CLASS=$TRIVIA,PRI=$ST  UIC 002 R3044000\n               ROUTE=$INT+$LOG+$UR,CLASS=$TRIVIA,PRI=$ST        UIC 002 R3582000\n         MVC   JQEUFLAG,RUFLAG     SET Q-DIRECTOR INFO          UIC 002 R3869010\n*        CLC   0(7,RPI),=CL7'/*SCAN'  TEST FOR INTERNAL READER SUIC 002 R4012000\n*        BE    RINRSCAN            BRANCH IF NOT                UIC 002 R4014000\n               ROUTE=$INT+$LOG+$UR+$TUBE,CLASS=$ALWAYS,PRI=$ST  UIC 002 R4828000\n         TM    JCT1FLG3,JCT13FRP   REPRO REQUEST ?              UIC 002 R4831610\n         BZ    *+8                 NO, SKIP KILL LOGIC          UIC 002 R4831620\n         MVI   JCT1FLG3,JCT13FFL   ELSE, CLEAR REP, NOTE KILL   UIC 002 R4831630\n         MVC   JQEUFLAG,RUFLAG     SET Q-DIRECTOR INFO          UIC 002 R4842010\n         COPY  #JCTTERM            GET JCT/JQE ADJUSTER         UIC 002 R4894610\n         TM    JCT1FLG3,JCT13FRP   WAS REPRO REQUESTED?         UIC 002 R4965610\n         BZ    *+8                 NO, SKIP MSG SET             UIC 002 R4965620\n         LA    RPI,RREPDOC         ELSE, NOTE REP REQ.          UIC 002 R4965630\n         COPY  #REPTERM            GET /*DUP CODE               UIC 002 R4990000\n               ROUTE=$INT+$LOG+$UR+$MAIN,CLASS=$NORMAL,PRI=$ST  UIC 002 R5074900\n         MVC   RUFLAG,JCT1FLG2     SAVE Q-DIRECTOR INFO         UIC 002 R5091110\n         COPY  #PDBCNST       GET J/TIP PDDB CONSTANT ADDITIONS UIC 002 R5336610\n++SRCUPD(HASPSSSM) DISTLIB(HASPSRC) .\n>< CHANGE NAME=HASPSSSM,SEQFLD=747                            77/08/15  T0000000\n         DC    A(HOSJCMD)          TS TO JES COMMAND            UIC 002 T0329210\n         DC    A(HOSFETCH)         FETCH JOB SYSOUT FUNCTION    UIC 002 T0329220\n         DC    A(0)                SPARE                        UIC 002 T0329230\n         DC    A(0)                SPARE                        UIC 002 T0329240\n         COPY  #SSSMVTC            SERVICE ROUTINE VECTOR TABLE UIC 002 T0337210\n         LTORG ,                   FIX UP JES LITERALS          UIC 002 T0767610\n         COPY  #JESCMD             GET SSSM MODULE FOR TS/JES CMUIC 002 T1091310\n         COPY  #HASPFJB            COPY SSSM FETCH SUPPORT      UIC 002 T1091320\n         CLC   0(8,R1),=CL8'JOB'   REQUEST FOR INDIRECT         UIC 002 T1131910\n         BE    4(0,R14)            RETURN WITH INDIRECT         UIC 002 T1131920\n         COPY  #HASPFET            COPY END OF TASK SUPPORT     UIC 002 T2648660\n         CH    R0,=C'FI'           IS IT FETCH?                 UIC 002 T2878610\n         BE    #HALF               YES, WE HAVE A FETCH REQUEST.UIC 002 T2878620\n         ST    R13,#DCT#SJB        PLANT INTRDR USER SJB ADDR   UIC 002 T3114620\n         COPY  #HASP#FA            COPY FETCH ALLOC CHANGES     UIC 002 T3129610\n         LH    R1,OCRDEST2         GET SECOND DEST FOR TEST     UIC 002 T3355110\n         LTR   R1,R1               IS SECOND PRESENT??          UIC 002 T3355120\n         BZ    HCP477              NO, TRY FOR THE FIRST        UIC 002 T3355130\n         LH    R1,OCRDEST1         ELSE, GET FIRST --           UIC 002 T3355140\n         B     HCP479              USE POSSIBLE 'JOB' RTE       UIC 002 T3355150\nHCP477   DS    0H                  ..                           UIC 002 T3355160\nHCP479   DS    0H                  ..                           UIC 002 T3356610\n         COPY  #PDBCNST            GET JTIP CONSTANT ADDITIONS  UIC 002 T3411550\n         CH    R0,=C'FI'           IF FETCH                     UIC 002 T3441610\n         BE    #HUAF               THEN GO UNALLOCATE           UIC 002 T3441615\n         COPY  #HASP#FD            FETCH UNALLOCATION           UIC 002 T3442610\n         COPY  #DUPNAME            GET OUTPUT IDENTIFIER CODE   UIC 002 T3750010\n         B     #HO500              SUBSYSTEM DATASET FETCH      UIC 002 T3752860\n         COPY  #HASP#FO            COPY FETCH OPEN CHANGES      UIC 002 T3784560\n         COPY  #PDBFILL            GET CODE TO FILL PDDB        UIC 002 T3826110\n         DC    X'11'               PRINT AND SPACE 2            UIC 002 T4115000\n         DC    C' '                1 BLANK FOR TERMINAL PRT     UIC 002 T4115500\n         CLC   DSNDSTYP,=C'FI'     IS IT FETCH?                 UIC 002 T4190500\n         BE    16(,R14)            RETURN TO +16 IF SO          UIC 002 T4190505\n         B     20(,R14)            ELSE RETURN TO +20 (UNKNOWN) UIC 002 T4190510\n         B     #HC500              SUBSYSTEM DATASET FETCH CLOSEUIC 002 T4213250\n#HC500   DS    0H                  CLOSE FETCH DATASET          UIC 002 T4233250\n         COPY  #HASPFGT                                         UIC 002 T4658610\n         COPY  #DCBFMOV            GET X-MEM RDR MSG MOVE CODE  UIC 002 T4795060\n         TM    BFFL1,RIDEOF+RIDDEL+RIDERQ+RIDCLS FUNNY?         UIC 002 T4815297\n         BNZ   HIR015                                           UIC 002 T4815298\n         ICM   R1,15,RPLCCHAR      POINT TO CONTROL CHAR        UIC 002 T4815301\n         BZ    HIR015               SKIP IF NONE                UIC 002 T4815303\n         LA    R5,LRCSOUT-LRCDSECT(,R3) ADJ LEN FOR CONTROL CHR UIC 002 T4815305\nHIR015   DS    0H                                               UIC 002 T4815307\n         COPY  #SSMIRDR                                         UIC 002 T4821601\n         COPY  #DCBFNIT            GET X-MEM RDR MSG INIT CODE  UIC 002 T5430310\n++SRCUPD(HASPXEQ) DISTLIB(HASPSRC) .\n>< CHANGE NAME=HASPXEQ,SEQFLD=747                             77/08/15  U0000000\n         LA    WA,HQTHQR            INSERT HQR                  UIC 002 U6206000\n         LA    WA,HQTHQR             ELSE PREPARE TO            UIC 002 U9368000\n><     ENDUP\n/*\n./ ADD NAME=VS00025A 0101-80102-80102-1133-00068-00012-00000-$SYS03  00\n//VS00025A JOB (2000,S010),S.CAIRES,CLASS=Z,MSGCLASS=A,TYPRUN=HOLD\n/*JOBPARM Q=F,I\n//*\n//* APPLY OR ACCEPT JTIP001 AS VS00025, WHICH REASSEMBLES NEARLY ALL\n//* JES2 WHEN APPLIED OR ACCEPTED.\n//*\n//* NOTE - THE JTIP DOCUMENTATION FROM UNIV OF ILL SUGGESTS INSTALLING\n//* JTIP001 INTO JES2 WITH\n//*    \"ACCEPT S(VS00025) NOAPPLY BYPASS(ID)\"\n//* BUT IT IS PROBABLY BETTER TO APPLY AND THEN ACCEPT JTIP001, PUTTING\n//* THE APPLY AND THE ACCEPT JES2 ASSEMBLY LISTINGS ON TAPE FOR LATER\n//* MICRO-FICHING AT THE PDC OR PRINTING ONE OF THEM.  REASON - IF\n//* VS00025 IS ACCEPTED WITH NOAPPLY, THE SYSTEM ENTRY FOR SYSMOD\n//* (VS00025) WILL NOT BE ON THE CDS, AND YOU WILL NOT BE ABLE TO APPLY\n//* ANY LOCAL MODS TO JES2 WITH PRE(VS00025).\n//*      IF YOU DO INSTALL JTIP001/VS00025 WITH \"ACCEPT NOAPPLY\", MAKE\n//* SURE YOU LINK THE JTIP001 JES2 MODULES INTO JES2 WHEN YOU LINK\n//* HASPJFET AND VERFYQEL FROM JTIP002/VS00026 INTO JES2.\n//*\n//* THIS JOB IS SET UP TO PUT THE JES2 ASSEMBLY LISTINGS TO DISK IN\n//* $SYSUT.VS00025.ASMOUT  (ABOUT 200K LINES).\n//*\n//* USE APPLY CHECK BEFORE APPLY.  SAME FOR ACCEPT.\n//* BACKUP SYS1.CDS AND SYS1.ACDS USING JOB FDRDSFD BEFORE APPLY OR\n//* ACCEPT, AND THEN USE  DIS(WRITE) INSTEAD OF  DIS(READ), WHICH IS 20\n//* TIMES FASTER.\n//*\n//* //ASMOUT DD  IS PUT TO DISK, THEN EITHER TO MICROFICHE OR PRINTER.\n//*\n//*\n//DELETE   EXEC PGM=IEFBR14\n//ASMOUT   DD  DSN=$SYSUT.VS00025.ASMOUT,\n//             UNIT=DISK,VOL=SER=USER02,\n//             DISP=(MOD,DELETE)\n//ASMOUT2  DD  DSN=$SYSUT.VS00025.ASMOUT,\n//             UNIT=DISK,VOL=SER=USER02,\n//             DISP=(MOD,UNCATLG)\n//*\n//ALLOC    EXEC PGM=IEFBR14\n//ASMOUT   DD  DSN=$SYSUT.VS00025.ASMOUT,\n//             DCB=(LRECL=121,RECFM=FBA,BLKSIZE=6050),  121 X 50\n//*        150 LL/TRK * 1333 TRKS = 200,000 LL; 1333 TRKS = 45 CYLS\n//             SPACE=(CYL,(45,15),RLSE),  150LL/TRK*1333 TRKS = 45 CYLS\n//             UNIT=DISK,VOL=SER=USER02,\n//             DISP=(,CATLG,DELETE)\n//*\n//VS00025  EXEC IPOSMP4      DLIB=PAG002,RES=SYS101,PTS=PAG002\n//ASMOUT   DD  DSN=$SYSUT.VS00025.ASMOUT,DISP=MOD\n//SYSIN    DD  *     (//SMPCNTL DD DDNAME=SYSIN IN IPOSMP4)\n LIST PTS  SYSMOD(VS00025) .\n          /* VS00025 (OR JTIP001) CONTAINS JES2 SOURCE CHANGES THAT\n             FORCE RE-ASSEMBLY OF NEARLY ALL OF JES2 */ .\n LIST CDS SYSMOD(VS00025) .\n APPLY   S(VS00025) DIS(WRITE) /* BACKUP CDS AND ACDS FIRST */ .\n LIST CDS SYSMOD(VS00025) .\n/*\n//*\n//*\n//*\n//DUMMYJCL DD  *     (UNUSED CARDS)\n APPLY   S(VS00025) DIS(READ ) CHECK .\n ACCEPT  S(VS00025) DIS(READ ) CHECK .\n LIST ACDS SYSMOD(VS00025) .\n ACCEPT  S(VS00025) DIS(WRITE) /* BACKUP CDS AND ACDS FIRST */ .\n LIST ACDS SYSMOD(VS00025) .\n\n ACCEPT S(VS00025) NOAPPLY BYPASS(ID) DIS(WRITE) /* BACKUP ACDS IST */ .\n/*\n./ ADD NAME=VS00026A 0125-79358-80108-1114-00062-00013-00059-$SYS03  00\n//VS00026A JOB (2000,S010),S.CAIRES,CLASS=Z,MSGCLASS=A\n/*JOBPARM Q=F,I\n//*JOBCAT   DD  DSN=CATALOG.VSYS101,DISP=SHR\n//*\n//* JTIP002 WAS RENAMED TO VS00026 PER ITEL/PDC CONVENTION.\n//* SEE JOB VS00026C.\n//*\n//* RE-APPLY VS00026 (JTIP SVC, MACROS AND HASPJFET AND VERFYQEL) AFTER\n//* PUT TAPES 7909, 7910 AND 7911 WERE APPLIED ON 7 MAR 80.  MUST\n//* RE-ASSEMBLE HASPJFET, AND PROBABLY VERFYQEL, DUE TO CHANGED JES2\n//* CONTROL BLOCKS, DUE TO LEVEL SET PTF UZ26743 IN PUT 7909.\n//*\n//* OC4 IN HASPJFET WHEN BRINGING UP JES2 COLD.  RE-ASSEMBLED A TEST\n//* VERSION OF HASPJFET (SEE MEMBER ASMTEST), USING THE SYSLIBS FROM\n//* IPOSMP4 PROC; COMPARED BEFORE AND AFTER HASPJFET'S USING TSO TEST\n//* COMMAND AND WYLBUR COMPARE -- NOT THE SAME.  CAIRES 3/12/80.\n//*\n//* //ASMOUT DD  IS PUT TO DISK, THEN EITHER TO MICROFICHE OR PRINTER.\n//*\n//*\n//* USE APPLY CHECK BEFORE APPLY.  SAME FOR ACCEPT.  BACKUP SYS1.CDS AND\n//* SYS1.ACDS USING JOB FDRDSFD BEFORE APPLY OR RESTORE OR ACCEPT, AND\n//* THEN USE  DIS(WRITE) INSTEAD OF  DIS(READ), WHICH IS 20 TIMES\n//* FASTER.\n//*\n//*\n//*\n//DELETE   EXEC PGM=IEFBR14\n//ASMOUT   DD  DSN=$SYSUT.VS00026.ASMOUT,\n//             UNIT=DISK,VOL=SER=USER02,\n//             DISP=(MOD,DELETE)\n//ASMOUT2  DD  DSN=$SYSUT.VS00026.ASMOUT,\n//             UNIT=DISK,VOL=SER=USER02,\n//             DISP=(MOD,UNCATLG)\n//*\n//ALLOC    EXEC PGM=IEFBR14\n//ASMOUT   DD  DSN=$SYSUT.VS00026.ASMOUT,\n//             DCB=(LRECL=121,RECFM=FBA,BLKSIZE=6050),  121 X 50\n//*        150 LL/TRK * 100 TRKS = 15,000 LL; 100 TRKS = 3.3 CYLS\n//             SPACE=(CYL,(5,5),RLSE),  150LL/TRK*1000 TRKS = 33 CYLS\n//             UNIT=DISK,VOL=SER=USER02,\n//             DISP=(,CATLG,DELETE)\n//*\n//*\n//*\n//VS00026  EXEC IPOSMP4,DLIB=PAG002,RES=SYS101,PTS=PAG002\n//ASMOUT   DD  DSN=$SYSUT.VS00026.ASMOUT,DISP=MOD\n//SYSIN    DD  *    ( //SMPCNTL DD DDNAME=SYSIN IN IPOSMP4 PROC )\n LIST PTS SYSMOD(VS00026) .\n LIST CDS SYSMOD(VS00026) .\n APPLY   S(VS00026) DIS(WRITE) /* BACKUP CDS AND ACDS FIRST */ .\n LIST CDS SYSMOD(VS00026) .\n/*\n//*\n//*\n//*\n//DUMMYJCL DD  *     UNUSED CARDS\n APPLY   S(VS00026) DIS(READ) CHECK .\n ACCEPT  S(VS00026) DIS(READ) CHECK .\n ACCEPT  S(VS00026) DIS(WRITE) .\n LIST ACDS SYSMOD(VS00026) .\n/*\n./ ADD NAME=VS00026C 0110-80107-80108-1152-00076-00040-00000-$SYS13  00\n//VS00025C JOB (2000,S010),S.CAIRES,CLASS=Z,MSGCLASS=A\n/*JOBPARM Q=F,I\n//*\n//* COPY PTF JTP002 AND RELFILE(S) FROM SMP4 FORMAT TAPE TO A NEW TAPE\n//* TO CHANGE NAMES FROM JTIP002 TO VS00026 -- ITEL/PDC CONVENTION.\n//*\n//*\n//* COPY JTIP TAPE FILE 17, JTIP002, TO DISK AS MEMBER VS00026.\n//*\n//IEBGEN   EXEC PGM=IEBGENER\n//SYSPRINT DD  SYSOUT=*\n//SYSUT1   DD  DSN=JTIP002,\n//             LABEL=(17,SL,EXPDT=98000),\n//             UNIT=TAPE,VOL=(,RETAIN,SER=JTIP),DISP=OLD\n//*SYSUT2   DD  DSN=SYS0.SMP.SE.CNTL(VS00026),\n//SYSUT2   DD  DSN=$SYSUT.JTIP.V12.CNTL(VS00026),\n//             DISP=SHR\n//SYSIN    DD  DUMMY\n//*\n//* USE TP MONITOR IN BATCH TO CHANGE ALL REFERENCES (PROBABLY JUST 1)\n//* IN MEMBER JTIP002/VS00026 FROM JTIP002 TO VS00026.\n//*\n//STEP1    EXEC PGM=IKJEFT01,COND=(4,LT)\n//SYSTSPRT DD SYSOUT=*\n//SYSTSIN  DD *\nFREE DA('$SYSUT.JTIP.V12.CNTL(VS00026)')\nEDIT '$SYSUT.JTIP.V12.CNTL(VS00026)' CNTL\nVERIFY\nCHANGE *,1000 /JTIP002/VS00026/ALL\nEND SAVE\nFREE ALL\n/*\n//*\n//* COPY MEMBER VS00026 (WITH ALL REFERENCES CHANGED FROM JTIP002\n//* TO VS00026) TO A NEW TAPE AS FILE 1.\n//*\n//IEBGENER  EXEC PGM=IEBGENER,COND=(4,LT)\n//SYSPRINT DD  SYSOUT=*\n//*SYSUT1   DD  DSN=$SYSUT.SMP.SE.CNTL(VS00026),DISP=SHR\n//SYSUT1   DD  DSN=$SYSUT.JTIP.V12.CNTL(VS00026),DISP=SHR\n//SYSUT2   DD  DSN=$SYSUT.JTIP.VS00026,\n//             DCB=(LRECL=80,RECFM=FB,BLKSIZE=3120),\n//             LABEL=(1,SL,EXPDT=99000),\n//             UNIT=TAPE,VOL=(,RETAIN),\n//             DISP=(,CATLG,DELETE)\n//SYSIN    DD  DUMMY\n//*\n//* COPY ORIGINAL JTIP TAPE FILES 18 AND 19, JTIP002.F1 AND\n//* JTIP002.F2 (SMP4 RELFILES) TO THE NEW TAPE AS FILES 2 AND 3,\n//* VS00026.F1 AND VS00026.F2.\n//*\n//COPY2    EXEC PGM=IEBCOPY,COND=(4,LT)\n//SYSPRINT DD  SYSOUT=*\n//SYSUT1   DD  DSN=JTIP002.F1,\n//             LABEL=(18,SL,EXPDT=98000),\n//             UNIT=TAPE,VOL=(,RETAIN,SER=JTIP),DISP=OLD\n//SYSUT2   DD  DSN=VS00026.F1,\n//             LABEL=(2,SL),\n//             UNIT=TAPE,VOL=(,RETAIN,REF=*.IEBGENER.SYSUT2),\n//             DISP=(,KEEP,DELETE)\n//SYSIN    DD  *\n COPY OUTDD=SYSUT2,INDD=SYSUT1\n/*\n//*\n//COPY3    EXEC PGM=IEBCOPY,COND=(4,LT)\n//SYSPRINT DD  SYSOUT=*\n//SYSUT1   DD  DSN=JTIP002.F2,\n//             LABEL=(19,SL,EXPDT=98000),\n//             UNIT=TAPE,VOL=(,RETAIN,SER=JTIP),DISP=OLD\n//SYSUT2   DD  DSN=VS00026.F2,\n//             LABEL=(3,SL),\n//             UNIT=TAPE,VOL=(,RETAIN,REF=*.IEBGENER.SYSUT2),\n//             DISP=(,KEEP,DELETE)\n//SYSIN    DD  *\n COPY OUTDD=SYSUT2,INDD=SYSUT1\n/*\n./ ADD NAME=VS00026R 0102-80102-80108-1115-00024-00024-00005-$SYS03  00\n//VS00026R JOB (2000,S010),S.CAIRES,CLASS=Z,MSGCLASS=A\n/*JOBPARM Q=F,I\n//*\n//* NOTE -- USE TAPE FOR SMPPTFIN, BECAUSE RELFILE SPECIFIES TAPE\n//*         FILES.\n//* USE APPLY CHECK BEFORE APPLY.  SAME FOR ACCEPT.\n//* BACKUP SYS1.CDS AND SYS1.ACDS USING JOB FDRDSFD BEFORE APPLY\n//* OR ACCEPT, AND THEN USE  DIS(WRITE) INSTEAD OF  DIS(READ),\n//* WHICH IS 20 TIMES FASTER.\n//*\n//* JTIP002 WAS RENAMED TO VS00026, PER ITEL AND PDC CONVENTION.\n//* SEE JOB VS00026C, WHICH COPIED JTIP002, JTIP002.F1 AND\n//* JTIP002.F2 FROM JTIP TAPE TO NEW TAPE, RENAMING TO VS00026.\n//*\n//VS00026  EXEC IPOSMP4          DLIB=PAG002,RES=SYS101,PTS=PAG002\n//*SMPPTFIN DD  DSN=JTIP002,VOL=SER=JTIP,LABEL=(17,SL,EXPDT=98000),\n//*             UNIT=TAPE,DISP=OLD\n//SMPPTFIN DD  DSN=$SYSUT.JTIP.VS00026,   CREATED BY JOB VS00026C\n//             UNIT=TAPE,DISP=OLD\n//SYSIN    DD  *\n REJECT S(VS00026).\n RECEIVE .\n APPLY   S(VS00026) DIS(READ)  CHECK.\n/*\n./ ADD NAME=VS00028  0104-80069-80119-1136-00029-00024-00001-$SYS13  00\n//VS00028 JOB (2000,S010),WENZEL,CLASS=Z\n/*JOBPARM Q=F,I\n//*\n//OZLINK EXEC PGM=IEBCOPY\n//SYSPRINT   DD SYSOUT=*\n//SYSUT3 DD UNIT=SYSDA,SPACE=(CYL,(10,10))\n//SYSUT4 DD UNIT=SYSDA,SPACE=(CYL,(10,10))\n//LINKLIB    DD DSN=SYS1.LINKLIB,DISP=SHR,UNIT=DISK,VOL=SER=SYS100\n//OZLIB      DD DSN=SYS1.OZLIB,DISP=SHR,UNIT=DISK,VOL=SER=SYS100\n//SYSIN      DD *\n COPY I=((OZLIB,R)),O=LINKLIB\n S M=OZB\n S M=OZC\n S M=OZD\n S M=OZJ\n S M=OZM\n S M=OZSGENER\n/*\n//OZUCL  EXEC IPOSMP4         UCLIN:  CMDLIB ---> LPALIB\n//SYSIN  DD  *\n  UCLIN CDS.\n  ADD LMOD(OZB)        SYSLIB(LINKLIB).\n  ADD LMOD(OZC)        SYSLIB(LINKLIB).\n  ADD LMOD(OZD)        SYSLIB(LINKLIB).\n  ADD LMOD(OZJ)        SYSLIB(LINKLIB).\n  ADD LMOD(OZM)        SYSLIB(LINKLIB).\n  ADD LMOD(OZSGENER)   SYSLIB(LINKLIB).\n  ENDUCL.\n/*\n./ ADD NAME=VS00029  0103-80093-80141-1649-00022-00019-00022-$SYS13  00\n//VS00029 JOB (2000,S010),WENZEL,CLASS=Z\n/*JOBPARM Q=F,I\n//STEP1  EXEC IPOSMP4\n//SYSIN DD *\n RESTORE S(VS00029) .\n REJECT  S(VS00029) .\n RECEIVE S(VS00029) .\n APPLY S(VS00029) .\n LIST CDS SYSMOD(VS00029) .\n LIST CDS MOD(IECVHIDT) .\n//SMPPTFIN DD *\n++ USERMOD (VS00029)          /*\n        MVS SYSTEM IPO ZAP TO CHANGE I/O THRESHOLD VALUES.\n        THIS VERSION IS APPLICABLE TO SU64 AND THE VALUES ARE\n        FROM THE IPO8 DOCUMENTATION.     */  .\n++ VER (Z038) FMID(FBB1221) PRE(UZ25990)     .\n++ ZAP (IECVHIDT) .\n NAME IECVHIDT\n VER 0000 00640064,000C0004\n REP 0000 02000200,001800F0\n IDRDATA VS000029\n/*\n./ ADD NAME=VS00030  0104-80102-80102-2032-00029-00020-00015-$SYS13  00\n//VS00030 JOB (2000,S010),WENZEL,CLASS=Z\n/*JOBPARM Q=F,I\n//*\n//*   INSTALL THE CICS SVC'S 214 AND 215\n//*\n//VS00030  EXEC IPOSMP4\n//SYSIN DD *\n UCLIN CDS .\n REP MOD(DFHHPSVC) LMOD(IEANUC01) DISTLIB(CICS) FMID(EBB1102) .\n ENDUCL .\n RECEIVE S(VS00030) .\n APPLY   S(VS00030) .\n LOG (ADD SVC'S 214 AND 215 FOR CICS) .\n LIST CDS SYSMOD(VS00030) .\n//CICS   DD DISP=SHR,DSN=CICS.LOADLIB\n//SMPPTFIN DD DATA\n++ USERMOD (VS00030) .\n++ VER (Z038) FMID(EBB1102) .\n++ MOD (DFHHPSVC)   DISTLIB(CICS) LKLIB(CICS) .\n++ MOD (DFHCSVC) DISTLIB(CICS) LKLIB(CICS) .\n++ JCLIN .\n//VS00030 EXEC PGM=IEBCOPY\n//SYSPRINT DD SYSOUT=*\n//CICS   DD DSN=CICS.LOADLIB,DISP=SHR\n//LPALIB DD DSN=SYS1.LPALIB,DISP=SHR,UNIT=DISK,VOL=SER=ITEL01\n//SYSIN  DD *\n C I=((CICS,R),O=LPALIB\n S M=((DFHCSVC,IGC0021D))\n/*\n./ ADD NAME=VS00031  3805-80010-80101-1754-00036-00019-00026-$SYS13  00\n//VS00031  JOB (2000,S010),WENZEL,CLASS=Z\n/*JOBPARM Q=F,I\n//*\n//*   THIS JOB IS APPLIED TO CIRCUMVENT 106-C'S BY COPYING\n//*   SOME SU33 MODULES FROM LINKLIB TO LPALIB.\n//*   REF : AZ25758\n//*\n//LPALINK EXEC IEBCOPY\n//LPALIB   DD DSN=SYS1.LPALIB,DISP=SHR,VOL=SER=ITEL01,UNIT=DISK\n//SLINKDD  DD DSN=SYS1.LINKLIB,DISP=SHR,VOL=SER=ITEL01,UNIT=DISK\n//SYSUT3 DD UNIT=SYSDA,SPACE=(CYL,(10,10))\n//SYSUT4 DD UNIT=SYSDA,SPACE=(CYL,(10,10))\n//SYSIN DD *\n COPY O=LPALIB,I=((SLINKDD,R))\n S M=(IEAVTFMT,IEAFTEED,IEAFTESA,IEAFTIHS,IEAFTFRR)\n S M=(IEAFTRTC,IEAFTRT2,IEAFTSCB,IEAFTSDW)\n S M=IECDAFMT\n S M=IECIOFMT\n/*\n//*\n//LINKUCL EXEC IPOSMP4        UCLIN: LINKLIB ---> LPALIB\n//SMPCNTL DD  *\n  UCLIN CDS DIS(WRITE).\n  ADD LMOD(IEAVTFMT)  SYSLIB(LPALIB).\n  ADD LMOD(IECDAFMT)  SYSLIB(LPALIB).\n  ADD LMOD(IECIOFMT)  SYSLIB(LPALIB).\n  ADD LMOD(IEAFTEED)  SYSLIB(LPALIB).\n  ADD LMOD(IEAFTESA)  SYSLIB(LPALIB).\n  ADD LMOD(IEAFTIHS)  SYSLIB(LPALIB).\n  ADD LMOD(IEAFTFRR)  SYSLIB(LPALIB).\n  ADD LMOD(IEAFTRTC)  SYSLIB(LPALIB).\n  ADD LMOD(IEAFTRT2)  SYSLIB(LPALIB).\n  ADD LMOD(IEAFTSCB)  SYSLIB(LPALIB).\n  ADD LMOD(IEAFTSDW)  SYSLIB(LPALIB).\n  ENDUCL.\n/*\n./ ADD NAME=VS00032  0102-80089-80101-1641-00048-00048-00006-$SYS13  00\n//VS00032  JOB  (2000,S010),WENZEL,CLASS=Z\n/*JOBPARM  Q=F,I\n//SMP EXEC IPOSMP4\n//* THIS MOD SHOULD BE ACCEPTED AFTER IT IS PROVEN TO WORK.\n//* ANY  I/O GENS WILL REMOVE THE MOD IF NOT.\n//SYSIN   DD *\n RECEIVE S (VS00032).\n APPLY S (VS00032).\n LIST CDS MOD(IEECVETC).\n LIST CDS SYSMOD(VS00032).\n//SMPPTFIN DD *\n++ USERMOD (VS00032)\n /*  PROBLEM :  UNATTENDED CONSOLES WILL QUEUE UP MESSAGES AND\n                EVENTUALLY CRASH SYSTEM DUE TO BUFFER SHORTAGE\n     SOLUTION:  INVOKE DIDOCS TO SETUP SCREENS IN DELETABLE MODE\n                AFTER INITIALIZATION\n     WARNING :  BE SURE TO ASSIGN ALL ALIAS NAMES AND ENTRY\n                POINT ON EXPAND OPERATION OF LINKAGE EDITOR\n                OR USE SMP\n                MODIFICATION WILL AUTOMATICALLY SET FOLLOWING\n                MODE ON ALL GRAPHICS CONSOLES:\n                    K  S,DEL=RD,RTME=1,CON=N,SEG=19\n     SOURCE  :  SSD #277 SHARE INC., JULY 15,1977\n     NOTES   :  R9 -- DCM TRANSIENT BASE REGISTER\n                R9 + X'40' -- POINTER TO ENTRY AREA\n                R9 + X'54' -- ADDRESS OF COMMAND OPERAND\n                R9 + X'50' -- CXSA SAVE AREA\n                R9 + X'160' - OPTIONS ROUTINE #1\n */  .\n++ VER (Z038) PRE(UZ23847) FMID(EBB1102) .\n++ ZAP (IEECVETC) .\n EXPAND IEECVETC(72)\n  NAME IEECVETC\n  VER 01AC 96E09122\n  VER 03B0 00000000,00000000,00000000,00000000\n  VER 03C0 00000000,00000000,00000000,00000000\n  VER 03D0 00000000,00000000,00000000,00000000\n  VER 03E0 00000000,00000000,00000000,00000000\n  REP 01AC 47F0C3AE\n  REP 03B0 96309122,58F09040\n  REP 03B8 D21DF000C3CE,41F0F002\n  REP 03C2 50F09054,58F09160\n  REP 03CA 58109050,07FF\n  REP 03D0 D240E26B,C4C5D37E             K S,DEL=\n  REP 03D8 D9C46BD9,E3D4C57E             RD,RTME=\n  REP 03E0 F16BC3D6,D57ED56B             1,CON=N,\n  REP 03E8 E2C5C77E,F1F9                 SEG=19\n  IDRDATA VS00032\n./ ADD NAME=VS00033  0107-80078-80101-1728-00201-00214-00000-$SYS03  00\n//VS00033   JOB (2000,S010),S.CAIRES,CLASS=Z,MSGCLASS=A\n/*JOBPARM Q=F,I\n//*\n//* RE-ACCEPT VS00033 (INTEGRATED WITH FOWLER'S VS00014)\n//* AFTER:\n//* (1) ACCEPT OF PUT TAPES 7909, 7910 AND 7911;\n//* (2) ACCEPT OF AMDAHL'S 6.1 UPGRADE AND CONFLICT TAPES FOR\n//*     7909, 7910 AND 7911;\n//* (3) ACCEPT OF SAME PTFS FROM CUSTOMIZED PUT TAPES 7910 AND 7911;\n//* (4) ACCEPT OF JTIP PTF JTIP002/VS00026;\n//*\n//* ON NEW MVS 3.8 SYSTEM FROM DLIB 7908 AT ITEL.\n//*\n//*\n//* VS00033 FROM FOWLER MEMOREX - MULTICOPY PAGE SEPARATOR.\n//*\n//* FOWLER'S VS00014 IS AN UPDATE TO VS00033 CHANGES TO HASPPRPU.\n//* (NOTE - VS00014 CHANGES INTERLEAVE LINES OF ORIGINAL VS00033.)  MOD\n//* VS00014 IS TO CORRECT A CONFLICT BETWEEN VS00033 AND IBM APAR\n//* OZ19494.  (THIS FIX WAS INTEGRATED INTO VS00033 BY CAIRES ON\n//* 3/18/80.)\n//*\n//* //ASMOUT DD  IS PUT TO DISK, THEN EITHER TO MICROFICHE OR PRINTER.\n//*\n//*\n//* USE ACCEPT CHECK BEFORE ACCEPT. SAME FOR ACCEPT. BACKUP SYS1.CDS AND\n//* SYS1.ACDS USING JOB FDRDSFD BEFORE ACCEPT OR RESTORE OR ACCEPT, AND\n//* THEN USE  DIS(WRITE) INSTEAD OF  DIS(READ), WHICH IS 20 TIMES\n//* FASTER.\n//*\n//*\n//DELETE   EXEC PGM=IEFBR14\n//ASMOUT   DD  DSN=$SYSUT.VS00033.ASMOUT,\n//             UNIT=DISK,VOL=SER=USER02,\n//             DISP=(MOD,DELETE)\n//ASMOUT2  DD  DSN=$SYSUT.VS00033.ASMOUT,\n//             UNIT=DISK,VOL=SER=USER02,\n//             DISP=(MOD,UNCATLG)\n//*\n//ALLOC    EXEC PGM=IEFBR14\n//ASMOUT   DD  DSN=$SYSUT.VS00033.ASMOUT,\n//             DCB=(LRECL=121,RECFM=FBA,BLKSIZE=6050),  121 X 50\n//*        150 LL/TRK * 100 TRKS = 15,000 LL; 100 TRKS = 3.3 CYLS\n//             SPACE=(CYL,(5,5),RLSE),  150LL/TRK*1000 TRKS = 33 CYLS\n//             UNIT=DISK,VOL=SER=USER02,\n//             DISP=(,CATLG,DELETE)\n//*\n//*\n//*\n//VS00033   EXEC IPOSMP4         DLIB=PAG002,RES=SYS101,PTS=PAG002\n//ASMOUT   DD  DSN=$SYSUT.VS00033.ASMOUT,DISP=MOD\n//SYSIN    DD  *    ( //SMPCNTL DD DDNAME=SYSIN IN IPOSMP4 PROC )\n LIST CDS SYSMOD(VS00033) .\n ACCEPT  S(VS00033) USERMODS\n                    DIS(WRITE) /* BACKUP CDS AND ACDS FIRST */ .\n LIST ACDS SYSMOD(VS00033) .\n/*\n//*\n//*\n//*\n//DUMMYJC1  DD *    UNUSED CARDS\n LIST PTS SYSMOD(VS00033) .\n LIST CDS SYSMOD(VS00033) .\n LIST ACDS SYSMOD(VS00033) .\n REJECT  S (VS00033) .\n RECEIVE S (VS00033) .\n LIST PTS SYSMOD(VS00033) .\n APPLY   S(VS00033) DIS(WRITE) /* BACKUP CDS AND ACDS FIRST */ .\n APPLY   S (VS00033) CHECK  /* DIS(READ) */ .\n\n ACCEPT  S (VS00033) USERMODS CHECK  /* DIS(READ) */ .\n/*\n//*\n//*\n//*\n//SMPPTFIN  DD *\n++ USERMOD (VS00033) /* JES2 MULTICOPY PAGE SEPARATOR MOD */\n                     /* WITH CORRECTIONS DUE TO OZ19494   */ .\n++VER (Z038) FMID(EJE1102)\n       PRE (UZ26743, UZ90070,           /* FOR HASPPRPU AND $PPPWORK */\n            VS00017, VS00025,           /* FOR HASPPRPU */\n            VS00018,                    /* FOR HASPRDR  */\n            AZ40644, UZ27051, UZ27259   /* FOR HASPPRPU */ ) .\n++MACUPD ($PPPWORK) DISTLIB(HASPSRC) .\n><  CHANGE  NAME=$PPPWORK\nPDCT     EQU   PCEDCT,4                    ADDRESS OF DCT       VS00033 FZ042010\n++SRCUPD (HASPPRPU) DISTLIB(HASPSRC) .\n><  CHANGE  NAME=HASPPRPU\n         MVC   BUFSTART+39(20),JCTPNAME    MOVE PGMR NAME       VS00033 Q1687020\n         MVC   BUFSTART+8(8),JCTJOBID      MOVE HASP JOBID      VS00033 Q1687030\n*        BH    PNXTCPY   DELETED FOR VS00033     DUE TO OZ19494 VS00033 Q3135000\n         BNH   PRCPYEND                          DUE TO OZ19494 VS00033 Q3135050\n         LA    R1,=CL5' END'      GENER END PAGE                VS00033 Q3135100\n         L     R15,=A(PRINTID) GO PRINT IT       DUE TO OZ19494 VS00033 Q3135150\n         BALR  R14,R15                           DUE TO OZ19494 VS00033 Q3135200\n         LA    R1,=CL5'COPY '                                   VS00033 Q3135300\n         L     R15,=A(PRINTID)                   DUE TO OZ19494 VS00033 Q3135350\n         BALR  R14,R15                           DUE TO OZ19494 VS00033 Q3135400\n         B     PNXTCPY                                          VS00033 Q3136300\n         CLC   PCEFORM(5),=CL5' END'  DONT PRINT *              VS00033 Q4840100\n         BE    PNXASTER                 ON ' END ' PAGE         VS00033 Q4840200\n         L     PL,PDCT                LOAD A(DCT)               VS00033 Q4840300\n         USING DCTDSECT,PL            DCT ADDRESSABILITY        VS00033 Q4840400\n         CLC   DCTUCS(4),=CL4'T11'    IS IT A XEROX? (UCS=T11)  VS00033 Q4840500\n         DROP  PL                     DROP DCT ADDRESSABILITY   VS00033 Q4840510\n         B     PNXASTER    WAS BNE    IF NOT XEROX, NO PRINTFJP/25MAY79 Q4840600\n         L     R1,PLNDISPL            GET NEW LINE DISPLACEMENT VS00033 Q4840700\n         LA    PC1,0(R1,PBUF)             BUFFER ADDRESS        VS00033 Q4840710\n         MVI   0(PC1),C'*'            GENERATE LINE OF *        VS00033 Q4840800\n         MVC   1(131,PC1),0(PC1)        FULL LINE               VS00033 Q4840900\n         LM    PC1,PC2,PRCCWID                                  VS00033 Q4840910\n         ICM   PC1,8,=X'13'        SET CCW TO DOUBLE-SPACE      VS00033 Q4840920\n         BAL   PL,PPPUT               ADD TO CHAIN              VS00033 Q4840930\nPNXASTER EQU   *                                                VS00033 Q4840940\n         CLC   7(5,PC1),=C'COPY '                               VS00033 Q4889100\n         BNE   CPYSKIP                                          VS00033 Q4889200\n         MVC   14(8,PC1),=C' '                                  VS00033 Q4889300\n         SR    PW,PW                                            VS00033 Q4889400\n         IC    PW,PPRCPYCT                                      VS00033 Q4889500\n         LA    PW,1(,PW)          MUST INCR COUNT AT THIS POINT VS00033 Q4889510\n         CVD   PW,PCCWORK                                       VS00033 Q4889600\n         UNPK  13(3,PC1),PCCWORK+6(2)                           VS00033 Q4889700\n         OI    15(PC1),X'F0'                                    VS00033 Q4889800\n         MVI   13(PC1),C' '                                     VS00033 Q4889810\n         MVI   16(PC1),C' '                                     VS00033 Q4889900\n         MVC   17(2,PC1),=C'OF'                                 VS00033 Q4889910\n         SR    PW,PW                                            VS00033 Q4889930\n         IC    PW,PPDSCPY                                       VS00033 Q4889940\n         CVD   PW,PCCWORK                                       VS00033 Q4889950\n         UNPK  19(3,PC1),PCCWORK+6(2)                           VS00033 Q4889960\n         MVI   19(PC1),C' '                                     VS00033 Q4889961\n         OI    21(PC1),X'F0'                                    VS00033 Q4889970\nCPYSKIP  DS    0H                                               VS00033 Q4889980\n         L     PL,PDCT               LOAD A(DCT)                VS00033 Q4950010\n         USING DCTDSECT,PL           DCT ADDRESSABILITY         VS00033 Q4950020\n         CLC   DCTUCS(4),=CL4'PN'    LOCAL 1403? (UCS=PN, PRT4) VS00033 Q4950030\n         BE    PPASTER               YES,PRINT *                VS00033 Q4950040\n         CLC   DCTUCS(4),=CL4'P11'   LOCAL 3211? (UCS=P11,PRT3) VS00033 Q4950050\n         BE    PPASTER               YES, PRINT *               VS00033 Q4950070\n         B     PNOASTER                IF NOT 3211, DONT PRINT  VS00033 Q4950080\nPPASTER  ICM   PC1,8,=X'19'          SET TRIPLE SPACE FOR       VS00033 Q4950100\n         BAL   PL,PPPUT               LINE OF *                 VS00033 Q4950200\n         LA    PC1,132(PC1)          GET NEW LINE BUFFER ADDR   VS00033 Q4950300\n         MVI   0(PC1),C'*'           GENERATE LINE OF *         VS00033 Q4950400\n         MVC   1(131,PC1),0(PC1)       FULL LINE                VS00033 Q4950500\n         AL    PC1,PRCCWID           SINGLE SPACE AFTER..       VS00033 Q4950600\n         BAL   PL,PPPUT              GO PRINT IT.               VS00033 Q4950700\nPNOASTER EQU   *                                                VS00033 Q4950800\n         DROP  PL                    DROP DCT ADDRESSABILITY    VS00033 Q4950900\n>< ENDUP\n/*\n//*\n//*\n//*\n//DUMMYJCL  DD *          UNUSED CARDS\n++ USERMOD (VS00014) .\n++ VER (Z038) FMID(EJE1102) PRE(UZ26743,UZ26744,UZ27051,UZ27259,\n              UZ90070,#Z90235,#Z90276,AZ40644,VS00017,VS00018,\n              VS00025,VS00033,#Z90297,VS00039) .\n++ SRCUPD(HASPPRPU) DISTLIB(HASPSRC) .\n\n* ORIGINAL VS00014 FROM FOWLER/MEMOREX.\n>< CHANGE NAME=HASPPRPU,SEQFLD=747\n*        BH    PNXTCPY DELETED FOR VS00033                $SYS3 VS00014 Q3135000\n         BNH   PRCPYEND                                   $SYS3 VS00014 Q3135050\n         L     R15,=A(PRINTID) GO PRINT IT       OZ19494  $SYS3 VS00014 Q3135150\n         BALR  R14,R15                 CODE FROM OZ19494  $SYS3 VS00014 Q3135200\n         L     R15,=A(PRINTID)         CODE FROM OZ19494  $SYS3 VS00014 Q3135350\n         BALR  R14,R15                 CODE FROM OZ19494  $SYS3 VS00014 Q3135400\n>< ENDUP\n\n* ORIGINAL VS00014 CHANGED TO VS00033 ID (AND OZ19494).\n>< CHANGE NAME=HASPPRPU\n*        BH    PNXTCPY   DELETED FOR VS00033     DUE TO OZ19494 VS00033 Q3135000\n         BNH   PRCPYEND                          DUE TO OZ19494 VS00033 Q3135050\n         L     R15,=A(PRINTID) GO PRINT IT       DUE TO OZ19494 VS00033 Q3135150\n         BALR  R14,R15                           DUE TO OZ19494 VS00033 Q3135200\n         L     R15,=A(PRINTID)                   DUE TO OZ19494 VS00033 Q3135350\n         BALR  R14,R15                           DUE TO OZ19494 VS00033 Q3135400\n>< ENDUP\n\n* ORIGINAL VS00014 (OZ19494) MERGED WITH AFFECTED VS00033 LINES.\n>< CHANGE NAME=HASPPRPU\n*        BH    PNXTCPY   DELETED FOR VS00033     DUE TO OZ19494 VS00033 Q3135000\n         BNH   PRCPYEND                          DUE TO OZ19494 VS00033 Q3135050\n         LA    R1,=CL5' END'      GENER END PAGE                VS00033 Q3135100\n         L     R15,=A(PRINTID) GO PRINT IT       DUE TO OZ19494 VS00033 Q3135150\n         BALR  R14,R15                           DUE TO OZ19494 VS00033 Q3135200\n         LA    R1,=CL5'COPY '                                   VS00033 Q3135300\n         L     R15,=A(PRINTID)                   DUE TO OZ19494 VS00033 Q3135350\n         BALR  R14,R15                           DUE TO OZ19494 VS00033 Q3135400\n>< ENDUP\n\n* REMOVED FROM ORIGINAL VS00033 (VS00014 MERGED INTO ORIGINAL VS00033)\n         BNH   PRCPYEND                                         VS00033 Q3135000\n         LA    R1,=CL5' END'      GENER END PAGE                VS00033 Q3135100\n         BAL   PL,PRINTID         GO PRINT IT                   VS00033 Q3135200\n         LA    R1,=CL5'COPY '                                   VS00033 Q3135300\n         BAL   PL,PRINTID                                       VS00033 Q3135400\n\n/*\n./ ADD NAME=VS00034  0101-80102-80102-2053-00015-00025-00008-$SYS13  00\n//VS00034  JOB (2000,S010),WENZEL,CLASS=Z\n/*JOBPARM Q=F,I\n//*\n//*        MOVE THE REENTRANT MODULES FOR COBOL TO LPALIB\n//*        DID NOT UPDATE CDS BECAUSE THERE WERE TOO MANY MODULES\n//*        AND TOO MANY ALIASES\n//*\n//STEP1  EXEC PGM=IEBCOPY\n//VSCOBOL  DD DISP=SHR,DSN=SYS4.VSCOBOL.V23.LPALIB\n//LPALIB   DD DISP=OLD,DSN=SYS1.LPALIB,\n//            VOL=SER=ITEL01,UNIT=DISK\n//SYSPRINT DD SYSOUT=*\n//SYSIN    DD *\n C I=((VSCOBOL,R)),O=LPALIB\n/*\n./ ADD NAME=VS00036  0100-80109-80109-1540-00009-00009-00000-$SYS13  00\n//VS00036  JOB (2000,S010),WENZEL,CLASS=Z\n/*JOBPARM Q=F,I\n//STEP01   EXEC ASMFCL,MAC1='SYS2.MACLIB'\n//ASM.SYSLIB DD UNIT=DISK,VOL=SER=ITEL01\n//ASM.SYSIN  DD  DISP=SHR,DSN=SYS0.CMDLIB2.SOURCE(SPFCOPY)\n//LKED.SYSLMOD  DD  DISP=SHR,DSN=SYS2.CMDLIB\n//LKED.SYSIN    DD  *\n NAME  SPFCOPY(R)\n/*\n./ ADD NAME=VS00037  0108-80109-80119-1604-00015-00011-00011-$SYS13  00\n//VS00037  JOB (2000,S010),WENZEL,CLASS=Z\n/*JOBPARM Q=F,I\n//*\n//*         STEP 1 ASSEMBLE AND LINKEDIT SPFIPAN2\n//*\n//STEP1    EXEC ASMFCL,MAC='SYS2.MACLIB'\n//ASM.SYSLIB DD\n//           DD UNIT=DISK,VOL=SER=SYS100\n//ASM.SYSIN DD DSN=SYS0.CMDLIB2.SOURCE(SPFIPAN2),DISP=SHR\n//LKED.SYSLMOD DD DISP=OLD,DSN=SYS2.CMDLIB\n//PANVALET DD DISP=SHR,DSN=SYS3.PANVALET.LINKLIB\n//LKED.SYSIN    DD  *\n INCLUDE PANVALET(PAM)\n NAME  SPFIPAN2(R)\n/*\n./ ADD NAME=VS00038  3802-80010-80101-1644-00025-00026-00009-$SYS13  00\n//VS00038  JOB  (2000,S010),WENZEL,CLASS=Z\n/*JOBPARM Q=F,I\n//SMP EXEC IPOSMP4\n//SYSIN DD *\n RECEIVE S (VS00038).\n APPLY S (VS00038) .\n LOG (CHANGE ALLOCATE DEFAULT DISPOSITION FROM OLD TO SHR).\n LIST CDS SYSMOD(VS00038) .\n LIST CDS    MOD(IKJEFD30) .\n/*\n//SMPPTFIN DD *\n++ USERMOD(VS00038)\n /* PROBLEM :  TSO ALLOC DEFAULTS TO 'OLD'\n    SOLUTION:  CHANGE ALLOC DEFAULT TO 'SHR'\n    BENEFIT :  LESSENS DATASET CONTENTION BY TSO USERS\n               AND/OR BATCH\n    SOURCE  :  SSD #277 SHARE INC., JULY 15,1977\n               CHANGED FOR SU 11  12/21/79 F.HAMBRICK\n */.\n++ VER (Z038) FMID(JBB1112) .\n++ ZAP (IKJEFD30) .\n  NAME IKJEFD30\n  VER 0284 D201A00E,C5CA              MVC  STATSPDE(2,@10),@CH00034\n  REP 0284 D201A00E,C5CC              MVC  STATSPDE(2,@10),@CH00088\n  IDRDATA VS00038\n./ ADD NAME=VS00039  0111-79358-80101-1732-00020-00016-00000-$SYS03  00\n//VS00039  JOB (2000,S010),S.CAIRES,CLASS=Z,MSGCLASS=A\n/*JOBPARM Q=F,I\n//* VS00039 FROM FOWLER MEMOREX.\n//VS00039  EXEC IPOSMP4          DLIB=PAG002,RES=SYS101,PTS=PAG002\n//SYSIN DD *\n LIST  PTS SYSMOD(VS00039) .\n REJECT  S (VS00039).\n RECEIVE S (VS00039).\n LIST  PTS SYSMOD(VS00039) .\n APPLY   S (VS00039) CHECK /* DIS(READ) */ .\n//SMPPTFIN DD  *\n++ USERMOD (VS00039) /* JTIP 12/17/79 FIXES */ .\n++ VER (Z038)  FMID(EJE1102)\n       PRE (AZ38575, UZ24620)\n       REQ (VS00025) .\n++ SRCUPD (HASPMISC) DISTLIB(HASPSRC) .\n>< CHANGE NAME=HASPMISC\n*  CODE DELETED FROM JTIP, INCLUDED BY ERROR 12/17/79   UIC 002 VS00039 N4830010\n*  CODE DELETED FROM JTIP, INCLUDED BY ERROR 12/17/79   UIC 002 VS00039 N5216010\n><  ENDUP\n./ ADD NAME=VS00040  0103-80171-80182-1904-00029-00029-00003-$SYS13  00\n//VS00040 JOB (2000,S010),WENZEL,CLASS=Z\n/*JOBPARM Q=F,I\n//*\n//*   INSTALL THE JARS CICS SVC'S 237 AND 208.\n//*\n//VS00040  EXEC IPOSMP4\n//SYSIN DD *\n UCLIN CDS .\n REP MOD(IGC208)   LMOD(IEANUC01) DISTLIB(JARSCICS) FMID(EBB1102) .\n ENDUCL .\n RECEIVE S(VS00040) .\n APPLY   S(VS00040) .\n LOG (ADD SVC'S 237 AND 208 FOR JARS TESTCICS) .\n LIST CDS SYSMOD(VS00040) .\n//JARSCICS DD DISP=SHR,DSN=SYS4.JARSCICS.V21.TEST.LOADLIB\n//SMPPTFIN DD DATA\n++ USERMOD (VS00040) .\n++ VER (Z038) FMID(EBB1102).\n++ MOD (IGC208)  DISTLIB(JARSCICS)  LKLIB(JARSCICS) .\n++ MOD (IGC0023G) DISTLIB(JARSCICS) LKLIB(JARSCICS) .\n++ JCLIN .\n//VS00040 EXEC PGM=IEBCOPY\n//SYSPRINT DD SYSOUT=*\n//JARSCICS DD DISP=SHR,DSN=SYS4.JARSCICS.V21.TEST.LOADLIB\n//LPALIB DD DSN=SYS1.LPALIB,DISP=OLD\n//SYSIN  DD *\n C I=((JARSCICS,R)),O=LPALIB\n S M=IGC0023G\n/*\n./ ADD NAME=VS00041  3803-80010-80101-1102-00357-00354-00011-$SYS13  00\n//VS00041 JOB (2000,S010),WENZEL,CLASS=Z\n/*JOBPARM Q=F,I\n//*\n//LPACMD EXEC PGM=IEBCOPY\n//SYSPRINT   DD SYSOUT=*\n//SYSUT3 DD UNIT=SYSDA,SPACE=(CYL,(10,10))\n//SYSUT4 DD UNIT=SYSDA,SPACE=(CYL,(10,10))\n//LPALIB     DD DSN=SYS1.LPALIB,DISP=SHR,UNIT=DISK,VOL=SER=ITEL01\n//SCMDLIB    DD DSN=SYS1.CMDLIB,DISP=SHR,UNIT=DISK,VOL=SER=ITEL01\n//SYSIN      DD *\n COPY OUTDD=LPALIB,INDD=SCMDLIB\n S M=AKJLKL01\n S M=AKJLKL02\n S M=ALLOC\n S M=ALLOCATE\n S M=ALTER\n S M=ATTR\n S M=ATTRIB\n S M=BIX\n S M=BLDINDEX\n S M=CANCEL\n S M=CNVTC\n S M=CNVTCAT\n S M=DEF\n S M=DEFINE\n S M=DEL\n S M=DELETE\n S M=E\n S M=EDIT\n S M=END\n S M=EX\n S M=EXEC\n S M=EXPORT\n S M=EXPORTRA\n S M=FREE\n S M=H\n S M=HELP\n S M=IDCAM01\n S M=IDCAM02\n S M=IKJEBEAA\n S M=IKJEBEAR\n S M=IKJEBEBO\n S M=IKJEBECH\n S M=IKJEBECI\n S M=IKJEBECK\n S M=IKJEBECO\n S M=IKJEBEDA\n S M=IKJEBEDC\n S M=IKJEBEDE\n S M=IKJEBEDO\n S M=IKJEBEDX\n S M=IKJEBEEN\n S M=IKJEBEEX\n S M=IKJEBEFC\n S M=IKJEBEFI\n S M=IKJEBEFO\n S M=IKJEBEHE\n S M=IKJEBEIA\n S M=IKJEBEIN\n S M=IKJEBEIP\n S M=IKJEBEIS\n S M=IKJEBELE\n S M=IKJEBELI\n S M=IKJEBELT\n S M=IKJEBEMA\n S M=IKJEBEMC\n S M=IKJEBEME\n S M=IKJEBEMM\n S M=IKJEBEMR\n S M=IKJEBEMS\n S M=IKJEBEM1\n S M=IKJEBEM2\n S M=IKJEBEM3\n S M=IKJEBEM4\n S M=IKJEBEM5\n S M=IKJEBEM6\n S M=IKJEBEM7\n S M=IKJEBEPS\n S M=IKJEBERC\n S M=IKJEBERE\n S M=IKJEBERN\n S M=IKJEBERU\n S M=IKJEBESA\n S M=IKJEBESC\n S M=IKJEBESE\n S M=IKJEBESU\n S M=IKJEBETA\n S M=IKJEBETO\n S M=IKJEBEUI\n S M=IKJEBEUN\n S M=IKJEBEUP\n S M=IKJEBEUT\n S M=IKJEBEVE\n S M=IKJEBEXT\n S M=IKJEBRE5\n S M=IKJEFE11\n S M=IKJEFFCA\n S M=IKJEGAT\n S M=IKJEGATD\n S M=IKJEGCAL\n S M=IKJEGCIV\n S M=IKJEGCPY\n S M=IKJEGDCB\n S M=IKJEGDEB\n S M=IKJEGDEL\n S M=IKJEGDRP\n S M=IKJEGEND\n S M=IKJEGEQU\n S M=IKJEGFRE\n S M=IKJEGGET\n S M=IKJEGGO\n S M=IKJEGLDF\n S M=IKJEGLDR\n S M=IKJEGLOD\n S M=IKJEGLSA\n S M=IKJEGLST\n S M=IKJEGMAP\n S M=IKJEGOFF\n S M=IKJEGPCH\n S M=IKJEGPSW\n S M=IKJEGQFY\n S M=IKJEGRUN\n S M=IKJEGSYM\n S M=IKJEGTCB\n S M=IKJEGWHR\n S M=IKJEHAL1\n S M=IKJEHDS1\n S M=IKJEHMEM\n S M=IKJEHPRO\n S M=IKJEHREN\n S M=IKJEHSIR\n S M=IKJLKL01\n S M=IMP\n S M=IMPORT\n S M=IMPORTRA\n S M=LINK\n S M=LISTA\n S M=LISTALC\n S M=LISTB\n S M=LISTBC\n S M=LISTC\n S M=LISTCAT\n S M=LISTCRA\n S M=LISTD\n S M=LISTDS\n S M=LISTR\n S M=LOAD\n S M=LOADGO\n S M=LOGOFF\n S M=LOGON\n S M=MPRA\n S M=OPER\n S M=OPERATOR\n S M=OUT\n S M=OUTPUT\n S M=PRINT\n S M=PROF\n S M=PROFILE\n S M=PROT\n S M=PROTECT\n S M=R\n S M=RCAT\n S M=REN\n S M=RENAME\n S M=REPRO\n S M=RESETCAT\n S M=RUN\n S M=SE\n S M=SEND\n S M=ST\n S M=STATUS\n S M=SUB\n S M=SUBMIT\n S M=TERM\n S M=TERMINAL\n S M=TEST\n S M=VERIFY\n S M=VFY\n S M=WHEN\n S M=XPRA\n/*\n//*S M=EXP  THIS ALIAS CAN BE USED WITH CAUTION\n//CMDUCL  EXEC IPOSMP4         UCLIN:  CMDLIB ---> LPALIB\n//SYSIN  DD  *\n  UCLIN CDS.\n  ADD LMOD(AKJLKL01)   SYSLIB(LPALIB).\n  ADD LMOD(AKJLKL02)   SYSLIB(LPALIB).\n  ADD LMOD(ALLOC)      SYSLIB(LPALIB).\n  ADD LMOD(ALLOCATE)   SYSLIB(LPALIB).\n  ADD LMOD(ALTER)      SYSLIB(LPALIB).\n  ADD LMOD(ATTR)       SYSLIB(LPALIB).\n  ADD LMOD(ATTRIB)     SYSLIB(LPALIB).\n  ADD LMOD(BIX)        SYSLIB(LPALIB).\n  ADD LMOD(BLDINDEX)   SYSLIB(LPALIB).\n  ADD LMOD(CANCEL)     SYSLIB(LPALIB).\n  ADD LMOD(CNVTC)      SYSLIB(LPALIB).\n  ADD LMOD(CNVTCAT)    SYSLIB(LPALIB).\n  ADD LMOD(DEF)        SYSLIB(LPALIB).\n  ADD LMOD(DEFINE)     SYSLIB(LPALIB).\n  ADD LMOD(DEL)        SYSLIB(LPALIB).\n  ADD LMOD(DELETE)     SYSLIB(LPALIB).\n  ADD LMOD(E)          SYSLIB(LPALIB).\n  ADD LMOD(EDIT)       SYSLIB(LPALIB).\n  ADD LMOD(END)        SYSLIB(LPALIB).\n  ADD LMOD(EX)         SYSLIB(LPALIB).\n  ADD LMOD(EXEC)       SYSLIB(LPALIB).\n  ADD LMOD(EXPORT)     SYSLIB(LPALIB).\n  ADD LMOD(EXPORTRA)   SYSLIB(LPALIB).\n  ADD LMOD(FREE)       SYSLIB(LPALIB).\n  ADD LMOD(H)          SYSLIB(LPALIB).\n  ADD LMOD(HELP)       SYSLIB(LPALIB).\n  ADD LMOD(IDCAM01)    SYSLIB(LPALIB).\n  ADD LMOD(IDCAM02)    SYSLIB(LPALIB).\n  ADD LMOD(IKJEBEAA)   SYSLIB(LPALIB).\n  ADD LMOD(IKJEBEAR)   SYSLIB(LPALIB).\n  ADD LMOD(IKJEBEBO)   SYSLIB(LPALIB).\n  ADD LMOD(IKJEBECH)   SYSLIB(LPALIB).\n  ADD LMOD(IKJEBECI)   SYSLIB(LPALIB).\n  ADD LMOD(IKJEBECK)   SYSLIB(LPALIB).\n  ADD LMOD(IKJEBECO)   SYSLIB(LPALIB).\n  ADD LMOD(IKJEBEDA)   SYSLIB(LPALIB).\n  ADD LMOD(IKJEBEDC)   SYSLIB(LPALIB).\n  ADD LMOD(IKJEBEDE)   SYSLIB(LPALIB).\n  ADD LMOD(IKJEBEDO)   SYSLIB(LPALIB).\n  ADD LMOD(IKJEBEDX)   SYSLIB(LPALIB).\n  ADD LMOD(IKJEBEEN)   SYSLIB(LPALIB).\n  ADD LMOD(IKJEBEEX)   SYSLIB(LPALIB).\n  ADD LMOD(IKJEBEFC)   SYSLIB(LPALIB).\n  ADD LMOD(IKJEBEFI)   SYSLIB(LPALIB).\n  ADD LMOD(IKJEBEFO)   SYSLIB(LPALIB).\n  ADD LMOD(IKJEBEHE)   SYSLIB(LPALIB).\n  ADD LMOD(IKJEBEIA)   SYSLIB(LPALIB).\n  ADD LMOD(IKJEBEIN)   SYSLIB(LPALIB).\n  ADD LMOD(IKJEBEIP)   SYSLIB(LPALIB).\n  ADD LMOD(IKJEBEIS)   SYSLIB(LPALIB).\n  ADD LMOD(IKJEBELE)   SYSLIB(LPALIB).\n  ADD LMOD(IKJEBELI)   SYSLIB(LPALIB).\n  ADD LMOD(IKJEBELT)   SYSLIB(LPALIB).\n  ADD LMOD(IKJEBEMA)   SYSLIB(LPALIB).\n  ADD LMOD(IKJEBEMC)   SYSLIB(LPALIB).\n  ADD LMOD(IKJEBEME)   SYSLIB(LPALIB).\n  ADD LMOD(IKJEBEMM)   SYSLIB(LPALIB).\n  ADD LMOD(IKJEBEMR)   SYSLIB(LPALIB).\n  ADD LMOD(IKJEBEMS)   SYSLIB(LPALIB).\n  ADD LMOD(IKJEBEM1)   SYSLIB(LPALIB).\n  ADD LMOD(IKJEBEM2)   SYSLIB(LPALIB).\n  ADD LMOD(IKJEBEM3)   SYSLIB(LPALIB).\n  ADD LMOD(IKJEBEM4)   SYSLIB(LPALIB).\n  ADD LMOD(IKJEBEM5)   SYSLIB(LPALIB).\n  ADD LMOD(IKJEBEM6)   SYSLIB(LPALIB).\n  ADD LMOD(IKJEBEM7)   SYSLIB(LPALIB).\n  ADD LMOD(IKJEBEPS)   SYSLIB(LPALIB).\n  ADD LMOD(IKJEBERC)   SYSLIB(LPALIB).\n  ADD LMOD(IKJEBERE)   SYSLIB(LPALIB).\n  ADD LMOD(IKJEBERN)   SYSLIB(LPALIB).\n  ADD LMOD(IKJEBERU)   SYSLIB(LPALIB).\n  ADD LMOD(IKJEBESA)   SYSLIB(LPALIB).\n  ADD LMOD(IKJEBESC)   SYSLIB(LPALIB).\n  ADD LMOD(IKJEBESE)   SYSLIB(LPALIB).\n  ADD LMOD(IKJEBESU)   SYSLIB(LPALIB).\n  ADD LMOD(IKJEBETA)   SYSLIB(LPALIB).\n  ADD LMOD(IKJEBETO)   SYSLIB(LPALIB).\n  ADD LMOD(IKJEBEUI)   SYSLIB(LPALIB).\n  ADD LMOD(IKJEBEUN)   SYSLIB(LPALIB).\n  ADD LMOD(IKJEBEUP)   SYSLIB(LPALIB).\n  ADD LMOD(IKJEBEUT)   SYSLIB(LPALIB).\n  ADD LMOD(IKJEBEVE)   SYSLIB(LPALIB).\n  ADD LMOD(IKJEBEXT)   SYSLIB(LPALIB).\n  ADD LMOD(IKJEBRE5)   SYSLIB(LPALIB).\n  ADD LMOD(IKJEFE11)   SYSLIB(LPALIB).\n  ADD LMOD(IKJEFFCA)   SYSLIB(LPALIB).\n  ADD LMOD(IKJEGAT)    SYSLIB(LPALIB).\n  ADD LMOD(IKJEGATD)   SYSLIB(LPALIB).\n  ADD LMOD(IKJEGCAL)   SYSLIB(LPALIB).\n  ADD LMOD(IKJEGCIV)   SYSLIB(LPALIB).\n  ADD LMOD(IKJEGCPY)   SYSLIB(LPALIB).\n  ADD LMOD(IKJEGDCB)   SYSLIB(LPALIB).\n  ADD LMOD(IKJEGDEB)   SYSLIB(LPALIB).\n  ADD LMOD(IKJEGDEL)   SYSLIB(LPALIB).\n  ADD LMOD(IKJEGDRP)   SYSLIB(LPALIB).\n  ADD LMOD(IKJEGEND)   SYSLIB(LPALIB).\n  ADD LMOD(IKJEGEQU)   SYSLIB(LPALIB).\n  ADD LMOD(IKJEGFRE)   SYSLIB(LPALIB).\n  ADD LMOD(IKJEGGET)   SYSLIB(LPALIB).\n  ADD LMOD(IKJEGGO)    SYSLIB(LPALIB).\n  ADD LMOD(IKJEGLDF)   SYSLIB(LPALIB).\n  ADD LMOD(IKJEGLDR)   SYSLIB(LPALIB).\n  ADD LMOD(IKJEGLOD)   SYSLIB(LPALIB).\n  ADD LMOD(IKJEGLSA)   SYSLIB(LPALIB).\n  ADD LMOD(IKJEGLST)   SYSLIB(LPALIB).\n  ADD LMOD(IKJEGMAP)   SYSLIB(LPALIB).\n  ADD LMOD(IKJEGOFF)   SYSLIB(LPALIB).\n  ADD LMOD(IKJEGPCH)   SYSLIB(LPALIB).\n  ADD LMOD(IKJEGPSW)   SYSLIB(LPALIB).\n  ADD LMOD(IKJEGQFY)   SYSLIB(LPALIB).\n  ADD LMOD(IKJEGRUN)   SYSLIB(LPALIB).\n  ADD LMOD(IKJEGSYM)   SYSLIB(LPALIB).\n  ADD LMOD(IKJEGTCB)   SYSLIB(LPALIB).\n  ADD LMOD(IKJEGWHR)   SYSLIB(LPALIB).\n  ADD LMOD(IKJEHAL1)   SYSLIB(LPALIB).\n  ADD LMOD(IKJEHDS1)   SYSLIB(LPALIB).\n  ADD LMOD(IKJEHMEM)   SYSLIB(LPALIB).\n  ADD LMOD(IKJEHPRO)   SYSLIB(LPALIB).\n  ADD LMOD(IKJEHREN)   SYSLIB(LPALIB).\n  ADD LMOD(IKJEHSIR)   SYSLIB(LPALIB).\n  ADD LMOD(IKJLKL01)   SYSLIB(LPALIB).\n  ADD LMOD(IMP)        SYSLIB(LPALIB).\n  ADD LMOD(IMPORT)     SYSLIB(LPALIB).\n  ADD LMOD(IMPORTRA)   SYSLIB(LPALIB).\n  ADD LMOD(LINK)       SYSLIB(LPALIB).\n  ADD LMOD(LISTA)      SYSLIB(LPALIB).\n  ADD LMOD(LISTALC)    SYSLIB(LPALIB).\n  ADD LMOD(LISTB)      SYSLIB(LPALIB).\n  ADD LMOD(LISTBC)     SYSLIB(LPALIB).\n  ADD LMOD(LISTC)      SYSLIB(LPALIB).\n  ADD LMOD(LISTCAT)    SYSLIB(LPALIB).\n  ADD LMOD(LISTCRA)    SYSLIB(LPALIB).\n  ADD LMOD(LISTD)      SYSLIB(LPALIB).\n  ADD LMOD(LISTDS)     SYSLIB(LPALIB).\n  ADD LMOD(LISTR)      SYSLIB(LPALIB).\n  ADD LMOD(LOAD)       SYSLIB(LPALIB).\n  ADD LMOD(LOADGO)     SYSLIB(LPALIB).\n  ADD LMOD(LOGOFF)     SYSLIB(LPALIB).\n  ADD LMOD(LOGON)      SYSLIB(LPALIB).\n  ADD LMOD(MPRA)       SYSLIB(LPALIB).\n  ADD LMOD(OPER)       SYSLIB(LPALIB).\n  ADD LMOD(OPERATOR)   SYSLIB(LPALIB).\n  ADD LMOD(OUT)        SYSLIB(LPALIB).\n  ADD LMOD(OUTPUT)     SYSLIB(LPALIB).\n  ADD LMOD(PRINT)      SYSLIB(LPALIB).\n  ADD LMOD(PROF)       SYSLIB(LPALIB).\n  ADD LMOD(PROFILE)    SYSLIB(LPALIB).\n  ADD LMOD(PROT)       SYSLIB(LPALIB).\n  ADD LMOD(PROTECT)    SYSLIB(LPALIB).\n  ADD LMOD(R)          SYSLIB(LPALIB).\n  ADD LMOD(RCAT)       SYSLIB(LPALIB).\n  ADD LMOD(REN)        SYSLIB(LPALIB).\n  ADD LMOD(RENAME)     SYSLIB(LPALIB).\n  ADD LMOD(REPRO)      SYSLIB(LPALIB).\n  ADD LMOD(RESETCAT)   SYSLIB(LPALIB).\n  ADD LMOD(RUN)        SYSLIB(LPALIB).\n  ADD LMOD(SE)         SYSLIB(LPALIB).\n  ADD LMOD(SEND)       SYSLIB(LPALIB).\n  ADD LMOD(ST)         SYSLIB(LPALIB).\n  ADD LMOD(STATUS)     SYSLIB(LPALIB).\n  ADD LMOD(SUB)        SYSLIB(LPALIB).\n  ADD LMOD(SUBMIT)     SYSLIB(LPALIB).\n  ADD LMOD(TERM)       SYSLIB(LPALIB).\n  ADD LMOD(TERMINAL)   SYSLIB(LPALIB).\n  ADD LMOD(TEST)       SYSLIB(LPALIB).\n  ADD LMOD(VERIFY)     SYSLIB(LPALIB).\n  ADD LMOD(VFY)        SYSLIB(LPALIB).\n  ADD LMOD(WHEN)       SYSLIB(LPALIB).\n  ADD LMOD(XPRA)       SYSLIB(LPALIB).\n  ENDUCL.\n/*\n//*ADD LMOD(EXP)      SYSLIB(LPALIB). /* TO BE USED WITH CAUTION) */\n./ ADD NAME=VS00042  0101-80155-80155-1238-00034-00049-00000-$SYS13  00\n//VS00042 JOB (2000,S010),WENZEL,CLASS=Z\n/*JOBPARM Q=F,I\n//*********************************************************************\n//* THIS JOB MUST NOT BE RENUMBERED         DO NOT RENUMBER           *\n//*********************************************************************\n//* REFER   IPO1.JCLLIB(MSTRUPD)\n//* COMPID  SYSTEMS\n//* DOC     THIS JOB WILL MODIFY MSTRJCL SUCH THAT\n//*         JES WILL NOT BE STARTED AUTOMATICALLY AT IPL.\n//*\n//*********************************************************************\n//* THIS JOB MUST NOT BE RENUMBERED         DO NOT RENUMBER           *\n//*********************************************************************\n//*\n//* STEP1  USES SMP TO CHANGE MACRO SGIEE0MS.  SMP WILL REASSEMBLE\n//*        AND LINK-EDIT MSTRJCL INTO SYS1.LINKLIB AUTOMATICALLY.\n//*\n//STEP1    EXEC  IPOSMP4\n//SMPPTFIN DD    *\n++ USERMOD (VS00042) .\n++ VER (Z038) FMID(JBB1222)\n                     /* COMMENT OUT START OF JES IN MSTRJCL */ .\n++ MACUPD (SGIEE0MS)  DISTLIB (AMODGEN) .\n>< CHANGE NAME=SGIEE0MS\n         DC    CL80'//*START &SSNAME       **VS00042 ***'       VS00042\n>< ENDUP\n/*\n//SYSIN  DD *\n REJECT  S(VS00042) .\n RESTORE S(VS00042) .\n RECEIVE S(VS00042) .\n APPLY   S(VS00042) DIS(NO) .\n LIST  CDS SYSMOD(VS00042) DIS(NO) .\n/*\n./ ADD NAME=VS00043,SSI=00000163\n//VS00043 JOB (2000,S010),S.CAIRES,MSGCLASS=A,CLASS=Z\n/*JOBPARM Q=F,I\n//GENZAPS  PROC MEM=,                         INPUT MEMBER NAME\n//             MAC1='SYS1.MACLIB',VOL1=,\n//             MAC2='SYS1.AMODGEN',VOL2=,\n//             STEP='ASM2.V24.ARCH.LOAD',    STEPLIB FOR GENZAPS\n//             OUT='SYS0.SMP.SE.CNTL', GENZAPS OUTPUT\n//             DISK=VIO,                     TEMPORARY WORK SPACE\n//             S='(1000,(1000,100),,,ROUND)'  UTILITY DATASET SPACE\n//*\n//*      ASSEMBLE THE MODIFICATION\n//*\n//ASM     EXEC PGM=IFOX00,PARM='XREF(SHORT),NODECK'\n//SYSLIB   DD  DISP=SHR,DSN=&MAC1,VOL=SER=&VOL1,UNIT=DISK\n//         DD  DISP=SHR,DSN=&MAC2,VOL=SER=&VOL2,UNIT=DISK\n//SYSPRINT DD  DSN=&&LIST,DISP=(,PASS),UNIT=&DISK,SPACE=&S\n//SYSUT1   DD  UNIT=&DISK,SPACE=&S\n//SYSUT2   DD  UNIT=&DISK,SPACE=&S\n//SYSUT3   DD  UNIT=&DISK,SPACE=&S\n//*\n//*      PRODUCE THE ASSEMBLER LISTING\n//*\n//LIST    EXEC PGM=IEBGENER,COND=(8,LT,ASM)\n//SYSIN    DD  DUMMY\n//SYSPRINT DD  SYSOUT=*\n//SYSUT1   DD  DSN=&&LIST,DISP=(OLD,PASS)\n//SYSUT2   DD  SYSOUT=*\n//*\n//*      GENERATE THE SUPERZAP CARDS\n//*\n//GENZAP  EXEC PGM=$GENZAPS\n//ASSEMBLY DD  DSN=&&LIST,DISP=(OLD,DELETE)\n//STEPLIB  DD  DISP=SHR,DSN=&STEP\n//SYSPRINT DD  SYSOUT=*\n//SYSPUNCH DD  DSN=&OUT.(&MEM),DISP=OLD,DCB=BLKSIZE=3120\n//SYSUT1   DD  UNIT=&DISK,SPACE=&S\n//        PEND\n//ASMOPEN  EXEC  GENZAPS,MEM=VS00043O,\n//          OUT='SYS0.SMP.SE.CNTL'\n//ASM.SYSIN DD DISP=SHR,DSN=ASM2.V24.ARCH.DATA(OPNMVSMD)\n//PRT  EXEC PGM=IEBGENER\n//SYSPRINT  DD SYSOUT=A\n//SYSIN DD DUMMY\n//SYSUT1 DD DSN=ASM2.V24.ARCH.DATA(OPNMVSMD),DISP=SHR\n//SYSUT2 DD DSN=SYS0.SMP.SE.CNTL(VS00043I),DISP=SHR\n//*         DCB=(LRECL=80,RECFM=FB,BLKSIZE=6000)\n//SMP EXEC IPOSMP4\n//SYSIN DD *\n RESTORE S (VS00043).\n REJECT  S (VS00043).\n RECEIVE S (VS00043).\n APPLY S (VS00043) DIS(NO) .\n LOG (INSTALL ZAPS FOR OPEN MOD WITH ACCOUNTING INFO).\n LOG (LOCAL FIX VS00006 HAS THE COMMAND PROCESSORS FOR ASM2).\n LIST CDS SYSMOD(VS00043) .\n/*\n//SMPPTFIN DD DISP=SHR,DSN=SYS0.SMP.SE.CNTL(VS00043O)\n//         DD *\n IDRDATA VS00043\n//\n./ ADD NAME=VS00044  0102-80162-80162-1215-00068-00357-00066-$SYS13  00\n//VS00044 JOB (2000,S010),WENZEL,CLASS=Z\n/*JOBPARM Q=F,I\n//*\n//VS00044  EXEC IPOSMP4\n//SYSIN    DD  *\n RECEIVE S (VS00044) .\n APPLY S (VS00044)  DIS(NO).\n//SMPPTFIN DD  *\n++USERMOD (VS00044) .\n++VER (Z038) FMID(ESY1400) PRE(UR00535)   /*\n           IBM INFORMATION/SYSTEM (INFO/SYSTEM) 5735-OZS\n THE INFORMATION IN THIS DATABASE HAS NOT BEEN SUBMITTED TO ANY FORMAL\n IBM TEST AND IS DISTRIBUTED ON AN -AS IS- BASIS WITHOUT ANY WARRANTY\n EITHER EXPRESSED OR IMPLIED. THE IBM PROVIDED DATA IS COPYRIGHTED.\n                  (C) COPYRIGHT IBM CORP. 1979.                      TAP\n\n\n LAST KWS: K E CICS SMP\n PRINT DATA ENTRY  E014918\n\n H E014918 D=FEB80 S=SMP       C=GHX4            L=055\n T                       F   -CRCMV-IR10797--5744-SC-130--MS-MSGHMA3562\n T UCLIN BUILT BY CICS CAUSES MSGHMA3562 BECAUSE OF DISTLIB\n\n    AC23751H PIN 5744-SC-130-299 IR10797 MS-MSGHMA3562\n  F   -     -CRCMV-\n  UCLIN BUILT BY CICS CAUSES MSGHMA3562 BECAUSE OF DISTLIB\n  END OF ABSTRACT   FESN5X01503-SY1\n  REPORTED RELEASE    R400\n  ERROR DESCRIPTION:\n  CICS STAGE 2 GEN PRODUCES UCLIN CARDS TO UPDATE CDS MACRO\n  ENTRIES AND CAUSES THE PROBLEM REFERENCED IN PP81128 AND\n  PP87158. THE PROBLEM IS THAT A MACRO MAY BE USED TO ASSEMBLE\n  MULTIPLE MODULES. A UCLIN ADD STATEMENT IS BUILT FOR EACH\n  MODULE NAME. THE FOLLOWING WOULD BE TYPICAL IF A MACRO\n  ASSEMBLED TWO MODULES:\n   UCLIN CDS.\n   ADD MACRO(MACA) MOD(MODA) DISTLIB(CICS).\n   ADD MACRO(MACA) MOD(MODB) DISTLIB(CICS).\n  WHEN SMP ENCOUNTERS THE FIRST MACRO, THE ENTRY WILL BE ADDED AND\n  EVERYTHING IS OK. WHEN SMP ENCOUNTERS THE SECOND ADD CARD,\n  MSGHMA3562 IS PRODUCED AND THE UCLIN STOPS. THE HMA3562 MESSAGE\n  IS VALID DUE TO THE DISTLIB ENTRY ALREADY BEING PRESENT FROM THE\n  FIRST ADD (A DISTLIB CAN ONLY BE ADDED TO AN EMPTY ENTRY). THE\n  RESULT IS THAT YOU CAN ONLY UPDATE THE MACRO ENTRY WITH THE\n  FIRST MODULE NAME.\n    IF THE ADD CARDS ARE CHANGED TO REP CARDS TO AVOID THE ERROR\n  MESSAGE, YOU GET ONLY THE EFFECT OF THE LAST REP AS THE REP\n  TOTALLY REPLACES THE MACRO ENTRY.\n  PROBLEM CONCLUSION:\n  IF THERE IS A NEED FOR A REDESIGN OF SMP4, CICS AND OTHER\n  PROGRAMS WHO MAY HAVE THE SAME PROBLEM SHOULD REQUEST A\n  DESIGN CHANGE OF SMP4.\n  COMMENTS:\n  THIS APAR WAS CREATED AS A PSEUDO APAR.\n  CIRCUMVENTION:\n  THE FOLLOWING CIRCUMVENTION MAY BE USED TO AVOID CHANGING\n  ALL THE UCLIN ADD CARDS. THIS CIRCUMVENTION WILL ALLOW THE\n  ADD FUNCTION TO, IN EFFECT, REPLACE THE DISTLIB ENTRY ONLY.\n  THUS, THE LAST DISTLIB ENCOUNTERED ON AN ADD WILL BE THE\n  DISTLIB IN THE MACRO ENTRY. THIS CIRCUMVENTION SHOULD BE\n  REMOVED AS SOON AS THE CDS HAS BEEN UPDATED. */ .\n++ZAP (HMASMUC1).\n  NAME HMASMUC1\n  VER 14D4 4770A4C7\n  REP 14D4 4700A4C7\n  IDRDATA VS00044\n/*\n./ ADD NAME=VS00045  0100-80170-80170-1301-00032-00032-00000-$SYS13  00\n//VS00045 JOB (2000,S010),WENZEL,CLASS=Z\n/*JOBPARM Q=F,I\n//*\n//*   INSTALL THE CICS SVC'S 245, 229 AND 209.\n//*\n//VS00045  EXEC IPOSMP4,RES=ITEL01\n//SYSIN DD *\n UCLIN CDS .\n REP MOD(DFHHPSV1) LMOD(IEANUC01) DISTLIB(CICS) FMID(EBB1102) .\n REP MOD(DFHIRCP)  LMOD(IEANUC01) DISTLIB(CICS) FMID(EBB1102) .\n ENDUCL .\n REJECT S(VS00045) .\n RECEIVE S(VS00045) .\n APPLY   S(VS00045) .\n LOG (ADD SVC'S 245, 229 AND 209 FOR CICS) .\n LIST CDS SYSMOD(VS00045) .\n//CICS   DD DSN=SYS4.CICS.V140.TEST.LOADLIB,DISP=SHR\n//SMPPTFIN DD DATA\n++ USERMOD (VS00045) .\n++ VER (Z038) FMID(EBB1102).\n++ MOD (DFHHPSV1) DISTLIB(CICS) LKLIB(CICS) .\n++ MOD (DFHIRCP)  DISTLIB(CICS) LKLIB(CICS) .\n++ MOD (IGC0024E) DISTLIB(CICS) LKLIB(CICS) .\n++ JCLIN .\n//VS00045 EXEC PGM=IEBCOPY\n//SYSPRINT DD SYSOUT=*\n//CICS   DD DSN=SYS4.CICS.V140.TEST.LOADLIB,DISP=SHR\n//LPALIB DD DSN=SYS1.LPALIB,DISP=SHR,UNIT=DISK,VOL=SER=ITEL01\n//SYSIN  DD *\n C I=((CICS,R),O=LPALIB\n S M=IGC0024E\n/*\n./ ADD NAME=VS00046  0105-80170-80170-1320-00049-00025-00041-$SYS13  00\n//VS00046 JOB (2000,S010),WENZEL,CLASS=Z\n/*JOBPARM Q=F,I\n//*\n//*         STEP 1 ASSEMBLE IEDQ21 FOR ACF2\n//*         STEP 2 SMP TO INSTALL IEDQ21 AND ZAP IEDAYW\n//*\n//STEP1    EXEC ASMFC,\n//          PARM.ASM='NOTERM,LIST,NODECK,OBJECT'\n//ASM.SYSGO DD DSN=SYS0.LINKLIB2.OBJ(IEDQ21),DISP=OLD\n//SYSIN     DD DSN=SYS4.ACF2.V221.ACFMAC(ACIEDQ21),DISP=SHR\n//*\n//STEP2  EXEC IPOSMP4,COND=(8,LT)\n//SMPCNTL  DD  *\n REJECT  S (VS00046).\n RECEIVE S (VS00046).\n APPLY   S (VS00046) DIS(NO).\n LOG (REPLACE TTY TRANSLATE TABLE AND ZAP IEDAYW).\n LIST  CDS SYSMOD(VS00046) DIS(NO).\n//SMPPTFIN  DD  *\n++USERMOD(VS00046)  /* ACF2 PTF TT70020, OLD ACF2 PTF TT70010 */ .\n++VER(Z038) FMID(ETC0108) PRE(UZ26841)   /* REL 3.8  */ .\n++MOD(IEDQ21) DISTLIB(AOS21)  TXLIB(OBJECT).\n++ZAP(IEDAYW) DISTLIB(AOS21)   /*\n  THESE ZAPS TO TCAM MODIFY THE I/O EDITTING\n  ROUTINES SO THAT TTY COMPATIBLE TERMINALS\n  ARE ABLE TO RECEIVE/SEND CERTAIN CONTROL\n  CHARACTERS SUCH AS PHYSICAL BACKSPACE,\n  SCREEN CLEAR STRINGS, AND OTHERS.  THIS ALSO\n  SHOULD REQUIRE THE INSTALLATION OF THE\n  UNIVERSAL ASCII TRANSLATE TABLE (IEDQ21).\n  IF THIS OPTIONAL FIX IS PLACED ON THE\n  SYSTEM, SEE THE @OPTS MACRO IN ACFFDR\n  FOR ASCII TERMINAL SPECIFICATIONS.  REMEMBER\n  TO RUN AN MCP LINKEDIT AFTER APPLICATION.  */ .\nNAME IEDAYW\n*  FOR USE WITH 270X EMULATOR\nVER 0F64 441031E4    REDUC01  EX  RNDX,CTLR     TR OUT CNTL CHARS\nVER 0F68 18F8                 LR  RRTN,RTEMP    COPY CHAR COUNT\nVER 0F6A 957A9000    CTLOOP   CLI ZERO(RTEMPA),COLON CHAR=COLON?\nVER 0F6E 477031C0             BNE NOPRINT       COUNT NON COLONS\n*  ALLOW ASCII TERMINAL TO USE BACKSPACE\nVER 0E7C 9120D15A             TM  AVTPARM3+2,CTWX  TWX TERMINAL?\nVER 0E80 471030EE             BO  REPWID        REPL BS W/IDLE\n*  CHANGE ABOVE TCAM CODE TO\nREP 0F64 4700                 NOP               LEAVE ALL CHARS\nREP 0F6E 47F0                 B   NOPRINT       CNT ALL CHARS\nREP 0E80 4700                 NOP               ALLOW BACKSPACE\n//OBJECT    DD  DISP=SHR,DSN=SYS0.LINKLIB2.OBJ\n//********************************************************************\n./ ADD NAME=VS00047  0104-80191-80207-1532-00047-00046-00000-$CSG05  00\n//VS00047  JOB (2000,S010),WENZEL,CLASS=Z\n/*JOBPARM Q=F,I\n//VS00047  EXEC IPOSMP4\n//SYSIN DD *\n REJECT  S (VS00047) .\n RECEIVE S (VS00047) .\n APPLY   S (VS00047) .\n//SMPPTFIN DD  *\n++ USERMOD (VS00047) /* PUT JOB NAME ON THE PUNCH SEPARATOR CARD */ .\n++ VER (Z038)  FMID(EJE1102)\n       PRE (AZ40644, UZ26743, UZ27051, UZ27259, UZ90070,\n            TT82211,\n            VS00017, VS00018, VS00025, VS00033) .\n++ SRCUPD (HASPPRPU) DISTLIB(HASPSRC) .\n>< CHANGE NAME=HASPPRPU\n         L     PW,PCEDCT           PROVIDE DCT                 @ITEL    Q2611510\n         USING DCTDSECT,PW          ADDRESSABILITY             @ITEL    Q2611520\n         CLC   DCTUCS,=CL4'TN'     TN TRAIN MOUNTED ?          @ITEL    Q2611530\n         BNE   *+8                 NO, USE ALREADY LOADED ADDR @ITEL    Q2611540\n         L     R15,=A(PTNTBL)      GET TN TRANSLATE TABLE      @ITEL    Q2611550\n         DROP  PW                  SUSPEND DCT ADDRESSABILITY  @ITEL    Q2611560\n***************************************************************@ITEL    Q5280404\n*                                                              @ITEL    Q5280408\n*        &PRTRANS TRANSLATE TABLE - 96 CHARACTER TRAIN         @ITEL    Q5280412\n*                                                              @ITEL    Q5280416\n*        TRANSLATE INVALID TN-TRAIN CHARACTERS TO BLANKS       @ITEL    Q5280420\n*                                                              @ITEL    Q5280424\n***************************************************************@ITEL    Q5280428\n         SPACE 1                                               @ITEL    Q5280432\nPTNTBL   DC    C'                                '  TRANSLATE  @ITEL    Q5280436\n         DC    C'                                '  TABLE      @ITEL    Q5280440\n         DC    C'           .<(+|&&         !$*);\u00ac' USED TO    @ITEL    Q5280444\n         DC    C'-/         ,%_>?          :#@''=\"' TRANSLATE  @ITEL    Q5280448\n         DC    X'40818283848586878889404040404040'             @ITEL    Q5280452\n         DC    X'40919293949596979899404040404040'             @ITEL    Q5280456\n         DC    X'40A1A2A3A4A5A6A7A8A9404040AD4040'             @ITEL    Q5280460\n         DC    X'40404040404040404040404040BD4040'             @ITEL    Q5280464\n         DC    X'C0'                                           @ITEL    Q5280468\n         DC    C'ABCDEFGHI      '                   CHARACTERS @ITEL    Q5280472\n         DC    X'D0'                                           @ITEL    Q5280476\n         DC    C'JKLMNOPQR      '                   CHARACTERS @ITEL    Q5280480\n         DC    X'E0'                                           @ITEL    Q5280484\n         DC    C' STUVWXYZ   '                                 @ITEL    Q5280486\n         DC    X'EC4040'                                       @ITEL    Q5280487\n         DC    C'0123456789|     '                  TO BLANKS  @ITEL    Q5280488\n><  ENDUP                                                               Q9999999\n/*\n./ ADD NAME=VS00048  0103-80182-80198-0810-00030-00029-00016-$SYS08  00\n//VS00048 JOB (2000,S010),WENZEL,CLASS=Z\n/*JOBPARM Q=F,I\n//*\n//*   INSTALL THE JARS CICS SVC'S 237 AND 208.\n//*\n//VS00048  EXEC IPOSMP4\n//SYSIN DD *\n UCLIN CDS .\n REP MOD(IGC207)   LMOD(IEANUC01) DISTLIB(JARSCICS) FMID(EBB1102) .\n ENDUCL .\n REJECT  S(VS00048) .\n RECEIVE S(VS00048) .\n APPLY   S(VS00048) .\n LOG (ADD SVC'S 236 AND 207 FOR JARS TESTCICS) .\n LIST CDS SYSMOD(VS00048) .\n//JARSCICS DD DISP=SHR,DSN=SYS4.JARSCICS.V21.PROD.LOADLIB\n//SMPPTFIN DD DATA\n++ USERMOD (VS00048) .\n++ VER (Z038) FMID(EBB1102).\n++ MOD (IGC207)  DISTLIB(JARSCICS)  LKLIB(JARSCICS) .\n++ MOD (IGC0023F) DISTLIB(JARSCICS) LKLIB(JARSCICS) .\n++ JCLIN .\n//VS00048 EXEC PGM=IEBCOPY\n//SYSPRINT DD SYSOUT=*\n//JARSCICS DD DISP=SHR,DSN=SYS4.JARSCICS.V21.PROD.LOADLIB\n//LPALIB DD DSN=SYS1.LPALIB,DISP=OLD\n//SYSIN  DD *\n C I=((JARSCICS,R)),O=LPALIB\n S M=IGC0023F\n/*\n./ ADD NAME=VS00053  0108-80060-80101-1733-00039-00039-00000-$SYS03  00\n//VS00053  JOB (2000,S010),S.CAIRES,CLASS=Z,MSGCLASS=A\n/*JOBPARM Q=F,I\n//*\n//* VS00053 FROM DENNIS BARTLEY OF UIC, 2/28/80, BY CAIRES.\n//* AVOID ERROR IN HASPCOMM DUE TO COPY #COFJMXQ CODE BY APPLYING\n//* VS00053 BEFORE UZ26743 FROM PUT TAPE 7909 IS APPLIED TO NEW MVS 3.8\n//* AT DLIB 7908 LEVEL.\n//*\n//VS00053  EXEC IPOSMP4          DLIB=PAG002,RES=SYS101,PTS=PAG002\n//SYSIN DD *    ( //SMPCNTL DD DDNAME=SYSIN  IN IPOSMP4 PROC )\n LIST  CDS SYSMOD(VS00053) .\n RESTORE S (VS00053)  DIS(WRITE)  /* BACKUP CDS AND ACDS FIRST */ .\n LIST  PTS SYSMOD(VS00053) .\n REJECT  S (VS00053).\n RECEIVE S (VS00053).\n LIST  PTS SYSMOD(VS00053, JTP0001) .\n APPLY   S (VS00053)  DIS(WRITE)  /* BACKUP CDS AND ACDS FIRST */ .\n LIST  CDS SYSMOD(VS00053, JTP0001) .\n ACCEPT  S (VS00053)  USERMODS\n                      DIS(WRITE)  /* BACKUP CDS AND ACDS FIRST */ .\n LIST  ACDS SYSMOD(VS00053) .\n//SMPPTFIN DD  *\n++ USERMOD (VS00053) /* JTIP 03/06/80 FIX TO HASPCOMM ERROR; APPLY\n                        BEFORE PUT 7909 WITH UZ26743 JES2 LEVEL SET;\n                        FROM DENNIS BARTLEY OF UIC 2/28/80;\n                        #COFJMXQ OBTAINED BY COPY IN HASPCOMM */.\n++ VER (Z038)  FMID(JTP0001) .\n++ MACUPD (#COFJMXQ) DISTLIB(JTIPMAC) .\n>< CHANGE NAME=#COFJMXQ\n*        C     R1,SJBJQE JQE'S MATCH??  DELETED PER UIC 2/28/80 VS00053\n*        BNE   COFJMXL2  BR IF NOT      DELETED PER UIC 2/28/80 VS00053\n><  ENDUP\n//DUMMYJCL DD *        (UNUSED CARDS)\n APPLY   S (VS00053) CHECK /* DIS(READ) */ .\n         C     R1,SJBJQE           JQE'S MATCH??           BAD? UIC 002\n         BNE   COFJMXL2             BR IF NOT              BAD? UIC 002\n         CLC   JQETRAK,SJBJCTRK    JCT TRACK MATCH?        GOOD UIC 002\n         BNE   COFJMXL2             BR IF NOT              GOOD UIC 002\n/*\n./ ADD NAME=VS00054  0105-80217-80218-0801-00081-00081-00081-$CSG05  00\n//VS00054  JOB (2000,S010),ASM2\n/*JOBPARM Q=F,I\n/*ROUTE PRINT LOCAL\n//GENZAPS  PROC MEM=,                INPUT MEMBER NAME\n//             MAC1='SYS1.MACLIB',\n//             MAC2='SYS1.AMODGEN',\n//             MAC3='SYS4.ASM2.V25.ARCH.DATA',\n//             STEP='SYS4.ASM2.V25.ARCH.LOAD', STEPLIB FOR GENZAPS\n//             DISK=SYSDA,           TEMPORARY WORK SPACE\n//             S='(1000,(1000,100),,,ROUND)' WORK SPACE\n//*\n//*      ASSEMBLE THE MODIFICATION\n//*\n//ASM     EXEC PGM=IFOX00,PARM='XREF(SHORT),NODECK',\n//             TIME=5,REGION=256K\n//SYSIN    DD  DSN=SYS0.SMP.SE.CNTL(&MEM.I),DISP=SHR\n//SYSLIB   DD  DISP=SHR,DSN=&MAC1\n//         DD  DISP=SHR,DSN=&MAC2\n//         DD  DISP=SHR,DSN=&MAC3\n//SYSPRINT DD  DSN=&LIST,DISP=(,PASS),UNIT=&DISK,SPACE=&S\n//SYSUT1   DD  UNIT=&DISK,SPACE=&S\n//SYSUT2   DD  UNIT=&DISK,SPACE=&S\n//SYSUT3   DD  UNIT=&DISK,SPACE=&S\n//*\n//*      PRODUCE THE ASSEMBLER LISTING\n//*\n//LIST    EXEC PGM=IEBGENER,TIME=2,REGION=256K\n//SYSIN    DD  DUMMY\n//SYSPRINT DD  SYSOUT=*\n//SYSUT1   DD  DSN=&LIST,DISP=(OLD,PASS)\n//SYSUT2   DD  SYSOUT=*\n//*\n//*      GENERATE THE SUPERZAP CARDS\n//*\n//GENZAP  EXEC PGM=$GENZAPS,COND=(4,LT,ASM)\n//ASSEMBLY DD  DSN=&LIST,DISP=(OLD,DELETE)\n//STEPLIB  DD  DISP=SHR,DSN=&STEP\n//SYSPRINT DD  SYSOUT=*\n//SYSPUNCH DD  DSN=SYS0.SMP.SE.CNTL(&MEM.O),DISP=OLD\n//SYSUT1   DD  UNIT=&DISK,SPACE=&S\n//        PEND\n//GNR196WA EXEC  PGM=IEBGENER\n//SYSPRINT  DD  SYSOUT=A\n//SYSUT1    DD  *\n TITLE 'VS00054' - IFG0196W - ASM2 INFORMATION INTO F1 DSCB\nIFG0196W CSECT\n      PRINT ON,DATA,GEN    NEEDED TO PICK UP LONG CHAR STRINGS\n         LCLC  &PTF,&EXP,&LMTYP,&LMOPT,&REL,&MODNAME\n         LCLC  &BASE,&BYP1,&PAT1,&ENDMOD\n&LMTYP   SETC  'ACT'      SET TO SELECT\n*                             LAST MOD ID OPTION\n*                               'JOB' - USE JOBNAME/USERID\n*                               'ACF' - USE ACF2 LOGON ID\n*                               'ACT' - USE 1ST 8 CHAR.\n*                                         OF OS ACCT INFO\n&LMOPT   SETC  'F'      SET TO SELECT LAST MOD ID\n*                    'F' - LAST MOD ID FIRST ONLRWB 5/30/80\n*                    'U' - LAST MOD ID EVERY UPDRWB 5/30/80\n&PTF     SETC  'EDM1102'    PTF LEVEL OF IFG0196W\n*\n&REL     SETC   '038'      RELEASE LEVEL (037 OR 038)\n*\n&MODNAME SETC   'VS00054'   USER MODIFICATION NAME\n/*\n//SYSUT2   DD  DSN=&TEMP1,DISP=(,PASS),UNIT=SYSDA,\n//             SPACE=(TRK,(1,1)),DCB=SYS4.ASM2.V25.ARCH.DATA\n//SYSIN    DD  DUMMY\n//GNR196WB EXEC  PGM=IEBGENER,COND=(0,LT,GNR196WA)\n//SYSPRINT DD  SYSOUT=A\n//SYSUT1   DD  DSN=&TEMP1,DISP=(OLD,DELETE)\n//         DD  DSN=SYS4.ASM2.V25.ARCH.DATA(OPNMVS6W),DISP=SHR\n//SYSUT2   DD  DSN=SYS0.SMP.SE.CNTL(VS00054I),DISP=OLD\n//SYSIN    DD  DUMMY\n//ASM196W EXEC GENZAPS,MEM=VS00054\n//SMP EXEC IPOSMP4,COND=(4,LT)\n//SMPPTFIN DD DISP=SHR,DSN=SYS0.SMP.SE.CNTL(VS00054O)\n//SYSIN DD *\n RESTORE S(VS00054).\n REJECT  S(VS00054).\n RECEIVE S(VS00054).\n APPLY   S(VS00054).\n./ ADD NAME=VS00055  0104-80217-80218-0917-00081-00073-00081-$CSG05  00\n//VS00055  JOB (2000,S010),ASM2\n/*JOBPARM Q=F,I\n/*ROUTE PRINT LOCAL\n//GENZAPS  PROC MEM=,                INPUT MEMBER NAME\n//             MAC1='SYS1.MACLIB',\n//             MAC2='SYS1.AMODGEN',\n//             MAC3='SYS4.ASM2.V25.ARCH.DATA',\n//             STEP='SYS4.ASM2.V25.ARCH.LOAD', STEPLIB FOR GENZAPS\n//             DISK=SYSDA,           TEMPORARY WORK SPACE\n//             S='(1000,(1000,100),,,ROUND)' WORK SPACE\n//*\n//*      ASSEMBLE THE MODIFICATION\n//*\n//ASM     EXEC PGM=IFOX00,PARM='XREF(SHORT),NODECK',\n//             TIME=5,REGION=256K\n//SYSIN    DD  DSN=SYS0.SMP.SE.CNTL(&MEM.I),DISP=SHR\n//SYSLIB   DD  DISP=SHR,DSN=&MAC1\n//         DD  DISP=SHR,DSN=&MAC2\n//         DD  DISP=SHR,DSN=&MAC3\n//SYSPRINT DD  DSN=&LIST,DISP=(,PASS),UNIT=&DISK,SPACE=&S\n//SYSUT1   DD  UNIT=&DISK,SPACE=&S\n//SYSUT2   DD  UNIT=&DISK,SPACE=&S\n//SYSUT3   DD  UNIT=&DISK,SPACE=&S\n//*\n//*      PRODUCE THE ASSEMBLER LISTING\n//*\n//LIST    EXEC PGM=IEBGENER,TIME=2,REGION=256K\n//SYSIN    DD  DUMMY\n//SYSPRINT DD  SYSOUT=*\n//SYSUT1   DD  DSN=&LIST,DISP=(OLD,PASS)\n//SYSUT2   DD  SYSOUT=*\n//*\n//*      GENERATE THE SUPERZAP CARDS\n//*\n//GENZAP  EXEC PGM=$GENZAPS,COND=(4,LT,ASM)\n//ASSEMBLY DD  DSN=&LIST,DISP=(OLD,DELETE)\n//STEPLIB  DD  DISP=SHR,DSN=&STEP\n//SYSPRINT DD  SYSOUT=*\n//SYSPUNCH DD  DSN=SYS0.SMP.SE.CNTL(&MEM.O),DISP=OLD\n//SYSUT1   DD  UNIT=&DISK,SPACE=&S\n//        PEND\n//GNR194CA EXEC  PGM=IEBGENER\n//SYSPRINT  DD  SYSOUT=A\n//SYSUT1    DD  *\n TITLE 'VS00055' - IFG0194C - ASM2 INFORMATION INTO F1 DSCB\nIFG0194C CSECT\n      PRINT ON,DATA,GEN    NEEDED TO PICK UP LONG CHAR STRINGS\n         LCLC  &PTF,&EXP,&LMTYP,&LMOPT,&REL,&MODNAME\n         LCLC  &BASE,&BYP1,&PAT1,&ENDMOD\n&LMTYP   SETC  'ACT'      SET TO SELECT\n*                             LAST MOD ID OPTION\n*                               'JOB' - USE JOBNAME/USERID\n*                               'ACF' - USE ACF2 LOGON ID\n*                               'ACT' - USE 1ST 8 CHAR.\n*                                         OF OS ACCT INFO\n&LMOPT  SETC  'F'      SET TO SELECT LAST MOD ID\n*                    'F' - LAST MOD ID FIRST ONLRWB 5/30/80\n*                    'U' - LAST MOD ID EVERY UPDRWB 5/30/80\n&PTF     SETC  'UZ90018'   PTF LEVEL OF IFG0194C\n*\n&REL     SETC   '038'      RELEASE LEVEL (037 OR 038)\n*\n&MODNAME SETC   'VS00055'   USER MODIFICATION NAME\n/*\n//SYSUT2   DD  DSN=&TEMP2,DISP=(,PASS),UNIT=SYSDA,\n//             SPACE=(TRK,(1,1)),DCB=SYS4.ASM2.V25.ARCH.DATA\n//SYSIN    DD  DUMMY\n//GNR194CB EXEC  PGM=IEBGENER,COND=(0,LT,GNR194CA)\n//SYSPRINT DD  SYSOUT=A\n//SYSUT1   DD  DSN=&TEMP2,DISP=(OLD,DELETE)\n//         DD  DSN=SYS4.ASM2.V25.ARCH.DATA(OPNMVS4C),DISP=SHR\n//SYSUT2   DD  DSN=SYS0.SMP.SE.CNTL(VS00055I),DISP=OLD\n//SYSIN    DD  DUMMY\n//ASM194C EXEC GENZAPS,MEM=VS00055\n//SMP EXEC IPOSMP4,COND=(4,LT)\n//SMPPTFIN DD DISP=SHR,DSN=SYS0.SMP.SE.CNTL(VS00055O)\n//SYSIN DD *\n RESTORE S(VS00055).\n REJECT  S(VS00055).\n RECEIVE S(VS00055).\n APPLY   S(VS00055).\n./ ADD NAME=VS00056  0104-80217-80218-0918-00072-00064-00072-$CSG05  00\n//VS00056  JOB (2000,S010),ASM2\n/*JOBPARM Q=F,I\n/*ROUTE PRINT LOCAL\n//GENZAPS  PROC MEM=,                INPUT MEMBER NAME\n//             MAC1='SYS1.MACLIB',\n//             MAC2='SYS1.AMODGEN',\n//             MAC3='SYS4.ASM2.V25.ARCH.DATA',\n//             STEP='SYS4.ASM2.V25.ARCH.LOAD', STEPLIB FOR GENZAPS\n//             DISK=SYSDA,           TEMPORARY WORK SPACE\n//             S='(1000,(1000,100),,,ROUND)' WORK SPACE\n//*\n//*      ASSEMBLE THE MODIFICATION\n//*\n//ASM     EXEC PGM=IFOX00,PARM='XREF(SHORT),NODECK',\n//             TIME=5,REGION=256K\n//SYSIN    DD  DSN=SYS0.SMP.SE.CNTL(&MEM.I),DISP=SHR\n//SYSLIB   DD  DISP=SHR,DSN=&MAC1\n//         DD  DISP=SHR,DSN=&MAC2\n//         DD  DISP=SHR,DSN=&MAC3\n//SYSPRINT DD  DSN=&LIST,DISP=(,PASS),UNIT=&DISK,SPACE=&S\n//SYSUT1   DD  UNIT=&DISK,SPACE=&S\n//SYSUT2   DD  UNIT=&DISK,SPACE=&S\n//SYSUT3   DD  UNIT=&DISK,SPACE=&S\n//*\n//*      PRODUCE THE ASSEMBLER LISTING\n//*\n//LIST    EXEC PGM=IEBGENER,TIME=2,REGION=256K\n//SYSIN    DD  DUMMY\n//SYSPRINT DD  SYSOUT=*\n//SYSUT1   DD  DSN=&LIST,DISP=(OLD,PASS)\n//SYSUT2   DD  SYSOUT=*\n//*\n//*      GENERATE THE SUPERZAP CARDS\n//*\n//GENZAP  EXEC PGM=$GENZAPS,COND=(4,LT,ASM)\n//ASSEMBLY DD  DSN=&LIST,DISP=(OLD,DELETE)\n//STEPLIB  DD  DISP=SHR,DSN=&STEP\n//SYSPRINT DD  SYSOUT=*\n//SYSPUNCH DD  DSN=SYS0.SMP.SE.CNTL(&MEM.O),DISP=OLD\n//SYSUT1   DD  UNIT=&DISK,SPACE=&S\n//        PEND\n//GNR192CA EXEC  PGM=IEBGENER\n//SYSPRINT  DD  SYSOUT=A\n//SYSUT1    DD  *\n TITLE 'VS00056' - IDA0192C - ASM2 INFORMATION INTO VSAM\nIDA0192C CSECT\n      PRINT ON,DATA,GEN    NEEDED TO PICK UP LONG CHAR STRINGS\n         LCLC  &PTF,&EXP,&REL,&MODNAME\n         LCLC  &HOOK,&ENDMOD\n&PTF     SETC  'UZ27104'   PTF LEVEL OF IDA0192C\n*\n&REL     SETC   '038'      RELEASE LEVEL (037 OR 038)\n*\n&MODNAME SETC   'VS00056'   USER MODIFICATION NAME\n/*\n//SYSUT2   DD  DSN=&TEMP3,DISP=(,PASS),UNIT=SYSDA,\n//             SPACE=(TRK,(1,1)),DCB=SYS4.ASM2.V25.ARCH.DATA\n//SYSIN    DD  DUMMY\n//GNR192CB EXEC  PGM=IEBGENER,COND=(0,LT,GNR192CA)\n//SYSPRINT DD  SYSOUT=A\n//SYSUT1   DD  DSN=&TEMP3,DISP=(OLD,DELETE)\n//         DD  DSN=SYS4.ASM2.V25.ARCH.DATA(CLSMVS2C),DISP=SHR\n//SYSUT2   DD  DSN=SYS0.SMP.SE.CNTL(VS00056I),DISP=OLD\n//SYSIN    DD  DUMMY\n//ASM192C EXEC GENZAPS,MEM=VS00056\n//SMP EXEC IPOSMP4,COND=(4,LT)\n//SMPPTFIN DD DISP=SHR,DSN=SYS0.SMP.SE.CNTL(VS00056O)\n//SYSIN DD *\n RESTORE S(VS00056).\n REJECT  S(VS00056).\n RECEIVE S(VS00056).\n APPLY   S(VS00056).\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LIB2SRCE": {"ttr": 23562, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\t\\x01\\x19#\\x0f\\x01\\x19#\\x0f\\x18\\t\\xeeF\\xeeF\\x00\\x00\\xe3\\xd6\\xd6\\xd3\\xe2@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2019-08-18T00:00:00", "modifydate": "2019-08-18T18:09:09", "lines": 60998, "newlines": 60998, "modlines": 0, "user": "TOOLS"}, "mimetype": "application/octet-stream", "datatype": "binary", "extension": ".bin"}, "MACLIB": {"ttr": 48393, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00$\\x01\\x19#\\x0f\\x01\\x19#\\x0f\\x14A\\x11\\xe1\\x11\\xe1\\x00\\x00\\xe6\\xe8\\xd3\\xc2\\xe4\\xd9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2019-08-18T00:00:00", "modifydate": "2019-08-18T14:41:24", "lines": 4577, "newlines": 4577, "modlines": 0, "user": "WYLBUR"}, "text": "./ ADD NAME=ALLOC\n         MACRO\n&NAME    ALLOC &DUMMY,&PERM,&DSN=,&DDN=,&DDNRET=,&MEMBER=,&DISP=,      X\n               &VOL=,&UNIT=,&SYSOUT=,&FREE=,&COPIES=,&LABEL=,          X\n               &BLKSIZE=,&DEN=,&DSORG=,&KEYLEN=,&LRECL=,&RECFM=,       X\n               &PASWORD=,&DSNRET=,&MF=AUTO,&PREFIX=,&ERROR=,           X\n               &SPACE=,&F=,&FILE=,&DA=,&QNAME=,&DSORGRT=,              X\n               &VOLRET=,&DCBDSN=,&DCBDDN=,&SPECIAL=,&DDNTO=,           X\n               &FORMS=,&DEST=,&SSREQ=,&FORUSER=,&TU=,&DSNPDE=\n.**********************************************************************\n.*                                                                    *\n.*    THIS MACRO PROVIDES A DYNAMIC ALLOCATION FUNCTION BY BUILDING   *\n.*    A DYNAMIC ALLOCATION PARAMETER LIST AND INVOKING SVC 99.        *\n.*    IT FIRST SETS UP A WORKAREA ENVIRONMENT FOR THE PARAMETER LIST  *\n.*    AND THEN TESTS THE KEYWORDS SUPPLIED AND INVOKES INNER MACROS   *\n.*    TO BUILD THE TEXT UNITS. THE INNER MACROS THEMSELVES USE INNER  *\n.*    MACROS TO UPDATE GLOBAL VARIABLES, STORE TEXT UNIT POINTERS ETC *\n.*    THERE ARE THREE WAYS OF SPECIFYING THE WORK AREA ADDRESS.       *\n.*    A) MF=AUTO, MF=G, MF=(E,ADDRESS,LNTHSYMB).                      *\n.*    IN THE FIRST FORM, AN INNER MACRO DYNSPACE IS CALLED TO NAME    *\n.*    A WORK AREA, THE NAME BEING RETURNED IN THE GLOBAL SETC         *\n.*    VARIABLE &DYNSP. A DSECT IS CREATED TO MAP THIS AREA.           *\n.*    THE GLOBAL VARIABLES &DTUO (TEXT UNIT OFFSET COUNTER) AND       *\n.*    &DTUPO (TEXT UNIT POINTER OFFSET ACCUMULATOR) ARE SET TO ZERO.  *\n.*    THESE ACCUMULATORS ARE UPDATED AS EACH TEXT UNIT PROCESSOR      *\n.*    AQUIRES STORAGE. AFTER ALL TEXT UNITS HAVE BEEN BUILT, THE      *\n.*    AMOUNT OF SPACE USED IS CALCULATED, AND THE DYNSPACE MACRO IS   *\n.*    THEN CALLED AGAIN TO LOG THE AMOUNT NEEDED. DYNSPACE SETS A     *\n.*    GLOBAL VARIABLE &DYNSPQ TO THE HIGHEST AMOUNT ANY ALLOC OR      *\n.*    FREE MACRO REQUESTED, AND WHEN CALLED WITH THE EXPAND OPTION,   *\n.*    (NO OPERANDS OR NAME FIELD SUPPLIED), EXPANDS INTO A DS FOR     *\n.*    THAT QUANTITY. (SEE DYNSPACE)                                   *\n.*    MF=G SPECIFIES THAT THE ALLOC MACRO ENTER THE BEGIN MACRO       *\n.*    WORKAREA TO ACQUIRE THE STORAGE NECESSARY. IT DOES THIS VIA     *\n.*    THE RCPDS MACRO. (SEE RCPDS). HOWEVER, IF THE ALLOC MACRO IS    *\n.*    CALLED SEVERAL TIMES WITH THIS OPTION, A LOT OF STORAGE WILL BE *\n.*    USED UP, AS THE STORAGE WILL NOT BE SHARED. THUS, THIS FORM     *\n.*    SHOULD ONLY BE USED IF THE ALLOC/FREE MACRO IS ONLY TO BE USED  *\n.*    ONCE OR TWICE DURING AN ASSEMBLY.                               *\n.*    MF=E CAUSES THE MACRO TO USE A USER SPECIFIED WORK AREA. THE    *\n.*    SECOND PARAMETER GIVES THE NAME OF THE WORKAREA, AND AN         *\n.*    OPTIONAL THIRD PARAMETER IS THE NAME OF A SYMBOL TO BE EQUATED  *\n.*    TO THE LENGTH OF THE REQUIRED WORK AREA.                        *\n.*                                                                    *\n.*    DYNAMIC ALLOCATION FUNCTIONS ARE SIMILAR TO THOSE AVAILABLE    *\n.*    WITH JCL, USING THE SAME KEYWORDS. HOWEVER, CERTAIN FORMATS    *\n.*    ARE SLIGHTLY DIFFERENT. FOR INSTANCE, CERTAIN KEYWORDS CAN     *\n.*    HAVE VARYING PARAMETERS, EG DATASET NAME, DDNAME, VOLSER ETC.  *\n.*    PROVISION IS MADE FOR BOTH VARIABLE SPECIFICATION.             *\n.*    IN THE ABSOLUTE FORM, THE PARAMETER IS ENTERED IN QUOTES,      *\n.*    E.G.   ALLOC DSN='SYS1.LINKLIB',DISP=SHR                       *\n.*    HOWEVER, THIS NAME REMAINS FIXED FOR THE ASSEMBLY.             *\n.*    IN THE VARIABLE FORMAT, THE ADDRESS OF A LOCATOR IS SPECIFIED, *\n.*    WHERE THE LOCATOR CONSISTS OF A SIX BYTE FIELD, THE FIRST 4    *\n.*    BYTES OF WHICH POINT TO THE PARAMETER, WHILE THE NEXT TWO      *\n.*    CONTAIN THE LENGTH.                                            *\n.*    EG          ALLOC DSN=LOCATOR                                  *\n.*       LOCATOR  DC    A(DSN),Y(12)                                 *\n.*       DSN      DC    C'SYS1.LINKLIB'                              *\n.*                                                                   *\n.*       NUMERIC QUANTITIES E.G. COPIES= FOR SYSOUT, SHOULD EITHER   *\n.*       SPECIFY A NUMERIC VALUE, COPIES=3,                          *\n.*       A VALUE IN A REGISTER, COPIES=(R3),                         *\n.*       OR THE NAME OFF A FULLWORD CONTAINING THE VALUE,            *\n.*          COPIES=NUMCOPYS, WHERE NUMCOPYS IS THE NAME OF A         *\n.*       FULLWORD FIELD.                                             *\n.*                                                                   *\n.*       OTHER KEYWORDS SUCH AS DISP= CAN ONLY HAVE THE ABSOLUTE     *\n.*       FORM, AND VALUES SHOULD NOT BE ENTERED WITHIN QUOTES.       *\n.*       ADDITIONAL FACILITIES NOT AVAILABLE WITH JCL ARE THE        *\n.*       RETURN BY THE SYSTEM OF INFORMATION ON THE DATASET, EG      *\n.*       DSORG. THIS IS DONE BY SPECIFYING DSORGRT=SYMBOL, WHERE     *\n.*       SYMBOL IS A SYMBOL WHICH WILL BE EQUATED TO A TWO BYTE      *\n.*       FIELD CONTAINING THE DSORG TYPE (SEE JOB MANAGEMENT,        *\n.*       SUPERVISOR AND TSO).                                        *\n.*       THE SYSTEM CAN ALSO GENERATE AND RETURN A DDNAME. THIS IS   *\n.*       CARRIED OUT BY ENTERING DDNTO=(ADDR1,ADDR2,,...)            *\n.*       WHERE ADDR1,ADDR2 ETC ARE THE NAMES OF 8 BYTE FIELDS WHICH  *\n.*       ARE TO RECEIVE THE DDNAME.                                  *\n.*       FOR FURTHER INFORMATION ON DYNAMIC ALLOCATION, SEE          *\n.*       JOB MANAGEMENT, SUPERVISOR AND TSO.                         *\n.*                                                                   *\n.**********************************************************************\n         GBLA  &RCPDYN            COUNTER FOR NO ENTRIES TO MACRO\n         GBLA  &DTUO              OFFSET TO TEXT UNITS\n         GBLA  &DTUPO             OFFSET TO TEXT UNIT POINTERS\n         GBLB  &RCPS99(2)         TELL RCPDSECT NEED DSECTS\n         GBLC  &DYNP              PREFIX FOR LABELS FOR THIS CALL\n         GBLC  &DYNSP         NAME FOR AUTOMATIC STORAGE ALLOC\n         LCLA  &DDNRTO,&DSNRTO         FOR EQUATES FOR RETURNED FLDS\n         LCLA  &VOLRTO,&DSRGRTO        FOR EQUATES FOR RETURNED FIELDS\n         LCLA  &I                 COUNTER\n         LCLB  &DSECT             DSECT NEEDED FOR STORAGE, MF=E\n         LCLC  &C,&T,&PAR\n.*\n.*   THE ALLOC MACRO PROVIDES A DYNAMIC ALLOCATION FUNCTION,\n&RCPS99(1)     SETB           1\n&RCPDYN  SETA  &RCPDYN+1          INCEREMENT COUNTER\n&DYNP    SETC  'DYN&RCPDYN' SET DEFAULT PREFIX\n&NAME    DS    0H\n         AIF   ('&PREFIX' EQ '').TMF\n         AIF   (K'&PREFIX LT 4).POK\n         MNOTE 4,'PREFIX TOO LONG, 1ST 4 CHARS USED'\n&DYNP    SETC  '&PREFIX'(1,4)\n         AGO   .TMF\n.POK     ANOP\n&DYNP    SETC  '&PREFIX'\n.TMF     AIF   ('&MF(1)' EQ 'G').GEN\n         AIF   ('&MF' NE 'AUTO').TMFE\nNAME     DYNSPACE             GET NAME FOR SPACE\n         LA    R1,&DYNSP               LOAD ADDRESS OF PARAM LIST\n         USING &DYNP.DS,R1             USE GENERATED DSECT\n&T       SETC  'A'\n&PAR     SETC  '&DYNSP+4'\n&DSECT   SETB  1\n         AGO   .START\n.TMFE    AIF   ('&MF(2)' NE '').E2OK\n         MNOTE 4,'PLIST ADDRESS OMITTED, MF=G USED'\n         AGO   .GEN\n.E2OK    ANOP\n&DSECT   SETB  1\n         AIF   ('&MF(2)' EQ '(').RMFE\n         LA    R1,&MF(2)               LOAD PARAM LIST ADDRESS\n         USING &DYNP.DS,R1             USE GENERATED DSECT\n         AGO   .START\n.RMFE    AIF   ('&MF(2)' EQ '(R1)' OR '&MF(2)' EQ '(1)').START\n         LR    R1,&PAR                 LOAD S99 PARAM LIST ADDRESS\n         AGO   .START\n.GEN     LA    R1,&DYNP.RBP            LOAD ADDRESS OF S99 RBP\n.START   LA    R15,&DYNP.RB            LOAD ADDRESS OF S99 RB\n         USING S99RB,R15\n         ST    R15,0(R1)               AND STORE IN RB POINTER\n         XC    4(&DYNP.LEN-4,R1),4(R1) ZERO PARAMETER LIST\n         MVI   S99RBLN,20              MOVE IN LIST LENGTH\n         MVI   S99VERB,S99VRBAL        MOVE IN VERB CODE\n         LA    R14,&DYNP.TUP           LOAD ADDRESS OF TU POINTERS\n         ST    R14,S99TXTPP            STORE ADDRESS IN S99 RB\n         LA    R15,&DYNP.TU            POINT TO SPACE FOR TEXT UNITS\n         USING S99TUNIT,R15\n&DTUO    SETA  0\n&DTUPO   SETA  0\n         AIF   ('&SSREQ' EQ 'YES').SSREQ\n.TDSN    AIF   ('&DSN&DA' NE '').DSN\n         AIF   ('&DSNPDE' NE '').DSNPDE\n         AIF   ('&DSNRET' NE '').DSNRT\n         AIF   ('&SYSOUT' NE '').SYSOUT\n         AIF   ('&DUMMY' NE '').DUMMY\n         AIF   ('&QNAME' NE '').QNAME\n.TDDN    AIF   ('&DDN&FILE&F' NE '').DDN\n         AIF   ('&DDNRET&DDNTO' NE '').DDNRT\n.TUNIT   AIF   ('&UNIT&VOL' NE '').UNIT\n.TVOLRET AIF   ('&VOLRET' NE '').VOLRET\n.TDSRGO  AIF   ('&DSORGRT' NE '').DSORGRT\n.TLABEL  AIF   ('&LABEL' NE '').LABEL\n.TPSWD   AIF   ('&PASWORD' NE '').PASWORD\n.TFORUSE AIF   ('&FORUSER' NE '').FORUSER\n.TTU     AIF   ('&TU' NE '').TU\n.TDISP   AIF   ('&DISP' NE '').DISP\n.TSPACE  AIF   ('&SPACE' NE '').SPACE\n.TLRECL  AIF   ('&LRECL' NE '').DCB\n         AIF   ('&DEN' NE '').DCB\n         AIF   ('&RECFM' NE '').DCB\n         AIF   ('&BLKSIZE' NE '').DCB\n         AIF   ('&DSORG' NE '').DCB\n         AIF   ('&KEYLEN' NE '').DCB\n.TDCBDSN AIF   ('&DCBDSN' NE '').DCBDSN\n.TDCBDDN AIF   ('&DCBDDN' NE '').DCBDDN\n.TFREE   AIF   ('&FREE' EQ 'CLOSE').FREE                         TE7343\n.TPERM   AIF   ('&PERM' EQ 'PERM' OR '&PERM' EQ 'PERMANENT').PERM\n         AIF   ('&DUMMY' EQ 'PERM' OR '&DUMMY' EQ 'PERMANENT').PERM\n.TSPECI  AIF   ('&SPECIAL' NE '').SPECIAL\n         AGO   .SVC99\n.SSREQ   RCPSSREQ\n         AGO   .TDSN\n.DSN     RCPDSN &DSN&DA,&MEMBER\n         AGO   .TDDN\n.DSNPDE  RCPDSNPD &DSNPDE\n         AGO   .TDDN\n.DSNRT   RCPDSNRT &DSNRET\n&DSNRTO  SETA  &DTUO-46\n         AGO   .TDDN\n.SYSOUT  RCPSYSOU &SYSOUT,COPIES=&COPIES,FREE=&FREE,DEST=&DEST,        X\n               FORMS=&FORMS\n         AGO   .TDDN\n.DUMMY   RCPDUMMY &DUMMY\n         AGO   .TDDN\n.QNAME   RCPQNAME &QNAME\n         AGO   .TDDN\n.DDN     RCPDDN &DDN&F&FILE\n         AGO   .TUNIT\n.DDNRT   RCPDDNRT &DDNRET\n&DDNRTO  SETA  &DTUO-10\n         AGO   .TUNIT\n.UNIT   RCPUNIT &UNIT,&VOL\n         AGO   .TVOLRET\n.VOLRET  RCPVOLRT &VOLRET\n&VOLRTO  SETA  &DTUO-8\n         AGO   .TDSRGO\n.DSORGRT RCPDSRGR\n&DSRGRTO SETA  &DTUO-2\n         AGO   .TLABEL\n.LABEL   RCPLABEL &LABEL\n         AGO   .TPSWD\n.PASWORD RCPPSWD &PASWORD\n         AGO   .TFORUSE\n.FORUSER RCPFORUS &FORUSER\n         AGO   .TTU\n.TU      RCPTU &TU\n         AGO   .TDISP\n.DISP    RCPDISP &DISP\n         AGO   .TSPACE\n.SPACE   RCPSPACE &SPACE\n         AGO   .TLRECL\n.DCB     RCPDDCB LRECL=&LRECL,DEN=&DEN,RECFM=&RECFM,BLKSIZE=&BLKSIZE,  X\n               DSORG=&DSORG,KEYLEN=&KEYLEN\n         AGO .TDCBDSN\n.DCBDSN  RCPDCBDS &DCBDSN\n         AGO .TDCBDDN\n.DCBDDN  RCPDCBDD &DCBDDN\n         AGO .TFREE                                              TE7343\n.FREE    RCPFREE  &FREE                                          TE7343\n         AGO   .TPERM\n.PERM    RCPPERM\n         AGO   .TSPECI\n.SPECIAL RCPSPEC &SPECIAL\n.SVC99   ANOP\n&DTUPO   SETA  &DTUPO-4\n         SPACE\n         MVI   &DYNP.TUP+&DTUPO,X'80'  SET HIGH ORDER BIT ON TEXT PTRS\n         MVI   &DYNP.RBP,X'80'         SET HIGH ORDER BIT ON RB PTR\n         RCPSR2 UNSAVE\n&DTUPO   SETA  &DTUPO+4\n         AIF   (NOT &DSECT).DYNA\n         DROP  R1,R15                  DEACTIVATE ADDRESSABILITY\n         LA    R14,4(R1)               POINT TO REQUEST BLOCK\n.DYNA    DYNALLOC\n         AIF   (NOT &DSECT).LTR\n         USING &DYNP.RB,R14            SET UP ADDRESSABILITY\n**       NOTE  R14 HAS RB ADDRESS, R15 HAS SVC 99 RETURN CODE        **\n.LTR     AIF   ('&ERROR' EQ '').TDDTO\n         LTR   R15,R15                 TEST RETURN CODE\n         BNZ   &ERROR                  BRANCH IF NON ZERO\n.TDDTO   AIF   ('&DDNTO' EQ '').RESERVE\n&I       SETA  0\n.DDNTOL  ANOP\n&I       SETA  &I+1\n         AIF   ('&DDNTO(&I)' EQ '').RESERVE\n         AIF   ('&DDNTO(&I)'(1,1) EQ '(').DDNTOR\n         MVC   &DDNTO(&I).(8),&DYNP.TU+&DDNRTO+2\n         AGO   .DDNTOL\n.DDNTOR  ANOP\n&C       SETC  '&DDNTO(&I)'(2,K'&DDNTO(&I)-2)\n         MVC   0(8,&C),&DYNP.TU+&DDNRTO+2\n         AGO   .DDNTOL\n.RESERVE AIF   (&DSECT).RESDS\n         SPACE 1\n***********************************************************************\n**       RESERVE SPACE FOR DYNALLOC PARAMETER LIST                   **\n***********************************************************************\n         RCPDS\n.SSP     ANOP\n&DYNP.RBP DS   F                       SVC 99 REQ BLOCK POINTER\n&DYNP.RB  DS   5F                      SVC 99 REQUEST BLOCK\n&DYNP.TUP DS   CL&DTUPO                SPACE FOR TEXT POINTERS\n         AIF   (&DTUO EQ 0).DTU21\n&DYNP.TU  DS   CL&DTUO                 SPACE FOR TEXT UNITS\n         AIF   (&DSNRTO EQ 0).TDDNRTO\n&DSNRET  EQU   &DYNP.TU+&DSNRTO        OFFSET TO RETURNED DSN\n.TDDNRTO AIF   ('&DDNRET' EQ '').DTU11\n&DDNRET  EQU   &DYNP.TU+&DDNRTO        OFFSET TO RETURNED DDNAME\n.DTU11   AIF   (&VOLRTO EQ 0).DTU12\n&VOLRET  EQU   &DYNP.TU+&VOLRTO        OFFSET TO RETURNED VOLSER\n.DTU12   AIF   (&DSRGRTO EQ 0).DTU10\n&DSORGRT EQU   &DYNP.TU+&DSRGRTO       OFFSET TO RETURNED DSORG\n         AGO   .DTU10\n.DTU21   ANOP\n&DYNP.TU  DS   0C                      NO SPACE NEEDED FOR TEXT UNITS\n.DTU10   ANOP\n&DYNP.LEN EQU  *-&DYNP.RBP             LENGTH OF SPACE USED\n         AIF   (&DSECT).DSP\n         RCPDS\n         SPACE 3\n         AGO   .EXIT\n.RESDS   ANOP\n         AIF   ('&DYNSP' EQ '').SP3\n         DYNSPACE ADD\n.SP3     SPACE\n&DYNP.DS DSECT                         DSECT TO MAP SVC 99 DATA\n         AGO   .SSP\n.DSP     AIF   ('&MF(3)' EQ '').END1\n&MF(3)   EQU   &DYNP.LEN               LENGTH OF AREA\n.END1    ANOP\n&SYSECT  CSECT\n         SPACE 3\n.EXIT    MEND\n./ ADD NAME=BLPRWA   0100-79355-79355-0620-00019-00019-00000-TEC015  00\n         MACRO\n         BLPRWA\nBLPRWA   DSECT\n         SPACE\nWAFLAG1  DS    X\n         SPACE\nWALOWCOL EQU   X'80'              LOW COL SPECIFIED\nWAHICOL  EQU   X'40'              HI COLUMN SPECIFIED\nWAFMRKN  EQU   X'20'              LIST MARKER\nWAFTWLN  EQU   X'10'\nWAF2LNS  EQU   X'08'              LIST TWOLINES\nWAFSQUSH EQU   X'04'              LIST SQUSHED\nWAFCAN   EQU   X'02'              CANCEL RUN\n         SPACE 3\nWAMRKCH  DS    CL1\nWA2LNCH  DS    CL1\n         DS    0F\nWASIZE   EQU   *-BLPRWA\n         MEND\n./ ADD NAME=BTD\n         MACRO\n&L       BTD   &LOC,&LEN,&WORD,&SW\n&L       SYSLR 15,&WORD,OP=L\n         SYSLR 0,&LEN,TYPE=&SW\n         SYSLR 1,&LOC\n         CVCALL BTD\n         MEND\n./ ADD NAME=BTX\n         MACRO\n&L       BTX   &LOC,&LEN,&WORD\n&L       SYSLR 15,&WORD,OP=L\n         SYSLR 0,&LEN\n         SYSLR 1,&LOC\n         CVCALL BTX\n         MEND\n./ ADD NAME=CA\n         MACRO                                                   JH2038\n         CA    &DUMMY   (&DUMMY ALLOWS COMMENTS FIELD)           JH2038\n.*                                                               JH2038\n.*CHANGED 72.038 (07FEB72), J. HALPERIN.                         JH2038\n.*  CHANGE FROM COPY TO MACRO CALL.                              JH2038\n.*  ADD CATCB FIELD.                                             JH2038\n.*                                                               JH2038\n*\n*  CONTROL AREA\n*\nCASTART  DS    0F\nCAFL     DS    0X .     --FLAG BYTE\n*\nCAFECB   EQU   X'80' .  CAECB CONTAINS AN ECB ADDR\nCAFQF    EQU   X'40' .  QUEUE HAS OVERFLOWED\nCAFQE    EQU   X'20' .  QUEUE HAS BEEN EMPTIED\n*\nCAECB    DS    A .      ADDR OF ECB\nCATCB    DS    A .      ADDR OF TCB CORRESPONDING TO ECB        +JH2038\nCAQCTR   DS    F .      NUMBER OF ENTRIES IN THE QUEUE\n*\nCAQSIZE  EQU   16 .     QUEUE CAPACITY (WORDS)\n*\nCAQUEUE  DS    (CAQSIZE)F\n*\nCASIZE   EQU   *-CASTART\n         MEND                                                    JH2038\n./ ADD NAME=CALCTRK,SSI=00009345\n         LA    R6,CPWA             SET BASE\n         USING DVTAREA,R6              FOR DEVTABLE\n         LA    R0,CPSIZE           SET R0 TO BLKSIZE ALSO\n         LR    R3,R0               SET R3 ALSO\n         MH    R3,DVTTOL           MULT BY TOLERANCE\n         SRA   R3,9                DIVIDE BY 512\n         SR    R1,R1               SET FOR IC\n         IC    R1,DVTKEYO          GET KEY OVERHEAD\n         SR    R0,R1               ADJUST BLKSIZES SINCE NO KEYS\n         SR    R3,R1\n         TM    DVTFLAG,DVTFOHD     IS IT HALF WORD OVERHEAD\n         BO    CALCTRK1            BR YES\n         IC    R1,DVTBLKO          GET NORMAL BLOCK OVERHEAD\n         AR    R3,R1               ADJUST NORMAL VALUE\n         IC    R1,DVTLBLKO         GET LAST BLOCK OVERHEAD\n         AR    R0,R1               ADJUST LAST BLOCK VALUE\n         B     CALCTRK2            NOW GO ON\n         SPACE\nCALCTRK1 LH    R1,DVTBLKO          GET BLOCK OVERHEAD\n         AR    R0,R1               ADJUST BOTH FOR\n         AR    R3,R1                   BLOCK OVERHEAD\nCALCTRK2 LH    R1,DVTTRKSZ         GET TRACK SIZE\n         SR    R1,R0               ADJUST FOR LAST BLOCK\n         AR    R1,R3               ADD TO INCR COUNT BY 1\n         SR    R0,R0               SET FOR DIVIDE\n         DR    R0,R3               CALCULATE VALUE IN R1\n         DROP  R6\n./ ADD NAME=CAMLST\n         MACRO\n&NAME    CAMLST &PAR1,&PAR2,&PAR3,&PAR4,&OPT1,&OPT2,&OPT3,&DUMMY=\n         LCLA  &B1,&B2,&B3,&CTR\n         LCLB  &P(16),&OP(3),&D(4),&NOGO                            TSO\n         AIF   ('&PAR1' EQ '').E1\n         AIF   ('&PAR2' EQ '').E2\n.R1      ANOP\n&P(1)    SETB  ('&PAR1' EQ 'CAT' OR '&PAR1' EQ 'CATBX')             TSO\n&P(2)    SETB  ('&PAR1' EQ 'RECAT')\n&P(3)    SETB  ('&PAR1' EQ 'UNCAT' OR '&PAR1' EQ 'UCATDX')          TSO\n&P(4)    SETB  ('&PAR1' EQ 'BLDX' OR '&PAR1' EQ 'CATBX')            TSO\n&P(5)    SETB  ('&PAR1' EQ 'BLDG')\n&P(6)    SETB  ('&PAR1' EQ 'BLDA')\n&P(7)    SETB  ('&PAR1' EQ 'LNKX')\n&P(8)    SETB  ('&PAR1' EQ 'DLTX' OR '&PAR1' EQ 'UCATDX')           TSO\n&P(9)    SETB  ('&PAR1' EQ 'DLTA')\n&P(10)   SETB  ('&PAR1' EQ 'DRPX')\n&P(11)   SETB  ('&PAR1' EQ 'NAME')\n&P(12)   SETB  ('&PAR1' EQ 'BLOCK')\n&P(13)   SETB  ('&PAR1' EQ 'SEARCH')\n&P(14)   SETB  ('&PAR1' EQ 'SEEK')\n&P(15)   SETB  ('&PAR1' EQ 'SCRATCH')\n&P(16)   SETB  ('&PAR1' EQ 'RENAME')\n&CTR     SETA  &P(1)+&P(2)+&P(3)+&P(4)+&P(5)+&P(6)+&P(7)+&P(8)+&P(9)\n&CTR     SETA  &CTR+&P(10)+&P(11)+&P(12)+&P(13)+&P(14)+&P(15)+&P(16)\n         AIF   (&CTR EQ 0).E3                                       TSO\n&D(1)    SETB  ('&PAR3' NE '')\n&D(2)    SETB  ('&PAR4' NE '')\n         AIF   (NOT &D(1) AND (&P(13) OR &P(14) OR &P(16))).E4\n.R3      AIF   (&D(1) AND &P(15)).E5\n         AIF   (NOT &D(2) AND (&P(1) OR &P(2) OR &P(6) OR &P(7) OR &P(1X\n               1) OR &P(12) OR &P(13) OR &P(14) OR &P(15) OR &P(16))).E\n         AIF   (&P(1) AND &P(4)).R2                                 TSO\n         AIF   (&D(2) AND (&P(3) OR &P(4) OR &P(5) OR &P(8) OR &P(9) ORX\n               &P(10))).E6\n.R2      AIF   ('&OPT1' EQ '').CONTA\n         AIF   ('&OPT1' NE 'DELETE').E7\n&OP(1)   SETB  1\n         AIF   (NOT &P(5)).E7\n.CONTA   AIF   ('&OPT2' EQ '').CONTB\n&OP(2)   SETB  ('&OPT2' EQ 'EMPTY')\n&OP(3)   SETB  ('&OPT2' EQ 'OVRD')\n         AIF   (&OP(2)+&OP(3)  NE 1).E8\n         AIF   (NOT &P(5) AND &OP(2) OR(NOT &P(15) AND &OP(3))).E8\n.CONTB   AIF   ('&OPT3' EQ '' AND &P(5)).E10\n         AIF   ('&OPT3' NE '' AND NOT &P(5)).E11\n         AIF   (&NOGO EQ 1).END\n&B1      SETA  128*&D(1)+64*&D(2)+32*&P(1)+20*&P(2)+8*&P(3)+2*&P(12) O\n&D(4)    SETB  (&P(3) OR &P(8))                                     TSO\n&B1      SETA  &B1+4*(&P(11)+&P(5)+&P(6)+&P(7)+&D(4)+&P(9)+&P(10))  TSO\n&D(3)    SETB  (&P(1) OR &P(4))                                     TSO\n&B1      SETA  &B1+4*&D(3)+&P(13)+&P(15)+&P(16)                     TSO\n&B2      SETA  128*&P(14)+64*&P(4)+32*&P(5)+16*&P(6)+8*&P(7)+4*&P(8)+&PX\n               (9)\n&B3      SETA  128*&P(10)+64*&P(15)+32*&P(16)+64*&OP(1)+16*&OP(3)+8*&OPX\n               (2)\n&NAME    DS    0F                                ALIGN ON FULL WORD\n         DC    AL1(&B1)                          THREE BYTES OF FLAGS\n         DC    AL1(&B2)                          INDICATING THE FUNC-\n         DC    AL1(&B3)                          TION TO BE PERFORMED\n         AIF   (&P(5)).CONTC\n         DC    AL1(0)                            NO OPTION THREE\n         AGO   .CONTD\n.CONTC   DC    AL1(&OPT3)                        NO. OF ENTRIES\n.CONTD   DC    A(&PAR2)                          PARAMETER TWO\n         AIF   (&D(1)).CONTE\n         DC    A(0)                              PARAM. THREE OMMITTED\n         AGO   .CONTF\n.CONTE   DC    A(&PAR3)                          PARAMETER THREE\n.CONTF   AIF   (NOT &D(2)).END\n         DC    A(&PAR4)                          PARAMETER FOUR\n         MEXIT\n.E       IHBERMAC 5                     PAR4 MISSING\n         MEXIT\n.E1      IHBERMAC 2                     PAR1 MISSING\n         MEXIT\n.E2      IHBERMAC 3                     PAR2 MISSING\n&NOGO    SETB  1\n         AGO   .R1\n.E3      IHBERMAC 36,,&PAR1             PAR1 INVALID\n         MEXIT\n.E4      IHBERMAC 4                     PAR3 MISSING\n&NOGO    SETB  1\n         AGO   .R3\n         MEXIT\n.E5      IHBERMAC 60,,&PAR3             PAR3 W/SCRATCH\n         MEXIT\n.E6      IHBERMAC 39,,&PAR4             PAR4 NOT ALLOWED\n&NOGO    SETB  1\n         AGO   .R2\n.E7      IHBERMAC 50,,&OPT1             OPTN1 INVALID\n&NOGO    SETB  1\n         AGO   .CONTA\n.E8      IHBERMAC 51,,&OPT2             OPTN2 INVALID\n&NOGO    SETB  1\n         AGO   .CONTB\n.E10     IHBERMAC 52                    OPTN3 MISSING\n         MEXIT\n.E11     IHBERMAC 53,,&OPT3             OPTN3 INVALID\n.END     MEND\n./ ADD NAME=COMMAND\n         MACRO\n&LABEL   COMMAND &CMND,&GOTO,&HELP,&ABBR\n         LCLA  &K,&I,&J,&MASK(8)\n&MASK(1) SETA  1\n&MASK(2) SETA  2\n&MASK(3) SETA  4\n&MASK(4) SETA  8\n&MASK(5) SETA  16\n&MASK(6) SETA  32\n&MASK(7) SETA  64\n&MASK(8) SETA  128\n&LABEL   DC    CL8'&CMND' .        COMMAND ID\n         DC    AL2(R&HELP-ROUTBLE) HELP ROUTINE\n         DC    H'0'\n.* NOW GENERATE THE MASK\n&I       SETA  4\n.LOOP    AIF   ('&SYSLIST(&I)' EQ '').DONE\n&K       SETA  &SYSLIST(&I)\n&J       SETA  &J+&MASK(&K)\n&I       SETA  &I+1\n         AGO   .LOOP\n.DONE    ANOP\n         DC    AL1(&J) .           ABBREVIATIONS\n         DC    AL3(&GOTO) .        PROCESSING ROUTINE\n         MEND\n./ ADD NAME=COMMOLD\n         MACRO\n         COMMON\nCPAREA   DSECT\n         SPACE\n         COPY  CPTSO\n         EJECT\n         COPY  DSNWA\n         EJECT\n         COPY  CVTSO\n         EJECT\n         COPY  CVUSER\n         EJECT\nJCB      DS    0F\n         SPACE\n         COPY  JCBTSO\n         SPACE\n         ROUTBLE ,\n         MEND\n./ ADD NAME=COMMON,SSI=00009361\n         MACRO\n         COMMON\nCPAREA   DSECT\n         COPY  CVTSO\n         EJECT\n         COPY  CVUSER\n         EJECT\nJCB      DS    0F\n         SPACE\n         COPY  JCBTSO\n         SPACE\n         ROUTBLE ,\n         SPACE\n         COPY  CPTSO\n         EJECT\n         COPY  DSNWA\n         EJECT\n         MEND\n./ ADD NAME=COUNT\n         MACRO\n&LABEL   COUNT &VALUE,&REG=0,&INCR=\n.* COUNT IS USED TO ADD INCR TO VALUE AND STORE IT BACK\n.* REG IS USED AS THE REGISTER AND LOGICAL ADDS ARE DONE TO\n.*     AVOID ANY OVERFLOW OR CONDITION CODE PROBLEMS.\n.* IF THE INCR IS OMITTED, THEN CVONE IS USED TO INCR BY ONE\n.*     IN THE ADD INSTRUCTION.  OTHERWISE, A LITERAL IS USED.\n.* IT WILL WORK FOR A, F, OR H TYPE CONSTANTS WITH IMPLIED LENGTHS\n         LCLC  &H,&TP\n&TP      SETC  T'&VALUE           SET TP TO TYPE OF VALUE\n         AIF   ('&TP' EQ 'A' OR '&TP' EQ 'F').GO\n         AIF   ('&TP' EQ 'H').GOH\n         MNOTE 8,'TYPE OF &VALUE IS &TP -- NOT A, F, OR H'\n         MEXIT\n.GOH     ANOP\n&H       SETC  'H'\n.GO      ANOP\n&LABEL   L&H   &REG,&VALUE        LOAD OLD COUNT\n         AIF   ('&INCR' EQ '').CVINCR\n         AL    &REG,=F'&INCR'     ADD INCR TO THE COUNT\n         AGO   .DOSTORE\n.CVINCR  AL    &REG,CVONE          ADD ONE TO THE COUNT\n.DOSTORE ST&H  &REG,&VALUE        SAVE NEW COUNT\n         MEND\n./ ADD NAME=CPOLD,SSI=00009327\n* WYLTSO LINE EDITOR CONTROL PAGE\n         SPACE ,\n*                                                               JEP005\n*                                                               JEP005\n* MODIFIED AT DCEC TO INCORPORATE UPPER AND LOWER OPERANDS      JEP005\n* ON THE CHANGE CMD FOR CHANGING CASE OF TEXT.                  JEP005\n*                                                               JEP004\n*                                                               JEP004\n* MODIFIED AT DCEC TO ENABLE RECOGNITION OF 3277 TERMINALS.     JEP004\n* ACCOMPLISHED IN LFLG1. JERRY PITTENGER                        JEP004\n*                                                               JEP010\n*                                                               JEP010\n* MODIFIED AT DCEC TO ALLOW FOR FOUR LOCAL FLAGS (LFLG1-4).     JEP010\n*                                                               JEP001\n*                                                               JEP001\n* MODIFIED AT DCEC TO ALLOW FOR UP TO 7 CHAR. LOGON ID.         JEP001\n*                                                               JEP001\n*                                                               JEP017\n* MODIFIED AT DCEC TO DOUBLE THE EXEC FILE SIZE.                JEP017\n*                                                               JEP017\nCPSTART  DS    0D\nCPR13    DS    A                       REGISTERS\nCPR14    DS    A\nCPR15    DS    A\nCPR0     DS    A\nCPR1     DS    A\nCPR2     DS    A\nCPR3     DS    A\nCPR4     DS    A\nCPR5     DS    A\nCPR6     DS    A\nCPR7     DS    A\nCPR8     DS    A\n         SPACE 3\n* REMOTE TERMINAL BUFFER\n         SPACE ,\nRTBSTART DC    0F'0'\nRTBTABS  DC    XL8'00'             TABS\n         SPACE 2\nRTBMFL   DC    AL1(0)              MODE FLAG\n         SPACE ,\nRTBMFUC  EQU   X'80'               UPPER-CASE ONLY\nRTBMFNA  EQU   X'40'               NO WRITE ATTN\nRTBMFCL  EQU   X'20'               CLEAN LISTING\nRTBMFNTO EQU   X'10'               NO TABS IN OUTPUT\nRTBNOCR  EQU   X'08'               NO CARRIAGE RETURNS\nRTBNOTR  EQU   X'04'               NO TRANSLATE TABLE\nRTBWRAP  EQU   X'02'               CR/LF NEEDED FOR WRAPPING\nRTBCRT   EQU   X'01'               PAGING IS TO BE DONE\n         SPACE 2\nRTBSFL   DC    X'00'       STATUS FLAGS\n         SPACE ,\nRTBSFEND EQU   X'C0'       ENDING STATUS, 00=OK, 01=ATTN, 11=I/O ERROR\nRTBSFATN EQU   X'40'       ATTENTION\nRTBSFERR EQU   X'C0'       I/O ERROR\nRTBSFUST EQU   X'20'       UNSET TAB\nRTBSFBRK EQU   X'10'       ENDED BY BREAK\nRTBSFHU  EQU   X'08'       HUNG UP PHONE\n         SPACE ,\nRTBWC    DC    H'0'        WRITE COUNT\nRTBPC    DC    H'0'        PROMPT COUNT\nRTBRC    DC    H'0'        READ COUNT\n         SPACE ,\nRTBNTEXT EQU   168         SIZE OF TEXT BUFFER\nRTBPMAX  EQU   32          MAX LENGTH FOR PROMPT\n         SPACE ,\nRTBWAPTR DS    F           RTB WORK AREA POINTER (256 BYTES)\nRTBATNSZ EQU   0           2 BYTES: ATTN SEQ LENGTH\nRTBATTN  EQU   2           8 BYTES: ATTN SEQ\nRTBPSZ   EQU   10          2 BYTES: PAGE SIZE\nRTBLSZ   EQU   12          2 BYTES: LINE SIZE\nRTBLINE  EQU   14          2 BYTES: LINES PRINTED\nRTBCURS  EQU   16          2 BYTES: CHARS PRINTED\nRTBBSCNT EQU   18          2 BYTES: BS COUNTER FOR TABS\nRTBTRBUF EQU   20        168 BYTES: TRANSLATE BUFFER\nRTBPRMPT EQU   188        32 BYTES: REPROMPT BUFFER\nRTBSAVE  EQU   220         2 BYTES: SAVE BUFFER FOR CR/LF\n*        EQU   222        26 BYTES: STILL AVAILABLE\nRTBPAUS  EQU   248         8 BYTES: CRT PAUSE READ BUFFER\n         SPACE 2\nRTBUFL   DS    X\n         SPACE ,\nRTBUATTN EQU   X'80'       ATTN SEQUENCE EXISTS\nRTBUNCOL EQU   X'40'       AUTOMATIC COLLECT NOT HONORED\nRTBUPAD  EQU   X'20'       PAD WHEN LISTING NOCR\nRTBURELT EQU   X'10'       TABS ARE RELATIVE\nRTBUBACK EQU   X'08'       BACKSPACE IS A GOOD CHARACTER\nRTBUFAST EQU   X'04'       FASTLIST IN EFFECT\nRTBUTBUN EQU   X'02'       TABS ARE UNNUMBERED\n         SPACE ,\n         DS    3X          MORE SPACE AVAILABLE\n         DC    0F'0'     FULL WORD FOR ORVYL-WYLBUR\nRTBTEXT  DC    CL(RTBNTEXT)' ' TEXT BUFFER\n         DC    0F'0'\n         SPACE ,\nRTBSIZE  EQU   *-RTBSTART\n         SPACE 3\nCPRTBSZ  EQU   RTBSIZE                 SIZE OF RTB\nCPSCANSZ EQU   24                      SIZE OF SCAN AREA\nCPSCAN   DS    0F,(CPSCANSZ)X          SCANNER WORK AREA\n         SPACE ,\n* FOR THE TEXT-EDITOR\nCPGLDL   DS    1F   GLOBAL DELTA\nCPHIPS   DS    1F   HIGHEST POSITION YET REACHED  * MUST\nCPLNCT   DS    1H   LINE COUNT                    *STAY\nCPAGCT   DS    1H   PAGE COUNT                    * TOGETHER\nCPLNGTH  DS    1H   LINE LENGTH OPTION\n         SPACE 2\nCPGFLG   DS    1X      GLOBAL FLAG BYTE\n         SPACE ,\nCPFOPN   EQU   X'80'   EXTERNAL DATA SET OPEN FLAG\nCPFCMOFF EQU   X'40'   TERSE MODE FLAG FOR NORMAL MESSAGES\nCPFUPLW  EQU   X'20'   UPPER-LOWER CASE FLAG\nCPFVOLM  EQU   X'10'   DEFAULT VOLUME SET FLAG\nCPFDIRCH EQU   X'08'   DIRECTORY HAS CHANGED\nCPFRETRY EQU   X'04'   COMMAND RETRY GOING ON\nCPFRETOK EQU   X'02'   COMMAND RETRY CAN BE DONE\n         SPACE 2\nCPGFLG2  DS    1X      GLOBAL FLAG BYTE\n         SPACE ,\nCPFEXEC  EQU   X'80'   TAKE COMMANDS FROM EXEC FILE\nCPFNOLOG EQU   X'40'   DON'T LOG COMMANDS FROM EXEC FILE\nCPFEXTER EQU   X'20'   EXEC MODE TERSE FLAG\nCPSKNULL EQU   X'04'   SKIP CHARACTER IS NULL FLAG\nCPESNULL EQU   X'02'   ESCAPE CHARACTER IS NULL FLAG\n         SPACE ,\nCPDOUB   DS    1D   DOUBLE-WORD WORK\nCPHFWRD  DS    H    USED TO EXTEND CPDOUB TO 10 BYTES\nCPVOLSV  DS    CL6  DEFAULT VOLUME SAVE AREA\n         SPACE ,\nCPLSTCOL DS    1F   NEXT LINE NO. TO COLLECT\nCPDLTCOL DS    1F   DELTA FOR COLLECT\n         SPACE ,\nCPEXLINE DS    F    EXEC FILE LINE NUMBER\nCPEXHIPS DS    F    HIGHEST LINENO IN EXEC FILE   * MUST\nCPEXLNCT DS    H    EXEC FILE LINE COUNT          * STAY\nCPEXCNT  DS    H    COUNT OF PAGES IN EXEC FILE   * TOGETHER\nCPEXCMCT DS    H    EXEC COMMAND COUNT WITHOUT USING TYPEWRITER\n*PEXDIR  DS     5CL6   EXEC FILE DIRECTORY SPACE                JEP017\nCPEXDIR  DS   10CL6    EXEC FILE DIRECTORY SPACE                JEP017\nCPEXECMX EQU   (*-CPEXDIR)/6 MAX NO. OF PAGES IN EXEC FILE\n         SPACE ,\nCPCURRL  DS    F   CURRENT LINE POINTER\n         SPACE ,\nCPPFXL   DS    H                       LENGTH OF PREFIX\n         SPACE ,\nCPPFXSZ  EQU   36                      SIZE OF PREFIX AREA\nCPPFX    DS    CL(CPPFXSZ)             PREFIX AREA\n         SPACE ,\nCPUSER   DS    CL3                 SIGNED ON USER\nCPGRP    DS    CL5                 SIGNED ON GROUP              JEP001\nCPUSERSV DS    CL3                 SAVE USER ID FOR DSNAMES\nCPGRPSV  DS    CL5                 SAVE GROUP ID FOR DSNAMES    JEP001\nCPMEMBSV DS    CL8                 SAVE MEMBER NAME FOR DSNAMES\nCPSTCNT  DS    H                   STOWIT MOD COUNT FOR RECOVERY\nCPRCVSZ1 EQU   *-CPGLDL            SIZE OF RECOVERY INFO\n         EJECT\n* LOCAL ITEMS FOR COMMANDS\n         DS    0F\nCPCMNM   DS    XL3  FOR FIRST 3 BYTES OF CURRENT COMMAND NAME\n         SPACE 2\nCPLFLG1  DS    1X      FIRST LOCAL FLAG BYTE\n         SPACE ,\nCPFTMINF EQU   X'80'   SHOW INFO/TIME FLAG\nCPFNOTRG EQU   X'80'   \"NOT\" LOGIC FOR RANGE\nCPFCPY   EQU   X'20'   COPY FLAG\nCPFALL   EQU   X'10'   FLAG FOR DETRNG|-- DEFAULT ALL OKAY\nCPFUSCAT EQU   X'04'   USE CATALOG TO LOCATE VOLUME\nCPFTNOV  EQU   X'01'   NOVERIFY OF SET TABS\n         SPACE ,\n* NUMBER USAGE\nCPFNMOD  EQU   X'02'   REMAINDER IN TIMES OPTION\nCPFTIMES EQU   X'01'   TIMES OPTION FOR NUMBER\n         SPACE 2\nCPLFLG2  DS    1X      SECOND LOCAL FLAG BYTE\n         SPACE ,\nCPFMODCD EQU   X'80'   MODIFY MODE -- USED IN MODIFY/EDIT\nCPFSCRTC EQU   X'40'   SCRATCH FLAG (SAVE-SHOW DSNAMES)\nCPFDSNMS EQU   X'20'   NULL/NO DEFAULT OK ON DSNAMES FLAG\nCPFSING  EQU   X'10'   SINGLE PROMPT MODE -- MODIFY/EDIT\nCPFCLEAR EQU   X'10'   CLEAR ACTIVE FILE FLAG\nCPFCOMB  EQU   X'08'   COMBINE FLAG FOR COPY\nCPFMERG  EQU   X'04'   MERGE FLAG FOR COPY/MOVE/COLLECT\nCPFREP1  EQU   X'02'   REPLACE CONTROL FLAG\nCPFDITTO EQU   X'01'   DITTO CONTROL FLAG (REPLACE & INSERT)\nCPFSMALL EQU   X'01'   SMALL DATA SET SAVED (SAVE)\n         SPACE ,\n* EXEC USAGE\nCPFEXLNE EQU   X'08'   EXPLICIT LINENO WAS SPECIFIED\nCPFEXACT EQU   X'04'   EXEC ACTIVE WAS SPECIFIED\nCPFEXPA  EQU   X'02'   EXEC PAUSE WAS SPECIFIED\nCPFEXFR  EQU   X'01'   EXEC FROM WAS SPECIFIED\n         SPACE ,\n* CHANGE USAGE\nCPFCHLIM EQU   X'20'   STRING POSITIONALLY DELIMITED\nCPFCHDEL EQU   X'10'   REPLACING STRING VOID FLAG\nCPFCHNGD EQU   X'08'   SOMETHING CHANGED FLAG\nCPFLNCHN EQU   X'04'   AT LEAST 1 LINE CHANGED FLAG\nCPFCHPOS EQU   X'02'   POSITIONAL CHANGE\nCPFCHND  EQU   X'01'   TERMINATE CHANGE FLAG\n         SPACE ,\n* SHOW DSNAMES & CONSOLE MSGS USAGE\nCPFSTOP  EQU   X'01'   STOP 2741 LIST FLAG FOR DSNAMES & CONSOLE MSGS\n         SPACE ,\n* READ USAGE\nCPFRDNO  EQU   X'02'   LINE NUMBER FLAG FOR READ\nCPFRDEL  EQU   X'01'   DELETE LINE AFTER READ FLAG\n         SPACE ,\n* SHOW SIZE USAGE\nCPFFIRST EQU   X'01'   TURNS ON 'NOT FIRST TIME' FLAG\nCPFCOUNT EQU   X'02'   TURNS ON 'DONT DISPLAY COUNT FLAG'\n         SPACE 2\nCPLFLG3  DS    X       THIRD LOCAL FLAG BYTE\n         SPACE ,\nCPFSET   EQU   X'80'   SET PREFIX AFTER SCAN (USE-SAVE-COPY-SCR)\nCPFDSCLG EQU   X'40'   CATALOG DATA SET (SAVE AND MISC)\nCPFUNCLG EQU   X'20'   UNCATALOG DATA SET (SAVE AND MISC)\nCPFRECLG EQU   CPFDSCLG+CPFUNCLG  (SAVE AND MISC)\n         SPACE ,\n* SHOW DSNAMES/DIRECTORY USAGE\nCPFPROTF EQU   X'20'   PROTECT OPTION FLAG\nCPFDATED EQU   X'10'   DATED OPTION FLAG\nCPFEXCL  EQU   X'08'   EXCLUDE OPTION FLAG\nCPFSPACE EQU   X'04'   SPACE OPTION FLAG\nCPFTYPE  EQU   X'02'   TYPE/ALL OPTION FLAG (SHOW DSN/DIR RESP.)\n         SPACE ,\n* SHOW DSNAMES/DIRECTORY - PUT USAGE\nCPFPUT   EQU   X'01'   PUT IN ACTIVE FILE\nCPFNOL   EQU   X'40'   PUT AND DONT LIST\nCPFPUTER EQU   X'08'   ERROR IN STOWING\nCPFPMSG  EQU   X'80'   GAVE PAGE SHRTGE MSG ALREADY\n         SPACE ,\n* CHANGE USAGE\nCPFCHIN  EQU   X'80'   RANGE SPECIFIED\nCPFCHUS  EQU   X'40'   CHANGE USING\nCPFCHTO  EQU   X'20'   CHANGE TO\nCPFCHNM  EQU   X'10'   CHANGE TO NUMBERS\nCPFCHNMI EQU   X'08'   INCREMENT NUMBER FLAG\nCPFCHLN  EQU   X'04'   LINE OPTION\nCPFCHREP EQU   X'02'   REPEAT OPTION FOR USING RANGE\nCPFCHALL EQU   X'01'    CHANGE ALL COLS TO UPPER OR LOWER       JEP005\n         SPACE ,\n* LIST USAGE\nCPFCLEAN EQU   X'80'   CLEAN LIST\n         SPACE ,\n* CPLBYT1 & CPLBYT2 NO LONGER USED BY LIST OR CHANGE\n         SPACE 2\nCPLFLG4  DS    1X      FOURTH LOCAL FLAG BYTE\n         SPACE ,\nCPFSTSPL EQU   X'80'   PAGE SPLIT AT LINE NUMBER FLAG FOR STOWIT\nCPFSTINS EQU   X'40'   ALLOW INSERT ONLY FLAG FOR STOWIT\nCPFDESET EQU   X'20'   THIS FLAG SIGNALS TO DESPOT THAT THE\n*                      VALUE OF CPNWLN HAS BEEN SET FOR THE NEXT\n*                      LOCATE AND SHOULD NOT BE KICKED UP.\n         SPACE ,\nCPFDESRT EQU   X'10'   RE-ENTRY TO DESPOT -- DON'T RESET RANGE\n*                      THIS ALLOWS RUN TO HANDLE DISJOINT RANGES AND\n*                      COUNT RANGES PROPERLY BUT IT DOES PROHIBIT\n*                      OCCURRENCE COUNTS FOR ASSOCIATIVE RANGES\n*                      AS WELL AS RE-USE OF THE RANGE AFTER RETURN\n*                      FROM DESPOT\nCPFCHUP  EQU   X'08'   USED BY CHANGE TO UPPER                  JEP005\nCPFCHLO  EQU   X'04'   USED BY CHANGE TO LOWER                  JEP005\n         SPACE ,\nCPFNOCUR EQU   X'02'   NO ABORT IF CURRENT, NEXT, OR PREVIOUS\n*                      DO NOT EXIST\n         SPACE ,\nCPFNOINC EQU   X'01'   NO INCREMENT ON LINE NUMBERS\n         SPACE 2\nCPLFLG5  DS    1X   FIFTH LOCAL FLAG BYTE\n         SPACE ,\n* COMMON FLAG BITS OF CPLFLG5 USED BY MANY COMMANDS\nCPFUNUM  EQU   X'80'   UNNUMBERED FLAG\nCPFNTEX  EQU   X'40'   NOTEXT LISTING CONTROL FLAG\nCPFNONUM EQU   CPFUNUM+CPFNTEX NONUMBER LISTING CONTROL FLAG\nCPFNLST  EQU   X'20'   NOLIST LISTING CONTROL FLAG\nCPFFOPT  EQU   X'10'   SET IF ANY NUMBER OPTION SPECIFIED\nCPFINT   EQU   X'08'   EXPAND LINE NUMBERS AS INTEGERS FLAG\nCPFSELOC EQU   X'06'   RANGE SELECTION FLAG BITS\n*              X'00'   USE NORMAL ACTIVE FILE FOR RANGE\n*              X'02'   USE EXEC FILE FOR RANGE\n*              X'06'   USE EXTERNAL FILE FOR RANGE\nCPFSELEX EQU   X'02'   RANGE WILL BE SELECTED FROM EXEC FILE\nCPFNCUR  EQU   X'01'   DON'T CHANGE CURRENT LINE POINTER FLAG\n         SPACE 3\nLFLG1    DS    1X      *****LOCAL FLAG BYTE 1*****              JEP010\nCPF3277  EQU   X'01'        3277 RECOGNITION                    JEP004\nLFLG2    DS    1X      *****LOCAL FLAG BYTE 2*****              JEP010\nLFLG3    DS    1X      *****LOCAL FLAG BYTE 3*****              JEP010\nLFLG4    DS    1X      *****LOCAL FLAG BYTE 4*****              JEP010\n         SPACE 3                                                JEP010\n* CPDRPT - CPLCNO - CPREVLN SET BY LOCATE LINE ROUTINES\nCPDRPT   DS    1F      ADDR DIR ENTRY OF LOCATE PG (1ST BYTE=FLAGS)\n         SPACE ,\nCPFNTYT  EQU   X'80'   NOTHING AT ALL IN USER'S DATA SET YET\nCPFHIGH  EQU   X'40'   HIGHER THAN ANY LINE NO. IN USER'S DATA SET YET\nCPFPGHI  EQU   X'20'   GTR THAN ANY LINENO ON PG, LESS THAN 1ST ON NEXT\nCPFPGLW  EQU   X'10'   FIRST LINE ON PAGE\nCPFMTCH  EQU   X'08'   LINE NO. MATCHES EXACTLY A PRE-EXISTING ONE\nCPFFSLN  EQU   X'04'   LINE NO. LESS OR EQUAL FIRST OF ALL\nCPFPGND  EQU   X'02'   LINE WAS LAST ON A TEXT PAGE\nCPFNDDS  EQU   X'01'   LINE WAS LAST IN WORKING DATA SET\n         SPACE ,\nCPLCNO   DS    1F   INTERNAL LINE NUMBER OF LOCATED LINE\nCPREVLN  DS    1F   LINE NO. PREVIOUS TO LOCATED IF ON SAME TEXT PAGE\nCPDIRCNT DS    H    RESIDUAL PAGE COUNT AFTER LOCATE\nCPGDISP  DS    H    PAGE DISPLACEMENT TO LOCATED LINE\n         SPACE ,\n* DETRNG SETS CPFSLN-CPLSLN-CPSTLN-CPSTAD-CPCMPST-CPCMPLN-CPMDLN-CPMDAD\n         SPACE ,\nCPNWLN   DS    1F   USED BY DESPOT TO REMEMBER LINE NO. IT'S AT\nCPFSLN   DS    1F   1ST LINE NO. IN RANGE\nCPLSLN   DS    1F   LAST LINE NO. IN RANGE\nCPCMPST  DS    1F   DISPLACEMENT INTO LINE OF FIELD FOR MATCH\nCPCMPLN  DS    1F   LENGTH OF MATCH FIELD\nCPSTLN   DS    1F   0=EXPL RNG, POS=LEN ASSOC CHAR STR, NEG=BLANK LINES\nCPSTAD   DS    1F   ADDRESS OF CHAR STRING FOR ASSOCIATIVE RANGE\n         SPACE ,\n* FLAGS FOR CPSTAD (FIRST BYTE)\nCPFEXPRG EQU   X'80'   EXPLICIT RANGE FLAG\nCPFSTRRG EQU   X'40'   ASSOCIATIVE RANGE FLAG (OVER WHOLE LINE)\nCPFLIMRG EQU   X'20'   ASSOCIATIVE RANGE FLAG(OVER SPECIFIED POSITIONS)\nCPFONERG EQU   X'10'   START POSITION FOR STRING SPECIFIED FLAG\nCPFBLKRG EQU   X'08'   BLANK LINE RANGE FLAG\nCPFMODS  EQU   X'04'   MODS SPECIFIED FLAG\nCPFDSJNT EQU   X'02'   DISJOINT EXPLICIT RANGE FLAG\nCPFSOME  EQU   X'01'   NON-VOID RANGE FLAG\n         SPACE ,\n* CPMDLN & CPMDAD ALSO USED BY LOCATE AND SHOW COMMANDS\nCPMDLN   DS    1F   NO. OF MODS OR NO EXPLICIT LINE NOS IN RANGE (0-10)\nCPMDAD   DS    10F  THE MODS OR LINE NOS.\n         SPACE ,\n* CPDRED FOR USE, SAVE, COPY, RUN, PUNCH, LIST OFFLINE\nCPDRED   DS    2F   ADDRESS OF BUFFER FOR EXTERNAL DATA SETS\n*              FLAG USED IN CPDRED\nCPFSTART EQU   X'F0'   SIGNAL 1ST READ OR NOT\n         SPACE ,\n* CPWKPS & CPWKDL ARE USED WHERE REQUIRED\n         SPACE ,\nCPWKPS   DS    1F   WORK POSITION\nCPWKDL   DS    1F   WORK DELTA\n* AS USED DURING RANGE DETERMINATION\nCPTELL   EQU   CPWKPS   (CPWKPS & CPWKDL - USED IN RANGE DETERMINATION)\nCPRCVSZ2 EQU   *-CPDRPT\n         EJECT\n* WORK CELLS FOR LOCAL USE BY TEXT-EDITING COMMANDS\n         SPACE ,\nCPWK1    DS    1F   WORK CELLS\nCPWK2    DS    1F\nCPWK3    DS    1F\nCPWK4    DS    1F\nCPWK5    DS    1F\nCPWK6    DS    1F\n         SPACE ,\n* CPWK1, CPWK2 & CPWK3 USED BY LXCATE (EXTERNAL COPY)\n* CPWK4 USED BY MOVE & COPY\n* CPWK1, CPWK2 & CPWK3 USED BY SHOW OPERATOR\n* CPWK1 USED BY IMMEDIATE DELETE IN BWYL\n         SPACE ,\n* CPWK6 AS USED BY RUN, PUNCH, SAVE, AND USE\nCPSEQFLD EQU   CPWK6   START OF SEQ FIELD FOR NUMBERED\nCPSEQLN  EQU   CPWK6+2 LENGTH OF SEQ FIELD FOR NUMBERED\n         SPACE ,\n* AS USED BY \"CHANGE\"\n         SPACE ,\nCPCHCST  EQU   CPWK1   DISPLACEMENT IN LINE OF CHANGE TARGET FIELD\nCPCHCLN  EQU   CPWK2   LENGTH OF FIELD\nCPCHLN1  EQU   CPWK3   LENGTH OF STRING TO MATCH\nCPCHAD1  EQU   CPWK4   IT'S ADDRESS\nCPCHMOD  EQU   CPCHAD1 USE FIRST BYTE FOR OCCURRENCE COUNT\nCPCHLN2  EQU   CPWK5   LENGTH OF STRING TO USE AS REPLACE\nCPCHAD2  EQU   CPWK6   IT'S ADDRESS\n         SPACE ,\n* AS USED BY \"MOVE\" & \"COPY\"\nCPBGLN   EQU   CPWK5   1ST LINE NO. OF COPY-MOVE\nCPNDLN   EQU   CPWK6   START OF REPLACE/INTERLEAVE ON COPY-MOVE\n         SPACE ,\n* AS USED BY \"USE\" & \"SAVE\"\nCPLRCL   EQU   CPWK1   LRECL FOR USE-SAVE\nCPNREC   EQU   CPWK2   BLOCKING FACTOR FOR USE-SAVE\nCPRCSZ   EQU   CPWK3   BLOCKSIZE FOR USE-SAVE\nCPNXAD   EQU   CPWK4   WORK CELL FOR USE-SAVE\nCPNWCT   EQU   CPWK5   WORK CELL FOR USE-SAVE\n         SPACE ,\n* AS USED BY \"ALIGN\"\nCPNAWAPT EQU   CPWK1   WORK AREA ADDR FOR ALIGN\n         SPACE ,\n* AS USED BY \"READ\"\nCPWKRD   EQU   CPWK1   LINE NUMBER FOR READ COMMAND\n         SPACE ,\n* AS USED BY \"LIST/POINT\"\nCPSPAC   EQU   CPWK4\n* AS USED BY \"COLLECT\"\nCPNXPS   EQU   CPWK1   COMPARE HERE FOR INTERLEAVE OR OVERLAY\n         SPACE ,\n* AS USED BY \"EXEC\"\nCPEXLNET EQU   CPWK6   SPECIFIED LINE NO. FOR EXEC\n         SPACE ,\n* AS USED BY SHOW SIZE\nCPOVSIZE EQU   CPWK1   WORK CELL FOR SHOW SIZE\n         SPACE 3\nCPWORK1  DS    F\nCPWORK2  DS    F\n         SPACE 2\nCPSYSFLG DS    X\n         SPACE ,\nCPFRNGCM EQU   X'40'\nCPFTUSXC EQU   X'20'\nCPFNTYPD EQU   X'10'\n         SPACE ,\nCPPROTFL DS    X                   PERMIT FLAGS\n         SPACE ,\nCPSPARE  DS    1F   1 SPARE  (USED TO BE 2--1 TAKEN FOR FLAGS)  JEP010\n         SPACE ,\n* PRE-PROC INFO\nCPRSCNVL DS    H                   RESCAN VALUE\nCPESCAPE DS    X                   ESCAPE CHAR\nCPSKIP   DS    X                   SKIP CHAR\n         SPACE ,\nCPSAVE   DS    2A   SCAN SAVES PTRS LAST ITEM HERE\n         EJECT\nCPWA     DS    199F                    WORK AREA\n         SPACE ,\n* FIRST PART OF CPWA USED FOR DSNAME WORK AREA WHEN REQUIRED.\nCPDSNWA  EQU   CPWA                DSNAME WORK AREA\n         SPACE 2\nCPCTSAV  EQU   CPWA+600    WT-EDT COMMAND COUNT TEMP SAVE\nCPCMSAV  EQU   CPWA+604    WT-EDT COMMAND TEMP SAVE (NOT TYPED)\n* CPCTSAV & CPCMSAV USED BY EXEC TO KEEP UNPRESSED COMMANDS\n         SPACE ,\nCPCHECK  DC    X'6913723F'             CHECK FOR OVERFLOW\n         SPACE ,\nCPSIZE   EQU   1584                    SIZE OF CONTROL PAGE\n         SPACE ,\nCPTNPG   EQU   (CPAREA+2*CPSIZE-*)/6   TOTAL NO. OF DIRECTORY ENTRIES\n         SPACE ,\nCPDREC   DS    0X                      START OF DIRECTORY\nCPRCVSZ3 EQU   CPAREA+CPSIZE-CPDREC    1ST DIRECTORY SIZE\n         SPACE ,\n         ORG   CPSTART+2*CPSIZE\n./ ADD NAME=CPTSO\n* WYLTSO LINE EDITOR CONTROL PAGE\n         SPACE ,\n*                                                               JEP005\n*                                                               JEP005\n* MODIFIED AT DCEC TO INCORPORATE UPPER AND LOWER OPERANDS      JEP005\n* ON THE CHANGE CMD FOR CHANGING CASE OF TEXT.                  JEP005\n*                                                               JEP004\n*                                                               JEP004\n* MODIFIED AT DCEC TO ENABLE RECOGNITION OF 3277 TERMINALS.     JEP004\n* ACCOMPLISHED IN LFLG1. JERRY PITTENGER                        JEP004\n*                                                               JEP010\n*                                                               JEP010\n* MODIFIED AT DCEC TO ALLOW FOR FOUR LOCAL FLAGS (LFLG1-4).     JEP010\n*                                                               JEP001\n*                                                               JEP001\n* MODIFIED AT DCEC TO ALLOW FOR UP TO 7 CHAR. LOGON ID.         JEP001\n*                                                               JEP001\n*                                                               JEP017\n* MODIFIED AT DCEC TO DOUBLE THE EXEC FILE SIZE.                JEP017\n*                                                               JEP017\nCPSTART  DS    0D\nCPR13    DS    A                       REGISTERS\nCPR14    DS    A\nCPR15    DS    A\nCPR0     DS    A\nCPR1     DS    A\nCPR2     DS    A\nCPR3     DS    A\nCPR4     DS    A\nCPR5     DS    A\nCPR6     DS    A\nCPR7     DS    A\nCPR8     DS    A\n         SPACE 3\n* REMOTE TERMINAL BUFFER\n         SPACE ,\nRTBSTART DC    0F'0'\nRTBTABS  DC    XL8'00'             TABS\n         SPACE 2\nRTBMFL   DC    AL1(0)              MODE FLAG\n         SPACE ,\nRTBMFUC  EQU   X'80'               UPPER-CASE ONLY\nRTBMFNA  EQU   X'40'               NO WRITE ATTN\nRTBMFCL  EQU   X'20'               CLEAN LISTING\nRTBMFNTO EQU   X'10'               NO TABS IN OUTPUT\nRTBNOCR  EQU   X'08'               NO CARRIAGE RETURNS\nRTBNOTR  EQU   X'04'               NO TRANSLATE TABLE\nRTBWRAP  EQU   X'02'               CR/LF NEEDED FOR WRAPPING\nRTBCRT   EQU   X'01'               PAGING IS TO BE DONE\n         SPACE 2\nRTBSFL   DC    X'00'       STATUS FLAGS\n         SPACE ,\nRTBSFEND EQU   X'C0'       ENDING STATUS, 00=OK, 01=ATTN, 11=I/O ERROR\nRTBSFATN EQU   X'40'       ATTENTION\nRTBSFERR EQU   X'C0'       I/O ERROR\nRTBSFUST EQU   X'20'       UNSET TAB\nRTBSFBRK EQU   X'10'       ENDED BY BREAK\nRTBSFHU  EQU   X'08'       HUNG UP PHONE\n         SPACE ,\nRTBWC    DC    H'0'        WRITE COUNT\nRTBPC    DC    H'0'        PROMPT COUNT\nRTBRC    DC    H'0'        READ COUNT\n         SPACE ,\nRTBNTEXT EQU   168         SIZE OF TEXT BUFFER\nRTBPMAX  EQU   32          MAX LENGTH FOR PROMPT\n         SPACE ,\nRTBWAPTR DS    F           RTB WORK AREA POINTER (256 BYTES)\nRTBATNSZ EQU   0           2 BYTES: ATTN SEQ LENGTH\nRTBATTN  EQU   2           8 BYTES: ATTN SEQ\nRTBPSZ   EQU   10          2 BYTES: PAGE SIZE\nRTBLSZ   EQU   12          2 BYTES: LINE SIZE\nRTBLINE  EQU   14          2 BYTES: LINES PRINTED\nRTBCURS  EQU   16          2 BYTES: CHARS PRINTED\nRTBBSCNT EQU   18          2 BYTES: BS COUNTER FOR TABS\nRTBTRBUF EQU   20        168 BYTES: TRANSLATE BUFFER\nRTBPRMPT EQU   188        32 BYTES: REPROMPT BUFFER\nRTBSAVE  EQU   220         2 BYTES: SAVE BUFFER FOR CR/LF\n*        EQU   222        26 BYTES: STILL AVAILABLE\nRTBPAUS  EQU   248         8 BYTES: CRT PAUSE READ BUFFER\n         SPACE 2\nRTBUFL   DS    X\n         SPACE ,\nRTBUATTN EQU   X'80'       ATTN SEQUENCE EXISTS\nRTBUNCOL EQU   X'40'       AUTOMATIC COLLECT NOT HONORED\nRTBUPAD  EQU   X'20'       PAD WHEN LISTING NOCR\nRTBURELT EQU   X'10'       TABS ARE RELATIVE\nRTBUBACK EQU   X'08'       BACKSPACE IS A GOOD CHARACTER\nRTBUFAST EQU   X'04'       FASTLIST IN EFFECT\nRTBUTBUN EQU   X'02'       TABS ARE UNNUMBERED\n         SPACE ,\n         DS    3X          MORE SPACE AVAILABLE\n         DC    0F'0'     FULL WORD FOR ORVYL-WYLBUR\nRTBTEXT  DC    CL(RTBNTEXT)' ' TEXT BUFFER\n         DC    0F'0'\n         SPACE ,\nRTBSIZE  EQU   *-RTBSTART\n         SPACE 3\nCPRTBSZ  EQU   RTBSIZE                 SIZE OF RTB\nCPSCANSZ EQU   24                      SIZE OF SCAN AREA\nCPSCAN   DS    0F,(CPSCANSZ)X          SCANNER WORK AREA\n         SPACE ,\n* FOR THE TEXT-EDITOR\nCPGLDL   DS    1F   GLOBAL DELTA\nCPHIPS   DS    1F   HIGHEST POSITION YET REACHED  * MUST\nCPLNCT   DS    1H   LINE COUNT                    *STAY\nCPAGCT   DS    1H   PAGE COUNT                    * TOGETHER\nCPLNGTH  DS    1H   LINE LENGTH OPTION\n         SPACE 2\nCPGFLG   DS    1X      GLOBAL FLAG BYTE\n         SPACE ,\nCPFOPN   EQU   X'80'   EXTERNAL DATA SET OPEN FLAG\nCPFCMOFF EQU   X'40'   TERSE MODE FLAG FOR NORMAL MESSAGES\nCPFUPLW  EQU   X'20'   UPPER-LOWER CASE FLAG\nCPFVOLM  EQU   X'10'   DEFAULT VOLUME SET FLAG\nCPFDIRCH EQU   X'08'   DIRECTORY HAS CHANGED\nCPFRETRY EQU   X'04'   COMMAND RETRY GOING ON\nCPFRETOK EQU   X'02'   COMMAND RETRY CAN BE DONE\n         SPACE 2\nCPGFLG2  DS    1X      GLOBAL FLAG BYTE\n         SPACE ,\nCPFEXEC  EQU   X'80'   TAKE COMMANDS FROM EXEC FILE\nCPFNOLOG EQU   X'40'   DON'T LOG COMMANDS FROM EXEC FILE\nCPFEXTER EQU   X'20'   EXEC MODE TERSE FLAG\nCPSKNULL EQU   X'04'   SKIP CHARACTER IS NULL FLAG\nCPESNULL EQU   X'02'   ESCAPE CHARACTER IS NULL FLAG\n         SPACE ,\nCPDOUB   DS    1D   DOUBLE-WORD WORK\nCPHFWRD  DS    H    USED TO EXTEND CPDOUB TO 10 BYTES\nCPVOLSV  DS    CL6  DEFAULT VOLUME SAVE AREA\n         SPACE ,\nCPLSTCOL DS    1F   NEXT LINE NO. TO COLLECT\nCPDLTCOL DS    1F   DELTA FOR COLLECT\n         SPACE ,\nCPEXLINE DS    F    EXEC FILE LINE NUMBER\nCPEXHIPS DS    F    HIGHEST LINENO IN EXEC FILE   * MUST\nCPEXLNCT DS    H    EXEC FILE LINE COUNT          * STAY\nCPEXCNT  DS    H    COUNT OF PAGES IN EXEC FILE   * TOGETHER\nCPEXCMCT DS    H    EXEC COMMAND COUNT WITHOUT USING TYPEWRITER\n*PEXDIR  DS     5CL6   EXEC FILE DIRECTORY SPACE                JEP017\nCPEXDIR  DS   10CL6    EXEC FILE DIRECTORY SPACE                JEP017\nCPEXECMX EQU   (*-CPEXDIR)/6 MAX NO. OF PAGES IN EXEC FILE\n         SPACE ,\nCPCURRL  DS    F   CURRENT LINE POINTER\n         SPACE ,\nCPPFXL   DS    H                       LENGTH OF PREFIX\n         SPACE ,\nCPPFXSZ  EQU   36                      SIZE OF PREFIX AREA\nCPPFX    DS    CL(CPPFXSZ)             PREFIX AREA\n         SPACE ,\nCPUSER   DS    CL3                 SIGNED ON USER\nCPGRP    DS    CL5                 SIGNED ON GROUP              JEP001\nCPUSERSV DS    CL3                 SAVE USER ID FOR DSNAMES\nCPGRPSV  DS    CL5                 SAVE GROUP ID FOR DSNAMES    JEP001\nCPMEMBSV DS    CL8                 SAVE MEMBER NAME FOR DSNAMES\nCPSTCNT  DS    H                   STOWIT MOD COUNT FOR RECOVERY\nCPRCVSZ1 EQU   *-CPGLDL            SIZE OF RECOVERY INFO\n         EJECT\n* LOCAL ITEMS FOR COMMANDS\n         DS    0F\nCPCMNM   DS    XL3  FOR FIRST 3 BYTES OF CURRENT COMMAND NAME\n         SPACE 2\nCPLFLG1  DS    1X      FIRST LOCAL FLAG BYTE\n         SPACE ,\nCPFTMINF EQU   X'80'   SHOW INFO/TIME FLAG\nCPFNOTRG EQU   X'80'   \"NOT\" LOGIC FOR RANGE\nCPFCPY   EQU   X'20'   COPY FLAG\nCPFALL   EQU   X'10'   FLAG FOR DETRNG|-- DEFAULT ALL OKAY\nCPFUSCAT EQU   X'04'   USE CATALOG TO LOCATE VOLUME\nCPFTNOV  EQU   X'01'   NOVERIFY OF SET TABS\n         SPACE ,\n* NUMBER USAGE\nCPFNMOD  EQU   X'02'   REMAINDER IN TIMES OPTION\nCPFTIMES EQU   X'01'   TIMES OPTION FOR NUMBER\n         SPACE 2\nCPLFLG2  DS    1X      SECOND LOCAL FLAG BYTE\n         SPACE ,\nCPFMODCD EQU   X'80'   MODIFY MODE -- USED IN MODIFY/EDIT\nCPFSCRTC EQU   X'40'   SCRATCH FLAG (SAVE-SHOW DSNAMES)\nCPFDSNMS EQU   X'20'   NULL/NO DEFAULT OK ON DSNAMES FLAG\nCPFSING  EQU   X'10'   SINGLE PROMPT MODE -- MODIFY/EDIT\nCPFCLEAR EQU   X'10'   CLEAR ACTIVE FILE FLAG\nCPFCOMB  EQU   X'08'   COMBINE FLAG FOR COPY\nCPFMERG  EQU   X'04'   MERGE FLAG FOR COPY/MOVE/COLLECT\nCPFREP1  EQU   X'02'   REPLACE CONTROL FLAG\nCPFDITTO EQU   X'01'   DITTO CONTROL FLAG (REPLACE & INSERT)\nCPFSMALL EQU   X'01'   SMALL DATA SET SAVED (SAVE)\n         SPACE ,\n* EXEC USAGE\nCPFEXLNE EQU   X'08'   EXPLICIT LINENO WAS SPECIFIED\nCPFEXACT EQU   X'04'   EXEC ACTIVE WAS SPECIFIED\nCPFEXPA  EQU   X'02'   EXEC PAUSE WAS SPECIFIED\nCPFEXFR  EQU   X'01'   EXEC FROM WAS SPECIFIED\n         SPACE ,\n* CHANGE USAGE\nCPFCHLIM EQU   X'20'   STRING POSITIONALLY DELIMITED\nCPFCHDEL EQU   X'10'   REPLACING STRING VOID FLAG\nCPFCHNGD EQU   X'08'   SOMETHING CHANGED FLAG\nCPFLNCHN EQU   X'04'   AT LEAST 1 LINE CHANGED FLAG\nCPFCHPOS EQU   X'02'   POSITIONAL CHANGE\nCPFCHND  EQU   X'01'   TERMINATE CHANGE FLAG\n         SPACE ,\n* SHOW DSNAMES & CONSOLE MSGS USAGE\nCPFSTOP  EQU   X'01'   STOP 2741 LIST FLAG FOR DSNAMES & CONSOLE MSGS\n         SPACE ,\n* READ USAGE\nCPFRDNO  EQU   X'02'   LINE NUMBER FLAG FOR READ\nCPFRDEL  EQU   X'01'   DELETE LINE AFTER READ FLAG\n         SPACE ,\n* SHOW SIZE USAGE\nCPFFIRST EQU   X'01'   TURNS ON 'NOT FIRST TIME' FLAG\nCPFCOUNT EQU   X'02'   TURNS ON 'DONT DISPLAY COUNT FLAG'\n         SPACE 2\nCPLFLG3  DS    X       THIRD LOCAL FLAG BYTE\n         SPACE ,\nCPFSET   EQU   X'80'   SET PREFIX AFTER SCAN (USE-SAVE-COPY-SCR)\nCPFDSCLG EQU   X'40'   CATALOG DATA SET (SAVE AND MISC)\nCPFUNCLG EQU   X'20'   UNCATALOG DATA SET (SAVE AND MISC)\nCPFRECLG EQU   CPFDSCLG+CPFUNCLG  (SAVE AND MISC)\n         SPACE ,\n* SHOW DSNAMES/DIRECTORY USAGE\nCPFPROTF EQU   X'20'   PROTECT OPTION FLAG\nCPFDATED EQU   X'10'   DATED OPTION FLAG\nCPFEXCL  EQU   X'08'   EXCLUDE OPTION FLAG\nCPFSPACE EQU   X'04'   SPACE OPTION FLAG\nCPFTYPE  EQU   X'02'   TYPE/ALL OPTION FLAG (SHOW DSN/DIR RESP.)\n         SPACE ,\n* SHOW DSNAMES/DIRECTORY - PUT USAGE\nCPFPUT   EQU   X'01'   PUT IN ACTIVE FILE\nCPFNOL   EQU   X'40'   PUT AND DONT LIST\nCPFPUTER EQU   X'08'   ERROR IN STOWING\nCPFPMSG  EQU   X'80'   GAVE PAGE SHRTGE MSG ALREADY\n         SPACE ,\n* CHANGE USAGE\nCPFCHIN  EQU   X'80'   RANGE SPECIFIED\nCPFCHUS  EQU   X'40'   CHANGE USING\nCPFCHTO  EQU   X'20'   CHANGE TO\nCPFCHNM  EQU   X'10'   CHANGE TO NUMBERS\nCPFCHNMI EQU   X'08'   INCREMENT NUMBER FLAG\nCPFCHLN  EQU   X'04'   LINE OPTION\nCPFCHREP EQU   X'02'   REPEAT OPTION FOR USING RANGE\nCPFCHALL EQU   X'01'    CHANGE ALL COLS TO UPPER OR LOWER       JEP005\n         SPACE ,\n* LIST USAGE\nCPFCLEAN EQU   X'80'   CLEAN LIST\n         SPACE ,\n* CPLBYT1 & CPLBYT2 NO LONGER USED BY LIST OR CHANGE\n         SPACE 2\nCPLFLG4  DS    1X      FOURTH LOCAL FLAG BYTE\n         SPACE ,\nCPFSTSPL EQU   X'80'   PAGE SPLIT AT LINE NUMBER FLAG FOR STOWIT\nCPFSTINS EQU   X'40'   ALLOW INSERT ONLY FLAG FOR STOWIT\nCPFDESET EQU   X'20'   THIS FLAG SIGNALS TO DESPOT THAT THE\n*                      VALUE OF CPNWLN HAS BEEN SET FOR THE NEXT\n*                      LOCATE AND SHOULD NOT BE KICKED UP.\n         SPACE ,\nCPFDESRT EQU   X'10'   RE-ENTRY TO DESPOT -- DON'T RESET RANGE\n*                      THIS ALLOWS RUN TO HANDLE DISJOINT RANGES AND\n*                      COUNT RANGES PROPERLY BUT IT DOES PROHIBIT\n*                      OCCURRENCE COUNTS FOR ASSOCIATIVE RANGES\n*                      AS WELL AS RE-USE OF THE RANGE AFTER RETURN\n*                      FROM DESPOT\nCPFCHUP  EQU   X'08'   USED BY CHANGE TO UPPER                  JEP005\nCPFCHLO  EQU   X'04'   USED BY CHANGE TO LOWER                  JEP005\n         SPACE ,\nCPFNOCUR EQU   X'02'   NO ABORT IF CURRENT, NEXT, OR PREVIOUS\n*                      DO NOT EXIST\n         SPACE ,\nCPFNOINC EQU   X'01'   NO INCREMENT ON LINE NUMBERS\n         SPACE 2\nCPLFLG5  DS    1X   FIFTH LOCAL FLAG BYTE\n         SPACE ,\n* COMMON FLAG BITS OF CPLFLG5 USED BY MANY COMMANDS\nCPFUNUM  EQU   X'80'   UNNUMBERED FLAG\nCPFNTEX  EQU   X'40'   NOTEXT LISTING CONTROL FLAG\nCPFNONUM EQU   CPFUNUM+CPFNTEX NONUMBER LISTING CONTROL FLAG\nCPFNLST  EQU   X'20'   NOLIST LISTING CONTROL FLAG\nCPFFOPT  EQU   X'10'   SET IF ANY NUMBER OPTION SPECIFIED\nCPFINT   EQU   X'08'   EXPAND LINE NUMBERS AS INTEGERS FLAG\nCPFSELOC EQU   X'06'   RANGE SELECTION FLAG BITS\n*              X'00'   USE NORMAL ACTIVE FILE FOR RANGE\n*              X'02'   USE EXEC FILE FOR RANGE\n*              X'06'   USE EXTERNAL FILE FOR RANGE\nCPFSELEX EQU   X'02'   RANGE WILL BE SELECTED FROM EXEC FILE\nCPFNCUR  EQU   X'01'   DON'T CHANGE CURRENT LINE POINTER FLAG\n         SPACE 3\nLFLG1    DS    1X      *****LOCAL FLAG BYTE 1*****              JEP010\nCPF3277  EQU   X'01'        3277 RECOGNITION                    JEP004\nLFLG2    DS    1X      *****LOCAL FLAG BYTE 2*****              JEP010\nLFLG3    DS    1X      *****LOCAL FLAG BYTE 3*****              JEP010\nLFLG4    DS    1X      *****LOCAL FLAG BYTE 4*****              JEP010\n         SPACE 3                                                JEP010\n* CPDRPT - CPLCNO - CPREVLN SET BY LOCATE LINE ROUTINES\nCPDRPT   DS    1F      ADDR DIR ENTRY OF LOCATE PG (1ST BYTE=FLAGS)\n         SPACE ,\nCPFNTYT  EQU   X'80'   NOTHING AT ALL IN USER'S DATA SET YET\nCPFHIGH  EQU   X'40'   HIGHER THAN ANY LINE NO. IN USER'S DATA SET YET\nCPFPGHI  EQU   X'20'   GTR THAN ANY LINENO ON PG, LESS THAN 1ST ON NEXT\nCPFPGLW  EQU   X'10'   FIRST LINE ON PAGE\nCPFMTCH  EQU   X'08'   LINE NO. MATCHES EXACTLY A PRE-EXISTING ONE\nCPFFSLN  EQU   X'04'   LINE NO. LESS OR EQUAL FIRST OF ALL\nCPFPGND  EQU   X'02'   LINE WAS LAST ON A TEXT PAGE\nCPFNDDS  EQU   X'01'   LINE WAS LAST IN WORKING DATA SET\n         SPACE ,\nCPLCNO   DS    1F   INTERNAL LINE NUMBER OF LOCATED LINE\nCPREVLN  DS    1F   LINE NO. PREVIOUS TO LOCATED IF ON SAME TEXT PAGE\nCPDIRCNT DS    H    RESIDUAL PAGE COUNT AFTER LOCATE\nCPGDISP  DS    H    PAGE DISPLACEMENT TO LOCATED LINE\n         SPACE ,\n* DETRNG SETS CPFSLN-CPLSLN-CPSTLN-CPSTAD-CPCMPST-CPCMPLN-CPMDLN-CPMDAD\n         SPACE ,\nCPNWLN   DS    1F   USED BY DESPOT TO REMEMBER LINE NO. IT'S AT\nCPFSLN   DS    1F   1ST LINE NO. IN RANGE\nCPLSLN   DS    1F   LAST LINE NO. IN RANGE\nCPCMPST  DS    1F   DISPLACEMENT INTO LINE OF FIELD FOR MATCH\nCPCMPLN  DS    1F   LENGTH OF MATCH FIELD\nCPSTLN   DS    1F   0=EXPL RNG, POS=LEN ASSOC CHAR STR, NEG=BLANK LINES\nCPSTAD   DS    1F   ADDRESS OF CHAR STRING FOR ASSOCIATIVE RANGE\n         SPACE ,\n* FLAGS FOR CPSTAD (FIRST BYTE)\nCPFEXPRG EQU   X'80'   EXPLICIT RANGE FLAG\nCPFSTRRG EQU   X'40'   ASSOCIATIVE RANGE FLAG (OVER WHOLE LINE)\nCPFLIMRG EQU   X'20'   ASSOCIATIVE RANGE FLAG(OVER SPECIFIED POSITIONS)\nCPFONERG EQU   X'10'   START POSITION FOR STRING SPECIFIED FLAG\nCPFBLKRG EQU   X'08'   BLANK LINE RANGE FLAG\nCPFMODS  EQU   X'04'   MODS SPECIFIED FLAG\nCPFDSJNT EQU   X'02'   DISJOINT EXPLICIT RANGE FLAG\nCPFSOME  EQU   X'01'   NON-VOID RANGE FLAG\n         SPACE ,\n* CPMDLN & CPMDAD ALSO USED BY LOCATE AND SHOW COMMANDS\nCPMDLN   DS    1F   NO. OF MODS OR NO EXPLICIT LINE NOS IN RANGE (0-10)\nCPMDAD   DS    10F  THE MODS OR LINE NOS.\n         SPACE ,\n* CPDRED FOR USE, SAVE, COPY, RUN, PUNCH, LIST OFFLINE\nCPDRED   DS    2F   ADDRESS OF BUFFER FOR EXTERNAL DATA SETS\n*              FLAG USED IN CPDRED\nCPFSTART EQU   X'F0'   SIGNAL 1ST READ OR NOT\n         SPACE ,\n* CPWKPS & CPWKDL ARE USED WHERE REQUIRED\n         SPACE ,\nCPWKPS   DS    1F   WORK POSITION\nCPWKDL   DS    1F   WORK DELTA\n* AS USED DURING RANGE DETERMINATION\nCPTELL   EQU   CPWKPS   (CPWKPS & CPWKDL - USED IN RANGE DETERMINATION)\nCPRCVSZ2 EQU   *-CPDRPT\n         EJECT\n* WORK CELLS FOR LOCAL USE BY TEXT-EDITING COMMANDS\n         SPACE ,\nCPWK1    DS    1F   WORK CELLS\nCPWK2    DS    1F\nCPWK3    DS    1F\nCPWK4    DS    1F\nCPWK5    DS    1F\nCPWK6    DS    1F\n         SPACE ,\n* CPWK1, CPWK2 & CPWK3 USED BY LXCATE (EXTERNAL COPY)\n* CPWK4 USED BY MOVE & COPY\n* CPWK1, CPWK2 & CPWK3 USED BY SHOW OPERATOR\n* CPWK1 USED BY IMMEDIATE DELETE IN BWYL\n         SPACE ,\n* CPWK6 AS USED BY RUN, PUNCH, SAVE, AND USE\nCPSEQFLD EQU   CPWK6   START OF SEQ FIELD FOR NUMBERED\nCPSEQLN  EQU   CPWK6+2 LENGTH OF SEQ FIELD FOR NUMBERED\n         SPACE ,\n* AS USED BY \"CHANGE\"\n         SPACE ,\nCPCHCST  EQU   CPWK1   DISPLACEMENT IN LINE OF CHANGE TARGET FIELD\nCPCHCLN  EQU   CPWK2   LENGTH OF FIELD\nCPCHLN1  EQU   CPWK3   LENGTH OF STRING TO MATCH\nCPCHAD1  EQU   CPWK4   IT'S ADDRESS\nCPCHMOD  EQU   CPCHAD1 USE FIRST BYTE FOR OCCURRENCE COUNT\nCPCHLN2  EQU   CPWK5   LENGTH OF STRING TO USE AS REPLACE\nCPCHAD2  EQU   CPWK6   IT'S ADDRESS\n         SPACE ,\n* AS USED BY \"MOVE\" & \"COPY\"\nCPBGLN   EQU   CPWK5   1ST LINE NO. OF COPY-MOVE\nCPNDLN   EQU   CPWK6   START OF REPLACE/INTERLEAVE ON COPY-MOVE\n         SPACE ,\n* AS USED BY \"USE\" & \"SAVE\"\nCPLRCL   EQU   CPWK1   LRECL FOR USE-SAVE\nCPNREC   EQU   CPWK2   BLOCKING FACTOR FOR USE-SAVE\nCPRCSZ   EQU   CPWK3   BLOCKSIZE FOR USE-SAVE\nCPNXAD   EQU   CPWK4   WORK CELL FOR USE-SAVE\nCPNWCT   EQU   CPWK5   WORK CELL FOR USE-SAVE\n         SPACE ,\n* AS USED BY \"ALIGN\"\nCPNAWAPT EQU   CPWK1   WORK AREA ADDR FOR ALIGN\n         SPACE ,\n* AS USED BY \"READ\"\nCPWKRD   EQU   CPWK1   LINE NUMBER FOR READ COMMAND\n         SPACE ,\n* AS USED BY \"LIST/POINT\"\nCPSPAC   EQU   CPWK4\n* AS USED BY \"COLLECT\"\nCPNXPS   EQU   CPWK1   COMPARE HERE FOR INTERLEAVE OR OVERLAY\n         SPACE ,\n* AS USED BY \"EXEC\"\nCPEXLNET EQU   CPWK6   SPECIFIED LINE NO. FOR EXEC\n         SPACE ,\n* AS USED BY SHOW SIZE\nCPOVSIZE EQU   CPWK1   WORK CELL FOR SHOW SIZE\n         SPACE 3\nCPWORK1  DS    F\nCPWORK2  DS    F\n         SPACE 2\nCPSYSFLG DS    X\n         SPACE ,\nCPFRNGCM EQU   X'40'\nCPFTUSXC EQU   X'20'\nCPFNTYPD EQU   X'10'\n         SPACE ,\nCPPROTFL DS    X                   PERMIT FLAGS\n         SPACE ,\nCPSPARE  DS    1F   1 SPARE  (USED TO BE 2--1 TAKEN FOR FLAGS)  JEP010\n         SPACE ,\n* PRE-PROC INFO\nCPRSCNVL DS    H                   RESCAN VALUE\nCPESCAPE DS    X                   ESCAPE CHAR\nCPSKIP   DS    X                   SKIP CHAR\n         SPACE ,\nCPSAVE   DS    2A   SCAN SAVES PTRS LAST ITEM HERE\n         EJECT\nCPWA     DS    199F                    WORK AREA\n         SPACE ,\n* FIRST PART OF CPWA USED FOR DSNAME WORK AREA WHEN REQUIRED.\nCPDSNWA  EQU   CPWA                DSNAME WORK AREA\n         SPACE 2\nCPCTSAV  EQU   CPWA+600    WT-EDT COMMAND COUNT TEMP SAVE\nCPCMSAV  EQU   CPWA+604    WT-EDT COMMAND TEMP SAVE (NOT TYPED)\n* CPCTSAV & CPCMSAV USED BY EXEC TO KEEP UNPRESSED COMMANDS\n         SPACE ,\nCPCHECK  DC    X'6913723F'             CHECK FOR OVERFLOW\n         SPACE ,\nCPSIZE   EQU   3016   1952 1584        SIZE OF CONTROL PAGE\n         SPACE ,\nCPTNPG   EQU   (CPAREA+2*CPSIZE-*)/6   TOTAL NO. OF DIRECTORY ENTRIES\n         SPACE ,\nCPDREC   DS    0X                      START OF DIRECTORY\nCPRCVSZ3 EQU   CPSTART+CPSIZE-CPDREC   1ST DIRECTORY SIZE\n         SPACE ,\n         ORG   CPSTART+2*CPSIZE\n./ ADD NAME=CUCCCVT\n         MACRO\n         CUCCCVT\n         SPACE 2\n*******************************************************************C511\n*                                                                 *C511\n*        THE CUCC CVT EXTENSION IS POINTED TO BY                  *C511\n*           THE CVTUSER FIELD IN THE CVT, AND                     *C511\n*           IS PART OF THE NUCLEUS.  IT CONTAINS                  *C511\n*           10 FULLWORDS.\n*                                                                 *C511\n*******************************************************************C511\n         SPACE  , -                                                C511\nCUCCCVT  DS    0F\nCVTNUCH1 DC    F'0' -              ADDRESS OF H1 PART OF NUCLEUS   C511\nCVTCBECB DC    F'0' -              CRBEWTR ECB                     C511\nCVTWRPRM DC    F'0' -              CRBEWTR PARM LIST               C511\nCVTDYNDS DC    F'0' -              DYNAMIC DISPATCHING PARM PTR    C511\nCVTACCTQ DC    F'0' -              REQUEST QUEUE FOR ACCTING TASK  C511\nCVTTVT   DC    F'0' -              ADDRESS OF ASP TVT              C511\nCVTCALL  DC    F'0' -              POINTER TO T#GTAB               C511\nCVTVOLS  DC    F'0' -     PROTECTION VOLLIST AND BATCH/TSO\nCVTPRTSO  EQU    X'80'      TSO BIT ON => TSO SUPPORT\nCVTPRBAT  EQU    X'40'      BATCH BIT ON => BATCH SUPPORT\nCVTTESTT  EQU    X'20'    TEST => NOT ENFORCED IN TSOBUT INDICATE VIOL\nCVTTESTB  EQU    X'10'    TEST=> NOT ENFORCED IN BATCH..INDICATE VIOL\nCVTUSERS DC    F'0' -     PROTECTION CODE PRIVED USER LIST\nCVTDSNS  DC    F'0' -     PROTECTION PROTECTED DSNS\n         SPACE 2\n         MEND\n./ ADD NAME=CVCALL\n         MACRO\n&L       CVCALL &R,&PFREE\n         GBLC  &PAGECDE\n         LCLC  &C\n         AIF   (K'&R LE 6).NOSCH\n         AIF   ('&R' EQ 'ABSCENT').ABSCENT\n         AIF   ('&R' EQ 'DOCLEAR').DOCLEAR\n         AIF   ('&R' EQ 'DSNAMED').DSNAMED\n         AIF   ('&R' EQ 'HASPSTAT').HSTAT\n         AIF   ('&R' EQ 'INVALID').INVALID\n         AIF   ('&R' EQ 'OPWRITE').OPWRITE\n         AIF   ('&R' EQ 'SETPFXNS').SPFXNS\n         AIF   ('&R' EQ 'TWRITEX').TWRITEX\n         AIF   ('&R' EQ 'UNLEGAL').UNLEGAL\n         AIF   ('&R' EQ 'VOLCHEK').VOLCHEK\n.NOSCH   ANOP\n&C       SETC  '&R'(1,6)           USE ONLY FIRST 6 CHARACTERS\n         AGO   .GO\n.ABSCENT ANOP\n&C       SETC  'ABSCNT'\n         AGO   .GO\n.DOCLEAR ANOP\n&C       SETC  'DOCLR'\n         AGO   .GO\n.DSNAMED ANOP\n&C       SETC  'DSNMED'\n         AGO   .GO\n.HSTAT   ANOP\n&C       SETC  'HSTAT'\n         AGO   .GO\n.INVALID ANOP\n&C       SETC  'INVAL'\n         AGO   .GO\n.OPWRITE ANOP\n&C       SETC  'OPWRT'\n         AGO   .GO\n.RDEDCH  ANOP\n         AGO   .GO\n.SPFXNS  ANOP\n&C       SETC  'SPFXNS'\n         AGO   .GO\n.TWRITEX ANOP\n&C       SETC  'TWRTX'\n         AGO   .GO\n.UNLEGAL ANOP\n&C       SETC  'UNLEG'\n         AGO   .GO\n.VOLCHEK ANOP\n&C       SETC  'VOLCHK'\n.GO      ANOP\n&L       L     14,CV&C\n         BALR  14,14\n         MEND\n./ ADD NAME=CVTSO    0100-79354-79354-0303-00197-00197-00000-TEC015  00\n         SPACE ,\n* WYLTSO COMMUNICATION VECTOR\n         SPACE ,\n*                                                               JEP001\n*                                                               JEP001\n* MOD JEP001                                                    JEP001\n*  USED 1 OF THE CVSPARES FOR NAMING CONV. DENOTED JEP001       JEP001\n*                                                               JEP001\n*                                                               JEP016\n*                                                               JEP016\n* MOD JEP016                                                    JEP016\n*  USED 3 OF THE CVSPARES FOR REENTERABILITY. DENOTED JEP016    JEP016\n*   ALSO CHANGED SOME CODE TO MAKE REENTRANT. DENOTED JEP016    JEP016\n*                                                               JEP012\n*                                                               JEP012\n* MOD JEP012                                                    JEP012\n*  ADDED VCON FOR STAX ADDRESS USED IN RUN COMMAND.             JEP012\n*   DENOTED JEP012                                              JEP012\n*                                                               JEP012\nCVSTART  DS    0F\n         SPACE 3\n* COMMON COMMAND EXIT ROUTINES\n         SPACE ,\nCVGETCOM L     14,CVCMDPRT\n         BR    14\n         SPACE ,\nCVQTYPE  L     14,CVQTYPED\n         BR    14\n         SPACE ,\nCVNVALID L     14,CVINVAL\n         BR    14\n         SPACE ,\nCVUNLEGL L     14,CVUNLEG\n         BR    14\n         SPACE ,\nCVABSENT L     14,CVABSCNT\n         BR    14\n         SPACE 3\n* COMMON SUBROUTINE CALL ADDRESSES\n         SPACE ,\nCVABSCNT DC    V(ABSCENT)     XCALL\nCVADDER  DC    V(ADDER)       XCALL\nCVBTD    DC    V(BTD)         CALLED BY BTD\nCVBTX    DC    V(BTX)         CALLED BY BTX\nCVCMDPRT DC    V(CMDPRT)      XCALL\nCVCVEXNO DC    V(CVEXNO)      XCALL\nCVDCLOSE DC    V(DCLOSE)      CALLED BY DCLOSE/HCLOSE\nCVDESPOT DC    V(DESPOT)      XCALL\nCVDETRNG DC    V(DETRNG)      XCALL\nCVDOCLR  DC    V(DOCLEAR)     XCALL\nCVDODELE DC    V(DODELE)      XCALL\nCVDODSNM DC    V(DODSNM)      XCALL\nCVDOPEN  DC    V(DOPEN)       CALLED BY DOPEN/DSCRATCH\nCVDQSCAN DC    V(DQSCAN)      XCALL\nCVDREAD  DC    V(DREAD)       CALLED BY DREAD\nCVDSNMED DC    V(DSNAMED)     XCALL\nCVDWRITE DC    V(DWRITE)      CALLED BY DWRITE\nCVINVAL  DC    V(INVALID)     XCALL\nCVLENCHK DC    V(LENCHK)      XCALL\nCVNTGDOP DC    V(NTGDOPN)     XCALL\nCVOPWRT  DC    V(OPWRITE)     CALLED BY OPWRITE\nCVPFREE  DC    V(PFREE)       CALLED BY PFREE\nCVPGET   DC    V(PGET)        CALLED BY PGET\nCVPJUNK  DC    V(PJUNK)\nCVIOWA   DS    A              ADDR OF GETMAINED CORE\nCVPMARK  DC    V(PMARK)       CALLED BY PMARK\nCVPNUM   DC    V(PNUM)        CALLED BY PNUM\nCVPRESS  DC    V(PRESS)       XCALL\nCVQTYPED DC    V(QTYPED)      XCALL\nCVSCAN   DC    V(SCAN)        CALLED BY SCAN\nCVSCINIT DC    V(SCINIT)      CALLED BY SCINIT\nCVSCTELL DC    V(SCTELL)      CALLED BY SCTELL\nCVSPFXNS DC    V(SETPFXNS)    XCALL\nCVSTOWIT DC    V(STOWIT)      XCALL\nCVTRDRTN DC    V(TRDRTN)      CALLED BY TATNRDR/TREADR\nCVTMARKX DC    V(TMARKX)      CALLED BY TMARK\nCVTREADX DC    V(TREADX)      CALLED BY TREAD/TREDE\nCVTSEGXB DC    V(TSEGXB)      CALLED BY TSEG\nCVTSEGXM DC    V(TSEGXM)      CALLED BY TSEG\nCVTSEGXW DC    V(TSEGXW)      CALLED BY TSEG\nCVTSEGX  DC    V(TSEGX)       CALLED BY TSEG\nCVTWRTX  DC    V(TWRITEX)     CALLED BY TWRITE\nCVUNLEG  DC    V(UNLEGAL)     XCALL\nCVUNPRES DC    V(UNPRESS)     XCALL\nCVVOLCHK DC    V(VOLCHEK)     XCALL\nCVYESREQ DC    V(YESREQ)      XCALL\nCVLISTLI DC    V(LISTLINE)    XCALL\nCVCLRTST DC    V(CLRTST)      XCALL\nCVCLEARC DC    V(CLEARCK)     XCALL\nCVITSNIL DC    V(ITSNIL)      XCALL\nCVSETPRM DC    V(SETPRMPT)    XCALL\nCVLOWMUL DC    V(LOWMULT)     XCALL\nCVLOCLIS DC    V(LOCLIST)     XCALL\nCVLOCATE DC    V(LOCATE)\nCVLSLNMS DC    V(LSLNMSG)     XCALL\nCVSELDEL DC    V(SELDELTA)    XCALL\nCVSCNEXF DC    V(SCNEXFR)     XCALL\nCVMEMBER DC    V(MEMBERED)    XCALL\nCVDATE   DC    V(DATE)        XCALL\nCVNOMORP DC    V(NOMORPG)     XCALL\nCVFIXNUM DC    V(FIXNUMB)     XCALL\nCVNOTMYD DC    V(NOTMYDS)     XCALL\nCVCTLGED DC    V(CTLGED)      XCALL\nCVATNRTN DC    V(ATTNRTN)     ATTENTION TRAP ROUTIONE FOR STAX\nCVPARM   DC    A(0)           PARAMETER POINTER PASSED\nCVFMTIME DC    V(FMTTIME)     PROC RTN TO FORMAT DATE&TIME\nCVPIOB   DC    A(0)           RECOVERY IOB ADDRESS\nCVPIO    DC    V(PAGEIO)      ADDRESS OF DO PAGE I/O IN WCP\nCVGOSAV  DC    V(GOSAVE)      ADDRESS OF SAVE COMMAND\nCVDOCLRX DC    V(DOCLREX)     CLEAR EXEC ROUTINE\nCVTIME   DC    V(TIME)        FORMAT TIME ROUTINE\nCVLNENO  DC    V(LNENOPRT)    POINTER TO LINE NO PRT\nCVLTNPR  DC    V(LTNPRT)      POINTER TO LIST OPTIONS PRT\nCVCLRPR  DC    V(CLRPRT)      POINTER TO CLEAR OPTIONS PRT\nCVPSYNAD DC    V(PSYNAD)      SYNAD EXIT FOR PAGE WRITES\nCVDSNSTD DC    V(DSNSTDDO)    STANDARD DSN CHECK\nCVDSNUDS DC    V(DSNUDSDO)    SET DSN POSSESSION FLAGS\nCVNUMPR  DC    V(NUMPRT)      PRT FOR NUMBER OPTIONS\nCVVOLCH  DC    V(VOLCHKNL)    VOL CHECK WITH R1 SET\nCVSHOVA  DC    V(SHOVAR)      SHOW VALUE\nCVSHEXE  DC    V(SHEXEC)      SHOW EXEC\nCVIGDSN  DC    V(IGDSNPRT)    ADDR OF IGNORE DSN PARMS PRT\nCVPGRTN  DC    A(0)           ADDR OF CUR. PGD CODE\nCVSTAX   DC    V(STAX)     STAX RTN ADDRESS                     JEP012\nCVTRACE  DC    A(0)           NEXT TRACE ENTRY\nCVTRSTRT DC    A(0)           START OF TABLE\nCVTREND  DC    A(0)           END OF TRACE TABLE\nCVPADDRS DC    A(0)           ADDRESS OF PCB TABLE\nCVDDNAMS DC    A(0)           POINTER TO DDNAMES\nCVDDCNT  DC    A(0)           COUNT OF DD'S\nCVDAIR   DC    A(0)           ADDR OF DAIR ROUTINE\nCVRETURN DC    A(0)           OS RETURN ADDR\nCVEXTRAP DC    A(0)           EXEC BREAK TRAP LINE NO.\nCVTRAPLN DC    A(0)           EXEC BROKEN LINE NO.\nCVUSRFLD DC    A(0)                USER FIELD...1 CHAR = ID LEN JEP001\nCOMMAREA DC    A(0)               COMMAREA FOR INTRDR COMMUN    JEP016\nSWITCH   DC    A(0)                USED FOR WHERE TO GO IN RUN  JEP016\nWYLDSNL  DC    H'0'              WYLBUR TYPE DSN LENGTH         JEP016\nDUMMY    DC    H'0'             DUMMY FOR LATER USE             JEP016\nCVPROMPT DC    H'0'           PROMPT COUNT\nCVPRMLIM DC    H'10'          # PROMPTS PER PAGEFILE UPDATE\nCVTPROTF DC    V(TPROTF)      XCALL -- DISPLAY PROT BITS\nCVSPARES DC    5A(0)          8 SPARES\nCVPFK    DC    A(0)           PAGE FOR PFK KEYS   JJG\n         SPACE 3\nCVMPAGE1 DC    X'00'\nCVMPAGE2 DC    X'FF'\nCVTTYPE  DC    C'TM'          TIOT IDENT FOR TEMP VOLS\nCVSTYPE  DC    C'IO'          DD PREFIX FOR SAVE VOLUMES\nCVUTYPE  DC    C'IN'          DD PREFIX FOR USE ONLY VOLUMES\n         SPACE 3\n* THE FOLLOWING CODE GETS A ROUTINE FROM THE MASTER\n         SPACE ,\nCVROUTGT STM   R14,R8,0(R13)       SAVE SOME REGISTERS\n         LR    R8,R13\n         LA    R13,11*4(,R8)\n         LA    R2,ROUTBLE          GET ADDRESS OF TABLE\n         AH    2,0(,14)            ADD IN DISPLACEMENT PARM\n         LH    0,0(,2)             GET PAGE NUMBER OF ROUTINE\n         SR    R1,R1               CLEAR PCB POINTER\n         L     R14,CVPGET          GET AN OLD PAGE\n         BALR  R14,R14             GO GET EM\n         ST    R1,CVPGRTN          SAVE ADDR OF PAGED RNT\n         LR    R10,R1              LOAD BASE ADDR\n         MVC   CVROUTG3+2(2),2(2)  SET ROUTINE ADDR IN BRANCH\n         LR    R13,R8              RESTORE SAVE AREA PTR\n         LM    R14,R8,0(R13)       RESTORE REGISTERS\n         LA    14,2(,14)           STEP 14 PAST DISPLACEMENT\nCVROUTG3 B     0(10)               GO TO ROUTINE. DISPLACEMENT\n*                                  IS FILLED IN BEFORE BRANCH\n         SPACE 3\n* CVCALLS IN PAGED CODE EXIT THE PAGE THROUGH THE FOLLOWING\n* ROUTINE TO MAKE THE RETURN ADDRESS RELATIVE.  NOTE THAT THE\n* PAGED CODE CAN USE R7 AS THE BAL REGISTER BECAUSE R10 IS USED\n* AS THE PROGRAM BASE.\n         SPACE ,\nCVCALLER SLR   7,10                MAKE RETURN ADDRESS RELATIVE\n         BALR  14,14               GO CALL ROUTINE\n         B     0(7,10)             ON RETURN -- RE-ENTER PAGE CODE\n         SPACE 3\n* NORMAL EXIT FROM PAGED CODE DOES NOT PFREE THE PAGE.\n* THE FOLLOWING ROUTINE CAN BE USED AS AN EXIT TO FREE\n* THE PAGE BEFORE FINISHING THE EXIT.\n         SPACE ,\nCVROUTEX STM   14,2,0(13)          SAVE SOME REGISTERS\n         LR    2,13                SAVE OLD R13\n         LA    13,20(,13)          BUMP 13 FOR PFREE\n         LR    1,10                PUT PAGE POINTER IN R1\n         SR    10,10               ZERO REGISTER 10\n         L     14,CVPFREE          GET ADDRESS OF PFREE\n         BALR  14,14               GO FREE PAGE\n         LR    13,2                RESTORE R13\n         LM    14,2,0(13)          RESTORE SAVED REGISTERS\n         BR    14                  COMPLETE THE EXIT\n         SPACE 3\n         DS    0F\nCVSIZE   EQU   *-CVSTART\n./ ADD NAME=CVUSER\n* WYLTSO COMMUNICATION VECTOR - USER DEPENDENT PART\n         SPACE ,\nCVUSER   DS    0F\nCVCPADDR DS    A                   VCP ADDRESS\n         SPACE\nCVFPAGE  DS    V                   V(FRSTPAGE)\nCVLPAGE  DS    V                   V(LASTPAGE)\nCVFPFCB  DS    V                   V(FRSTPFCB)\nCVLPFCB  DS    V                   V(LASTPFCB)\nCVSPIEAD DS    A                   SPIE RECOVERY ADDRESS\nCVTIOT   DS    A                   POINTER TO TIOT\nCVTIOTCT DS    F                   COUNTER OF SAVE VOLUMES\n         SPACE\n./ ADD NAME=DAIRINT\n         TITLE  'DAIR DEFAULT PARAMS FOR INTRDR'\nDAIRINT  DS    0F\nDAIR30   DC    X'0030'\n         DC    X'0000'\n         DC    X'00000000'\n         DC    F'0'\n         DC    CL8'WYLRDR'\n         DC    CL8' '\n         DC    CL8' '\n         DC    F'80'\n         DC    F'0'\n         DC    F'0'\nDAIRWTR  DC    CL8'INTRDR'\n         DC    CL4' '\n         DC    XL3'000000'\n         DC    X'80'\n         DC    CL8' '\n         DS    0F\nDAIR18   DC    X'0018'\n         DC    X'0000'\n         DC    X'0000'\n         DC    X'0000'\n         DC    AL4(0)\n         DC    CL8'WYLRDR'\n         DC    CL8' '\n         DC    C'O'\n         DC    X'0'\n         DC    X'0'\n         DC    X'0'\n         DC    8X'0'\nDAINTSZ  EQU   *-DAIRINT\n./ ADD NAME=DAIRLST,SSI=00009355\n         TITLE  'DAIR DEFAULT PARAMS FOR LISTOFF COMMAND'\nDAIRLST  DS    0F\n         DC    X'0030'\n         DC    X'0000'\n         DC    X'00000000'\n         DC    F'0'\n         DC    CL8'WYLPRINT'\n         DC    CL8' '\n         DC    CL8' '\n         DC    F'80'\n         DC    F'0'\n         DC    F'0'\n         DC    CL8' '\n         DC    CL4' '\n         DC    XL3'000000'\n         DC    X'80'\n         DC    CL8' '\nDALSTSZ  EQU   *-DAIRLST\n./ ADD NAME=DCATLG\n         MACRO\n&L       DCATLG\n&L       DOPEN ,,CATLG\n         MEND\n./ ADD NAME=DCLOSE\n         MACRO\n&L       DCLOSE\n&L       CVCALL DCLOSE\n         MEND\n./ ADD NAME=DEB\n         SPACE ,\n* OS DATA EXTENT BLOCK (DEB)\n         SPACE ,\nDEBSTART DS    0F\n         SPACE ,\n* APPENDAGE TABLE\n         SPACE ,\nDEBAPP   DS    0F\nDEBEOEA  DS    A                   END OF EXTENT APPENDAGE\nDEBSIOA  DS    A                   START I/O APPENDAGE\nDEBPCIA  DS    A                   PCI APPENDAGE\nDEBCEA   DS    A                   CHANNEL END APPENDAGE\nDEBXCEA  DS    A                   ABNORMAL END APPENDAGE\nDEBAPPSZ EQU   *-DEBAPP            SIZE OF APPENDAGE TABLE\n         SPACE ,\n* PREFIX SECTION\n         SPACE ,\nDEBPFX   DS    0F\nDEBWKARA DS    X                   I/O SUPPORT WORK AREA (DA)\nDEBDSCBA DS    XL7                 DSCB ADDRESS (DA)\nDEBDCBMK DS    F                   DCB MODIFICATION MASK\nDEBLNGTH DS    X                   LENGTH OF DEB IN DOUBLE WORDS\n         DS    3X\nDEBPFXSZ EQU   *-DEBPFX            SIZE OF PREFIX\n         SPACE ,\n* BASIC SECTION\n         SPACE ,\nDEBBASIC DS    0F\nDEBNMSUB DS    X                   NO. OF SUBROUTINES LOADED\nDEBTCBAD DS    AL3                 TCB ADDRESS\nDEBAMLNG DS    X                   SIZE OF ACCESS METHOD\nDEBDEBAD DS    AL3                 NEXT DEB\nDEBOFLGS DS    X                   DATA SET STATUS FLAGS\nDEBIRBAD DS    AL3                 IRB FOR APPENDAGE EXITS\nDEBOPATB DS    X                   METHOD OF I/O PROCESSING\nDEBQSCNT DS    X                   QUIESCE COUNT\n         DS    H\nDEBNMEXT DS    X                   NO. OF EXTENTS\nDEBUSRPG DS    AL3                 1ST IOB IN USER PURGE CHAIN\nDEBPRIOR DS    X                   TASK PRIORITY\nDEBECBAD DS    AL3                 ADDRESS OF PURGE ECB LIST\nDEBPROTG DS    X                   PROTECTION KEY\n         ORG   *-1\nDEBDEBID DS    X\nDEBDCBAD DS    AL3                 DCB ADDRESS\nDEBEXSCL DS    X                   EXTENT SCALE\nDEBAPPAD DS    AL3                 APPENDAGE TABLE\nDEBBASSZ EQU   *-DEBBASIC          SIZE OF BASIC SECTION\n         SPACE ,\n* DEVICE DEPENDENT SECTION\n         SPACE ,\nDEBDDEP  DS    0F\nDEBDVMOD DS    X                   DEVICE MODIFIER\nDEBUCBAD DS    AL3                 1ST UCB ADDRESS\n         SPACE ,\nDEBDSZMT EQU   *-DEBDDEP           SIZE FOR MAGNETIC TAPE\nDEBDSZUR EQU   *-DEBDDEP           SIZE FOR UNIT RECORD\nDEBDSZTC EQU   *-DEBDDEP           SIZE FOR TELECOMMUNICATIONS\n         SPACE ,\nDEBBINUM DS    H                   BIN NO.\nDEBSTRCC DS    H                   CC FOR START OF EXTENT\nDEBSTRHH DS    H                   HH FOR START OF EXTENT\nDEBENDCC DS    H                   CC FOR END OF EXTENT\nDEBENDHH DS    H                   HH FOR END OF EXTENT\nDEBNMTRK DS    H                   NO. OF TRACKS IN EXTENT\n         SPACE ,\nDEBDSZDA EQU   *-DEBDDEP           SIZE FOR DIRECT ACCESS\n./ ADD NAME=DECBS\n         MACRO\n&L       DECBS\n         GBLA  &NCP\n         LCLA  &CNT\n.* THIS MACRO DEFINES THE DECB'S AND BUFFERS FOR THE VTOC READ\n.*    THE GLOBAL ASSEMBLY VARIABLE NCP DEFINES HOW MANY DECB'S\n.*    SHOULD BE CREATED\n.*    THE DECB'S AND BUFFERS ARE ALSO USED TO READ THE DIRECTORIES\n         MNOTE *,'&NCP DECBS AND BUFFERS ARE DEFINED'\n&CNT     SETA  1\nDECB1    DS    0F                  START OF DECB'S\n         AIF   ('&L' EQ '').LOOP\n&L       EQU   *                   DEFINE LABEL\n.LOOP    ANOP  ,\n         READ  GDECB&CNT,SF,DCB,BUFF&CNT,MF=L\nBUFF&CNT DS    35F    264 BYTE AREA FOR DSCB OR DIRECTORY BLOCK\n         AIF   (&CNT NE 1).SKIP    SKIP AFTER FIRST TIME\nDECBLEN  EQU   *-DECB1             LENGTH OF DECB AND BUFFER\n.SKIP    ANOP  ,\n&CNT     SETA  &CNT+1              INCREASE LOOP COUNTER\n         AIF   (&CNT LE &NCP).LOOP   LOOP IF NOT DONE\nDECB2    DS    0F                  MARK END OF DECB'S\n         MEND\n./ ADD NAME=DENTER\n         MACRO\n&L       DENTER &W,&SZ,&L2,&BASE\n.* MACRO TO REPLACE GENTER FOR DSNAME COMMANDS\n         AIF   ('&L' EQ '').NEP\n         ENTRY &L\n.NEP     ANOP\n&L       DS    0H\n         LA    8,CPDSNWA+(&W+3)/4*4\n         LR    13,8\n&L2      GENTERI &SZ,&BASE\n.EXIT    MEND\n./ ADD NAME=DENTRY\n* DEVICE TABLE FOR WYLBUR VOLUMES\n         SPACE\nDVNAME   DS    CL6                 DCU001\nDVTYPE   DS    CL2                 IO/TM/US\nDDTYPE   DS    XL1                 09\nDUNIT    DS    CL6                 2305-2/3330\nDENTSZ   EQU   *-DVNAME\n./ ADD NAME=DIE\n         MACRO\n&LABEL   DIE   &DUMDUM\n&LABEL   DC    H'0'                ABEND .. 0C1\n         MEND\n./ ADD NAME=DOPEN\n         MACRO\n&L       DOPEN &FMT,&SPACE,&TYPE\n&L       SYSLR 0,&FMT,NULL=,OP=L\n         SYSLR 15,&SPACE,NULL=,OP=L\n         AIF   ('&TYPE'(1,3) EQ 'USE').USE\n         AIF   ('&TYPE'(1,3) EQ 'SAV').SAVE\n         AIF   ('&TYPE'(1,3) EQ 'SCR').SCR\n         AIF   ('&TYPE'(1,7) EQ 'SHOWDSN').SHOWDSN\n         AIF   ('&TYPE'(1,7) EQ 'SHOWDIR').SHOWDIR\n         AIF   ('&TYPE'(1,7) EQ 'SHOWCAT').SHOWCAT\n         AIF   ('&TYPE'(1,3) EQ 'CAT').CATLG\n         MNOTE 4,'&TYPE INVALID.  ''USE'' ASSUMED.'\n.USE     MVI   DSNWAF2,0\n         AGO   .CALL\n.SAVE    MVI   DSNWAF2,DSNFWRT\n         AGO   .CALL\n.SCR     MVI   DSNWAF2,DSNFWRT+DSNFSCR\n         AGO   .CALL\n.SHOWDSN MVI   DSNWAF2,DSNFSHOW\n         AGO   .CALL\n.SHOWDIR MVI   DSNWAF2,DSNFSHOW+DSNFPDS\n         AGO   .CALL\n.SHOWCAT MVI   DSNWAF2,DSNFSHOW+DSNFCAT\n         AGO   .CALL\n.CATLG   MVI   DSNWAF2,DSNFCAT\n.CALL    ANOP\n         CVCALL DOPEN\n         MEND\n./ ADD NAME=DPDSD\n         MACRO\n&L       DPDSD &P\n&L       DSHOW &P,SHOWDIR\n         MEND\n./ ADD NAME=DREAD\n         MACRO\n&L       DREAD\n&L       CVCALL DREAD\n         MEND\n./ ADD NAME=DSCRATCH\n         MACRO\n&L       DSCRATCH\n&L       DOPEN ,,SCRATCH\n         MEND\n./ ADD NAME=DSHCAT\n         MACRO\n&L       DSHCAT &P\n&L       DSHOW &P,SHOWCAT\n         MEND\n./ ADD NAME=DSHOW\n         MACRO\n&L       DSHOW &P,&FUNCT\n         AIF   ('&P' EQ '').DEF\n&L       DOPEN ,&P,&FUNCT\n         MEXIT\n.DEF     ANOP\n&L       DOPEN ,=A(GETTPAG),&FUNCT\n         MEND\n./ ADD NAME=DSNWA\n* WYLTSO DATA SET CONSTANTS\n         SPACE ,\n         ORG   CPDSNWA   DSNAME WORK AREA IN CP\nDSNWADSN DS    CL44           DSNAME\n         SPACE ,\n* OFFSETS OF DSNAME LEVELS FOR STANDARD WYLBUR DSNAMES\nDSNXG    EQU   4         OFFSET OF GROUP ID IN STD DSNAME\nDSNXGL   EQU   3         LENGTH OF GROUP ID LEVEL IN STD DSNAME\nDSNXU    EQU   DSNXG+DSNXGL  OFFSET OF USER ID IN STD DSNAME\nDSNXUL   EQU   4         LENGTH OF USER ID LEVEL IN STD DSNAME\nDSNXN    EQU   DSNXU+DSNXUL  OFFSET AFTER STD DSNAME PREFIX\n         SPACE ,\nDSNWAMBR DS    CL8            PDS MEMBER NAME\nDSNWAVOL DS    CL6            VOLUME\nDSNWACLR EQU   *-DSNWADSN     LENGTH TO BE CLEARED TO BLANKS\nDSNWANL  DS    H              DSNAME LENGTH\n         SPACE 2\nDSNWAF1  DS    CL1            DSNAME FLAG BYTE 1\n         SPACE ,\nDSNFSTD  EQU   X'80'          DSNAME IS STANDARD WYLBUR NAME\nDSNFMYDS EQU   X'40'          DSNAME BELONGS TO USER\nDSNFWLIB EQU   X'20'          DATA SET IS STANDARD WYLBUR PDS\nDSNFQDSN EQU   X'10'          DSNAME WAS SPECIFIED IN QUOTES\nDSNFCCNO EQU   X'08'          NOT CATALOG'ED\nDSNFCCAT EQU   X'04'          CATALOG\nDSNFCUNC EQU   X'02'          UNCATALOG\nDSNFCUNO EQU   X'01'          NOT UNCATALOG'ED\n         SPACE 2\nDSNWAF2  DS    CL1            DSNAME FLAG BYTE 2\n         SPACE ,\nDSNFWRT  EQU   X'80'          DATA SET TO BE WRITTEN\nDSNFSCR  EQU   X'40'          SCRATCH FUNCTION FLAG\nDSNFPDS  EQU   X'20'          COMMAND DEALING WITH A PDS\nDSNFPERM EQU   X'10'          PERMIT COMMAND IN PROGRESS\nDSNFSHOW EQU   X'08'          FUNCTION IS SHOW\nDSNFCAT  EQU   X'04'          COMMAND MANIPULATING THE CATLG\nDSNFRENM EQU   X'02'          RENAME COMMAND IN PROGRESS\nDSNNOVER EQU   X'01'          NOVERIFY OPTION SPECIFIED\n         SPACE 2\nDSNWAF3  DS    CL1\n         SPACE ,\nDSNFTYP  EQU   X'80'          SHOW DSN/TYPE,DIR/ALL,CAT/TYPE\nDSNFLIN  EQU   X'80'               LINES OPTION ON SAVE\nDSNFSPAC EQU   X'40'          SHOW DSN/SPACE\nDSNFDATD EQU   X'20'          SHOW DSN/DATED\nDSNFXCL  EQU   X'10'          EXCLUDE ON SHOW DSN/DIR/CAT\nDSNFCHT  EQU   X'04'               TYPE CHANGE OK ON SAVE\nDSNFRTO  EQU   X'04'          TO OPTION IN RENAME\nDSNFEXP  EQU   X'02'               EXPDT OVERRIDE OK ON SAVE/SCR\nDSNFRALI EQU   X'02'          ALIAS OPTION IN RENAME\nDSNFSSI  EQU   X'01'               SSI VALUE SPECIFIED\n         SPACE 2\nDSNWAF4  DS    CL1            PROTECTION FLAG TO BE SET\n         SPACE ,\nDSNPSET  EQU   X'01'\nDSNPRUSR EQU   X'80'\nDSNPRGRP EQU   X'40'\nDSNPRBLK EQU   X'C0'\nDSNPPUB  EQU   X'00'\nDSNPWUSR EQU   X'20'\nDSNPWGRP EQU   X'10'\nDSNPWBLK EQU   X'30'\nDSNPDPO  EQU   X'02'\nDSNPREAD EQU   X'08'\nDSNPWRIT EQU   X'04'\n         SPACE 2\nDSNWAF5  DS    CL1            SPARE FLAG\n         SPACE ,\nDSNFSHR  EQU   X'80'          DON'T ENQ EXCLUSIVE, PLEASE...\nDSNPSYDS EQU   X'40'          DS IS NON STD, NON AC, NON SYSMSG\nDSNPSYD2 EQU   X'20'          FRO RENAME DSN 2 IS NON STD\nDSNRCVRY EQU   X'10'          RECOVERY RUNNING. NO PROT CHK\n         SPACE 2\nDSNWAF6  DS    CL1            SPARE FLAG\n         SPACE 2\nDSNWAF7  DS    CL1            SPARE FLAG\n         SPACE 2\nDSNWAGOR DS    CL(DSNXGL-1)   DSNAME GROUP OVERRIDE\nDSNWAUOR DS    CL(DSNXUL-1)   DSNAME USER OVERRIDE\n         SPACE ,\n         DS    0F\nDSSIZ    EQU   *-DSNWADSN     LENGTH OF DSNAME WORK AREA\n         SPACE ,\n* OFFSETS IN DSNAME WORK AREA FOR SHOW DSNAMES\nSDSNQSZ  EQU   44                 SHOW DSNAMES BOUND AREA SIZE\nSDSNQLB  DS    CL(SDSNQSZ)        SHOW DSNAMES LOWER BOUND\nSDSNQUB  DS    CL(SDSNQSZ)        SHOW DSNAMES UPPER BOUND\nSDSNDSZ  EQU   *-DSNWADSN                LNGTH OF SDSN WK AREA\n         SPACE ,\n         ORG   DSNWADSN+DSSIZ      DEFINE AREA FOR SAVE\nDSAVSSI  DS    F                   SPACE FOR SSI IF GIVEN\nDSAVSPA  DS    F                   BYTE SIZE FOR NEW DATA SET\nDSAVCNT  DS    H                   LINE COUNT FOR NEW DATA SET\nDSAVBLK  DS    H                   BLOCK COUNT FOR EDIT SAVE\nDSAVSIZ  EQU   *-DSNWADSN          SIZE OF WORK AREA FOR SAVE\n         SPACE ,\nMXRECSZ  EQU   3520    MAX RECORD SIZE WYLBUR SAVES\n         ORG   ,\n./ ADD NAME=DVTAREA\n         MACRO\n&L       DVTAREA &DUMMY\n.* THIS IS A MAPPING OF THE DEVCODE INFORMATION\n&L       DS    0F\nDVTDEVCD DS    F                   DEVICE CODE\nDVTFRPS  EQU   X'10'  RPS FLAG BIT FOR OPTION BYTE (2ND BYTE)\n         DS    F                   MAX BLOCK SIZE -- NOT NEEDED\nDVTNUMC  DS    H                   NUMBER OF CYLINDERS\nDVTNUMT  DS    H                   NUMBER OF TRACKS\nDVTTRKSZ DS    H                   TRACK SIZE\nDVTBLKO  DS    X                   KEYED BLOCK OVERHEAD\nDVTLBLKO DS    X                   KEYED BLOCK OVERHEAD (LAST)\nDVTKEYO  DS    X                   REDUCE OVERHEAD IF NO KEYS\nDVTFLAG  DS    X                   FLAG BYTE\nDVTFOHD  EQU   8                   OVERHEAD IS SINGLE HALF-WORD\nDVTFTOL  EQU   1                   DEVICE NEEDS TOLERANCE FACTOR\nDVTTOL   DS    H                   TOLERANCE FACTOR FOR DEVICE\n*  NOTE: DVTTOL IS 512 FOR DEVICES NOT HAVING TOLERANCE FACTOR\n*        SO DVTFTOL NEED NOT BE CHECKED BEFORE USING DVTTOL.\n         MEND\n./ ADD NAME=DVTOC\n         MACRO\n&L       DVTOC &P\n&L       DSHOW &P,SHOWDSN\n         MEND\n./ ADD NAME=DWRITE\n         MACRO\n&L       DWRITE &LEN\n&L       SYSLR 0,&LEN\n         CVCALL DWRITE\n         MEND\n./ ADD NAME=GENTER\n         MACRO\n&L       GENTER &SZ,&BASE\n         AIF   ('&L' EQ '').NEP\n         ENTRY &L\n.NEP     ANOP\n&L       GENTERI &SZ,&BASE\n         MEND\n./ ADD NAME=GENTERI\n         MACRO\n&L       GENTERI &SZ,&BASE\n         GBLC  &PAGECDE\n         AIF   ('&L' EQ '').NONM\n&L       DS    0H\n.NONM    ANOP\n         AIF   ('&SZ' EQ '').NWA\n         LA    13,(&SZ+3)/4*4(,13)\n.NWA     ANOP\n         AIF   ('&BASE' EQ 'NO').EXIT\n         AIF   ('&PAGECDE' EQ 'YES').EXIT\n         BALR  7,0\n         USING *,7\n.EXIT    MEND\n./ ADD NAME=HT\n         MACRO\n&L       HT    &O,&LEN=1\n.* THIS MACRO WILL GENERATE A 2 'DC' STATMENTS, THE FIRST\n.* BEING THE LENGTH OF THE OPERAND SUPPLIED IN EITHER A\n.* HALFWORD OR AS AL1 DEPENDING ON 'LEN=' OPERAND, AND THE\n.* SECOND THE OPERAND ITSELF IN A C'...' FORM.\n         LCLA  &X,&N\n         LCLC  &C\n         AIF   ('&O' EQ '').ERR\n         AIF   ('&O'(1,1) NE '''').ERR\n&X       SETA  1\n&C       SETC  '&&'\n.LOOP    ANOP\n&X       SETA  &X+1\n         AIF   (&X GE K'&O).EL\n&N       SETA  &N+1\n         AIF   ('&O'(&X,1) NE '''' AND '&O'(&X,1) NE '&C'(1,1)).LOOP\n&X       SETA  &X+1\n         AGO   .LOOP\n.EL      AIF   (&LEN EQ 2).HALF\n         AIF   (&LEN NE 1).ERR\n&L       DC    AL1(&N),C&O\n         MEXIT\n.HALF    AIF   (&N/2*2 NE &N).ODD\n&L       DC    H'&N',C&O\n         MEXIT\n.ODD     ANOP\n&N       SETA  &N+1\n&L       DC    H'&N',C&O,C' '\n         MEXIT\n.ERR     ANOP\n&L       SYSLR ERR='***** BAD OPERAND *****'\n         MEND\n./ ADD NAME=IECSDSL1 0100-80106-80106-1255-00182-00182-00000-$SYS13  00\n         MACRO\n         IECSDSL1 &PARA\n         LCLA  &CTR\n&CTR     SETA  1\n.LOOP    AIF   (&CTR GT N'&PARA).ENDOFIT\n         AIF   ('&PARA(&CTR)' EQ '1').FIRSTON\n         AIF   ('&PARA(&CTR)' EQ '2').SECNDON\n         AIF   ('&PARA(&CTR)' EQ '3').THIRDON\n         AIF   ('&PARA(&CTR)' EQ '4').FORTHON\n         AIF   ('&PARA(&CTR)' EQ '5').FIFTHON\n         AGO   .ERROR\n.FIRSTON ANOP\nIECSDSL1 EQU   *                        FORMAT 1 DSCB\nDS1DSNAM DS    11F                      DATA SET NAME\nDS1FMTID DS    CL1                      FORMAT IDENTIFIER\nDS1DSSN  DS    CL6                      DATA SET SERIAL NUMBER\nDS1VOLSQ DS    CL2                      VOLUME SEQUENCE NUMBER\nDS1CREDT DS    CL3                      CREATION DATE\nDS1EXPDT DS    CL3                      EXPIRATION DATE\nDS1NOEPV DS    CL1                      NUMBER OF EXTENTS ON VOLUME\nDS1NOBDB DS    CL1                      NUMBER OF BYTES USED IN LAST\n*                                          DIRECTORY BLOCK\n         DS    CL1                      SPARE BYTE\nDS1SYSCD DS    CL13                     SYSTEM CODE\n*        DS    CL7                      FUTURE USE (ALREADY USED)\nDS1TIME  DS    XL3                 BINARY TIME OF CREATION         C522\nDS1SPACE DS    X                   FLAG = X'69' IF WYLBUR DATASET  C522\nDS1FLAG  DS    X                   FLAG = X'CB' FOR CRBEOUT DS,    C522\nDS1REFD  EQU   DS1FLAG             REF DATA SU60\n*                                  OR X'10' FOR TEMPORARY DATASET. C522\nDS1MODEL DS    X -                 MODEL NUMBER OF CREATING 360    C522\nDS1PROTF DS    X                   DATA SET PROTECTION FLAGS.   WA45090\n         SPACE ,                                                WA45090\nDS1RDFLG EQU   X'C0'               READ BITS MASK.              WA45090\nDS1WRFLG EQU   X'30'               WRITE BITS MASK.             WA45090\nDS1ACFLG EQU   X'01'               DATA SET PROTECTION IN EFFECTWA45090\nDS1DSORG DS    CL2                      DATA SET ORGANIZATION\nDS1RECFM DS    CL1                      RECORD FORMAT\nDS1OPTCD DS    CL1                      OPTION CODE\nDS1BLKL  DS    CL2                      BLOCK LENGTH\nDS1LRECL DS    CL2                      RECORD LENGTH\nDS1KEYL  DS    CL1                      KEY LENGTH\nDS1RKP   DS    CL2                      RELATIVE KEY POSITION\nDS1DSIND DS    CL1                      DATA SET INDICATORS\nDS1SCALO DS    CL4                      SECONDARY ALLOCATION\nDS1LSTAR DS    CL3                      LAST USED TRACK AND RECORD ON\n*                                          TRACK\nDS1TRBAL DS    CL2                      AMOUNT OF SPACE REMAINING ON\n*                                          LAST TRACK USED\n         DS    CL2                      SPARE BYTES\nDS1EXT1  DS    CL10                     FIRST EXTENT DESCRIPTION\n*        FIRST BYTE                     EXTENT TYPE INDICATOR\n*        SECOND BYTE                   EXTENT SEQUENCE NUMBER\n*        THIRD - SIXTH BYTES            LOWER LIMIT\n*        SEVENTH - TENTH BYTES         UPPER LIMIT\nDS1EXT2  DS    CL10                     SECOND EXTENT DESCRIPTION\nDS1EXT3  DS    CL10                     THIRD EXTENT DESCRIPTION\nDS1PTRDS DS    CL5                      POINTER TO NEXT DSCB RECORD\n&CTR     SETA  &CTR+1\n         AGO   .LOOP\n.SECNDON ANOP\nIECSDSL2 EQU   *                        FORMAT 2 DSCB\n         DS    CL1                      UNUSED (IN KEY)\nDS22MIND DS    CL7                      ADDRESS OF 2ND LEVEL MASTER IND\nDS2L2MEN DS    CL5                      LAST 2ND LEVEL MASTER IND ENTRY\nDS23MIND DS    CL7                      ADDRESS OF 3RD LEVEL MASTER\n*                                          INDEX\nDS2L3MIN DS    CL5                      LAST 3RD LEVEL MASTER INDEX\n*                                          ENTRY\n         DS    CL19                     SPARE\n* THE FOLLOWING FIELDS ARE CONTAINED IN THE DATA PORTION OF THE FORMAT\n* 2DSCB:\nDS2FMTID DS    CL1                     FORMAT ID\nDS2NOLEV DS    CL1                      NUMBER OF INDEX LEVELS\nDS2DVIND DS    CL1                      HIGH LEVEL INDEX DEVELOPMENT\n*                                          INDICATOR\nDS21RCYL DS    CL3                      FIRST DATA RECORD IN CYLINDER\nDS2LTCYL DS    CL2                      LAST  DATA TRACK  IN CYLINDER\nDS2CYLOV DS    CL1                      NUMBER OF TRACKS FOR CYLINDER\n*                                          OVERFLOW\nDS2HIRIN DS    CL1                      HIGHEST \"R\" ON HIGH-LEVEL INDEX\n*                                          TRACK\nDS2HIRPR DS    CL1                     HIGHEST @R@ ON HIGH-LEVEL INDEX\nDS2HIROV DS    CL1                      HIGHEST \"R\" ON OVERFLOW TRACK\nDS2RSHTR DS    CL1                      \"R\" OF LAST DATA RECORD ON\n*                                          SHARED TRACK\n         DS    CL2                      RESERVED FOR FUTURE USE\nDS2TAGDT DS    CL2                      TAG DELETION COUNT\nDS2RORG3 DS    CL3                      NON-FIRST OVERFLOW REFERENCE\n*                                          COUNT (RORG3)\nDS2NOBYT DS    CL2                      NUMBER OF BYTES FOR HIGHEST-\n*                                          LEVEL INDEX\nDS2NOTRK DS    CL1                      NUMBER OF TRACKS FOR HIGHEST-\n*                                          LEVEL INDEX\nDS2PRCTR DS    CL4                      PRIME RECORD COUNT\nDS2STIND DS    CL1                      STATUS INDICATORS\n*        BIT   DESCRIPTION\n*        0     LAST BLOCK FULL\n*        1     LAST TRACK FULL\n*        2-7   MUST REMAIN OFF\n*\nDS2CYLAD DS    CL7                      ADDRESS OF CYLINDER INDEX\nDS2ADLIN DS    CL7                      ADDRESS OF LOWEST LEVEL MASTER\n*                                          INDEX\nDS2ADHIN DS    CL7                      ADDRESS OF HIGHEST LEVEL MASTER\n*                                          INDEX\nDS2LPRAD DS    CL8                      LAST PRIME DATA RECORD ADDRESS\nDS2LTRAD DS    CL5                      LAST TRACK INDEX ENTRY ADDRESS\nDS2LCYAD DS    CL5                      LAST CYLINDER INDEX ENTRY\n*                                          ADDRESS\nDS2LMSAD DS    CL5                      LAST MASTER INDEX ENTRY ADDRESS\nDS2LOVAD DS    CL8                      LAST INDEPENDENT OVERFLOW\n*                                          RECORD ADDRESS\nDS2BYOVL DS    CL2                      BYTES REMAINING ON OVERFLOW\n*                                          TRACK\nDS2RORG2 DS    CL2                      NUMBER OF INDEPENDENT OVERFLOW\n*                                          TRACKS\nDS2OVRCT DS    CL2                      OVERFLOW RECORD COUNT\nDS2RORG1 DS    CL2                      CYLINDER OVERFLOW AREA COUNT\n         DS    CL3                      SPARE\nDS2PTRDS DS    CL5                      POINTER TO FORMAT 3 DSCB\n&CTR     SETA  &CTR+1\n         AGO   .LOOP\n.THIRDON ANOP\nIECSDSL3 EQU   *                        FORMAT 3 DSCB\n         DS    CL4                      UNUSED (IN KEY)\nDS3EXTNT DS    CL40                     EXTENT (IN KEY)\nDS3FMTID DS    CL1                      FORMAT IDENTIFIER\nDS3ADEXT DS    CL90                     ADDITIONAL EXTENT\nDS3PTRDS DS    CL5                      POINTER TO NEXT DSCB\n&CTR     SETA  &CTR+1\n         AGO   .LOOP\n.FORTHON ANOP\nIECSDSF4 EQU   *                        FORMAT 4 DSCB\nDS4IDFMT DS    CL1                      FORMAT ID\nDS4HPCHR DS    CL5                      HIGHEST PRIME CCHHR\nDS4DSREC DS    CL2                      AVAILABLE DSCB RECORDS\nDS4HCCHH DS    CL4                      HIGHEST CCHH OF ALTERNATE TRKS\nDS4NOATK DS    CL2                      NUMBER OF ALTERNATE TRACKS\nDS4VTOCI DS    CL1                      VTOC INDICATORS\n*        BIT             DESCRIPTION\n*        O               IF ON INDICATES THAT EITHER NO FORMAT 5 DSCB'S\n*                        EXIST, OR THAT THEY DO NOT REFLECT THE TRUE\n*                        STATUS OF THE VOLUME\n*        1-7             SPARE\nDS4NOEXT DS    CL1                      NUMBER OF EXTENTS\n         DS    CL2                      RESERVED FOR FUTURE USE\nDS4DEVCT DS    0CL14                   DEVICE CONSTANTS\nDS4DEVSZ DS    CL4                      DEVICE SIZE\nDS4DEVTK DS    CL2                      DEVICE TRACK LENGTH\nDS4DEVOV DS    0CL3                    DEVICE RECORD OVERHEAD\nDS4DEVI  DS    CL1                     FOR KEYED RECORD NOT LAST ONE\nDS4DEVL  DS    CL1                     FOR KEYED RECORD LAST ONE\nDS4DEVK  DS    CL1                      CONSTANT TO BE SUBTRACTED IF\n*                                          RECORD IS UNKEYED\nDS4DEVFG DS    CL1                      FLAG BYTE\n*        BIT                  DESCRIPTION\n*        7                    A TOLERANCE FACTOR MUST BE APPLIED TO ALL\n*                             BUT THE LAST RECORD ON THE TRACK\n*        6                    CC AND HH MUST BE USED AS 1 BYTE VALUES\n*                                AS IN THE CASE OF THE 2321\nDS4DEVTL DS    CL2                     DEVICE TOLERANCE\nDS4DEVDT DS    CL1                      NUMBER OF DSCB'S PER TRACK\nDS4DEVDB DS    CL1                      NUMBER OF DIRECTORY BLOCKS PER\n*                                          TRACK\n         DS    CL29                     SPARE\nDS4VTOCE DS    CL10                     VTOC EXTENT\n         DS    CL25                     SPARE\n&CTR     SETA  &CTR+1\n         AGO   .LOOP\n.FIFTHON ANOP\nIECSDSF5 EQU   *                        FORMAT 5 DSCB\nDS5KEYID DS    CL4                      KEY IDENTIFICATION\nDS5AVEXT DS    CL5                      AVAILABLE EXTENT\nDS5EXTAV DS    CL35                     AVAILABLE EXTENTS, IN KEY\nDS5FMTID DS    CL1                      FORMAT IDENTIFIER\nDS5MAVET DS    CL90                    AVAILABLE EXTENTS\nDS5PTRDS DS    CL5                      POINTER TO NEXT FORMAT 5 DSCB\n&CTR     SETA  &CTR+1\n         AGO   .LOOP\n.ERROR   MNOTE 7,'***INCORRECT FORMAT NUMBER'\n.ENDOFIT MEND\n./ ADD NAME=JCBTSO\n* WYLTSO LINE EDITOR - JOB CONTROL BLOCK\n         SPACE ,\nJCBSTART DS    0D\n         SPACE ,\nJCBPAGES DS    3A\nJCBWAPTR DS    A\n         SPACE ,\nJCBAFL   DS    X                       FLAGS\n         SPACE ,\nJCBAFALO EQU   X'80'                   AUTO LOGOFF\nJCBSYSPR EQU   X'40'                   SYS PRIV\nJCBTSO   EQU   X'20'                   TSO TASK\nJCBAFDO  EQU   X'10'                   DATA SET IS OPEN\nJCBSTAX  EQU   X'08'                   STAX ISSUED\nJCBSTAXD EQU   X'04'                   STAX DEFER=YES\nJCBAFIA  EQU   X'02'                   IDLE ATTN RECEIVED\nJCBAINIT EQU   X'01'                   INITILIZATION PHASE\n         SPACE ,\nJCBBFL   DS    X                       FLAGS\n         SPACE ,\nJCBBFPER EQU   X'80'                   PAGE DRUM ERROR\nJCBPGRD  EQU   X'40'                   PAGE MUST BE READ IN\nJCBPIOW  EQU   X'20'                   WAIT MUST BE ISSUED\n         SPACE ,\n         DS    0F\nJCBSIZE  EQU   *-JCBSTART\n./ ADD NAME=KWYL\nKWYL     DC    C'WYL.'        FIRST LEVEL OF WYLBUR DSNAMES\n./ ADD NAME=MDC\n*\n*  MACHINE DEPENDENT CELLS\n*\nEXTOPSW  EQU   24                      EXTERNAL OLD PSW\nSVCOPSW  EQU   32                      SVC OLD PSW\nPIOPSW   EQU   40                      PROGRAM OLD PSW\nMKOPSW   EQU   48                      MACHINE CHECK OLD PSW\nIOOPSW   EQU   56                      I/O OLD PSW\nCSW      EQU   64                      CHANNEL STATUS WORD\nCSWKEY   EQU   64                      PROTECT KEY PORTION\nCSWADDR  EQU   65                      ADDRESS PORTION OF CSW\nCSWSTAT  EQU   68                      STATUS BYTES\n*\nCSWSATTN EQU   X'80'                   ATTENTION\nCSWSSM   EQU   X'40'                   STATUS MODIFIER\nCSWSCUE  EQU   X'20'                   CONTROL UNIT END\nCSWSBUSY EQU   X'10'                   CONTROL UNIT BUSY\nCSWSCE   EQU   X'08'                   CHANNEL END\nCSWSDE   EQU   X'04'                   DEVICE END\nCSWSUC   EQU   X'02'                   UNIT CHECK\nCSWSUE   EQU   X'01'                   UNIT EXCEPTION\n*\nCSWSTAT2 EQU   69                      2ND STATUS BYTE\n*\nCSWSPCI  EQU   X'80'                   PCI\nCSWSIL   EQU   X'40'                   INCORRECT LENGTH\nCSWSPC   EQU   X'20'                   PROGRAM CHECK\nCSWSSPC  EQU   X'10'                   STORAGE PROTECTION CHECK\nCSWSCDC  EQU   X'08'                   CHANNEL DATA CHECK\nCSWSCCC  EQU   X'04'                   CHANNEL CONTROL CHECK\nCSWSICC  EQU   X'02'                   INTERFACE CONTROL CHECK\nCSWSCC   EQU   X'01'                   CHAINING CHECK\n*\nCSWLEN   EQU   70                      UNUSED LENGTH\nCAW      EQU   72                      CHANNEL ADDRESS WORD\nTIMER    EQU   80                      INTERVAL TIMER\nEXTNPSW  EQU   88                      EXTERNAL NEW PSW\nSVCNPSW  EQU   96                      SVC NEW PSW\nPINPSW   EQU   104                     PROGRAM NEW PSW\nMKNPSW   EQU   112                     MACHINE CHECK NEW PSW\nIONPSW   EQU   120                     I/O NEW PSW\nDSA      EQU   128                     DIAGNOSTIC SCAN-OUT AREA\n*\n*  CCW DEFINITIONS\n*\nCCWCC    EQU   0                       COMMAND CODE\n*\nCCWCSAD0 EQU   X'13'                   SET ADDRESS 0\nCCWCSAD1 EQU   X'17'                   SET ADDRESS 1\nCCWCSAD2 EQU   X'1B'                   SET ADDRESS 2\nCCWCSAD3 EQU   X'1F'                   SET ADDRESS 3\nCCWCEABL EQU   X'27'                   ENABLE\nCCWCDABL EQU   X'2F'                   DISABLE\nCCWCPREP EQU   X'06'                   PREPARE\nCCWCBRK  EQU   X'0D'                   BREAK\nCCWCWR   EQU   X'01'                   WRITE\nCCWCRDTO EQU   X'02'                   READ WITH TIMEOUT\nCCWCRDI  EQU   X'0A'                   READ INHIBIT\nCCWCNOP  EQU   X'03'                   NO OPERATION\nCCWCTIC  EQU   X'08'                   TRANSFER IN CHANNEL\n*\nCCWADDR  EQU   1                       ADDRESS\nCCWFL    EQU   4                       FLAGS\n*\nCCWFDCH  EQU   X'80'                   DATA CHAINING BIT\nCCWFCCH  EQU   X'40'                   COMMAND CHAINING BIT\nCCWFSLI  EQU   X'20'                   SUPPRESS INCORRECT LENGTH BIT\nCCWFSKIP EQU   X'10'                   SUPPRESS DATA TRANSFER BIT\n*\nCCWLEN   EQU   6                       LENGTH\n*\n*  SENSE BYTES\n*\nSNSBYTE1 EQU   0                       SENSE BYTE 1\n*\nSNSBCR   EQU   X'80'                   COMMAND REJECT\nSNSBIR   EQU   X'40'                   INTERVENTION REQUIRED\nSNSBBOPC EQU   X'20'                   BUS OUT PARITY CHECK\nSNSBEC   EQU   X'10'                   EQUIPMENT CHECK\nSNSBDC   EQU   X'08'                   DATA CHECK\nSNSBOR   EQU   X'04'                   OVERRUN\nSNSBLD   EQU   X'02'                   LOST DATA\nSNSBTO   EQU   X'01'                   TIMEOUT\n./ ADD NAME=OFFSET\n         MACRO\n&LABEL   OFFSET &REG,&TAG\n&LABEL   L     &REG,=A(&TAG-CPAREA)\n         AR    &REG,R12\n         MEND\n./ ADD NAME=OPWRITE\n         MACRO\n&L       OPWRITE\n&L       CVCALL OPWRITE\n         MEND\n./ ADD NAME=PAGECDE\n         MACRO\n&LCSECT  PAGECDE\n.* THIS MACRO STARTS THE ASSEMBLY OF CODE THAT WILL BE PAGED\n.* THE LABEL FIELD MUST BE THE CSECT NAME.  AFTER DEFINING THE\n.* CSECT, THE GLOBAL SYMBOL &PAGECDE IS SET TO 'YES' AND A\n.* USING FOR REGISTER 10 IS DONE\n.* THE OPERANDS OF PAGECDE ARE THE NAMES OF THE ROUTINES FOUND\n.* IN THIS PAGE.  A \"P\" IS PREFIXED TO THE ROUTINE NAME TO GET THE\n.* ENTRY SYMBOL IN THE PAGE AND AN \"R\" IS PREFIXED TO GET THE\n.* ROUTBLE SYMBOL.\n         GBLC  &PAGECDE,&CSECT\n         LCLA  &CTR\n         LCLC  &CURR\n&CSECT   SETC  '&LCSECT'\n         SPACE ,\n&CSECT   CSECT\n&PAGECDE SETC 'YES'\n         USING *,10                   R10 POINTS TO START OF CSECT\n         DC    AL2(&CSECT.END-&CSECT) DISPLACEMENT TO INIT START\n         SPACE ,\n* EACH PAGE OF CODE MUST START WITH A PAGECDE DEFINING THE ROUTINES\n* FOUND IN THE PAGE.  THE PAGED-CODE MUST END WITH A PINIT AND\n* PEND MACRO SURROUNDING ANY INITIALIZATION CODE NECESSARY FOR\n* THE PAGE.  THE INITIALIZATION ROUTINE IS CALLED BEFORE ANY\n* PAGE IS WRITTEN SO IT CAN BE USED TO INITIALIZE SUCH THINGS\n* AS SCAN TABLE PUSH DOWN POINTERS THAT ARE ABSOLUTE ADDRESSES.\n* ADDRESSABILITY FOR THE PAGED-CODE, THE CV, AND CV2 IS ESTABLISHED\n* BEFORE THE ROUTINE IS CALLED.  THE PEND MACRO GENERATES THE\n* RETURN VIA R14.  R0-R4 CAN BE USED BY THE ROUTINES.\n         SPACE ,\n* EACH PAGE OF CODE CAN BE NO LONGER THAN CPSIZE.  THE FOLLOWING\n* SCON GENERATES NO CODE BUT IT WILL GENERATE AN ERROR IF THE\n* PAGE CODE SIZE EXCEEDS CPSIZE.\n         DC    0S(CPSIZE-&CSECT.END+&CSECT.(0))\n         SPACE ,\n* THE TABLE OF ROUTINES IN THIS PAGE IS GIVEN BELOW.  EACH ENTRY\n* CONSISTS OF 2 HALFWORD DISPLACEMENTS USED BY THE WYLOAD ROUTINE\n* AT STARTUP TO INITIALIZE THE ROUTBLE ENTRIES.\n* THE FIRST HALFWORD IS THE ROUTBLE DISPLACEMENT TO BE INITIALIZED\n* AT STARTUP; THE SECOND HALFWORD IS THE DISPLACEMENT TO THE START\n* OF THE ROUTINE IN THE PAGE.  IF THE ROUTINE IS THE NAME \"MISSING\",\n* THE PAGE DISPLACEMENT AND PAGE NUMBER OF THE ROUTINE WILL BE USED\n* TO INITIALIZE ALL ENTRIES IN ROUTBLE WHICH WERE NOT INITIALIZED\n* BY OTHER ROUTINES.  ONLY 1 \"MISSING\" ROUTINE SHOULD EVER BE\n* DEFINED.\n         SPACE ,\n         AIF   (N'&SYSLIST NE 0).GO\n         MNOTE 8,'NO ROUTINES DEFINED IN PAGE'\n         MEXIT\n.GO      ANOP\n&CTR     SETA  &CTR+1\n&CURR    SETC  '&SYSLIST(&CTR)'\n         AIF   ('&CURR' EQ 'MISSING').MISS\n         DC    AL2(R&CURR-ROUTBLE,P&CURR-&CSECT)\n         AGO   .TEST\n.MISS    ANOP\n* THE FOLLOWING ROUTINE WILL FILL ALL MISSING ROUTINES IN ROUTBLE\n         DC    AL2(0-1,P&CURR-&CSECT)\n         SPACE ,\n.TEST    AIF   (N'&SYSLIST GT &CTR).GO\n         DC    AL2(0-2)  END OF TABLE FOR THIS PAGE\n         MEND\n./ ADD NAME=PAGEFILE\n         MACRO\n         PAGEFILE\n         GBLA  &PFCBCNT\n         LCLA  &X,&DD\n.LOOP    ANOP\n&X       SETA  &X+1\n         AIF   (&X GT N'&SYSLIST).EXIT\n&PFCBCNT SETA  &PFCBCNT+1\nPTSIZE&PFCBCNT EQU &SYSLIST(&X)\nPFCB&PFCBCNT DC 0F'0',(PFCBSIZE)X'00'\n         PFORG PFCBPTST\n         DC    A(PT&PFCBCNT)\n         PFORG PFCBNP\n         DC    A(&SYSLIST(&X))\n         PFORG PFCBMASK\n         DC    A((&PFCBCNT-1)*X'1000')\n         AIF   (&X NE N'&SYSLIST).NOFL\n         PFORG PFCBFL\n         DC    AL1(PFCBFGND)\n.NOFL    ANOP\n         PFORG PFCBDCBA\n&DD      SETA  &PFCBCNT-1\n         DCB   DDNAME=PAGE&DD,MACRF=E,DEVD=DA,DSORG=DA\n         ORG   ,\n         SPACE ,\n         AGO   .LOOP\n.EXIT    ANOP\n         MEND\n./ ADD NAME=PAGEOPEN 0105-79320-79323-0830-00028-00060-00000-TEC015  00\n*\n*  OPEN FILE\n*\n         LA    R3,PFCBDCB          POINT AT DCB\n         OPEN  ((R3),(OUTPUT))     OPEN PAGE FILE\n         TM    PFCBDCB+(DCBOFLGS-IHADCB),X'10' OPEN OK\n         BZ    BADOPEN             BAD PUT OUT MSG\n*\nPFOPND   DS    0H\n         L     R3,PFCBDCB+(DCBDEBAD-IHADCB)  DEB ADDR\n         USING DEBBASIC,R3\n         SR    R4,R4\n         IC    R4,DEBNMEXT         NO. OF EXTENTS\n         LA    R3,DEBBASND              END OF BASIC SECTION\n         USING DEBDASD,R3               IS START OF DASD EXTENT\n         SR    1,1                 SET NO. OF TRACKS\nCNTTRK   AH    1,DEBNMTRK          NO. TRACKS IN THIS EXTENT\n         LA    R3,(DEBNMTRK-DEBDASD)+L'DEBNMTRK(,R2)  +SIZE OF S\n         BCT   R4,CNTTRK           NEXT EXTENT\n         M     0,PFCBRPT           TIMES RECORDS/TRACK\n         CL    1,PFCBNP            COMPARE WITH MAX DEFINED\n         BNH   *+8                 BR IF OK\n         L     1,PFCBNP            OR USE MAX DEFINED\n         ST    1,PFCBNP            SAVE NO. OF PAGES\n         AL    1,PFCBPTST          POINT TO\n         BCTR  1,0                     END OF PAGE TABLE\n         ST    1,PFCBPTND          SAVE IT\nENDOPEN  DS    0H                                                JJG\n./ ADD NAME=PAGES\n         MACRO\n         PAGES &NUM\n         LCLA  &PAGES\n.LOOP    ANOP\n&PAGES   SETA  &PAGES+1\nCVPAGE&PAGES DS  0D\n         DS    XL(PCBSIZE)\n         AIF   (&PAGES LT &NUM).LOOP\n         MEND\n./ ADD NAME=PCALL\n         MACRO\n&L       PCALL &R\n.* THIS MACRO GENERATES CODE TO CALL PAGED WYLBUR CODE\n.* TO GET THE DISPLACEMENT IN ROUTBLE AN \"R\" IS PREFIXED\n.* TO THE ROUTINE NAME GIVEN.\n         GBLC  &PAGECDE\n&L       BAL   14,CVROUTGT         GO TO CODE-GET ROUTINE\n         DC    AL2(R&R-ROUTBLE) DISPLACEMENT FOR ROUTINE\n         AIF   ('&PAGECDE' NE 'YES').EXIT\n         DC    AL2(0) FORCE ERROR IF RETURN IS MADE TO PAGED CODE\n.EXIT    MEND\n./ ADD NAME=PCBTSO\n* WYLTSO LINE EDITOR PAGE BUFFER\n         SPACE\nPCBSTART DS    0D\nPCBPSIZE EQU   3016   1952   1584      PAGE SIZE\nPCBBUF   DS    (PCBPSIZE)X             PAGE BUFFER\nPCBPT    DS    A                       POINTER TO PT ENTRY\nPCBPFCB  DS    A                       ADDRESS OF PFCB\nPCBPN    DS    H                       PAGE NUMBER\n*                    FORMAT: X'ZYYY'    Z: PFCB SEQUENCE\n*                          :          YYY: RELATIVE PG #\nPCBFL    DS    X              FLAGS\n*\nPCBFFULL EQU   X'80'               BUFFER IS FULL\nPCBPCODE EQU   X'40'               PAGED CODE\nPCBFMARK EQU   X'20'               PAGE HAS BEEN ALTERED\nPCBOWNED EQU   X'10'               PCB IN USE\nPIOWRITE EQU   5                   OPCODE FOR WRITE\nPIOREAD  EQU   6                   OPCODE FOR READ\nPCBECB   DC    A(0)                ECB FOR EXCP\nPCBIOB   DS    0F                  START OF IOB\nPCBFLG1  DC    X'42'               IOB FLAGS 1\nPCBSECT  DC    X'00'               SECTOR NUMBER IF RPS\nPCBSNS   DC    X'0000'             SENSE BYTES\n         DC    X'00'\nPCBECBP  DC    AL3(PCBECB)         ECB POINTER\nPCBCSW   DC    2A(0)               CHANNEL STATUS WORD\n         DC    X'00'\nPCBCCWP  DC    AL3(PCBCCWS)        POINTER TO CCWS\n         DC    X'00'\nPCBDCB   DC    AL3(0)              POINTER TO DCB\n         DC    2A(0)\nPCBSEEK  DC    XL8'00'             SEEK VALUE (MBBCCHHR)\nPCBCCWSC CCW   X'23',PCBSECT,X'40',1  SET SECTOR CCW\nPCBCCWS  CCW   X'31',PCBSEEK+3,X'40',5  SEARCH\n         CCW   X'08',*-8,0,0       TIC\nPCBRWCCW CCW   X'06',PCBBUF,0,PCBPSIZE  READ/WRITE\n         SPACE\nPCBQF    DS    F                   PTR TO NEXT BUFF ON Q\nPCBQB    DS    F                   PTR TO PREV BUFF ON Q\n         DS    0D\nPCBSIZE  EQU   *-PCBSTART              SIZE OF PCB\n./ ADD NAME=PEND\n         MACRO\n         PEND\n         GBLC  &PAGECDE,&CSECT\n         AIF   ('&PAGECDE' EQ 'YES').GO\n         MNOTE 12,'PEND IS ILLEGAL WHEN NOT IN PAGED-CODE'\n         MEXIT\n.GO      ANOP\n         SPACE ,\n         DROP  11\n         SPACE ,\n         BR    14\n         SPACE ,\n         LTORG\n&PAGECDE SETC  ''\n         MEND\n./ ADD NAME=PFCBTSO,SSI=00009361\n* WYLTSO PAGE FILE CONTROL BLOCK\n         SPACE\nPFCBSTRT DS    0F\nPFCBRPT  DC    A(0)                RECORDS/ TRACK\nPFCBPTST DS    A(0)                START OF PAGE TABLE\nPFCBPTND DC    A(0)                END OF PAGE TABLE\nPFCBNP   DC    A(0)                NO. OF PAGES\nPFCBCP   DC    A(0)                CURRENT PAGES USED\nPFCBMASK DC    XL4'1000'           MASK TO OR IN FILE NO.\nPFCBFL   DC    X'00'               FLAGS\n         SPACE\nPFCBFGND EQU   X'80'               END OF GROUP\nPFCBFRPS EQU   X'40'               FILE HAS RPS\n*\nPFCBSECM EQU   19                  MAX SECTOR RECORDS FOR RPS\nPFCBSECT DC    (PFCBSECM)X'00'     DEFINE AREA FOR SECTOR VALUES\n         SPACE\nPFCBDCBA DS    0F                  DCB AREA\nPFCBDCB  DCB   DDNAME=PAGE0,MACRF=(E),DEVD=DA,DSORG=DA\nPFCBDSZ1 EQU   *-PFCBDCB\n         DS    0F\nPFCBPDCB DCB   DDNAME=PAGE0,MACRF=WP,DSORG=PS,OPTCD=C\nPFCBDSZ2 EQU   *-PFCBPDCB\n         DS    0F\nPFCBWRIT WRITE PFCBDECB,SF,0,0,'S',MF=L\n         DS    0F\nPFCBSIZE EQU   *-PFCBSTRT\n./ ADD NAME=PFK      0101-79354-79354-0905-00032-00031-00000-TEC015  00\nPFK01    EQU   X'F1'\nPFK02    EQU   X'F2'\nPFK03    EQU   X'F3'\nPFK04    EQU   X'F4'\nPFK05    EQU   X'F5'\nPFK06    EQU   X'F6'\nPFK07    EQU   X'F7'\nPFK08    EQU   X'F8'\nPFK09    EQU   X'F9'\nPFK10    EQU   X'7A'\nPFK11    EQU   X'7B'\nPFK12    EQU   X'7C'\nPFK13    EQU   X'C1'\nPFK14    EQU   X'C2'\nPFK15    EQU   X'C3'\nPFK16    EQU   X'C4'\nPFK17    EQU   X'C5'\nPFK18    EQU   X'C6'\nPFK19    EQU   X'C7'\nPFK20    EQU   X'C8'\nPFK21    EQU   X'C9'\nPFK22    EQU   X'4A'\nPFK23    EQU   X'4B'\nPFK24    EQU   X'4C'\nENTER    EQU   X'7D'\nRESEND   EQU   X'6E'\nPFKENT   EQU   64\nPFKTYP   EQU   0\nPFKSIZ   EQU   1\nPFKNO    EQU   2\nPFKCMD   EQU   5\nNUMPFK   EQU   24\n./ ADD NAME=PFLIP\n         MACRO\n&L       PFLIP &R,&S\n&L       LR    1,&R\n         LR    &R,&S\n         LR    &S,1\n         MEND\n./ ADD NAME=PFORG\n         MACRO\n         PFORG &F\n         GBLA  &PFCBCNT\n         ORG   (&F)-PFCB+PFCB&PFCBCNT\n         MEND\n./ ADD NAME=PFREE\n         MACRO\n&L       PFREE &R,&T\n         AIF   ('&T' EQ 'EMPTY').LCR\n&L       LTR   1,&R\n         AGO   .X\n.LCR     ANOP\n&L       LCR   1,&R\n.X       ANOP\n         BZ    *+12\n         SR    &R,&R\n         CVCALL PFREE\n         MEND\n./ ADD NAME=PGET\n         MACRO\n&L       PGET  &R,&N\n         LCLC  &LAB\n&LAB     SETC  '&L'\n         AIF   ('&R' EQ '1').NOLOAD\n         AIF   ('&R' EQ 'R1').NOLOAD\n&LAB     LR    1,&R\n&LAB     SETC  ''\n.NOLOAD  ANOP\n&LAB     SYSLR 0,&N,OP=LH\n         CVCALL PGET\n         AIF   ('&R' EQ '1').NLD2\n         AIF   ('&R' EQ 'R1').NLD2\n         LR    &R,1\n.NLD2    ANOP\n         AIF   ('&N' NE '').NOLTR\n         LTR   0,0\n.NOLTR   ANOP\n         MEND\n./ ADD NAME=PINIT\n         MACRO\n         PINIT\n         GBLC  &PAGECDE,&CSECT\n         AIF   ('&PAGECDE' EQ 'YES').GO\n         MNOTE 12,'PINIT IS ILLEGAL WHEN NOT IN PAGED-CODE'\n         MEXIT\n.GO      ANOP\n         SPACE ,\n         DROP  10\n         SPACE 3\n         LTORG\n         EJECT\n* DEFINE THE HEADER FOR THE PAGE-CODE INITIALIZATION ROUTINE\n         SPACE ,\n&CSECT.END DS  0H\n         SPACE ,\n*  THE FOLLOWING USING ESTABLISH ADDRESSABILITY FOR INITIALIZATION\n*  AS USUAL, R12 POINTS TO CP/CV AREA\n         SPACE ,\n         USING &CSECT,11\n         SPACE\n         MEND\n./ ADD NAME=PIOB,SSI=00000157\nPIOBSTRT DS    0D\nPIOBFLG1 DC    X'42'\n         DC    X'00'\nPIOBSNS  DC    X'0000'\n         DC    X'00'\nPIOBECB  DC    AL3(PECB)\nPIOBCSW  DC    2A(0)\n         DC    X'00'\nPIOBCCW  DC    AL3(PCCWS)\n         DC    X'00'\nPIOBDCB  DC    AL3(0)\n         DC    2A(0)\nPSEEK1   DC    XL8'0'\nPSEEKREC EQU   PSEEK1+7\nPSEEK2   DC    XL8'0'\nPSEEK3   DC    XL8'0'\nPCCWS    DS    0D\nPCCWSID1 CCW   X'31',PSEEK1+3,X'40',5\nPCCWTIC1 CCW   X'08',*-8,0,0\nPCCWWRT1 CCW   X'05',0,X'40',CPSIZE\nPCCWSID2 CCW   X'31',PSEEK2+3,X'40',5\nPCCWTIC2 CCW   X'08',*-8,0,0\nPCCWWRT2 CCW   X'05',0,X'40',CPSIZE\nPCCWSID3 CCW   X'31',PSEEK3+3,X'40',5\nPCCWTIC3 CCW   X'08',*-8,0,0\nPCCWWRT3 CCW   X'05',0,0,CPSIZE\nPECB     DC    A(0)\n         DS    0D\nPIOBSIZE EQU   *-PIOB\n./ ADD NAME=PJUNK\n         MACRO\n&L       PJUNK &N\n.*  MODIFIED 9/18/70 BY E. RUSSELL\n&L       SYSLR 0,&N,OP=LH\n         CVCALL PJUNK\n         MEND\n./ ADD NAME=PMAC,SSI=00000164\n         GBLA  &NUMPAGE\n         GBLA  &PAGE0\n*                                                               JEP017\n* MODIFIED AT TO TRIPLE PAGE0 SIZE AND DOUBLE EXEC FILE         JEP017\n*                                                               JEP017\n         GBLA  &PFILES\n         GBLA  &MAXDDS\n*PAGE0   SETA  25*12                                            JEP017\n&PAGE0   SETA   595+20+10+42    MAX WITH 3016 PAGESIZE         JJG\n*NUMPAGE SETA  12                                               JEP017\n&NUMPAGE SETA  16                                               JEP017\n&PFILES  SETA  1\n&MAXDDS  SETA  24\n./ ADD NAME=PMARK\n         MACRO\n&L       PMARK &R\n&L       LR    1,&R\n         CVCALL PMARK\n         MEND\n./ ADD NAME=PMOVE\n         MACRO\n&L       PMOVE &R,&S\n&L       LR    1,&R\n         LR    &R,&S\n         SR    &S,&S\n         CVCALL PFREE\n         MEND\n./ ADD NAME=PNUM\n         MACRO\n&L       PNUM  &R\n&L       LR    1,&R\n         CVCALL PNUM\n         MEND\n./ ADD NAME=PT\n         MACRO\n         PT\n         GBLA  &PFCBCNT\n         LCLA  &X\n.LOOP    ANOP\n&X       SETA  &X+1\nPT&X     DC    (PTSIZE&X)X'FF'\n         AIF   (&X LT &PFCBCNT).LOOP\n         MEND\n./ ADD NAME=READWA\n* WORK AREA DSECT FOR READ COMMAND -- CREATED BY JWW ON 2/4/72\nREADWA   DSECT\nRDWAFL   DS    X                   READ FLAG BYTE\n         SPACE\nRDWAFLNO EQU   X'80'               READ LINE NUMBER GIVEN\nRDWAFDEL EQU   X'40'               DELETE OPTION GIVEN\nRDWAFPRO EQU   X'20'               READ VALUE OR READ STRING\nRDWAFSTR EQU   X'10'               READ STRING\n         SPACE\nRDWACOL1 DS    H                   FIRST COLUMN NO. - 1\nRDWACOL2 DS    H                   SECOND COL NO. - FIRST + 1\nRDWAPRLN DS    H                   READ PROMPT LENGTH\nRDWAPRMT DS    XL62                READ PROMPT AREA\nRDWAVARN DS    H                   NUMBER OF VARIABLES GIVEN\nRDVARMAX EQU   8                   MAX NO. OF VARIABLES ALLOWED\nRDWAVAR  DS    (RDVARMAX)F         VARIABLE ADDRESS SAVE AREA\nRDWALINO DS    F                   READ LINE NUMBER\nRDWASIZE EQU   *-READWA            SIZE OF READ WORK AREA\n./ ADD NAME=REGS\n         MACRO\n         REGS\nR0       EQU   0                        REGISTER DEFINITIONS\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n         MEND\n./ ADD NAME=ROUTBLE,SSI=00009327\n         MACRO\n         ROUTBLE &TYPE\n         AIF   ('&TYPE' EQ 'NAMES').RNAMES\nROUTBLE  DS    0D\n         SPACE ,\n* TABLE ENTRIES ARE 2 HALFWORDS\n* THE FIRST HALFWORD IS THE NUMBER OF THE PAGE CONTAINING THE ROUTINE\n* THE SECOND HALFWORD IS THE DISPLACEMENT IN THAT PAGE TO THE ROUTINE\n*                                                           JEP018\n*                                                           JEP018\n* MOD JEP018                                                JEP018\n*  MODIFIED AT DCEC TO INCLUDE TSOCMDS. JERRY PITTENGER     JEP018\n*                                                           JEP018\n*                                                           JEP018\n         AGO   .ROUTINE\n.RNAMES  ANOP\nROUTNAM  EQU   *\n.ROUTINE ANOP\n&TYPE    ROUTINE BWYLGO,RECOVER,STACK,GODUMP,HELP,DECIDE\n&TYPE    ROUTINE LGOFF,COMPARE,INFO,SUSPND,WHERE,CLEAR\n&TYPE    ROUTINE GOCOLL,MODGO,GOINS,GOREPL,GONUMB\n&TYPE    ROUTINE GOTAB,SHOCOL,GOALINE,DOALINE,GOCENTR\n&TYPE    ROUTINE GOSHO,SHOSIZ,SHONAM,SHODSN,WRICTDR,WRIDSSP\n&TYPE    ROUTINE SHOVOLS,NOMORPG,GOCTLG,SHOCAT\n&TYPE    ROUTINE NTGDCAT,NTGDOPN\n&TYPE    ROUTINE SHOSPAC,DSNERR,GOCOMP,SEND\n&TYPE   ROUTINE GOPUT,STAX,TIME,GOTSO,PROFIL,LSTUSR,TSOCMDS JEP018\n&TYPE    ROUTINE HDSN,HSHOW,HSET,HALIGN,HCATLG,HCENTR,HCHANG\n&TYPE    ROUTINE HCLEAR,HCOLCT,HCOMNT,HCOMP,HCOPY,HDECD\n&TYPE    ROUTINE HDEL,HSET1,HEDIT,HEXCT,HIF,HINSRT\n&TYPE    ROUTINE HJUST,HLIST,HLOAD,HLOGF,HMODFY,HMOVE,HNUM\n&TYPE    ROUTINE HPOINT,HPOP,HPUT,HREAD,HRECAT,HRENM,HREP\n&TYPE    ROUTINE HRESTR,HSAVE,HSCR,HSEND,HSTACK,HCRT,HSUSP\n&TYPE    ROUTINE NOHELP,HTSO,HUNCAT,HUSE,HSET2,HHELP\n         SPACE ,\n         AIF   ('&TYPE' EQ 'NAMES').ROUTNL\nROUTBLEN EQU   *-ROUTBLE\n         MEXIT\n.ROUTNL  ANOP\nROUTNLEN EQU   *-ROUTNAM\n         MEND\n./ ADD NAME=ROUTINE\n         MACRO\n&TYPE    ROUTINE\n.* GENERATE ENTRIES FOR ROUTBLE\n         LCLA  &CNT\n         LCLC  &ROUT\n.LOOP    AIF   (N'&SYSLIST LE &CNT).EXIT\n&CNT     SETA  &CNT+1\n&ROUT    SETC  '&SYSLIST(&CNT)'\n         AIF   ('&TYPE' EQ 'NAMES').ROUTNAM\nR&ROUT   DC    2H'0'\n         AGO   .LOOP\n.ROUTNAM DC    CL7'&ROUT'\n         AGO   .LOOP\n.EXIT    MEND\n./ ADD NAME=RTNCODES\n         SPACE 2\n***  SYMBOLIC NAMES FOR RETURN CODES GOING TO NTGDOPN ROUTINE\n*\nRTNNODS  EQU   4         DATA SET NOT FOUND\nRTNDUPDS EQU   8         DATA SET ALREADY EXISTS\nRTNNOSPC EQU   12        NO SPACE FOR DATA SET\nRTNINUSE EQU   16        DATA SET IN USE\nRTNINVBS EQU   20        INVALID BLOCK SIZE\nRTNILDSN EQU   24        ILLEGAL DSNAME\nRTNILORG EQU   28        INVALID RECFM OR DSORG\n** TALOCODE IS 32 DEFINED IN WYLCONST\n** ABRTCODE IS 36 DEFINED IN WYLCONST\nRTNBDVOL EQU   40        INVALID VOLUME\nRTNBDMBR EQU   44        INVALID MEMBER NAME\nRTNDIRFL EQU   48        DIRECTORY FULL\nRTNEXPDT EQU   52        DATA SET IS EXPIRATION DATE PROTECTED   JW2066\nRTNOVSP  EQU   56        USER HAS EXCEEDED SEQUENTIAL SAVE SPACE**JWW22\nRTNDIRIO EQU   60        DIRECTORY I/O ERROR                     JW2066\nRTNSHERR EQU   80        ERROR IN SHOW DSNAMES/DIRECTORY ROUTINE\nRTNCATER EQU   100       \"CATASTROPHIC\" ERROR\nRTNPAGES EQU   64        INSUFFICIENT PAGES FOR SHO COMMANDS     RTT\nRTNPROT  EQU   68        DATASET PROTECTED BY ORIGINAL OWNER       D008\n./ ADD NAME=SCAN\n         MACRO\n&L       SCAN  &PRT,&NO\n         GBLC  &PAGECDE\n&L       SYSLR 1,&PRT\n         AIF   ('&PAGECDE' NE 'YES').GO\n         AIF   ('&PRT' EQ '').GO\n         AIF   ('&PRT' EQ '0').GO\n         AIF   ('&NO' EQ 'NO').GO\n         SLR   1,10                CONVERT ADDR TO RELATIVE\n         LCR   1,1                     AND MAKE IT NEGATIVE\n.GO      ANOP\n         CVCALL SCAN\n         MEND\n./ ADD NAME=SCANRSTR\n         MACRO\n&L       SCANRSTR &T\n.* MACRO TO RESTORE SCAN POINTERS FROM SPECIFIED SAVE AREA\n         AIF   ('&T' EQ '').DEFLT\n         AIF   ('&T'(1,1) EQ '(').REG   REG SPEC?\n&L       MVC   CPSCAN(6),&T\n         MEXIT\n.DEFLT   ANOP\n&L       MVC   CPSCAN(6),CPTELL\n         MEXIT\n.REG     ANOP\n&L       MVC   CPSCAN(6),0&T\n         MEND\n./ ADD NAME=SCANSAVE\n         MACRO\n&L       SCANSAVE &T\n.* MACRO TO SAVE SCAN POINTERS IN SPECIFIED SAVE AREA\n.* FORMAT OF PARAMETER MAY BE ANY OF THE FOLLOWING FORMS:\n.*   NAME   SYMBOLIC NAME WITH ADDRESSABILITY\n.*   N(R)   RX FORM - OFFSET N FROM REGISTER R\n.*   (R)    REGISTER CONTAINS ADDRESS\n.*   NULL   DEFAULT VALUE\n         LCLA  &LNT,&PTR,&CNT,&SUB\n         LCLC  &C(8)\n&LNT     SETA  K'&T                LENGTH OF OPERAND\n&CNT     SETA  1                   WORK COUNTER\n         AIF   (&LNT EQ 0).DEFLT   CHECK NULL PARM\n         AIF   ('&T'(1,1) EQ '(').REG  CHECK REG FORM\n.SCHLP   ANOP                      SEARCH FOR LEFT PAREN FOR RX FORM\n&CNT     SETA  &CNT+1\n         AIF   (&CNT GT &LNT).GEN  CHECK END OF OPERAND\n         AIF   ('&T'(&CNT,1) NE '(').SCHLP\n.* RX FORM\n&PTR     SETA  1                   SET POINTER TO START OF PARM\n&SUB     SETA  1                   INIT SUBSCRIPT\n.LOOP    ANOP                      SAVE PART OF PARM IN 8 CHAR GROUPS\n         AIF   (&CNT LE 8).HVOP    CHECK LAST GROUP REQ\n&C(&SUB) SETC  '&T'(&PTR,8)        8 CHAR GROUP\n&SUB     SETA  &SUB+1              BUMP SUBSCRIPT\n&PTR     SETA  &PTR+8              BUMP SCAN POINTER\n&CNT     SETA  &CNT-8              REDUCE LENGTH\n         AGO   .LOOP\n.* HAVE LAST GROUP\n.HVOP    ANOP\n&C(&SUB) SETC  '&T'(&PTR,&CNT)     SAVE LAST GROUP\n&PTR     SETA  &PTR+&CNT           BUMP PAST PROCESSED STUFF\n&CNT     SETA  &LNT-((&SUB-1)*8)-&CNT  REMAINING LENGTH\n         AIF   (&PTR GT &LNT).GO   BR IF SECOND PART OF RX PARM\n.* JUST PROCESSED FIRST PART OF RX FORM\n&C(&SUB+1) SETC '6,'               PUT IN EXPLICIT LENGTH\n&SUB     SETA  &SUB+2\n         AGO   .LOOP\n.* FINISHED WITH RX FORM\n.GO      ANOP\n&L       MVC   &C(1)&C(2)&C(3)&C(4)&C(5)&C(6)&C(7)&C(8),CPSCAN\n         MEXIT\n.* DEFAULT VALUE TO BE USED\n.DEFLT   ANOP\n&L       MVC   CPTELL(6),CPSCAN\n         MEXIT\n.* SYMBOLIC NAME - NOT IN RX FORM\n.GEN     ANOP\n&L       MVC   &T.(6),CPSCAN\n         MEXIT\n.* REGISTER FORM\n.REG     ANOP\n&C(1)    SETC  '&T'(2,&LNT-2)\n&L       MVC   0(6,&C(1).),CPSCAN\n         MEND\n./ ADD NAME=SCATBUF\n         ORG   SBUF\nSCBUF    DS    0D        OUTPUT BUFFER FOR SHOW CATALOG\nSCBCODE  DS    CL1       TYPE ENTRY CODE\nSCBNM    DS    CL8       INDEX LEVEL NAME\nSCBNM2   DS    0CL8      OTHER NAME FOR ALIAS ENTRY\nSCBVOL   DS    CL6       VOLUME NAME\n* FOLLOWING TWO FIELDS MUST REMAIN IN ORDER\nSCBMAX   DS    CL1       MAX GDG NAMES\nSCBNVOLS DS    H         NUMBER OF VOLS OR GDG ENTRIES\nSCBSZ    EQU   *-SCBUF   ** MUST BE HALFWORD MULTIPLE **\n./ ADD NAME=SCINIT\n         MACRO\n&L       SCINIT &LOC,&LEN\n&L       SYSLR  1,&LOC,NULL=\n         SYSLR  0,&LEN,NULL=\n         CVCALL SCINIT\n         MEND\n./ ADD NAME=SCKW\n         MACRO\n&L       SCKW  &KP,&XP,&TP,&MP\n         GBLC  &PAGECDE\n         LCLA  &X,&PV,&TV,&AV,&LV\n         LCLC  &RP,&RPP,&AL\n&RP      SETC  '&XP'\n&AL      SETC  'AL3'   USE AL3 FOR RELOCATIBLE ADCONS NOT IN PAGED CODE\n         AIF   ('&RP' NE '').UNZ\n&RP      SETC  '0'\n.UNZ     AIF   ('&PAGECDE' NE 'YES').UNPAG\n&AL      SETC  'AL.24' USE AL.24 FOR ADCONS IN PAGED CODE SO THAT IF\n.*             ARE RELOCATIBLE BY ACCIDENT AN ASSEMBLY ERROR WILL BE\n.*             GENERATED.\n         AIF   ('&RP' EQ '0').UNPAG\n&RPP     SETC  '&SYSECT.-'\n.UNPAG   AIF   ('&KP'.'&TP' EQ '').UNREC\n.LOOP    ANOP\n&X       SETA  &X+1\n         AIF   (&X GT N'&TP).DONE\n         AIF   ('&TP(&X)' EQ 'P').P\n         AIF   ('&TP(&X)' EQ 'S').S\n         AIF   ('&TP(&X)' EQ 'PI').PI\n         AIF   ('&TP(&X)' EQ 'I').I\n         AIF   ('&TP(&X)' EQ 'LN').LN\n         AIF   ('&TP(&X)' EQ 'A').A\n         AIF   ('&TP(&X)' EQ 'POP').POP\n         AIF   ('&TP(&X)' EQ 'PUSH').PUSH\n         MNOTE 12,'***** \"&TP(&X)\" IS ILLEGAL'\n.P       ANOP\n&PV      SETA  1\n         AGO   .LOOP\n.S       ANOP\n&TV      SETA  1\n         AGO   .LOOP\n.PI      ANOP\n&TV      SETA  2\n.ICOM    AIF   ('&MP' EQ '').LOOP\n&TV      SETA  &TV+1\n         AGO   .LOOP\n.I       ANOP\n&TV      SETA  4\n         AGO   .ICOM\n.LN      ANOP\n&TV      SETA  6\n         AGO   .LOOP\n.A       ANOP\n&AV      SETA  1\n         AGO   .LOOP\n.DONE    ANOP\n         AIF   ('&KP' EQ '').NOKW\n&LV      SETA  K'&KP-1\n         AIF   ('&KP'(1,1) NE '''').NOQ\n&LV      SETA  &LV-2\n.NOQ     ANOP\n         AIF   (&LV LT 8).NOKW\n&LV      SETA  7\n.NOKW    ANOP\n&X       SETA  &PV*128+&TV*16+&AV*8+&LV\n         AIF   ('&KP' EQ '').NOKPQ\n         AIF   ('&KP'(1,1) NE '''').NOKPQ\n&L       DC    AL1(&X),&AL.(&RPP.&RP),CL(&LV+1)&KP\n         AGO   .LIM\n.NOKPQ   ANOP\n&L       DC    AL1(&X),&AL.(&RPP.&RP),CL(&LV+1)'&KP '\n.LIM     ANOP\n         AIF   (&TV LT 2 OR &TV GT 5).END\n         AIF   ('&MP' EQ '').END\n         DC    AL4(&MP)\n         MEXIT\n.UNREC   ANOP\n&L       DC    X'FF',&AL.(&RPP.&RP)\n         MEXIT\n.POP     ANOP\n&L       DC    X'F9'\n         MEXIT\n.PUSH    ANOP\n&L       DC    X'F8',&AL.(&RPP.&RP)\n.END     MEND\n./ ADD NAME=SCTELL\n         MACRO\n&L       SCTELL\n&L       CVCALL SCTELL\n         MEND\n./ ADD NAME=SCTYPE\n         MACRO\n&L       SCTYPE &T\n&L       SYSLR 1,&T\n         XCALL SCTYPE\n         MEND\n./ ADD NAME=SDSNBUF\nSBUF     DS    0D        OUTPUT BUFFER FOR SHOW DSNAMES\nSBDSN    DS    CL44      DSNAME\nSBCRDT   DS    CL3       CREATION DATE\nSBEXDT   DS    CL3       LAST ACCESS AT SLAC\nSBNOEX   DS    CL1       NO. OF EXTENTS\nSBDSORG  DS    CL1       DSORG\nSBRECFM  DS    CL1       RECFM\nSBKEYL   DS    CL1       KEY LENGTH\nSBLRECL  DS    H         LRECL\nSBBLKSZ  DS    H         BLKSIZE\nSBLB     DS    0H,CL5    LAST BLOCK - TTRLL\nSBACCTG  DS    CL1       ACCOUNTED FOR FLAG\nSPTRK    DS    H         TRACKS ALLOC\nSBPROTF  DS    CL1       PROTECTION FLAG\n         DS    CL1       SPARE\nSBSZ     EQU   *-SBUF    ** MUST BE HALFWORD MULTIPLE **\n./ ADD NAME=SENDH\n         MACRO\n&H       SENDH\n         SPACE\n* REG 3 CONTAINS ADDR(LAST LINE-1)\n* REG 2 CONTAINS ADDR(1ST LINE-1)\n         SPACE\n&H       SR    R4,R4              ZERO R4\nH&SYSNDX IC    R4,0(,R2)          GET LENGTH OF LINE\n         LA    R1,1(,R2)          GET ADDR(LINE)\n         TSEG  (1),(4),W\n         BP    CVQTYPE\n         CR    R2,R3              IS THIS THE LAST LINE?\n         BE    CVGETCOM           BR IF IT IS.\n         LA    R2,1(R2,R4)        GET ADDR. OF LENGTH OF NEXT LINE\n         B     H&SYSNDX           GO OUTPUT THE REST\n         MEND\n./ ADD NAME=SENTER\n         MACRO\n&L       SENTER &R,&S,&SZ\n         GBLC  &PAGECDE\n         AIF   ('&L' EQ '').NEP\n         ENTRY &L\n.NEP     ANOP\n&L       DS    0H\n         AIF   ('&S' EQ '').NT2\n         STM   &R,&S,0(13)\n         AIF   ('&SZ' EQ '').NWA\n         AIF   ('&SZ' EQ '*').MIN\n.SIZ     ANOP\n         LR    8,13\n         LA    13,(&SZ+3)/4*4(,13)\n         AGO   .NWA\n.MIN     AIF   (&R GT &S).WRP\n         LR    8,13\n         LA    13,(&S+1-(&R))*4(,13)\n         AGO   .NWA\n.WRP     ANOP\n         LR    8,13\n         LA    13,(&S+17-(&R))*4(,13)\n         AGO   .NWA\n.NT2     ANOP\n         AIF   ('&R' EQ '').NWA\n         ST    &R,0(,13)\n         AIF   ('&SZ' EQ '').NWA\n         AIF   ('&SZ' NE '*').SIZ\n         LR    8,13\n         LA    13,4(13)\n.NWA     ANOP\n         AIF   ('&PAGECDE' EQ 'YES').EXIT\n         BALR  7,0\n         USING *,7\n.EXIT    MEND\n./ ADD NAME=SETSM\n         MACRO\n&L       SETSM &MASK\n&L       DC    0H'0',X'80',AL1(&MASK),S(*-1)\n         MEND\n./ ADD NAME=SEXIT\n         MACRO\n&L       SEXIT &R,&S,&CUE,&PFREE\n         GBLC  &PAGECDE\n&L       DS    0H\n         AIF   ('&CUE' EQ '').NLR\n         LR    13,8\n.NLR     AIF   ('&S' EQ '').NT2\n         LM    &R,&S,0(13)\n         AGO   .OUT\n.NT2     AIF   ('&R' EQ '').OUT\n         L     &R,0(,13)\n.OUT     ANOP\n         AIF   ('&PAGECDE' EQ 'YES').OUTP\n.OUTP1   BR    14\n         MEXIT\n.OUTP    AIF   ('&PFREE' EQ '').OUTP1\n         B     CVROUTEX            PFREE ROUTINE PAGE AND EXIT\n         MEND\n./ ADD NAME=SHODSN\n         MACRO\n         SHODSN\n         ORG   DBUF\nLASTFMT1 DS    CL5 .               LAST VALID FORMAT 1 DSCB\nSEARFMT1 DS    CL5 .               START OF SEARCH ID\nTRKSPCYL DS    H .                 # OF TRKS/CYL\nCURRDSCB DS    A .                 PTR TO CURRENT DSCB\nLASTDSCB DS    A .                 PTR TO LAST DSCB READ IN\nDSCBPTRK DS    H .                 # OF DSCB'S PER TRK\nDSCBNUM  DS    H .                 # OF CURRENT DSCB\n         DS    0D .                ALIGNMENT\nVTOCPGM  DS    2D .                SEARCH & TIC CCW\n         DS    20D .               PGM TO READ 20 DSCB'S AT A TIME\nDSCBBUFF DS    20CL148 .           ROOM FOR 20 DSCB'S\n         ORG   ,\n         MEND\n./ ADD NAME=SVCS\n*  SVC NUMBER DEFINITIONS\n         SPACE\nSVCGEN2  EQU   243                     GEN PURPOSE TYPE 2 SVC\nSVCACME  EQU   244\nSVCSTAT  EQU   254                     JOB STATUS SVC\nSVCMIL   EQU   251\nSVCHASP  EQU   255                     HASP SVC\n./ ADD NAME=SYSKWT\n         MACRO\n&L       SYSKWT &NAME,&KWS,&LEGAL\n         LCLA  &X,&Y\n&X       SETA  1\n.LOOP    AIF   (&X GT N'&KWS).END\n&Y       SETA  1\n.LUP     AIF   (&Y GT N'&LEGAL).ERROR\n         AIF   ('&KWS(&X)' EQ '&LEGAL(&Y)').LUPEND\n&Y       SETA  &Y+1\n         AGO   .LUP\n.ERROR   MNOTE 12,'\"&KWS(&X)\" IS AN ILLEGAL &NAME'\n.LUPEND  ANOP\n&X       SETA  &X+1\n         AGO   .LOOP\n.END     MEND\n./ ADD NAME=SYSLR\n         MACRO\n&L       SYSLR &R,&P,&TYPE=,&SELECT=,&NULL=0,&ERR=,&OP=LA\n         LCLA  &X,&Y,&PT,&KC(8)\n         LCLB  &LCR\n         LCLC  &C(8),&LABEL,&OPC\n         AIF   ('&TYPE' EQ '').GO\n&LCR     SETB  1\n         AIF   ('&SELECT' EQ '').GO\n&X       SETA  1\n.LUP     AIF   (&X GT N'&TYPE).LUPEND\n&Y       SETA  1\n.LUPTOO  AIF   (&Y GT N'&SELECT).LUPGO\n         AIF   ('&TYPE(&X)' EQ '&SELECT(&Y)').GO\n&Y       SETA  &Y+1\n         AGO   .LUPTOO\n.LUPGO   ANOP\n&X       SETA  &X+1\n         AGO   .LUP\n.LUPEND  ANOP\n&LCR     SETB  0\n.GO      ANOP\n         AIF   ('&P' NE '').NBL\n         AIF   ('&ERR' EQ '').NERR\n         MNOTE 12,&ERR\n.NERR    AIF   ('&NULL' EQ '').LBL\n         AIF   ('&NULL' EQ '0').SR\n&L       &OP   &R,&NULL\n         AGO   .COM\n.LBL     ANOP\n         AIF   ('&L' EQ '').END\n&L       DS    0H\n         MEXIT\n.NBL     AIF   ('&P'(1,1) EQ '(').REG\n         AIF   ('&P' EQ '0').SR\n&LABEL   SETC  '&L'\n         AIF   (K'&P LT 2).EXPR\n         AIF   ('&P'(1,2) EQ 'L:').L\n         AIF   (K'&P LT 3).EXPR\n         AIF   ('&P'(1,3) EQ 'LA:').LA\n         AIF   ('&P'(1,3) EQ 'LH:').LA\n         AIF   ('&P'(1,3) NE 'IC:').EXPR\n&L       SR    &R,&R\n&LABEL   SETC  ''\n.LA      ANOP\n&PT      SETA  2\n         AGO   .DO\n.L       ANOP\n&PT      SETA  1\n.DO      ANOP\n&X       SETA  1\n.LOOP    AIF   (K'&P LE &X*8).BIT\n&KC(&X)  SETA  8\n&C(&X)   SETC  '&P'((&X-1)*8+1,8)\n&X       SETA  &X+1\n         AGO   .LOOP\n.BIT     ANOP\n&KC(&X)  SETA  K'&P-(&X-1)*8\n&C(&X)   SETC  '&P'((&X-1)*8+1,&KC(&X))\n&C(1)    SETC  '&C(1)'(&PT+2,&KC(1)-&PT-1)\n&OPC     SETC  '&P'(1,&PT)\n&LABEL   &OPC  &R,&C(1)&C(2)&C(3)&C(4)&C(5)&C(6)&C(7)&C(8)\n         AGO   .COM\n.EXPR    ANOP\n&L       &OP   &R,&P\n.COM     AIF   (NOT &LCR).END\n         LCR   &R,&R\n         MEXIT\n.SR      ANOP\n&L       SR    &R,&R\n         MEXIT\n.REG     AIF   (&LCR).LCR\n         AIF   ('(&R)' EQ '&P').LBL\n&L       LR    &R,&P\n         MEXIT\n.LCR     ANOP\n&L       LCR   &R,&P\n.END     MEND\n./ ADD NAME=SYSQ\n*\n* SYSTEM (OS) INPUT MESSAGE QUEUE FORMAT\n*\nSYSQNEXT DC    A(0)        ADDRESS OF NEXT BUFFER IN INPUT QUEUE\nSYSQLEN  DC    H'0'        ACTUAL LENGTH OF CURRENT MESSAGE\n         DC    X'0'        UNUSED\nSYSQUCMI DC    AL1(0)      ID OF ORIGINATING OPR CONSOLE\nSYSQBUF  DC    CL126' '    MESSAGE TEXT\nSYSQBUFL EQU   L'SYSQBUF   MAXIMUM LENGTH OF MESSAGE TEXT\nSYSQSIZE EQU   *-SYSQNEXT  TOTAL SIZE OF QUEUE BUFFER\n./ ADD NAME=SYSQS\n         MACRO\n&L       SYSQS &AR,&LR,&AP,&LP\n         LCLA  &X,&N\n         LCLC  &C\n         AIF   ('&AP' EQ '').NSTR\n         AIF   ('&AP'(1,1) EQ '''').STR\n.NSTR    ANOP\n&L       SYSLR &AR,&AP,ERR='***** LOCATION MISSING *****'\n.LL      AIF   ('&LR' EQ '').END\n         SYSLR &LR,&LP,ERR='***** LENGTH MISSING *****'\n         MEXIT\n.STR     AIF   ('&LP' NE '').LG\n&L       LA    &AR,=C&AP\n&X       SETA  1\n&C       SETC  '&&'\n.LOOP    ANOP\n&X       SETA  &X+1\n         AIF   (&X GE K'&AP).EL\n&N       SETA  &N+1\n         AIF   ('&AP'(&X,1) NE '''' AND '&AP'(&X,1) NE '&C'(1,1)).LOOP\n&X       SETA  &X+1\n         AGO   .LOOP\n.EL      LA    &LR,&N\n         MEXIT\n.LG      ANOP\n&L       LA    &AR,=CL(&LP)&AP\n         AGO   .LL\n.END     MEND\n./ ADD NAME=TALO\n         MACRO\n&L       TALO\n&L       CVCALL TALO\n         MEND\n./ ADD NAME=TATNRDR\n         MACRO\n&L       TATNRDR &LOC,&LEN,&CHAR,&CHRB\n&L       SYSQS 1,0,&LOC,&LEN\n         LA    15,C'&CHAR'\n         AIF   (N'&SYSLIST(4) EQ 0).A\n         SLL   15,8\n         LA    15,C'&CHRB'(,15)\n.A       LCR   15,15\n         CVCALL TRDRTN\n         MEND\n./ ADD NAME=TESTPCB\n         MACRO\n&LABEL   TESTPCB &REG,&EXIT=\n         LCLC  &TARGET\n&TARGET  SETC  '&LABEL'\n         AIF   ('&EXIT' EQ '').NORMAL\n&TARGET  C     &REG,CVCPADDR .     VCP?\n         BE    &EXIT .             YES.. IGNORE CALL\n&TARGET  SETC  ''\n.NORMAL  ANOP\n&TARGET  C     &REG,CVFPAGE .      LOW?\n         BNL   LOK&SYSNDX\n         DC    H'0' .              KILL\nLOK&SYSNDX C   &REG,CVLPAGE .      HIGH?\n         BNH   HOK&SYSNDX\n         DC    H'0' .              KILL\nHOK&SYSNDX EQU   *\n         MEND\n./ ADD NAME=TMARK\n         MACRO\n&L       TMARK\n&L       CVCALL TMARKX\n         MEND\n./ ADD NAME=TRACER\n         MACRO\n         TRACER &A\n         GBLC  &TRACEEE\n&TRACEEE SETC  '&A'\n         MEND\n./ ADD NAME=TREAD\n         MACRO\n&L       TREAD\n.*  MODIFIED 9/18/70 BY E. RUSSELL\n&L       CVCALL TREADX\n         MEND\n./ ADD NAME=TREADR\n         MACRO\n&L       TREADR &LOC,&LEN,&QM=YES\n&L       SYSQS 1,0,&LOC,&LEN\n         AIF   ('&QM' EQ 'NO').NQM\n         SR    15,15\n         AGO   .CALL\n.NQM     LA    15,4\n.CALL    ANOP\n         CVCALL TRDRTN\n         MEND\n./ ADD NAME=TREDE\n         MACRO\n&L       TREDE\n&L       LA    15,4\n         CVCALL TREADX\n         MEND\n./ ADD NAME=TSEG\n         MACRO\n&L       TSEG  &LOC,&LEN,&TYPE\n         LCLC  &C\n&L       SYSQS 1,0,&LOC,&LEN\n         AIF   ('&TYPE' EQ '').CALL\n&C       SETC  '&TYPE'(1,1)\n.CALL    ANOP\n         CVCALL TSEGX&C\n         MEND\n./ ADD NAME=TTABS\n         MACRO\n&L       TTABS &A\n&L       SYSLR 1,&A\n         XCALL TTABS\n         MEND\n./ ADD NAME=TWRITE\n         MACRO\n&L       TWRITE\n&L       CVCALL TWRITEX\n         MEND\n./ ADD NAME=TXCTL\n         MACRO\n&L       TXCTL &A\n&L       SYSLR 1,&A\n         CVCALL TXCTL\n         MEND\n./ ADD NAME=VCPTSO\nDVCP     DSECT\nVCP#SVAR EQU   10                 # OF STRING VARIABLES\nVCPR     EQU   9                  BASE REG\nVCPWVAR  DS    XL40               LINE # AREA\nVCPLVAR  EQU   VCPWVAR\nVCPNVAR  DS    XL40               INTEGER AREA\nVCPSVAR  DS    XL752              STRING AREA\nVCPLSVA  EQU   *-VCPSVAR          LENGTH OF STRING AREA\nVCPLNG   EQU   *-DVCP\n./ ADD NAME=WDIOWA   0100-80113-80113-1547-00369-00369-00000-$SYS13  00\n         MACRO\n&NM      WDIOWA &TYPE\n         SPACE ,\n         AIF   ('&TYPE' EQ '').NOSECT\n         AIF   ('&TYPE'(1,1) EQ 'C').CSECT\n         AIF   ('&TYPE'(1,1) EQ 'D').DSECT\n         MNOTE 4,'&TYPE INVALID - IGNORED'\n         AGO   .NOSECT\n.DSECT   ANOP\n&NM      DSECT\n         AGO   .START\n.CSECT   ANOP\n&NM      CSECT\n         AGO   .START\n.NOSECT  ANOP\n&NM      DS    0D\n.START   ANOP\n*                                                               JEP013\n*                                                               JEP013\n* MOD JEP013                                                    JEP013\n*  CHANGED DEFAULT NAME FROM WYL.CU.CTR.VTOC TO FDRABR  ITEL    JEP013\n*  DENOTED JEP013 IN 66/71.  JERRY PITTENGER                    JEP013\n*                                                               JEP013\n         SPACE 2\n         DS    0D\nWADECB   DC    AL1(255),AL3(DECB)\nUCB      DC    A(0)      UCB ADDR FOR SPEC VOLUME\n         SPACE\nDFL      DC    X'00'     FLAGS\n         SPACE ,\nDFREPL   EQU   X'08'     STOW REPL TO BE DONE AT CLOSE\nDFUPTSPC EQU   X'02'     UPDATE SPACE ACCTG AT CLOSE\nDFUSPCNM EQU   X'01'     NO COND SHOW SPACE CALL IF ON\n         SPACE 2\nFLAGS    DS    CL5       SAVE DSNAME FLAGS\nF1       EQU   FLAGS          FIRST DSNAME FLAG\nF2       EQU   FLAGS+1        SECOND DSNAME FLAG\nF3       EQU   FLAGS+2        THIRD DSNAME FLAG\nF4       EQU   FLAGS+4        FOURTH DSNAME FLAG\nF5       EQU   FLAGS+5        FIFTH DSNAME FLAG\n         SPACE ,\nDSDD     DC    CL8'IOVVVVVV'  DDNAME\n         SPACE 2\n* EXLST FOR DCB\nEXLST    DS    0F\n         DC    X'00'               ENTRY TO BE FILLED IN\n         DC    AL3(0)\n         DC    X'87'               LAST ENTRY/JFCB POINTER\n         DC    AL3(JFCB)\n         SPACE 2\n* IOB FOR EXCP\nIOB      DS    0D\n         DC    XL2'C200'\nIOBSNS   DC    H'0'\n         DC    A(DECB)\nIOBCSW   DC    2F'0'\nIOBSTART DC    F'0'\n         DC    A(FOURS)       DCB\n         DC    2F'0'\n         DC    XL1'0'\nIOBB     DC    XL2'0'\nSEEK     DC    XL5'0'\n         SPACE 2\n* CHANNEL PROGRAM FOR EXCP\nMT       EQU   X'80'          MULTI-TRACK\nSCHIDEQ  EQU   X'31'          SEARCH ID EQUAL\nTIC      EQU   X'08'          XFER IN CHANNEL\nSCHKYEQ  EQU   X'29'          SEARCH KEY EQUAL\nSCHKYHI  EQU   X'49'          SEARCH KEY HIGH\nSCHKYHE  EQU   X'69'          SEARCH KEY HI OR EQUAL\nSCHKADEQ EQU   X'2D'          SEARCH KEY AND DATA EQUAL\nSCHKADHI EQU   X'4D'          SEARCH KEY AND DATA HIGH\nSCHKADHE EQU   X'6D'          SEARCH KEY AND DATA HI OR EQUAL\nSWKADKY  EQU   SCHKADHE-SCHKYHE    USED TO SWAP SCH KAD/SCH KEY\nRDCNT    EQU   X'12'          READ COUNT\nRDDATA   EQU   X'06'          READ DATA\nRDKYDATA EQU   X'0E'          READ KEY AND DATA\nNOPIC    EQU   X'03'          NOP IN CHANNEL\nCC       EQU   X'40'          COMMAND CHAIN\nDC       EQU   X'80'          DATA CHAIN\nSLI      EQU   X'20'          SLI\nSKP      EQU   X'10'          SKIP DATA XFER\n         SPACE ,\nSRCHCCW  CCW   SCHIDEQ,SEEK,CC+SLI,5         SEARCH FOR PREV REC\n         CCW   TIC,SRCHCCW,CC+SLI,0\nCCWSW    CCW   TIC,ID,CC+SLI,0               SWITCH BETWEEN ID & PDSRD\nID       CCW   SCHIDEQ+MT,ENDTEST,CC+SLI,5   LAST VTOC REC?\n         CCW   TIC,KEY,CC+SLI,0              TIC IF NO\n         CCW   TIC,ENDCCW1,CC+SLI,0          TIC IF YES\n*              LENGTH FIELD IS CHANGED IN FOLLOWING CCW\nKEY      CCW   SCHKADEQ+MT,DSNAME,CC+SLI,0   IS REC ONE WE WANT?\n         CCW   TIC,ID,CC+SLI,0               TIC IF NO\n         CCW   RDCNT+MT,SRCHC,SLI,5          READ ADDR OF FOLL REC\n* END OF THIS PART OF COMMAND CHAIN\n         SPACE 2\n*              LENGTH FIELD IS CHANGED IN FOLLOWING CCW\nENDCCW1  CCW   SCHKADEQ,DSNAME,CC+SLI,0  IS LAST VTOC REC ONE WE WANT?\n         CCW   TIC,ENDCCW,CC+SLI,0       TIC IF NO\n         CCW   NOPIC,SEEK,CC+SLI+SKP,1   DUMMY CMND\nENDCCW2  CCW   SCHIDEQ,ENDTEST,CC+SLI,5  SO WE CAN SEARCH AGAIN\n         CCW   TIC,ENDCCW2,CC+SLI,0\nREADCCW2 CCW   RDKYDATA,DS1DSNAM,SLI,DS1END-DS1DSNAM  READ DSCB\n* END OF THIS PART OF COMMAND CHAIN\n         SPACE 2\nENDCCW   CCW   NOPIC,SEEK,SLI,1      DUMMY CMD TO FLAG END OF SEARCH\n* IF FINAL CSW POINTS HERE THEN THE VTOC HAS BEEN COMPLETELY SEARCHED\n         SPACE ,\n* CHANNEL PROGRAM RESTARTED HERE IF A RECORD FOUND WE WANT\nREADCCW  CCW   SCHIDEQ,SRCHC,CC+SLI,5     SEARCH FOR THE ONE WE WANTED\n         CCW   TIC,READCCW,CC+SLI,0\n         CCW   RDKYDATA,DS1DSNAM,SLI,DS1END-DS1DSNAM    READ DSCB\n* END OF THIS PART OF COMMAND CHAIN\n         SPACE 2\n* CHANNEL PROGRAM SECTION FOR READING PDS DIRECTORY\nPDSREAD  CCW   RDCNT+MT,SRCHC,CC+SLI,5\n         CCW   RDKYDATA,DBUF,SLI,264\n         SPACE 3\n* MISCELLANEOUS WORK AREAS AND CONSTANTS\nCCREDT   DS    D\nDSNAME   DS    CL44\nDSN      DC    44X'04'\n         SPACE ,\nBLDL     DS    0F\n         DC    H'1'           ONE ENTRY\n         DC    AL2(BLDLSZ)    LENGTH OF ENTRY\nMEMBER   DS    CL8            MEMBER NAME\nBLDLTTR  DS    CL3            MEMBER TTR\nBLDLKZC  DS    CL3            OTHER BLDL TRASH\nBLDLSZ   EQU   *-MEMBER\n         ORG   BLDLKZC+1      STOW REQUIRES C BUT NOT K AND Z\nSTOWLTTR DS    F              DATE OF LAST STOW OR SSI\nSTOWSZ   EQU   *-MEMBER       SIZE OF DIRECTORY ENTRY STOWED\n         SPACE ,\nRRECFM   DS    CL1            RECFM\n         SPACE ,\nSCRVLST  DS    0F             SCRATCH LIST AND OTHERS\n         DC    H'1'           NUMBER OF VOLUMES\nDEVCODE  DS    CL4            RESULT OF DEVTYPE\nDSVID    DS    CL6            VOLUME ID\n         DC    X'0'           BYTE OF ZERO\nSCRRET   DC    X'0'           RETURN CODE FROM SCRATCH\n         SPACE 3\nVTOCCCW  DC    AL3(ID)        TIC ADDR FOR SHOW DSNAMES\nPDSCCW   DC    AL3(PDSREAD)   TIC ADDR FOR SHOW DIRECTORY\nLASTCCW  DC    AL3(ENDCCW+8)  ADDR IN CSW WHEN VTOC SEARCH DONE\nLASTCCW1 DC    AL3(ENDCCW)    ADDR IN CSW WHEN LAST VTOC REC WANTED\nRECSIZE  DS    F\nLRECSIZE DS    F\nERROR    DS    F\nSPACE    DS    F\nDEVBLOCK DS    F              DEVICE BLOCK SIZE\nRETCOD   DS    F\n         EJECT\n* DECBS AND PARAMTER LISTS\n         SPACE ,\n         READ  DECB,SF,DCB,DBUF,MF=L\n         SPACE 3\nDSCB     CAMLST SEARCH,DSNAME,DSVID,DS1FMTID\n         SPACE 3\nSCRLST   CAMLST SCRATCH,DSNAME,,SCRVLST\n         SPACE 3\nUSCATL   CAMLST NAME,DSNAME,,CATBLOCK\n         SPACE 3\nUSCATL2  CAMLST BLOCK,CATNTTR,CATVOLID,CATBLOCK\nCAMVOLID EQU   USCATL2+8      ADDR OF VOLUME ID PTR IN PREV LIST A26\n         SPACE 3\nVTOC     CAMLST SEARCH,DSN,DSVID,VTOCAREA\n         SPACE 3\nVTOC3    CAMLST SEEK,DS1PTRDS,DSVID,IECSDSL3\n         SPACE 3\nCATLST   CAMLST CAT,DSNAME,,SCRVLST     USED FOR CAT/UNCAT/RECAT\n         SPACE 3\nOPENLIST OPEN  (DCB),MF=L\n         SPACE 3\nENQDSN   ENQ   (,DSNAME,,,SYSTEM),RET=USE,MF=L\n         EJECT\n* DUMMY  DCBS\n         SPACE 2\n* DUMMY DCB TO ALLOCATE SPACE FOR DCB TO BE MOVED IN\nDCB      DCB   DSORG=PS,MACRF=(RP,WP)\n         EJECT\nFOURS    DCB   DSORG=PS,MACRF=E,EXLST=EXLST\n         EJECT\n***  THE DATA BUFFER IS ALSO USED AS A WORK AREA AND FOR READING\n**    VARIOUS CONTROL BLOCKS.  IT IS CAREFULLY CONSTRUCTED SO\n**    THAT AREAS WHICH ARE REQUIRED SIMULTANEOUSLY DO NOT OVERLAY\n**    EACH OTHER.  THE OVERLAY STRUCTURE IS AS FOLLOWS:\n*\n**   DBUF      FMT 4 DSCB WORK AREA\n**     |       SHOW DSNAMES WORK AREA\n**     |       JFCB AREA\n**     |       LOCATE VOL WORK AREA\n**     |       REST OF CATLG BLOCK AREA      DSCB1/3/5 WORK AREAS\n**     |                 |                            V\n**     |                 V\n**     |       SHOW DSNAMES BUFFER           SHOW CATLG BUFFER\n**     |                 |                   CLEAR JFCB WORK AREA\n**     |                 V                            |\n**     |                                              V\n**     |                                     SUBTASK R13 REG SV AREA\n**     |                                              V\n**     |\n**     V\n         SPACE 3\n* DAIR INTERFACE:\nWAUPT    DC    A(0)\nWAECT    DC    A(0)\nWAECB    DC    A(WADARECB)\nWAPSCB   DC    A(0)\nWADAIR   DC    A(DA08CD)\nWADARECB DC    F'0'\nDAIRDSN  DC    AL2(44)                                          JEP013\nDSNPREF  DC    CL44'FDRABR'                                     JEP013\n***********************************************************************\n* THIS OPERATION CODE CAUSES ALLOCATION OF A DATA SET. IT CAN ALLOC.  *\n* EITHER A NEW OR OLD SET.                                            *\n***********************************************************************\n         DS    0F\nDA08CD   DC    AL2(8)   DAIR ENTRY CODE\nDA08FLG  DC    X'00'    FUNCTIONS TO BE PERFORMED WHEN RET CODE IS 0\nDA08FPE  EQU   X'80'    FUNCT PERFORMED BUT ERROR INDICATED BY RETCD\n         DC    X'00'\nDA08DARC DC    H'0'     DYN ALLOC RETURN CODE\nDA08CTRC DC    H'0'     CATALOG RETURN CODE\nDA08PDSN DC    A(DAIRDSN)   PTR TO DSNAME TO BE SEARCHED IN DSE\nDA08DDN  DC    CL8' '   DDNAME TO BE SEARCHED IN DSE\nDA08UNIT DC    CL8' '   UNITNAME REQUESTED\nDA08SER  DC    CL8' '   VOLUME SERIAL NUMBER-PADDED W/BLANKS\nDA08BLK  DC    F'0'     DATA SET  AVERAGE RECORD LENGTH\nDA08PQTY DC    F'0'     PRIMARY SPACE QUANTITY\nDA08SQTY DC    F'0'     SECONDARY SPACE QUANTITY\nDA08DQTY DC    F'0'     DIRECTORY BLOCK QUANTITY\nDA08MNM  DC    CL8' '   MEMBER NAME\nDA08PSWD DC    CL8' '   PASSWORD\nDA08DSP1 DC    X'08'    DATA SET STATUS FLGS(IF=0 OLD ASSUMED)\nDA08SHR  EQU   X'08'    DATA SET IS SHR\nDA08NEW  EQU   X'04'    DATA SET IS NEW\nDA08MOD  EQU   X'02'    DATA SET IS MOD\nDA08OLD  EQU   X'01'    DATA SET IS OLD\nDA08DPS2 DC    X'08'    DATA SET DISPOSITION(IF=0 KEEP ASSUMED)\nDA08KEEP EQU   X'08'    DS DISP IS KEEP\nDA08DEL  EQU   X'04'    DS DISP IS DELETE\nDA08CAT  EQU   X'02'    DS DISP IS CATLG\nDA08UCAT EQU   X'01'    DS DISP IS UNCATALOG\nDA08DPS3 DC    X'08'    DATA SET CONDITIONAL DISPOSITION\nDA08KEP  EQU   X'08'\nDA08DELE EQU   X'04'\nDA08CATL EQU   X'02'    DS DISP OF CATLG DESIRED\nDA08UNCT EQU   X'01'    DS DISP OF UNCATLG DESIRED\nDA08CTL  DC    X'08'    FLAGS TO CONTROL ACTIONS TAKEN BY DAIR\nDA08TRKS EQU   X'80'    UNITS ARE TRKS\nDA08ABKL EQU   X'40'\nDA08CYLS EQU   X'C0'    UNITS ARE CYLS\nDA08UID  EQU   X'20'    USER ID IS TO BE PREFIXED\nDA08RLSE EQU   X'10'    RELEASE (RLSE) REQUESTED\nDA08PERM EQU   X'08'    DATA SET MUST BE SPECIFICALLY UNALLOCATED\nDA08DMMY EQU   X'04'\nDA08ATRL EQU   X'02'    ATTRIBUTE LIST SUPPLIED\n         DC    XL3'00'  RESERVED\nDA08DSO  DC    XL1'00'  DSORG\nDA08ALN  DC    CL8' '   ATTR-LIST-NAME\n***********************************************************************\n* THIS OPERATION CAUSES THE REQUESTED DATA SET OR DDNAME TO BE        *\n* UNALLOCATED. DISPOSITION CAN BE SPECIFIED TO OVERRIDE ANY PREVIOUS  *\n* DISPOSITION. LIKENISE SYSOUT CLASS MAY BE SPECIFIED TO OVERRIDE ANY *\n* PREVIOUS CLASS.                                                     *\n***********************************************************************\n         DS    0F\nDA18CD   DC    AL2(24)  DAIR ENTRY CODE\nDA18FLG  DC    X'00'    FUNCTIONS TO BE PERFORMED WHEN RET CODE IS 0\nDA18FPE  EQU   X'80'    FUNCT PERFORMED BUT ERROR INDICATED BY RETCD\n         DC    X'00'\nDA18DARC DC    H'0'                    DYNAMIC ALLOCATION RETURN CODE\nDA18CTRC DC    H'0'               CATALOG RETURN CODE AREA\nDA18PDSN DC    A(0)         PTR TO DSNAME TO BE SEARCHED IN DSE\nDA18DDN  DC    CL8' '   DDNAME TO BE SEARCHED IN DSE\nDA18MNM  DC    CL8' '   MEMBER NAME\nDA18SCLS DC    CL2' '   SYSOUT CLASS DESIRED WHEN UNALLOCATING  A\n*                       SYSOUT DATA SET\nDA18DPS2 DC    X'08'    DATA SET DISPOSITION\nDA18KEEP EQU   X'08'    CHANGE DISP TO KEEP\nDA18DEL  EQU   X'04'    CHANGE DISP TO DELETE\nDA18CAT  EQU   X'02'    CHANGE DISP TO CATALOG\nDA18UCAT EQU   X'01'    CHANGE DISP TO UNCATLOG\nDA18CTL  DC    X'10'    FLAGS FOR SPECIAL DAIR PROCESSING\nDA18UID  EQU   X'20'    USER ID IS TO BE PREFIXED TO DSNAME\nDA18PERM EQU   X'10'    UNALLOCATE PERM. ALLOCATED DSE'S\nDA18JBNM DC    CL8' '\n         SPACE ,\nATTDECB  DC   A(0)                 ECB FOR ATTACH\nWATTACH  ATTACH EP=IKJEFT01,ECB=ATTDECB,SF=L\n         DS    0F\nWASTAX   DC    5A(0)               STAX PARAMETER LIST\nDBUF     DS    0D\nDBUFSIZE EQU   13030\nACCTWA   EQU   DBUF       ACCOUNTING WORK AREA\n         DS    (DBUFSIZE)C\n         SPACE 3\n* WORK AREA FOR DVTOC\n         SPACE ,\n* FIRST PART IS FORMAT 4 DSCB AREA\n         ORG   DBUF\nVTOCAREA DS    0D\n         IECSDSL1 4\n         ORG   DS4VTOCE       FMT 4 EXTENT DESCRIPTION\n         DS    CL2\nVTOCBEG  DS    CL4\nVTOCEND  DS    CL4\n         DS    279C\n         SPACE 3\nPAGEGET  DS    F\nVTOCSV   DS    11F\nWAR14    EQU   VTOCSV    REG SAVE AREA FOR SUBTASK COMMUNICATION\nWAR15    EQU   WAR14+4\n*\nENDTEST  DS    XL5\n*\n*\nDVTAREA  DVTAREA ,                 DEFINE DEVCODE AREA\n*\n*\nNUMTRK   DS    H\n*\nSRCHC    DS    H\nSRCHH    DS    H\nSRCHR    DS    H\n         EJECT\nJFCB     DS    0D\n         IEFJFCBN\n         EJECT\n* VOLUME CATALOG ENTRY WORK AREA\n         SPACE ,\nCATBLOCK DS    0D\nCATNOENT DS    H\nCATDVTYP DS    CL4\nCATVOL   DS    CL6\nCATTRASH DS    CL2\nCATENTSZ EQU   *-CATDVTYP\nCATNTTR  EQU   CATBLOCK+256        TTR OF BLOCK FOLL READ BLOCK\nCATVOLID EQU   CATNTTR+3           VOL ID OF CATLG\nCATRSIZE EQU   CATVOLID+6-CATBLOCK SIZE READ FROM CATLG\n         SPACE 3\n* FORMAT 1 DSCB WORK AREA\n         DS    0D\n         IECSDSL1 1\nDS1END   EQU   *\nSPACFLAG EQU   X'69'          SPACE ACCOUNTING FLAG BITS\n         SPACE 3\n* FORMAT 3 DSCB WORK AREA\n         ORG   IECSDSL1\n         DS    0D\n         IECSDSL1 3\nDS3END   EQU   *\n         SPACE 3\n* FORMAT 5 DSCB WORK AREA\n         ORG   IECSDSL1\n         IECSDSL1 5\n         SPACE 3\n         ORG   CATBLOCK+CATRSIZE   (MUST BE .GT. DS3END)\n         COPY  SDSNBUF\n         SPACE 3\n         COPY  SCATBUF\n         SPACE 3\nJFCBSAVE DS    0D\n         DS    CL(JFCBLGTH)\n         SPACE 3\nWASA     DS    18F       R13 SAVE AREA DURING SUBTASK\n         ORG   ,\n         MEND\n./ ADD NAME=WDIOWA9  0100-80113-80113-1546-00369-00369-00000-$SYS13  00\n         MACRO\n&NM      WDIOWA &TYPE\n         SPACE ,\n         AIF   ('&TYPE' EQ '').NOSECT\n         AIF   ('&TYPE'(1,1) EQ 'C').CSECT\n         AIF   ('&TYPE'(1,1) EQ 'D').DSECT\n         MNOTE 4,'&TYPE INVALID - IGNORED'\n         AGO   .NOSECT\n.DSECT   ANOP\n&NM      DSECT\n         AGO   .START\n.CSECT   ANOP\n&NM      CSECT\n         AGO   .START\n.NOSECT  ANOP\n&NM      DS    0D\n.START   ANOP\n*                                                               JEP013\n*                                                               JEP013\n* MOD JEP013                                                    JEP013\n*  CHANGED DEFAULT NAME FROM WYL.CU.CTR.VTOC TO WYLBUR.         JEP013\n*  DENOTED JEP013 IN 66/71.  JERRY PITTENGER                    JEP013\n*                                                               JEP013\n         SPACE 2\n         DS    0D\nWADECB   DC    AL1(255),AL3(DECB)\nUCB      DC    A(0)      UCB ADDR FOR SPEC VOLUME\n         SPACE\nDFL      DC    X'00'     FLAGS\n         SPACE ,\nDFREPL   EQU   X'08'     STOW REPL TO BE DONE AT CLOSE\nDFUPTSPC EQU   X'02'     UPDATE SPACE ACCTG AT CLOSE\nDFUSPCNM EQU   X'01'     NO COND SHOW SPACE CALL IF ON\n         SPACE 2\nFLAGS    DS    CL5       SAVE DSNAME FLAGS\nF1       EQU   FLAGS          FIRST DSNAME FLAG\nF2       EQU   FLAGS+1        SECOND DSNAME FLAG\nF3       EQU   FLAGS+2        THIRD DSNAME FLAG\nF4       EQU   FLAGS+4        FOURTH DSNAME FLAG\nF5       EQU   FLAGS+5        FIFTH DSNAME FLAG\n         SPACE ,\nDSDD     DC    CL8'IOVVVVVV'  DDNAME\n         SPACE 2\n* EXLST FOR DCB\nEXLST    DS    0F\n         DC    X'00'               ENTRY TO BE FILLED IN\n         DC    AL3(0)\n         DC    X'87'               LAST ENTRY/JFCB POINTER\n         DC    AL3(JFCB)\n         SPACE 2\n* IOB FOR EXCP\nIOB      DS    0D\n         DC    XL2'C200'\nIOBSNS   DC    H'0'\n         DC    A(DECB)\nIOBCSW   DC    2F'0'\nIOBSTART DC    F'0'\n         DC    A(FOURS)       DCB\n         DC    2F'0'\n         DC    XL1'0'\nIOBB     DC    XL2'0'\nSEEK     DC    XL5'0'\n         SPACE 2\n* CHANNEL PROGRAM FOR EXCP\nMT       EQU   X'80'          MULTI-TRACK\nSCHIDEQ  EQU   X'31'          SEARCH ID EQUAL\nTIC      EQU   X'08'          XFER IN CHANNEL\nSCHKYEQ  EQU   X'29'          SEARCH KEY EQUAL\nSCHKYHI  EQU   X'49'          SEARCH KEY HIGH\nSCHKYHE  EQU   X'69'          SEARCH KEY HI OR EQUAL\nSCHKADEQ EQU   X'2D'          SEARCH KEY AND DATA EQUAL\nSCHKADHI EQU   X'4D'          SEARCH KEY AND DATA HIGH\nSCHKADHE EQU   X'6D'          SEARCH KEY AND DATA HI OR EQUAL\nSWKADKY  EQU   SCHKADHE-SCHKYHE    USED TO SWAP SCH KAD/SCH KEY\nRDCNT    EQU   X'12'          READ COUNT\nRDDATA   EQU   X'06'          READ DATA\nRDKYDATA EQU   X'0E'          READ KEY AND DATA\nNOPIC    EQU   X'03'          NOP IN CHANNEL\nCC       EQU   X'40'          COMMAND CHAIN\nDC       EQU   X'80'          DATA CHAIN\nSLI      EQU   X'20'          SLI\nSKP      EQU   X'10'          SKIP DATA XFER\n         SPACE ,\nSRCHCCW  CCW   SCHIDEQ,SEEK,CC+SLI,5         SEARCH FOR PREV REC\n         CCW   TIC,SRCHCCW,CC+SLI,0\nCCWSW    CCW   TIC,ID,CC+SLI,0               SWITCH BETWEEN ID & PDSRD\nID       CCW   SCHIDEQ+MT,ENDTEST,CC+SLI,5   LAST VTOC REC?\n         CCW   TIC,KEY,CC+SLI,0              TIC IF NO\n         CCW   TIC,ENDCCW1,CC+SLI,0          TIC IF YES\n*              LENGTH FIELD IS CHANGED IN FOLLOWING CCW\nKEY      CCW   SCHKADEQ+MT,DSNAME,CC+SLI,0   IS REC ONE WE WANT?\n         CCW   TIC,ID,CC+SLI,0               TIC IF NO\n         CCW   RDCNT+MT,SRCHC,SLI,5          READ ADDR OF FOLL REC\n* END OF THIS PART OF COMMAND CHAIN\n         SPACE 2\n*              LENGTH FIELD IS CHANGED IN FOLLOWING CCW\nENDCCW1  CCW   SCHKADEQ,DSNAME,CC+SLI,0  IS LAST VTOC REC ONE WE WANT?\n         CCW   TIC,ENDCCW,CC+SLI,0       TIC IF NO\n         CCW   NOPIC,SEEK,CC+SLI+SKP,1   DUMMY CMND\nENDCCW2  CCW   SCHIDEQ,ENDTEST,CC+SLI,5  SO WE CAN SEARCH AGAIN\n         CCW   TIC,ENDCCW2,CC+SLI,0\nREADCCW2 CCW   RDKYDATA,DS1DSNAM,SLI,DS1END-DS1DSNAM  READ DSCB\n* END OF THIS PART OF COMMAND CHAIN\n         SPACE 2\nENDCCW   CCW   NOPIC,SEEK,SLI,1      DUMMY CMD TO FLAG END OF SEARCH\n* IF FINAL CSW POINTS HERE THEN THE VTOC HAS BEEN COMPLETELY SEARCHED\n         SPACE ,\n* CHANNEL PROGRAM RESTARTED HERE IF A RECORD FOUND WE WANT\nREADCCW  CCW   SCHIDEQ,SRCHC,CC+SLI,5     SEARCH FOR THE ONE WE WANTED\n         CCW   TIC,READCCW,CC+SLI,0\n         CCW   RDKYDATA,DS1DSNAM,SLI,DS1END-DS1DSNAM    READ DSCB\n* END OF THIS PART OF COMMAND CHAIN\n         SPACE 2\n* CHANNEL PROGRAM SECTION FOR READING PDS DIRECTORY\nPDSREAD  CCW   RDCNT+MT,SRCHC,CC+SLI,5\n         CCW   RDKYDATA,DBUF,SLI,264\n         SPACE 3\n* MISCELLANEOUS WORK AREAS AND CONSTANTS\nCCREDT   DS    D\nDSNAME   DS    CL44\nDSN      DC    44X'04'\n         SPACE ,\nBLDL     DS    0F\n         DC    H'1'           ONE ENTRY\n         DC    AL2(BLDLSZ)    LENGTH OF ENTRY\nMEMBER   DS    CL8            MEMBER NAME\nBLDLTTR  DS    CL3            MEMBER TTR\nBLDLKZC  DS    CL3            OTHER BLDL TRASH\nBLDLSZ   EQU   *-MEMBER\n         ORG   BLDLKZC+1      STOW REQUIRES C BUT NOT K AND Z\nSTOWLTTR DS    F              DATE OF LAST STOW OR SSI\nSTOWSZ   EQU   *-MEMBER       SIZE OF DIRECTORY ENTRY STOWED\n         SPACE ,\nRRECFM   DS    CL1            RECFM\n         SPACE ,\nSCRVLST  DS    0F             SCRATCH LIST AND OTHERS\n         DC    H'1'           NUMBER OF VOLUMES\nDEVCODE  DS    CL4            RESULT OF DEVTYPE\nDSVID    DS    CL6            VOLUME ID\n         DC    X'0'           BYTE OF ZERO\nSCRRET   DC    X'0'           RETURN CODE FROM SCRATCH\n         SPACE 3\nVTOCCCW  DC    AL3(ID)        TIC ADDR FOR SHOW DSNAMES\nPDSCCW   DC    AL3(PDSREAD)   TIC ADDR FOR SHOW DIRECTORY\nLASTCCW  DC    AL3(ENDCCW+8)  ADDR IN CSW WHEN VTOC SEARCH DONE\nLASTCCW1 DC    AL3(ENDCCW)    ADDR IN CSW WHEN LAST VTOC REC WANTED\nRECSIZE  DS    F\nLRECSIZE DS    F\nERROR    DS    F\nSPACE    DS    F\nDEVBLOCK DS    F              DEVICE BLOCK SIZE\nRETCOD   DS    F\n         EJECT\n* DECBS AND PARAMTER LISTS\n         SPACE ,\n         READ  DECB,SF,DCB,DBUF,MF=L\n         SPACE 3\nDSCB     CAMLST SEARCH,DSNAME,DSVID,DS1FMTID\n         SPACE 3\nSCRLST   CAMLST SCRATCH,DSNAME,,SCRVLST\n         SPACE 3\nUSCATL   CAMLST NAME,DSNAME,,CATBLOCK\n         SPACE 3\nUSCATL2  CAMLST BLOCK,CATNTTR,CATVOLID,CATBLOCK\nCAMVOLID EQU   USCATL2+8      ADDR OF VOLUME ID PTR IN PREV LIST A26\n         SPACE 3\nVTOC     CAMLST SEARCH,DSN,DSVID,VTOCAREA\n         SPACE 3\nVTOC3    CAMLST SEEK,DS1PTRDS,DSVID,IECSDSL3\n         SPACE 3\nCATLST   CAMLST CAT,DSNAME,,SCRVLST     USED FOR CAT/UNCAT/RECAT\n         SPACE 3\nOPENLIST OPEN  (DCB),MF=L\n         SPACE 3\nENQDSN   ENQ   (,DSNAME,,,SYSTEM),RET=USE,MF=L\n         EJECT\n* DUMMY  DCBS\n         SPACE 2\n* DUMMY DCB TO ALLOCATE SPACE FOR DCB TO BE MOVED IN\nDCB      DCB   DSORG=PS,MACRF=(RP,WP)\n         EJECT\nFOURS    DCB   DSORG=PS,MACRF=E,EXLST=EXLST\n         EJECT\n***  THE DATA BUFFER IS ALSO USED AS A WORK AREA AND FOR READING\n**    VARIOUS CONTROL BLOCKS.  IT IS CAREFULLY CONSTRUCTED SO\n**    THAT AREAS WHICH ARE REQUIRED SIMULTANEOUSLY DO NOT OVERLAY\n**    EACH OTHER.  THE OVERLAY STRUCTURE IS AS FOLLOWS:\n*\n**   DBUF      FMT 4 DSCB WORK AREA\n**     |       SHOW DSNAMES WORK AREA\n**     |       JFCB AREA\n**     |       LOCATE VOL WORK AREA\n**     |       REST OF CATLG BLOCK AREA      DSCB1/3/5 WORK AREAS\n**     |                 |                            V\n**     |                 V\n**     |       SHOW DSNAMES BUFFER           SHOW CATLG BUFFER\n**     |                 |                   CLEAR JFCB WORK AREA\n**     |                 V                            |\n**     |                                              V\n**     |                                     SUBTASK R13 REG SV AREA\n**     |                                              V\n**     |\n**     V\n         SPACE 3\n* DAIR INTERFACE:\nWAUPT    DC    A(0)\nWAECT    DC    A(0)\nWAECB    DC    A(WADARECB)\nWAPSCB   DC    A(0)\nWADAIR   DC    A(DA08CD)\nWADARECB DC    F'0'\nDAIRDSN  DC    AL2(44)                                          JEP013\nDSNPREF  DC    CL44'@WYLBUR'                                    JEP013\n***********************************************************************\n* THIS OPERATION CODE CAUSES ALLOCATION OF A DATA SET. IT CAN ALLOC.  *\n* EITHER A NEW OR OLD SET.                                            *\n***********************************************************************\n         DS    0F\nDA08CD   DC    AL2(8)   DAIR ENTRY CODE\nDA08FLG  DC    X'00'    FUNCTIONS TO BE PERFORMED WHEN RET CODE IS 0\nDA08FPE  EQU   X'80'    FUNCT PERFORMED BUT ERROR INDICATED BY RETCD\n         DC    X'00'\nDA08DARC DC    H'0'     DYN ALLOC RETURN CODE\nDA08CTRC DC    H'0'     CATALOG RETURN CODE\nDA08PDSN DC    A(DAIRDSN)   PTR TO DSNAME TO BE SEARCHED IN DSE\nDA08DDN  DC    CL8' '   DDNAME TO BE SEARCHED IN DSE\nDA08UNIT DC    CL8' '   UNITNAME REQUESTED\nDA08SER  DC    CL8' '   VOLUME SERIAL NUMBER-PADDED W/BLANKS\nDA08BLK  DC    F'0'     DATA SET  AVERAGE RECORD LENGTH\nDA08PQTY DC    F'0'     PRIMARY SPACE QUANTITY\nDA08SQTY DC    F'0'     SECONDARY SPACE QUANTITY\nDA08DQTY DC    F'0'     DIRECTORY BLOCK QUANTITY\nDA08MNM  DC    CL8' '   MEMBER NAME\nDA08PSWD DC    CL8' '   PASSWORD\nDA08DSP1 DC    X'08'    DATA SET STATUS FLGS(IF=0 OLD ASSUMED)\nDA08SHR  EQU   X'08'    DATA SET IS SHR\nDA08NEW  EQU   X'04'    DATA SET IS NEW\nDA08MOD  EQU   X'02'    DATA SET IS MOD\nDA08OLD  EQU   X'01'    DATA SET IS OLD\nDA08DPS2 DC    X'08'    DATA SET DISPOSITION(IF=0 KEEP ASSUMED)\nDA08KEEP EQU   X'08'    DS DISP IS KEEP\nDA08DEL  EQU   X'04'    DS DISP IS DELETE\nDA08CAT  EQU   X'02'    DS DISP IS CATLG\nDA08UCAT EQU   X'01'    DS DISP IS UNCATALOG\nDA08DPS3 DC    X'08'    DATA SET CONDITIONAL DISPOSITION\nDA08KEP  EQU   X'08'\nDA08DELE EQU   X'04'\nDA08CATL EQU   X'02'    DS DISP OF CATLG DESIRED\nDA08UNCT EQU   X'01'    DS DISP OF UNCATLG DESIRED\nDA08CTL  DC    X'08'    FLAGS TO CONTROL ACTIONS TAKEN BY DAIR\nDA08TRKS EQU   X'80'    UNITS ARE TRKS\nDA08ABKL EQU   X'40'\nDA08CYLS EQU   X'C0'    UNITS ARE CYLS\nDA08UID  EQU   X'20'    USER ID IS TO BE PREFIXED\nDA08RLSE EQU   X'10'    RELEASE (RLSE) REQUESTED\nDA08PERM EQU   X'08'    DATA SET MUST BE SPECIFICALLY UNALLOCATED\nDA08DMMY EQU   X'04'\nDA08ATRL EQU   X'02'    ATTRIBUTE LIST SUPPLIED\n         DC    XL3'00'  RESERVED\nDA08DSO  DC    XL1'00'  DSORG\nDA08ALN  DC    CL8' '   ATTR-LIST-NAME\n***********************************************************************\n* THIS OPERATION CAUSES THE REQUESTED DATA SET OR DDNAME TO BE        *\n* UNALLOCATED. DISPOSITION CAN BE SPECIFIED TO OVERRIDE ANY PREVIOUS  *\n* DISPOSITION. LIKENISE SYSOUT CLASS MAY BE SPECIFIED TO OVERRIDE ANY *\n* PREVIOUS CLASS.                                                     *\n***********************************************************************\n         DS    0F\nDA18CD   DC    AL2(24)  DAIR ENTRY CODE\nDA18FLG  DC    X'00'    FUNCTIONS TO BE PERFORMED WHEN RET CODE IS 0\nDA18FPE  EQU   X'80'    FUNCT PERFORMED BUT ERROR INDICATED BY RETCD\n         DC    X'00'\nDA18DARC DC    H'0'                    DYNAMIC ALLOCATION RETURN CODE\nDA18CTRC DC    H'0'               CATALOG RETURN CODE AREA\nDA18PDSN DC    A(0)         PTR TO DSNAME TO BE SEARCHED IN DSE\nDA18DDN  DC    CL8' '   DDNAME TO BE SEARCHED IN DSE\nDA18MNM  DC    CL8' '   MEMBER NAME\nDA18SCLS DC    CL2' '   SYSOUT CLASS DESIRED WHEN UNALLOCATING  A\n*                       SYSOUT DATA SET\nDA18DPS2 DC    X'08'    DATA SET DISPOSITION\nDA18KEEP EQU   X'08'    CHANGE DISP TO KEEP\nDA18DEL  EQU   X'04'    CHANGE DISP TO DELETE\nDA18CAT  EQU   X'02'    CHANGE DISP TO CATALOG\nDA18UCAT EQU   X'01'    CHANGE DISP TO UNCATLOG\nDA18CTL  DC    X'10'    FLAGS FOR SPECIAL DAIR PROCESSING\nDA18UID  EQU   X'20'    USER ID IS TO BE PREFIXED TO DSNAME\nDA18PERM EQU   X'10'    UNALLOCATE PERM. ALLOCATED DSE'S\nDA18JBNM DC    CL8' '\n         SPACE ,\nATTDECB  DC   A(0)                 ECB FOR ATTACH\nWATTACH  ATTACH EP=IKJEFT01,ECB=ATTDECB,SF=L\n         DS    0F\nWASTAX   DC    5A(0)               STAX PARAMETER LIST\nDBUF     DS    0D\nDBUFSIZE EQU   13030\nACCTWA   EQU   DBUF       ACCOUNTING WORK AREA\n         DS    (DBUFSIZE)C\n         SPACE 3\n* WORK AREA FOR DVTOC\n         SPACE ,\n* FIRST PART IS FORMAT 4 DSCB AREA\n         ORG   DBUF\nVTOCAREA DS    0D\n         IECSDSL1 4\n         ORG   DS4VTOCE       FMT 4 EXTENT DESCRIPTION\n         DS    CL2\nVTOCBEG  DS    CL4\nVTOCEND  DS    CL4\n         DS    279C\n         SPACE 3\nPAGEGET  DS    F\nVTOCSV   DS    11F\nWAR14    EQU   VTOCSV    REG SAVE AREA FOR SUBTASK COMMUNICATION\nWAR15    EQU   WAR14+4\n*\nENDTEST  DS    XL5\n*\n*\nDVTAREA  DVTAREA ,                 DEFINE DEVCODE AREA\n*\n*\nNUMTRK   DS    H\n*\nSRCHC    DS    H\nSRCHH    DS    H\nSRCHR    DS    H\n         EJECT\nJFCB     DS    0D\n         IEFJFCBN\n         EJECT\n* VOLUME CATALOG ENTRY WORK AREA\n         SPACE ,\nCATBLOCK DS    0D\nCATNOENT DS    H\nCATDVTYP DS    CL4\nCATVOL   DS    CL6\nCATTRASH DS    CL2\nCATENTSZ EQU   *-CATDVTYP\nCATNTTR  EQU   CATBLOCK+256        TTR OF BLOCK FOLL READ BLOCK\nCATVOLID EQU   CATNTTR+3           VOL ID OF CATLG\nCATRSIZE EQU   CATVOLID+6-CATBLOCK SIZE READ FROM CATLG\n         SPACE 3\n* FORMAT 1 DSCB WORK AREA\n         DS    0D\n         IECSDSL1 1\nDS1END   EQU   *\nSPACFLAG EQU   X'69'          SPACE ACCOUNTING FLAG BITS\n         SPACE 3\n* FORMAT 3 DSCB WORK AREA\n         ORG   IECSDSL1\n         DS    0D\n         IECSDSL1 3\nDS3END   EQU   *\n         SPACE 3\n* FORMAT 5 DSCB WORK AREA\n         ORG   IECSDSL1\n         IECSDSL1 5\n         SPACE 3\n         ORG   CATBLOCK+CATRSIZE   (MUST BE .GT. DS3END)\n         COPY  SDSNBUF\n         SPACE 3\n         COPY  SCATBUF\n         SPACE 3\nJFCBSAVE DS    0D\n         DS    CL(JFCBLGTH)\n         SPACE 3\nWASA     DS    18F       R13 SAVE AREA DURING SUBTASK\n         ORG   ,\n         MEND\n./ ADD NAME=WIDENT\n         MACRO\n         WIDENT &LEVEL\n         SPACE ,\n.* THIS MACRO PROVIDES LEVEL,DATE, AND TIME STAMP FOR ASSEMBLIES\n.* MUST BE RUN UNDER THE 18JAN70 RELEASE OF ASMG, WITH EXTEN OPTION\n         GBLC  &MOD,&IDDATE,&IDTIME\n         LCLC  &X1,&X2,&X3,&ENT\n&MOD     SETC  '&LEVEL'\n&IDDATE  SETC  '&SYSDATE '(1,7)\n&IDTIME  SETC  '&SYSTIME'\n&X1      SETC  '&IDDATE'(1,2)\n&X2      SETC  '&IDDATE'(3,3)\n&X3      SETC  '&IDDATE'(6,2)\n         AIF   ('&X3'(2,1) NE ' ').A1\n&X3      SETC  '0'.'&X3'(1,1)\n.A1      ANOP\n&IDDATE  SETC  '&X3&X2&X1'\n&ENT     SETC  '&SYSECT&MOD'\n         SPACE ,\n         ENTRY &ENT\n         SPACE ,\n&ENT     DC    C'&ENT,&IDDATE,&IDTIME'\n         MEND\n./ ADD NAME=WSTP\n         MACRO\n&L       WSTP  &A\n&L       SYSLR 1,&A\n         L     0,=X'AABBCCDD'\n         SVC   SVCMIL\n         MEND\n./ ADD NAME=WYLCONST\n         SPACE ,\n* REGISTER DEFINITIONS\n         SPACE ,\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n         SPACE ,\n* CONSTANTS\n         SPACE ,\nC4       EQU   4\nC8       EQU   8\nC12      EQU   12\nC16      EQU   16\nC20      EQU   20\nC24      EQU   24\nC28      EQU   28\nC32      EQU   32\nC36      EQU   36\nC40      EQU   40\nC44      EQU   44\nC48      EQU   48\nC52      EQU   52\nC80      EQU   80\nSZR      EQU   148\nMXPRTSZ  EQU   133     MAX LINE SIZE (UNPRESSED)\nABRTCODE EQU   36      ABORT RETURN CODE FOR NTGDOPN ROUTINE\nTALOCODE EQU   32      TALO RETURN CODE FOR NTGDOPN ROUTINE\nDESRELA  EQU   X'02'   ROUTINE ADDR IS RELATIVE OFF R10\nINCORE   EQU   X'33'   PAGE IS IN CORE\nFNEGBT   EQU   X'80'   NEGATIVE BIT\nFLOWBT   EQU   X'01'   LOW ORDER BIT\nFALLBT   EQU   X'FF'   ALL BITS\n         SPACE ,\n* DESPOT FLAGS\n         SPACE ,\nDESRTRN  EQU   X'80'   RETURN FROM DESPOT  ** FOR DESPOT CALLS\nDESNRTN  EQU   X'00'   CALL CMDPRT FROM DESPOT\nLEXATRTN EQU   X'40'   USE LOCATEEX\nLXCATRTN EQU   X'60'   USE LXCATE\nLOCATRTN EQU   X'00'   USE LOCATE\nDESMATCH EQU   X'10'   MATCH A LINE NO ALWAYS\nDESNMTCH EQU   X'00'   NO MATCH AT PAGE END\nUNPRST   EQU   X'01'   RETURN UNPRESSED FROM DESPOT\nPREST    EQU   X'00'   RETURN PRESSED FROM DESPOT\n         SPACE ,\nFRNGTYP  EQU   X'C0'   RANGE TYPE BITS\n*              X'00'   SINGLE LINE NUMBER RANGE N\n*              X'40'   COUNT RANGE N(M)\n*              X'C0'   NORMAL TWO LINE RANGE N/M\n./ ADD NAME=XCALL\n         MACRO\n&L       XCALL &R\n         GBLC  &PAGECDE\n         AIF   ('&PAGECDE' EQ 'YES').XCALLP\n&L       L     14,=A(&R)\n         BALR  14,14\n         MEXIT\n.XCALLP  ANOP\n&L       LA    14,&R\n         BAL   7,CVCALLER\n         MEND\n./ ADD NAME=XENTER\n         MACRO\n&L       XENTER &R,&S,&SZ,&BASE=\n         AIF   ('&L' EQ '').NEP\n         ENTRY &L\n.NEP     ANOP\n&L       ST    14,0(,13)\n         XENTERI &R,&S,&SZ\n         AIF   ('&BASE' EQ '').DATSALL\n         L     7,=A(&BASE)\n         USING &BASE,7\n.DATSALL ANOP\n         MEND\n./ ADD NAME=XENTERI\n         MACRO\n&L       XENTERI &R,&S,&SZ\n         GBLC  &PAGECDE\n         AIF   ('&L' EQ '').NEP\n         ENTRY &L\n.NEP     ANOP\n&L       STM   &R,&S,4(13)\n         LR    8,13\n         AIF   ('&SZ' EQ '').NWA\n         AIF   ('&SZ' EQ '*').MIN\n         LA    13,(&SZ+3)/4*4(,13)\n         AGO   .NWA\n.MIN     ANOP\n         LA    13,(&S+2-(&R))*4(,13)\n.NWA     AIF   ('&PAGECDE' EQ 'YES').EXIT\n         BALR  7,0\n         USING *,7\n.EXIT    MEND\n./ ADD NAME=XEXIT\n         MACRO\n&L       XEXIT &R,&S,&LTR\n         GBLC  &PAGECDE\n&L       LR    13,8\n         LM    &R,&S,4(13)\n         L     14,0(,13)\n         AIF   ('&PAGECDE' EQ 'YES').PEXIT\n         AIF   ('&LTR' EQ '').NLTR\n         LTR   15,15\n.NLTR    BR    14\n         MEXIT\n.PEXIT   AIF   ('&LTR' NE 'PFREE').PEXIT1\n         B     CVROUTEX            PFREE ROUTINE PAGE AND EXIT\n         MEXIT\n.PEXIT1  AIF   ('&LTR' EQ '').NLTR\n         MNOTE 8,'&LTR INVALID IN PAGED CODE'\n         AGO   .NLTR\n         MEND\n./ ADD NAME=XSA\n         MACRO\n&L       XSA   &S,&R\n&L       DC    (&R+2-(&S))A(0)\n         MEND\n./ ADD NAME=XTRACE\n         MACRO\n&L       XTRACE &NAME,&A,&B,&SM=255\n         GBLC  &TRACEEE\n         AIF   ('ON' EQ '&TRACEEE').YESS\n&L       SYSLR 1,(1)\n         MEXIT\n.YESS    ANOP\n         AIF   ('&SM' EQ '0').ZSM\n&L       SETSM 0\n         STM   14,1,TRAC&SYSNDX+4\n         AGO   .STD\n.ZSM     ANOP\n&L       STM   14,1,TRAC&SYSNDX+4\n.STD     ANOP\n         AIF   ('&A' EQ '').NULL\n         AIF   ('&A'(1,1) EQ '(').AR\n         MVC   TRAC&SYSNDX+12(8),&A\n         AGO   .B\n.AR      AIF   ('&A' EQ '(0)').B\n         ST    &A,TRAC&SYSNDX+12\n.B       AIF   ('&B' EQ '').NULL\n         AIF   ('&B'(1,1) EQ '(').BR\n         MVC   TRAC&SYSNDX+16(4),&B\n         AGO   .NULL\n.BR      AIF  ('&B' EQ '(1)' AND '&A'(1,1) EQ '(').NULL\n         ST    &B,TRAC&SYSNDX+16\n.NULL    ANOP\n         CNOP  2,4\n         L     15,TRAC&SYSNDX\n         BALR  14,15\nTRAC&SYSNDX DC V(TRACE)\n         DC    4A(0)\n         DC    CL8'&NAME'\n         LM    14,15,4(14)\n         AIF   ('&SM' EQ '0').NRSM\n         SETSM &SM\n.NRSM    ANOP\n         MEND\n./ ADD NAME=XTRNS\n         MACRO\n         XTRNS &DUMMY\n         LCLC  &C\n.* MACRO TO GENERATE EXTRN STATEMENTS FOR WYLTSO\n&C       SETC  '&SYSECT'\n         AIF   ('&C' EQ 'PDOS').W1\n* PDOS ENTRIES\n         EXTRN DOCHNG,DODELEL,DODELE,STOWIT,UNPRESS\n         EXTRN LENCHK,TRDRTN,LISTLINE,SETPRMPT,RDSKER\n         EXTRN WDSKER,ADDER,LOWMULT,CVEXNO,PRESS\n.W1      AIF   ('&C' EQ 'PGOS').W1A\n* PGOS ENTRIES\n         EXTRN GOCHNG,GODEL,BOOMDEL,GOCOPY,GOMOVE\n         EXTRN WORK,LOCLIST,LSLNMSGA,SELDELTA,FIXNUMB\n         EXTRN GOSET,SETPFXNS\n.W1A     AIF   ('&C' EQ 'PEDS').W2\n* PEDS ENTRIES\n         EXTRN VOLCHEK,GOSAVE,NTGDOPN,WORKX,GOREN\n         EXTRN GOSCRT,NOTMYDS,GOUSE,CLEARCK,YESREQ\n         EXTRN DSNAMED,MEMBERED,CTLGED,VOLCHKNL\n         EXTRN CHKMBRIG,NOMORPG,GOPERMIT\n.W2      AIF   ('&C' EQ 'BLPR').W3\n* BLPR ENTRIES\n         EXTRN GOPOINT,GOLSPRN,LSTWORK\n.W3      AIF   ('&C' EQ 'PUTB').W5\n* PUTB ENTRIES\n         EXTRN DESPOT,DETRNG,ITSNIL,LOCATE,LOCATEEX\n         EXTRN LXCATE,DODSNM,DSNSTDDO,DSNUDSDO,FMTCHK\n.W5      AIF   ('&C' EQ 'PWYL').W6\n* PWYL ENTRIES\n         EXTRN WYLTSO,CMDPRT,INVALID,ILLCMD\n         EXTRN EDTCOMMV,EDTCOM,ATTNRTN,PSYNAD\n         EXTRN CLRTST,DOCLEAR,GORDCMD\n         EXTRN UNLEGAL,ABSCENT,AMMISS,QTYPED,QSYSGO\n.W6      AIF   ('&C' EQ 'PAGER').W8\n* PAGER ENTRIES\n         EXTRN PGET,WPAGES,PAGEIO,PFREE,PMARK\n         EXTRN PNUM,PJUNK\n.W8      AIF   ('&C' EQ 'PDIO').W9\n* PDIO ENTRIES\n         EXTRN DOPEN,DOUCBSR,RENCTG,PRENA,DREAD\n         EXTRN DWRITE,DCLOSE,CALCTRK\n.W9      AIF   ('&C' EQ 'PSCN').W10\n* PSCN ENTRIES\n         EXTRN SCINIT,SCTELL,SCAN,DQSCAN\n.W10     AIF   ('&C' EQ 'WTR').W11\n* WTR ENTRIES\n         EXTRN TSEGXM,TSEGXW,TSEGXB,TSEGX,TMARKX\n         EXTRN TWRITEX,OPWRITE,TREADX,TTABS\n.W11     ANOP\n         AIF   ('&C' EQ 'BEXE').W12\n* BEXE ENTRIES\n         EXTRN GOLOAD,GOEXEC,STEXEPRT,SHEXEC,GETEXCMD\n         EXTRN WRITECOM,EXLOOPCK,EXECABRT,GORESTOR,GOCOMMNT\n         EXTRN EXCLRCK,DOCLREX\n.W12     AIF   ('&C' EQ 'PPRT').W14\n* PPRT ENTRIES\n         EXTRN LISTPRT,TEXTPRT,LTNPRT,NUMPRT,SCRPRT\n         EXTRN CLSCRPRT,CLRPRT,IGDSNPRT,LNENOPRT,LNENOPRN\n         EXTRN SCNEXFR\n.W14     AIF   ('&C' EQ 'PROC').W15\n* PROC ENTRIES\n         EXTRN FMTTIME,GOIF,LOOKUP,PREPROC,READVAR\n         EXTRN READSTR,SETVAR,SHOVAR\n.W15     ANOP  ,\n* CR ENTRIES\n         EXTRN DTB,XTB,BTD,BTX,DATE,TIME\n.EXIT    MEND\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "MACLIB0": {"ttr": 50435, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00$\\x01\\x19#\\x0f\\x01\\x19#\\x0f\\x14A\\x05\\x10\\x05\\x10\\x00\\x00\\xe6\\xe8\\xd3\\xc2\\xe4\\xd9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2019-08-18T00:00:00", "modifydate": "2019-08-18T14:41:24", "lines": 1296, "newlines": 1296, "modlines": 0, "user": "WYLBUR"}, "text": "./ ADD NAME=BLPRWA,SSI=00000168\n         MACRO\n         BLPRWA\nBLPRWA   DSECT\n         SPACE\nWAFLAG1  DS    X\n         SPACE\nWALOWCOL EQU   X'80'              LOW COL SPECIFIED\nWAHICOL  EQU   X'40'              HI COLUMN SPECIFIED\nWAFMRKN  EQU   X'20'              LIST MARKER\nWAFTWLN  EQU   X'10'\nWAF2LNS  EQU   X'08'              LIST TWOLINES\nWAFSQUSH EQU   X'04'              LIST SQUSHED\nWAFCAN   EQU   X'02'              CANCEL RUN\nWAFOFF   EQU   X'01'\n         SPACE\nWAFLAG2  DS    X\n         SPACE 3\nWAMRKCH  DS    CL1\nWA2LNCH  DS    CL1\nJOBNUM   DS    CL8\nJOBNAM   DS    CL8\nREASON   DS    CL4\nWAOFFCNT DS    F\n         DS    0F\nWASIZE   EQU   *-BLPRWA\n         MEND\n./ ADD NAME=CPTSO,SSI=00000176\n* WYLTSO LINE EDITOR CONTROL PAGE\n         SPACE ,\n*                                                               JEP005\n*                                                               JEP005\n* MODIFIED AT DCEC TO INCORPORATE UPPER AND LOWER OPERANDS      JEP005\n* ON THE CHANGE CMD FOR CHANGING CASE OF TEXT.                  JEP005\n*                                                               JEP004\n*                                                               JEP004\n* MODIFIED AT DCEC TO ENABLE RECOGNITION OF 3277 TERMINALS.     JEP004\n* ACCOMPLISHED IN LFLG1. JERRY PITTENGER                        JEP004\n*                                                               JEP010\n*                                                               JEP010\n* MODIFIED AT DCEC TO ALLOW FOR FOUR LOCAL FLAGS (LFLG1-4).     JEP010\n*                                                               JEP001\n*                                                               JEP001\n* MODIFIED AT DCEC TO ALLOW FOR UP TO 7 CHAR. LOGON ID.         JEP001\n*                                                               JEP001\n*                                                               JEP017\n* MODIFIED AT DCEC TO DOUBLE THE EXEC FILE SIZE.                JEP017\n*                                                               JEP017\nCPSTART  DS    0D\nCPR13    DS    A                       REGISTERS\nCPR14    DS    A\nCPR15    DS    A\nCPR0     DS    A\nCPR1     DS    A\nCPR2     DS    A\nCPR3     DS    A\nCPR4     DS    A\nCPR5     DS    A\nCPR6     DS    A\nCPR7     DS    A\nCPR8     DS    A\n         SPACE 3\n* REMOTE TERMINAL BUFFER\n         SPACE ,\nRTBSTART DC    0F'0'\nRTBTABS  DC    XL8'00'             TABS\n         SPACE 2\nRTBMFL   DC    AL1(0)              MODE FLAG\n         SPACE ,\nRTBMFUC  EQU   X'80'               UPPER-CASE ONLY\nRTBMFNA  EQU   X'40'               NO WRITE ATTN\nRTBMFCL  EQU   X'20'               CLEAN LISTING\nRTBMFNTO EQU   X'10'               NO TABS IN OUTPUT\nRTBNOCR  EQU   X'08'               NO CARRIAGE RETURNS\nRTBNOTR  EQU   X'04'               NO TRANSLATE TABLE\nRTBWRAP  EQU   X'02'               CR/LF NEEDED FOR WRAPPING\nRTBCRT   EQU   X'01'               PAGING IS TO BE DONE\n         SPACE 2\nRTBSFL   DC    X'00'       STATUS FLAGS\n         SPACE ,\nRTBSFEND EQU   X'C0'       ENDING STATUS, 00=OK, 01=ATTN, 11=I/O ERROR\nRTBSFATN EQU   X'40'       ATTENTION\nRTBSFERR EQU   X'C0'       I/O ERROR\nRTBSFUST EQU   X'20'       UNSET TAB\nRTBSFBRK EQU   X'10'       ENDED BY BREAK\nRTBSFHU  EQU   X'08'       HUNG UP PHONE\n         SPACE ,\nRTBWC    DC    H'0'        WRITE COUNT\nRTBPC    DC    H'0'        PROMPT COUNT\nRTBRC    DC    H'0'        READ COUNT\n         SPACE ,\nRTBNTEXT EQU   168         SIZE OF TEXT BUFFER\nRTBPMAX  EQU   32          MAX LENGTH FOR PROMPT\n         SPACE ,\nRTBWAPTR DS    F           RTB WORK AREA POINTER (256 BYTES)\nRTBATNSZ EQU   0           2 BYTES: ATTN SEQ LENGTH\nRTBATTN  EQU   2           8 BYTES: ATTN SEQ\nRTBPSZ   EQU   10          2 BYTES: PAGE SIZE\nRTBLSZ   EQU   12          2 BYTES: LINE SIZE\nRTBLINE  EQU   14          2 BYTES: LINES PRINTED\nRTBCURS  EQU   16          2 BYTES: CHARS PRINTED\nRTBBSCNT EQU   18          2 BYTES: BS COUNTER FOR TABS\nRTBTRBUF EQU   20        168 BYTES: TRANSLATE BUFFER\nRTBPRMPT EQU   188        32 BYTES: REPROMPT BUFFER\nRTBSAVE  EQU   220         2 BYTES: SAVE BUFFER FOR CR/LF\n*        EQU   222        26 BYTES: STILL AVAILABLE\nRTBPAUS  EQU   248         8 BYTES: CRT PAUSE READ BUFFER\n         SPACE 2\nRTBUFL   DS    X\n         SPACE ,\nRTBUATTN EQU   X'80'       ATTN SEQUENCE EXISTS\nRTBUNCOL EQU   X'40'       AUTOMATIC COLLECT NOT HONORED\nRTBUPAD  EQU   X'20'       PAD WHEN LISTING NOCR\nRTBURELT EQU   X'10'       TABS ARE RELATIVE\nRTBUBACK EQU   X'08'       BACKSPACE IS A GOOD CHARACTER\nRTBUFAST EQU   X'04'       FASTLIST IN EFFECT\nRTBUTBUN EQU   X'02'       TABS ARE UNNUMBERED\n         SPACE ,\n         DS    3X          MORE SPACE AVAILABLE\n         DC    0F'0'     FULL WORD FOR ORVYL-WYLBUR\nRTBTEXT  DC    CL(RTBNTEXT)' ' TEXT BUFFER\n         DC    0F'0'\n         SPACE ,\nRTBSIZE  EQU   *-RTBSTART\n         SPACE 3\nCPRTBSZ  EQU   RTBSIZE                 SIZE OF RTB\nCPSCANSZ EQU   24                      SIZE OF SCAN AREA\nCPSCAN   DS    0F,(CPSCANSZ)X          SCANNER WORK AREA\n         SPACE ,\n* FOR THE TEXT-EDITOR\nCPGLDL   DS    1F   GLOBAL DELTA\nCPHIPS   DS    1F   HIGHEST POSITION YET REACHED  * MUST\nCPLNCT   DS    1H   LINE COUNT                    *STAY\nCPAGCT   DS    1H   PAGE COUNT                    * TOGETHER\nCPLNGTH  DS    1H   LINE LENGTH OPTION\n         SPACE 2\nCPGFLG   DS    1X      GLOBAL FLAG BYTE\n         SPACE ,\nCPFOPN   EQU   X'80'   EXTERNAL DATA SET OPEN FLAG\nCPFCMOFF EQU   X'40'   TERSE MODE FLAG FOR NORMAL MESSAGES\nCPFUPLW  EQU   X'20'   UPPER-LOWER CASE FLAG\nCPFVOLM  EQU   X'10'   DEFAULT VOLUME SET FLAG\nCPFDIRCH EQU   X'08'   DIRECTORY HAS CHANGED\nCPFRETRY EQU   X'04'   COMMAND RETRY GOING ON\nCPFRETOK EQU   X'02'   COMMAND RETRY CAN BE DONE\n         SPACE 2\nCPGFLG2  DS    1X      GLOBAL FLAG BYTE\n         SPACE ,\nCPFEXEC  EQU   X'80'   TAKE COMMANDS FROM EXEC FILE\nCPFNOLOG EQU   X'40'   DON'T LOG COMMANDS FROM EXEC FILE\nCPFEXTER EQU   X'20'   EXEC MODE TERSE FLAG\nCPSKNULL EQU   X'04'   SKIP CHARACTER IS NULL FLAG\nCPESNULL EQU   X'02'   ESCAPE CHARACTER IS NULL FLAG\n         SPACE ,\nCPDOUB   DS    1D   DOUBLE-WORD WORK\nCPHFWRD  DS    H    USED TO EXTEND CPDOUB TO 10 BYTES\nCPVOLSV  DS    CL6  DEFAULT VOLUME SAVE AREA\n         SPACE ,\nCPLSTCOL DS    1F   NEXT LINE NO. TO COLLECT\nCPDLTCOL DS    1F   DELTA FOR COLLECT\n         SPACE ,\nCPEXLINE DS    F    EXEC FILE LINE NUMBER\nCPEXHIPS DS    F    HIGHEST LINENO IN EXEC FILE   * MUST\nCPEXLNCT DS    H    EXEC FILE LINE COUNT          * STAY\nCPEXCNT  DS    H    COUNT OF PAGES IN EXEC FILE   * TOGETHER\nCPEXCMCT DS    H    EXEC COMMAND COUNT WITHOUT USING TYPEWRITER\n*PEXDIR  DS     5CL6   EXEC FILE DIRECTORY SPACE                JEP017\nCPEXDIR  DS   20CL6    EXEC FILE DIRECTORY SPACE                JEP017\nCPEXECMX EQU   (*-CPEXDIR)/6 MAX NO. OF PAGES IN EXEC FILE\n         SPACE ,\nCPCURRL  DS    F   CURRENT LINE POINTER\n         SPACE ,\nCPPFXL   DS    H                       LENGTH OF PREFIX\n         SPACE ,\nCPPFXSZ  EQU   36                      SIZE OF PREFIX AREA\nCPPFX    DS    CL(CPPFXSZ)             PREFIX AREA\n         SPACE ,\nCPUSER   DS    CL3                 SIGNED ON USER\nCPGRP    DS    CL5                 SIGNED ON GROUP              JEP001\nCPUSERSV DS    CL3                 SAVE USER ID FOR DSNAMES\nCPGRPSV  DS    CL5                 SAVE GROUP ID FOR DSNAMES    JEP001\nCPMEMBSV DS    CL8                 SAVE MEMBER NAME FOR DSNAMES\nCPSTCNT  DS    H                   STOWIT MOD COUNT FOR RECOVERY\nCPRCVSZ1 EQU   *-CPGLDL            SIZE OF RECOVERY INFO\n         EJECT\n* LOCAL ITEMS FOR COMMANDS\n         DS    0F\nCPCMNM   DS    XL3  FOR FIRST 3 BYTES OF CURRENT COMMAND NAME\n         SPACE 2\nCPLFLG1  DS    1X      FIRST LOCAL FLAG BYTE\n         SPACE ,\nCPFTMINF EQU   X'80'   SHOW INFO/TIME FLAG\nCPFNOTRG EQU   X'80'   \"NOT\" LOGIC FOR RANGE\nCPFCPY   EQU   X'20'   COPY FLAG\nCPFALL   EQU   X'10'   FLAG FOR DETRNG|-- DEFAULT ALL OKAY\nCPFUSCAT EQU   X'04'   USE CATALOG TO LOCATE VOLUME\nCPFTNOV  EQU   X'01'   NOVERIFY OF SET TABS\n         SPACE ,\n* NUMBER USAGE\nCPFNMOD  EQU   X'02'   REMAINDER IN TIMES OPTION\nCPFTIMES EQU   X'01'   TIMES OPTION FOR NUMBER\n         SPACE 2\nCPLFLG2  DS    1X      SECOND LOCAL FLAG BYTE\n         SPACE ,\nCPFMODCD EQU   X'80'   MODIFY MODE -- USED IN MODIFY/EDIT\nCPFSCRTC EQU   X'40'   SCRATCH FLAG (SAVE-SHOW DSNAMES)\nCPFDSNMS EQU   X'20'   NULL/NO DEFAULT OK ON DSNAMES FLAG\nCPFSING  EQU   X'10'   SINGLE PROMPT MODE -- MODIFY/EDIT\nCPFCLEAR EQU   X'10'   CLEAR ACTIVE FILE FLAG\nCPFCOMB  EQU   X'08'   COMBINE FLAG FOR COPY\nCPFMERG  EQU   X'04'   MERGE FLAG FOR COPY/MOVE/COLLECT\nCPFREP1  EQU   X'02'   REPLACE CONTROL FLAG\nCPFDITTO EQU   X'01'   DITTO CONTROL FLAG (REPLACE & INSERT)\nCPFSMALL EQU   X'01'   SMALL DATA SET SAVED (SAVE)\n         SPACE ,\n* EXEC USAGE\nCPFEXLNE EQU   X'08'   EXPLICIT LINENO WAS SPECIFIED\nCPFEXACT EQU   X'04'   EXEC ACTIVE WAS SPECIFIED\nCPFEXPA  EQU   X'02'   EXEC PAUSE WAS SPECIFIED\nCPFEXFR  EQU   X'01'   EXEC FROM WAS SPECIFIED\n         SPACE ,\n* CHANGE USAGE\nCPFCHLIM EQU   X'20'   STRING POSITIONALLY DELIMITED\nCPFCHDEL EQU   X'10'   REPLACING STRING VOID FLAG\nCPFCHNGD EQU   X'08'   SOMETHING CHANGED FLAG\nCPFLNCHN EQU   X'04'   AT LEAST 1 LINE CHANGED FLAG\nCPFCHPOS EQU   X'02'   POSITIONAL CHANGE\nCPFCHND  EQU   X'01'   TERMINATE CHANGE FLAG\n         SPACE ,\n* SHOW DSNAMES & CONSOLE MSGS USAGE\nCPFSTOP  EQU   X'01'   STOP 2741 LIST FLAG FOR DSNAMES & CONSOLE MSGS\n         SPACE ,\n* READ USAGE\nCPFRDNO  EQU   X'02'   LINE NUMBER FLAG FOR READ\nCPFRDEL  EQU   X'01'   DELETE LINE AFTER READ FLAG\n         SPACE ,\n* SHOW SIZE USAGE\nCPFFIRST EQU   X'01'   TURNS ON 'NOT FIRST TIME' FLAG\nCPFCOUNT EQU   X'02'   TURNS ON 'DONT DISPLAY COUNT FLAG'\n         SPACE 2\nCPLFLG3  DS    X       THIRD LOCAL FLAG BYTE\n         SPACE ,\nCPFSET   EQU   X'80'   SET PREFIX AFTER SCAN (USE-SAVE-COPY-SCR)\nCPFDSCLG EQU   X'40'   CATALOG DATA SET (SAVE AND MISC)\nCPFUNCLG EQU   X'20'   UNCATALOG DATA SET (SAVE AND MISC)\nCPFRECLG EQU   CPFDSCLG+CPFUNCLG  (SAVE AND MISC)\n         SPACE ,\n* SHOW DSNAMES/DIRECTORY USAGE\nCPFPROTF EQU   X'20'   PROTECT OPTION FLAG\nCPFDATED EQU   X'10'   DATED OPTION FLAG\nCPFEXCL  EQU   X'08'   EXCLUDE OPTION FLAG\nCPFSPACE EQU   X'04'   SPACE OPTION FLAG\nCPFTYPE  EQU   X'02'   TYPE/ALL OPTION FLAG (SHOW DSN/DIR RESP.)\n         SPACE ,\n* SHOW DSNAMES/DIRECTORY - PUT USAGE\nCPFPUT   EQU   X'01'   PUT IN ACTIVE FILE\nCPFNOL   EQU   X'40'   PUT AND DONT LIST\nCPFPUTER EQU   X'08'   ERROR IN STOWING\nCPFPMSG  EQU   X'80'   GAVE PAGE SHRTGE MSG ALREADY\n         SPACE ,\n* CHANGE USAGE\nCPFCHIN  EQU   X'80'   RANGE SPECIFIED\nCPFCHUS  EQU   X'40'   CHANGE USING\nCPFCHTO  EQU   X'20'   CHANGE TO\nCPFCHNM  EQU   X'10'   CHANGE TO NUMBERS\nCPFCHNMI EQU   X'08'   INCREMENT NUMBER FLAG\nCPFCHLN  EQU   X'04'   LINE OPTION\nCPFCHREP EQU   X'02'   REPEAT OPTION FOR USING RANGE\nCPFCHALL EQU   X'01'    CHANGE ALL COLS TO UPPER OR LOWER       JEP005\n         SPACE ,\n* LIST USAGE\nCPFCLEAN EQU   X'80'   CLEAN LIST\n         SPACE ,\n* CPLBYT1 & CPLBYT2 NO LONGER USED BY LIST OR CHANGE\n         SPACE 2\nCPLFLG4  DS    1X      FOURTH LOCAL FLAG BYTE\n         SPACE ,\nCPFSTSPL EQU   X'80'   PAGE SPLIT AT LINE NUMBER FLAG FOR STOWIT\nCPFSTINS EQU   X'40'   ALLOW INSERT ONLY FLAG FOR STOWIT\nCPFDESET EQU   X'20'   THIS FLAG SIGNALS TO DESPOT THAT THE\n*                      VALUE OF CPNWLN HAS BEEN SET FOR THE NEXT\n*                      LOCATE AND SHOULD NOT BE KICKED UP.\n         SPACE ,\nCPFDESRT EQU   X'10'   RE-ENTRY TO DESPOT -- DON'T RESET RANGE\n*                      THIS ALLOWS RUN TO HANDLE DISJOINT RANGES AND\n*                      COUNT RANGES PROPERLY BUT IT DOES PROHIBIT\n*                      OCCURRENCE COUNTS FOR ASSOCIATIVE RANGES\n*                      AS WELL AS RE-USE OF THE RANGE AFTER RETURN\n*                      FROM DESPOT\nCPFCHUP  EQU   X'08'   USED BY CHANGE TO UPPER                  JEP005\nCPFCHLO  EQU   X'04'   USED BY CHANGE TO LOWER                  JEP005\n         SPACE ,\nCPFNOCUR EQU   X'02'   NO ABORT IF CURRENT, NEXT, OR PREVIOUS\n*                      DO NOT EXIST\n         SPACE ,\nCPFNOINC EQU   X'01'   NO INCREMENT ON LINE NUMBERS\n         SPACE 2\nCPLFLG5  DS    1X   FIFTH LOCAL FLAG BYTE\n         SPACE ,\n* COMMON FLAG BITS OF CPLFLG5 USED BY MANY COMMANDS\nCPFUNUM  EQU   X'80'   UNNUMBERED FLAG\nCPFNTEX  EQU   X'40'   NOTEXT LISTING CONTROL FLAG\nCPFNONUM EQU   CPFUNUM+CPFNTEX NONUMBER LISTING CONTROL FLAG\nCPFNLST  EQU   X'20'   NOLIST LISTING CONTROL FLAG\nCPFFOPT  EQU   X'10'   SET IF ANY NUMBER OPTION SPECIFIED\nCPFINT   EQU   X'08'   EXPAND LINE NUMBERS AS INTEGERS FLAG\nCPFSELOC EQU   X'06'   RANGE SELECTION FLAG BITS\n*              X'00'   USE NORMAL ACTIVE FILE FOR RANGE\n*              X'02'   USE EXEC FILE FOR RANGE\n*              X'06'   USE EXTERNAL FILE FOR RANGE\nCPFSELEX EQU   X'02'   RANGE WILL BE SELECTED FROM EXEC FILE\nCPFNCUR  EQU   X'01'   DON'T CHANGE CURRENT LINE POINTER FLAG\n         SPACE 3\nLFLG1    DS    1X      *****LOCAL FLAG BYTE 1*****              JEP010\nCPF3277  EQU   X'01'        3277 RECOGNITION                    JEP004\nLFLG2    DS    1X      *****LOCAL FLAG BYTE 2*****              JEP010\nLFLG3    DS    1X      *****LOCAL FLAG BYTE 3*****              JEP010\nLFLG4    DS    1X      *****LOCAL FLAG BYTE 4*****              JEP010\n         SPACE 3                                                JEP010\n* CPDRPT - CPLCNO - CPREVLN SET BY LOCATE LINE ROUTINES\nCPDRPT   DS    1F      ADDR DIR ENTRY OF LOCATE PG (1ST BYTE=FLAGS)\n         SPACE ,\nCPFNTYT  EQU   X'80'   NOTHING AT ALL IN USER'S DATA SET YET\nCPFHIGH  EQU   X'40'   HIGHER THAN ANY LINE NO. IN USER'S DATA SET YET\nCPFPGHI  EQU   X'20'   GTR THAN ANY LINENO ON PG, LESS THAN 1ST ON NEXT\nCPFPGLW  EQU   X'10'   FIRST LINE ON PAGE\nCPFMTCH  EQU   X'08'   LINE NO. MATCHES EXACTLY A PRE-EXISTING ONE\nCPFFSLN  EQU   X'04'   LINE NO. LESS OR EQUAL FIRST OF ALL\nCPFPGND  EQU   X'02'   LINE WAS LAST ON A TEXT PAGE\nCPFNDDS  EQU   X'01'   LINE WAS LAST IN WORKING DATA SET\n         SPACE ,\nCPLCNO   DS    1F   INTERNAL LINE NUMBER OF LOCATED LINE\nCPREVLN  DS    1F   LINE NO. PREVIOUS TO LOCATED IF ON SAME TEXT PAGE\nCPDIRCNT DS    H    RESIDUAL PAGE COUNT AFTER LOCATE\nCPGDISP  DS    H    PAGE DISPLACEMENT TO LOCATED LINE\n         SPACE ,\n* DETRNG SETS CPFSLN-CPLSLN-CPSTLN-CPSTAD-CPCMPST-CPCMPLN-CPMDLN-CPMDAD\n         SPACE ,\nCPNWLN   DS    1F   USED BY DESPOT TO REMEMBER LINE NO. IT'S AT\nCPFSLN   DS    1F   1ST LINE NO. IN RANGE\nCPLSLN   DS    1F   LAST LINE NO. IN RANGE\nCPCMPST  DS    1F   DISPLACEMENT INTO LINE OF FIELD FOR MATCH\nCPCMPLN  DS    1F   LENGTH OF MATCH FIELD\nCPSTLN   DS    1F   0=EXPL RNG, POS=LEN ASSOC CHAR STR, NEG=BLANK LINES\nCPSTAD   DS    1F   ADDRESS OF CHAR STRING FOR ASSOCIATIVE RANGE\n         SPACE ,\n* FLAGS FOR CPSTAD (FIRST BYTE)\nCPFEXPRG EQU   X'80'   EXPLICIT RANGE FLAG\nCPFSTRRG EQU   X'40'   ASSOCIATIVE RANGE FLAG (OVER WHOLE LINE)\nCPFLIMRG EQU   X'20'   ASSOCIATIVE RANGE FLAG(OVER SPECIFIED POSITIONS)\nCPFONERG EQU   X'10'   START POSITION FOR STRING SPECIFIED FLAG\nCPFBLKRG EQU   X'08'   BLANK LINE RANGE FLAG\nCPFMODS  EQU   X'04'   MODS SPECIFIED FLAG\nCPFDSJNT EQU   X'02'   DISJOINT EXPLICIT RANGE FLAG\nCPFSOME  EQU   X'01'   NON-VOID RANGE FLAG\n         SPACE ,\n* CPMDLN & CPMDAD ALSO USED BY LOCATE AND SHOW COMMANDS\nCPMDLN   DS    1F   NO. OF MODS OR NO EXPLICIT LINE NOS IN RANGE (0-10)\nCPMDAD   DS    10F  THE MODS OR LINE NOS.\n         SPACE ,\n* CPDRED FOR USE, SAVE, COPY, RUN, PUNCH, LIST OFFLINE\nCPDRED   DS    2F   ADDRESS OF BUFFER FOR EXTERNAL DATA SETS\n*              FLAG USED IN CPDRED\nCPFSTART EQU   X'F0'   SIGNAL 1ST READ OR NOT\n         SPACE ,\n* CPWKPS & CPWKDL ARE USED WHERE REQUIRED\n         SPACE ,\nCPWKPS   DS    1F   WORK POSITION\nCPWKDL   DS    1F   WORK DELTA\n* AS USED DURING RANGE DETERMINATION\nCPTELL   EQU   CPWKPS   (CPWKPS & CPWKDL - USED IN RANGE DETERMINATION)\nCPRCVSZ2 EQU   *-CPDRPT\n         EJECT\n* WORK CELLS FOR LOCAL USE BY TEXT-EDITING COMMANDS\n         SPACE ,\nCPWK1    DS    1F   WORK CELLS\nCPWK2    DS    1F\nCPWK3    DS    1F\nCPWK4    DS    1F\nCPWK5    DS    1F\nCPWK6    DS    1F\n         SPACE ,\n* CPWK1, CPWK2 & CPWK3 USED BY LXCATE (EXTERNAL COPY)\n* CPWK4 USED BY MOVE & COPY\n* CPWK1, CPWK2 & CPWK3 USED BY SHOW OPERATOR\n* CPWK1 USED BY IMMEDIATE DELETE IN BWYL\n         SPACE ,\n* CPWK6 AS USED BY RUN, PUNCH, SAVE, AND USE\nCPSEQFLD EQU   CPWK6   START OF SEQ FIELD FOR NUMBERED\nCPSEQLN  EQU   CPWK6+2 LENGTH OF SEQ FIELD FOR NUMBERED\n         SPACE ,\n* AS USED BY \"CHANGE\"\n         SPACE ,\nCPCHCST  EQU   CPWK1   DISPLACEMENT IN LINE OF CHANGE TARGET FIELD\nCPCHCLN  EQU   CPWK2   LENGTH OF FIELD\nCPCHLN1  EQU   CPWK3   LENGTH OF STRING TO MATCH\nCPCHAD1  EQU   CPWK4   IT'S ADDRESS\nCPCHMOD  EQU   CPCHAD1 USE FIRST BYTE FOR OCCURRENCE COUNT\nCPCHLN2  EQU   CPWK5   LENGTH OF STRING TO USE AS REPLACE\nCPCHAD2  EQU   CPWK6   IT'S ADDRESS\n         SPACE ,\n* AS USED BY \"MOVE\" & \"COPY\"\nCPBGLN   EQU   CPWK5   1ST LINE NO. OF COPY-MOVE\nCPNDLN   EQU   CPWK6   START OF REPLACE/INTERLEAVE ON COPY-MOVE\n         SPACE ,\n* AS USED BY \"USE\" & \"SAVE\"\nCPLRCL   EQU   CPWK1   LRECL FOR USE-SAVE\nCPNREC   EQU   CPWK2   BLOCKING FACTOR FOR USE-SAVE\nCPRCSZ   EQU   CPWK3   BLOCKSIZE FOR USE-SAVE\nCPNXAD   EQU   CPWK4   WORK CELL FOR USE-SAVE\nCPNWCT   EQU   CPWK5   WORK CELL FOR USE-SAVE\n         SPACE ,\n* AS USED BY \"ALIGN\"\nCPNAWAPT EQU   CPWK1   WORK AREA ADDR FOR ALIGN\n         SPACE ,\n* AS USED BY \"READ\"\nCPWKRD   EQU   CPWK1   LINE NUMBER FOR READ COMMAND\n         SPACE ,\n* AS USED BY \"LIST/POINT\"\nCPSPAC   EQU   CPWK4\n* AS USED BY \"COLLECT\"\nCPNXPS   EQU   CPWK1   COMPARE HERE FOR INTERLEAVE OR OVERLAY\n         SPACE ,\n* AS USED BY \"EXEC\"\nCPEXLNET EQU   CPWK6   SPECIFIED LINE NO. FOR EXEC\n         SPACE ,\n* AS USED BY SHOW SIZE\nCPOVSIZE EQU   CPWK1   WORK CELL FOR SHOW SIZE\n         SPACE 3\nCPWORK1  DS    F\nCPWORK2  DS    F\n         SPACE 2\nCPSYSFLG DS    X\n         SPACE ,\nCPFRNGCM EQU   X'40'\nCPFTUSXC EQU   X'20'\nCPFNTYPD EQU   X'10'\n         SPACE ,\nCPPROTFL DS    X                   PERMIT FLAGS\n         SPACE ,\nCPSPARE  DS    1F   1 SPARE  (USED TO BE 2--1 TAKEN FOR FLAGS)  JEP010\n         SPACE ,\n* PRE-PROC INFO\nCPRSCNVL DS    H                   RESCAN VALUE\nCPESCAPE DS    X                   ESCAPE CHAR\nCPSKIP   DS    X                   SKIP CHAR\n         SPACE ,\nCPSAVE   DS    2A   SCAN SAVES PTRS LAST ITEM HERE\n         EJECT\nCPWA     DS    199F                    WORK AREA\n         SPACE ,\n* FIRST PART OF CPWA USED FOR DSNAME WORK AREA WHEN REQUIRED.\nCPDSNWA  EQU   CPWA                DSNAME WORK AREA\n         SPACE 2\nCPCTSAV  EQU   CPWA+600    WT-EDT COMMAND COUNT TEMP SAVE\nCPCMSAV  EQU   CPWA+604    WT-EDT COMMAND TEMP SAVE (NOT TYPED)\n* CPCTSAV & CPCMSAV USED BY EXEC TO KEEP UNPRESSED COMMANDS\n         SPACE ,\nCPCHECK  DC    X'6913723F'             CHECK FOR OVERFLOW\n         SPACE ,\nCPSIZE   EQU   3016   1952 1584        SIZE OF CONTROL PAGE\n         SPACE ,\nCPTNPG   EQU   (CPAREA+2*CPSIZE-*)/6   TOTAL NO. OF DIRECTORY ENTRIES\n         SPACE ,\nCPDREC   DS    0X                      START OF DIRECTORY\nCPRCVSZ3 EQU   CPSTART+CPSIZE-CPDREC   1ST DIRECTORY SIZE\n         SPACE ,\n         ORG   CPSTART+2*CPSIZE\n./ ADD NAME=DAIRINT,SSI=00000168\n         TITLE  'DAIR DEFAULT PARAMS FOR INTRDR'\nDAIRINT  DS    0F\nDAIR30   DC    X'0030'\n         DC    X'0000'\n         DC    X'00000000'\n         DC    F'0'\n         DC    CL8'WYLRDR'\n         DC    CL8' '\n         DC    CL8' '\n         DC    F'80'\n         DC    F'0'\n         DC    F'0'\nDAIRWTR  DC    CL8'INTRDR'\n         DC    CL4' '\n         DC    XL3'000000'\n         DC    X'80'\n         DC    CL8' '\n         DS    0F\nDAIR18   DC    X'0018'\n         DC    X'0000'\n         DC    X'0000'\n         DC    X'0000'\n         DC    AL4(0)\n         DC    CL8'WYLRDR'\n         DC    CL8' '\n         DC    C'O'\n         DC    X'0'\n         DC    X'0'\n         DC    X'0'\n         DC    8X'0'\nDAINTSZ  EQU   *-DAIRINT\nWYLRDR   ACB   DDNAME=WYLRDR,MACRF=(ADR,SEQ,OUT)\nRPL      RPL   ACB=WYLRDR,RECLEN=255,OPTCD=(ADR,SEQ,SYN,NUP),          X\n               AREA=BUF,AREALEN=255,CCHAR=CCHAR\nECB      DC    F'0'\nBUF      DC    CL255' '\nCCHAR    DC    C' '\n./ ADD NAME=PIOB\nPIOBSTRT DS    0D\nPIOBFLG1 DC    X'42'\n         DC    X'00'\nPIOBSNS  DC    X'0000'\n         DC    X'00'\nPIOBECB  DC    AL3(PECB)\nPIOBCSW  DC    2A(0)\n         DC    X'00'\nPIOBCCW  DC    AL3(PCCWS)\n         DC    X'00'\nPIOBDCB  DC    AL3(0)\n         DC    2A(0)\nPSEEK1   DC    XL8'0'\nPSEEKREC EQU   PSEEK1+7\nPSEEK2   DC    XL8'0'\nPSEEK3   DC    XL8'0'\nPSEEK4   DC    XL8'0'\nPCCWS    DS    0D\nPCCWSID1 CCW   X'31',PSEEK1+3,X'40',5\nPCCWTIC1 CCW   X'08',*-8,0,0\nPCCWWRT1 CCW   X'05',0,X'40',CPSIZE      JCBWAPTR\nPCCWSID2 CCW   X'31',PSEEK2+3,X'40',5\nPCCWTIC2 CCW   X'08',*-8,0,0\nPCCWWRT2 CCW   X'05',0,X'40',CPSIZE      JCBWAPTR+CPSIZE\nPCCWSID3 CCW   X'31',PSEEK3+3,X'40',5\nPCCWTIC3 CCW   X'08',*-8,0,0\nPCCWWRT3 CCW   X'05',0,X'40',CPSIZE      2ND CP PAGE\nPCCWSID4 CCW   X'31',PSEEK4+3,X'40',5\nPCCWTIC4 CCW   X'08',*-8,0,0\nPCCWWRT4 CCW   X'05',0,0,CPSIZE          VCP\nPECB     DC    A(0)\n         DS    0D\nPIOBSIZE EQU   *-PIOB\n./ ADD NAME=VCPTSO,SSI=00000168\nDVCP     DSECT\nVCP#SVAR EQU   16                 # OF STRING VARIABLES\nVCPR     EQU   9                  BASE REG\nVCPWVAR  DS    XL64               LINE # AREA\nVCPLVAR  EQU   VCPWVAR\nVCPNVAR  DS    XL64               INTEGER AREA\nVCPSVAR  DS    XL1380             STRING AREA\nVCPLSVA  EQU   *-VCPSVAR          LENGTH OF STRING AREA\nVCPLNG   EQU   *-DVCP\nVCPPVAR  DS    XL600           USE FOR PFK'S\nVCPSPVA  EQU   *-VCPPVAR       SIZE OF PFK AREA\n./ ADD NAME=WDIOWA   0102-80182-80218-0926-00371-00371-00000-$SYS13  00\n         MACRO\n&NM      WDIOWA &TYPE\n         SPACE ,\n         AIF   ('&TYPE' EQ '').NOSECT\n         AIF   ('&TYPE'(1,1) EQ 'C').CSECT\n         AIF   ('&TYPE'(1,1) EQ 'D').DSECT\n         MNOTE 4,'&TYPE INVALID - IGNORED'\n         AGO   .NOSECT\n.DSECT   ANOP\n&NM      DSECT\n         AGO   .START\n.CSECT   ANOP\n&NM      CSECT\n         AGO   .START\n.NOSECT  ANOP\n&NM      DS    0D\n.START   ANOP\n*                                                               JEP013\n*                                                               JEP013\n* MOD JEP013                                                    JEP013\n*  CHANGED DEFAULT NAME FROM WYL.CU.CTR.VTOC TO FDRABR  ITEL    JEP013\n*  DENOTED JEP013 IN 66/71.  JERRY PITTENGER                    JEP013\n*                                                               JEP013\n         SPACE 2\n         DS    0D\nWADECB   DC    AL1(255),AL3(DECB)\nUCB      DC    A(0)      UCB ADDR FOR SPEC VOLUME\n         SPACE\nDFL      DC    X'00'     FLAGS\n         SPACE ,\nDFREPL   EQU   X'08'     STOW REPL TO BE DONE AT CLOSE\nDFUPTSPC EQU   X'02'     UPDATE SPACE ACCTG AT CLOSE\nDFUSPCNM EQU   X'01'     NO COND SHOW SPACE CALL IF ON\n         SPACE 2\nFLAGS    DS    CL5       SAVE DSNAME FLAGS\nF1       EQU   FLAGS          FIRST DSNAME FLAG\nF2       EQU   FLAGS+1        SECOND DSNAME FLAG\nF3       EQU   FLAGS+2        THIRD DSNAME FLAG\nF4       EQU   FLAGS+4        FOURTH DSNAME FLAG\nF5       EQU   FLAGS+5        FIFTH DSNAME FLAG\n         SPACE ,\nDSDD     DC    CL8'IOVVVVVV'  DDNAME\n         SPACE 2\n* EXLST FOR DCB\nEXLST    DS    0F\n         DC    X'00'               ENTRY TO BE FILLED IN\n         DC    AL3(0)\n         DC    X'87'               LAST ENTRY/JFCB POINTER\n         DC    AL3(JFCB)\n         SPACE 2\n* IOB FOR EXCP\nIOB      DS    0D\n         DC    XL2'C200'\nIOBSNS   DC    H'0'\n         DC    A(DECB)\nIOBCSW   DC    2F'0'\nIOBSTART DC    F'0'\n         DC    A(FOURS)       DCB\n         DC    2F'0'\n         DC    XL1'0'\nIOBB     DC    XL2'0'\nSEEK     DC    XL5'0'\n         SPACE 2\n* CHANNEL PROGRAM FOR EXCP\nMT       EQU   X'80'          MULTI-TRACK\nSCHIDEQ  EQU   X'31'          SEARCH ID EQUAL\nTIC      EQU   X'08'          XFER IN CHANNEL\nSCHKYEQ  EQU   X'29'          SEARCH KEY EQUAL\nSCHKYHI  EQU   X'49'          SEARCH KEY HIGH\nSCHKYHE  EQU   X'69'          SEARCH KEY HI OR EQUAL\nSCHKADEQ EQU   X'2D'          SEARCH KEY AND DATA EQUAL\nSCHKADHI EQU   X'4D'          SEARCH KEY AND DATA HIGH\nSCHKADHE EQU   X'6D'          SEARCH KEY AND DATA HI OR EQUAL\nSWKADKY  EQU   SCHKADHE-SCHKYHE    USED TO SWAP SCH KAD/SCH KEY\nRDCNT    EQU   X'12'          READ COUNT\nRDDATA   EQU   X'06'          READ DATA\nRDKYDATA EQU   X'0E'          READ KEY AND DATA\nNOPIC    EQU   X'03'          NOP IN CHANNEL\nCC       EQU   X'40'          COMMAND CHAIN\nDC       EQU   X'80'          DATA CHAIN\nSLI      EQU   X'20'          SLI\nSKP      EQU   X'10'          SKIP DATA XFER\n         SPACE ,\nSRCHCCW  CCW   SCHIDEQ,SEEK,CC+SLI,5         SEARCH FOR PREV REC\n         CCW   TIC,SRCHCCW,CC+SLI,0\nCCWSW    CCW   TIC,ID,CC+SLI,0               SWITCH BETWEEN ID & PDSRD\nID       CCW   SCHIDEQ+MT,ENDTEST,CC+SLI,5   LAST VTOC REC?\n         CCW   TIC,KEY,CC+SLI,0              TIC IF NO\n         CCW   TIC,ENDCCW1,CC+SLI,0          TIC IF YES\n*              LENGTH FIELD IS CHANGED IN FOLLOWING CCW\nKEY      CCW   SCHKADEQ+MT,DSNAME,CC+SLI,0   IS REC ONE WE WANT?\n         CCW   TIC,ID,CC+SLI,0               TIC IF NO\n         CCW   RDCNT+MT,SRCHC,SLI,5          READ ADDR OF FOLL REC\n* END OF THIS PART OF COMMAND CHAIN\n         SPACE 2\n*              LENGTH FIELD IS CHANGED IN FOLLOWING CCW\nENDCCW1  CCW   SCHKADEQ,DSNAME,CC+SLI,0  IS LAST VTOC REC ONE WE WANT?\n         CCW   TIC,ENDCCW,CC+SLI,0       TIC IF NO\n         CCW   NOPIC,SEEK,CC+SLI+SKP,1   DUMMY CMND\nENDCCW2  CCW   SCHIDEQ,ENDTEST,CC+SLI,5  SO WE CAN SEARCH AGAIN\n         CCW   TIC,ENDCCW2,CC+SLI,0\nREADCCW2 CCW   RDKYDATA,DS1DSNAM,SLI,DS1END-DS1DSNAM  READ DSCB\n* END OF THIS PART OF COMMAND CHAIN\n         SPACE 2\nENDCCW   CCW   NOPIC,SEEK,SLI,1      DUMMY CMD TO FLAG END OF SEARCH\n* IF FINAL CSW POINTS HERE THEN THE VTOC HAS BEEN COMPLETELY SEARCHED\n         SPACE ,\n* CHANNEL PROGRAM RESTARTED HERE IF A RECORD FOUND WE WANT\nREADCCW  CCW   SCHIDEQ,SRCHC,CC+SLI,5     SEARCH FOR THE ONE WE WANTED\n         CCW   TIC,READCCW,CC+SLI,0\n         CCW   RDKYDATA,DS1DSNAM,SLI,DS1END-DS1DSNAM    READ DSCB\n* END OF THIS PART OF COMMAND CHAIN\n         SPACE 2\n* CHANNEL PROGRAM SECTION FOR READING PDS DIRECTORY\nPDSREAD  CCW   RDCNT+MT,SRCHC,CC+SLI,5\n         CCW   RDKYDATA,DBUF,SLI,264\n         SPACE 3\n* MISCELLANEOUS WORK AREAS AND CONSTANTS\nCCREDT   DS    D\nDSNAME   DS    CL44\nDSN      DC    44X'04'\n         SPACE ,\nBLDL     DS    0F\n         DC    H'1'           ONE ENTRY\n         DC    AL2(BLDLSZ)    LENGTH OF ENTRY\nMEMBER   DS    CL8            MEMBER NAME\nBLDLTTR  DS    CL3            MEMBER TTR\nBLDLKZC  DS    CL3            OTHER BLDL TRASH\nBLDLSZ   EQU   *-MEMBER\n         ORG   BLDLKZC+1      STOW REQUIRES C BUT NOT K AND Z\nSTOWLTTR DS    F              DATE OF LAST STOW OR SSI\nSTOWSZ   EQU   *-MEMBER       SIZE OF DIRECTORY ENTRY STOWED\n         SPACE ,\nRRECFM   DS    CL1            RECFM\n         SPACE ,\nSCRVLST  DS    0F             SCRATCH LIST AND OTHERS\n         DC    H'1'           NUMBER OF VOLUMES\nDEVCODE  DS    CL4            RESULT OF DEVTYPE\nDSVID    DS    CL6            VOLUME ID\n         DC    X'0'           BYTE OF ZERO\nSCRRET   DC    X'0'           RETURN CODE FROM SCRATCH\n         SPACE 3\nVTOCCCW  DC    AL3(ID)        TIC ADDR FOR SHOW DSNAMES\nPDSCCW   DC    AL3(PDSREAD)   TIC ADDR FOR SHOW DIRECTORY\nLASTCCW  DC    AL3(ENDCCW+8)  ADDR IN CSW WHEN VTOC SEARCH DONE\nLASTCCW1 DC    AL3(ENDCCW)    ADDR IN CSW WHEN LAST VTOC REC WANTED\nRECSIZE  DS    F\nLRECSIZE DS    F\nERROR    DS    F\nSPACE    DS    F\nDEVBLOCK DS    F              DEVICE BLOCK SIZE\nRETCOD   DS    F\n         EJECT\n* DECBS AND PARAMTER LISTS\n         SPACE ,\n         READ  DECB,SF,DCB,DBUF,MF=L\n         SPACE 3\nDSCB     CAMLST SEARCH,DSNAME,DSVID,DS1FMTID\n         SPACE 3\nSCRLST   CAMLST SCRATCH,DSNAME,,SCRVLST\n         SPACE 3\nUSCATL   CAMLST NAME,DSNAME,,CATBLOCK\n         SPACE 3\nUSCATL2  CAMLST BLOCK,CATNTTR,CATVOLID,CATBLOCK\nCAMVOLID EQU   USCATL2+8      ADDR OF VOLUME ID PTR IN PREV LIST A26\n         SPACE 3\nVTOC     CAMLST SEARCH,DSN,DSVID,VTOCAREA\n         SPACE 3\nVTOC3    CAMLST SEEK,DS1PTRDS,DSVID,IECSDSL3\n         SPACE 3\nCATLST   CAMLST CAT,DSNAME,,SCRVLST     USED FOR CAT/UNCAT/RECAT\n         SPACE 3\nOPENLIST OPEN  (DCB),MF=L\n         SPACE 3\nENQDSN   ENQ   (,DSNAME,,,SYSTEM),RET=USE,MF=L\n         EJECT\n* DUMMY  DCBS\n         SPACE 2\n* DUMMY DCB TO ALLOCATE SPACE FOR DCB TO BE MOVED IN\nDCB      DCB   DSORG=PS,MACRF=(RP,WP)\n         EJECT\nFOURS    DCB   DSORG=PS,MACRF=E,EXLST=EXLST\n         EJECT\n***  THE DATA BUFFER IS ALSO USED AS A WORK AREA AND FOR READING\n**    VARIOUS CONTROL BLOCKS.  IT IS CAREFULLY CONSTRUCTED SO\n**    THAT AREAS WHICH ARE REQUIRED SIMULTANEOUSLY DO NOT OVERLAY\n**    EACH OTHER.  THE OVERLAY STRUCTURE IS AS FOLLOWS:\n*\n**   DBUF      FMT 4 DSCB WORK AREA\n**     |       SHOW DSNAMES WORK AREA\n**     |       JFCB AREA\n**     |       LOCATE VOL WORK AREA\n**     |       REST OF CATLG BLOCK AREA      DSCB1/3/5 WORK AREAS\n**     |                 |                            V\n**     |                 V\n**     |       SHOW DSNAMES BUFFER           SHOW CATLG BUFFER\n**     |                 |                   CLEAR JFCB WORK AREA\n**     |                 V                            |\n**     |                                              V\n**     |                                     SUBTASK R13 REG SV AREA\n**     |                                              V\n**     |\n**     V\n         SPACE 3\n* DAIR INTERFACE:\nWAUPT    DC    A(0)\nWAECT    DC    A(0)\nWAECB    DC    A(WADARECB)\nWAPSCB   DC    A(0)\nWADAIR   DC    A(DA08CD)\nWADARECB DC    F'0'\nDAIRDSN  DC    AL2(44)                                         JJGP013\nDSNPREF  DC    CL9'DPC1.VOL.'                                  JJG\nDSNVOL   DC    CL6' '                                          JJG\n         DC    CL29' '                                         JJG\n***********************************************************************\n* THIS OPERATION CODE CAUSES ALLOCATION OF A DATA SET. IT CAN ALLOC.  *\n* EITHER A NEW OR OLD SET.                                            *\n***********************************************************************\n         DS    0F\nDA08CD   DC    AL2(8)   DAIR ENTRY CODE\nDA08FLG  DC    X'00'    FUNCTIONS TO BE PERFORMED WHEN RET CODE IS 0\nDA08FPE  EQU   X'80'    FUNCT PERFORMED BUT ERROR INDICATED BY RETCD\n         DC    X'00'\nDA08DARC DC    H'0'     DYN ALLOC RETURN CODE\nDA08CTRC DC    H'0'     CATALOG RETURN CODE\nDA08PDSN DC    A(DAIRDSN)   PTR TO DSNAME TO BE SEARCHED IN DSE\nDA08DDN  DC    CL8' '   DDNAME TO BE SEARCHED IN DSE\nDA08UNIT DC    CL8' '   UNITNAME REQUESTED\nDA08SER  DC    CL8' '   VOLUME SERIAL NUMBER-PADDED W/BLANKS\nDA08BLK  DC    F'0'     DATA SET  AVERAGE RECORD LENGTH\nDA08PQTY DC    F'0'     PRIMARY SPACE QUANTITY\nDA08SQTY DC    F'0'     SECONDARY SPACE QUANTITY\nDA08DQTY DC    F'0'     DIRECTORY BLOCK QUANTITY\nDA08MNM  DC    CL8' '   MEMBER NAME\nDA08PSWD DC    CL8' '   PASSWORD\nDA08DSP1 DC    X'08'    DATA SET STATUS FLGS(IF=0 OLD ASSUMED)\nDA08SHR  EQU   X'08'    DATA SET IS SHR\nDA08NEW  EQU   X'04'    DATA SET IS NEW\nDA08MOD  EQU   X'02'    DATA SET IS MOD\nDA08OLD  EQU   X'01'    DATA SET IS OLD\nDA08DPS2 DC    X'08'    DATA SET DISPOSITION(IF=0 KEEP ASSUMED)\nDA08KEEP EQU   X'08'    DS DISP IS KEEP\nDA08DEL  EQU   X'04'    DS DISP IS DELETE\nDA08CAT  EQU   X'02'    DS DISP IS CATLG\nDA08UCAT EQU   X'01'    DS DISP IS UNCATALOG\nDA08DPS3 DC    X'08'    DATA SET CONDITIONAL DISPOSITION\nDA08KEP  EQU   X'08'\nDA08DELE EQU   X'04'\nDA08CATL EQU   X'02'    DS DISP OF CATLG DESIRED\nDA08UNCT EQU   X'01'    DS DISP OF UNCATLG DESIRED\nDA08CTL  DC    X'08'    FLAGS TO CONTROL ACTIONS TAKEN BY DAIR\nDA08TRKS EQU   X'80'    UNITS ARE TRKS\nDA08ABKL EQU   X'40'\nDA08CYLS EQU   X'C0'    UNITS ARE CYLS\nDA08UID  EQU   X'20'    USER ID IS TO BE PREFIXED\nDA08RLSE EQU   X'10'    RELEASE (RLSE) REQUESTED\nDA08PERM EQU   X'08'    DATA SET MUST BE SPECIFICALLY UNALLOCATED\nDA08DMMY EQU   X'04'\nDA08ATRL EQU   X'02'    ATTRIBUTE LIST SUPPLIED\n         DC    XL3'00'  RESERVED\nDA08DSO  DC    XL1'00'  DSORG\nDA08ALN  DC    CL8' '   ATTR-LIST-NAME\n***********************************************************************\n* THIS OPERATION CAUSES THE REQUESTED DATA SET OR DDNAME TO BE        *\n* UNALLOCATED. DISPOSITION CAN BE SPECIFIED TO OVERRIDE ANY PREVIOUS  *\n* DISPOSITION. LIKENISE SYSOUT CLASS MAY BE SPECIFIED TO OVERRIDE ANY *\n* PREVIOUS CLASS.                                                     *\n***********************************************************************\n         DS    0F\nDA18CD   DC    AL2(24)  DAIR ENTRY CODE\nDA18FLG  DC    X'00'    FUNCTIONS TO BE PERFORMED WHEN RET CODE IS 0\nDA18FPE  EQU   X'80'    FUNCT PERFORMED BUT ERROR INDICATED BY RETCD\n         DC    X'00'\nDA18DARC DC    H'0'                    DYNAMIC ALLOCATION RETURN CODE\nDA18CTRC DC    H'0'               CATALOG RETURN CODE AREA\nDA18PDSN DC    A(0)         PTR TO DSNAME TO BE SEARCHED IN DSE\nDA18DDN  DC    CL8' '   DDNAME TO BE SEARCHED IN DSE\nDA18MNM  DC    CL8' '   MEMBER NAME\nDA18SCLS DC    CL2' '   SYSOUT CLASS DESIRED WHEN UNALLOCATING  A\n*                       SYSOUT DATA SET\nDA18DPS2 DC    X'08'    DATA SET DISPOSITION\nDA18KEEP EQU   X'08'    CHANGE DISP TO KEEP\nDA18DEL  EQU   X'04'    CHANGE DISP TO DELETE\nDA18CAT  EQU   X'02'    CHANGE DISP TO CATALOG\nDA18UCAT EQU   X'01'    CHANGE DISP TO UNCATLOG\nDA18CTL  DC    X'10'    FLAGS FOR SPECIAL DAIR PROCESSING\nDA18UID  EQU   X'20'    USER ID IS TO BE PREFIXED TO DSNAME\nDA18PERM EQU   X'10'    UNALLOCATE PERM. ALLOCATED DSE'S\nDA18JBNM DC    CL8' '\n         SPACE ,\nATTDECB  DC   A(0)                 ECB FOR ATTACH\nWATTACH  ATTACH EP=IKJEFT01,ECB=ATTDECB,SF=L\n         DS    0F\nWASTAX   DC    5A(0)               STAX PARAMETER LIST\nDBUF     DS    0D\nDBUFSIZE EQU   19069\nACCTWA   EQU   DBUF       ACCOUNTING WORK AREA\n         DS    (DBUFSIZE)C\n         SPACE 3\n* WORK AREA FOR DVTOC\n         SPACE ,\n* FIRST PART IS FORMAT 4 DSCB AREA\n         ORG   DBUF\nVTOCAREA DS    0D\n         IECSDSL1 4\n         ORG   DS4VTOCE       FMT 4 EXTENT DESCRIPTION\n         DS    CL2\nVTOCBEG  DS    CL4\nVTOCEND  DS    CL4\n         DS    279C\n         SPACE 3\nPAGEGET  DS    F\nVTOCSV   DS    11F\nWAR14    EQU   VTOCSV    REG SAVE AREA FOR SUBTASK COMMUNICATION\nWAR15    EQU   WAR14+4\n*\nENDTEST  DS    XL5\n*\n*\nDVTAREA  DVTAREA ,                 DEFINE DEVCODE AREA\n*\n*\nNUMTRK   DS    H\n*\nSRCHC    DS    H\nSRCHH    DS    H\nSRCHR    DS    H\n         EJECT\nJFCB     DS    0D\n         IEFJFCBN\n         EJECT\n* VOLUME CATALOG ENTRY WORK AREA\n         SPACE ,\nCATBLOCK DS    0D\nCATNOENT DS    H\nCATDVTYP DS    CL4\nCATVOL   DS    CL6\nCATTRASH DS    CL2\nCATENTSZ EQU   *-CATDVTYP\nCATNTTR  EQU   CATBLOCK+256        TTR OF BLOCK FOLL READ BLOCK\nCATVOLID EQU   CATNTTR+3           VOL ID OF CATLG\nCATRSIZE EQU   CATVOLID+6-CATBLOCK SIZE READ FROM CATLG\n         SPACE 3\n* FORMAT 1 DSCB WORK AREA\n         DS    0D\n         IECSDSL1 1\nDS1END   EQU   *\nSPACFLAG EQU   X'69'          SPACE ACCOUNTING FLAG BITS\n         SPACE 3\n* FORMAT 3 DSCB WORK AREA\n         ORG   IECSDSL1\n         DS    0D\n         IECSDSL1 3\nDS3END   EQU   *\n         SPACE 3\n* FORMAT 5 DSCB WORK AREA\n         ORG   IECSDSL1\n         IECSDSL1 5\n         SPACE 3\n         ORG   CATBLOCK+CATRSIZE   (MUST BE .GT. DS3END)\n         COPY  SDSNBUF\n         SPACE 3\n         COPY  SCATBUF\n         SPACE 3\nJFCBSAVE DS    0D\n         DS    CL(JFCBLGTH)\n         SPACE 3\nWASA     DS    18F       R13 SAVE AREA DURING SUBTASK\n         ORG   ,\n         MEND\n./ ADD NAME=WDIOWA9  0100-80182-80182-1753-00371-00371-00000-$SYS13  00\n         MACRO\n&NM      WDIOWA &TYPE\n         SPACE ,\n         AIF   ('&TYPE' EQ '').NOSECT\n         AIF   ('&TYPE'(1,1) EQ 'C').CSECT\n         AIF   ('&TYPE'(1,1) EQ 'D').DSECT\n         MNOTE 4,'&TYPE INVALID - IGNORED'\n         AGO   .NOSECT\n.DSECT   ANOP\n&NM      DSECT\n         AGO   .START\n.CSECT   ANOP\n&NM      CSECT\n         AGO   .START\n.NOSECT  ANOP\n&NM      DS    0D\n.START   ANOP\n*                                                               JEP013\n*                                                               JEP013\n* MOD JEP013                                                    JEP013\n*  CHANGED DEFAULT NAME FROM WYL.CU.CTR.VTOC TO FDRABR  ITEL    JEP013\n*  DENOTED JEP013 IN 66/71.  JERRY PITTENGER                    JEP013\n*                                                               JEP013\n         SPACE 2\n         DS    0D\nWADECB   DC    AL1(255),AL3(DECB)\nUCB      DC    A(0)      UCB ADDR FOR SPEC VOLUME\n         SPACE\nDFL      DC    X'00'     FLAGS\n         SPACE ,\nDFREPL   EQU   X'08'     STOW REPL TO BE DONE AT CLOSE\nDFUPTSPC EQU   X'02'     UPDATE SPACE ACCTG AT CLOSE\nDFUSPCNM EQU   X'01'     NO COND SHOW SPACE CALL IF ON\n         SPACE 2\nFLAGS    DS    CL5       SAVE DSNAME FLAGS\nF1       EQU   FLAGS          FIRST DSNAME FLAG\nF2       EQU   FLAGS+1        SECOND DSNAME FLAG\nF3       EQU   FLAGS+2        THIRD DSNAME FLAG\nF4       EQU   FLAGS+4        FOURTH DSNAME FLAG\nF5       EQU   FLAGS+5        FIFTH DSNAME FLAG\n         SPACE ,\nDSDD     DC    CL8'IOVVVVVV'  DDNAME\n         SPACE 2\n* EXLST FOR DCB\nEXLST    DS    0F\n         DC    X'00'               ENTRY TO BE FILLED IN\n         DC    AL3(0)\n         DC    X'87'               LAST ENTRY/JFCB POINTER\n         DC    AL3(JFCB)\n         SPACE 2\n* IOB FOR EXCP\nIOB      DS    0D\n         DC    XL2'C200'\nIOBSNS   DC    H'0'\n         DC    A(DECB)\nIOBCSW   DC    2F'0'\nIOBSTART DC    F'0'\n         DC    A(FOURS)       DCB\n         DC    2F'0'\n         DC    XL1'0'\nIOBB     DC    XL2'0'\nSEEK     DC    XL5'0'\n         SPACE 2\n* CHANNEL PROGRAM FOR EXCP\nMT       EQU   X'80'          MULTI-TRACK\nSCHIDEQ  EQU   X'31'          SEARCH ID EQUAL\nTIC      EQU   X'08'          XFER IN CHANNEL\nSCHKYEQ  EQU   X'29'          SEARCH KEY EQUAL\nSCHKYHI  EQU   X'49'          SEARCH KEY HIGH\nSCHKYHE  EQU   X'69'          SEARCH KEY HI OR EQUAL\nSCHKADEQ EQU   X'2D'          SEARCH KEY AND DATA EQUAL\nSCHKADHI EQU   X'4D'          SEARCH KEY AND DATA HIGH\nSCHKADHE EQU   X'6D'          SEARCH KEY AND DATA HI OR EQUAL\nSWKADKY  EQU   SCHKADHE-SCHKYHE    USED TO SWAP SCH KAD/SCH KEY\nRDCNT    EQU   X'12'          READ COUNT\nRDDATA   EQU   X'06'          READ DATA\nRDKYDATA EQU   X'0E'          READ KEY AND DATA\nNOPIC    EQU   X'03'          NOP IN CHANNEL\nCC       EQU   X'40'          COMMAND CHAIN\nDC       EQU   X'80'          DATA CHAIN\nSLI      EQU   X'20'          SLI\nSKP      EQU   X'10'          SKIP DATA XFER\n         SPACE ,\nSRCHCCW  CCW   SCHIDEQ,SEEK,CC+SLI,5         SEARCH FOR PREV REC\n         CCW   TIC,SRCHCCW,CC+SLI,0\nCCWSW    CCW   TIC,ID,CC+SLI,0               SWITCH BETWEEN ID & PDSRD\nID       CCW   SCHIDEQ+MT,ENDTEST,CC+SLI,5   LAST VTOC REC?\n         CCW   TIC,KEY,CC+SLI,0              TIC IF NO\n         CCW   TIC,ENDCCW1,CC+SLI,0          TIC IF YES\n*              LENGTH FIELD IS CHANGED IN FOLLOWING CCW\nKEY      CCW   SCHKADEQ+MT,DSNAME,CC+SLI,0   IS REC ONE WE WANT?\n         CCW   TIC,ID,CC+SLI,0               TIC IF NO\n         CCW   RDCNT+MT,SRCHC,SLI,5          READ ADDR OF FOLL REC\n* END OF THIS PART OF COMMAND CHAIN\n         SPACE 2\n*              LENGTH FIELD IS CHANGED IN FOLLOWING CCW\nENDCCW1  CCW   SCHKADEQ,DSNAME,CC+SLI,0  IS LAST VTOC REC ONE WE WANT?\n         CCW   TIC,ENDCCW,CC+SLI,0       TIC IF NO\n         CCW   NOPIC,SEEK,CC+SLI+SKP,1   DUMMY CMND\nENDCCW2  CCW   SCHIDEQ,ENDTEST,CC+SLI,5  SO WE CAN SEARCH AGAIN\n         CCW   TIC,ENDCCW2,CC+SLI,0\nREADCCW2 CCW   RDKYDATA,DS1DSNAM,SLI,DS1END-DS1DSNAM  READ DSCB\n* END OF THIS PART OF COMMAND CHAIN\n         SPACE 2\nENDCCW   CCW   NOPIC,SEEK,SLI,1      DUMMY CMD TO FLAG END OF SEARCH\n* IF FINAL CSW POINTS HERE THEN THE VTOC HAS BEEN COMPLETELY SEARCHED\n         SPACE ,\n* CHANNEL PROGRAM RESTARTED HERE IF A RECORD FOUND WE WANT\nREADCCW  CCW   SCHIDEQ,SRCHC,CC+SLI,5     SEARCH FOR THE ONE WE WANTED\n         CCW   TIC,READCCW,CC+SLI,0\n         CCW   RDKYDATA,DS1DSNAM,SLI,DS1END-DS1DSNAM    READ DSCB\n* END OF THIS PART OF COMMAND CHAIN\n         SPACE 2\n* CHANNEL PROGRAM SECTION FOR READING PDS DIRECTORY\nPDSREAD  CCW   RDCNT+MT,SRCHC,CC+SLI,5\n         CCW   RDKYDATA,DBUF,SLI,264\n         SPACE 3\n* MISCELLANEOUS WORK AREAS AND CONSTANTS\nCCREDT   DS    D\nDSNAME   DS    CL44\nDSN      DC    44X'04'\n         SPACE ,\nBLDL     DS    0F\n         DC    H'1'           ONE ENTRY\n         DC    AL2(BLDLSZ)    LENGTH OF ENTRY\nMEMBER   DS    CL8            MEMBER NAME\nBLDLTTR  DS    CL3            MEMBER TTR\nBLDLKZC  DS    CL3            OTHER BLDL TRASH\nBLDLSZ   EQU   *-MEMBER\n         ORG   BLDLKZC+1      STOW REQUIRES C BUT NOT K AND Z\nSTOWLTTR DS    F              DATE OF LAST STOW OR SSI\nSTOWSZ   EQU   *-MEMBER       SIZE OF DIRECTORY ENTRY STOWED\n         SPACE ,\nRRECFM   DS    CL1            RECFM\n         SPACE ,\nSCRVLST  DS    0F             SCRATCH LIST AND OTHERS\n         DC    H'1'           NUMBER OF VOLUMES\nDEVCODE  DS    CL4            RESULT OF DEVTYPE\nDSVID    DS    CL6            VOLUME ID\n         DC    X'0'           BYTE OF ZERO\nSCRRET   DC    X'0'           RETURN CODE FROM SCRATCH\n         SPACE 3\nVTOCCCW  DC    AL3(ID)        TIC ADDR FOR SHOW DSNAMES\nPDSCCW   DC    AL3(PDSREAD)   TIC ADDR FOR SHOW DIRECTORY\nLASTCCW  DC    AL3(ENDCCW+8)  ADDR IN CSW WHEN VTOC SEARCH DONE\nLASTCCW1 DC    AL3(ENDCCW)    ADDR IN CSW WHEN LAST VTOC REC WANTED\nRECSIZE  DS    F\nLRECSIZE DS    F\nERROR    DS    F\nSPACE    DS    F\nDEVBLOCK DS    F              DEVICE BLOCK SIZE\nRETCOD   DS    F\n         EJECT\n* DECBS AND PARAMTER LISTS\n         SPACE ,\n         READ  DECB,SF,DCB,DBUF,MF=L\n         SPACE 3\nDSCB     CAMLST SEARCH,DSNAME,DSVID,DS1FMTID\n         SPACE 3\nSCRLST   CAMLST SCRATCH,DSNAME,,SCRVLST\n         SPACE 3\nUSCATL   CAMLST NAME,DSNAME,,CATBLOCK\n         SPACE 3\nUSCATL2  CAMLST BLOCK,CATNTTR,CATVOLID,CATBLOCK\nCAMVOLID EQU   USCATL2+8      ADDR OF VOLUME ID PTR IN PREV LIST A26\n         SPACE 3\nVTOC     CAMLST SEARCH,DSN,DSVID,VTOCAREA\n         SPACE 3\nVTOC3    CAMLST SEEK,DS1PTRDS,DSVID,IECSDSL3\n         SPACE 3\nCATLST   CAMLST CAT,DSNAME,,SCRVLST     USED FOR CAT/UNCAT/RECAT\n         SPACE 3\nOPENLIST OPEN  (DCB),MF=L\n         SPACE 3\nENQDSN   ENQ   (,DSNAME,,,SYSTEM),RET=USE,MF=L\n         EJECT\n* DUMMY  DCBS\n         SPACE 2\n* DUMMY DCB TO ALLOCATE SPACE FOR DCB TO BE MOVED IN\nDCB      DCB   DSORG=PS,MACRF=(RP,WP)\n         EJECT\nFOURS    DCB   DSORG=PS,MACRF=E,EXLST=EXLST\n         EJECT\n***  THE DATA BUFFER IS ALSO USED AS A WORK AREA AND FOR READING\n**    VARIOUS CONTROL BLOCKS.  IT IS CAREFULLY CONSTRUCTED SO\n**    THAT AREAS WHICH ARE REQUIRED SIMULTANEOUSLY DO NOT OVERLAY\n**    EACH OTHER.  THE OVERLAY STRUCTURE IS AS FOLLOWS:\n*\n**   DBUF      FMT 4 DSCB WORK AREA\n**     |       SHOW DSNAMES WORK AREA\n**     |       JFCB AREA\n**     |       LOCATE VOL WORK AREA\n**     |       REST OF CATLG BLOCK AREA      DSCB1/3/5 WORK AREAS\n**     |                 |                            V\n**     |                 V\n**     |       SHOW DSNAMES BUFFER           SHOW CATLG BUFFER\n**     |                 |                   CLEAR JFCB WORK AREA\n**     |                 V                            |\n**     |                                              V\n**     |                                     SUBTASK R13 REG SV AREA\n**     |                                              V\n**     |\n**     V\n         SPACE 3\n* DAIR INTERFACE:\nWAUPT    DC    A(0)\nWAECT    DC    A(0)\nWAECB    DC    A(WADARECB)\nWAPSCB   DC    A(0)\nWADAIR   DC    A(DA08CD)\nWADARECB DC    F'0'\nDAIRDSN  DC    AL2(44)                                         JJGP013\nDSNPREF  DC    CL9'GHI.PACK.'                                  JJG\nDSNVOL   DC    CL6' '                                          JJG\n         DC    CL29' '                                         JJG\n***********************************************************************\n* THIS OPERATION CODE CAUSES ALLOCATION OF A DATA SET. IT CAN ALLOC.  *\n* EITHER A NEW OR OLD SET.                                            *\n***********************************************************************\n         DS    0F\nDA08CD   DC    AL2(8)   DAIR ENTRY CODE\nDA08FLG  DC    X'00'    FUNCTIONS TO BE PERFORMED WHEN RET CODE IS 0\nDA08FPE  EQU   X'80'    FUNCT PERFORMED BUT ERROR INDICATED BY RETCD\n         DC    X'00'\nDA08DARC DC    H'0'     DYN ALLOC RETURN CODE\nDA08CTRC DC    H'0'     CATALOG RETURN CODE\nDA08PDSN DC    A(DAIRDSN)   PTR TO DSNAME TO BE SEARCHED IN DSE\nDA08DDN  DC    CL8' '   DDNAME TO BE SEARCHED IN DSE\nDA08UNIT DC    CL8' '   UNITNAME REQUESTED\nDA08SER  DC    CL8' '   VOLUME SERIAL NUMBER-PADDED W/BLANKS\nDA08BLK  DC    F'0'     DATA SET  AVERAGE RECORD LENGTH\nDA08PQTY DC    F'0'     PRIMARY SPACE QUANTITY\nDA08SQTY DC    F'0'     SECONDARY SPACE QUANTITY\nDA08DQTY DC    F'0'     DIRECTORY BLOCK QUANTITY\nDA08MNM  DC    CL8' '   MEMBER NAME\nDA08PSWD DC    CL8' '   PASSWORD\nDA08DSP1 DC    X'08'    DATA SET STATUS FLGS(IF=0 OLD ASSUMED)\nDA08SHR  EQU   X'08'    DATA SET IS SHR\nDA08NEW  EQU   X'04'    DATA SET IS NEW\nDA08MOD  EQU   X'02'    DATA SET IS MOD\nDA08OLD  EQU   X'01'    DATA SET IS OLD\nDA08DPS2 DC    X'08'    DATA SET DISPOSITION(IF=0 KEEP ASSUMED)\nDA08KEEP EQU   X'08'    DS DISP IS KEEP\nDA08DEL  EQU   X'04'    DS DISP IS DELETE\nDA08CAT  EQU   X'02'    DS DISP IS CATLG\nDA08UCAT EQU   X'01'    DS DISP IS UNCATALOG\nDA08DPS3 DC    X'08'    DATA SET CONDITIONAL DISPOSITION\nDA08KEP  EQU   X'08'\nDA08DELE EQU   X'04'\nDA08CATL EQU   X'02'    DS DISP OF CATLG DESIRED\nDA08UNCT EQU   X'01'    DS DISP OF UNCATLG DESIRED\nDA08CTL  DC    X'08'    FLAGS TO CONTROL ACTIONS TAKEN BY DAIR\nDA08TRKS EQU   X'80'    UNITS ARE TRKS\nDA08ABKL EQU   X'40'\nDA08CYLS EQU   X'C0'    UNITS ARE CYLS\nDA08UID  EQU   X'20'    USER ID IS TO BE PREFIXED\nDA08RLSE EQU   X'10'    RELEASE (RLSE) REQUESTED\nDA08PERM EQU   X'08'    DATA SET MUST BE SPECIFICALLY UNALLOCATED\nDA08DMMY EQU   X'04'\nDA08ATRL EQU   X'02'    ATTRIBUTE LIST SUPPLIED\n         DC    XL3'00'  RESERVED\nDA08DSO  DC    XL1'00'  DSORG\nDA08ALN  DC    CL8' '   ATTR-LIST-NAME\n***********************************************************************\n* THIS OPERATION CAUSES THE REQUESTED DATA SET OR DDNAME TO BE        *\n* UNALLOCATED. DISPOSITION CAN BE SPECIFIED TO OVERRIDE ANY PREVIOUS  *\n* DISPOSITION. LIKENISE SYSOUT CLASS MAY BE SPECIFIED TO OVERRIDE ANY *\n* PREVIOUS CLASS.                                                     *\n***********************************************************************\n         DS    0F\nDA18CD   DC    AL2(24)  DAIR ENTRY CODE\nDA18FLG  DC    X'00'    FUNCTIONS TO BE PERFORMED WHEN RET CODE IS 0\nDA18FPE  EQU   X'80'    FUNCT PERFORMED BUT ERROR INDICATED BY RETCD\n         DC    X'00'\nDA18DARC DC    H'0'                    DYNAMIC ALLOCATION RETURN CODE\nDA18CTRC DC    H'0'               CATALOG RETURN CODE AREA\nDA18PDSN DC    A(0)         PTR TO DSNAME TO BE SEARCHED IN DSE\nDA18DDN  DC    CL8' '   DDNAME TO BE SEARCHED IN DSE\nDA18MNM  DC    CL8' '   MEMBER NAME\nDA18SCLS DC    CL2' '   SYSOUT CLASS DESIRED WHEN UNALLOCATING  A\n*                       SYSOUT DATA SET\nDA18DPS2 DC    X'08'    DATA SET DISPOSITION\nDA18KEEP EQU   X'08'    CHANGE DISP TO KEEP\nDA18DEL  EQU   X'04'    CHANGE DISP TO DELETE\nDA18CAT  EQU   X'02'    CHANGE DISP TO CATALOG\nDA18UCAT EQU   X'01'    CHANGE DISP TO UNCATLOG\nDA18CTL  DC    X'10'    FLAGS FOR SPECIAL DAIR PROCESSING\nDA18UID  EQU   X'20'    USER ID IS TO BE PREFIXED TO DSNAME\nDA18PERM EQU   X'10'    UNALLOCATE PERM. ALLOCATED DSE'S\nDA18JBNM DC    CL8' '\n         SPACE ,\nATTDECB  DC   A(0)                 ECB FOR ATTACH\nWATTACH  ATTACH EP=IKJEFT01,ECB=ATTDECB,SF=L\n         DS    0F\nWASTAX   DC    5A(0)               STAX PARAMETER LIST\nDBUF     DS    0D\nDBUFSIZE EQU   19069\nACCTWA   EQU   DBUF       ACCOUNTING WORK AREA\n         DS    (DBUFSIZE)C\n         SPACE 3\n* WORK AREA FOR DVTOC\n         SPACE ,\n* FIRST PART IS FORMAT 4 DSCB AREA\n         ORG   DBUF\nVTOCAREA DS    0D\n         IECSDSL1 4\n         ORG   DS4VTOCE       FMT 4 EXTENT DESCRIPTION\n         DS    CL2\nVTOCBEG  DS    CL4\nVTOCEND  DS    CL4\n         DS    279C\n         SPACE 3\nPAGEGET  DS    F\nVTOCSV   DS    11F\nWAR14    EQU   VTOCSV    REG SAVE AREA FOR SUBTASK COMMUNICATION\nWAR15    EQU   WAR14+4\n*\nENDTEST  DS    XL5\n*\n*\nDVTAREA  DVTAREA ,                 DEFINE DEVCODE AREA\n*\n*\nNUMTRK   DS    H\n*\nSRCHC    DS    H\nSRCHH    DS    H\nSRCHR    DS    H\n         EJECT\nJFCB     DS    0D\n         IEFJFCBN\n         EJECT\n* VOLUME CATALOG ENTRY WORK AREA\n         SPACE ,\nCATBLOCK DS    0D\nCATNOENT DS    H\nCATDVTYP DS    CL4\nCATVOL   DS    CL6\nCATTRASH DS    CL2\nCATENTSZ EQU   *-CATDVTYP\nCATNTTR  EQU   CATBLOCK+256        TTR OF BLOCK FOLL READ BLOCK\nCATVOLID EQU   CATNTTR+3           VOL ID OF CATLG\nCATRSIZE EQU   CATVOLID+6-CATBLOCK SIZE READ FROM CATLG\n         SPACE 3\n* FORMAT 1 DSCB WORK AREA\n         DS    0D\n         IECSDSL1 1\nDS1END   EQU   *\nSPACFLAG EQU   X'69'          SPACE ACCOUNTING FLAG BITS\n         SPACE 3\n* FORMAT 3 DSCB WORK AREA\n         ORG   IECSDSL1\n         DS    0D\n         IECSDSL1 3\nDS3END   EQU   *\n         SPACE 3\n* FORMAT 5 DSCB WORK AREA\n         ORG   IECSDSL1\n         IECSDSL1 5\n         SPACE 3\n         ORG   CATBLOCK+CATRSIZE   (MUST BE .GT. DS3END)\n         COPY  SDSNBUF\n         SPACE 3\n         COPY  SCATBUF\n         SPACE 3\nJFCBSAVE DS    0D\n         DS    CL(JFCBLGTH)\n         SPACE 3\nWASA     DS    18F       R13 SAVE AREA DURING SUBTASK\n         ORG   ,\n         MEND\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "MENUSF": {"ttr": 50948, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00T\\x01\\x19#\\x0f\\x01\\x19#\\x0f\\x14V\\r\\x0c\\r\\x0c\\x00\\x00\\xc6\\xc2`\\xf8\\xf0@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2019-08-18T00:00:00", "modifydate": "2019-08-18T14:56:54", "lines": 3340, "newlines": 3340, "modlines": 0, "user": "FB-80"}, "text": "./ ADD NAME=APRIOPT  0101-80119-80137-1417-00074-00076-00000-$SYS13  00\n&-----------------------  SPF/TSO PRIMARY OPTION MENU  -------------------------\n&SELECT OPTION ===>%OPT     $\n &                                                          $USERID   -@ID\n&   0 $SPF PARMS  - SPECIFY TERMINAL AND SPF PARAMETERS     $TIME     -@TIME\n$                   1) TERMINAL  2) LOG/LIST  3) PF KEYS    $TERMINAL -@TERM\n&   1 $BROWSE     - DISPLAY SOURCE DATA OR OUTPUT LISTINGS  $PFKEYS   -@KY\n&   2 $EDIT       - CREATE OR CHANGE SOURCE DATA\n&   3 $UTILITY    - PERFORM SPF UTILITY FUNCTIONS\n$                   1) LIBRARY    3) MOVE/COPY   5) RESET      7) VTOC\n$                   2) DATA SET   4) CATALOG     6) HARDCOPY   8) OUTLIST\n&   4 $FOREGROUND - COMPILE, ASSEMBLE, OR LINK EDIT, OR DEBUG\n&   5 $BACKGROUND - COMPILE, ASSEMBLE, OR LINK EDIT\n&   6 $TSO        - ENTER TSO COMMAND OR CLIST\n&   7 $TUTORIAL   - DISPLAY INFORMATION ABOUT SPF\n&   J $JTIP       - PERFORM JTIP UTILITY FUNCTIONS\n&   P $PANVALET   - SPF/TSO/PANVALET INTERFACE\n$                               2) CHANGE    4) DISPLAY  6) PRINT    8) RETRIEVE\n$                   1) ADD      3) COPY      5) LISTDS   7) RENAME   9) STORE\n&   X $EXIT       - TERMINATE SPF USING LIST/LOG DEFAULTS\n&\n$PRESS&END KEY$TO TERMINATE SPF$\n&\n<ACTION>\n1 OPT CHAR(8) CURSOR GENHELP(TTUTOR)\n LIST   (0     ,0.1   ,0.2   ,0.3   ,1     ,2      ,\n  3      ,3.1   ,3.2   ,3.3   ,3.4   ,3.5   ,3.6   ,3.7   ,3.8   ,3.9   ,\n  4      ,4.1   ,4.2   ,4.3   ,4.4   ,4.5   ,4.6   ,4.7   ,4.8   ,\n  5     ,5.1   ,5.2   ,5.3   ,5.4   ,5.5   ,5.6   ,\n  6     ,7       ,\n  P     ,P.0   ,P.1   ,P.2   ,P.3   ,P.4   ,P.5   ,P.6    ,P.7   ,\n  P.8   ,P.9   ,\n  A     ,A.1   ,A.2   ,A.3   ,\n  J     ,\n  X  ,TESTMENU,' ',*)\n RETURN (SPFOPT,SPFOPT,SPFOPT,SPFOPT,SPFBRO,SPFEDIT,\n  SPFUTIL,SPFUDA,SPFUDA,SPFUMC,SPFUCA,SPFURS,SPFUHC,SPFUVT,SPFUOL,SPFUSC,\n  SPFUTIL,SPFFOR,SPFFOR,SPFFOR,SPFFOR,SPFFOR,SPFFOR,SPFFOR,SPFFOR,\n  SPFJOB,SPFJOB,SPFJOB,SPFJOB,SPFJOB,SPFJOB,SPFJOB,\n  SPFTSO,SPFTUTOR,\n  SPFUTIL,TKSPED0D,SPFFOR,SPFFOR,SPFFOR,SPFIPAN2,SPFFOR,SPFFOR,SPFFOR\n  SPFFOR,SPFFOR,\n  SPFUTIL,SPFFOR,SPFFOR,SPFFOR,\n  SPFIJTIP,\n  END,SPFTMENU,' ',?);\n2 OPT CHAR(8) INIT($PARM2)\n LIST   (0    ,0.1  ,0.2  ,0.3  ,3   ,3.1 ,3.2 ,3.8  ,3.9   ,\n  4   ,4.1  ,4.2  ,4.3  ,4.4  ,4.5  ,4.6  ,4.7  ,4.8  ,\n  5    ,5.0  ,5.1  ,5.2  ,5.3  ,5.4  ,5.5  ,5.6  ,7,\n  P    ,P.0  ,P.1  ,P.2  ,P.3  ,P.4  ,P.5  ,P.6  ,P.7,\n  P.8  ,P.9  ,\n  A    ,A.1  ,A.2  ,A.3  ,\n  J)\n RETURN (OPT00,OPT01,OPT02,OPT03,UTIL,UDA1,UDA2,UOL01,SCRPTA,\n  FORA,FOR01,FOR02,FOR03,FOR04,FOR05,FOR06,FOR07,FOR08,\n  *JOBA,JOB00,JOB01,JOB02,JOB03,JOB04,JOB05,JOB06,T,\n  VPAN,VPANE,VPAN01,VPAN02,VPAN03,VPAN04,VPAN05,VPAN06,VPAN07,\n  VPAN08,VPAN09,\n  VASM2,V$AR,V$BK,V$SM,\n  VJTIP);\n3 ID CHAR(8) INIT($PARM3);\n4 TIME CHAR(5) INIT($PARM4);\n5 DATE CHAR(8) INIT($PARM5);\n6 DATEJ CHAR(6) INIT($PARM6);\n7 KY CHAR(2) INIT($PARM7);\n8 TERM CHAR(8) INIT($PARM8);\n9 MODE CHAR(1) INIT($PARM9)\n LIST   (MONO,DUAL)\n RETURN (M   ,D   );\n10 PFX CHAR(8) INIT($PARM10);\n11 STEP CHAR(8) INIT($PARM11);\n12 * FIXED(8) INIT(0);  ** RESERVED **\n13 * CHAR(8) INIT(' '); ** RESERVED **\n14 * FIXED(31) INIT(0); ** RESERVED **\n<END>\n./ ADD NAME=APRIOPT0 0100-80137-80137-1416-00076-00076-00000-$SYS13  00\n&-----------------------  SPF/TSO PRIMARY OPTION MENU  -------------------------\n&SELECT OPTION ===>%OPT     $\n &                                                          $USERID   -@ID\n&   0 $SPF PARMS  - SPECIFY TERMINAL AND SPF PARAMETERS     $TIME     -@TIME\n$                   1) TERMINAL  2) LOG/LIST  3) PF KEYS    $TERMINAL -@TERM\n&   1 $BROWSE     - DISPLAY SOURCE DATA OR OUTPUT LISTINGS  $PFKEYS   -@KY\n&   2 $EDIT       - CREATE OR CHANGE SOURCE DATA\n&   3 $UTILITY    - PERFORM SPF UTILITY FUNCTIONS\n$                   1) LIBRARY    3) MOVE/COPY   5) RESET      7) VTOC\n$                   2) DATA SET   4) CATALOG     6) HARDCOPY   8) OUTLIST\n&   4 $FOREGROUND - COMPILE, ASSEMBLE, OR LINK EDIT, OR DEBUG\n&   5 $BACKGROUND - COMPILE, ASSEMBLE, OR LINK EDIT\n&   6 $TSO        - ENTER TSO COMMAND OR CLIST\n&   7 $TUTORIAL   - DISPLAY INFORMATION ABOUT SPF\n&   A $ASM2       - ASM2 DISK STORAGE MANAGEMENT SYSTEM\n$                   1) ARCHIVE  2) BACKUP    3) SPACE MANAGEMENT\n&   J $JTIP       - PERFORM JTIP UTILITY FUNCTIONS\n&   P $PANVALET   - SPF/TSO/PANVALET INTERFACE\n$                               2) CHANGE    4) DISPLAY  6) PRINT    8) RETRIEVE\n$                   1) ADD      3) COPY      5) LISTDS   7) RENAME   9) STORE\n&   X $EXIT       - TERMINATE SPF USING LIST/LOG DEFAULTS\n&\n$PRESS&END KEY$TO TERMINATE SPF$\n&\n<ACTION>\n1 OPT CHAR(8) CURSOR GENHELP(TTUTOR)\n LIST   (0     ,0.1   ,0.2   ,0.3   ,1     ,2      ,\n  3      ,3.1   ,3.2   ,3.3   ,3.4   ,3.5   ,3.6   ,3.7   ,3.8   ,3.9   ,\n  4      ,4.1   ,4.2   ,4.3   ,4.4   ,4.5   ,4.6   ,4.7   ,4.8   ,\n  5     ,5.1   ,5.2   ,5.3   ,5.4   ,5.5   ,5.6   ,\n  6     ,7       ,\n  P     ,P.0   ,P.1   ,P.2   ,P.3   ,P.4   ,P.5   ,P.6    ,P.7   ,\n  P.8   ,P.9   ,\n  A     ,A.1   ,A.2   ,A.3   ,\n  J     ,\n  X  ,TESTMENU,' ',*)\n RETURN (SPFOPT,SPFOPT,SPFOPT,SPFOPT,SPFBRO,SPFEDIT,\n  SPFUTIL,SPFUDA,SPFUDA,SPFUMC,SPFUCA,SPFURS,SPFUHC,SPFUVT,SPFUOL,SPFUSC,\n  SPFUTIL,SPFFOR,SPFFOR,SPFFOR,SPFFOR,SPFFOR,SPFFOR,SPFFOR,SPFFOR,\n  SPFJOB,SPFJOB,SPFJOB,SPFJOB,SPFJOB,SPFJOB,SPFJOB,\n  SPFTSO,SPFTUTOR,\n  SPFUTIL,TKSPED0D,SPFFOR,SPFFOR,SPFFOR,SPFIPAN2,SPFFOR,SPFFOR,SPFFOR\n  SPFFOR,SPFFOR,\n  SPFUTIL,SPFFOR,SPFFOR,SPFFOR,\n  SPFIJTIP,\n  END,SPFTMENU,' ',?);\n2 OPT CHAR(8) INIT($PARM2)\n LIST   (0    ,0.1  ,0.2  ,0.3  ,3   ,3.1 ,3.2 ,3.8  ,3.9   ,\n  4   ,4.1  ,4.2  ,4.3  ,4.4  ,4.5  ,4.6  ,4.7  ,4.8  ,\n  5    ,5.0  ,5.1  ,5.2  ,5.3  ,5.4  ,5.5  ,5.6  ,7,\n  P    ,P.0  ,P.1  ,P.2  ,P.3  ,P.4  ,P.5  ,P.6  ,P.7,\n  P.8  ,P.9  ,\n  A    ,A.1  ,A.2  ,A.3  ,\n  J)\n RETURN (OPT00,OPT01,OPT02,OPT03,UTIL,UDA1,UDA2,UOL01,SCRPTA,\n  FORA,FOR01,FOR02,FOR03,FOR04,FOR05,FOR06,FOR07,FOR08,\n  *JOBA,JOB00,JOB01,JOB02,JOB03,JOB04,JOB05,JOB06,T,\n  VPAN,VPANE,VPAN01,VPAN02,VPAN03,VPAN04,VPAN05,VPAN06,VPAN07,\n  VPAN08,VPAN09,\n  VASM2,V$AR,V$BK,V$SM,\n  VJTIP);\n3 ID CHAR(8) INIT($PARM3);\n4 TIME CHAR(5) INIT($PARM4);\n5 DATE CHAR(8) INIT($PARM5);\n6 DATEJ CHAR(6) INIT($PARM6);\n7 KY CHAR(2) INIT($PARM7);\n8 TERM CHAR(8) INIT($PARM8);\n9 MODE CHAR(1) INIT($PARM9)\n LIST   (MONO,DUAL)\n RETURN (M   ,D   );\n10 PFX CHAR(8) INIT($PARM10);\n11 STEP CHAR(8) INIT($PARM11);\n12 * FIXED(8) INIT(0);  ** RESERVED **\n13 * CHAR(8) INIT(' '); ** RESERVED **\n14 * FIXED(31) INIT(0); ** RESERVED **\n<END>\n./ ADD NAME=UDA1     0100-80038-80038-2341-00038-00038-00000-$SYS13  00\n&----------------------------  LIBRARY UTILITY  --------------------------------\n&SELECT OPTION ===>%CODE                                                       $\n&\n&   C$- COMPRESS DATASET                   &P$- PRINT MEMBER\n&   X$- PRINT INDEX LISTING                &R$- RENAME MEMBER\n&   L$- PRINT ENTIRE DATASET               &D$- DELETE MEMBER\n&   BLANK$- DISPLAY MEMBER LIST            &B$- BROWSE MEMBER\n$\n$SPF LIBRARY DATASET:\n$   PROJECT&===>%PROJECT $\n$   LIBRARY&===>%LIBRARY $\n$   TYPE   &===>%TYPE    $\n$   MEMBER &===>%MEMBER  $ (IF OPTION \"P\", \"R\", \"D\", OR \"B\" SELECTED)\n$   NEWNAME&===>%NEWNAME $ (IF OPTION \"R\" SELECTED)\n$\n$OTHER PARTITIONED OR SEQUENTIAL DATASET:\n$   DATASET NAME &===>%DSN                                                     $\n$   VOLUME SERIAL&===>%VOL   $  (IF NOT CATALOGED)\n$\n$DATASET PASSWORD&===>\u00acPSWD    $(IF PASSWORD PROTECTED)\n<ACTION>\n 1 CODE    CHAR(1)  INIT($PARM1) CURSOR   GENHELP(TUL)\n           LIST  (C,L,X,P,R,D,B,' ',*)\n           RETURN(Z,L,X,P,R,D,B,M  ,?);\n 2 PROJECT CHAR(8)  INIT($PARM2) NOCURSOR;\n 3 LIBRARY CHAR(8)  INIT($PARM3) NOCURSOR;\n 4 TYPE    CHAR(8)  INIT($PARM4) NOCURSOR;\n 5 DSN     CHAR(56) INIT($PARM5) NOCURSOR;\n 6 VOL     CHAR(6)  INIT($PARM6) NOCURSOR;\n 7 PSWD    CHAR(8)  INIT($PARM7) NOCURSOR;\n 8 MEMBER  CHAR(8)  INIT($PARM8) NOCURSOR;\n 9 NEWNAME CHAR(8)  INIT($PARM9) NOCURSOR;\n10 *       CHAR(8)  INIT('SPFCOPY '); - COMPRESS PGM NAME IF NOT IEBCOPY\n11 *       CHAR(8)  INIT('PPRINTED'); - PRINT MEMBER OPT/RESPONSE\n12 *       CHAR(8)  INIT('RRENAMED'); - RENAME MEMBER OPT/RESPONSE\n13 *       CHAR(8)  INIT('DDELETED'); - DELETE MEMBER OPT/RESPONSE\n14 *       CHAR(8)  INIT('B       '); - BROWSE MEMBER OPT/RESPONSE\n<END>\n./ ADD NAME=V$AR     0120-80014-80039-0852-00062-00061-00000-TYD9801 00\n&------------------------ ASM2 ARCHIVE UTILITY ---------------------------------\n&SELECT OPTION ===>%OPT                                                        $\n&\n&   A$- QUEUE A DATASET TO BE ARCHIVED\n&   R$- QUEUE A DATASET TO BE RELOADED FROM AN ARCHIVE TAPE\n&   BLANK$- INQUIRE ABOUT ARCHIVED DATASET(S)\n$\n$COMPLETE DSN (OR PARTIAL DSN, WITHOUT QUOTES, FOR INQUIRY.)\n$  NAME &===>%DSN                                                $\n$\n$FOR ARCHIVE REQUEST (OPTION A)\n$   RETENTION  &===>%RET$  PERMANENT ARCHIVE &===>%P$ (Y OR N)\n$   QUALIFIER  &===>%QUAL    $\n$   COMMENT    &===>%CMT                           $\n$\n$FOR INQUIRY REQUEST (OPTION 'BLANK')\n$   CYCLE      &===>%CYC$  (ONLY DATASETS ARCHIVED WITHIN LAST NNN DAYS)\n$   COMMENT    &===>%C$    (ENTER 'Y' TO DISPLAY COMMENTS)\n$\n$\n$\n$\n$\n$\n<ACTION>\n 1 OPT     CHAR (1)  INIT(' ')     LIST   (A,R,' ',*) GENHELP(VT$AR)\n                       CURSOR      RETURN (A,R,' ',?);\n 2 OPT     CHAR (1)  INIT(' ')     LIST   ('A' ,  * )  KEY(SW1)\n                     NOCURSOR      RETURN (' ' , '\u00ac');\n 3 OPT     CHAR (1)  INIT(' ')     LIST   (' ' ,  * )  KEY(SW2)\n                     NOCURSOR      RETURN (' ' , '\u00ac');\n 4 OPT     CHAR (1)  INIT(' ')     LIST   ('R' ,  * )  KEY(SW3)\n                     NOCURSOR      RETURN (' ' , '\u00ac');\n 5 DSN     CHAR (51) INIT(' ')     LIST   (' ' ,  * )\n                     NOCURSOR      RETURN (' '      ); OPTIONAL\n 6 DSN     CHAR (1)  INIT(' ')     LIST   (' ' ,  * )  KEY(SW8)\n                     NOCURSOR      RETURN ('\u00ac' , ' ');\n 7 RET     CHAR (3)  INIT(' ')     LIST   (' ' ,  * )\n                     NOCURSOR      RETURN (' '      ); OPTIONAL\n 8 RET     CHAR (1)  INIT(' ')     LIST   (' ' ,  * )  KEY(SW4)\n                     NOCURSOR      RETURN ('\u00ac' , ' ');\n 9 P       CHAR (1)  INIT('N')     LIST   ('Y' , 'N',  * )\n                     NOCURSOR      RETURN ('Y' , 'N',  ? );\n10 P       CHAR (1)  INIT('N')     LIST   ('Y' ,  * )  KEY(SW6)\n                     NOCURSOR      RETURN (' ' , '\u00ac');\n11 QUAL    CHAR (8)  INIT(' ')     LIST   (' ' ,  * )\n                     NOCURSOR      RETURN (' '      ); OPTIONAL\n12 QUAL    CHAR (1)  INIT(' ')     LIST   (' ' ,  * )  KEY(SW5)\n                     NOCURSOR      RETURN ('\u00ac' , ' ');\n13 CMT     CHAR (30) INIT(' ')     LIST   (' ' ,  * )\n                     NOCURSOR      RETURN (' '      ); OPTIONAL\n14 CMT     CHAR (1)  INIT(' ')     LIST   (' ' ,  * )  KEY(SW7)\n                     NOCURSOR      RETURN ('\u00ac' , ' ');\n15 C       CHAR (1)  INIT('N')     LIST   ('Y' , 'N',  * )\n                     NOCURSOR      RETURN ('Y' , 'N',  ? );\n16 C       CHAR (1)  INIT('N')     LIST   ('Y' ,  * )  KEY(SWB)\n                     NOCURSOR      RETURN (' ' , '\u00ac');\n17 CYC     CHAR (3)  INIT(' ')     LIST   (' ' ,  * )\n                     NOCURSOR      RETURN (' '      ); OPTIONAL\n18 CYC     CHAR (1)  INIT(' ')     LIST   (' ' ,  * )  KEY(SW9)\n                     NOCURSOR      RETURN ('\u00ac' , ' ');\n<END>\n./ ADD NAME=V$BK     0119-80014-80021-0729-00058-00061-00000-TYD9801 00\n&------------------------ ASM2 BACKUP UTILITY ----------------------------------\n&SELECT OPTION ===>%OPT                                                        $\n&\n&   B$- QUEUE A DATASET TO BE BACKED UP\n&   R$- QUEUE A DATASET TO BE RELOADED FROM AN BACKUP TAPE\n&   BLANK$- INQUIRE ABOUT BACKED UP DATASET(S)\n$\n$COMPLETE DSN (OR PARTIAL DSN, WITHOUT QUOTES, FOR INQUIRY)\n$  NAME &===>%DSN                                                $\n$\n$FOR ARCHIVE REQUEST (OPTION B)\n$   RETENTION  &===>%RET$\n$   QUALIFIER  &===>%QUAL    $\n$   COMMENT    &===>%CMT                           $\n$\n$FOR INQUIRY REQUEST (OPTION 'BLANK')\n$   CYCLE      &===>%CYC$ (ONLY DATASETS BACKED UP WITHIN LAST NNN DAYS)\n$   COMMENT    &===>%C$   (ENTER 'Y' TO DISPLAY COMMENTS)\n$\n$\n$\n$\n$\n$\n<ACTION>\n 1 OPT     CHAR (1)  INIT(' ')     LIST   (B,R,' ',*) GENHELP(VT$BK)\n                       CURSOR      RETURN (B,R,' ',?);\n 2 OPT     CHAR (1)  INIT(' ')     LIST   ('B' ,  * )  KEY(SW1)\n                     NOCURSOR      RETURN (' ' , '\u00ac');\n 3 OPT     CHAR (1)  INIT(' ')     LIST   (' ' ,  * )  KEY(SW2)\n                     NOCURSOR      RETURN (' ' , '\u00ac');\n 4 OPT     CHAR (1)  INIT(' ')     LIST   ('R' ,  * )  KEY(SW3)\n                     NOCURSOR      RETURN (' ' , '\u00ac');\n 5 DSN     CHAR (51) INIT(' ')     LIST   (' ' ,  * )\n                     NOCURSOR      RETURN (' '      ); OPTIONAL\n 6 DSN     CHAR (1)  INIT(' ')     LIST   (' ' ,  * )  KEY(SW8)\n                     NOCURSOR      RETURN ('\u00ac' , ' ');\n 7 RET     CHAR (3)  INIT(' ')     LIST   (' ' ,  * )\n                     NOCURSOR      RETURN (' '      ); OPTIONAL\n 8 RET     CHAR (1)  INIT(' ')     LIST   (' ' ,  * )  KEY(SW4)\n                     NOCURSOR      RETURN ('\u00ac' , ' ');\n10 QUAL    CHAR (8)  INIT(' ')     LIST   (' ' ,  * )\n                     NOCURSOR      RETURN (' '      ); OPTIONAL\n11 QUAL    CHAR (1)  INIT(' ')     LIST   (' ' ,  * )  KEY(SW5)\n                     NOCURSOR      RETURN ('\u00ac' , ' ');\n12 CMT     CHAR (30) INIT(' ')     LIST   (' ' ,  * )\n                     NOCURSOR      RETURN (' '      ); OPTIONAL\n13 CMT     CHAR (1)  INIT(' ')     LIST   (' ' ,  * )  KEY(SW7)\n                     NOCURSOR      RETURN ('\u00ac' , ' ');\n14 C       CHAR (1)  INIT('N')     LIST   ('Y' , 'N',*)\n                     NOCURSOR      RETURN ('Y' , 'N',?);\n15 C       CHAR (1)  INIT('N')     LIST   ('Y' , 'N')  KEY(SWB)\n                     NOCURSOR      RETURN (' ' , '\u00ac');\n16 CYC     CHAR (3)  INIT(' ')     LIST   (' ' ,  * )\n                     NOCURSOR      RETURN (' '      ); OPTIONAL\n17 CYC     CHAR (1)  INIT(' ')     LIST   (' ' ,  * )  KEY(SW9)\n                     NOCURSOR      RETURN ('\u00ac' , ' ');\n<END>\n./ ADD NAME=V$SM     0110-80014-80018-1638-00048-00060-00000-TYD9801 00\n&---------------- ASM2 DISK SPACE MANAGEMENT UTILITY ---------------------------\n&SELECT OPTION ===>%OPT                                                        $\n&\n&   BLANK$- DISPLAY DISK DATASET SPACE INFORMATION\n&   U$- DISPLAY DISK DATASET USAGE INFORMATION\n&   C$- COMPRESS DATASET WITHOUT RELEASING UNUSED SPACE\n&   R$- RELEASE UNUSED SPACE IN DATASETS (COMPRESS OPTIONAL)\n&   E$- RESET END-OF-FILE TO BEGINNING OF SEQUENTIAL DATASET\n$\n$TYPE OF NAME  &===>%T$     (L=INDEX LEVELS, BLANK=FULL DSN))\n$   NAME       &===>%DSN                                         $\n$\n$OPTIONS FOR RELEASE/COMPRESS OPTION (OPTION 'R','C')\n$   COMPRESS   &===>%C$     (FOR PDS ONLY, 'Y' OR 'N')\n$   BACKUP     &===>%B$     (FOR COMPRESS ONLY, 'Y' OR 'N')\n$   SAVE       &===>%S    $ (SAVE NNNNN UNUSED TRACKS)\n<ACTION>\n 1 OPT     CHAR (1)  INIT(' ')     LIST   (U,R,E,C,' ',*) GENHELP(VT$SM)\n                       CURSOR      RETURN (U,R,E,C,' ',?);\n 2 OPT     CHAR (1)  INIT(' ')     LIST   ('U' ,  * )  KEY(SW1)\n                     NOCURSOR      RETURN ('\u00ac' , ' ');\n 3 OPT     CHAR (1)  INIT(' ')     LIST   ('U' ,  * )  KEY(SW2)\n                     NOCURSOR      RETURN (' ' , '\u00ac');\n 4 OPT     CHAR (1)  INIT(' ')     LIST   ('R' ,  * )  KEY(SW7)\n                     NOCURSOR      RETURN (' ' , '\u00ac');\n 5 OPT     CHAR (1)  INIT(' ')     LIST   ('E' ,  * )  KEY(SW8)\n                     NOCURSOR      RETURN (' ' , '\u00ac');\n 6 OPT     CHAR (1)  INIT(' ')     LIST   ('C' ,  * )  KEY(SW9)\n                     NOCURSOR      RETURN (' ' , '\u00ac');\n 7 DSN     CHAR (44) INIT(' ')     LIST   (' ' ,  * )\n                     NOCURSOR      RETURN (' '      ); OPTIONAL\n 8 DSN     CHAR (1)  INIT(' ')     LIST   (' ' ,  * )  KEY(SW3)\n                     NOCURSOR      RETURN ('\u00ac' , ' ');\n 9 T       CHAR (1)  INIT(' ')     LIST   (' ' , 'L' ,  * )\n                     NOCURSOR      RETURN (' ' , 'L' ,  ? ); OPTIONAL\n10 T       CHAR (1)  INIT(' ')     LIST   (' ' ,  * )  KEY(SW4)\n                     NOCURSOR      RETURN ('\u00ac' , ' ');\n11 T       CHAR (1)  INIT(' ')     LIST   ('L' ,  * )  KEY(SW5)\n                     NOCURSOR      RETURN ('\u00ac' , ' ');\n12 C       CHAR (2)  INIT('Y')     LIST   ('N' ,  'Y' ,  * )\n                     NOCURSOR      RETURN ('NO' , ' ' ,  ? ); REQUIRED\n13 B       CHAR (2)  INIT('Y')     LIST   ('N' ,  'Y' ,  * )\n                     NOCURSOR      RETURN ('NO' , ' ' ,  ? ); REQUIRED\n14 S       CHAR (5)  INIT(' ')     LIST   (' ' ,  * )\n                     NOCURSOR      RETURN (' '      ); OPTIONAL\n15 S       CHAR (1)  INIT(' ')     LIST   (' ' ,  * )  KEY(SW6)\n                     NOCURSOR      RETURN ('\u00ac' , ' ');\n<END>\n./ ADD NAME=VAPRIOPT 0108-79288-80108-1411-00157-00144-00000-$CSG05  00\n&-----------------------  SPF/TSO PRIMARY OPTION MENU  -------------------------\n&SELECT OPTION ===>%OPT     $\n&                                                           $USERID   -@ID\n&   0 $SPF PARMS  - SPECIFY TERMINAL AND SPF PARAMETERS     $TIME     -@TIME\n$                   1) TERMINAL  2) LOG/LIST  3) PF KEYS    $TERMINAL -@TERM\n&   1 $BROWSE     - DISPLAY SOURCE DATA OR OUTPUT LISTINGS  $PFKEYS   -@KY\n&   2 $EDIT       - CREATE OR CHANGE SOURCE DATA\n&   3 $UTILITY    - PERFORM SPF UTILITY FUNCTIONS\n$                   1) LIBRARY    3) MOVE/COPY   5) RESET      7) VTOC\n$                   2) DATA SET   4) CATALOG     6) HARDCOPY   8) OUTLIST\n&   4 $FOREGROUND - COMPILE, ASSEMBLE, OR LINK EDIT, OR DEBUG\n&   5 $BACKGROUND - COMPILE, ASSEMBLE, OR LINK EDIT\n&   6 $TSO        - ENTER TSO COMMAND OR CLIST\n&   7 $TUTORIAL   - DISPLAY INFORMATION ABOUT SPF\n&   A $ASM2       - ASM2 DISK STORAGE MANAGEMENT SYSTEM\n$                   1) ARCHIVE  2) BACKUP    3) SPACE MANAGEMENT\n&   P $PANVALET   - SPF/TSO/PANVALET INTERFACE\n$                               2) CHANGE    4) DISPLAY  6) PRINT    8) RETRIEVE\n$                   1) ADD      3) COPY      5) LISTDS   7) RENAME   9) STORE\n&   J $JTIP       - PERFORM JTIP UTILITY FUNCTIONS\n&   X $EXIT       - TERMINATE SPF USING LIST/LOG DEFAULTS\n&\n&\n$PRESS&PF3$(END KEY) TO TERMINATE SPF$\n&\n<ACTION>\n1 OPT CHAR(8) CURSOR GENHELP(TTUTOR)\n LIST    (0       ,0.1     ,0.2     ,0.3     ,\n  1       ,\n  2       ,\n  3       ,3.1     ,3.2     ,3.3     ,3.4     ,3.5     ,3.6     ,3.7    ,\n  3.8     ,3.9     ,\n  4       ,4.1     ,4.2     ,4.3     ,4.4     ,4.5     ,4.6     ,4.7    ,\n  4.8     ,\n  5       ,5.1     ,5.2     ,5.3     ,5.4     ,5.5     ,5.6     ,5.7    ,\n  5.8     ,\n  6       ,\n  7       ,\n  8       ,8.0     ,8.1     ,8.2     ,8.3     ,8.4     ,8.5     ,8.6    ,\n  8.7     ,8.8     ,8.9     ,\n  9       ,\n  A       ,A.1     ,A.2     ,A.3     ,\n  C       ,\n  J       ,\n  X       ,TESTMENU,' '    ,*)\n RETURN  (SPFOPT  ,SPFOPT  ,SPFOPT  ,SPFOPT  ,\n  SPFBRO  ,\n  SPFEDIT ,\n  SPFUTIL ,SPFUDA  ,SPFUDA  ,SPFUMC  ,SPFUCA  ,SPFURS  ,SPFUHC  ,SPFUVT  ,\n  SPFUOL  ,SPFUTIL ,\n  SPFUTIL ,SPFUTIL ,SPFUTIL ,SPFUTIL ,SPFUTIL ,SPFUTIL ,SPFUTIL ,SPFUTIL ,\n  SPFUTIL ,\n  SPFJOB  ,SPFJOB  ,SPFJOB  ,SPFJOB  ,SPFJOB  ,SPFJOB  ,SPFJOB  ,SPFJOB  ,\n  SPFJOB  ,\n  SPFTSO  ,\n  SPFTUTOR,\n  SPFUTIL ,TKSPED0D,SPFFOR  ,SPFFOR  ,SPFFOR  ,TKSPBR0D,SPFFOR  ,SPFFOR ,\n  SPFFOR  ,SPFFOR  ,SPFFOR  ,\n  SPFUTIL ,\n  SPFUTIL ,SPFFOR  ,SPFFOR  ,SPFFOR  ,\n  TKSUOL0D,\n  TKSJOL0D,\n  END     ,SPFTMENU,' '   ,?);\n2 OPT CHAR(8) INIT($PARM2)\n LIST     (0       ,0.1     ,0.2     ,0.3     ,\n  3       ,3.1     ,3.2     ,3.8     ,3.9     ,\n  4       ,4.1     ,4.2     ,4.3     ,4.4     ,4.5     ,4.6     ,4.7     ,\n  4.8     ,\n  5       ,5.1     ,5.2     ,5.3     ,5.4     ,5.5     ,5.6     ,5.7     ,\n  5.8     ,\n  7       ,\n  8       ,8.0     ,8.1     ,8.2     ,8.3     ,8.4     ,8.5     ,8.6     ,\n  8.7     ,8.8     ,8.9     ,\n  9       ,\n  A       ,A.1     ,A.2     ,A.3     ,\n  C       ,\n  J       )\n RETURN   (OPT00   ,OPT01   ,OPT02   ,OPT03   ,\n  UTIL    ,UDA1    ,UDA2    ,UOL01   ,VNOTSUP ,\n  VNOTSUP ,VNOTSUP ,VNOTSUP ,VNOTSUP ,VNOTSUP ,VNOTSUP ,VNOTSUP ,VNOTSUP ,\n  VNOTSUP ,\n  *JOBA   ,JOB01   ,JOB02   ,JOB03   ,JOB04   ,JOB05   ,JOB06   ,JOB07   ,\n  JOB08   ,\n  T       ,\n  VPAN    ,VPANE   ,VPAN01  ,VPAN02  ,VPAN03  ,VPAN04  ,VPAN05  ,VPAN06  ,\n  VPAN07  ,VPAN08  ,VPAN09  ,\n  VINDEV  ,\n  VASM2   ,V$AR    ,V$BK    ,V$SM    ,\n  VUOL01  ,\n  VJTIP   );\n 3 ID       CHAR (8) INIT($PARM3);\n 4 TIME     CHAR (5) INIT($PARM4);\n 5 DATE     CHAR (8) INIT($PARM5);\n 6 DATEJ    CHAR (6) INIT($PARM6);\n 7 KY       CHAR (2) INIT($PARM7);\n 8 TERM     CHAR (8) INIT($PARM8);\n 9 MODE     CHAR (1) INIT($PARM9)\n            LIST   (MONO,DUAL)\n            RETURN (M   ,D   );\n10 PFX      CHAR (8) INIT($PARM10);\n11 STEP     CHAR (8) INIT($PARM11);\n12 *        FIXED (8) INIT(0);  ** RESERVED **\n13 *        CHAR (8) INIT(' '); ** RESERVED **\n14 *        FIXED (31) INIT(0); ** RESERVED **\n<END>\n***\n*** ORIGINAL STATEMENTS\n***\n&-----------------------  SPF/TSO PRIMARY OPTION MENU  -------------------------\n&SELECT OPTION ===>%OPT     $\n &                                                          $USERID   -@ID\n &  0 $SPF PARMS  - SPECIFY TERMINAL AND SPF PARAMETERS     $TIME     -@TIME\n&   1 $BROWSE     - DISPLAY SOURCE DATA OR OUTPUT LISTINGS  $TERMINAL -@TERM\n&   2 $EDIT       - CREATE OR CHANGE SOURCE DATA            $PF KEYS  -@KY\n&   3 $UTILITY    - PERFORM SPF UTILITY FUNCTIONS\n&   4 $FOREGROUND - COMPILE, ASSEMBLE, LINK EDIT, OR DEBUG\n&   5 $BACKGROUND - COMPILE, ASSEMBLE, OR LINK EDIT\n&   6 $TSO        - ENTER TSO COMMAND OR CLIST\n&   7 $TUTORIAL   - DISPLAY INFORMATION ABOUT SPF\n&   X $EXIT       - TERMINATE SPF USING LIST/LOG DEFAULTS\n&\n$PRESS&END KEY$TO TERMINATE SPF$\n&\n<ACTION>\n1 OPT CHAR(8) CURSOR GENHELP(TTUTOR)\n LIST   (0     ,0.1   ,0.2   ,0.3   ,1     ,2      ,\n  3      ,3.1   ,3.2   ,3.3   ,3.4   ,3.5   ,3.6   ,3.7   ,3.8   ,3.9   ,\n  4      ,4.1   ,4.2   ,4.3   ,4.4   ,4.5   ,4.6   ,4.7   ,4.8   ,\n  5     ,5.1   ,5.2   ,5.3   ,5.4   ,5.5   ,5.6   ,\n  6     ,7       ,X  ,TESTMENU,' ',*)\n RETURN (SPFOPT,SPFOPT,SPFOPT,SPFOPT,SPFBRO,SPFEDIT,\n  SPFUTIL,SPFUDA,SPFUDA,SPFUMC,SPFUCA,SPFURS,SPFUHC,SPFUVT,SPFUOL,SPFUSC,\n  SPFUTIL,SPFFOR,SPFFOR,SPFFOR,SPFFOR,SPFFOR,SPFFOR,SPFFOR,SPFFOR,\n  SPFJOB,SPFJOB,SPFJOB,SPFJOB,SPFJOB,SPFJOB,SPFJOB,\n  SPFTSO,SPFTUTOR,END,SPFTMENU,' ',?);\n2 OPT CHAR(8) INIT($PARM2)\n LIST   (0    ,0.1  ,0.2  ,0.3  ,3   ,3.1 ,3.2 ,3.8  ,3.9   ,\n  4   ,4.1  ,4.2  ,4.3  ,4.4  ,4.5  ,4.6  ,4.7  ,4.8  ,\n  5    ,5.0  ,5.1  ,5.2  ,5.3  ,5.4  ,5.5  ,5.6  ,7)\n RETURN (OPT00,OPT01,OPT02,OPT03,UTIL,UDA1,UDA2,UOL01,SCRPTA,\n  FORA,FOR01,FOR02,FOR03,FOR04,FOR05,FOR06,FOR07,FOR08,\n  *JOBA,JOB00,JOB01,JOB02,JOB03,JOB04,JOB05,JOB06,T);\n3 ID CHAR(8) INIT($PARM3);\n4 TIME CHAR(5) INIT($PARM4);\n5 DATE CHAR(8) INIT($PARM5);\n6 DATEJ CHAR(6) INIT($PARM6);\n7 KY CHAR(2) INIT($PARM7);\n8 TERM CHAR(8) INIT($PARM8);\n9 MODE CHAR(1) INIT($PARM9)\n LIST   (MONO,DUAL)\n RETURN (M   ,D   );\n10 PFX CHAR(8) INIT($PARM10);\n11 STEP CHAR(8) INIT($PARM11);\n12 * FIXED(8) INIT(0);  ** RESERVED **\n13 * CHAR(8) INIT(' '); ** RESERVED **\n14 * FIXED(31) INIT(0); ** RESERVED **\n<END>\n./ ADD NAME=VASM2    0105-80014-80015-0744-00026-00021-00000-TYD9801 00\n&---------------------  ASM2 UTILITY SELECTION MENU  ---------------------------\n&SELECT OPTION ===>%OPT     $\n&\n&\n&       1$- ARCHIVE FUNCTIONS\n$           REQUEST ARCHIVE TO TAPE.  INQUIRE ABOUT ARCHIVED DATASETS.\n$           REQUEST RELOAD OF ARCHIVED DATASET.\n$\n&       2$- BACKUP FUNCTIONS\n$           REQUEST BACKUP TO TAPE.   INQUIRE ABOUT BACKED UP DATASETS.\n$           REQUEST RESORE OF BACKED UP DATASET.\n$\n&       3$- SPACE MANAGEMENT FUNCTIONS\n$           LIST DISK DATASET SPACE AND USAGE INFORMATION.\n$           COMPRESS AND/OR RELEASE UNUSED SPACE FROM DATASETS.\n$           RESET END-OF-FILE ON A SEQUENTIAL DATASET.\n&\n&\n<ACTION>\n1 OPT CHAR(8) CURSOR GENHELP(VTASM2)\n      LIST   (1       ,2       ,3       ,*        )\n      RETURN (SPFFOR  ,SPFFOR  ,SPFFOR  ,?        );\n2 OPT CHAR(8)\n      LIST   (1       ,2       ,3       )\n      RETURN (V$AR    ,V$BK    ,V$SM    );\n<END>\n./ ADD NAME=VINDEV   0100-79269-79269-1311-00021-00021-00000-TYD9835 00\n&-------------------  SPF MENU DEVELOPMENT DISPLAY  ----------------------------\n&\n&\n&\n&         * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n&         * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n&         * * $                                                 & * *\n&         * * $                                                 & * *\n&         * * $         THE MENU THAT WAS SELECTED              & * *\n&         * * $         IS CURRENTLY IN DEVELOPMENT.            & * *\n&         * * $                                                 & * *\n&         * * $                                                 & * *\n&         * * $    PRESS&(PF3)$TO DISPLAY PRIMARY OPTION MENU   & * *\n&         * * $                                                 & * *\n&         * * $                                                 & * *\n&         * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n&         * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n<ACTION>\n 1 PRJ1    CHAR (8)  INIT(' ')      LIST   (' ')\n                     NOCURSOR       RETURN (' '); REQUIRED\n<END>\n./ ADD NAME=VJTIP    0108-80108-80135-1122-00051-00051-00000-$SYS13  00\n&-----------------------------  JTIP UTILITY  ----------------------------------\n&SELECT OPTION ===>%TCOD                                                       $\n&\n&   L$- SHOW JOB NAMES/ID'S VIA THE JTIP SHOW COMMAND\n&   S$- SHOW A JOB'S FETCH DATASET INFORMATION\n&   D$- DELETE JOB OUTPUT FROM FETCH OR SYSOUT QUEUE\n&   R$- REQUEUE JOB OUTPUT FROM FETCH QUEUE TO SYSOUT QUEUE\n&   O$- DISPLAY JOB OUTPUT AT TERMINAL\n&   BLANK$- COPY OUTPUT FROM FETCH QUEUE TO TEMPORARY DATASET AND BROWSE\n$\n$FOR JOB TO BE SELECTED:\n$   JOBNAME OR JOBID &===>%TJNM    $\n$\n$   DDNAME(S)     &===>%TDDNAME                            $\n$   DATASET ID(S) &===>%TPN                                $\n$\n$FOR OPTION 'O':                       FOR OPTION 'R':\n$   START  COLUMN &===>%TC1$              DEST &===>%TDST  $\n$   ENDING COLUMN &===>%TC2$\n<ACTION>\n 1 TCOD    CHAR (1)  INIT(' ')     LIST   (L,S,D,R,O,' ',*) GENHELP(VTJTIP)\n                       CURSOR      RETURN (L,S,D,R,O, B ,?); REQUIRED\n 2 TCOD    CHAR (1)  INIT(' ')     LIST   ('L' ,  * )  KEY(SW1)\n                     NOCURSOR      RETURN ('\u00ac' , ' ');\n 3 TCOD    CHAR (1)  INIT(' ')     LIST   ('S' ,  * )  KEY(SW2)\n                     NOCURSOR      RETURN ('\u00ac' , ' ');\n 4 TCOD    CHAR (1)  INIT(' ')     LIST   ('D' ,  * )  KEY(SW3)\n                     NOCURSOR      RETURN ('\u00ac' , ' ');\n 5 TCOD    CHAR (1)  INIT(' ')     LIST   ('R' ,  * )  KEY(SW4)\n                     NOCURSOR      RETURN ('\u00ac' , ' ');\n 6 TCOD    CHAR (1)  INIT(' ')     LIST   ('O' ,  * )  KEY(SW5)\n                     NOCURSOR      RETURN ('\u00ac' , ' ');\n 7 TCOD    CHAR (1)  INIT(' ')     LIST   (' ' ,  * )  KEY(SW6)\n                     NOCURSOR      RETURN ('\u00ac' , ' ');\n 8 TJNM    CHAR (8)  INIT($PARM8)  LIST   (' ' ,  * )\n                     NOCURSOR      RETURN ('\u00ac'      ); OPTIONAL\n 9 TDDNAME CHAR (35) INIT(' ')     LIST   (' ' ,  * )\n                     NOCURSOR      RETURN (' '      ); OPTIONAL\n10 TDDNAME CHAR (1)  INIT(' ')     LIST   (' ' ,  * )  KEY(SW7)\n                     NOCURSOR      RETURN ('\u00ac' , ' ');\n11 TPN     CHAR (35) INIT(' ')     LIST   (' ' ,  * )\n                     NOCURSOR      RETURN (' '      ); OPTIONAL\n12 TPN     CHAR (1)  INIT(' ')     LIST   (' ' ,  * )  KEY(SW8)\n                     NOCURSOR      RETURN ('\u00ac' , ' ');\n13 TC1     CHAR (3)  INIT('001')   LIST   (' ' ,  * )\n                     NOCURSOR      RETURN ('001'    ); OPTIONAL\n14 TC2     CHAR (3)  INIT('079')   LIST   (' ' ,  * )\n                     NOCURSOR      RETURN ('079'    ); OPTIONAL\n15 TDST    CHAR (4)  INIT($PARM15)  LIST   (' ' , * )\n                     NOCURSOR      RETURN (' '      ); OPTIONAL\n<END>\n./ ADD NAME=VJTIPB   0100-79269-79269-1311-00007-00007-00000-TYD9835 00\n&JTIP OUTPUT LISTING FOR#JOB                            &LINE 00001 COLS 001 080\n&COMMAND INPUT ===>%INPUT                                     &SCROLL ===>%AMT $\n<ACTION>\n1 JOB   CHAR(35) INIT($PARM1) GENHELP(VTJTIPB);\n0 INPUT CHAR(40) CURSOR;\n0 AMT   CHAR(4)  INIT('PAGE');\n<END>\n./ ADD NAME=VJTIPO   0104-79269-80108-0931-00051-00049-00000-$CSG05  00\n&-----------------------------  JTIP UTILITY  ----------------------------------\n&SELECT OPTION ===>%TCOD                                                       $\n&\n&   L$- SHOW JOB NAMES/ID'S VIA THE JTIP SHOW COMMAND\n&   S$- SHOW A JOB'S FETCH DATASET INFORMATION\n&   D$- DELETE JOB OUTPUT FROM FETCH OR SYSOUT QUEUE\n&   R$- REQUEUE JOB OUTPUT FROM FETCH QUEUE TO SYSOUT QUEUE\n&   O$- DISPLAY JOB OUTPUT AT TERMINAL\n&   BLANK$- COPY OUTPUT FROM FETCH QUEUE TO TEMPORARY DATASET AND BROWSE\n$\n$FOR JOB TO BE SELECTED:\n$   JOBNAME OR JOBID &===>%TJNM    $\n$\n$   DDNAME(S)     &===>%TDDNAME                            $\n$   DATASET ID(S) &===>%TPN                                $\n$\n$FOR OPTION 'O':                       FOR OPTION 'R':\n$   START  COLUMN &===>%TC1$              DEST &===>%TDST$\n$   ENDING COLUMN &===>%TC2$\n<ACTION>\n 1 TCOD    CHAR (1)  INIT(' ')     LIST   (L,S,D,R,O,' ',*) GENHELP(VTJTIP)\n                       CURSOR      RETURN (L,S,D,R,O, B ,?); REQUIRED\n 2 TCOD    CHAR (1)  INIT(' ')     LIST   ('L' ,  * )  KEY(SW1)\n                     NOCURSOR      RETURN ('\u00ac' , ' ');\n 3 TCOD    CHAR (1)  INIT(' ')     LIST   ('S' ,  * )  KEY(SW2)\n                     NOCURSOR      RETURN ('\u00ac' , ' ');\n 4 TCOD    CHAR (1)  INIT(' ')     LIST   ('D' ,  * )  KEY(SW3)\n                     NOCURSOR      RETURN ('\u00ac' , ' ');\n 5 TCOD    CHAR (1)  INIT(' ')     LIST   ('R' ,  * )  KEY(SW4)\n                     NOCURSOR      RETURN ('\u00ac' , ' ');\n 6 TCOD    CHAR (1)  INIT(' ')     LIST   ('O' ,  * )  KEY(SW5)\n                     NOCURSOR      RETURN ('\u00ac' , ' ');\n 7 TCOD    CHAR (1)  INIT(' ')     LIST   (' ' ,  * )  KEY(SW6)\n                     NOCURSOR      RETURN ('\u00ac' , ' ');\n 8 TJNM    CHAR (8)  INIT($PARM8)  LIST   (' ' ,  * )\n                     NOCURSOR      RETURN ('\u00ac'      ); OPTIONAL\n 9 TDDNAME CHAR (35) INIT(' ')     LIST   (' ' ,  * )\n                     NOCURSOR      RETURN (' '      ); OPTIONAL\n10 TDDNAME CHAR (1)  INIT(' ')     LIST   (' ' ,  * )  KEY(SW7)\n                     NOCURSOR      RETURN ('\u00ac' , ' ');\n11 TPN     CHAR (35) INIT(' ')     LIST   (' ' ,  * )\n                     NOCURSOR      RETURN (' '      ); OPTIONAL\n12 TPN     CHAR (1)  INIT(' ')     LIST   (' ' ,  * )  KEY(SW8)\n                     NOCURSOR      RETURN ('\u00ac' , ' ');\n13 TC1     CHAR (3)  INIT('001')   LIST   (' ' ,  * )\n                     NOCURSOR      RETURN ('001'    ); OPTIONAL\n14 TC2     CHAR (3)  INIT('079')   LIST   (' ' ,  * )\n                     NOCURSOR      RETURN ('079'    ); OPTIONAL\n15 TDST    CHAR (4)  INIT($PARM15)  LIST   (' ' , * )\n                     NOCURSOR      RETURN (' '      ); OPTIONAL\n<END>\n./ ADD NAME=VJTIP9   0100-80135-80135-1114-00051-00051-00000-$SYS13  00\n&-----------------------------  JTIP UTILITY  ----------------------------------\n&SELECT OPTION ===>%TCOD                                                       $\n&\n&   L$- SHOW JOB NAMES/ID'S VIA THE JTIP SHOW COMMAND\n&   S$- SHOW A JOB'S FETCH DATASET INFORMATION\n&   D$- DELETE JOB OUTPUT FROM FETCH OR SYSOUT QUEUE\n&   R$- REQUEUE JOB OUTPUT FROM FETCH QUEUE TO SYSOUT QUEUE\n&   O$- DISPLAY JOB OUTPUT AT TERMINAL\n&   BLANK$- COPY OUTPUT FROM FETCH QUEUE TO TEMPORARY DATASET AND BROWSE\n$\n$FOR JOB TO BE SELECTED:\n$   JOBNAME OR JOBID &===>%TJNM    $\n$\n$   DDNAME(S)     &===>%TDDNAME                            $\n$   DATASET ID(S) &===>%TPN                                $\n$\n$FOR OPTION 'O':                       FOR OPTION 'R':\n$   START  COLUMN &===>%TC1$              DEST &===>%TDST$\n$   ENDING COLUMN &===>%TC2$\n<ACTION>\n 1 TCOD    CHAR (1)  INIT(' ')     LIST   (L,S,D,R,O,' ',*) GENHELP(VTJTIP)\n                       CURSOR      RETURN (L,S,D,R,O, B ,?); REQUIRED\n 2 TCOD    CHAR (1)  INIT(' ')     LIST   ('L' ,  * )  KEY(SW1)\n                     NOCURSOR      RETURN ('\u00ac' , ' ');\n 3 TCOD    CHAR (1)  INIT(' ')     LIST   ('S' ,  * )  KEY(SW2)\n                     NOCURSOR      RETURN ('\u00ac' , ' ');\n 4 TCOD    CHAR (1)  INIT(' ')     LIST   ('D' ,  * )  KEY(SW3)\n                     NOCURSOR      RETURN ('\u00ac' , ' ');\n 5 TCOD    CHAR (1)  INIT(' ')     LIST   ('R' ,  * )  KEY(SW4)\n                     NOCURSOR      RETURN ('\u00ac' , ' ');\n 6 TCOD    CHAR (1)  INIT(' ')     LIST   ('O' ,  * )  KEY(SW5)\n                     NOCURSOR      RETURN ('\u00ac' , ' ');\n 7 TCOD    CHAR (1)  INIT(' ')     LIST   (' ' ,  * )  KEY(SW6)\n                     NOCURSOR      RETURN ('\u00ac' , ' ');\n 8 TJNM    CHAR (8)  INIT($PARM8)  LIST   (' ' ,  * )\n                     NOCURSOR      RETURN ('\u00ac'      ); OPTIONAL\n 9 TDDNAME CHAR (35) INIT(' ')     LIST   (' ' ,  * )\n                     NOCURSOR      RETURN (' '      ); OPTIONAL\n10 TDDNAME CHAR (1)  INIT(' ')     LIST   (' ' ,  * )  KEY(SW7)\n                     NOCURSOR      RETURN ('\u00ac' , ' ');\n11 TPN     CHAR (35) INIT(' ')     LIST   (' ' ,  * )\n                     NOCURSOR      RETURN (' '      ); OPTIONAL\n12 TPN     CHAR (1)  INIT(' ')     LIST   (' ' ,  * )  KEY(SW8)\n                     NOCURSOR      RETURN ('\u00ac' , ' ');\n13 TC1     CHAR (3)  INIT('001')   LIST   (' ' ,  * )\n                     NOCURSOR      RETURN ('001'    ); OPTIONAL\n14 TC2     CHAR (3)  INIT('079')   LIST   (' ' ,  * )\n                     NOCURSOR      RETURN ('079'    ); OPTIONAL\n15 TDST    CHAR (4)  INIT('RMT0')   LIST   (' ' , * )\n                     NOCURSOR      RETURN ('RMT0'   ); OPTIONAL\n<END>\n./ ADD NAME=VNOTSUP  0100-79269-79269-1311-00021-00021-00000-TYD9835 00\n&-------------------  SPF MENU UNSUPPORTED DISPLAY  ----------------------------\n&\n&\n&\n&         * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n&         * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n&         * * $                                                 & * *\n&         * * $                                                 & * *\n&         * * $         THE MENU THAT WAS SELECTED              & * *\n&         * * $         IS NOT CURRENTLY SUPPORTED.             & * *\n&         * * $                                                 & * *\n&         * * $                                                 & * *\n&         * * $    PRESS&(PF3)$TO DISPLAY PRIMARY OPTION MENU   & * *\n&         * * $                                                 & * *\n&         * * $                                                 & * *\n&         * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n&         * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n<ACTION>\n 1 PRJ1     CHAR (8)  INIT(' ')    LIST   (' ')\n                      NOCURSOR     RETURN (' '); REQUIRED\n<END>\n./ ADD NAME=VOPT01SM 0100-79269-79269-1311-00087-00087-00000-TYD9835 00\n&-----------------------  TERMINAL CHARACTERISTICS  ----------------------------\n&ENTER/VERIFY PARAMETERS BELOW:\n&\n$\n$TERMINAL TYPE    &===>%TERM    $(3277 - 3277/3275 DISPLAY STATION)\n$                                (3278 - 3278/3276 DISPLAY STATION)\n$\n$NUMBER OF PF KEYS&===>%KY$      (12 - TWELVE PROGRAM FUNCTION KEYS)\n$                                (24 - TWENTY FOUR PROGRAM FUNCTION KEYS)\n$\n$CHARACTER MODE   &===>%MODE$    (DUAL - DISPLAY UPPER/LOWER CASE CHARACTERS)\n$                                (MONO - DISPLAY UPPER CASE CHARACTERS ONLY)\n$\n$SESSION MANAGER MODE FOR LINE MESSAGES\n$                 &===>%SMM$    (NO  - DO NOT ENTER SESSION MANAGER MODE)\n$                               (YES - ENTER SESSION MANAGER MODE)\n<ACTION>\n 1 TERM    CHAR(8)  INIT(' '   ) CURSOR GENHELP(TOPT1)\n                    LIST   (3277   ,3278   ,3278C   ,' ',*)\n                    RETURN (SPF3277,SPF3278,SPF3278C,' ',?);\n 2 TERM    CHAR(8)  INIT($PARM2) NOCURSOR;\n 3 KY      CHAR(2)  INIT($PARM3) NOCURSOR;\n 4 MODE    CHAR(1)  INIT($PARM4) NOCURSOR\n                    LIST   (MONO,DUAL,*)\n                    RETURN (M   ,D   );\n 5 SMM     CHAR(1)  INIT($PARM5) NOCURSOR\n                    LIST   (NO,YES,*)\n                    RETURN (N ,Y  );\n<END>\n************************************************************************\n\nTHE FOLLOWING MODIFICATIONS MAY BE MADE TO THIS MENU IF YOU WANT TO\nTO CONTROL SESSION MANAGER MODE FOR TSO MESSAGES OUTSIDE OF OPTION 6\nAND OPTION 4.\n\n*** MOVE THE FOLLOWING 4 LINES BEFORE THE \"<ACTION>\" STATEMENT *********\n$\n$SESSION MANAGER MODE FOR LINE MESSAGES\n$                 &===>%SMM$    (NO  - DO NOT ENTER SESSION MANAGER MODE)\n$                               (YES - ENTER SESSION MANAGER MODE)\n\n*** REPLACE ACTION STATEMENT 5 WITH THE FOLLOWING 3 LINES **************\n 5 SMM     CHAR(1)  INIT($PARM5) NOCURSOR\n                    LIST   (NO,YES,*)\n                    RETURN (N ,Y  );\n*\n* ORGINAL STATEMENTS\n*\n&-----------------------  TERMINAL CHARACTERISTICS  ----------------------------\n&ENTER/VERIFY PARAMETERS BELOW:\n&\n$\n$TERMINAL TYPE    &===>%TERM    $(3277 - 3277/3275 DISPLAY STATION)\n$                                (3278 - 3278/3276 DISPLAY STATION)\n$\n$NUMBER OF PF KEYS&===>%KY$      (12 - TWELVE PROGRAM FUNCTION KEYS)\n$                                (24 - TWENTY FOUR PROGRAM FUNCTION KEYS)\n$\n$CHARACTER MODE   &===>%MODE$    (DUAL - DISPLAY UPPER/LOWER CASE CHARACTERS)\n$                                (MONO - DISPLAY UPPER CASE CHARACTERS ONLY)\n<ACTION>\n 1 TERM    CHAR(8)  INIT(' '   ) CURSOR GENHELP(TOPT1)\n                    LIST   (3277   ,3278   ,3278C   ,' ',*)\n                    RETURN (SPF3277,SPF3278,SPF3278C,' ',?);\n 2 TERM    CHAR(8)  INIT($PARM2) NOCURSOR;\n 3 KY      CHAR(2)  INIT($PARM3) NOCURSOR;\n 4 MODE    CHAR(1)  INIT($PARM4) NOCURSOR\n                    LIST   (MONO,DUAL,*)\n                    RETURN (M   ,D   );\n 5 SMM     CHAR(1)  INIT('N'); SESSION MANAGER MODE - SEE COMMENTS BELOW\n<END>\n************************************************************************\n\nTHE FOLLOWING MODIFICATIONS MAY BE MADE TO THIS MENU IF YOU WANT TO\nTO CONTROL SESSION MANAGER MODE FOR TSO MESSAGES OUTSIDE OF OPTION 6\nAND OPTION 4.\n\n*** MOVE THE FOLLOWING 4 LINES BEFORE THE \"<ACTION>\" STATEMENT *********\n$\n$SESSION MANAGER MODE FOR LINE MESSAGES\n$                 &===>%SMM$    (NO  - DO NOT ENTER SESSION MANAGER MODE)\n$                               (YES - ENTER SESSION MANAGER MODE)\n\n*** REPLACE ACTION STATEMENT 5 WITH THE FOLLOWING 3 LINES **************\n 5 SMM     CHAR(1)  INIT($PARM5) NOCURSOR\n                    LIST   (NO,YES,*)\n                    RETURN (N ,Y  );\n./ ADD NAME=VPAN     0105-79269-80119-1603-00021-00021-00000-$SYS13  00\n&--------------------------  PANVALET SELECTION MENU  --------------------------\n&SELECT OPTION ===>%P       $\n&\n&  0$- PAN EDIT                            &5$- PAN LISTDS\n&  1$- PAN ADD                             &6$- PAN PRINT\n&  2$- PAN CHANGE                          &7$- PAN RENAME\n&  3$- PAN COPY                            &8$- PAN RETRIEVE\n&  4$- PAN DISPLAY                         &9$- PAN STORE\n&\n<ACTION>\n1 P   CHAR(8) CURSOR GENHELP(VTPAN)\n      LIST   (0       ,1       ,2       ,3        ,4        ,5       ,\n              6       ,7       ,8        ,9        ,*       )\n      RETURN (TKSPED0D,SPFFOR  ,SPFFOR  ,SPFFOR   ,SPFIPAN2 ,SPFFOR  ,\n              SPFFOR  ,SPFFOR  ,SPFFOR   ,SPFFOR   ,'?'     );\n2 P   CHAR(8)\n      LIST   (0       ,1       ,2        ,3       ,4        ,5       ,\n              6       ,7       ,8        ,9        )\n      RETURN (VPANE   ,VPAN01  ,VPAN02   ,VPAN03  ,VPAN04   ,VPAN05  ,\n              VPAN06  ,VPAN07  ,VPAN08   ,VPAN09   );\n<END>\n./ ADD NAME=VPANE    0122-79262-79333-1709-00050-00055-00000-TYD9801 00\n&---------------------------------  PAN EDIT  ----------------------------------\n&SELECT OPTION ===>%VOPT$\n&\n&   S$- SAVE EDITED MEMBER VIA PAN STORE (SPF MEMBER DELETED)\n&   D$- DISPLAY EDIT STATUS OF PANVALET MEMBER\n&   E$- END PANVALET MEMBER EDIT STATUS WITHOUT SAVE\n&   BLANK$- EDIT PANVALET MEMBER\n&\n$    PANVALET LIBRARY$===> DDNAME&===>%VDDNAME $\n$                         PANNAME&===>%VPANNAM   $\n$                          ACCESS&===>\u00acVACC $\n$                         CONTROL&===>\u00acVCTL $\n&\n$    SPF DATASET$===>     PROJECT&===>%PRJ0    &\n$                         LIBRARY&===>%LIB0    &\n$                            TYPE&===>%TYP0    &\n$                          MEMBER&===>%MEMBER  $(IF DIFFERENT THAN PANNAME)&\n&\n<ACTION>\n 1 VOPT    CHAR (1)   INIT(' ')   LIST   (S,D,E,' ',*) GENHELP(VTPANE)\n                        CURSOR    RETURN (S,D,E, R ,?); REQUIRED\n 2 VOPT    CHAR (1)   INIT(' ')   LIST   (' ' ,  * )  KEY(SW1)\n                      NOCURSOR    RETURN (' ' , '\u00ac');\n 3 VOPT    CHAR (1)   INIT(' ')   LIST   ('S' ,  * )  KEY(SW2)\n                      NOCURSOR    RETURN (' ' , '\u00ac');\n 4 VOPT    CHAR (1)   INIT(' ')   LIST   ('E' ,  * )  KEY(SW3)\n                      NOCURSOR    RETURN (' ' , '\u00ac');\n 5 VOPT    CHAR (1)   INIT(' ')   LIST   ('D' ,  * )  KEY(SW4)\n                      NOCURSOR    RETURN (' ' , '\u00ac');\n 6 PRJ0     CHAR (8)  INIT($PARM6)  LIST   (' ' , * )\n                      NOCURSOR      RETURN ('?'     ); REQUIRED\n 7 LIB0     CHAR (8)  INIT($PARM7)  LIST   (' ' , * )\n                      NOCURSOR      RETURN ('?'     ); REQUIRED\n 8 TYP0     CHAR (8)  INIT($PARM8)  LIST   (' ' , * )\n                      NOCURSOR      RETURN ('?'     ); REQUIRED\n 9 MEMBER   CHAR (8)  INIT(' ')     LIST   (' ' , * )\n                      NOCURSOR      RETURN ('?'     ); OPTIONAL\n10 VDDNAME  CHAR (8)  INIT($PARM10) LIST   (' ' , * )\n                      NOCURSOR      RETURN ('?'     ); REQUIRED\n11 VPANNAM  CHAR (10) INIT(' ')     LIST   (' ' , * )\n                        CURSOR      RETURN ('?'     ); OPTIONAL\n12 VACC     CHAR (5)  INIT(' ')\n                      NOCURSOR                       ; OPTIONAL\n13 VACC     CHAR (1)  INIT(' ')     LIST   (' ' , * )  KEY(SW5)\n                      NOCURSOR      RETURN ('\u00ac' ,' ');\n14 VCTL     CHAR (5)  INIT(' ')\n                      NOCURSOR                       ; OPTIONAL\n15 VCTL     CHAR (1)  INIT(' ')     LIST   (' ' , * )  KEY(SW6)\n                      NOCURSOR      RETURN ('\u00ac' ,' ');\n<END>\n./ ADD NAME=VPAN01   0101-79269-80028-2005-00055-00055-00000-TYD9801 00\n&----------------------------------  PAN ADD  ----------------------------------\n&ENTER/VERIFY PARAMETERS BELOW:\n&\n$TO PANVALET LIBRARY $                        PANVALET OPTIONS\n$        DDNAME&===>%VDDNAME $                          USER&===>\u00acVUSR$\n$       PANNAME&===>%VPANNAM   $                     CONTROL&===>\u00acVCTL $\n$        FORMAT&===>%VFORMAT $                  INTERNAL FMT&===>%VINTFMT $\n$                                                DISPOSITION&===>%VDISP $\n$FROM SPF DATASET\n$       PROJECT&===>%PRJ1    &\n$       LIBRARY&===>%LIB1    &\n$          TYPE&===>%TYP1    &\n$        MEMBER&===>%MEMBER  &\n&\n$FROM NON-SPF SEQUENTIAL OR PARTITIONED DATASET\n$        DSNAME&===>%VDSNAME                                                 $\n&\n<ACTION>\n40 VDDNAME  CHAR (8)  INIT($PARM40) LIST   (' ' , * )  GENHELP(VTPAN01)\n                      NOCURSOR      RETURN ('?'     ); REQUIRED\n41 VPANNAM  CHAR (10) INIT(' ')     LIST   (' ' , * )\n                        CURSOR      RETURN ('?'     ); REQUIRED\n42 VFORMAT  CHAR (8)  INIT(' ')     LIST   (' ' , * )\n                      NOCURSOR      RETURN ('?'     ); REQUIRED\n10 PRJ1     CHAR (8)  INIT($PARM10) LIST   (' ' , * )\n                      NOCURSOR      RETURN ('\u00ac'     ); OPTIONAL\n11 LIB1     CHAR (8)  INIT($PARM11) LIST   (' ' , * )\n                      NOCURSOR      RETURN ('\u00ac'     ); OPTIONAL\n12 TYP1     CHAR (8)  INIT($PARM12) LIST   (' ' , * )\n                      NOCURSOR      RETURN ('\u00ac'     ); OPTIONAL\n31 MEMBER   CHAR (8)  INIT(' ')     LIST   (' ' , * )\n                      NOCURSOR      RETURN ('\u00ac'     ); OPTIONAL\n61 MEMBER   CHAR (1)  INIT(' ')     LIST   (' ' , * )  KEY(SW1)\n                      NOCURSOR      RETURN ('\u00ac' ,' ');\n47 VDSNAME  CHAR (56) INIT(' ')     LIST   (' ' , * )\n                      NOCURSOR      RETURN ('\u00ac'     ); OPTIONAL\n67 VDSNAME  CHAR (1)  INIT(' ')     LIST   (' ' , * )  KEY(SW2)\n                      NOCURSOR      RETURN ('\u00ac' ,' ');\n43 VUSR     CHAR (4)  INIT(' ')     LIST   (' ' , * )\n                      NOCURSOR      RETURN ('\u00ac'     ); OPTIONAL\n63 VUSR     CHAR (1)  INIT(' ')     LIST   (' ' , * )  KEY(SW3)\n                      NOCURSOR      RETURN ('\u00ac' ,' ');\n44 VCTL     CHAR (5)  INIT(' ')     LIST   (' ' , * )\n                      NOCURSOR      RETURN ('\u00ac'     ); OPTIONAL\n64 VCTL     CHAR (1)  INIT(' ')     LIST   (' ' , * )  KEY(SW4)\n                      NOCURSOR      RETURN ('\u00ac' ,' ');\n45 VINTFMT  CHAR (8)  INIT('TSO')   LIST (' ' , TSO , PANVALET , NOFORMAT ,\n                                             T , P , N )\n                      NOCURSOR      RETURN ('?' , TSO , PANVALET , NOFORMAT ,\n                                             T , P , N ); REQUIRED\n46 VDISP    CHAR (6)  INIT('DELETE') LIST  (' ' , DELETE , KEEP ,\n                                                      DE , K )\n                      NOCURSOR      RETURN ('?' , DELETE , KEEP ,\n                                                      DE , K ); REQUIRED\n<END>\n./ ADD NAME=VPAN02   0100-79269-79269-1311-00047-00047-00000-TYD9835 00\n&--------------------------------  PAN CHANGE  ---------------------------------\n&ENTER/VERIFY PARAMETERS BELOW:\n&\n$IN PANVALET LIBRARY\n$        DDNAME&===>%VDDNAME $\n$       PANNAME&===>%VPANNAM   $\n&\n&ENTER CHANGE IN ONLY ONE CRITERION\n$       STATUS &===>%VSTATUS $\n$       COMMENT&===>%VCOM                                              $\n$          USER&===>\u00acVUSR$\n$         LEVEL&===>%VLV$\n&\n$PANVALET OPTIONS\n$        ACCESS&===>\u00acVACC $\n$       CONTROL&===>\u00acVCTL $\n&\n<ACTION>\n40 VDDNAME  CHAR (8)  INIT($PARM40) LIST   (' ' , * )  GENHELP(VTPAN02)\n                      NOCURSOR      RETURN ('?'     ); REQUIRED\n41 VPANNAM  CHAR (10) INIT(' ')     LIST   (' ' , * )\n                        CURSOR      RETURN ('?'     ); REQUIRED\n49 VSTATUS  CHAR (8)  INIT(' ')     LIST   (' ' , * )\n                      NOCURSOR      RETURN ('\u00ac'     ); OPTIONAL\n3  VSTATUS  CHAR (1)  INIT(' ')     LIST   (' ' , * )  KEY(SW1)\n                      NOCURSOR      RETURN ('\u00ac' ,' ');\n50 VCOM     CHAR (50) INIT(' ')     LIST   (' ' , * )\n                      NOCURSOR      RETURN ('\u00ac'     ); OPTIONAL\n2  VCOM     CHAR (1)  INIT(' ')     LIST   (' ' , * )  KEY(SW2)\n                      NOCURSOR      RETURN ('\u00ac' ,' ');\n43 VUSR     CHAR (4)  INIT(' ')     LIST   (' ' , * )\n                      NOCURSOR      RETURN ('\u00ac'     ); OPTIONAL\n63 VUSR     CHAR (1)  INIT(' ')     LIST   (' ' , * )  KEY(SW3)\n                      NOCURSOR      RETURN ('\u00ac' ,' ');\n51 VLV      CHAR (3)  INIT(' ')     LIST   (' ' , * )\n                      NOCURSOR      RETURN ('\u00ac'     ); OPTIONAL\n61 VLV      CHAR (1)  INIT(' ')     LIST   (' ' , * )  KEY(SW4)\n                      NOCURSOR      RETURN ('\u00ac' ,' ');\n48 VACC     CHAR (5)  INIT(' ')     LIST   (' ' , * )\n                      NOCURSOR      RETURN ('\u00ac'     ); OPTIONAL\n68 VACC     CHAR (1)  INIT(' ')     LIST   (' ' , * )  KEY(SW5)\n                      NOCURSOR      RETURN ('\u00ac' ,' ');\n44 VCTL     CHAR (5)  INIT(' ')     LIST   (' ' , * )\n                      NOCURSOR      RETURN ('\u00ac'     ); OPTIONAL\n64 VCTL     CHAR (1)  INIT(' ')     LIST   (' ' , * )  KEY(SW6)\n                      NOCURSOR      RETURN ('\u00ac' ,' ');\n<END>\n./ ADD NAME=VPAN03   0100-79269-79269-1311-00028-00028-00000-TYD9835 00\n&---------------------------------  PAN COPY  ----------------------------------\n&ENTER/VERIFY PARAMETERS BELOW:\n&\n$IN PANVALET LIBRARY\n$        DDNAME&===>%VDDNAME $\n$  FROM PANNAME&===>%VPANNAM   $\n$    TO NEWNAME&===>%VNEWNAM   $\n&\n$PANVALET OPTIONS\n$        ACCESS&===>\u00acVACC $\n$       CONTROL&===>\u00acVCTL $\n&\n<ACTION>\n40 VDDNAME  CHAR (8)  INIT($PARM40) LIST   (' ' , * )  GENHELP(VTPAN03)\n                      NOCURSOR      RETURN ('?'     ); REQUIRED\n41 VPANNAM  CHAR (10) INIT(' ')     LIST   (' ' , * )\n                        CURSOR      RETURN ('?'     ); REQUIRED\n52 VNEWNAM  CHAR (10) INIT(' ')     LIST   (' ' , * )\n                      NOCURSOR      RETURN ( '?'    ); REQUIRED\n48 VACC     CHAR (5)  INIT(' ')     LIST   (' ' , * )\n                      NOCURSOR      RETURN ('\u00ac'     ); OPTIONAL\n68 VACC     CHAR (1)  INIT(' ')     LIST   (' ' , * )  KEY(SW1)\n                      NOCURSOR      RETURN ('\u00ac' ,' ');\n44 VCTL     CHAR (5)  INIT(' ')     LIST   (' ' , * )\n                      NOCURSOR      RETURN ('\u00ac'     ); OPTIONAL\n64 VCTL     CHAR (1)  INIT(' ')     LIST   (' ' , * )  KEY(SW2)\n                      NOCURSOR      RETURN ('\u00ac' ,' ');\n<END>\n./ ADD NAME=VPAN04   0104-79269-79304-1425-00029-00039-00000-TYD9801 00\n&--------------------------------  PAN DISPLAY  --------------------------------\n&ENTER/VERIFY PARAMETERS BELOW:\n&\n&\n&\n&\n&\n&\n         $IN PANVALET LIBRARY\n                     $DDNAME&===>%VDDNAME $\n             $      $PANNAME&===>%VPANNAM   $\n&\n         $PANVALET OPTIONS\n                     $ACCESS&===>\u00acVACC$\n                     $EXPAND&===>%VEXPAND $\n&\n&\n<ACTION>\n1  VDDNAME  CHAR (8)  INIT($PARM1)  LIST   (' ' , * )  GENHELP(VTPAN04)\n                      NOCURSOR      RETURN ('?'     ); REQUIRED\n2  VPANNAM  CHAR (10) INIT(' ')     LIST   (' ' , * )\n                        CURSOR      RETURN ('?'     ); REQUIRED\n3  VACC     CHAR (4)  INIT(' ')     LIST   (' ' , * )\n                      NOCURSOR      RETURN ('?'     ); OPTIONAL\n4  VEXPAND  CHAR (8)  INIT('NOEXPAND') LIST (' ' , NOEXPAND , EXPAND ,\n                                                          N , E )\n                      NOCURSOR      RETURN ('?'  , NOEXPAND , EXPAND ,\n                                                          N , E ); REQUIRED\n<END>\n./ ADD NAME=VPAN04B  0104-79269-79304-1503-00007-00007-00000-TYD9801 00\n&PAN BROWSE#TITLE                                       &LINE 00001 COLS 001 080\n&COMMAND INPUT ===>%INPUT                                     &SCROLL ===>%AMT $\n<ACTION>\n1 TITLE CHAR(44) INIT($PARM1)  GENHELP(TB)    ;\n0 INPUT CHAR(40) CURSOR;\n0 AMT   CHAR(4)  INIT('PAGE');\n<END>\n./ ADD NAME=VPAN05   0100-79269-79269-1311-00030-00030-00000-TYD9835 00\n&--------------------------------  PAN LISTDS  ---------------------------------\n&ENTER/VERIFY PARAMETERS BELOW:\n&\n$IN PANVALET LIBRARY\n$        DDNAME&===>%VDDNAME $\n$       PANNAME&===>%VPANNAM   $\n&\n$PANVALET OPTIONS\n$        ACCESS&===>\u00acVACC $\n$       CONTROL&===>\u00acVCTL $\n$       COMMENT&===>%VCOM   $\n&\n<ACTION>\n40 VDDNAME  CHAR (8)  INIT($PARM40) LIST   (' ' , * )  GENHELP(VTPAN05)\n                      NOCURSOR      RETURN ('?'     ); REQUIRED\n41 VPANNAM  CHAR (10) INIT(' '  )   LIST   (' ' , * )\n                        CURSOR      RETURN ('?'     ); REQUIRED\n50 VCOM     CHAR (7)  INIT('COMMENT') LIST (' ' , COMMENT , COM )\n                      NOCURSOR      RETURN ('\u00ac' , COMMENT , COM ); OPTIONAL\n60 VCOM     CHAR (1)  INIT('COMMENT') LIST (' ' , COMMENT , COM )  KEY(SW1)\n                      NOCURSOR      RETURN ('\u00ac' ,' ',' ');\n48 VACC     CHAR (5)  INIT(' ')     LIST   (' ' , * )\n                      NOCURSOR      RETURN ('\u00ac'     ); OPTIONAL\n68 VACC     CHAR (1)  INIT(' ')     LIST   (' ' , * )  KEY(SW2)\n                      NOCURSOR      RETURN ('\u00ac' ,' ');\n44 VCTL     CHAR (5)  INIT(' ')     LIST   (' ' , * )\n                      NOCURSOR      RETURN ('\u00ac'     ); OPTIONAL\n64 VCTL     CHAR (1)  INIT(' ')     LIST   (' ' , * )  KEY(SW3)\n                      NOCURSOR      RETURN ('\u00ac' ,' ');\n<END>\n./ ADD NAME=VPAN06   0100-79269-79269-1311-00044-00044-00000-TYD9835 00\n&---------------------------------  PAN PRINT  ---------------------------------\n&ENTER/VERIFY PARAMETERS BELOW:\n&\n$IN PANVALET LIBRARY\n$        DDNAME&===>%VDDNAME $\n&\n&ENTER ONLY ONE SELECTION CRITERION\n$          NAME&===>%VPANNAM   $\n$        STATUS&===>%VSTATUS $\n$          TYPE&===>%VTYPE   $\n$          USER&===>\u00acVUSR$\n&\n$PANVALET OPTIONS\n$       CONTROL&===>\u00acVCTL $\n$       COMMENT&===>%VCOM   $\n&\n<ACTION>\n40 VDDNAME  CHAR (8)  INIT($PARM40) LIST   (' ' , * )  GENHELP(VTPAN06)\n                      NOCURSOR      RETURN ('?'     ); REQUIRED\n41 VPANNAM  CHAR (10) INIT(' ')     LIST   (' ' , * )\n                        CURSOR      RETURN ('\u00ac'     ); OPTIONAL\n4  VPANNAM  CHAR (1)  INIT(' ')     LIST   (' ' , * )  KEY(SW3)\n                      NOCURSOR      RETURN ('\u00ac' ,' ');\n49 VSTATUS  CHAR (8)  INIT(' ')     LIST   (' ' , * )\n                      NOCURSOR      RETURN ('\u00ac'     ); OPTIONAL\n3  VSTATUS  CHAR (1)  INIT(' ')     LIST   (' ' , * )  KEY(SW1)\n                      NOCURSOR      RETURN ('\u00ac' ,' ');\n53 VTYPE    CHAR (8)  INIT(' ')     LIST   (' ' , * )\n                      NOCURSOR      RETURN ('\u00ac'     ); OPTIONAL\n1  VTYPE    CHAR (1)  INIT(' ')     LIST   (' ' , * )  KEY(SW2)\n                      NOCURSOR      RETURN ('\u00ac' ,' ');\n43 VUSR     CHAR (4)  INIT(' ')     LIST   (' ' , * )\n                      NOCURSOR      RETURN ('\u00ac'     ); OPTIONAL\n63 VUSR     CHAR (1)  INIT(' ')     LIST   (' ' , * )  KEY(SW4)\n                      NOCURSOR      RETURN ('\u00ac' ,' ');\n44 VCTL     CHAR (5)  INIT(' ')     LIST   (' ' , * )\n                      NOCURSOR      RETURN ('\u00ac'     ); OPTIONAL\n64 VCTL     CHAR (1)  INIT(' ')     LIST   (' ' , * )  KEY(SW5)\n                      NOCURSOR      RETURN ('\u00ac' ,' ');\n50 VCOM     CHAR (7)  INIT('COMMENT') LIST (' ' , COMMENT , COM )\n                      NOCURSOR      RETURN ('\u00ac' , COMMENT , COM ); OPTIONAL\n60 VCOM     CHAR (1)  INIT('COMMENT') LIST (' ' , * )  KEY(SW6)\n                      NOCURSOR      RETURN ('\u00ac' ,' ');\n<END>\n./ ADD NAME=VPAN07   0100-79269-79269-1311-00028-00028-00000-TYD9835 00\n&--------------------------------  PAN RENAME  ---------------------------------\n&ENTER/VERIFY PARAMETERS BELOW:\n&\n$IN PANVALET LIBRARY\n$        DDNAME&===>%VDDNAME $\n$  FROM PANNAME&===>%VPANNAM   $\n$    TO NEWNAME&===>%VNEWNAM   $\n&\n$PANVALET OPTIONS\n$        ACCESS&===>\u00acVACC $\n$       CONTROL&===>\u00acVCTL $\n&\n<ACTION>\n40 VDDNAME  CHAR (8)  INIT($PARM40) LIST   (' ' , * )  GENHELP(VTPAN07)\n                      NOCURSOR      RETURN ('?'     ); REQUIRED\n41 VPANNAM  CHAR (10) INIT(' ')     LIST   (' ' , * )\n                        CURSOR      RETURN ('?'     ); REQUIRED\n52 VNEWNAM  CHAR (10) INIT(' ')     LIST   (' ' , * )\n                      NOCURSOR      RETURN ('?'     ); REQUIRED\n48 VACC     CHAR (5)  INIT(' ')     LIST   (' ' , * )\n                      NOCURSOR      RETURN ('\u00ac'     ); OPTIONAL\n68 VACC     CHAR (1)  INIT(' ')     LIST   (' ' , * )  KEY(SW1)\n                      NOCURSOR      RETURN ('\u00ac' ,' ');\n44 VCTL     CHAR (5)  INIT(' ')     LIST   (' ' , * )\n                      NOCURSOR      RETURN ('\u00ac'     ); OPTIONAL\n64 VCTL     CHAR (1)  INIT(' ')     LIST   (' ' , * )  KEY(SW2)\n                      NOCURSOR      RETURN ('\u00ac' ,' ');\n<END>\n./ ADD NAME=VPAN08   0100-79269-79269-1311-00053-00053-00000-TYD9835 00\n&-------------------------------  PAN RETRIEVE  --------------------------------\n&ENTER/VERIFY PARAMETERS BELOW:\n&\n$FROM PANVALET LIBRARY $                        PANVALET OPTIONS\n$          DDNAME&===>%VDDNAME $                          ACCESS&===>\u00acVACC $\n$         PANNAME&===>%VPANNAM   $                       CONTROL&===>\u00acVCTL $\n$          EXPAND&===>%VEXPAND $                    INTERNAL FMT&===>%VINTFMT $\n&\n$TO SPF DATASET\n$         PROJECT&===>%PRJ1    &\n$         LIBRARY&===>%LIB1    &\n$            TYPE&===>%TYP1    &\n$          MEMBER&===>%MEMBER  &\n&\n$TO NON-SPF SEQUENTIAL OR PARTITIONED DATASET\n$          DSNAME&===>%VDSNAME                                                 $\n&\n<ACTION>\n40 VDDNAME  CHAR (8)  INIT($PARM40) LIST   (' ' , * )  GENHELP(VTPAN08)\n                      NOCURSOR      RETURN ('?'     ); REQUIRED\n41 VPANNAM  CHAR (10) INIT(' ')     LIST   (' ' , * )\n                        CURSOR      RETURN ('?'     ); REQUIRED\n1  PRJ1     CHAR (8)  INIT($PARM1)  LIST   (' ' , * )\n                      NOCURSOR      RETURN ('\u00ac'     ); OPTIONAL\n2  LIB1     CHAR (8)  INIT($PARM2)  LIST   (' ' , * )\n                      NOCURSOR      RETURN ('\u00ac'     ); OPTIONAL\n6  TYP1     CHAR (8)  INIT($PARM6)  LIST   (' ' , * )\n                      NOCURSOR      RETURN ('\u00ac'     ); OPTIONAL\n31 MEMBER   CHAR (8)  INIT(' ')     LIST   (' ' , * )\n                      NOCURSOR      RETURN ('\u00ac'     ); OPTIONAL\n61 MEMBER   CHAR (1)  INIT(' ')     LIST   (' ' , * )  KEY(SW1)\n                      NOCURSOR      RETURN ('\u00ac' ,' ');\n54 VEXPAND  CHAR (8)  INIT('NOEXPAND') LIST (' ' , NOEXPAND , EXPAND ,\n                                                          N , E )\n                      NOCURSOR      RETURN ('?' , NOEXPAND , EXPAND ,\n                                                      N , E ); OPTIONAL\n47 VDSNAME  CHAR (56) INIT(' ')     LIST   (' ' , * )\n                      NOCURSOR      RETURN ('\u00ac'     ); OPTIONAL\n67 VDSNAME  CHAR (1)  INIT(' ')     LIST   (' ' , * )  KEY(SW2)\n                      NOCURSOR      RETURN ('\u00ac' ,' ');\n44 VCTL     CHAR (5)  INIT(' ')     LIST   (' ' , * )\n                      NOCURSOR      RETURN ('\u00ac'     ); OPTIONAL\n64 VCTL     CHAR (1)  INIT(' ')     LIST   (' ' , * )  KEY(SW3)\n                      NOCURSOR      RETURN ('\u00ac' ,' ');\n45 VINTFMT  CHAR (8)  INIT('TSO')   LIST   (' ' , TSO , PANVALET ,\n                                                    T , P )\n                      NOCURSOR      RETURN ('?' , TSO , PANVALET ,\n                                                    T , P ); OPTIONAL\n48 VACC     CHAR (5)  INIT(' ')     LIST   (' ' , * )\n                      NOCURSOR      RETURN ('\u00ac'     ); OPTIONAL\n68 VACC     CHAR (1)  INIT(' ')     LIST   (' ' , * )  KEY(SW4)\n                      NOCURSOR      RETURN ('\u00ac' ,' ');\n<END>\n./ ADD NAME=VPAN09   0100-79269-79269-1311-00055-00055-00000-TYD9835 00\n&---------------------------------  PAN STORE  ---------------------------------\n&ENTER/VERIFY PARAMETERS BELOW:\n&\n$TO PANVALET LIBRARY$                          PANVALET OPTIONS\n$        DDNAME&===>%VDDNAME $                         ACCESS&===>\u00acVACC $\n$       PANNAME&===>%VPANNAM   $                      CONTROL&===>\u00acVCTL $\n$         LEVEL&===>%VLV$                        INTERNAL FMT&===>%VINTFMT $\n$                                                 DISPOSITION&===>%VDISP $\n$FROM SPF DATASET\n$       PROJECT&===>%PRJ1    &\n$       LIBRARY&===>%LIB1    &\n$          TYPE&===>%TYP1    &\n$        MEMBER&===>%MEMBER  &\n&\n$FROM NON-SPF SEQUENTIAL OR PARTITIONED DATASET\n$        DSNAME&===>%VDSNAME                                                 $\n&\n<ACTION>\n40 VDDNAME  CHAR (8)  INIT($PARM40) LIST   (' ' , * )  GENHELP(VTPAN09)\n                      NOCURSOR      RETURN ('?'     ); REQUIRED\n41 VPANNAM  CHAR (10) INIT(' ')     LIST   (' ' , * )\n                        CURSOR      RETURN ('?'     ); REQUIRED\n51 VLV      CHAR (3)  INIT(' ')     LIST   (' ' , * )\n                      NOCURSOR      RETURN ('?'     ); REQUIRED\n1  PRJ1     CHAR (8)  INIT($PARM1)  LIST   (' ' , * )\n                      NOCURSOR      RETURN ('\u00ac'     ); OPTIONAL\n2  LIB1     CHAR (8)  INIT($PARM2)  LIST   (' ' , * )\n                      NOCURSOR      RETURN ('\u00ac'     ); OPTIONAL\n6  TYP1     CHAR (8)  INIT($PARM6)  LIST   (' ' , * )\n                      NOCURSOR      RETURN ('\u00ac'     ); OPTIONAL\n31 MEMBER   CHAR (8)  INIT(' ')     LIST   (' ' , * )\n                      NOCURSOR      RETURN ('\u00ac'     ); OPTIONAL\n61 MEMBER   CHAR (1)  INIT(' ')     LIST   (' ' , * )  KEY(SW1)\n                      NOCURSOR      RETURN ('\u00ac' ,' ');\n47 VDSNAME  CHAR (56) INIT(' ')     LIST   (' ' , * )\n                      NOCURSOR      RETURN ('\u00ac'     ); OPTIONAL\n67 VDSNAME  CHAR (1)  INIT(' ')     LIST   (' ' , * )  KEY(SW2)\n                      NOCURSOR      RETURN ('\u00ac' ,' ');\n44 VCTL     CHAR (5)  INIT(' ')     LIST   (' ' , * )\n                      NOCURSOR      RETURN ('\u00ac'     ); OPTIONAL\n64 VCTL     CHAR (1)  INIT(' ')     LIST   (' ' , * )  KEY(SW3)\n                      NOCURSOR      RETURN ('\u00ac' ,' ');\n45 VINTFMT  CHAR (8)  INIT('PANVALET') LIST (' ' , TSO , PANVALET ,\n                                                    T , P )\n                      NOCURSOR      RETURN ('?' , TSO , PANVALET ,\n                                                    T , P ); REQUIRED\n46 VDISP    CHAR (6)  INIT('DELETE') LIST  (' ' , DELETE , KEEP ,\n                                                      DE , K )\n                      NOCURSOR      RETURN ('?' , DELETE , KEEP ,\n                                                      DE , K ); REQUIRED\n48 VACC     CHAR (5)  INIT(' ')     LIST   (' ' , * )\n                      NOCURSOR      RETURN ('\u00ac'     ); OPTIONAL\n68 VACC     CHAR (1)  INIT(' ')     LIST   (' ' , * )  KEY(SW4)\n                      NOCURSOR      RETURN ('\u00ac' ,' ');\n<END>\n./ ADD NAME=VSUBMT   0100-79269-79269-1311-00037-00037-00000-TYD9835 00\n&----------------------------------  SUBMIT  -----------------------------------\n&ENTER/VERIFY PARAMETERS BELOW:\n&\n$FROM SPF DATASET\n$       PROJECT&===>%PRJ1    &        $       PROJECT&===>%PRJ2    &\n$       LIBRARY&===>%LIB1    &        $       LIBRARY&===>%LIB2    &\n$          TYPE&===>%TYP1    &        $          TYPE&===>%TYP2    &\n$        MEMBER&===>%MEMBER1 &        $        MEMBER&===>%MEMBER2 &\n&\n$FROM NON-SPF SEQUENTIAL OR PARTITIONED DATASET\n$        DSNAME&===>%VDSNAME1                                                $\n&\n$FROM NON-SPF SEQUENTIAL OR PARTITIONED DATASET\n$        DSNAME&===>%VDSNAME2                                                $\n&\n$FROM PANNVALET LIBRARY\n$        DDNAME&===>%VDDNAME1&        $        DDNAME&===>%VDDNAME2&\n$       PANNAME&===>%VPANNAM1  &      $       PANNAME&===>%VPANNAM2  &\n&\n<ACTION>\n10 PRJ1     CHAR (8)  INIT($PARM10) LIST   (' ' , * )\n                      NOCURSOR      RETURN ('\u00ac'     ); OPTIONAL\n11 LIB1     CHAR (8)  INIT($PARM11) LIST   (' ' , * )\n                      NOCURSOR      RETURN ('\u00ac'     ); OPTIONAL\n12 TYP1     CHAR (8)  INIT($PARM12) LIST   (' ' , * )\n                      NOCURSOR      RETURN ('\u00ac'     ); OPTIONAL\n31 MEMBER1  CHAR (8)  INIT(' ')     LIST   (' ' , * )\n                      NOCURSOR      RETURN ('\u00ac'     ); OPTIONAL\n10 PRJ2     CHAR (8)  INIT($PARM10) LIST   (' ' , * )\n                      NOCURSOR      RETURN ('\u00ac'     ); OPTIONAL\n11 LIB2     CHAR (8)  INIT($PARM11) LIST   (' ' , * )\n                      NOCURSOR      RETURN ('\u00ac'     ); OPTIONAL\n12 TYP2     CHAR (8)  INIT($PARM12) LIST   (' ' , * )\n                      NOCURSOR      RETURN ('\u00ac'     ); OPTIONAL\n31 MEMBER2  CHAR (8)  INIT(' ')     LIST   (' ' , * )\n                      NOCURSOR      RETURN ('\u00ac'     ); OPTIONAL\n<END>\n./ ADD NAME=VT$AR    0103-80015-80105-1504-00031-00031-00000-$CSG05  00\n<FIELDS>\u00ac%!&$#@\n&TUTORIAL ------------------ ASM2 ARCHIVE UTILITY --------------------- TUTORIAL\n&NEXT SELECTION ===>%SELECT                             &\n$\n&                      ----------------------------------\n                       | ASM2 ARCHIVE UTILITY FUNCTIONS |\n                       ----------------------------------\n$\n  THE ASM2 ARCHIVE UTILITY ALLOWS USERS TO MAKE USE OF THE ASM2 ARCHIVE\n  FACILITY.  ARCHIVING IS THE PROCESS BY WHICH A DATASET IS COPIED TO AN ASM2\n  ARCHIVE TAPE AND THEN DELETED FROM DISK AND UNCATALOGED.  THIS PROCESS ALLOWS\n  DATA TO BE RETAINED FOR POSSIBLE FUTURE USE ON DISK EVEN THOUGH THE VOLUME OR\n  FREQUENCY OF USE WOULD NOT NORMALLY WARRANT KEEPING THE DATASET ON DISK.\n  ARCHIVING CAN OCCUR AUTOMATICALLY IN ACCORDANCE WITH INSTALLATION STANDARDS,\n  OR IT CAN BE EXPLICITLY REQUESTED BY THE USER.  IN EITHER CASE THE DATASET IS\n  RETAINED FOR A SPECIFIED,  OR DEFAULT, TIME DURING WHICH IT MAY BE RESTORED\n  TO DISK VIA A USER REQUEST.\n\n THE FOLLOWING TOPICS ARE PRESENTED IN SEQUENCE, OR MAY BE SELECTED BY NUMBER:\n    &1$- GENERAL ARCHIVE CONSIDERATIONS\n    &2$- QUEUEING DATASETS TO BE ARCHIVED\n    &3$- QUEUEING DATASETS TO BE RESTORED\n    &4$- INQUIRING ABOUT THE STATUS OF ARCHIVED DATASETS\n<ACTION>\n1 SELECT CHAR(36) CURSOR;\n2 SELECT CHAR(8) LIST(   1   ,   2   ,   3   ,   4   )\n               RETURN(VT$AR1 ,VT$AR2 ,VT$AR3 ,VT$AR4 );\n3 * CHAR(8) INIT('VTASM2 ');\n4 * CHAR(8) INIT('VT$BK   ');\n5 * CHAR(8) INIT('VT$AR1  ');\n<END>\n./ ADD NAME=VT$AR1   0103-80015-80015-1657-00030-00028-00000-TYD9801 00\n<FIELDS>\u00ac%!&$#@\n&TUTORIAL ------------------ ASM2 ARCHIVE UTILITY --------------------- TUTORIAL\n&NEXT SELECTION ===>%SELECT                             &\n$\n&                      ----------------------------------\n                       | GENERAL ARCHIVE CONSIDERATIONS |\n                       ----------------------------------\n$\n  THE ASM2 ARCHIVE FACILITY IS USED TO COPY A DATASET FROM DISK TO TAPE.\n  THE DISK DATASET IS UNCATALOGED AND DELETED.\n\n  ASM2 PROVIDES FACILITIES TO ARCHIVE DATASETS ,  INQUIRE ABOUT ARCHIVED\n  DATASETS, AND TO RESTORE ARCHIVED DATASETS.    THESE FUNCTIONS MAY BE\n  REQUESTED  FROM A TSO TERMINAL.   THE DATASET IS NOT ARCHIVED OR RESTORED\n  IMMEDIATELY UPON REQUEST.  THE REQUEST IS QUEUED UNTIL A BATCH ARCHIVE OR\n  RESTORE RUN IS SUBMITTED.\n\n THE FOLLOWING TOPICS ARE PRESENTED IN SEQUENCE, OR MAY BE SELECTED BY NUMBER:\n    &1$- ARCHIVE DATASET RESTRICTIONS\n    &2$- TYPES OF ARCHIVE TAPES\n    &3$- SYSTEM INITIATED ARCHIVING\n    &4$- USER INITIATED ARCHIVE\n<ACTION>\n1 SELECT CHAR(36) CURSOR;\n2 SELECT CHAR(8) LIST(   1   ,   2   ,   3   ,   4   )\n               RETURN(VT$AR11,VT$AR12,VT$AR13,VT$AR14);\n3 * CHAR(8) INIT('VT$AR  ');\n4 * CHAR(8) INIT('VT$AR2  ');\n5 * CHAR(8) INIT('VT$AR11 ');\n<END>\n./ ADD NAME=VT$AR11  0102-80015-80016-0739-00028-00021-00000-TYD9801 00\n<FIELDS>\u00ac%!&$#@\n&TUTORIAL ------------------ ASM2 ARCHIVE UTILITY --------------------- TUTORIAL\n&NEXT SELECTION ===>%SELECT                             &\n$\n&                      --------------------------------\n                       | ARCHIVE DATASET RESTRICTIONS |\n                       --------------------------------\n$\n  THE ASM2 ARCHIVE FACILITY CAN BE USED ON ALMOST ALL TYPES OF DATASETS.\n\n  CERTAIN TYPES OF DATASETS ARE NOT NORMALLY ARCHIVED.\n    1. UNMOVEABLE DATASETS\n    2. MULTI-VOLUME DATASETS\n    3. DATSETS WITH INVALID DCB INFORMATION.\n    4. EMPTY DATASETS (CAN BE ARCHIVED WITH PARAMETER OVERRIDE)\n    5. GDG DATASETS (SPECIAL GDG HANDLING IS AVAILABLE)\n\n  VSAM CATALOGS,  PAGE SPACES,  ALTERNATE INDEXES,  DATA COMPONENTS, AND INDEX\n  COMPONENTS CANNOT BE ARCHIVED.  VSAM CLUSTERS MAY BE ARCHIVED AS LONG AS THEY\n  DO NOT HAVE ALTERNATE INDEXES ASSOCIATED WITH THEM.\n\n  ASM2 USES THE 'EXPORT PERMANENT' FUNCTION OF IDCAMS TO ARCHIVE THE CLUSTER.\n<ACTION>\n1 SELECT CHAR(36) CURSOR;\n3 * CHAR(8) INIT('VT$AR1 ');\n4 * CHAR(8) INIT('VT$AR12 ');\n5 * CHAR(8) INIT('        ');\n<END>\n./ ADD NAME=VT$AR12  0100-80015-80015-1646-00025-00025-00000-TYD9801 00\n<FIELDS>\u00ac%!&$#@\n&TUTORIAL ------------------ ASM2 ARCHIVE UTILITY --------------------- TUTORIAL\n&NEXT SELECTION ===>%SELECT                             &\n$\n&                             --------------------------\n                              | TYPES OF ARCHIVE TAPES |\n                              --------------------------\n$\n  ARCHIVED DATASETS ARE GROUPED ON TO ASM2 CONTROLLED ARCHIVE TAPES.  MANY\n  DATASETS ARE WRITTEN ON TO EACH TAPE,  THUS PROVIDING SAVINGS IN TAPES.\n\n  ASM2 SEGREGATES ARCHIVED TAPES INTO TWO GROUPS.  THESE ARE KNOWN AS 'NORMAL'\n  ARCHIVES AND 'PERMANENT' ARCHIVES.  THIS IS DONE TO REDUCE THE HANDLING AND\n  PASSING OF TAPES CONTAINING DATA WHICH IS TO BE KEPT  FOR  LONG  PERIODS  OF\n  TIME,  AND MOST LIKELY,  NOT REFERENCED VERY FREQUENTLY.  ANY ARCHIVE REQUEST\n  SPECIFYING  A  RETENTION  PERIOD  GREATER  THAN  3  YEARS,   IS  CONSIDERED\n  'PERMANENT'.   YOU  MAY  ALSO  DESIGNATE  AN  ARCHIVE  DATASET AS PERMANENT,\n  REGARDLESS OF RETENTION.  THE DEFAULT RETENTION PERIOD IS 1 YEAR FOR NORMAL\n  ARCHIVES,  AND 5 YEARS FOR PERMANENT ARCHIVES.\n<ACTION>\n1 SELECT CHAR(36) CURSOR;\n3 * CHAR(8) INIT('VT$AR1 ');\n4 * CHAR(8) INIT('VT$AR13 ');\n5 * CHAR(8) INIT('        ');\n<END>\n./ ADD NAME=VT$AR13  0104-80015-80017-1605-00021-00025-00000-TYD9801 00\n<FIELDS>\u00ac%!&$#@\n&TUTORIAL ------------------ ASM2 ARCHIVE UTILITY --------------------- TUTORIAL\n&NEXT SELECTION ===>%SELECT                             &\n$\n&                         ------------------------------\n                          | SYSTEM INITIATED ARCHIVING |\n                          ------------------------------\n$\n  IN SYSTEM INITIATED ARCHIVAL,  ONLINE DISK VOLUMES ARE SCANNED FOR DATASETS\n  WHICH ARE NOT PRE-AUTHORIZED TO REMAIN ON DISK.  THE UNAUTHORIZED DATASETS\n  ARE THEN SUBJECT TO TESTS FOR INACTIVITY.  A DATASET IS INACTIVE IF IT HAS\n  NOT BEEN ACCESSED IN 'X' DAYS. ('X' IS DETERMINED BY CURRENT INSTALLATION\n  STANDARDS.)  INACTIVE DATASETS WHICH ARE ARCHIVABLE ARE ARCHIVED.\n  NON-ARCHIVABLE DATASETS ARE SCRATCHED.  (SEE 'ARCHIVE DATASET RESTRICTIONS')\n\n<ACTION>\n1 SELECT CHAR(36) CURSOR;\n3 * CHAR(8) INIT('VT$AR1 ');\n4 * CHAR(8) INIT('VT$AR14 ');\n5 * CHAR(8) INIT('        ');\n<END>\n./ ADD NAME=VT$AR14  0105-80015-80016-0758-00023-00025-00000-TYD9801 00\n<FIELDS>\u00ac%!&$#@\n&TUTORIAL ------------------ ASM2 ARCHIVE UTILITY --------------------- TUTORIAL\n&NEXT SELECTION ===>%SELECT                             &\n$\n&                           ----------------------------\n                            | USER INITIATED ARCHIVING |\n                            ----------------------------\n$\n  USER INITIATED ARCHIVING IS DONE TO REMOVE DATASETS FROM DISK WHILE KEEPING A\n  COPY OF THE DATASET AVAILABLE FOR FUTURE PROCESSING.  DATA SUCH AS TEST DATA,\n  YEAR END FILES,  OLD VERSIONS OF LIBRARIES,  ETC.  ARE ALL CANDADATES FOR\n  ARCHIVING.\n\n  A USER ARCHIVE REQUEST IS USUALLY INITIATED THROUGH THE ASM2 TSO COMMAND.\n  THE SPF INTERFACE PROVIDES MENU SUPPORT TO THIS COMMAND.  (SEE 'QUEUEING\n  DATASETS TO BE ARCHIVED' FOR MORE INFORMATION.\n\n<ACTION>\n1 SELECT CHAR(36) CURSOR;\n3 * CHAR(8) INIT('VT$AR1 ');\n4 * CHAR(8) INIT('        ');\n5 * CHAR(8) INIT('        ');\n<END>\n./ ADD NAME=VT$AR2   0104-80015-80021-0730-00030-00015-00000-TYD9801 00\n<FIELDS>\u00ac%!&$#@\n&TUTORIAL ------------------ ASM2 ARCHIVE UTILITY --------------------- TUTORIAL\n&NEXT SELECTION ===>%SELECT                             &\n$\n&                     ------------------------------------\n                      | QUEUEING DATASETS TO BE ARCHIVED |\n                      ------------------------------------\n$\n  A DATASET IS QUEUED FOR LATER ARCHIVE PROCESSING THROUGH THE ASM2 TSO\n  COMMAND.  AN SPF INTERFACE HAS BEEN PROVIDED TO SIMPLIFY USE OF THIS COMMAND.\n\n  A DATASET IS QUEUED FOR ARCHIVING BY SELECTING OPTION&A$ON THE &ASM2 ARCHIVE\n  UTILITY$MENU.  ENTER THE NAME OF THE DATASET TO BE ARCHIVED IN THE&NAME$AREA.\n  NORMAL TSO NAMING CONVENTIONS APPLY.  USE SINGLE QUOTES&(')$FOR FULLY\n  QUALIFIED NAMES.\n\n  YOU MAY SPECIFY THE NUMBER OF DAYS THE ARCHIVED DATASET SHOULD BE KEPT IN\n  THE&RETENTION$FIELD.  NOTE:  DEFAULTS ARE&365 (1 YR.)$FOR &NORMAL\n  ARCHIVES$,AND&1825 (5 YR.)&FOR PERMANENT ARCHIVES$. A RETENTION GREATER\n  THAN&3 YEARS$IS AUTOMATICALLY CONSIDERED PERMANENT.  YOU MAY CLASSIFY AN\n  ARCHIVE REQUEST AS PERMANENT,  REGARDLESS OF THE RETENTION PERIOD,  BY CODING\n  A&Y$ IN THE&PERMANENT ARCHIVE$FIELD.\n\n                         (CONTINUED ON NEXT PAGE)\n<ACTION>\n1 SELECT CHAR(36) CURSOR;\n3 * CHAR(8) INIT('VT$AR  ');\n4 * CHAR(8) INIT('VT$AR3  ');\n5 * CHAR(8) INIT('VT$AR2A ');\n<END>\n./ ADD NAME=VT$AR2A  0103-80016-80016-1330-00025-00030-00000-TYD9801 00\n<FIELDS>\u00ac%!&$#@\n&TUTORIAL ------------------ ASM2 ARCHIVE UTILITY --------------------- TUTORIAL\n&NEXT SELECTION ===>%SELECT                             &\n$\n&                     ------------------------------------\n                      | QUEUEING DATASETS TO BE ARCHIVED |\n                      ------------------------------------\n$\n  WHEN A DATASET IS ARCHIVED TO TAPE IT NORMALLY RETAINS THE SAME NAME.  USE OF\n  THE&QUALIFIER$CAUSES THE DATASET TO BE RENAMED.  THE VALUE SPECIFIED IS\n  INSERTED IMMEDIATELY BEFORE THE LAST NODE OF THE DATASET NAME.  FOR EXAMPLE:\n  IF THE QUALIFIER&SMITH$WERE SPECIFIED WHEN ARCHIVING A DATASET NAMED\n &BCPQT.A1007211.CLAIMS$, THE NEW DATASET WOULD BE&BCPQT.A1007211.SMITH.CLAIMS$\n\n  THE&COMMENT$FIELD IS USED TO PLACE ANY USER INFORMATION, UP TO 30 CHARACTERS\n  LONG,  INTO THE ASM2 CATALOG.  WHEN INQUIRIES ARE MADE ABOUT ARCHIVED\n  DATASETS,  THE COMMENT CAN BE DISPLAYED.\n\n\n<ACTION>\n1 SELECT CHAR(36) CURSOR;\n3 * CHAR(8) INIT('VT$AR2 ');\n4 * CHAR(8) INIT('        ');\n5 * CHAR(8) INIT('        ');\n<END>\n./ ADD NAME=VT$AR3   0104-80015-80021-0730-00027-00015-00000-TYD9801 00\n<FIELDS>\u00ac%!&$#@\n&TUTORIAL ------------------ ASM2 ARCHIVE UTILITY --------------------- TUTORIAL\n&NEXT SELECTION ===>%SELECT                             &\n$\n&                     ------------------------------------\n                      | QUEUEING DATASETS TO BE RESTORED |\n                      ------------------------------------\n$\n  DATASETS ARE QUEUED FOR RELOADING BY SELECTING OPTION&R$ON THE&ASM2 ARCHIVE\n  UTILITY$MENU.  THE NAME OF THE DATASET TO BE RELOADED IS ENTERED IN\n  THE&NAME$FIELD. NORMAL TSO NAMING CONVENTIONS APPLY.  FULLY QUALIFIED DATASET\n  NAMES MUST BE ENCLOSED IN SINGLE QUOTES&(')$.\n\n  IF MULTIPLE ARCHIVED VERSIONS OF A DATASET EXIST,  YOU MAY SPECIFY THE\n  VERSION IN A MANNER SIMILAR TO GENERATION DATASETS.  YOU SPECIFY THE NEXT TO\n  LATEST VERSION BY ADDING A&(-1)$FOLLOWING THE NAME.&(-2)$ SPECIFIES THE ONE\n  BEFORE THAT,  AND SO ON.\n\n  WHEN THE BATCH RELOAD JOB IS COMPLETE,  A MESSAGE WILL BE SENT TO THE TSO\n  USER WHO REQUESTED THE RELOAD.\n\n<ACTION>\n1 SELECT CHAR(36) CURSOR;\n3 * CHAR(8) INIT('VT$AR  ');\n4 * CHAR(8) INIT('VT$AR4  ');\n5 * CHAR(8) INIT('        ');\n<END>\n./ ADD NAME=VT$AR4   0103-80015-80021-0731-00030-00015-00000-TYD9801 00\n<FIELDS>\u00ac%!&$#@\n&TUTORIAL ------------------ ASM2 ARCHIVE UTILITY --------------------- TUTORIAL\n&NEXT SELECTION ===>%SELECT                             &\n$\n&                          -----------------------------\n                           | ARCHIVE DATASET INQUIRIES |\n                           -----------------------------\n$\n  ONCE A DATASET HAS BEEN ARCHIVED BY THE BATCH RUN,  IT IS POSSIBLE TO INQUIRE\n  ABOUT THE STATUS THROUGH THE INQUIRY OPTION&(OPTION BLANK)$.\n\n  AN INQUIRY WITH NOTHING IN THE&NAME$FIELD WILL CAUSE DATASETS BEGINNING WITH\n  THE REQUESTOR'S USERID TO BE LISTED.\n\n  YOU MAY ENTER A PARTIAL OR FULL NAME IN THE&NAME$FIELD. UNLIKE NORMAL TSO\n  DATASET NAMES,   YOUR  USERID  IS&NOT$APPENDED TO  THE  BEGINNING.   ALL\n  DATASETS&BEGINNING$WITH THE CHARACTERS SPECIFIED WILL BE LISTED.\n\n  THE&CYCLE$FIELD IS USED TO LIMIT THE INQUIRIES TO DATASETS ARCHIVED WITHIN\n  THE LAST 'NNN' DAYS.  WHERE 'NNN' IS THE NUMBER ENTERED.\n\n  TYPING A&Y$IN THE&COMMENT$FIELD CAUSES ANY USER COMMENTS ENTERED AT THE TIME\n  THE DATASET WAS ARCHIVED TO BE DISPLAYED.\n\n<ACTION>\n1 SELECT CHAR(36) CURSOR;\n3 * CHAR(8) INIT('VT$AR  ');\n4 * CHAR(8) INIT('        ');\n5 * CHAR(8) INIT('        ');\n<END>\n./ ADD NAME=VT$BK    0101-80015-80015-1715-00030-00030-00000-TYD9801 00\n<FIELDS>\u00ac%!&$#@\n&TUTORIAL ------------------ ASM2 BACKUP UTILITY ---------------------- TUTORIAL\n&NEXT SELECTION ===>%SELECT                             &\n$\n&                      ---------------------------------\n                       | ASM2 BACKUP UTILITY FUNCTIONS |\n                       ---------------------------------\n$\n  THE ASM2 BACKUP UTILITY ALLOWS USERS MAKE USE OF THE ASM2 BACKUP FACILITY.\n  'BACKUP' IS THE PROCESS BY WHICH A DATASET IS COPIED TO AN ASM2 BACKUP TAPE,\n  WHILE THE DISK RESIDENT DATASET IS LEFT UNDISTURBED.   THIS PROCESS ALLOWS\n  DATA TO BE REFERENCED ON DISK,  AND INSURES THE DATASET MAY BE RECONSTRUCTED\n  IF THE DISK  DATASET  IS  DAMAGED.   BACKUP  CAN  OCCUR  AUTOMATICALLY  IN\n  ACCORDANCE WITH INSTALLATION STANDARDS,  OR IT CAN BE EXPLICITLY REQUESTED BY\n  THE USER.  IN EITHER CASE THE BACKED UP DATASET IS RETAINED FOR A SPECIFIED,\n  OR DEFAULT,  TIME DURING WHICH IT MAY BE RESTORED TO DISK VIA A USER REQUEST.\n\n THE FOLLOWING TOPICS ARE PRESENTED IN SEQUENCE, OR MAY BE SELECTED BY NUMBER:\n    &1$- GENERAL BACKUP CONSIDERATIONS\n    &2$- QUEUEING DATASETS TO BE BACKED UP\n    &3$- QUEUEING DATASETS TO BE RESTORED\n    &4$- INQUIRING ABOUT THE STATUS OF BACKED UP DATASETS\n<ACTION>\n1 SELECT CHAR(36) CURSOR;\n2 SELECT CHAR(8) LIST(   1   ,   2   ,   3   ,   4   )\n               RETURN(VT$BK1 ,VT$BK2 ,VT$BK3 ,VT$BK4 );\n3 * CHAR(8) INIT('VTASM2 ');\n4 * CHAR(8) INIT('VT$SM   ');\n5 * CHAR(8) INIT('VT$BK1  ');\n<END>\n./ ADD NAME=VT$BK1   0101-80015-80015-1656-00029-00028-00000-TYD9801 00\n<FIELDS>\u00ac%!&$#@\n&TUTORIAL ------------------ ASM2 BACKUP UTILITY ---------------------- TUTORIAL\n&NEXT SELECTION ===>%SELECT                             &\n$\n&                      ---------------------------------\n                       | GENERAL BACKUP CONSIDERATIONS |\n                       ---------------------------------\n$\n  THE ASM2 BACKUP FACILITY IS USED TO COPY A DATASET FROM DISK TO TAPE.\n  THE DISK DATASET IS LEFT UNDISTURBED.\n\n  ASM2 PROVIDES FACILITIES TO BACK UP DATASETS ,  INQUIRE ABOUT BACKED UP\n  DATASETS, AND TO RESTORE BACKED UP DATASETS.   THESE  FUNCTIONS MAY BE\n  REQUESTED  FROM A TSO TERMINAL.   THE DATASET IS NOT BACKED UP OR RESTORED AT\n  THE TIME THE REQUEST IS ENTERED.  THE REQUEST IS PLACED IN A QUEUE TO BE\n  PROCESSED WHEN A BATCH BACKUP OR RESTORE RUN IS SUBMITTED.\n\n THE FOLLOWING TOPICS ARE PRESENTED IN SEQUENCE, OR MAY BE SELECTED BY NUMBER:\n    &1$- BACK UP DATASET RESTRICTIONS\n    &2$- SYSTEM INITIATED INCREMENTAL BACKUP\n    &3$- USER INITIATED BACKUP\n<ACTION>\n1 SELECT CHAR(36) CURSOR;\n2 SELECT CHAR(8) LIST(   1   ,   2   ,   3   )\n               RETURN(VT$BK11,VT$BK12,VT$BK13);\n3 * CHAR(8) INIT('VT$BK  ');\n4 * CHAR(8) INIT('VT$BK2  ');\n5 * CHAR(8) INIT('VT$BK11 ');\n<END>\n./ ADD NAME=VT$BK11  0104-80015-80017-1606-00027-00021-00000-TYD9801 00\n<FIELDS>\u00ac%!&$#@\n&TUTORIAL ------------------ ASM2 BACK UP UTILITY --------------------- TUTORIAL\n&NEXT SELECTION ===>%SELECT                             &\n$\n&                      --------------------------------\n                       | BACK UP DATASET RESTRICTIONS |\n                       --------------------------------\n$\n  THE ASM2 BACK UP FACILITY CAN BE USED ON ALMOST ALL TYPES OF DATASETS.\n\n  CERTAIN TYPES OF DATASETS ARE NOT NORMALLY BACKED UP.\n    1. MULTI-VOLUME DATASETS\n    2. DATSETS WITH INVALID DCB INFORMATION.\n    3. EMPTY DATASETS (CAN BE ARCHIVED WITH PARAMETER OVERRIDE)\n    4. GDG DATASETS (SPECIAL GDG HANDLING IS AVAILABLE)\n\n  VSAM CATALOGS,  PAGE SPACES,  ALTERNATE INDEXES,  DATA COMPONENTS, AND INDEX\n  COMPONENTS CANNOT BE BACKED UP.  VSAM CLUSERS CAN BE BACKED UP.\n\n  ASM2 USES THE 'EXPORT TEMPORARY' FUNCTION OF IDCAMS TO BACK UP THE CLUSTER.\n\n<ACTION>\n1 SELECT CHAR(36) CURSOR;\n3 * CHAR(8) INIT('VT$BK1 ');\n4 * CHAR(8) INIT('VT$BK12 ');\n5 * CHAR(8) INIT('        ');\n<END>\n./ ADD NAME=VT$BK12  0105-80015-80016-1600-00026-00025-00000-TYD9801 00\n<FIELDS>\u00ac%!&$#@\n&TUTORIAL ------------------ ASM2 BACK UP UTILITY --------------------- TUTORIAL\n&NEXT SELECTION ===>%SELECT                             &\n$\n&                  ----------------------------------------\n                   | SYSTEM INITIATED INCREMENTAL BACK UP |\n                   ----------------------------------------\n$\n  IN SYSTEM INITIATED BACK UP,   ONLINE DISK VOLUMES ARE SCANNED FOR DATASETS\n  WHICH HAVED BEEN OPENED FOR UPDATE SINCE THE LAST INCREMENTAL BACKUP FOR THAT\n  VOLUME.  THESE DATASETS ARE AUTOMATICALLY BACKUP.\n\n  THIS METHOD INSURES ALL DATASETS (ON VOLUMES PROCESSED BY INCREMENTAL BACKUP)\n  ARE BACKED UP IF THEY HAVE BEEN CHANGED SINCE THE LAST INCREMENTAL BACKUP.\n  DATASETS NOT CHANGED NEED NOT BE BACKED UP SINCE A PREVIOUS BACKUP ALREADY\n  EXISTS.\n\n  NO ACTION IS NECESSARY BY THE USER OTHER THAN INSURING HIS DATASETS RESIDE ON\n  AN 'INCREMENATLLY BACKED UP' VOLUME.\n\n<ACTION>\n1 SELECT CHAR(36) CURSOR;\n3 * CHAR(8) INIT('VT$BK1 ');\n4 * CHAR(8) INIT('VT$BK13 ');\n5 * CHAR(8) INIT('        ');\n<END>\n./ ADD NAME=VT$BK13  0106-80015-80016-1426-00019-00025-00000-TYD9801 00\n<FIELDS>\u00ac%!&$#@\n&TUTORIAL ------------------ ASM2 BACK UP UTILITY --------------------- TUTORIAL\n&NEXT SELECTION ===>%SELECT                             &\n$\n&                            --------------------------\n                             | USER INITIATED BACK UP |\n                             --------------------------\n$\n  USER INITIATED BACK UP IS AVAILABLE TO SUPPLEMENT THE SYSTEM INITIATED BACK\n  UP OF ASM2.  THE USER CAN EXPLICITLY REQUEST BACK UP OF HIS DATASETS VIA A\n  TSO COMMAND.  THE SPF INTERFACE PROVIDES MENU SUPPORT TO THIS COMMAND.  (SEE\n  'QUEUEING DATASETS TO BE BACKED UP' FOR MORE INFORMATION.\n\n<ACTION>\n1 SELECT CHAR(36) CURSOR;\n3 * CHAR(8) INIT('VT$BK1 ');\n4 * CHAR(8) INIT('        ');\n5 * CHAR(8) INIT('        ');\n<END>\n./ ADD NAME=VT$BK2   0107-80015-80021-0731-00027-00015-00000-TYD9801 00\n<FIELDS>\u00ac%!&$#@\n&TUTORIAL ------------------ ASM2 BACK UP UTILITY --------------------- TUTORIAL\n&NEXT SELECTION ===>%SELECT                             &\n$\n&                     -------------------------------------\n                      | QUEUEING DATASETS TO BE BACKED UP |\n                      -------------------------------------\n$\n  A DATASET IS QUEUED FOR LATER BACK UP PROCESSING THROUGH THE ASM2 TSO\n  COMMAND.  AN SPF INTERFACE HAS BEEN PROVIDED TO SIMPLIFY USE OF THIS COMMAND.\n\n  A DATASET IS QUEUED FOR BACK UP BY SELECTING OPTION&B$ON THE &ASM2 BACK UP\n  UTILITY$MENU.  ENTER THE NAME OF THE DATASET TO BE BACKED UP IN THE&NAME$AREA.\n  NORMAL TSO NAMING CONVENTIONS APPLY.  USE SINGLE QUOTES&(')$FOR FULLY\n  QUALIFIED NAMES.\n\n  YOU MAY SPECIFY THE NUMBER OF DAYS THE BACKED UP DATASET SHOULD BE KEPT IN\n  THE&RETENTION$FIELD.  NOTE:  DEFAULT (AND MAXIMUM) IS&90$.  NOTE THAT THIS\n  MAXIMUM DOES NOT AFFECT INCREMENTALLY BACKED UP DATASET RETENTIONS.\n\n                         (CONTINUED ON NEXT PAGE)\n<ACTION>\n1 SELECT CHAR(36) CURSOR;\n3 * CHAR(8) INIT('VT$BK  ');\n4 * CHAR(8) INIT('VT$BK3  ');\n5 * CHAR(8) INIT('VT$BK2A ');\n<END>\n./ ADD NAME=VT$BK2A  0105-80016-80016-1603-00024-00030-00000-TYD9801 00\n<FIELDS>\u00ac%!&$#@\n&TUTORIAL ------------------ ASM2 BACK UP UTILITY --------------------- TUTORIAL\n&NEXT SELECTION ===>%SELECT                             &\n$\n&                     -------------------------------------\n                      | QUEUEING DATASETS TO BE BACKED UP |\n                      -------------------------------------\n$\n  WHEN A DATASET IS BACKED UP TO TAPE IT NORMALLY RETAINS THE SAME NAME.  USE\n  OF THE&QUALIFIER$CAUSES THE DATASET TO BE RENAMED.  THE VALUE SPECIFIED IS\n  INSERTED IMMEDIATELY BEFORE THE LAST NODE OF THE DATASET NAME.  FOR EXAMPLE:\n  IF THE QUALIFIER&SMITH$WERE SPECIFIED WHEN BACKING UP A DATASET NAMED\n $BCPQT.A1007211.CLAIMS$, THE NEW DATASET WOULD BE&BCPQT.A1007211.SMITH.CLAIMS$\n\n  THE&COMMENT$FIELD IS USED TO PLACE ANY USER INFORMATION, UP TO 30 CHARACTERS\n  LONG,  INTO THE ASM2 CATALOG.  WHEN INQUIRIES ARE MADE ABOUT BACKED UP\n  DATASETS,  THE COMMENT CAN BE DISPLAYED.\n\n<ACTION>\n1 SELECT CHAR(36) CURSOR;\n3 * CHAR(8) INIT('VT$BK2 ');\n4 * CHAR(8) INIT('        ');\n5 * CHAR(8) INIT('        ');\n<END>\n./ ADD NAME=VT$BK3   0106-80015-80021-0731-00027-00015-00000-TYD9801 00\n<FIELDS>\u00ac%!&$#@\n&TUTORIAL ------------------ ASM2 BACK UP UTILITY --------------------- TUTORIAL\n&NEXT SELECTION ===>%SELECT                             &\n$\n&                     ------------------------------------\n                      | QUEUEING DATASETS TO BE RESTORED |\n                      ------------------------------------\n$\n  DATASETS ARE QUEUED FOR RELOADING BY SELECTING OPTION&R$ON THE&ASM2 BACK UP\n  UTILITY$MENU.  THE NAME OF THE DATASET TO BE RELOADED IS ENTERED IN\n  THE&NAME$FIELD. NORMAL TSO NAMING CONVENTIONS APPLY.  FULLY QUALIFIED DATASET\n  NAMES MUST BE ENCLOSED IN SINGLE QUOTES&(')$.\n\n  IF MULTIPLE BACK UP VERSIONS EXIST,  AND YOU DO NOT WANT TO RELOAD THE LATEST\n  VERSION,  YOU MAY SPECIFY THE RELATIVE VERSION IN MUCH THE SAME WAY AS\n  GENERATION DATASETS. YOU SPECIFY THE NEXT TO LATEST VERSION BY ADDING&(-1)$\n  FOLLOWING THE NAME. &(-2)$SPECIFIES THE ONE BEFORE THAT,  AND SO ON.\n\n  WHEN THE BATCH RELOAD JOB IS COMPLETE,  A MESSAGE WILL BE SENT TO THE TSO\n  USER WHO REQUESTED THE RELOAD.\n\n<ACTION>\n1 SELECT CHAR(36) CURSOR;\n3 * CHAR(8) INIT('VT$BK  ');\n4 * CHAR(8) INIT('VT$BK4  ');\n5 * CHAR(8) INIT('        ');\n<END>\n./ ADD NAME=VT$BK4   0104-80015-80021-0732-00030-00015-00000-TYD9801 00\n<FIELDS>\u00ac%!&$#@\n&TUTORIAL ------------------ ASM2 BACK UP UTILITY --------------------- TUTORIAL\n&NEXT SELECTION ===>%SELECT                             &\n$\n&                          -----------------------------\n                           | BACK UP DATASET INQUIRIES |\n                           -----------------------------\n$\n  ONCE A DATASET HAS BEEN BACKED UP BY THE BATCH RUN,  IT IS POSSIBLE TO\n  INQUIRE ABOUT THE STATUS THROUGH THE INQUIRY OPTION&(OPTION BLANK)$.\n\n  AN INQUIRY WITH NOTHING IN THE&NAME$FIELD WILL CAUSE DATASETS BEGINNING WITH\n  THE REQUESTOR'S USERID TO BE LISTED.\n\n  YOU MAY ENTER A PARTIAL OR FULL NAME IN THE&NAME$FIELD. UNLIKE NORMAL TSO\n  DATASET NAMES,   YOUR  USERID  IS&NOT$APPENDED TO  THE BEGINNING.   ALL\n  DATASETS&BEGINNING$WITH THE CHARACTERS SPECIFIED WILL BE LISTED.\n\n  THE&CYCLE$FIELD IS USED TO LIMIT THE INQUIRIES TO DATASETS BACKED UP WITHIN\n  THE LAST 'NNN' DAYS.  WHERE 'NNN' IS THE NUMBER ENTERED.\n\n  TYPING A&Y$IN THE&COMMENT$FIELD CAUSES ANY USER COMMENTS ENTERED AT THE TIME\n  THE DATASET WAS BACKED UP TO BE DISPLAYED.\n\n<ACTION>\n1 SELECT CHAR(36) CURSOR;\n3 * CHAR(8) INIT('VT$BK  ');\n4 * CHAR(8) INIT('        ');\n5 * CHAR(8) INIT('        ');\n<END>\n./ ADD NAME=VT$SM    0102-80015-80016-1616-00031-00030-00000-TYD9801 00\n<FIELDS>\u00ac%!&$#@\n&TUTORIAL -------------- ASM2 SPACE MANAGEMENT UTILITY ---------------- TUTORIAL\n&NEXT SELECTION ===>%SELECT                             &\n$\n&                 -------------------------------------------\n                  | ASM2 SPACE MANAGEMENT UTILITY FUNCTIONS |\n                  -------------------------------------------\n$\n  THE ASM2 DISK SPACE MANAGEMENT UTILITY ALLOWS USERS MAKE USE OF THE ASM2\n  UNIQUE FACILITIES TO MANAGE THEIR OWN DATASETS EFFICIENTLY.  THE USER IS ABLE\n  TO EASILY DETERMINE BOTH THE AMOUNT OF SPACE HIS DATASETS OCCUPY,  AND THE\n  FREQUENCY WITH WHICH THE DATASET IS USED.  WITH THIS INFORMATION,  ASM2\n  PROVIDES FACILITIES TO COMPRESS DATASETS AND/OR TO RELEASE UNUSED SPACE FROM\n  OVER-ALLOCATED DATASETS.  OBSOLETE OR INFREQUENTLY USED DATASETS CAN BE\n  DELETED OR ARCHIVED TO TAPE.\n\n THE FOLLOWING TOPICS ARE PRESENTED IN SEQUENCE, OR MAY BE SELECTED BY NUMBER:\n    &1$- GENERAL SPACE MANAGEMENT CONSIDERATIONS\n    &2$- DISPLAYING DISK DATASET USAGE INFORMATION\n    &3$- DISPLAYING DISK DATASET SPACE INFORMATION\n    &4$- COMPRESSING PARTITIONED DATASETS\n    &5$- RELEASING UNUSED SPACE FROM DATASETS\n    &6$- RESETTING END-OF-FILE ON SEQUENTIAL DATASETS\n<ACTION>\n1 SELECT CHAR(36) CURSOR;\n2 SELECT CHAR(8) LIST(   1   ,   2   ,   3   ,   4   ,   5   ,   6   )\n               RETURN(VT$SM1 ,VT$SM2 ,VT$SM3 ,VT$SM4 ,VT$SM5 ,VT$SM6 );\n3 * CHAR(8) INIT('VTASM2 ');\n4 * CHAR(8) INIT('VTASM2  ');\n5 * CHAR(8) INIT('VT$SM1  ');\n<END>\n./ ADD NAME=VT$SM1   0102-80015-80105-1514-00027-00027-00000-$CSG05  00\n<FIELDS>\u00ac%!&$#@\n&TUTORIAL -------------- ASM2 SPACE MANAGEMENT UTILITY ---------------- TUTORIAL\n&NEXT SELECTION ===>%SELECT                             &\n$\n&               ------------------------------------------------\n                | ASM2 SPACE MANAGEMENT GENERAL CONSIDERATIONS |\n                ------------------------------------------------\n$\n  THERE ARE TWO ITEMS REQUIRED TO BE ABLE TO MANAGE YOUR DISK DATASETS.  FIRST,\n  YOU MUST BE ABLE TO OBTAIN INFORMATION CONCERNING THE USE OF DISK SPACE.\n  SECONDLY YOU MUST BE ABLE TO CHANGE THE WAY IN WHICH THE DISK SPACE IS USED.\n\n  THE ASM2 SPACE MANAGEMENT UTILITY SEARCHES THE SYSTEM CATALOGS TO FIND ALL\n  THE DATASETS MATCHING THE CRITERIA WHICH YOU SPECIFY.  THE DISK VOLUMES ARE\n  THEN SEARCHED TO OBTAIN SPECIFIC INFORMATION ABOUT THE DATASETS. IF YOU SO\n  SPECIFY,  THE SPACE ALLOCATIONS CAN BE CHANGED TO MAKE MORE EFFICIENT USE OF\n  THE SPACE AVAILABLE.\n\n  VSAM DATASETS ARE NOT CURRENTLY SUPPORTED BY THE SPACE MANAGEMENT\n  UTILITY.\n\n<ACTION>\n1 SELECT CHAR(36) CURSOR;\n3 * CHAR(8) INIT('VT$SM  ');\n4 * CHAR(8) INIT('VT$SM2  ');\n5 * CHAR(8) INIT('        ');\n<END>\n./ ADD NAME=VT$SM2   0101-80016-80016-1622-00028-00028-00000-TYD9801 00\n<FIELDS>\u00ac%!&$#@\n&TUTORIAL --------------- ASM2 SPACE MANAGEMENT UTILITY   ------------- TUTORIAL\n&NEXT SELECTION ===>%SELECT                             &\n$\n&                   ---------------------------------------------\n                    | DISPLAYING DISK USAGE DATASET INFORMATION |\n                    ---------------------------------------------\n$\n  TO DISPLAY DISK DATASET USAGE INFORMATION A&U$IS ENTERED IN THE&SELECT OPTION\n $FIELD.\n\n  IF NO OTHER FIELDS ARE ENTERED,  ALL DISK DATASETS BEGINNING WITH THE\n  REQUESTOR'S USERID ARE DISPLAYED.\n\n  YOU MAY ALSO SELECT A SPECIFIC DATASET BY ENTERING DATASET NAME IN\n  THE&NAME$FIELD. (NORMAL TSO NAMING CONVENTIONS APPLY.  ENCLOSE FULLY\n  QUALIFIED DATASET NAMES IN SINGLE QUOTES)\n\n  BY SPECIFYING AN&L$IN THE&TYPE OF NAME$FIELD,  AND ONE OR MORE INDEX LEVELS\n  IN THE&NAME$FIELD, YOU CAN DISPLAY INFORMATION FOR ANY DISK DATASETS\n  BEGINNING WITH THE SPECIFIED INDEX LEVEL(S).\n\n<ACTION>\n1 SELECT CHAR(36) CURSOR;\n3 * CHAR(8) INIT('VT$SM  ');\n4 * CHAR(8) INIT('VT$SM3  ');\n5 * CHAR(8) INIT('        ');\n<END>\n./ ADD NAME=VT$SM3   0104-80015-80016-1618-00028-00015-00000-TYD9801 00\n<FIELDS>\u00ac%!&$#@\n&TUTORIAL --------------- ASM2 SPACE MANAGEMENT UTILITY   ------------- TUTORIAL\n&NEXT SELECTION ===>%SELECT                             &\n$\n&                     ---------------------------------------\n                      | DISPLAYING DISK DATASET INFORMATION |\n                      ---------------------------------------\n$\n  TO DISPLAY DISK DATASET SPACE INFORMATION A&BLANK$IS ENTERED IN THE&SELECT\n  OPTION$FIELD.\n\n  IF NO OTHER FIELDS ARE ENTERED,  ALL DISK DATASETS BEGINNING WITH THE\n  REQUESTOR'S USERID ARE DISPLAYED.\n\n  YOU MAY ALSO SELECT A SPECIFIC DATASET BY ENTERING DATASET NAME IN\n  THE&NAME$FIELD. (NORMAL TSO NAMING CONVENTIONS APPLY.  ENCLOSE FULLY\n  QUALIFIED DATASET NAMES IN SINGLE QUOTES)\n\n  BY SPECIFYING AN&L$IN THE&TYPE OF NAME$FIELD,  AND ONE OR MORE INDEX LEVELS\n  IN THE&NAME$FIELD, YOU CAN DISPLAY INFORMATION FOR ANY DISK DATASETS\n  BEGINNING WITH THE SPECIFIED INDEX LEVEL(S).\n\n<ACTION>\n1 SELECT CHAR(36) CURSOR;\n3 * CHAR(8) INIT('VT$SM  ');\n4 * CHAR(8) INIT('VT$SM4  ');\n5 * CHAR(8) INIT('        ');\n<END>\n./ ADD NAME=VT$SM4   0103-80015-80018-1246-00030-00015-00000-TYD9801 00\n<FIELDS>\u00ac%!&$#@\n&TUTORIAL --------------- ASM2 SPACE MANAGEMENT UTILITY   ------------- TUTORIAL\n&NEXT SELECTION ===>%SELECT                             &\n$\n&                     ------------------------------------\n                      | COMPRESSING PARTITIONED DATASETS |\n                      ------------------------------------\n$\n  A PARTITIONED DATASET MAY BE COMPRESSED IN TWO WAYS.\n\n  THE COMPRESS OPTION&(C)$,  CAUSES THE NAMED DATASET TO BE COMPRESSED WITHOUT\n  RELEASING UNUSED SPACE.  THE RELEASE OPTION&(R)$, CAN ALSO CAUSE P.D.S\n  COMPRESSION IF A&Y$IS ENTERED IN THE&COMPRESS$FIELD.  (SEE 'RELEASING UNUSED\n  SPACE').\n\n  WHEN A DATASET IS COMPRESSED BY EITHER METHOD,  YOU HAVE THE OPTION OF FIRST\n  MAKING A BACK UP COPY OF THE DATASET PRIOR TO THE COMPRESS.  THIS OPTION IS\n  SELECTED BY CODING A&Y$IN THE&BACKUP$FIELD.  WHEN THIS IS DONE,  A COPY OF\n  THE DATASET MADE UNDER A NEW NAME.  THE NEW NAME IS THE SAME AS THE OLD NAME,\n  BUT AN INDEX LEVEL NAMED&BKUP$ IS INSERTED IMMEDIATELY BEFORE THE LAST\n  QUALIFIER. FOR EXAMPLE:\n          &TBD95XX.EDIT.DATA$ IS BACKED UP IN &TBD95XX.EDIT.BKUP.DATA$\n  THE BACK UP DATASET IS DELETED UPON SUCCESSFULL COMPLETION OF THE COMPRESS.\n\n<ACTION>\n1 SELECT CHAR(36) CURSOR;\n3 * CHAR(8) INIT('VT$SM  ');\n4 * CHAR(8) INIT('VT$SM5  ');\n5 * CHAR(8) INIT('        ');\n<END>\n./ ADD NAME=VT$SM5   0104-80015-80016-1624-00029-00015-00000-TYD9801 00\n<FIELDS>\u00ac%!&$#@\n&TUTORIAL --------------- ASM2 SPACE MANAGEMENT UTILITY   ------------- TUTORIAL\n&NEXT SELECTION ===>%SELECT                             &\n$\n&                             --------------------------\n                              | RELEASING UNUSED SPACE |\n                              --------------------------\n$\n  THE RELEASE OPTION&(R)$IS USED TO RELEASE UNUSED SPACE FROM SEQUENTIAL OR\n  PARTIONED DATASETS.  YOU MAY ALSO SPECIFY A NUMBER OF TRACKS OF UNUSED SPACE\n  TO BE SAVED BY ENTERING THE NUMBER IN THE&SAVE$FIELD.  EVEN IF YOU MAKE A\n  MISTAKE IN THE 'SAVE' AMOUNT ASM2 WILL NEVER RELEASE USED SPACE.  IF THE\n  DATASET IS ALLOCATED IN CYLINDERS, THE 'SAVE' AMOUNT IS ROUNDED UP TO THE\n  NEAREST CYLINDER.\n\n  THE NAME OF THE DATASET FOR WHICH SPACE IS TO BE RELEASED, IS ENTERED IN\n  THE&NAME$FIELD.  (NORMAL TSO NAMING CONVENTIONS APPLY.  ENCLOSE FULLY\n  QUALIFIED NAMES IN SINGLE QUOTES.)\n\n  IN CONJUNCTION WITH THE RELEASE OPTION,  A P.D.S CAN ALSO\n  BE COMPRESSED PRIOR TO SPACE RELEASE.  (SEE 'COMPRESSING\n  PARTITIONED DATASETS').\n\n<ACTION>\n1 SELECT CHAR(36) CURSOR;\n3 * CHAR(8) INIT('VT$SM  ');\n4 * CHAR(8) INIT('VT$SM6  ');\n5 * CHAR(8) INIT('        ');\n<END>\n./ ADD NAME=VT$SM6   0102-80015-80016-1625-00022-00015-00000-TYD9801 00\n<FIELDS>\u00ac%!&$#@\n&TUTORIAL --------------- ASM2 SPACE MANAGEMENT UTILITY   ------------- TUTORIAL\n&NEXT SELECTION ===>%SELECT                             &\n$\n&               ------------------------------------------------\n                | RESETTING END-OF FILE ON SEQUENTIAL DATASETS |\n                ------------------------------------------------\n$\n  OPTION&E$CAN BE USED TO WRITE AN END-OF-FILE AT THE BEGINNING OF A SEQUENTIAL\n  DATASET.\n\n  THE DATASET NAME TO BE RESET IS ENTERED IN THE&NAME$FIELD.  (NORMAL TSO\n  NAMING CONVENTIONS APPLY.  ENCLOSE FULLY QUALIFIED NAMES IN SINGLE QUOTES.)\n\n  IF A NON-SEQUENTIAL DATASET IS SPECIFIED,  THE RESET REQUEST IS IGNORED.\n\n<ACTION>\n1 SELECT CHAR(36) CURSOR;\n3 * CHAR(8) INIT('VT$SM  ');\n4 * CHAR(8) INIT('        ');\n5 * CHAR(8) INIT('        ');\n<END>\n./ ADD NAME=VTASM2   0103-80015-80015-1058-00033-00030-00000-TYD9801 00\n<FIELDS>\u00ac%!&$#@\n&TUTORIAL ---------- ASM2 DISK SPACE MANAGEMENT UTILITIES ------------- TUTORIAL\n&NEXT SELECTION ===>%SELECT                             &\n$\n&                  ----------------------------------------\n                   | ASM2 UTILITIES - GENERAL INFORMATION |\n                   ----------------------------------------\n$\n  THE ASM2 DISK MANAGEMENT SYSTEM FROM THE CAMBRIDGE SYSTEMS GROUP IS INTENDED\n  TO SIMPLIFY THE MANAGEMENT OF DISK DATA IN MEDIUM AND LARGE SYSTEMS USING ANY\n  OS OPERATING SYSTEM.   UTILITIES ARE PROVIDED TO ALLOW INSTALLATIONS TO MORE\n  EASILY UTILIZE ALL THEIR STORAGE MEDIA.   THIS INCLUDES DISK,  TAPE, AND MASS\n  STORAGE SYSTEMS.   ASM2  ALLOWS  EFFICIENT  AND  ECONOMICAL  USE  OF THE MOST\n  EFFECTIVE MEDIUM. DISK IS USED FOR HIGH USE, QUICK ACCESS TO RELATIVELY SMALL\n  AMOUNTS OF DATA.   MASS STORAGE  OR  TAPE  IS  UTILIZED FOR LOW USE AND LARGE\n  VOLUME DATASETS.\n\n  SEVERAL OF THE UTILITIES OF ASM2 ARE USER ORIENTED.  THESE ALLOW THE USER TO\n  MAINTAIN BETTER CONTROL OF HIS DATA  ,  WHILE  PERMITTING  A  HIGH DEGREE OF\n  TOTAL SYSTEM EFFICIENCY.\n\n THE FOLLOWING TOPICS ARE PRESENTED IN SEQUENCE, OR MAY BE SELECTED BY NUMBER:\n    &1$- ARCHIVE UTILITY FUNCTIONS\n    &2$- BACK UP UTILITY FUNCTIONS\n    &3$- SPACE MANAGEMENT UTILITY FUNCTIONS\n<ACTION>\n1 SELECT CHAR(36) CURSOR;\n2 SELECT CHAR(8) LIST(   1   ,   2   ,   3   )\n               RETURN(VT$AR  ,VT$BK  ,VT$SM  );\n3 * CHAR(8) INIT('       ');\n4 * CHAR(8) INIT('        ');\n5 * CHAR(8) INIT('VT$AR   ');\n<END>\n./ ADD NAME=VTJTIP   0100-79269-79269-1311-00024-00024-00000-TYD9835 00\n<FIELDS>\u00ac%!&$#@\n&TUTORIAL ---------------------- JTIP UTILITY ------------------------- TUTORIAL\n&NEXT SELECTION ===>%SELECT                             &\n$\n&                    ----------------------------------\n                     |         JTIP   UTILITY         |\n                     ----------------------------------\n$\n\n THE FOLLOWING TOPICS ARE PRESENTED IN SEQUENCE, OR MAY BE SELECTED BY NUMBER:\n    &1$- LISTING JOB NAMES/IDS VIA THE JTIP SHOW COMMAND\n    &2$- LISTING A JOBS FETCH DATASET INFORMATION\n    &3$- DELETING A JOBS OUTPUT\n    &4$- REQUEUEING JOB OUTPUT FROM FETCH QUEUE TO SYSOUT QUEUE\n    &5$- DISPLAYING JOB OUTPUT AT THE TERMINAL\n    &6$- COPYING OUTPUT TO TEMPORARY DATASET AND BROWSE\n<ACTION>\n1 SELECT CHAR(36) CURSOR;\n2 SELECT CHAR(8) LIST(   1   ,   2   ,   3   ,   4   ,   5   ,   6   )\n               RETURN(VTJTIP1,VTJTIP2,VTJTIP3,VTJTIP4,VTJTIP5,VTJTIP6);\n3 * CHAR(8) INIT('VTJTIP ');\n4 * CHAR(8) INIT('        ');\n5 * CHAR(8) INIT('VTJTIP1 ');\n<END>\n./ ADD NAME=VTJTIPB  0100-79269-79269-1311-00020-00020-00000-TYD9835 00\n&TUTORIAL ------------------ JTIP UTILITY - DISPLAY ------------------- TUTORIAL\n&NEXT SELECTION ===>%SELECT                             &\n$\n$  THE&DISPLAY FETCH SYSOUT JOB$FUNCTION CAUSED A LISTING FOR THE SPECIFIED JOB\n   TO BE DISPLAYED AT THE TERMINAL.  THE LISTING WAS PRODUCED VIA THE TSO FETCH\n   COMMAND.\n\n   THE SPF&BROWSE$FUNCTION WAS AUTOMATICALLY INVOKED TO DISPLAY THE\n   JOB LISTING, AND ALL BROWSE OPTIONS MAY BE USED, INCLUDING\n  &SCROLLING$AND THE&FIND$COMMAND.  USE THE&END$KEY TO TERMINATE THE\n   BROWSE FUNCTION AND RETURN TO THE JTIP UTILITY MENU.\n\n   IF YOU PRESS THE&ENTER$KEY NOW YOU WILL ENTER THE BROWSE TUTORIAL.\n<ACTION>\n1 SELECT CHAR(36) CURSOR;\n2 SELECT CHAR(8) LIST(' ') RETURN(' ');\n3 * CHAR(8) INIT('TTUTOR  ');\n4 * CHAR(8) INIT('        ');\n5 * CHAR(8) INIT('TUB     ');\n<END>\n./ ADD NAME=VTJTIP1  0100-79269-79269-1311-00024-00024-00000-TYD9835 00\n&TUTORIAL ----------- JTIP UTILITY - SHOW JOB NAMES / ID'S ------------ TUTORIAL\n&NEXT SELECTION ===>%SELECT                             &\n$\n   THE&SHOW JOBS$FUNCTION ( OPTION&L$) IS USED TO DISPLAY THE STATUS OF\n   A JOB OR JOBS.\n\n   FILL IN THE FOLLOWING FIELDS OF THE JTIP UTILITY MENU:\n       - ENTER&L$IN THE SELECT OPTION FIELD.\n\n   THE FOLLOWING RULES APPLY FOR THE&JOBNAME/JOBID$PARAMETER WHEN USED\n   WITH THE&L$OPTION:\n\n       -&JOBNAME/ID$= BLANK - ALL JOBS THAT HAVE JOB NAMES BEGINNING WITH\n                              THE USER'S ID WILL BE DISPLAYED.\n       -&JOBNAME$   = USERID + ONE CHARACTER - SAME AS BLANK.\n       -&JOBNAME/ID$= ANYTHING ELSE - ONLY THE NAMED JOB WILL BE DISPLAYED.\n\n<ACTION>\n1 SELECT CHAR(36) CURSOR;\n2 SELECT CHAR(8) LIST(' ') RETURN(' ');\n3 * CHAR(8) INIT('VTJTIP  ');\n4 * CHAR(8) INIT('VTJTIP2 ');\n5 * CHAR(8) INIT('        ');\n<END>\n./ ADD NAME=VTJTIP2  0100-79269-79269-1311-00017-00017-00000-TYD9835 00\n&TUTORIAL ------------- JTIP UTILITY - SHOW FETCH INFO --------------  TUTORIAL\n&NEXT SELECTION ===>%SELECT                             &\n$\n   THE&SHOW FETCH$FUNCTION ( OPTION&S$) IS USED TO DISPLAY THE NUMBER OF\n   LINES, COPIES, AND FORM TYPE FOR EACH SYSOUT DATASET OF A JOB IN THE\n  &FETCH$QUEUE.\n\n   FILL IN THE FOLLOWING FIELDS OF THE JTIP UTILITY MENU:\n      - ENTER&S$IN THE SELECT OPTION FIELD.\n      - ENTER A&JOBNAME$OR&JOBID.$ ONE OR THE OTHER MUST BE SPECIFIED.\n<ACTION>\n1 SELECT CHAR(36) CURSOR;\n2 SELECT CHAR(8) LIST(' ') RETURN(' ');\n3 * CHAR(8) INIT('VTJTIP  ');\n4 * CHAR(8) INIT('VTJTIP3 ');\n5 * CHAR(8) INIT('        ');\n<END>\n./ ADD NAME=VTJTIP3  0100-79269-79269-1311-00016-00016-00000-TYD9835 00\n&TUTORIAL ------------ JTIP UTILITY - DELETE JOB OUTPUT -------------- TUTORIAL\n&NEXT SELECTION ===>%SELECT                             &\n$\n   THE&DELETE$FUNCTION ( OPTION&D$) IS USED TO DELETE THE OUTPUT OF A\n   JOB IN THE&FETCH$QUEUE.\n\n   FILL IN THE FOLLOWING FIELDS OF THE JTIP UTILITY MENU:\n      - ENTER&D$IN THE SELECT OPTION FIELD.\n      - ENTER A&JOBNAME$OR&JOBID.$ ONE OR THE OTHER MUST BE SPECIFIED.\n<ACTION>\n1 SELECT CHAR(36) CURSOR;\n2 SELECT CHAR(8) LIST(' ') RETURN(' ');\n3 * CHAR(8) INIT('VTJTIP  ');\n4 * CHAR(8) INIT('VTJTIP4 ');\n5 * CHAR(8) INIT('        ');\n<END>\n./ ADD NAME=VTJTIP4  0100-79269-79269-1311-00018-00018-00000-TYD9835 00\n&TUTORIAL ------------- JTIP UTILITY - ROUTE JOB OUTPUT -------------- TUTORIAL\n&NEXT SELECTION ===>%SELECT                             &\n$\n   THE&ROUTE$FUNCTION ( OPTION&R$) IS USED TO ROUTE THE OUTPUT OF A JOB\n   IN THE&FETCH$QUEUE TO THE SYSOUT QUEUE FOR NORMAL OUTPUT PROCESSING.\n   ALL DATASETS FOR THE JOB WILL BE PRINTED TOGETHER, I.E., BETWEEN TWO\n   BANNER PAGES.\n\n   FILL IN THE FOLLOWING FIELDS OF THE JTIP UTILITY MENU:\n      - ENTER&R$IN THE SELECT OPTION FIELD.\n      - ENTER A&JOBNAME$OR&JOBID.$ ONE OR THE OTHER MUST BE SPECIFIED.\n<ACTION>\n1 SELECT CHAR(36) CURSOR;\n2 SELECT CHAR(8) LIST(' ') RETURN(' ');\n3 * CHAR(8) INIT('VTJTIP  ');\n4 * CHAR(8) INIT('VTJTIP5 ');\n5 * CHAR(8) INIT('        ');\n<END>\n./ ADD NAME=VTJTIP5  0100-79269-79269-1311-00026-00026-00000-TYD9835 00\n&TUTORIAL ------------ JTIP UTILITY - DISPLAY JOB OUTPUT ------------- TUTORIAL\n&NEXT SELECTION ===>%SELECT                             &\n$\n   THE&DISPLAY$FUNCTION ( OPTION&O$) IS USED TO VIEW THE OUTPUT OF A JOB\n   IN THE&FETCH$QUEUE AT THE TERMINAL. COLUMN NUMBERS MAY BE SPECIFIED.\n\n   FILL IN THE FOLLOWING FIELDS OF THE JTIP UTILITY MENU:\n      - ENTER&O$IN THE SELECT OPTION FIELD.\n      - ENTER A&JOBNAME$OR&JOBID.$ ONE OR THE OTHER MUST BE SPECIFIED.\n\n   THE FOLLOWING RULES APPLY FOR THE&DDNAME/DATASET ID$PARAMETERS WHEN\n   USED WITH THE&O$OPTION:\n\n      -&DDNAME$AND&DATASET ID$ARE MUTUALLY EXCLUSIVE. CHOSE ONE OR THE OTHER.\n\n      -&DDNAME$    -  ENTER THE 1 TO 8 CHARACTER DDNAME TO BE DISPLAYED.\n      -&DATASET ID$-  ENTER THE 1 TO 4 DIGIT NUMBER OF THE DATASET TO BE\n                      DISPLAYED. THIS IS THE NUMBER UNDER THE&PN$HEADING\n                      OBTAINED WITH THE&SHOW FETCH$FUNCTION ( OPTION&S$).\n<ACTION>\n1 SELECT CHAR(36) CURSOR;\n2 SELECT CHAR(8) LIST(' ') RETURN(' ');\n3 * CHAR(8) INIT('VTJTIP  ');\n4 * CHAR(8) INIT('VTJTIP6 ');\n5 * CHAR(8) INIT('        ');\n<END>\n./ ADD NAME=VTJTIP6  0100-79269-79269-1311-00027-00027-00000-TYD9835 00\n&TUTORIAL ------------- JTIP UTILITY - FETCH AND BROWSE -------------- TUTORIAL\n&NEXT SELECTION ===>%SELECT                             &\n$\n   THE&FETCH AND BROWSE$FUNCTION ( OPTION&BLANK$) IS USED TO VIEW THE OUTPUT\n   OF A JOB IN THE&FETCH$QUEUE. JOB OUTPUT IS FETCHED TO A TEMPORARY DATASET\n   AND CONTROL IS PASSEDTO SPF BROWSE. ANY OF THE BROWSE OPTIONS CAN BE USED.\n\n   FILL IN THE FOLLOWING FIELDS OF THE JTIP UTILITY MENU:\n      - ENTER&BLANK$IN THE SELECT OPTION FIELD.\n      - ENTER A&JOBNAME$OR&JOBID.$ ONE OR THE OTHER MUST BE SPECIFIED.\n\n   THE FOLLOWING RULES APPLY FOR THE&DDNAME/DATASET ID$PARAMETERS WHEN\n   USED WITH THE&BLANK$OPTION:\n\n      -&DDNAME$AND&DATASET ID$ARE MUTUALLY EXCLUSIVE. CHOSE ONE OR THE OTHER.\n\n      -&DDNAME$    -  ENTER THE 1 TO 8 CHARACTER DDNAME TO BE DISPLAYED.\n      -&DATASET ID$-  ENTER THE 1 TO 4 DIGIT NUMBER OF THE DATASET TO BE\n                      DISPLAYED. THIS IS THE NUMBER UNDER THE&PN$HEADING\n                      OBTAINED WITH THE&SHOW FETCH$FUNCTION ( OPTION&S$).\n<ACTION>\n1 SELECT CHAR(36) CURSOR;\n2 SELECT CHAR(8) LIST(' ') RETURN(' ');\n3 * CHAR(8) INIT('VTJTIP  ');\n4 * CHAR(8) INIT('        ');\n5 * CHAR(8) INIT('        ');\n<END>\n./ ADD NAME=VTPAN    0105-79269-80102-1819-00036-00037-00000-$CSG05  00\n<FIELDS>\u00ac%!&$#@\n&TUTORIAL ---------------  PANVALET PROCESSING OPTION  --------------   TUTORIAL\n&NEXT SELECTION ===>%SELECT                             &(OR PRESS PF1 FOR HELP)\n&\n&                       --------------------------------\n&                       |  PANVALET PROCESSING OPTION  |\n&                       --------------------------------\n&\n$   THE PANVALET PROCESSING OPTION ALLOWS A PANVALET FUNCTION TO BE EXECUTED\n$   UNDER SPF. THE PANVALET SELECTION MENU, WHICH IS DISPLAYED WHEN OPTION\n$   &P$IS ENTERED ON THE PRIMARY OPTION MENU, ALLOWS YOU TO SELECT ONE OF\n$   THE TEN PANVALET OPTIONS LISTED BELOW:\n&\n$THE FOLLOWING TOPICS ARE PRESENTED IN SEQUENCE, OR MAY BE SELECTED BY NUMBER:\n   & G$- PAN PROCESSING OPTION GENERAL INFORMATION\n   & 0$- PAN EDIT\n   & 1$- PAN ADD\n   & 2$- PAN CHANGE\n   & 3$- PAN COPY\n   & 4$- PAN DISPLAY\n   & 5$- PAN LISTDS\n   & 6$- PAN PRINT\n   & 7$- PAN RENAME\n   & 8$- PAN RETRIEVE\n   & 9$- PAN STORE\n<ACTION>\n 1 SELECT CHAR(36) INIT(' ')   CURSOR;\n 2 SELECT CHAR(8)\n          LIST   (G       ,0       ,1       ,2       ,3       ,4       ,\n                  5       ,6       ,7       ,8       ,9       )\n          RETURN (VTPAN00 ,VTPANE  ,VTPAN01 ,VTPAN02 ,VTPAN03 ,VTPAN04 ,\n                  VTPAN05 ,VTPAN06 ,VTPAN07 ,VTPAN08 ,VTPAN09 );\n 3 *      CHAR(8)  INIT('TTUTOR  ');\n 4 *      CHAR(8)  INIT('TC      ');\n 5 *      CHAR(8)  INIT('VTPAN00 ');\n<END>\n./ ADD NAME=VTPANE   0103-79296-79303-1211-00024-00024-00000-TYD9801 00\n&TUTORIAL --------------------- PAN EDIT ------------------------------ TUTORIAL\n&NEXT SELECTION ===>%SELECT                             &\n$\n                    &----------------------------------&\n                    &-            PAN EDIT            -&\n                    &----------------------------------$\n\n$PAN EDIT ALLOWS YOU TO MORE EASILY USE SPF EDIT TO MODIFY MEMBERS OF\n PANVALET LIBRARIES.\n\n THE FOLLOWING TOPICS ARE PRESENTED IN SEQUENCE, OR MAY BE SELECTED BY NUMBER:\n    &0$- GENERAL INTRODUCTION\n    &1$- EDIT PANVALET MEMBER\n    &2$- SAVE EDITED MEMBER VIA PAN STORE\n    &3$- END PANVALET EDIT STATUS WITHOUT SAVE\n    &4$- DISPLAY EDIT STATUS OF PANVALET MEMBER\n<ACTION>\n1 SELECT CHAR(36) CURSOR;\n2 SELECT CHAR(8) LIST(   0   ,   1   ,   2   ,   3   ,   4   )\n               RETURN(VTPANE0,VTPANE1,VTPANE2,VTPANE3,VTPANE4);\n3 * CHAR(8) INIT('VTPAN   ');\n4 * CHAR(8) INIT('VTSUBMT ');\n5 * CHAR(8) INIT('VTPANE0 ');\n<END>\n./ ADD NAME=VTPANEX  0101-79296-79304-1727-00027-00027-00000-TYD9801 00\n&TUTORIAL -------------- PAN EDIT - OWNERSHIP ------------------------- TUTORIAL\n&NEXT SELECTION ===>%SELECT                             &\n&\n&                    &-----------------------------------&\n&                    &-            PAN EDIT             -&\n&                    &-    MODULE OWNERSHIP CONCEPT     -&\n&                    &-----------------------------------$\n$\n$ PAN EDIT USES AN OWNERSHIP CONCEPT TO CONTROL ACCESS TO PANVALET MEMBERS.\n$ INITIALLY A PANVALET MEMBER IS 'UNOWNED' AFTER IT IS ADDED TO THE\n$ PANVALET LIBRARY.  WHEN A MODULE IS RETRIEVED VIA PAN EDIT OR PAN\n$ RETRIEVE, THE MODULE BECOMES 'OWNED' BY THAT TSO USER.  WHEN 'OWNED',\n$ A MODULE CAN NOT BE UPDATED BY BATCH PANVALET.  ONLY THE 'OWNER' CAN\n$ UPDATE IT VIA PAN EDIT 'SAVE' OR PAN STORE.\n$\n$ A MODULE RETRIEVED WHICH IS NOT 'TEST,ENABLED, AND ACTIVE' WILL NOT\n$ BECOME 'OWNED' SINCE IT CANNOT BE STORED BACK ON THE PANVALET LIBRARY.\n$\n$ A MODULE IS CHANGED BACK TO 'UNOWNED' AFTER A SUCCESSFULL PAN STORE,\n$ PAN EDIT SAVE, OR PAN EDIT END.\n<ACTION>\n1 SELECT CHAR(36) CURSOR;\n2 SELECT CHAR(8) LIST(' ') RETURN(' ');\n3 * CHAR(8) INIT('VTPANE  ');\n4 * CHAR(8) INIT('        ');\n5 * CHAR(8) INIT('        ');\n<END>\n./ ADD NAME=VTPANE0  0101-79296-79296-1528-00030-00030-00000-TYD9801 00\n&TUTORIAL -------------- PAN EDIT - INTRODUCTION ---------------------- TUTORIAL\n&NEXT SELECTION ===>%SELECT                             &\n&\n                     &-----------------------------------&\n                     &-            PAN EDIT             -&\n                     &-       GENERAL INTRODUCTION      -&\n                     &-----------------------------------$\n$\n$ PAN EDIT IS DESIGNED TO SIMPLIFY THE INTERFACE BETWEEN SPF EDIT AND\n$ PANVALET.  NORMALLY YOU MUST RETRIEVE A MEMBER FROM THE PANVALET\n$ LIBRARY INTO AN SPF DATASET,  AND THEN USE SPF EDIT TO MAKE CHANGES.\n$ AFTER YOUR CHANGES ARE COMPLETE,  YOU MUST USE PANVALET 'STORE' TO\n$ RETURN THE MODIFIED MEMBER TO PANVALET.  THESE OPERATIONS REQUIRE\n$ SEVERAL STEPS AND ALSO REQUIRE MANUAL CO-ORDINATION TO PREVENT MORE\n$ THAN ONE PERSON FROM WORKING ON THE SAME PANVALET MEMBER IN SEPARATE\n$ SPF DATASETS.\n$\n$ PAN EDIT SIMPLIFIES THE OPERATION BY FURNISHING ADDITIONAL CHECKING\n$ AND CONTROLS TO INSURE ONLY ONE PERSON IS EDITING A PANVALET MEMBER AT\n$ A TIME.  IT SIMPLIFIES USAGE BY PERFORMING SEVERAL FUNCTIONS WITH\n$ FEWER SCREENS.\n$\n                          $(CONTINUED ON NEXT PAGE)\n<ACTION>\n1 SELECT CHAR(36) CURSOR;\n2 SELECT CHAR(8) LIST(' ') RETURN(' ');\n3 * CHAR(8) INIT('VTPANE  ');\n4 * CHAR(8) INIT('VTPANE1 ');\n5 * CHAR(8) INIT('VTPANE01');\n<END>\n./ ADD NAME=VTPANE01 0104-79296-79304-1731-00028-00025-00000-TYD9801 00\n&TUTORIAL -------------- PAN EDIT - INTRODUCTION ---------------------- TUTORIAL\n&NEXT SELECTION ===>%SELECT                             &\n$\n$ HERE ARE HIGHLIGHTS OF PAN EDIT FUNCTIONS:\n$   1. FOR EDIT REQUESTS, A CHECK IS MADE TO SEE IF THE MEMBER HAS\n$      ALREADY BEEN RETRIEVED BY ANOTHER MEMBER.\n$\n$   2. FOR EDIT REQUESTS,  A PAN RETRIEVE COMMAND IS EXECUTED AND THE\n$      SPF EDIT DRIVER IS CALLED DIRECTLY FROM THE PAN EDIT SCREEN.\n$\n$   3. FOR EDIT REQUESTS, SPF COMPATABLE SEQUENCE NUMBERS, BANKERS AUDIT\n$      TRAIL INFORMATION,  AND AN SPF COMPATABLE DIRECTORY ENTRY ARE\n$      GENERATED FOR COBOL AND ASSEMBLER MEMBERS.\n$\n$   4. FOR SAVE REQUESTS,  THE PAN 'STORE' COMMAND IS EXECUTED, AND\n$      THE SPF MEMBER IS DELETED FROM THE SPF LIBRARY.\n$\n$NOTES: PAN EDIT,  BATCH PANVALET,  AND PAN 'STORE' AND 'RETRIEVE'\n$      PROCCESSING ARE COORDINATED.  IE. A BATCH UPDATE OR PAN RETRIEVE\n$      IS NOT ALLOWED IF THE MODULE IS 'OWNED'.  A PAN 'STORE' IS NOT\n$      ALLOWED UNLESS THE 'STORER' IS ALSO THE 'OWNER'.\n<ACTION>\n1 SELECT CHAR(36) CURSOR;\n2 SELECT CHAR(8) LIST(' ') RETURN(' ');\n3 * CHAR(8) INIT('VTPANE0 ');\n4 * CHAR(8) INIT('        ');\n5 * CHAR(8) INIT('        ');\n<END>\n./ ADD NAME=VTPANE1  0103-79296-79304-1732-00028-00030-00000-TYD9801 00\n&TUTORIAL -------------- PAN EDIT - EDIT OPTION ----------------------- TUTORIAL\n&NEXT SELECTION ===>%SELECT                             &\n&\n&                    &-----------------------------------&\n&                    &-            PAN EDIT             -&\n&                    &-        OPTION ' ' - EDIT        -&\n&                    &-----------------------------------$\n$\n$ THE EDIT FUNCTION PERFORMS THE FOLLOWING FUNCTIONS:\n$   1. IF PAN MEMBER IS NOT CURRENTLY 'OWNED' BY A TSO USER,  IT IS\n$      RETRIEVED INTO THE SPF DATASET SPECIFIED.  IF 'OWNED' BY THE TSO\n$      USER ENTERING THE EDIT OPTION,  SPF EDIT IS CALLED WITHOUT A\n$      RETRIEVE.  IF THE MEMBER IS OWNED BY ANOTHER TSO USER, THE EDIT\n$      REQUEST IS DENIED;  THE MEMBER CANNOT BE RETRIEVED.\n$\n$   2. IF THE MEMBER IS COBOL OR ASSEMBLER,  AND IT IS NOT 'NOFORMAT',\n$      THE SAME 'AUDIT TRAIL' CONSTANTS ARE INSERTED AS IN BATCH\n$      PROCCESSING;  THE MODULE IS RESEQUENCED USING STANDARD SPF OR\n$      COBOL SEQUENCE NUMBERS.\n$\n                           (CONTINUED ON NEXT PAGE)\n<ACTION>\n1 SELECT CHAR(36) CURSOR;\n2 SELECT CHAR(8) LIST(' ') RETURN(' ');\n3 * CHAR(8) INIT('VTPANE  ');\n4 * CHAR(8) INIT('VTPANE2 ');\n5 * CHAR(8) INIT('VTPANE11');\n<END>\n./ ADD NAME=VTPANE11 0103-79296-79304-1733-00026-00028-00000-TYD9801 00\n&TUTORIAL -------------- PAN EDIT - EDIT OPTION ----------------------- TUTORIAL\n&NEXT SELECTION ===>%SELECT                             &\n&\n                     &-----------------------------------&\n                     &-            PAN EDIT             -&\n                     &-        OPTION ' ' - EDIT        -&\n                     &-----------------------------------$\n$\n$   3. THE SPF DIRECTORY STATISTICS ARE INITIALIZED.  THE 'CREATION DATE'\n$      IS SET TO THE 'DATE LAST MAINTAINED' FROM PANVALET.\n$\n$   4. IF THE MEMBER IS NOT 'TEST,ACTIVE,ENABLED' THE RETRIEVE IS DONE,\n$      BUT THE MEMBER IS NOT 'OWNED';  NO SAVE (STORE) WILL BE ALLOWED.\n$\n$NOTES: YOU NEED SPECIFY ONLY THE SPF MEMBER OR THE PANVALET MEMBER ON\n$      THE PAN EDIT MENU.  IF ONLY THE SPF MEMBER IS SPECIFIED,  THE PAN\n$      MEMBER NAME IS DEFAULTED TO THE SAME NAME. IF ONLY THE PAN MEMBER\n$      SPECIFIED,  THE SPF NAME IS DEFAULTED TO THE FIRST 8 CHARACTERS\n$      OF THE PAN MEMBER NAME.\n<ACTION>\n1 SELECT CHAR(36) CURSOR;\n2 SELECT CHAR(8) LIST(' ') RETURN(' ');\n3 * CHAR(8) INIT('VTPANE1 ');\n4 * CHAR(8) INIT('        ');\n5 * CHAR(8) INIT('        ');\n<END>\n./ ADD NAME=VTPANE2  0101-79296-79296-1533-00026-00026-00000-TYD9801 00\n&TUTORIAL -------------- PAN EDIT - SAVE OPTION ----------------------- TUTORIAL\n&NEXT SELECTION ===>%SELECT                             &\n&\n                     &-----------------------------------&\n                     &-            PAN EDIT             -&\n                     &-        OPTION 'S' - SAVE        -&\n                     &-----------------------------------$\n$\n$ THE SAVE FUNCTION PERFORMS THE FOLLOWING FUNCTIONS:\n$   1. IF PAN MEMBER IS CURRENTLY 'OWNED' BY THE TSO USER ISSUING THE\n$      SAVE REQUEST,  PANVALET 'STORE' IS INVOKED TO STORE THE MEMBER\n$      BACK ON THE PANVALET LIBRARY. IF THE MODULE IS NOT OWNED BY THE\n$      REQUESTOR,  THE SAVE IS DISSALLOWED.\n$\n$   2. IF THE 'SAVED' MEMBER IS DELETED FROM THE SPF LIBRARY, AFTER\n$      SUCCESSFULL 'STORE'.\n$\n$   3. THE MODULE IS MARKED AS 'NOT OWNED' SO ANOTHER USER MAY RETRIEVE\n$      IT FOR EDIT.\n<ACTION>\n1 SELECT CHAR(36) CURSOR;\n2 SELECT CHAR(8) LIST(' ') RETURN(' ');\n3 * CHAR(8) INIT('VTPANE  ');\n4 * CHAR(8) INIT('VTPANE3 ');\n5 * CHAR(8) INIT('        ');\n<END>\n./ ADD NAME=VTPANE3  0101-79296-79296-1535-00021-00021-00000-TYD9801 00\n&TUTORIAL -------------- PAN EDIT - END OPTION ------------------------ TUTORIAL\n&NEXT SELECTION ===>%SELECT                             &\n&\n                     &-----------------------------------&\n                     &-            PAN EDIT             -&\n                     &-        OPTION 'E' - END         -&\n                     &-----------------------------------$\n$\n$ THE END FUNCTION PERFORMS THE FOLLOWING FUNCTIONS:\n$   1. IF PAN MEMBER IS CURRENTLY 'OWNED' BY THE TSO USER ISSUING THE\n$      END REQUEST,  THE MODULE IS MARKED AS 'NOT OWNED'. IF THE MODULE\n$      IS NOT OWNED BY THE REQUESTER,  NO ACTION IS PERFORMED.\n$\n$   2. THE MODULE IS LEFT ON THE SPF LIBRARY.\n<ACTION>\n1 SELECT CHAR(36) CURSOR;\n2 SELECT CHAR(8) LIST(' ') RETURN(' ');\n3 * CHAR(8) INIT('VTPANE  ');\n4 * CHAR(8) INIT('VTPANE4 ');\n5 * CHAR(8) INIT('        ');\n<END>\n./ ADD NAME=VTPANE4  0103-79296-79304-1735-00017-00017-00000-TYD9801 00\n&TUTORIAL ------------ PAN EDIT - DISPLAY OPTION ---------------------- TUTORIAL\n&NEXT SELECTION ===>%SELECT                             &\n&\n                     &-----------------------------------&\n                     &-            PAN EDIT             -&\n                     &-      OPTION 'D' - DISPLAY       -&\n                     &-----------------------------------$\n$\n$ THE DISPLAY FUNCTION PERFORMS THE FOLLOWING FUNCTION:\n$   1. THE LAST ACTION PERFORMED USING PAN/TSO IS DISPLAYED.\n<ACTION>\n1 SELECT CHAR(36) CURSOR;\n2 SELECT CHAR(8) LIST(' ') RETURN(' ');\n3 * CHAR(8) INIT('VTPANE  ');\n4 * CHAR(8) INIT('VTPANE  ');\n5 * CHAR(8) INIT('VTPAN01 ');\n<END>\n./ ADD NAME=VTPAN00  0102-79269-79303-1228-00038-00036-00000-TYD9801 00\n<FIELDS>\u00ac%!&$#@\n&TUTORIAL ---------------  PANVALET PROCESSING OPTION  --------------   TUTORIAL\n&NEXT SELECTION ===>%SELECT                             &(OR PRESS PF1 FOR HELP)\n&\n&                       ----------------------------------\n&                       |  PANVALET GENERAL INFORMATION  |\n&                       ----------------------------------\n&\n$   THE PANVALET PROCESSING OPTION USES THE TSO/PAN COMMAND TO PERFORM THE\n$   FOLLOWING FUNCTIONS:\n&\n$             EDIT, ADD, CHANGE, COPY, DISPLAY,\n$             LISTDS, PRINT, RENAME, RETRIEVE, AND STORE.\n$\n$   DISCUSSIONS OF THE INDIVIDUAL FUNCTIONS MAY BE OBTAINED BY SELECTED NUMBER:\n$\n   & 0$- PAN EDIT\n   & 1$- PAN ADD\n   & 2$- PAN CHANGE\n   & 3$- PAN COPY\n   & 4$- PAN DISPLAY\n   & 5$- PAN LISTDS\n   & 6$- PAN PRINT\n   & 7$- PAN RENAME\n   & 8$- PAN RETRIEVE\n   & 9$- PAN STORE\n&\n<ACTION>\n 1 SELECT CHAR(36) INIT(' ')   CURSOR;\n 2 SELECT CHAR(8)\n          LIST   (0       ,1       ,2       ,3       ,4       ,5       ,\n                  6       ,7       ,8       ,9       )\n          RETURN (VTPANE  ,VTPAN01 ,VTPAN02 ,VTPAN03 ,VTPAN04 ,VTPAN05 ,\n                  VTPAN06 ,VTPAN07 ,VTPAN08 ,VTPAN09 );\n 3 *      CHAR(8)  INIT('TTUTOR  ');\n 4 *      CHAR(8)  INIT('VTPAN   ');\n 5 *      CHAR(8)  INIT('VTPANE  ');\n<END>\n./ ADD NAME=VTPAN01  0101-79269-79303-1214-00029-00029-00000-TYD9801 00\n<FIELDS>\u00ac%!&$#@\n&TUTORIAL ---------------  PANVALET PROCESSING OPTION  --------------   TUTORIAL\n&NEXT SELECTION ===>%SELECT                             &(OR PRESS PF1 FOR HELP)\n&\n&                             ---------------------\n&                             |  PAN ADD COMMAND  |\n&                             ---------------------\n&\n$   A TSO PDS MEMBER OR SEQUENTIAL DSN MAY BE ADDED TO THE PANVALET LIBRARY.\n$\n$        SPECIFY: DDNAME   (NAME OF PANVALET LIBRARY  EG. PAN3912)\n$                 PANNAME  (NEW PANVALET MEMBER NAME TO BE ADDED)\n$                 FORMAT   (ASM, COBOL, DATA, FORT, PL1, OBJ, OTHER, JCL)\n$\n$                 PROJECT-LIBRARY-TYPE-MEMBER (NORMAL SPF DATASET NAME FORMAT)\n$\n$                 DSNAME   (NON SPF SEQUENTIAL OR PARTITIONED DATASET)\n$\n$                 USER     (OPTIONAL USER CODE OF THE PANVALET MEMBER)\n$                 CONTROL  (CONTROL CODE OF THE PANVALET LIBRARY)\n$                 INT FMT  (INTERNAL FORMAT - TSO, PANVALET, OR NOFORMAT)\n$                 DISP     (DISPOSITION OF FROM DATASET, KEEP OR DELETE)\n&\n<ACTION>\n 1 SELECT CHAR(36) INIT(' ')         CURSOR;\n 3 *      CHAR(8)  INIT('TTUTOR  ');\n 4 *      CHAR(8)  INIT('VTPANE  ');\n 5 *      CHAR(8)  INIT('VTPAN02 ');\n<END>\n./ ADD NAME=VTPAN02  0100-79269-79269-1311-00029-00029-00000-TYD9835 00\n<FIELDS>\u00ac%!&$#@\n&TUTORIAL ---------------  PANVALET PROCESSING OPTION  --------------   TUTORIAL\n&NEXT SELECTION ===>%SELECT                             &(OR PRESS PF1 FOR HELP)\n&\n&                           ------------------------\n&                           |  PAN CHANGE COMMAND  |\n&                           ------------------------\n&\n$   INDIVIDUAL PANVALET DATASET ATTRIBUTES MAY BE APPLIED, ALTERED OR REMOVED.\n$   ONLY ONE ATTRIBUTE MAY BE CHANGED AT A TIME.\n$\n$        SPECIFY: DDNAME   (NAME OF PANVALET LIBRARY  EG. PAN3912)\n$                 PANNAME  (NAME OF PANVALET MEMBER)\n$\n$                 STATUS   (TEST/PROD ENABLED/DISABLED ACTIVE/INACTIVE)\n$                 COMMENT  (50 BYTE COMMENT FIELD. MUST BE IN QUOTES)\n$                 USER     (CHANGE USER CODE AND/OR SECURITY LEVEL)\n$                 LEVEL    (CHANGE LEVEL OF PANVALET MEMBER)\n$\n$                 ACCESS   (ACCESS CODE OF THE PANVELET MEMBER)\n$                 CONTROL  (CONTROL CODE OF THE PANVALET LIBRARY)\n$\n&\n<ACTION>\n 1 SELECT CHAR(36) INIT(' ')         CURSOR;\n 3 *      CHAR(8)  INIT('TTUTOR  ');\n 4 *      CHAR(8)  INIT('VTPAN01 ');\n 5 *      CHAR(8)  INIT('VTPAN03 ');\n<END>\n./ ADD NAME=VTPAN03  0100-79269-79269-1311-00024-00024-00000-TYD9835 00\n<FIELDS>\u00ac%!&$#@\n&TUTORIAL ---------------  PANVALET PROCESSING OPTION  --------------   TUTORIAL\n&NEXT SELECTION ===>%SELECT                             &(OR PRESS PF1 FOR HELP)\n&\n&                            ----------------------\n&                            |  PAN COPY COMMAND  |\n&                            ----------------------\n&\n$   THE COPY FUNCTION CREATES A DUPLICATE MEMBER ON THE PANVALET LIBRARY GIVING\n$   A NEW NAME AND PLACING THE COPY IN TEST, ENABLE STATUS.\n$\n$        SPECIFY:   DDNAME   (NAME OF PANVALET LIBRARY EG. PAN3912)\n$              FROM PANNAME  (NAME OF PANVALET MEMBER TO BE COPIED)\n$                TO NEWNAME  (NEW PANVALET MEMBER TO BE COPIED TO)\n$\n$                   ACCESS   (ACCESS CODE OF THE PANVALET MEMBER)\n$                   CONTROL  (CONTROL CODE OF THE PANVALET LIBRARY)\n&\n<ACTION>\n 1 SELECT CHAR(36) INIT(' ')         CURSOR;\n 3 *      CHAR(8)  INIT('TTUTOR  ');\n 4 *      CHAR(8)  INIT('VTPAN02 ');\n 5 *      CHAR(8)  INIT('VTPAN04 ');\n<END>\n./ ADD NAME=VTPAN04  0102-79269-79303-1229-00025-00024-00000-TYD9801 00\n<FIELDS>\u00ac%!&$#@\n&TUTORIAL ---------------  PANVALET PROCESSING OPTION  --------------   TUTORIAL\n&NEXT SELECTION ===>%SELECT                             &(OR PRESS PF1 FOR HELP)\n&\n&                           -------------------------\n&                           |  PAN DISPLAY COMMAND  |\n&                           -------------------------\n&\n$   A PANVALET MEMBER MAY BE DISPLAYED FROM THE PANVALET LIBRARY.\n$\n$        SPECIFY: DDNAME   (NAME OF PANVALET LIBRARY   EG. PAN3912)\n$                 PANNAME  (NAME OF PANVALET MEMBER TO BE DISPLAYED)\n$\n$                 ACCESS   (ACCESS CODE OF THE PANVALET MEMBER)\n$                 EXPAND   (OPTIONAL REQUEST TO EXPAND IMBEDDED ++INCLUDE\n$                           STATEMENTS DURING DISPLAY. DEFAULT IS NOEXPAND)\n&\n<ACTION>\n 1 SELECT CHAR(36) INIT(' ')         CURSOR;\n 3 *      CHAR(8)  INIT('TTUTOR  ');\n 4 *      CHAR(8)  INIT('VTPAN03 ');\n 5 *      CHAR(8)  INIT('VTPAN05 ');\n<END>\n* THE FOLLOWING PARAMETER IS NOT USED BY THE PANDSPLY PROGRAM.\n$                 SEQ2     (OPTIONAL ENDING LINE NUMBER TO BE DISPLAYED)\n./ ADD NAME=VTPAN05  0100-79269-79269-1311-00024-00024-00000-TYD9835 00\n<FIELDS>\u00ac%!&$#@\n&TUTORIAL ---------------  PANVALET PROCESSING OPTION  --------------   TUTORIAL\n&NEXT SELECTION ===>%SELECT                             &(OR PRESS PF1 FOR HELP)\n&\n&                           ------------------------\n&                           |  PAN LISTDS COMMAND  |\n&                           ------------------------\n&\n$   THE ATTRIBUTES (DIRECTORY LISTING) OF A PANVALET MEMBER MAY BE DISPLAYED.\n$\n$        SPECIFY: DDNAME   (NAME OF PANVALET LIBRARY   EG. PAN3912)\n$                 PANNAME  (NAME OF PANVALET MAMBER)\n$\n$                 ACCESS   (ACCESS CODE OF THE PANVALET MEMBER)\n$                 CONTROL  (CONTROL CODE OF THE PANVALET LIBRARY)\n$                 COMMENT  (COMMENTS ARE LISTED BY DEFAULT. CLEAR\n$                           'COMMENT' TO NOT SHOW COMMENTS)\n&\n<ACTION>\n 1 SELECT CHAR(36) INIT(' ')         CURSOR;\n 3 *      CHAR(8)  INIT('TTUTOR  ');\n 4 *      CHAR(8)  INIT('VTPAN04 ');\n 5 *      CHAR(8)  INIT('VTPAN06 ');\n<END>\n./ ADD NAME=VTPAN06  0100-79269-79269-1311-00027-00027-00000-TYD9835 00\n<FIELDS>\u00ac%!&$#@\n&TUTORIAL ---------------  PANVALET PROCESSING OPTION  --------------   TUTORIAL\n&NEXT SELECTION ===>%SELECT                             &(OR PRESS PF1 FOR HELP)\n&\n&                            -----------------------\n&                            |  PAN PRINT COMMAND  |\n&                            -----------------------\n&\n$   PRODUCES A SELECTIVE DIRECTORY LIST OF THE PANVALET LIBRARY.  ENTER ONLY\n$   ONE SELECTION CRITERION PER EXECUTION\n$\n$        SPECIFY: DDNAME  (NAME OF PANVALET LIBRARY  EG. PAN3912)\n$\n$                 NAME    (LIST MEMBERS BEGINNING WITH THIS STRING)\n$                 STATUS  (ONLY LIST MEMBERS WITH THIS STATUS)\n$                 TYPE    (ASM, COBOL, DATA, FORT, PLI, OBJ, JCL, OTHER)\n$                 USER    (ONLY LIST MEMBERS WITH THIS USER CODE)\n$\n$                 CONTROL (CONTROL CODE OF THE PANVALET LIBRARY)\n$                 COMMENT (OPTIONALY DISPLAY USER COMMENTS)\n&\n<ACTION>\n 1 SELECT CHAR(36) INIT(' ')         CURSOR;\n 3 *      CHAR(8)  INIT('TTUTOR  ');\n 4 *      CHAR(8)  INIT('VTPAN05 ');\n 5 *      CHAR(8)  INIT('VTPAN07 ');\n<END>\n./ ADD NAME=VTPAN07  0100-79269-79269-1311-00023-00023-00000-TYD9835 00\n<FIELDS>\u00ac%!&$#@\n&TUTORIAL ---------------  PANVALET PROCESSING OPTION  --------------   TUTORIAL\n&NEXT SELECTION ===>%SELECT                             &(OR PRESS PF1 FOR HELP)\n&\n&                           ------------------------\n&                           |  PAN RENAME COMMAND  |\n&                           ------------------------\n&\n$   CHANGE THE NAME OF A PANVALET LIBRARY MEMBER.\n$\n$        SPECIFY:   DDNAME  (NAME OF PANVALET LIBRARY  EG. PAN3912)\n$              FROM PANNAME (OLD NAME OF PANVALET MEMBER)\n$                TO NEWNAME (NEW NAME OF PANVALET MEMBER)\n$\n$                   ACCESS  (ACCESS CODE OF THE PANVALET MEMBER)\n$                   CONTROL (CONTROL CODE OF THE PANVALET LIBRARY)\n&\n<ACTION>\n 1 SELECT CHAR(36) INIT(' ')         CURSOR;\n 3 *      CHAR(8)  INIT('TTUTOR  ');\n 4 *      CHAR(8)  INIT('VTPAN06 ');\n 5 *      CHAR(8)  INIT('VTPAN08 ');\n<END>\n./ ADD NAME=VTPAN08  0100-79269-79269-1311-00031-00031-00000-TYD9835 00\n<FIELDS>\u00ac%!&$#@\n&TUTORIAL ---------------  PANVALET PROCESSING OPTION  --------------   TUTORIAL\n&NEXT SELECTION ===>%SELECT                             &(OR PRESS PF1 FOR HELP)\n&\n&                          --------------------------\n&                          |  PAN RETRIEVE COMMAND  |\n&                          --------------------------\n&\n$   A PANVALET LIBRARY MEMBER MAY BE RETRIEVED INTO A TSO PDS MEMBER,\n$   OR A SEQUENTIAL DATASET.\n$\n$\n$        SPECIFY: DDNAME  (NAME OF PANVALET LIBRARY)\n$                 PANNAME (NAME OF PANVALET MEMBER TO BE RETRIEVED)\n$                 EXPAND  (OPTIONAL REQUEST TO EXPAND IMBEDDED ++INCLUDE\n$                          STATEMENTS DURING RETRIEVE. DEFAULT IS NOEXPAND)\n$\n$                 PROJECT-LIBRARY-TYPE-MEMBER  (NORMAL SPF DATASET NAME FORMAT)\n$\n$                 DSNAME  (NON SPF SEQUENTIAL OR PARTITIONED DATASET)\n$\n$                 ACCESS  (ACCESS CODE OF THE PANVALET MEMBER)\n$                 CONTROL (CONTROL CODE OF THE PANVALET LIBRARY)\n$                 INT FMT (INTERNAL FORMAT - TSO,PANVALET, OR NOFORMAT)\n&\n<ACTION>\n 1 SELECT CHAR(36) INIT(' ')         CURSOR;\n 3 *      CHAR(8)  INIT('TTUTOR  ');\n 4 *      CHAR(8)  INIT('VTPAN07 ');\n 5 *      CHAR(8)  INIT('VTPAN09 ');\n<END>\n./ ADD NAME=VTPAN09  0100-79269-79269-1311-00030-00030-00000-TYD9835 00\n<FIELDS>\u00ac%!&$#@\n&TUTORIAL ---------------  PANVALET PROCESSING OPTION  --------------   TUTORIAL\n&NEXT SELECTION ===>%SELECT                             &(OR PRESS PF1 FOR HELP)\n&\n&                            -----------------------\n&                            |  PAN STORE COMMAND  |\n&                            -----------------------\n&\n$   A PANVALET LIBRARY MEMBER MAY BE REPLACED USING A TSO PDS MEMBER,\n$   OR A SEQUENTIAL DATASET.\n$\n$        SPECIFY: DDNAME  (NAME OF PANVALET LIBRARY  EG. PAN3912)\n$                 PANNAME (NAME OF PANVALET MEMBER TO BE UPDATED)\n$                 LEVEL   (CURRENT LEVEL OF THIS MEMBER)\n$\n$                 PROJECT-LIBRARY-TYPE-MEMBER  (NORMAL SPF DATASET NAME FORMAT)\n$\n$                 DSNAME  (NON SPF SEQUENTIAL OR PARTITIONED DATASET)\n$\n$                 ACCESS  (ACCESS CODE OF THE PANVALET MEMBER)\n$                 CONTROL (CONTROL CODE OF THE PANVALET LIBRARY)\n$                 INT FMT (INTERNAL FORMAT - TSO, PANVALET, OR NOFORMAT)\n$                 DISP    (DISPOSITION OF FROM DATASET, KEEP OR DELETE)\n&\n<ACTION>\n 1 SELECT CHAR(36) INIT(' ')         CURSOR;\n 3 *      CHAR(8)  INIT('TTUTOR  ');\n 4 *      CHAR(8)  INIT('VTPAN08 ');\n 5 *      CHAR(8)  INIT('VTPAN00 ');\n<END>\n./ ADD NAME=VTSUBMT  0101-79269-79271-1201-00027-00027-00000-TYD9835 00\n<FIELDS>\u00ac%!&$#@\n&TUTORIAL--------------  SUBMIT PROCESSING OPTION  ------------------   TUTORIAL\n&NEXT SELECTION ===>%SELECT                             &(OR PRESS PF1 FOR HELP)\n&\n&\n&\n&         * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n&         * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n&         * * $                                                 & * *\n&         * * $                                                 & * *\n&         * * $         THE TUTORIAL THAT WAS SELECTED          & * *\n&         * * $         IS CURRENTLY IN DEVELOPMENT.            & * *\n&         * * $                                                 & * *\n&         * * $                                                 & * *\n&         * * $      PRESS&(PF3)$TO DISPLAY PRIMARY MENU        & * *\n&         * * $                     OR                          & * *\n&         * * $    PRESS&(ENTER)$ TO DISPLAY TUTORIAL MENU      & * *\n&         * * $                                                 & * *\n&         * * $                                                 & * *\n&         * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n&         * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n<ACTION>\n 1 SELECT CHAR(36) INIT(' ')         CURSOR;\n 3 *      CHAR(8)  INIT('TTUTOR  ');\n 4 *      CHAR(8)  INIT('TTUTOR  ');\n 5 *      CHAR(8)  INIT('TTUTOR  ');\n<END>\n./ ADD NAME=VTU      0100-79269-79269-1311-00066-00066-00000-TYD9835 00\n<FIELDS>\u00ac%!&$#@\n&TUTORIAL ------------------------ UTILITIES -------------------------- TUTORIAL\n&NEXT SELECTION ===>%SELECT                             &\n$\n&                     -----------------------------------\n&                     |            UTILITIES            |\n                      -----------------------------------\n$  THE&UTILITY$OPTION ALLOWS YOU TO SELECT ONE OF NINE UTILITIES LISTED BELOW.\n   TO SELECT A UTILITY, ENTER A NUMBER FROM 1 TO 9 ON THE UTILITY SELECTION\n   MENU, WHICH IS DISPLAYED WHEN OPTION 3 IS ENTERED ON THE PRIMARY OPTION MENU.\n\n THE FOLLOWING TOPICS ARE PRESENTED IN SEQUENCE, OR MAY BE SELECTED BY NUMBER:\n    &1$- LIBRARY UTILITIES......PRINT INDEX OR ENTIRE DATA SET; PRINT, RENAME,\n                                OR DELETE MEMBER; COMPRESS DATA SET\n    &2$- DATA SET UTILITIES.....ALLOCATE, RENAME, DELETE, CATALOG, OR UNCATALOG\n                                DATA SET; DISPLAY DATA SET INFORMATION\n    &3$- MOVE/COPY UTILITY......MOVE OR COPY MEMBERS OR DATA SETS\n    &4$- CATALOG MANAGEMENT.....DISPLAY OR PRINT CATALOG ENTRIES;\n                                INITIALIZE OR DELETE PROJECT CATALOG POINTER\n    &5$- RESET SPF STATISTICS...RESET SOURCE MEMBER STATISTICS\n    &6$- HARDCOPY UTILITY.......INITIATE HARDCOPY OUTPUT\n    &7$- VTOC UTILITY...........DISPLAY OR PRINT A DASD VTOC\n    &8$- OUTLIST UTILITY........BROWSE, DELETE, OR PRINT HELD JOB OUTPUT\n<ACTION>\n1 SELECT CHAR(36) CURSOR;\n2 SELECT CHAR(8) LIST(1  ,2  ,3   ,4   ,5  ,6  ,7  ,8   ,9)\n               RETURN(TUL,TUD,TUMC,TUCM,TUR,TUH,TUV,TUOL,VTNOTSUP);\n3 * CHAR(8) INIT('TTUTOR  ');\n4 * CHAR(8) INIT('TP      ');\n5 * CHAR(8) INIT('TUL     ');\n<END>\n***\n*** ORGINAL STATEMENTS\n***\n<FIELDS>\u00ac%!&$#@\n&TUTORIAL ------------------------ UTILITIES -------------------------- TUTORIAL\n&NEXT SELECTION ===>%SELECT                             &\n$\n&                     -----------------------------------\n&                     |            UTILITIES            |\n                      -----------------------------------\n$  THE&UTILITY$OPTION ALLOWS YOU TO SELECT ONE OF NINE UTILITIES LISTED BELOW.\n   TO SELECT A UTILITY, ENTER A NUMBER FROM 1 TO 9 ON THE UTILITY SELECTION\n   MENU, WHICH IS DISPLAYED WHEN OPTION 3 IS ENTERED ON THE PRIMARY OPTION MENU.\n\n THE FOLLOWING TOPICS ARE PRESENTED IN SEQUENCE, OR MAY BE SELECTED BY NUMBER:\n    &1$- LIBRARY UTILITIES......PRINT INDEX OR ENTIRE DATA SET; PRINT, RENAME,\n                                OR DELETE MEMBER; COMPRESS DATA SET\n    &2$- DATA SET UTILITIES.....ALLOCATE, RENAME, DELETE, CATALOG, OR UNCATALOG\n                                DATA SET; DISPLAY DATA SET INFORMATION\n    &3$- MOVE/COPY UTILITY......MOVE OR COPY MEMBERS OR DATA SETS\n    &4$- CATALOG MANAGEMENT.....DISPLAY OR PRINT CATALOG ENTRIES;\n                                INITIALIZE OR DELETE PROJECT CATALOG POINTER\n    &5$- RESET SPF STATISTICS...RESET SOURCE MEMBER STATISTICS\n    &6$- HARDCOPY UTILITY.......INITIATE HARDCOPY OUTPUT\n    &7$- VTOC UTILITY...........DISPLAY OR PRINT A DASD VTOC\n    &8$- OUTLIST UTILITY........BROWSE, DELETE, OR PRINT HELD JOB OUTPUT\n    &9$- SCRIPT/VS UTILITY......FORMAT, DISPLAY, AND PRINT SCRIPT TEXT\n<ACTION>\n1 SELECT CHAR(36) CURSOR;\n2 SELECT CHAR(8) LIST(1  ,2  ,3   ,4   ,5  ,6  ,7  ,8   ,9)\n               RETURN(TUL,TUD,TUMC,TUCM,TUR,TUH,TUV,TUOL,TUS);\n3 * CHAR(8) INIT('TTUTOR  ');\n4 * CHAR(8) INIT('TP      ');\n5 * CHAR(8) INIT('TUL     ');\n<END>\n./ ADD NAME=VTUOL    0100-80022-80022-1656-00025-00025-00000-TYD9835 00\n<FIELDS>\u00ac%!&$#@\n&TUTORIAL --------------------- OUTLIST UTILITY ----------------------- TUTORIAL\n&NEXT SELECTION ===>%SELECT                             &\n$\n&                     -----------------------------------\n                      |            UTILITIES            |\n                      |         OUTLIST UTILITY         |\n                      -----------------------------------\n$\n   YOU MAY SELECT THE OUTLIST UTILITY BY:\n       - SELECTING OPTION&C$FROM THE&PRIMARY OPTION MENU\n\n THE FOLLOWING TOPICS ARE PRESENTED IN SEQUENCE, OR MAY BE SELECTED BY NUMBER:\n    &1$- LISTING THE STATUS OF JOBS\n    &2$- DELETING THE OUTPUT OF A HELD JOB\n    &3$- PRINTING THE OUTPUT OF A HELD JOB\n    &4$- DISPLAYING THE OUTPUT OF A HELD JOB\n<ACTION>\n1 SELECT CHAR(36) CURSOR;\n2 SELECT CHAR(8) LIST(1       ,2       ,3       ,4       )\n               RETURN(VTUOL01L,VTUOL01D,VTUOL01P,VTUOL01B);\n3 * CHAR(8) INIT('TU      ');\n4 * CHAR(8) INIT('TUS     ');\n5 * CHAR(8) INIT('VTUOL01L');\n<END>\n./ ADD NAME=VTUOLB\n&TUTORIAL ----------------- OUTLIST UTILITY - DISPLAY ----------------- TUTORIAL\n&NEXT SELECTION ===>%SELECT                             &\n$\n$  THE&DISPLAY HELD SYSOUT JOB$FUNCTION CAUSED A LISTING FOR THE SPECIFIED JOB\n   TO BE DISPLAYED AT THE TERMINAL.  THE LISTING WAS PRODUCED VIA THE TSO OUTPUT\n   COMMAND.\n\n   THE SPF&BROWSE$FUNCTION WAS AUTOMATICALLY INVOKED TO DISPLAY THE\n   JOB LISTING, AND ALL BROWSE OPTIONS MAY BE USED, INCLUDING\n  &SCROLLING$AND THE&FIND$COMMAND.  USE THE&END$KEY TO TERMINATE THE\n   BROWSE FUNCTION AND RETURN TO THE OUTLIST UTILITY MENU.\n\n   IF YOU PRESS THE&ENTER$KEY NOW YOU WILL ENTER THE BROWSE TUTORIAL.\n<ACTION>\n1 SELECT CHAR(36) CURSOR;\n2 SELECT CHAR(8) LIST(' ') RETURN(' ');\n3 * CHAR(8) INIT('TTUTOR  ');\n4 * CHAR(8) INIT('        ');\n5 * CHAR(8) INIT('TUB     ');\n<END>\n./ ADD NAME=VTUOL01B\n&TUTORIAL ------------- OUTLIST UTILITY - DISPLAY JOB OUTPUT ---------- TUTORIAL\n&NEXT SELECTION ===>%SELECT                             &\n$\n$  THE&DISPLAY JOB OUTPUT$FUNCTION IS USED TO BROWSE OUTPUT FROM A HELD SYSOUT\n   QUEUE FOR A PARTICULAR JOB.  FOR MVS, THE DATA IS NOT DELETED FROM THE HELD\n   SYSOUT QUEUE.  HOWEVER, FOR SVS, THE DATA IS ALWAYS DELETED.  FOR THIS\n   REASON, IN THE SVS CASE, AFTER COMPLETION OF THE BROWSE FUNCTION, THE OUTLIST\n   PRINT MENU WILL BE AUTOMATICALLY DISPLAYED.\n   (USE THE&LIST JOB$OPTION IF YOU WISH TO OBTAIN THE NAMES AND ID'S (MVS ONLY)\n   OF CURRENTLY HELD JOBS)\n\n   FILL IN THE FOLLOWING FIELDS OF THE OUTLIST UTILITY MENU:\n       - ENTER&BLANK$IN THE SELECT OPTION FIELD\n       - ENTER THE&JOB NAME$IN THE APPROPRIATE FIELD\n       - ENTER THE&CLASS$IN THE APPROPRIATE FIELD\n       - ENTER THE&JOB ID$IN THE APPROPRIATE FIELD (MVS ONLY)\n           (THIS IS REQUIRED ONLY IF DUPLICATE JOBNAMES EXIST IN THE HELD\n           SYSOUT CLASS)\n\n   AFTER PRESSING THE&ENTER$KEY, THE DATA WILL BE DISPLAYED AND THE USER\n   WILL BE IN BROWSE MODE. ANY OF THE BROWSE OPTIONS CAN BE INVOKED.\n<ACTION>\n1 SELECT CHAR(36) CURSOR;\n2 SELECT CHAR(8) LIST(' ') RETURN(' ');\n3 * CHAR(8) INIT('TUOL    ');\n4 * CHAR(8) INIT('        ');\n5 * CHAR(8) INIT('        ');\n<END>\n./ ADD NAME=VTUOL01D 0100-80022-80022-1657-00022-00022-00000-TYD9835 00\n&TUTORIAL ------------- OUTLIST UTILITY - DELETE JOB OUTPUT ----------- TUTORIAL\n&NEXT SELECTION ===>%SELECT                             &\n$\n   THE&DELETE JOB OUTPUT$FUNCTION IS USED TO DELETE OUTPUT FROM A HELD SYSOUT\n   QUEUE FOR A PARTICULAR JOB.\n   (USE THE&LIST JOB$OPTION IF YOU WISH TO OBTAIN THE NAMES AND IDS (MVS ONLY)\n   OF CURRENTLY HELD JOBS)\n\n   FILL IN THE FOLLOWING FIELDS OF THE OUTLIST UTILITY MENU:\n       - ENTER&D$IN THE SELECT OPTION FIELD\n       - ENTER THE&JOB NAME$IN THE APPROPRIATE FIELD\n       - ENTER THE&CLASS$IN THE APPROPRIATE FIELD\n       - ENTER THE&JOB ID$IN THE APPROPRIATE FIELD (MVS ONLY)\n           (THIS IS REQUIRED ONLY IF DUPLICATE JOBNAMES EXIST IN THE HELD\n           SYSOUT CLASS)\n<ACTION>\n1 SELECT CHAR(36) CURSOR;\n2 SELECT CHAR(8) LIST(' ') RETURN(' ');\n3 * CHAR(8) INIT('TUOL    ');\n4 * CHAR(8) INIT('VTUOL01P');\n5 * CHAR(8) INIT('        ');\n<END>\n./ ADD NAME=VTUOL01L 0100-80022-80022-1658-00030-00030-00000-TYD9835 00\n&TUTORIAL --------- OUTLIST UTILITY - LIST JOB NAMES / ID'S ----------- TUTORIAL\n&NEXT SELECTION ===>%SELECT                             &\n$\n   THE&LIST JOBS$FUNCTION IS USED TO OBTAIN STATUS INFORMATION ON JOBS IN\n   YOUR SYSTEM.\n\n   FILL IN THE FOLLOWING FIELDS OF THE OUTLIST UTILITY MENU:\n       - ENTER&L$IN THE SELECT OPTION FIELD\n\n   THE&JOBNAME$PARAMETER IS HANDLED AS FOLLOWS:\n\n       -&JOBNAME$= BLANK - STATUS IS LISTED FOR ALL JOBS HAVING JOBNAMES\n                           CONSISTING OF YOUR USER ID FOLLOWED BY ONE CHARACTER.\n\n       -&JOBNAME$= USERID + ONE CHARACTER - STATUS IS LISTED FOR ALL JOBS HAVING\n                                            JOBNAMES CONSISTING OF YOUR USER ID\n                                            FOLLOWED BY ONE CHARACTER.\n\n       -&JOBNAME$= ANYTHING ELSE - STATUS IS LISTED FOR THE JOBNAME SPECIFIED.\n\n   THE JOB NAMES WILL BE DISPLAYED ON THE LOWER PART OF THE MENU. IF THE LIST\n   IS TOO LONG TO FIT ON THE SCREEN,&***$WILL BE WRITTEN AS THE LAST LINE.\n   BY PRESSING THE&ENTER$KEY THE NEXT PAGE OF DATA WILL BE DISPLAYED.\n<ACTION>\n1 SELECT CHAR(36) CURSOR;\n2 SELECT CHAR(8) LIST(' ') RETURN(' ');\n3 * CHAR(8) INIT('TUOL    ');\n4 * CHAR(8) INIT('VTUOL01D');\n5 * CHAR(8) INIT('        ');\n<END>\n./ ADD NAME=VTUOL01P 0100-80022-80022-1658-00025-00025-00000-TYD9835 00\n&TUTORIAL ------------- OUTLIST UTILITY - PRINT JOB OUTPUT ------------ TUTORIAL\n&NEXT SELECTION ===>%SELECT                             &\n$\n$  THE&PRINT JOB OUTPUT$FUNCTION IS USED TO PRINT OUTPUT FROM A HELD SYSOUT\n   QUEUE FOR A PARTICULAR JOB.  THE DATA IS AUTOMATICALLY DELETED FROM THE HELD\n   SYSOUT QUEUE WHENEVER THIS FUNCTION IS SELECTED.\n   (USE THE&LIST JOB$OPTION IF YOU WISH TO OBTAIN THE NAMES AND IDS (MVS ONLY)\n   OF CURRENTLY HELD JOBS)\n\n   FILL IN THE FOLLOWING FIELDS OF THE OUTLIST UTILITY MENU:\n       - ENTER&P$IN THE SELECT OPTION FIELD\n       - ENTER THE&JOB NAME$IN THE APPROPRIATE FIELD\n       - ENTER THE&CLASS$IN THE APPROPRIATE FIELD\n       - ENTER THE&JOB ID$IN THE APPROPRIATE FIELD (MVS ONLY)\n           (THIS IS REQUIRED ONLY IF DUPLICATE JOBNAMES EXIST IN THE\n           HELD SYSOUT CLASS)\n\n                           (CONTINUED ON NEXT PAGE)\n<ACTION>\n1 SELECT CHAR(36) CURSOR;\n2 SELECT CHAR(8) LIST(' ') RETURN(' ');\n3 * CHAR(8) INIT('TUOL    ');\n4 * CHAR(8) INIT('VTUOL01R');\n5 * CHAR(8) INIT('TUOL01P1');\n<END>\n./ ADD NAME=VUAA     0101-79269-80022-1511-00042-00087-00000-TYD9835 00\n&------------------------  ALLOCATE NEW DATASET  -------------------------------\n$DATASET NAME:#DSN                                         $\n$\n$   VOLUME SERIAL   &===>%VOL   $     (BLANK FOR AUTHORIZED DEFAULT VOLUME)\n$   SPACE UNITS     &===>%SPCU      $ (BLKS, TRKS OR CYLS)\n$   PRIMARY QUAN    &===>%PRIQ $      (IN ABOVE UNITS)\n$   SECONDARY QUAN  &===>%SECQ $      (IN ABOVE UNITS)\n$   DIRECTORY BLOCKS&===>%DIRB $      (ZERO FOR SEQUENTIAL DATASET)\n$   RECORD FORMAT   &===>%RECFM $\n$   RECORD LENGTH   &===>%LRECL$\n$   BLOCK SIZE      &===>%BLKSZ$\n<ACTION>\n 1 DSN     CHAR(44)  INIT($PARM1) NOCURSOR GENHELP(TUDA);\n 2 VOL     CHAR(8)   INIT($PARM2) CURSOR;\n 3 SPCU    CHAR(10)  INIT($PARM3) NOCURSOR\n           LIST  (CYLS     , TRKS  , BLKS  ,\n                  CYLINDERS, TRACKS, BLOCKS,\n                  CYLINDER , TRACK , BLOCK ,\n                  CYL      , TRK   , BLK   ,\n                  C        , T     , B     ,' ',*)\n           RETURN(CYLINDER , TRACK , BLOCK ,\n                  CYLINDER , TRACK , BLOCK ,\n                  CYLINDER , TRACK , BLOCK ,\n                  CYLINDER , TRACK , BLOCK ,\n                  CYLINDER , TRACK , BLOCK ,' ',' ');\n 4 PRIQ    FIXED(31) INIT($PARM4) NOCURSOR\n           LIST  (0  ,' ',*)\n           RETURN(0  ,0  );\n 5 SECQ    FIXED(31) INIT($PARM5) NOCURSOR\n           LIST  (0  ,' ',*)\n           RETURN(0  ,0  );\n 6 DIRB    FIXED(31) INIT($PARM6) NOCURSOR\n           LIST  (0  ,' ',*)\n           RETURN(0  ,0  );\n 7 RECFM   CHAR(6)   INIT($PARM7) NOCURSOR;\n 8 LRECL   FIXED(16) INIT($PARM8) NOCURSOR\n           LIST  (0  ,' ',*)\n           RETURN(0  ,0  );\n 9 BLKSZ   FIXED(16) INIT($PARM9) NOCURSOR\n           LIST  (0  ,' ',*)\n           RETURN(0  ,0  );\n<END>\n./ ADD NAME=VUDA1    0100-79269-79269-1311-00079-00079-00000-TYD9835 00\n&----------------------------  LIBRARY UTILITY  --------------------------------\n&SELECT OPTION ===>%CODE                                                       $\n&\n&   C$- COMPRESS DATASET                   &P$- PRINT MEMBER\n&   X$- PRINT INDEX LISTING                &R$- RENAME MEMBER\n&   L$- PRINT ENTIRE DATASET               &D$- DELETE MEMBER\n&   BLANK$- DISPLAY MEMBER LIST            &B$- BROWSE MEMBER\n$\n$SPF LIBRARY DATASET:\n$   PROJECT&===>%PROJECT $\n$   LIBRARY&===>%LIBRARY $\n$   TYPE   &===>%TYPE    $\n$   MEMBER &===>%MEMBER  $ (IF OPTION \"P\", \"R\", \"D\", OR \"B\" SELECTED)\n$   NEWNAME&===>%NEWNAME $ (IF OPTION \"R\" SELECTED)\n$\n$OTHER PARTITIONED OR SEQUENTIAL DATASET:\n$   DATASET NAME &===>%DSN                                                     $\n$   VOLUME SERIAL&===>%VOL   $  (IF NOT CATALOGED)\n$\n$DATASET PASSWORD&===>\u00acPSWD    $(IF PASSWORD PROTECTED)\n<ACTION>\n 1 CODE    CHAR(1)  INIT($PARM1) CURSOR   GENHELP(TUL)\n           LIST  (C,L,X,P,R,D,B,' ',*)\n           RETURN(Z,L,X,P,R,D,B,M  ,?);\n 2 PROJECT CHAR(8)  INIT($PARM2) NOCURSOR;\n 3 LIBRARY CHAR(8)  INIT($PARM3) NOCURSOR;\n 4 TYPE    CHAR(8)  INIT($PARM4) NOCURSOR;\n 5 DSN     CHAR(56) INIT($PARM5) NOCURSOR;\n 6 VOL     CHAR(6)  INIT($PARM6) NOCURSOR;\n 7 PSWD    CHAR(8)  INIT($PARM7) NOCURSOR;\n 8 MEMBER  CHAR(8)  INIT($PARM8) NOCURSOR;\n 9 NEWNAME CHAR(8)  INIT($PARM9) NOCURSOR;\n10 *       CHAR(8)  INIT('SPFCOPY '); - COMPRESS PGM NAME IF NOT IEBCOPY\n11 *       CHAR(8)  INIT('PPRINTED'); - PRINT MEMBER OPT/RESPONSE\n12 *       CHAR(8)  INIT('RRENAMED'); - RENAME MEMBER OPT/RESPONSE\n13 *       CHAR(8)  INIT('DDELETED'); - DELETE MEMBER OPT/RESPONSE\n14 *       CHAR(8)  INIT('B       '); - BROWSE MEMBER OPT/RESPONSE\n<END>\n***\n*** ORGINAL STATEMENTS\n***\n&----------------------------  LIBRARY UTILITY  --------------------------------\n&SELECT OPTION ===>%CODE                                                       $\n&\n&   C$- COMPRESS DATASET                   &P$- PRINT MEMBER\n&   X$- PRINT INDEX LISTING                &R$- RENAME MEMBER\n&   L$- PRINT ENTIRE DATASET               &D$- DELETE MEMBER\n&   BLANK$- DISPLAY MEMBER LIST            &B$- BROWSE MEMBER\n$\n$SPF LIBRARY DATASET:\n$   PROJECT&===>%PROJECT $\n$   LIBRARY&===>%LIBRARY $\n$   TYPE   &===>%TYPE    $\n$   MEMBER &===>%MEMBER  $ (IF OPTION \"P\", \"R\", \"D\", OR \"B\" SELECTED)\n$   NEWNAME&===>%NEWNAME $ (IF OPTION \"R\" SELECTED)\n$\n$OTHER PARTITIONED OR SEQUENTIAL DATASET:\n$   DATASET NAME &===>%DSN                                                     $\n$   VOLUME SERIAL&===>%VOL   $  (IF NOT CATALOGED)\n$\n$DATASET PASSWORD&===>\u00acPSWD    $(IF PASSWORD PROTECTED)\n<ACTION>\n 1 CODE    CHAR(1)  INIT($PARM1) CURSOR   GENHELP(TUL)\n           LIST  (C,L,X,P,R,D,B,' ',*)\n           RETURN(Z,L,X,P,R,D,B,M  ,?);\n 2 PROJECT CHAR(8)  INIT($PARM2) NOCURSOR;\n 3 LIBRARY CHAR(8)  INIT($PARM3) NOCURSOR;\n 4 TYPE    CHAR(8)  INIT($PARM4) NOCURSOR;\n 5 DSN     CHAR(56) INIT($PARM5) NOCURSOR;\n 6 VOL     CHAR(6)  INIT($PARM6) NOCURSOR;\n 7 PSWD    CHAR(8)  INIT($PARM7) NOCURSOR;\n 8 MEMBER  CHAR(8)  INIT($PARM8) NOCURSOR;\n 9 NEWNAME CHAR(8)  INIT($PARM9) NOCURSOR;\n10 *       CHAR(8)  INIT('        '); - COMPRESS PGM NAME IF NOT IEBCOPY\n11 *       CHAR(8)  INIT('PPRINTED'); - PRINT MEMBER OPT/RESPONSE\n12 *       CHAR(8)  INIT('RRENAMED'); - RENAME MEMBER OPT/RESPONSE\n13 *       CHAR(8)  INIT('DDELETED'); - DELETE MEMBER OPT/RESPONSE\n14 *       CHAR(8)  INIT('B       '); - BROWSE MEMBER OPT/RESPONSE\n<END>\n./ ADD NAME=VUOL01   0100-80022-80022-1555-00055-00055-00000-TYD9835 00\n&------------------  PRODUCTION CONTROL OUTPUT FUNCTIONS  ----------------------\n&SELECT OPTION ===>%TCOD                                                       $\n&\n&   L$- LIST JOB NAMES/ID'S VIA THE TSO STATUS COMMAND\n&   D$- DELETE JOB OUTPUT AND SAVE IN CONTROL PDS\n&   P$- PRINT JOB OUTPUT AND SAVE IN CONTROL PDS\n&   BLANK$- DISPLAY JOB OUTPUT AND SAVE IN CONTROL PDS\n$\n$FOR JOB TO BE SELECTED:\n$   JOBNAME&===>%TJNM    $\n$   CLASS  &===>%TCL1$\n$   JOBID  &===>%TJID    $\n$\n$FOR JOB TO BE PRINTED:\n$       OUTPUT CLASS&===>%TCL2$\n$\n<ACTION>\n 1 TCOD    CHAR(1)  NOCURSOR   KEY(SW1)\n           LIST  (' ', * )\n           RETURN(' ','\u00ac');\n 2 TCOD    CHAR(1)  NOCURSOR   KEY(SW2)\n           LIST  ( D , * )\n           RETURN(' ','\u00ac');\n 4 TCOD    CHAR(1)  NOCURSOR   KEY(SW3)\n           LIST  ( L , * )\n           RETURN(' ','\u00ac');\n 5 TCOD    CHAR(1)  NOCURSOR   KEY(SW4)\n           LIST  ( L , * )\n           RETURN('\u00ac',' ');\n 6 TCOD    CHAR(1)  NOCURSOR   KEY(SW5)\n           LIST  ( P , * )\n           RETURN(' ','\u00ac');\n 7 TCOD    CHAR(1)  INIT(' ') CURSOR   GENHELP(VTUOL)\n           LIST  (L,D,P,' ',*)\n           RETURN(L,D,P, B ,?);\n 8 TJNM    CHAR(1)  NOCURSOR   KEY(SW6)\n           LIST  (' ', *)\n           RETURN('\u00ac',' ');\n 9 TJNM    CHAR(1)  NOCURSOR   KEY(SW7)\n           LIST  (' ', *)\n           RETURN(' ','\u00ac');\n10 TJNM    CHAR(8)  INIT($PARM10) NOCURSOR;\n11 TCL1    CHAR(1)  NOCURSOR   KEY(SW8)\n           LIST  (' ', * )\n           RETURN('\u00ac',' ');\n12 TCL1    CHAR(1)  INIT($PARM12) NOCURSOR;\n13 TJID    CHAR(1)  NOCURSOR   KEY(SW9)\n           LIST  (' ', *)\n           RETURN('\u00ac',' ');\n14 TJID    CHAR(1)  NOCURSOR   KEY(SWA)\n           LIST  (' ', *)\n           RETURN(' ','\u00ac');\n15 TJID    CHAR(8)  INIT($PARM15) NOCURSOR;\n16 TCL2    CHAR(1)  INIT($PARM16) NOCURSOR;\n<END>\n./ ADD NAME=VUTIL    0100-79269-79269-1311-00062-00062-00000-TYD9835 00\n&----------------------  UTILITY SELECTION MENU  -------------------------------\n&SELECT OPTION ===>%PRI                                                        $\n&\n&   1 $LIBRARY   - LIBRARY UTILITIES:\n$                           PRINT INDEX LISTING OR ENTIRE DATASET\n$                           PRINT, RENAME, OR DELETE MEMBERS\n$                           COMPRESS DATASET\n&   2 $DATASET   - DATASET UTILITIES:\n$                           DISPLAY DATASET INFORMATION\n$                           ALLOCATE, RENAME, OR DELETE ENTIRE DATASET\n$                           CATALOG OR UNCATALOG DATASET\n&   3 $MOVE/COPY - MOVE OR COPY MEMBERS OR DATASETS\n&   4 $CATALOG   - CATALOG MANAGEMENT:\n$                           DISPLAY OR PRINT CATALOG ENTRIES\n$                           INITIALIZE OR DELETE PROJECT CATALOG POINTER\n&   5 $RESET     - RESET STATISTICS FOR MEMBERS OF SPF LIBRARY DATASET\n&   6 $HARDCOPY  - INITIATE HARDCOPY OUTPUT\n&   7 $VTOC      - DISPLAY OR PRINT VTOC ENTRIES FOR A DASD VOLUME\n&   8 $OUTLIST   - DISPLAY, DELETE, OR PRINT HELD JOB OUTPUT\n<ACTION>\n1 PRI   CHAR(8) CURSOR    GENHELP(TU)\n        LIST   (1       ,2       ,3       ,4       ,5       ,6       ,\n                7       ,8       ,9       ,' '     ,*       )\n        RETURN (SPFUDA  ,SPFUDA  ,SPFUMC  ,SPFUCA  ,SPFURS  ,SPFUHC  ,\n                SPFUVT  ,SPFUOL  ,SPFUTIL ,' '     ,?       );\n2 PRI   CHAR(8)\n        LIST   (1       ,2       ,8       ,9       ,*       )\n        RETURN (UDA1    ,UDA2    ,UOL01   ,VNOTSUP ,' '     );\n<END>\n***\n*** ORGINAL STATEMENTS\n***\n&----------------------  UTILITY SELECTION MENU  -------------------------------\n&SELECT OPTION ===>%PRI                                                        $\n&\n&   1 $LIBRARY   - LIBRARY UTILITIES:\n$                           PRINT INDEX LISTING OR ENTIRE DATASET\n$                           PRINT, RENAME, OR DELETE MEMBERS\n$                           COMPRESS DATASET\n&   2 $DATASET   - DATASET UTILITIES:\n$                           DISPLAY DATASET INFORMATION\n$                           ALLOCATE, RENAME, OR DELETE ENTIRE DATASET\n$                           CATALOG OR UNCATALOG DATASET\n&   3 $MOVE/COPY - MOVE OR COPY MEMBERS OR DATASETS\n&   4 $CATALOG   - CATALOG MANAGEMENT:\n$                           DISPLAY OR PRINT CATALOG ENTRIES\n$                           INITIALIZE OR DELETE PROJECT CATALOG POINTER\n&   5 $RESET     - RESET STATISTICS FOR MEMBERS OF SPF LIBRARY DATASET\n&   6 $HARDCOPY  - INITIATE HARDCOPY OUTPUT\n&   7 $VTOC      - DISPLAY OR PRINT VTOC ENTRIES FOR A DASD VOLUME\n&   8 $OUTLIST   - DISPLAY, DELETE, OR PRINT HELD JOB OUTPUT\n&   9 $SCRIPT/VS - FORMAT, DISPLAY, AND OPTIONALLY PRINT SCRIPT TEXT\n<ACTION>\n1 PRI   CHAR(8) CURSOR    GENHELP(TU)\n        LIST   (1       ,2       ,3       ,4       ,5       ,6       ,\n                7       ,8       ,9       ,' '     ,*       )\n        RETURN (SPFUDA  ,SPFUDA  ,SPFUMC  ,SPFUCA  ,SPFURS  ,SPFUHC  ,\n                SPFUVT  ,SPFUOL  ,SPFUSC  ,' '     ,?       );\n2 PRI   CHAR(8)\n        LIST   (1       ,2       ,8       ,9       ,*       )\n        RETURN (UDA1    ,UDA2    ,UOL01   ,SCRPTA  ,' '     );\n<END>\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "MSGSF": {"ttr": 52231, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x02\\x01\\x19#\\x0f\\x01\\x19#\\x0f\\x14W\\x00T\\x00T\\x00\\x00\\xc6\\xc2`\\xf8\\xf0@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2019-08-18T00:00:00", "modifydate": "2019-08-18T14:57:02", "lines": 84, "newlines": 84, "modlines": 0, "user": "FB-80"}, "text": "./ ADD NAME=V01      0108-79269-79299-0736-00027-00003-00000-TYD9801 00\nV011 *        ------- FETCH PROC ERROR  ALARM\nCHARACTER STRING 'DATASET(' NOT FOUND IN COMMAND\n\nV012 *        ------ PAN LIBRARY ERROR  ALARM\nRDJFCB FAILED FOR PANVALET LIBRARY. MAKE SURE PAN LIBRARY IS ALLOCATED.\n\nV013 *        --------- INVALID OPTION  ALARM\nVALID OPTIONS ARE ' ','E','S','D'\n\nV014 *        ---- PROCESSING COMPLETE\nSPF/PANVALET EDIT HAS COMPLETED NORMALLY\n\nV015 *        ----- RETURN CODE <1F24>  ALARM\nSPF/PAN EDIT HAS COMPLETED WITH RETURN CODE <1F24> DECIMAL.\n\nV016 *        -- ATTENTION TERMINATION\nSPF/PAN EDIT TERMINATED DUE TO ATTENTION KEY BEING PRESSED.\n\nV017 *        ---- ABEND CODE <1X3>     ALARM\nSPF/PAN EDIT HAS ABENDED. COMPLETION CODE <1X3> HEX.\n\nV018 *        ---- GENACB ERR <1X4>     ALARM\nRECORD ERROR CODE AND CONTACT SOFTWARE PROGRAMMING.\n\nV019 *        ---- OPEN ERROR <1X4>     ALARM\nRECORD ERROR CODE AND CONTACT SOFTWARE PROGRAMMING.\n\n./ ADD NAME=V02      0110-79290-79304-0917-00030-00027-00000-TYD9801 00\nV020 *        - GENRPL ERR <1X4>        ALARM\nRECORD ERROR CODE AND CONTACT SOFTWARE PROGRAMMING.\n\nV021 *        ------- PANCTL I/O ERROR  ALARM\nCONTACT SOFTWARE PROGRAMMING.\n\nV022 *         PANCTL ERR <1X4>         ALARM\nRECORD ERROR CODE AND CONTACT SOFTWARE PROGRAMMING.\n\nV023 VTPANEX  MEMBER OWNED BY <1C7>     ALARM\nSPECIFIED PANVALET MEMBER ALREADY RETRIEVED BY <1C7>.\n\nV024 VTPANEX  ------- MEMBER NOT OWNED  ALARM\nSPECIFIED PANVALET MEMBER HAS NOT BEEN RETRIEVED FOR EDIT.\n\nV025 VTPANEX  ----- PAN STATUS NOT TEA  ALARM\nMEMBER STATUS IS <1C3>. MEMBER RETRIEVED, BUT CANNOT BE SAVED.\n\nV026 *        --- MUST HAVE SPF MEMBER  ALARM\nPAN MEMBER NOT RETRIEVED TO THIS SPF DATASET. MEMBER REQUIRED.\n\nV027 *        - UNDETERMINED PAN ERROR  ALARM\nPREVIOUS MESSAGES SHOULD EXPLAIN, IF NOT, CONTACT SOFTWARE PROGRAMMING.\n\nV028 *         PANE EDIT PROGRAM ERROR  ALARM\nA 'SNO' ERROR HAS OCCURRED.  CONTACT SOFTWARE PROGRAMMING.\n\nV029 *        - PAN LIBRARY OPEN ERROR  ALARM\nUNABLE TO OPEN PAN LIBRARY. MAKE SURE PAN DDNAME IS CORRECT.\n\n./ ADD NAME=V03      0104-79304-80107-0808-00024-00030-00000-$CSG05  00\nV030 *        --- PAN MEMBER NOT FOUND  ALARM\nMEMBER NOT FOUND OR PAN DIRECTORY ERROR.\n\nV031 *         PAN ERROR CODE PV0<1F8>  ALARM\nSEE PANVALET MESSAGE PV0<1F8> FOR ERROR DESCRIPTION.\n\nV032 *        -- I/O ERROR ON SFPCNTLX  ALARM\nRETRY.  IF ERROR RE-OCCURS LOGOFF AND LOGON AGAIN.\n\nV033 *        --- ACCESS CODE REQUIRED  ALARM\nSPECIFIED PANVALET MEMBER REQUIRES ACCESS CODE.\n\nV034 *        ----- NO DATA TO DISPLAY  ALARM\nTHE TEMPORARY WORK FILE IS EMPTY. THIS SHOULD NOT OCCUR.\n\nV035 *        ---- PROCESSING COMPLETE\nPANVALET DISPLAY PROCESSING HAS COMPLETED NORMALLY.\n\nV036 *        ---- SECURITY LEVEL GT 1  ALARM\nPAN DISPLAY DOES NOT SUPPORT SECURITY LEVELS GREATER THAN 1.\n\nV037 *        -- INCORRECT ACCESS CODE  ALARM\nACCESS CODE SUPPLIED IS INCORRECT.\n\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "OBJ": {"ttr": 52234, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00$\\x01\\x19#\\x0f\\x01\\x19#\\x0f\\x14A\\x0c}\\x0c}\\x00\\x00\\xe6\\xe8\\xd3\\xc2\\xe4\\xd9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2019-08-18T00:00:00", "modifydate": "2019-08-18T14:41:24", "lines": 3197, "newlines": 3197, "modlines": 0, "user": "WYLBUR"}, "mimetype": "application/octet-stream", "datatype": "binary", "extension": ".bin"}, "PDSLOAD": {"ttr": 53514, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x08\\x01\\x17\\x05?\\x01\\x17\\x05?  \\x00}\\x00}\\x00\\x00\\xd3\\xd6\\xc1\\xc4\\xd3\\xc9\\xc2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2017-02-22T00:00:00", "modifydate": "2017-02-22T20:20:08", "lines": 125, "newlines": 125, "modlines": 0, "user": "LOADLIB"}, "mimetype": "application/xmit", "datatype": "binary", "extension": ".xmi"}, "PROCS": {"ttr": 53763, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00$\\x01\\x19#\\x0f\\x01\\x19#\\x0f\\x14A\\x01\\xb5\\x01\\xb5\\x00\\x00\\xe6\\xe8\\xd3\\xc2\\xe4\\xd9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2019-08-18T00:00:00", "modifydate": "2019-08-18T14:41:24", "lines": 437, "newlines": 437, "modlines": 0, "user": "WYLBUR"}, "text": "./ ADD NAME=FOR01    0105-79360-79361-1343-00023-00024-00004-$CSG00  00\nPASSWORD &PSWD\nSCANLIB  &PRJ1..&LIB1..&ASMT.(&MEM)\nSCANLIB  &PRJ1..&LIB2..&ASMT.(&MEM)\nSCANLIB  &PRJ1..&LIB3..&ASMT.(&MEM)\nSCANLIB  &PRJ1..&LIB4..&ASMT.(&MEM)\nCOMMAND  ASM '&SCANLIB'\n /&PSWD\n LIB('&PRJ1..&LIB2..&ASMT'\n /&PSWD                                &SW1\n ,'&PRJ1..&LIB3..&ASMT'\n /&PSWD                                &SW2\n ,'&PRJ1..&LIB4..&ASMT'\n /&PSWD                                &SW3\n ,'SYS1.MACLIB'\n ,'SYS1.AMODGEN'\n )\n LOAD('&PRJ1..&LIB1..OBJ(&MEM)'\n /&PSWD\n )\n PRINT(&LID)\n &FASM\nLOG      ASSEMBLY --------- TO &PRJ1..&LIB1..OBJ(&MEM)\nEND\n./ ADD NAME=JOB01    0101-80060-80133-1715-00032-00032-00004-$SYS00  00\n//SCAN   EXEC  PGM=SPFSCAN,PARM='&MEM',COND=(12,LE)\n//*--------------------------------------------------------------------\nLOG  ASSEMBLY --------- TO &PRJ1..&LIB1..OBJ(&MEM)\n//*--------------------------------------------------------------------\n//IN       DD  DSN=&PRJ1..&LIB1..&ASMT,DISP=SHR\n//         DD  DSN=&PRJ1..&LIB2..&ASMT,DISP=SHR\n//         DD  DSN=&PRJ1..&LIB3..&ASMT,DISP=SHR\n//         DD  DSN=&PRJ1..&LIB4..&ASMT,DISP=SHR\n//OUT      DD  UNIT=SYSDA,DISP=(NEW,PASS),SPACE=(CYL,(2,2)),\n//             DSN=&&TEMP1\n//*--------------------------------------------------------------------\n//ASM    EXEC  PGM=IFOX00,COND=(12,LE),\n// PARM=(&BASMT,\n//   '&BASM')\n//SYSPRINT DD  SYSOUT=(&BCLA)                         &SW1\n//SYSPRINT DD  DSN=&TSOPFX..&LID..LIST,UNIT=SYSDA,    &SW2\n//             SPACE=(CYL,(2,2)),DISP=(MOD,CATLG),    &SW2\n//             DCB=(RECFM=FBA,LRECL=121,BLKSIZE=3146) &SW2\n//SYSIN    DD  DSN=&&TEMP1,DISP=(OLD,DELETE)\n//SYSLIB   DD  DSN=SYS1.MACLIB,DISP=SHR\n//         DD  DSN=&PRJ1..&LIB1..&ASMT,DISP=SHR\n//         DD  DSN=&PRJ1..&LIB2..&ASMT,DISP=SHR\n//         DD  DSN=&PRJ1..&LIB3..&ASMT,DISP=SHR\n//         DD  DSN=&PRJ1..&LIB4..&ASMT,DISP=SHR\n//SYSUT1   DD  UNIT=VIO,SPACE=(CYL,(2,2))\n//SYSUT2   DD  UNIT=VIO,SPACE=(CYL,(2,2))\n//SYSUT3   DD  UNIT=VIO,SPACE=(CYL,(2,2))\n//SYSGO    DD  DSN=&PRJ1..&LIB1..OBJ(&MEM),DISP=OLD\n//SYSTERM  DD  DSN=&TSOPFX..&MEM..TERM,UNIT=SYSDA,    &SW3\n//             SPACE=(CYL,(1,1)),DISP=(MOD,CATLG)     &SW3\n//*--------------------------------------------------------------------\nEND\n./ ADD NAME=JOB02    0101-80060-80133-1716-00032-00032-00005-$SYS00  00\n//SCAN   EXEC  PGM=SPFSCAN,PARM='&MEM',COND=(12,LE)\n//*--------------------------------------------------------------------\nLOG  COBOL COMPILE ---- TO &PRJ1..&LIB1..OBJ(&MEM)\n//*--------------------------------------------------------------------\n//IN       DD  DSN=&PRJ1..&LIB1..&COBT,DISP=SHR\n//         DD  DSN=&PRJ1..&LIB2..&COBT,DISP=SHR\n//         DD  DSN=&PRJ1..&LIB3..&COBT,DISP=SHR\n//         DD  DSN=&PRJ1..&LIB4..&COBT,DISP=SHR\n//OUT      DD  UNIT=SYSDA,DISP=(NEW,PASS),SPACE=(CYL,(2,2)),\n//             DSN=&&TEMP1\n//*--------------------------------------------------------------------\n//COBOL  EXEC  PGM=IKFCBL00,COND=(12,LE),\n// PARM=(&BCOBT,\n//   '&BCOB')\n//SYSPRINT DD  SYSOUT=(&BCLA)                         &SW1\n//SYSPRINT DD  DSN=&TSOPFX..&LID..LIST,UNIT=SYSDA,    &SW2\n//             SPACE=(CYL,(2,2)),DISP=(MOD,CATLG),    &SW2\n//             DCB=(RECFM=FBA,LRECL=121,BLKSIZE=3146) &SW2\n//SYSIN    DD  DSN=&&TEMP1,DISP=(OLD,DELETE)\n//SYSPUNCH DD  DUMMY\n//SYSUT1   DD  UNIT=VIO,SPACE=(CYL,(2,2))\n//SYSUT2   DD  UNIT=VIO,SPACE=(CYL,(2,2))\n//SYSUT3   DD  UNIT=VIO,SPACE=(CYL,(2,2))\n//SYSUT4   DD  UNIT=VIO,SPACE=(CYL,(2,2))\n//SYSUT5   DD  DSN=&PRJ1..&LIB1..SYM(&MEM),DISP=OLD   &SW3\n//SYSLIB   DD  DSN=&PRJ1..&LIB1..&COBT,DISP=SHR\n//         DD  DSN=&PRJ1..&LIB2..&COBT,DISP=SHR\n//         DD  DSN=&PRJ1..&LIB3..&COBT,DISP=SHR\n//         DD  DSN=&PRJ1..&LIB4..&COBT,DISP=SHR\n//SYSLIN   DD  DSN=&PRJ1..&LIB1..OBJ(&MEM),DISP=OLD\n//*--------------------------------------------------------------------\nEND\n./ ADD NAME=JOB03    0101-80060-80133-1716-00021-00021-00001-$SYS00  00\n//SCAN   EXEC  PGM=SPFSCAN,PARM='&MEM',COND=(12,LE)\n//*--------------------------------------------------------------------\nLOG  FORTRAN COMPILE -- TO &PRJ1..&LIB1..OBJ(&MEM)\n//*--------------------------------------------------------------------\n//IN       DD  DSN=&PRJ1..&LIB1..&FORT,DISP=SHR\n//         DD  DSN=&PRJ1..&LIB2..&FORT,DISP=SHR\n//         DD  DSN=&PRJ1..&LIB3..&FORT,DISP=SHR\n//         DD  DSN=&PRJ1..&LIB4..&FORT,DISP=SHR\n//OUT      DD  UNIT=SYSDA,DISP=(NEW,PASS),SPACE=(CYL,(2,2)),\n//             DSN=&&TEMP1\n//*--------------------------------------------------------------------\n//FORT   EXEC  PGM=IGIFORT,COND=(12,LE),\n// PARM='&BFOR'\n//SYSPRINT DD  SYSOUT=(&BCLA)                         &SW1\n//SYSPRINT DD  DSN=&TSOPFX..&LID..LIST,UNIT=SYSDA,    &SW2\n//             SPACE=(CYL,(2,2)),DISP=(MOD,CATLG),    &SW2\n//             DCB=(RECFM=FBSA,LRECL=120,BLKSIZE=3120) &SW2\n//SYSIN    DD  DSN=&&TEMP1,DISP=(OLD,DELETE)\n//SYSLIN   DD  DSN=&PRJ1..&LIB1..OBJ(&MEM),DISP=OLD\n//*--------------------------------------------------------------------\nEND\n./ ADD NAME=JOB05    0101-80060-80133-1714-00026-00026-00002-$SYS00  00\n//SCAN   EXEC  PGM=SPFSCAN,PARM='&MEM',COND=(12,LE)\n//*--------------------------------------------------------------------\nLOG  PLI OPT COMPILE -- TO &PRJ1..&LIB1..OBJ(&MEM)\n//*--------------------------------------------------------------------\n//IN       DD  DSN=&PRJ1..&LIB1..&PLIT,DISP=SHR\n//         DD  DSN=&PRJ1..&LIB2..&PLIT,DISP=SHR\n//         DD  DSN=&PRJ1..&LIB3..&PLIT,DISP=SHR\n//         DD  DSN=&PRJ1..&LIB4..&PLIT,DISP=SHR\n//OUT      DD  UNIT=SYSDA,DISP=(NEW,PASS),SPACE=(CYL,(2,2)),\n//             DSN=&&TEMP1\n//*--------------------------------------------------------------------\n//PLIO   EXEC  PGM=IEL0AA,COND=(12,LE),\n// PARM='&BPLO'\n//SYSPRINT DD  SYSOUT=(&BCLA)                         &SW1\n//SYSPRINT DD  DSN=&TSOPFX..&LID..LIST,UNIT=SYSDA,    &SW2\n//             SPACE=(CYL,(2,2)),DISP=(MOD,CATLG),    &SW2\n//             DCB=(RECFM=VBA,LRECL=125,BLKSIZE=3129) &SW2\n//SYSIN    DD  DSN=&&TEMP1,DISP=(OLD,DELETE)\n//SYSUT1   DD  UNIT=VIO,SPACE=(CYL,(2,2))\n//SYSLIB   DD  DSN=&PRJ1..&LIB1..&PLIT,DISP=SHR\n//         DD  DSN=&PRJ1..&LIB2..&PLIT,DISP=SHR\n//         DD  DSN=&PRJ1..&LIB3..&PLIT,DISP=SHR\n//         DD  DSN=&PRJ1..&LIB4..&PLIT,DISP=SHR\n//SYSLIN   DD  DSN=&PRJ1..&LIB1..OBJ(&MEM),DISP=OLD\n//*--------------------------------------------------------------------\nEND\n./ ADD NAME=JOB06    0101-80060-80133-1714-00036-00036-00001-$SYS00  00\n//SCAN   EXEC  PGM=SPFSCAN,PARM='&MEM',COND=(12,LE)\n//*--------------------------------------------------------------------\nLOG  LINKAGE EDIT ----- TO &PRJ1..&LIB1..LOAD(&MEM)\n//*--------------------------------------------------------------------\n//IN        DD DSN=&PRJ1..&LIB1..&LNKT,DISP=SHR\n//          DD DSN=&PRJ1..&LIB2..&LNKT,DISP=SHR\n//          DD DSN=&PRJ1..&LIB3..&LNKT,DISP=SHR\n//          DD DSN=&PRJ1..&LIB4..&LNKT,DISP=SHR\n//OUT       DD UNIT=SYSDA,DISP=(NEW,PASS),SPACE=(CYL,(2,2)),\n//             DSN=&&TEMP1\n//*--------------------------------------------------------------------\n//LINK    EXEC PGM=IEWL,COND=(12,LE),\n// PARM=(&BLNKT,\n//   '&BLNK')\n//SYSPRINT DD  SYSOUT=(&BCLA)                         &SW1\n//SYSPRINT DD  DSN=&TSOPFX..&LID..LINKLIST,UNIT=SYSDA, &SW2\n//             SPACE=(CYL,(2,2)),DISP=(MOD,CATLG),    &SW2\n//             DCB=(RECFM=FBA,LRECL=121,BLKSIZE=3146) &SW2\n//SYSLIN   DD DSN=&&TEMP1,DISP=(OLD,DELETE)\n//OBJECT   DD DSN=&PRJ1..&LIB1..OBJ,DISP=SHR\n//         DD DSN=&PRJ1..&LIB2..OBJ,DISP=SHR\n//         DD DSN=&PRJ1..&LIB3..OBJ,DISP=SHR\n//         DD DSN=&PRJ1..&LIB4..OBJ,DISP=SHR\n//SYSLIB   DD DSN=&PRJ1..&LIB1..LOAD,DISP=SHR\n//         DD DSN=&PRJ1..&LIB2..LOAD,DISP=SHR\n//         DD DSN=&PRJ1..&LIB3..LOAD,DISP=SHR\n//         DD DSN=&PRJ1..&LIB4..LOAD,DISP=SHR\n//       DD DSN=&BSL1,DISP=SHR\n//       DD DSN=&BSL2,DISP=SHR\n//SYSLMOD  DD DSN=&PRJ1..&LIB1..LOAD(&MEM),\n//            DISP=SHR,DCB=(BLKSIZE=3072)\n//SYSUT1   DD UNIT=SYSDA,DISP=NEW,SPACE=(CYL,(2,2))\n//SYSTERM  DD DSN=&TSOPFX..&MEM..TERM,DISP=(MOD,CATLG),    &SW3\n//            UNIT=SYSDA,SPACE=(CYL,(1,1))                 &SW3\n//*--------------------------------------------------------------------\nEND\n./ ADD NAME=V$AR     0113-80014-80017-1743-00025-00026-00024-TYD9801 00\nCOMMAND  $AR                                               &SW1\n &DSN                                                      &SW1\n RETPD(&RET)                                          &SW4 &SW1\n QUAL(&QUAL)                                          &SW5 &SW1\n PERM                                                 &SW6 &SW1\n COM('&CMT')                                          &SW7 &SW1\nCOMMAND  $AI                                               &SW2\n DA(&DSN)                                             &SW8 &SW2\n CYCLE(&CYC)                                          &SW9 &SW2\n COM                                                  &SWB &SW2\nCOMMAND  $$RA                                              &SW3\n &DSN                                                      &SW3\nLOG      $AR                                               &SW1\nLOG      &DSN                                              &SW1\nLOG      RETPD(&RET)                                  &SW4 &SW1\nLOG      QUAL(&QUAL)                                  &SW5 &SW1\nLOG      PERM                                         &SW6 &SW1\nLOG      COM('&CMT')                                  &SW7 &SW1\nLOG      $AI                                               &SW2\nLOG      DA(&DSN)                                     &SW8 &SW2\nLOG      CYCLE(&CYC)                                  &SW9 &SW2\nLOG      COM                                          &SWB &SW2\nLOG      $$RA                                              &SW3\nLOG      &DSN                                              &SW3\nEND\n./ ADD NAME=V$BK     0116-80014-80018-1643-00023-00026-00022-TYD9801 00\nCOMMAND  $BK                                               &SW1\n &DSN                                                      &SW1\n RETPD(&RET)                                          &SW4 &SW1\n QUAL(&QUAL)                                          &SW5 &SW1\n COM('&CMT')                                          &SW7 &SW1\nCOMMAND  $BI                                               &SW2\n DA(&DSN)                                             &SW8 &SW2\n CYCLE(&CYC)                                          &SW9 &SW2\n COM                                                  &SWB &SW2\nCOMMAND  $$RB                                              &SW3\n &DSN                                                      &SW3\nLOG      $BK                                               &SW1\nLOG      &DSN                                              &SW1\nLOG      RETPD(&RET)                                  &SW4 &SW1\nLOG      QUAL(&QUAL)                                  &SW5 &SW1\nLOG      COM('&CMT')                                  &SW7 &SW1\nLOG      $BI                                               &SW2\nLOG      DA(&DSN)                                     &SW8 &SW2\nLOG      CYCLE(&CYC)                                  &SW9 &SW2\nLOG      COM                                          &SWB &SW2\nLOG      $$RB                                              &SW3\nLOG      &DSN                                              &SW3\nEND\n./ ADD NAME=V$SM     0108-80014-80102-1643-00025-00017-00014-$CSG05  00\nCOMMAND   $SM                                              &SW1\n DSN(&DSN)                                       &SW5 &SW3 &SW1\n INDEX(&DSN)                                     &SW4 &SW3 &SW1\n LIST NOTAPE                                               &SW1\n &C.COMPRESS &B.BACKUP                      &SW3 &SW5 &SW9 &SW1\n &C.COMPRESS &B.BACKUP RLSE                 &SW3 &SW5 &SW7 &SW1\n &C.COMPRESS &B.BACKUP RLSE                      &SW4 &SW7 &SW1\n SAVE(&S)                                        &SW6 &SW7 &SW1\n RESET                                                &SW8 &SW1\nCOMMAND  $US                                               &SW2\n &DSN                                            &SW5 &SW3 &SW2\n U(&DSN)                                         &SW4 &SW3 &SW2\nLOG       $SM                                              &SW1\nLOG      DSN(&DSN)                               &SW5 &SW3 &SW1\nLOG      INDEX(&DSN)                             &SW4 &SW3 &SW1\nLOG      LIST NOTAPE                                       &SW1\nLOG      &C.COMPRESS &B.BACKUP              &SW3 &SW5 &SW9 &SW1\nLOG      &C.COMPRESS &B.BACKUP RLSE         &SW3 &SW5 &SW7 &SW1\nLOG      &C.COMPRESS &B.BACKUP RLSE              &SW4 &SW7 &SW1\nLOG      SAVE(&S)                                &SW6 &SW7 &SW1\nLOG      RESET                                        &SW8 &SW1\nLOG      $US                                               &SW2\nLOG      &DSN                                    &SW5 &SW3 &SW2\nLOG     U(&DSN)                                  &SW4 &SW3 &SW2\nEND\n./ ADD NAME=VJTIP    0103-79269-80105-1150-00026-00026-00005-$CSG05  00\nCOMMAND  SHOW                               &SW2 &SW3 &SW4 &SW5 &SW6\nCOMMAND  SHOW  J(&TJNM)                     &SW1 &SW3 &SW4 &SW5 &SW6\nCOMMAND  ROUTE J(&TJNM)                          &SW1 &SW2 &SW5 &SW6\nCOMMAND  FETCH J(&TJNM)                          &SW1 &SW2 &SW3 &SW4\n J(&TJNM)                                   &SW2 &SW3 &SW4 &SW5 &SW6\n DDNAME(&TDDNAME)                           &SW1 &SW2 &SW3 &SW4 &SW7\n PN(&TPN)                                   &SW1 &SW2 &SW3 &SW4 &SW8\n COLUMN(&TC1,&TC2)                          &SW1 &SW2 &SW3 &SW4 &SW6\n DEST                                       &SW1 &SW3 &SW4 &SW5 &SW6\n PURGE                                      &SW1 &SW2 &SW4 &SW5 &SW6\n OUTPUT(&TDST)                              &SW1 &SW2 &SW3 &SW5 &SW6\n DATASET(*)                                 &SW1 &SW2 &SW3 &SW4 &SW6\n DATASET('&TSOPXID..SPFTEMPX.LIST')         &SW1 &SW2 &SW3 &SW4 &SW5\nLOG      SHOW                               &SW2 &SW3 &SW4 &SW5 &SW6\nLOG      SHOW  J(&TJNM)                     &SW1 &SW3 &SW4 &SW5 &SW6\nLOG      ROUTE J(&TJNM)                          &SW1 &SW2 &SW5 &SW6\nLOG      FETCH J(&TJNM)                          &SW1 &SW2 &SW3 &SW4\nLOG      DDNAME(&TDDNAME)                   &SW1 &SW2 &SW3 &SW4 &SW7\nLOG      PN(&TPN)                           &SW1 &SW2 &SW3 &SW4 &SW8\nLOG      COLUMN(&TC1,&TC2)                  &SW1 &SW2 &SW3 &SW4 &SW6\nLOG      DEST                               &SW1 &SW3 &SW4 &SW5 &SW6\nLOG      PURGE                              &SW1 &SW2 &SW4 &SW5 &SW6\nLOG      OUTPUT(&TDST)                      &SW1 &SW2 &SW3 &SW5 &SW6\nLOG      DATASET(*)                         &SW1 &SW2 &SW3 &SW4 &SW6\nLOG      DATASET('&TSOPXID..SPFTEMPX.LIST') &SW1 &SW2 &SW3 &SW4 &SW5\nEND\n./ ADD NAME=VPANE    0113-79269-79338-1000-00021-00026-00020-TYD9801 00\nCOMMAND  PAN  RETRIEVE &VPANNAM                                 &SW1\nCOMMAND  PAN  STORE   &VPANNAM                                  &SW2\nCOMMAND  PANCTLM DEQUEUE FIRST(&VPANNAM) DD(&VDDNAME)           &SW3\nCOMMAND  PANCTLM SHOW    FIRST(&VPANNAM) DD(&VDDNAME)           &SW4\n         ACCESS(&VACC)                                          &SW5\n         CONTROL(&VCTL)                                         &SW6\n         DDNAME(&VDDNAME)                                       &SW1\n         DATASET('&PRJ0..&LIB0..&TYP0.(&MEMBER)')               &SW1\n         DDNAME(&VDDNAME)                                       &SW2\n         DATASET('&PRJ0..&LIB0..&TYP0.(&MEMBER)')               &SW2\nLOG      PAN RETRIEVE &VPANNAM                                  &SW1\nLOG      PAN STORE   &VPANNAM                                   &SW2\nLOG      PANCTLM DEQUEUE FIRST(&VPANNAM)    DD(&VDDNAME)        &SW3\nLOG      PANCTLM SHOW    FIRST(&VPANNAM)    DD(&VDDNAME)        &SW4\nLOG      ACCESS(&VACC)                                          &SW5\nLOG      CONTROL(&VCTL)                                         &SW6\nLOG      DDNAME(&VDDNAME)                                       &SW1\n         DATASET('&PRJ0..&LIB0..&TYP0.(&MEMBER)')               &SW1\nLOG      DDNAME(&VDDNAME)                                       &SW2\n         DATASET('&PRJ0..&LIB0..&TYP0.(&MEMBER)')               &SW2\nEND\n./ ADD NAME=VPAN01   0101-79269-80105-1638-00013-00013-00002-$CSG05  00\nCOMMAND  PAN ADD &VPANNAM DDNAME(&VDDNAME) FORMAT(&VFORMAT)\n &VINTFMT &VDISP\n DATASET('&PRJ1..&LIB1..&TYP1.(&MEMBER)')                  &SW1\n DATASET(&VDSNAME)                                         &SW2\n USER(&VUSR)                                               &SW3\n CONTROL(&VCTL)                                            &SW4\nLOG      PAN ADD &VPANNAM DDNAME(&VDDNAME) FORMAT(&VFORMAT)\n &VINTFMT &VDISP\nLOG      DATASET('&PRJ1..&LIB1..&TYP1.(&MEMBER)')          &SW1\nLOG      DATASET(&VDSNAME)                                 &SW2\nLOG      USER(&VUSR)                                       &SW3\nLOG      CONTROL(&VCTL)                                    &SW4\nEND\n./ ADD NAME=VPAN02   0102-79269-79309-1116-00015-00015-00001-TYD9835 00\nCOMMAND  PAN CHANGE &VPANNAM DDNAME(&VDDNAME)\n STATUS(&VSTATUS)                                          &SW1\n COMMENT(&VCOM)                                            &SW2\n USER(&VUSR)                                               &SW3\n LEVEL(&VLV)                                               &SW4\n ACCESS(&VACC)                                             &SW5\n CONTROL(&VCTL)                                            &SW6\nLOG      PAN CHANGE &VPANNAM DDNAME(&VDDNAME)\nLOG      STATUS(&VSTATUS)                                  &SW1\nLOG      COMMENT(&VCOM)                                    &SW2\nLOG      USER(&VUSR)                                       &SW3\nLOG      LEVEL(&VLV)                                       &SW4\nLOG      ACCESS(&VACC)                                     &SW5\nLOG      CONTROL(&VCTL)                                    &SW6\nEND\n./ ADD NAME=VPAN03   0100-79269-79269-1310-00007-00007-00000-TYD9835 00\nCOMMAND  PAN COPY &VPANNAM &VNEWNAM DDNAME(&VDDNAME)\n ACCESS(&VACC)                                             &SW1\n CONTROL(&VCTL)                                            &SW2\nLOG      PAN COPY &VPANNAM &VNEWNAM DDNAME(&VDDNAME)\nLOG      ACCESS(&VACC)                                     &SW1\nLOG      CONTROL(&VCTL)                                    &SW2\nEND\n./ ADD NAME=VPAN04   0100-79269-79269-1310-00010-00010-00000-TYD9835 00\nCOMMAND  PANDSPLY &VPANNAM DDNAME(&VDDNAME) &VEXPAND\n ACCESS(&VACC)                                             &SW2\n SEQ1(&VSEQ1)                                              &SW3\nLOG      PANDSPLY &VPANNAM DDNAME(&VDDNAME) &VEXPAND\nLOG      ACCESS(&VACC)                                     &SW2\nLOG      SEQ1(&VSEQ1)                                      &SW3\nEND\n*   THE FOLLOWING PARAMETERS ARE NOT USED BY THE PANDSPLY PROGRAM\n SEQ2(&VSEQ2)                                              &SW4\nLOG      SEQ2(&VSEQ2)                                      &SW4\n./ ADD NAME=VPAN05   0100-79269-79269-1310-00009-00009-00000-TYD9835 00\nCOMMAND  PAN LISTDS &VPANNAM DDNAME(&VDDNAME)\n &VCOM                                                     &SW1\n ACCESS(&VACC)                                             &SW2\n CONTROL(&VCTL)                                            &SW3\nLOG      PAN LISTDS &VPANNAM DDNAME(&VDDNAME)\nLOG      &VCOM                                             &SW1\nLOG      ACCESS(&VACC)                                     &SW2\nLOG      CONTROL(&VCTL)                                    &SW3\nEND\n./ ADD NAME=VPAN06   0100-79269-79269-1310-00015-00015-00000-TYD9835 00\nCOMMAND  PAN PRINT DDNAME(&VDDNAME)\n STATUS(&VSTATUS)                                          &SW1\n TYPE(&VTYPE)                                              &SW2\n NAME(&VPANNAM)                                            &SW3\n USER(&VUSR)                                               &SW4\n CONTROL(&VCTL)                                            &SW5\n &VCOM                                                     &SW6\nLOG      PAN PRINT DDNAME(&VDDNAME)\nLOG      STATUS(&VSTATUS)                                  &SW1\nLOG      TYPE(&VTYPE)                                      &SW2\nLOG      NAME(&VPANNAM)                                    &SW3\nLOG      USER(&VUSR)                                       &SW4\nLOG      CONTROL(&VCTL)                                    &SW5\nLOG      &VCOM                                             &SW6\nEND\n./ ADD NAME=VPAN07   0100-79269-79269-1310-00007-00007-00000-TYD9835 00\nCOMMAND  PAN RENAME &VPANNAM &VNEWNAM DDNAME(&VDDNAME)\n ACCESS(&VACC)                                             &SW1\n CONTROL(&VCTL)                                            &SW2\nLOG      PAN RENAME &VPANNAM &VNEWNAM DDNAME(&VDDNAME)\nLOG      ACCESS(&VACC)                                     &SW1\nLOG      CONTROL(&VCTL)                                    &SW2\nEND\n./ ADD NAME=VPAN08   0100-79269-79269-1310-00013-00013-00000-TYD9835 00\nCOMMAND  PAN RETRIEVE &VPANNAM DDNAME(&VDDNAME)\n &VEXPAND &VINTFMT\n DATASET('&PRJ1..&LIB1..&TYP1.(&MEMBER)')                  &SW1\n DATASET(&VDSNAME)                                         &SW2\n CONTROL(&VCTL)                                            &SW3\n ACCESS(&VACC)                                             &SW4\nLOG      PAN RETRIEVE &VPANNAM DDNAME(&VDDNAME)\nLOG      &VEXPAND &VINTFMT\nLOG      DATASET('&PRJ1..&LIB1..&TYP1.(&MEMBER)')          &SW1\nLOG      DATASET(&VDSNAME)                                 &SW2\nLOG      CONTROL(&VCTL)                                    &SW3\nLOG      ACCESS(&VACC)                                     &SW4\nEND\n./ ADD NAME=VPAN09   0101-79269-80108-1005-00013-00013-00002-$CSG05  00\nCOMMAND  PAN STORE &VPANNAM DDNAME(&VDDNAME) LEVEL(&VLV)\n &VINTFMT &VDISP\n DATASET('&PRJ1..&LIB1..&TYP1.(&MEMBER)')                  &SW1\n DATASET(&VDSNAME)                                         &SW2\n CONTROL(&VCTL)                                            &SW3\n ACCESS(&VACC)                                             &SW4\nLOG      PAN STORE &VPANNAM DDNAME(&VDDNAME) LEVEL(&VLV)\nLOG      &VINTFMT &VDISP\nLOG      DATASET('&PRJ1..&LIB1..&TYP1.(&MEMBER)')          &SW1\nLOG      DATASET(&VDSNAME)                                 &SW2\nLOG      CONTROL(&VCTL)                                    &SW3\nLOG      ACCESS(&VACC)                                     &SW4\nEND\n./ ADD NAME=VSUBMT   0100-79269-79269-1310-00011-00011-00000-TYD9835 00\nCOMMAND  SUB (\n '&PRJ1..&LIB1..&TYP1.(&MEM1)'                             &SW1\n '&PRJ2..&LIB2..&TYP2.(&MEM2)'                             &SW2\n '&VDSNAME'                                                &SW3\n '&DSNAME'                                                 &SW4\n )\nLOG      &PRJ1..&LIB1..&TYP1.(&MEM1) HAS BEEN SUBMITTED    &SW1\nLOG      &PRJ2..&LIB2..&TYP2.(&MEM2) HAS BEEN SUBMITTED    &SW2\nLOG      '&VDSNAME' HAS BEEN SUBMITTED                     &SW3\nLOG      '&DSNAME' HAS BEEN SUBMITTED                      &SW4\nEND\n./ ADD NAME=VUOL01   0101-79262-80022-1620-00012-00013-00011-TYD9835 00\nCOMMAND  STATUS                                                  &SW3\nCOMMAND  OUTPUT                                                  &SW4\n &TJNM                                                      &SWA &SW4\n &TJNM.(&TJID)                                              &SW9 &SW4\n CLASS(&TCL1)                                               &SW8 &SW4\n PRINT('&TSOPXID..SPF&TLID..OUTLIST') KEEP HOLD BEGIN       &SW1 &SW4\n PRINT('&TSOPXID..SPF&TLID..OUTLIST') BEGIN                 &SW5 &SW4\n DELETE                                                     &SW2 &SW4\nLOG      OUTLIST DELETE &TJNM                               &SW2 &SW4\nLOG      OUTLIST REQUEUE &TJNM                                   &SW4\nLOG      OUTLIST PRINT &TJNM                                &SW5 &SW4\nEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "SYS2HELP": {"ttr": 53771, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00X\\x01\\x19#\\x0f\\x01\\x19#\\x0f\\x18\\x00\\x07\\xcf\\x07\\xcf\\x00\\x00\\xe6\\xe8\\xd3\\xc2\\xe4\\xd9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2019-08-18T00:00:00", "modifydate": "2019-08-18T18:00:58", "lines": 1999, "newlines": 1999, "modlines": 0, "user": "WYLBUR"}, "text": "./ ADD NAME=$RAB     0100-80207-80207-1337-00022-00022-00000-$SYS11  00\n)F   FUNCTION -\n   THE $RAB COMMAND SUBMITS A BACKGROUND JOB TO A SPECIAL JOB\n   CLASS FOR THE PURPOSE OF DOING A $RL (RELOADS FROM ARCHIVES).\n   A MESSAGE IS SENT TELLING YOU WHETHER THE RELOAD WAS SUCCESSFUL\n   OR NOT UPON COMPLETION OF THE JOB.\n)X  SYNTAX -\n    $RAB   'DATASET NAME'\n   OR\n    $RAB  (DATASET NAME LIST)\n    DEFAULTS - NONE\n)O  OPERANDS -\n  'DATASET NAME'\n             - SPECIFIES A DSNAME IN THE ARCHIVES THAT YOU WISH\n               TO BE RELOADED.  STANDARD TSO NAMING CONVENTIONS\n               APPLY (I.E. QUOTES ARE REQUIRED IF DSNAME DOES NOT\n               BEGIN WITH YOUR USERID).\n  (DATASET NAME LIST)\n             - SPECIFIES A LIST OF DATASETS  THAT YOU WISH\n               TO BE RELOADED.  STANDARD TSO NAMING CONVENTIONS\n               APPLY (I.E. QUOTES ARE REQUIRED IF DSNAME DOES NOT\n               BEGIN WITH YOUR USERID).\n               THE LIST MUST BE WITHIN PARENTHEIS.\n./ ADD NAME=#        0100-78266-78266-0111-00034-00034-00000-$SYS13  00\n)F       THE # COMMAND CAN BE USED IN PLACE OF THE CALL COMMAND\n         FOR PROGRAMS THAT ARE IN THE 'SYS1.LINKLIB' DATA SETS;\n         THIS INCLUDES ALL COMPILERS AND UTILITIES AS WELL AS\n         SPNB PROGRAMS SUCH AS MRCLEAN AND LISTPDS#.\n\n         ADVANTAGES OF THE # COMMAND OVER CALL:\n         1) THE # COMMAND REQUIRES NO DYNAMIC DD CARD NOR\n            ALLOCATION AND IS, THEREFORE, CONSIDERABLY FASTER;\n         2) THE # COMMAND SIMPLIFIES SYNTAX AND REQUIRES LESS TYPING;\n         3) THE # COMMAND ALLOWS USE OF PROGRAMS IN ANY OF THE LINKLIB\n            DATA SETS, WITHOUT KNOWING WHICH OF THE DATA SETS THE\n            PROGRAM IS IN.\n         DISADVANTAGES OF THE # COMMAND:\n         THE ONLY DISADVANTAGE OF THE # COMMAND IS THAT THE PROGRAM\n         BEING CALLED MUST BE IN A LINKLIB DATA SET; HENCE,\n         TO CALL A USER'S PROGRAM FROM HIS LIBRARY, THE CALL COMMAND\n         MUST STILL BE USED.\n)X       THE SYNTAX OF THE # COMMAND IS AS FOLLOWS:\n         # PROGRAM 'PARM'\n         WHERE PROGRAM IS THE NAME OF THE PROGRAM TO BE EXECUTED AND\n         'PARM' IS AN OPTIONAL PARM FIELD OF UP TO 100 CHARACTERS\n         WHICH IS TO BE PASSED TO THE PROGRAM.\n)O       THE OPERANDS OF THE # COMMAND ARE:\n         PROGRAM - THE 1 TO 8 CHARACTER NAME OF THE PROGRAM TO BE\n                   EXECUTED.\n         'PARM'  - THE OPTIONAL 0 TO 100 CHARACTER STRING, ENCLOSED IN\n                   QUOTES, REPRESENTING THE PARAMETER TO BE PASSED TO\n                   THE PROGRAM.\n\n         EXAMPLE - INVOKING MRCLEAN FOR VOLS PUBDA1 AND TSODA1\n         # MRCLEAN 'PUBDA1,TSODA1'\n\n         EXAMPLE - INVOKING ASSEMBLER F WITH PARMS OF TEST AND RENT\n         # IEUASM 'TEST,RENT'\n./ ADD NAME=ASID\nSID TITLE 'ASID COMMAND PROCESSOR - DISPLAY ACTIVE ADDRESS SPACES'\n        MACRO\n        REGS\n        LCLA  &R\nR       AIF   (&R EQ 16).END\n&R      EQU   &R\nR       SETA  &R+1\n        AGO   .R\nEND     MEND\nSPACE 4\nSID    CSECT\n\n   ASID WAS WRITTEN BY\n                             R P WENZEL\n                             OPTIMUM SYSTEMS INCORPORATED\n                             5615 FISHERS LANE\n                             ROCKVILLE, MARYLAND 20852\n                             (301) 468-1000 X232\n                             JUNE 2, 1976.\n\n   WITH MODIFICATIONS BY\n                             J R PASEUR\n                             OPTIMUM SYSTEMS INCORPORATED\n\n   MORE MODIFICATIONS BY\n                             R P WENZEL\n                             U S POSTAL SERVICE\n                             850 CHERRY AVE.\n                             SAN BRUNO, CALIFORNIA 94097\n                             (415) 876-9142\n                             FEBRUARY 1977.\n   MORE MODIFICATIONS BY\n                             R P WENZEL\n                             MEMOREX CORPORATION\n                             SAN TOMAS AT CENTRAL EXP.\n                             SANTA CLARA, CALIF. 95052\n                             (408) 987-0952\n                             APRIL 1979.\n   MORE MODIFICATIONS FOR SE-II\n                             R P WENZEL\n                             ITEL CORPORATION\n                             55 FRANCISCO ST.\n                             SAN FRANCISCO CALIF. 94133\n                             (415) 955-0473\n                             APRIL 1980.\nEJECT\n)F FUNCTION -\n  THE ASID COMMAND DISPLAYS INFORMATION ON THE ADDRESS SPACES.\n)X SYNTAX -\n         ASID    'ASID#'/*  STC/JOBS/TS/ALL HOLES GROUP('N1')\n                 PERIOD('N2') DOMAIN('N3') IN/OUT/BOTH\n  REQUIRED - NONE\n  DEFAULTS - ASID ALL,BOTH\n  ALIAS    - AS\n  NOTE     - ASID OUTPUT HAS THE FOLLOWING FORMAT :\nID  DP JOB  STEP  FLAGS CPUTIME REAL WORK  G/P/D  SRC SC SERV TRC SERV\nWHERE\n        ID - ASID NUMBER\n        DP - DISPATCHING PRIORITY\n       JOB - JOBNAME\n      STEP - STEPNAME\n     FLAGS - XXXYY\n       XXX - APG - AUTOMATIC-PRIORITY-GROUP APPLIES\n             AXS - AUX SHORTAGE FORCED SWAP\n             ENQ - TEMPORARILY NON-SWAPPABLE DUE TO ENQ\n             GOB - CURRENTLY CHANGING STATUS\n             GOI - IN PROCESS OF BEING SWAPPED IN\n             GOO - IN PROCESS OF BEING SWAPPED OUT\n             IN  - IN CORE, SWAPPED IN (DEFAULT IF NONE OF THE BELOW)\n             LSW - LOGICALLY SWAPPED\n             NSW - NON-SWAPPABLE\n             OUT - SWAPPED OUT\n             PVL - PRIVILEDGED (NON-SWAPPABLE EXCEPT FOR LONG WAIT)\n             RPG - RPGNS ARE PRESENT\n        YY - CP  - SIGINIFICANT CPU USER (SET BY IRARMCPM)\n             LW  - EXPLICIT LONG WAIT\n             MW  - LONG WAIT STATUS DETECTED BY MSO (MS6)\n             NW  - NON-SWAPPABLE WAIT\n             OW  - OUTPUT TERMINAL WAIT\n             TW  - TERMINAL WAIT\n   CPUTIME - STEP CPU TIME IN HOURS:MINUTES:SECONDS\n      REAL - AMOUNT OF REAL CORE AT LAST PAGE-IN\n      WORK - WORKING SET SIZE AT LAST SWAPIN\n     G/P/D - PERFORMANCE GROUP/PERFORMANCE GROUP PERIOD/DOMAIN\n       SRC - SWAP OUT REASON CODES\n             ASS - AUXILIARY STORAGE SHORTAGE\n              DW - DETECTED WAIT\n              EE - ENQ EXCHANGE\n             ERV - EXCHANGE OF RECOMMENDATION VALUE\n             ITW - INPUT TERMINAL WAIT\n              LW - LONGWAIT\n             OTW - OUTPUT TERMINAL WAIT\n              RS - REQUESTED SWAP\n             RSS - REAL PAGEABLE STORAGE SHORTAGE\n               U - UNILATERAL\n        SC - NUMBER OF SWAPS FOR CURRENT TRANSACTION\n      SERV - SERVICE UNITS ACCUMALATED FOR CURRENT TRANSACTION\n       TRC - NUMBER OF TRANSACTIONS DURING SESSION\n      SERV - SERVICE UNITS ACCUMALATED DURING SESSION\n)O OPERANDS -\n  'ASID#'      - ADDRESS SPACE IDENTIFICATION NUMBER.  AN ASTERISK (*)\n                 INDICATES CURRENT TSO USER.\n))STC          - DISPLAY STARTED OR SYSTEM TASKS.\n))JOBS         - DISPLAY JOBS ON JES INITIATORS.\n))TS           - DISPLAY TSO USERS.\n))ALL          - PERFORM SYSTEM, INITIATOR AND TSO FUNCTIONS.\n))HOLES        - DISPLAY ASIDS WITHOUT JOBNAMES.\n))GROUP('N1')  - DISPLAY ASIDS IN A PARTICULAR PERFORMANCE GROUP.\n        'N1'   - PERFORMANCE GROUP NUMBER FROM 0 TO 99.\n))PERIOD('N2') - DISPLAY ASIDS IN A PARTICULAR PERIOD.\n         'N2'  - PERIOD RANGES FROM 0 TO 9.\n))DOMAIN('N3') - DISPLAY ASIDS IN A PARTICULAR DOMAIN.\n         'N3'  - DOMAIN RANGES FROM 0 TO 99.\n))IN           - DISPLAY ASIDS IN CORE.\n))OUT          - DISPLAY ASIDS OUT OF CORE.\n))BOTH         - DISPLAY ASIDS BOTH IN AND OUT OF CORE.\n./ ALIAS NAME=AS\n./ ADD NAME=ASM\n)F   FUNCTION -\n         THE ASM COMMAND PROVIDES AN INTERFACE BETWEEN TSO AND THE\n         IBM MVS ASSEMBLER TO ALLOW ASSEMBLIES TO BE PERFORMED\n         FROM A TSO TERMINAL.\n\n         THE ASM COMMAND ALLOWS USERS TO SPECIFY THE INPUT DATA\n         SETS TO BE ASSEMBLED, THE DATA SET WHICH IS TO CONTAIN\n         THE OBJECT MODULE FROM THE ASSEMBLY, THE MACRO LIBRARY\n         DATA SETS TO BE USED BY THE ASSEMBLER, AND AN OPTIONAL\n         DATA SET TO CONTAIN THE ASSEMBLY LISTING.\n\n\n)X  SYNTAX -\n   ASM DSNAME   LOAD(DSNAME2) / NOLOAD\n                 PRINT(DSNAME3) / NOPRINT / SYSOUT(CLASS)\n                 LIB(DSNAME4)\n                 MACLIB / NOMACLIB\n                 TERM   / NOTERM\n                 NUM    / NONUM\n                 STMT   / NOSTMT\n                 TEST   / NOTEST\n                 RENT   / NORENT\n                 ESD    / NOESD\n                 RLD    / NORLD\n                 XREF   / FULLXREF   /  NOXREF\n                 LIST   / NOLIST\n                 ALGN   / NOALGN\n                 LINECNT(INTEGER)\n                 UTSPACE(NN NN)\n\n    REQUIRED -   DSNAME\n\n\n    DEFAULTS -  LOAD, TERM, MACLIB, TEST, NORENT, ALGN,\n                NUM, STMT, ESD, RLD, XREF\n                LINECNT(55), NOPRINT, UTSPACE(19 19).\n\n\n    NOTES - IF ANY OPTION IS SPECIFIED WHICH REFERS TO THE ASSEMBLY\n            LISTING, SUCH AS LIST, ESD, RLD,  XREF, ETC.,\n            THEN THE DEFAULT NOPRINT IS CHANGED TO PRINT(DSNAME).\n\n            IF EITHER PRINT(DSNAME) OR SYSOUT(CLASS) IS SPECIFIED,\n            THEN THE DEFAULTS FOR THE ASSEMBLY LISTING ARE CHANGED\n            AS FOLLOWS--\n              LIST, FULLXREF, ESD, RLD\n\n            IF PRINT(*) IS SPECIFIED, THEN 'LIST' BECOMES\n            THE DEFAULT FOR THE ASSEMBLY LISTING.\n\n            IF THE LIB OPERAND IS NOT SPECIFIED, THEN THE\n            SPNB MACRO LIBRARY, 'SYS2.MACLIB', IS USED AS A\n            DEFAULT LIBRARY.\n\n)O   OPERANDS -\n      'DSNAME' -NAME OF THE DATA SET CONTAINING THE ASSEMBLY\n                LANGUAGE SOURCE TO BE ASSEMBLED.\n                A MAXIMUM OF SIXTEEN (16) DATA SETS CAN BE ACCEPTED.\n                IF MORE THAN ONE DATA SET IS TO BE PROCESSED,\n                THEN THE LIST OF DATA SET NAMES MUST BE ENCLOSED\n                WITHIN PARENTHESIS.\n\n))LOAD('DSNAME2')  - INDICATES THAT AN OBJECT MODULE IS TO\n                     BE PRODUCED BY THE ASSEMBLER.\n                     IF 'DSNAME2' IS SPECIFIED, THEN THE OBJECT\n                     MODULE WILL BE PLACED IN THIS DATA SET.\n                     OTHERWISE A DATA SET CONFORMING TO\n                     STANDARD NAMING CONVENTIONS IS USED.\n))NOLOAD         -   INDICATES NO OBJECT MODULE IS TO BE PRODUCED.\n\n))PRINT('DSNAME3') - INDICATES THAT AN ASSEMBLY LISTING IS TO BE\n                     PRODUCED. 'DSNAME3' SPECIFIES THE NAME OF\n                     DATA SET IN WHICH THE LISTING WILL BE PLACED.\n                     IF 'DSNAME3' IS NOT SPECIFIED, THEN THE LISTING\n                     IS PRODUCED AT THE TERMINAL. IF '*' IS\n                     SPECIFIED, THEN THE LISTING IS PRODUCED AT THE\n                     TERMINAL.\n))SYSOUT(CLASS)    - INDICATES THAT THE ASSEMBLY LISTING IS TO BE\n                     PRODUCED AND PRINTED VIA A STANDARD OS WRITER.\n                     'CLASS' REPRESENTS ONE OF THE STANDARD OS OUTPUT\n                     CLASSES, A-Z OR 0-9. IF CLASS IS NOT SPECIFIED,\n                     C IS USED AS THE DEFAULT CLASS.\n))NOPRINT          - INDICATES THAT NO ASSEMBLY LISTING IS TO BE\n                     PRODUCED. THE VALUE OF THIS OPERAND IS ALSO\n                     DEPENDENT ON THE VALUES SPECIFIED FOR THE\n                     OTHER OPERANDS WHICH NORMALLY CONTROL THE\n                     FORMATING OF THE ASSEMBLY LISTING. FOR MORE\n                     INFORMATION ON THIS CONDITION, SEE THE\n                     DESCRIPTION OF THESE OPERANDS.\n\n))LIB('DSNAME4')   - INDICATES THE NAMES OF THE MACRO LIBRARIES TO\n                     BE USED FOR THIS ASSEMBLY. A MAXIMUM OF\n                     FIFTEEN (15) LIBRARIES CAN BE SPECIFIED.\n                     IF 'DSNAME4' IS NOT A FULLY QUALIFIED LIBRARY\n                     NAME, (DOES NOT END IN EITHER .ASM OR .MACLIB),\n                     THEN AN ATTEMPT WILL BE MADE TO QUALIFY THE\n                     NAME THROUGH THE SYSTEM CATALOG.\n                     IF THE NAME OF THE SYSTEM MACRO LIBRARY,\n                     'SYS3.MACLIB', IS SPECIFIED IN THIS OPERAND,\n                     THEN THE VALUE OF THE MACLIB OPERAND IS IGNORED.\n\n))MACLIB           - INDICATES THAT THE SYSTEM MACLIB IS TO BE USED\n                     IN CONJUNCTION WITH THE MACRO LIBRARIES AS\n                     SPECIFIED WITH THE LIB OPERAND.\n                     THIS LIBRARY IS REFERENCED AFTER ALL OF THE\n                     LIBRARIES SPECIFIED WITH THE LIB OPERAND HAVE\n                     PROCESSED. IF THE SYSTEM MACRO LIBRARY CONTAINS\n                     MACROS WHICH MAY BE DUPLICATED IN ANY OF THE\n                     OTHER MACRO LIBRARIES, AND THOSE IN THE SYSTEM\n                     LIBRARY SHOULD BE THE ONES USED, THEN THE NAME\n                     OF THE SYSTEM LIBRARY, 'SYS3.MACLIB', SHOULD\n                     BE SPECIFIED IN THE LIB OPERAND, BEFORE THE\n                     NAMES OF THE LIBRARIES WHICH CONTAIN THE\n                     DUPLICATED MACRO INSTRUCTIONS.\n))NOMACLIB         - INDICATES THAT THE SYSTEM MACRO LIBRARY IS NOT\n                     TO BE USED DURING THIS ASSEMBLY.\n\n))LIST             - INDICATES THAT THE STANDARD ASSEMBLY LISTING\n                     IS TO BE PRODUCED. IF THIS OPERAND IS\n                     SPECIFIED, THEN THE VALUE OF THE PRINT OPERAND\n                     IS OVERRIDEN.\n))NOLIST           - INDICATES THAT NO LISTING IS TO BE PRODUCED.\n\n))TERM             - INDICATES THAT ERROR AND STATUS MESSAGES ARE\n                     TO BE SENT TO THE TERMINAL.\n))NOTERM           - INDICATES THAT THESE MESSAGES ARE NOT TO BE\n                     SENT. 'NOTERM' WILL BE FORCED IF THE ASSEMBLY\n                     LISTING IS BEING SENT TO THE TERMINAL.\n\n))NUM              - INDICATES THAT ANY ERROR MESSAGES SENT TO THE\n                     TERMINAL, WHEN THE TERM OPTION IS USED, ARE\n                     TO CONTAIN THE SEQUENCE NUMBER OF THE SOURCE\n                     STATEMENT IN ERROR.\n))NONUM            - INDICATES THAT THE SEQUENCE NUMBER OF THE\n                     SOURCE STATEMENT IN ERROR IS NOT TO BE INCLUDED\n                     IN ANY ERROR MESSAGES.\n\n))STMT             - INDICATES THAT ANY ERROR MESSAGES SENT TO THE\n                     TERMINAL, WHEN THE TERM OPTION IS USED, ARE\n                     TO CONTAIN THE ASSEMBLY LISTING STATEMENT\n                     NUMBER OF THE STATEMENT IN ERROR.\n))NOSTMT           - INDICATES THAT STATEMENT NUMBERS ARE NOT TO\n                     BE INCLUDED IN ANY ERROR MESSAGES.\n\n))ESD              - INDICATES THAT THE EXTERNAL SYMBOL DICTIONARY\n                     IS TO BE INCLUDED IN THE ASSEMBLY LISTING.\n                     IF THIS OPTION IS SPECIFIED, THE VALUE OF THE\n                     PRINT OPERAND IS IGNORED, AND AN ASSEMBLY\n                     LISTING WILL BE GENERATED.\n                     THIS OPTION MAY BE ABBREVIATED 'ED'.\n))NOESD            - INDICATES THAT THE EXTERNAL SYMBOL DICTIONARY\n                     IS NOT TO BE INCLUDED IN THE ASSEMBLY LISTING.\n\n))RLD              - INDICATES THAT THE RELOCATION SYMBOL DICTIONARY\n                     IS TO BE INCLUDED IN THE ASSEMBLY LISTING.\n                     IF THIS OPTION IS SPECIFIED, THEN THE VALUE\n                     OF THE PRINT OPERAND IS IGNORED AND AN\n                     ASSEMBLY LISTING IS GENERATED.\n                     THIS OPTION MAY BE ABBREVIATED 'RD'.\n))NORLD            - INDICATES THAT THE RELOCATION SYMBOL DICTIONARY\n                     IS NOT TO BE INCLUDED IN THE ASSEMBLY LISTING.\n\n))XREF             - INDICATES THAT A CROSS-REFERENCE LISTING OF THE\n                     REFERENCES TO EACH SYMBOL IN THE ASSEMBLY IS TO\n                     BE PRODUCED. THE LISTING WILL ALSO CONTAIN\n                     A CROSS REFERENCE TABLE OF LITERALS USED\n                     IN THE ASSEMBLY.\n))FULLXREF         - INDICATES THAT THE CROSS-REFERENCE LISTING IS TO\n                     INCLUDE SYMBOLS THAT ARE DEFINED BUT NEVER\n                     REFERENCED. A LITERAL CROSS REFERENCE WILL ALSO\n                     BE PRODUCED.\n))NOXREF           - INDICATES THAT THE CROSS-REFERENCE LISTING IS\n                     NOT TO BE PRODUCED.\n\n))TEST             - INDICATES THAT THE ASSEMBLER IS TO INCLUDE THE\n                     INFORMATION ON THE INTERNAL SYMBOLS IN THE\n                     OBJECT MODULE PRODUCED, TO ALLOW THESE SYMBOLS\n                     TO BE KNOWN TO THE TSO TEST COMMAND. IF THIS\n                     OPTION IS NOT USED, THEN THE TEST COMMAND CAN\n                     ONLY REFER TO THE EXTERNAL SYMBOLS GENERATED\n                     BY THIS MODULE, AND RELATIVE OFFSETS WILL BE\n                     REQUIRED TO REFER TO INTERNAL SYMBOLS AND\n                     LOCATIONS WITHIN THIS PROGRAM.\n))NOTEST           - INDICATES THAT THE INFORMATION RELATING TO THE\n                     INTERNAL SYMBOLS IS NOT TO BE INCLUDED IN THE\n                     OBJECT MODULE.\n\n))RENT             - INDICATES THAT THE ASSEMBLER IS TO CHECK FOR\n                     VIOLATIONS OF CODING THAT WOULD MAKE THIS\n                     PROGRAM NOT RE-ENTRANT.\n))NORENT           - INDICATES THAT NO CHECK IS TO BE PERFORMED FOR\n                     RE-ENTERANT CODING VIOLATIONS.\n\n))ALGN             - INDICATES THAT THE ASSEMBLER IS TO CHECK FOR\n                     BOUNDARY ALIGNMENT VIOLATIONS ON INSTRUCTIONS\n                     WHICH NORMALLY REQUIRED CERTAIN ALIGNMENTS FOR\n                     PROPER EXECUTION. STATEMENTS WHICH CONTAIN\n                     AN INSTRUCTION WHICH DOES NOT HAVE PROPER\n                     BOUNDARY ALIGNMENT WILL BE FLAGGED IN ERROR.\n))NOALGN           - INDICATES THAT NO CHECK IS TO BE PERFORMED BY\n                     THE ASSEMBLER FOR INTRUCTIONS WITH INVALID\n                     BOUNDARY ALIGNMENT.\n\n\n))LINECNT('INTEGER') -   INDICATES THE NUMBER OF LINES TO BE PRINTED ON\n                     EACH PAGE OF THE ASSEMBLY LISTING. THE DEFAULT\n                     IS 55.\n\n\n))UTSPACE('NN NN')  - NUMBER OF TRACKS TO BE USED AS PRIMARY AND\n                      SECONDARY SPACE QUANTITIES FOR UTILITY FILES.\n                      THIS OPTION SHOULD NOT BE USED UNLESS AN ERROR\n                      MESSAGE ISSUED BY THE ASSEMBLER INDICATES THAT\n                      THE DEFAULT VALUES ARE INSUFFICIENT.\n./ ALIAS NAME=ASMX\n./ ADD NAME=CLR3270  0105-79004-79101-1346-00011-00011-00000-$SYS15  00\n)F FUNCTION -\n   THE CLR3270 COMMAND WILL CLEAR THE SCREEN OF A 3270 DISPLAY\n   TERMINAL.  SUBSEQUENT OUTPUT LINES WILL BE WRITTEN STARTING\n   AT THE TOP OF THE SCREEN.  THIS COMMAND SHOULD NOT BE ISSUED\n   FROM TERMINALS OTHER THAN IBM 3270 COMPATIBLE ONES.\n)X SYNTAX   -\n              CLR3270\n\nALIAS    -    CLR1377\n)O OPERANDS -\n   THERE ARE NO OPERANDS ON THE CLR3270 COMMAND.\n./ ADD NAME=COMMANDS 0101-79149-79351-1844-00075-00077-00002-$SYS13  00\nMISCELLANEOUS COMMANDS:\n\nLOCAL      FOR ADDITIONAL LOCAL ITEL COMMANDS\nPP         FOR ADDITIONAL PROGRAM PRODUCT COMMANDS\n\nLANGUAGE PROCESSING COMMANDS:\n\nASM        INVOKE ASSEMBLER PROMPTER AND ASSEMBLER F COMPILER.\n\nPROGRAM CONTROL COMMANDS:\n\nCALL       LOAD AND EXECUTE THE SPECIFIED LOAD MODULE.\nLINK       INVOKE LINK PROMPTER AND LINKAGE EDITOR.\nLOADGO     LOAD AND EXECUTE PROGRAM.\nRUN        COMPILE, LOAD, AND EXECUTE PROGRAM.\nTEST       TEST USER PROGRAM.\n\nDATA MANAGEMENT COMMANDS:\n\nALLOCATE   ALLOCATE A DATA SET.\nCONVERT    SIFT ITF/PL1 AND FORTRAN SOURCE.\nCOPY       COPY A DATA SET.\nDELETE     DELETE A DATA SET.\nEDIT       CREATE, EDIT, AND/OR EXECUTE A DATA SET.\nFORMAT     FORMAT AND PRINT A TEXT DATA SET.\nFREE       RELEASE A DATA SET.\nLIST       DISPLAY A DATA SET.\nLISTALC    DISPLAY ACTIVE DATA SETS.\nLISTBC     DISPLAY MESSAGES FROM OPERATOR/USER.\nLISTCAT    DISPLAY USER CATALOGUED DATA SETS.\nLISTDS     DISPLAY DATA SET ATTRIBUTES.\nMERGE      COMBINE DATA SETS.\nPROTECT    PASSWORD PROTECT DATA SETS.\nRENAME     RENAME A DATA SET.\n\nSYSTEM CONTROL COMMANDS:\n\nACCOUNT    MODIFY/ADD/DELETE USER ATTRIBUTES.\nOPERATOR   PLACE TERMINAL IN OPERATOR MODE.\n\nSESSION CONTROL:\n\nEXEC       INVOKE COMMAND PROCEDURE.\nHELP       INVOKE HELP PROCESSOR.\nLOGOFF     END TERMINAL SESSION.\nLOGON      START TERMINAL SESSION.\nPROFILE    DEFINE USER CHARACTERISTICS.\nSEND       SEND MESSAGE TO OPERATOR/USER.\nTERMINAL   DEFINE TERMINAL CHARACTERISTICS.\nTIME       LOG SESSION USAGE TIME.\nWHEN       CONDITIONALLY EXECUTE NEXT COMMAND.\n\nFOREGROUND INITIATED BACKGROUND COMMANDS:\n\nCANCEL     CANCEL BACKGROUND JOB.\nOUTPUT     DIRECT OUTPUT MEDIUM FOR BACKGROUND JOB.\nSTATUS     LIST STATUS OF BACKGROUND JOB.\nSUBMIT     SUBMIT BACKGROUND JOB.\n\nACCESS METHOD SERVICE COMMANDS\n\nALTER       ALTER ATTRIBUTES IN CATALOG ENTRIES.\nCNVTCAT     ENTRIES IN AN OS CATALOG ARE CONVERTED TO ENTRIES IN\n            AN EXISTING VS2 MASTER OR USER CATALOG.\nDEFINE      DEFINE USER CATALOGS,DATA SPACES, CLUSTERS, PAGE SPACES,\n            NONVSAM DATASETS, ALIAS NAMES, AND GENERATION DATA GROUPS.\nEXPORT      MOVE A CLUSTER OR USER CATALOG ENTRY FROM THE SYSTEM IN\n            WHICH THE COMMAND IS EXECUTED.\nIMPORT      MOVE A CLUSTER OR USER CATALOG ENTRY INTO THE SYSTEM IN\n            WHICH THE COMMAND IS EXECUTED.\nPRINT       LIST ALL OR PART OF AN INDEXED SEQUENTIAL, SEQUENTIAL,\n            OR VSAM DATASET.\nREPRO       COPY VSAM CLUSTERS, CATALOGS, AND NONVSAM DATASETS.\nVERIFY      VERIFY END OF FILE.\n\n./ ADD NAME=CR\n)F FUNCTION-\n         THE CREATE COMMAND ALLOWS MOST OF THE PARAMETERS ON THE\n         ALLOCATE AND ATTRIBUTE COMMANDS FOR A NEW DATASET.\n)X SYNTAX-\n         CREATE DATA-SET-NAME BFALN('BUFFER BOUNDARY ALIGNMENT')\n         BFTEK('BUFFER TECHNIQUE') BLKSIZE('BLOCK SIZE')\n         BUFL('BUFFER LENGTH') BUFNO('NUMBER OF BUFFERS')\n         DIR('INTEGER') EROPT('ERROR OPTION') EXPDT('YYDDD')\n         FILE('DDNAME') KEYLEN('KEY LENGTH') LRECL('LOGICAL\n         RECORD LENGTH') NCP('MAX. R/W MACROS') OPTCD('OPTIONAL\n         SERVICES') RECFM('RECORD FORMAT') SPACE('QUANTITY',\n         'INCREMENT','TYPE') VOLUME('SERIAL') LIKE(DATA-SET-NAME)\n\n         REQUIRED - DATA-SET-NAME\n         ALIAS    - CR\n         DEFAULTS - NONE\n         NOTE     - DATA SETS REMAIN ALLOCATED UNTIL LOGOFF OR\n                    FREED BY THE FREE COMMAND.\n)O OPERANDS -\n))DATA-SET-NAME -DATASET TO BE PERMANENTLY ALLOCATED.\n))LIKE          -DATA-SET-NAME USED AS A MODEL\n                 FOLLOWING INFORMATION USED:\n                 DIRECTORY BLOCKS -IF A PDS\n                 EROPT\n                 EXPDT\n                 KEYLEN\n                 BLKSIZE\n                 LRECL\n                 RECFM\n                 SPACE-TOTAL USED AS PRIMARY QUANTITY\n                 VOLUME SERIAL\n))BFALN         - BUFFER BOUNDARY ALIGNMENT\n                  F--FULL WORD BOUNDARY\n                  D--DOUBLE WORD BOUNDARY\n))BFTEK         - TYPE OF BUFFERING\n                  A--AUTOMATIC RECORD AREA CONSTRUCTION\n                  R--RECORD BUFFERING\n                  S--SIMPLE BUFFERING\n                  E--EXCHANGE BUFFERING\n))BLKSIZE       - BLOCK SIZE\n))BUFL          - BUFFER LENGTH\n))BUFNO         - NUMBER OF BUFFERS\n))DIR           - NUMBER OF DIRECTORY BLOCKS\n))EROPT         - ERROR OPTION\n                  ACC--ACCEPT BLOCK CAUSING ERROR\n                  SKP--SKIP BLOCK CAUSING ERROR\n                  ABE--ABNORMAL END OF TASK\n))EXPDT         - DATA SET EXPIRATION DATE(YYDDD)\n))FILE          - DDNAME ASSOCIATED WITH DATA SET\n))KEYLEN        - KEY LENGTH\n))LRECL         - LOGICAL RECORD LENGTH\n))NCP           - MAX# OF READ/WRITE MACROS BEFORE A CHECK\n))OPTCD         - OPTIONAL SERVICES CODES\n                  C--CHAINED SCHEDULING IS TO BE USED\n                  T--REQUESTS USER TOTALING FACILITY\n                  W--REQUESTS A VALIDITY CHECK FOR WRITE\n                     OPERATIONS ON DIRECT ACCESS DEVICES.\n                  Q--ANSI TRANSLATE\n))RECFM         - RECORD FORMAT\n                  F--FIXED\n                  V--VARIABLE\n                  U--UNDEFINED\n                  T--TRACK OVERFLOW\n                  B--BLOCKED\n                  S--STANDARD BLOCKS\n                  A--ASA PRINTER CHARACTERS\n                  M--MACHINE CONTROL CHARACTER\n))SPACE         - DIRECT ACCESS SPACE REQUIRED\n                 QUANTITY--UNITS INITIALLY ALLOCATED TO DATASET\n                 INCREMENT--UNITS ADDED EACH TIME PREVIOUS\n                            SPACE HAS BEEN FILLED.\n                 TYPE--UNIT OF SPACE FOR ALLOCATION\n                      BLOCK-BLKSIZE VALUE*QUANTITY\n                      TRK-REQUESTED QUANTITY IN TRACKS\n                      CYL-REQUESTED QUANTITY IN CYLINDERS\n))VOLUME        - VOLUME DATA SET IS TO RESIDE\n./ ADD NAME=CREATE\n)F FUNCTION-\n         THE CREATE COMMAND ALLOWS MOST OF THE PARAMETERS ON THE\n         ALLOCATE AND ATTRIBUTE COMMANDS FOR A NEW DATASET.\n)X SYNTAX-\n         CREATE DATA-SET-NAME BFALN('BUFFER BOUNDARY ALIGNMENT')\n         BFTEK('BUFFER TECHNIQUE') BLKSIZE('BLOCK SIZE')\n         BUFL('BUFFER LENGTH') BUFNO('NUMBER OF BUFFERS')\n         DIR('INTEGER') EROPT('ERROR OPTION') EXPDT('YYDDD')\n         FILE('DDNAME') KEYLEN('KEY LENGTH') LRECL('LOGICAL\n         RECORD LENGTH') NCP('MAX. R/W MACROS') OPTCD('OPTIONAL\n         SERVICES') RECFM('RECORD FORMAT') SPACE('QUANTITY',\n         'INCREMENT','TYPE') VOLUME('SERIAL') LIKE(DATA-SET-NAME)\n\n         REQUIRED - DATA-SET-NAME\n         ALIAS    - CR\n         DEFAULTS - NONE\n         NOTE     - DATA SETS REMAIN ALLOCATED UNTIL LOGOFF OR\n                    FREED BY THE FREE COMMAND.\n)O OPERANDS -\n))DATA-SET-NAME -DATASET TO BE PERMANENTLY ALLOCATED.\n))LIKE          -DATA-SET-NAME USED AS A MODEL\n                 FOLLOWING INFORMATION USED:\n                 DIRECTORY BLOCKS -IF A PDS\n                 EROPT\n                 EXPDT\n                 KEYLEN\n                 BLKSIZE\n                 LRECL\n                 RECFM\n                 SPACE-TOTAL USED AS PRIMARY QUANTITY\n                 VOLUME SERIAL\n))BFALN         - BUFFER BOUNDARY ALIGNMENT\n                  F--FULL WORD BOUNDARY\n                  D--DOUBLE WORD BOUNDARY\n))BFTEK         - TYPE OF BUFFERING\n                  A--AUTOMATIC RECORD AREA CONSTRUCTION\n                  R--RECORD BUFFERING\n                  S--SIMPLE BUFFERING\n                  E--EXCHANGE BUFFERING\n))BLKSIZE       - BLOCK SIZE\n))BUFL          - BUFFER LENGTH\n))BUFNO         - NUMBER OF BUFFERS\n))DIR           - NUMBER OF DIRECTORY BLOCKS\n))EROPT         - ERROR OPTION\n                  ACC--ACCEPT BLOCK CAUSING ERROR\n                  SKP--SKIP BLOCK CAUSING ERROR\n                  ABE--ABNORMAL END OF TASK\n))EXPDT         - DATA SET EXPIRATION DATE(YYDDD)\n))FILE          - DDNAME ASSOCIATED WITH DATA SET\n))KEYLEN        - KEY LENGTH\n))LRECL         - LOGICAL RECORD LENGTH\n))NCP           - MAX# OF READ/WRITE MACROS BEFORE A CHECK\n))OPTCD         - OPTIONAL SERVICES CODES\n                  C--CHAINED SCHEDULING IS TO BE USED\n                  T--REQUESTS USER TOTALING FACILITY\n                  W--REQUESTS A VALIDITY CHECK FOR WRITE\n                     OPERATIONS ON DIRECT ACCESS DEVICES.\n                  Q--ANSI TRANSLATE\n))RECFM         - RECORD FORMAT\n                  F--FIXED\n                  V--VARIABLE\n                  U--UNDEFINED\n                  T--TRACK OVERFLOW\n                  B--BLOCKED\n                  S--STANDARD BLOCKS\n                  A--ASA PRINTER CHARACTERS\n                  M--MACHINE CONTROL CHARACTER\n))SPACE         - DIRECT ACCESS SPACE REQUIRED\n                 QUANTITY--UNITS INITIALLY ALLOCATED TO DATASET\n                 INCREMENT--UNITS ADDED EACH TIME PREVIOUS\n                            SPACE HAS BEEN FILLED.\n                 TYPE--UNIT OF SPACE FOR ALLOCATION\n                      BLOCK-BLKSIZE VALUE*QUANTITY\n                      TRK-REQUESTED QUANTITY IN TRACKS\n                      CYL-REQUESTED QUANTITY IN CYLINDERS\n))VOLUME        - VOLUME DATA SET IS TO RESIDE\n./ ADD NAME=DEBUG\n)S       DEBUGGER - SUBCOMMANDS:\n         <ADDR>    - DISPLAY STORAGE AROUND THE GIVEN ADDRESS\n                     EXAMPLE - 1204 - DISPLAY AROUND LOCATION 1204 (HEX)\n         ASCB      - DISPLAY THE ASCB OF THE NAMED ADDRESS SPACE\n                     EXAMPLE - ASCB'TSDWSF' - ASCB FOR TSDWSF IS LOCATED\n         C         - DISPLAY AROUND ADDRESS THAT IS COMPLEMENT OF\n                     CURRENT ADDRESS\n         CSCB      - DISPLAY THE CSCB OF THE NAMED ADDRESS SPACE\n                     EXAMPLE - CSCB'TSDWSF' - CSCB OF TSDWSF IS LOCATED\n         D         - DISPLAY AN ADDRESS IN MEMORY\n                     EXAMPLES- D01234 - DISPLAY LOCATION 1234 (HEX)\n                               DBARF  - LOC AROUND VALUE OF NAME 'BARF'\n         DELETE    - DELETE A LOAD MODULE LOADED VIA THE 'LOAD' COMMAND\n                     EXAMPLE - DELETE'IEFIIC' DELETES THE NAMED MODULE\n         END       - LEAVE DEBUGGER\n         F         - FULLWORD INDIRECT ADDRESS FROM CURRENT DISPLAY ADDR\n         H         - HALFWORD INDIRECT FROM CURRENT DISPLAY ADDR\n         HELP      - REQUEST FOR HELP TEXT (YOU'RE LOOKING AT IT)\n         LOAD      - LOAD A MODULE\n                     EXAMPLE - LOAD'IEFIIC' LOADS THE NAMED MODULE,\n                     THE CURRENT DISPLAY ADDRESS IS SET TO THE NAMED\n                     ENTRY POINT.  TO FIND OFFSET ZERO IN THE MODULE,\n                     YOU MAY USE THE '?C' COMMAND.\n         N         - AND STORAGE AT CURRENT DISPLAY ADDRESS\n                     EXAMPLE - NFE - AND CURRENT ADDR WITH  X'FE'\n         O         - OR STORAGE AT CURRENT DISPLAY ADDRESS\n                     EXAMPLE - O01 - OR CURRENT ADDR WITH X'01'\n         S         - STORE AT THE CURRENT DISPLAY ADDRESS\n                     EXAMPLE - S'CE' - STORE C'CE' AT CURRENT ADDR\n         UCB       - DISPLAY THE UCB FOR A DEVICE\n                     EXAMPLE - UCB00F - FIND UCB FOR DEVICE '00F'\n         X         - EXCLUSIVE OR AT THE CURRENT DISPLAY ADDRESS\n                     EXAMPLE - X0F - XOR CURRENT ADDR WITH X'0F'\n         X SPACE   - P.C.F. TRANSFER TO OTHER TSO COMMAND\n                     EXAMPLE - X MS - INVOKE ''MS'' COMMAND (SPACE REQ)\n                     N O T E - IF YOU ''X'' TO AN UNAUTHORIZED COMMAND,\n                               YOU WILL LOSE A.P.F. AUTHORIZATION.\n                               TO REGAIN AUTHORIZATION YOU MUST LEAVE\n                               AND RE-ENTER DEBUGGER.\n         =         - ASSIGN A NAME TO CURRENT DISPLAY ADDRESS\n                     EXAMPLE - =QQ - ASSIGN CURRENT ADDR TO NAME 'QQ'\n         %         - INVOKE AN EXEC FROM SYSPROC\n                     EXAMPLE - %CVT - INVOKE 'CVT' EXEC FROM SYSPROC\n                     N O T E - 'CONTROL LIST' IN A CLIST WILL NOT HAVE\n                               ANY EFFECT.  THE STACK WILL BE FLUSHED\n                               AT THE FIRST INVALID COMMAND.\n         <         - BACKUP IN DISPLAY TRACE TABLE\n                     EXAMPLE - <<< - BACK UP THREE ENTRIES\n         >         - FORWARD IN DISPLAY TRACE TABLE\n                     EXAMPLE - >>> - GO FORWARD THREE ENTRIES\n         ?C        - DISPLAY LOADED MODULE INFORMATION\n         ?N        - DISPLAY NAME TABLE\n         ?T        - DISPLAY TRACE TABLE\n         +         - ADD TO CURRENT DISPLAY ADDRESS AND DISPLAY\n                     EXAMPLE - +40 - ADD X'40' TO CURRENT LOCATION\n                               QQ+40 - ADD X'40' TO VALUE OF NAME 'QQ'\n                                       AND DISPLAY THAT LOCATION\n         -         - SUBTRACT FROM CURRENT DISPLAY ADDRESS AND DISPLAY\n                     EXAMPLE - -40 - SUB X'40' FROM CURRENT LOCATION\n                               QQ-40 - SUB X'40' FROM VALUE OF NAME 'QQ'\n                                       AND DISPLAY THAT LOCATION\n         ,         - SEPARATE COMMANDS\n                     EXAMPLE - 10,F,F,+4,F - FINDS CURRENT TCB\n                     N O T E - ',' CANNOT BE USED ON THE SAME INPUT\n                               LINE AS A '%' INVOCATION OF A CLIST.\n         *         - REDISPLAY CURRENT CORE ADDRESS\n         (BLANKS)  - SAME AS '*'\n         ANYTHING ELSE IS TAKEN AS AN ADDRESS TO\n                   DISPLAY (NAMES MAY BE USED AS ADDRESSES)\n)F       DEBUGGER - FUNCTION\n         THE DEBUGGER IS USED TO DISPLAY AND/OR MODIFY\n         VIRTUAL MEMORY.\n         CURRENTLY, ONLY THE VIRTUAL ADDRESS SPACE OF THE CALLER IS\n         AVAILABLE.\n         BOTH UNPROTECTED AND PROTECTED STORAGE MAY BE EXAMINED\n         AND ALTERED.\n)X       DEBUGGER - SYNTAX\n         DEBUGGER\n\n         THE DEBUGGER IS RESTRICTED TO TECHNICAL SUPPORT\n                   MAINTENANCE PERSONNEL.\n         ANY OTHER PERSON REQUESTING THE DEBUGGER WILL\n                   BE RETURNED TO READY MODE.\n\n         SPECIFYING AN ADDRESS IN EITHER HEXIDECIMAL OR DECIMAL\n         WILL CAUSE DEBUGGER TO DISPLAY STORAGE AROUND THAT ADDRESS.\n\n         EXAMPLES OF THE SYNTAX OF ADDRESS AND VALUES ARE AS FOLLOWS:\n               01234DF   -  HEXIDECIMAL SELF DEFINING TERM\n               123456.   -  DECIMAL     SELF DEFINING TERM\n               'ABCDEF'  -  CHARACTER   SELF DEFINING TERM\n\n         -- THE VALUE OF <ADDR> AND <VALUE> USED IN THE FOLLOWING\n            DISPLAYS IS DETERMINED AS FOLLOWS:\n            NUMBERS AND HEX DIGITS ENTERED WITHOUT A TRAILING '.'\n            ARE INTERPRETED IN ALL CASES TO BE 'HEX';\n            IF FOLLOWED BY A '.', IT IS INTERPRETED TO BE\n            'DECIMAL'\n                   (NOTE: FOR PURPOSES OF STORAGE ALTERING COMMANDS,\n                    THE LENGTH OF STORAGE TO BE ALTERED IS ALWAYS:\n                    1+LEN_ENTERED/2 DROPPING ANY REMAINDER FOR HEX,\n                    4 FOR DECIMAL,AND\n                    LEN_ENTERED FOR CHARACTER.\n                    THE MAXIMUM LENGTH IS:\n                    8 HEX DIGITS, OR\n                    8 CHARACTERS, OR\n                    AS MUCH AS 1 FULLWORD (DECIMAL)\n\n            FOR PURPOSES OF INTERMEDIATE COMPUTATION, ALL\n            VALUES ARE KEPT IN A FULLWORD, WITH HI ORDER BITS\n            TRUNCATED AS NECESSARY.\n                   (E.G.  D123456789 - WOULD BE INTERPRETED AS\n                          D23456789)\n\n            IF THE INPUT FOR AN <ADDR> VALUE IS INVALID,\n            I.E. CONTAINS NON-HEX CHARACTERS, IT WILL BE ASSUMED\n            TO BE A NAME.  IF IT IS NOT FOUND IN THE NAME TABLE,\n            AN ERROR MESSAGE WILL BE DISPLAYED WITH A BAR ('|') UNDER\n            THE APPROXIMATE LOCATION OF THE ERROR, IF POSSIBLE.\n\n            <VALUE> INFORMATION MUST BE ENTERED AS A SELF-DEFINING\n            TERM IN HEX, OR DECIMAL (FOLLOWED BY A '.'), OR\n            CHARACTER (STRING OF CHARACTERS SURROUNDED BY, AND\n            CONTAINING NO, SINGLE QUOTES ('))\n\n         NOTE -\n                   SINCE 'B','C',AND 'D' ARE COMMANDS, HEX NUMBERS\n                   BEGINNING WITH THESE VALUES MUST BE SPECIFIED WITH\n                   A LEADING ZERO.\n                   NAMES BEGINNING WITH THESE LETTERS SHOULD BE AVOIDED.\n)O      NO OPERANDS ARE REQUIRED ON THE DEBUGGER COMMAND.\n./ ADD NAME=DEX\n)F       FUNCTION\n         DEX IS A HEX/DECIMAL CALCULATOR.\n         IT IS STRICTLY 'FIXED-POINT' AND IGNORES OVERFLOW\n            CONDITIONS.\n)X       SYNTAX\n         DEX WILL ACCEPT JUST ABOUT ANYTHING FOR INPUT.\n         OPERATIONS THAT WILL BE ACCEPTED ARE:\n            + - ADD;\n            - - SUBTRACT\n            * - MULTIPLY;\n            / - DIVIDE.\n            --- EXPONENTIATION IS NOT SUPPORTED --\n         A SEMI-COLON (;) IS USED TO SEPARATE INPUT EQUATIONS.\n\n         COMMAND SYNTAX:\n           SYMBOL = VALUE;\n           VALUE;\n           EQUATION;\n           (E.G.   A=23;126H;33+3233H-323.+7) ARE ALL VALID\n\n         THE DEFAULT MODE IS DECIMAL.\n           ALL HEX VALUES IN DECIMAL MODE MUST BE FOLLOWED BY\n           THE CHARACTER 'H'.\n           ALL DECIMAL VALUES IN HEX MODE MUST BE FOLLOWED\n           BY THE CHARACTER '.'.\n\n)O       OPERANDS AND COMMANDS\n         /SORT - DISPLAY A SORTED SYMBOL TABLE\n         /DUMP - DISPLAY THE SYMBOL TABLE\n         /HEX  - SET MODE TO HEX\n         /DEC  - SET MODE TO DECIMAL\n         /DISP - DISPLAY ALL EQUATIONS AS PROCESSED\n         /NODISP-DISPLAY ONLY THE RESULT\n         /DELETE-DELETE A SYMBOL FROM THE SYMBOL TABLE\n\n         EXAMPLES OF INPUT:\n         /HEX;START=0ABBC0;ERROR=0AC000;OFFSET=ERROR-START;/SORT\n         (NOTE THAT HEX VALUES BEGINNING WITH A CHARACTER\n          MUST BE PRECEEDED BY A ZERO TO PREVENT THEIR\n          BEING INTERPRETED AS VARIABLES).\n\n         --- NOTES --\n           1) SEMI-COLONS SEPARATE EQUATIONS;\n           2) DIVISION BY ZERO YIELDS AN ERROR MESSAGE;\n           3) 0FFFFFFFFH + 1 YIELDS ZERO.\n           4) A PRIMATIVE LOOPING CAPABILITY IS PRESENT,\n              IF NEW INPUT IS NOT ENTERED AFTER ANY DISPLAY,\n              THE LAST INPUT WILL BE USED.\n              EXAMPLE:\n               YOU ENTER: A = 3;\n               DEX RETURNS:   3 00000003\n               YOU ENTER: A = A*3;\n               DEX RETURNS:   9 00000009\n               YOU ENTER: <CARRIER RETURN OR SHIFT/ENTER>\n               DEX RETURNS: ENTER EQUATION(S) OR 'END'\n               YOU ENTER: <CARRIER RETURN OR SHIFT/ENTER>\n               DEX RETURNS:  27 0000001B\n            ETC...\n           5) THE CURRENT RESULT IS KEPT IN THE SYMBOL '*'...\n              THIS MEANS THAT TO GET THE CURRENT RESULT TIMES 2\n              ONE COULD ENTER **2;\n              TO GET THE CURRENT RESULT TO THE THIRD POWER, ONE\n              COULD ENTER *****.\n\n./ ADD NAME=DISK\n)F FUNCTION -\n   THE DISK COMMAND WILL LIST ALL DASD DEVICES THAT ARE ONLINE.\n)X SYNTAX -\n         DISK    ADDRESS/VOLSER/BOTH\n  REQUIRED - NONE\n  DEFAULTS - BOTH\n  ALIAS    - DI\n\n   OUTPUT FROM THE SPACE COMMAND HAS THE FOLLOWING FORMAT:\n\n   VOL SER     ADDR      UNIT    ALOC\n\n          VOL SER  - IS THE VOLUME SERIAL.\n\n             ADDR  - IS THE ADDRESS OF THE DEVICE.\n\n             UNIT  - IS THE DEVICE TYPE.\n\n             ALOC  - IS AN INDICATOR.\n                     A MEANS THE DEVICE IS ALLOCATED.\n                     U MEANS THE DEVICE IS UNALLOCATED.\n\n)O OPERANDS -\n))ADDRESS      - DISPLAY ONLINE DASD VOLUMES BY ASCENDING ADDRESSES.\n))VOLSER       - DISPLAY ONLINE DASD VOLUMES BY SORTED VOLUME NAMES.\n))BOTH         - DISPLAY ONLINE DASD VOLUMES FIRST BY ASCENDING\n                 ADDRESSES AND THEN BY SORTED VOLUME NAMES.\n./ ALIAS NAME=DI\n./ ADD NAME=DMOD     0100-80154-80154-1658-00018-00018-00000-$SYS13  00\n)F   DMOD CAN CHANGE FIELDS IN THE FORMAT 1 DSCB.\n)X  DMOD  DSNAME  'OPTIONS'\n    DSNAME    -  STANDARD TSO DSNAME FORMAT.\n    'OPTIONS' -  ANY OR ALL OF THE FOLLOWING FIELDS OF THE FORMAT 1\n               DSCB THAT ARE TO BE MODIFIED.\n\n       ACCOUNT(DATA) -\n       BLKSIZE(NUMBER) -\n       LRECL(NUMBER) -\n       RECFM('FBS', 'VBA', 'U', ETC.) -\n       DSORG('IS', 'ISU', 'DA', 'DAU', 'PO', 'POU', 'PS', OR 'PSU') -\n       KEYLEN(NUMBER) -\n       CDATE(JULIAN DATE) -\n       EDATE(JULIAN DATE) -\n       PASSWORD('R', 'W' OR 'N') -\n       VOLUME(VOLSER FOR UNCATALOGED DATA SETS) -\n       ADDRESS  -  WRITTEN AS IS - RETURNS DSCB ADDRESS\n)O\n./ ADD NAME=DPCPROB  0100-80036-80036-1211-00015-00015-00000-$SYS13  00\n)F   FUNCTION -\n   THE DPCPROB COMMAND PROVIDES THE TSO USER WITH A MEANS TO DOCUMENT\n   PROBLEMS EXPERIENCED WHILE USING THE SERVICES PROVIDED AT THE\n   ITEL DATA PROCESSING CENTER.  THESE PROBLEMS WILL BE REVIEWED\n   ON A DAILY BASIS. COMMENTS RECOMMENDATIONS AND SUGGESTIONS FOR\n   AREAS OF IMPROVEMENT ARE ALSO WELCOME AND ENCOURAGED.\n\n   THE DPCPROB COMMAND WILL PROMPT THE USER FOR DOCUMENTATION.\n   THE USER SHOULD ENTER AS MANY 80 CHARACTER LINES AS NECESSARY TO\n   THOROUGHLY EXPLAIN HIS/HER PROBLEM; THEN ENTER A CARRIAGE RETURN\n   TO SIGNAL THAT THE INPUT IS COMPLETE.\n)X   SYNTAX   -\n          DPCPROB\n)O   OPERANDS -\n          THERE ARE NO OPERANDS FOR THIS COMMAND.\n./ ADD NAME=DSAT\n)F FUNCTION -\n  THE DSAT COMMAND PROVIDES DATASET ATTRIBUTE AND ALLOCATION\n  INFORMATION.\n\n)X SYNTAX -\n        DSAT 'DSNAME'\n\n  REQUIRED  - 'DSNAME'\n)O OPERANDS -\n  'DSNAME'  - SPECIFIES THE NAME OF THE DATASET TO HAVE ITS ATTRIBUTES\n              AND ALLOCATION INFORMATION DISPLAYED.\n./ ADD NAME=DSPACE\n)F FUNCTION -\n  THE DSPACE COMMAND  DISPLAYS THE AMOUNT OF FREE SPACE ON A VOLUME.\n)X SYNTAX -\n         DSPACE 'VOLLIST'\n  REQUIRED - 'VOLLIST'\n  DEFAULTS - NONE\n  ALIAS    - DS\n)O OPERANDS -\n  'VOLLIST' - A SINGLE VOLUME OR A LIST OF VOLUMES TO BE LISTED.\n./ ALIAS NAME=DS\n./ ADD NAME=DUMMY\nDJDJ\n./ ADD NAME=ENQ\n)S SUBCOMMANDS -\n     CONFLICT,GLOBAL,FIND,END\n)F FUNCTION -\n     THE ENQ COMMAND DISPLAYS THE MVS ENQUEUE STRUCTURE\n)X SYNTAX -\n     ENQ\n)O OPERANDS -\n     THERE ARE NO OPTIONS WHICH MAY BE GIVEN FOR THE ENQ COMMAND\n     THE DEFAULT REQUEST FOR THE INITIAL ENTRY IS CONFLICT.\n\n SUBCOMMANDS\n   CONFLICT -\n     THE CONFLICT SUBCOMMAND IS INVOKED BY ENTERING CONFLICT OR C,\n     AND DISPLAYS ONLY THOSE ENQUEUES WHICH ARE IN CONFLICT\n     WITH ONE ANOTHER.\n\n   GLOBOL -\n     THE GLOBAL SUBCOMMAND IS INVOKED BY ENTERING GLOBAL OR G,\n     AND DISPLAYS ALL OUTSTANDING MVS ENQUEUES.\n\n   FIND MAJOR MINOR JOB -\n     THE FIND COMMAND IS INVOKED BY ENTERING FIND OR F,\n     AND DISPLAYS ANY OUTSTANDING MVS ENQUEUES WHICH MATCH\n     THE SCAN CRITERIA ENTERED WITH THE FIND COMMAND.\n\n       MAJOR - IS THE MAJOR QCB NAME TO BE FOUND.\n         THE COMPARISON IS PERFORMED ON AS MANY BYTES OF\n         MAJOR NAME AS ARE GIVEN IN THE FIND COMMAND.\n         A ''*'' MAY BE GIVEN WHICH MEANS TO FIND ALL\n         MAJOR NAMES.\n\n       MINOR - IS THE MINOR QCB NAME TO BE FOUND.\n         THE COMPARISON IS PERFORMED ON AS MANY BYTES OF\n         MINOR NAME AS ARE GIVEN IN THE FIND COMMAND.\n         A ''*'' MAY BE GIVEN WHICH MEANS TO FIND ALL\n         MINOR NAMES.\n\n       JOB - IS THE JOB NAME TO BE FOUND.\n         THE COMPARISON IS PERFORMED ON AS MANY BYTES OF\n         JOB NAME AS ARE GIVEN IN THE FIND COMMAND.\n         A ''*'' MAY BE GIVEN WHICH MEANS TO FIND ALL\n         JOB NAMES.\n\n     END -\n     THE END COMMAND TERMINATES THE ENQ PROGRAM.  MAY BE GIVEN AS\n     END OR E.\n\n     THE FORMAT OF THE ENQ DISPLAY IS AS FOLLOWS:\n\n1234  JJJJJJJJ VVVVVV-UUU MMMMMMMM NNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNN\n\n     1 - THE SCOPE OF THE ENQ; Y = SYSTEM, J = STEP\n     2 - THE TYPE OF ENQ; E = EXCLUSIVE, S = SHARED\n     3 - THE STATUS OF THE ENQ; G = HAS RESOURCE, W = WAITING\n     4 - THE SYSTEM SCOPE OF ENQ; R = RESERVE\n\n     J - THE JOB NAME OF THE ENQING ADDRESS SPACE\n     V - THE VOLUME SERIAL ON THE RESERVED SPINDLE\n     U - THE UNIT ADDRESS OF THE RESERVED SPINDLE\n     M - THE MAJOR RESOURCE NAME\n     N - THE MINOR RESOURCE NAME\n./ ADD NAME=LA       0103-79157-79157-1821-00009-00061-00005-$SYS15  00\n)F FUNCTION -\n   THE LISTATTR COMMAND DISPLAYS ALL CURRENTLY DEFINED ATTRIBUTE LISTS.\n)X SYNTAX -\n   LISTATTR\n   DEFAULTS - NONE\n   ALIAS    - LA\n)O OPERANDS -\n   THERE ARE NO OPERANDS FOR THE LISTATTR COMMAND.\n\n./ ADD NAME=LISTATTR 0103-79157-79157-1821-00009-00061-00005-$SYS15  00\n)F FUNCTION -\n   THE LISTATTR COMMAND DISPLAYS ALL CURRENTLY DEFINED ATTRIBUTE LISTS.\n)X SYNTAX -\n   LISTATTR\n   DEFAULTS - NONE\n   ALIAS    - LA\n)O OPERANDS -\n   THERE ARE NO OPERANDS FOR THE LISTATTR COMMAND.\n\n./ ADD NAME=LOCAL    0100-80044-80044-0803-00029-00029-00000-$SYS13  00\n)F LOCAL (NON-IBM) COMMANDS:\n)X\n#         PERFORM FUNCTIONS OF THE CALL COMMAND BUT IS RESTRICTED TO\n          DATASETS CONTAINED IN THE LINKLIST.\n          (NEEDS AUTHORIZATION LEVEL OF 2 OR LESS).\nASID      DISPLAY SYSTEM INFORMATION ABOUT JOBS, TASKS AND TSO USERS.\nASM       TSO ASSEMBLER PROMPTER.\n          (NEEDS AUTHORIZATION LEVEL OF 2 OR LESS).\nCALC      A TSO CALCULATOR PROGRAM.\nCLR3270   ALLOWS A TSO USER TO ISSUE A FULL-SCREEN CLEAR OF A 3277\nDEX       A DECIMAL AND HEXADECIMAL CALCULATOR.\nDISK      DISPLAY DISKS CURRENTLY ONLINE.\nDPCPROB   A FACILITY FOR DOCUMENTING USER PROBLEMS, SUGGESTIONS, AND\n          RECOMMENDATIONS FOR AREAS OF IMPROVEMENT IN USING MVS/TSO.\nDSPACE    DISPLAY THE AMOUNT OF FREE SPACE ON A VOLUME.\nENQ       DISPLAY SYSTEM ENQ STRUCTURE.\nENQASID   DISPLAY ENQ FOR AN ADDRESS SPACE.\nFREEALL   FREE ALL DYNAMICALLY ALLOCATED FILES.\nLISTATTR  DISPLAY ALL CURRENTLY DEFINED ATTRIBUTE LISTS.\nLPDS      ACCESS MEMBERS AND MANIPULATE THE DIRECTORY OF A\n          PARTITIONED DATASET.\nPRINTOFF  OBTAIN  HARDCOPY OF DATASETS ON LOCAL OR REMOTE PRINTERS.\nSPACE     INDICATE SPACE ATTRIBUTES OF DATA SETS - ALIAS SP.\nSTATE     USED IN CLISTS TO DETERMINE WHETHER A DATASET IS CATALOGED\n          OR NOT CATALOGED.\nTAPEINQ   DISPLAY INFORMATION ABOUT TAPES THROUGH UCC TAPE MANAGEMENT\n          SOFTWARE (TMS).\nWHOHAS    SHOWS WHO HAS A PARTICULAR DATASET.\n)O\n./ ADD NAME=LOCAL9   0100-80028-80028-1011-00032-00032-00000-$SYS13  00\n)F LOCAL (NON-IBM) COMMANDS:\n)X\n#         PERFORM FUNCTIONS OF THE CALL COMMAND BUT IS RESTRICTED TO\n          DATASETS CONTAINED IN THE LINKLIST.\nASID      DISPLAY SYSTEM INFORMATION ABOUT JOBS, TASKS AND TSO USERS.\nASM       TSO ASSEMBLER PROMPTER.\nCLR3270   ALLOWS A TSO USER TO ISSUE A FULL-SCREEN CLEAR OF A 1377/3277\nCREATE    COMBINES MOST OF THE PARAMETERS OF THE ALLOCATE AND THE\n          ATTRIBUTE COMMANDS FOR CREATING NEW DATASETS INTO A SINGLE\n          COMMAND.\nDEX       A DECIMAL AND HEXADECIMAL CALCULATOR.\nDISK      DISPLAY DISKS CURRENTLY ONLINE.\nDSPACE    DISPLAY THE AMOUNT OF FREE SPACE ON A VOLUME.\nENQ       DISPLAY SYSTEM ENQ STRUCTURE.\nENQASID   DISPLAY ENQ FOR AN ADDRESS SPACE.\nFREEALL   FREE ALL DYNAMICALLY ALLOCATED FILES.\nLISTATTR  DISPLAY ALL CURRENTLY DEFINED ATTRIBUTE LISTS - ALIAS LA.\nLPDS      ACCESS MEMBERS AND MANIPULATE THE DIRECTORY OF A\n          PARTITIONED DATASET.\nPANVIEW   NOT A COMMAND BUT A FULL-SCREEN PROGRAM FOR DISPLAYING\n          PANVALET MODULES AT A 3277 TYPE TERMINAL.\nPRINTOFF  OBTAIN  HARDCOPY OF DATASETS ON LOCAL OR REMOTE PRINTERS.\nSPACE     INDICATE SPACE ATTRIBUTES OF DATA SETS - ALIAS SP.\nSTATE     USED IN CLISTS TO DETERMINE WHETHER A DATASET IS CATALOGED\n          OR NOT CATALOGED.\nVOLSER    TO MAKE INQUIRIES INTO THE SYSTEM CATALOG AS WELL AS CATLG\n          OR UNCATLG A DATA SET.\nVTOC      DISPLAY THE VOLUME TABLE OF CONTENTS OF ON-LINE DASD MEETING\n          A VARIETY OF USER-DEFINED CRITERIA - SUPERIOR TO THE SPF VTOC\n          UTILITY FUNCTION (OPTION 3.7).\nWHOHAS    SHOWS WHO HAS A PARTICULAR DATASET.\n)O\n./ ADD NAME=LP\n)F FUNCTION -\n               THE LPDS COMMAND ALLOWS THE TSO USER TO\n               ACCESS AND MANIPULATE THE DIRECTORY AND\n               SELECTED MEMBERS OF A PARTITIONED DATA SET.\n\n               THE LPDS COMMAND PROVIDES OPTIONS TO DISPLAY THE\n               DIRECTORY, SCRATCH, RENAME AND CREATE ALIASES\n               FOR SELECTED MEMBERS, TO DISPLAY AND UPDATE\n               THE ATTRIBUTES OF LOAD MODULES, AND TO PRODUCE\n               A BRIEF MODULE MAP AND HISTORY SUMMARY FOR\n               SELECTED LOAD MODULES.\n\n)X SYNTAX -\n          LPDS    DSNAME     VOLUME(NAME)\n\n DEFAULTS - NONE.\n REQUIRED - DSNAME.\n\n ALIAS    - LP.\n\n)O OPERANDS -\n   DSNAME -    INDICATES THE NAME OF THE PARTITIONED DATA SET.\n   VOLUME -    INDICATES THE OPTIONAL NAME OF THE VOLUME ON\n               WHICH THE DATA SET RESIDES.\n\n)S  THE LPDS COMMAND HAS THE FOLLOWING SUBCOMMANDS:\n               ALIAS, ATTRIBUTE, CHANGE, DISPLAY, END, EXEC,\n               HELP, HISTORY, LIST, MAP, OPTIONS, RENAME,\n               SCRATCH, USAGE\n=ALIAS=AL=ALI=ALIA\n)F THE ALIAS SUBCOMMAND ALLOWS AN ALIAS TO BE ASSIGNED TO AN EXISTING\n  MEMBER. IF THE DATA SET IS A LOAD MODULE LIBRARY, AND THE ALIAS\n  NAME IS AN IMBEDDED EXTERNAL NAME WITHIN THE LOAD MODULE, THEN\n  THE ENTRY POINT ASSIGNED FOR THE ALIAS WILL REFLECT THE ADDRESS\n  OF THE IMBEDDED ENTRY WITHIN THE LOAD MODULE. IF THE ALIAS\n  NAME IS NOT AN IMBEDDED ENTRY, THE ENTRY POINT FOR THE ORIGINAL\n  LOAD MODULE IS ASSIGNED AS THE ENTRY POINT FOR THE NEW ALIAS.\n)X SYNTAX -\n         ALIAS    MEMBER1  MEMBER2\n)O OPERANDS -\n MEMBER1 -     SPECIFIES THE NAME OF THE EXISTING MEMBER TO WHICH THE\n               ALIAS IS TO BE ASSIGNED.\n MEMBER2 -     SPECIFIES THE ALIAS NAME TO BE ASSIGNED TO THE MEMBER.\n=ATTR=A=AT=ATT\n)F THE ATTRIBUTE SUBCOMMAND ALLOWS THE ATTRIBUTES OF A LOAD MODULE TO\n  BE DISPLAYED, AND OPTIONALLY, NEW ATTRIBUTES TO BE ASSIGNED TO THE\n  LOAD MODULE. THIS SUBCOMMAND IS AVAILABLE ONLY FOR USE WITH LOAD\n  MODULE LIBRARIES.\n)X SYNTAX -\n         ATTR     MEMBER1  (NAME NAME NAME ....)\n)O OPERANDS -\n MEMBER   -    SPECIFIES THE NAME OF THE LOAD MODULE WHOSE ATTRIBUTES\n               ARE TO BE DISPLAYED OR UPDATED.\n NAME     -    SPECIFIES THE ATTRIBUTE(S) WHICH ARE TO BE ASSIGNED TO\n               THE LOAD MODULE. CURRENT ATTRIBUTES ARE NULLIFIED BY\n               PREFIXING THE ATTRIBUTE NAME WITH 'NO'. ONLY THE\n\n                       RENT   REUS   REFR  EXEC  AUTH\n\n               ATTRIBUTES MAY BE CHANGED. FOR A COMPLETE DESCRIPTION\n               OF THE ATTRIBUTES OF A LOAD MODULE, REFER TO THE\n               IBM LINKAGE EDITOR MANUAL.\n\n NOTE - IF THE ATTRIBUTE LIST IS NOT SPECIFIED, ONLY THE CURRENT\n        ATTRIBUTES OF THE LOAD MODULE ARE DISPLAYED.\n\n     - AUTHORIZATION CAN ONLY BE CHANGED FOR MODULES LINK EDITIED\n       BY THE OS/VS LINKAGE EDITOR.  THE ATTRIBUTE COMMAND WILL\n       INFORM YOU IF A MODULE WAS NOT SO LINK EDITED.\n=CHANGE=C=CH=CHA=CHAN=CHANG\n)F   THE CHANGE SUBCOMMAND ALLOWS THE USER TO SWITCH PROCESSING FROM\n ONE DATA SET TO ANOTHER WITH OUT LEAVING THE LPDS COMMAND.\n)X SYNTAX -\n         CHANGE   DSNAME   VOLUME(VOLID)\n)O OPERANDS -\n DSNAME  -     SPECIFIES THE NAME OF THE NEW DATA SET TO BE PROCESSED.\n VOLUME  -     SPECIFIES THE OPTIONAL NAME OF THE VOLUME ON WHICH THE\n               DATA SET RESIDES.\n=DISPLAY=D=DIS=DISP=DISPL=DISPLA\n)F       THE DISPLAY SUBCOMMAND ALLOWS THE DIRECTORY OF THE DATA\n   SET TO BE LISTED. OPTIONALLY, THE STARTING AND ENDING\n   RANGE WITHIN THE DIRECTORY MAY BE SPECIFIED.\n)X SYNTAX -\n         DISPLAY  MEMBER1  MEMBER2\n)O OPERANDS -\n MEMBER1 -     SPECIFIES THE STARTING MEMBER NAME, OR PORTION OF THE\n               MEMBER NAME AT WHICH THE DISPLAY IS TO START.\n MEMBER2 -     SPECIFIES THE ENDING MEMBER NAME, OR PORTION OF THE\n               NAME, AT WHICH THE DISPLAY IS TO STOP. CAN ONLY BE\n               SPECIFIED IF MEMBER1 IS SPECIFIED. IF THIS NAME IS\n               OMITTED, THE DISPLAY CONTINUES THROUGH THE END OF THE\n               DIRECTORY.\n=END=E=EN\n)F   THE END SUBCOMMAND IS USED TO LEAVE THE LPDS COMMAND.\n)X SYNTAX -\n         END\n)O OPERANDS -\n NO OPERANDS ARE SUPPORTED.\n=EXEC=E=EX=EXE=%\n)F   THE EXEC SUBCOMMAND WILL EXECUTE A CLIST.\n     THE IMPLICIT CLIST FORM IS ALSO SUPPORTED.\n)X SYNTAX -\n         EXEC     CLISTNAME     LIST\n         %MEMBER\n)O OPERANDS -\n CLISTNAME -   SPECIFIES THE NAME OF THE CLIST DATA SET TO BE\n               EXECUTED, PRIOR TO EXECUTION.\n MEMBER    -   SPECIFIES THE NAME OF THE MEMBER OF THE CLIST PDS\n               ALLOCATED TO THE FILE NAME 'SYSPROC' THAT IS TO BE\n               EXECUTED.\n=HISTORY=HI=HIS=HIST=HISTO=HISTOR\n)F THE HISTORY SUBCOMMAND PRODUCES A BRIEF LISTING OF THE SYSTEM\n IDENTIFY RECORDS ASSIGNED TO THE LOAD MODULE.\n\n NOTE THAT THESE RECORDS DO NOT EXIST FOR LOAD MODULES CREATED\n PRIOR TO RELEASE 21 OF OS/360,  AND THAT THE\n INFORMATION WITHIN THESE RECORDS IS BASED UPON THAT INFORMATION\n SUPPLIED BY THE USER. ITS CONTENTS AND CURRENT STATUS IS\n THEREFORE DEPENDENT ON THE PERSON RESPONSIBLE FOR THE MODULE\n AND MAY NOT ALWAYS BE CURRENT OR APPLICABLE.\n)X SYNTAX -\n         HISTORY   MEMBER\n)O OPERANDS -\n MEMBER  -  SPECIFIES THE NAME OF THE LOAD MODULE FOR WHICH\n            THE HISTORY SUMMARY IS TO BE PRODUCED.\n=LIST=L=LI=LIS\n)F   THE LIST SUBCOMMAND WILL LIST THE CONTENTS OF A NON LOAD MODULE\n (I.E. SOURCE, CLIST, CNTL) MEMBER\n)X SYNTAX -\n         LIST     MEMBER    NUM/NONUM\n         DEFAULT  NUM\n)O OPERANDS -\n MEMBER  -  SPECIFIES THE NAME OF THE MEMBER TO BE LISTED\n NUM     -  NUM INDICATES THAT THE MEMBER TO BE LISTED HAVE\n            SEQUENCE FIELDS, WHICH WILL APPEAR ON THE LEFT OF THE\n            OUTPUT.\n NONUM   -  THE SEQUENCE FIELD OF THE DATA RECORD(S) IS TO BE\n            IGNORED AND WILL BE PRINTED AS DATA.\n=MAP=M=MA\n)F    THE MAP SUBCOMMAND PRODUCES A BRIEF REFERENCE MAP OF THE\n LINKAGE EDITOR STRUCTURE FOR A LOAD MODULE. THIS MAP IS\n SIMILAR IN NATURE TO THE ONE PRODUCED BY THE MAP OPTION OF\n THE LINKAGE EDITOR.\n)X SYNTAX -\n         MAP     MEMBER\n)O OPERANDS -\n MEMBER -      SPECIFIES THE NAME OF THE LOAD MODULE FOR WHICH\n               THE MODULE MAP IS TO BE PRODUCED.\n=OPTIONS=O=OP=OPT=OPTI=OPTIO=OPTION\n)F   THE OPTIONS SUBCOMMAND DISPLAYS THE SUBCOMMANDS CURRENTLY\n SUPPORTED BY THE LPDS COMMAND.  A SIMILAR DISPLAY CAN BE OBTAINED\n USING 'HELP'.\n)X SYNTAX -\n         OPTIONS\n)O OPERANDS -\n NO OPERANDS ARE SUPPORTED.\n=RENAME=R=RE=REN=RENA=RENAM\n)F THE RENAME SUBCOMMAND ALLOWS A SELECTED MEMBER TO BE RENAME\n    WITHIN THE DATA SET.\n)X SYNTAX -\n         RENAME   MEMBER1  MEMBER2\n)O OPERANDS -\n MEMBER1 -     SPECIFIES THE CURRENT NAME OF THE MEMBER.\n MEMBER2 -     SPECIFIES THE NEW NAME FOR THE MEMBER.\n=SCRATCH=S=SC=SCR=SCRA=SCRAT=SCRATC\n)F THE SCRATCH SUBCOMMAND ALLOWS A SELECTED MEMBER TO BE DELETED FROM\n  THE DATA SET.\n)X SYNTAX -\n         SCRATCH  MEMBER\n)O OPERANDS -\n MEMBER - SPECIFIES THE NAME OF THE MEMBER TO BE DELETED.\n=USAGE=U=US=USA=USAG\n)F   THE USAGE SUBCOMMAND WILL LIST THE ALLOCATION AND SPACE\n UTILIZATION INFORMATION OF THE CURRENT PDS.\n)X SYNTAX -\n         USAGE\n)O OPERANDS -\n NO OPERANDS ARE SUPPORTED\n./ ADD NAME=LPDS\n)F FUNCTION -\n               THE LPDS COMMAND ALLOWS THE TSO USER TO\n               ACCESS AND MANIPULATE THE DIRECTORY AND\n               SELECTED MEMBERS OF A PARTITIONED DATA SET.\n\n               THE LPDS COMMAND PROVIDES OPTIONS TO DISPLAY THE\n               DIRECTORY, SCRATCH, RENAME AND CREATE ALIASES\n               FOR SELECTED MEMBERS, TO DISPLAY AND UPDATE\n               THE ATTRIBUTES OF LOAD MODULES, AND TO PRODUCE\n               A BRIEF MODULE MAP AND HISTORY SUMMARY FOR\n               SELECTED LOAD MODULES.\n\n)X SYNTAX -\n          LPDS    DSNAME     VOLUME(NAME)\n\n DEFAULTS - NONE.\n REQUIRED - DSNAME.\n\n ALIAS    - LP.\n\n)O OPERANDS -\n   DSNAME -    INDICATES THE NAME OF THE PARTITIONED DATA SET.\n   VOLUME -    INDICATES THE OPTIONAL NAME OF THE VOLUME ON\n               WHICH THE DATA SET RESIDES.\n\n)S  THE LPDS COMMAND HAS THE FOLLOWING SUBCOMMANDS:\n               ALIAS, ATTRIBUTE, CHANGE, DISPLAY, END, EXEC,\n               HELP, HISTORY, LIST, MAP, OPTIONS, RENAME,\n               SCRATCH, USAGE\n=ALIAS=AL=ALI=ALIA\n)F THE ALIAS SUBCOMMAND ALLOWS AN ALIAS TO BE ASSIGNED TO AN EXISTING\n  MEMBER. IF THE DATA SET IS A LOAD MODULE LIBRARY, AND THE ALIAS\n  NAME IS AN IMBEDDED EXTERNAL NAME WITHIN THE LOAD MODULE, THEN\n  THE ENTRY POINT ASSIGNED FOR THE ALIAS WILL REFLECT THE ADDRESS\n  OF THE IMBEDDED ENTRY WITHIN THE LOAD MODULE. IF THE ALIAS\n  NAME IS NOT AN IMBEDDED ENTRY, THE ENTRY POINT FOR THE ORIGINAL\n  LOAD MODULE IS ASSIGNED AS THE ENTRY POINT FOR THE NEW ALIAS.\n)X SYNTAX -\n         ALIAS    MEMBER1  MEMBER2\n)O OPERANDS -\n MEMBER1 -     SPECIFIES THE NAME OF THE EXISTING MEMBER TO WHICH THE\n               ALIAS IS TO BE ASSIGNED.\n MEMBER2 -     SPECIFIES THE ALIAS NAME TO BE ASSIGNED TO THE MEMBER.\n=ATTR=A=AT=ATT\n)F THE ATTRIBUTE SUBCOMMAND ALLOWS THE ATTRIBUTES OF A LOAD MODULE TO\n  BE DISPLAYED, AND OPTIONALLY, NEW ATTRIBUTES TO BE ASSIGNED TO THE\n  LOAD MODULE. THIS SUBCOMMAND IS AVAILABLE ONLY FOR USE WITH LOAD\n  MODULE LIBRARIES.\n)X SYNTAX -\n         ATTR     MEMBER1  (NAME NAME NAME ....)\n)O OPERANDS -\n MEMBER   -    SPECIFIES THE NAME OF THE LOAD MODULE WHOSE ATTRIBUTES\n               ARE TO BE DISPLAYED OR UPDATED.\n NAME     -    SPECIFIES THE ATTRIBUTE(S) WHICH ARE TO BE ASSIGNED TO\n               THE LOAD MODULE. CURRENT ATTRIBUTES ARE NULLIFIED BY\n               PREFIXING THE ATTRIBUTE NAME WITH 'NO'. ONLY THE\n\n                       RENT   REUS   REFR  EXEC  AUTH\n\n               ATTRIBUTES MAY BE CHANGED. FOR A COMPLETE DESCRIPTION\n               OF THE ATTRIBUTES OF A LOAD MODULE, REFER TO THE\n               IBM LINKAGE EDITOR MANUAL.\n\n NOTE - IF THE ATTRIBUTE LIST IS NOT SPECIFIED, ONLY THE CURRENT\n        ATTRIBUTES OF THE LOAD MODULE ARE DISPLAYED.\n\n     - AUTHORIZATION CAN ONLY BE CHANGED FOR MODULES LINK EDITIED\n       BY THE OS/VS LINKAGE EDITOR.  THE ATTRIBUTE COMMAND WILL\n       INFORM YOU IF A MODULE WAS NOT SO LINK EDITED.\n=CHANGE=C=CH=CHA=CHAN=CHANG\n)F   THE CHANGE SUBCOMMAND ALLOWS THE USER TO SWITCH PROCESSING FROM\n ONE DATA SET TO ANOTHER WITH OUT LEAVING THE LPDS COMMAND.\n)X SYNTAX -\n         CHANGE   DSNAME   VOLUME(VOLID)\n)O OPERANDS -\n DSNAME  -     SPECIFIES THE NAME OF THE NEW DATA SET TO BE PROCESSED.\n VOLUME  -     SPECIFIES THE OPTIONAL NAME OF THE VOLUME ON WHICH THE\n               DATA SET RESIDES.\n=DISPLAY=D=DIS=DISP=DISPL=DISPLA\n)F       THE DISPLAY SUBCOMMAND ALLOWS THE DIRECTORY OF THE DATA\n   SET TO BE LISTED. OPTIONALLY, THE STARTING AND ENDING\n   RANGE WITHIN THE DIRECTORY MAY BE SPECIFIED.\n)X SYNTAX -\n         DISPLAY  MEMBER1  MEMBER2\n)O OPERANDS -\n MEMBER1 -     SPECIFIES THE STARTING MEMBER NAME, OR PORTION OF THE\n               MEMBER NAME AT WHICH THE DISPLAY IS TO START.\n MEMBER2 -     SPECIFIES THE ENDING MEMBER NAME, OR PORTION OF THE\n               NAME, AT WHICH THE DISPLAY IS TO STOP. CAN ONLY BE\n               SPECIFIED IF MEMBER1 IS SPECIFIED. IF THIS NAME IS\n               OMITTED, THE DISPLAY CONTINUES THROUGH THE END OF THE\n               DIRECTORY.\n=END=E=EN\n)F   THE END SUBCOMMAND IS USED TO LEAVE THE LPDS COMMAND.\n)X SYNTAX -\n         END\n)O OPERANDS -\n NO OPERANDS ARE SUPPORTED.\n=EXEC=E=EX=EXE=%\n)F   THE EXEC SUBCOMMAND WILL EXECUTE A CLIST.\n     THE IMPLICIT CLIST FORM IS ALSO SUPPORTED.\n)X SYNTAX -\n         EXEC     CLISTNAME     LIST\n         %MEMBER\n)O OPERANDS -\n CLISTNAME -   SPECIFIES THE NAME OF THE CLIST DATA SET TO BE\n               EXECUTED, PRIOR TO EXECUTION.\n MEMBER    -   SPECIFIES THE NAME OF THE MEMBER OF THE CLIST PDS\n               ALLOCATED TO THE FILE NAME 'SYSPROC' THAT IS TO BE\n               EXECUTED.\n=HISTORY=HI=HIS=HIST=HISTO=HISTOR\n)F THE HISTORY SUBCOMMAND PRODUCES A BRIEF LISTING OF THE SYSTEM\n IDENTIFY RECORDS ASSIGNED TO THE LOAD MODULE.\n\n NOTE THAT THESE RECORDS DO NOT EXIST FOR LOAD MODULES CREATED\n PRIOR TO RELEASE 21 OF OS/360,  AND THAT THE\n INFORMATION WITHIN THESE RECORDS IS BASED UPON THAT INFORMATION\n SUPPLIED BY THE USER. ITS CONTENTS AND CURRENT STATUS IS\n THEREFORE DEPENDENT ON THE PERSON RESPONSIBLE FOR THE MODULE\n AND MAY NOT ALWAYS BE CURRENT OR APPLICABLE.\n)X SYNTAX -\n         HISTORY   MEMBER\n)O OPERANDS -\n MEMBER  -  SPECIFIES THE NAME OF THE LOAD MODULE FOR WHICH\n            THE HISTORY SUMMARY IS TO BE PRODUCED.\n=LIST=L=LI=LIS\n)F   THE LIST SUBCOMMAND WILL LIST THE CONTENTS OF A NON LOAD MODULE\n (I.E. SOURCE, CLIST, CNTL) MEMBER\n)X SYNTAX -\n         LIST     MEMBER    NUM/NONUM\n         DEFAULT  NUM\n)O OPERANDS -\n MEMBER  -  SPECIFIES THE NAME OF THE MEMBER TO BE LISTED\n NUM     -  NUM INDICATES THAT THE MEMBER TO BE LISTED HAVE\n            SEQUENCE FIELDS, WHICH WILL APPEAR ON THE LEFT OF THE\n            OUTPUT.\n NONUM   -  THE SEQUENCE FIELD OF THE DATA RECORD(S) IS TO BE\n            IGNORED AND WILL BE PRINTED AS DATA.\n=MAP=M=MA\n)F    THE MAP SUBCOMMAND PRODUCES A BRIEF REFERENCE MAP OF THE\n LINKAGE EDITOR STRUCTURE FOR A LOAD MODULE. THIS MAP IS\n SIMILAR IN NATURE TO THE ONE PRODUCED BY THE MAP OPTION OF\n THE LINKAGE EDITOR.\n)X SYNTAX -\n         MAP     MEMBER\n)O OPERANDS -\n MEMBER -      SPECIFIES THE NAME OF THE LOAD MODULE FOR WHICH\n               THE MODULE MAP IS TO BE PRODUCED.\n=OPTIONS=O=OP=OPT=OPTI=OPTIO=OPTION\n)F   THE OPTIONS SUBCOMMAND DISPLAYS THE SUBCOMMANDS CURRENTLY\n SUPPORTED BY THE LPDS COMMAND.  A SIMILAR DISPLAY CAN BE OBTAINED\n USING 'HELP'.\n)X SYNTAX -\n         OPTIONS\n)O OPERANDS -\n NO OPERANDS ARE SUPPORTED.\n=RENAME=R=RE=REN=RENA=RENAM\n)F THE RENAME SUBCOMMAND ALLOWS A SELECTED MEMBER TO BE RENAME\n    WITHIN THE DATA SET.\n)X SYNTAX -\n         RENAME   MEMBER1  MEMBER2\n)O OPERANDS -\n MEMBER1 -     SPECIFIES THE CURRENT NAME OF THE MEMBER.\n MEMBER2 -     SPECIFIES THE NEW NAME FOR THE MEMBER.\n=SCRATCH=S=SC=SCR=SCRA=SCRAT=SCRATC\n)F THE SCRATCH SUBCOMMAND ALLOWS A SELECTED MEMBER TO BE DELETED FROM\n  THE DATA SET.\n)X SYNTAX -\n         SCRATCH  MEMBER\n)O OPERANDS -\n MEMBER - SPECIFIES THE NAME OF THE MEMBER TO BE DELETED.\n=USAGE=U=US=USA=USAG\n)F   THE USAGE SUBCOMMAND WILL LIST THE ALLOCATION AND SPACE\n UTILIZATION INFORMATION OF THE CURRENT PDS.\n)X SYNTAX -\n         USAGE\n)O OPERANDS -\n NO OPERANDS ARE SUPPORTED\n./ ADD NAME=PP       0104-80016-80225-1342-00010-00037-00009-$SYS11  00\n)F PROGRAM PRODUCTS USED WITH TSO:\n)X\nASM2      ARCHIVAL STORAGE MANAGEMENT SYSTEM.\nJTIP      JES2/TSO INTERFACE PACKAGE.\nPAN       PANVALET SYSTEM.\nPCF       PROGRAMMING CONTROL FACILITY-II\nPLI       PL/1 OPTIMIZING COMPILER\nSPF       STRUCTURED PROGRAMMING FACILITY\nTSOCMDPK  TSO COMMAND PACKAGE.\nTSOUTIL   TSO UTILITES (COPY FORMAT LIST AND MERGE)\n./ ADD NAME=PRINTO   2000-77202-77202-1052-00051-00051-00000-TSO     00\n)F FUNCTION -\n   THE PRINTOFF COMMAND CAN BE USED TO OBTAIN HARDCOPY\n   OF DATA SETS THROUGH FOREGROUND COPYING TO SYSOUT.\n   THE COMMAND PRINTS A DATASET(S) WHICH IS SEQUENTIAL\n   OR PARTITIONED, BLOCKED OR UNBLOCKED, WITH FIXED OR\n   VARIABLE RECORD LENGTH LESS THAN OR EQUAL TO 256\n   (255 IF WITHOUT CARRIAGE CONTROL).\n\n)X SYNTAX -\n     PRINTOFF ('DSLIST') CLASS('CLASS') DEST('USERID')\n              COPIES('NNN') HOLD/NOHOLD\n              LIST/NOLIST PRINT/NOPRINT\n              FOLD/NOFOLD VOLUME('VOLSER')\n\n     REQUIRED -- 'DSLIST'\n     ALIAS    -- PRINTO\n     DEFAULTS -- CLASS(A), COPIES(1), NOHOLD, LIST, PRINT, NOFOLD\n\n)O OPERANDS -\n))'DSLIST'  - 'DATA SET LIST' CONTAINS THE NAMES OF DATA SETS\n            TO BE PRINTED OR PUNCHED.  THE NAMES SHOULD FOLLOW\n            TSO CONVENTION,  IN QUOTES IF THE PRIMARY INDEX\n            DIFFERS FROM YOUR USERID, OR WITHOUT QUOTES AND\n            WITH THE PRIMARY INDEX OMITTED IF IT IS THE SAME\n            AS YOUR USERID.\n))CLASS('CLASS') - SYSOUT CLASS IN WHICH OUTPUT IS TO BE\n            PRINTED.  DEFAULT IS A.\n))COPIES('NNN') - NUMBER OF COPIES TO BE PRINTED.\n            DEFAULT IS 1.\n))DEST('USERID') - REMOTE USER TO WHICH SYSOUT DATA SETS\n            ARE TO BE ROUTED.\n))HOLD      - OUTPUT IS TO BE PLACED ON A HOLD QUEUE UPON\n            DEALLOCATION.\n))NOHOLD    - OUTPUT IS NOT TO BE PLACED ON A HOLD QUEUE\n            UPON DEALLOCATION.\n))LIST      - MEMBER NAMES ARE ONLY TO BE LISTED UNLESS\n            PRINT IS EXPLICITLY STATED.\n))NOLIST    - MEMBER NAMES ARE NOT TO BE LISTED (ONLY\n            PRINTED UNLESS NOPRINT IS EXPLICITLY STATED).\n))PRINT     - MEMBERS ARE ONLY TO BE PRINTED (NOT LISTED\n            UNLESS LIST IS EXPLICITLY STATED).\n))NOPRINT   - MEMBERS ARE NOT TO BE PRINTED (ONLY LISTED\n            UNLESS NOLIST IS EXPLICITLY STATED).\n))FOLD      - OUTPUT IS TO BE CONVERTED TO UPPER CASE\n            PRIOR TO PRINTING.\n))NOFOLD    - OUTPUT IS NOT TO BE CONVERTED TO UPPER CASE\n            PRIOR TO PRINTING.\n))VOLUME('VOLSER') - VOLUME SERIAL OF VOLUME ON WHICH DATA SETS\n            TO BE PRINTED ARE FOUND.  THIS VOLUME SERIAL\n            WILL BE USED FOR ALL DATA SETS SPECIFIED IN\n            THE DATA SET LIST.\n./ ADD NAME=PRINTOFF 2000-77202-77202-1052-00051-00051-00000-TSO     00\n)F FUNCTION -\n   THE PRINTOFF COMMAND CAN BE USED TO OBTAIN HARDCOPY\n   OF DATA SETS THROUGH FOREGROUND COPYING TO SYSOUT.\n   THE COMMAND PRINTS A DATASET(S) WHICH IS SEQUENTIAL\n   OR PARTITIONED, BLOCKED OR UNBLOCKED, WITH FIXED OR\n   VARIABLE RECORD LENGTH LESS THAN OR EQUAL TO 256\n   (255 IF WITHOUT CARRIAGE CONTROL).\n\n)X SYNTAX -\n     PRINTOFF ('DSLIST') CLASS('CLASS') DEST('USERID')\n              COPIES('NNN') HOLD/NOHOLD\n              LIST/NOLIST PRINT/NOPRINT\n              FOLD/NOFOLD VOLUME('VOLSER')\n\n     REQUIRED -- 'DSLIST'\n     ALIAS    -- PRINTO\n     DEFAULTS -- CLASS(A), COPIES(1), NOHOLD, LIST, PRINT, NOFOLD\n\n)O OPERANDS -\n))'DSLIST'  - 'DATA SET LIST' CONTAINS THE NAMES OF DATA SETS\n            TO BE PRINTED OR PUNCHED.  THE NAMES SHOULD FOLLOW\n            TSO CONVENTION,  IN QUOTES IF THE PRIMARY INDEX\n            DIFFERS FROM YOUR USERID, OR WITHOUT QUOTES AND\n            WITH THE PRIMARY INDEX OMITTED IF IT IS THE SAME\n            AS YOUR USERID.\n))CLASS('CLASS') - SYSOUT CLASS IN WHICH OUTPUT IS TO BE\n            PRINTED.  DEFAULT IS A.\n))COPIES('NNN') - NUMBER OF COPIES TO BE PRINTED.\n            DEFAULT IS 1.\n))DEST('USERID') - REMOTE USER TO WHICH SYSOUT DATA SETS\n            ARE TO BE ROUTED.\n))HOLD      - OUTPUT IS TO BE PLACED ON A HOLD QUEUE UPON\n            DEALLOCATION.\n))NOHOLD    - OUTPUT IS NOT TO BE PLACED ON A HOLD QUEUE\n            UPON DEALLOCATION.\n))LIST      - MEMBER NAMES ARE ONLY TO BE LISTED UNLESS\n            PRINT IS EXPLICITLY STATED.\n))NOLIST    - MEMBER NAMES ARE NOT TO BE LISTED (ONLY\n            PRINTED UNLESS NOPRINT IS EXPLICITLY STATED).\n))PRINT     - MEMBERS ARE ONLY TO BE PRINTED (NOT LISTED\n            UNLESS LIST IS EXPLICITLY STATED).\n))NOPRINT   - MEMBERS ARE NOT TO BE PRINTED (ONLY LISTED\n            UNLESS NOLIST IS EXPLICITLY STATED).\n))FOLD      - OUTPUT IS TO BE CONVERTED TO UPPER CASE\n            PRIOR TO PRINTING.\n))NOFOLD    - OUTPUT IS NOT TO BE CONVERTED TO UPPER CASE\n            PRIOR TO PRINTING.\n))VOLUME('VOLSER') - VOLUME SERIAL OF VOLUME ON WHICH DATA SETS\n            TO BE PRINTED ARE FOUND.  THIS VOLUME SERIAL\n            WILL BE USED FOR ALL DATA SETS SPECIFIED IN\n            THE DATA SET LIST.\n./ ADD NAME=Q\n)F FUNCTION -\n  THE QUEUE COMMAND IS USED TO INTERROGATE THE SYSTEM QUEUES IN ORDER\n  TO DETERMINE THE STATUS OF A JOB OR GROUP OF JOBS. IT ALSO PROVIDES\n  ACCESS TO ALL PARTS OF A JOB WHILE IT IS ON THE QUEUE.\n\n  FOR MORE INFORMATION, TYPE IN - QUEUE HELP.\n)X SYNTAX -\n         QUEUE  OPERAND\n  REQUIRED - NONE\n  DEFAULTS - STATUS\n  ALIAS    - Q\n)S SUBCOMMANDS -\n  FOR A LIST OF SUBCOMMANDS TYPE IN - QUEUE HELP.\n)O OPERANDS -\n))CKPT(UNIT,VOLSER) - SPECIFIES A JES2 CHECKPOINT DATASET OTHER THAN\n                      THE STANDARD DATASET.\n))SUBCOMMAND        - A SUBCOMMAND MAY BE ENTERED ON THE COMMAND LINE\n                      IF CKPT IS NOT SPECIFIED.\n\n./ ADD NAME=QUEUE\n)F FUNCTION -\n  THE QUEUE COMMAND IS USED TO INTERROGATE THE SYSTEM QUEUES IN ORDER\n  TO DETERMINE THE STATUS OF A JOB OR GROUP OF JOBS. IT ALSO PROVIDES\n  ACCESS TO ALL PARTS OF A JOB WHILE IT IS ON THE QUEUE.\n\n  FOR MORE INFORMATION, TYPE IN - QUEUE HELP.\n)X SYNTAX -\n         QUEUE  OPERAND\n  REQUIRED - NONE\n  DEFAULTS - STATUS\n  ALIAS    - Q\n)S SUBCOMMANDS -\n  FOR A LIST OF SUBCOMMANDS TYPE IN - QUEUE HELP.\n)O OPERANDS -\n))CKPT(UNIT,VOLSER) - SPECIFIES A JES2 CHECKPOINT DATASET OTHER THAN\n                      THE STANDARD DATASET.\n))SUBCOMMAND        - A SUBCOMMAND MAY BE ENTERED ON THE COMMAND LINE\n                      IF CKPT IS NOT SPECIFIED.\n\n./ ADD NAME=SP\n)F FUNCTION -\n  THE SPACE COMMAND PROVIDES INFORMATION ABOUT THE AMOUNT OF DIRECT\n  ACCESS SPACE OCCUPIED BY DATA SETS.  A KEYWORD PARAMETER ALLOWS\n  DIRECTORY SPACE FOR PARTITIONED DATA SETS TO BE LISTED.\n\nOUTPUT FROM THE SPACE COMMAND HAS THE FOLLOWING FORMAT:\n\nTYPE    INIT   SEC  EXT  TOTAL  UNUSED\nAAA     B-CC    D    E   B-CC     C\n\n         TYPE   -  IS THE TYPE OF ALLOCATION UNITS.\n\n                   AAA = REC IS BLOCKS OR BLKSIZE\n                       = TRK IS TRACKS\n                       = CYL IS CLYINDERS\n\n         INIT   -  IS THE AMOUNT OF PRIMARY SPACE ALLOCATED.\n\n                   B   = CYLINDERS\n                   CC  = TRACKS\n\n         SEC    -  IS THE NUMBER OF ALLOCATION UNITS (TYPE) WHICH\n                   WILL BE USED FOR SECONDARY SPACE ALLOCATED.\n\n                   D   = NUMBER OF AAA.\n\n\n         EXT    -  IS THE NUMBER OF EXTENTS A DATASET CURRENTLY HAS.\n\n                   E   = NUMBER (MAXIMUM OF 16)\n\n         TOTAL  -  IS TOTAL SPACE ALLOCATED.\n\n                   B   = CYLINDERS\n                   CC  = TRACKS\n\n         UNUSED -  IS THE AMOUNT OF SPACE NOT IN USE.\n\n                   C   = TRACKS\n\n)X SYNTAX -\n         SPACE  'DSLIST' 'DIR'\n  REQUIRED - 'DSLIST'\n  ALIAS    - SP\n)O OPERANDS -\n  'DSLIST' - SPECIFIES THE NAMES OF DATA SETS TO HAVE THEIR SPACE\n             ALLOCATIONS LISTED.\n))'DIR'    - SPECIFIES THAT TOTAL NUMBER OF DIRECTORY BLOCKS ALLOCATED\n             TO A PARTITIONED DATASET, AND THE AMOUNT OF UNUSED\n             DIRECTORY SPACE BE LISTED.\n./ ADD NAME=SPACE\n)F FUNCTION -\n  THE SPACE COMMAND PROVIDES INFORMATION ABOUT THE AMOUNT OF DIRECT\n  ACCESS SPACE OCCUPIED BY DATA SETS.  A KEYWORD PARAMETER ALLOWS\n  DIRECTORY SPACE FOR PARTITIONED DATA SETS TO BE LISTED.\n\nOUTPUT FROM THE SPACE COMMAND HAS THE FOLLOWING FORMAT:\n\nTYPE    INIT   SEC  EXT  TOTAL  UNUSED\nAAA     B-CC    D    E   B-CC     C\n\n         TYPE   -  IS THE TYPE OF ALLOCATION UNITS.\n\n                   AAA = REC IS BLOCKS OR BLKSIZE\n                       = TRK IS TRACKS\n                       = CYL IS CLYINDERS\n\n         INIT   -  IS THE AMOUNT OF PRIMARY SPACE ALLOCATED.\n\n                   B   = CYLINDERS\n                   CC  = TRACKS\n\n         SEC    -  IS THE NUMBER OF ALLOCATION UNITS (TYPE) WHICH\n                   WILL BE USED FOR SECONDARY SPACE ALLOCATED.\n\n                   D   = NUMBER OF AAA.\n\n\n         EXT    -  IS THE NUMBER OF EXTENTS A DATASET CURRENTLY HAS.\n\n                   E   = NUMBER (MAXIMUM OF 16)\n\n         TOTAL  -  IS TOTAL SPACE ALLOCATED.\n\n                   B   = CYLINDERS\n                   CC  = TRACKS\n\n         UNUSED -  IS THE AMOUNT OF SPACE NOT IN USE.\n\n                   C   = TRACKS\n\n)X SYNTAX -\n         SPACE  'DSLIST' 'DIR'\n  REQUIRED - 'DSLIST'\n  ALIAS    - SP\n)O OPERANDS -\n  'DSLIST' - SPECIFIES THE NAMES OF DATA SETS TO HAVE THEIR SPACE\n             ALLOCATIONS LISTED.\n))'DIR'    - SPECIFIES THAT TOTAL NUMBER OF DIRECTORY BLOCKS ALLOCATED\n             TO A PARTITIONED DATASET, AND THE AMOUNT OF UNUSED\n             DIRECTORY SPACE BE LISTED.\n./ ADD NAME=STATE\n)F FUNCTION -\n   THE STATE COMMAND CHECKS THE CATALOG FOR THE GIVEN DATA SET\n   AND GIVES A RETURN CODE FOR OTHER PROCESSORS TO CHECK:\n        RETURN CODE OF 0 INDICATES DATASET EXISTS\n        RETURN CODE OF 4 INDICATES DATASET DOES NOT EXISTS\n)X SYNTAX -\n         STATE DATA-SET-NAME\n     REQUIRED - DATA-SET-NAME\n     DEFAULTS - NONE\n)O OPERANDS -\n   DATA-SET-NAME - THE NAME OF THE DATA SET TO BE CHECKED\n./ ADD NAME=TAPEINQ  0100-80059-80059-2206-00066-00066-00000-$SYS13  00\n)F FUNCTION -\n  TAPEINQ  PROVIDES A METHOD OF ONLINE INQUIRY OF TAPE MANAGEMENT\n  CATALOG RECORDS.\n)X SYNTAX -\n         TAPEINQ\n)O OPERAND - NONE\n  REQUIRED - NONE\n  DEFAULTS - NONE\n\n  NOTE     - WHEN ACTIVE IT WILL ISSUE THE FOLLOWING MESSAGE:\n             IEETMS1 AWAITING REQUEST/REPLY\n\n             TO TERMINATE TAPEINQ:\n             ENTER: C\n\n             INQUIRY MAY BE ACCOMPLISHED BY ONE OF THE FOLLOWING\n             METHODS:\n             1.  SPEICFIC INQUIRY BY VOLUME SERIAL NUMBER\n                 ENTER:  VVVVVV\n                         WHERE VVVVVV IS THE VOLUME SERIAL NUMBER\n             2.  GENERAL INQUIRY BY CATALOGED DATASET NAME\n                 ENTER:  DSNAME OR DSNAME(0) OR DSNAME(-X)\n                         WHERE DSNAME IS A CATALOGED DATASET NAME\n                         OR GENERATION DATA SET NAME\n             3.  SPECIFIC INQUIRY BY VOLUME SERIAL NUMBER AND KEYWORD\n                 ENTER:  VVVVVV,KEYWORD OR KEYWORDS\n                         WHERE THE KEYWORDS ARE SORTED BY THE\n                         TMS DESCRIPTION AND MAYBE:\n\n         KEYWORDS   TMC DESCRIPTION         OUTPUT\n\n         ACCT       ACCOUNTING INFORMTION   1 TO 41 CHARACTERS\n         BLKCNT     BLOCK COUNT             1 TO 5 NUMERIC CHAR\n         BLKSIZE    BLOCK SIZE              1 TO 5 NUMERIC CHAR\n         CRTDT(C)   CREATION DATE           JUALIAN DATE (YYDDD)\n         CJOB(J)    CREATING JOBNAME        1 TO 8 CHARACTERS\n         STPNAME    CREATING STEPNAME       1 TO 8 CHARACTERS\n         CTIME      CREATION TIME           NUMERIC TIME (HHMM)\n         CUNIT      CREATION UNIT           DRIVE ADDRESS (CUU)\n         DSN(D)     DATA SET NAME           1 TO 44 CHARACTERS\n         BTHDATE    DATE FIRST USED         JULIAN DATE (YYDDD)\n         LDATE      DATE LAST USED          JULIAN DATE (YYDDD)\n         DATECLN    DATE OF LAST CLEANING   JULIAN DATE (YYDDD)\n         DEN        DENSITY                 2 HEXADECIMAL CHAR\n         EXPDT(E)   EXPIRATION DATE         JUALIAN DATE (YYDDD)\n         ISTVOL     FIRST VOLUME NUMBER     VALID VOL SERIAL #\n         LABEL      LABEL TYPE              2 CHARACTERS\n         LJOB       LAST JOB TO USE TAPE    1 TO 8 CHARACTERS\n         LUNIT      LAST UNIT USED          DRIVE ADDRESS (CUU)\n         LRECL      LOGICAL RECORD LENGTH   1 TO 5 NUMERIC CHAR\n         NEXTVOL    NEXT VOLUME NUMBER      VALID VOL SERIAL #\n         NUMDSNB    NUMBER OF DSNBS         1 TO 5 NUMERIC CHAR\n         CLNCNT     NUMBER OF TIMES CLEANED 1 TO 3 NUMERIC CHAR\n         COUNT      NUMBER OF TIMES USED    1 TO 5 NUMERIC CHAR\n         OUTCODE(0) OUT-OF-AREA CODE        1 TO 4 CHARACTERS\n         OUTDATE    OUT-OF-AREA DATE        JULIAN DATE (YYDDD)\n         PASSWRD    PASSWORD                8 CHARACTERS\n         PREVVOL    PREVIOUS VOLUME NUMBER  VALID VOL SERIAL #\n         READERR    READ ERRORS             1 NUMERIC CHARACTER\n         RECFM      RECORD FORMAT           2 HEXADECIMAL CHAR\n         TRTCH      RECORDING TECHNIQUE     2 HEXADECIMAL CHAR\n         USECLN     USE COUNT LAST CLEAN    1 TO 5 NUMERIC CHAR\n         SLOT       VAULT SLOT NUMBER       1 TO 5 NUMERIC CHAR\n         VOLSEQ(V)  VOLUME SEQUENCE NUMBER  1 TO 4 NUMERIC CHAR\n         VOLSER     VOLUME SERIAL NUMBER    VALID VOL SERIAL #\n         WRITERR    WRITE ERRORS            1 NUMERIC CHARACTER\n./ ADD NAME=VTOC\n)F FUNCTION -\n  THE VTOC COMMAND DISPLAYS SELECTED DATA SETS ON A DISK OR SET OF\n  DISKS.  EACH DISK HAS A VOLUME TABLE OF CONTENTS ( VTOC ).  THIS\n  TABLE IS SEARCHED FOR DATA SETS THAT MEET THE SPECIFICATIONS.\n)X SYNTAX -\n         VTOC     'VOLUME-LIST'           LEVEL('DSNAME-START')\n                                          CONTAINING('DSNAME-STRING')\n                                          ENDING('DSNAME-END')\n                  KBYTES/MBYTES/TRKS/CYLS\n                  NOSORT/SORT             BREAK('BREAK-CHARS')\n                  NOPRINT/PRINT('PRINT-OP' ('PRINT-ITEM-LIST')\n                  LIMIT('KEYWORD' 'OPER' 'VALUE')\n                  AND1/OR1('KEYWORD' 'OPER' 'VALUE')\n                  AND2/OR2('KEYWORD' 'OPER' 'VALUE')\n                  AND3/OR3('KEYWORD' 'OPER' 'VALUE')\n                  CHARS('CHARS-PER-LINE')\n                  LINES('LINES-PER-PAGE')\n                  NOHEADING/HEADING('TEXT')\n                  DSNLEN('LENGTH')\n  NOTE     - THERE ARE SOME OTHER OPERANDS THAT WILL BE DOCUMENTED\n             WHEN THEY ARE WORKING.\n  REQUIRED - 'VOLUME-LIST'\n  DEFAULTS - LIST ALL DATA SETS ON THE VOLUME(S) SELECTED.\n             TRKS, SORT, PRINT\n  ALIAS    - NONE\n)O OPERANDS -\n))'VOLUME-LIST'     - A VOLUME SERIAL NUMBER OR A LIST OF VOLUMES.\n              IF THE FIRST ONE TO FIVE CHARACTERS OF A VOLUME\n              SERIAL NUMBER ARE ENTERED, ALL VOLUMES THAT ARE\n              MOUNTED ON THE MACHINE WHICH START WITH THOSE\n              CHARACTERS WILL BE LISTED.\n))LEVEL('DSNAME-START')  - SPECIFIES THE HIGH LEVEL QUALIFIERS TO BE\n         SEARCHED.  THIS WILL NOT BE PREFIXED BY YOUR USERID OR\n         PREFIX.  ONLY DATA SETS STARTING WITH THESE PREFIXES WILL\n         BE LISTED.\n))CONTAINING('DSNAME-STRING') - SPECIFIES A CHARACTER STRING CONTAINED\n         IN THE DATA SET NAME.  AT LEAST ONE OF THE STRINGS MUST\n         BE IN THE DSNAME FOR THE DATA SET TO BE LISTED.\n         THESE STRINGS MUST CONFORM TO DSNAME STANDARDS.\n         THEY CANNOT BEGIN WITH A PERIOD OR A NUMBER.\n))ENDING('DSNAME-END')  - SPECIFIES THE ENDING CHARACTERS OF THE\n         DSNAME.  THE FINAL NONBLANK CHARACTERS OF THE DSNAME MUST\n         BE ONE OF THESE STRINGS TO ALLOW THE DATA SET TO BE LISTED.\n         THESE STRINGS MUST CONFORM TO DSNAME STANDARDS.\n))KBYTES   -  SPACE ITEMS ARE LISTED IN KILOBYTES ( 1000 BYTES ).\n))MBYTES   -  SPACE ITEMS ARE LISTED IN MEGABYTES ( 1,000,000 BYTES ).\n))TRKS     -  SPACE ITEMS ARE LISTED IN TRACKS FOR THE DEVICE(S).\n))CYLS     -  SPACE ITEMS ARE LISTED IN CYLINDERS FOR THE DEVICE(S).\n))NOSORT   -  THE DATA SETS ARE NOT SORTED.  THEY ARE OUTPUT AS THEY\n              ARE FOUND.\n))SORT     -  THE DATA SETS ARE SORTED INTO ALPHABETICAL ORDER, BASED\n              UPON THE DSNAME.\n))BREAK('BREAK-CHARS') - THE LISTING WILL CONTAIN A NEW HEADER,\n              ( ON A NEW PAGE IF THE VTOCOUT DD CARD OPTION IS USED ),\n              WHENEVER THE SPECIFIED NUMBER OF CHARACTERS DIFFERS\n              FROM THE PRECEDING DATA SET.  THIS OPTION FUNCTIONS\n              ONLY WITH THE SORT OPTION.\n))CHARS('CHARS-PER-LINE') - SPECIFIES THE NUMBER OF CHARACTERS ON EACH\n              LINE OF OUTPUT.  THE DEFAULT IS 150 FOR PRINT AND THE\n              LINESIZE OF THE TERMINAL FOR TSO SESSIONS.\n              YOU CAN GET MORE INFORMATION BY SPECIFYING A LARGER\n              NUMBER OF CHARACTERS PER LINE OR YOU CAN LIMIT THE\n              PRINTING BY SETTING A SMALLER NUMBER OF CHARACTERS\n              PER LINE OF OUTPUT.\n))LINES('LINES-PER-PAGE') - SPECIFIES THE NUMBER OF LINES BEFORE A NEW\n              TITLE LINE IS PRODUCED.  IT DEFAULTS TO 60 FOR PRINT\n              AND TO THE SCREEN SIZE FOR TSO SESSIONS.\n))NOHEADING   - DO NOT PRODUCE A HEADING.  THE HEADING WILL ONLY BE\n              OUTPUT IF THE VTOCOUT DD STATEMENT IS PRESENT.\n))HEADING('TEXT') - IF A DD STATEMENT WITH A DDNAME OF VTOCOUT IS\n              PRESENT, THIS TEXT WILL BE USED TO BEGIN EVERY PAGE.\n              CARRIAGE CONTROL SHOULD BE INCLUDED ( ASA ).  THE\n              DEFAULT HEADER CONSISTS OF VTOC COMMAND VERSION 02\n              AND THE COMMAND THAT WAS ENTERED.\n))DSNLEN('LENGTH') - SPECIFIES THE LENGTH OF THE DSNAME TO PRINT.\n              THE REST OF THE DSNAME IS TRUNCATED.  THE CHARS PARAMETER\n              WILL ALSO CAUSE THE DSNAME TO BE TRUNCATED, IF THE NAME\n              AND THE PRECEDING INFORMATION EXCEEDS THE PRINT LINE.\n))NOPRINT     - SPECIFIES THAT INDIVIDUAL ITEMS ARE NOT TO BE LISTED.\n              THE COMMAND CAN BE USED TO CALCULATE TOTALS.\n))PRINT('PRINT-OP' ('PRINT-ITEM-LIST')) -\n              SPECIFIES THE ITEMS TO PRINT.  THE 'PRINT-OP' IS THE\n              OPERATION TO BE DONE.  THEY INCLUDE THE FOLLOWING.\n                NEW - THE 'PRINT-ITEM-LIST' IS A COMPLETE LIST OF WHAT\n                      TO PRINT.\n                REP - THE FIRST 'PRINT-ITEM' WILL BE REPLACED WITH THE\n                      REST OF THE ITEMS ON THE LIST.\n                ADD - THE REST OF THE 'PRINT-ITEM-LIST' WILL BE ADDED\n                      AFTER THE FIRST ITEM ON THE LIST.\n                DEL - THE ITEMS ON THE 'PRINT-ITEM-LIST' WILL NOT BE\n                      PRINTED.\n              THE 'PRINT-ITEM-LIST' NAMES ARE THE SAME KEYWORDS USED\n              IN LIM, AND, AND OR FUNCTIONS AND ARE ALSO THE TITLES\n              AS PRINTED.\n              THE ADD, DEL, AND REP PRINT OPERATIONS REFER TO THE\n              DEFAULT PRINT LIST.  THE DEFAULT LIST IS ALLOC, UNUSED,\n              PCT, EXT, DSORG, RECFM, BLKSZ, LRECL, CDATE, LSTUS,\n              DSNAME, VOLUME, SECQ, SECT, ROUND, PASS, ACTION,\n              AND TYPE.  AS NOTED UNDER CHARS ABOVE, ONLY THE ITEMS\n              THAT WILL FIT ON THE PRINT LINE WILL BE LISTED.\n))LIMIT('VALUE' 'OPER' 'KEYWORD') - SPECIFIES WHICH DATA SETS ARE TO\n              BE LISTED.  ONLY DATA SETS THAT SATISFY THE RELATION\n              ARE LISTED.\n))'KEYWORD'   - IS THE NAME OF A DATA SET FIELD.  THE LIST OF CURRENTLY\n                PROVIDED FIELDS FOLLOWS.  THE KEYWORDS AND THEIR VALUES\n                ARE THE SAME AS IN THE VTOC OUTPUT.\n\n                      ALLOC      DATA SET ALLOCATION\n                                    NUMBER OF KILOBYTES, TRACKS,\n                                    CYLINDERS, OR MEGABYTES ALLOCATED.\n                                    DEFAULT IS TRKS.\n                      UNUSED     AMOUNT OF UNUSED SPACE IN THE DATA\n                                    SET.  SAME UNITS AS IN ALLOC.\n                      USED       AMOUNT OF SPACE USED IN THE DATA SET.\n                                    SAME UNITS AS IN ALLOC.\n                      PCT        PERCENTAGE OF SPACE USED IN THE DATA\n                                    USED.\n                      EXT        NUMBER OF EXTENTS IN THE DATA SET.\n                      DSORG      DATA SET ORGANIZATION\n                                    PS = SEQUENTIAL   PO = PARTITIONED\n                                    VS = VSAM         IS = ISAM\n                                    DA = DIRECT ACCESS  U = UNMOVEABLE\n                      RECFM      RECORD FORMAT\n                                    F  = FIXED        V  = VARIABLE\n                                    U  = UNDEFINED    B  = BLOCKED\n                                    T  = TRACK OVERFLOW\n                                    S  = SPANNED OR STANDARD\n                                    A  = ASA CARRIAGE CONTROL\n                                    M  = MACHINE CARRIAGE CONTROL\n                      BLKSZ      BLOCKSIZE FOR PHYSICAL BLOCKS OF\n                                    DATA.\n                      LRECL      LOGICAL RECORD LENGTH IN BYTES.\n                      CDATE      CREATION DATE IN THE FORM YYDDD,\n                                    SOMETIMES CALLED JULIAN.\n                      EXPDT      EXPIRATION DATE IN THE SAME FORM.\n                                    THIS FIELD IS RARELY USED HERE.\n                      LSTUS      LAST USE DATE IN THE SAME FORM.\n                                    THIS DATE IS WHEN THE DATA SET WAS\n                                    LAST OPENED.\n                      SECT       TYPE OF ALLOCATION\n                                    A  = ABSOLUTE TRACK\n                                    B  = BLOCKS\n                                    T  = TRACKS\n                                    C  = CYLINDERS\n                      PASS       PROTECTION INDICATORS\n                                    N  = NONE\n                                    R  = READ AND WRITE PROTECTION\n                                    W  = WRITE PROTECTION\n                      ROUND      SPACE ROUNDED UP TO CYLINDERS\n                                    R  = ROUND\n                                    N  = NO ROUND\n                      CCHH       CYLINDER AND HEAD ADDRESS, IN 4 OR 8\n                                    HEXADECIMAL DIGITS.  IF 4 DIGITS\n                                    ARE USED, ONLY THE CYLINDER IS USED\n                                    FOR COMPARISON, OTHERWISE, THE CYL\n                                    AND TRACK ARE COMPARED.\n                      VOLUME     VOLUME SERIAL NUMBER OR DISK NAME\n                      DSNAME     NAME OF THE DATA SET\n                      ACTION     SOME ERROR INDICATIONS\n                      TYPE       RESERVED FOR EXIT USAGE.\n))'OPER'      - IS AN OPERATOR.  THE LIST OF OPERATORS FOLLOWS.\n                        EQ       IS EQUAL TO\n                        NE       IS NOT EQUAL TO\n                        LE       IS LESS THAN OR EQUAL TO\n                        LT       IS LESS THAN\n                        GE       IS GREATER THAN OR EQUAL TO\n                        GT       IS GREATER THAN\n))'VALUE'     - GIVES THE VALUE OF THE ITEM FOR COMPARISON, SUCH AS\n              FB, PS, R, OR A NUMBER.\n))AND1('VALUE' 'OPER' 'KEYWORD') -  SPECIFIES WHICH DATA SETS ARE TO\n                 BE LISTED.  BOTH THE LIMIT AND THIS CONDITION MUST\n                 BE TRUE TO ALLOW THE LISTING.\n))OR1('VALUE' 'OPER' 'KEYWORD') -   SPECIFIES WHICH DATA SETS ARE TO\n                 BE LISTED.  EITHER THE LIMIT OR THIS CONDITION MUST\n                 BE TRUE TO ALLOW THE LISTING.\n))AND2('VALUE' 'OPER' 'KEYWORD') -  SPECIFIES WHICH DATA SETS ARE TO\n                 BE LISTED.  BOTH THE PREVIOS RESULT AND THIS\n                 CONDITION MUST BE TRUE TO ALLOW THE LISTING.\n))OR2('VALUE' 'OPER' 'KEYWORD') -   SPECIFIES WHICH DATA SETS ARE TO\n                 BE LISTED.  EITHER THE PREVIOUS RESULT OR THIS\n                 CONDITION MUST BE TRUE TO ALLOW THE LISTING.\n))AND3('VALUE' 'OPER' 'KEYWORD') -  SPECIFIES WHICH DATA SETS ARE TO\n                 BE LISTED.  BOTH THE PREVIOS RESULT AND THIS\n                 CONDITION MUST BE TRUE TO ALLOW THE LISTING.\n))OR3('VALUE' 'OPER' 'KEYWORD') -   SPECIFIES WHICH DATA SETS ARE TO\n                 BE LISTED.  EITHER THE PREVIOUS RESULT OR THIS\n                 CONDITION MUST BE TRUE TO ALLOW THE LISTING.\n))EXAMPLES -\n  LIST ALL DATA SETS ON DATA51          VTOC DATA51\n  LIST ALL DATA SETS THAT START\n     WITH  XXX   ON ANY DATA VOLUME     VTOC DATA LEV(XXX)\n  LIST ALL RECENTLY CREATED DATA SETS   VTOC DATA51 LIM(CDATE GT 78004)\n  LIST DATA SETS WITH UNUSED SPACE      VTOC VOL LIM(PCT LT 50)  -\n                                                OR1(UNUSED GT 30)\n  LIST DATA SETS WITH MULTIPLE EXTENTS  VTOC VOL LIM(EXT GT 1)\n  LIST ALL OF USER'S DATA ON TSO AND\n       SWYLBUR VOLUMES        VTOC (DATA5B DATA5C DATA5D) LEV(USER)\n       THIS LIST CAN BE USED\n       TO COMPARE TO THE CATALOG LISTING ( LISTC OR LISTS ).\n  LIST ALL DATA SETS OVER 100 TRKS      VTOC VOL LIM(ALLOC GT 100) TRK\n  LIST DATA SETS UNDER THE FIXED HEADS  VTOC VOL LIM(CC EQ 0001) -\n                                                 OR1(CC EQ 0002)\n  LIST USED SPACE INSTEAD OF UNUSED,\n       IN TRACKS.                VTOC VOL PRINT(REP (UNUSED USED)) TRK\n  LIST CLIST DATA SETS           VTOC VOL END(CLIST)\n  LIST ALL OF THE INFORMATION ABOUT\n       USER'S DATA SETS AT A 3270.   VTOC VOL CHAR(150)\n  SHORTEN THE DSNAME LENGTH ON A\n       LISTING                   VTOC VOL DSNLEN(20)\n//MACROS  EXEC  UPDT,NAME=MACROS,SPC=50\n//SYSIN    DD   *\n./ ADD NAME=WH\n)F FUNCTION -\n  THE WHOHAS COMMAND SHOWS WHO HAS A PARTICULAR DATA SET BY EXAMINING\n  THE QCB CHAIN.  EXCLUSIVE OR SHARED ENQ IS LISTED ALONG WITH\n  JOB- FOR JOBS, TSO- FOR TSO USERS OR STC- FOR STARTED TASKS.\n  THE MESSAGE - DATASET NOT IN USE - APPEARS IF NO JOB, TSO USER OR\n  STARTED TASK HAS ALLOCATED THE DATA SET.\n)X SYNTAX -\n         WHOHAS 'DATASET'\n  REQUIRED - 'DATASET'\n  DEFAULTS - NONE\n  ALIAS    - WH\n)O OPERANDS -\n  'DATASET' - SPECIFIES THE DATA SET NAME.\n./ ADD NAME=WHOHAS   0100-79157-79157-1821-00013-00013-00000-$SYS15  00\n)F FUNCTION -\n  THE WHOHAS COMMAND SHOWS WHO HAS A PARTICULAR DATA SET BY EXAMINING\n  THE QCB CHAIN.  EXCLUSIVE OR SHARED ENQ IS LISTED ALONG WITH\n  JOB- FOR JOBS, TSO- FOR TSO USERS OR STC- FOR STARTED TASKS.\n  THE MESSAGE - DATASET NOT IN USE - APPEARS IF NO JOB, TSO USER OR\n  STARTED TASK HAS ALLOCATED THE DATA SET.\n)X SYNTAX -\n         WHOHAS 'DATASET'\n  REQUIRED - 'DATASET'\n  DEFAULTS - NONE\n  ALIAS    - WH\n)O OPERANDS -\n  'DATASET' - SPECIFIES THE DATA SET NAME.\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "WYLBCMS": {"ttr": 54787, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00X\\x01\\x19#\\x0f\\x01\\x19#\\x0f\\x134\\x0b\\xa8\\x0b\\xa8\\x00\\x00\\xc7\\xe9\\xc9\\xd7\\xc1\\xe6\\xe2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2019-08-18T00:00:00", "modifydate": "2019-08-18T13:34:58", "lines": 2984, "newlines": 2984, "modlines": 0, "user": "GZIPAWS"}, "mimetype": "application/gzip", "datatype": "binary", "extension": ".gz"}, "WYLBTSO": {"ttr": 55818, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00X\\x01\\x19#\\x0f\\x01\\x19#\\x0f\\x134U\\xa8U\\xa8\\x00\\x00\\xc7\\xe9\\xc9\\xd7\\xc1\\xe6\\xe2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2019-08-18T00:00:00", "modifydate": "2019-08-18T13:34:58", "lines": 21928, "newlines": 21928, "modlines": 0, "user": "GZIPAWS"}, "mimetype": "application/gzip", "datatype": "binary", "extension": ".gz"}, "WYLMENUS": {"ttr": 64777, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x005\\x01\\x19#\\x0f\\x01\\x19#\\x0f\\x14F\\x07\\xe4\\x07\\xe4\\x00\\x00\\xe7\\xd4\\xc9\\xe3@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2019-08-18T00:00:00", "modifydate": "2019-08-18T14:46:35", "lines": 2020, "newlines": 2020, "modlines": 0, "user": "XMIT"}, "mimetype": "application/xmit", "datatype": "binary", "extension": ".xmi"}, "WYLMSGS": {"ttr": 65793, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x005\\x01\\x19#\\x0f\\x01\\x19#\\x0f\\x14F\\x003\\x003\\x00\\x00\\xe7\\xd4\\xc9\\xe3@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2019-08-18T00:00:00", "modifydate": "2019-08-18T14:46:35", "lines": 51, "newlines": 51, "modlines": 0, "user": "XMIT"}, "mimetype": "application/xmit", "datatype": "binary", "extension": ".xmi"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT995/FILE995.XMI", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT995", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}